{"ver":"0.1","info":{"id":"Wdlfzn","date":"1587610035","viewed":49,"name":"Alex Goodisman - Noise","username":"agoodisman","description":"The plane is mapped using worley noise, the sphere is mapped using fbm, and the cube is mapped using perlin noise. The noise is color mapped using a cosine palette.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["hw9"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int RAY_STEPS = 256;\n\n#define GI 1\n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n    \nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvec3 rotateX(vec3 p, float amt) {\n    return vec3(p.x, cos(amt) * p.y - sin(amt) * p.z, sin(p.y) + cos(p.z));\n}\n\nvec3 rotateZ(vec3 p, float amt) {\n    \n    return vec3(cos(amt)* p.x - sin(amt)*p.y, cos(amt) * p.y + sin(amt) * p.x, p.z);\n}\n\n\nvoid raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref) {\n    eye = vec3(0.0, 5.5, -20.0);\n    ref = vec3(0.0, 2.5, 0.0);\n    \n    float len = tan(3.14159 * 0.125) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n}\n\nfloat sphere(vec3 p, float r, vec3 c)\n{\n    return distance(p, c) - r;\n}\n\nfloat torus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q) - t.y;\n}\n\nfloat cone(vec3 p, vec2 c)\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n// Box with side lengths b\nfloat box(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\nfloat plane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj, vec3 lightPos)\n{\n    t = plane(pos+vec3(0.0,2.5,0.0), vec4(0.0,1.0,0.0,0.0));\n    obj = 0; // 0 is center sphere\n    float t2;\n    if((t2 = sphere(rotateY(pos+vec3(-4, 1, -0.75),-0.3054), 4.0, vec3(0.0,0.0,0.0))) < t) {\n        t = t2;\n        obj = 1;\n    }\n    float t3;\n    if((t3 = box(rotateY(pos+vec3(4,0,-3), 0.480), vec3(3,3,3))) < t) {\n        t = t3;\n        obj = 2;\n    }\n}\n\nfloat sceneMap3D(vec3 pos, vec3 lightPos)\n{\n    float t;\n    int obj;\n    sceneMap3D(pos, t, obj, lightPos);\n    return t;\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj, vec3 lightPos)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj, lightPos);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nvec3 computeNormal(vec3 pos, vec3 lightPos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx, lightPos) - sceneMap3D(pos - epsilon.yxx, lightPos),\n                            sceneMap3D(pos + epsilon.xyx, lightPos) - sceneMap3D(pos - epsilon.xyx, lightPos),\n                            sceneMap3D(pos + epsilon.xxy, lightPos) - sceneMap3D(pos - epsilon.xxy, lightPos)));\n}\n\nfloat random1( vec2 p) {\n\treturn fract(sin(dot(p,vec2(695.8,351.2))) * 1352.9418 * iTime / 10000.0);\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)),\n                 dot(p, vec2(269.5,183.3))))\n                 * 43758.5453 * iTime / 10000.0);\n}\n\nfloat random3( vec3 p) {\n    return fract(sin(dot(p,vec3(269.7, 532.4, 986.2))) * 1489.63 * iTime / 10000.0);\n}\n\n\n\n\nfloat worley(vec2 uv)\n{\n    vec2 corner = floor(uv);\n    vec2 toPoint = fract(uv);\n    float minDist = 1.0;\n    for(int y = -1; y <= 1; ++y) {\n        for(int x = -1; x <= 1; ++x) {\n            vec2 toNeighbor = vec2(float(x), float(y)); \n            vec2 neighbor = corner + toNeighbor;\n            vec2 toCenterpoint = random2(neighbor); \n            float dist = length(toNeighbor + toCenterpoint - toPoint);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n\n}\n\nfloat interpRandom2D(vec2 p) {\n\tint x = int(floor(p.x));\n    float tx = fract(p.x);\n    int y = int(floor(p.y));\n    float ty = fract(p.y);\n\n    float n00 = random1(vec2(x, y));\n    float n10 = random1(vec2(x + 1, y));\n    float n01 = random1(vec2(x, y + 1));\n    float n11 = random1(vec2(x + 1, y + 1));\n\n    float n0 = mix(n00, n10, tx);\n    float n1 = mix(n01, n11, tx);\n    return mix(n0, n1, ty);\n\n}\n\nfloat fbm(vec2 uv)\n{\n    float fbm = 0.0;\n    for(int i = 1; i <= 4; i++) \n    {    \n        float frequency = pow(2.0, float(i));\n        fbm += interpRandom2D(frequency * uv) * pow(0.5, float(i));\n    }\n    return fbm;\n\n}\n\nfloat surflet(vec3 p, vec3 gridPoint) {\n    \n    vec3 diff = p - gridPoint;\n    vec3 t = abs(diff);\n    //smooth\n    vec3 s = vec3(1.0) - 6.f * pow(t, vec3(5.0)) + 15.0 * pow(t, vec3(4.0)) - 10.0 * pow(t, vec3(3.0));\n\n    vec3 gradient = random3(gridPoint) * 2.0 - vec3(1,1,1);\n\n    float height = dot(diff, gradient);\n\n    return height * s.x * s.y * s.z;\n}\n\n\nfloat perlin(vec3 uvw)\n{\n    float sum = 0.0;\n\tfor(int dx = 0; dx <= 1; dx++)\n    {\n\t\tfor(int dy = 0; dy <= 1; dy++)\n        {\n            for(int dz = 0; dz <= 1; dz++)\n            {\n\t\t\tsum += surflet(uvw, floor(uvw) + vec3(dx, dy, dz));\n            }\n\t\t}\n\t}\n\treturn sum;\n}\n\n\nvec3 palette(float t, vec3 d)\n{\n    vec3 a = vec3(0.5);\n    vec3 b = vec3(0.5);\n    vec3 c = vec3(1.0);\n    \n    return a + b * cos(2.0 * 3.14159 * (t*c+d));\n}\n\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 light, vec3 view) {\n    float t;\n    switch(hitObj) {\n        case 0:\n        // floor plane\n        float noise =  worley(vec2(p.x,p.z));\n        return palette(noise, vec3(0.63, 0.065, 0.05));\n        break;\n        case 1:\n        // Green wall\n        vec3 d = normalize(vec3(4, -1, 0.75) - p);\n        float u2 = 0.5 + atan(d.z,d.x) / (2.0 * 3.14159);\n        float v2 = 0.5 - asin(d.y) / 3.14159;\n        float noise2 = fbm(vec2(u2,v2));\n        return palette(noise2, vec3(0.14, 0.75, 0.091));\n        break;\n        \n        case 2:\n        // box\n        vec3 boxCoords = rotateY(p+vec3(4,0,-3), 0.480); //side length 1.5 centered at origin\n        //need to adjust to 0,0,0 .. 1,1,1\n        float noise3 = perlin((boxCoords + vec3(1.5,1.5,1.5)) / 3.0);\n        return palette(noise3, vec3(0.85, 0.81, 0.78));\n        break;\n        \n        case -1:\n        // Background\n        return vec3(0.0);\n        break;\n    }\n    return vec3(1.0);\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye, vec3 lightPos)\n{\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj, lightPos);\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect, lightPos);\n    vec3 lightDir = normalize(lightPos - isect);\n    \n    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect));\n    \n    return Intersection(t, surfaceColor, isect, hitObj);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 lightPos = vec3(0.0, 7.45, 0.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // [-1, 1]\n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n    \n    Intersection aaIsects[4];\n    vec3 dir, eye, ref;\n    int idx = 0;\n    for(float i = 0.0; i < 1.0; i += 0.5) {\n        for(float j = 0.0; j < 1.0; j += 0.5) {\n            raycast(uv2 + vec2(i, j) / iResolution.xy, dir, eye, ref);\n            aaIsects[idx++] = sdf3D(dir, eye, lightPos);\n        }\n    }\n    vec3 avgColor = vec3(0.0);\n    for(int i = 0; i < 4; ++i) {\n        avgColor += aaIsects[i].color;\n    }\n    avgColor *= 0.25;\n    fragColor = vec4(avgColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}