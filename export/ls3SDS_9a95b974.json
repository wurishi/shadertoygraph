{"ver":"0.1","info":{"id":"ls3SDS","date":"1461170144","viewed":270,"name":"Nexus 7 stripped Ball","username":"LaBodilsen","description":"A Nexus 7 effect.\nmy first try at shader code, and first raymarching experiment.  \ninspired by Blueberry's revision 2016 live shader effort. \nthanks to Dila, for the youtube tutorial that got me startet on this path\n\nsorry for any newbie errors.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","amiga","ball","bounce","nexus7"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float map (vec3 p){\n\n\tfloat ax = iTime*0.6;\n\tfloat ay = iTime*1.5;\n\tfloat az = -iTime*.8;\n\n    float div = iResolution.y*(.7/iResolution.y);\n    p.y += .8-abs(sin(iTime*2.5)*1.5);\n\tp.x +=  -div+(abs(mod(iTime*1.2,div*4.)-div*2.));\n    p.xy *= mat2(cos(az),-sin(az),sin(az),cos(az));\n    p.zy *= mat2(cos(ax),-sin(ax),sin(ax),cos(ax));\n    p.zx *= mat2(cos(ay),-sin(ay),sin(ay),cos(ay));\n    \n    float sphere1 = length(p)-.75;\n    float sphere2 = length(p)-.74;\n\n    float cube1 = length(max(abs(p-vec3(0.0,0.0,-.6))-vec3(.8,.8,.06),0.0))-.01;\n    float cube2 = length(max(abs(p-vec3(0.0,0.0,-.3))-vec3(.8,.8,.06),0.0))-.01;\n    float cube3 = length(max(abs(p)-vec3(.8,.8,.06),0.0))-.01;\n    float cube4 = length(max(abs(p-vec3(0.0,0.0,.3))-vec3(.8,.8,.06),0.0))-.01;\n    float cube5 = length(max(abs(p-vec3(0.0,0.0,.6))-vec3(.8,.8,.06),0.0))-.01;\n    float cube = min(min(min(cube1,cube2),min(cube3,cube4)),cube5);\n    \n    return max(-cube,max(sphere1,-sphere2));\n}\n\nvec3 get_normal( in vec3 p ) // by iq\n{ \n    vec2 e = vec2(0.001, -0.001);\n    return normalize(\n        e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) +\n        e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    //Init\n    fragColor = vec4(0.0);\n\n    //Draw Background\n    vec3 blue=vec3(0.0,0.,.5-length(uv)/8.);\n    vec3 red=vec3(0.2,0.,0.0);\n\n    float radius=0.47;\n    float arms=10.;\n   \n    vec3 fc=red;\n\t//Draw Arms\n    if(cos(atan(uv.y,uv.x)*arms+(texture(iChannel0,uv).r*1.5)+sin(length(uv*20.))/1.5)<-.8\n       || length(uv)<radius+texture(iChannel0,uv).r*0.2){\n        fc=blue;}\n\n    //Draw Center\n    if(length(uv)<radius+texture(iChannel0,uv).r*0.2-.15)\n        fc=red;\n\n    //Raymarch and draw Sphere object\n    float move = iTime;\n    vec3 origin = vec3(0.0,0.0,-1.9);\n    vec3 ray_dir = normalize(vec3(uv,2.0));\n    vec3 light = vec3(3.,2.0,-4.0);\n    \n    \n    float t= 0.0;\n\tfloat color = 0.0;\n    vec3 point = vec3(0.0);\n    for (int iterations = 0;iterations<80;iterations++){\n        point = origin + ray_dir * t;\n        float distance_point = map(point);\n        if (distance_point < 0.0001 || distance_point > 15.){\n\t\t\tt = min(distance_point, 15.);\n            if (t < 15.) {\n            vec3 point_normal = get_normal(point);\n\t\t\tvec3 light_dir = normalize(light-point);\n    \t\tcolor = (max(-0.1, dot(light_dir, point_normal))+.1);\n    \t\tfc = vec3(color+.1,color-.1,color-0.3);\n                break;}\n        }\n        t += distance_point;\n    }\n    \n    fragColor = vec4(fc,1.0);\n}","name":"Image","description":"","type":"image"}]}