{"ver":"0.1","info":{"id":"dtcSWB","date":"1685823243","viewed":169,"name":"Icy Pyramids","username":"fungi","description":"trying to draw with shaders :)","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["winter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                    https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83                        //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                               //\n                                                                                                               //\n            float rand(vec2 n) {                                                                               //\n\t            return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);                                 //\n            }                                                                                                  //\n                                                                                                               //\n            float noise(vec2 p){                                                                               //\n\t            vec2 ip = floor(p);                                                                            //\n\t            vec2 u = fract(p);                                                                             //\n\t            u = u*u*(3.0-2.0*u);                                                                           //\n            \t                                                                                               //\n\t            float res = mix(                                                                               //\n\t\t            mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),                                                  //\n\t\t            mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);                               //\n\t            return res*res;                                                                                //\n            }                                                                                                  //\n                                                                                                               //\n                                                                                                               //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n// my own code below :)\n\n#define STAR_GRID_SIZE     100.0\n#define MOON_POS           vec2(0.23, 0.71)\n#define MOON_SIZE          0.15\n#define EARTH_SHADOW_POS   vec2(0.3, 0.7)\n#define EARTH_SHADOW_SIZE  0.13\n#define SUN_DIR            normalize(vec3(-1.0, 0.0, 2.0))\n#define STAR_SIZE          0.03\n#define WATER_LEVEL        0.4\n#define SNOW_SPEED         0.1\n#define SNOW_PROBABILITY   0.2\n\n#define AA                 1\n\n\nvoid star_impl(vec2 uv, inout float color, float grid_size, float star_size) {\n    uv *= grid_size;\n    \n    vec2 grid     = floor(uv);\n    vec2 grid_pos = fract(uv);\n    vec2 star_pos = abs(vec2(noise(grid * 100.0), noise(133.7 * grid + vec2(100.0))));\n    \n    float border = 1.0 / star_size;\n    star_pos = mix(vec2(border), vec2(1.0 - border), star_pos);\n        \n    color = max(color, 1.0 - length(grid_pos - star_pos) * star_size);\n}\n\nvoid stars(vec2 uv, inout float color) {\n    star_impl(uv, color, STAR_GRID_SIZE, 1.0 / STAR_SIZE);\n}\n\nvoid moon(vec2 uv, inout float color) {\n    vec2 screen_surface_pos = (uv - MOON_POS) / MOON_SIZE;\n    \n    if (length(screen_surface_pos) > 1.0)\n        return;\n        \n    vec3 surface_pos = vec3(screen_surface_pos, sqrt(1.0 - dot(screen_surface_pos, screen_surface_pos)));\n    \n    float lighting = dot(SUN_DIR, surface_pos);\n    float nalbedo = 0.0;\n    \n    star_impl(0.01 * uv, nalbedo, 100.0, 10.0);\n    \n    nalbedo *= 0.5;\n    \n    star_impl(uv,        nalbedo, 2.0, 10.0);\n    star_impl(uv + 15.0, nalbedo, 2.0, 10.0);\n    star_impl(uv + 55.0, nalbedo, 3.5, 7.0);\n    star_impl(uv - 30.0, nalbedo, 4.5, 6.0);\n    star_impl(uv - 40.0, nalbedo, 9.9, 9.0);\n    star_impl(uv - 60.0, nalbedo, 2.0, 10.0);\n    \n    nalbedo = pow(nalbedo, 0.2);\n    \n    float albedo = mix(1.0, 0.7, nalbedo) + 0.0666 * noise(uv * 666.6);\n    \n    albedo *= pow(clamp(length(uv - EARTH_SHADOW_POS) / EARTH_SHADOW_SIZE, 0.0, 1.0), 75.0);\n    \n    // smooth border (not pixel perfect)\n    albedo *= pow(clamp(0.99-length(screen_surface_pos), 0.0, 1.0), 0.15);\n        \n    color = lighting * clamp(albedo, 0.0, 1.0);\n}\n\nfloat ground_pat0(vec2 uv) {\n    float p = uv.x - uv.y;\n    p += 0.01*noise(vec2(100.0 * uv.y, 10.0 * uv.x));\n    return p;\n}\n\nfloat ground_pat1(vec2 uv) {\n    float p = ground_pat0(uv);\n    p = noise(vec2(0.0, 1000.0 * p));\n    p = clamp(p, 0.0, 1.0);\n    return mix(0.6, 0.7, p);\n}\n\nvoid mountain(vec2 uv, inout float color) {    \n    int peak_len = 3;\n    vec3[] peaks = vec3[](\n        vec3(0.19, 0.69, 0.96),\n        vec3(0.50, 0.75, 1.0),\n        vec3(0.72, 0.64, 1.05)\n    );\n        \n    float p = ground_pat0(uv);\n        \n    for (int i = 0; i < peak_len; i++) {\n        vec3 peak = peaks[i];\n        float angle = atan(peak.y - uv.y, peak.x - p);\n        float pat = ground_pat1(uv + peak.xy);\n    \n        if (angle < 1.4 || angle > 2.6 || uv.y < 0.4) continue;\n    \n        if (angle > 2.1) pat *= 0.1;\n        pat *= peak.z;\n        color = pat;\n    }\n}\n\nvoid snowy_plains(vec2 uv, inout float color) {\n    if (uv.y < WATER_LEVEL) return;\n    \n    vec2 s = uv.xx * 4.0;\n    float h =\n        0.500 * noise(s       + vec2(100.0, 0.0))\n      + 0.250 * noise(s * 2.0 + vec2(200.0, 0.0))\n      + 0.125 * noise(s * 4.0 + vec2(300.0, 0.0));\n      \n    if (uv.y - WATER_LEVEL < h * 0.05 + 0.03) {\n        color = mix(0.74, 0.79, noise(uv * 1000.0));\n    }\n}\n\nvoid trees(vec2 uv, inout float color) {    \n    return; // disabled\n\n    // uv in range vec2(-1, 0) vec2(1, 1)\n    uv = vec2(2.0*fract(uv.x * 5.0) - 1.0, (uv.y-WATER_LEVEL) * 5.0);\n    \n    if (uv.y < 0.0 || uv.y > 1.0) return;\n    \n    // stem\n    if (abs(uv.x) < 0.1 && uv.y < 0.5)\n        color = 0.0;\n        \n    // leaves\n    if (1.0-abs(uv.x) > uv.y && uv.y > 0.222)\n        color = 1.0;\n    \n    \n}\n\nvoid particles(vec2 uv, inout float color, float time) {\n    return; // disabled\n    uv.y += iTime * SNOW_SPEED;\n    uv *= 10.0;\n    \n    if (noise(floor(uv)) > SNOW_PROBABILITY) return;\n\n    vec2 uv1 = fract(uv);\n    uv1 = abs(vec2(0.5) - uv1);    \n    \n    if (uv1.x < 0.1 && uv1.y < 0.1) {\n        float snow_col = 1.0;\n        float snow_alpha = 0.1;\n        color = mix(color, snow_col, snow_alpha);\n    }\n}\n\nvoid mist(vec2 uv, inout float color) {\n    color += 0.1 * clamp(8.0 * (0.6 - uv.y), 0.0, 1.0);\n}\n\nvoid layer0(vec2 uv, inout float col) {\n    stars(uv, col);\n    moon (uv, col);\n}\n\nvoid layer1(vec2 uv, inout float col) {\n    mountain(uv, col);\n    snowy_plains(uv, col);\n    trees(uv, col);\n    mist(uv, col);\n}\n\nvoid layers(vec2 uv, inout float col) {\n    layer0(uv, col);\n    layer1(uv, col);\n}\n\nbool lake(vec2 uv) {\n    return uv.y < WATER_LEVEL;\n}\n\nvoid mainImage1( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    float col = 0.0;\n    \n    if (lake(uv)) {\n        vec2 m = vec2(uv.x, 2.0 * WATER_LEVEL - uv.y);\n        vec2 ni = uv * 20.0 * vec2(1.0, 15.0);\n        \n        // perturbation\n        vec2 p = vec2(noise(ni), noise(ni + 1000.0 + iTime * 0.05));                \n        vec2 uv1 = m + 0.025 * p;\n        \n        layers(uv1, col);        \n        layer1(uv, col);\n    } else {\n        layers(uv, col);\n    }\n    \n    mist  (uv, col);\n    \n    particles(uv, col, iTime);\n    \n    col = clamp(col, 0.0, 1.0);\n\n    fragColor = vec4(vec3(col), 1.0);\n}\nvec4 mainImage2(in vec2 fragCoord) {\n    vec4 color;\n    mainImage1(color, fragCoord);\n    return color;\n}\n\n\n// Box-filter by Greg Rostami\n// Add this code to the bottom of any shader that has aliasing problems:\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    \n    float stepsize = 1.0 / float(AA);\n    float x, y;\n    \n    x = -0.5;\n    for (int ax = 0; ax < AA; ax++) {\n        y = -0.5;\n        for (int ay = 0; ay < AA; ay++) {\n            fragColor += mainImage2(vec2(x, y) + fragCoord);\n            y += stepsize;\n        }\n        x += stepsize;\n    }\n            \n\tfragColor /= float(AA * AA);\n}","name":"Image","description":"","type":"image"}]}