{"ver":"0.1","info":{"id":"slyyzt","date":"1661989870","viewed":88,"name":"Shader SDF ","username":"jeffbustercase","description":"Shader demonstration without a 3D model,\nthis one makes me self accomplished because I made almost without consulting other examples. (don't know how to fix the texture)\n\"other examples\"= https://www.shadertoy.com/view/4t2fR1","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float getSdf(vec3 p)\n{\n    p *= .21;\n    float y = p.y;\n    float x = p.x;\n    float z = p.z;\n    float s = .32;\n    float r = min(abs(y),s);\n    r = max(r,min(abs(x),s));\n    r = min(r,max(abs(z),s));\n    r += .01;\n    \n    return length(p) - r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy*2.-1.;\n    \n\n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(0.,0.,-2.);\n    \n    ro.y += sin(iTime)*3.;\n    ro.x += cos(iTime)*3.;\n    \n    vec3 lookAt = vec3(0.);\n    float focal = 600.;\n    vec3 camDir = normalize(lookAt-ro);\n    vec2 sensorSize = iResolution.xy*.65;\n    vec3 center = ro + focal * camDir;\n    vec2 coord = uv * sensorSize;\n    \n    vec3 zpos = -camDir;\n    vec3 xpos = cross(vec3(0.,1.,0.),zpos);\n    vec3 ypos = cross(zpos,xpos);\n    \n    vec3 target =\n        center\n        + coord.x * xpos\n        + coord.y * ypos;\n    \n    vec3 camToTarget = target-ro;\n    vec3 rd = normalize(camToTarget);\n    \n    vec3 light = vec3(-5.,5.,0.);\n    \n    float t = iTime;\n    float st = sin(t);\n    float ct = cos(t);\n    mat3 rot = mat3(st,0.,ct\n                   ,0.,1.,0.\n                   ,-ct,0.,st);\n    \n    light *= rot;\n    \n    const float EPISILON = 0.001;\n    const float MIN_DIS = EPISILON;\n    const float MAX_DIS = 2000.;\n    const int MAX_RAYMARCH_STEPS = 256;\n    float depth = EPISILON;\n    for(int i=0;i<MAX_RAYMARCH_STEPS;i++)\n    {\n        vec3 p = ro + depth*rd;\n        vec2 txy = vec2(p.xy);\n        vec4 tex = texture(iChannel0,txy);\n        \n        float dist = getSdf(p); // solid distance function\n        \n        \n        if(dist < MIN_DIS)\n        {// hit\n            \n            vec3 ambient = vec3(0.015);\n            col += ambient;\n            \n            vec2 eps = vec2(EPISILON,0.);\n            vec3 nor = normalize(vec3(\n                 getSdf(p+eps.xyy) - getSdf(p-eps.xyy)\n                ,getSdf(p+eps.yxy) - getSdf(p-eps.yxy)\n                ,getSdf(p+eps.yyx) - getSdf(p-eps.yyx)\n                ));\n            \n            vec3 eye = -(camDir);\n            vec3 sdfToLight = normalize(light-p);\n            vec3 sdfToEye = normalize(eye-p);\n            \n            vec3 diffuse = tex.xyz;\n            float diffGrd = dot(sdfToLight, sdfToEye);\n            if(diffGrd > 0.)\n            {\n                col += diffuse * diffGrd;\n                col *= 1./.76;\n            }\n            \n            vec3 negEye = -rd;\n            vec3 reflected = reflect(-sdfToLight,nor);\n            float specGrd = dot(reflected,negEye);\n            if(specGrd > 0.)\n            {\n                float shininess = 1.5;\n                vec3 specular = vec3(.8);\n                col += specular * pow(specGrd, shininess);\n            }\n            \n            break;\n        }\n        \n        depth += dist;\n        \n        if(dist > MAX_DIS)\n        {// background\n            vec3 xyz = vec3(uv, sqrt(uv.x*uv.x+uv.y*uv.y + 2.01));\n            xyz.y += sin(iTime)*3.;\n            xyz.x += cos(iTime)*3.;\n            \n            vec3 res = iChannelResolution[1].xyz;\n            vec4 btex = texture(iChannel1,rd);\n            col = btex.xyz;\n            break;\n        }\n    }\n    \n    \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}