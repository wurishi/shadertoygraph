{"ver":"0.1","info":{"id":"3s3fWj","date":"1605959857","viewed":111,"name":"Creepy mandelbulb","username":"CHN","description":"Creepy mandelbulb\n\nControls: Arrow keys, N-M for vertical movement, Z-X for changing power of bulb\n\n/Based on Coding Adventure: Ray Marching by Sebastian Lague \nMore information: https://www.youtube.com/watch?v=Cp5WWtMoeKg","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","ray","mandelbrot","mandel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based on Coding Adventure: Ray Marching by Sebastian Lague \n// More information: https://www.youtube.com/watch?v=Cp5WWtMoeKg\n\n\nconst int MAX_MARCHING_STEPS = 150;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.004;\nfloat power = 10.;\nfloat marchSteps = 0.;\nfloat darkness = 25.;\nfloat colorLerp = 0.5;\nvec4 colorA = vec4(1., 0., 0.7, 1.);\nvec4 colorB = vec4(0.3, 0., 1., 1.);\nvec3 LightDir = vec3(-.5,-.5,-.5);\n\nfloat mandelbulbSDF(vec3 pos)\n{\n\tvec3 z = pos;\n    float dr = 1.;\n    float r;\n    \n    for(int i=0; i < 5; i++)\n    {\n    \tr = length(z);\n        if(r > 2.) break;\n        \n        float theta = acos(z.z / r) * power;\n        float phi = atan(z.y / z.x) * power;\n        float zr = pow(r, power);\n        dr = pow(r, power - 1.) * power * dr + 1.;\n        \n        z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n    \tz += pos;\n    }\n    return 0.5 * log(r) * r / dr;\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float eps = 0.0001;\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(mandelbulbSDF(p+h.xyy) - mandelbulbSDF(p-h.xyy),\n                           mandelbulbSDF(p+h.yxy) - mandelbulbSDF(p-h.yxy),\n                           mandelbulbSDF(p+h.yyx) - mandelbulbSDF(p-h.yyx) ) );\n}\n\nfloat saturate(float s)\n{\n\treturn clamp(s,0.0,1.0);\n}\n\nfloat map(vec3 pos, vec3 dir, out vec4 color) {\n    float depth = MIN_DIST;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = mandelbulbSDF(pos + depth * dir);\n        if (dist < EPSILON) {\n            marchSteps = float(i);\n            vec3 normal = calcNormal(pos + depth * dir);\n            float ndd = dot(-normal, dir);\n            \n            vec4 cA = saturate(dot(normal * 0.5 + .5, -LightDir)) * colorA;\n            vec4 cB = saturate(ndd) * colorB;\n                       \n            color = mix(cA, cB, colorLerp * ndd);\n            \n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= MAX_DIST) {\n            marchSteps = float(i);\n            return MAX_DIST;\n        }\n    }\n    marchSteps = float(MAX_MARCHING_STEPS);\n    return MAX_DIST;\n}\n            \nvec3 rayDirection(float fieldOfView, vec3 camRot, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    vec3 dir = vec3(xy, -z);\n    dir = apply_rot(rotationMatrix(vec3(1,0,0), camRot.x), dir);\n    dir = apply_rot(rotationMatrix(vec3(0,1,0), camRot.y), dir);\n    dir = apply_rot(rotationMatrix(vec3(0,0,1), camRot.z), dir);\n    return normalize(dir);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    loadAll(iChannel0);\n    power = itrCount.x;\n\tvec3 dir = rayDirection(60.0, rot.xyz, iResolution.xy, fragCoord);\n    vec4 color;\n    float dist = map(pos.xyz, dir, color);\n   \tfloat rim = (marchSteps + 15.) / darkness; \n    fragColor = mix(color, vec4(1), 0.3) * rim;\n    fragColor = pow(fragColor, vec4(2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n\n#define KEY_A 65\n#define KEY_D 68\n#define KEY_S 83\n#define KEY_W 87\n\n#define KEY_J 74\n#define KEY_L 76\n#define KEY_K 75\n#define KEY_O 79\n\n#define KEY_N 78\n#define KEY_M 77\n\n#define KEY_Z 90\n#define KEY_X 88\n\n#define varRow 0\n#define var(name, column, row) ivec2 name = ivec2(column, row)\n\nvar(_pos, 0, varRow);\nvar(_rot, 1, varRow);\nvar(_oldMousePos, 2, varRow);\nvar(_itrCount, 3, varRow);\n\nvec4 pos, rot, oldMousePos, rayDir, rayPos, itrCount;\n\nvec4 load(sampler2D buffer, in ivec2 coord)\n{\n\treturn texelFetch(buffer, coord, 0);\n}\n\nvoid loadAll(sampler2D buffer)\n{\n\tpos = load(buffer, _pos);\n    rot = load(buffer, _rot);\n    itrCount = load(buffer, _itrCount);\n}\n\nvec4 save(in ivec2 valCoord, in vec4 value, in ivec2 coord)\n{\n\tif(coord == valCoord)\n    {\n    \treturn value;\n    }\n    \n    return vec4(0.);\n}\n\nvec4 saveAll(in vec2 fCoord)\n{\n    ivec2 coord = ivec2(fCoord);\n    \n    vec4 saveVal = vec4(0.);\n      \n    saveVal += save(_pos, pos, coord);\n    saveVal += save(_rot, rot, coord);\n    saveVal += save(_oldMousePos, oldMousePos, coord);\n    saveVal += save(_itrCount, itrCount, coord);\n    \n    return saveVal;\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    angle = radians(angle);\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 apply_rot(mat4 r, vec3 p)\n{\n    return (r*vec4(p, 1.)).xyz;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float getKeyState(int key)\n{\n    return texelFetch(iChannel1, ivec2(key, 0), 0).x * 0.1;\n}\n\nvoid writeDefaults()\n{\n    pos = vec4(0.,0,3,0);\n\trayDir = vec4(1,0,0,0);\n    itrCount.x = 14.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    loadAll(iChannel0);\n    oldMousePos = load(iChannel0, _oldMousePos);\n    \n    vec3 posDif;\n    \n    posDif.x = -getKeyState(KEY_LEFT) + getKeyState(KEY_RIGHT);\n    posDif.y = -getKeyState(KEY_N) + getKeyState(KEY_M);\n    posDif.z = -getKeyState(KEY_UP) + getKeyState(KEY_DOWN);\n    \n    posDif = apply_rot(rotationMatrix(vec3(0,1,0), rot.y) * rotationMatrix(vec3(1,0,0), rot.x), posDif);\n    \n    pos.xyz += posDif * 0.25; \n    \n    itrCount.x += -getKeyState(KEY_Z) * 1.5 + getKeyState(KEY_X) * 1.5;\n    \n    if(iFrame == 0)\n    {\n        writeDefaults();\n    \toldMousePos.xyz = iMouse.xyz;\n    }\n    \n    if (oldMousePos.z > 0. && iMouse.z > 0.) {\n    \trot.xy += vec2((-iMouse.y + oldMousePos.y) * 0.05, \n                   \t\t(iMouse.x - oldMousePos.x) * 0.1);  \n    }\n    \n   \toldMousePos.xyz = iMouse.xyz;\n    \n\tfragColor = saveAll(fragCoord);\n}","name":"Buffer A","description":"","type":"buffer"}]}