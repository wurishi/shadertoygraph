{"ver":"0.1","info":{"id":"lsGfzc","date":"1529940696","viewed":343,"name":"Dust Light Explosion","username":"TheRomanOne","description":"Experimenting with camera settings, split screen, rotation matrices and the smoothstep function.\n","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["camera","rotation","martix","split"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Experimenting with rotation matrices and a split screen.\n// Use mouse to change the position of the separation line\n// on the screen.\n// Number of particles is gridSizeÂ³, so feel free to change it\n//\n// Special thanks to BigWIngs\n\n\n#define PI 3.141592654\n\n\n\nfloat gridSize = 7.;\n\n\n\nstruct Globals\n{\n    vec3 origin;\n    vec3 rd;\n    vec3 lookAt;\n};\n\nGlobals globals;\n\nfloat getDistance(vec3 point)\n{\n    return length(cross(point - globals.origin, globals.rd))/length(globals.rd);\n}\n\nfloat drawSphere(vec3 point, float radius, float y)\n{\n    float dis = getDistance(point);\n    float scale = 1. + 0.5*cos(iTime*y * 5.5);\n    return smoothstep(radius, radius - scale,dis ); \n}\n\nvoid init(vec2 uv, vec3 lookAt)\n{\n    globals.lookAt = lookAt;\n    globals.origin = vec3(0, 0, -70.);\n    vec3 camZ = normalize(globals.lookAt - globals.origin);\n    vec3 camX = normalize(cross(vec3(0,1,0), camZ));\n    vec3 camY = cross(camZ, camX);\n    vec3 newuv = vec3(uv, 0.);\n    globals.rd = normalize(newuv.x * camX + newuv.y * camY + camZ);\n}\n\nmat4 rotateX(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    return mat4(\n        1, 0, 0, 0,\n        0, c,-s, 0,\n        0, s, c, 0,\n        0, 0, 0, 1\n    );\n}\n\nmat4 rotateY(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return mat4(\n        c, 0, s, 0,\n        0, 1, 0, 0,\n       -s, 0, c, 0,\n        0, 0, 0, 1\n    );\n}\n\nmat4 rotateZ(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return mat4(\n        c,-s, 0, 0,\n        s, c, 0, 0,\n        0, 0, 1, 0,\n        0, 0, 0, 1\n    );\n}\n\nmat4 translateXYZ(float x, float y, float z)\n{\n    return mat4(\n            1, 0, 0, x,\n            0, 1, 0, y,\n            0, 0, 1, z,\n            0, 0, 0, 1\n        );\n}\n\nvec3 mat4Vec3(mat4 m, vec3 v)\n{\n    return (m * vec4(v, 1.)).xyz;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy) - 0.5;\n    uv.y *= iResolution.y/iResolution.x;\n    vec3 col = vec3(0.);\n    float t = (iTime + 14.1)/ 3.;\n    \n    float interval = 20. * (1. + sin(t));\n    float sphereSize = .9 - .4 * cos(t+PI/2.);\n    init(uv, vec3((gridSize - 1.)* interval / 2.));\n    \n    vec2 mo = iMouse.xy / iResolution.xy;\n    float mouse = mo.x-.5;\n    if (mo.y == 0.)\n        mouse = -0.0025;\n    float line = 0.005;\n    \n    if(uv.x > mouse && uv.x < mouse + line)\n        col = vec3(1., .52, 0.7);\n    else\n        for(float i = 0.; i < gridSize; i++)\n            for(float j = 0.; j < gridSize; j++)\n                for(float k = 0.; k < gridSize; k++)\n                {\n                    vec3 point = vec3(\n                        i*interval,\n                        j*interval,\n                        k*interval\n                    );\n\n                    mat4 matrixStack = mat4(1);\n                    float forX, forY, forZ = 0.;\n                    if(uv.x < mouse)\n                    {\n                        forX = j + k;\n                        forY = i + k;\n                        forZ = j + i;\n                    }\n                    \n                    matrixStack *= rotateX(t + forX);\n                    matrixStack *= rotateY(t + forY);\n                    matrixStack *= rotateZ(t + forZ);  \n                    \n\t\t\t\t\tpoint -= globals.lookAt;\n                    point = mat4Vec3(matrixStack, point);\n                    point += globals.lookAt;\n\n                    vec3 c = 7.*vec3(i, j, k)/gridSize;\n\n                    col += vec3(c*drawSphere(point, sphereSize, k));   \n                }\n    \n    fragColor = vec4(col/2.,1.0);\n}","name":"Image","description":"","type":"image"}]}