{"ver":"0.1","info":{"id":"sslfRn","date":"1644485292","viewed":304,"name":"Water Bottom","username":"March3rd","description":"I make the random vector of each vertex in Perlin Noise changing its length with time. You can find this operation in Hash22();","likes":6,"published":3,"flags":0,"usePreview":0,"tags":["turbulence"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define VOLUME_LIGHT_RADIUS 1.0\n#define LIGHT_ENFLUENCE_RADIUS 10.0\n\n#define MAX_STEP 100\n#define STEP_LEN 0.01\n#define MAX_DEPTH 1000.0\n#define BLANK_COLOR vec3(0.0, 0.0, 0.0)\n#define SURFACE_DIST 0.001\n\n//----Globals----//\nstruct Ray {\n    vec3 ro;\n    vec3 rd;\n};\nstruct Light {\n     vec3 pos;\n     vec3 col;\n     float range;\n};\n\nRay _view;\n\nLight _light[1];\nint _lightNum = 1;\nvec3 _ambient;\n\nfloat _depthBuffer;\nvec3 _colorBuffer;\n//---------------//\n\n//----SDFs----//\nfloat PlaneSDF(vec3 base, vec3 normal, vec3 pos) {\n    return dot(pos - base, normalize(normal)); \n}\n//-----------//\n\n//----Noise----//\nvec2 Hash22(vec2 p) {\n    p = vec2( dot(p,vec2(127.1,311.7)),\n              dot(p,vec2(269.5,183.3)));\n\n    vec2 result = normalize(-1.0 + 2.0 * fract(sin(p)*43758.5453123));\n    result *= sin(iTime * 1.0 + p.x * 3.14 + p.y * 3.14);\n    return result;\n}\nvec2 Tilling(vec2 p, int n) {\n    if (abs(p.x - float(n)) < 0.1) p.x = 0.0;\n    if (abs(p.y - float(n)) < 0.1) p.y = 0.0;\n    return p;\n}\nfloat PerlinNoise(vec2 p, int n, float frequency) {\n    p *= frequency;\n    p = fract(p);\n    p *= float(n);\n    vec2 pi = floor(p);\n    vec2 pf = p - pi;\n\n    vec2 w = pf * pf * (3.0 - 2.0 * pf);\n\n    return mix(mix(dot(Hash22(Tilling(pi + vec2(0.0, 0.0), n)), pf - vec2(0.0, 0.0)), \n                   dot(Hash22(Tilling(pi + vec2(1.0, 0.0), n)), pf - vec2(1.0, 0.0)), w.x), \n               mix(dot(Hash22(Tilling(pi + vec2(0.0, 1.0), n)), pf - vec2(0.0, 1.0)), \n                   dot(Hash22(Tilling(pi + vec2(1.0, 1.0), n)), pf - vec2(1.0, 1.0)), w.x),\n               w.y);\n}\nfloat Turbulence(vec2 p, int n, float frequency, int octaves, float attenFrequency, float attenAmplitude) {\n    float value = 0.0;\n    float amplitude = 1.0 - attenAmplitude;\n    for (int i = 0; i < octaves; i ++) {\n        value += amplitude * abs(PerlinNoise(p, n, frequency));\n        amplitude *= attenAmplitude;\n        frequency *= attenFrequency;\n    }\n    return pow(1.0 - clamp(value, 0.0, 1.0), 8.0);;\n}\n//-------------//\n\n//----Classes----//\n//Plane\nstruct Plane {\n    vec3 base;\n    vec3 normal;\n    vec3 col;\n};\n\nfloat MapPlane(Plane plane, vec3 pos) {\n    return PlaneSDF(plane.base, plane.normal, pos);\n}\nvec3 ShadePlaneWithLight(Plane plane, vec3 pos, Light light) {\n    float dist = length(light.pos - pos);\n    float attenuation = (dist < light.range) ? pow(1.0 - dist / light.range, 2.0) : 0.0;\n    vec3 diffuse = clamp(dot(plane.normal, normalize(light.pos - pos)), 0.0, 1.0) * light.col * plane.col;\n    return attenuation * diffuse;\n}\nvec3 ShadePlane(Plane plane, vec3 pos) {\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    for (int i = 0; i < _lightNum; i ++) {\n        col += ShadePlaneWithLight(plane, pos, _light[i]);\n    }\n    return _ambient + mix(col, vec3(1.0, 1.0, 0.8), Turbulence(pos.xz, 10, 0.01, 6, 2.0, 0.5));\n}\nfloat GotoPlane(Plane plane) {\n    float depth = 0.0;\n    for (int i = 0; i < MAX_STEP; i ++) {\n        float dist = MapPlane(plane, _view.ro + _view.rd * depth);\n        depth += dist;\n        if (depth > _depthBuffer || dist < SURFACE_DIST) {\n            break;\n        }\n    }\n    return depth;\n}\n\nvoid RenderPlane(Plane plane) {\n    float depth = GotoPlane(plane);\n    if (depth < _depthBuffer) {\n        _depthBuffer = depth;\n        _colorBuffer = ShadePlane(plane, _view.ro + _view.rd * depth);\n    }\n}\n//---------------//\n\n//----PipeLine----//\nvoid Pipeline() {\n    //Objects\n    Plane plane;\n    plane.base = vec3(0.0, -10.0, 0.0);\n    plane.normal = vec3(0.0, 1.0, 0.0);\n    plane.col = vec3(0.8, 0.9, 0.3);\n    //Opaque\n    RenderPlane(plane);\n    \n    //RenderBurningBall(burningBall);\n    //Transparant\n    \n    //PostEffects\n    _colorBuffer = mix(_colorBuffer, vec3(0.3, 0.7, 0.8), clamp(_depthBuffer / 100.0, 0.0, 1.0)); \n}\n//----------------//\n\n//----Entry----//\nvoid Init() {\n    //light0\n    _light[0].pos = vec3(0.0, 10.0, 25.0);\n    _light[0].col = vec3(1.0, 1.0, 1.0);\n    _light[0].range = 100.0;\n    //ambient\n    _ambient = vec3(0.3, 0.3, 0.3);\n    //buffer\n    _depthBuffer = MAX_DEPTH;\n    _colorBuffer = BLANK_COLOR;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    //Init\n    Init();\n    //Normalized pixel coordinates\n    vec2 uv = (fragCoord-0.5*iResolution.xy) / iResolution.y;\n    //Ray\n    _view.ro = vec3(0.0, 0.0, -0.5);\n    _view.rd = normalize(vec3(uv.x, uv.y, 0.5));\n    //Pipeline\n    Pipeline();\n    // Output to screen\n    fragColor = vec4(_colorBuffer, 1.0);\n}\n//-------------//","name":"Image","description":"","type":"image"}]}