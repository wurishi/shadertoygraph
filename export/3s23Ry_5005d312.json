{"ver":"0.1","info":{"id":"3s23Ry","date":"1549489835","viewed":117,"name":"Raymarching Workshop - 2D Rings","username":"trevortheblack","description":"SDF, simple, copied from \nhttps://github.com/ajweeks/RaymarchingWorkshop","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// TREVOR BLACK\n// LICENSE - There Ain't One\n// This is my take on the 2D raymarching from the RaymarchingWorkshop\n\n\n// Companion shader for Raymarching Workshop run at Electric Square\n// Workshop site: https://github.com/ajweeks/RaymarchingWorkshop\n\n// MIT license\n\n\n#define M_PI 3.1415926535897932384626433832795028841971693993751058209749445923078164062\n\n// -------------------------\n// SDF FUNCTION DECLARATIONS\nfloat sdSphere   (vec3 p, float s);\nfloat sdBox      (vec3 p, vec3 b);\nfloat sdPlane    (vec3 p, vec4 n);\nfloat sdCylinder (vec3 p, vec3 c);\nfloat sdTorus    (vec3 p, vec2 t);\nfloat sdRoundBox (vec3 p, vec3 b, float r);\nfloat sdCircle(vec2 p, vec2 pos, float radius);\nfloat sdRing(vec2 p, vec2 pos, vec2 radii);\n\n// -------------------------\n// SDF UTILITY DECLARATIONS\nfloat opU(float d1, float d2);\nfloat opBlend(float d1, float d2);\n\n\n// --------------------------\n// MAIN FUNCTION DECLARATIONS\nfloat sdf(vec2 p);\nvec2 screenToWorld(vec2 screen);\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d);\nvec3 shade(float sd);\n\n// compute pixel colour\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // project screen coordinate into world\n\tvec2 p = screenToWorld(fragCoord);\n    \n    // signed distance for scene\n    float sd = sdf(p);\n    \n    // compute signed distance to a colour\n    vec3 col = shade(sd);\n    \n    fragColor = vec4(col, 1.0);\n}\n\n\nvec2 screenToWorld(vec2 screen)\n{\n    vec2 result = 2.0 * (screen/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y;\n    return result;\n}\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    t = clamp(t, 0., 1.);\n    return a + b*cos(6.28318*(c*t+d));\n}\nvec3 shade(float sd)\n{\n    float maxDist = 2.0;\n    vec3 palCol = palette(clamp(0.5-sd*0.4, -maxDist,maxDist), \n                      vec3(0.3,0.3,0.0),vec3(0.8,0.8,0.1),vec3(0.9,0.7,0.0),vec3(0.3,0.9,0.8));\n\n    vec3 col = palCol;\n    \n    // Darken around surface\n\tcol = mix(col, col*1.0-exp(-10.0*abs(sd)), 0.4);\n\t// repeating lines\n    col *= 0.8 - 0.2*cos(150.0*sd - sign(sd)*M_PI*5.0*iTime);\n    // White outline at surface\n    col = mix(col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(sd)));\n    \n    return col;\n}\n\n// SDF \nfloat sdf(vec2 p)\n{\n\tfloat d = 1000.0;\n    \n    d = opBlend(d, sdRing(p, vec2(-0.15, -0.3), vec2(0.2, 0.55)));\n    d = opBlend(d, sdRing(p, vec2(1.6, -0.1), vec2(1.0,1.3)));\n    d = opBlend(d, sdRing(p, vec2(1.6, -0.1), vec2(0.4,0.7)));\n    d = opBlend(d, sdCircle(p, vec2(1.6, -0.1), 0.1));\n    \n    //d = opBlend(d, sdCircle(p, vec2(1.6, -0.1), 1.3));\n    \n    return d;\n}\n\n\n\n// -------------------------\n// SDF FUNCTION DEFINITIONS\n// -------------------------\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - s;   \n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.0)) + \n        min(max(d.x, max(d.y,d.z)), 0.0);\n}\n\nfloat sdPlane    (vec3 p, vec4 n)\n{ // n must be normalized\n    return dot(p, n.xyz) + n.w;\n}\n\nfloat sdCylinder (vec3 p, vec3 c)\n{\n    return length(p.xz-c.xy) - c.z;\n}\n\nfloat sdTorus    (vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdRoundBox (vec3 p, vec3 b, float r)\n{\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.0)) - r +\n        min(max(d.x, max(d.y,d.z)), 0.0);                 \n}\n\nfloat sdCircle(vec2 p, vec2 pos, float radius)\n{\n    return length(p-pos)-radius;\n}\n\nfloat sdRing(vec2 p, vec2 pos, vec2 radii)\n{\n    vec2 pRingSpace = p - pos;\n    float dInner = radii.x - length(pRingSpace);\n    float dOuter = length(pRingSpace) - radii.y;\n    //return max(dInner, dOuter);\n    // smooth out sd in body of the ring\n    float dMax = max(dInner, dOuter);\n    /*\n    if(dMax < 0.0)\n    {\n        float dCenterBodyRing = length(pRingSpace) - 0.5*(radii.x+radii.y);\n        dCenterBodyRing = sqrt(dCenterBodyRing*dCenterBodyRing + 0.001); // 0.1 is an eps\n        dCenterBodyRing = dCenterBodyRing - 0.5*(radii.y-radii.x);\n        return dCenterBodyRing;   \n    }\n    */\n    return dMax;\n\n    \n    \n    //float dMax = max(dInner, dOuter);\n    //float width = radii.y - radii.x;\n    //float dMaxCenterAtOrigin = \n    //return sqrt( (dMax-width)*() + 0.0001f);\n    \n}\n// -------------------------\n\n// -------------------------\n// SDF Utility Library\n\n// polynomial smooth min (k = 0.1);\nfloat sminCubic(float a, float b, float k)\n{\n    float h = max(k-abs(a-b), 0.0);\n    return min(a, b) - h*h*h/(6.0*k*k);\n}\n\nfloat opU(float d1, float d2)\n{\n    return min(d1, d2);\n}\n\nfloat opBlend(float d1, float d2)\n{\n    float k = 0.2;\n    return sminCubic(d1, d2, k);\n}\n// --------------------------","name":"Image","description":"","type":"image"}]}