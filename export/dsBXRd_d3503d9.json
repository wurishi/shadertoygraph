{"ver":"0.1","info":{"id":"dsBXRd","date":"1670715255","viewed":123,"name":"Subtle AA and Denoiser","username":"ianertson","description":"Anti Alias & Denoiser","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["aa","denoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EDGE_SENSITIVITY 0.6\n#define NOISE_SENSITIVITY 2.6\n\n\n\nvoid edge_detect_make_kernel(inout vec4 n[9], sampler2D tex, vec2 coord, vec2 texSize)\n{\n\n\n  \n  float w = 1.0 / texSize.x;\n  float h = 1.0 / texSize.y;\n\n  n[0] = texture(tex, coord + vec2( -w, -h));\n  n[1] = texture(tex, coord + vec2(0.0, -h));\n  n[2] = texture(tex, coord + vec2(  w, -h));\n  n[3] = texture(tex, coord + vec2( -w, 0.0));\n  n[4] = texture(tex, coord);\n  n[5] = texture(tex, coord + vec2(  w, 0.0));\n  n[6] = texture(tex, coord + vec2( -w, h));\n  n[7] = texture(tex, coord + vec2(0.0, h));\n  n[8] = texture(tex, coord + vec2(  w, h));\n}\n\n\nfloat edge_detect(sampler2D tex, vec2 coord, vec2 texSize) {\n\n\n  vec4 n[9];\n  edge_detect_make_kernel(n, tex, coord, texSize);\n\n  vec4 sobel_edge_h = n[2] + (2.0*n[5]) + n[8] - (n[0] + (2.0*n[3]) + n[6]);\n  vec4 sobel_edge_v = n[0] + (2.0*n[1]) + n[2] - (n[6] + (2.0*n[7]) + n[8]);\n  vec4 sobel = sqrt((sobel_edge_h * sobel_edge_h) + (sobel_edge_v * sobel_edge_v));\n\n  return max(max(sobel.r, sobel.g), sobel.b);\n    \n}\n\nfloat color_vary(vec3 pixel, sampler2D tex, vec2 uv, vec2 scalar) {\n  vec3 c_left = texture(tex, vec2(uv + vec2(-1, 0) * scalar)).rgb;\n  vec3 c_right = texture(tex, vec2(uv + vec2(1, 0) * scalar)).rgb;\n  vec3 c_up = texture(tex, vec2(uv + vec2(0, 1) * scalar)).rgb;\n  vec3 c_down = texture(tex, vec2(uv + vec2(0, -1) * scalar)).rgb;\n\n\n\n  float v = 0.0;\n  v += distance(pixel, c_left);\n  v += distance(pixel, c_right);\n  v += distance(pixel, c_up);\n  v += distance(pixel, c_down);\n\n\n  return v / 4.0;\n}\n\nvec3 avg_color(sampler2D tex, vec2 uv, vec2 scalar) {\n  vec3 c_left = texture(tex, vec2(uv.xy + vec2(-1, 0) * scalar)).rgb;\n  vec3 c_right = texture(tex, vec2(uv.xy + vec2(1, 0) * scalar)).rgb;\n  vec3 c_up = texture(tex, vec2(uv.xy + vec2(0, 1)) * scalar).rgb;\n  vec3 c_down = texture(tex, vec2(uv.xy + vec2(0, -1)*scalar)).rgb;\n  vec3 c_center = texture(tex, vec2(uv.xy + vec2(0, 0)*scalar)).rgb;\n\n\n  return (c_left + c_right + c_up + c_down + c_center) / 5.0;\n}\n\nvec3 radial(sampler2D tex, vec2 uv, int count, vec2 scalar, float radius) {\n  vec3 avg = vec3(0.0);\n  for (int i = 0; i < count; i++) {\n    float R = radians((float(i) / float(count)) * 360.0);\n    vec2 offset = vec2(cos(R), sin(R)) * scalar * radius;\n    vec3 next = texture(tex, uv + offset).rgb;\n\n    avg += next;\n  }\n\n  avg = avg / float(count);\n\n  return avg;\n}\n\nvec3 smoothen(vec3 px, sampler2D tex, vec2 uv, vec2 scalar, float amp) {\n   float E = pow(amp, 3.0);\n   vec3 a = avg_color(tex, uv, scalar);\n   vec3 b = radial(tex, uv, max(3, int(32.0 * E)), scalar, 2.0 * E);\n   return mix(a, b,  clamp(E, 0.0, 1.0));\n}\n\nvec3 denoise(sampler2D tex, vec2 uv, float edge_sense, float noise_sense) {\n   vec3 col = texture(tex, uv).rgb;\n   float pwr = length(col);\n   vec2 texSize = vec2(textureSize(tex, 0).xy);\n   \n   vec2 scalar =  1.0 / texSize;\n   \n   \n   float edge = clamp(edge_detect(tex, uv, texSize) * edge_sense, 0.0, 1.0);\n   float noisy = clamp(color_vary(col, tex, uv, scalar) * noise_sense, 0.0, 1.0);\n   \n   \n   float F = clamp(max(edge, noisy), 0.0, 1.0);\n   \n   vec3 S = smoothen(col, tex, uv, scalar, F);\n   \n   vec3 next_col = mix(col, S, F);\n   float next_pwr = length(next_col);\n   \n   float loss = max(0.0, pwr - next_pwr); // calculate some lost \"energy\"\n   \n   return next_col + (loss * 0.49);\n}\n\nbool mouseDown() {\n    return (iMouse.z + iMouse.w) > 0.001;\n}\n\n\nvec3 mainWrap(vec2 uv, vec2 c, sampler2D tex) {\n    \n    vec3 colA = texture(tex, uv).rgb;\n    vec3 colB = denoise(tex, uv, EDGE_SENSITIVITY, NOISE_SENSITIVITY);\n    \n    vec2 point = mouseDown() ? iMouse.xy : (iResolution.xy / 2.0);\n        \n    vec3 col = c.x < point.x ? colA : colB;\n    col *= (abs(c.x - point.x) <= 2.0 ? 0.0 : 1.0);\n    \n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy);\n    vec2 c = fragCoord.xy;\n\n    \n    float img = clamp(0.5 + cos(iTime*0.5), 0.0, 1.0);\n    \n    vec3 A = mainWrap(uv, c, iChannel0);\n    vec3 B = mainWrap(uv, c, iChannel1);\n    \n  \n    vec3 col = mix(A, B, img);\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}