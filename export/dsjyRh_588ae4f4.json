{"ver":"0.1","info":{"id":"dsjyRh","date":"1687438478","viewed":47,"name":"raymarching test2","username":"calc","description":"a","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"  const int MAX_MARCHING_STEPS = 255;\n  const float MIN_DIST = 0.0;\n  const float MAX_DIST = 100.0;\n  const float PRECISION = 0.001;\n  const vec3 BACKGROUND_COLOR = vec3(0.0, 0.0, 0.0);\n\n\n  float sdSphere(vec3 p, float r )\n  {\n    vec3 offset = vec3(0, 0, -2);\n    return length(p - offset) - r;\n  }\n\n  float map(vec3 p) {\n    // p.xy *= rotate(iTime) ;\n    // p.yz *= rotate(iTime) ;\n      vec3 b = vec3(.3,.8, .2); // radius of sphere\n      float d = sdSphere(p,.4);\n    return d;\n  }\n\n  vec3 calcNormal(vec3 p) {\n      vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n      vec3 b = vec3(.3,.8, .2); // radius of box\n      return normalize(\n        e.xyy * sdSphere(p + e.xyy, .2) +\n        e.yyx * sdSphere(p + e.yyx, .2) +\n        e.yxy * sdSphere(p + e.yxy, .2) +\n        e.xxx * sdSphere(p + e.xxx, .2));\n  }\n\n  vec3 ApplyGammaCorrection(vec3 color){\n      float gamma =2.2;\n      return pow(color, vec3(1. / gamma));\n  }\n\n  void mainImage( out vec4 fragColor, in vec2 fragCoord )\n  {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0, 0, -3); // ray origin that represents **camera position**\n    vec3 camera_dir = normalize(vec3(0 , 0 , 1.0)); // ray direction\n    vec3 camera_up = vec3(0, 1, 0); // ray up vector\n    vec3 camera_side = cross(camera_dir,camera_up ); // ray side vector\n\n    vec3 rd = normalize(camera_dir + uv.x * camera_side + uv.y * camera_up); // ray direction\n\n\n\n\n    // ray marching\n    float d = 0.0;\n    vec3 p = ro; // p is now pos\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n      d = map(p);\n      p += d * rd;\n    }\n      // light\n    vec3 li_pos = vec3(2, 3, -4);\n    vec3 li_dir = normalize(li_pos - p);\n\n\n\n\n\n    if (d > MAX_DIST) {\n      col = vec3(BACKGROUND_COLOR); // ray didn't hit anything\n    } else {\n      vec3 normal = calcNormal(p);\n\n      // Calculate diffuse reflection by taking the dot product of \n      // the normal and the light direction.\n      float dif = dot(normal, li_dir);\n\n      col = ApplyGammaCorrection( vec3( clamp(dif, 0.,1.)  ) );\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n  }","name":"Image","description":"","type":"image"}]}