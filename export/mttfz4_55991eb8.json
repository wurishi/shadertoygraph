{"ver":"0.1","info":{"id":"mttfz4","date":"1706541027","viewed":119,"name":"Voxel Pathtracer","username":"Depth","description":"wasd to move and mouse to look around\nalso has POM (parallax occulusion mapping) and normal mapping\n(Changing the texture in iChannel2 of buffer B will change what texture each voxel is using)","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["shader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n    color *= 1.2;\n    float tonemap_crunch = 2.;\n    color = pow(tanh(pow(color, vec3(tonemap_crunch))), vec3(1./tonemap_crunch));\n    color  = pow(color, vec3(1./2.2));\n    fragColor = vec4(color, 1);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define KeyLeft 65\n#define KeyRight 68\n#define KeyUp 87\n#define KeyDown 83\n#define KeyE 69\n#define KeyQ 81\n#define KeyR 82\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //(0,0)=mouse, (1,0)=campos, (2,0)=camangle, (3,0)=iter\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    if(floor(uv*10.)==vec2(0,0)){\n        fragColor = vec4(iMouse);\n    }\n    \n    if(floor(uv*10.)==vec2(1,0)){\n        vec2 CamAngle = texture(iChannel0, vec2(.25,.05)).xy;\n        vec3 CamOffset = texture(iChannel0, uv).xyz;\n        if(texelFetch(iChannel1, ivec2(KeyLeft,0),0).x==1.){\n            CamOffset.x += .04*-cos(CamAngle.x);\n            CamOffset.z += .04*sin(CamAngle.x);\n        }\n        if(texelFetch(iChannel1, ivec2(KeyRight,0),0).x==1.){\n            CamOffset.x += .04*cos(CamAngle.x);\n            CamOffset.z += .04*-sin(CamAngle.x);\n        }\n        if(texelFetch(iChannel1, ivec2(KeyUp,0),0).x==1.){\n            CamOffset.x += .04*-sin(-CamAngle.x);\n            CamOffset.z += .04*cos(-CamAngle.x);\n        }\n        if(texelFetch(iChannel1, ivec2(KeyDown,0),0).x==1.){\n            CamOffset.x += .04*sin(-CamAngle.x);\n            CamOffset.z += .04*-cos(-CamAngle.x);\n        }\n        CamOffset.y += .04*texelFetch(iChannel1, ivec2(KeyE,0),0).x;\n        CamOffset.y -= .04*texelFetch(iChannel1, ivec2(KeyQ,0),0).x;\n        if(texelFetch(iChannel1, ivec2(KeyR,0),0).x==1.){\n            CamOffset = vec3(0,0,0);\n        }\n        fragColor = vec4(CamOffset,1.0);\n    }\n    if(floor(uv*10.)==vec2(2,0)){\n        vec2 CamAngle = texture(iChannel0, uv).xy;\n        CamAngle.x -= 4.*(texelFetch(iChannel0, ivec2(.5,.5),0).x-iMouse.x)/iResolution.x*float(sign(texelFetch(iChannel0, ivec2(.5,.5),0).z)==1.);\n        CamAngle.y -= 4.*(texelFetch(iChannel0, ivec2(.5,.5),0).y-iMouse.y)/iResolution.y*float(sign(texelFetch(iChannel0, ivec2(.5,.5),0).z)==1.);\n        if(texelFetch(iChannel1, ivec2(KeyR,0),0).x==1.){\n            CamAngle = vec2(0,0);\n        }\n        fragColor = vec4(CamAngle,1.0,1.0);\n    }\n    if(floor(uv*10.)==vec2(3,0)){\n        float iter = min(texture(iChannel0, uv).x+1., 100.);\n        if(sign(texelFetch(iChannel0, ivec2(.5,.5),0).z)==1.) iter = 0.;\n        if(texelFetch(iChannel1, ivec2(KeyLeft,0), 0).x==1.) iter = 0.;\n        if(texelFetch(iChannel1, ivec2(KeyRight,0),0).x==1.) iter = 0.;\n        if(texelFetch(iChannel1, ivec2(KeyUp,0),0).x==1.) iter = 0.;\n        if(texelFetch(iChannel1, ivec2(KeyDown,0),0).x==1.) iter = 0.;\n        if(texelFetch(iChannel1, ivec2(KeyE,0),0).x==1.) iter = 0.;\n        if(texelFetch(iChannel1, ivec2(KeyQ,0),0).x==1.) iter = 0.;\n        if(texelFetch(iChannel1, ivec2(KeyR,0),0).x==1.) iter = 0.;\n        fragColor = vec4(iter,0,0,0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Configurable\n    //Range\n#define Bounces 3\n#define Samples 1\n#define ViewDist 4\n#define ParallaxDepth .15\n#define NormalMapStrength 1.\n#define Worldsize 3\n#define MaxLights 1\n#define LightSamples 1\n#define ParallaxSamples 8\n    //Toggles (bool)\n#define SelfShadowing false\n#define PBR true\n\n//No touchy\n#define Pi 3.141592653589\n#define Epsilon .00001\n\n//Remove with minecraft data\n#define FocalDist 1.\n\n//Basic Definitions\nfloat CamYaw;\nfloat CamPitch;\nvec3 RayOrgn = vec3(0,0,0);\nvec3 RayDir = vec3(0,0,0);\nfloat Dist;\nfloat iter;\nvec3 Normal;\nvec3 uv;\nmat3 TBN;\nint PrevID;\nint HitBlock;\nint Seed;\nint world[int(pow(2., 3.*float(Worldsize)))];\nvec3 LightPos[MaxLights];\nvec3 LightColor[MaxLights];\nvec2 LightProp[MaxLights]; //x: Lumenosity, y: Size\nconst float BlockSize = pow(2., float(Worldsize));\n\n//Code\nfloat GetRand(in float mi, in float ma){\n    Seed = Seed * 747796405 + 2891336453;\n    int result = ((Seed >> ((Seed >> 28) + 4)) ^ Seed) * 277803737;\n    result = (result >> 22) ^ result;\n    return (mod(float(result)/149729.4323, (ma-mi)) + mi);\n}\n\nfloat AtanTwo(in float Slope){\n    return atan(Slope)+(Pi*float(Slope<.0001));\n}\n\nvec3 Transform(in vec3 View){\n    if (abs(Normal.x)==1.) return vec3(View.z*Normal.x, View.y, -View.x*Normal.x);\n    if (abs(Normal.y)==1.) return vec3(View.x, View.z, -View.y*Normal.y);\n    if (abs(Normal.z)==1.) return vec3(View.x, View.y, -View.z*Normal.z);\n}\n\nvoid GetTexture(in int ID, out vec3 Color, out vec4 Material, inout vec3 N){\n    //x: Roughness, y: Refraction Probability, z: Color Obsorbancy, w: Refractive Index\n    if (world[ID] == 2){\n        Color = vec3(.1,.1,.8);\n        Material.x = 0.025;\n        Material.y = 0.65;\n        Material.z = 0.5;\n        Material.w = 1.5168;\n    } else {\n        Color = vec3(1.0,1.0,1.0);\n        Material.x = 0.8;\n        Material.y = 0.0;\n        Material.z = 1.0;\n        Material.w = 1.0;\n    }\n    Color = vec3(.6);\n    vec3 iNorm = fract(RayOrgn);\n    TBN = mat3(                                    //ox,     oy,  oz    vx, vy, vz\n        1.-abs(N.x), 0,           -N.x,     //if x: (-vz*nx, vy,  -vx*nx)  \n        0,           1.-abs(N.y), -N.y,     //if y: (vx,     vz,  -vy*ny)\n        -N.x,        -N.y,         abs(N.z) //if z: (vx,     vy,  -vz*nz)\n    );\n    vec2 NA = vec2(AtanTwo(Normal.x/Normal.z), -AtanTwo(Normal.y/length(Normal.xz)));\n    /*vec3(\n        RayDir.x*cos(NA.x) - RayDir.z*sin(NA.x),\n        RayDir.y*cos(NA.y) - ( RayDir.z*cos(NA.x) + RayDir.x*sin(NA.x) )*sin(NA.y),\n        ( RayDir.z*cos(NA.x) + RayDir.x*sin(NA.x) )*cos(NA.y) + RayDir.y*sin(NA.y)\n    );\n    */\n    vec3 TexDir = vec3(\n        RayDir.x*cos(NA.x) - RayDir.z*sin(NA.x),\n        (RayDir.y*cos(NA.y)) + (( RayDir.z*cos(NA.x) + RayDir.x*sin(NA.x) )*sin(NA.y)),\n        ( RayDir.z*cos(NA.x) + RayDir.x*sin(NA.x) )*cos(NA.y) - RayDir.y*sin(NA.y)\n    );\n    /*TexDir = RayDir*-(Normal*2.-1.);\n    TexDir = vec3(\n        TexDir.x,\n        (RayDir.y*cos(NA.y)+RayDir.z*sin(NA.y)),\n        (RayDir.z*cos(NA.y)-RayDir.y*sin(NA.y))\n       );\n    TexDir = vec3(\n        (TexDir.x*cos(NA.x)-TexDir.z*sin(NA.x)),\n        TexDir.y,\n        (TexDir.z*cos(NA.x)+TexDir.x*sin(NA.x))\n    );*/\n    uv = vec3((iNorm*TBN).xy,1);\n    uv = vec3(Transform(iNorm).xy, 1);\n    if (PBR){\n        vec2 edge = (((1.-mod(uv.xy*(vec2(uv.x<.5, uv.y<.5)*2.-1.), 1.)))-.5)*2.;\n        //vec3 TexDir = vec3(RayDir*TBN);\n        //TexDir = Transform(RayDir);\n        vec3 Coord = uv;\n        float t = 1.;\n        //Parallax\n        for (int b=0; b<ParallaxSamples; b++){\n            float Depth = length(texture(iChannel2, Coord.xy).rgb)/pow(3., .5);\n            //apply function for better depthmaps\n            Depth = 1.-pow(Depth, .3);\n            \n            if (abs(t-Depth)<Epsilon) break;\n            t -= (abs(t-Depth)/(t-Depth))/pow(2., float(b+1));\n            Coord.xy = (((TexDir.xy/TexDir.z)*(1.-t))*ParallaxDepth)+uv.xy;\n        }\n        uv += vec3(((TexDir.xy/TexDir.z)*(1.-t))*ParallaxDepth,0);\n        uv.z = (1.-t);\n        //parallax shadows (not self shadowing)\n        //get how close to an edge\n        //Color = vec3(max(edge.x, edge.y));\n        RayOrgn += -Normal*t*ParallaxDepth*max((t*ParallaxDepth)-max(edge.x,edge.y), 0.); //get factor so it doesn't have weird edge shadows\n    \n        //Auto Generate Data\n        iNorm = vec3(\n            length(texture(iChannel2, uv.xy+vec2(.001,0)).rgb)-length(texture(iChannel2, uv.xy-vec2(.001,0)).rgb),\n            length(texture(iChannel2, uv.xy-vec2(0,.001)).rgb)-length(texture(iChannel2, uv.xy+vec2(0,.001)).rgb),\n            length(texture(iChannel2, uv.xy).rgb)\n        )*vec3(1,(iNorm.z*2.)-1.,1./NormalMapStrength);\n        mat3 Tex = mat3(iNorm.z, iNorm.x, iNorm.x,\n                        iNorm.y, iNorm.z, iNorm.y,\n                        iNorm.x, iNorm.y, iNorm.z);\n        //N = normalize((5.*N*Tex)+N);\n    }\n    Color = pow(texture(iChannel2, uv.xy).rgb, vec3(2.2));\n    //Color = TexDir;\n}\n\nvoid LoadWorld(){\n    Seed = 33;\n    //for (int i=0; i<world.length(); i++){\n    //    world[i] = int((GetRand(.5,1.5)));\n    //}\n    world = int[](1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,1,1,2,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n    \n    LightPos[0] = vec3(1.25,4,5);\n    LightColor[0] = vec3(.4,.7,1);\n    LightProp[0] = vec2(6, .01);\n    /*\n    LightPos[1] = vec3(6,4,5);\n    LightColor[1] = vec3(.4,.7,1);\n    LightProp[1] = vec2(6, .5);\n    \n    LightPos[2] = vec3(5,-.1,6);\n    LightColor[2] = vec3(1,.7,.2);\n    LightProp[2] = vec2(24, .5);\n    \n    LightPos[3] = vec3(3,-.1,6);\n    LightColor[3] = vec3(1,.7,.2);\n    LightProp[3] = vec2(24, .5);\n    \n    LightPos[4] = vec3(3,4,0);\n    LightColor[4] = vec3(1,.7,.2);\n    LightProp[4] = vec2(4, .25);\n    \n    LightPos[5] = vec3(5,4,0);\n    LightColor[5] = vec3(1,.7,.2);\n    LightProp[5] = vec2(4, .25);\n    */\n}\n\nvoid PointTowards(in vec3 Coord){\n    RayDir = normalize(Coord-RayOrgn);\n}\n\nfloat VoxelIntersection(inout int HitID, in float MaxDist){\n    RayDir = normalize(RayDir); //failsafe\n    float t = 0.;\n    int BlockID;\n    \n    vec3 tCoord;\n    vec3 Coord = RayOrgn;\n    float mi;\n    \n    for (int i=0; i<int(pow(2., float(ViewDist))); i++){\n        if (t>MaxDist) break;\n        tCoord = (floor(Coord)+vec3(RayDir.x>0.,RayDir.y>0.,RayDir.z>0.)-Coord)/RayDir;\n        mi = min(min(tCoord.x, tCoord.y), tCoord.z);\n        t += mi+(Epsilon*.8);\n        Coord = RayOrgn+(RayDir*t);\n        if (Coord.x<0. || Coord.y<0. || Coord.z<0.) continue;\n        if (Coord.x>BlockSize || Coord.y>BlockSize || Coord.z>BlockSize) continue;\n        BlockID = int(floor(Coord.x)+(floor(Coord.y)*BlockSize)+(floor(Coord.z)*BlockSize*BlockSize));\n        if (world[BlockID]!=0){\n            HitID = BlockID;\n            return t;\n        }\n        \n    }\n    return 0.;\n}\n\nfloat AABBIntersection(in vec3 Pos[2]){\n    vec2 t = (vec2(Pos[0].x, Pos[1].x)-RayOrgn.x)/RayDir.x;\n    t = vec2(min(t[0],t[1]), max(t[0],t[1]));\n    \n    vec2 Ty = (vec2(Pos[0].y, Pos[1].y)-RayOrgn.y)/RayDir.y;\n    Ty = vec2(min(Ty[0],Ty[1]), max(Ty[0],Ty[1]));\n    \n    \n    if (t[0]>Ty[1] || Ty[0]>t[1]) return -1.;\n    \n    t = vec2(max(t[0], Ty[0]), min(t[1], Ty[1]));\n    \n    vec2 Tz = (vec2(Pos[0].z, Pos[1].z)-RayOrgn.z)/RayDir.z;\n    Tz = vec2(min(Tz[0],Tz[1]), max(Tz[0],Tz[1]));\n    \n    if (t[0]>Tz[1] || Tz[0]>t[1]) return -1.;\n    \n    t = vec2(max(t[0], Tz[0]), min(t[1], Tz[1]));\n    \n    if (t[0]<0.) return t[1]+Epsilon*10.;\n    return t[0];\n}\n\nfloat GetIntersection(inout int HitID, in bool Light, out vec3 lCol){\n    vec3 Hits[int(pow(2., 3.*float(Worldsize)))];\n    int HitCount = 1;\n    \n    float Closest = pow(2., float(ViewDist))*float(!Light) + (Dist*float(Light));\n    int CheckSize = int(pow(2., float(Worldsize)));\n    \n    vec3 Coord;\n    HitID = -1;\n    //Check Self\n    if (SelfShadowing && PBR && Light){\n        float t = uv.z;\n        float Depth;\n        vec3 TexDir = -Transform(-RayDir);\n        for(int i=0; i<ParallaxSamples; i++){\n            uv.xy += (uv.z/float(ParallaxSamples))*(TexDir.xy/-TexDir.z);\n            t -= uv.z/float(ParallaxSamples);\n            Depth = length(texture(iChannel2, uv.xy).rgb)/pow(3., .5);\n            Depth = pow(Depth, 3.);\n            if((1.-t)-Depth<-GetRand(0.,.1)){\n                HitID = HitBlock;\n                Closest = Epsilon*2.;\n            }\n        }\n    }\n    Closest = VoxelIntersection(HitID, Closest);\n    \n    lCol = vec3(1);\n    \n    vec3 TexColor = vec3(1);\n    vec4 TexMat = vec4(1,1,0,1);\n    vec3 N;\n    if (HitID!=-1) GetTexture(HitID, TexColor, TexMat, N);\n    lCol *= TexColor*(1.-TexMat.z);\n    return Closest;\n}\n\nvec3 GBNormal(in int ID){\n    vec3 Dir = RayOrgn-vec3(\n        floor(mod(float(ID), BlockSize))+.5,\n        floor(mod(float(ID), (BlockSize*BlockSize))/BlockSize)+.5,\n        floor(float(ID)/(BlockSize*BlockSize))+.5);\n    \n    float Inside = ((min(float(abs(Dir.x)>.5-Epsilon)+float(abs(Dir.y)>.5-Epsilon)+float(abs(Dir.z)>.5-Epsilon),float(PrevID!=ID)))*2.)-1.; //test if inside block\n    \n    if (abs(Dir.x)>max(abs(Dir.y),abs(Dir.z))) {return vec3(Dir.x/abs(Dir.x),0,0)*Inside;}\n    if (abs(Dir.y)>abs(Dir.z)) {return vec3(0,Dir.y/abs(Dir.y),0)*Inside;}\n    else {return vec3(0,0,Dir.z/abs(Dir.z))*Inside;}\n}\n\nvec3 SingleLight(in vec3 Pos, in int LightID){\n    vec3 Rand = vec3(GetRand(-.5,.5),GetRand(-.5,.5),GetRand(-.5,.5));\n    //cubify lights\n    Rand /= max(max(Rand.x,Rand.y), Rand.z)*2.;\n    RayDir = (LightPos[LightID]+(Rand*LightProp[LightID].y))-RayOrgn;\n    \n    Dist = length(RayDir);\n    RayDir /= Dist;\n    \n    float a = dot(RayDir, Normal);\n    if (a<0.) {RayOrgn = Pos; return vec3(0);}\n    \n    RayOrgn += RayDir*Epsilon*1.;\n    int Hit = -1;\n    vec3 lCol;\n    GetIntersection(Hit, true, lCol);\n    RayOrgn = Pos;\n    return (LightProp[LightID].x*LightColor[LightID]*lCol / max((Dist*Dist), 4.)) * (a*float(LightPos.length()))/float(LightSamples);\n}\n\nvec3 GetLight(){\n    vec3 Dir = RayDir;\n    vec3 LightColor;\n    for (int i=0; i<LightSamples/LightPos.length(); i++){\n        for (int ID=0; ID<LightPos.length(); ID++){\n            LightColor += SingleLight(RayOrgn, ID);\n        }\n    }\n    int LightID;\n    for (int i; i<int(mod(float(LightSamples), float(LightPos.length()))); i++){\n        LightID = int(GetRand(.5,float(LightPos.length())+.5));\n        LightColor += SingleLight(RayOrgn, LightID);\n    }\n    \n    RayDir = Dir;\n    return LightColor;\n}\n\nvec3 PathTrace(){\n    vec3 PixColor;\n    vec3 RayColor = vec3(1,1,1);\n    float RayRef = 1.0003;\n    PrevID = -1;\n    \n    for (int b=0; b<Bounces; b++){\n        int HitID = -1;\n        vec3 f;\n        float t = GetIntersection(HitID, false, f);\n        if (HitID == -1) return PixColor+(vec3(.4,.6,1.)*RayColor*.4);\n        RayOrgn += RayDir*t;\n        Normal = GBNormal(HitID);\n        HitBlock = HitID;\n        \n        vec3 TexColor;\n        vec4 TexProp;\n        //x: Roughness, y: Refraction Probability, z: Light Obsorbancy, w: Refractive Index\n        GetTexture(HitID, TexColor, TexProp, Normal);\n        \n        TexProp.y *= 1.-((1.-TexProp.x)*(pow((1.+dot(RayDir, Normal))-.005, 4.)+.05));\n        \n        bool Ref = GetRand(Epsilon,1.)>TexProp.y;\n        \n        RayColor *= (TexColor*TexProp.z)+vec3(1.-TexProp.z);\n        PixColor += RayColor*GetLight()*TexProp.x;\n        \n        vec3 Rand = vec3(GetRand(-1.,1.),GetRand(-1.,1.),GetRand(-1.,1.));\n        if (dot(Rand, Normal)*((float(Ref)*2.)-1.) < 0.) Rand *= -1.;\n        \n        if (HitID==PrevID) {TexProp.w = 1.003;}\n        \n        vec3 Bounce;\n        if (Ref) {Bounce=reflect(RayDir, Normal);} else {Bounce=refract(RayDir, Normal, RayRef/TexProp.w); RayRef=TexProp.w;}\n        \n        RayDir = (Bounce*(1.-TexProp.x))+(Rand*TexProp.x);\n        RayOrgn += RayDir*(Epsilon*2.);\n        PrevID = HitID;\n    }\n    \n    return PixColor;\n}\n\nvoid GetData(){\n    iter = (texture(iChannel1, vec2(.35,.05)).x*1.)+1.;\n    CamYaw = texture(iChannel1, vec2(.25,.05)).x*57.;\n    CamPitch = texture(iChannel1, vec2(.25,.05)).y*57.;\n    RayOrgn = texture(iChannel1, vec2(.15,.05)).xyz;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    LoadWorld();\n    GetData();\n    Seed = int(mod(float(iFrame), 1000.)*1720.+fragCoord.x+(fragCoord.y*120.)+(iTime*iResolution.x+20.));\n    \n    vec2 ImgCoord = fragCoord+vec2(GetRand(-.25,.25),GetRand(-.25,.25));\n    //Ray Calculation\n    PointTowards(RayOrgn+vec3(((ImgCoord-(iResolution.xy/2.))/iResolution.y)*vec2(1,iResolution.x/iResolution.y), FocalDist));\n    float Raw = (CamYaw/360.)*-2.*Pi;\n    float Yawn = (CamPitch/360.)*2.*Pi;\n    RayDir = vec3(RayDir.x,(RayDir.y*cos(Yawn)+RayDir.z*sin(Yawn)),(RayDir.z*cos(Yawn)-RayDir.y*sin(Yawn)));\n    RayDir = vec3((RayDir.x*cos(Raw)-RayDir.z*sin(Raw)),RayDir.y,(RayDir.z*cos(Raw)+RayDir.x*sin(Raw)));\n    \n    vec3 Pos = RayOrgn;\n    vec3 Dir = RayDir;\n    \n    vec3 Color;\n    for (int s=0; s<Samples; s++){\n        RayOrgn = Pos;\n        \n        Color += PathTrace();\n        //int Hit = -1;\n        //float t = VoxelIntersection(Hit);\n        //Color += vec3(t/10.)*float(Hit>-1);\n        RayDir = Dir;\n    }\n    fragColor = vec4((clamp(Color,0.,1.)/iter)/float(Samples)+texture(iChannel0, fragCoord/iResolution.xy).rgb*(1.-(1./iter)),1);\n}","name":"Buffer B","description":"","type":"buffer"}]}