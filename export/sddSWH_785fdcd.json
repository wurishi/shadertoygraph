{"ver":"0.1","info":{"id":"sddSWH","date":"1702458883","viewed":28,"name":"RayMarching CG Test","username":"ThomasJld","description":"Raymarching Test","likes":1,"published":1,"flags":0,"usePreview":1,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 120.\n#define MAX_STEP 32\n#define MIN_DIST 0.1\n#define EPS 0.001\n#define FXAA 1\n\nfloat n21(vec2 p){ return fract(sin(p.x * 12.9898 + p.y * 78.233)* 43758.5453); }\n\nconst int numsphere = 12;\nconst int steps = 4;\nconst float path[2*steps*numsphere] = float[2*steps*numsphere](\n     10.0, 0.0,  10.0,  20.0,  20.0,  20.0,  20.0,   0.0,\n     10.0, 0.0,  10.0, -20.0,  20.0, -20.0,  20.0,   0.0,\n     10.0, 0.0,  10.0,  20.0,   0.0,  20.0,   0.0,   0.0,\n     10.0, 0.0,  10.0, -20.0,   0.0, -20.0,   0.0,   0.0,\n     10.0, 0.0,  20.0,   0.0,  20.0,  20.0,  10.0,  20.0,\n     10.0, 0.0,  20.0,   0.0,  20.0, -20.0,  10.0, -20.0,\n    -10.0, 0.0, -10.0,  20.0, -20.0,  20.0, -20.0,   0.0,\n    -10.0, 0.0, -10.0, -20.0, -20.0, -20.0, -20.0,   0.0,\n    -10.0, 0.0, -10.0,  20.0,   0.0,  20.0,   0.0,   0.0,\n    -10.0, 0.0, -10.0, -20.0,   0.0, -20.0,   0.0,   0.0,\n    -10.0, 0.0, -20.0,   0.0, -20.0,  20.0, -10.0,  20.0,\n    -10.0, 0.0, -20.0,   0.0, -20.0, -20.0,  -10.0, -20.0\n);\n\n\nconst float radi[steps] = float[steps](3., 3., 3., 3.);\n\n\n\n\nstruct PinholeCamera { float fov; vec3 pos, dir; };\nstruct Ray { vec3 origin, dir; };\nstruct PointLight { vec3 pos, col; float r; };\n\nmat3 computeViewMatrix(PinholeCamera cam){\n    vec3 cw = normalize(cam.dir);\n    vec3 cr = vec3(0., 1., 0.);\n    vec3 cu = normalize(cross(cw, cr));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\n\n\n\nconst int numlights = 3;\nconst vec3 light_pos = vec3(60., 20.0, -20.0);\nconst vec3 light_color = vec3(0.91, 0.52, 0.47);\nconst PointLight light = PointLight(light_pos, light_color, 2.);\n\nconst vec3 light_pos2 = vec3(-60, 20.0, -20.0);\nconst vec3 light_color2 = vec3(0.91, 0.73, 0.47);\nconst PointLight light2 = PointLight(light_pos2, light_color2, 2.);\n\nconst vec3 light_pos3 = vec3(0.0, -20.0, 100.0);\nconst vec3 light_color3 = vec3(0.47, 0.91, 0.91);\nconst PointLight light3 = PointLight(light_pos3, light_color3, 2.);\n\nconst PointLight lights[numlights] = PointLight[numlights](\n    light, light2, light3\n);\n\nconst vec3 albedo = vec3(0.49, 0.93, 0.49);\n\n\nfloat smin( float a, float b, float k ) //iq\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat sphereDist(vec3 point, vec3 sphere, float r){\n    return length(sphere - point) - r;\n}\n\nvec2 sceneDist(vec3 point) {\n    float speed = .5;\n    int current = int(mod(iTime*speed, 4.));\n    int next = int(mod(float(current+1), 4.));\n    float percentage = mod(4.0*iTime*speed, 4.)/4.;\n\n    vec4 spheres[numsphere];\n    spheres[0] = vec4(\n        path[2*current] + percentage*(path[2*next] - path[2*current]),\n        path[2*current + 1] + percentage*(path[2*next + 1] - path[2*current + 1]),\n        30.0, radi[current] + percentage*(radi[next] - radi[current]));\n    float d = sphereDist(point, spheres[0].xyz, spheres[0].w);\n    float smooth_d = d;\n    float new_d;\n    int mat_index = 0;\n\n    for(int i = 1; i < numsphere; i++){\n        spheres[i] = vec4(\n        path[i*8 + 2*current] + percentage*(path[i*8 + 2*next] - path[i*8 + 2*current]),\n        path[i*8 + 2*current + 1] + percentage*(path[i*8 + 2*next + 1] - path[i*8 + 2*current + 1]),\n        30.0, radi[current] + percentage*(radi[next] - radi[current]));\n\n        new_d = sphereDist(point, spheres[i].xyz, spheres[i].w);\n        d = min(d, new_d);\n        smooth_d = smin(smooth_d, new_d, 10.);\n\n        if(d == new_d) mat_index = i;\n    }\n\n    for(int i = 0; i < numlights; i++){\n\n        new_d = sphereDist(point, lights[i].pos, lights[i].r);\n        d = min(d, new_d);\n        smooth_d = smin(smooth_d, new_d, 10.);\n\n        if(d == new_d) mat_index = i + numsphere;\n    }\n\n    return vec2(smooth_d, mat_index);\n}\n\nvec3 normal(vec3 r) {\n    const vec2 h = vec2(EPS, 0.);\n    return normalize(vec3(\n        sceneDist(r + h.xyy).x - sceneDist(r - h.xyy).x,\n        sceneDist(r + h.yxy).x - sceneDist(r - h.yxy).x,\n        sceneDist(r + h.yyx).x - sceneDist(r - h.yyx).x\n    ));\n}\n\n\nfloat lighting(vec3 norm, vec3 light){\n    return max(-dot(norm, light), 0.);\n}\n\n\nvec3 render(Ray ray, PinholeCamera cam){\n    vec3 col = vec3(0.58, 0.78, 0.84);\n    vec3 point = ray.origin;\n\n    float d = sceneDist(cam.pos).x;\n    vec2 res;\n\n\n    for(int t = 0; t < MAX_STEP; t++){\n        point = point + d*ray.dir;\n        res = sceneDist(point);\n        d = res.x;\n        if(res.x < MIN_DIST) {\n\n            vec3 object_normal = normal(point);\n\n            vec3 ligth_normal = normalize(point - light.pos);\n            vec3 ligth_normal2 = normalize(point - light2.pos);\n            vec3 ligth_normal3 = normalize(point - light3.pos);\n\n            if(int(res.y) < numsphere){\n                col = vec3(0.1);\n                col += vec3(light.col*pow(lighting(object_normal, ligth_normal), 1.0));\n                col += vec3(light2.col*pow(lighting(object_normal, ligth_normal2), 1.0));\n                col += vec3(light3.col*pow(lighting(object_normal, ligth_normal3), 1.0));\n\n                col = col * albedo;\n\n                d = 1.;\n                ray.dir -= 2.*dot(ray.dir,object_normal)*object_normal;\n                vec3 other_col = vec3(0.);\n\n                for(int t = 0; t < MAX_STEP; t++){\n                    point = point + d*ray.dir;\n                    res = sceneDist(point);\n                    d = res.x;\n                    if(res.x < MIN_DIST) {\n\n                        vec3 object_normal = normal(point);\n\n                        vec3 ligth_normal = normalize(point - light.pos);\n                        vec3 ligth_normal2 = normalize(point - light2.pos);\n                        vec3 ligth_normal3 = normalize(point - light3.pos);\n\n                        if(int(res.y) < numsphere){\n                            other_col = vec3(0.1);\n                            other_col += vec3(light.col*pow(lighting(object_normal, ligth_normal), 1.0));\n                            other_col += vec3(light2.col*pow(lighting(object_normal, ligth_normal2), 1.0));\n                            other_col += vec3(light3.col*pow(lighting(object_normal, ligth_normal3), 1.0));\n\n                            other_col = other_col * albedo;\n                            col += 0.3*other_col;\n\n\n                            d = 1.;\n                            ray.dir -= 2.*dot(ray.dir,object_normal)*object_normal;\n                            vec3 other_col = vec3(0.);\n\n                            for(int t = 0; t < MAX_STEP; t++){\n                                point = point + d*ray.dir;\n                                res = sceneDist(point);\n                                d = res.x;\n                                if(res.x < MIN_DIST) {\n\n                                    vec3 object_normal = normal(point);\n\n                                    vec3 ligth_normal = normalize(point - light.pos);\n                                    vec3 ligth_normal2 = normalize(point - light2.pos);\n                                    vec3 ligth_normal3 = normalize(point - light3.pos);\n\n                                    if(int(res.y) < numsphere){\n                                        other_col = vec3(0.1);\n                                        other_col += vec3(light.col*pow(lighting(object_normal, ligth_normal), 1.0));\n                                        other_col += vec3(light2.col*pow(lighting(object_normal, ligth_normal2), 1.0));\n                                        other_col += vec3(light3.col*pow(lighting(object_normal, ligth_normal3), 1.0));\n\n                                        other_col = other_col * albedo;\n                                        col += 0.1*other_col;\n                                    }\n                                    else{\n                                        other_col = 3.*lights[int(res.y) - numsphere].col;\n                                        col += 0.2*other_col;\n                                    }\n\n                                    // col *= vec3(1., 0.5, res.y/float(numsphere));\n                                    break;\n                                }\n                                if(length(point-cam.pos) > MAX_DIST) break;\n                            }\n\n\n                        }\n                        else{\n                            other_col = 3.*lights[int(res.y) - numsphere].col;\n                            col += other_col;\n                        }\n\n                        // col *= vec3(1., 0.5, res.y/float(numsphere));\n                        break;\n                    }\n                    if(length(point-cam.pos) > MAX_DIST) break;\n                }\n\n\n            }\n            else{\n                col = lights[int(res.y) - numsphere].col;\n            }\n\n            // col *= vec3(1., 0.5, res.y/float(numsphere));\n            break;\n        }\n        if(length(point-cam.pos) > MAX_DIST) break;\n    }\n\n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col;\n\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    mouse = (mouse - 0.5)*2.0;\n    mouse.x = mouse.x*iResolution.x/iResolution.y;\n\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = (uv - 0.5)*2.0;\n    uv.x = uv.x*iResolution.x/iResolution.y;\n\n    vec3 scene_center = vec3(0, 0, 30);\n    float radius = 45.;\n    float speed = 0.5;\n\n    float cam_fov = 65.;\n    vec3 cam_pos = vec3(radius * sin(iTime * speed), scene_center.y, scene_center.z - radius * cos(iTime * speed));\n    vec3 cam_dir = vec3(-sin(iTime * speed), 0, cos(iTime * speed));\n    PinholeCamera cam = PinholeCamera(cam_fov, cam_pos, cam_dir);\n    mat3 view = computeViewMatrix(cam);\n\n\n    vec3 ray_origin = cam.pos;\n    vec3 ray_dir = view * normalize(vec3(uv, 1.0));\n\n    Ray ray = Ray(ray_origin, ray_dir);\n\n    for(int y = 0; y < FXAA; y++){\n        for(int x = 0; x < FXAA; x++){\n            vec2 offset = vec2(n21(vec2(x))*EPS, n21(vec2(y))*EPS);\n            ray.dir = view * normalize(vec3(uv + offset, 1.0));\n            col += render(ray, cam);\n        }\n    }\n    col /= float(FXAA)*float(FXAA);\n\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}