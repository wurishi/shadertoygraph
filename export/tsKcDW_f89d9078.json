{"ver":"0.1","info":{"id":"tsKcDW","date":"1602878674","viewed":399,"name":"Tunable Denoising Filter","username":"Hatchling","description":"A tunable filter that weights a neighborhood of pixels based on distance and difference from the center pixel, and sorts them on luminance. Some combination of these pixels are blended together, depending on window parameters.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["denoisemediannonlinearbluredgeavoidinggaussian"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Use the mouse to control some of the effect parameters.\n    weightedMedian\n    (\n        iChannel0, \n        fragColor, \n        fragCoord,\n        \n        // Sampling distance scaled to emphasize effect.\n        3,\n        \n        // Minimum filter at left, median in center, maximum filter at right.\n    \t(iMouse.x != 0. ? iMouse.x : fragCoord.x) / iResolution.x,\n        \n        // Window size varies vertically:\n        // Sampling width of N at top: \n        //    - All samples considered\n        //    - Functions as a Gaussian filter if color difference sensivitiy is 0.\n        // Sampling width of 1 at center,\n        //    - If pixels are uniformly weighted, functions as a traditional min/med/max filter.\n        // Sampling width of 0 at bottom.\n        //    - Selects only one pixel, producing harsher results.\n        (iMouse.y != 0. ? iMouse.y : fragCoord.y) / iResolution.y,\n        \n        // Color difference sensitivity.\n        50.,\n        \n        // How much to blend filtered image with original.\n        // Negative values emphasize noise.\n        // Values greater than 1 just look... weird.\n        1.\n    );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const int radius = 2;\nconst float stdev = float(radius) * 0.75;\nconst int boxWidth = radius * 2 + 1;\nconst int count = boxWidth*boxWidth;\n\nstruct WeightedSample\n{\n    vec3 color;\n    float lum;\n    float weight;\n};\n\nWeightedSample colors[count];\n\nfloat luminance(vec3 color) { return dot(color, vec3(0.2126, 0.7152, 0.0722)); }\n\nfloat gaussian(float sqrMag) { return exp(-sqrMag/(stdev*stdev)); }\n\nfloat squareDistance(vec3 a, vec3 b)\n{\n    a -= b;\n    return dot(a, a);\n}\n\n// I didn't write this, but I forget the source I copied it from.\nvoid sort(inout WeightedSample values[count])\n{\n\tint inc = count / 2;\n\twhile (inc > 0)\n\t{\n\t\tfor (int i = inc; i < count; ++i)\n\t\t{\n\t\t\tWeightedSample tmp = values[i];\n\t\t\tint j = i;\n\t\t\twhile (j >= inc && values[j - inc].lum > tmp.lum)\n\t\t\t{\n\t\t\t\tvalues[j] = values[j - inc];\n\t\t\t\tj -= inc;\n\t\t\t}\n\t\t\tvalues[j] = tmp;\n\t\t}\n\t\tinc = int(float(inc) / 2.2 + 0.5);\n\t}\n}\n\nvoid weightedMedian(\n    sampler2D tex, \n    out vec4 fragColor, \n    in vec2 fragCoord, \n    in int spread, \n    in float minOrMax, \n    in float windowSize01, \n    in float colorDifferenceSensitivity,\n\tin float blend)\n{\n    vec3 centerColor = texelFetch(tex, ivec2(fragCoord), 0).rgb;\n    \n    int index = 0;\n    for(int x = -radius; x <= radius; x++)\n    for(int y = -radius; y <= radius; y++)\n    {\n        vec3 color;\n        float weight;\n        if(x == 0 && y == 0)\n        { \n           \tcolor = centerColor;\n        \tweight = gaussian(0.);\n        }\n        else\n        {\n            color = texelFetch(tex, ivec2(fragCoord) + ivec2(x,y) * spread, 0).rgb;\n            float colorDiff = squareDistance(color, centerColor) * colorDifferenceSensitivity;\n        \tweight = gaussian(float(x*x+y*y)+colorDiff);\n        }\n        \n        \n        colors[index] = WeightedSample(color, luminance(color), weight);\n        index++;\n    }\n    \n    sort(colors);\n    \n    float starts[count];\n    float ends[count];\n    \n    float sum = 0.;\n    for(int i = 0; i < count; i++)\n    {\n        starts[i] = sum;\n        sum += colors[i].weight;\n        ends[i] = sum;\n    }\n    \n    vec3 colorAccum = vec3(0);\n    float colorWeight = 0.;\n    \n    // The range 0 to 1 gets mapped to 0 to sum,\n    // but where 0.5 gets mapped to 1.\n    float ratio = 1. / float(sum);\n    float exponent = -log(ratio)/log(2.);\n    float windowSize = pow(windowSize01, exponent) * float(sum);\n    \n    // The \"minOrMax\" parameter determines where within the\n    // stack of sorted pixels the window will overlap.\n    float windowStart = minOrMax * (sum - windowSize);\n    float windowEnd = windowStart + windowSize;\n    \n    // Weigh the samples by how much they overlap with the window.\n    for(int i = 0; i < count; i++)\n    {\n        if(windowStart >= ends[i])\n            continue;\n        \n        if(windowEnd <= starts[i])\n            break;\n        \n        float s = max(windowStart, starts[i]);\n        float e = min(windowEnd, ends[i]);\n        \n        float w = e-s;\n        \n        colorAccum += colors[i].color * w;\n        colorWeight += w;\n    }\n    \n    vec3 col = colorAccum / colorWeight;\n    \n    col = mix(centerColor, col, blend);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Coordinates for channel, in texel space.\n    vec2 uv = fragCoord/iChannelResolution[0].xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}