{"ver":"0.1","info":{"id":"flfGDs","date":"1623076263","viewed":132,"name":"Ray Marching - Normal","username":"ChaosOfZen","description":"A basic ray marching shader.\nAdapted from: https://timcoster.com/2020/02/11/raymarching-shader-pt1-glsl/","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sphere","color"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Adapted from: https://timcoster.com/2020/02/11/raymarching-shader-pt1-glsl/\n\n\n\n// Constants\n#define PI 3.1415925359\n#define TWO_PI 6.2831852\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST .01\n \nfloat GetDist(vec3 p) \n{\n    vec4 s = vec4(0,1,6. + sin(iTime)*3.,1); //Sphere xyz is position w is radius\n    float sphereDist = length(p-s.xyz) - s.w;\n    float planeDist  = p.y;\n    float d = min(sphereDist,planeDist);\n \n    return d;\n}\n \n/*\n\nDistance field\nThe ray march loop marches from the origin/camera into the direction of the scene. \nAfter each iteration it checks if the distance to the scene is smaller than the minimum distance(SURACE_DIST). \nIf so, it returns the distance to the object. If the distance is greater than the max distance, \nmeaning the ray hasnâ€™t hit an object it also breaks out of the loop.\n*/  \n \nfloat RayMarch(vec3 ro, vec3 rd) \n{\n    float dO = 0.; //Distane Origin\n    for(int i=0;i<MAX_STEPS;i++)\n    {\n        vec3 p = ro + rd * dO;\n        float ds = GetDist(p); // ds is Distance Scene\n        dO += ds;\n        if(dO > MAX_DIST || ds < SURFACE_DIST) break;\n    }\n    return dO;\n}\n\n/*\n\nNormals\nTo get the normals the point where the raymarch hits is used and a small amount (Epsilon) \nis added to the point in the right, up and forward direction. This new offset point is \nthen normalized to turn it into a unit vector/direction.\n*/\n \nvec3 GetNormal(vec3 p)\n{ \n    float d = GetDist(p); // Distance\n    vec2 e = vec2(.01,0); // Epsilon\n    vec3 n = d - vec3(\n    GetDist(p-e.xyy),  \n    GetDist(p-e.yxy),\n    GetDist(p-e.yyx));\n   \n    return normalize(n);\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0,1,0); // Ray Origin/Camera\n    vec3 rd = normalize(vec3(uv.x,uv.y,1)); // Ray Direction\n   \n    float d = RayMarch(ro,rd); // Distance\n   \n    vec3 p = ro + rd * d;\n    //float dif = GetLight(p); // Diffuse lighting\n    //d/= 10.;\n    vec3 color = vec3(0);\n    //color = vec3(dif);\n    color = GetNormal(p);\n \n    // Set the output color\n    fragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}