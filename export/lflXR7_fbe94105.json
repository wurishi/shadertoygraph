{"ver":"0.1","info":{"id":"lflXR7","date":"1705372684","viewed":63,"name":"CRT Forked","username":"Nieb","description":"See Arty.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["postprocessing","crt"],"hasliked":0,"parentid":"tssSzM","parentname":"Old CRT screen emulation"},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\n#define PI 3.14159265359\n\n//  CRT Parameters:\nfloat CRT_IntensityOut          = 1.1;  //  Intensity of CRT cell outline.\nfloat CRT_IntensityIn           = 0.9;  //  Intensity of CRT cell inside.\n\nfloat CRT_ScanLineIntensity     = 1.9;\n\nfloat CRT_HaloRadius            = 1.8;  //  Radius of the ellipsis halo.\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\n// from rez in Glenz vector form Hell\nfloat rand(in vec2 p,in float t) {\n    return fract(sin(dot(p+mod(t,1.0),vec2(12.9898,78.2333)))*43758.5453);\n}\n\n//==================================================================================================\nfloat CRT_ScanLines(vec2 ScreenUV, vec2 vRes) {\n    float dy = ScreenUV.y * vRes.y;\n          dy = fract(dy) - 0.5;\n\n    return exp2(-dy*dy * CRT_ScanLineIntensity);\n}\n\n//==================================================================================================\nvec3 CRT_Mask(vec2 FragCoord) {\n    FragCoord    = floor(FragCoord * vec2(1.0, 0.5));\n    FragCoord.x += FragCoord.y * 3.0;\n    FragCoord.x  = fract(FragCoord.x / 6.0);\n\n    vec3 c = vec3(CRT_IntensityOut);\n\n    if      (FragCoord.x < 0.333) c.r = CRT_IntensityIn;\n    else if (FragCoord.x < 0.666) c.g = CRT_IntensityIn;\n    else                          c.b = CRT_IntensityIn;\n\n    return c;\n}\n\n//==================================================================================================\nfloat CRT_Halo(vec2 ScreenUV) {\n    return CRT_HaloRadius \n         - distance(ScreenUV, vec2(0.2,0.5)) \n         - distance(ScreenUV, vec2(0.8,0.5));\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\n//  Virtual Screen Stuff:\n//==================================================================================================\nvec2 Virtual_Resolution(float vRes_Y) {\n    return vec2( round(vRes_Y * (iResolution.x/iResolution.y)), vRes_Y );\n}\n\n//==================================================================================================\nvec2 Virtual_FragCoord(vec2 FragCoord, vec2 vRes) {\n    return FragCoord * (vRes/iResolution.xy);\n}\n\n//==================================================================================================\n//  Mipmapping must be disabled, otherwise artifacts can occur.\nvec2 Virtual_ScreenUV(vec2 FragCoord, vec2 vRes) {\n\n    vec2 RealToVrtl = vRes/iResolution.xy;\n\n    #if 0\n        vec2 OffsetNoise = vec2(0.0);\n    #elif 1\n        vec2 OffsetNoise = vec2( rand(FragCoord.xy, iTime*0.002)*0.5-0.25, 0.0 );\n    #else\n        vec2 OffsetNoise = vec2( rand(FragCoord.xy, iTime*0.002)*0.5-0.25, rand(FragCoord.yx, iTime*0.002)*0.5-0.25 );\n    #endif\n\n    #if 0\n        return floor(FragCoord * RealToVrtl) / vRes;\n    #elif 0\n        return (FragCoord * RealToVrtl - 0.5 + OffsetNoise) / vRes;\n    #else\n        vec2 vFragCoord = FragCoord * RealToVrtl - 0.5;\n\n        float P = 2.0;\n        //if (iMouse.x > 0.5) { P = 1.0 + iMouse.x/iResolution.x*16.0; }\n\n        vec2 Interp = fract(vFragCoord * 2.0);\n        Interp.x = (fract(vFragCoord.x) < 0.5)  ?  pow(Interp.x, P) * 0.5  :  (1.0 - pow(1.0-Interp.x, P)) * 0.5 + 0.5;\n        Interp.y = (fract(vFragCoord.y) < 0.5)  ?  pow(Interp.y, P) * 0.5  :  (1.0 - pow(1.0-Interp.y, P)) * 0.5 + 0.5;\n\n        return (floor(vFragCoord) + Interp + OffsetNoise) / vRes;\n    #endif\n}\n\n//==================================================================================================\nvec4 TestVirtualScreen(vec2 FragCoord, vec2 vRes) {\n    vec2 Pixel   = fract(FragCoord * (vRes/iResolution.xy));\n         Pixel.x = (Pixel.x > 0.98 || Pixel.x < 0.02) ? 1.0 : 0.0;\n         Pixel.y = (Pixel.y > 0.98 || Pixel.y < 0.02) ? 1.0 : 0.0;\n    return vec4(0.0, 0.0, 0.0, max(Pixel.x, Pixel.y));\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\nvec4 Nyan(vec2 Pos, float Rot, float Scl, vec2 FragCoord) {\n    const vec2 Pxl  = vec2( 1.0/256.0,  1.0/32.0);\n    const vec2 Siz  = vec2(40.0/256.0, 32.0/32.0);\n    const vec2 SizH = vec2(20.0/256.0, 16.0/32.0);\n\n    int Frame = int(floor(iTime*12.0)) % 6;   // 0 to 5\n\n    vec2 UV    = rot(FragCoord-Pos, Rot) * Pxl;\n         UV   /= Scl;                         //  Scale\n         UV   += SizH;                        //  Position @ Center of sprite.\n         UV    = clamp(UV, vec2(0.0), Siz);\n         UV.x += float(Frame) * Siz.x;        //  Offset UV.x to current frame.\n         UV.y += (Frame <= 1) ? -Pxl.y : 0.0; //  Fix frames 0,1 vertical position.\n\n    return texture(iChannel3, UV);\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\nvoid mainImage(out vec4 FragColor, in vec2 FragCoord) {\n    //==============================================================================================\n    vec2       vRes = Virtual_Resolution(120.0);\n    vec2 vFragCoord = Virtual_FragCoord(FragCoord, vRes);\n    vec2  vScreenUV = Virtual_ScreenUV(FragCoord, vRes);\n\n    vec2   ScreenUV = FragCoord.xy/iResolution.xy;\n    //==============================================================================================\n    #if 0\n        vec3 Clr_BG = SubTexture(iChannel0, vScreenUV, vRes).rgb;\n    #elif 1\n        vec3 Clr_BG = SubTexture(iChannel1, vScreenUV, vRes).rgb;\n    #elif 1\n        vec3 Clr_BG = SubTexture(iChannel2, vScreenUV, vRes).rgb;\n    #else\n        vec3 Clr_BG = vec3(0.0,0.2,0.4);\n    #endif\n    //==============================================================================================\n    #if 0\n        vec2  MeowPos  = vRes*0.5;\n              MeowPos += vec2( cos(iTime*1.1) * (vRes.x*0.1875 ),\n                               sin(iTime*1.9) * (vRes.y*0.0625));\n        float MeowRot  = 0.065 + sin(iTime*2.7)*0.1;\n        float MeowScl  = 1.1   + sin(iTime    )*0.2;\n        vec4 Clr_Meow = Nyan(MeowPos, MeowRot, MeowScl, floor(vFragCoord));\n    #elif 0\n        vec4 Clr_Meow = TestVirtualScreen(FragCoord, vRes);\n    #else\n        vec4 Clr_Meow = vec4(0.0);\n    #endif\n    //==============================================================================================\n    FragColor.rgb = mix(Clr_BG, Clr_Meow.rgb, Clr_Meow.a);\n    #if 1\n        FragColor.rgb *= CRT_ScanLines(ScreenUV, vRes);\n        FragColor.rgb *=      CRT_Mask(FragCoord);\n        FragColor.rgb *=      CRT_Halo(ScreenUV);\n    #endif\n    //==============================================================================================\n    FragColor.a = 1.0;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\nfloat sRGB_To_Linear(float v) { return (v <= 0.04044823627710820) ? v / 12.92 : pow((v+0.055)/1.055, 2.4); }\nfloat Linear_To_sRGB(float v) { return (v <= 0.00313066844250063) ? v * 12.92 : pow(v, 0.41666666666666666)*1.055 - 0.055; }\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//   INPUT: (0..1, ANY, ANY)\n//  OUTPUT: vA to vB\nfloat SmoothMix(float vP, float vA, float vB) {\n    float DltAB = vB-vA;\n    float LinStep = clamp((vP*DltAB)/(DltAB), 0.0, 1.0);\n    float SmoStep = (LinStep*LinStep) * (3.0 - 2.0*LinStep);\n    return vA*(1.0-SmoStep) + vB*(SmoStep);\n}\nvec2 SmoothMix(vec2 vP, vec2 vA, vec2 vB) {\n    vec2 DltAB = vB-vA;\n    vec2 LinStep = clamp((vP*DltAB)/(DltAB), 0.0, 1.0);\n    vec2 SmoStep = (LinStep*LinStep) * (3.0 - 2.0*LinStep);\n    return vA*(1.0-SmoStep) + vB*(SmoStep);\n}\nvec3 SmoothMix(vec3 vP, vec3 vA, vec3 vB) {\n    vec3 DltAB = vB-vA;\n    vec3 LinStep = clamp((vP*DltAB)/(DltAB), 0.0, 1.0);\n    vec3 SmoStep = (LinStep*LinStep) * (3.0 - 2.0*LinStep);\n    return vA*(1.0-SmoStep) + vB*(SmoStep);\n}\nvec4 SmoothMix(vec4 vP, vec4 vA, vec4 vB) {\n    vec4 DltAB = vB-vA;\n    vec4 LinStep = clamp((vP*DltAB)/(DltAB), 0.0, 1.0);\n    vec4 SmoStep = (LinStep*LinStep) * (3.0 - 2.0*LinStep);\n    return vA*(1.0-SmoStep) + vB*(SmoStep);\n}\n\n//======================================================================================================================\n//   INPUT: (0..1, ANY, ANY, ANY, ANY)\n//  OUTPUT: v00 to v11\nfloat BiMix( vec2 vP, float v00, float v10,\n                      float v01, float v11 ) {\n    vec2 ivP = 1.0-vP;\n    return (v00 * ivP.x * ivP.y) + (v10 * vP.x * ivP.y) +\n           (v01 * ivP.x *  vP.y) + (v11 * vP.x *  vP.y);\n}\nvec2 BiMix( vec2 vP, vec2 v00, vec2 v10,\n                     vec2 v01, vec2 v11 ) {\n    vec2 ivP = 1.0-vP;\n    return (v00 * ivP.x * ivP.y) + (v10 * vP.x * ivP.y) +\n           (v01 * ivP.x *  vP.y) + (v11 * vP.x *  vP.y);\n}\nvec3 BiMix( vec2 vP, vec3 v00, vec3 v10,\n                     vec3 v01, vec3 v11 ) {\n    vec2 ivP = 1.0-vP;\n    return (v00 * ivP.x * ivP.y) + (v10 * vP.x * ivP.y) +\n           (v01 * ivP.x *  vP.y) + (v11 * vP.x *  vP.y);\n}\nvec4 BiMix( vec2 vP, vec4 v00, vec4 v10,\n                     vec4 v01, vec4 v11 ) {\n    vec2 ivP = 1.0-vP;\n    return (v00 * ivP.x * ivP.y) + (v10 * vP.x * ivP.y) +\n           (v01 * ivP.x *  vP.y) + (v11 * vP.x *  vP.y);\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//  Mipmapping must be disabled, otherwise artifacts can occur.\nvec4 SubTexture(sampler2D Texture, vec2 UV, vec2 SubRes) {\n    UV = UV*SubRes;\n    vec2 uv0 = floor(UV) / SubRes;\n    vec2 uv1 =  ceil(UV) / SubRes;\n\n    vec4 t00 = texture(Texture,      uv0           );  vec4 t10 = texture(Texture, vec2(uv1.x, uv0.y) );\n    vec4 t01 = texture(Texture, vec2(uv0.x, uv1.y) );  vec4 t11 = texture(Texture,      uv1           );\n\n    return BiMix( fract(UV),  t00, t10, t01, t11 );\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\nvec2 rot(vec2 vP, float Theta) {\n    Theta = -Theta; // Theta is clockwise.\n    float CosT = cos(Theta);\n    float SinT = sin(Theta);\n\n    return vec2(vP.x*CosT - vP.y*SinT,\n                vP.x*SinT + vP.y*CosT );\n}\n\n//======================================================================================================================\nvec2 rot(vec2 vP, vec2 Pivot, float Theta) {\n    Theta = -Theta; // Theta is clockwise.\n    float CosT = cos(Theta);\n    float SinT = sin(Theta);\n\n    vec2 Dlt = vP - Pivot;\n\n    return vec2(Pivot.x  +  Dlt.x*CosT - Dlt.y*SinT,\n                Pivot.y  +  Dlt.x*SinT + Dlt.y*CosT );\n}\n","name":"Common","description":"","type":"common"}]}