{"ver":"0.1","info":{"id":"4XyXRG","date":"1720075804","viewed":36,"name":"Fastaro Fractal heron paradox","username":"robfast","description":"work in progress","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["floor","fraction","pythagorean"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ShaderToy shader code\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n#define PI 3.14159265359\n\n// Helper functions\nfloat m(float t) { return 2.0 + sin(t); }\nfloat n(float t) { return 1.0 + cos(t); }\nfloat k(float t) { return 1.0 + sin(2.0 * t); }\n\n// Heronian triangle area calculation\nfloat heronianArea(float t, float x, float y) {\nfloat m_val = m(t + x);\nfloat n_val = n(t + y);\nfloat k_val = k(t + x + y);\n\n\nfloat a = n_val * (m_val * m_val + k_val * k_val);\nfloat b = m_val * (n_val * n_val + k_val * k_val);\nfloat c = (m_val + n_val) * (m_val * n_val - k_val * k_val);\nfloat s = (a + b + c) * 0.5;\n\nreturn floor(sqrt(s * (s - a) * (s - b) * (s - c)));\n}\n\nfloat customIterationFunction(float x, float log_p, float log_q) {\n    float term1 = (-1.0 + floor((x * log_p) / log_q)) * floor((x * log_p) / log_q) * log_q;\n    float term2 = (2.0 * log_p);\n    float term3 = floor((x * log_p) / log_q) * (x - (log_q / log_p) * floor((x * log_p) / log_q));\n    return (term1 / term2) + term3;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Introduce a dynamic zoom based on time\n    float zoom = 1.0+sin(iTime/22.0); // Adjusted zoom effect\n    float rotation = iTime/3333.0; // Slow rotation effect\n    mat2 rot = mat2(cos(rotation), -sin(rotation), sin(rotation), cos(rotation));\n    vec2 baseC = (uv * rot) / zoom; // Apply zoom and rotation to fractal view\n    \n      vec3 ro = vec3(0.0, -3.0, -3.0); // Camera position\n    vec3 ta = vec3(0.0, 3.0, 0.0);  // Target position\n   \n    \n    // Camera-to-world matrix\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    vec3 rd = normalize(uv.x*uu + uv.y*vv + zoom*ww);\n\n    // Raymarch\n    float t = 0.0;\n    \n    float h = 0.0;\n    \n    \n    \n    \n    float slowTime = iTime * 0.2;\n    float context =  sin(slowTime) * 0.5;\n    float truthDegree = 3.0* cos(slowTime) * 0.5;\n    \n    // Oscillating parameters for q and p\n    float n1 = -0.09993406684822648;\n    float n2 = -12.0 * 3.141592653589793 + sin(slowTime * 0.001) * 12.0 * 3.141592653589793;\n    float q = pow(2.0, n1);\n    float p = exp(n2);\n    float log_p = log(p);\n    float log_q = log(q);\n     vec3 col = vec3(0.0);\n    vec2 z = baseC;\n    vec2 c = vec2(0.355, 0.355);\n    int maxIter = 40;\n    float iter = 0.0;\n    \n    for(int i = 0; i < maxIter; i++)\n    {\n        float x = z.x * z.x - z.y * z.y + c.x;\n        float y = 2.0 * z.x * z.y + c.y;\n        z = vec2(x, y);\n        \n        float euclidean = customIterationFunction(length(z)*zoom, log_p, log_q) * truthDegree;\n        float nonEuclidean = customIterationFunction(length(z)*zoom, log_p, log_q) * context;\n        \n        float val = mix(euclidean-float(t)* slowTime, nonEuclidean+float(i)*0.5,float(i) + sin(slowTime));\n        vec3 p = ro + iter * rd;\n\n        h = heronianArea(customIterationFunction(t*length(z), log_p, log_q) * truthDegree, x, p.z) * 0.5 -y;\n\n        t += h*log_q*rotation/log_p;\n        if(val > 100.0 *zoom* (sin(context * slowTime/88.0)))\n        {\n            iter = float(i) / 888.0*abs(n2)*float(maxIter);\n             \n        vec3 p = ro + iter * rd;\n        float f = customIterationFunction(heronianArea(t, p.x, p.y),log_p,log_q);\n        col = customIterationFunction(f/length(z),log_p,t) * cos(length(z) + vec3(f,0.5,p.y));\n    \n          \n        }\n      \n    // Coloring\n   \n   \n    }\n    \n    float sg = iter;\n    \n   float truthValue = iter;\n    vec3 euclideanColor = vec3(0.5 * sin(truthValue * 6.28 + slowTime) + 0.5,\n                               0.5 * cos(truthValue * 6.28 + slowTime) + 0.5,\n                              sin(truthValue * 6.28 - slowTime));\n    vec3 nonEuclideanColor = vec3(sin(truthValue * 6.28 + slowTime),\n                                  cos(truthValue * 6.28 + slowTime),\n                                  sin(truthValue * 6.28 - slowTime));\n    vec3 finalColor = mix(col, mix(nonEuclideanColor,euclideanColor,0.5), 0.5);\n    float hueRangeStart = 0.4; // Start of hue range\n    float hueRangeEnd = 0.75; // End of hue range\n    float hue = hueRangeStart + mod(sg / 20.0 + iTime/10.0, hueRangeEnd - hueRangeStart);\n\n    float saturation = 0.7;\n    float value = 0.9;\n\n    vec3 hsv = vec3(hue, saturation, value);\n    vec3 rgb = hsv2rgb(hsv); // Convert HSV to RGB\n\n   \n    \n    fragColor = vec4(mix(finalColor,rgb,2.95+hue), 1.0);\n   \n}\n","name":"Image","description":"","type":"image"}]}