{"ver":"0.1","info":{"id":"XfcXWB","date":"1714610762","viewed":94,"name":"Charged Particles","username":"berelium","description":"Based on my interactive particle system. Applied coulombs law: https://en.wikipedia.org/wiki/Coulomb%27s_law\nI want to explore further with Coulombs law, maybe recreate some of the visuals in the vid.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["mouse","particles","physics","particle","magnetic","magnet","multipass","gpu","magnets","charged"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Interactive Particles\" by berelium. https://shadertoy.com/view/McXXzH\n// 2024-04-29 03:41:57\n// I modified this work to simply add a magnetic charge to the particles when the mouse is pressed.\n// Was inspired to do this after seeing a video on magnetic fields.\n// I think it turned out quite nice. You can invert one of the charges by toggling ATTRACT in Buffer A.\n// It does lose control a bit as Coulombs law heads for infinity as it approaches zero, so particles will reach max speed.\n\n#define P_ITERATOR int(floor(sqrt(float(NUM_PARTICLES))))+1\n\n\n// The number of particles can be modified in common.\n// If your computer is struggling, you can use the Shadertoy Unnoficial plugin to lower the resolution (ALT + 1-9),\n// where each number is a screenspace division. Ex (ALT + 2) == iResolution / 2.0\n\n// NOTE: This method is not practical in a standalone GLSL implementation.\n//       This was made to work in shadertoy, and is not efficient as it needs \n//       to iterate thousands of particles on each pixel of the screen.\n//       ===\n//       A more realistic implementation would be a vertex shader calculating positions/velocities \n//       on a fixed buffer of particles. Then a fragment shader could simple iterate the buffer and \n//       render the particles.\n\n// Thanks to iq for the hsl/hsv functions!\n// https://www.shadertoy.com/view/lsS3Wc\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n#define ltos1(x) (x <= 0.0031308 ? x * 12.92 : 1.055 * pow(x, 0.4166667) - 0.055)\n#define ltos3(x, y, z) vec3(ltos1(x), ltos1(y), ltos1(z))\n\nvec3 render( in vec2 uv ) {\n    vec3 color = vec3(0.01), col;\n    float c, mag, f = 0.015;\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    vec4 currParticle;\n    vec2 particlePos;\n    // Iterate over a grid of particles to render\n    for(int y = 0; y < P_ITERATOR; y++) {\n        for(int x = 0; x < P_ITERATOR; x++) {\n            // Grab a particle\n            currParticle = texelFetch(iChannel0, ivec2(x, y), 0);\n            particlePos = uv - currParticle.xy;\n            particlePos.x *= ASPECT;\n            \n           \n            // Calculate magnitude of the particle\n            mag = (currParticle.z * currParticle.z + currParticle.w * currParticle.w) * 0.000000625;\n            \n           \n            // Derive a color based on magnitude\n#ifdef ATAN_COLOR\n            // Use polar coordinates based on the velocity to choose a hue\n            // Normalize velocity???\n            float r = atan(currParticle.w, currParticle.z);\n            r += PI * 1.5;\n            col = hsl2rgb( vec3(((r / PI) / 2.0), mag + 0.45, mag + 0.11));\n#else             \n            if(iMouse.z > 0.5) {\n                vec2 mV = m - currParticle.xy;\n                mV.x *= iResolution.x / iResolution.y;    \n               \n                // q1 is mouse charge, q2 is particles charge\n                float q1 = MOUSE_F;\n                float q2 = PARTI_F;\n                //float q2 = hash12(uv) * PARTI_F + 0.2;\n\n                f = Coulombs_law(length(mV) * 0.65, vec2(q1,q2));\n            }\n            \n            col = hsl2rgb(vec3(mag, 0.6, max(0.2, f)));\n            col += f;\n#endif\n            \n            // Use distance field to make a glow effect @alro\n            c = 1. / length(particlePos);\n            c *= PARTICLE_SIZE; // Radius\n            c = pow(c, INTENSITY); // Intensity\n            \n            color += c * col;\n        }\n    }\n    \n    //color /= 1.5;\n    \n    // Render mouse magnet\n    vec2 particle = uv - m;\n    particle.x *= ASPECT;\n    c = 1. / length(particle);\n    c *= PARTICLE_SIZE * 9.; // Radius\n    c = pow(c, INTENSITY); // Intensity\n\n    vec3 mc = vec3(0.25);\n    if(iMouse.z > 0.5) {\n        mc = vec3(0.25, 0.025, 0.0);\n    }\n    \n#ifdef VIEW_FIELD\n    vec2 mV = uv - m;\n    mV.x *= iResolution.x / iResolution.y;\n    f =  Coulombs_law(length(mV), vec2(MOUSE_F,hash12(uv) * PARTI_F + 0.2));\n    c += f;\n#endif\n\n    color += c * mc;\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = render(uv);\n    \n    // Contrast + ACES tonemap + Gamma\n    col = ((col - 0.5) * CONTRAST) + 0.5;\n    col = (col * (2.51 * col + 0.03)) / (col * (2.43 * col + 0.59) + 0.14);\n    col = ltos3(col.r, col.g, col.b);\n    col = pow(col, vec3(1.0 / GAMMA));\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define ASPECT iResolution.x / iResolution.y\n#define PI 3.14159265359\n#define TAU PI * 2.0\n\n/* Some notes:\n   = If wrap edges isn't defined, the particles will bounce off the edges with some random velocity\n   = Center attractor is a constant force in the middle of the screen for particles to gravitate around\n   = Num of particle is not exact, but close. It gets floor-sqrted and +1 later for reading from the buffer. AKA 1500 == 1521 (39*39)\n   = Gravity is a vec2 here because you can apply gravity in any direction\n   = Attraction is used for the mouse and the center attractor\n   = Bounce is for if wrap edges is off, for colliding with walls\n   = Max speed is the max speed a particle can reach, before being limited\n   = Intensity is for the intensity of light around each particle\n   = dt is the simulation step time\n*/\n//#define WRAP_EDGES\n//#define CENTER_ATTRACTOR\n// Adjust number of particles if its too laggy (or bump it up if you are cool)\n#define NUM_PARTICLES 2000\n#define PARTICLE_SIZE 0.0005 * ASPECT\n#define GRAVITY vec2(-0.0, -.0)\n#define BOUNCE 0.6\n#define MAX_SPEED 200.\n#define dt iTimeDelta * 0.001\n\n\n//#define ATAN_COLOR\n#define INTENSITY 2.0\n#define CONTRAST 1.04\n#define GAMMA 2.2\n\n\n// Magnetic Settings\n//#define VIEW_FIELD\n//#define ATTRACT\n\n// Electric constant (Lower numbers will increase the magnet strength)\n#define E0 1.0\n#define MOUSE_F 0.1\n#define PARTI_F 1.0\n\n// https://en.wikipedia.org/wiki/Coulomb%27s_law. Takes in:\n//   r - the distance between two simalarly charged particles.\n//   q - the charge of each particle (q1,q2) => (q.x, q.y)\nfloat Coulombs_law( in float r, in vec2 q ) {\n    return ((q.x * q.y) / (4.0 * PI * E0)) * (r / pow(r, 3.0));;\n}\n\n\n\n//----------------------------------------------------------------------------------------\n// Hash without sine ( https://www.shadertoy.com/view/4djSRW ); Thanks Dave!\n//----------------------------------------------------------------------------------------\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\n\n\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n        vec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n        vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n        p3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n        vec3 p3 = fract(vec3(p) * HASHSCALE3);\n        p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n        vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n        p3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n    vec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n        vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n        vec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n        p4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Initialize the buffer with random positions and zeroed velocity\n    if(iFrame < 5) {\n        vec2 pos = hash22(uv.yx);\n        vec2 vel = vec2(0.0);\n        fragColor = vec4(pos, vel);\n        return;\n    }\n    \n    // Grab the previous states\n    vec4 previousState = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec2 position = previousState.xy;\n    vec2 velocity = previousState.zw;\n    \n    \n    // Apply simple gravity force\n    velocity += GRAVITY;\n    \n    \n    // Check if L-Mouse is pressed\n    if(iMouse.z > 0.01)\n    {\n    \tvec2 m = iMouse.xy/iResolution.xy;\n        vec2 mV = m - position;\n        mV.x *= iResolution.x / iResolution.y;\n        float d = length(mV);\n        \n        // q1 is mouse charge, q2 is particles charge\n        float q1 = MOUSE_F;\n        //float q2 = PARTI_F;\n        float q2 = hash12(uv) * PARTI_F + 0.2;\n        \n#ifdef ATTRACT\n        q1 *= -1.0;\n#endif\n        \n        d *= 0.8; // distance modifier\n        vec2 q = vec2(q1,q2); \n        float f = Coulombs_law(d, q);\n        float a = atan(mV.y, mV.x);\n        \n        // Apply force based on position relative to the mouse\n        //velocity.x += f * (mV.x < 0.0 ? 1.0 : -1.0);\n        //velocity.y += f * (mV.y < 0.0 ? 1.0 : -1.0);\n        velocity.x -= f * cos(a);\n        velocity.y -= f * sin(a);\n    }\n  \n    // Edge handling    \n#ifdef WRAP_EDGES\n    position = fract(position);\n#else\n    if(position.x - PARTICLE_SIZE < 0.0) { // Left\n        position.x = PARTICLE_SIZE;\n        velocity.x = abs(velocity.x) * BOUNCE;\n    }\n    if(position.y + PARTICLE_SIZE > 1.0) { // Up\n        position.y = 1.0 - PARTICLE_SIZE;\n        velocity.y = -abs(velocity.y) * BOUNCE;\n    }\n    if(position.x + PARTICLE_SIZE > 1.0) { // Right\n        position.x = 1.0 - PARTICLE_SIZE;\n        velocity.x = -abs(velocity.x) * BOUNCE;\n    }\n    if(position.y - PARTICLE_SIZE < 0.0) { // Down\n        position.y = PARTICLE_SIZE;\n        velocity.y = abs(velocity.y) * BOUNCE;\n    }\n#endif\n\n    \n    // Update position with velocity and timestep\n    position += velocity * dt;\n    \n    \n    // Limit the particle if its moving too fast\n    if( length(velocity) > MAX_SPEED ) {\n        velocity = normalize(velocity) * MAX_SPEED;\n    }\n    \n    \n    // Update position and velocity\n    fragColor = vec4(position, velocity);\n}","name":"Buffer A","description":"","type":"buffer"}]}