{"ver":"0.1","info":{"id":"Xs3XW7","date":"1459576032","viewed":545,"name":"Shader Lesson #3, trigonometry","username":"hubbe","description":"Demonstrates SIN (top right) and COS (bottom left) functions and how they relate to the unit circle.\n","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["educational"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Plot a function, and a background grid.\n\nhighp float pi = 3.14159265;\n\n// Fom -2 to 2\nhighp float scale = 4.0;\n\n// Transform an vec2 onscreen coordinate (0.0-1.0) to a coordinate that\n// we want to plot the function for. (+/- scale*2)\nvec2 p2v(vec2 pos) {\n    pos -= vec2(0.5 * iResolution.x/iResolution.y, 0.5);\n    pos *= scale;\n    return pos;\n}\n\n// Draws the sine curves.\nbool t(vec2 pos) {\n    pos = p2v(pos);\n    \n    if (pos.x > 0.0) {\n      if (pos.y > 0.0) {\n        return sin(iTime - pos.x * pi) + 1.0 > pos.y;\n      } else {\n          return true;\n      }\n    } else {\n      if (pos.y > 0.0) {\n        return sin(iTime) + 1.0 > pos.y && cos(iTime) - 1.0 < pos.x;\n      } else {\n        return cos(iTime + pos.y * pi) - 1.0 < pos.x;\n      }\n    }\n    return false;\n}\n\n// Draws the circle.\nbool t2(vec2 pos) {\n    pos = p2v(pos);\n    return length(pos + vec2(1,-1)) < 1.0; \n}\n\n// Draw the angle.\nbool t3(vec2 pos) {\n    pos = p2v(pos) + vec2(1, -1);\n    vec2 v = vec2(cos(iTime), sin(iTime));\n    vec2 v2 = vec2(-v.y, v.x);\n    vec2 v3 = vec2(dot(pos, v), dot(pos, v2));\n    if (v3.x < 0.0 || v3.x > 1.0) return false;\n    return abs(v3.y) < scale / iResolution.y / 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.yy;\n    int cnt = 0;\n    int cnt2 = 0;\n    int cnt3 = 0;\n    int max_cnt = 0;\n    // Multisample.\n    for (float x = -1.25; x <= 1.25; x += 0.25) {\n        for (float y = -1.25; y <= 1.25; y += 0.25) {\n            max_cnt ++;\n            if (t((fragCoord.xy + vec2(x, y)) / iResolution.yy))\n                cnt ++;\n            if (t2((fragCoord.xy + vec2(x, y)) / iResolution.yy))\n                cnt2 ++;\n            if (t3((fragCoord.xy + vec2(x, y)) / iResolution.yy))\n                cnt3 ++;\n        }\n    }\n    if (cnt > max_cnt / 2) cnt = max_cnt - cnt;\n    if (cnt2 > max_cnt / 2) cnt2 = max_cnt - cnt2;\n    if (cnt3 > max_cnt / 2) cnt3 = max_cnt - cnt3;\n    \n    float color = float(cnt) * 2.0 / float(max_cnt);\n    float color2 = float(cnt2) * 2.0 / float(max_cnt);\n    float color3 = float(cnt3) * 2.0 / float(max_cnt);\n\tfloat bg = 0.0;\n    vec2 v = p2v(uv);\n    // Black axis\n    if (abs(v.x + 1.0) < scale/iResolution.x || abs(v.y - 1.0) < scale/iResolution.y) {\n      bg = 0.0;\n    } else {\n\t    vec2 grid = step(mod(v, vec2(2.0, 2.0)), vec2(1.0, 1.0));\n    \tif (grid.x == grid.y) {\n          bg = 0.3;\n        } else {\n          bg = 0.4;\n        }\n    }\n    \n    // Blend colors.\n    fragColor = vec4(1);\n    fragColor = mix(vec4(bg), fragColor, color);\n    fragColor = mix(fragColor, vec4(0,1,1,0), color2);\n    fragColor = mix(fragColor, vec4(0,1,0,0), color3);\n}","name":"Image","description":"","type":"image"}]}