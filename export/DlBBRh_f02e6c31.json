{"ver":"0.1","info":{"id":"DlBBRh","date":"1694146468","viewed":96,"name":"topographic map (zv)","username":"zerovolts","description":"2-pass box blurred noise (looks more natural than just lowering the noise iterations) which is then stepped and outlined. There are a few remaining issues such as the aliasing of the outlines and the warping edges.","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["contour","isoline","topography"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const mat3 EDGE_KERNEL = mat3(\n    -1, -1, -1,\n    -1,  8, -1,\n    -1, -1, -1\n);\n\nvec3 lerpColor(vec3 from, vec3 to, float progress) {\n    vec3 range = to - from;\n    return from + range * progress;\n}\n\n// Takes 0.0-1.0 and returns 0.0-1.0\nfloat discretize(float value, float offset) {\n    return floor(value * float(LAYERS) + offset) / float(LAYERS);\n}\n\nfloat tex(vec2 p) {\n    return discretize(texture(iChannel0, p).x, .5);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord / iResolution.xy;\n    vec2 uv = (fragCoord - .5 * iResolution.xy) * 2. / iResolution.y;\n    float height = tex(st);\n    \n    vec3 color = vec3(0);\n    \n    // edge detection\n    float edge = 0.;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            vec2 offset = vec2(float(j - 1), float(i - 1)) / iResolution.xy;\n            vec2 texCoord = st + offset;;\n            edge += 1. / tex(texCoord) * EDGE_KERNEL[j][i];\n        }\n    }\n    vec3 outlineMask = edge > 0.01 ? vec3(1.) : vec3(0.);\n    \n#ifdef WATER\n    color += height >= WATER_LEVEL ? outlineMask * .15 : vec3(0);\n    color += height > WATER_LEVEL\n        ? lerpColor(COLOR_LOW, COLOR_HIGH, height)\n        : COLOR_WATER;\n#else\n    color += outlineMask * .15;\n    color += lerpColor(COLOR_LOW, COLOR_HIGH, height);\n#endif\n\n    // paper texture\n    //color += (random2(uv + iTime).x - .5) * .05;\n    color += texture(iChannel1, (uv + vec2(0., iTime / 5.)) * 4.).x * .2 - .1;\n    \n    vec3 srgb = pow(color, vec3(1. / 2.2));\n    fragColor = vec4(srgb, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// NOISE GENERATION\n\nconst int NOISE_ITERATIONS = 3;\n\nfloat hash2(vec2 p) {\n\treturn textureLod(iChannel0, p, 0.0).x;\n}\n\nfloat noise(vec2 p) {\n    float total = 0.;\n    float resolution = 1.;\n    float weight = .5;\n    for (int i = 0; i < NOISE_ITERATIONS; i++) {\n        total += hash2(p * resolution) * weight;\n        resolution *= 2.;\n        weight /= 2.;\n    }\n    return total;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - .5 * iResolution.xy) * 2. / iResolution.y;\n    float height = noise((uv + vec2(0, iTime / 5.)) / 100.);\n    fragColor = vec4(vec3(height), 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// CONTROLS\n\n//#define WATER\n\nconst vec3 COLOR_LOW = vec3(.04, .28, .34);\nconst vec3 COLOR_HIGH = vec3(1., .89, .45);\nconst vec3 COLOR_WATER = vec3(0.05, 0.65, 0.70);\n\nconst int LAYERS = 15;\nconst int BLUR_SIZE = 20;\nconst float WATER_LEVEL = .3;\n\n// DERIVED\n\nconst float LAYER_WIDTH = 1. / float(LAYERS);\nconst int HALF_BLUR_SIZE = BLUR_SIZE / 2;","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// HORIZONTAL BOX BLUR\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord / iResolution.xy;\n    vec2 uv = (fragCoord - .5 * iResolution.xy) * 2. / iResolution.y;\n    \n    float total = 0.;\n    for (int i = -HALF_BLUR_SIZE; i < HALF_BLUR_SIZE; i++) {\n        vec2 offset = vec2(float(i), 0.) / iResolution.xy;\n        vec2 texCoord = st + offset;\n        total += texture(iChannel0, texCoord).x;\n    }\n    total /= float(BLUR_SIZE);\n    \n    fragColor = vec4(vec3(total), 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// VERTICAL BOX BLUR\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord / iResolution.xy;\n    vec2 uv = (fragCoord - .5 * iResolution.xy) * 2. / iResolution.y;\n    \n    float total = 0.;\n    for (int i = -HALF_BLUR_SIZE; i < HALF_BLUR_SIZE; i++) {\n        vec2 offset = vec2(0., float(i)) / iResolution.xy;\n        vec2 texCoord = st + offset;\n        total += texture(iChannel0, texCoord).x;\n    }\n    total /= float(BLUR_SIZE);\n    \n    // Arbitrary adjustment to account for blur reducing the range\n    total *= 1.5;\n    total -= .15;\n    \n    fragColor = vec4(vec3(total), 1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}