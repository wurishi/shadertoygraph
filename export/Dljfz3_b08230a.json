{"ver":"0.1","info":{"id":"Dljfz3","date":"1694318282","viewed":85,"name":"Ocean with water reflection","username":"TheFakeDev","description":"An ocean with simple water reflection ðŸ‘€","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["water","ocean","sky","atmosphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tNon-Accurate Atmospheric Scattering\n\tMade by Robobo1221, optimized by TheFakeDev\n\t\n\thttps://www.shadertoy.com/view/Ml2cWG\n  \n\t--------------------------------------------\n\t\n\tWorldPosition Calculation\n\tMade by Robobo1221  \n  \n\thttps://www.shadertoy.com/view/MstBWs\n*/\n\nconst float pi  = acos(-1.0);\nconst float rPi = 1.0 / pi;\nconst float hPi = pi * 0.5;\nconst float tau = pi * 2.0;\n\nconst float zenithOffset\t\t = 0.1;\nconst float multiScatterPhase\t = 0.1;\nconst float density\t\t\t\t = 0.7;\n\nconst float anisotropicIntensity = 0.0; //Higher numbers result in more anisotropic scattering\n\nconst vec3 skyColor\t\t\t\t = vec3(0.27,0.5,1.0) * (1.0 + anisotropicIntensity); // Make sure one of the conponents is never 0.0\n\n#define smooth(x) x*x*(3.0-2.0*x)\n#define zenithDensity(x) density / pow(max(x - zenithOffset, 0.35e-2), 0.75)\n\nvec3 getSkyAbsorption(vec3 x, float y){\n\n\tvec3 absorption = x * -y;\n\t\t absorption = exp2(absorption) * 2.0;\n\n\treturn absorption;\n}\n\nfloat getSunPoint(vec3 p, vec3 lp){\n\treturn smoothstep(0.9993, 0.99999, dot(p, lp)) * 1e2;\n}\n\nfloat getRayleigMultiplier(vec3 p, vec3 lp){\n\tfloat pdotlp = dot(p, lp);\n    \n\treturn 3.0 / (16.0 * pi) * (1.0 + pdotlp * pdotlp) * 15.0;\n}\n\nfloat getMie(vec3 p, vec3 lp){\n\tfloat pdotlp = dot(p, lp);\n    \n\t//Henyey-Greenstein\n\tfloat g\t     = 0.76;\n\tfloat gSqr   = g * g;\n\treturn (1.0 - gSqr) / (4.0 * pi * pow(1.0 + gSqr - 2.0 * g * pdotlp, 1.5)) / 5.0;\n}\n\nvec3 getAtmosphericScattering(vec3 p, vec3 lp){\n\tvec3 correctedLp = lp;// vec3(lp.xy / max(iResolution.x, iResolution.y) * iResolution.xy, lp.z);\n\t\t\n\tfloat zenith\t\t   = zenithDensity(p.y + 0.128);\n\tfloat sunPointDistMult = clamp(length(max(correctedLp.y + multiScatterPhase - zenithOffset, 0.0)), 0.0, 1.0);\n\t\n\tfloat rayleighMult = getRayleigMultiplier(p, correctedLp);\n\t\n\tvec3 absorption\t   = getSkyAbsorption(skyColor, zenith);\n\tvec3 sunAbsorption = getSkyAbsorption(skyColor, zenithDensity(correctedLp.y + multiScatterPhase));\n\t\n    vec3 sky = skyColor * zenith * rayleighMult;\n\tvec3 sun = getSunPoint(p, correctedLp) * absorption;\n\tvec3 mie = getMie(p, correctedLp) * sunAbsorption;\n\t\n\tvec3 totalSky  = mix(sky * absorption, sky / (sky + 0.5), sunPointDistMult);\n\t\t totalSky += sun + mie;\n\t\t totalSky *= sunAbsorption * 0.5 + 0.5 * length(sunAbsorption);\n\t\n\treturn totalSky * pi;\n}\n\nvec3 jodieReinhardTonemap(vec3 c){\n\tfloat l = dot(c, vec3(0.2126, 0.7152, 0.0722));\n\tvec3 tc = c / (c + 1.0);\n\n\treturn mix(c / (l + 1.0), tc, tc);\n}\n\n//#define SPHERICAL_PROJECTION\n\nvec3 sphereToCart(vec3 sphere) {\n\tvec2 c = cos(sphere.xy);\n\tvec2 s = sin(sphere.xy);\n\t\n\treturn sphere.z * vec3(c.x * c.y, s.y, s.x * c.y);\n}\n\nvec3 calculateWorldSpacePosition(vec2 p){\n\tp = p * 2.0 - 1.0;\n\t\n\tvec3 worldSpacePosition =  vec3(p.x, p.y, 1.0);\n\t\n\t#ifdef SPHERICAL_PROJECTION\n\t\tworldSpacePosition = sphereToCart(worldSpacePosition * vec3(pi, hPi, 1.0));\n\t#endif\n\t\n\treturn worldSpacePosition;\n}\n\nmat2 rotateMatrix(float angle){\n\treturn mat2(vec2(cos(angle), -sin(angle)), vec2(sin(angle), cos(angle)));\n}\n\nfloat waterWaves(vec2 position){\n\tposition /= 1.25;\n  \n\tfloat wave  = texture(iChannel0, position * 0.01 + vec2(iTime * 0.033)).x * 0.2;\n\t\t  wave += texture(iChannel0, position * 0.05 - vec2(iTime * 0.015)).x * 0.3;\n\t\t  wave += texture(iChannel0, position * 0.02 + vec2(iTime * 0.015)).x * 0.5;\n\t\t  wave *= 2.0 - 1.0;\n  \n\treturn wave / tau;\n}\n\nvec3 waterNormal(vec3 position){\n\tvec2 coord = position.xz;\n\n\tconst float delta = 0.25;\n\n\tfloat h0 = waterWaves(coord);\n\tfloat h1 = waterWaves(coord + vec2(delta, 0.0));\n\tfloat h2 = waterWaves(coord + vec2(0.0, delta));\n\n\tfloat xDelta = (h0 - h1) / delta;\n\tfloat yDelta = (h0 - h2) / delta;\n\n\treturn normalize(vec3(xDelta, 1.0, yDelta));\n}\n\nvec3 constructedNormal(vec3 position){\n\tvec3 dFdxPos = dFdx(position);\t\n\tvec3 dFdyPos = dFdy(position);\n\n\treturn normalize(cross(dFdxPos, dFdyPos));\n}\n\n#define waterParallaxSteps 16\n#define waterParallaxDepth 1.0\n#define waterParallaxDistance 1.0\n\nvec3 waterParallax(mat2x3 position){\n\t\n\treturn position[0];\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 texcoord   = fragCoord.xy / iResolution.xy;\n\tvec2 mousecoord = iMouse.xy\t/ iResolution.xy;\n\t\n\tmousecoord = mousecoord.x < 0.001 ? vec2(0.4, 0.64) : mousecoord;\n\n\tvec3 worldPosition = calculateWorldSpacePosition(texcoord);\n\tvec3 sunVector\t   = normalize(calculateWorldSpacePosition(mousecoord));\n\t\n\tvec2 newTexcoord  = texcoord * 2.0 - 1.0;\n\t\t newTexcoord *= iResolution.x / iResolution.y;\n\n\tvec3 newPosition  = vec3(newTexcoord.x, newTexcoord.y, 3.0 / 2.0);\n\t\t newPosition /= newPosition.y / 10.0;\n\n\tvec3 normal = constructedNormal(newPosition);\n\t\n\tvec3 n = normalize(normal);\n\tvec3 t = normalize(cross(n, cross(n, vec3(0.0, 0.0, 1.0))));\n\tvec3 b = normalize(cross(t, n));\n\n\tmat3 tbn = transpose(mat3(t, b, n));\n\t\n\tvec3 viewPosition\t = normalize(tbn * newPosition);\n\t\t viewPosition.x -= 0.25;\n\t\t \n\tnewPosition = waterParallax(mat2x3(newPosition, viewPosition));\n\tnormal\t\t= waterNormal(newPosition);\n  \n\tvec3 reflectedVector = reflect(normalize(worldPosition), normal);\n\t\n\tvec3 color = vec3(0.0);\n\t\t color = getAtmosphericScattering(texcoord.y > 0.5 ? normalize(worldPosition) : reflectedVector, sunVector);\n\t\t color = jodieReinhardTonemap(color);\n\t\t color = pow(color, vec3(2.2));\n\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}