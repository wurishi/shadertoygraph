{"ver":"0.1","info":{"id":"MdsyRn","date":"1486763195","viewed":654,"name":"Star sky","username":"andras","description":"Star sky","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["noise","random","star","fun","sky","so","much"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n\n    Please note:\n    This code is pretty badly written, I just experimented with the different noises.\n\n\tEspecially the hills don't really make sense. \n\tI did not find a way to make them smaller in the middle and higher on the sides.\n\n    Sources:\n    ashima github, shadertoy (maybe IQ's fbm), thebookofshaders...\n\tand the hills are from someone on this site\n    sorry if I left out somebody, this shader is just meant for fun anyway\n\n**/\n\n\n\nfloat globalRandom = 2101.671;\t// Change this for another effect\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n// -------------------------------------------------------------------------------------------------------------------------------------\n\nfloat random (in vec2 st) \n{ \n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))* \n        43758.5453123);\n}\n\nfloat noise(in vec2 st)\n{\n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\t\n\t// 4 corners in a 2d tile\n\tfloat a = random(i);\n\tfloat b = random(i + vec2(1.0, 0.0));\n\tfloat c = random(i + vec2(0.0, 1.0));\n\tfloat d = random(i + vec2(1.0, 1.0));\n\t\n\tvec2 u = vec2(0.0);\n\t//u = f * f * (3.0 - 2.0 * f);\n\tu = f*f*f*(f*(f*6.-15.)+10.);\n\t\n\treturn mix(a, b, u.x) + \n\t\t(c - a) * u.y * (1.0 - u.x) + \n\t\t(d - b) * u.x * u.y;\n}\n\n// -------------------------------------------------------------------------------------------------------------------------------------\n\n#define OCTAVES 7\n\nfloat fbms(in vec2 coord)\n{\n\tfloat sum = 0.0;\n\tfloat f = 0.0;\n\t\n\tvec2 dir = vec2(1.0, 0.0);\n\t\n\tvec2 q = coord;\n\n\t\n\tfor(int i = 0; i < OCTAVES; ++i)\n\t{\n\t\tfloat multip = 0.5 / pow(2.0, float(i) );\n\t\t\n\t\tf += multip * snoise(q);\n\t\tsum += multip;\n\t\tq = q * 2.01; \n\t}\n\t\n\treturn f / sum;\n}\n\nfloat fbm(in vec2 coord)\n{\n\tfloat sum = 0.0;\n\tfloat f = 0.0;\n\t\n\tvec2 dir = vec2(1.0, 0.0);\n\t\n\tvec2 q = coord;\n\n\t\n\tfor(int i = 0; i < OCTAVES; ++i)\n\t{\n\t\tfloat multip = 0.5 / pow(2.0, float(i) );\n\t\t\n\t\tf += multip * noise(q);\n\t\tsum += multip;\n\t\tq = q * 2.01; \n\t}\n\t\n\treturn f / sum;\n}\n\n// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n#define RIDGE_OCTAVES 1\n\n// Ridged multifractal\n// See \"Texturing & Modeling, A Procedural Approach\", Chapter 12\nfloat ridge(float h, float offset) {\n    h = abs(h);     // create creases\n    h = offset - h; // invert so creases are at top\n    //h = h * h;      // sharpen creases\n    return h;\n}\n\nfloat ridgedMF(vec2 p) {\n    float lacunarity = 2.0;\n    float gain = 0.5;\n    float offset = 0.9;\n        \n    float sum = 0.0;\n    float freq = 1.0, amp = 0.5;\n    float prev = 1.0;\n    for(int i=0; i < RIDGE_OCTAVES; i++) {\n        float n = ridge(snoise(p*freq), offset);\n        sum += n*amp;\n        sum += n*amp*prev;  // scale by previous octave\n        prev = n;\n        freq *= lacunarity;\n        amp *= gain;\n    }\n    return sum;\n}\n\n// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nmat2 makem2(in float theta)\n{\n\tfloat c = cos(theta);\n\tfloat s = sin(theta);\n\treturn mat2(c, -s, s, c);\n}\n\n// ------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\nfloat gradient(vec2 p){\n\tfloat v = 0.8 - length(p / 2.0);\n\tv *= v * 2.0;\n\treturn  v * step(0.0, v);\n}\n\nfloat fractal(vec2 c, float val){\n\tvec2 o = vec2(0.0);\n\t\n\tfloat f1 = fbms(c * 0.7 * makem2(2.7) + val);\n\t\n\tfloat a1 = fbms(c * 0.2);\n\tfloat f3 = ridgedMF(c * 0.4 + val + a1 * 0.4);\n\t\n\treturn f1 * f3 * 2.0;\n}\n\nfloat fractal2(vec2 c, float val){\n\tvec2 o = vec2(0.0);\n\t\n\tfloat f1 = fbms(c * 0.7 * makem2(2.7) + val);\n\t\n\tfloat a1 = fbms(c * 0.2);\n\tfloat f3 = ridgedMF(c * 0.4 + val + a1 * 0.4);\n\t\n\tfloat f4 = fbms(c * (0.7 + 0.9 * f1 * f3) * makem2(2.7) + val);\n\t\n\treturn f4;\n}\n\nfloat stars(vec2 uv, float val) {    \n    float n1 = random(uv*102. + val);\n    float n2 = random(uv*101. + val);\n    float a1 = pow(n1, 20.);\n    float a2 = pow(n2, 20.);\n  \n    return a1 * a2;\n}\n\n// ------------------------------------------------------------------------------------------------------------------------------------------------\n\nfloat hills( vec2 pp, float offsetY, float val)\n{\n\tfloat x = pp.x;\n\n\t\n\tpp.x += val;\n\tpp.y += offsetY;\n\t\n\t\n\t// Properties\n\tconst int octaves = 8;\n\tfloat lacunarity = 2.0;\n\tfloat gain = 0.5;\n\t//\n\t// Initial values\n\tfloat amplitude = 0.9;\n\tfloat frequency = 0.6;\n\n\t\n\t// Loop of octaves\n\tfor (int i = 0; i < octaves; i++) {\n\t\tamplitude *= gain;\n\t\tpp.y += amplitude * snoise(vec2(frequency*pp.x) );\n\t\tfrequency *= lacunarity;\t\n\t}\n\t\n\tfloat h = pp.y;\n\t\n\th = smoothstep( -9./iResolution.y, 0., h-.8);\n\t\n\treturn 1.0 - h;\n}\n\nfloat twoHills(float offsetY, float val, vec2 fragCoord)\n{\n\tvec2 pp = ( 2.0 * (gl_FragCoord.xy) - iResolution.xy) / iResolution.y;\n\t\n\tfloat y = pp.y;\n\tpp.y = y * ( (iResolution.x - fragCoord.x) / iResolution.x * 3.5);\n\t\n\tfloat h1 = hills(pp, offsetY, val);\n\t\n\tpp.y = y * ( fragCoord.x / iResolution.x * 3.5);\n\tfloat h2 = hills(pp, offsetY, val);\n\t\n\treturn h1 + h2;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Not scaled\n\tvec2 k = (fragCoord.xy / iResolution.xy - 0.5) * 2.0;\n\tfloat g = gradient(k);\n\t\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\t\n    \tvec2 p = -0.5 + 2.0 * q;\n\t\n\tif(iResolution.x < iResolution.y) {\n   \t\tp.y *= iResolution.y/iResolution.x;\n\t}\n\telse{\n\t\tp.x *= iResolution.x/iResolution.y;\n\t}\n\t\n\tvec3 color = vec3(0.0);\n\t\n\tfloat val = globalRandom;\n\t\n\t// Rotating really sells this effect\n\tfloat c1 = fractal2(p * makem2(0.5), val + 0.3) * g;\n\t\n\t// Idea for coloring small areas\n\tfloat s1 = snoise(p + val);\n\tfloat s2 = snoise(p * 0.7 + val + 3.0);\n\tfloat s3 = snoise(p + val + 13.0);\n\t\n\t\n\tfloat st1 = stars(p, val);\n\tfloat st2 = stars(p, val + 1.0);\n\tfloat st3 = stars(p, val + 2.0);\n\tfloat st4 = stars(p, val + 3.0);\n\tfloat st5 = stars(p, val + 4.0);\n\t\n\t\n\t// Light blue 900 -> 400\n\tcolor = mix(vec3(0.003921569, 0.34117648, 0.60784316) * 0.5, vec3(0.16078432, 0.7137255, 0.9647059) * 1.0, c1 * s1 * 1.1);\t\n\t\n\tcolor += st1;\n\tcolor += (st2 + st3) * c1 * s1 * 8.0;\n\t\n\t// Hills ->\n\t// Hills can have different colors\n\tvec2 pp = ( 2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\t\n\tfloat h1 = twoHills(1.9, val + 23.0, fragCoord);\n\t\n\tvec3 temp = color * step(0.5, 1.0 - h1);\n\tcolor = vec3(0.003921569, 0.34117648, 0.60784316) * step(0.5, h1) * 0.3;\n\tcolor += temp;\n\t\n\tfloat h2 = twoHills(2.8, val + 27.0, fragCoord);\n\ttemp = color * step(0.5, 1.0 - h2);\n\tcolor = vec3(0.003921569, 0.34117648, 0.60784316) * step(0.5, h2) * 0.4;\n\tcolor += temp;\n\t\t\n\t\n\tfragColor = vec4( color, 1.0 );\n}","name":"Image","description":"","type":"image"}]}