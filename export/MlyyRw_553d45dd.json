{"ver":"0.1","info":{"id":"MlyyRw","date":"1535491139","viewed":515,"name":"Plexus","username":"tobySixx","description":"Plexus","likes":16,"published":1,"flags":96,"usePreview":0,"tags":["plexus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xs2XW3","filepath":"https://soundcloud.com/elysianrecords/royalty","previewfilepath":"https://soundcloud.com/elysianrecords/royalty","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n        \n    // Post process\n    // chromatic aberation\n    float a = texelFetch(iChannel0, ivec2(4, 0), 0).x;\n    vec2 offset = vec2(0.008, 0.008) * a;\n    vec4 col = texture(iChannel0, uv);\n    col.r = texture(iChannel0, uv + offset).r;\n    col.b = texture(iChannel0, uv - offset).b;\n\n    \n    // Vignette\n    col *= 1.0 - smoothstep(0.6, 1.5, length((fragCoord/iResolution.xy)*2.0-1.0));\n    \n    //col.rgb = vec3(a);\n    \n \tfragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4s2XW3","filepath":"https://soundcloud.com/elysianrecords/royalty","previewfilepath":"https://soundcloud.com/elysianrecords/royalty","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float N21(vec2 p)\n{\n \treturn fract(sin(dot(p, vec2(48.3354, 51.483))) * 40504.584);   \n}\n\nvec2 N22(vec2 p)\n{\n \tfloat n = N21(p);\n    return vec2(n, N21(p+n));\n}\n\nfloat circle(vec2 p, vec2 c, float r)\n{\n    vec2 j = (c-p) * 10.0;\n    return 1.0 / dot(j, j);\n\treturn smoothstep(r, r - 0.1, distance(p, c));   \n}\n\nfloat distanceToLineSegment(in vec2 a, in vec2 b, in vec2 p)\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n\treturn length(pa-ba*h);\n}\n\nfloat line(vec2 a, vec2 b, vec2 p)\n{\n    float d = distance(a, b); \n \treturn 1.0 - smoothstep(0.1 * max(0.0, 2.7 - d) - 0.2, 0.1 * max(0.0, 2.7 - d), distanceToLineSegment(a, b, p));   \n}\n\nfloat plexus(vec2 uv, float fft)\n{\n    float col = 0.0;\n\n    vec2 st = fract(uv);\n    st = st * 2.0 - 1.0;\n    \n    vec2 id = floor(uv);\n    \n    vec2 cc = vec2(sin((iTime+1.0) * N22(id).x) * 0.65, cos((iTime+1.0) * N22(id).y) * 0.65);\n    \n    for(float x=-1.0; x<2.0; x++)\n    {\n\t\tfor(float y=-1.0; y<2.0; y++)\n        {\n            // Draw circles\n\t\t\tvec2 nc = vec2(sin((iTime+1.0) * N22(id+vec2(x, y)).x) * 0.65, \n                           cos((iTime+1.0) * N22(id+vec2(x, y)).y) * 0.65)\n                \t\t\t+ vec2(2.0*x, 2.0*y); \n           \t\n    \t\tfloat c = circle(st, nc, 0.2);\n    \t\tcol += c * max(0.15, fft) * 2.5;\n            \n            if(x==0.0&&y==0.0)\n            {\n                continue;\n            }\n            \n            // Draw lines\n            col += line(cc, nc, st);\n        }\n    }\n    \n    // Draw overlap lines   \n    vec2 lc = vec2(sin((iTime+1.0) * N22(id+vec2(-1.0, 0.0)).x) * 0.65, cos((iTime+1.0) * N22(id+vec2(-1.0, 0.0)).y) * 0.65)+ vec2(-2.0, 0.0);    \n    vec2 rc = vec2(sin((iTime+1.0) * N22(id+vec2(1.0, 0.0)).x) * 0.65, cos((iTime+1.0) * N22(id+vec2(1.0, 0.0)).y) * 0.65) + vec2(2.0, 0.0);   \n    vec2 tc = vec2(sin((iTime+1.0) * N22(id+vec2(0.0, 1.0)).x) * 0.65, cos((iTime+1.0) * N22(id+vec2(0.0, 1.0)).y) * 0.65) + vec2(0.0, 2.0);  \n    vec2 bc = vec2(sin((iTime+1.0) * N22(id+vec2(0.0, -1.0)).x) * 0.65, cos((iTime+1.0) * N22(id+vec2(0.0, -1.0)).y) * 0.65) + vec2(0.0, -2.0);    \n    float tcrcl = line(tc, rc, st);\n    float tclcl = line(tc, lc, st);\n    float bcrcl = line(bc, rc, st);\n    float bclcl = line(bc, lc, st);   \n    col += tcrcl + tclcl + bcrcl + bclcl;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;  \n    uv *= 4.0;\n\n    vec3 col = vec3(0.0);\n       \n    float fft  = texelFetch( iChannel0, ivec2(1.0/255.0,0), 0 ).x; \n    \n    float rs = 0.1;\n    mat2 m;\n    m[0] = vec2(cos(iTime * rs), -sin(iTime * rs));\n    m[1] = vec2(sin(iTime * rs), cos(iTime * rs));\n    \n    uv *= m;   \n  \n    col += plexus(uv, fft);\n        \n    // Remove centre\n    vec2 cuv = fragCoord/iResolution.xy;\n    cuv = cuv * 2.0 - 1.0;\n    cuv.x *= iResolution.x / iResolution.y;    \n    col -= (1.0 - smoothstep(0.0, 0.9, length(cuv * 2.0)));\n    col = max(vec3(0.0), col);\n        \t\n    // Light\n    float l = 1.0 / (length(cuv * 4.));\n    \n    // Sample the audio\n    int tx = int((fragCoord/iResolution.xy).x * 256.0);\n    \n    tx = 4;\n    float a = texelFetch(iChannel0, ivec2(tx, 0), 0).x;\n    \n    l *= a;\n    \n    col += l;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}