{"ver":"0.1","info":{"id":"cdtXRB","date":"1680026629","viewed":111,"name":"Fork mobius gears","username":"gregmulvihill","description":"Mobius gears","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"fsXBzN","parentname":"mobius gears"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = atan(-1.0);\n\nmat2 rot(float a)\n{\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nvec2 fan(vec2 p, int n)\n{\n    float N = float(n);\n    float a = atan(p.y, p.x);\n    a = mod(a, pi * 2.0 / N) - pi / N;\n    return length(p) * vec2(cos(a), sin(a));\n}\n\nfloat box(vec3 p, vec3 s)\n{\n    vec3 d = abs(p) - s;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat map(vec3 p)\n{\n    float t = float(iFrame) / 60.0;\n    p *= sin(t * 0.7) * 0.50 - 0.75;//zoom in and out\n    p.xz *= rot(-1.8 + t*0.17);//rotate arount y\n    p.yz *= rot(-0.0 + t*0.31);//rotate arount x\n    p.xy *= rot(-0.0 + t*0.53);//rotate arount z\n\n    t *= 30.0;\n    float d = 1e3;\n\n    float k = 0.5;\n    float kk = 0.0625;\n    float n = -0.075;\n\n    float gears = 40.0;\n    float gearheight = 0.015;\n    float height = 0.05;\n    \n    vec3 q = -p;\n    \n    //if (0==1)\n    {\n        p.y -= k + kk;\n        p.x -= n;\n        p = p.yxz;\n\n        float a = atan(p.z, p.x);\n\n        //p.yz *= rot(-pi / 4.0);\n        p.xz *= rot( pi / 2.0);\n        p.yz *= rot(-pi / 2.0);\n        p.xz = fan(p.xz, 300) - vec2(k, 0.0);\n        p.xy *= rot(  a / 2.0);\n\n        d = min(d, box(p, vec3(0.1, height - (sin(a * gears + gears / (pi * 2.0) + t)) * gearheight, 5.0)));\n    }\n    \n    //if (0==1)\n    {\n        //q = -q;\n        q.y -= k + kk;\n        q.x -= n;\n        q = q.yxz;\n        \n        float a = atan(q.z, q.x);\n\n        //p.yz *= rot(-pi / 4.0);\n        q.xz *= rot( pi / 2.0);\n        q.yz *= rot(-pi / 2.0);\n        q.xz = fan(q.xz, 300) - vec2(k, 0.0);\n        q.xy *= rot(  a / 2.0);\n\n      d = min(d, box(q, vec3(0.1, height - (sin(a * gears                      - t)) * gearheight, 5.0)));\n    }\n\n    return d * 0.7;//teeth .1=soft or .9=sharp\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(1, 0) * 0.0025;//add zero makes it grainy\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    vec3 col = vec3(0);\n\n    float t = 0.0;\n    vec3 ro = vec3(0, 0, -5);\n    vec3 rd = normalize(vec3(uv, 2.5));\n    bool hit = false;\n\n    for (int i = 0; i < 128; ++i)\n    {\n        float h = map(ro + rd * t);\n        if (h < 00.01) { hit = true; break; }\n        if (t > 15.00) break;\n        t += h;\n    }\n\n    if (hit)\n    {\n        vec3 p = ro + rd * t;\n        vec3 n = normal(p);\n        vec3 l = normalize(vec3(3, 4, -5));\n        float dif = max(0.0, dot(l, n));\n        col += 0.05 + dif;\n    }\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}