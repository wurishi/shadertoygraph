{"ver":"0.1","info":{"id":"4ftyzr","date":"1730214026","viewed":138,"name":"AABB Soft Shadows","username":"aaron9000","description":"Faking soft shadows by estimating how close a ray travels to the nearest occluder. The shadows look reasonable but are bigger / wider than they should be.\n\nUse the mouse to adjust the camera.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","shadows","softshadows","aabb","soft"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Pseudocode\n// - cast ray\n// - on hit, cast shadow ray R towards each light\n// - if the path to the light is blocked, no light contribution\n// - otherwise:\n//     - find point P along R that minimizes distance to the nearest AABB edge\n//     - calculate distance D between P and the nearest AABB edge\n//     - calculate the ratio between D and T (where T is distance along R to reach P)\n//     - modulate the light intensity by the ratio\n\nstruct Ray {\n    vec3 from;\n    vec3 forward;\n};\nstruct RayIntersect {\n    float dist;\n    vec3 pos;\n    int box_index;\n};\nstruct AABB {\n    vec3 center;\n    vec3 half_dims;\n    vec3 albedo;\n};\nstruct Light {\n    vec3 color;\n    float radius;\n    float sharpness_factor;\n};\nconst float SMALL = 0.0001;\nconst RayIntersect RAY_MISS = RayIntersect(10000.0, vec3(0.0), 0);\n\n// Geometry\nconst vec3 TOWER_POS = vec3(0.0, -60.0, 0.0);\nconst float TOWER_SCALE = 0.65;\nconst vec3 FACTORY_POS = vec3(0.0, 60.0, 0.0);\nconst float FACTORY_SCALE = 0.8;\nconst vec3 CAGE_POS = vec3(0.0, -2.0, 0.0);\nconst float CAGE_SCALE = 0.85;\nconst int BOX_COUNT = 22;\nconst AABB BOXES[BOX_COUNT] = AABB[BOX_COUNT](\n    AABB(vec3(0.0, 0.0, -5.0), vec3(150.0, 250.0, 10.0) * 0.5, vec3(1.0)),\n    AABB(vec3(70.0, 0.0, 25.0), vec3(10.0, 250.0, 50.0) * 0.5, vec3(1.0)),\n    AABB(TOWER_POS + vec3(0.0, 0.0, 15.0) * TOWER_SCALE, vec3(30.0, 25.0, 30.0) * TOWER_SCALE * 0.5, vec3(0.6, 0.5, 0.5)),\n    AABB(TOWER_POS + vec3(0.0, 0.0, 50.0) * TOWER_SCALE, vec3(18.0, 15.0, 40.0) * TOWER_SCALE * 0.5, vec3(0.5, 0.6, 0.5)),\n    AABB(TOWER_POS + vec3(0.0, 0.0, 75.0) * TOWER_SCALE, vec3(12.0, 10.0, 12.0) * TOWER_SCALE * 0.5, vec3(0.5, 0.5, 0.6)),\n    AABB(TOWER_POS + vec3(0.0, 0.0, 87.0) * TOWER_SCALE, vec3(5.0, 4.0, 12.0) * TOWER_SCALE * 0.5, vec3(0.3, 0.3, 0.3)),\n    AABB(FACTORY_POS + vec3(0.0, 0.0, 16.0) * FACTORY_SCALE, vec3(30.0, 30.0, 16.0) * 0.5 * FACTORY_SCALE, vec3(0.9, 0.9, 0.9)),\n    AABB(FACTORY_POS + vec3(0.0, 0.0, 4.0) * FACTORY_SCALE, vec3(40.0, 40.0, 8.0) * 0.5 * FACTORY_SCALE, vec3(0.8, 0.8, 0.8)),\n    AABB(FACTORY_POS + vec3(0.0, -8.0, 26.0) * FACTORY_SCALE, vec3(24.0, 10.0, 5.0) * 0.5 * FACTORY_SCALE, vec3(0.6, 0.6, 0.6)),\n    AABB(FACTORY_POS + vec3(0.0, 8.0, 26.0) * FACTORY_SCALE, vec3(24.0, 10.0, 5.0) * 0.5 * FACTORY_SCALE, vec3(0.6, 0.6, 0.6)),\n    AABB(FACTORY_POS + vec3(-6.0, 0.0, 32.0) * FACTORY_SCALE, vec3(2.0, 2.0, 16.0) * 0.5 * FACTORY_SCALE, vec3(0.3, 0.3, 0.3)),\n    AABB(FACTORY_POS + vec3(6.0, 0.0, 32.0) * FACTORY_SCALE, vec3(2.0, 2.0, 16.0) * 0.5 * FACTORY_SCALE, vec3(0.3, 0.3, 0.3)),\n    AABB(CAGE_POS + vec3(-10.0, 0.0, 10.0) * CAGE_SCALE, vec3(4.0, 4.0, 20.0) * 0.5 * CAGE_SCALE, vec3(0.83, 0.76, 0.21)),\n    AABB(CAGE_POS + vec3(10.0, 0.0, 10.0) * CAGE_SCALE, vec3(4.0, 4.0, 20.0) * 0.5 * CAGE_SCALE, vec3(0.83, 0.76, 0.21)),\n    AABB(CAGE_POS + vec3(00.0, 0.0, 22.0) * CAGE_SCALE, vec3(24.0, 4.0, 4.0) * 0.5 * CAGE_SCALE, vec3(0.83, 0.76, 0.21)),\n    AABB(CAGE_POS + vec3(-10.0, -26.0, 10.0) * CAGE_SCALE, vec3(4.0, 4.0, 20.0) * 0.5 * CAGE_SCALE, vec3(0.83, 0.76, 0.21)),\n    AABB(CAGE_POS + vec3(10.0, -26.0, 10.0) * CAGE_SCALE, vec3(4.0, 4.0, 20.0) * 0.5 * CAGE_SCALE, vec3(0.83, 0.76, 0.21)),\n    AABB(CAGE_POS + vec3(00.0, -26.0, 22.0) * CAGE_SCALE, vec3(24.0, 4.0, 4.0) * 0.5 * CAGE_SCALE, vec3(0.83, 0.76, 0.21)),\n    AABB(CAGE_POS + vec3(-10.0, 26.0, 10.0) * CAGE_SCALE, vec3(4.0, 4.0, 20.0) * 0.5 * CAGE_SCALE, vec3(0.83, 0.76, 0.21)),\n    AABB(CAGE_POS + vec3(10.0, 26.0, 10.0) * CAGE_SCALE, vec3(4.0, 4.0, 20.0) * 0.5 * CAGE_SCALE, vec3(0.83, 0.76, 0.21)),\n    AABB(CAGE_POS + vec3(0.0, 26.0, 22.0) * CAGE_SCALE, vec3(24.0, 4.0, 4.0) * 0.5 * CAGE_SCALE, vec3(0.83, 0.76, 0.21)),\n    AABB(CAGE_POS + vec3(0.0, 0.0, 18.0) * CAGE_SCALE, vec3(4.0, 56.0, 4.0) * 0.5 * CAGE_SCALE, vec3(0.5))\n);\n\n// Lights\nconst float DIRECTIONAL = 0.3;\nconst float AMBIENT = 0.2;\nconst float DIRECT = 0.35;\nconst float POINT = 0.15;\nconst vec3 ENV_COLOR = vec3(0.6, 0.5, 0.8);\nconst vec3 DIRECTIONAL_LIGHT_DIR = vec3(0.649, -0.464, -0.603);\nconst int LIGHT_COUNT = 2;\nLight[LIGHT_COUNT] LIGHTS = Light[LIGHT_COUNT](\n    Light(vec3(1.0, 0.8, 0.5), 175.0, 30.0),\n    Light(vec3(0.5, 1.0, 0.7), 250.0, 10.0)\n);\n\n// AABB lookups\nconst vec3 CORNERS[8] = vec3[8](\n    vec3( 1.0,  1.0,  1.0),\n    vec3(-1.0,  1.0,  1.0),\n    vec3(-1.0, -1.0,  1.0),\n    vec3( 1.0, -1.0,  1.0),\n    vec3( 1.0,  1.0, -1.0),\n    vec3(-1.0,  1.0, -1.0),\n    vec3(-1.0, -1.0, -1.0),\n    vec3( 1.0, -1.0, -1.0)\n);\nconst vec3 LINE_DIRS[12] = vec3[12](\n    vec3( 0.0,  1.0,  0.0),\n    vec3(-1.0,  0.0,  0.0),\n    vec3( 0.0, -1.0,  0.0),\n    vec3( 1.0,  0.0,  0.0),\n    vec3( 0.0,  0.0, -1.0),\n    vec3( 0.0,  0.0, -1.0),\n    vec3( 0.0,  0.0, -1.0),\n    vec3( 0.0,  0.0, -1.0),\n    vec3( 0.0,  1.0,  0.0),\n    vec3(-1.0,  0.0,  0.0),\n    vec3( 0.0, -1.0,  0.0),\n    vec3( 1.0,  0.0,  0.0)\n);\nconst int LINE_STARTS[12] = int[12](3, 0, 1, 2, 3, 0, 1, 2, 7, 4, 5, 6);\n\n\nvec3 get_light_pos(int index){\n    float t = iTime + 32.5;\n    vec3[LIGHT_COUNT] lights = vec3[LIGHT_COUNT](\n        vec3(-35.0, 0.0, 45.0) + vec3(sin(t * 0.53) * 5.0, sin(t * 0.51) * 80.0, sin(t * 0.76) * 40.0),\n        vec3(35.0, 0.0, 45.0) + vec3(sin(t * 0.42) * 5.0, sin(t * 0.67) * 80.0, sin(t * 0.91) * 40.0)\n    );\n    return lights[index];\n}\n\nvec3 get_camera_pos(){\n    vec2 m = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 orbit = vec3(0.0, clamp(m.x, -0.5, 0.5), clamp(-m.y, -0.5, 0.5)) * 200.0;\n    return vec3(-100.0, 0.0, 100.0) + orbit;\n}\n\nfloat sample_volume_intersect(RayIntersect intersect, float sample_size, vec3 normal){\n    vec3 half_dims = vec3(sample_size) * 0.5;\n    vec3 center = intersect.pos + normal * sample_size * 0.5;\n    float sum = 0.0;\n    for (int i = 0; i < BOX_COUNT; i++){\n        AABB box = BOXES[i];\n        vec3 maxes = max(center + half_dims, box.center + box.half_dims);\n        vec3 mins = min(center - half_dims, box.center - box.half_dims);\n        vec3 intersect = max((half_dims + box.half_dims) * 2.0 - (maxes - mins), vec3(0.0));\n        sum += intersect.x * intersect.y * intersect.z;\n    }\n    float initial_volume = half_dims.x * half_dims.y * half_dims.z * 8.0;\n    return clamp(sum / initial_volume, 0.0, 1.0);\n}\n\n// Volume-intersect AO\n// https://aarongeisler.com/2023/12/31/volume-intersect-ao/\n// https://www.shadertoy.com/view/4clGWS\nfloat calculate_occlusion(RayIntersect intersect, vec3 normal){\n    float sample_size = 15.0;\n    float strength = 0.3;\n    float intersect_volume = 0.0;\n    float sum = 0.0;\n    for (int i = 0; i < 6; i++){\n        intersect_volume = sample_volume_intersect(intersect, sample_size, normal);\n        sum += strength * intersect_volume;\n        if (intersect_volume <= SMALL){\n            return clamp(sum, 0.0, 1.0);\n        }\n        sample_size *= 0.5;\n    }\n    return clamp(sum, 0.0, 1.0);\n}\n\nRayIntersect ray_sphere_intersect(Ray ray, vec3 pos, float radius, int index) {\n    vec3 ray_to_sphere = ray.from - pos;\n    float d = dot(ray_to_sphere, ray.forward);\n    float p = dot(ray_to_sphere, ray_to_sphere) - radius * radius;\n    float h = d * d - p;\n    if (h < 0.0) {\n       return RAY_MISS;\n    }else{\n       h = sqrt(h);\n       float t = -d - h;\n       return RayIntersect(t, ray.from + (t * ray.forward), -index - 1);\n    }\n}\n\nRayIntersect ray_aabb_intersect(Ray ray, int box_index){\n    AABB aabb = BOXES[box_index];\n    vec3 box_min = aabb.center - aabb.half_dims;\n    vec3 box_max = aabb.center + aabb.half_dims;\n    vec3 t_min = (box_min - ray.from) / ray.forward;\n    vec3 t_max = (box_max - ray.from) / ray.forward;\n    vec3 t1 = min(t_min, t_max);\n    vec3 t2 = max(t_min, t_max);\n    float t_near = max(max(t1.x, t1.y), t1.z);\n    float t_far = min(min(t2.x, t2.y), t2.z);\n    if ((step(t_near, t_far) * step(0.0, t_far)) == 0.0) {\n       return RAY_MISS;\n    }else{\n       return RayIntersect(t_near, ray.from + (t_near * ray.forward), box_index);\n    }\n}\n\nRayIntersect find_closest_intersect(Ray ray){\n    RayIntersect closest_intersect = RAY_MISS; \n    for (int i = 0; i < BOX_COUNT; i++){\n        RayIntersect intersect = ray_aabb_intersect(ray, i);\n        if (intersect.dist < closest_intersect.dist){\n            closest_intersect = intersect;\n        }\n    }\n    for (int i = 0; i < LIGHT_COUNT; i++){\n        RayIntersect light_intersect = ray_sphere_intersect(ray, get_light_pos(i), 50.0 / LIGHTS[i].sharpness_factor, i);\n        if (light_intersect.dist < closest_intersect.dist){\n            closest_intersect = light_intersect;\n        }\n    }\n    return closest_intersect;\n}\n\nfloat calculate_min_distance_between_ray_and_aabb(float curr_lowest, Ray ray, int box_index, float max_dist){\n    AABB aabb = BOXES[box_index];\n    float lowest_dist = curr_lowest;\n    vec3 dims = aabb.half_dims * 2.0;\n    for (int i = 0; i < 12; i++){\n        vec3 l_start = CORNERS[LINE_STARTS[i]] * aabb.half_dims + aabb.center;\n        vec3 line_dir_scaled = dims * LINE_DIRS[i];\n        float line_mag = abs(line_dir_scaled.x + line_dir_scaled.y + line_dir_scaled.z);\n        vec3 line_start_to_ray_start = ray.from - l_start;\n        float b = dot(ray.forward, line_dir_scaled);\n        float c = line_mag * line_mag;\n        float d = dot(ray.forward, line_start_to_ray_start);\n        float e = dot(line_dir_scaled, line_start_to_ray_start);\n        float det = c - b * b;\n        float t = clamp((b * e - c * d) / det, 0.0, max_dist);\n        float s = clamp((e - b * d) / det, 0.0, 1.0);\n        float dist = distance(l_start + line_dir_scaled * s, ray.from + ray.forward * t);\n        lowest_dist = min(lowest_dist, dist / t);\n    }\n    return lowest_dist;\n}\n\nvec3 calculate_dynamic_light(vec3 normal, RayIntersect intersect){\n    vec3 sum = vec3(0.0);\n    for (int i = 0; i < LIGHT_COUNT; i++){\n        Light light = LIGHTS[i];\n\n        // Direct lighting w/ fake soft shadows\n        vec3 intersect_to_light = get_light_pos(i) - intersect.pos;\n        float dist_to_light = length(intersect_to_light);\n        Ray shadow_ray = Ray(intersect.pos + normal * SMALL, normalize(intersect_to_light));\n        RayIntersect shadow_intersect = RAY_MISS; \n        float lowest = 1.0;\n        for (int i = 0; i < BOX_COUNT; i++){        \n            shadow_intersect = ray_aabb_intersect(shadow_ray, i);\n            if (shadow_intersect.dist < dist_to_light){\n                lowest = 0.0;\n                break;\n            }\n            lowest = calculate_min_distance_between_ray_and_aabb(lowest, shadow_ray, i, dist_to_light);\n        }\n        float light_visibility = 1.0 - smoothstep(0.0, 1.0, 1.0 - clamp(lowest * light.sharpness_factor, 0.0, 1.0 - SMALL));\n        float falloff = 1.0 - clamp(dist_to_light / light.radius, 0.0, 1.0);\n        float direct_light = light_visibility * falloff * falloff * DIRECT; \n        \n        // Point lighting (a little bit looks nice)\n        float ratio = dist_to_light / light.radius;\n        float point_light = POINT / (1.0 + 6.0 * ratio * ratio);  \n        sum += (point_light + direct_light) * light.color;\n    }\n    return sum;\n}\n\n\nvec3 world_fragment(Ray ray, RayIntersect intersect){\n\n    // Lights\n    if (intersect.box_index < 0){\n        Light light = LIGHTS[-intersect.box_index - 1];\n        return mix(vec3(1.0), light.color, 1.0);\n    }\n    \n    // Geometry\n    AABB aabb = BOXES[intersect.box_index];\n    vec3 delta_center = aabb.center - intersect.pos;\n    vec3 mag = abs(delta_center / aabb.half_dims);\n    vec3 normal = (mag.x > mag.y && mag.x > mag.z) ? \n                    vec3(-sign(delta_center.x), 0.0, 0.0) :\n                        (mag.y > mag.x && mag.y > mag.z) ? \n                        vec3(0.0, -sign(delta_center.y), 0.0) : \n                        vec3(0.0, 0.0, -sign(delta_center.z));\n                            \n    \n    // Ambient lighting / AO\n    float occlusion = calculate_occlusion(intersect, normal);\n    float directional = 1.0 - ((dot(normal, DIRECTIONAL_LIGHT_DIR) + 1.0) * 0.5);\n    vec3 ambient_light = (1.0 - occlusion) * directional * (AMBIENT + DIRECTIONAL) * ENV_COLOR;\n\n    // Dynamic light\n    vec3 light_sum = calculate_dynamic_light(normal, intersect);\n    \n    return BOXES[intersect.box_index].albedo * (light_sum + ambient_light);\n}\n\nvec3 bg_fragment(Ray ray, RayIntersect intersect){\n    float light_value = 1.0 - (0.5 * (dot(DIRECTIONAL_LIGHT_DIR, ray.forward) + 1.0));\n    return vec3((light_value * DIRECTIONAL) + AMBIENT) * ENV_COLOR;\n}\n\nRay camera_ray(vec2 fragCoord){\n    vec3 camera_pos = get_camera_pos();\n    vec3 fwd = normalize(vec3(0.0, 0.0, 10.0) - camera_pos);\n    vec3 left = cross(fwd, vec3(0.0, 0.0, 1.0));\n    vec3 up = cross(left, fwd);\n    mat3 rot = mat3(left, fwd, up);\n    vec2 uv = fragCoord / iResolution.xy;\n    float aspect_ratio = iResolution.x / iResolution.y;\n    vec3 ray_fwd = rot * normalize(vec3((uv.x - 0.5) * aspect_ratio, 1.0, (uv.y - 0.5)));\n    return Ray(camera_pos, normalize(ray_fwd));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    Ray ray = camera_ray(fragCoord);\n    RayIntersect intersect = find_closest_intersect(ray);\n    vec3 color = intersect == RAY_MISS ? bg_fragment(ray, intersect) : world_fragment(ray, intersect);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}