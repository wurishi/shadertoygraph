{"ver":"0.1","info":{"id":"Ntcyz7","date":"1661977782","viewed":967,"name":"Pathtraced voxel city","username":"morimea","description":"Very simple voxel city.\nVoxels with interior mapping,\nPathtracer with reprojection.\n\nBecause ANGLE main scene turn off, to see main scene:\n[b]Edit Common, delete #define NO_COMPILE[/b]\n\nTo disable ANGLE:\n[code]chrome.exe --use-angle=gl[/code]","likes":40,"published":1,"flags":48,"usePreview":0,"tags":["procedural","voxels","pathtracer","city","reprojection","interior"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Created by Danil (2022+) https://github.com/danilw\n// License - The MIT License\n\n// self https://www.shadertoy.com/view/Ntcyz7\n\n\n// using https://www.shadertoy.com/view/3dlSW7\n// using https://www.shadertoy.com/view/WdjcDd\n\n\n// this pathtracer minimal template \n// https://www.shadertoy.com/view/fsyBRW\n\n// interior and box\n// https://www.shadertoy.com/view/sltyR2\n\n\n// look parameters in Common(on top)\n// (delete NO_COMPILE in Common to make shader work)\n// Compiling disabled because ANGLE compile it too slow\n// Shader performance fast enough to run even on integrated GPU (teted)\n\n\n// remember to set mipmaps to iChannel3 in Image to use bloom\n//#define use_bloom\n#ifdef use_bloom\nmat3 gaussianFilter = mat3(41, 26, 7,\n                           26, 16, 4,\n                           7,  4,  1) / 273.;\n// bloom\nvec3 bloom(float scale, float threshold, vec2 fragCoord){\n    float logScale = log2(scale);\n    vec3 bloom = vec3(0);\n    for(int y = -2; y <= 2; y++)\n        for(int x = -2; x <= 2; x++)\n            bloom += gaussianFilter[abs(x)][abs(y)] * textureLod(iChannel3, (fragCoord+vec2(x, y)*scale)/iResolution.xy, logScale).rgb;\n    return max(bloom - vec3(threshold), vec3(0));\n}\n#endif\n\n\n// volume raymarch mix color\n//----------------------------------------------\n#ifdef enable_volume\n\nvec3 raymarchVolume_image(vec3 backGround, float absorb, vec3 sunColor, float lDotV, float fogLitPercent){\n    \n    float phaseMie = hGPhase(lDotV, 0.8);\n    \n    vec3 c_fogColorLit = backGround+sunColor * phaseMie*0.5+0.0005*(0.5+sunColor*0.5);\n    const vec3 c_fogColorUnlit = vec3(0.);\n    \n    vec3 fogColor = mix(c_fogColorUnlit, c_fogColorLit, fogLitPercent*fogLitPercent*fogLitPercent);\n    return mix(fogColor, backGround, absorb);\n}\n#endif\n//----------------------------------------------\n\nvec3 ACESFilm(vec3 x);\nvec3 srgb_encode (vec3 v);\nfloat print_UI0(vec2 U);float print_UI1(vec2 U);\nfloat print_UI2(vec2 U);float print_UI3(vec2 U);\nfloat print_UI4(vec2 U);float print_UI5(vec2 U);\nfloat print_UI6(vec2 U);float print_text_nc(vec2 U);\nfloat print_UI7(vec2 U);float print_UI8(vec2 U);\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if(texelFetch(iChannel0,spos_ui,0).a>0.5)lightDir=lightDir2;\n    if(texelFetch(iChannel0,spos_ui,0).a>1.5)lightDir=lightDir3;\n    float spui=load(sun_pow_ui, iChannel0);\n    if(spui>0.5)sunIluminance=0.85;\n    if(spui>1.5)sunIluminance=0.5;\n    if(spui>2.5)sunIluminance=0.15;\n    \n    vec2 fc = fragCoord.xy;\n    \n    vec3 color = texelFetch(iChannel3, ivec2(fc), 0).rgb;\n    \n#ifdef enable_volume\n    float fogLitPercent = texelFetch(iChannel2, ivec2(fc), 0).a;\n    float absorb = texelFetch(iChannel3, ivec2(fc), 0).a;\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    vec3 ro;\n    vec3 rd;\n    SetCamera(uv, iChannel0, ro, rd, iResolution.xy);\n    \n    vec3 sunColor = calculateSunColor(lightDir.y);\n    float lDotV = dot(rd, lightDir);\n    color = raymarchVolume_image(color, absorb, sunColor, lDotV, fogLitPercent);\n#endif\n\n    vec3 blom = vec3(0.);\n#ifdef use_bloom\n    blom += bloom(.015 * iResolution.y, 0.002,fragCoord)*0.05;\n    blom += bloom(.05 * iResolution.y, 0.002,fragCoord)*0.025;\n#endif\n    \n    color = ACESFilm(color+blom);\n    color = srgb_encode(color);\n    \n\tfragColor = vec4(color, 1.0 );\n#ifndef NO_COMPILE\n    if(texelFetch(iChannel0,hide_ui,0).a<0.5)\n    {\n        vec2 res = iResolution.xy/iResolution.y;\n        vec2 tuv = fragCoord/iResolution.y * 2.0 - res;\n        vec2 char=res/7.;\n        if(tuv.y>res.y-char.y*9.&&tuv.x>res.x-1.7)\n        {\n            fragColor.rgb*=0.75;\n            if(tuv.y>res.y-char.y){\n                float d = print_UI0((tuv-res)*7.-vec2(-11.,-1.));\n                fragColor.rgb = mix(fragColor.rgb,vec3(1.),d);\n            }else\n            if(tuv.y>res.y-char.y*2.){\n                float d = print_UI1((tuv-res)*7.-vec2(-11.,-2.));\n                fragColor.rgb = mix(fragColor.rgb,vec3(1.),d);\n            }else\n            if(tuv.y>res.y-char.y*3.){\n                float d = print_UI2((tuv-res)*7.-vec2(-11.,-3.));\n                fragColor.rgb = mix(fragColor.rgb,vec3(1.),d);\n            }\n            else\n            if(tuv.y>res.y-char.y*4.){\n                float d = print_UI3((tuv-res)*7.-vec2(-11.,-4.));\n                fragColor.rgb = mix(fragColor.rgb,vec3(1.),d);\n            }else\n            if(tuv.y>res.y-char.y*5.){\n                float d = print_UI4((tuv-res)*7.-vec2(-11.,-5.));\n                fragColor.rgb = mix(fragColor.rgb,vec3(1.),d);\n            }else\n            if(tuv.y>res.y-char.y*6.){\n                float d = print_UI5((tuv-res)*7.-vec2(-11.,-6.));\n                fragColor.rgb = mix(fragColor.rgb,vec3(1.),d);\n            }else\n            if(tuv.y>res.y-char.y*7.){\n                float d = print_UI6((tuv-res)*7.-vec2(-11.,-7.));\n                fragColor.rgb = mix(fragColor.rgb,vec3(1.),d);\n            }else\n            if(tuv.y>res.y-char.y*8.){\n                float d = print_UI7((tuv-res)*7.-vec2(-11.,-8.));\n                fragColor.rgb = mix(fragColor.rgb,vec3(1.),d);\n            }else\n            if(tuv.y>res.y-char.y*9.){\n                float d = print_UI8((tuv-res)*7.-vec2(-11.,-9.));\n                fragColor.rgb = mix(fragColor.rgb,vec3(1.),d);\n            }\n        }\n    }\n#else\n    vec2 res = iResolution.xy/iResolution.y;\n    vec2 tuv = fragCoord/iResolution.y * 2.0 - res;\n    vec2 char=res/5.5;\n    if(tuv.y>res.y-char.y*4.&&tuv.x>res.x-2.7)\n    {\n        fragColor.rgb*=0.75;\n        float d = print_text_nc((tuv-res)*5.5-vec2(-15.,-1.));\n        fragColor.rgb = mix(fragColor.rgb,vec3(1.),d);\n    }\n#endif\n   \n}\n\n\n\nvec3 ACESFilm(vec3 x){\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\nvec3 srgb_encode (vec3 v) {\n  return mix(12.92*v,1.055*pow(v,vec3(.41666))-.055,step(.0031308,v));\n}\n\n\n//using https://www.shadertoy.com/view/llyXRW\n\nvoid C(inout vec2 U, inout vec4 T, in int c, bool dir){\n    U.x+=dir?.5:-0.5;\n    vec2 tu=U/16. + fract( vec2(float(c), float(15-c/16)) / 16.);\n    vec4 tT= textureGrad( iChannel1,tu, dFdx(tu/16.),dFdy(tu/16.));\n    if(U.x<.0||U.x>1.||U.y<0.||U.y>1. ){\n        T+= vec4(0);\n    }\n    else{\n        T+= tT;\n    }\n}\n\nconst int text0[]=int[](72, 105, 100, 101, 32, 85, 73);\nconst int text1[]=int[](82, 101, 102, 108, 101, 99, 116, 105, 111, 110);\nconst int text2[]=int[](50, 110, 100, 32, 108, 105, 103, 104, 116, 32, 98, 111, 117, 110, 99, 101);\nconst int text3[]=int[](108, 105, 103, 104, 116, 32, 119, 105, 110, 100, 111, 119);\nconst int text4[]=int[](83, 117, 110, 32 );\nconst int text5[]=int[](114, 111, 111, 109, 115 );\nconst int text6[]=int[](99, 111, 108, 111, 114, 32, 98, 117, 105, 108, 100, 105, 110, 103);\nconst int text7[]=int[](83, 117, 110, 32, 112, 111, 119, 101, 114);\nconst int text8[]=int[](68, 97, 121);\nconst int text9[]=int[](77, 101, 100);\nconst int text10[]=int[](76, 111, 119);\nconst int text11[]=int[](78, 105, 103, 104, 116);\n\nfloat print_UI0(vec2 U){\n    vec4 T=vec4(0.);\n    for(int i=0;i<text0.length();i++){\n        C(U,T,text0[i], false);\n    }\n    if(length(T.yz)==0.)\n        return 0.;\n    return T.x;\n}\nfloat print_UI1(vec2 U){\n    vec4 T=vec4(0.);\n    int c4 = 43;\n    if(texelFetch(iChannel0,refl_ui,0).a>0.5)c4=45;\n    C(U,T,c4, false);\n    for(int i=0;i<text1.length();i++){\n        C(U,T,text1[i], false);\n    }\n    if(length(T.yz)==0.)\n        return 0.;\n    return T.x;\n}\nfloat print_UI2(vec2 U){\n    vec4 T=vec4(0.);\n    int c4 = 43;\n    if(texelFetch(iChannel0,lght_ui,0).a>0.5)c4=45;\n    C(U,T,c4, false);\n    for(int i=0;i<text2.length();i++){\n        C(U,T,text2[i], false);\n    }\n    if(length(T.yz)==0.)\n        return 0.;\n    return T.x;\n}\nfloat print_UI3(vec2 U){\n    vec4 T=vec4(0.);\n    int c4 = 43;\n    if(texelFetch(iChannel0,rlght_ui,0).a>0.5)c4=45;\n    C(U,T,c4, false);\n    for(int i=0;i<text3.length();i++){\n        C(U,T,text3[i], false);\n    }\n    if(length(T.yz)==0.)\n        return 0.;\n    return T.x;\n}\nfloat print_UI4(vec2 U){\n    vec4 T=vec4(0.);\n    int c4 = 43;\n    if(texelFetch(iChannel0,spos_ui,0).a<0.5)c4=45;\n    C(U,T,c4, false);\n    for(int i=0;i<text4.length();i++){\n        C(U,T,text4[i], false);\n    }C(U,T,49, false);C(U,T,32, false);\n    c4 = 43;\n    if(texelFetch(iChannel0,spos_ui,0).a>0.5&&texelFetch(iChannel0,spos_ui,0).a<1.1)c4=45;\n    C(U,T,c4, false);\n    for(int i=0;i<text4.length();i++){\n        C(U,T,text4[i], false);\n    }C(U,T,50, false);C(U,T,32, false);\n    c4 = 43;\n    if(texelFetch(iChannel0,spos_ui,0).a>1.5)c4=45;\n    C(U,T,c4, false);\n    for(int i=0;i<text4.length();i++){\n        C(U,T,text4[i], false);\n    }C(U,T,51, false);C(U,T,32, false);\n    if(length(T.yz)==0.)\n        return 0.;\n    return T.x;\n}\nfloat print_UI5(vec2 U){\n    vec4 T=vec4(0.);\n    int c4 = 43;\n    if(texelFetch(iChannel0,voxbox_ui,0).a>0.5)c4=45;\n    C(U,T,c4, false);\n    for(int i=0;i<text5.length();i++){\n        C(U,T,text5[i], false);\n    }\n    if(length(T.yz)==0.)\n        return 0.;\n    return T.x;\n}\nfloat print_UI6(vec2 U){\n    vec4 T=vec4(0.);\n    int c4 = 43;\n    if(texelFetch(iChannel0,color_ui,0).a>0.5)c4=45;\n    C(U,T,c4, false);\n    for(int i=0;i<text6.length();i++){\n        C(U,T,text6[i], false);\n    }\n    if(length(T.yz)==0.)\n        return 0.;\n    return T.x;\n}\nfloat print_UI7(vec2 U){\n    vec4 T=vec4(0.);\n    for(int i=0;i<text7.length();i++){\n        C(U,T,text7[i], false);\n    }\n    if(length(T.yz)==0.)\n        return 0.;\n    return T.x;\n}\nfloat print_UI8(vec2 U){\n    vec4 T=vec4(0.);\n    float spui=load(sun_pow_ui, iChannel0);\n    int c4 = 43;\n    if(spui<0.5)c4=45;\n    C(U,T,c4, false);\n    for(int i=0;i<text8.length();i++){\n        C(U,T,text8[i], false);\n    }C(U,T,32, false);\n    c4 = 43;\n    if(spui>0.5&&spui<1.5)c4=45;\n    C(U,T,c4, false);\n    for(int i=0;i<text9.length();i++){\n        C(U,T,text9[i], false);\n    }C(U,T,32, false);\n    c4 = 43;\n    if(spui>1.5&&spui<2.5)c4=45;\n    C(U,T,c4, false);\n    for(int i=0;i<text10.length();i++){\n        C(U,T,text10[i], false);\n    }C(U,T,32, false);\n    c4 = 43;\n    if(spui>2.5)c4=45;\n    C(U,T,c4, false);\n    for(int i=0;i<text11.length();i++){\n        C(U,T,text11[i], false);\n    }\n    if(length(T.yz)==0.)\n        return 0.;\n    return T.x;\n}\n\nconst int text_nc1[]=int[](84, 111, 32, 67, 111, 109, 112, 105, 108, 101, 58);\nconst int text_nc2[]=int[](69, 100, 105, 116, 32, 67, 111, 109, 109, 111, 110);\nconst int text_nc3[]=int[](100, 101, 108, 101, 116, 101, 32, 35, 100, 101, 102, 105, 110, 101, 32, 78, 79, 95, 67, 79, 77, 80, 73, 76, 69);\n\nfloat print_text_nc(vec2 U){\n    vec4 T=vec4(0.);\n    vec2 oU=U;\n    for(int i=0;i<text_nc1.length();i++){\n        C(U,T,text_nc1[i], false);\n    }\n    U=oU;\n    U.y+=1.;\n    for(int i=0;i<text_nc2.length();i++){\n        C(U,T,text_nc2[i], false);\n    }\n    U=oU;\n    U.y+=2.;\n    for(int i=0;i<text_nc3.length();i++){\n        C(U,T,text_nc3[i], false);\n    }\n    if(length(T.yz)==0.)\n        return 0.;\n    return T.x;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n// delete this define to compile scene\n#define NO_COMPILE\n\n\n// voxels size of scene\n// ---------------\n\n// max vec2(40,40) because I save object id as float\nconst vec2 voxels_num=vec2(8.,8.); // number of voxels\n\nconst float voxel_h = 8.; // voxels max height\n\nconst float camera_fov = 70.;\n// ---------------\n\n#define AORays 5\n#define reflectionRays 5\n#define shadowRays 3\n\n\n// (controlled by UI)\n#define sunlight_2nd_bounce\n#define enable_reflections\n\n// add emission color to reflection\n#define reflection_color_emi\n\n#define use_ConeVector\n#define use_reproject_TAA\n\n// ---------------\n//ANGLE\n\n// does not speedup compiling\n#define ANGLE_loops 0\n//#define ANGLE_loops min(iFrame,0)\n\n//look line 1136 Common\n// single call BoxIntersectMin_interior make ANGLE compile time +30 sec from 1.5\n// two calls to BoxIntersectMin_interior 60+sec... so ANGLE just explode shader code when this function used\n\n// ---------------\n\n\n// ---------------\n// volumetric shadow\n//#define enable_volume\n#define volumeSteps 10\nconst float volume_fogDensity = .125;\n\n// render only boxes instead of building\n//#define voxel_box_only\nbool ui_voxel_box_only;\n\n//#define box_floor\nconst vec3 floor_rooms = vec3(2.,4.,2.);\nconst vec2 floor_border = vec2(0.48,0.4);\n\n// ---------------\n\n// sun pos\nvec3 lightDir = normalize(vec3(0.5, .185, 1.0));\nconst vec3 lightDir2 = normalize(vec3(0.5, .85, 1.0));\nconst vec3 lightDir3 = normalize(vec3(0.5, 7.85, 1.0));\n\n\n// ---------------\n\nconst float pltf_h = .85;// platform box height\nconst float pltf_sp = 1.25;// platform box free space from ground\n\nconst int max_vox_draw = 150; //max voxel loops, max distance for voxels, clamped to 10000 max\n// shadow can be broken when set low number\n//const int max_vox_draw = int(max(voxels_num.x,voxels_num.y))*10;\n\nconst int max_vox_draw_AO_light = 20; // voxel loops(vis range) for AO and light\nconst int max_vox_draw_reflection = 20; // voxel loops(vis range) for reflections\n\n// ---------------\n\n// OBJ_ is >=0 and <1000, not negative\n// OBJ_ is second value in voxel ID\n#define OBJ_SKY 0\n#define OBJ_SPHERE 1\n#define OBJ_FLOOR 2\n#define OBJ_BOX 3\n#define OBJ_BOX_build 4\n#define OBJ_BOX_room 5\n#define OBJ_BOX_build_floor 6\n#define OBJ_BOX_room_b_floor 7\n#define OBJ_BOX_floor_emi 8\n#define OBJ_BOX_build_ncomp 9\n#define OBJ_BOX_room_b_ncomp 10\n\n\nfloat hash12(vec2 p);\nfloat hash13(vec3 p3);\nvec2 hash22(vec2 p);\nvec3 hash32(vec2 p);\n\n// ---------------\n\n// voxel map\n// ---------------\n\nconst vec3 bpos=vec3(0.0, pltf_h+pltf_sp, 0.0); // position of model (dont edit)\n\n// pos=vec2(1 to (voxels_num*2+1) xy), boxs is voxels_num+0.5\n// return height\nfloat get_heightField(vec2 pos, vec2 boxs)\n{\n//return 1.;\n    vec2 hash = hash22(30.*pos/(boxs*2.));\n    float h = 1.-3.*length(pos-boxs-.5)/length(boxs*2.); // 1 at middle\n    h=clamp(h,0.35,1.);\n    h *= h*(0.3+0.7*hash.x)* (0.3+0.7*hash.y);\n    h=clamp(h*2.,0.025,1.);\n    return h;\n}\n\n// resturn shifted position and size (of box, without height)\n// return vec4(vec2(center), vec2(size))\nvec4 get_vox_size(vec2 pos, vec2 boxs){\n    vec3 hash = hash32(30.*pos/(boxs*2.));\n    vec2 w = .105 + .295 * abs(hash.xy);\n    vec2 center = vec2(pos.x, pos.y);\n    center.xy += vec2(.5 - w) * (vec2(hash.y, hash.z) * 2. - 1.);\n    return vec4(vec2(center),vec2(w));\n}\n\n// ---------------\n\n#ifdef NO_COMPILE\nvec3 box_ncomp_rooms = vec3(4.,12.,6.);\n#endif\n\n\n#define PI 3.141592653589793\n#define TAU 6.283185307179586\n#define c_goldenRatioConjugate 0.61803398875f\n#define upVec vec3(0.0, 1.0, 0.0)\n\n#define MAX_DIST 1000.\n#define MIN_DIST .0001\n\n\n// ---------------\n\n// material by object id\n// remember about dFd bugs\n// ---------------\n\n// this color used only by reflection on objects\n// OBJ_FLOOR for scene has sky color (set in get_scene_material)\nvoid material_OBJ_FLOOR(vec3 pos, vec3 norm, out vec3 albedo, out vec3 emission, \n                        out float roughness, out float metalness){\n    albedo = vec3(1.);\n    emission = vec3(0.);\n    roughness = 0.15;\n    metalness = 0.35;\n}\n\n// box on floor \nvoid material_OBJ_BOX(vec3 pos, vec3 norm, out vec3 albedo, out vec3 emission, \n                        out float roughness, out float metalness){\n    albedo = vec3(0.98);\n    emission = vec3(0.);\n    roughness = 0.31;\n    metalness = 0.317;\n}\n\n\nvec3 tex_Window_border(vec3 pos, vec3 nor, vec3 box, vec3 bbox, vec2 s);\nbool lghtwin;\nbool colors_;\nfloat iwt;\nfloat cwt;\n// return material for voxel object\nvoid material_OBJ_BOX_in_voxel(vec3 pos, int obj_id, vec3 norm, out vec3 albedo, out vec3 emission, \n                        out float roughness, out float metalness){\n    int tix = obj_id/1000-1;\n    int lid = obj_id-(obj_id/1000)*1000;\n    vec2 vox_id = vec2(float(tix%int((voxels_num.x+0.5)*2.)),float(tix/int((voxels_num.x+0.5)*2.)));\n        \n    float hs = hash12(vox_id+1.);\n    vec3 cb = vec3(1.);\n    float hs_col = 0.;\n    \n    if(colors_){\n        hs_col = hash12((vox_id+1.)*13.33+3.123+cwt*6.33);\n        vec3 cb1 = vec3(0.4,0.6,1.);\n        vec3 cb2 = vec3(0.3,1.,0.4);\n        if(hs_col>0.33)cb=cb1;\n        if(hs_col>0.63)cb=cb2;\n    }\n    \n    albedo = cb*(0.45+0.55*vec3(1.-hs*hs*hs));\n    emission = vec3(0.);\n    roughness = 0.31;\n    metalness = 0.17;\n    if(lid==OBJ_BOX){\n        if(abs(norm.y)<0.5)\n        {\n            vec2 box = voxels_num+0.5;\n            float max_h=voxel_h;\n            float voxh = max(get_heightField(vox_id+1.,box),0.001)*max_h;\n            vec4 boxp = get_vox_size(vox_id+1.,box);\n            vec3 opos = vec3(boxp.x+0.5,-0.+voxh,boxp.y+0.5);\n            vec3 box_v = vec3(boxp.z,voxh,boxp.w);\n            vec3 ir=max(floor(box_v/0.1),vec3(2.,2.,2.));\n            ir+=2.*fract(ir/2.);\n            vec2 s = vec2(0.48);\n            if(voxh/max_h<0.3)s = vec2(0.248);\n            pos=pos+vec3(box.x,0.,box.y);\n            pos=pos-opos+vec3(1.,-pltf_h,1.);\n            vec3 twb = tex_Window_border(pos, norm, box_v, ir, s);\n            if(twb.x>0.5){\n                if(lghtwin){\n                    float hx = hash12(iwt+3.133+(twb.yz*(norm.xz+2.5))*8.3+vox_id);\n                    float hx2 = hash12(iwt+.133+(twb.yz*(norm.xz+2.5))*3.3+vox_id);\n                    vec3 c1 = vec3(1.,0.7,0.3);\n                    vec3 c2 = vec3(0.6,0.8,1.);\n                    vec3 c = hx2>0.5?c1:c2;\n                    emission = c*4.5*vec3(step(0.85,hx*hx*hx));\n                }\n                roughness = 0.131;\n                metalness = 0.17;\n            }else albedo*=0.85;\n        }\n    }else if(lid==OBJ_BOX_room){\n        if(colors_){\n            cb = vec3(1.);\n            vec3 cb2 = vec3(1.0,0.5,0.1);\n            vec3 cb1 = vec3(0.88,0.6,1.0);\n            if(hs_col>0.33)cb=cb1;\n            if(hs_col>0.63)cb=cb2;\n            albedo = cb*(0.45+0.55*vec3(1.-hs*hs*hs));\n        }\n        if(lghtwin){\n            if(norm.y<-0.5){\n                vec2 box = voxels_num+0.5;\n                float max_h=voxel_h;\n                float voxh = max(get_heightField(vox_id+1.,box),0.001)*max_h;\n                vec4 boxp = get_vox_size(vox_id+1.,box);\n                vec3 opos = vec3(boxp.x+0.5,-0.+voxh*0.,boxp.y+0.5);\n                vec3 box_v = vec3(boxp.z,voxh,boxp.w);\n                vec3 ir=max(floor(box_v/0.1),vec3(2.,2.,2.));\n                ir+=2.*fract(ir/2.);\n                vec2 s = vec2(0.48);\n                if(voxh/max_h<0.3)s = vec2(0.248);\n                pos=pos+vec3(box.x,0.,box.y);\n                pos=pos-opos+vec3(1.,-pltf_h,1.);\n                \n                // change to correct id\n                vec3 room_id=floor(pos*ir/box_v*.5); //xz is +-index, centered to 0 in building middle\n                float hx = hash13(iwt+3.133+(room_id)*1.3+vec3(vox_id.x,0.,vox_id.y));\n                float hx2 = hash13(iwt+.133+(room_id)*3.3+vec3(vox_id.x,0.,vox_id.y));\n                vec3 c1 = vec3(1.,0.7,0.3);\n                vec3 c2 = vec3(0.6,0.8,1.);\n                vec3 c = hx2>0.5?c1:c2;\n                emission = c*4.5*vec3(step(0.65,hx*hx*hx));\n            }\n        }\n    }\n}\n\n\nvoid material_OBJ_BOX_build_floor(vec3 pos, vec3 norm, out vec3 albedo, out vec3 emission, \n                        out float roughness, out float metalness){\n    albedo = vec3(1.);\n    emission = vec3(0.);\n    roughness = 0.31;\n    metalness = 0.317;\n    if(abs(norm.y)<0.5){\n        albedo = vec3(0.135);\n        roughness=0.41;\n        metalness=0.417;\n    }\n}\n\nvoid material_OBJ_BOX_room_b_floor(vec3 pos, vec3 norm, out vec3 albedo, out vec3 emission, \n                        out float roughness, out float metalness){\n    albedo = vec3(1.);\n    emission = vec3(0.);\n    roughness = 0.231;\n    metalness = 0.321;\n}\n\nvoid material_OBJ_BOX_floor_emi(vec3 pos, vec3 norm, out vec3 albedo, out vec3 emission, \n                        out float roughness, out float metalness){\n    albedo = vec3(1.);\n    emission = vec3(3.5,1.5,1.05);\n    roughness = 0.31;\n    metalness = 0.5021;\n}\n\n\nvec3 get_normal_OBJ_SPHERE(vec3 pos){\n    if(length(pos)<0.0001)return vec3(0.,0.,1.);\n    return normalize(pos);\n}\n\nvec3 boxNormal(vec3 pos,vec3 p0,vec3 p1, vec3 bsize);\nvec3 get_normal_OBJ_BOX(vec3 pos, vec3 opos, vec3 box){\n    vec3 p = box*0.5+opos;\n    vec3 q = -box*0.5+opos;\n    vec3 tnorm = boxNormal(pos, p, q, box);\n    // bug on reflected light, test normal length is 1.41421\n    //if(length(tnorm)>1.1)return normalize(tnorm); //return vec3(1.) to test (youl see white dots on edges)\n    // this why normalize\n    return normalize(tnorm);\n}\n\nvec3 get_normal_OBJ_room(vec3 pos, vec3 opos, vec3 box, vec3 rooms){\n    box = (box*2./rooms);\n    vec3 tpos = fract((pos-opos)/(box));\n    vec3 p = vec3(0.5);\n    vec3 q = -vec3(0.5);\n    vec3 tnorm = -boxNormal((tpos-0.5)*1., p, q, vec3(1.));\n    // bug on reflected light, test normal length is 1.41421\n    //if(length(tnorm)>1.1)return normalize(tnorm); //return vec3(1.) to test (youl see white dots on edges)\n    // this why normalize\n    return normalize(tnorm);\n}\n\nvec3 get_normal_OBJ_FLOOR(vec3 pos){\n    return vec3(0.,1.,0.);\n}\n\n// ---------------\n\n\n\n// sky\n//----------------------------------------------\n\nconst float sunAngularDiameter = 2.5;\n\nfloat sunIluminance = 1.5;\n\nconst float goldenAngle = 2.3999632297286533;\n\n// sky from https://www.shadertoy.com/view/3dlSW7\n\nfloat hGPhase(float cosTheta, const float g){\n\tfloat g2 = g * g;\n    \n    return 0.25 * (1.0 - g2) * pow(g2 - 2.0 * g * cosTheta + 1.0, -1.5);\n}\n\nvec3 calculateSunColor(float sunZenith){\n\treturn mix(vec3(1.0, 0.4, 0.05), vec3(1.0), max(sunZenith, 0.0));\n}\n\nfloat calculateSun(float lDotV){\n    const float cosRad = cos(radians(sunAngularDiameter));\n    float sunLuminance = sunIluminance / ((1.0 - cosRad) * TAU);\n    \n    return smoothstep(cosRad,cosRad*1.001, lDotV) * sunLuminance;\n}\n\nvec3 calculateSky(vec3 background, float lDotU, float lDotV){\n    float phaseMie = hGPhase(lDotV, 0.8);\n    \n    float zenith = max(lDotU, 0.0);\n    \n    float sunZenith = lightDir.y;\n    const vec3 topCol = vec3(0.1, 0.34, 1.0);\n    const vec3 bottomCol = vec3(1.0);\n    \n    vec3 sky = mix(topCol, (bottomCol + topCol), exp2(-zenith * 8.0));\n         sky += phaseMie * exp2(-zenith * 6.0);\n    \n    vec3 absorbColor = calculateSunColor(1.0 - exp2(-zenith * 2.0));\n    \n    sky = sky * mix(absorbColor * 0.9 + 0.1, vec3(1.0), sunZenith);\n\treturn background * absorbColor + sky * sunIluminance * (1.0 - clamp(-sunZenith * 10.0, 0.0, 1.0));\t\n}\n\nvec3 get_sky_color(vec3 rd){\n    float lDotU = dot(rd, upVec);\n\tfloat lDotV = dot(rd, lightDir);\n    vec3 col = vec3(0.0);\n    col += calculateSun(lDotV)*calculateSunColor(lightDir.y);\n    col = calculateSky(col, lDotU, lDotV);\n    return col;\n}\n\n//----------------------------------------------\n\n\n// pathtracing functions\n//----------------------------------------------\n\n// with ConeVector better visual result\n// ConeVector distribution, look this screenshots\n// https://danilw.github.io/GLSL-howto/vulkan_sh_launcher/upl_demos/pathtracer/ray_distr1.jpg\n// https://danilw.github.io/GLSL-howto/vulkan_sh_launcher/upl_demos/pathtracer/ray_distr2.png\n#ifdef use_ConeVector\n\nmat3 calculateTangentMatrix(vec3 direction){\n\tvec3 c1 = cross(direction, vec3(0.0, 0.0, 1.0));\n\tvec3 c2 = cross(direction, vec3(0.0, 1.0, 0.0));\n    \n    vec3 tangent = dot(c1, c1) > dot(c2, c2) ? c1 : c2;\n    vec3 biDir = cross(direction, tangent);\n    \n    return mat3(tangent, biDir, direction);\n}\n\nvec3 calculateConeVector(const float i, const float angularRadius, const int steps) {\n    float x = i * 2.0 - 1.0;\n    float y = i * float(steps) * 16.0 * 16.0 * goldenAngle;\n    \n    float angle = acos(x) * radians(angularRadius) * 1./PI;\n    float c = cos(angle);\n    float s = sin(angle);\n\n    return vec3(cos(y) * s, sin(y) * s, c);\n}\n\nvec3 calculateRoughSpecular(const float i, const int steps, float roughness) {\n    float r = roughness * roughness * roughness * roughness;\n    float x = (r * i) / max(1.0 - i,0.0001);\n    float y = i * float(steps) * 16.0 * 16.0 * goldenAngle;\n    //if(1.0 - i<0.)\n    //x = (r * i)*1000.;\n    float c = inversesqrt(x + 1.0);\n    float s = sqrt(x) * c;\n\n    return vec3(cos(y) * s, sin(y) * s, c);\n}\n\n#else\n\n// CosineWeightedSample\n\nfloat seed;\nfloat hash11_seed()\n{\n    float p=seed;\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    seed+=1.33;\n    return fract(p);\n}\n\nvec3 ortho(vec3 v) {\n  return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)  : vec3(0.0, -v.z, v.y);\n}\n\nvec3 getCosineWeightedSample(vec3 dir, float radius) {\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = vec2(hash11_seed(), hash11_seed());\n\tr.x = r.x * 2.0 * PI;\n\tr.y = pow(r.y, radius);\n\tfloat oneminus = sqrt(abs(1.0-r.y*r.y));\n\treturn cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir;\n}\n\n\n#endif\n//----------------------------------------------\n\n\n// Camera related (just to have less code in buffers)\n// ---------------\nconst ivec2 MEMORY_BOUNDARY = ivec2(2, 17); //BufA reserved (and top right pixel)\n\nconst ivec2 RES_LAST0 = ivec2(0, 0);\nconst ivec2 RES_LAST1 = ivec2(0, 1);\nconst ivec2 INIT0 = ivec2(0, 2);\nconst ivec2 TARGET0 = ivec2(0, 3);\nconst ivec2 TARGET1 = ivec2(0, 4);\nconst ivec2 TARGET2 = ivec2(0, 5);\n\nconst ivec2 POSITION0 = ivec2(0, 6);\nconst ivec2 POSITION1 = ivec2(0, 7);\nconst ivec2 POSITION2 = ivec2(0, 8);\nconst ivec2 POSITION_last0 = ivec2(0, 9);\nconst ivec2 POSITION_last1 = ivec2(0, 10);\nconst ivec2 POSITION_last2 = ivec2(0, 11);\n\nconst ivec2 VMOUSE0 = ivec2(1, 0);\nconst ivec2 VMOUSE1 = ivec2(1, 1);\nconst ivec2 VMOUSE2 = ivec2(1, 2);\nconst ivec2 VMOUSE_last0 = ivec2(1, 3);\nconst ivec2 VMOUSE_last1 = ivec2(1, 4);\n\nconst ivec2 INPUT0 = ivec2(1, 5);\nconst ivec2 HALTON0 = ivec2(1, 6);\nconst ivec2 HALTON1 = ivec2(1, 7);\nconst ivec2 HALTON_last0 = ivec2(1, 8);\nconst ivec2 HALTON_last1 = ivec2(1, 9);\nconst ivec2 PMOUSE0 = ivec2(1, 10);\nconst ivec2 PMOUSE1 = ivec2(1, 11);\n\nconst ivec2 hide_ui = ivec2(0, 12);\nconst ivec2 refl_ui = ivec2(0, 13);\nconst ivec2 lght_ui = ivec2(1, 12);\nconst ivec2 rlght_ui = ivec2(1, 13);\nconst ivec2 rlght_lwt = ivec2(1, 14);\nconst ivec2 spos_ui = ivec2(0, 14);\nconst ivec2 color_ui = ivec2(1, 15);\nconst ivec2 voxbox_ui = ivec2(0, 15);\nconst ivec2 sun_pow_ui = ivec2(0, 16);\n\nfloat load(ivec2 P, sampler2D self){return texelFetch(self, ivec2(P), 0).a;}\n\n// Camera\nmat3 rotationMatrix(vec2 m){\n  mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n  mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n  return rotY*rotX;\n}\nvoid SetCamera(vec2 uv, sampler2D caminfo, out vec3 ro, out vec3 rd, vec2 ires)\n{\n    ro = vec3(load(POSITION0,caminfo),load(POSITION1,caminfo),load(POSITION2,caminfo));\n    vec2 m = vec2(load(VMOUSE0,caminfo),load(VMOUSE1,caminfo));\n    m.y = -m.y;\n    float fov=camera_fov;\n    float aspect = ires.x / ires.y;\n    float screenSize = (1.0 / (tan(((180.-fov)* (3.1415926 / 180.0)) / 2.0)));\n    rd = vec3(uv*screenSize, 1./aspect);\n    \n    rd = normalize(rd);\n    rd = rotationMatrix(m) * rd;\n}\n\n// ---------------\n\n\n// reprojection\n//----------------------------------------------\n\nvec2 pos2uv(vec3 pos, sampler2D caminfo, vec2 ires){\n    vec3 ro_old = vec3(load(POSITION_last0,caminfo),load(POSITION_last1,caminfo),load(POSITION_last2,caminfo));\n    vec2 m_old = vec2(load(VMOUSE_last0,caminfo),load(VMOUSE_last1,caminfo))*vec2(1.,-1.);\n    vec3 td = pos - ro_old;\n    if(length(td)<0.0001)return vec2(-1.);\n    vec3 dir = normalize(td) * (rotationMatrix(m_old));\n    float fov=camera_fov;\n    float aspect = ires.x / ires.y;\n    float screenSize = (1.0 / (tan(((180.-fov)* (3.1415926 / 180.0)) / 2.0)));\n    dir.z+=0.0001*(1.-abs(sign(dir.z)));\n    return dir.xy * (.5/screenSize) / dir.z ;\n}\n\nfloat distancePixel( vec2 prevFragCoord, vec3 pos, sampler2D samplerx, vec2 ires){\n    if(  min(ires.xy, prevFragCoord) != prevFragCoord\n      && max(vec2(0.)      , prevFragCoord) != prevFragCoord) return MAX_DIST;\n    \n    vec3 prevPos = textureLod(samplerx, prevFragCoord/ires.xy,0.).xyz;\n    return length(prevPos-pos);\n}\n\n#define PixelAcceptance 2.\n#define PixelCheckDistance .75\nvec4 previousSample(vec3 ro, vec3 pos, sampler2D caminfo, sampler2D last_pos_fbo, sampler2D last_color, vec2 ires){\n    vec2 old_halton_px_shift=vec2(load(HALTON_last0,caminfo),load(HALTON_last1,caminfo));\n    vec2 prevUv = pos2uv(pos, caminfo, ires)-old_halton_px_shift/ires.y;\n    vec2 prevFragCoord = prevUv * ires.y + ires.xy/2.0;\n    \n    vec2 pfc=vec2(0.);\n    vec2 finalpfc=vec2(0.);\n    float dist, finaldist = MAX_DIST;\n    for(int x = -1; x <= 1; x++){\n        for(int y = -1; y <= 1; y++){\n            pfc = prevFragCoord + PixelCheckDistance*vec2(x, y);\n            dist = distancePixel(pfc, pos, last_pos_fbo, ires);\n            if(dist < finaldist){\n                finalpfc = pfc;\n                finaldist = dist;\n            }\n      }\n    }\n    \n    float aspect = ires.x / ires.y;\n    float fov=camera_fov;\n    float screenSize = (1.0 / (tan(((180.-fov)* (3.1415926 / 180.0)) / 2.0)));\n    if(finaldist < PixelAcceptance*(length(pos-ro)/(aspect*screenSize)/ires.y))\n        return textureLod(last_color, finalpfc/ires.xy,0.);\n    return vec4(0.);\n}\n\n//----------------------------------------------\n\n\n\n\n\n\n// intersection template\n//----------------------------------------------\n\nstruct HitInfo {\n    float t;\n    vec3 norm;\n    vec4 color;\n    vec3 emisson;\n    float rough;\n    float metal;\n    int obj_type;\n};\n\n\nbool boxAABB(in vec3 dims, vec3 ro, vec3 rd) {\n    rd += 0.0001 * (1.0 - abs(sign(rd)));\n    vec3 n = ro / rd;\n    vec3 k = dims / abs(rd);\n    vec3 t1 = -k - n, t2 = k - n;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    return tN < tF && tF > 0.0;\n}\n\nbool PlaneIntersect(vec4 Plane, vec3 ro, vec3 rd, out float t, out vec3 norm) {\n    norm=vec3(0.,1.,0.);\n    t=-1.;\n    float dd = dot(rd, Plane.xyz);\n    if (dd == 0.0) return false;\n    float t1 = -(dot(ro, Plane.xyz) + Plane.w) / dd;\n    if (t1 < 0.0) return false;\n    norm = normalize(Plane.xyz);\n    t = t1;\n    return true;\n}\n\nvec2 Box_hit(vec3 ro,vec3 rd,vec3 p0,vec3 p1)\n{\n    //rd+=0.0001*(1.-abs(sign(rd))); //rd can be 0. when camera look horizontal or vertical\n    vec3 t0 = (mix(p1, p0, step(0., rd * sign(p1 - p0))) - ro) / rd;\n    vec3 t1 = (mix(p0, p1, step(0., rd * sign(p1 - p0))) - ro) / rd;\n    return vec2(max(t0.x, max(t0.y, t0.z)),min(t1.x, min(t1.y, t1.z)));\n}\n\nvec3 boxNormal(vec3 pos,vec3 p0,vec3 p1, vec3 bsize)\n{\n    pos = pos - (p0 + p1) / 2.;\n    vec3 arp = abs(pos) / bsize;\n    return step(arp.yzx, arp) * step(arp.zxy, arp) * sign(pos);\n}\n\n// box intersection, inverted faces\nbool BoxIntersect_min_inv( in vec3 ro, in vec3 rd, vec3 opos, vec3 size, out float tN, out vec3 norm){\n    vec3 p = size*0.5+opos;\n    vec3 q = -size*0.5+opos;\n    vec2 b = Box_hit(ro, rd, p, q);\n    tN=MIN_DIST;\n    norm=vec3(0.,1.,0.);\n\n    if(b.y > MIN_DIST && b.x < b.y && b.y < MAX_DIST)\n    {\n        tN = b.y;\n        vec3 pos = ro + rd * tN;\n        norm = -boxNormal(pos, p, q, size);\n        return true;\n    }\n    return false;\n}\n\n// box intersection\nbool BoxIntersect_min( in vec3 ro, in vec3 rd, vec3 opos, vec3 size, out float tN, out vec3 norm){\n    vec3 p = size*0.5+opos;\n    vec3 q = -size*0.5+opos;\n    vec2 b = Box_hit(ro, rd, p, q);\n    tN=MIN_DIST;\n    norm=vec3(0.,1.,0.);\n\n    if(b.x > MIN_DIST && b.x < b.y && b.x < MAX_DIST)\n    {\n        tN = b.x;\n        vec3 pos = ro + rd * tN;\n        norm = boxNormal(pos, p, q, size);\n        return true;\n    }\n    return false;\n}\n\nvoid BoxIntersectMin_minimal_inv(vec3 ro, vec3 rd, vec3 box, vec3 opos, inout bool result, inout HitInfo hit, int obj_id) {\n    float tnew;\n    vec3 normnew;\n    //bool inbox = false;\n    //inbox=(abs(ro-opos).x<box.x*0.5&&abs(ro-opos).y<box.y*0.5&&abs(ro-opos).z<box.z*0.5);\n    \n    if (BoxIntersect_min_inv(ro, rd, opos, box, tnew, normnew)) {\n        if (tnew < hit.t) {\n            hit.t = tnew;\n            hit.norm = normnew;\n            \n            hit.color = vec4(normnew,1.);\n            hit.obj_type = obj_id;\n            result = true;\n        }\n    }\n}\n\nvoid BoxIntersectMin_minimal_nins(vec3 ro, vec3 rd, vec3 box, vec3 opos, inout bool result, inout HitInfo hit, int obj_id) {\n    float tnew;\n    vec3 normnew;\n    //bool inbox = false;\n    //inbox=(abs(ro-opos).x<box.x*0.5&&abs(ro-opos).y<box.y*0.5&&abs(ro-opos).z<box.z*0.5);\n    \n    if (BoxIntersect_min(ro, rd, opos, box, tnew, normnew)) {\n        if (tnew < hit.t) {\n            hit.t = tnew;\n            hit.norm = normnew;\n            \n            vec3 albedo;\n            material_OBJ_BOX(ro+rd*hit.t, hit.norm,  albedo, hit.emisson, hit.rough, hit.metal);\n            if(obj_id==OBJ_BOX_floor_emi)material_OBJ_BOX_floor_emi(ro+rd*hit.t, hit.norm,  albedo, hit.emisson, hit.rough, hit.metal);\n            hit.color = vec4(albedo,1.);\n            hit.obj_type = obj_id;\n            result = true;\n        }\n    }\n}\n\nvoid BoxIntersectMin_minimal(vec3 ro, vec3 rd, vec3 box, vec3 opos, inout bool result, inout HitInfo hit, int obj_id) {\n\n    float tnew;\n    vec3 normnew;\n    bool inbox = false;\n    inbox=(abs(ro-opos).x<box.x*0.5&&abs(ro-opos).y<box.y*0.5&&abs(ro-opos).z<box.z*0.5);\n    bool intr;\n    if(inbox)intr=BoxIntersect_min_inv(ro, rd, opos, box, tnew, normnew);\n    else intr=BoxIntersect_min(ro, rd, opos, box, tnew, normnew);\n    if (intr) {\n        if (tnew < hit.t) {\n            hit.t = tnew;\n            hit.norm = normnew;\n            hit.color = vec4(normnew,1.);\n            hit.obj_type = obj_id;\n            result = true;\n        }\n    }\n}\n\n// window border\nfloat wborder_uv(vec2 p,vec2 s){\n    float d = 0.;\n    d = 1.-step(s.x,abs(p.x));\n    d = d*(1.-step(s.y,abs(p.y)));\n    return d;\n}\n\nfloat wuv(vec2 p, vec2 rooms,vec2 s){\n    return wborder_uv(fract(p*rooms)-0.5,s);\n}\n\n#define NOT_box_building\n// render when look inside and outside room\nvec3 render_room_light(vec3 pos, vec3 size, vec2 tlrb, vec3 norm, vec3 innorm, bool inbox, vec3 interior_rooms, vec2 s)\n{\n    pos = pos / (size*2./interior_rooms);\n    pos=fract(pos);\n    vec3 ligPos = vec3(0.5,.972,0.25);\n    float intensity = 0.5/dot(ligPos-pos,ligPos-pos);\n#ifndef NOT_box_building\n    if (innorm.y>.5)\n    {\n        vec2 uv = fract(vec2(pos.x,-pos.z));\n        if(!inbox){\n            if(tlrb.x<.5&&abs(norm.y)<0.5)return 0.01*vec3(1.-2.*wborder_uv(uv-0.5,s));\n        }else{\n            if(norm.y<-0.5)tlrb.x=0.;\n            if(tlrb.x<.5&&norm.y<0.5)return 0.01*vec3(1.-2.*wborder_uv(uv-0.5,s));\n        }\n    }else if (innorm.y<-.5)\n    {\n        vec2 uv = fract(pos.xz);\n        if(!inbox){\n            if(tlrb.x>interior_rooms.y-1.5&&abs(norm.y)<0.5)return 0.01*vec3(1.-2.*wborder_uv(uv-0.5,s));\n        }else{\n            if(norm.y>0.5)tlrb.x=interior_rooms.y-1.;\n            if(tlrb.x>interior_rooms.y-1.5&&norm.y>-0.5)return 0.01*vec3(1.-2.*wborder_uv(uv-0.5,s));\n        }\n    }else \n#endif\n    if (innorm.x>.5)\n    {\n        vec2 uv = fract(vec2(-pos.z,pos.y));\n        if(!inbox){\n            if(tlrb.y>interior_rooms.x-1.5&&abs(norm.x)<0.5)return 0.01*vec3(1.-2.*wborder_uv(uv-0.5,s));\n        }else{\n            if(norm.x<-0.5)tlrb.y=interior_rooms.x-1.;\n            if(tlrb.y>interior_rooms.x-1.5&&norm.x<0.5)return 0.01*vec3(1.-2.*wborder_uv(uv-0.5,s));\n        }\n    }else if (innorm.x<-.5)\n    {\n        vec2 uv = fract(pos.zy);\n        if(!inbox){\n            if(tlrb.y<.5&&abs(norm.x)<0.5)return 0.01*vec3(1.-2.*wborder_uv(uv-0.5,s));\n        }else{\n            if(norm.x>0.5)tlrb.y=0.;\n            if(tlrb.y<.5&&norm.x>-0.5)return 0.01*vec3(1.-2.*wborder_uv(uv-0.5,s));\n        }\n    }else if (innorm.z>.5)\n    {\n        vec2 uv = fract(pos.xy);\n        if(abs(norm.y)>0.5)tlrb.y=tlrb.x;\n        if(!inbox){\n            if(tlrb.y>interior_rooms.z-1.5&&abs(norm.z)<0.5)return 0.01*vec3(1.-2.*wborder_uv(uv-0.5,s));\n        }else{\n            if(norm.z<-0.5)tlrb.y=interior_rooms.z-1.;\n            if(tlrb.y>interior_rooms.z-1.5&&norm.z<0.5)return 0.01*vec3(1.-2.*wborder_uv(uv-0.5,s));\n        }\n    }else if (innorm.z<-.5)\n    {\n        vec2 uv = fract(pos.xy);\n        if(abs(norm.y)>0.5)tlrb.y=tlrb.x;\n        if(!inbox){\n            if(tlrb.y<.5&&abs(norm.z)<0.5)return 0.01*vec3(1.-2.*wborder_uv(uv-0.5,s));\n        }else{\n            if(norm.z>0.5)tlrb.y=0.;\n            if(tlrb.y<.5&&norm.z>-0.5)return 0.01*vec3(1.-2.*wborder_uv(uv-0.5,s));\n        }\n    }  \n    //vec3 insideLight = clamp(dot(innorm, normalize(ligPos-pos)),0.,1.) * vec3(1.,0.5,0.1)*1.;\n    //return insideLight*intensity;\n    return vec3(1.);\n}\n\n// return vec3(window, vec2(room_id)) room_id.x 0 at bot 3 at top, y left right\nvec3 tex_Window_border(vec3 pos, vec3 nor, vec3 box, vec3 bbox, vec2 s)\n{\n    float tc= abs(nor.x)*wuv(0.5*1./box.yz*pos.yz,bbox.yz,s.yx) + \n                   abs(nor.y)*wuv(0.5*1./box.zx*pos.zx,bbox.zx,s.yx) + \n                   abs(nor.z)*wuv(0.5*1./box.xy*pos.xy,bbox.xy,s);\n    vec2 idx = abs(nor.x)*floor((0.5+0.5*1./box.yz*pos.yz*vec2(1.,-1.))*bbox.yz) +\n                   abs(nor.y)*floor((0.5+0.5*1./box.zx*pos.zx)*bbox.zx) + \n                   abs(nor.z)*floor((0.5+0.5*1./box.yx*pos.yx*vec2(1.,-1.))*bbox.yx);\n    return vec3(tc,mod(abs(idx),abs(nor.x)*vec2(bbox.yz)+abs(nor.y)*vec2(bbox.zx)+abs(nor.z)*vec2(bbox.yx)));\n}\n\nvoid interior_box(vec3 ro, float tbox, vec3 rd, vec3 box, vec3 norm, vec3 wb, inout bool result, inout HitInfo hit, bool inbox, vec3 interior_rooms, int room_idx, int build_idx, vec2 s){\n    vec3 size = box/(interior_rooms*2.);\n    vec3 tshift = box/(interior_rooms*interior_rooms/2.);\n    vec3 nd = (1.-abs(sign(norm)));\n    vec3 opos =vec3(norm*size*(interior_rooms-1.)*2.+vec3(nd*size*(interior_rooms-1.)*2.)*vec3(1.,-1.,1.));\n    if(abs(norm.x)>0.5){\n        opos += interior_rooms*vec3(0.,wb.y*tshift.y,-wb.z*tshift.z);\n    }else\n    if(abs(norm.z)>0.5){\n        opos += interior_rooms*vec3(-wb.z*tshift.x,wb.y*tshift.y,0.);\n    }else\n    if(abs(norm.y)>0.5){\n        opos += interior_rooms*vec3(wb.z*tshift.x-(interior_rooms.x-1.)*tshift.x,0.,wb.y*tshift.z-(interior_rooms.z-1.)*tshift.z);\n        wb.z=(interior_rooms.x-1.)-wb.z;wb.y=(interior_rooms.z-1.)-wb.y;\n    }\n#ifdef NOT_box_building\n    if((abs(norm.y)>0.5||wb.x<0.01)&&!inbox){\n#else\n    if(wb.x<0.01&&!inbox){\n#endif\n        hit.t = tbox;\n        hit.norm = norm;\n        hit.obj_type = build_idx;\n        result = true;\n        hit.color = vec4(vec3(1.),1.);\n        hit.emisson=vec3(0.);\n        hit.rough=0.31;\n        hit.metal=0.17;\n        return;\n    }\n    float tnew; vec3 normnew;\n#ifdef NOT_box_building\n    if ((abs(norm.y)<0.5||inbox)&&BoxIntersect_min_inv(ro, rd, opos, size*3.99, tnew, normnew)) {\n#else\n    if (BoxIntersect_min_inv(ro, rd, opos, size*3.99, tnew, normnew)) {\n#endif\n        if (tbox+tnew < hit.t) \n        {\n            vec3 color = render_room_light(ro+rd*tnew, box, wb.yz, norm, normnew, inbox, interior_rooms,s);\n            if(color.x<0.&&(wb.x>0.01||inbox))return;\n            color = vec3(1.);\n            hit.t = tbox+tnew-0.001;\n            hit.norm = normnew;\n            hit.obj_type = room_idx;\n            result = true;\n            hit.color = vec4(max(color,vec3(0.)),1.);\n            hit.emisson=vec3(0.);\n            hit.rough=0.31;\n            hit.metal=0.17;\n            if(build_idx==OBJ_BOX_room_b_floor){\n                vec3 col;\n                material_OBJ_BOX_room_b_floor((ro+rd*tnew)/(box*2./interior_rooms), normnew, col, hit.emisson, \n                        hit.rough, hit.metal);\n                hit.color = vec4(col,1.);\n            }\n        }\n    }else \n    if(!inbox)\n    {\n        hit.t = tbox;\n        hit.color = vec4(vec3(1.),1.);\n        hit.emisson=vec3(0.);\n        hit.rough=0.31;\n        hit.metal=0.17;\n        hit.norm = norm;\n        hit.obj_type = build_idx;\n        if(build_idx==OBJ_BOX_build_floor){\n            vec3 col;\n            material_OBJ_BOX_build_floor(ro+rd*tbox,norm, col, hit.emisson, \n                        hit.rough, hit.metal);\n            hit.color = vec4(col,1.);\n        }\n        result = true;\n    }\n}\n\n// interior_rooms x - rooms on side abs(norm.x), y rooms on heigh, z on side abs(norm.z)\nvoid BoxIntersectMin_interior(vec3 ro, vec3 rd, vec3 box, vec3 opos, vec3 interior_rooms, inout bool result, inout HitInfo hit, int room_idx, int build_idx, vec2 s) {\n    float tnew;\n    vec3 normnew;\n    bool inbox = false;\n    vec3 tbox=box+0.001; //fix box switch \n    inbox=(abs(ro-opos).x<tbox.x&&abs(ro-opos).y<tbox.y&&abs(ro-opos).z<tbox.z);\n    if(inbox)\n    {\n        vec3 p = vec3(0.5);\n        vec3 q = -vec3(0.5);\n        \n        // normal to camera inside of box\n        vec3 tpos = floor(((ro-opos)/(box*2.))*interior_rooms);\n        tpos+=step(vec3(0.),tpos); //remove 0 from index\n        tpos = tpos/interior_rooms;\n        normnew = boxNormal(tpos, p, q, vec3(1.));\n        bvec3 bv=bvec3(ivec3(abs(normnew))); \n        normnew*=bv.x?vec3(1.,0.,0.):bv.y?vec3(0.,1.,0.):bv.z?vec3(0.,0.,1.):vec3(1.);\n        \n        vec3 pos = ro+normnew*0.0001-opos;\n        vec3 wb = tex_Window_border(pos,normnew,box, interior_rooms,s);\n        interior_box(pos, MIN_DIST, rd, box, normnew, wb, result, hit, inbox, interior_rooms, room_idx, build_idx,s);\n    }\n    else\n    if(BoxIntersect_min(ro, rd, opos, box*2., tnew, normnew))\n    {\n        if (tnew < hit.t) {\n            vec3 pos = (ro+rd*tnew)+normnew*0.0001-opos;\n            vec3 wb = tex_Window_border(pos,normnew,box, interior_rooms,s);\n            interior_box(pos, tnew, rd, box, normnew, wb, result, hit, inbox, interior_rooms, room_idx, build_idx,s);\n            //hit.color = vec4(hit.color.rgb*wb.x,1.);\n        }\n    }\n}\n\n\n\n\n\n\n\n\n\n\nvoid GroundIntersectMin(vec3 ro, vec3 rd, inout bool result, inout HitInfo hit) {\n    float tnew;\n    vec3 normnew;\n    vec4 pp=vec4(0., 1., 0., 0.);\n    if (PlaneIntersect(pp, ro+vec3(0.,0.,0.), rd, tnew, normnew)) {\n        if (tnew < hit.t) {\n            hit.t = tnew;\n            hit.norm = normnew;\n            \n            hit.emisson = vec3(0.,0.,0.);\n            vec3 albedo;\n            material_OBJ_FLOOR(ro+rd*hit.t, hit.norm,  albedo, hit.emisson, hit.rough, hit.metal);\n            hit.color = vec4(albedo, 1.);\n            hit.obj_type = OBJ_FLOOR;\n            result = true;\n        }\n    }\n}\n\n\n// ffix float precision fix, fix reflections 0.0001 main, -0.0009 refl\nbool VoxelsIntersect(int steps, vec2 box, float max_h, float ffix, in vec3 ro, in vec3 rd, out vec3 normal , out float tnew, out vec2 vox_idx, out int obj_idx) {\n    steps=clamp(steps,0,10000);\n    vec2 pos = floor(ro.xz);\n    rd += 0.0001 * (1.0 - abs(sign(rd)));\n    vec3 rdi = 1./rd;\n\n    vec3 rda = abs(rdi);\n    vec3 rds = sign(rd);\n    vec2 dis = (pos - ro.xz + .5 + rds.xz*.5) * rdi.xz;\n    \n    vec3 roi = rdi*(ro-vec3(.5,0.,.5));\n    \n    \n    vec2 mm = vec2(0.0);\n    for( int i=0; i<steps; i++ ) {  \n        float tm=1.;\n        if (any(greaterThan(pos,box*2.))||any(lessThan(pos,vec2(1.))))tm=0.;\n        float voxh = max(get_heightField(pos,box),0.001)*max_h;\n        float tps = -0.00099+voxh*tm;\n        vec3 n = roi - rdi * vec3(pos.x, tps-1., pos.y);\n        \n        vec3 k = rda*vec3(.5, tps, .5);\n\n        vec3 t1 = -n - k;\n        vec3 t2 = -n + k;\n\n        float tN = max( max( t1.x, t1.y ), t1.z )-ffix;\n        float tF = min( min( t2.x, t2.y ), t2.z );\n\n        // comments is voxels\n        if ( tN < tF && tN<MAX_DIST) { // && tN>MIN_DIST && tN<MAX_DIST\n            //normal = -rds*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n            //tnew = tN;\n            \n            vec3 tnor;float ttn;\n            vec4 boxp = get_vox_size(pos,box);\n            //BoxIntersectMin_interior\n#ifdef voxel_box_only\n            if(BoxIntersect_min(ro, rd, vec3(boxp.x+0.5,-1.+voxh,boxp.y+0.5), vec3(boxp.z,voxh,boxp.w)*2., ttn, tnor)){\n                normal=tnor;\n                tnew=ttn;\n                vox_idx = pos;\n                obj_idx = OBJ_BOX;\n                return true;\n            }\n#else\n            if(ui_voxel_box_only){\n            // not optimized, lots of not needed data\n            HitInfo hit;\n            hit.t = MAX_DIST;\n            hit.obj_type = OBJ_SKY;\n            hit.norm = vec3(0.,1.,0.);\n            hit.color=vec4(0.);\n            hit.emisson = vec3(0.);\n            vec3 opos = vec3(boxp.x+0.5,-1.+voxh,boxp.y+0.5);\n            vec3 box_v = vec3(boxp.z,voxh,boxp.w);\n            vec3 interior_rooms=max(floor(box_v/0.1),vec3(2.,2.,2.));\n            interior_rooms+=2.*fract(interior_rooms/2.);\n            bool result = false;\n            vec2 s = vec2(0.448);\n            if(voxh/max_h<0.3)s = vec2(0.348);\n            BoxIntersectMin_interior(ro, rd,box_v,opos,interior_rooms,result, hit, OBJ_BOX_room, OBJ_BOX_build, s);\n            if(result){\n                normal=hit.norm;\n                tnew=hit.t;\n                vox_idx = pos;\n                obj_idx = hit.obj_type;\n                return true;\n            }\n            }else{\n                if(BoxIntersect_min(ro, rd, vec3(boxp.x+0.5,-1.+voxh,boxp.y+0.5), vec3(boxp.z,voxh,boxp.w)*2., ttn, tnor)){\n                    normal=tnor;\n                    tnew=ttn;\n                    vox_idx = pos;\n                    obj_idx = OBJ_BOX;\n                    return true;\n                }\n            }\n#endif\n        }\n\n        mm = step( dis.xy, dis.yx ); \n        dis += mm*rda.xz;\n        pos += mm*rds.xz;\n    }\n\n    return false;\n}\n\nvoid VoxelsIntersectMin(vec2 box, float max_h , vec3 posl, vec3 ro, vec3 rd, inout bool result, inout HitInfo hit, int voxel_draw_dist) {\n    \n    float tnew;\n    vec2 vox_idx; // idx starts from 1\n    int obj_idx;\n    vec3 normnew;\n    posl.xz+=1.;\n    ro+=posl;\n    if(!boxAABB(vec3(box.x,max_h,box.y), ro+vec3(-1.,-max_h+1.,-1.), rd))return;\n    ro.xz+=box;\n    float vros = length(ro.xz-(box+1.));\n    if(VoxelsIntersect(min(int(vros*1.5)+int(max(voxels_num.x,voxels_num.y)*2.+5.),voxel_draw_dist), box, max_h, 0.0001, ro, rd, normnew, tnew, vox_idx, obj_idx)){\n        bool in_box=(vox_idx.x<=box.x*2.)&&(vox_idx.y<=box.y*2.);\n        in_box=in_box&&all(greaterThan(vox_idx,vec2(0.)));\n        if (in_box&&(tnew < hit.t)) {\n            int vox_id = int(vox_idx.x)+int(vox_idx.y-1.)*int((voxels_num.x+0.5)*2.);\n            vox_id=vox_id*1000+obj_idx;\n            \n            vec3 albedo;\n            vec2 box = voxels_num+0.5;\n            float max_h=voxel_h;\n            float voxh = max(get_heightField(vox_idx+1.,box),0.001)*max_h;\n            material_OBJ_BOX_in_voxel((ro+rd*tnew)-vec3(box.x+1.,-pltf_h-1.,box.y+1.), vox_id, normnew,  albedo, hit.emisson, hit.rough, hit.metal);\n            hit.color = vec4(albedo, 1.);\n            \n            hit.obj_type = vox_id;\n            result = true;\n            hit.t = tnew;\n            hit.norm = normnew;\n        }\n    }\n}\n\n\n//----------------------------------------------\n\n\n\n// render NOT OPTIMIZED\n// can be optimized by separating normal/albedo calculation and hit(bool)\n// by making two functions, one used by shadows other by pathtracing\n// look get_scene_ \n//----------------------------------------------\n\nbool minDist(vec3 ro, vec3 rd, out HitInfo hit, int vox_draw_dist)\n{\n    hit.t = MAX_DIST;\n    hit.obj_type = OBJ_SKY;\n    hit.norm = vec3(0.,1.,0.);\n    \n    hit.color=vec4(get_sky_color(rd),1.);\n    hit.emisson = vec3(0.,0.,0.);\n    bool result = false;\n\n\n    GroundIntersectMin(ro, rd, result, hit);\n#if defined(box_floor)||defined(NO_COMPILE)\n    BoxIntersectMin_minimal_nins(ro, rd,vec3(voxels_num.x+0.5,pltf_h,voxels_num.y+0.5)*2.,bpos, result, hit, OBJ_BOX);\n#else\n    BoxIntersectMin_interior(ro, rd,vec3(voxels_num.x+0.5,pltf_h,voxels_num.y+0.5),bpos,floor_rooms,result, hit, OBJ_BOX_room_b_floor, OBJ_BOX_build_floor, floor_border);\n    //BoxIntersectMin_minimal_nins(ro, rd,vec3(voxels_num.x+0.5,pltf_h,voxels_num.y+0.5)*vec3(0.35,1.99,0.35),bpos, result, hit, OBJ_BOX_floor_emi);\n#endif\n\n#ifndef NO_COMPILE\n    VoxelsIntersectMin(voxels_num+0.5, voxel_h, vec3(0.,-pltf_h-1.,0.)-bpos, ro, rd, result, hit, vox_draw_dist);\n#else\n    // can not even display this with ANGLE on\n    //BoxIntersectMin_interior(ro, rd,0.35*vec3(voxels_num.x+0.5,15.,voxels_num.y+0.5),bpos+vec3(0.,6.35,0.),box_ncomp_rooms,result, hit, OBJ_BOX_room_b_ncomp, OBJ_BOX_build_ncomp, vec2(0.4));\n#endif\n    return result;\n}\n\nvoid get_scene_material(bool d, vec3 ro, vec3 rd, vec3 pos, vec3 norm, int obj_id, out vec3 albedo, out vec3 emission, \n                        out float roughness, out float metalness){\n    albedo=vec3(0.0);\n    emission=vec3(0.0);\n    roughness=0.0001;\n    metalness=0.0001;\n    // pos+= objpos todo\n    if(d){\n        if(obj_id==OBJ_FLOOR){\n            material_OBJ_FLOOR(pos, norm, albedo, emission, roughness, metalness);\n            albedo=get_sky_color(rd);\n        }\n        else if(obj_id==OBJ_BOX)\n            material_OBJ_BOX(pos+bpos, norm, albedo, emission, roughness, metalness);\n        else if(obj_id==OBJ_BOX_floor_emi)\n            material_OBJ_BOX_floor_emi(pos+bpos, norm, albedo, emission, roughness, metalness);\n        else if(obj_id==OBJ_BOX_build_floor)\n            material_OBJ_BOX_build_floor(pos+bpos,norm, albedo, emission, roughness, metalness);\n        else if(obj_id==OBJ_BOX_room_b_floor){\n            vec3 st =(vec3(voxels_num.x+0.5,pltf_h,voxels_num.y+0.5)*2./floor_rooms);\n            material_OBJ_BOX_room_b_floor(fract((pos-bpos)/st), norm, albedo, emission, roughness, metalness);\n        }\n        else if(obj_id/1000>=1)\n            material_OBJ_BOX_in_voxel(pos-bpos, obj_id, norm, albedo, emission, roughness, metalness);\n        else if(obj_id==OBJ_BOX_build_ncomp||obj_id==OBJ_BOX_room_b_ncomp)\n            material_OBJ_BOX(pos, norm, albedo, emission, roughness, metalness);\n    }\n}\n\n//----------------------------------------------\n\n\n// noise https://www.shadertoy.com/view/7sGBzW\n// hash https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n    p=floor(p*1000.)/1000.;\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n    p3=floor(p3*1000.)/1000.;\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash21(float p)\n{\n    p=floor(p*1000.)/1000.;\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash22(vec2 p)\n{\n    p=floor(p*1000.)/1000.;\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash32(vec2 p)\n{\n    p=floor(p*1000.)/1000.;\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hash33(vec3 p3)\n{\n    p3=floor(p3*1000.)/1000.;\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n\n// saved in BufA as alpha\nfloat Bnoise(vec2 U) {\n    float v = 0.;\n    for (int k=0; k<9; k++)\n        v += hash12( U + vec2(k%3-1,k/3-1) ); \n    v=.9 *( 1.125*hash12(U)- v/8.) + .5;\n    //return clamp(v,0.,1.);\n    //return fract(abs(v));\n    return v < 0. ? -v : v > 1. ? 2.-v : v ;\n}\n\n// halton low discrepancy sequence, from https://www.shadertoy.com/view/wdXSW8\nvoid halton_loop(inout vec2 s, inout vec4 a){\n    const vec2 coprimes = vec2(2.0f, 3.0f);\n    a.xy = a.xy/coprimes;\n    a.zw += a.xy*mod(s, coprimes);\n    s = floor(s/coprimes);\n}\nvec2 halton (int index){\n    vec2 s = vec2(index, index);\n\tvec4 a = vec4(1,1,0,0);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    return a.zw;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// this exist just because Shadertoy has only 4 buffers\n\n// rgb is last_pos\n\n// camera control use 1 alpha pixel per value\n\n// also in alpha saved noise\n// noie everywhere except MEMORY_BOUNDARY and top right pixel\n\n\n\n#define keyboard_texture iChannel3\n\nconst vec3 start_pos = vec3(4.+voxels_num.x, 6.0+pltf_h*2., -4.0-voxels_num.y); //vec3(12.0, 9.0, -11.0);\nconst vec2 start_mouse = vec2(-.7, -0.35); //vec2(-.88,-0.55);\n\nconst float speed = 1.75;\n\n\nvoid store(ivec2 P, ivec2 ipx, float V, inout vec4 fc){ if(ipx==P) fc.a = V;}\n\nfloat key(int K, sampler2D kb){return step(0.5, texelFetch(kb, ivec2(K, 0), 0).x);}\n\n\n\nconst int Key_Backspace = 8, Key_Tab = 9, Key_Enter = 13, Key_Shift = 16, Key_Ctrl = 17, \nKey_Alt = 18, Key_Pause = 19, Key_Caps = 20, Key_Escape = 27, Key_Space = 32, \nKey_PageUp = 33, Key_PageDown = 34, Key_End = 35,Key_Home = 36, Key_LeftArrow = 37, \nKey_UpArrow = 38, Key_RightArrow = 39, Key_DownArrow = 40, Key_Insert = 45, \nKey_Delete = 46, Key_0 = 48, Key_1 = 49, Key_2 = 50, Key_3 = 51, Key_4 = 52,\nKey_5 = 53, Key_6 = 54, Key_7 = 55, Key_8 = 56, Key_9 = 57, Key_A = 65, Key_B = 66, \nKey_C = 67, Key_D = 68, Key_E = 69, Key_F = 70, Key_G = 71, Key_H = 72,Key_I = 73, \nKey_J = 74, Key_K = 75, Key_L = 76, Key_M = 77, Key_N = 78, Key_O = 79, Key_P = 80,\nKey_Q = 81, Key_R = 82, Key_S = 83, Key_T = 84, Key_U = 85,Key_V = 86, Key_W = 87, \nKey_X = 88, Key_Y = 89, Key_Z = 90, Key_LeftWindow = 91, Key_RightWindows = 92, \nKey_Select = 93, Key_Numpad0 = 96, Key_Numpad1 = 97, Key_Numpad2 = 98, Key_Numpad3 = 99,\nKey_Numpad4 = 100, Key_Numpad5 = 101, Key_Numpad6 = 102, Key_Numpad7 = 103, \nKey_Numpad8 = 104, Key_Numpad9 = 105, Key_NumpadMultiply = 106, Key_NumpadAdd = 107,\nKey_NumpadSubtract = 109, Key_NumpadPeriod = 110, Key_NumpadDivide = 111, Key_F1 = 112,\nKey_F2 = 113, Key_F3 = 114, Key_F4 = 115, Key_F5 = 116, Key_F6 = 117, Key_F7 = 118,\nKey_F8 = 119, Key_F9 = 120, Key_F10 = 121, Key_F11 = 122, Key_F12 = 123, \nKey_NumLock = 144, Key_ScrollLock = 145,Key_SemiColon = 186, Key_Equal = 187, \nKey_Comma = 188, Key_Dash = 189, Key_Period = 190, Key_ForwardSlash = 191, \nKey_GraveAccent = 192, Key_OpenBracket = 219, Key_BackSlash = 220, \nKey_CloseBraket = 221, Key_SingleQuote = 222;\n\n\n\nvec2 KeyboardInput(sampler2D kb) {\n    ivec4 inputs1 = ivec4(Key_UpArrow, Key_DownArrow, Key_RightArrow, Key_LeftArrow); //ARROWS\n    ivec4 inputs2 = ivec4(Key_W, Key_S, Key_D, Key_A);//WASD\n    //ivec4 inputs2 = ivec4(Key_E, Key_D, Key_F, Key_S);//ESDF\n    \n\tvec2 i = vec2(max(key(inputs1.z,kb),key(inputs2.z,kb))   - max(key(inputs1.w,kb),key(inputs2.w,kb)), \n                  max(key(inputs1.x,kb),key(inputs2.x,kb)) - max(key(inputs1.y,kb),key(inputs2.y,kb)));\n    \n    float n = abs(abs(i.x) - abs(i.y));\n    return i * (n + (1.0 - n)*0.707106);\n}\n\nvec3 CameraDirInput(vec2 vm, sampler2D kb) {\n    vec2 m = vm;\n    m.y = -m.y;\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    return (rotY * rotX) * vec3(KeyboardInput(kb), 0.0).xzy;\n}\n\n\nvoid Collision_floor(vec3 prev, inout vec3 p) {\n    if (p.y < 1.0) p = vec3(prev.xz, max(1.0, prev.y)).xzy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    ivec2 ipx = ivec2(fragCoord);\n    fragColor.rgb = texelFetch(iChannel1,ipx,0).rgb;\n    fragColor.a = texelFetch(iChannel0,ipx,0).a;\n    \n    if(ipx==ivec2(iResolution.xy)-1){\n        fragColor.a=2.; // resolution control for pause case\n        return;\n    }\n    \n    \n    vec2 res_l = vec2(load(RES_LAST0,iChannel0),load(RES_LAST1,iChannel0));\n    bool input_registered = false;\n    input_registered = ivec2(res_l)!=ivec2(iResolution.xy);\n    // resolution control\n    input_registered = input_registered||(load(ivec2(iResolution.xy)-1, iChannel0))<0.5;\n    \n\n    \n    float bnoise=fragColor.a;\n    if(input_registered||iFrame==0)\n    if (any(greaterThan(ipx, MEMORY_BOUNDARY))){bnoise=Bnoise(fragCoord+iDate.w*0.01);fragColor.a=bnoise;}\n    \n    if (any(greaterThan(ipx, MEMORY_BOUNDARY))) return;\n    \n    vec2 vm_l = vec2(load(VMOUSE0, iChannel0),load(VMOUSE1, iChannel0));\n    bool is_init = load(INIT0, iChannel0)<1.;\n    \n    if (iFrame == 0 || is_init) {\n        vm_l=start_mouse;\n        vec3 position_l=start_pos;\n        store(POSITION0, ipx, start_pos.x, fragColor); // ro\n        store(POSITION1, ipx, start_pos.y, fragColor);\n        store(POSITION2, ipx, start_pos.z, fragColor);\n        store(POSITION_last0, ipx, position_l.x, fragColor); // last_ro\n        store(POSITION_last1, ipx, position_l.y, fragColor);\n        store(POSITION_last2, ipx, position_l.z, fragColor);\n        store(TARGET0, ipx, start_pos.x, fragColor); // mouse look\n        store(TARGET1, ipx, start_pos.y, fragColor);\n        store(TARGET2, ipx, start_pos.z, fragColor);\n        store(VMOUSE0, ipx, start_mouse.x, fragColor); // virtual mouse (rotation_mat)\n        store(VMOUSE1, ipx, start_mouse.y, fragColor);\n        store(VMOUSE_last0, ipx, vm_l.x, fragColor); // last virtual mouse\n        store(VMOUSE_last1, ipx, vm_l.y, fragColor);\n        store(PMOUSE0, ipx, start_mouse.x, fragColor); // real mouse pos\n        store(PMOUSE1, ipx, start_mouse.y, fragColor);\n        store(INIT0, ipx, 2., fragColor); // is_init(0 false, 2 true)\n        store(INPUT0, ipx, 2., fragColor); // key_pressed(0 false, 2 true) \n        store(RES_LAST0, ipx, iResolution.x, fragColor); // xy = last_resolution\n        store(RES_LAST0, ipx, iResolution.x, fragColor);\n        store(HALTON0, ipx, 0., fragColor);\n        store(HALTON1, ipx, 0., fragColor);\n        store(HALTON_last0, ipx, 0., fragColor);\n        store(HALTON_last1, ipx, 0., fragColor);\n        store(hide_ui, ipx, 0., fragColor);\n        store(refl_ui, ipx, 1., fragColor);\n        store(lght_ui, ipx, 0., fragColor);\n        store(rlght_ui, ipx, 0., fragColor);\n        store(rlght_lwt, ipx, 0., fragColor);\n        store(spos_ui, ipx, 0., fragColor);\n        store(color_ui, ipx, 0., fragColor);\n        store(voxbox_ui, ipx, 0., fragColor);\n        store(sun_pow_ui, ipx, 0., fragColor);\n        return;\n    }\n\n    vec3 target      = vec3(load(TARGET0, iChannel0),load(TARGET1, iChannel0),load(TARGET2, iChannel0));   \n    vec3 position    = vec3(load(POSITION0, iChannel0),load(POSITION1, iChannel0),load(POSITION2, iChannel0));\n    vec3 position_l = position;\n    \n    vec2 pm          = vec2(load(PMOUSE0, iChannel0),load(PMOUSE1, iChannel0));\n    vec3 vm          = vec3(load(VMOUSE0, iChannel0),load(VMOUSE1, iChannel0),load(VMOUSE2, iChannel0));\n    \n    vec3 ptarget = target;\n    target += CameraDirInput(vm.xy, keyboard_texture) * iTimeDelta * speed;\n    \n    //Collision_floor(ptarget, target);\n    \n    vec3 lp = position;\n    position += (target - position) * iTimeDelta * 5.0;\n\n    \n    if(length(abs(position)-abs(lp))>0.0001)input_registered=true;\n    \n    store(TARGET0, ipx, target.x, fragColor);\n    store(TARGET1, ipx, target.y, fragColor);\n    store(TARGET2, ipx, target.z, fragColor);\n    store(POSITION0, ipx, position.x, fragColor);\n    store(POSITION1, ipx, position.y, fragColor);\n    store(POSITION2, ipx, position.z, fragColor);\n    \n    if (iMouse.z>0.0) {\n        vec2 tpm = pm + (abs(iMouse.zw) - iMouse.xy)/iResolution.y;\n        input_registered=input_registered||(abs(tpm.x-vm.x)>.5/iResolution.y||abs(tpm.y-vm.y)>.5/iResolution.y);\n    \tstore(VMOUSE0, ipx, tpm.x, fragColor);\n        store(VMOUSE1, ipx, tpm.y, fragColor);\n        store(VMOUSE2, ipx, 1., fragColor);\n    }\n    else if (vm.z > 0.5) {\n    \tstore(PMOUSE0, ipx, vm.x, fragColor);\n        store(PMOUSE1, ipx, vm.y, fragColor);\n        store(VMOUSE2, ipx, 0., fragColor);\n    }\n    store(POSITION_last0, ipx, position_l.x, fragColor);\n    store(POSITION_last1, ipx, position_l.y, fragColor);\n    store(POSITION_last2, ipx, position_l.z, fragColor);\n    store(VMOUSE_last0, ipx, vm_l.x, fragColor);\n    store(VMOUSE_last1, ipx, vm_l.y, fragColor);\n    \n    store(INPUT0, ipx, input_registered?2.:0., fragColor);\n    \n    vec2 halton = input_registered?vec2(0.):halton(iFrame % 16 + 1) - 0.5f;\n    store(HALTON0, ipx, halton.x, fragColor);\n    store(HALTON1, ipx, halton.y, fragColor);\n    \n    vec2 halton_last = vec2(load(HALTON0,iChannel0),load(HALTON1,iChannel0));\n    store(HALTON_last0, ipx, halton_last.x, fragColor);\n    store(HALTON_last1, ipx, halton_last.y, fragColor);\n    \n    store(RES_LAST0, ipx, iResolution.x, fragColor);\n    store(RES_LAST1, ipx, iResolution.y, fragColor);\n    \n#ifndef NO_COMPILE\n    bool last_ui=load(hide_ui, iChannel0)>0.5;\n    bool last_refl=load(refl_ui, iChannel0)>0.5;\n    bool last_lght=load(lght_ui, iChannel0)>0.5;\n    bool rlast_lght=load(rlght_ui, iChannel0)>0.5;\n    bool rlast_tmp = rlast_lght;\n    float last_spos = load(spos_ui, iChannel0);\n    float last_color_ui=load(color_ui, iChannel0);\n    bool last_voxbox_ui=load(voxbox_ui, iChannel0)>0.5;\n    float last_sun_pow_ui=load(sun_pow_ui, iChannel0);\n    //if(!last_ui)\n    {\n        if (iMouse.z>0.0&&vm.z < 0.5) {\n            vec2 res = iResolution.xy/iResolution.y;\n            vec2 tuv = iMouse.xy/iResolution.y * 2.0 - res;\n            vec2 char=res/7.;\n            if(tuv.y>res.y-char.y*9.&&tuv.x>res.x-1.7){\n                if(tuv.y>res.y-char.y){\n                    last_ui=!last_ui;\n                }else\n                if(tuv.y>res.y-char.y*2.&&(!last_ui)){\n                    last_refl=!last_refl;\n                }else\n                if(tuv.y>res.y-char.y*3.&&(!last_ui)){\n                    last_lght=!last_lght;\n                }\n                else\n                if(tuv.y>res.y-char.y*4.&&(!last_ui)){\n                    rlast_lght=!rlast_lght;\n                }\n                else\n                if(tuv.y>res.y-char.y*5.&&(!last_ui)){\n                    if(tuv.x<res.x-1.)last_spos=0.;\n                    else if(tuv.x<res.x-.5)last_spos=1.;\n                    else if(tuv.x<res.x-0.)last_spos=2.;\n                }\n                else\n                if(tuv.y>res.y-char.y*6.&&(!last_ui)){\n                    last_voxbox_ui=!last_voxbox_ui;\n                }else\n                if(tuv.y>res.y-char.y*7.&&(!last_ui)){\n                    if(last_color_ui>0.5)last_color_ui=0.;\n                    else last_color_ui=1.+iTime;\n                }else\n                if(tuv.y>res.y-char.y*9.&&(!last_ui)){\n                    if(tuv.x<res.x-1.15)last_sun_pow_ui=0.;\n                    else if(tuv.x<res.x-0.75)last_sun_pow_ui=1.;\n                    else if(tuv.x<res.x-.4)last_sun_pow_ui=2.;\n                    else if(tuv.x<res.x-.15)last_sun_pow_ui=3.;\n                }\n            }\n        }\n    }\n    store(hide_ui, ipx, float(last_ui), fragColor);\n    store(refl_ui, ipx, float(last_refl), fragColor);\n    store(lght_ui, ipx, float(last_lght), fragColor);\n    store(rlght_ui, ipx, float(rlast_lght), fragColor);\n    if(!rlast_tmp&&rlast_lght)store(rlght_lwt, ipx, iTime, fragColor);\n    store(spos_ui, ipx, last_spos, fragColor);\n    store(voxbox_ui, ipx, float(last_voxbox_ui), fragColor);\n    store(color_ui, ipx, last_color_ui, fragColor);\n    store(sun_pow_ui, ipx, last_sun_pow_ui, fragColor);\n#endif\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n// pos, obj_id\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ui_voxel_box_only=load(voxbox_ui, iChannel0)>0.5;\n\n    vec2 fc=fragCoord.xy;\n    \n    vec2 halton_px_shift = vec2(load(HALTON0,iChannel0),load(HALTON1,iChannel0));\n    fragCoord.xy += halton_px_shift;\n    \n    \n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    vec3 ro;\n    vec3 rd;\n    SetCamera( uv, iChannel0, ro, rd, iResolution.xy);\n    \n    HitInfo hit;\n\tbool rayHit = minDist(ro, rd, hit, max_vox_draw+ANGLE_loops);\n    \n    fragColor=vec4(ro+rd*hit.t,float(hit.obj_type)+.5);\n\t\n}\n\n\n\n\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n\n// using pathtracer functions https://www.shadertoy.com/view/3dlSW7\n// using reprojection functions https://www.shadertoy.com/view/WdjcDd\n\n\n\n// object_id format: (for voxels, by default it just object id)\n\n// (I use \"FLOAT\" to store int so in THIS shader case voxel size max 40x40)\n\n// IF it is UINT then it 999999999 max (it is not, look above)\n// 999999 - 6 numbers goes to voxel ID this why \"city size\" max 1000x1000 - 1 (last voxel(in 1000x1000) empty, reason below)\n\n// 999 - 3 number goes to object in voxel\n\n// for objects - like cube is 1 sphere is 2 etc\n\n// building room ID - restored from pos\n\n// since I have objects \"not in voxel\" - their ID start from 000000\n// this why last voxel in 1000x1000 grid will be empty\n\n\n\n//----------------------------------------------\n\nfloat get_scene_intersect(vec3 ro, vec3 rd, vec3 norm){\n    HitInfo hit;\n    // +0.002 is light leaking\n    return (minDist(ro+0.002*norm, rd, hit, max_vox_draw+ANGLE_loops)?0.:1.);\n}\n\nfloat get_scene_intersect_AO(vec3 ro, vec3 rd, vec3 norm){\n    HitInfo hit;\n    return (minDist(ro+0.002*norm, rd, hit, max_vox_draw_AO_light+ANGLE_loops)?0.:1.);\n}\n\nfloat get_scene_bounce_light(vec3 ro, vec3 rd, vec3 innorm, out vec3 ndir, out vec3 albedo, out vec3 emission, out vec3 norm){\n    HitInfo hit;\n    bool d = minDist(ro+innorm*0.002, rd, hit, max_vox_draw_AO_light+ANGLE_loops);\n    ndir=vec3(0.0001);\n    albedo=vec3(0.0);\n    emission=vec3(0.0);\n    norm = vec3(0.0001);\n    if(d){\n        ndir=ro+rd*hit.t;\n        albedo=hit.color.rgb;\n        emission=hit.emisson;\n        norm = hit.norm;\n    }\n    \n    return d?0.:1.;\n}\n\n//----------------------------------------------\n\n\n\n\n\n// pathtracing functions\n//----------------------------------------------\n\n\n\n\nfloat calculateShadow(vec3 ro, vec3 rd, vec3 normal, float dither, int rays_shadow){\n\tfloat shadow = 0.0;\n    float rShadowRays = 1.0 / float(rays_shadow);\n    \n#ifdef use_ConeVector\n    mat3 tbl = calculateTangentMatrix(rd);\n#endif\n\tfor (int i = 0; i < rays_shadow+ANGLE_loops; ++i){\n#ifdef use_ConeVector\n        vec3 dir = tbl * calculateConeVector((float(i) + dither) * rShadowRays, sunAngularDiameter, rays_shadow);\n#else\n        vec3 dir = normalize(rd+radians(sunAngularDiameter)*getCosineWeightedSample(lightDir,0.15));\n#endif\n        float lDotN = dot(dir, normal);\n        if (lDotN <= 0.0) continue;\n        \n        lDotN = sqrt(clamp(lDotN, 0.0, 1.0));\n        \n\t\tfloat light = sunIluminance * lDotN;\n        float rayHit = get_scene_intersect(ro, dir, normal);\n\t\t\n\t\tshadow += rayHit * light;\n\t}\n    \n    return shadow * rShadowRays;\n}\n\nvec3 calculate_bouncelight_AO(vec3 ro, vec3 rd, vec3 normal, float percentSpecular, float roughness, vec3 sunColor, float noise){\t\n    vec3 AO = vec3(0.0);\n    const float rAORays = 1.0 / float(AORays);\n    \n#ifdef sunlight_2nd_bounce\n    vec3 bouncedLight = vec3(0.0);\n    vec3 abso = vec3(1.);\n#endif\n    \n#ifdef use_ConeVector\n    mat3 tbn = calculateTangentMatrix(normal);\n#endif\n\tfor (int i = 0; i < AORays+ANGLE_loops; ++i){\n#ifdef use_ConeVector\n\t\tvec3 dir = tbn * calculateConeVector((float(i) + noise) * rAORays, 90.0, AORays);\n#else\n\t\tvec3 dir = normalize(normal + 5.*getCosineWeightedSample(normal,0.5));\n#endif\n        float lDotN = dot(dir, normal);\n        if (lDotN <= 0.0) continue;\n        \n        lDotN = sqrt(clamp(lDotN, 0.0, 1.0));\n        float lDotU = dot(dir, upVec);\n        float lDotV = dot(dir, lightDir);\n        \n\t\tvec3 light = calculateSky(vec3(0.0), lDotU, lDotV) * lDotN;\n        \n#ifdef sunlight_2nd_bounce\n        float rayHit;\n        if(texelFetch(iChannel0,lght_ui,0).a>0.5){\n            vec3 bouncePos;\n            vec3 bounceNormal;\n            vec3 bouncedAlbedo;\n            vec3 bouncedEmissive;\n            rayHit = get_scene_bounce_light(ro, dir, normal, bouncePos, bouncedAlbedo, bouncedEmissive, bounceNormal);\n            if(rayHit<0.5)\n            {\n                vec3 bouncedLighting = calculateShadow(bouncePos, lightDir, bounceNormal, noise, 2)*sunColor;\n                bouncedLighting += abso * (bouncedEmissive + bouncedAlbedo*bouncedLighting);\n                abso *= bouncedAlbedo;\n                bouncedLight += bouncedLighting * (1.0 - rayHit) * lDotN;\n            }\n        }else rayHit = get_scene_intersect_AO(ro, dir, normal);\n#else\n        float rayHit = get_scene_intersect_AO(ro, dir, normal);\n#endif\n\t\tAO += rayHit * light;\n\t}\n    \n    AO = AO * rAORays * 2./PI;\n#ifdef sunlight_2nd_bounce\n    bouncedLight = bouncedLight * rAORays;\n    AO+=bouncedLight;\n#endif\n    \n\treturn AO;\n}\n\n//----------------------------------------------\n\n\n// volume\n//----------------------------------------------\n#ifdef enable_volume\nfloat raymarchVolume(vec3 ro, vec3 rd, float noise){\n    const float rSteps = 1.0 / float(volumeSteps);\n    \n    vec3 start = vec3(0.0);\n    vec3 end = ro;\n    float endDepth = length(end);\n    end /= max(endDepth,0.0001);\n    endDepth = min(length(ro), MAX_DIST);\n    end *= endDepth;\n    \n    vec3 increment = (end - start) * rSteps;\n    vec3 rayPosition = noise * increment + start;\n    \n    float fogLitPercent = 0.0f;\n    for (int i = 0; i < volumeSteps+ANGLE_loops; i++){\n        float volumetricShadow = get_scene_intersect(rayPosition + rd, lightDir, rayPosition + rd);\n        fogLitPercent = mix(fogLitPercent, volumetricShadow, 1.0 / float(i+1));\n        rayPosition +=  increment;\n     }\n    return fogLitPercent;\n}\n#endif\n//----------------------------------------------\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    lghtwin=texelFetch(iChannel0,rlght_ui,0).a>0.5;\n    iwt=texelFetch(iChannel0,rlght_lwt,0).a;\n    if(texelFetch(iChannel0,spos_ui,0).a>0.5)lightDir=lightDir2;\n    if(texelFetch(iChannel0,spos_ui,0).a>1.5)lightDir=lightDir3;\n    ui_voxel_box_only=load(voxbox_ui, iChannel0)>0.5;\n    colors_=load(color_ui, iChannel0)>0.5;\n    cwt=texelFetch(iChannel0,color_ui,0).a;\n    float spui=load(sun_pow_ui, iChannel0);\n    if(spui>0.5)sunIluminance=0.85;\n    if(spui>1.5)sunIluminance=0.5;\n    if(spui>2.5)sunIluminance=0.15;\n\n#ifndef use_ConeVector\n    seed = hash12(fragCoord.xy+hash21(float(iFrame%10000)*0.333)*1234.123);\n#endif\n    vec2 fc=fragCoord.xy;\n    vec2 halton_px_shift = vec2(load(HALTON0,iChannel0),load(HALTON1,iChannel0));\n    fragCoord.xy += halton_px_shift;\n\n    vec2 screen_uv = fc.xy / iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    vec3 ro;\n    vec3 rd;\n    SetCamera(uv, iChannel0, ro, rd, iResolution.xy);\n    \n    float noise=0.; \n    \n#ifdef use_ConeVector\n    // noise for ConeVector\n    \n    ivec2 ipx = ivec2(fc);\n    ivec2 reserv = ivec2(5,MEMORY_BOUNDARY.y+5);\n    ipx=ipx%(ivec2(textureSize(iChannel0,0).xy)-reserv);\n    float n0 = texelFetch(iChannel0, textureSize(iChannel0,0).xy-ipx-1, 0).a;\n    noise = fract(n0 + 0.75*float(iFrame % 264) * c_goldenRatioConjugate);\n\n    // test hash12 as noise\n    //vec2 tfc = fc.xy+hash21(float(iFrame%10000)*0.333)*iResolution.y*2.;\n    //noise = hash12(tfc);\n    \n#endif\n\n    vec4 this_pos = texelFetch(iChannel1, ivec2(fc), 0);\n    int obj_id = int(abs(this_pos.w));\n    vec3 pos=this_pos.xyz;\n    \n    bool rayHit = obj_id>0;\n    vec3 normal=rd;\n    vec3 albedo;\n    vec3 emission;\n    float rough;\n    float metal;\n    \n    if(obj_id==OBJ_FLOOR)normal=get_normal_OBJ_FLOOR(pos);\n    else if(obj_id==OBJ_BOX)normal=get_normal_OBJ_BOX(pos, bpos,vec3(voxels_num.x+0.5,pltf_h,voxels_num.y+0.5));\n    else if(obj_id==OBJ_BOX_floor_emi)normal=get_normal_OBJ_BOX(pos, bpos,vec3(voxels_num.x+0.5,pltf_h,voxels_num.y+0.5)*vec3(0.35,1.99,0.35));\n    else if(obj_id/1000>=1){\n        int tix = obj_id/1000-1;\n        int lid = obj_id-(obj_id/1000)*1000;\n        vec2 vox_id = vec2(float(tix%int((voxels_num.x+0.5)*2.)),float(tix/int((voxels_num.x+0.5)*2.)));\n        // https://www.shadertoy.com/view/mdfSz8\n        float voxh = max(get_heightField(vox_id+1.+min(iTime,0.),voxels_num+0.5+min(iTime,0.)),0.001)*voxel_h;\n        vec4 boxp = get_vox_size(vox_id+1.,voxels_num+0.5);\n        vec3 tvoxbox=vec3(-boxp.x,-pltf_h,-boxp.y);\n        vec3 vox_size=vec3(boxp.z,voxh,boxp.w);\n        vec3 vox_0_shift = -bpos+vec3(1.,-voxh,1.);\n        vox_0_shift.xz+=voxels_num;\n#ifdef voxel_box_only\n        normal=get_normal_OBJ_BOX(pos,-vox_0_shift-tvoxbox,vox_size);\n#else\n        if(ui_voxel_box_only){\n            vec3 interior_rooms=vec3(4.,4.,4.);\n            interior_rooms=max(floor(vox_size/0.1),vec3(2.,2.,2.));\n            interior_rooms+=2.*fract(interior_rooms/2.);\n            if(lid==OBJ_BOX_build||lid==OBJ_BOX)normal=get_normal_OBJ_BOX(pos,-vox_0_shift-tvoxbox,vox_size);\n            else normal=get_normal_OBJ_room(pos,-vox_0_shift-tvoxbox,vox_size, interior_rooms);\n        }else normal=get_normal_OBJ_BOX(pos,-vox_0_shift-tvoxbox,vox_size);\n#endif\n    }\n    else if(obj_id==OBJ_BOX_build_floor)normal=get_normal_OBJ_BOX(pos, bpos,vec3(voxels_num.x+0.5,pltf_h,voxels_num.y+0.5));\n    else if(obj_id==OBJ_BOX_room_b_floor)normal=get_normal_OBJ_room(pos, bpos,vec3(voxels_num.x+0.5,pltf_h,voxels_num.y+0.5), floor_rooms);\n#ifdef NO_COMPILE\n    else if(obj_id==OBJ_BOX_build_ncomp)normal=get_normal_OBJ_BOX(pos, bpos+vec3(0.,6.35,0.),0.35*vec3(voxels_num.x+0.5,15.,voxels_num.y+0.5));\n    else if(obj_id==OBJ_BOX_room_b_ncomp)normal=get_normal_OBJ_room(pos, bpos+vec3(0.,6.35,0.),0.35*vec3(voxels_num.x+0.5,15.,voxels_num.y+0.5), box_ncomp_rooms);\n#endif\n    get_scene_material(rayHit, ro, rd, pos, normal, obj_id, albedo, emission, rough, metal);\n    \n    vec3 sunColor = calculateSunColor(lightDir.y);\n\tvec3 color_light_AO = calculate_bouncelight_AO(pos, rd, normal, metal, rough, sunColor, noise);\n    \n    vec3 shadow = calculateShadow(pos, lightDir, normal, noise, shadowRays)*sunColor;\n    float de = dot(clamp(emission,0.,1.),vec3(1.))/3.;\n    vec3 color = mix(color_light_AO+shadow,vec3(0.),0.*de);\n    if(obj_id==OBJ_FLOOR)color=clamp(color,0.,1.); //to make floor same as sky\n    color = mix(albedo*color, emission, de);\n    if(!rayHit) color = get_sky_color(rd);\n    \n    float fogLitPercent=0.;\n#ifdef enable_volume\n    #ifdef use_ConeVector\n    fogLitPercent = raymarchVolume(pos - ro, ro, noise);\n    #else\n    fogLitPercent = raymarchVolume(pos - ro, ro, hash11_seed());\n    #endif\n#endif\n    \n    bool input_registered = load(INPUT0,iChannel0)>1.;\n    fragColor = vec4(color, fogLitPercent);\n    //protection when camera go inside of shape and intersection function may return inf or nan\n    fragColor=clamp(fragColor,0.,100.); \n#ifdef use_reproject_TAA\n    // reprojection TAA\n    if(input_registered){\n        vec4 oldCol = previousSample(ro, pos,iChannel0, iChannel0, iChannel2, iResolution.xy);\n        float factor = (oldCol.a == 0.) ? 0. : .95;\n        fragColor.rgb = mix(fragColor.rgb, oldCol.rgb, factor);\n        fragColor.a = mix(fragColor.a, oldCol.a, factor*0.75); \n        //fragColor.a=fogLitPercent; // to disable reproj for volumtertic shadow\n    }else\n#endif\n    // default TAA\n    {\n        vec4 backColor = texture(iChannel2, screen_uv);\n        fragColor = mix(fragColor, backColor, 0.95 * (1.-float(input_registered)));\n    }\n    fragColor.a=max(fragColor.a,0.00001); // reprojection flag\n}\n\n\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\n\n// using https://www.shadertoy.com/view/3dlSW7\n// using https://www.shadertoy.com/view/WdjcDd\n\n\n\n//----------------------------------------------\n\n\nfloat get_scene_intersect_reflection(vec3 ro, vec3 rd, vec3 norm){\n    HitInfo hit;\n    //0.002 is light leak\n    return (minDist(ro+0.002*norm, rd, hit, max_vox_draw_reflection+ANGLE_loops)?0.:1.);\n}\n\nfloat get_scene_bounce_light_reflection(vec3 ro, vec3 rd, vec3 innorm, out vec3 ndir, out vec3 albedo, out vec3 emission, out vec3 norm){\n    HitInfo hit;\n    bool d = minDist(ro+innorm*0.002, rd, hit, max_vox_draw_reflection+ANGLE_loops);\n    ndir=vec3(0.0001);\n    albedo=vec3(0.0);\n    emission=vec3(0.0);\n    norm = vec3(0.0001);\n    if(d){\n        ndir=ro+rd*hit.t;\n        albedo=hit.color.rgb;\n        emission=hit.emisson;\n        norm = hit.norm;\n    }\n    \n    return d?0.:1.;\n}\n\n//----------------------------------------------\n\n\n\n\n\n// pathtracing functions\n//----------------------------------------------\n\nfloat calculateFresnel(float cosTheta, float f0){\n    cosTheta = 1.0 - cosTheta;\n\tcosTheta = cosTheta * cosTheta * cosTheta * cosTheta * cosTheta;\n    \n    return cosTheta * (1.0 - f0) + f0;\n}\n\n#ifdef enable_reflections\nvec3 calculateReflection(vec3 ro, vec3 rd, vec3 normal, float percentSpecular, float roughness, vec3 totalLighting, float noise){\t\n#ifdef use_ConeVector\n    mat3 tbn = calculateTangentMatrix(normal);\n#endif\n    vec3 reflection = vec3(0.0);\n    float rReflectionRays = 1.0 / float(reflectionRays);\n    float fresnel = 0.0;\n\n    for (int i = 0; i < reflectionRays+ANGLE_loops; ++i){\n#ifdef use_ConeVector\n        vec3 dir = tbn * calculateRoughSpecular(fract((float(i) + noise) * rReflectionRays), reflectionRays, roughness);\n#else\n        vec3 dir = normalize(normal + 3.5*roughness*roughness*getCosineWeightedSample(normal,0.1+0.4*roughness));\n#endif\n        dir = reflect(rd, dir);\n\n        float lDotN = dot(dir, normal);\n        float f = lDotN;\n        if (lDotN <= 0.0) continue;\n\n        float lDotU = dot(dir, upVec);\n        float lDotV = dot(dir, lightDir);\n\n        fresnel += calculateFresnel(f, percentSpecular);\n\n        vec3 light = calculateSky(vec3(0.0), lDotU, lDotV);\n#ifdef reflection_color_emi\n        vec3 bouncePos;\n        vec3 bounceNormal;\n        vec3 bouncedAlbedo;\n        vec3 bouncedEmissive;\n        float rayHit = get_scene_bounce_light_reflection(ro, dir, normal, bouncePos, bouncedAlbedo, bouncedEmissive, bounceNormal);\n        reflection += rayHit * light;\n        reflection += (1.-rayHit) * bouncedEmissive;\n#else\n        float rayHit = get_scene_intersect_reflection(ro, dir, normal);\n        reflection += rayHit * light;\n#endif\n    }\n    \n    reflection = reflection * rReflectionRays;\n    fresnel = fresnel * rReflectionRays;\n\n    totalLighting = mix(totalLighting, reflection, fresnel);\n\t\n\treturn totalLighting;\n}\n#endif\n//----------------------------------------------\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    lghtwin=texelFetch(iChannel0,rlght_ui,0).a>0.5;\n    iwt=texelFetch(iChannel0,rlght_lwt,0).a;\n    if(texelFetch(iChannel0,spos_ui,0).a>0.5)lightDir=lightDir2;\n    if(texelFetch(iChannel0,spos_ui,0).a>1.5)lightDir=lightDir3;\n    ui_voxel_box_only=load(voxbox_ui, iChannel0)>0.5;\n    colors_=load(color_ui, iChannel0)>0.5;\n    cwt=texelFetch(iChannel0,color_ui,0).a;\n    float spui=load(sun_pow_ui, iChannel0);\n    if(spui>0.5)sunIluminance=0.85;\n    if(spui>1.5)sunIluminance=0.5;\n    if(spui>2.5)sunIluminance=0.15;\n\n#ifndef use_ConeVector\n    seed = hash12(fragCoord.xy+hash21(float(iFrame%10000)*0.333)*1234.123);\n#endif\n    vec2 fc=fragCoord.xy;\n    vec2 halton_px_shift = vec2(load(HALTON0,iChannel0),load(HALTON1,iChannel0));\n    fragCoord.xy += halton_px_shift;\n\n    vec2 screen_uv = fc.xy / iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    vec3 ro;\n    vec3 rd;\n    SetCamera(uv, iChannel0, ro, rd, iResolution.xy);\n    \n    \n    float noise=0.; \n    \n#ifdef use_ConeVector\n    // noise for ConeVector\n    \n    ivec2 ipx = ivec2(fc);\n    ivec2 reserv = ivec2(5,MEMORY_BOUNDARY.y+5);\n    ipx=ipx%(ivec2(textureSize(iChannel0,0).xy)-reserv);\n    float n0 = texelFetch(iChannel0, textureSize(iChannel0,0).xy-ipx-1, 0).a;\n    noise = fract(n0 + 0.75*float(iFrame % 264) * c_goldenRatioConjugate);\n\n    // test hash12 as noise\n    //vec2 tfc = fc.xy+hash21(float(iFrame%10000)*0.333)*iResolution.y*2.;\n    //noise = hash12(tfc);\n#endif\n    vec4 this_pos = texelFetch(iChannel1, ivec2(fc), 0);\n    int obj_id = int(abs(this_pos.w));\n    vec3 pos=this_pos.xyz;\n    \n    bool rayHit = obj_id>0;\n    vec3 normal=rd;\n    vec3 albedo;\n    vec3 emission;\n    float rough;\n    float metal;\n    \n    \n    if(obj_id==OBJ_FLOOR)normal=get_normal_OBJ_FLOOR(pos);\n    else if(obj_id==OBJ_BOX)normal=get_normal_OBJ_BOX(pos, bpos,vec3(voxels_num.x+0.5,pltf_h,voxels_num.y+0.5));\n    else if(obj_id==OBJ_BOX_floor_emi)normal=get_normal_OBJ_BOX(pos, bpos,vec3(voxels_num.x+0.5,pltf_h,voxels_num.y+0.5)*vec3(0.35,1.99,0.35));\n    else if(obj_id/1000>=1){\n        int tix = obj_id/1000-1;\n        int lid = obj_id-(obj_id/1000)*1000;\n        vec2 vox_id = vec2(float(tix%int((voxels_num.x+0.5)*2.)),float(tix/int((voxels_num.x+0.5)*2.)));\n        // https://www.shadertoy.com/view/mdfSz8\n        float voxh = max(get_heightField(vox_id+1.+min(iTime,0.),voxels_num+0.5+min(iTime,0.)),0.001)*voxel_h;\n        vec4 boxp = get_vox_size(vox_id+1.,voxels_num+0.5);\n        vec3 tvoxbox=vec3(-boxp.x,-pltf_h,-boxp.y);\n        vec3 vox_size=vec3(boxp.z,voxh,boxp.w);\n        vec3 vox_0_shift = -bpos+vec3(1.,-voxh,1.);\n        vox_0_shift.xz+=voxels_num;\n#ifdef voxel_box_only\n        normal=get_normal_OBJ_BOX(pos,-vox_0_shift-tvoxbox,vox_size);\n#else\n        if(ui_voxel_box_only){\n            vec3 interior_rooms=vec3(4.,4.,4.);\n            interior_rooms=max(floor(vox_size/0.1),vec3(2.,2.,2.));\n            interior_rooms+=2.*fract(interior_rooms/2.);\n            if(lid==OBJ_BOX_build||lid==OBJ_BOX)normal=get_normal_OBJ_BOX(pos,-vox_0_shift-tvoxbox,vox_size);\n            else normal=get_normal_OBJ_room(pos,-vox_0_shift-tvoxbox,vox_size, interior_rooms);\n        }else normal=get_normal_OBJ_BOX(pos,-vox_0_shift-tvoxbox,vox_size);\n#endif\n    }\n    else if(obj_id==OBJ_BOX_build_floor)normal=get_normal_OBJ_BOX(pos, bpos,vec3(voxels_num.x+0.5,pltf_h,voxels_num.y+0.5));\n    else if(obj_id==OBJ_BOX_room_b_floor)normal=get_normal_OBJ_room(pos, bpos,vec3(voxels_num.x+0.5,pltf_h,voxels_num.y+0.5), floor_rooms);\n#ifdef NO_COMPILE\n    else if(obj_id==OBJ_BOX_build_ncomp)normal=get_normal_OBJ_BOX(pos, bpos+vec3(0.,6.35,0.),0.35*vec3(voxels_num.x+0.5,15.,voxels_num.y+0.5));\n    else if(obj_id==OBJ_BOX_room_b_ncomp)normal=get_normal_OBJ_room(pos, bpos+vec3(0.,6.35,0.),0.35*vec3(voxels_num.x+0.5,15.,voxels_num.y+0.5), box_ncomp_rooms);\n#endif\n    get_scene_material(rayHit, ro, rd, pos, normal, obj_id, albedo, emission, rough, metal);\n    \n    \n    \n    vec3 sunColor = calculateSunColor(lightDir.y);\n    vec3 color = texelFetch(iChannel2, ivec2(fc), 0).rgb;\n#ifdef enable_reflections\n    if(texelFetch(iChannel0,refl_ui,0).a>0.5){\n        color = calculateReflection(pos, rd, normal, metal, rough, color, noise);\n\n        //fade color to sky on floor\n        if(obj_id==OBJ_FLOOR) color=mix(color,get_sky_color(rd),smoothstep(100.,200.,length(pos.xz)));\n    }\n#endif\n    \n\tfloat lDotU = dot(rd, upVec);\n\tfloat lDotV = dot(rd, lightDir);\n\t\n    if(!rayHit) color = get_sky_color(rd);\n    \n    float absorb = 0.;\n#ifdef enable_volume\n    float depth = length(ro-pos);\n    absorb = exp(-depth * volume_fogDensity);\n    absorb = clamp(absorb,.25,1.);\n#endif\n    \n    bool input_registered = load(INPUT0,iChannel0)>1.;\n    fragColor = vec4(color, absorb);\n    //protection when camera go inside of shape and intersection function may return inf or nan\n    fragColor=clamp(fragColor,0.,100.); \n#ifdef use_reproject_TAA\n    // reprojection TAA\n    if(input_registered){\n        vec4 oldCol = previousSample(ro, pos,iChannel0, iChannel0, iChannel3, iResolution.xy);\n        float factor = (oldCol.a == 0.) ? 0. : .90;\n        fragColor.rgb = mix(fragColor.rgb, oldCol.rgb, factor);\n        fragColor.a = mix(fragColor.a, oldCol.a, factor*0.75); \n        //fragColor.a=absorb; // to disable reproj for volumtertic shadow\n    }else\n#endif\n    // default TAA\n    {\n        vec4 backColor = texture(iChannel3, screen_uv);\n        fragColor = mix(fragColor, backColor, 0.905 * (1.-float(input_registered)));\n    }\n    fragColor.a=max(fragColor.a,0.00001); // reprojection flag\n    \n}\n\n","name":"Buffer D","description":"","type":"buffer"}]}