{"ver":"0.1","info":{"id":"XsdSRs","date":"1460928243","viewed":160,"name":"Boxed In","username":"Neph","description":"Experimenting. Still learning so probably a lot wrong.\nNot sure how to avoid recursion between the reflection and refraction functions.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","texture","color","mirror","lights","reflect","refract"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXREFLECTIONS 2\n#define MAXITER 64\n\nstruct color{\n  vec3  c;\n  float d;\n  vec2  m;\n  vec2  r;\n};\n\ncolor map (vec3 p){\n        color final;\n    \tfinal.c = vec3(1.0);\n    \tfinal.d = 1.0;\n    \tfinal.m = vec2(0.0);\n    \tfinal.r = vec2(0.0);\n    \t\n    \tcolor sphere;\n    \tsphere.c = vec3(1.0, 0.0, 0.0);\n    \tsphere.d = length(p + vec3(0.8, -0.8, 0.0)) - 0.2;\n    \tsphere.m = vec2(0.0);\n    \tsphere.r = vec2(0.0);\n    \n    \tcolor msphere;\n    \tmsphere.c = vec3(0.0);\n    \tmsphere.d = length(p + vec3(-0.5, 1.0, 0.0)) - 0.5;\n    \tmsphere.m = vec2(1.0, 0.3);\n    \tmsphere.r = vec2(0.0);\n    \n    \tcolor rsphere;\n    \trsphere.c = vec3(1.0);\n    \trsphere.d = length(p) - 0.5;\n    \trsphere.m = vec2(0.0);\n    \trsphere.r = vec2(1.0, 0.8);\n    \n    \tcolor rceiling;\n    \trceiling.c = vec3(0.2, 0.3, 1.0);\n    \trceiling.d = -p.y + 1.0;\n    \trceiling.m = vec2(1.0, 0.9);\n    \trceiling.r = vec2(0.0);\n    \n        color rfloor;\n    \trfloor.c = vec3(1.0);\n    \trfloor.d = p.y + 1.0;\n    \trfloor.m = vec2(0.0);\n    \trfloor.r = vec2(0.0);\n    \n    \tcolor lwall;\n    \tlwall.c = vec3(1.0, 0.2, 0.2);\n    \tlwall.d = p.x + 1.0;\n    \tlwall.m = vec2(0.0);\n    \tlwall.r = vec2(0.0);\n    \n    \tcolor rwall;\n    \trwall.c = vec3(0.2, 1.0, 0.2);\n    \trwall.d = -p.x + 1.0;\n    \trwall.m = vec2(0.0);\n    \trwall.r = vec2(0.0);\n    \n    \tcolor bwall;\n        vec2 q = fract(p.xy / 2.0 + 0.5);\n        bwall.c = vec3(q, 0.0);\n        bwall.c = texture(iChannel0, bwall.c.xy).xyz;\n    \tbwall.d = -p.z + 0.5;\n    \tbwall.m = vec2(0.0);\n    \tbwall.r = vec2(0.0);\n    \n    \tcolor hwall;\n    \thwall.c = vec3(0.5, 0.5, 0.0);\n    \thwall.d = p.z + 3.5;\n    \thwall.m = vec2(0.0);\n    \thwall.r = vec2(0.0);\n    \n    if(final.d > sphere.d){\n     \tfinal = sphere;   \n    }\n    if (final.d > msphere.d){\n     \tfinal = msphere;   \n    }\n    if (final.d > rsphere.d){\n     \tfinal = rsphere;   \n    }\n    if(final.d > rceiling.d){\n     \tfinal = rceiling;   \n    }\n    if(final.d > rfloor.d){\n     \tfinal = rfloor;   \n    }\n    if(final.d > lwall.d){\n     \tfinal = lwall;   \n    }\n    if(final.d > rwall.d){\n     \tfinal = rwall;   \n    }\n    if(final.d > bwall.d){\n        final = bwall;\n    }\n    if(final.d > hwall.d){\n     \tfinal = hwall;   \n    }\n    \treturn final;\n    }\n\ncolor march(vec3 o, vec3 r){\n \tcolor t;\n    t.c = vec3(0.0);\n    t.d = 0.0;\n    t.m = vec2(0.0);\n    t.r = vec2(0.0);\n    \n    for(int i = 0; i < MAXITER; i++){\n     \tvec3 p = o + r * t.d;\n        color scene = map(p);\n        \n        t.c = scene.c;\n        t.d += scene.d * 0.5;\n        t.m = scene.m;\n        t.r = scene.r;\n    }\n    return t;\n}\nvec3 gradient (vec3 p){\n    const vec3 dx = vec3(0.1, 0.0, 0.0);\n    const vec3 dy = vec3(0.0, 0.1, 0.0);\n    const vec3 dz = vec3(0.0, 0.0, 0.1);\n    \n    return normalize(vec3(\n        \t\tmap(p+dx).d - map(p-dx).d,\n                map(p+dy).d - map(p-dy).d,\n                map(p+dz).d - map(p-dz).d\n    \t\t\t));\n}\nvec3 shade(vec3 n, vec3 pos, color scene){\n\tvec3 iFin = vec3(0.0);\n    {\n     vec3  lipos = vec3(sin(iTime)*0.5, 0.4, -1.0);\n     vec3  licol = vec3(1.0);\n     float lintensity = 1.0;\n     vec3 lidir = normalize((lipos - pos));\n     float libdir = dot(n, lidir);\n     iFin += scene.c * libdir;\n    }\n    return iFin;\n}\nvec3 gloss(color scene, vec3 rd, vec3 p, vec3 nor){\n    color d = scene;\n    vec3 c = scene.c;\n    vec3 r = rd;\n    vec3 pos = p;\n    vec3 n = nor;\n    float amt = 0.0;\n    \n    for (int i = 0; i < MAXREFLECTIONS; i++){\n        if (d.m.x > 0.0){\n            r = reflect(r, n);\n            amt += d.m.y;\n            d = march(pos + r * 0.001, r);\n            pos = pos + r * d.d;\n            n = gradient(pos);\n            vec3 lit = shade(n, pos, d);\n            lit = clamp(lit, 0.0, 1.0);\n            c = mix(c, lit, 1.0 - amt);\n        }\n    }\n    return c;\n}\nvec3 refr (vec3 col, vec3 rd, vec3 p, vec3 nor, color scene){\n    vec3 r = refract(rd, -nor, scene.r.y);\n    color d = march(-p - r * 0.001, -r);\n    vec3 pos = p + r * d.d;\n    vec3 n = gradient(pos);\n    scene.c = shade(n, pos, d);\n    return scene.c;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n        \n    vec3 col = vec3(0.0);\n    \n    vec3 ro = vec3((iMouse.x/iResolution.x)*2.0 - 1.0 + 0.1, 0.0, -(iMouse.y/iResolution.y)*2.0 - 1.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    color scene = march(ro, rd);\n    \n    vec3 pos = ro + rd * scene.d;\n    \n    vec3 n = gradient(pos);\n    vec3 lit = shade(n, pos, scene);\n    if(scene.r.x > 0.0){\n     \tlit = refr(lit, rd, pos, n, scene);   \n    }\n    if(scene.m.x > 0.0){\n     \tlit = gloss(scene, rd, pos, n);   \n    }\n    \n    col = vec3(lit);\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}