{"ver":"0.1","info":{"id":"dly3zm","date":"1683957932","viewed":148,"name":"RayTracing(Wbox1)","username":"wbox","description":"my first try of making ray tracing shaders","likes":1,"published":3,"flags":32,"usePreview":0,"tags":["myraytracingfirsttry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float MaxDistance = 99999.0;\nconst int MaxReflections = 4;\nconst float lightStrenth = 1.0;\nconst int samples = 4;\nconst float blur = 0.9995;\n\nfloat seed;\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Box\n{\n    vec3 position;\n    float size;\n    vec4 color;\n};\n\nstruct Sphere\n{\n    vec3 position;\n    float radius;\n    vec4 color;\n};\n\nstruct Plane\n{\n    float position;\n    vec3 normal;\n    vec4 color;\n};\n\nstruct LightSource\n{\n    vec3 position;\n    float radius;\n};\n\nint LCGStep(int z, int A, int C)\n{\n\treturn (A * z + C);\t\n}\n\nfloat random(vec2 co){\n    return fract(sin(dot(co * seed, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 randomOnSphere(Ray ray) {\n\tvec3 rand = vec3(\n    random(ray.direction.xy),\n    random(ray.direction.yz),\n    random(ray.direction.zx));\n\tfloat theta = rand.x * 2.0 * 3.14159265;\n\tfloat v = rand.y;\n\tfloat phi = acos(2.0 * v - 1.0);\n\tfloat r = pow(rand.z, 1.0 / 3.0);\n\tfloat x = r * sin(phi) * cos(theta);\n\tfloat y = r * sin(phi) * sin(theta);\n\tfloat z = r * cos(phi);\n\treturn vec3(x, y, z);\n}\n\nvec3 light = normalize(vec3(0.0, -1.0, 1.0));\n\nvec3 getSky(vec3 rd) {\n\tvec3 col = vec3(0.3, 0.6, 1.0);\n\tvec3 sun = vec3(0.95, 0.9, 1.0);\n\tsun *= max(0.0, pow(dot(rd, light), 256.0));\n\t//col *= max(0.0, pow(dot(rd, light), 256.0));\n    col *= pow(dot(rd * 2.0,vec3(0.0,1.0,0.0)),0.1);\n    //return vec3(0.0);\n\treturn clamp(sun+col,0.0,1.0);\n}\n\nfloat planeIntersect(Ray ray,Plane plane)\n{\n    return -(dot(ray.origin,plane.normal)+plane.position)/dot(ray.direction,plane.normal);\n}\n\nvec2 sphereIntersect(Ray ray, Sphere sphere)\n{\n    vec3 oc = ray.origin - sphere.position;\n    float b = dot( oc, ray.direction );\n    float c = dot( oc, oc ) - sphere.radius*sphere.radius;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nvec2 boxIntersection(Ray ray, Box box, out vec3 outNormal) \n{\n    ray.origin -= box.position;\n    vec3 m = 1.0/ray.direction; \n    vec3 n = m*ray.origin;   \n    vec3 k = abs(m)*box.size;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); \n    if (tN > 0.0)\n    {\n        outNormal = step(vec3(tN),t1);\n    }\n    else\n    {\n        outNormal = step(t2,vec3(tF));\n    }\n    outNormal *= -sign(ray.direction);\n    return vec2( tN, tF );\n}\n\nvec4 castRay(out Ray ray)\n{\n    vec2 minHitDistance = vec2(MaxDistance);\n    vec2 hitDistance = vec2(0.0);\n    vec4 color = vec4(1.0);\n    vec3 normal = vec3(0.0);\n    \n    Sphere sphere;\n    sphere.position =  vec3(7.0,6.0,2.0);\n    sphere.radius = 1.5;\n    sphere.color = vec4(1.0,1.0,1.0,-1.0);\n    \n    hitDistance = sphereIntersect(ray,sphere);\n    if (hitDistance.x > 0.0 && hitDistance.x < minHitDistance.x)\n    {\n        minHitDistance = hitDistance;      \n        normal = normalize((ray.origin + ray.direction * hitDistance.x) - sphere.position);\n        color = sphere.color;\n    }\n    \n    Sphere sphere2;\n    sphere2.position = vec3(-6.0,0.1,6.0);\n    sphere2.radius = 3.0;\n    sphere2.color = vec4(1.0,1.0,1.0,0.95);    \n    hitDistance = sphereIntersect(ray,sphere2);\n    if (hitDistance.x > 0.0 && hitDistance.x < minHitDistance.x)\n    {\n        minHitDistance = hitDistance;      \n        normal = normalize((ray.origin + ray.direction * hitDistance.x) - sphere2.position);\n        color = sphere2.color;\n    }\n    \n    Sphere sphere3;\n    sphere3.position = vec3(0.0,15.0,10.0);\n    sphere3.radius = 3.0;\n    sphere3.color = vec4(1.0,1.0,1.0,-3.0);    \n    hitDistance = sphereIntersect(ray,sphere3);\n    if (hitDistance.x > 0.0 && hitDistance.x < minHitDistance.x)\n    {\n        minHitDistance = hitDistance;      \n        normal = normalize((ray.origin + ray.direction * hitDistance.x) - sphere3.position);\n        color = sphere3.color;\n    }\n    \n    Plane plane;\n    plane.normal = vec3(0.0,1.0,0.0);\n    plane.position = 1.0;\n    plane.color = vec4(0.5,0.5,0.5,0.0);\n    hitDistance = vec2(planeIntersect(ray,plane));\n    if (hitDistance.x > 0.0 && hitDistance.x < minHitDistance.x)\n    {\n        minHitDistance = hitDistance;\n        normal = plane.normal;\n        color = plane.color;\n    }\n    \n    Plane plane2;\n    plane2.normal = vec3(-1.0,0.0,0.0);\n    plane2.position = 10.0;\n    plane2.color = vec4(1.0,0.1,0.1,0.0);\n    hitDistance = vec2(planeIntersect(ray,plane2));\n    if (hitDistance.x > 0.0 && hitDistance.x < minHitDistance.x)\n    {\n        minHitDistance = hitDistance;\n        normal = plane2.normal;\n        color = plane2.color;\n    }\n    \n    Plane plane3;\n    plane3.normal = vec3(1.0,0.0,0.0);\n    plane3.position = 10.0;\n    plane3.color = vec4(1.0,1.0,1.0,0.0);\n    hitDistance = vec2(planeIntersect(ray,plane3));\n    if (hitDistance.x > 0.0 && hitDistance.x < minHitDistance.x)\n    {\n        minHitDistance = hitDistance;\n        normal = plane3.normal;\n        color = plane3.color;\n    }\n    \n    Plane plane4;\n    plane4.normal = vec3(0.0,0.0,-1.0);\n    plane4.position = 10.0;\n    plane4.color = vec4(0.0,1.0,0.0,0.0);\n    hitDistance = vec2(planeIntersect(ray,plane4));\n    if (hitDistance.x > 0.0 && hitDistance.x < minHitDistance.x)\n    {\n        minHitDistance = hitDistance;\n        normal = plane4.normal;\n        color = plane4.color;\n    }\n    \n    Plane plane5;\n    plane5.normal = vec3(0.0,-1.0,0.0);\n    plane5.position = 15.0;\n    plane5.color = vec4(0.0,0.0,1.0,0.0);\n    hitDistance = vec2(planeIntersect(ray,plane5));\n    if (hitDistance.x > 0.0 && hitDistance.x < minHitDistance.x)\n    {\n        minHitDistance = hitDistance;\n        normal = plane5.normal;\n        color = plane5.color;\n    }\n    \n    Box box;\n    box.position = vec3(7.0,2.1,2.0);\n    box.size = 2.0;\n    box.color = vec4(0.0,1.0,0.0,0.0);\n    vec3 boxNormal = vec3(0.0);\n    hitDistance = boxIntersection(ray,box,boxNormal);\n    if (hitDistance.x > 0.0 && hitDistance.x < minHitDistance.x)\n    {\n        minHitDistance = hitDistance;\n        color = box.color;\n        normal = boxNormal;\n    }\n    if (minHitDistance.x == MaxDistance)\n    {\n        return vec4(getSky(ray.direction),-2.0);\n    }\n    if(color.a == -2.0) \n    {\n        return color;\n    }\n    vec3 reflected = reflect(ray.direction, normal);\n    if(color.a == -3.0)\n    {\n        \n        //float fresnel = 1.0 - abs(dot(ray.direction, normal));\n        //if (1.0/fresnel > 2.0) \n        //{\n        //    color.a = -2.0;\n        //    return color;\n        //}\n        //vec3 hitPosition = ray.origin + ray.direction * hitDistance.x;\n        //vec3 r = randomOnSphere(ray);\n        //vec3 diffuse = normalize(r * dot(r, normal));\n        //ray.origin += ray.direction * (minHitDistance.x - 0.0001);\n        //ray.direction = mix(diffuse, reflected, color.a);\n\t\treturn color;\n    }\n    if(color.a < 0.0) {\n\t\tfloat fresnel = 1.0 - abs(dot(ray.direction, normal));\n\t\tif(length(randomOnSphere(ray)) - 0.7 < pow(fresnel,5.4)) {\n\t\t\tray.direction = reflected;\n\t\t\treturn color * pow(fresnel+1.0,0.25);\n\t\t}\n\t\tray.origin += ray.direction * (minHitDistance.y + 0.0001);\n\t\tray.direction = refract(ray.direction, normal, 1.0 / (1.0 - color.a));\n\t    \n        return color;\n\t}\n    vec3 hitPosition = ray.origin + ray.direction * hitDistance.x;\n\tvec3 r = randomOnSphere(ray);\n\tvec3 diffuse = normalize(r * dot(r, normal));\n\tray.origin += ray.direction * (minHitDistance.x - 0.0001);\n\tray.direction = mix(diffuse, reflected, color.a);\n    return color;\n}\n\nvec3 traceRay(Ray ray) {\n\tvec3 color = vec3(1.0);\n\tfor(int i = 0; i < MaxReflections; i++)\n\t{\n\t\tvec4 reflectedColor = castRay(ray);\n\t\t\n\t\tif(reflectedColor.a == -2.0)\n        {\n            float a = 0.8;\n            color *= vec3(\n            pow(reflectedColor.r,a),\n            pow(reflectedColor.g,a),\n            pow(reflectedColor.b,a));\n            if (distance(color,vec3(1.0,1.0,1.0)) < 0.310009)\n            {\n                color = color * lightStrenth;\n            }\n            return color;\n        }\n        color *= reflectedColor.rgb;\n        if(reflectedColor.a == -3.0) \n        {\n           \n            return color * reflectedColor.rgb;\n        }\n\t}\n\treturn vec3(0.0);\n}\n\nvec2 initUV(vec2 fragCoord)\n{\n    return (fragCoord-0.5*iResolution.xy)/iResolution.y;\n}\n\nuniform float accumulator;\n\nvec4 GetColor(vec4 fragColor, vec2 fragCoord )\n{\n    vec2 uv = initUV(fragCoord);\n    Ray ray;\n    ray.origin = vec3(-1.0,7.5,-15.0);\n    ray.direction = normalize(vec3(uv,1.0));\n    \n    seed = iTime;\n    vec3 r = randomOnSphere(ray);\n\tray.direction = normalize(mix(r, ray.direction, blur));\n    \n    \n    vec3 color = vec3(0.0);\n   \n    \n    for(int i = 0;i<samples;i++)\n    {\n        color+=traceRay(ray);\n        seed +=1.1;\n    }\n    color/=float(samples);\n    \n    float white = 8.0;\n    color = (color * white * (1.0 + color / white))/(1.0 + color*white);\n    //vec3 sampleColor = texture(iChannel0,fragCoord.xy).rgb;\n    //color = mix(color,sampleColor,(1.0/float(seed)/10.0));\n    //color = mix(color,sampleColor,1.0);\n\treturn vec4(color, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy; \n    \n    vec4 color = texture(iChannel0, uv);\n    float white = 14.0;\n\tcolor *= white * 3.0;\n\tcolor = (color * (1.0 + color / white / white)) / (1.0 + color);\n    \n    fragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float MaxDistance = 99999.0;\nconst int MaxReflections = 4;\nconst float lightStrenth = 4.0;\nconst int samples = 4;\nconst float blur = 0.999;\n\nvec2 u_seed1;\nvec2 u_seed2;\n\nfloat seed;\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Box\n{\n    vec3 position;\n    float size;\n    vec4 color;\n};\n\nstruct Sphere\n{\n    vec3 position;\n    float radius;\n    vec4 color;\n};\n\nstruct Plane\n{\n    float position;\n    vec3 normal;\n    vec4 color;\n};\n\nstruct LightSource\n{\n    vec3 position;\n    float radius;\n};\n\nint LCGStep(int z, int A, int C)\n{\n\treturn (A * z + C);\t\n}\n\nvec2 hash22(vec2 p)\n{\n\tp += u_seed1.x;\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx+33.33);\n\treturn fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat random(vec2 co){\n    return fract(sin(dot(co * seed, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 randomOnSphere(Ray ray) {\n\tvec3 rand = vec3(\n    random(ray.direction.xy),\n    random(ray.direction.yz),\n    random(ray.direction.zx));\n\tfloat theta = rand.x * 2.0 * 3.14159265;\n\tfloat v = rand.y;\n\tfloat phi = acos(2.0 * v - 1.0);\n\tfloat r = pow(rand.z, 1.0 / 3.0);\n\tfloat x = r * sin(phi) * cos(theta);\n\tfloat y = r * sin(phi) * sin(theta);\n\tfloat z = r * cos(phi);\n\treturn vec3(x, y, z);\n}\n\nvec3 light = normalize(vec3(0.0, -1.0, 1.0));\n\nvec3 getSky(vec3 rd) {\n\tvec3 col = vec3(0.3, 0.6, 1.0);\n\tvec3 sun = vec3(0.95, 0.9, 1.0);\n\tsun *= max(0.0, pow(dot(rd, light), 256.0));\n\t//col *= max(0.0, pow(dot(rd, light), 256.0));\n    col *= pow(dot(rd * 2.0,vec3(0.0,1.0,0.0)),0.1);\n    //return vec3(0.0);\n\treturn clamp(sun+col,0.0,1.0);\n}\n\nfloat planeIntersect(Ray ray,Plane plane)\n{\n    return -(dot(ray.origin,plane.normal)+plane.position)/dot(ray.direction,plane.normal);\n}\n\nvec2 sphereIntersect(Ray ray, Sphere sphere)\n{\n    vec3 oc = ray.origin - sphere.position;\n    float b = dot( oc, ray.direction );\n    float c = dot( oc, oc ) - sphere.radius*sphere.radius;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0);\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nvec2 boxIntersection(Ray ray, Box box, out vec3 outNormal) \n{\n    ray.origin -= box.position;\n    vec3 m = 1.0/ray.direction; \n    vec3 n = m*ray.origin;   \n    vec3 k = abs(m)*box.size;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); \n    if (tN > 0.0)\n    {\n        outNormal = step(vec3(tN),t1);\n    }\n    else\n    {\n        outNormal = step(t2,vec3(tF));\n    }\n    outNormal *= -sign(ray.direction);\n    return vec2( tN, tF );\n}\n\nvec4 castRay(out Ray ray)\n{\n    vec2 minHitDistance = vec2(MaxDistance);\n    vec2 hitDistance = vec2(0.0);\n    vec4 color = vec4(1.0);\n    vec3 normal = vec3(0.0);\n    \n    Sphere sphere;\n    sphere.position =  vec3(7.0,6.0,2.0);\n    sphere.radius = 1.5;\n    sphere.color = vec4(1.0,1.0,1.0,-1.0);\n    \n    hitDistance = sphereIntersect(ray,sphere);\n    if (hitDistance.x > 0.0 && hitDistance.x < minHitDistance.x)\n    {\n        minHitDistance = hitDistance;      \n        normal = normalize((ray.origin + ray.direction * hitDistance.x) - sphere.position);\n        color = sphere.color;\n    }\n    \n    Sphere sphere2;\n    sphere2.position = vec3(-6.0,0.1,6.0);\n    sphere2.radius = 3.0;\n    sphere2.color = vec4(1.0,1.0,1.0,0.95);    \n    hitDistance = sphereIntersect(ray,sphere2);\n    if (hitDistance.x > 0.0 && hitDistance.x < minHitDistance.x)\n    {\n        minHitDistance = hitDistance;      \n        normal = normalize((ray.origin + ray.direction * hitDistance.x) - sphere2.position);\n        color = sphere2.color;\n    }\n    \n    Sphere sphere3;\n    sphere3.position = vec3(0.0,15.0,10.0);\n    sphere3.radius = 3.0;\n    sphere3.color = vec4(1.0,1.0,1.0,-3.0);    \n    hitDistance = sphereIntersect(ray,sphere3);\n    if (hitDistance.x > 0.0 && hitDistance.x < minHitDistance.x)\n    {\n        minHitDistance = hitDistance;      \n        normal = normalize((ray.origin + ray.direction * hitDistance.x) - sphere3.position);\n        color = sphere3.color;\n    }\n    \n    Plane plane;\n    plane.normal = vec3(0.0,1.0,0.0);\n    plane.position = 1.0;\n    plane.color = vec4(0.5,0.5,0.5,0.0);\n    hitDistance = vec2(planeIntersect(ray,plane));\n    if (hitDistance.x > 0.0 && hitDistance.x < minHitDistance.x)\n    {\n        minHitDistance = hitDistance;\n        normal = plane.normal;\n        color = plane.color;\n    }\n    \n    Plane plane2;\n    plane2.normal = vec3(-1.0,0.0,0.0);\n    plane2.position = 10.0;\n    plane2.color = vec4(1.0,0.1,0.1,0.0);\n    hitDistance = vec2(planeIntersect(ray,plane2));\n    if (hitDistance.x > 0.0 && hitDistance.x < minHitDistance.x)\n    {\n        minHitDistance = hitDistance;\n        normal = plane2.normal;\n        color = plane2.color;\n    }\n    \n    Plane plane3;\n    plane3.normal = vec3(1.0,0.0,0.0);\n    plane3.position = 10.0;\n    plane3.color = vec4(1.0,1.0,1.0,0.0);\n    hitDistance = vec2(planeIntersect(ray,plane3));\n    if (hitDistance.x > 0.0 && hitDistance.x < minHitDistance.x)\n    {\n        minHitDistance = hitDistance;\n        normal = plane3.normal;\n        color = plane3.color;\n    }\n    \n    Plane plane4;\n    plane4.normal = vec3(0.0,0.0,-1.0);\n    plane4.position = 10.0;\n    plane4.color = vec4(0.0,1.0,0.0,0.0);\n    hitDistance = vec2(planeIntersect(ray,plane4));\n    if (hitDistance.x > 0.0 && hitDistance.x < minHitDistance.x)\n    {\n        minHitDistance = hitDistance;\n        normal = plane4.normal;\n        color = plane4.color;\n    }\n    \n    Plane plane5;\n    plane5.normal = vec3(0.0,-1.0,0.0);\n    plane5.position = 15.0;\n    plane5.color = vec4(0.0,0.0,1.0,0.0);\n    hitDistance = vec2(planeIntersect(ray,plane5));\n    if (hitDistance.x > 0.0 && hitDistance.x < minHitDistance.x)\n    {\n        minHitDistance = hitDistance;\n        normal = plane5.normal;\n        color = plane5.color;\n    }\n    \n    Box box;\n    box.position = vec3(7.0,2.1,2.0);\n    box.size = 2.0;\n    box.color = vec4(0.0,1.0,0.0,0.0);\n    vec3 boxNormal = vec3(0.0);\n    hitDistance = boxIntersection(ray,box,boxNormal);\n    if (hitDistance.x > 0.0 && hitDistance.x < minHitDistance.x)\n    {\n        minHitDistance = hitDistance;\n        color = box.color;\n        normal = boxNormal;\n    }\n    if (minHitDistance.x == MaxDistance)\n    {\n        return vec4(getSky(ray.direction),-2.0);\n    }\n    if(color.a == -2.0) \n    {\n        return color;\n    }\n    vec3 reflected = reflect(ray.direction, normal);\n    if(color.a == -3.0)\n    {\n        \n        //float fresnel = 1.0 - abs(dot(ray.direction, normal));\n        //if (1.0/fresnel > 2.0) \n        //{\n        //    color.a = -2.0;\n        //    return color;\n        //}\n        //vec3 hitPosition = ray.origin + ray.direction * hitDistance.x;\n        //vec3 r = randomOnSphere(ray);\n        //vec3 diffuse = normalize(r * dot(r, normal));\n        //ray.origin += ray.direction * (minHitDistance.x - 0.0001);\n        //ray.direction = mix(diffuse, reflected, color.a);\n\t\treturn color;\n    }\n    if(color.a < 0.0) {\n\t\tfloat fresnel = 1.0 - abs(dot(ray.direction, normal));\n\t\tif(length(randomOnSphere(ray)) - 0.7 < pow(fresnel,5.4)) {\n\t\t\tray.direction = reflected;\n\t\t\treturn color * pow(fresnel+1.0,0.25);\n\t\t}\n\t\tray.origin += ray.direction * (minHitDistance.y + 0.0001);\n\t\tray.direction = refract(ray.direction, normal, 1.0 / (1.0 - color.a));\n\t    \n        return color;\n\t}\n    vec3 hitPosition = ray.origin + ray.direction * hitDistance.x;\n\tvec3 r = randomOnSphere(ray);\n\tvec3 diffuse = normalize(r * dot(r, normal));\n\tray.origin += ray.direction * (minHitDistance.x - 0.0001);\n\tray.direction = mix(diffuse, reflected, color.a);\n    return color;\n}\n\nvec3 traceRay(Ray ray) {\n\tvec3 color = vec3(1.0);\n\tfor(int i = 0; i < MaxReflections; i++)\n\t{\n\t\tvec4 reflectedColor = castRay(ray);\n\t\t\n\t\tif(reflectedColor.a == -2.0)\n        {\n            float a = 0.8;\n            color *= vec3(\n            pow(reflectedColor.r,a),\n            pow(reflectedColor.g,a),\n            pow(reflectedColor.b,a));\n            if (distance(color,vec3(1.0,1.0,1.0)) < 0.310009)\n            {\n                color = color * lightStrenth;\n            }\n            return color;\n        }\n        color *= reflectedColor.rgb;\n        if(reflectedColor.a == -3.0) \n        {\n           \n            return color * reflectedColor.rgb * lightStrenth;\n        }\n\t}\n\treturn vec3(0.0);\n}\n\nvec2 initUV(vec2 fragCoord)\n{\n    return (fragCoord-0.5*iResolution.xy)/iResolution.y;\n}\n\nuniform float accumulator;\n\nvec4 GetColor(vec4 fragColor, vec2 fragCoord )\n{\n    vec2 uv = initUV(fragCoord);\n    u_seed1 = vec2(0.0,1.0/iTime);\n    Ray ray;\n    ray.origin = vec3(-1.0,7.5,-15.0);\n    ray.direction = normalize(vec3(uv,1.0));\n    \n    seed = iTime;\n    vec3 r = randomOnSphere(ray);\n\tray.direction = normalize(mix(r, ray.direction, blur));\n    \n    \n    vec3 color = vec3(0.0);\n   \n    \n    for(int i = 0;i<samples;i++)\n    {\n        color+=traceRay(ray);\n        seed +=1.1;\n    }\n    color/=float(samples);\n    \n    float white = 8.0;\n    color = (color * white * (1.0 + color / white))/(1.0 + color*white);\n    \n    vec2 uv2 = fragCoord.xy / iResolution.xy;\n    color = mix(color,texture(iChannel0,uv2).rgb,0.5);\n    //vec3 sampleColor = texture(iChannel0,fragCoord.xy).rgb;\n    //color = mix(color,sampleColor,(1.0/float(seed)/10.0));\n    //color = mix(color,sampleColor,1.0);\n\treturn vec4(color, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = initUV(fragCoord);\n    u_seed1 = vec2(0.0,1.0/iTime);\n    Ray ray;\n    ray.origin = vec3(-1.0,7.5,-15.0);\n    ray.direction = normalize(vec3(uv,1.0));\n    \n    seed = iTime;\n    vec3 r = randomOnSphere(ray);\n\tray.direction = normalize(mix(r, ray.direction, blur));\n    \n    \n    vec3 color = vec3(0.0);\n   \n    \n    for(int i = 0;i<samples;i++)\n    {\n        color+=traceRay(ray);\n        seed +=1.1;\n    }\n    color/=float(samples);\n    \n    \n    vec2 uv2 = fragCoord.xy / iResolution.xy;\n    vec3 previousColor = texture(iChannel0,uv2).rgb;\n    if (iFrame > 0)\n    color = mix(previousColor,color,1.0/pow(float(iFrame),0.7));\n    //if (iFrame > 0)\n    //color = clamp(color+texture(iChannel0,uv2).rgb,0.0,1.0);\n    //vec3 sampleColor = texture(iChannel0,fragCoord.xy).rgb;\n    //color = mix(color,sampleColor,(1.0/float(seed)/10.0));\n    //color = mix(color,sampleColor,1.0);\n\tfragColor = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}