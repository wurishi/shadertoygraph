{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"/*///////////////////////////////////////////////////////////////////////////////\n Distance estimation for (very) simple IFS. by knighty (nov. 2013).\n \n Computing DE for IFS requires normally a priority list or at least a stack. (references later)\nIt happens that there is a correspondance between a n generators IFS and the base n representation\nof a number in [0,1[. That is there is a /bijection/(Edit: that is not true in the limit) between the IFS\nand the [0,1[ interval. So we can we call any IFS a CURVE?\n\n This fact is used here to discard whole subtrees in the evaluation of the DE.\n\n? This method could be used to compute distance to any curve provided we have a way to compute\na bounding volume to any segment of that curve (for example a curve is contained in the circle\nwhich radius is the length of that curve and centred at any point inside the curve).\nThis is the case of Bezier curves (obviously the length of it's skeleton).\n\n This method could be applied in principle to other IFS.\n\n For fragmentarium scripts see: \nhttp://www.fractalforums.com/ifs-iterated-function-systems/dragonkifs-promising-formula-but-help-needed/msg68853/#msg68853\n\n///////////////////////////////////////////////////////////////////////////////*/\n\n#define DEPTH 10\n#define ITER_NUM pow(2., float(DEPTH))\n\n//Bounding radius to bailout. must be >1. higher values -> more accurate but slower\n#define BR2BO 64.\nvec2 A = vec2( 1.);//Computed in main(). Stores the similarity of the transformation\nfloat scl = 1.414;//scale of the IFS. must be >1. Smaller values -> slower.\nfloat Findex=0.;//mapping of IFS point to [0,1[\nfloat minFindex=0.;//\nfloat BR=2.;//Computed in main(). Bounding circle radius. The smaller, the better (that is faster) but it have to cover the fractal\nfloat BO=16.;//Computed in main(). Bailout value. it should be = (BR*s)^2 where s>1. bigger s give more accurate results but is slower.\nfloat od=1000.;//computed object trap DE\nfloat otR;//=0.3*(sin(iTime*5.)+2.);//object trap is a disc with radius otR;\n//Complex multiplication\nvec2 Cmult(vec2 a, vec2 b){ return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);}\n\n//Original. very slow.\n/*float dragonSample1(vec2 p, float lastDist){\n\tfloat q=rnd;\n\tfloat d=length(p)-BR;\n\tfloat dd=1.;\n\tfor(int i=0; i<iterNum; i++){\n\t\tif(d>lastDist) break;//continue;//\n\t\tfloat sgn=2.*floor(q*2.)-1.; q=fract(q*2.);\n\t\tp=Cmult(A,p); p.x+=sgn;\n\t\tdd*=lA;\n\t\td=(length(p)-BR)/dd;\n\t}\n\trnd = fract( rnd + 1./256. );//fract( rnd * 8.13 );\n\treturn min(d,lastDist);\n}*/\n\n//Estimate the distance to the fractal by using a simple mathod\n//it gives the exact result when A is pure real or pure imaginary\nfloat dragonSampleEst(vec2 p){\n\tfloat dd=1.;\n\tfloat q=0.,j=1.;\n\tfor(int i=0; i<DEPTH; i++){\n\t\tif(dot(p,p)>BO) break;//continue;//\n\t\tp=Cmult(A,p);\n\t\tfloat l0=dot(p+vec2(1.,0.), p+vec2(1.,0.));\n\t\tfloat l1=dot(p-vec2(1.,0.), p-vec2(1.,0.));\n\t\tq*=2.;j*=0.5;\n\t\tif(min(l0,l1)==l0) {p.x+=1.; q+=1.;} \n\t\telse p.x-=1.;//select nearest branche\n\t\tdd*=scl;\n\t}\n\tminFindex=q*j;\n\tfloat d=(length(p)-BR)/dd;\n\treturn d;\n}\n\n//Computes distance to the point in the IFS which index is the current index.\n//lastDist is a given DE. If at some level the computed distance is bigger than lastDist\n//that means the current index point is not the nearest so we bail out and discard all\n//children of the current index point.\n//We also use a static Bail out value to speed things up a little while accepting less accurate DE.\nfloat dragonSample(vec2 p, float lastDist){\n\tfloat q=Findex;//Get the index of the current point\n\tfloat dd=1.;//running scale\n\tfloat j=ITER_NUM;\n\tfor(int i=0; i<DEPTH; i++){\n\t\tfloat temp=BR+lastDist*dd;//this id to avoid computing length (sqrt)\n\t\tfloat l2=dot(p,p);\n\t\tif(l2>0.0001+temp*temp || l2>BO) break;//continue;//continue is too slow here\n\t\t\n\t\t//get the sign of the translation from the binary representation of the index\n\t\tfloat sgn=2.*floor(q*2.)-1.; q=fract(q*2.); j*=.5;\n\t\t\n\t\tp=Cmult(A,p);//similarity\n\t\tp.x+=sgn;    //translation\n\t\tdd*=scl;\n\t}\n\t//update current index. it is not necessary to check the next j-1 points.\n\t//This is the main optimization\n\tFindex = ( Findex + j*1./ITER_NUM );\n\tfloat d=(length(p)-BR)/dd;//distance to current point\n\tif(d<lastDist) minFindex=Findex;\n\treturn min(d,lastDist);\n}\n\nfloat dragonSample1(vec2 p, float lastDist){\n\tfloat q=Findex;//Get the index of the current point\n\tfloat dd=1.;//running scale\n\tfloat d=(length(p)-BR);\n\tfloat j=ITER_NUM;\n\tfor(int i=0; i<DEPTH; i++){\n\t\t//float temp=BR+lastDist*dd;//this id to avoid computing length (sqrt)\n\t\tfloat l2=dot(p,p);\n\t\tif(d>0.0001+lastDist || l2>BO) break;//continue;//continue is too slow here\n\t\t\n\t\t//get the sign of the translation from the binary representation of the index\n\t\tfloat sgn=2.*floor(q*2.)-1.; q=fract(q*2.); j*=.5;\n\t\t\n\t\tp=Cmult(A,p);//similarity\n\t\tp.x+=sgn;    //translation\n\t\tdd*=scl;\n\t\td=(length(p)-BR)/dd;\n\t}\n\t//update current index. it is not necessary to check the next j-1 points.\n\t//This is the main optimization\n\tFindex = ( Findex + j*1./ITER_NUM );\n\t//float d=(length(p)-BR)/dd;//distance to current point\n\tif(d<lastDist) minFindex=Findex;\n\treturn min(d,lastDist);\n}\n\nfloat dragonSampleOT(vec2 p, float lastDist){\n\tfloat q=Findex;//Get the index of the current point\n\tfloat dd=1.;//running scale\n\tfloat d=(length(p)-BR);\n\tod=min(od,(length(p)-otR));//length(p)-0.33;\n\tfloat j=ITER_NUM;\n\tfor(int i=0; i<DEPTH; i++){\n\t\t//float temp=BR+lastDist*dd;//this is to avoid computing length (sqrt)\n\t\tfloat l2=dot(p,p);\n\t\tif(d>0.0001+lastDist || l2>BO) break;//continue;//\n\t\t\n\t\t//get the sign of the translation from the binary representation of the index\n\t\tfloat sgn=2.*floor(q*2.)-1.; q=fract(q*2.); j*=.5;\n\t\t\n\t\tp=Cmult(A,p);//similarity\n\t\tp.x+=sgn;    //translation\n\t\tdd*=scl;\n\t\td=(length(p)-BR)/dd;\n\t\tod=min(od,(length(p)-otR)/dd);//object trap. you could replace it with another shape. Just make it sure it fits inside bounding circle!\n\t}\n\tFindex = ( Findex + j*1./ITER_NUM );\n\t//float d=(length(p)-BR)/dd;//distance to current point\n\tif(d<lastDist) minFindex=Findex;\n\treturn min(d,lastDist);\n}\n\nfloat dragonSampleKali(vec2 p, float lastDist){\n\tfloat q=Findex;//Get the index of the current point\n\tfloat d=(length(p)-BR);\n\tfloat dd=1.;//running scale\n\tfloat j=ITER_NUM;\n\tfor(int i=0; i<DEPTH; i++){\n\t\tfloat l2=dot(p,p);\n\t\tif(d>lastDist || l2>BO) break;//continue;//continue is too slow here\n\t\t\n\t\t//get the sign of the translation from the binary representation of the index\n\t\tfloat sgn=2.*floor(q*2.)-1.; q=fract(q*2.); j*=.5;\n\t\t//float lp=(sgn*p.x+0.)/dd;\n\t\tp=Cmult(A,p);//similarity\n\t\tdd*=scl;\n\t\tfloat lp=(sgn*p.x-0.)/dd;\n\t\tp.x+=sgn;    //translation\n\t\t\n\t\td=max(d,max(lp,(length(p)-BR)/dd));\n\t}\n\t//update current index. it is not necessary to check the next j-1 points.\n\t//This is the main optimization\n\tFindex = ( Findex + j*1./ITER_NUM );\n\t//float d=(length(p)-BR)/dd;//distance to current point\n\treturn min(d,lastDist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\totR=0.3*(sin(iTime*5.)+2.);\n    //construct similarity using angle ang and scale scl\n\tfloat ang=0.1*iTime;\n\tA = scl*vec2(cos(ang), sin(ang));\n\t//compute bounding circle's radius. it's that simple :)\n\tBR=1./(scl-1.);\n\t//Compute bail out value\n\tBO=BR*BR*BR2BO;\n\t//coordinates of current pixel in object space. \n\tvec2 uv = 2.*BR *(fragCoord.xy-0.5*iResolution.xy) / iResolution.y;\n\t//Get an estimate. not necessary, but it's faster this way.\n\tfloat d=dragonSampleEst(uv);//1.;//0.01;//\n\t//refine the DE\n\tfor(int i=0; i<120; i++){//experiment: try other values\n\t// In principle max number of iteration should be ITER_NUM but we actually\n\t//do much less iterations. Maybe less than O(DEPTH^2). Depends also on scl.\n\t\td=dragonSampleOT(uv,d);\n\t\tif(Findex==1.) break;\n\t}\n\tif(mod(iTime,10.)<5.) d=od;//switch between regular IFS and object trap\n\tfragColor = vec4(pow(abs(d),0.33))*(0.9+0.1*sin(vec4(10.,6.5,3.25,1.)*minFindex));//\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dBGzm","date":"1393024478","viewed":651,"name":"DE for simple IFS","username":"knighty","description":"Distance estimate of a simple IFS. Fighting exponential growth. This shader works fine here with firefox. Does it work elsewhere?","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["ifs","de"],"hasliked":0,"parentid":"","parentname":""}}