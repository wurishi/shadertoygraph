{"ver":"0.1","info":{"id":"lsKfzV","date":"1529653204","viewed":133,"name":"projekt2-hda-dotgen","username":"schnaader","description":"Erzeugt ein gleichmäßiges Punktmuster mit möglichst unterschiedlichen Farben im HSV-Raum","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["pattern","generation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Konvertiert HSV in RGB, Quelle: https://www.laurivan.com/rgb-to-hsv-to-rgb-for-shaders/\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 count = vec2(10.0, 10.0); // Anzahl der Punkte in x, y\n    vec2 s = (1.0 / (count + 1.0)); // gleichmäßiger Abstand der Punkte in x, y\n    float r = 0.75; // Radius der Punkte 0 .. 1\n    \n    // Umrechnung des normierten Radius\n    r *= max(s.x, s.y) / 2.0;\n    \n    // Normalisierte Pixelkoordinaten 0 .. 1\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec4 white = vec4(1.0);\n        \n    fragColor = white;\n    \n    for (int i = 1; i <= int(count.x); i++) {\n      for (int j = 1; j <= int(count.y); j++) {\n          vec2 pos = s * vec2(i, j);\n          vec2 delta = uv - pos;\n          \n          // Erzeugt Kreise statt Ellipsen\n          delta.x /= iResolution.y / iResolution.x;\n          \n          float dist = length(delta);\n          if (dist <= r) { // Innerhalb des Kreises\n              float i_norm = float(i) / count.x;\n              float j_norm = (float(j) / count.y) / 2.0 + 0.5;\n              vec3 hsv = vec3(i_norm, j_norm, j_norm);\n              fragColor = vec4(hsv2rgb(hsv), 1.0);\n          }\n      }\n    }\n}","name":"Image","description":"","type":"image"}]}