{"ver":"0.1","info":{"id":"NdKcWm","date":"1654979713","viewed":98,"name":"RayTrace04","username":"alanza","description":"A fourth and most successful attempt at raytracing","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Triangle {\n    vec3 a;\n    vec3 b;\n    vec3 c;\n    vec4 color;\n};\n\nstruct Hit {\n    bool hit;\n    float dist;\n};\n\nstruct Ray {\n    vec3 point;\n    vec3 direction;\n};\n\nvec3 normalToPlane(in Triangle plane) {\n    return normalize(cross(plane.a - plane.b, plane.a - plane.c));\n}\n\nHit intersectPlane (in Ray ray, in Triangle plane) {\n    vec3 normal = normalToPlane(plane);\n    float dirdot = dot(ray.direction, normal);\n    if (dirdot == 0.0) {\n        return Hit(false,0.0);\n    } else {\n        float dist = (dot(plane.a - ray.point, normal)/dirdot);\n        if (dist <= 0.01) {\n            return Hit(false,0.0);\n        }\n        else return Hit(true, dist);\n    }\n}\n\nfloat angle (in vec3 center, in vec3 a, in vec3 b) {\n    return acos(dot(a - center, b - center)/(length(a - center)* length(b - center)));\n}\n\nHit intersectTriangle (in Ray ray, in Triangle triangle) {\n    Hit hit = intersectPlane(ray, triangle);\n    if (hit.hit == false) return hit;\n    else {\n        vec3 intersect = ray.point + hit.dist * ray.direction;\n        if (angle(triangle.a, intersect, triangle.b) < angle(triangle.a, triangle.c, triangle.b)\n            && angle(triangle.b, intersect, triangle.c) < angle(triangle.b, triangle.a, triangle.c)\n            && angle(triangle.c, intersect, triangle.a) < angle(triangle.c, triangle.b, triangle.a)) {\n            return hit;\n        } else return Hit(false,0.0);\n    }\n}\n\nstruct Light {\n    vec3 position;\n    float intensity;\n};\n\nstruct rayTraceData {\n    Ray ray;\n    vec4 color;\n    bool keepGoing;\n};\n\nvec3 toLight (in vec3 point, in Light light) {\n    return light.intensity * normalize(light.position - point);\n}\n\nTriangle triangles [8];\nTriangle planes [1];\nLight lights [3];\n\nrayTraceData rayTrace (in Ray ray) {\n    int mint = -1;\n    float dist;\n    for (int i = 0; i < triangles.length(); i++) {\n        Hit hit = intersectTriangle(ray, triangles[i]);\n        if ((hit.hit == true) && (mint == -1 || hit.dist < dist)) {\n            mint = i;\n            dist = hit.dist;\n        }\n    }\n    bool hitIsTriangle = true;\n    for (int i = 0; i < planes.length(); i++) {\n        Hit hit = intersectPlane(ray, planes[i]);\n        if ((hit.hit == true) && (mint == -1 || hit.dist < dist)) {\n            mint = i;\n            hitIsTriangle = false;\n            dist = hit.dist;\n        }\n    }\n    if (mint == -1) return rayTraceData(ray, vec4(0,0,0,1), false);\n    Ray new;\n    vec4 color;\n    if (hitIsTriangle) {\n        vec3 normal = normalToPlane(triangles[mint]);\n        vec3 hit = ray.point + dist * ray.direction;\n        new = Ray(hit, reflect(ray.direction, normal));\n        color = triangles[mint].color;\n    }\n    else {\n        vec3 normal = normalToPlane(planes[mint]);\n        vec3 hit = ray.point + dist * ray.direction;\n        new = Ray(hit, reflect(ray.direction, normal));\n        color = planes[mint].color;\n    }\n    vec3 col;\n    for (int i = 0; i < lights.length(); i++) {\n        Ray lightRay = Ray(new.point, normalize(toLight(new.point, lights[i])));\n        float shade = dot(toLight(new.point, lights[i]), new.direction);\n        bool obstructed = false;\n        for (int j = 0; j < triangles.length(); j++) {\n            obstructed = intersectTriangle(lightRay, triangles[j]).hit || obstructed;\n        }\n        for (int j = 0; j < planes.length(); j++) {\n            obstructed = intersectPlane(lightRay, planes[j]).hit || obstructed;\n        }\n        if (obstructed == false && shade <= 0.0) {\n            float r = distance(lights[i].position, new.point);\n            col = col + shade * shade * color.rgb / r / r;\n        }\n    }\n    return rayTraceData(new, vec4(col,1.0), true);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -.5 to 0.5)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n    vec3 camera = vec3(0,0,0);\n    Ray ray = Ray(camera, normalize(vec3(uv,1.0)));\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec4 color = vec4(col,1.0);\n    vec4 roloc = vec4(0.5 + 0.5*sin(iTime+uv.xyx+vec3(4,3,2)),1);\n    vec3 rotate = cos(2.0*iTime + vec3(1,3,5));\n    vec3 rotate2 = sin(3.0*iTime + vec3(5,3,1));\n    \n    vec3 i = vec3(2,2,18) + rotate;\n    vec3 j = vec3(-2,2,18) + rotate;\n    vec3 k = vec3(0,0,10) + rotate;\n    vec3 l = vec3(1,3,20) + rotate;\n    vec3 m = vec3(-4,0,13) + rotate2;\n    vec3 n = vec3(-1,0,10) + rotate2;\n    vec3 o = vec3(-4,1,13) + rotate2;\n    vec3 p = vec3(-2,1,15) + rotate2;\n    \n    triangles[0] = Triangle(i,j,k,color);\n    triangles[1] = Triangle(i,j,l,color);\n    triangles[2] = Triangle(i,k,l,color);\n    triangles[3] = Triangle(j,k,l,color);\n    triangles[4] = Triangle(m,n,o,roloc);\n    triangles[5] = Triangle(m,n,p,roloc);\n    triangles[6] = Triangle(m,o,p,roloc);\n    triangles[7] = Triangle(n,o,p,roloc);\n    \n    planes[0] = Triangle(vec3(0,-1,1),vec3(-1,-1,0),vec3(1,-1,0),vec4(0.125,0.125,0.125,1));\n    \n    lights[0] = Light(vec3(-3,4,2),20.0);\n    lights[1] = Light(vec3(0,0,-4),10.0);\n    lights[2] = Light(vec3(2,2,1),20.0);\n    \n    fragColor = vec4(0,0,0,1);\n   \n    for (int i = 0; i <5; i++) {\n        rayTraceData data = rayTrace(ray);\n        fragColor = fragColor + data.color;\n        ray = data.ray;\n        if (data.keepGoing == false) break;\n    }\n}","name":"Image","description":"","type":"image"}]}