{"ver":"0.1","info":{"id":"Ds2BW3","date":"1690368252","viewed":104,"name":"Space Curvature Simulation","username":"HyperPoss","description":"This shader is my small experiment about space curvature, I want to look how different shapes look with coordinates curvature.\n\nIt's my almost first project in GLSL, please, only soft and good criticism)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["simulation","x","y","curvature","spacecurvature"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Draw Space Curvature Lines?\n#define Space_Curvature_Lines\n\n// Draw Shape: \n// 0 - None, 1 - Circle, 2 - Square, 3 - Triangle.\n#define Shape 1\n\n// Try Different Space Curvature (1 or 2), you can add new, XD:\n#define variant 1\n\n// Position of camera.\n\n#if(variant == 1)\n    vec2 cameraPos = vec2(0.75, -1.0);\n#elif(variant == 2)\n    vec2 cameraPos = vec2(0.0, 0.0);\n#endif\n\n#define AA_UNIT ( 8./iResolution.y )\n#define SMAA(d) ( smoothstep(AA_UNIT, 0., d) )\n#define THICKNESS ( 0.04 )\nfloat y_axis(vec2 uv) { return SMAA(abs(uv.x)); }\nfloat x_axis(vec2 uv) { return SMAA(abs(uv.y)); }\nfloat vertical_line(vec2 uv, float x0) { return SMAA(abs(uv.x-x0)-THICKNESS); }\nfloat horizontal_line(vec2 uv, float y0) { return SMAA(abs(uv.y-y0)-THICKNESS); }\nfloat cells(vec2 uv)\n{\n    uv = fract(uv);\n    uv = fract(min(uv, 1. - uv));\n    return\n        min(vertical_line(uv, 0.), horizontal_line(uv, 0.)) +\n        max(vertical_line(uv, 0.), horizontal_line(uv, 0.));\n}\n\nfloat square( vec2 p)\n{\n    vec2 d = abs(p)- vec2(0.8);\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat triangle( vec2 p )\n{\n    const float k = sqrt(3.0);\n    const float r = 0.8;\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // Shift pixels using camera pos\n    uv += cameraPos;\n    // Space Curvature Code, any coordinates changes.\n    // Here can be many variants at once, for example:\n    #if(variant == 1)\n        uv.x += sin(uv.y * (iTime / 10.));\n        uv.y += cos(uv.x * (iTime / 10.));\n    #elif(variant == 2)\n        float tempX = uv.x;\n        uv.x += sin(uv.y * (iTime / 10.));\n        uv.y += sin(tempX * (iTime / 10.));\n    #endif\n    \n    // Set Color (X - Red, Y - Green.)\n    vec3 col = vec3(abs(uv.xy), 0.0);\n    \n    // Drawing Shape\n    #if (Shape == 1)\n        col = mix(col, vec3(1), SMAA(length(uv)-0.8));\n    #elif(Shape == 2)\n        col = mix(col, vec3(1), SMAA(square(uv)));\n    #elif(Shape == 3)\n        col = mix(col, vec3(1), SMAA(triangle(uv)));\n    #endif\n        \n    // Draw Space Curvature Lines if needed\n    #if defined(Space_Curvature_Lines)\n        col = mix(col, vec3(0), cells(uv*10.));\n        col = mix(col, vec3(0,0,1), max(x_axis(uv), y_axis(uv)));\n    #endif\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Original Code.\n\n\n\n/*\n// Draw Space Curvature Lines?\n#define Space_Curvature_Lines\n\n// Draw Shape: \n// 0 - None, 1 - Circle, 2 - Square, 3 - Triangle.\n#define Shape 1\n\n// Position of camera.\nvec2 cameraPos = vec2(0.75, -1.0);\n//vec2 cameraPos = vec2(0.0, 0.0);\n\nbool drawSpaceCurvature( vec2 uv )\n{\n    // Horizontal Lines\n    if(mod(abs(uv.x), 0.1) < 0.013) {\n        return true;\n    }\n    \n    // Vertical Lines\n    if(mod(abs(uv.y), 0.1) < 0.013) {\n        return true;\n    }\n    \n    return false;\n}\n\nbool square( vec2 p)\n\n{\n\n    vec2 d = abs(p)- vec2(0.8);\n\n    float result = length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n    if(result < 0.0) {\n        return true;\n    }\n    return false;\n}\n\nbool triangle( vec2 p )\n{\n    const float k = sqrt(3.0);\n    const float r = 0.8;\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    float result = -length(p)*sign(p.y);\n    if(result < 0.0) {\n        return true;\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Shift pixels using camera pos\n    uv += cameraPos;\n    //Space Curvature Code, any coordinates changes, for example:\n    uv.x += sin(uv.y * (iTime / 10.));\n    uv.y += cos(uv.x * (iTime / 10.));\n    \n    // Set Color (X - Red, Y - Green.)\n    vec3 col = vec3(abs(uv.xy), 0.0);\n    \n    // Drawing Shape\n    #if (Shape == 1)\n        if(length(uv) < 0.8)\n            col = vec3(1.0);\n    #elif(Shape == 2)\n        if(square(uv)) {\n            col = vec3(1.0);\n        }\n    #elif(Shape == 3)\n        if(triangle(uv)) {\n            col = vec3(1.0);\n        }\n    #endif\n        \n    // Draw Space Curvature Lines if needed\n    #if defined(Space_Curvature_Lines)\n        if(drawSpaceCurvature(uv)) col = vec3(0.0);\n    #endif\n    \n\n\n    fragColor = vec4(col, 1.0);\n}\n*/","name":"Common","description":"","type":"common"}]}