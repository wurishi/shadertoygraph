{"ver":"0.1","info":{"id":"MltyR8","date":"1531577535","viewed":1215,"name":"Smooth iteration count","username":"darkeclipz","description":"Currently trying to implement a smooth iteration count (http://iquilezles.org/articles/mset_smooth/mset_smooth.htm).","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// resources:\n// - https://iquilezles.org/articles/msetsmooth\n// - http://colorpalettes.net/color-palette-3885/\n\n// Color palettes\nstruct palette {\n    vec3 c0, c1, c2, c3, c4;\n};\n\npalette palette1() {\n    palette p;\n    p.c0 = vec3(0);\n    p.c1 = vec3(190,220,227)/255.;\n    p.c2 = vec3(243,243,246)/255.;\n    p.c3 = vec3(227,220,213)/255.;\n    p.c4 = vec3(218,112, 21)/255.;\n    return p;\n}\n\npalette palette2() {\n    palette p; p.c0 = vec3(0,2,5)/255.;\n    p.c1 = vec3(8,45,58)/255.;\n    p.c2 = vec3(38,116,145)/255.;\n    p.c3 = vec3(167,184,181)/255.;\n    p.c4 = vec3(207,197,188)/255.;\n    return p;    \n}\n\n// Complex math\n\nvec2 cpow ( vec2 z ) { return mat2(z, -z.y, z.x) * z; }\n//vec2 cmul( vec2 z1, vec2 z2 ) { return vec2( z1.x*z2.x -z1.y*z2.y, 2.*z1.x*z1.y ); } + z2.x*z2.y :/\n//vec2 cmul( vec2 z1, vec2 z2 ) { return mat2(z2, -z2.y, z2.x) * z1; }\nvec2 cmul( vec2 z1, vec2 z2 ) { return mat2(z1, -z1.y, z1.x) * z2; }\n\n/* missed one iter\nvec2 cpown (vec2 z, int n) {\n    mat2 m = mat2(z, -z.y, z.x);\n    for(int i=0; i<n;++i) \n    \tz *= m;\n   \treturn z;\n}*/\nvec2 cpown (vec2 z, int n) {\n    mat2 m = mat2(z, -z.y, z.x);\n    for(;--n>0;) z *= m;\n   \treturn z;\n}\n\nfloat cmod( vec2 z ) {\n\t//return ri.x * ri.x + ri.y * ri.y;    \n    return dot(z,z);\n}\n\n// Mapping\n\n#define ZOOM\nvec2 map ( vec2 uv ) {\n    #ifdef ZOOM\n    return 1./exp(mod(iTime/2.,80.))*uv;\n    #else\n\treturn 2.*uv;\n    #endif\n}\n\nvec3 cmap( float t, palette p ) {\n    //t=fract(t);\n    vec3 col = vec3(0);\n    col = mix( p.c0,  p.c1, smoothstep(0. , .2, t));\n    col = mix( col, p.c2, smoothstep(.2, .4 , t));\n    col = mix( col, p.c3, smoothstep(.4 , .6, t));\n    col = mix( col, p.c4, smoothstep(.6,  .8, t));\n    col = mix( col, vec3(0), smoothstep(.8, 1.,  t));\n    return col;\n}\n\n\n// Polynomials\n\nvec2 fMandelbrot( vec2 z, vec2 c) { return cpow(z) + c; }\nvec2 fCPoly1 ( vec2 z, vec2 c ) { return cpown(z,11) + cmul((vec2(1.,0.)-c),cpown(z,5)) + cmul((c+1.+vec2(0,1)),z) + c; }\nvec2 fCPoly2 ( vec2 z, vec2 c ) { return cpown(z,5) + cmul((vec2(1.,0.)-c),cpown(z,3)) + cmul((c+1.+vec2(0,1)),z) + c; }\n\n//Display the color map.\n//#define CMAP\n#define ROTATE\n\n// Main\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    palette p = palette2(); // palette1\n    #ifdef CMAP\n    fragColor = vec4(cmap(fragCoord.x/iResolution.x, p), 1.); return; \n    #endif\n    \n    float t = iTime/4.;\n    vec2 R = iResolution.xy;\n    vec2 uv = (2.*fragCoord-R)/iResolution.y;\n    \n    #ifdef ROTATE\n    float angle = -2.*t;\n    mat2 rot = mat2(cos(angle),sin(angle),-sin(angle),cos(angle));\n    uv*=rot;\n    #endif\n    \n\tvec3 col = vec3(0);\n    vec2 z = vec2(0);\n    vec2 c = map(uv);\n    float n = 0.;\n    float threshold = 4.;\n    float maxIter = 200.;\n    \n    for(; n++ < maxIter ;) {\n        z = fCPoly1(z,c);\n        if(cmod(z) > threshold) break;\n    }\n    \n    fragColor = vec4(cmap( fract(-log(log(dot(z,z))/log(11.))/log(11.) + t), p ),1.0);\n}","name":"Image","description":"","type":"image"}]}