{"ver":"0.1","info":{"id":"7dccDj","date":"1654184585","viewed":230,"name":"Progressive PathTracer 3 by Omni","username":"Omniscience","description":"WASD/RF/QE/mouselook controls.\nVastly fixes lighting model, gaussian noise quality and correctness, and continues to unify traditional spec/diff components into a single gaussian probability distribution. thx to ShnitzelKiller for better noise functions.","likes":7,"published":1,"flags":48,"usePreview":0,"tags":["gi","raytrace","pathtrace","bdrf","flycam"],"hasliked":0,"parentid":"NdcyDj","parentname":"Progressive PathTracer 2 by Omni"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 kres = 1.0 / iResolution.xy;\n    vec4 samples = texture(iChannel0, fragCoord * kres);\n    \n    fragColor = vec4(samples.xyz, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define BW_NOT(x)        (0xffffffffU - (x))\n#define BIT_GET(x, n)    (0x1U & ((x) >> n))\n#define BIT_SET(x, n, v) x = (x & BW_NOT(0x1U << n)) | (v << n)\n\n#define GET_FLAG(x, n)    bool(BIT_GET(x, n))\n#define SET_FLAG(x, n, v) BIT_SET(x, n, uint(v))\n\nconst float EPSILON = 0.0001;\nconst float PI = 3.141592653589793238462643327950;\nconst float TWO_PI = PI * 2.0;\nconst float PI_BY_TWO = PI / 2.0;\nconst float PI_BY_90 = PI / 90.0;\nconst float DEG_TO_RAD = PI / 180.0;\nconst vec3 FWD = vec3(0.0, 0.0, 1.0);\nconst vec3 UP = vec3(0.0, 1.0, 0.0);\nconst vec3 RIGHT = vec3(1.0, 0.0, 0.0);\nconst vec3 ZERO3 = vec3(0.0, 0.0, 0.0);\nconst vec3 ONE3 = vec3(1.0, 1.0, 1.0);\n\nuvec4 vec4BitsToUvec4(vec4 v) {\n    return uvec4(\n        floatBitsToUint(v.x),\n        floatBitsToUint(v.y),\n        floatBitsToUint(v.z),\n        floatBitsToUint(v.w)\n    );\n}\nvec4 uvec4BitsToVec4(uvec4 v) {\n    return vec4(\n        uintBitsToFloat(v.x),\n        uintBitsToFloat(v.y),\n        uintBitsToFloat(v.z),\n        uintBitsToFloat(v.w)\n    );\n}\n\nfloat lerp(float a, float b, float x) { return a + (b-a) * x; }\nvec3 lerp(vec3 a, vec3 b, float x) { return a + (b-a) * x; }\n\nfloat unmix(float y0, float y1, float y) { return (y-y0)/(y1-y0); }\nvec3 unmix(vec3 y0, vec3 y1, vec3 y) { return (y-y0)/(y1-y0); }\n\nfloat remix(float x0, float x1, float x, float y0, float y1) { return mix(y0, y1, unmix(x0, x1, x)); }\nvec3 remix(vec3 x0, vec3 x1, vec3 x, vec3 y0, vec3 y1) { return mix(y0, y1, unmix(x0, x1, x)); }\nvec3 remix(float x0, float x1, float x, vec3 y0, vec3 y1) { return mix(y0, y1, unmix(x0, x1, x)); }\n\nmat4 identity() {\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\nmat4 scale(vec3 s) {\n    return mat4(\n        s.x, 0.0, 0.0, 0.0,\n        0.0, s.y, 0.0, 0.0,\n        0.0, 0.0, s.z, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\nmat4 translate(vec3 pos) {\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        pos.x, pos.y, pos.z, 1.0\n    );\n}\nmat4 rotateX(float t) {\n    float s = sin(t);\n    float c = cos(t);\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0,   c,   s, 0.0,\n        0.0,  -s,   c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\nmat4 rotateY(float t) {\n    float s = sin(t);\n    float c = cos(t);\n    return mat4(\n          c, 0.0,  -s, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n          s, 0.0,   c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\nmat4 rotateZ(float t) {\n    float s = sin(t);\n    float c = cos(t);\n    return mat4(\n          c,   s, 0.0, 0.0,\n         -s,   c, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 matrixFromQuat(vec4 q) {\n    float x = q.x, y = q.y, z = q.z, w = q.w;\n    float x2 = x*x, y2 = y*y, z2 = z*z;\n    \n    float xy = x*y, xz = x*z, yz = y*z,\n          xw = x*w, yw = y*w, zw = z*w;\n    \n    return identity() + 2.0 * mat4(\n        -(y2 + z2),  (xy + zw),  (xz - yw), 0.0,\n         (xy - zw), -(x2 + z2),  (yz + xw), 0.0,\n         (xz + yw),  (yz - xw), -(x2 + y2), 0.0,\n               0.0,        0.0,        0.0, 0.0\n    );\n}\n\nvec4 quatConjugate(vec4 q) {\n    return vec4(-q.xyz, q.w);\n}\n\nvec4 qmul(vec4 a, vec4 b) {\n    float ax = a.x, ay = a.y, az = a.z, aw = a.w;\n    float bx = b.x, by = b.y, bz = b.z, bw = b.w;\n    return vec4(\n        aw*bx + ax*bw + ay*bz - az*by,\n        aw*by + ay*bw + az*bx - ax*bz,\n        aw*bz + az*bw + ax*by - ay*bx,\n        aw*bw - ax*bx - ay*by - az*bz\n    );\n}\n\nvec3 qmulv(vec4 q, vec3 v) {\n    vec4 vq = vec4(v, 0.0);\n    vec4 c = quatConjugate(q);\n    q = qmul(q, vq);\n    q = qmul(q, c);\n    return q.xyz;\n}\nvec4 qmulv(vec4 q, vec4 v) {\n    return vec4(qmulv(q, v.xyz), v.w);\n}\n\nvec4 quatFromAxisAngle(vec3 axis, float angle) {\n    angle *= 0.5;\n    float sa = sin(angle);\n    float ca = cos(angle);\n    return vec4(\n        axis.x * sa,\n        axis.y * sa,\n        axis.z * sa,\n        ca\n    );\n}\n\nvec4 quatFromEulerDeg(vec3 euler) {\n    float ex = euler.x, ey = euler.y, ez = euler.z;\n    float ep = ex * PI_BY_90,\n          eq = ey * PI_BY_90,\n          er = ez * PI_BY_90,\n        sinp = sin(ep),\n        siny = sin(eq),\n        sinr = sin(er),\n        cosp = cos(ep),\n        cosy = cos(eq),\n        cosr = cos(er);\n    vec4 q = vec4(\n        sinr * cosp * cosy - cosr * sinp * siny,\n        cosr * sinp * cosy + sinr * cosp * siny,\n        cosr * cosp * siny - sinr * sinp * cosy,\n        cosr * cosp * cosy + sinr * sinp * siny\n    );\n    return normalize(q);\n}\n\nvec4 quatBetweenTwoVecs(vec3 a, vec3 b) {\n    float dp = dot(a, b);\n    if (dp == 1.0) return vec4(0.0, 0.0, 0.0, 1.0);\n    vec3 c = RIGHT;\n    if (dp == -1.0) c = cross(a, b);\n    float amag2 = dot(a, a);\n    float bmag2 = dot(b, b);\n    return normalize(vec4(c, sqrt(amag2 + bmag2) + dp));\n}\n\nvec4 quatBetweenTwoNorms(vec3 a, vec3 b) {\n    float dp = dot(a, b);\n    if (dp == 1.0) return vec4(0.0, 0.0, 0.0, 1.0);\n    vec3 c = RIGHT;\n    if (dp != -1.0) c = cross(a, b);\n    return normalize(vec4(c, 1.0 + dp));\n}\n\nstruct Transform {\n    vec3 pos;\n    vec4 rot;\n};\n\nTransform t_identity() {\n    return Transform(ZERO3, vec4(0.0, 0.0, 0.0, 1.0));\n}\n\nmat4 matrixFromTransform(Transform xform) {\n    mat4 m = identity();\n    m *= translate(xform.pos);\n    m *= matrixFromQuat(xform.rot);\n    return m;\n}\n\n// wang_hash, GetRandom(), randnorm() lifted from https://www.shadertoy.com/view/wlsyRN\n// thanks, ShnitzelKiller\nuint wgSeed;\nvoid wang_seed(float seed) {\n    wgSeed = uint(seed * 4294967296.0);\n}\nuint wang_hash() {\n    wgSeed = uint(wgSeed ^ uint(61)) ^ uint(wgSeed >> uint(16));\n    wgSeed *= uint(9);\n    wgSeed = wgSeed ^ (wgSeed >> 4);\n    wgSeed *= uint(0x27d4eb2d);\n    wgSeed = wgSeed ^ (wgSeed >> 15);\n    return wgSeed;\n}\nfloat GetRandom() {\n    return float(wang_hash()) / 4294967296.0;\n}\n// My own trig hashes\n/*\nconst vec4 gSeed = vec4(12.9898, 77.233, 14.66337, 23.53277);\nfloat hash(float p) { return fract(sin(p * gSeed.x)*43758.5453123); }\nfloat hash(vec2 p) { return fract(sin(dot(p, gSeed.xy))*43758.5453123); }\nvec2 hash2(vec2 p) { return fract(sin(p * gSeed.xy)*43758.5453123); }\n*/\n\nfloat hash() { return GetRandom(); }\nvec2 hash2() { return vec2(GetRandom(), GetRandom()); }\nvec3 hash3() { return vec3(GetRandom(), GetRandom(), GetRandom()); }\n\nvec2 rand2() {\n    return hash2();\n}\nvec3 rand3() {\n    return hash3();\n}\n\nfloat stdNormDistPositive(float x) {\n    return sqrt(-2.0 * log(max(x, EPSILON)));\n}\nfloat normDistPositive(float x, float std) {\n    return std * stdNormDistPositive(x);\n}\nfloat stdNormDist(float x) {\n    if (x < 0.0) return -stdNormDistPositive(-x);\n    return stdNormDistPositive(x);\n}\nfloat normDist(float x, float std) {\n    return std * stdNormDist(x);\n}\nvec2 randBoxMuller(vec2 U) {\n    float r = normDistPositive(U.x, EPSILON);\n    float t = 2.0 * PI * U.y;\n    return vec2(\n        r*cos(t),\n        r*sin(t)\n    );\n}\n\nvec3 randnorm() {\n    vec2 utheta = hash2() * 2. - 1.;\n    utheta.y *= PI;\n    float rho = sqrt(1.-utheta.x * utheta.x);\n    return vec3(cos(utheta.y)*rho, sin(utheta.y)*rho, utheta.x);\n}\n\nvec3 gaussUpHemisphere(float std) {\n    float t = hash() * TWO_PI - PI;\n    float r = std * clamp(normDistPositive(hash(), std), -TWO_PI, TWO_PI);\n    \n    // TODO: why does this work? shouldn't we need [-pi/2, pi/2] for a hemisphere?\n    r = fract(r+0.5) - 0.5; //[-0.5, 0.5]\n    r *= TWO_PI;            //[-pi, pi]\n    \n    vec3 right = vec3(cos(t), 0.0, -sin(t));\n    return qmulv(quatFromAxisAngle(right, r), UP);\n}\n\nvec3 gaussHemisphere(vec3 fwd, float std) {\n    vec3 v = gaussUpHemisphere(std);\n    vec4 q = quatBetweenTwoNorms(UP, fwd);\n    return qmulv(q, v);\n}\n\nvec3 gaussReflect(vec3 v, vec3 n, float std) {\n    vec3 rIdeal = reflect(v, n);\n    vec3 rRand = gaussHemisphere(rIdeal, std);\n    if (dot(rRand, n) < 0.0)\n        rRand = reflect(rRand, n);\n    return rRand;\n}\n\nvec3 heatMap(float x) {\n    if (x < 0.25) return remix(0.0 , 0.25, x, vec3(0.0, 0.0, 0.125), vec3(0.0, 0.0, 1.0));\n    if (x < 0.5)  return remix(0.25, 0.5,  x, vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 0.0));\n    if (x < 0.75) return remix(0.5 , 0.75, x, vec3(0.0, 1.0, 0.0), vec3(1.0, 1.0, 0.0));\n    if (x < 1.0)  return remix(0.75, 1.0,  x, vec3(1.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0));\n    return vec3(1.0, 0.0, 0.0);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define STATE_LENGTH   5.0\n#define STATE_LENGTH_I 5\n\n#define STATE_FLAGS 0.5\n#define STATE_POS   1.5\n#define STATE_ROT   2.5\n#define STATE_VEL   3.5\n#define STATE_MOUSE 4.5\n\n#define STATE_FLAGS_I 0\n#define STATE_POS_I   1\n#define STATE_ROT_I   2\n#define STATE_VEL_I   3\n#define STATE_MOUSE_I 4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 kres = 1.0 / iResolution.xy;\n    vec2 uvi = fragCoord;\n    vec2 uv = uvi * kres;\n    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    if (uvi.y < 1.0 && uvi.x < STATE_LENGTH) {\n        vec4 state[] = vec4[] (\n            texture(iChannel0, vec2(0.5, 0.5) * kres),\n            texture(iChannel0, vec2(1.5, 0.5) * kres),\n            texture(iChannel0, vec2(2.5, 0.5) * kres),\n            texture(iChannel0, vec2(3.5, 0.5) * kres),\n            texture(iChannel0, vec2(4.5, 0.5) * kres)\n        );\n        \n        vec4 flags = state[STATE_FLAGS_I];\n        \n        // Catch initial load and set default values\n        if (flags.x == 0.0) {\n            flags.x = 1.0;\n            state[STATE_POS_I] = vec4(-2.0, 5.0, 12.0, 0.0);\n            state[STATE_ROT_I] = qmul(\n                quatFromAxisAngle(UP, 170.0 * DEG_TO_RAD),\n                quatFromAxisAngle(RIGHT, 20.0 * DEG_TO_RAD)\n            );\n        }\n        \n        // Controls\n        vec4 kbW = texture(iChannel1, vec2(87.0/256.0, 0.0));\n        vec4 kbA = texture(iChannel1, vec2(65.0/256.0, 0.0));\n        vec4 kbS = texture(iChannel1, vec2(83.0/256.0, 0.0));\n        vec4 kbD = texture(iChannel1, vec2(68.0/256.0, 0.0));\n        vec4 kbR = texture(iChannel1, vec2(82.0/256.0, 0.0));\n        vec4 kbF = texture(iChannel1, vec2(70.0/256.0, 0.0));\n        vec4 kbQ = texture(iChannel1, vec2(81.0/256.0, 0.0));\n        vec4 kbE = texture(iChannel1, vec2(69.0/256.0, 0.0));\n        \n        vec4 prevMouse = state[STATE_MOUSE_I];\n        state[STATE_MOUSE_I] = iMouse;\n        if (prevMouse.z != iMouse.z)\n            prevMouse = iMouse;\n        vec4 dMouse = iMouse - prevMouse;\n        \n        vec2 sensitivity = vec2(2.5, 2.5);\n        \n        // Rotation\n        float roll = (kbQ.x - kbE.x) * 0.02;\n        vec2 mouse_norm = dMouse.xy * kres * sensitivity;\n        vec3 angles = vec3(-mouse_norm.y, mouse_norm.x, roll);\n        \n        vec4 rot = state[STATE_ROT_I];\n        rot = qmul(rot, quatFromAxisAngle(FWD, angles.z));\n        rot = qmul(rot, quatFromAxisAngle(UP, angles.y));\n        rot = qmul(rot, quatFromAxisAngle(RIGHT, angles.x));\n        \n        state[STATE_ROT_I] = normalize(rot);\n        \n        // Translation\n        vec4 velocity = state[STATE_VEL_I];\n        \n        vec4 accel = vec4(kbD.x - kbA.x, kbR.x - kbF.x, kbW.x - kbS.x, 0.0);\n        accel *= 0.0125;\n        accel = qmulv(rot, accel);\n        \n        velocity += accel;\n        velocity *= 0.875;\n        if (dot(velocity, velocity) < 0.00001)\n            velocity.xyz = ZERO3;\n        \n        state[STATE_VEL_I] = velocity;\n        state[STATE_POS_I] += velocity;\n        \n        // Moving flag\n        if (dot(dMouse,dMouse) > 0.0 || dot(velocity,velocity) > 0.0 || dot(angles,angles) > 0.0)\n            flags.y = 1.0;\n        else\n            flags.y = 0.0;;\n        \n        state[STATE_FLAGS_I] = flags;\n        \n        // Write\n        color = state[int(uvi.x - 0.5)];\n    }\n    \n    fragColor = color;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Material {\n    vec3 albedo;\n    vec3 emission;\n    float roughness;\n    float metallic;\n    float ior;\n};\n\n#define mtlBasic(col, r)         Material(col, ZERO3, r, 1.0-r, 1.5)\n#define mtlBasic2(col, r, m)     Material(col, ZERO3, r, m, 1.5)\n#define mtlBasic3(col, r, m, ir) Material(col, ZERO3, r, m, ir)\n#define mtlEmissive(emission)    Material(ZERO3, emission, 1.0, 0.0, 1.0)\n\nstruct AABB {\n    vec3 p0;\n    vec3 p1;\n    Material material;\n};\nstruct Sphere {\n    vec3 position;\n    float radius;\n    Material material;\n};\n\nstruct Contact {\n    bool hit;\n    vec3 position;\n    vec3 normal;\n    Material material;\n};\n\nstruct Sample {\n    vec3 light;\n    Contact contact;\n    int depth;\n};\n\n// Settings\n\nconst int MAX_DEPTH = 6;\nconst float SUPERSAMPLE_POS_STD = 0.001;\nconst float SUPERSAMPLE_DIR_STD = 0.01;\nconst float EXPOSURE = 600000.0;\nconst float K_SHUTTER = 1.0 / EXPOSURE;\nconst bool DBG_SHOW_BOUNCES = false;\n\n// Materials\n\nconst Material mtl_chk_black  = mtlBasic2(vec3(0.125).xxx, 0.25, 0.625);\nconst Material mtl_chk_white  = mtlBasic2(vec3(0.875).xxx, 0.375, 0.625);\n//const Material mtl_chk_black  = mtlBasic2(vec3(0.125).xxx, 0.95, 0.0);\n//const Material mtl_chk_white  = mtlBasic2(vec3(0.875).xxx, 0.95, 0.0);\nconst Material mtl_atmosphere = mtlEmissive(vec3(0.5,0.75,1.0) * 1.5);\nconst Material mtl_sun        = mtlEmissive(vec3(1.0,0.75,0.5) * 100.0);\n\nconst Material mtl_matte_white = mtlBasic(vec3(1.0, 1.0, 1.0), 1.0);\nconst Material mtl_matte_black = mtlBasic(vec3(0.0, 0.0, 0.0), 1.0);\nconst Material mtl_default_wall = mtl_matte_white;\nconst Material mtl_left_wall = mtlBasic(vec3(1.0, 0.25, 0.25), 1.0);\nconst Material mtl_right_wall = mtlBasic(vec3(0.25, 0.25, 1.0), 1.0);\n\nconst Material mtl_background = mtlBasic2(ZERO3, 0.0, 0.0);\nconst Contact NO_CONTACT = Contact(false, ZERO3, ZERO3, mtl_background);\n\n// Scene\n\nconst bool USE_FLOOR = true;\nconst bool USE_ATMOSPHERE = true;\nconst bool USE_SUNLIGHT = true;\nconst bool USE_ENVMAP = false;\n\nvec3 SUN_DIR = normalize(vec3(1.0, 1.0, 1.0));\n\nconst int NUM_AABBS = 4;\n\nconst vec3 ext = vec3(4.0, 6.0, 5.0);\nconst float thk = 0.5;\nconst float raise = 0.0;\n// top, back, front, left, right\nconst AABB aabbs[] = AABB[](\n    AABB(vec3(-ext.x-thk, ext.y+raise, -ext.z), vec3(ext.x+thk, ext.y+thk+raise, ext.z     ), mtl_default_wall),\n    AABB(vec3(-ext.x    , 0.0        , -ext.z), vec3(ext.x    , ext.y          , -ext.z+thk), mtl_default_wall),\n    //AABB(vec3(-ext.x    , 0.0     , ext.z-thk), vec3(ext.x    , ext.y          , ext.z     ), mtl_default_wall),\n    AABB(vec3(-ext.x-thk, 0.0        , -ext.z), vec3(-ext.x   , ext.y          , ext.z     ), mtl_left_wall),\n    AABB(vec3(ext.x     , 0.0        , -ext.z), vec3(ext.x+thk, ext.y          , ext.z     ), mtl_right_wall)\n);\n\nconst int NUM_SPHERES = 10;\n\nconst float _m = 0.0;\nconst float _M = 1.0;\nconst vec3 _c = vec3(1.0, 1.0, 0.0);\nconst float _ior = 1.5;\nconst Sphere spheres[] = Sphere[](\n    //Sphere(vec3(1.0, 0.5, 1.0)*1000.0, 100.0, Material(ZERO3, mtl_sun.emission, 1.0, 0.0, 1.5)),\n    Sphere(vec3(0.0, 4.0, 0.0), 1.0, Material(ZERO3, mtl_sun.emission*0.04, 1.0, 0.0, 1.5)),\n    Sphere(vec3(-2.5, 1.0, -2.5), 1.0, mtlBasic3(_c, _m, _m, _ior)),\n    Sphere(vec3(0.0,  1.0, -2.5), 1.0, mtlBasic3(_c, _m, 0.5, _ior)),\n    Sphere(vec3(2.5,  1.0, -2.5), 1.0, mtlBasic3(_c, _m, _M, _ior)),\n    Sphere(vec3(-2.5, 1.0, 0.0), 1.0, mtlBasic3(_c, 0.5, _m, _ior)),\n    Sphere(vec3(0.0,  1.0, 0.0), 1.0, mtlBasic3(_c, 0.5, 0.5, _ior)),\n    Sphere(vec3(2.5,  1.0, 0.0), 1.0, mtlBasic3(_c, 0.5, _M, _ior)),\n    Sphere(vec3(-2.5, 1.0, 2.5), 1.0, mtlBasic3(_c, _M, _m, _ior)),\n    Sphere(vec3(0.0,  1.0, 2.5), 1.0, mtlBasic3(_c, _M, 0.5, _ior)),\n    Sphere(vec3(2.5,  1.0, 2.5), 1.0, mtlBasic3(_c, _M, _M, _ior))\n);\n\n// Functions\n\nContact rayAABBContact(Ray ray, AABB aabb) {\n    vec3 O = ray.pos;\n    vec3 D = ray.dir;\n    \n    vec3 minB = aabb.p0;\n    vec3 maxB = aabb.p1;\n    vec3 maxT = vec3(-1.0).xxx;\n    vec3 coord = ZERO3;\n    vec3 norm = ZERO3;\n    bvec3 inside = bvec3(true, true, true);\n    \n    if (O.x < minB.x) { coord.x = minB.x; norm.x = -1.0; inside.x = false; }\n    if (O.x > maxB.x) { coord.x = maxB.x; norm.x = 1.0; inside.x = false; }\n    if (O.y < minB.y) { coord.y = minB.y; norm.y = -1.0; inside.y = false; }\n    if (O.y > maxB.y) { coord.y = maxB.y; norm.y = 1.0; inside.y = false; }\n    if (O.z < minB.z) { coord.z = minB.z; norm.z = -1.0; inside.z = false; }\n    if (O.z > maxB.z) { coord.z = maxB.z; norm.z = 1.0; inside.z = false; }\n    \n    if (inside.x && inside.y && inside.z)\n        return NO_CONTACT;\n    \n    if (!inside.x && D.x != 0.0) maxT.x = (coord.x - O.x) / D.x; else maxT.x = -1.0;\n    if (!inside.y && D.y != 0.0) maxT.y = (coord.y - O.y) / D.y; else maxT.y = -1.0;\n    if (!inside.z && D.z != 0.0) maxT.z = (coord.z - O.z) / D.z; else maxT.z = -1.0;\n    \n    int tBestAxis = 0;\n    float tBest = -1.0;\n    \n    if (maxT.x > tBest) { tBestAxis = 0; tBest = maxT.x; }\n    if (maxT.y > tBest) { tBestAxis = 1; tBest = maxT.y; }\n    if (maxT.z > tBest) { tBestAxis = 2; tBest = maxT.z; }\n    \n    if (tBest < 0.0)\n        return NO_CONTACT;\n    \n    if (tBestAxis != 0) {\n        norm.x = 0.0;\n        coord.x = O.x + tBest * D.x;\n        if (coord.x < minB.x || coord.x > maxB.x)\n            return NO_CONTACT;\n    }\n    if (tBestAxis != 1) {\n        norm.y = 0.0;\n        coord.y = O.y + tBest * D.y;\n        if (coord.y < minB.y || coord.y > maxB.y)\n            return NO_CONTACT;\n    }\n    if (tBestAxis != 2) {\n        norm.z = 0.0;\n        coord.z = O.z + tBest * D.z;\n        if (coord.z < minB.z || coord.z > maxB.z)\n            return NO_CONTACT;\n    }\n    \n    return Contact(true, coord, norm, aabb.material);\n}\n\nContact raySphereContact(Ray ray, Sphere sphere) {\n    vec3 O = ray.pos;\n    vec3 D = ray.dir;\n    vec3 C = sphere.position;\n    float r = sphere.radius;\n    float r2 = r*r;\n    vec3 L = C - O;\n    \n    float tca = dot(L, D);\n    //if (tca < 0.0) return NO_CONTACT;\n    \n    float d2 = dot(L, L) - tca*tca;\n    if (d2 > r2) return NO_CONTACT;\n    \n    float thc = sqrt(r2 - d2);\n    float t0 = min(tca - thc, tca + thc);\n    if (t0 < 0.0) return NO_CONTACT;\n    \n    vec3 P = O + t0 * D;\n    \n    return Contact(true, P, normalize(P - C), sphere.material);\n}\n\nContact rayFloorContact(Ray ray) {\n    vec3 O = ray.pos;\n    vec3 D = ray.dir;\n    if (D.y < 0.0 && O.y > 0.0) {\n        float y = O.y;\n        float aspect = y / D.y;\n        float h = -1.0 * aspect;\n        vec3 P = O + D * h;\n\n        Material mat = mtl_chk_black;\n        bool bx = fract(P.x * 0.5) < 0.5;\n        bool bz = fract(P.z * 0.5) < 0.5;\n        if (bx ^^ bz) mat = mtl_chk_white;\n        \n        return Contact(true, P, UP, mat);\n    }\n    return NO_CONTACT;\n}\n\nfloat genSeed(float x, vec3 c) { return x + fract(sin(dot(c,c))) + fract(sin(iTime/100.0)); }\n\nContact sampleRayOnce(Ray ray) {\n    Contact best = NO_CONTACT;\n    float bestDist = 0.0;\n    \n    for (int i=0; i<NUM_AABBS; ++i) {\n        AABB aabb = aabbs[i];\n        Contact contact = rayAABBContact(ray, aabb);\n        if (contact.hit) {\n            float d = distance(ray.pos, contact.position);\n            if (!best.hit || d < bestDist) {\n                best = contact;\n                bestDist = d;\n            }\n        }\n    }\n    \n    for (int i=0; i<NUM_SPHERES; ++i) {\n        Sphere sphere = spheres[i];\n        Contact contact = raySphereContact(ray, sphere);\n        if (contact.hit) {\n            float d = distance(ray.pos, contact.position);\n            if (!best.hit || d < bestDist) {\n                best = contact;\n                bestDist = d;\n            }\n        }\n    }\n\n    if (USE_FLOOR) {\n        Contact contact = rayFloorContact(ray);\n        if (contact.hit) {\n            float d = distance(ray.pos, contact.position);\n            if (!best.hit || d < bestDist) {\n                best = contact;\n                bestDist = d;\n            }\n        }\n    }\n    \n    if (!best.hit) {\n        vec3 emit = ZERO3;\n        if (USE_ENVMAP) {\n            emit += texture(iChannel1, ray.dir).xyz;\n        }\n        if (USE_ATMOSPHERE) {\n            emit += mtl_atmosphere.emission * lerp(0.5, 1.0, pow(1.0 - abs(ray.dir.y), 2.0));\n        }\n        if (USE_SUNLIGHT) {\n            emit += mtl_sun.emission * pow(clamp(dot(ray.dir, SUN_DIR), 0.0, 1.0), 256.0);\n        }\n        emit = pow(emit, vec3(1.0)) * 1.0;\n        best.material.emission = emit;\n    }\n    \n    return best;\n}\n\nfloat fresnelApprox(float ior, vec3 incident, vec3 normal) {\n    float F0 = abs((1.0 - ior) / (1.0 + ior));\n    F0 *= F0;\n\n    float dp = clamp(-dot(incident, normal), 0.0, 1.0);\n    float kFresnel = pow(1.0 - dp, 5.0);\n    float fresnel = F0 + (1.0 - F0) * kFresnel;\n    return fresnel;\n}\n\nSample sampleRay(Ray ray) {\n    Contact firstContact = NO_CONTACT;\n    vec3 light = ZERO3;\n    vec3 absorbtion = ONE3;\n    int depth = 0;\n    \n    for (depth=0; depth<MAX_DEPTH; ++depth) {\n        Contact contact = sampleRayOnce(ray);\n        Material mtl = contact.material;\n        \n        if (depth == 0) firstContact = contact;\n        \n        if (contact.hit) {\n            vec3 D = ray.dir;\n            vec3 P = contact.position;\n            vec3 N = contact.normal;\n            \n            float fresnel = fresnelApprox(mtl.ior, D, N);\n            float kRough = (1.0 - fresnel);\n            \n            float roughness = mtl.roughness;\n            roughness *= roughness * kRough;\n            \n            float pAbsorb = (roughness + (1.0 - mtl.metallic)) / 2.0;\n            \n            float kAbsorb = hash();\n            if (kAbsorb > pAbsorb) kAbsorb = 0.0; else kAbsorb = 1.0;\n            float kReflect = 1.0 - kAbsorb;\n            \n            roughness = mix(roughness, 1.0, kAbsorb);\n            \n            vec3 idealRef = reflect(D, N);\n            vec3 ref = gaussReflect(D, N, roughness);\n            ray = Ray(P, ref);\n            \n            vec3 absFilter = mix(mtl.albedo, ONE3, kReflect);\n            \n            light += mtl.emission * kRough * absorbtion;\n            absorbtion *= absFilter;\n        }\n        else {\n            light += mtl.emission * absorbtion;\n            break;\n        }\n    }\n    \n    return Sample(light, firstContact, depth-1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    wgSeed = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    \n    vec2 kres = 1.0 / iResolution.xy;\n    \n    vec4 state[] = vec4[] (\n        texture(iChannel0, vec2(0.5, 0.5) * kres),\n        texture(iChannel0, vec2(1.5, 0.5) * kres),\n        texture(iChannel0, vec2(2.5, 0.5) * kres)\n    );\n    vec4 flags = state[0];\n    bool moving = flags.y != 0.0;\n    Transform xform = Transform(state[1].xyz, state[2]);\n    mat4 view = matrixFromTransform(xform);\n    \n    /*vec4 test = vec4(0.124781, -68.3158, 1295.351, 0.0051);\n    uvec4 utest = vec4BitsToUvec4(test);\n    uvec4 utestOrig = utest;\n    bool pass = uvec4BitsToVec4(utest) != test;\n    \n    SET_FLAG(utest.x, 3, true);\n    pass = utest.x == utestOrig.x;\n    pass = bool(1U) == true && bool(0U) == false && uint(true) == 1U && uint(false) == 0U;\n    \n    if (pass) fragColor = vec4(0.0,1.0,0.0,1.0);\n    else fragColor = vec4(1.0,0.0,0.0,1.0);\n    return;*/\n    \n    float aspectRatio = iResolution.x / iResolution.y;\n    vec4 screenPos = vec4(-1.0 + 2.0 * fragCoord * kres, 0.0, 1.0);\n    screenPos.x *= aspectRatio;\n    \n    vec4 rayPos = view * vec4(ZERO3, 1.0);\n    vec3 rayDir = normalize(vec3(screenPos.xy, 2.0));\n    \n    rayPos.xyz += randnorm() * normDistPositive(hash(), SUPERSAMPLE_POS_STD);\n    rayDir = gaussHemisphere(rayDir, SUPERSAMPLE_DIR_STD);\n    \n    rayDir = mat3(view) * rayDir;\n    Ray ray = Ray(rayPos.xyz, rayDir);\n    \n    Sample raySample = sampleRay(ray);\n    Contact contact = raySample.contact;\n    \n    vec4 prevColor = texture(iChannel3, fragCoord * kres);\n    vec3 nextColor = raySample.light;\n    \n    if (DBG_SHOW_BOUNCES)\n        nextColor = heatMap(float(raySample.depth) / float(MAX_DEPTH-1));\n    \n    const float minWeight = K_SHUTTER;\n    float w = 1.0;\n    \n    if (moving) prevColor.w = 1.0;\n    \n    if (prevColor.w > 0.0) {\n        w = 1.0 / (1.0 / prevColor.w + 1.0);\n        w = clamp(w, minWeight, 1.0);\n    }\n    \n    nextColor *= w;\n    nextColor += (1.0 - w) * prevColor.xyz;\n    \n    fragColor = vec4(nextColor, w);\n}","name":"Buffer B","description":"","type":"buffer"}]}