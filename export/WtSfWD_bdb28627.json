{"ver":"0.1","info":{"id":"WtSfWD","date":"1598984575","viewed":782,"name":"Raymarch Optimization","username":"davisgamdev","description":"Optimized raymarch with depth of field blurring. Prepass (BufferA) does a quick distance check over a reduced version of the raymarch shader (BufferB). Selectively renders and blurs based on BufferA calculations.","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["raymarch","blur","bokeh","depthoffield","optimization","gaussian"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n\tsize: max ring radius\n\tquality: number of rings\n\tringSamples: number of samples collected on each ring\n*/\n\nconst float SampleSize = 10.;\n\nconst float GaussianDepth = 2.;\nconst float GaussianRingSamples = 12.;\n\n\nconst float BlurTileDist = 5.;\nconst float BokehMult = 2.25; // max gaussian radius\nconst float GammaAdjust = 0.03;\n\n// roughly supports a guassian size up to 8 with sample size 10\n// blur dist 1-10\n\n#define TAU 6.28318530718\n\n\n\nvec4 RotateBlur(vec2 fragCoord, float GaussianSize) {\n    \n    const float total = GaussianDepth * GaussianRingSamples;\n    \n    vec2 uvCoord = fragCoord/iResolution.xy;\n    vec4 avgs = texture(iChannel1, uvCoord);\n  \n    // start larger, otherwise we tend to miss an angle\n    //\t(it looked like a small gap at a big enough bokeh)\n    float angle = TAU/GaussianRingSamples;\n    \n    vec2 radStep = GaussianSize/iResolution.xy;\n    vec2 rad = radStep;\n    \n    vec2 uvOffset = vec2(0.);\n    \n    \n    for(float i = 0.; i < total; ++i) {\n        \n        uvOffset = vec2(cos(angle), sin(angle)) * rad;\n      \n        \n        avgs += texture(iChannel1, uvCoord + uvOffset);\n        \n        \n        // we wrap to zero if we're bigger than 2PI\n        angle += (-TAU * float(angle > TAU));\n        \n        // otherwise we add\n        angle += (TAU/GaussianRingSamples);\n        \n        // we increment if we went full circle\n        rad += float(angle > TAU) * (radStep);\n    }\n    \n    \n    // tiny adjust seems to fix it, weird \n    // needs adjust based on effect amount\n    return avgs / total - GammaAdjust;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    \n    //fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy); return;\n    \n    // tl;dr, we need to adjust for how far to look based on what the max radius of\n        // blur effect is\n    \n    vec2 floorst = floor(fragCoord/SampleSize) * SampleSize;\n    \n    //float nearDist = texture(iChannel0, floorst/iResolution.xy);\n    \n    \n    // take a step back;\n    vec2 currentTile = floorst - vec2(SampleSize * floor(BlurTileDist/2.));\n    \n    float bokehAcc = 0.;\n    float bokehCount = 1.;\n    \n    // this should unroll\n    // we need to check additional tiles to prevent hard edges on smoothing\n    for(float i = 0.; i < pow(BlurTileDist, 2.); ++i) {\n     \tvec2 offset = vec2(mod(i, BlurTileDist), floor(i / BlurTileDist)) * SampleSize;\n        vec4 color = texture(iChannel0, (currentTile + offset)/iResolution.xy);\n        \n        // format :vec4(1.0, 0.0, bokeh, 1.);\n        // if no data 0\n        \n        // TODO lerp distances, prevent flickering on ball interference\n        \n        bokehAcc += color.b;//smoothstep(color.b, nearDist, length();\n        bokehCount += float(color.a > 0.0);\n    }\n    \n    // this tile nor nearest have any data, no blur pass (just the background in most cases\n    if(bokehCount <= 1.) {\n        fragColor = texture(iChannel1, fragCoord/iResolution.xy);\n        return;\n    }\n    \n    \n    \n    \n   \n    float bokehDist = bokehAcc/bokehCount;\n    \n    \n    vec4 color = RotateBlur(fragCoord, mix(0., 8., bokehDist * BokehMult));\n    \n    //vec4 color = texture(iChannel1, fragCoord/iResolution.xy);\n  \n    \n    fragColor = vec4(color.xyz, 1.);\n    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_STEPS 15\n#define MIN 1.\n#define MAX 100.\n#define EPSILON 0.1\n#define SMOOTHFACTOR 0.5\n#define NUM_SPHERES 100\n// REDUCED ARGS FROM FULL SHADER\n\n\nconst vec3 Eye = vec3(0., 0., -15.);\nconst float Radius = 0.1;\n\nconst float BokehStart = 10.;\nconst float BokehEnd = 20.;\nconst float BokehAdjust = 1.5;\n\n\nconst float SampleSize = 10.;\n\n// MUST BE 0 IN BUFFER\nconst vec4 BackgroundColor = vec4(0.);\n\n\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvec4 getSphere(int num) {\n\n    float time = iTime/5. + float(num);\n    float constRandom = rand(vec2(float(num), float(num) + 7.));\n    \n    float rStep = 1.;\n    \n    vec3 sizePos = vec3(\n        sin(time + constRandom) + 1., \n        cos(time + constRandom * rStep++) + 1., \n        sin(time + constRandom * rStep++) + 1.) * 2.;\n        \n    sizePos *= sin(time + constRandom * rStep++) - .5;\n    sizePos.x += float(NUM_SPHERES - NUM_SPHERES/2)/100.;\n    sizePos.y  = sizePos.y * 0.8 + 0.3;\n    \n    sizePos.z *= 2.;\n\n    return vec4(sizePos, 1.);\n        \n}\n\n\n\nfloat SmoothMinSDF( float a, float b, float smoothFactor )\n{\n    float h = max( smoothFactor-abs(a-b), 0.0 )/smoothFactor;\n    return min( a, b ) - h*h*h*smoothFactor*(1.0/6.0);\n}\n\n\nfloat SphereSDF(vec3 point, float rad) {\n    return length(point) - rad;\n}\n\n\n\nfloat SceneSDF(vec3 point) {\n\n    float dist = SphereSDF(point + getSphere(0).xyz, Radius);\n    \n    for(int i = 1; i < NUM_SPHERES; ++i) {\n        vec4 sphere = getSphere(i);\n        float distA = SphereSDF(point + sphere.xyz, Radius);\n        dist = SmoothMinSDF(dist, distA, sphere.a * SMOOTHFACTOR);\n    }\n\n    return dist;\n}\n\n\n\n/** Helpers */\n\n// Gets the direction vector from the eye point for a resolved pixel\nvec3 GetRayDirection(float fov, vec2 res, vec2 fragCoord) {\n    vec2 xy = fragCoord - res/2.;\n    float z = res.y / tan(radians(fov/2.));\n    return normalize(vec3(xy, -z));\n}\n\n\n/**\n * Calculates a transformation matrix for world coordinates\n */\nmat4 GetViewMatrix(vec3 eye, vec3 center, vec3 up) {\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.),\n\t\tvec4(u, 0.),\n\t\tvec4(-f, 0.),\n\t\tvec4(0., 0., 0., 1.)\n\t);\n}\n\n\nfloat March(vec3 eye, vec3 dir, float start, float end) {\n    \n\tfloat depth = start;\n   \n    int i = 0;\n    do {\n\n     \tfloat dist = SceneSDF(eye + depth * dir);\n        \n        if(dist < EPSILON) return depth;\n        \n        depth += dist;\n        \n        if(depth >= end) return end;\n\n    }\n    while(i++ < MAX_STEPS);\n\n    return end;\n}\n    \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    float isZero = floor(mod(fragCoord.x, SampleSize)) + floor(mod(fragCoord.y, SampleSize));\n\n    if( isZero != 0.) {\n     \tfragColor = vec4(0.);\n        return;\n    }\n    \n    vec3 viewDir = GetRayDirection(45., iResolution.xy, fragCoord);\n    \n    mat4 worldViewMatrix = GetViewMatrix(Eye, vec3(0.), vec3(0., 1., 0.));\n    vec3 worldDir = (worldViewMatrix * vec4(viewDir, 0.)).xyz;\n \n    \n    float dist = March(Eye, worldDir, MIN, MAX);\n    \n    if(dist > MAX - EPSILON) {\n        fragColor = BackgroundColor;\n        return;\n    }\n    \n    float bokeh = ((dist - BokehStart)/(BokehEnd - BokehStart)) * BokehAdjust;\n   \n    fragColor = vec4(1.0, 0.0, bokeh, 1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n// These values are incredibly exaggerated\n//\tUncommenting the selective rendering logic shows\n//\tjust how slow these values are when loops aren't optimized\n\n#define MAX_STEPS 300\n#define MIN 1.\n#define MAX 1000.\n#define EPSILON 0.001\n#define SMOOTHFACTOR 0.5\n\n#define NUM_SPHERES 100\n\n\nconst float SampleSize = 10.;\nconst vec4 BackgroundColor = vec4(0.7);\n\n\nconst vec3 Eye = vec3(0., 0., -15.);\nconst float Radius = 0.1;\n\n\nconst vec3 AmbientColor = vec3(1.);\nconst vec3 AmbientIntensity = vec3(0.4);\n\n\nconst vec3 DirectionLightPosition = vec3(0., 10., -10.);\nconst vec3 DirectionLightColor = vec3(1.);\nconst float DirectionLightIntensity = 1.;\n\n\n\nconst vec3 ObjectSpecularColor = vec3(1.);\nconst float ObjectSpecularIntensity = 30.;\n\n\nconst vec4 RGB = vec4(vec3(256.), 1.);\n//const vec4 GradientColorStep1 = vec4(1., 0., 0., 1000.);\nconst vec4 GradientColorStep1 = vec4(64, 31, 62, 1.)/RGB;\nconst vec4 GradientColorStep2 = vec4(69, 63, 120, 2.)/RGB;\nconst vec4 GradientColorStep3 = vec4(117, 154, 171, 3.5)/RGB;\nconst vec4 GradientColorStep4 = vec4(250, 242, 161, 5.)/RGB;\n\n\n\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvec4 getSphere(int num) {\n\n    float time = iTime/5. + float(num);\n    float constRandom = rand(vec2(float(num), float(num) + 7.));\n    \n    float rStep = 1.;\n    \n    vec3 sizePos = vec3(\n        sin(time + constRandom) + 1., \n        cos(time + constRandom * rStep++) + 1., \n        sin(time + constRandom * rStep++) + 1.) * 2.;\n        \n    sizePos *= sin(time + constRandom * rStep++) - .5;\n    sizePos.x += float(NUM_SPHERES - NUM_SPHERES/2)/100.;\n    sizePos.y  = sizePos.y * 0.8 + 0.3;\n\n    sizePos.z *= 2.;\n\n    return vec4(sizePos, 1.);\n        \n}\n\n\n\n\n// end uniforms\n\n\n/** Lighting */\n\nconst vec3 AmbientLight = AmbientColor * AmbientIntensity;\nconst vec3 DirectionLight = DirectionLightColor * DirectionLightIntensity;\n\n\n\n// polynomial smooth min (k = 0.1);\nfloat SmoothMinSDF( float a, float b, float smoothFactor )\n{\n    float h = max( smoothFactor-abs(a-b), 0.0 )/smoothFactor;\n    return min( a, b ) - h*h*h*smoothFactor*(1.0/6.0);\n}\n\n\n\n/** Primitive SDF Functions */\nfloat SphereSDF(vec3 point, float rad) {\n    return length(point) - rad;\n}\n\n\n\n\n/** Full Scene Intersect */\nfloat SceneSDF(vec3 point) {\n\n    float dist = SphereSDF(point + getSphere(0).xyz, Radius);\n\n    for(int i = 1; i < NUM_SPHERES; ++i) {\n        vec4 sphere = getSphere(i);\n        float distA = SphereSDF(point + sphere.xyz, Radius);\n        dist = SmoothMinSDF(dist, distA, sphere.a * SMOOTHFACTOR);\n    }\n\n    return dist;\n}\n\n\n\nvec3 GetRayDirection(float fov, vec2 res, vec2 fragCoord) {\n    vec2 xy = fragCoord - res/2.;\n    float z = res.y / tan(radians(fov/2.));\n    return normalize(vec3(xy, -z));\n}\n\n\n// better normal https://iquilezles.org/articles/normalsSDF\nvec3 EstimateNormal(vec3 p) {\n\n    #define ZERO (min(iFrame,0)) // non-constant zero\n    \n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy * SceneSDF( p + k.xyy * EPSILON ) + \n                      k.yyx * SceneSDF( p + k.yyx * EPSILON ) + \n                      k.yxy * SceneSDF( p + k.yxy * EPSILON ) + \n                      k.xxx * SceneSDF( p + k.xxx * EPSILON ) );\n}\n\n\n\nmat4 GetViewMatrix(vec3 eye, vec3 center, vec3 up) {\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.),\n\t\tvec4(u, 0.),\n\t\tvec4(-f, 0.),\n\t\tvec4(0., 0., 0., 1.)\n\t);\n}\n\n\n\nvec3 BlinnPhongLighting(\n    vec3 point,\n    vec3 eye,\n    vec3 N,\n    vec3 ambient,\n    vec3 diffuse,\n    vec3 specular,\n    float specularAlpha\n){\n    vec3 L = normalize(DirectionLightPosition);\n    vec3 V = normalize(eye - point);\n    vec3 H = normalize(L + V);\n\n    float dotNH = clamp(dot(N, H), 0., 1.);\n    float dotNL = clamp(dot(N, L), 0., 1.);\n\n\n    vec3 ambientColor = diffuse * AmbientLight;\n    vec3 diffColor = dotNL * diffuse;\n    vec3 specColor = pow(dotNH, specularAlpha) * specular;\n\n    return ambientColor + (DirectionLight * (diffColor + specColor));\n}\n\n\n\nvec3 mixGrad(vec4 grad1, vec4 grad2, float l) {\n    return mix(grad1, grad2, (l - grad1.a)/(grad2.a - grad1.a)).xyz;\n}\n\n\nvec3 GetDiffuseColor(float l) {\n\n    bvec4 dist = lessThan(\n        vec4(l), \n        vec4(\n            GradientColorStep1.a,\n            GradientColorStep2.a,\n            GradientColorStep3.a,\n            GradientColorStep4.a\n        ));\n\n    if(dist.x) return GradientColorStep1.xyz;\n    else if(dist.y) return mixGrad(GradientColorStep1, GradientColorStep2, l);\n    else if (dist.z) return mixGrad(GradientColorStep2, GradientColorStep3, l);\n    else if(dist.a) return mixGrad(GradientColorStep3, GradientColorStep4, l);\n    else return GradientColorStep4.xyz;\n}\n\n\n\n\n/** Ray March function */\n/**\n * eye: point on view plane, origin of ray\n * dir: direction of ray, normalized\n * start: start distance from eye (march forward)\n * end: max distance before ending (do we need this?)\n*/\nfloat March(vec3 eye, vec3 dir, float start, float end) {\n    \n\tfloat depth = start;\n    \n    int i = 0;\n    do {\n\n        // check against scene\n     \tfloat dist = SceneSDF(eye + depth * dir);\n        \n        // smol distance, we found a hit\n        if(dist < EPSILON) return depth;\n        \n        // incr\n        depth += dist;\n        \n        // too big, hit the void\n        if(depth >= end) return end;\n\n    }\n    while(i++ < MAX_STEPS);\n\n    return end;\n}\n    \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // Uncomment below to test BufferA\n    //fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy); return;\n    \n    vec2 nearest = floor(fragCoord/SampleSize) * SampleSize;\n    \n    vec4 distColor = texture(iChannel0, nearest.xy/iResolution.xy);\n    distColor += texture(iChannel0, (nearest.xy + vec2(SampleSize))/iResolution.xy);\n    distColor += texture(iChannel0, (nearest.xy + vec2(SampleSize, 0.))/iResolution.xy);\n\tdistColor += texture(iChannel0, (nearest.xy + vec2(0., SampleSize))/iResolution.xy);\n\n    // Comment out below to cancel optimizations\n    if(length(distColor.xyz) <= 0.1) {\n        // make this slightly darker so it's obvious\n     \tfragColor = BackgroundColor;// + 0.05;   \n        return;\n    }\n    \n    vec3 viewDir = GetRayDirection(45., iResolution.xy, fragCoord);\n    \n    // rotate scene a bit\n    mat4 worldViewMatrix = GetViewMatrix(Eye, vec3(0.), vec3(0., 1., 0.));\n    vec3 worldDir = (worldViewMatrix * vec4(viewDir, 0.)).xyz;\n    \n    \n    float dist = March(Eye, worldDir, MIN, MAX);\n    \n    if(dist > MAX - EPSILON) {\n        fragColor = BackgroundColor;\n        return;\n        \n    }\n    \n    vec3 surfacePoint = Eye + dist * worldDir;\n\n\n    vec3 ObjectDiffuseColor = GetDiffuseColor(length(surfacePoint));\n\n    \n    vec3 surfaceColor = BlinnPhongLighting(\n       \t\tsurfacePoint,\n        \tEye,\n        \tEstimateNormal(surfacePoint),\n        \tAmbientLight,\n        \tObjectDiffuseColor,\n        \tObjectSpecularColor,\n        \tObjectSpecularIntensity);\n        \n    \n    fragColor = vec4(surfaceColor, 1.);\n    \n\n}","name":"Buffer B","description":"","type":"buffer"}]}