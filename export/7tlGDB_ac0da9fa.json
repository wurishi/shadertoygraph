{"ver":"0.1","info":{"id":"7tlGDB","date":"1622806107","viewed":89,"name":"simple RayTracing","username":"yunhai","description":"my try for a simple ray tracing demo :)\n","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","try"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI=3.14159265;\nconst float MaxDist=100.;\nconst float MinDist=1e-5;\n\nconst int times=4;//ray jump times\nconst float AirRef=1.;//air refraction\nstruct Ray\n{\n    vec3 o;\n    vec3 d;\n}; \nstruct Hit\n{\n    int id;\n    float dis;\n    vec3 pos;\n    vec3 nml;\n    float ref;//refraction\n    bool isIn;//hit from innner\n};\nstruct Cam\n{\n    vec3 pos;\n    vec3 lookat;\n    vec3 f;\n    vec3 r;\n    vec3 u;\n}cam;\nstruct RayIntersection\n{\n    float t;\n    bool isIn;\n};\nstruct RayGroup\n{\n    Ray rr,gr,br;\n};\nvoid setCam(vec3 pos,vec3 lookat)\n{\n    cam.pos=pos;\n    cam.lookat=lookat;\n    cam.f=normalize(lookat-pos);\n    cam.r=cross(vec3(0,1,0),cam.f);\n    cam.u=cross(cam.f,cam.r);\n}\nRay getRay(vec2 uv){return Ray(cam.pos,normalize(uv.x*cam.r+uv.y*cam.u+cam.f));}\nfloat dot2(vec3 v){return dot(v,v);}\n\n//search for a intersection\nRayIntersection isphere(Ray r,vec4 s)\n{\n    RayIntersection sec=RayIntersection(MaxDist,false);\n    vec3 co=r.o-s.xyz;\n    float a=dot2(r.d);\n    float b=2.*dot(co,r.d);\n    float c=dot2(co)-s.w*s.w;\n    float delta=b*b-4.*a*c;\n    //float root=(-b-sqrt(delta))/(2.*a),\n    if(delta<0.)\n        return sec;\n    float selRoot;\n    if(a*c<0.)\n    {\n        selRoot=1.;\n        sec.isIn=true;\n    }   \n    else\n    {\n        if(a*b>0.)\n            return sec;\n        else selRoot=-1.;\n    }   \n    sec.t=(-b+selRoot*sqrt(delta))/(2.*a);\n    return sec;\n}\nRayIntersection icube(Ray r,vec3 pos,vec3 size)\n{\n    RayIntersection sec=RayIntersection(MaxDist,false);\n    size*=.5;\n    vec3 pmin=pos-size,pmax=pos+size,//AABB\n    t1=(pmin-r.o)/r.d,t2=(pmax-r.o)/r.d,\n    tn3=min(t1,t2),tf3=max(t1,t2);\n    float tmin=max(tn3.x,max(tn3.y,tn3.z)),\n          tmax=min(tf3.x,min(tf3.y,tf3.z));\n    if(tmin>tmax||tmax<0.)\n        return sec;\n    if(tmin<0.)\n        sec.isIn=true;\n    sec.t=mix(tmax,tmin,step(0.,tmin));\n    return sec;\n}\n\nconst int nid=-1;\nconst int ObjCount=4;\nconst int cid=0;\nconst int s1id=1;\nconst int s2id=2;\nconst int s3id=3;\nvec3 getObjCol(Hit h,Ray r)\n{\n    vec3 col;\n    if(h.id==cid)\n        col=h.nml*.5+.5;\n    else if(h.id==s1id)\n        col=vec3(.8,.14,.4);\n    else if(h.id==s2id)\n        col=h.nml*.5+.5;\n    else if(h.id==s3id)\n        return texture(iChannel0,r.d).xyz;\n    return col;\n}\nfloat pit(float o,float t){return step(o,t)+1.-step(-o,t);}\nvec3 pit(vec3 o,vec3 v){return vec3(pit(o.x,v.x),pit(o.y,v.y),pit(o.z,v.z));}\nHit getHit(){return Hit(nid,MaxDist,vec3(0),vec3(0),1.,false);}\n\nHit rayCast(Ray r)\n{\n    vec4 s[3];\n    s[0]=vec4(vec3(0,0,0),1.);\n    s[1]=vec4(vec3(1.5,0,0),.5);\n    s[2]=vec4(vec3(-1.5,0,0),.5);\n    vec3 cpos=vec3(0,-1,0);\n    vec3 csiz=vec3(4.,.3,2.);\n    RayIntersection d[4];\n    d[0]=icube(r,cpos,csiz);\n    d[1]=isphere(r,s[0]);\n    d[2]=isphere(r,s[1]);\n    d[3]=isphere(r,s[2]);\n    Hit h=getHit();\n    for(int i=0;i<ObjCount;i++)\n        if(h.dis>d[i].t)\n        {\n            h.id=i;\n            h.dis=d[i].t;\n            h.isIn=d[i].isIn;\n        }\n    h.pos=r.o+r.d*h.dis;\n    //normal, refrac\n    if(h.id>=0)\n    {\n        h.ref=1.08;\n        if(h.id>=s1id)\n            h.nml=(h.pos-s[h.id-1].xyz)/s[h.id-1].w;\n        else if(h.id==cid)\n        {\n            vec3 cp=h.pos-cpos;\n            h.nml=normalize(pit(csiz/2.-1e-5,cp)*sign(cp));\n        }  \n        if(h.isIn)\n            h.nml=-h.nml;\n    }\n    \n    return h;\n}\nvec3 refract(vec3 vin,vec3 nml,float n21)//n21=n2/n1 from n1 to n2\n{\n    float len=length(vin);\n    vin/=len;\n    vec3 nmlTvin=-vin-nml*dot(nml,-vin);//nml to -vin\n    float sin1=length(nmlTvin);\n    float sin2=sin1/n21;\n    float cos2=sqrt(1.-sin2*sin2);\n    return (-nml*cos2-nmlTvin*sin2/sin1)*len;\n}\n\nHit rayCast(Ray r,out Ray rfl,out Ray rfr)\n{\n    Hit h=rayCast(r);\n    rfl=Ray(h.pos+MinDist*h.nml,reflect(r.d,h.nml));\n    rfr=Ray(h.pos-MinDist*h.nml,refract(r.d,h.nml,h.isIn?(AirRef/h.ref):h.ref/AirRef));\n    return h;\n}\n\nHit rayCast(Ray r,out Ray rfl,out RayGroup rg)\n{\n    Hit h=rayCast(r);\n    rfl=Ray(h.pos+MinDist*h.nml,reflect(r.d,h.nml));\n    float diff=.1;\n    float tRef=h.ref;\n    rg.gr=Ray(h.pos-MinDist*h.nml,refract(r.d,h.nml,h.isIn?(AirRef/tRef):tRef/AirRef));\n    tRef=h.ref-diff;\n    rg.rr=Ray(h.pos-MinDist*h.nml,refract(r.d,h.nml,h.isIn?(AirRef/tRef):tRef/AirRef));\n    tRef=h.ref+diff;  \n    rg.br=Ray(h.pos-MinDist*h.nml,refract(r.d,h.nml,h.isIn?(AirRef/tRef):tRef/AirRef));\n    return h;\n}\n\nvec3 getColor(Hit h,Ray r)\n{\n    if(h.id<0)\n        return texture(iChannel0,r.d).xyz;\n    return getObjCol(h,r);\n}\nvec3 getColor(Hit h,RayGroup rg)\n{\n    if(h.id<0)\n    {\n        return vec3(texture(iChannel0,rg.rr.d).r,\n                    texture(iChannel0,rg.gr.d).g,\n                     texture(iChannel0,rg.br.d).b);\n    }\n    return getObjCol(h,rg.gr);\n}\n\nvec3 render(Ray r)\n{\n    \n    Hit h=rayCast(r);\n    if(h.id<0)\n        return texture(iChannel0,r.d).xyz;\n    Hit lastRefraction;\n    vec3 col=vec3(0); \n    \n    \n    const int cnum=int(round(pow(2.,float(times))-1.));    \n    Ray rq[cnum];\n    RayGroup rgq[cnum/2+1];//refracted rays of r g b\n    float dim[cnum];\n    int top=0;\n    rq[top]=r;\n    dim[top]=.5;\n    top++;\n    for(int i=0;i<cnum;i++)\n    {\n        r=rq[i];\n        RayGroup rg=rgq[i/2];\n        Ray rfl;\n        RayGroup rfrg;\n        \n        h=rayCast(r,rfl,rfrg);\n        float fresnel=1.-pow(clamp(dot(h.nml,-r.d),0.,1.),.5);\n        if(top<cnum)\n        {\n            rq[top]=rfl;\n            dim[top]=mix(0.,dim[i]*.5,fresnel);\n            top++;\n            //only keep the green one to reduce the amount of ray \n            rq[top]=rfrg.gr;\n            rgq[top/2]=rfrg;\n            dim[top]=dim[i]*.5-dim[top-1];\n            top++;\n        }\n        if(i==0||i%2==1)\n            col+=getColor(h,r)*dim[i];\n        else\n            col+=getColor(h,rg)*dim[i];\n    }\n    return col;\n}\n\nvec3 getPixelCol(in vec2 pixel,vec2 resolution)\n{\n    vec2 uv = (pixel-.5*resolution.xy)/resolution.y;\n    vec2 m=iMouse.xy/iResolution.xy;\n    float t=iTime*.6;\n    setCam(vec3(3.*sin(t),sin(t),3.*cos(t)),vec3(0));\n    Ray r=getRay(uv);\n    vec3 col=render(r);\n    return col;\n}\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    O.rgb=getPixelCol(C,iResolution.xy);\n}","name":"Image","description":"","type":"image"}]}