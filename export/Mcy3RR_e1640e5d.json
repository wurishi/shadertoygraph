{"ver":"0.1","info":{"id":"Mcy3RR","date":"1712311507","viewed":602,"name":"[4k] Drifting Shore","username":"NuSan","description":"Drifting Shore by nusan, PC 4k intro made for Revision 2024\nSound is made with shaders too!\nI lowered the sample count from 25 to 10 so it's fast on an average PC\nOriginal code is here: https://github.com/TheNuSan/Lev4k/tree/DriftingShore","likes":49,"published":1,"flags":40,"usePreview":0,"tags":["sound","intro","4k","revision"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Drifting Shore\n// by nusan\n// PC 4k intro made for Revision 2024\n\n// To play it properly with sound in sync\n// restart it by pressing the button on the left under the image\n\n// you can adjust SAMPLE_COUNT in \"Buffer A\" tab if you want to adjust the quality\n\n// Original code is here: https://github.com/TheNuSan/Lev4k/tree/DriftingShore\n\n// if the shader compilation fails (on mobile for example)\n// you can try the \"soundcloud\" version here, where the audio shader is off\n// https://www.shadertoy.com/view/Mct3WB\n\n// this code is often a mess, it was made in a rush to meet approaching revision's deadline\n// so don't judge it too harshly, it could be sizecoded a lot more but I didn't have time\n\n\n////////////////////////////\n// POST-PROCESS           //\n////////////////////////////\n\nfloat time;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\ttime = max(0.,iTime-1.);\n\t\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n\t\n\t// get back the color from the first pass framebuffer\n\tvec4 value=texture(iChannel0,uv);    \n    vec3 col=value.xyz;\n\n\t// compute bloom by sampling the mipmaps of the first pass\n\tvec3 cumul = vec3(0);\n\tfor(float i=0.; i<32.; ++i) {\n\t\t// spiral pattern with a per-pixel random rotation\n\t\tvec2 off=vec2((i+.1)/32.,0)*rot(i*4.+rnd23(gl_FragCoord.xy).x*7.);\n\t\tvec4 cur = textureLod(iChannel0, uv + off*140./iResolution.xy, 4.5);\n\t\tcumul += cur.xyz;\n\t}\n\t// apply the bloom \n\tcol += cumul * 0.01 * pow(smoothstep(.0,1.,dot(cumul.xyz,vec3(.1))),0.5);\n\t\n\t// vignetting\n\tcol *= 1.-length(uv-.5)*1.2;\n\tcol *= 1.08*(2.51*col+0.03)/(col*(2.43*col+0.59)+0.14); // \"filmic\" tonemapping\n\n\t// global fade-in / fade-out\n\tcol *= block(time-4.,139.,4.,1.);\n        \n\tfragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float pi;\n\nfloat note_freq(float note) { return 440.*pow(2.,note/12.); }\nconst int tmajor[7] = int[7](0,2,4,5,7,9,11);\nfloat major(float k) {\n    return 3. + float(tmajor[int(k+140.)%7])+floor(k/7.)*12.; // B Major\n}\n\n//////////// synth params\n\n// seed, overtones, sharpness, width\nvec4 seeding=vec4(31,60,1.2,0.03);\n// repeat, attack, sustain duration, release\nvec4 enveloppe = vec4(4,1.,2.5,.5);\n\nfloat decay = 1.;\n\n// AMP\nfloat pregain = 0.2;\nfloat gain = 1.;\n\n// enveloppe based on time t\nfloat env(float t) {\n    return c01(t/enveloppe.y) * c01(1.-(t-enveloppe.y-enveloppe.z)/enveloppe.w);\n}\n\n// main synth of the intro\n// play 40 frequencies randomly chosen as integer multiplier of the base frequency\n// for each of thoses frequency, play 40 instances with slight phase and frequency offsets\nfloat realsynth(vec3 note) {\n\tif(note.y<-98.) return 0.;\n\n    float s=0.;    \n    for(float i=0.; i<40.; ++i) {\n        float id = i+seeding.x;\n\t\tfloat cur = note.y;\n\t\tfloat freq = note_freq(cur);\n\t\tfloat over = rnd11(id);\n\t\tfreq *= 1.+floor(pow(over,seeding.z)*seeding.y);\n\t\tfloat amp = pow(1.-over, note.x*decay);\n\t\tfor(float j=1.; j<40.; ++j) {\n\t\t\tfloat sub = freq * (1.+(rnd11(id+j*.3)-.5) * seeding.w);\n\t\t\ts += amp*sin(sub*pi*2.*note.x + 2.*pi*rnd11(id+j*.7+.1)) * 2.;\n\t\t}\n    }\n\n\ts*=note.z*pregain;\n\ts *= sqrt(gain / (1369. + (gain - 1.) * s * s));\n\t\n\treturn s;\n}\n\nfloat pad(float time, float h) {\n\tfloat rt = mod(time, enveloppe.x);\n\tfloat ch = major(h+floor(rnd11(floor(time/enveloppe.x))*5.)*2.-16.);\n\treturn realsynth(vec3(rt,ch,env(rt)));\n}\n\nfloat lead(float time) {\n\tfloat note = floor(time*4.);\n\tfloat t=fract(time*4.)/4.;\n\n\t// melody from the \"pink sky\" part\n\tfloat val = float(int[16](3,-99,5,-99,7,6,-99,-99,5,7,6,8,7,5,6,4)[int(note)%16]);\n\tif(mod(floor(note),4.)==0.)val+=mod(floor(note/16.),4.)*2.-2.;\n\tfloat mus = realsynth(vec3(t,major(val-4.),env(t)));\n\tmus += realsynth(vec3(t,major(val),env(t)))*(0.5+sin(time)*0.5);\n\tmus += realsynth(vec3(t,major(val-12.),env(t)))*(0.5+sin(time*0.7)*0.5);\n\treturn mus;\n}\n\nfloat snare( float _phase ) {\n  return clamp(sin( _phase * 800.) * exp( -_phase * 30. ) , -0.5, 0.5);\n}\n\n// random growling sound\nvec2 growl(float tt, float id) {\n\tseeding.y=rnd11(id)*40.+3.;\n\tseeding.z=rnd11(id+.1)*40.;\n\treturn abs(vec2(1,0)*rot(rnd11(id+.27)))*realsynth(vec3(tt,major(-32.+floor(24.*rnd11(id+.13))),1.));\n}\n\n// fade smoothly from a random growling sound to the next\nvec2 growl2(float t, float r) {\n\tfloat tt=fract(t/r);\n\tfloat nn=floor(t/r);\n\treturn mix(growl((tt+1.)*r,nn),growl(tt*r,nn+1.), pow(smoothstep(0.,1.,tt),1.));\n}\n\nvec2 mainSound( int samp, float time_base )\n{\n    pi =acos(-1.);\n    \n    float time = max(0.,time_base - 1.03);\n\n    vec2 mus = vec2(0);\n    float beat = fract(time);\n\n    // global control of the song parts\n    vec2 lead1 = vec2(0.6,.4) * block(time-91.,25.4,1.,.1); // pink sky part\n    vec2 lead3 = vec2(0.5) * block(time-34.,30.,1.,.8); // sound for all the little spheres\n    vec2 pad1 = 0.4*abs(vec2(sin(time*.2),cos(time*.25))) * block(time-24.5,68.5,8.,4.);\n    vec2 bass = vec2(.7,.3)*block(time-36.,80.,.1,.1);\n    vec2 drum = bass.yx;\n    vec2 gro = vec2(1.-.8*block(time-40.,77.,4.,4.));\n    float lead2 = block(time-67.,22.,2.,2.); // glowy sphere music\n\n    // pad\n    //seeding=vec4(31,60,1.2,0.03);\n    //enveloppe=vec4(4,1.,2.5,.5);\n    float padoc = -16.+lead2*8.;\n    mus += pad1*pad(time, padoc)*vec2(1.2,0.2);\n    mus += pad1*pad(time+1., padoc+2.) * chop(time*7.)*vec2(0.7,0.8);\n    mus += pad1*pad(time+2., padoc+4.) * (0.5+0.5*chop(time*10.))*vec2(0.2,1.2);\n\n    // lead 2 (glowy sphere)\n    seeding=vec4(20,60,40,0.06+0.055*sin(time/10.)*sin(time/7.));\n    enveloppe=vec4(1,.01,0.01,.4);\n\n    float chord = mod(floor(time*2.), 8.)-2.;\n    vec2 lead2b = 0.5*vec2(0.4,.6) * lead2;\n    mus += lead2b*realsynth(vec3(fract(time),major(chord),exp(-fract(time)*3.)));\n    mus += lead2b*realsynth(vec3(fract(time),major(chord+3.),exp(-fract(time)*3.)));\n    mus += lead2b*realsynth(vec3(fract(time*3.),major(chord + mod(floor(time*3.),4.)*2. - 4.),exp(-fract(time*3.))));\n\n    // lead 3 (sound of all the little spheres)\n    seeding=vec4(77,30,20.+cos(time/30.)*17.,0.02+cos(time)*.04);\n    enveloppe=vec4(0.5,.01,0.06,.02);\n    for (int i=0; i<12; ++i) {\n        mus += lead3*pad(time-float(i%4)-float(i/4)*0.3, -float(i%4*2))*(4.-float(i%4))*.15;\n    }\n\n    // lead 1 (pink sky part)\n    seeding=vec4(22,60,12.+sin(time/16.)*10.,0.013);\n    enveloppe=vec4(1,.01,0.12,.11);\n    pregain=10.;\n    gain=2.;\n    mus += lead1 * lead(time) * 0.07;\n    mus += lead1 * lead(time-.5) * 0.02;\n    mus += lead1 * lead(time-.25) * 0.01;\n\n    // bass\n    seeding.z = 60.;\n    mus += bass*0.13*realsynth(vec3(fract(time+.5),-40.,exp(-fract(time*4.)*4.)));\n\n    // growling sounds\n    pregain=0.2;\n    gain=1.;\n    seeding=vec4(22,60,2,0.07+1.0);\n    enveloppe=vec4(1,.1,0.8,.1);\n\n    // to produce some sfx, I just boost the growing a lot with appropriate fading\n    // menacing sound when the wall approach the sphere, just before it stars glowing\n    float crash=block(time-65.2,0.4,1.5,1.);\n    // crash just before the yellow part\n    crash=max(crash,block(time-117.5,0.2,.5,3.));\n    // \"click\" when all the little purple spheres light's up\n    crash=max(crash,block(time-30.1,0.1,.1,1.));\n    gro+=crash*5.;\n    decay = 0.1;\n    vec2 gr = growl2(time, 8.)*2.;\n    gr += growl2(time, 4.);\n    gr += growl2(time, 2.);\n    // add an extra glowing sound at the end part\n    gr += growl2(time, 0.05)*0.5*block(time-124.,10.,4.,8.);\n    // crank the gain to the max for the growling\n    gr *= 100.;\n    gain = 2.;\n    gr *= sqrt(gain / (1369. + (gain - 1.) * gr * gr));\n    mus += gro*gr*0.15;\n\n    // dunking the music when the kick hit\n    float mub = c01(beat*100.)*c01(exp(-beat*5.));\n    mus *= 1.-mub;\n\n    // kick\n    float k = sin(beat*307.3)*cos(beat*100.)*exp(-beat*4.);\n    k += sin(beat*200.)*exp(-beat*20.);\n    mus += drum*max(-0.5,min(0.5,k));\n\n    // snare\n    mus += drum*snare(fract(time+0.5))*lead1;\n    mus += drum*snare(fract(time/2.+0.25))*2.;\n    mus += drum*snare(fract(time/4.+0.0525))*2.;\n\n    // highhats\n    float beat2 = min(fract(time*2.), fract(time*6.));\n    mus += drum*(1.-block(time-64.,8.,.1,.1))*fract(sin(beat2*142.454)*485.523) * exp(-beat2*10.) * 0.1 * step(mod(time,16.),12.);\n\n    // global fade-in and fade-out\n    mus *= block(time-2.,141.,2.,1.);\n\n    return clamp(mus,-1.,1.);\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"float c01(float a) {return clamp(a,0.,1.);}\n\n//DAVE HOSKINS' HASH FUNCTIONS\nfloat rnd11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    return fract(2.*p*p);\n}\n\nvec3 rnd23(vec2 p)\n{\n\tvec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 rnd33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yxx) * p3.zyx);\n}\n\n// rotation function\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\n// fade in, stay on for d duration and then fade out \nfloat block(float t, float d, float fi, float fo) {\n\treturn c01(t/fi+1.)*c01((d-t)/fo+1.);\n}\n\n// out 1 for half the time and then 0 for the rest, with fade in/out\nfloat chop(float t) {\n\treturn c01(min(fract(t)*30.,fract(1.-t)*30.-15.));\n}\n\n// only for webgl, as it gives infinites when normalizing a zero vector, which lead to visual glitches\nvec3 safenorm(vec3 val) {\n    float vald=length(val);\n    if(vald<=0.) return vec3(0,1,0);\n    return val/vald;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Main rendering pass\n\n// change this to adjust quality versus speed\n// for this shadertoy version I put 10 has is't already looking fine\n// for the release I choose 25 but compo PC could probably\n// have gone for more but it starts to loose impact pretty fast\n#define SAMPLE_COUNT 10.\n\nfloat time;\n\n////////////////////////////\n// PATHTRACING            //\n////////////////////////////\n\n// current ray start position, ray direction, normal at hit point, emissive color at hit point\nvec3 s,r,n,emit;\n// distance of first collision along the ray, starts very high\nfloat d=10000.;\n\n// analytical intersection between current ray and a sphere of \"size\" at a position \"pos\", with a specific color \"co\"\nvoid sphere(vec3 pos, float size, vec3 co) {  \n    vec3 l = pos - s;\n\tfloat tca = dot(l, r);\n    float d2 = dot(l,l) - tca*tca;\n\tif(d2 < size*size) {\n        float thc = tca - sqrt(size*size-d2);\n        if (thc > 0. && thc < d)\n        {\n            d =  thc;\n            n = safenorm(d*r-l);\n\t\t\temit = co;\n        }\n    }\n}\n\n// color of the sky for the current ray direction\nvec3 skycol() {\n\t// lighting in first scene, just some large blurry white blobs, inspired by Blackle's way of doing that\n\tif(time<90.) return vec3(.7,.8,1)*abs(dot(sin(r*vec3(5,7,13)),vec3(1)));\n\t// lighting in final scene, a pure desaturated blueish sky with a small bright pink rising sun\n\tif(time>120.) return c01((time-123.)/2.)*mix(vec3(0.6,0.8,1)*.8, vec3(1,0.3,0.3) * 15., pow(max(dot(r,safenorm(vec3(-1,0,-1.5))),0.),50.));\n\t// lighting in \"flashing pink bars\" scene\n\tvec3 cid = floor(abs(r)*vec3(30,1,30)+floor(time*6.));\n\tfloat fad = c01((116.4-time)*4.);\n\t// makes pink bars that flashes at random intervals\n\treturn fad*vec3(pow(1.-abs(r.y),4.)+.3,0.5,1.)*8.*rnd33(cid).y*max(0.,sin(time*8.*rnd11(cid.x)));\n}\n\n////////////////////////////\n// MAIN PASS              //\n////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 frag = fragCoord.xy;\n\tvec2 uv = (frag-iResolution.xy*0.5)/iResolution.y;\n\t\n\tvec3 col = vec3(0);\n    \t\n\ttime = max(iTime-1.,0.);\n            \t\t\n\t//////// CAMERA ANIMATION ////////\n\n\t// sections are 8 beats, the music is like 120 bpm, so no need to put any factor there\n\tint section = int(time/8.)%18;\n\t// variable going from 0 to 8 in a section\n\tfloat rest = mod(time,8.);\n\t// way to separate section in two parts, this variable is at 1 if in the second half of a section\n\tfloat mi = floor(rest/4.);\n\n\t// Main way to control the intro (camera, DOF focus, shape)\n    // Each vec3 is a section of the intro\n    // first value is the seed of the camera motionpath/speed/FOV, fractionnal part is a time offset, negative values subdivide the section in two parts\n    // second value is the focus distance for the DOF, negative value makes the DOF bigger\n    // third value is the shape seed, integer value is the background shape, fractionnal part is the center shape\n\tvec3 mot[18] = vec3[18]( // 18 sections in total\n\t\t vec3(18.32,-12,0)\n\t\t,vec3(-16,-18,0)\n\t\t,vec3(-7,-20.-max(0.,rest-7.5)*200.,0)\n\t\t,vec3(-7,-min(rest,4.)*10.,8)\n\t\t// -------------- // 32\n\t\t,vec3(-4.+mi*4.1,-13,8)\n\t\t,vec3(-13.+mi*3.,15,14.1)\n\t\t,vec3(-7.97,-25.+mi*10.,8.2)\n\t\t,vec3(-4.9,8,11)\n\t\t// -------------- // 64\n\t\t,vec3(-5.9,7,2.6)\n\t\t,vec3(-7.5,-18,15)\n\t\t,vec3(-16.95-mi*5.,20,8)\n\t\t,vec3(25.+mi,-20,4.6)\n\t\t// -------------- // 96\n\t\t,vec3(-35,20,6.9)\n\t\t,vec3(-51,-20.+mi*10.,7.9)\n\t\t,vec3(-16,30,14.4-mi)\n\t\t,vec3(-5,-20.-rest*30.,13.025+mi*(25.-.025))\n\t\t// -------------- // 128\n\t\t,vec3(2.+mi*39.,10,6)\n\t\t,vec3(31.+mi*7.,-12.-rest*2.,0)\n\t\t);\n\n\t// my way of working was to put random seeds for the shape or camera and find some that I find good\n\t// then I can just copy/past that seed in the array above to put it in a section\n\n\t// seed values for the current section\n\tvec3 mval = mot[section];\n\t// camera avance along it's path\n\tvec3 pcam = rnd23(vec2(round(abs(mval.x)),0));\n\tfloat avance = pcam.x*300. + rest * (pcam.y*.5-0.2) + fract(mval.x)*8.;\n\tif(mval.x<0.) avance += floor(rest/4.)*100.;\n\tif(section==9) avance += rest*0.05;\n\t\n\t// distance where scene will be sharp (no blur)\n\tfloat focusdist = abs(mval.y)*5.;\n\t// extra push that lets you put the camera far away without actually moving it or having objects going in front of it\n\tfloat extrapush = mval.y>0. ? 0. : 50.;\n\t// if extrapush is activated, use a larger amount of dof\n\tfloat dofamount = .075+extrapush/50.;\n\t// adjust fov to compensate for extrapush\n\tfloat fov = 1. + extrapush/50.;\n\t\n\t// size of the sphere that limits the 3 planes\n\tfloat bigsphere=100000.;\n\t// location of that sphere\n\tvec3 msp=vec3(0,-10,0);\n\n\t// lissajous curve to makes interesting camera motion\n\t// a section of the intro is only a time offset in that very long lissajous curve\n\tfloat dt=rnd11(pcam.z)*20.-10.;\n\tvec3 bs=vec3(100.*sin(avance*.4 + 0.7),-20. + sin(avance*.2)*3.,100.*sin(avance*.9));\n\tvec3 t = vec3(100.*sin(avance*.4 + 0.7 + dt),sin(avance*.3)*3.,100.*sin(avance*.9 + dt));\n\tif (section==12) t+=vec3(-80,0,-0);\n\n\t//////// CAMERA COMPUTE ////////\n\tvec3 cz=safenorm(t-bs);\n\tvec3 cx=safenorm(cross(cz,vec3(0,1,0)));\n\tvec3 cy=cross(cz,cx);\n\t\t\n\t// number of samples per pixel, here 25 give about 30fps on my RTX3070 but will give at least 60fps on the compo machine\n\tfloat steps=SAMPLE_COUNT;\n\tfor(float i=0.; i<steps; ++i) {\n    \n\t\ts=bs;\n\t\t// DOF\n\t\tvec2 h = rnd23(frag-13.6-i*184.7).xy;\n\t\tvec3 voff = sqrt(h.x)*(cx*sin(h.y*6.283)+cy*cos(h.y*6.283))*dofamount;\n\t\ts-=voff;\n\t\tr=safenorm(uv.x*cx+uv.y*cy+fov*cz + voff*fov/(focusdist+extrapush));\n\t\ts += (r-cz) * extrapush;\n\t\t\n\t\t// up to 3 rays per sample (1 primary ray and 2 bounces)\n\t\tfloat alpha = 1.;\n\t\tfor(float j=0.; j<3.; ++j) {\n\t\t\t////////// TRACE //////////\n\t\t\td=100000.;\n\t\t\t\n\t\t\temit=vec3(0);\n\t\t\t\n\t\t\t////////// SCENE //////////\n            \n\t\t\t// the scene is made of 3 rotating planes\n\t\t\tfor(float k=0.;k<3.;++k) {\n\t\t\t\n\t\t\t\tfloat seed=k+round(mval.z)*100.4;\n\n\t\t\t\t// we keep around previous ray hit values, in case we are going through a hole of this plane\n\t\t\t\tfloat d2 = d;\n\t\t\t\tvec3 n2 = n;\n\t\t\t\tvec3 emit2 = emit;\n    \n\t\t\t\tvec3 planenorm = vec3(0,1,0);\n\t\t\t\t\n\t\t\t\t// animation variables\n\t\t\t\tfloat ani=fract(mval.z)*4.;\n\t\t\t\tfloat ani2=time>48. && time<80.?1.:0.;\n\t\t\t\tfloat adj=0.;\n\t\t\t\t\n\t\t\t\t// distance from origin of the plane\n\t\t\t\tfloat dist = rnd11(seed-.1)*40.+40.;\n\t\t\t\t// plane thickness\n\t\t\t\tfloat size = 2.5;\n\t\t\t\t// radius of the sphere inside the plane\n\t\t\t\tfloat minsph = 2.5;\n\t\t\t\t// value that \"pushes\" the sphere back from camera so you can have sphere thicker than the plane\n\t\t\t\tfloat artpush=0.;\n\t\t\t\t\n\t\t\t\t// size of the main repeating grid of boxes that carve through the planes\n\t\t\t\tvec3 p2=vec3(100,100,100);\n\n\t\t\t\tif(time>80.) {\n\t\t\t\t\tdist=min(3.,-80.+(time-88.)*20.);\n\t\t\t\t\tif (time>90.) bigsphere=mix(80.,26.,smoothstep(0.,1.,(time-90.)/4.));\n\t\t\t\t}\n\n\t\t\t\tif (time>117.) {\n\t\t\t\t\tbigsphere=(time-117.)*400.;\n\t\t\t\t\tp2 *= vec3(1,3,1);\n\t\t\t\t\tdist = (time-117.)*70.;\n\t\t\t\t\tartpush=5.;\n\t\t\t\t} else if (time>100.) {\n\t\t\t\t\tani2=2.;\n\t\t\t\t\t// cheat to deform the planes \"organicaly\"\n\t\t\t\t\t// we just offset the rotation according to the original ray direction\n\t\t\t\t\t// the reflection doesn't follow properly but it breaks the rigidity of the scene a lot\n\t\t\t\t\tvec3 br=safenorm(uv.x*cx+uv.y*cy+fov*cz);\n\t\t\t\t\tadj=br.y*3.-sin(br.z*3.)+sin(br.x*3.);\n\t\t\t\t\tsize=5.;\n\t\t\t\t\tminsph = 5.;\n\t\t\t\t\tp2 = vec3(20,100,20);\n\t\t\t\t}\n\t\t\t\tif(time>120.) { dist=300.+(time-120.)*5.; p2 = vec3(140); ani2=1.;}\n\t\t\t\tif(time>=124.) { dist=200.; minsph=0.;artpush=0.; size=1.; ani2=0.;}\n\t\t\t\t\n\t\t\t\t// the 3 planes are mostly rotating with a random speed\n\t\t\t\tplanenorm.yz *= rot(sin(rest*.13*ani + rnd11(seed)*7.)*1.57+adj);\n\t\t\t\tplanenorm.xz *= rot(rest*.07*ani + rnd11(seed+.1)*7.+adj*.7);\n\t\t\t\t\t\t\t\t\n\t\t\t\tif (time<24.) {\n\t\t\t\t\t// first scene, the 3 planes are nearly flat\n\t\t\t\t\tplanenorm=vec3(k*0.01,1,-0.02);\n\t\t\t\t\tdist = max(16.-time,0.);\n\t\t\t\t\tif(section==2) dist+= 10./(1.+rest)-4.;\n\t\t\t\t\tminsph = 0.;\n\t\t\t\t} else if(time<40.) {\n\t\t\t\t\t// second scene, the 3 planes are less flat\n\t\t\t\t\tplanenorm.y+=4.-pow(max(time-33.,0.),2.)*.05;\n\t\t\t\t\tdist=10.;\n\t\t\t\t\tfloat tre=min(time-24.,6.);\n\t\t\t\t\tminsph=min(tre,2.5);\n\t\t\t\t\tartpush=tre*6.;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tplanenorm=safenorm(planenorm);\n\n\t\t\t\t// find the collision with a plane of thickness \"size\"\n\t\t\t\tfloat dn = dot(r,planenorm);\n\t\t\t\tfloat ds = dot(s,planenorm);\n\t\t\t\tfloat dplane = (dist-ds)/dn;\n\t\t\t\tfloat dsi = abs(size/dn);\n\n\t\t\t\t// ray start is inside the thickness of the plane\n\t\t\t\tif(abs(dplane)<dsi) {\n\t\t\t\t\td = 0.;\n\t\t\t\t\tn = vec3(0);\n\t\t\t\t\temit = vec3(0);\n\t\t\t\t} else if(dplane<d+dsi && dplane>dsi) { // hit the plane, works from both side of it\n\t\t\t\t\td = dplane-dsi;\n\t\t\t\t\tn = -planenorm * sign(dn);\n\t\t\t\t\temit = vec3(0);\n\t\t\t\t}\n        \n\t\t\t\t// location of the hit with the plane\n\t\t\t\tvec3 uv = s+r*d;\n    \t\t\t\n\t\t\t\t// octree subdivision:\n\t\t\t\t// we split the space 3 times, each time we divide in 2 blocks at a random offset on each axes (so 8 blocks)\n\t\t\t\t// this lets us have a non-repeating slicing of our plane\n\t\t\t\t// we can then animate the slip location\n\t\t\t\tvec3 offp = floor(uv/p2)*p2;\n\t\t\t\t// p1 and p2 are the two extreme of the block containing the hit location\n\t\t\t\tvec3 p1=offp;\n\t\t\t\tp2+=offp;\n\t\t\t\t// we also want a random id different for each block\n\t\t\t\tvec3 id=offp+vec3(seed);\n    \n\t\t\t\tfor (float l=0.; l<3.; ++l) {\n\t\t\t\t\tfloat t3=time*0.5*ani2+l*.2;\n\t\t\t\t\tvec3 c = (mix(rnd33(id+floor(t3)),rnd33(id+floor(t3)+1.),pow(smoothstep(0.,1.,fract(t3)),10.)) * 0.5 + 0.25)*(p2-p1)+p1;\n\t\t\t\t\tp1=mix(p1,c,step(c,uv));\n\t\t\t\t\tp2=mix(c,p2,step(c,uv));\n\t\t\t\t\tid+=mix(vec3(0.03),vec3(0.1),step(c,uv));\n\t\t\t\t}\n\n\t\t\t\t// now each block contain a box that carve the plane\n\t\t\t\t// here we compute it's position and size\n\t\t\t\tvec3 cubepos=(p1+p2)*.5;\n\t\t\t\tvec3 cubesize=(p2-p1)*.5-0.3;\n\t\t\t\t\n\t\t\t\t// carving box intersection\n\t\t\t\tvec3 invd = 1./r;\n  \n\t\t\t\tvec3 t0 = ((cubepos-cubesize) - s) * invd;\n\t\t\t\tvec3 t1 = ((cubepos+cubesize) - s) * invd;\n\t\t\t\tvec3 mi = min(t0, t1);\n\t\t\t\tvec3 ma = max(t0, t1);\n  \n\t\t\t\tfloat front = min(min(ma.x,ma.y),ma.z);\n\t\t\t\tfloat back = max(max(mi.x,mi.y),mi.z);\n  \n\t\t\t\tif(front>d && front > 0.) {\n\t\t\t\t\tvec3 cur = step(abs(s+r*d-cubepos),cubesize);\n\t\t\t\t\tif (min(cur.x,min(cur.y,cur.z))>0.) {\n\t\t\t\t\t\t// we hit a side of the cube, compute it's normal\n\t\t\t\t\t\td = front;\n\t\t\t\t\t\tn = (1.-clamp((ma-front)*1000.,0.,1.)) * sign(t1-t0);\n\t\t\t\t\t\temit = vec3(0);\n\t\t\t\t\t}\n\t\t\t\t}\n    \n\t\t\t\t// in each block, there is also a sphere\n\t\t\t\t// to get it's position, we project the middle position of the block on plane\n\t\t\t\tvec3 mp=(p1+p2)*0.5;\n\t\t\t\tmp-=(dot(mp,planenorm)-dist)*planenorm;\n\t\t\t\t\n\t\t\t\tmp += planenorm*artpush;\n\t\t\t\t// lighting of the small sphere\n\t\t\t\tvec3 lglow=vec3(0);\n\t\t\t\tif (time>30. && rnd33(floor(mp/5.)).x>.8) lglow=vec3(4.+sin(time/8.)*3.,1,5);\n\t\t\t\tif (time>117.) lglow=vec3(5,3.2,1.8);\n\t\t\t\tif (time>124.) lglow=vec3(0);\n\n\t\t\t\tsphere(mp, minsph + artpush, lglow);\n\t\n\t\t\t\tif(d>dplane+dsi || d>=d2) {\n\t\t\t\t\t// if the intersection we found is beyond the thickness of the plane\n\t\t\t\t\t// we skip it, we want the ray to go through the plane\n\t\t\t\t\t// so we restore original ray hit values\n\t\t\t\t\td=d2;\n\t\t\t\t\tn=n2;\n\t\t\t\t\temit=emit2;\n\t\t\t\t}\n\t\n\t\t\t\t// for the pink sky section, I wanted to limit the size of the planes to a \"big sphere\"\n\t\t\t\t// it's not perfectly working, the sphere limits have no thickness\n\t\t\t\t// but it's good enough for my use\n\t\t\t\tvec3 bigp = s + r*d-msp;\n\t\t\t\tif (dot(bigp,bigp)>bigsphere*bigsphere){\n\t\t\t\t\t// if ray hit of the plane is outside the big sphere, we undo it\n\t\t\t\t\td=d2;\n\t\t\t\t\tn=n2;\n\t\t\t\t\temit=emit2;\n\t\t\t\t}\n\n\t\t\t\td2=d;\n\t\t\t\tn2=n;\n\t\t\t\temit2=emit;\n\t\t\t\tsphere(msp, bigsphere,vec3(0));\n\t\t\t\tvec3 bigp2 = s + r * d;\n\t\t\t\tif (abs(dot(bigp2,planenorm)-dist)>size) {\n\t\t\t\t\t// display the hit with the big sphere only if inside the thickness of the plane\n\t\t\t\t\td=d2;\n\t\t\t\t\tn=n2;\n\t\t\t\t\temit=emit2;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// the main sphere of the intro\n\t\t\t// stay perfectly still all the time, and just glow a bit in the middle, it really is a lazy one :)\n\t\t\tvec3 spglow=vec3(1,0.5,0.2)*6.*c01(time*2.-131.)*c01(94.-time);\n\t\t\tsphere(msp, 20., spglow);\n\t\t\t\n\t\t\t// ground plane intersection\n\t\t\tfloat dplane = (4.-s.y)/r.y;\n            \n\t\t\tif(dplane<d && dplane>0.) {\n\t\t\t\td = dplane;\n                //n = vec3(0,-sign(r.y),0);\n\t\t\t\tn = vec3(0,-1,0);\n                emit = vec3(0);\n\t\t\t}\n            \n\t\t\t// blend color with the sky depending on the distance\n\t\t\tfloat fog = exp(-max(d-100.,0.)/2000.);\n\t\t\tcol += alpha * skycol() * (1.-fog);\n\t\t\talpha *= fog;\n\t\t\t\n\t\t\t// early out if we didn't intersect anything\n\t\t\tif(d>10000.) {\n\t\t\t\tbreak;\n\t\t\t}\n            \n\t\t\t// go to collision point\n\t\t\ts = s + r * d;\n\n\t\t\t// accumulate emissive color\t\t\t\n\t\t\tcol += alpha * max(emit,0.);\n\t\t\n\t\t\tif(j==2.) break;\n\t\t\t\n\t\t\t// next reflection will be dimer (yeah we could do fresnel here but I think it looks cooler like that)\n\t\t\talpha *= 0.7;\n\n\t\t\t// slight offset so the reflexion starts already out of the collision\n\t\t\ts-=r*0.01;\n\t\t\t// roughness if just a random amout at each integer coordinate\n\t\t\tfloat rough = 0.01+rnd33(floor(s)).x*0.5;\n\t\t\tif (time>90. && length(s-msp)<20.1) rough=.0;\n\t\t\t\n\t\t\t// \"shading\" model, just add a normalized random vector scaled by the roughness to the reflected normal\n\t\t\t// first time I saw that kind of reflection was in \"HBC-00017: Newton Protocol\" at Revision 2019\n\t\t\t// I love it's simplicity, even if a more physic based approach would probably look better but cost more\n\t\t\tr=safenorm(reflect(r,n) + safenorm(rnd23(frag+vec2(i*277.,j*375.)+fract(time)*1.)-.5)*rough);\n\t\t}\n\t}\n\tcol *= .6/steps;\n    \t\n    fragColor = vec4(col, 1);\n}","name":"Buffer A","description":"","type":"buffer"}]}