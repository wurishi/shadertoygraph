{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"float M=512.0,L=0.01,R=3.0;\nvec3 l=vec3(0.577);\nvec3 bl=vec3(0.5,0.7,1.0);\n\n\n// IQ's noise stuff\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\nfloat noise2(vec3 p){\n\treturn noise(p*32.0);\n}\n\nvec4 u, v;\n\nvec3 K(vec3 p) {\n\tfloat a=atan(p.x,p.y)+p.z*0.5,d=length(p.xy);\n\tvec3 p2=vec3(a*0.31831+u.z,d*0.2*u.y,p.z*0.2*u.y);\n\tfloat xr = noise2(p2);\n\tfloat yr = noise2(p*0.02);\n\tfloat yg = noise2(p*0.02+vec3(3.63));\n\tfloat zr = noise2(p*0.07);\n\tfloat zg = noise2(p*0.07+vec3(5.72));\n\tfloat nn = yr*yg+zr*zg;\n\treturn vec3(\n\t\tv.w*nn*nn*3.0+\n\t\tv.z*(6.0-(d+xr*4.0*v.y)+(sin(p.x*1.7+u.w-sin(p.y*2.5+u.w))+sin(p.z*1.5-u.w)*0.7)*0.5),\n\t\tclamp(nn*nn*0.25,0.0,1.0),\n\t\txr);\n}\n\nvec3 N(vec3 p,float a) {\n\treturn normalize(vec3(a-K(vec3(p.x+0.05,p.y,p.z)).r,a-K(vec3(p.x,p.y+0.05,p.z)).r,a-K(vec3(p.x,p.y,p.z+0.05)).r));\n}\n\nvec4 calc_pixel(vec3 ro, vec3 rd) {\n\tvec3 P,D=rd*L;\n\tfloat s=48.0,ks,a=1.0,f2;\n\tvec3 k=vec3(0.0),f=vec3(0.0),n,h,d,b,c;\n\n\t//for (;s<M;) {\n\tfor (int i=0; i<64; i++) {\n\t\tP=ro+D*s;\n\t\tk=K(P);\n\t\tif (k.r>R) break;\n\t\tif (s>=M) break;\n\t\tks=clamp(k.g-v.w*0.025,0.0,0.1);\n\t\ta=a*(1.0-ks);\n\t\tf=f+vec3(1.5-ks*14.0)*a*ks;\n\t\tif (a<0.01) break;\n\t\ts=s+clamp((R-k.r)*5.0,1.0,20.0);\n\t}\n\n\tif (s<M) for (int i=0;i<9;i++) {\n\t\tD=D*0.5;\n\t\tif (k.r>R) P=P-D;\n\t\telse P=P+D;\n\t\tk=K(P);\n\t}\n\n\tD=rd;\n\tn=N(P,k.r);\n\th=vec3(dot(reflect(normalize(D),n),l));\n\th=clamp(h*h*h*h*h*h*h*vec3(0.9,0.9,1.0),0.0,1.0);\n\tb=dot(n,-l)*bl.bgr;\n\td=clamp(dot(n,l)*bl+b*b,0.0,1.0);\n\tf2=clamp(1.0-(M-s)/M,0.0,1.0);\n\tc=mix((h+d)*abs(sin(k.b))*2.0,bl*v.w*0.5,f2*f2);\n\treturn vec4(u.x*mix(f*f2*f2,c,a),1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\t\n    u = vec4(1.0, sin(iTime*0.1)*0.2+0.6, iTime*0.2, -iTime*2.0);\n    v = vec4(0.0, 1.0-(cos(iTime*0.1)*0.25+0.5), 1.0, 1.0-(cos(iTime*0.05)*0.5+0.5));\n\n\tvec2 p = -1.0 + 2.0 * (fragCoord.xy / iResolution.xy);\n\tvec3 cp = vec3(sin(iTime*0.2)*5.0, cos(iTime*0.2)*5.0, iTime*0.05);\n\tvec3 t = vec3(0.0, 0.0, cp.z-5.0);\n\tvec3 z = normalize(t-cp);\n\tvec3 x = cross(z, vec3(0.0, 1.0, 0.0));\t\n\tvec3 y = cross(z, x); \n\tvec3 ro = cp+p.x*x-p.y*y;\n\tcp = cp-z*1.0;\n\tvec3 rd = (normalize(ro - cp));\n    fragColor = calc_pixel(ro, rd);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldXGzH","date":"1362321695","viewed":769,"name":"Baghdad","username":"kurli","description":"Raymarching effect from Baghdad by Nordic Conspiracy\nhttp://www.pouet.net/prod.php?which=54956\nOriginal effect uses 3d texture for noise, this one has IQ's noise instead\nsource is formatted for 4k so it might be a bit ambiguous, also slow :)","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","demoscene"],"hasliked":0,"parentid":"","parentname":""}}