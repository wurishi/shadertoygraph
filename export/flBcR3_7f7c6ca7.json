{"ver":"0.1","info":{"id":"flBcR3","date":"1652159497","viewed":152,"name":"184_terrain","username":"blblj","description":"184","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["terrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).xyz;\n         \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// 2D rotation\nconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\n// 3D rotation\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\nconst mat3 m3i = mat3( 0.00, -0.80, -0.60,\n                       0.80,  0.36, -0.48,\n                       0.60, -0.48,  0.64 );\n\n// just a random function cuz I need more random values...\nfloat hash1(float n) {\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\n// input xz position, output noisy height y. used for terrain.    \nvec3 noise2d(in vec2 x){\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n\n    // texel fetch version\n    ivec2 p = ivec2(floor(x));\n    float a = texelFetch( iChannel0, (p+ivec2(0,0))&255, 0 ).x;\n\tfloat b = texelFetch( iChannel0, (p+ivec2(1,0))&255, 0 ).x;\n\tfloat c = texelFetch( iChannel0, (p+ivec2(0,1))&255, 0 ).x;\n\tfloat d = texelFetch( iChannel0, (p+ivec2(1,1))&255, 0 ).x;\n    \n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\tdu*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\n// input xyz position, output noisy distance d. used for sculping clouds.   \nvec4 noise3d(in vec3 x){\n    // value noise idea from https://iquilezles.org/articles/morenoise/\n    vec3 fr = fract(x);\n    vec3 u = fr*fr*(3.0-2.0*fr);\n    vec3 du = 6.0*fr*(1.0-fr);\n\n    ivec2 p = ivec2(floor(x));\n    \n    float nn = floor(x).x + 317.0*floor(x).y + 157.0*floor(x).z;\n    \n    float a = texelFetch( iChannel0, (p+ivec2(0,0))&255, 0 ).x;\n\tfloat b = texelFetch( iChannel0, (p+ivec2(1,0))&255, 0 ).x;\n\tfloat c = texelFetch( iChannel0, (p+ivec2(0,1))&255, 0 ).x;\n\tfloat d = texelFetch( iChannel0, (p+ivec2(1,1))&255, 0 ).x;\n    float e = hash1(nn+317.0);\n    float f = hash1(nn+345.0);\n    float g = hash1(nn+987.0);\n    float h = hash1(nn+195.0);\n    \n    float k0 = a;\n    float k1 = b-a;\n    float k2 = c-a;\n    float k3 = e-a;\n    float k4 = a-b-c+d;\n    float k5 = a-c-e+g;\n    float k6 = a-b-e+f;\n    float k7 = -a+b+c-d+e-f-g+h;\n    \n    float n = k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z;\n    \n    float dndx = k1 + k4*u.y + k6*u.z + k7*u.y*u.z;\n    float dndy = k2 + k4*u.x + k5*u.z + k7*u.x*u.z;\n    float dndz = k3 + k5*u.y + k6*u.x + k7*u.x*u.y;\n    vec3 dndxyz = du * vec3(dndx, dndy, dndz);\n    \n\treturn vec4(n, dndxyz);\n}\n\n// terrain FBM function (with different coarseness)\nfloat terrainFBM(in vec2 x, int k) {\n    vec2  p = x*0.003;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<k; i++ )\n    {\n        vec3 n = noise2d(p);\n        d += n.yz;\n        a += b*n.x;\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\treturn 100.0*a;\n}\n\nfloat terrainH(in vec2 x) {\n\treturn terrainFBM(x, 15);\n}\n\nfloat terrainM(in vec2 x) {\n\treturn terrainFBM(x, 5);\n}\n\nfloat terrainL(in vec2 x) {\n\treturn terrainFBM(x, 3);\n}\n\n// a numerical way to compute normal vector of terrain\nvec3 calcNormal(in vec3 pos, float t) {\n    vec2  eps = vec2( 0.001*t, 0.0 );\n    return normalize( vec3( terrainH(pos.xz-eps.xy) - terrainH(pos.xz+eps.xy),\n                            2.0*eps.x,\n                            terrainH(pos.xz-eps.yx) - terrainH(pos.xz+eps.yx) ) );\n}\n\n// cloud FBM function\nvec4 cloudFBM(in vec3 x, int k) {\n    vec3  p = x;\n    float a = 0.0;\n    float b = 1.0;\n\tvec3  d = vec3(0.0);\n    mat3  m = mat3(1.0,0.0,0.0,\n                   0.0,1.0,0.0,\n                   0.0,0.0,1.0);\n    for( int i=0; i<k; i++ )\n    {\n        vec4 n = noise3d(p);\n        d += b*m*n.yzw;\n        a += b*n.x;\n\t\tb *= 0.5;\n        p = m3*p*2.0;\n        m = m3i*m*2.0;\n    }\n\treturn vec4(a, d);\n}\n\nfloat a = 1000.0;\nfloat b = 150.0;\nvec4 cloudSDF(in vec3 pos) {\n    vec4 c = cloudFBM((pos+vec3(-470,0,170)*iTime) / a, 3);\n    float h = abs(pos.y - 800.0) - 100.0 + b * c.x;\n    vec3 grad = vec3(0.0, sign(pos.y - 800.0), 0.0) + b / a * c.yzw;\n    return vec4(h, grad);\n}\n\n// raymarching funcions\nfloat raymarchTerrain(in vec3 ro, in vec3 rd, in float tmin, in float tmax) {\n    // (note that terrain should be below 100)\n    float t = tmin;\n\tfor( int i=0; i<300; i++ ) {\n        vec3 pos = ro + t*rd;\n\t\tfloat h = pos.y - terrainM( pos.xz );\n\t\tif( abs(h)<(0.0015*t) || t>tmax ) break;\n\t\tt += 0.4*h;\n\t}\n\n\treturn t;\n}\n\nfloat raymarchCloud(in vec3 ro, in vec3 rd, in float tmin, in float tmax, out vec3 grad) {\n    float t = tmin;\n\tfor( int i=0; i<300; i++ ) {\n        vec3 pos = ro + t*rd;\n        vec4 res = cloudSDF(pos);\n        float h = res.x;\n        grad = res.yzw;\n\t\tif( abs(h)<(0.000005*t) || t>tmax ) break;\n\t\tt += 0.4 * h;\n\t}\n\n\treturn t;\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd, in float mint) {\n    float res = 1.0;\n    float t = mint;\n    for(int i=0; i<32; i++) {\n        vec3  pos = ro + t*rd;\n        float  env = terrainL(pos.xz);\n        float h = pos.y - env;\n        res = min(res, 12.0*h/t);\n        // if occlusion or maximum height reached -> end\n        if(res<0.0001 || pos.y>2000.0) break;\n        t += clamp( h, 2.0+t*0.1, 100.0 );\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nconst float kMaxT = 5000.0;\n\n// -----------------colors--------------------\nconst vec3 skyBlue = vec3(0.3,0.5,0.85);\nconst vec3 sandBrown = vec3(0.76, 0.7, 0.5);\nconst vec3 grassGreen = vec3(0.2, 0.25, 0.0);\nconst vec3 cloudWhite = vec3(0.9, 0.9, 0.9);\nconst vec3 sunGold = vec3(1.0, 0.93, 0.18);\nconst vec3 generalGray = vec3(0.3, 0.3, 0.3);\n// -------------------------------------------\n\n\nvec4 render(in vec3 ro, in vec3 rd, in float vy) {\n    vec3 sun = vec3(-0.624695,0.468521,-0.624695);\n    // bounding plane\n    float tmin = 1.0;\n    float tmax = kMaxT;\n    \n    float maxh = 2000.0;\n    float tp = (maxh-ro.y)/rd.y; // time to reach max height\n    if(tp > 0.0) {\n        if( ro.y>maxh ) // if camera above max height -> tmin starts a max height plane\n            tmin = max( tmin, tp );\n        else // if below -> tmax stops at max height plane\n            tmax = min( tmax, tp );\n    }\n    \n    // output color\n\tvec3 col;\n    // an interpolation factor\n    float lambda;\n    \n    // raymarching\n    vec3 cloudGrad;\n    float tc = raymarchCloud(ro, rd, tmin, 3.0*tmax, cloudGrad);\n    float tt = raymarchTerrain(ro, rd, tmin, tmax);\n    \n    if(tt > tmax && tc > 3.0 * tmax) {\n        // ---------------sky with color gradient------------\n        col = skyBlue - 0.15 * vy;\n        \n        // --------------cloud plane at y=1500----------------\n        float ct = (1000.0 - ro.y) / rd.y;\n        vec2 x = vec2(ro.x + rd.x * ct, ro.z + rd.z * ct);\n        lambda = 0.4 * smoothstep(-0.1, 0.5, 0.004 * terrainM(0.9 * x));\n        col = (1.0 - lambda) * col + lambda * cloudWhite; \n\t} else if (tc < 3.0*tmax && tt > tmax) {\n        // --------------cloud box at y = 800------------------\t\t\n\t\tvec3 pos = ro + tc * rd;\n        vec3 nor = normalize(cloudGrad);\n        \n        vec3 material = cloudWhite;\n        \n        vec3 lighting = vec3(0.0);\n        // diffuse\n        lighting += clamp(0.7 + 0.2*dot(nor, sun), 0.0, 1.0);\n        // ambient from sky\n        lighting += 0.5 * (1.0 + nor.y) * skyBlue;\n        // ambient from terrain\n        lighting += 0.1 * (1.0 - nor.y) * grassGreen;\n        \n        col = material * lighting;\n        \n        //highlight\n        col += pow(clamp(dot(sun, rd), 0.0, 1.0), 52.0) * sunGold;\n        \n        // color decay for depth\n        lambda = exp(-0.0001 * tc);\n        col = lambda * col + (1.0 - lambda) * generalGray;\n    } else if (tt < tmax && tt < tc){\t\t\n\t\tvec3 pos = ro + tt * rd;\n        vec3 nor = calcNormal(pos, tt);\n        \n        // ---------------------sand + grass------------------\n        lambda = smoothstep(0.8, 1.0, nor.y);\n        vec3 material = (1.0 - lambda) * sandBrown + lambda * grassGreen;\n        \n        vec3 lighting = vec3(0.0);\n        \n        float shadow;\n        // shadow from terrain\n        shadow = softShadow(pos + vec3(0.0, 0.02, 0.0), sun, 0.02);\n        // shadow from cloud\n        vec3 q = pos + sun * (800.0 - pos.y) / sun.y; // cloud plane intersection\n        float d = cloudSDF(q).x;\n        shadow *= smoothstep(-60.0, 10.0, d);\n        \n        \n        // diffuse\n        lighting += clamp(dot(nor, sun), 0.0, 1.0) * shadow;\n        // ambient from sky\n        lighting += 0.05 * (1.0 + nor.y) * skyBlue;\n        // ambient from terrain\n        lighting += 0.05 * sandBrown * clamp(dot(nor, -sun), 0.0, 1.0);\n        \n        col = material * lighting;\n        \n        // highlight\n        vec3 r = 2.0 * nor * dot(nor, sun) - sun;\n        float fr = 0.05 + 0.95 * pow(1.0 - sqrt((1.0 + clamp(dot(sun, -rd), 0.0, 1.0)) / 2.0), 5.0);\n        col += pow(clamp(dot(r, -rd), 0.0, 1.0), 9.0) * clamp(dot(nor, sun), 0.0, 1.0) * fr;\n        \n        \n        // color decay for depth\n        lambda = exp(-0.0005 * tt);\n        col = lambda * col + (1.0 - lambda) * generalGray;\n        \n\t}\n    \n    // sun glare\n    col += pow(clamp(dot(rd, sun), 0.0, 1.0), 4.0) * sunGold / 8.0;\n    \n    // gamma\n\tcol = sqrt(col);\n    \n\treturn vec4( col, tt );\n}\n\nvec3 camPath(float time) {\n\treturn 1100.0*vec3( cos(0.0+0.23*time), 0.0, cos(1.5+0.21*time) );\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, in float cr) {\n    // camera pointing axis (the roll axis)\n\tvec3 cw = normalize(ta-ro);\n    \n    // roll around z axis \n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n    \n    // (the pitch axis)\n\tvec3 cu = normalize( cross(cw,cp) );\n    // (the yaw axis)\n\tvec3 cv = normalize( cross(cu,cw) );\n    \n    return mat3( cu, cv, cw );\n}\n\nvoid moveCamera(float time, out vec3 oRo, out vec3 oTa, out float oCr, out float oFl) {\n\tvec3 ro = camPath( time );\n\tvec3 ta = camPath( time + 3.0 );\n    \n    // yaw and pitch\n\tro.y = terrainL( ro.xz ) + 40.0; // elevate camera above terrain\n\tta.y = ro.y - 40.0; // pointing at the terrain position 3 sec later\n    \n    // roll\n\tfloat cr = 0.05*cos(0.1*time);\n    oRo = ro;\n    oTa = ta;\n    oCr = cr;\n    oFl = 3.0;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float time = iTime*0.1 - 0.1 + 0.3 + 4.0*iMouse.x/iResolution.x;\n\n    // camera position\n    vec3 ro, ta; float cr, fl;\n    moveCamera(time, ro, ta, cr, fl);\n\n    // camera2world transform    \n    mat3 cam = setCamera(ro, ta, cr);\n\n    // bring range between -1 and 1\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    float t = kMaxT;\n    vec3 tot = vec3(0.0); \n    vec2 s = p;\n\n    // pathtracing    \n    vec3 rd = cam * normalize(vec3(s,fl));\n\n    vec4 res = render(ro, rd, p.y);\n    t = min(t, res.w);\n \n    tot += res.xyz;\n    \n    fragColor = vec4(tot, 0.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}