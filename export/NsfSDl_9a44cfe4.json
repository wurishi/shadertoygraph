{"ver":"0.1","info":{"id":"NsfSDl","date":"1619406570","viewed":130,"name":"Schrödinger's/Probabilistic GoL","username":"dan9er","description":"Click to \"observe\" superpositioned cells and collapse their state.\nSee Buffer A for details.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["2d","simulation","automata","life","conway","gameoflife","multipass"],"hasliked":0,"parentid":"XstGRf","parentname":"GameOfLife"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by inigo quilez - iq/2016\n// Forked by dan9er/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord),0).xxx,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by inigo quilez - iq/2016\n// Forked by dan9er/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n// Schrödinger's/Probabilistic Game of Life\n// An extension of Conway's GoL.\n\n// expression defining the cell's new state\n// float c_0 - cell's previous state\n// float n[8] - cell's neighbours\n// float calc_2(n) - probability that exactly 2 neighbours are alive\n// float calc_3(n) - probability that exactly 3 neighbours are alive\n#define STATE_EXPR (c_0 * calc_2(n)) + calc_3(n)\n\n// click to \"observe\" superpositioned cells and collapse their state\n// observation brush size:\n#define BRUSH_SIZE 20.0\n\n/*  (Explaination, ends at line 53)\n\n    Instead of 2 boolean states (alive & dead), each cell is represented by a\n    real number in the range [0-1], which is a continuum between those 2 states.\n    This real number is the \"probability\" that this cell is alive.\n\n    Instead of counting the # of alive neighbours, each cell calculates the\n    probability that # neighbours are alive using this recursive function:\n    float calc(int i, int j, in float n[8])\n    {\n        if (i == 0)\n        {\n            if (j == 0)\n                return 1.0 - n[0];\n            else if (j == 1)\n                return n[0];\n            else\n                return 0.0;\n        }\n        else if (j == 0)\n            return (1.0 - n[i]) * calc(i-1,0,n);\n        else\n            return (n[i] * calc(i-1,j-1,n)) + ((1.0 - n[i]) * calc(i-1,j,n));\n    }\n\n    Sadly, GLSL doesn't support recursive functions, so calc_2(n) and calc_3(n)\n    below are manual unrollings of calc(7,2,n) and calc(7,3,n), respectively.\n\n    After that, the default (see STATE_EXPR above) rules are the same:\n    - If alive, stay alive if 2 or 3 live neighbors\n    - If dead, become alive if 3 live neighbours\n    - Otherwise, die/stay dead\n    Again, instead of strict states, we deal with probabilites, including the\n    probability that the cell was alive or not.\n*/\n\n// gets the state of a cell\nfloat Cell(in ivec2 p)\n{\n    // handle wrapping\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n\n    // fetch pixel from iChannel0\n    return texelFetch(iChannel0, p, 0).x;\n}\n\n// rng\nfloat hash1(float n)\n    {return fract(sin(n)*iDate.w);}\nfloat rng(in vec2 n)\n    {return hash1(n.x*13.0 + hash1(n.y*71.1));}\n\n// calculates probability of 2 cells in n being alive\nfloat calc_2(in float n[8])\n    {return (n[7] * ((n[6] * ((1.0 - n[5]) * ((1.0 - n[4]) * ((1.0 - n[3]) * ((1.0 - n[2]) * ((1.0 - n[1]) * (1.0 - n[0]))))))) + ((1.0 - n[6]) * ((n[5] * ((1.0 - n[4]) * ((1.0 - n[3]) * ((1.0 - n[2]) * ((1.0 - n[1]) * (1.0 - n[0])))))) + ((1.0 - n[5]) * ((n[4] * ((1.0 - n[3]) * ((1.0 - n[2]) * ((1.0 - n[1]) * (1.0 - n[0]))))) + ((1.0 - n[4]) * ((n[3] * ((1.0 - n[2]) * ((1.0 - n[1]) * (1.0 - n[0])))) + ((1.0 - n[3]) * ((n[2] * ((1.0 - n[1]) * (1.0 - n[0]))) + ((1.0 - n[2]) * ((n[1] * (1.0 - n[0])) + ((1.0 - n[1]) * n[0]))))))))))))) + ((1.0 - n[7]) * ((n[6] * ((n[5] * ((1.0 - n[4]) * ((1.0 - n[3]) * ((1.0 - n[2]) * ((1.0 - n[1]) * (1.0 - n[0])))))) + ((1.0 - n[5]) * ((n[4] * ((1.0 - n[3]) * ((1.0 - n[2]) * ((1.0 - n[1]) * (1.0 - n[0]))))) + ((1.0 - n[4]) * ((n[3] * ((1.0 - n[2]) * ((1.0 - n[1]) * (1.0 - n[0])))) + ((1.0 - n[3]) * ((n[2] * ((1.0 - n[1]) * (1.0 - n[0]))) + ((1.0 - n[2]) * ((n[1] * (1.0 - n[0])) + ((1.0 - n[1]) * n[0]))))))))))) + ((1.0 - n[6]) * ((n[5] * ((n[4] * ((1.0 - n[3]) * ((1.0 - n[2]) * ((1.0 - n[1]) * (1.0 - n[0]))))) + ((1.0 - n[4]) * ((n[3] * ((1.0 - n[2]) * ((1.0 - n[1]) * (1.0 - n[0])))) + ((1.0 - n[3]) * ((n[2] * ((1.0 - n[1]) * (1.0 - n[0]))) + ((1.0 - n[2]) * ((n[1] * (1.0 - n[0])) + ((1.0 - n[1]) * n[0]))))))))) + ((1.0 - n[5]) * ((n[4] * ((n[3] * ((1.0 - n[2]) * ((1.0 - n[1]) * (1.0 - n[0])))) + ((1.0 - n[3]) * ((n[2] * ((1.0 - n[1]) * (1.0 - n[0]))) + ((1.0 - n[2]) * ((n[1] * (1.0 - n[0])) + ((1.0 - n[1]) * n[0]))))))) + ((1.0 - n[4]) * ((n[3] * ((n[2] * ((1.0 - n[1]) * (1.0 - n[0]))) + ((1.0 - n[2]) * ((n[1] * (1.0 - n[0])) + ((1.0 - n[1]) * n[0]))))) + ((1.0 - n[3]) * ((n[2] * ((n[1] * (1.0 - n[0])) + ((1.0 - n[1]) * n[0]))) + ((1.0 - n[2]) * ((n[1] * n[0])))))))))))));}\n\n// calculates probability of 3 cells in n being alive\nfloat calc_3(in float n[8])\n    {return (n[7] * ((n[6] * ((n[5] * ((1.0 - n[4]) * ((1.0 - n[3]) * ((1.0 - n[2]) * ((1.0 - n[1]) * (1.0 - n[0])))))) + ((1.0 - n[5]) * ((n[4] * ((1.0 - n[3]) * ((1.0 - n[2]) * ((1.0 - n[1]) * (1.0 - n[0]))))) + ((1.0 - n[4]) * ((n[3] * ((1.0 - n[2]) * ((1.0 - n[1]) * (1.0 - n[0])))) + ((1.0 - n[3]) * ((n[2] * ((1.0 - n[1]) * (1.0 - n[0]))) + ((1.0 - n[2]) * ((n[1] * (1.0 - n[0])) + ((1.0 - n[1]) * n[0]))))))))))) + ((1.0 - n[6]) * ((n[5] * ((n[4] * ((1.0 - n[3]) * ((1.0 - n[2]) * ((1.0 - n[1]) * (1.0 - n[0]))))) + ((1.0 - n[4]) * ((n[3] * ((1.0 - n[2]) * ((1.0 - n[1]) * (1.0 - n[0])))) + ((1.0 - n[3]) * ((n[2] * ((1.0 - n[1]) * (1.0 - n[0]))) + ((1.0 - n[2]) * ((n[1] * (1.0 - n[0])) + ((1.0 - n[1]) * n[0]))))))))) + ((1.0 - n[5]) * ((n[4] * ((n[3] * ((1.0 - n[2]) * ((1.0 - n[1]) * (1.0 - n[0])))) + ((1.0 - n[3]) * ((n[2] * ((1.0 - n[1]) * (1.0 - n[0]))) + ((1.0 - n[2]) * ((n[1] * (1.0 - n[0])) + ((1.0 - n[1]) * n[0]))))))) + ((1.0 - n[4]) * ((n[3] * ((n[2] * ((1.0 - n[1]) * (1.0 - n[0]))) + ((1.0 - n[2]) * ((n[1] * (1.0 - n[0])) + ((1.0 - n[1]) * n[0]))))) + ((1.0 - n[3]) * ((n[2] * ((n[1] * (1.0 - n[0])) + ((1.0 - n[1]) * n[0]))) + ((1.0 - n[2]) * ((n[1] * n[0]))))))))))))) + ((1.0 - n[7]) * ((n[6] * ((n[5] * ((n[4] * ((1.0 - n[3]) * ((1.0 - n[2]) * ((1.0 - n[1]) * (1.0 - n[0]))))) + ((1.0 - n[4]) * ((n[3] * ((1.0 - n[2]) * ((1.0 - n[1]) * (1.0 - n[0])))) + ((1.0 - n[3]) * ((n[2] * ((1.0 - n[1]) * (1.0 - n[0]))) + ((1.0 - n[2]) * ((n[1] * (1.0 - n[0])) + ((1.0 - n[1]) * n[0]))))))))) + ((1.0 - n[5]) * ((n[4] * ((n[3] * ((1.0 - n[2]) * ((1.0 - n[1]) * (1.0 - n[0])))) + ((1.0 - n[3]) * ((n[2] * ((1.0 - n[1]) * (1.0 - n[0]))) + ((1.0 - n[2]) * ((n[1] * (1.0 - n[0])) + ((1.0 - n[1]) * n[0]))))))) + ((1.0 - n[4]) * ((n[3] * ((n[2] * ((1.0 - n[1]) * (1.0 - n[0]))) + ((1.0 - n[2]) * ((n[1] * (1.0 - n[0])) + ((1.0 - n[1]) * n[0]))))) + ((1.0 - n[3]) * ((n[2] * ((n[1] * (1.0 - n[0])) + ((1.0 - n[1]) * n[0]))) + ((1.0 - n[2]) * ((n[1] * n[0]))))))))))) + ((1.0 - n[6]) * ((n[5] * ((n[4] * ((n[3] * ((1.0 - n[2]) * ((1.0 - n[1]) * (1.0 - n[0])))) + ((1.0 - n[3]) * ((n[2] * ((1.0 - n[1]) * (1.0 - n[0]))) + ((1.0 - n[2]) * ((n[1] * (1.0 - n[0])) + ((1.0 - n[1]) * n[0]))))))) + ((1.0 - n[4]) * ((n[3] * ((n[2] * ((1.0 - n[1]) * (1.0 - n[0]))) + ((1.0 - n[2]) * ((n[1] * (1.0 - n[0])) + ((1.0 - n[1]) * n[0]))))) + ((1.0 - n[3]) * ((n[2] * ((n[1] * (1.0 - n[0])) + ((1.0 - n[1]) * n[0]))) + ((1.0 - n[2]) * ((n[1] * n[0]))))))))) + ((1.0 - n[5]) * ((n[4] * ((n[3] * ((n[2] * ((1.0 - n[1]) * (1.0 - n[0]))) + ((1.0 - n[2]) * ((n[1] * (1.0 - n[0])) + ((1.0 - n[1]) * n[0]))))) + ((1.0 - n[3]) * ((n[2] * ((n[1] * (1.0 - n[0])) + ((1.0 - n[1]) * n[0]))) + ((1.0 - n[2]) * ((n[1] * n[0]))))))) + ((1.0 - n[4]) * ((n[3] * ((n[2] * ((n[1] * (1.0 - n[0])) + ((1.0 - n[1]) * n[0]))) + ((1.0 - n[2]) * ((n[1] * n[0]))))) + ((1.0 - n[3]) * ((n[2] * ((n[1] * n[0])))))))))))));}\n\n// run for every pixel, every frame\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // get pixel location\n    ivec2 px = ivec2(fragCoord);\n\n    // get cell's status\n    float c_0 = Cell(px);\n\n    // get cell's neighbours status\n    float n[8];\n\tn[0] = Cell(px+ivec2(-1,-1));\n    n[1] = Cell(px+ivec2( 0,-1));\n    n[2] = Cell(px+ivec2( 1,-1));\n    n[3] = Cell(px+ivec2(-1, 0));\n    n[4] = Cell(px+ivec2( 1, 0));\n    n[5] = Cell(px+ivec2(-1, 1));\n    n[6] = Cell(px+ivec2( 0, 1));\n    n[7] = Cell(px+ivec2( 1, 1));\n\n    // on first frame, generate random noise\n    if (iFrame == 0)\n        fragColor.x = smoothstep(0.844,0.846, rng(fragCoord));\n    else\n    {\n        // cell's next state\n        // clamp is for preventing occasional boxes of death (prob nan or inf)\n        float c = clamp(STATE_EXPR,0.,1.);\n\n        // superposition collapsing mouse brush\n        // mouse condition pinched off https://www.shadertoy.com/view/ld3Sz7\n        if (distance(iMouse.xy, fragCoord) < BRUSH_SIZE && iMouse.z > .0)\n            c = float(c > rng(fragCoord));\n\n        // set pixel\n        fragColor.x = c;\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}