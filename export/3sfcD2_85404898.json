{"ver":"0.1","info":{"id":"3sfcD2","date":"1585988218","viewed":171,"name":"Basic raymarch","username":"SomeGuy","description":"My first attempt at Raymarching in ShaderToy. Currently just trying to get my head around the basic techniques. Inspired to learn this stuff by the incredible work of guys like Evvvvil, Nusan and Shane.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//-------------------------------------------------------------------\n// Trying out ShaderToy and trying to get to grips with ray marching.\n// Inspired by the amazing creations of Evvvvil, Nusan and Shane\n//-------------------------------------------------------------------\n\n#define MD 30.\t\t// max distance\n#define SD 0.001    // surface distance\n#define MS 100      // max number of steps to march\n#define EPS 0.005   // distance used for sampling the gradient\n\nfloat time;\n\n// always handy to have PI available\nconst float PI = acos(-1.);\nconst float TWOPI = 2.*PI;\n\n// fog color.\nconst vec3 fog = vec3(.01,.1,.01);\n// base camera position\nconst vec4 cam = vec4(0,1,3,1);\n\n\n// distance functions\n// sphere\nfloat sph(vec3 p, float r){return length(p)-r;}\n\n// cylinder\nfloat cyl(vec2 p, float r){return length(p)-r;}\n\n// box\nfloat box(vec3 p, vec3 b){p=abs(p)-b; return max(max(p.x,p.y),p.z);}\n\n\n// helper for doing min with material\nvec2 mmin(vec2 a, vec2 b) {return a.x < b.x ? a:b;}\n\n// 2d rotation matrix\nmat2 rot(float a) {\n    float c=cos(a), s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\n// the SDF for the scene\nvec2 map(vec3 p) {\n\tp.xz *= rot(time/2.);\n    vec2 s = vec2(sph(p-vec3(0,.5,0),.5), 5.);\n    vec2 c = vec2(cyl(p.xz,.2), 6.);\n    vec2 b = vec2(box(p-vec3(0,-.5,0), vec3(.6,.3,.6)),1.);\n    \n    return mmin(mmin(s,c),b);\n}\n\n// determine the normal at point p by sampling the gradient of the SDF\nvec3 normal(vec3 p) {\n \tvec2 off = vec2(EPS, 0.);\n    return normalize(map(p).x - vec3(map(p-off.xyy).x,map(p-off.yxy).x,map(p-off.yyx).x));\n}\n\n//-------------------------------------------------------------\n// lighting and colour,\n// heavily based on Evvvvil's Micro Lighting Engine Broski (TM)\n//-------------------------------------------------------------\n\n// shortcuts for calculating fake ambient occlusion and subsurface scattering\n#define aoc(d) clamp(map(p + n * d).x/d, 0., 1.)\n#define sss(d) smoothstep(0.,1.,map(p+ld*d).x/d)\n\nvec3 surface(vec3 ro, vec3 rd, vec2 hit) {\n\t// albedo, or base color, based on material ID\t\n    vec3 al = hit.y < 5. ? vec3(0) : hit.y > 5. ? vec3(1) : vec3(.1,.2,.4);\n    \n    float d=hit.x;         // distance from ray origin\n    vec3 p = ro + rd * d;  // the point in space\n    vec3 n = normal(p);    // normal of the SDF at point p\n    \n    vec3 ld = normalize(vec3(-1));     // light direction\n    float diff = max(0., dot(n, -ld)); // diffuse illumination\n    \n    vec3 lr = reflect(ld, n);          // reflected light ray\n    float spec = pow(max(0., dot(lr,-rd)),32.);   // specular illumination\n    \n    float frz = pow(max(0., 1. - dot(n,-rd)),4.); // freznel)\n\t\n    float ao = aoc(.2); // fake AO\n    float ss = sss(.5); // fake subsurface scattering\n    \n    vec3 col =  al * ao * (diff + ss) + spec; // combine it all together\n    col = mix(col, fog, min(frz,.1));         // fog the edges\n    \n    return col; // the final color\n}\n\n// ray marching loop\nvec3 march(vec3 ro, vec3 rd) {\n\tfloat dd=0.1;\t\t// start with a slight z offset\n    vec3 col=vec3(0);   // no color initially\n    vec3 p=ro + rd * dd;// current point\n    \n    for(int i=0; i<MS; ++i) {  // start marching\n     \tvec2 d = map(p);  // distance to SDF\n    \n        if(d.x < SD) { // close to a surface\n            // get the color of the surface\n            col += d.y > 0. ? surface(ro, rd, vec2(dd, d.y)) : vec3(0.);\n            break; // we're done\n        }\n        \n        if(dd > MD) { // we've reached the max draw distance,\n            dd = MD;  // store it\n            break;    // and we're done\n        }\n        \n        dd += d.x;     // track the total distance\n        p += rd * d.x; // and update the current position\n    }\n    \n    // blend in some distance-based fog and return\n    return mix(fog, col, exp(-0.0005*dd*dd));\n}\n\n\n// given the ray origin, lookat point and uv's, calculate the ray direction\nvec3 raydir(vec3 ro, vec3 la, vec2 uv) {\n    // x,y and z axes\n    vec3 cz = normalize(la-ro);\n    vec3 cx = normalize(cross(cz,vec3(0,1,0)));\n    vec3 cy = normalize(cross(cx,cz));\n    // project and normalize\n    return normalize(cx*uv.x + cy*uv.y + cz);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    // make sure that the pixels are square\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    // get rid of some artifacts\n    time = mod(iTime, 63.39);\n    \n    // setup the ray\n    vec3 ro = cam.xyz * cam.w;\n    vec3 rd = raydir(ro, vec3(0), uv);\n    \n    // march\n    vec3 col = march(ro, rd);\n\n    // exposure\n    col = vec3(1) - exp(-col * 1.);\n    // gamma\n    col = pow(col, vec3(1./2.2));\n    // final color\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}