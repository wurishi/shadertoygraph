{"ver":"0.1","info":{"id":"43lfW4","date":"1728400747","viewed":59,"name":"Light Spreading over time","username":"FrederickAmpsUp","description":"Forked from my template path tracer. I'm fairly happy with the results, although moving objects wouldn't work.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","template","pathtracing","sampling","mis","importance"],"hasliked":0,"parentid":"43BczG","parentname":"MIS Path Tracing template"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 denoise(sampler2D tex, ivec2 coord) {\n    float total_luminance = 0.0;\n    vec3 total_color = vec3(0.0);\n    float total_weight = 0.0;\n    \n    const int search_size = 7;\n    \n    for (int i = -search_size; i <= search_size; i++) {\n        for (int j = -search_size; j <= search_size; j++) {\n            if (i == 0 && j == 0) continue;\n            \n            float dst = length(vec2(i, j) / float(search_size));\n            \n            float weight = exp(-4.0*(dst*dst));\n            \n            vec3 col = texelFetch(tex, coord+ivec2(i, j), 0).xyz;\n            float lum = length(col);\n            \n            total_luminance += lum * weight;\n            total_color += col * weight;\n            total_weight += weight;\n        }\n    }\n    \n    float average_luminance = total_luminance / total_weight;\n    vec3 average_color = total_color / total_weight;\n    \n    vec3 center = texelFetch(tex, coord, 0).xyz;\n    float center_luminance = length(center);\n\n    center /= center_luminance;\n\n    float lum_diff = (center_luminance-average_luminance);\n    center *= mix(center_luminance, average_luminance, clamp(lum_diff, 0.0, 1.0));\n    \n    return center;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = denoise(iChannel0, ivec2(fragCoord)).xyz;\n    //col = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n    \n    col = fbct_transform(col);\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#ifdef GL_ES\nprecision highp float;\n#endif\n\n/** \n * Constants and definitions\n */\nconst float INFINITY = 99999999999999.9;\nconst float PI = 3.14159265;\n\nconst int N_BOUNCES = 3;\nconst int N_SAMPLES_PER_FRAME = 5;\n\nconst vec3 WORLD_UP = vec3(0, 1, 0);\n\n// end constants and definitions\n\n/** \n * RNG stuff from https://www.mattkeeter.com/projects/rayray/\n */\n\n// global seed\nuint seed;\n\n// slow but good hash (used to generate initial seed)\nuint hash(uint key) {\n    uint h = 0u;\n    for (int i = 0; i < 4; ++i) {\n        h += (key >> uint(i * 8)) & 0xFFu;\n        h += h << 10;\n        h ^= h >> 6;\n    }\n    h += h << 3;\n    h ^= h >> 11;\n    h += h << 15;\n    return h;\n}\n\n// unique id for every pixel\nuint gen_seed(int frame, ivec2 fragCoord, ivec2 resolution) {\n    return hash(uint(frame * resolution.x * resolution.y + fragCoord.y * resolution.x + fragCoord.x));\n}\n\n// mutates seed, thus can be called multiple times for multiple values\nfloat rand1(inout uint seed) {\n    // 32-bit LCG Multiplier from\n    // \"Computationally Easy, Spectrally Good Multipliers for\n    // Congruential Pseudorandom Number Generators\" [Steele + Vigna]\n    seed = 0xadb4a92du * seed + 1u;\n\n    // Low bits have less randomness [L'ECUYER '99], so we'll shift the high\n    // bits into the mantissa position of an IEEE float32, then mask with\n    // the bit-pattern for 2.0\n    uint m = (seed >> 9) | 0x40000000u;\n\n    // floating-point bit magic\n    float f = uintBitsToFloat(m); // Range [2:4]\n    return f / 2.0 - 1.0; // Range [0:1]\n}\n\nfloat rand1() {\n    return rand1(seed);\n}\n\nvec2 rand2(inout uint seed) {\n    return vec2(rand1(seed), rand1(seed));\n}\n\nvec2 rand2() {\n    return rand2(seed);\n}\n\nvec3 rand3(inout uint seed) {\n    return vec3(rand1(seed), rand1(seed), rand1(seed));\n}\n\nvec3 rand3() {\n    return rand3(seed);\n}\n\nvec4 rand4(inout uint seed) {\n    return vec4(rand1(seed), rand1(seed), rand1(seed), rand1(seed));\n}\n\nvec4 rand4() {\n    return rand4(seed);\n}\n\n// rejection sampling\nvec3 rand_in_unit_sphere() {\n    vec3 s;\n    do {\n        s = rand3() * 2.0 - 1.0;\n    } while(dot(s, s) > 1.0);\n    return s;\n}\n\n// essentially faceforward\nvec3 rand_in_hemisphere(vec3 hemis_normal) {\n    vec3 s = rand_in_unit_sphere();\n    return s * sign(dot(s, hemis_normal));\n}\n\n// normalized\nvec3 rand_on_hemisphere(vec3 hemis_normal) {\n    return normalize(rand_in_hemisphere(hemis_normal));\n}\n\n// end rng stuff\n\n/** \n * Structures and utilities\n */\n\n// Mathematical ray\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\n// Get a point on the ray using the ray parametric equation o+dt\nvec3 Ray_at(Ray r, float t) {\n    return r.origin + r.direction * t;\n}\n\n// Hit information for where a ray hits the scene\nstruct RayHit {\n    bool did_hit;\n    float t;\n    vec3 position, normal;\n    int mat_id;\n};\n\n// \"Empty\" ray hit\nconst RayHit RAYHIT_NULL = RayHit(false, INFINITY, vec3(0.0), vec3(0.0), 0);\n\n// materials\nstruct Material {\n    vec3 albedo;\n    vec3 emission;\n};\n\nconst Material MATERIAL_NULL = Material(vec3(0.0), vec3(0.0));\nconst int MATERIAL_RED = 1;\nconst int MATERIAL_WHITE = 2;\nconst int MATERIAL_WHITE_LIGHT = 3;\nconst int MATERIAL_GREEN = 4;\n\nvoid Material_fromid(out Material mat, int id) {\n    mat = MATERIAL_NULL;\n    if (id == MATERIAL_RED) {\n        mat.albedo = vec3(0.8, 0.2, 0.2);\n        mat.emission = vec3(0);\n    }\n    if (id == MATERIAL_WHITE) {\n        mat.albedo = vec3(0.8, 0.8, 0.8);\n        mat.emission = vec3(0);\n    }\n    if (id == MATERIAL_WHITE_LIGHT) {\n        mat.albedo = vec3(0.0);\n        mat.emission = vec3(5.0);\n    }\n    if (id == MATERIAL_GREEN) {\n        mat.albedo = vec3(0.2, 0.8, 0.2);\n        mat.emission = vec3(0);\n    }\n}\n\n// end structures and utilities\n\n/** \n * Scene definition\n */\n\n// Sphere object with material ID\nstruct Sphere {\n    vec3 center;\n    float radius;\n    int mat_id;\n} scene_spheres[] = Sphere[] (\n    // Floor\n    Sphere(vec3(0, -1000.5, 0), 1000.0, MATERIAL_WHITE),\n    \n    // Left wall (red)\n    Sphere(vec3(-1000.75, 0, 0), 1000.0, MATERIAL_RED),\n    \n    // Right wall (green)\n    Sphere(vec3(1000.75, 0, 0), 1000.0, MATERIAL_GREEN),\n    \n    // Back wall (white)\n    Sphere(vec3(0, 0, 1001.5), 1000.0, MATERIAL_WHITE),\n    \n    // Light source (top)\n    Sphere(vec3(0, 0.7, 1.5), 0.2, MATERIAL_WHITE_LIGHT),\n    \n    Sphere(vec3(0, -0.25, 1), 0.25, MATERIAL_WHITE)\n);\n\n// comment out if no spheres are being importance sampled\n#define IS_SPHERES\n\n#ifdef IS_SPHERES\n\n// list of indices in the spheres array to importance sample. THIS IS NOT BOUND CHECKED, DON'T GPU SEGFAULT!!\nint IS_spheres[] = int[](\n    4\n);\n#endif\n\nbool ray_sphere(Ray r, Sphere s, out RayHit info) {\n    vec3 oc = s.center - r.origin;\n    float a = dot(r.direction, r.direction);\n    float h = dot(r.direction, oc);\n    float c = dot(oc, oc) - s.radius * s.radius;\n    float discriminant = h * h - a * c;\n\n    if (discriminant < 0.0) {\n        info = RAYHIT_NULL;\n        return false;\n    } else {\n        info.t = (h - sqrt(discriminant)) / a;\n        info.did_hit = info.t > 0.0;\n        info.position = Ray_at(r, info.t);\n        info.normal = (info.position - s.center) / s.radius;\n        info.mat_id = s.mat_id;\n        return info.did_hit;\n    }\n}\n\nstruct Camera {\n    vec3 forward, right, up;\n    vec3 eye;\n    float focal_length;\n};\n\nvoid Camera_lookat(inout Camera cam, vec3 lookfrom, vec3 lookat) {\n    cam.forward = normalize(lookat - lookfrom);\n    cam.right = -normalize(cross(cam.forward, WORLD_UP));\n    cam.up = cross(cam.forward, cam.right);\n    cam.eye = lookfrom;\n}\n\nvoid Camera_vfov(inout Camera cam, float fov_radians) {\n    cam.focal_length = 2.0 * tan(0.5 / fov_radians);\n}\n\nRay Camera_raygen(in Camera cam, vec2 aspect_ndc) {\n    vec3 origin = cam.eye;\n    vec3 direction = cam.forward * cam.focal_length + cam.right * aspect_ndc.x + cam.up * aspect_ndc.y;\n    return Ray(origin, direction);\n}\n\n// TODO: triangle meshes and possibly SDF geometry\n\n// end scene definition\n\n/**\n * Importance sampling\n */\n\nvec4 IS_uniform(RayHit inf) {\n    vec3 rd = rand_on_hemisphere(inf.normal);\n    float pdf_value = 1.0 / (2.0 * PI);\n    \n    return vec4(rd, pdf_value);\n}\n\n\nvec4 IS_sphere(Sphere sph, RayHit inf) {\n    vec3 on_sphere = sph.center + sph.radius*normalize(rand_in_unit_sphere());\n    vec3 rd = normalize(on_sphere-inf.position);\n    \n    float numerator = dot(on_sphere-inf.position, on_sphere-inf.position);\n    \n    float area = 4.0 * PI * sph.radius * sph.radius;\n    \n    float cos_theta = abs(dot(rd, inf.normal));\n    \n    if (cos_theta < 0.0001) {\n        cos_theta = 1.0; // avoid infinities\n    }\n    \n    float pdf_value = numerator / (0.5 * area * cos_theta);\n    \n    return vec4(rd, pdf_value);\n}\n\nvec4 PDF_mix(vec4 a, vec4 b) {\n    if (rand1() < 0.5) {\n        return a;\n    } else {\n        return b;\n    }\n}\n// end importance sampling\n\n/** \n * Raytracing functions\n */\n\n// Intersect-test a ray with the scene\nbool ray_scene(Ray r, out RayHit info) {\n    info = RAYHIT_NULL;\n\n    RayHit obj_inf;\n    for (int i = 0; i < scene_spheres.length(); i++) {\n        Sphere sph = scene_spheres[i];\n        if (ray_sphere(r, sph, obj_inf) && (obj_inf.t < info.t || !info.did_hit)) {\n            info = obj_inf;\n        }\n    }\n    return info.did_hit;\n}\n\n// Trace a ray through the scene and accumulate light\nvec3 trace(Ray r, out float t) {\n    RayHit hit;\n    vec3 color = vec3(1.0);\n    vec3 light = vec3(0.0);\n\n    t = 0.0;\n\n    for (int bounce = 0; bounce < N_BOUNCES; bounce++) {\n        if (!ray_scene(r, hit)) {\n            light += color * vec3(0.0); // sky (temporary)\n            break;\n        } else {\n             if (bounce > 0) t += hit.t;\n        \n            Material mat;\n            Material_fromid(mat, hit.mat_id);\n            \n            vec4 importance = IS_sphere(scene_spheres[IS_spheres[0]], hit);\n            vec4 random = IS_uniform(hit);\n            \n            vec4 scatter_pdf = PDF_mix(importance, random);\n            \n            float maxReflectance = max(mat.albedo.r, max(mat.albedo.g, mat.albedo.b));\n            \n            light += color * mat.emission;\n            \n            if (rand1() > maxReflectance || maxReflectance < 0.001) {\n                break;\n            }\n            \n            color *= mat.albedo / (PI * scatter_pdf.w * maxReflectance);\n            \n            r.origin = hit.position + hit.normal * 0.001;\n            r.direction = scatter_pdf.xyz;\n        }\n    }\n    return light;\n}\n\n// end raytracing functions\n\n/*\n * FBCT - Fred's Basic Color Transform\n * https://www.shadertoy.com/view/4XXcDB\n */\n \nconst float FBCT_DESATURATION = 0.02;\nconst float FBCT_EXPOSURE = 1.0;\n\nconst float FBCT_RED_BIAS = 1.0;\nconst float FBCT_GRN_BIAS = 1.0;\nconst float FBCT_BLU_BIAS = 1.0;\n\nconst mat4 fbct_color_matrix = \nmat4(\n    FBCT_RED_BIAS, FBCT_GRN_BIAS*FBCT_DESATURATION, FBCT_BLU_BIAS*FBCT_DESATURATION, 0.00,\n    FBCT_RED_BIAS*FBCT_DESATURATION, FBCT_GRN_BIAS, FBCT_BLU_BIAS*FBCT_DESATURATION, 0.00,\n    FBCT_RED_BIAS*FBCT_DESATURATION, FBCT_GRN_BIAS*FBCT_DESATURATION, FBCT_BLU_BIAS, 0.00,\n    0.0, 0.0, 0.0, FBCT_EXPOSURE\n\n);\n\nvec3 fbct_transform(vec3 color) {\n    vec4 mmr = (vec4(color, 1) * fbct_color_matrix);\n    vec3 cc = mmr.xyz * mmr.w;\n    \n    cc = cc / (cc + 1.0);\n    \n    cc = pow(cc, vec3(1.0 / 2.2));\n\n    return cc;\n}\n\n// End FBCT","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 ndc = uv * 2.0 - 1.0;\n    vec2 acdc = vec2(ndc.x, ndc.y * (iResolution.y / iResolution.x));\n\n    seed = gen_seed(iFrame, ivec2(fragCoord), ivec2(iResolution.xy));\n\n    Camera camera;\n    Camera_lookat(camera, vec3(0), vec3(0, 0, 1));\n    Camera_vfov(camera, radians(90.0));\n\n    Ray camera_ray = Camera_raygen(camera, acdc);\n\n    float t;\n    float s = 0.0;\n    vec3 col = vec3(0.0);\n    \n    for (int i = 0; i < N_SAMPLES_PER_FRAME; i++) {\n        col += trace(camera_ray, t) * step(t, iTime);\n        s += step(t, iTime);\n    }\n    \n    vec4 last = texture(iChannel0, uv);\n    \n    if (any(notEqual(last, last)) || iFrame == 0) last = vec4(0);\n    \n    fragColor = vec4(col + last.xyz, last.w + s);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    vec3 col = data.xyz / data.w;\n    \n    if (data.w == 0.0) col = vec3(0.0);\n    \n    if (col.x != col.x) col.x = 0.0;\n    if (col.y != col.y) col.y = 0.0;\n    if (col.z != col.z) col.z = 0.0;\n    \n    if (col.x > INFINITY) col.x = 1.0;\n    if (col.y > INFINITY) col.y = 1.0;\n    if (col.z > INFINITY) col.z = 1.0;\n\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}