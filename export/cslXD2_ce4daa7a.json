{"ver":"0.1","info":{"id":"cslXD2","date":"1671402192","viewed":171,"name":"¡Argentina campeón del Mundo!","username":"LucasR","description":"TERCERA COPA","likes":10,"published":1,"flags":32,"usePreview":1,"tags":["football","soccer","worldcup","argentina"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// set AA to 0 if the shader is running too slow\n#define AA 2\n#define ZERO (min(iFrame,0))\n\n// set withCover to 0 to remove glass cover\n#define withCover 0\n\n// set multCups to 1 to see the three trophies, to 0 to get only one\n#define multCups 1\n\nvec2 vmin(vec2 a, vec2 b){ // regular min() compares all components, I don't want to compare material IDs\n    return a.x < b.x ? a : b;\n}\n\nvec2 smin( vec2 a, vec2 b, float k ){\n    float h = max( k-abs(a.x-b.x), 0.0 )/k;\n    return vmin( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat smin( float a, float b, float k ){\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat sdSphere( vec3 p, float s ){\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 ){\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ){\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdLady(vec3 pos){\n    vec3 s = vec3(abs(pos.x), pos.y, pos.z);\n    float ld = sdSphere(s-vec3(0., .15, .3), .06); // head\n    ld = smin(ld, sdSphere(s-vec3(0., .1, .35), .04), .05); // jaw\n    ld = smin(ld, sdCapsule(s, vec3(0., 0., .3), vec3(0., .1, .3), .03), .03); // neck\n    // arms\n    ld = min(ld, sdCapsule(s, vec3(.1, 0., .3), vec3(.2, .18, .35), .03));\n    ld = smin(ld, sdCapsule(s, vec3(.21, .21, .35), vec3(.17, .5, .32), .025), .03);\n    \n    ld = smin(ld, sdBox(s-vec3(0., -.2, .3), vec3(.06, .14, .01))-.05, .04); // torso\n    \n    // legs\n    ld = smin(ld, sdCapsule(pos, vec3(-.08, -.35, .3), vec3(-.12, -.503, .35), .045), .03); // upper right\n    ld = smin(ld, sdCapsule(pos, vec3(-.12, -.55, .35), vec3(-.08, -.71, .3), .04), .03); // lower right\n    ld = smin(ld, sdCapsule(pos, vec3(.08, -.35, .3), vec3(.1, -.5, .27), .045), .03); // upper left\n    ld = smin(ld, sdCapsule(pos, vec3(.1, -.55, .27), vec3(.12, -.71, .2), .04), .03); // lower left\n    \n    return ld;\n}\n\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e ){\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdBox( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec2 boxIntersection( in vec3 ro, in vec3 rd, in vec3 rad, out vec3 oN ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    \n    oN = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    return vec2( tN, tF );\n}\n\n\n\n\n// modeling\n\nvec2 map(in vec3 pos){ // signed distance in m.x and material ID in m.y\n#if multCups\n    pos.x = mod(pos.x+1., 2.)-1.;\n#endif\n    float cyl = sdCapsule(pos, vec3(0., -1., 0.), vec3(0., .2, 0.), .2);\n    vec2 m = vec2(cyl, 0.0);\n    if(cyl < 2.8){ // bounding volume\n    m = vec2(sdSphere(pos-vec3(0., .6, 0.), .45), 1.); // globe\n    \n    // continents/countries\n    {\n        float ct = sdBox(pos.xy-vec2(-.15, .8), vec2(.1, .07)); // Canada & upper USA\n        ct = smin(ct, sdBox(pos.xy-vec2(-.05, .68), vec2(.05, .02)), .07); // lower USA\n        ct = smin(ct, sdBox(pos.xy-vec2(-.1, .58), vec2(.01)), .05); // Mexico\n        ct = smin(ct, sdBox(pos.xy-vec2(0., .5), vec2(.05)), .05); // Colombia & Venezuela\n        ct = smin(ct, sdBox(pos.xy-vec2(.1, .35), vec2(.1)), .05); // Brazil\n        ct = smin(ct, sdBox(pos.xy-vec2(.1, .3), vec2(.1)), .05); // Argentina\n        \n        m.x = m.x - 0.035*smoothstep(0.1, 0., ct);\n    }\n    \n    m.x = m.x -(0.0025*( sin(50.*pos.y) - 0.8333*sin(87.*pos.z) )\n              - 0.00125*( sin(93.*pos.y) - 0.4166*sin(127.*pos.z) )\n              - 0.000625*( sin(234.*pos.y) - sin(233.*pos.z) ) ) * 0.5 ; // displacement\n    \n    m.x = min(m.x, sdCappedCone(pos-vec3(0., -.925, 0.), .14, .4, .25)-.02); // bottom\n    m.x = min(m.x, cyl); // center filling\n    \n    \n    // ladies\n    {\n        float c = cos(0.3*pos.y);\n        float s = sin(0.3*pos.y);\n        vec3 lpos = pos;\n        lpos.xz = mat2(c, s, -s, c)*lpos.xz;\n        float ld = sdLady(lpos); // front facing\n        // 120º rotation\n        c = -0.5;\n        s = 0.866;\n        vec3 r = lpos;\n        r.x = -abs(r.x);\n        r.xz = mat2(c, -s, s, c)*r.xz;\n        ld = min(ld, sdLady(r)); // back two ladies\n        m.x = smin(m.x, ld, .01);\n    }\n    \n    m = vmin(m, vec2(sdBox(pos-vec3(0., -1.6, 0.), vec3(0.5))-.02, 2.0)); // pedestal cloth\n    m = vmin(m, vec2(sdBox(pos-vec3(0., -1.785, 0.), vec3(0.65))-.03, 3.0)); // pedestal cement\n#if withCover\n    m = vmin(m, vec2(sdBoxFrame(pos, vec3(.65, 1.1, .65), .005)-.005, 4.0)); // frame\n#endif\n    }\n    return m;\n}\n\n\n\n\n\nvec2 castRay( in vec3 ro, in vec3 rd ){\n    vec2 res = vec2(1000.0, -1.0);\n    float tmin = 0.01;\n    float tmax = 4.5;\n    \n    float t = tmin;\n    for(int i=ZERO; i<256 && t<tmax; i++){\n        vec2 h = map( ro+rd*t );\n        //if( h.x < 0.001 ){\n        //if( abs(h.x)<(0.001*t) ){\n        if( abs(h.x)<0.00022 ){ // cone tracing (*t) added shadow artifacts\n            res = vec2(t, h.y);\n            break;\n        }\n        t += h.x;\n    }\n    return res;\n}\n\n// change between 0 and 1 to test different normal calculation functions\n#if 1\nvec3 calcNormal(vec3 q){ // gscene3 from https://www.shadertoy.com/view/NscXR4\n    float h = 0.001;\n\tvec3 n = vec3(0);\n\tfor (int i = ZERO; i < 4; ++i) {\n\t\tvec3 e = vec3((ivec3(i+3, i, i+i)&2) - 1);\n\t\tn += map(q + e * h).x * e;\n\t}\n\treturn normalize(n);\n}\n#else\nvec3 calcNormal(vec3 p){\n  vec2 e = vec2(1.0, -1.0) * 0.0005;\n  return normalize(\n    e.xyy * map(p + e.xyy).x +\n    e.yyx * map(p + e.yyx).x +\n    e.yxy * map(p + e.yxy).x +\n    e.xxx * map(p + e.xxx).x);\n}\n#endif\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float maxt){\n// source: https://www.shadertoy.com/view/ltyXD3\n    float res = 1.0;\n    float t = mint;\n    \n    for(int i = ZERO; i < 16; i++) {\n        float h = map(ro + rd * t).x;\n        res = min(res, 8.0*h/t);\n        t += clamp(h, 0.02, 0.10);\n        if(h < 0.001 || t > maxt) break;\n    }\n    \n    return clamp( res, 0.0, 1.0 );\n}\n\nvec4 render( in vec3 ro, in vec3 rd ){\n    vec4 col;\n    vec2 res = castRay(ro, rd);\n    vec3 pos = ro+res.x*rd;\n    vec3 n = calcNormal(pos);\n    float spe = 0.;\n    \n    vec3 sunDir = normalize(vec3(0.2, 0.3, 0.2));\n    vec3 sunCol = vec3(1.2, 1.1, 0.8);\n    float sunDif = clamp(dot(n, sunDir), 0.0, 1.0);\n    \n    // materials\n    if(0.5 < res.y){ // not sky\n        col.rgb = vec3(0.);\n        col.a = 1.;\n        if(res.y < 1.5){ // trophy metal\n            // add green stripes to the gold color\n            col.rgb = ((pos.y < -.79) && (pos.y > -.89)) || ((pos.y < -.99) && (pos.y > -1.05)) ?\n                vec3(.1, .8, .2) : vec3(.9, .8, .1);\n            \n            vec3 refRo = pos + n*0.01;\n            vec3 refRd = reflect(rd, n);\n            float RV = clamp(dot(reflect(sunDir, n), rd), 0., 1.);\n            spe = pow(RV, 5.)*.5;\n            vec2 refRes = castRay(refRo, refRd);\n            if(refRes.y < 0.5) // if it doesn't hit anything, reflect cubemap (tinted with surface color)\n                col.rgb *= texture(iChannel0, refRd).rgb;\n            else{ // second reflection\n                vec3 refPos = refRo + refRes.x*refRd;\n                vec3 refN = calcNormal(refPos);\n                refRo = refPos + refN*0.01;\n                refRd = reflect(refRd, refN);\n                refRes = castRay(refRo, refRd);\n                if(refRes.y < 0.5) col.rgb *= .8*texture(iChannel0, refRd).rgb;\n                // could add an else statement for more reflections, but base color is good enough\n            }\n        }else if(res.y < 2.5) col.rgb = vec3(.8, .05, .02); // pedestal cloth\n        else if(res.y < 3.5) col.rgb = vec3(.6, .6, .45); // pedestal cement\n        else if(res.y < 4.5) col.rgb = vec3(.16, .11, .035); // frame\n    \n        float topOcc = softShadow(pos, vec3(0., 1., 0.), 0.02, .5)+0.02;\n        vec3 lin = vec3(0.0);\n        lin += sunDif*sunCol*softShadow(pos, sunDir, 0.02, 1.5); // Sun\n        lin += spe;\n        lin += .02+(0.05+0.95*clamp(n.y, 0.0, 1.0))*vec3(0.2, 0.2, 0.9)*topOcc; // sky\n        \n        col.rgb = col.rgb*lin;\n    }\n    \n    // add glass cover\n#if withCover\n    vec3 bN;\n    vec2 bi = boxIntersection(ro, rd, vec3(.65, 1.105, .65), bN);\n    float RV = clamp(dot(reflect(sunDir, bN), rd), 0., 1.);\n    spe = pow(RV, 5.)*5.;\n    vec3 glCol = vec3(.62, .89, .88);\n    glCol += .8*texture(iChannel0, reflect(rd, bN)).rgb;\n    glCol *= spe;\n    col.rgb = ((bi.x < res.x) && (bi.x > 0.)) ? mix(col.rgb, glCol, .2) : col.rgb;\n#endif\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec4 tot;\n    float time = iTime;\n#if AA > 1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n    vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n    vec2 uv = ((fragCoord+o) - .5 * iResolution.xy) / iResolution.y;\n#else\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n#endif\n    vec3 ro = vec3(0., 0., 3.);\n    vec3 rd = normalize(vec3(uv, -1.));\n    \n// side view -- only intended for testing\n#if 0\n    ro = vec3(3., 0., 0.);\n    rd = rd.zyx;\n#endif\n    \n    /*if(iMouse.z > 0.){ // if LMB is being pressed rotate camera\n        vec2 mouse = (iMouse.xy - .5 * iResolution.xy) / iResolution.y;\n        float cx, cy, sx, sy;\n        cx = cos(mouse.x); cy = cos(mouse.y); sx = sin(mouse.x); sy = sin(mouse.y);\n        rd.yz = mat2(cy, -sy, sy, cy)*rd.yz;\n        rd.xz = mat2(cx, -sx, sx, cx)*rd.xz;\n    }*/\n    \n    vec4 col = render(ro, rd);\n    col.rgb = pow(col.rgb, vec3(0.4545)); // gamma correction\n    tot += col;\n    \n#if AA > 1\n    }\n    tot /= float(AA*AA);\n#endif\n    tot = mix(texture(iChannel1, fragCoord/iResolution.xy), tot, tot.a);\n    fragColor = tot;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const vec3 lBlue = vec3(117., 170., 219.)/255.;\nconst vec3 gold = vec3(252., 191., 73.)/255.;\nconst vec3 brown = vec3(132., 53., 17.)/255.;\nconst float pi = 3.14159265359;\n\nmat2 rot(float theta){ // 2D rotation matrix\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdCircle(vec2 p, float r){\n// source: https://iquilezles.org/articles/distfunctions2d/\n    return length(p) - r;\n}\n\n//float sdStar(in vec2 p, in float r, in int n, in float m){\nfloat sdStar(in vec2 p, in float r){\n// source: https://iquilezles.org/articles/distfunctions2d/\n    // these 4 lines can be precomputed for a given shape\n    /*float an = 3.141593/float(n);\n    float en = 3.141593/m;\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) and simplify, for regular polygon,*/\n    \n    // using n = 16, m = 12.:\n    float an = 0.19634954084;\n    float en = 0.26179938779;\n    vec2 acs = vec2(0.9807852804, 0.19509032201);\n    vec2 ecs = vec2(0.96592582628, 0.2588190451);\n\n    // reduce to first sector\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n\n    // line sdf\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n    float bands = step(.5-1./3., abs(uv.y));\n    vec3 col = (1.-bands) * vec3(1.) + bands * lBlue;\n    \n    float SunMask = sdCircle(uv, 0.05);\n    SunMask = min(SunMask, sdStar(uv, .12));\n    \n    vec2 uvDist = uv; // distort uvs to make curved Sun rays\n    float r = sqrt(uv.x*uv.x + uv.y*uv.y);\n    float theta = atan(uv.y, uv.x);\n    theta += sin(15.*r + .2)*1.;\n    uvDist = vec2(r*cos(theta), r*sin(theta));\n    SunMask = min(SunMask, sdStar(uvDist, .12));\n    \n    col = mix(brown, col, smoothstep(0., 4./iResolution.y, SunMask));\n    col = mix(gold, col, smoothstep(0., 2./iResolution.y, SunMask));\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}