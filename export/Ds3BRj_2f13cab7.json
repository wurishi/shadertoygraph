{"ver":"0.1","info":{"id":"Ds3BRj","date":"1697345218","viewed":23,"name":"GEO experiment - cos f0 - var","username":"davidmachadosf","description":"KEYS\n    \" ' (below ESC) : reset\n  (numlock OFF):\n    ARROWS   : move\n    NUMPAD5  : center 0,0\n    * /      : zoom in/out  \n    + -      : inc/dec zoom vel\n    .        : cicle pallete\n    Home End : +/- cicle vel\n    PgUp PgDown: Cicle 15 diff f(x,y)","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["math"],"hasliked":0,"parentid":"dstBzB","parentname":"GEO experiment - cos func 0"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n  David Machado Santos Filho\n  davidmachadosf@gmail.com\n  \n  Based on openprocessing app:\n  https://openprocessing.org/sketch/1916670\n  (same author)\n  \n  \n  Any suggestion for improvement and inclusion of \n  interesting features is welcome! \n  \n  Feel free to fork the code and test your own ideas! \n  This code is copyleft! ;-)\n  \n*/\n\nfloat n = 5.;\nfloat pi = 3.141592;\nfloat thetax = 0.;\nfloat thetay = .5*3.141592;\n\n\n\n\nfloat processFunction(int func, float x, float y){\n\n    switch(func){\n        case  0: return log(abs(x)) + log(abs(y));\n        case  1: return log(abs(x)) +         y  ;\n        case  2: return         x   + log(abs(y));\n        case  3: return         x   +         y  ;\n        case  4: return         x   +       y*y  ;\n        case  5: return       x*x   +       y*y  ;\n        case  6: return       x*x   +     y*y*y  ;\n        case  7: return     x*x*x   +       y*y  ;\n        case  8: return     x*x*x   +     y*y*y  ;\n        case  9: return   x*x*x*x   +   y*y*y*y  ;\n        case 10: return x*x*x*x*x   + y*y*y*y*y  ;\n        case 11: return      1./x   +      1./y  ;\n        case 12: return  1./(x*x)   +  1./(y*y)  ;\n        case 13: return 1./(x*x*x)  + 1./(y*y*y) ;\n        case 14: return     sin(log(abs(x*y)))   + \n                            cos(log(abs(y/x)))   ;\n    }\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    \n    float[5] colors;\n    \n    //\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    // get parameters\n    float xi   = get(paramXi );\n    float xf   = get(paramXf );\n    float yi   = get(paramYi );\n    float yf   = get(paramYf );\n    float vel  = get(paramVel);\n    \n    int func = int(get(paramFunc));\n    \n    bool     cicle  = get(paramCicle)>0.;\n    float velCicle  = get(paramVelCicle);\n    float timeCicle = get(paramTimeCicle);\n    float timeBase  = get(paramTimeBase);\n    \n    float x = (xi+(xf-xi)*uv.x);\n    float y = (yi+(yf-yi)*uv.y);\n    \n    float d, newx, newy;\n    \n    \n     \n    for(int i=0;i<5;i++){\n\n        d = processFunction(func,x,y);\n        \n        \n        float t = timeBase;\n        \n        if(cicle){\n           \n           t += (float(iTime)-timeBase)*velCicle;        \n\t\t}\t\n        \n        float omegax = y/d + x/sqrt(n) + thetax + 2.*t;\n        float omegay = x/d + y/sqrt(n) + thetay + .5*t;\n        \n        \n        \n        \n        \n        \n        //newx = sin(omegax/omegay);\n        //newy = sin(omegay/omegax);\n\t\t\n        // bellow some different recurrence steps if anyone wants to test ;-)\n        \n        //newx=sin(y/d+x/d+thetax);\n        //newy=sin(x/d+y/d+thetay);\n\t\t\t\t\n\t\t//newx=sin(y/sqrt(n)+x/sqrt(n)+thetax);\n        //newy=sin(x/sqrt(n)+y/sqrt(n)+thetay);\n\t\t\t\t\n\t\tnewx=cos(log(abs(y))/d + log(abs(x))/sqrt(n)+thetax + 2.*t) ;\n        newy=sin(log(abs(x))/d + log(abs(y))/sqrt(n)+thetay + .5*t) ;\n\t\t\t\t\n        x = newx;\n\t\ty = newy;\n        \n        colors[i]=abs(280.-pow(x+y,2.)*128.);\n      }\n\t\t\t\n\n    // Output to screen\n    //vec3 col = vec3();\n    \n    fragColor = vec4(colors[2]/256.,colors[3]/256.,colors[4]/256.,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n  David Machado Santos Filho\n  davidmachadosf@gmail.com\n  \n  Based on openprocessing app:\n  https://openprocessing.org/sketch/1916670\n  (same author)\n  \n  \n  Any suggestion for improvement and inclusion of \n  interesting features is welcome! \n  \n  Feel free to fork the code and test your own ideas! \n  This code is copyleft! ;-)\n  \n*/\n\n// parameters (coordinates on texture buffer)\nconst ivec2 paramXi = ivec2(0,0);\nconst ivec2 paramXf = ivec2(0,1);\nconst ivec2 paramYi = ivec2(0,2);\nconst ivec2 paramYf = ivec2(0,3);\n\nconst ivec2 paramVel   = ivec2(1,0);\nconst ivec2 paramFunc  = ivec2(2,0);\n\nconst ivec2 paramCicle     = ivec2(3,0);\nconst ivec2 paramVelCicle  = ivec2(3,1);\nconst ivec2 paramTimeCicle = ivec2(3,2);\nconst ivec2 paramTimeBase  = ivec2(3,3);\n\n// read and store values as x value on texture pixels\n#define get(var) texelFetch(iChannel0, var, 0).x\n#define set(var, value, fragColor, fragCoord) fragColor=(ivec2(fragCoord)==var?vec4(value,0.,0.,1.):fragColor)\n\n\n// reset to initial parameters\nconst int keyReset = 192; // Esc\n\n// change image functions\nconst int keyPrev = 33; // PgUp\nconst int keyNext = 34; // PgDown\n\n\n// change position (arrow keys)\nconst int keyNorth = 38;\nconst int keySouth = 40;\nconst int keyEast  = 37;\nconst int keyWest  = 39;\nconst int keyOrig  = 12;\n\n\n\n// keycodes below are from numeric keyboard\n\n// change scale\nconst int keyZoomOut = 111; // /\nconst int keyZoomIn  = 106; // *\n\n// change scale velocity\nconst int keySlow = 109; // -\nconst int keyFast = 107; // +\n\n// cicle palete over time\nconst int keyCicle = 110; // .\n\n// change cicle velocity\nconst int keyCicleSlow = 36; // Home\nconst int keyCicleFast = 35; // End\n\n\n\n\n\n#define keyToggle(code)  ( texelFetch(iChannel1,ivec2(code,2),0).x > 0.)\n#define keyClick(code)   ( texelFetch(iChannel1,ivec2(code,1),0).x > 0.)\n#define keyDown(code)    ( texelFetch(iChannel1,ivec2(code,0),0).x > 0.)\n\n#define shift             ( texelFetch(iChannel1,ivec2(16,0),0).x  > 0.)\n#define ctrl              ( texelFetch(iChannel1,ivec2(17,0),0).x  > 0.)\n#define alt               ( texelFetch(iChannel1,ivec2(18,0),0).x  > 0.)\n#define modifier          ( int(shift) +2*int(ctrl) + 4*int(alt) )\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n  David Machado Santos Filho\n  davidmachadosf@gmail.com\n  \n  Based on openprocessing app:\n  https://openprocessing.org/sketch/1916670\n  (same author)\n  \n  \n  Any suggestion for improvement and inclusion of \n  interesting features is welcome! \n  \n  Feel free to fork the code and test your own ideas! \n  This code is copyleft! ;-)\n  \n*/\n\n\n/* MANUAL\n\nKEYS\n    ESC : reset\n  (numpad numlock OFF):\n    ARROWS   : move\n    NUMPAD5  : center 0,0\n    * /      : zoom in/out  \n    + -      : inc/dec zoom vel\n    .        : cicle pallete\n    Home End : inc/dec cicle vel\n    PgUp PgDown: Cicle 15 diff f(x,y)\n    \n*/\n\n\n// initial parameter values\nfloat iniXi       =  -100. ;\nfloat iniXf       =   100. ;\nfloat iniYi       =  -100. ;\nfloat iniYf       =   100. ;\nfloat iniVel      =   .01;\nfloat iniFunc     =  0.  ;\n\nfloat iniCicle     =  1.  ;\nfloat iniVelCicle  =   .1 ;\nfloat iniTimeCicle =  0.  ;\nfloat iniTimeBase  =  0.  ;\n\n\n\n\nvoid initParameters(inout vec4 fragColor, in vec2 fragCoord){\n    set(paramXi,       iniXi,       fragColor, fragCoord);   \n    set(paramXf,       iniXf,       fragColor, fragCoord);   \n    set(paramYi,       iniYi,       fragColor, fragCoord);   \n    set(paramYf,       iniYf,       fragColor, fragCoord);   \n    set(paramVel,      iniVel,      fragColor, fragCoord);   \n    set(paramFunc,     iniFunc,     fragColor, fragCoord);   \n    \n    set(paramCicle,     iniCicle,     fragColor, fragCoord);   \n    set(paramVelCicle,  iniVelCicle,  fragColor, fragCoord);   \n    set(paramTimeCicle, iniTimeCicle, fragColor, fragCoord);\n    set(paramTimeBase,  iniTimeBase,  fragColor, fragCoord);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // initialize values\n    if (iFrame==0) {\n        initParameters(fragColor, fragCoord);    \n    }\n\n    else { \n    \n        // get current values\n        float xi       = get(paramXi);   \n        float xf       = get(paramXf);   \n        float yi       = get(paramYi);   \n        float yf       = get(paramYf);   \n        float vel      = get(paramVel);   \n        float func     = get(paramFunc); \n        \n        float cicle     = get(paramCicle);  \n        float velCicle  = get(paramVelCicle);  \n        float timeCicle = get(paramTimeCicle);  \n        float timeBase  = get(paramTimeBase);  \n        \n        // current visible window size\n        float dx = xf-xi;\n        float dy = yf-yi;\n        \n        // move image\n        if(keyDown(keyNorth)){\n            yi+=dy/100.;\n            yf+=dy/100.;\n        }\n        if(keyDown(keySouth)){\n            yi-=dy/100.;\n            yf-=dy/100.;\n        }\n        if(keyDown(keyEast)){\n            xi-=dx/100.;\n            xf-=dx/100.;\n        }\n        if(keyDown(keyWest)){\n            xi+=dx/100.;\n            xf+=dx/100.;\n        }\n        \n        // return to 0,0 (dont change scale)\n        if(keyDown(keyOrig)){\n            xi=-dx/2.;\n            xf=+dx/2.;\n            yi=-dy/2.;\n            yf=+dy/2.;\n        }\n        \n        // zoom controls\n        if(keyDown(keyZoomOut)){\n            xi-=dx*vel;\n            xf+=dx*vel;\n            yi-=dy*vel;\n            yf+=dy*vel;\n        }        \n        if(keyDown(keyZoomIn)){\n            xi+=dx*vel;\n            xf-=dx*vel;\n            yi+=dy*vel;\n            yf-=dy*vel;\n        }\n        \n        // zoom velocity change\n        if(keyClick(keySlow)){\n            vel/=2.;\n        }        \n        if(keyClick(keyFast)){\n            vel*=2.;\n        }\n        \n        \n        \n        \n        \n        // restart to initial status\n        if(keyClick(keyReset)){            \n            xi    = iniXi;\n            xf    = iniXf;\n            yi    = iniYi;\n            yf    = iniYf;\n            vel   = iniVel;\n            func  = iniFunc;\n            \n            cicle     = iniCicle;\n            velCicle  = iniVelCicle;  \n            timeBase  = 1.*iTime; \n            timeCicle = timeBase;\n        }\n        \n        \n        // change f(x,y) function\n        if(keyClick(keyPrev)){\n            func = func-1.;\n            if(func<0.) func = 14.;\n        }        \n        if(keyClick(keyNext)){\n            func = func+1.;\n            if(func>=15.) func = 0.;\n        }\n        \n        // cicle fase and colors by iTime\n        if(keyClick(keyCicle)){\n            // its a bool, but I must store as float... \n            cicle*=-1.;\n            \n            if(cicle<0.){\n                timeBase += float(iTime)-timeBase; \n            }\n            else{\n                \n                //timeCicle = timeBase; \n            }\n        }\n        \n        // cicle velocity change\n        if(keyDown(keyCicleSlow)){\n            //timeCicle -= (float(iTime) - timeCicle)*velCicle; \n            velCicle/=1.01;            \n        }        \n        if(keyDown(keyCicleFast)){\n            //timeCicle += (float(iTime) - timeCicle)*velCicle;\n            velCicle*=1.01;            \n        }\n        \n        \n        // update parameters\n        set(paramXi,       xi,    fragColor, fragCoord);   \n        set(paramXf,       xf,       fragColor, fragCoord);   \n        set(paramYi,       yi,       fragColor, fragCoord);   \n        set(paramYf,       yf,       fragColor, fragCoord);   \n        set(paramVel,      vel,      fragColor, fragCoord);   \n        set(paramFunc,     func,     fragColor, fragCoord);   \n        \n        set(paramCicle,     cicle,     fragColor, fragCoord); \n        set(paramVelCicle,  velCicle,  fragColor, fragCoord); \n        set(paramTimeCicle, timeCicle, fragColor, fragCoord); \n        set(paramTimeBase,  timeBase,  fragColor, fragCoord); \n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}