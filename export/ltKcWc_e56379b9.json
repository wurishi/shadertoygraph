{"ver":"0.1","info":{"id":"ltKcWc","date":"1538023670","viewed":2151,"name":"Raymarching Ambient Occlusion ","username":"edo_m18","description":"Face AO with raymarching.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["ao"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 cameraPos = vec3(0.0, -0.5, 1.5);\nvec3 cameraDir = normalize(vec3(0.0, -0.3, -1.0));\nvec3 lightDir = vec3(1.0, 1.0, 1.0);\nfloat softShadow = 16.0;\nfloat size = 0.5;\n\n// sphereの距離関数\nfloat distSphere(vec3 pos, float size)\n{\n    vec3 spPos = vec3(1.0, -1.8, -1.0);\n    return length(pos - spPos) - size;\n}\n\n// Planeの距離関数\nfloat distPlane(vec3 pos, vec4 n)\n{\n    return dot(pos, n.xyz) + n.w;\n}\n\n// トーラスの距離関数\nfloat distTorus(vec3 p, vec2 t)\n{\n  vec2 tPos = vec2(0.0, -2.0);\n  vec2 q = vec2(length(p.xy - tPos) - t.x, p.z);\n  return length(q - tPos) - t.y;\n}\n\nfloat distFunc(vec3 pos)\n{\n    float d1 = distSphere(pos, size);\n    float d2 = distPlane(pos, vec4(0.0, 1.0, 0.0, 2.0));\n    float d3 = distTorus(pos, vec2(0.5, 0.2));\n    return min(d3, min(d1, d2));\n}\n\nvec3 getNormal(vec3 pos)\n{\n    const float e = 0.0001;\n    const vec3 dx = vec3(e, 0, 0);\n    const vec3 dy = vec3(0, e, 0);\n    const vec3 dz = vec3(0, 0, e);\n\n    float d = distFunc(pos);\n\n    return normalize(vec3(\n        d - distFunc(vec3(pos - dx)),\n        d - distFunc(vec3(pos - dy)),\n        d - distFunc(vec3(pos - dz))\n    ));\n}\n\n// 影を計算する\n// オブジェクトの衝突位置からライト方向にレイを飛ばし、\n// 遮蔽があったら影とする。\n// また、ライトに向かうレイがなにかのオブジェクトに接近した場合は\n// 最接近情報を保持し、影の影響度として利用する（ソフトシャドウ）\n// +-----------------+--------------------+\n// | ro = Ray Origin | rd = Ray Direction |\n// +-----------------+--------------------+\nfloat genShadow(vec3 ro, vec3 rd)\n{\n    // 距離関数の結果 = 距離\n    float h = 0.0;\n\n    // 現在のレイの位置\n    float c = 0.001;\n\n    // レイの最接近距離\n    float r = 1.0;\n\n    // シャドウ係数（濃さ）\n    float shadowCoef = 0.5;\n\n    // レイマーチにより影を計算する\n    for (float t = 0.0; t < 50.0; t++)\n    {\n        h = distFunc(ro + rd * c);\n\n        if (h < 0.0001)\n        {\n            return shadowCoef;\n        }\n\n        // 現時点の距離関数の結果と係数を掛けたものを\n        // レイの現時点での位置で割ったものを利用する\n        // 計算結果のうち、もっとも小さいものを採用する\n        r = min(r, h * softShadow / c);\n\n        c += h;\n    }\n\n    return 1.0 - shadowCoef + (r * shadowCoef);\n}\n\n// なんちゃってAOを計算する\n//\n// +-----------------+--------------------+\n// | ro = Ray Origin | rd = Ray Direction |\n// +-----------------+--------------------+\nvec4 genAmbientOcclusion(vec3 ro, vec3 rd)\n{\n    vec4 totao = vec4(0.0);\n    float sca = 1.0;\n\n    for (int aoi = 0; aoi < 5; aoi++)\n    {\n        float hr = 0.01 + 0.02 * float(aoi * aoi);\n        vec3 aopos = ro + rd * hr;\n        float dd = distFunc(aopos);\n        float ao = clamp(-(dd - hr), 0.0, 1.0);\n        totao += ao * sca * vec4(1.0, 1.0, 1.0, 1.0);\n        sca *= 0.75;\n    }\n\n    const float aoCoef = 0.5;\n    totao.w = 1.0 - clamp(aoCoef * totao.w, 0.0, 1.0);\n\n    return totao;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec4 m = iMouse / iResolution.xxxx;\n    \n    vec3 col = vec3(0.0);\n\n    vec3 cPos = cameraPos;\n    vec3 cDir = normalize(vec3(m.x, -m.y, -1.0));\n    vec3 cSide = normalize(cross(cDir, vec3(0, 1, 0)));\n    vec3 cUp = normalize(cross(cSide, cDir));\n    float targetDepth = 1.3;\n\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n\n    float dist, depth;\n    depth = 0.0;\n\n    vec3 pos;\n\n    const int maxsteps = 128;\n    const float eps = 0.0001;\n\n    for (int i = 0; i < maxsteps; i++)\n    {\n        pos = cPos + ray * depth;\n\n        dist = distFunc(pos);\n\n        if (dist < eps)\n        {\n            break;\n        }\n\n        depth += dist;\n    }\n\n    float shadow = 1.0;\n\n    if (dist < eps)\n    {\n        vec3 n = getNormal(pos);\n\n        float diff = dot(n, lightDir);\n\n        shadow = genShadow(pos + n * 0.0001, lightDir);\n\n        vec4 totao = genAmbientOcclusion(pos + n * 0.0001, n);\n\n        float u = 1.0 - floor(mod(pos.x, 2.0));\n        float v = 1.0 - floor(mod(pos.z, 2.0));\n        if ((u == 1.0 && v < 1.0) || (v == 1.0 && u < 1.0))\n        {\n            diff *= 0.7;\n        }\n\n        col = vec3(diff) + vec3(0.1);\n        col -= totao.xyz * totao.w;\n    }\n\n    fragColor = vec4(col * max(0.5, shadow), 1.0) * exp(-depth * 0.12);\n}","name":"Image","description":"","type":"image"}]}