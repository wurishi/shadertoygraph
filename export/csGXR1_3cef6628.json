{"ver":"0.1","info":{"id":"csGXR1","date":"1680695609","viewed":46,"name":"weird 3D julia","username":"rucksack","description":"For some reason the distance estimator simply passes all rays through itself, which makes the mindist glow the only thing that works :/","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","julia"],"hasliked":0,"parentid":"csGSRz","parentname":"3D Julia but wrong????"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Raymarching parameters\nconst int MAX_STEPS = 300;\nconst float TOO_FAR = 100.0;\nconst float NEAR_ENOUGH = 0.001;\nconst float NORMAL_DELTA = 0.0005;\n\n// Colors\nconst vec3 BACKGROUND_COLOR = .1*vec3(0.97255,0.95686,0.94118);\n\nconst float PI = 3.14159265359;\n\n\nmat3 rotateY(float a) {\n    return mat3(\n        -sin(a), 0, cos(a),\n              0, 1, 0,\n         cos(a), 0, sin(a)\n    );\n}\n\nmat3 rotateX(float a) {\n    return mat3(\n        1,       0,      0,\n        0, -sin(a), cos(a),\n        0,  cos(a), sin(a)\n    );\n}\n\nfloat rand(vec2 uv) {\n    return fract(sin(dot(uv, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat dither(vec2 uv) {\n  return (rand(uv)*2. - 1.) / 156.;\n}\n\n// f_n(z) = f_n-1(z)^2 + c, f_0(z) = z\nvec4 next(vec4 z, vec4 c) {\n    return qmul(z, z) + c;\n}\n\n// f'_n(z) = 2*f_n-1(z)*f'_n-1(z), f'_0(z) = 1\nvec4 derivative(vec4 z, vec4 dr) {\n    return qmul(z, dr);\n}\n\nconst int iterations = 50;\n\nfloat map(vec4 z, vec4 c, out int i) {\n    i = 0;\n    vec4 dr = vec4(1, vec3(0));\n    float d = 0.;\n    for (; i < iterations && length(z) < 2.*length(c); i++) {\n        z = next(z, c);\n        dr = derivative(z, dr);\n    }\n    return .5 * log(length(z)) * length(z)/max(NEAR_ENOUGH, length(dr));\n}\n\nfloat distance_from_everything(vec3 pos) {\n    int i;\n    return map(vec4(pos, .5), vec4(1, vec3(0)), i);\n}\n\nfloat ray_march(vec3 ray_origin, vec3 ray_direction, out int steps, out float mindist) {\n    float d = 0.0;\n    steps = 0;\n    mindist = TOO_FAR;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 point = ray_origin + ray_direction*d;\n        float current_distance = distance_from_everything(point);\n        mindist = min(mindist, current_distance);\n        d += current_distance;\n        steps++;\n        if (current_distance < NEAR_ENOUGH || d > TOO_FAR)\n            break;\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 xy = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    mat3 rot = rotateX(m.y*PI) * rotateY(m.x*PI*2.);\n\n    vec3 camera = vec3(0, 0, -2.5) * rot;\n    vec3 ray_direction = vec3(xy, 1) * rot;\n\n    int steps;\n    float mindist;\n    float dist = ray_march(camera, ray_direction, steps, mindist);\n    vec3 point = camera + ray_direction * dist;\n\n    // Only use minimum distance\n    vec3 base_color = BACKGROUND_COLOR + .07*log(1./mindist);\n\n    fragColor = vec4(base_color + dither(fragCoord), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Multiplication obeys a set of laws for i, j and k\nvec4 qmul(in vec4 a, in vec4 b) {\n    return vec4(a.s*b.s - a.t*b.t - a.p*b.p - a.q*b.q,\n                a.s*b.t + a.t*b.s + a.p*b.q - a.q*b.p,\n                a.s*b.p + a.p*b.s + a.q*b.t - a.t*b.q,\n                a.s*b.q + a.q*b.s + a.t*b.p - a.p*b.t);\n}\n\n// Norm is simply the sum of squares of its components\nfloat qnorm(in vec4 q) {\n    return q.s*q.s + q.t*q.t + q.p*q.p + q.q*q.q;\n}","name":"Common","description":"","type":"common"}]}