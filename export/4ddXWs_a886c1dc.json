{"ver":"0.1","info":{"id":"4ddXWs","date":"1462203003","viewed":187,"name":"Reflections Testings","username":"gsitcia","description":"Had to figure out another different way to do lighting.... at least reflections work now.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat rpBox( vec3 p, vec3 c ) {\n    vec3 q = mod(p,c)-0.5*c;\n    return udBox( p, vec3(0.5, 0.5, 0.5) );\n}\n\nfloat sdPlane( vec3 p )\n{\n  // n must be normalized\n  return p.y;\n}\n\nfloat omap( vec3 p ) {\n    float d1 = sdPlane( p );\n    float d2 = sdSphere( p - vec3(0.0, 0.5, 0.0), 1.0);\n    float d3 = udBox( p - vec3(-1.0, 1.0, 0.0), vec3(1.7, 2.0, 2.0) );\n    float d4 = sdSphere( p - vec3(1.0, 0.5, 0.0), 0.5);\n    return min(max(-d2, max(d3, d4)), d1);\n}\n\nfloat map( vec3 p ) {\n    float d1 = sdPlane(p);\n    float d2 = udBox( p - vec3(0.0, 0.9, 0.0), vec3(0.1, 0.9, 0.4) );\n    float d3 = sdSphere( p - vec3(1.0, 0.5, 0.0), 0.5);\n    return min(min(d1, d3), d2);\n}\n\nvec3 cmap( vec3 p ) {\n    float d1 = sdPlane(p); // White\n    float d2 = udBox( p - vec3(0.0, 0.9, 0.0), vec3(0.1, 0.9, 0.4) ); // Dark Gray\n    float d3 = sdSphere( p - vec3(1.0, 0.5, 0.0), 0.5); // Barely White\n    float z = min(d1, d2);\n    z = min(z, d3);\n    if (z == d1) {\n        return vec3(1.0, 0.5, 0.3);\n    }\n    if (z == d2) {\n        return vec3(0.1, 0.3, 0.1);\n    }\n    if (z == d3) {\n        return vec3(0.9, 0.9, 0.7);\n    }\n    return vec3(0.0, 0.0, 0.0);\n}\n\nbool rmap( vec3 p ) {\n    float d1 = sdPlane(p); // Not Reflective\n    float d2 = udBox( p - vec3(0.0, 0.9, 0.0), vec3(0.1, 0.9, 0.4) ); // Reflective\n    float d3 = sdSphere( p - vec3(1.0, 0.5, 0.0), 0.5); // Not Reflective\n    float z = min(d1, d2);\n    z = min(z, d3);\n    if (z == d3) {\n        return true;\n    }\n    return false;\n}\n    \nvec3 norm( vec3 p ) {\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 fr = vec3(0.0, 0.0, 1.0);\n    vec3 rt = vec3(1.0, 0.0, 0.0);\n    \n    float mp = map(p);\n    float mu = map(p + mp * up)/mp;\n    float md = map(p - mp * up)/mp;\n    float mr = map(p + mp * rt)/mp;\n    float ml = map(p - mp * rt)/mp;\n    float mf = map(p + mp * fr)/mp;\n    float mb = map(p - mp * fr)/mp;\n    \n    float k;\n    \n    k = 2.0 / (mu + md);\n    \n    mu *= k;\n    md *= k;\n    \n    k = 2.0 / (mr + ml);\n    \n    mr *= k;\n    ml *= k;\n    \n    k = 2.0 / (mf + mb);\n    \n    mf *= k;\n    mb *= k;\n    \n    float ud = sqrt(1.0 - mu*md);\n    float rl = sqrt(1.0 - mr*ml);\n    float fb = sqrt(1.0 - mf*mb);\n    \n    vec3 fv = vec3(0.0, 0.0, 0.0);\n    \n    if (mu > md) {\n        fv += ud * up;\n    } else {\n        fv -= ud * up;\n    }\n    \n    if (mr > ml) {\n        fv += rl * rt;\n    } else {\n        fv -= rl * rt;\n    }\n    \n    if (mf > mb) {\n        fv += fb * fr;\n    } else {\n        fv -= fb * fr;\n    }\n    \n    return fv;\n}\n\nvec3 normc( vec3 p ) {\n    float dt = 0.5*map(p);\n    \n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 fr = vec3(0.0, 0.0, 1.0);\n    vec3 rt = vec3(1.0, 0.0, 0.0);\n    \n    vec3 n1 = norm(p);\n    vec3 n2 = norm(p+dt*up);\n    vec3 n3 = norm(p-dt*up);\n    vec3 n4 = norm(p+dt*fr);\n    vec3 n5 = norm(p-dt*fr);\n    vec3 n6 = norm(p+dt*rt);\n    vec3 n7 = norm(p-dt*rt);\n    \n   \tvec3 n = (n1 + n2 + n3 + n4 + n5 + n6 + n7) / 7.0;\n    \n    return n;\n}\n\nfloat shadow( vec3 p, vec4 l ) {\n    vec3 dr = normalize(p - l.xyz);\n    float dst = 0.0;\n    float res = 1.0;\n    for (int i = 0; i < 100; ++i) {\n        float dt = map(l.xyz);\n        l.xyz += dr * dt * 0.8;\n        dst += dt * 0.8;\n        if (dt < 0.0001) {\n            if (distance(l.xyz, p) < 0.001) {\n                return res;\n            } else {\n            \treturn 0.0;\n            }\n        }\n        res = min(res, 4.0 * dt * dst / length(p - l.xyz));\n    }\n    return res * l.w;\n}\n\nfloat shadown( vec3 p, vec4 l ) {\n    vec3 dr = normalize(p - l.xyz);\n    vec3 orig = l.xyz;\n    float dst = 0.0;\n    for (int i = 0; i < 100; ++i) {\n        float dt = map(l.xyz);\n        l.xyz += dr * dt * 0.8;\n        dst += dt * 0.8;\n        if (dt < 0.0001) {\n            if (distance(l.xyz, orig) < 0.0001) {\n                return 0.0;\n            } else {\n                return 1.0;\n            }\n        }\n    }\n    return 0.0;\n}\n\nvec3 lights( vec3 p, vec4 l, vec4 ldir, vec3 lc ) {\n    vec3 ld = normalize(l.xyz - p);\n    vec3 ds = norm(p);\n    float li = dot(ds, ld);\n    vec3 c = cmap(p);\n    c.x *= lc.x;\n    c.y *= lc.y;\n    c.z *= lc.z;\n   \treturn c * li * l.w * pow(clamp(ldir.w/distance(ld, ldir.xyz), 0.0, 1.0), 1.0/ldir.w);\n    /*if (distance(ld, ldir.xyz) < ldir.w) {\n    \treturn cmap(p) * li * l.w;\n    } else {\n        return vec3(0.03, 0.03, 0.03);\n    }*/\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec3 id = vec3(1.0, 1.0, 1.0);\n    \n    float mindist = min(iResolution.x, iResolution.y);\n    \n    vec3 uv = vec3((gl_FragCoord.xy - iResolution.xy / 2.0) / mindist, 0.0);\n    \n    // vec3 eye = vec3((2.0 * (iMouse.xy - iResolution.xy / 2.0) / mindist) + vec2(0.0, 1.0), -2.5);\n    \n    vec3 eye = vec3(3.0 * sin(iMouse.x * 3.141592 / 360.0), (iResolution.y - iMouse.y) / 45.0 , 3.0 * cos(iMouse.x * 3.141592 / 360.0));\n    \n    float fl = 1.0;\n    \n    vec3 fo = normalize(-1.0 * eye);\n    \n    // vec3 up = normalize(vec3(0.0, 1.0, 0.0)); // 2 point perspective\n    \n    vec3 up;\n    \n    vec4 light = vec4(3.0 * sin(iTime * 3.141592 / 45.0), 3.0, 3.0  * cos(iTime * 3.141592 / 45.0), 10.0);\n    \n    vec4 lightdir = vec4(normalize(-1.0 * light.xyz), 0.7);\n    \n    vec3 lightcolor = vec3(0.9, 0.9, 1.0);\n    \n    up.xz = -1.0 * fo.xz;\n    \n    up.xz *= fo.y / length(fo.xz);\n    \n    up.y = length(fo.xz); // 3 point perspective\n    \n    vec3 si = cross(up, fo);\n    \n    uv = eye + fl * fo + uv.x * si + uv.y * up;\n    \n    vec3 dr = uv - eye;\n    \n    uv = eye;\n    \n    dr = dr / length(dr);\n    \n    float dt = 0.0;\n    \n    for (int i = 0; i < 1000; ++i) {\n        dt = map( uv );\n        if (dt < 0.0001) {\n            dt = float(i);\n            break;\n        }\n        uv = uv + dr * dt * 0.8;\n    }\n    \n    // reflect\n    \n    vec4 rf = vec4(shadow( uv, light ) * lights( uv, light, lightdir, lightcolor ), 1.0);\n    \n    if (rmap(uv)) {\n    \tfloat dt = 0.01;\n        \n        vec3 ds = norm(uv);\n    \t\n    \tdr = -1.0 * dr;\n        \n        ds *= dot(ds, dr);\n        \n        vec3 q = ds - dr;\n        \n        dr += 2.0 * q;\n        \n        for (int i = 0; i < 100; ++i) {\n    \t    uv = uv + dr * dt * 0.8;\n            dt = map( uv );\n            if (dt < 0.0001) {\n    \t        dt = float(i);\n    \t        break;\n    \t    }\n    \t}\n        rf.w = 0.9;\n    }\n    \n    if (rmap(uv)) {\n    \tfloat dt = 0.01;\n        \n        vec3 ds = norm(uv);\n    \t\n    \tdr = -1.0 * dr;\n        \n        ds *= dot(ds, dr);\n        \n        vec3 q = ds - dr;\n        \n        dr += 2.0 * q;\n        \n        for (int i = 0; i < 100; ++i) {\n    \t    uv = uv + dr * dt * 0.8;\n            dt = map( uv );\n            if (dt < 0.0001) {\n    \t        dt = float(i);\n    \t        break;\n    \t    }\n    \t}\n        rf.w = 0.9;\n    }\n    \n    if (rmap(uv)) {\n    \tfloat dt = 0.01;\n        \n        vec3 ds = norm(uv);\n    \t\n    \tdr = -1.0 * dr;\n        \n        ds *= dot(ds, dr);\n        \n        vec3 q = ds - dr;\n        \n        dr += 2.0 * q;\n        \n        for (int i = 0; i < 100; ++i) {\n    \t    uv = uv + dr * dt * 0.8;\n            dt = map( uv );\n            if (dt < 0.0001) {\n    \t        dt = float(i);\n    \t        break;\n    \t    }\n    \t}\n        rf.w = 0.9;\n    }\n    \n    \n    \n    // vec3 dc = vec3(dt, dt, dt) / 50.0;\n   \t\n    /* if (dt == 100.0) {\n       \tdc = vec3(0.0, 1.0, 0.5);\n    } else {\n        dc = vec3(dt, dt, dt) / 50.0;\n    } */\n    \n    vec3 dc = shadow( uv, light ) * lights( uv, light, lightdir, lightcolor );\n    \n    dc = rf.w*dc + (1.0 - rf.w)*rf.xyz;\n    \n    fragColor = vec4(dc, 0.0);\n}","name":"Image","description":"","type":"image"}]}