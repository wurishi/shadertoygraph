{"ver":"0.1","info":{"id":"3s2BDR","date":"1590053829","viewed":2602,"name":"OCEAN SURFACE: NOISE FBM","username":"alro","description":"Use mouse to move camera.","likes":45,"published":1,"flags":32,"usePreview":1,"tags":["raymarching","waves","sss","heightfield","water","ocean","scattering","fresnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Ocean shader with noise waves and slope based subsurface scattering.\n\n//Based on:\n//https://www.shadertoy.com/view/Ms2SD1\n//https://unitywatershader.wordpress.com/\n//https://www.alanzucconi.com/2017/08/30/fast-subsurface-scattering-1/\n//https://www.fxguide.com/fxfeatured/assassins-creed-iii-the-tech-behind-or-beneath-the-action/\n\n//Average the results of a 2x2 region of subpixel samples for antialiasing.\n//#define AA\n\n//Raymarching\nconst int MAX_STEPS = 300;\nconst float MAX_DIST = 1800.0;\nconst float EPSILON = 1e-4;\n\n//Wave extent and noise field scale.\nconst float HEIGHT = 4.0;\nconst float SCALE = 0.035;\nfloat waveSpeed = 0.035;\n\n//Octaves of FBM.\nconst int shapeLimit = 3;\nconst int normalLimit = 8;\n\nconst vec3 skyColour = vec3(0.09, 0.33, 0.81);\nconst vec3 sunLightColour = vec3(1);\nconst vec3 sunColour = sunLightColour;\n\nfloat specularStrength = 100.0;\nfloat shininess = 2048.0;\nconst vec3 specularColour = sunLightColour;\n\n//In a circle of 2*PI\nconst float sunLocation = 0.0;\n//0: horizon, 1: zenith\nconst float sunHeight = 0.35;\n\nconst float diffuseStrength = 0.2;\nconst vec3 diffuseColour = diffuseStrength * vec3(0.05,0.45,0.65);\n\nfloat ambientStrength = 0.5;\nvec3 ambientColour = 0.5 * diffuseColour;\n\nvec3 scatterColour = vec3(0.05, 0.8, 0.7);\nfloat power = 8.0;\nfloat scale = 0.4;\nfloat distortion = 0.2;\nfloat scatterStrength = 0.3;\n\nconst float angle = 3.14;\n\nconst float s = sin(angle);\nconst float c = cos(angle);\nconst mat2 rotation = mat2(c, s, -s, c);\n\nfloat saturate(float x){\n\treturn clamp(x, 0.0, 1.0);\n}\n\nvec3 rayDirection(float fieldOfView, vec2 fragCoord) {\n    vec2 xy = fragCoord - iResolution.xy / 2.0;\n    float z = (0.5 * iResolution.y) / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n//https://www.geertarien.com/blog/2017/07/30/breakdown-of-the-lookAt-function-in-OpenGL/\nmat3 lookAt(vec3 camera, vec3 targetDir, vec3 up){\n  vec3 zaxis = normalize(targetDir);    \n  vec3 xaxis = normalize(cross(zaxis, up));\n  vec3 yaxis = cross(xaxis, zaxis);\n\n  return mat3(xaxis, yaxis, -zaxis);\n}\n\n//Darken sky when looking up and add a white haze at the horizon.\nvec3 getSkyColour(vec3 rayDir){\n    return mix(vec3(1), mix(skyColour, 0.2*skyColour, rayDir.y), \n               smoothstep(-0.5, 0.25, rayDir.y));\n}\n\n//By iq\nfloat noised( in vec2 x ){\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n  \n    vec2 p = floor(x);\n\tfloat a = textureLod( iChannel1, (p+vec2(0.5,0.5))*0.00390625, 0.0 ).x;\n\tfloat b = textureLod( iChannel1, (p+vec2(1.5,0.5))*0.00390625, 0.0 ).x;\n\tfloat c = textureLod( iChannel1, (p+vec2(0.5,1.5))*0.00390625, 0.0 ).x;\n\tfloat d = textureLod( iChannel1, (p+vec2(1.5,1.5))*0.00390625, 0.0 ).x;\n    \n\tfloat res = (a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y);\n    res = res - 0.5;\n    return res;\n}\n\nfloat fbm(vec3 pos, int limit){\n    float res = 0.0;\n    float freq = 1.0;\n    float amp = 1.0;\n    \n    for(int i = 0; i < 9; i++){ \n        if(i == limit){break;}\n\n       \tres += noised(freq*(pos.xz+iTime*(waveSpeed*float(9-i+1))))*amp;\n\n        freq *= 1.75;\n        amp *= 0.5;\n        \n        pos.xz *= rotation;\n    }\n\treturn res;\n}\n\n//Get height of waves at xz coordinates.\nfloat getHeight(vec3 pos, int limit){\n    return HEIGHT*fbm(SCALE*pos, limit);\n}\n\n//Binary search for 0 crossing given two points on either side of the surface.\nfloat bisection(vec3 start, vec3 rayDir, float near_, float far_){\n    float midpoint = (far_ + near_) * 0.5;\n    //Sample point\n    vec3 p = vec3(0);\n    float near = near_;\n    float far = far_;\n    float height = 0.0;\n    //Difference between sample point and water height.\n    float diff = 0.0;\n    \n    for(int i = 0; i < 8; i++){\n        p = start + rayDir * midpoint;\n        height = getHeight(p, shapeLimit);\n        diff = p.y - height;\n        \n        if(abs(diff) < EPSILON){\n        \tbreak;\n        }else{\n            \n            if(diff < EPSILON){\n                //Point is below waves\n                //Search first half\n                far = midpoint;\n            }else{\n                //Point is above waves\n                //Search second half\n                near = midpoint;\n            }\n            midpoint = (far + near) * 0.5;\n        }\n    }\n    return midpoint;\n}\n\n//Assume normalised vectors.\nbool getPlaneIntersection(vec3 org, vec3 ray, vec3 planePoint, vec3 normal, out float t){\n    float denom = dot(normal, ray); \n    if (denom > 1e-6) { \n        vec3 p0l0 = planePoint - org; \n        t = dot(p0l0, normal) / denom; \n        return (t >= 0.0); \n    } \n \n    return false; \n}\n\nfloat getIntersection(vec3 start, vec3 rayDir, float maxDist){\n\t//Distance between sample points. Set according to previous sample.\n    float stepSize = 0.0;\n    //Height of the waves.\n    float height = 0.0;\n    //Length of the ray.\n    float dist = 0.0;\n    //Difference between sample point and wave heights.\n    float diff = 0.0;\n    \n    //Start ray tracing from intersection with xz-plane at y == 1.1*HEIGHT.\n    float distToStart = 0.0;\n    bool hitsPlane = getPlaneIntersection(start, rayDir, vec3(0.0, 1.1*HEIGHT, 0.0), \n                                          vec3(0,-1,0), distToStart);\n    if(hitsPlane){\n        dist = distToStart;\n    }\n    \n    for(int i = 0; i < MAX_STEPS; i++){\n        //Sample point\n        vec3 p = start + rayDir * dist;\n        \n        //The height of the waves at the xz coordinates of the sample point.\n        height = getHeight(p, shapeLimit);\n        \n        diff = abs(p.y - height);\n        \n        //If sample point is close enough to the water surface, return distance.\n        if(diff < EPSILON){\n            return dist;\n        }\n        //If height of sample point is less than the height of the waves,\n        //the ray has hit the water. Use bisection to find the 0 crossing.\n        if(p.y < height){\n        \tdist = bisection(start, rayDir, dist - stepSize, dist);\n            return dist;\n        }\n        \n        //Static step size misses features and leads to banding. \n        //Set the step size to a fraction of the distance above the waves.\n        //Could also have a small step size which increases with distance, giving \n        //detailed results close to the camera and reaching far. However, \n        //this approach is used in many shaders and seems to give best results.\n        stepSize = diff * 0.5;\n        \n        //Increment ray\n        dist += stepSize;\n        \n        if(dist > MAX_DIST){\n        \treturn MAX_DIST;\n        }\n    }\n    return dist;\n}\n\n//https://iquilezles.org/articles/normalsSDF\n//https://stackoverflow.com/questions/33736199/calculating-normals-for-a-height-map\nvec3 getNormal(vec3 p, float t, int limit){\n    \n\t//Making the normal sample distance depend on the ray length and resolution\n    //leads to less noise.\n    float eps = (0.05 / iResolution.y) * pow(t, 1.55);\n    \n    //Central difference method for estimating the derivatives and normal of a surface.\n    /*\n    float left = getHeight(vec3(p.x-eps, p.y, p.z), limit);\n    float right = getHeight(vec3(p.x+eps, p.y, p.z), limit);\n    float top = getHeight(vec3(p.x, p.y, p.z-eps), limit);\n    float bottom = getHeight(vec3(p.x, p.y, p.z+eps), limit);\n    \n    float uy = right-left;\n    vec3 u = normalize(vec3(2.0*eps, uy, 0.0));\n\n   \tfloat vy = bottom-top;\n    vec3 v = normalize(vec3(0.0, vy, 2.0*eps));\n    \n    return normalize(cross(v,u));\n    */\n    \n    //The above is equivalent to the following:\n    return normalize(vec3( \n        getHeight(vec3(p.x-eps, p.y, p.z), limit) \n        - getHeight(vec3(p.x+eps, p.y, p.z), limit),\n        \n        2.0*eps,\n        \n        getHeight(vec3(p.x, p.y, p.z-eps), limit) \n        - getHeight(vec3(p.x, p.y, p.z+eps), limit) \n    ));\n}\n\n//https://learnopengl.com/PBR/Theory\nfloat fresnelSchlick(vec3 cameraPos, vec3 position, vec3 normal){\n    float cosTheta = dot(normal, normalize(cameraPos - position));\n\tfloat F0 = 0.02;\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n//Return colour of surface fragment based on light information.\nvec3 shading(vec3 cameraPos, vec3 position, vec3 normal, vec3 rayDir, \n             float dist, vec3 lightDirection){\n    \n\tvec3 result = vec3(0.0); \n    \n\tvec3 halfwayDir = normalize(lightDirection - rayDir);  \n\tfloat spec = pow(max(dot(normal, halfwayDir), 0.0), shininess);\n\n\t//Colour of light sharply reflected into the camera.\n\tvec3 specular = spec * specularColour * sunLightColour; \n\t\n\t//How much a fragment faces the sun.\n\tfloat sun = max(dot(normal, lightDirection), 0.0);\n    //Main sunlight contribution.\n    vec3 sunLight = sun * sunLightColour;\n    \n    //How much the fragment faces up.\n    float sky = max(dot(normal, vec3(0,1,0)), 0.0);\n    //Sky light. A blue light from directly above.\n\tvec3 skyLight = sky * skyColour;\n    \n    //Combine light\n    result += 0.1 * sunLight;\n    result += 0.1 * skyLight;\n    \n    //Sample point height in the wave.\n    float heightFraction = (position.y + HEIGHT) / (2.0 * HEIGHT);\n    \n    //Lighten the water when looking towards the horizon and darken it straight down.\n    vec3 col = mix(ambientColour, 0.5*scatterColour, pow(0.5+0.5*rayDir.y, 2.0));\n    \n    //Light and material interaction.\n    result *= diffuseColour;\n    result += ambientStrength * col + specularStrength * specular;\n    \n    //Fake subsurface scattering based on light direction and surface normal.\n    //https://www.alanzucconi.com/2017/08/30/fast-subsurface-scattering-1/\n    vec3 h = normalize(-lightDirection + normal * distortion);\n\tfloat vDotH = pow(saturate(dot(rayDir, -h)), power) * scale;\n    \n    //Scattering in stronger closer to the camera and higher in the wave.\n    result += \tscatterStrength * pow((1.0-dist/MAX_DIST), 4.0) * \n        \t\theightFraction * vDotH * scatterColour;\n    \n    //Reflection of the sky.\n    vec3 reflectedDir = normalize(reflect(rayDir, normal));\n    vec3 reflectedCol = getSkyColour(reflectedDir);\n    float fresnel = saturate(fresnelSchlick(cameraPos, position, normal));\n   \tresult = mix(result, 0.5*reflectedCol, fresnel);\n\n    return result;\n}\n\nfloat getGlow(float dist, float radius, float intensity){\n    dist = max(dist, 1e-6);\n\treturn pow(radius/dist, intensity);\t\n}\n\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x){\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n        \n    //Camera position is persistent and calculated in BufferA.\n    vec3 cameraPos = texelFetch(iChannel0, ivec2(0.5, 1.5), 0).xyz;\n    vec3 targetDir = -cameraPos;\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    //Get the view matrix from the camera orientation.\n    mat3 viewMatrix = lookAt(cameraPos, targetDir, up);\n    \n    vec3 lightDirection = normalize(vec3(sin(sunLocation), sunHeight, cos(sunLocation)));\n    vec3 col = vec3(0);\n    vec3 rayDir;\n    bool skyVisible = false;\n    \n    #ifdef AA\n    \n    for(int i = 0; i <= 1; i++) {\n        for(int j = 0; j <= 1; j++) {\n\n            //Get the default direction of the ray (along the negative Z direction).\n            rayDir = rayDirection(40.0, fragCoord+vec2(i,j)/2.0);\n            \n            #else\n            \n            rayDir = rayDirection(40.0, fragCoord);\n            \n            #endif\n\n\n            //Transform the ray to point in the correct direction.\n            rayDir = normalize(viewMatrix * rayDir);\n\n            float dist = MAX_DIST;\n            \n            //Only render water for rays pointing down.\n            if(rayDir.y < 0.0){\n                //Find the distance to where the ray stops.\n                dist = getIntersection(cameraPos, rayDir, MAX_DIST);\n            }\n\n            if(dist == MAX_DIST){\n                skyVisible = true;\n                col += getSkyColour(rayDir);\n            }else{\n                vec3 position = cameraPos + rayDir * dist;\n                int limit = normalLimit;\n\t\t\t\tfloat xzDist = length(cameraPos.xz - position.xz);\n                \n                //Reduce normal detail after a certain distance.\n                if(xzDist > 0.3*MAX_DIST){\n                    limit = 4;\n                }\n\n                vec3 normal = getNormal(position, xzDist, limit);\n                col += shading(cameraPos, position, normal, rayDir, dist, lightDirection);\n            }\n\n            #ifdef AA\n        }\n    }\n\n    col *= 0.25;\n    \n    #endif\n\n    //Display the sun as a glow in the light direction.\n    if(skyVisible){\n        float mu = dot(rayDir, lightDirection);\n        col += sunColour*getGlow(1.0-mu, 0.0005, 1.0);\n    }\n    \n    //Tonemapping.\n    col = ACESFilm(col);\n\n    //Gamma correction 1.0/2.2 = 0.4545...\n    col = pow(col, vec3(0.4545));\n\n    //Output to screen.\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Track mouse movement and resolution change between frames and set camera position\n\n#define PI 3.14159\n#define EPS 1e-4\n#define CAMERA_DIST 100.0\n\nfloat modulo(float m, float n){\n  return mod(mod(m, n) + n, n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    //Work with just the first four pixels\n    if((fragCoord.x == 0.5) && (fragCoord.y < 4.0)){\n        \n        vec4 oldData = texelFetch(iChannel0, ivec2(0.5), 0).xyzw;\n\n        vec2 oldPolarAngles = oldData.xy;\n        vec2 oldMouse = oldData.zw;\n\n        vec2 polarAngles = vec2(0);\n        vec2 mouse = iMouse.xy / iResolution.xy; \n        \n        // Stop camera going directly above and below\n        float angleEps = 0.01;\n\n        float mouseDownLastFrame = texelFetch(iChannel0, ivec2(0.5, 3.5), 0).x;\n        \n        // If mouse button is down and was down last frame.\n        if(iMouse.z > 0.0 && mouseDownLastFrame > 0.0){\n            \n            // Difference between mouse position last frame and now.\n            vec2 mouseMove = mouse - oldMouse;\n            polarAngles = oldPolarAngles + vec2(5.0, 3.0) * mouseMove;\n            \n        }else{\n            polarAngles = oldPolarAngles;\n        }\n        \n        polarAngles.x = modulo(polarAngles.x, 2.0 * PI - angleEps);\n        polarAngles.y = min(0.49*PI - angleEps, max(angleEps, polarAngles.y));\n\n        // Store mouse data in the first pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 0.5)){\n            // Set value at first frames.\n            if(iFrame < 10){\n                polarAngles = vec2(1.8, 1.33);\n                mouse = vec2(0);\n            }\n            fragColor = vec4(polarAngles, mouse);\n        }\n\n        // Store camera position in the second pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 1.5)){\n            // Cartesian direction from polar coordinates.\n            vec3 cameraPos = normalize(vec3(-cos(polarAngles.x) * sin(polarAngles.y), \n                                             cos(polarAngles.y), \n                                            -sin(polarAngles.x) * sin(polarAngles.y)));\n\n            fragColor = vec4(CAMERA_DIST * cameraPos, 1.0);\n        }\n        \n        //Store resolution change data in the third pixel of Buffer A\n        if(fragCoord == vec2(0.5, 2.5)){\n            float resolutionChangeFlag = 0.0;\n            //The resolution last frame\n            vec2 oldResolution = texelFetch(iChannel0, ivec2(0.5, 2.5), 0).yz;\n            \n            if(iResolution.xy != oldResolution){\n            \tresolutionChangeFlag = 1.0;\n            }\n            \n        \tfragColor = vec4(resolutionChangeFlag, iResolution.xy, 1.0);\n        }\n        \n        //Store whether the mouse button is down in the fourth pixel of Buffer A\n        if(fragCoord == vec2(0.5, 3.5)){\n            if(iMouse.z > 0.0){\n            \tfragColor = vec4(vec3(1.0), 1.0);\n            }else{\n            \tfragColor = vec4(vec3(0.0), 1.0);\n            }\n        }\n        \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\n    Copyright (c) 2020 al-ro\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/","name":"Common","description":"","type":"common"}]}