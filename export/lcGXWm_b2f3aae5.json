{"ver":"0.1","info":{"id":"lcGXWm","date":"1715256381","viewed":39,"name":"Gradient orbit","username":"fusagi","description":"A gradient moon orbiting a gradient planet.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["gradient","orbit","practice","thebookofshaders"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Practice by fusagi â€” 2024\n\n\n// Based on an exercise in https://thebookofshaders.com/07/\n// Original Author @patriciogv - 2015\n// http://patriciogonzalezvivo.com\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265359\n\nfloat is_circle(vec2 st, vec2 center, float radius){\n    return 1.-smoothstep(radius,radius+.01,distance(st,center));\n}\n\n// parametric over time\n// yes this could be done with matrices  \nvec2 elliptic_orbit(vec2 center, float rad_a, float rad_b, float alpha){\n    vec2 orbit_pos = vec2(.0);\n    orbit_pos.x = rad_a * cos(alpha) * cos(iTime) - rad_b * sin(alpha) * sin(iTime) + center.x;\n    orbit_pos.y = rad_b * cos(alpha) * sin(iTime) + rad_a * sin(alpha) * cos(iTime) + center.y;\n    return orbit_pos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // center the picture\n    vec2 st = vec2(fragCoord.x - (iResolution.x - iResolution.y) / 2.0, fragCoord.y) / iResolution.y;\n    //vec2 st = fragCoord.xy/iResolution.yy;\n    \n    float radius = 0.4;\n    \n    float is_big_circle = is_circle(st, vec2(0.5), radius);\n    vec3 big_circle = vec3(0.0, st.x, st.y) * is_big_circle;\n    \n    // ok I want to make the small one orbit the big one\n    // the center of the circle should be on an elliptical orbit as a function of time\n    // this is parametric equations oops\n       \n    vec2 orbit_position = elliptic_orbit(vec2(0.5), 0.6, 0.2, 0.2);\n    \n    float is_small_circle = is_circle(st, orbit_position, 0.1);\n    vec3 small_circle = vec3(st.y, 0.0, st.x) * is_small_circle;\n    \n    vec3 color = vec3(0.);\n    \n    // choose which one is in front\n    // 1 when should be big on top of small\n    float is_behind = 1. - step(0., -sin(iTime));\n    // small on top of big\n    vec3 small_on_big = (1. - is_small_circle) * big_circle + small_circle;\n    // big on top of small\n    vec3 big_on_small = big_circle + (1. - is_big_circle) * small_circle;\n    \n    color = is_behind * big_on_small + (1. - is_behind) * small_on_big;\n    \n\tfragColor = vec4( color, 1.0 );\n}\n\n\n","name":"Image","description":"","type":"image"}]}