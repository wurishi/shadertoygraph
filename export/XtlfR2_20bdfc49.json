{"ver":"0.1","info":{"id":"XtlfR2","date":"1512871231","viewed":382,"name":"Sun Dog 3","username":"dpiponi","description":"Ray traced population of randomly oriented ice crystals.\nSwitch off re-rendering.\nCrank up NSAMPLES as high as you dare! High values crash.\nThese are refractive effects. No reflective effects yet (except TIR).\nSee https://en.wikipedia.org/wiki/Sun_dog","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["atmosphericeffects"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Just a bit of blur\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 position = ( fragCoord.xy / iResolution.xy );\n    vec4 col = vec4(0.0, 0.0, 0.0, 1.0);\n    float w = 0.0;\n    for (int i = 0; i < 1; ++i) {\n        for (int j = 0; j < 1; ++j) {\n            float p = exp(-(float(i*i+j*j)/3.0));\n    \t\tcol += p*texture(iChannel0, position+vec2(1.5*float(i), 1.5*float(j))/iResolution.xy);\n            w += p;\n        }\n    }\n    \n    float n = texture(iChannel0, position).y;\n    float i = col.x/w/n;\n    //i = clamp(i, 0.0, 1.0);\n    fragColor = vec4(mix(vec3(0.5,0.6,1.0),vec3(1.0,0.95,0.85),i),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int NSAMPLES=50;\n\n//\n// Crystal geometry\n//\nconst float u = sqrt(3.0)/2.0;\n\nconst vec3 norms[8] = vec3[8](\n    vec3(u, 0.5, 0.0),\n    vec3(-u, 0.5, 0.0),\n    vec3(u, -0.5, 0.0),\n    vec3(-u, -0.5, 0.0),\n    vec3(0.0, 1.0, 0.0),\n    vec3(0.0, -1.0, 0.0),\n    vec3(0.0, 0.0, 1.0),\n    vec3(0.0, 0.0, -1.0)\n);\n\nfloat ints[8] = float[8](\n    u, u, u, u, u, u, 4.0, 4.0\n);\n\n\nfloat rand(float seed, vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898+seed,78.233-seed))) * 43758.5453+7.0*iTime);\n}\n\nfloat unifrm(float seed, vec2 uv, float a, float b) {\n    return a+(b-a)*rand(seed, uv);\n}\n\nfloat bernoulli(float seed, vec2 co, float p){\n    return rand(seed, co) < p ? 1.0 : -1.0;\n}\n\nfloat unifrm2(float seed, vec2 uv, float a, float b) {\n    return 0.5*(a+b)+0.5*(b-a)*(rand(seed, uv)+rand(3.0*seed+1.0, uv)-1.0);\n}\n\nfloat unifrm3(float seed, vec2 uv, float a, float b) {\n    return 0.5*(a+b)+0.5*(b-a)*(rand(seed, uv)+rand(3.0*seed+1.0, uv)+rand(13.0*seed-7.0, uv)-1.5);\n}\n\nfloat unifrm4(float seed, vec2 uv, float a, float b) {\n    return 0.5*(a+b)+0.5*(b-a)*(rand(seed, uv)+\n                                rand(3.0*seed+1.0, uv)+rand(13.0*seed-7.0, uv)\n                                +rand(-23.0*seed-17.0, uv)-2.0);\n}\n\nfloat expo(float seed, vec2 uv) {\n    float a =-log(1.0-rand(seed, uv));\n    return a;\n}\n\n\nmat3 rotation_z(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n}\n\nmat3 rotation_x(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\n}\n\nmat3 rotation_y(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\n}\n\nmat3 complete(vec3 a) {\n    vec3 u;\n    if (abs(a.x) > abs(a.y)) {\n        u = vec3(0.0, 1.0, 0.0);\n    } else {\n        u = vec3(1.0, 0.0, 0.0);\n    }\n    vec3 v = cross(u, a);\n    vec3 w = cross(a, v);\n    return mat3(normalize(a), normalize(v), normalize(w));\n}\n\nfloat intersect_in(vec3 n, float k, vec3 z, vec3 d) {\n    float den = dot(n, d);\n    if (den >= 0.0) {\n        return -1.0;\n    }\n    return (k-dot(n, z))/den;\n}\n\nfloat intersect_out(vec3 n, float k, vec3 z, vec3 d) {\n    float den = dot(n, d);\n    if (den <= 0.0) {\n        return -1.0;\n    }\n    return (k-dot(n, z))/den;\n}\n\nvec3 refrct(vec3 I, vec3 N, float eta) {\n    float ni = dot(N, I);\n    float k;\n    if (ni < 0.0) {\n        ni = -ni;\n        eta = 1.0/eta;\n        k = 1.0-eta*eta*(1.0-ni*ni);\n    } else {\n        N = -N;\n        k = 1.0-eta*eta*(1.0-ni*ni);\n    }\n    // printf(\"k=%f\\n\", k);\n    if (k < 0.0) {\n        // printf(\"TIR\\n\");\n        return vec3(0.0, 0.0, 0.0);\n    }\n    return eta*I+(eta*ni-sqrt(k))*N;\n}\n\nstruct meet {\n    int N;\n    vec3 z;\n};\n\n    \nmeet test_in(vec3 z, vec3 d) {\n    int besti = -1;\n    float bestt = -1000.0;\n\n    // Find last intersection facing right way\n    for (int i = 0; i < 8; ++i) {\n        float t = intersect_in(norms[i], ints[i], z, d);\n        if (t >= 0.0 && t > bestt) {\n            bestt = t;\n            besti = i;\n        }\n    }\n    float t = bestt;\n    if (t < 0.0) {\n        return meet(-1,vec3(0.0,0.0,0.0));\n    }\n    z = z+t*d;\n\n    //\n    // Is it really inside?\n    //\n    for (int i = 0; i < 8; ++i) {\n        if (i != besti && dot(norms[i], z) > ints[i]) {\n            return meet(-1,vec3(0.0, 0.0, 0.0));\n        }\n    }\n\n    return meet(besti, z);\n}\n\nmeet test_out(vec3 z, vec3 d) {\n    int besti = -1;\n    float bestt = 1000.0;\n\n    // Find first intersection facing same direction\n    for (int i = 0; i < 8; ++i) {\n        float t = intersect_out(norms[i], ints[i], z, d);\n        if (t >= 0.0 && t < bestt) {\n            bestt = t;\n            besti = i;\n        }\n    }\n    float t = bestt;\n    if (t < 0.0) {\n        return meet(-1, vec3(0.0, 0.0, 0.0));\n    }\n    z = z+t*d;\n\n    //\n    // Is it really inside?\n    //\n    for (int i = 0; i < 8; ++i) {\n        if (i != besti && dot(norms[i], z) > ints[i]) {\n            return meet(-1, vec3(0.0, 0.0, 0.0));\n        }\n    }\n\n    return meet(besti, z);\n}\n\nconst float bias = 1e-6;\n\nvec3 ray(vec3 z, vec3 d) {\n    float r = 1.3333;\n    meet a = test_in(z, d);\n    if (a.N < 0) {\n        // Complete miss\n        // printf(\"Miss\\n\");\n        return d;\n    }\n    // First refraction\n    z = a.z;\n    \n    if (unifrm(-1.23, z.xy, 0.0, 1.0) < 0.0) {\n        return reflect(d, normalize(norms[a.N]));\n    }\n    \n    d = refrct(normalize(d), normalize(norms[a.N]), r);\n    z = a.z+bias*d;\n    int count = 0;\n    // We're now inside\n    while (true) {\n        if (count > 2) {\n            return vec3(0.0, 0.0, 0.0);\n        }\n        ++count;\n        meet a = test_out(z, d);\n        if (a.N < 0) {\n            // Complete miss\n            // printf(\"Error - no way out!\\n\");\n            return vec3(0.0, 0.0, 0.0);\n        }\n        z = a.z;\n        // printf(\"newz = %f %f %f\\n\", z.x, z.y, z.z);\n        vec3 td = refrct(normalize(d), normalize(norms[a.N]), r);\n        if (td != vec3(0.0, 0.0, 0.0)) {\n            return td;\n        }\n        // TIR\n        d = reflect(d, normalize(norms[a.N]));\n        z = a.z+bias*d;\n    }\n}\n\nconst float M_PI = 3.1415926;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy -0.5* iResolution.xy)/iResolution.x+0.5;\n    \n    \n    const int nsamples = NSAMPLES;\n    float total = 0.0;\n    for (int k = 0; k < nsamples; ++k) {\n        float z = 2.0*2.0*(uv.y-0.5);\n        float x = 2.0*2.0*(uv.x-0.5);\n        float y = 1.0;\n        vec3 d = normalize(vec3(x, y, z));\n        mat3 b = complete(d);\n        vec3 dx = 4.0*b[1];\n        vec3 dy = 4.0*b[2];\n        vec3 s = -2.0*d+unifrm(18.0*float(k), uv, -1.0, 1.0)*\n                        dx+unifrm(-2.0*float(k), uv, -1.0, 1.0)*dy;\n\n        float theta, psi, phi, alpha;\n        float r = unifrm(27.1*float(k), uv, 0.0, 1.0);\n        if (r < 0.33) {\n            theta = 0.2*expo(3.0*float(k), uv)*bernoulli(-3.0*float(k), uv, 0.5);\n            psi = 0.2*expo(14.0*float(k), uv)*bernoulli(-13.0*float(k), uv, 0.5);\n            phi = unifrm(5.0*float(k), uv, 0.0, 2.0*M_PI);\n            alpha = 0.0;\n        } else if (r < 0.66) {\n            theta = 0.02*expo(3.0*float(k), uv)*bernoulli(-3.0*float(k), uv, 0.5);\n            psi = 0.02*expo(14.0*float(k), uv)*bernoulli(-13.0*float(k), uv, 0.5);\n            phi = unifrm(5.0*float(k), uv, 0.0, 2.0*M_PI);\n            alpha = M_PI/2.0;\n        } else {\n            theta = expo(3.0*float(k), uv)*bernoulli(-3.0*float(k), uv, 0.5);\n            psi = expo(14.0*float(k), uv)*bernoulli(-13.0*float(k), uv, 0.5);\n            phi = unifrm(5.0*float(k), uv, 0.0, 2.0*M_PI);\n            alpha = M_PI/2.0;\n        }\n\n        mat3 m = rotation_y(alpha)*rotation_y(theta)*rotation_x(psi)*rotation_z(phi);\n        s = m*s;\n        d = m*d;\n\n        vec3 ot = ray(s, d)*m;\n        //vec3 out = d*m;\n\n        //bool sun = acos(normalize(ot).y) < 2.0*3.1415926/360.0;\n        float sun = smoothstep(cos(0.5*3.1415926/180.0), 1.0, normalize(ot).y);\n        total += float(sun);\n    }\n    float i = texture(iChannel0, fragCoord.xy/iResolution.xy).x+10000.0*total/float(nsamples);\n    float n = texture(iChannel0, fragCoord.xy/iResolution.xy).y+1.0;\n    \n    fragColor = vec4(i,n,i,i);\n\t//fragColor = vec4(mix(vec3(0.5,0.6,1.0),vec3(1.0,0.975,0.95),i),1.0);\n}\n\n","name":"Buf A","description":"","type":"buffer"}]}