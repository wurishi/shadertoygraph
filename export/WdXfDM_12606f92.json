{"ver":"0.1","info":{"id":"WdXfDM","date":"1588315956","viewed":289,"name":"Floating water block","username":"42yeah","description":"Currently learning refraction - https://frame.42yeah.casa/2020/05/01/refraction.html","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection","refraction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sol(vec3 pos) {\n    return pos.y;\n}\n\nfloat cube(vec3 pos, vec3 off) {\n    pos -= off;\n    vec3 d = abs(pos) - vec3(0.5);\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat ball(vec3 pos, vec3 off) {\n    pos -= off;\n    return length(pos) - 0.5;\n}\n\nvec2 map(vec3 pos) {\n    float closest = 1000.0;\n    float id = -1.0;\n    \n    float dist = sol(pos);\n    if (dist < closest) { closest = dist; id = 0.5; }\n    \n    dist = cube(pos, vec3(0.0, 0.48, 0.0));\n    if (dist < closest) { closest = dist; id = 1.5; }\n\n    dist = ball(pos, vec3(1.2, 0.48, 0.3));\n    if (dist < closest) { closest = dist; id = 2.5; }\n    \n    return vec2(closest, id);\n}\n\nvec2 mapRefr(vec3 pos) {\n    float closest = 1000.0;\n    float id = -1.0;\n\n    float dist = -cube(pos, vec3(0.0, 0.48, 0.0));\n    if (dist < closest) { closest = dist; id = 0.5; }\n\n    return vec2(closest, id);\n}\n\nvec2 trace(vec3 ro, vec3 rd) {\n    float depth = 0.0;\n    float id = -1.0;\n    for (int i = 0; i < 200; i++) {\n        vec2 info = map(ro + rd * depth);\n        if (abs(info.x) <= 0.001) {\n            id = info.y;\n            break;\n        }\n        depth += info.x;\n    }\n    return vec2(depth, id);\n}\n\nvec3 getSkyColor(vec3 rd) {\n    vec3 sky = vec3(0.67, 0.79, 0.89);\n    return mix(sky, vec3(1.0), clamp(rd.y * 5.0, 0.0, 1.0));\n}\n\nvec3 getTileColor(vec3 pos) {\n    vec3 baseColor = vec3(0.9, 0.9, 0.9);\n    vec3 u = mod(floor(pos * 2.0), 2.0);\n    float att = 1.0 - clamp(abs(u.x - u.z), 0.0, 0.22);\n    return vec3(baseColor * att);\n}\n\nvec3 getColor(float id, vec3 pos, vec3 rd) {\n    if (id < -0.5) { return getSkyColor(rd); } // sky\n    if (id < 1.0) { return getTileColor(pos); } // ground\n    if (id < 2.0) { return vec3(1.0, 0.5, 0.0); }\n    if (id < 3.0) { return vec3(1.0, 0.5, 0.0); }\n    return vec3(1.0, 0.0, 0.0); // red for undefined\n}\n\nvec3 getNormal(vec3 pos) {\n    const float epsilon = 0.001;\n    float mapped = map(pos).x;\n    return normalize(vec3(\n        mapped - map(vec3(pos.x - epsilon, pos.yz)).x,\n        mapped - map(vec3(pos.x, pos.y - epsilon, pos.z)).x,\n        mapped - map(vec3(pos.x, pos.y, pos.z - epsilon)).x\n    ));\n}\n\nvec3 getNormalRefr(vec3 pos) {\n    const float epsilon = 0.001;\n    float mapped = mapRefr(pos).x;\n    return normalize(vec3(\n        mapped - mapRefr(vec3(pos.x - epsilon, pos.yz)).x,\n        mapped - mapRefr(vec3(pos.x, pos.y - epsilon, pos.z)).x,\n        mapped - mapRefr(vec3(pos.x, pos.y, pos.z - epsilon)).x\n    ));\n}\n\nvec2 traceRefr(vec3 ro, vec3 rd) {\n    float depth = 0.001;\n    float id = -1.0;\n    for (int i = 0; i < 100; i++) {\n        vec2 info = mapRefr(ro + rd * depth);\n        if (abs(info.x) <= 1e-6) {\n            id = info.y;\n            break;\n        }\n        depth += info.x;\n    }\n    return vec2(depth, id);\n}\n\nvec2 mapFinal(vec3 pos) {\n    float closest = 1000.0;\n    float id = -1.0;\n    \n    float dist = sol(pos);\n    if (dist < closest) { closest = dist; id = 0.5; }\n\n    // We removed the ball here (as it is refractive material)\n\n    dist = ball(pos, vec3(1.2, 0.48, 0.3));\n    if (dist < closest) { closest = dist; id = 2.5; }\n    \n    return vec2(closest, id);\n}\n\nfloat getShadowIntensity(vec3 ro, vec3 rd) {\n    float depth = 1e-3;\n    float res = 1.0;\n    for (int i = 0; i < 25; i++) {\n        vec2 info = mapFinal(ro + rd * depth);\n        res = min(res, 20.0 * info.x / depth);\n        if (res < 1e-3) { break; }\n        depth += info.x;\n    }\n    return res;\n}\n\nvec3 rand3d(float f) {\n    return fract(sin(\n        vec3(f) * vec3(12.456, 92.125, 102.215)\n    ) * 41235.56) * 2.0 - 1.0;\n}\n\nfloat getAmbientOcclusion(vec3 pos, vec3 n) {\n    float totalAO = 0.0;\n    for (int i = 0; i < 25; i++) {\n        vec3 ray = rand3d(float(i));\n        ray = pow(ray, vec3(3.0));\n        ray = sign(dot(ray, n)) * ray;\n        vec2 info = map(pos + n * 1e-3 + 0.15 * ray);\n        totalAO += clamp(info.x * 48.0, 0.0, 1.0);\n    }\n    totalAO /= 25.0;\n    return clamp(totalAO, 0.0, 1.0);\n}\n\nvec3 getNormalFinal(vec3 pos) {\n    const float epsilon = 0.001;\n    float mapped = mapFinal(pos).x;\n    return normalize(vec3(\n        mapped - mapFinal(vec3(pos.x - epsilon, pos.yz)).x,\n        mapped - mapFinal(vec3(pos.x, pos.y - epsilon, pos.z)).x,\n        mapped - mapFinal(vec3(pos.x, pos.y, pos.z - epsilon)).x\n    ));\n}\n\n// traceRefr takes up less iterations, so to save cycles.\nvec2 traceFinal(vec3 ro, vec3 rd) {\n    float depth = 0.0;\n    float id = -1.0;\n    for (int i = 0; i < 100; i++) {\n        vec2 info = mapFinal(ro + rd * depth);\n        if (abs(info.x) <= 0.001) {\n            id = info.y;\n            break;\n        }\n        depth += info.x;\n    }\n    return vec2(depth, id);\n}\n\nvec3 getLight(vec3 pos, vec3 n, vec3 lightDir) {\n    vec3 light = vec3(0.0);\n    float ambient = 1.0;\n    float diffuse = max(dot(n, lightDir), 0.0);\n    float dome = 0.2 + 0.8 * clamp(n.y, 0.0, 1.0);\n    float sol = 0.2 + 0.8 * clamp(-n.y, 0.0, 1.0);\n    float back = max(dot(n, vec3(-lightDir.x, 0.0, -lightDir.z)), 0.0);\n    float shadow = getShadowIntensity(pos + n * 1e-3, lightDir);\n    float ao = getAmbientOcclusion(pos, n);\n\n    light += ambient * vec3(0.22, 0.22, 0.1) * shadow * ao;\n    light += diffuse * vec3(0.97, 0.99, 0.99) * shadow;\n    light += dome * vec3(0.19, 0.20, 0.26) * 2.0 * ao;\n    light += sol * vec3(0.2, 0.22, 0.22) * ao;\n    light += back * vec3(0.1, 0.11, 0.2) * ao;\n    return light;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n    \n    vec3 ro = vec3(3.0 * sin(iTime), 2.0, 3.0 * cos(iTime));\n    vec3 center = vec3(0.0, 0.5, 0.0);\n\n    vec3 front = normalize(center - ro);\n    vec3 right = normalize(cross(front, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, front));\n    \n    mat4 lookAt = mat4(\n        vec4(right, 0.0),\n        vec4(up, 0.0),\n        vec4(front, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n    vec3 rd = normalize(vec3(lookAt * vec4(uv, 2.0, 1.0)));\n\n    vec2 info = trace(ro, rd);\n    vec3 pos = ro + rd * info.x;\n    vec3 n = getNormal(pos);\n\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n\n    vec3 light = vec3(1.0);\n    vec3 refl = vec3(0.0);\n    \n    vec3 objColor = vec3(0.0);\n    if ((info.y > 0.0 && info.y < 1.0) || (info.y > 2.0)) {\n        objColor = getColor(info.y, pos, rd) * getLight(pos, n, lightDir);\n        objColor = pow(objColor, vec3(0.4545));\n    } else if (info.y > 1.0 && info.y < 2.0) {\n        float fresnel = clamp(1.0 + dot(rd, n), 0.0, 1.0);\n        vec3 reflected = reflect(rd, n);\n        info = trace(pos + n * 1e-3, reflected);\n        vec3 reflectedPos = pos + reflected * info.x;\n        vec3 reflectedN = getNormal(reflectedPos);\n        if ((info.y > 0.0 && info.y < 1.0) || (info.y > 2.0)) {\n            light = getLight(pos, n, lightDir);\n        }\n        refl = getColor(info.y, reflectedPos, reflected) * light;\n        \n        rd = refract(rd, n, 1.0 / 1.33); // water\n        info = traceRefr(pos - n * 1e-3, rd);\n\n        pos = pos + rd * info.x;\n        n = getNormalRefr(pos);\n        pos = pos - n * 1e-5;\n\n        rd = refract(rd, n, 1.0 / 1.33);\n        info = traceFinal(pos, rd);\n        pos = pos + rd * info.x;\n        n = getNormalFinal(pos);\n\n        light = vec3(1.0);\n        if ((info.y > 0.0 && info.y < 1.0) || (info.y > 2.0)) {\n            light = getLight(pos, n, lightDir);\n        }\n        \n        vec3 refr = getColor(info.y, pos, rd) * light;\n        objColor = mix(refr, refl, pow(fresnel, 5.0) * 0.8 + 0.2);\n        objColor = pow(objColor, vec3(0.4545));\n    } else {\n        objColor = getColor(info.y, pos, rd);\n    }\n\n    fragColor = vec4(objColor, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}