{"ver":"0.1","info":{"id":"MsVSRc","date":"1468955808","viewed":264,"name":"Cook-Torrance Blobby Dimension","username":"elzeru","description":"Funny shapes with Cook-Torrance shader","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","cooktorrance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Cook-Torrance Blobby Dimension\n// By el Zeru\n// A strange space-time... Are they evel worms froum outer dimensions, or just funky sausages ?\n// In this shader, we play with the Cook-Torrance BRDF. Still many things to enhance and clean,\n// it's a WIP, but I find the result still nice.\n\n\nfloat stepize(float a, int nb)\n{\n \ta = float(int(a*float(nb)))/float(nb);   \n    return a;\n}\n\nvec4 glow(vec2 fragCoord)\n{\n    vec3 color = vec3(texture(iChannel0,fragCoord / iResolution.xy).xyz) +\n        vec3(texture(iChannel0,(fragCoord+vec2(1.0,0.0)) / iResolution.xy).xyz)+\n        vec3(texture(iChannel0,(fragCoord+vec2(-1.0,0.0)) / iResolution.xy).xyz)+\n        vec3(texture(iChannel0,(fragCoord+vec2(0.0,1.0)) / iResolution.xy).xyz)+\n        vec3(texture(iChannel0,(fragCoord+vec2(0.0,1.0)) / iResolution.xy).xyz);\n     color = color*0.2;\n     return vec4(color,1.0);\n        \n}\n\nvec4 lens(vec4 inputPixel, vec2 fragCoord, float amount)\n{\n    vec4 returnImage;\n    \n    vec2 lensShift = vec2(amount*abs(0.5-fragCoord.x/iResolution.x)\n                         ,amount*abs(0.5-fragCoord.y/iResolution.y));\n    vec4 lShift = vec4(texture(iChannel0,(fragCoord-lensShift) / iResolution.xy).xyzx);\n    vec4 rShift = vec4(texture(iChannel0,(fragCoord+lensShift) / iResolution.xy).xyzx);\n   \n    returnImage = vec4(lShift.r, inputPixel.g, rShift.b ,inputPixel.a);\n    \n    return returnImage; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 inputColor = vec4(texture(iChannel0,fragCoord / iResolution.xy).rgba);\n   \n    //inputColor = glow(fragCoord);\n    fragColor = inputColor;\n    float lensShiftAmplitude = 0.01*iResolution.x;\n    fragColor = lens(inputColor, fragCoord, lensShiftAmplitude);\n\n    fragColor.xyz = pow(fragColor.xyz,vec3(1.1))*6.0;  \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159265359\n\n\n// As the distance field is very distorded, we have to use small ray steps\n// If you have a good idea to avoid this, please tell me !\nconst int PRIM_RAY_IT = 400 ;\nconst float PRIM_RAY_STEP = 0.05;\nconst float EPS_NOR = 0.01;\nconst int AO_it = 6;\n\nstruct Impact {\n\tfloat d;\n    float lum;\n\tvec3 col;\n\tint refl;\n};\n\nstruct Light{\n\tvec3 p;\n    float r;    \n    float lum; \n    vec3 col;\n};\n\n\n// Color not managed for now\nLight light1 = Light(vec3( 1.0, 1.0, 1.0), 0.00, 30.0, vec3(0.0,0.0,0.0));\nLight light2 = Light(vec3( 1.0, 1.0, 1.0), 0.00, 30.0, vec3(0.0,0.0,0.0));\n\n// A min function based on the distance for the Impact structures\nImpact getClosest( Impact p1, Impact p2 )\n{\n    if (p1.d<p2.d)\n    {\n        return p1;\n    }\n    else return p2;\n\n}\n\n//Shapes definition\nfloat dSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\nfloat dTerrain(vec3 p)\n{    \n    vec3 p2 = p + vec3(PI/2.0,PI/0.1,0.0);\n    float k=0.1;\n    \n    float rotation = 0.0*iTime*0.1+sin(p.z*1.0);   \n   \n    p2.x = p.x*cos(rotation) + p.y*sin(rotation);\n    p2.y = -p.x*sin(rotation) + p.y*cos(rotation);\n      \n    p2 = p2 + vec3(1.7,1.7,0.0);\n    \n    \n    float peakFrequency = 1.0;\n    float peakAmplitude = 0.4;\n    \n    float microFrequency = 10.0;\n    float microAmplitude = 0.0;\n    \n    // Uncomment for fun\n    //float microAmplitude = 0.9*abs(cos(p.x)*cos(p.y)*cos(p.z)*cos(p.z));\n    \n    \n    float nanoFrequency =120.0;\n    float nanoAmplitude = 0.005;\n    \n    // Chaning this value is also fun\n    float growth = 0.15;\n    \n    float rad = (cos(p2.x)+sin(p2.x));\n    // It is not messy, it's art...\n    float rv = 1.0*cos(rad)+(cos(p2.x)*cos(p2.x)+abs(peakAmplitude*cos(peakFrequency*p2.x)))\n              *(cos(p2.y)*cos(p2.y)+abs(peakAmplitude*cos(peakFrequency*p2.y)))\n              *(-1.2*abs(sin(0.0*iTime+p2.z*1.0))+abs(peakAmplitude*sin(peakFrequency*p2.z))) \n        \t  + growth \n              + microAmplitude*abs(sin(microFrequency*p.x)+sin(microFrequency*p.y))\n              + nanoAmplitude*abs(sin(nanoFrequency*p.x)+sin(nanoFrequency*p.y))\n              +0.2*cos(p2.z);\n    \n    return rv; \n \n}\n\n//Return information about the closest primitives\nImpact map(in vec3 pos)\n{\n    float terrainDistance = dTerrain(pos);\n    vec3 terrainColour = texture(iChannel0, vec2( pos.x/10.0,pos.y/10.0)).xyz;\n\n    terrainColour = vec3(abs(sin(pos.z*2.3)/PI)*0.8,abs(sin(pos.z)/PI)*0.8,abs(cos(pos.z*1.333))/PI*0.9);\n    \n    terrainColour = pow(terrainColour, vec3(1.9));\n  \n    Impact terrain = Impact(terrainDistance, 0.0, terrainColour, 0);\n    \n    //Light globe\n    float lightRadius = light1.r;\n\tfloat lightDistance = dSphere( pos-light1.p, lightRadius );\n    Impact light_p1 = Impact(lightDistance,light1.lum, light1.col, 0);\n    Impact closest = getClosest(terrain,light_p1);\n    \n    \n    lightRadius = light2.r;\n\tlightDistance = dSphere( pos-light2.p, lightRadius );\n    Impact light_p2 = Impact(lightDistance,light2.lum, light2.col, 0);\n    closest = getClosest(closest,light_p2);\n\n    return closest;\n}\n\n//Compute the normal - Gradient of the distance function\nvec3 getNormal( in vec3 pos )\n{\n\tvec2 eps = vec2( EPS_NOR, 0.0 );\t\n\tvec3 nor = vec3(\n\t\tmap(pos+eps.xyy).d - map(pos-eps.xyy).d,\n\t\tmap(pos+eps.yxy).d - map(pos-eps.yxy).d,\n\t\tmap(pos+eps.yyx).d - map(pos-eps.yyx).d );\n    \n\treturn normalize(nor);\n}\n\n//Cast a ray from ro in direction d\nImpact castRay(in vec3 ro, in vec3 inputDir)\n{\t\n    vec3 dir = normalize(inputDir);\n    float t;\n    t = 0.1;\n    Impact impact;\n \tfor (int i = 0; i < PRIM_RAY_IT; i++)\n    {\n        vec3 p = ro+t*dir;\n        impact = map(p);     \n        if(impact.d < t*0.002) {\n            impact.d = t + impact.d;\n            return impact;\n        }\n       \n        t += impact.d*0.1;        \n    }\n    return Impact(0.0,0.0,vec3(0.0,0.0,0.0),-1);\n}\n\nfloat compAO(vec3 p, vec3 norm)\n{\n    float cumulDistToMap = 0.0;\n    vec3 p_AO = p + norm*0.01;\n\n \tfor(int i = 0; i<AO_it; i++)\n    {\n     \tcumulDistToMap +=  (map(p_AO)).d;  \n        p_AO += norm*0.01;\n    }\n    return cumulDistToMap/float(AO_it);\n}\n\n\nvec3 BRDF_CookTorrance(vec3 n, vec3 wi, vec3 wo, float beta, float m, float alpha){ \n    vec3 h = normalize(wi + wo);\n\t// G Term (shadowing)\n\tfloat G1 = 2.*dot(n,h)*dot(n,wo)/dot(wo,h);\n    float G2 = 2.*dot(n,h)*dot(n,wi)/dot(wo,h);\n\tfloat G = min(1., min(G1, G2));\n    \n\t// D term (roughness)\n    alpha = acos(dot(n,h));\n\tfloat D = cos(beta)*exp(-(pow(alpha/m, 2.)));\n     \n    // F Term (Schlick Specular Fresnel Term)\n\tvec3 F = vec3(0.5) + ( 1.0  - vec3(0.5) ) * pow( 1.0 - dot(h, wo), 5.0 );\n\t\n    return F/PI*D*G/(dot(wo,n)*dot(wi,n))+ 0.1;  \n}\n\nvec4 tracePath(in vec3 po, in vec3 dir, in vec2 fragCoord)\n{\n    vec3 p = po;\n    vec3 col_base = vec3(1.0);\n    vec4 col = vec4(0.0);\n    vec3 norm = vec3(0.0);  \n\n    float fact_r = 1.0;\n    float alpha = 1.0;\n    float beta = 0.1;\n    float m = 1.5;\n    for (int i = 0; i<1 ;i++)\n        {  \n\t        Impact impact = castRay(p,dir);\n    \t    p = p + dir*impact.d;            \n            \n            vec3 norm = getNormal(p);\n            \n            float ambiantOcc = compAO(p, norm);\n                \n\t\t\tvec3 dirToLight1 = light1.p - p;   \n\t\t\tImpact impactOnLight1 = castRay(p,dirToLight1);    \n             \n            // vec3 n, vec3 wi, vec3 wo, float beta, float m, float alpha\n            vec3 e1 = BRDF_CookTorrance(norm,\n                                         normalize(dirToLight1),\n                                         -normalize(dir),\n                                         beta,\n                                         m,\n                                         alpha)*max(dot(norm,normalize(dirToLight1)), 0.0);\n                        \n            \n            vec3 myCol = impactOnLight1.lum*col_base*impact.col*(e1)*1.0;\n            \n            \n            vec3 dirToLight2 = light2.p - p;   \n\t\t\tImpact impactOnLight2 = castRay(p,dirToLight2);    \n             \n            // vec3 n, vec3 wi, vec3 wo,float beta, float m, float alpha\n            vec3 e2 = BRDF_CookTorrance(norm,\n                                         normalize(dirToLight2),\n                                         -normalize(dir),\n                                         beta,\n                                         m,\n                                         alpha)*max(dot(norm,normalize(dirToLight2)), 0.0);\n            \n            \n            myCol += impactOnLight2.lum*col_base*impact.col*(e2)*1.0;\n           \n\n            myCol *= ambiantOcc*3.0;\n            \n            col_base = impact.col;             \t\n          \t  \t    \n    \t    col.rgb += myCol*fact_r;\n            \n            vec3 newPos = p + dir*impact.d;\n            \n            float distanceToEye = length((po - newPos));\n            \n            col.rgb = mix(col.rgb, vec3(.0)+col.rgb*0.1, smoothstep(0., 40.0, distanceToEye));\n            //col.a = abs(dot(norm,normalize(dir)));\n\n            \n            fact_r *=0.8;\n            \n            norm = getNormal(p);\n           \t\n            dir = reflect(dir, norm);   \n        }\n   \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 positionShift = vec3(sin(iTime)*0.5 + sin(iTime*4.2)*0.1, \n                              cos(iTime*1.33)*0.5+ cos(iTime*3.3)*0.03, \n                              iTime*1.0);\n\n    \n    vec3 eye = vec3(sin(iTime*0.7)*0.2, cos(iTime*0.2)*0.2,-0.5) + positionShift ;   \n    \n    light1.p = positionShift + 1.0*vec3(0.0+cos(iTime*2.3)*0.2,-0.0,+cos(1.7*iTime)*0.2)+vec3(0.0,0.0,1.0);\n    \n    light2.p = positionShift; //+1.0*vec3(0.0-cos(iTime*2.3)*0.2,-0.0,-cos(1.7*iTime)*0.2)+vec3(0.0,0.0,0.0);\n    \n    float resRatio = iResolution.x/iResolution.y;\n    \n    vec3 pixelPos = vec3(fragCoord.xy/ iResolution.xy*vec2(resRatio,1.0)-vec2(0.5*resRatio,0.5),0.0) + positionShift;\n    \n    vec3 dir = normalize(pixelPos - eye);      \n        \n    dir = normalize (pixelPos - eye);\n        \n    vec4 col = tracePath(eye,dir, fragCoord);                  \n       \n    fragColor = vec4(col);\n    \n}","name":"Buf A","description":"","type":"buffer"}]}