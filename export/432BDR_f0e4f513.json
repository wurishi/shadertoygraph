{"ver":"0.1","info":{"id":"432BDR","date":"1729338362","viewed":282,"name":"true Worley noise","username":"FabriceNeyret2","description":"true Worley noise (without fractal cascade)\nSig'96 paper \"A Cellular Texture Basis Function\": https://itn-web.it.liu.se/~stegu76/TNM084-2019/worley-originalpaper.pdf\n- distrib = Poisson (col<4), not \"1 per cell\" (col4)\n- combine d to 1 to 4 nearest points","likes":29,"published":3,"flags":0,"usePreview":0,"tags":["procedural","voronoi","cellular","worleynoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define poisson(n,h)     floor( normal( float(n), sqrt(float(n)), h ) ) // Poisson distribution (dual to white-noise )\n#define normal(m, s, h)  m + s * gauss(h)                               // Normal distribution\n#define  gauss(u)        sqrt(-2.*log(u.x)) * cos(6.283*u.y)            // takes u = vec2 uniform()\n#define H(v)             fract( 1e3* sin( (v) * mat2(R-7.,91.-R) ) )    // vec2 uniform\n#define hue(v)           ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, D,\n         U = 15. * u/R.y,\n         I = floor(u*vec2(4,4)/R); \n    int m = I.x < 3. ? 4 : 0; // point distrib: col 1-3: Poisson ( = white noise )\n                              //                col 4  : 1 per cell ( = ~ bluenoise, Poisson disc )\n\n    vec4 M = vec4(9);         // returns in M the 4 closest distances\n    for ( int n = 5, k ; k<n*n; k++ ) {             // check neighboors\n        D = floor(U) + vec2(k%n -n/2,k/n -n/2);     // neighboor ID\n        for (float i; i < clamp( poisson(m,H(D)),1.,9.); i++ ) { // amount of points in cell\n            float d = length( U - D - H(D-.791*i) );// distance to random point \n            if      (d<M.x) M.yzw = M.xyz, M.x = d; // sort 1-4 closest neighbors\n            else if (d<M.y) M.zw  = M.yz , M.y = d;\n            else if (d<M.z) M.w   = M.z  , M.z = d;\n            else if (d<M.w)                M.w = d;\n        }\n     }\n\n    O = M;                                                          // brute 1-4 closest neighbors\n    if (I.x>0.) O = M - vec4(0,M);                                  // Mi - Mi-1 always >= 0\n // if (I.x>0.) O = vec4(M.x,(M.x+M.y)*.8,(M.x+M.y+M.z)*.5,(M.x+M.y+M.z+M.w)*.33); // sum Mi up to 1-4\n    if (I.x<2.) O = vec4(O[3-int(I.y)]);                            // show separate components\n // if (I.x>1.&&I.y==2.)                                            // composed in RGB channels\n    if (I.x>1.&&I.y==3.) O = vec4( smoothstep(22./R.y,0.,M.x-.1) ); // show seeds\n    if (I.x>1.&&I.y<2.)  I += floor(3.*iTime),\n                         O = hue( .3*dot(M,vec4(H(I),H(I+.5))*4.-2. ));// random linear combination (mapped to hue)\n\n    O += length(step(fract(u*4./R) , 4./R));                        // separator\n/** I += floor(3.*iTime);\n    O = abs( .3* vec4( dot(M,vec4(H(I   ),H(I+.5))*4.-2. ), // random linear combination (mapped to each channem)\n                       dot(M,vec4(H(I+.1),H(I+.6))*4.-2. ),\n                       dot(M,vec4(H(I+.2),H(I+.7))*4.-2. ),\n                      1));\n/**/\n}","name":"Image","description":"","type":"image"}]}