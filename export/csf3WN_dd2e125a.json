{"ver":"0.1","info":{"id":"csf3WN","date":"1666186373","viewed":152,"name":"Cube of Cubes (or Spheres)","username":"azeem","description":"Using raymarching for this is overkill, I guess.","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["sdf","cube","raymraching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS 32\n#define MAX_DIST 20.\n#define PI 3.14159265359\nfloat smin( float a, float b, float k )\n{\nfloat h = max( k-abs(a-b), 0.0 )/k;\nreturn min( a, b ) - h*h*h*k*(1.0/6.0);\n}\nfloat smax(float a, float b, float k){ return -smin(-a,-b,k);}\nfloat e(float x){\nreturn x < 0.5 ? 4.*pow(x,3.): 1. - pow(-2. * x + 2., 3.) / 2.;\n}\nfloat sphSDF(vec3 p, vec3 c, float r){ return length(p-c)-r;}\nfloat cubeSDF(vec3 p, vec3 c, float s){\nvec3 q = abs(p-c) - s;\nreturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\treturn mat3(-cr, normalize(cross(cd, cr)), -cd);\n}\nvec2 rot(vec2 p,vec2 c,float ang){\n    return (p-c)*mat2(cos(ang), -sin(ang), sin(ang), cos(ang))+c;\n}\nfloat distanceToScene(in vec3 p){\n    float fd=MAX_DIST;\n    float side=.45;\n    float gap=.21;\n    float timeInt=5.;\n    float spe=2.*PI*e(fract(iTime/timeInt));\n    float spe2=2.*PI*e(fract(iTime/timeInt/2.));\n    for(float i=-1.;i<1.1;i+=1.){\n        for(float j=-1.;j<1.1;j+=1.){\n            vec3 cubeP=p;\n            if(j<-.5)cubeP.xz=rot(cubeP.xz,vec2(0.,0.),spe);\n            else if(j<.5)cubeP.xz=rot(cubeP.xz,vec2(0.,0.),spe*2.);\n            else cubeP.xz=rot(cubeP.xz,vec2(0.,0.),spe*3.);\n            for(float k=-1.;k<1.1;k+=1.){\n                vec3 cubeP1=cubeP;\n                vec3 s=vec3( i*(2.*side+gap),j*(2.*side+gap),k*(2.*side+gap)    );\n                cubeP1.xy=rot(cubeP1.xy,s.xy,spe);\n                cubeP1.yz=rot(cubeP1.yz,s.yz,spe);\n                cubeP1-=sin(spe/2.)*.5;\n                float d=cubeSDF(cubeP1,s,side-.8*side*sin(spe2/2.) );\n                float f=sphSDF(cubeP1,s,side-.8*side*sin(spe/2.) );\n                d=smin(f,d,.2);\n                fd=min(fd,d);\n            }\n        }\n    }\n    return fd;\n}\nfloat  marchRay(vec3 rayO, vec3 rayD,inout bool boundary){\n    float dis=0.;\n    float prevD=10.;\n    float d;\n    vec3 p=rayO+rayD*dis;\n    for(int i=0;i<STEPS;i++){\n        p = rayO+rayD*dis;\n        d=distanceToScene(p);\n        if(abs(d)<.001 || dis>MAX_DIST)break;\n        dis+=d;\n        if(d<0.1&&d/prevD>1.){\n            boundary=true;\n            return d;\n        }\n        prevD=d;\n    }\n    return dis;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =(fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 rayO = vec3(4., 4., 4.);//camera pos\n    vec3 lookPoint = vec3(0.,0.,0.);//where to look\n    float zoom=1.;\n    \n    vec3 rayD= camera(rayO, lookPoint) * normalize(vec3(uv, -zoom)); // ray direction\n\n    vec3 col=vec3(0.);\n    bool boundary=false;\n    float dis=marchRay(rayO,rayD,boundary);\n    if(boundary)col=vec3(smoothstep(  0.6,1., 1.-(dis-0.001)/(0.1-0.001) ) );\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}