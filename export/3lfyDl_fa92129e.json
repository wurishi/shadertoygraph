{"ver":"0.1","info":{"id":"3lfyDl","date":"1593380579","viewed":386,"name":"Numerical Gradient Comparison","username":"harry7557558","description":"Comparing 3d numerical differentiation methods.\n\nSeems like the tetrahedron method doesn't work much better than the naive method ~.~","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["gradient","compare","differen"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Comparing numerical gradient methods\n\n// I just discovered that sampling gradient on a 2d simplex \n// has an error of 1/h O(h²), so I want to know if that applies to 3d.\n\n// Left to right: reference, naive method, central difference, tetrahedron method\n\n// In the three graphs on the right:\n// Red indicates the difference in the direction of gradient;\n// Blue indicates the difference in the magnitude of gradient;\n// A brighter color represents a higher error.\n\n// In the reference graph: rgb -> xyz\n\n// Mouse control:\n// Left/Right: view rotation\n// Up/Down: numerical differentiation step\n\n// The 4-sample tetrahedron method doesn't seem to be much better\n// than the 3-sample naive method.\n\n// Using Taylor expansion, one gets: [+ 1/h O(h³)]\n\n// Naive method:        (∂F/∂x,∂F/∂y,∂F/∂z) + h/2 (∂²F/∂x²,∂²F/∂y²,∂²F/∂z²)\n// Central difference:  (∂F/∂x,∂F/∂y,∂F/∂z)\n// Tetrahedron method:  (∂F/∂x,∂F/∂y,∂F/∂z) + h (∂²F/∂y∂z,∂²F/∂x∂z,∂²F/∂x∂y)\n\n// You can uncomment the commented lines in fun() and map()\n// to see how these methods applied to a sphere and a hyperboloid.\n\n// However, you may need to change these:\n#define saturation 1.0\n#define raymch_step_sc 0.8\n\n// ======================================================================= end of story\n\n\n\n// the funny shape: F(x,y,z)=(x²+2y²+z²)³-(9x²+y²)z³-0.5\nfloat fun(in vec3 p) {\n    //return dot(p,p)-1.; // sphere\n    //return p.x*p.y+p.x*p.z+p.y*p.z+1.; // hyperboloid\n    float e = p.x*p.x+2.*p.y*p.y+p.z*p.z;\n\treturn e*e*e-(9.*p.x*p.x+p.y*p.y)*p.z*p.z*p.z-.5;\n}\n\n// return value and analytical gradient at once\nvec4 map(in vec3 p) {\n    //return vec4(2.*p,dot(p,p)-1.); // sphere\n    //return vec4(p.y+p.z,p.x+p.z,p.x+p.y,p.x*p.y+p.x*p.z+p.y*p.z+1.); // hyperboloid\n    vec3 p2 = p*p;\n    float e = p2.x+2.*p2.y+p2.z, f = 9.*p2.x+p2.y;\n    return vec4(\n        e*e*vec3(6,12,6)*p - p2.z*vec3(18.*p.x*p.z,2.*p.y*p.z,3.*f),\n        e*e*e - p2.z*p.z*f - .5);\n}\n\n\n\n// numerical differentiation step\nfloat h = 0.1;\n\n// numerical gradient method id\nint method = 0;\n\n// naive method\nvec3 grad_naive(in vec3 p){\n    float v = fun(p);\n    return (1./h)*vec3(\n        fun(p+vec3(h,0,0))-v,\n        fun(p+vec3(0,h,0))-v,\n        fun(p+vec3(0,0,h))-v);\n}\n// central difference\nvec3 grad_central(in vec3 p){\n    return (.5/h)*vec3(\n        fun(p+vec3(h,0,0))-fun(p-vec3(h,0,0)),\n        fun(p+vec3(0,h,0))-fun(p-vec3(0,h,0)),\n        fun(p+vec3(0,0,h))-fun(p-vec3(0,0,h)));\n}\n// tetrahedron method\nvec3 grad_tetrahedron(in vec3 p){\n\tfloat a = fun(p+vec3(h,h,h));\n\tfloat b = fun(p+vec3(h,-h,-h));\n\tfloat c = fun(p+vec3(-h,h,-h));\n\tfloat d = fun(p+vec3(-h,-h,h));\n\treturn (.25/h)*vec3(a+b-c-d,a-b+c-d,a-b-c+d);\n}\n\n\n\n// raymarching\n\nvec3 light = vec3(.3,.1,1);\nvec3 render(vec3 p, vec3 d) {\n\tfloat t = 3., dt;\n\tfor (int i = 0; i < 1024; i++) {\n        vec4 mp = map(p+t*d);\n\t\tdt = abs(mp.w) / length(mp.xyz);\n\t\tt += raymch_step_sc*dt;\n        if (dt<.001) {\n\t\t\tp += t*d;\n            vec3 grad = mp.xyz;\n            float m0 = length(grad);\n    \t\tvec3 n0 = normalize(grad);\n            vec3 col = vec3(.2*clamp(dot(n0,light),0.,1.)+.2);\n            if (method==0) return col+(n0+vec3(.5))*vec3(.4,.2,.4);\n            \n            if (method==1) grad=grad_naive(p);\n            if (method==2) grad=grad_central(p);\n            if (method==3) grad=grad_tetrahedron(p);\n            float m = length(grad);\n            vec3 n = normalize(grad);\n            \n            float ed = 10.*(1.-dot(n0,n));\n            float el = (m-m0)*(m-m0)/sqrt(m0*m0+1.);\n    \t\treturn col+vec3(ed,0,el)*saturation;\n        }\n\t\tif (t>20.) break;\n\t}\n    return vec3(.5*clamp(dot(d,light),0.,1.));\n}\n\n#define AA 2\n#define res iResolution.xy\nvoid mainImage(out vec4 color, in vec2 coord) {\n    vec3 col = vec3(0.0);\n    vec2 gd = coord.xy;\n    method = int(4.*gd.x/res.x);\n    gd.x = mod(gd.x,.25*res.x);\n    \n    for (int i=0;i<AA;i++) for (int j=0;j<AA;j++) {\n        vec2 uv=(12./res.x)*((gd+vec2(i,j)/float(AA))-vec2(.125,.5)*res.xy);\n        vec3 pos = vec3(0,-10,0.);\n        vec3 dir = vec3(uv.x,0,uv.y)-pos;\n        float a = .3*sin(iTime);\n        mat3 R = mat3(1,0,0,0,cos(a),-sin(a),0,sin(a),cos(a));\n        if (iMouse.z>0.){\n            uv = iMouse.xy/res.xy;\n            a = 6.283*(uv.x-.5);\n            R = mat3(cos(a),-sin(a),0,sin(a),cos(a),0,0,0,1) * R;\n            a = 2.*(uv.y-.5);\n            h = 0.1+0.1*a;\n        }\n        light = R*vec3(.3,.1,1);\n        pos = R*pos, dir = R*dir;\n        col += render(pos,normalize(dir));\n    }\n    \n    color = vec4(col/float(AA*AA),1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}