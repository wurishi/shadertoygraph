{"ver":"0.1","info":{"id":"mdjXRW","date":"1719257301","viewed":48,"name":"Path Tracer Reference","username":"Tech_","description":"Reference Path Tracer.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"7sfXzN","parentname":"Cornell Box Template"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv    = fragCoord / iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb / float(iFrame + 1);\n    vec2 px    = rcp(iResolution.xy);\n    \n    color *= 0.5;\n    color = TonemapPrism(color);\n    color = LinearTosRGB(color);\n   \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_STEPS 300\n#define MAX_DIST 100.0\n#define SURF_DIST 1e-5\n\n#define EPS 1e-6\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define rcp(x) (1.0 / (x))\n#define max0(x) max(x, 0.0)\n#define maxEPS(x) max(x, EPS)\n\n#define SUN_ANGLE 1.1\n\n#define IBL\n\nconst float PI  = radians(180.0);\nconst float TAU = PI * 2.0;\nconst float INV_PI = rcp(PI);\nconst vec3  LIGHT_INTENSITY = vec3(3.0);\n\nfloat pow2(float x) { return x * x; }\nvec2  pow2(vec2 x)  { return x * x; }\nvec3  pow2(vec3 x)  { return x * x; }\n\nfloat pow3(float x) { return x * x * x; }\nvec2  pow3(vec2 x)  { return x * x * x; }\nvec3  pow3(vec3 x)  { return x * x * x; }\n\nfloat pow4(float x) { return pow2(pow2(x)); }\nvec2  pow4(vec2 x)  { return pow2(pow2(x)); }\nvec3  pow4(vec3 x)  { return pow2(pow2(x)); }\n\nfloat pow5(float x) { return pow3(x) * pow2(x); }\nvec2  pow5(vec2 x)  { return pow3(x) * pow2(x); }\nvec3  pow5(vec3 x)  { return pow3(x) * pow2(x); }\n\nfloat maxOf(vec3 x) { return max(x.x, max(x.y, x.z)); }\n\nstruct ComplexVec3\n{\n    vec3 r;\n    vec3 i;\n};\n\n// https://en.wikipedia.org/wiki/Refractive_index (0C, 1atm)\nconst ComplexVec3 airIOR = ComplexVec3(vec3(1.000293), vec3(0.0));\n\n// Complex Math\nComplexVec3 ComplexAdd(ComplexVec3 a, ComplexVec3 b)\n{\n    ComplexVec3 c;\n    c.r = a.r + b.r;\n    c.i = a.i + b.i;\n    return c;\n}\n\nComplexVec3 ComplexMult(ComplexVec3 a, ComplexVec3 b) \n{\n    ComplexVec3 c;\n    c.r = a.r * b.r - a.i * b.i;\n    c.i = a.r * b.i + a.i * b.r;\n    return c;\n}\n\nComplexVec3 ComplexMult(ComplexVec3 a, float b) \n{\n    return ComplexVec3(a.r * b, a.i * b);\n}\n\nComplexVec3 ComplexDiv(ComplexVec3 a, ComplexVec3 b) \n{\n    ComplexVec3 c;\n    vec3 denom = b.r * b.r + b.i * b.i;\n    c.r = (a.r * b.r + a.i * b.i) / denom;\n    c.i = (a.i * b.r - a.r * b.i) / denom;\n    return c;\n}\n\nComplexVec3 ComplexSub(ComplexVec3 a, ComplexVec3 b) \n{\n    ComplexVec3 c;\n    c.r = a.r - b.r;\n    c.i = a.i - b.i;\n    return c;\n}\n\nComplexVec3 ComplexSub(float a, ComplexVec3 b) \n{\n    return ComplexVec3(a - b.r, b.i);\n}\n\nvec3 ComplexAbs(ComplexVec3 num) \n{\n    return sqrt(num.r * num.r + num.i * num.i);\n}\n\nComplexVec3 ComplexSqrt(ComplexVec3 num) \n{\n    ComplexVec3 c;\n    vec3 absNum = ComplexAbs(num);\n    c.r =               sqrt(max(num.r + absNum, 0.0) * 0.5);\n    c.i = sign(num.i) * sqrt(max(num.i - absNum, 0.0) * 0.5);\n    return c;\n}\n\nComplexVec3 ComplexPow2(ComplexVec3 num)\n{\n    ComplexVec3 c;\n    c.r = num.r * num.r - num.i * num.i;\n    c.i = 2.0 * num.r * num.i;\n    return c;\n}\n\n// F0/IOR conversions\nfloat IORToF0(float ior)\n{\n    return pow2((1.0 - ior) / (1.0 + ior));\n}\n\nvec3 IORToF0(vec3 ior)\n{\n    return pow2((1.0 - ior) / (1.0 + ior));\n}\n\nvec3 IORToF0(vec3 n1, vec3 n2)\n{\n    return pow2((n1 - n2) / (n1 + n2));\n}\n\nfloat F0ToIOR(float f0)\n{\n    return 2.0 / maxEPS(1.0 - sqrt(f0)) - 1.0;\n}\n\nvec3 F0ToIOR(vec3 f0)\n{\n    return 2.0 / maxEPS(1.0 - sqrt(f0)) - 1.0;\n}\n\nstruct MaterialData \n{\n    vec3 albedo;\n    float roughness;\n    // bool isMetal;\n    vec3 f0;\n    // float porosity;\n    // float subsurface;\n    // float ao;\n    float emissive;\n    // float opacity;\n    ComplexVec3 ior;\n};\n\nconst MaterialData airMaterial = MaterialData(\n    vec3(1.0),\n    0.0,\n    // false,\n    vec3(0.0),\n    // 0.0,\n    // 0.0,\n    // 1.0,\n    0.0,\n    // 1.0,\n    airIOR\n);\n\n// Other\nstruct RayMarchObject \n{\n    MaterialData material;\n    float dist;\n};\n\nmat2 Rot(float a)\n{\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat SDFBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat SDFSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// ACES Fit\n/*\n    From https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n    By https://github.com/selfshadow\n*/\nmat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\nmat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 ACESFitted(vec3 color)\n{\n    color = color * ACESInputMat;\n    color = RRTAndODTFit(color);\n    color = color * ACESOutputMat;\n    color = saturate(color);\n\n    return color;\n}\n\n// Custom Tonemaps\nvec3 TonemapTech2022(vec3 color, const float Tl, const float Ts, const float S)\n{\n\treturn (1.0 - exp(-color / Tl) * Ts) * color / (color + S);\n}\n\nvec3 EvaluateLSICurve(vec3 x, float l, float s, float i)\n{\n    vec3 a = pow(x / l, vec3(2.0 * rcp(s)));\n    return i * pow(a / (a + 1.0), vec3(0.5 * s)) + (1.0 - i);\n}\n\n#define tonemapConfiguration TONEMAP_CINEMATIC\nvec3 TonemapPrism(vec3 color)\n{\n    /*\n        Custom parameterized tone.\n        Can yield a variety of different desired looks.\n\n        ~ Tech\n    */\n\n    const mat2x3 TONEMAP_CINEMATIC = mat2x3(\n        0.25085, 1.37, 0.95,\n        0.31357, 1.62, 1.00\n    );\n\n    const mat2x3 TONEMAP_NEUTRAL = mat2x3(\n        0.325, 1.0, 0.3,\n        0.813, 1.0, 1.0\n    );\n\n    vec3 toe       = EvaluateLSICurve(color, tonemapConfiguration[0][0], tonemapConfiguration[0][1], tonemapConfiguration[0][2]);\n    vec3 shoulder  = EvaluateLSICurve(color, tonemapConfiguration[1][0], tonemapConfiguration[1][1], tonemapConfiguration[1][2]);\n\n    return toe * shoulder;\n}\n\nvec3 LinearTosRGB(vec3 x)\n{\n\tvec3 sRGBLo = x * 12.92;\n\tvec3 sRGBHi = pow(abs(x), vec3(1.0 / 2.4)) * 1.055 - 0.055;\n\treturn mix(sRGBHi, sRGBLo, step(x, vec3(0.0031308)));\n}\n\nvec3 SRGBToLinear(vec3 x)\n{\n    vec3 linearLo = x / 12.92;\n    vec3 linearHi = pow((x + 0.055) / 1.055, vec3(2.4));\n    return mix(linearHi, linearLo, step(x, vec3(0.04045)));\n}\n\n/* https://www.shadertoy.com/view/4djSRW */\nvec2 Hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 UniformSphereSample(vec2 hash) \n{\n    hash = vec2(hash.x * TAU, hash.y * 2.0 - 1.0);\n    return vec3(vec2(sin(hash.x), cos(hash.x)) * sqrt(1.0 - pow2(hash.y)), hash.y);\n}\n\nvec3 UniformHemisphereSample(vec3 vector, vec2 hash) \n{\n    vec3 dir = UniformSphereSample(hash);\n    return dot(dir, vector) < 0.0 ? -dir : dir;\n}\n\nvec3 CosineWeightedHemisphereSample(vec3 vector, vec2 hash)\n{\n    vec3 dir = normalize(UniformSphereSample(hash) + vector);\n    return dot(dir, vector) < 0.0 ? -dir : dir;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"MaterialData MakeMaterial(vec3 albedo, float roughness, vec3 f0, float emissive)\n{\n    return MaterialData(\n        albedo,\n        roughness,\n        f0,\n        emissive,\n        ComplexVec3(F0ToIOR(f0), vec3(0.0))\n    );\n}\n\nRayMarchObject GetScene(vec3 p) \n{\n    // Material Definitions\n    MaterialData defaultWhite  = MakeMaterial(vec3(1.0), 1.0, vec3(0.03), 0.0);\n    MaterialData defaultGreen  = MakeMaterial(vec3(0.09, 1.0, 0.16), 1.0, vec3(0.03), 1.0);\n    MaterialData defaultBlue   = MakeMaterial(vec3(0.09, 0.12, 1.0), 1.0, vec3(0.03), 2.0);\n    MaterialData defaultRed    = MakeMaterial(vec3(1.0, 0.09, 0.16), 1.0, vec3(0.03), 2.0);\n    MaterialData emissiveWhite = MakeMaterial(vec3(1.0), 1.0, vec3(0.1), 0.0);\n\n    // Scene Definitions\n    float distBox = SDFBox(vec3(Rot(0.5) * p.xz, p.y).xzy + vec3(0.02, 0.02, -0.04), vec3(0.025, 0.055, 0.025));\n    RayMarchObject box = RayMarchObject(defaultWhite, distBox);\n    \n    float distCube = SDFSphere(p - vec3(0.035, -0.05, -0.02), 0.025);\n    RayMarchObject cube = RayMarchObject(defaultWhite, distCube);\n    \n    float leftBoxDist = SDFBox(p + vec3(0.1, -0.025, 0.0), vec3(0.0005, 0.1, 0.1));\n    RayMarchObject leftBox = RayMarchObject(defaultGreen, leftBoxDist);\n    \n    float rightBoxDist = SDFBox(p - vec3(0.1, 0.025, 0.0), vec3(0.0005, 0.1, 0.1));\n    RayMarchObject rightBox = RayMarchObject(defaultBlue, rightBoxDist);\n    \n    float groundBoxDist = SDFBox(p - vec3(0.0, -0.075, 0.0), vec3(0.1, 0.0, 0.1));\n    RayMarchObject groundBox = RayMarchObject(defaultWhite, groundBoxDist);\n    \n    float topBoxDist = SDFBox(p - vec3(0.0, 0.125, 0.0), vec3(0.1, 0.0005, 0.1));\n    RayMarchObject topBox = RayMarchObject(defaultWhite, topBoxDist);\n    \n    float backBoxDist = SDFBox(p - vec3(0.0, 0.025, 0.1), vec3(0.1, 0.1, 0.0));\n    RayMarchObject backBox = RayMarchObject(defaultWhite, backBoxDist);\n    \n    float lampDist = SDFBox(p - vec3(0.0, 0.124, 0.0), vec3(0.04, 0.0005, 0.04));\n    RayMarchObject lamp = RayMarchObject(emissiveWhite, lampDist);\n    \n    const int objectCount = 8;\n    RayMarchObject[objectCount] allObjects = RayMarchObject[objectCount](\n        box, cube, leftBox, rightBox, groundBox, backBox, topBox, lamp\n    );\n    \n    //////////////////////////////////////////\n    \n    RayMarchObject finalObject = allObjects[0];\n    \n    for (int i = 0; i < objectCount - 1; i++)\n    {\n        RayMarchObject currentObj = allObjects[i + 1];\n        if (currentObj.dist < finalObject.dist) finalObject = currentObj;\n    }\n    \n    return finalObject;\n}\n\nRayMarchObject RayMarch(vec3 rayOrigin, vec3 rayDir) \n{\n\tfloat originDist = 0.0;\n    MaterialData material;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n    \tvec3 p = rayOrigin + rayDir * originDist;\n        RayMarchObject object = GetScene(p);\n        \n        originDist += object.dist;\n        \n        if (originDist       > MAX_DIST ) break;\n        if (abs(object.dist) < SURF_DIST) { material = object.material; break; }\n    }\n    \n    return RayMarchObject(material, originDist);\n}\n\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetScene(p).dist;\n    const vec2 eps = vec2(EPS, 0.0);\n    \n    vec3 n = d - vec3(\n        GetScene(p - eps.xyy).dist,\n        GetScene(p - eps.yxy).dist,\n        GetScene(p - eps.yyx).dist\n    );\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z)\n{\n    vec3 f = normalize(l - p);\n    vec3 r = normalize(cross(vec3(0.0, 1.0, 0.0), f));\n    vec3 u = cross(f, r);\n    vec3 c = f * z;\n    vec3 i = c + uv.x * r + uv.y * u;\n    return normalize(i);\n}\n\nfloat TraceShadow(vec3 hitPos, vec3 L)\n{\n    if (maxOf(LIGHT_INTENSITY) == 0.0) return 0.0;\n\n    bool hit = false;\n    \n    vec2 hash = Hash22(gl_FragCoord.xy + iTime * vec2(11.342, -23.2417));\n    L = mix(L, UniformHemisphereSample(L, hash), 0.03);\n    \n    RayMarchObject sampleObject = RayMarch(hitPos + L * 0.0001, L);\n    \n    hit = sampleObject.dist < MAX_DIST;\n    \n    return float(!hit);\n}\n\nvec3 ComplexFresnelNonpolarized(float cosThetaI, ComplexVec3 n1, ComplexVec3 n2)\n{\n    ComplexVec3 eta = ComplexDiv(n1, n2);\n    float sinThetaISqr = 1.0 - pow2(cosThetaI);\n\n    ComplexVec3 cosThetaT = ComplexSqrt(ComplexSub(1.0, ComplexMult(ComplexPow2(eta), sinThetaISqr)));\n\n    // Senkrecht (perpendicular) reflectance\n    ComplexVec3 aS = ComplexMult(n1, cosThetaI);\n    ComplexVec3 bS = ComplexMult(n2, cosThetaT);\n    ComplexVec3 nomS = ComplexSub(aS, bS);\n    ComplexVec3 denomS = ComplexAdd(aS, bS);\n    vec3 rS = pow2(ComplexAbs(ComplexDiv(nomS, denomS)));\n\n    // Parallel reflectance\n    ComplexVec3 aP = ComplexMult(n2, cosThetaI);\n    ComplexVec3 bP = ComplexMult(n1, cosThetaT);\n    ComplexVec3 nomP = ComplexSub(aP, bP);\n    ComplexVec3 denomP = ComplexAdd(aP, bP);\n    vec3 rP = pow2(ComplexAbs(ComplexDiv(nomP, denomP)));\n\n    return 0.5 * (rS + rP);\n}\n\nvec3 UnitHemisphericalAlbedo(vec3 f0)\n{\n    return pow(0.996901 * f0, 0.637487 + 0.570946 * sqrt(f0));\n}\n\nvec3 FresnelHemisphereAvg(vec3 f0)\n{\n    return 0.342004 * (pow(0.655311 * tan(f0), vec3(0.210603)) + tan(f0 + 0.0859915));\n}\n\nfloat DistributionTrowbridgeReitz(float NdotH, float alpha2)\n{\n    float denom = (NdotH * NdotH * (alpha2 - 1.0) + 1.0);\n    return alpha2 / (PI * denom * denom);\n}\n\nfloat G2SmithTR(float NdotV, float NdotL, float alpha2) \n{\n    float masking = NdotL * sqrt(NdotV * NdotV * (1.0 - alpha2) + alpha2);\n    float shadowing = NdotV * sqrt(NdotL * NdotL * (1.0 - alpha2) + alpha2);\n    return saturate(2.0 * NdotV * NdotL / (shadowing + masking));\n}\n\nvec3 RoughK(vec3 f0)\n{\n    /*\n        Fresnel correction factor for highly reflective\n        and rough Hammon materials.\n        \n        ~ Tech\n    */\n    \n    vec3 k = /*(48.0 / 35.0) */ pow2(1.0 - FresnelHemisphereAvg(f0)) / (1.0 - UnitHemisphericalAlbedo(f0));\n    return mix(k, sqrt(1.0 - f0), pow2(f0));\n}\n\nvec3 DiffuseHammon(MaterialData m1, MaterialData m2, float NdotL, float NdotH, float LdotV, float NdotV)\n{   \n    vec3 roughK = RoughK(m2.f0);\n    \n    vec3 viewRough = roughK * (LdotV * (0.25 - 0.1 * LdotV) + 0.35) * ((0.5 + NdotH) / max(NdotH, 0.15));\n    vec3 viewSmooth = max0(1.0 - ComplexFresnelNonpolarized(NdotL, m1.ior, m2.ior))\n                    * max0(1.0 - ComplexFresnelNonpolarized(NdotV, m1.ior, m2.ior))\n                    / (1.0 - (UnitHemisphericalAlbedo(m2.f0)));\n   \n    vec3 single   = INV_PI * mix(viewSmooth, viewRough, m2.roughness);\n    vec3 multi    = 0.1159 * m2.roughness * m2.albedo * pow2(roughK);\n    multi = multi / (1.0 - multi);\n    \n    return single + multi;\n}\n\nvec3 EvaluateEmission(MaterialData material)\n{\n    return material.emissive * material.albedo;\n}\n\nvec3 EvaluateDiffuseBRDF(MaterialData material, vec3 pos, vec3 L, float NdotL, float NdotH, float LdotV, float NdotV)\n{\n    float shadow  = TraceShadow(pos, L);\n    vec3 diffuse  = DiffuseHammon(airMaterial, material, NdotL, NdotH, LdotV, NdotV) * NdotL;\n\n    return shadow * diffuse * material.albedo * LIGHT_INTENSITY;\n}\n\n/* With shadow out */\nvec3 EvaluateDiffuseBRDF(MaterialData material, vec3 pos, vec3 L, float NdotL, float NdotH, float LdotV, float NdotV, inout float shadow)\n{\n    shadow  = TraceShadow(pos, L);\n    vec3 diffuse  = DiffuseHammon(airMaterial, material, NdotL, NdotH, LdotV, NdotV) * NdotL;\n    \n    return shadow * diffuse * material.albedo * LIGHT_INTENSITY;\n}\n\nvec3 EvaluateSpecularBRDF(MaterialData material, float NdotL, float NdotH, float NdotV, float VdotH)\n{\n    float roughness2 = pow2(material.roughness);\n    \n    float D  = DistributionTrowbridgeReitz(NdotH, roughness2);\n    float G2 = G2SmithTR(max0(NdotV), NdotL, roughness2);\n    vec3  F  = ComplexFresnelNonpolarized(VdotH, airMaterial.ior, material.ior);\n    \n    return D * G2 * F * rcp(4.0 * NdotV * NdotL);\n}\n\nvec3 SampleGGXVNDF(vec3 Ve, float roughness, vec2 hash) \n{\n    vec3 v = normalize(vec3(roughness * Ve.x, roughness * Ve.y, Ve.z));\n\n    float lensq = dot(v.xy, v.xy);\n    vec3 t1 = lensq > 0.0 ? vec3(-v.y, v.x, 0.0) * inversesqrt(lensq) : vec3(1.0, 0.0, 0.0);\n    vec3 t2 = cross(v, t1);\n    float r = sqrt(hash.x);\n    float phi = TAU * hash.y;\n\n    float p1 = r * cos(phi);\n    float p2 = r * sin(phi);\n    float s = 0.5 * (1.0 + v.z);\n    p2 = mix(sqrt(1.0 - p1 * p1), p2, s);\n\n    vec3 n = p1 * t1 + p2 * t2 + sqrt(max(0.0, 1.0 - p1 * p1 - p2 * p2)) * v;\n\n    return normalize(vec3(roughness * n.x, roughness * n.y, max(0.0, n.z)));\n}\n\n// TODO\nvec3 TraceReflection(MaterialData material, vec3 hitPos, vec3 N, vec3 V, vec3 L)\n{\n    vec2 hash = Hash22(gl_FragCoord.xy + iTime * vec2(11.342, -23.2417));\n    // vec3 rV = -SampleGGXVNDF(-V, 0.0, hash);\n    vec3 rR = -reflect(V, N);\n    \n    RayMarchObject sampleObject = RayMarch(hitPos + rR * 0.0001, rR);\n    \n    vec3 reflectionPos = hitPos + rR * sampleObject.dist;\n    \n    vec3 newV = rR;\n    vec3 newN = GetNormal(reflectionPos);\n    vec3 newH = normalize(newV + L);\n    \n    float NdotL = dot(newN, L   );\n    float NdotH = dot(newN, newH);\n    float LdotV = dot(L   , newV);\n    float NdotV = dot(newN, newV);\n    float VdotH = dot(newV, newH);\n    \n    float shadow  = 0.0;\n    vec3 diffuse  = EvaluateDiffuseBRDF(sampleObject.material, reflectionPos, L, NdotL, NdotH, LdotV, NdotV, shadow);\n    vec3 specular = EvaluateSpecularBRDF(sampleObject.material, NdotL, NdotH, NdotV, VdotH) * max0(NdotL) * shadow;\n    vec3 emission = EvaluateEmission(sampleObject.material);\n    \n    return max0(diffuse + specular + emission);\n}\n\nvec3 PathTraceAmbientDiffuse(MaterialData material, vec3 pos, vec3 N, vec3 V, vec3 L)\n{\n    const uint bounces = 1u;\n\n    vec3 ambient = vec3(0.0);\n    vec3 throughput = vec3(1.0);\n    \n    for (uint i = 0u; i < bounces; i++)\n    {\n        vec2 hash = Hash22(gl_FragCoord.xy + iTime * vec2(11.342, -23.2417));\n        vec3 rL   = UniformHemisphereSample(N, hash);\n\n        RayMarchObject object = RayMarch(pos + rL * 0.0001, rL);\n\n        vec3  rH     = normalize(rL + V);\n        float rNdotL = dot(N , rL);\n        float rNdotH = dot(N , rH);\n        float rLdotV = dot(rL,  V);\n        float rNdotV = dot(N ,  V);\n\n        if (object.dist > MAX_DIST)\n        {\n            #ifdef IBL\n            return SRGBToLinear(texture(iChannel1, rL).rgb) * INV_PI * 0.5 * material.albedo * LIGHT_INTENSITY;\n            #else\n            return vec3(0.0);\n            #endif\n        }\n\n        vec3 hitPos = pos + rL * object.dist;\n\n        vec3  bsdf     = DiffuseHammon(object.material, airMaterial, rNdotL, rNdotH, rLdotV, rNdotV) * rNdotL * object.material.albedo;\n        float shadow   = TraceShadow(hitPos, L);\n        vec3  emission = EvaluateEmission(object.material);\n        \n        ambient    += (bsdf * shadow + emission) * throughput;\n        throughput *= bsdf;\n        \n        pos = hitPos;\n        N   = GetNormal(hitPos);\n        V   = rL;\n    }\n    \n    return ambient * material.albedo;\n}\n\nvec3 Render(MaterialData material, vec3 pos, vec3 N, vec3 V, vec3 L)\n{\n    vec3 H = normalize(L + V);\n    vec3 R = reflect(N, V);\n\n    float NdotL = dot(N, L);\n    float NdotH = dot(N, H);\n    float LdotV = dot(L, V);\n    float NdotV = dot(N, V);\n    float VdotH = dot(V, H);\n\n    float shadow = 0.0;\n\n    vec3 ambient  = PathTraceAmbientDiffuse(material, pos, N, V, L);\n    vec3 diffuse  = EvaluateDiffuseBRDF(material, pos, L, NdotL, NdotH, LdotV, NdotV, shadow);\n    vec3 specular = EvaluateSpecularBRDF(material, NdotL, NdotH, NdotV, VdotH) * max0(NdotL) * shadow;\n    vec3 emission = EvaluateEmission(material);\n\n    specular += TraceReflection(material, pos, N, V, L) * ComplexFresnelNonpolarized(max0(NdotV), airMaterial.ior, material.ior);\n    \n    return max0(diffuse + specular + ambient + emission);\n}\n\nvec3 GetFrame()\n{\n    vec3 color;\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    uv += (Hash22(vec2(iTime)) * 2.0 - 1.0) * rcp(iResolution.xy); // Quick AA\n\n    vec3 rayOrigin = vec3(0.0, 0.021, -0.135) * 2.2;\n    vec3 rayDir = GetRayDir(uv, rayOrigin, vec3(0.0, 0.02, 0.0), 1.);\n   \n    RayMarchObject scene = RayMarch(rayOrigin, rayDir);\n    \n    if (scene.dist < MAX_DIST) \n    {\n        vec3 hitPos = rayOrigin + rayDir * scene.dist;\n        \n        vec3 N = GetNormal(hitPos);\n        vec3 L = normalize(vec3(SUN_ANGLE, 0.6, -1.3));\n        \n        color = Render(scene.material, hitPos, N, -rayDir, L);\n    }\n    #ifdef IBL\n    else\n    {\n        color = SRGBToLinear(texture(iChannel1, rayDir).rgb) * LIGHT_INTENSITY;\n    }\n    #endif\n\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 color = texture(iChannel0, gl_FragCoord.xy / iResolution.xy).rgb;\n    \n    if (iFrame == 0) color  = vec3(0.0);\n    else             color += GetFrame();\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}