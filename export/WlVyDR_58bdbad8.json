{"ver":"0.1","info":{"id":"WlVyDR","date":"1611789780","viewed":136,"name":"Minimal surface simulation ","username":"arifr123","description":"[url=https://en.wikipedia.org/wiki/Minimal_surface]Minimal surface[/url] (soap film) simulation.\nPlotting the surface using a technique I used in my [url=https://www.shadertoy.com/view/ttKyzh]surface plotter[/url].","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["math","gradientdescent","minimalsurface","soapfilm"],"hasliked":0,"parentid":"ttKyzh","parentname":"Surface Plotter - Boy's surface"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nMinimal surface simulation (soap film).\n\n### Try clicking S ones, and then dragging one of the points. (You should stop the rotation first by clicking the SPACE) ###\n\n--- Actions: ---\nMouse options:\n    Defult - drag the mouse to rotate the model, or:\n    Click S - select and move spesific points on the surface.\n    Click D - enable/disable eraser with the mouse.\n\nOther options:\n    Click SPACE - stop/start auto-rotate.\n    Click M - stop/start the minimization process.\n    Click G - hide/show grid lines.\n\n\n\n### You can change to a different surface in \"Common\". ###\n\nCatenoid:\n    https://en.wikipedia.org/wiki/Catenoid\n\n*/\n\n\n\n\n\n#define BUFFA iChannel0\n#define BUFFB iChannel2\n#define KEYBOARD iChannel1\n\nconst int searchSize = 3;\n\nvec3 normal(vec3 origin, ivec2 s) // not Normalized\n{\n    return cross((portalSurface(s + ivec2(1, 0)).xyz - origin), (portalSurface(s + ivec2(0, 1)).xyz - origin));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    int frame = iFrame;\n    \n\n    ivec2 coord = ivec2(fragCoord);\n        \n    /// Rotation Data ///\n    vec2 rotation = getRotation();\n        \n    vec2 cisXY = cis(rotation.x);\n    vec2 cisRZ = cis(rotation.y);\n        \n    vec3 right = vec3(-cisXY.y, cisXY.x, 0);\n    vec3 up = vec3(-cisRZ.y * cisXY, cisRZ.x);\n    \n    vec3 forward = cross(right, up);\n    /////////////////////\n    \n    vec3 light = normalize(vec3(1, 0, -1));\n    float ambient = 0.3;\n    \n\n    \n    float coefficientSum = 0.;\n    vec3 avgPos = vec3(0);\n    vec3 avgNorm = vec3(0);\n    vec2 avgS = vec2(0);\n    \n    vec4 maxPriority = vec4(vec3(0), NONE);\n    \n    ivec2 res = ivec2(iResolution.xy);\n    for(int x = max(0, coord.x - searchSize); x <= min(coord.x + searchSize, res.x - 1); x++)\n    {\n        for(int y = max(0, coord.y - searchSize); y <= min(coord.y + searchSize, res.y - 1); y++)\n        {\n            ivec2 otherCoord = ivec2(x, y);\n            vec4 otherP = texelFetch(BUFFA, otherCoord, 0);\n            \n            if(Mode(otherP) == ACTIVE || texelFetch(KEYBOARD, ivec2(71 /* g */, 2), 0).x <= 0.)\n            {\n                switch(higherPriority(maxPriority, otherP, forward, 0.0))\n                {\n                    case 1:\n                        coefficientSum = 0.;\n                        avgPos = vec3(0);\n                        avgNorm = vec3(0);\n\n                        // NO BREAK!\n                        //break;\n\n                    case 0:\n                        vec3 pos = portalSurface(otherP.xy).xyz;\n                        \n                        float coefficient = 1.;  // exp(- sq(vec2(otherCoord - coord) / 1.*float(searchSize)));\n                        \n                        avgPos += coefficient * pos;\n                        avgNorm += coefficient * normalize(normal(pos, ivec2(otherP.xy)));\n                        avgS += coefficient * otherP.xy;\n                        coefficientSum += coefficient;\n\n                        break;\n                }\n            }\n        }\n    }\n    \n    avgPos /= coefficientSum;\n    avgS /= coefficientSum;\n    avgNorm = normalize(avgNorm);\n        \n    \n    vec3 col = avgPos - center;\n    col /= 2. * initialBoundingRadius;\n    \n    col += 0.5;\n    \n    col = normalize(col);\n    \n    //col = vec3(vec2(avgS)/vec2(gridSize), 0);\n\n    col *= ambient + (1. / (1. - ambient)) * (2. * (smoothstep(-0.2, 0.2, dot(avgNorm, forward)) - 0.5) * dot(avgNorm, light) + 1.) / 2.;\n                \n    \n        \n    fragColor = vec4(col, 1.0);  //  + surfaceI(coord)\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\nBuffer A\n\nContains the projection of the surface to screen coordinats, for rendering purposes.\n\nFormat:\nvec4(vec2{s}, ?, {mode: NONE, ACTIVE, UNSETTLED})\n\ns: an ivec2 representing the coordinates in Buffer B containing the 3D point.\nConverted to vec2 using intBitsToFloat in order to be stored in the buffer.\nI diden't use uintBitsToFloat because texelFetch accepts a ivec2 and not a uvec2.\n\nUPDATE: apparently floatBitsToInt(intBitsToFloat(i)) != i for most i so instead I used regular float to int and int to float casting.\n*/\n\n#define BUFFA iChannel0\n#define BUFFB iChannel2\n#define KEYBOARD iChannel1\n\n\n\n\nvec2 toP2(vec3 p, vec3 right, vec3 up)\n{\n    return (p - center)*mat2x3(right, up) * min(iResolution.x, iResolution.y) * 0.5 / BOUNDINGRADIUS + iResolution.xy / 2.;\n}\n# define toP2i(p) ivec2(toP2(p, right, up))\n\nivec2 radialClamp(ivec2 v, float r);\n\nconst int searchSize = 2;\n\nconst float equivalenceThreshold = 0.06;//0.07;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    ivec2 coord = ivec2(fragCoord);\n        \n    vec4 p = texelFetch(BUFFA, coord, 0);\n    uint pMode = Mode(p);\n    \n    int mouseMode = getMouseMode();\n    \n    \n    if(mouseMode == ERASER_MOUSE_MODE)\n    {\n        if(sq(fragCoord - iMouse.xy) < sq(90.) && iMouse.z > 0.0)\n        {\n            p.w = 0.;\n            fragColor = p;\n            return;\n        }\n    }\n    \n    // Coords ivec2(0, 0) and ivec2(1, 0) store the rotation data.\n    if(coord == ivec2(0))  \n    {\n        if(iFrame == 0) p = vec4(timeRotation(0.), vec2(0));\n        else \n        {\n            if(mouseMode == ROTATE_MOUSE_MODE && iMouse.z > 0.0 && iMouse.w <= 0.0)\n            {   \n                vec2 mouseOffset = iMouse.xy - abs(iMouse.zw);\n                p.xy = mouseOffset * PI * 0.5 / iResolution.xy;\n            }\n            \n        }\n        \n    \n        fragColor = p;\n        \n        return;\n    }\n    if(coord == ivec2(1, 0))\n    {\n        if(iFrame == 0) p = vec4(0.);\n        else\n        {            \n            if(iMouse.w > 0.0 && mouseMode == ROTATE_MOUSE_MODE)\n            {\n                p.xy += texelFetch(BUFFA, ivec2(0), 0).xy;\n            }\n            \n            if(ROTATE_KEYPRESS)  // stop and continue the rotation.\n            {\n                if(ROTATE_TOGGLE)\n                {\n                    p.z = iTime;\n                }\n                else\n                {\n                    p.xy += timeRotation(iTime - p.z) - timeRotation(0.);\n\n                }\n            }\n        }\n        \n        \n        fragColor = p;\n        \n        return;\n    }\n    //Coord ivec2(0, 1) stores the zoom data\n    if(coord == ivec2(0, 1))\n    {\n        if(iFrame == 0) p = withMode(vec3(initialBoundingRadius, 0, 0), NONE);\n        else\n        {\n            if(texelFetch(KEYBOARD, ivec2(38 /* UP   */ , 0), 0 ).x > 0.)\n            {\n                p.x -= 0.01;\n            }\n            if(texelFetch(KEYBOARD, ivec2(40 /* DOWN */ , 0), 0 ).x > 0.)\n            {\n                p.x += 0.01;\n            }\n        }\n        \n        fragColor = p;\n        \n        return;\n    }\n    \n    \n    // Axis calculations based on the rotation.\n    vec2 rotation = getRotation();\n        \n    vec2 cisXY = cis(rotation.x);\n    vec2 cisRZ = cis(rotation.y);\n        \n    vec3 right = vec3(-cisXY.y, cisXY.x, 0);\n    vec3 up = vec3(-cisRZ.y * cisXY, cisRZ.x);\n    \n    vec3 forward = cross(right, up);\n    \n    \n    // Wait for the rotation data before placing the initial particle.\n    if(iFrame == 0)\n    {\n        fragColor = vec4(vec3(0), NONE);\n        return;\n    }\n    if(iFrame == 1)  // Place the initial.\n    {\n        vec4 p = vec4(0);\n        \n        const ivec2 initial = gridStart + ivec2(1);\n        if(coord == toP2i(surface(initial)))\n        {\n            p = withMode(p, ACTIVE);\n            p.xy = vec2(initial);\n        }\n        else p = withMode(p, NONE);\n        \n        fragColor = p;\n        return;\n    }\n    \n    // Set all particles to NONE by defult. TODO: if statment may not be necessary.\n    if(pMode == ACTIVE || pMode == UNSETTLED)\n    {\n        p = withMode(p, NONE);\n    }\n    \n\n    // The neighborhood search. \n    ivec2 res = ivec2(iResolution.xy);\n    for(int x = max(0, coord.x - searchSize); x <= min(coord.x + searchSize, res.x - 1); x++)\n    {\n        for(int y = max(0, coord.y - searchSize); y <= min(coord.y + searchSize, res.y - 1); y++)\n        {\n            ivec2 otherCoord = ivec2(x, y);\n            \n            if(float(sqI(otherCoord - coord)) > sq(float(searchSize) + 0.5)) continue;\n            \n            \n            vec4 otherP = texelFetch(BUFFA, otherCoord, 0);\n                        \n            uint otherMode = Mode(otherP);\n            \n            if(otherMode == ACTIVE || otherMode == UNSETTLED)\n            {\n                \n            \n                ivec2 otherP2 = toP2i(portalSurface(otherP.xy).xyz);\n                //ivec2 clampedOtherP2 = clamp(otherP2, otherCoord - searchSize, otherCoord + searchSize);\n                ivec2 clampedOtherP2 = otherCoord + radialClamp(otherP2 - otherCoord, float(searchSize));\n                \n                \n                if(clampedOtherP2 == coord)\n                {\n                    higherPriority(p, withMode(otherP, otherP2 == coord ? ACTIVE : UNSETTLED), forward, equivalenceThreshold);\n                }\n                \n                // The birth of new particles.\n                if(otherMode == ACTIVE)// && otherP2 == otherCoord)\n                {\n                    for(int i = 0; i < 4; i++)\n                    {\n                        ivec2 s = ivec2(otherP.xy);\n                        \n                        s += circle4(i + iFrame);\n                        \n                        vec4 surfaceValue = portalSurfaceSOut(s);//texelFetch(BUFFB, ivec2(s), 0);\n                        \n                        if(!isActualSurfacePoint(Mode(surfaceValue))) continue;  // Surface boundaries\n                        \n                        ivec2 newOtherP2 = toP2i(surfaceValue.xyz);\n                        //ivec2 newClampedOtherP2 = clamp(newOtherP2, otherCoord - searchSize, otherCoord + searchSize);\n                        ivec2 newClampedOtherP2 = otherCoord + radialClamp(newOtherP2 - otherCoord, float(searchSize));\n                       \n                        \n                        if(newClampedOtherP2 == coord)\n                        {\n                            higherPriority(p, withMode(vec4(vec2(s), 0, 0), newOtherP2 == coord ? ACTIVE : UNSETTLED), forward, equivalenceThreshold);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n\n    fragColor = p;\n}\n\nivec2 radialClamp(ivec2 v, float r)\n{\n    vec2 fv = vec2(v);\n    float len = length(fv);\n    if(len > 0.) \n        return ivec2(round( min(len, r) * fv / len ));\n    else\n        return ivec2(0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Posible models:\n#define CATENOID 0\n#define RECTANGLE 1\n#define HEXAGON 2\n\n// Current model:\n#define MODEL CATENOID\n/*\nChange to:\n    #define MODEL RECTANGLE\nOr:\n    #define MODEL HEXAGON\nOr:\n    #define MODEL CATENOID\nCompile and click the \"Reset time\" button.\n*/\n\n\n#define NONE 0U\n#define ACTIVE 1U\n#define UNSETTLED 2U\n#define PORTAL 3U\n#define STATIONARY 4U\n#define MOUSE 5U\n\n#define PI 3.14159265359\n\n#define Mode(p) uint(p.w)\n//#define setMode(p, v) p.w = float(v)\n#define withMode(p, m) vec4(p.xyz, m)\n\n#define sq(v) dot(v, v)\n#define cis(t) vec2(cos(t), sin(t))\n\nint sqI(ivec2 v)\n{ return v.x*v.x + v.y*v.y; }\n\n/// Surface Defenition ///\n#if MODEL == CATENOID\nconst float initialBoundingRadius = 1.;\n#elif MODEL == RECTANGLE\nconst float initialBoundingRadius = 0.7;\n#elif MODEL == HEXAGON\nconst float initialBoundingRadius = 0.6;\n#endif\n\n#define BOUNDINGRADIUS texelFetch(BUFFA, ivec2(0, 1), 0).x\nconst vec3 center = vec3(0);\n\n#if MODEL == CATENOID\nconst ivec2 gridSize = ivec2(30, 10);\n#elif MODEL == RECTANGLE\nconst ivec2 gridSize = ivec2(20);\n#elif MODEL == HEXAGON\nconst ivec2 gridSize = ivec2(20);\n#endif\n\nconst ivec2 gridStart = ivec2(1, 0);\nconst ivec2 gridEnd = gridStart + gridSize;\n\n\n/// Optimization (gradient descent optimizer's (adam) parameters) ///\nconst float learningRate = 0.001; // 0.001\nconst float epsilon = 1e-8; // 1e-8\nconst float beta1 = 0.5;  // 0.9  //  I think that using 0.5 instead of 0.9 prevents the catenoid from collapsing.\nconst float beta2 = 0.999;\n\n#define OPTIMIZATION_TOGGLE (texelFetch(KEYBOARD, ivec2(77 /* m */, 2), 0).x <= 0. && iFrame > 60*3)\n\n\n/// Rotation ///\nvec2 timeRotation(float t)\n{\n    t = 0.2 * t;\n    return vec2(-t, 0.5 * PI * (-0.25*sin(t + PI/2.)));\n}\n\n#define getRotation() _getRotation(texelFetch(BUFFA, ivec2(0), 0), texelFetch(BUFFA, ivec2(1, 0), 0), iTime, ROTATE_TOGGLE)\nvec2 _getRotation(vec4 p0, vec4 p1, float t, bool rotateToggle)\n{\n    return p0.xy + p1.xy + (rotateToggle ? timeRotation(t - p1.z) - timeRotation(0.) : vec2(0)); \n}\n#define ROTATE_TOGGLE (texelFetch(KEYBOARD, ivec2(32 /* SPACE */, 2), 0).x <= 0.)\n#define ROTATE_KEYPRESS (texelFetch(KEYBOARD, ivec2(32 /* SPACE */, 1), 0).x > 0.)\n\n\n/// Mouse mode ///\n#define ROTATE_MOUSE_MODE 0\n#define ERASER_MOUSE_MODE 1\n#define SELECT_MOUSE_MODE 2\n\n#define ERASER_TOGGLE (texelFetch(KEYBOARD, ivec2(68 /* d */, 2), 0).x > 0.)\n#define SELECT_TOGGLE (texelFetch(KEYBOARD, ivec2(83 /* s */, 2), 0).x > 0.)\n#define getMouseMode() _getMouseMode(KEYBOARD)\nint _getMouseMode(sampler2D KEYBOARD)\n{\n    if(SELECT_TOGGLE) return SELECT_MOUSE_MODE;\n    if(ERASER_TOGGLE) return ERASER_MOUSE_MODE;\n    return ROTATE_MOUSE_MODE;\n}\n\n\n/// Surface ///\n#define surface(s) texelFetch(BUFFB, ivec2(s), 0).xyz\n#define portalSurface(s) _portalSurface(ivec2(s), BUFFB)\n#define portalSurfaceSOut(s) _portalSurfaceSOut(s, s, BUFFB)\nvec4 _portalSurfaceSOut(ivec2 s, out ivec2 sOut, sampler2D BUFFB)\n{\n    vec4 surfaceData = texelFetch(BUFFB, s, 0);\n    \n    if(Mode(surfaceData) == PORTAL)\n    {\n        sOut = ivec2(surfaceData.xy);\n        return texelFetch(BUFFB, sOut, 0);\n    }\n    \n    return surfaceData;\n}\nvec4 _portalSurface(ivec2 s, sampler2D BUFFB)\n{\n    ivec2 sOut;\n    return _portalSurfaceSOut(s, sOut, BUFFB);\n}\nbool isActualSurfacePoint(uint m)\n{\n    return m == ACTIVE || m == STATIONARY || m == MOUSE;\n}\n\n\n#define higherPriority(p, newP, forward, equivalenceThreshold) _higherPriority(p, newP, forward, equivalenceThreshold, BUFFB)\nint _higherPriority(inout vec4 p, vec4 newP, vec3 forward, float equivalenceThreshold, sampler2D BUFFB)\n// returned value: \n// 1: newP's priority is higher and p changed.\n// 0: equivalent priority       and p did not changed.\n//-1: newP's priority is lower  and p did not changed.\n{\n    uint newM = Mode(newP);\n    \n    if(newM == NONE) return -1;\n    \n    uint m = Mode(p);\n    \n    if(m == NONE)\n    {\n        p = newP; \n        return 1;\n    }\n    //not accurate but also noncritical.\n    \n    \n    float forwardDiff = dot(portalSurface(p.xy).xyz, forward) - dot(portalSurface(newP.xy).xyz, forward);\n    \n    if(abs(forwardDiff) < equivalenceThreshold * initialBoundingRadius)\n    {\n        return 0;  // too close\n    }\n    \n    if(forwardDiff < 0. /* p is behined pNew  &&  */) // if the diff is small the conflict is probably between neer by particles so they should take turns\n    {\n        return -1;\n    }\n    else\n    {\n        p = newP;\n        return 1;\n    }\n}\n\nivec2 circle4(int i)\n{\n    i = (i%4 + 4) % 4;\n    return ivec2((1 - i) * ((i+1) % 2), (2 - i) * (i % 2));\n}\n\n#define gradient(p, coord) _gradient(p, coord, BUFFB) \nvec3 _gradient(vec3 p, ivec2 coord, sampler2D BUFFB)\n{\n    vec3 delta = vec3(0);\n    int missing = -1;\n    vec4 last = portalSurface(coord + circle4(-1));\n    for(int i = 0; i < 4 && isActualSurfacePoint(Mode(last)); i++)\n    {\n        vec4 pointData = portalSurface(coord + circle4(i));\n\n\n        if(isActualSurfacePoint(Mode(pointData)))\n        {\n            // Minimize area.\n            \n            // area = sq(0.5 * cross(b - a, p - a))\n            // area = 0.25 * sq(cross(b - a, p - a))\n            // d(area)/dp = 0.25 * 2. * cross(b - a, p - a) * d(cross(b - a, p - a))/dp\n            // d(cross(b - a, p - a))/dp = cross(b - a, d(p - a)/dp)\n            // d(cross(b - a, p - a))/dp = cross(b - a, I)\n            // d(cross(b - a, p - a))/dp = crossMatForm(b - a)\n            // d(area)/dp = 0.5 * cross(b - a, p - a) * crossMatForm(b - a)\n            // d(area)/dp = 0.5 * cross(b - a, cross(b - a, po - a))\n            // d(area)/dp = 0.5 * ( dot(b - a, p - a) * (b - a) - sq(b - a) * (p - a) )\n                    \n            vec3 a = last.xyz;\n            vec3 b = pointData.xyz;\n\n            vec3 pa = (p.xyz - a);\n            vec3 ba = (b - a);\n\n\n            delta -= 0.25 * 0.5*(dot(ba, pa) * ba - sq(ba) * pa);\n            //delta -= 0.25 * 0.5 * cross(ba, normalize(cross(ba, pa)));\n        }\n        else missing = i;\n\n        last = pointData;\n    }\n\n\n    // Boundery points\n    if(!isActualSurfacePoint(Mode(last)))\n    {\n        // Minimize length instead\n        delta = vec3(0);\n        for(int i = missing - 1; i <= missing + 1; i += 2)\n        {\n            // To have the same \"units\" as the area gradient, instead of minimizing:\n            // l = sq(p - o)\n            // I use:\n            // l = (sq(p - o))^2\n            // Which is the same as minimaizeing the area squared.\n            \n            // l = (sq(p - o))^2\n            // dl/dp = 2.*sq(p - o) * d(sq(p - o))/dp\n            // dl/dp = 2.*sq(p - o) * 2.*(p - o)\n            // The second part of the multiplication is the gradient i would have without \"conserving the units\",\n            // so it will probably work with or without scaling by 2.*sq(p - o).\n            \n            vec3 po = p - portalSurface(coord + circle4(i)).xyz;\n        \n            delta += 0.5 * (2.*po * 2.*sq(po));\n        }\n        //delta *= .2;\n        \n        /*float len = length(delta);\n        if(len > 0.)\n        {\n            delta /= len;\n            len = max(len, 0.001);\n            delta *= len;\n        }\n        else delta = vec3(0, 0, 0.001);*/\n        \n        //vec3 badDirection = normalize(portalSurface(coord + circle4(missing + 2)).xyz - p.xyz);\n        //delta = delta - abs(dot(badDirection, delta))*badDirection;\n\n        /*if(isActualSurfacePoint(Mode(portalSurface(coord + circle4(missing + 1)))) && isActualSurfacePoint(Mode(portalSurface(coord + circle4(missing - 1)))) && isActualSurfacePoint(Mode(portalSurface(coord + circle4(missing + 2)))))\n        {\n\n            vec3 right = normalize(portalSurface(coord + circle4(missing + 1)).xyz - portalSurface(coord + circle4(missing - 1)).xyz);\n            vec3 forward = normalize(portalSurface(coord + circle4(missing + 2)).xyz - p.xyz);\n            vec3 up = cross(right, forward);\n\n            delta = right * dot(right, delta) + up * dot(up, delta);\n        }\n        else delta = vec3(0);*/\n    }\n    \n    return delta;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\nBuffer B\n\nRepresents the surface.\nThis buffer replaces the surface(vec2 s) function in the Surface Plotter.\n\nFormat:\nvec4(vec3{3D position}, {mode: NONE, ACTIVE, STATIONARY, PORTAL})\n\nA PORTAL is an inactive cell, witch represents another remote ACTIVE cell.\nFormat:\nvec4(vec2{s}, ?, PORTAL)\n*/\n\n#define BUFFB iChannel0\n#define BUFFC iChannel1\n#define BUFFD iChannel2\n#define KEYBOARD iChannel3\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n\n    vec4 p = texelFetch(BUFFB, coord, 0);\n\n    /// Set the surface ///\n    // Including: stationary parts, connections (portals), and initial point positions.\n    if(iFrame == 0)\n    {\n        p = withMode(p, NONE);\n        \n        #if MODEL == CATENOID\n        \n        if(all(greaterThanEqual(coord, gridStart)) && all(lessThan(coord, gridEnd)))\n        {\n            p = withMode(p, ACTIVE);\n            if(coord.y == gridStart.y || coord.y == gridEnd.y - 1) p = withMode(p, STATIONARY);\n            \n            vec2 prm = (fragCoord - vec2(gridStart)) / vec2(gridSize);  // [0, 1)\n            p.xyz = vec3(0.75*vec2(cos(2. * PI * prm.x), sin(2. * PI * prm.x)), prm.y - 0.5);\n        }\n        if(coord.x == 0)\n        {\n            p = withMode(p, PORTAL);\n            \n            p.xy = vec2(gridSize.x, coord.y);\n        }\n        if(coord.x == gridSize.x + 1)\n        {\n            p = withMode(p, PORTAL);\n            \n            p.xy = vec2(1, coord.y);\n        }\n        \n        #elif MODEL == RECTANGLE\n        \n        if(all(greaterThanEqual(coord, gridStart)) && all(lessThan(coord, gridEnd)))\n        {\n            p = withMode(p, ACTIVE);\n            if(coord == gridStart || coord == ivec2(gridStart.x, gridEnd.y-1) || coord == ivec2(gridEnd.x-1, gridStart.y) || coord == gridEnd-1) p = withMode(p, STATIONARY);\n            \n            vec2 prm = (fragCoord - vec2(gridStart)) / vec2(gridSize);  // [0, 1)\n            p.xyz = vec3(prm - 0.5, 0);\n            \n            if(coord == gridStart || coord == gridEnd-1) p.z = 0.25;\n            if(coord == ivec2(gridStart.x, gridEnd.y-1) || coord == ivec2(gridEnd.x-1, gridStart.y)) p.z = -0.25;\n        }\n        \n        #elif MODEL == HEXAGON\n        \n        if(all(greaterThanEqual(coord, gridStart)) && all(lessThan(coord, gridEnd)))\n        {\n            p = withMode(p, ACTIVE);\n            \n            vec2 prm = (fragCoord - vec2(gridStart)) / vec2(gridSize);  // [0, 1)\n            p.xyz = vec3(prm - 0.5, 0);\n            \n            for(int i = 0; i < 6; i++)\n            {\n                if(coord == gridStart + ivec2(0.5 * vec2(gridSize-1) * (clamp(sqrt(2.) * cis(2.*PI * (float(i) / 6.)), vec2(-1), vec2(1)) + 1.)))\n                {\n                    p = withMode(p, STATIONARY);\n                    p.z = float((i%2) * 2 - 1) * 0.25;\n                }\n            }\n        }\n        \n        #endif\n        \n        fragColor = p;\n        \n        return;\n    }\n    /*if(iFrame == 1) // Wait for Buffer C.\n    {\n        fragColor = p;\n        \n        return;\n    }*/\n    \n    \n    /// SELECT Mouse Mode ///\n    \n    if(Mode(p) == MOUSE)\n    {\n        if(iMouse.z < 0.)\n        {\n            p = withMode(p, ACTIVE);\n        }\n        else\n        {\n            vec4 mouseClick = texelFetch(BUFFC, ivec2(iResolution.xy) - 1, 0);\n            if(Mode(mouseClick) == MOUSE)\n            {\n                const float alpha = 0.995;\n                p.xyz = alpha * p.xyz + (1. - alpha) * mouseClick.xyz;\n            }\n        }\n        \n        // TODO: maybe not to return?\n        \n        fragColor = p;\n        \n        return;\n    }\n    else if(getMouseMode() == SELECT_MOUSE_MODE && iFrame >= 2)  // no s\n    {        \n        vec4 mouseClick = texelFetch(BUFFC, ivec2(iResolution.xy) - 1, 0);\n        if(Mode(mouseClick) == ACTIVE && coord == ivec2(mouseClick.xy))\n        {\n            p = withMode(p, MOUSE);\n            \n            fragColor = p;\n        \n            return;\n        }\n    }\n    \n    \n    if(Mode(p) == ACTIVE && OPTIMIZATION_TOGGLE)\n    {\n        /// The Optimization (gradient descent) ///\n        \n        \n        /*\n        //RMSprop\n        const float learningRate = 0.01; // 0.001\n        const float epsilon = 1e-8; // 1e-8\n        \n        const float gamma = 0.9;\n        \n        vec3 g = gradient(p.xyz, coord);\n        \n        vec3 movingExpAvg = gamma * texelFetch(BUFFC, coord, 0).xyz  + (1. - gamma) * (g*g);\n        p.xyz -= learningRate * g / sqrt(movingExpAvg + epsilon);\n        */\n        \n        \n        /*\n        //Momentum\n        p.xyz -= texelFetch(BUFFC, coord, 0).xyz;\n        */\n        \n        \n        /*\n        //Adadelta\n        const float gamma = 0.9;\n        const float epsilon = 1e-8; // 1e-8\n        \n        vec3 g = gradient(p.xyz, coord);\n        \n        vec2 expAvgs = texelFetch(BUFFC, coord, 0).xy;\n        float gradSqExpAvg = gamma * expAvgs.x  + (1. - gamma) * sq(g);\n        \n        p.xyz -= g * sqrt(expAvgs.y + epsilon) / sqrt(gradSqExpAvg + epsilon);\n        */\n        \n        \n        //Adam\n        vec3 mHat = texelFetch(BUFFC, coord, 0).xyz / float(1. - pow(beta1, float(iFrame)));\n        vec3 vHat = texelFetch(BUFFD, coord, 0).xyz / float(1. - pow(beta2, float(iFrame)));\n\n        p.xyz -= learningRate * ( mHat / (sqrt(vHat) + epsilon) );\n    }\n    \n    \n    fragColor = p;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/*\nBuffer C\n\nContaining additional optimization data for Buffer B.\n*/\n\n#define BUFFB iChannel0\n#define BUFFC iChannel1\n#define KEYBOARD iChannel2\n#define BUFFA iChannel3\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    vec4 p = texelFetch(BUFFC, coord, 0);\n    \n    vec4 pointData = texelFetch(BUFFB, coord, 0);\n    \n    if(iFrame == 0)\n    {\n        p = vec4(0);\n        return;\n    }\n    \n    \n    \n    // Coord ivec2(iResolution.xy) - 1 stores the mouse click\n    if(coord == ivec2(iResolution.xy) - 1)\n    {\n        vec2 rotation = getRotation();\n\n        vec2 cisXY = cis(rotation.x);\n        vec2 cisRZ = cis(rotation.y);\n\n        vec3 right = vec3(-cisXY.y, cisXY.x, 0);\n        vec3 up = vec3(-cisRZ.y * cisXY, cisRZ.x);\n\n        vec3 forward = cross(right, up);\n    \n    \n        if(iMouse.w > 0.)\n        {\n            vec4 maxPriority = vec4(vec3(0), NONE);\n            int sqDistToMax = 0;\n\n            ivec2 res = ivec2(iResolution.xy);\n            const int searchSize = 8;\n            ivec2 mouse = ivec2(iMouse.xy);\n            for(int x = max(0, mouse.x - searchSize); x <= min(mouse.x + searchSize, res.x - 1); x++)\n            {\n                for(int y = max(0, mouse.y - searchSize); y <= min(mouse.y + searchSize, res.y - 1); y++)\n                {\n                    ivec2 otherCoord = ivec2(x, y);\n                    vec4 otherP = texelFetch(BUFFA, otherCoord, 0);\n\n                    if(Mode(otherP) == ACTIVE)\n                    {\n                        switch(higherPriority(maxPriority, otherP, forward, 0.07))\n                        {\n                            case 0:\n                                int dist = sqI(otherCoord - mouse);\n                                if(dist < sqDistToMax)\n                                {\n                                    maxPriority = otherP;\n                                    sqDistToMax = dist;\n                                }\n                                \n                                break;\n                                \n                            case 1:\n                                sqDistToMax = sqI(otherCoord - mouse);\n                                \n                                break;\n                        }\n                        \n                    }\n                }\n            }\n\n            fragColor = maxPriority;\n\n            return;\n        }\n        else\n        {\n            vec2 rightUpCoord = 2. * BOUNDINGRADIUS * (iMouse.xy - iResolution.xy / 2.) / min(iResolution.x, iResolution.y);\n            vec3 position = rightUpCoord.x * right + rightUpCoord.y * up + center;\n            //(p - center)*mat2x3(right, up) * min(iResolution.x, iResolution.y) * 0.5 / BOUNDINGRADIUS + iResolution.xy / 2.;\n            \n            fragColor = withMode(position, MOUSE);\n        \n            return;\n        }\n    }\n    \n    \n    if(Mode(pointData) == ACTIVE && OPTIMIZATION_TOGGLE)\n    {\n        /*\n        //RMSprop\n        const float gamma = 0.9;\n        \n        vec3 g = gradient(pointData.xyz, coord);\n        p.xyz = gamma * p.xyz + (1. - gamma) * (g*g);\n        */\n        \n        \n        \n        /*\n        //Momentum\n        const float gamma = 0.9;\n        const float learningRate = 1.; // 0.001\n        \n        vec3 g = gradient(pointData.xyz, coord);\n        p.xyz = gamma * p.xyz + learningRate * g;\n        */\n        \n        \n        /*\n        //Adadelta\n        const float gamma = 0.9;\n        const float epsilon = 1e-8; // 1e-8\n        \n        vec3 g = gradient(pointData.xyz, coord);\n        \n        // grad sq exp avg\n        p.x = gamma * p.x + (1. - gamma) * sq(g);\n        \n        vec3 delta = g * sqrt(p.y + epsilon) / sqrt(p.x + epsilon);\n        p.y = gamma * p.y + (1. - gamma) * sq(delta);\n        */\n        \n        \n        \n        //Adam\n        vec3 g = gradient(pointData.xyz, coord);\n        \n        // m\n        p.xyz = beta1 * p.xyz + (1. - beta1) * g;\n        \n        \n        \n        \n        fragColor = p;\n        return;\n    }\n    \n    \n    \n    \n    fragColor = p;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"/*\nBuffer D\n\nContaining additional optimization data for Buffer B.\n*/\n\n#define BUFFB iChannel0\n#define BUFFD iChannel1\n#define KEYBOARD iChannel2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    vec4 p = texelFetch(BUFFD, coord, 0);\n    \n    vec4 pointData = texelFetch(BUFFB, coord, 0);\n    \n    if(iFrame == 0)\n    {\n        p = vec4(0);\n        return;\n    }\n    \n    if(Mode(pointData) == ACTIVE && OPTIMIZATION_TOGGLE)\n    {\n        //Adam\n        vec3 g = gradient(pointData.xyz, coord);\n        \n        // v\n        p.xyz = beta2 * p.xyz + (1. - beta2) * (g*g);\n        \n        \n        \n        fragColor = p;\n        return;\n    }\n    \n    \n    \n    \n    fragColor = p;\n}","name":"Buffer D","description":"","type":"buffer"}]}