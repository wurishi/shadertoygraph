{"ver":"0.1","info":{"id":"fsSfDW","date":"1646738030","viewed":734,"name":"Solid angle sampling line/volume","username":"matte","description":"A experiment for finding more optimal sampling locations on a line light when using equiangular distance sampling in a volume. Still some problems though, please read the commented code!\nLeft: Importance sampled\nRight: Random area sampling","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["volume","line","lighting","light","sampling","linear","render","importance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright Â© 2022 Matt Ebb\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#define PIXEL_SAMPLES 8\n#define INTERSECT_SPHERE 0\n\n/*\nEquiangular sampling (Kulla, Sony Picures Imageworks)\nis used in volume rendering to importance sample the \n1/r^2 'falloff' term between a single point (light) \nand a line segment (view ray), in order to sample more \ndensely where the light is closest to the ray and \ncontributing more energy.\n\nThis is a form of solid angle sampling, relating the \nsolid angle of the line as seen by the point, since\n'inverse square falloff' is really just another way of\ntalking about change in solid angle with distance.\n\nEquiangular sampling extends reasonably well to non-point \nlight shapes, however it raises the problem of finding an\noptimal location to sample on the light. For line lights\nin a volume, we have a similar issue to sampling distances,\nwe want to find the locations on the light that contribute \nmost light the ray as a whole (since the distances are only\nsampled after an initial sample location on the light \nsource has been found).\n\nIn thinking of relating the solid angle of a line to a ray\nI remembered this trick for finding segment-segment distance:\nhttps://zalo.github.io/blog/closest-point-between-segments/\n- just collapse one of the dimensions and solve it one at \na time.\n\nThe below experiment does something similar.\n- First project the line light into the plane defined \nby the view ray to collapse it to 2D\n- Then use equiangular sampling to sample the line light's \nsolid angle from a single point (the ray origin).\n\nThe idea being:\n- A light parallel to the view ray will become very short\nafter projection, and sample somewhat evenly, while...\n- A light perpendicular to the view ray will concentrate samples\nmore densely closest to the point representing the collapsed\nray, and more sparsely in areas further from the collapsed ray.\n\nAs you can see in the viewer, this works pretty well when \ndealing with a long/infinite ray but if the ray is clipped to\nto a shorter finite segment (eg. after intersecting some geometry)\nit reveals some artifacts. I think it's related to the pdf \ncalculation but I'm not quite mathematically inclined enough to\nfigure it out.\n\nYou can test this by defining INTERSECT_SPHERE to 1 \nat the top of this source, to insert an occluding sphere \nin front of the light.\n\nI think this technique may have potential, so I'd be delighted\nto hear any thoughts from people smarter than I!\n\n*/\n\nvec3 s_curve(vec3 x)\n{\n    const float a = 2.51f;\n    const float b = 0.03f;\n    const float c = 2.43f;\n    const float d = 0.59f;\n    const float e = 0.14f;\n    x = max(x, 0.0);\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e),0.0,1.0);\n}\n\n\nfloat hash( ivec2 c )\n{\n    int x = 0x3504f333*c.x*c.x + c.y;\n    int y = 0xf1bbcdcb*c.y*c.y + c.x;\n    \n    return float(x*y)*(2.0/8589934592.0)+0.5;\n\n}\n\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec3 center, in float radius )\n{\n\tvec3 oc = ro - center;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - radius*radius;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\n// equiangular sampling\n// from Volume Rendering Techniques at Imageworks\n// https://fpsunflower.github.io/ckulla/data/volume-rendering-techniques.pdf\n// requires a max distance to bound the distance samples\nfloat sample_distance_equiangular(vec3 ro, vec3 rd, vec3 lightP, float u, float maxd, out float pdf) {\n\t// closest pt on ray to light\n    // - project r on ray\n\tfloat delta = dot((lightP - ro), rd);\n\t\n\t// distance from light to ray\n\tfloat D = length(ro + rd*delta - lightP);\n\n\t// angles to a and b\n\tfloat theta_a = atan(-delta, D);\n\tfloat theta_b = atan(maxd - delta, D);\n\t\n\t// take sample\n\tfloat t = D * tan(mix(theta_a, theta_b, u));\n\n\t// t is relative to closest point on ray, negative in 'a' triangle\n\tfloat dist = delta + t;\n\n\tpdf = D / ((theta_b - theta_a) * (D*D + t*t));\n\n\treturn dist;\n}\n\nvec3 sample_line_light_area(vec3 la, vec3 lb, float u, out float pdf) {\n\tpdf = 1.0;\n\treturn mix(la, lb, u);\n}\n\nvec3 sample_line_light_ray_solidangle(vec3 la, vec3 lb, vec3 ro, vec3 rd, float u, out float pdf) {\n\t\n\t// it's not possible to calculate solid angle against a ray \n\t// since there are many possible origins of the spherical coordinate system along the ray,\n\t// but maybe we can approximate it in aggregate by flattening our line light against the \n\t// plane defined by the ray\n\n\t// light endpoints in world space\n\tvec3 L = lb - la;\n\n\t// project line endpoints against plane defined by ray\n\tvec3 pa = la - rd*dot(la-ro, rd);\n\tvec3 pb = lb - rd*dot(lb-ro, rd);\n\tfloat proj_len = length(pb-pa);\n\n\t// from here on we deal with coordinates in projected space\n\tvec3 pL = normalize(pb - pa);\n\n    // closest point to ray origin along line segment\n    float delta = dot(pL, ro-pa);\n\n    // get distance from ray origin to to line\n    float D = length(pa + pL*delta - ro);\n        \n    // get angle of endpoints\n    float theta_a = atan(-delta, D);\n    float theta_b = atan(proj_len - delta, D);\n\n    // take sample\n    float angle = mix(theta_a, theta_b, u);\n    float t = D*tan(angle);\n    \n   \n    // sample in world space, remap back to our original line\n    vec3 sampleP = la + L*((delta+t)/proj_len);\n    float f = (delta+t)/proj_len;\n    f = max(min(f, 1.0), 0.0);\n    \n    sampleP = mix(la, lb, f);\n    \n    pdf = D/((theta_b - theta_a)*(D*D + t*t));\n    pdf *= proj_len;\n    \n    return sampleP;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // camera matrix\n    vec3 ro = vec3( 0.0, 0.4, 2.0 );\n    vec3 ta = vec3( 0.0, 0.5, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    // pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n\n    // create view ray\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n    \n    // light endpoints\n    vec3 la = vec3(-1.5, 0.25 + 0.35*sin(iTime + 3.141/2.0), 0.0);\n    vec3 lb = vec3(1.5, 0.25 + 0.35*sin(iTime), 0.0);\n    vec3 lc = 1.0 + 0.5*cos(iTime*0.5+vec3(0,1,2));\n    \n    const float density = 0.5;\n    \n    vec3 col = vec3(0.0);\n    int samples = PIXEL_SAMPLES;\n    \n    for (int p=1; p<=samples; p++) {\n        \n        float u0 = hash(ivec2(fragCoord) * ivec2(p) );\n        float u1 = hash(ivec2(fragCoord) * ivec2(p*123));\n        \n        const float maxdist = 10.0;\n#if INTERSECT_SPHERE        \n        vec3 sP = vec3(0.0,0.7, 1.0);\n        float r = 0.4;\n        float t = sphIntersect(ro, rd, sP, r);\n        t = t<0.0 ? maxdist : t;\n#else\n        float t = maxdist;\n#endif\n        float light_pdf, dist_pdf;\n        vec3 lightP;\n        \n        if (fragCoord.x > iResolution.x*0.5) {\n            // sample position on light randomly\n            lightP = sample_line_light_area(la, lb, u0, light_pdf);\n        } else {\n            // sample position on light according to its 'solid angle' from view ray\n            lightP = sample_line_light_ray_solidangle(la, lb, ro, rd, u0, light_pdf);\n        }\n            \n        // use the position on light to sample a distance using equiangular sampling\n        \n        float d = sample_distance_equiangular(ro, rd, lightP, u1, t, dist_pdf);\n        \n        vec3 P = ro + rd*d;\n        vec3 L = lightP - P;\n        float geoterm = 1.0/dot(L, L);\n        \n        // transmission from camera to P to light\n\t\tfloat tr = exp(-density*(d+length(L)));\n        \n        vec3 rad = lc * tr * geoterm / (light_pdf*dist_pdf);\n        col += rad;\n    }\n    col /= float(samples);\n\n    col *= 1.0;\n\n    col = s_curve(col);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}