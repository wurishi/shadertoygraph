{"ver":"0.1","info":{"id":"3t3GRs","date":"1578027894","viewed":270,"name":"raymarch critter","username":"markbehm","description":"Learning about raymarching. Most of the code taken from others and others' ideas.\nWIP\n[ arrow keys, home key, hold x y or z and move mouse ] \n\n\n","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","interactive","sdf","creature"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// by Martijn Steinrucken aka BigWings/CountFrolic - 2018\n\n\n\n\nconst vec2 _apos \t\t\t= vec2( 0.0, 0.0 ); // xyz pos a size\nconst vec2 _boogerNoise \t= vec2( 10.0, 0.0 ); // x noisetoggle y noise_amt\nconst vec2 _cameraPos\t\t= vec2( 20.0, 0.0 ); // cam loc\nconst vec2 _cameraRot\t\t= vec2( 30.0, 0.0 ); // cam rot\nvec4 boogerNoise;\nvec4 apos;\nvec4 cameraPos;\nvec4 cameraLoc;\n\n\nvec4 LoadValue( vec2 loc )\n    // vec4 theVal = LoadValue( _apos );\n{\n    //return floor( texture( iChannel1, ( tx + 0.5 ) / iChannelResolution[ 1 ].xy ) );\n    return texture(iChannel1,loc);\n}\n\n/*\n// https://www.shadertoy.com/user/Hamneggs --------------------------------------------------------\nvoid StoreValue( in vec4 val, in vec2 loc, in vec2 fragCoord)\n{\n    vec4 buffer = texture(iChannel1, loc);\n    vec2 offset = abs(loc-floor(fragCoord));\n    buffer = mix( val, buffer, step(.01,max(offset.x,offset.y)) );\n}\n\n*/\n\n//--------------------------------------------------------------------------------------------\n\nfloat f(float t) { return 6.0*t*t*t*t*t-15.0*t*t*t*t+10.0*t*t*t; }\nvec2 noise(vec2 p){\n\treturn (vec2(\n\t\tfract(sin(dot(p.xy, vec2(50159.91193,49681.51239))) * 73943.1699),\n\t\tfract(sin(dot(p.xy, vec2(90821.40973,2287.62201))) * 557.96557)\n\t)-0.5)*2.0;\n}\n\n//--------------------------------------------------------------------------------------------\n//\nfloat rand3d(vec3 co,float seed)\n{\n\treturn sin(fract((sin(dot(co ,vec3(30.233 * seed,7.233 * seed,20.2352 * seed)))) * 815150.5453)*321.321);\n}\n//----------------------------------------------------------------------------------------------------------------\nfloat Noise3d(vec3 pos,float Size,float seed)\n{\t    \n\tfloat GridX = floor(pos.x * Size);\n\tfloat NextGridX = floor( (pos.x  +(1./Size)) * Size);\n\tfloat GridY = floor(pos.y * Size);\n\tfloat NextGridY = floor( (pos.y  +(1./Size)) * Size);\n\tfloat GridZ = floor(pos.z * Size);\n\tfloat NextGridZ = floor( (pos.z  +(1./Size)) * Size);\t\n\tvec3 PosGrid = mod((pos),1./Size) * Size ;\n\t\n    PosGrid = smoothstep(0.,1.,PosGrid);\n    \n\t//FrontFace\n\tfloat CornerUpLeftFrontRandom = rand3d(vec3(GridX,GridY,GridZ),1.);\n\tfloat CornerUpRightFrontRandom = rand3d(vec3(NextGridX,GridY,GridZ),1.);\n\tfloat CornerDownLeftFrontRandom = rand3d(vec3(GridX,NextGridY,GridZ),1.);\n\tfloat CornerDownRightFrontRandom = rand3d(vec3(NextGridX,NextGridY,GridZ),1.);\n\tfloat MixUp_Front = mix(CornerUpLeftFrontRandom,CornerUpRightFrontRandom,PosGrid.x);\n\tfloat MixDown_Front = mix(CornerDownLeftFrontRandom,CornerDownRightFrontRandom,PosGrid.x);\t\t\n\t//BackFace\n\tfloat CornerUpLeftBackRandom = rand3d(vec3(GridX,GridY,NextGridZ),1.);\n\tfloat CornerUpRightBackRandom = rand3d(vec3(NextGridX,GridY,NextGridZ),1.);\n\tfloat CornerDownLeftBackRandom = rand3d(vec3(GridX,NextGridY,NextGridZ),1.);\n\tfloat CornerDownRightBackRandom = rand3d(vec3(NextGridX,NextGridY,NextGridZ),1.);\n\tfloat MixUp_Back = mix(CornerUpLeftBackRandom,CornerUpRightBackRandom,PosGrid.x);\n\tfloat MixDown_Back = mix(CornerDownLeftBackRandom,CornerDownRightBackRandom,PosGrid.x);\t\n\t//FrontFace\n\tfloat MixFrontFace = mix(MixUp_Front,MixDown_Front,PosGrid.y);\n\t//BackFace\n\tfloat MixBackFace = mix(MixUp_Back,MixDown_Back,PosGrid.y);\t\n\t//MixCube\n\tfloat MixCube = mix(MixFrontFace,MixBackFace,PosGrid.z);\t\n\treturn MixCube;\n}\n//----------------------------------------------------------------------------------------------------------------\nfloat perlinNoise3d(vec3 pos,float Size,float seed,float Iteration)\n{\n    float r =0.;\n\tfor(float i = 0.;i < Iteration;i++)\n    {\n        float freq = pow(2.,i);\n        r += Noise3d(pos,Size*freq,seed )*(1./freq);\n    }\n\treturn r;\n}\n//-----------------------------------------------------------------------------------------------------\n\nfloat perlin(vec2 p)\n{\n\tint X = int(floor(p.x));\n\tint Y = int(floor(p.y));\n\t\n\tp.x -= float(X);\n\tp.y -= float(Y);\n\t\n\tvec2 g00 = noise(vec2(X  , Y  ));\n\tvec2 g01 = noise(vec2(X  , Y+1));\n\tvec2 g10 = noise(vec2(X+1, Y  ));\n\tvec2 g11 = noise(vec2(X+1, Y+1));\n\t\n\tfloat q00 = dot(g00, vec2(p.x    , p.y    ));\n\tfloat q01 = dot(g01, vec2(p.x    , p.y-1.0));\n\tfloat q10 = dot(g10, vec2(p.x-1.0, p.y    ));\n\tfloat q11 = dot(g11, vec2(p.x-1.0, p.y-1.0));\n\n\tp.x = f(p.x);\n\tp.y = f(p.y);\n\t\n\tfloat qx0 = mix(q00, q10, p.x);\n\tfloat qx1 = mix(q01, q11, p.x);\n\tfloat qxy = mix(qx0, qx1, p.y);\n\n\treturn qxy;\n}\n//--------------------------------------------------------------------------\n\nfloat fbm(vec2 p)\n{\n    float f = 1.0;\n    \n    f += perlin(p/16.)*16.;\n    f += perlin(p/8.)*8.;\n    f += perlin(p/4.)*4.;\n    f += perlin(p/2.)*2.;\n    f += perlin(p/1.)*1.;\n    \n    return f/(1.+2.+4.+8.+16.);\n}\n//--------------------------------------------------------------------------\n\nfloat smin( float a, float b, float k ){\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 smin( vec2 a, vec2 b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b.x-a.x)/k, 0.0, 1.0 );\n\treturn vec2( mix( b.x, a.x, h ) - k*h*(1.0-h), mix( b.y, a.y, h ) );\n}\n\nfloat sminCubic(float a, float b, float k)\n{\n    \n    float h = max(k-abs(a-b), 0.0);\n    return min(a, b) - h*h*h/(6.0*k*k);\n}\n \nvec2 blend(vec2 d1, vec2 d2,float k)\n{\n\n    float d = sminCubic(d1.x, d2.x, k);\n    float m = mix(d1.y, d2.y, clamp(d1.x-d,0.0,1.0));\n    return vec2(d, m);\n}\n\n\n\n\n//--------------------------------------------------------------------------\n\nfloat smax( float a, float b, float k ){\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\nvec2 smax( vec2 a, vec2 b, float k ){\n\tfloat h = clamp( 0.5 + 0.5*(b.x-a.x)/k, 0.0, 1.0 );\n\treturn vec2(mix( a.x, b.x, h ) + k*h*(1.0-h),mix(a.y,b.y,h));\n}\n\n//--------------------------------------------------------------------------\n\nfloat sphere(vec3 p,float r){\n    float d = length(p)-r;\n\treturn d;\n    }\n//--------------------------------------------------------------------------\n\nfloat box( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n\t}\n//--------------------------------------------------------------------------\n\nfloat smBox( vec3 p, vec3 b, float r ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n//--------------------------------------------------------------------------\n\nfloat segment( vec3 a, vec3 b, vec3 p,float r ){\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn  length( pa - ba*h  );\n}\n//--------------------------------------------------------------------------\n\nvec2 sdSegment( vec3 a, vec3 b, vec3 p )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n//--------------------------------------------------------------------------\n\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\n//--------------------------------------------------------------------------\n\nvec3 getClosest( vec2 b0, vec2 b1, vec2 b2 ) \n{\n\t\n  float a =     det(b0,b2);\n  float b = 2.0*det(b1,b0);\n  float d = 2.0*det(b2,b1);\n  float f = b*d - a*a;\n  vec2  d21 = b2-b1;\n  vec2  d10 = b1-b0;\n  vec2  d20 = b2-b0;\n  vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n  vec2  pp = -f*gf/dot(gf,gf);\n  vec2  d0p = b0-pp;\n  float ap = det(d0p,d20);\n  float bp = 2.0*det(d10,d0p);\n  float t = clamp( (ap+bp)/(2.0*a+b+d), 0.0 ,1.0 );\n  return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\n//--------------------------------------------------------------------------\n\nvec2 sdBezier( vec3 a, vec3 b, vec3 c, vec3 p )\n{\n\tvec3 w = normalize( cross( c-b, a-b ) );\n\tvec3 u = normalize( c-b );\n\tvec3 v =          ( cross( w, u ) );\n\n\tvec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n\tvec2 b2 = vec2( 0.0 );\n\tvec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n\tvec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n\tvec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy );\n\n\treturn vec2( sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z), cp.z );\n}\n\n\n//mat3x3 rotationAlign( vec3  d, vec3 z ){\n //   vec3  v = cross( z, d );\n //   float c = dot( z, d );\n  //  float k = 1.0f/(1.0f+c);\n  //  return mat3x3( v.x*v.x*k + c, v.y*v.x*k - v.z, v.z*v.x*k + v.y, v.x*v.y*k + v.z, v.y*v.y*k + c, v.z*v.y*k - v.x,v.x*v.z*k - v.y, v.y*v.z*k + v.x, v.z*v.z*k + c);\n//}\n//----------------------------------------------------------------------------------------------------------------\n// http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nvec3 rotation(vec3 point, vec3 axis, float angle){\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    mat4 rot= mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,0.0,0.0,1.0);\n    return (rot*vec4(point,1.)).xyz;\n}\n\nmat2 rot(float a){\n    float s = sin(a);\n    float c  = cos(a);\n    return mat2(c,-s,s,c);\n}\n\n\n\n//----------------------------------------------------------------------------------------------------------------\n//----------------------------------------------------------------------------------------------------------------\n//----------------------------------------------------------------------------------------------------------------\n//----------------------------------------------------------------------------------------------------------------\nvec2 GetDist(vec3 p)\n\t{\n   \n    float d = 0.0;\n    float noise,shape;\n    float x,y,z;\n    vec3 axis;\n    vec2 res = vec2( 1e10, 0.0 );\n        \n    p = rotation(p,vec3(0,1,0),-1.1);   // rot whole fig\n\tp.x=abs(p.x);\n        \n    float pnoise_1 =  perlinNoise3d(vec3(p.x,p.x-sin(p.y),p.z),2.0,7.0,6.);\n    float pnoise_2 = perlinNoise3d(p,.8,9.,8.);\n    // first center chest sphere\n    vec3 mp = p-vec3(0,1,6); \t\n\tres = vec2( sphere(mp,.7), MAT_SKIN);\n    // clav\n    vec3 t = vec3(1,.6,6.5);\n    mp = rotation(p-t,vec3(0,0,1),-.2);\n    res = blend( res, vec2( smBox(mp,vec3(.7,.4,.7),.3) + .13* pnoise_1, MAT_SKIN), .6 );\n        \n        \n    // shoulder\n\n\tres = smin( \tres, \n                \tvec2( sphere( p-vec3(2.0,0.6,6.0),0.7) + .02*pnoise_1, MAT_SKIN ), \n                \t.6);\n    \n        \n    //d = smin(d,sph2,.6);\n    // traps\n    res = smin( \tres, \n                \tvec2( sphere(p-vec3(.76,1.55,6.11).xyz,.3) , MAT_SKIN ), \n                \t1.2);\n  \n    // neck\n    vec2 h = sdSegment( vec3(0,0.6,6), vec3(0,3,5.5), p );\n\tfloat d2 = h.x - 0.7;\n    res = smin( \tres, \n                \tvec2(d2, MAT_SKIN ), \n                \t1.4 );\n         \n    \n        // sternoc\n    h = sdSegment( vec3(.3,0.67,5.4), vec3(.7,3,5.2), p );\n\td2 = h.x - 0.1;\n\tres = smin( \tres, \n                \tvec2(d2, MAT_SKIN ), \n                \t0.3 );\n         \n        \n   \t \n         \n    // stern notch\n    d = smax( res.x,  -sphere(p-vec3(0,0.49,5.3),.2)   ,.9 );    \n        \n      \n        \n    // head\n  \n    res = vec2(d,MAT_SKIN);\n    res = smin(res,vec2( box(p-vec3(0,3.,5.),vec3(.7,.25,.65))- .3 * perlinNoise3d(vec3(p.x,p.y,p.y+p.z),0.8,8.,7.), MAT_SKIN ),\t0.9 );\n        \n   \n\t// snout\n    h = sdSegment( vec3(x+.1 , 3. , 5.0), vec3(x-.02 , 2.6 , 4.), p );\n\tfloat d1 = h.x - 0.6 + 0.25*h.y;\n    res = smin(res,vec2( d1 , MAT_SKIN_WARM),\t0.5 );\n    \n        \n     \n    // eye stalks\n\n    float any = sin(.1*iTime)*.1*smoothstep(0.,.2,cos(iTime));\n    float anz = .03*smoothstep(0.,.2,sin(cos(.0001*iTime)*iTime));   \n    y = 4.+ any; \n    z = 5.+ anz; \n    x = 1.3;\n    \n    h = sdSegment( vec3(x,y,5.2), vec3(x-.2,y-.4,5.2), p );\n\td1 = h.x - 0.2 + 0.25*h.y;\n    res = smin(res,vec2( d1 , MAT_SKIN_COOL ),\t0.8);    \n        \n   \n        \n        // bulbs\n        d1 = sphere(p-vec3(x+.2,y+.1,z+.2),.45) + .03*(perlin(p.zx *16.) );\n        res = smin(res,vec2( d1 , MAT_SKIN_COOL ),\t0.8); \n  \n           \n        // carve\n        res = smax(res,   vec2(-sphere(p-vec3(x+.2,y+.05,z-.3),.49)\t\t,MAT_SKIN)\t ,.1 ); // soft\n        \n        \n\n       //nostrils\n     res = smin(res, vec2(\tsphere(p-vec3(.37,2.819,3.915),.4)+.1* pnoise_2, MAT_SKIN_WARM ) ,\t.6);\n     res = smax(res, vec2(-sphere(p-vec3(.42,2.819,3.815),.2)+.03* pnoise_2, MAT_SKIN_SHAD ) ,.2);\n       \n              \n     //eeers\n      {\n        vec3 earXfm = p;\n        \n     // anim curve\n     float er1,er2,er3;\n        \n     \t// tie to eye ud\n        //x = iTime-.02;\n      \n      \ter1 =  2. * ( sin(.1*iTime)*.1*smoothstep(0.,.2,cos(iTime-.06)) );         \n        er2 =  2. * (sin(.1*iTime)*.1*smoothstep(0.,.2,cos(iTime-.2)) );\n        er3 =  0.6 * (sin(.1*iTime)*.1*smoothstep(0.,.2,cos(iTime-.4)) );\n\n         earXfm.y-=er1;\n         vec3 p1 = vec3(1.34,2.70,5.67); // pivot point\n         earXfm -= p1; \n         earXfm = rotation(earXfm, vec3 (0., 0, 1.0) ,er2); // main rotation\n         earXfm += p1;\n\n\n         res = smin(res,\tvec2( sphere(earXfm-vec3(1.74,2.70,5.67),.28),MAT_SKIN_WARM )\t\t,.3); // base\n         res = smin(res,\tvec2( sphere(earXfm-vec3(1.9,2.37,5.68),.14),MAT_SKIN_WARM )\t\t,.2); // mid\n\n         res = smax(res,\tvec2( -sphere(earXfm-vec3(1.74,2.70,5.56),.26),MAT_SKIN_WARM )\t\t,.1); // cut\n         res = smax(res,\tvec2( -sphere(earXfm-vec3(1.9,2.37,5.35),.26),MAT_SKIN_WARM )\t,.2); // cut\n         res = smin(res,\tvec2( sphere(earXfm-vec3(2.04,2.23+er3,5.79),.01),MAT_SKIN_WARM )\t\t,.3);   // tip\n\n        } \n        \n     // orbs\n                \n \n            res = smin(res,\tvec2(sphere(p-vec3(x+.2,y+.1,z-.1),.46),\tMAT_EYESC), 0.0);  \n            // iris\n            res = smax(res,  vec2( -sphere(p-vec3(x+.42,y+.05,z-.4),.2),\tMAT_EYEIRIS) ,.05);\n             // pupils   \n            res = smin(res,   vec2( sphere(p-vec3(x+.42,y+.05,z-.4),.1),\tMAT_EYEP) ,.05 );\n            \n             \n                   \n      \n         \n        \n    // horns\n\n     vec3 p1 = vec3(1.23,3.12,7.89);\n\t vec3 p2 = vec3(1.91,3.5,8.39);\n    //vec3 p2 = vec3(1.17, 3.16, 7.24);\n     res = smin(res,  vec2(sphere(p-vec3(1.2,3.009,6.095),.5) - .2*pnoise_2 ,MAT_SKIN) ,.3);\n     h = sdSegment( vec3(1.2,3.009,6.095), p1, p )\t+.03*(perlin(p.xz *16.));  \n     d1 = h.x - 0.42 + 0.2*h.y;\n     res = smin (res, vec2(d1,MAT_SKIN_COOL), .3);\n     \n     axis = p2-p1;\n    float boxLen = .5;\n    //\n    vec3 nudge = axis*vec3(0.,0.,-boxLen*4.);\n    mp = rotation(p-p1,axis,-.7); // main rotation\n    mp += nudge; // bump to edge of box\n\n    float scale  = mix(1.,8.,smoothstep(-1.,2.,mp.z)); // setup taper\n    mp.xy *= scale; // taper\n    mp.xy *= rot(mp.z*2.); // twist\n    mp.zy *= rot(smoothstep(0.,2., 1.2*-mp.z)); // curve\n    float box = smBox(mp,vec3(.2,.2,boxLen*2.),.1)/scale ;    \n    res = smin( res, vec2( box , MAT_SKIN_COOL), .4 );\n\n    // floor plane\n    res = smin(res,vec2( p.y-.2,MAT_FLOOR),.01);\n    \n      \n        \n        \n    // user controlled 'boogers'\n    apos = LoadValue( _apos );\n        \n    noise = boogerNoise.x;\n    shape = sphere(p-apos.xyz,apos.a)+ .1*pnoise_2;\n    res = smin( res,  vec2(shape,MAT_SKIN) , .3 );\n        \n\treturn res; \n    \n}\n\n//----------------------------------------------------------------------------------------------------------------\n// https://iquilezles.org/articles/rmshadows\n\n\n//----------------------------------------------------------------------------------------------------------------\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    //float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tvec2 h = GetDist( ro + rd*t );\n        float a = 8.0;\n        a = 1.0;\n        float s = clamp(a*h.x/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h.x\n                   , 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\n//----------------------------------------------------------------------------------------------------------------\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\n\tfloat t=0.0; // min dist\n    vec2 res = vec2(0,0);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd * t;\n        //vec2 dS = GetDist(p);\n        vec2 res = GetDist(p);\n        if (res.x < (0.0001*t) ) { return vec2(t,res.y); }\n        t+=res.x;\n        \n        //t += dS.x;\n        \n        //if(t>MAX_DIST || dS.x<SURF_DIST) break;\n        \n        // res.x = t; // dist\n        //res.y = dS.y; // material\n    }\n    \n    return vec2(-1,-1);\n}\n//----------------------------------------------------------------------------------------------------------------\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    \n    for( int i=0; i<4; i++ )\n    {\n        float hr = 0.01 + 0.32*float(i)/4.2;\n        vec3 aopos =  nor * hr + pos;\n        vec2 dd = GetDist( aopos );\n        occ += -(dd.x-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n    //return clamp( 1.0 - 2.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n//----------------------------------------------------------------------------------------------------------------\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*GetDist(pos+0.0005*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n//----------------------------------------------------------------------------------------------------------------\nvec3 lighting(vec3 p, vec3 rd) {\n    \n    //vec3 lightPos = vec3(1, 5, -3);\n    //lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    //vec3 l = normalize(lightPos-p);\n    vec3 n = calcNormal(p);\n    \n    \n    vec3 col = vec3(0.0);\n\n    float fre = clamp( 1.0+dot(n,rd), 0.0, 1.0 );\n    \n    float sfre = 0.04 + 0.96*pow( fre, 5.0 );\n    \n    float matRough = .2;\n    vec3 matColor = vec3(.3,.31,.32);\n    float pn = exp2( 10.0*(1.0-matRough) );\n    float ao = calcAO(p,n);\n    \n // sun light\n    {\n        vec3 sunColor = vec3(5.0,4.0,3.0)*1.0;\n        vec3 sun = normalize(vec3(-0.8,0.55,-0.3));\n        float dif = clamp( dot(sun,n), 0.0, 1.0 );\n        //float sha = 0.0; if( dif>0.0 ) sha = calcShadow( pos, sun );\n        //float sha = .5;\n        float sha = calcSoftshadow( p, sun, 0.02, 2.5);\n    \n        vec3 hal = normalize( sun - rd );\n        float spe = pow( clamp(dot(hal,n), 0.0, 1.0 ), pn );\n        \n        col += matColor * sunColor * dif * vec3(sha,0.5*sha*(1.0+sha),sha*sha);\n        col += (1.-matRough)*sunColor * spe * pn * dif * sha * sfre / 4.0;\n    }\n\n    // sky light\n    {\n        vec3 skyColor = vec3(0.3,0.5,0.7)*2.0;\n        float dif = 0.1 + 0.3*n.y;\n        col += matColor * skyColor * dif * ao;\n        col += skyColor * (1.0-matRough) * smoothstep( 0.0,0.2,reflect(rd,n).y ) * sfre * 2.5 * ao;\n    }\n    vec3 matGamma = vec3(0.75,0.75,0.9);\n    col += fre*matColor*ao;\n    col = pow( max(col,0.0), matGamma );\n    \n    return col;\n    \n    \n    \n    //float dif = clamp(dot(n, l), 0., .5);\n    \n    //float d = RayMarch(p+n*SURF_DIST*2., l);\n    //dif *= .5 +calcSoftshadow( p, lightPos, 0.02, 2.5);\n    \n    //return vec3(dif,dif,dif);\n}\n\nfloat DigitBin(const in int x){\n    if(x==0) return 480599.0; if(x==1) return 139810.0; if(x==2) return 476951.0; if(x==3) return 476999.0;\tif(x==4) return 350020.0; \n    if(x==5) return 464711.0; if(x==6) return 464727.0; if(x==7) return 476228.0; if(x==8) return 481111.0; if(x==9) return 481095.0; \n    return 0.0;}\nfloat PrintValue(vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces){\n    vec2 vStringCharCoords = (fragCoord.xy - vPixelCoords) / vFontSize;\n    if ((vStringCharCoords.y < 0.0) || (vStringCharCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCharCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n            if((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;} \n        else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;} \n            else {\n\t\t\t\tif(fDigitIndex < 0.0) fDigitIndex += 1.0;\n\t\t\t\tfloat fDigitValue = (abs(fValue / (pow(10.0, fDigitIndex))));\n                float kFix = 0.0001;\n                fCharBin = DigitBin(int(floor(mod(kFix+fDigitValue, 10.0))));} } }\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCharCoords.x) * 4.0) + (floor(vStringCharCoords.y * 5.0) * 4.0))), 2.0));}\nvec3 WriteValueToScreenAtPos(vec2 fragCoord, float vValue, vec2 vPixelCoord, vec3 vColour, vec2 vFontSize, float vDigits, float vDecimalPlaces, vec3 vColor){\n    float num = PrintValue(fragCoord, vPixelCoord, vFontSize, vValue, vDigits, vDecimalPlaces);\n    return mix( vColour, vColor, num);}\n\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    // camera\t\n   \n\n    vec3 col = vec3(0);\n    float an = 10.0 + 0.7*sin(16.0+0.2*iTime);\n\t\n    \n    vec3 ro;\n    ro = vec3(-2.5, 2., -5.);\n    //ro + 1.1 * vec3(cos(an),.8+.3*(sin(an)),.5*sin(an));\n    if (iMouse.z > 0.){\n    \t//{ ro.yz *= rot((.1*-m.y) * 3.14+1.);\n   \t\t ro.xz *= rot((.1*-m.x) * 6.2831);\n        }\n    ro +=  1.1 * vec3(cos(an),.8+.3*(sin(an)),.5*sin(an));\n   // vec3 rd = R(uv, ro, vec3(0,1,0), 1.);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n    vec2 d = RayMarch(ro, rd);\n    \n    \n    vec3 p = ro + rd * d.x;\n    \n    \n    if (d.x==-1.0) // no hits\n    \t{\n        col = vec3(0.3,0.36,0.60)-(rd.y*0.6);\n    \t}\n    else\n    \t{\n    \tcol = lighting(p,rd);\n            \n        // mat color blend\n        vec3 skin = vec3(.81,.81,.8);\n        vec3 skin_w = vec3 (1.0,.35,.1);\n        vec3 skin_c = vec3 (.5,.6,.8);\n\n                \n        if (d.y >= MAT_FLOOR){col *=  vec3(0.2,0.2,0.22) ;}\n        else if (d.y >= MAT_EYEP ){col  = mix(vec3(.02,0.,0.), col, 0.1)  ;}    \n        else if (d.y >= MAT_EYEIRIS){col = mix(vec3(0.,.5,.8), col, 0.7)  ;}\n        else if (d.y >= MAT_EYESC){col = mix(vec3(1.,1.,1.), col, 0.7) ;}\n        else if (d.y >= MAT_SKIN_COOL) {col *= mix(skin_c, skin, MAT_SKIN_COOL-d.y) ;}\n        else if (d.y >= MAT_SKIN) {col *= mix(skin_c, skin, MAT_SKIN_COOL-d.y) ;}\n        else if (d.y >= MAT_SKIN_WARM) {col *= mix(skin_w, skin, d.y) ;}    \n            else if (d.y >= MAT_SKIN_SHAD) {col *= mix(vec3(0.2,0.01,0.01),skin_w , smoothstep(MAT_SKIN_SHAD, MAT_SKIN_WARM, d.y) )  ;}    \n        \n        \n        \n        \n            \n            \n        }\n   \n    \n  \t{\n    vec4 boogerNoise = LoadValue(_boogerNoise);\n     \n    vec4 apos =LoadValue(_apos); \n\tvec3 black = vec3(0.5);\n    vec2 size = vec2(6.0, 12.0);\n    col = WriteValueToScreenAtPos(fragCoord, apos.x, vec2(20., 2.),col , size, 3., 2., black);\n    col = WriteValueToScreenAtPos(fragCoord, apos.y, vec2(120., 2.), col, size, 3., 2., black);\n    col = WriteValueToScreenAtPos(fragCoord, apos.z, vec2(220., 2.), col , size, 3., 2., black);\n    col = WriteValueToScreenAtPos(fragCoord, apos.a, vec2(310., 2.), col , size, 3., 2., black);\n    }\n\t/*     \n\t for(int i=0; i<16; i++)\n\t{\n\t\t//RGB distortion\n\t\tcol.r += texture(iChannel0,uv+offset*float(i)+offset2).r;\n\t\tcol.g += texture(iChannel0,uv+offset*float(i)).g;\n\t\tcol.b += texture(iChannel0,uv+offset*float(i)-offset2).b;\n\t}\n\t*/\n\t// gamma\n    col = pow( col, vec3(0.547) );\n    \n    // vignetting\t\n    uv = fragCoord/iResolution.xy;\n\tcol *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n\n    \n    //col = clamp(col,0.0,1.0);\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define keyDown(ascii)    ( texelFetch(iChannel0,ivec2(ascii,1),0).x > 0.)\n#define BUFF_RES iChannelResolution[1].xy\n\nconst vec2 _apos \t\t\t= vec2( 0.0, 0.0 ); // xyz pos a size\nconst vec2 _boogerNoise \t= vec2( 10.0, 0.0 ); // x noisetoggle y noise_amt\nconst vec2 _cameraPos\t\t= vec2( 20.0, 0.0 ); // cam loc\nconst vec2 _cameraRot\t\t= vec2( 30.0, 0.0 ); // cam rot\nvec4 boogerNoise;\nvec4 apos;\nvec4 cameraPos;\nvec4 cameraLoc;\n\n\nvec4 LoadValue( vec2 loc )\n    // vec4 theVal = LoadValue( _apos );\n{\n    //return floor( texture( iChannel1, ( loc + 0.5 ) / iChannelResolution[ 1 ].xy ) );\n    return texture(iChannel1,loc);\n}\n\n\n// https://www.shadertoy.com/user/Hamneggs --------------------------------------------------------\nvoid StoreValue( in vec4 val, in vec2 loc, inout vec4 fragColor, in vec2 fragCoord)\n{\n   \n    fragCoord = floor( fragCoord );\n    fragColor = ( fragCoord.x == loc.x && fragCoord.y == loc.y ) ? val : fragColor;\n}\n\n\n\n\n\n// mostly user input buffer----------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int X_KEY = 88; \n    int Y_KEY = 89;   \n    int Z_KEY = 90; \n    int U_KEY = 38;\n    int D_KEY = 40;\n    int L_KEY = 37;\n    int R_KEY = 39;\n    int Pg_UP_KEY = 33;\n    int Pg_DN_KEY = 34;\n    int Ctrl_KEY = 17;\n    int Shift_KEY = 16;\n    int Alt_KEY=18;\n\tint HOME_KEY=36;\n    int N_KEY = 32;\n    int S_KEY = 83;\n    \n   \n    // first frame: reset values\n    vec4 apos;\n    if (iFrame < 3){\n        apos = vec4(1.,2.,2.,.3);\n        StoreValue(apos,_apos,fragColor,fragCoord);\n    \t}\n    // otherwise load values\n    else\n    \t{\n           apos = LoadValue( _apos ); \n           boogerNoise = LoadValue(_boogerNoise);\n    \t}\n    \n\n      vec2 uv = fragCoord/iResolution.xy;\n     \n    float inc = .01;\n    \n    // retreive value\n     //vec4 apos = texture(iChannel1,vec2(0,0));\n    \n     \n   \t \n    float zDown =0.;\n    float xDown =0.;\n    float yDown =0.;\n    \n    \n    // keyboard\n     float ctrlDown = texelFetch( iChannel0, ivec2(Ctrl_KEY,0), 0 ).x;\n      zDown = texelFetch( iChannel0, ivec2(Z_KEY,0), 0 ).x ;\n      xDown = texelFetch( iChannel0, ivec2(X_KEY,0), 0 ).x ;\n      yDown = texelFetch( iChannel0, ivec2(Y_KEY,0), 0 ).x ;\n     float moveRight = texelFetch( iChannel0, ivec2(L_KEY,0), 0 ).x;\n     float moveLeft =  texelFetch( iChannel0, ivec2(R_KEY,0), 0 ).x;\n     apos.x += inc*(moveRight-moveLeft);\n     float moveFwd = texelFetch( iChannel0, ivec2(U_KEY,0), 0 ).x;\n     float moveBack =  texelFetch( iChannel0, ivec2(D_KEY,0), 0 ).x;\n     apos.z += inc*(moveFwd-moveBack);\n     float moveUp = texelFetch( iChannel0, ivec2(Pg_UP_KEY,0), 0 ).x;\n     float moveDn =  texelFetch( iChannel0, ivec2(Pg_DN_KEY,0), 0 ).x;\n     //float larger =  texelFetch( iChannel0, ivec2(Pg_DN_KEY,0), 0 ).x;\n     //float smaller =  texelFetch( iChannel0, ivec2(Pg_DN_KEY,0), 0 ).x;\n     apos.y += inc*(moveUp-moveDn);\n     \n      float deltaX = (iMouse.z-iMouse.x);\n      float deltaY = (iMouse.w-iMouse.y);\n      //m.x =  iMouse.x/iResolution.x\n     if (iMouse.z > 0.0 && ctrlDown > 0.0)\n      \t{\n        apos.a += (inc/50.)*(-deltaX);\n        if (apos.a < .01) apos.a = .01;\n        if (apos.a > 1.8) apos.a = 1.8;\n        }\n    /*\n      if (iMouse.z > 0.0 &&  zDown > 0.0)\n      \t{\n        apos.z += (inc/50.)*(deltaX+deltaY);\n        //if (apos.a < .01) apos.a = .01;\n        //if (apos.a > 1.8) apos.a = 1.8;\n        }\n     if (iMouse.z > 0.0 &&  xDown > 0.0)\n      \t{\n        apos.x += (inc/50.)*(deltaX+deltaY);\n        //if (apos.a < .01) apos.a = .01;\n        //if (apos.a > 1.8) apos.a = 1.8;\n        }\n    if (iMouse.z > 0.0 &&  yDown > 0.0)\n      \t{\n        apos.y += (inc/50.)*-(deltaX+deltaY);\n        //if (apos.a < .01) apos.a = .01;\n        //if (apos.a > 1.8) apos.a = 1.8;\n        }\n    */\n    \n     // reset boogers\n     if(texelFetch( iChannel0, ivec2(HOME_KEY,0), 0 ).x > 0.) apos = vec4(1.,2.,2.,.3);\n    \n     // booger noise toggle\n     if(texelFetch( iChannel0, ivec2(N_KEY,0), 0 ).x > 0.) \n     \t{\n          \t{\n            boogerNoise.x = 1.;\n          \t}\n                \n        }\n        \n      // save values\n     StoreValue(apos,_apos,fragColor,fragCoord);\n     StoreValue(boogerNoise, _boogerNoise,fragColor, fragCoord );\n     \n     // clear to 0 on first frame\n    fragColor = iFrame < 1 ? vec4( 0.0 ) : fragColor;\n\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define MAX_STEPS 256\n#define MAX_DIST 1000.\n\n#define SURF_DIST .1\n\n#define MAT_SKIN_SHAD 0.1\n#define MAT_SKIN_WARM 0.3\n#define MAT_SKIN 1.0\n#define MAT_SKIN_COOL 2.0\n\n#define MAT_EYESC 3.0\n#define MAT_EYEIRIS 4.0\n#define MAT_EYEP 5.0\n#define MAT_HORN1 6.0\n\n#define MAT_FLOOR 7.0\n","name":"Common","description":"","type":"common"}]}