{"ver":"0.1","info":{"id":"4X33RM","date":"1716222875","viewed":124,"name":"Horror Game Monster Test","username":"TwentySeven","description":"RUN. DO NOT TOUCH ANYTHING. RUN.\nUpdate: Collisions","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["volumetric","depth"],"hasliked":0,"parentid":"l3cGRr","parentname":"Horror Game Test"},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//buffer C+D has actual rendering stuff, this buffer is just for dithering\n\n\nvec3 loadValue3( in vec2 re ){\n    return texture( iChannel3, (0.5+re) / iChannelResolution[3].xy, -100.0 ).xyz;\n}\nvec2 loadValue2( in vec2 re ){\n    return texture( iChannel3, (0.5+re) / iChannelResolution[3].xy, -100.0 ).xy;\n}\n\n\nvoid mainImage( out vec4 C, in vec2 F ){\n//monster code\nvec3 monster=loadValue3(vec2(10,0));\nvec3 cpos= (loadValue3(vec2(0,0)).xyz);\nbool gameover;\n\nif(distance(cpos,monster)<=2.){\ngameover=true;}\n//checks distance to monster\nfloat dis=smoothstep(3.,10.,distance(cpos,monster));\n\n//distorts image based on distance\nfloat dep=mix(-0.,4.,dis);\nF=((F+(mix(1.,0.,dis)*(hash(vec4(F,0.,iTime)).xy))));\nvec4 a=texture(iChannel0,F/iChannelResolution[0].xy);\nfloat b=(texture(iChannel2,(F)/iChannelResolution[2].xy).x);\nvec4 c=(texture(iChannel1,(F)/iChannelResolution[1].xy));\nvec4 j=c.w>a.w?a:c;\nvec4 post1 = vec4(floor(j*dep)/dep);\nvec4 post2 = vec4(floor((j+(1./dep))*dep)/dep);\nbvec4 grad=greaterThan((j-post1)*dep,vec4(b));\nvec4 color=mix(post1,post2,grad);\nfloat fdep1=sat(j.w/16.);\nfloat fdep2=sat(j.w/32.);\nvec4 fog=mix(vec4(1),mix(vec4(.3,.1,.1,0.),vec4(0),fdep2),fdep1);\nC=color*fog;\n\nif(gameover){C=vec4(0,0,0,1);}\n\n\n}\n//void mainImage(out vec4 C,in vec2 F){C=texture(iChannel0,F/iResolution.xy);}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 clickStore\t= vec2(4.,  0.);\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\n\nfloat loadValue1( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 ).x;\n}\n\nvoid storeValue1( in vec2 re, float va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? vec4(va, .0, .0, .0) : fragColor;\n}\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n\n\tfragColour = vec4(0);\n    float click = 0.0;\n    float oldClick = loadValue1(clickStore);\n    if (iFrame == 0) oldClick = 0.0;\n        \n    if (iMouse.z > 0.0)\n   \t{\n      if (oldClick == .0)\n        click = 1.0;\n    }\n  \n\tstoreValue1(clickStore, click,  fragColour, fragCoord);\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Flying camera code...\n// by David Hoskins\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nfloat t=0.2;\n\n\n\nconst float KEY_W\t\t= 87.5/256.0;\nconst float KEY_A\t\t= 65.5/256.0;\nconst float KEY_S\t\t= 83.5/256.0;\nconst float KEY_D\t\t= 68.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\nconst float KEY_SPACE\t= 32.5/256.0;\nconst float KEY_SHIFT\t= 16.5/256.0;\n\n\nvec2 clickStoreA = vec2(4.0,  0.0);\nvec2 camStore = vec2(0.0,  0.0);\nvec2 rotationStore\t= vec2(1.,  0.);\nvec2 monsterStore=vec2(10,0);\nvec2 matrostore1= vec2(7,0);\nvec2 matrostore2= vec2(8,0);\nvec2 matrostore3= vec2(9,0);\nvec2 mouseStore = vec2(2.,  0.);\nvec2 startStore\t\t= vec2(3.,  0.);\nvec2 timeStore = vec2(6.0,  0.0);\n\n\nbool isKeyPressed(float key)\n{\n\treturn texture( iChannel2, vec2(key, 0.25) ).x > .0;\n}\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nvec4 loadValue4( in vec2 re )\n{\n    return texture( iChannel1, (0.5+re) / iChannelResolution[1].xy, -100.0 );\n}\nvec3 loadValue3( in vec2 re )\n{\n    return texture( iChannel1, (0.5+re) / iChannelResolution[1].xy, -100.0 ).xyz;\n}\nvec2 loadValue2( in vec2 re )\n{\n    return texture( iChannel1, (0.5+re) / iChannelResolution[1].xy, -100.0 ).xy;\n}\nfloat loadValue1( in vec2 re )\n{\n    return texture( iChannel1, (0.5+re) / iChannelResolution[0].xy, -100.0 ).x;\n}\nfloat loadValueA1( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 ).x;\n}\n\nvoid storeValue4( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? va : fragColor;\n}\nvoid storeValue3( in vec2 re, in vec3 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? vec4(va, 0.0) : fragColor;\n}\n\nvoid storeValue2( in vec2 re, in vec2 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? vec4(va, .0, .0) : fragColor;\n}\nvoid storeValue1( in vec2 re, in float va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? vec4(va, .0, .0, .0) : fragColor;\n}\nvec2 rot2D(inout vec2 p, float a)\n{\n    return cos(a)*p - sin(a) * vec2(p.y, -p.x);\n}\n\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n   \tfragColour = vec4(0);\n    \n    \n\tvec2 tempStart \t= loadValue2(startStore);\n\tfloat click \t= loadValueA1(clickStoreA);\n    float time \t\t= loadValue1(timeStore);\n    vec3 monster;\n    vec3 camPos;\n    vec2 rot;\n    vec3 matro1;\n    vec3 matro2;\n    vec3 matro3;\n\n    if (iFrame == 0)\n    {\n        monster=vec3(.5,.5,-10);\n        camPos = vec3(.5);\n        rot = vec2(.0, 0.);\n        matro1=vec3(1,0,0);\n        matro2=vec3(0,1,0);\n        matro3=vec3(0,0,1);\n    }else\n    {\n        monster=loadValue3(monsterStore);\n        camPos = loadValue3(camStore);\n        rot \t\t= loadValue2(rotationStore);\n        matro1=loadValue3(matrostore1);\n        matro2=loadValue3(matrostore2);\n        matro3=loadValue3(matrostore3);\n    }\n\n\n    vec4 mouse = iMouse /iResolution.xyxy;\n    \n    if (click > 0.0)\n    {\n    \ttempStart = mouse.xy;// First clicked\n    }\n    if (mouse.z > 0.0)\n    \trot += mouse.xy - tempStart;\n        rot/=2.;\n\n    \n\tstoreValue2(startStore, tempStart,  fragColour, fragCoord);\n\tstoreValue2(rotationStore, rot,  fragColour, fragCoord);\n    \n    rot*= TAU;\n\n    mat3 M=mat3(matro1,matro2,matro3);\n    mat3 mY = RotationMatrix(vec3(1,0,0), rot.y);\n    mat3 mX = RotationMatrix(vec3(0,-1,0),rot.x);\n    mat3 MOP=mY*mX*M;\n  \n    mat3 MAJ=(MOP);\n        M=MOP;\n    matro1=M[0];\n    matro2=M[1];\n    matro3=M[2];\n    storeValue3(matrostore1,M[0],  fragColour, fragCoord);\n    storeValue3(matrostore2,M[1],  fragColour, fragCoord);\n    storeValue3(matrostore3,M[2],  fragColour, fragCoord);\n\n\t\n    time = iTime - time;\n    float speed = time*2.;\n   vec3 damPos=camPos,eamPos=camPos;\n\n    if (isKeyPressed(KEY_W) || isKeyPressed(KEY_UP)){\n\t\tdamPos += (vec3(0,0,-1)*MAJ)* speed;}\n    if (isKeyPressed(KEY_S) || isKeyPressed(KEY_DOWN)){\n\t\tdamPos += (vec3(0,0, 1)*MAJ)* speed;}\n  \tif (isKeyPressed(KEY_D) || isKeyPressed(KEY_RIGHT)){\n\t\tdamPos += (vec3( 1,0,0)*MAJ)* speed;}\n\tif (isKeyPressed(KEY_A) || isKeyPressed(KEY_LEFT)){\n\t\tdamPos += (vec3(-1,0,0)*MAJ)* speed;}\n\nvec3[2] sw=vec3[2](eamPos,damPos);\nvec3[6]c1=vec3[6](vec3(t,0,0),vec3(0,t,0),vec3(0,0,t),vec3(-t,0,0),vec3(0,-t,0),vec3(0,0,-t));\nbool[6]no=bool[6](\nvoxel_color(floor(damPos-vec3( t,0,0))).w>.5,\nvoxel_color(floor(damPos-vec3(0, t,0))).w>.5,\nvoxel_color(floor(damPos-vec3(0,0, t))).w>.5,\nvoxel_color(floor(damPos-vec3(-t,0,0))).w>.5,\nvoxel_color(floor(damPos-vec3(0,-t,0))).w>.5,\nvoxel_color(floor(damPos-vec3(0,0,-t))).w>.5);\nint\nxst =(no[0]&&sign(camPos.x-damPos.x)>0.)?0:1,\nyst =(no[1]&&sign(camPos.y-damPos.y)>0.)?0:1,\nzst =(no[2]&&sign(camPos.z-damPos.z)>0.)?0:1,\nxstn=(no[3]&&sign(camPos.x-damPos.x)<0.)?0:1,\nystn=(no[4]&&sign(camPos.y-damPos.y)<0.)?0:1,\nzstn=(no[5]&&sign(camPos.z-damPos.z)<0.)?0:1;\nvoxel_color(floor(damPos-c1[1])).w>.5;\ncamPos=vec3(\nsw[xst&xstn].x,\n//+(no[0]||no[3]?((no[3]?-1.:1.)*0.01):0.),\nsw[yst&ystn].y,\n//+(no[1]||no[4]?((no[4]?-1.:1.)*0.01):0.),\nsw[zst&zstn].z\n//+(no[2]||no[5]?((no[5]?-1.:1.)*0.01):0.)\n);\n\n    storeValue3(camStore, camPos,  fragColour, fragCoord);\n    storeValue1(timeStore, iTime,  fragColour, fragCoord);\n\n\n    monster=mix(monster,camPos,.005);\n    if(distance(camPos,monster)<=2.) monster=camPos;\n    storeValue3(monsterStore, monster,  fragColour, fragCoord);\n            \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define TAU 6.28318530718\n#define PI 3.14159265359\n#define loop(v,m,n) for(int v=m;v<n;v++)\n#define sat(v) min(1.,max(0.,v))\nvec4 voxel_color(vec3 xyz){\nxyz=abs(xyz-.5)-10.;\nint x=int(xyz.x),y=int(xyz.y),z=int(xyz.z);\nfloat X=xyz.x,Y=xyz.y,Z=xyz.z;\nint j=((x+y)&(y+z)&(z+x));\nvec3 c=(vec3(X,Y,Z)/2.)+1.;\nreturn j>0?vec4(1):vec4(0);\n}\n\n\nstruct Ray{\nvec3 ro;\nvec3 rd;\n};\nstruct Render{\nvec4 color;\nfloat dist;\nvec3 pos;\nvec3 nor;\nvec3 voxspace;\nvec3 oVos;\nvec3 oDir;\n};\n\nvec2 boxIntersection( in vec3 ro, in vec3 rd, in vec3 rad) {\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    \n   // oN = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    return vec2( tN, tF );\n}\nvec3 hash(vec4 p)\n{\n\tuvec4 q = uvec4(ivec4(p)) * uvec4(1597334673U, 3812015801U, 2798796415U, 1979697957U);\n\tq = (q.x ^ q.y ^ q.z ^ q.w)*uvec4(1597334673U, 3812015801U, 2798796415U, 1979697957U);\n\treturn vec3(q) * 2.328306437080797e-10;\n}\n\nfloat compare(float value, float comp, float range){\nreturn (value<(comp+range)&&value>(comp-range)?1.:0.);\n}\nmat3 RotationMatrix(vec3 axis, float angle){\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\nfloat maxcomp( in vec4 v )\n{\n    return max( max(v.x,v.y), max(v.z,v.w) );\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n\nconst int STEPS =64;\n\nconst float EPSY = 0.001;\n\n\nconst vec3 lig = normalize( vec3(-0.4,0.3,0.7) );\n\nRender raycast(Ray cam,vec2 uv){\nvec4 J=texture(iChannel1,uv);\nvec3 ro=cam.ro;\nro=mix(ro,ro+J.xyz,smoothstep(3.,0.,distance(ro,J.xyz)));\n\nvec3 rd=cam.rd;\n\n\tvec3 pos = floor(ro);\n\tvec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tfloat res = -1.0;\n\tvec3 mm = vec3(0.0);\n\tfor( int i=0; i<STEPS; i++ ) \n\t{\n    \n\t\tif( voxel_color(pos).w>0.5 ) { res=1.0; break; }\n\t\tmm = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n\n\tvec3 nor = -mm*rs;\n\tvec3 vos = pos;\n\t\n    // intersect the cube\t\n\tvec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n\tfloat t = max ( mini.x, max ( mini.y, mini.z ) );\n\t\n\n\n\treturn Render(\n    voxel_color(pos),\n    ((res==1.)?t*res:t),\n    ro+(rd*t*res),\n    nor,\n    mini,\n    pos,\n    mm\n    \n    );\n}\n\nfloat shadow(Ray cam){\nvec3 ro=cam.ro;\nvec3 rd=cam.rd;\n\tvec3 pos = floor(ro);\n\tvec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tfloat res = -1.0;\n\tvec3 mm = vec3(0.0);\n\tfor( int i=0; i<STEPS; i++ ) \n\t{\n\t\tif( voxel_color(pos).w>0.5 ) { res=1.0; break; }\n\t\tmm = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n\n\tvec3 nor = -mm*rs;\n\tvec3 vos = pos;\n\t\n    // intersect the cube\t\n\tvec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n\tfloat t = max ( mini.x, max ( mini.y, mini.z ) );\n\t\n\n\n\treturn sat(t);\n    \n;\n}\nfloat isEdge( in vec2 uv, vec4 va, vec4 vb, vec4 vc, vec4 vd ){\n    vec2 st = 1.0 - uv;\n\n    // edges\n    vec4 wb =vec4(uv.x,\n                                           st.x,\n                                           uv.y,\n                                           st.y)  * ( 1.0 - va + va*vc );\n    // corners\n    vec4 wc = vec4(uv.x*uv.y,\n                                           st.x*uv.y,\n                                           st.x*st.y,\n                                           uv.x*st.y)  * ( 1.0 - vb + vd*vb );\n    return maxcomp( max(wb,wc) );\n}\nvec3 render( in vec3 ro, in vec3 rd ,float var1,vec2 uv){\nRender A=raycast(Ray( ro, rd),uv);vec3 col = vec3(0.0);float t = A.dist;vec3 vos=A.oVos, dir=A.oDir;\n\n\tif( t>0.0 )\n\t{\n        vec3 nor = -dir*sign(rd);\n        vec3 pos = ro + rd*t;\n        vec3 uvw = pos - vos;\t\t\n\t\tvec3 v1  = vos + nor + dir.yzx;\n\t    vec3 v2  = vos + nor - dir.yzx;\n\t    vec3 v3  = vos + nor + dir.zxy;\n\t    vec3 v4  = vos + nor - dir.zxy;\n\t\tvec3 v5  = vos + nor + dir.yzx + dir.zxy;\n        vec3 v6  = vos + nor - dir.yzx + dir.zxy;\n\t    vec3 v7  = vos + nor - dir.yzx - dir.zxy;\n\t    vec3 v8  = vos + nor + dir.yzx - dir.zxy;\n\t    vec3 v9  = vos + dir.yzx;\n\t    vec3 v10 = vos - dir.yzx;\n\t    vec3 v11 = vos + dir.zxy;\n\t    vec3 v12 = vos - dir.zxy;\n \t    vec3 v13 = vos + dir.yzx + dir.zxy; \n\t    vec3 v14 = vos - dir.yzx + dir.zxy ;\n\t    vec3 v15 = vos - dir.yzx - dir.zxy;\n\t    vec3 v16 = vos + dir.yzx - dir.zxy;\n\t\tvec4 vc = vec4( voxel_color(v1).w,  voxel_color(v2).w,  voxel_color(v3).w,  voxel_color(v4).w  );\n\t    vec4 vd = vec4( voxel_color(v5).w,  voxel_color(v6).w,  voxel_color(v7).w,  voxel_color(v8).w  );\n\t    vec4 va = vec4( voxel_color(v9).w,  voxel_color(v10).w, voxel_color(v11).w, voxel_color(v12).w );\n\t    vec4 vb = vec4( voxel_color(v13).w, voxel_color(v14).w, voxel_color(v15).w, voxel_color(v16).w );\n\t\tvec2 uv = vec2( dot(dir.yzx, uvw), dot(dir.zxy, uvw) );\n\t\t\t\n        // wireframe\n        float www = mix(\n        1.-isEdge( uv, va, vb, vc, vd )<.01?1.:0.,isEdge( uv, va, vb, vc, vd )<.99?1.:0.,var1);\n        col=vec3(1);\n        col *= www;\n\t\t\n \n\n        float occ = 1.0;\n\t\n        // ambient occlusion (https://iquilezles.org/articles/voxellines/)\n        vec2 st = 1.0 - uv;\n        // edges\n        vec4 wa = vec4( uv.x, st.x, uv.y, st.y ) * vc;\n        // corners\n        vec4 wb = vec4(uv.x*uv.y,\n                       st.x*uv.y,\n                       st.x*st.y,\n                       uv.x*st.y)*vd*(1.0-vc.xzyw)*(1.0-vc.zywx);\nocc = wa.x + wa.y + wa.z + wa.w +\n              wb.x + wb.y + wb.z + wb.w;\n           \n           \n        occ = 1.0 - occ/8.0;\n        occ = occ*occ;\n        occ = occ*occ;\n col*=vec3(occ);\n \n        }\n    return col;\n}\nvec4 rend(Render im1,Ray cam,vec2 uv){\nfloat shade = mix(0.9,1.,dot(im1.nor,normalize(lig)));\nfloat Shadow=shadow(Ray(im1.pos+(im1.nor/1000.),lig));\n#ifdef invertshadow\nvec4 amb=vec4(render(cam.ro,cam.rd,Shadow,uv),1);\n#else\nvec4 amb=vec4(render(cam.ro,cam.rd,1.,uv),1);\n#endif\n//vec3 col=vec3(1);\nreturn vec4(im1.color.xyz*shade,im1.dist)*amb*vec4(vec3(mix(0.5,1.,Shadow)),1);\n}\nvec3 loadValue3( in vec2 re ){\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 ).xyz;\n}\nvec2 loadValue2( in vec2 re ){\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 ).xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\nvec2 imxy=fragCoord/iChannelResolution[1].xy;\nvec2 uv = (fragCoord-(iResolution.xy/2.));\nmat3 M=mat3(loadValue3(vec2(7,0)),loadValue3(vec2(8,0)),loadValue3(vec2(9,0)));\nvec3 cpos= (loadValue3(vec2(0,0)).xyz);\nvec3 cdir =normalize(vec3(uv,-256))*M;\nvec4 col;\nRay cam=Ray(cpos,cdir);\nRender a=raycast(cam,fragCoord);\nRay cam2=Ray(a.pos+(a.nor/1009.),reflect(cdir,a.nor));\nRender b=raycast(cam2,fragCoord);\nvec4 c1=rend(a,cam,imxy);\nvec4 c2=rend(b,cam2,imxy);\nfragColor=vec4(mix(c1,c2,0.1).xyz,c1.w);\n\n}\n\n\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\nconst int STEPS=64;\nconst float EPS=0.001;\nvec3 loadValue3( in vec2 re ){\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 ).xyz;\n}\nvec2 loadValue2( in vec2 re ){\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 ).xy;\n}\n\nfloat sdf(vec3 a){\nvec3 monster=loadValue3(vec2(10,0));\nfloat x=a.x,y=a.y,z=a.z;\n//vec3 p=vec3((sin(y*10.)/10.)+(sin(z*10.)/10.)+x,(sin(x*10.)/10.)+(sin(z*10.)/10.)+y,(sin(y*10.)/10.)+(sin(x*10.)/10.)+z);\nvec3 p=a;\n\nreturn length(p-monster)-1.;}\nvec4 march(Ray Camera,vec2 uv){\nvec4 im=texture(iChannel1,uv/iResolution.xy);\nfloat t=0.;\nvec3 p = Camera.ro;\nvec3 d=normalize(Camera.rd);\nfloat h=0.;\nint stpcnt=0;\nfor(int i = 1;i<STEPS; i++){\nt=sdf(p);\np=p+(d*t);\nh=length(p-Camera.ro);;\nif((t>-EPS&&t<EPS)||h>im.w||h>100.) break;}\nreturn vec4(p,h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\nvec2 uv = (fragCoord-(iResolution.xy/2.));\nmat3 M=mat3(loadValue3(vec2(7,0)),loadValue3(vec2(8,0)),loadValue3(vec2(9,0)));\nvec3 cpos= (loadValue3(vec2(0,0)).xyz);\nvec3 cdir =normalize(vec3(uv,-256))*M;\nRay cam=Ray(cpos,cdir);\nfragColor= march(cam,fragCoord);\n\n}","name":"Buffer D","description":"","type":"buffer"}]}