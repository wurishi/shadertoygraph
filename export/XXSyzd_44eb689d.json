{"ver":"0.1","info":{"id":"XXSyzd","date":"1727555946","viewed":31,"name":"Code 14: 2D SDFs","username":"rattlehead","description":"Just a visualisation of how signed-distance functions work for toying around with when getting into shaders.\nDrag mouse to set sample point.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d","mouse","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// code_14.txt\n// 2D SDFs\n\n#define PI 3.141592653589793\n\nmat2 rotate(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(\n        c,-s,\n        s,c\n    );\n}\n\nfloat sdCircle(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdBox(vec2 p, vec2 r)\n{\n    p = abs(p) - r;\n    return length(max(p, 0.0)) + min(max(p.x, p.y), 0.0);\n}\n\nfloat sdLineSegment(vec2 p, vec2 a, vec2 b, float r)\n{\n    p -= a;\n    b -= a;\n    float l = dot(p, b) / dot(b, b);\n    l = clamp(l, 0.0, 1.0);\n    return length(p - l * b) - r;\n}\n\nfloat sdLineSegment(vec2 p, float l, float r)\n{\n    p.x = max(abs(p.x) - l, 0.0);\n    return length(p) - r;\n}\n\nfloat sdPlane(vec2 p, vec2 o, vec2 n)\n{\n    vec2 q = p - o;\n    return dot(q, normalize(n));\n}\n\nfloat sdf(vec2 p, float time)\n{\n    float angle = atan(p.y, p.x);\n    vec2 r = vec2(0.4);\n    float d = sdBox(p, r + r * sin(time));\n    p -= vec2(0.3, 0.1);\n    p *= rotate(-PI / 4.0);\n\n    d = min(d, sdLineSegment(p, vec2(-1.4, 0.4), vec2(-1.3, 1.2), 0.24 + 0.24 * sin(time)));\n    d = min(d, sdPlane(p, vec2(0.8, -0.4), vec2(-0.5, 1.0)));\n    return d;\n}\n\nvec3 getColor(vec2 uv, float time, float duv)\n{\n    vec3 col = vec3(0);\n\n    float wave = 200.0 * iResolution.x / 800.0;\n    // negative space\n    col += vec3(0.800, 0.001, 0.001) * sqrt(sqrt(smoothstep(0.00, 1.00, -duv))) * (smoothstep(-6.0, 1.0, sin(min(duv, 0.0) * wave - time)));\n    // positive space\n    col += vec3(0.001, 0.800, 0.001) * sqrt(sqrt(smoothstep(0.00, 1.00, duv))) * (smoothstep(-6.0, 1.0, sin(max(duv, 0.0) * wave + time)));\n    // surface area\n    wave = 0.009 * 800.0 / iResolution.x;\n    col += smoothstep(wave, 0.000, abs(duv));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 ms = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    float time = iTime * 1.0;\n    float phase = cos(time * 0.1) * 0.5 + 0.5;\n\n    float d = sdf(uv, time);\n\n    vec3 col = getColor(uv, time, d);\n\n    float r = sdf(ms, time);\n    r = abs(r);\n    float dms = length(uv - ms) - r;\n\n    r = 800.0 / iResolution.x;\n    col += clamp(iMouse.z, 0.2, 5.0) * vec3(1.0, 1.0, 0.0) * smoothstep(0.008 * r, 0.003 * r, abs(dms)); // mouse circle\n    col += clamp(iMouse.z, 1.0, 5.0) * vec3(1.0, 1.0, 0.0) * smoothstep(0.01 * r, 0.005 * r, length(uv - ms)); // mouse position\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}