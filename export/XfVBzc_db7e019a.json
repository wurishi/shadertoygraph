{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"#define offset 0.001\n\n#define EdgeDetection\n//#define Scharr\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float edgeThreshold = .9;\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    vec3 topLeft = texture(iChannel0, uv + vec2(-offset, offset)).rgb;\n    vec3 topMiddle = texture(iChannel0, uv + vec2(0., offset)).rgb;\n    vec3 topRight = texture(iChannel0, uv + vec2(offset, offset)).rgb;\n    \n    vec3 right = texture(iChannel0, uv + vec2(offset,0.)).rgb;\n    vec3 left = texture(iChannel0, uv + vec2(-offset, 0.)).rgb;\n    \n    vec3 botLeft = texture(iChannel0, uv + vec2(-offset, -offset)).rgb;\n    vec3 botMiddle = texture(iChannel0, uv + vec2(0., -offset)).rgb;\n    vec3 botRight = texture(iChannel0, uv + vec2(offset, -offset)).rgb;\n    \n#ifdef EdgeDetection\n    //Sobel Operator Vertical\n    //1 0 -1\n    //2 0 -2\n    //1 0 -1\n    vec3 verticalGradiant = topLeft + (2. * topMiddle) + topRight -botLeft - (2. * botMiddle) - botRight; \n    \n    //Sobel Vertical\n    // 1  2  1\n    // 0  0  0\n    //-1 -2 -1\n    vec3 horizontalGradiant = -topLeft + topRight + (2. * right) + (-2. * left) - botLeft + botRight;\n    \n    vec3 gradiantmMagnitude = sqrt(verticalGradiant * verticalGradiant + horizontalGradiant * horizontalGradiant);\n    \n    float edgeValue = (0.299*gradiantmMagnitude.r + 0.587*gradiantmMagnitude.g + .114*gradiantmMagnitude.b) > edgeThreshold ? 1. : 0.;\n    \n    fragColor = vec4(edgeValue);\n#endif\n#ifdef Scharr\n    //Sobel Vertical\n    //47 0 -47\n    //162 0 -162\n    //47 0 -47\n    vec3 verticalGradiant = (47. * topLeft) + (-47. * topRight) + (162. * right) + (-162. * left) + (47. * botLeft) + (-47. * botRight); \n    \n    \n    //Sobel Vertical\n    // 47  162  47\n    // 0   0    0\n    //-47 -162 -47\n    vec3 horizontalGradiant = (47. * topLeft) + (162. * topMiddle) + (47. * topRight) + (-47. * botLeft) - (162. * botMiddle) + (-47. * botRight);\n    \n    vec3 gradiantmMagnitude = sqrt(verticalGradiant * verticalGradiant + horizontalGradiant * horizontalGradiant);\n    \n    float edgeValue = (0.299*gradiantmMagnitude.r + 0.587*gradiantmMagnitude.g + .114*gradiantmMagnitude.b) / 35. > edgeThreshold ? 1. : 0.;\n    \n    fragColor = vec4(edgeValue);\n#endif\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XfVBzc","date":"1734294663","viewed":41,"name":"Sobel Operations","username":"Danoontje","description":"Sobels EdgeDetection \nDONT USE SOBELS EDGE DETECTION ITS NOT GOOD!\ni like using either Canny Edge Detection for crisp edges or Roberts Cross Edge Detection for height detailed edges\nmore types of edgedetection:\nhttps://blog.roboflow.com/edge-detection","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["edgesoble"],"hasliked":0,"parentid":"","parentname":""}}