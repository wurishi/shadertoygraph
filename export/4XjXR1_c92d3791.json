{"ver":"0.1","info":{"id":"4XjXR1","date":"1710330820","viewed":105,"name":"Project to nearest edge 2d grid","username":"Oneleven","description":"A failed attempt at producing some sort of digital look. The idea was to use that projection approach on 3d particles in UE5 as a final step after velocity/force calculations.\nBut end result is not good, so I wont\n","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["grid","projection","edge"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv2 = fract((fragCoord-0.5*iResolution.xy)/iResolution.y*ZOOM);   \n        \n    //grid\n    vec2 uvG = abs(uv2*2.0-1.0);\n    vec3 col = vec3(smoothstep(PIX*ZOOM,0., 1.0 - max(uvG.x,uvG.y))*0.1);\n    \n    col += texture(iChannel0, uv).rgb;\n    fragColor = vec4(col,0.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Hash without Sine by Dave_Hoskins\n//https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat getDot(vec2 p, vec2 uv, vec2 id)\n{\n    vec2 uvD = fract(p*ZOOM) - 0.5; \n    float pp = 0.;\n    \n    //current cell\n    if (floor(p * ZOOM) == id)\n    {\n        uv -= 0.5;\n        \n        // get sector index\n        float a = atan(uvD.y, uvD.x);\n        a = floor(fract(a/PI*0.5+0.5+0.125)*4.0); \n        \n        //project point to the edge of a square\n        float k, g;\n        if (a == 0. || a == 1.) k = -0.5;\n        else k = 0.5;\n        if (a == 1. || a == 3.) g = uvD.y;\n        else g = uvD.x;\n        uvD = k * uvD/g;\n        \n        //draw dot\n        pp = distance(uv, uvD);\n        pp = smoothstep(PIX*ZOOM*2.0,0., pp)*1.0;     \n    }\n    \n    return pp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;    \n\n    vec2 uv2 = uv * ZOOM;\n    vec2 id = floor(uv2);\n    uv2 = fract(uv2);    \n    \n    vec3 col = vec3(0);\n    for (float i=0.; i<40.; i++)\n    {\n        float h = hash11(i);\n        vec2 p = vec2(cos(i*PI*0.25+iTime*0.111 + h), sin(i*PI*0.3+iTime*0.203+h))*0.5; //source point\n        p.x*=1.6;\n        col += vec3(smoothstep(PIX*1.0, PIX*0.0, distance(uv, p)),0,0); //draw source point in red\n        col += vec3(getDot(p, uv2, id)); //draw projected point in white\n    }\n    \n    //trails\n    col += texture(iChannel0, fragCoord/iResolution.xy).rgb*0.97;\n\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PIX 2.0/iResolution.y\nconst float ZOOM = 15.;\n\nconst float PI = 3.14159265;","name":"Common","description":"","type":"common"}]}