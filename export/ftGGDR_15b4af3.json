{"ver":"0.1","info":{"id":"ftGGDR","date":"1637429822","viewed":2128,"name":"Fractal Gliding","username":"AntoineC","description":"The Julia set for Zn+1 = b*abs(a*Zn)+c offers a pretty amazing variety of shapes and textures.\n \nGo fullscreen, relax and enjoy the trip!\n \nAs Fabrice commented below: take your time, the animation is 133s long!","likes":56,"published":1,"flags":32,"usePreview":0,"tags":["2d","fractal","julia"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ----------------------------------------------------------------------------------------\n//\t\"Fractal Gliding\" by Antoine Clappier - Nov 2021\n//\n//\tLicensed under:\n//  A Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n//\thttp://creativecommons.org/licenses/by-nc-sa/4.0/\n// ----------------------------------------------------------------------------------------\n//\n//     The Julia set for Zn+1 = b*abs(a*Zn^3)+c offers a pretty amazing\n//     variety of shapes and textures.\n//\n//     Go fullscreen, relax and enjoy the trip!\n//\n//\n// Point of interests:\n//  - Optimized for high quality full-screen rendering (tested to\n//    run smoothly on a laptop GeForce 1650 at 2560x1440).\n//\n//  - Temporal oversampling up to 32 samples per pixel with rounded\n//    image transformations to avoid smearing.\n//\n//  - Adaptive quality based on measured fps.\n//\n//  - Detection of scene transitions and screen resolution to reset\n//    accumulation buffer.\n//\n//\n//    Interactive version:  https://www.shadertoy.com/view/fty3zK\n//    \n//\n//\n\n\n\nvoid mainImage(out vec4 color, in vec2 coord)\n{\n\t// Read accumulation buffer, add fade in between sequences:\n    vec4  c    = texture(iChannel0, coord/iResolution.xy);\n\tfloat fade = smoothstep(0.0, 0.7, Time < 9.0 ? 0.3+6.0*fract(7.0*Time/9.0) : mod(mod(Time-9.0, 19.0), 8.0)); // Scene: 19s, Sequence: 8s\n    color      = mix(vec4(0.0), c, fade);\n\n    // \"De-banding\" with 1-bit random dithering (use Dave Hoskins hash33):\n    vec3 p = fract(vec3(coord, iFrame) * vec3(.1031, .1030, .0973));\n    p += dot(p, p.yxz+19.19);\n    vec3 noise = fract((p.xxy + p.yxx)*p.zyx);\n    color.rgb += (noise-0.5)/255.0;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//  Uncomment '#define Slow' in for a slower animation. \n\n\n//#define Slow\n\n\n#ifdef Slow\n#define Time (0.9*iTime)\n#else\n#define Time (1.3*iTime)\n#endif\n\n//#define DebugFps\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define Pi        3.14159265359\n#define Tau       6.28318530718\n#define ToRad(a)  ((a)*Pi/180.0)\n#define ToDeg(a)  ((a)*180.0/Pi)\n#define Rot(a)    mat2(cos(ToRad(a)),sin(ToRad(a)),-sin(ToRad(a)),cos(ToRad(a)))\n#define Scale(s)  mat2((s),0.,0.,(s))\n\n\nfloat PreScale             = 0.0;\nfloat PreGamma             = 1.0;\nbool  RepeatEnabled        = false;\nfloat RepeatFrequency      = 1.0;\nfloat ContrastStrength     = 0.0;\nfloat ContrastHighlight    = 1.0;\nfloat PostGamma            = 1.0;\nint   MaxIter              = 256;\nfloat Rotation             = 0.0;\nvec2  A                    = vec2(1.0,0.0);\nvec2  B                    = vec2(1.0,0.0);\nvec2  C                    = vec2(-0.512511,0.521295);\nvec3  Loc0                 = vec3(0.0,0.0,1.0);\nvec2  Dst0                 = vec2(0.0,0.0);\nvec3  Loc1                 = vec3(0.0,0.0,1.0);\nvec2  Dst1                 = vec2(0.0,0.0);\nvec3  Loc2                 = vec3(0.0,0.0,1.0);\nvec2  Dst2                 = vec2(0.0,0.0);\nvec3  BackColor            = vec3(0.286,0.353,0.459);\nfloat R0                   = 0.20884;\nfloat R1                   = 2.21687;\n\n\n// -----------------------------------------------------------------------\n// --- Fractal: ----------------------------------------------------------\n// -----------------------------------------------------------------------\n\nvec2 Cube(vec2 z)\n{\n\tvec2 b = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y);\n\treturn vec2(z.x*b.x - z.y*b.y, z.x*b.y + z.y*b.x);\n}\n\nvec2 Mul(vec2 a, vec2 b)\n{\n\treturn vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvec2 Julia(vec2 z)\n{\n    float d = 0.0;\n    vec2 z0 = z;\n    float magnitude0 = length(z);\n    for(int i=0; i<MaxIter; i++)\n    {\n    \t// Formula: Zn+1 = b*abs(a*Zn^3) + c\n    \t//  Based on a formula seen a while ago on Tom Beddard's blog.\n    \t//  The Mandelbrot set is uninteresting.\n    \t//  But the Julia sets are quite varied and surprising!\n\n\t\tz = Mul(abs(Mul(A, Cube(z))), B) + C;\n\n\t\tfloat magnitude = length(z);\n\t\tif(magnitude > 32.0)\n        {\n\t\t\treturn vec2(0.0);\n        }\n\n\t\td += exp(-1.0/abs(magnitude0 - magnitude));\n\t\tz0 = z;\n\t\tmagnitude0 = magnitude;\n    }\n\n    return vec2(log(d), 1.0);\n}\n\n// -----------------------------------------------------------------------\n// --- Animation: --------------------------------------------------------\n// -----------------------------------------------------------------------\n\nfloat EaseOut(in float x)\n{\n\t// See: https://www.desmos.com/calculator/korqdwvlco\n\tconst float q = 2.0/8.0, qd = 3.0-2.0*q;\n\tconst float a = q/qd, b = -3.0*q/qd, c = 3.0*q/qd, d = 3.0*(1.0-q)/qd;\n\tfloat t = (x+q-1.0)/q;\n\treturn x <= 1.0 - q ? 3.0*x/qd : t*(a*t*t + b*t + c) + d;\n}\n\nfloat DelayEnd(in float x)\n{\n\treturn min(x/(1.0-0.5/8.0), 1.0);\n}\n\n// -----------------------------------------------------------------------\n// --- Sequencing: -------------------------------------------------------\n// -----------------------------------------------------------------------\nconst float IntroDuration = 9.0;\nconst float SequenceDuration = 8.0;\nconst float SceneDuration = 2.0*SequenceDuration + 3.0; // 2*8s + 3s\nconst float SceneCount = 7.0;\nconst float MovieDuration = SceneCount*SceneDuration;\n\nvec3 Sequencing(float t)\n{\n\tif( t < IntroDuration)\n\t{\n\t\t//return vec3(0.0, 0.0, 1000.0);\n\t\treturn vec3(0.0, 0.0, floor(7.0*Time/IntroDuration));\n\t}\n\tt -= IntroDuration;\n\n\tfloat scene = 0.0, sequence = 0.0;\n\tt = mod(t, MovieDuration);\n\tscene = floor(t / SceneDuration);\n\tt = mod(t, SceneDuration);\n\tsequence = floor(t / SequenceDuration);\n\tt = mod(t, SequenceDuration);\n\treturn vec3(t, sequence, scene);\n}\n\nvec3 GetTransform(float t)\n{\n\tvec3  ts = Sequencing(t);\n\tfloat k  = EaseOut(DelayEnd(ts.x/8.0));\n\tif     (ts.y == 0.0) { return vec3(mix(Loc0.xy, Dst0, k), Loc0.z); }\n\telse if(ts.y == 1.0) { return vec3(mix(Loc1.xy, Dst1, k), Loc1.z); }\n\telse                 { return vec3(mix(Loc2.xy, Dst2, k), Loc2.z); }\n}\n\n\nvec2 Translation(float t)\n{\n\tvec3 TransZoom = GetTransform(t);\n\tvec2 trans = -TransZoom.z*TransZoom.xy;\n\treturn  iResolution.y*trans/2.0;\n}\n\n\nvec2 Jitter(in vec2 fragCoord)\n{\n\t// Using Dave Hoskin's hash:\n\tvec3 p3 = fract(vec3(fragCoord, Time) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+19.19);\n\treturn fragCoord + vec2(fract((p3.xx+p3.yz)*p3.zy) - 0.5);\n}\n\nvoid SetSceneParameters(float scene)\n{\n\t// Settings were created interactively using Synthclipse\n\t// A nice IDE to code Shadertoys.\n\tif(scene == 0.0)\n\t{\n\t\t// Setting7:\n\t\tA=vec2(-0.05050397,-0.168316); B=vec2(0.96969604,-1.242424); C=vec2(-0.909088,0.8788879); ContrastStrength=0.72245; Dst0=vec2(1.51278,0.0); Dst1=vec2(0.25989,0.50691); Loc0=vec3(0.52830005,0.0,5.05447); Loc1=vec3(0.25989,1.6831,3.45227); Loc2=vec3(0.0,0.0,0.38554); MaxIter=232; PostGamma=1.5959187; PreGamma=1.0685698; PreScale=-0.18775594; R0=1.1245; R1=5.644266; RepeatFrequency=2.2; Rotation=65.47356;\n\t}\n\telse if(scene == 1.0)\n\t{\n\t\t// Setting10:\n\t\tA=vec2(2.0,1.0026519); B=vec2(-0.27045596,0.74801207); C=vec2(-0.014915943,-0.48476005); ContrastStrength=0.50204; Dst0=vec2(-0.09985,0.0516); Dst1=vec2(0.0,0.75789); Loc0=vec3(-0.1517,0.08739,41.14481); Loc1=vec3(0.0,0.25713,6.7275); MaxIter=243; PostGamma=0.6497946; PreGamma=1.099593; PreScale=1.1199999; RepeatEnabled=true; RepeatFrequency=0.72755504; Rotation=21.132;\n\t}\n\telse if(scene == 2.0)\n\t{\n\t\t// Setting1:\n\t\tA=vec2(1.0,1.071604); B=vec2(0.92345595,-1.120988); BackColor=vec3(0.28627452,0.45882353,0.42352942); C=vec2(-0.34274006,0.3664961); ContrastHighlight=0.155102; ContrastStrength=0.395918; Dst0=vec2(0.0,0.31722); Dst1=vec2(0.38814,0.0); Loc0=vec3(-0.3941,0.31722,6.11591); Loc1=vec3(0.38814,-0.53359,4.17725); MaxIter=252; PostGamma=1.8440815; PreGamma=0.6546016; PreScale=0.42379594; R1=2.538152; RepeatFrequency=0.63; Rotation=14.2956;\n\t}\n\telse if(scene == 3.0)\n\t{\n\t\t// Setting9:\n\t\tA=vec2(2.0,2.0); B=vec2(-0.29177594,0.75862); BackColor=vec3(0.26666668,0.36078432,0.45882353); C=vec2(-0.07557595,-0.40087605); ContrastStrength=0.62576604; Dst0=vec2(-0.20006,0.0); Dst1=vec2(0.24391,0.4249); Loc0=vec3(-0.26006,0.0,54.76373); Loc1=vec3(0.24842,0.43541,276.8017); Loc2=vec3(0.0,0.0,1.21); MaxIter=243; PostGamma=0.773876; PreGamma=0.6546016; PreScale=1.232652; R1=1.95984; RepeatFrequency=2.2; Rotation=134.94635;\n\t}\n\telse if(scene == 4.0)\n\t{\n\t\t// Setting11:\n\t\tA=vec2(2.0,0.8859401); B=vec2(-1.1830239,0.3662479); BackColor=vec3(1.0,0.9607843,0.8); C=vec2(0.3154359,-0.30016804); ContrastHighlight=0.0; ContrastStrength=-0.640816; Dst0=vec2(-0.715,0.0); Dst1=vec2(0.0,-0.36); Loc0=vec3(-0.65108,0.0,66.26409); Loc1=vec3(0.0,0.0,15.86309); Loc2=vec3(0.0,0.0,1.4641); MaxIter=243; PostGamma=0.96; PreGamma=4.0; PreScale=1.134692; R0=0.353412; R1=1.783132; RepeatEnabled=true; RepeatFrequency=0.9663227; Rotation=112.032715;\n\t}\n\telse if(scene == 5.0)\n\t{\n\t\t// Setting12:\n\t\tA=vec2(0.11140394,-0.992044); B=vec2(-0.854112,0.3662479); BackColor=vec3(0.38039216,0.4392157,0.56078434); C=vec2(0.581028,0.562248); ContrastHighlight=0.0; ContrastStrength=0.191836; Dst0=vec2(-0.59736,0.11306); Dst1=vec2(0.0,-1.06502); Loc0=vec3(-0.59736,-0.05234,23.22517); Loc1=vec3(0.0,-0.76502,13.11); Loc2=vec3(0.0,0.0,0.75131); MaxIter=345; PostGamma=0.96; PreScale=-0.808512; R0=0.096384; R1=3.084336; RepeatEnabled=true; RepeatFrequency=1.494685; Rotation=57.81492;\n\t}\n\telse if(scene == 6.0)\n\t{\n\t\t// Setting6:\n\t\tA=vec2(-0.31983197,-0.030303955); B=vec2(0.96969604,-0.19192004); BackColor=vec3(0.19607843,0.2627451,0.4); C=vec2(-0.90909195,0.878788); ContrastHighlight=0.0; ContrastStrength=-0.67347; Dst0=vec2(-0.88277,0.0); Dst1=vec2(0.0,-1.01423); Loc0=vec3(0.0,0.0,4.17725); Loc1=vec3(0.0,-1.23423,13.11); Loc2=vec3(0.0,0.0,0.51316); MaxIter=243; PostGamma=1.5959187; PreScale=-0.773672; R0=1.140564; R1=3.598392; RepeatEnabled=true; RepeatFrequency=0.8071442; Rotation=57.81492;\n\t}\n}\n\nvoid SetScene(float scene, vec2 p)\n{\n\tSetSceneParameters(scene);\n\tif(Time<IntroDuration)\n\t{\n\t\tLoc0 = Loc2; Dst0 = Dst2;\n\t\tLoc1 = Loc2; Dst1 = Dst2;\n\t\tBackColor = vec3(0.286,0.353,0.459); R0 = 0.20884/Loc2.z; R1 = 2.21687/Loc2.z;\n\t}\n}\n\n// -----------------------------------------------------------------------\n// --- Image processing: -------------------------------------------------\n// -----------------------------------------------------------------------\nvec3 Cubic(vec3 c, float d0, float d1)\n{\n\treturn c*((d0+d1-2.)*c*c +(3.-2.*d0-d1)*c + d0);\n}\n\nvec3 Contrast(vec3 c)\n{\n\tfloat s = ContrastStrength, h = ContrastHighlight;\n    float d0 = 1.-s, d1 = (1.-h) + h*(1.-s);\n\treturn Cubic(Cubic(c, d0, d1), d0, d1);\n}\n\nvec3 Repeat(vec3 c)\n{\n\t// Triangle:\n\treturn abs(2.0*fract(RepeatFrequency*c+0.5) - 1.0);\n}\n\nvec3 Curve(vec3 c)\n{\n\tc = max(c, 0.0);\n    c = c*pow(2.0, PreScale);\n    c = pow(c, vec3(PreGamma));\n    c = RepeatEnabled ? c = Repeat(c) : c;\n    c = clamp(c, 0.0, 1.0);\n    c = Contrast(c);\n    c = pow(c, vec3(PostGamma));\n\n    return c;\n}\n\n\n\n// -----------------------------------------------------------------------\n// --- Rendering: --------------------------------------------------------\n// -----------------------------------------------------------------------\n\nvoid Render(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = (fragCoord - 0.5*iResolution.xy)*2.0/iResolution.y;\n\n    // Apply transform:\n    //  Translation is already applied to fragCoord\n\tvec3 transZoom = GetTransform(Time);\n\tuv = uv / transZoom.z;\n    mat2 tfm = Rot(Rotation);\n\n    // Render:\n    vec2 cm   = Julia(tfm*uv);\n    vec3 col  = Curve(vec3(cm.x));\n    vec3 back = mix(vec3(0.0), BackColor, smoothstep(R0, R1, length(uv)));\n    col = mix(back, col, cm.y);\n\n    fragColor = vec4(col, 1.0);\n}\n\n\n// ---------------------------------------------------------------------\n// --- Load/Store from IQ (https://www.shadertoy.com/view/MddGzf) ------\n// ---------------------------------------------------------------------\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nvec4 Load(in vec2 address) { return texture(iChannel0, (0.5+address) / iResolution.xy, -100.0 ); }\nvoid Store(in vec2 address, in vec4 value, inout vec4 fragColor, in vec2 fragCoord) { fragColor = (isInside(fragCoord,address) > 0.0) ? value : fragColor; }\n\n// Address:\nconst vec2 mWidthHeightTimeState = vec2( 0.0, 0.0);\nconst vec2 mScene                = vec2(1.0, 0.0);\n\n\n// ---------------------------------------------------------------------\n// ---------------------------------------------------------------------\n// ---------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Load state:\n\tvec4 state = Load(mWidthHeightTimeState);\n\tfloat t0 = state.z;\n\tfloat t1 = Time;\n\tvec2 resolution0 = state.xy;\n\tvec2 resolution1 = iResolution.xy;\n    float threshold = state.w;\n    vec3 stateB = Load(mScene).xyz;\n\tvec2 scene0 = stateB.xy;\n\tvec2 scene1 = Sequencing(Time).yz;\n    float thresholdTime = stateB.z;\n\n\t// Update scene parameters:\n\tSetScene(scene1.y, fragCoord);\n\n\t// Translation in frag coordinates:\n\t//   Use integer translation to avoid smearing when accumulating values\n\tvec2 trans0 = floor(Translation(t0));\n\tvec2 trans1 = floor(Translation(t1));\n\tvec2 deltaTrans = trans0 - trans1;\n\n\t// Coordinate of the current pixel in the accumulation buffer:\n\tvec2 uv0 = (fragCoord + deltaTrans)/iResolution.xy;\n\n\t// Invalidate buffer?\n\tbool invalidate = iFrame == 0;\n\tinvalidate = invalidate || uv0.x < 0.0 || uv0.x > 1.0 || uv0.y < 0.0 || uv0.y > 1.0;;\n\tinvalidate = invalidate || (uv0.y < 1.0/iResolution.y && uv0.x < 3.0/iResolution.x);\n\tinvalidate = invalidate || resolution0 != resolution1;\n\tinvalidate = invalidate || scene0 != scene1;\n\n\t// Get accumulated color at previous coordinate:\n\tvec4 color = invalidate ? vec4(0) : texture(iChannel0, uv0);\n\n\t// Adaptive max accumulation per pixel:\n    if(resolution0 != resolution1)\n    {\n    \t// Used to wait for FPS to settle down when changing resolution\n        thresholdTime = iTime + 40.0/60.0;\n    }\n\n    const float maxThreshold = 32.0;\n    if((iFrame < 60) || (resolution1.x < resolution0.x))\n    {\n        threshold = maxThreshold;\n        thresholdTime = iTime;\n    }\n    else if(iTime > thresholdTime + 20.0/60.0)\n    {\n    \t// Reduce max accumulation when FPS is low:\n        threshold = iFrameRate < 45.0 ? threshold -= 2.0 : threshold;\n        threshold = clamp(threshold, 4.0, maxThreshold);\n    }\n\n\t// Render:\n\tif(color.w < threshold)\n\t{\n\t\tRender(fragColor, Jitter(fragCoord - trans1));\n\n\t\t// Accumulate in linear space:\n\t\tcolor.rgb = pow(color.rgb, vec3(2.2)) * color.w + pow(fragColor.rgb, vec3(2.2));\n\t\tcolor.w++;\n\t\tcolor.rgb = pow(color.rgb/color.w, vec3(1./2.2));\n\t}\n    fragColor = color;\n\n\n#ifdef DebugFps\n    // Show FPS and threshold:\n    if(fragCoord.y < 10.0)\n    {\n        vec4 bar = (0.5+0.5*floor(mod(fragCoord.x/8.0, 2.0)))*vec4(1,0,0,0);\n        fragColor = mix(mix(bar, (bar+5.0*fragColor)/6.0, vec4(fragCoord.x>2.0*threshold)), fragColor, vec4(fragCoord.x > 2.0*32.0));\n    }\n    else if(fragCoord.y < 20.0)\n    {\n        vec4 bar = (0.5+0.5*floor(mod(fragCoord.x/15.0, 2.0)))*vec4(0,1,0,0);\n        fragColor = mix(mix(bar, (bar+5.0*fragColor)/6.0, vec4(fragCoord.x>2.0*iFrameRate)), fragColor, vec4(fragCoord.x > 2.0*60.0));\n    }\n#endif\n\n\t// Store state:\n\t//  Only update time when an actual translation occurs.\n\tfloat t = deltaTrans != vec2(0.0) ? t1 : t0;\n\tStore(mWidthHeightTimeState, vec4(resolution1, t, threshold),  fragColor, fragCoord);\n\tStore(mScene,                vec4(scene1, thresholdTime, 0.0), fragColor, fragCoord);\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}