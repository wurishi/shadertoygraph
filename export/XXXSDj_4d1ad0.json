{"ver":"0.1","info":{"id":"XXXSDj","date":"1710092716","viewed":129,"name":" Five polyhedral tiling 几种多面体密铺","username":"shadertoyjiang","description":"平铺，密铺堆砌\n凸均匀堆砌，又称三维凸均匀蜂巢体（英语：Convex uniform honeycomb）","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["m"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2024-3-9\n// 3-27注：化单\n#define N12 12\nvec3 n[N12];\n\nint who ;// 0,1,2,3,4       // 2024-3-9\nint type ; // 距离类型：面2,线框1,0 中心, 顶点\nfloat size;//pa,cc;\n\n\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n\nvec3 center(vec3 p)\n{\n        switch (who)\n        {\n                case 0: return cent1214(p, size );\n                case 1: return cent1424(p, size );\n                case 2: return cent0806(p, size );\n                case 3: return cent0812(p, size );\n                case 4: return cent0608(p, size );\n        }\n}\n\nfloat dist(vec3 p,vec3 f)\n{        \n        // type who size\n        float pa=.02, cc=.15*(1.+float(type==2)), sz;\n        if(type==0)cc=.5;\n        //if(type==3)pa=.1;\n        sz=size*(1.-pa-cc); // 边距，圆弧尺寸，核心尺寸\n        cc*=size;\n        switch (who)\n        {\n                case 0: return dist1214(p, sz, type)-cc;\n                case 1: return dist1424(p, sz, type)-cc;\n                case 2: return dist0806(p, sz, f, type)-cc;\n                case 3: return dist0812(p, sz, type)-cc;\n                case 4: return dist0608(p, sz, type)-cc;\n        }\n}\n\n\nfloat map(vec3 p)\n{\n        //if(length(p)>15.)return true;\n        float c;\n        p *= .225;\n        if( dot(sin(p), cos(p.yzx-.1)) < -1.)c=1.; \n        return c;                                            \n}\n\n\n\n\n\nvoid getNorm(int who, inout int N, inout vec3 norm[N12],inout float dfc[N12])\n{\n        who = who>-1 && who< 5 ? who : 0;\n        for(int i;i<N12;i++)norm[i]++;\n        ////int N = Nnorm + (Nnorm==2 ? 2 : 0);//+ int(Nnorm==2)*2; // 多的两个只是简化取模运算\n        #define CPY for(int i,j;i<N + (who==2 ? 4 : 0);i++) { j=i*3, norm[i]=vec3(m[j],m[j+1],m[j+2]), dfc[i]= (who==1 && i>2) ? SQ3*.5 *size: size; }\n        switch (who)\n        {\n                case 0:{ N=6;int   m[]=  int[](0,1,1,   1,0,1,   1,1,0,   0,-1,1,   -1,0,1 ,   -1,1,0 );CPY break;}                  // 菱形十二面体\n                case 1:{ N=7;int   m[]=  int[](1,0,0,   0,1,0,   0,0,1,   1,-1,1,   -1,1,1,   1,1,-1,   1,1,1 );CPY break;}         // 截角八面体\n                case 2:{ N=4;int   m[]=  int[](-1,1,0,   1,1,0,   0,1,-1,   0,1,1,   1,0,-1,   1,0,1, /**/  -1,1,0,   1,1,0);CPY break;} // 八面体（六个就够了）\n                case 3:{ N=4;float m[]=float[](SQ3,0.,1.,  0.,0.,2.,  -SQ3,0.,1.,  0.,2.,0. );CPY break;}   // 六棱柱\n                case 4:{ N=3;int   m[]=  int[]( 1,0,0,   0,1,0,  0,0,1);CPY break;}               // 正方体\n        }\n}\n\n               \n\n\n\n// 内\nvec4 distIn(vec3 c, vec3 p,vec3 r) // 21:57 2024-3-7\n{\n        vec3 f = abs(dir0806((p+c)*.5,size));\n        vec3 o = p - c, q;\n        vec4 ret;ret.w=-1.;\n        float d,t;\n        if(map(c)<.5)return ret;\n        for(int i; i<28 && t <size *3.; i++)\n        {\n                q = o + r * t;\n                d = dist(q, f);\n                if(d<.01)\n                {\n                        vec3 e= vec3(0,.001,0);\n                        ret.xyz = normalize(vec3( dist(q+e.yxx,f) ,dist(q+e,f) ,dist(q+e.xxy,f) )-d);\n                        ret.w=d;\n                        break;\n                }\n                t += d*.9;\n        }\n        return ret;\n}\n\n\n\nvoid mainImage( out vec4 O, vec2 v)\n{\n        // fff大\n\n        size = 1.5;// pa=size*.05, cc=size*.2;\n\n        \n\n        float t =iTime*.5;//23.52;// iTime;\n\n        who = int(t+10.)/4%5;//  who=2;\n\n        \n        \n        \n        //who=1;\n        //type=2;\n\n        \n\n        int i,j,k, N,h;\n\n        O *= 0.;\n\n        vec2 R = iResolution.xy,\n\n             u = (v+v +.3- R)/R.y;\n        \n        if(t>3.)u.y-=.82;\n\n        vec3 o = vec3(.5,0,-1.+t*3.),p,q,c,\n\n             r = normalize(vec3(u,2)),\n\n             s = normalize(vec3(-1,3,-5));///3.7; // light\n\n        //r.yx *= rot(sin(t*8.)*.02);\n\n        r.xz *= rot(-.5); r.xy *= rot(.1);\n\n        s.xz *= rot(-.5); s.xy *= rot(.1);\n        \n        \n        \n        vec4 d,g;\n        vec3 n[N12],  f;\n        vec4 ret;\n        float dfc[N12],sn[N12];\n        \n        getNorm(who, N ,n,dfc);\n        \n        // 顺向，单位化\n        // i<N+(who==2?2:0)\n        for(int i;i<N+(who==2?4:0);i++)n[i]=sign(dot(r,n[i])) * normalize(n[i]),sn[i]=1./dot(r, n[i]);  \n        \n        c = center(o);\n        p = o    ; // 初始起点\n        q = o - c; // 晶内偏移\n        for(j=0;j<28;j++)\n        {\n                // 选取晶格（法向量代表）\n                h=0;if(who==2) f = abs(dir0806((p+c)*.5, size)), h=int(f.x*4.+f.z*2.);\n\n                float mind=size*99., d;\n                int mini,j;\n                vec3 nn;\n                for(int i;i<N;i++)\n                {       \n                        //j=i+h;\n                        d =(dfc[i+h] - dot(q, n[i+h]))/ dot(r, n[i+h]); // / sm[i+h];\n                        if(mind>d)mind=d, mini=i+h;\n                }\n                p += mind * r;\n                c += dfc[mini] * 2. * n[mini];\n                c = center((p+c)*.5); // 消除累积误差\n                \n                type = int(t)%2+1;\n                if(t>4.)type=int(fract(332.645*cos(c*223.544))*5.)%4;\n                \n                \n                //ret.w=map(c)-1.,ret.xyz=-n[mini];  // 最简单\n                ret = distIn(c, p, r);\n                if(ret.w>-.1)\n                { \n                        nn = ret.xyz;\n                        float d = dot(nn, s),\n                              l =max(d, 0.),\n                              a = d* .5 + .5,\n                              //b = dot(reflect(r, nn), nn)*.5+.5,\n                              g = 1.5+pow(a, 200.)-a*1.2; // 665.352.6.542.9958.8.63\n                              g = pow(g, .5);\n                            O += l*.2;\n                        if(type==1)g=a*.5;\n                        O .rgb += g* fract(234.56*sin(length(c) *123.456+cos(c.yzx))) *2.;//, 0., 1.);\n                        O *= .7;\n                       // O -= .1 ;\n                        \n                        O *= clamp(10. * exp(-.1*length(p-o)), 0., 1.);\n                        return;// 漏写\n                }\n                q = p - c; \n                // 对于一般面对称，这里有改法向量 和 改（射线，光子，三坐标轴）两种方法。\n                // 前一种\n                // for(int i;i<N+(who==2?2:0);i++)n[i]=reflect(n[i], nn),n[i]=sign(dot(r,n[i])) * normalize(n[i]),sn[i]=dot(r, n[i]);\n        }\n}\n\n\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// 2024-3-9\n// 五种密铺多面体\n\n#define SQ2 1.414213562  // sqrt(2.)\n#define SQ3 1.732050808  // sqrt(3.)\n#define SQ6 2.449489743  // sqrt(6.)\n\n\n//////////////////////////////////////////////////////////////////////////////////\n// 简易表面距离\n// 正方体 square\n\nfloat dist0608easy(vec3 p, float sz)\n\n{// 正方体简易距离\n        return length(max(abs(p)-sz, 0.));\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// 正方体 square\n\nvec3 cent0608(vec3 p, float sz)\n{// 正方体中心 2024-3-5\n        sz = .5 / sz;\n        return round(p*sz)/sz;\n}\n\n\n\nfloat dist0608(vec3 p, float sz, int type)\n{// 正方体距离 2024-3-6 带内部距离 已验证 23:52 2024-3-6\n        if(type==0)return length(p);\n        p = abs(p)-sz;\n        //if(type==3)return length(p);\n        if(p.y<p.x)p=p.yxz;\n        if(type==1)\n        {       p = p.z<p.x ? p.zyx : p; // mix(p, p.zyx, float(p.z<p.x)) // p+step(p.z, p.x)*(p.zyx-p) // p+float(p.z<p.x)*(p.zyx-p); // max( ) // abs( )\n                p.x=max(p.x,0.);\n        }\n        if(type==2)\n        {       p = p.z>p.y ? p.xzy : p;\n                p.xz=max(p.xz, 0.);\n        }\n        return length(p);\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// 六棱柱 hexagonal prism\nvec3 cent0812(vec3 p, float sz)\n{// 六棱柱中心 2024-3-8\n        sz = .5 / sz;\n        p *= sz;\n        vec3 f, c=vec3(.866,1,1), v=p/c, i=round(v);\n        i.z += mod(i.x, 2.)*(step(0., v-i).z-.5);// =.5*sign(v-i).z; but sign(0)==0\n        f = abs(v-i);\n        i += step(1., f.z+1.5*f.x)*sign(v-i)*vec3(1,0,.5);\n        return i * c / sz;\n}\n\n\nfloat dist0812(vec3 p,float sz, int type)\n{// 六棱柱距离 2024-3-6 已经验证 23:38 2024-3-6\n        if(type==0)return length(p);\n        sz = .5 / sz;\n        p = abs(p)*sz;\n        vec3 n = vec3(-SQ3,0,1)*.5;\n        if(dot(p, n)<0.)p=reflect(p, n);p = abs(p);\n        p -= .25 / abs(n.xzz);\n        if(type==1)\n        {       p = p.y<p.x ? p.yxz : p;\n                p.x=max(p.x, 0.);\n        }\n        if(type==2)\n        {       p = p.y<p.z ? p.xzy : p;\n                p.xz=max(p.xz, 0.);\n        }\n        return length(p)/sz;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////\n// 八面体 octahedron\n\nvec3 dir0806(vec3 p,float sz)\n{// 八面体主轴朝向\n        sz = SQ2*.25 /sz;  \n        p *= sz;\n        vec3 i = round(p), f = p - i;\n        vec3 s = sign(f), b = abs(f);\n        b = step(  b.yzx, b)*step( b.zxy, b);  // 最大取1\n        return s * b; // 返回指向\n}\n\nvec3 cent0806(vec3 p, float sz)\n{// 八面体中心：\n        float c = SQ2*.25 / sz;\n        return (round(p*c)+dir0806(p,sz)*.5)/c;  \n}\n\nfloat dist0806(vec3 p ,float sz, vec3 f, int type)  \n{ // 八面体距离：23:58 2024-3-7 最后修改\n        if(type==0)return length(p);\n        if(f.y>.5)p=p.yxz;\n        if(f.z>.5)p=p.zyx;\n        // 此时最长柱在 x \n        float d;\n        sz = SQ2 / sz;\n        p *= sz;\n        // 乘了四倍，除去了 .25\n        p = abs(p); \n                                                        // 23:00 2024-3-7 此时有两个顶点：(0,2,2),(2,0,0)\n        if(p.y<p.z)p=p.xzy;\n        \n        vec3 nx = normalize(vec3(-1,1,1)),\n             ny = normalize(vec3(1,1,0)),\n             nz = cross(ny,nx),//normalize(vec3(1,-1,2)), \n             zh = normalize(vec3(1,-1, SQ3 -1.)),w;         //00:00 2024-3-8\n        // 折\n        p-=vec3(0,2,2);                                      // 23:58 2024-3-7 一个顶点\n        if(dot(p, zh)<0.)p=reflect(p, zh);\n        p+=vec3(-1,1,1);     //vec3(0,2,2)-vec3(1)        // 减去棱边中心\n        \n        w.x = dot(p, nx),\n        w.y = dot(p, ny) ,\n        w.z = dot(p, nz);\n        \n        w.x=abs(w.x)- SQ3;\n        if(type==1)w.x =max(w.x , 0.);                        //00:00 2024-3-8\n        if(type==2)w.xz=max(w.xz, 0.);\n        \n        return length(w) / sz;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////\n// 菱形十二面体 rhombic dodecahedron\n// 等于四个八面体拼成，也等于三个六棱柱相交，等于四个不同方向的平行四面体\nvec3 cent1214(vec3 p, float sz)\n{// 菱形十二面体中心 20:04 2024-3-8\n        sz = SQ2*.5 / sz;\n        p *= sz;\n        vec3 i=round(p/2.)*2., \n             f=p-i, \n             s=sign(f), \n             a = abs(f), \n             n;\n        n = 1. - step(a,a.yzx)*step(a,a.zxy);\n        if(dot(a,n)>1.)i+=n*s;\n        return i / sz;\n}\n\nfloat dist1214(vec3 p, float sz, int type)\n{ // 菱形十二面体的距离 \n        if(type==0)return length(p);\n        sz= SQ2 *2./sz; // 4倍，省数字\n        p = abs(p) * sz;\n        \n        p= p.z<p.x ? p.zyx : p;\n        p= p.y<p.x ? p.yxz : p;\n        p= p.y<p.z ? p.xzy : p;  \n        \n        //vec3 x = vec3(-1,1,-1) / SQ3,\n        //     y = vec3( 0,1, 1) / SQ2,                      \n        //     z = cross(nx, ny),\n        //     w;      \n        vec3 x = normalize(vec3(-1,1,-1)),\n             y = normalize(vec3( 0,1, 1)),                      \n             z = normalize(vec3( 2,1,-1)),   // = cross(nx, ny);  \n             w;\n        p-=vec3(1,3,1);\n        w.x = abs(dot(p, x))- SQ3; // 线段抠除中间\n        w.y =     dot(p, y);\n        w.z =     dot(p, z);\n        if(type==1)w.x = max(w.x, 0.);\n        if(type==2)w.xz=max(w.xz, 0.);\n        return length(w) / sz;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////\n// 截角八面体 truncated octahedron\n\n//vec3 cent1424(vec3 p, float sz)\n//{\n//        sz = .5  / sz;  // .5 当晶格中心距离为1时，面心距 .5 \n//        p *= sz;\n//        vec3 n=normalize(vec3(1)),\n//             i = round(p),  \n//             f = p - i, \n//             s =sign(f),\n//             a = abs(f);\n//        float d = sqrt(3.)/4.; // 斜面距离 /当小正方形距离 * .5时\n//        if(dot(a, n)>d) i = i + n*s * d * 2.;\n//        return i / sz;\n//}\n\nvec3 cent1424(vec3 p, float sz)\n{// 截角八面体中心 21:16 2024-3-6\n        p *= sz = .5 / sz;\n        vec3 i = round(p),\n             s = sign(p-i),\n             a = abs(p-i);\n        return (a.x+a.y+a.z>.75 ? i+.5*s : i) /sz;\n}\n\n\n\n\nfloat dist1424(vec3 p,float sz, int type) \n{// 截角八面体距离 21:14 2024-3-6  验证  2024-3-7\n        if(type==0)return length(p);\n        sz = 2. / sz;\n        p *= sz;\n        //float g5 = SQ2 /2.;\n        vec3 nx = normalize(vec3(1,0,-1)), \n             nz = normalize(vec3(-1,2,-1)), \n             ny;ny += 1./SQ3;  // normalize(vec3(1))\n        vec3 w,\n             m=normalize(ny - vec3(0,1,0));\n        // 折成一角\n        p=abs(p);\n        if(p.x<p.z)p=p.zyx;\n        if(p.y<p.z)p=p.xzy;\n        if(p.y<p.x)p=p.yxz;\n        // 减顶点\n        p -= vec3(1, 2, 0);\n        // 分别折角和折面，这里不分先后\n        if(dot(p, nz.yxx)>0.) p=reflect(p, nz.yxx); \n        if(dot(p, m)<0.)p=reflect(p, m);\n        \n        w = vec3(dot(p,nx), dot(p,ny), dot(p,nz));\n        if(type==1)w.x= max(w.x, 0.);\n        if(type==2)w.xz=max(w.xz,0.);\n        return length(w) / sz;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Common","description":"","type":"common"}]}