{"ver":"0.1","info":{"id":"MtKGWD","date":"1474767583","viewed":154,"name":"hex trigonometry","username":"ollj","description":"trying to make constants for this tiny hex function more precise\nshown to be not really worth it as they already are VERY precise.\n\nshowing that trigonometry often just is the slower and less precise approach than unions of simpler shapes.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["circle","rotate","hexagon","rotation","hex","scale","trigonometry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rainbowSeizure\n//rainbowSeizure shows underlining geometry.\n\n//in conclusion: trigonometry functions like sin()\n//quickly accumulate larger rounding errors than\n//the precision that you could get from\n//using them to calculate more precise constants for skewed gradients.\n//and this only gets worse for mobile hardware that rounds sin() even more.\n\n//skewing (rotated) gradients for distance functions\n//easily is more precise than inverse square roots or asin()\n\n//this is all about the constants of this hex function.\nconst float tau=asin(1.)*4.,\n    c1=0.57735,//0.57735\n    c2=1.1547;//1.1547\n//return distance of p to border of hexagon with inner radius r.\nfloat hexBase(const in vec2 p,const in float r){vec2 q=abs(p);\n return max(q.x,max(q.x+q.y*c1,q.y*c2))-r;}\n//i was curious if i could \n//trigonometrically calculate them to higher precision.\n//but i gave up, realizing tha they already are VERY precise\n//for pretty much all purposes of signed distance functions.\n//they are more precise than the accumulative\n//precision loss of a few sin() mod() (1/x*x) (1+1/x) functions.\n//showing that hexBase() is not only tiny \n//but also bestPerformance and PreciseEnough\n//unless you want some subpixel precision for antialiasing\n//which i do not care for.\n\n//hex()==hexBase() but with 2 more components\nvec3 hex(const in vec2 p,const in float r){vec2 q=abs(p);\n vec3 s=vec3(0.);//return value.                    \n s.x=q.x+q.y*c1;\n s.y=    q.y*c2;   \n s.z=max(q.x,max(q.x+q.y*c1,q.y*c2))-r;\n return s;}\n//for optional visualization of what shapes are defined by the constants.\n//via \"#rainbowSeizure\"\n\n//return 2d rotation matrix r=2.*pi->full rotation;\nmat2 r2(float r){float s=sin(r),c=cos(r);return mat2(c,s,-s,c);}\n#define oz vec3(1,0,-1)\n//shorter faster (less precise) variant of r2();\n#define r2s(r) mat2(sin(r+oz.xyyz*asin(1.)))\n//for single rotations only !!!\n//as it rotates by mirroring along half-rotation.\n//and that mirror symmetry cancels out all accumulativeEven rotations \n//(similar to how 2 quaternion rotations of an inaginary vector cancel out the real part)\n\n#define ssb(a,b,c) smoothstep(a-b,a+b,c)\n\nvoid mainImage(out vec4 r,in vec2 f){\n vec2 p=f.xy/iResolution.xy;//scale frame to screen resolution.\n p-=vec2(.5);//move frame so that p=vec2(0,0)=frame.center\n p.x/=iResolution.y/iResolution.x;//scale frame.x to aspect ratio\n p*=2.;//scale frame\n p*=r2s(tau/6.);//rotate frame by fullRotation/6;\n float blur=sin(iTime)*.5+.52;//vary blur ovrer time\n vec3 h=hex(p,1.);\n h=mod(h*2./blur,2.);//blur also sets some scaling.\n    //mod(x.2.)makes the image brighter, i want to see the circles\n //r.rgb=ssb(.5,blur,h);\n r.rgb=vec3(ssb(.5,blur,h.z))*.8+.2;\n#ifdef rainbowSeizure\n r.rg*=h.rg;//optional\n#endif\n //\n //draw 6 circles to measure the corners of the hexagon.\n vec2 d=vec2(1.,.0);//circle.center , gets rotated.\n #define tru g=length(p-d);if(mod(g,1.)<.005 \n float tru)r.r-=.5+.2;//1 blue circle\n for(int i=0;i<6;i++){\n  d*=r2(tau/6.);tru)r.g-=.5+.2;//rotate redraw.\n}}","name":"Image","description":"","type":"image"}]}