{"ver":"0.1","info":{"id":"msf3W4","date":"1666382564","viewed":85,"name":"GPS display","username":"jorges119","description":"Very basic test for GPS display","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf","compass","gps"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ROWS 16.\n#define COLS 16.\n#define latitude 51783375.\n#define longitude 4783329.\n#define distance 52123.\n\nprecision highp float;\n    \nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nmat2 rotate2D(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat2(c, -s, s, c);\n}\n\nfloat linearstep(float edge0, float edge1, float x)\n{\n    return  clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n}\n\nvec2 scale(float size, vec2 p)\n{\n    return  vec2(\n        clamp((p.x + size/2.) / size, 0.0, 1.0) - 0.5,\n        clamp((p.y + size/2.) / size, 0.0, 1.0) - 0.5\n    );\n}\n\nfloat glyph(vec2 p, int index, bool rotate) {\n    mat2 r = rotate2D(-iTime);\n    vec2 coords = rotate ? p * r + 0.5 : p + 0.5;\n\tfloat xOffset = (mod(float(index),COLS) / COLS) - 0.5 + 0.001;\n\tfloat yOffset = (floor(float(index) / ROWS) / ROWS) - 0.5 + 0.001;\n\treturn -texture(iChannel0, vec2(xOffset + coords.x / (COLS + 0.0), yOffset + coords.y / (ROWS + 1.0))).r;\n}\n\nfloat numberToGlyph(float number, int numDigits, int point, vec2 coords, int symbol, float size){\n\tfloat nDigits = 0.0;\n\twhile (number > pow(10.0, nDigits) && nDigits < float(numDigits)){\n\t\tnDigits+=1.0;\n\t}\n    float spacing = size * (0.036/0.08);\n    float offset = (nDigits + 1.) * spacing / 2.;\n    float result = glyph(scale(size*1.05, (coords - vec2(offset,0.))), symbol, false);\n\tfor (float i = 0.0; i < nDigits; i++){\n\t\tfloat factor = pow(10.0, i + 1.0);\n\t\tint cifer = int(floor(10.0 * fract(number/factor)));\n\t\tint digit;\n\n\t\t// There seems to be some bug/conceptual problem with switch case and it does not work\n\t\t// when the value is passed with a uniform;\n\t\tif (cifer == 0) digit = 72;\n\t\telse if (cifer == 1) digit = 73;\n\t\telse if (cifer == 2) digit = 74;\n\t\telse if (cifer == 3) digit = 75;\n\t\telse if (cifer == 4) digit = 76; \n\t\telse if (cifer == 5) digit = 77;\n\t\telse if (cifer == 6) digit = 78;\n\t\telse if (cifer == 7) digit = 79;\n\t\telse if (cifer == 8) digit = 64;\n\t\telse if (cifer == 9) digit = 65;\n\t\telse digit = 7;\n        \n        float extra = (i + 1. > float(point))? spacing : 0.01;\n        result = min(result,\n                      glyph(scale(size, (coords - vec2(offset,0.)) + vec2(spacing * (i+1.) + extra,0.)), digit, false)\n        );\n        if (int(i + 1.) == point){\n            result = min(result,\n                         glyph(scale(size, (coords - vec2(offset,0.)) + vec2(spacing * (i+1.) + spacing/0.8,0.)), (symbol == 21?86:200), false)\n            );\n        }\n\t}\n\treturn result;\n}\n\nfloat compass(vec2 p, float angle) {\n\tfloat outer = length(p) - 0.45;\n    float inner = length(p) - 0.43;\n    float gap = 0.04;\n    vec2 dist = abs(p) - gap/2.;\n    float col = step(gap, min(dist.x, dist.y)); \n    float north = glyph(scale(0.12, p - vec2(0.,0.44)), 54, true);\n    float south = glyph(scale(0.12, p - vec2(0.,-0.44)), 43, true);\n    float east = glyph(scale(0.12, p - vec2(0.44,0.)), 61, true);\n    float west = glyph(scale(0.12, p - vec2(-0.44,0.)), 47, true);\n\n    return min(min(\n                min(\n                max(max(outer, -inner), -col), \n                north),\n                south),\n           min(east,west));\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy);\n    float ratio = (iResolution.y/iResolution.x) / 2.0;\n    float x = linearstep(0.5-ratio, 0.5+ratio, uv.x); \n    vec2 coord = vec2(x,uv.y) - 0.5;\n\n\n\tvec3 bkg = vec3(0.12941176470588237);\n\tvec3 seg = vec3(0.7450980392156863);\n    vec3 arrow = vec3(0.00392156862745098, 0.592156862745098, 0.8313725490196079);\n    float sdf= step(0., compass(coord * rotate2D(iTime), 0.));\n    float indicator = step(0.,sdTriangleIsosceles(scale(-0.3,coord-vec2(0.,0.4)), vec2(0.1,0.5)));\n    float lat = step(0., numberToGlyph(latitude + iTime, 8, 6, coord + vec2(0.,-0.05),54, 0.09));\n    float lon = step(0., numberToGlyph(longitude + iTime, 8, 6, coord + vec2(0.,0.05),61,0.09));\n    float dist = step(0., numberToGlyph(distance + iTime, 5, 2, coord + vec2(0.,0.15),21,0.15));\n\n    vec3 color = mix(seg, bkg, min(sdf,min(min(lat,lon),dist)));\n    color = mix( arrow, color, indicator);\n   \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}