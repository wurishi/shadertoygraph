{"ver":"0.1","info":{"id":"cs3BDM","date":"1697319894","viewed":201,"name":"2D Splat vs 3D Gaussian","username":"chronos","description":"Fork of my previous shader with added comparison with ray marched volumetric version and slightly corrected math.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["3d","volume","box","gaussian","viewer","splats","splatting","ewa"],"hasliked":0,"parentid":"csGcDd","parentname":"3D Gaussian Splatting"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nThis is a fork of my previous shader, where I compare the splats with a \nnumerically integrated volumetric 3D gaussian function.\n\nsplat on the left, volumetric version on the right\n\nwent over the math some more and tried to make sure\nthat it behaved correctly wrt focal length and translations.\n\nStill haven't optimized anything :)\n\n\n\nFrom forked shader:\n\nBased on \"EWA Volume Splatting\" paper   (EWA = Elliptical Weighted Average)\nby Matthias Zwicker, Hanspeter Pfister, Jeroen van Baar and Markus Gross\nhttps://cgl.ethz.ch/Downloads/Publications/Papers/2001/p_Zwi01b.pdf\n\nNote: seems like this is a bit newer version(2002):\nhttps://www.cs.umd.edu/~zwicker/publications/EWASplatting-TVCG02.pdf\n\nI opted to implement this straightforwardly and directly from the paper,\nas a consequence there's a lot of wasteful computation being performed.\nParticularly because most operations uses matrix multiplication where not necessary.\nEven so they could be rearranged in a more efficient manner.\n\nFor example:\nFor rotations, inverse(R) = traspose(R), and det(R) = det(inv(R)) = 1\nScaling can be performed by vector multiplication, since they are diagonal matrices here.\nmatrices that are repeated, like in: u = v^T *M^T * M * v can instead be computed as \nw = M * v; u = dot(w, w)\netc...\n\n// Notation from paper:\n\nt_k = is the center of a Gaussian in camera space \nu = phi(t) = Wt + d = viewing transformation ( for matrix W and translation vector d)\nu_k = phi(t_k) = center of gaussian in object space\n\nm(u) = perspective transform ( z division )\nx_k = m(u_k) = center of gaussian in ray space ( screenspace + depth, after projection)\nx_hat = screenspace coordinates\nx_hat_k = gaussian center in screenspace\n\nThis method is used for rendering 3D Gaussians in the paper\n\"3D Gaussian Splatting for Real-Time Radiance Field Rendering\"\nhttps://repo-sam.inria.fr/fungraph/3d-gaussian-splatting/3d_gaussian_splatting_high.pdf\n\n*/\n\n// Jacobian for linear approximation of perspective transform (z-divide)\n// Derived by taking the partial derivatives of the perspective divide function\n// with respect to the components of the gaussian center in camera space.\n// Note that the perspective divide here is different from the one in the paper\n// because I divide by w = -z instead of z.\nmat3 Jacobian(vec3 t_k, vec2 focal_xy)\n{\n    vec3 last_row = t_k / length(t_k);\n    \n    mat3 J = mat3\n    (\n        -focal_xy.x/t_k.z, 0.,                                           last_row.x,\n        0., -focal_xy.y/t_k.z,                                           last_row.y,\n        (focal_xy.x * t_k.x)/(t_k.z*t_k.z), (focal_xy.y * t_k.y)/(t_k.z*t_k.z), last_row.z\n    );\n    \n    return J;\n}\n\n// Based on formula from wikipedia :)\nmat3 RotationMatrix(vec3 axis, float angle)\n{\n    float c = cos(angle), s = sin(angle);\n    return\n        mat3(c) + \n        s * mat3(0, axis.z, -axis.y, -axis.z, 0, axis.x, axis.y, -axis.x, 0) + \n        (1.-c) * outerProduct(axis, axis);\n}\n\nfloat gaussian(mat3 V, vec3 x) // 3D gaussian\n{\n    return exp(-.5 * dot(x, inverse(V)*x)) / sqrt(pow(2. * PI,3.) * (determinant(V)));\n}\n\nfloat gaussian(mat2 V, vec2 x) // 2D gaussian\n{\n    return exp(-.5 * dot(x, inverse(V)*x)) / sqrt(pow(2. * PI,2.) * (determinant(V)));\n}\n\n// Computes eq 21:\n//\n//     G_V_hat_k(x_hat - x_hat_k) / (det(inv(J)) * det(inv(W))\n//\n// But starting from gaussian center in cameraspace\n//\nfloat gaussianSplat(vec3 u_k, vec3 scale, mat3 R, vec2 x_hat, vec2 focal_xy, vec3 Camera_Position)\n{\n    // Camera rotation\n    mat3 W = transpose(R);\n    float invDetW = determinant(inverse(W)); // For rotation matrices, the inverse is the transpose and the determinant is 1\n\n    // Compute camera space center t_k from world space center u_k\n    vec3 d = - Camera_Position;\n    vec3 t_k = W * u_k + d;       // psi\n\n    // In the paper, u.z is positive in the forward direction in camera space\n    //t_k.z *= -1.;\n    \n    mat3 J = Jacobian(t_k, focal_xy);\n    float invDetJ = determinant(inverse(J));\n    \n    // Compute ray space center of gaussian (eq 15 and 17)\n    // x_k = phi(t_k)\n    vec3 x_k = vec3((t_k.x * focal_xy.x)/-t_k.z, (focal_xy.y * t_k.y)/-t_k.z, length(t_k));\n    \n    // Compute linear approximation to perspective transform  (eq 18)\n    vec2 x = x_hat.xy - x_k.xy;\n    \n    // Compute 3D variace matrix\n    mat3 S = mat3(scale.x,0,0, 0,scale.y,0, 0,0,scale.z);\n    mat3 V_dprime_k = S*transpose(S) + 1.*mat3(.3/iResolution.y);\n    mat3 V_prime_k = W * V_dprime_k * transpose(W);\n    mat3 V_k = J * V_prime_k * transpose(J);\n    \n    mat2 V_hat_k = mat2(V_k[0].xy, V_k[1].xy);        // 3D to 2D integration for gaussians\n    \n    //V_hat_k += mat2(.06/iResolution.y);\n    \n    return gaussian(V_hat_k, x) / abs(invDetJ * invDetW);\n}\n\nfloat gaussianVolumetric(vec3 t_k, vec3 scale, mat3 R, vec3 x)\n{\n    // Camera rotation\n    mat3 W = transpose(R);\n    float invDetW = determinant(inverse(W)); // For rotation matrices, the inverse is the transpose and the determinant is 1\n    \n    x = x - t_k;\n    \n    // Compute 3D variace matrix\n    mat3 S = mat3(scale.x,0,0, 0,scale.y,0, 0,0,scale.z);\n    mat3 V_dprime_k = S*transpose(S);\n    mat3 V_prime_k = V_dprime_k;\n    \n    return gaussian(V_prime_k, x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * .75; // Just a convenient way to scale time\n\n    vec2 uv = (2. * fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2. * iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    // Idle mouse animation\n    if(length(iMouse.xy) < 10.)\n    {\n        mouse = vec2(cos(time), sin(time));\n    }\n    \n    float pix_size = 2. / iResolution.y; // Unused atm\n    \n    float focal = 1.; // TODO: Change perspective transform and u_k to allow focal != 1.\n\n    vec2 focal_xy = vec2(focal);\n\n    vec3 Camera_Position = vec3(0, 0, 6.);\n    vec3 rd = normalize(vec3(uv, -focal));\n    \n    mat3 Tilt = RotationMatrix(vec3(1,0,0), \n     //mouse.y *\n     -0.5\n    );\n    \n    float angle = 0.;\n\n    vec3 color = vec3(0);\n\n    vec3 box_center = vec3(cos(iTime)*4., 0, -1.+4.*sin(iTime)); // t_k\n    float radius = 1.0;\n\n    vec3 axis = normalize(vec3(0,1,0));\n    mat3 Camera_Rotation = RotationMatrix(axis, angle) * Tilt;\n\n    vec3 ro = Camera_Rotation * Camera_Position; // ray origin world space\n    \n    // Ray tracing box & splatting gaussian\n    {\n        vec2 T = RayBox(ro, Camera_Rotation * rd, box_center, vec3(radius));\n\n        // Parameters for ray entering and ray exiting box for volumetric calculations.\n        float t_enter = min(T.x, T.y);\n        float t_exit = max(T.x, T.y);\n        float t = T.x;\n        if(T.t >= 0. && (T.y < T.x)) t = T.y;\n\n        vec3 gaussian_center = box_center; //vec3(0,0,0); // t_k\n        //vec3 gaussian_scale = vec3(0.4, 0.1, 0.2);\n        \n        vec3 gaussian_scale = vec3(0.2, 0.05, 0.2);\n\n        // Draw box\n        if(t > 0.)\n        {\n            vec3 p = Camera_Rotation*rd * t + ro;\n            vec3 pos_color = (normalize(p - box_center) + 1.) / 2.;\n            float opacity = 0.9;\n            color += exp(-2.5*(T.y - T.x)) * opacity * pos_color;\n            \n            if(mouse.x < uv.x)\n            {\n                float density = 0.; // 1.; // Alternate\n                float opacity = 1.;\n                float stepsize = 0.0001;\n                \n                for(t = t_enter; t <= t_exit; t+=stepsize)\n                {\n                    vec3 mean = gaussian_center;\n                    vec3 scale = gaussian_scale;\n                    vec3 axis = normalize(vec3(0,1,0));\n                    float angle = 0.;//*iTime;\n\n                    p = Camera_Rotation * rd * t + ro;\n                    float g = gaussianVolumetric(mean, scale, Camera_Rotation, p);\n\n                    density += g * stepsize;\n                }\n                color += density; //vec3(1.-exp(-density));\n                \n            }\n        }\n        \n        \n        // Convert world space center (t_k) to cameraspace center (u_k)\n        //mat3 W = transpose(Camera_Rotation);\n        //vec3 d = - Camera_Position;\n        //vec3 u_k = W * gaussian_center + d;\n        \n        vec3 u_k = gaussian_center;\n        \n        // Splat the gaussian!\n        if(mouse.x > uv.x)\n        {\n            color += gaussianSplat(u_k, gaussian_scale, Camera_Rotation, uv, focal_xy, Camera_Position);\n        }\n            \n            \n        // Draw center of gaussian as green dot    \n        T = RaySphere(ro, Camera_Rotation * rd, gaussian_center, 0.05);\n        if(T.x > 0.)\n        {\n            color = vec3(0,1,0);\n        }\n        \n        // Draw center of box as blue dot\n        T = RaySphere(ro, Camera_Rotation * rd, box_center, 0.025);\n        if(T.x > 0.)\n        {\n            color = vec3(1,0,0);\n        }\n    }\n    \n    color = tanh(color);\n    \n    // vertical separator line\n    if(uv.y > 0.5 || uv.y < -0.5)\n        color = mix(color, vec3(1), smoothstep(pix_size * 2., pix_size * 1., abs(mouse.x - uv.x)));\n    \n    color = sRGBencode(color);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265;\n\nfloat sRGBencode(float C_linear)\n{\n    return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear);\n}\n\nvec3 sRGBencode(vec3 C_linear)\n{\n    return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z));\n}\n\nfloat sRGBdecode(float C_sRGB)\n{\n    return C_sRGB > 0.04045 ? (pow((C_sRGB + 0.055)/1.055, 2.4) ) : (C_sRGB / 12.92);\n}\n\nvec3 sRGBdecode(vec3 C_sRGB)\n{\n    return vec3(sRGBdecode(C_sRGB.x), sRGBdecode(C_sRGB.y), sRGBdecode(C_sRGB.z));\n}\n\nvec3 rot(vec3 p, vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    \n    // Project p onto axis:\n    vec3 proj = dot(axis, p) * axis;\n    \n    // Reject p from axis:\n    vec3 rjct = p - proj;\n    \n    // Construct helper axes ( such that cross(a, b) = axis ):\n    // Constructing the axes un-normalized allows up to skip multiplication by length(rjct) later\n    vec3 a = /*normalize*/(rjct);\n    vec3 b = cross(axis, a);\n    \n    vec3 result = // length(rjct) *\n        (cos(angle) * a + sin(angle) * b) + proj;\n    \n    return result;\n}\n\n\nvec3 quadratic_formula(float a, float b, float c)\n{\n    // 0 = b * x + c\n    // x = (0 - c) / b\n\n    if( a == 0.) return vec3(-c / b, 0, 0);\n\n    float discriminant = b * b - 4. * a * c;\n\n    float disc = sqrt(abs(discriminant));\n\n    vec3 result = \n        vec3(\n            (-b + disc) / (2. * a),\n            (-b - disc) / (2. * a),\n            float(discriminant > 0.)\n        );\n\n    return result;\n}\n\nvec2 RaySphere(vec3 ro, vec3 rd, vec3 center, float radius)\n{\n    // o = ro - center\n    // p = o + rd * t\n    // dot(p, p) = r * r\n    // dot(o + rd * t, o + rd * t) = r * r\n    // dot(o,o) - r * r + 2. * t * dot(o, rd) + t * t * dot(rd, rd) = 0\n    \n    vec3 o = ro - center;\n    \n    float a = dot(rd, rd);\n    float b = 2. * dot(o, rd);\n    float c = dot(o, o) - radius * radius;\n    \n    float discriminant = b * b - 4. * a * c;\n    \n    if(discriminant < 0.)\n        return vec2(-1);\n    \n    float t1 = .5 * (sqrt(abs(discriminant)) - b) / a;\n    float t2 = .5 * (-sqrt(abs(discriminant)) - b) / a;\n    \n    float t_min = min(t1, t2);\n    float t_max = max(t1, t2);\n    \n    return vec2(t_min, t_max);\n}\n\nfloat RayPlane(vec3 ro, vec3 rd, vec3 center, vec3 normal)\n{\n    // dot(ro - center, normal) + t * dot(rd, normal) = 0.\n    return -dot(ro - center, normal) / dot(rd, normal);\n}\n\nvec2 RayBox(vec3 ro, vec3 rd, vec3 center, vec3 halfextents)\n{\n    vec3 t1, t2;\n    \n    // X planes\n    vec3 N = vec3(1, 0, 0);\n    t1.x = RayPlane(ro, rd, center + N * halfextents.x,  N);\n    t2.x = RayPlane(ro, rd, center - N * halfextents.x, -N);\n    \n    // Y planes\n    N = vec3(0, 1, 0);\n    t1.y = RayPlane(ro, rd, center + N * halfextents.y,  N);\n    t2.y = RayPlane(ro, rd, center - N * halfextents.y, -N);\n    \n    // Z planes\n    N = vec3(0, 0, 1);\n    t1.z = RayPlane(ro, rd, center + N * halfextents.z,  N);\n    t2.z = RayPlane(ro, rd, center - N * halfextents.z, -N);\n\n    float t_min = -1.;\n    float t_max = -1.;\n    vec3 p = vec3(0);\n    float pmax = 9e9;\n    \n    vec3 o = (ro - center);\n    \n    const float eps = 1e-3;\n    \n    for(int i = 0; i < 3; i++)\n    {\n        p = abs(t1[i] * rd + o);\n        pmax = max(p.x-halfextents.x, max(p.y-halfextents.y, p.z-halfextents.z));\n        if(((t1[i] < t_min) || t_min < 0.) && pmax <= eps) { t_min = t1[i]; }\n        if(((t1[i] > t_max) || t_max < 0.) && pmax <= eps) { t_max = t1[i]; }\n   \n        p = abs(t2[i] * rd + o);\n        pmax = max(p.x-halfextents.x, max(p.y-halfextents.y, p.z-halfextents.z));\n        if(((t2[i] < t_min) || t_min < 0.) && pmax <= eps) { t_min = t2[i]; }\n        if(((t2[i] > t_max) || t_max < 0.) && pmax <= eps) { t_max = t2[i]; }\n    }\n\n    return vec2(t_min, t_max);\n}\n\nfloat BoxDist(vec3 p, vec3 center, vec3 halfextents)\n{\n    vec3 o = abs(p - center) - halfextents;\n    \n    float d = min(max(o.x, max(o.y, o.z)), 0.);\n    \n    return length(length(max(o, 0.))) + d;\n}\n\nfloat SphereDist(vec3 p, vec3 center, float radius)\n{\n    return length(p - center) - radius;\n}\n\nfloat gaussian3D(vec3 mean, vec3 scale, vec3 axis, float angle, vec3 p)\n{\n    vec3 v = scale * rot(p - mean, axis, angle);\n    return exp(-dot(v, v));\n}","name":"Common","description":"","type":"common"}]}