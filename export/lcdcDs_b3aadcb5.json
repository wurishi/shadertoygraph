{"ver":"0.1","info":{"id":"lcdcDs","date":"1731380321","viewed":59,"name":"PC98 Color loading","username":"skymen","description":"A PC98 Shader that aims to replicate this effect:\nhttps://www.youtube.com/watch?v=KYzC4TW08qs&t=574s","likes":2,"published":3,"flags":0,"usePreview":1,"tags":["palette","pc98"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Define colors as individual variables in order of increasing luminance\nvec3 color0 = vec3(0.1098, 0.0314, 0.0627); // Darkest\nvec3 color1 = vec3(0.3333, 0.0627, 0.0314);\nvec3 color2 = vec3(0.4902, 0.0941, 0.0941);\nvec3 color3 = vec3(0.4431, 0.2039, 0.0627);\nvec3 color4 = vec3(0.3961, 0.4431, 0.3137);\nvec3 color5 = vec3(0.6824, 0.2980, 0.1882);\nvec3 color6 = vec3(0.7137, 0.0627, 0.1882);\nvec3 color7 = vec3(0.7922, 0.4431, 0.2353);\nvec3 color8 = vec3(0.4431, 0.5843, 0.5529);\nvec3 color9 = vec3(0.8549, 0.6471, 0.4275);\nvec3 color10 = vec3(0.9176, 0.8392, 0.6667);\nvec3 color11 = vec3(0.6471, 0.7294, 0.6824);\nvec3 color12 = vec3(0.8863, 0.2510, 0.3137);\nvec3 color13 = vec3(0.9333, 0.4431, 0.4588);\nvec3 color14 = vec3(0.9647, 0.6157, 0.6157);\nvec3 color15 = vec3(1.0000, 1.0000, 0.9490); // Lightest\n\n// Define the color palette array with ordered colors\nvec3 getColor(int index) {\n    if (index == 0) return color0;\n    if (index == 1) return color1;\n    if (index == 2) return color2;\n    if (index == 3) return color3;\n    if (index == 4) return color4;\n    if (index == 5) return color5;\n    if (index == 6) return color6;\n    if (index == 7) return color7;\n    if (index == 8) return color8;\n    if (index == 9) return color9;\n    if (index == 10) return color10;\n    if (index == 11) return color11;\n    if (index == 12) return color12;\n    if (index == 13) return color13;\n    if (index == 14) return color14;\n    return color15;\n}\n\n// Function to find the nearest color index\nint findNearestColorIndex(vec3 color) {\n    float minDist = distance(color, getColor(0));\n    int nearestIndex = 0;\n    for (int i = 1; i < 16; i++) {\n        float dist = distance(color, getColor(i));\n        if (dist < minDist) {\n            minDist = dist;\n            nearestIndex = i;\n        }\n    }\n    return nearestIndex;\n}\n\n// Simple hash function to generate a float from a Y coordinate\nfloat hash(float y) {\n    return fract(sin(y * 12.9898 + 78.233) * 43758.5453);\n}\n\n// Main shader function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Original color based on some input function\n    vec3 col = texture(iChannel0, uv).rgb;\n\n    // Find the nearest color in the palette\n    int nearestIndex = findNearestColorIndex(col);\n\n    // Calculate bias factor based on distance from screen center\n    float yNorm = uv.y * 2.0 - 1.0; // Normalize y to range [-1, 1]\n    float bias = cos(yNorm * 3.141592); // Cosine curve that peaks at the center\n\n    // Generate random shift using the bias, ranging from -16 to -32\n    //float randomShift = mix(-16.0, -32.0, bias) - hash(fragCoord.y) * 8.0;\n    float randomShift = -24.0 - hash(fragCoord.y) * bias * 8.0;\n    randomShift = min(0.0, randomShift + sin(iTime) * 16.0 + 16.0);\n    int shiftedIndex = clamp(nearestIndex + int(randomShift), 0, 15);\n\n    // Set the output color to the shifted palette color\n    fragColor = vec4(getColor(shiftedIndex), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}