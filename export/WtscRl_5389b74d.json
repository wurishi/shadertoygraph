{"ver":"0.1","info":{"id":"WtscRl","date":"1592801535","viewed":74,"name":"Simple Reflect material","username":"antoinefortin","description":"ddd","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["ddd"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/* SDF */\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n\nfloat sdFloorPlane(vec3 pos)\n{\n\treturn pos.y;\n}\n\n// Map here, define SDF here\nfloat map(vec3 pos)\n{\n\tfloat sol = sdFloorPlane(pos);\n    \n    // Bring the sphere higher of the ground\n    pos.y -= 2.5;\n    float sphere1 = sdSphere(pos, 1.);\n    float sphere2 = sdSphere(pos + vec3(5.0, 0., 0.), 2.);\n    \n\n    \n    //return sol;\n    return min(sphere1, sphere2);\n\treturn min(sol, min(sphere1, sphere2));\n}\n\nfloat castRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for(int i = 0; i < 100; i++)\n    {\n    \tvec3 pos = ro + t * rd;\n        \n        float h = map(pos);\n        if(h < 0.001)\n        {\n        \tbreak;\n        }\n        t += h;\n        \n        if(t > 120.0) break;\n        \n    }\n    \n    if(t > 120.0) t = -1.0;\n    \n    return t;\n}\n\n// basic normal.\nvec3 normal(vec3 p) {\n\tvec2 h = vec2(0.001, 0.0);\n\tvec3 n = vec3(\n\t\tmap(p + h.xyy) - map(p - h.xyy),\n\t\tmap(p + h.yxy) - map(p - h.yxy),\n\t\tmap(p + h.yyx) - map(p - h.yyx)\n\t);\n\treturn normalize(n);\n}\n\n\nvec3 calcNormal(vec3 pos)\n{\n    vec2 e = vec2(0.01, 0.0);\n    \n\treturn normalize(vec3(\n        \t\t\t\t\tmap(pos+e.xyy) - map(pos-e.xyy),\n        \t\t\t\t\tmap(pos+e.yxy) - map(pos-e.yxy),\n        \t\t\t\t\tmap(pos+e.yyx) - map(pos-e.yyx)\n    \t\t\t\t));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n    \n        // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord- iResolution.xy) / iResolution.y;\n\t\n\tvec3 ro = vec3(0., 2.0, -5.);\n\tvec3 rd = normalize(vec3(uv.x, uv.y, 1.));  \n\t\n\tvec3 col = vec3(0.25, .15, .2); // Sky color\n\tvec3 lig = normalize(vec3(0., 5.7, -2.6));\n\t\n\t// Rendering part\n\n    for(int i = 0; i < 5; i ++)\n    {\t\n\t\tfloat t = castRay(ro, rd);\t\t\n    \tif(t > 0.0)\n    \t{\n         \tvec3 rcol = vec3(0);\n\t\t\t// geometry, hit position, normal, reflect\n\t\t\tvec3 pos = ro + rd*t;\n\t\t\tvec3 nor = calcNormal(pos);\n\t\t\tvec3 ref = reflect(rd, nor);\n            \n\t\t\t// lighting ambient + diffuse + fresnel + specular\n\t\t\tvec3 ambient = vec3(.05, .2, .1);\n            rcol += ambient;\n            \n            vec3 diffuse = vec3(clamp(dot(lig, nor), 0.0, 1.0));\n            diffuse.r += 0.5;\n            rcol += diffuse;\n            \n            vec3 specular = vec3(1.0*pow(clamp(dot(ref, lig), 0.0, 1.0), 120.0)); \n            rcol += specular;\n\t\t\t\n            \n            \n\t\t\t// set up the ray orgin and direction for reflection.\n\t\t\tro = pos + nor;\n\t\t\trd = ref;\n            \n            // Fog depth\n\t          //rcol = mix(rcol, vec3(.45, 0.8, 1.0), 1.0 - exp(-0.1*t));\n            \n    \t\tcol = rcol;\n    \t}\n    \n    }\n\n\t\t\n\tfragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}