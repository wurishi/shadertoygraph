{"ver":"0.1","info":{"id":"wdBXRt","date":"1554794327","viewed":752,"name":"disk/square mapping","username":"morimea","description":"Click on any to zoom\n[b]Top: square to circle[/b]\n[b]Bot: circle to square[/b]\nBufA/B is just textures\n\nsaw on [url]https://twitter.com/marc_b_reynolds/status/1114995504142868480[/url]\n\nOnly copy of code to GLSL...nothing more.","likes":20,"published":1,"flags":32,"usePreview":0,"tags":["2d","mapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//WARNING this is \"copy-paste to GLSL\" original source code linked\n\n// https://squircular.blogspot.com/\n\n\n#define sgn(xx)(xx==0.0?0.0:(xx < 0.?-1.0:1.0))\n#define ep 0.0001\n\n// https://squircular.blogspot.com/2015/09/elliptical-arc-mapping.html\n\n// replaced by iq https://www.shadertoy.com/view/3dsSWs\nfloat maxcomp( in vec2 v ) { return max(v.x,v.y); }\nvec2 sstd( in vec2 v )\n{\n    return maxcomp(abs(v))*normalize(v);\n}\n\nvec2 sdts(vec2 v) {\n    if ((abs(v.x) < ep) || (abs(v.y) < ep))return v;\n    return v*length(v)/maxcomp(abs(v));\n}\n\n// https://squircular.blogspot.com/2015/09/fg-squircle-mapping.html\n\nvec2 fstd(vec2 p) {\n    vec2 xy = p*p;\n    float r2 = xy.x + xy.y;\n    if (r2 < ep)return p;\n    return p * sqrt(r2 - xy.x * xy.y) * (1.0 / sqrt(r2));\n}\n\nvec2 fdts(vec2 p) {\n    //if ((abs(p.x) < ep) || (abs(p.y) < ep))return p; //if you need fix \"small bugs on middle of texture\"\n    vec2 uv = p*p;\n    float r2 = uv.x + uv.y;\n    float u = p.x * p.y;\n    float f = 4.0 * u * u;\n    float s = 1.;\n    if (r2 * (r2 - f) > 0.) s = sqrt(0.5 * (r2 - sqrt(r2 * (r2 - f)))); //or abs in second sqrt\n    return vec2((abs(p.y) > ep) ? sgn(u) / p.y * s : p.x, (abs(p.x) > ep) ? sgn(u) / p.x * s : p.y);\n}\n\n// https://squircular.blogspot.com/2015/09/mapping-circle-to-square.html\n\nvec2 estd(vec2 p) {\n    return p* sqrt(1. - .5 * (p.yx*p.yx));\n}\n\nvec2 edts(vec2 p) {\n    vec2 uv = p*p;\n    float t = 2.0 * sqrt(2.0);\n    vec2 s = vec2(2.0 + uv.x - uv.y, 2.0 - uv.x + uv.y);\n    vec2 t1 = s + p * t;\n    vec2 t2 = s - p * t;\n    //t1=abs(t1);t2=abs(t2); //or this\n    if (any(lessThan(vec4(t1, t2), vec4(0.))))return 0.5 * (t1) - 0.5 * (t2);\n    return 0.5 * sqrt(t1) - 0.5 * sqrt(t2);\n}\n\nfloat red_line(vec2 p, int id) {\n    float d = 0.;\n    if (id < 3)d = max(step(abs(abs(p.x) - 0.5), .015), step(abs(p.x), .5) * step(abs(abs(p.y) - 0.5), .015));\n    else d = step(abs(length(p) - 0.5), .015);\n    return d;\n}\n\nvec3 draw_texture(vec2 p, int id) {\n\n    vec2 po = p * 2.; // screen size +-0.5 this why method(po*2.)/2.\n\n    //method for tile\n    switch (id) {\n        case 0:po = sstd(po);break;\n        case 3:po = sdts(po);break;\n        case 1:po = fstd(po);break;\n        case 4:po = fdts(po);break;\n        case 2:po = estd(po);break;\n        case 5:po = edts(po);break;\n    }\n    po *= 0.5;\n\n    //anim\n    float at=0.;\n    if (iMouse.z < 0.5){\n        at = smoothstep(20., 18., mod(iTime + 12. + float(id), 20.)) *\n            smoothstep(4., 6., mod(iTime + 12. + float(id), 20.));\n        po = mix(p, po, at);\n    }\n    //po=mix(p,po,iMouse.x/iResolution.x);\n\n    //borders to cut\n    float d = 0.;\n    if (id < 3)d = step(length(po), .5);\n    else d = step(abs(po.x), .5) * step(abs(po.y), .5);\n\n    //coord to texture\n    vec2 res = (iResolution.xy / iResolution.y);\n    po = vec2(po.x / res.x, po.y) + 0.5;\n\n    vec3 retc = vec3(0.);\n    if (id < 3) retc = texture(iChannel1, po).rgb;\n    else retc = texture(iChannel0, po).rgb;\n    \n    //texture fade animation\n    float at2 = smoothstep(13., 10., mod(iTime + 5., 15.)) *\n            smoothstep(3., 6., mod(iTime + 5., 15.));\n    vec4 tc = texture(iChannel2, po);\n    retc = mix(retc, tc.rgb, min(at,max(tc.a + at2-0.6*(at),0.)));\n    \n    retc *= d; //cut, comment if need\n\n    d = red_line(p, id); //red line\n\n    return retc * (1. - d * 0.25) + vec3(.75, 0., 0.) * d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 res = (iResolution.xy / iResolution.y);\n    vec2 uv = (fragCoord.xy) / iResolution.y;\n    float id = 0.;\n    if (iMouse.z > 0.5) {\n        uv += -res / 2.0;\n        vec2 im = iMouse.xy / iResolution.xy;\n        id = floor(im.x * 3.) + floor(im.y * 2.)*3.;\n    } else {\n        id = floor(uv.x / res.x * 3.) + floor(uv.y * 2.)*3.;\n        uv = mod(uv, vec2(res.x / 3., 0.5))*2. - vec2((res.x / 3.), 0.5); //tiles\n    }\n    fragColor = vec4(draw_texture(uv, int(id)), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//square grid from https://www.shadertoy.com/view/XtlyWH\n\n// Fork of https://www.shadertoy.com/view/XllyD8\n\n#define SCALE 2.  // Global scale!\n#define FSAA 4.  // Fullscreen antialiasing!\n\n#define GRID_SCALE0_FREQ .25\n#define GRID_SCALE1_FREQ 1.\n#define GRID_SCALE2_FREQ 4.\n\n#define MAX_GRID_SCALE0_SCALE (32. * GRID_SCALE0_FREQ)\n#define MAX_GRID_SCALE1_SCALE (32. * GRID_SCALE1_FREQ)\n#define MAX_GRID_SCALE2_SCALE (32. * GRID_SCALE2_FREQ)\n\n#define RGB_LIGHT vec3(.96)\n#define RGB_DARK  vec3(.04)\n#define RGB_GRAY  vec3(.7)\n#define RGB_X  vec3(.0, .5, 1.)\n#define RGB_Y  vec3(.0, .5, 0.)\n\n// I wonder if there's a shorter way to write this...\nvec2 df_op_repeat(vec2 point, vec2 frequency){\n    vec2 half_frequency = .5 * frequency;\n    return mod(point - half_frequency, frequency) - half_frequency;\n    //return frequency * (fract(point / frequency - .5) - .5);  // By ollj!\n}\n\nvec3 rgb_grid(vec2 uv, float aa){\n    //uv.y += sin(uv.x + iTime);\n\n    // This is the manual part. Instead of manually adding each scale (either unrolled or by looping through each scale),\n    // perhaps there's a way do write a function that does this *without* loops!\n    vec2 grid_scale0 = abs(df_op_repeat(uv, vec2(GRID_SCALE0_FREQ)));\n    vec2 grid_scale1 = abs(df_op_repeat(uv, vec2(GRID_SCALE1_FREQ)));\n    vec2 grid_scale2 = abs(df_op_repeat(uv, vec2(GRID_SCALE2_FREQ)));\n\n    // This is the manual part. Instead of manually adding each scale (either unrolled or by looping through each scale),\n    // perhaps there's a way do write a function that does this *without* loops!\n    vec3 rgb = RGB_LIGHT;  // Background color!\n    rgb = mix(rgb, RGB_GRAY, smoothstep(aa, .0, min(grid_scale0.x, grid_scale0.y)) * float(SCALE < MAX_GRID_SCALE0_SCALE));\n    rgb = mix(rgb, RGB_X, smoothstep(aa, .0, grid_scale1.x) * float(SCALE < MAX_GRID_SCALE1_SCALE));\n    rgb = mix(rgb, RGB_Y, smoothstep(aa, .0, grid_scale1.y) * float(SCALE < MAX_GRID_SCALE1_SCALE));\n    rgb = mix(rgb, RGB_DARK, smoothstep(aa, .0, min(grid_scale2.x, grid_scale2.y)) * float(SCALE < MAX_GRID_SCALE2_SCALE));\n    return rgb;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = SCALE * (2. * fragCoord - iResolution.xy) / iResolution.y;\n\n    float time = .1 * iTime;\n    //uv = mat2(cos(time), -sin(time), sin(time), cos(time)) * uv;\n\n    float grid_aa = FSAA * SCALE / iResolution.y;\n    fragColor.rgb = rgb_grid(uv, grid_aa);\n    fragColor.a=1.;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//only polar grid texture\n\n#define PI atan(0.,-1.)\n#define TAU (2.*PI)\n#define res (iResolution.xy / iResolution.y)\n\nvec2 ToPolar(vec2 v)\n{\n    return vec2(atan(v.y, v.x), length(v))/TAU;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord.xy) / iResolution.y - res/2.0;\n    uv=ToPolar(uv);\n    vec4 ret_col=vec4(0.);\n    vec2 d=smoothstep(vec2(0.002/uv.y,0.07),vec2(0.),abs(fract(uv*vec2(12.,63.)-0.5)-0.5));\n    ret_col.rgb=vec3(0.1,0.1,0.9)*max(d.x,d.y);\n    vec2 d2=smoothstep(vec2(0.002/uv.y,0.07),vec2(0.),abs(fract(uv*vec2(12.,63.)-0.)-0.5));\n    ret_col.rgb+=vec3(0.9,0.1,0.1)*max(d2.x,d2.y)*(1.-max(d.x,d.y));\n    ret_col.rgb+=vec3(.96)*(1.-max(d2.x,d2.y))*(1.-max(d.x,d.y));\n    \n    fragColor = ret_col;\n}","name":"Buffer B","description":"","type":"buffer"}]}