{"ver":"0.1","info":{"id":"WlGcDV","date":"1611756801","viewed":195,"name":"A Simple Kaleidoscope","username":"SonOfLilit","description":"A simple kaleidoscope","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["kaleidoscope","hearts"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"bool is_above_line(vec2 r, vec2 q, vec2 p) {\n    return (q.y - p.y)*(r.x - q.x)-(q.x - p.x) * (r.y - q.y) > 0.;\n}\n\nvec2 reflect_line(vec2 a, vec2 b, vec2 p) {\n    vec2 x = 0.5 * (a + b);\n    vec2 n = normalize(x);\n    return x + reflect(p - x, n);\n}\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\nbool is_heart(vec2 p, float size) {\n    p /= size;\n    p.x = abs(p.x);\n    return 1. - p.y*p.y - 0.5*max(p.y/p.x, 0.) > 2.*p.x;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/ iResolution.y;\n    uv *= 10.;\n\n    float brightness = 1.0;\n    vec2 center = vec2(0, 0);\n    vec2 right = vec2(sqrt(3.)/2., 0.5);\n    vec2 left = vec2(-sqrt(3.)/2., 0.5);\n    vec2 bottom = vec2(0., -1.);\n    vec2 p = uv;\n    \n    for (int i = 0; i < 10; i++) {\n        bool lr = is_above_line(left, right, p);\n        bool rb = is_above_line(right, bottom, p);\n        bool bl = is_above_line(bottom, left, p);\n        bool cr = is_above_line(center, right, p);\n        bool cb = is_above_line(center, left, p);\n        bool cl = is_above_line(center, bottom, p);\n        if (lr || rb || bl) {\n            if (lr && (cr && !cb)) {\n                p = reflect_line(left, right, p);\n            } else if (rb && (cl)) {\n                p = reflect_line(right, bottom, p);\n            } else if (bl && (cb)) {\n                p = reflect_line(bottom, left, p);\n            } else {\n                p = vec2(0.);\n            }\n            brightness *= 0.85;\n        }\n    }\n\n    // Time varying pixel color\n    p = rotate(p + .7*cos(iTime), iTime);\n    float size = 2. + max(0., sin(24.*mod(0.25*iTime, .1)));\n    if (is_heart((mod(3.*p, 2.0) + vec2(-1.0)), size*0.25)) {\n        p += vec2(3.0);\n        p *= 0.25;\n    }\n    vec3 col = 0.5*cos(iTime + p.xyx+vec3(0,2,4)) + 0.1*sin(p.xyx*10.);\n    col.g = 0.;\n\n    if (distance(vec2(0.), p) < 0.01) {\n        col = vec3(0.);\n    }\n\n    // Output to screen\n    fragColor = vec4(brightness*col, 1.0);\n}","name":"Image","description":"","type":"image"}]}