{"ver":"0.1","info":{"id":"WtjGRm","date":"1559337119","viewed":362,"name":"Asensio - Logarithmic Spiral","username":"Asensio12","description":"Adaptation of my Data Structures (CS - 225) project in January 2018, at UIUC.\nMove the center of the spiral using the MOUSE (enable it first), or change some of the parameters, defined at the beginning of the file.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["spiral","logaritmic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// User Defines\n\n#define USE_LOG_RADIAL_COMPONENT\n#define USE_ANGULAR_COMPONENT\n//#define USE_MOUSE\n\nconst float n             = 18.0; // number of colors\nconst float speed         =  0.5; // movement of the figure\nconst float log_curvature =  2.0; // acts as the inverse of thickness when ANGULAR_COMPONENT is disabled\n\n// Do-not-touch defines\nconst float PI  = 3.1415926;\nconst float r60 = PI/3.0;\nconst float theta_gap  = (2.0*PI) / float(n);\n\n\n\n// Hue to RGB convesion:\n// source: iq comment\nvec3 hue2rgb(in float H, in float S, in float L) {\n\tvec3 rgb = clamp( abs(mod(H*3.0/PI+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return L + S * (rgb-0.5)*(1.0-abs(2.0*L-1.0));       \n}\n\n// Equation to compute Angular luminance\nfloat AngularLuminanceFcn(in float t) {\n    float t2 = t * t;\n    float lum = (1.0-t2)*0.8+0.0;\n    return lum;\n}\n\n// Transform absolute coordinates into (0,0) centered relative coordinates\nvec2 coordTransform(in vec2 init) {\n    return ( init - 0.500001* iResolution.xy ) / iResolution.y;\n}\n\n\n// Sub Main program\nvoid subMainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Local coordinates\n    vec2 uv = coordTransform(fragCoord);\n    \n    // Half diagonal\n    vec2 uvMax = coordTransform(iResolution.xy);\n    float r_max = length(uvMax);\n    \n    // Obtain origin from mouse (or not)\n#ifdef USE_MOUSE\n    vec2    orig = coordTransform(iMouse.xy);\n#else\n    vec2    orig = vec2(0.0);\n#endif\n    \n    // Calculate the relative position of the pixel\n    vec2       d = uv-orig;\n    float      r = length(d);\n    \n    // Start the internal parameter of the program\n    float  theta = iTime*speed;\n    \n    // Logarithmic radial component\n#ifdef USE_LOG_RADIAL_COMPONENT\n    theta += log(r/n) * log_curvature;\n#endif\n    \n    // Angular component\n#ifdef USE_ANGULAR_COMPONENT\n    theta -= atan(d.y, d.x);\n#endif\n    \n    // Adjust angle of theta to [0, 2*PI[\n    theta = mod(theta, 2.0*PI);\n    \n    // Color is equidistant (distance: 2*PI/n) from the other colors in the Hue circle\n    float Hue = theta_gap * floor(n * (theta / (2.0 *PI)));\n    \n    // Calculate position in the width of the sub-spiral in range [-1,1]\n    float t = (mod(theta,theta_gap)/theta_gap-0.5)*2.0;\n    \n    // Calculate radial luminance\n    float radial_luminance = (1.0-0.95*sqrt(r/r_max));\n    \n    // Calculate angular luminance\n    float angular_luminance = AngularLuminanceFcn(t);\n    \n    // Combine angular and radial luminance\n    float lumprop = 0.85;\n    float Lum  = mix(angular_luminance, radial_luminance, lumprop);\n    \n    // Saturation: Focus Grey colors in the center of the image\n    float Sat = sqrt(r / r_max);\n    \n    // Output result\n    fragColor = vec4(hue2rgb(Hue, Sat, Lum),1.0);\n}\n\n// Antialiassing program\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 fragColor1, fragColor2, fragColor3, fragColor4, fragColor5;\n    \n    // combine 5 pixels to achieve smoothness\n    subMainImage(fragColor1, fragCoord);\n    subMainImage(fragColor2, fragCoord+vec2( 0.5,  0.5));\n    subMainImage(fragColor3, fragCoord+vec2(-0.5,  0.5));\n    subMainImage(fragColor4, fragCoord+vec2(-0.5, -0.5));\n    subMainImage(fragColor5, fragCoord+vec2( 0.5, -0.5));\n    \n    float c = 1.0, s = 0.25;\n    fragColor = (fragColor1*c + fragColor2*s + fragColor3*s + fragColor4*s + fragColor5*s)/(c+4.0*s);\n}","name":"Image","description":"","type":"image"}]}