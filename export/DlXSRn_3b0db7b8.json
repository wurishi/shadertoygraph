{"ver":"0.1","info":{"id":"DlXSRn","date":"1674167929","viewed":366,"name":"FFT frequencies visualized","username":"MartyMcFly","description":"original image                               |      current isolated frequency component (real component)\nmasked fft (orange = removed)      |      stacked isolated frequencies \n","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["fft","fourier","dft"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord.x -= (iResolution.x - SIZE*2.0)*0.5;\n    if(fragCoord.x < 0.0) \n    {\n        fragColor = vec4(0.0); return;\n    }\n    \n     uvec2 tile = uvec2(floor(fragCoord / SIZE));   \n     fragColor = vec4(0.0);   \n\n     \n     //bottom left, frequency vis + mask\n     if(tile.x == 0u && tile.y == 0u)\n     {\n        fragColor = vec4(log(1.0 + 0.01*length(texelFetch(iChannel0, ivec2(fragCoord), 0).xy)));\n        uint idx = pixel_coord_to_idx(uvec2(fragCoord) % uvec2(SIZE), uint(SIZE));  \n#ifdef INVERSE_MODE \n        if(idx < convert_frame_to_idx(iFrame, SIZE)) fragColor = vec4(1.0, 0.5, 0.0, 1.0);  \n#else \n        if(idx > convert_frame_to_idx(iFrame, SIZE)) fragColor = vec4(1.0, 0.5, 0.0, 1.0);\n#endif                   \n     }\n     \n     //top right, single frequency\n     if(tile.x == 1u && tile.y == 1u)\n     {\n         fragColor = vec4(log(1.0 + length(texelFetch(iChannel1, ivec2(fragCoord), 0).xx))); //showing 1 phase only\n     }\n\n     //unchanged image\n     if(tile.x == 0u && tile.y == 1u) fragColor = vec4(texelFetch(iChannel2, ivec2(mod(fragCoord, SIZE)), 0).x);\n     \n     //image with frequencies removed\n     if(tile.x == 1u && tile.y == 0u) fragColor = vec4(texelFetch(iChannel1, ivec2(fragCoord), 0).x);    \n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define NORMALIZE_ISOLATED_FREQUENCY\n//#define INVERSE_MODE\n#define ANIM_SPEED                       500.0\n\n\n//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n#define TAU 6.2831853\n#define INPUT_SIZE iResolution.y*0.5\n#define SIZE (2.0 * round((INPUT_SIZE) / 2.0))\n\n\nvec4 get_data(sampler2D s, float x, float y, ivec2 offset)\n{\n    return texelFetch(s, ivec2(x, y) + offset, 0);\n}\n\nvec2 cmul(vec2 a,float b) \n{ \n    return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b));\n}\n\nfloat wrap(float t, float size)\n{\n    return fract(t / size + 0.5) * size; //mod(p + size * 0.5, size);\n}\n\n//these do DFT inside their size*size tiles\n//thanks to https://www.shadertoy.com/view/MscGWS for original concept\n//2 passes pipelined : in -> buf.zw -> buf.xy -> out\nvec4 dft(sampler2D sA, sampler2D sB, vec2 p, float size)\n{   \n    ivec2 offset = ivec2(floor(p / size) * size);\n    p = mod(p, size);\n    \n    vec2 xn, yn, a;  \n    vec4 res = vec4(0.0);\n    \n    for(float n = 0.0; n < size; n++)\n    {\n        xn = get_data(sA, n+0.5, p.y, offset).xy;\n        yn = get_data(sB, p.x, n+0.5, offset).zw;\n        \n        \n        a = vec2(-TAU * n/size);        \n        a *= p - 0.5 - size * 0.5;\n        \n        res.zw += cmul(xn, a.x);\n        res.xy += cmul(yn, a.y);\n    }\n    \n    return res;\n\n}\n\n//2 passes pipelined : in -> buf.zw -> buf.xy -> out\nvec4 idft(sampler2D sA, sampler2D sB, vec2 p, float size)\n{\n    ivec2 offset = ivec2(floor(p / size) * size);\n    p = mod(p, size);\n    \n    vec2 xn, yn, a;  \n    vec4 res = vec4(0.0);\n    \n    for(float n = 0.0; n < size; n++)\n    {\n        float m = wrap(n, size);\n        xn = get_data(sA, m+0.5, p.y, offset).xy;\n        yn = get_data(sB, p.x, m+0.5, offset).zw;\n        \n        \n        a = vec2(-TAU * n/size);        \n        a *= -(p - 0.5);\n        \n        res.zw += cmul(xn, a.x);\n        res.xy += cmul(yn, a.y);\n    }\n    \n    res /= size;\n    \n    return res;\n\n}\n\nuint pixel_coord_to_idx(uvec2 p, uint gridsize)\n{\n    uint x = p.x;\n    uint y = p.y;\n    \n    uint ring_id = min(min(x, y), min(gridsize - 1u - x, gridsize - 1u - y));       \n    \n    uint N = gridsize - 2u * ring_id;  //size of ring \n    uint ring_total = 4u * N - 4u;\n    \n    uint idx_in_ring = (x - ring_id) + (y - ring_id);\n    idx_in_ring = y > x ? ring_total - idx_in_ring : idx_in_ring;    \n\n    uint num_outer_rings = ring_id * 4u * (gridsize - ring_id); \n    return gridsize * gridsize - (num_outer_rings + idx_in_ring); //index from inside out      \n}\n\nuint convert_frame_to_idx(int framecount, float size)\n{      \n    return uint(exp(min(1.0, float(framecount) / (size*size)) * ANIM_SPEED)); \n\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    if(max(fragCoord.x, fragCoord.y) <= SIZE) \n        fragColor.x = dot(vec3(0.3333), texture(iChannel0, fragCoord / SIZE).rgb);   \n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = dft(iChannel0, iChannel1, fragCoord, SIZE);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    fragColor = vec4(0.0);     \n     \n    uvec2 tile = uvec2(floor(fragCoord / SIZE));\n    fragCoord = mod(fragCoord, SIZE);\n    \n    //bottom left, show all frequencies (will later be masked for visualization)\n    if(tile.x == 0u && tile.y == 0u) \n    {\n        fragColor.xy = texelFetch(iChannel0, ivec2(fragCoord), 0).xy;\n    }    \n    \n    //bottom right, masked frequencies\n    if(tile.x == 1u && tile.y == 0u) \n    {\n        fragColor.xy = texelFetch(iChannel0, ivec2(fragCoord), 0).xy;\n        uint idx = pixel_coord_to_idx(uvec2(fragCoord), uint(SIZE));\n#ifdef INVERSE_MODE  \n        if(idx < convert_frame_to_idx(iFrame, SIZE)) fragColor = vec4(0.0);   \n#else \n        if(idx > convert_frame_to_idx(iFrame, SIZE)) fragColor = vec4(0.0);  \n#endif\n    }\n    \n    \n    //top right, show only the current frequency\n    if(tile.x == 1u && tile.y == 1u)\n    {\n        fragColor.xy = texelFetch(iChannel0, ivec2(fragCoord), 0).xy;\n        \n#ifdef NORMALIZE_ISOLATED_FREQUENCY\n        fragColor.xy = dot(fragColor.xy, fragColor.xy) == 0.0 ? vec2(1.0, 0.0) : normalize(fragColor.xy) * SIZE * SIZE;\n#endif\n        uint idx = pixel_coord_to_idx(uvec2(fragCoord), uint(SIZE));        \n        if(idx != convert_frame_to_idx(iFrame, SIZE)) fragColor = vec4(0.0);  \n    }  \n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    fragColor = idft(iChannel0, iChannel1, fragCoord, SIZE);\n}","name":"Buffer D","description":"","type":"buffer"}]}