{"ver":"0.1","info":{"id":"Mf2Szt","date":"1706719215","viewed":166,"name":"Camera control","username":"Elsio","description":"tentando entender a matemática por trás do dda. ","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["tutorial","voxel","cubes","dda"],"hasliked":0,"parentid":"4cSXR3","parentname":"Corredores"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define t 8. * iTime\n#define camPath(z) path(z, .19, .25, 1.3, 1.)  \n#define pat2(z) path(z, .2, .1, 6.2, 4.2)  \n#define pat3(z) path(z, .03, .12, 5.2, 6.2)\n#define path(z, a, b, c, d) vec3(z, cos((z) * a) * c, sin((z) * b) * d)\n#define vagal1 pat2(t + 15. + cos(t * .1 + 2.) * 10.)\n#define vagal2 pat3(t + 15. + cos(t * .1 + 4.) * 10.)\n#define vagal3 camPath(t + 10. + cos(t * .1) * 5.)\n#define rot(a) mat2(cos(a + vec4(0, 11, 33, 0)))\n\nvec3 cor;\nfloat bvol;\n\nfloat map(vec3 p){\n    float a = length(p.yz - camPath(p.x).yz) * 4.,\n          b = length(p.yz - pat2(p.x).yz) * 1.8,\n          c = length(p.yz - pat3(p.x).yz) * 1.7,\n          tun = 7. - min(a, min(b, c)),\n    \n          e = length(p - vagal1) - 1.5,\n          f = length(p - vagal2) - 2.,\n          g = length(p - vagal3) - .8,\n          balls = min(e, min(f, g));\n    \n    cor  = vec3(balls == e, balls == f, balls == g) * .9;\n    bvol = step(tun, balls);\n                  \n    return min(tun, balls);\n} \n\n\nvoid camera(vec2 u, out vec3 ro, out vec3 D, float T){\n    vec3 R = iResolution, fw, rt;\n    float tt = floor(fract(T / 230.) * 3.);\n    \n    if(tt == 1.) T = T + 30.;\n    if(tt == 2.) T = floor(T / 50.) * 50. + 25.;\n    \n    ro = camPath(T);\n    fw = normalize(camPath(T + 1.) - ro);\n    rt = vec3(fw.z, 0, -fw.x);\n    D = fw + mat2x3(rt, cross(fw, rt)) * (u - .5 * R.xy) / R.y / 1.2;\n    \n    if(tt == 0.) D.xy *= rot(cos(t * .1) * .5);\n    if(tt == 1.) D.xz *= rot(3.14);\n    if(tt == 2.) D.xz *= rot(cos(t * .1) * .5);\n    \n    return; \n}\n\nvoid mainImage(out vec4 o, vec2 u) {\n    float res = .4, z, border;\n    vec3 norm, mask, side, p, q, vol, ro, D, s;\n    \n    camera(u, ro, D, t); // define ray orig & ray dir\n    \n    ro /= res;\n    p = floor(ro);\n    side = (p - ro + .5) / D + .5 / abs(D);\n    \n    int i, far = 1280;\n    vol = vec3(1);\n    while (q = p * res, i++ < far){\n        if(map(q) < .0) {\n            if(bvol > 0.){\n                vol *= dot(mask, vec3(8, 9, 6) / 8.);\n                break;\n            }\n            vol *= cor * 1.2;\n        }\n        side += mask / abs(D),\n        mask = step(side, side.yzx) * step(side, side.zxy),\n        p += norm = mask * sign(D);\n    }\n\n    if(i < far)\n        z = dot(side, mask),\n        q = abs(fract(ro + z * D) - .5),\n        \n        border = .48 - dot(max(q.yzx, q.zxy), mask),\n        o = sqrt(vol.xyzz * (3. / z - .01)\n              * (1.5 + smoothstep(0., fwidth(border), border) * .5));\n}\n","name":"Image","description":"","type":"image"}]}