{"ver":"0.1","info":{"id":"DlXGzX","date":"1672250709","viewed":91,"name":"Light Intensity - Cornell Box","username":"wagyx","description":"Rendering of different light intensity profiles from convex shapes with closed form solutions and meshes.\nUse mouse to navigate: x axis changes the shape, y-axis changes the light axis.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["light","cornell","intensity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThe purpose of this shader is demonstrate the intensity profile of several light source shapes but reduced to a point light.\nThe luminance is supposed to be constant across the surface.\nThis is equivalent to an IES profile for common shapes with closed form solutions:\n- planar surface (triangle, rectangle, disk, ellipse)\n- box\n- sphere\n- tube and cylinder\nI also propose a method that works on convex triangular meshes and apply it to the tetrahedron.\n\nFor more details and if you are curious, I suggest you take a look at my blog post:\nhttps://asliceofcuriosity.pagesperso-orange.fr/blog/posts/rendering5.html\nThe functions are also plotted in a shader:\nhttps://www.shadertoy.com/view/3dGyDw\nhttps://www.shadertoy.com/view/3s3fDj\n\nI am using a simple ray marching algorithm to display a cornell box.\nWhen a ray hits, a light ray to evaluate the shadow and the light intensity.\nI did not bothered implementing anything fancy there, sorry for that.\n*/\n\n\n/**\nRAYMARCHING ALGORITHM\nfrom  Ray Marching: Part 2 by jfwong : https://www.shadertoy.com/view/lt33z7\nfrom  Raymarching - Primitives by iq : https://www.shadertoy.com/view/Xds3zN\n*/\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\nconst float PI = 3.141592653589793;\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n\nfloat sdPlane( vec3 p ){\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s ){\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b ){\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat opU( float d1, float d2 ) {\n\treturn min(d1,d2);\n}\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size * 0.5;\n    float z = size.y / tan(radians(fieldOfView) * 0.5);\n    return normalize(vec3(xy, z));\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {\n    float res = 1e10;\n    res = opU(res, sdSphere(samplePoint-vec3(1.0,0.5,-1.), 0.5));\n    res = opU(res, sdBox(samplePoint-vec3(-1.0,0.5,1.), vec3(0.5,0.5,0.5)));\n    \n    float size=2.;\n    float thickness=0.01;\n    res = opU(res, sdBox(samplePoint-vec3(0.0,0.0,0.0),vec3(size,thickness,size)));\n    res = opU(res, sdBox(samplePoint-vec3(0.0,2.*size,0.0),vec3(size,thickness,size)));\n    res = opU(res, sdBox(samplePoint-vec3(-size,size,0.0),vec3(thickness,size,size)));\n    res = opU(res, sdBox(samplePoint-vec3(size,size,0.0),vec3(thickness,size,size)));\n    res = opU(res, sdBox(samplePoint-vec3(0.0,size,size),vec3(size,size,thickness)));\n    return res;\n}\n\n\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\n\n\n///////////////////////////////////////////////////////////\n//SOME MATHS FOR ROTATIONS\n/////////////////////////////////////////////////////\n\n// taken from https://www.shadertoy.com/view/WtjcDt\nmat4 rotationMatrix(vec3 axis, float cosAngle, float sinAngle) {\n    float s = sinAngle;\n    float c = cosAngle;\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nmat4 rotationMatrix(vec3 axis, float angle) {\n    // taken from http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n    // angle = radians(angle);\n    //axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    return rotationMatrix(axis, s, c);\n}\n\n//taken from https://www.shadertoy.com/view/WtjcDt\nvec3 apply_rot(mat4 r, vec3 p) {\n    return (r*vec4(p, 1.)).xyz;\n}\n\nvec3 rotateVectorFromZenith(vec3 view, vec3 direction) {\n    const vec3 zaxis = vec3(0.f,0.f,1.f);\n    vec3 axis = cross(zaxis,direction);\n    float sinAngle = length(axis);\n    float cosAngle = dot(zaxis,direction);\n    axis /= sinAngle;\n    mat4 mat = rotationMatrix(axis, cosAngle, sinAngle);\n    return apply_rot(mat,view);\n}\n\n/////////////////////////////////////////////////////\n// FUNCTIONS TO COMPUTE THE INTENSITY OF VARIOUS SHAPES\n/////////////////////////////////////////////////////\n\nfloat sphereAppSurface(float radius){\n    return PI*radius*radius;\n}\n\n// view is the direction from which the object is observed, must be normalized\n// normal is the normal of the flat surface, must be normalized\n// area is the area of the object\n// isSingleFaced indicates whether the surface emits from the normal side (true) or both sides false.\nfloat flatAppSurface(vec3 view, vec3 normal, float area, bool isSingleFaced) {\n    float res = dot(view,normal);\n    //when negative, take absolute value if not single faced and zero else\n    if (res < 0.f) {\n        res*= sign(res)*float(!isSingleFaced); \n    }\n\treturn res*area;\n}\n\n//widths are the side lengths of the rectangle\nfloat rectAppSurface(vec3 view, vec3 normal, vec2 widths, bool isSingleFaced){\n\treturn flatAppSurface(view, normal, widths.x*widths.y, isSingleFaced);\n}\n\nfloat triangleAppSurface(vec3 view, vec3 p0, vec3 p1, vec3 p2, bool isSingleFaced){\n\tvec3 normal = cross(p1-p0,p2-p0);\n    float area = length(normal);\n    normal/=area;\n    area*=0.5;\n    return flatAppSurface(view, normal, area, isSingleFaced);\n}\n\n// halfWidths are the half widths of the minor and major axis of the ellipse\nfloat ellipseAppSurface(vec3 view, vec3 normal, vec2 halfWidths, bool isSingleFaced){\n\treturn flatAppSurface(view, normal, PI*halfWidths.x*halfWidths.y, isSingleFaced);\n}\nfloat diskAppSurface(vec3 view, vec3 normal, float radius, bool isSingleFaced){\n\treturn ellipseAppSurface(view, normal, vec2(radius), isSingleFaced);\n}\n\nfloat alignedBoxAppSurface(vec3 view, vec3 widths){\n    const vec3 xaxis = vec3(1.f,0.f,0.f);\n    const vec3 yaxis = vec3(0.f,1.f,0.f);\n    const vec3 zaxis = vec3(0.f,0.f,1.f);\n\tfloat res= rectAppSurface(view, zaxis, widths.xy, false);\n    res+= rectAppSurface(view, xaxis, widths.yz, false);\n    res+= rectAppSurface(view, yaxis, widths.xz, false);\n    return res;\n}\nfloat vertTubeAppSurface(vec3 view, float radius, float height){\n    const vec3 zaxis= vec3(0.f,0.f,1.f);\n    float res= length(cross(view,zaxis));\n    return res*radius*height*2.f;\n}\n\nfloat vertCylinderAppSurface(vec3 view, float radius, float height){\n    const vec3 zaxis = vec3(0.f,0.f,1.f);\n\tfloat res= diskAppSurface(view, zaxis, radius, false);\n    res+= vertTubeAppSurface(view, radius, height);\n    return res;\n}\n\n//FOR LIGHT WITH ANY DIRECTION USE THE FOLOWING\n\nfloat tubeAppSurface(vec3 view, vec3 axis, float radius, float height){\n    vec3 newView= rotateVectorFromZenith(view,axis);\n    return vertTubeAppSurface(newView, radius, height);\n}\n    \nfloat cylinderAppSurface(vec3 view, vec3 axis, float radius, float height){\n    float res=0.f;\n\tres+= diskAppSurface(view, axis, radius, false);\n\tres+= tubeAppSurface(view, axis, radius, height);\n    return res;\n}\n\nfloat boxAppSurface(vec3 view ,vec3 axis, vec3 widths){\n    vec3 newView= rotateVectorFromZenith(view,axis);\n    return alignedBoxAppSurface(newView, widths);\n}\n\n\n// FOR CONVEX TRIANGULAR MESHES\n#define meshMaxNbFaces 30\n#define meshMaxNbVert 30\n\nstruct TriMesh {\n    int nbVert;\n    int nbFaces;\n\tvec3 vert[meshMaxNbVert];\n\tivec3 faces[meshMaxNbFaces];    \n};\n\nconst float C0 = 0.35355339059328;\nTriMesh genTetrahedron() {\n    TriMesh mesh;\n    mesh.nbVert=4;\n    mesh.vert[0] = vec3( C0, -C0,  C0);\n    mesh.vert[1] = vec3( C0,  C0, -C0);\n    mesh.vert[2] = vec3(-C0,  C0,  C0);\n    mesh.vert[3] = vec3(-C0, -C0, -C0);\n    mesh.nbFaces=4;\n    mesh.faces[0] = ivec3( 0, 1, 2 );\n    mesh.faces[1] = ivec3( 1, 0, 3 );\n    mesh.faces[2] = ivec3( 2, 3, 0 );\n    mesh.faces[3] = ivec3( 3, 2, 1 );\n    return mesh;\n}\n\n\nfloat triMeshAppSurface(vec3 view, vec3 axis, TriMesh mesh){\n    vec3 newView= rotateVectorFromZenith(view,axis);\n    float res=0.f;\n    for(int i=0; i<mesh.nbFaces; ++i){\n        ivec3 face = mesh.faces[i];\n        res+=triangleAppSurface(newView, mesh.vert[face.x], mesh.vert[face.y], mesh.vert[face.z], true);\n    }\n    return res;\n}\n\n///////////////////////////////////////\nfloat lightAppSurface(vec3 view, vec3 surfaceNormal, float lightID) {\n\n    float appSurf = 0.f;\n    //Sphere\n    if (lightID == 0.0)\n        appSurf = sphereAppSurface(0.5);\n        \n    // Rectangle and Box\n    else if (lightID == 1.0)\n        appSurf = flatAppSurface(view,surfaceNormal,1.1,false);\n    else if (lightID == 2.0)\n        appSurf = rectAppSurface(view,surfaceNormal,vec2(1.,1.),false);\n\telse if (lightID == 3.0)\n        appSurf = alignedBoxAppSurface(view, vec3(1.f,1.f,1.f))/1.73f;\n    else if (lightID == 4.0)\n        appSurf = boxAppSurface(view, surfaceNormal, vec3(1.f, 1.f,1.f))/1.5f;\n    \n    //Disk, Tube and Cylinder\n    else if (lightID == 5.0)\n        appSurf = diskAppSurface(view, surfaceNormal, 1.f, false)/PI;\n    else if (lightID == 6.0)\n        // actually aligned with z axis (front, back)\n        appSurf = vertTubeAppSurface(view, 1.f, 1.f)/2.f;\n    else if (lightID == 7.0)\n        // actually aligned with z axis (front, back)\n        appSurf = vertCylinderAppSurface(view, 1.f, 1.f)/3.8f;\n    else if (lightID == 8.0)\n        appSurf = tubeAppSurface(view, surfaceNormal, 1.f, 1.f)/2.f;\n    else if (lightID == 9.0)\n        appSurf = cylinderAppSurface(view, surfaceNormal, 1.f, 1.f)/3.8f;\n\t\n    // Ellipse\n    else if (lightID == 10.0)\n        appSurf = ellipseAppSurface(view, surfaceNormal, vec2(1.f,2.f), false)/(2.f*PI);\n    \n    // Mesh\n    else if (lightID == 11.0)\n        appSurf = triMeshAppSurface(view, surfaceNormal, genTetrahedron());\n        \n    return appSurf;\n}\n\n////////////////////////////////////////////////////////\n// MAIN\n////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Ray ray = Ray(vec3(0.f,2.f,-6.f), rayDirection(90.0, iResolution.xy, fragCoord));\n    \n    // compute intersection     \n    float dist = shortestDistanceToSurface(ray.origin,ray.direction, MIN_DIST, MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0,0.0,0.0, 1.0);\n        return;\n    }\n    vec3 hitPoint = ray.origin + dist * ray.direction;\n    vec3 hitPointNormal = estimateNormal(hitPoint);\n    \n    \n    vec3 lightPos = vec3(0.0,3.0,0.0);\n    vec3 lightColor = vec3(1.0,1.0,1.0)*3.;\n    vec3 lightAxis = normalize(vec3((iMouse.y/iResolution.y-0.5)*5.,1.0,0.0));\n    float lightID = floor(iMouse.x * 12. / iResolution.x );\n    \n    // animate \n    if (length(iMouse.xy) < 20.) {\n        lightAxis = normalize(vec3(cos(iTime),1.,sin(iTime)));\n        lightID = mod(floor(iTime),12.);\n    }\n    \n    //vec3 lightAxis = vec3(0.0,1.0,0.0); //for vertical axis\n    \n    vec3 dirToLight = lightPos-hitPoint;\n    float distToLight = length(dirToLight);\n    dirToLight = dirToLight/distToLight;\n    \n    ray = Ray(lightPos, -dirToLight);\n    dist = shortestDistanceToSurface(ray.origin,ray.direction, MIN_DIST, MAX_DIST);\n    vec3 col = vec3(0.);\n    if (abs(dist - distToLight) < 0.001) {\n        float appSurface = lightAppSurface(-dirToLight, lightAxis, lightID);\n        \n        // lightColor is the light radiance\n        col = lightColor * appSurface; // this is the point light intensity\n        // because it is a point light, we need to convert to irradiance\n        col *= dot(hitPointNormal, dirToLight)/(distToLight*distToLight);\n    }\n    \n    // Output to screen\n    //fragColor = vec4((hitPointNormal+1.)*0.5, 1.);\n    fragColor = vec4(pow(col,vec3(0.45)),1.0);\n}","name":"Image","description":"","type":"image"}]}