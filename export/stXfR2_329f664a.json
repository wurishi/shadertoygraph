{"ver":"0.1","info":{"id":"stXfR2","date":"1651117428","viewed":133,"name":"Atmos Rayleigh Scatter With LUT","username":"March3rd","description":"I studied to use LUT to accelerate Rayleigh Scatter in atmos. It's just for practice.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["atmoslutscatter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RED_DEC 0.00000519673\n#define GREEN_DEC 0.0000121427\n#define BLUE_DEC 0.0000296453\n#define H 7500.0\n#define STEP_LEN 10000.0\n#define STEP_NUM 100\n#define EARTH_INNER_R 6371393.0\n#define EARTH_OUTER_R 7371393.0\n#define PI 3.1415926\n\nvec3 Sun_Dir = normalize(vec3(0.0, -0.0, -1.0));\nvec3 Sun_Col = vec3(1.0, 1.0, 1.0) * 15.0; \nvec3 Earth_Base = vec3(0.0, -EARTH_INNER_R, 0.0);\n\nfloat sphereSDF(vec3 base, float r, vec3 pos) {\n    return length(pos - base) - r;\n}\n\nvec3 rayleighDecay(float h, float d) {\n    float density = 1.0 / exp(h / H);\n    return vec3(1.0 / exp(RED_DEC * density * d)\n              , 1.0 / exp(GREEN_DEC * density * d)\n              , 1.0 / exp(BLUE_DEC  * density * d));\n}\nvec3 rayleighScatter(float h, vec3 in_dir, vec3 out_dir) {\n    float k = 3.0 / 16.0 / PI;\n    float p = 1.0 / exp(h / H); \n    float d = 1.0 + pow(dot(in_dir, out_dir), 2.0);\n    vec3 scatter = vec3(RED_DEC, GREEN_DEC, BLUE_DEC) * k * p * d;\n    return scatter;\n}\nvec3 lightDecaySampler(float h, vec3 in_dir, vec3 out_dir) {\n    vec2 uv;\n    uv.x = acos(dot(in_dir, out_dir)) / PI;\n    uv.y = h / (EARTH_OUTER_R - EARTH_INNER_R);\n    if (uv.y < 0.0 || uv.y > 1.0) {\n        return vec3(0.0);\n    } else {\n        return texture(iChannel0, uv).rgb;\n    }\n}\n\nvec3 rayMarching(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.0);\n    vec3 view_decay = vec3(1.0);\n    vec3 pos = ro;\n    for (int i = 0; i < STEP_NUM; i ++) {\n        float h = sphereSDF(Earth_Base, EARTH_INNER_R, pos);\n        if (h > EARTH_OUTER_R - EARTH_INNER_R) {\n            break;\n        }\n        float dist = STEP_LEN;\n        view_decay *= rayleighDecay(h, dist);\n        vec3 light_decay = lightDecaySampler(h, normalize(Earth_Base - pos), -Sun_Dir);\n        vec3 rayleigh_scatter = rayleighScatter(h, Sun_Dir, -rd);\n        col += Sun_Col * light_decay * rayleigh_scatter * dist * view_decay;\n        pos += dist * rd;\n    }\n    col += pow(clamp(dot(-Sun_Dir, rd) -0.5, 0.0, 1.0) * 1.985, 128.0) * view_decay * Sun_Col;\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    float v = 0.25;\n    float theta = sin(v * iTime) * PI * 0.12 + PI / 12.0;\n    Sun_Dir = vec3(0.0, -sin(theta), -cos(theta));\n\n    //Normalized pixel coordinates\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    //Ray\n    vec3 ro = vec3(0.0, 5.0, 0.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 0.5));\n    vec3 col = rayMarching(ro, rd);\n    // Output to screen\n    \n    fragColor = vec4(pow(col, vec3(1.0 / 2.2)),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define EARTH_INNER_R 6371393.0\n#define EARTH_OUTER_R 7371393.0\n#define PI 3.1415926\n#define H 7500.0\n#define RED_DEC 0.00000519673\n#define GREEN_DEC 0.0000121427\n#define BLUE_DEC 0.0000296453\n\n#define STEP_NUM 100\n#define STEP_LEN 10000.0\n\nvec3 rayleighDecay(float h, float d) {\n    float density = 1.0 / exp(h / H);\n    return vec3(1.0 / exp(RED_DEC * density * d)\n              , 1.0 / exp(GREEN_DEC * density * d)\n              , 1.0 / exp(BLUE_DEC  * density * d));\n}\n\nfloat sphereSDF2D(vec2 base, float r, vec2 pos) {\n    return length(pos - base) - r;\n}\n\nvec3 rayMarching(vec2 ro, vec2 rd) {\n    vec2 pos = ro;\n    vec3 decay = vec3(1.0);\n    for (int i = 0; i < STEP_NUM; i ++) {\n        float h = sphereSDF2D(vec2(0.0), EARTH_INNER_R, pos);\n        if (h > EARTH_OUTER_R - EARTH_INNER_R) {\n            break;\n        }\n        float dist = STEP_LEN;\n        decay *= rayleighDecay(h, dist);\n        pos += rd * dist;\n        \n    }\n    return decay;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 ro = vec2(0.0, mix(EARTH_INNER_R, EARTH_OUTER_R, uv.y));\n    float theta = (uv.x - 0.5) * PI;\n    vec2 rd = vec2(cos(theta), sin(theta));\n    vec3 decay = rayMarching(ro, rd);\n    fragColor = vec4(decay ,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}