{"ver":"0.1","info":{"id":"wstSDB","date":"1573232095","viewed":181,"name":"SNOW, CAP v1,0alfa","username":"cmarangu","description":"Made this to overwrite a low-quality and not primarily-blue shader.\nAnd to learn how voxel rendering engine work. I thought surface effects would be easy, but from ambient occlusion to some apparent floating-point-rounding artifacts, I seemto have problem","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","wip","minecraft"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// /*\n// Current Code\n// Title: minecraft sort of\n// Tags: raytracing\n// Date Started: 2020 2/17\n// Date Finished: -\n// Description: Made this to overwrite a low-quality and not primarily-blue shader.\n// And to learn how voxel rendering engine work. I thought surface effects would be\n// easy, but from ambient occlusion to some apparent floating-point-rounding artifacts,\n// I seemto have problem\n\n// TODO:\n// - Could make dodecahedron voxels\n// - Could use spherical \"arcs\"/eggshelfrag to truchet tile smooth\n// - need to texture like rubix cubes everywhere\n// - i think monte-carlo tracing could fix problems w antialiasing and ambient occlusion\n//   and shadows so i will have to learn it\n\n// EDITABLE PARAMS:\n#define fog_start 50.\n#define fog_dist 13.\n\n#define PI 3.141592653589793238462643383279502884197169399375105820974944592307816406286\n// i know more\n\nvec3 sky_map (vec3 d) {\n    return vec3(0., 0., 100./255.);\n}\n\nint bloctyp (vec3 p) {\n    p += vec3(0., 5., 0.);\n    p = floor(p);\n    // return p.y <= 0. ? 1 : 0;\n    // return float(p.y) < sin(float(p.x)/5.+float(p.z)/10.)*8.-8. ? 1 : 0;\n    if (float(p.y) < (texture(iChannel0, p.xz/705.).r-1.)*15.) {\n        if (mod(p.x, 10.) < 5.) {\n            return 2;\n        }\n        return 1;\n    }\n    return 0;\n}\n\nbool cast_ray (vec3 p, vec3 d, out int id, out float dist, out vec3 n) {\n    \n    vec3 camp = p;\n    \n    id = 0;\n    dist = 1e9;\n    n = vec3(0.);\n    \n    if (p.y > 1.) {\n        // trace down onto plane where all the grounds below\n        float a = p.y-1.;\n        float h = a/dot(d, vec3(0., -1., 0.));\n        if (dot(d, vec3(0., -1., 0.)) > 0.) {\n            p += d*h;\n        }\n        else {\n            return false;\n        }\n\t}\n    \n    // help with whole number glitches\n    if (p.x == floor(p.x)) {\n        p.x += 1e-5;\n    }\n    if (p.y == floor(p.y)) {\n        p.y += 1e-5;\n    }\n    if (p.z == floor(p.z)) {\n        p.z += 1e-5;\n    }\n\n    float dist_d;\n    float dist_l;\n    float dist_b;\n    float dist_u;\n    float dist_r;\n    float dist_f;\n    vec3 lp;\n    float closest_dist;\n    vec3 closest_n;\n\n    if (bloctyp(p) != 0) {\n        // u need to be in a transparent block\n        // to see anything\n        id = 0;\n        dist = 0.;\n        n = vec3(0., 0., -1.);\n        return true;\n    }\n\n    for (int i=0; i<100; ++i) {\n\n        closest_dist = 1e9;\n        closest_n = vec3(0.);\n\n        lp = fract(p);\n        //float dist_d = inter_ray_plane(p, d, vec3(0., floor(p.y), 0.), vec3(0., 1., 0.)).dist;\n        //float dist_d = lp.y/dot(d, vec3(0., -1., 0.));\n        // d l f b r u\n        dist_d = lp.y/-d.y;\n        if (dist_d < closest_dist && -d.y > 0.) {\n            closest_dist = dist_d;\n            closest_n = vec3(0., 1., 0.);\n        }\n        dist_l = lp.x/-d.x;\n        if (dist_l < closest_dist && -d.x > 0.) {\n            closest_dist = dist_l;\n            closest_n = vec3(1., 0., 0.);\n        }\n        dist_b = lp.z/-d.z;\n        if (dist_b < closest_dist && -d.z > 0.) {\n            closest_dist = dist_b;\n            closest_n = vec3(0., 0., 1.);\n        }\n\n        dist_u = (1.-lp.y)/d.y;\n        if (dist_u < closest_dist && d.y > 0.) {\n            closest_dist = dist_u;\n            closest_n = vec3(0., -1., 0.);\n        }\n        dist_r = (1.-lp.x)/d.x;\n        if (dist_r < closest_dist && d.x > 0.) {\n            closest_dist = dist_r;\n            closest_n = vec3(-1., 0., 0.);\n        }\n        dist_f = (1.-lp.z)/d.z;\n        if (dist_f < closest_dist && d.z > 0.) {\n            closest_dist = dist_f;\n            closest_n = vec3(0., 0., -1.);\n        }\n        \n        if (closest_dist < 1e9) {\n            // jots [prta;\n            // -hits portal\n            vec3 p2 = p+d*(closest_dist+1e-5);\n            int current_bloctyp = bloctyp(p2);\n            // int current_bloctyp = p2.y < -10. ? 1 : 0;\n            if (current_bloctyp != 0) {\n                id = current_bloctyp;\n                dist = length(p2-camp);\n                n = closest_n;\n                return true;\n            }\n            else {\n                p = p2;\n            }\n        }\n        if (p.y > 2. || length(p-camp) > fog_start+fog_dist) {\n            return false;\n        }\n        \n    }\n    \n    return false;\n    \n}\n\nvec3 trace (vec3 p, vec3 d) {\n    vec3 camp = p;\n    int id = 0;\n    float dist = 1e9;\n   \tvec3 n = vec3(0.);\n    \n    bool hit = cast_ray(p, d, id, dist, n);\n    \n    if (!hit) {\n        return sky_map(d);\n    }\n    \n    vec3 p2 = camp+dist*d;\n    \n    // There is a block. You have surface normal, sky map, material type; shade it.\n    vec3 sund = normalize(vec3(cos(iTime), 1., sin(iTime)) );\n    float lit = 1.;\n    vec3 tex = vec3(1., 1., 1.);\n    \n    if (id == 1) {\n        // shadow raytracing / diffuse lighting\n        // diffuse lighting attempt\n        lit *= .5+.5*dot(n, sund);\n        // lit *= clamp(dot(n, sund), 0., 1.);\n        lit = pow(lit, 3.);\n        // ambient occlusion attempt\n        float occ = clamp(-(p2.y-2.)/25., 0., 1.);\n        occ = pow(occ, .7);\n        lit *= mix(1., .0,  occ);\n        // shadow casting atttempt\n        // int shid = 0;\n        // float shdist = 0.;\n        // vec3 shn = vec3(0.);\n        // bool shado = cast_ray(p2-d*1e-5+sund*3e-3, sund, shid, shdist, shn);\n        // if (shado) {\n        //     lit *= .8;\n        // }\n        \n        tex *= texture(iChannel1, vec2(p2.x+p2.y, p2.z)/20.).rgb;\n        float czk = mod(floor(p2.x*1.)+floor(p2.y*1.)+floor(p2.z*1.), 2.);\n        czk = .5+.5*czk;\n        tex.r *= czk;\n        tex.b = 1.;\n        \n    }\n    else if (id == 2) {\n        // shiny reflective surface\n        int spec_rid = 0;\n        float spec_rdist = 1e9;\n        vec3 spec_rn = vec3(0.);\n        bool spec_r = cast_ray(p2-d*1e-4, reflect(d, n), spec_rid, spec_rdist, spec_rn);\n        \n        float czk = mod(floor(p2.x*1.)+floor(p2.y*1.)+floor(p2.z*1.), 2.);\n        czk = .5+.5*czk;\n        tex *= czk;\n        \n        if (spec_r) {\n        \ttex = .5*tex+.5*sky_map(reflect(d, n));\n        }\n        \n    }\n    \n    \n    vec3 retina = tex*lit;\n    \n    if (dist >= fog_start) {\n        retina = mix(retina, sky_map(d), clamp((dist-fog_start)/fog_dist, 0., 1.) );\n    }\n    \n    return retina;\n    \n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screen = (fragCoord.xy-iResolution.xy/2.)/iResolution.y;\n    vec3 camp = vec3(0., 0., 0.+iMouse.y*0.);\n    vec3 camd = normalize(vec3(screen.x, screen.y, 1.));\n    \n    float zenith = clamp((iMouse.y-iResolution.y/2.)/iResolution.y*PI*2.5, -.0, PI*.5);\n    camd.yz *= mat2(\n        cos(zenith), cos(zenith+PI*.5),\n        sin(zenith), sin(zenith+PI*.5)\n    );\n    float azimuth = iMouse.x/iResolution.x*14.-7.;\n    camd.xz *= mat2(\n        cos(azimuth), cos(azimuth+PI*.5),\n        sin(azimuth), sin(azimuth+PI*.5)\n    );\n    // th = atan(camd.z, camd.x)+th;\n    // float r = length(camd.xz);\n    // camd = vec3(\n    //     cos(th),\n    //     camd.y,\n    //     sin(th)\n    // );\n    //camd = normalize(camd);\n    \n    vec3 retina = trace(camp, camd);\n\t\n    fragColor = vec4(retina, 1.);\n\t\n}\n\n\n/**/\n\n/*\n// Old code (failed)\n// Title: (WIP) MINECRAFT: METAL AND ICE\n// tags: terrain, voxel, minecraft\n// date: unknown\n// description: i am only scratching th surface of the world of raymarching. why do i even bother\n\nfloat wnoise (float ix, float iy) {\n    return mod(ix*ix*26.+ix*iy*41.+ix*55.+iy*77., 16.)/15.;\n}\n\nfloat gnoise (float px, float py) {\n    float mx = mod(px, 1.);\n    float my = mod(py, 1.);\n    mx = 3.*mx*mx-2.*mx*mx*mx;\n    my = 3.*my*my-2.*my*my*my;\n    \n    px = floor(px);\n    py = floor(py);\n    return mix(\n        mix(wnoise(px, py), wnoise(px+1., py), mx),\n        mix(wnoise(px, py+1.), wnoise(px+1., py+1.), mx),\n        my\n    );\n}\n\n// i know more\nconst float PI = 3.14159265358979323;\nvec3 sund () {\n    return normalize(\n        vec3(\n            cos(iTime),\n            1.,\n            sin(iTime)\n        )\n    );\n}\n// const vec3 sund = normalize(vec3(-3., 0., -1.));\n\nfloat h (float x, float z) {\n    return sin((x/3.)+(z/3.))*2.;\n}\n\nfloat steelSDF (vec3 p) {\n    // return length(p-vec3(0., 0., 5.))-2.;\n    // return p.y+(gnoise(p.x/7., p.z/7.)-.5)*1.;\n    return p.y+sin(p.x);\n    float SDFp = 1e6;\n    float fx = floor(p.x);\n    float fz = floor(p.z);\n    vec2 q;\n    SDFp = min(SDFp, p.y+h(fx, fz));\n    for (float x=-1.; x<=1.; ++x) {\n        if (x == 0.) {\n            continue;\n        }\n        if (p.y+h(fx+x, fz) < 0.) {\n        \tSDFp = min(SDFp, min(fract(p.x), 1.-fract(p.x) ));\n        }\n    }\n    for (float z=-1.; z<=1.; ++z) {\n        if (z == 0.) {\n            continue;\n        }\n        if (p.y+h(fx, fz+z) < 0.) {\n        \tSDFp = min(SDFp, min(fract(p.z), 1.-fract(p.z) ));\n        }\n    }\n    SDFp = p.y+h(p.x, p.z);\n    return SDFp;\n}\n\nfloat iceSDF (vec3 p) {\n    // return length(p-vec3(0., 1., 5.))-2.;\n    return p.y;\n}\n\nfloat SDF (vec3 p) {\n    return min(iceSDF(p), steelSDF(p));\n}\n\nvec3 dsteelSDF (vec3 p) {\n    float steelSDFp = steelSDF(p);\n    return normalize(\n        vec3(\n            steelSDF(vec3(p.x+1e-3, p.y, p.z))-steelSDFp,\n            steelSDF(vec3(p.x, p.y+1e-3, p.z))-steelSDFp,\n            steelSDF(vec3(p.x, p.y, p.z+1e-3))-steelSDFp\n        )\n    );\n}\n\nvec3 diceSDF (vec3 p) {\n    float iceSDFp = iceSDF(p);\n    // return normalize(\n    //     vec3(\n    //         iceSDF(vec3(p.x+1e-3, p.y, p.z))-iceSDFp,\n    //         iceSDF(vec3(p.x, p.y+1e-3, p.z))-iceSDFp,\n    //         iceSDF(vec3(p.x, p.y, p.z+1e-3))-iceSDFp\n    //     )\n    // );\n    // ;P\n    return vec3(0., 1., 0.);\n}\n\nvec3 steelTEX (vec3 p, vec3 d, vec3 dsteelSDFp) {\n    vec3 TEXp = vec3(.9, .9, .9);\n    // TEXp *= mod(floor(p.x+.5)+floor(p.z+.5), 2.);\n    float lighting = 1.;\n    lighting *= clamp(dot(dsteelSDFp, sund()), 0., 1.);\n    // lighting = .7+.3*lighting;\n    return TEXp*lighting;\n}\n\nvec3 iceTEX (vec3 p, vec3 d, vec3 diceSDFp) {\n    vec3 TEXp = vec3(.4, .8, 1.);\n    // TEXp *= .8+.2*mod(floor(p.x*3.)+floor(p.y*3.), 2.);\n    float lighting = 1.;\n    lighting *= clamp(dot(diceSDFp, sund()), 0., 1.);\n    lighting = .5+.5*lighting;\n    return TEXp*lighting;\n}\n\nfloat steelSPEX (vec3 p, vec3 d, vec3 diceSDFp) {\n    return pow(\n        clamp(\n            dot(\n                reflect(\n                    d,\n                    diceSDFp\n                ),\n            \tsund()\n            ),\n        \t0.,\n        \t1.\n        ),\n        10.\n    );\n}\n\nfloat iceSPEX (vec3 p, vec3 d, vec3 diceSDFp) {\n    return pow(\n        clamp(\n            dot(\n                reflect(\n                    d,\n                    diceSDFp\n                ),\n            \tsund()\n            ),\n        \t0.,\n        \t1.\n        ),\n        1.\n    );\n}\n\nvec3 march (vec3 p, vec3 d) {\n    float steelSDFp;\n    float iceSDFp;\n    float SDFp;\n    vec3 dsteelSDFp;\n    vec3 diceSDFp;\n    vec3 TEXp;\n    vec3 finalcol = vec3(0.);\n    float shiny = 1.;\n    float rxcount = 0.;\n    for (int i=0; i<100; ++i) {\n        steelSDFp = steelSDF(p);\n        iceSDFp = abs(iceSDF(p));\n        SDFp = min(steelSDFp, iceSDFp);\n        if (SDFp < 1e-2) {\n            p = p+d*SDFp*.95;\n            if (steelSDFp < iceSDFp) {\n            \tdsteelSDFp = dsteelSDF(p);\n                dsteelSDFp = vec3(0., 1., 0.);\n                TEXp = steelTEX(p, d, dsteelSDFp);\n                finalcol = finalcol+clamp(TEXp*.2+steelSPEX(p, d, dsteelSDFp), 0., 1.)*shiny;\n                shiny *= .8;\n                d = reflect(d, dsteelSDFp);\n                p = p+d*.2;\n                ++rxcount;\n            }\n            else {\n            \tdiceSDFp = diceSDF(p);\n                TEXp = iceTEX(p, d, diceSDFp);\n                finalcol = finalcol+clamp(TEXp*.4+iceSPEX(p, d, diceSDFp), 0., 1.)*shiny;\n                shiny *= .6;\n                // d = reflect(d, diceSDFp);\n                p = p+d*.2;\n                ++rxcount;\n            }\n            if (rxcount > 2.) {\n                break;\n            }\n            if (p.y < -10. || p.y > 20.) {\n                break;\n            }\n        }\n        p = p+d*SDFp*.7;\n        if (length(p) > 10.) {\n            p = p+d*SDFp*.2;\n        }\n    }\n    // add the sky color\n    finalcol = finalcol+shiny*vec3(0., 0., 0.);\n    return finalcol;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screen = (fragCoord-iResolution.xy/2.)/iResolution.y;\n    vec2 maus =   (iMouse.xy-iResolution.xy/2.)/iResolution.y;\n    vec3 d = normalize(vec3(screen.x, screen.y, 1.));\n    // rotate\n    float dzy = atan(d.z, d.y)+maus.y*PI*.5*3.;\n    float dzyr = sqrt(d.z*d.z+d.y*d.y);\n    d.y = dzyr*cos(dzy);\n    d.z = dzyr*sin(dzy);\n    float dzx = atan(d.z, d.x)+maus.x*PI*2.;\n    float dzxr = sqrt(d.z*d.z+d.x*d.x);\n    d.x = dzxr*cos(dzx);\n    d.z = dzxr*sin(dzx);\n    \n    \n    vec3 retina = march(vec3(0., 5., 0.), d);\n    fragColor = vec4(retina, 1.);\n}\n\n\n/**/\n\n\n\n\n\n\n\n\n\n\n// Older code\n/*\n// its hideous honestly ym eyesare bleeding i swer\n// use mouse to rotate\n// Update 2019 11/10 WHY DOES THIS HAVE SO MANY LIKES?? its incomplete and very messy\n// i know more\nconst float PI = 3.141592653589793238;\n\nconst vec3 suncol = vec3(1., 1., 1.);\n\nvec3 hadamard (vec3 a, vec3 b) {\n    return vec3(a.x*b.x, a.y*b.y, a.z*b.z);\n}\n\nfloat lerp (float a, float b, float t) {\n    float o = a+(b-a)*t;\n    o = 3.*o*o-2.*o*o*o;\n    o = 3.*o*o-2.*o*o*o;\n    return o;\n}\n\nfloat rand (float x) {\n    // chaotic not random number from 0 to 1\n    return mod(x*17.+mod(x, 3.)*2., 100.)/100.;\n}\n\nfloat lattice (float x, float y) {\n    return rand(x*2.+y*3.);\n}\n\nfloat white_noise (float x, float y) {\n    // thid should do teh trick :D\n    return mod(x*x*56.+273.65+y*x+x*y*x+y*2439459.241334, 100.)/100.;\n}\n\nfloat grad_noise (float x, float y) {\n    float mx1 = fract(x);\n    float my1 = fract(y);\n    x = floor(x);\n    y = floor(y);\n    return lerp(\n        lerp(lattice(x, y), lattice(x+1., y), mx1),\n        lerp(lattice(x, y+1.), lattice(x+1., y+1.), mx1),\n        my1\n    );\n}\n\nfloat noise (float x, float y) {\n    return (grad_noise(x/3., y/3.)*2.+grad_noise(x/5., y/5.)*2.+grad_noise(x/10., y/10.))/5.;\n}\n\nfloat SDFwater (vec3 p) {\n\t// return p.y+(sin((p.x+p.z)/2.)+sin((p.x+p.z)/2.+iTime*5.))/4.+.5;\n    return p.y;\n}\n\nfloat SDFland (vec3 p) {\n    float PH = 6.;\n    // float SDFp = p.y-cos(p.x*PI/2./10.)*3.;\n    float SDFp = p.y-noise(p.x/5., p.z/5.)*10.+3.;\n    return SDFp;\n}\n\nfloat SDF (vec3 p) {\n    float SDFp = 1e20;\n    SDFp = min(SDFp, SDFwater(p));\n    SDFp = min(SDFp, SDFland(p));\n    return SDFp;\n}\n\nvec3 dSDF (vec3 p) {\n    float SDFp = SDF(p);\n    return normalize(\n        vec3(\n            SDF(vec3(p.x+1e-4, p.y, p.z))-SDFp,\n            SDF(vec3(p.x, p.y+1e-4, p.z))-SDFp,\n            SDF(vec3(p.x, p.y, p.z+1e-4))-SDFp\n        )\n    );\n}\n\nfloat idSDF (vec3 p) {\n    float SDFlandp = SDFland(p);\n    float SDFwaterp = SDFwater(p);\n    if (SDFwaterp < SDFlandp) {\n        return 1.;\n    }\n\treturn 0.;\n}\n\nfloat rxindex (vec3 p) {\n    float idSDFp = idSDF(p);\n    if (idSDFp == 0.) {\n        return 0.;\n    }\n    if (idSDFp == 1.) {\n        return .7;\n    }\n}\n\nvec3 sund () {\n    return normalize(vec3(cos(iTime*PI*2./4.), 1., sin(iTime*PI*2./4.) ));\n}\n\nvec3 TEX (vec3 p, vec3 d) {\n    vec3 col = vec3(1., 0., 0.);\n    vec3 dSDFp = dSDF(p);\n    float idSDFp = idSDF(p);\n    float czk;\n    if (idSDFp == 0.) {\n        czk = mod(floor(p.x*3.)+floor(p.z*3.), 2.);\n        if (p.y > 2.) {\n\t\t\t// col = vec3(0., .4, 0.)*(.0+.99*white_noise(p.x, p.y));\n            col = vec3(0., .4, 0.)*czk;\n        }\n        else {\n            // col = vec3(.9, .8, .3)*(.7+.3*white_noise(p.x, p.y));\n            col = vec3(.9, .8, .3)*(.7+.3*czk);\n        }\n    }\n    if (idSDFp == 1.) {\n        czk = 1.;\n        col = vec3(.0, .2, .3)*czk;\n    }\n    vec3 lighting = vec3(1., 1., 1.);\n    // diffuse lighting\n    float ang = clamp(dot(sund(), dSDFp)/2.+1., 0., 1.);\n    ang = (dot(sund(), dSDFp)+1.)/2.;\n    // ang = clamp(dot(sund(), dSDFp), 0., 1.);\n   \tlighting = lighting*ang;\n    // ambient lighting\n    lighting = .3+lighting*.7;\n    // u cant have red light from a blue sun\n    col = hadamard(col, hadamard(lighting, suncol));\n    return col;\n}\n\nvec3 bg (vec3 d) {\n    vec3 col = vec3(.3, .7, .9);\n    col += suncol*pow( clamp(dot(sund(), d), 0., 1.), 140.);\n    col = clamp(col, 0., 1.);\n    return col;\n}\n\nvec3 march (vec3 p, vec3 d) {\n    float rxcount = 0.;\n    float shiny = 1.;\n    vec3 finalcol = vec3(0., 0., 0.);\n    float distfromcam = 0.;\n    for (int i=0; i<100; ++i) {\n        float SDFp = SDF(p);\n        if (SDFp < 1e-1) {\n            p = p+d*SDFp*.995;\n            vec3 TEXpd = TEX(p, d);\n            float rxindexp = rxindex(p);\n            if (rxindexp == 0. || rxcount > 4.) {\n                // hits solid object, final color determined\n                finalcol = finalcol+TEXpd*shiny*(1.-rxindexp);\n                return finalcol;\n            }\n            if (rxcount > 3.) {\n                // waaaay to many reflections reflect background col\n                break;\n            }\n            finalcol = finalcol+TEXpd*shiny*(1.-rxindexp);\n            shiny = shiny*rxindexp;\n            d = reflect(d, dSDF(p));\n            p = p+d*.2;\n            ++rxcount;\n        }\n        float DE = SDFp;\n        if (0. < DE && DE < 10.) {\n            DE *= .7;\n        }\n        p = p+d*DE;\n        distfromcam += DE;\n        if (distfromcam > 155.) {\n            break;\n        }\n    }\n    // diverges waaaay out into the sky. reflect sky color\n    if (rxcount > 0.) {\n        return finalcol+bg(d)*shiny;\n    }\n    return bg(d);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec2 maus = iMouse.xy;\n    if (maus.x == 0.) { maus.x = iResolution.x/2.; }\n    if (maus.y == 0.) { maus.y = iResolution.y/2.; }\n    vec2 screen = (fragCoord*2.-iResolution.xy)/iResolution.x;\n    vec3 dir1 = vec3(screen.x, screen.y, 1.);\n    dir1 = normalize(dir1);\n    float dir1zytheta = atan(dir1.z, dir1.y);\n    float dir1zyr = sqrt(dir1.z*dir1.z+dir1.y*dir1.y);\n    float dir2phi = dir1zytheta+clamp((maus.y-iResolution.y/2.)/iResolution.x*10.+0., -PI/4., PI/2.);\n    dir1.y = dir1zyr*cos(dir2phi);\n    dir1.z = dir1zyr*sin(dir2phi);\n    float dir1zxtheta = atan(dir1.z, dir1.x);\n    float dir1zxr = sqrt(dir1.z*dir1.z+dir1.x*dir1.x);\n    float dir2theta = dir1zxtheta+(maus.x-iResolution.x/2.)/iResolution.x*10./2.*2.;\n    dir1.x = dir1zxr*cos(dir2theta);\n    dir1.z = dir1zxr*sin(dir2theta);\n    float PI = PI;\n    vec3 retina = march(vec3(0., 15., iTime*3.), dir1);\n    fragColor = vec4(retina, 1.);\n}\n/**/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Oldest code\n/*\nconst vec3 origin = vec3(0., 0., 0.);\n\nconst vec3 lightcol = vec3(1., 1., 1.);\n\nvec3 hadamard (vec3 a, vec3 b) {\n    return vec3(a.x*b.x, a.y*b.y, a.z*b.z);\n}\n\nfloat waterSDF (vec3 p) {\n    return p.y+7.;\n}\n\nfloat SDF (vec3 p) {\n    p.x = mod(p.x+25., 50.)-25.;\n    float x = max(abs(p.x+sin(p.z/5.)*5.)-2., 0.);\n    // float SDFp = p.y+2.+(x > .5 ? x/2. : x*x/2.);\n    float SDFp = p.y+2.+x;\n    SDFp = min(SDFp, waterSDF(p));\n    float PI = 3.1415926;\n    float SPHSDFp = length(vec3(p.x-4., p.y-1., mod(p.z, PI*2.)-PI))-1.;\n    SDFp = min(SDFp, SPHSDFp);\n    return SDFp;\n}\n\nvec3 RFX (vec3 p) {\n    float SDFp = SDF(p);\n    return normalize(\n        vec3(\n            SDF(vec3(p.x+1e-4, p.y, p.z))-SDFp,\n            SDF(vec3(p.x, p.y+1e-4, p.z))-SDFp,\n            SDF(vec3(p.x, p.y, p.z+1e-4))-SDFp\n        )\n    );\n}\n\nvec3 TEXcolor (vec3 p, vec3 incidentd) {\n    vec3 RFXp = RFX(p);\n    vec3 headingd = reflect(incidentd, RFXp);\n    // lightning that gets obsorbed\n    float lightness = 0.;\n    // diffuse light\n        // point light\n        vec3 light1p = vec3(0., 2., 0.);\n        vec3 light1d = normalize(light1p-p);\n        // directional light\n        light1d = normalize(vec3(cos(iTime), 1., sin(iTime)));\n    \tfloat diff = 0.;\n    \tdiff = dot(light1d, RFXp);\n        // diff = dot(light1d, headingd);\n    \t// float light1dzx = atan(light1d.z, light1d.x);\n    \t// float headingdzx = atan(headingd.z, headingd.x);\n    \t// float headingdzxr = sqrt(headingd.z*headingd.z+headingd.x*headingd.x);\n    \t// headingd.x = headingdzxr*cos(headingdzx-light1dzx);\n    \t// headingd.z = headingdzxr*sin(headingdzx-light1dzx);\n    \t// float light1dyx = atan(light1d.y, light1d.x);\n    \t// float headingdyx = atan(headingd.y, headingd.x);\n    \t// float headingdyxr = sqrt(headingd.y*headingd.y+headingd.x*headingd.x);;\n    \t// headingd.x = headingdyxr*cos(headingdyx+3.141/2.-light1dyx);\n    \t// headingd.y = headingdyxr*sin(headingdyx+3.141/2.-light1dyx);\n    \t// diff = acos(headingd.y)/3.14159;\n    \t// diff = clamp(headingd.y, 0., 1.);\n    \t// diff = 1.-acos(diff)/3.14159;\n    \tdiff = clamp(diff/2.+1., 0., 1.);\n    lightness += diff;\n    // ambient light\n    // lightness = 0.3+0.7*lightness;\n    // lightness = clamp(lightness, 0., 1.);\n    \n    // texture that absorbs tje light just like in real life\n    float czk = mod(floor(p.x)+floor(p.z)+floor(p.y*0.), 2.);\n    // czk = mod(floor(p.x*3.)+floor(p.y*3.), 2.)/2.;\n    czk = mod(floor(p.y), 2.);\n    // czk = 1.;\n    vec3 col = vec3(.2)+vec3(0., czk*.5, czk*.5);\n    // combined them to get a thing 'sumcol'\n    vec3 sumcol = hadamard(lightcol*lightness, col);\n    // then add specular wich reflects all the light that hits it\n    // from major light sources\n    float specular = 0.;\n    specular = clamp(dot(light1d, headingd), 0., 1.);\n    specular = pow(specular, 3.)/2.;\n    sumcol += specular;\n    return sumcol;\n}\n\nfloat TEXrindex (vec3 p) {\n    if (waterSDF(p) < 1e-2) {\n        return .9;\n    }\n    return 0.;\n}\n\nvec3 bg (vec3 direction, float closestSDF) {\n    vec3 lightd = normalize(vec3(cos(iTime), 1., sin(iTime)));\n    float ind = clamp(dot(normalize(direction), lightd), 0., 1.);\n    vec3 glowcol = vec3(.7, 1., 1.);\n    float glowperc = pow(.3, closestSDF);\n    return pow(ind, 306.)+ind*0.+vec3(0., 0., 100./255.)*(1.-glowperc)+glowcol*glowperc;\n    // return lightcol*1.+pow(ind, 606.)*3.;\n}\n\nvec3 march (vec3 origin, vec3 direction) {\n    bool hit = false;\n    float compoundedd = 0.;\n    float closestSDF = 1e10;\n    float rcount = 0.;\n    vec3 finalTX = vec3(1.);\n    vec3 objcol;\n    for (int i=0; i<200; ++i) {\n        if ((compoundedd>100. || origin.y>16.) && rcount == 0.) {\n            return bg(direction, closestSDF);\n        }\n        float SDFp = SDF(origin);\n        closestSDF = min(closestSDF, SDFp);\n        float DE = SDF(origin);\n        if (DE > .1 && DE < 100.) {\n            DE *= .7;\n        }\n        if (SDFp < 1e-2) {\n            origin += direction*SDFp*.99;\n            objcol = TEXcolor(origin, direction);\n            if (TEXrindex(origin) == 0. && rcount == 0.) {\n            \treturn objcol;\n            }\n            if (rcount > 0.) {\n                break;\n            }\n            float shiny = pow(.7, rcount+1.);\n            direction = reflect(direction, RFX(origin));\n            origin = origin+direction*.1;\n            objcol = objcol*(1.-shiny)+bg(direction, closestSDF)*shiny;\n            rcount++;\n        }\n        origin += direction*DE;\n        compoundedd += DE;\n    }\n    if (rcount > 0.) {\n        float shiny = pow(.7, rcount+1.);\n        return objcol*(1.-shiny)+bg(direction, closestSDF)*shiny;\n    }\n    return bg(direction, closestSDF);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec2 maus = iMouse.xy;\n    if (maus.x == 0.) {\n        maus.x = iResolution.x/2.;\n    }\n    if (maus.y == 0.) {\n        maus.y = iResolution.y/2.;\n    }\n    vec2 screen = (fragCoord*2.-iResolution.xy)/iResolution.x;\n    vec3 dir1 = vec3(screen.x, screen.y, 1.);\n    dir1 = normalize(dir1);\n    float dir1zytheta = atan(dir1.z, dir1.y);\n    float dir1zyr = sqrt(dir1.z*dir1.z+dir1.y*dir1.y);\n    float dir2phi = dir1zytheta+clamp((maus.y-iResolution.y/2.)/iResolution.x*10.+0., -3.14/4., 3.14/2.);\n    dir1.y = dir1zyr*cos(dir2phi);\n    dir1.z = dir1zyr*sin(dir2phi);\n    float dir1zxtheta = atan(dir1.z, dir1.x);\n    float dir1zxr = sqrt(dir1.z*dir1.z+dir1.x*dir1.x);\n    float dir2theta = dir1zxtheta+(maus.x-iResolution.x/2.)/iResolution.x*10./2.*2.;\n    dir1.x = dir1zxr*cos(dir2theta);\n    dir1.z = dir1zxr*sin(dir2theta);\n    \n    vec3 retina = march(vec3(25., 12., mod(iTime*6., 3.1415926*10.)), dir1);\n    fragColor = vec4(retina, 1.);\n}\n/**/\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}