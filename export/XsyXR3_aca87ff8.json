{"ver":"0.1","info":{"id":"XsyXR3","date":"1466154842","viewed":191,"name":"Spherical Triangular Elevation","username":"soma_arc","description":"Terrain Raymarching + Dodecahedral tiling on sphere","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","tiling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nCreated by soma_arc - 2016\nThis work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported.\n*/\n\nvec2 cPos = vec2(-1.618033, 0.);\nvec3 spherePos = vec3(0, 0.5, 0);\nfloat sphereR = 0.5;\nfloat r = 1.90211;\nconst float PI = 3.14159265359;\nconst float EPSILON = 0.001;\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(float c) {\n    vec2 seed = vec2(c);\n    seed+=vec2(-1,1);\n\t// implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n\t\tfract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec2 circleInverse(vec2 pos, vec2 circlePos, float circleR){\n\treturn ((pos - circlePos) * circleR * circleR)/(length(pos - circlePos) * length(pos - circlePos) ) + circlePos;\n}\n\nint invCount = 0;\nconst int ITERATIONS = 20;\n\nint IIS(vec2 pos){\n    bool fund = true;\n    invCount = 1;\n\tfor(int i = 0 ; i < ITERATIONS ; i++){\n        fund = true;\n        if(pos.y < 0.){\n            pos *= vec2(1, -1);\n            invCount++;\n            fund = false;\n        }\n        if(distance(pos, cPos) > r ){\n        \tpos = circleInverse(pos, cPos, r);\n            invCount++;\n            fund = false;\n        }\n        if (atan(pos.y, pos.x) > PI/5.){\n            float theta = PI*2./5.;\n            mat2 reflectMat = mat2(cos(theta), sin(theta), sin(theta), -cos(theta));\n            pos = reflectMat * pos;\n            invCount++;\n\t       \tfund = false;\n        }\n        if(fund)\n        \treturn invCount;\n    }\n\n\treturn invCount;\n}\n\nvec2 stereoProject(vec3 p){\n\treturn vec2(p.x / (1. - p.z), p.y / (1. - p.z));\n}\n\nvec2 twistedReflect(vec2 p){\n\treturn -p / (p.x * p.x + p.y * p.y);\n}\n\nfloat intersectSphere(vec3 sphereCenter, float radius, \n                      vec3 rayOrigin){\n\tvec3 v = rayOrigin - sphereCenter;\n\tvec3 p = radius * normalize(v) + sphereCenter;\n    vec2 pos2d = stereoProject(p.xzy);\n    int d = IIS(pos2d);\n    //if(mod(float(d), 2.) == 0.)\n    //\treturn 1.2;// + abs(sin(iTime));\n    //return 1.;// + abs(cos(iTime));\n    return 1. + abs(sin(rand2n(float(d)).x * (iTime+1.) *.5));\n}\n\nfloat calcHeight(vec3 p){\n    return intersectSphere(spherePos, sphereR, p) * sphereR;\n}\n\nconst vec3 BLACK = vec3(0);\nfloat march(vec3 rayOrigin, vec3 rayDir){\n    const float delt = 0.01;\n    const float mint = .5;\n    const float maxt = 5.;\n    for( float t = mint; t < maxt; t += delt ) {\n        vec3 p = rayOrigin + rayDir * t;\n        if( distance(p, spherePos) < calcHeight(p)) {\n            return t - 0.5 * delt;\n        }\n    }\n    return -1.;\n}\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n  float imagePlane = (height * .5) / tan(fov * .5);\n  vec3 v = normalize(target - eye);\n  vec3 xaxis = normalize(cross(v, up));\n  vec3 yaxis =  normalize(cross(v, xaxis));\n  vec3 center = v * imagePlane;\n  vec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));\n  return normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));\n}\n\nconst vec4 K = vec4(1.0, .666666, .333333, 3.0);\nvec3 hsv2rgb(const vec3 c){\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nconst vec2 d = vec2(0.01, 0.);\nvec3 calcNormal(const vec3 p){\n  return normalize(vec3(calcHeight(p - d.xyy) - calcHeight(p + d.xyy),\n//                     \t calcHeight(p - d.yxy) - calcHeight(p + d.yxy),\n                                             \t2. * d.x,\n                     \t calcHeight(p - d.yyx) - calcHeight(p + d.yyx)));\n}\n\nconst float PI_4 = 12.566368;\nconst vec3 LIGHTING_FACT = vec3(0.);\nvec3 diffuseLighting(const vec3 p, const vec3 n, const vec3 diffuseColor,\n                     const vec3 lightPos, const vec3 lightPower){\n  vec3 v = lightPos - p;\n  float dot = dot(n, normalize(v));\n  float r = length(v);\n  return (dot > 0.) ?\n    (lightPower * (dot / (PI_4 * r * r))) * diffuseColor\n    : LIGHTING_FACT * diffuseColor;\n}\n\nvec3 lightPos = vec3(0, 100, 0);\nconst vec3 lightPower = vec3(50000.);\nvec3 calcColor(vec3 eye, vec3 ray){\n  \tvec3 l = BLACK;\n  \tfloat coeff = 1.;\n    float t = march(eye, ray);\n  \t\n    if(t >= 0.){\n        vec3 intersection = eye + ray * t;\n        vec3 normal = calcNormal(intersection);\n     //vec3 matColor = vec3(hsv2rgb(vec3(distance(intersection,vec3(0,0.5,0))>0.505?0.1:0.3 ,1., 1.)));\n   \t //vec3 matColor = vec3(hsv2rgb(vec3(mod(float(invCount), 2.) == 0.?0.1:0.3 ,1., 1.)));\n        vec3 matColor = vec3(hsv2rgb(vec3(mod(float(invCount), 2.) == 0.?float(invCount)*0.05:0.5+float(invCount)*0.05 ,1., 1.)));\n        l += diffuseLighting(intersection, normal, matColor, lightPos, lightPower);\n    }\n  \treturn l;\n}\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n  return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nconst vec3 target = vec3(0, 0.5, 0);\nconst vec3 up = vec3(0, 1, 0);\nfloat fov = radians(60.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  const vec2 coordOffset = vec2(0.5);\n  vec3 eye = vec3(1.5 * sin(iTime), 2., 1.5 * cos(iTime) );\n  vec3 ray = calcRay(eye, target, up, fov,\n                     iResolution.x, iResolution.y,\n                     gl_FragCoord.xy + coordOffset);\n\n  fragColor = vec4(gammaCorrect(calcColor(eye, ray)), 1.);\n}","name":"Image","description":"","type":"image"}]}