{"ver":"0.1","info":{"id":"wdGyWR","date":"1602681477","viewed":158,"name":"Software Rasterizer","username":"copperbotte","description":"Software rasterization, with a simple shadow map.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["rasterization"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//color space transforms\nfloat lsrgb2srgb(in float lsrgb)\n{\n    if(lsrgb < 0.0031308)\n        return lsrgb * 12.92;\n    float a = 1.055;\n    return a * pow(lsrgb, 1.0/2.4) - (a - 1.0);\n}\n\nvec3 lsrgb2srgb(in vec3 lsrgb)\n{\n    return vec3(lsrgb2srgb(lsrgb.x),lsrgb2srgb(lsrgb.y),lsrgb2srgb(lsrgb.z));\n}\n\nfloat srgb2lsrgb(in float srgb)\n{\n    if(srgb < 0.04045)\n        return srgb / 12.92;\n    float a = 1.055;\n    return pow(1.0 + (srgb - 1.0) / a, 2.4);\n}\n\nvec3 srgb2lsrgb(in vec3 srgb)\n{\n    return vec3(srgb2lsrgb(srgb.x),srgb2lsrgb(srgb.y),srgb2lsrgb(srgb.z));\n}\n\n//https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 rgb2hsv(in vec3 rgb)\n{\n\tvec4 k = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(rgb.bg, k.wz), vec4(rgb.gb, k.xy), step(rgb.b, rgb.g));\n    vec4 q = mix(vec4(p.xyw, rgb.r), vec4(rgb.r, p.yzx), step(p.x, rgb.r));\n    \n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    \n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(in vec3 hsv)\n{\n\tvec4 k = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(hsv.xxx + k.xyz) * 6.0 - k.www);\n    return hsv.z * mix(k.xxx, clamp(p - k.xxx, 0.0, 1.0), hsv.y);    \n}\n\nvec3 saturationClip(in vec3 rgb)\n{\n    vec3 hsv = rgb2hsv(rgb);\n    \n    if(1.0 < hsv.z)\n        hsv.yz /= hsv.z;\n    \n    return hsv2rgb(hsv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texture(iChannel0, fragCoord/iResolution.xy).xyz;\n    \n    //saturation projection\n    col = saturationClip(col);\n    \n    //convert color space from lsrgb to srgb\n    col = lsrgb2srgb(col);\n    \n\t//output image\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n//vbuffer\n//this is a model of the stanford bunny, decimated in blender with triangulation to 128 tris.\n//this python script is then applied to the resulting .obj model to convert it to this format:\n//vbuff = \"\"\" ... \"\"\"\t\t\t\t\t\t\t\t  # this is the vertex buffer, with the \"v\" format.\n//vb2 = [a.split(' ')[1:] for a in vbuff.split('\\n')] #makes a list of lists, strips the v.\n//vo = \"\"\n//for tri in vb2:\n//    vo += \"vec4(%s, %s, %s, 1.0),\\n\" % tuple(tri)   #makes a string of vec4 elements\n//print(vo)                                           #vo is what is written below, as vbuffer\n\nvec4 vbuffer[66] = vec4[66](\n    vec4(0.958839, 0.266724, 1.443269, 1.0),\n    vec4(-1.300110, 0.162805, 2.831713, 1.0),\n    vec4(-4.747822, 5.014085, 0.821022, 1.0),\n    vec4(-1.442004, 5.780937, 1.808076, 1.0),\n    vec4(-2.318545, 7.939757, 1.024962, 1.0),\n    vec4(0.578863, 6.029078, 2.092660, 1.0),\n    vec4(0.355957, 8.267916, -0.808063, 1.0),\n    vec4(-0.292910, 9.883357, -0.864159, 1.0),\n    vec4(5.086565, 2.465895, 1.200150, 1.0),\n    vec4(-2.814757, 7.370413, -0.179435, 1.0),\n    vec4(-3.247441, 7.734357, -3.342923, 1.0),\n    vec4(-3.735043, 1.942311, 1.003896, 1.0),\n    vec4(-4.071073, 9.044668, -2.891740, 1.0),\n    vec4(-3.107624, 3.428051, -1.338644, 1.0),\n    vec4(-3.685019, 0.054145, 0.540416, 1.0),\n    vec4(-4.364438, 6.855221, 3.275381, 1.0),\n    vec4(1.502600, 6.361782, 0.118895, 1.0),\n    vec4(-4.732244, 7.508119, 1.254780, 1.0),\n    vec4(-3.396537, 5.285670, 3.563933, 1.0),\n    vec4(-4.770891, 4.025372, 1.476797, 1.0),\n    vec4(-0.187690, 3.762182, 3.835387, 1.0),\n    vec4(0.292728, 9.487623, -1.720766, 1.0),\n    vec4(1.927758, 0.131275, 2.917917, 1.0),\n    vec4(3.352051, 1.113109, 2.292715, 1.0),\n    vec4(3.758426, 4.537707, -0.318181, 1.0),\n    vec4(1.627294, 4.732998, 2.969565, 1.0),\n    vec4(-3.890874, 7.272460, -0.357972, 1.0),\n    vec4(-2.058447, 6.694858, 0.227077, 1.0),\n    vec4(4.845649, 1.032457, 1.301659, 1.0),\n    vec4(-1.975306, 3.835867, 3.017735, 1.0),\n    vec4(3.769710, 1.460197, -0.438896, 1.0),\n    vec4(-4.926750, 5.220490, 2.775886, 1.0),\n    vec4(2.769115, 3.492326, 3.302084, 1.0),\n    vec4(-4.297833, 5.743647, -0.289439, 1.0),\n    vec4(-0.661861, 4.425951, -1.382365, 1.0),\n    vec4(2.913474, 5.715573, 1.900639, 1.0),\n    vec4(-2.271390, 1.549972, 2.222723, 1.0),\n    vec4(-0.734289, 1.321469, 2.476397, 1.0),\n    vec4(-0.459241, 4.279339, 2.991758, 1.0),\n    vec4(0.018167, 1.105121, 3.278054, 1.0),\n    vec4(-3.867378, 7.784256, -0.001812, 1.0),\n    vec4(1.410773, 1.640430, 3.771088, 1.0),\n    vec4(-2.518578, 1.394690, 0.150844, 1.0),\n    vec4(-2.628563, 6.925992, 2.279535, 1.0),\n    vec4(-1.000049, 1.249540, -0.597956, 1.0),\n    vec4(3.631215, 3.139428, -0.792511, 1.0),\n    vec4(3.066831, -0.036837, 0.750446, 1.0),\n    vec4(2.636083, 1.235894, -1.499107, 1.0),\n    vec4(-0.639350, 3.306185, -2.442304, 1.0),\n    vec4(-3.548184, 4.711820, 2.556335, 1.0),\n    vec4(-3.162743, 9.496496, -3.763538, 1.0),\n    vec4(4.192937, 2.761569, 1.184182, 1.0),\n    vec4(-0.777987, 0.267966, 3.739648, 1.0),\n    vec4(-3.026660, 0.134489, 3.055478, 1.0),\n    vec4(-4.405719, 3.473636, -0.332427, 1.0),\n    vec4(1.338161, 5.255086, -1.145308, 1.0),\n    vec4(-1.648821, 0.128784, -1.940353, 1.0),\n    vec4(-0.467044, 5.626334, -0.540899, 1.0),\n    vec4(-1.321962, 3.212960, -1.354884, 1.0),\n    vec4(0.980224, 1.869646, -2.221987, 1.0),\n    vec4(2.068294, 4.161321, -1.556098, 1.0),\n    vec4(-0.443658, 0.893707, -1.731797, 1.0),\n    vec4(1.783108, 0.125406, -1.100781, 1.0),\n    vec4(-3.918510, 2.886163, 2.593541, 1.0),\n    vec4(-1.228898, 0.021466, 0.749603, 1.0),\n    vec4(-1.748716, 0.161099, -0.935354, 1.0)\n);\n\n//ibuffer\n//Like vbuffer above, ibuffer is processed from the same .obj model with this script:\n//ibuff = \"\"\" ... \"\"\"\t\t\t\t\t\t\t\t  # this is the index buffer, with the \"f\" format.\n//ib2 = [a.split(' ')[1:] for a in ibuff.split('\\n')] #makes a list of lists, strips the f.\n//io = \"\"\n//for tri in ib2:\n//    tri = [int(x)-1 for x in tri]\n//    io += ivec4(\"%i, %i, %i, 0),\\n\" % tuple(tri)   #makes a string of indices\n//print(io)   \n\nivec4 ibuffer[128] = ivec4[128](\n    ivec4(22, 52, 1, 0),\n    ivec4(22, 1, 0, 0),\n    ivec4(65, 1, 64, 0),\n    ivec4(12, 40, 50, 0),\n    ivec4(40, 4, 9, 0),\n    ivec4(16, 3, 5, 0),\n    ivec4(16, 5, 35, 0),\n    ivec4(29, 49, 63, 0),\n    ivec4(22, 41, 39, 0),\n    ivec4(56, 61, 62, 0),\n    ivec4(17, 33, 2, 0),\n    ivec4(46, 47, 30, 0),\n    ivec4(35, 5, 25, 0),\n    ivec4(29, 3, 49, 0),\n    ivec4(32, 25, 20, 0),\n    ivec4(51, 45, 24, 0),\n    ivec4(29, 63, 36, 0),\n    ivec4(37, 29, 36, 0),\n    ivec4(20, 25, 38, 0),\n    ivec4(37, 38, 29, 0),\n    ivec4(38, 3, 29, 0),\n    ivec4(63, 54, 11, 0),\n    ivec4(32, 20, 41, 0),\n    ivec4(5, 3, 38, 0),\n    ivec4(8, 51, 23, 0),\n    ivec4(25, 5, 38, 0),\n    ivec4(39, 41, 20, 0),\n    ivec4(43, 15, 18, 0),\n    ivec4(28, 8, 23, 0),\n    ivec4(54, 63, 19, 0),\n    ivec4(30, 28, 46, 0),\n    ivec4(49, 3, 18, 0),\n    ivec4(1, 37, 53, 0),\n    ivec4(4, 6, 7, 0),\n    ivec4(23, 32, 41, 0),\n    ivec4(3, 43, 18, 0),\n    ivec4(6, 27, 21, 0),\n    ivec4(51, 32, 23, 0),\n    ivec4(6, 21, 7, 0),\n    ivec4(23, 41, 22, 0),\n    ivec4(30, 8, 28, 0),\n    ivec4(22, 39, 52, 0),\n    ivec4(27, 6, 4, 0),\n    ivec4(32, 51, 35, 0),\n    ivec4(37, 36, 53, 0),\n    ivec4(9, 10, 50, 0),\n    ivec4(61, 56, 44, 0),\n    ivec4(62, 47, 46, 0),\n    ivec4(47, 45, 30, 0),\n    ivec4(17, 40, 33, 0),\n    ivec4(19, 2, 54, 0),\n    ivec4(62, 1, 65, 0),\n    ivec4(42, 13, 58, 0),\n    ivec4(27, 4, 43, 0),\n    ivec4(24, 35, 51, 0),\n    ivec4(50, 40, 9, 0),\n    ivec4(3, 27, 43, 0),\n    ivec4(4, 15, 43, 0),\n    ivec4(4, 17, 15, 0),\n    ivec4(27, 3, 57, 0),\n    ivec4(17, 4, 40, 0),\n    ivec4(24, 16, 35, 0),\n    ivec4(16, 57, 3, 0),\n    ivec4(39, 20, 37, 0),\n    ivec4(1, 52, 37, 0),\n    ivec4(37, 52, 39, 0),\n    ivec4(15, 31, 18, 0),\n    ivec4(37, 20, 38, 0),\n    ivec4(63, 49, 19, 0),\n    ivec4(2, 19, 49, 0),\n    ivec4(50, 26, 12, 0),\n    ivec4(26, 50, 10, 0),\n    ivec4(61, 58, 48, 0),\n    ivec4(58, 34, 48, 0),\n    ivec4(55, 57, 16, 0),\n    ivec4(61, 44, 58, 0),\n    ivec4(36, 42, 14, 0),\n    ivec4(26, 40, 12, 0),\n    ivec4(9, 4, 7, 0),\n    ivec4(9, 7, 21, 0),\n    ivec4(2, 33, 54, 0),\n    ivec4(34, 60, 48, 0),\n    ivec4(17, 31, 15, 0),\n    ivec4(2, 31, 17, 0),\n    ivec4(33, 40, 26, 0),\n    ivec4(42, 11, 54, 0),\n    ivec4(45, 51, 30, 0),\n    ivec4(60, 24, 45, 0),\n    ivec4(16, 24, 55, 0),\n    ivec4(51, 8, 30, 0),\n    ivec4(27, 13, 33, 0),\n    ivec4(34, 13, 27, 0),\n    ivec4(25, 32, 35, 0),\n    ivec4(65, 14, 42, 0),\n    ivec4(27, 57, 34, 0),\n    ivec4(33, 26, 9, 0),\n    ivec4(54, 13, 42, 0),\n    ivec4(13, 54, 33, 0),\n    ivec4(42, 58, 44, 0),\n    ivec4(47, 59, 45, 0),\n    ivec4(60, 45, 59, 0),\n    ivec4(56, 65, 44, 0),\n    ivec4(33, 9, 27, 0),\n    ivec4(62, 59, 47, 0),\n    ivec4(61, 59, 62, 0),\n    ivec4(65, 42, 44, 0),\n    ivec4(58, 13, 34, 0),\n    ivec4(9, 21, 27, 0),\n    ivec4(34, 55, 60, 0),\n    ivec4(60, 55, 24, 0),\n    ivec4(59, 48, 60, 0),\n    ivec4(48, 59, 61, 0),\n    ivec4(62, 65, 56, 0),\n    ivec4(9, 26, 10, 0),\n    ivec4(2, 49, 31, 0),\n    ivec4(18, 31, 49, 0),\n    ivec4(22, 46, 23, 0),\n    ivec4(46, 22, 0, 0),\n    ivec4(28, 23, 46, 0),\n    ivec4(57, 55, 34, 0),\n    ivec4(42, 36, 11, 0),\n    ivec4(36, 63, 11, 0),\n    ivec4(36, 14, 53, 0),\n    ivec4(64, 14, 65, 0),\n    ivec4(46, 0, 62, 0),\n    ivec4(1, 53, 14, 0),\n    ivec4(62, 0, 1, 0),\n    ivec4(1, 14, 64, 0)\n);\n\n//point in tri\n//https://www.shadertoy.com/view/WsVczw\n\nbool inTri(in vec3 point, in mat3 tri, out vec2 coords)\n{\n    //move space toward first vertex\n    //maybe use a mul?\n    point -= tri[0];\n    tri -= mat3(tri[0],tri[0],tri[0]);\n    \n    //using v1 and v2 as a basis, find a vector normal to both to build a plane\n    vec3 norm = normalize(cross(tri[1], tri[2]));\n    \n    //find the projection of vt onto the normal\n    float proj = dot(point, norm);\n    \n    //if(proj * proj < 0.01) // point is not on plane of triangle\n    //    return false;\n    \n    //move point onto plane of triangle\n    point -= norm * proj;\n    \n    //v1 and v2 form a basis space, whose linear combination is vt. vt = a*v1 + b*v2.\n    //Since vt is guaranteed to be on the plane between the two, its psuedoinverse is its inverse.\n    //moore-penrose psuedoinverse: (MT*M)^-1 * MT = M+\n    \n    mat2x3 space = mat2x3(tri[1], tri[2]); // can this be truncated from tri?\n    mat3x2 st = transpose(space);\n    mat2x2 inv = st * space;\n    \n    //if the inverse's inputs has no determinant, it covers no area, and has no inverse.\n    if(determinant(inv) == 0.0)\n        return false;\n    \n    mat3x2 mpi = inverse(inv) * st;\n    vec2 mpipt = mpi * point; // move into basis space\n    \n    //if the point does not lie within the unit triangle, it misses.\n    if(mpipt.x < 0.0)\n        return false;\n    if(mpipt.y < 0.0)\n        return false;\n    if(1.0 < dot(mpipt, vec2(1,1)))\n       return false;\n    \n    coords = mpipt;\n    return true;\n}\n\nmat4 vshader_matrix_world()\n{\n    //simple rotation matrix\n    mat4 rotate = mat4(1.0);\n    rotate[0][0] = cos(iTime);\n    rotate[0][2] = sin(iTime);\n    rotate[2][0] =-rotate[0][2];\n    rotate[2][2] = rotate[0][0];\n    \n    mat4 scale = mat4(1.0 / 10.0);\n    scale[3][3] = 1.0;\n    \n    mat4 translate = mat4(1.0);\n    //translate[3] += vec4(0,-0.25,-1.0,0.0);\n    //translate[3] += vec4(0,-0.25,0.0,0.0);\n    //translate[3] += vec4(0,-0.1,0.0,0.0);\n    translate[3] += vec4(0,-0.5,0.0,0.0);\n    \n    mat4 world = translate * scale * rotate;\n    \n    return world;\n}\n\nmat4 vshader_shadowmap_matrix_viewproj()\n{\n    mat4 rotate_right = mat4(1.0);\n    float rt = (1.0 / 8.0) * 3.141592 * 2.0;\n    rotate_right[0][0] = cos(rt);\n    rotate_right[0][2] = sin(rt);\n    rotate_right[2][0] =-sin(rt);\n    rotate_right[2][2] = cos(rt);\n    \n    mat4 rotate_up = mat4(1.0);\n    rotate_up[1][1] = cos(2.0 * 3.141592 * (-1.0 / 8.0));\n    rotate_up[1][2] = sin(2.0 * 3.141592 * (-1.0 / 8.0));\n    rotate_up[2][1] =-rotate_up[1][2];\n    rotate_up[2][2] = rotate_up[1][1];\n    \n    mat4 view = mat4(1.0);\n    view[3] += vec4(0.0,0.0,2.5,0.0);\n    \n    //view = rotate_up * rotate_right * view;\n    view = view * rotate_up * rotate_right;\n    \n    mat4 proj = mat4(1.0);\n    float width = 1.0;\n    float height = iResolution.y / iResolution.x;\n    float near = 1.0;\n    float far = 10.0;\n    proj[0][0] = 2.0 * near / width;\n    proj[1][1] = 2.0 * near / height;\n    proj[2][2] = -far / (near - far);\n    proj[3][2] = near * far / (near - far);\n    proj[2][3] = 1.0;\n    proj[3][3] = 0.0;\n    \n    mat4 vp = proj * view;\n    \n    return vp;\n}\n\nmat4 vshader_matrix_viewproj()\n{\n    mat4 view = mat4(1.0);\n    view[3] += vec4(0.0,0.0,2.5,0.0);\n    \n    mat4 proj = mat4(1.0);\n    float width = 1.0;\n    float height = iResolution.y / iResolution.x;\n    float near = 1.0;\n    float far = 10.0;\n    proj[0][0] = 2.0 * near / width;\n    proj[1][1] = 2.0 * near / height;\n    proj[2][2] = -far / (near - far);\n    proj[3][2] = near * far / (near - far);\n    proj[2][3] = 1.0;\n    proj[3][3] = 0.0;\n    \n    mat4 vp = proj * view;\n    \n    return vp;\n}\n\n\nvec4 vshader(in vec4 mPos)\n{\n    mat4 world = vshader_matrix_world();\n    //mat4 viewproj = vshader_matrix_viewproj();\n    mat4 viewproj = vshader_shadowmap_matrix_viewproj();\n    mat4 wvp = viewproj * world;\n    \n    vec4 sPos = wvp * mPos;\n    \n    return sPos;\n}\n\nvec3 pshader(in vec4 sPos, in vec4 wPos, in vec3 normal)\n{\n    //transform to projected screen\n    mat4 sm_m_vp = vshader_shadowmap_matrix_viewproj();\n    vec4 sm_sPos = sm_m_vp * wPos;\n    sm_sPos /= sm_sPos.w;\n    \n    return sm_sPos.xyz;\n    \n    //find ray origin\n    //mat4 sm_im_vp = inverse(sm_m_vp); // slow, can be brought into the pshader\n    //vec4 sm_wPos = sm_im_vp * vec4(sm_sPos.xy, 0.0, 1.0);\n    vec4 sm_wPos = vec4(vec3(0,-0.25,-1.0), 1.0);\n    \n    //correct for projection screen\n    sm_sPos.xy = (sm_sPos.xy + 1.0) / 2.0;\n\n    //shadow map texture\n    float dtest = texture(iChannel0, sm_sPos.xy).x;\n    bvec4 bbox = bvec4(sm_sPos.x < 0.0, sm_sPos.y < 0.0, 1.0 < sm_sPos.x, 1.0 < sm_sPos.x);\n\n    //shadow map test\n    vec3 col = texture(iChannel1, sm_sPos.xy).xyz * 0.5 + 0.5;\n    //if(0.01 < dtest - sm_sPos.z || any(bbox))\n    //    return vec3(0.25);\n    \n    //phong brdf\n    vec3 Li = normalize(sm_wPos.xyz - wPos.xyz);\n    \n    float diffuse = max(0.0, dot(normal, Li));\n    \n    //col = vec3(1) * diffuse;\n    \n    //col *= diffuse;\n        \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 xy = uv * 2.0 - 1.0;\n\t\n    //zbuffer\n    float depth = 100000.0;\n    \n    for(int i=0; i<128; i++)\n    {\n        //get a single triangle from the index buffer\n        ivec3 tri = ibuffer[i].xyz;\n        \n        //look up associated vertices, and do a simple resize\n        vec4 v0 = vshader(vbuffer[tri[0]]);\n        vec4 v1 = vshader(vbuffer[tri[1]]);\n        vec4 v2 = vshader(vbuffer[tri[2]]);\n        mat3 vin = mat3(v0.xyz/v0.w, v1.xyz/v1.w, v2.xyz/v2.w);\n        \n        //setup const z-clipping matrix\n        mat3 zclip = mat3(1.0);\n        zclip[2][2] = 0.0;\n        \n        //if point is within a triangle, display a color\n        vec2 coords;\n        if(inTri(vec3(xy,0.0), zclip*vin, coords))\n        {\n            //from the barycentric coords, lerp vertex values (for zbuffer, useful for uvs or normals)\n            vec4 sOut = mat3x4(v1 - v0, v2 - v0, v0) * vec3(coords, 1.0);\n            vec3 outPos = sOut.xyz / sOut.w;\n            \n            if(outPos.z < depth)\n                depth = outPos.z;\n        }\n    }\n    \n    vec3 col = vec3(1) * clamp(depth,0.0,1.0);\n    \n    //col = texture(iChannel1, uv).xyz;\n    \n    //col = vec3(uv, 0.0);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n//vbuffer\n//this is a model of the stanford bunny, decimated in blender with triangulation to 128 tris.\n//this python script is then applied to the resulting .obj model to convert it to this format:\n//vbuff = \"\"\" ... \"\"\"\t\t\t\t\t\t\t\t  # this is the vertex buffer, with the \"v\" format.\n//vb2 = [a.split(' ')[1:] for a in vbuff.split('\\n')] #makes a list of lists, strips the v.\n//vo = \"\"\n//for tri in vb2:\n//    vo += \"vec4(%s, %s, %s, 1.0),\\n\" % tuple(tri)   #makes a string of vec4 elements\n//print(vo)                                           #vo is what is written below, as vbuffer\n\nvec4 vbuffer[66] = vec4[66](\n    vec4(0.958839, 0.266724, 1.443269, 1.0),\n    vec4(-1.300110, 0.162805, 2.831713, 1.0),\n    vec4(-4.747822, 5.014085, 0.821022, 1.0),\n    vec4(-1.442004, 5.780937, 1.808076, 1.0),\n    vec4(-2.318545, 7.939757, 1.024962, 1.0),\n    vec4(0.578863, 6.029078, 2.092660, 1.0),\n    vec4(0.355957, 8.267916, -0.808063, 1.0),\n    vec4(-0.292910, 9.883357, -0.864159, 1.0),\n    vec4(5.086565, 2.465895, 1.200150, 1.0),\n    vec4(-2.814757, 7.370413, -0.179435, 1.0),\n    vec4(-3.247441, 7.734357, -3.342923, 1.0),\n    vec4(-3.735043, 1.942311, 1.003896, 1.0),\n    vec4(-4.071073, 9.044668, -2.891740, 1.0),\n    vec4(-3.107624, 3.428051, -1.338644, 1.0),\n    vec4(-3.685019, 0.054145, 0.540416, 1.0),\n    vec4(-4.364438, 6.855221, 3.275381, 1.0),\n    vec4(1.502600, 6.361782, 0.118895, 1.0),\n    vec4(-4.732244, 7.508119, 1.254780, 1.0),\n    vec4(-3.396537, 5.285670, 3.563933, 1.0),\n    vec4(-4.770891, 4.025372, 1.476797, 1.0),\n    vec4(-0.187690, 3.762182, 3.835387, 1.0),\n    vec4(0.292728, 9.487623, -1.720766, 1.0),\n    vec4(1.927758, 0.131275, 2.917917, 1.0),\n    vec4(3.352051, 1.113109, 2.292715, 1.0),\n    vec4(3.758426, 4.537707, -0.318181, 1.0),\n    vec4(1.627294, 4.732998, 2.969565, 1.0),\n    vec4(-3.890874, 7.272460, -0.357972, 1.0),\n    vec4(-2.058447, 6.694858, 0.227077, 1.0),\n    vec4(4.845649, 1.032457, 1.301659, 1.0),\n    vec4(-1.975306, 3.835867, 3.017735, 1.0),\n    vec4(3.769710, 1.460197, -0.438896, 1.0),\n    vec4(-4.926750, 5.220490, 2.775886, 1.0),\n    vec4(2.769115, 3.492326, 3.302084, 1.0),\n    vec4(-4.297833, 5.743647, -0.289439, 1.0),\n    vec4(-0.661861, 4.425951, -1.382365, 1.0),\n    vec4(2.913474, 5.715573, 1.900639, 1.0),\n    vec4(-2.271390, 1.549972, 2.222723, 1.0),\n    vec4(-0.734289, 1.321469, 2.476397, 1.0),\n    vec4(-0.459241, 4.279339, 2.991758, 1.0),\n    vec4(0.018167, 1.105121, 3.278054, 1.0),\n    vec4(-3.867378, 7.784256, -0.001812, 1.0),\n    vec4(1.410773, 1.640430, 3.771088, 1.0),\n    vec4(-2.518578, 1.394690, 0.150844, 1.0),\n    vec4(-2.628563, 6.925992, 2.279535, 1.0),\n    vec4(-1.000049, 1.249540, -0.597956, 1.0),\n    vec4(3.631215, 3.139428, -0.792511, 1.0),\n    vec4(3.066831, -0.036837, 0.750446, 1.0),\n    vec4(2.636083, 1.235894, -1.499107, 1.0),\n    vec4(-0.639350, 3.306185, -2.442304, 1.0),\n    vec4(-3.548184, 4.711820, 2.556335, 1.0),\n    vec4(-3.162743, 9.496496, -3.763538, 1.0),\n    vec4(4.192937, 2.761569, 1.184182, 1.0),\n    vec4(-0.777987, 0.267966, 3.739648, 1.0),\n    vec4(-3.026660, 0.134489, 3.055478, 1.0),\n    vec4(-4.405719, 3.473636, -0.332427, 1.0),\n    vec4(1.338161, 5.255086, -1.145308, 1.0),\n    vec4(-1.648821, 0.128784, -1.940353, 1.0),\n    vec4(-0.467044, 5.626334, -0.540899, 1.0),\n    vec4(-1.321962, 3.212960, -1.354884, 1.0),\n    vec4(0.980224, 1.869646, -2.221987, 1.0),\n    vec4(2.068294, 4.161321, -1.556098, 1.0),\n    vec4(-0.443658, 0.893707, -1.731797, 1.0),\n    vec4(1.783108, 0.125406, -1.100781, 1.0),\n    vec4(-3.918510, 2.886163, 2.593541, 1.0),\n    vec4(-1.228898, 0.021466, 0.749603, 1.0),\n    vec4(-1.748716, 0.161099, -0.935354, 1.0)\n);\n\n//ibuffer\n//Like vbuffer above, ibuffer is processed from the same .obj model with this script:\n//ibuff = \"\"\" ... \"\"\"\t\t\t\t\t\t\t\t  # this is the index buffer, with the \"f\" format.\n//ib2 = [a.split(' ')[1:] for a in ibuff.split('\\n')] #makes a list of lists, strips the f.\n//io = \"\"\n//for tri in ib2:\n//    tri = [int(x)-1 for x in tri]\n//    io += ivec4(\"%i, %i, %i, 0),\\n\" % tuple(tri)   #makes a string of indices\n//print(io)   \n\nivec4 ibuffer[128] = ivec4[128](\n    ivec4(22, 52, 1, 0),\n    ivec4(22, 1, 0, 0),\n    ivec4(65, 1, 64, 0),\n    ivec4(12, 40, 50, 0),\n    ivec4(40, 4, 9, 0),\n    ivec4(16, 3, 5, 0),\n    ivec4(16, 5, 35, 0),\n    ivec4(29, 49, 63, 0),\n    ivec4(22, 41, 39, 0),\n    ivec4(56, 61, 62, 0),\n    ivec4(17, 33, 2, 0),\n    ivec4(46, 47, 30, 0),\n    ivec4(35, 5, 25, 0),\n    ivec4(29, 3, 49, 0),\n    ivec4(32, 25, 20, 0),\n    ivec4(51, 45, 24, 0),\n    ivec4(29, 63, 36, 0),\n    ivec4(37, 29, 36, 0),\n    ivec4(20, 25, 38, 0),\n    ivec4(37, 38, 29, 0),\n    ivec4(38, 3, 29, 0),\n    ivec4(63, 54, 11, 0),\n    ivec4(32, 20, 41, 0),\n    ivec4(5, 3, 38, 0),\n    ivec4(8, 51, 23, 0),\n    ivec4(25, 5, 38, 0),\n    ivec4(39, 41, 20, 0),\n    ivec4(43, 15, 18, 0),\n    ivec4(28, 8, 23, 0),\n    ivec4(54, 63, 19, 0),\n    ivec4(30, 28, 46, 0),\n    ivec4(49, 3, 18, 0),\n    ivec4(1, 37, 53, 0),\n    ivec4(4, 6, 7, 0),\n    ivec4(23, 32, 41, 0),\n    ivec4(3, 43, 18, 0),\n    ivec4(6, 27, 21, 0),\n    ivec4(51, 32, 23, 0),\n    ivec4(6, 21, 7, 0),\n    ivec4(23, 41, 22, 0),\n    ivec4(30, 8, 28, 0),\n    ivec4(22, 39, 52, 0),\n    ivec4(27, 6, 4, 0),\n    ivec4(32, 51, 35, 0),\n    ivec4(37, 36, 53, 0),\n    ivec4(9, 10, 50, 0),\n    ivec4(61, 56, 44, 0),\n    ivec4(62, 47, 46, 0),\n    ivec4(47, 45, 30, 0),\n    ivec4(17, 40, 33, 0),\n    ivec4(19, 2, 54, 0),\n    ivec4(62, 1, 65, 0),\n    ivec4(42, 13, 58, 0),\n    ivec4(27, 4, 43, 0),\n    ivec4(24, 35, 51, 0),\n    ivec4(50, 40, 9, 0),\n    ivec4(3, 27, 43, 0),\n    ivec4(4, 15, 43, 0),\n    ivec4(4, 17, 15, 0),\n    ivec4(27, 3, 57, 0),\n    ivec4(17, 4, 40, 0),\n    ivec4(24, 16, 35, 0),\n    ivec4(16, 57, 3, 0),\n    ivec4(39, 20, 37, 0),\n    ivec4(1, 52, 37, 0),\n    ivec4(37, 52, 39, 0),\n    ivec4(15, 31, 18, 0),\n    ivec4(37, 20, 38, 0),\n    ivec4(63, 49, 19, 0),\n    ivec4(2, 19, 49, 0),\n    ivec4(50, 26, 12, 0),\n    ivec4(26, 50, 10, 0),\n    ivec4(61, 58, 48, 0),\n    ivec4(58, 34, 48, 0),\n    ivec4(55, 57, 16, 0),\n    ivec4(61, 44, 58, 0),\n    ivec4(36, 42, 14, 0),\n    ivec4(26, 40, 12, 0),\n    ivec4(9, 4, 7, 0),\n    ivec4(9, 7, 21, 0),\n    ivec4(2, 33, 54, 0),\n    ivec4(34, 60, 48, 0),\n    ivec4(17, 31, 15, 0),\n    ivec4(2, 31, 17, 0),\n    ivec4(33, 40, 26, 0),\n    ivec4(42, 11, 54, 0),\n    ivec4(45, 51, 30, 0),\n    ivec4(60, 24, 45, 0),\n    ivec4(16, 24, 55, 0),\n    ivec4(51, 8, 30, 0),\n    ivec4(27, 13, 33, 0),\n    ivec4(34, 13, 27, 0),\n    ivec4(25, 32, 35, 0),\n    ivec4(65, 14, 42, 0),\n    ivec4(27, 57, 34, 0),\n    ivec4(33, 26, 9, 0),\n    ivec4(54, 13, 42, 0),\n    ivec4(13, 54, 33, 0),\n    ivec4(42, 58, 44, 0),\n    ivec4(47, 59, 45, 0),\n    ivec4(60, 45, 59, 0),\n    ivec4(56, 65, 44, 0),\n    ivec4(33, 9, 27, 0),\n    ivec4(62, 59, 47, 0),\n    ivec4(61, 59, 62, 0),\n    ivec4(65, 42, 44, 0),\n    ivec4(58, 13, 34, 0),\n    ivec4(9, 21, 27, 0),\n    ivec4(34, 55, 60, 0),\n    ivec4(60, 55, 24, 0),\n    ivec4(59, 48, 60, 0),\n    ivec4(48, 59, 61, 0),\n    ivec4(62, 65, 56, 0),\n    ivec4(9, 26, 10, 0),\n    ivec4(2, 49, 31, 0),\n    ivec4(18, 31, 49, 0),\n    ivec4(22, 46, 23, 0),\n    ivec4(46, 22, 0, 0),\n    ivec4(28, 23, 46, 0),\n    ivec4(57, 55, 34, 0),\n    ivec4(42, 36, 11, 0),\n    ivec4(36, 63, 11, 0),\n    ivec4(36, 14, 53, 0),\n    ivec4(64, 14, 65, 0),\n    ivec4(46, 0, 62, 0),\n    ivec4(1, 53, 14, 0),\n    ivec4(62, 0, 1, 0),\n    ivec4(1, 14, 64, 0)\n);\n\n//point in tri\n//https://www.shadertoy.com/view/WsVczw\n\nbool inTri(in vec3 point, in mat3 tri, out vec2 coords)\n{\n    //move space toward first vertex\n    //maybe use a mul?\n    point -= tri[0];\n    tri -= mat3(tri[0],tri[0],tri[0]);\n    \n    //using v1 and v2 as a basis, find a vector normal to both to build a plane\n    vec3 norm = normalize(cross(tri[1], tri[2]));\n    \n    //find the projection of vt onto the normal\n    float proj = dot(point, norm);\n    \n    //if(proj * proj < 0.01) // point is not on plane of triangle\n    //    return false;\n    \n    //move point onto plane of triangle\n    point -= norm * proj;\n    \n    //v1 and v2 form a basis space, whose linear combination is vt. vt = a*v1 + b*v2.\n    //Since vt is guaranteed to be on the plane between the two, its psuedoinverse is its inverse.\n    //moore-penrose psuedoinverse: (MT*M)^-1 * MT = M+\n    \n    mat2x3 space = mat2x3(tri[1], tri[2]); // can this be truncated from tri?\n    mat3x2 st = transpose(space);\n    mat2x2 inv = st * space;\n    \n    //if the inverse's inputs has no determinant, it covers no area, and has no inverse.\n    if(determinant(inv) == 0.0)\n        return false;\n    \n    mat3x2 mpi = inverse(inv) * st;\n    vec2 mpipt = mpi * point; // move into basis space\n    \n    //if the point does not lie within the unit triangle, it misses.\n    if(mpipt.x < 0.0)\n        return false;\n    if(mpipt.y < 0.0)\n        return false;\n    if(1.0 < dot(mpipt, vec2(1,1)))\n       return false;\n    \n    coords = mpipt;\n    return true;\n}\n\nmat4 vshader_matrix_world()\n{\n    //simple rotation matrix\n    mat4 rotate = mat4(1.0);\n    rotate[0][0] = cos(iTime);\n    rotate[0][2] = sin(iTime);\n    rotate[2][0] =-rotate[0][2];\n    rotate[2][2] = rotate[0][0];\n    \n    mat4 scale = mat4(1.0 / 10.0);\n    scale[3][3] = 1.0;\n    \n    mat4 translate = mat4(1.0);\n    //translate[3] += vec4(0,-0.25,-1.0,0.0);\n    //translate[3] += vec4(0,-0.25,0.0,0.0);\n    //translate[3] += vec4(0,-0.1,0.0,0.0);\n    translate[3] += vec4(0,-0.5,0.0,0.0);\n    \n    mat4 world = translate * scale * rotate;\n    \n    return world;\n}\n\nmat4 vshader_shadowmap_matrix_viewproj()\n{\n    mat4 rotate_right = mat4(1.0);\n    float rt = (1.0 / 8.0) * 3.141592 * 2.0;\n    rotate_right[0][0] = cos(rt);\n    rotate_right[0][2] = sin(rt);\n    rotate_right[2][0] =-sin(rt);\n    rotate_right[2][2] = cos(rt);\n    \n    mat4 rotate_up = mat4(1.0);\n    rotate_up[1][1] = cos(2.0 * 3.141592 * (-1.0 / 8.0));\n    rotate_up[1][2] = sin(2.0 * 3.141592 * (-1.0 / 8.0));\n    rotate_up[2][1] =-rotate_up[1][2];\n    rotate_up[2][2] = rotate_up[1][1];\n    \n    mat4 view = mat4(1.0);\n    view[3] += vec4(0.0,0.0,2.5,0.0);\n    \n    //view = rotate_up * rotate_right * view;\n    view = view * rotate_up * rotate_right;\n    \n    mat4 proj = mat4(1.0);\n    float width = 1.0;\n    float height = iResolution.y / iResolution.x;\n    float near = 1.0;\n    float far = 10.0;\n    proj[0][0] = 2.0 * near / width;\n    proj[1][1] = 2.0 * near / height;\n    proj[2][2] = -far / (near - far);\n    proj[3][2] = near * far / (near - far);\n    proj[2][3] = 1.0;\n    proj[3][3] = 0.0;\n    \n    mat4 vp = proj * view;\n    \n    return vp;\n}\n\nmat4 vshader_matrix_viewproj()\n{\n    mat4 view = mat4(1.0);\n    view[3] += vec4(0.0,0.0,2.5,0.0);\n    \n    mat4 proj = mat4(1.0);\n    float width = 1.0;\n    float height = iResolution.y / iResolution.x;\n    float near = 1.0;\n    float far = 10.0;\n    proj[0][0] = 2.0 * near / width;\n    proj[1][1] = 2.0 * near / height;\n    proj[2][2] = -far / (near - far);\n    proj[3][2] = near * far / (near - far);\n    proj[2][3] = 1.0;\n    proj[3][3] = 0.0;\n    \n    mat4 vp = proj * view;\n    \n    return vp;\n}\n\n\nvec4 vshader(in vec4 mPos)\n{\n    mat4 world = vshader_matrix_world();\n    mat4 viewproj = vshader_matrix_viewproj();\n    //mat4 viewproj = vshader_shadowmap_matrix_viewproj();\n    mat4 wvp = viewproj * world;\n    \n    vec4 sPos = wvp * mPos;\n    \n    return sPos;\n}\n\nfloat srgb2lsrgb(in float srgb)\n{\n    if(srgb < 0.04045)\n        return srgb / 12.92;\n    float a = 1.055;\n    return pow(1.0 + (srgb - 1.0) / a, 2.4);\n}\n\nvec3 srgb2lsrgb(in vec3 srgb)\n{\n    return vec3(srgb2lsrgb(srgb.x),srgb2lsrgb(srgb.y),srgb2lsrgb(srgb.z));\n}\n\nvec3 pshader(in vec4 sPos, in vec4 wPos, in vec3 normal)\n{\n    \n    //transform to projected screen\n    mat4 sm_m_vp = vshader_shadowmap_matrix_viewproj();\n    vec4 sm_sPos = sm_m_vp * wPos;\n    sm_sPos /= sm_sPos.w;\n    \n    //find ray origins\n    mat4 sm_im_vp = inverse(sm_m_vp); // slow, can be brought into the pshader\n    vec4 sm_wPos = sm_im_vp * vec4(sm_sPos.xy, 0.0, 1.0);\n    \n    mat4 m_vp = vshader_matrix_viewproj();\n    mat4 im_vp = inverse(m_vp);\n    vec4 vw_pos = m_vp * vec4(sPos.xy, 0.0, 1.0);\n    vec3 view = normalize(vw_pos.xyz - wPos.xyz);\n    \n    //correct for projection screen\n    sm_sPos.xy = (sm_sPos.xy + 1.0) / 2.0;\n\n    //shadow map texture\n    float dtest = texture(iChannel0, sm_sPos.xy).x;\n    bvec4 bbox = bvec4(sm_sPos.x < 0.0, sm_sPos.y < 0.0, 1.0 < sm_sPos.x, 1.0 < sm_sPos.x);\n\n    //shadow map test\n    float brdf = 0.0;\n    vec3 col = srgb2lsrgb(texture(iChannel1, sm_sPos.xy).xyz);// * 0.5 + 0.5;\n    if(0.01 < sm_sPos.z - dtest || any(bbox))\n        brdf = 0.0;\n    else\n    {\n        //phong brdf\n        vec3 Li = sm_wPos.xyz - wPos.xyz;\n        vec3 nLi = normalize(Li);\n\n        float albedo = 1.0;\n        float reflectivity = 0.25;\n        float power = 100.0;\n\n        float diffuse = max(0.0, dot(normal, nLi));\n        //diffuse /= 3.141592;\n\n        vec3 refl = reflect(nLi, normal);\n        float specular = max(0.0, dot(view, refl));\n        specular = pow(specular, power);\n        specular *= (power + 2.0) / 2.0; //(2.0 * 3.141592);\n\n        brdf = (1.0 - reflectivity) * albedo * diffuse + reflectivity * specular;\n        brdf /= dot(Li, Li);\n    }\n    \n    col *= brdf;\n    \n    //col *= diffuse;\n        \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = texture(iChannel0, uv);\n    //return;\n\n    vec2 xy = uv * 2.0 - 1.0;\n    \n    //fake camera perspective\n    //xy.y *= iResolution.y / iResolution.x;\n    \n    //fake camera\n    //xy += vec2(0,0.5);\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos((iTime+uv.xyx+vec3(0,2,4))*1.0);\n\t\n    //zbuffer\n    float depth = 100000.0;\n    \n    //do this viewvec in the shader\n    vec3 viewvec = vec3(xy * vec2(1.0, iResolution.y / iResolution.x), 1.0);\n    viewvec = normalize(viewvec);\n    col = srgb2lsrgb(texture(iChannel2, viewvec).xyz);\n    \n    for(int i=0; i<128; i++)\n    {\n        //get a single triangle from the index buffer\n        ivec3 tri = ibuffer[i].xyz;\n        \n        //look up associated vertices, and do a simple resize\n        vec4 v0 = vshader(vbuffer[tri[0]]);\n        vec4 v1 = vshader(vbuffer[tri[1]]);\n        vec4 v2 = vshader(vbuffer[tri[2]]);\n        mat3 vin = mat3(v0.xyz/v0.w, v1.xyz/v1.w, v2.xyz/v2.w);\n        \n        //setup const z-clipping matrix\n        mat3 zclip = mat3(1.0);\n        zclip[2][2] = 0.0;\n        \n        //if point is within a triangle, display a color\n        vec2 coords;\n        if(inTri(vec3(xy,0.0), zclip*vin, coords))\n        {\n            //from the barycentric coords, lerp vertex values (for zbuffer, useful for uvs or normals)\n            vec4 sOut = mat3x4(v1 - v0, v2 - v0, v0) * vec3(coords, 1.0);\n            vec3 outPos = sOut.xyz / sOut.w;\n            if(outPos.z < depth)\n            {\n                depth = outPos.z;\n                //col = vec3(1,1,1) * float(i) / 127.0;\n                \n                //shadow mapping: map the worldspace position to a point on the shadowmap.\n                //find the depth of the shadowmap at that point and compare it to that point's.\n                //if they disagree, they aren't lit.\n                \n                //get world coords of pixel\n                mat4 world = vshader_matrix_world();\n                vec4 w0 = world * vbuffer[tri[0]];\n                vec4 w1 = world * vbuffer[tri[1]];\n                vec4 w2 = world * vbuffer[tri[2]];\n                \n                //interpolate world position\n                mat3x4 wm = mat3x4(w0, w1-w0, w2-w0);\n                vec4 w = wm * vec3(1.0, coords);\n                \n                //find normal\n                vec3 wn1 = normalize((w1-w0).xyz);\n                vec3 wn2 = normalize((w2-w0).xyz);\n                vec3 normal = normalize(cross(wn1, wn2));\n                \n                col = pshader(sOut, w, normal);\n                \n                //col = vec3(1.0) * float(i) / 127.0;\n            }\n        }\n    }\n\t/*\n\tfor(int i=0; i<66; i++)\n    {\n        vec4 vert = vshader(vbuffer[i]);\n        vert /= vert.w;\n        if(distance(vert.xy, xy) < 0.01)\n        {\n            if(depth < vert.z)\n            {\n                depth = vert.z;\n            \tcol = vec3(1,1,1) * float(i) / 65.0;\n            }\n        }\n    }\n\t*/\n    \n    //fragColor = vec4(vec3(depth), 1.0);\n    \n    // Output to screen\n    \n    //col = texture(iChannel0, fragCoord.xy).xyz;\n    \n    //col = texture(iChannel0, uv).xyz;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}