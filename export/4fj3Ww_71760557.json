{"ver":"0.1","info":{"id":"4fj3Ww","date":"1704293395","viewed":29,"name":"Test Minecraft Shader","username":"jnngl","description":"A shader that tries to reproduce the Minecraft promo art outline and highlights.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["minecraft"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define USE_ICHANNEL0 0\n#define AA 1\n\nvec3 palette[3] = vec3[3](\n    vec3(0.230470, 0.539065, 0.738284),\n    vec3(0.367189, 0.675784, 0.875003),\n    vec3(0.164063, 0.398439, 0.656253)\n);\n\nvec3 fetch_texture(float factor, vec2 uv) {\n    if (factor == 0.0) return vec3(0.0);\n    \n    vec2 normalized = uv;\n    if (normalized.x < 0.0) {\n        normalized.x = 1.0 - normalized.x;\n    }\n    if (normalized.y < 0.0) {\n        normalized.y = 1.0 - normalized.y;\n    }\n    normalized = vec2(mod(normalized.x, 1.0), mod(normalized.y, 1.0));\n    \n#if USE_ICHANNEL0\n    return texture(iChannel0, normalized).xyz;\n#else\n    int x = int(normalized.x * 16.0);\n    int y = int(normalized.y * 16.0);\n    int index = 1;\n    \n    if (y >= 0 && y <= 2) {\n        if (x == 0 || (y == 0 ? x == 2 : false) \n                   || (y == 2 ? x == 8 : false)) index = 0;\n    } else if (y == 3 || y == 7 || y == 11 || y == 15) {\n        index = 2;\n    } else if (y >= 4 && y <= 6) {\n        if (x == 7 || (y == 4 ? x == 11 : false)\n                   || (y == 5 ? x == 1 : false)\n                   || (y == 6 ? x == 10 : false)) index = 0;\n    } else if (y >= 8 && y <= 10) {\n        if (x == 15 || (y == 8 ? x == 5 : false)\n                    || (y == 9 ? x == 11 : false)) index = 0;\n    } else if (y >= 12 && y <= 14) {\n        if (x == 7 || (y == 12 ? x == 9 : false)\n                   || (y == 13 ? x == 1: false)) index = 0;\n    }\n    \n    return palette[index].zyx * factor;\n#endif\n}\n\nstruct ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct camera {\n    vec3 origin;\n    vec3 lower_left_corner;\n    vec3 horizontal;\n    vec3 vertical;\n    vec3 u, v, w;\n};\n\ncamera create_camera(vec3 lookfrom, vec3 lookat, vec3 vup, float vfov, float aspect_ratio, float focus_dist) {\n    float theta = degrees(vfov);\n    float h = tan(theta / 2.0);\n    float viewport_height = 2.0 * h;\n    float viewport_width = aspect_ratio * viewport_height;\n    \n    camera cam;\n    cam.w = normalize(lookfrom - lookat);\n    cam.u = normalize(cross(vup, cam.w));\n    cam.v = cross(cam.w, cam.u);\n    cam.origin = lookfrom;\n    cam.horizontal = focus_dist * viewport_width * cam.u;\n    cam.vertical = focus_dist * viewport_height * cam.v;\n    cam.lower_left_corner = cam.origin - cam.horizontal / 2.0 - cam.vertical / 2.0 - focus_dist * cam.w;\n    \n    return cam;\n}\n\nray get_ray(camera cam, float s, float t) {\n    ray r;\n    r.origin = cam.origin;\n    r.direction = cam.lower_left_corner + s * cam.horizontal + t * cam.vertical - cam.origin;\n    return r;\n}\n\nvec3 saturate(vec3 rgb, float adj) {\n    vec3 w = vec3(0.2125, 0.7154, 0.0721);\n    vec3 i = vec3(dot(rgb, w));\n    return mix(i, rgb, adj);\n}\n\nvec3 mapColor(vec3 x) {\n    return clamp(sqrt(saturate(x, 1.3)), vec3(0.0), vec3(1.0));\n}\n\nvec2 boxIntersect(vec3 ro, vec3 rd, vec3 boxSize, out vec3 outNormal) {\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if (tN > tF || tF < 0.0) {\n        return vec2(-1.0);\n    }\n    \n    outNormal = tN > 0.0 ? step(vec3(tN), t1) : step(t2, vec3(tF));\n    outNormal *= -sign(rd);\n    return vec2(tN, tF);\n}\n\nvec3 pixelColor(camera cam, vec2 fragCoord) {\n    vec3 boxpos = vec3(0.0);\n    vec3 boxsize = vec3(0.5);\n    \n    vec3 sun_vec = vec3(1.0, 2.5, -1.8);\n    vec3 sun_color = vec3(1.1);\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    ray r = get_ray(cam, uv.x, 1.0 - uv.y);\n\n    vec3 boxNormal;\n    float boxi = boxIntersect(r.origin - boxpos, r.direction, boxsize, boxNormal).x;\n    if (boxi < 0.0) {\n        // Plane intersection\n        float h = (-0.5 - r.origin.y) / r.direction.y;\n        if (h > 0.0) {\n            // Cast shadow\n            vec3 isec = r.origin + r.direction * h;\n            vec3 color = sun_color * vec3(0.46, 0.76, 0.92) * max(dot(vec3(0.0, 1.0, 0.0), normalize(sun_vec)), 0.1);\n            vec3 dummy;\n            if (boxIntersect(isec - boxpos, normalize(sun_vec - isec), boxsize, dummy).x >= 0.0) {\n                color *= 0.5;\n            }\n            return color;\n        } else {\n            return vec3(0.0);\n        }\n    } else {\n        vec3 isec = r.origin + r.direction * boxi;\n        \n        bool outline = false;\n        bool edge = false;\n        for (int dx = -1; dx <= 1; dx += 2) {\n            for (int dy = -1; dy <= 1; dy += 2) {\n                float _x = fragCoord.x + float(dx) * 1.5;\n                float _y = fragCoord.y + float(dy) * 1.5;\n                vec2 _uv = vec2(_x, _y) / iResolution.xy;\n                ray _r = get_ray(cam, _uv.x, 1.0 - _uv.y);\n                vec3 _normal;\n                float dist = boxIntersect(_r.origin - boxpos, _r.direction, boxsize, _normal).x;\n                if (dist < 0.0) {\n                    outline = true;\n                } else if (_normal != boxNormal) {\n                    edge = true;\n                }\n            }\n        }\n        \n        vec3 texture_color = fetch_texture(abs(boxNormal.x), vec2(isec.z, isec.y) - 0.5) +\n                             fetch_texture(abs(boxNormal.y), vec2(isec.z, isec.x) - 0.5) +\n                             fetch_texture(abs(boxNormal.z), vec2(isec.x, isec.y) - 0.5);\n        \n        float cos_theta = min(dot(-r.direction, boxNormal), 1.0);\n        float reflectance = pow((1.0 - cos_theta), 5.0);\n        vec3 reflectDir = reflect(normalize(-sun_vec), boxNormal);\n        vec3 viewDir = normalize(r.origin - isec);\n        float spec = pow(max(dot(viewDir, reflectDir), 0.0), 1.5);\n        vec3 color = sun_color * texture_color * max(dot(boxNormal, normalize(sun_vec - isec)) + spec * 0.25, 0.1);\n        if (edge && spec == 0.0) color *= 0.75;\n        color = mix(color, vec3(1.0), reflectance);\n        if (outline) color *= 0.5;\n        if (edge) color += sun_color * spec * 1.5;\n        \n        return color;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 camera_center = vec3(sin(iTime / 5.0) * 1.5, 1.5, cos(iTime / 5.0) * 1.5);\n    vec3 camera_look = vec3(0.0);\n    \n    camera cam = create_camera(camera_center, camera_look, vec3(0.0, 1.0, 0.0), 40.0, iResolution.x / iResolution.y, 2.0);\n    \n    vec3 color;\n    \n#if AA == 0\n    color = pixelColor(cam, fragCoord);\n#else\n    float w1 = 0.125;\n    float w2 = 0.5;\n    vec2 q = vec2(0.5);\n    \n    color = (pixelColor(cam, fragCoord + vec2(0.5) + vec2(-q.x, +q.y)) +\n             pixelColor(cam, fragCoord + vec2(0.5) + vec2(+q.y, +q.x)) +\n             pixelColor(cam, fragCoord + vec2(0.5) + vec2(+q.x, -q.y)) +\n             pixelColor(cam, fragCoord + vec2(0.5) + vec2(-q.y, -q.x))) * w1 +\n            (pixelColor(cam, fragCoord + vec2(0.5) + vec2( 0.0,  0.0))) * w2;\n#endif\n    \n    \n    fragColor = vec4(mapColor(color), 1.0);\n}","name":"Image","description":"","type":"image"}]}