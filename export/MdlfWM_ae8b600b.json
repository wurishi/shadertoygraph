{"ver":"0.1","info":{"id":"MdlfWM","date":"1497412034","viewed":261,"name":"Fractal Furball Monster","username":"soma_arc","description":"WATCHING YOU.\nYou can move the camera with your mouse.\nFur shader is based on  \"furball\" by simesgreen.\nhttps://www.shadertoy.com/view/XsfGWN","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["3d","fractal","fur"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2017 @soma_arc\n\nconst int OBJ_FUR = 0;\nconst float MARCH_THRESHOLD = 0.1;\nconst int MAX_KLEIN_ITARATION = 50;\nconst int TRACE_DEPTH = 6;\nconst float SAMPLE_NUM = 2.;\nfloat iTime2;\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n\tvec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n\t// implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n    return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nconst float GAMMA = 2.2;\nvec3 degamma(vec3 rgb) {\n    return vec3((min(pow(rgb.r, GAMMA), 1.)),\n                (min(pow(rgb.g, GAMMA), 1.)),\n                (min(pow(rgb.b, GAMMA), 1.)));\n}\n\n// Fur Rendering code is based on \"furball\" by simesgreen.\n// https://www.shadertoy.com/view/XsfGWN\nconst float uvScale = 1.0;\nconst float colorUvScale = 0.1;\nconst float furDepth = 0.4;\nconst int furLayers = 64;\nconst float rayStep = furDepth*2.0 / float(furLayers);\nconst float furThreshold = 0.4;\nconst float shininess = 90.0;\n\nvec3 rotateX(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec2 cartesianToSpherical(vec3 p, vec4 ball)\n{\t\n    vec3 ballPos = p - ball.xyz;\n    float r = length(ballPos);\n\n    float depth = furDepth * ball.w;\n\tfloat t = (r - (ball.w - depth)) / depth;\t\n\tballPos = rotateX(ballPos.zyx, -cos(iTime*1.5)*t*t*0.2).zyx;\t// curl\n\n\tballPos /= r;\t\n\tvec2 uv = vec2(atan(ballPos.y, ballPos.x), acos(ballPos.z));\n\n\tuv.y -= t*t*0.1;\t// curl down\n\treturn uv;\n}\n\nfloat furDensity(vec3 pos, vec4 ball, out vec2 uv)\n{\n\tuv = cartesianToSpherical(pos.xzy, ball.xzyw);\t\n\tvec4 tex = textureLod(iChannel0, uv*uvScale, 0.0);\n\n    float threshold = ball.w * furThreshold;\n\t// thin out hair\n\tfloat density = smoothstep(furThreshold, 1., tex.x);\n\t\n    float depth = ball.w * furDepth;\n\tfloat r = length(pos - ball.xyz);\n\tfloat t = (r - (ball.w - depth)) / depth;\n\t\n\t// fade out along length\n\tfloat len = tex.y;\n\tdensity *= smoothstep(len, len-0.2 , t);\n\n\treturn density;\t\n}\n\nvec3 furNormal(vec3 pos, vec4 ball, float density)\n{\n    float eps = 1.;\n    vec3 n;\n\tvec2 uv;\n    n.x = furDensity( vec3(pos.x+eps, pos.y, pos.z), ball, uv ) - density;\n    n.y = furDensity( vec3(pos.x, pos.y+eps, pos.z), ball, uv ) - density;\n    n.z = furDensity( vec3(pos.x, pos.y, pos.z+eps), ball, uv ) - density;\n    return normalize(n);\n}\n\nvec3 furShade(vec3 pos, vec4 ball, vec2 uv, vec3 ro, float density, vec3 mColor){\n\tconst vec3 L = vec3(0, 1, 0);\n\tvec3 V = normalize(ro - pos);\n\tvec3 H = normalize(V + L);\n\n\tvec3 N = -furNormal(pos, ball, density);\n\n\tfloat diff = max(0.0, sqrt(1. - dot(N, L)* dot(N, L)));\n\tfloat spec = pow(max(0.0, sqrt(1. - dot(N, H) * dot(N, H)) ), shininess);\n\n\tvec3 color = degamma(textureLod(iChannel1, uv*colorUvScale, 0.0).xyz);\n\n    float depth = furDepth * ball.w;\n\tfloat r = length(pos - ball.xyz);\n\tfloat t = (r - (ball.w - depth)) / depth;\n\tt = clamp(t, 0.0, 1.0);\n\tfloat i = t*0.5+0.5;\n\t\t\n\treturn color*diff*i +vec3(0) * vec3(spec*i);\n}\n\n\n\nconst float schottkyRadius = 300.;\nvec4 schottky1 = vec4(300, 300, 0, schottkyRadius);\nvec4 schottky2 = vec4(300, -300, 0, schottkyRadius);\nvec4 schottky3 = vec4(-300, 300, 0, schottkyRadius);\nvec4 schottky4 = vec4(-300, -300, 0, schottkyRadius);\nvec4 schottky5 = vec4(0, 0, 424.26, schottkyRadius);\nvec4 schottky6 = vec4(0, 0, -424.26, schottkyRadius);\n\nvec3 sphereInvert(vec3 pos, vec4 sphere){\n\tvec3 diff = pos - sphere.xyz;\n    float d = length(diff);\n\treturn (diff * sphere.w * sphere.w)/(d * d) + sphere.xyz;\n}\n\nvec3 g_pos;\nfloat loopNum = 0.;\nvec4 baseSphere = vec4(0, 0, 0, 115);\nfloat g_baseRadius;\nfloat distKlein(vec3 pos){\n    float scalingFactor= 0.1;\n    loopNum = 0.;\n    float dr = 1.;\n    bool loopEnd = true;\n    for(int i = 0 ; i < MAX_KLEIN_ITARATION ; i++){\n        loopEnd = true;\n        if(distance(pos, schottky1.xyz) < schottky1.w){\n            vec3 diff = (pos - schottky1.xyz);\n            dr *= (schottky1.w * schottky1.w) / dot(diff, diff);\n            pos = sphereInvert(pos, schottky1);\n            loopEnd = false;\n            loopNum++;\n        }else if(distance(pos, schottky2.xyz) < schottky2.w){\n            vec3 diff = (pos- schottky2.xyz);\n            dr *= (schottky2.w * schottky2.w) / dot(diff, diff);\n            pos = sphereInvert(pos, schottky2);\n            loopEnd = false;\n            loopNum++;\n        }else if(distance(pos, schottky3.xyz) < schottky3.w){\n            vec3 diff = (pos- schottky3.xyz);\n            dr *= (schottky3.w * schottky3.w) / dot(diff, diff);\n            pos = sphereInvert(pos, schottky3);\n            loopEnd = false;\n            loopNum++;\n        }else if(distance(pos, schottky4.xyz) < schottky4.w){\n            vec3 diff = (pos- schottky4.xyz);\n            dr *= (schottky4.w * schottky4.w) / dot(diff, diff);\n            pos = sphereInvert(pos, schottky4);\n            loopEnd = false;\n            loopNum++;\n        }else if(distance(pos, schottky5.xyz) < schottky5.w){\n            vec3 diff = (pos- schottky5.xyz);\n            dr *= (schottky5.w * schottky5.w) / dot(diff, diff);\n            pos = sphereInvert(pos, schottky5);\n            loopEnd = false;\n            loopNum++;\n        }else if(distance(pos, schottky6.xyz) < schottky6.w){\n            vec3 diff = (pos- schottky6.xyz);\n            dr *= (schottky6.w * schottky6.w) / dot(diff, diff);\n            pos = sphereInvert(pos, schottky6);\n            loopEnd = false;\n            loopNum++;\n        }\n        if(loopEnd == true) break;\n    }\n    g_pos = pos;\n  \tg_baseRadius = baseSphere.w / abs(dr);\n    return (length(pos) - baseSphere.w) / abs(dr) * scalingFactor;\n}\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n    float imagePlane = (height * .5) / tan(fov * .5);\n    vec3 v = normalize(target - eye);\n    vec3 xaxis = normalize(cross(v, up));\n    vec3 yaxis =  normalize(cross(v, xaxis));\n    vec3 center = v * imagePlane;\n    vec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));\n    return normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));\n}\n\nconst vec4 K = vec4(1.0, .666666, .333333, 3.0);\nvec3 hsv2rgb(const vec3 c){\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat distFunc(vec3 p){\n    return distKlein(p);\n}\n\nconst vec2 d = vec2(0.01, 0.);\nvec3 getNormal(const vec3 p){\n    return normalize(vec3(distFunc(p + d.xyy) - distFunc(p - d.xyy),\n                          distFunc(p + d.yxy) - distFunc(p - d.yxy),\n                          distFunc(p + d.yyx) - distFunc(p - d.yyx)));\n}\n\nconst int MAX_MARCHING_LOOP = 1000;\nint march(const vec3 origin, const  vec3 ray, const float threshold,\n           float t0, float t1,\n           out vec3 intersection){\n    vec3 rayPos = origin + t0 * ray;\n    float dist;\n    float rayLength = t0;\n    for(int i = 0 ; i < MAX_MARCHING_LOOP ; i++){\n        if(rayLength > t1) break;\n        dist = distFunc(rayPos);\n        rayLength += dist;\n        rayPos = origin + ray * rayLength ;\n        if(dist < threshold) {\n        \tintersection = rayPos;\n            return OBJ_FUR;\n        }\n    }\n    return -1;\n}\n\nbool intersectSphere(vec4 sphere, \n                     vec3 rayOrigin, vec3 rayDir,\n                     out float t0, out float t1){\n  \tvec3 v = rayOrigin - sphere.rgb;\n  \tfloat b = dot(rayDir, v);\n  \tfloat c = dot(v, v) - sphere.w * sphere.w;\n  \tfloat d = b * b - c;\n  \tif(d >= 0.){\n    \tfloat s = sqrt(d);\n    \tfloat tmin = -b - s;\n        float tmax = -b + s;\n            if(tmin < tmax) {\n            \tt0 = tmin;\n                t1 = tmax;\n            } else {\n            \tt0 = tmax;\n                t1 = tmin;\n            }\n      \t\treturn true;\n    \t\n  \t}\n  \treturn false;\n}\n\nconst float PI = 3.14159265359;\nconst float TWO_PI = 2. * PI;\nvec2 equirectangularCoord(const vec3 coordOnSphere){\n    vec3 dir = (coordOnSphere);\n    float l = atan(dir.z, dir.x);\n    if (l < 0.) l += TWO_PI;\n    return vec2(l, abs(acos(dir.y) -PI));\n}\n\nbool inEqui(vec2 a, vec2 b, float threshold){\n\treturn (distance(a, b) < threshold ||\n            distance(a , b + vec2(TWO_PI, 0)) < threshold||\n            distance(a , b - vec2(TWO_PI, 0)) < threshold);\n}\n\nvec3 calcColor(vec3 eye, vec3 ray){\n    vec3 originalEye = eye;\n    vec4 l = vec4(0);\n    float coeff = 1.;\n    float t0, t1;\n    bool intersect =  intersectSphere(vec4(0,0,0, 310.), eye, ray, t0, t1);\n    if(intersect == false) return l.rgb; \n\tif(t0 < 0.) t0 = 0.;\n    for(int rayDepth = 0 ; rayDepth < TRACE_DEPTH ; rayDepth++){\n\t\tvec3 intersection, normal;\n    \tint objId = march(eye, ray, MARCH_THRESHOLD, t0, t1, intersection);\n    \tif(objId != -1){\n\t\t\tnormal = getNormal(intersection);\n\n\t\t\tvec4 c = vec4(0.0);        \n        \tvec3 pos = intersection;\n        \n        \tfloat ballRadius = g_baseRadius;\n        \tvec4 ball = vec4(intersection - normal * ballRadius, ballRadius);\n        \tfloat depth = ballRadius * furDepth;\n        \tfloat rstep = depth*2.0 / float(furLayers);\n\n\t\t\t// render eye        \n            vec2 eqc = equirectangularCoord(normalize(intersection - ball.xyz));\n        \tvec2 v = equirectangularCoord(normalize(normalize(originalEye - ball.xyz)));\n        \tvec2 left = v - vec2(.23 , -0.1);\n        \tvec2 right = v + vec2(.23, 0.1);\n            if(inEqui(eqc, left, .1)){\n        \t    c = vec4(0, 0, 0, 1);\n                c.rgb *= c.a;\n\t\t\t\tl = l + c * (1.0 - l.a);\n            \tbreak;\n            }else if(inEqui(eqc, left, .2)){\n            \tc = vec4(1);\n                c.rgb *= c.a;\n\t\t\t\tl = l + c * (1.0 - l.a);\n                break;\n            }\n            if(inEqui(eqc, right, .1)){\n           \t\tc = vec4(0, 0, 0, 1);\n                c.rgb *= c.a;\n\t\t\t\tl = l + c * (1.0 - l.a);\n            \tbreak;\n            }else if(inEqui(eqc, right, .2)){\n            \tc = vec4(1);\n                c.rgb *= c.a;\n\t\t\tl = l + c * (1.0 - l.a);\n                break;\n            }\n            //dummy\n            vec3 matColor = vec3(0);\n            // render fur\n\t\t\tfor(int i=0; i<furLayers; i++) {\n\t\t\t\tvec4 sampleCol;\n\t\t\t\tvec2 uv;\n\t\t\t\tsampleCol.a = furDensity(pos, ball, uv);\n\t\t\t\tif (sampleCol.a > 0.0) {\n\t\t\t\t\tsampleCol.rgb = furShade(pos, ball, uv, eye, sampleCol.a, matColor);\n\n\t\t\t\t\tsampleCol.rgb *= sampleCol.a;\n\t\t\t\t\tc = c + sampleCol*(1.0 - c.a);\n\t\t\t\t\tif (c.a > 0.99) break;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tpos += ray*rstep;\n\t\t\t}\n        \tc = clamp(c, 0., 1.);            \n            \n        \tc.rgb *= c.a;\n\t\t\tl = l + c * (1.0 - l.a);\n        \tfloat tmin, tmax;\n        \tintersectSphere(ball, eye, ray, tmin, tmax);\n        \teye = eye + ray * (tmax + ball.w * 0.2);\n        \tt0 = 0.;\n    \t} else {\n        \tvec4 c = vec4(0, 0, 0, 1);\n        \tc.rgb *= c.a;\n\t\t\tl = l + c * (1.0 - l.a);\n    \t\tbreak;\n    \t}\n    \tif (l.a > 0.99) break;\n    }\n    return l.rgb;\n}\n\nvec3 eye = vec3(300 , 0., 550 );\nconst vec3 target = vec3(0, 0, 0);\nconst vec3 up = vec3(0, 1, 0);\nfloat fov = radians(60.);\n\nfloat scene(in float t, in float w, in float s){\n    return clamp(t - w, 0.0, s) / s;  \n}\n\nfloat expEasingIn(float t){\n    return pow( 2., 13. * (t - 1.) );\n}\nfloat expEasingOut(float t) {\n\treturn -pow( 2., -10. * t) + 1.;\n}\n\nfloat circEasingInOut(float t){\n\tt /= .5;\n\tif (t < 1.) return -.5 * (sqrt(1. - t*t) - 1.);\n\tt -= 2.;\n\treturn .5 * (sqrt(1. - t*t) + 1.);\n}\n\nfloat circEasingIn(float t){\n\treturn -  (sqrt(1. - t*t) - 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec3 sum = vec3(0);\n    float t = iTime * .5;\n    iTime2 = iTime;\n    float dist = 500. + -iMouse.x;\n    float height = 100. + iMouse.y;\n\n    eye = vec3(dist * cos(t) , height, \n               dist * sin(t) );\n\n    \n    float start = 0.;\n    float dur = 1.; \n\tschottky1.w = mix(0., schottkyRadius, expEasingIn(scene(t, start, dur)));\n   \tschottky5.w = mix(0., schottkyRadius, expEasingIn(scene(t, start + .5, dur)));\n\tschottky2.w = mix(0., schottkyRadius, expEasingIn(scene(t, start + 2. * .5, dur)));\n\tschottky4.w = mix(0., schottkyRadius, expEasingIn(scene(t, start + 3. * .5, dur)));\n    schottky3.w = mix(0., schottkyRadius, expEasingIn(scene(t, start + 4. * .5, dur)));\n\tschottky6.w = mix(0., schottkyRadius, expEasingIn(scene(t, start + 5. * .5, dur)));\n\tdur = dur * 6.;\n    \n  \tfor(float i = 0. ; i < SAMPLE_NUM ; i++){\n    \tvec2 coordOffset = rand2n(gl_FragCoord.xy, i);\n    \tvec3 ray = calcRay(eye, target, up, fov,\n        \t               iResolution.x, iResolution.y,\n            \t           gl_FragCoord.xy + coordOffset);\n          \n    \tsum += calcColor(eye, ray);\n\t}\n\tvec3 col = (sum/SAMPLE_NUM);\n\n\tfragColor = vec4(gammaCorrect(col), 1.);\n}","name":"Image","description":"","type":"image"}]}