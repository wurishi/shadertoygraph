{"ver":"0.1","info":{"id":"3tSXDR","date":"1566188425","viewed":192,"name":"PBR101","username":"bearworks","description":"PBR from Substance Painter","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["pbr","substance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Bloom from https://www.shadertoy.com/view/lstSRS Gargantua With HDR Bloom \n\n#define bloomRanger 0.45\n#define bloomIntensity 0.25\n\nvec4 cubic(float x)\n{\n    float x2 = x * x;\n    float x3 = x2 * x;\n    vec4 w;\n    w.x =   -x3 + 3.0*x2 - 3.0*x + 1.0;\n    w.y =  3.0*x3 - 6.0*x2       + 4.0;\n    w.z = -3.0*x3 + 3.0*x2 + 3.0*x + 1.0;\n    w.w =  x3;\n    return w / 6.0;\n}\n\nvec4 BicubicTexture(in sampler2D tex, in vec2 coord)\n{\n\tvec2 resolution = iResolution.xy;\n\n\tcoord *= resolution;\n\n\tfloat fx = fract(coord.x);\n    float fy = fract(coord.y);\n    coord.x -= fx;\n    coord.y -= fy;\n\n    fx -= 0.5;\n    fy -= 0.5;\n\n    vec4 xcubic = cubic(fx);\n    vec4 ycubic = cubic(fy);\n\n    vec4 c = vec4(coord.x - 0.5, coord.x + 1.5, coord.y - 0.5, coord.y + 1.5);\n    vec4 s = vec4(xcubic.x + xcubic.y, xcubic.z + xcubic.w, ycubic.x + ycubic.y, ycubic.z + ycubic.w);\n    vec4 offset = c + vec4(xcubic.y, xcubic.w, ycubic.y, ycubic.w) / s;\n\n    vec4 sample0 = texture(tex, vec2(offset.x, offset.z) / resolution);\n    vec4 sample1 = texture(tex, vec2(offset.y, offset.z) / resolution);\n    vec4 sample2 = texture(tex, vec2(offset.x, offset.w) / resolution);\n    vec4 sample3 = texture(tex, vec2(offset.y, offset.w) / resolution);\n\n    float sx = s.x / (s.x + s.y);\n    float sy = s.z / (s.z + s.w);\n\n    return mix( mix(sample3, sample2, sx), mix(sample1, sample0, sx), sy);\n}\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nvec3 BloomFetch(vec2 coord)\n{\n \treturn BicubicTexture(iChannel3, coord).rgb;   \n}\n\nvec3 Grab(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord /= scale;\n    coord -= offset;\n\n    return BloomFetch(coord);\n}\n\nvec2 CalcOffset(float octave)\n{\n    vec2 offset = vec2(0.0);\n    \n    vec2 padding = vec2(10.0) / iResolution.xy;\n    \n    offset.x = -min(1.0, floor(octave / 3.0)) * (0.25 + padding.x);\n    \n    offset.y = -(1.0 - (1.0 / exp2(octave))) - padding.y * octave;\n\n\toffset.y += min(1.0, floor(octave / 3.0)) * 0.35;\n    \n \treturn offset;   \n}\n\nvec3 GetBloom(vec2 coord)\n{\n \tvec3 bloom = vec3(0.0);\n    \n    //Reconstruct bloom from multiple blurred images\n    bloom += Grab(coord, 1.0, vec2(CalcOffset(0.0))) * 1.0;\n    bloom += Grab(coord, 2.0, vec2(CalcOffset(1.0))) * 1.5;\n\tbloom += Grab(coord, 3.0, vec2(CalcOffset(2.0))) * 1.0;\n    bloom += Grab(coord, 4.0, vec2(CalcOffset(3.0))) * 1.5;\n    bloom += Grab(coord, 5.0, vec2(CalcOffset(4.0))) * 1.8;\n    bloom += Grab(coord, 6.0, vec2(CalcOffset(5.0))) * 1.0;\n    bloom += Grab(coord, 7.0, vec2(CalcOffset(6.0))) * 1.0;\n    bloom += Grab(coord, 8.0, vec2(CalcOffset(7.0))) * 1.0;\n\n\treturn pow(bloom, vec3(bloomRanger));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = ColorFetch(uv);\n    color += GetBloom(uv) * bloomIntensity;\n    \n    fragColor = vec4(color, 1.0);\n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Based on Cheap orthonormal basis by nimitz\n//Shading code from Substance Painter\n\n#define ITR 1000\n#define FAR 10.\n\n#define nbSamples 256\n#define mipmapLevel 8.\n\n#define metal 0.9\n#define rough 0.32\n#define baseColor vec3(1.000, 0.766, 0.336)\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nfloat map(vec3 p)\n{\n\tp.x += sin(p.z*5.+sin(p.y*5.))*0.3;\n    return (length(p)-1.)*0.7;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float d = 0.;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    float res = map(ro+rd*d);\n        h = res;\n    }\n\treturn d;\n}\n\n\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.005;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n//http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content\nvoid basis(in vec3 n, out vec3 f, out vec3 r)\n{\n    #ifdef HANDLE_SINGULARITY\n    if(n.z < -0.999999)\n    {\n        f = vec3(0 , -1, 0);\n        r = vec3(-1, 0, 0);\n    }\n    else\n    {\n    \tfloat a = 1./(1. + n.z);\n    \tfloat b = -n.x*n.y*a;\n    \tf = vec3(1. - n.x*n.x*a, b, -n.x);\n    \tr = vec3(b, 1. - n.y*n.y*a , -n.y);\n    }\n    #else\n    float a = 1./(1. + n.z);\n    float b = -n.x*n.y*a;\n    f = vec3(1. - n.x*n.x*a, b, -n.x);\n   \tr = vec3(b, 1. - n.y*n.y*a , -n.y);\n    #endif\n}\n\n\t\t\t\nvec3 GenerateDiffuseColor(vec3 c, float metallic)\n{\n    return c * (1.0 - metallic);\n}\n\nvec3 GenerateSpecularColor(vec3 c, float metallic)\n{\n    return mix(vec3(0.08), c, metallic);\n}\n\nfloat normal_distrib(\n    float ndh,\n    float Roughness)\n{\n    // use GGX / Trowbridge-Reitz, same as Disney and Unreal 4\n    // cf http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf p3\n    float alpha = Roughness * Roughness;\n    float tmp = alpha / max(1e-8, (ndh*ndh*(alpha*alpha - 1.0) + 1.0));\n    return tmp * tmp / 3.14;\n}\n\nvec3 fresnel(\n    float vdh,\n    vec3 F0)\n{\n    // Schlick with Spherical Gaussian approximation\n    // cf http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf p3\n    float sphg = pow(2.0, (-5.55473*vdh - 6.98316) * vdh);\n    return F0 + (vec3(1.0, 1.0, 1.0) - F0) * sphg;\n}\n\n// SH lighting environment\nconst vec4\t\tSHAr = vec4(-0.1756558,0.2664177,-0.2789761,0.5250854);\nconst vec4\t\tSHAg = vec4(-0.1814491,0.3129014,-0.2843459,0.5691819);\nconst vec4\t\tSHAb = vec4(-0.1731578,0.3431886,-0.2603939,0.5708114);\nconst vec4\t\tSHBr = vec4(-0.04007974,-0.07741283,0.06866416,0.05455012);\nconst vec4\t\tSHBg = vec4(-0.03529865,-0.0636037,0.06799685,0.05711872);\nconst vec4\t\tSHBb = vec4(-0.02891537,-0.04369103,0.05991907,0.05570727);\nconst vec4\t\tSHC  = vec4(0.02075195,0.03393171,0.0448513,1);\n\nvec3 envIrradiance(vec3 dir)\n{\n\n\tvec4 shDir = vec4( dir.x,dir.y,dir.z, 1.0);\n\n\tvec3 sh9 = vec3(0);\n\n  \tshDir.z = -shDir.z;\n\n\t// Linear (L1) + constant (L0) polynomial terms\n\tsh9.r = dot(SHAr, shDir);\n\tsh9.g = dot(SHAg, shDir);\n\tsh9.b = dot(SHAb, shDir);\n\n\tvec3 x1, x2;\n\tvec4 vB = shDir.xyzz * shDir.yzzx;\n\n\tx1.r = dot(SHBr, vB);\n\tx1.g = dot(SHBg, vB);\n\tx1.b = dot(SHBb, vB);\n\n\t// Final (5th) quadratic (L2) polynomial\n\tfloat vC = shDir.x*shDir.x - shDir.y*shDir.y;\n\tx2 = SHC.rgb * vC;\n\n\t// Quadratic polynomials\n\tsh9 += x1 + x2;\n\n\treturn sh9;\n}\n\nfloat fibonacci1D_Imm(int i)\n{\n  return fract((float(i) + 1.0) * 1.618);\n}\n\nvec2 fibonacci2D_Imm(int i, int s)\n{\n  return vec2(\n    (float(i)+0.5) / float(s),\n    fibonacci1D_Imm(i)\n  );\n}\n\nfloat G1(\n\tfloat ndw, // w is either Ln or Vn\n\tfloat k)\n{\n\t// One generic factor of the geometry function divided by ndw\n\t// NB : We should have k > 0\n\treturn 1.0 / (ndw*(1.0 - k) + k);\n}\n\nfloat visibility(\n\tfloat ndl,\n\tfloat ndv,\n\tfloat Roughness)\n{\n\t// Schlick with Smith-like choice of k\n\t// cf http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf p3\n\t// visibility is a Cook-Torrance geometry function divided by (n.l)*(n.v)\n\tfloat k = max(Roughness * Roughness * 0.5, 1e-5);\n\treturn G1(ndl, k)*G1(ndv, k);\n}\n\nvec3 cook_torrance_contrib(\n\tfloat vdh,\n\tfloat ndh,\n\tfloat ndl,\n\tfloat ndv,\n\tvec3 Ks,\n\tfloat Roughness)\n{\n\t// This is the contribution when using importance sampling with the GGX based\n\t// sample distribution. This means ct_contrib = ct_brdf / ggx_probability\n\treturn fresnel(vdh, Ks) * (visibility(ndl, ndv, Roughness) * vdh * ndl / ndh);\n}\n\nvec3 importanceSampleGGX(vec2 Xi, vec3 T, vec3 B, vec3 N, float roughness)\n{\n\tfloat a = roughness * roughness;\n\tfloat cosT = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0)*Xi.y));\n\tfloat sinT = sqrt(1.0 - cosT * cosT);\n\tfloat phi = 2.0*3.14*Xi.x;\n\treturn\n\t\tT * (sinT*cos(phi)) +\n\t\tB * (sinT*sin(phi)) +\n\t\tN * cosT;\n}\n\nfloat probabilityGGX(float ndh, float vdh, float Roughness)\n{\n\treturn normal_distrib(ndh, Roughness) * ndh / (4.0*vdh);\n}\n\nfloat distortion(vec3 Wn)\n{\n\t// Computes the inverse of the solid angle of the (differential) pixel in\n\t// the cube map pointed at by Wn\n\tfloat sinT = sqrt(1.0 - Wn.y*Wn.y);\n\treturn sinT;\n}\n\nfloat computeLOD(vec3 Ln, float p)\n{\n\treturn max(0.0, (mipmapLevel - 1.5) - 0.5 * log2(float(nbSamples) * p * distortion(Ln)));\n}\n\nvec3 CubemapSampler(vec3 dir, float lod)\n{\n  vec2 pos = vec2(atan(-dir.z, -1.0 * dir.x), 2.0 * asin(dir.y)) / 3.14;\n  pos = 0.5 * pos + vec2(0.5);\n  return texture( iChannel0, pos, lod ).xyz;\n}\n\n// Compute the microfacets specular reflection to the viewer's eye\nvec3 pbrComputeSpecular(vec3 viewDir, vec3 normalWorld, vec3 tangent, vec3 bitangent, vec3 specColor, float roughness)\n{\n\tvec3 radiance;\n\tfloat ndv = dot(viewDir, normalWorld);\n\n\tvec2 Xi = vec2(0.);\n\tvec3 Hn = vec3(0.);\n\tvec3 Ln = vec3(0.);\n\n\tfloat ndl = 0.;\n\tfloat vdh = 0.;\n\tfloat ndh = 0.;\n\tfloat lodS = 0.;\n\n\tfor (int i = 0; i < nbSamples; ++i)\n\t{\n\t\tXi = fibonacci2D_Imm(i, nbSamples);\n\n\t\tHn = importanceSampleGGX(Xi, tangent, bitangent, normalWorld, roughness);\n\t\tLn = -reflect(viewDir, Hn);\n\n\t\tndl = dot(normalWorld, Ln);\n\t\tndl = max(1e-8, ndl);\n\t\tvdh = max(1e-8, dot(viewDir, Hn));\n\t\tndh = max(1e-8, dot(normalize(normalWorld), Hn));\n\t\tlodS = roughness < 0.01 ? 0.0 : computeLOD(Ln, probabilityGGX(ndh, vdh, roughness)) ;\n\t\tradiance += CubemapSampler(Ln, lodS) * cook_torrance_contrib(vdh, ndh, ndl, ndv, specColor, roughness);\n\t}\n\t// Remove occlusions on shiny reflections\n\tradiance *= 1.0f / float(nbSamples);\n\n\t//return Ln * 0.5 + 0.5;\n\treturn radiance;\n}\n\nvec3 ACESFilm( vec3 x )\n{\n    float tA = 2.51;\n    float tB = 0.03;\n    float tC = 2.43;\n    float tD = 0.59;\n    float tE = 0.14;\n    return clamp((x*(tA*x+tB))/(x*(tC*x+tD)+tE),0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(0.8,0.1):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n\t//camera\n\tvec3 ro = vec3(0.,0.,4.5);\n    vec3 rd = normalize(vec3(p,-1.5));\n    vec3 rd2 = vec3(0,0.,-1);\n    mat2 mx = mm2(mo.x*6.);\n    mat2 my = mm2(mo.y*6.); \n    ro.xz *= mx;rd.xz *= mx;rd2.xz *= mx;\n    ro.xy *= my;rd.xy *= my;rd2.xy *= my;\n\t\n    vec3 col =  vec3(0.,0.,0.);\n    \n\tfloat rz = march(ro,rd);\n    \n    if ( rz < FAR )\n    {\n        vec3 pos = ro+rz*rd;\n        vec3 nor= normal(pos);\n        vec3 r = vec3(0);vec3 f = vec3(0);\n        basis(nor,f,r);\n        \n        vec3 diff = GenerateDiffuseColor(baseColor, metal);\n        vec3 spec = ACESFilm(GenerateSpecularColor(baseColor, metal) * 1.5);\n        \n        col = pbrComputeSpecular(-rd, nor, f, r, spec, rough);\n        col += envIrradiance(nor) * diff;\n    }\n\n\tfragColor = vec4( max(col, vec3(0.)), 1.0 );\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//First bloom pass, mipmap tree thing\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nvec3 Grab1(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = ColorFetch(coord);\n\n    return color;\n}\n\nvec3 Grab4(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 4;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color /= weights;\n    \n    return color;\n}\n\nvec3 Grab8(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 8;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color /= weights;\n    \n    return color;\n}\n\nvec3 Grab16(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 16;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color /= weights;\n    \n    return color;\n}\n\nvec2 CalcOffset(float octave)\n{\n    vec2 offset = vec2(0.0);\n    \n    vec2 padding = vec2(10.0) / iResolution.xy;\n    \n    offset.x = -min(1.0, floor(octave / 3.0)) * (0.25 + padding.x);\n    \n    offset.y = -(1.0 - (1.0 / exp2(octave))) - padding.y * octave;\n\n\toffset.y += min(1.0, floor(octave / 3.0)) * 0.35;\n    \n \treturn offset;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    vec3 color = vec3(0.0);\n    \n    /*\n    Create a mipmap tree thingy with padding to prevent leaking bloom\n   \t\n\tSince there's no mipmaps for the previous buffer and the reduction process has to be done in one pass,\n    oversampling is required for a proper result\n\t*/\n    color += Grab1(uv, 1.0, vec2(0.0,  0.0)   );\n    color += Grab4(uv, 2.0, vec2(CalcOffset(1.0))   );\n    color += Grab8(uv, 3.0, vec2(CalcOffset(2.0))   );\n    color += Grab16(uv, 4.0, vec2(CalcOffset(3.0))   );\n    color += Grab16(uv, 5.0, vec2(CalcOffset(4.0))   );\n    color += Grab16(uv, 6.0, vec2(CalcOffset(5.0))   );\n    color += Grab16(uv, 7.0, vec2(CalcOffset(6.0))   );\n    color += Grab16(uv, 8.0, vec2(CalcOffset(7.0))   );\n\n\n    fragColor = vec4(color, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//Horizontal gaussian blur leveraging hardware filtering for fewer texture lookups.\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nfloat weights[5];\nfloat offsets[5];\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n    weights[0] = 0.19638062;\n    weights[1] = 0.29675293;\n    weights[2] = 0.09442139;\n    weights[3] = 0.01037598;\n    weights[4] = 0.00025940;\n    \n    offsets[0] = 0.00000000;\n    offsets[1] = 1.41176471;\n    offsets[2] = 3.29411765;\n    offsets[3] = 5.17647059;\n    offsets[4] = 7.05882353;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n    float weightSum = 0.0;\n    color += ColorFetch(uv) * weights[0];\n    weightSum += weights[0];\n\n    for(int i = 1; i < 5; i++)\n    {\n        vec2 offset = vec2(offsets[i]) / iResolution.xy;\n        color += ColorFetch(uv + offset * vec2(0.5, 0.0)) * weights[i];\n        color += ColorFetch(uv - offset * vec2(0.5, 0.0)) * weights[i];\n        weightSum += weights[i] * 2.0;\n    }\n\n    color /= weightSum;\n    fragColor = vec4(color,1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//Vertical gaussian blur leveraging hardware filtering for fewer texture lookups.\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nfloat weights[5];\nfloat offsets[5];\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n    weights[0] = 0.19638062;\n    weights[1] = 0.29675293;\n    weights[2] = 0.09442139;\n    weights[3] = 0.01037598;\n    weights[4] = 0.00025940;\n    \n    offsets[0] = 0.00000000;\n    offsets[1] = 1.41176471;\n    offsets[2] = 3.29411765;\n    offsets[3] = 5.17647059;\n    offsets[4] = 7.05882353;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n    float weightSum = 0.0;\n    \n    color += ColorFetch(uv) * weights[0];\n    weightSum += weights[0];\n\n    for(int i = 1; i < 5; i++)\n    {\n        vec2 offset = vec2(offsets[i]) / iResolution.xy;\n        color += ColorFetch(uv + offset * vec2(0.0, 0.5)) * weights[i];\n        color += ColorFetch(uv - offset * vec2(0.0, 0.5)) * weights[i];\n        weightSum += weights[i] * 2.0;\n    }\n\n    color /= weightSum;\n    fragColor = vec4(color,1.0);\n}","name":"Buffer D","description":"","type":"buffer"}]}