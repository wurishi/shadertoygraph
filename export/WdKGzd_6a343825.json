{"ver":"0.1","info":{"id":"WdKGzd","date":"1570801663","viewed":265,"name":"textured water from perlin","username":"onak","description":"water reflections from \"perlin\" noise, with added texture distortion","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["perlin","water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float pixelsize = 1.0;\nfloat PI = 3.14159265359;\n\nvec2 hash22(vec2 p) {\n    p = p*mat2(127.1,311.7,269.5,183.3);\n\tp = -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n\treturn sin(p*6.283 + iTime);\n}\n\nfloat perlin_noise(vec2 p) {\n\tvec2 pi = floor(p);\n    vec2 pf = p - pi;\n    \n    // interpolation\n    vec2 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    float f00 = dot(hash22(pi + vec2(0.0, 0.0)), pf - vec2(0.0, 0.0));\n    float f01 = dot(hash22(pi + vec2(0.0, 1.0)), pf - vec2(0.0, 1.0));\n    float f10 = dot(hash22(pi + vec2(1.0, 0.0)), pf - vec2(1.0, 0.0));\n    float f11 = dot(hash22(pi + vec2(1.0, 1.0)), pf - vec2(1.0, 1.0));\n    \n    // mixing top & bottom edges\n    float xm1 = mix(f00, f10, w.x);\n    float xm2 = mix(f01, f11, w.x);\n    \n    // mixing to point\n    float ym = mix(xm1, xm2, w.y); \n    \n    return ym;\n}\n\nfloat fBM2(float size, int octaves, float persistence, float scale, vec2 coord) {\n    float c = 0.0;\n    float p = 1.0;\n    float n = p;\n    \n    for (int i = 1; i <= octaves; i++) {\n        c += perlin_noise(coord * size) * p;\n        n    += p;\n        size *= scale;\n        p    *= persistence;\n    }\n    // normalize c\n    c /= n;\n    \n    return c;\n}\n\n// photoshop blend modes: https://www.shadertoy.com/view/XdS3RW\nvec4 blend_lighten(vec4 s, vec4 d) {\n    return max(s,d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    // normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    if (pixelsize > 1.0f) {\n   \t\tuv = (pixelsize * floor(iResolution.xy * uv / pixelsize)) / iResolution.xy;\n    }\n    \n   \t// noise-based reflections\n\tfloat n = fBM2(6.0, 3, 0.5, 2.5, uv);\n    //  tweak the reflection curve\n    n = sin(n * PI/0.1);\n    \n    // background distortion - reusing the noise value calculated for the reflections\n    vec2 swellDirection = vec2(0.4, 0.8);\n    float swellIntensity = 0.02;\n    float waveIntensity = 0.01;\n    vec2 coord = vec2(\n        n * waveIntensity + swellIntensity * sin(iTime * swellDirection.x),\n        n * waveIntensity + swellIntensity * sin(iTime * swellDirection.y)\n    );\n    \n    // output to screen\n    vec4 t = texture(iChannel0, uv + coord);\n    vec4 l = vec4(n, n, n, 1.0);\n    \n    fragColor = blend_lighten(t, l);\n}","name":"Image","description":"","type":"image"}]}