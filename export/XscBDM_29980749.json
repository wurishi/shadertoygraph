{"ver":"0.1","info":{"id":"XscBDM","date":"1525296197","viewed":233,"name":"Gabor Function","username":"chronos","description":"Simple adaption of the Gabor filter basis function as presented in the wikipedia article.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["filter","function","gabor","signal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n// From Wikipedia:\n// https://en.wikipedia.org/wiki/Gabor_filter#Example_implementations\nimport numpy as np\ndef gabor_fn(sigma, theta, Lambda, psi, gamma):\n    sigma_x = sigma\n    sigma_y = float(sigma) / gamma\n\n    # Bounding box\n    nstds = 3 # Number of standard deviation sigma\n    xmax = max(abs(nstds * sigma_x * np.cos(theta)), abs(nstds * sigma_y * np.sin(theta)))\n    xmax = np.ceil(max(1, xmax))\n    ymax = max(abs(nstds * sigma_x * np.sin(theta)), abs(nstds * sigma_y * np.cos(theta)))\n    ymax = np.ceil(max(1, ymax))\n    xmin = -xmax\n    ymin = -ymax\n    (y, x) = np.meshgrid(np.arange(ymin, ymax + 1), np.arange(xmin, xmax + 1))\n\n    # Rotation \n    x_theta = x * np.cos(theta) + y * np.sin(theta)\n    y_theta = -x * np.sin(theta) + y * np.cos(theta)\n\n    gb = np.exp(-.5 * (x_theta ** 2 / sigma_x ** 2 + y_theta ** 2 / sigma_y ** 2)) * np.cos(2 * np.pi / Lambda * x_theta + psi)\n    return gb\n**/\n\n// Directly adapted, unoptimized version\n#define PI 3.14159\nfloat gabor_fn(vec2 uv, float sigma, float theta, float Lambda, float psi, float gamma)\n{\n    float sigma_x = sigma;\n    float sigma_y = sigma / gamma;\n   \n    // \"Bounding Box\"\n    float nstds = 3., xmax, ymax, xmin, ymin;\n    xmax = max(\tabs(nstds * sigma_x * cos(theta)),\n        \t\tabs(nstds * sigma_y * sin(theta)));\n    xmax = ceil(max(1., xmax));\n    ymax = max(\tabs(nstds * sigma_x * sin(theta)),\n        \t\tabs(nstds * sigma_y * cos(theta)));\n    ymax = ceil(max(1., ymax));\n    xmin = -xmax;\n    ymin = -ymax;\n    \n    float x = (xmax - xmin) * uv.x + xmin;\n    float y = (ymax - ymin) * uv.y + ymin;\n    \n    // Rotation\n    float x_theta = x * cos(theta) + y * sin(theta);\n    float y_theta = -x * sin(theta) + y * cos(theta);\n    \n    float gb = \n         exp( -.5 * \n             (pow(x_theta / sigma_x, 2.) + \n              pow(y_theta / sigma_y, 2.))\n        \t) *\n            cos(2. * PI / Lambda * x_theta + psi);\n    \n    return gb;\n}\n\n// Somewhat compactified Gabor function\nfloat gabor_fn2(vec2 uv, float sigma, float theta, float Lambda, float psi, float gamma)\n{\n    vec2 sigma_xy = vec2(sigma, sigma / gamma);\n   \n    vec2 trig = vec2(cos(theta), sin(theta));\n    \n    const float nstds = 5.; // \"Bounding Box\"\n    vec4 bounds = abs(nstds * sigma_xy.xxyy * trig.xyyx);\n    vec2 max_bounds = ceil(max(vec2(1),max(bounds.xy, bounds.zw)));\n    \n    vec2 xy = 2. * max_bounds * uv - max_bounds;\n    vec2 xy_theta = mat2(trig.x, -trig.y, trig.y, trig.x) * xy; // Rotate by theta\n    \n    return\n         exp( -.5 * dot(pow(xy_theta / sigma_xy, vec2(2)), vec2(1))) *  // 2D Gaussian\n            cos(2. * PI / Lambda * xy_theta.x + psi);\t\t\t\t\t// Cosine \n}\n\n// From: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.28.6586&rep=rep1&type=pdf\n// Omega = color spiral rotation frequency\n// Phi   = color spiral rotation phase\n// Assumes 0 <= t <= 1\nvec3 pseudocolor(float t, float omega, float phi)\n{\n    const float root3 = sqrt(3.);\n\tmat3 rot = mat3(1. + root3, 1. - root3, -2., // Rotate to spiral around grayscale axis\n                    1. - root3, 1. + root3, -2.,\n                    2         , 2         ,  2);\n    float r = sqrt(1.5) * t * (1.-t); // spiral radius\n    vec3 spiral = vec3(r * sin(omega * t + phi),\n                       r * cos(omega * t + phi),\n                       root3 * t);\n\treturn rot * spiral / (2. * root3);  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // center and fix aspect ratio\n    vec2 uv = (fragCoord - .5 * vec2(iResolution.x - iResolution.y, 0.)) /iResolution.y;\n\n    // Gabor function parameters\n    float             // Attempt at interpreting values from formulas :)\n        sigma   = 1., // Standard Deviation\n        theta   = 1., // Rotation\n        Lambda  = .5, // Oscilation inverse frequency\n        psi     = 1., // Oscilation phase\n        gamma   = 1.; // Standard deviation // falloff \"aspect ratio\"\n    \n    // Animate parameters\n    theta *= iTime / 4.;\n    sigma *= 4. * abs(iMouse.x/iResolution.x - .5);\n    Lambda *= mix(2., .1, iMouse.y/iResolution.y);\n    psi   *= 5. * iTime;\n    gamma *= mix(.5, 2., iMouse.x/iResolution.x);\n    \n    // Gabor function\n    float gb = gabor_fn2(uv, sigma, theta, Lambda, psi, gamma);\n\n    // Color parameters\n    float omega = 5.5; // Pseudocolor hue frequency\n    float phi = 2.1;   // Pseudocolor hue phase\n    const float scale = exp(0.);\n    vec3 col = pseudocolor(.5*(gb / scale + 1.), omega, phi);\n    \n    // Show only unit square area\n    col *=  step(0., uv.y) * step(0., 1.-uv.y) * step(0., uv.x) * step(0., 1.-uv.x);\n    \n    fragColor = vec4(col,1.0); // Output to screen\n}","name":"Image","description":"","type":"image"}]}