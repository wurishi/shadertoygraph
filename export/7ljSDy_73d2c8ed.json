{"ver":"0.1","info":{"id":"7ljSDy","date":"1628654285","viewed":193,"name":"Bad moon rising","username":"Vinicius_Jesus","description":"Simple ray march scene. ","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["raymarch","moon","blend","dark"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;         \n    fragColor = vec4(texture( iChannel0, p ));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_STEPS 500\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec4 Tex3D(in vec3 p, in vec3 n, sampler2D s) {\n    return texture(s, p.yz, 0.0) * abs(n.x) + \n           texture(s, p.xz, 0.0) * abs(n.y) + \n           texture(s, p.xy, 0.0) * abs(n.z);\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdSphere(in vec3 pos, float rad){\n    float d = length(pos)-rad;\n    return d;\n}\n\nfloat sdElipsoid(in vec3 pos, vec3 rad){\n    float d0 = length(pos/rad);\n    float d1 = length(pos/rad/rad);\n    \n    return d0*(d0-1.0)/d1;\n}\n\nfloat smin(in float a, in float b, float k){\n    float h = max(k - abs(a-b), 0.);\n    return min(a,b) - h*h/(k*4.);\n}\n\nfloat smax(in float a, in float b, float k){\n    float h = max(k - abs(a-b), 0.);\n    return max(a,b) + h*h/(k*4.);\n}\n\nvec2 hash(float n) {\n    return fract(sin(vec2(n, n + 1.0)) * vec2(437.685, 228.135));\n}\n\nvec2 sdMoon(in vec3 pos, float aTime){\n    vec3 cen = vec3(0., 1., aTime-1.);\n    vec3 p = pos-cen;\n    \n    p.yz *= Rot(-.25);\n    \n    float bump = 0.0;\n    \n    vec3 h = p;\n    \n    vec2 t = normalize(hash(aTime)) * (2./200.0);\n    h.xy += t;\n        \n    //moon\n    float d = sdSphere(h-vec3(0., .3, 0.), .5);\n    \n    vec3 sh = vec3(abs(h.x), h.yz); //simetric\n    \n    //eyebrows\n    vec3 eb = sh-vec3(.1,.5, .33);\n    eb.xy = (mat2(1,-4,4,3)/5.)*eb.xy; //rotate eyebrows evil face\n    float d2 = sdElipsoid(eb, vec3(.1, .08, .15));\n    d = smin(d, d2, .04);\n    \n    //hole eye\n    vec3 dm = vec3(.20,.4, .5);\n    d2 = sdSphere(sh - dm, .11);\n    d = smax(d, -d2, .01);\n    \n    //nouse\n    d2 = sdCapsule(h - vec3(.0 ,.4 ,.45), vec3(0,-.1,.1), vec3(0,0,0), .07);\n    d = smin(d, d2, .04);\n    \n    vec3 bn = sh-vec3(.04,.28, .5);\n    bn.xy = (mat2(1,-4,4,3)/5.)*bn.xy;\n    d2 = sdElipsoid(bn, vec3(.060, .05, .08));\n    d = smin(d, d2, .04);\n    \n    //mouth\n    d2 = sdElipsoid(h-vec3(0.,0.11 - 1.*h.x*h.x,0.5), vec3(.2, .08, .3));\n    d = smax(d, -d2, .03);\n    \n    if(d < d + .055) {\n\t\tbump = Tex3D(h * .55, h, iChannel0).r * .055;\n\t}\n    \n\td += bump;\n    \n    vec2 res = vec2(d, 2.);\n    \n    //eye\n    d2 = sdSphere(sh - vec3(.17,.4, .38), .04);\n    if (d2<d) res = vec2(d2, 3.);\n    \n    d = smin(d, d2, .03);\n    \n    // teeth\t\n    if( sh.x<0.2 ) {\n        h.x = mod(abs(h.x), .1);\t\n        d2 = sdElipsoid(h-vec3(.05,.005, .258), vec3(.05, .065, .05));\n        d2 *= sdElipsoid(h-vec3(.05, .22, .39), vec3(.05, .065, .05));\n        \n        if( d2<d ) res = vec2( d2, 4. );\n\n        d = smin(d, d2, .03);\n    }\n    \n    // ground\n    float fh = -.1 + .1 * (sin(2.5*pos.x)+sin(2.5*pos.z));\n    d = pos.y + fh;\n    \n    // waves ground\n    vec3 vp = vec3(mod(abs(pos.x), 3.), pos.y, mod(pos.z+1.5, 3.)-1.5);\n    vec2 id = vec2(floor(abs(pos.x)/3.), floor((pos.z+1.5)/3.));\n    float fid = id.x*11.2 + id.y * 31.6;\n    float fy = fract(fid*1.312+aTime*.1);\n    float by = -1.+1.*fy;\n    float siz = 4.5*fy*(1.-fy);\n    \n    d2 = sdSphere(vp-vec3(2.,by,0.), siz);\n    \n    bump = 0.0;\n    \n    if(d < d + .065) {\n\t\tbump = Tex3D(p * .55, vec3(0,1,0), iChannel0).r * .065;\n\t}\n    \n    d = smin(d,d2,.2) - bump;\n    \n    if(d<res.x) res = vec2(d, 1.);\n    \n    return res;\n}\n\nvec2 map(in vec3 pos, float time) {\n    return sdMoon(pos, time);\n}\n\nvec3 calcNormal(in vec3 pos, float time) {\n    vec2 e = vec2(0.0001, 0.);\n    return normalize(vec3(map(pos+e.xyy, time).x-map(pos-e.xyy, time).x,\n                          map(pos+e.yxy, time).x-map(pos-e.yxy, time).x,\n                          map(pos+e.yyx, time).x-map(pos-e.yyx, time).x));\n} \n\nvec2 rayMarch(in vec3 ro, in vec3 rd, float time) {\n    vec2 res = vec2(-1.,-1.);\n    \n    float tmin = .5;\n    float tmax = 20.;\n    \n    float t = tmin;\n    for(int i=0; i<MAX_STEPS && t<tmax; i++) {\n    \n        vec3 pos = ro + rd * t; \n        vec2 h = map(pos, time);\n        \n        if(abs(h.x)<(.001*t)) {\n            res = vec2(t, h.y);\n            break;\n        }\n        t += h.x;\n    }  \n    \n    return res;\n}\n\nfloat calcSoftshadow(in vec3 ro, vec3 rd, float time){\n    float res = 1.0;\n    \n    float tmax = 12.0;\n    float tp = (3.4-ro.y)/rd.y;\n    \n    if( tp>0.0 ) tmax = min( tmax, tp );  \n    \n    float t = 0.02;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, time ).x;\n        res = min( res, mix(1.0,16.0*h/t, 1.) );\n        t += clamp( h, 0.05, 0.40 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcOcclusion(in vec3 pos, in vec3 nor, float time) {\n    \n    float occ = 0.;\n    float sca = 1.;\n    \n    for(int i=0; i<5; i++) {\n        float h = .01 +.11 * float(i)/4.;\n        vec3 opos = pos + h * nor;\n        float d = map(opos, time).x;\n        occ += (h-d)*sca;\n        sca *= .95;\n    }\n    return clamp(1. - 2.*occ, 0., 1.);\n}\n\nvec3 render(in vec3 ro, vec3 rd, float time) {\n    \n    //sky\n    vec3 col = vec3(.05, .04, .04) - max(rd.y, 0.)*.15;\n    \n    vec2 res = rayMarch(ro, rd, time);\n    \n    if (res.y > 0.) {\n        float t = res.x;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos, time);\n        vec3 ref = reflect(rd, nor);\n        \n        col = vec3(0.);\n        \n        if(res.y<1.5) //floor material\n        {\n            col = vec3(.08, .01, .01);\n            \n        } else if(res.y<2.5) //body material\n        {\n            col = vec3(.05);\n            \n        } else if(res.y<3.5) //eye material\n        {\n            col = vec3(1.,0.,0.);\n            \n        } else if(res.y<4.5) //teeth material\n        {\n            col = vec3(.25);\n            \n        }\n        \n        //occ\n        float occ = calcOcclusion(pos, nor, time);\n        float spe = clamp(.5+dot(nor,rd),0.0,1.0);\n        \n        //lighting\n        vec3  light_dir = normalize( vec3(0.6, 0.35, 0.5) );\n        \n        float light_dif = clamp(dot( nor, light_dir ), 0.0, 1.0 );\n        vec3  light_hal = normalize( light_dir-rd );\n        float light_spe = pow(clamp(dot(nor,light_hal),0.0,1.0),8.0)*light_dif*(0.04+0.96*pow(clamp(1.0+dot(light_hal,rd),0.0,1.0),5.0));\n        \n        float light_sha = calcSoftshadow( pos, light_dir, time );\n        //float light_sha = step(rayMarch( pos+0.001*nor, light_dir,time ).y,0.0);\n        \n\t\tfloat sky_dif = sqrt(clamp( .5 + .5 * nor.y, 0., 1. ));\n        float sky_spe = smoothstep( .0, .5, ref.y )*(.04 + .96 * spe);\n\n\t\tvec3 lin = vec3(0.0);\n        lin += light_dif*vec3(8.10,6.00,4.20)*vec3(light_sha,light_sha*0.5+0.5*light_sha,light_sha*light_sha);\n        lin += sky_dif*vec3(0.50,0.70,1.00)*occ;\n\t\tcol = col*lin;\n        \n\t\tcol += light_spe*vec3(9.90,8.10,6.30)*occ;\n        col += sky_spe*vec3(0.05,0.05,0.05)*occ;\n        \n        //foog\n        vec3 fogc = vec3(.05, .04, .04);\n        col = mix(col, fogc, 1.-exp(-.008*t*t*t));\n    }\n    \n    return col;\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n    \n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = cross(cu, cw);\n    return mat3(cu, cv, cw);\n}\n\n#define AA 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 total = vec3(0.);\n    \n    for( int m=0; m<AA; m++ ) {\n    \n        for( int n=0; n<AA; n++ ) {\n        \n            vec2 offset = -.5+vec2(float(m), float(n))/float(AA);\n\n            vec2 p = (2.0*(fragCoord+offset)-iResolution.xy)/iResolution.y;\n            float time = iTime;\n            time *= 1.2;\n\n            //camera\n            float an = 10.*iMouse.x/iResolution.x; //rotate camera\n            float cd = 0.;\n            vec3 ta = vec3(.0, .9, .2+cd+time);\n            vec3 ro = ta + vec3(sin(an),0.,cos(an));\n\n            mat3 cam = setCamera(ro, ta, 0.);\n            \n            float zoom = 1.8;\n            vec3 rd = cam * normalize(vec3(p, zoom));\n\n            vec3 col = render(ro, rd, time);\n\n            col = pow(col, vec3(.5565));\n\n            total += col;\n        }\n    }\n    \n    total /= float(AA*AA);\n\n    fragColor = vec4(total,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}