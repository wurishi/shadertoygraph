{"ver":"0.1","info":{"id":"4c3yWM","date":"1730817750","viewed":41,"name":"raymarched scene test","username":"silly_goose","description":"just a simple raymarched scene","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec4 roundMerge(vec4 item1, vec4 item2, float radius) {\n    vec2 intersection = vec2(item1.w - radius, item2.w - radius);\n    intersection = min(intersection, 0.0);\n    float insideDistance = -length(intersection);\n    float simpleUnion = min(item1.w, item2.w);\n    float outsideDistance = max(simpleUnion, radius);\n    vec3 intersectionColor = mix(item1.xyz, item2.xyz, 0.5);\n    vec3 outputColor = item1.w < item2.w ? item1.xyz : item2.xyz;\n    \n    if (outsideDistance > item1.w && outsideDistance > item2.w) {\n        outputColor = intersectionColor;\n    }\n    \n    return  vec4(outputColor, insideDistance + outsideDistance);\n}\n\nvec3 repeat(vec3 p, float c) {\n    return vec3(mod(p.x,c)-0.5*c, p.y, mod(p.z,c)-0.5*c);\n}\n\nvec4 sphereSDF(vec3 color, vec3 p) {\n    return vec4(color, length(p) - 1.0);\n}\n\nvec4 boxSDF(vec3 color, vec3 p)\n{\n    \n    vec3 scaleTransform = vec3(2000.0, 0.5, 2000.0);\n    vec3 translateTransform = vec3(0.0, 7.0, -2000.0);\n    float displacement = sin(p.x * cos(p.z + iTime) + iTime) * sin(cos(p.y + iTime) + iTime) + .5 * sin(cos(p.z / 2.0) + iTime);\n    vec3 d = abs(p + translateTransform) - scaleTransform;\n    return vec4(color, min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0))) + displacement;\n}\n\n\nvec4 sceneSDF(vec3 p) {\n    // p = repeat(p + vec3(0.0, 0.0, 0.0), 40.0);\n    vec4 scene = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    \n    vec4[5] sceneItems;\n    float offset = 1.0;\n    sceneItems[0] = boxSDF(vec3(sin(iTime * offset) + 1.0, cos(iTime * offset) + 1.0, normalize(iTime * offset) + 1.0), p);\n    \n    \n    //scene = roundMerge(sceneItems[0], sceneItems[1], 0.5);\n    scene += sceneItems[0];\n    \n    return scene;\n}\n\n\n\nvec3 calculateNormal(vec3 rd) {\n    vec3 normal = normalize(vec3(sceneSDF(vec3(rd.x + 0.01, rd.yz)).w - sceneSDF(vec3(rd.x - 0.01, rd.yz)).w,\n                                 sceneSDF(vec3(rd.x, rd.y + 0.01, rd.z)).w - sceneSDF(vec3(rd.x, rd.y - 0.01, rd.z)).w,\n                                 sceneSDF(vec3(rd.xy, rd.z + 0.01)).w - sceneSDF(vec3(rd.xy, rd.z - 0.01)).w));\n    return normal;\n}\n\nvec3 calculateAmbient() {\n    vec3 ambientLight = vec3(0.3);\n    return ambientLight;\n}\n\nvec3 calculateDiffuse(vec3 ro, vec3 rd, vec3 currentPosition, vec3 normal, vec3[1] lightSources) {\n    vec3 relativeLightSourcePos = normalize(lightSources[0].xyz - currentPosition);\n    vec3 diffuse;\n    diffuse += max(0.0, dot(normal, relativeLightSourcePos));\n    return diffuse;\n}\n\nfloat calculateSpecular(vec3 ro, vec3 rd, vec3 currentPosition, vec3 normal, vec3[1] lightSources) {\n    vec3 relativeLightSourcePos = normalize(lightSources[0].xyz - currentPosition);\n    vec3 reflectDir = reflect(relativeLightSourcePos, normal);\n    float specular = pow(max(dot(rd, reflectDir), 0.0), 16.0);\n    return specular;\n}\n\nvec3 calculateLighting(vec3 ro, vec3 rd, vec3 currentPosition, vec3[1] lightSources) {\n\n    vec3 outputColor = sceneSDF(currentPosition).xyz;\n\n    vec3 normal = calculateNormal(currentPosition);\n    \n    vec3 ambient = calculateAmbient();\n    vec3 diffuse = calculateDiffuse(ro, rd, currentPosition, normal, lightSources);\n    float specular = calculateSpecular(ro, rd, currentPosition, normal, lightSources);\n    \n    outputColor = outputColor * (ambient + diffuse + (0.5 * specular));\n    return outputColor;\n}\n\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n    \n    vec3[1] lightSources;\n    lightSources[0] = vec3(cos(iTime) * 10.0, 6.0, sin(iTime) * 10.0 + 30.0);\n    float depth = 0.0;\n    \n    for (int i = 0; i < 10000; i++) {\n        vec3 currentPosition = ro + depth * rd;\n        float dist = sceneSDF(ro + depth * rd).w;\n        \n        if (dist < 0.001) {\n            return calculateLighting(ro, rd, currentPosition, lightSources);\n        }\n        depth += min(dist, 2.5);\n    if (depth >= 200.0) {\n            break;\n        }\n    }\n    return vec3(0.7);\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Move origin to the center of the screen\n    vec2 uvCenter = uv - 0.5;\n    // Fix aspect ratio\n    uvCenter.x *= iResolution.x/iResolution.y;\n    \n    vec3 cameraPos = vec3(0.0, 5.0, -10.0);\n    vec3 cameraDir = normalize(vec3(vec2(uvCenter.x, uvCenter.y - .6), 1));\n\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0, 0.0, 0.0);\n\n    \n\n  \n    \n    \n    \n    \n\n        col = rayMarch(cameraPos, cameraDir);\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}