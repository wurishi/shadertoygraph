{"ver":"0.1","info":{"id":"XtsczM","date":"1504068992","viewed":261,"name":"Antialiased grid of dots","username":"etale_cohomology","description":"Fork of cacheflowe's https://www.shadertoy.com/view/MdBfzm\n\nThe dot radius is constant, regardless of how many dots per `uv` unit there are.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["2d","simple","grid","zoom","antialias","dots","scale","scaling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of cacheflowe's https://www.shadertoy.com/view/MdBfzm\n\n#define SCALE       1. * ((1.01 + sin(.5 * iTime)) * 6.)\n#define DOT_FREQ    .5\n#define DOT_RADIUS .1\n\nfloat sdf_disk(vec2 uv, float radius, vec2 center){\n    return distance(uv, center) - radius;\n}\n\n// @scale is a number that aids antialiasing!\nfloat draw_dotgrid(vec2 uv, float scale){\n    vec2 uv_repeat  = mod(uv - .5 * DOT_FREQ, DOT_FREQ) - .5 * DOT_FREQ;\n    //vec2 uv_repeat = fract(uv * N_DOTS - .5) - .5;\n\n    float dot_aa     = 4. * scale / iResolution.y;  // Scale-sensitive antialiasing!\n    float dot_radius = DOT_RADIUS;  // Keep radius constant, shrink spacing between dots!\n    return smoothstep(dot_aa, .0, sdf_disk(uv_repeat, dot_radius, vec2(0)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = SCALE * (2. * fragCoord - iResolution.xy) / iResolution.y;  // The Fabrice map!\n\tfloat dotgrid = draw_dotgrid(uv, SCALE);\n    fragColor.rgb = vec3(dotgrid);\n}\n\n/*\n// GregRostami's golfed version! (144 chars)\n\n#define mainImage(o,U)\t\t\t\t\t\t\t\t\t\t\t\t\\\nvec2 R = iResolution.xy,\t\t\t\t\t\t\t\t\t\t\t\\\n    u = ( o.a = (1.02 + sin(.5*iTime)) * 6.) * (U+U - R) / R.y;\t\t\\\n\to += smoothstep(8. * o.a / R.y, .0, length(fract(u+u-.5)-.5) - .2)\n*/","name":"Image","description":"","type":"image"}]}