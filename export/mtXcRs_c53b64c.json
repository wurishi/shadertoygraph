{"ver":"0.1","info":{"id":"mtXcRs","date":"1691089808","viewed":58,"name":"Foggy Graveyard","username":"andrew741","description":"A foggy graveyard. Didn't come out perfect but it's still alright.\n\nYou can look around using the mouse.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["volume","cloud","fog","stars","moon","night","volumetrics","graveyard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define Itterations 16.\n#define MaxFogDepth 10.\n\n// the matrix for the hash function\n#define HashMat  mat3( vec3(127.1,311.7, 74.7), vec3(269.5,183.3,246.1),vec3(113.5,271.9,124.6))\n#define HashMat2 mat2( vec2(127.1, 311.7), vec2(269.5, 183.3))\n\n// this hash is from someone elses shader (with a slight modifaction)\nvec3 hash(vec3 p) {  return fract(sin(p * HashMat ) * 43758.5453123) * 2. - 1.;  }\nvec2 hash(vec2 p) {  return fract(sin(p * HashMat2) * 43758.5453123) * 2. - 1.;  }\n\n// from another persons shader\nfloat Perlin(vec3 x)\n{\n    // grid\n    vec3 i = floor(x);\n    vec3 w = fract(x);\n    \n    // cubic interpolant\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    \n    // gradients\n    vec3 ga = hash( i+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( i+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( i+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( i+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( i+vec3(0.0,0.0,1.0) );\n\tvec3 gf = hash( i+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( i+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( i+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolations\n    return va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z;\n}\n\n\n// multiple layers of perlin noise (to provide more detial to it)\nfloat Fractal(vec3 p)\n{\n    float perlin  = Perlin(p      ) * 0.4 ;\n    perlin       += Perlin(p * 2. ) * 0.27;\n    perlin       += Perlin(p * 4. ) * 0.17;\n    perlin       += Perlin(p * 8. ) * 0.1 ;\n    perlin       += Perlin(p * 16.) * 0.06;\n    return pow(max(perlin * 2. - 0.05, 0.), 0.5);\n}\n\n// rotates a 2d point based on an angle\nvec2 rot2D(vec2 v, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return v * mat2(ca, -sa, sa, ca);\n}\n\n// renders grave stones\nfloat GraveStone(vec2 uv, float scale, vec2 offset)\n{\n    // getting the relative position\n    vec2 np = vec2(mod(uv.x * scale - offset.x, 0.5) - 0.25, uv.y * scale + offset.y);\n    float bright = 1.;\n    \n    // drawing the grave stone\n    if (abs(np.x-0.03) < 0.1 && abs(np.y-max(np.x - 0.1, 0.)) < 0.15 || length(np-vec2(0.031, 0.16)) < 0.1) bright = 0.5;\n    if (abs(np.x) < 0.1 && abs(np.y) < 0.15 || length(np-vec2(0., 0.15)) < 0.1) bright = 0.05;\n    \n    // drawing the letters\n    if (abs(np.x+0.06) < 0.004 && abs(np.y-0.1  )<0.03 ) bright = 0.99;\n    if (abs(np.x+0.03) < 0.004 && abs(np.y-0.116)<0.015) bright = 0.99;\n    if (abs(np.x + 0.045) < 0.015 && abs(np.y - 0.1) < 0.004) bright = 0.99;\n    if (abs(np.x + 0.045) < 0.015 && abs(np.y - 0.129) < 0.004) bright = 0.99;\n    if (abs(-np.x-(np.y-0.045)) < 0.006 && abs(np.x+0.045) < 0.0155) bright = 0.99;\n\n    if (abs(np.x-0.007) < 0.004 && abs(np.y - 0.1  )< 0.03  ) bright = 0.99;\n    if (abs(np.x-0.007) < 0.015 && abs(np.y - 0.07 ) < 0.004) bright = 0.99;\n    if (abs(np.x-0.007) < 0.015 && abs(np.y - 0.129) < 0.004) bright = 0.99;\n\n    if (abs(np.x-0.05) < 0.004 && abs(np.y-0.1  )<0.03 ) bright = 0.99;\n    if (abs(np.x-0.08) < 0.004 && abs(np.y-0.116)<0.015) bright = 0.99;\n    if (abs(np.x - 0.065) < 0.015 && abs(np.y - 0.1) < 0.004) bright = 0.99;\n    if (abs(np.x - 0.065) < 0.015 && abs(np.y - 0.129) < 0.004) bright = 0.99;\n    \n    // returning the final brightness\n    return bright;\n}\n\n// the main method\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // getting the uv coord\n    vec2 offset = vec2(iMouse.x/iResolution.x + iTime*0.08, iMouse.y/iResolution.y*0.2-0.05);\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    float tvx = max(uv.x, 0.);\n    \n    // rendering the sky (starts + moon)\n    vec2 starUv = uv + vec2(iTime*0.015, iTime*0.02);\n    float twinkle = Perlin(vec3(starUv * 100., -iTime * 0.75));\n    float stars = min(twinkle * max(hash(round(starUv*500.)/500.).x - 0.99, 0.) * 20000., 1.);\n    float moonCraters = pow(length(texture(iChannel2, uv).rgb), 4.);\n    float moon = smoothstep(0.2, 0.19, length(uv-vec2(0.8, 0.5)));\n    vec3 col = mix(vec3(0., 0., 0.1) + max(stars - tvx*1.2, 0.) + tvx*0.3, max(vec3(0.75)-min(moonCraters, 0.2), 0.), moon);\n    \n    // rendering the ground\n    float groundFog = exp(-uv.y*3.-0.9);\n    if (groundFog > 0.245) col = mix(vec3(0., 0., 0.1), texture(iChannel0, (uv+vec2(uv.x*0.2, 0.))*2.+offset).rgb * vec3(0.1, 0.2, 0.1), smoothstep(0., 0.4, groundFog));\n    \n    // rendering the fog and gravestones \n    for (float i = Itterations; i > 0.; i--)\n    {\n        vec2 nUv = uv + offset/i;\n        \n        // rendering grave stones\n        float height = uv.y * i + (-i * 0.2 + 0.4);\n        float grave = GraveStone(nUv, i, vec2(i - 0.15, -i * 0.2 + 0.4));\n        if (grave < 1.) col = texture(iChannel1, nUv).rgb * grave/i;\n        \n        // rendering the fog\n        if (i < MaxFogDepth)\n        {\n            float fog = Fractal(vec3(nUv, i + iTime*0.05)) / i * 0.4;\n            col += fog * (height+0.25) * 1.75 * clamp(uv.x + 0.3, 0.4, 1.);\n        }\n    }\n    \n    // the final color\n    fragColor = vec4(pow(col, vec3(0.9)), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}