{"ver":"0.1","info":{"id":"lcXSDB","date":"1705647249","viewed":190,"name":"2D Lighting Demo (WIP MK2.)","username":"Ironbard","description":"A shader demonstrating a 2D light that you can mess around with! : D\n\nThis was inspired by a post on the discord for one of my favourite games; Barotrauma!","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["2d","2d","mouse","attenuation","light","cone"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//   _   _  _____ __   __   _      _ \n//  | | | || ____|\\ \\_/ /  / \\    | |\n//  | |_| || |_    \\   /  / _ \\   | |\n//  |  _  ||  _|    \\ /  / /_\\ \\  |_|\n//  | | | || |___   | | / _____ \\  _\n//  |_| |_||_____|  |_|/_/     \\_\\(_)\n//\n// Hullo there! And welcome to my humble shader abode! : D\n// \n// This shader demonstrates how editable 2D-lights might be generated for use in the AWESOME game;\n//\n//                                 █ █ █\n//██████████████████████████████████░█▒█████████████████████████████████████████\n//█░░░░░░▓▓░░░░░░█▒░░░░░▓█▓░░░▒▓█░░▒░░░░░▒▓░░░░▒██░░░░░░▓▓░▒██░░█▒▓███▓▓█░░░░░░▓\n//█░░░▒░░▒▓░░▒▒░░█░░░▒░░░█░░▒▒░░▓░░░░░░░░▒▒░░▒░░▓█░░▒▒░░▓▓░░██░░█▒░░░░░▒█░░▒▒░░▓\n//█░░▓█░░▒▓░░█▓░░█░░▒█▒░▒█░░██░░▓░░░░░░▒░▒░░▒█▒░░█░░▓█░░▓▓░░██░░█▒░░▒░░▒█░░▓█░░▓\n//░░░░░░░▓▓░░░░░░█░░░░░░▓█░░██░░▓██▓░░░▒██░░░░░░▒█░░░▒░░▓▓░░██░░█▒░▒█▒░▒█░░░▒░░▓\n//▒░░▒▒░░▓▓░░▒░░░█░░░░░░▒█░░██░░▓██░░░░░▓█░░░░░░░█░░▒▒░░▓▓░░██░░█▒░▒█▒░▒█░░▒▒░░░\n//█░░▓█░░▒▓░░██░░█░░▒▓░░░█░░▓█░░▓█▓▒░░░▓██░░▒█▒░░▓▒░▓█░░▓▓░░██░░█▒░▒█▒░░█░░▓█░░░\n//█░░▓█░░▒▓░░█▓░░█░░▒█▒░▒█░░░░░░▒██▒░░░▓██░░▒█▒░░█░░▓█░░▓▓░░▓▓░░█▒░▒█▒░░█░░▓█░░▓\n//█░░░░░░▒▓░░█▓░░█░░▒█▒░▒█░░░░░░▓███░░░▒▓█▒░▒█▒░▒█░░██░░▓▓░░░░░░█▒░▒█▒░░█░░▓█░░█\n//██████████████████████████████████░░░█████████████████████████████████████████\n//                               ██▒░░▓█                                        \n//                              █▓▒▒███                                         \n//\n// -developed by FakeFish, Undertow Games and published by Daedalic Entertainment.\n//\n// .............................................................................\n//\n// Pardon for the mess in the other files.\n// The code is not complete yet; but I thought there was enough here to show that it can be done! A Mark I!\n//\n// Most of the controls live in the \"Common\" tab on the upper left.\n// Some controls are also in \"BufferA\", because I haven't yet figured out how to seperate the code as neatly as I'd like.\n//\n// So far the controls cover the following:\n//\n//   AimDirection  -> Direction the light is pointed in, measured in degrees from 0° to 360°!(Goes counter-clockwise and starts from the right!)\n//\n//   HalfBeamAngle -> How focused the light is, measured in degrees from 0° ~ 180°. (If you want the arc to cover 45°, then type in '45.0/2.0' or '22.5' if you're cool.)\n//\n//   LightColor    -> The Red, Green and Blue components of the light, measured as 32 bit float from 0.0 ~ 1.0.\n//\n//   RotationSpeed -> How fast the light rotates, if ROTATE is defined; measured in degrees ° per second.\n//   \n//   \n// The the plan is to also implement the following:\n// \n//   Flicker          \n//   Flicker Speed    \n//   Pulse Frequency\n//   Pulse Amount\n//   Blink Frequency\n// \n// -all based on the source available at:\n//\n//   https://github.com/Regalis11/Barotrauma/blob/master/Barotrauma/BarotraumaClient/ClientSource/Map/Lights/LightSource.cs\n//\n// -so as to get the best feel for what it could be like if implemented in the game.\n//\n// For now I'm keeping the controls minimalistic, because thinking in shaders is difficult. (t_t )\n//\n// ...\n//\n// Version Notes :\n// ¯¯¯¯¯¯¯¯¯¯¯¯¯¯\n// /¯¯¯¯¯¯¯¯\\\n// | MK  I  |\n// \\        /\n//  \\      ∕\n//   ◟  ◞\n//     ⤻\n//\n//     ↳ A monolithic slab of code, yet somehow the barebones proof of concept.\n//\n//\n// /¯¯¯¯¯¯¯¯\\\n// | MK  II |\n// \\        /\n//  \\      ∕\n//   ◟  ◞\n//     ⤻\n//\n//     ||↳ Seperated out some stuff into its own files namely; \"Common\" and \"Buffer A\".\n//     ||                                                              \n//     |↳ The buffer allows for easier rendering out to a texture. , ÷ ^ ^ ^ ƒ ;\n//     |                                                           |\\_/¯|±|¯\\_/|\n//     ↳ Also made this dope landing page!                         |___________|\n//                                                                ༼༼༼(◥Ø▶ل͜◀O◤)༽༽༽\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    fragColor = vec4(col.rgb, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Play around with these!\n//\nfloat aimDirection = radians(float(45.0)); // 0° = Right, 90° = Up, 180° = Left, 270° = Down, 360° = Right ... etc. ad infinitum!\nfloat halfBeamAngle = float(45); // Changes the broad or narrow the beam is! Think of it as the FoV(Field of View) of the light beam!\n\nvec3 lightColor = vec3(0.250,0.611,1.0);// 64, 156, 255\nfloat rotationSpeed = float(1.0); // °'s per second\n\n// These values control how the light attenuates for the basic\nfloat a = 1.0; //x\nfloat b = 1.0; //x^2\nfloat c = 1.0; //x^3\n\n// Some setup variables and helpful constants.\n\nconst float PI = 3.1415926; // FP32 only has accuracy for the intwfwe part and 7 decimals? A note of Arcana to be reviewed in the near future!\nconst vec2 uvMid = vec2(0.0, 0.0);\nvec2 pMid = vec2(400, 225); // Default resolution for shadertoy seems to be 800x450; hence half of that 400x225. But I am also setting it in the shader, so that it works in fullscreen.\n\nvec3 errorMagenta = vec3(1.0, 0.0, 1.0); // Handy to quickly multiply the output with a predefined error-color.\n\n/* Comment and Uncomment the defines, in order to see what each part contributes to the whole! : D */\n\n// ------------------------------\n// | Light Aim Defines |\n// ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯\n// Choose one of these(uncomment the \"//\" at the beginning of the next line!), or none! I mean you can choose both, but I havent had the time to check what happens!\n\n//#define ROTATE 1\n#define SEEK 1\n\n// ------------------------------\n// | Light Attenuation Defines |\n// ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯\n// Choose only one of these! If you choose more than one, then the colors will be tinted with 'errorMagenta'!\n//\n// #define ATTENUATE_ABC 1\n #define ATTENUATE_NO_CUSP 1\n// #define ATTENUATE_CUSP 1\n\n\n\n//#define CLAMP 1\n\nvoid validateSetupVars()\n{\n    halfBeamAngle = abs(halfBeamAngle) > 180.0 ? mod(abs(halfBeamAngle), 180.0) : abs(halfBeamAngle);\n}\n\n\nfloat sqr(float inputX)\n{\n    return inputX * inputX;\n}\n\n\n#ifdef ATTENUATE_ABC\nfloat lightAttenuationABC(float inputDistance)\n{\n    float lDistMin = 0.01;\n    float attenuatedLight = ( (lDistMin / inputDistance) * a) +\n                            ( (lDistMin / (inputDistance * inputDistance)) * b) +\n                            ( (lDistMin / (inputDistance * inputDistance * inputDistance)) * c);\n    return attenuatedLight;\n}\n#endif\n\n// Some useful resources:\n// https://lisyarus.github.io/blog/graphics/2022/07/30/point-light-attenuation.html <---The attenuation functions below were taken from there. I'll never look at lighting code the same again! Beautiful!\n// https://geom.io/bakery/wiki/index.php?title=Point_Light_Attenuation\n\n#ifdef ATTENUATE_NO_CUSP\n    float attenuate_no_cusp(float distance, float radius, float max_intensity, float falloff)\n    {\n        float s = distance / radius;\n\n        if (s >= 1.0)\n            return 0.0;\n\n        float s2 = sqr(s);\n\n        return max_intensity * sqr(1.0 - s2) / (1.0 + falloff * s2);\n    }\n#endif\n\n#ifdef ATTENUATE_CUSP\nfloat attenuate_cusp(float distance, float radius, float max_intensity, float falloff)\n{\n\tfloat s = distance / radius;\n\n\tif (s >= 1.0)\n\t\treturn 0.0;\n\n\tfloat s2 = sqr(s);\n\n\treturn max_intensity * sqr(1.0 - s2) / (1.0 + falloff * s);\n}\n#endif\n\nvec2 rotateUV(vec2 inputUV, float inputRotation)\n{\n    float rotation = radians(inputRotation);\n    \n    vec2 rotatedUV = vec2( (cos(rotation) * inputUV.x) + (sin(rotation) * inputUV.y),\n                           (cos(rotation) * inputUV.y) - (sin(rotation) * inputUV.x) );\n    return rotatedUV;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    validateSetupVars();\n    pMid = iResolution.xy * 0.5;\n    \n    vec3 error = vec3(1.0, 1.0, 1.0);\n    // ^^^Output will be multiplied by this in last step. Useful for debugging visually.\n\n    #ifdef ROTATE\n        aimDirection = (aimDirection + (iTimeDelta * rotationSpeed)); // Delta time in seconds * degrees per second. Looks right to me! Yolo!\n    #endif\n    \n    #ifdef SEEK\n        vec4 m = iMouse / iResolution.y;\n        vec2 mPos =( (iMouse.xy/iResolution.y) - vec2(((iResolution.x/iResolution.y))*0.5, 0.5)) * 2.0;\n        aimDirection = atan(mPos.y, mPos.x);\n        \n    #endif\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    // Normalized pixel coordinates(-1.0 <--0.0--> 1.0)0 middle, increase outwards? Q1++, Q2-+, Q3--, Q4+- ?\n    vec2 uv = ( (fragCoord/iResolution.y) - vec2(((iResolution.x/iResolution.y))*0.5, 0.5)) * 2.0;\n    //uv = vec2(uv.x*(450.0/800.0),uv.y);\n    \n    // Is uv and p Equivalent? ...\n    \n    \n    // input: pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    // angle of each pixel to the center of the screen\n    float a = atan(p.y,p.x);\n    \n    // By definition angle from center outwards toward pixel?\n    float auv = atan(uv.y,uv.x); \n    \n    vec2 aimVector = vec2(cos(aimDirection), sin(aimDirection));\n    \n    vec2 gaugeVector = rotateUV(aimVector, halfBeamAngle);\n    \n    vec2 auvVector = vec2(cos(auv), sin(auv));\n    \n    float dotGauge = dot(aimVector, gaugeVector);\n    \n    float pGauge = dot(aimVector, p);\n    \n    float auvGauge = dot(aimVector, auvVector);\n    \n    float pCol1 = pGauge >= dotGauge ? 1.0 : 0.0;\n    \n    float pCol2 = auvGauge >= dotGauge ? 1.0 : 0.0;\n    \n    float uvDist = distance(uvMid, uv);\n    \n    float pDist = distance(pMid, fragCoord.xy);\n    \n    /*\n    pCol1 = pCol1 * clamp(pDistanceMax/pDist, 0.0, 1.0);\n    pCol2 = pCol2 * clamp(pDistanceMax/pDist, 0.0, 1.0);\n    */\n    \n    /*pCol1 = pCol1 * clamp(1.0-uvDist, 0.0, uvDistanceMax);\n    pCol2 = pCol2 * clamp(1.0-uvDist, 0.0, uvDistanceMax);\n    */\n    \n    float attenuatedLight = 0.0;\n    \n    float clampedLight = 0.0;\n    \n    float pDistanceMax = iResolution.y*0.5; // Otherwise the lightcone will go out of bounds.\n    float uvDistanceMax = 1.0;\n    \n// LIGHT ATTENUATION BEGIN\n\n    #if defined ATTENUATE_ABC\n        attenuatedLight = lightAttenuationABC(uvDist);\n        pCol2 = pCol2 * attenuatedLight;\n        #if defined ATTENUATE_NO_CUSP\n            error = errorMagenta;\n        #elif defined ATTENUATE_CUSP\n            error = errorMagenta;\n        #endif\n    #endif\n    \n    \n    float radius = iResolution.y * 0.5;\n\n    float maxIntensity = 1.0;\n\n    float falloff = 1.0;\n    \n    #if defined ATTENUATE_NO_CUSP\n        attenuatedLight = attenuate_no_cusp(pDist, radius, maxIntensity, falloff);\n        pCol2 = pCol2 * attenuatedLight;\n        #if defined ATTENUATE_ABC\n            error = errorMagenta;\n        #elif defined ATTENUATE_CUSP\n            error = errorMagenta;\n        #endif\n    #endif\n    \n    #if defined ATTENUATE_CUSP\n        attenuatedLight = attenuate_cusp(pDist, radius, maxIntensity, falloff);\n        pCol2 = pCol2 * attenuatedLight;\n        #if defined ATTENUATE_ABC\n            error = errorMagenta;\n        #elif defined ATTENUATE_NO_CUSP\n            error = errorMagenta;\n        #endif\n    #endif\n    \n// LIGHT ATTENUATION END\n\n// LIGHT CLAMP BEGIN\n    #ifdef CLAMP\n        clampedLight = mix(attenuatedLight, pCol2, 1.0) * clamp(1.0-(uvDist*uvDist), 0.0, uvDistanceMax);\n        pCol2 = pCol2 * clampedLight;\n    #endif\n// LIGHT CLAMP END\n    \n    vec3 col = (vec3(pCol2)*lightColor)*error;\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}