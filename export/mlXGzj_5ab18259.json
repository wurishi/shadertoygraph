{"ver":"0.1","info":{"id":"mlXGzj","date":"1672027904","viewed":81,"name":"Cube Cam","username":"starmole2","description":"Little cubes camera filter\nPlay with parameters! ","likes":0,"published":1,"flags":2,"usePreview":0,"tags":["filter","cubes","cam"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nuvec3 pcg3d(uvec3 v) {\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n    v = v ^ (v >> 16u);\n    v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n    return v;\n}\n\nvec3 pcg3d(vec3 v) {\n    uvec3 uv = uvec3(abs(v + 10000.0));\n    uvec3 r = pcg3d(uv);\n    return vec3(r & uvec3(0xffff)) * 1.0/65535.0;\n}\n\nvec2 intersectUnitBox(vec3 rayOrigin, vec3 rayDir) {\n    vec3 tMin = (vec3(-1.0) - rayOrigin) / rayDir;\n    vec3 tMax = (vec3(1.0) - rayOrigin) / rayDir;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    return vec2(tNear, tFar);\n}\n\nvec3 normalUnitBox(vec3 p) {\n    vec3 ap = abs(p);\n    bvec3 sel = greaterThan(ap.xyz, max(ap.yxx, ap.zzy));\n    return mix(vec3(0.0),sign(p), sel);\n    //if ( ap.x > ap.y ) { if ( ap.x > ap.z ) return vec3(sign(p.x), 0.0, 0.0);\n    //} else { if ( ap.y > ap.z ) return vec3(0.0, sign(p.y), 0.0);}\n    //return vec3(0.0, 0.0, sign(p.z)); \n}\n\nmat3x3 rotX(float a) {\n    float s = sin(a); float c = cos(a);\n    return mat3x3(1.0,0.0,0.0,0.0,c,-s,0.0,s,c);\n}\n\nmat3x3 rotY(float a) {\n    float s = sin(a); float c = cos(a);\n    return mat3x3(c,0.0,s,0.0,1.0,0.0,-s,0.0,c);\n}\n\nmat3x3 rotZ(float a) {\n    float s = sin(a); float c = cos(a);\n    return mat3x3(c,-s,0.0,s,c,0.0,0.0,0.0,1.0);\n}\n\nvec3 traceCube(vec2 uv, vec3 rot, vec3 cd, vec3 bg) {\n    vec3 rayDir = vec3(0.0, 0.0, -1.0);\n    vec3 rayPos = vec3(uv*1.7, 2.0);\n    \n    mat3x3 r = rotX(rot.x) * rotY(rot.y) * rotZ(rot.z);\n    mat3x3 invr = inverse(r);\n    rayDir *= r;\n    rayPos *= r;\n\n    vec2 t = intersectUnitBox(rayPos, rayDir);\n    \n    vec3 col;\n    if ( t.x < t.y ) {\n        // hit\n        cd += vec3(.05,.05,.05);\n        vec3 hitp = rayPos + t.x * rayDir;\n        vec3 n = normalUnitBox(hitp) * invr;\n        const vec3 l0 = normalize(vec3(.1,.3,1.0));\n        const vec3 l1 = normalize(vec3(-.6,-.3,.2));\n        \n        vec3 l = vec3(1.0) * max(dot(l0,n), 0.0); \n        l += vec3(.2,.2,.7) * max(dot(l1,n), 0.0);\n        \n        col = cd * l;\n    } else {\n        col = bg * .5;\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    float aspect = iResolution.x / iResolution.y; \n    uv = uv * 2.0 - 1.0;\n    uv.x *= aspect;\n    \n    float gridsize = iResolution.x / 140.0;\n    \n    vec2 uvgrid = floor(gridsize * uv) / gridsize;\n    vec2 uvsub = ((uv - uvgrid) * gridsize) * 2.0 - 1.0;\n    \n    vec3 bg = textureLod(iChannel0, fragCoord / iResolution.xy, 9.0 ).xyz;\n    vec3 cd = textureLod(iChannel0, uvgrid * vec2(.5/aspect, .5) + .5, 4.0 ).xyz;\n    vec3 rot = cd * 3.0;\n    rot.z += iTime * .4;\n    //rot.y += iTime * .33;\n    //rot += vec3(uvgrid, 0.0);\n\n    vec3 col = traceCube(uvsub, rot, pow(cd, vec3(2.2)), pow(bg, vec3(2.2)));\n\n    // Output to screen\n    fragColor = vec4(pow(col,vec3(1.0/2.2)),1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}