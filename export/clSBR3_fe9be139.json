{"ver":"0.1","info":{"id":"clSBR3","date":"1694278513","viewed":142,"name":"Chewy Cubes","username":"krajzeg","description":"Tasty chewable metacubes.\n*glom* *unglom*","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","metaballs","cubemap"],"hasliked":0,"parentid":"ml2fzK","parentname":"Basic metacubes"},"renderpass":[{"inputs":[{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 rotate2d(vec2 v, float a) {\n    return vec2(cos(a) * v.x - sin(a) * v.y, sin(a) * v.x + cos(a) * v.y); \n}\n\nvec3 rotate3d(vec3 v, vec3 angles) {\n    v = vec3(v.x, rotate2d(v.yz, angles.x));\n    vec2 rxz = rotate2d(v.xz, angles.y);\n    v = vec3(rxz.x, v.y, rxz.y);\n    v = vec3(rotate2d(v.xy, angles.z), v.z);\n    return v;\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = max(k-abs(a-b), 0.0) / k;\n    return min(a, b) - h*h*k*(1.0/4.0);\n}\n\nfloat softcubeSdf(in vec3 center, in float radius, in vec3 rot, in float soft, in vec3 pos) {\n    vec3 disp = pos - center;\n    disp = rotate3d(disp, rot);\n    vec3 d = abs(disp) - vec3(radius - soft);\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - soft;\n}\n\n\nfloat shapeSdf(in vec3 center, in float radius, in vec3 rot, in vec3 pos) {\n    return softcubeSdf(center, radius, rot, 0.4, pos);\n}\n\nvec2 map(in vec3 pos) {\n    vec3 ctr1 = vec3(sin(iTime * 0.5) * 6.0, 0.0, 8.0 + cos(iTime * 0.3) * 2.9);\n    vec3 ctr2 = vec3(sin(iTime * 0.5 + 2.0) * 6.0, 0.0, 8.0 + cos(iTime * 0.2 + 0.1) * 2.9);\n    float s1 = shapeSdf(ctr1, 3.0, vec3(iTime*0.5), pos);\n    float s2 = shapeSdf(ctr2, 3.0, vec3(-iTime*0.25)+vec3(0.5,2,0), pos);\n    return vec2(smin(s1, s2, 3.0), s2 - s1);\n}\n\nvec3 mapNormal(in vec3 p) {\n    const float eps = 0.0001;\n    const vec2 h = vec2(eps,0);\n    return normalize(vec3(map(p+h.xyy).x - map(p-h.xyy).x,\n                          map(p+h.yxy).x - map(p-h.yxy).x,\n                          map(p+h.yyx).x - map(p-h.yyx).x));\n}\n\nvec3 rayColor(in vec3 origin, in vec3 dir, in float maxDist) {\n    dir = normalize(dir);\n    vec3 p = origin;\n    vec3 prev = p;\n    float s = map(p).x;\n    float dist = maxDist;\n    while (s > 0.0001 && dist > 0.0) {\n        float stepLen = max(s, 0.02);\n        dist -= stepLen;\n        prev = p;\n        p += dir * stepLen;\n        s = map(p).x;\n    }\n    if (s > 0.0001) return vec3(0);\n    vec3 norm = mapNormal(p);\n    \n    float mat = map(p).y;\n    float red = clamp(smoothstep(-5.0, 5.0, mat), 0.0, 1.0);\n    float blue = clamp(smoothstep(-5.0, 5.0, -mat), 0.0, 1.0);\n    vec3 ambient = normalize(vec3(red, 0.0, blue)) * 0.5;\n\n    vec3 reflectDir = 2.0 * dot(norm, -dir) * norm + dir;\n    vec3 reflection = texture(iChannel0, reflectDir).rgb * 0.5;\n\n    vec3 lightDir = normalize(vec3(1,-1,1));\n    vec3 diffuse = (max(dot(lightDir, -norm),0.2)-0.2) * vec3(0.5 + 0.5 * red, 0.7, 0.5 + 0.5 * blue);\n    return ambient + diffuse + reflection;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = (fragCoord/iResolution.y - vec2(0.5 * iResolution.x/iResolution.y, 0.5)) * 5.0;\n    vec3 cam = vec3(0,0,-4);\n    vec3 ray = vec3(xy,0.0) - cam;\n    \n    vec3 col = rayColor(cam, ray, 20.0);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}