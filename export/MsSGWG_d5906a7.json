{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"vec2 find_direction(float direction)\n{\n\tvec2 dir;\n\t\n\tif(direction > 1.0)\n\t{\n\t\tif(direction == 2.0)\n\t\t\tdir = vec2(1.0,0.0);\n\t\telse\n\t\t\tdir = vec2(0.0,-1.0);\n\t}\n\telse\n\t{\n\t\tif(direction == 0.0)\n\t\t\tdir = vec2(-1.0,0.0);\n\t\telse\n\t\t\tdir = vec2(0.0,1.0);\n\t}\n\t\n\treturn dir;\n}\n\nfloat get_index(vec4 v, float i)\n{\n\tfloat val;\n\tif(i > 1.0)\n\t{\n\t\tif(i == 2.0)\n\t\t\tval = v[2];\n\t\telse\n\t\t\tval = v[3];\n\t}\n\telse\n\t{\n\t\tif(i==0.0)\n\t\t\tval = v[0];\n\t\telse\n\t\t\tval = v[1];\n\t}\n\treturn val;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 find_outgoing(float t, vec2 ixy)\n{\n\tvec4 P = vec4(0.0,1.0,2.0,3.0);\n\tfloat random;\n\t\n\trandom = floor(4.0*rand(ixy + vec2(t,t)));\n\t//random number 0-3, then switch with last number\n\tif(random > 1.0)\n\t{\n\t\tif(random == 2.0)\n\t\t\tP.xyzw = P.xywz;\n\t\t//random == 3.0 already there\n\t}\n\telse\n\t{\n\t\tif(random == 0.0)\n\t\t\tP.xyzw = P.wyzx;\n\t\telse\n\t\t\tP.xyzw = P.xwzy;\n\t}\n\t\n\trandom = floor(3.0*rand(ixy + vec2(t+50.0,t+50.0)));\n\t//random number 0-2, then switch with second to last number\n\tif(random == 0.0)\n\t\tP.xyzw = P.zyxw;\n\telse if(random == 1.0)\n\t\tP.xyzw = P.xzyw;\n\t//random == 2.0 already there\n\t\t\n\trandom = floor(2.0*rand(ixy + vec2(t+100.0,t+100.0)));\n\t//random number 0-1, then switch with second number\n\tif(random == 0.0)\n\t\tP.xyzw = P.yxzw;\n\t//random == 1.0 already there\n\t\n\treturn P;\n}\n\nvec4 reverse(vec4 ig)\n{\n\t//based on an outgoing\n\tvec4 og;\n\t\n\tfor(int i = 0; i<4 ; i++)\n\t{\n\t\tif(ig[i] > 1.0)\n\t\t{\n\t\t\tif(ig[i] == 2.0)\n\t\t\t\tog[2] = float(i);\n\t\t\telse\n\t\t\t\tog[3] = float(i);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(ig[i] == 0.0)\n\t\t\t\tog[0] = float(i);\n\t\t\telse\n\t\t\t\tog[1] = float(i);\n\t\t}\n\t}\n\treturn og;\n}\n\nfloat draw_incoming_dot(float time, float itime, vec2 uv, vec2 iuv, vec4 exit_points, float d)\n{\n\t//work out positions of points\n\tvec2 P0, P1, P2, P3;\n\tvec2 point;\n\tvec2 total_offset;\n\t\n\tvec2 dir = find_direction(get_index(exit_points, d));\n\tP3.x = 0.5 + 0.5*dir.x + 0.17*dir.y;\n\tP3.y = 0.5 + 0.5*dir.y - 0.17*dir.x;\n\t\n\tdir = find_direction(d);\n\tP2.x = 0.5 + 0.5*dir.x + 0.17*dir.y;\n\tP2.y = 0.5 + 0.5*dir.y - 0.17*dir.x;\n\t\n\tP1.x = 0.5 + dir.x;\n\tP1.y = 0.5 + dir.y;\n\t\n\ttotal_offset = dir;\n\td = get_index(reverse(find_outgoing(itime, iuv+total_offset)), mod(d+2.0,4.0));\n\tdir = find_direction(d);\n\t\n\tP1.x += 0.5*dir.x + 0.17*dir.y;\n\tP1.y += 0.5*dir.y - 0.17*dir.x;\n\t\n\ttotal_offset+=dir;\n\tP0.x = 0.5 + total_offset.x;\n\tP0.y = 0.5 + total_offset.y;\n\t\n\td = get_index(reverse(find_outgoing(itime-1.0, iuv+total_offset)), mod(d+2.0,4.0));\n\tdir = find_direction(d);\n\tP0.x += 0.5*dir.x - 0.17*dir.y;\n\tP0.y += 0.5*dir.y + 0.17*dir.x;\n\t\n\tvec2 middle = P1;\n\tmiddle += 0.5*time*(P2-P0);\n\tmiddle += time*time*(P0 + 2.0*P2 - 2.5*P1 - 0.5*P3);\n\tmiddle += time*time*time*(1.5*P1 + 0.5*P3 - 0.5*P0 - 1.5*P2);\n\t\n\t//n = calc_circle(n, uv);\n\tpoint = vec2(0.0, 0.67);\n\tvec2 r = uv - iuv - middle;\n\t\n\treturn smoothstep(0.005, 0.0005, dot(r,r));\n}\n\nfloat draw_outgoing_dot(float time, float itime, vec2 uv, vec2 iuv, vec4 entry_points, float d)\n{\n\t//work out positions of points\n\tvec2 P0, P1, P2, P3;\n\tvec2 point;\n\tvec2 total_offset;\n\t\n\tvec2 dir = find_direction(get_index(entry_points, d));\n\tP0.x = 0.5 + 0.5*dir.x - 0.17*dir.y;\n\tP0.y = 0.5 + 0.5*dir.y + 0.17*dir.x;\n\t\n\tdir = find_direction(d);\n\tP1.x = 0.5 + 0.5*dir.x - 0.17*dir.y;\n\tP1.y = 0.5 + 0.5*dir.y + 0.17*dir.x;\n\t\n\tP2.x = 0.5 + dir.x;\n\tP2.y = 0.5 + dir.y;\n\t\n\ttotal_offset = dir;\n\td = get_index(find_outgoing(itime, iuv+total_offset), mod(d+2.0,4.0));\n\tdir = find_direction(d);\n\t\n\tP2.x += 0.5*dir.x - 0.17*dir.y;\n\tP2.y += 0.5*dir.y + 0.17*dir.x;\n\t\n\ttotal_offset+=dir;\n\tP3.x = 0.5 + total_offset.x;\n\tP3.y = 0.5 + total_offset.y;\n\t\n\td = get_index(find_outgoing(itime+1.0, iuv+total_offset), mod(d+2.0,4.0));\n\tdir = find_direction(d);\n\tP3.x += 0.5*dir.x + 0.17*dir.y;\n\tP3.y += 0.5*dir.y - 0.17*dir.x;\n\t\n\tvec2 middle = P1;\n\tmiddle += 0.5*time*(P2-P0);\n\tmiddle += time*time*(P0 + 2.0*P2 - 2.5*P1 - 0.5*P3);\n\tmiddle += time*time*time*(1.5*P1 + 0.5*P3 - 0.5*P0 - 1.5*P2);\n\t\n\t//n = calc_circle(n, uv);\n\tpoint = vec2(0.0, 0.67);\n\tvec2 r = uv - iuv - middle;\n\t\n\treturn smoothstep(0.005, 0.0005, dot(r,r));\n}\n\nfloat draw_middle_dot(float time, float itime, vec2 uv, vec2 iuv, vec4 exit_points, float d)\n{\n\t//work out positions of points\n\tvec2 P0, P1, P2, P3;\n\tvec2 point;\n\tvec2 dir = find_direction(d);\n\t\n\tP1.x = 0.5 + 0.5*dir.x + 0.17*dir.y;\n\tP1.y = 0.5 + 0.5*dir.y - 0.17*dir.x;\n\t\n\tP0.x = 0.5 + dir.x;\n\tP0.y = 0.5 + dir.y;\n\t\n\tdir = find_direction(get_index(reverse(find_outgoing(itime-1.0, iuv + dir)),mod(d+2.0,4.0)));\n\t// 0, 1, 2, 3\n\tP0.x += 0.5*dir.x - 0.17*dir.y;\n\tP0.y += 0.5*dir.y + 0.17*dir.x;\n\t\n\td = get_index(exit_points,d);\n\tdir = find_direction(d);\n\t\n\tP2.x = 0.5 + 0.5*dir.x - 0.17*dir.y;\n\tP2.y = 0.5 + 0.5*dir.y + 0.17*dir.x;\n\t\n\tP3.x = 0.5 + dir.x;\n\tP3.y = 0.5 + dir.y;\n\t\n\tdir = find_direction(get_index(find_outgoing(itime+1.0, iuv + dir),mod(d+2.0,4.0)));\n\t\n\tP3.x += 0.5*dir.x + 0.17*dir.y;\n\tP3.y += 0.5*dir.y - 0.17*dir.x;\n\t\n\tvec2 middle = P1;\n\tmiddle += 0.5*time*(P2-P0);\n\tmiddle += time*time*(P0 + 2.0*P2 - 2.5*P1 - 0.5*P3);\n\tmiddle += time*time*time*(1.5*P1 + 0.5*P3 - 0.5*P0 - 1.5*P2);\n\t\n\t//n = calc_circle(n, uv);\n\tpoint = vec2(0.0, 0.67);\n\tvec2 r = uv - iuv - middle;\n\t \n\treturn smoothstep(0.005, 0.0005, dot(r,r));\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tuv.x = uv.x*7.0*iResolution.x/iResolution.y;\n\tuv.y = uv.y*7.0;\n\t\n\tvec2 iuv = floor(uv);\n\t\n\tfloat gtime = iTime + 0.04*rand(iTime*uv); //rand part is motion blur\n\tfloat itime = floor(gtime); //time integer\n\tfloat time = gtime - itime; //time within 0.0-1.0 range\n\t\n\tfloat n = 0.0;\n\t\n\t//first work out dots entering\n\tvec4 rp; //reused points\n\trp = find_outgoing(itime, iuv);\n\tn += draw_middle_dot(time, itime, uv, iuv, rp, 0.0);\n\tn += draw_middle_dot(time, itime, uv, iuv, rp, 1.0);\n\tn += draw_middle_dot(time, itime, uv, iuv, rp, 2.0);\n\tn += draw_middle_dot(time, itime, uv, iuv, rp, 3.0);\n\t\n\tif(time<0.5)\n\t{\n\t\trp = reverse(find_outgoing(itime-1.0, iuv));\n\t\tn += draw_outgoing_dot(time, itime, uv, iuv, rp, 0.0);\n\t\tn += draw_outgoing_dot(time, itime, uv, iuv, rp, 1.0);\n\t\tn += draw_outgoing_dot(time, itime, uv, iuv, rp, 2.0);\n\t\tn += draw_outgoing_dot(time, itime, uv, iuv, rp, 3.0);\n\t}\n\telse\n\t{\n\t\trp = find_outgoing(itime+1.0, iuv);\n\t\tn += draw_incoming_dot(time, itime, uv, iuv, rp, 0.0);\n\t\tn += draw_incoming_dot(time, itime, uv, iuv, rp, 1.0);\n\t\tn += draw_incoming_dot(time, itime, uv, iuv, rp, 2.0);\n\t\tn += draw_incoming_dot(time, itime, uv, iuv, rp, 3.0);\n\t}\n\t\n\t\n\t//n += smoothstep(0.01, 0.0, uv.x - floor(uv.x));\n\t//n += smoothstep(0.01, 0.0, uv.y - floor(uv.y));\n\t\n\tn = 1.0 - n;\n\t\n\tfragColor = vec4(n, n, n, 1.0);\n\t \n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsSGWG","date":"1393007322","viewed":483,"name":"Dot randomizer","username":"chalky","description":"I was originally just going to work out a fixed number of dot paths, and implement it like truchet tiles, but catmull-rom curves make it so smooth. It could probably use some jazzing up though...","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["randomizer","catmull","rom"],"hasliked":0,"parentid":"","parentname":""}}