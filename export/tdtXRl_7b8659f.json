{"ver":"0.1","info":{"id":"tdtXRl","date":"1572667038","viewed":193,"name":"Outrun Style Ray Marching","username":"Jordan","description":"Modified from the tutorial on \"The Art of Code\" https://www.youtube.com/watch?v=PGtv-dBi2wE ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","raymarching","raymarch","80s","sphere","sky","outrun","neon","synthwave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MAX_STEPS 100\n#define MIN_DIST 0.01\n#define MAX_DIST 100.\n\n\nfloat GetDist(vec3 p)\n{\n    vec4 sphere = vec4(0.,pow(sin(iTime),2.)+1.,6.+pow(sin(iTime),2.)*0.5,1.);\n    float d_sphere = length(p-sphere.xyz) - sphere.w;\n    float d_plane = p.y;\n    float d = min(d_plane,d_sphere);\n    return d;\n}\n\n\n\nvec2 RayMarch(vec3 r_origin, vec3 r_direction)\n{\n    float d_origin = 0.;\n    float min_dist = 1000000.0;\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n        vec3 p = r_origin + d_origin*r_direction;\n        float d_surf = GetDist(p);\n        min_dist = min(d_surf, min_dist);\n        d_origin += d_surf;\n        if(d_surf<MIN_DIST || d_origin>MAX_DIST) break;\n    }\n    \n    return vec2(d_origin,min_dist);\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p);\n    vec2 e = vec2(.01,0);\n    \n    vec3 n = d - vec3( \n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n        \n    return normalize(n);\n}\n\nvec3 GetLight(vec3 p)\n{\n\n    vec3 rgb = vec3(0.,0.,0.);\n    vec3 lightPos = vec3(0,3,6);\n    \n    \n    lightPos.xz += vec2(5.*sin(iTime),5.*cos(iTime));\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n,l),0.,1.);\n    vec2 rm = RayMarch(p+n*MIN_DIST*1.1,l);\n    float mindist = rm.y;\n    float d = rm.x;\n    if(d<length(lightPos-p)) dif*=0.1;\n    vec3 lightCol = vec3(0,0,0);\n    if(d>=MAX_DIST)\n    \tlightCol = 0.05*(vec3(10./(mindist+0.09),1./(mindist+0.5),1./(mindist+0.09)));\n    \n    rgb = dif+lightCol;\n    \n    return rgb;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy) / iResolution.y;\n\n    vec3 r_origin = vec3(0,1,0);\n    vec3 r_direction = normalize(vec3(uv.x,uv.y,1));\n    vec2 rm = RayMarch(r_origin, r_direction);\n    float mindist = rm.y;\n    float dist = rm.x;\n    vec3 p = r_origin + r_direction*dist;\n    vec3 diffuse = GetLight(p);\n    vec3 col = diffuse;\n    \n    fragColor = vec4(col*mindist*2. +vec3(1.5*col.y/dist,0.3*col.z/dist,0.3*col.x/dist),1.0);\n}","name":"Image","description":"","type":"image"}]}