{"ver":"0.1","info":{"id":"MctfDX","date":"1733584489","viewed":79,"name":"Texture mapping glitch","username":"userfriend","description":"Circular lines appear on the table, especially when looking from top. Maybe someone knows why it happens","likes":0,"published":3,"flags":32,"usePreview":0,"tags":["glitch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Most important code in Buffer A\n\n// Fork of \"Balls path2\" by userfriend. https://shadertoy.com/view/McKcWz\n// 2024-12-07 14:57:24\n\n// Fork of \"Balls path\" by userfriend. https://shadertoy.com/view/4fcyz7\n// 2024-11-16 08:20:48\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.xy;\n    \n    \n    int asp = (iResolution.y / iResolution.x > RESOLUTION.y / RESOLUTION.x)\n        ? 1 : 0;\n    float m = RESOLUTION[asp] / iResolution[asp];\n        \n    vec2 p = (fragCoord * m + .5 * (RESOLUTION - iResolution.xy * m))\n        / iChannelResolution[0].xy;\n    vec3 col = texture(iChannel0, p).xyz;\n    \n    col = linearToSRGB(col);\n    \n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define TAU 6.283185\n#define PI 3.141592\n\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat atan2(in float y, in float x) {\n    bool s = (abs(x) > abs(y));\n    return mix(PI/2.0 - atan(x,y), atan(y,x), s);\n}\n\nfloat boxSd(vec3 p, vec3 s) {\n    p = abs(p) - s;\n\treturn length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat hash21(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash11(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat sceneHitId; // Id of a surface that's closest to ray, used in hitSurface function\n\nfloat sceneSd(vec3 p) {\n    float bd, d = 1000000.;\n    bd = boxSd(p, vec3(5, .5, 5));\n    if (bd < d) {\n        d = bd;\n        sceneHitId = 0.; // Table\n    }\n    \n    bd = length(p - vec3(0, 5, 0)) - .5;\n    if (bd < d) {\n        d = bd;\n        sceneHitId = 1.; // Emissive ball\n    }\n    \n    bd = length(p - vec3(2, 3, 3)) - .5;\n    if (bd < d) {\n        d = bd;\n        sceneHitId = 2.; // Reflective ball\n    }\n    \n    return d;\n}\n\nvec3 bgCol(vec3 ro, vec3 rd) {\n    return SRGBToLinear(texture(iChannel1, rd).xyz);\n}\n\nfloat mainHashSeed = 0.;\nfloat mainHash() {\n    return hash11(mainHashSeed++);\n}\n\nvec3 unitVec() {\n    vec3 x;\n    for (int i = 0; i < 3; i++) { // Rejection sampling\n        x = vec3(mainHash(), mainHash(), mainHash()) * 2. - 1.;\n        if (length(x) < 1.) break;\n    }\n    return normalize(x);\n}\n\nstruct Hit {\n    vec3 rd; // Output ray direction\n    vec3 em; // Surface emission\n    vec3 re; // Surface reflection color\n};\n\n// How ray should act (where to bounce, coloring) when a surface is hit\nHit hitSurface(vec3 p, vec3 rd, vec3 n) {\n    Hit h;\n    if (sceneHitId == 0.) { // Texture mapped table\n        h.em = vec3(0);\n        h.re = vec3(1);\n        \n        vec3 tex = texture(iChannel2, vec2(p.x, p.z) / 20.).rgb;\n        h.re = tex;\n        h.rd = reflect(rd, n);\n        \n    } else if (sceneHitId == 1.) { // Emissive ball\n        h.rd = reflect(rd, n);\n        h.em = vec3(1);\n        h.re = vec3(0);\n        \n    } else if (sceneHitId == 2.) { // Reflective ball\n        h.rd = reflect(rd, n);\n        h.em = vec3(0);\n        h.re = vec3(1);\n    }\n    return h;\n}\n\n// This function simulates a ray, marches, bounces, etc.\nvec3 pathSample(vec3 ro, vec3 rd) {\n    // p = ray position,\n    // em = emission,\n    // re = reflection.\n    vec3 p = ro, em = vec3(0), re = vec3(1);\n    \n    for (int i = 0; i < 200; i++) {\n        float d = sceneSd(p);\n        p += rd * d;\n        \n        if (d > 10000.) { // If ray isn't hitting anything\n            em += re * bgCol(p, rd);\n            break;\n        }\n        \n        if (abs(d) < .01) { // Ray hits a surface\n            vec2 e = vec2(.001, 0);\n            vec3 n = normalize( // Normal vector\n                sceneSd(p) - vec3(\n                    sceneSd(p - e.xyy),\n                    sceneSd(p - e.yxy),\n                    sceneSd(p - e.yyx)\n                )\n            );\n            \n            Hit h = hitSurface(p, rd, n);\n            \n            em += re * h.em;\n            re *= h.re;\n            rd = h.rd;\n            p += .02 * rd; // To avoid hitting the surface again\n            \n        }\n    }\n    \n    return em;\n}\n\nvec3 camTrans(vec3 x) { // For spheric camera motion\n    vec2 m = iMouse.xy / iResolution.xy - .5;\n    x.zy *= rot(m.y * 4.);\n    x.xz *= rot(-m.x * 7.);\n    \n    return x;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 prevCol = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    if (fragCoord.x > RESOLUTION.x || fragCoord.y > RESOLUTION.y)\n        return;\n    \n    vec2 uv = (fragCoord - RESOLUTION * .5) / RESOLUTION.y;\n    vec3 ro = vec3(0, 0, -9), rd = normalize(vec3(uv * 2., 1));\n    ro = camTrans(ro);\n    rd = camTrans(rd);\n    vec3 col = pathSample(ro, rd);\n    fragColor = vec4(col, 1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\nconst vec2 RESOLUTION = vec2(1011, 569);\n\nvec3 lt(vec3 f, float value) {\n    return vec3(\n        (f.x < value) ? 1. : 0.,\n        (f.y < value) ? 1. : 0.,\n        (f.z < value) ? 1. : 0.);\n}\n \nvec3 linearToSRGB(vec3 rgb) {\n    rgb = clamp(rgb, 0., 1.);\n \n    return mix(\n        pow(rgb, vec3(1. / 2.4)) * 1.055 - 0.055,\n        rgb * 12.92,\n        lt(rgb, 0.0031308)\n    );\n}\n \nvec3 SRGBToLinear(vec3 rgb) {\n    rgb = clamp(rgb, 0., 1.);\n \n    return mix(\n        pow(((rgb + 0.055) / 1.055), vec3(2.4)),\n        rgb / 12.92,\n        lt(rgb, 0.04045)\n    );\n}","name":"Common","description":"","type":"common"}]}