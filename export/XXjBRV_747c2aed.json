{"ver":"0.1","info":{"id":"XXjBRV","date":"1731920089","viewed":74,"name":"BozeMan Begins","username":"kaiware007","description":"SESSIONS2024","likes":4,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","boze"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ------------------------------------------------------------------------------------\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// Reference \"[SH18] The Olympian\" created by Klems : https://www.shadertoy.com/view/XltyRf\n// ------------------------------------------------------------------------------------\n//#define SIMPLE_HUMAN\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define MAX_MARCH 100\n#define MAX_DIST 100.\n\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n\n#define M_PI03 1.04719\n#define M_PI06 2.09439\n\n#define AA 1\n\nconst float EPS = 0.001;\nconst float EPS_N = 1e-4;\nconst float OFFSET = EPS * 10.0;\n\nstruct surface {\n\tfloat dist;\n    vec3 albedo;\n    vec3 emission;\n    float roughness;\n    float metalness;\n    int count;\n    bool isTransparent;\n    float refractPower;\n    bool isHit;\n};\n\n// Surface Data Define\n#define SURF_NOHIT(d)   (surface(d, vec3(0,1,1), \t\t vec3(0), 0.0, 0.0, 0, false, 0.0, false))\n#define SURF_BLACK(d) \t(surface(d, vec3(0.),        vec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_FACE(d) \t(surface(d, vec3(1,0.7,0.6), vec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_MOUSE(d) \t(surface(d, vec3(1,0,0.1),   vec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_CHEEP(d) \t(surface(d, vec3(1,0.3,0.4), vec3(0), 0.3, 0.0, 0, false, 0.0, true))\nsurface SURF_BG1(float d, vec3 pos)\n{\n    vec3 index = floor(pos * 2. + 0.5);\n    vec3 col = vec3(0.0) + vec3(0.75) * mod(mod(index.x + index.y, 2.0) + index.z + index.y, 2.0);\n    //vec3 col = max(vec3(0),pos) * mod(mod(index.x + index.y, 2.0) + index.z + index.y, 2.0);\n    return surface(d, col, vec3(0), 0.5, 0.3, 0, false, 0., true);\n}\n#define SURF_BODY(d) \t(surface(d, vec3(0.1), vec3(0), 0.5, 0.0, 0, false, 0.0, true))\n#define SURF_DIMPLE(d, t)  (surface(d, vec3(0.025), vec3(2,0.05,0.01) * t, 0.9, 0.0, 0, false, 0.0, true))\n#define SURF_WALL(d) \t(surface(d, vec3(0.5), vec3(0), 0.8, 0.0, 0, false, 0.0, true))\n\n// Hash without Sine by Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11( in float p ) {\n\tvec3 p3 = fract(vec3(p) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//  1 out, 2 in...\nfloat hash12( in vec2 p ) {\n\tvec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n// 1D perlin, between -1 and 1\nfloat perlin( in float x, in float seed ) {\n    x += hash11(seed);\n    float a = floor(x);\n    float b = a + 1.0;\n    float f = fract(x);\n    a = hash12(vec2(seed, a));\n    b = hash12(vec2(seed, b));\n    f = f*f*(3.0-2.0*f);\n    return mix(a, b, f)*2.0-1.0;\n}\n\n// Distance functions by iq\n// https://iquilezles.org/articles/distfunctions\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - mix(r1, r2, h);\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Distance Function 2D\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nsurface opU(surface d1, surface d2)\n{\n\t//return (d1.dist < d2.dist) ? d1 : d2;\n    if(d1.dist < d2.dist){\n        return d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opS( surface d1, surface d2 )\n{ \n    //return (-d1.dist > d2.dist) ? vec2(-d1.x, d1.y): d2;\n    //return (-d1.dist > d2.dist) ? surface(-d1.dist, d1.albedo, d1.emission, d1.roughness, d1.metalness) : d2;\n    if(-d1.dist > d2.dist){\n        d1.dist = -d1.dist;\n    \treturn d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opSU( surface d1, surface d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.dist - d1.dist)/k, 0.0, 1.0 );\n    float d = mix( d2.dist, d1.dist, h ) - k*h*(1.0-h);\n    vec3 albedo = mix( d2.albedo, d1.albedo, h );\n    vec3 emission = mix( d2.emission, d1.emission, h );\n    float roughness = mix( d2.roughness, d1.roughness, h );\n    float metalness = mix( d2.metalness, d1.metalness, h );\n    float refractPower = mix( d2.refractPower, d1.refractPower, h );\n    return surface(d, albedo, emission, roughness, metalness, d1.count, h > 0.5 ? d1.isTransparent : d2.isTransparent, refractPower, true);\n}\n\nsurface opI( surface d1, surface d2 )\n{ \n    //return (d1.dist > d2.dist) ? d1 : d2;]\n    if(d1.dist > d2.dist) {\n        return d1;\n    }else{\n        return d2;\n    }\n}\n\nsurface opPaint(surface d1, surface d2)\n{\n    //return (d1.dist < d2.dist) ? d1 : surface(d1.dist, d2.albedo, d2.emission, d2.roughness, d2.metalness);\n    if(d1.dist < d2.dist) {\n        return d1;\n    } else {\n        d2.dist = d1.dist;\n        return d2;\n    }\n}\n             \n// Union, Subtraction, SmoothUnion (distance only)\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\nvec2 foldRotate(in vec2 p, in float s) {\n    float a = M_PI / s - atan(p.x, p.y);\n    float n = M_PI2 / s;\n    a = floor(a / n) * n;\n    p *= rot(a);\n    return p;\n}\n\n\nvec3 opTwist(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x, q.y, q.z);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opRep2D( in vec2 p, in vec2 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nfloat smin( in float a, in float b, in float s ) {\n    float h = clamp( 0.5 + 0.5*(b-a)/s, 0.0, 1.0 );\n    return mix(b, a, h) - h*(1.0-h)*s;\n}\n\n// 線分と無限平面の衝突位置算出\n// rayPos : レイの開始地点\n// rayDir : レイの向き\n// planePos : 平面の座標\n// planeNormal : 平面の法線\nfloat GetIntersectLength(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal)\n{\n    return dot(planePos - rayPos, planeNormal) / dot(rayDir, planeNormal);\n}\n\n// 直方体とレイの衝突位置算出\nvec2 GetIntersectBox(vec3 rayPos, vec3 rayDir, vec3 boxPos, vec3 boxSize)\n{\n    vec3 diff = rayPos - boxPos;\n\tvec3 m = 1.0 / rayDir;\n    vec3 n = m * diff;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    \n    return vec2(tN, tF);\n/*    \n    if(tN > tF || tF < 0.0)\n        return vec2(-1.0);\t// no intersection\n    \n    return vec2(tN, tF);\n*/\n}\n\n// IK\nvec3 solve( vec3 p, float l1, float l2, vec3 dir )\n{\n\tvec3 q = p*( 0.5 + 0.5*(l1*l1-l2*l2)/dot(p,p) );\n\t\n\tfloat s = l1*l1 - dot(q,q);\n\ts = max( s, 0.0 );\n\tq += sqrt(s)*normalize(cross(p,dir));\n\t\n\treturn q;\n\n}\n\nvec3 solve( vec3 a, vec3 b, float l1, float l2, vec3 dir )\n{\n\treturn a + solve( b-a, l1, l2, dir );\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// easing function\n/////////////////////////////////////////////////////////////////////////////////////////////////\nfloat ease_cubic_out(float p)\n{\n\tfloat f = (p - 1.0);\n\treturn f * f * f + 1.0;\n}\n\nfloat easeInCirc(float x)\n{\n\treturn 1. - sqrt(1. - pow(x, 2.));\n}\n\nfloat easeOutCirc(float x) \n{\n\treturn sqrt(1. - pow(x - 1., 2.));\n}\n\nfloat easeInExpo(float x)\n{\n\treturn x == 0. ? 0. : pow(2., 10. * x - 10.);\n}\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\n#define RAD90 (M_PI * 0.5)\n\nfloat sdEar(vec3 p)\n{\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0), vec2(sin(0.7),cos(0.7)), 0.03, 0.01);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nvec3 opBendXZ(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec2 xz = m*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\n\nvec3 opBendYZ(vec3 p, float k)\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec2 yz = m*p.yz;\n    return vec3(p.x, yz.xy);\n}\n\n\nfloat sdMouse(vec3 p, float ms)\n{\n    vec3 q = opBendXY(p, 2.0);\n    ms += 0.00001;\n    //return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015 + sin(iTime * 1.) * 0.05,0.05) * sc);\n    return sdEllipsoid(q - vec3(0,0,0.2), vec3(0.035, 0.01 * ms,0.2 * ms));\n}\n\nfloat sdCheep(vec3 p)\n{    \n    const float x = 0.05;\n    const float z = -0.175;\n    const float r = 0.0045;\n    const float rb1 = 100.;\n    \n    p = rotate(p, M_PI * -0.6 * (p.x - x), vec3(-0.2,0.8,0));\n\t\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z), rb1), vec3(-0.005,0.0,0.0), vec3(0.005, 0., 0.001), r);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z), 200.0), vec3(-0.0026,0.0,0), vec3(0.0026, 0., 0), r);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z), -rb1), vec3(-0.01,0.0,-0.01), vec3(0.0045, 0., 0.0), r);\n    \n    return opUnion(opUnion(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p)\n{\n    const float x = 0.05;\n    p = opBendXZ(p + vec3(0.02,0,-0.02), -6.5);\n    return sdRoundBox(p + vec3(0.005, -0.14,-0.11), vec3(0.003,0.0025,0.05), 0.001);\n}\n\nsurface sdBoze(vec3 p, vec3 sc, float ms)\n{    \n    surface result = SURF_NOHIT(0.);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = opSmoothUnion(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opUnion(d, d2);\n\n\tsurface head = SURF_FACE(d);\n\n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    surface mouse = SURF_MOUSE(d6);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n    surface cheep = SURF_CHEEP(d7);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    eye.dist = opUnion(eye.dist, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\n\n\n\n// skeleton, represented as pitch/yaw/roll rotations\nvec3 skel[16];\n\n// rotate a limb\nvec3 rotateLimb( in vec3 p, in int i ) {\n    vec3 pitchYawRoll = skel[i];\n    p.xz *= rot(pitchYawRoll.y);\n    p.yz *= rot(pitchYawRoll.x);\n    p.xz *= rot(pitchYawRoll.z);\n    return p;\n}\n\n// rotate an arm\nvec3 rotateArm(vec3 p, int i ) {\n    vec3 pitchYawRoll = skel[i];\n    p.xz *= rot(pitchYawRoll.y);\n    p.xy *= rot(pitchYawRoll.x);\n    p.yz *= rot(pitchYawRoll.z);\n    return p;\n}\n\n// 0  = upper body\n// 1  = lower body\n// 2  = neck\n// 3  = head\n// 4  = right shoulder\n// 5  = right elbow\n// 6  = right hand\n// 7  = left shoulder\n// 8  = left elbow\n// 9  = left hand\n// 10 = right hip\n// 11 = right knee\n// 12 = right foot\n// 13 = left hip\n// 14 = left knee\n// 15 = left foot\n\n// initialize skeleton\nvoid initSkel( in int seqID, in float seqTime, in float time, out float bodyOffsetY ) {\n    \n    for (int i = 0 ; i < skel.length() ; i++) {\n        skel[i] = vec3(0);\n    }\n    bodyOffsetY = 0.;\n    \n    if (seqID < 2) {\n        float f1 = 1.;\n        skel[0] = mix(skel[0], vec3(1.6, 0, 0), f1);    // upper body\n        skel[1] = mix(skel[1], vec3(-1.0, 0, 0), f1);   // lower body\n        skel[2] = mix(skel[2], vec3(0.15, 0, 0), f1);    // neck\n        skel[3] = mix(skel[3], vec3(0.4, 0, 0), f1);    // head\n        \n        skel[4] = mix(skel[4], vec3(0.1, 1.2, 0.5), f1); // right shoulder\n        skel[5] = mix(skel[5], vec3(0.4, 0.125, 0.5), f1);   // right elbow\n        skel[6] = mix(skel[6], vec3(-0.05, 0.1, 0.5), f1);   // right hand\n        \n        skel[7] = mix(skel[7], vec3(0.1, 1.2, 0.5), f1); // left shoulder\n        skel[8] = mix(skel[8], vec3(0.4, 0.125, 0.5), f1);   // left elbow\n        skel[9] = mix(skel[9], vec3(-0.05, 0.1, 0.5), f1);   // left hand\n\n        skel[10] = mix(skel[10], vec3(-1.3, -0.15, 0), f1);// right hip\n        skel[11] = mix(skel[11], vec3(2.5, 0, 0), f1); // right knee\n        skel[12] = mix(skel[12], vec3(-0.1, 0, 0), f1); // right foot\n        \n        skel[13] = mix(skel[13], vec3(-2.2, -0.12, 0), f1);// left hip\n        skel[14] = mix(skel[14], vec3(2.45, 0, 0), f1); // left knee\n        skel[15] = mix(skel[15], vec3(-0.5, 0, 0), f1); // left foot\n        \n        \n    } else {\n        float f1 = smoothstep(0.0, 0.5, seqTime);\n        bodyOffsetY = mix(0., -0.5, f1);\n        skel[0] = mix(vec3(1.6, 0, 0), vec3(1.1, 0, 0), f1);    // upper body\n        skel[1] = mix(vec3(-1.0, 0, 0), vec3(-0.5, 0, 0), f1);   // lower body\n        skel[2] = mix(vec3(0.15, 0, 0), vec3(-0.5, 0, 0), f1);    // neck\n        skel[3] = mix(vec3(0.4, 0, 0), vec3(-0.5, 0, 0), f1);    // head\n        \n        skel[4] = mix(vec3(0.1, 1.2, 0.5), vec3(-0.5, 1.2, 0.5), f1); // right shoulder\n        skel[5] = mix(vec3(0.4, 0.125, 0.5), vec3(0.4, 0.125, 0.5), f1);   // right elbow\n        skel[6] = mix(vec3(-0.05, 0.1, 0.5), vec3(-0.05, 0.1, 0.5), f1);   // right hand\n        \n        skel[7] = mix(vec3(0.1, 1.2, 0.5), vec3(-0.5, 1.2, 0.5), f1); // left shoulder\n        skel[8] = mix(vec3(0.4, 0.125, 0.5), vec3(0.4, 0.125, 0.5), f1);   // left elbow\n        skel[9] = mix(vec3(-0.05, 0.1, 0.5), vec3(-0.05, 0.1, 0.5), f1);   // left hand\n\n        skel[10] = mix(vec3(-1.3, -0.15, 0), vec3(-1.3, -0.15, 0), f1);// right hip\n        skel[11] = mix(vec3(2.5, 0, 0), vec3(2.5, 0, 0), f1); // right knee\n        skel[12] = mix(vec3(-0.1, 0, 0), vec3(-0.1, 0, 0), f1); // right foot\n        \n        skel[13] = mix(vec3(-2.2, -0.12, 0), vec3(-2.2, -0.12, 0), f1);// left hip\n        skel[14] = mix(vec3(2.45, 0, 0), vec3(2.45, 0, 0), f1); // left knee\n        skel[15] = mix(vec3(-0.5, 0, 0), vec3(-0.5, 0, 0), f1); // left foot   \n    }\n}\n\nfloat getTorso( in vec3 p ) {\n    \n    vec3 offset = vec3(0., 0.1, 0);\n    p = rotate(p + offset, skel[0].x * 0.5, vec3(1,0,0));\n    p = opBendYZ(p + offset, skel[0].x * 0.5);\n    p -= offset;\n\n    #ifdef SIMPLE_HUMAN    \n    return sdBox(p - vec3(0, 0.25, 0.0), vec3(0.4, 0.25, 0.1))-0.15;\n    #endif\n    \n    vec3 mainDim = vec3(0.375, 0.2, 0.05);\n    mainDim.x -= cos(p.y*2.0+0.9)*0.19;\n    mainDim.y -= cos(p.x*7.0)*0.05;\n    vec3 inTorso = p - vec3(0, 0.15, 0.05);\n    inTorso.z += smoothstep(-0.2, 0.5, inTorso.y)*0.2;\n    float torso = sdBox(inTorso, mainDim) - 0.15;\n    \n    vec3 trapDim = vec3(0.2, 0.13, 0);\n    vec3 inTrap = inTorso - vec3(0.2, 0.33, -0.07);\n    inTrap.xy *= rot(0.4);\n    inTrap.yz *= rot(-0.2);\n    float trap = sdBox(inTrap, trapDim)-0.13;\n    \n    vec3 pecDim = vec3(0.15, 0.08, 0.0);\n    pecDim.y += sin(inTorso.x*7.5)*0.05;\n    vec3 inPec = inTorso - vec3(0.21, 0.2, 0.12);\n    float pec = sdBox(inPec, pecDim) - 0.1;\n    float pecMore = length(inPec)-0.15;\n    pec = smin(pec, pecMore, 0.25);\n    \n    float spine = smoothstep(0.13, 0.0, p.x)*smoothstep(0.1, -0.3, p.z);\n    \n    float d = torso;\n    d = smin(d, trap, 0.1);\n    d = smin(d, pec, 0.05);\n    d += spine*0.02;\n    return d;\n}\n\nfloat getPelvis( in vec3 p ) {\n    \n\n    vec3 offset = vec3(0, 0.15, 0.1);\n    float bend = -skel[1].x * 0.5;\n    p = rotate(p + offset, -bend * 0.25, vec3(1,0,0));\n    p = opBendYZ(p + offset, bend);\n    p -= offset;\n\n    #ifdef SIMPLE_HUMAN\n    return sdBox(p - vec3(0, -0.45, 0.08), vec3(0.13, 0.3, 0))-0.2;\n    #endif\n    \n    vec3 mainDim = vec3(0.17, 0.3, 0);\n    mainDim.x += sin(p.y*6.0)*0.04;\n    vec3 inMain = p - vec3(0, -0.45, 0.07);\n    inMain.z -= cos(inMain.y*6.0)*0.02;\n    \n    float main = sdBox(inMain, mainDim) - 0.2;\n    \n    vec3 absDim = vec3(0.13, 0.29, 0.0);\n    absDim.z -= cos(p.x*30.0)*0.007;\n    absDim.z -= cos(p.y*36.0)*0.007;\n    vec3 inAbs = inMain - vec3(0, 0.1, 0.13);\n    float absD = sdBox(inAbs, absDim)-0.1;\n    \n    vec3 penisDim = vec3(0.03, 0.05, 0.05);\n    penisDim.x -= sin(p.y*10.0)*0.03;\n    vec3 inPenis = p - vec3(0, -0.9, 0.13);\n    inPenis.z += inPenis.y*0.2;\n    float penis = sdBox(inPenis, penisDim)-0.12;\n    \n    float butt = sdEllipsoid(p - vec3(0.17, -0.75, -0.03),\n                             vec3(0.2, 0.28, 0.2));\n    \n    float spine = smoothstep(0.1, 0.0, p.x)*smoothstep(0.1, -0.1, p.z);\n    \n    float d = main;\n    d = smin(d, absD, 0.1);\n    d = smin(d, penis, 0.1);\n    d = smin(d, butt, 0.1);\n    d += spine*0.02;\n    return d;\n}\n\nfloat getNeck( in vec3 p ) {\n    return sdCapsule(p, vec3(0,-0.1,0), vec3(0, 0.24, 0.07), 0.2, 0.15);\n}\n\nfloat getHead( in vec3 p ) {\n    \n    #ifdef SIMPLE_HUMAN\n    return sdBox(p - vec3(0, 0.18, 0.05), vec3(0.1, 0.19, 0.14))-0.1;\n    #endif\n    \n    vec3 brainDim = vec3(0.2, 0.23, 0.22);\n    vec3 inBrain = p - vec3(0, 0.27, 0.0);\n    float brain = sdEllipsoid(inBrain, brainDim);\n    \n    vec3 faceDim = vec3(0.04, 0.19, 0.03);\n    faceDim.x += sin(p.y*5.0)*0.05;\n    faceDim.z += cos(p.x*15.0)*0.02;\n    faceDim.z += sin(p.y*6.0)*0.03;\n    vec3 inFace = p - vec3(0, 0.18, 0.11);\n    float face = sdBox(inFace, faceDim) - 0.1;\n    \n    float d = brain;\n    d = smin(d, face, 0.1);\n    return d;\n}\n\nfloat getUpperArm( in vec3 p ) {\n    \n    #ifdef SIMPLE_HUMAN\n    return sdCapsule(p, vec3(0), vec3(0.89, 0, 0), 0.1);\n    #endif\n    \n    vec3 shoulderDim = vec3(0.3, 0.2, 0.22);\n    float shoulder = sdEllipsoid(p - vec3(0.05, 0.05, 0.0), shoulderDim);\n    \n    float muscle1Rad = 0.12;\n    muscle1Rad -= cos(p.x*8.0)*0.02;\n    vec3 muscle1Pos1 = vec3(0.0, 0.05, 0.03);\n    vec3 muscle1Pos2 = vec3(0.74, 0.05, 0.03);\n    float muscle1 = sdCapsule(p, muscle1Pos1, muscle1Pos2, muscle1Rad);\n    \n    float muscle2Rad = 0.125;\n    muscle2Rad += sin(p.x*7.0)*0.02;\n    vec3 muscle2Pos1 = vec3(0.0, -0.04, -0.03);\n    vec3 muscle2Pos2 = vec3(0.78, -0.02, -0.03);\n    float muscle2 = sdCapsule(p, muscle2Pos1, muscle2Pos2, muscle2Rad);\n    \n    float d = shoulder;\n    d = smin(d, muscle1, 0.015);\n    d = smin(d, muscle2, 0.02);\n    return d;\n}\n\nfloat getForearm( in vec3 p ) {\n    const vec3 handPos = vec3(0.58, 0, 0);\n    \n    #ifdef SIMPLE_HUMAN\n    return sdCapsule(p, vec3(0), handPos, 0.1);\n    #endif\n    \n    float rad = 0.1 + sin(p.x*9.0)*0.03;\n    float muscle1 = sdCapsule(p, vec3(0.06, 0.06, 0.0),\n                              handPos+vec3(0, 0.05, 0), rad);\n    float muscle2 = sdCapsule(p, vec3(0.04, -0.02, 0.03),\n                              handPos+vec3(0, -0.01, 0), rad);\n    \n    float elbow = length(p)-0.08;\n    \n    float d = muscle1;\n    d = smin(d, muscle2, 0.015);\n    d = smin(d, elbow, 0.03);\n    return d;\n}\n\nfloat getHand( in vec3 p ) {\n    \n    #ifdef SIMPLE_HUMAN\n    return sdBox(p - vec3(0.25, 0.02, 0.0), vec3(0.14, 0.07, 0.0)) - 0.05;\n    #endif\n    \n    vec3 handDim = vec3(0.05, 0.08 + p.x * 0.01, 0.01);\n    vec3 gooDim  = vec3(0.01, 0.08 + p.x * 0.01, 0.025);\n    float cu1 = cos(p.y*11.0-0.3);\n\thandDim.x += cu1*0.025;\n    gooDim.x  += cu1*0.01;\n    \n    float hand = sdBox(p - vec3(0.15, 0.02, 0), handDim) - 0.05;\n    float goo  = sdBox(p - vec3(0.2,  0.02, 0.05), gooDim) - 0.05;\n    \n    float thumb = sdCapsule(p, vec3(0.1, 0.02, 0.03),\n                            vec3(0.15, 0.02, 0.08), 0.06);\n    \n    float d = hand;\n    d = smin(d, thumb, 0.07);\n    d = smin(d, goo, 0.03);\n    return d;\n}\n\nfloat getUpperLeg( in vec3 p ) {\n    const vec3 kneePos = vec3(0, -1.01, 0);\n    \n    #ifdef SIMPLE_HUMAN\n    return sdCapsule(p, vec3(0), kneePos, 0.15);\n    #endif\n    \n    float muscle1Rad = 0.16 - sin(p.y*4.0)*0.05;\n    float muscle1 = sdCapsule(p, vec3(0.03, 0.0, 0.1), kneePos, muscle1Rad);\n    float muscle2 = sdCapsule(p, vec3(-0.12, 0.0, -0.05), kneePos, muscle1Rad);\n    \n    float knee = sdEllipsoid(p - vec3(0, -0.95, 0.03), vec3(0.12, 0.2, 0.12));\n    \n    float d = muscle1;\n    d = smin(d, muscle2, 0.02);\n    d = smin(d, knee, 0.03);\n    \n    return d;\n}\n\nfloat getLowerLeg( in vec3 p ) {\n    const vec3 footPos = vec3(0, -1.06, -0.08);\n    \n    #ifdef SIMPLE_HUMAN\n    return sdCapsule(p, vec3(0), footPos, 0.15);\n    #endif\n    \n    float muscle1Rad = 0.13 - sin(p.y*4.0)*0.06;\n    float muscle1 = sdCapsule(p, vec3(0.02, 0.0, 0.0), footPos, muscle1Rad);\n    \n    float muscle2Rad = 0.09 - sin(p.y*5.3)*0.05;\n    float muscle2 = sdCapsule(p, vec3(-0.02, 0.04, -0.08),\n                              footPos + vec3(0.0, 0.04, -0.02), muscle2Rad);\n    \n    float d = muscle1;\n    d = smin(d, muscle2, 0.02);\n    return d;    \n}\n\nfloat getFoot( in vec3 p ) {\n    \n    #ifdef SIMPLE_HUMAN\n    return sdBox(p - vec3(0.0, -0.13, 0.15), vec3(0.08, 0.0, 0.25))-0.05;\n    #endif\n    \n    vec3 footDim = vec3(0.04, 0.0, 0.19);\n    footDim.x -= cos(p.z*13.0-0.4)*0.04;\n    footDim.z += cos(p.x*14.0+0.2)*0.05;\n    vec3 inFoot = p - vec3(0.03, -0.13, 0.19);\n    float foot = sdBox(inFoot, footDim)-0.05;\n    \n    float ankle = sdEllipsoid(inFoot - vec3(0.0, 0.07, -0.13),\n                              vec3(0.1, 0.08, 0.18));\n    \n    float d = foot;\n    d = smin(d, ankle, 0.1);\n    return d;\n}\n\n\n// main distance function\nsurface de( in vec3 p ) {\n    \n    p.y += 0.5;\n    \n    // main pivot point is upper body\n    vec3 inUpperBody = p;\n    inUpperBody = rotateLimb(inUpperBody, 0);\n    \n    inUpperBody -= vec3(0, 1.3, 0);\n    vec3 inLowerBody = inUpperBody;\n    inLowerBody = rotateLimb(inLowerBody, 1);\n    \n    // keep upper body unflipped for the head\n    vec3 inUpperBodyNoFlip = inUpperBody;\n    // do some flipping\n    int upperOffset = int(inUpperBody.x > 0.0)*3;\n    int lowerOffset = int(inLowerBody.x > 0.0)*3;\n    inUpperBody = vec3(abs(inUpperBody.x), inUpperBody.yz);\n    inLowerBody = vec3(abs(inLowerBody.x), inLowerBody.yz);\n    \n    // do the torso\n    float torso = getTorso(inUpperBody);\n    \n    // do the pelvis\n    float pelvis = getPelvis(inLowerBody);\n    \n    // do the neck and head\n    vec3 inNeck = inUpperBodyNoFlip - vec3(0, 0.68, -0.1);\n    inNeck = rotateLimb(inNeck, 2);\n    float neck = getNeck(inNeck);\n    vec3 inHead = inNeck - vec3(0, 0.29, 0.07);\n    inHead = rotateLimb(inHead, 3);\n    //float head = getHead(inHead);\n    surface head = sdBoze(inHead, vec3(1.8), 1.);\n    \n    // do the arms\n    vec3 inShoulder = inUpperBody - vec3(0.45, 0.48, -0.12);\n    inShoulder = rotateArm(inShoulder, 4+upperOffset);\n    float shoulder = getUpperArm(inShoulder);\n    vec3 inElbow = inShoulder - vec3(0.79, 0, 0);\n    inElbow = rotateArm(inElbow, 5+upperOffset);\n    float elbow = getForearm(inElbow);\n    vec3 inHand = inElbow - vec3(0.56, 0, 0);\n    inHand = rotateArm(inHand, 6+upperOffset);\n    float hand = getHand(inHand);\n    \n    // do the legs\n    vec3 inHip = inLowerBody - vec3(0.25, -0.79, 0);\n    inHip = rotateLimb(inHip, 10+lowerOffset);\n    float hip = getUpperLeg(inHip);\n    vec3 inKnee = inHip - vec3(0, -1.01, 0);\n    inKnee = rotateLimb(inKnee, 11+lowerOffset);\n    float knee = getLowerLeg(inKnee);\n    vec3 inFoot = inKnee - vec3(0, -1.06, -0.08);\n    inFoot = rotateLimb(inFoot, 12+lowerOffset);\n    float foot = getFoot(inFoot);\n    \n    // blend the body together\n    float d = torso;\n    d = smin(d, pelvis, 0.2);\n    d = smin(d, neck, 0.15);\n    //d = smin(d, head, 0.04);\n    // blend the arms together\n    float arms = shoulder;\n    arms = smin(arms, elbow, 0.05);\n    arms = smin(arms, hand, 0.05);\n    // blend the legs together\n    float legs = hip;\n    legs = smin(legs, knee, 0.05);\n    legs = smin(legs, foot, 0.1);\n    // blend everything and return the value\n    d = smin(d, arms, 0.1);\n    d = smin(d, legs, 0.05);\n    \n    surface result = SURF_BODY(d);\n    result = opSU(result, head, 0.04);\n    return result;\n}\n\n#define SEQ_1_TIME 5.0\n#define SEQ_2_TIME (SEQ_1_TIME + 5.0)\n#define SEQ_3_TIME (SEQ_2_TIME + 1.0)\n\n// return sequence id and time in this sequence\nvoid getSequence( in float time, out int seqID, out float seqTime ) {\n    \n    seqID = 2;\n    seqTime = time;\n    \n    //return;\n    \n    if (time < SEQ_1_TIME) {\n        seqID = 0;\n        seqTime = time / SEQ_1_TIME;\n    } else if (time < SEQ_2_TIME) {\n        seqID = 1;\n        seqTime = (time - SEQ_1_TIME) / 5.;\n    } else {\n        seqID = 2;\n        seqTime = (time - SEQ_2_TIME);\n    }\n\n}\n\nvoid getCamera(in int seqID, in float seqTime, in float time, out vec3 cameraPos, out vec3 targetPos, out float fov)\n{\n    fov = 3.5;\n    if(seqID == 0) {\n        float theta = RAD90 + 0.25 + seqTime * 0.02;\n        float r = 30. - seqTime * 0.1;\n        cameraPos = vec3(cos(theta) * r, 4., -sin(theta) * r);\n        targetPos = vec3(0., 1.5, 0.);\n    } else if(seqID == 1) {\n        float theta = -RAD90 + 0.1 + seqTime * 0.1;\n        float r = 5. - seqTime * 0.2;\n        cameraPos = vec3(cos(theta) * r, 1.5, -sin(theta) * r);\n        targetPos = vec3(0., 0.5, 0.);\n    } else if(seqID == 2) {\n        float offsetY = smoothstep(0., 0.3, seqTime) * 0.7;\n        cameraPos = vec3(0, 1.5 + offsetY, -3.0 + saturate(ease_cubic_out(seqTime)) * 0.15 + seqTime * 0.1);\n        targetPos = vec3(0., 1.5 + offsetY, 0.);\n        fov = 5.;\n    }\n}\n\nfloat getFade(in int seqID, in float seqTime, in float time)\n{\n    float o = 0.;\n    if (seqID <= 1) {\n        o = seqTime < 0.5 ? smoothstep(0., 0.1, seqTime) : smoothstep(1., 0.9, seqTime);\n    } else {\n        o = smoothstep(10., 5., seqTime);\n    }\n    return o;\n    \n}\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nsurface map(vec3 p)\n{\n\tsurface result = SURF_NOHIT(MAX_DIST);\n    p = rotate(p, M_PI, vec3(0,1,0));\n    \n    float d = sdSphere(p, 4.);\n    if(d < 1.0)\n    {\n        int seqID = 0;\n        float seqTime = 0.0;\n        float bodyYOffset = 0.;\n\n        getSequence(iTime, seqID, seqTime);\n        initSkel( seqID, seqTime, iTime, bodyYOffset);\n\n        result = de(p - vec3(0, 1.9 + bodyYOffset, -2.0));\n    }\n    \n    // background\n    surface bg1 = SURF_BG1(sdPlane(p, vec4(0,1,0,0)), p);\n    surface bg2 = SURF_WALL(sdBox(p + vec3(-9,0,11), vec3(10,100, 10)));\n    bg1 = opU(bg1, bg2);\n    \n    surface dimple = SURF_DIMPLE(sdSphere(p - vec3(0, 4.8, -0.55), 6.0), max(0., 1.0 - iTime * 0.15));\n\n    bg1 = opS(dimple, bg1);\n    result = opU(result, bg1);\n\n    return result;\n}\n\nvec3 norm(in vec3 position) {\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          map(position + epsilon.xyy).dist - map(position - epsilon.xyy).dist,\n          map(position + epsilon.yxy).dist - map(position - epsilon.yxy).dist,\n          map(position + epsilon.yyx).dist - map(position - epsilon.yyx).dist);\n    return normalize(n);\n}\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        float h = map(origin + direction * t).dist;\n        if (h < EPS) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\nsurface traceRay(in vec3 origin, in vec3 direction) {\n    float t = 0.0;\n    \n    vec3 pos = origin;\n\n    int count = 0;\n    surface hit;\n    float d;\n    for (int i = 0; i < MAX_MARCH; i++) {\n        hit = map(pos);\n        d = abs(hit.dist);\n        \n        if (d <= EPS || d >= MAX_DIST) {\n        \tbreak;\n        }\n\n        t += d * 0.8;\n        pos = origin + direction * t;\n\n        count++;        \n    }\n\n    if(d <= EPS){\n    \treturn surface(t, hit.albedo, hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, true);\n    }else{\n    \treturn surface(t, vec3(0), hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, false);\n    }\n}\n\nvec3 SkyColor( vec3 rd )\n{\n    // Black\n    return vec3(0,0,0);\n}\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / M_PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / M_PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / M_PI;\n}\n\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\nvec3 calcAmb(vec3 pos, vec3 rayDir, vec3 normal, vec3 lightPos, vec3 lightColor, surface surf) {\n    vec3 color = vec3(0);\n    vec3 lightDir = normalize(lightPos);\n    vec3 viewDir = normalize(-rayDir);\n    vec3 halfV = normalize(viewDir + lightDir);\n    //vec3 r = normalize(reflect(rayDir, normal));\n\t\n    float NoV = abs(dot(normal, viewDir)) + 1e-5;\n    float NoL = saturate(dot(normal, lightDir));\n    float NoH = saturate(dot(normal, halfV));\n    float LoH = saturate(dot(lightDir, halfV));\n    \n    float indirectIntensity = 0.64;\n    \n    vec3 albedo = surf.albedo;\n    float roughness = surf.roughness;\n    float metallic = surf.metalness;\n    float linearRoughness = roughness * roughness;\n    vec3 diffuseColor = (1.0 - metallic) * albedo.rgb;\n    vec3 f0 = 0.04 * (1.0 - metallic) + albedo.rgb * metallic;\n    \n    float attenuation = shadow(pos, lightDir);\n    \n    // specular BRDF\n    float D = D_GGX(linearRoughness, NoH, halfV);\n    float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n    vec3  F = F_Schlick(f0, LoH);\n    vec3 Fr = (D * V) * F;\n\n    // diffuse BRDF\n    vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n    color = Fd + Fr;\n    color *= (attenuation * NoL) * lightColor;\n    \n \t// diffuse indirect\n    vec3 indirectDiffuse = Irradiance_SphericalHarmonics(normal) * Fd_Lambert();\n    \n    vec3 ibl = diffuseColor * indirectDiffuse;\n    \n    color += ibl * indirectIntensity;\n\tcolor += surf.emission;\n    \n    return color;\n}\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n\nvec3 materialize(vec3 ro, vec3 p, vec3 ray, surface mat, vec2 uv)\n{\n    vec3 col = vec3(0,1,0);\n    vec3 sky = SkyColor(ray);\n    \n    vec3 lightPos = vec3(-0.6, 0.8, -0.5);\n    //vec3 lightColor = vec3(0.98, 0.92, 0.89) * 1.0;\n    vec3 lightColor = vec3(0.2, 0.25, 1.0) + vec3(1, 0.05, 0.01) * (sin(iTime * 10.) * 0.5 + 0.5);\n\n    if (mat.dist >= MAX_DIST) {\n        col = sky;\n    } else {\n        vec3 result = vec3(0.);\n        vec3 nor = norm(p);\n\t\tvec3 sky = SkyColor(ray);\n        \n        col = calcAmb(p, ray, nor, lightPos, lightColor, mat);\n        col = mix(col, sky, 1.0 - saturate(exp2(1.0 - mat.dist*0.15)));\n        float metalness = mat.metalness;\n        float dist = mat.dist;\n    }\n    \n    // Tone mapping\n    col = Tonemap_ACES(col);\n\n\n    // Gamma compression\n    col = OECF_sRGBFast(col);\n    return col;\n}\n\nvec3 render(vec3 p, vec3 ray, vec2 uv)\n{\n    vec3 pos;\n    surface mat = traceRay(p, ray);\n    \n    pos = p + mat.dist * ray;\n    return materialize(p, pos, ray, mat, uv);\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);\n    int seqID = 0;\n    float seqTime = 0.0;\n    getSequence(iTime, seqID, seqTime);\n    \n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n    \n        //float t = iTime * M_PI2 * -0.1;\n        //float t = iTime * -0.1;\n        //float t = 0.;\n        //float y = sin(t * 2.5) * 0.125-0.0;\n        //float y = sin(t * M_PI2 * 0.5) * 0.1 + 1.5;\n        //float y = 1.5;\n        //float r = 2. + sin(t * 0.5)*0.5;\n        //float theta = t + RAD90 + RAD90*0.25;\n        //float theta = RAD90 + RAD90*0.25;\n        //float theta = RAD90;\n        //vec3 ro = vec3( 0., 0.05, -0.75 );\n        //vec3 ro = vec3(cos(theta) * r, y, -sin(theta) * r);\n        //vec3 ro = vec3(0,-0.5,5.);\n        //vec3 ta = vec3(0., 0.75 + iMouse.y / iResolution.y * 3.0, 0.);\n        /*\n        float t = iMouse.x / iResolution.x * M_PI2 * 1.5;\n        float y = iMouse.y / iResolution.y * 3.0;\n        float r = 6.;\n        float theta = t + RAD90;\n        vec3 ro = vec3(cos(theta) * r, y, -sin(theta) * r);\n        vec3 ta = vec3(0., 0.5, 0.);\n        */\n        \n        vec3 ro = vec3(0);\n        vec3 ta = vec3(0);\n        float fov = 3.5;\n        getCamera(seqID, seqTime, iTime, ro, ta, fov);\n        \n        mat3 c = camera(ro, ta, 0.0);\n        vec3 ray = c * normalize(vec3(p, fov));\n        vec3 col = render(ro, ray, fragCoord.xy);\n    \n    \ttot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    float o = getFade(seqID, seqTime, iTime);\n    \n    fragColor = vec4(tot * o,1.0);\n}","name":"Image","description":"","type":"image"}]}