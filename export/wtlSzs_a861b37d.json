{"ver":"0.1","info":{"id":"wtlSzs","date":"1563989798","viewed":389,"name":"crappy smooth stencil outlines","username":"cdyk","description":"Experiment with using stencil shapes to create somewhat anti-aliased outlines for NPR-rendering. Values of weights are quite arbitrary and just found by some experimenting.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["outlines","npr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // 3x3 mask around pixel position\n    uint id00 = uint(texture(iChannel0, (fragCoord+vec2(-1,-1))/iResolution.xy).a);\n    uint id01 = uint(texture(iChannel0, (fragCoord+vec2( 0,-1))/iResolution.xy).a);\n    uint id02 = uint(texture(iChannel0, (fragCoord+vec2( 1,-1))/iResolution.xy).a);\n    uint id10 = uint(texture(iChannel0, (fragCoord+vec2(-1, 0))/iResolution.xy).a);\n    uint id11 = uint(texture(iChannel0, (fragCoord+vec2( 0, 0))/iResolution.xy).a);\n    uint id12 = uint(texture(iChannel0, (fragCoord+vec2( 1, 0))/iResolution.xy).a);\n    uint id20 = uint(texture(iChannel0, (fragCoord+vec2(-1, 1))/iResolution.xy).a);\n    uint id21 = uint(texture(iChannel0, (fragCoord+vec2( 0, 1))/iResolution.xy).a);\n    uint id22 = uint(texture(iChannel0, (fragCoord+vec2( 1, 1))/iResolution.xy).a);\n\n    // Hard line - object id of left, below and left-below neihbour different -> line\n    // (used for comparison)\n    bool hardLine =\n        id11 != id12 ||\n        id11 != id21 ||\n        id11 != id22;\n\n    // Classify shape of boundary, 256 cases.\n    uint code =\n        (id11 != id00 ? 1u : 0u) +\n        (id11 != id01 ? 2u : 0u) +\n        (id11 != id02 ? 4u : 0u) +\n        (id11 != id10 ? 8u : 0u) +\n        (id11 != id12 ? 16u : 0u) +\n        (id11 != id20 ? 32u : 0u) +\n        (id11 != id21 ? 64u : 0u) +\n        (id11 != id22 ? 128u : 0u);\n\n    // Blackness for each stencil shape.\n    float weights[256];\n\n    // no bits set is far away from boundary\n    weights[0] = 0.0;\n    \n    // Default for all cases that I have forgotten about\n    const float weight_default       = 0.5;\n    for(int i=1; i<256; i++) weights[i] = weight_default;\n\n    // X 0 0\n    // 0 0 0\n    // 0 0 0 and symmetries\n    const float weight_single_pixel  = 0.25;\n    weights[  1] = weight_single_pixel;\n    weights[  2] = weight_single_pixel;\n    weights[  4] = weight_single_pixel;\n    weights[  8] = weight_single_pixel;\n    weights[ 16] = weight_single_pixel;\n    weights[ 32] = weight_single_pixel;\n    weights[ 64] = weight_single_pixel;\n    weights[128] = weight_single_pixel;\n\n    // X X 0\n    // 0 0 0 \n    // 0 0 0 and symmetries\n    const float weight_pairs_pixel   = 0.5;\n    weights[ 1+  2] = weight_pairs_pixel;\n    weights[ 2+  4] = weight_pairs_pixel;\n    weights[ 4+ 16] = weight_pairs_pixel;\n    weights[16+128] = weight_pairs_pixel;\n    weights[ 1+  8] = weight_pairs_pixel;\n    weights[ 8+ 32] = weight_pairs_pixel;\n    weights[32+ 64] = weight_pairs_pixel;\n    weights[64+128] = weight_pairs_pixel;\n\n\t// X X X\n    // 0 0 0\n    // 0 0 0 and symmetries\n    const float weight_full_row      = 0.6;\n    weights[ 1+ 2+  4] = weight_full_row;\n    weights[ 4+16+128] = weight_full_row;\n   \tweights[ 1+ 8+ 32] = weight_full_row;\n    weights[32+64+128] = weight_full_row;\n\n    // X X 0\n    // X 0 0\n    // 0 0 0 and symmetries\n    const float weight_single_corner = 0.5;\n    weights[ 1+ 2+  8] = weight_single_corner;\n    weights[ 2+ 4+ 16] = weight_single_corner;\n    weights[16+64+128] = weight_single_corner;\n    weights[ 8+32+ 64] = weight_single_corner;\n\n    // X X X\n    // X 0 0\n    // 0 0 0 and symmetries\n    const float weight_l_corner      = 0.5;\n    weights[ 1+ 2+  4+  8] = weight_l_corner;\n    weights[ 1+ 2+  8+ 32] = weight_l_corner;\n    weights[ 1+ 2+  4+ 16] = weight_l_corner;\n    weights[ 2+ 4+ 16+128] = weight_l_corner;\n    weights[ 1+ 8+ 32+ 64] = weight_l_corner;\n    weights[ 8+32+ 64+128] = weight_l_corner;\n    weights[ 4+16+ 64+128] = weight_l_corner;\n    weights[16+32+ 64+128] = weight_l_corner;\n\n    // X X X\n    // X 0 0\n    // X 0 0 and symmetries\n    const float weight_long_corner   = 0.8;\n    weights[1+ 2+ 4+ 8+ 32] = weight_long_corner;\n    weights[1+ 2+ 4+16+128] = weight_long_corner;\n    weights[1+ 8+32+64+128] = weight_long_corner;\n    weights[4+16+32+64+128] = weight_long_corner;\n\n    \n    float weight = 1.0 - weights[code];\n    vec4 tmp = texture(iChannel0, uv);\n    int id = int(tmp.a);\n    vec3 baseColor = 0.5*(vec3((id>>2)&1,(id>>1)&1,id & 1)+vec3(1));\n    if(id==0) {\n        baseColor = vec3(0.5, 0.7, 1.0);\n    }\n\n    if((int(iTime)%2) == 0) {\n        weight = hardLine ? 0.0 : 1.0;\n\t}\n    else {\n    \tif(weights[code]==0.76) {\n        \tfragColor = vec4(1,0,0,0);\n        \treturn;\n\t  \t}   \n    }\n\tfragColor = vec4(weight*baseColor, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct Ray\n{\n    vec3 o;\n    vec3 d;\n};\n\n    \nfloat intersectSphere(out vec3 normal,\n\t                  in Ray v,\n                      in vec3 o,\n                      in float r2)\n{\n    vec3 g = v.o - o;\n    \n    //<g + t*v.d, g + t*v.d> = r^2\n    //<g,g> - r^2 + 2*t*<g,v.d> + t^2 <v.d,v.d> = 0\n\n    float a = dot(v.d, v.d);\n    float b = 2.0*dot(g, v.d);\n    float c = dot(g, g) - r2;\n    \n    float disc = b*b - 4.0*a*c;\n    if(disc < 0.0) return -1.0;\n    \n    float d = sqrt(disc);\n    float t0 = (-b - d)/(2.0*a);\n    \n    vec3 w = g + t0*v.d;\n    normal = normalize(w);\n\n    return t0;\n}\n   \nfloat intersectCube(out vec3 normal,\n                    in Ray r,\n                    in vec3 o,\n                    in vec3 s)\n{\n    vec3 rcp = 1.0/r.d;\n    vec3 a = rcp*(o - r.o);\n\n    vec3 ta = a - abs(rcp)*s;\n    vec3 tb = a + abs(rcp)*s;\n    \n\n    normal = vec3(0,1,1);\n    \n    float tn = max(max(ta.x, ta.y), ta.z);\n    float tf = min(min(tb.x, tb.y), tb.z);\n    if( tf < max(0.0, tn)) {\n        return -1.0;\n    }\n    \n    // find channel that is less than the two other channels.\n    // flip sign to choose correct face.\n    vec3 lessThan1 = step(ta.yzx, ta.xyz);\n    vec3 lessThan2 = step(ta.zxy, ta.xyz);\n    normal = -sign(r.d)*lessThan1*lessThan2;\n   \n    return tn;\n}\n\nfloat intersectCylinder(out vec3 normal,\n                        in Ray r,\n                        in vec3 o,\n                        float hl,\n                        float r2)\n{\n    vec2 g = r.o.xy - o.xy;\n    \n    //<g + t*v.d, g + t*v.d> = r^2\n    //<g,g> - r^2 + 2*t*<g,v.d> + t^2 <v.d,v.d> = 0\n\n    float a = dot(r.d.xy, r.d.xy);\n    float b = 2.0*dot(g.xy, r.d.xy);\n    float c = dot(g.xy, g.xy) - r2;\n    \n    float disc = b*b - 4.0*a*c;\n    if(disc < 0.0) return -1.0;\n\n    \n    float d = sqrt(disc);\n    float t0 = (-b - d)/(2.0*a);\n    float t1 = (-b + d)/(2.0*a);\n\n    float rcp = 1.0/r.d.z;\n    float aa = rcp*(o - r.o).z;\n    float ta = aa - abs(rcp)*hl;\n    float tb = aa + abs(rcp)*hl;\n\n    // cylinder is between near and far cap\n    if(ta <= t0 && t0 <= tb) {\n        vec2 w = g + t0*r.d.xy;\n\t    normal = normalize(vec3(w,0));\n        return t0;\n    }\n            \n    // near cap is inside infinite cylinder\n    if(t0 < ta && ta < t1) {\n     \tnormal = vec3(0,0,-sign(r.d.z));\n        return ta;\n    }\n\n    return -1.0;\n}\n\nfloat intersectPlane(out vec3 normal,\n                     in Ray r,\n                     in vec3 n,\n                     float d)\n{\n    normal = n;\n    return -(d - dot(r.o, n))/dot(r.d, n);\n}\n\n\nfloat castRay(out vec3 n, out int id, in Ray r)\n{\n    id = 0;\n    float t = 1e37;\n    for(int k=0; k<3; k++) {\n        for(int j=0; j<3; j++) {\n            for(int i=0; i<3; i++) {\n                vec3 nn;\n                float tt;\n\n                int kk = i+j+k;\n                \n                vec3 o = vec3(i-1, j-1, k-1);\n                \n                if((kk % 3)==0) {\n\t                tt = intersectSphere(nn, r, o, 0.45*0.45);\n                }\n                else if((kk %3)==1) {\n                    tt = intersectCylinder(nn, r, o, 0.45, 0.45*0.45);\n                }\n                else {\n\t                tt = intersectCube(nn, r, o, vec3(0.45));\n                }\n                 if(0.0 < tt && tt < t) {\n                    t = tt;\n                    n = nn;\n                    id = 3*(3*k+j) + i + 2; \n                }\n            }\n        }\n    }\n \n    {\n        vec3 nn;\n        float tt = intersectPlane(nn, r, vec3(0,1,0), 2.0);\n        if(0.0 < tt && tt < t) {\n            t = tt;\n            n = nn;\n            id = 1;\n        }\n    }\n    \n    return t < 1e37 ? t : -1.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float ww = 0.1;\n    float c0 = cos(ww*iTime + 0.2);\n    float s0 = sin(ww*iTime + 0.2);\n    float c1 = cos(ww*iTime+0.6);\n    float s1 = sin(ww*iTime+0.6);\n    \n    float w = 2.0/max(iResolution.x, iResolution.y);\n    vec3 q = vec3(w*(fragCoord.xy - 0.5*iResolution.xy), -1.0);\n    \n    Ray r;\n\n    r.d.x = c0*q.x - s0*q.z;\n    r.d.y = q.y;\n    r.d.z = s0*q.x + c0*q.z;\n    r.d = normalize(r.d);\n\n    r.o = 5.0*vec3(-s0,0,c0);\n   \n    int id;\n\tvec3 n;\n    float t = castRay(n, id, r);\n\n    if(0.0 < t) {\n        vec3 lp = 7.0*vec3(-s1, 0.75, c1);\n        \n        Ray s;\n        s.o = r.o + t*r.d;\n        s.d = normalize(lp-s.o);\n        //s.o += 0.01*s.d;\n        \n        vec3 foo;\n        int bar;\n        float tt = castRay(foo, bar, s);\n        bool inShadow = 0.0 < tt;\n        \n        float diffuse = inShadow ? 0.0 : dot(s.d, n);\n        \n    \tfragColor = vec4(n, float(id) + fract(max(0.0, diffuse)));\n    }\n    else {\n\t    fragColor = vec4(0,0,1,0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}