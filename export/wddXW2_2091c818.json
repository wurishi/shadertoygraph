{"ver":"0.1","info":{"id":"wddXW2","date":"1572943111","viewed":95,"name":"Polkadot 3D - Plastic Moons","username":"vikitux","description":"Simple and easy polkadot 3d","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytrace","points","polkadot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based on original shader https://www.shadertoy.com/view/wd3GDf\n// 2019 (c) Animation CPU Project Experiments https://twitter.com/acpustudio\n\n#define FALLOFF 100.0\n#define EPSILON 0.001\n\nfloat torus(vec3 ray, vec2 size) {\n    vec2 v = vec2(length(ray.xz) - size.x, ray.y);\n    return length(v) - size.y - 0.1*length(ray);\n}\n\nfloat toScene(vec3 ray) {\n    vec3 bray = ray - vec3(0.0, 0.75, 2);\n    vec3 period = vec3(11, 22, 11);\n    vec3 mray = mod(bray + vec3(0, 0, iTime * 4.0), period) - 0.5 * period;\n    return torus(mray, vec2(0.13550, 0.9));\n}\n\nfloat ray(vec3 origin, vec3 direction) {\n    float d = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 ray = origin + direction * d;\n        float step = abs(toScene(ray));\n        d += step;\n        if (d > FALLOFF || step < EPSILON) {\n            break;\n        }\n    }\n    return d;\n}\n\nvec3 getNormal(vec3 p) {\n    float d = toScene(p);\n    vec2 grade = vec2(0.001, 0);\n    vec3 n = d - vec3(toScene(p - grade.xyy),\n                      toScene(p - grade.yxy),\n                      toScene(p - grade.yyx));\n    return normalize(n);\n}\n\nfloat light(vec3 from) {\n    vec3 lv = vec3(5, 5, -5) - from;\n    vec3 l = normalize(lv);\n    vec3 n = getNormal(from);\n    float diffuse = clamp(dot(n, l) * 0.5 + 0.5, 0.0, 1.0);\n    float d = ray(from + n * EPSILON * 2.0, l);\n    if (d < length(lv)) {\n        diffuse *= 0.5;\n    }\n    return diffuse;\n}\n\nvec3 lookat(vec2 uv, vec3 from, vec3 to, float zoom) {\n    vec3 forward = normalize(to - from);\n    vec3 right = cross(vec3(0, 1, 0), forward);\n    vec3 up = cross(forward, right);\n    return normalize(forward * zoom + uv.x * right + uv.y * up);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n\n    vec3 origin = vec3(10., 15, 6.+16.*sin(iTime*.1));\n    \n    vec3 direction = lookat(uv, origin, vec3(1, 0, 1), 0.8);\n    \n    float d = ray(origin, direction);\n    vec3 col = vec3(0);\n    \n    if (d < FALLOFF) {\n        vec3 p = origin + direction * d;\n        float diffuse = light(p);\n        col = vec3(diffuse);\n    }\n    \n    fragColor = vec4(col/vec3(0.2,d*0.02,d/11.), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}