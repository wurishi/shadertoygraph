{"ver":"0.1","info":{"id":"lfXfD4","date":"1730069828","viewed":31,"name":"Boring Modified Newton Fractal","username":"OetkenPurveyorOfCode","description":"boring newton fractal with a modified derivative","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["newton"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 cmul(vec2 a, vec2 b) { // complex multiplication\n    return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);\n}\nvec2 cdiv(vec2 a, vec2 b) { // complex division\n    return vec2(a.x*b.x+a.y*b.y, -a.x*b.y+a.y*b.x) / (b.x*b.x+b.y*b.y);\n}\n\nvec2 fn(vec2 z) { // f(z) = z^3 - 1\n    return cmul(z,cmul(z,z)) - vec2(1,0);\n}\n\nvec2 dfn(vec2 z) { // f'(z) = 3*z^2\n    return cmul(vec2(0.6*sin(iTime)+3.0,0),cmul(z+vec2(sin(iTime*0.1), -0.4*sin(iTime*0.37)),z));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord/iResolution.xy * 2.0 - 1.0;\n    float zoom = pow(1.0+1.05,2.);\n    vec2 z = coord/zoom;\n    \n    vec2 zPrev = z;\n    float threshold = 0.00001;\n    float i;\n    \n    // iterate: zNext = z - f(z)/f'(z)\n    for (i=0.; i<100.; i++) { \n        z -= cdiv(fn(z),dfn(z));\n        if (length(z - zPrev) < threshold) break;\n        zPrev = z;\n    }\n    \n    float theta = atan(z.y,z.x);\n    float rotation = mod(theta/6.2832 + 1., 1.); // [0,1]\n    \n    vec3 color;\n    if (rotation < 0.33) {\n         color = vec3(1,0.2,0.1);\n    } else if (rotation < 0.66) {\n         color = vec3(0.97,0.8,0.12);\n    } else {\n         color = vec3(0.2,0.2,0.3);\n    }\n    \n    // set intensity based on how fast the solution was found\n    float intensity = 1./(log(i)-2.0); \n    \n    fragColor = vec4(color * intensity, 1);\n}\n","name":"Image","description":"","type":"image"}]}