{"ver":"0.1","info":{"id":"ts3SRj","date":"1572506795","viewed":520,"name":"Experiments simulating gravity","username":"rmmcal","description":"I'm not a physicist... forgive the nonsense calculus... I'm just testing my crazy theory...\n=> I am in the wonderful world of ideas where everything is possible...\nEach checkbox (\"remove\"/\"normalize\") the equation...\n=> 100 particles (2 dimension).","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["2d","ui","gravity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision highp  float;\n#endif\n\n/////////////////////////////////////////////////////////////\n/////      .. Experiments simulating gravity ..     ///////// \n/////////////////////////////////////////////////////////////\n// Brasil/Amazonas/Manaus\n// Experiments simulating gravity\n// Created by Rodrigo Cal (twitter: @rmmcal) - 2019/10\n// - https://www.shadertoy.com/view/ts3SRj\n/////////////////////////////////////////////////////////////\n// -------------------------------------------------------\n//\n//  I'm not a physicist... Forgive the nonsense calculus... \n//  I'm just testing my crazy theory...\n//\n//  Notes:\n//   - 100 particles (2 dimension).\n//   - All particles have the same mass.\n//   - Each checkbox => (\"remove\"/\"normalize\") the equation...\n//   - The memory map (left bottom) \n//   - Lessness => min postion of all particules.\n//   - Greatness=> max postion of all particules.\n//\n// -------------------------------------------------------\n/////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////\n//========================\n//= Function of Text \n//========================\n//\n\nint shift(int v, int s){\n    if ( s == 0) return v;\n    if ( s == 8) return v/256;\n    if ( s == 16) return v/256/256;\n    if ( s == 24) return (v/256)/256/256;\n    return 0;\n}\n\nint modi(int a, int n){\n\treturn a - (n * int(a/n));\n}\nvec4 char( vec2 p, int v){ \n    vec2 v2 = clamp(p / 16., 0.0, 1./16.) -vec2(0.,1./16.) + vec2(float(modi(v,16))/16., -float(v/16)/16.);\n    return vec4(texture(iChannel3,v2,-1.));                     \n}\n\nint map(ivec4 c, int i)\n{\n\tif (i == 0) return c.x;\n\tif (i == 1) return c.y;\n\tif (i == 2) return c.z;\n\tif (i == 3) return c.w;\n    return 0;\n}\n\nvec4 mapText(vec2 p, vec2 tp, float s, ivec4 text) { \n    vec4 chr = vec4(0.);\n    int k = 0;\n    p -= tp;\n    p+=vec2( .5/s );\n    p *= vec2(s);\n    int ip = 0;\n    float len = 0.;\n    for ( int i = 0; i < 20; i++){\t\t\t\t\t \t// ivec4( 0x_01_02_03_04, 0x_05_06_07_08, 0x_09_10_11_12, 0x_13_14_15_16 )\n        int chv = map(text,k); // text[k] \n        if (chv == 0) break; \t\t\t\t\t \t// nothing to process then break\n        if (ip == 4) {\n            k++; ip=0; // continue; // next index to process\n        } else\n        {\n            //int ch = (chv >> (8*(3-( ip % 4)))) % 256;\t\t// ascii code from ivec4 \n\n            int ch =  modi((shift(chv, 8*(3-(modi((ip),4))))),256); // compatibility mode\n            \n            if (ch == 0) {\n                ip++; //continue; \t\t\t\t\t\t\t\t// next index to process\n            }else\n            {\n                chr = max(chr,  char(p, ch).x); \t\t\t\t// draw           \n                len++;\n                p-=vec2(float(.5),0.);\t\t\t\t\t\t \t// move postion to next char\n                ip++;\t\t\t\t\t\t\t\t\t\t\t// next char\n            }                \n        }\n    }  \n    return vec4(chr.xyz, len);                   \n}  \n\nvec4 mapNumber( vec2 p, vec2 tp, float s, float v1){\n    float vn = abs(v1), vf = fract(vn), count = .0, vc = vn;\n    vec4 chr = vec4(0.);\n    for (int i = 0; i < 10; i++) { \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// count digits \n        count++; vc /= 10.;\n        if (vc <= 1.0 && i != 0) break;\n    }\n    if (v1 < 0.) count++;\n    p = (p - tp + vec2(.5/s ) + vec2(-count*.05, 0.)) * vec2(s);\n    if (v1 < 0.){\n        chr = max(chr, char( (p+vec2(float(count-1.)*.5,0.)), 0x2d).x); \t\t\t\t\t\t// minus/(-)\n\t}\n    chr = max(chr, char((p-vec2(float(1)*.5,0.)), 0x2e).x); \t\t\t\t\t\t\t\t\t// dot/period (.)\n    for (int i = 0; i < 10; i++) {\n        if (vn >= 1.0 || i == 0)\n            chr = max(chr, char( (p+vec2(float(i)*.5,0.)), 48+int(mod(abs(vn),10.))).x); \t\t// draw int\n        vn /= 10.; vf *= 10.;\n        if (i < 2)\n                chr = max(chr, char( (p-vec2(float(i+2)*.5,0.)), 48+int(mod(abs(vf),10.))).x); // draw dec\n    }\n    return chr;\n} \n\nfloat drawText( inout vec4 c, vec2 p, vec2 tp, float s, ivec4 text, vec4 color) { \n    vec4 m = mapText( p, tp, 10./s, text);\n    c = mix(c, color,  clamp(m.x, 0.,1.));\n    return m.w;\n}\n\nvoid drawTextNumber( inout vec4 c, vec2 p, vec2 tp, float s, float textNumber, vec4 color) { \n    c = mix(c, color,  clamp(mapNumber(p, tp, 10./s, textNumber).x, 0.,1.));\n}\n\n////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////\n//========================\n//= Draw Components \n//========================\n//\n\nfloat mapX(vec2 p,  float s){\n\n    return max(length(p)-s, min(abs(p.x-p.y), abs(p.x+p.y)));\n}\n\nvoid drawCheckbox( inout vec4 c, vec2 p, vec2 t, float selected){\n    p-=t;\n    c = mix(c, vec4(0.,1.,0.,1.), selected*smoothstep(0.,.01, .03 - sdBox(p,vec2(.012))));\n    c = mix(c, vec4(0.,0.,0.,1.), smoothstep(0.,.01, .01-abs(.03 - sdBox(p,vec2(.010)))));\n    c = mix(c, vec4(1. ), selected*(1.-smoothstep(-0.011,0.0, -.015+mapX(p,  0.03)))) ; // icon\n}\n\nvoid drawButton( inout vec4 c, vec2 p, vec4 t, float pressed){\n    p-=t.xy;\n    float area = .03 - sdBox(p,vec2(.020)+t.zw);\n    float arean = smoothstep(0.,.01, area);\n\n    c = mix(c, vec4(0.5,.5,0.5,1.), arean);\n    c = mix(c, vec4(0.9,.9,0.9,1.), min(arean, (smoothstep(0.,.04, area))));\n    c = mix(c, vec4(0.0,1.,0.8,1.), pressed*min(arean, (smoothstep(0.,.04, area))));\n    c = mix(c, vec4(0.,0.,0.,1.), smoothstep(0.,.01, .01-abs(.03 - sdBox(p,vec2(.015)+t.zw))));\n}\n\n\n\nvoid drawUI( inout vec4 c, sampler2D iChannelFont, sampler2D iChannel0, vec2 fragCoord, vec2 iResolution, vec4 iMouse){\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 a = vec2( iResolution.x/ iResolution.y, 1.);\n    vec2 p = (uv-.5)*a;\n    for (int i = 0 ; i < componentsLength; i++)\n    {\n        Component comp = components[i];\n        // switch(comp.type)  // removed to compatibility but losing performance\n        {\n            //case TYPE_CHECKBOX:\n            if (comp.type == TYPE_CHECKBOX)\n            {\n                drawCheckbox(c, p, comp.positionSize.xy, float(comp.value));\n            \tdrawText(c, p, comp.positionSize.xy+vec2(0.08,0.), .8, comp.textHexStr, vec4(0.)); \n            }\n            if (comp.type == TYPE_BUTTON)\n            {\n                drawButton(c, p, comp.positionSize, float(comp.value));\n                drawText( c, p, comp.positionSize.xy+vec2(0.01,0.)-comp.positionSize.zw, 1., comp.textHexStr, vec4(0.)); \n            }\n            if (comp.type == TYPE_LABEL)\n            {\n            \tdrawText( c, p, comp.positionSize.xy+vec2(0.01,0.), comp.positionSize.z, comp.textHexStr, comp.color); \n            }\n            if (comp.type == TYPE_LABEL_NUMBER)\n            {\n                float len = drawText(c, p, 1.*comp.positionSize.xy+vec2(0.01,0.), comp.positionSize.z, comp.textHexStr, comp.color); \n                drawTextNumber( c, p, 1.*comp.positionSize.xy+vec2(0.01+len*.04*comp.positionSize.z,0.), comp.positionSize.z, comp.value.x, comp.color);\n            }\n        }\n    }\n}\n\n\n////////////////////////////////////////////////////////////\n//========================\n//= Draw Particules\n//========================\n//\n\nvec4 drawParticules(inout vec4 c, sampler2D iChannel0,  vec2 fragCoord, vec2 iResolution, vec4 iMouse){\n\tvec2 ar = vec2( iResolution.x/ iResolution.y, 1.);\n  \n    vec2 r = iResolution.xy;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 a = vec2( iResolution.x/ iResolution.y, 1.);\n    vec2 p = (uv-.5);\n\t\n    vec2 pmed = components[ 8].value.zw;\n    vec2 pmin = components[ 9].value.zw;\n    vec2 pmax = components[10].value.zw;\n    \n    float s = clamp(sqrt(sqrt(components[8].value.x- components[10].value.x)), 1.,6.); \n    p *= s;\n    \n    p = p * a;\n    for (int j = 0; j < SY; j++)\n        for (int i = 0; i < SX; i++)\n        {\n            vec4 pos = textureBase( iChannel0, ivec2(i,j));\n            c = mix(c, vec4(s/20.), smoothstep(0.,0.001,.01-length(p-pos.xy)));\n        }\n    return c;\n}\n\nvec4 bgColor(vec2 fragCoord){\n    vec4 c = vec4(1.);\n    vec2 r = iResolution.xy;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 a = vec2( iResolution.x/ iResolution.y, 1.);\n    vec2 p = (uv-.5)*a;\n    c = mix(c , vec4(0.,0.,0.,1.),1.- smoothstep(0.,3.,3. - length(p)));\n    return c;\n}\n\nvoid drawMap(inout vec4 c, vec2 fragCoord)\n{\n    if (iResolution.x < 420.)\n        return;\n    \n    // show map memory.\n    ivec2 ifc = ivec2(fragCoord/4.);\n    if (ifc.x > 0 && ifc.x < SX && ifc.y > 0 &&ifc.y < SY)  \n        c = mix(c, textureBase ( iChannel0, ifc), .5 );\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    init(iResolution, iFrame, iTime, iMouse);\n    loadMemory(iChannel0, fragCoord);\n    \n    \n    vec4 c = bgColor(fragCoord);\n    drawParticules(c, iChannel0,  fragCoord,  iResolution.xy, iMouse);\n \n    drawMap(c, fragCoord);\n    \n    drawUI( c, iChannel3, iChannel0, fragCoord,  iResolution.xy, iMouse);\n    \n    fragColor = vec4(c.xyz,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////\n//========================\n//= Processing Components \n//========================\n//\n\nvoid invertBool(inout float x){\n    x = x == 0. ? 1. : 0.;\n}\n\nvoid processMouseOnComponents(ivec2 ifc, vec2 m){\n    //switch(components[ifc.y].type)\n    {\n        if (components[ifc.y].type == TYPE_CHECKBOX)\n        {\n            if (isClicking(components[ifc.y].positionSize.xy, vec2(.020),  m) == 1. && onEventPress)\n            {\n                invertBool(components[ifc.y].value.x);\n            }\n        }\n        //break;\n\n        if (components[ifc.y].type == TYPE_BUTTON)\n        {\n            if (isClicking(components[ifc.y].positionSize.xy,  vec2(.030)+components[ifc.y].positionSize.zw, m) == 1. && onEventPress)\n            {\n                invertBool(components[ifc.y].value.x);\n            }\n        }\n        //break;\n    }\n}\n\nvoid processActionsComponents(ivec2 ifc){\n    //switch(components[ifc.y].type)\n    {\n        if (components[ifc.y].type == TYPE_BUTTON)\n        {\n            if (components[ifc.y].value.x == 1. && !onPress)\n            {\n                invertBool(components[ifc.y].value.x);\n            }\n        }\n    }\n}\n\nvoid dataUpdate(ivec2 ifc, vec2 m){\n    components[12].value.x = float(frame)/time;\n    if ( ifc.x == MEM_COMPONENTS && ifc.y < componentsLength )\n    {\n        processActionsComponents(ifc);\n        processMouseOnComponents( ifc,  m);\n    }\n}\n\n////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////\n//========================\n//= Method to process Particules\n//========================\n//\n\nvoid sum(inout vec2 add, vec2 dir) {\n    if (normalizeDistance){\n        add += normalize(dir); \t\t\t\t// ignore distance\n    } \n    else {\n        add += (dir)/(pow(length(dir),2.)); \n    }\n}\n\nvec2 acc(vec2 sum) {\n    if (normalizeMass){\n        return normalize(sum); \t\t\t\t// ignore mass \n    }\n    else {\n        return (sum); \t\t\t\t\t\t//  newton\n    }\n}\n\nvoid join(inout vec2 position, inout vec2 inertia, vec2 dir) {\n\n    inertia -= acc(dir) / 100000.;\n    if (normalizeInertia)\n    {\n        inertia = normalize(inertia)  / 1000.;\n    }\n\n    if (normalizeGravity)\n    {\n        position -= acc(dir) / (normalizeMass ? 1000. : 100000. );\n    }\n    else\n    {\n        position += inertia;\n    }\n}\n\n////////////////////////////////////////////////////////////\n//========================\n//= Processing Particules\n//========================\n//\n\nvec4 processBackbuffer( out vec4 fragColor, sampler2D iChannel0,sampler2D iChannel1, in vec2 fragCoord, vec2 iResolution, int iFrame, float iTime, vec4 iMouse )\n{\n    vec2 r = iResolution.xy;\n    vec2 fc = fragCoord;\n    ivec2 ifc = ivec2(fc);\n    vec2 uv = fc / r.xy;\n    vec2 ar = vec2( iResolution.x/ iResolution.y, 1.);\n    vec2 p = (uv-.5)*ar;\n    vec2 m = (iMouse.xy/r-.5)*ar;\n    vec4 a;\n\n    onPress = iMouse.z > 0. && iMouse.w > 0.;\n    onSamePress = iMouse.xy == iMouse.zw;\n    onEvent = backMouse != mouse;\n    onEventPress = onEvent && onSamePress;\n\n    if (iFrame < 5 || resetParticules) \n    {\n        // Action to Reset button\n        components[8].value.x =  .4;\n        components[9].value.x =  .4;\n        components[10].value.x = -.4;\n        components[11].value.x = -.4;\n   \t\t\n        a.xy = ((fc/vec2(SX,SY))-.5)*.5;\n\n        // a.xy = ((uv-.5/vec2(SX,SY)*ar.yx)*ar)*10.;\n       \t// a.xy = vec2(0.1);\n    }\n    else if (int(fc.x) <= MEM_COMPONENTS && int(fc.y) <= MEM_COMPONENTS)\n    {\n        // Processing particules\n        vec4 posBase = textureBase( iChannel0, ivec2(fc));\n        a = posBase;\n        vec2 center; \n      \tvec2 dir; \n        vec4 pmax = vec4(-10000.); \n        vec4 pmin = vec4(+10000.); \n        for (int j = 0; j < SY; j++)\n            for (int i = 0; i < SX; i++)\n            {\n                vec4 pos = textureBase( iChannel0, ivec2(i,j));\n                pmax = max(pmax,pos);\n                pmin = min(pmin ,pos);\n\n                vec2 direction = (posBase.xy-pos.xy);\n                if (length(direction) != 0.) // ignore singularity\n                {\n                    sum(dir, direction);\n                }\n                \n                center += direction;\n            }\n\n        join(a.xy, a.zw, dir);\n      \n        components[8].value.x =  pmax.x;\n        components[9].value.x =  pmax.y;\n        components[10].value.x = pmin.x;\n        components[11].value.x = pmin.y;\n    }\n    else\n    {\n    \t//discard; // Buffer A \n    }\n\n    dataUpdate(ifc, m);\n    return  texturePack(vec4(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init(iResolution, iFrame, iTime, iMouse);\n \tloadMemory(iChannel0, fragCoord);\n    \n    vec4 v = processBackbuffer(fragColor, iChannel0, iChannel1, fragCoord, iResolution.xy, iFrame, iTime, iMouse);\n    fragColor = v;\n\n    saveMemory(iChannel0, fragColor, fragCoord);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n/////////\n\n#define textureUnpack(a) a\n#define texturePack(a) a\n#define textureBase(a,b) texelFetch( a,  ivec2(b), 0 )\n\n/**\n\n#define textureUnpack(a) (a-.5)*1000.\n#define texturePack(a) clamp((a/1000.+.5), 0., 1.)\n\n#define textureBase(a,b) textureUnpack(texture( a,  vec2(b)/resolution.xy, -1000000. ))\n/**/\n\n\n/////////////////////////////////////////////////////////////\n//============= \n//= Constants =\n//============= \n/////////////////\n\nconst int SX = 10;\nconst int SY = 10;\nconst int ST = SX*SY;\nconst int MEM = SX+1;\nconst int MEM_COMPONENTS = SX+2;\n\nconst ivec2 LOC_STATE_MOUSE = ivec2(MEM,0);\nconst ivec2 LOC_STATE_PMOUSE = ivec2(MEM,1);\nconst ivec2 LOC_STATE_MODE  = ivec2(MEM,2);\n\nvec4 backMouse;\nvec4 deltaMouse;\n\n\n/////////////////////////////////////////////////////////////\n//============= \n//= Struture of UI Components \n//============= \n// \n\nconst int TYPE_CHECKBOX \t= 0;\nconst int TYPE_BUTTON \t\t= 1;\nconst int TYPE_LABEL \t\t= 2;\nconst int TYPE_LABEL_NUMBER = 3;\n\n\nstruct Component{\n    int type;\n    vec4 positionSize;\n    ivec4 textHexStr;\n    vec4 color;\n    vec4 value;\n};\n\n    const vec4 checkBoxes = vec4(-.82,.20,0.,0.);    \n\nconst int componentsLength = 13;\nComponent components[componentsLength];\n\nvoid initComponents(){\n\n    // Component[] components = Component[](Component(...),...); // removed.... :(\n\n    components[0] = Component(\n        TYPE_CHECKBOX,\n        vec4(0., 0., .0, .0) + checkBoxes,\t\t// position \n        ivec4(0x47726176, 0x697479, 0, 0), \t\t// Gravity // acceleration\n        vec4(0.),\t\t\t\t\t\t\t\t// initial color\n        vec4(0.)\t\t\t\t\t\t\t\t// initial value\n    );\n    \n    components[1] = Component(\n        TYPE_CHECKBOX,\n        vec4(0., -0.1, .0, .0) + checkBoxes, \t// position \n        ivec4(0x4d617373, 0, 0, 0), \t\t\t// Mass\n        vec4(0.),\t\t\t\t\t\t\t\t// initial color\n        vec4(0.)\t\t\t\t\t\t\t\t// initial value\n    );\n    components[2] = Component(\n        TYPE_CHECKBOX,\n        vec4(0., -0.2, .0, .0) + checkBoxes,\t// position \n        ivec4(0x44697374, 0x616e6365, 0, 0),\t// Distance\n        vec4(0.),\t\t\t\t\t\t\t\t// initial color\n        vec4(0.)\t\t\t\t\t\t\t\t// initial value\n    );\n    components[3] = Component(\n        TYPE_CHECKBOX,\n        vec4(0., -0.3, .0, .0) + checkBoxes, \t// position \n        ivec4(0x496e6572, 0x746961,  0, 0), \t// Inercia\n        vec4(0.),\t\t\t\t\t\t\t\t// initial color\n        vec4(0.)\t\t\t\t\t\t\t\t// initial value\n    );\n    components[4] = Component(\n        TYPE_BUTTON,\n        vec4(.55,.3, .12, .0), \t\t\t\t\t// position \n        ivec4(0x52657365, 0x74, 0, 0), \t\t\t// Reset\n        vec4(0.),\t\t\t\t\t\t\t\t// initial color\n        vec4(0.)\t\t\t\t\t\t\t\t// initial value\n    );\n    components[5] = Component(\n        TYPE_LABEL,\n        vec4(-.84,.45, 1.05, .0),\t\t\t\t\t\t\t\t// position \n        ivec4(0x45787065, 0x72696d65, 0x6e747320, 0x53696d75),  // Experiments Simu\n        vec4(0.),\t\t\t\t\t\t\t\t\t\t\t\t// initial color\n        vec4(0.0)\t\t\t\t\t\t\t\t\t\t\t\t// initial value\n    );\n    components[6] = Component(\n        TYPE_LABEL,\n        vec4(.0,.45, 1.05, .0),\t\t\t\t\t\t\t\t\t// position \n        ivec4(0x6c617469, 0x6e672047, 0x72617669, 0x7479),\t\t// ________________lating Gravity\n        vec4(0.),\t\t\t\t\t\t\t\t\t\t\t\t// initial color\n        vec4(0.0)\t\t\t\t\t\t\t\t\t\t\t\t// initial value\n    );\n    components[7] = Component(\n        TYPE_LABEL,\n        vec4(+.0,.1, 1., .0)+checkBoxes,\t\t\t\t\t\t// position, size\n        ivec4(0x52656d6f, 0X76652f4e, 0X6f726d61, 0X6c697a65),  // Remove/Normalize\n        vec4(0.),\t\t\t\t\t\t\t\t\t\t\t\t// initial color\n        vec4(0.0)\t\t\t\t\t\t\t\t\t\t\t\t// initial value\n    );\n    components[8] = Component(\n        TYPE_LABEL_NUMBER,\n        vec4(+.13,-.4, .7, .0),\t\t\t\t\t\t\t\t\t// position, size\n        ivec4(0x47726561, 0x746e6573, 0x73583a, 0x0),  \t\t\t// GreatnessX:\n        vec4(0.),\t\t\t\t\t\t\t\t\t\t\t\t// initial color\n        vec4(0.4,0,.4,1)\t\t\t\t\t\t\t\t\t\t// initial value\n    );\n    components[9] = Component(\n        TYPE_LABEL_NUMBER,\n        vec4(+.13,-.45, .7, .0),\t\t\t\t\t\t\t\t// position, size\n        ivec4(0x47726561, 0x746e6573, 0x73593a, 0x0),  \t\t\t// GreatnessY:\n        vec4(0.),\t\t\t\t\t\t\t\t\t\t\t\t// initial color\n        vec4(0.4,0,.4,1)\t\t\t\t\t\t\t\t\t\t// initial value\n    );\n    components[10] = Component(\n        TYPE_LABEL_NUMBER,\n        vec4(-.57,-.4, .7, .0),\t\t\t\t\t\t\t\t\t// position, size\n        ivec4(0x4c657373, 0x6e657373, 0x583a, 0x0),  \t\t\t// LessnessX:\n        vec4(0.),\t\t\t\t\t\t\t\t\t\t\t\t// initial color\n        vec4(-.4,0,.4,1)\t\t\t\t\t\t\t\t\t\t// initial value\n    );\n    components[11] = Component(\n        TYPE_LABEL_NUMBER,\n        vec4(-.57,-.45, .7, .0),\t\t\t\t\t\t\t\t// position, size\n        ivec4(0x4c657373, 0x6e657373, 0x593a, 0x0),  \t\t\t// LessnessY:\n        vec4(0.),\t\t\t\t\t\t\t\t\t\t\t\t// initial color\n        vec4(-.4,0,.4,1)\t\t\t\t\t\t\t\t\t\t// initial value\n    );\n    components[12] = Component(\n        TYPE_LABEL_NUMBER,\n        vec4(-.57,-.35, .7, .0),\t\t\t\t\t\t\t\t// position, size\n        ivec4(0x4670733a, 0x0, 0x0, 0x0),  \t\t\t\t\t\t// Fps:\n        vec4(0.),\t\t\t\t\t\t\t\t\t\t\t\t// initial color\n        vec4(0.0,0,.4,1)\t\t\t\t\t\t\t\t\t\t// initial value\n    );\n\n    \n}\n\n/////////////////////////////////////////////////////////////\n//============= \n//= Interaction \n//============= \n// \n\nbool onPress;\nbool onSamePress;\nbool onEventPress;\nbool onEvent;\n\nvec4   mouse;\nint    frame;\nfloat  time;\nvec3   resolution;\n\nvoid init( vec3 iResolution, int iFrame, float iTime, vec4 iMouse ){\n    initComponents();\n    frame = iFrame;\n    mouse = iMouse;\n    time  = iTime;\n    resolution = iResolution;\n}\n\n/////////////////////////////////////////////////////////////\n//============= \n//= Memory \n//============= \n//\n\nbool normalizeGravity;\nbool normalizeDistance;\nbool normalizeMass;\nbool normalizeInertia;\nbool resetParticules;\n\nvoid loadMemory(sampler2D iChannel0,  vec2 fragCoord){\n    backMouse  = textureBase( iChannel0, LOC_STATE_MOUSE);\n    deltaMouse = textureBase( iChannel0, LOC_STATE_PMOUSE);\n\n    if (frame > 0) // ignore frame 0 \n        for (int i = 0 ; i < componentsLength; i++) {\n            components[i].value = textureBase( iChannel0,  ivec2(MEM_COMPONENTS,i));\n        }\n\n    normalizeGravity  \t= components[0].value.x==1.;\n    normalizeMass\t\t= components[1].value.x==1.;\n    normalizeDistance \t= components[2].value.x==1.;\n    normalizeInertia  \t= components[3].value.x==1.;\n    resetParticules   \t= components[4].value.x==1.;\n}\n\nvoid saveMemory(sampler2D iChannel0, inout vec4 fragColor, vec2 fragCoord){\n    vec2 fc = fragCoord;\n    ivec2 ifc = ivec2(fc);\n    if ( ifc == LOC_STATE_MOUSE ) fragColor = texturePack(mouse);\n    if ( ifc == LOC_STATE_PMOUSE) fragColor = texturePack(mouse-backMouse);\n    if ( ifc.x == MEM_COMPONENTS && ifc.y < componentsLength ) fragColor =  texturePack(components[ifc.y].value);\n}\n\n////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat isClicking(vec2 t, vec2 s, vec2 mouse){\n    return clamp(step(.0, .03 - sdBox(mouse-t, s) ),0.,1. );\n}\n","name":"Common","description":"","type":"common"}]}