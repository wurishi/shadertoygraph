{"ver":"0.1","info":{"id":"wdGczD","date":"1602449366","viewed":126,"name":"Phong+AA+AO+Shadow","username":"emedan","description":"Phong light model. White sphere. Light color is changing.\nAmbient occlusion is distance based.\nAA is just blur. One ray is alwas cast. Only if that hits an object, then 4 more are cast around it and blurs.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ray march - not ray trace - to find object.\n// Ray trace is easier, analytic expression.\n\n// Important to not have ; here.\n#define MAX_STEPS 600\n#define SURF_DIST 0.0001\n#define MAX_DIST 1000.0\n\n#define pi 3.141593\n#define pi2 6.28318530718\n#define pi4 12.5663706144\n\n\n// Camera\n//vec3 ro;\t// Camera position\n\n// Global list to simplify function returns.\nfloat objectDistances[10];\n\n\n// map from to, clamped\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return clamp(min2 + (value - min1) * (max2 - min2) / (max1 - min1), min2, max2);\n}\n\n\n// polynomial smooth min (k = 0.1);\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n\n// Return rotation matrix\nmat3 rotate3dx(float _angle){\n    float c = cos(_angle);\n    float s = sin(_angle);\n    return mat3(\n        1, 0,  0, \n        0, c, -s,\n        0, s,  c\n    );\n}\nmat3 rotate3dy(float _angle){\n\tfloat c = cos(_angle);\n    float s = sin(_angle);\n    return mat3(\n         c, 0, s,\n         0, 1, 0,  \n        -s, 0, c\n    );\n}\nmat3 rotate3dz(float _angle){\n\tfloat c = cos(_angle);\n    float s = sin(_angle);\n    return mat3(\n        c, -s, 0,\n        s,  c, 0,\n        0,  0, 1\n    );\n}\n\n\n// Signed, negative inside object\nfloat SDF_box(vec3 p, vec3 size, float rounding) {\n\tp = abs(p)-size;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0) - rounding;\n}\n\n\n// Signed, negative inside object\nfloat SDF_capsule(vec3 p, vec3 A, vec3 B, float r) {\n    vec3 AB = B-A;\n    vec3 AP = p-A;\n    \n    float t = dot(AB, AP) / dot(AB, AB);\n    t = clamp(t, 0.0, 1.0);\n    \n    //return length(p - (A + t*AB)) - r;\n    float tt = 2.0*abs(0.5 - t);\t// 1 .. 0 .. 1\n    tt = t;\n    return length(p - (A + t*AB)) -r + r*smoothstep(1.0, 0.0, pow(tt, 0.9));\n    \n    float s1 = length(p - (A + t*AB)) - r*smoothstep(1.0, 0.0, tt);\n    float s2 =  length(p - (A + t*AB)) - r*(1.0+1.0*pow((t-0.5), 2.0));\n    float s = 0.5*(1.0+sin(iTime));\n    s = 0.0;\n    return s*s1+(1.0-s)*s2;\n}\n\n\n//Signed, negative inside object.\nfloat SDF_sphere(vec3 p, vec3 c, float r) {\n    return length(p - c) - r;\n}\n\n\n// Get the distance from point p to the closest object of all objects in the scene.\n// Returns: distance, object index\n// Distance can be constrained to selected object.\nfloat GetDist(vec3 p, out int objIndex, in int objConstraint) {\n    // Reusable translation variable.\n    vec3 trans;\n    \n    // Sphere /////////////////////////////////////////\n    //vec4 sphere = vec4(2.*sin(iTime), 0, 10.+6.*cos(iTime), 2);\n    vec4 sphere;\n    sphere = vec4(0, 3, 4, 2.1);\n    float sdf_sphere = SDF_sphere(p, sphere.xyz, sphere.w);\n    //sdf_sphere = abs(sdf_sphere) - 0.05;\t// Shell\n\t///////////////////////////////////////////////////\n    \n    // A sphere above the light to make a lamp\n    float sdf_sphereLight = SDF_sphere(p, vec3(12.*sin(iTime/4.), 13, 12.*cos(iTime/4.) + 6.), 0.8);\n\tsdf_sphereLight = SDF_sphere(p, vec3(0, 15, 0), 0.8);\n    \n    // Capsule ///////////////////////////////////////\n\tvec3 cpA, cpB;\n    float cr;\n    cr = 0.85;\n\n    // Position object before rotating around world origo\n\t// Rotate around origo\n    float xang = iTime*0.6+pi/4.0;\n    float yang = iTime*0.3;\n    float zang = iTime*0.3+pi/3.0;\n    mat3 rot = rotate3dy(yang) * rotate3dx(xang) * rotate3dz(zang);\n    \n    float a = 1.0;\n    float b = 4.0;\n    vec3 cpA1 = vec3(a, 0, 0);\n    vec3 cpB1 = vec3(b, 0, 0);\n    vec3 cpA2 = vec3(-a, 0, 0);\n    vec3 cpB2 = vec3(-b, 0, 0);\n    vec3 cpA3 = vec3(0, a, 0);\n    vec3 cpB3 = vec3(0, b, 0);\n    vec3 cpA4 = vec3(0, -a, 0);\n    vec3 cpB4 = vec3(0, -b, 0);\n    vec3 cpA5 = vec3(0, 0, a);\n    vec3 cpB5 = vec3(0, 0, b);\n    vec3 cpA6 = vec3(0, 0, -a);\t\t\n    vec3 cpB6 = vec3(0, 0, -b);\n    vec3 baseT = vec3(0, 3, 4);\n    cpA1 *= rot;\n    cpB1 *= rot;\n    cpA2 *= rot;\n    cpB2 *= rot;\n    cpA3 *= rot;\n    cpB3 *= rot;\n    cpA4 *= rot;\n    cpB4 *= rot;\n    cpA5 *= rot;\n    cpB5 *= rot;\n    cpA6 *= rot;\n    cpB6 *= rot;\n    cpA1 += baseT;\n    cpB1 += baseT;\n    cpA2 += baseT;\n    cpB2 += baseT;\n    cpA3 += baseT;\n    cpB3 += baseT;\n    cpA4 += baseT;\n    cpB4 += baseT;\n    cpA5 += baseT;\n    cpB5 += baseT;\n    cpA6 += baseT;\n    cpB6 += baseT;\n    \n    \n    ///////////////////////////////////////////////////\n    float sdf_capsule1 = SDF_capsule(p, cpA1, cpB1, cr);\n    float sdf_capsule2 = SDF_capsule(p, cpA2, cpB2, cr);\n    float sdf_capsule3 = SDF_capsule(p, cpA3, cpB3, cr);\n    float sdf_capsule4 = SDF_capsule(p, cpA4, cpB4, cr);\n    float sdf_capsule5 = SDF_capsule(p, cpA5, cpB5, cr);\n    float sdf_capsule6 = SDF_capsule(p, cpA6, cpB6, cr);\n    \n    // Box ////////////////////////////////////////////\n    vec3 boxSize = vec3(0.7);\n    vec3 boxCenter = vec3(-6, 3., 6);\n    float boxRounding = 1.5;\n    float boxThickness = 0.05;\n    vec3 boxPos = p-boxCenter;\n    \n    // Mirror in x. Works because position contains marching point and box sdf function\n    //  is made for box at origo.\n    //boxPos.x = abs(boxPos.x); \n    //boxPos.x -= 4.;\t\t\t\t// Space mirrored out from original pos.\n    \n    float sdf_box = SDF_box(boxPos, boxSize, boxRounding);\n    //sdf_box = abs(sdf_box) - boxThickness;\t// Makes shell with thickness.\n    ///////////////////////////////////////////////////\n    \n    // Floor plane ////////////////////////////////////\n    float sdf_plane = p.y;\t//  flat and at y = 0.\n    sdf_plane = dot(p, normalize(vec3(0, 1, 0 )));\t// Tilt plane\n    sdf_plane += sin(p.x/4. +iTime/4.) /5.;\n    sdf_plane += sin(p.x/2. +iTime/2.) /7.;\n    sdf_plane += sin(p.x    +iTime/1.) /9.;\n\n    sdf_plane += sin(p.z/2. +iTime)    /3.;\n    sdf_plane += sin(p.z    +iTime*3.) /7.;\n    ///////////////////////////////////////////////////\n    \n    // Info about hit object.\n    int objIndexDist = 0;\n    float objLimit = SURF_DIST;\n\n    // Capsules + sphere\n    if      (sdf_capsule1   < objLimit) objIndexDist = 1;\n    else if (sdf_capsule2   < objLimit) objIndexDist = 2;\n    else if (sdf_capsule3   < objLimit) objIndexDist = 3;\n    else if (sdf_capsule4   < objLimit) objIndexDist = 4;\n    else if (sdf_sphere     < objLimit) objIndexDist = 5;\n    else if (sdf_capsule5   < objLimit) objIndexDist = 6;\n    else if (sdf_capsule6   < objLimit) objIndexDist = 7;\n\n    ///////////////////////////////////////////////////    \n    // Copy all distances to a global array\n    objectDistances[0] = sdf_capsule1;\n    objectDistances[1] = sdf_capsule2;\n    objectDistances[2] = sdf_capsule3;\n    objectDistances[3] = sdf_capsule4;\n    objectDistances[4] = sdf_sphere;\n    objectDistances[5] = sdf_capsule5;\n    objectDistances[6] = sdf_capsule6;\n\t    \n    // Return the distance to any object for this position p.\n    // The ray marcher will march until the distance is really small.\n    // Distance functions must be signed, and return negative value inside object.\n    //\n    // abs(object distance) - Creates shell. Distance will increase from edges.\n    //\n    // Using: \n    //  min(d1, d2)  - Ray will stop at closest to either one. Typical usage.\n    //  max(d1, d2)  - Ray point requires both d1 and d2 small. Will get the intersection.\n    //  max(-d1, d2) - Object 1 will cut out object 2.\n    float d = MAX_DIST;\n    \n    \n        \n    // Capsules + sphere\n    d = MAX_DIST;\n    d = min(d, sdf_capsule1);\n    d = min(d, sdf_capsule2);\n    d = min(d, sdf_capsule3);\n    d = min(d, sdf_capsule4);\n    d = min(d, sdf_capsule5);\n    d = min(d, sdf_capsule6);\n    d = min(d, sdf_sphere);\n\n    \n    // With object constraint, only give the distance to the selected object.\n    if (objConstraint > -1) {\n        d = MAX_DIST;\n        if      (objConstraint == 1) d = min(d, sdf_capsule1);\n        else if (objConstraint == 2) d = min(d, sdf_capsule2);\n        else if (objConstraint == 3) d = min(d, sdf_capsule3);\n        else if (objConstraint == 4) d = min(d, sdf_capsule4);\n        else if (objConstraint == 5) d = min(d, sdf_sphere);\n        else if (objConstraint == 6) d = min(d, sdf_capsule5);\n        else if (objConstraint == 7) d = min(d, sdf_capsule6);\n    }\n    \n    objIndex = objIndexDist;\n    return d;\n    //return vec2(d, float(objIndexDist));\n}\n\n\n// Ray march / sphere trace. Walk in ray direction, but the distance of the closest object.\n//  Guarantees to not oveshoot the second closest object.\n// Returns: distance to first hit object, hit object index, iterations\nvoid RayMarch(vec3 ro, vec3 rd, \n              out float dO, out int objIndex, out int iterations) {\n\t\n    // Distance from origin start 0 each loop\n    dO = 0.0;\n    float dS;\n    vec2 distResult;\n    int i;\n    for ( i=0; i<MAX_STEPS; i++ ) {\n        // Point marches along ray direction.\n        vec3 p = ro + dO*rd;\n        \n        // Check if the point is so close to a surface that it's a hit.\n        // GetDist returns (distance, object index)\n        dS = GetDist(p, objIndex, -1);\n        //dS = distResult.x;\n        \n        // March the length of closest distance, but in ray direction.\n        dO += dS; \n        \n        // Exit loop if hit object or too long distance.\n        if (abs(dS) < SURF_DIST || dO > MAX_DIST) {\n        \tbreak;\n        } \n    }\n    \n    //Outputs\n    //dO\n    //objIndex\n    iterations = i;\n    return;\n    //return; vec3(dO, float(objIndex), float(i));\n    //return vec3(dO, float(distResult.y), float(i));\t// Always return distance for when loop was exited.\n    // Return nbr of iterations for glow effect. Iteratons increase for rays passing close to objects. \n}\n\n\n// Approximate normal calculation. Uses GetDist to \"find\" the actual object.\n//  Needs p on object for relevant result.\n// The approximate surface of different objects is used if they are close.\n// Approxmation of normal can be constrained to surface of the object found at point p.\nvec3 GetNormal(vec3 p, bool useObjConstraint) {\n    int objConstraint;\n    int dummy;\n    float d =  GetDist(p, objConstraint, -1);\t// Since p is passed here, the distance to p is likely known.\n\tvec2 eps = vec2(0.01 ,0);\n    \n    if (!useObjConstraint) objConstraint = -1;\n    \n    // Get tangent plane\n    float xd =  GetDist(p + eps.xyy, dummy, objConstraint);\n    \n    float yd = GetDist(p + eps.yxy, dummy, objConstraint);\n    \n    float zd = GetDist(p + eps.yyx, dummy, objConstraint);\n    \n    // Normal?? Detta är väl planet?\n    // Det är normalen. Färglägger man blir planet grönt, dvs y = 1.\n    return normalize( vec3(xd, yd, zd) - d );\n}\n\n\nvec3 PhongLight(vec3 p, int objIndex, vec3 ro) {\n    // Famous because it's a computer efficient approximation.\n    \n\t// For each light source in the scene, components (often in rgb values)\n    //  L_is - intensity of specular component\n    //  L_id - intensity of diffuse component\n    // A single term sum of all ambient\n    //  L_ia - intensity of ambient\n    //\n    // For each material in the scene, the following parameters are defined:\n\t//  M_ks - specular reflection constant, ratio of reflection of the specular term of incoming light,\n\t//  M_kd - diffuse reflection constant, ratio of reflection of the diffuse term of incoming light \n    //         (Lambertian reflectance),\n    //  M_ka - ambient reflection constant, ratio of reflection of the ambient term present \n    //         in all points in the scene rendered.\n    //  M_a  - shininess constant which is larger for surfaces that are smoother \n    //         and more mirror-like. When this constant is large the specular highlight is small.\n        \n    // v_L - which is the direction vector from the point on the surface toward each light source \n    //        (m specifies the light source),\n    // v_N  - which is the normal at this point on the surface,\n    //\n    // v_R - which is the direction that a perfectly reflected ray of light would take from \n    //        this point on the surface\n    // v_V  - which is the direction pointing towards the viewer (such as a virtual camera).\n    \n    // Ip = M_ka * L_ia + \n    //      sum of all ligths:\n    //      M_kd * dot(v_L,v_N) * L_id + \n    //      M_ks * dot(v_R,v_V)^M_a * L_is\n    \n    // v_R = 2 * dot(v_L,v_N) * v_N - v_L\n    \n    \n    // Point light ////////////////////////////////////////\n    vec3 LPos;\n    LPos = vec3(25.0*sin(iTime/4.), 20.0+5.0*pow(cos(iTime/4.), 2.0), 2);\n\tLPos = vec3(10.0, 25, -5);\n    float LPower = 2500.0;\n        \n    // Light distance and intensity falloff\n    float LDist = length(LPos - p);\n    float LI = LPower/pi4/LDist/LDist;\n    \n    // Get normal of point on object.\n    //  Light directly to object, dot = 1. At 90 deg angle, dot = 0.\n    vec3 v_L = normalize(LPos - p);\n    vec3 v_N = GetNormal(p, true);\n    \n    // Light color\n    vec3 v_L_is = vec3(1, 1, 0.6);\t// Skumt att light kan ha specular component.\n    vec3 v_L_id = vec3(1, 1, 1);\n    vec3 v_L_ia = vec3(0.4);\n    \n    // Vary the light color \n    float ph1 = pi2*sin(iTime*0.1);\n    float ph2 = pi2*sin(iTime*0.1+0.3*ph1);\n    v_L_id = vec3(0.5+0.5*sin(iTime), 0.5+0.5*sin(iTime*0.9+ph1), 0.5+0.5*sin(iTime*0.57+ph2));\n    // Vary the light tone\n    v_L_id += 0.5+0.5*sin(iTime*0.5);\n\n    // v_R\n    float dotLN = dot(v_L, v_N);\n    vec3 v_R = normalize( 2.0 * dotLN * v_N - v_L );\n    vec3 v_V = normalize( ro - p );\n    \n    \n    // Get object info /////////////////////////////////////\n    // Material \n    float M_ks = 1.0;\n    float M_kd = 1.0;\n    float M_ka = 0.2;//0.1;\n    float M_a = 4.;\n    \n    vec3 objSpecCol = vec3(1); \n    vec3 objDiffCol = vec3(0); // The object finder did not find an object.\n\n    if (objIndex == 1) { \n        objDiffCol = vec3(1, 0, 0);\n        M_ks = 3.;\n\t    M_a = 4.;\n    }\n    else if (objIndex == 2) { \n        objDiffCol = vec3(0, 1, 0);\n        M_ks = 3.;\n\t    M_a = 8.;\n    }\n    else if (objIndex == 3) {\n\t\tobjDiffCol = vec3(0, 0, 1);\n        M_ks = 3.;\n\t    M_a = 16.;\n    }\n    else if (objIndex == 4) {\n        objDiffCol = vec3(1, 0, 1);\n        M_ks = 3.;\n\t    M_a = 32.;\n    }\n    else if (objIndex == 5) {\t// Sphere\n        objDiffCol = vec3(1, 1, 1);\n        M_ks = 3.;\n\t    M_a = 8.;\n    }\n    else if (objIndex == 6) {\n        objDiffCol = vec3(1, 1, 0);\n        M_ks = 3.;\n\t    M_a = 32.;\n    }\n    else if (objIndex == 7) {\n        objDiffCol = vec3(0, 1, 1);\n        M_ks = 3.;\n\t    M_a = 32.;\n    }\n\n    \n    // Phong output\n    vec3 I_ambient = M_ka * v_L_ia;\n    // Below should be summed for all lights.\n    vec3 I_diffuse = M_kd * max(dotLN, 0.0) * v_L_id;\n    vec3 I_specular = M_ks * pow( max(dot(v_R,v_V), 0.0), M_a ) * v_L_is;\n\n    \n    // Additional shading. Not Phong.\n    // Add ambient occlusion where dot L N is -1, and the diffuse part is already 0.\n    //  This will make the core shadow darker. \n    // Material parameter.\n    float M_da = 0.8;\t// Reduction of ambient light in the shadow.\n    I_ambient *= M_da * (1.0 + clamp(dotLN, -1.0, 0.0));\n    \n    // Add more shadows if no path to light source from point p.  //////////\n    // This causes extra ray march. Approximation.\n    // Go from point towards light. If hit an object first - no light path.\n    //  But start a little bit above the surface of p.\n    // Must shadow a point by its own object or else a strange gradient comes.\n    float dShadowObject;\n    int dummy_iterations;\n    int shadowindex;\n    const float SHADOW_FO = 2.5;\t// Falloff\n    RayMarch(p + 3.0*SURF_DIST*v_N, v_L, \n             dShadowObject, shadowindex, dummy_iterations);\n    bool inShade = dShadowObject < LDist + SURF_DIST;\n    bool selfShade = inShade && shadowindex == objIndex;\n    if (inShade) {\n        // Point is affected by shadow.\n        float sf = clamp(M_da*dShadowObject/SHADOW_FO, 0.0, 1.0);\n        sf = pow(sf, 2.0);\n        I_diffuse *= sf;\n        I_specular *= pow(sf, 1.1);\n    }\n    //if (selfShade) { I_ambient = vec3(1); I_diffuse = vec3(1); } // Debug\n    //if (inShade && !selfShade) { I_ambient = vec3(0); I_diffuse = vec3(0); } // Debug\n    ////////////////////////////////////////////////\n    \n    \n    return objDiffCol * I_ambient + \n           objDiffCol * I_diffuse * LI + \n           objSpecCol * I_specular * LI;\n}\n\n\n// Ambient occlusion affect objects close to each other.\n// It's an simplification. \n//  Don't detect the object intersect edge, but should shadow narrow angles more.\n//  Improve by using normal of the other object. How to get that?\nfloat AO(vec3 p, int objIndex) {\n    // Point p is on the surface of object[objIndex], so the distance to other objects\n    //  will be from this.\n    // But when objects intersect the distance will be wrong - it should be only distances\n    //  to visible parts. Can the GetDist / RayMarch also return p of all other distances, and\n    //  not only the p of the \"found\" object?\n    float ao, ao_sum = 0.0;\t\t\t// 0: No ao at all\n    const int NBR_RODS = 6;\n    const int sphereIndex = 5;\n    const float d_fo = 0.3;\t\t// 0..r Fall off distance\n    const float ao_max = 0.8;\t// 0..1 Maximum amount of ao \n    \n    // Make sure global distance variables are updated. XXX now it starts becoming unnecessary (costly).\n    int dummy_index;\n    GetDist(p, dummy_index, -1);\n    \n    // Point is on the sphere.\n    if (objIndex == sphereIndex) {\n        // Move the rod distances to array for iteration possibility.\n        float rd[NBR_RODS];\n        rd[0] = objectDistances[0];\n        rd[1] = objectDistances[1];\n        rd[2] = objectDistances[2];\n        rd[3] = objectDistances[3];\n        rd[4] = objectDistances[5];\n        rd[5] = objectDistances[6];\n\n        // Shadow depending on the distance to each rod.\n        for (int i = 0; i < NBR_RODS; i++) {\n            // Normalize distance between 0..1\n            float d = clamp(rd[i] / d_fo, 0.0, 1.0);\n            \n            // Calculate ao based on distance function.\n            ao = clamp(pow((1.0-d), 3.0), 0.0, 1.0);\n            //ao = 0.3*d;\n            \n            // Add to existing ao with a reduction factor.\n            ao_sum += clamp(0.75*min(ao, ao_max), 0.0, 1.0);\n        }\n    }\n    else {\n    \t// Point is on a rod.\n        // Normalize distance between 0..1\n        float d = clamp(objectDistances[4] / d_fo, 0.0, 1.0);\n\n        // Calculate ao based on distance function.\n        ao = clamp(pow((1.0-d), 3.0), 0.0, 1.0);\n        //ao = 0.3*d;\n\n        // Add to existing ao with a reduction factor. Will matter when several nearby objects\n        //  contribute to the same occlusion.\n        ao_sum += clamp(0.75*min(ao, ao_max), 0.0, 1.0); \n    }\n    \n    return 1.0 - min(ao_sum, ao_max);\n}\n\n\n// Sky color\nvec3 skyColor(vec2 uv) {\n    // 077b88 = \n    // 9dc6ca = \n\tvec3 col; \n    col = mix(vec3(0.615, 0.776, 0.792), vec3(0.027, 0.482, 0.533), 2.0*sqrt(abs(uv.y)));\n    \n    // Lighten middle, darken out. Multiply with > 1.\n    col *= mix(vec3(2), vec3(1), 2.0*pow(abs(uv.y), 0.25));\n        \n    col = pow( clamp(col,0.0,1.0), vec3(2.2) );\t// Inverse gamma bc sky color was chosen from palette.\n\treturn col;\n}\n\n// Render the point of the ray\n// returns: vec3 color, object index, object distance\nvec3 Render(vec3 ro, vec3 rd, vec2 uv,\n            out int objIndex, out float d) {\n    \n    // Ray march in direction for this uv-coordinate / screen pixel.\n    int raySteps;\n    RayMarch(ro, rd, \n             d, objIndex, raySteps);\t// Returns (distance, object index, ray iterations)\n    \n    // Light and color for the intersected point.\n    // Don't do color calculations if there was no hit.\n    vec3 col = vec3(1);\n    if (d < MAX_DIST) {\n        vec3 p = ro + d*rd;\n        col = PhongLight(p, objIndex, ro);\n\n        // Ambient occlusion \n        col *= AO(p, objIndex);\n\n        // Use the nbr of marched steps for glow.\n        //if (objIndex > 1) {\n        //    float stepF = float(raySteps)/float(MAX_STEPS); \n        //    difCol += (pow(stepF*10., 2.0)*1.);   \n        //}\n\n        // Do not shade the light ball\n        //if (objIndex == 5) col = vec3(1, 1, 0);\n    }\n    else {\n        // Background. Remove anything when marcher did not reach because of distance.\n        col = skyColor(uv);\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Rescale x so a circle looks like a circle, and move to new center.\n    // uv.y: -0.5 .. 0.5\n    // uv.x: ( -0.5 .. 0.5 ) * aspect ratio.\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    // Camera ////////////////////////////////////////////////////////////\n    // Camera ray origin, ray direction, ro, rd\n    // x, y view plane and z is depth.\n    vec3 ro;\n\n    // Camera ray direction - look from origin in the direction of each screen pixel.\n    // XXX - Är det ortogonal view genom att sätta x, y, 1 alltid. Nej...\n\tvec3 rd;\n    \n    // Pixel color for what the ray hit.\n    vec3 col;\n    \n    // Camera ray origin\n    ro = vec3(0, 7, -8);\t\n\n    // Camera ray direction\n    rd = normalize( vec3(uv.x, uv.y-0.3, 1) );\n    //////////////////////////////////////////////////////////////////////\n\n    // Cast original ray\n\tvec2 uvorg = uv;\n            \n    // Render what the ray hits.\n    int objIndex;\n    float dist;\n    col = Render(ro, rd, uvorg,\n          objIndex, dist);  // Color of hit point\n    \n    \n    // Focus blur /////////////////////////////////////\n    float fact;\n    fact = 700.0;\t// Use 700 for good AA.\n\n    float range = 0.5;\n    float fp = 4.5;\n    fact =  clamp(pow(abs(dist-fp), 3.2), 20.0, 700.0);\n    ///////////////////////////////////////////////////\n    \n    \n    // Calculate distance\n    //XXXvec3 p = GetDist();\n    //float centerDist = p.z-ro.z;\t// Orthogonal distance to object from camera.\n    //if (objIndex1 == 0) centerDist = MAX_DIST;\n    \n    // Cast ray\n    // How to calculate backwards from uv into a ray direction?\n    // Seems better than to ray with small angular difference.\n\n    // Anti-aliasing - sample 4 points (or perhaps only affect when point is on object edge).\n    // 4 sample is just blur everywhere.\n    // \n    \n    // Procesing saving algorithm for at least few objects:\n    //  Cast the ray.\n    //  If ray hits an object\n    //    Cast the AA rays.\n    //    Optional:\n    //    Blur only if one or more AA ray does not hit object. Prevents pure object internal blur.\n    //\n    // Rays cast: 1 per \"normal cast\". 5 per normal cast that hits an object.\n    \n    // And AA only on \"edge between objects\" but not \"edges within the same object\"\n    //  Cast the ray\n    //  If ray hits Object obj at Point p:\n    //    Calculate a new point pp that is a small view angle in the normal direction of p\n    //     Point pp distance from p depends on camera and perspective transform.\n    //    Cast a ray towards pp\n    //      If ray does not hit obj:\n    //        Blur color of p with whatever color was found in direction of pp.\n    //\n    // Rays cast: 1 per \"normal cast\". 2 per normal cast that hits an object.\n\n    // AA 2 is 4 passes. Costs.\n    #define AA 2\n    \n    // Mouse top half - no AA\n    // Mouse lower left - fixed blur\n    // Mouse lower right - variable blur.\n    bool useAA = (iMouse.y/iResolution.y < 0.5);\n    \n    // Don't cast additional AA rays unless the first ray hit an object.\n    //useAA = useAA && objIndex > 0;\t// XXX Have to or edge can be missed. Blur avoided by not blurring if all points was on object.\n\n\tvec3 tot = vec3(0.0);\t// Summary of all render passes.\n    int m, n;\n    int samples = 0;\n    bool allPointsOnObject = true;\n    for( m=0; m<AA; m++ ) {\n        for( n=0; n<AA; n++ ) {\n            // How to calculate backwards from uv into a ray direction?\n            // Seems better than to ray with small angular difference.\n            vec2 uvorg = uv;\n            \n            // Create offset for the cast ray.\n            vec2 of = vec2(m, n) - 0.5;\n            of /= fact;\n\t\t\t\n            // Modify camera ray direction a little for each AA pass.\n            rd = normalize( rd + vec3(of.x, of.y, 0) );\n\n            // Render what the ray hits.\n            int objIndexOld = objIndex;\n            float distDummy;\n            vec3 col = Render(ro, rd, uvorg,\n                              objIndex, distDummy);  // Color of hit point\n\n \t\t\t// accumulate for AA\n            tot += col;\n            samples++;\n            allPointsOnObject = allPointsOnObject && objIndexOld == objIndex;\n  \t    }        \n    }\n    if (useAA && true) {//!allPointsOnObject) {\n    \tcol = tot / (float(samples));\n    }\n    \n    //if (dist < 7.5) col*= 0.0;\n            \n\n\n    // hdr->ldr tonemap (iniqo)\n    col = col*1.6/(1.0+col);\n    col = col*col*(3.0-2.0*col);\n\n    // Gamma\n    col = pow( clamp(col,0.0,1.0), vec3(1.0 / 2.2) );\n\n    // Output to screen\n    fragColor = vec4( col, 1.0 );\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}