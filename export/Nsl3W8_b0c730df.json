{"ver":"0.1","info":{"id":"Nsl3W8","date":"1616133818","viewed":66,"name":"redpillbluepill","username":"nvollo","description":"test","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float geo(int i, vec3 coords){\n    \n    if(i==0){\n        vec3 pos = vec3(0.,-1,20.);\n        vec3 q = abs(coords)-pos;\n        return length(max(q-vec3(2.,1.,2.),1.));\n    }\n    \n    //if(i==3) return distance(coords, vec3(sin(iTime)*0.7,cos(iTime)*0.2,sin(iTime)*0.2+3.))-1.;\n    if(i==3) return distance(coords, vec3(sin(iTime+coords.z)*0.5,cos(iTime)*0.2,sin(iTime)*0.2+3.))-1.;\n    if(i==2) return distance(coords, vec3(-sin(iTime+coords.z)*0.5,-cos(iTime)*0.2,sin(iTime)*0.2+3.))-1.;\n    \n    if(i==1) return distance(coords, vec3(-sin(iTime)*0.8,-cos(iTime)*0.2,sin(iTime)*0.2+2.44))-.4;\n    float xx = cos(iTime*4.)*0.03+sin(coords.x)*0.1;\n    float yy = sin(iTime*4.)*0.03;\n    if(i==4) return distance(coords, vec3(-sin(iTime)*0.84+xx,-cos(iTime)*0.2+yy,sin(iTime)*0.2+2.24))-.2;\n    \n    if(i==5) return distance(coords, vec3(sin(iTime)*0.8,cos(iTime)*0.2,sin(iTime)*0.2+2.44))-.4;\n    xx = -cos(iTime*4.)*0.03+sin(coords.x)*0.1;\n    //xx = mod(xx,2.);\n    yy = -sin(iTime*4.)*0.03;\n    if(i==6) return distance(coords, vec3(sin(iTime)*0.84+xx,cos(iTime)*0.2+yy,sin(iTime)*0.2+2.24))-.2;\n    \n}\n\nfloat sdf(vec3 coords){\n    float minimum=1000.;\n    for( int i = 0; i <= 5; i++){\n        minimum = min(minimum,geo(i, coords));\n    }\n    return min(minimum,.1);\n}\nfloat march(vec3 ro, vec3 rd, int limit){\n    float rlen = 0.;\n    for(int i = 0; i < limit; i ++ ){\n        float marchDistance = sdf(ro+(rlen*rd));\n        rlen += marchDistance;\n        if(marchDistance < 0.001){\n            return rlen;\n        }\n    }\n    return rlen;\n}\n\nvec3 getCol(vec3 col, vec3 coord){\n    if(geo(3,coord) < 0.001){\n        col.x += 2.;\n        col += -cos(iTime)*vec3(0.3,.3,.3);\n    }\n    if(geo(2,coord) < 0.01){\n        col *= vec3(1.0,1.0,2.);\n        col += -cos(iTime)*vec3(0.3,.3,.3);\n    }\n    if(geo(0,coord) < 0.01){\n        col += vec3(.01,.3,.3);\n    }\n    \n    if(geo(1,coord) < 0.01){\n        col += vec3(0.3,.3,.3);\n    }\n    \n    if(geo(4,coord) < 0.01){\n        col *= vec3(0.,.0,.8);\n        col -= cos(iTime)*vec3(0.3,.3,.3);\n    }\n    \n    if(geo(5,coord) < 0.01){\n        col += vec3(0.3,.3,.3);\n    }\n    \n    if(geo(6,coord) < 0.01){\n        col *= vec3(0.8,.0,.0);\n        col -= sin(iTime)*vec3(0.3,.3,.3);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv =((2.*fragCoord)-(iResolution.xy))/iResolution.y;\n\n    vec3 ro = vec3(0.,0.,1.);\n    \n    //point from uv image flat plane towards RayOrigin]\n    //ro is just 1 unit deep in z\n    vec3 rd = normalize(vec3(uv,0.)+ro);\n    \n    \n    \n    vec3 col = vec3(1.,0.,1.);// + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    float rlen = march(ro,rd, 100);\n    \n    col *= rlen/2.;\n    col = getCol(col, ro+(rd*rlen));\n    \n    //dont worry be happy\n    if(rlen > 3. && (ro+(rlen*rd)).y < -1.){\n        col += vec3(.2,.2,.2);\n        float rlen = 0.;\n        bool refl = false;\n        for(int i = 0; i < 100; i ++ ){\n            float marchDistance = sdf(ro+(rlen*rd)*.8+vec3(0.,1.,-.2)+.1);\n            rlen += marchDistance;\n            if(marchDistance < 0.001){\n                refl=true;\n                break;\n            }\n        }\n        if(refl){\n            col = (getCol(col,ro+(rd*rlen)*.8+vec3(0.,1.,-.2)+.1)+vec3(5.))*0.09;\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,0.);\n}","name":"Image","description":"","type":"image"}]}