{"ver":"0.1","info":{"id":"stjSzV","date":"1628146904","viewed":91,"name":"MRR_SoftShadow","username":"MiguelRodRic","description":"Casting soft shadows from a raymarched sphere using basic cone tracing","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","softshadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXSTEPS 100\n#define MAXDISTANCE 100.0\n#define HITDISTANCE 0.01\n#define SURFACEOFFSET 0.1\n#define HSHADOWSAMPLES 8\n#define SAMPLINGWEIGHT 0.00390625  \n//SAMPLINGWEIGHT == 1 / (HSHADOWSAMPLES * 2 * HSHADOWSAMPLES * 2)\n#define SHADOWOFFSET 0.015\n\nfloat GetDistanceToSphere(vec3 point, vec3 center, float radius)\n{\n    float distance = length(point - center.xyz) - radius;\n    return distance;\n}\n\nfloat GetDistance(vec3 point)\n{\n    vec4 sphere = vec4(0.0, 1.0, 6.0, 1.0);\n    float planeDistance = point.y; //Plane is axis-aligned with y = 0\n    \n    float sphereDistance = GetDistanceToSphere(point, sphere.xyz, sphere.w);\n    \n    float distance = min(sphereDistance, planeDistance);\n    \n    return distance;\n}\n\nfloat RayMarch(vec3 rOrigin, vec3 rDirection)\n{\n    float distanceFromOrigin = 0.0;\n    \n    for(int i = 0; i < MAXSTEPS; ++i)\n    {\n        vec3 p = rOrigin + rDirection * distanceFromOrigin;\n        float distanceToScene = GetDistance(p);\n        distanceFromOrigin += distanceToScene;\n        \n        if (distanceFromOrigin > MAXDISTANCE || distanceToScene < HITDISTANCE) break;\n    }\n    \n    return distanceFromOrigin;\n}\n\nvec3 GetNormal(vec3 point)\n{\n    float distance = GetDistance(point);\n    vec2 offset = vec2(0.01, 0.0);\n    \n    vec3 normal = distance - vec3(GetDistance(point - offset.xyy), GetDistance(point - offset.yxy),  GetDistance(point - offset.yyx));\n        \n    return  normalize(normal);\n}\n\nfloat GetLight(vec3 point)\n{\n    vec3 lightPosition = vec3(3.0 * sin(iTime), 4.5, 5.0 + cos(iTime) * 3.0);\n    vec3 lightDirection = normalize(lightPosition - point);\n    vec3 surfaceNormal = GetNormal(point);\n    \n    float diffuse = clamp(dot(surfaceNormal, lightDirection), 0.0, 1.0);\n    \n    float shadow = 0.0;\n    \n    //Basic Cone Tracing\n    for (int x = -HSHADOWSAMPLES; x < HSHADOWSAMPLES; ++x)\n    {\n        for (int z = -HSHADOWSAMPLES; z < HSHADOWSAMPLES; ++z)\n        {\n            float shadowRay = RayMarch(point  + (surfaceNormal * SURFACEOFFSET), vec3(lightDirection.x + (float(x) * SHADOWOFFSET), lightDirection.y, lightDirection.z + (float(z) * SHADOWOFFSET)));\n            shadow += float(step(shadowRay, length(lightPosition - point)));\n        }\n    }\n    \n    shadow *= SAMPLINGWEIGHT;\n        \n    diffuse -= shadow * 0.9;\n    \n    return diffuse;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 rOrigin = vec3(0.0, 5.0, 0.0);\n    vec3 rDirection = normalize(vec3(uv.x, uv.y - 0.7, 1.0));\n\n    float d = RayMarch(rOrigin, rDirection);\n\n    vec3 point = rOrigin + rDirection * d;\n    \n    float diffuseLight = GetLight(point);\n    \n    vec3 col = vec3(diffuseLight);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}