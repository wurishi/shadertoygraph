{"ver":"0.1","info":{"id":"ttfczf","date":"1592611699","viewed":107,"name":"very slow line rendering","username":"meteotrix","description":"testing something to replace implicit modeling. deadline coming, can't think about how to optimize x) it's precomputed don't worry.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["linerendering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//from https://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment\nfloat minimum_distance(vec2 v, vec2 w, vec2 p) {  \n  float l2 = distance(v, w)*distance(v, w);\n  if (l2 == 0.0) return distance(p, v);\n   float t = max(0.0, min(1.0, dot(p - v, w - v) / l2));\n   vec2 projection = v + t * (w - v);\n  return distance(p, projection);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= 1.777;\n    uv.x -= 0.38;\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n//#define OLD_VERSION    \n#ifdef OLD_VERSION //cleaned it up a bit but basically this:\n    \n    float distance_to_center = distance(uv.xy, vec2(0.5));\n\tfloat angle_around_center = acos(dot(normalize(uv.xy - vec2(0.5)), vec2(1, 0)));\n\tbool draw = (fract((angle_around_center - 0.02) * 32.0) < 0.25 && distance_to_center > 0.25 && distance_to_center < 0.3);\n\tcol = draw ? vec3(0) : col ;\n    \n#else\n    \n    //create points for lines\n    #define count 36.0  \n    vec2[int(count)] pts_A;\n    vec2[int(count)] pts_B;    \n    for(float p=0.0; p<count; ++p)\n    {\n        float degrees = p * (360.0/count);\n        float rads = (degrees / 180.0) * 3.14159;\n        mat2x2 rotation = mat2x2(cos(rads), -sin(rads), sin(rads), cos(rads));\n        \n        vec2 dir = vec2(1, 0) * rotation;\n        vec2 center = vec2(0.5,0.5);\n        pts_A[int(p)] = center + dir*0.2;\n        pts_B[int(p)] = center + dir*0.5;\n        \n    }\n    \n    \n    //draw lines\n    float line_thickness = 2.0 / iResolution.y;\n    //int samples_per_frag = 1;\n    for(int p=0; p <int(count);++p)\n    {\n        if (minimum_distance(pts_A[p], pts_B[p], uv.xy) < line_thickness) col.rgb = vec3(0.0);\n    }\n    \n#endif\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}