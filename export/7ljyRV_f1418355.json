{"ver":"0.1","info":{"id":"7ljyRV","date":"1671364638","viewed":113,"name":"dancing atom interactive","username":"batersy","description":"A force simulation system playground\nKeyboard Control:\nW/UP to speed up, S/Down to slow down\nUse A/Left and D/Right to turn left or right\nMouse Control:\nclick mouse to place another mass","likes":7,"published":1,"flags":48,"usePreview":0,"tags":["simulation","gravity","force"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * dancing atom interactive\n * Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n * Contact: seplanely@gmail.com\n */\n\n// A force simulation system playground\n// Keyboard Control:\n// W/UP to speed up, S/Down to slow down\n// Use A/Left and D/Right to turn left or right\n// Mouse Control:\n// click mouse to place another mass\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xyz;\n\n    col = pow( col, vec3(0.4545) );\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float Thickness = 0.00005;\nvec2 initPos = vec2(0.8, 0.);\nvec2 initVel = vec2(-1.0, 0.1);\nfloat initSpeed = 0.5;\nvec2 attractorPos = vec2(0,0);\nvec2 extraAttractorPos = vec2(0.4,0);\nfloat borderColor = 0.05;\nfloat maxVel = 6.;\nfloat maxAcc = 50.;\n\nfloat gravityCoefficient = 2.0;\nfloat repulsionCoefficient = 0.5;\nfloat repulsionContinuousCoefficient = 0.01;\nfloat boxCoefficient = 1.0;\nfloat pullCoefficient = 1.0;\nfloat frictionCoefficient = 0.12;\nfloat musicCoefficient = 0.4;\nfloat mouseCoefficient = 1.0;\nfloat randomCoefficient = 6.0;\n\n#define USE_CONTINUOUS_REPUTATION 0\nvec3 drawLine(vec3 color, vec2 ro, vec2 rd, float dis, vec2 p) {\n    vec2 pnew = p - ro;\n    float d = dot(pnew, rd);\n    float lineDis = dot(pnew, pnew) - d * d;\n    if(d > 0. && d < dis && lineDis < Thickness) {\n        return color * smoothstep(1., 0., lineDis / Thickness);\n    }\n    return vec3(0);\n}\n\nvec3 getNearBoxForce(vec2 p, vec4 box, float pad) {\n    float dis = 1.0;\n    ivec2 forceDir = ivec2(0);\n    if(p.x < box.x + pad) {\n        forceDir += ivec2(1,0);\n        dis = min(dis, p.x - box.x);\n    }\n    if(p.x > box.z - pad) {\n        forceDir += ivec2(-1,0);\n        dis = min(dis,  box.z - p.x);\n    }\n    if(p.y < box.y + pad) {\n        forceDir += ivec2(0,1);\n        dis = min(dis, p.y - box.y);\n    }\n    if(p.y > box.w - pad) {\n        forceDir += ivec2(0,-1);\n        dis = min(dis, box.w - p.y);\n    }\n    if(forceDir != ivec2(0)) return vec3(dis, normalize(vec2(forceDir)));\n    return vec3(dis, forceDir);\n}\n\nvec4 checkBorder(vec2 p, vec2 ratio, vec2 mousePos) {\n    vec3 color = vec3(0);\n    int flag = 0;\n    float radius = length(p - attractorPos);\n    if(radius < repulsionAttrDis) {\n        flag = 1;\n        color += borderColor * smoothstep(repulsionAttrDis, repulsionAttrDis - 0.01, radius);\n    }\n    if(mousePos != vec2(0)) {\n        flag = 1;\n        color += borderColor * smoothstep(repulsionAttrDis, repulsionAttrDis - 0.01, length(p - mousePos));\n    }\n    if(p.x < -ratio.x + repulsionBorderDis || p.x > ratio.x - repulsionBorderDis || \n        p.y < -ratio.y + repulsionBorderDis || p.y > ratio.y - repulsionBorderDis) {\n        flag = 1;\n        color += borderColor;\n    }\n    return vec4(flag, color);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord.xy -iResolution.xy) / iResolution.y;\n    vec2 ratio = iResolution.xy / iResolution.y;\n    vec3 color = vec3(0);\n    uint state = uint(fragCoord.x) + uint(fragCoord.y) * uint(iResolution.x) + uint(iFrame) * uint(iResolution.x) * uint(iResolution.y);\n\n    vec2 pos = initPos;\n    vec2 vel = initSpeed * initVel;\n    float t = texelFetch( iChannel0, ivec2(0,1), 0 ).w;\n    if(iFrame > 0) {\n        vec4 mem = texelFetch( iChannel0, ivec2(0), 0 );\n        pos = mem.xy;\n        vel = mem.zw;\n    }\n    float velocity = length(vel);\n    \n    vec4 spect = texture(iChannel2, abs(p) * -1.);\n    vec2 mousePos = extraAttractorPos;\n    if(ivec2(iMouse.xy) != ivec2(0)) {\n        mousePos = (2.0 * iMouse.xy -iResolution.xy) / iResolution.y;\n    }\n    float dt = iTime - t;\n    if(vel != vec2(0)) {\n        vec3 specColor = 0.5 + 0.5*cos(iTime+spect.x * 5.+vec3(0,2,4));\n        color = drawLine(specColor, pos, normalize(vel), length(vel) * dt, p);\n    }\n    if( iFrame!=0 ) {\n        vec4 border = checkBorder(p, ratio, mousePos);\n        if(border.x > 0.) {\n            color += 0.01 * border.yzw;\n        }\n        vec3 lastColor = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xyz;\n        color += lastColor * 0.999;\n    }\n\n    // gravity, when object very close to attractor, replace with an strong repulsion\n    float r = dot(pos - attractorPos, pos - attractorPos);\n    vec2 gravity = (gravityCoefficient + 0.5 * spect.x) / r * normalize(attractorPos - pos);\n#if USE_CONTINUOUS_REPUTATION\n    gravity += (repulsionContinuousCoefficient *(1. + 0.5 * spect.x)) / (r*r) * normalize(pos - attractorPos);\n#else\n    if(r < repulsionAttrDis) gravity = (repulsionCoefficient + 0.5 * spect.x) / r * normalize(pos - attractorPos);\n#endif\n    // pull force\n    float leftPressed = texelFetch(iChannel1, ivec2(KEY_LEFT,0),0 ).x + texelFetch(iChannel1, ivec2(KEY_A,0),0 ).x;\n    float rightPressed = texelFetch(iChannel1, ivec2(KEY_RIGHT,0),0 ).x + texelFetch(iChannel1, ivec2(KEY_D,0),0 ).x;\n    float upPressed = texelFetch(iChannel1, ivec2(KEY_UP,0),0 ).x + texelFetch(iChannel1, ivec2(KEY_W,0),0 ).x;\n    float downPressed = texelFetch(iChannel1, ivec2(KEY_DOWN,0),0 ).x + texelFetch(iChannel1, ivec2(KEY_S,0),0 ).x;\n    vec2 pullDir;\n    if(leftPressed > 0.) {\n        pullDir = vec2(vel.y, -vel.x);\n    } else if(rightPressed > 0.) {\n        pullDir = vec2(-vel.y, vel.x);\n    } else if(upPressed > 0.) {\n        pullDir = vel;\n    } else if(downPressed > 0.) {\n        pullDir = -vel;\n    }\n    vec2 pullForce = pullCoefficient * pullDir;\n    \n    // repulsion near box\n    vec3 nearBox = getNearBoxForce(pos, vec4(-ratio, ratio), repulsionBorderDis);\n    vec2 boxForce = vec2(0);\n    float nearLen = max(repulsionBorderMinDis, nearBox.x);\n    float d = nearLen / repulsionBorderDis;\n    if(nearBox.x < repulsionBorderDis)\n        boxForce = boxCoefficient / (d * d) * velocity * nearBox.yz;\n        // prevent speed get bigger and bigger\n        if(dot(vel, nearBox.yz) > 0.) boxForce *= 0.3;\n    \n    vec2 frictionForce = frictionCoefficient * -vel;\n    vec2 musicForce = musicCoefficient * spect.x * normalize(vel);\n    vec2 mouseForce = vec2(0);\n    mouseForce = -mouseCoefficient * normalize(pos - mousePos) / dot(pos - mousePos, pos - mousePos);\n    float randowStrength = random(0., 1.0, state);\n    randowStrength *= randowStrength;\n    randowStrength *= randowStrength;\n    vec2 randomForce = randomCoefficient * randowStrength * normalize(vec2(random(-1.0, 1.0, state), random(-1.0, 1.0, state)));\n\n    // update new position and velocity\n    vec2 totalForce = gravity + pullForce + boxForce + frictionForce + musicForce + mouseForce + randomForce;\n    vec2 acc = totalForce;\n    if(length(acc) > maxAcc) acc = maxAcc * normalize(acc);\n    vel += acc * dt;\n    if(length(vel) > maxVel) vel = maxVel * normalize(vel);\n    pos += vel * dt;\n    if(ivec2(fragCoord) == ivec2(0)) {\n        fragColor = vec4(pos, vel);\n        return;\n    } else if (ivec2(fragCoord) == ivec2(0, 1)) {\n        fragColor = vec4(0);\n        fragColor.w = iTime;\n        return;\n    }\n\n    fragColor = vec4(color,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// keyboard control\n#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n#define KEY_W 87\n#define KEY_A 65\n#define KEY_S 83\n#define KEY_D 68\n\n#define repulsionAttrDis 0.05\n#define repulsionBorderDis 0.06\n#define repulsionBorderMinDis 0.001\n\n// https://www.pcg-random.org/\nfloat pcg(inout uint state)\n{\n\tstate = state * 747796405u + 2891336453u;\n\tuint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n\treturn float((word >> 22u) ^ word) / float(0xffffffffu);\n}\n\nfloat random(float from, float to, inout uint state) {\n    return from + pcg(state) * (to - from);\n}","name":"Common","description":"","type":"common"}]}