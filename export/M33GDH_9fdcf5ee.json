{"ver":"0.1","info":{"id":"M33GDH","date":"1716409251","viewed":32,"name":"trianglish '24","username":"Hawzen","description":"Triangles ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["triangle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define M_PI 3.14159265358979323846\n\nfloat rand(vec2 co){return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);}\nfloat rand (vec2 co, float l) {return rand(vec2(rand(co), l));}\nfloat rand (vec2 co, float l, float t) {return rand(vec2(rand(co, l), t));}\n\nfloat perlin(vec2 p, float dim, float time) {\n\tvec2 pos = floor(p * dim);\n\tvec2 posx = pos + vec2(1.0, 0.0);\n\tvec2 posy = pos + vec2(0.0, 1.0);\n\tvec2 posxy = pos + vec2(1.0);\n\t\n\tfloat c = rand(pos, dim, time);\n\tfloat cx = rand(posx, dim, time);\n\tfloat cy = rand(posy, dim, time);\n\tfloat cxy = rand(posxy, dim, time);\n\t\n\tvec2 d = fract(p * dim);\n\td = -0.5 * cos(d * M_PI) + 0.5;\n\t\n\tfloat ccx = mix(c, cx, d.x);\n\tfloat cycxy = mix(cy, cxy, d.x);\n\tfloat center = mix(ccx, cycxy, d.y);\n\t\n\treturn center * 2.0 - 1.0;\n}\n\n// p must be normalized!\nfloat perlin(vec2 p, float dim) {\n\t\n\t/*vec2 pos = floor(p * dim);\n\tvec2 posx = pos + vec2(1.0, 0.0);\n\tvec2 posy = pos + vec2(0.0, 1.0);\n\tvec2 posxy = pos + vec2(1.0);\n\t\n\t// For exclusively black/white noise\n\t/*float c = step(rand(pos, dim), 0.5);\n\tfloat cx = step(rand(posx, dim), 0.5);\n\tfloat cy = step(rand(posy, dim), 0.5);\n\tfloat cxy = step(rand(posxy, dim), 0.5);*/\n\t\n\t/*float c = rand(pos, dim);\n\tfloat cx = rand(posx, dim);\n\tfloat cy = rand(posy, dim);\n\tfloat cxy = rand(posxy, dim);\n\t\n\tvec2 d = fract(p * dim);\n\td = -0.5 * cos(d * M_PI) + 0.5;\n\t\n\tfloat ccx = mix(c, cx, d.x);\n\tfloat cycxy = mix(cy, cxy, d.x);\n\tfloat center = mix(ccx, cycxy, d.y);\n\t\n\treturn center * 2.0 - 1.0;*/\n\treturn perlin(p, dim, 0.0);\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  float seed = .1;\n\n\n  vec2 points[3];\n  vec3 colors[3];\n\n  // New: Make the points move with time\n  points[0] = vec2(0., 4.5);\n  points[1] = vec2(3.0, 0);\n  points[2] = vec2(-3.0, 0);\n\n  // Make the color chagne with time in intersting ways and smooth ways\n  colors[0] = vec3(1.0, 0.0, 0.0) * (0.6 + 0.5 * sin(iTime) + 0.7);\n  colors[1] = vec3(0.0, 1.0, 0.0) * (0.5 + 0.7 * cos(iTime + 2.0) + .5);\n  colors[2] = vec3(0.0, 0.0, 1.0) * (0.7 + 1. * tanh(iTime + 2.0)) + .2;\n\n  // Compute distances to the points\n  vec2 uv = (gl_FragCoord.xy / iResolution.xx) * 15. - vec2(7.5, 2.5);\n  int minIndex = 0;\n  float dists[3];\n  for (int i = 0; i < 3; i++) {\n    dists[i] = length(uv - points[i]);\n    if (dists[i] < dists[minIndex]) {\n      minIndex = i;\n    }\n  }\n\n  // Normalize the distances, so that they sum to 1\n  float minDist = min(min(dists[0], dists[1]), dists[2]);\n  float maxDist = max(max(dists[0], dists[1]), dists[2]);\n  float dists_sum = dists[0] + dists[1] + dists[2];\n  dists[0] = dists[0] / dists_sum;\n  dists[1] = dists[1] / dists_sum;\n  dists[2] = dists[2] / dists_sum;\n\n  // Build the color with the 3 colors and the distances\n  vec3 color_no_fade = colors[0] * dists[0] + colors[1] * dists[1] + colors[2] * dists[2];\n\n  // I want contour lines around each point, separated by spaces\n  float contour = 80.0 + iTime * 100.;\n  color_no_fade = mix(color_no_fade, vec3(.0), fract(maxDist * iTime / 5.) + 0.1);   \n\n  // Color the pixel\n  fragColor = vec4(color_no_fade * 1.2, 0.);\n  \n  \n}","name":"Image","description":"","type":"image"}]}