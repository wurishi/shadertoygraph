{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"/*\n\nWritten by Alan Wolfe\nhttp://demofox.org/\nhttp://blog.demofox.org/\n\nWang tiling is a method for creating organic looking images with 2d tiles\n\nMore info on wang tiling:\nhttp://research.microsoft.com/en-us/um/people/cohen/WangFinal.pdf\nhttp://procworld.blogspot.ca/2013/01/introduction-to-wang-tiles.html\n*/\n\n// unscaled tile size\n#define TILE_SIZE 0.15\n\n// used when displaying the individual tiles\n#define TILE_PADDING 0.05\n\n// used when displaying the tile grid\n#define TILE_SCALE 1.5\n#define TILE_SCROLL vec2(0.25, 0.1)*5.0\n\nfloat SDFHorizLine( in vec2 coords )\n{\n    float v = 0.5-coords.y;\n    vec2  g = vec2(0.0,-1.0);\n    return abs(v)/length(g);\n}\n\nfloat SDFVertLine( in vec2 coords )\n{\n    float v = coords.x - 0.5;\n    vec2  g = vec2(1.0,0.0);\n    return abs(v)/length(g);\n}\n\nfloat SDFCircle( in vec2 coords )\n{\n    coords.x -= 0.5;\n    coords.y -= 0.5;\n    float v = coords.x * coords.x + coords.y * coords.y - 0.001;\n    vec2  g = vec2(2.0 * coords.x, 2.0 * coords.y);\n    return v/length(g); \n}\n\nvec3 RenderTilePixel (int leftType, int topType, int rightType, int bottomType, float percentX, float percentY)\n{\n    float col = 1.0;\n    \n    if ((leftType == 1 && percentX < 0.5) ||\n        (rightType == 1 && percentX > 0.5))\n    \tcol = min(col, SDFHorizLine(vec2(percentX,percentY)));\n    \n    if ((topType == 1 && percentY < 0.5) ||\n        (bottomType == 1 && percentY > 0.5))\n    \tcol = min(col, SDFVertLine(vec2(percentX,percentY)));    \n    \n    if (leftType != rightType || topType != bottomType)\n        col = min(col, SDFCircle(vec2(percentX,percentY)));\n    \n    col = smoothstep(0.09,0.11,col);\n    //col = 1.0 - step(col, 0.1);    \n    return mix(vec3(0.125,0.125,0.125),vec3(0,1,0),col);\n}\n\nvec3 RenderAllTiles (vec2 pixel)\n{\n    float tileX = floor(pixel.x / (TILE_SIZE + TILE_PADDING));\n    float tileY = floor(pixel.y / (TILE_SIZE + TILE_PADDING));\n        \n    if (tileX < 0.0 || tileY < 0.0 || tileX > 3.0 || tileY > 3.0)\n        return vec3(0,0,0);\n        \n    float tileOffsetX = pixel.x - tileX * (TILE_SIZE + TILE_PADDING) - TILE_PADDING;\n    float tileOffsetY = pixel.y - tileY * (TILE_SIZE + TILE_PADDING) - TILE_PADDING;\n    \n    if (tileOffsetX < 0.0 || tileOffsetY < 0.0)\n        return vec3(0,0,0);\n    \n    tileOffsetX /= TILE_SIZE;\n    tileOffsetY /= TILE_SIZE;\n    \n    float tile = tileY * 4.0 + tileX;   \n    int leftType = int(mod(tile / 8.0,2.0));\n    int topType = int(mod(tile / 4.0,2.0));\n    int rightType = int(mod(tile / 2.0,2.0));    \n    int bottomType = int(mod(tile,2.0));\n\n    return RenderTilePixel(leftType,topType,rightType,bottomType,tileOffsetX,tileOffsetY);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn texture( iChannel0, (uv+118.4)/256.0, -100.0 ).x;\n}\n\nint CoinFlip (vec2 sampleAt, vec2 seed)\n{\n    return noise(sampleAt / seed) > 0.5 ? 1 : 0;\n}\n\nvec3 RenderScreen(vec2 pixel)\n{    \n    float tileX = floor(pixel.x / TILE_SIZE);\n    float tileY = floor(pixel.y / TILE_SIZE);\n  \n  \tfloat tileOffsetX = fract(pixel.x / TILE_SIZE);\n    float tileOffsetY = fract(pixel.y / TILE_SIZE);\n    \n    // calculate our tile edges, making sure to be coherent with our neighbors!\n    int leftType   = CoinFlip(vec2(tileX-1.0,tileY    ), vec2(0.12,0.37));\n    int rightType  = CoinFlip(vec2(tileX,    tileY    ), vec2(0.12,0.37));\n\tint topType    = CoinFlip(vec2(tileX,    tileY-1.0), vec2(0.41,0.73));\n    int bottomType = CoinFlip(vec2(tileX,    tileY    ), vec2(0.41,0.73));\n\n\t// render the tile pixel!\n    return RenderTilePixel(leftType,topType,rightType,bottomType,tileOffsetX,tileOffsetY);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // calculate our pixel's location in X,Y percent of the resolution of the screen\n    // and apply the aspect ratio to get rid of distortion. Also make y = 0 be at the\n    // top of the screen and center the display\n\tvec2 pixel = fragCoord.xy / iResolution.xy;\n    pixel.y = 1.0 - pixel.y;\n    pixel.y = pixel.y - 0.5 + (TILE_SIZE + TILE_PADDING) * 2.0 + TILE_PADDING * 0.5;\n\n    float aspectRatio = iResolution.x / iResolution.y;\n    pixel.x -= 0.5;\n    pixel.x *= aspectRatio;\n    pixel.x += (TILE_SIZE + TILE_PADDING)*2.0 + TILE_PADDING * 0.5;\n    \n    vec3 color = vec3(0,0,0);\n\tif (iMouse.z > 0.0)\n    {\n    \tcolor = RenderAllTiles(pixel);\n    }\n    else\n    {\n    \tfloat scale = 0.5 + TILE_SCALE * (sin(iTime*0.33) * 0.5 + 0.5);\t\n  \t\tcolor = RenderScreen(pixel*scale + iTime * TILE_SCROLL);\n    }\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MssSWs","date":"1407997781","viewed":1711,"name":"Wang Tiling 2D","username":"demofox","description":"An attempt at procedurally generating wang tiling. I suspect flying through a raymarched something-or-rather infinitely, that used wang tiling to hide the fact that it's tiled might look interesting.  Maybe a more organic set of tiles would be nice too (:","likes":29,"published":1,"flags":0,"usePreview":1,"tags":["2d","tiling","wangtiling"],"hasliked":0,"parentid":"","parentname":""}}