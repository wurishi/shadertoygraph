{"ver":"0.1","info":{"id":"MssyRH","date":"1487194280","viewed":184,"name":"Lights with shadows","username":"SalikSyed","description":"Just a pattern of circles with a rotating light. Needs to be performance tuned.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["circles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define N 5\n#define M 5\n#define K 12\n#define RING_RADIUS 0.04\n#define OBSTACLE_RADIUS 0.004\n#define M_PI 3.1415926535897932384626433832795\n#define DEBUG\n\nvec3 isectCircle(vec2 target, vec2 origin, vec2 sphereCenter, float r, float depth, float max) {\n    vec2 d = target - origin;\n\n    float a = dot(d, d);\n    float b = 2.0 * dot(d, origin - sphereCenter);\n    float c = dot(sphereCenter, sphereCenter) + dot(origin, origin) - 2.0 * dot(sphereCenter, origin) - r*r;\n    float test = b*b - 4.0*a*c;\n\n    bool behind = length(origin - target) < length(origin - sphereCenter);\n    \n\tif (test >= 0.0 && !behind) {\n  \t\tfloat u = (-b - sqrt(test)) / (2.0 * a);\n  \t    vec2 hitp = origin + u * (target - origin);\n        \n        vec2 offset = (sphereCenter - origin);\n        vec2 ray_dir = normalize(target-origin);\n        float b = dot(ray_dir, offset);\n        float c = dot(offset, offset) - r;\n        float disc = b*b - c;\n    \tfloat disr = sqrt(disc);\n    \tfloat factor = clamp(depth*0.15/disr, 0.15, max);\n        \n        if (length(hitp.xy - target) > length(target - origin)) {\n            return vec3(-1.0,0.0,.0); \n        }\n        if (depth < 0.0) {\n            return vec3(1.0, hitp);\n        } else {\n            \n        \treturn vec3(factor, hitp);\n        }\n    } else {\n        return vec3(-1.0,0.0,.0);   \n    }\n}\n\n\n// Computes a light bloom amount for a given light position\nfloat light_bloom(vec2 light_pos, float light_rad, float dist)\n{\n    // Apply an inverse square fall-off model\n    return light_rad/(180.0*dist+1.0);\n}\n\n\nfloat samplef(vec2 pt, vec2 lightPos) {\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    float h = 1.0;\n    float w = aspectRatio;\n\n\n    float encloseR = RING_RADIUS;\n    float encloserRadius = OBSTACLE_RADIUS;\n    float spacingX = (w / (float(N) + 1.0));\n    float spacingY = h / (float(M) + 1.0);\n    float darkness = 0.0;\n    float num = 0.0;\n    float dist = length(pt - lightPos);\n    bool found = false;\n    float factor = 1.0;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) { \n            // check if the ray from pt->lightPos intersects the outer group of circles:\n            vec2 center = vec2(spacingX * (float(i) + 1.0), spacingY * (float(j) + 1.0));\n            bool insideEncloser = length(pt - center) < encloserRadius + encloseR ;\n            if (!insideEncloser && isectCircle(lightPos, pt, center, encloserRadius + encloseR, -1.0, -1.0).x < 0.0) {\n                continue;\n            } else {\n                // intersects one of the enclosing cylinders\n                for(int k = 0; k < K; k++) {\n                    float theta = M_PI * 2.0 * float(k)/ float(K);\n                    float x = center.x + cos(theta) * encloseR;\n                    float y = center.y + sin(theta) * encloseR;\n                    vec2 encloser = vec2(x,y);\n                    vec3 isect = isectCircle(lightPos, pt, encloser, encloserRadius, dist, factor);\n                    if (isect.x > 0.0) {\n                        found = true;\n\t\t\t\t\t\tfactor = isect.x;\n                        if (factor <= 0.15) {\n                         \tbreak;   \n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (found) {\n     \treturn factor * light_bloom(lightPos, .5, dist); \n    } else {\n        return light_bloom(lightPos, .5, dist); \n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    float h = 1.0;\n    float w = aspectRatio;\n\n    vec2 uv = vec2(fragCoord.x / iResolution.x * aspectRatio, fragCoord.y / iResolution.y); \n\n    float encloseR = RING_RADIUS;\n    float encloserRadius = OBSTACLE_RADIUS;\n    float spacingX = (w / (float(N) + 1.0));\n    float spacingY = h / (float(M) + 1.0);\n    float x = 0.0;\n    float y = 0.0;\n    vec2 lightPos = vec2(aspectRatio/2.0 + sin(iTime)*0.1, 0.5+ cos(iTime)*0.1);\n    \n    #ifdef DEBUG\n    if (length(lightPos - uv) < encloseR) {\n     \t   //fragColor = vec4(1.0);\n           //return;\n    }\n\n\tvec3 color = vec3(0.48, 0.55, 0.57);\n    color += clamp(step(mod(uv.x, 45.0),1.0) + step(mod(uv.y, 45.0),1.0), 0.0, 0.055);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) { \n            // compute the center of the diagram\n            vec2 center = vec2(spacingX * (float(i) + 1.0), spacingY * (float(j) + 1.0));\n            \n    \t\tvec2 offsetVec = vec2(sin(iTime)*0.06, 0.06);\n    \t\tcolor += vec3(1.0, 0.7, 0.4) * samplef(uv, center + offsetVec);\n    \n\t\n            \n            if (length(uv - center) > encloserRadius + encloseR) {\n                continue;\n                return;\n            } else {\n                // intersects one of the enclosing 24 cylinders\n                for(int k = 0; k < K; k++) {\n                    float theta = M_PI * 2.0 * float(k)/ float(K);\n                    x = center.x + cos(theta) * encloseR;\n                    y = center.y + sin(theta) * encloseR;\n                    vec2 encloser = vec2(x,y);\n                    if (length(uv - encloser) < encloserRadius) {\n                        fragColor = vec4(0.85,0.87,0.84, 1.0);\n                    \treturn;\n                    }\n                    \n                }   \n            }\n        }\n    }\n    #endif\n    \n\n\n    fragColor = vec4(color, 1.0);\n\n\n}","name":"Image","description":"","type":"image"}]}