{"ver":"0.1","info":{"id":"DlXXDj","date":"1675355284","viewed":118,"name":"Schrödinger Eq. Stable","username":"weasel","description":"Simulation of the Schrödinger equation for a one particle field. The default potential (shown in blue) is a diffractiion grid. Particles can be spawned with left-click. The shown intensity is log(p) where p is the probability density.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["physics","quantum","wavefunction","qm","schrdinger"],"hasliked":0,"parentid":"DsX3Rr","parentname":"Schrödinger Eq."},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Look at \"Common\" shader tab for an explanation\n\n// this tab just contains the visual representation.\n// see below for an option to see the phase.\n\nPOTENTIAL\n\nfloat smoothstep2(float x) {\n    float x_ = clamp(x, 0.0, 1.0);\n    return cos((x_-0.5)*2.0*3.1415926)*0.5+0.5;\n}\n\nfloat contour_lines(float V, float stepsize) {\n    float Vd = length(vec2(dFdx(V), dFdy(V)));\n    return smoothstep2((mod(V/stepsize+10.0, 1.0)/(Vd+1e-6))*.03) * min(1.0, Vd*iResolution.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 value = psi(fragCoord);\n    vec2 V = potential(fragCoord);\n    vec4 V_rings = vec4(0., 0., contour_lines(V.x, 0.1), 0.);\n    float q = value.r;\n    \n    // change this to 1 to see the phase!\n#if 0\n    fragColor = mix(vec4(1.,0.,0.,1.), vec4(0.,0.,1.,1.), (sign(q)+1.0)*0.5) * abs(q) * 10.0 + V_rings;\n#else\n    float p = value.g;\n    float psi_sqr = q*q + p*p;\n    fragColor = vec4(vec3(max(0.0, 1.0+0.1*log(psi_sqr))), 1.0) + V_rings;\n#endif\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"LAPLACE\nPOTENTIAL\nTIMESTEP_IMAG\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 value = timestep(fragCoord); // only the Im part\n    if (iMouse.z > 0.0) {\n        float d = length(fragCoord - iMouse.xy);\n        float size = 40.;\n        const float fac = 4.0;\n        //value = d < size ? vec4(1.0,0.0,0.0,1.0) : value;\n        vec2 dir = normalize(vec2(sign(iMouse.x - iResolution.x/2.0), 0.0));\n        float phase = dot(fragCoord - iMouse.xy, dir)*.77;\n        value = d < size ? vec4(cos(phase),sin(phase+0.07),0.0,1.0) * (exp(-fac*d*d/(size*size)) - exp(-fac)) : value;\n    }\n    if (iFrame == 0) {\n        value = vec4(0., 0., 0., 1.);\n    }\n#ifdef PLANE_WAVE\n    const int frames = 30;\n    if (fragCoord.x <= 16.0) {\n        // TODO the plane wave strength here should be choosen a bit more carefully\n        value = vec4(cexp(vec2(1.0-potential(fragCoord).x, -3.1415*2.0 / float(frames) * float(iFrame % frames))), 0.0, 1.0);\n        if (iFrame < 100) {\n            value *= float(iFrame) / 100.0;\n        }\n    }\n#endif\n#ifdef OPEN_BORDERS\n    if (fragCoord.x <= 16.0) {\n        value *= exp((fragCoord.x - 16.0)*0.015);\n    }\n    if (iResolution.x - fragCoord.x <= 16.0) {\n        value *= exp((iResolution.x - fragCoord.x - 16.0)*0.015);\n    }\n    if (fragCoord.y <= 16.0) {\n        value *= exp((fragCoord.y - 16.0)*0.015);\n    }\n    if (iResolution.y - fragCoord.y <= 16.0) {\n        value *= exp((iResolution.y - fragCoord.y - 16.0)*0.015);\n    }\n#endif\n    fragColor = value;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Field is structured as (r,g,b,a)=(Re(psi), Im(psi), 0, 1)\n// The Equation is\n// i*h d/dt |psi(t)> = H |psi(t)>\n// where H = p^2/(2m) + V(x) = -h^2/(2m)*laplace(psi(x,t)) + V(x)\n// so we simplify set h = point distance for the laplacian and get\n// H|psi(x,t)> = -1/(2m) * (4*psi(x,t)-psi(x+(1,0),t)-psi(x-(1,0),t)-psi(x+(0,1),t)-psi(x-(0,1),t))\n//\n// the differential equation can be solved using\n//\n// psi(t+dt) = exp(-i H dt/h) |psi(t)>\n//\n// which for small steps is:\n//\n// d_psi(t) = psi(t+dt)-psi(t) = (exp(-i H dt/h) - 1) |psi(t)>\n//          = (-i H dt/h + O(dt^2)) |psi(t)>\n//\n// however this euler method is unstable, instead use a symplectic integrator for\n//\n// d/dt Re(psi(t)) =  Im(H |psi(t)>)/h\n// d/dt Im(psi(t)) = -Re(H |psi(t)>)/h\n//\n// with this better method there are still numerical errors, which cause some diffusion effects\n// but for reasonable values for dt and mass, the simulation is at least stable.\n//\n// the problems remains, that the potential V(x) needs to be small, because otherwise\n// the phase will oscillate quicker than the integrator can handle.\n// To adress that, the potential is handled in an extra step, using the exact solution with a\n// complex exponential.\n\n// to get rid of the h, we define dt in units of h\n#define dt 0.24\n#define mass 0.5\n\n// switches to enable different setups\n//#define OPEN_BORDERS\n//#define PLANE_WAVE\n\n// complex exponential\nvec2 cexp(vec2 c) {\n    return exp(c.x)*vec2(cos(c.y), sin(c.y));\n}\n\n// complex multiplication\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\n// complex conjugation\nvec2 conj(vec2 c) { return vec2(c.x, -c.y); }\n\n// complex division\nvec2 cdiv(vec2 a, vec2 b) {\n    return cmul(a, conj(b)) / dot(b, b);\n}\n\n// multiplication with i*hbar (hbar = 1)\nvec2 ih(vec2 c) { return vec2(-c.y, c.x); }\n\n// complex/real magnitude squared\nfloat sqr(float x) { return x*x; }\nfloat sqr(vec2 x) { return dot(x,x); }\n\n#define psi(pos) (texture(iChannel0, abs(pos)/iResolution.xy).rg)\n\n#define LAPLACE \\\nvec2 laplace_psi(vec2 pos, vec2 psi_) {\\\n    vec2 smpl1 = psi(pos + vec2(0,1));\\\n    vec2 smpl2 = psi(pos + vec2(0,-1));\\\n    vec2 smpl3 = psi(pos + vec2(1,0));\\\n    vec2 smpl4 = psi(pos + vec2(-1,0));\\\n    return 4.*psi_ - smpl1 - smpl2 - smpl3 - smpl4;\\\n}\n\n#define TIMESTEP_REAL \\\nvec4 timestep(vec2 pos) {\\\n    vec2 psi_ = psi(pos);\\\n    vec2 lapl = laplace_psi(pos, psi_) / (2.0*mass);\\\n    psi_ -= ih(-lapl) * vec2(dt, 0);\\\n    psi_ = cmul(psi_, cexp(-ih(0.5*dt * potential(pos))));\\\n    return vec4(psi_.r, psi_.g, 0., 1.);\\\n}\n\n#define TIMESTEP_IMAG \\\nvec4 timestep(vec2 pos) {\\\n    vec2 psi_ = psi(pos);\\\n    vec2 lapl = laplace_psi(pos, psi_) / (2.0*mass);\\\n    psi_ -= ih(-lapl) * vec2(0, dt);\\\n    psi_ = cmul(psi_, cexp(-ih(0.5*dt * potential(pos))));\\\n    return vec4(psi_.r, psi_.g, 0., 1.);\\\n}\n\n// this defines the potential V(x), to make the simulation stable, this must be smooth,\n// however the absolute value doesn't matter.\n\n// no potential\n//#define POTENTIAL vec2 potential(vec2 pos) { return vec2(0.0, 0.0); }\n\n// double slit\n//#define POTENTIAL vec2 potential(vec2 pos) { return vec2(1.0, -1.0) * 2.0 * smoothstep(max(0.0, 10.0-abs(pos.x - iResolution.x/2.0))*sqr(1.0-sqr(pos.y-iResolution.y/2.0)*0.001), 0.0, 1.0); }\n\n// ion\n//#define POTENTIAL vec2 potential(vec2 pos) { return vec2(1.0-0.0005/max(0.0005, sqr(length(pos-iResolution.xy/2.0)/iResolution.x)), 0.0); }\n\n// grid\n#define POTENTIAL vec2 potential(vec2 pos) { return vec2(0.5, -0.1) * smoothstep(max(0.0, 10.0-abs(pos.x - iResolution.x/2.0))*(sqr(cos(pos.y*0.2))), 0.0, 1.0); }\n\n// wall\n//#define POTENTIAL vec2 potential(vec2 pos) { return vec2(smoothstep(pos.x - iResolution.x/2.0, 1.0, 0.0), 0.0); }\n\n// harmonic well\n//#define POTENTIAL vec2 potential(vec2 pos) { return vec2(clamp(1.0 - sqr(length(pos-iResolution.xy/2.0)/iResolution.x)*10.0, 0.0, 1.0), 0.0); }\n\n// lens (curved wall)\n//#define POTENTIAL vec2 potential(vec2 pos) { return vec2(smoothstep(0.125*(pos.x - iResolution.x/2.0 - 0.0003*sqr(pos.y-iResolution.y/2.0)), 0.0, 0.1), 0.0); }\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"LAPLACE\nPOTENTIAL\nTIMESTEP_REAL\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 value = timestep(fragCoord); // only the Re part\n    if (iFrame == 0) {\n        value = vec4(0., 0., 0., 1.);\n    }\n    fragColor = value;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"LAPLACE\nPOTENTIAL\nTIMESTEP_IMAG\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 value = timestep(fragCoord); // only the Im part\n    if (iFrame == 0) {\n        value = vec4(0., 0., 0., 1.);\n    }\n    fragColor = value;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"LAPLACE\nPOTENTIAL\nTIMESTEP_REAL\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 value = timestep(fragCoord); // only the Re part\n    if (iFrame == 0) {\n        value = vec4(0., 0., 0., 1.);\n    }\n    fragColor = value;\n}","name":"Buffer D","description":"","type":"buffer"}]}