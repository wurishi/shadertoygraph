{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"//Starbattle by codesorc@gmail.com\n//First attempt hacking procedural effects, mixing different procedural shaders to create space battle. \n//background is tweaked Kali Starnest http://glsl.herokuapp.com/e#14485.0\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define iterations 15\n#define formuparam 0.340\n\n#define volsteps 12\n#define stepsize 0.110\n\n#define zoom 1.0\n#define tile 0.750\n#define speed 2.\n\n#define brightness 0.0019\n#define darkmatter 0.400\n#define distfading 0.960\n#define saturation 1.7\n#define PI 3.1415\n\n#define SHADERTOY\n#ifdef SHADERTOY\n  #define time iTime\n  #define resolution iResolution\n#else\n  uniform float time;\n  uniform vec2 resolution;\n#endif\n\n\nfloat sat(float v){\n  return clamp(v,0.,1.);\n}\n\nvec3 nrand3( vec2 co )\n{\n    vec3 a = fract( cos( co.x*8.3e-3 + co.y )*vec3(1.3e5, 4.7e5, 2.9e5) );\n    vec3 b = fract( sin( co.x*0.3e-3 + co.y )*vec3(8.1e5, 1.0e5, 0.1e5) );\n    vec3 c = mix(a, b, 0.5);\n    return c;\n}\n\n\nfloat permutation(float index) {\n\treturn mod(index * index, 257.0);\n}\n\nvec3 gradient(float index) {\n\n\tindex = mod(index * index, 251.0);\n\t\n\tfloat angleAroundZ = mod(index, 16.0) * (2.0 * PI / 16.0);\n\tfloat angleAroundY = floor(index / 16.0) * (2.0 * PI / 16.0);\n\t\n\tvec3 gradient = vec3(cos(angleAroundZ), sin(angleAroundZ), 0.0);\n\tvec3 rotatedGradient;\n\trotatedGradient.x = gradient.x * cos(angleAroundY);\n\trotatedGradient.y = gradient.y;\n\trotatedGradient.z = gradient.x * sin(angleAroundY);\n\t\n\treturn rotatedGradient;\n}\n\nfloat hermit3D(vec3 position) {\n\tvec3 square = position * position;\n\tvec3 cube = square * position;\n\treturn (3.0*square.x - 2.0*cube.x) * (3.0*square.y - 2.0*cube.y) * (3.0*square.z - 2.0*cube.z);\n}\n\nmat2 makem2(in float theta){float c = cos(theta);float s = sin(theta);return mat2(c,-s,s,c);}\n\n\nmat2 m2 = mat2( 0.80, 0.60, -0.60, 0.80 );\n\n\nfloat perlinNoise3D(int gridWidth, int gridHeight, int gridDepth, vec3 position) {\n\t\n\t// Takes input position in the interval [0, 1] in all axes, outputs noise in the range [0, 1].\n\tvec3 gridDimensions = vec3(gridWidth, gridHeight, gridDepth);\n\tposition *= gridDimensions;\n\t\n\t// Get corners,\n\tvec3 lowerBoundPosition = floor(position);\n\t\n\t// Calculate gradient values!\n\tfloat gradientValues[8];\n\tfor (float z=0.0; z<2.0; z++) {\n\t\tfor (float y=0.0; y<2.0; y++) {\n\t\t\tfor (float x=0.0; x<2.0; x++) {\n\t\t\t\tvec3 currentPointPosition = lowerBoundPosition + vec3(x, y, z);\n\t\t\t\t\n\t\t\t\tvec3 displacementVector = (currentPointPosition - position);\n\t\t\t\tvec3 gradientVector = gradient(mod(currentPointPosition.x + permutation(mod(currentPointPosition.y + permutation(currentPointPosition.z), 256.0)), 256.0));\n\t\t\t\t\n\t\t\t\tgradientValues[int((z*4.0) + (y*2.0) + x)] = (0.0 + dot(gradientVector, displacementVector)) * 2.0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t\n\t// Interpolate using Hermit,\n\tvec3 interpolationRatio = position - lowerBoundPosition;\n\tfloat finalNoise = 0.0;\n\tfinalNoise += gradientValues[7] * hermit3D(interpolationRatio);\n\tfinalNoise += gradientValues[6] * hermit3D(vec3(1.0 - interpolationRatio.x, interpolationRatio.y, interpolationRatio.z));\n\tfinalNoise += gradientValues[5] * hermit3D(vec3( interpolationRatio.x, 1.0 - interpolationRatio.y, interpolationRatio.z));\n\tfinalNoise += gradientValues[4] * hermit3D(vec3(1.0 - interpolationRatio.x, 1.0 - interpolationRatio.y, interpolationRatio.z));\n\t\n\tfinalNoise += gradientValues[3] * hermit3D(vec3( interpolationRatio.x, interpolationRatio.y, 1.0 - interpolationRatio.z));\n\tfinalNoise += gradientValues[2] * hermit3D(vec3(1.0 - interpolationRatio.x, interpolationRatio.y, 1.0 - interpolationRatio.z));\n\tfinalNoise += gradientValues[1] * hermit3D(vec3( interpolationRatio.x, 1.0 - interpolationRatio.y, 1.0 - interpolationRatio.z));\n\tfinalNoise += gradientValues[0] * hermit3D(vec3(1.0 - interpolationRatio.x, 1.0 - interpolationRatio.y, 1.0 - interpolationRatio.z));\n\t\n\t\n\t\n\treturn finalNoise;\n}\n\n\nfloat fbm( in vec2 p )\n{\n\tfloat z=2.;\n\tfloat rz = 0.;\n\tfor (float i= 1.;i < 7.;i++ )\n\t{\n\t\trz+= abs((perlinNoise3D(1,1,1,vec3(p,0.5))-0.5)*2.)/z;\n\t\tz = z*2.;\n\t\tp = p*2.;\n\t\tp*= m2;\n\t}\n\treturn rz;\n}\n\n\nvec3 hsv(float h,float s,float v) {\nreturn mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n\nvec2 rotate(vec2 p, float a)\n{\n    return vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));\n}\n\n// 1D random numbers\nfloat rand(float n)\n{\n    return fract(sin(n) * 43758.5453123);\n}\n\n// 2D random numbers\nvec2 rand2(in vec2 p,float t)\n{\n    return fract(vec2(sin(p.x * 591.32 + p.y * 154.077 + t), cos(p.x * 391.32 + p.y * 49.077 + t)));\n}\n\n// 1D noise\nfloat noise1(float p)\n{\n    float fl = floor(p);\n    float fc = fract(p);\n    return mix(rand(fl), rand(fl + 1.0), fc);\n}\n\n// voronoi distance noise, based on iq's articles\nfloat voronoi(in vec2 x,float t)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    \n    vec2 res = vec2(8.0);\n    for(int j = -1; j <= 1; j ++)\n    {\n        for(int i = -1; i <= 1; i ++)\n        {\n            vec2 b = vec2(i, j);\n            vec2 r = vec2(b) - f + rand2(p + b,t);\n            \n            // chebyshev distance, one of many ways to do this\n            float d = sqrt(abs(r.x*r.x) + abs(r.y*r.y));\n            \n            if(d < res.x)\n            {\n                res.y = res.x;\n                res.x = d;\n            }\n            else if(d < res.y)\n            {\n                res.y = d;\n            }\n        }\n    }\n    return res.y - res.x;\n}\n\nvec3 worly_star_base(vec2 pos,vec2 uv,vec2 suv,float r,float t,vec3 col){\n    float flicker = noise1(time * 2.0) * 0.8 + 0.4;\n    float v = 0.0;\n    \n    v = 1.0 - length(uv-pos.xy)/r;\n    float a = 0.16, f = 12.0;\n    \n    for(int i = 0; i < 4; i ++)\n    {    \n        float v1 = voronoi(uv * f + 5.0,t);\n        float v2 = 0.0;\n \n        if(i > 0)\n        {\n            // of course everything based on voronoi\n            v2 = voronoi(uv * f * 0.5 + 50.0 + t,t);\n            \n            float va = 0.0, vb = 0.0;\n            va = 1.0 - smoothstep(0.0, 0.1, v1);\n            vb = 1.0 - smoothstep(0.0, 0.08, v2);\n            v += a * pow(va * (0.5 + vb), 2.0);\n        }\n        \n        // make sharp edges\n        v1 = 1.0 - smoothstep(0.0, 0.3, v1);\n        \n        // noise is used as intensity map\n        v2 = a * (noise1(v1 * 0.5 + 0.1));\n        \n        // octave 0's intensity changes a bit\n        if(i == 0)\n            v += v2 * flicker;\n        else\n            v += v2;\n        \n        f *= 3.0;\n        a *= 0.7;\n    }\n\n    // slight vignetting\n    v *= exp(-0.6 * length(suv)) * 1.2;\n    \n    // old blueish color set\n    vec3 cexp = col;vec3(1.0, 2.0, 4.0);\n        cexp *= 1.3;\n\n    col = pow( vec3(max(v,0.0)), cexp ) * 8.0;\n    \n    return col;\n}\n\n\nvec3 worly_star(vec2 pos,vec2 uv,vec2 suv,float r,float t){\n    return worly_star_base(pos,uv,suv,r,t,vec3(1.0, 2.0, 4.0));\n}\n\nvec3 worly_star_blue(vec2 pos,vec2 uv,vec2 suv,float r,float t){\n   return worly_star_base(pos,uv,suv,r,t,vec3(2.0, 1.0, 1.0));\n}\n\nvec4 eye(vec2 pos,vec2 pointPosition,float sphereRadius){\n  float noise = 0.0;\n  vec3 noisePoint = vec3(pointPosition.xy,-(time*0.16));\n  noise +=         abs(perlinNoise3D(4, 4, 4, noisePoint));\n  noise += 0.500 * abs(perlinNoise3D(8, 8, 8, noisePoint));\n  noise += 0.250 * abs(perlinNoise3D(16, 16, 16, noisePoint));\n  noise += 0.125 * abs(perlinNoise3D(32, 32, 32, noisePoint));\n  noise += 0.0625 * abs(perlinNoise3D(64, 64, 64, noisePoint));\n\t    \n  float radius = length(pointPosition) - 1.0*sphereRadius;\n  radius /= sphereRadius * 0.3;\n  float phase = clamp(radius + 1.0*noise, 0.0, 0.5*PI);\n  radius = sin(phase);\n  \n  vec4 color;\n  color = mix(vec4(0.8, 0.95, 0.2, 1.0), vec4(1.0, 0.1, 0.0, 1.0), radius)*(noise-0.2)* 2.*(1.0 - radius);\n  color*=5.*pow(smoothstep(0.0,1.0,2.0*length(pos)),0.85);\n  vec3 col=clamp(worly_star(pointPosition,pos,pos,0.1,time),0.,1.);\n  col=clamp(col,0.,1.);\n  color=color;\n  color=clamp(color,0.,1.);\n  color+=vec4(col,1.);\n  return clamp(color,0.,1.);\n}\n\n\n\nvec3 something(vec2 uv,vec3 obj_pos, vec2 fragCoord){\n  \tvec3 v=vec3(0.);\n\tfloat noise = 0.0;\n\tvec3 pointPosition=vec3(uv,length(uv.xy))*4.;\n;\n\tfloat sr=0.05;\n\tfloat radius = length(pointPosition-obj_pos) - 1.0*sr;\n\tfloat phase = clamp(+1.*noise, 0.0, 0.5*PI);\n\tradius = sin(phase);\n\n\t\n\tconst float kNumParts=7.0;\n\tfor(float part=0.0;part<kNumParts;part+=1.0){\n\t\tfloat ang=2.0*3.14*(part/(kNumParts))+time*4.0;\n\t\tvec2 dxy=vec2(cos(ang),sin(ang))*0.01;\n\t\tfloat mag=(1.0 / exp(pow(600.0 * length(uv-obj_pos.xy-dxy), 0.5)));\n\t\tvec3 c=vec3(mag,mag,0.);\n\t\tv+=2.*c;\n\t}\n\t\n\tfloat tau = 3.1415926535*2.0;\n\tfloat ang = atan(uv.x-obj_pos.x,uv.y-obj_pos.y)-time*1.9;\n\tfloat d = abs(length(uv-obj_pos.xy)-0.025);\n\t\n\t\n\t\n\tv.b-=0.4;\n\tvec2 xy=fragCoord.xy/resolution.xy;\n\tv+=0.5*hsv((ang+0.5)/3.14/2.0,1.0,1.0)*pow(cos(clamp(d*5.0,-3.14*0.6,3.14*0.15)),2000.0);//*(1.0+sin(ang+pow(time,0.1)*10.))*(1.0+sin(d+time*3.));\n\treturn clamp(v,0.,1.);\n}\n\n/*\n*fireball thingy\n*/\nfloat snoise(vec3 uv, float res)\n{\n  const vec3 s = vec3(1e0, 1e2, 1e3);\n  \n  uv *= res;\n  \n  vec3 uv0 = floor(mod(uv, res))*s;\n  vec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\n  \n  vec3 f = fract(uv); f = f*f*(3.0-2.0*f);\n\n  vec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n              uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\n  vec4 r = fract(sin(v*1e-1)*1e3);\n  float r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n  \n  r = fract(sin((v + uv1.z - uv0.z)*1e-1)*1e3);\n  float r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n  \n  return mix(r0, r1, f.z)*2.-1.;\n}\n\nfloat fireball_mono(vec2 p,float t){\n  float color = 3.0 - (3.*length(2.*p));\n  \n  vec3 coord = vec3(atan(p.x,p.y)/6.2832+.5, length(p)*.4, .5);\n  \n  for(int i = 1; i <=4; i++)\n  {\n    float power = pow(2.0, float(i));\n    color += (1.5 / power) * snoise(coord + vec3(0.,-t*.05, t*.01), power*16.);\n  }\n  return color;\n}\n\nvec3 fireball(vec2 p,float t,vec3 pos,float r){\n        float color=fireball_mono((p-pos.xy)/r,t);\n  return clamp(vec3(color, pow(max(color,0.),2.)*0.4, pow(max(color,0.),3.)*0.15),0.,1.);\n}\n\n/*\n*end fireball thingy\n*/\n\n/*\n*start rocket\n*/\nvec3 flame_rocket(vec2 uv,vec2 pos,float r,vec2 dir,vec2 rdir){\n  //TODO change this mess with better flame eye noise, thought not sure if it works well on small details\n  vec3 v;\n  float flame=0.;\n  float a=atan(dir.x,rdir.y);\n  float nx=cos(a)*(uv.x-pos.x)-sin(a)*(uv.y-pos.y);\n  float ny=sin(a)*(uv.x-pos.x)+cos(a)*(uv.y-pos.y);\n  \n  vec2 uv2=vec2(nx,ny)/r;\n  uv2.x*=4.;\n  float octaves=0.;\n  float t=time*8.;\n  octaves+=perlinNoise3D(1,1,1,vec3(uv2*128.,t));\n  octaves+=perlinNoise3D(1,1,1,vec3(uv2*64.,t))*2.;\n  octaves+=perlinNoise3D(1,1,1,vec3(uv2*32.,t))*4.;\n  octaves+=perlinNoise3D(1,1,1,vec3(uv2*16.,t))*8.;\n  octaves+=perlinNoise3D(1,1,1,vec3(uv2*8.,t))*10.;\n  flame+=0.00175*octaves;\n    \n  v=vec3( sat(100.*((0.5-abs(uv2.x)+flame)-0.5*(uv2.y+0.5))) ) ;\n  v*=sat(100.*(2.*flame+ 0.2-abs(uv2.y)));\n  \n  v*=mix(vec3(1.,1.0,0.),vec3(1.,0.2,0.),sat(((uv2.y+0.2)*2.)*2.))*(perlinNoise3D(1,1,1,vec3(uv2*16.,t*4.))+1.)*2.;\n  v*=1./(1.+length(uv)*10.);\n  return clamp(v,0.,1.);\n}\n/*\n*end rocket\n*/\n\n/*\n*star laser\n*/\n    \nfloat laser(vec2 uv,vec2 laser_start,vec2 laser_end,float laser_radius){\nlaser_radius*=0.3;\n  float laser_len=distance(laser_end,laser_start);\n  vec2 laser_normal=normalize(laser_end-laser_start);\n  float t=dot(laser_normal,uv-laser_start)/laser_len;\n  float d=pow(distance(laser_start+laser_normal*laser_len*t,uv),1.);\n  float d2=laser_len*float(t<0.)*pow(-t,2.0)+float(t>1.0)*pow(t-1.,2.);\n  float d3=sqrt(d*d+d2*d2);\n  return laser_radius/pow(d3,1.0); \n}\n/*\n*end laser\n*/\n\nvec3 starnest(vec2 uv){\n  vec3 v=vec3(0.4);\n  vec3 dir=vec3(uv*zoom,1.);\n  float a1=0.18;\n  float a2=2.;\n  mat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n  mat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n  dir.xz*=rot1;\n  dir.xy*=rot2;\n  vec3 from=vec3(0.,0.,0.);\n  from+=vec3(.1*time+0.1*sin(time),.120*time-0.1*cos(time*0.1),2.+0.010*time);\n  float s=.05,fade=.0377;\n  float frequencyVariation=0.5;\n  for (int r=0; r<volsteps; r++) {\n    vec3 p=from+s*dir*1.5;\n    p = abs(vec3(frequencyVariation) - mod(p, vec3(frequencyVariation * 2.0)));\n\n    p.x+=float(r*r)*0.01;\n    p.y+=float(r)*0.02;\n    float pa,a=pa=0.;\n    for (int i=0; i<iterations; i++){\n      p=abs(p)/dot(p,p)-formuparam;\n      a+=abs(length(p)-pa*0.1);\n      pa=length(p);\n    }\n    a*=pow(a,2.750)*1.; // add contrast\n    v+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n    fade*=distfading; // distance fading\n    s+=stepsize;\n  }\n  v=pow(v,vec3(1.05));\n  v=mix(vec3(length(v)),v,saturation); //color adjust\n  v=v*0.005;\n  return v;\n}\n\n\nfloat noise2D(vec2 uv)\n{\n    uv = fract(uv)*1e3;\n    vec2 f = fract(uv);\n    uv = floor(uv);\n    float v = uv.x+uv.y*1e3;\n    vec4 r = vec4(v, v+1., v+1e3, v+1e3+1.);\n    r = fract(1e5*sin(r*1e-2));\n    f = f*f*(3.0-2.0*f);\n    return (mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y));    \n}\n\nfloat fractal(vec2 p) {\n    float v = 0.5;\n    v += noise2D(p*16.); v*=.5;\n    v += noise2D(p*8.); v*=.5;\n    v += noise2D(p*4.); v*=.5;\n    v += noise2D(p*2.); v*=.5;\n    v += noise2D(p*1.); v*=.5;\n    return v;\n}\n\nvec3 func( vec2  p,float t) {\n    p = p*.1+.5;\n    vec3 c = vec3(.0, .0, .1);\n    vec2 d = vec2(t*.0001, 0.);\n    c = mix(c, vec3(.8, .1, .1), pow(fractal(p*.20-d), 3.)*2.);\n    c = mix(c, vec3(.9, .6, .6), pow(fractal(p.y*p*.10+d)*1.3, 3.));\n    c = mix(c, vec3(1., 1., 1.), pow(fractal(p.y*p*.05+d*2.)*1.2, 1.5));\n    return c;\n}\n\nvec4 planet(vec2 uv,vec3 pos,float r,float t){\n    vec2 p=(uv-pos.xy)*1./r;\n    vec3 n;\n    n.xy=p;\n    n.z=sqrt(1.-(p.x*p.x+p.y*p.y));\n    n=normalize(n);\n    vec3 l=normalize(vec3(-uv,0.));\n    \n\t\n    float d = length(p);\n    p *= (acos(d) - 1.57079632)/d;    \n    vec3 v;\n    v=func(p,t*8.)*max(1.-d*d*d, 0.);\n    \n\n    v=2.*clamp(v,0.,1.)*(vec3(1.0,0.6,0.)*sat(dot(n,l))+0.25);\n    v+=vec3(1.,0.8,0.6)*sat(pow(1.-abs(n.z),1.5));\n    \n    return vec4(v,length(uv-pos.xy)/r);\n}\n\nvec3 draw_planets(vec2 uv,vec3 v,vec3 planet_to_be_attacked_position,float planet_to_be_attacked_radius){\n  vec4 red_planet=planet(uv,planet_to_be_attacked_position,planet_to_be_attacked_radius,time);\n  red_planet.xyz-=0.3;\n  float is_planet=sat(pow(sat(1.-sat(red_planet.w*0.5-0.3)),1.))*sat((length(red_planet)-0.10)*1000.) ;\n  return clamp(3.*red_planet.xyz,0.,1.)*is_planet+v*(1.-is_planet);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=fragCoord.xy/resolution.xy-.5;\n  uv.y*=resolution.y/resolution.x;\n  vec3 v=starnest(uv);\n\n  vec3 planet_to_be_attacked_position=vec3(cos(time*0.6),sin(time*0.6),0.)*0.25;  \n  float planet_to_be_attacked_radius=.05;\n  v+=draw_planets(uv,v,planet_to_be_attacked_position,planet_to_be_attacked_radius);\n\t\n  v+=clamp(0.2*worly_star(vec2(0.0),uv,uv,0.2,time),0.,1.);\n\n  \n  vec3 attacker_1_position_at_shot_time=vec3(-0.15,0.1,0.);\n  vec3 attacker_1_pos=attacker_1_position_at_shot_time+vec3(sin(time)*0.1,sin(time*0.5)*0.2,0.);\n  vec3 obj=something(uv,attacker_1_pos, fragCoord);\n  \n   \n  #define NUM_FIREBALLS 2\n  for(int i=0;i<NUM_FIREBALLS;i++){\n    vec2 dxy=nrand3(vec2(float(i)*5.,0.5)).xy-0.5;\n    vec3 dir_fireball=normalize(planet_to_be_attacked_position-attacker_1_pos)+vec3(0.8*dxy,0.);\n    float dist_fireball=(length(planet_to_be_attacked_position-attacker_1_pos)-planet_to_be_attacked_radius*0.5);\n    float rocket_offset=float(i)*0.5;\n    vec3 fireball_traectory=dir_fireball*dist_fireball*sin(mod(time*1.1+rocket_offset,3.14159*0.5));\n    vec3 fireball_pos=attacker_1_pos+fireball_traectory;\n    v+=fireball(uv,time*4.,fireball_pos,0.035+0.155*pow(clamp(sin(mod(time*1.1+rocket_offset,3.14159*0.5))-0.9,0.,1.),0.25));\n  }\n\n  #define NUM_GUIDED_ROCKETS 7\n  for(int i=0;i<NUM_GUIDED_ROCKETS;i++){\n    vec2 dir=(attacker_1_pos-planet_to_be_attacked_position).xy;    \n    vec2 ndir=normalize(dir);\n    vec2 left_dir=vec2(-ndir.y,ndir.x);//90 ccw rotate\n    float dist=length(dir);\n    float sin_amp=(nrand3(vec2(float(i)*160.,0.5)).x-0.5)*0.7;\n    sin_amp+=0.1*abs(sin_amp)/sin_amp;\n    sin_amp*=8.*dist;\n    float t=mod(time*0.5+float(i)*0.24,1.);\n    t=pow(t,float(i)*2.250/float(NUM_GUIDED_ROCKETS));\n    //vec2 rocket_pos_t0=planet_to_be_attacked_position.xy;\n    vec2 rocket_pos=planet_to_be_attacked_position.xy+0.87*(ndir*dist+left_dir*sin_amp*sin(pow(t,0.25)*3.14159))*t;\n    vec2 rocket_pos_next=planet_to_be_attacked_position.xy+0.87*(ndir*dist+left_dir*sin_amp*sin(pow((t+0.01),0.25)*3.14159))*(t+0.01);\n    vec2 dir_d_rocket_pos=normalize(rocket_pos_next-rocket_pos);\n    v+=3.*flame_rocket(uv,rocket_pos.xy,0.075,ndir,dir_d_rocket_pos);\n    v+=fireball(uv,time*4.,vec3(rocket_pos,0.),0.015+0.155*pow(clamp(sin(t-0.87),0.,1.),0.25));      \n    float laser_attack_time=sat(mod(time*0.05,1.)-0.90);\n    vec2 laser_target_xy=attacker_1_pos.xy+(planet_to_be_attacked_position.xy-attacker_1_pos.xy)*sat(1.*laser_attack_time)*0.7;\n    v+=vec3(0.5,1.,0.1)*laser(uv,planet_to_be_attacked_position.xy,laser_target_xy.xy,0.002)*sat(10.*laser_attack_time);\n  }\n  \n  v+=clamp(eye(uv-attacker_1_pos.xy,uv,0.075).rgb,0.,1.);\n  v+=clamp(0.2*worly_star_blue(attacker_1_pos.xy,uv,uv,0.1,time),0.,1.);\n  \n  fragColor = vec4(v,1.);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sSXRt","date":"1414660848","viewed":2389,"name":"StarBattle","username":"CodeMaster","description":"Mixing different procedural effects to create  space battle.","likes":47,"published":1,"flags":0,"usePreview":1,"tags":["star","space","planet","rocket","battle","fireball","worly"],"hasliked":0,"parentid":"","parentname":""}}