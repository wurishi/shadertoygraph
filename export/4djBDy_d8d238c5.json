{"ver":"0.1","info":{"id":"4djBDy","date":"1502018939","viewed":187,"name":"RayCastSphere multipass","username":"diroru","description":"A 2-pass version of [url=http://www.shadertoy.com/view/XdjBDG]RayCastSphere[/url] (here used for normal map generation), with minor algorithm improvements. Work in progress.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["raycasting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 lightDir = normalize(vec3(1.0, 0.0, 0.0));\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec2 inc = vec2(1.0) / iResolution.xy;\n    //info: lat, lon, depth, alpha;\n    vec4 info = texture(iChannel0, uv);\n    //vec3 v00 = vec3(0.0, 0.0, info.z);\n    //vec3 v10 = vec3(vec2(inc.x, 0.0), texture(iChannel0, uv + vec2(inc.x, 0.0)).z);\n    //vec3 v01 = vec3(vec2(0.0, inc.y), texture(iChannel0, uv + vec2(0.0, inc.y)).z);\n    \n    vec3 v00 = info.xyz;\n    vec3 v10 = texture(iChannel0, uv + vec2(inc.x, 0.0)).xyz;\n    vec3 v01 = texture(iChannel0, uv + vec2(0.0, inc.y)).xyz;\n\t\n    vec3 n = normalize(cross(normalize(v10 - v00), normalize(v01 - v00)));\n    \n    //fragColor = texture(iChannel0, uv);\n    if (length(info) == 0.0) {\n    \tfragColor = vec4(0.2);\n    } else {\n        //fragColor = info*0.002;\n        //fragColor = vec4(texture(iChannel1, info.st).rgb,info.a);\n        fragColor = vec4(n*0.5 + vec3(0.5),info.a);\n        //fragColor = vec4(texture(iChannel1, info.st).rgb*dot(lightDir,n),1.0);\n        //fragColor = vec4(vec3(dot(lightDir,n)),1.0);\n\t\t//fragColor = texture(iChannel2, n);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159265359\n#define STEP_SIZE 0.002 //a lower value produces better results but requires more computation\n#define STEP_DECAY 1.002\n\nvec3 getEyeVec(vec2 xy, vec3 eyeOrigin) {\n  return normalize(vec3(xy,0) - eyeOrigin);\n}\n\nfloat angleBetween(vec3 a, vec3 b) {\n    //TODO: signed version\n    return acos(dot(a, b) / length(a) / length(b));\n}\n\n//source: https://math.stackexchange.com/questions/1830695/how-to-rotate-a-3d-vector-on-the-surface-of-a-plane-by-a-known-angle\nvec3 rotateInPlane(vec3 v, vec3 n, float theta) {\n    return cos(theta)*v + sin(theta)*cross(n, v);\n}\n\nvec3 getIntersectionCandidate(vec3 sphereOrigin, vec3 eyeOrigin, vec3 eyeVec, float angleInc) {\n\tvec3 eyeSphere = eyeOrigin-sphereOrigin;\n    float theta = angleBetween(eyeSphere, eyeVec)*angleInc;\n    //normal of the plane defined by the eye origin, sphere origin and the eye vector\n    vec3 n = normalize(cross(eyeSphere, eyeVec));\n    return normalize(rotateInPlane(eyeSphere, n, theta));\n}\n\n//same as getIntersectionCandidate() but uses linear steps\n//opposed to radial ones\nvec4 getISCLinear(vec3 sphereOrigin, vec3 eyeOrigin, vec3 eyeVec, float maxDist, float inc) {\n    vec3 eyeAxis = eyeOrigin - sphereOrigin; //could be cached as uniform\n    float maxLength = maxDist + length(eyeAxis); //the local max is less, but not sure if it's worth calculating\n    vec3 d = eyeAxis + normalize(eyeVec)*maxLength*inc;\n    return vec4(d,length(d));\n}\n\n\n//we have a triangle formed by three vectors, with only one known side\n//and would like to determine (the lenght of) one of the unknown sides (belonging to vector c)\n//in other words a + mu * b + lambda * c = 0\n//mu and lambda are unknown scalars\n//lambda is what we are looking for\n//c should be normalized\nfloat getDistanceToRay(vec3 a, vec3 b, vec3 c) {\n    //TODO: check for corner cases!?\n    return (a.x*b.y*b.z - 0.5*a.y*b.x*b.z - 0.5*a.z*b.x*b.y)/(c.x*b.y*b.z - 0.5*c.y*b.x*b.z - 0.5*c.z*b.x*b.y);\n}\n\nfloat map(float value, float low1, float high1, float low2, float high2) {\n\treturn low2 + (value - low1) * (high2 - low2) / (high1 - low1);\n}\n\nvec2 xyzToLatLon(vec3 v) {\n    vec3 p = normalize(v);\n    float lat = map(asin(p.z),-PI*0.5, PI*0.5, 0.0, 1.0);\n    float lon = map(atan(p.y, p.x), -PI, PI, 0.0, 1.0);\n    return vec2(lat, lon);\n}\n\nvec3 xRot(vec3 v, float theta) {\n  float x = v.x;\n  float y = v.y*cos(theta) - v.z*sin(theta);\n  float z = v.y*sin(theta) + v.z*cos(theta);\n  return vec3(x,y,z);\n}\n\nvec3 yRot(vec3 v, float theta) {\n  float x = v.z*sin(theta) + v.x*cos(theta);\n  float y = v.y;\n  float z = v.z*cos(theta) - v.x*sin(theta);\n  return vec3(x,y,z);\n}\n\nvec3 zRot(vec3 v, float theta) {\n  float x = v.x*cos(theta) - v.y*sin(theta);\n  float y = v.x*sin(theta) + v.y*cos(theta);\n  float z = v.z;\n  return vec3(x,y,z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //GLOBALS\n    float width = iResolution.x;\n    float height =  iResolution.y;\n    float fov_h = PI / 3.0;\n\tfloat eyeZ = -width / 2.0 / tan(fov_h*0.5);\n\tvec3 eyeOrigin = vec3(width*0.5, height*0.5, eyeZ);\n\tfloat fov_v = atan(height*0.5, eyeZ)*2.0;\n\n    vec3 sphereOrigin = vec3(iMouse.xy, 0.0);\n    float sphereRadius = 200.0;\n    float maxDisplacement = -100.0;\n    vec3 eyeVec = getEyeVec(fragCoord.xy, eyeOrigin);\n    vec3 eyeSphere = eyeOrigin-sphereOrigin;\n    \n    //DEBUG\n    float theta_limit = asin(sphereRadius/length(eyeSphere));\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    //fragColor = vec4(eyeVec(fragCoord.xy, eyeOrigin),1.0);\n\tfragColor = vec4(0.0);\n    float step = STEP_SIZE;\n    for (float i=0.0; i<1.0; i = i + step) {\n    \t//vec3 isc = getIntersectionCandidate(sphereOrigin, eyeOrigin, eyeVec, i);\n        //float d =  getDistanceToRay(eyeSphere, eyeVec, isc);\n        vec4 isc = getISCLinear(sphereOrigin, eyeOrigin, eyeVec, sphereRadius+abs(maxDisplacement), i);\n        float d =  isc.w;\n        vec3 isc_r = xRot(yRot(isc.xyz, iTime*0.5),iTime*0.1);\n        vec2 latlon = xyzToLatLon(isc_r);\n        //vec2 latlon = xyzToLatLon(isc.xyz)+ vec2(iTime*0.00,iTime*0.01);\n        float displacement = texture(iChannel0, latlon).r*maxDisplacement;\n        //displacement = 0.0;\n        if (d <= sphereRadius + displacement && d > 0.0) {\n            //fragColor = vec4(latlon, 0.0, 1.0);\n            //fragColor = texture(iChannel0, latlon);\n            //fragColor = vec4(latlon, (sphereOrigin + isc_r*d).z, 1.0);\n            //DEBUG\n            //fragColor = vec4(sphereOrigin + isc*d, 1.0);\n            fragColor = vec4(isc.xyz*d, 1.0);\n            break;\n        }\n        step = step*STEP_DECAY;\n    }\n    \n    //DEBUG\n    //if (angleBetween(-eyeSphere, eyeVec) < theta_limit) {\n    //    fragColor += vec4(0.0, 1.0, 0.0, 0.5);\n    //}\n}","name":"Buf A","description":"","type":"buffer"}]}