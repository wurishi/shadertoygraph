{"ver":"0.1","info":{"id":"3lKyDz","date":"1610826558","viewed":69,"name":"Bienvenue dans la 4ème dimension","username":"Akanoa","description":"Opération booléenne dynamique sur des shères en raymarching avec applications de textures et d'ombrage","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["debutant"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MIN_DISTANCE   0.001\n#define MAX_DISTANCE   20.\n#define MAX_ITERATIONS 200\n\n\n#define MATERIAL_RED   1  \n#define MATERIAL_BLUE  2\n#define MATERIAL_GREEN 3\n#define MATERIAL_YELLOW 4\n\n\n/**\n* m : index du matériau à appliquer\n* d : distance à la surface observée\n*/\nstruct Data {\n    float d;\n    int m;\n};\n\n\n/**\n* Calcul la distance signée en entre le point p et la surface de la sphère\n* p : point courant calculé par rapport à la sphère\n* c : coordonnées du centre de la sphère\n* r : rayon de la sphère\n* m : matériau à appliquer sur la surface de la sphère\n*/\nData sdSphere(vec3 p, vec3 c, float r, int m) {\n    return Data(length(p - c) - r, m);\n}\n\n/**\n* Calcule la distance signée entre le point p et la surface du plan de hauteur h\n* p : point courant calculé par rapport à la sphère\n* h : hauteur du plan par rapport à l'origine du monde\n* m : matériau à appliquer sur la surface du plan\n*/\nData sdPlanH(vec3 p, float h, int m) {\n    return Data(p.y - h, m);\n}\n\nData sdBox(vec3 p, vec3 b, int m) {\n    vec3 q = abs(p) - b;\n    float d = min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0));\n    return Data(d, m);\n}\n\nData sdTorus(vec3 p, vec2 t, int m) {\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    float d = length(q)-t.y;\n    return Data(d, m);\n}\n\nData minData(Data d1, Data d2) {\n    \n    if(d1.d < d2.d) {\n        return d1;\n    }\n    return d2; \n}\n\nData maxData(Data d1, Data d2) {\n    \n    if(d1.d > d2.d) {\n        return d1;\n    }\n    return d2; \n}\n\nData minusData(Data d) {\n    return Data(-d.d, d.m);\n}\n\nData scene(vec3 p) {\n    \n    Data s1 = sdSphere(p, vec3(0.5*cos(iTime), 0, 1.7), 0.7, MATERIAL_RED);\n    Data s2 = sdSphere(p, vec3(cos(iTime), 0, 1.2), 0.2, MATERIAL_GREEN);\n    Data s3 = sdSphere(p, vec3(cos(0.9*iTime), 0, 1.2), 0.3, MATERIAL_BLUE);\n    \n    Data b = sdBox(p - vec3(0, max(0.0,0.5*sin(0.5*iTime)), 1), vec3(1, 2, 500)*.1, MATERIAL_YELLOW);\n    \n    Data pl = sdPlanH(p, -0.2, MATERIAL_BLUE);\n    \n    Data s = maxData(minusData(s2), s1);\n    \n    Data donut = sdTorus(p - vec3(0,0,1), vec2(0.25, 0.1), MATERIAL_GREEN);\n  \n    s = maxData(minusData(s3), s);\n    s = maxData(minusData(b), s);\n    s = minData(s, pl);\n    s = minData(donut, s);\n    \n    return s;\n}\n\nData rayMarch(vec3 rO, vec3 rD) {\n    \n    float d = 0.0;\n    int m = 0;\n    for(int i=0; i < MAX_ITERATIONS; i++) {\n        \n        vec3 p =  rO + rD * d;\n        Data ds =  scene(p);\n        d += ds.d;\n        m = ds.m;\n        if (ds.d < MIN_DISTANCE || d > MAX_DISTANCE) break;\n    }\n    \n    return Data(d, m);\n\n}\n\n\nvec3 material(int index) {\n    switch(index) {\n        case MATERIAL_RED:\n            return vec3(1.0, 0, 0);\n        case MATERIAL_GREEN:\n            return vec3(0, 1.0, 0);\n        case MATERIAL_BLUE:\n            return vec3(0, 0, 1.0);\n        case MATERIAL_YELLOW:\n            return vec3(1.0, 1.0, 0);\n        default:\n            return vec3(0);\n    }\n        \n}\n\nvec3 normal(vec3 p) {\n    float dp = scene(p).d;\n    \n    float eps = 0.01;\n    \n    float dx = scene(p + vec3(eps, 0, 0)).d - dp;\n    float dy = scene(p + vec3(0, eps, 0)).d - dp;\n    float dz = scene(p + vec3(0, 0, eps)).d - dp;\n    \n    return normalize(vec3(dx, dy, dz));\n}\n\n\nfloat lighting(vec3 p, vec3 n, vec3 lp) {\n    \n    vec3 ld = lp - p;\n    vec3 ln = normalize(ld);\n    \n    float d = rayMarch(p + n * 0.01, ln).d;\n    \n    if (d < length(ld)) return 0.0;\n    \n    return max(0.0, dot(ln, n));\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5* iResolution.xy) / iResolution.y;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    \n    float k = 1.;\n    vec3 lp = vec3(k*cos(iTime), 1, k*sin(iTime));\n    \n    \n    vec3 camera = vec3(0, mouse.y, 0);\n    vec3 screen = vec3(uv, 1.0);\n    \n    vec3 rD = normalize(screen - camera);\n    \n    Data data =  rayMarch(camera, rD);\n    \n    vec3 col = vec3(0);\n    \n    if(data.d < MAX_DISTANCE) {\n    \n       vec3 p = camera + rD * data.d;\n       vec3 n = normal(p);\n       float l = lighting(p, n, lp);\n       \n       vec3 m = material(data.m);\n       \n       col = m * l;\n       col = pow(col, vec3(0.4545));\n       \n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}