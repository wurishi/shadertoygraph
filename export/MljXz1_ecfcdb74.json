{"ver":"0.1","info":{"id":"MljXz1","date":"1441778347","viewed":365,"name":"Waveland","username":"ddsol","description":"based on Sculpture II https://www.shadertoy.com/view/4ssSRX#\nnoise from https://github.com/ashima/webgl-noise/blob/master/src/classicnoise3D.glsl","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","noise","distancefield","perlinnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// Created by inigo quilez - iq/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//#define USE_GRADIENTS\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n//==========================================================================\n\nvec4 texCube( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n    vec3 w = pow( abs(n), vec3(k) );\n\treturn (x*w.x + y*w.y + z*w.z) / (w.x+w.y+w.z);\n}\n\nfloat rand2(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand3(vec3 co){\n    return fract(sin(dot(vec2(rand2(co.xy), rand2(co.xz)) ,vec2(12.9897,78.243))) * 44758.5453);\n}\n\nvec4 map2( vec3 p )\n{\n    float v = 2.0;\n    float wiggle = iTime * 0.05;\n    \n    //p.z += cnoise(p*2.0)*0.1;\n    \n    p.x += 0.5*sin( v*p.y + wiggle );\n    p.y += 0.5*sin( v*p.z + wiggle );\n    p.z += 0.5*sin( v*p.x + wiggle );\n    p.x += 0.5*sin( v*p.y + wiggle );\n    p.y += 0.5*sin( v*p.z + wiggle );\n    p.z += 0.5*sin( v*p.x + wiggle );\n    p.x += 0.5*sin( v*p.y + wiggle );\n    p.y += 0.5*sin( v*p.z + wiggle );\n    p.z += 0.5*sin( v*p.x + wiggle );\n    p.x += 0.5*sin( v*p.y + wiggle );\n    p.y += 0.5*sin( v*p.z + wiggle );\n    p.z += 0.5*sin( v*p.x + wiggle );\n\n    \n    p.z += cnoise(p*10.0)*0.1;\n    \n    float d1 = length(p) - 1.0*smoothstep(0.0,2.0,iTime);;\n    d1 *= 0.02;\t\n\n    return vec4( d1, p );\n}\n\nvec4 map( vec3 p )\n{\n    //vec4 res = (map2(p) + map2(p+vec3(0.01)))/2.0;\n    vec4 res = map2(p);\n    \n    \n    \n    float d2 = p.y - 0.5;\n    if( d2<res.x ) res = mix(res, vec4( d2, 0.0, 0.0, 0.0 ), smoothstep(0.0, 1.0, -d2*0.1));\n    \n    \n\n\treturn res;\n}\n\nvec4 intersect( in vec3 ro, in vec3 rd, in float maxd )\n{\n    vec3 res = vec3(-1.0);\n\tfloat precis = 0.00005;\n    float t = 1.0;\n    for( int i=0; i<512; i++ )\n    {\n\t    vec4 tmp = map( ro+rd*t );\n        res = tmp.yzw;\n        float h = tmp.x;\n        if( h<precis||t>maxd ) break;\n        t += h;\n    }\n\n    return vec4( t, res );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n#ifdef USE_GRADIENTS    \n    return normalize( cross(dFdx(pos),dFdy(pos)) );\n#else    \n    vec2 e = vec2(1.0,-1.0)*0.001;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#endif    \n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    for( int i=0; i<128; i++ )\n    {\n        h = map(ro + rd*t).x;\n        res = min( res, k*h/t );\n        if( res<0.0001 ) break;\n        t += clamp( h, 0.01, 0.05 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat calcOcc( in vec3 pos, in vec3 nor )\n{\n    const float h = 0.2;\n\tfloat ao = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        vec3 dir = sin( float(i)*vec3(1.0,7.13,13.71)+vec3(0.0,2.0,4.0) );\n        //dir = normalize(nor + dir);\n        dir *= sign(dot(dir,nor));\n        float d = map2( pos + h*dir ).x;\n        ao += max(0.0,h-d*2.0);\n    }\n    return clamp( 4.0 - 2.5*ao, 0.0, 1.0 )*(0.5+0.5*nor.y);\n}\n\nvec3 lig = normalize(vec3(1.0,0.7,0.9));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.5);\n\tif( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n\n\t\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n\t\n\tfloat an = 0.005*iTime + 7.5 - 5.0*m.x;\n\n\tvec3 ro = vec3(4.5*sin(an),0.5,4.5*cos(an));\n    vec3 ta = vec3(0.0,0.5,0.0);\n\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = vec3(0.0);\n\t// raymarch\n    const float maxd = 9.0;\n    vec4  inn = intersect(ro,rd,maxd);\n    float t = inn.x;\n    if( t<maxd )\n    {\n        vec3 tra = inn.yzw;\n\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\t\tvec3 ref = reflect( rd, nor );\n\n        // material\n        col = vec3(0.3,0.3,0.3);\n        if(true ||  pos.y>-0.99) {\n            col += 0.2*tra;\n        }\n        vec3 pat = texCube( iChannel0, 0.5*pos, nor, 4.0 ).xyz;\n        col *= pat;\n        col *= 0.5;\n        \n\t\t// lighting\n\t\tfloat occ = calcOcc( pos, nor );\n\n        float amb = 0.5 + 0.5*nor.y;\n\t\tfloat dif = max(dot(nor,lig),0.0);\n\t\tfloat bou = max(0.0,-nor.y);\n        float bac = max(0.2 + 0.8*dot(nor,-lig),0.0);\n\t\tfloat sha = 0.0; if( dif>0.01 ) sha=softshadow( pos+0.01*nor, lig, 0.0005, 128.0 );\n        float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 3.0 );\n        float spe = 15.0*pat.x*max( 0.0, pow( clamp( dot(lig,reflect(rd,nor)), 0.0, 1.0), 16.0 ) )*dif*sha*(0.04+0.96*fre);\n\t\t\n\t\t// lights\n\t\tvec3 lin = vec3(0.0);\n\n        lin += 3.5*dif*vec3(6.00,4.00,3.00)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n\t\tlin += 1.0*amb*vec3(0.30,0.30,0.30)*occ;\n\t\tlin += 1.0*bac*vec3(0.80,0.50,0.20)*occ;\n\t\tlin += 1.0*bou*vec3(1.00,0.30,0.20)*occ;\n        lin += 4.0*fre*vec3(1.00,0.80,0.70)*(0.3+0.7*dif*sha)*occ;\n        lin += spe*2.0;\n\n        // surface-light interacion\n\t\tcol = col*lin + spe;\n\n        col *= min(200.0*exp(-1.5*t),1.0);\n        col *= 1.0-smoothstep( 1.0,6.0,length(pos.xz) );\n\t}\n\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\n    // grading\n    col = pow( col, vec3(0.6,1.0,1.0) );\n    // vignetting\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t   \n    fragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}