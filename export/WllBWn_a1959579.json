{"ver":"0.1","info":{"id":"WllBWn","date":"1596464268","viewed":108,"name":"fresnel-Schlick y GGX-II","username":"jorge2017a1","description":"fresnel-Schlick y GGX-II","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fresnelschlickyggxii"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//#define PI \t\t3.1415926535897932384626\n#define ZERO \t\tvec3(0.0)\n#define X\t\tvec3(1.0,0.0,0.0)\n#define Y\t\tvec3(0.0,1.0,0.0)\n#define Z\t\tvec3(0.0,0.0,1.0)\n#define R\t\t2.0\n#define T\t\t4\n\n#define EPSILON\t\t0.001\n#define MAX_DIST\t80.0\n#define MAX_ITER\t100\n\n#define MAX_LIGHT\t2\n#define BALL_ROW\t1.0\n#define BALL_COL\t2.0\n#define RADIUS\t\t2.0\n\n#define ALBEDO  \tvec3(0.75)\n#define METALLIC \t0.99\n#define ROUGHNESS \t1.0\n#define F0\t\tmix(vec3(0.04),albedo,metallic)\n#define AO\t\t1.0\n\n\n\n\n//-----------------------------\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdtorus( vec3 p, vec3 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x, p.y+t.z);\n  return length(q)-t.y;\n}\n\n\n//Sphere function\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat solidSphere(vec3 pos, vec3 center, float radius)\n{\n\tfloat d = distance(pos,center)-radius;\n\treturn d;\n}\n\nfloat sdsphere(vec3 pos, vec3 center, float radius)\n{\n\tfloat d = solidSphere(pos,center,radius);\n\treturn d;\n}\n\n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\nfloat sdbox(vec3 pos,vec3 center,vec3 size)\n{\n  \tvec3 d = abs(pos-center) - size;\n \treturn length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n\n//-----------------------------\n\nfloat rand(vec3 seed){\n\treturn fract(sin(dot(seed, vec3(12.9898,78.233,233.33))) * 43758.5453);\n}\n\nfloat rand(vec2 seed)\n{\n\treturn rand(vec3(seed,0.0));\n}\n\nfloat rand(float seed)\n{\n\treturn rand(vec3(seed,0.0,0.0));\n}\n\nfloat noise3(vec3 pos)\n{\n\tfloat t = -iTime*0.0;\n\tvec3 base = floor(pos*R+t);\n\tvec3 pot = fract(pos*R+t);\n\tvec3 f = smoothstep(0.0,1.0,pot);\n\tfloat w1 = mix(rand(base),    rand(base+X),    f.x);\n\tfloat w2 = mix(rand(base+Z),  rand(base+X+Z),  f.x);\n\tfloat w3 = mix(rand(base+Y),  rand(base+X+Y),  f.x);\n\tfloat w4 = mix(rand(base+Y+Z),rand(base+X+Y+Z),f.x);\n\treturn mix(\n\t\tmix(w1,w3,f.y),\n\t\tmix(w2,w4,f.y),\n\t\tf.z\n\t);\n}\n\n\nfloat fbm3(vec3 pos)\n{\n\tfloat total = 0.0, amp = 1.0;\n\tfor (int i = 0; i < T; i++){\n\t\ttotal += noise3(pos) * amp; \n\t\tpos *= 2.0;\n\t\tamp *= 0.5;\n\t}\n\treturn 1.0-exp(-total*total);\n}\n//\nvec3 fresnelSchlick(vec3 albedo,float cosTheta,float metallic)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n    return nom / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n    return nom / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n    return ggx1 * ggx2;\n}\n\n//\nfloat sdplane(vec3 pos,vec3 normal,float h)\n{\n\treturn dot(pos,normalize(normal))-h;\n}\n\n\n\n\n\n\nvec2 dmin(vec2 a,vec2 b)\n{\n\tif(a.x == min(a.x,b.x))\n\t\treturn a;\n\telse \n\t\treturn b;\n}\n\n//--------------------------------------------------------\n///---------------------------------------\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n///------------------------------------\n\n//---------------------------------------------------------\n\n// return (distance, id)\n\n\nvec2 dist(vec3 p)\n{\n\tfloat id = 0.0;\n\tfloat d = MAX_DIST;\n    \n\tfloat obj = id;\n\t\n    \n    vec2 res = vec2(9999, 0);\n    \n    float sdpl1=sdplane(p,Y,-RADIUS);\n    float sds1= sdSphere(p-vec3(-10.0,0.0,0.0), 2.0 );\n    float sdb1= sdBox(p-7.0*Z-5.0*X,vec3(RADIUS) );\n    \n    float sdb3= sdbox( p,vec3(-10.0,0.0,-10.0), vec3(2.0,1.0,2.0) );\n    float sdc1 =sdCylinder(p+5.*X-5.*Z,vec2(1.0,5.0));\n    float sdt1=sdtorus(p+5.*X-5.*Z,vec3(2.0,0.5,1.5));\n    float sdpl2=sdsphere(p,1.25*(0.0*X-1.0*Z-Z)*RADIUS,RADIUS);\n    float sdpl3=sdsphere(p,1.25*(2.0*X-2.0*Z-Z)*RADIUS,RADIUS);\n        \n    \n    res =opU(res, vec2(sdb1,42.0)); \n    res =opU(res, vec2(sdb3,41.0)); \n    res =opU(res, vec2(sdpl1,1.0)); \n    res =opU(res, vec2(sdc1,43.0)); \n    res =opU(res, vec2(sdt1,44.0)); \n    \n    res =opU(res, vec2(sds1,45.0)); \n    res =opU(res, vec2(sdpl2,47.0)); \n    res =opU(res, vec2(sdpl3,46.0)); \n    \n    \n    \n\n\treturn res;\n}\n\n\n\n\nvec3 setCamera(vec2 uv,vec3 pos,vec3 lookat,vec3 up)\n{\n\tvec3 camDir = normalize(lookat-pos);\n\tvec3 camUp = normalize(up);\n\tvec3 camRight = cross(camDir,camUp);\n\treturn normalize(uv.x*camRight+uv.y*camUp+5.0*camDir);\n}\n\n//return  (hinc distance,id_obj)\nvec3 rayMarching(vec3 ro,vec3 rd,float mint)\n{\n\tvec2 d = vec2(mint);\n\tfloat h = d.x;\n\tfor(int i = 0; i<MAX_ITER; i++){\n\t\td = dist(ro+rd*h);\n\t\tif(d.x < EPSILON){ \n\t\t\tbreak;\n\t\t}\n\t\tif(h > MAX_DIST){\n\t\t\treturn vec3(MAX_DIST);\n\t\t}\n\t\th += d.x;\n\t}\n\treturn vec3(h,d);\n}\n\nvec3 calcNormal(vec3 pos)\n{\n\t return normalize(vec3(\n        \tdist(pos+X*EPSILON).x - dist(pos - X*EPSILON).x,\n        \tdist(pos+Y*EPSILON).x - dist(pos - Y*EPSILON).x,\n        \tdist(pos+Z*EPSILON).x - dist(pos - Z*EPSILON).x\n    \t));\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float k)\n{\n    float res = 1.0;\n    float h = mint;\n    for(int t = 0; t < MAX_ITER; t++){\n        float d = dist(ro+rd*h).x;\n        if( d < EPSILON)\n            return 0.0;\n\tif( h > MAX_DIST)\n\t\tbreak;\n        res = min(res, k*d/h);\n        h += d;\n    }\n    return res;\n}\n\nfloat calcShadow(vec3 pos,vec3 dir)\n{\n\tfloat esp = 100.0*EPSILON;\n\tfloat d = rayMarching(pos,dir,esp).y;\n\treturn step(esp,d);\n}\n\n\n\n\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\n\n//Creado por dr2 en 2020-07-28\n//https://www.shadertoy.com/view/3lfBz8\nvec3 getMouse(vec3 ro)\n{    \n     vec4 mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  float tCur = iTime;\n    \n  float az = 0.;\n  float el = -0.15 * PI;\n\n    az += 2. * PI * mPtr.x;\n    el += PI * mPtr.y;\n \n    \n    \n  mat3 vuMat = StdVuMat (el, az);\n\treturn ro*vuMat;\n}\n\n//----------------------------------------------\nvec3 RenderColor(vec3 pos,vec3 ro, vec3 light,vec3 albedo, float metallic, float roughness)\n{\n    \n    vec3 Lo = ZERO;\n    vec3 color = ZERO;\n    \n    vec3 N = calcNormal(pos);\n\tvec3 L = normalize(light-pos);\n\tvec3 V = normalize(ro-pos);\n\tvec3 H = normalize(V+L);\n\t\t\n\tvec3 F  = fresnelSchlick(albedo,max(dot(H, V), 0.0),metallic);\n\tfloat NDF = DistributionGGX(N, H, roughness);       \n\tfloat G   = GeometrySmith(N, V, L, roughness);\n\t\t\n\tfloat dis = 1.0;//length(light-pos);\n        //float dis = length(light-pos);\n    float attenuation = 1.5 / (dis * dis);\n    vec3 radiance     = vec3(1.0,1.0,1.0) * attenuation;\n\n\tvec3 nominator  = NDF * G * F;\n\tfloat denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; \n\tvec3 specular     = nominator / denominator;\n\tvec3 kS = F;\n\tvec3 kD = vec3(1.0) - kS;\n\tkD *= 1.0 - metallic; \n\tfloat NdotL = max(dot(N, L), 0.0);        \n   \tLo += (kD * albedo / PI + specular) * radiance * NdotL;\n\tvec3 ambient = vec3(0.03) * albedo * AO ;\n\tcolor += ambient + Lo * softShadow(pos,L,0.1,16.0); \n    \n    \n    color=color*albedo*albedo;\n    \n\n    return color;\n}\n\n\n\nvec3 RenderLuces(vec3 ro, vec3 rd, vec3 h)\n{   \n    \n    vec3 color = ZERO;\n    vec3 light;\n     light = vec3(0.0,5.0,-5.0);\n    \n    mObj.rd=rd;\n    \n    for(int i = 0; i< 2;i++)\n        {\n\t\tvec3 Lo = ZERO;\n\t\tfloat t = 0.2 * iTime;\n\t\tvec3 light = 18.0*vec3(sin(t*float(i)),0.3,cos(float(i)*t));\n        \n            /*\n        if (i==0)\n             light = vec3(0.0,5.0,-40.0);\n        else if (i==1)\n             light = vec3(0.0,5.0,15.0);\n\n\t\telse if (i==2)\n             light = vec3(0.0,10.0,10.0);\n\n            */\n            \n\t\tvec3 pos = ro+rd*h.x;\n\t\tmObj.p=pos;\n        \n        float row;\n        float col;\n        float k;\n        float id;\n        vec3 albedo;\n        float roughness;\n\t\tfloat metallic;           \n        \n        \n              albedo = getColor(int(h.z));\n            \n            roughness =3.0;\n            metallic = 2.0;\n        \n            \n            \n        if (h.z>=0.0 && h.z<=24.0)    //box\n        { \n            albedo = getColor(int(h.z));\n            //roughness = ROUGHNESS*(1.0);\n            //metallic = METALLIC+0.2;\n            roughness =1.0;\n            metallic = 1.0;\n \t\t}\t     \n         \n        \n        if (h.z>=40.0  &&  h.z<=64.0)    //box\n        { \n            \n            row = floor(h.y / BALL_COL);\n\t\t\tcol = h.y - row * BALL_COL;\n\t\t\tk = smoothstep(0.4,0.7,fbm3(pos));\n\t\t\tid = step(0.0,h.z);\n\t\t\t\n            albedo = getColor(int(h.z-40.0));\n            albedo = mix(vec3(1.0),mix(ALBEDO,albedo,1.0-k),id);\n\t\t\troughness = ROUGHNESS*(1.0-k)*id+0.2;\n\t\t\tmetallic = METALLIC*(k)*id+0.2;//*(col+1.0)/BALL_COL;\n            \n \t\t}\t         \n            \n          \n        color+=  RenderColor(pos,ro, light, albedo,  metallic,  roughness);\n        \n           \n\t\t}\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ( 2.0 * fragCoord.xy - iResolution.xy ) / iResolution.y;\n\t\n    \n    //vec3 ro=vec3(0.0,10.0,-30.0);\n    \n    float t=mod(iTime*2.0, 200.0);\n    \n    vec3 ro=vec3(0.0+5.0*sin(t),10.0,-35.0+5.0*cos(t));\n    //ro= getMouse(ro);\n    \n    \n    ro= getMouse(ro);\n    \n    \n    \n\tvec3 rd = setCamera(uv,ro,ZERO,Y);\n\tvec3 h = rayMarching(ro,rd,EPSILON);\n\t\n\tvec3 color = ZERO;\n    \n    if(h.x < MAX_DIST)\n    {\n\t\t\n        color= RenderLuces( ro,  rd,  h);\n\t\tcolor = color / (color + vec3(1.0));\n\t\tcolor = pow(color, vec3(1.0/2.19)); \n\t}\n\t\n\tfragColor = vec4(color, 1.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"///------------------------------------\nstruct TObj\n{\n    float idcolor;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 rf;\n   \n};\n\n\nTObj mObj;\nfloat itime;\n\n\n\n#define PI 3.14159265358979323846264\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\n\nvec3 fcos( vec3 x )\n{\n    vec3 w = fwidth(x);\n    return cos(x) * smoothstep(3.14*2.0,0.0,w); // filtered-approx\n }\n\nvec3 getColorvII( in float t )\n{\n    vec3 col = vec3(0.3,0.4,0.5);\n    col += 0.12*fcos(6.28318*t*  1.0+vec3(0.0,0.8,1.1));\n    col += 0.11*fcos(6.28318*t*  3.1+vec3(0.3,0.4,0.1));\n    col += 0.10*fcos(6.28318*t*  5.1+vec3(0.1,0.7,1.1));\n    col += 0.00*fcos(6.28318*t*  9.1+vec3(0.2,0.8,1.4));\n    col += 0.10*fcos(6.28318*t* 17.1+vec3(0.2,0.6,0.7));\n    col += 0.10*fcos(6.28318*t* 31.1+vec3(0.1,0.6,0.7));\n    col += 0.10*fcos(6.28318*t* 65.1+vec3(0.0,0.5,0.8));\n    col += 0.10*fcos(6.28318*t*115.1+vec3(0.1,0.4,0.7));\n    col += 0.10*fcos(6.28318*t*265.1+vec3(1.1,1.4,2.7));\n    return col;\n}\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{\n    \n    float m;\nif (i==-2 ) { return mObj.color; }       \nif (i==0 ) { return vec3(0,0,0)/255.0; }\nif (i==1 ) { return vec3(255.,255.,255.)/255.0; }\nif (i==2 ) { return vec3(255,0,0)/255.0; }\nif (i==3 ) { return vec3(0,255,0)/255.0; }\nif (i==4 ) { return vec3(0,0,255)/255.0; }\nif (i==5 ) { return vec3(255,255,0)/255.0; }\nif (i==6 ) { return vec3(0,255,255)/255.0; }\nif (i==7 ) { return vec3(255,0,255)/255.0; }\nif (i==8 ) { return vec3(192,192,192)/255.0; }\nif (i==9 ) { return vec3(128,128,128)/255.0; }\nif (i==10 ) { return vec3(128,0,0)/255.0; }\nif (i==11 ) { return vec3(128,128,0)/255.0; }\nif (i==12 ) { return vec3(0,128,0)/255.0; }\nif (i==13 ) { return vec3(128,0,128)/255.0; }\nif (i==14 ) { return vec3(0,128,128)/255.0; }\nif (i==15 ) { return vec3(0,0,128)/255.0; }\n    \nif (i==16 ) { return vec3(255, 204, 188)/255.0; }\nif (i==17 ) { return vec3(0.8, 0.8, 0.8); }\nif (i==18 ) { return vec3(0.5, 0.5, 0.8); }\n\n    if(i== 19 )\n    {  return vec3(1, 0.5, 0);    } \n    if(i== 20 )\n    { return vec3(1.0, 1.0, 1.0); } \n    if(i== 21 )\n    {  return vec3(247./255., 168./255.,  184./255.);  } \n    if(i== 22 )\n    { return vec3(0, 1, 1);} \n    if(i== 23 )\n    { return vec3(85./255., 205./255., 252./255.); } \n    \n    \n    if(i== 24 )\n    { return  pow( getColorvII(length( mObj.p)) ,vec3(3.5))  ; } \n    \n    \n    \n      \n    if(i== 50 )\n    {\n     \n           \n            vec3 p = mObj.p;\n        \t//vec3 p =  mObj.normal*0.5;\n           vec3 marbleP = p*2.0;\n    \n            marbleP.x += sin(p.y*0.5)*0.12;\n            marbleP.z += sin(p.y*2.0)*0.1;\n            marbleP.y += sin(p.x*5.0)*0.13;\n            marbleP.y += sin(p.z*3.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*10.0)*0.011;\n            marbleP.z += sin(p.y*12.0)*0.013;\n            marbleP.y += sin(p.x*15.0)*0.012;\n            marbleP.y += sin(p.z*13.0)*0.015;\n\n            marbleP.x *= 0.5;\n            marbleP.z *= 0.8;\n            marbleP.y *= 0.50;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 0.2;\n            marbleP.z *= 0.3;\n            marbleP.y *= 0.10;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n\n    \n    \n    \n    //////// Colorization\n\n}\n\n///--------------------------------------------\n\n","name":"Common","description":"","type":"common"}]}