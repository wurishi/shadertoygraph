{"ver":"0.1","info":{"id":"msG3zG","date":"1678715980","viewed":2898,"name":"LEGO Denoising","username":"Mathis","description":"Max viewport resolution: (2048x2048).\n\nA SDF volume is used to improve performance, at the cost of geometric quality and the LEGO logo.\nTAA and 3 denoisers: indirect diffuse SVGF + wavelet filters for glossy reflections and soft shadows.","likes":116,"published":1,"flags":48,"usePreview":1,"tags":["global","illumination","lego","denoising","svgf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nNotes:\n    Transparent windows:\n        The blue panels should actually be transparent, but compilation time...\n            Original idea was to use checkerboard rendering or render them at a separate pass\n    Bricks\n        Are injected into a SDF volume to increase performance and reduce compilation time\n            Max buffer size for this volume is 2048x1024\n            Trilinear sampling is optimized to only need one texture lookup\n        Color/material index is interpolated in the volume -> color bleeding when objects share a SDF volume point\n        Lower geometric quality and removal of the logo\n        My door model does not exist as an actual brick\n    Denoising\n        SVGF\n            Slightly modified SVGF denoiser with 3 passes\n            Ordinary reprojection with weighted bilinear sampling\n                Relaxed weights since variance updating is delayed with one frame\n                    This results in some white ghosting when disocclusion happens\n        Shadow and reflection denoisers\n            Wavelet filters\n    Reflections\n        Should be more mirrorlike, but glossy reflections are cooler\n    Secondary bounce\n        Sampling screen space information is on by default, which introduces the usual artifacts\n            Alternatively a second ray can be traced for second bounce diffuse light\n        Reflections will also sample screen space information\n            Direct light is traced with hard shadows\n            It has no other information about indirect light\n    I like feedback \n\n\n\nControls:\n    WASD and mouse to move around\n        Camera collides against the SDF, so you have to move around it :)\n    M/N to rotate the sun\n    Remove the commented \"#define SecondBounce\" in the Common tab to replace\n        screen space sampling to second bounce diffuse light\n\n*/\n\nvec3 acesFilm(vec3 x) {\n    //Aces film curve\n    return clamp((x*(2.51*x+0.03))/(x*(2.43*x+0.59)+0.14),0.,1.);\n}\n\nvec4 textureCube(vec2 UV) {\n    //Samples the cubemap\n    float Sign = -mod(floor(UV.y*I1024),2.)*2.+1.;\n    vec3 D = vec3(vec2(UV.x,mod(UV.y,1024.))*I512-1.,Sign);\n    if (UV.y>4096.) D = D.xzy;\n    else if (UV.y>2048.) D = D.zxy;\n    return texture(iChannel3,D);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float YOffset = 2048.+floor(fragCoord.x*I1024)*1024.+floor(fragCoord.y*I1024)*2048.;\n    vec3 Color = textureCube(mod(fragCoord,1024.)+vec2(0.,YOffset)).xyz;\n    fragColor = vec4(pow(acesFilm(max(vec3(0.),Color)),vec3(0.45)),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Settings\nconst float FOV = radians(85.);\nconst vec3 SkyLight = vec3(0.6,0.8,1.)*0.5;\nconst vec3 SunLight = vec3(1.,0.5,0.25)*5.;\nconst float SunCR = 0.05;\n//#define SecondBounce\n\n//Other vars\nconst float LightCoeff = 8.;\nconst float ILightCoeff = 1./LightCoeff;\nconst float VarCoeff = 16.;\nconst float RefMaterial = 0.075;\nconst int BuildFrames = 7;\nconst float CFOV = tan(FOV*0.5);\nconst float PI = 3.141592653;\nconst float HPI = PI*0.5;\nconst float IPI = 1./PI;\nconst float PI2 = PI*2.;\nconst float IPI2 = 0.5/PI;\nconst float ToRadians = PI/180.;\nconst float I3 = 1./3.;\nconst float I16 = 1./16.;\nconst float I32 = 1./32.;\nconst float I64 = 1./64.;\nconst float I128 = 1./128.;\nconst float I256 = 1./256.;\nconst float I300 = 1./300.;\nconst float I512 = 1./512.;\nconst float I1024 = 1./1024.;\nconst float I2048 = 1./2048.;\nconst vec2 eps = vec2(0.0025,0.);\n//Bricks\nconst vec3 LEGOObliqueSlope = normalize(vec3(0.,-3.,-3.4));\nconst vec3 LEGOSlope331 = normalize(vec3(0.9,2.,0.));\nconst vec3 LEGOSlope = normalize(vec3(0.9,1.,0.));\nconst vec3 LEGOISlope = normalize(vec3(0.9,-1.,0.));\nconst vec3 LEGOOSlope = normalize(vec3(3.5/6.,1.,0.));\n//RES\n#define RES iChannelResolution[0].xy\n#define IRES (1./iChannelResolution[0].xy)\n#define ASPECT vec2(RES.x/RES.y,1.)\n\nconst vec2 SSOffsets[16] = vec2[16](vec2(0.),vec2(-0.4,-0.4),vec2(0.,0.2),vec2(0.15,-0.4),vec2(-0.4,-0.15),\n                                    vec2(0.15,0.4),vec2(-0.2,-0.2),vec2(-0.4,0.4),vec2(0.4,0.15),vec2(0.2,-0.2),\n                                    vec2(0.4,0.4),vec2(-0.4,0.15),vec2(0.4,-0.15),\n                                    vec2(-0.15,0.4),vec2(0.4,-0.4),vec2(-0.15,-0.4));\n\nstruct HIT { float D; vec3 N; vec3 C; vec3 E; };\nstruct BRICK { vec3 P; vec3 Q; int C; int I; };\n\n//SKY\nvec3 SampleSky(vec3 d, vec3 sd, float Time) {\n    return SkyLight*(1.-0.5*d.y)*(d.y*0.5+0.5);\n}\n\n//SDF\nfloat DFBox(vec3 p, vec3 b) {\n    vec3 d = abs(p-b*0.5)-b*0.5;\n    return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\n}\n\nfloat DFBoxC(vec3 p, vec3 b) {\n    vec3 d = abs(p)-b;\n    return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\n}\n\nfloat DFBox(vec2 p, vec2 b) {\n    vec2 d = abs(p-b*0.5)-b*0.5;\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\nfloat DFBoxC(vec2 p, vec2 b) {\n    vec2 d = abs(p)-b;\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\nfloat DFDisk(vec3 p) {\n    float d = length(p.xz-0.5)-0.35;\n    vec2 w = vec2(d,abs(p.y));\n    return min(max(w.x,w.y),0.)+length(max(w,0.));\n}\n\nfloat DFLine(vec3 p, vec3 a, vec3 b) {\n    vec3 ba = b-a;\n    float k = dot(p-a,ba)/dot(ba,ba);\n    return length((a+clamp(k,0.,1.)*(b-a))-p);\n}\n\nfloat DFCylinder(vec3 p, float r, float h) {\n    vec2 d = vec2(length(p.xz)-r,abs(p.y)-h);\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\n\nfloat DFPlane(vec3 p, vec3 p0, vec3 p1, vec3 p2) {\n    //Intersects a plane\n    vec3 Normal = normalize(cross(p1-p0,p2-p0));\n    vec3 tp = vec3(dot(p-p0,normalize(p1-p0)),dot(p-p0,normalize(p2-p0)),dot(p-p0,Normal));\n    return DFBox(tp-vec3(0.,0.,-0.005),vec3(length(p1-p0),length(p2-p0),0.01));\n}\n\nvec2 Rotate(vec2 p, float ang) {\n    float c = cos(ang), s = sin(ang);\n    return vec2(p.x*c-p.y*s,p.x*s+p.y*c);\n}\n\nvec2 Repeat(vec2 p, float n) {\n    float ang = 2.*3.14159/n;\n    float sector = floor(atan(p.x,p.y)/ang+0.5);\n    p = Rotate(p,sector*ang);\n    return p;\n}\n\nfloat smin(float a, float b, float k) {\n    //https://iquilezles.org/articles/smin\n    float h = max(k-abs(a-b),0.)/k;\n    return min(a,b)-h*h*h*k*(1.0/6.0);\n}\n\nmat3 TBN(vec3 N) {\n    vec3 Nb,Nt;\n    if (abs(N.y)>0.999) {\n        Nb=vec3(1.,0.,0.);\n        Nt=vec3(0.,0.,1.);\n    } else {\n    \tNb=normalize(cross(N,vec3(0.,1.,0.)));\n    \tNt=normalize(cross(Nb,N));\n    }\n    return mat3(Nb.x,Nt.x,N.x,Nb.y,Nt.y,N.y,Nb.z,Nt.z,N.z);\n}\n\nvec3 TBN(vec3 N, out vec3 O) {\n    O = ((abs(N.y)<=0.999)?normalize(cross(N,vec3(0.,1.,0.))):vec3(1.,0.,0.));\n    return normalize(cross(O,N));\n}\n\nvec3 RandSample(vec2 v) {\n    float r=sqrt(1.-v.x*v.x);\n    float phi=2.*3.14159*v.y;\n    return vec3(cos(phi)*r,sin(phi)*r,v.x);\n}\n\nvec3 RandSampleCos(vec2 v) {\n    float theta=sqrt(v.x);\n    float phi=2.*3.14159*v.y;\n    float x=theta*cos(phi);\n    float z=theta*sin(phi);\n    return vec3(x,z,sqrt(max(0.,1.-v.x)));\n}\n\nvec3 SchlickFresnel(vec3 r0, float angle) {\n    //Schlick Fresnel approximation\n    return r0+(1.-r0)*pow(1.-angle,5.);\n}\n\nvec3 ARand23(vec2 uv) {\n    //Analytic random\n    return fract(sin(uv.x*uv.y)*vec3(403.125,486.125,513.432)+cos(dot(uv,vec2(13.18273,51.2134)))*vec3(173.137,261.23,203.127));\n}\n\nfloat ARand21(vec2 uv) {\n    //Analytic random\n    return fract(sin(uv.x*uv.y)*403.125+cos(dot(uv,vec2(13.18273,51.2134)))*173.137);\n}\n\nvec2 ABox(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax) {\n    vec3 tMin = (bmin-origin)*dir;\n    vec3 tMax = (bmax-origin)*dir;\n    vec3 t1 = min(tMin,tMax);\n    vec3 t2 = max(tMin,tMax);\n    return vec2(max(max(t1.x,t1.y),t1.z),min(min(t2.x,t2.y),t2.z));\n}\n\nvec2 ABoxfarNormal(vec2 origin, vec2 dir, vec2 bmin, vec2 bmax) {\n    vec2 tMin=(bmin-origin)*dir;\n    vec2 tMax=(bmax-origin)*dir;\n    vec2 t2=max(tMin,tMax);\n    vec2 signdir = -(max(vec2(0.),sign(dir))*2.-1.);\n    if (t2.x<t2.y) return vec2(signdir.x,0.);\n    else return vec2(0.,signdir.y);\n}\n\nvec2 ABoxNormal(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax, out vec3 N) {\n    vec3 tMin=(bmin-origin)*dir;\n    vec3 tMax=(bmax-origin)*dir;\n    vec3 t1=min(tMin,tMax);\n    vec3 t2=max(tMin,tMax);\n    vec3 signdir = -(max(vec3(0.),sign(dir))*2.-1.);\n    if (t1.x>max(t1.y,t1.z)) N = vec3(signdir.x,0.,0.);\n    else if (t1.y>t1.z) N = vec3(0.,signdir.y,0.);\n    else N = vec3(0.,0.,signdir.z);\n    return vec2(max(max(t1.x,t1.y),t1.z),min(min(t2.x,t2.y),t2.z));\n}\n\n//Non-optimal vec2/vec3 to float functions\nvec3 FloatToVec3(float v) {\n    float x = fract(v);\n    float z = floor(v*I300);\n    float y = floor(v-z*300.)*I300;\n    return vec3(x,y,z*I300);\n}\n\nfloat Vec3ToFloat(vec3 v) {\n    return min(v.x,0.998)+min(299.,floor(v.y*300.+0.5))+floor(v.z*300.+0.5)*300.;\n}\n\nvec2 FloatToVec2(float v) {\n    return vec2((floor(fract(v)*2048.)+0.5)*I2048,(floor(v)+0.5)*I2048);\n}\n\nfloat Vec2ToFloat(vec2 v) {\n    return min(v.x,0.999)+min(floor(v.y*2048.),2048.);\n}\n\n//MODELS\nfloat DFStud(vec3 p) {\n    float d = -smin(-DFLine(p,vec3(0.5,-1.,0.5),vec3(0.5,1.,0.5))+0.3,-p.y+0.2,0.075);\n    d = max(-p.y,smin(d,DFDisk(p),0.05));\n    return d;\n}\n\nfloat DFBrick(vec3 p, vec3 BSize) {\n    float d = DFBox(p-vec3(0.04),BSize-vec3(0.08,0.48,0.08))-0.04;\n    d = max(d,-DFBox(p-vec3(0.2,-1.,0.2),BSize-vec3(0.4,-0.4,0.4)));\n    if (min(BSize.x,BSize.z)>1.5) {\n        float tmpLine = DFLine(vec3(p.x-clamp(floor(p.x-0.5),0.,BSize.x-2.)-0.5,p.yz),vec3(0.5,-1.,1.),vec3(0.5,1.,1.));\n        d = min(d,max(max(max(tmpLine-0.407,-tmpLine+0.3),p.y-(BSize.y-0.45)),-p.y));\n    } else if (BSize.x>1.5) {\n        float tmpLine = DFLine(vec3(p.x-clamp(floor(p.x-0.5),0.,BSize.x-2.)-0.5,p.yz),vec3(0.5,-1.,0.5),vec3(0.5,2.,0.5));\n        d = min(d,max(max(max(tmpLine-0.2,-tmpLine+0.1),p.y-(BSize.y-0.45)),-p.y));\n    }\n    vec3 StudPos = vec3(clamp(floor(p.x),0.,BSize.x-1.),BSize.y-0.4,clamp(floor(p.z),0.,BSize.z-1.));\n    d = max(d,-max(DFLine(p-StudPos,vec3(0.5,-1.,0.5),vec3(0.5,-0.05,0.5))-0.15,p.y-1.19)); //Hole under stud\n    d = min(d,DFStud(p-StudPos)); //Studs\n    return d;\n}\n\nfloat DFBrick_NoStud(vec3 p, vec3 BSize) {\n    float d = DFBox(p-vec3(0.04),BSize-vec3(0.08,0.48,0.08))-0.04;\n    d = max(d,-DFBox(p-vec3(0.2,-1.,0.2),BSize-vec3(0.4,-0.4,0.4)));\n    if (BSize.x>1.5) {\n        float tmpLine = DFLine(vec3(p.x-clamp(floor(p.x-0.5),0.,BSize.x-2.)-0.5,p.yz),vec3(0.5,-1.,0.5),vec3(0.5,2.,0.5));\n        d = min(d,max(max(max(tmpLine-0.2,-tmpLine+0.1),p.y-(BSize.y-0.45)),-p.y));\n    }\n    return d;\n}\n\nfloat DFPanelWall(vec3 p, vec3 BSize) {\n    float d = DFBox(p-vec3(0.04),vec3(BSize.x-0.08,0.32,BSize.z-0.08));\n    d = min(d,DFBox(p-vec3(0.04),vec3(BSize.x-0.08,BSize.y-0.08,0.12)));\n    d = min(d,DFBox(p-vec3(0.04,BSize.y-0.16,0.04),vec3(BSize.x-0.08,0.12,BSize.z-0.08)));\n    return d-0.04;\n}\n\nfloat DFGrate(vec3 p) {\n    float d = DFBox(p-vec3(0.02),vec3(1.96,0.36,0.96))-0.02;\n    d = max(d,-DFBox(p-vec3(0.2,-1.,0.2),vec3(1.6,1.25,0.6)));\n    d = max(d,-DFBox(vec3(p.x+2.,p.y-0.2,fract(p.z*2.5)*0.4-0.2),vec3(8.,1.,0.2)));\n    return d;\n}\n\nfloat DFRound111(vec3 p) {\n    float LineDF = DFLine(p,vec3(0.5,-1.,0.5),vec3(0.5,1.,0.5));\n    float d = -smin(smin(-LineDF+0.5,-p.y+0.4,0.04),p.y-0.3,0.015);\n    d = min(d,max(max(max(LineDF-0.397,-LineDF+0.305),p.y-0.35),-p.y));\n    d = max(d,-max(LineDF-0.15,p.y-0.39));\n    d = min(d,DFStud(vec3(p.x,p.y-0.4,p.z))); //Stud\n    return d;\n}\n\nfloat DFRound131(vec3 p) {\n    float LineDF = DFLine(p,vec3(0.5,-1.,0.5),vec3(0.5,2.,0.5));\n    float d = max(max(LineDF-0.397,p.y-0.35),-p.y);\n    d = min(d,max(-smin(-LineDF+0.48,-p.y+1.2,0.05),-p.y+0.2));\n    //Stud\n    d = smin(d,max(-smin(-LineDF+0.3,-p.y+1.4,0.07),-p.y+1.2),0.07);\n    d = -smin(-d,LineDF-0.2,0.07);\n    return d;\n}\n\nfloat DFCone131(vec3 p) {\n    float d = max(max(DFLine(p,vec3(0.5,-1.,0.5),vec3(0.5,1.,0.5))-0.397,p.y-0.35),-p.y);\n    d = min(d,max(-smin(-DFLine(p,vec3(0.5,-1.,0.5),vec3(0.5,2.,0.5))+mix(0.48,0.33,p.y-0.2),-p.y+1.2,0.05),-p.y+0.2));\n    //Stud\n    d = smin(d,max(-smin(-DFLine(p,vec3(0.5,-1.,0.5),vec3(0.5,2.,0.5))+0.3,-p.y+1.4,0.07),-p.y+1.2),0.04);\n    d = -smin(-d,DFLine(p,vec3(0.5,-1.,0.5),vec3(0.5,2.,0.5))-0.2,0.07);\n    return d;\n}\n\nfloat DFISlope(vec3 p, float Z) {\n    float d = -smin(-DFBox(p-vec3(0.02),vec3(1.96,1.16,Z-0.04))+0.02,-dot(LEGOISlope,p-vec3(1.,0.,0.)),0.03);\n    d = -smin(-d,max(DFBox(p-vec3(1.15,0.2,0.15),vec3(0.75,2.,Z-0.3)),dot(LEGOISlope,p-vec3(1.,0.2,0.))),0.05);\n    //Stud\n    float StudZ = clamp(floor(p.z),0.,Z-1.)+0.5;\n    d = smin(d,-smin(-max(-smin(-DFLine(p,vec3(1.5,-1.,StudZ),vec3(1.5,2.,StudZ))+0.3,-p.y+1.4,0.07),-p.y+0.85),\n    DFLine(p,vec3(1.5,-1.,StudZ),vec3(1.5,2.,StudZ))-0.2,0.07),0.07);\n    d = min(d,DFStud(p-vec3(0.,1.2,StudZ-0.5))); //Studs\n    return d;\n}\n\nfloat DFOnlySlope(vec3 p) {\n    float d = -smin(-DFBox(p-vec3(0.1,0.1,0.1),vec3(0.8,0.8,0.8))+0.1,-dot(LEGOOSlope,p-vec3(0.,0.8,0.)),0.06);\n    return d;\n}\n\nfloat DFHeadLight(vec3 p) {\n    float d = -smin(-DFBox(p-vec3(0.04),vec3(0.92,1.12,0.92))+0.04,DFBox(p-vec3(-1.,0.25,-1.),vec3(1.2,2.,3.)),0.05);\n    //Stud\n    d = smin(d,-smin(-DFLine(p,vec3(0.5,0.7,0.5),vec3(-2.,0.7,0.5))+0.3,p.x,0.07),0.05);\n    d = max(d,-min(DFLine(p,vec3(0.5,0.7,0.5),vec3(-2.,0.7,0.5))-0.2,DFBox(p-vec3(0.3,-1.,0.2),vec3(0.5,1.5,0.6))));\n    d = max(d,-DFBox(p-vec3(0.3,0.2,0.2),vec3(3.,0.8,0.6)));\n    d = min(d,max(-smin(-DFLine(p-vec3(0.,1.2,0.),vec3(0.5,-1.,0.5),vec3(0.5,1.,0.5))+0.3,-p.y+1.2+0.2,0.075),-p.y+1.2)); //Stud\n    return d;\n}\n\nfloat DFHose(vec3 p) {\n    vec3 rp = p-vec3(0.5,0.,0.5);\n    float lrp = length(rp);\n    float d = -smin(rp.y,-max(lrp-0.45,-lrp+0.35),0.02);\n    d = smin(d,DFLine(p,vec3(0.5,0.45,0.5),vec3(0.5,1.15,0.5))-0.2,0.07);\n    //Stud\n    d = smin(d,-smin(smin(-DFLine(p,vec3(0.5,-1.,0.5),vec3(0.5,2.,0.5))+0.3,-p.y+1.4,0.07),p.y-1.2,0.07),0.07);\n    //Arm\n    d = smin(d,DFLine(p,vec3(0.7,0.95,0.5),vec3(1.2,0.95,0.5))-0.2+(p.x-0.7)*0.1,0.1);\n    d = smin(d,max(max(DFLine(p,vec3(0.,0.95,0.5),vec3(3.,0.95,0.5))-0.2,-p.x+1.2),p.x-1.4),0.04);\n    return d;\n}\n\nfloat DFPanel(vec3 p) {\n    float d = DFBox(p-vec3(0.04),vec3(1.92,0.32,0.92))-0.04;\n    d = max(d,-DFBox(p-vec3(0.2,-1.,0.2),vec3(1.6,1.2,0.6)));\n    d = min(d,DFBox(p-vec3(0.05,0.05,0.05),vec3(1.9,1.1,0.))-0.05);\n    return d;\n}\n\nfloat DFHandle(vec3 p, float type) {\n    //Symmetric through the x-axis\n    vec3 syp = vec3(p.xy,abs(p.z-1.));\n    float d = DFBox(syp-vec3(0.04,0.04,-0.96),vec3(0.92,0.32,1.92))-0.04;\n    //Handle\n    float Z = type*0.4;\n    float tmpCyl = length(syp.xy-vec2(1.5,0.3));\n    d = min(d,DFBox(syp-vec3(0.04,0.04,0.74-Z),vec3(1.46,0.32,0.22))-0.04);\n    d = min(d,-smin(smin(-tmpCyl+0.3,1.-Z-syp.z,0.04),syp.z-0.7+Z,0.04));\n    d = min(d,max(tmpCyl-0.2,syp.z-1.));\n    //Interior + Stud\n    d = max(d,-DFBox(syp-vec3(0.2,-1.,-0.8),vec3(0.6,1.2,1.6)));\n    float tmpLine = min(DFLine(vec3(syp.xy,syp.z+0.5),vec3(0.5,-1.,0.5),vec3(0.5,1.2,0.5)),\n    DFLine(vec3(syp.xy,syp.z+0.5),vec3(0.5,-1.,0.5),vec3(0.5,0.6,0.5)));\n    d = min(d,max(max(max(tmpLine-0.2,-tmpLine+0.1),syp.y-(0.4-0.075)),-syp.y));\n    d = max(d,-max(DFLine(syp,vec3(0.5,-1.,0.5),vec3(0.5,0.35,0.5))-0.15,syp.y-1.19)); //Hole under stud\n    d = min(d,DFStud(syp-vec3(0.,0.4,0.))); //Studs\n    return d;\n}\n\nfloat DFGrip(vec3 p) {\n    float d = DFBox(p-vec3(0.04,0.44,0.04),vec3(0.92,0.32,0.92))-0.04;\n    //Grip\n    d = min(d,DFBox(p-vec3(0.04,0.44,0.39),vec3(1.36,0.32,0.22))-0.04);\n    d = min(d,-smin(smin(-length(p.xy-vec2(1.45,0.68))+0.37,-p.z+0.65,0.04),-0.35+p.z,0.04));\n    d = max(d,-length(p.xy-vec2(1.5,0.7))+0.2);\n    d = -smin(-d,1.62-p.x,0.08);\n    //Stud\n    d = max(d,-DFBox(p-vec3(0.2,-1.,0.2),vec3(0.6,1.6,0.6)));\n    vec3 StudPos = vec3(0.,0.8,0.);\n    d = max(d,-max(DFLine(p-StudPos,vec3(0.5,-1.,0.5),vec3(0.5,2.,0.5))-0.15,p.y-0.75)); //Hole under stud\n    d = min(d,DFStud(p-StudPos)); //Studs\n    return d;\n}\n\nfloat DFDisk(vec3 p, float radius) {\n    //(0.4-y)^2 = 1+(0.1-y)^2\n    //(0.8-y)^2 = 2.25+(0.1-y)^2\n    float d;\n    float sY = ((radius<1.5)?-1.41667:-1.375);\n    if (radius<1.5) {\n        float LenMiddle = length(p.xz-1.);\n        d = max(max(length(p-vec3(1.,sY,1.))-(-sY+0.4),\n             -length(p-vec3(1.,sY-0.1,1.))+(-sY+0.4)),LenMiddle-1.);\n        d = smin(d,max(-p.y,-smin(-DFLine(p,vec3(1.,-1.,1.),\n             vec3(1.,1.,1.))+0.3,-p.y+0.6,0.075)),0.04); //Stud\n        d = min(d,max(max(LenMiddle-0.4,-p.y),p.y-0.35));\n        //Holes\n        d = -smin(-d,LenMiddle-0.2,0.05);\n        d = max(d,-max(p.y+0.05-0.4*radius,LenMiddle-0.3));\n    } else {\n        float LenMiddle = length(p.xz-1.5);\n        d = max(max(length(p-vec3(1.5,sY,1.5))-(-sY+0.8),\n             -length(p-vec3(1.5,sY-0.1,1.5))+(-sY+0.8)),LenMiddle-1.5);\n        d = min(d,max(-p.y,max(p.y-0.2,abs(LenMiddle-1.4)-0.1)));\n        d = smin(d,max(-p.y+0.4,-smin(-DFLine(p,vec3(1.5,-1.,1.5),\n             vec3(1.5,1.,1.5))+0.3,-p.y+1.,0.075)),0.04); //Stud\n        d = min(d,max(max(LenMiddle-0.4,-p.y+0.4),p.y-0.75));\n        //Holes\n        d = -smin(-d,LenMiddle-0.2,0.05);\n        d = max(d,-max(p.y+0.05-0.8,LenMiddle-0.3));\n    }\n    return d;\n}\n\nfloat DFDoor(vec3 p) {\n    //~Model 3861\n    float d = DFBox(p-vec3(0.48,0.42,0.02),vec3(3.46,5.16,0.16))-0.02;\n    //Ornament\n    d = -smin(-d,DFBox(p-vec3(0.75,0.6,-1.),vec3(2.5,2.6,1.1)),0.1);\n    d = min(d,DFBox(p-vec3(1.15,1.,0.),vec3(1.7,1.8,0.15)));\n    //Window\n    d = -smin(-d,DFBox(p-vec3(0.75,3.75,-1.),vec3(2.5,1.4,1.1)),0.1);\n    //Handle\n    d = min(d,DFLine(p,vec3(3.5,3.4,0.),vec3(3.2,3.4,0.))-0.15);\n    //Vertical cylinder\n    d = min(d,max(max(DFLine(p,vec3(0.5,-1.,0.5),vec3(0.5,10.,0.5))-0.5,p.y-5.6),-p.y));\n    return d;\n}\n\n\n//BrickDim array\nfloat BrickADim[7]=float[7](1.,2.,3.,4.,6.,8.,10.);\nvec3 BrickDim[44]=vec3[44](\n    vec3(2.,0.8,1.), //DFGrate\n    vec3(2.,0.8,2.), //DFCorner 2x1x2\n    vec3(2.,1.2,2.), //DFCorner 2x2x2\n    vec3(2.,1.6,2.), //DFCorner 2x3x2\n    vec3(1.,0.8,1.), //Round111\n    vec3(1.,1.6,1.), //Round131\n    vec3(1.,1.6,1.), //Cone131\n    vec3(2.,1.6,1.), //Slope 2x3x1\n    vec3(2.,1.6,2.), //Slope 2x3x2\n    vec3(2.,1.6,3.), //Slope 2x3x3\n    vec3(2.,1.6,4.), //Slope 2x3x4\n    vec3(2.,1.6,5.), //Slope 2x3x5\n    vec3(2.,1.6,6.), //Slope 2x3x6\n    vec3(2.,1.6,7.), //Slope 2x3x7\n    vec3(2.,1.6,8.), //Slope 2x3x8\n    vec3(3.,1.6,1.), //DFSlope331\n    vec3(2.,1.6,1.), //DFISlope 2x3x1\n    vec3(2.,1.6,2.), //DFISlope 2x3x2\n    vec3(1.,0.8,1.), //DFOnlySlope\n    vec3(1.,1.6,1.), //DFHeadLight\n    vec3(2.,1.6,1.), //DFHose\n    vec3(2.,1.2,1.), //DFDoubleSlope\n    vec3(2.,1.2,2.), //DFDoubleSlope\n    vec3(2.,1.2,3.), //DFDoubleSlope\n    vec3(2.,1.2,4.), //DFDoubleSlope\n    vec3(2.,1.2,5.), //DFDoubleSlope\n    vec3(2.,1.2,6.), //DFDoubleSlope\n    vec3(2.,1.6,2.), //DFRound232\n    vec3(2.,1.2,1.), //DFPanel\n    vec3(2.,2.8,1.), //DFWindow 2x2x1\n    vec3(4.,5.2,1.), //DFWindow 4x4x1\n    vec3(2.,3.,1.), //DFWindowPanel\n    vec3(1.,1.6,1.), //DFBrickHole\n    vec3(4.,7.2,1.), //DFDoor\n    vec3(2.,0.8,2.), //DFHandle 1 Handle\n    vec3(2.,0.8,2.), //DFHandle 3 Handle\n    vec3(2.,1.2,1.), //DFGrip\n    vec3(2.,0.8,2.), //DFDisk R = 1\n    vec3(3.,1.2,3.), //DFDisk R = 1.5\n    vec3(2.,1.6,2.), //DFSlopeCross\n    vec3(2.,1.2,2.), //DFDoubleSlopeInverse\n    vec3(2.,2.4,1.), //DFPanelWall H=2, x=2\n    vec3(2.,3.6,1.), //DFPanelWall H=3, x=2\n    vec3(3.,3.6,1.) //DFPanelWall H=3, x=3\n);\n\n//Colors: //White,LightBlue,Orange,Black,Red,Blue,Beige,Brown,LightBlack,LightGreen,Grey,DarkGrey,TrueYellow\nconst vec3 BrickColorArray[13] = vec3[13](vec3(0.9),vec3(0.3,0.55,0.85),vec3(0.8,0.35,0.2),vec3(0.05),\n    vec3(0.99,0.05,0.05),vec3(0.05,0.1,0.95),vec3(0.7,0.6,0.1),vec3(0.4,0.1,0.03),\n    vec3(0.1),vec3(0.15,0.99,0.15),vec3(0.45),vec3(0.25),vec3(1.,1.,0.1)\n);\nconst vec3 GarageY = normalize(vec3(0.,cos(radians(30.)),sin(radians(30.))));\nconst vec3 GarageRotP = vec3(21.,5.9,11.7);\nconst vec3 StairX = normalize(vec3(cos(radians(65.)),sin(radians(65.)),0.));\nconst vec3 StairY = vec3(-StairX.y,StairX.x,0.);\nconst vec3 StairRotP = vec3(19.5,8.3,24.);\nconst vec3 LampZ = normalize(vec3(0.,1.,-1.));\nconst vec3 LampY = vec3(0.,LampZ.z,-LampZ.y);\nconst vec3 LampRotP = vec3(24.5,9.5,11.5);\nconst vec3 DiskX = normalize(vec3(1.,1.,0.));\nconst vec3 DiskY = vec3(-DiskX.y,DiskX.x,0.);\nconst vec3 DiskRotP = vec3(20.4,12.2,15.5);\nconst int NBricks = 128;\nconst BRICK BrickArray0[NBricks]=BRICK[NBricks](\n    //Floor\n        BRICK(vec3(0.,0.,0.),vec3(1.,0.,0.),0,12),\n        BRICK(vec3(0.,0.,2.),vec3(1.,0.,0.),0,12),\n        BRICK(vec3(0.,0.,4.),vec3(1.,0.,0.),0,12),\n        BRICK(vec3(0.,0.,6.),vec3(1.,0.,0.),0,12),\n        BRICK(vec3(0.,0.,8.),vec3(1.,0.,0.),0,12),\n        BRICK(vec3(0.,0.,10.),vec3(1.,0.,0.),0,12),\n        BRICK(vec3(0.,0.,12.),vec3(1.,0.,0.),0,12),\n        BRICK(vec3(0.,0.,14.),vec3(1.,0.,0.),0,12),\n        BRICK(vec3(0.,0.,16.),vec3(1.,0.,0.),0,12),\n        BRICK(vec3(0.,0.,18.),vec3(1.,0.,0.),0,12),\n        BRICK(vec3(0.,0.,20.),vec3(1.,0.,0.),0,5),\n    \n    //Wall H=1\n        BRICK(vec3(0.,0.4,0.),vec3(1.,0.,0.),0,5), //Back\n        BRICK(vec3(1.,0.4,1.),vec3(0.,0.,1.),0,5), //Behind head\n            BRICK(vec3(1.,0.4,9.),vec3(0.,0.,1.),0,5),\n            BRICK(vec3(1.,0.4,17.),vec3(0.,0.,1.),0,3),\n        BRICK(vec3(8.,0.4,1.),vec3(0.,0.,1.),0,3), //Door wall\n            BRICK(vec3(8.,0.4,9.),vec3(0.,0.,1.),0,5),\n            BRICK(vec3(8.,0.4,17.),vec3(0.,0.,1.),0,3),\n        BRICK(vec3(1.,0.4,20.),vec3(1.,0.,0.),0,4), //Front\n        //Head H=1\n        BRICK(vec3(1.,0.4,4.),vec3(1.,0.,0.),0,2),\n            BRICK(vec3(1.,0.4,9.),vec3(1.,0.,0.),0,2),\n    \n    //Doors H=1\n        BRICK(vec3(4.,0.4,5.),vec3(0.,0.,1.),0,89), //Head door\n            //BRICK(vec3(3.9,0.4,4.85),vec3(sin(0.3),0.,cos(0.3)),0,89), //Head door (rotated)\n        BRICK(vec3(8.,0.4,5.),vec3(0.,0.,1.),0,89), //Entrance door\n    \n    //Wall H=2\n        BRICK(vec3(1.,0.8,0.),vec3(1.,0.,0.),11,4),\n        BRICK(vec3(1.,0.8,0.),vec3(0.,0.,1.),11,5), //Behind head\n            BRICK(vec3(1.,0.8,8.),vec3(0.,0.,1.),11,5),\n            BRICK(vec3(1.,0.8,16.),vec3(0.,0.,1.),11,3),\n        BRICK(vec3(0.,0.8,20.),vec3(1.,0.,0.),11,5), //Front\n        BRICK(vec3(8.,0.8,0.),vec3(0.,0.,1.),11,3), //Door wall\n            BRICK(vec3(8.,0.8,4.),vec3(0.,0.,1.),11,0),\n            BRICK(vec3(8.,0.8,9.),vec3(0.,0.,1.),11,5),\n            BRICK(vec3(8.,0.8,17.),vec3(0.,0.,1.),11,2),\n        //Head H=2\n        BRICK(vec3(1.,0.8,4.),vec3(1.,0.,0.),11,2),\n            BRICK(vec3(1.,0.8,9.),vec3(1.,0.,0.),11,2),\n    \n    //Wall panels\n        BRICK(vec3(1.,1.2,0.),vec3(1.,0.,0.),0,98), //Back\n            BRICK(vec3(3.,1.2,0.),vec3(1.,0.,0.),0,98),\n            BRICK(vec3(5.,1.2,0.),vec3(1.,0.,0.),0,98),\n        BRICK(vec3(0.,1.2,4.),vec3(0.,0.,-1.),1,99), //Sides\n            BRICK(vec3(8.,1.2,1.),vec3(0.,0.,1.),1,99),\n        BRICK(vec3(4.,1.2,5.),vec3(-1.,0.,0.),2,99), //Head\n            BRICK(vec3(1.,1.2,9.),vec3(1.,0.,0.),2,99),\n            BRICK(vec3(0.,1.2,7.),vec3(0.,0.,-1.),0,98), //Along wall toilet\n                BRICK(vec3(0.,1.2,9.),vec3(0.,0.,-1.),0,98),\n        BRICK(vec3(0.,1.2,20.),vec3(0.,0.,-1.),2,98), //Behind chairs front\n            BRICK(vec3(8.,1.2,18.),vec3(0.,0.,1.),2,98),\n        BRICK(vec3(3.,2.4,21.),vec3(-1.,0.,0.),1,97), //Front\n            BRICK(vec3(5.,2.4,21.),vec3(-1.,0.,0.),1,97),\n            BRICK(vec3(7.,2.4,21.),vec3(-1.,0.,0.),1,97),\n        BRICK(vec3(0.,2.4,17.),vec3(0.,0.,-1.),1,97), //Windows kitchen and sofa\n            BRICK(vec3(0.,2.4,15.),vec3(0.,0.,-1.),1,97),\n            BRICK(vec3(8.,2.4,15.),vec3(0.,0.,1.),1,97),\n            BRICK(vec3(8.,2.4,13.),vec3(0.,0.,1.),1,97),\n    \n    //Wall H=3 from back door wall\n        BRICK(vec3(8.,1.2,0.),vec3(0.,0.,1.),2,14), //Back\n        BRICK(vec3(8.,1.2,4.),vec3(0.,0.,1.),2,14), //Near door\n            BRICK(vec3(8.,1.2,10.),vec3(0.,0.,1.),2,17),\n            BRICK(vec3(8.,1.2,9.),vec3(0.,0.,1.),2,14),\n            BRICK(vec3(8.,1.2,14.),vec3(0.,0.,1.),2,17),\n            BRICK(vec3(4.,1.2,20.),vec3(1.,0.,0.),2,17),\n        BRICK(vec3(1.,1.2,10.),vec3(0.,0.,1.),2,17), //Opposite door\n            BRICK(vec3(1.,1.2,9.),vec3(0.,0.,1.),2,14),\n            BRICK(vec3(1.,1.2,14.),vec3(0.,0.,1.),2,17),\n            BRICK(vec3(0.,1.2,20.),vec3(1.,0.,0.),2,17),\n        BRICK(vec3(1.,1.2,0.),vec3(0.,0.,1.),2,14), //Near back and head\n            BRICK(vec3(1.,1.2,4.),vec3(0.,0.,1.),2,14),\n    \n    //Wall H=6 (same as panels)\n        BRICK(vec3(8.,2.4,0.),vec3(0.,0.,1.),2,14), //Back\n        BRICK(vec3(8.,2.4,4.),vec3(0.,0.,1.),2,14), //Near door\n            BRICK(vec3(8.,2.4,9.),vec3(0.,0.,1.),2,17),\n            BRICK(vec3(8.,2.4,17.),vec3(0.,0.,1.),2,14),\n            BRICK(vec3(8.,2.4,20.),vec3(0.,0.,1.),2,14),\n        BRICK(vec3(1.,2.4,9.),vec3(0.,0.,1.),2,17), //Opposite door\n            BRICK(vec3(1.,2.4,17.),vec3(0.,0.,1.),2,14),\n            BRICK(vec3(1.,2.4,20.),vec3(0.,0.,1.),2,14),\n        BRICK(vec3(1.,2.4,0.),vec3(0.,0.,1.),2,14), //Near back and head\n            BRICK(vec3(1.,2.4,4.),vec3(0.,0.,1.),2,14),\n    \n    //Wall H=9\n        BRICK(vec3(8.,3.6,0.),vec3(0.,0.,1.),2,14), //Back\n        BRICK(vec3(8.,3.6,4.),vec3(0.,0.,1.),2,14), //Door side\n                BRICK(vec3(8.,3.6,9.),vec3(0.,0.,1.),2,3), //Hooks and stove\n                BRICK(vec3(8.,4.,9.),vec3(0.,0.,1.),2,3),\n                BRICK(vec3(8.,4.4,11.),vec3(0.,0.,1.),10,8), //Stove\n                    BRICK(vec3(7.,4.8,11.),vec3(0.,0.,1.),8,56),\n                BRICK(vec3(8.,4.4,9.),vec3(0.,0.,1.),10,1),\n            BRICK(vec3(8.,3.6,17.),vec3(0.,0.,1.),2,14),\n            BRICK(vec3(8.,3.6,20.),vec3(0.,0.,1.),2,14),\n        BRICK(vec3(1.,3.6,9.),vec3(0.,0.,1.),2,17), //Opposite door\n            BRICK(vec3(1.,3.6,17.),vec3(0.,0.,1.),2,14),\n            BRICK(vec3(1.,3.6,20.),vec3(0.,0.,1.),2,14),\n            BRICK(vec3(1.,3.6,20.),vec3(0.,0.,1.),2,14),\n        BRICK(vec3(1.,3.6,0.),vec3(0.,0.,1.),2,14), //Near back and head\n            BRICK(vec3(1.,3.6,4.),vec3(0.,0.,1.),2,14),\n    \n    //Wall H=12 (white with curtains hooks)\n        BRICK(vec3(0.,4.8,0.),vec3(1.,0.,0.),0,19), //Back\n        BRICK(vec3(8.,4.8,3.),vec3(0.,0.,1.),0,15), //Door wall\n            BRICK(vec3(8.,4.8,9.),vec3(0.,0.,1.),0,17),\n            BRICK(vec3(8.,4.8,19.),vec3(0.,0.,1.),0,15),\n                BRICK(vec3(7.,4.8,17.),vec3(1.,0.,0.),0,75), //Air vent\n                BRICK(vec3(7.,4.8,18.),vec3(1.,0.,0.),0,75),\n                BRICK(vec3(7.2,6.,17.),vec3(0.,90.,1.),2,56),\n        BRICK(vec3(1.,4.8,5.),vec3(0.,0.,1.),0,17), //Opposite door\n            BRICK(vec3(1.,4.8,9.),vec3(0.,0.,1.),0,17),\n            BRICK(vec3(1.,4.8,17.),vec3(0.,0.,1.),0,17),\n        BRICK(vec3(0.,4.8,4.),vec3(1.,0.,0.),0,17), //Head\n            BRICK(vec3(1.,4.8,9.),vec3(1.,0.,0.),0,14),\n            BRICK(vec3(2.,4.8,10.),vec3(0.,0.,-1.),0,75),\n                BRICK(vec3(2.,6.,9.8),vec3(1.,90.,0.),2,60),\n                BRICK(vec3(2.,6.,8.6),vec3(1.,90.,0.),2,60),\n            BRICK(vec3(3.,4.8,9.),vec3(1.,0.,0.),0,14),\n    \n    //Roof base H=15\n        BRICK(vec3(1.,6.,0.),vec3(1.,0.,0.),10,32), //Back\n        BRICK(vec3(8.,6.,0.),vec3(0.,0.,1.),10,29), //Door side\n            BRICK(vec3(8.,6.,2.),vec3(0.,0.,1.),10,0),\n            BRICK(vec3(8.,6.,3.),vec3(0.,0.,1.),10,33),\n            BRICK(vec3(8.,6.,11.),vec3(0.,0.,1.),10,0),\n            BRICK(vec3(8.,6.,12.),vec3(0.,0.,1.),10,33),\n        BRICK(vec3(0.,6.,20.),vec3(1.,0.,0.),10,29), //Front\n            BRICK(vec3(3.,6.,20.),vec3(0.,0.,1.),10,0),\n            BRICK(vec3(3.,6.,20.),vec3(1.,0.,0.),10,29),\n            BRICK(vec3(6.,6.,20.),vec3(0.,0.,1.),10,0),\n            BRICK(vec3(6.,6.,20.),vec3(1.,0.,0.),10,29),\n        BRICK(vec3(1.,6.,0.),vec3(0.,0.,1.),10,29), //Opposite door\n            BRICK(vec3(1.,6.,2.),vec3(0.,0.,1.),10,0),\n            BRICK(vec3(1.,6.,3.),vec3(0.,0.,1.),10,33),\n            BRICK(vec3(1.,6.,11.),vec3(0.,0.,1.),10,0),\n            BRICK(vec3(1.,6.,12.),vec3(0.,0.,1.),10,33),\n    \n    //Front window hooks\n    BRICK(vec3(1.,4.8,20.),vec3(1.,0.,0.),0,4),\n        BRICK(vec3(1.,5.2,21.),vec3(0.,0.,-1.),0,91),\n        BRICK(vec3(3.,5.2,21.),vec3(0.,0.,-1.),0,91),\n        BRICK(vec3(5.,5.2,21.),vec3(0.,0.,-1.),0,91),\n        BRICK(vec3(1.,5.6,20.),vec3(1.,0.,0.),0,4),\n    \n    //Side windows front - window hooks\n    BRICK(vec3(1.,4.8,13.),vec3(0.,0.,1.),0,3),\n        BRICK(vec3(0.,5.2,13.),vec3(1.,0.,0.),0,91)\n);\n\nconst BRICK BrickArray1[96]=BRICK[96](\n        BRICK(vec3(0.,5.2,15.),vec3(1.,0.,0.),0,91),\n        BRICK(vec3(1.,5.6,13.),vec3(0.,0.,1.),0,3),\n    BRICK(vec3(8.,4.8,13.),vec3(0.,0.,1.),0,3),\n        BRICK(vec3(8.,5.2,15.),vec3(-1.,0.,0.),0,91),\n        BRICK(vec3(8.,5.2,17.),vec3(-1.,0.,0.),0,91),\n        BRICK(vec3(8.,5.6,13.),vec3(0.,0.,1.),0,3),\n    \n    //Side windows back - window hooks\n    BRICK(vec3(1.,4.8,1.),vec3(0.,0.,1.),0,1),\n        BRICK(vec3(1.,4.8,3.),vec3(0.,0.,1.),0,14),\n        BRICK(vec3(0.,5.2,1.),vec3(1.,0.,0.),0,91),\n        BRICK(vec3(1.,5.6,1.),vec3(0.,0.,1.),0,1),\n    BRICK(vec3(8.,4.8,1.),vec3(0.,0.,1.),0,1),\n        BRICK(vec3(8.,5.2,3.),vec3(-1.,0.,0.),0,91),\n        BRICK(vec3(8.,5.6,1.),vec3(0.,0.,1.),0,1),\n    \n    //Interior - bed\n        BRICK(vec3(6.,0.4,1),vec3(0.,0.,1.),7,9), //\"Not\" legs\n        BRICK(vec3(6.,0.8,1.),vec3(0.,0.,1.),7,9),\n    BRICK(vec3(2.,1.2,1.),vec3(0.,0.,1.),0,30), //Base\n        BRICK(vec3(4.,1.2,1.),vec3(0.,0.,1.),0,37),\n        BRICK(vec3(6.,1.2,1.),vec3(0.,0.,1.),0,37),\n    BRICK(vec3(1.5,1.6,1.41666666),vec3(0.,0.,1.),10,1), //Pillow\n    BRICK(vec3(1.5,1.6,3.25),vec3(cos(0.8),0.,-sin(0.8)),9,10), //Blanket\n    BRICK(vec3(6.,0.4,2.),vec3(0.,0.,-1.),10,75), //Small table\n        BRICK(vec3(7.,1.61,1.),vec3(0.,0.,1.),6,60),\n    \n    //Roof base - head\n    BRICK(vec3(4.,6.,4.),vec3(0.,0.,1.),10,29),\n        BRICK(vec3(1.,6.,4.),vec3(1.,0.,0.),10,29),\n        BRICK(vec3(1.,6.,9.),vec3(1.,0.,0.),10,30),\n    \n    //Interior - head\n    BRICK(vec3(1.,0.4,5.),vec3(1.,0.,0.),5,60), //Basin\n        BRICK(vec3(1.,0.8,5.),vec3(1.,0.,0.),0,72),\n        BRICK(vec3(1.,2.01,5.),vec3(1.,0.,0.),10,76),\n    BRICK(vec3(4.,0.4,6.),vec3(0.,0.,1.),7,2), //Entrance brick\n        BRICK(vec3(1.,0.41,6.),vec3(1.,0.,0.),2,56), //Grate\n    BRICK(vec3(1.,0.4,7.),vec3(1.,0.,0.),0,8), //Seat\n        BRICK(vec3(1.,0.8,7.),vec3(1.,0.,0.),0,8),\n        BRICK(vec3(3.,1.21,8.),vec3(0.,0.,1.),10,75),\n        BRICK(vec3(1.,1.21,8.),vec3(1.,0.,0.),5,61),\n    \n    //Interior - entrance\n    BRICK(vec3(6.,0.4,6.),vec3(0.,0.,1.),2,37), //Entrance\n        BRICK(vec3(8.,0.4,6.),vec3(0.,0.,1.),2,37),\n    \n    //Galley\n    BRICK(vec3(7.,0.4,11.),vec3(0.,0.,1.),0,11), //Stove\n        BRICK(vec3(7.,0.8,11.),vec3(0.,0.,1.),11,15),\n        BRICK(vec3(5.,0.8,11.),vec3(1.,0.,0.),11,75),\n        BRICK(vec3(5.,0.8,12.),vec3(1.,0.,0.),11,75),\n        BRICK(vec3(7.,2.,11.),vec3(0.,0.,1.),11,8),\n            BRICK(vec3(5.,2.41,11.),vec3(1.,0.,0.),10,60),\n            BRICK(vec3(5.,2.41,12.),vec3(1.,0.,0.),10,60),\n            BRICK(vec3(6.,2.41,11.),vec3(1.,0.,0.),10,60),\n            BRICK(vec3(6.,2.41,12.),vec3(1.,0.,0.),10,60),\n        BRICK(vec3(7.,0.4,10.),vec3(0.,0.,1.),10,14), //Stove wall with hooks\n            BRICK(vec3(6.,1.2,11.),vec3(0.,0.,-1.),10,92),\n            BRICK(vec3(7.,2.,10.),vec3(0.,0.,1.),10,14),\n            BRICK(vec3(6.,2.8,11.),vec3(0.,0.,-1.),10,92),\n            BRICK(vec3(7.,3.6,10.),vec3(0.,0.,1.),11,0),\n            BRICK(vec3(6.,4.,11.),vec3(0.,0.,-1.),11,74),\n    BRICK(vec3(7.,0.8,13.),vec3(0.,0.,1.),0,15), //Working area\n        BRICK(vec3(6.,0.8,13.),vec3(0.,0.,1.),0,15),\n        BRICK(vec3(7.,2.,13.),vec3(0.,0.,1.),0,36),\n        BRICK(vec3(6.001,0.8,14.),vec3(0.,0.,1.),0,72),\n        BRICK(vec3(6.,0.81,15.),vec3(1.,0.,0.),5,61),\n        BRICK(vec3(7.,2.02,16.),vec3(-1.,0.,0.),10,76),\n    BRICK(vec3(6.,0.81,16.),vec3(1.,0.,0.),4,61), //Fire extinguisher\n        BRICK(vec3(6.8,2.02,17.15),vec3(-0.9,0.,-0.43588989),0,76),\n    \n    //Sofa\n    BRICK(vec3(3.,0.4,10.),vec3(0.,0.,1.),10,11),\n        BRICK(vec3(3.,0.8,10.),vec3(0.,0.,1.),9,11),\n    BRICK(vec3(1.,1.2,10.),vec3(1.,0.,0.),9,74),\n        BRICK(vec3(1.,1.21,11.),vec3(1.,0.,0.),9,74),\n        BRICK(vec3(1.,1.21,12.),vec3(1.,0.,0.),9,74),\n        BRICK(vec3(1.,1.21,13.),vec3(1.,0.,0.),9,74),\n        BRICK(vec3(1.,1.21,14.),vec3(1.,0.,0.),9,74),\n        BRICK(vec3(1.,1.21,15.),vec3(1.,0.,0.),9,74),\n        BRICK(vec3(2.01,1.21,16.),vec3(0.,0.,-1.),9,74), //Sofa side\n    \n    //Dining area\n    BRICK(vec3(1.,0.4,18.),vec3(1.,0.,0.),0,11),\n        BRICK(vec3(2.,0.8,18.),vec3(0.,0.,1.),2,1),\n        BRICK(vec3(3.,0.8,18.),vec3(0.,0.,1.),2,56),\n        BRICK(vec3(7.,0.8,18.),vec3(0.,0.,1.),2,1),\n        BRICK(vec3(6.,0.8,18.),vec3(0.,0.,1.),2,56),\n    BRICK(vec3(3.5,0.9,18.5),vec3(1.,0.,0.),11,61), //Table\n        BRICK(vec3(3.,2.,18.),vec3(1.,0.,0.),0,8),\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    BRICK(vec3(210.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(210.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(210.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(210.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(210.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(210.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(210.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(210.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(210.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(210.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(210.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(210.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(210.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(210.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(210.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(210.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(210.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(210.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(210.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(210.,0.,12.),vec3(1.,0.,0.),10,29),\n    BRICK(vec3(210.,0.,12.),vec3(1.,0.,0.),10,29)\n);","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Storage, primary rays and diffuse rays\n\nvec4 textureCube(vec2 UV) {\n    //Samples the cubemap\n    float Sign = -mod(floor(UV.y*I1024),2.)*2.+1.;\n    vec3 D = vec3(vec2(UV.x,mod(UV.y,1024.))*I512-1.,Sign);\n    if (UV.y>4096.) D = D.xzy;\n    else if (UV.y>2048.) D = D.zxy;\n    return texture(iChannel3,D);\n}\n\nvec4 SampleMB(vec2 uv, vec3 PPos, vec3 Normal, vec3 LPos, mat3 LEyeMat) {\n    //A weighted sample for a bilinear mix\n    vec4 C = texture(iChannel0,clamp(uv,vec2(0.5,1.5),RES-0.5)*IRES);\n    vec3 SDir = normalize(vec3((uv*IRES*2.-1.)*(ASPECT*CFOV),1.)*LEyeMat);\n    float W = max(0.0001,float(dot(Normal,LPos+SDir*C.w-PPos)<0.2)*0.+float(C.w>-0.5))*\n              max(0.01,dot(Normal,normalize(FloatToVec3(C.z)*2.-1.))*5.-4.);\n    return vec4(vec3(FloatToVec2(C.x)*LightCoeff,C.y)*W,W);\n}\n\nvec4 ManualBilinear(vec2 uv, vec3 PPos, vec3 Normal, vec3 LPos, mat3 LEyeMat) {\n    //Returns weighted RGB sum + weight sum\n    vec2 Fuv = floor(uv-0.499)+0.5;\n    vec4 S0 = SampleMB(Fuv,PPos,Normal,LPos,LEyeMat);\n    vec4 S1 = SampleMB(Fuv+vec2(1.,0.),PPos,Normal,LPos,LEyeMat);\n    vec4 S2 = SampleMB(Fuv+vec2(0.,1.),PPos,Normal,LPos,LEyeMat);\n    vec4 S3 = SampleMB(Fuv+vec2(1.),PPos,Normal,LPos,LEyeMat);\n    vec2 fuv = fract(uv-0.499);\n    float MixedWeight = mix(mix(S0.w,S1.w,fuv.x),mix(S2.w,S3.w,fuv.x),fuv.y);\n    return vec4(mix(mix(S0.xyz,S1.xyz,fuv.x),mix(S2.xyz,S3.xyz,fuv.x),fuv.y)/MixedWeight,MixedWeight);\n}\n\nfloat SampleSDF(vec3 sp) {\n    //Samples the volume SDF\n    float SVal = (sp.y/6.4)*80.;\n    vec2 UVmod = 0.5+(sp.zx/vec2(21.,8.))*vec2(252.,96.);\n    vec2 UVSlice0 = vec2(min(floor(mod(SVal,4.)),3.)*253.,min(floor(SVal/4.),20.)*97.);\n    vec4 TexC = textureCube(UVmod+UVSlice0);\n    return mix(TexC.x,TexC.z,fract(SVal));\n}\n\n\nHIT Trace(vec3 P, vec3 D, float Time) {\n    HIT OUT = HIT(100000.,vec3(0.),vec3(-1.),vec3(0.));\n    //SDF ray tracing\n    vec2 bb = ABox(P,1./D,vec3(0.),vec3(8.,6.399,21.));\n    float FAR = bb.y;\n    float t = 0.; float dfs = 10000.;\n    if (P.y>6.399) {\n        if (bb.x>0. && bb.y>bb.x) t = bb.x+0.01;\n        else return OUT;\n    }\n    for (int i=0; i<512; i++) {\n        vec3 sp = P+D*t;\n        dfs = SampleSDF(sp);\n        t += dfs;\n        if (min(FAR-t,dfs-0.001)<0.) break;\n    }\n    if (dfs<0.001) {\n        vec3 sp = P+D*t;\n        float SVal = (sp.y/6.4)*80.+0.5;\n        vec2 UVmod = 0.5+floor((sp.zx/vec2(21.,8.))*vec2(252.,96.)+0.5);\n        vec2 UVSlice0 = vec2(min(floor(mod(SVal,4.)),3.)*253.,min(floor(SVal/4.),20.)*97.);\n        return HIT(t,normalize(vec3(SampleSDF(sp+eps.xyy)-SampleSDF(sp-eps.xyy),\n                   SampleSDF(sp+eps.yxy)-SampleSDF(sp-eps.yxy),\n                   SampleSDF(sp+eps.yyx)-SampleSDF(sp-eps.yyx))),\n                   BrickColorArray[int(floor(textureCube(UVmod+UVSlice0).y))],vec3(0.));\n    }\n    //Return\n    return OUT;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Output = texture(iChannel0,fragCoord.xy*IRES);\n    if (iFrame==0) {\n        //Initialization\n        if (fragCoord.x<10. && fragCoord.y<1.) { //Store vars\n            if (fragCoord.x<1.) Output = vec4(0.,0.,0.,0.); //Mouse\n            else if (fragCoord.x<2.) Output = vec4(-0.69,2.55,0.,0.); //Player Eye (Angles)\n            else if (fragCoord.x<3.) Output = vec4(0.,0.,0.,1.); //Player Eye (Vector)\n            else if (fragCoord.x<4.) Output = vec4(1.4,6.,18.9,1.); //Player Pos\n            else if (fragCoord.x<5.) Output = vec4(0.75,-5.,0.,0.); //Sun angles\n            else if (fragCoord.x<6.) Output = vec4(0.,0.,0.,0.); //Sun direction\n        }\n    } else {\n        //Update\n\t\tif (fragCoord.x<16. && fragCoord.y<1.) {\n            //Update vars\n            if (fragCoord.x<1.) { //Mouse\n                if (iMouse.z>0.) {\n                    if (Output.w==0.) {\n                    \tOutput.w = 1.;\n                    \tOutput.xy = iMouse.zw;\n                    }\n                } else Output.w = 0.;\n            } else if (fragCoord.x<2.) {\n                //Player Eye (Angles)\n                vec4 LMouse = texture(iChannel0,vec2(0.5,0.5)*IRES);\n                if (LMouse.w==0.)  Output.zw = Output.xy;\n                if (LMouse.w==1.) {\n                \t//Y led\n                \tOutput.x = Output.z+(iMouse.y-LMouse.y)*IRES.y*5.;\n                \tOutput.x = clamp(Output.x,-2.8*0.5,2.8*0.5);\n                \t//X led\n                \tOutput.y = Output.w-(iMouse.x-LMouse.x)*IRES.x*10.;\n               \t\tOutput.y = mod(Output.y,3.1415926*2.);\n                }\n            } else if (fragCoord.x<3.) {\n                //Player Eye (Vector)\n                vec3 Angles = texture(iChannel0,vec2(1.5,0.5)*IRES).xyz;\n                Output.xyz = normalize(vec3(cos(Angles.x)*sin(Angles.y),\n                  \t\t\t   \t\t\tsin(Angles.x),\n                  \t\t\t   \t\t\tcos(Angles.x)*cos(Angles.y)));\n            } else if (fragCoord.x<4.) {\n                //Player Pos\n                float Speed = iTimeDelta*2.;\n                \tif (texelFetch(iChannel1,ivec2(32,0),0).x>0.) Speed = 6.*iTimeDelta;\n                vec3 Eye = texture(iChannel0,vec2(2.5,0.5)*IRES).xyz;\n                vec3 Tan = normalize(cross(vec3(Eye.x,0.,Eye.z),vec3(0.,1.,0.)));\n                vec3 NEye = -Eye;\n                vec3 NTan = -Tan;\n                //Next position\n                vec3 NPos = Output.xyz;\n                if (texelFetch(iChannel1,ivec2(87,0),0).x>0.) NPos += Eye*Speed; //W\n                if (texelFetch(iChannel1,ivec2(83,0),0).x>0.) NPos += NEye*Speed; //S\n                if (texelFetch(iChannel1,ivec2(65,0),0).x>0.) NPos += NTan*Speed; //A\n                if (texelFetch(iChannel1,ivec2(68,0),0).x>0.) NPos += Tan*Speed; //D\n                //SDF collisions\n                if (DFBox(NPos-vec3(0.),vec3(8.,6.4,21.))<0.) {\n                    float LoneSample = SampleSDF(NPos-eps.yxy);\n                    if (LoneSample<0.1) {\n                        vec3 SDFGradient = normalize(vec3(SampleSDF(Output.xyz+eps.xyy)-SampleSDF(Output.xyz-eps.xyy),\n                                                          SampleSDF(Output.xyz+eps.yxy)-SampleSDF(Output.xyz-eps.yxy),\n                                                          SampleSDF(Output.xyz+eps.yyx)-SampleSDF(Output.xyz-eps.yyx)));\n                        Eye += SDFGradient*max(0.,-dot(SDFGradient,Eye));\n                        Tan += SDFGradient*max(0.,-dot(SDFGradient,Tan));\n                        NEye += SDFGradient*max(0.,-dot(SDFGradient,NEye));\n                        NTan += SDFGradient*max(0.,-dot(SDFGradient,NTan));\n                    }\n                }\n                if (texelFetch(iChannel1,ivec2(87,0),0).x>0.) Output.xyz += Eye*Speed; //W\n                if (texelFetch(iChannel1,ivec2(83,0),0).x>0.) Output.xyz += NEye*Speed; //S\n                if (texelFetch(iChannel1,ivec2(65,0),0).x>0.) Output.xyz += NTan*Speed; //A\n                if (texelFetch(iChannel1,ivec2(68,0),0).x>0.) Output.xyz += Tan*Speed; //D\n                //Clamping the position\n                Output.xyz = clamp(Output.xyz,vec3(0.2),vec3(7.8,10.,20.8));\n            } else if (fragCoord.x<5.) {\n                //Sun angle\n                if (texelFetch(iChannel1,ivec2(77,0),0).x>0.) Output.y += iTimeDelta*0.75;\n                if (texelFetch(iChannel1,ivec2(78,0),0).x>0.) Output.y -= iTimeDelta*0.75;\n                Output.z = Output.y; //Sunangle last frame\n            } else if (fragCoord.x<6.) {\n                //Sun direction\n                vec2 Angles = texture(iChannel0,vec2(4.5,0.5)*IRES).xy;\n                Output = vec4(normalize(vec3(cos(Angles.y)*cos(Angles.x)\n                \t,sin(Angles.x),sin(Angles.y)*cos(Angles.x))),1.);\n            } else if (fragCoord.x<7.) {\n                //Last frame dir\n                Output = texture(iChannel0,vec2(2.5,0.5)*IRES);\n            } else if (fragCoord.x<8.) {\n                //Last frame position\n                Output = texture(iChannel0,vec2(3.5,0.5)*IRES);\n            } else if (fragCoord.x<9.) {\n                //Last frame SunDir\n                Output = texture(iChannel0,vec2(5.5,0.5)*IRES);\n            } else if (fragCoord.x<10.) {\n                //Last last frame dir\n                Output = texture(iChannel0,vec2(6.5,0.5)*IRES);\n            } else if (fragCoord.x<11.) {\n                //Last last frame position\n                Output = texture(iChannel0,vec2(7.5,0.5)*IRES);\n            }\n        }\n    }\n    //Rendering\n    if (fragCoord.y>1. && iFrame>3+BuildFrames) {\n        //G-Buffer\n        float CurrentFrame = float(iFrame);\n        vec2 SSOffset = SSOffsets[iFrame%16];\n        vec3 SunDir = texture(iChannel0,vec2(5.5,0.5)*IRES).xyz;\n        vec3 Pos = texture(iChannel0,vec2(3.5,0.5)*IRES).xyz;\n        vec3 Eye = texture(iChannel0,vec2(2.5,0.5)*IRES).xyz;\n        mat3 EyeMat = TBN(Eye);\n        vec3 LPos = texture(iChannel0,vec2(7.5,0.5)*IRES).xyz;\n        vec3 LEye = texture(iChannel0,vec2(6.5,0.5)*IRES).xyz;\n        mat3 LEyeMat = TBN(LEye);\n        vec3 LTan; vec3 LBit = TBN(LEye,LTan);\n        vec3 Dir = normalize(vec3(((fragCoord+SSOffset)*IRES*2.-1.)*(ASPECT*CFOV),1.)*EyeMat);\n        //Render scene\n        HIT Pixel = Trace(Pos,Dir,iTime);\n        if (Pixel.C.x>=0.) {\n            //Geometry\n            vec3 PPos = Pos+Dir*Pixel.D;\n            Output.w = Pixel.D;\n            Output.z = Vec3ToFloat(Pixel.N*0.5+0.5);\n\n\n            //\n            //Indirect diffuse light accumulation\n            //\n            vec3 IDLight = vec3(0.);\n            vec3 RandV = ARand23(fragCoord*IRES*(1.+mod(CurrentFrame*7.253,9.234)));\n            vec3 RandDir = RandSampleCos(RandV.xy)*TBN(Pixel.N);\n            HIT Sample = Trace(PPos+Pixel.N*0.01,RandDir,iTime);\n            if (Sample.C.x>=0.) {\n                //Geometry\n                RandV = ARand23(fragCoord*IRES*(1.+mod(CurrentFrame*7.253,3.234)));\n                vec3 SunRandDir = normalize(RandSampleCos(RandV.xy)*TBN(SunDir)*SunCR+SunDir);\n                if (dot(Sample.N,SunRandDir)>0.)\n                    IDLight += Sample.C*SunLight*(dot(Sample.N,SunRandDir)*\n                               float(Trace(PPos+RandDir*Sample.D+Sample.N*0.01,SunRandDir,iTime).C.x<0.));\n                #ifdef SecondBounce\n                    //World space sampling\n                    vec3 PPos2 = PPos+RandDir*Sample.D+Sample.N*0.01;\n                    RandV.xy = clamp(ARand23(fragCoord*I1024*(1.+mod(float(iFrame)*6.63839,27.2734))).xy,vec2(0.001),vec2(0.999));\n                    RandDir = RandSampleCos(RandV.xy)*TBN(Sample.N);\n                    HIT Sample2 = Trace(PPos2,RandDir,iTime);\n                    if (Sample2.C.x>=0.) {\n                        RandV = ARand23(fragCoord*IRES*(1.+mod(CurrentFrame*8.553,13.234)));\n                        SunRandDir = normalize(RandSampleCos(RandV.xy)*TBN(SunDir)*SunCR+SunDir);\n                        if (dot(Sample2.N,SunRandDir)>0.)\n                            IDLight += Sample.C*Sample2.C*SunLight*(dot(Sample2.N,SunRandDir)*\n                                    float(Trace(PPos2+RandDir*Sample2.D+Sample2.N*0.01,SunRandDir,iTime).C.x<0.));\n                    } else {\n                        //Sky\n                        IDLight += SampleSky(RandDir,SunDir,iTime);\n                    }\n                #else\n                    //Screen space sampling\n                    vec3 SSPos = PPos+RandDir*Sample.D-LPos;\n                    SSPos = vec3(dot(SSPos,LTan),dot(SSPos,LBit),dot(SSPos,LEye));\n                    vec2 Luv = ((SSPos.xy/SSPos.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n                    if (SSPos.z>0. && DFBox(Luv-vec2(0.,1.),RES-vec2(0.,1.))<0.) {\n                        vec4 SSC = texture(iChannel0,(floor(Luv)+0.5)*IRES);\n                        float Weight = float(SSC.w>-0.5)*float(dot(normalize(FloatToVec3(SSC.z)*2.-1.),Sample.N)>0.8);\n                        IDLight += Sample.C*vec3(FloatToVec2(SSC.x)*LightCoeff,SSC.y)*Weight;\n                    }\n                #endif\n                \n            } else {\n                //Sky\n                IDLight += SampleSky(RandDir,SunDir,iTime);\n            }\n            //Reprojection\n            vec3 LVPos = PPos-LPos;\n            LVPos = vec3(dot(LVPos,LTan),dot(LVPos,LBit),dot(LVPos,LEye));\n            vec2 Luv = ((LVPos.xy/LVPos.z)*0.5/(ASPECT*CFOV)+0.5)*RES-SSOffsets[(iFrame-1)%16];\n            if (DFBox(Luv,RES)<0.) {\n                //Inside screen -> reprojection exists\n                vec4 LFrame = ManualBilinear(Luv,PPos,Pixel.N,LPos,LEyeMat);\n                float Confidence = LFrame.w; //Confidence in our sample from last frame\n                IDLight = (IDLight+LFrame.xyz*(23.*Confidence))/(1.+23.*Confidence);\n            }\n            Output.xy = vec2(Vec2ToFloat(IDLight.xy*ILightCoeff),min(IDLight.z,LightCoeff));\n        } else {\n            //Sky\n            Output = vec4(-1.);\n        }\n    } else if (fragCoord.y>1.) {\n        //Initial frames\n        Output = vec4(0.);\n    }\n    fragColor = Output;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Denoising + tracing reflections and shadows\n\nvec4 textureCube(vec2 UV) {\n    //Samples the cubemap\n    float Sign = -mod(floor(UV.y*I1024),2.)*2.+1.;\n    vec3 D = vec3(vec2(UV.x,mod(UV.y,1024.))*I512-1.,Sign);\n    if (UV.y>4096.) D = D.xzy;\n    else if (UV.y>2048.) D = D.zxy;\n    return texture(iChannel3,D);\n}\n\nfloat SampleSDF(vec3 sp) {\n    //Samples the volume SDF\n    float SVal = (sp.y/6.4)*80.;\n    vec2 UVmod = 0.5+(sp.zx/vec2(21.,8.))*vec2(252.,96.);\n    vec2 UVSlice0 = vec2(min(floor(mod(SVal,4.)),3.)*253.,min(floor(SVal/4.),20.)*97.);\n    vec4 TexC = textureCube(UVmod+UVSlice0);\n    return mix(TexC.x,TexC.z,fract(SVal));\n}\n\n\nHIT Trace(vec3 P, vec3 D, float Time) {\n    HIT OUT = HIT(100000.,vec3(0.),vec3(-1.),vec3(0.));\n    //SDF ray tracing\n    float FAR = ABox(P,1./D,vec3(0.),vec3(8.,6.4,21.)).y;\n    float t = 0.; float dfs = 10000.;\n    //if (P.y>6.399) {\n    //    if (D.y>=0.) return OUT;\n    //    t = -(P.y-6.399)/D.y;\n    //}\n    for (int i=0; i<384; i++) {\n        vec3 sp = P+D*t;\n        dfs = SampleSDF(sp);\n        t += dfs;\n        if (min(FAR-t,dfs-0.001)<0.) break;\n    }\n    if (dfs<0.001) {\n        vec3 sp = P+D*t;\n        float SVal = (sp.y/6.4)*80.+0.5;\n        vec2 UVmod = 0.5+floor((sp.zx/vec2(21.,8.))*vec2(252.,96.)+0.5);\n        vec2 UVSlice0 = vec2(min(floor(mod(SVal,4.)),3.)*253.,min(floor(SVal/4.),20.)*97.);\n        return HIT(t,normalize(vec3(SampleSDF(sp+eps.xyy)-SampleSDF(sp-eps.xyy),\n                   SampleSDF(sp+eps.yxy)-SampleSDF(sp-eps.yxy),\n                   SampleSDF(sp+eps.yyx)-SampleSDF(sp-eps.yyx))),\n                   BrickColorArray[int(floor(textureCube(UVmod+UVSlice0).y))],vec3(0.));\n    }\n    //Return\n    return OUT;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Output = vec4(0.);\n    if (fragCoord.y>1.) {\n        float CurrentFrame = float(iFrame);\n        vec2 SSOffset = SSOffsets[iFrame%16];\n        vec3 SunDir = texture(iChannel0,vec2(8.5,0.5)*IRES).xyz;\n        vec3 Pos = texture(iChannel0,vec2(7.5,0.5)*IRES).xyz;\n        vec3 Eye = texture(iChannel0,vec2(6.5,0.5)*IRES).xyz;\n        vec3 Tan; vec3 Bit = TBN(Eye,Tan);\n        mat3 EyeMat = TBN(Eye);\n        vec3 LPos = texture(iChannel0,vec2(10.5,0.5)*IRES).xyz;\n        vec3 LEye = texture(iChannel0,vec2(9.5,0.5)*IRES).xyz;\n        vec3 LTan; vec3 LBit = TBN(LEye,LTan);\n        vec3 Dir = normalize(vec3(((fragCoord+SSOffset)*IRES*2.-1.)*(ASPECT*CFOV),1.)*EyeMat);\n        vec4 CAttr = texture(iChannel0,fragCoord*IRES);\n        if (CAttr.w>-0.5) {\n            //Geometry\n            vec3 PPos = Pos+Dir*CAttr.w;\n            vec3 Normal = normalize(FloatToVec3(CAttr.z)*2.-1.);\n            //\n            //Shadows\n            //\n            float ShadowLen = -1.;\n            vec3 RandV = ARand23(fragCoord*IRES*(1.+mod(CurrentFrame*7.253,9.234)));\n            vec3 RandDir = normalize(RandSampleCos(RandV.xy)*TBN(SunDir)*SunCR+SunDir);\n            if (dot(Normal,RandDir)>0.) {\n                HIT ShadHit = Trace(PPos+Normal*0.01,RandDir,iTime);\n                ShadowLen = ((ShadHit.C.x<0.)?10000.:ShadHit.D);\n            }\n            Output.y = ShadowLen;\n            //\n            //Reflections\n            //\n            vec3 RefC = vec3(0.);\n            float RefDist = -1.;\n            vec3 RefDir = reflect(Dir,Normal);\n            float RefCR = RefMaterial*min(1.,tan((HPI-acos(dot(RefDir,Normal)))));\n            RandDir = normalize(RandSampleCos(RandV.xy)*TBN(RefDir)*RefCR+RefDir);\n            if (dot(RandDir,Normal)<0.) RandDir = reflect(RandDir,Normal);\n            HIT Sample = Trace(PPos+Normal*0.01,RandDir,iTime);\n            if (Sample.C.x>=0.) {\n                //Geometry\n                RefDist = Sample.D;\n                //Screen space test\n                vec3 SSPos = PPos+RandDir*Sample.D-LPos;\n                SSPos = vec3(dot(SSPos,LTan),dot(SSPos,LBit),dot(SSPos,LEye));\n                vec2 Luv = ((SSPos.xy/SSPos.z)*0.5/(ASPECT*CFOV)+0.5)*RES-SSOffsets[(iFrame-1)%16];\n                float Weight = 0.;\n                vec3 SSLight = vec3(0.);\n                float SSDF = DFBox(Luv-vec2(0.,1.),RES-vec2(0.,1.));\n                if (SSPos.z>0. && SSDF<0.) {\n                    SSPos = PPos+RandDir*Sample.D-Pos;\n                    SSPos = vec3(dot(SSPos,Tan),dot(SSPos,Bit),dot(SSPos,Eye));\n                    vec2 CUV = ((SSPos.xy/SSPos.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n                    vec4 SSC = texture(iChannel0,(floor(CUV)+0.5)*IRES);\n                    Weight = max(0.,dot(normalize(FloatToVec3(SSC.z)*2.-1.),Sample.N)*10.-9.)*\n                             clamp(1.-SSDF*0.1,0.,1.)*float(length(SSPos)-SSC.w<0.2);\n                    vec2 SSC2 = texture(iChannel2,(floor(Luv)+0.5)*IRES).xy;\n                    SSLight = Sample.C*vec3(FloatToVec2(SSC2.x)*10.,SSC2.y);\n                }\n                vec3 WLight = vec3(0.);\n                if (dot(Sample.N,SunDir)>0.)\n                    WLight = Sample.C*SunLight*(dot(Sample.N,SunDir)*\n                            float(Trace(PPos+RandDir*Sample.D+Sample.N*0.01,SunDir,iTime).C.x<0.));\n                RefC += mix(WLight,SSLight,Weight);\n            } else {\n                //Sky\n                RefDist = 10000.;\n                RefC += SampleSky(RandDir,SunDir,iTime);\n            }\n            Output.z = Vec3ToFloat(RefC*ILightCoeff);\n            Output.w = RefDist;\n            //\n            //SVGF denoising\n            //\n            vec2 Moments;\n            vec3 LVPos0 = PPos-LPos;\n            LVPos0 = vec3(dot(LVPos0,LTan),dot(LVPos0,LBit),dot(LVPos0,LEye));\n            vec2 MoLuv = ((LVPos0.xy/LVPos0.z)*0.5/(ASPECT*CFOV)+0.5)*RES-SSOffsets[(iFrame-1)%16];\n            if (DFBox(MoLuv-vec2(0.,1.),RES-vec2(0.,1.))>0.) {\n                Moments = vec2(10.,0.);\n            } else {\n                Moments = texture(iChannel2,MoLuv*IRES).zw;\n            }\n            float Variance = abs(Moments.y-Moments.x*Moments.x);\n            vec3 CLight = vec3(FloatToVec2(CAttr.x)*LightCoeff,CAttr.y);\n            vec4 IDLight = vec4(CLight*2.,2.);\n            for (float x=-2.; x<2.5; x+=1.) {\n                for (float y=-2.; y<2.5; y+=1.) {\n                    if (x==0. && y==0.) continue;\n                    vec2 SUV = floor(fragCoord+vec2(x,y)*16.)+0.5;\n                    vec4 SC = texture(iChannel0,SUV*IRES);\n                    vec3 SNormal = normalize(FloatToVec3(SC.z)*2.-1.);\n                    vec3 SDir = normalize(vec3(((SUV+SSOffset)*IRES*2.-1.)*(ASPECT*CFOV),1.)*EyeMat);\n                    if (SC.w<-0.5 || DFBox(SUV-vec2(0.,1.),RES-vec2(0.,1.))>0.) continue;\n                    vec3 SLight = vec3(FloatToVec2(SC.x)*LightCoeff,SC.y);\n                    float SWeight = float(abs(dot(Pos+SDir*SC.w-PPos,Normal))<0.05)*\n                                   max(0.,dot(SNormal,Normal)*2.-1.)*exp(-length(CLight-SLight)/(0.1+VarCoeff*Variance));\n                    IDLight += vec4(SLight,1.)*SWeight;\n                }\n            }\n            IDLight.xyz /= IDLight.w;\n            Output.x = Vec3ToFloat(IDLight.xyz*ILightCoeff);\n        }\n    }\n    //Output\n    fragColor = Output;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//Denoising\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Output = vec4(0.);\n    if (fragCoord.y>1.) {\n        float CurrentFrame = float(iFrame);\n        vec2 SSOffset = SSOffsets[iFrame%16];\n        vec3 SunDir = texture(iChannel0,vec2(8.5,0.5)*IRES).xyz;\n        vec3 Pos = texture(iChannel0,vec2(7.5,0.5)*IRES).xyz;\n        vec3 Eye = texture(iChannel0,vec2(6.5,0.5)*IRES).xyz;\n        vec3 Tan; vec3 Bit = TBN(Eye,Tan);\n        mat3 EyeMat = TBN(Eye);\n        vec3 LPos = texture(iChannel0,vec2(10.5,0.5)*IRES).xyz;\n        vec3 LEye = texture(iChannel0,vec2(9.5,0.5)*IRES).xyz;\n        vec3 LTan; vec3 LBit = TBN(LEye,LTan);\n        vec3 Dir = normalize(vec3(((fragCoord+SSOffset)*IRES*2.-1.)*(ASPECT*CFOV),1.)*EyeMat);\n        vec4 CAttr = texture(iChannel0,fragCoord*IRES);\n        if (CAttr.w>-0.5) {\n            //Geometry\n            vec3 PPos = Pos+Dir*CAttr.w;\n            vec3 Normal = normalize(FloatToVec3(CAttr.z)*2.-1.);\n            vec4 LWPass = texture(iChannel1,fragCoord*IRES);\n            //\n            //Reflections denoising\n            //\n            vec4 RefC = vec4(FloatToVec3(LWPass.z)*LightCoeff*2.,2.);\n            vec3 RefDir = reflect(Dir,Normal);\n            float RefCR = RefMaterial*min(1.,tan((HPI-acos(dot(RefDir,Normal)))));\n            vec3 CVPos0 = vec3(LWPass.w*RefCR,0.,CAttr.w+LWPass.w)*TBN(Dir);\n            vec3 CVPos1 = vec3(-LWPass.w*RefCR,0.,CAttr.w+LWPass.w)*TBN(Dir);\n            vec3 LVPos0 = vec3(dot(CVPos0,Tan),dot(CVPos0,Bit),dot(CVPos0,Eye));\n            vec3 LVPos1 = vec3(dot(CVPos1,Tan),dot(CVPos1,Bit),dot(CVPos1,Eye));\n            vec2 Luv0 = ((LVPos0.xy/LVPos0.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n            vec2 Luv1 = ((LVPos1.xy/LVPos1.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n            float HalfRadius = min(32.,length(Luv0-Luv1)*0.5)*0.5;\n            for (float x=-2.; x<2.5; x+=1.) {\n                for (float y=-2.; y<2.5; y+=1.) {\n                    if (x==0. && y==0.) continue;\n                    vec2 Offset2 = normalize(vec2(x,y))*max(abs(x),abs(y))*HalfRadius;\n                    vec2 SUV = floor(fragCoord+Offset2)+0.5;\n                    vec4 SC = texture(iChannel0,SUV*IRES);\n                    vec3 SNormal = normalize(FloatToVec3(SC.z)*2.-1.);\n                    vec3 SDir = normalize(vec3(((SUV+SSOffset)*IRES*2.-1.)*(ASPECT*CFOV),1.)*EyeMat);\n                    if (SC.w<-0.5 || DFBox(SUV-vec2(0.,1.),RES-vec2(0.,1.))>0.) continue;\n                    vec4 SRefShad = texture(iChannel1,SUV*IRES);\n                    vec2 SRand = ARand23(SUV*IRES*(1.+mod(CurrentFrame*7.253,9.234))).xy;\n                    vec3 SRefDir = reflect(SDir,SNormal);\n                    float SCR = RefMaterial*min(1.,tan((HPI-acos(dot(RefDir,Normal)))));\n                    vec3 SRDir = normalize(RandSampleCos(SRand)*TBN(SRefDir)*SCR+SRefDir);\n                    vec3 HitP = Pos+SDir*SC.w+SNormal*0.01+SRDir*SRefShad.w;\n                    if (dot(HitP-PPos,Normal)<=0.) continue;\n                    if (sqrt(1./dot(normalize(HitP-PPos),RefDir)-1.)<=RefCR) RefC += vec4(FloatToVec3(SRefShad.z)*LightCoeff,1.);\n                }\n            }\n            RefC.xyz /= RefC.w;\n            Output.w = Vec3ToFloat(RefC.xyz*ILightCoeff);\n            //\n            //Shadow denoising\n            //\n            vec2 Shad = vec2(float(LWPass.y>999.)*2.,2.);\n            CVPos0 = vec3(LWPass.y*SunCR,0.,CAttr.w)*TBN(Dir);\n            CVPos1 = vec3(-LWPass.y*SunCR,0.,CAttr.w)*TBN(Dir);\n            LVPos0 = vec3(dot(CVPos0,Tan),dot(CVPos0,Bit),dot(CVPos0,Eye));\n            LVPos1 = vec3(dot(CVPos1,Tan),dot(CVPos1,Bit),dot(CVPos1,Eye));\n            Luv0 = ((LVPos0.xy/LVPos0.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n            Luv1 = ((LVPos1.xy/LVPos1.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n            HalfRadius = max(1.2,min(32.,length(Luv0-Luv1)*0.5)*0.5);\n            for (float x=-2.; x<2.5; x+=1.) {\n                for (float y=-2.; y<2.5; y+=1.) {\n                    if (x==0. && y==0.) continue;\n                    vec2 Offset2 = normalize(vec2(x,y))*max(abs(x),abs(y))*HalfRadius;\n                    vec2 SUV = floor(fragCoord+Offset2)+0.5;\n                    vec4 SC = texture(iChannel0,SUV*IRES);\n                    vec3 SNormal = normalize(FloatToVec3(SC.z)*2.-1.);\n                    vec3 SDir = normalize(vec3(((SUV+SSOffset)*IRES*2.-1.)*(ASPECT*CFOV),1.)*EyeMat);\n                    if (SC.w<-0.5 || DFBox(SUV-vec2(0.,1.),RES-vec2(0.,1.))>0. || abs(dot(Pos+SDir*SC.w-PPos,Normal))>0.19) continue;\n                    vec4 SLWPass = texture(iChannel1,SUV*IRES);\n                    vec2 SRand = ARand23(SUV*IRES*(1.+mod(CurrentFrame*7.253,9.234))).xy;\n                    vec3 HitP = Pos+SDir*SC.w+SNormal*0.01+normalize(RandSampleCos(SRand.xy)*TBN(SunDir)*SunCR+SunDir)*SLWPass.y;\n                    if (dot(HitP-PPos,Normal)<=0.) continue;\n                    if (sqrt(1./dot(normalize(HitP-PPos),SunDir)-1.)<=SunCR) Shad += vec2(float(SLWPass.y>999.),1.);\n                }\n            }\n            Output.z = Shad.x/Shad.y;\n            //\n            //SVGF denoising\n            //\n            vec2 Moments;\n            LVPos0 = PPos-LPos;\n            LVPos0 = vec3(dot(LVPos0,LTan),dot(LVPos0,LBit),dot(LVPos0,LEye));\n            vec2 MoLuv = ((LVPos0.xy/LVPos0.z)*0.5/(ASPECT*CFOV)+0.5)*RES-SSOffsets[(iFrame-1)%16];\n            if (DFBox(MoLuv-vec2(0.,1.),RES-vec2(0.,1.))>0.) {\n                Moments = vec2(10.,0.);\n            } else {\n                Moments = texture(iChannel2,MoLuv*IRES).zw;\n            }\n            float Variance = abs(Moments.y-Moments.x*Moments.x);\n            vec3 CLight = FloatToVec3(LWPass.x)*LightCoeff;\n            vec4 IDLight = vec4(CLight*2.,2.);\n            for (float x=-2.; x<2.5; x+=1.) {\n                for (float y=-2.; y<2.5; y+=1.) {\n                    if (x==0. && y==0.) continue;\n                    vec2 SUV = floor(fragCoord+vec2(x,y)*4.)+0.5;\n                    vec4 SC = texture(iChannel0,SUV*IRES);\n                    vec3 SNormal = normalize(FloatToVec3(SC.z)*2.-1.);\n                    vec3 SDir = normalize(vec3(((SUV+SSOffset)*IRES*2.-1.)*(ASPECT*CFOV),1.)*EyeMat);\n                    if (SC.w<-0.5 || DFBox(SUV-vec2(0.,1.),RES-vec2(0.,1.))>0.) continue;\n                    vec2 SC2 = texture(iChannel1,SUV*IRES).xy;\n                    vec3 SLight = FloatToVec3(SC2.x)*LightCoeff;\n                    float SWeight = exp(-abs(dot(Pos+SDir*SC.w-PPos,Normal))*20.)*\n                                   max(0.,dot(SNormal,Normal)*2.-1.)*exp(-length(CLight-SLight)/(0.1+VarCoeff*Variance));\n                    IDLight += vec4(SLight,1.)*SWeight;\n                }\n            }\n            IDLight.xyz /= IDLight.w;\n            Output.xy = vec2(Vec2ToFloat(IDLight.xy*ILightCoeff),IDLight.z);\n        }\n    }\n    //Output\n    fragColor = Output;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//Denoising and composition\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Output = vec4(0.,0.,0.,8.);\n    if (fragCoord.y>1. && iFrame>3+BuildFrames) {\n        float CurrentFrame = float(iFrame);\n        vec2 SSOffset = SSOffsets[iFrame%16];\n        vec3 SunDir = texture(iChannel0,vec2(8.5,0.5)*IRES).xyz;\n        vec3 Pos = texture(iChannel0,vec2(7.5,0.5)*IRES).xyz;\n        vec3 Eye = texture(iChannel0,vec2(6.5,0.5)*IRES).xyz;\n        vec3 Tan; vec3 Bit = TBN(Eye,Tan);\n        mat3 EyeMat = TBN(Eye);\n        vec3 LPos = texture(iChannel0,vec2(10.5,0.5)*IRES).xyz;\n        vec3 LEye = texture(iChannel0,vec2(9.5,0.5)*IRES).xyz;\n        vec3 LTan; vec3 LBit = TBN(LEye,LTan);\n        vec3 Dir = normalize(vec3(((fragCoord+SSOffset)*IRES*2.-1.)*(ASPECT*CFOV),1.)*EyeMat);\n        vec4 CAttr = texture(iChannel0,fragCoord*IRES);\n        if (CAttr.w>-0.5) {\n            //Geometry\n            vec3 PPos = Pos+Dir*CAttr.w;\n            vec3 Normal = normalize(FloatToVec3(CAttr.z)*2.-1.);\n            vec4 LWPass = texture(iChannel1,fragCoord*IRES);\n            //\n            //Reflections denoising\n            //\n            vec4 RefC = vec4(FloatToVec3(texture(iChannel2,fragCoord*IRES).w)*LightCoeff*2.,2.);\n            vec3 RefDir = reflect(Dir,Normal);\n            float RefCR = RefMaterial*min(1.,tan((HPI-acos(dot(RefDir,Normal)))));\n            vec3 CVPos0 = vec3(LWPass.w*RefCR,0.,CAttr.w+LWPass.w)*TBN(Dir);\n            vec3 CVPos1 = vec3(-LWPass.w*RefCR,0.,CAttr.w+LWPass.w)*TBN(Dir);\n            vec3 LVPos0 = vec3(dot(CVPos0,Tan),dot(CVPos0,Bit),dot(CVPos0,Eye));\n            vec3 LVPos1 = vec3(dot(CVPos1,Tan),dot(CVPos1,Bit),dot(CVPos1,Eye));\n            vec2 Luv0 = ((LVPos0.xy/LVPos0.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n            vec2 Luv1 = ((LVPos1.xy/LVPos1.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n            float HalfRadius = min(8.,length(Luv0-Luv1)*0.5)*0.5;\n            for (float x=-2.; x<2.5; x+=1.) {\n                for (float y=-2.; y<2.5; y+=1.) {\n                    if (x==0. && y==0.) continue;\n                    vec2 Offset2 = normalize(vec2(x,y))*max(abs(x),abs(y))*HalfRadius;\n                    vec2 SUV = floor(fragCoord+Offset2)+0.5;\n                    vec4 SC = texture(iChannel0,SUV*IRES);\n                    vec3 SNormal = normalize(FloatToVec3(SC.z)*2.-1.);\n                    vec3 SDir = normalize(vec3(((SUV+SSOffset)*IRES*2.-1.)*(ASPECT*CFOV),1.)*EyeMat);\n                    if (SC.w<-0.5 || DFBox(SUV-vec2(0.,1.),RES-vec2(0.,1.))>0.) continue;\n                    vec4 SRefShad = texture(iChannel1,SUV*IRES);\n                    vec2 SRand = ARand23(SUV*IRES*(1.+mod(CurrentFrame*7.253,9.234))).xy;\n                    vec3 SRefDir = reflect(SDir,SNormal);\n                    float SCR = RefMaterial*min(1.,tan((HPI-acos(dot(RefDir,Normal)))));\n                    vec3 SRDir = normalize(RandSampleCos(SRand)*TBN(SRefDir)*SCR+SRefDir);\n                    vec3 HitP = Pos+SDir*SC.w+SNormal*0.01+SRDir*SRefShad.w;\n                    if (dot(HitP-PPos,Normal)<=0.) continue;\n                    if (sqrt(1./dot(normalize(HitP-PPos),RefDir)-1.)<=RefCR)\n                        RefC += vec4(FloatToVec3(texture(iChannel2,SUV*IRES).w)*LightCoeff,1.);\n                }\n            }\n            RefC.xyz /= RefC.w;\n            //\n            //Shadow denoising\n            //\n            vec2 Shad = vec2(texture(iChannel2,fragCoord*IRES).z*2.,2.);\n            CVPos0 = vec3(LWPass.y*SunCR,0.,CAttr.w)*TBN(Dir);\n            CVPos1 = vec3(-LWPass.y*SunCR,0.,CAttr.w)*TBN(Dir);\n            LVPos0 = vec3(dot(CVPos0,Tan),dot(CVPos0,Bit),dot(CVPos0,Eye));\n            LVPos1 = vec3(dot(CVPos1,Tan),dot(CVPos1,Bit),dot(CVPos1,Eye));\n            Luv0 = ((LVPos0.xy/LVPos0.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n            Luv1 = ((LVPos1.xy/LVPos1.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n            HalfRadius = max(1.2,min(8.,length(Luv0-Luv1)*0.5)*0.5);\n            for (float x=-2.; x<2.5; x+=1.) {\n                for (float y=-2.; y<2.5; y+=1.) {\n                    if (x==0. && y==0.) continue;\n                    vec2 Offset2 = normalize(vec2(x,y))*max(abs(x),abs(y))*HalfRadius;\n                    vec2 SUV = floor(fragCoord+Offset2)+0.5;\n                    vec4 SC = texture(iChannel0,SUV*IRES);\n                    vec3 SNormal = normalize(FloatToVec3(SC.z)*2.-1.);\n                    vec3 SDir = normalize(vec3(((SUV+SSOffset)*IRES*2.-1.)*(ASPECT*CFOV),1.)*EyeMat);\n                    if (SC.w<-0.5 || DFBox(SUV-vec2(0.,1.),RES-vec2(0.,1.))>0. || abs(dot(Pos+SDir*SC.w-PPos,Normal))>0.19) continue;\n                    vec4 SLWPass = texture(iChannel1,SUV*IRES);\n                    vec2 SRand = ARand23(SUV*IRES*(1.+mod(CurrentFrame*7.253,9.234))).xy;\n                    vec3 HitP = Pos+SDir*SC.w+SNormal*0.01+normalize(RandSampleCos(SRand.xy)*TBN(SunDir)*SunCR+SunDir)*SLWPass.y;\n                    if (dot(HitP-PPos,Normal)<=0.) continue;\n                    if (sqrt(1./dot(normalize(HitP-PPos),SunDir)-1.)<=SunCR) Shad += vec2(texture(iChannel2,SUV*IRES).z,1.);\n                }\n            }\n            Shad.x /= Shad.y;\n            //\n            //SVGF denoising (no variance weight)\n            //\n            vec2 tmpSC2 = texture(iChannel2,fragCoord*IRES).xy;\n            vec4 IDLight = vec4(FloatToVec2(tmpSC2.x)*LightCoeff*2.,tmpSC2.y*2.,2.);\n            for (float x=-2.; x<2.5; x+=1.) {\n                for (float y=-2.; y<2.5; y+=1.) {\n                    if (x==0. && y==0.) continue;\n                    vec2 SUV = floor(fragCoord+vec2(x,y))+0.5;\n                    vec4 SC = texture(iChannel0,SUV*IRES);\n                    vec3 SNormal = normalize(FloatToVec3(SC.z)*2.-1.);\n                    vec3 SDir = normalize(vec3(((SUV+SSOffset)*IRES*2.-1.)*(ASPECT*CFOV),1.)*EyeMat);\n                    if (SC.w<-0.5 || DFBox(SUV-vec2(0.,1.),RES-vec2(0.,1.))>0.) continue;\n                    float SWeight = exp(-abs(dot(Pos+SDir*SC.w-PPos,Normal))*20.)*\n                                   max(0.,dot(SNormal,Normal)*2.-1.);\n                    vec2 SC2 = texture(iChannel2,SUV*IRES).xy;\n                    IDLight += vec4(vec3(FloatToVec2(SC2.x)*LightCoeff,SC2.y),1.)*SWeight;\n                }\n            }\n            IDLight.xyz /= IDLight.w;\n            //\n            //Composition\n            //\n            vec3 DLight = Shad.x*max(0.,dot(Normal,SunDir))*SunLight;\n            vec3 Composition = mix(DLight+IDLight.xyz,RefC.xyz,SchlickFresnel(vec3(0.1),max(0.,dot(Normal,-Dir))));\n            Output.xy = vec2(Vec2ToFloat(Composition.xy*0.1),min(Composition.z,10.));\n            //\n            //Update moments\n            //\n            LVPos0 = PPos-LPos;\n            LVPos0 = vec3(dot(LVPos0,LTan),dot(LVPos0,LBit),dot(LVPos0,LEye));\n            Luv0 = ((LVPos0.xy/LVPos0.z)*0.5/(ASPECT*CFOV)+0.5)*RES-SSOffsets[(iFrame-1)%16];\n            if (DFBox(Luv0-vec2(0.,1.),RES-vec2(0.,1.))>0.) {\n                //Outside screen\n                Output.zw = vec2(0.,8.);\n            } else {\n                //Naive reprojection, without attributes we can't validate\n                vec2 LastMoments = texture(iChannel3,Luv0*IRES).zw;\n                float Lum = dot(vec3(FloatToVec2(CAttr.x)*LightCoeff,CAttr.y),vec3(0.3333));\n                Output.zw = (LastMoments*20.+vec2(Lum,Lum*Lum))/24.;\n            }\n        } else {\n            //Sky\n            vec3 Composition = SampleSky(Dir,SunDir,iTime);\n            Output.xy = vec2(Vec2ToFloat(Composition.xy*0.1),Composition.z);\n        }\n    }\n    //Output\n    fragColor = Output;\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"//SDF volume and TAA\n\nvec4 textureCube(vec2 UV) {\n    //Samples the cubemap\n    float Sign = -mod(floor(UV.y*I1024),2.)*2.+1.;\n    vec3 D = vec3(vec2(UV.x,mod(UV.y,1024.))*I512-1.,Sign);\n    if (UV.y>4096.) D = D.xzy;\n    else if (UV.y>2048.) D = D.zxy;\n    return texture(iChannel3,D);\n}\n\nvec4 sampleLevel0(vec2 PriorUV) {\n    float YOffset = 2048.+floor(PriorUV.x*I1024)*1024.+floor(PriorUV.y*I1024)*2048.;\n    return textureCube(mod(PriorUV,1024.)+vec2(0.,YOffset));\n}\n\nvoid MIN(inout vec2 Out, vec2 In) {\n    Out = ((Out.x<In.x)?Out:In);\n}\n\nvec4 SampleTextureCatmullRom(vec2 uv) {\n    vec2 samplePos = uv;\n    vec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n    vec2 f = samplePos - texPos1;\n    vec2 w0 = f * ( -0.5 + f * (1.0 - 0.5*f));\n    vec2 w1 = 1.0 + f * f * (-2.5 + 1.5*f);\n    vec2 w2 = f * ( 0.5 + f * (2.0 - 1.5*f) );\n    vec2 w3 = f * f * (-0.5 + 0.5 * f);\n    vec2 w12 = w1 + w2;\n    vec2 offset12 = w2 / w12;\n    vec2 texPos0 = texPos1 - vec2(1.0);\n    vec2 texPos3 = texPos1 + vec2(2.0);\n    vec2 texPos12 = texPos1 + offset12;\n    vec4 result = vec4(0.);\n    result += sampleLevel0( vec2(texPos0.x,  texPos0.y)) * w0.x * w0.y;\n    result += sampleLevel0( vec2(texPos12.x, texPos0.y)) * w12.x * w0.y;\n    result += sampleLevel0( vec2(texPos3.x,  texPos0.y)) * w3.x * w0.y;\n    result += sampleLevel0( vec2(texPos0.x,  texPos12.y)) * w0.x * w12.y;\n    result += sampleLevel0( vec2(texPos12.x, texPos12.y)) * w12.x * w12.y;\n    result += sampleLevel0( vec2(texPos3.x,  texPos12.y)) * w3.x * w12.y;\n    result += sampleLevel0( vec2(texPos0.x,  texPos3.y)) * w0.x * w3.y;\n    result += sampleLevel0( vec2(texPos12.x, texPos3.y)) * w12.x * w3.y;\n    result += sampleLevel0( vec2(texPos3.x,  texPos3.y)) * w3.x * w3.y;\n    return max(vec4(0.,0.,0.,1.),result);\n}\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir) {\n    vec4 Output = texture(iChannel3,rayDir);\n    vec2 UV; vec3 aDir = abs(rayDir);\n    if (aDir.z>max(aDir.x,aDir.y)) {\n        //Z-side\n        UV = floor(((rayDir.xy/aDir.z)*0.5+0.5)*1024.)+0.5;\n        if (rayDir.z<0.) UV.y += 1024.;\n    } else if (aDir.x>aDir.y) {\n        //X-side\n        UV = floor(((rayDir.yz/aDir.x)*0.5+0.5)*1024.)+0.5;\n        if (rayDir.x>0.) UV.y += 2048.;\n        else UV.y += 3072.;\n    } else {\n        //Y-side\n        UV = floor(((rayDir.xz/aDir.y)*0.5+0.5)*1024.)+0.5;\n        if (rayDir.y>0.) UV.y += 4096.;\n        else UV.y += 5120.;\n    }\n    //SDF volume\n    if (DFBox(UV,vec2(1012.,2037.))<0.) {\n        //SDF\n        vec3 Pos1 = vec3(floor(mod(UV.y,97.))/96.,(floor(UV.x/253.)+4.*floor(UV.y/97.))/80.\n                        ,floor(mod(UV.x,253.))/252.)*vec3(8.,6.4,21.);\n        //Brick injection\n        if (iFrame<2) {\n            Output = vec4(1000.);\n        } else if (iFrame<2+BuildFrames) {\n            for (int bi=(iFrame-2)*32; bi<(iFrame-1)*32; bi++) {\n                BRICK CBrick;\n                if (bi<128)\n                    CBrick = BrickArray0[bi];\n                else\n                    CBrick = BrickArray1[bi-128];\n                //Offset hacking for more bricks\n                CBrick.P.y -= 0.32;\n                //Read brick attributes\n                float ColorIndex = float(CBrick.C)+0.5;\n                float CBrickIndexf = float(CBrick.I);\n                int CBrickIndex = CBrick.I;\n                vec3 CBrickSize = vec3(0.);\n                if (CBrickIndex<28)\n                    CBrickSize = vec3(BrickADim[CBrickIndex%7],0.8+0.8*floor(CBrickIndexf/14.),1.+mod(floor(CBrickIndexf/7.),2.));\n                else if (CBrickIndex<56)\n                    CBrickSize = vec3(BrickADim[CBrickIndex%7],0.8+0.8*floor((CBrickIndexf-28.)/14.),\n                                      1.+mod(floor((CBrickIndexf-28.)/7.),2.));\n                else\n                    CBrickSize = BrickDim[CBrickIndex-56];\n                //Semi-quaternion\n                vec4 Q = vec4(CBrick.Q,0.);\n                Q = vec4(normalize(vec3(Q.x,fract(abs(Q.y))*sign(Q.y),Q.z)),floor(abs(Q.y))*ToRadians);\n                vec3 CX = Q.xyz;\n                vec2 sincos = vec2(sin(Q.w),cos(Q.w));\n                vec3 RefCZ = normalize(cross(CX,vec3(0.,1.,0.)));\n                vec3 RefCY = cross(RefCZ,CX);\n                vec3 CY = sincos.y*RefCY+sincos.x*RefCZ;\n                vec3 CZ = -sincos.x*RefCY+sincos.y*RefCZ;\n                \n                //Pos1\n                vec3 BRPos = Pos1-CBrick.P;\n                BRPos = BRPos.x*vec3(CX.x,CY.x,CZ.x)+BRPos.y*vec3(CX.y,CY.y,CZ.y)+BRPos.z*vec3(CX.z,CY.z,CZ.z);\n                //Sample SDF\n                if (CBrickIndex<28)       MIN(Output.xy,vec2(DFBrick(BRPos,CBrickSize),ColorIndex));\n                else if (CBrickIndex<56)  MIN(Output.xy,vec2(DFBrick_NoStud(BRPos,CBrickSize),ColorIndex));\n                else if (CBrickIndex==56) MIN(Output.xy,vec2(DFGrate(BRPos),ColorIndex));\n                else if (CBrickIndex==60) MIN(Output.xy,vec2(DFRound111(BRPos),ColorIndex));\n                else if (CBrickIndex==61) MIN(Output.xy,vec2(DFRound131(BRPos),ColorIndex));\n                else if (CBrickIndex==62) MIN(Output.xy,vec2(DFCone131(BRPos),ColorIndex));\n                else if (CBrickIndex<=70) MIN(Output.xy,vec2(10000.,ColorIndex));\n                else if (CBrickIndex==71) MIN(Output.xy,vec2(10000.,ColorIndex));\n                else if (CBrickIndex<=73) MIN(Output.xy,vec2(DFISlope(BRPos,CBrickSize.z),ColorIndex));\n                else if (CBrickIndex==74) MIN(Output.xy,vec2(DFOnlySlope(BRPos),ColorIndex));\n                else if (CBrickIndex==75) MIN(Output.xy,vec2(DFHeadLight(BRPos),ColorIndex));\n                else if (CBrickIndex==76) MIN(Output.xy,vec2(DFHose(BRPos),ColorIndex));\n                else if (CBrickIndex<=81) MIN(Output.xy,vec2(10000.,ColorIndex));\n                else if (CBrickIndex==83) MIN(Output.xy,vec2(10000.,ColorIndex));\n                else if (CBrickIndex==84) MIN(Output.xy,vec2(DFPanel(BRPos),ColorIndex));\n                else if (CBrickIndex<=86) MIN(Output.xy,vec2(10000.,ColorIndex));\n                else if (CBrickIndex==87) MIN(Output.xy,vec2(10000.,ColorIndex));\n                else if (CBrickIndex==88) MIN(Output.xy,vec2(10000.,ColorIndex));\n                else if (CBrickIndex==89) MIN(Output.xy,vec2(DFDoor(BRPos),ColorIndex));\n                else if (CBrickIndex<=91) MIN(Output.xy,vec2(DFHandle(BRPos,CBrickIndexf-91.),ColorIndex));\n                else if (CBrickIndex==92) MIN(Output.xy,vec2(DFGrip(BRPos),ColorIndex));\n                else if (CBrickIndex<=94) MIN(Output.xy,vec2(DFDisk(BRPos),ColorIndex));\n                else if (CBrickIndex==95) MIN(Output.xy,vec2(10000.,ColorIndex));\n                else if (CBrickIndex==96) MIN(Output.xy,vec2(10000.,ColorIndex));\n                else if (CBrickIndex<=100) MIN(Output.xy,vec2(DFPanelWall(BRPos,CBrickSize),ColorIndex));\n            }\n        } else if (iFrame<3+BuildFrames) {\n            //Copy next layer for output.zw\n            vec2 tmpUV = vec2(mod(UV.x+253.,1012.),UV.y+float(UV.x+253.>1012.)*97.);\n            Output.zw = textureCube(tmpUV).xy;\n        }\n    } else if (UV.y>2048.) {\n        //TAA\n        vec2 RESOffset = vec2((mod(floor((UV.y-2048.)*I1024)+0.5,2.)-0.5)*1024.,\n                              floor((UV.y-2048.)*I1024*0.5)*1024.);\n        vec2 CUV = mod(UV,1024.)+RESOffset;\n        if (DFBox(CUV-3.,RES-6.)<0.) {\n            //Inside the screen\n            vec2 BCRef = texture(iChannel2,CUV*IRES).xy;\n            vec3 FinalColor = vec3(FloatToVec2(BCRef.x)*10.,BCRef.y);\n            //Reprojection\n            float CurrentFrame = float(iFrame);\n            vec2 SSOffset = SSOffsets[iFrame%16];\n            vec3 Pos = texture(iChannel0,vec2(7.5,0.5)*IRES).xyz;\n            vec3 Eye = texture(iChannel0,vec2(6.5,0.5)*IRES).xyz;\n            vec3 Tan; vec3 Bit = TBN(Eye,Tan);\n            mat3 EyeMat = TBN(Eye);\n            vec3 PriorPos = texture(iChannel0,vec2(10.5,0.5)*IRES).xyz;\n            vec3 PriorEye = texture(iChannel0,vec2(9.5,0.5)*IRES).xyz;\n            vec3 PriorTan; vec3 PriorBit = TBN(PriorEye,PriorTan);\n            mat3 PriorEyeMat = TBN(PriorEye);\n            vec3 Dir = normalize(vec3(((CUV+SSOffset)*IRES*2.-1.)*CFOV*ASPECT,1.)*EyeMat);\n            vec4 CAttr = texture(iChannel0,CUV*IRES);\n            float Distance = CAttr.w;\n            if (Distance<-0.5) Distance = 100000.; //Sky pixel\n            vec3 PPos = Pos+Dir*Distance;\n            vec3 Normal = normalize(FloatToVec3(CAttr.z)*2.-1.);\n            //Color multiplication\n            if (Distance<9999.) {\n                float SVal = (PPos.y/6.4)*80.+0.5;\n                vec2 UVmod = 0.5+floor((PPos.zx/vec2(21.,8.))*vec2(252.,96.)+0.5);\n                vec2 UVSlice0 = vec2(min(floor(mod(SVal,4.)),3.)*253.,min(floor(SVal/4.),20.)*97.);\n                FinalColor *= BrickColorArray[int(floor(textureCube(UVmod+UVSlice0).y))];\n            }\n            //Prior position\n            vec3 PriorVPos = vec3(dot(PPos-PriorPos,PriorTan),dot(PPos-PriorPos,PriorBit),dot(PPos-PriorPos,PriorEye));\n            vec2 PriorUV = ((PriorVPos.xy/PriorVPos.z)*0.5/(ASPECT*CFOV)+0.5)*RES;\n            if (DFBox(PriorUV-3.,RES-6.)<0.) {\n                //Valid reprojection\n                vec4 LFinalColor;\n                if (length(PriorUV-CUV-SSOffset)>0.02) {\n                    //Catmull-rom sampling\n                    PriorUV -= SSOffsets[(iFrame-1)%16];\n                    LFinalColor = SampleTextureCatmullRom(PriorUV);\n                } else {\n                    //Nearest neighbour sampling\n                    PriorUV = floor(PriorUV)+0.5;\n                    float YOffset = 2048.+floor(PriorUV.x*I1024)*1024.+floor(PriorUV.y*I1024)*2048.;\n                    LFinalColor = textureCube(mod(PriorUV,1024.)+vec2(0.,YOffset));\n                }\n                //Clamping\n                vec3 FMIN = vec3(1000.);\n                vec3 FMAX = vec3(0.);\n                for (float x=-1.; x<1.5; x+=1.) {\n                    for (float y=-1.; y<1.5; y+=1.) {\n                        BCRef = texture(iChannel2,(CUV+vec2(x,y))*IRES).xy;\n                        vec3 Sample = vec3(FloatToVec2(BCRef.x)*10.,BCRef.y);\n                        //Color\n                        vec3 SDir = normalize(vec3(((CUV+vec2(x,y)+SSOffset)*IRES*2.-1.)*CFOV*ASPECT,1.)*EyeMat);\n                        vec4 SAttr = texture(iChannel0,(CUV+vec2(x,y))*IRES);\n                        if (SAttr.w>-0.5) {\n                            vec3 SPPos = Pos+SDir*SAttr.w;\n                            float SVal = (SPPos.y/6.4)*80.+0.5;\n                            vec2 UVmod = 0.5+floor((SPPos.zx/vec2(21.,8.))*vec2(252.,96.)+0.5);\n                            vec2 UVSlice0 = vec2(min(floor(mod(SVal,4.)),3.)*253.,min(floor(SVal/4.),20.)*97.);\n                            Sample *= BrickColorArray[int(floor(textureCube(UVmod+UVSlice0).y))];\n                        }\n                        //Clamp\n                        FMIN = min(FMIN,Sample);\n                        FMAX = max(FMAX,Sample);\n                    }\n                }\n                LFinalColor.xyz = clamp(LFinalColor.xyz,FMIN,FMAX);\n                //Output\n                Output = vec4((FinalColor+LFinalColor.xyz*LFinalColor.w)/(LFinalColor.w+1.),min(31.,LFinalColor.w+1.));\n            } else {\n                //Invalid reprojection\n                Output = vec4(FinalColor,1.);\n            }\n        }\n    }\n    //Output\n    fragColor = Output;\n}","name":"Cube A","description":"","type":"cubemap"}]}