{"ver":"0.1","info":{"id":"M3BXWG","date":"1710992930","viewed":42,"name":"Raymarched Normals","username":"Smiley98","description":"Normals be jammin.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A very small number.\n// Various use cases, but we use it to evaluate our scene within a small radius of a point to estimate a surface's normals\nconst float EPSILON = 0.0001;\nconst float NEAR = 0.001;\nconst float FAR = 100.0;\n\nfloat sdSphere(vec3 p, float r)\n{\n  return length(p) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat map(vec3 p)\n{\n    float ground = p.y + 0.75;\n    vec3 spherePosition = vec3(/*sin(iTime) * 3.0*/0.0, 0.0, 0.0);\n    float sphere = sdSphere(p - spherePosition, 1.0);\n    return min(sphere, ground);\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n        map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n        map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // [0, 1] --> [-1, 1]\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    // Ray origin\n    vec3 ro = vec3(0.0, 0.0, -3.0);\n    \n    // FoV of 90 degrees\n    float fov = tan(45.0 * 3.14 / 180.0);\n    \n    // Ray direction\n    vec3 rd = normalize(vec3(uv * fov, 1.0));\n    \n    // Distance along ray\n    float t = 0.0;\n    \n    for (int i = 0; i < 80; i++)\n    {\n        // Scene position\n        vec3 p = ro + rd * t;\n        \n        // Determine maxmimum safe stepping distance\n        float d = map(p);\n        \n        // Step along ray by distance d\n        t += d;\n        \n        // Intersection if distance is very close to surface (SDF --> -1)\n        if (d < NEAR) break;\n        \n        // No intersection if distance along ray exceeds view distance\n        if (t > FAR) break;\n    }\n    \n    vec3 p = ro + rd * t;\n    vec3 fgColor = estimateNormal(p) * 0.5 + 0.5;\n    vec3 bgColor = vec3(0.25, 0.25, 0.25);\n    \n    bool hit = t < FAR - EPSILON;\n    vec3 color = hit ? fgColor : bgColor;\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}