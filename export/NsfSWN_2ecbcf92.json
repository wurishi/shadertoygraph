{"ver":"0.1","info":{"id":"NsfSWN","date":"1618617135","viewed":139,"name":"Fast Gaussian separable blur ","username":"scherzo","description":"This separable blur uses linear filtering hardware to average two texels in one fetch. It's a direct implementation of http://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/ referenced by iq.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["2d","blur","multipass"],"hasliked":0,"parentid":"Xd33Rf","parentname":"Fast Separable Blur"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// See: https://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/\n// See: https://www.shadertoy.com/view/Xd33Rf\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n//\n// Vertical blur pass + composite\n//\n\nconst int taps = 3;\nconst float offset[3] = float[](0.0, 1.3846153846, 3.2307692308);\nconst float weight[3] = float[](0.2270270270, 0.3162162162, 0.0702702703);\n\n//const int taps = 4;\n//const float offset[4] = float[](0.0, 1.4117647058823528, 3.2941176470588234, 5.176470588235294);\n//const float weight[4] = float[](0.1964795505549364, 0.2969024319496817, 0.09446895562035326, 0.010381203914324535);\n\n//const int taps = 9;\n//const float weight[9] = float[](0.2507413753093973, 0.18561374535890446, 0.09146184553917033, 0.02954921163573195, 0.0060974563692780225, 0.0007709427593340027, 0.00005595552285488729, 0.0000020945917646214494, 3.3247488327324596e-8);\n//const float offset[9] = float[](0.4871794871794872, 2.435897435897436, 4.384615384615385, 6.333333333333333, 8.282051282051281, 10.230769230769232, 12.17948717948718, 14.128205128205128, 16.076923076923077);\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord;\n    vec3 blr = vec3(0.0);\n    \n    // Offset the texel coordinates to sample the weighted average of two texels, \n    // levaraging the bilinear filtering hardware\n    blr += texture( iChannel0, fragCoord/iResolution.xy ).rgb * weight[0];\n    for (int i=1; i<taps; i++) {\n      blr += texture( iChannel0, (fragCoord + vec2(0.0, offset[i]))/iResolution.xy).rgb * weight[i]; \n      blr += texture( iChannel0, (fragCoord - vec2(0.0, offset[i]))/iResolution.xy).rgb * weight[i];\n    }     \n\n    fragColor = vec4( blr, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// See: https://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/\n// See: https://www.shadertoy.com/view/Xd33Rf\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    \n    p.x += 0.1*sin(6.0*p.y + 0.5*iTime);\n    p.y += 0.5*sin(4.0*p.x + 0.5*iTime);\n    \n    vec3 col = texture( iChannel0, p ).zyx * 1.5;\n\n    fragColor = vec4( col, 1.0 );\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// See: https://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/\n// See: https://www.shadertoy.com/view/Xd33Rf\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n//\n// Horizontal blur pass. \n//\n\nconst int taps = 3;\nconst float offset[3] = float[](0.0, 1.3846153846, 3.2307692308);\nconst float weight[3] = float[](0.2270270270, 0.3162162162, 0.0702702703);\n\n//const int taps = 4;\n//const float offset[4] = float[](0.0, 1.4117647058823528, 3.2941176470588234, 5.176470588235294);\n//const float weight[4] = float[](0.1964795505549364, 0.2969024319496817, 0.09446895562035326, 0.010381203914324535);\n\n//const int taps = 9;\n//const float weight[9] = float[](0.2507413753093973, 0.18561374535890446, 0.09146184553917033, 0.02954921163573195, 0.0060974563692780225, 0.0007709427593340027, 0.00005595552285488729, 0.0000020945917646214494, 3.3247488327324596e-8);\n//const float offset[9] = float[](0.4871794871794872, 2.435897435897436, 4.384615384615385, 6.333333333333333, 8.282051282051281, 10.230769230769232, 12.17948717948718, 14.128205128205128, 16.076923076923077);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord;\n    vec3 blr = vec3(0.0);\n    \n    // Offset the texel coordinates to sample the weighted average of two texels, \n    // levaraging the bilinear filtering hardware\n    blr += texture( iChannel0, uv/iResolution.xy ).rgb * weight[0];\n    for (int i=1; i<taps; i++) {\n      blr += texture( iChannel0, (uv + vec2(0.0, offset[i]))/iResolution.xy).rgb * weight[i]; \n      blr += texture( iChannel0, (uv - vec2(0.0, offset[i]))/iResolution.xy).rgb * weight[i];\n    }\n    \n    fragColor = vec4( blr, 1.0 );\n}","name":"Buffer B","description":"","type":"buffer"}]}