{"ver":"0.1","info":{"id":"clK3Rh","date":"1683560464","viewed":79,"name":"Metaballs __","username":"Envy24","description":"Example from book \"Geometry for Programmers\" (10.3.3, 10.3.4).","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["metaballs"],"hasliked":0,"parentid":"dsXXzX","parentname":"SDF template"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCENE_SCALE ( 5. )\n#define ORIGIN      ( vec2(0) )\n\n//#define METRIC(B, E) ( L1(B, E) )\n#define METRIC(B, E) ( L2(B, E) )\n//#define METRIC(B, E) ( Linf(B, E) )\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nfloat quasi_inverse(float x)\n{\n    return\n        x < 1. ?\n            ((1.-x)*(1.-x)) / x :\n            0.;\n}\n\nfloat quasi_inverse_with_locality(float x, float locality)\n{\n    return quasi_inverse(x / locality);\n}\n\n//#define QUASI_INVERSE(x) ( quasi_inverse(x) )\n#define QUASI_INVERSE(x) ( quasi_inverse_with_locality(x, 4.) )\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, false);\n\n    randomize_balls(iTime);\n\n    /* Metaballs */\n    float sum = 0.;    \n    for (int i = 0; i < num_of_balls; ++i)\n    {\n        sum += 1. / METRIC(balls[i], NDC);\n    }\n    float minDist = 1. / sum / float(num_of_balls)  -  0.25;\n    \n    float aa = pow(2., 1.)/iResolution.y;\n    vec3 color = vec3(smoothstep(0., aa, minDist));\n    /* Metaballs */\n    \n    /* Metaballs with quasi_inverse *\n    float sum = 0.;    \n    for (int i = 0; i < num_of_balls; ++i)\n    {\n        sum += QUASI_INVERSE(METRIC(balls[i], NDC));\n    }\n    float minDist = 1. / sum / float(num_of_balls)  -  0.25;\n    \n    float aa = pow(2., 4.)/iResolution.y;\n    vec3 color = vec3(smoothstep(.0, aa, abs(minDist)));\n    /* Metaballs with quasi_inverse */\n    \n    O = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nvec2 rotateAroundZ(vec2 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    return vec2(\n        p.x * c - p.y * s,\n        p.y * c + p.x * s);\n}\n\nfloat L1(vec2 B, vec2 E)\n{\n    vec2 D = E - B;\n    return abs(D.x) + abs(D.y);\n}\n\nfloat L2(vec2 B, vec2 E)\n{\n    vec2 D = E - B;\n    return sqrt(D.x*D.x + D.y*D.y);\n}\n\nfloat Linf(vec2 B, vec2 E)\n{\n    vec2 D = E - B;\n    return max(abs(D.x), abs(D.y));\n}\n\nconst int num_of_balls = 3;\nvec2 balls[num_of_balls] = vec2[num_of_balls](\n    vec2(-1., -1.), vec2(1., -1.), vec2(0., 1.)//,\n    //vec2(-1., -1.), vec2(1., -1.), vec2(0., 1.)\n);\n\n/* \n    Returns random vec2([-1.0; 1.0], [-1.0; 1.0]).\n*/\nvec2 hash2to2(\n    const uint x,\n    const uint y)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint entropy0 = 123u;\n    const uint entropy1 = 456u;\n    const uint entropy2 = 789u;\n\n    // Use linear offset method to mix coordinates.\n    uint value0 = y * entropy2 + x;\n    uint value1 = x * entropy2 + y;\n\n    // Calculate hash.\n\tvalue0 += entropy1; value0 *= 445593459u; value0 ^= entropy0;\n    value1 += entropy1; value1 *= 445593459u; value1 ^= entropy0;\n    \n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n\n    return \n        vec2(\n            float(value0 * value0 * value0) * 4.6566128730773926e-10f - 1.0f,\n            float(value1 * value1 * value1) * 4.6566128730773926e-10f - 1.0f);\n}\n\nvoid randomize_balls(float time)\n{\n    time *= 0.5;\n    float t = fract(time);\n    uint T = uint(time);\n\n    for (int k = 0; k < num_of_balls; ++k)\n    {\n        uint x = T + uint(k);\n        uint y = 2u * T + uint(k * 2);\n        vec2 c = hash2to2(x, y);\n        vec2 n = hash2to2(x + 1u, y + 2u);\n    \n        balls[k] = (c * (1. - t) + n * t) * 2.2;\n    }\n}","name":"Common","description":"","type":"common"}]}