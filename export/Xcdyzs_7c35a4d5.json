{"ver":"0.1","info":{"id":"Xcdyzs","date":"1731097599","viewed":95,"name":"Segmented spiral (denominator)","username":"ChunderFPV","description":"Whatever you set T to will describe the denominator visually.  For ex. set T to .75 (3/4) and you will see 4 represented as repeated groupings of 4 points arranged in 4 directions.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sdf","spiral","fraction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// alternate version of Segmented spiral whirlpool: https://www.shadertoy.com/view/4ctcRl\n\n#define T (iTime/2e2)\n#define A(v) mat2(cos((v)*3.1416 - vec4(0, 1.5708, -1.5708, 0)))  // rotate\n#define H(v) (cos(((v)+.5)*6.2832 + vec3(0, 1, 2))*.5+.5)         // hue\n\nfloat Q(vec3 u)  // sdf\n{\n    float t = T,       // speed\n          l = 4.,      // loop to reduce clipping\n          s = .4,      // object radius (max)\n          a = 3.,      // amplitude\n          f = 1e20, i = 0., y, z;\n    \n    u.xy = vec2(atan(u.x, u.y), length(u.xy));  // polar transform\n    u.x += t*133.;  // counter rotation\n    \n    for (; i++<l;)\n    {\n        vec3 p = u;\n        y = round((p.y-i)/l)*l+i;         // segment y & skip rows\n        p.x *= y;                         // scale x with segmented y\n        p.x -= y*y*t*3.1416;              // move x (shows denominator of t)\n        p.x -= round(p.x/6.2832)*6.2832;  // move x into segmented x\n        p.y -= y;                         // move y into segmented y\n        z = cos(y*t*6.2832)*.5+.5;        // cosine wave to match pattern\n        p.z += z*a;                       // wave z\n        f = min(f, length(p) - s*z);      // spheres\n    }\n    return f;\n}\n\nvoid mainImage( out vec4 C, vec2 U )\n{\n    vec2 R = iResolution.xy,\n         m = iMouse.z > 0. ?  // clicking?\n               (iMouse.xy - R/2.)/R.y:  // coords from mouse\n               cos(iTime/4. - vec2(0, 1.5708))*.2;  // coords from time\n    \n    vec3 o = vec3(0, -10.*sqrt(1.-abs(m.y*2.)), -90./(m.y+1.)),  // camera\n         u = normalize(vec3(U - R/2., R.y)),  // 3d coords\n         c = o.xxx, p;\n    \n    mat2 h = A(m.x/2.), // rotate horizontal\n         v = A((m.y+.5)/2.);   // vertical\n    \n    float i = 0., d = i, s, g;\n    \n    for (; i++<50.;)  // raymarch\n    {\n        p = u*d + o;\n        p.xz *= h;\n        p.yz *= v;\n        \n        s = Q(p);  // map scene\n        g = cos(round(length(p.xy))*T*6.2832)*.5+.5;  // gradient\n        c += min(s, exp(-s/.05))  // black & white\n           * (g+.1)               // shade\n           * H(.1-g/2.)           // color\n           * 5.;                  // brighten\n        \n        if (s < 1e-3 || d > 1e3) break;\n        d += s*.7;\n    }\n    \n    C = vec4(exp(log(c)/2.2), 1);\n}","name":"Image","description":"","type":"image"}]}