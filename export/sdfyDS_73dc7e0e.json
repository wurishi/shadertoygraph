{"ver":"0.1","info":{"id":"sdfyDS","date":"1642629064","viewed":826,"name":"Flow Fields","username":"manu210404","description":"Press r to reset\nUse the browser extension to speed up to your liking\n\nFeedback is always welcome! I'd like to improve my style of coding. ","likes":31,"published":3,"flags":48,"usePreview":0,"tags":["noise","perlin","turbulence","buffer","flowfield"],"hasliked":0,"parentid":"ttXfzN","parentname":"buffer experimentation"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n//    vec4 col = 0.1+0.8*texture(iChannel0,uv);\n    vec4 col = texture(iChannel0,uv);\n    col = pow(col, vec4(1.5));\n#ifdef LIGHT_MODE\n    col = (1.-col);\n#endif\n    uv = fragCoord/iResolution.xy-0.5;\n    fragColor = col\n#ifdef VIGNETTE\n    *(1.-0.5*dot(uv,uv))\n#endif\n    ;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    \n    int n = posToIdx(ivec2(fragCoord), int(iResolution.y));\n    \n    \n    // position of dot\n    vec2 p = texelFetch(iChannel0, ivec2(fragCoord), 0).xy;\n#ifdef CURL\n    p += field(p)*STEP_SIZE/FIELD_SCALE;\n#else\n    p += field(p)*STEP_SIZE;\n#endif\n    fragColor = vec4(p,0.0,1.0);\n    \n    // the dot gets random position when...\n    // ...pressing r for resetting\n    bool r = bool(texelFetch(iChannel1, ivec2(R, 0), 0).x);\n    \n#ifdef RESET_OUTOFBOUND\n    // ...out of bounds\n    bool b = p.x > iResolution.x/iResolution.y || p.x < 0.0 || p.y > 1.0 || p.y < 0.0;\n#else\n    bool b;\n#endif\n\n    // ...randomly\n#ifdef RESET_PROB\n    bool h = hash11(float(n)+float(iFrame)/127.0) < RESET_PROB;\n#else\n    bool h = false;\n#endif\n    \n    //bool o = texture(iChannel2, p).x < 0.5;\n    if (r || b || h || iFrame == 0) {\n        // reset position \n        fragColor = vec4(hash22(uv+fract(iTime))*vec2(iResolution.x/iResolution.y, 1.0), 0.0, 1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// -- tweakable parameters --\n// size of particles\n#define PARTICLE_SIZE 0.004\n// amount of particles\n#define PARTICLES 128\n// opacity of particles\n#define OPACITY 1.0\n// step size per frame\n#define STEP_SIZE 0.002\n// scale of the noise function used for the curls\n#define FIELD_SCALE 2.5\n// offset of the noise function for variety\n#define FIELD_OFFSET vec2(0, 0)\n// if defined, use curl field else just noise field\n//#define CURL\n// if defined, particles have the given probability to teleport to a random position each frame (the closer to 0 the longer the paths)\n#define RESET_PROB 0.02\n// if 2, the mouseposition modifies the distortion if 1 it doesn't and if 0 it is the only distortion\n#define MOUSE 1\n// if defined, the image appears white with black dots, else, it's the other way around\n#define LIGHT_MODE\n// if defined, the particles are reset when out of bounds\n//#define RESET_OUTOFBOUNDS\n// if defined, a subtle blur is added to the older lines.\n//#define BLUR\n// if defined a vignette effect is added\n//#define VIGNETTE\n\n\n// -- helper functions and definitions --\n\n// reset key\nconst int R = 82;\n\n// indexing of the position buffer (Buffer A)\nivec2 idxToPos(int i, int width) {return ivec2(i / width, i % width);}\nint posToIdx(ivec2 i, int width) {return i.x * width + i.y;}\n\n\n// -- noise functions --\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 hash22(vec2 co) {\n    return fract(sin(vec2(dot(co,vec2(167.1,311.7)),dot(co,vec2(269.5,183.3))))*737.5453);\n}\n\nfloat smoother(float t) {\n    t = clamp(t, 0.0, 1.0);\n    // 6t^{5}-15t^{4}+10t^{3}; polynomial used for smooth interpolation (from the same family of curves as the smoothstep function)\n    // this function has a continuous second derivative which makes it very useful for many applications\n    return 6.0*(t*t*t*t*t) - 15.0*(t*t*t*t) + 10.0*(t*t*t);\n}\n\nfloat perlin2d(vec2 p) {\n    vec2 i = floor(p);\n    vec2 j = ceil(p);\n    vec2 f = fract(p);\n    \n    //float su = smoothstep(uv.x, 0.0, 1.0);\n    //float sv = smoothstep(uv.y, 0.0, 1.0);\n    float su = smoother(f.x);\n    float sv = smoother(f.y);\n\n    float n0 = (1.-su)*dot(normalize(hash22(vec2(i.x, i.y))*2.-1.), f)\n                 + su *dot(normalize(hash22(vec2(j.x, i.y))*2.-1.), f-vec2(1, 0));\n    float n1 = (1.-su)*dot(normalize(hash22(vec2(i.x, j.y))*2.-1.), f-vec2(0, 1))\n                 + su *dot(normalize(hash22(vec2(j.x, j.y))*2.-1.), f-1.);\n    \n    return (1.-sv)*n0 + sv*n1;\n}\n\n// had to define them as macros because iMouse and iResolution are not defined in the \"Common\" Tab\n#define mouse_to_world(p) (iMouse.xy/iResolution.xy-(p)/vec2(iResolution.x/iResolution.y, 1.0))*vec2(iResolution.x/iResolution.y, 1.0)\n#if MOUSE == 2\n#define distortion(p) (perlin2d((p).xy * FIELD_SCALE + FIELD_OFFSET)*(clamp(length(mouse_to_world(p)), 0.0,0.4)*2.5-1.)*2.0)\n#elif MOUSE == 1\n#define distortion(p) (perlin2d((p).xy * FIELD_SCALE + FIELD_OFFSET))\n#else\n#define distortion(p) (clamp(length(mouse_to_world(p)), 0.0, 0.5)*2.-.5)\n#endif\n\n#define EPS 0.0001\n#ifdef CURL\n// the raw code of this function is commented out at the bottom (curl())\n#define field(p) normalize(vec2((distortion((p) + vec2(0,EPS)) - distortion((p) - vec2(0,EPS)))/(2.0 * EPS), -(distortion((p) + vec2(EPS,0)) - distortion((p) - vec2(EPS,0)))/(2.0 * EPS)))*4.0\n#else\nvec2 field(vec2 p) {\n    return normalize(vec2(perlin2d(p*FIELD_SCALE+FIELD_OFFSET), perlin2d(p*FIELD_SCALE + FIELD_OFFSET + 100.)))*2.;\n}\n#endif\n\n\n\n/*\nvec2 curl(vec2 p) {\n    // source: https://al-ro.github.io/projects/curl/\n    \n    float eps = 0.0001;\n    vec2 r = vec2(0);\n    \n    float n1 = distortion(vec2(p.x + eps, p.y));\n    float n2 = distortion(vec2(p.x - eps, p.y));\n    \n    r.y = (n1 - n2)/(2.0 * eps);\n\n    n1 = distortion(vec2(p.x, p.y + eps));\n    n2 = distortion(vec2(p.x, p.y - eps));\n\t\n    r.x = (n1 - n2)/(2.0 * eps);\n    return vec2(r.x, -r.y);\n}*/","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col;\n    vec2 uv = (fragCoord/iResolution.y);// + vec2((iResolution.y - iResolution.x) / iResolution.y / 2.0, 0));\n\n    // rendering the dots\n    float minDist = 2.;\n    for (int i = 0; i < PARTICLES; i++) {\n        vec2 p = texelFetch(iChannel0, idxToPos(i, int(iResolution.y)), 0).xy;\n        minDist = min(minDist, length(uv-p));\n    }\n    \n\n    if ((iFrame == 0) || bool(texelFetch(iChannel2, ivec2(R, 0), 0).x)){\n        col = vec4(0);\n    } else {\n        col = texture(iChannel1,(fragCoord/iResolution.xy)\n#ifdef BLUR\n        // adding a small amount to the coordinates adds a subtle blur to the old lines\n        +0.000006*(iFrame%2==0?-1.0:1.0)\n#endif\n        );\n    }\n    col = col + (1.-col) * vec4(OPACITY*smoothstep(PARTICLE_SIZE + 0.0015, PARTICLE_SIZE - 0.0015, minDist));\n    \n    // damping\n    col = col*0.996;\n    \n    // col = vec3(texelFetch(iChannel0, ivec2(fragCoord), 0));\n\n    fragColor = col;\n}","name":"Buffer B","description":"","type":"buffer"}]}