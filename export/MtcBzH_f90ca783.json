{"ver":"0.1","info":{"id":"MtcBzH","date":"1538595995","viewed":732,"name":"double swirl","username":"sporadiclizard","description":"swirly radial lines that have undergone a mobius transformation. couldn't decide between blurry and crisp, it goes in between the two :)\n\ncontrol the \"focal points\" with your mouse.\ntry the toggles for extra nausea! ","likes":30,"published":1,"flags":0,"usePreview":0,"tags":["mobius","rgb","hypnotic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ******** TOGGLES 0 / 1 **************** // \nconst int SWIRL_OSC = 0;\nconst int ONE_OSC \t= 1;\n// ******** TOGGLES 0 / 1 **************** // \n\n////////////////////////////////////////\n\n// 2*pi\n#define TAU 6.283185307179\n \nvec2 cxmul(vec2 z, vec2 w) {\n    return mat2(z, -z.y, z.x) * w; //vec2(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\n\nvec2 cxdiv(vec2 z, vec2 w) {\n    return cxmul(z, vec2(w.x, -w.y)) / dot(w,w);\n}\n\nvec2 mobius(vec2 z, vec2 a, vec2 b, vec2 c, vec2 d) {\n    return cxdiv(cxmul(a,z) + b, cxmul(c,z) + d); \n}\n\n// mobius transformation described with which complex numbers \n// it sends zero, one and infinity to.\n// 0 -> q, 1 -> r, inf -> s\nvec2 mobi3(vec2 z, vec2 q, vec2 r, vec2 s) {\n    return cxdiv(cxmul(z - q, r - s), cxmul(z - s, r - q));\n}\n\n\n////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mnuv = iMouse.xy/iResolution.xy;\n    vec2 mn = (2. * iMouse.xy - iResolution.xy) / iResolution.y;\n    \n    vec2 pos = ( 2. * fragCoord - iResolution.xy ) / iResolution.y; \n    \n    // mouse control! \n    vec2 inf = mn;\n    vec2 zero = -inf;\n\t\n    vec2 one = vec2(0.);\n    if (ONE_OSC==1) {\n    \tfloat t = sin(iTime*0.912)*0.3 + 0.5;\n    \tone = t*inf + (1.-t)*zero;\n    } else {\n    \tone =  (inf + zero) * 0.5;\n    }\n    \n    // mobius transformed position - deforms the plane \n    vec2 posi = mobi3(pos, zero, one, inf);\n    \n    float logr = log(length(posi));\n    \n    float swirl = 0.;\n    if (SWIRL_OSC==1) {\n\t\tswirl = 2.*TAU*sin(iTime*0.5) * atan(logr);\n\t} else { \n        // 2 positive turns at infinity, 2 negative turns at zero  \n    \tswirl = 2.*TAU*atan(logr);\n    }\n    \n    // add in the swirl\n    float ang = atan(posi.y,posi.x) + swirl;\n            \n    // RGB offset\n    const float offset = TAU*0.1;\n    vec3 offsetv = vec3(-offset,0.,offset);\n    \n    vec3 colVal = sin(ang*2.+ iTime*5. + offsetv);\n    \n    // smooth colors mode\n    vec3 smoothCol = colVal * 0.5 + 0.5;\n    \n    // antialiased solid colors mode \n    vec3 b = fwidth(colVal);\n    vec3 col_aa = smoothstep(vec3(-b), vec3(b), colVal); \n    \n    // switch modes\n    vec3 col = mix(col_aa, smoothCol, 0.7+0.2*sin(iTime));//floor(mod(iTime*0.5,2.)));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}