{"ver":"0.1","info":{"id":"sdfXz7","date":"1618588052","viewed":54,"name":"Penumbra Shadow approximation","username":"eyadnabeel","description":"Raymarched penumbra shadow approximation","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["cis561hw"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n#define EPSILON 0.0001\n#define PI_2 PI/2.f\n\n#define INFINITY 99999999999999999999999999.99\n\n#define SPHERE 0\n#define BOX 1\n#define PLANE 2\n\n#define LAMBERT 0\n#define TEXTURE 1\n#define LIGHT 2\n\nconst float SHADOW_HARDNESS = 6.0;\nconst int RAY_STEPS = 50;\n\n#define NUM_SHAPES 4\n\nstruct Intersection\n{\n    float t;\n    vec3 point;\n    vec3 normal;\n    vec3 color;\n};\n\nstruct Shape\n{\n    int type, material;\n    vec3 translate, rotate, scale;\n    vec3 color;\n};\n\nShape [NUM_SHAPES] s;\n\nvec2 noise_2D (vec2 p)\n{\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvoid computeRay (vec3 eye, vec3 ref, vec2 ndc, float fov, out vec3 ro, out vec3 rd)\n{\n    // TODO: Implement ray computation\n    vec3 look = ref - eye;\n    \n    float len = tan(fov * PI/180.f) * distance(eye, ref);\n    \n    vec3 v, h;\n    h = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    v = normalize(cross(h, look));;\n\n    h *= len * iResolution.x/iResolution.y;\n    v *= len;\n    \n    vec3 p = ref + ndc.x * h + ndc.y * v;\n            \n    p = ref + ndc.x * h + ndc.y * v;\n        \n    ro = eye;\n    rd = normalize(p - eye);\n}\n\nfloat sdf_sphere(vec3 ro, vec3 p, float r)\n{\n    return length(p - ro) - r;\n}\n\nfloat sdf_cube(vec3 ro, vec3 p, vec3 b)\n{\n    vec3 ro_shifted = ro + p;\n    vec3 q = abs(ro_shifted) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdf_plane(vec3 ro, vec3 n, float h)\n{\n  // n must be normalized\n  \n  vec3 dist = vec3(min(1.f - abs(ro.x), 0.f), min(1.f - abs(ro.y), 0.f), dot(ro, n));\n  return length(dist);\n}\n\nmat4 compute_transformation(int idx)\n{\n    mat4 rot_x, rot_y, rot_z, scale, translate;\n    \n    rot_x = mat4(vec4(1.f, 0.f, 0.f, 0.f), \n                 vec4(0.f, cos(s[idx].rotate.x), sin(s[idx].rotate.x), 0.f), \n                 vec4(0.f, -sin(s[idx].rotate.x), cos(s[idx].rotate.x), 0.f), \n                 vec4(0.f, 0.f, 0.f, 1.f));\n                 \n    rot_y = mat4(vec4(cos(s[idx].rotate.y), 0.f, -sin(s[idx].rotate.y), 0.f), \n                 vec4(0.f, 1.f, 0.f, 0.f), \n                 vec4(sin(s[idx].rotate.y), 0.f, cos(s[idx].rotate.y), 0.f), \n                 vec4(0.f, 0.f, 0.f, 1.f));\n    \n    rot_z = mat4(vec4(cos(s[idx].rotate.z), sin(s[idx].rotate.z), 0.f, 0.f), \n                 vec4(-sin(s[idx].rotate.z), cos(s[idx].rotate.z), 0.f, 0.f), \n                 vec4(0.f, 0.f, 1.f, 0.f), \n                 vec4(0.f, 0.f, 0.f, 1.f));\n                 \n    scale = mat4(vec4(s[idx].scale.x, 0.f, 0.f, 0.f), \n                 vec4(0.f, s[idx].scale.y, 0.f, 0.f), \n                 vec4(0.f, 0.f, s[idx].scale.z, 0.f), \n                 vec4(0.f, 0.f, 0.f, 1.f));\n                 \n    translate = mat4(vec4(1.f, 0.f, 0.f, 0.f), \n                     vec4(0.f, 1.f, 0.f, 0.f), \n                     vec4(0.f, 0.f, 1.f, 0.f), \n                     vec4(s[idx].translate.x, s[idx].translate.y, s[idx].translate.z, 1.f));\n    return translate * rot_z * rot_y * rot_x * scale;\n}\n\nvec3 computeNormal(int idx, vec3 ro, vec3 p, vec3 b, float r)\n{\n    vec3 normal;\n    float minus_x, plus_x;\n    float minus_y, plus_y;\n    float minus_z, plus_z;\n    if (s[idx].type == 0){\n        // SPHERE NORMALS\n        minus_x = sdf_sphere(vec3(ro.x - EPSILON, ro.yz), p, r);\n        plus_x = sdf_sphere(vec3(ro.x + EPSILON, ro.yz), p, r);\n        minus_y = sdf_sphere(vec3(ro.x, ro.y - EPSILON, ro.z), p, r);\n        plus_y = sdf_sphere(vec3(ro.x, ro.y + EPSILON, ro.z), p, r);\n        minus_z = sdf_sphere(vec3(ro.xy, ro.z - EPSILON), p, r);\n        plus_z = sdf_sphere(vec3(ro.xy, ro.z + EPSILON), p, r);\n    } else if (s[idx].type == 1){\n        // BOX NORMALS\n        minus_x = sdf_cube(vec3(ro.x - EPSILON, ro.yz), p, b);\n        plus_x = sdf_cube(vec3(ro.x + EPSILON, ro.yz), p, b);\n        minus_y = sdf_cube(vec3(ro.x, ro.y - EPSILON, ro.z), p, b);\n        plus_y = sdf_cube(vec3(ro.x, ro.y + EPSILON, ro.z), p, b);\n        minus_z = sdf_cube(vec3(ro.xy, ro.z - EPSILON), p, b);\n        plus_z = sdf_cube(vec3(ro.xy, ro.z + EPSILON), p, b);\n    } else if (s[idx].type == 2){\n        // PLANE NORMALS\n        minus_x = sdf_plane(vec3(ro.x - EPSILON, ro.yz), p, r);\n        plus_x = sdf_plane(vec3(ro.x + EPSILON, ro.yz), p, r);\n        minus_y = sdf_plane(vec3(ro.x, ro.y - EPSILON, ro.z), p, r);\n        plus_y = sdf_plane(vec3(ro.x, ro.y + EPSILON, ro.z), p, r);\n        minus_z = sdf_plane(vec3(ro.xy, ro.z - EPSILON), p, r);\n        plus_z = sdf_plane(vec3(ro.xy, ro.z + EPSILON), p, r);\n    }\n    normal = vec3(plus_x - minus_x, plus_y - minus_y, plus_z - minus_z);\n    mat3 inverse_transpose = mat3(transpose(inverse(compute_transformation(idx))));\n    return normalize(inverse_transpose * normal.xyz);\n}\n\n\nIntersection intersect (int idx, vec3 ro, vec3 rd)\n{\n    mat4 transformation = compute_transformation(idx);\n    mat4 inverse_transformation = inverse(compute_transformation(idx));\n    vec3 local_ro = (inverse_transformation * vec4(ro, 1.f)).xyz;\n    vec3 local_rd = (inverse_transformation * vec4(rd, 0.f)).xyz;\n    Intersection isect;\n    float t;\n    if (s[idx].type == 0){\n        t = sdf_sphere(local_ro, vec3(0.f), 1.f);\n    } else if (s[idx].type == 1){\n        t = sdf_cube(local_ro, vec3(0.f), vec3(1.f));\n    } else if (s[idx].type == 2){\n        t = sdf_plane(local_ro, vec3(0.f, 0.f, 1.f), 0.f);\n    }\n    while (t >= 0.0 && t <= 50.0){\n        if (t <= EPSILON && t >= 0.0){\n            isect.point = (transformation * vec4(local_ro + local_rd * t, 1.f)).xyz;\n            isect.t = distance(ro, isect.point);\n            if (s[idx].type == 0){\n                isect.normal = computeNormal(idx, local_ro, vec3(0.f), vec3(0.f), 1.0);\n            } else if (s[idx].type == 1){\n                isect.normal = computeNormal(idx, local_ro, vec3(0.f), vec3(1.f), 0.0);\n            } else if (s[idx].type == 2){\n                isect.normal = computeNormal(idx, local_ro, vec3(0.f, 0.f, 1.f), vec3(0.f), 0.0);\n            }\n            return isect;\n        }\n        local_ro += local_rd * t;\n        if (s[idx].type == 0){\n            t = sdf_sphere(local_ro, vec3(0.f), 1.f);\n        } else if (s[idx].type == 1){\n            t = sdf_cube(local_ro, vec3(0.f), vec3(1.f));\n        } else if (s[idx].type == 2){\n            t = sdf_plane(local_ro, vec3(0.f, 0.f, 1.f), 0.f);\n        }\n    }\n    isect.t = -1.f;\n    return isect;\n}\n\nfloat min_sdf (int main_idx, vec3 ro)\n{\n    mat4 inverse_transformation = inverse(compute_transformation(0));\n    vec3 local_ro = (inverse_transformation * vec4(ro, 1.f)).xyz;\n    Intersection isect;\n    float t, t_trans;\n\n    t = INFINITY;\n    \n    for (int idx = 0; idx < NUM_SHAPES; idx++){\n        if (idx == main_idx || s[idx].material == LIGHT){\n            continue;\n        }\n        inverse_transformation = inverse(compute_transformation(idx));\n        local_ro = (inverse_transformation * vec4(ro, 1.f)).xyz;\n        if (s[idx].type == 0){\n            t_trans = sdf_sphere(local_ro, vec3(0.f), 1.f);\n        } else if (s[idx].type == 1){\n            t_trans = sdf_cube(local_ro, vec3(0.f), vec3(1.f));\n        } else if (s[idx].type == 2){\n            t_trans = sdf_plane(local_ro, vec3(0.f, 0.f, 1.f), 0.f);\n        }\n        if (t_trans < t && t >= 0.f){\n            t = t_trans;\n        } else if (t < 0.f){\n            t = t_trans;\n        }\n    }\n    return t;\n}\n\nvoid intersect_scene(vec3 ro, vec3 rd, out Intersection isect, out Shape isect_shape)\n{\n    isect = intersect(0, ro, rd);\n    Intersection test;\n    isect_shape = s[0];\n    \n    for (int i = 0; i < NUM_SHAPES; i++){\n        test = intersect(i, ro, rd);\n        if (test.t < isect.t && test.t > -1.f){\n            isect = test;\n            isect_shape = s[i];\n        } else if (isect.t < 0.f){\n            isect = test;\n            isect_shape = s[i];\n        }\n    }\n}\n\nvoid intersect_scene_excluding(int idx, vec3 ro, vec3 rd, out Intersection isect, out Shape isect_shape)\n{\n    Intersection test;\n    if (idx == 0){\n        isect = intersect(1, ro, rd);\n        isect_shape = s[1];\n    } else {\n        isect = intersect(0, ro, rd);\n        isect_shape = s[0];\n    }\n    \n    for (int i = 0; i < NUM_SHAPES; i++){\n        if (i == idx || s[i].material == LIGHT){\n            continue;\n        }\n        test = intersect(i, ro, rd);\n        if (test.t < isect.t && test.t > -1.f){\n            isect = test;\n            isect_shape = s[i];\n        } else if (isect.t < 0.f){\n            isect = test;\n            isect_shape = s[i];\n        }\n    }\n}\n\nfloat shadow(vec3 dir, vec3 origin, float light_dist, int idx) {\n    float res = 1.f;\n    float t = EPSILON;\n    for (int i = 0; i < RAY_STEPS; ++i){\n        float m = min_sdf(idx, origin + t * dir);\n        if (m < EPSILON){\n            return 0.f;\n        }\n        if (m >= 0.f){\n            res = min(res, (SHADOW_HARDNESS * m)/t);\n            t += m;\n        } else {\n            return 1.f;\n        }\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //CAMERA VARIABLES\n    vec3 eye, ref, rayLook;\n    vec3 look, up, right;\n    float fov;\n    \n    fov = 25.f;\n    eye = vec3(-10.0 , 3.0, 10);\n    ref = vec3(0.0, 0.0, 0.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Normalized device coordinates (from -1 to 1)\n    vec2 ndc = vec2((2.f * uv.x) - 1.f, 1.f - (2.f * uv.y)); \n    \n    vec3 ro, rd;\n    \n    computeRay(eye, ref, ndc, fov, ro, rd);\n    \n    vec3 col = vec3(0.0);\n        \n    \n    s[0].type = PLANE;\n    s[0].material = TEXTURE;\n    s[0].translate = vec3(0.f, -3.f, 0.f);\n    s[0].rotate = vec3(PI/2.f, 0.f, 0.f * sin(iTime));\n    s[0].scale = vec3(40.f, 40.f, 1.f);\n    s[0].color = vec3(1.f, 1.f, 0.9f);\n    \n    s[1].type = SPHERE;\n    s[1].material = LAMBERT;\n    s[1].translate = vec3(0.f, -1.f, 0.f);\n    s[1].rotate = vec3(0.f, 0.f, 0.f * sin(iTime));\n    s[1].scale = vec3(2.f, 2.f, 2.f);\n    s[1].color = vec3(1.f, 0.2f, 0.1f);\n    \n    s[2].type = BOX;\n    s[2].material = LAMBERT;\n    s[2].translate = vec3(3.f, 0.f, 3.f);\n    s[2].rotate = vec3(0.f,  -iTime, 0.f * sin(iTime));\n    s[2].scale = vec3(1.f, 3.f, 1.f);\n    s[2].color = vec3(0.1f, 0.7f, 0.1f);\n    \n    \n    vec3 lightPos = vec3(-10.5f * cos(iTime), 10.5f * abs(cos(iTime)), 10.5f * sin(iTime));\n    \n    Shape light;\n    light.type = SPHERE;\n    light.material = LIGHT;\n    light.translate = lightPos;\n    light.scale = vec3(1.f);\n    light.rotate = vec3(0.f);\n    light.color = vec3(0.92, 0.9, 0.8);\n    \n    s[3] = light;\n\n    Intersection isect;\n    Shape isect_shape;\n    intersect_scene(ro, rd, isect, isect_shape);\n    \n    int idx;\n    \n    for (int i = 0; i < NUM_SHAPES; i++){\n        if (isect_shape == s[i]){\n            idx = i;\n            break;\n        }\n    }\n    \n    float threshold = 80.f;\n    \n    if (isect.t > -1.0){\n        float dist = 1.f - (isect.t * isect.t)/(threshold * threshold);\n        float lambert = max(dot(isect.normal, normalize(lightPos - isect.point)), 0.f);\n        float penumbra_shadow = shadow(normalize(lightPos - isect.point), isect.point, distance(isect.point, lightPos), idx);\n        switch(isect_shape.material){\n            case LAMBERT:\n            col = isect_shape.color * lambert * penumbra_shadow;\n            break;\n            case TEXTURE:\n            float t = floor(mod(1.0 * (sin(isect.point.x) + sin(isect.point.z)), 2.0));\n            col = mix(vec3(0.5), vec3(1.0), t) * isect_shape.color * lambert * penumbra_shadow * dist;\n            break;\n            case LIGHT:\n            col = isect_shape.color;\n            break;\n        }\n        \n        \n    }\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}