{"ver":"0.1","info":{"id":"3sfczH","date":"1584105324","viewed":163,"name":"Spiral of Spheres","username":"MeHigh_","description":"I tried to generate infinite spherese with the DE formula, but I have some problems with the lights and shadows","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["spheres"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MAX_ITER 100\n#define MAX_DIST 100.\n#define SURF_DIST 1e-3\n#define S(a, b, c) smoothstep(a, b, c)\n#define PI 3.1415\n\nconst vec3 blue = vec3(0.1216, 0.502, 1.);\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nmat2 rotate(float ang) {\n \treturn mat2(cos(ang), -sin(ang),\n                sin(ang),  cos(ang));\n}\n\nvec3 Transform(vec3 p) {\n    p.xy *= rotate(p.z * .23);\n\tp.z += iTime * .5;\n    p.y -= .10;\n    \n    return p;\n}\n\nfloat getDist(vec3 p) {\n    p = Transform(p);\n \tp = mod(p, 1.);\n    return length(p - vec3(.5)) - .2;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n\tfloat dO = 0., dS;\n    for(int i = 0; i < MAX_ITER; ++i) {\n     \tvec3 p = ro + dO * rd;\n        dS = getDist(p);\n        dO += dS;\n        if(dO > MAX_DIST || abs(dS) < SURF_DIST)\n            break;\n    }\n    \n    return dO;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(.0025, -.0025); \n    vec3 n = e.xyy * getDist(p - e.xyy) +\n        \t e.yxy * getDist(p - e.yxy) +\n        \t e.yyx * getDist(p - e.yyx) +\n        \t e.xxx * getDist(p - e.xxx);\n    return normalize(n);\n}\n\nfloat getLight(vec3 p) {\n\tvec3 lightPos = vec3(0., 5., .5);\n    lightPos.xy += vec2(sin(iTime), cos(iTime) * 1.5);\n    vec3 l = normalize(lightPos - p);\n    vec3 n = normalize(p);\n    \n    float dif = clamp(dot(n, l) * .5 + .5, 0., 1.);\n    float d = rayMarch(p + n * SURF_DIST * 2., l);\n\t\n    if(d < length(lightPos - p))\n        dif *= fract(pow(d, 1./1.4));\n    \n\treturn dif;\n}\n\nvec3 getRayDir(vec2 uv, vec3 ro, vec3 l, float zoom) {\n\tvec3 f = normalize(l - ro);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n    vec3 cam = ro + f * zoom;\n    vec3 intersect = cam + uv.x * r + uv.y * u;\n    vec3 d = normalize(intersect - ro);\n    \n    return d;\n}\n\nvec3 bkg(vec3 rd, vec2 uv) {\n\tvec3 col = vec3(0.);\n    \n    float z = rd.z * .5 + .5;\n    \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\t\n    vec2 mo = iMouse.xy / iResolution.xy;\n    \n    vec3 ro = vec3(0., 0., -3.); \n    vec3 lookAt = vec3(0., 0., 0.);\n   \t\n   \tvec3 rd = getRayDir(uv, ro, lookAt, 1.);\n    \n\tvec3 col = vec3(0.);\n    \n    float d = rayMarch(ro, rd);\n    \n    if(d < MAX_DIST) {\n     \tvec3 p = ro + rd * d;  \n\t\tvec3 n = getNormal(p);\n        p = Transform(p);\n        \n        float dif = n.z * .5 + .5;\n        \n        col += dif * dif;\n        \n    \tfloat sph1 = getDist(p);\n        \n        vec4 tex;\n\t\ttex += texture(iChannel1, p.xy);\n        //Remove the texture stretching\n        tex += texture(iChannel1, p.yz);\n        tex += texture(iChannel1, p.zx);\n\t\t\n        vec3 sphT = S(-1., 1., sph1) *  tex.xyz ;\n\t\t\n\t\tcol *= sphT;\n    }\n    \n    vec3 bg = bkg(rd, uv);\n        \n    col = mix(col, bg, S(0., 12., d));\n    col = pow(col, vec3(1./2.2));\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}