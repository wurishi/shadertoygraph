{"ver":"0.1","info":{"id":"3lsSWr","date":"1564511582","viewed":507,"name":"RayMarchingTestScene","username":"LudusEstArs","description":"Features:\n - Blinn-Phong illumination\n - Soft Shadows\n - Fog\n - Ambient Occlusion\n - Multiple lights\n - Point and Directional lights\n - Color lights\n - Rotations\n - Blending\n - 1 step reflections\n- Texturing","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// COMMON FUNCTIONS //////////////////////////////////////////////////////////////////\nvec2 NormalizeScreenCoords(vec2 screenCoord)\n{\n    vec2 result = 2.0 * (screenCoord/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y;\n    return result;\n}\n\nfloat CheckersGradBox(vec2 p)\n{ // iquilezles.org/articles/checkerfiltering\n    vec2 w = fwidth(p) + .001;\n    vec2 i = 2.0 * (abs(fract((p-.5*w)*.5)-.5)-abs(fract((p+.5*w)*.5)-.5))/w;\n    return .5 - .5*i.x*i.y;\n}\n\nfloat Checkers(in vec3 p)\n{\n    ivec2 ip = ivec2(round(p+.5));\n    return float((ip.x^ip.y)&1);\n}\n\nmat3 ComputeRotationMatrix(const float x, const float y, const float z)\n{ // NOTE: mat = (firstCOLUMN, secondCOLUMN, thirdCOLUMN);\n    mat3 o = mat3(0);\n    \n   \to  = mat3( 1.0, 0.0\t,  0.0,\t\t\n             0.0, cos(x), -sin(x),\n             0.0, sin(x), cos(x)  );\n    \n\to *= mat3( cos(y), 0.0, sin(y),\n               0.0\t , 1.0, 0.0,\n               -sin(y), 0.0, cos(y) );\n    \n\to *= mat3( cos(z), -sin(z), 0.0,\n               sin(z), cos(z) , 0.0,\n               0.0\t , 0.0    , 1.0 );\n    return o;\n}\n//////////////////////////////////////////////////////////////////////////////////////\n\n// Configure the scene\nvoid SceneInit(out Scene s)\n{\n    // Setup camera\n    s.cam.pos \t  = vec3(0);\n    s.cam.forward = vec3(0,0,1);\n    s.cam.right   = normalize(cross(vec3(0, 1, 0), s.cam.forward));\n    s.cam.up      = normalize(cross(s.cam.forward, s.cam.right));\n    s.cam.fPersp  = 2.0;\n\n    // Moving Directional Light\n    /*Light dirLight;\n\tdirLight.type      = 0;\n    dirLight.pos       = vec3(0);\n    dirLight.dir       = normalize(vec3(sin(iTime*.5), cos(iTime*.25)-1.0, 1));\n    dirLight.color \t   = vec3(1);\n    dirLight.range     = MAX_DISTANCE;\n    dirLight.intensity = .0;\n\n    s.lights[0] = dirLight;*/\n    \n    // Orange Point Light\n    Light pLight;\n    pLight.type      = POINT;\n    pLight.dir \t\t = vec3(0);\n    pLight.color  \t = VERMILION;\n    pLight.range \t = 7.5;\n    pLight.intensity = 1.0;\n    pLight.pos       = vec3(0,2,6) +\n        \t\t\t   vec3(5.*sin(1.5*iTime), 0, 5.*cos(1.5*iTime));\n    s.lights[0] = pLight;\n    \n    // Teal point Light\n    Light pLight2;\n    pLight2.type      = POINT;\n    pLight2.dir       = vec3(0);\n    pLight2.color  \t  = TEAL;\n    pLight2.range \t  = 7.5;\n    pLight2.intensity = 1.0;\n    pLight2.pos       = vec3(0,2,6) +\n        \t\t\t    vec3(5.*sin(iTime+180.), 0, 5.*cos(iTime+180.));\n    s.lights[1] = pLight2;\n    \n    // Floor plane\n    Shape plane;\n    plane.blendType = NO_OP;\n    plane.type      = FLOOR_PLANE;\n    plane.pos       = vec3(0);\n    plane.rot       = ComputeRotationMatrix(0., 0., 0.);\n    plane.color     = vec4(0);\n    plane.normal    = vec4(0, 1, 0, 2);\n    plane.glossy    = .25;\n    plane.texID     = 0;\n    \n    s.objects[0] = plane;\n    \n    // Red Box\n    Shape box;\n    box.blendType = NO_OP;\n    box.type      = BOX;\n    box.pos       = vec3(-3, -1.35, 6);\n    box.scale     = vec3(.75);\n    box.rot       = ComputeRotationMatrix(0., 90., 0.);\n    box.color     = vec4(RED, 1);\n    box.glossy    = 0.;\n    box.texID     = 1;\n\n    s.objects[1] = box;\n    \n    // Green Ball\n    Shape ball;\n    ball.blendType = BLEND;\n    ball.type      = SPHERE;\n    ball.pos       = vec3(0, -1, 6);\n    ball.radii     = vec2(1, 0);\n    ball.rot       = ComputeRotationMatrix(0., 0., 0.);\n    ball.color     = vec4(GREEN, 1);\n    ball.glossy    = 1.0;\n    ball.blendStrength = .5;\n    ball.texID     = 0;\n\n    s.objects[2] = ball;\n   \n    // Blue Torus\n    Shape torus;\n    torus.blendType = NO_OP;\n    torus.type      = TORUS;\n    torus.pos       = vec3(2.75, -1, 6);\n    torus.radii     = vec2(.75, .25);\n    torus.rot       = ComputeRotationMatrix(cos(iTime), sin(iTime), 0.);\n    torus.color     = vec4(BLUE, 1);\n    torus.glossy    = .5;\n\n    s.objects[3] = torus;\n\n    return;\n}\n\nvoid Blend(inout Shape current, inout float currentD,\n           Shape candidate, float candidateD)\n{ // Based on IÃ±igo Quilez's smooth min algorithm:\n  // iquilezles.org/articles/smin\n    float h = clamp(.5+.5*(candidateD-currentD)/candidate.blendStrength,\n                    .0, 1.);\n    \n    currentD       = mix(candidateD, currentD, h) -\n                         candidate.blendStrength * h * (1.- h);\n    current.color  = mix(candidate.color, current.color, h);\n    current.normal = mix(candidate.normal, current.normal, h);\n    \n    // TODO: Find a better way to interpolate the texture / patterns\n    current.type   = (h>=.5) ? current.type   : candidate.type;\n\t// TODO: Find a better way to interpolate glossiness\n    current.glossy = (h>=.5) ? current.glossy : candidate.glossy;\n}\n\nfloat GetShapeDst(Shape s, vec3 eye)\n{\n    float o = MAX_DISTANCE + 1.;\n    vec3 p = s.rot * (s.pos - eye);\n    \n    switch(s.type)\n    {\n        case FLOOR_PLANE:\n        \to = PlaneSDF(eye, s.pos, s.normal);\n        \tbreak;\n        case SPHERE:\n           \to = SphereSDF(eye, s.pos, s.radii.x);\n        \tbreak;\n        case BOX:\n           \to = BoxSDF(p, s.scale);\n        \tbreak;\n        case TORUS:\n        \to = TorusSDF(p, s.radii);\n        \tbreak;\n        default:\n           \tbreak;\n    }\n    \n    return o;\n}\n\nRayIntersection GetNearestShape(vec3 origin)\n{\n    RayIntersection o;\n    o.distance = MAX_DISTANCE;\n    \n    float shapeD;\n    Shape s;\n    \n    for (int i=0; i<NUM_SHAPES; i++)\n    {\n        s = scene.objects[i];\n\t\tshapeD = GetShapeDst(s, origin);\n        \n        switch (s.blendType)\n        {\n            case NO_OP:\n                if (shapeD<o.distance)\n        \t\t{\n            \t\to.shape    = s;\n            \t\to.distance = shapeD;\n        \t\t}\n            \tbreak;\n            \n  \t\t\tcase BLEND:\n            \tBlend(o.shape, o.distance, s, shapeD);\n            \tbreak;\n            \n            case CUT: // TODO\n            \tbreak;\n            \n            case MASK: // TODO\n            \tbreak;\n\t\t\t\n            default:\n            \tbreak;\n        }\n    }\n    \n    return o;\n}\n\nvec3 ComputeNormals(vec3 p)\n{\n    vec3 o;\n    \n    vec3 epsilonX = vec3(EPSILON, 0, 0);\n    vec3 epsilonY = vec3(0, EPSILON, 0);\n    vec3 epsilonZ = vec3(0, 0, EPSILON);\n    \n    // To estimate the normal in an axis, from a surface point, we move slightly\n    // in that axis and get the changing in the distance to the surface itself.\n    // If the change is 0 or really small it means the surface doesn't change in that\n    // direction, so its normal in that point won't have that axis component.\n    float reference = GetNearestShape(p).distance;\n    o.x = GetNearestShape(p+epsilonX).distance - reference;\n    o.y = GetNearestShape(p+epsilonY).distance - reference;\n    o.z = GetNearestShape(p+epsilonZ).distance - reference;\n    \n    return normalize(o);\n}\n\nRayIntersection CastRay(const Ray r, const float max_dst)\n{\n    RayIntersection o;\n    o.ray         = r;\n \to.distance    = max_dst;\n    o.shadow      = max_dst;\n    o.shape.type  = NO_SHAPE;\n    \n    int i = 0;\n    float travelDist = 0.0f;\n    RayIntersection tmpRI;\n    \n    while (travelDist<max_dst && i<MAX_ITERATIONS)\n    {\n        i++;\n\n\t\ttmpRI = GetNearestShape(r.o + r.d*travelDist);\n        \n        travelDist += tmpRI.distance;\n        \n        // Soft shadows\n        o.shadow = min(o.shadow, SOFT_SHADOWS_C*tmpRI.distance/travelDist);\n        \n        if (tmpRI.distance < EPSILON)\n        { // We collided\n            o.pos      = r.o + r.d*travelDist;\n            o.shape    = tmpRI.shape;\n            o.distance = travelDist;\n            if (o.shape.normal == vec4(0))\n            { // Avoid computing the normals of shapes that already have them\n              // (such as planes)\n            \to.shape.normal = vec4(ComputeNormals(o.pos), 1);\n            }\n            break;\n        }\n    }\n    \n    if (o.shape.type == FLOOR_PLANE)\n    {\n    \to.shape.color = vec4(vec3(CheckersGradBox(o.pos.xz*.5)*.5 + .25), 1);\n        o.shape.glossy *= o.shape.color.r;\n    }\n\n    o.numIt = i;\n    return o;\n}\n\nRay GetCameraRay(Camera cam, const vec2 uv)\n{\n    Ray o;\n    \n    o.o = cam.pos;\n  \to.d = normalize(uv.x * cam.right +\n                    uv.y * cam.up +\n                    cam.forward * cam.fPersp);\n    return o;\n}\n\nvoid ApplyFog(inout vec3 c, const float d)\n{\n    float m = exp(-d*d*.001);\n    c = mix(FOG_COLOR, c, m);\n}\n\nvoid SmoothCubeMapHorizon(inout vec3 c, const vec3 cm, float d)\n{\n    float m = exp(-d*d*.001);\n    c = mix(cm, c, m);\n}\n\nfloat ComputeShadow(const vec3 p, const vec3 n, const vec3 L, const float d2l)\n{\n    float shadow = 1.0;\n    \n    Ray r;\n    r.o = p + n*SHADOW_BIAS; // Without this, the ray doesn't leave the surface\n    r.d = L;\n    \n    RayIntersection ri = CastRay(r, d2l);\n    if (ri.shape.type != NO_SHAPE) shadow = 0.0;\n    else shadow = clamp(ri.shadow, .0,1.0);\n\n    return shadow;\n}\n\nfloat ComputeAO(const vec3 p, const vec3 n)\n{\n    float ao = 0.0;\n    \n    int   i = 0;\n    float r,d;\n    while (i<AO_NUM_STEPS)\n    {\n        i++;\n        d = AO_STEP_SIZE * float(i);\n    \tr = GetNearestShape(p + n*d).distance;\n   \n        ao += max(0.0, (d-r)/d);\n    }\n    \n    return 1.0 - ao*AO_INTENSITY;\n}\n\nvec3 TriplanarTextureMapping(const vec3 p, const vec3 n, const int texID)\n{\n    mat3 samples;\n    \n    switch(texID)\n    {\n        // iChannel0 is for the SkyBox\n        case 1:\n        \tsamples = mat3 (texture(iChannel1, p.yz).rgb,\n                         \ttexture(iChannel1, p.xz).rgb,\n                         \ttexture(iChannel1, p.xy).rgb );\n        \tbreak;\n        case 2:\n        \tsamples = mat3 (texture(iChannel2, p.yz).rgb,\n                         \ttexture(iChannel2, p.xz).rgb,\n                         \ttexture(iChannel2, p.xy).rgb );\n        \tbreak;\n        case 3:\n        \tsamples = mat3 (texture(iChannel3, p.yz).rgb,\n                         \ttexture(iChannel3, p.xz).rgb,\n                         \ttexture(iChannel3, p.xy).rgb );\n        \tbreak;\n        default:\n        \tsamples = mat3(0);\n        \tbreak;\n    }\n    \n    // Weight the samples with the normal to get the one more aligned\n    return samples * abs(n);\n}\n\nvoid DoTheLighting(RayIntersection ri, out vec4 c)\n{\n    float attByDst;\n    float NoL, specAngle;\n    float shadow, ao;\n    float d2l = MAX_DISTANCE;\n    vec3  diffuse, specular;\n    vec3  L, halfVec;\n    vec4  ambient;\n    \n    if (ri.shape.texID != 0)\n    {\n        ri.shape.color.rgb *= TriplanarTextureMapping(ri.pos,\n                                                     ri.shape.normal.xyz,\n                                                     ri.shape.texID);\n    }\n    \n\tfor (int i=0; i<NUM_LIGHTS; i++)\n    {\n        if (scene.lights[i].type == DIRECTIONAL)\n        {\n            L \t\t = -scene.lights[i].dir;\n            attByDst = 1.0;\n        }\n        else if (scene.lights[i].type == POINT)\n        {\n            vec3  p2l = scene.lights[i].pos - ri.pos;\n            d2l = length(p2l); \n            if (d2l > scene.lights[i].range) continue;\n            attByDst = (scene.lights[i].range - d2l) / scene.lights[i].range;\n            L = normalize(p2l);\n        }\n\n        // BLINN-PHONG\n        // Diffuse component\n        NoL      = clamp(dot(L, ri.shape.normal.xyz), .0, 1.0);\n        diffuse += NoL * attByDst *\n            \t   scene.lights[i].color * scene.lights[i].intensity;\n        \n        // Specular component\n        if (NoL >= .0 && ri.shape.glossy > .0)\n        {\n            halfVec    = normalize(-ri.ray.d + L);\n            specAngle  = clamp(dot(ri.shape.normal.rgb, halfVec), .0, 1.0);\n            specular  += pow(specAngle, ri.shape.glossy*512.) * attByDst *\n                \t\t scene.lights[i].color * scene.lights[i].intensity;\n        }\n\n        shadow += ComputeShadow(ri.pos, ri.shape.normal.xyz, L, d2l);\n    }\n    // Ambient Occlusion\n    ao = ComputeAO(ri.pos, ri.shape.normal.xyz);\n    \n    //ambient = AMBIENT_LIGHT;\n    ambient = texture(iChannel0, reflect(ri.ray.d, ri.shape.normal.xyz),\n                       1./ri.shape.glossy);\n\n    // Combine all the illumination components\n    c  = ri.shape.color * vec4(diffuse, 1);\n    c *= shadow * ao;\n    c += ri.shape.color * ambient;\n\tc += vec4(specular, 0);\n    \n    // DEBUG: Normals\n    //c = ri.shape.normal;\n    // DEBUG: Ambient Occlusion\n    //c = vec4(ao,ao*.5,0,1);\n    \n    // NOTE: Applying the fog here keeps the sky gradient,\n    // but makes the horizon look too sharp\n\t//ApplyFog(c.rgb, ri.distance);\n}\n\nvec3 ComputeReflection(inout Ray r, const float g)\n{\n    RayIntersection ri = CastRay(r, MAX_REFLECTION_DIST);\n    \n    r = ri.ray;\n    \n    vec4 o = vec4(BLACK,1);\n    DoTheLighting(ri, o);\n    \n    return mix(BLACK, o.rgb, g).rgb * REFLECTION_INTENSITY * g;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    SceneInit(scene);\n    \n    vec2 uv = NormalizeScreenCoords(fragCoord);\n    vec3 cm;\n    Ray ray = GetCameraRay(scene.cam, uv);\n    \n\tRayIntersection ri = CastRay(ray, MAX_DISTANCE);\n    cm = texture(iChannel0, reflect(ri.ray.d, ri.shape.normal.xyz)).rgb;\n    \n    if (ri.shape.type != NO_SHAPE)\n    {        \n        DoTheLighting(ri, fragColor);\n        \n        if (ri.shape.glossy > .0)\n        { // Reflections\n\n            Ray reflectedRay;\n            reflectedRay.d = reflect(ray.d, ri.shape.normal.xyz);\n            reflectedRay.o = ri.pos + ri.shape.normal.xyz * EPSILON;\n         \n            fragColor.rgb += ComputeReflection(reflectedRay, ri.shape.glossy);\n        }\n    }\n    else\n    { // Sky box\n        //fragColor = vec4(FOG_COLOR.rgb - ri.ray.d.y*.4, 1);\n        fragColor = vec4(cm,1);\n    }\n    \n    // NOTE: Applying the fog here makes the horizon smooth,\n    // but also the sky uniform.\n    //ApplyFog(fragColor.rgb, ri.distance);\n    \n    SmoothCubeMapHorizon(fragColor.rgb, cm, ri.distance);\n    \n    // Red rim glow\n    //fragColor = vec4(float(ri.numIt)/float(MAX_ITERATIONS), 0,0,1);\n    \n    // Vignette\n    fragColor.rgb *= 1. - VIGNETTE_STR * length(uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// CONSTANTS ///////////////////////////////////////////\n// Scene info\nconst int   NUM_SHAPES    = 4;\nconst int   NUM_LIGHTS    = 2;\nconst float FOG_DENSITY   = 0.01;\nconst float VIGNETTE_STR  = 0.15;\nconst vec3  FOG_COLOR     = vec3(0, .25, .5);\nconst vec4  AMBIENT_LIGHT = vec4(.1, .1, .1, 1);\n\n// Ray marching variables\nconst int   MAX_ITERATIONS = 256;\nconst float MAX_DISTANCE   = 256.0;\nconst float EPSILON        = 0.001;\n\n// Shadows\nconst float SHADOW_BIAS    = EPSILON * 50.0;\nconst float SOFT_SHADOWS_C = 16.0;\n\n// Ambient Occlusion\nconst int   AO_NUM_STEPS = 3;\nconst float AO_STEP_SIZE = 0.05;\nconst float AO_INTENSITY = 0.5;\n\n// Shape types\nconst int FLOOR_PLANE = 0;\nconst int SPHERE      = 1;\nconst int BOX         = 2;\nconst int TORUS       = 3;\nconst int NO_SHAPE    = 999;\n\n// Blend operations\nconst int NO_OP = 0;\nconst int BLEND = 1;\nconst int CUT   = 2;\nconst int MASK  = 3;\n\n// Light types\nconst int DIRECTIONAL = 0;\nconst int POINT       = 1;\n\n// Reflections\nconst int   MAX_REFLECTION_STEPS = 1;\nconst float MAX_REFLECTION_DIST  = MAX_DISTANCE * .5;\nconst float REFLECTION_INTENSITY = .5;\n\n// Usual colors\nconst vec3 BLACK     = vec3(0);\nconst vec3 WHITE     = vec3(1);\nconst vec3 RED    \t = vec3(1,0,0);\nconst vec3 GREEN  \t = vec3(0,1,0);\nconst vec3 BLUE   \t = vec3(0,0,1);\nconst vec3 TEAL   \t = vec3(.21, .46, .53);\nconst vec3 VERMILION = vec3(.89, .26, .2); \n////////////////////////////////////////////////////////\n\n// SDFs ////////////////////////////////////////////////\n// iquilezles.org/articles/distfunctions\nfloat PlaneSDF(vec3 eye, vec3 p, vec4 n)\n{ // NOTE: n must be normalized\n    return dot(eye-p, n.xyz) + n.w;\n}\n\nfloat SphereSDF(vec3 eye, vec3 p, float r)\n{ \n\treturn distance(p,eye) - r;\n}\n\nfloat BoxSDF(vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) +\n        \tmin(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat TorusSDF(vec3 p, vec2 radii)\n{\n\tvec2 q = vec2(length(p.xz) - radii.x, p.y);\n    return length(q) - radii.y;\n}\n////////////////////////////////////////////////////////\n\n// DATA STRUCTS ////////////////////////////////////////\nstruct Ray\n{\n    vec3 o;\n    vec3 d;\n};\n    \nstruct Camera\n{\n    float fPersp;\n    vec3  pos, forward, up, right;\n};\n\nstruct Light\n{\n    int   type;\n    float range, intensity;\n    vec3  pos, dir;\n    vec3  color;\n};\n    \nstruct Shape\n{\n    int   type, blendType, texID;\n    float glossy, blendStrength;\n    vec2  radii; // SPHERE: X | TORUS: X = external, Y = internal\n    vec3  pos, scale;\n    vec4  normal, color;\n    mat3  rot;\n    mat4  T, iT;\n};\n    \nstruct RayIntersection\n{\n\tint   numIt;\n    float distance;\n    float shadow;\n    vec3  pos;\n    Ray   ray;\n    Shape shape;\n};\n    \nstruct Scene\n{\n    vec4 ambientLight;\n    Camera cam;\n    Light[NUM_LIGHTS] lights;\n    Shape[NUM_SHAPES] objects;\n};\n////////////////////////////////////////////////////////\n    \n// GLOBALS /////////////////////////////////////////////\nScene scene;\n////////////////////////////////////////////////////////","name":"Common","description":"","type":"common"}]}