{"ver":"0.1","info":{"id":"3ttGRB","date":"1576782287","viewed":116,"name":"Orbo Spherical","username":"onlinerocker","description":"Orbo chillin' on chcekerboard island\nOptimization tips appreciated ;p","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","phong","fun","animation","spheretracing","character"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define VIEW_DIST 70.0\n//change VIEW_DIST for farther or shorter render distance\n\nstruct Object\n{\n \tfloat dist;\n    float difVal;\n    float specVal;\n    float specKs;\n    float normEps; //artifacting was occuring for some objects when this value was too high\n    \t\t\t   //thus, you can specify a value for each object.\n    vec3 color;\n    vec3 normal;\n};\n\nstruct MarchRes\n{\n \tfloat totalDist;\n    vec3 curRay;\n    Object obj;\n};\n    \nstruct Light\n{\n\tfloat intensity;\n    vec3 color;\n    vec3 pos;  \n};\n\n//iq\nfloat sdSphere(vec3 pos, float rad)\n{\n \treturn length(pos) - rad;\n}\n\n//iq\nfloat sdPlaneInf(vec3 pos, float y)\n{\n \treturn pos.y - y;   \n}\n\n//iq\nfloat sdPlane( vec3 p, vec4 n )\n{\n  \treturn dot(p,n.xyz) + n.w;\n}\n\n//iq\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n      p.y -= clamp( p.y, 0.0, h );\n      return length( p ) - r;\n}\n\n//iq\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n//iq\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n//slightly modified, but IQ\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayDir,   // camera to point vector\n               in vec3  sunDir )  // sun light direction\n{\n    float fogAmount = 1.0 - exp( -distance*(distance*(0.001 / pow(clamp(VIEW_DIST / 70.0, 0.0, 1.0), 2.0))) );\n    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n    vec3  fogColor  = mix( vec3(0.5,0.6,0.7), // bluish\n                           vec3(0.5,0.6,0.7), // yellowish\n                           pow(sunAmount,8.0) );\n    return mix( rgb, fogColor, fogAmount );\n}\n\n//https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n    \nObject map(vec3 pos)\n{\n    Object o;\n    o.difVal = 1.0;\n    o.dist = 1000.0;\n    o.normEps = 0.00001;\n    o.color = vec3(0);\n    \n    float yOff = 0.05*sin(5.0*iTime);\n    vec3 offset = vec3(0, yOff, 0);\n    \n    //ground\n    vec3 boardPos = pos;\n    boardPos.z = mod(boardPos.z, 10.0);\n    boardPos.x = mod(boardPos.x, 12.0);\n\tfloat dBoard = sdRoundBox(boardPos - vec3(0,-3,0), vec3(12, 0.5, 10.0), 0.1);\n    if(dBoard < o.dist)\n    {\n        o.dist = dBoard;\n        o.difVal = 0.9;\n        \n        //checker board\n        vec3 col;\n        float modi = 2.0*(round(step(sin(pos.z*1.*PI), 0.0)) - 0.5);\n        float goldMod = step(-2.0, pos.x) * step(pos.x, 2.0);\n        \n        col = vec3(1.0*(1.0-goldMod)) + vec3(0.0,0.4,0.6)*goldMod;\n        col *= (round(step((modi)*sin(pos.x*1.0*PI), 0.0)));\n        \n        o.color = col;\n        o.specVal = 200.0;\n        o.specKs = 0.5;\n    }\n    \n    //tree \n    vec3 treePos = pos;\n    vec2 id = floor(vec2(treePos.x/3.5, treePos.z/5.5));\n    treePos.x = abs(treePos.x);\n    treePos.z = mod(treePos.z, 5.5);\n    treePos.x = mod(treePos.x, 7.0);\n    treePos -= vec3(5.5, -4.5, 2.5);\n    \n    float h = sin(id.x) * 337.0 * sin(id.y) * 43.3;\n    h = -1.0 + mod(h, 3.0);\n    float timeMod = 0.5 + mod(id.x*123.0 / id.y*1234.0, 1.0);\n    h *= sin(iTime*1.0 + 43.445*id.y + 122.89*id.x);\n    treePos.y -= h;\n    \n    float treeBound = sdVerticalCapsule(treePos, 5.0, 0.75);\n    \n    if(treeBound < o.dist)\n    {\n        \n        float dTree = sdVerticalCapsule(treePos, 5.0, 0.5);\n        dTree = smin(dBoard, dTree, 0.3);\n        if(dTree < o.dist)\n        {\n            o.dist = dTree;   \n            o.difVal = 0.9;\n            float modi = 2.0*(round(step(sin(pos.z*PI), 0.0)) - 0.5);\n            float yStep = smoothstep(0.0, 0.3, treePos.y);\n\n            vec3 colTrunk = vec3(0.4, 0.3, 0) + vec3(sin(10.0*floor(10.0*treePos.y)))*0.05;\n            vec3 col = mix(vec3(1)*(round(step((modi)*sin(pos.x*1.0*PI), 0.0))),colTrunk, yStep);\n\n            o.color = col;\n            o.specVal = 200.0;\n            o.specKs = 0.0;\n        }\n        //tree leaves\n        vec3 leafPos = pos;\n        leafPos.x = abs(leafPos.x);\n        leafPos.z = mod(leafPos.z, 5.5);\n        leafPos.x = mod(leafPos.x, 7.0);\n        leafPos -= vec3(5.5, 1.5, 2.5);\n        leafPos.y -= h;\n\n        float dLeaf = sdEllipsoid(leafPos, vec3(1.5, 1.0, 1.5));\n        dTree = smin(dTree, dLeaf, 0.5);\n        if(dLeaf < o.dist)\n        {\n            o.dist = dTree;   \n            o.difVal = 0.9;\n\n            float modi = 2.0*(round(step(sin(pos.z*1.*PI), 0.0)) - 0.5);\n\n            float yStep = smoothstep(-1.0, -0.8, leafPos.y);\n            vec3 col = mix(vec3(0.4, 0.3, 0) ,vec3(0, 0.3, 0), yStep);\n\n            o.color = col;\n            o.specVal = 200.0;\n            o.specKs = 0.0;\n        }\n    }\n    \n    //character bounding box\n    float dBBChar = sdSphere(pos - vec3(0,-0.9,0), 1.7);     \n    if(dBBChar < o.dist)\n    {\n        //body\n\t\tfloat dSphere = sdSphere(pos - vec3(0,-0.9,0) + offset, 1.0);\n        \n        //brows\n        float ang = 0.0;\n        vec3 browPos = pos;\n        browPos.x = abs(browPos.x);\n        browPos = browPos - vec3(0.35,-0.5,0.85) + offset;  \n        browPos.y -= -2.0*browPos.x *(2.0*browPos.x/2.0);\n        mat2 browRot = mat2( vec2(cos(ang), -sin(ang)), vec2(sin(ang), cos(ang)) );\n        browPos = vec3(browRot * browPos.xy, browPos.z);\n        float dBrow = sdEllipsoid(browPos, vec3(0.24, 0.1, 0.16));\n        dSphere = smin(dBrow, dSphere, 0.07);\n        \n        if(dSphere < o.dist)\n        {\n            o.dist = dSphere;\n            float z = pos.y + 1.0;\n            vec3 col = vec3(235.0/255.0, 182.0/255.0, 255.0/255.0);\n            col = mix(col,vec3(0.2, 0, .3), (z/2.0));\n            o.color = col;\n            o.specVal = 55.0;\n            o.specKs = 0.04;\n        }\n\n        //mouth\n        vec3 mouthPos = pos - vec3(0, -1.2, 0.9) + offset;\n        mouthPos.y -=  2.0*mouthPos.x * (mouthPos.x/2.0);\n        float mouthHeight = 0.02 + 0.1*clamp(sin(iTime/2.0), 0.0, 1.0);\n        float dMouth = sdEllipsoid(mouthPos, vec3(0.34, mouthHeight, 0.8));\n\t\tif(-dMouth > o.dist)\n            o.color = vec3(255.0/255.0, 182.0/255.0, 215.0/255.0) * 0.6;\n        o.dist = max(o.dist, -dMouth);\n        \n\n\n\n        //hair sdRoundBox( vec3 p, vec3 b, float r )\n        vec3 hairPos = pos - vec3(0, 0.1, 0);\n        hairPos.y -= -hairPos.z * (hairPos.z/2.0);\n        hairPos.y -= 0.05*sin(hairPos.z*25.0);\n        hairPos += offset;\n        float dHair = sdRoundBox(hairPos, vec3(0.1, 0.2, 0.7), 0.05);\n        if(dHair < o.dist)\n        {\n            o.dist = dHair;\n            //o.color = vec3(0.5, 1.0, 0.5);\n            o.color = vec3(1, 0.5, 0.5) + vec3(0, hairPos.y*1.53, 0);\n            o.specVal = 2.0;\n            o.specKs = 0.0;\n        }\n\n        //add bobbing and swinging animation\n        //\n\n        //feet\n        ang = -PI/4.0;\n        vec3 footPos = pos; \n        footPos.x = abs(footPos.x);\n        mat2 footRot = mat2( vec2(cos(ang), -sin(ang)), vec2(sin(ang), cos(ang)) );\n        vec2 footXZ = footRot * footPos.xz;\n        footPos = vec3(footXZ.x, pos.y, footXZ.y);\n        float dFoot = sdEllipsoid(footPos - vec3(0.3,-2.3,0.6), vec3(0.3, 0.3, 0.4));\n        if(dFoot < o.dist)\n        {\n            o.dist = dFoot;\n            o.color = vec3(0.5, 0., 0.);\n            o.specVal = 2.0;\n            o.specKs = 0.4;\n        }\n\n        //hands\n        float hAng = PI/2.0;\n        vec3 handPos = pos;\n        float modi = handPos.x / abs(handPos.x);\n        handPos.x = abs(handPos.x);\n        \n        handPos = handPos - vec3(1.35+offset.y,-1.5,0.0);\n        //handPos += offset;\n        //handPos = opCheapBend(handPos);\n        mat2 handRot = mat2( vec2(cos(hAng), sin(hAng)), vec2(-sin(hAng), cos(hAng)) );\n        vec2 handXZ = handRot * handPos.xz;\n        handPos = vec3(handXZ.x, handPos.y, handXZ.y);\n        //handRot = mat2( vec2(cos(hAng), -sin(hAng)), vec2(sin(hAng), cos(hAng)) );\n        //handPos = vec3(handPos.x, handRot * handPos.yz);\n        float dHand = sdEllipsoid(handPos, vec3(0.3, 0.35, 0.23));\n        if(dHand < o.dist)\n        {\n            o.dist = dHand;\n            o.color = vec3(1);\n            o.specVal = 50.0;\n            o.specKs = 0.4;\n        }\n\n        //eyes\n        vec3 eyePos = pos;\n        eyePos.x = abs(eyePos.x);\n        eyePos += offset;\n        float dEye = sdSphere(eyePos - vec3(0.34,-0.7,0.8), 0.2);\n        if(dEye < o.dist)\n        {\n            o.dist = dEye;\n            o.color = vec3(1);\n            o.specVal = 100.0;\n            o.specKs = 2.0;\n        }\n\n        //pupils\n        vec3 pupPos = pos;\n        pupPos.x = abs(pupPos.x);\n        pupPos += offset;\n        float dEyePup = sdSphere(pupPos - vec3(0.32,-0.7,0.94), 0.08);\n        if(dEyePup < o.dist)\n        {\n            o.dist = dEyePup;\n            o.color = vec3(0);\n            o.specVal = 100.0;\n            o.specKs = 2.0;\n        }\n        \n        //eye lid\n        vec3 lidPos = pos;\n        //lidPos.y = clamp(lidPos.y, -0.8,-0.5);\n        lidPos.x = abs(lidPos.x);\n        lidPos += offset;\n        float dLid = sdSphere(lidPos - vec3(0.34,-0.7,0.8), 0.225);\n        \n        //consulted IQ's happy jumping for a similar blink rate function\n        if(dLid < o.dist && lidPos.y > 1.0 - 2.0*pow(sin(iTime),40.0))\n        {\n            o.dist = dLid;\n            o.color = vec3(235.0/255.0, 182.0/255.0, 255.0/255.0);\n            o.specVal = 55.0;\n            o.specKs = 0.04;\n        }\n    \n    }\n    \n    \n    return o;\n}\n\nvec3 calcNormal(vec3 pos, float ep)\n{\n    return normalize(vec3(map(pos + vec3(ep, 0, 0)).dist - map(pos - vec3(ep, 0, 0)).dist,\n                \t\tmap(pos + vec3(0, ep, 0)).dist - map(pos - vec3(0, ep, 0)).dist,\n                \t\tmap(pos + vec3(0, 0, ep)).dist - map(pos - vec3(0, 0, ep)).dist));                                \n}\n    \nMarchRes marchRay(vec3 pos, vec3 dir, float speed)\n{\n \tMarchRes res;\n    Object o;\n    \n    res.totalDist = 0.001;\n\n    for(int x=0; x<200; x++)\n    {\n \t\tres.curRay = pos + (dir*res.totalDist);\n        \n        o = map(res.curRay);\n        if(abs(o.dist) < 0.00001)\n        {\n            res.obj = o;\n            break;\n        }\n        else if(res.totalDist >= VIEW_DIST) break;\n            \n        res.totalDist += o.dist*speed; // repalce 0.8 w/ this for trippy mode ;p => (0.3+0.2*(sin(iTime))); //couldn't handle the hair :' (\n    }\n    \n    if(res.totalDist < VIEW_DIST)\n    {\n        o.normal = calcNormal(res.curRay, o.normEps);\n        res.obj = o;\n    }\n    \t\n    \n    return res;\n}\n\n//iq (modified slightly)\nfloat marchSoftShadow(vec3 pos, Light l, float speed, float w)\n{\n \tMarchRes res;\n    Object o;\n    vec3 dir = normalize(l.pos);\n    float len = length(l.pos - pos);\n    float maxDist = len;\n    \n    res.totalDist = 0.001;\n\n    float sha = 1.0;\n    for(int x=0; x<200; x++)\n    {\n \t\tres.curRay = pos + (dir*res.totalDist);\n        \n        o = map(res.curRay);\n        \n        sha = min( sha, 0.5*o.dist/(w*res.totalDist) );\n        if(sha < 0.00001)\n        {\n            res.obj = o;\n            break;\n        }\n        else if(res.totalDist > maxDist) break;\n            \n        res.totalDist += o.dist*speed; // repalce 0.8 w/ this for trippy mode ;p => (0.3+0.2*(sin(iTime))); //couldn't handle the hair :' (\n    }\t\n    \n    sha = max(sha,0.0);\n    return sha*sha*(3.0-2.0*sha);\n}\n\nfloat apprSoftShadow(vec3 ro, vec3 rd, float mint, float tmax, float w)\n{\n \tfloat t = mint;\n    float res = 1.0;\n    for( int i=0; i<256; i++ )\n    {\n     \tObject h = map(ro + t*rd);\n        res = min( res, h.dist/(w*t) );\n    \tt += clamp(h.dist, 0.005, 0.50);\n        if( res<-1.0 || t>tmax ) break;\n    }\n    res = max(res,-1.0); // clamp to [-1,1]\n\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep\n}\n\nfloat calcShadowSoft(vec3 pos, Light l)\n{\n    //MarchRes res;\n    float val;\n    \n    //val = apprSoftShadow(pos, normalize(l.pos), 0.1, 20.0, 0.005);\n    \n    if(VIEW_DIST > 20.0)\n \t\tval = marchSoftShadow(pos, l, 1.0, 0.05); //march slower to prevent shadow artifacts\n    else\n    \tval = marchSoftShadow(pos, l, 1.0, 0.05);\n\n\treturn val;\n}\n\nfloat calcShadow(vec3 pos, Light l)\n{\n    MarchRes res;\n    if(VIEW_DIST > 20.0)\n \t\tres = marchRay(pos, normalize(l.pos - pos), 0.3); //march slower to prevent shadow artifacts\n    else\n    \tres = marchRay(pos, normalize(l.pos - pos), 1.0);\n        \n    if(res.totalDist < VIEW_DIST)\n        return 0.0;\n\treturn 1.0;\n}\n\nvec3 calcDiffuseLight(Object o, Light l, vec3 pos)\n{\n    vec3 dir = normalize(l.pos - pos);\n    return (o.color) * l.intensity * l.color * clamp(dot(o.normal, dir), 0.0, 1.0) * o.difVal;   \n}\n\nvec3 calcSpecLight(Object o, Light l, vec3 pos, vec3 camPos)\n{\n \tvec3 dir = normalize(l.pos - pos);  \n    vec3 viewDir = normalize(camPos - pos);\n    vec3 specR = 2.0*clamp( dot(o.normal, dir), 0.0, 1.0) * o.normal - dir;\n    float spec = clamp( dot(viewDir, specR), 0.0, 1.0);\n    //lightInt*(lightCol*pow(lightSpec, res.obj.specVal))*res.obj.specKs * lightShadow;\n      \n    return o.specKs*l.intensity*(l.color*pow(spec, o.specVal));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n\tvec3 camEye = vec3(0,-0.5,3.5);\n    vec3 dir = normalize(vec3(uv, -1));\n    \n\n    float camAng = PI/15.0 + iMouse.x/20.0;\n    float camAngX = iMouse.y/20.0;\n    \n    mat2 rotCam = mat2( vec2(cos(camAng), -sin(camAng)), vec2(sin(camAng), cos(camAng)) );\n    mat2 rotCamX = mat2( vec2(cos(camAng), sin(camAng)), vec2(-sin(camAng), cos(camAng)) );\n\n    vec2 camXZ = rotCam * camEye.xz;\n    camEye = vec3(camXZ.x, camEye.y, camXZ.y);\n    vec2 dirXZ = rotCam * dir.xz;\n    dir = vec3(dirXZ.x, dir.y, dirXZ.y);\n    \n    Light light;\n    light.intensity = 1.0;\n    light.pos = vec3(0, 4, 10);\n    light.color = vec3(1);\n    \n    Light lightSky;\n    lightSky.intensity = 3.1;\n    lightSky.pos = vec3(0, 3, 0);\n    lightSky.color = vec3(0.1, 0.1, 0.1);\n    \n    //add bounce light\n    \n\tMarchRes res = marchRay(camEye, dir, 1.0);\n    vec3 pos = res.curRay;  \n    \n    float y = uv.y + 1.0;\n    y = y / 1.62;\n    y = clamp(y, 0.7, 1.0);\n    vec3 col = (vec3(0.3, 0.6, 0.85)*(y) + vec3(1)*(1.0 - y));\n    col += step(pow(dir.x*10.0, 2.0) + pow(dir.z*50.0+50.0, 2.0), 1.0) * vec3(1,0,0) * vec3(sin(dir.x*10.0)*sin(dir.z*50.0));\n\t//col += vec3(1) * mod(dir*50.0, 2.0) * step(50.0, pos.y);\n    \n    if(res.totalDist < VIEW_DIST)\n    {\n        col = calcDiffuseLight(res.obj, light, pos) * calcShadowSoft(pos, light)\n            + calcDiffuseLight(res.obj, lightSky, vec3(0));\n        //col += calcDiffuseLight(res.obj, light1, pos);\n        col += calcSpecLight(res.obj, light,pos, camEye) * calcShadowSoft(pos, light);\n        col = applyFog(col, sqrt(pow(pos.x,2.0) + pow(pos.y,2.0) + pow(pos.z,2.0)), normalize(pos), normalize(light.pos - pos));\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}