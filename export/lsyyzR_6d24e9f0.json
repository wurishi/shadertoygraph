{"ver":"0.1","info":{"id":"lsyyzR","date":"1520786224","viewed":235,"name":"Advanced bricks1","username":"WQS33","description":"hash and bricks","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["hash","bricks","sampler"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Irrationals with precision shifting \n//\nfloat PHI = 1.61803398874989484820459 * 00000.1; // Golden Ratio   \nfloat PI  = 3.14159265358979323846264 * 00000.1; // PI\nfloat SRT = 1.41421356237309504880169 * 10000.0; // Square Root of Two\n\nfloat seed = 198.34;\n\n// Gold Noise function\n//\nfloat gold_noise(in vec2 coordinate, in float seed)\n{\n    return fract(sin(dot(coordinate*seed, vec2(PHI, PI)))*SRT);\n}\n\n//draw bricks \nvoid Bricks(in vec2 uv, in vec2 div, in float edgeWidth, out float intensity){\n    vec2 orinal_uv = uv;\n    uv = fract(uv * div);\n    \n    \n    float shift = mod(floor(orinal_uv.y * div.y), 2.0);\n    \n    orinal_uv += fract(vec2(shift / div.x * 0.5, 0.0));\n    vec2 index = floor(orinal_uv * div);\n    \n    \n    float intensitdiff = gold_noise(index, seed);\n    //uv *= shift;\n    uv = mod(uv + vec2(0.5 * shift, 0.0), vec2(1.0)) + vec2(0.5);\n    vec2 value = abs(uv - vec2(0.5)) - vec2(edgeWidth * 0.5);    \n    intensity = float(min(value.x, value.y) > 0.0) * intensitdiff;\n}\n\nvoid BricksSamplerPlain(in vec2 uv, in vec2 div, in float edgeWidth, out float intensity, out vec2 sampleUV){\n    vec2 orinal_uv = uv;\n    uv = fract(uv * div);\n    \n    \n    float shift = mod(floor(orinal_uv.y * div.y), 2.0);\n    \n    orinal_uv += fract(vec2(shift / div.x * 0.5, 0.0));\n    vec2 index = floor(orinal_uv * div);\n    \n    \n    sampleUV = index / div;\n    //uv *= shift;\n    uv = mod(uv + vec2(0.5 * shift, 0.0), vec2(1.0)) + vec2(0.5);\n    vec2 value = abs(uv - vec2(0.5)) - vec2(edgeWidth * 0.5);    \n    intensity = float(min(value.x, value.y) > 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float intensity = 0.0;\n    vec2 sampleruv = vec2(0.0);\n    \n    //Bricks(uv, vec2(4, 6), 0.03, intensity);\n    BricksSamplerPlain(uv, vec2(10, 20), 0.06, intensity, sampleruv);\n    \n    vec3 col = texture(iChannel1, sampleruv).rgb * intensity;\n    \n    //intensity = gold_noise(index / vec2(4, 6), seed);\n    //vec3 col = vec3(intensity);\n    \n    //vec3 col = vec3(sampleruv, 0.0);\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}