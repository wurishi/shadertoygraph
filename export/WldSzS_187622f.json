{"ver":"0.1","info":{"id":"WldSzS","date":"1581217624","viewed":278,"name":"volume-light","username":"bitnenfer","description":"Small test inspired by the GDC talk about INSIDE rendering.\nUse mouse horizontal movement to control scene rotation and vertical movement to control light position.","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["volume","raymarch","light"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define USE_NOISE 1\n#define USE_BLUE_NOISE 1\n\nfloat gSeed = 0.0;\nvec2 gUV;\n\nfloat hash( float n )\n{\n    return fract(sin(n + gSeed)*43758.5453);\n}\n\nfloat random() {\n\n    return hash(fract(sin(dot(gUV, vec2(12.9898, 78.233)) * (gSeed += 1.0)) * 43758.5453));\n}\n\nmat2 rot(float r)\n{\n    float c = cos(r), s = sin(r);\n    return mat2(c, s, -s, c);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat box(vec3 p, vec3 s)\n{\n    vec3 d = abs(p) - s;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat map(vec3 p)\n{\n    vec3 pr = p;\n    pr.yz *= rot(1.6);\n    float a = min(min(length(p + vec3(0.0, 0.5, 0.0)) - 0.7, sdTorus(pr + vec3(0.0, 1.0, 2.0), vec2(1.0, 0.4))), p.y + 1.0);\n    float b = box(p + vec3(0.0, 0.0, -3.0), vec3(200.0, 200.0, 0.3));\n    b = max(b, -box(p + vec3(0.0, -3.0, 0.0), vec3(1.0, 3.5, 20.0)));\n    b = max(b, -box(p + vec3(0.0, -3.0, 0.0), vec3(2.0, 1.0, 20.0)));\n    return min(a, b);\n}\n\nvec3 norm(vec3 p)\n{\n    const vec2 e = vec2(0.0, 0.001);\n    return normalize(vec3(\n        map(p + e.yxx) - map(p - e.yxx),\n        map(p + e.xyx) - map(p - e.xyx),\n        map(p + e.xxy) - map(p - e.xxy)\n    ));\n}\n\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 color = vec3(0.0);\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    \n    gUV = uv;\n    gSeed = 0.0;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    bool useMouseCtrl = iMouse.z > 0.0;\n    \n    float mx = 1.4 * sin(iTime * 0.2);\n    float my = 0.24;\n    \n    if (useMouseCtrl)\n    {\n\t    mx = (iMouse.x / iResolution.x * 2.0 - 1.0);\n    \tmy = 0.1 + (iMouse.y / iResolution.y);\n    }\n    \n    vec3 l = vec3(0.0, my, 1.0);\n    vec3 ro = vec3(0.0, 3.0, -20.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y - 0.2, 4.0));\n    \n    ro.xz *= rot(mx);\n    rd.xz *= rot(mx);\n    \n    // moon rendering\n    float lt = 0.0;\n    float moonGlow = 0.0;\n    for (int i = 0; i < 100; ++i)\n    {\n       \n        float ld = (length((ro + rd * lt) - (l * 50.0)) - 0.2);\n        moonGlow += 4.0/(0.1+pow(ld,2.0));\n        if (ld < 0.1) \n        {\n            color += 1.0;\n            break;\n        }\n        lt += ld;\n        \n    }\n    color += vec3(0.01) * moonGlow;\n    \n    float t = 0.0;\n    \n    for (int i = 0; i < 300; ++i)\n    {\n        float d = map(ro + rd * t);\n        if (d < 0.01)\n        {\n            break;\n        }\n        t += d;\n        if (t > 100.0) break;\n    }\n    \n    // lambert reflectance\n    if (t < 100.0)\n    {\n        vec3 p = ro + rd * t;\n        vec3 n = norm(p);\n        vec3 v = normalize(ro - p);\n        vec3 h = normalize(v + l);\n        #if 1\n        float NdotH = dot(n, h) * 0.5 + 0.5;\n        float NdotL = dot(n, l) * 0.5 + 0.5;\n        #else\n        float NdotH = max(dot(n, h),0.0);\n        float NdotL = max(dot(n, l),0.0);        \n        #endif\n        vec3 checkerP = p * 1.0;\n        float checker = 0.5+mod(floor(checkerP.x) + floor(checkerP.y) + floor(checkerP.z), 2.0);\n        float sh = 1.0;\n    \n        // hard shadows \n        #if 1\n        vec3 srd = l;\n        vec3 sro = p + srd * 0.1;\n        float st = 0.0;\n        for (int i = 0; i < 64; ++i)\n        {\n            float d = map(sro + srd * st);\n            if (d < 0.001)\n            {\n                sh = 0.0;\n                break;\n            }\n            st += d;\n            if (st > 100.0) break;\n        }\n        #endif\n        vec3 checkerColor = vec3(0.1) + checker * vec3(0.1);\n        color = checkerColor + vec3(0.6, 0.6, 1.0) * (NdotL*sh) + pow(NdotH * sh, 10.0)*0.1;\n        color = mix(color, vec3(0.0), clamp(t / 40.0, 0.0, 1.0));\n    }\n    \n    // volumetric light\n    #if 1\n    {    \n        vec3 lc = vec3(0.0);\n        float t1 = 0.0;\n        for (int i = 0; i < 150; ++i)\n        {\n            vec3 o = ro + rd * t1;\n            float t2 = 0.0;\n            for (int j = 0; j < 60; ++j)\n            {\n                float d = map(o + l * t2);\n                if (d < 0.01)\n                {\n                    break;\n                }\n                t2 += d;\n                if (t2 > 100.0)\n                {\n                    lc += 0.4;\n                    break;\n                }\n            }\n            #if USE_NOISE\n            #if USE_BLUE_NOISE\n            t1 += 0.1 + (texture(iChannel0, (o + l * t2).xz).r) * 0.2;\n            #else\n            t1 += 0.1 + random() * 0.2;\n            #endif\n            #else\n            t1 += 0.2;\n            #endif\n            if (t1 > t) break;\n        }\n        color += clamp(lc / 100.0, 0.0, 0.1) * (vec3(0.1, 0.1, 0.2) * 10.0);\n    }\n    #endif\n        \n    fragColor = vec4(acesFilm(color), 1.0);\n}","name":"Image","description":"","type":"image"}]}