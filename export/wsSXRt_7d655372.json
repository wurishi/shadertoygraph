{"ver":"0.1","info":{"id":"wsSXRt","date":"1554683533","viewed":166,"name":"surf_surreal","username":"rory618","description":"Surf (counter strike/quake style ramp sliding) on a world defined by a signed distance function. WASD direction and mouse to look around, make sure to use \"Enable Mouse Lock\" link in my first comment.","likes":8,"published":1,"flags":48,"usePreview":0,"tags":["game","sdf","surf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_SPACE = 32;\nconst int KEY_W = 87;\nconst int KEY_A = 65;\nconst int KEY_S = 83;\nconst int KEY_D = 68;\n#define T(x) texelFetch(iChannel0, ivec2(x,0),0)\n#define flmaxspeed .01\nvoid mainImage( out vec4 o, in vec2 i )\n{\n    vec3 p = T(0).xyz;\n    vec3 v = T(1).xyz;\n    vec4 d = T(2);\n    vec4 m = T(3);\n    if(iFrame <3 || texelFetch(iChannel3, ivec2(82,1) , 0).x>.5 ) {\n        p = vec3(0,2,1);\n        v = vec3(0,0,0);\n        d = vec4(1,0,0,0);\n    } else {\n        vec3 norm = vec3(0);\n        v.y-=.002;\n        float rad = .0007;\n        \n        float dst = map(p);\n        if(map(p) < rad){\n            norm = normalize(vec3(map(p+vec3(1e-6,0,0)),map(p+vec3(0,1e-6,0)),map(p+vec3(0,0,1e-6)))-dst);\n            v -= dot(v,norm) * norm *.6;\n            p += norm*max(0.,rad-dst)*.6;\n            \n        }\n        \n        \n        if(texelFetch( iChannel3, ivec2(KEY_SPACE,0), 0 ).x>.0 && p.y==0. ){\n            v.y=.03;\n        }\n        float fmove = 0.;\n        float smove = 0.;\n        if(texelFetch( iChannel3, ivec2(KEY_W,0), 0 ).x>.0){\n            fmove += 1.;\n        }\n        if(texelFetch( iChannel3, ivec2(KEY_A,0), 0 ).x>.0 ){\n            smove += 1.;\n        }\n        if(texelFetch( iChannel3, ivec2(KEY_S,0), 0 ).x>.0  ){\n            fmove -= 1.;\n            \n        }\n        if(texelFetch( iChannel3, ivec2(KEY_D,0), 0 ).x>.0 ){\n            smove -= 1.;\n        }\n        vec3 f = d.xyz;\n        f.y=0.;\n        f/=length(f);\n        vec3 r = vec3(-f.z,0,f.x);\n        //This is the heart of surfing\n        if(fmove!=0.||smove!=0.){\n            \n            vec3 wishvel = f * fmove + r * smove;\n            float wishspeed = length(wishvel);\n            if(norm != vec3(0)){\n                if(dot(wishvel,norm)<0.){\n                    wishvel = cross(cross(norm,wishvel),norm) * wishspeed;\n                }\n            }\n            if (wishspeed != 0. && (wishspeed > flmaxspeed))\n            {\n                wishvel *= flmaxspeed / wishspeed;\n                wishspeed = flmaxspeed;\n            }\n            vec3 wishdir = normalize(wishvel);\n            float currentspeed = dot(wishdir, v);\n\n\t\t\tfloat addspeed = wishspeed - currentspeed;\n            addspeed = max(0.,addspeed);\n            float accelspeed = wishspeed * 100.;\n            accelspeed = min(accelspeed, addspeed);\n            v += wishdir * accelspeed;\n            \n        }\n        p = p + v*1e-3;\n\n    }\n    if(iMouse.zw != vec2(0)){\n        float phi = acos(d.y);\n        float theta = atan(d.z,d.x);\n        vec2 dm = (iMouse.zw-m.zw)*vec2(1,-1);\n        phi -= dm.y/2000.;\n        phi = max(min(phi,3.),0.1);\n        theta -= dm.x/2000.;\n        d.xyz = vec3(cos(theta)*sin(phi),cos(phi),sin(theta)*sin(phi));\n    }\n    o = vec4(0);\n    o += float(int(i.x)==0)*vec4(p,0);\n    o += float(int(i.x)==1)*vec4(v,0);\n    o += float(int(i.x)==2)*d;\n    o += float(int(i.x)==3)*iMouse;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//Thanks gleurop for base of this distance feild from The other road to hell - https://www.shadertoy.com/view/Xsf3z2\n\n// I love this distance field. So elegant, and I can thank Fizzer for coming up with it.\n// The idea is about as simple as it gets. Break space into octahedrons then use each\n// otahedral cell to obtain a unique ID. Use that ID to render a randomly oriented square \n// tube and you're done.\n//\n// I've done a little trimming and shuffling, which probably confuses things slightly. \n// Either way, it's worth reading the following article for a much clearer explanation:\n//\n// Implicit Maze-Like Patterns - Fizzer\n// http://amietia.com/slashmaze.html\n//\nvec2 rotate(in vec2 v, in float a) {\n\treturn vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y);\n}\n\nfloat torus(in vec3 p, in vec2 t)\n{\n\tvec2 q = abs(vec2(max(abs(p.x), abs(p.z))-t.x, p.y));\n\treturn max(q.x, q.y)-t.y;\n}\n\nfloat torusv(in vec3 p, in vec2 t)\n{\n\tvec2 q = abs(vec2(max(abs(p.x+p.z)/sqrt(2.), abs(p.x-p.z)/sqrt(2.))-t.x, p.y));\n\treturn max(q.x, q.y)-t.y;\n}\n\n// These are all equally interesting, but I could only pick one :(\nfloat trap(in vec3 p)\n{\n\t//return abs(max(abs(p.y)-0.1, abs(p.x)-0.1))-0.01;\n\t//return length(max(abs(p.xy) - 0.05, 0.0));\n\t//return length(p)-0.5;\n\t//return length(max(abs(p) - 0.35, 0.0));\n\t//return abs(length(p.xz)-0.2)-0.01;\n\t//return (min(torus(vec3(p.x-p.y, mod(p.y+p.x,0.4)-0.2, p.z), vec2(0.6, 0.05)), max(abs(p.z)-0.05, abs(p.x-p.y)-0.05)))-0.005;\n\treturn (min(torusv(vec3(p.x-p.y, mod(length(p.xz),0.4)-0.2, p.z), vec2(0.6, 0.05)), length(vec2(abs(p.y)-0.05, length(p.xz)-0.05))))-0.005;\n\t//return abs(min(torus(p, vec2(0.3, 0.05)), max(abs(p.z)-0.05, abs(p.x)-0.05)))-0.005;\n\t//return min(length(p.xz), min(length(p.yz), length(p.xy))) - 0.05;\n}\n\nfloat map(in vec3 p)\n{\n    float time = 0.+0.0;\n\tfloat cutout = dot(abs(p.yz),vec2(0.5))-0.035;\n\tfloat road = max(abs(p.y-0.025), abs(p.z)-0.035);\n\t\n\tvec3 z = abs(1.0-mod(p,2.0));\n\tz.yz = rotate(z.yz, time*0.05);\n\n\tfloat d = 999.0;\n\tfloat s = 1.0;\n\tfor (float i = 0.0; i < 4.0; i++) {\n\t\tz.xz = rotate(z.xz, radians(i*10.0+time));\n\t\tz.zy = rotate(z.yz, radians((i+1.0)*20.0+time*1.1234));\n\t\tz = abs(1.0-mod(z+i/3.0,2.0));\n\t\t\n\t\tz = z*2.0 - 0.3;\n\t\ts *= 0.5;\n\t\td = min(d, trap(z) * s);\n\t}\n\treturn min(max(d, -cutout), road);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define T(x) texelFetch(iChannel3, ivec2(x,0),0)\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float time = iTime+60.0;\n\tvec3 upDirection = vec3(0, 1, 0);\n\tvec3 cameraDir = (T(2)).xyz;\n\tvec3 p = (T(0)).xyz;\n\t\n\tvec3 u = normalize(cross(upDirection, cameraDir));\n\tvec3 v = normalize(cross(cameraDir, u));\n\tvec2 screenPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n\tvec3 rd = normalize(u * screenPos.x + v * screenPos.y + cameraDir*(1.0-length(screenPos)*0.5));\n    float l = 0.;\n    for(int i = 0; i < 40; i++){\n        float closest = map(p+l*rd);\n        l += .8*closest;\n    }\n    p = p+l*rd;\n    \n    vec3 norm = normalize(1e-6+vec3(map(p+vec3(1e-4,0,0)),map(p+vec3(0,1e-4,0)),map(p+vec3(0,0,1e-4)))- map(p));\n    l=(l*l+5.)/(l+1.);\n    l*=10.;\n\tfragColor = .4*texture(iChannel0,fragCoord.xy/iResolution.xy) + .6*vec4(0.5+0.5*sin(.4*vec3(acos(norm.y),atan(norm.z,norm.x),0)+l*vec3(.3,.4,.5)),1.0);\n\n\n    \n} \n    ","name":"Buffer B","description":"","type":"buffer"}]}