{"ver":"0.1","info":{"id":"MtyyzD","date":"1676517307","viewed":98,"name":"A Drive Home (Remake)","username":"ROAG99","description":"Work extending the project from the Art of Code tutorial.\n\nadditions: Road vibrations\n\ns/o creator bigwings","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["artofcodetut"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define S(x,y,z) smoothstep(x,y,z)\n\nfloat Noise(float t){\n    return fract(sin(t*3456.)*6547.);\n}\n\nvec4 N14(float t){\n    return fract(sin(t*vec4(123., 1024., 3456., 9564.))*vec4(6547., 345., 8799., 1564.));\n}\n\nstruct ray{\n    vec3 origin, dir;\n};\nray CreateCamera(vec2 uv, vec3 camPos, vec3 lookat, float zoom) {\n\tray ret;\n    ret.origin = camPos;\n    \n    vec3 forward = normalize(lookat-camPos);\n    vec3 right = cross(vec3(0, 1., 0),forward);\n    vec3 up = cross(forward, right);\n    vec3 center = ret.origin + forward*zoom;\n    vec3 intersection = center + uv.x*right + uv.y*up;\n    \n    ret.dir = normalize(intersection - ret.origin);\n    return ret;\n}\n\nray GetRay(vec2 uv, vec3 camPos, vec3 lookat, float zoom) {\n\tray ret;\n    ret.origin = camPos;\n    \n    vec3 forward = normalize(lookat-camPos);\n    vec3 right = cross(vec3(0, 1., 0),forward);\n    vec3 up = cross(forward, right);\n    vec3 center = ret.origin + forward*zoom;\n    vec3 intersection = center + uv.x*right + uv.y*up;\n    \n    ret.dir = normalize(intersection - ret.origin);\n    return ret;\n}\n\nvec3 ClosestPoint(ray r, vec3 p){\n \tvec3 ret;\n    ret = r.origin + max(0., dot(p - r.origin, r.dir))*r.dir;\n    return ret;\n}\n\nfloat DistRay(ray r, vec3 p){\n \treturn length(p - ClosestPoint(r, p));   \n}\n\nfloat Bokeh(ray r, vec3 p, float size, float blur){\n \tfloat ret;\n    size *= length(p);\n    float dist = DistRay(r, p);\n    ret = S(size,size*(1.-blur),dist);\n    ret *= mix(.6, 1., S(size*.8, size, dist));\n    return ret;\n}\n\nvec3 Streetlights(ray r, float t){\n    float side = step(r.dir.x, 0.);\n\tr.dir.x = abs(r.dir.x);\n    \n    float mask;\n    float s = (1./10.);\n    for (float i =0.; i < 1.; i+=s){\n        float ti = fract(t + i + side*s*0.5);\n    \tvec3 p = vec3(2., 2., 100.-ti*100.);\n      \tmask += Bokeh(r, p, .05, .1)*ti*ti*ti;\n    }\n    return vec3(.7, .2, .01)*mask;\n}\n\nvec3 Envlights(ray r, float t){\n    float side = step(r.dir.x, 0.);\n\tr.dir.x = abs(r.dir.x);\n    \n    vec3 c = vec3(0.);\n    \n    float s = (1./10.);\n    for (float i =0.; i < 1.; i+=s){\n        float ti = fract(t + i + side*s*0.5);\n        \n        vec4 n = N14(i+side*100.);\n        float x = mix(2.5, 10., n.x);\n        float y = mix(1., 1.5, n.y);\n        \n        float occlusion = sin(ti*6.28*10.*n.x)*.5+.5;\n        float fade = occlusion; //ti*ti*ti;\n        \n        vec3 colour = n.wzy;\n        \n    \tvec3 p = vec3(x, y, 50.-ti*50.);\n      \tc += Bokeh(r, p, .05, .1)*fade*colour*.2;\n    }\n    return c;\n}\n\nvec3 Headlights(ray r, float t){\n    t*=2.;\n    float carWidth = .25;\n    float carWidth2 = carWidth*1.2;\n    float mask;\n    float s = (1./30.);\n    for (float i =0.; i < 1.; i+=s){\n        float randNo = Noise(i);\n        if (randNo > 0.1) continue;\n        float ti = fract(t + i + s*0.5);\n    \tfloat z =  100. - ti*100.;\n        float fade = ti*ti*ti*ti*ti;\n\t\tfloat focus = S(.9, 1., ti);\n        float size = mix(.05, .03, focus);\n        \n        mask += Bokeh(r, vec3(-1.-carWidth,.15,z), size, .1)*fade;\n        mask += Bokeh(r, vec3(-1.+carWidth,.15,z), size, .1)*fade;\n        \n        mask += Bokeh(r, vec3(-1.-carWidth2,.15,z), size, .1)*fade;\n        mask += Bokeh(r, vec3(-1.+carWidth2,.15,z), size, .1)*fade;\n        \n        float ref = .0;\n        ref += Bokeh(r, vec3(-1.-carWidth2,-.15,z), size*3., 1.)*fade;\n        ref += Bokeh(r, vec3(-1.+carWidth2,-.15,z), size*3., 1.)*fade;\n        \n        mask += ref*focus;\n    }\n    return vec3(.9, .9, 1.)*mask;\n}\n\nvec3 Taillights(ray r, float t){\n    t*= .25;\n    float carWidth = .25;\n    float carWidth2 = carWidth*1.2;\n    float mask;\n    float s = (1./15.);\n    for (float i =0.; i < 1.; i+=s){\n        float randNo = Noise(i);\n        if (randNo < 0.5) continue;\n        float lane = step(.25, randNo);\n        \n        float ti = fract(t + i);\n    \tfloat z =  100. - ti*100.;\n        float fade = ti*ti*ti*ti*ti;\n\t\tfloat focus = S(.9, 1., ti);\n        float size = mix(.05, .03, focus);\n        \n        float laneShift = S(1., .96, ti);\n        float x = 1.5 - lane*laneShift;\n        \n        float blink = step(0., sin(t*1000.))*7.*lane*step(.96, ti);\n        mask += Bokeh(r, vec3(x-carWidth,.15,z), size, .1)*fade;\n        mask += Bokeh(r, vec3(x+carWidth,.15,z), size, .1)*fade;\n        \n        mask += Bokeh(r, vec3(x-carWidth2,.15,z), size, .1)*fade;\n        mask += Bokeh(r, vec3(x+carWidth2,.15,z), size, .1)*fade*(1.+blink);\n        \n        float ref = .0;\n        ref += Bokeh(r, vec3(x-carWidth2,-.15,z), size*3., 1.)*fade;\n        ref += Bokeh(r, vec3(x+carWidth2,-.15,z), size*3., 1.)*fade*(1.+blink*.1);\n        \n        mask += ref*focus;\n    }\n    return vec3(1., .1, .03)*mask;\n}\n\nvec2 Rain(vec2 uv, float t){\n    t*=40.;\n\n    vec2 a = vec2(3., 1.);\n    //grab the uv coord so that they can manipulated\n    vec2 st = uv*a;\n    //create an id for grid divided screen\n    vec2 id = floor(st);\n    //scroll uvs in st\n    st.y+=t*.20;\n    float n = fract(sin(id.x*716.34)*768.34);\n    st.y+=n;\n    uv.y+=n;\n    id = floor(st);\n    st = fract(st)-.5;\n    \n    t+=fract(sin(id.x*76.34+id.y*1453.7)*768.34)*6.283;\n    float y = -sin(t+sin(t+sin(t)*.5))*.42;\n    vec2 p1 = vec2(0., y);\n    vec2 o1 = (st-p1)/a;\n    float d = length(o1);\n    float m1 = S(.07, 0., d);\n    // if (st.x>.46 || st.y>.49) m1 = 1.;\n    \n    vec2 o2 = (fract(uv*a.x*vec2(1., 2.))-.5)/vec2(1., 2.);\n    d=length(o2);\n    float m2 = S(.2*(.5-st.y), 0., d)*S(-.1, .1, st.y-p1.y);\n \treturn vec2(m1*o1*30.+m2*o2*20.);   \n}\n\nbool vibsFlag = false;\nvec3 tremble(vec3 camPos, float t){\n    // ease in/out sin wave\n    float vibzEaseIO = sin(t*0.8);\n    // gen vec4 random numbers\n    vec4 rand4 = N14(t);\n    // first gens small +- vibrations on original cam y\n    float yVibs = sin(rand4.x*78.)*0.0025;\n    // second controls allowToVibrate flag, set to zero when random val is not good\n    float vibzFlag = fract(rand4.y);\n    if (vibzFlag < 0.3 && !vibsFlag){\n        // if good vibration only persists as long sinShiftDown > 0\n        vibsFlag = true;\n        camPos.y += yVibs*vibzEaseIO;\n    }\n    else{\n        vibsFlag = step(0., vibzEaseIO)>0.;\n    }\n    \n \treturn camPos;   \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n\tfloat timeslowdown = 0.05;\n    float t = iTime*timeslowdown + mouse.x;\n    \n    vec3 camPos = vec3(0.5, .2, 0); \n    vec3 lookat = tremble(vec3(0.5, .2, 1.), t);\n    \n    vec2 rainDistort = Rain(uv*5., t)*.5;\n    rainDistort = Rain(uv*7., t)*.5;\n    \n    uv.x += sin(uv.y*70.)*.005;\n    uv.y += sin(uv.x*120.)*.003;\n    \n    ray r = CreateCamera(uv-rainDistort*.5, camPos, lookat, 2.);\n    vec3 col = Streetlights(r, t);\n    col += Headlights(r, t);\n    col += Taillights(r, t);\n    col += Envlights(r, t);\n    col += (r.dir.y+.25)*vec3(.2, .1, .5);\n    \n    // Output to screen\n    //col = vec3(rainDistort, 0.);\n    fragColor = vec4(col, 1.);\n}\t\t","name":"Image","description":"","type":"image"}]}