{"ver":"0.1","info":{"id":"MscyW4","date":"1518814426","viewed":196,"name":"Inverse Menger","username":"chronosis","description":"9 levels of recursion on an inverse Menger sponge, with 200 steps of raymarching. \n\nNote: At farther distances and dense regions there will be distortion from light scattering. This can be fixed by increasing the # of steps at the cost of performance.","likes":5,"published":1,"flags":64,"usePreview":0,"tags":["raymarching","fractal","menger"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XtSGRc","filepath":"https://soundcloud.com/chronosis/chronosis-satellite","previewfilepath":"https://soundcloud.com/chronosis/chronosis-satellite","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Based on Inigo Quilez Menger Sponge\n// https://iquilezles.org/articles/menger\n\n#define levels 9.\n#define steps 200\n\n// light\nvec3 light = normalize(vec3(1.0, 0.9, 0.3));\n\nfloat msize = pow(3., (levels - 3.));\n\nfloat maxcomp(in vec3 pos) { return max(pos.x, max(pos.y, pos.z));}\nint msteps = steps;\n\nfloat sdBox(vec3 pos, vec3 size)\n{\n  vec3 delta = abs(pos) - size;\n  float mc = maxcomp(delta);\n  return min(mc, length(max(delta, 0.0)));\n}\n\nvec4 map(in vec3 pos)\n{\n    float d = sdBox(pos, vec3(msize));\n    vec4 res = vec4( d, 1.0, 0.0, 0.0 );\n\n    float size = (1. / msize);\n    for( float lvl = 0.; lvl < levels; lvl++ )\n    {\n        // \n        vec3 a = mod( pos * size, 2.0 ) - 1.0;\n        // Increase size by 3 each level\n        size *= 3.0;\n        vec3 r = abs(3.0 - 3.0 * abs(a));\n        float da = max(r.x, r.y);\n        float db = max(r.y, r.z);\n        float dc = max(r.z, r.x);\n        float c = (min(da, min(db, dc)) - 1.0) / size;\n\n        // if point is outside box\n        if( c > d )\n        {\n          d = c;\n          res = vec4( d, min(res.y, 0.2 * da * db * dc), (1.0 + float(lvl)) / levels, 0.0 );\n        }\n    }\n\n    return res;\n}\n\nvec4 intersect( in vec3 ro, in vec3 rd )\n{\n    float t = 0.0;\n    vec4 res = vec4(-1.0);\n\tvec4 h = vec4(1.0);\n    for( int i=0; i < msteps; i++ )\n    {\n\t\tif( h.x < 0.001 || t > msize ) break;\n        h = map(ro + rd*t);\n        res = vec4(t,h.yzw);\n        t += h.x;\n    }\n\tif( t > msize ) res=vec4(-1.0);\n    return res;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n\tfloat h = 1.0;\n    for( int i = 0; i < msteps; i++ )\n    {\n        h = map(ro + rd * t).x;\n        res = min(res, k * h / t);\n\t\tt += clamp(h, 0.0005, 0.1);\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 nor;\n    nor.x = map(pos+eps.xyy).x - map(pos-eps.xyy).x;\n    nor.y = map(pos+eps.yxy).x - map(pos-eps.yxy).x;\n    nor.z = map(pos+eps.yyx).x - map(pos-eps.yyx).x;\n    return normalize(nor);\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    // background color\n    float f = rd.x * 0.5 + 0.5;\n    vec3 col = mix( vec3(0.8, 0.3, 0.2), vec3(0.7, 0.7, 0.2), f);\n    vec2 r = rd.xy;\n    r.x = abs(abs(r.y) - abs(r.x));\n    col *= vec3(texture(iChannel0, r.xy).x);\n\t\n    vec4 tmat = intersect(ro, rd);\n    if( tmat.x > 0.0 )\n    {\n        vec3  pos = ro + tmat.x * rd;\n        vec3  nor = calcNormal(pos);\n\t\t\n        float occ = tmat.y;\n\t\tfloat sha = softshadow(pos, light, 0.1, 128.0);\n\n\t\tfloat dif = max(0.1 + 0.9 * dot(nor, light), 0.0);\n\t\tfloat sky = 0.5 + 0.5 * nor.y;\n        float bac = max(0.4 + 0.6 * dot(nor, vec3(-light.x, light.y, -light.z)), 0.0);\n\n        vec3 lin  = vec3(0.0);\n        lin += 1.00 * dif * vec3(1.10, 0.85, 0.60) * sha;\n        lin += 0.50 * sky * vec3(0.10, 0.20, 0.40);// * occ;\n        lin += 0.10 * bac * vec3(1.00, 1.00, 1.00) * (0.5 + 0.5 * occ);\n        lin += 0.25 * occ * vec3(0.15, 0.17, 0.20);\t \n\n        vec3 matcol = vec3(\n            0.6 + 0.5 * cos(2.0 + 2.0 * tmat.z),\n            0.5 + 0.5 * cos(1.0 + 1.0 * tmat.z),\n            0.5 + 0.5 * cos(0.0 + 0.0 * tmat.z) );\n        col = matcol * lin;\n    }\n\n    //return col;\n    return pow( col, vec3(0.4545) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    float ctime = iTime;\n    // camera\n    vec3 ro = 10. * vec3(0.5 * sin(0.25 * ctime), 1.0 + 1.0 * cos(.13 * ctime), 0.5 * cos(0.25 * ctime));\n    vec3 ww = normalize(vec3(0.0) - ro);\n    vec3 uu = normalize(cross( vec3(0.0, 1.0, 0.0), ww ));\n    vec3 vv = normalize(cross(ww, uu));\n    vec3 rd = normalize( p.x * uu + p.y * vv + 2.5 * ww );\n\n    vec3 col = render( ro, rd );\n    \n    fragColor = vec4(col, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}