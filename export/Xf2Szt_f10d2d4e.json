{"ver":"0.1","info":{"id":"Xf2Szt","date":"1706698285","viewed":85,"name":"gabor face :)","username":"altunenes","description":"yet another experiment with gabors...  :)\nI might add some hair, and a nose in the future :-)  (If I manage :D ) ","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["face","gabor","pareidolia"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.1415926535897932384626433832795;\n// Gabor fn\nvec3 gaborPatch(vec2 uv, vec2 patchPos, float lambda, float sigma, float gamma, float theta, float psi) {\n    vec2 uvPatch = uv - patchPos;\n    float xPrime = uvPatch.x * cos(theta) - uvPatch.y * sin(theta);\n    float yPrime = uvPatch.x * sin(theta) + uvPatch.y * cos(theta);\n    float envelope = exp(-((xPrime * xPrime) + (gamma * gamma * yPrime * yPrime)) / (2.0 * sigma * sigma));\n    float carrier = cos(2.0 * PI * xPrime / lambda + psi);\n    float gabor = envelope * carrier;\n    return 0.5 * vec3(gabor);\n}\n//oscilation fn for scramble\nfloat osc(float minValue, float maxValue, float interval, float currentTime) {\n    return minValue + (maxValue - minValue) * 0.5 * (sin(2.0 * PI * currentTime / interval) + 1.0);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = 2.0 * (fragCoord / iResolution.xy) - 1.0;\n    float lambda = 0.06; // Wavelength\n    float scramb = osc(0.05, 0.02, 5.0, iTime); //scrambling for sigma\n    float sigma = scramb;  // Gaussian envelope sigma\n    float gamma = 1.0;   // Aspect ratio\n\n    vec3 col = vec3(0.5); // bg \n    float fr = 0.45; // Radius of the face circle\n    vec2 fc = vec2(0.0, 0.0); // Center of the face\n\n    // Eye parameters\n    float er = 0.05; // Radius of the eyes\n    vec2 le = vec2(-0.15, 0.1); // Position of the left eye\n    vec2 re = vec2(0.15, 0.1); // right eye\n   // Mouth parameters\n    float mw = 0.25; // Width of the mouth\n    float mcurv = 0.15; // Curvature of the mouth\n    vec2 mc = vec2(0.0, -0.15); // Centeral position of the mouth\n\n    int N = 100; // Number of gabor patches (for each part; n/2 for mouth)\n\n    for (int i = 0; i < N; ++i) {\n        // face\n        float thetaFace = 2.0 * PI * float(i) / float(N); \n        vec2 patchPosFace = fc + fr * vec2(cos(thetaFace), sin(thetaFace));\n        float psiFace = iTime * 5.5 + float(i) * PI / 10.0; // Phase offset\n        col += gaborPatch(uv, patchPosFace, lambda, sigma, gamma, thetaFace, psiFace);\n        // left eye\n        float thetaEye = 2.0 * PI * float(i) / float(N);\n        vec2 PosLeftey = le + er * vec2(cos(thetaEye), sin(thetaEye));\n        float psilefteye = iTime * 5.5 + float(i) * PI / 10.0;\n        col += gaborPatch(uv, PosLeftey, lambda, sigma, gamma, thetaEye, psilefteye);\n        // patch Posright eye\n        vec2 PosRe = re + er * vec2(cos(thetaEye), sin(thetaEye));\n        float psiRightEye = iTime * 5.5 + float(i) * PI / 10.0;\n        col += gaborPatch(uv, PosRe, lambda, sigma, gamma, thetaEye, psiRightEye);\n        // mouth\n        if (i < N / 2) {  //n/2 gabor for mouth\n            float thetaMouth = 2.0 * PI * float(i) / float(N / 2) - PI; \n            float xMouth = mw * cos(thetaMouth);\n            float yMouth = mcurv * sin(thetaMouth);\n            vec2 posmouth = mc + vec2(xMouth, -abs(yMouth));\n            float psiMouth = iTime * 5.5 + float(i) * PI / 10.0; // Phase offset\n            col += gaborPatch(uv, posmouth, lambda, sigma, gamma, thetaMouth, psiMouth);\n    }\n        }\n\n    fragColor = vec4(col, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}