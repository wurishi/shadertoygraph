{"ver":"0.1","info":{"id":"3lKfRh","date":"1613866518","viewed":75,"name":"lissajous electric boogaloo","username":"pema99","description":"local bezier approximation https://www.geogebra.org/classic/sx9g2rsw","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["lissajous"],"hasliked":0,"parentid":"3ldfWf","parentname":"Failed lissajous experiment xdd"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// from iq: https://www.shadertoy.com/view/MlKcDD\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\nfloat udBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if( h>=0.0 ) \n    {   // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d+(c+b*t)*t);\n    }\n    else \n    {   // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0))/3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n    }\n    \n    return res; // edit: no need for sqrt here, it can be added after marching\n}\n\n// My code starts here\n#define LINES 0 // Use line segments instead of bezier\n#define DOTS 0 // Show dots evaluated along the curve\n#define CUTOFF 1 // Makes the DE easier to visualize\n\nvec2 lissajous(float t, float a, float b, float omega, float delta)\n{\n    t = clamp(t, 0.0, 6.28);\n    return vec2(a*sin(omega*t+delta), b*sin(t));\n}\n\nfloat lissajousDist(vec2 p, float a, float b, float omega, float delta)\n{\n    float minDist = 1000.0;\n    \n    float iters = 24.0;\n    float inc = 6.28 / iters;\n    float incHalf = inc / 2.0;\n    \n    for (float t = 0.0; t < 6.28; t += inc)\n    {\n        vec2 pa = lissajous(t, a, b, omega, delta);\n        vec2 pc = lissajous(t + inc, a, b, omega, delta);\n        \n        vec2 mid = lissajous(t + incHalf, a, b, omega, delta);\n        vec2 pb = vec2(2.0*mid.x-(pa.x/2.0)-(pc.x/2.0), 2.0*mid.y-(pa.y/2.0)-(pc.y/2.0));\n        \n        #if LINES\n        pb = pa;\n        #endif\n        \n        minDist = min(minDist, udBezier(p, pa, pb, pc));\n    }\n    \n    return sqrt(minDist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy - 0.5) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n    uv *= 1.33;\n    \n    float a = 1.0;\n    float b = 1.0;\n    float omega = (sin(iTime*0.3)*0.5+0.5)*3.14*2.0;//m.x*3.14*2.0;\n    float delta = (cos(iTime*0.3)*0.5+0.5)*3.14/2.0;//3.14/2.0*m.y;\n    \n    float c1 = 0.0;\n    for (float i = 0.0; i < 6.28; i += 0.01)\n    {\n        vec2 d = lissajous(i, a, b, omega, delta);\n        c1 = max(c1, smoothstep(0.02, 0.0, distance(d, uv)));\n    }\n    #if !DOTS\n    c1 = 0.0;\n    #endif\n    \n    float c2 = lissajousDist(uv, a, b, omega, delta);\n    #if CUTOFF\n    if (c2 <= 0.01) c2 = 1.0;\n    #endif\n\n    fragColor = vec4(c1, c2, 0.0, 1.0);\n}","name":"Image","description":"","type":"image"}]}