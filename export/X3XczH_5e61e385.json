{"ver":"0.1","info":{"id":"X3XczH","date":"1725813058","viewed":105,"name":"Icosahedron Face numbers","username":"kastorp","description":"experiments on numbering the faces of an icosahedron:\n1) Balanced arrangement\n2) 4 regions\n3) connected path","likes":17,"published":1,"flags":0,"usePreview":1,"tags":["icosahedron","dice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Icosahedron Face numbers\" by Kastorp\n\n//------------\n#define SPHERE //comment for flat faces\n\n//--------------------------------\n//BALANCED: a suboptimal face arrangemet for a dice\n// rules:\n// 1) opposite face sum must be 21\n// 2) connected faces must not be consecutive numbers\n// 3) sum of 3 neighbours of a face must be as close as possibile to 31.5 \n// 4) sum of 5 neighbours of a vertex must be as close as possibile to 52.5 \n// \n// with some assumptions, I tried about 720 permutations\n// and found this combination, where \n// rule 3 range is from 28 to 35\n// rule 4 range is from 51 to 54\n//\n//  \t4-----------15------------ 8\n//  \t| \\\t\t\t|\t\t\t / |\n//  \t|  11---5---18---12--- 1   |\n//  \t|\t|\t|\t      |    |   |\n//  ---\t7\t|\t2--------14\t   |   19---\n//      |   |\t|\t      |\t   |   |\n//  \t|  20---13---6---17---10   |\n//  \t| /\t\t\t |\t\t\t \\ |\n//  \t9----------- 3------------16\n//---------------------------------------------\n// PATCHES: subdivision into 5 uniform and connected regions \n//\n//  \tD---------- D---------- C\n//  \t| \\\t\t\t|\t\t  / |\n//  \t|   D---A---A---C---C   |\n//  \t|\t|\t|\t    |   |   |\n//  ---\tD\t|\tA-------A\t|   D---\n//      |   |\t|\t    |   |   |\n//  \t|   B---A---B---C---C   |\n//  \t| /\t\t\t|\t\t  \\ |\n//  \tB-----------B-----------B\n//\n//----------------------------------------------\n// HAMILTON CYCLE: a path through all the faces\n//\n//\t11+++++++++ 10++++++++++++++9\n//\t| +\t\t    |\t\t\t /\t+\n//\t|\t12++13++14+++15+++16\t+\n//\t|\t|\t|\t\t  |\t   +\t+\n//++7\t|\t3+++++++++2\t   +\t8++\n//\t+\t|\t+\t\t  +\t   +\t|\n//\t+\t5+++4---20+++ 1--- 17\t|\n//\t+ +\t\t\t|\t\t\t +\t|\n//\t6---------\t19+++++++++++++18\n//\n//-----------------\n\n//FabriceNeyret\nfloat letter(sampler2D chn,vec2 p,int ch){\n    ch+=48;\n    if(max(abs(p.x),abs(p.y))>.5)  return length(p)-.3;\n    vec2 cp = vec2(ivec2(ch%16, 15-ch/16));\n    vec4 d= textureLod(chn, (p+ cp + 0.5)/16., 0.) ;\n    vec2 grad=vec2(-1,1) *(d.yz-vec2(.5))*2.;\n    float dst=(d.w-.501) ;\n    return dst;\n}\nfloat sInt(sampler2D chn,vec2 p, float n) {\n    float d=1e5;\n    if (n < 0.)  p += vec2(-.5,0), n = -n;\n    for (float i = (n>9.?1.:0.); i>=0.; i--)  n /=  9.999999, d=min(d,\n   letter(chn, p - .5*vec2(i,0), int(fract(n)*10.) )\n    );\n    return d;\n}\n\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\n//Iq\nfloat opExtrude( in float  z, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\n\n\n\nvec3 q;\n\nfloat faces(float id){\n    int F[20];\n    \n    if(mod(iTime,15.)<5.) \n            F=  int[20] (6,11,6,16,11,11,1,1,16,16,1,1,6,6,16,1,11,11,6,16);\n    else  if(mod(iTime,15.)<10.) \n            F= int[20](18,9,6,11,1,15,4,13,8,7,2,3,19,20,10,14,17,16,5,12);\n    else \n            F=int[20](16,8,9,4,17,12,13,5,19,7,14,2,3,6,15,18,10,1,20,11);\n    return float(F[int(id)-1]);\n}               \n// ICOSAHEDRON map function. xy=uv, z=face distance, w=face id, \nvec4 ico(in vec3 pos){\n  \n  // setup constants\n  const float pi = 3.14159;\n  const float k = (sqrt(5.0) - 1.0) / 2.0; //golden ratio  - 1\n  const float side=1.+k*k; //triangle side length\n  const vec3 e3 = vec3(.0, 0.0, 1.0);\n  const vec3 V1 = vec3(0.0,  1.0, k); //one of the 3 vertexes inside octahedron quadrant\n  const vec3 G = vec3(1.+k) / 3.0;   //central face barycenter\n  const vec3 P12 = normalize(cross(V1.zxy - e3, V1 - e3)); //the normal of one of the lateral faces\n  const vec3 P123 = normalize(G); //the normal of the central face\n \n   vec2 uv=vec2(0);\n   float id=0.,fl=1.;  \n   \n   float t = 1e10;   \n   vec3 va=V1,vb= V1.zxy,vc= V1.yzx;\n\n   // OCTAHEDRON symmetry\n   vec3 p = abs(pos);\n   \n   //barycenter coordinates on central triangle\n    q=(vec3(dot(p,cross(va,vb)),dot(p,cross(vb,vc)),dot(p,cross(vc,va))))/side;   \n   if(all(greaterThanEqual(q,vec3(0.)))) {\n       //inside central triangle    \n       id=dot(vec3(1,2,4),sign(pos))*.5+4.5;   //face id 1-8\n       t= dot(p - G, P123); //face distance\n       if(pos.x*pos.z*pos.y<0.) fl=-1.; //flip x axis\n   }\n   else {\n       //inside one of the 3 semi-faces\n       //use AXIS symmetry\n       id=9.;\n       if(q.y<0.){p=p.yzx;pos=pos.yzx;id+=4.;} //120° rotation \n       else if(q.z<0.){p=p.zxy;pos=pos.zxy;id+=8.;} //inverse 120° rotation \n\n       t= dot(p - vec3(0,0,1), P12); //face distance\n       vc = vb*vec3(-1, 0, 1); //3-rd vertex is specular\n       if(pos.x<.0){ vb*=vec3(-1, 0, 1);;vc*=vec3(-1, 0, 1);} //flip 2-nd and 3-rd vertexes \n       id+=dot(vec3(0,1,2),sign(pos))*.5+1.5; //face id 9-12 (or 13-16 or 17-20)\n       fl=-sign(pos.y*pos.z);  //flip x axis \n       \n       //recalc face barycenter coordinates\n       q=(vec3(dot(p,cross(va,vb)),dot(p,cross(vb,vc)),dot(p,cross(vc,va))))/side;\n       \n   }  \n   q/=(q.x+q.y+q.z);\n\n   //uv coordinates, where center is in(0,0)\n   uv=(vec2(q.y+q.z*.5,q.z*sqrt(3.)/2.)-vec2(.5,.5/sqrt(3.)))*vec2(fl,1);  \n \n   return vec4(uv*side,t,faces(id));\n}\n\n\nfloat map(in vec3 p){\n\n    vec4 t= ico(p);\n   \n#ifdef SPHERE \n    t.z=length(p)-1.;\n#else\n    t.xy/=(1.-t.z);\n#endif    \n\nt.z =max(max(max (t.z,-length(vec2(t.z,q.x))+.03),-length(vec2(t.z,q.z))+.03),-length(vec2(t.z,q.y))+.03);\n   float mode=floor(mod(iTime,15.)/5.); \n   if(t.z<.2 && mode !=0.){\n   t.z= min(max(\n       max(t.z,-opExtrude(t.z, length(t.xy)-.27,.02)), \n      t.z),\n      \n    // t.z= min(t.z,sBox(vec3(t.z-.2,t.xy*rot(iTime*5.)),vec3(.05,.25,.25)));\n    opExtrude(t.z+.02, sInt(iChannel3,t.xy*2. +vec2(t.w>9.? .25:.0,.0),t.w)/2.,.02));\n    }\n    return t.z;\n}\n\nvec3 calcNormal(vec3 p){\n  const vec2 eps = vec2(0.0001, 0.0);\n  vec3 n;\n  n.x = map(p + eps.xyy) - map(p - eps.xyy);\n  n.y = map(p + eps.yxy) - map(p - eps.yxy);\n  n.z = map(p + eps.yyx) - map(p - eps.yyx);\n  return normalize(n);\n}\n\n\nfloat march(vec3 ray, vec3 camera){\n  const float maxd = 20.0; \n  const float precis = 0.001;  \n  float t = 0.0; \n  float result = -1.0,h=maxd;\n  for(int i = 0; i < 100; i++){\n    if(h < precis || t > maxd){ break; }\n    h = map(camera + t * ray);\n    t += h;\n  }\n  if(t < maxd){ result = t; }\n  return result;\n}\n\nvec3 transform(in vec3 p, vec2 uv){\n\n p.xz *= rot(uv.y);\n  p.yz *=rot(uv.x);  \n  \n  return p;\n}\n\n// main.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n  vec3 color;\n\n  vec2 m = iMouse.z>0.?(.5-iMouse.xy/ iResolution.xy).yx*vec2(3.14): iTime*vec2(.6,.8);\n  vec3 ray = transform(normalize(vec3(p, -1.8)),m);\n  vec3 camera =transform( vec3(0.0, 0.0, 2.7),m);\n  vec3 light = transform(normalize(vec3(1., 1., 1.0)),m);\n      \n  //background\n  float mode= floor(mod(iTime,15.)/5.);\n  color = mix(cos(vec3(11,0,33) +mode*2.)*.2+.4,\n              cos(vec3(11,0,33) +mode*2.+1.)*.2+.8,\n              .5 + p.y * 0.5);\n  float t = march(ray, camera);\n  \n  if(t > -0.001){\n    vec3 pos = camera + t * ray;\n    vec3 n = calcNormal(pos);\n    \n    vec4 co = ico(pos);  co.xy/= (1.-co.z);  \n    vec3  baseColor= cos(vec3(11,0,33) +co.w/20.*6.28)*.5+.5;\n    baseColor=mix(baseColor,vec3(0),smoothstep(0.01, 0.0,min(min(q.x,q.y),q.z)));\n    if(mode!=0.) baseColor=mix(baseColor,vec3(1),smoothstep(0.0,-0.001,sInt(iChannel3,co.xy*2. +vec2(co.w>9.? .25:.0,.0),co.w)/2.));\n\n    // lighting.\n    float diff = dot(n, light);\n    t = march(light, pos+n*.01);\n    if(t>0. && t<1e5) diff*=.3;\n    diff=max(diff,0.)+.3;\n    baseColor *= diff;\n      \n    // fadeout effect.\n    color = mix(baseColor, color, tanh(t * 0.02));\n  }\n  \n#if 1\n  //DEBUG FACES\n  vec2 uv = (p-vec2(iResolution.x/iResolution.y-.4,.6)) /.4;\n  if(length(uv)<1.) {     \n      vec3 pos =vec3(uv/length(uv),1./tan(length(uv)*3.14));\n      vec4 ic = ico(normalize(transform(pos,m)));\n      color= cos(vec3(11,0,33) +ic.w/20.*6.28)*.5+.5;\n      if(mode!=0.) color=mix(color,vec3(0),smoothstep(0.0,-0.001,sInt(iChannel3,ic.xy*2. +vec2(ic.w>9.? .25:.0,.0),ic.w)/2.));\n      \n      color=mix(color,vec3(0),smoothstep(0.01, 0.0,min(min(q.x,q.y),q.z)));   \n    }\n#endif\n\n  fragColor = vec4(color, 1.0);\n  \n}","name":"Image","description":"","type":"image"}]}