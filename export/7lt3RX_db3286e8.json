{"ver":"0.1","info":{"id":"7lt3RX","date":"1636505530","viewed":88,"name":"rot2D refactorings","username":"akohdr","description":"macro refactoring of rotation and quarternion gists\nWARNING: likely includes errors YMMV \nShould take time to delve into SPIR-V output of various compilers","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Andrew Wild - akohdr/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define rot2D(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n#define PI2 1.5705\n// incorrect but can suffice in certain cases\n//#define rotErr(a) mat2(sin(a*vec3(1,2.5705,-1).yxzy))\n\n#define rot(a) mat2(sin(vec3(a,a+PI2,-a).yxzy))\n//#define rot(a) mat2(sin(vec3(a+PI2,-a,a).xzyx))\n//#define rot(a) mat2(sin(vec3(a,-a,a+PI2).zxyz))\n\n// use _s,_c support vars declared in scope\n#define _rotV float _s,_c\n#define _rot(a) mat2(_c = cos(a),_s = sin(a),-_s,_c)\n\n// as functions\nmat2 _rot1(float a) {\n  float s = sin(a), c = cos(a);\n  return mat2(c,s,-s,c);\n}\n\nmat2 _rot2(float a) {\n  vec2 s = sin(vec2(a,-a));\n  float c = cos(a);\n  return mat2(c,s,c);\n}\n\n\n// Quarternions\nvec4 conjQ(vec4 a) \n{\n    return vec4(-a.x,-a.y,-a.z,a.w);\n}\n\n// library def from C source\nvec4 mulQ_c(vec4 q1,vec4 q2) \n{\n    vec4 v = vec4(0);\n    v.x =  q1.x * q2.w + q1.y * q2.z - q1.z * q2.y + q1.w * q2.x;\n    v.y = -q1.x * q2.z + q1.y * q2.w + q1.z * q2.x + q1.w * q2.y;\n    v.z =  q1.x * q2.y - q1.y * q2.x + q1.z * q2.w + q1.w * q2.z;\n    v.w = -q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w;\n    return v;\n}\n\nvec4 mulQ2(vec4 a,vec4 b) \n{\n    return vec4( a.x * b.w + a.y * b.z - a.z * b.y + a.w * b.x,\n                -a.x * b.z + a.y * b.w + a.z * b.x + a.w * b.y,\n                 a.x * b.y - a.y * b.x + a.z * b.w + a.w * b.z,\n                -a.x * b.x - a.y * b.y - a.z * b.z + a.w * b.w);\n}\n\nvec4 mulQ3(vec4 a,vec4 b) \n{\n    return vec4(dot(a.xyzw, b.wzyx * vec4( 1, 1,-1, 1)),\n                dot(a.xyzw, b.zwxy * vec4(-1, 1, 1, 1)),\n                dot(a.xyzw, b.yxwz * vec4( 1,-1, 1, 1)),\n                dot(a.xyzw, b.xyzw * vec4(-1,-1,-1, 1)));\n}\n\n#define CONJQ(a) vec4(-(a).x,-(a).y,-(a).z,(a).w)\n#define NX(a) vec4(-(a).x,(a).yzw)\n//#define NY(a) vec4((a).x,-(a).y,(a).zw)\n#define NY(a) NX((a).yxzw).yxzw\n//#define NZ(a) vec4((a).xy,-(a).z,(a).w)\n#define NZ(a) NX((a).zyxw).zyxw\n\n// with bit of swizzling (would imagine amortized in load opcode)\nvec4 mulQ4(vec4 a,vec4 b)\n{\n    return vec4(dot(a, NZ(b.wzyx)), dot(a, NX(b.zwxy)),\n                dot(a, NY(b.yxwz)), dot(a, CONJQ(b)));\n}\n\n// with mat4 operation on negated swizzled components\nvec4 mulQ5(vec4 a,vec4 b) \n{\n    return a*mat4(NZ(b.wzyx), NX(b.zwxy), NY(b.yxwz), CONJQ(b));\n}\n\n// GLSL vec4 dot(u,v)   = u.x * v.x + u.y * v.y + u.z * v.z + u.w * v.w\n//           cross(u,v) = {u.y * v.z - v.y * u.z, u.z * v.x - v.z * u.x, u.x * v.y - v.x * u.y}\n//                      = u.yzx * v.zxy - v.yzx * u.zxy\n//                      = (u * v.yzx - v * u.yzx).yzx\n#define CROSS(a,b) ((a * b.yzx - b * a.yzx).yzx)\n\n// quarternion multiplication with cross() and dot() believe this is prefered approach\nvec4 mulQ(vec4 a, vec4 b)\n{\n    vec3 u = a.xyz, v = b.xyz;\n\treturn vec4(v * a.w + u * b.w + cross(u,v), a.w * b.w - dot(u,v));\n}\n\n#define RED vec4(1,0,0,0)\n#define GRN vec4(0,1,0,0)\n#define BLU vec4(0,0,1,0)\n\n#define SC(a) vec2(sin(a),cos(a))\n#define CS(a) vec2(cos(a),sin(a))\n\n#define CONJQ(a) vec4(-(a).x,-(a).y,-(a).z,(a).w)\n#define NX(a) vec4(-(a).x,(a).yzw)\n//#define NY(a) vec4((a).x,-(a).y,(a).zw)\n#define NY(a) NX((a).yxzw).yxzw\n//#define NZ(a) vec4((a).xy,-(a).z,(a).w)\n#define NZ(a) NX((a).zyxw).zyxw\n\n#define MULQ(a,b) ((a)*mat4(NZ((b).wzyx), NX((b).zwxy), NY((b).yxwz), CONJQ(b)))\n#define QROT2D(v,a) (MULQ(vec4(v,0,0),vec4(SC(a).xxxy)).xy)\n\n// obtuse but offers slightly better fps(?!)\n#define _QROTV vec2 _sc\n//per mla\n//#define QROTV2D(v,a) (MULQ(vec4(v,(_sc=sin(vec2(a,a+PI2)))-_sc),_sc.xxxy).xy)\n#define QROTV2D(v,a) (_sc=sin(vec2(a,a+PI2)),MULQ(vec4(v,0,0),_sc.xxxy).xy)\n\n\nvoid mainImage( out vec4 k, in vec2 p )\n{\n    float t = iTime;\n    vec2 ir = iResolution.xy, \n          c = p-ir.xy/2.; c /= ir.y;\n          \n    vec2 v = c;                  // use v for dynamic coords\n    v *= 9.+t;                   // zoom out \n\n    float rt = length(c)*t;      // increasing rotation radially produces spiral\n\n// mat2 based rotation\n//    v *= rot2D(rt);\n//    v *= rot(rt);\n\n// quarternion based rotations.\n//    v = mulQ(vec4(CS(rt).yxxx),vec4(0,0,v)).xy;\n//    v = mulQ(vec4(SC(rt).xyxx),vec4(0,0,v)).xy;\n//    v = mulQ(vec4(v,0,0),vec4(CS(rt).xxyx)).xy;\n//    v = mulQ(vec4(v,0,0),vec4(SC(rt).xxxy)).xy;\n//    v = MULQ(vec4(v,0,0),vec4(SC(rt).xxxy)).xy;\n//    v = QROT2D(v,rt);\n    _QROTV; v = QROTV2D(v,rt);\n    \n//   v *= rot(-rt); //opposite rotation i.e should result in original coords\n    \n    vec2 d = v*v;\n    float e = d.x-d.y-1.;        // unit hyperbola  x^2 - y^2 = 1\n    \n    k  = RED *  vec4(e < t-3.);  // including t animates the black boundary stripe\n    k += GRN * float(e > t+3.);\n\n    k += mulQ(v.xyyy,k);         // makes things a little more colourful\n}\n\n","name":"Image","description":"","type":"image"}]}