{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// ray marching\r\nconst int max_iterations = 128;\r\nconst float stop_threshold = 0.01;\r\nconst float grad_step = 0.05;\r\nconst float clip_far = 1000.0;\r\n\r\n// math\r\nconst float PI = 3.14159265359;\r\nconst float DEG_TO_RAD = PI / 180.0;\r\n\r\nmat3 roty( float angle ) {\r\n\tfloat c = cos( angle );\r\n\tfloat s = sin( angle );\r\n\t\r\n\treturn mat3(\r\n\t\tc  , 0.0, -s  ,\r\n\t\t0.0, 1.0, 0.0,\r\n\t\ts  , 0.0, c  \r\n\t);\r\n}\r\n\r\nmat3 rotzx( vec2 angle ) {\r\n\tvec2 c = cos( angle );\r\n\tvec2 s = sin( angle );\r\n\t\r\n\treturn\r\n\tmat3(\r\n\t\tc.y, s.y, 0.0,\r\n\t\t-s.y, c.y, 0.0,\r\n\t\t0.0, 0.0, 1.0\r\n\t) *\r\n\tmat3(\r\n\t\t1.0, 0.0, 0.0,\r\n\t\t0.0, c.x, s.x ,\r\n\t\t0.0, -s.x, c.x\r\n\t);\r\n}\r\n\r\n// distance function\r\nfloat dist_sphere( vec3 pos, float r ) {\r\n\treturn length( pos ) - r;\r\n}\r\n\r\nfloat dist_box( vec3 pos, vec3 size ) {\r\n\treturn length( max( abs( pos ) - size, 0.0 ) );\r\n}\r\n\r\nfloat dist_cone( vec3 p, float r, float h )\r\n{\r\n\tvec2 c = normalize( vec2( h, r ) );\r\n    float q = length(p.xy);\r\n    return max( dot(c,vec2(q,p.z)), -(p.z + h) );\r\n}\r\n\r\nfloat dist_capsule( vec3 p, vec3 a, vec3 b, float r )\r\n{\r\n    vec3 pa = p - a, ba = b - a;\r\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n    return length( pa - ba*h ) - r;\r\n}\r\n\r\nvec2 princess( vec3 p ) {\r\n\tp = vec3( p.x,abs(p.y),p.z );\r\n\t\r\n\t// hat\r\n\tfloat d0 = dist_cone( roty( radians( 70.0  ) ) * ( p - vec3( -3.4, 0.0, 2.04 ) ), 0.97, 3.3 );\r\n\t// skirt\r\n\tfloat d1 = dist_cone( roty( radians( -10.0 ) ) * ( p - vec3( 0.03, 0.0, -0.1 ) ), 1.6, 2.6 );\r\n\t// head\r\n\tfloat d2 = dist_sphere( p + vec3( 0.0, 0.0, -0.8 ), 1.0 );\r\n\t// neck\r\n\tfloat d3 = dist_capsule( p, vec3( 0.0, 0.0, -0.5 ), vec3( 0.0, 0.0, 1.0 ), 0.18 );\r\n\t// legs\r\n\tfloat d4 = dist_capsule( p + vec3( 0.0, -0.4, 0.0 ), vec3( 0.0, 0.0, -4.6 ), vec3( 0.0, 0.0, -2.0 ), 0.15 );\r\n\t// feet\r\n\tfloat d5 = dist_cone( roty( -90.0 * DEG_TO_RAD ) * ( p + vec3( -0.53, -0.4, 4.58 ) ), 0.16, 0.5 );\r\n\r\n\tfloat g0 = min( min( d0, d1 ), min( d4, d5 ) );\r\n\r\n\tfloat d = g0;\r\n\tfloat id = 1.0;\r\n\t\r\n\tif ( d > d3 ) { d = d3; id = 0.0; }\r\n\tif ( d > d2 ) { d = d2; id = step( 0.2, p.x ); }\r\n\t\r\n\treturn vec2( d, id );\r\n}\r\n\r\n// distance\r\nvec2 dist_field( vec3 p ) {\r\n\treturn princess( p + vec3( 0.0, 0.0, -0.85 ) );\r\n}\r\n\r\n// gradient\r\nvec3 gradient( vec3 pos ) {\r\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\r\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\r\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\r\n\treturn normalize (\r\n\t\tvec3(\r\n\t\t\tdist_field( pos + dx ).x - dist_field( pos - dx ).x,\r\n\t\t\tdist_field( pos + dy ).x - dist_field( pos - dy ).x,\r\n\t\t\tdist_field( pos + dz ).x - dist_field( pos - dz ).x\t\t\t\r\n\t\t)\r\n\t);\r\n}\r\n\r\n// ray marching\r\nvec2 ray_marching( vec3 origin, vec3 dir, float start, float end ) {\r\n\tfloat depth = start;\r\n\tfor ( int i = 0; i < max_iterations; i++ ) {\r\n\t\tvec2 hit = dist_field( origin + dir * depth );\r\n\t\tif ( hit.x < stop_threshold ) {\r\n\t\t\treturn hit;\r\n\t\t}\r\n\t\tdepth += hit.x;\r\n\t\tif ( depth >= end) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn vec2( end, -1.0 );\r\n}\r\n\r\n// othogonal ray direction\r\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\r\n\tvec2 xy = pos - size * 0.5;\r\n\r\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\r\n\tfloat z = size.y * 0.5 * cot_half_fov;\r\n\t\r\n\treturn normalize( vec3( xy, -z ) );\r\n}\r\n\r\nvec3 EvalPixel( vec2 pix ) {\r\n\t// default ray dir\r\n\tvec3 dir = ray_dir( 45.0, iResolution.xy, pix );\r\n\t\r\n\t// default ray origin\r\n\tvec3 eye = vec3( 0.0, 0.0, 13.0 );\r\n\r\n\t// rotate camera\r\n\tmat3 rot = rotzx( vec2( 70.0 * DEG_TO_RAD, 0.7 * iTime ) );\r\n\tdir = rot * dir;\r\n\teye = rot * eye;\r\n\t\r\n\t// ray marching\r\n\tvec2 hit = ray_marching( eye, dir, 0.0, clip_far );\r\n\tif ( hit.x >= clip_far ) {\r\n\t\treturn mix( vec3( 0.0, 0.3, 0.4 ), vec3( 0.17, 0.7, 0.7 ), pix.y / iResolution.y );\r\n\t}\r\n\t\r\n\t// shading\r\n\treturn vec3( hit.y );\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\tvec3 color = vec3( 0.0 );\r\n\r\n#if 1\r\n\tcolor += EvalPixel( fragCoord.xy                    );\r\n\tcolor += EvalPixel( fragCoord.xy + vec2( 0.5, 0.0 ) );\r\n\tcolor += EvalPixel( fragCoord.xy + vec2( 0.0, 0.5 ) );\r\n\tcolor += EvalPixel( fragCoord.xy + vec2( 0.5, 0.5 ) );\r\n\t\r\n\tcolor *= 0.25;\r\n#else\r\n\tcolor = EvalPixel( fragCoord.xy );\r\n#endif\t\r\n\t\r\n\tfragColor = vec4( color, 1.0 );\r\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XsfXWH","date":"1399803400","viewed":3950,"name":"Monument Valley V0.1","username":"gltracy","description":"IDA","likes":30,"published":1,"flags":0,"usePreview":0,"tags":["monumentvalley"],"hasliked":0,"parentid":"","parentname":""}}