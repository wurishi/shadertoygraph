{"ver":"0.1","info":{"id":"ltyyD3","date":"1538672466","viewed":71,"name":"ambient-277","username":"teraspora","description":"test","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// More Experiments with panes\n// Author: John Lynch (teraspora);\n// Date: 26 SEP 2018.\n\nconst float HALF = 0.5;\nconst float PI = 3.141592654;\nconst float TWO_PI = 6.283185307;\n\nconst vec3 white =      vec3(1.,   1.,   1.  );\nconst vec3 black =      vec3(0.,   0.,   0.  );\nconst vec3 cyan =       vec3(0.0,  1.,   0.84);\nconst vec3 magenta =    vec3(1.0,  0.,   1.0 );\nconst vec3 blue =       vec3(0.0,  0.6,  0.84);\nconst vec3 gold =       vec3(1.0,  0.98, 0.84);\nconst vec3 orange =     vec3(1.0,  0.2,  0.0 );\nconst vec3 yellow =     vec3(1.0,  1.0,  0.0 );\nconst vec3 dark_blue =  vec3(0.0,  0.05, 0.15);\nconst vec3 crimson =    vec3(0.76, 0.0,  0.42);\n    \nvec3[] cols = vec3[](magenta, cyan, crimson, blue, orange, yellow);\nint cl = cols.length();\n\n// bitmaps of the 10 decimal digits, given in octal for ease of visualisation\nconst uint[] digits = uint[](07642424276u, 01010101010u, 07602764076u, 07602760276u,\n                             04040447604u, 07640760276u, 04040764276u, 07602020202u,\n                             07642764276u, 07642760202u);\nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 polar(float r, float phi) {\n    return vec2(r * cos(phi), r * sin(phi));\n}\n\nvec2 times(vec2 v, vec2 w) {\n    return vec2(v.x * w.x - v.y * w.y, v.x * w.y + v.y * w.x);\n}\n\nvec2 rotate(vec2 v, float phi) {\n    return times(v, polar(1.0, phi)) ;\n}\n\nfloat om(float x) {\n\treturn 1. - x;\n}\n\nint largestPrimeLessThan(int n) {\n    if (n < 3) return 2;\n\tbool prime[2048];\n    for (int i = 0; i < prime.length(); i++) {\n    \tprime[i] = true;\n    }    \n    for (int p = 2; p * p <= n; p++) { \n        if (prime[p]) { \n            for (int i = p * 2; i <= n; i += p) \n                prime[i] = false; \n        } \n    } \n\tfor (int i = n - 1; i >= 0; i--) {\n    \tif (prime[i]) return i;\n    }    \n}\n\n\n// MAIN METHOD:\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \n    int num = int(iTime);\n    // Set this var to the number of tiles acroos and down:\n    float tileDim = 1.;\n    float numTiles = tileDim * tileDim;\n    \n    // some shorter names:\n    float fx = fragCoord.x;\n    float fy = fragCoord.y;\n    float resx = iResolution.x;\n    float resy = iResolution.y;\n    vec2 f = fragCoord.xy;\n    vec2 hr = iResolution.xy / tileDim;\n    \n    // MUTABLE VARIABLES\n    float scaleFactor = 1.0;\n    \n    // ===============================================================\n    // the output vector giving the position the program needs to know!-\n    vec2 pp = f;\n    // Make numTiles sub-frames:\n    vec2 n = vec2(float(int(f.x / resx * tileDim)), float(int(f.y / resy * tileDim)));\n    \n    float tile = tileDim == 1. ? -1. : numTiles -(n.y * tileDim + n.x) - 1.;\t// start at 1 so we don't lose stuff when multiplying\n    float toe = fract(tile / 2.) * 4. - 1.; // returns 1. if tile index odd, -1. if even;\n    float tile2 = tile * tile;\n    \n    // shift back to the first tile if in any other tile:\n    pp.x -= hr.x * n.x;\n    pp.y -= hr.y * n.y;\n    // normalise to [0, 1[, shift to make unit quad with origin in centre\n    vec2 q = pp / hr - 0.5;     // normalise\n    // then scale:\n    q /= scaleFactor;\n    \n    // control factors for changing colours\n        \n\n        // Initial colour set:\n    vec3 col = mix(yellow, cyan, length(q));\n\t\n    switch(int(tile)) {\n        case -1:\n        float time = 277. - iTime;\n        col.b *= (sin(time / 6.) + 1.);\n        col.g *= (cos(time / 11.) + 1.);\n        \n        //col *= \t  om(step(0.05, length(q)))\n        vec2 qq = q;\n        qq *= abs(cos(time * 0.5) + time);\n        float s = 0.005 + 0.02 * cos(length(qq) * 9.);\n        col *= step(s, mod(length(qq), 0.004))   \t\n             \t\n            ;\n        \n        \tbreak;\n        case 1: \n        \tq = mod(q, 0.25) * 1.5;\n        \tq.x -= 0.2; \n        \n        \tcol = mix(white, crimson, sqrt(sin(abs(q.y) + abs(q.x))));\n        \tcol.b *= (sin(iTime) + 1.);\n        \tfloat sign = 1.;\n        \tif(mod(iTime, 64.) < 32.) sign = -1.;\n        \tq = rotate(q, sign * iTime );\n        \tcol *= smoothstep(0.01, 0.06, abs(q.x));\n        \tcol *= smoothstep(0.01, 0.06, abs(q.y));\n        \tcol *= smoothstep(0.4, 0.45, 1. - smoothstep(0.4, 0.45, length(q)));\n        \tcol *= (1. + 0.1 * sin( 10. * atan(q.y, q.x)));\t\n    \t\n        \tq.x += 0.4; \n        \n        \tcol = mix(white, crimson, sqrt(sin(abs(q.y) + abs(q.x))));\n        \tcol.b *= (sin(iTime) + 1.);\n        \t\n        \tif(mod(iTime, 64.) < 32.) sign = -1.;\n        \tq = rotate(q, sign * iTime );\n        \tcol *= smoothstep(0.01, 0.06, abs(q.x));\n        \tcol *= smoothstep(0.01, 0.06, abs(q.y));\n        \tcol *= smoothstep(0.4, 0.45, 1. - smoothstep(0.4, 0.45, length(q)));\n        \tcol *= (1. + 0.1 * sin( 10. * atan(q.y, q.x)));\t\n                \t\n            break;\n        case 4: \n        \tq += vec2(0.1 * sin(iTime / 4.), -0.15 * cos(iTime / 4.));\n        \tq = rotate(q, iTime / 4.);\n        \tq *= 1.8 * sqrt(abs(sin(iTime / 32.)));\n        \tint t = int(iTime);\n        \t\n        \n        \n        \tq.y *= 88.0 *abs(cos(q.x * 8.)) * abs(sin(iTime / 32.));\n    \t\t\n        \n        \tcol = mix(cyan, crimson, sin(q.y));\n        \tcol.g *= ((-cos(iTime / 5.) + 1.) * 0.5);\n    \t\tnum = largestPrimeLessThan(t);\n        \n        \tfloat rows = 5.;\n    \t\tfloat columns = 54.;\n    \t\t// width and height of a digit in rows of bit-blocks\n    \t\tfloat dw = 6.;\n    \t\tfloat dh = 5.;\n\n    \t\t// populate the bitmap array with bitmaps for the appropriate digits:\n    \t\tuint[] bitmap = uint[10](0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u);\n    \t\tfor (int i = 0, divisor = 100000000; i < 9; i++, divisor /= 10) {\t\n        \t    int m = num / divisor;\n        \t\tbitmap[i] = digits[m];\n        \t    num -= m * divisor;\n        \t}\n        \tvec2 box = vec2(0.9, 0.2);\n    \t\tvec2 padding = (-box + 1.) / 2.;\n    \t\t\n        \tif (q.x >= -0.5 + padding.x && q.x < 0.5 - padding.x\n        \t\t  && q.y >= -0.5 + padding.y && q.y < 0.5 - padding.y) {        \n        \t\tvec2 p = (q * vec2(1., -1.) + vec2(0.5, 0.5) - padding) / box;\n        \t    float bx = float(p.x * columns);\n        \t    float by = float(p.y * rows);\n        \t    float place = bx / dw;\n        \t    float dx = bx - floor(place) * dw;\n        \t    float dy = floor(by);\n        \t    uint digit = bitmap[int(place)]; \n        \t    int bitx = int(dy * dw + dx);\n        \t    int charSize = int(dw * dh);\n        \t    bitx = charSize - bitx ;\n        \t    col *= (1. - float((digit >> bitx) & 1u));        \n            }       \n            break;\n        case 8: \n            col = mix(blue, magenta, sqrt(sin(abs(q.y))));\n        \tq.x -= 0.1;\n        \tq.y += 0.1;\n        \tq = mod(q, 0.2) * .16;\t\n            q = rotate(q, iTime);\n\t\t\tfloat r = (sin( 6. * atan(q.x, q.y)) + 1.) * 0.1;\n        \t\n        \tcol *=  smoothstep(r, r + 0.01, length(q));\n        \t//q.x += 0.1;\n        \t//col *= 0.;\n        \t\n        break;\n        \t\n        default: \t\t // some rotation and translation for a bit of variation!\n        \tif (fract((numTiles + 37.) / tile) == 0.0) q = rotate(q, 0.5 * PI);\n        \tq *= 1.0 + sin(iTime / 20.) * tile / numTiles * toe;    \n        \tq = rotate(q, iTime / 10.);\n\t\t\t\n        \n        \tcol.b = 0.*sin(iTime  / 6.);\n\n        \tfloat freq = 10. + float(int(sqrt(tile))) + 10. * sin(iTime / 100.);\n        \tfloat rmin = 0.15;\n        \tfloat rinc = 0.06;\n        \tfloat k = 0.25 + 0.1 * sin(iTime) * sin(tile);\n\n        \t// shift the tree:\n        \tq.x += 0.2 * sin(iTime / 2.) * toe;\n        \tq.x -= 0.2 * sin(iTime / 10.) * toe;\n\n        \tfloat phi = sin(iTime / 2. + tile) * 0.2;\n        \tq = rotate(q, phi);    \n        \t// r has all the info to make fronds and splay them:\n        \tr = rmin + k * cos(atan(q.y, q.x) * freq + 40. * q.x  + 1.4 * toe);\n        \tq = rotate(q, -phi);    \n        \tq = rotate(q, phi * toe * 2.);    \n\n        \t// make trunk wavy:\n        \tfloat trunkAngle = 0.2 * toe * cos(iTime / 10.);\n        \tfloat trunkWaviness = tile;\n        \tfloat barkRoughness = 0.002;\n        \tfloat barkIndentation = 60.;\n        \tfloat baseSize = -.19;    \n\n        \t// make arms:\n        \tcol *= smoothstep(r, r + rinc, length(q));\n        \t// and a trunk:\n        \tr = 0.04 * tile / numTiles;\n        \tr += barkRoughness * cos(barkIndentation * q.y);\n        \tr += exp(baseSize * pp.y);\n\t\n        \tcol *= 1. - (1. - smoothstep(r, r+ 0.001, abs(q.x - trunkAngle * sin(trunkWaviness * q.y)))) \n                  * (1. - smoothstep(0.0, 0.01, q.y));    \n        \t\n            break;\n    }    \n    \n \n    \n    // ===============================================================================\n\n    // Make a border: 8px solid black; with line inset:\n    float b = 6.;   // border width    \n    vec3 borderInsetLineColour = white;\n    \n    // Make a line inset:\n    if ((pp.x > b - 1. && pp.x <= b + 1.) || (pp.x > hr.x - b - 1. && pp.x < hr.x - b + 1.)) col = borderInsetLineColour;\n    if ((pp.y > b - 1. && pp.y <= b + 1.) || (pp.y > hr.y - b - 1. && pp.y < hr.y - b + 1.)) col = borderInsetLineColour;\n    \n    // Now put a black border on top:\n    col *= step(b, pp.x);\n    col *= step(b, pp.y);\n    col *= (1. - step(hr.x - b, pp.x));\n    col *= (1. - step(hr.y - b, pp.y));\n    \n    // Black out a 'random' tile...\n    // if (int(mod(tile * 79., numTiles)) == int(mod(iTime * 2., numTiles))) col = black;\n    \n    \n    // and finally return the colour:\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}