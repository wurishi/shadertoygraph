{"ver":"0.1","info":{"id":"Mt3SDr","date":"1716969381","viewed":67,"name":"Simple Fluid Sym","username":"decrooks","description":"fluid","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["fluid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 color = texture(iChannel0, uv);\n    \n    \n    \n\tfragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 random3(vec3 v) {\n\tv  =   v.xyz*vec3(18.9898,78.233,63.341) \n         + v.zxy*vec3(26.91133,36.311343,23.311417) \n         + v.yzx*vec3(19.6785,14.91741,20.141237);\n    vec3 result = -1.0 + 2.0*fract(sin(v)*76123.512378);\n    return result.zxy;\n}\n\n\nvec3 quinticSmoothstep(vec3 u){\n    return u*u*u*(u*(u*6.0-15.0)+10.0);\n}\n\nvec3 smoothstepDerivitive(vec3 u){\n    return 30.0*u*u*(u*(u-2.0)+1.0);\n}\n\nvec4 gradientNoiseD(vec3 v){\n    \n    //https://iquilezles.org/articles/morenoise\n    vec3 i = floor(v);\n    vec3 f = fract(v);\n    //vec3 s = smoothstep(0.0,1.0,f);\n   \tvec3 s = quinticSmoothstep(f);\n    vec3 ds = smoothstepDerivitive(f);\n    \n    float a000 = dot(random3(i),f);\n    float a100 = dot(random3(i + vec3(1.0,0.0,0.0)), f - vec3(1.0,0.0,0.0));\n    float a010 = dot(random3(i + vec3(0.0,1.0,0.0)), f - vec3(0.0,1.0,0.0));\n    float a001 = dot(random3(i + vec3(0.0,0.0,1.0)), f - vec3(0.0,0.0,1.0));\n    float a110 = dot(random3(i + vec3(1.0,1.0,0.0)), f - vec3(1.0,1.0,0.0));\n    float a101 = dot(random3(i + vec3(1.0,0.0,1.0)), f - vec3(1.0,0.0,1.0));\n    float a011 = dot(random3(i + vec3(0.0,1.0,1.0)), f - vec3(0.0,1.0,1.0));\n    float a111 = dot(random3(i + vec3(1.0,1.0,1.0)), f - vec3(1.0,1.0,1.0));\n   \n \n    vec3 k1;\n    k1.x = a100 - a000;//1\n    k1.y = a010 - a000;//2\n    k1.z = a001 - a000;//3\n    \n    vec3 k2;\n    k2.x = a000 - a100 -a010 + a110;//4\n    k2.y = a000 - a001 -a010 + a011;//5\n    k2.z = a000 - a001 -a100 + a101;//6\n    \n    float k3 = -a000 + a100 +a010 + a001 - a110 - a101 - a011 + a111;\n    \n    vec4 result;\n    result.x = a000 + dot(k1,s) + k2.x*s.x*s.y + k2.y*s.y*s.z + k2.z*s.z*s.x + k3*s.x*s.y*s.z;\n    \n    //derivitives\n    result.y = ds.x * (k1.x + k2.x*s.y + k2.z*s.z + k3*s.y*s.z);\n    result.z = ds.y * (k1.y + k2.y*s.z + k2.x*s.x + k3*s.z*s.x);\n    result.w = ds.z * (k1.z + k2.z*s.x + k2.y*s.y + k3*s.x*s.y);\n    \n    return result;\n      \n}\n\n\n//time varying fractal noise + derivites dx/dx and dn/dy;\nvec3 noise2td(vec2 v){\n  \n    vec4 value = vec4( 0.0);\n    float a = 0.5;\n   float flowRate = 0.3;\n    \n    \n   \tfor(int i=0;i<10;i++){   \nvec3 v3 = vec3(v + flowRate*iTime,flowRate*iTime);\n        value +=  a*gradientNoiseD(v3);\n        v *= 1.713;\n        a *= 0.6;\n    }\n    \n    return value.xyz;\n}\n    \n\n/*    \n    The function curlOfNoise() generates a random vector flow field from noise.\n \n    The intuive notion that a vector field is flowing smoothly\n    corresponds to the mathematical condition that it is divergence free:\n \n        Div F = 0\n \n    We can satisfy this condtion by writing F = Curl H because Div Curl H = 0 for any H.  We also want our field to flow in 2d, so we require Fz = 0.\n    Fz depends on the derivites of the x and y components, so setting these to any constant solves this conditon.\n    Setting H = (0,0,E(x,y)) gives:\n \n        F = (dE/dy, -dE/dx,0)\n \n    for any scalar function of x and y.\n    So setting  E(x,y) = noise(x,y) gives a random divergence free flow field, as required.\n \n*/\n\n\nvec2 curlOfNoise(vec2 v) {\n   \n    vec3 n = noise2td(4.0*v);\n    \n    vec2 dn = n.yz;\n    \n    return vec2(dn.y,-dn.x);\n}\n\n\n#define PI  3.14\n\n//Add somme ink to the fluid or there will be nothing to see.\nvoid addInk(inout vec4 color,vec2 v) {\n    float t = iTime;\n    vec2 p = 0.35*vec2(sin(t),cos(t));\n    float d = distance(p,v);\n    if(d<0.01) color = vec4(1.0);\n       \n   \tp = 0.35*(1.0 +0.1*sin( 0.1*t))*vec2(sin(0.55*t),cos(0.55*t));\n    d = distance(p,v);\n    if(d<0.01) color = vec4(1.0);\n   \n    p = 0.65*(1.0 +0.2*sin( 0.1*t))*vec2(sin(0.4*t),cos(0.4*t));\n    d = distance(p,v);\n    if(d<0.01) color = vec4(0.0,0.0,1.0,1.0);\n \n    p = 0.35*(1.0 +0.5*sin( 0.15*t))*vec2(sin(0.75*t),cos(0.75*t));\n    d = distance(p,v);\n    if(d<0.01) color = vec4(1.0,1.0,0.3,1.0);\n    \n    p = 0.75*(1.0 +0.3*sin( 0.1*t))*vec2(sin(0.45*t),cos(0.45*t));\n    d = distance(p,v);\n    if(d<0.05) color = vec4(1.0,1.0,1.0,1.0);\n    \n    if(abs(v.x) >0.87 )  color = vec4(1.0,1.0,1.0,1.0);\n   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 v = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    float advectionRate = 0.5;\n   \tvec2 advection = advectionRate*curlOfNoise(v);\n    \n    vec2 samplePoint = (fragCoord.xy + advection)/ iResolution.xy;\n    vec4 fluid = texture(iChannel0, samplePoint);\n    \n    \n   // vec2 uv = fragCoord.xy / iResolution.xy;\n    addInk(fluid,v);\n    \n\tfragColor = fluid;\n}","name":"Buffer A","description":"","type":"buffer"}]}