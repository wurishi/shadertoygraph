{"ver":"0.1","info":{"id":"XsVBWt","date":"1531058023","viewed":138,"name":"Morphing primitives","username":"rkibria","description":"Just playing with raymarching some more.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThanks to\n\nhttp://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nhttps://iquilezles.org/articles/distfunctions\nhttp://shadertoy.wikia.com/wiki/Noise\n\n*/\n\n#define MAX_MARCHING_STEPS 50\n#define EPSILON 0.02\n#define MAX_DIST 1000.0\n\nmat4 rotXMatrix(in float phi) {\n    float cos_phi = cos(phi);\n    float sin_phi = sin(phi);\n    return mat4(\n\t    1.0,          0.0,            0.0,            0.0,\n\t    0.0,          cos_phi,        sin_phi,        0.0,\n\t    0.0,          -sin_phi,       cos_phi,        0.0,\n\t    0.0,          0.0,            0.0,            1.0\n    \t);\n}\n\nmat4 rotYMatrix(in float phi) {\n    float cos_phi = cos(phi);\n    float sin_phi = sin(phi);\n    return mat4(\n\t    cos_phi,      0.0,            -sin_phi,       0.0,\n\t    0.0,          1.0,            0.0,            0.0,\n\t    sin_phi,      0.0,            cos_phi,        0.0,\n\t    0.0,          0.0,            0.0,            1.0\n    \t);\n}\n\nmat4 rotZMatrix(in float phi)\n{\n    float cos_phi = cos(phi);\n    float sin_phi = sin(phi);\n    return mat4(\n\t    cos_phi,      sin_phi,        0.0,            0.0,\n\t    -sin_phi,     cos_phi,        0.0,            0.0,\n\t    0.0,          0.0,            1.0,            0.0,\n\t    0.0,          0.0,            0.0,            1.0\n    \t);\n}\n\nfloat rand(float n){\n    return fract(cos(n*89.42)*343.42);\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nconst int n_shapes = 6;\nfloat shapeSelect( in vec3 p, in float r, in int i )\n{\n    switch(i)\n    {\n    case 0:\n        return sdEllipsoid( p, vec3(r, r/2., r) );\n    case 1:\n        return udBox( p, vec3(r) );\n    case 2:\n        return sdTorus( p, vec2(r, r/3.) );\n    case 3:\n        return sdCappedCylinder( p, vec2(r, r*2. ) );\n    case 4:\n        return sdTriPrism( p, vec2(r, r*2. ) );\n    case 5:\n        return sdHexPrism( p, vec2(r, r*2. ) );\n    }\n}\n\nfloat sdf( in vec3 p )\n{\n    const float r = 1.;\n    const float period = 2.;\n    \n    mat4 mtx = rotZMatrix(iTime) * rotYMatrix(iTime) * rotXMatrix(iTime);\n    vec3 q = (mtx * vec4(p, 0)).xyz;\n\n    int t = int(iTime / period);\n    int i1 = int( rand(float(t)) * float(n_shapes + 1) ) % n_shapes;\n    int i2 = int( rand(float(t+1)) * float(n_shapes + 1) ) % n_shapes;\n\n    float d1 = shapeSelect( q, r, i1 );\n\tfloat d2 = shapeSelect( q, r, i2 );\n    \n    return mix( d1, d2, mod(iTime, period) / period );\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sdf(vec3(p.x + EPSILON, p.y, p.z)) - sdf(vec3(p.x - EPSILON, p.y, p.z)),\n        sdf(vec3(p.x, p.y + EPSILON, p.z)) - sdf(vec3(p.x, p.y - EPSILON, p.z)),\n        sdf(vec3(p.x, p.y, p.z  + EPSILON)) - sdf(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 background(in vec2 uv)\n{\n    return mix( vec3(1., 1., 1.), vec3( 0.2, 0.2, 1. ), uv.y *2. + 0.5 );\n}\n\nvec3 lighting(in vec2 uv, in vec3 eye, in vec3 pos, in vec3 n)\n{\n    vec3 a = vec3( 0.05 + max(0., dot(n, vec3(1., 0.5, -0.5)) ) );\n    return a;\n}\n\nvec3 march(in vec2 uv, in vec3 eye, in vec3 ray)\n{\n    float depth = 0.0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 pos = eye + depth * ray;\n        float dist = sdf( pos );\n        if( dist < EPSILON ) {\n            return lighting( uv, eye, pos, estimateNormal( pos ) );\n        }\n\n        depth += dist;\n\n        if ( depth >= MAX_DIST ) {\n            return background(uv);\n        }\n    }\n    return background(uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ( fragCoord - .5 * iResolution.xy ) / iResolution.x;\n    \n    vec3 eye = vec3(0, 0, -7.5);\n\n    vec3 col = vec3( 0 );\n    const int N = 3;\n    float dd = 1./iResolution.x;\n    vec3 ray0 = normalize( vec3( 1.5 * uv, 1. ) );\n    for(int i = 0; i < N; ++i)\n    {\n        vec3 ray = ray0 + vec3(\n            (rand(iTime + float(i)     ) - 0.5) * 2. * dd,\n            (rand(iTime + float(i) + 1.) - 0.5) * 2. * dd,\n            (rand(iTime + float(i) + 2.) - 0.5) * 2. * dd\n        \t);\n\t    col += march( uv, eye, ray );\n    }\n    col /= float(N);\n    \n    fragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"}]}