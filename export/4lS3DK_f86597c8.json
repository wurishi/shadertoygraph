{"ver":"0.1","info":{"id":"4lS3DK","date":"1432286230","viewed":704,"name":"Hyper Dodecahedron","username":"tholzer","description":"A hyperbolic kaleidoscope dodecahedron original created by nimitz.\nUse mouse to select shape and to rotate it.","likes":28,"published":1,"flags":64,"usePreview":0,"tags":["raymarcher","kaleidoscope","dodecahedron","hyperbolic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Wj","filepath":"https://soundcloud.com/daniel-koerber/zack-hemsey-see-what-ive","previewfilepath":"https://soundcloud.com/daniel-koerber/zack-hemsey-see-what-ive","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//---------------------------------------------------------\n// Shader:   HyperDodecahedron.glsl   by tholzer 2015-05-11\n//           https://www.shadertoy.com/view/4lS3DK \n// original: 'Famous solid' by nimitz (@stormoid)\n//           https://www.shadertoy.com/view/ltlGWM\n// modified: use mouse to select different shape types now\n// tags:     hyperbolic, dodecahedron, kaleidoscope, raymarcher\n//---------------------------------------------------------\n/*\nQuick laydown of what's going on:\n -knighty's folding technique to get dodecahedron distance (see: https://www.shadertoy.com/view/XlX3zB)\n -Linear extrapolation of sphere to \"hyberbolize\" the dodecahedron\n -Fold symmetries are used to displace, shade and color\n -Cheap analytic curvature for shading (see: https://www.shadertoy.com/view/Xts3WM)\n -Wave noise for bump mapping (generalized triangle noise: https://www.shadertoy.com/view/XtX3DH)\n -eiffie's auto-overstep raymarching method: https://www.shadertoy.com/view/ldSSDV\n -Lighting mostly from iq\n*/\n\n#define ROTATE true\n#define ITR 120\n#define FAR 7.0\n#define time iTime\n#define TYPES 5.0\n\nint solidType = 2;   // use 0 to 4 for starting shape.\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nvec3 fold(in vec3 p)\n{\n    const vec3 nc = vec3(-0.5,-0.809017,0.309017);\n    for(int i=0;i<5;i++)\n    {\n\t\tp.xy = abs(p.xy);\n\t\tfloat t = 2.*min(0.,dot(p,nc));\n\t\tp -= t*nc;\n\t}\n    return p;\n}\n\nfloat smax(float a, float b)\n{\n    const float k = 2.;\n    float h = 1.-clamp(.5 + .5*(b-a)/k, 0., 1.);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat tri(in float x){return abs(fract(x)-0.5)*2.;}\n\nfloat map(in vec3 p)\n{\n    vec3 fp = fold(p) - vec3(0.,0.,1.275);\n    float d = mix(dot(fp,vec3(.618,0,1.)), length(p)-1.15,-3.6);\n    \n    if (solidType == 1)\n    {\n\t  d += tri(fp.x*8.+fp.z*3.)*0.05+tri(fp.x*fp.y*40.+time*0.2)*0.07-0.17;\n      d += tri(fp.y*5.)*0.04;\n      d *= 0.9;\n\t}\n    else if (solidType == 2)\n    {\n\t  d *= 0.7;\n      d += sin(time+fp.z*5.+sin(fp.x*20.*fp.y*8.)+1.1)*0.05-0.08;\n      d += sin(fp.x*20.*sin(fp.z*8.+time*0.2))*0.05;\n      d += sin(fp.x*20.*sin(fp.z*8.-time*0.3)*sin(fp.y*10.))*0.05;\n    }\n\telse if (solidType == 3)\n\t{\n      d = smax(d+.5, -(d+sin(fp.y*20.+time+fp.z*10.)+1.5)*0.3)*.55;\n      d += sin(max(fp.x*1.3,max(fp.z*.5,fp.y*1.))*35.+time)*0.03;\n    }\n\telse if (solidType == 4)\n      d = smax(d+.5, -(d+sin(fp.z*10.+sin(fp.x*20.*fp.y*9.)+1.1)*0.3-0.3))*.5;\n\telse\n    {\n      d = smax(d+.2, -(d+cos(fp.z*13.+cos(fp.x*18.*fp.y*2.)+2.1)*0.5-0.5))*.8;\n\t  d += tri(fp.x*3.+fp.z*6.)*0.1+tri(fp.x*fp.y*4.+time*0.2)*0.1-0.17;\n      d *= 0.5;\n    }\n    \n    return d*0.25;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n    float t=0.,stp=0.0,os=0.0,pd=10.0, d =0.;\n\tfor(int i=0;i<ITR;i++)\n    {\n        t+=stp;\n        d=map(ro+rd*t);\n        if (t>FAR || abs(d) <0.0005)break;\n        if(d>=os)\n        {\t\t\n            os=.9*d*d/pd;\n            stp=d+os;\n            pd=d;\n        }\n        else\n        {\n            stp=-os;\n            pd=1.;\n            os=.001;\n        }\n    }\n    return t;\n}\n\nvec3 normal(in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.0001;\n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n//Cheap analytic curvature: https://www.shadertoy.com/view/Xts3WM\nfloat curv(in vec3 p)\n{\n    vec2 e = vec2(-1., 1.)*0.03;\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return .15/(e.x*e.x) *(t1 + t2 + t3 + t4 - 4. * map(p));\n}\n\nfloat wav(in float x){return sin(x*6.283)*0.25+0.25;}\nvec2 wav2(in vec2 p){return vec2(wav(p.x+wav(p.y*1.5)),wav(p.y+wav(p.x*1.5)));}\n\nfloat wavenoise(in vec2 p)\n{\n    float z=2.;\n    float z2=1.;\n\tfloat rz = 0.;\n    vec2 bp = p;\n    rz+= (wav(-time*0.5+p.x*(sin(-time)*0.3+.9)+wav(p.y-time*0.2)))*.7/z;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec2 dg = wav2(bp*2.)*.8;\n        dg *= mm2(time*.2);\n        p += dg/z2;\n\n        bp *= 2.4;\n        z2 *= 1.05;\n\t\tz *= 2.4;\n\t\tp *= 1.4;\n        \n        rz+= (wav(p.x+wav(p.y)))/z;\n\t}\n\treturn rz;\n}\n\nvec3 tex(in vec3 p)\n{   \n    float rz;\n    vec3 col;\n    if (solidType == 1)\n    {\n        rz= p.y*15.+p.x*30.+p.z*5.;\n    \tcol = (sin(vec3(.7,2.,.1-rz*0.2)+rz*.1+0.45))*0.5+0.5;\n\t}\n\telse if (solidType == 2)\n    {\n    \trz= (sin(p.x*0.+p.z*20.)-p.y*20.);\n    \tcol = (sin(vec3(2.1,.7,.1)+rz*.09+4.15))*0.5+0.5;\n\t}\n\telse if (solidType == 3)    \n    {\n        rz= sin(p.z*3.+p.x*6.)*0.5+0.5;\n    \tcol = mix(vec3(.7,0.1,0.),vec3(1,.5,0.4),rz)*0.5+0.05;\n    }\n\telse if (solidType == 4)\n    {\n        rz= p.z*13.+p.x*30.;\n    \tcol = (sin(vec3(2.2,.7,.1)+rz*.1+4.2))*1.3+1.3;\n    }\n\telse \n    {\n        rz= sin(p.z*13.) + p.x*23.;\n    \tcol = (sin(vec3(0.2,.9,.5)+rz*0.4+2.2))*1.1+1.1;\n    }\n    return col;\n}\n\n//Bump mapping\nfloat bumptex(in vec3 p)\n{\n    if      (solidType == 1) return wavenoise(mix(p.zy,p.yx,1.)*0.55);\n    else if (solidType == 2) return wavenoise(mix(p.yz,p.xy,.5)*0.55);\n    else if (solidType == 3) return wavenoise(mix(p.zy,p.xy,.5)*0.44);\n    else if (solidType == 4) return wavenoise(mix(p.zy,p.xy,.1)*0.55);\n    else                     return wavenoise(mix(p.zy,p.xy,.2)*0.50);\n}\n\nvec3 bump(in vec3 p, in vec3 n)\n{\n    vec2 e = vec2(.01,0);\n    float n0 = bumptex(p);\n    vec3 d = vec3(bumptex(p+e.xyy)-n0, bumptex(p+e.yxy)-n0, bumptex(p+e.yyx)-n0)/e.x;\n    n = normalize(n-d*.3);\n    return n;\n}\n\nfloat shadow(in vec3 ro, in vec3 rd, in float mint, in float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<15; i++ )\n    {\n\t\tfloat h = map(ro + rd*t);\n        res = min( res, 4.*h/t );\n        t += clamp( h, 0.01, .1 );\n        if(h<0.001 || t>tmax) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat ao( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= .95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 rotx(vec3 p, float a)\n{\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 roty(vec3 p, float a)\n{\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = q-0.5;\n\tfloat ratio = iResolution.x / iResolution.y;\n    p.x *= ratio;\n    solidType = int( iMouse.x / iResolution.x * TYPES);\n\t\n    // camera\n    vec2 mo = iMouse.xy / iResolution.xy*1.5 -.75;\n\tmo.x *= ratio;\n\tif (ROTATE)\n        mo += vec2(time*0.03, time*0.004);\n\tvec3 ro = vec3(.0,0.0,-7.0);\n    vec3 rd = vec3(p,1.2);\n\tro = rotx(ro, -mo.y*3.0);ro = roty(ro, mo.x*3.0);\n\trd = rotx(rd, -mo.y*3.0);rd = roty(rd ,mo.x*3.0);\n\t\n    float rz = march(ro,rd);\n    vec3 col = vec3(0.9);   \n    if ( rz < FAR )\n    {\n        //setup\n        vec3 pos = ro+rz*rd;\n        float crv= curv(pos);\n        vec3 nor = normal(pos);\n       \tvec3 fpos = fold(pos);\n        vec3 lgt = normalize(vec3(.0, 1., 0.9));\n        float shd = shadow( pos, lgt, 0.02, 3.0 );\n        nor = bump(fpos, nor);\n        \n        //components\n        float dif = max(dot(nor,lgt),0.0)*shd;\n        float bac = max(0.2 + 0.8*dot(nor,vec3(-lgt.x,lgt.y,-lgt.z)),0.0);\n        float fre = clamp(pow(1.0+dot(nor,rd),3.),0.,10.)*shd;\n        vec3 haf = normalize(lgt - rd);\n        float spe = pow(clamp(dot(nor,haf),0.0,1.0),50.0)*shd;\n        float occ= crv*0.25+0.75;\n\t\t\n        //compose\n        col  = 0.2*occ + dif*vec3(1.0,0.8,0.6) \n            + 0.4*bac*vec3(1.0)*occ;\n        col *= 0.5*pow(tex(fpos),vec3(.5));\n        col += .4*fre*vec3(1.0) + .35*spe*vec3(1.0);\n        col *= ao(pos,nor);\n        col = pow(col,vec3(.75))*1.3;\n    }\n    \n    //vignetting from iq\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.12 )*0.8+0.4;\n\t\n\tfragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}