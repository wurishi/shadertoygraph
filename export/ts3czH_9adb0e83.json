{"ver":"0.1","info":{"id":"ts3czH","date":"1604240927","viewed":285,"name":"Particle Party","username":"savegor","description":"Based on Particle Party: fast and fun version","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["particles","parties"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    float dist = 1.0e3;\n    float vel = 1.0e3;\n    \n    for(float i = -2.0; i < 2.01; i += 1.0) {\n        for(float j = -2.0; j < 2.01; j += 1.0) {\n            vec2 crd = fragCoord + vec2(i, j);\n            vec4 cell_state = texture(iChannel0, SCALE * crd / iResolution.xy);\n            vec2 pos = cell_state.xy / SCALE;\n    \t\tfloat cur_dist = distance(fragCoord, pos);\n            \n            if(cur_dist < dist) {\n                dist = cur_dist;\n                vel = length(cell_state.zw);\n            }\n   \n        }\n    }\n    \n    float red = smoothstep(0.25, 0.5, vel); \n    float green = smoothstep(0.0, 0.25, vel) * smoothstep(0.5, 0.25, vel);\n    float blue = smoothstep(0.25, 0.0, vel);\n    \n    vec4 background = texture(iChannel1, fragCoord / iResolution.xy);\n    \n    fragColor = float(dist < (1.0 / SCALE)) * vec4(red, green, blue, 1) + background;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat noise(vec2 st) {\n    return fract(sin(st.x + iTime) * st.y * iTime);\n}\n\nbool correct_cell(vec4 cell_state, vec2 cell) {\n    vec2 diff = abs(cell_state.xy - cell);\n\treturn diff.x < 1.0 && diff.y < 1.0;    \n}\n\nvec2 calc_accel(vec4 next_state, vec2 cell) {\n    vec2 cell_uv = cell / iResolution.xy;\n    vec4 cell_state = texture(iChannel0, cell_uv);\n    \n    float particle_in_cell = float(correct_cell(cell_state, cell));\n    \n    vec2 diff = next_state.xy - cell_state.xy;\n    \n    float sqr_dist = dot(diff, diff);\n    \n    float collision = 0.15 * float(sqr_dist < 7.0);\n    \n    return particle_in_cell * collision * (7.0 - sqr_dist) * normalize(diff); \n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    if(iFrame == 0) {\n\n        if(int(fragCoord.x) % 5 == 0 && int(fragCoord.y) % 4 == 0) {\n            if(noise(fragCoord) > 0.5) {\n                vec2 start_velocity = vec2(noise(fragCoord), noise(fragCoord.yx));\n                if(length(start_velocity) > 1.0) {\n                \tstart_velocity = normalize(start_velocity);    \n                }\n                \n                // 0.5 pixel per frame is the max value of the each particle velocity\n                // so the relative speed is not exceed 1 pixel per frame\n                start_velocity *= 0.5;\n                \n            \tfragColor = vec4(fragCoord.xy, start_velocity);    \n            }\n        }\n        \n    }\n    else {\n        \n        if(iFrame % 2 == 0) {\n            vec4 cur_state = texture(iChannel0, fragCoord / iResolution.xy);\n\t\t\t\n            if(correct_cell(cur_state, fragCoord)) {\n                // COLLISION\n                // calculate the repulsion from particles\n                // in the outer boundary:\n                //\n                // * * * * *\n                // *       *\n                // *   O < O\n                // *   ^   *\n                // * * O * *\n                // \n                vec2 accel = vec2(0.0);\n                \n                for(float i = -2.0; i < 2.01; i += 1.0) {\n                    for(float j = -2.0; j < 2.01; j += 1.0) {\n                        if(abs(i) > 0.1  || abs(j) > 0.1) {\n                        \taccel += calc_accel(cur_state, fragCoord + vec2(i, j));\n                        }\n                    }\n                }\n\t\t\t\t\n\n                cur_state.zw += accel;\n                \n                // GRAVITY\n                \n                cur_state.w += -0.001;\n                \n                // BOUNDARIES\n                \n                // right boundary\n                float rb_diff = cur_state.x - SCALE * iResolution.x;\n                cur_state.z += 0.25 * rb_diff * float(abs(rb_diff) < 2.0); \n                \n                // left boundary\n                float lb_diff = cur_state.x;\n                cur_state.z += 0.25 * lb_diff * float(abs(lb_diff) < 2.0); \n                \n                \n                // top boundary\n                float top_diff = cur_state.y - SCALE * iResolution.y;\n                cur_state.w += 0.25 * top_diff * float(abs(top_diff) < 2.0); \n                \n                // bottom boundary\n                float bot_diff = cur_state.y;\n                cur_state.w += 0.25 * bot_diff * float(abs(bot_diff) < 2.0);\n                \n                // mouse repulsion\n                vec2 mouse = iMouse.xy * SCALE;\n                //if(distance(fragCoord, mouse) < 40.0 / SCALE) {\n                    vec2 dir = mouse - fragCoord;\n                    dir = normalize(dir);\n                    cur_state.zw += 0.01 * dir * sin(iTime * 0.1);\n                //}\n                \n                // velocity normalization\n                float velocity = length(cur_state.zw);\n                if(velocity > 0.5) {\n                \tcur_state.zw = cur_state.zw / velocity * 0.5;   \n                }\n                \n                \n                fragColor = cur_state;\n            }\n        }\n        else {\n            // MOTION\n            // simulation the particle propagation from the \n            // neighbouring cells into current one:\n            //\n            //  ____________________\n            // |      |      |      |\n            // |      |      |      |\n            // |      |      |      |\n            // |______|______|______|\n            // |      |      |      |\n            // |  O---|->    |      |\n            // |      |      |      |\n            // |______|______|______|\n            // |      |      |      | \n            // |      |      |      |\n            // |      |      |      |\n            // |______|______|______|\n            //\n            // IMPORTANT: we assume that only one particle \n            // can be inside any 3x3 square\n            // some particles will disappear otherwise\n        \t\n            vec4 next_state = vec4(0.0, 0.0, 0.0, 0.0);\n\n            for(float shifti = -1.0; shifti < 1.01; shifti += 1.0) {\n                for(float shiftj = -1.0; shiftj < 1.01; shiftj += 1.0) {\n                    vec2 crd = fragCoord + vec2(shifti, shiftj);\n\n                    vec2 uv = crd / iResolution.xy;\n\n                    vec4 ng = texture(iChannel0, uv);\n\n                    vec2 cur_move = ng.xy + ng.zw;\n\n                    vec2 diff = abs(fragCoord - cur_move);\n\n                    if(diff.x <= 0.5 && diff.y <= 0.5) {\n                        next_state.xy = cur_move; // coord\n                        next_state.zw = ng.zw;    // velocity\n                    }\n                };\n            }\n\n            fragColor = next_state;\n        }\n    }\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float SCALE = 0.6;","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel1, fragCoord / iResolution.xy);\n    \n    if(iFrame % 2 == 0) {\n        float dist = 1.0e3;\n\n        float vel = 1.0e3;\n\n        for(float i = -2.0; i < 2.01; i += 1.0) {\n            for(float j = -2.0; j < 2.01; j += 1.0) {\n                vec2 crd = SCALE * fragCoord + vec2(i, j);\n                vec4 cell_state = texture(iChannel0, crd / iResolution.xy);\n\t\t\t\t\n                    vec2 pos = cell_state.xy / SCALE;\n                \t\n                 \tvec2 diff = pos - fragCoord;\n                \n                \tfloat cur_dist = dot(diff, diff);\n                    if(cur_dist < dist) {\n                        dist = cur_dist;\n                        vel = length(cell_state.zw);\n                    }\n            }\n        }\n\n        fragColor *= 0.98;\n\n\n        if(vel < 1.0) {\n            float red = smoothstep(0.25, 0.5, vel); \n            float green = smoothstep(0.0, 0.25, vel) * smoothstep(0.5, 0.25, vel);\n            float blue = smoothstep(0.25, 0.0, vel);\n            fragColor += 0.06 * vec4(red, green, blue, 1.0) * min(1.0, 1.0 / ((1.0 - vel) * dist));\n        }\n        fragColor = max(vec4(0.0), fragColor);\n        fragColor = min(vec4(1.0), fragColor);\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\nfloat noise(vec2 st) {\n    return fract(sin(st.x + iTime) * st.y * iTime);\n}\n\nbool correct_cell(vec4 cell_state, vec2 cell) {\n    vec2 diff = abs(cell_state.xy - cell);\n\treturn diff.x < 1.0 && diff.y < 1.0;    \n}\n\nvec2 calc_accel(vec4 next_state, vec2 cell) {\n    vec2 cell_uv = cell / iResolution.xy;\n    vec4 cell_state = texture(iChannel0, cell_uv);\n    \n    float particle_in_cell = float(correct_cell(cell_state, cell));\n    \n    vec2 diff = next_state.xy - cell_state.xy;\n    \n    float sqr_dist = dot(diff, diff);\n    \n    float collision = 0.15 * float(sqr_dist < 7.0);\n    \n    return particle_in_cell * collision * (7.0 - sqr_dist) * normalize(diff); \n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        \n        if(iFrame % 2 == 1) {\n            vec4 cur_state = texture(iChannel0, fragCoord / iResolution.xy);\n\t\t\t\n            if(correct_cell(cur_state, fragCoord)) {\n                // COLLISION\n                // calculate the repulsion from particles\n                // in the outer boundary:\n                //\n                // * * * * *\n                // *       *\n                // *   O < O\n                // *   ^   *\n                // * * O * *\n                // \n                vec2 accel = vec2(0.0);\n                \n                for(float i = -2.0; i < 2.01; i += 1.0) {\n                    for(float j = -2.0; j < 2.01; j += 1.0) {\n                        if(abs(i) > 0.1  || abs(j) > 0.1) {\n                        \taccel += calc_accel(cur_state, fragCoord + vec2(i, j));\n                        }\n                    }\n                }\n\t\t\t\t\n\n                cur_state.zw += accel;\n                \n                // GRAVITY\n                \n                cur_state.w += -0.001;\n                \n                // BOUNDARIES\n                \n                // right boundary\n                float rb_diff = cur_state.x - SCALE * iResolution.x;\n                cur_state.z += 0.25 * rb_diff * float(abs(rb_diff) < 2.0); \n                \n                // left boundary\n                float lb_diff = cur_state.x;\n                cur_state.z += 0.25 * lb_diff * float(abs(lb_diff) < 2.0); \n                \n                \n                // top boundary\n                float top_diff = cur_state.y - SCALE * iResolution.y;\n                cur_state.w += 0.25 * top_diff * float(abs(top_diff) < 2.0); \n                \n                // bottom boundary\n                float bot_diff = cur_state.y;\n                cur_state.w += 0.25 * bot_diff * float(abs(bot_diff) < 2.0);\n                \n                // mouse repulsion\n                vec2 mouse = iMouse.xy * SCALE;\n                if(distance(fragCoord, mouse) < 40.0 / SCALE) {\n                    vec2 dir = mouse - fragCoord;\n                    dir = normalize(dir);\n                    cur_state.zw += 0.01 * dir * sin(iTime * 0.1);\n                }\n                \n                // velocity normalization\n                float velocity = length(cur_state.zw);\n                if(velocity > 0.5) {\n                \tcur_state.zw = cur_state.zw / velocity * 0.5;   \n                }\n                \n                \n                fragColor = cur_state;\n            }\n        }\n        else {\n            // MOTION\n            // simulation the particle propagation from the \n            // neighbouring cells into current one:\n            //\n            //  ____________________\n            // |      |      |      |\n            // |      |      |      |\n            // |      |      |      |\n            // |______|______|______|\n            // |      |      |      |\n            // |  O---|->    |      |\n            // |      |      |      |\n            // |______|______|______|\n            // |      |      |      | \n            // |      |      |      |\n            // |      |      |      |\n            // |______|______|______|\n            //\n            // IMPORTANT: we assume that only one particle \n            // can be inside any 3x3 square\n            // some particles will disappear otherwise\n        \t\n            vec4 next_state = vec4(0.0, 0.0, 0.0, 0.0);\n\n            for(float shifti = -1.0; shifti < 1.01; shifti += 1.0) {\n                for(float shiftj = -1.0; shiftj < 1.01; shiftj += 1.0) {\n                    vec2 crd = fragCoord + vec2(shifti, shiftj);\n\n                    vec2 uv = crd / iResolution.xy;\n\n                    vec4 ng = texture(iChannel0, uv);\n\n                    vec2 cur_move = ng.xy + ng.zw;\n\n                    vec2 diff = abs(fragCoord - cur_move);\n\n                    if(diff.x <= 0.5 && diff.y <= 0.5) {\n                        next_state.xy = cur_move; // coord\n                        next_state.zw = ng.zw;    // velocity\n                    }\n                };\n            }\n\n            fragColor = next_state;\n        }\n\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\nfloat noise(vec2 st) {\n    return fract(sin(st.x + iTime) * st.y * iTime);\n}\n\nbool correct_cell(vec4 cell_state, vec2 cell) {\n    vec2 diff = abs(cell_state.xy - cell);\n\treturn diff.x < 1.0 && diff.y < 1.0;    \n}\n\nvec2 calc_accel(vec4 next_state, vec2 cell) {\n    vec2 cell_uv = cell / iResolution.xy;\n    vec4 cell_state = texture(iChannel0, cell_uv);\n    \n    float particle_in_cell = float(correct_cell(cell_state, cell));\n    \n    vec2 diff = next_state.xy - cell_state.xy;\n    \n    float sqr_dist = dot(diff, diff);\n    \n    float collision = 0.15 * float(sqr_dist < 7.0);\n    \n    return particle_in_cell * collision * (7.0 - sqr_dist) * normalize(diff); \n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        \n        if(iFrame % 2 == 0) {\n            vec4 cur_state = texture(iChannel0, fragCoord / iResolution.xy);\n\t\t\t\n            if(correct_cell(cur_state, fragCoord)) {\n                // COLLISION\n                // calculate the repulsion from particles\n                // in the outer boundary:\n                //\n                // * * * * *\n                // *       *\n                // *   O < O\n                // *   ^   *\n                // * * O * *\n                // \n                vec2 accel = vec2(0.0);\n                \n                for(float i = -2.0; i < 2.01; i += 1.0) {\n                    for(float j = -2.0; j < 2.01; j += 1.0) {\n                        if(abs(i) > 0.1  || abs(j) > 0.1) {\n                        \taccel += calc_accel(cur_state, fragCoord + vec2(i, j));\n                        }\n                    }\n                }\n\t\t\t\t\n\n                cur_state.zw += accel;\n                \n                // GRAVITY\n                \n                cur_state.w += -0.001;\n                \n                // BOUNDARIES\n                \n                // right boundary\n                float rb_diff = cur_state.x - SCALE * iResolution.x;\n                cur_state.z += 0.25 * rb_diff * float(abs(rb_diff) < 2.0); \n                \n                // left boundary\n                float lb_diff = cur_state.x;\n                cur_state.z += 0.25 * lb_diff * float(abs(lb_diff) < 2.0); \n                \n                \n                // top boundary\n                float top_diff = cur_state.y - SCALE * iResolution.y;\n                cur_state.w += 0.25 * top_diff * float(abs(top_diff) < 2.0); \n                \n                // bottom boundary\n                float bot_diff = cur_state.y;\n                cur_state.w += 0.25 * bot_diff * float(abs(bot_diff) < 2.0);\n                \n                // mouse repulsion\n                vec2 mouse = iMouse.xy * SCALE;\n                if(distance(fragCoord, mouse) < 40.0 / SCALE) {\n                    vec2 dir = mouse - fragCoord;\n                    dir = normalize(dir);\n                    cur_state.zw += 0.01 * dir * sin(iTime * 0.1);\n                }\n                \n                // velocity normalization\n                float velocity = length(cur_state.zw);\n                if(velocity > 0.5) {\n                \tcur_state.zw = cur_state.zw / velocity * 0.5;   \n                }\n                \n                \n                fragColor = cur_state;\n            }\n        }\n        else {\n            // MOTION\n            // simulation the particle propagation from the \n            // neighbouring cells into current one:\n            //\n            //  ____________________\n            // |      |      |      |\n            // |      |      |      |\n            // |      |      |      |\n            // |______|______|______|\n            // |      |      |      |\n            // |  O---|->    |      |\n            // |      |      |      |\n            // |______|______|______|\n            // |      |      |      | \n            // |      |      |      |\n            // |      |      |      |\n            // |______|______|______|\n            //\n            // IMPORTANT: we assume that only one particle \n            // can be inside any 3x3 square\n            // some particles will disappear otherwise\n        \t\n            vec4 next_state = vec4(0.0, 0.0, 0.0, 0.0);\n\n            for(float shifti = -1.0; shifti < 1.01; shifti += 1.0) {\n                for(float shiftj = -1.0; shiftj < 1.01; shiftj += 1.0) {\n                    vec2 crd = fragCoord + vec2(shifti, shiftj);\n\n                    vec2 uv = crd / iResolution.xy;\n\n                    vec4 ng = texture(iChannel0, uv);\n\n                    vec2 cur_move = ng.xy + ng.zw;\n\n                    vec2 diff = abs(fragCoord - cur_move);\n\n                    if(diff.x <= 0.5 && diff.y <= 0.5) {\n                        next_state.xy = cur_move; // coord\n                        next_state.zw = ng.zw;    // velocity\n                    }\n                };\n            }\n\n            fragColor = next_state;\n        }\n\n}","name":"Buffer D","description":"","type":"buffer"}]}