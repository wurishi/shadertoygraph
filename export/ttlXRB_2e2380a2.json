{"ver":"0.1","info":{"id":"ttlXRB","date":"1563445920","viewed":408,"name":"Texture waves","username":"Eseris","description":"Simulate waves on the texture.\nClick on the screen to generate waves.","likes":1,"published":3,"flags":32,"usePreview":0,"tags":["2d","wave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The buffer A is used to compute a height map. An acceleration is applied on texels using\n// the height difference from the neighbours\n// The Image uses this generated texture to compute an offset on the texture coordinates\n\nconst vec2 kern[] = vec2[](\n    vec2(1,0), vec2(-1,0), vec2(0,1), vec2(0,-1)\n);\nconst int kernSize = 4;\n\n\nvec3 getState(vec2 p) {\n    return texelFetch(iChannel0, ivec2(p), 0).xyz;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float pos = getState(fragCoord).x;\n    \n    // compute an offset from the gradient of the height map\n    vec2 offset = vec2(0);\n    for(int i = 0; i < kernSize; ++i)\n        offset += (getState(fragCoord + kern[i]).x - pos) * kern[i];\n    \n    vec2 uv = fragCoord / iResolution.yy;\n    vec3 col = texture(iChannel1, uv + 3. * offset).xyz;\n    \n    fragColor = vec4(pow(col, vec3(1./2.2)),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define DIAG_NEIGHBOURS\n\nconst float accelCoef = 30.;\nconst float velMax = 10.;\nconst float posDamping = .98;\n\nconst vec2 kern[] = vec2[](\n    vec2(0,0),\n    vec2(1,0), vec2(-1,0), vec2(0,1), vec2(0,-1),\n    vec2(1,1), vec2(-1,1), vec2(1,-1), vec2(-1,-1)\n);\n\n#ifdef DIAG_NEIGHBOURS\nconst int kernSize = 9;\nconst float weights[] = float[](-6.828,  1., 1., 1., 1., .707, .707, .707, .707);\n#else\nconst int kernSize = 5;\nconst float weights[] = float[](-4.,  1., 1., 1., 1.);\n#endif\n\nvec3 getState(vec2 p) {\n    //return texelFetch(iChannel0, ivec2(p), 0).xyz;\n    return texture(iChannel0, p / iResolution.xy).xyz;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 state = getState(fragCoord);\n    float pos = state.x, vel = state.y;\n    float ac = accelCoef * accelCoef * iTimeDelta;\n    \n    // acceleration induced by the neighbours\n    for(int i = 0; i < kernSize; ++i) {\n        float nPos = getState(fragCoord + 2.5 * kern[i]).x;\n        vel += ac * weights[i] * nPos;\n        //vel += accelCoef * accelCoef * iTimeDelta * (nPos - pos);\n    }\n    \n    vel = clamp(vel, -velMax, velMax);\n    //vel *= .97;\n    \n    // apply velocity to the position\n    pos = clamp(pos + iTimeDelta * vel, -1., 1.);\n    pos *= posDamping; // damping\n    \n    if(iMouse.z > 0.) {\n        vec2 uv = (fragCoord - iMouse.xy) / iResolution.yy;\n        pos = mix(pos, sin(10. * iTime), smoothstep(.0, .1, .06 - length(uv)));\n    }\n    \n    fragColor = vec4(pos, vel, 0, 0);\n}","name":"Buffer A","description":"","type":"buffer"}]}