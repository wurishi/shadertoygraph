{"ver":"0.1","info":{"id":"lsXcWs","date":"1490299026","viewed":642,"name":"Bibliotheque","username":"dr2","description":"Another library, with lots more books (use the mouse)","likes":7,"published":3,"flags":0,"usePreview":0,"tags":["raymarching","library","books"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Bibliotheque\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrRCylDf (vec3 p, float r, float rt, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\n\nconst float pi = 3.14159;\n\nvec3 ltDir;\nvec2 bsa1, bsa2;\nfloat dstFar, tCur, szRg, rdRm, htRm, rdCl, htCl, wdDr, spShf, htShf, rdLt, htLt;\nint idObj;\nconst int idRm = 1, idCol = 2, idChr = 3, idBks = 4, idShlf = 5, idNm = 6, idLt = 7;\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  vec2 w;\n  float dMin, d, a, r;\n  dMin = dstFar;\n  q = p;\n  q.xz = mod (q.xz + szRg, 2. * szRg) - szRg;\n  r = length (q.xz);\n  a = (r > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.;\n  d = max (r - rdRm, - q.y - htRm);\n  qq = q;  qq.y -= - htCl;\n  d = max (d, length (qq) - rdCl);\n  qq = q;  qq.y -= -0.2;\n  qq = abs (qq);\n  w = vec2 (min (qq.x, qq.z), qq.y) - vec2 (wdDr, htRm - 0.2);\n  d = - min (d, min (max (w.x, w.y), 0.));\n  if (d < dMin) { dMin = d;  idObj = idRm; }\n  qq.xz += step (qq.x, qq.z) * (qq.zx - qq.xz) - vec2 (rdRm, wdDr);\n  d = PrCylDf (qq.xzy, 0.3, htRm - 0.2);\n  if (d < dMin) { dMin = d;  idObj = idCol; }\n  qq = q;  qq.y -= 0.7 - htRm;\n  d = PrRCylDf (qq.xzy, 2.5, 0.1, 0.7);\n  if (d < dMin) { dMin = d;  idObj = idChr; }\n  qq = q;  qq.y -= 1.65 - htRm;\n  d = PrCylDf (qq.xzy, 1., 0.25);\n  if (d < dMin) { dMin = d;  idObj = idNm; }\n  q.xz = Rot2D (q.xz, 2. * pi * ((floor (4. * a) + 0.5) / 4.));\n  q.z = abs (q.z);\n  d = max (abs (r - rdRm + 0.6) - 0.6, dot (q.xz, bsa2));\n  d = max (d, abs (q.y) - htRm);\n  if (d < dMin) { dMin = d;  idObj = idBks; }\n  d = max (abs (r - rdRm + 0.9) - 0.9, dot (q.xz, bsa1));\n  d = max (d, min (abs (mod (q.y + 0.5 * spShf, spShf) -\n     0.5 * spShf) - htShf, - dot (q.xz, bsa2)));\n  d = max (d, abs (q.y) - htRm);\n  if (d < dMin) { dMin = d;  idObj = idShlf; }\n  qq = q;  qq.y -= rdCl - htCl - 0.4;\n  d = PrCylDf (qq.xzy, 2., 0.15);\n  qq = q;  qq.y -= htLt;\n  d = min (d, max (PrTorusDf (qq.xzy, 0.15, rdLt), dot (q.xz, bsa1)));\n  if (d < dMin) { dMin = d;  idObj = idLt; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 WoodCol (vec3 p, vec3 n)\n{\n  float f;\n  p *= 4.;\n  f = dot (vec3 (Fbm2 (p.zy * vec2 (1., 0.1)),\n     Fbm2 (p.zx * vec2 (1., 0.1)), Fbm2 (p.xy * vec2 (1., 0.1))), abs (n));\n  return 0.7 * mix (vec3 (0.8, 0.5, 0.3), vec3 (0.55, 0.35, 0.1), f);\n}\n\nvec3 FloorCol (vec2 p)\n{\n  return mix (vec3 (0.8, 0.4, 0.2), vec3 (0.5, 0.25, 0.1),\n     Fbm2 (20. * vec2 (1., 0.1) * p.xy)) *\n     (0.5 + 0.5 * SmoothBump (0.03, 0.97, 0.01, mod (3. * p.x, 1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col, q;\n  vec2 gbRm, gbBk;\n  float dstObj, a, s, bh, r, cRm;\n  int idObjT;\n  bool isLit;\n  rdRm = 18.;\n  rdCl = 1.3 * rdRm; \n  htCl = sqrt (rdCl * rdCl - rdRm * rdRm) - htRm - 1.;\n  rdLt = 0.9 * rdRm;\n  htLt = sqrt (rdCl * rdCl - rdLt * rdLt) - htCl;\n  wdDr = 2.5;\n  htShf = 0.07;\n  spShf = 0.167 * (2. * htRm - htShf);\n  bsa1 = vec2 (sin (1. * 2. * pi / 16.), cos (1. * 2. * pi / 16.));\n  bsa2 = vec2 (sin (0.97 * 1. * 2. * pi / 16.), cos (0.97 * 1. * 2. * pi / 16.));\n  isLit = true;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    if (idObj == idNm) {\n      if (ro.y + rd.y * dstObj > 1.9 - htRm - 0.01) {\n        ro += rd * dstObj;\n        rd = reflect (rd, vec3 (0., 1., 0.));\n        ro += 0.01 * rd;\n        dstObj = ObjRay (ro, rd);\n      }\n    }\n  }\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    q = ro;\n    gbRm = floor (q.xz / (2. * szRg) + 0.5);\n    cRm = mod (31. * Fbm2 (gbRm * vec2 (17., 11.)), 1.);\n    q.xz = mod (q.xz + szRg, 2. * szRg) - szRg;\n    r = length (q.xz);\n    a = (r > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.;\n    if (idObj == idRm) {\n      a *= 4.;\n      if (ro.y < - (htRm - 0.001)) {\n        if (r > 2. * wdDr) col = FloorCol ((min (abs (q.x), abs (q.z)) < wdDr) ?\n           ((abs (q.x) < abs (q.z)) ? ro.xz : ro.zx) :\n           vec2 (r, 20. * (mod (a, 1.) - 0.5)));\n        else col = HsvToRgb (vec3 (cRm, 1., 0.7)) *\n           (1. - 0.1 * smoothstep (0.4, 0.6, Fbm2 (3. * ro.xz)));\n        s = mix (1. - 0.3 * smoothstep (0.3, 0.6, r / rdRm),\n           0.8 + 0.2 * smoothstep (0.1, 0.3, abs (0.5 - mod (a - 0.5, 1.))),\n           smoothstep (0.7, 0.85, r / rdRm));\n        col *= s;\n        isLit = false;\n      } else if (r > rdRm + 0.001) {\n        col = vec3 (0., 0., 0.3 + 0.5 * (htRm + ro.y) / (2. * htRm - 0.4));\n        isLit = false;\n      } else if (ro.y < htRm - 0.4) {\n        col = vec3 (0.6, 0.6, 0.7);\n        if (r < rdRm)\n           vn.xz = Rot2D (vn.xz, 0.5 * (mod (100. * mod (a, 1.), 1.) - 0.5));\n      } else if (ro.y < htRm + 1.001) {\n        col = vec3 (0.6, 0.6, 0.7);\n      } else {\n        s = mix (1. - 0.3 * smoothstep (0.4, 0.7, r / rdRm),\n           0.7 + 0.3 * smoothstep (0.2, 0.3, abs (0.5 - mod (a - 0.5, 1.))),\n           smoothstep (0.75, 0.95, r / rdRm));\n        col = vec3 (0., 0., 0.3) + vec3 (0.4, 0.4, 0.3) * s;\n        s = 0.;\n        rd = (normalize (q) + vec3 (1., 0.7, 0.3) +\n           0.1 * normalize (vec3 (gbRm.x, 0.1, gbRm.y)));\n        for (int j = 0; j < 19; j ++) rd = abs (rd) / dot (rd, rd) - 0.9;\n        s += min (1., 0.5e-3 * pow (min (6., length (rd)), 5.));  \n        col += s * vec3 (0.4, 0.4, 0.15);\n        isLit = false;\n      }\n      if (isLit) vn = VaryNf (100. * ro, vn, 2.);\n    } else if (idObj == idCol) {\n      a = abs (1. - 2. * mod (atan (vn.z, vn.x) / (2. * pi), 1.));\n      col = HsvToRgb (vec3 (cRm, 1., 0.9)) *\n         (0.8 + 0.2 * smoothstep (0.3, 0.7,\n         Fbm2 (gbRm + vec2 (5. * a, 10. * ro.y + 0.3 * sin (8. * pi * a)))));\n    } else if (idObj == idChr) {\n      col = vec3 (0.3, 0.2, 0.);\n      if (r > 0.2) col *=\n         0.4 + 0.6 * SmoothBump (-0.4, 0.4, 0.05, mod (4. * a + 0.5, 1.) - 0.5);\n    } else if (idObj == idBks) {\n      a = 120. * mod (mod (4. * a + 1./8., 4.), 4.);\n      gbBk = floor (vec2 (q.y / spShf, a));\n      bh = (0.7 + 0.3 * Fbm2 ((gbRm + gbBk) * vec2 (19., 31.))) * spShf;\n      q.y = mod (q.y, spShf);\n      if (q.y < bh) { \n        s = mod (a, 1.);\n        col = vec3 (HsvToRgb (vec3 (mod (cRm +\n           0.4 * (Fbm2 (gbBk * vec2 (17., 11.)) - 0.5), 1.), 1.,\n           0.9 * SmoothBump (0.08, 0.92, 0.01, 0.1 + 0.9 * s) *\n           (1. - 0.3 * step (abs (abs (q.y / bh - 0.5) - 0.35), 0.02)))));\n        vn.xz = Rot2D (vn.xz, 2. * (s - 0.5));\n        vn = VaryNf (20. * ro, vn, 1.);\n      } else col = vec3 (0.1);\n    } else if (idObj == idShlf) {\n      q = vec3 (5. * (mod (4. * a, 1.) - 0.5), ro.y, r);\n      col = WoodCol (q, vn);\n    } else if (idObj == idLt) {\n      col = vec3 (1., 1., 0.6) * 0.5 * (1. - vn.y);\n      isLit = false;\n    } else if (idObj == idNm) {\n      col = vec3 (0.8, 0.8, 0.);\n      q.xy = vec2 (-2. * (mod (3. * a + 0.5 * tCur + 0.5, 1.) - 0.5),\n         ro.y - (1.65 - htRm));\n      if (abs (q.x) < 0.6 && abs (q.y) < 0.2) {\n        if (ShowInt (vec2 (q.x - 0.45, q.y + 0.13),\n           vec2 (1., 0.25), 4., dot (mod (vec2 (42., 24.) + gbRm, 100.),\n           vec2 (100., 1.))) != 0.) col = vec3 (0.8, 0., 0.);\n      }\n      isLit = false;\n    }\n    if (isLit) col = col * (0.5 + 0.5 * max (dot (vn, ltDir), 0.) +\n       0.1 * pow (max (0., dot (ltDir, reflect (rd, vn))), 64.));\n    col = mix (col, vec3 (0.1, 0.1, 0.15), smoothstep (0.6, 1., dstObj / dstFar));\n  } else {\n    col = 0.5 * vec3 (0.6, 0.6, 0.7);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvec3 TrackPath (float t)\n{\n  vec3 p;\n  float s, cCount;\n  t *= 10.;\n  p.y = htRm * (0.1 * SmoothBump (0.2, 0.8, 0.1, mod (0.08 * t, 1.)) + 0.1);\n  s = mod (t, 11.);\n  if (s < 7.) p.xz = (s < 4.) ? vec2 (0., s) : vec2 (s - 4., 4.);\n  else p.xz = (s < 9.) ? vec2 (3., 11. - s) : vec2 (12. - s, 2.);\n  cCount = floor (t / 11.);\n  if (mod (cCount, 2.) == 0.) p.x *= -1.;\n  else p.x -= 1.;\n  p.z += 2. * cCount;\n  p.xz *= 2. * szRg;\n  return p;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, fpF, fpB, vd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, spd;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  szRg = 20.;\n  htRm = 4.;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.7 * pi * mPtr.y;\n  }\n  spd = 0.02;\n  fpF = TrackPath (spd * tCur + 0.02);\n  fpB = TrackPath (spd * tCur - 0.02);\n  ro = 0.5 * (fpF + fpB);\n  vd = fpF - fpB;\n  ori = vec2 (el, az - (atan (vd.z, vd.x) - 0.5 * pi));\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 1.7));\n  dstFar = 400.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrRCylDf (vec3 p, float r, float rt, float h)\n{\n  vec2 dc;\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  dc = vec2 (dxy, dz) + rt;\n  return min (min (max (dc.x, dz), max (dc.y, dxy)), length (dc) - rt);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n)) * (1. / 1.9375);\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s, Fbmn (p + e.yxy, n) - s,\n     Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nfloat DigSeg (vec2 q)\n{\n  return step (abs (q.x), 0.12) * step (abs (q.y), 0.6);\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.5, 2.2);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);\n  DSG (q.xy - vp);\n  DSG (q.xy - vm);\n  DSG (q.yx);\n  DSG (q.xy + vm);\n  DSG (q.xy + vp);\n  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log (val) / log (10.), 0.)) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (sgn < 0.) {\n      if (idChar == mxChar - nDig - 1.) s = ShowDig (q, -1);\n      else ++ v;\n    }\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n","name":"Image","description":"","type":"image"}]}