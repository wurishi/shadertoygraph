{"ver":"0.1","info":{"id":"XfSBRD","date":"1724687408","viewed":36,"name":"O(log(n)) iterative box blur","username":"hasse","description":"An iterative box blur, where the blur radius grows exponentially. At 12 passes (36 texture taps per pixel, total), the blur size is 729x729. Kind of pointless since an O(1) box blur exists, but maybe it could be useful in some corner case?","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["postprocessing","blur","boxblur"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// CC0\n// \n// Iterative box blur for doing big blurs quickly, that also parallelizes nicely.\n// There's probably nothing new here, it's kind of just a variation of an A-Trous filter.\n//\n// A better, O(1) algorithm also exists (moving averages):\n//     https://www.intel.com/content/www/us/en/developer/articles/technical/an-investigation-of-fast-real-time-gpu-based-image-blur-algorithms.html\n//     https://fgiesen.wordpress.com/2012/07/30/fast-blurs-1/\n// It's a bit trickier to implement efficiently, but by using modern GPU hardware features\n// (e.g. subgroup/warp per line, implement moving average with subgroup ops), it's probably\n// faster than this approach in practice. But it requires compute shaders, which are not\n// available on shadertoy ;)\n\n#define PASS_COUNT 12\n\n// A-trous is probably a misnomer for this, since this specifically requires powers of 3 and not 2, but it works similarly.\n// The strides work such that each pixel collects groups of previously blurred pixels without overlaps between the groups.\nivec2 separated_atrous_offset(int pass_index, int neighbor_index)\n{\n    int stride = int(pow(3.0f, float(pass_index/2)));\n    int axis = pass_index % 2;\n\n    if(neighbor_index == 0)\n        stride = -stride;\n\n    return axis == 0 ? ivec2(stride, 0) : ivec2(0, stride);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / vec2(iResolution.xy);\n    vec3 c;\n    int f = iFrame % 128;\n    if(f == 0)\n    { // Initialize with the original image\n        c = texture(iChannel1, uv).rgb;\n    }\n    else\n    { // Read previous pass\n        ivec2 p = ivec2(fragCoord.xy);\n        c = texelFetch(iChannel0, p, 0).rgb;\n\n        if(f <= PASS_COUNT)\n        { // Blur with two neighbors\n            ivec2 n1 = p+separated_atrous_offset(f-1, 0);\n            ivec2 n2 = p+separated_atrous_offset(f-1, 1);\n            n1 = clamp(n1, ivec2(0), ivec2(iResolution.xy)-1);\n            n2 = clamp(n2, ivec2(0), ivec2(iResolution.xy)-1);\n            c += texelFetch(iChannel0, n1, 0).rgb;\n            c += texelFetch(iChannel0, n2, 0).rgb;\n            c /= 3.0f;\n        }\n    }\n    fragColor = vec4(c,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}