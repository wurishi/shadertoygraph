{"ver":"0.1","info":{"id":"cdXXD7","date":"1668986785","viewed":81,"name":"Bulbing Mandelbrot (Feigenbaum)","username":"PhDFractal","description":"Zooming into (or out of) the Feigenbaum point, where the Mandelbrot Set Real bulbs limiting or when the bifurcation double-cascades. Absolute vs. Julia Set, only 3-4 bulbs in due to limit of single precision. Rainbow Fractal eXtreme palette or UF5 colors.","likes":3,"published":1,"flags":16,"usePreview":0,"tags":["fractal","mandelbrot","juliaset","feigenbaum"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////////\n//\n// Bulbing Mandelbrot\n//\n// Comparison of Absolute vs. Julia Set of Bulbing Mandelbrot (Feigenbaum point).\n//\n// Created by PhdFractal, 8/11/2022\n//\n// Drag mouse on the screen to change angle of approach. Observe the difference\n// between the expanding/shrinking morphs of the Absolute vs. Julia sets.\n//\n// Press 'b' to zoom out, and 'b' again to zoom in.\n//\n// Challenge: find the expanding points of the regular Julia set corresponding\n// to the end bulbing points of the Absolute Julia. Use \"backwards\" to make it\n// easier. Hint: from the needle, the expanding points will split when the path\n// of approach is over the Thue-Morse external ray emanating from the bulbing\n// point. They could even split over hyperbolic points!\n//\n// Press 'l' for log to see different coloring and different density.\n//\n// WARNING: there is a slight break every second since the bulbing location is not\n// zoomed in deeply enough (single precision). In the limit there will be no break.\n//\n// Bulbing location (Feigenbaum point): -1.40115518909205060052382678789.\n// Feigenbaum Constant I:                4.66920160910299067185320382047.\n// Feigenbaum Constant II:               2.50290787509589282228390287322.\n// \n////////////////////////////////////////////////////////////////////////////////\n\n// Created by PhdFractal: https://www.youtube.com/channel/UCY-W4FvxaNRoZ8N5b-KzSZg\n// I share this piece (art and code) here in Shadertoy and through its Public API,\n// only for educational purposes. You cannot use, sell, share or host this piece\n// or modifications of it as part of your own commercial or non-commercial product\n// website or project. You cannot use, sell, share or host this piece or modifications\n// of it as part of your own commercial or non-commercial product, website or project.\n// You can share a link to it or an unmodified screenshot of it provided you attribute\n// \"by PhdFractal (@Fractal MathPro)\".\n\nfloat pi=3.14159265358979; //π\nbool keypress(int code){ return texelFetch(iChannel0,ivec2(code,2),0).x != 0.0; } //for keys\nvec2 sqr(vec2 z){ return vec2(z.x*z.x-z.y*z.y,2.*z.x*z.y); }  //squaring\nvec4 rainbow(int i,float density){                       //rainbow palette\n    vec4 black=vec4(0.,0.,0.,1.); vec4 red=vec4(1.,0.,0.,1.); vec4 yellow=vec4(1.,1.,0.,1.);\n    vec4 green=vec4(0.,1.,0.,1.); vec4 cyan=vec4(0.,0.698,1.,1.); vec4 blue=vec4(0.,0.,1.,1.);\n    int r=int(float(i)*density+75.)%100;\n    if(r<16){ float R=float(r)/16.; return mix(black,red,R); }\n    else if(r>=16 && r<31){ float R=float(r-16)/15.; return mix(red,yellow,R); }\n    else if(r>=31 && r<45){ float R=float(r-31)/14.; return mix(yellow,green,R); }\n    else if(r>=45 && r<62){ float R=float(r-45)/17.; return mix(green,cyan,R); }\n    else if(r>=62 && r<78){ float R=float(r-62)/16.; return mix(cyan,blue,R); }\n    else{ float R=float(r-78)/22.; return mix(blue,black,R); }\n}\nvec4 logUF(int i,float shift){                           //log UF palette\n    vec4 black=vec4(0.,0.,0.,1.); vec4 blue=vec4(0.,0.027,0.392,1.); vec4 cyan=vec4(0.125,0.420,0.796,1.);\n    vec4 white=vec4(1.,1.,1.,1.); vec4 yellow=vec4(1.,0.667,0.,1.);\n    int r=int(100.*(log(float(i))/log(2.)+shift))%100; float R=0.;\n    if(r<16){ R=float(r)/16.; return mix(blue,cyan,R); }\n    else if(r>=16 && r<42){ R=float(r-16)/26.; return mix(cyan,white,R); }\n    else if(r>=42 && r<64){ R=float(r-42)/22.; return mix(white,yellow,R); }\n    else if(r>=64 && r<86){ R=float(r-64)/22.; return mix(yellow,black,R); }\n    else{ R=float(r-86)/14.; return mix(black,blue,R); }\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 c=vec2(0.,0.);          //Seed initialized to (0,0).\n    bool backwards=keypress(66); //Press key 'b' for zooming backwards (out).\n    bool islog=keypress(76);     //Press key 'l' for log color mapping (UF).\n    vec4 color=vec4(0.,0.,0.,1.);\n    vec2 z0=vec2(0.,0.); vec2 pix=fragCoord/iResolution.x-.5*vec2(1,iResolution.y/iResolution.x);\n    //Warning: color shift visible since not deep enough!\n    float end=-1.401155189; float pinch=-1.3996344;      //Reference pinch point\n    float feig=4.669201609; float tine=2.502907875; float rem=0.;\n    if(!backwards) { rem=iTime-floor(iTime); }           //Remainder is increasing/decreasing sawtooth.\n    else { rem=ceil(iTime)-iTime; }\n    float diff=(pinch-end)/pow(feig,rem);                //distance to bulbing point (end)\n    float angle=48./23.*pi*(iMouse.x/iResolution.x-0.5); //angle has range 48π/23, slightly more than 2π\n    c=vec2(end+diff*cos(angle),diff*sin(angle));         //c is the exp interpolate seed for bulbing rotated ang\n    float zooma=4.*pow(feig,rem/2.); float zoomj=7.*pow(tine,rem);\n    vec2 za=vec2(0.,0.);                                 //neater to initialize za first\n    if(pix.x<=0.){                                       //absolute bulbing\n        za=1./zooma*(pix+vec2(0.25,0.));\n        for(int i=0; i<int(700.*pow(2.,rem)); i++){\n            vec2 z=sqr(z0)+sqr(za)+c;\n            if(dot(z,z)>4.){\n                if(!islog) { color=logUF(i,0.3-rem); break; }\n                else { color=rainbow(i,1./pow(2.,rem)); break; }\n            }\n            else{ z0=z; } } }\n    else{                                                //julia dissolving/tining/threshing\n        z0=1./zoomj*(pix-vec2(0.25,0.));\n        for(int i=0; i<int(700.*pow(2.,rem)); i++){\n            vec2 z=sqr(z0)+c;\n            if(dot(z,z)>4.){\n                if(!islog) { color=logUF(i,0.3-rem); break; }\n                else { color=rainbow(i,1./pow(2.,rem)); break; }\n            }\n            else{ z0=z; } } }\n    fragColor=color; }","name":"Image","description":"","type":"image"}]}