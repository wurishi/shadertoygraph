{"ver":"0.1","info":{"id":"Nl3fDf","date":"1663707530","viewed":310,"name":"Unreal 1 inspired water","username":"Admer456","description":"Pretty simple shader that approximates water ripples from Unreal Engine 1, or well, is more like inspired by them. \n\nThe original water ripples can be seen here:\nhttps://youtu.be/WTRmZ6aFEWM?t=308\nAnd here:\nhttps://youtu.be/sSSv6cJMUME","likes":8,"published":1,"flags":0,"usePreview":1,"tags":["ripples","retro","water","unreal1998"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Unreal Engine 1 (1998) style water\n// Happily figured out by Admer456, provided to you under Creative Commons Zero 1.0 (CC0),\n// which means free to use anywhere, forever: https://creativecommons.org/publicdomain/zero/1.0/\n//\n// This has been something that has fascinated me for years and years, the original Unreal 1 water effect.\n// When I wrote my first shader thing in 2019, I mentally wrote it down on my bucket list, that I gotta\n// tackle that thing one day and try doing it myself. To my knowledge, Unreal Engine 1 source code is closed,\n// so there's nothing to look at, not that I could understand it anyway. Why would I not understand it?\n// You know, back in 1998, they did not have shaders (omg, imagine the world without that now), and I was\n// pretty curious as to how they did it. And honestly, the most educated guess I have is that they did\n// some sin/cos stuff like in this shader, and reuploaded the texture every frame or two. I don't see any other way,\n// and they must've used some really good, really fast, hand-optimised assembly routines.\n// Lots of other effects seem to have been generated the same way: fire sprites, certain smoke sprites etc.,\n// lots of effects are procedural and that was WAAAAAAY ahead of its time for 1998 IMO. The only late 90s engine that\n// could maybe top this in terms of technological ahead-of-timeness is Trespasser with their bumpmaps, but yeah\n//\n// This actually started off with me experimenting with Quake-style water warping, and well, quickly evolved into this\n// after I accidentally swapped x and y somewhere and/or used a * instead of a + somewhere. I'm pretty happy with it NGL.\n//\n// Could be useful to you if you're writing a 90s-lookin authentic-ish renderer! I'm probably gonna use this in\n// my retro FPS engine, which you can check out here: https://github.com/Admer456/btx-engine\n\n// XY -> wave scale (inverse, more = smaller)\n// ZW -> time scale (more = faster)\n// This was originally intended to have unique coefficients for\n// wave X, wave Y, time on X, time on Y etc., but it seems\n// simplicity worked out better for this one\nconst vec4 WaveCoeffs[4] = vec4[4](\n    vec4( 6.0 ),\n    vec4( 36.0 ),\n    vec4( 4.0 ),\n    vec4( 32.0 )\n);\n\n// Zoom level, greater value = zooming out\nconst float Zoom = 1.0;\n// Global time multiplier\nconst float Speed = 0.36;\n// The greater this is, the smaller the wave will be\nconst float WaveToTextureScale = 2.0;\n// Strength of the ripples, recommended to be around 0.1 to 0.5 \nconst float RippleScale = 0.4;\n// Variation of the ripple, recommended to be about 25% of RippleScale\n// If EnableRippleVariation is 0, this is used as a simple scale multiplier for the ripple\nconst float RippleVariation = 0.05;\n// Additional Quake-style water warp, recommended to be pretty low\nconst float TurbulenceScale = 0.15;\n\n// The \"extra\" pass will consider the last 2 elements in WaveCoeffs\n// I believe without the extra pass is closer to the original, however with it, it looks a bit better IMO\n#define EnableExtraPass 1\n#define EnableRippleVariation 1\n#define EnableTurbulence 1\n// This will help you understand better what's going on, visually\n#define DebugView 0\n\n// Internal detail, don't touch this\n#if EnableExtraPass == 1\n#define MaxCoefficients 4\n#else\n#define MaxCoefficients 2\n#endif\n\n// Surprisingly the star field can be a pretty\n// good water texture when you tint it blue and zoom in\nvec4 SampleColour( vec2 textureCoords )\n{\n    vec3 colour = texture( iChannel0, textureCoords ).rgb;\n    float avg = (colour.r + colour.g + colour.b) / 3.0;\n    return vec4( vec3( avg ) * vec3( 0.2, 0.4, 0.6 ) * 3.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    // And aspect ratio taken into account\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.x *= (iResolution.x / iResolution.y);\n    uv *= WaveToTextureScale * Zoom;\n    \n    float time = iTime * Speed;\n    \n    vec2 turbulenceOffset = vec2( 0.0 );\n    // turbulenceOffset += value0\n    // turbulenceOffset *= value1\n    // turbulenceOffset += value2\n    // turbulenceOffset *= value3\n    for ( int i = 0; i < MaxCoefficients; i++ )\n    {\n        int j = (i + 1) % 4;\n        \n        // The KEY takeaway here is that we're doing this:\n        // x = sin(x' + y') \n        // y = cos(x' - y')\n        vec2 value = vec2(\n            sin( uv.x * WaveCoeffs[i].x + uv.y * WaveCoeffs[j].y + time * WaveCoeffs[i].z ),\n            cos( uv.x * WaveCoeffs[j].x - uv.y * WaveCoeffs[i].y + time * WaveCoeffs[i].w )\n        );\n        \n        // If you *only* multiplied it by value, you'd need to set the\n        // initial vlaue of turbulenceOffset to 1.0, or something a lot higher :>\n        //\n        // Could I maybe do 'turbulenceOffset += value * float( (i % 2) == 0 );' here?\n        // Would avoid branching etc. but I don't think it causes an issue here\n        if ( (i % 2) == 0 )\n        {\n            turbulenceOffset += value;\n        }\n        else\n        {\n            turbulenceOffset *= value;\n        }\n    }\n    #if EnableRippleVariation == 1\n    // Add some variation in wave intensity, like a wind is blowing\n    turbulenceOffset.x *= RippleVariation + sin( uv.y + time * 2.5 ) * (RippleVariation * 0.5);\n    turbulenceOffset.y *= RippleVariation + cos( uv.x + time * 4.5 ) * (RippleVariation * 0.5);\n    #else\n    turbulenceOffset *= RippleVariation;\n    #endif\n    \n    #if EnableTurbulence == 1\n    // Add some Quake-style turbulence, looks nicer to me this way\n    turbulenceOffset.x += sin( uv.y + time * 2.0 ) * TurbulenceScale;\n    turbulenceOffset.y += cos( uv.x + time * 1.2 ) * TurbulenceScale;\n    #endif\n    \n    vec2 finalUv = (uv / WaveToTextureScale) + (turbulenceOffset * RippleScale);\n    \n    #if DebugView == 0\n    fragColor = SampleColour( finalUv / 8.0 );\n    #else\n    fragColor = vec4( mod( finalUv, 1.0 ), 1.0, 1.0 );\n    #endif\n}","name":"Image","description":"","type":"image"}]}