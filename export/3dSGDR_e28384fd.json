{"ver":"0.1","info":{"id":"3dSGDR","date":"1549969176","viewed":1147,"name":"Procedural Octree","username":"fizzer","description":"Similarly to IQ's procedural BVH (https://www.shadertoy.com/view/4tKBWy), here is a raytraced procedural Octree. This one is stackless, it traverses from the root on every node intersection.","likes":50,"published":1,"flags":0,"usePreview":0,"tags":["octree"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Similarly to IQ's procedural BVH (https://www.shadertoy.com/view/4tKBWy), here is\n// a raytraced procedural Octree. This one is stackless, it traverses from the root on every\n// node intersection.\n// \n// Because it's an octree, the number of leaf nodes increases as 8^N where N is the tree depth, so\n// a lot of boxes can be rendered with a small tree-descending loop.\n//\n\n// Ray-box intersection.\nvec2 box(vec3 ro,vec3 rd,vec3 p0,vec3 p1)\n{\n    vec3 t0 = (mix(p1, p0, step(0., rd * sign(p1 - p0))) - ro) / rd;\n    vec3 t1 = (mix(p0, p1, step(0., rd * sign(p1 - p0))) - ro) / rd;\n    return vec2(max(t0.x, max(t0.y, t0.z)),min(t1.x, min(t1.y, t1.z)));\n}\n\n// Box surface normal.\nvec3 boxNormal(vec3 rp,vec3 p0,vec3 p1)\n{\n    rp = rp - (p0 + p1) / 2.;\n    vec3 arp = abs(rp) / (p1 - p0);\n    return step(arp.yzx, arp) * step(arp.zxy, arp) * sign(rp);\n}\n\nfloat traceFirst(vec3 ro, vec3 rd, inout vec3 outn, inout float id)\n{\n\t// Scene AABB.\n    vec2 ob = box(ro, rd, vec3(-1), vec3(1));\n\n    if(ob.y < ob.x || ob.x < 0.)\n    {\n        return -1.0;\n    }\n\n    float tt = max(0., ob.x);\n    vec3 n = vec3(0, 1, 0);\n\n    // March through the octree, one leaf node per step.\n    for(int j = 0; j < 64; ++j)\n    {\n        if(tt > ob.y - 1e-5)\n            break;\n\n        vec3 p2 = ro + rd * tt;\n        vec3 p = p2 + sign(rd) * 1e-4;\n        vec3 p0 = vec3(-1), p1 = vec3(+1);\n\n        id = 0.;\n\n        // Traverse the octree from root, to classify the current march point.\n        for(int i = 0; i < 4; ++i)\n        {\n            // Get centre point of node in worldspace.\n            vec3 c = p0 + (p1 - p0) * (.5 + vec3(.4, .4, .4) * cos(id * vec3(1, 2, 3)));\n\n            if(i < 2)\n                c = p0 + (p1 - p0) * .5;\n\n            // Classify the point within this node.\n            vec3 o = step(c, p);\n\n            // Concatenate the relative child index.\n            id = id * 8. + dot(o, vec3(1, 2, 4));\n\n            p0 = p0 + (c - p0) * o;\n            p1 = p1 + (c - p1) * (vec3(1) - o);\n        }\n\n        // Test the leaf node for solidity.\n        if(cos(id) < -.7)\n        {\n            n = (p2 - (p0 + p1) / 2.) / (p1 - p0);\n            break;\n        }\n        \n        vec2 b = box(ro, rd, p0, p1);\n        tt = b.y;\n    }\n\n    // Get a 'bevelled' normal.\n    outn = normalize(pow(abs(n), vec3(16)) * sign(n));\n\n    return tt;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to +1)\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n\n    // Aspect correction.\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Primary ray.\n    vec3 ro = vec3(0, -.1, 3.), rd = normalize(vec3(uv, -2.));\n\n    float a;\n    mat2 m;\n\n    a = iMouse.z > 0. ? 1.7 - 1.7 * iMouse.y / iResolution.y : cos(iTime / 7.) / 3. + .5;\n    m = mat2(cos(a), sin(a), -sin(a), cos(a));\n\n    ro.yz *= m;\n    rd.yz *= m;\n\n    a = iMouse.z > 0. ? 0. - 2. * iMouse.x / iResolution.x : cos(iTime / 4.) + .5;\n    m = mat2(cos(a), sin(a), -sin(a), cos(a));\n\n    ro.xz *= m;\n    rd.xz *= m;\n\n\t// Scene AABB.\n    vec2 ob = box(ro, rd, vec3(-1), vec3(1));\n\n    fragColor.rgb = vec3(.1);\n\n    float id = 0.;\n    vec3 n = vec3(0, 1, 0);\n    float tt = traceFirst(ro, rd, n, id);\n\n    float pt = (-1. - ro.y) / rd.y;\n    vec3 ld = normalize(vec3(1, 3, 1));\n\n    if(ob.y < ob.x || tt >= ob.y - 1e-5)\n    {\n        tt = pt;\n        id = -1.;\n\n        // Fake shadow.\n        fragColor.rgb *= smoothstep(0., 2., length((ro + rd * tt).xz));\n    }\n\n    vec3 rp = ro + rd * tt;\n    vec3 r = reflect(rd, n);\n\n    if(id >= 0. && ob.x < ob.y)\n    {\n        fragColor.rgb = vec3(.5 + .5 * dot(ld, n));\n        fragColor.rgb += pow(.5 + .5 * n.y, 2.) / 3.;\n\n        if(id < 0.)\n        {\n            // Floor.\n            fragColor.rgb *= .5;\n        }\n        else\n        {\n            // Cuboid.\n            fragColor.rgb *= mix(mix(vec3(1, 1, .25), vec3(.25, .5, 1.), .5 + .5 * cos(id * 8.)),\n                                 \tvec3(.6), pow(.5 + .5 * cos(id * 19.), 4.));\n        }\n\n        // Envmap.\n        fragColor.rgb = mix(fragColor.rgb, texture(iChannel0,r).rgb, mix(.02, .6, pow(1. - clamp(dot(-rd, n), 0., 1.), 2.)));\n\n        // Fake shadow.\n        fragColor.rgb *= pow(smoothstep(-.5, 1.4, length(rp)), 2.);\n    }\n\n    // Gamma.\n    fragColor.rgb = pow(fragColor.rgb, vec3(1./2.2));\n    \n    // Dither.\n    fragColor.rgb += texelFetch(iChannel1, ivec2(fragCoord) & 1023, 0).rgb / 200.;\n}\n\n\n\n","name":"Image","description":"","type":"image"}]}