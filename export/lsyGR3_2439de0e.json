{"ver":"0.1","info":{"id":"lsyGR3","date":"1455999211","viewed":405,"name":"Castle Elsewhere","username":"vnarayanan","description":"A procedural castle based off the following painting: http://willtheartman.deviantart.com/art/Castle-Elsewhere-106004246.","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["procedural","raymarching","fog","npr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926\n#define NOISE\n\nconst mat2 rotMat = mat2(.8660, .5,\n                         -.5, .8660);\nconst int radius = 3;\n\nfloat rand(in vec2 coords)\n{\n    return abs(sin(coords.x * coords.x + 1000.0 * coords.y));\n}\n\nfloat noise2D(in vec2 coords)\n{\n    vec2 smoothCoords = fract(coords);\n    smoothCoords = smoothCoords * smoothCoords * (3.0 - 2.0 * smoothCoords);\n    \n    // Corners\n    vec2 ul = floor(coords);\n    vec2 ur = ul + vec2(1.0, 0.0);\n    vec2 bl = ul + vec2(0.0, 1.0);\n    vec2 br = ul + vec2(1.0);\n    \n    return mix(mix(rand(ul), rand(ur), smoothCoords.x),\n               mix(rand(bl), rand(br), smoothCoords.x),\n               smoothCoords.y);\n}\n\nfloat octaveNoise2D(in vec2 coords)\n{\n    float noise = 0.5 * noise2D(coords); coords = 2.0 * rotMat * coords;\n    noise += 0.25 * noise2D(coords); coords = 2.0 * rotMat * coords;\n    noise += 0.125 * noise2D(coords); coords = 2.0 * rotMat * coords;\n    noise += 0.0625 * noise2D(coords); coords = 2.0 * rotMat * coords;\n    return noise;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/ iResolution.xy;\n    vec4 color = texture(iChannel0, uv);\n    \n    #ifdef NOISE\n    float noise = octaveNoise2D(fragCoord);\n    #else\n    float noise = 0.5;\n    #endif\n    float intensity = .2989 * color.x + .5870 * color.y + .1140 * color.z;\n    float scale = mix(0.5 + 1.0 * noise, 1.0, max(intensity, 1.0 - intensity));\n    \n    \n    // Don't abstract background colors but still perturb them\n    if (color.a == 0.0) {\n        fragColor.rgb = scale * color.rgb;\n        fragColor.a = 1.0;\n        return;\n    }\n    \n    // compute E[X] and E[X^2]\n    vec3 ev[4];\n    vec3 evsquare[4];\n    float qSize = float((radius + 1) * (radius + 1)); // quadrant size\n    \n    for (int index = 0; index < 4; index++) {\n        ev[index] = vec3(0.0);\n        evsquare[index] = vec3(0.0);\n    }\n    \n    // iterate through quadrants\n    vec3 qColor; // sampled color in quadrant\n    \n    for (int i = 0; i <= radius; i++) {\n        for (int j = 0; j <= radius; j++) {\n            qColor = texture(iChannel0, uv + vec2(i, j) / iResolution.xy).rgb;\n            ev[0] += qColor;\n            evsquare[0] += qColor * qColor;\n        }\n    }\n    \n    for (int i = -radius; i <= 0; i++) {\n        for (int j = 0; j <= radius; j++) {\n            qColor = texture(iChannel0, uv + vec2(i, j) / iResolution.xy).rgb;\n            ev[1] += qColor;\n            evsquare[1] += qColor * qColor;\n        }\n    }\n    \n    for (int i = 0; i <= radius; i++) {\n        for (int j = -radius; j <= 0; j++) {\n            qColor = texture(iChannel0, uv + vec2(i, j) / iResolution.xy).rgb;\n            ev[2] += qColor;\n            evsquare[2] += qColor * qColor;\n        }\n    }\n    \n    for (int i = -radius; i <= 0; i++) {\n        for (int j = -radius; j <= 0; j++) {\n            qColor = texture(iChannel0, uv + vec2(i, j) / iResolution.xy).rgb;\n            ev[3] += qColor;\n            evsquare[3] += qColor * qColor;\n        }\n    }\n    \n    for (int index = 0; index < 4; index++) {\n        ev[index] = ev[index] / qSize;\n        evsquare[index] = evsquare[index] / qSize;\n    }\n        \n    \n    \n    vec3 sd;\n    float sdIntensity, minSD = 1000.0;\n    for (int index = 0; index < 4; index++) {\n        sd = abs(evsquare[index] - ev[index] * ev[index]); // Don't need to compute square roots since comparing sd\n        sdIntensity = dot(sd, vec3(.2989, .5870, .1140)); // compute grayscale\n        if (sdIntensity < minSD) {\n            minSD = sdIntensity;\n            fragColor = vec4(scale * ev[index], 1.0);\n        }\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Light sky color, before blending with space/horizon\n#define HORIZON 0.75\n#define NPR 0.0\n#define cl(a) clamp(a, 0.0, 1.0)\n#define MOON_RADIUS .1\n#define PLANET_RADIUS .48\n\nconst vec3 SKY_COLOR = vec3(.1, .3, .5);\n\nconst vec3 MOON_COLOR = vec3(.137, .217, 0.3);\nconst vec2 MOON_LOC = vec2(.2, .8);\n\nconst vec3 PLANET_BAND_1 = vec3(1.0, 0.7294, .8235);\nconst vec3 PLANET_BAND_2 = vec3(0.0, .4019, 0.6);\nconst vec3 PLANET_BAND_3 = vec3(1.0);\nconst vec2 PLANET_LOC = vec2(.85, .3);\n\nfloat rand2d(in vec2 coord)\n{\n    return fract(fract(257.7292 * cos(coord.x)) + fract(177.229 * sin(3.0 * coord.y)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Blend sky color with space\n    float spaceDist = 1.0 - uv.y;\n    // The 4.4 comes from making the intensity 1.0 at HORIZON\n    // the 0.6 makes said intensity actually 0.6\n    vec3 color =  4.4 * 0.6 * spaceDist * SKY_COLOR;\n    \n    \n    // Stars at the top\n    // see https://www.shadertoy.com/view/Md2SR3\n    float threshold = 0.97;\n    float rand = rand2d(uv);\n    if (rand > threshold)\n    {\n       float timeFactor = 0.5 * (1.0 + cos(iTime + 10000.0 * rand));\n       rand = pow((rand - threshold) * 35.0, 7.0);\n       color += pow((1.0 - spaceDist), 8.0) * timeFactor * vec3(rand);\n    }\n    \n    \n    // Moon and planet\n    float aratio = iResolution.x / iResolution.y;\n    vec2 auv = vec2(aratio * uv.x, uv.y);\n    vec2 aMOON_LOC = vec2(aratio * MOON_LOC.x, MOON_LOC.y);\n    if (length(auv - aMOON_LOC) < MOON_RADIUS) {\n        vec3 bgcolor = color;\n        color = (10.0 * pow(length(auv + (MOON_RADIUS * .2) * vec2(1.0, -1.0) - aMOON_LOC), 0.8)) * MOON_COLOR;\n        color = color * (.75 + .5 * texture(iChannel0, uv - uv * uv).r);\n        color = mix(color, bgcolor, pow(length(auv - aMOON_LOC) / MOON_RADIUS, 40.0));\n    }\n    \n    vec2 aPLANET_LOC = vec2(aratio * PLANET_LOC.x, PLANET_LOC.y);\n    mat2 rotMat = mat2(.8660, .5,\n                       -.5, .8660);\n    vec2 puv = rotMat * (auv - aPLANET_LOC);\n    if (length(puv) < PLANET_RADIUS) {\n        vec3 bgcolor = color;\n        color = mix(PLANET_BAND_1, PLANET_BAND_2, 0.5 * (1.0 + sin(60.0 * puv.y)));\n        color = mix(color, PLANET_BAND_3, 0.5 * (1.0 + sin(80.0 * puv.y * puv.y)));\n        color = length(puv + (PLANET_RADIUS * .3) * vec2(-1.0, -1.0)) * color;\n        color = mix(color, bgcolor, pow(length(auv - aPLANET_LOC) / PLANET_RADIUS, 80.0));\n    }\n    \n    // Fade to white at horizon\n    float horizFactor = cl(3.0 * pow(abs(uv.y - HORIZON), 2.5));\n    color = mix(color, vec3(1.0), horizFactor);\n\t\n\tfragColor = vec4(color, NPR);\n}\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const vec3 LIGHT_DIR = normalize(vec3(-1.0, 2.0, -1.0)); // light direction\n\nconst vec3 ROCK_COLOR = 0.5 * vec3(.6706, .4706, .2392);\nconst vec3 FOG_COLOR = vec3(.2, .4216, .5164);\nconst vec3 HOUSE_COLOR_1 = vec3(1.0, .8906, .7656);\nconst vec3 HOUSE_COLOR_2 = 2.0 * vec3(1.0, .6509, .4078);\nconst vec3 HOUSE_POS = vec3(23.0, 2.5, -2.6);\n\nconst mat2 rotMat = mat2(.8, -.6,\n                         .6, .8);\nconst mat3 plateauMat =\n    mat3(.9, 0.0, .4359,\n         0.0, 1.0, 0.0,\n         -.4359, 0.0, .9);\nconst mat3 wallMat =\n    mat3(.99, 0.0, -.1411,\n         0.0, 1.0, 0.0,\n         .1411, 0.0, .99);\nconst float houseTheta = 0.4;\nconst mat3 houseMat = \n    mat3(cos(houseTheta), 0.0, -sin(houseTheta),\n         0.0, 1.0, 0.0,\n         sin(houseTheta), 0.0, cos(houseTheta));\nconst mat3 houseInvMat = \n    mat3(cos(houseTheta), 0.0, sin(houseTheta),\n         0.0, 1.0, 0.0,\n         -sin(houseTheta), 0.0, cos(houseTheta));\nconst mat3 roofMat = wallMat * wallMat * wallMat;\n\nconst float EPSILON = 0.002;\nconst int MAX_STEPS = 500; // Max raymarching steps\nconst float MAX_DIST = 50.0;\n\nvec2 uv;\n\n#define range(value, low, high) (low <= value && value <= high)\n\n#define NPR 1.0\n\n// Object IDs\n#define ID_NONE 0.0\n#define ID_ROCKS 1.0\n#define ID_FOG 2.0\n#define ID_PLATEAU 3.0\n#define ID_CASTLE 4.0\n#define ID_HOUSE 5.0\n#define ID_ROOF 6.0\n\nfloat rand(in vec2 coords)\n{\n    return fract(fract(257.7292 * cos(coords.x)) + fract(177.229 * sin(3.0 * coords.y)));\n}\n\n\nfloat noise2D(in vec2 coords)\n{\n    vec2 smoothCoords = fract(coords);\n    smoothCoords = smoothCoords * smoothCoords * (3.0 - 2.0 * smoothCoords);\n    \n    // Corners\n    vec2 ul = floor(coords);\n    vec2 ur = ul + vec2(1.0, 0.0);\n    vec2 bl = ul + vec2(0.0, 1.0);\n    vec2 br = ul + vec2(1.0);\n    \n    return mix(mix(rand(ul), rand(ur), smoothCoords.x),\n               mix(rand(bl), rand(br), smoothCoords.x),\n               smoothCoords.y);\n}\n\nfloat octaveNoise2D(in vec2 coords)\n{\n    float noise = 0.5 * noise2D(coords); coords = 2.0 * rotMat * coords;\n    noise += 0.25 * noise2D(coords); coords = 2.0 * rotMat * coords;\n    noise += 0.125 * noise2D(coords); coords = 2.0 * rotMat * coords;\n    noise += 0.0625 * noise2D(coords); coords = 2.0 * rotMat * coords;\n    return noise;\n}\n\n// Signed distance for plane on the XZ-plane (using the OpenGL coordinate system)\nfloat sdRocks(in vec3 point)\n{\n    return point.y - 1.85 * octaveNoise2D(point.xz / 1.8);\n}\n\nfloat sdCappedCylinder( vec3 point, vec2 h )\n{\n  vec2 d = abs(vec2(length(point.xz),point.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox(vec3 point, vec3 b)\n{\n  vec3 d = abs(point) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdTriPrism(vec3 point, vec2 h)\n{\n    vec3 q = abs(point);\n    return max(q.z-h.y,max(q.x*0.866025+point.y*0.5,-point.y)-h.x*0.5);\n}\n\nfloat sdPlateau(vec3 point, float size, vec2 bounds) {\n\tvec3 q = abs(point);\n\tfloat f = max(bounds.y - point.y, q.x + q.y + q.z - size);\n    f = max(f, point.y - bounds.x);\n    return f;\n}\n\nfloat sdRoof(in vec3 point, float thickness)\n{\n    point.y = point.y * 3.0;\n    vec2 h1 = vec2(1.2, 0.6);\n    vec2 h2 = vec2(1.2, 0.6 - thickness);\n    return max(-sdTriPrism(point + vec3(0.0, 0.1, 0.0), h1), sdTriPrism(point, h2));\n}\n\nfloat sdHouse(in vec3 point)\n{\n    return min(sdBox(point, vec3(1.4, 0.75, 1.0)),\n               sdTriPrism((point - vec3(0.0, 1.0, 0.0)) * vec3(0.3, 1.0, 1.0), vec2(0.5, 1.0)));\n}\n\nfloat sdFog(in vec3 point)\n{\n    return point.y -  1.3 + rand(point.xz);\n}\n\n// Signed distance function for the overall scene\nvec2 sdScene(in vec3 point)\n{\n    // Start with rocks\n    float id = ID_ROCKS;\n    float sd = sdRocks(point);\n\n    float fog = sdFog(point);\n    float s = 4.0;\n    \n    float plateau = s * sdPlateau(plateauMat * (point - vec3(25.0, 0.0, -3.0)) / s,\n                                  1.0,\n                                  vec2(0.5, 0.0));\n    //plateau = plateau - 0.1 * octaveNoise2D(point.zy - point.xz);\n    \n    vec3 columnSize = vec3(1.0, 0.45, 1.0);\n    \n    float column1 = sdCappedCylinder(columnSize * (point - vec3(21.2, 2.1, -4.0)), vec2(0.25));\n    float column2 = sdCappedCylinder(columnSize * (point - vec3(21.2, 2.1, -2.0)), vec2(0.25));\n    float column3 = sdCappedCylinder(columnSize * (point - vec3(25.2, 2.1, -1.4)), vec2(0.25));\n    float column4 = column1;// NOT VISIBLE sdCappedCylinder(columnSize * (point - vec3(25.2, 2.1, -3.2)), vec2(0.25));\n    float castle = sdBox(wallMat * (columnSize * (point - vec3(23.2, 1.99, -2.66))), vec3(2.0, 0.155, 1.1));\n    castle = min(castle, min(column1, min(column2, min(column3, column4))));\n    \n    float roof = sdRoof(roofMat * 1.0 * (point - HOUSE_POS - vec3(0.0, 0.42, 0.03)), 0.1);\n    \n    float house = sdHouse(2.0 * houseMat * (point - HOUSE_POS));\n    \n    if (fog < sd) {\n        id = ID_FOG;\n        sd = fog;\n    }\n    \n    if (plateau < sd) {\n        id = ID_PLATEAU;\n        sd = plateau;\n    }\n    \n    if (castle < sd) {\n        id = ID_CASTLE;\n        sd = castle;\n    }\n    \n    if (house < sd) {\n        id = ID_HOUSE;\n        sd = house;\n    }\n    \n    if (roof < sd) {\n        id = ID_ROOF;\n        sd = roof;\n    }\n    \n    \n    //return vec2(plateau, ID_PLATEAU);\n    \n    return vec2(sd, id);\n}\n\n// Approximate normal at a given point\nvec3 gradScene(in vec3 point)\n{\n    // Recall that for a function f, df/dx = lim_{h \\to 0} f(x + h) - f(x) / h\n    // Approximately, df/dx is f(x + h) - f(x - h) / 2h\n    // We prefer this form because it might average out any wackiness the estimators have\n    // Normalization removes h\n    return normalize(vec3(sdScene(point + vec3(EPSILON, 0, 0)).x - sdScene(point - vec3(EPSILON, 0, 0)).x,\n                          sdScene(point + vec3(0, EPSILON, 0)).x - sdScene(point - vec3(0, EPSILON, 0)).x,\n                          sdScene(point + vec3(0, 0, EPSILON)).x - sdScene(point - vec3(0, 0, EPSILON)).x));\n}\n\n// Uses raymarching to find the intersection of the ray with the scene\nvec2 raymarch(in vec3 ro, in vec3 rd)\n{\n    float t = 0.01;\n    vec2 sd;\n    float id = ID_NONE;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        sd = sdScene(ro + t * rd);\n\n        if (sd.x < EPSILON) {\n            id = sd.y;\n            break;\n        }\n        \n        if (t > MAX_DIST) break;\n        \n        // extra precision for windows is helpful;\n        // to make them sharper multiply sd.x by some small constant (say, 0.7)\n        // correspondingly the max number of steps needs to be at least 500\n        t += sd.x;\n    }\n    \n    return vec2(t, id);\n}\n\nvec3 render( in vec3 ro, in vec3 rd, out float id)\n{  \n    \n    vec2 sceneSample = raymarch(ro, rd);\n    float t = sceneSample.x;\n    id = sceneSample.y;\n    vec3 point = ro + t * rd;\n    \n    if (sceneSample.y == ID_NONE) {\n        return vec3(0.0);\n    }\n    \n    // Compute Phong shading -- no specular highlights because all the materials are matte\n    vec3 fogColor = clamp(2.0 * octaveNoise2D(point.xz + vec2(iTime, 0.0)), 0.0, 1.0) * FOG_COLOR;\n    bool fog = true;\n    vec3 diffuse;\n    if (sceneSample.y == ID_ROCKS) {\n        diffuse = ROCK_COLOR;\n        diffuse = mix(diffuse, vec3(1.0), pow(t/ MAX_DIST, 4.0));\n    }\n    else if (sceneSample.y == ID_PLATEAU) {\n        diffuse = texture(iChannel2, uv).xyz;\n        diffuse = vec3(dot(diffuse, vec3(0.2989, 0.5870, 0.1140)));\n    }\n    else if (sceneSample.y == ID_CASTLE) {\n        diffuse = texture(iChannel1, uv).xyz;\n        diffuse = 1.5 * vec3(dot(diffuse, vec3(0.2989, 0.5870, 0.1140)));\n        fog = true;\n    }\n    else if (sceneSample.y == ID_HOUSE) {\n        vec3 flatPoint = houseInvMat * (point - HOUSE_POS);\n        bool window = range(flatPoint.x, -0.5, -0.4) && range(flatPoint.y, 0.1, 0.2);\n        window = window || range(flatPoint.x, -0.5, -0.4) && range(flatPoint.y, -0.2, -0.1);\n        window = window || range(flatPoint.x, -0.7, -0.6) && range(flatPoint.y, 0.1, 0.2);\n        window = window || range(flatPoint.x, -0.7, -0.6) && range(flatPoint.y, -0.2, -0.1);\n        window = window || range(flatPoint.x, -0.3, -0.2) && range(flatPoint.y, 0.1, 0.2);\n        window = window || range(flatPoint.x, -0.3, -0.2) && range(flatPoint.y, -0.2, -0.1);\n        if (window) diffuse = HOUSE_COLOR_2;\n        else diffuse = HOUSE_COLOR_1;\n        fog = false;\n    }\n    else if (sceneSample.y == ID_ROOF) {\n        diffuse = 0.5 * texture(iChannel1, uv).xyz;\n        fog = false;\n    }\n    else if (sceneSample.y == ID_FOG) {\n        return mix(fogColor, vec3(1.0), pow(t/ MAX_DIST, 4.0));;\n    }\n    \n    vec3 toLight = LIGHT_DIR;\n    vec3 normal = gradScene(point);\n\n    if (fog)\n        return mix(fogColor, diffuse * clamp(dot(toLight, normal), 0.0, 1.0), pow(abs(1.3 - point.y), 0.2));\n    else\n        return diffuse * clamp(dot(toLight, normal), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Global variable, used in rendering too\n\tuv = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*uv; // pixel space of the focal plane\n\tp.x *= iResolution.x/iResolution.y; // NOTE: I think this is incorrect but if it's changed\n                                        // I'd need to change a bunch of positions which I haven't gotten to\n    \n\t// camera\n    vec3 eye = vec3(0.0, 2.0, 0.0);\n    vec3 look = vec3(20.0, 3.0, 0.0); // where camera is pointing at\n\tvec3 up = vec3( 0.0, 1.0, 0.0 ); // up axis of world\n\tfloat d = 8.5; // distance between eye and focal plane\n    \n    vec3 w = normalize( look - eye);\n\tvec3 u = normalize( cross(w,up) );\n\tvec3 v = normalize( cross(u,w) );\n\tvec3 rd = normalize( p.x*u + p.y*v + d*w );\n    \n    float id;\n    vec3 col = render(eye, rd, id);\n    \n    if (id == ID_NONE)\n        fragColor = texture(iChannel0, uv);\n    else\n        fragColor=vec4(col, NPR);\n}","name":"Buf B","description":"","type":"buffer"}]}