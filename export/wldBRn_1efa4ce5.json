{"ver":"0.1","info":{"id":"wldBRn","date":"1612297588","viewed":67,"name":"Terrain from noise","username":"d3ed3e905","description":"Generating terrain using original perlin noise","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["perlinnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////// __Usage(Presets)__/////////////////////////////////\n\n// Choose between DIRECTION1 and DIRECTION2. What you choose must match\n// direction from Buffer A.\n\n// You can what type of light to apply. Select between LINEAR_LIGHT, CURVED_LIGHT or\n// SIN_LIGHT.\n\n// Feel free to modify ITER number. If you have a good video card, you can try a big\n// number for ITER. For a good result ITER must be at least 100.\n\n// For more controls, please check the __KEYBOARD INPUT_ section. \n\n/////////////////////////////////////////////////////////////////////////////////\n\n\n//______Switch______\n//#define DIRECTION1\n#define DIRECTION2\n\n//______Switch______\n//#define LINEAR_LIGHT\n//#define CURVED_LIGHT\n#define SIN_LIGHT\n\n// parallax mapping\n#define ITER 1000\n\n////////////////////////////////////////////__KEYBOARD INPUT__///////////////////////////////////////////\n\nconst float KEY_F = 70.; // Enable ATMOSPHERE\nconst float KEY_Q = 81.; // Light mode: MIX\nconst float KEY_W = 87.; // Light mode: ADD\nconst float KEY_A = 65.; // Switch white/green (in MIX mode)\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n#define PI 3.141592653589793\n\n#define BLUE_LIGHT vec3(0.6, 0.8, 1.)\n#define GREY vec3(0.36, 0.54, 0.54)\n#define GREY_LIGHT vec3(0.93, 0.96, 0.96)\n#define GREEN_DARK vec3(0.2, 0.4, 0.2)\n#define GREEN_LIGHT vec3(0.0, 0.6, 0.2)\n#define GREEN_VERY_DARK vec3(0.0, 0.20, 0.0)\n\nfloat height(vec3 p)\n{\n    return texture(iChannel0, p.xy / 20.).x * .25 + p.z;\n}\n\nfloat getR(vec3 p)\n{\n    return (texture(iChannel0, p.xy / 20.) * .25).r;\n}\n\nvec3 interpolateColors(float n, vec2 limits, vec3 startColor, vec3 endColor)\n{\n    float a = ((n - limits.x) / (limits.y - limits.x));\n    float invn = 1.0 - a;\n    return vec3(endColor.r * a + startColor.r * invn,\n                endColor.g * a + startColor.g * invn,\n                endColor.b * a + startColor.b * invn);\n}\n\nvec3 EffectsSky(vec3 rgb, vec2 xy)\n{\n    float contrast = 1.3;\n    float saturation = 1.;\n    float brightness = 1.3;\n    \n    rgb = mix(vec3(.5), mix(vec3(dot(vec3(.892125, .89154, .921), rgb * brightness)), rgb * brightness, saturation), contrast);\n    rgb *= 0.5 * pow(180.0 * (xy.x + 0.1) * (xy.y + 0.05) * (1.1 - xy.x) * (1.1 - xy.y), 0.2); // Vignete\n    \n    return clamp(rgb, 0.0, 1.0);\n}\n\nvec3 EffectsMountain(vec3 rgb, vec2 xy, vec3 p)\n{\n    rgb *= 0.5 * pow(180.0 * (xy.x + 0.1) * (xy.y + 0.05) * (1.1 - xy.x) * (1.1 - p.z), 0.2); // Vignete\n    return clamp(rgb, 0.0, 1.0);\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec2 xy = fragCoord.xy / iResolution.xy;\n    float mouse = iMouse.x / iResolution.x * 360.;\n\n    vec3 ro = vec3(7., 1.5, .0);\n    vec3 rd = normalize(vec3(uv.x, 1.5, uv.y - 0.3));\n\n    float a = sin(iTime / 3.0) / 10. - .1;\n    rd.yz *= mat2(cos(a), -sin(a), sin(a), cos(a));\n\n    vec3 p = vec3(ro.xy - ro.z / (rd.z / rd.xy), 0.);\n    float d = length(p - ro);\n\n    for (int i = 0; i <= ITER; i++)\n    {\n        if ((p.y > 10.) || (p.x < 0.0) || (p.x > 20.0) || (p.z > 0.9) || (p.y <0.0))\n            break;\n        p = ro + rd * d;\n        d += height(p);\n    }\n\n    vec3 fcolor;\n    float v = getR(p); //color value from height map\n\n    if (v < 0.20)\n        fcolor = interpolateColors(v, vec2(0., 0.20), GREY_LIGHT, GREY);\n    else if (v < 0.45)\n        fcolor = interpolateColors(v, vec2(0.22, 0.45), GREY, GREEN_LIGHT);\n    else if (v < 0.6)\n        fcolor = interpolateColors(v, vec2(0.45, 0.6), GREEN_LIGHT, GREEN_DARK);\n    else if (v < 0.99)\n        fcolor = interpolateColors(v, vec2(0.8, .99), GREEN_DARK, GREEN_VERY_DARK);\n    else if ((p.z > -0.2) && (p.z < .1))\n            fcolor = GREEN_VERY_DARK;\n\n    if ((p.y > 10.) || (p.z > 0.9) || (p.x < 0.0) || (p.x > 20.0)||(p.y <0.0))\n    {\n        fcolor = BLUE_LIGHT;\n        fragColor = vec4(fcolor, .7);\n    }\n    else\n    {\n        vec3 n = texture(iChannel0, p.xy / 20.).xyz * 1.3;\n        vec3 sun = normalize(vec3(-.29, 50., -8.5));\n        n = normalize(vec3(n.y, 2., n.z));\n        float b = dot(sun, n);\n        vec3 col = fcolor;\n        col *= vec3(b);\n        vec3 color1 = vec3(fcolor * dot(vec3(0.5, 0.9, 0.1), normalize(vec3(col.y * 2.0 - 1.0, 0.6, col.z * 2.0 - 1.0)))); \n\n        // lights\n        vec3 normal = (texture(iChannel1, p.xy / 20.) + 0.25).rgb;\n\n        float Cmax = max(max(normal.r, normal.g), normal.b);\n        float Cmin = min(min(normal.r, normal.g), normal.b);\n        float Delta = Cmax - Cmin;\n        float hue;\n        if (Delta == 0.)\n            hue = 0.;\n        else if (Cmax == normal.r)\n            hue = 60. * mod((normal.g - normal.b) / Delta, 6.);\n        else if (Cmax == normal.g)\n            hue = 60. * ((normal.b - normal.r) / Delta + 2.);\n        else\n            hue = 60. * ((normal.r - normal.g) / Delta + 4.);\n\n        float limL = mouse - 35.;\n        float limR = mouse + 35.;\n\n        float factor = 0.;\n        if ((hue > limL) && (hue < limR))\n        {\n        \n//////////////____________________________LIGHT FUNCTIONS__________________________________//////////////\n///////////////////////////////////////////___LINEAR___//////////////////////////////////////////////////\n\n#ifdef LINEAR_LIGHT\n            float mean = (limL+limR)/2.;\n            if (hue <= mean)\n            {\n                float aux = mean - limL;\n                factor = (hue - limL) / aux;\n            }\n            else if (hue >= mean)\n            {\n                float aux = limR - mean;\n                factor = (limR - hue) / aux;\n            }\n#endif\n\n////////////////////////////////////////////__CURVED__///////////////////////////////////////////////////\n\n#ifdef CURVED_LIGHT\n            float x = 2. * (hue - limL) / (limR - limL);\n            float factor = -1. * pow(x - 1., 2.) + 1.;\n#endif\n\n////////////////////////////////////////////__SINUS__////////////////////////////////////////////////////\n\n#ifdef SIN_LIGHT\n            float x = (hue - limL) / (limR - limL);\n            float factor = (sin(2. * PI * (x - .25)) + 1.) / 2.;\n#endif\n\n//////////////////____________________________LIGHT MODE__________________________________///////////////\n////////////////////////////////////////////__MIX COLORS__///////////////////////////////////////////////\n\n    if (bool(texelFetch(iChannel2, ivec2(KEY_Q, 2), 0).r)){\n    vec3 color2;\n\n#ifdef DIRECTION1\n    if (bool(texelFetch(iChannel2, ivec2(KEY_A, 2), 0).r))\n            color2 = color1 + vec3(0.8, 0.7, 0.7)/(abs(v)+.05)*factor*texture(iChannel3, p.xz).x; // WHITE\n    else\n            color2 = color1 + vec3(0.3, 0.4, 0.3) / (abs(v) + .05) * factor * texture(iChannel3, p.xz).x; // GREEN\n#endif\n\n\n#ifdef DIRECTION2\n    if (bool(texelFetch(iChannel2, ivec2(KEY_A, 2), 0).r))\n            color2 = color1 + vec3(0.8, 0.7, 0.7)/(abs(v)+.05)*factor*texture(iChannel3, p.yz).x; // WHITE\n    else\n            color2 = color1 + vec3(0.3, 0.4, 0.3) / (abs(v) + .05) * factor * texture(iChannel3, p.yz).x; // GREEN\n#endif\n            color1 = mix(color1, color2, .1);\n}\n\n////////////////////////////////////////////__ADD COLORS__///////////////////////////////////////////////\n\nif (bool(texelFetch(iChannel2, ivec2(KEY_W, 2), 0).r)){\n\n#ifdef DIRECTION1\n            color1 += vec3(0.02, 0.02, 0.01) / (abs(v) + .05) * factor * texture(iChannel3, p.xz).x;\n#endif\n    \n#ifdef DIRECTION2\n            color1 += vec3(0.02, 0.02, 0.01) / (abs(v) + .05) * factor * texture(iChannel3, p.yz).x;\n#endif\n            \n}\n        }\n\n////////////////////////////////////////////__ATMOSPHERE__///////////////////////////////////////////////\n\n        if (p.y > .7)\n        {\n            float var_alpha = 0.4;\n            if (bool(texelFetch(iChannel2, ivec2(KEY_F, 2), 0).r))\n                var_alpha = 0.;\n\n            vec4 color4 = vec4(BLUE_LIGHT * max(v, 0.) * (p.y - 0.7), var_alpha);\n            vec4 color3 = vec4(color1, 1.0);\n            color3 = mix(color3, color4, color4.a);\n            fragColor = color3;\n        }\n    }\n    if ((p.y > 10.) || (p.z > 0.9) || (p.x < 0.0))\n    {\n        vec3 col = EffectsSky(vec3(fragColor.r, fragColor.g, fragColor.b), xy);\n        fragColor = vec4(col, 1.0);\n    }\n    else\n    {\n        vec3 col = EffectsMountain(vec3(fragColor.r, fragColor.g, fragColor.b), xy, p);\n        fragColor = vec4(col, 1.0);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//#define DIRECTION1\n#define DIRECTION2\n\nconst int p[512] = int[](151, 160, 137, 91, 90, 15,\n                         131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,\n                         190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33,\n                         88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166,\n                         77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244,\n                         102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196,\n                         135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123,\n                         5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42,\n                         223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9,\n                         129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228,\n                         251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107,\n                         49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,\n                         138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180, 151,\n                         160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99,\n                         37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35,\n                         11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134,\n                         139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55,\n                         46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18,\n                         169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250,\n                         124, 123,5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42,\n                         223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9,\n                         129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228,\n                         251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107,\n                         49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,\n                         138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180);\n\nfloat lerp(float amount, float left, float right)\n{\n    return float((1.0 - amount) * left + amount * right);\n}\n\nfloat fade(float t)\n{\n    return t * t * t * (t * (t * 6. - 15.) + 10.);\n}\n\nfloat grad(int hash, float x, float y)\n{\n    switch (hash & 3)\n    {\n    case 0:\n        return x + y;\n    case 1:\n        return -x + y;\n    case 2:\n        return x - y;\n    case 3:\n        return -x - y;\n    default:\n        return 0.0;\n    }\n}\nfloat noise(float x, float y)\n{\n    int xi = int(floor(x)) & 255;\n    int yi = int(floor(y)) & 255;\n    int g1 = p[p[xi] + yi];\n    int g2 = p[p[xi + 1] + yi];\n    int g3 = p[p[xi] + yi + 1];\n    int g4 = p[p[xi + 1] + yi + 1];\n\n    float xf = float(x - floor(x));\n    float yf = float(y - floor(y));\n\n    float d1 = grad(g1, xf, yf);\n    float d2 = grad(g2, xf - 1., yf);\n    float d3 = grad(g3, xf, yf - 1.);\n    float d4 = grad(g4, xf - 1., yf - 1.);\n\n    float u = fade(xf);\n    float v = fade(yf);\n\n    float x1Inter = lerp(u, d1, d2);\n    float x2Inter = lerp(u, d3, d4);\n    float yInter = lerp(v, x1Inter, x2Inter);\n\n    return yInter;\n}\n\nfloat fbm(in vec2 st)\n{\n    float value = 0.0;\n    const int octaves = 6;\n    float lacunarity = 2.0;\n    float gain = .5;\n    float amplitude = 1.0;\n    float frequency = 1.7;\n\n    for (int i = 0; i < octaves; i++)\n    {\n        value += amplitude * noise(st.x * frequency, st.y * frequency);\n        frequency *= lacunarity;\n        amplitude *= gain;\n    }\n    return value;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n#ifdef DIRECTION1\n    uv.y += iTime / 20.;\n#endif\n\n#ifdef DIRECTION2\n    uv.x += iTime / 20.;\n#endif\n\n    float color = 0.0;\n    color += fbm(uv * 8.);\n    //float new_uv_x = smoothstep(-1.0, 1.0, color);\n\n    vec3 r = vec3(color) + 1.0;\n    fragColor = vec4(r, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float getHeight(vec2 uv)\n{\n    return texture(iChannel0, uv).r;\n}\n\nvec4 normalFromDepth(vec2 uv, vec2 resolution, float scale)\n{\n    vec2 step = 1. / resolution;\n    float height = getHeight(uv);\n    vec2 dxy = height - vec2(\n                            getHeight(uv + vec2(step.x, 0.)),\n                            getHeight(uv + vec2(0., step.y)));\n\n    return vec4(normalize(vec3(dxy * scale / step, 1.)), height);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(normalFromDepth(uv, iResolution.xy, 0.1).rgb * .5 + .5, 1.);\n}","name":"Buffer B","description":"","type":"buffer"}]}