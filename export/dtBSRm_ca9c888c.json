{"ver":"0.1","info":{"id":"dtBSRm","date":"1675827496","viewed":224,"name":"Happy patterns","username":"ianertson","description":"You can drag around with the mouse if you want to :)","likes":15,"published":1,"flags":32,"usePreview":0,"tags":["noise","colors","patterns","happy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n\nvec3 mouse(vec2 uv) { return texture(iChannel1, uv).xyz; }\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = fc/R.xy;\n    vec3 m = mouse(uv);\n    vec2 p = uv.xy;\n    p.x *= R.x/R.y;\n    m.x *= R.x/R.y;\n    vec2 L = normalize((p.xy) - (m.xy));\n    float dist = distance(p, m.xy);\n    col = texture(iChannel0 , uv).rgb;\n    vec2 bump = extractBump(iChannel0, uv);\n    bump = normalize(mix(bump, L, 0.45));\n    float NdotL = max(0.0, dot(bump, L));\n    col = saturate(col, 0.7);\n    float att = clamp(NdotL * (0.01 / max(0.001, pow(dist, 2.0))), 0.0, 1.0);\n    att = max(clamp(pow(luma(col), 3.8)*4., 0.0, 1.0), att);\n    col = col * att;\n    col += ((col+0.001)*luma(col)) / (2.);\n    col = mix(col, col*col, 0.6);\n    vec3 fcol = col;\n    fcol /= vec3(1.0)+fcol;\n    fcol = pow(fcol, vec3(1.0 / 2.2));\n    col = mix(col, fcol, clamp(0.1 + (luma(col)*2.), 0.0, 0.45));\n    O = vec4(clamp(col, 0.0, 1.0), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 mousePos() {\n    if (iMouse.z > 0.001) return iMouse.xy;\n    float poofX = pow(max(0.0, 0.5+(0.5*sin(T*2.))), 8.0);\n    float poofY = pow(max(0.0, 0.5+(0.5*cos(T*2.))), 8.0);\n    vec2 poof = vec2(poofX, poofY);\n    vec2 p = vec2(cos((T*0.5)*(2.+(poofX*0.05))), sin((T*0.5)*(2.+(poofY*0.05))))*(R.x*0.15)*(R.x/R.y);\n    p.x += 0.5*(sin(poofY*6.0)*(R.x*0.5)*0.5) * (R.x/R.y);\n    p.y += 0.5*(cos(poofX*6.0)*(R.y*0.5)*0.5);\n    p.x *= (R.x/R.y);\n    p = (R.xy/2.0) + p; \n    p.x = clamp(p.x, 16.0, R.x-16.0);\n    p.y = clamp(p.y, 16.0, R.y-16.0);\n    return p;\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = fc/R.xy;\n    float size = 1.0 / TS(iChannel0).x;\n    vec3 old = texture(iChannel0, uv).xyz;\n    vec3 next = vec3(mousePos()/R.xy, iMouse.z);\n    next = mix(old, next, 0.2 * (iMouse.z > 0.01 ? 1.1 : 0.5));\n    col.xyz = next;\n    O = vec4(col, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define TS(tex) vec2(textureSize(tex, 0).xy)\n#define P2(v) (pow(v, 2.0))\n#define M_PI (3.1416)\n#define TAU (M_PI * 2.0)\n#define T (iTime*0.2)\n#define R iResolution.xy\n\n\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    \n    \n    return mat2(c, s, -s, c);\n}\n\nfloat hash1(float x) {\n    uint y = floatBitsToUint(x + 12.);\n    uint y2 = (y >> 9u);\n    y2 ^= y2 << 13;\n    y2 ^= y2 >> 17;\n    y2 ^= y2 << 5;\n    uint n = 912229U * ((y) ^ ((y2 ^ (y<<2))>>3U));\n    return float(n) / float(0xffffffffU);\n}\n\nfloat hash2(vec2 x, float seed) {\n    seed = hash1(seed+0.91256);\n    uint hx = uint(hash1(x.x+35.1)*3921.52 + seed);\n    uint hy = uint(hash1(x.y+91.1)*3921.44 + seed);\n    uvec2 y = uvec2(floatBitsToUint(x.x+12.92815 + seed), floatBitsToUint(x.y+12.12245 + seed));\n    uint a = 912229U * (((y.x << (hx >> (hy ^ (y.x+y.y)))) ^ (y.y >> 2u)) ^ (hx ^ hy));\n    return float(a) / float(0xffffffffU);\n}\n\nfloat noise(vec2 p, float seed) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p);\n    lv = lv * lv * (3.0 - 2.0 * lv);\n    float ab = mix(hash2(id, seed), hash2(id+vec2(1.0, 0.0), seed), lv.x);\n    float cd = mix(hash2(id+vec2(0.0, 1.0), seed), hash2(id+vec2(1.0, 1.0), seed), lv.x);\n    return mix(ab, cd, lv.y);\n}\n\n#define NOISE_BODY(c)\\\n    float n = 0.0;\\\n    float amp = 1.0;\\\n    float div = 0.0;\\\n    for (int i = 0; i < c; i++) {\\\n        div += amp;\\\n        n += amp * noise(p*freq, seed);\\\n        freq *= 2.;\\\n        amp /= 2.0;\\\n    }\\\n    return n / div;\n\n//float noise8(vec2 p, float freq) { NOISE_BODY(8); }\nfloat noise16(vec2 p, float freq, float seed) { NOISE_BODY(16); }\n//float noise32(vec2 p, float freq) { NOISE_BODY(32); }\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nvec2 extractBump(sampler2D tex, vec2 uv) {\n    vec3 color = texture(tex, uv).rgb;\n    vec2 texelSize = 1.0 / vec2(textureSize(tex, 0));\n    vec3 dx = texture(tex, uv + vec2(texelSize.x, 0)).rgb - color;\n    vec3 dy = texture(tex, uv + vec2(0, texelSize.y)).rgb - color;\n    float l = (abs(dy.r - dx.r) + abs(dx.g - dy.g)) / 2.0;\n    vec2 a = normalize(vec2(dy.r - dx.r, dx.g - dy.g));\n    return a;\n}\n\nvec3 saturate(vec3 color, float amnt) {\n  float l = color.r * 0.2 + color.g * 0.7 + color.b * 0.1;\n  vec3 gray = vec3(l,l,l);\n  vec3 diff = color.rgb - gray.rgb;\n  diff *= (1.0 + amnt);\n  vec3 saturated = clamp(gray + diff,0.0,1.0);\n  return mix(color, saturated, clamp(amnt, 0.0, 1.0));\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nvec3 smin(vec3 a, vec3 b, float k) {\n    return vec3(\n        smin(a.x, b.x, k),\n        smin(a.y, b.y, k),\n        smin(a.z, b.z, k)\n    );\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec3 mouse(vec2 uv) { return texture(iChannel0, uv).xyz; }\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = fc/R.xy;\n    vec2 center = R.xy*0.5;\n    vec2 cuv = (fc-0.5*R.xy)/R.y;\n    center.x *= (R.x/R.y);\n    center /= R.xy;\n    vec3 m = mouse(uv);\n    vec2 travel = vec2(T, -T)*0.2*(iMouse.z > 0.01 ? 0.1 : 0.7);\n    float seed = 0.20156;\n    vec3 old = texture(iChannel1, uv).rgb;\n    float oldSeed = T <= 0.01 ? 0.0 : texelFetch(iChannel1, ivec2(0), 0).r;\n    uv.x *= (R.x/R.y);\n    m.x *= (R.x/R.y);\n    float fM = smoothstep(0.3-0.1, 0.3+0.1, distance(uv, m.xy));\n    fM = mix(fM, max(0.001, 1.0 / (0.1+distance(uv, m.xy))), 0.5);\n    vec2 fshift = m.xy*(0.2+fM);\n    vec2 shift = vec2(cos(T*0.2), sin(T*0.2))*8.;\n    vec2 dir = normalize(m.xy - center.xy);\n    vec2 ruv = uv;\n    ruv.x -= 0.5*(R.x/R.y);\n    ruv.y -= 0.5;\n    ruv *= rot(dot(cuv.yx, -dir));\n    ruv.x += 0.5*(R.x/R.y);\n    ruv.y += 0.5;\n    uv = mix(uv, ruv, 0.5*clamp(3.0*pow(distance(m.xy, center), 3.0), 0.0, 1.0));\n    \n    uv += travel;\n    uv *= 2.2 + ((0.5+(0.5*cos((T+8.13)*0.2)))*3.);\n    float reg = noise16((uv*16.)+(fshift*4.)+shift, 0.2, seed); // regions\n    float k = (0.5+(0.5*sin((T*reg)*0.5)))*0.002;\n    seed = mix(oldSeed, reg, 1.0 / 30.)*(max(0.0, 0.003-k)*reg); \n    float freq = 1.2;\n    float t = (((T+(reg*16.))*(0.5+(reg*0.009)))*(0.2+(reg*0.0009)))*0.2;\n    uv.x += t*0.001;\n    uv.y -= t*0.001;\n    uv += T*0.15;\n    vec2 sR = vec2(reg+cos(t+(reg*3.3)), reg+sin(t+(reg*3.3)));\n    vec2 sG = vec2(reg+sin(t+(reg*3.3)), reg+cos(t+(reg*3.3)));\n    vec2 sB = vec2(reg+sin(t+(reg*3.3)), reg+sin(t+(reg*3.3)));\n    float r = noise16((uv+sR) + old.g*0.1, freq, 0.5167 + seed);\n    float g = noise16((uv+sG) + old.b*0.1, freq, 1.2916 + seed);\n    float b = noise16((uv+sB) + old.r*0.1, freq, 3.9283 + seed);\n    col = vec3(r, g, b);\n    \n    if (T > 0.01) {\n        col = mix(old, col, 0.46);\n        vec3 ma = smin(old, col, -0.05);\n        col = mix(col, ma, 0.46);\n    }\n    // storing the seed here \n    if (fc.x <= 1.0) { col = vec3(seed); }\n    O = vec4(clamp(col, 0.0, 1.0), 1.0);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}