{"ver":"0.1","info":{"id":"csXyWs","date":"1687288245","viewed":34,"name":"sandbox-naphipps","username":"naphipps","description":"sandbox","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sandbox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 white = vec3(1.0);\nvec3 black = vec3(0.0);\nvec3 gray = vec3(0.5);\nvec3 red = vec3(1.0, 0.0, 0.0);\nvec3 blue = vec3(0.0, 1.0, 0.0);\nvec3 green = vec3(0.0, 0.0, 1.0);\nvec3 yellow = vec3(1.0, 1.0, 0.0);\nvec3 cyan = vec3(0.0, 1.0, 1.0);\nvec3 magenta = vec3(1.0, 0.0, 1.0);\n\nvec3 outline_color = vec3(1.0);\nfloat outline_width = 3.0;\nfloat mouse_radius = 10.0;\n\nvec3 get_background_color(in vec2 fragCoord)\n{\n    return 0.5 + 0.5 * cos(iTime + (fragCoord / iResolution.xy).xyx + vec3(0, 2, 4)); // Time varying pixel color\n}\n\nvec3 get_mouse_color(in vec2 fragCoord)\n{\n    return get_background_color(fragCoord).brg;\n}\n\n//https://iquilezles.org/articles/distfunctions2d/\n\nfloat dot2( vec2 v )\n{\n    return dot(v,v);\n}\n\nfloat sdf_circle(in vec2 p, in float r)\n{\n    return length(p) - r;\n}\n\nfloat sdf_rect(in vec2 p, in vec2 b)\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdf_round_rect( in vec2 p, in vec2 b, in float r)\n{\n    b -= r;\n    return sdf_rect(p, b) - r;\n}\n\nfloat sdf_round_rect( in vec2 p, in vec2 b, in vec4 r)\n{\n    r.xy = (p.x > 0.0) ? r.xy : r.zw;\n    r.x  = (p.y > 0.0) ? r.x : r.y;\n    vec2 q = abs(p) - b + r.x;\n    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;\n}\n\nfloat sdf_rot_rect(in vec2 p, in vec2 a, in vec2 b, float thickness)\n{\n    float l = length(b - a);\n    vec2  d = (b - a) / l;\n    vec2  q = p - (a + b) * 0.5;\n          q = mat2(d.x, -d.y, d.y, d.x) * q;\n          q = abs(q) - vec2(l * 0.5, thickness);\n    return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0);    \n}\n\nfloat sdf_round_rot_rect(in vec2 p, in vec2 a, in vec2 b, float thickness, in float r)\n{\n    vec2 dir = (b - a) / length(b - a);\n    a += r * dir;\n    b -= r * dir;\n    return sdf_rot_rect(p, a, b, thickness - r) - r;\n}\n\nfloat sdf_cool_s(in vec2 p)\n{\n    float six = p.y < 0.0 ? -p.x : p.x;\n    p.x = abs(p.x);\n    p.y = abs(p.y) - 0.2;\n    float rex = p.x - min(round(p.x / 0.4), 0.4);\n    float aby = abs(p.y - 0.2) - 0.6;\n    \n    float d = dot2(vec2(six, -p.y) - clamp(0.5*(six - p.y), 0.0, 0.2));\n    d = min(d, dot2(vec2(p.x, -aby) - clamp(0.5*(p.x - aby), 0.0, 0.4)));\n    d = min(d, dot2(vec2(rex, p.y - clamp(p.y, 0.0, 0.4))));\n    \n    float s = 2.0 * p.x + aby + abs(aby + 0.4) - 0.4;\n\n    return sqrt(d) * sign(s);\n}\n\nvec3 blend_add(in vec3 a, in vec3 b)\n{\n    float _min = 0.0;\n    float _max = 1.0;\n    return clamp(a + b, vec3(_min, _min, _min), vec3(_max, _max, _max));\n}\n\nvec3 blend_mult(in vec3 a, in vec3 b)\n{\n    float _min = 0.0;\n    float _max = 1.0;\n    return clamp(a * b, vec3(_min, _min, _min), vec3(_max, _max, _max));\n}\n\nvec3 outline(in vec3 color, in vec3 outline_color, in float outline_width, in float t)\n{\n    return (t >= 0.0 || t <= 1.0) ? mix(color, outline_color, 1.0 - smoothstep(0.0, pow(outline_width, 2.0), pow(t, 2.0))) : color;\n}\n\nvec3 fill(in vec3 color, in vec3 fill_color, in float threshold, in float t)\n{\n    return t < threshold ? fill_color : color;\n}\n\nvec3 mouse(in vec3 color, in vec2 point)\n{\n    vec2 mouse = iMouse.xy;\n    vec3 mouse_color = get_mouse_color(point);\n    float d = sdf_circle(point - mouse, mouse_radius);\n    \n    color = fill(color, mouse_color, 0.0, d);\n    color = outline(color, outline_color, outline_width, d);\n    return color;\n}\n\nvoid mainImageCircle(out vec4 fragColor, in vec2 point)\n{\n    vec3 res = iResolution;\n    vec3 background = get_background_color(point);\n    vec3 color = background;\n    float d;\n    \n    vec2 circle_center = res.xy / 2.0;\n    float circle_radius = res.y / 3.0;\n    vec3 circle_color = 1.0 - background;\n    \n    //draw circle\n    d = sdf_circle(point - circle_center, circle_radius);\n    color = fill(color, circle_color, 0.0, d);\n    color = outline(color, outline_color, outline_width, d);\n    \n    \n    //draw mouse\n    if (iMouse.z > 0.001) //if MLB down\n    {\n        color = mouse(color, point);\n        \n        //draw circle difference thing\n        vec2 diff = iMouse.xy;\n        d = sdf_circle(diff - circle_center, circle_radius);\n        \n        d = sdf_circle(point - diff, abs(d));\n        color = outline(color, outline_color, outline_width, d);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\nvoid mainImageRect(out vec4 fragColor, in vec2 point)\n{\n    vec2 res = iResolution.xy;\n    vec3 background = get_background_color(point);\n    vec3 color = background;\n    float d;\n    \n    vec2 rect_zone = vec2(res.x / 3.0, res.y);\n    vec2 rect_center = rect_zone / 2.0;\n    vec2 rect_size = vec2(rect_zone.x / 3.0, rect_zone.y / 3.0);\n    float rect_radius = min(res.x, res.y) / 25.0;\n    vec4 rect_radi = vec4(0.0, rect_radius, rect_radius * 2.0, rect_radius * 3.0);\n    vec3 rect_color = 1.0 - background.brg;\n    \n    //simple rect\n    d = sdf_rect(point - rect_center, rect_size);\n    color = fill(color, rect_color, 0.0, d);\n    color = outline(color, outline_color, outline_width, d);\n    \n    //rect with one radius value\n    rect_color = rect_color.brg;\n    rect_center.x += rect_zone.x;\n    \n    d = sdf_round_rect(point - rect_center, rect_size, rect_radius);\n    color = fill(color, rect_color, 0.0, d);\n    color = outline(color, outline_color, outline_width, d);\n    \n    //rect with multi radius values\n    rect_color = rect_color.brg;\n    rect_center.x += rect_zone.x;\n    \n    d = sdf_round_rect(point - rect_center, rect_size, rect_radi);\n    color = fill(color, rect_color, 0.0, d);\n    color = outline(color, outline_color, outline_width, d);\n    \n    //draw mouse\n    if (iMouse.z > 0.001) //if MLB down\n    {\n        color = mouse(color, point);\n        \n        //draw circle difference thing to closest rect\n        vec2 diff = iMouse.xy;\n        \n        rect_center = rect_zone / 2.0;\n        d = sdf_rect(diff - rect_center, rect_size);\n        \n        rect_center.x += rect_zone.x;\n        d = min(d, sdf_round_rect(diff - rect_center, rect_size, rect_radius));\n        \n        rect_center.x += rect_zone.x;\n        d = min(d, sdf_round_rect(diff - rect_center, rect_size, rect_radi));\n        \n        d = sdf_circle(point - diff, abs(d));\n        color = outline(color, outline_color, outline_width, d);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\nvoid mainImageRotRect(out vec4 fragColor, in vec2 point)\n{\n    vec2 res = iResolution.xy;\n    vec3 background = get_background_color(point);\n    vec3 color = background;\n    float d;\n    \n    vec2 rect_zone = vec2(res.x / 2.0, res.y);\n    vec2 rect_size = vec2(rect_zone.x / 3.0, rect_zone.y / 3.0);\n    vec2 rect_center = rect_zone / 2.0;\n    float rect_radius = min(res.x, res.y) / 25.0;\n    vec3 rect_color = 1.0 - background.brg;\n    \n    float thickness = res.x / 5.0;\n    vec2 rect_disp = vec2(10.0, thickness * 0.8);\n    \n    //simple rot rect\n    d = sdf_rot_rect(point, rect_center - rect_disp, rect_center + rect_disp, thickness);\n    \n    color = fill(color, rect_color, 0.0, d);\n    color = outline(color, outline_color, outline_width, d);\n    \n    //round rot rect\n    rect_color = rect_color.brg;\n    rect_center.x += rect_zone.x;\n    rect_disp.x *= -1.0;\n    \n    d = sdf_round_rot_rect(point, rect_center - rect_disp, rect_center + rect_disp, thickness, rect_radius);\n    rect_disp.x *= -1.0;\n    \n    color = fill(color, rect_color, 0.0, d);\n    color = outline(color, outline_color, outline_width, d);\n    \n    //draw mouse\n    if (iMouse.z > 0.001) //if MLB down\n    {\n        color = mouse(color, point);\n        \n        //draw circle difference thing to closest rect\n        vec2 diff = iMouse.xy;\n        \n        rect_center = rect_zone / 2.0;\n        d = sdf_rot_rect(diff, rect_center - rect_disp, rect_center + rect_disp, thickness);\n        \n        rect_center.x += rect_zone.x;\n        rect_disp.x *= -1.0;\n        d = min(d, sdf_round_rot_rect(diff, rect_center - rect_disp, rect_center + rect_disp, thickness, rect_radius));\n        rect_disp.x *= -1.0;\n        \n        d = sdf_circle(point - diff, abs(d));\n        color = outline(color, outline_color, outline_width, d);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\nvoid mainImageCoolS(out vec4 fragColor, in vec2 point)\n{\n    vec2 res = iResolution.xy;\n    vec3 background = get_background_color(point);\n    vec3 color = background;\n    vec2 center = res / 2.0;\n    float d;\n    \n    vec3 cool_color = 1.0 - background.brg;\n    float scale = 1.0 / min(res.x, res.y) / 0.4;\n    \n    //sdf_cool_s has a werid sdf, so we use a scalor to keep things managable\n    \n    d = sdf_cool_s((point - center) * scale);\n    \n    color = fill(color, cool_color, 0.0, d);\n    color = outline(color, outline_color, outline_width * scale, d);\n    \n    //draw mouse\n    if (iMouse.z > 0.001) //if MLB down\n    {\n        color = mouse(color, point);\n        \n        //draw difference thing\n        vec2 diff = iMouse.xy;\n        \n        d = sdf_cool_s((diff - center) * scale);\n        \n        d = sdf_circle((point - diff) * scale, abs(d));\n        color = outline(color, outline_color, outline_width * scale, d);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n\nvoid mainImageBlendAddCircles(out vec4 fragColor, in vec2 point)\n{\n    vec2 res = iResolution.xy;\n    vec3 color = black;\n    \n    vec2 center = res.xy / 2.0;\n    float radius = res.y / 3.5;\n    \n    vec2 offset = vec2(res.x / 10.0, res.y / 6.0);\n    \n    float d1 = sdf_circle(point - center + vec2(offset.x, offset.y), radius);\n    color = fill(color, blend_add(red, color), 0.0, d1);\n    \n    float d2 = sdf_circle(point - center + vec2(-offset.x, offset.y), radius);\n    color = fill(color, blend_add(green, color), 0.0, d2);\n    \n    float d3 = sdf_circle(point - center + vec2(0.0, -offset.y), radius);\n    color = fill(color, blend_add(blue, color), 0.0, d3);\n    \n    color = outline(color, outline_color, outline_width, d1);\n    color = outline(color, outline_color, outline_width, d2);\n    color = outline(color, outline_color, outline_width, d3);\n    \n    fragColor = vec4(color, 1.0);\n}\n\nvoid mainImageBlendMultCircles(out vec4 fragColor, in vec2 point)\n{\n    vec2 res = iResolution.xy;\n    vec3 color = white;\n    \n    vec2 center = res.xy / 2.0;\n    float radius = res.y / 3.5;\n    \n    vec2 offset = vec2(res.x / 10.0, res.y / 6.0);\n    \n    float d1 = sdf_circle(point - center + vec2(offset.x, -offset.y), radius);\n    color = fill(color, blend_mult(yellow, color), 0.0, d1);\n    \n    float d2 = sdf_circle(point - center + vec2(-offset.x, -offset.y), radius);\n    color = fill(color, blend_mult(cyan, color), 0.0, d2);\n    \n    float d3 = sdf_circle(point - center + vec2(0.0, offset.y), radius);\n    color = fill(color, blend_mult(magenta, color), 0.0, d3);\n    \n    color = outline(color, outline_color, outline_width, d1);\n    color = outline(color, outline_color, outline_width, d2);\n    color = outline(color, outline_color, outline_width, d3);\n    \n    fragColor = vec4(color, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    mainImageCircle(fragColor, fragCoord);\n    //mainImageRect(fragColor, fragCoord);\n    //mainImageRotRect(fragColor, fragCoord);\n    //mainImageCoolS(fragColor, fragCoord);\n    //mainImageBlendAddCircles(fragColor, fragCoord);\n    //mainImageBlendMultCircles(fragColor, fragCoord);\n}","name":"Image","description":"","type":"image"}]}