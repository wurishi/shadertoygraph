{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"precision highp float;\n\n#define time iTime\n#define resolution iResolution.xy\n\nstruct Ray\n{\n\tfloat t;\n\tint id;\n};\n\nstruct Sphere\n{\n\tvec3 pos;\n   \tvec3 ambient;\n   \tvec3 diffuse;\n    vec3 angle;\n\tfloat radius;\n} ball;\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rotate(vec3 p, int axis, float angle)\n{\n \tif(axis < 0 || axis > 2)\n\t\treturn p;\n    float c = cos(angle);\n    float s = sin(angle);\n    mat3 m;\n    //X axis\n    if(axis == 0)\n    {\n        m[0] = vec3(1.0,0.0,0.0);\n        m[1] = vec3(0.0,c,s);\n        m[2] = vec3(0.0,-s,c);\n    }\n    //Y axis\n    else if (axis == 1)\n    {\n        m[0] = vec3(c,0.0,-s);\n        m[1] = vec3(0.0,1.0,0.0);\n        m[2] = vec3(s,0.0,c);\n    }\n    //Z axis\n    else if (axis == 2)\n    {\n        m[0] = vec3(c,-s,0.0);\n        m[1] = vec3(s,c,0.0);\n        m[2] = vec3(0.0,0.0,1.0);\n    }\n    return m*p;\n}\n\nvec3 rotateAroundPoint(vec3 p, vec3 o, int axis, float angle)\n{\n \treturn rotate(p-o,axis,angle)+o;   \n}\n\nvec2 transform(vec2 p)\n{\n \tp = -1.0+2.0*p/resolution.xy;\n    p.x *= resolution.x/resolution.y;\n    return p;\n}\n\nvec3 cSphere(vec3 pos, Sphere sph)\n{\n\tvec3 col = sph.ambient;\n\tfloat a = atan(pos.z-sph.pos.z,pos.y-sph.pos.y);\n    \n    for(int i = 0; i < 2; i++)\n    \tpos = rotateAroundPoint(pos,sph.pos,i,sph.angle[i]);\n\n\n\tfloat d = pos.x-sph.pos.x;\n    float e = pos.y-sph.pos.y;\n\n\tvec3 p = pos-sph.pos;\n    //Ball curve, not perfect but looks good\n\tbool b = abs(p.x*p.x - sin(p.z)*2.0 - p.y*p.y/3.0) < sph.radius*0.1;\n\tif(b)\n\t\tcol = vec3(1.0);\n\n\treturn col;\n}\n\nvec3 nSphere(vec3 pos, Sphere sph)\n{\n    return (pos-sph.pos)/sph.radius;\n}\n\nfloat iSphere(vec3 ro, vec3 rd, Sphere sph)\n{\n \tvec3 oc = ro - sph.pos;\n    float b = 2.0*dot(oc,rd);\n    float c = dot(oc,oc) - sph.radius*sph.radius;\n    float h = b*b - 4.0*c;\n    if(h < 0.0) return -1.0;\n    float t = (-b - sqrt(h))/2.0;\n    return t;\n}\n\nvec3 nPlane(vec3 pos)\n{\n \treturn vec3(0.0,1.0,0.0);\n}\n\nfloat iPlane(vec3 ro, vec3 rd)\n{\n \treturn -ro.y/rd.y;\n}\n\nRay intersect(vec3 ro,vec3 rd)\n{\n\tRay ray;\n    ray.t = 1000.0;\n    ray.id = -1;\n    float id = -1.0;\n \tfloat tsph = iSphere(ro,rd, ball);\n    float tpla = iPlane(ro,rd);\n\n    if(tsph > 0.0)\n    {\n        ray.id = 1;\n        ray.t = tsph;\n    }\n    if( tpla > 0.0 && tpla < ray.t)\n    {\n        ray.id = 2;\n        ray.t = tpla;\n    }\n\n    return ray;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 mouse = transform(iMouse.xy);\n    \n\tball.pos = vec3(0.0,6.0,5.0);\n    ball.radius = 2.0;\n\tball.diffuse = vec3(0.7,0.8,0.1);\n    ball.ambient = vec3(0.4,0.6,0.1);\n\tball.angle = vec3(time*1.35,time*3.0,time*0.5);\n    //ball.angle = vec3(mouse.y,-mouse.x,0.0);\n    \n    vec3 light = normalize(vec3(0.57703));\n\n\tvec2 p = transform(fragCoord.xy);\n\n    ball.pos.x = 3.5*cos(time);\n    ball.pos.y = ball.radius+abs(cos(time*2.5)*5.5);\n    ball.pos.z = -3.0+6.5*sin(time);\n    \n    vec3 col = vec3(0.5, 0.4, 0.1);\n\n    vec3 ro = vec3(0.0, 5.0, 12.0);\n    vec3 rd = normalize(vec3(p, -1.0));\n\n    float t;\n    Ray ray = intersect(ro,rd);\n    vec3 pos = ro + ray.t*rd;\n    if( ray.id == 1)\n    {\n\n        vec3 nor = nSphere(pos, ball);\n        float dif = clamp(dot(nor, light),0.0,1.0);\n        float ao = 0.5 + 0.5*nor.y;\n        vec3 amb = cSphere(pos, ball);\n     \tcol = ball.diffuse*dif + amb;\n        col *= ao;\n    }\n    else if( ray.id == 2)\n    {\n        vec3 nor = nPlane(pos);\n        float dif = clamp(dot(nor,light),0.0,1.0);\n     \tfloat amb = smoothstep(0.0,ball.radius*ball.radius/ball.pos.y,length(pos.xz-ball.pos.xz));\n        col = vec3(0.0,0.6,0.9)*amb;\n    }\n    col = sqrt(col);\n\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4djSWz","date":"1410952659","viewed":685,"name":"tennis ball","username":"nexor","description":"A rotating, bouncing tennis ball based on iq's shader tutorial.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["ball","curve","rotation"],"hasliked":0,"parentid":"","parentname":""}}