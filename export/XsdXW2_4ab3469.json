{"ver":"0.1","info":{"id":"XsdXW2","date":"1461586899","viewed":253,"name":"just boxes - my first raymarcher","username":"Marqin","description":"My first raymarcher. With dynamic light, shadows and MSAA.\n\nIf you have low FPS, comment out:\n#define MSAA_4rays\n\ntutorials I've used:\n* http://9bitscience.blogspot.com/2013/07/raymarching-distance-fields_14.html\n* http://iquilezles.org/","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MaximumRaySteps = 128;\nconst float MinimumDistance = 0.00001;\n\n// comment this to disable MSAA:\n#define MSAA_4rays\n\nstruct Ray {\n\tvec3 origin;\n    vec3 direction;\n};\n    \nfloat sdPlane( vec3 p ) {\n\treturn p.y;\n}\n\nfloat sdBox( vec3 boxpos, vec3 p, vec3 b ) {\n    p -= boxpos;\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat boxLine( vec3 point, float z ) {\n    \n    float bsize = 0.5;\n    \n    vec3 box = vec3(0., bsize, z);\n    \n    float dist = sdBox(box, point, vec3(bsize));\n    \n    for( float i = 1.; i < 4.; i++ ) {\n        vec3 npos = vec3(box.x + i*2.*(bsize+0.05), box.y, box.z);\n        float newBox = sdBox(npos, point, vec3(bsize));\n        dist = min(dist, newBox);\n    }\n    \n    return dist;\n}\n\nfloat DistanceEstimator( vec3 point ) {\n    \n    float dist = min(boxLine(point, 0.), boxLine(point, 2.5));\n\n    return min(dist, sdPlane(point));\n}\n\n\nmat3 lookAt( vec3 origin, vec3 direction, float roll ) {\n    vec3 ww = normalize(direction);\n\tvec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll),0.0)));\n\tvec3 vv = normalize(cross(uu, ww));\n    return mat3( uu, vv, ww );\n}\n\nvec3 getNormal( in vec3 pos ) {\n// from iq\n\tvec3 eps = vec3( MinimumDistance, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    DistanceEstimator(pos+eps.xyy) - DistanceEstimator(pos-eps.xyy),\n\t    DistanceEstimator(pos+eps.yxy) - DistanceEstimator(pos-eps.yxy),\n\t    DistanceEstimator(pos+eps.yyx) - DistanceEstimator(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\n\nconst float k = 32.;\n\nfloat shadow( Ray r ) {\n    float dist = 2.*MinimumDistance;\n    float sh = 1.0;\n\tfor( int i = 0; i < MaximumRaySteps; i++ ) {\n        vec3 newLocation = r.origin + dist * r.direction;\n\t\tfloat h = DistanceEstimator(newLocation);\n        if( h < MinimumDistance || dist > 10.)\n            return sh;\n        sh = min( sh, 32.*h/dist );\n        dist += h;\n    }\n    return sh;\n}\n\nvec3 shade(vec3 p) {\n    vec3 lightColor = vec3(0.9, 0.99, 0.99);\n\n    vec3 lightDir = normalize(vec3(sin(iTime/1.0), 0.6, -0.3));\n\n    \n    vec3 normal = getNormal(p);\n    vec3 light = lightColor * dot(normal, lightDir);\n   \n    return light* shadow(Ray(p, normalize(lightDir)));\n}\n\n\nvec3 trace( Ray r ) {\n\tfloat totalDistance = 0.0;\n    \n    float colour = 0.8;\n    \n\tfor( int i = 0; i < MaximumRaySteps; i++ ) {\n\t\tvec3 newLocation = r.origin + totalDistance * r.direction;\n\t\tfloat distance = DistanceEstimator(newLocation);\n\t\ttotalDistance += distance;\n        if( distance < MinimumDistance ) {\n            if( newLocation.y <= MinimumDistance )\n            \tcolour = 1.0;\n        \tbreak;\n        }\n\t}\n   \n    return colour*shade(r.origin + totalDistance* r.direction);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n\n    vec2 uv = 2.*gl_FragCoord.xy/iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n        \n    vec3 cam = vec3(2.*sin(iTime/1.5) - 1.0, 3, -3.);\n        \n    vec3 dir = vec3(1.,0.,0.) - cam;\n    \t\n    \n    mat3 cameraMatrix = lookAt( cam, dir, 0.0 );\n    vec3 rd = normalize(lookAt( cam, dir, 0.0 ) * vec3(uv,2.0));\n\n\n    vec2 uvNext = 2.*(gl_FragCoord.xy+vec2(1.,1.))/iResolution.xy - 1.0;\n    uvNext.x *= iResolution.x/iResolution.y;\n    \n    vec2 uvDiff = uvNext - uv;\n    uvDiff /= 3.;\n\n\n    vec3 sum = vec3(0.0);\n    vec3 rd1 = normalize(cameraMatrix * vec3(uv+ vec2( 1.0 * uvDiff.x, 1.0 * uvDiff.y),2.0));\n //   vec3 rd2 = normalize(cameraMatrix * vec3(uv+ vec2( 1.0 * uvDiff.x, 0.0 * uvDiff.y),2.0));\n    vec3 rd3 = normalize(cameraMatrix * vec3(uv+ vec2( 1.0 * uvDiff.x,-1.0 * uvDiff.y),2.0));\n //   vec3 rd4 = normalize(cameraMatrix * vec3(uv+ vec2( 0.0 * uvDiff.x, 1.0 * uvDiff.y),2.0));\n    vec3 rd5 = normalize(cameraMatrix * vec3(uv+ vec2( 0.0 * uvDiff.x, 0.0 * uvDiff.y),2.0));\n //   vec3 rd6 = normalize(cameraMatrix * vec3(uv+ vec2( 0.0 * uvDiff.x,-1.0 * uvDiff.y),2.0));\n    vec3 rd7 = normalize(cameraMatrix * vec3(uv+ vec2(-1.0 * uvDiff.x, 1.0 * uvDiff.y),2.0));\n //   vec3 rd8 = normalize(cameraMatrix * vec3(uv+ vec2(-1.0 * uvDiff.x, 0.0 * uvDiff.y),2.0));\n    vec3 rd9 = normalize(cameraMatrix * vec3(uv+ vec2(-1.0 * uvDiff.x,-1.0 * uvDiff.y),2.0));\n\n    \n    float nr = 1.;\n   // sum += trace(Ray(cam, rd5));   \n#ifdef MSAA_4rays\n    nr = 4.;\n    sum += trace(Ray(cam, rd1));\n    sum += trace(Ray(cam, rd3));\n    sum += trace(Ray(cam, rd7));\n    sum += trace(Ray(cam, rd9));\n#else\n    sum += trace(Ray(cam, rd5));\n#endif\n   \n    vec3 gr = sum/nr;\n    \n    fragColor = vec4(gr, 1.0);\n}","name":"Image","description":"","type":"image"}]}