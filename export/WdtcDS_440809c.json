{"ver":"0.1","info":{"id":"WdtcDS","date":"1602263961","viewed":89,"name":"Eli's Path Tracer","username":"SNAKFRIEN","description":"Triangle?","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.1415926538;\nconst float epsilon = 0.001;\n\nconst int nSpheres = 20;\nconst int nSamples = 8;\nconst int maxDepth = 4;\n\nconst int lightIndex = 0;\n\nvec2 NewSeed(vec2 seed)\n{\n\treturn seed += 0.1;\n}\n\nfloat repeatRand(inout vec2 seed)\n{\n\tseed = NewSeed(seed);\n\treturn fract(sin(dot(seed.xy ,vec2(12.3215,78.233))) * 9.5453);\n}\n\nvec2 repeatRand2(inout vec2 seed)\n{\n\tseed = NewSeed(seed);\n\treturn vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n\t\t\t\tfract(sin(dot(seed.xy ,vec2(35431.1234,45.567))) * 15454.5675));\n}\n\nvec3 repeatRand3(inout vec2 seed)\n{\n\tseed = NewSeed(seed);\n\treturn vec3(fract(sin(dot(seed.xy ,vec2(1334.9898,128.233))) * 7.5453),\n\t\t\t\tfract(sin(dot(seed.xy ,vec2(1342.1234,45.567))) * 53.5675), \n\t\t\t\tfract(sin(dot(seed.xy ,vec2(5904.2344,2.244))) * 234.6451));\n}\n\nfloat SameRand(vec2 seed)\n{\n\treturn fract(sin(dot(seed.xy ,vec2(12.3215,78.233))) * 9.5453);\n}\n\nvec3 SameRand3(vec2 seed)\n{\n\treturn vec3(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n\t\t\t\tfract(sin(dot(seed.xy ,vec2(1.1234,45.567))) * 23454.5675), \n\t\t\t\tfract(sin(dot(seed.xy ,vec2(56.2344,23.244))) * 46442.6451));\n}\n\nstruct Material\n{\n\tvec3 albedo;\n\tvec3 emission;\n\tint type; //0 = diffuse, 1 = specular, 2 = refractive\n\t\n};\n\nstruct Sphere\n{\n\tvec3 pos;\n\tfloat radius;\n\tMaterial material;\n};\n\nstruct Intersection\n{\n\tbool isFound;\n\tfloat dist;\n\tvec3 pos;\n\tMaterial material;\n\tvec3 normal;\n};\n\nvec3 GenerateRayDirection(vec2 uv, vec2 seed)\n{\n\tvec2 pixelScale = 1.0 / iResolution.xy;\n\tfloat xOffset = repeatRand(seed) * pixelScale.x;\n\tfloat yOffset = repeatRand(seed) * pixelScale.y;\n\treturn normalize(vec3(uv.x + xOffset, uv.y + yOffset, 1));\n}\n\nvoid GenerateSpheres(inout Sphere spheres[nSpheres])\n{\n\tvec2 seed = vec2(2);\n\tfor(int i = 0; i < nSpheres; i++)\n\t{\n\t\tspheres[i].pos = SameRand3(seed);\n\t\tspheres[i].pos.x = (spheres[i].pos.x - 0.5) * 10.0;\n\t\tspheres[i].pos.y = (spheres[i].pos.y - 0.5) * 5.0 * sin(iTime * 1.1234 * SameRand(vec2(float(i)))) - 3.;\n\t\tspheres[i].pos.z = spheres[i].pos.z * 20.0 + 5.0;\n\t\tif(false) //toggle side view\n\t\t{\n\t\t\tfloat temp = spheres[i].pos.x;\n\t\t\tspheres[i].pos.x = spheres[i].pos.y;\n\t\t\tspheres[i].pos.y = temp;\n\t\t}\n\t\t\n\t\tspheres[i].radius = 1.0;\n\t\tMaterial m;\n\t\tm.albedo = repeatRand3(seed) * 0.5 + 0.5;\n\t\tm.emission = vec3(0);\n\t\tspheres[i].material = m;\n\t}\n\t//Add light source\n\tspheres[lightIndex].pos = vec3(sin(iTime) * 2.0, 3.0, 15.0 + cos(iTime) * 2.0);\n\t//spheres[lightIndex].pos = vec3(0.0, 4.0, 15.0);\n\tspheres[lightIndex].material.emission = vec3(1);\n\tspheres[lightIndex].radius = 1.0;\n\t//Add walls\n\tspheres[5].pos = vec3(1000, 0, 0);\n\tspheres[5].radius = 995.0;\n\tspheres[5].material.albedo = vec3(0.9, 0, 0);\n\t\n\tspheres[4].pos = vec3(-1000, 0, 0);\n\tspheres[4].radius = 995.0;\n\tspheres[4].material.albedo = vec3(0, 0.9, 0);\n\t\n\tspheres[3].pos = vec3(0, 1000, 0);\n\tspheres[3].radius = 995.0;\n\tspheres[3].material.albedo = vec3(0.9, 0.9, 0.9);\n\t\n\tspheres[2].pos = vec3(0, -1000, 0);\n\tspheres[2].radius = 995.0;\n\tspheres[2].material.albedo = vec3(0.9, 0.9, 0.9);\n\n\tspheres[1].pos = vec3(0, 0, 1000);\n\tspheres[1].radius = 970.0;\n\tspheres[1].material.albedo = vec3(0.9, 0.9, 0.9);\n}\n\nvoid MakeOrthonormal(vec3 v1, inout vec3 v2, inout vec3 v3)\n{\n\tif(abs(v1.x) > abs(v1.y))\n\t{\n\t\t//Project to the y = 0 plane and construct a normalized orthogonal vector in this plane\n\t\tfloat invertedLength = 1.0 / sqrt(v1.x * v1.x + v1.z * v1.z);\n\t\tv2 = vec3(-v1.z * invertedLength, 0.0, v1.x * invertedLength);\n\t}\n\telse\n\t{\n\t\t//Project to the x = 0 plane and construct a normalized orthogonal vector in this plane\n\t\tfloat invertedLength = 1.0 / sqrt(v1.y * v1.y + v1.z * v1.z);\n\t\tv2 = vec3(0.0, v1.z * invertedLength, -v1.y * invertedLength);\n\t}\n\tv3 = cross(v1, v2);\n}\n\nvec3 HemisphereDirection(vec2 uv)\t//Projects flat points onto a hemisphere\n{\n\tfloat r = sqrt(1.0 - uv.x * uv.x);\n\tfloat phi = 2.0 * PI * uv.y;\n\treturn vec3(cos(phi) * r, sin(phi) * r, uv.x);\n}\n\nvec3 RandomSpherePoint(inout vec2 seed, float radius)\n{\n\twhile(true)\n\t{\n\t\tvec3 result = repeatRand3(seed);\n\t\tresult * radius;\n\t\tif(length(result) < radius)\n\t\t{\n\t\t\treturn result;\n\t\t}\n\t}\n}\n\nvec3 RandomSphereDirection(inout vec2 seed) {\n    vec2 h = repeatRand2(seed) * vec2(2.,6.28318530718)-vec2(1,0);\n    float phi = h.y;\n\treturn vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\n}\n\nbool TraceLightRay(vec3 rayOrigin, inout Sphere spheres[nSpheres], inout vec2 seed)\n{\n\tvec3 randomLightPoint = RandomSphereDirection(seed) * spheres[lightIndex].radius + spheres[lightIndex].pos;\n\tvec3 rayDirection = normalize(randomLightPoint - rayOrigin);\n\tint intersectionIndex = 1000;\n\tfloat closestDistance = 5000.0;\n\tfor(int i = 0; i < nSpheres; i++)\n\t{\n\t\tfloat t = dot(spheres[i].pos - rayOrigin, rayDirection);\n\t\tvec3 p = rayOrigin + rayDirection * t;\n\t\tfloat y = length(spheres[i].pos - p);\n\t\tif(y < spheres[i].radius)\n\t\t{\n\t\t\tfloat x = sqrt(spheres[i].radius * spheres[i].radius - y * y);\n\t\t\tfloat t1 = t - x;\n\t\t\tfloat t2 = t + x;\n\t\t   \tfloat dist;\n\t\t\tif(t1 < epsilon)\n\t\t\t{\n\t\t\t\tdist = t2;\n\t\t\t}\n\t\t\telse if(t2 < epsilon)\n\t\t\t{\n\t\t\t\tdist = t1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdist = min(t1, t2);\n\t\t\t}\n\t\t\tif(dist < closestDistance && dist > epsilon)\n\t\t\t{\n\t\t\t\tintersectionIndex = i;\n\t\t\t\tclosestDistance = dist;\n\t\t\t}\n\t\t}\n\t}\n\treturn intersectionIndex == lightIndex;\n}\n\nvec3 TraceRay(vec3 rayOrigin, vec3 rayDirection, vec2 uv, int depth, inout vec2 seed, bool justAlbedo)\n{\n\tSphere spheres[nSpheres];\n\tGenerateSpheres(spheres);\n\n\tvec3 result = vec3(0);//0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0, 2, 4));\n\tvec3 collectedAlbedo[maxDepth];\n\tvec3 collectedEmission[maxDepth];\n\tvec3 collectedIncomingLight[maxDepth]; //Collects incoming light from the light source at this poin\n\n\tfor(int i; i < maxDepth; i++)\n\t{\n\t\tIntersection intersection;\n\t\tintersection.dist = 5000.0;\n\t\tintersection.isFound = false;\n\n\t\tfor(int j = 0; j < nSpheres; j++)\n\t\t{\n\t\t\t//Calculate collision with sphere\n\t\t\tfloat t = dot(spheres[j].pos - rayOrigin, rayDirection);\n\t\t\tvec3 p = rayOrigin + rayDirection * t;\n\t\t\tfloat y = length(spheres[j].pos - p);\n\t\t\tif(y < spheres[j].radius)\n\t\t\t{\n\t\t\t\tfloat x = sqrt(spheres[j].radius * spheres[j].radius - y * y);\n\t\t\t\tfloat t1 = t - x;\n\t\t\t\tfloat t2 = t + x;\n\t\t\t   \tfloat dist = min(t1, t2);\n\t\t\t\tif(dist < intersection.dist && dist > epsilon)\n\t\t\t\t{\n\t\t\t\t\tvec3 intersectionPoint = rayOrigin + rayDirection * dist;\n\t\t\t\t\tintersection.isFound = true;\n\t\t\t\t\tintersection.dist = dist;\n\t\t\t\t\tintersection.pos = intersectionPoint;\n\t\t\t\t\tintersection.material = spheres[j].material;\n\t\t\t\t\tintersection.normal = normalize(intersectionPoint - spheres[j].pos);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(intersection.isFound)\n\t\t{\n\t\t\tMaterial m = intersection.material;\n\t\t\tif(justAlbedo)\n\t\t\t{\n\t\t\t\tif(TraceLightRay(intersection.pos, spheres, seed))\n\t\t\t\t{\n\t\t\t\t\treturn m.albedo;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn m.albedo * 0.2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Calculate direction for next ray\n\t\t\tvec3 rotationX;\n\t\t\tvec3 rotationY;\n\t\t\tMakeOrthonormal(intersection.normal, rotationX, rotationY);\n\t\t\tvec3 sampleDirection = HemisphereDirection(repeatRand2(seed));\n\t\t\tvec3 rotatedDirection;\n\t\t\trotatedDirection.x = dot(vec3(rotationX.x, rotationY.x, intersection.normal.x), sampleDirection);\n\t\t\trotatedDirection.y = dot(vec3(rotationX.y, rotationY.y, intersection.normal.y), sampleDirection);\n\t\t\trotatedDirection.z = dot(vec3(rotationX.z, rotationY.z, intersection.normal.z), sampleDirection);\n\t\t\tfloat cosTerm = dot(rotatedDirection, intersection.normal);\n\n\t\t\t//Set up next ray\n\t\t\trayOrigin = intersection.pos;\n\t\t\trayDirection = rotatedDirection;//sampleDirection;\n\n\t\t\t//Store emitted light and albedo for current ray\n\t\t\tcollectedAlbedo[i] = m.albedo * cosTerm;\n\t\t\tcollectedEmission[i] = m.emission * 2.0; //2.0 to account for lack of infinite light bounces\n\n\t\t\t//Direct light sampling\n\t\t\tif(TraceLightRay(intersection.pos, spheres, seed))\n\t\t\t{\n\t\t\t\tcollectedIncomingLight[i] = spheres[lightIndex].material.emission;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcollectedIncomingLight[i] = vec3(0.0);\n\t\t\t}\n\t\t}\n\t}\n\n\t//Get light from the final bounce\n\tvec3 transmittedRadiance = vec3(0.0);//vec3(0.3);//collectedEmission[maxDepth - 1];\n\t//Apply reflected light in reverse order\n\tfor(int i = maxDepth - 1; i >= 0; i--)\n\t{\n\t\ttransmittedRadiance = collectedEmission[i] + collectedAlbedo[i] * transmittedRadiance + collectedAlbedo[i] * collectedIncomingLight[i];\n\t}\n\t\n\treturn result = transmittedRadiance;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\t\n\tvec2 seed = uv * PI * fract(1.12345314312*iTime);\n\n\tvec3 col = vec3(0);\n\t\n\tbool justAlbedo;\n\tif(sin(iTime * 1.1) < 0.0)\n\t{\n\t\tjustAlbedo = true;\n\t}\n\telse\n\t{\n\t\tjustAlbedo = false;\n\t}\n\n\t//Trace ray through scene to retrieve color for current pixel\n\tfor(int i = 0; i < nSamples; i++)\n\t{\n\t\t//Generate ray\n\t\tvec3 rayOrigin = vec3(0);\n\t\tvec3 rayDirection = GenerateRayDirection(uv, seed);\n\t\tcol += TraceRay(rayOrigin, rayDirection, uv, 0, seed, justAlbedo);\n\t}\n\t\n\tcol /= float(nSamples);\n\t\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}