{"ver":"0.1","info":{"id":"3sc3Wn","date":"1568225305","viewed":134,"name":"Julia Monster World","username":"96logda","description":"All monsters in this shader are made by using Julia fractal algorithm in a quite different way then usual.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","julia","monster"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Copyright (c) 2019-09-10 - 2019-09-11 by Angelo Logahd\n//Portfolio: https://angelologahd.wixsite.com/portfolio\n\n#define SHADER_1 0\n#define SHADER_2 1\n#define SHADER_3 2\n#define SHADER_4 3\n#define SHADER_5 4\n#define SHADER_6 5\n\n#define SHADER_TYPE SHADER_5\n\n#if SHADER_TYPE == SHADER_3\nconst vec2  juliaC = vec2(0.395, 0.2935);\n#elif SHADER_TYPE == SHADER_5\nconst vec2  juliaC = vec2(0.395, 0.2985);\n#else\nconst vec2  juliaC = vec2(0.4, 0.3);\n#endif\n\nvec2 complexZ(const in vec2 z)\n{\n    return mat2(z, -z.y, z.x) * z;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy - iResolution.xy * 0.5;\n\tuv *= 2.0 / min(iResolution.x, iResolution.y);\n    \n    uv.x += 1.15;\n    uv.y -= 0.3;\n    \n    vec3 col = vec3(0.0);\n    vec2 z = uv * 0.5;   \n    int count = 0;\n\tfor (; count < 4; ++count) \n    {\n \t\tz = complexZ(z) - juliaC;\n        z = complexZ(z) + juliaC;\n        z = complexZ(z) + juliaC;\n        z = complexZ(z) + juliaC;\n        \n        z = complexZ(z) - juliaC;\n        z = complexZ(z) - juliaC;\n        z = complexZ(z) - juliaC;\n        z = complexZ(z) - juliaC;\n        \n        #if SHADER_TYPE == SHADER_6\n        z = complexZ(z) - juliaC;\n        #endif\n        \n        #if SHADER_TYPE == SHADER_2\n        z = abs(z);\n        #endif\n        \n        if (dot(z, z) > 2.0)\n        {\n            break;\n \t\t} \n    }\n    \n    #if SHADER_TYPE == SHADER_5 || SHADER_TYPE == SHADER_6\n    for (; count < 4; ++count) \n    {\n        z = complexZ(z) - juliaC;\n        z = complexZ(z) + juliaC;\n        \n        if (dot(z, z) > 2.0)\n        {\n            break;\n \t\t} \n    }\n    #endif\n    \n    col = texture(iChannel1, uv * 2.0).rgb / texture(iChannel0, uv).rgb;\n    #if SHADER_TYPE == SHADER_4\n    col += z.x * 0.1 * z.y * 0.1;\n    #endif\n    #if SHADER_TYPE == SHADER_5\n    col *= 0.25;\n    #endif\n    \n    float d = abs(dot(z, vec2(0.5)));\n    col -= step(d, 2.0);\n    col = mix(col, vec3(1.0, 1.0, 1.0), 0.7);\n    \n    vec2 texUV = vec2(float(count));\n    texUV /= 100.0;\n\n    fragColor.rgb = texture(iChannel0, texUV).rgb * vec3(0.5, 1.0, 1.0) - col;\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.4545));\n    fragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"}]}