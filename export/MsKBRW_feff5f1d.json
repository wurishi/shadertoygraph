{"ver":"0.1","info":{"id":"MsKBRW","date":"1528113945","viewed":770,"name":"Glitch Texture","username":"TekF","description":"Glitchy abstract designs, for applying to computer screens in another shader.","likes":9,"published":3,"flags":32,"usePreview":1,"tags":["glitch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n    \n    fragColor.rgb = pow(fragColor.rgb,vec3(1./2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Glitch Texture\n// by Hazel Quantock 2018\n// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. http://creativecommons.org/licenses/by-nc-sa/4.0/\n\n// palette\nconst vec3 bg = vec3(0);\nconst vec3 grin = vec3(0,1,.5);\nconst vec3 hot = vec3(1,0,.1);\nconst vec3 cool = vec3(.01,0,.5);\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n    \n    fragColour.rgb = bg;\n    \n    // glitch scanline\n    float scanline = fract(iTime/3.);\n    float scany = (uv.y) - 1. + scanline;\n    uv.x += .001/scany;\n    fragCoord.x += iResolution.y*.001/scany;\n    \n    // feedback effect\n    fragColour.rgb = mix(\n        fragColour.rgb,\n        texture( iChannel0, fract(1.618*vec2(1.618,1)*fragCoord/iResolution.xy + vec2(.2,.3)) ).rgb,\n        mix(cool*.9+.1,\n            mix(hot,grin+cool,fract(iTime*.2)),\n            .1+.8*pow(.5+.5*cos(iTime*1.5),20.) ) );\n    \n    // glow\n    vec4 d = vec4(-.75,.75,-.25,.25)*.005;\n    fragColour.rgb = mix(\n        fragColour.rgb,\n        (\n            texture( iChannel0, fragCoord/iResolution.xy + d.xz ).rgb +\n            texture( iChannel0, fragCoord/iResolution.xy + d.zy ).rgb +\n            texture( iChannel0, fragCoord/iResolution.xy + d.yw ).rgb +\n            texture( iChannel0, fragCoord/iResolution.xy + d.wx ).rgb\n        ) / 4.,\n        .5 );\n    \n    // binary couting block\n    ivec2 bin = ((ivec2(uv*256.)-ivec2(30))&127)>>3;// /16; // omg divide rounds upward!?\n    if ( min(bin.x,bin.y) >= 0 && max(bin.x,bin.y) < 4 )\n        //dot(step(vec4(0),vec4(bin,3-bin)),vec4(1)) == 4. ) // hahahaha this is probably not as clever as it looks\n    {\n        int bit = (bin.x&1) + 2*((bin.x&2) + (bin.y&1)) + 4*(bin.y&2);\n        //int bit = (bin.x&1)*8 + 1*((bin.x&2) + (bin.y&1)) + 2*(bin.y&2); // ooh nice\n        //int bit = (bin.y&1)*8 + 1*((bin.y&2) + (bin.x&1)) + 2*(bin.x&2); // flipped\n        //int bit = (bin.y&1)*4 + 1*((bin.x&2) + (bin.x&1)) + 4*(bin.y&2); // sequential from bottom - nice actually\n        \n        //bit = (bit^(iFrame>>4))&0xf;\n        \n        bit += 3; // slow it down\n        \n        if ( ((iFrame)&(1<<bit)) == 0 )\n\t        fragColour.rgb = grin;\n    }\n    \n    \n    vec2 tex = uv*256.-vec2(200,40);\n    if ( min(tex.x,tex.y) >= 0. && max(tex.x,tex.y) < 160. )\n    {\n        vec4 text = texture(iChannel1,(tex+iTime*8.)/200.);\n        fragColour.rgb = mix( fragColour.rgb, cool, text.x );\n    }\n    \n    fragColour.rgb = mix( hot, fragColour.rgb, smoothstep( .0/256., 2./256., abs(scany) ) );\n    \n    fragColour.a = 1.;\n}","name":"Buf A","description":"","type":"buffer"}]}