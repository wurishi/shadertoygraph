{"ver":"0.1","info":{"id":"3sy3Ry","date":"1570405767","viewed":327,"name":"Basic Advection","username":"tsuhre","description":"A basic advection algorithm utilizing reverse-lookup from the flow vector combined with a cosine blur","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["fluid","advection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 v = texture(iChannel0, fragCoord/iResolution.xy).xy;\n    fragColor = xy2hue(v);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 pixelOffset(vec2 pos, vec2 off){\n    return texture(iChannel0, (pos+off)/iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv  = fragCoord/iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    \n   \tcol = pixelOffset(fragCoord, col.xy*intensity)*fade;\n    \n    vec2 mouse = iMouse.xy;\n    if (iMouse.z <= 0.){\n        float x = (sinWave(iTime, .5)*.8 + .1)*iResolution.x;\n        float y = (sinWave(iTime, 1.)*.6 + .2)*iResolution.y;\n        mouse = vec2(x, y);\n    }\n    \n    vec2 v = fragCoord.xy - mouse;\n    if (length(v) < radius){\n        col = vec4(-v/radius, 0, 1);\n    }\n    \n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float radius = 20.;\nfloat intensity = 5.;\nfloat fade = .99;\n\nfloat pi = 3.14159265359;\n\nfloat blurRadius = 3.;\n\nfloat sinWave(float v, float m){return (sin(v*m*pi*2.)+1.)/2.;}\n\n//from https://github.com/hughsk/glsl-hsv2rgb\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 xy2hue(vec2 v){\n    float h = (atan(v.y, v.x)/(pi) + 1.)/2.;\n    float b = length(v);\n    return vec4(hsv2rgb(vec3(h, 1., b)), 1.);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n  X pass blur\n\n  uses a cosine distribution instead of the normal distribution\n  to approximate a gaussian kernel\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float r = blurRadius;\n    \n    vec4 avg   = texture(iChannel0, fragCoord/iResolution.xy);\n    float area  = 1.;\n    \n    vec2 dir = vec2(1, 0);\n    \n    for (float i = 1.; i < r; i += 1.){\n        float m = (cos(i*pi/r) + 1.)/2.;\n        area += m*2.;\n    \tavg += texture(iChannel0, (fragCoord+dir*i)/iResolution.xy)*m;\n        avg += texture(iChannel0, (fragCoord-dir*i)/iResolution.xy)*m;\n    }\n    \n    avg /= area;\n    \n    fragColor = avg;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/*\n  Y pass blur\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float r = blurRadius;\n    \n    vec4 avg   = texture(iChannel0, fragCoord/iResolution.xy);\n    float area  = 1.;\n    \n    vec2 dir = vec2(0, 1);\n    \n    for (float i = 1.; i < r; i += 1.){\n        float m = (cos(i*pi/r) + 1.)/2.;\n        area += m*2.;\n    \tavg += texture(iChannel0, (fragCoord+dir*i)/iResolution.xy)*m;\n        avg += texture(iChannel0, (fragCoord-dir*i)/iResolution.xy)*m;\n    }\n    \n    avg /= area;\n    \n    fragColor = avg;\n}","name":"Buffer C","description":"","type":"buffer"}]}