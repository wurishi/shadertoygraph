{"ver":"0.1","info":{"id":"lsGXzc","date":"1465692610","viewed":178,"name":"Texture on a sphere","username":"VoidChicken","description":"A texture on a sphere.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","texture","uv","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358979\n#define rotate(point,axiss,angle) vec3 axis = normalize(axiss);float s = sin(angle);float c = cos(angle);float oc = 1.0 - c; mat4 rot = mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0, 0.0,                                0.0,                                0.0,                                1.0); vec3 rotpoint = (vec4(point,1.)*rot).xyz\nvec2 uv (vec3 p) {\n\tfloat x = p.x;\n    float y = p.y;\n    float z = p.z;\n    float u = atan(x, z) / (2. * PI) + .5;\n    float v = asin(y) / (PI) + .5;\n    return vec2(u,v);\n}\nfloat map(vec3 r) {\n    rotate(r,vec3(0,1,0),iDate.w);\n    return length(r)-(2.);\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n    vec3 r=ro;\n    for (int i = 0; i < 128; i++) {\n        float df = map(r);\n        vec3 nr = normalize(r);\n        if (df<.01) {\n            rotate(nr,vec3(0,1,0),iDate.w);\n            vec3 val = texture(iChannel0,uv(normalize(rotpoint))).rgb;\n            return vec3(val);\n        }\n        r+=rd*df;\n    }\n    return vec3(texture(iChannel1,rd));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 hexel = 1./iResolution.xy/2.;\n    vec3 nei = vec3(0);\n    vec3 og = march(vec3(0,0,-10),vec3(uv-.5,1));\n    nei += march(vec3(0,0,-10),vec3(uv-.5+vec2(hexel.x , 0),1));\n    nei += march(vec3(0,0,-10),vec3(uv-.5+vec2(0 , hexel.y),1));\n     nei += march(vec3(0,0,-10),vec3(uv-.5-vec2(hexel.x , 0),1));\n    nei += march(vec3(0,0,-10),vec3(uv-.5-vec2(0 , hexel.y),1));\n      nei += march(vec3(0,0,-10),vec3(uv-.5+hexel,1));\n    nei += march(vec3(0,0,-10),vec3(uv-.5-hexel,1));\n    nei += march(vec3(0,0,-10),vec3(uv-.5+vec2(hexel.x,-hexel.y),1));\n    nei += march(vec3(0,0,-10),vec3(uv-.5-vec2(hexel.x,-hexel.y),1));\n\tfragColor = vec4((og+nei)/9.,1.0);\n}","name":"Image","description":"","type":"image"}]}