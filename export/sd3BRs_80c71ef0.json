{"ver":"0.1","info":{"id":"sd3BRs","date":"1657027143","viewed":186,"name":"Simple - Mandelbulb","username":"zxy_aaron","description":"Just try.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["mandelbulbfractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define LIGHTCOL vec3(1.f, 0.9f, 0.8f)\n#define O_COLOR  vec3(0.5f, 0.7f, 1.f)\n#define LIGHTDIR vec3(1.f, 1.f, 1.f)\n#define B_COLOR  vec3(0.8f, 0.7f, 0.6f)\n\nmat3 ident(){\n    return mat3(vec3(1., 0., 0.),\n                vec3(0., 1., 0.),\n                vec3(0., 0., 1.));\n}\n\nmat3 rotatorXAxis(in float dRotation){\n    return mat3(vec3(1., 0., 0),\n                vec3(0., cos(radians(dRotation)), sin(radians(dRotation))),\n                vec3(0., -sin(radians(dRotation)), cos(radians(dRotation))));\n}\n\nmat3 rotatorYAxis(in float dRotation){\n    return mat3(vec3(cos(radians(dRotation)), 0., -sin(radians(dRotation))),\n                vec3(0., 1., 0.),\n                vec3(sin(radians(dRotation)), 0., cos(radians(dRotation))));\n}\n\nfloat mandelbulb(vec3 pos){\n    vec3 v = pos;\n    vec3 c = v;\n    float n = 6.f * (sin(iTime * 0.02f) * 0.5f + 0.5f) + 2.f;\n    float dr = 1.f;\n    float nextR = length(v);\n    float r, phi, theta, iX, iY, iZ, rN;\n    \n    for(int i = 0; i < 6; i++){\n        r = length(v);\n        if(r > 3.f){\n            break;\n        }\n        phi = atan(v.y, v.x);\n        theta = acos(v.z / r) + iTime * 0.25f;\n        \n        iX = sin(n * theta) * cos(n * phi);\n        iY = sin(n * theta) * sin(n * phi);\n        iZ = cos(n * theta);\n        \n        rN = pow(r, n);\n        v = rN * vec3(iX, iY, iZ) + c;\n        \n        dr = pow(r, n - 1.f) * n * dr + 1.f;\n    }\n    \n    return 0.5f * log(r) * r / dr;\n}\n\nvec4 rayMarching(vec3 startPos, vec3 rayDir, int maxSteps){\n    vec3 curPos = startPos;\n    float curSDF = mandelbulb(curPos);\n    float depth = 0.f;\n    for(int i = 0; i < maxSteps; i++){\n        if(curSDF < 0.00000f || depth > 10.f){\n            break;\n        }\n        curPos += curSDF * rayDir;\n        depth += curSDF;\n        \n        curSDF = mandelbulb(curPos);\n    }\n    \n    return vec4(curPos, depth);\n}\n\nvec3 normal(vec3 pos){\n    vec3 offset = vec3(0.01f, 0.f, 0.f);\n    \n    return normalize(vec3(mandelbulb(pos + offset.xyz) - mandelbulb(pos - offset.xyz), \n                          mandelbulb(pos + offset.yxz) - mandelbulb(pos - offset.yxz), \n                          mandelbulb(pos + offset.yyx) - mandelbulb(pos - offset.yyx)));\n}\n\nvec3 lambert(vec3 nor){\n    vec3 lightDir = normalize(LIGHTDIR);\n    float shadow = dot(nor, lightDir) * 0.5 + 0.5;\n    \n    return shadow * O_COLOR * LIGHTCOL;\n}\n\nvec3 phong(vec3 nor,vec3 camDir){\n    vec3 lightDir = normalize(LIGHTDIR);\n    vec3 h = normalize(lightDir + camDir);\n    float gloss = 50.f;\n    vec3 phong = LIGHTCOL * O_COLOR * pow(max(dot(nor, h), 0.f), gloss);\n    \n    return phong;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 VF = (fragCoord - iResolution.xy / 2.f) / min(iResolution.x, iResolution.y);\n    vec3 dir = normalize(vec3(VF, 1.f));\n    vec3 startPos = vec3(0.f, 0.f, -3.f);\n    \n    mat3 rotator = rotatorYAxis(radians(iTime * 360.f * 5.f));\n    dir *= rotator;\n    startPos *= rotator;\n    \n    vec4 mandelbulbDate = rayMarching(startPos, dir, 255);\n    \n    vec3 nor = normal(mandelbulbDate.xyz);\n    \n    vec3 lambert = lambert(nor);\n    vec3 phong = phong(nor, -dir);\n    vec3 col = lambert + phong;\n    float background = float(mandelbulbDate.w < 10.f);\n    vec3 b_Col = (1.f - background) * B_COLOR;\n    fragColor = vec4(vec3(col * background + b_Col), 1.f);\n}","name":"Image","description":"","type":"image"}]}