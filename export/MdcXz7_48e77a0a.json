{"ver":"0.1","info":{"id":"MdcXz7","date":"1458396280","viewed":257,"name":"Additive Detuned Oscillator","username":"SolarLiner","description":"Of course it's based on the JP-8000 (or is planned to!)","likes":7,"published":1,"flags":8,"usePreview":0,"tags":["sound","oscillator","saw","supersaw"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"XsfGRr","channel":0}],"code":"#define OSCILLATOR_TYPE\t\t\t3\t\t// 0: Sine, 1: Triangle, 2: Square, 3: Sawtooth\n#define PARTIAL_COUNT\t\t\t1024.0\t// Number of added sine to form the final wave\n\nfloat Sine(float freq, float phase, float time, float vol)\n{\n    return sin(6.2831*(phase+freq*time))*vol;\n}\n\n// Additive\nfloat Oscillator(float freq, float phase, float time, float vol)\n{\n    float sound = 0.0;\n    \n    if(OSCILLATOR_TYPE==0)\n    {\n        sound = Sine(freq, phase, time, vol);\n    }\n    else if(OSCILLATOR_TYPE==1)\n    {\n        for(float i=1.;i<=PARTIAL_COUNT;i++)\n        {\n            float f = freq*(2.*i-1.0);\n            float v = (vol/pow(i,2.0));\n            \n            if(f>iSampleRate/2.0) break; // Antialias (Actually none for the JP-8000)\n            \n            sound += Sine(f, phase, time, v);\n        }\n    }\n    else if(OSCILLATOR_TYPE==2)\n    {\n        for(float i=1.; i<=PARTIAL_COUNT;i++)\n        {\n            float f = freq*(2.0*i-1.0);\n            float v = vol/(2.0*i-1.0);\n            \n            if(f>iSampleRate/2.) break; // Antialias (Actually none for the JP-8000)\n            \n            sound += Sine(f, phase, time, v);\n        }\n    }\n    else\n    {\n        for(float i=1.0;i<=PARTIAL_COUNT;i++)\n        {\n            float f = freq*i;\n            float v = vol/i;\n            \n            if(f>iSampleRate/2.0) break; // Antialias (Actually none for the JP-8000)\n            \n            sound += Sine(f, phase, time, v);\n        }\n    }\n    return sound;\n}\n\n/*\n Detuned saw (Supersaw)\nn \t\t\tNumber of oscillators\ndisp_freq\tFrequency dispersion (Hz)\ndisp_pan\tStereo detuning\ncenter_mix\tdrops the middle osc in volume\n*/\nvec2 Supersaw(float freq, float phase, float time, float vol, float disp_freq, float disp_pan, float center_mix)\n{\n    vec2 sound = vec2(0.);\n    \n    const float n = 7.0;\n    // Detune offsets (https://www.nada.kth.se/utbildning/grukth/exjobb/rapportlistor/2010/rapporter10/szabo_adam_10131.pdf)\n    float det[7];\n    det[0] =  -0.11002313;\n    det[1] = -0.06288439;\n\tdet[2] = -0.01952356;\n    det[3] = 0.0;\n    det[4] = 0.01991221;\n    det[5] = 0.06216538;\n    det[6] = 0.10745242;\n    \n    for(float i = 0.; i<n; i++)\n    {\n        float m = mod(i, 2.0)*2.0 -1.0;\n        float p = .5+ disp_pan*((i-0.5)/n)*m;\n        float f = freq + det[int(i)]*10.0*disp_freq;\n        \n        m = i==4.0?\n            1.0-center_mix :\n        \tpow(-0.73764*center_mix, 2.0) + 1.2841*center_mix;\n        \n        float s = Oscillator(f, .5+ phase+det[int(i)]*150.0, time, vol*m/n);\n        float left = clamp(1.-p,0.,.5)*2.;\n        float right = clamp(p,0.,.5)*2.;\n        \n        sound += vec2(s*left, s*right);\n    }\n    \n    return sound;\n}\n\nvec2 mainSound( in int samp, float time )\n{\n    //float freq = 80.+sin(time*6.283); // Hz;\n    float freq = 80.0;\n    float vol = exp(time*-3.0);\n    \n    return Supersaw(freq, 0., time, 0.6, 2.0, 1.0, 1.0);\n}","name":"Sound","description":"","type":"sound"}]}