{"ver":"0.1","info":{"id":"4sKcWt","date":"1523757059","viewed":341,"name":"isometricks","username":"crundle","description":"an experiment in rendering voxel grids.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","voxel","isometric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//vec2 V;\n//#define rot(a) mat2( V= sin(vec2(1.57, 0) + a), -V.y, V.x)\n#define rot(a) mat2( sin ( a+1.57*vec4(1,0,2,1) ) );\n\nvec3 getNormal(vec3 p) {\n    vec3 sub = (fract(p)-.5)*2.;\n    sub= abs(sub);\n    float y = min(step(0.,sub.y-sub.z),step(0.,sub.y-sub.x));\n    float x = min(1.-y,step(0.,sub.x-sub.z)); \n    float z = min(1.-y,1.-x);\n    return vec3(x,y,z)*sign((fract(p)-.5)*2.); //fixed for backfaces\n}\n\nfloat dist(vec3 p,vec3 dir) {\n    if(p.y>6.5) return p.y-6.5; //bail!\n    vec3 f = fract(p);\n    vec3 d = step(0.,dir); //backface\n    float d1 = dot( (d-f), vec3(0,1,0))/dot(dir,vec3(0,1,0));\n    float d2 = dot( (d-f), vec3(1,0,0))/dot(dir,vec3(1,0,0));\n    float d3 = dot( (d-f), vec3(0,0,-1))/dot(dir,vec3(0,0,-1));\n    return abs(min(d1,min(d2,d3))) ;\n}\n\nfloat getPillars(vec3 block, inout vec3 col) {\n    float cy = 1.-step(texture(iChannel0,block.xz/256.).r*12.,block.y+6.);\n    col = mix(col,vec3(.5,.5,.5),cy);\n    return cy;\n}\n\nfloat getVoxel(vec3 p,out vec3 col) {\n    vec3 block = trunc(p);\n    float fl = 1.-step(texture(iChannel0,block.xz/512.).r*6.,block.y); //works with Textures!\n    col = mix(vec3(0.6,0.5,0.3),vec3(0.4,0.6,0.2),step(4.,block.y));\n    return max(fl,getPillars(block,col));\n}\n\n//now with shadows!\nfloat shadow(vec3 pos, vec3 l) {\n    vec3 col = vec3(0.1);\n \tint maxsteps = 25;\n    vec3 p = pos; \n    float d = .01;\n    for(int steps = 0; steps<maxsteps;steps++) {\n        p = (pos+l*d);\n        float v = getVoxel(p,col);\n        if(v>.9) {\n            return 1.0;\n        }\n        d+= max(0.0001,dist(p,l));    \n    }\n    return 0.0;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x;\n\t\n    vec3 dir = normalize(vec3(1.,-.5,1.));\n\tdir.xz*=rot(sin(iTime*.025)*3.14);\n    vec3 ndx = cross(dir,vec3(0.,-1.,0.));\n    vec3 ndy = cross(dir,ndx);\n    \n    vec3 o = ndx*(uv.x*30.)+ndy*(uv.y*30.+3.)+dir*(0.);\n    o+=vec3(20.,5.,150.); //bias - things get glitchy in negative space\n    o+=vec3(iTime*4.,sin(iTime*0.2),sin(iTime*.2)*5.); \n    \n    //raymarch!\n    vec3 col = vec3(0.1);\n    float steplength = .01;\n    float steps = 0.; float maxsteps = 100.;\n    vec3 p = o; \n    float d = steplength;\n    for(steps = 0.; steps<maxsteps;steps+=1.) {\n        p = (o+dir*d);\n        float v = getVoxel(p,col);\n        if(v>.9) {\n            break;\n        }\n        steplength = max(0.0001,dist(p,dir));\n        d+=steplength;     \n    }\n    \n    vec3 light = vec3(.8,1.,0.5);\n    light.xz*=rot(iTime*0.2);\n    \n    //shading\n    float shad = shadow(p,light);\n    float shading = dot(getNormal(p),light);\n    col =col*shading*(1.-shad)+col*shading*.5*shad;\n    \n    //fake water\n    float depth = (1.-smoothstep(0.,4.,p.y));\n    col*=(1.-depth);\n    col += vec3(0.,.5,1.)*(1.-step(2.7,p.y+sin(p.x*2.-iTime*3.)*0.1+cos(p.z*3.-iTime*2.)*0.1))*depth;\n    col*=0.6+(1.-depth)*0.4;\n    \n    //col *=vec3(1.-(steps/maxsteps));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}