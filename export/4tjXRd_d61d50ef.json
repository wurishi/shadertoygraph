{"ver":"0.1","info":{"id":"4tjXRd","date":"1445941308","viewed":146,"name":"Mandelbrot transforms","username":"danim","description":"Applying some affine transforms (just translation and scale).\nKeep pressed MLB in order to center the visualization at mouse position.\nYou can tweak zoom parameters animation or just a static zoom.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rn","filepath":"/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","previewfilepath":"/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","type":"music","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define PI 3.1415926535\n#define ZOOM_SPEED 1.\n\n// no animation just zoom\n#define STATIC_ZOOM 0\n#define ZOOM_FACTOR 10.0\nmat3 T = mat3( 1. );\n\nmat3 zoomTransform( )\n{\n    float ar = iResolution.x / iResolution.y;\n    mat3 t1 = mat3( 3. / iResolution.y, 0., 0., // col 1\n                    0., 3. / iResolution.y, 0., // col 2\n                   -2. * ar, -1.5 , 1. );\t\t// col 3\n    if( iMouse.z > 0. )\n    {\n        // center it at the mouse pos\n        vec3 mousePos = t1 * vec3( iMouse.xy, 1.);\n#if !STATIC_ZOOM\n    \t// zoom-in\n        mat3 t2 = mat3( 1./(1. + iTime * ZOOM_SPEED), 0., 0.,\n                      \t0., 1./(1. + iTime * ZOOM_SPEED), 0.,\n                      \tmousePos.x, mousePos.y, 1. );\n#else\n        mat3 t2 = mat3( 1./ZOOM_FACTOR, 0., 0.,\n                      \t0., 1./ZOOM_FACTOR, 0.,\n                      \tmousePos.x, mousePos.y, 1. );\n#endif\n        T = t2 * T;\n        \n        return T * t1;\n    }\n    else\n    {\n        return T * t1;\n    }\n}\n\nmat3 scaleTransform()\n{\n    float ar = iResolution.x / iResolution.y;\n    mat3 t1 = mat3( 3. / iResolution.y, 0., 0., // col 1\n                    0., 3. / iResolution.y, 0., // col 2\n                   -2. * ar, -1.5 , 1. );\t\t// col 3\n    // some simple linear and ugly bounce\n    float s1 = sin( iTime * PI * 0.5  ); // big bounce lengths four seconds\n    float s3 = smoothstep( -0.75, 0.75, s1 );\n    \n    // little linear bounce only at the ends\n    float s4 = step( 0.75, abs( s1 ) );\n    float s2 = cos( iTime * 2. * PI * 4. ); // little bounce with more frequence\n    \n    float s5 = 1. + ( s3 * 1.15 );\n    float s6 = s2 * s4 * s5 * 0.25;\n    mat3 scalexy = mat3( 1./ ( s5 + s6 ) );\n    \n    return \tscalexy * t1;\n}\n\nmat3 heartbeatTransform()\n{\n    float ar = iResolution.x / iResolution.y;\n    mat3 t1 = mat3( 3. / iResolution.y, 0., 0., // col 1\n                    0., 3. / iResolution.y, 0., // col 2\n                   -2. * ar, -1.5 , 1. );\t\t// col 3\n    float s1 = cos( iTime * PI * 2.0 ); // 1 bpm\n    float beat = smoothstep( 0.9, 1.0, s1 );\n    \n    mat3 scalexy = mat3( 1./ ( 1. + beat ) );\n    \n    return \tscalexy * t1;\n}\n\nmat3 createTransform()\n{\n    //return heartbeatTransform();\n    return zoomTransform();\n}\n\nmat3 soundTransform( in vec2 p )\n{\n    vec4 pt = texture( iChannel0, p );\n    return mat3( 1. / ( 1. + pt.x ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // mandelbrot goes from [-2,1] in the real part and [-1,1] in the imaginary part\n    //vec2 uv;\n    //uv.x = ( 3. * fragCoord.x - 2. * iResolution.x ) / iResolution.y;\n    //uv.y = 3. * ( fragCoord.y - 0.5 * iResolution.y ) / iResolution.y;\n    vec3 uv = vec3( fragCoord, 1.0 );\n    \n    mat3 t = soundTransform( fragCoord ) * createTransform( );\n    uv = t * uv;\n    \n    vec3 black = vec3( 0 );\n    vec3 white = vec3( 1 );\n    \n    fragColor = vec4(black,1);\n    // tmp will hold Zn^2\n    vec2 tmp;\n    vec2 z = uv.xy;\n    // play with the number of its!\n    const int its = 100;\n    for( int i = 0; i < its; ++i )\n    {\n        if( length( z ) >= 4. )\n        {\n            fragColor = vec4( vec3( 1. - float(i)/float(its) ), 1 ) - texture( iChannel0, fragCoord );\n            break;\n        }\n        tmp.x = z.x * z.x - z.y * z.y;\n       \ttmp.y = 2. * z.x * z.y;\n        z = tmp + uv.xy;\n    }\n}","name":"","description":"","type":"image"}]}