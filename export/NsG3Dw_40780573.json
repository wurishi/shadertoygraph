{"ver":"0.1","info":{"id":"NsG3Dw","date":"1635167787","viewed":113,"name":"Water Searchlight","username":"itslinaaaa","description":"A watery wonderland, that isn't so watery\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n/* const matrices for 3d rotation */\nconst mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);\nconst mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);\nconst mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);\n\n/* directional artifacts can be reduced by rotating each octave */\nfloat noise(vec3 m) {\n    return   0.5333333*simplex3d(m*rot1)\n\t\t\t+0.2666667*simplex3d(2.0*m*rot2)\n\t\t\t+0.1333333*simplex3d(4.0*m*rot3)\n\t\t\t+0.0666667*simplex3d(8.0*m);\n}\n\n\n\n\n\n\n\n\n\n\nfloat planeSDF (vec3 position, vec3 start, vec3 normal ) {\n    float distance = dot( position - start, normal );\n    return distance;\n}\n\n\n\nfloat wave (float x, float y, float t) {\n    float wave = 0.3 * noise(vec3(0.3 * x - 2.1 * t, 0.5 * y,  2.0 * t))\n        ;\n        \n    return wave;\n}\n\nfloat waterSDF (vec3 position) {\n    float x = position.x;\n    float y = position.z;\n    float w = wave(position.x, position.z, iTime / 10.0);\n    vec3 pos = position + vec3(0, w, 0);\n    float floor = planeSDF(pos, vec3(0, -5, 0), vec3(0, 1, 0));\n    return floor;\n}\n\n\nfloat SDF (vec3 position) {\n    float water = waterSDF(position);\n    return water;\n}\n\n\nvec3 normal (vec3 position) {\n    float dt = 0.0001;\n    float dx = SDF(position + vec3(dt, 0, 0)) - SDF(position - vec3(dt, 0, 0));\n    float dy = SDF(position + vec3(0, dt, 0)) - SDF(position - vec3(0, dt, 0));\n    float dz = SDF(position + vec3(0, 0, dt)) - SDF(position - vec3(0, 0, dt));\n    vec3 normal = normalize(vec3(dx, dy, dz));\n    return normal;\n}\n\n\nfloat raymarch (vec3 start, vec3 direction) {\n    #define maxSteps 100\n    #define converged 0.0001\n    vec3 position = start;\n    float totalDistance = 0.0;\n    for (int i = 0; i < maxSteps; i++ ) {\n        // Step forward by the SDF distance\n        float currentDistance = SDF(position);\n        totalDistance += currentDistance;\n        position += direction * currentDistance;\n        \n        // If we are close to a surface, stop iterating\n        if ( currentDistance < converged ) break;\n    }\n    return totalDistance;\n}\n\n\nvec3 lighting ( vec3 surface ) {\n    // Define the lighting parameters\n    vec3 light = vec3(0, 2, 18) + 15.0 * vec3(cos(iTime), 0, sin(iTime));\n    float strength = 0.3;\n    vec3 specular = vec3(145, 228, 237) / 255.0;\n    vec3 diffuse = vec3(11, 45, 77) / 255.0;\n    \n    // Calculate the sphere's brightness\n    vec3 lightDelta = light - surface;\n    vec3 N = normal(surface);\n    vec3 L = normalize(lightDelta);\n    float lightDistance = raymarch(surface + 0.2 * N, L);\n    float brightness = strength * dot(N, L);\n    \n    // Add a reflection\n    \n    \n    // Add a Shadow color\n    float straightLightDistance = length(lightDelta);\n    bool occluded = straightLightDistance < 300.0\n        && straightLightDistance + 0.3 > lightDistance;\n    vec3 shadow = occluded\n        ? 1.0 * vec3(1, 1, 1)\n        : vec3(1, 1, 1);\n    \n    // Calculate the color\n\n    vec3 color = brightness * specular * shadow / pow(straightLightDistance, 2.0) * 300.0 + diffuse ;\n    return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Setup the camera and the pixel coordinates\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    vec3 start = vec3(uv, 0);\n    vec3 camera = vec3(0, 0.4, -0.3);\n    vec3 direction = normalize(start - camera);\n   \n    \n    // Get the distance to the nearest object\n    float distance = raymarch(start, direction);\n    if ( distance > 100.0 ) {\n        fragColor = vec4(17, 45, 79, 0)/255.0;\n        return;\n    }\n    \n    // Find the surface point and the corresponding normal \n    vec3 surface = start + distance * direction;\n    vec3 color = lighting(surface);\n    fragColor = vec4(color, 0.0);    \n    \n    // Output to screen\n    fragColor = vec4(color ,1.0);\n}","name":"Image","description":"","type":"image"}]}