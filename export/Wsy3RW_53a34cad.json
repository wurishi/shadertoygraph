{"ver":"0.1","info":{"id":"Wsy3RW","date":"1570557683","viewed":167,"name":"Rock planet","username":"96logda","description":"I am quite proud of this shader. :)\nI welcome all feedback.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["terrain","fbm","shadow","space","planet","bump","rock"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright (c) 2019-09-29 - 2019-10-08 by Angelo Logahd\n// Portfolio: https://www.artstation.com/angelologahd\n\n#define PI 3.14\n#define saturate(x) clamp(x, 0.0, 1.0)\n\nconst vec3 TerrainTint = vec3(0.8, 0.7, 0.4);\n\nvec2 rotate2D(vec2 p, float angle)\n{\n    float sRot = sin(angle);\n    float cRot = cos(angle);\n    return p * cRot + p.yx * sRot * vec2(-1.0, 1.0);\n}\n\nfloat fbm(in vec2 p)\n{\n    const mat2 m = mat2(0.8, -0.6, 0.6, 0.8);\n    float f = 0.0;\n    f += 0.5000 * texture(iChannel0, p / 256.0, -100.0).x; p = m * p * 2.02;\n    f += 0.2500 * texture(iChannel0, p / 256.0, -100.0).x; p = m * p * 2.03;\n    f += 0.1250 * texture(iChannel0, p / 256.0, -100.0).x; p = m * p * 2.01;\n    f += 0.0625 * texture(iChannel0, p / 256.0, -100.0).x;\n    return f / 0.9375;\n}\n\nfloat raySphere(vec3 ro, vec3 rd, vec3 spherePos, float sphereRadius)\n{\n\tvec3 occ = ro - spherePos;\n\tfloat b = dot(occ, rd);\n\tfloat c = dot(occ, occ) - sphereRadius * sphereRadius;\n\tfloat h = b * b - c;\t\n\tif (h < 0.0)\n    {\n\t\treturn -1.0;\n    }\n\treturn -b - sqrt(h);\n}\n\nvec3 getTerrainColor(in vec3 pos, in vec3 nor) \n{\n    vec3 texCol1 = texture(iChannel1, pos.xz * 0.005, -100.0).rgb;\n    vec3 texCol2 = texture(iChannel2, pos.xz * 0.005, -100.0).rgb;\n    vec3 texCol  = mix(texCol1, texCol2, 0.5);\n    return texCol * TerrainTint;\n}\n\nvec2 map(in vec3 p)\n{    \n    float mountains = fbm(p.xz * 0.073) * 20.0;\n    float rocks \t= fbm(p.xz * 8.0) * 0.2;\n    float res = p.y - 8.0 + mountains - rocks;\n    return vec2(res, 1.0);\n}\n\nvec3 calcNormal(in vec3 pos, float trace)\n{\n    vec3 eps = vec3(0.001 * trace, 0.0, 0.0); //The closer we are the more detail we will see.\n    vec3 n;\n    n.x = map(pos + eps.xyy).x - map(pos - eps.xyy).x;\n    n.y = map(pos + eps.yxy).x - map(pos - eps.yxy).x;\n    n.z = map(pos + eps.yyx).x - map(pos - eps.yyx).x;\n    return normalize(n);\n}\n\nfloat calcShadow(in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n    float t = 0.0;\n    for (int i = 0; i < 8; ++i)\n    {\n\t\tvec3 pos = ro + rd * t;\n        float h = map(pos).x;\n        res = min(res, float(8) * h / t);\n        if(res < 0.001)\n\t\t{\n\t    \tbreak;\n\t\t}\n        t += clamp(h, 0.01, 0.2);\n    }\n    return saturate(res);\n}\n\nfloat starHash(float n) \n{\n    return fract((1.0 + cos(n)) * 15.92653) * 1.35;\n}\n\nvec3 starSky(in vec2 p) \n{\n    p = p * 0.125; // Multiply with some small value to avoid flickering.\n    float starValue = fract(starHash(p.x * 37.0) + starHash(p.y * 80.0));\n    if (starValue > 0.98) \n    {\n        return vec3(pow((starValue - 0.98) / 0.02, 25.0)) * 0.5;\n    }  \n    return vec3(0.0);\n}\n\nvec3 sky(in vec2 coord, vec3 rd, vec3 light)\n{\n    vec3 col = vec3(0.0);  \n    vec3 planetPos = vec3(1.5, 1.5, -1.8);\n    float planetTrace = raySphere(vec3(0.0), rd, planetPos, 0.5);\n    if (planetTrace >= 0.0)\n    {\n        vec3 pos = planetPos;\n        vec3 normal = normalize(planetPos - planetTrace * rd);\n        \n        float lambert = saturate(dot(normal, light));\n        col = col * 0.8 + vec3(2.0, 1.0, 1.0);\n        col *= texture(iChannel0, rd.xz).rgb;\n        col *= mix(col, texture(iChannel1, rd.xz * 0.85).rgb, 0.85);  \n        col *= lambert;\n        \n        float shadow = calcShadow(pos + 0.001 * normal, light);\n        col *= shadow;\n    }   \n    else\n    {\n        col += starSky(coord);\n    }\n    return col;\n}\n\nvec2 raymarch(in vec3 ro, in vec3 rd)\n{\n    vec2  h = vec2(0.001, 0.0);\n    float t = 0.0;\n    float tmax = 100.0;\n    \n    for (int i = 0; i < 64; ++i)\n    {\n        if (abs(h.x) < 0.001 || t > tmax) \n        {\n            break;\n        }\n        h = map(ro + t * rd);\n        t += h.x * 0.85;\n    }\n    \n    if(t > tmax) \n    {\n        h.y = -1.0;\n    }\n    \n    return vec2(t, h.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    vec2 cameraRot;\n    if (iMouse.xy != vec2(0))\n    {\n        cameraRot = iMouse.xy / iResolution.xy;\n    }\n    else\n    {\n        cameraRot = vec2(0.55, 0.25);\n    }\n    \n    vec3 ro = vec3(12.5, 1.9, -2.0); \n    vec3 ww = normalize(vec3(0.0, cameraRot.y * 5.0 * PI, 0.0) - ro);\n    ww.xz = rotate2D(ww.xz, -cameraRot.x * 2.0 * PI);\n    vec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    vec3 rd = normalize(p.x * uu + p.y * vv + 2.0 * ww);\n    \n    const vec3 light = normalize(vec3(0.9, 0.1, 0.6));\n    vec3 col = vec3(0.0);\n    vec2 res = raymarch(ro, rd);\n    if (res.y > 0.0)\n    {\n        vec3 pos = ro + res.x * rd;\n        vec3 normal = calcNormal(pos, res.x);\n        \n        float lambert = saturate(dot(normal, light));\n        col = getTerrainColor(pos, normal);    \n        col *= lambert;    \n        col += vec3(0.2);    \n        col *= 0.6;\n        \n        float shadow = calcShadow(pos + 0.001 * normal, light);\n        col *= shadow;\n    }\n    else\n    {\n        col = sky(p, rd, light);\n    }    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}