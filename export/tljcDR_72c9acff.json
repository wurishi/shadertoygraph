{"ver":"0.1","info":{"id":"tljcDR","date":"1594158540","viewed":215,"name":"Chromatic Aberration and Outline","username":"LiamHz","description":"Implemented chromatic aberration and object outlines for a raymarcher","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","effect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"# define EDGE_WIDTH 0.125\n# define DISTORTION_DISTANCE 0.01\n\n/* \nChromatic Aberration (lines 199-221)\n- Acheived by sending 3 rays into the scene,\n- Each ray's x-direction is shifted by sin(iTime)\n- Each ray is responsible for 1 of the fragment's RGB values\n\nObject Outline (line 90)\n- If a marched ray comes close to a SDF, but never intersects\n  with a surface, that ray has intersected with a surface edge\n*/\n\n#define EPS 0.0001\n\nstruct Light {\n    vec3 position;\n    vec3 intensity;\n};\n\n// CSG operations\nfloat opI(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat opS(float d1, float d2) {\n    return max(d1, -d2);\n}\n\n// CSG union and material operator\n// d1 is a vec2 where .x is the distance\n// and .y is the color / material\nvec2 opU(vec2 d1, vec2 d2) {\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\n// SDFs\nfloat sdfSphere(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat sdfTorus(vec3 pos, vec2 t) {\n    vec2 q = vec2(length(0.80*pos.xz + 1.75) - 2.75*t.x, 1.25*pos.y);\n    return 1.1*length(q) - t.y;\n}\n\nfloat sdfCube(vec3 p) {\n    vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    float outsideDistance = length(max(d, 0.0));\n    return insideDistance + outsideDistance;\n}\n\n// Map of scene SDFs\nvec2 map(vec3 p) {\n    float cubeD   = sdfCube(p);\n    float sphereD = sdfSphere((p) / 1.2, 1.0) * 1.2;\n    float torusD  = sdfTorus(p, vec2(0.88));\n\n    float cubeSphereD = opI(cubeD, sphereD);\n    \n    vec2 res = opU(vec2(cubeSphereD, 0.3),\n                   vec2(torusD, 0.6));\n\n    return res;\n}\n\nvec3 raymarch(vec3 viewPos, vec3 ray) {\n    vec2 res;\n    float depth = EPS;\n    float minDist = 16.0;\n    float maxDepth = 16.0;\n    int maxIterations = 64;\n\n    for (int i = 0; i < maxIterations; i++) {\n        // res.x is distance from nearest surface\n        // res.x < EPS indicates surface intersection\n        // res.y is material code\n        res = map(viewPos + depth * ray);\n        minDist = min(res.x, minDist);\n        if (res.x < EPS || depth > maxDepth) break;\n        depth += res.x;\n    }\n    \n    float material = depth > maxDepth ? -1.0 : res.y;\n    float isEdge = minDist < EDGE_WIDTH && depth > maxDepth ? 1.0 : 0.0;\n\n    return vec3(depth, material, isEdge);\n}\n\n// Estimate normal of surface at point p by sampling nearby points\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + EPS, p.y, p.z)).x - map(vec3(p.x - EPS, p.y, p.z)).x,\n        map(vec3(p.x, p.y + EPS, p.z)).x - map(vec3(p.x, p.y - EPS, p.z)).x,\n        map(vec3(p.x, p.y, p.z + EPS)).x - map(vec3(p.x, p.y, p.z - EPS)).x\n    ));\n}\n\nvec3 getLightContrib(vec3 p, vec3 eye, vec3 k_d, vec3 k_s, \n                    float shininess, Light light) {\n    vec3 N = estimateNormal(p);             // Normal\n    vec3 L = normalize(light.position - p); // Light vector\n    vec3 V = normalize(eye - p);            // View vector\n    vec3 R = normalize(reflect(-L, N));     // Reflect vector\n    \n    float diff = max(dot(L, N), 0.0);\n    float spec = pow(max(dot(R, V), 0.0), shininess);\n\n    vec3 diffuse  = k_d * diff;\n    vec3 specular = k_s * spec;\n\n    return light.intensity * (diffuse + specular);\n}\n\nvec3 getLighting(vec3 p, vec3 viewPos) {\n    vec3 k_a = vec3(0.3);\n    vec3 k_d = vec3(0.7);\n    vec3 k_s = vec3(1.0);\n    float shininess = 16.0;\n\n    vec3 ambientLightIntensity = vec3(1.0);\n    vec3 lighting;\n\n    Light light1;\n    light1.intensity = vec3(0.5);\n    light1.position  = vec3(20.0, 3.0, 5.0);\n\n    lighting += getLightContrib(p, viewPos, k_d, k_s, shininess, light1);\n    lighting += k_a * ambientLightIntensity;\n\n    return lighting;\n}\n\n// Create look at matrix\nmat4 setCamera(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n\n    return mat4(vec4(s, 0), vec4(u, 0), vec4(-f, 0), vec4(0, 0, 0, 1));\n}\n\n// Cosine based palette\n// From iq: shadertoy.com/view/ll2GD3\nvec3 palette(float t) {\n    // Palette parameters\n    vec3 a = vec3(0.5);\n    vec3 b = vec3(0.5);\n    vec3 c = vec3(1.0);\n    vec3 d = vec3(0.0, 0.10, 0.2);\n    return a + b*cos(6.28318*(c*t+d));\n}\n\nvec3 getPixel(vec3 viewPos, vec3 worldRay) {\n    vec3 edgeColor       = vec3(1.0);\n    vec3 backgroundColor = vec3(0.0);\n\n    // r.x == length of ray at intersection, \n    // r.y == material (-1.0 if no intersection)\n    // r.z == isEdge\n    vec3 r = raymarch(viewPos, worldRay);\n\n    if (r.z == 1.0) return edgeColor;\n    if (r.y == -1.0) return backgroundColor;\n    \n    // Point of intersection of view ray with surface\n    vec3 p = viewPos + r.x * worldRay;\n    vec3 lighting = getLighting(p, viewPos);\n\n    return palette(r.y) * lighting * 2.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize screen coordinates\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    // Camera\n    vec3 pos    = vec3(5.0, 6.0, 5.0);\n    vec3 center = vec3(0.0);\n    vec3 up     = vec3(0.0, 1.0, 0.0);\n    mat4 camera = setCamera(pos, center, up);\n\n    // Chromatic aberration\n    // dx is distance to distort by\n    float dx = 0.0;\n    dx = (1.0 + sin(iTime*6.0)) * 0.5;\n    dx *= 1.0 + sin(iTime*16.0) * 0.5;\n    dx *= 1.0 + sin(iTime*19.0) * 0.5;\n    dx *= 1.0 + sin(iTime*27.0) * 0.5;\n    dx = pow(dx, 3.0);\n\n    dx *= DISTORTION_DISTANCE;\n    \n    // Transform rays by distortion amount (dx),\n    // and convert them from view to world space \n    vec3 ray1 = (camera * normalize(vec4(p.x     , p.y, -2.0, 0.0))).xyz;\n    vec3 ray2 = (camera * normalize(vec4(p.x - dx, p.y, -2.0, 0.0))).xyz;\n    vec3 ray3 = (camera * normalize(vec4(p.x + dx, p.y, -2.0, 0.0))).xyz;\n    \n    vec3 col;\n    col.r = getPixel(pos, ray2).r;\n    col.g = getPixel(pos, ray1).g;\n    col.b = getPixel(pos, ray3).b;\n\n    col *= (1.0 - dx * 0.5);\n    \n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}