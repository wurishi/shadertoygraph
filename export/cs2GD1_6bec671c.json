{"ver":"0.1","info":{"id":"cs2GD1","date":"1667563188","viewed":153,"name":"CPE v1.1","username":"kshitijgangwar","description":"Camera Preview Enhancements\nInteractive Demo for Simple Ehancements v1\n\nEnhancements as follows:\nBrightness\nContrast\nSaturation\nSharpness\nColor Temperature\nNoise Reduction\n\n","likes":1,"published":1,"flags":34,"usePreview":0,"tags":["demo"],"hasliked":0,"parentid":"DdX3DX","parentname":"CPE v1.0 - Interactive Demo"},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = float(3.14159);\n\n\n    \nstruct AppState\n{\n    float\tmenuId;\n    float   roughness;\n    float   focus;\n    vec2    focusObjRot;\n    vec2    objRot;\n};\n\n//----------------------------------------Noise Reduction Parameters----------------------------------\n#define LUMINANCE_PRESERVATION 0.75\n#define EPSILON 1e-10\n\n#define KERNELSIZE (max(int(ceil(uSpatialSigma * 2.0)), 1) * 2 + 1) //Kernel size, must be an positive odd integer.\n#define KERNELHALFSIZE (int(KERNELSIZE/2)) //Half of the kernel size without remainder. Must be equal to trunc(KERNELSIZE/2).\n#define KERNELLEN (KERNELSIZE * KERNELSIZE) //Total area of kernel. Must be equal to KERNELSIZE * KERNELSIZE.\n\n//----------------------------------------------------------------------------------------------------\n\n//----------------------------------------Sharpness Parameters----------------------------------------\n#define curve_height    1.0                  // Main control of sharpening strength [>0]\n        // 0.3 <-> 2.0 is a reasonable range of values\n\n#define overshoot_ctrl  false                // Allow for higher overshoot if the current edge pixel\n// is surrounded by similar edge pixels\n\n// Defined values under this row are \"optimal\" DO NOT CHANGE IF YOU DO NOT KNOW WHAT YOU ARE DOING!\n\n#define curveslope      0.5                  // Sharpening curve slope, high edge values\n\n#define L_compr_low     0.167                // Light compression, default (0.167=~6x)\n#define L_compr_high    0.334                // Light compression, surrounded by edges (0.334=~3x)\n\n#define D_compr_low     0.250                // Dark compression, default (0.250=4x)\n#define D_compr_high    0.500                // Dark compression, surrounded by edges (0.500=2x)\n\n#define scale_lim       0.1                  // Abs max change before compression [>0.01]\n#define scale_cs        0.056                // Compression slope above scale_lim\n\n#define pm_p            1.0                  // Power mean p-value [>0-1.0]\n\n#define max4(a,b,c,d)  ( max(max(a, b), max(c, d)) )\n\n// Soft if, fast linear approx\n#define soft_if(a,b,c) ( sat((a + b + c + 0.056/2.5)/(maxedge + 0.03/2.5) - 0.85) )\n\n// Soft limit, modified tanh approx\n#define soft_lim(v,s)  ( sat(abs(v/s)*(27.0 + pow(v/s, 2.0))/(27.0 + 9.0*pow(v/s, 2.0)))*s )\n\n// Weighted power mean\n#define wpmean(a,b,w)  ( pow(w*pow(abs(a), pm_p) + abs(1.0-w)*pow(abs(b), pm_p), (1.0/pm_p)) )\n\n// Get destination pixel values\n#define get(a,b)       ( texture(iChannel1, vuv + vec2(a,b)/size).rgb )\n#define sat(x)         ( clamp(x, 0.0, 1.0) )\n#define dxdy(val)      ( length(fwidth(val)) ) // =~1/2.5 hq edge without c_comp\n\n#ifdef LUMA_tex\n#define CtL(RGB)       RGB.x\n#else\n#define CtL(RGB)       ( sqrt(dot(sat(RGB)*sat(RGB), vec3(0.2126, 0.7152, 0.0722))) )\n#endif\n\n#define b_diff(pix)    ( (blur-luma[pix])*(blur-luma[pix]) )\n//----------------------------------------------------------------------------------------------------\n\nvec4 gaussian_vec(vec4 x, vec4 s, vec4 m) {\n    vec4 scaled = (x - m) / s;\n    return exp(-0.5 * scaled * scaled);\n}\n\nfloat gaussian(float x, float s, float m) {\n    float scaled = (x - m) / s;\n    return exp(-0.5 * scaled * scaled);\n}\n\nvec4 noiseReduction(float uGamma, float uIntensitySigma, float uSpatialSigma, vec4 vc, vec2 size, vec2 vuv){\n    vec4 sum = vec4(0.0);\n    vec4 n = vec4(0.0);\n    \n    vec4 is = pow(vc + 0.0001, vec4(uGamma)) * uIntensitySigma;\n    float ss = uSpatialSigma;\n\n    for (int i = -1 * KERNELHALFSIZE; i <= KERNELHALFSIZE; i++) {\n        for (int j = -1 * KERNELHALFSIZE; j <= KERNELHALFSIZE; j++){\n    \n            vec4 v = texture(iChannel1, vuv + vec2(i,j)/size);\n            \n            vec4 d = gaussian_vec(v, is, vc) * gaussian(length(vec2(float(i),float(j))), ss, 0.0);\n            sum += d * v;\n            n += d;\n        }\n    }\n    \n    return sum / n;\n}\n\nfloat saturate(float x) { return clamp(x, 0., 1.); }\nvec2  saturate(vec2  v) { return clamp(v, vec2(0.0), vec2(1.0)); }\nvec3  saturate(vec3  x) { return clamp(x, vec3(0.0), vec3(1.0)); }\nvec4  saturate(vec4  v) { return clamp(v, vec4(0.0), vec4(1.0)); }\n\nvec3 ColorTemperatureToRGB(float temperatureInKelvins)\n{\n    vec3 retColor;\n\n    temperatureInKelvins = clamp(temperatureInKelvins, 1000.0, 40000.0) / 100.0;\n\n    if (temperatureInKelvins <= 66.0)\n    {\n        retColor.r = 1.0;\n        retColor.g = saturate(0.39008157876901960784 * log(temperatureInKelvins) - 0.63184144378862745098);\n    }\n    else\n    {\n        float t = temperatureInKelvins - 60.0;\n        retColor.r = saturate(1.29293618606274509804 * pow(t, -0.1332047592));\n        retColor.g = saturate(1.12989086089529411765 * pow(t, -0.0755148492));\n    }\n\n    if (temperatureInKelvins >= 66.0)\n        retColor.b = 1.0;\n    else if(temperatureInKelvins <= 19.0)\n        retColor.b = 0.0;\n    else\n        retColor.b = saturate(0.54320678911019607843 * log(temperatureInKelvins - 10.0) - 1.19625408914);\n\n    return retColor;\n}\n\nfloat Luminance(vec3 color)\n{\n    float fmin = min(min(color.r, color.g), color.b);\n    float fmax = max(max(color.r, color.g), color.b);\n    return (fmax + fmin) / 2.0;\n}\n\nvec3 HUEtoRGB(float H)\n{\n    float R = abs(H * 6.0 - 3.0) - 1.0;\n    float G = 2.0 - abs(H * 6.0 - 2.0);\n    float B = 2.0 - abs(H * 6.0 - 4.0);\n    return saturate(vec3(R,G,B));\n}\n\nvec3 HSLtoRGB(in vec3 HSL)\n{\n    vec3 RGB = HUEtoRGB(HSL.x);\n    float C = (1.0 - abs(2.0 * HSL.z - 1.0)) * HSL.y;\n    return (RGB - 0.5) * C + vec3(HSL.z);\n}\n\nvec3 RGBtoHCV(vec3 RGB)\n{\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (RGB.g < RGB.b) ? vec4(RGB.bg, -1.0, 2.0/3.0) : vec4(RGB.gb, 0.0, -1.0/3.0);\n    vec4 Q = (RGB.r < P.x) ? vec4(P.xyw, RGB.r) : vec4(RGB.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6.0 * C + EPSILON) + Q.z);\n    return vec3(H, C, Q.x);\n}\n\nvec3 RGBtoHSL(vec3 RGB)\n{\n    vec3 HCV = RGBtoHCV(RGB);\n    float L = HCV.z - HCV.y * 0.5;\n    float S = HCV.y / (1.0 - abs(L * 2.0 - 1.0) + EPSILON);\n    return vec3(HCV.x, S, L);\n}\n\nvec3 colorTempWrapper(float uTemp, float uFactor, vec3 col){\n    vec3  colorTempRGB = ColorTemperatureToRGB(uTemp);\n    float originalLuminance = Luminance(col);\n    vec3  blended = mix(col, col * colorTempRGB, uFactor);\n    vec3  resultHSL = RGBtoHSL(blended);\n    vec3  luminancePreservedRGB = HSLtoRGB(vec3(resultHSL.x, resultHSL.y, originalLuminance));        \n    col = mix(blended, luminancePreservedRGB, LUMINANCE_PRESERVATION);\n    return col;\n}\n\n\n\nvec4 LoadValue(int x, int y)\n{\n    return texelFetch(iChannel0, ivec2(x, y), 0);\n}\n\nvoid LoadState(out AppState s)\n{\n    vec4 data;\n\n    data = LoadValue(0, 0);\n    s.menuId    = data.x;\n    s.roughness = data.y;\n    s.focus     = data.z;\n    \n    data = LoadValue(1, 0);\n    s.focusObjRot  \t= data.xy;\n    s.objRot    \t= data.zw;\n}\n\nfloat Smooth(float x)\n{\n\treturn smoothstep(0., 1., saturate(x));   \n}\n\nfloat Circle(vec2 p, float r)\n{\n    return (length(p / r) - 1.) * r;\n}\n\nvoid Rotate(inout vec2 p, float a) \n{\n    p = cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\n\nfloat Capsule(vec2 p, float r, float c) \n{\n\treturn mix(length(p.x) - r, length(vec2(p.x, abs(p.y) - c)) - r, step(c, abs(p.y)));\n}\n\nfloat TextSDF(vec2 p, float glyph)\n{\n    p = abs(p.x - .5) > .5 || abs(p.y - .5) > .5 ? vec2(0.) : p;\n    return 2. * (texture(iChannel3, p / 16. + fract(vec2(glyph, 15. - floor(glyph / 16.)) / 16.)).w - 127. / 255.);\n}\n\nfloat RoundBox(vec3 p, vec3 b, float r)\n{\n\treturn length(max(abs(p) - b, 0.0)) - r;\n}\n\nvec3 sharpen(float uSharpenAmount, vec3 tex, vec2 vuv, vec2 size){\n\n    vec3 c[25] = vec3[](get( 0, 0), get(-1,-1), get( 0,-1), get( 1,-1), get(-1, 0),\n                        get( 1, 0), get(-1, 1), get( 0, 1), get( 1, 1), get( 0,-2),\n                        get(-2, 0), get( 2, 0), get( 0, 2), get( 0, 3), get( 1, 2),\n                        get(-1, 2), get( 3, 0), get( 2, 1), get( 2,-1), get(-3, 0),\n                        get(-2, 1), get(-2,-1), get( 0,-3), get( 1,-2), get(-1,-2));\n\n    float e[13] = float[](dxdy(c[0]),  dxdy(c[1]),  dxdy(c[2]),  dxdy(c[3]),  dxdy(c[4]),\n                        dxdy(c[5]),  dxdy(c[6]),  dxdy(c[7]),  dxdy(c[8]),  dxdy(c[9]),\n                        dxdy(c[10]), dxdy(c[11]), dxdy(c[12]));\n\n    // RGB to luma\n    float luma[25] = float[](CtL(c[0]), CtL(c[1]), CtL(c[2]), CtL(c[3]), CtL(c[4]), CtL(c[5]), CtL(c[6]),\n                            CtL(c[7]),  CtL(c[8]),  CtL(c[9]),  CtL(c[10]), CtL(c[11]), CtL(c[12]),\n                            CtL(c[13]), CtL(c[14]), CtL(c[15]), CtL(c[16]), CtL(c[17]), CtL(c[18]),\n                            CtL(c[19]), CtL(c[20]), CtL(c[21]), CtL(c[22]), CtL(c[23]), CtL(c[24]));\n\n    float c0_Y = luma[0];\n\n    // Blur, gauss 3x3\n    float  blur   = (2.0 * (luma[2]+luma[4]+luma[5]+luma[7]) + (luma[1]+luma[3]+luma[6]+luma[8]) + 4.0 * luma[0]) / 16.0;\n\n    // Contrast compression, center = 0.5\n    float c_comp = sat(0.266666681f + 0.9*exp2(blur * blur * -7.4));\n\n    // Edge detection\n    // Relative matrix weights\n    // [          1          ]\n    // [      4,  5,  4      ]\n    // [  1,  5,  6,  5,  1  ]\n    // [      4,  5,  4      ]\n    // [          1          ]\n\n    float edge = ( 1.38*b_diff(0)\n                + 1.15*(b_diff(2) + b_diff(4) + b_diff(5) + b_diff(7))\n                + 0.92*(b_diff(1) + b_diff(3) + b_diff(6) + b_diff(8))\n                + 0.23*(b_diff(9) + b_diff(10) + b_diff(11) + b_diff(12)) ) * c_comp;\n\n    vec2 cs = vec2(L_compr_low,  D_compr_low);\n\n    if (overshoot_ctrl) {\n        float maxedge = max4( max4(e[1],e[2],e[3],e[4]), max4(e[5],e[6],e[7],e[8]),\n                            max4(e[9],e[10],e[11],e[12]), e[0] );\n\n        // [          x          ]\n        // [       z, x, w       ]\n        // [    z, z, x, w, w    ]\n        // [ y, y, y, 0, y, y, y ]\n        // [    w, w, x, z, z    ]\n        // [       w, x, z       ]\n        // [          x          ]\n        float sbe = soft_if(e[2],e[9], dxdy(c[22]))*soft_if(e[7],e[12],dxdy(c[13]))  // x dir\n            + soft_if(e[4],e[10],dxdy(c[19]))*soft_if(e[5],e[11],dxdy(c[16]))  // y dir\n            + soft_if(e[1],dxdy(c[24]),dxdy(c[21]))*soft_if(e[8],dxdy(c[14]),dxdy(c[17]))  // z dir\n            + soft_if(e[3],dxdy(c[23]),dxdy(c[18]))*soft_if(e[6],dxdy(c[20]),dxdy(c[15])); // w dir\n\n        cs = mix(cs, vec2(L_compr_high, D_compr_high), sat(2.4002*sbe - 2.282));\n    }\n\n    // Precalculated default squared kernel weights\n    const vec3 w1 = vec3(0.5,           1.0, 1.41421356237); // 0.25, 1.0, 2.0\n    const vec3 w2 = vec3(0.86602540378, 1.0, 0.54772255751); // 0.75, 1.0, 0.3\n\n    // Transition to a concave kernel if the center edge val is above thr\n    vec3 dW = pow(mix( w1, w2, sat(2.4*edge - 0.82)), vec3(2.0));\n\n    // Use lower weights for pixels in a more active area relative to center pixel area\n    // This results in narrower and less visible overshoots around sharp edges\n    float modif_e0 = 3.0 * e[0] + 0.02/2.5;\n\n    float weights[12]  = float[](( min(modif_e0/e[1],  dW.y) ),\n                                ( dW.x ),\n                                ( min(modif_e0/e[3],  dW.y) ),\n                                ( dW.x ),\n                                ( dW.x ),\n                                ( min(modif_e0/e[6],  dW.y) ),\n                                ( dW.x ),\n                                ( min(modif_e0/e[8],  dW.y) ),\n                                ( min(modif_e0/e[9],  dW.z) ),\n                                ( min(modif_e0/e[10], dW.z) ),\n                                ( min(modif_e0/e[11], dW.z) ),\n                                ( min(modif_e0/e[12], dW.z) ));\n\n    weights[0] = (max(max((weights[8]  + weights[9])/4.0,  weights[0]), 0.25) + weights[0])/2.0;\n    weights[2] = (max(max((weights[8]  + weights[10])/4.0, weights[2]), 0.25) + weights[2])/2.0;\n    weights[5] = (max(max((weights[9]  + weights[11])/4.0, weights[5]), 0.25) + weights[5])/2.0;\n    weights[7] = (max(max((weights[10] + weights[11])/4.0, weights[7]), 0.25) + weights[7])/2.0;\n\n    // Calculate the negative part of the laplace kernel and the low threshold weight\n    float lowthrsum   = 0.0;\n    float weightsum   = 0.0;\n    float neg_laplace = 0.0;\n\n    for (int pix = 0; pix < 12; ++pix)\n    {\n        float lowthr = sat((20.*4.5*c_comp*e[pix + 1] - 0.221));\n\n        neg_laplace += luma[pix+1] * luma[pix+1] * weights[pix] * lowthr;\n        weightsum   += weights[pix] * lowthr;\n        lowthrsum   += lowthr / 12.0;\n    }\n\n    neg_laplace = sqrt(neg_laplace / weightsum);\n\n    // Compute sharpening magnitude function\n    float sharpen_val = uSharpenAmount/(uSharpenAmount*curveslope*edge + 0.625);\n\n    // Calculate sharpening diff and scale\n    float sharpdiff = (c0_Y - neg_laplace)*(lowthrsum*sharpen_val + 0.01);\n\n    // Calculate local near min & max, partial sort\n    float temp;\n\n    for (int i1 = 0; i1 < 24; i1 += 2)\n    {\n        temp = luma[i1];\n        luma[i1]   = min(luma[i1], luma[i1+1]);\n        luma[i1+1] = max(temp, luma[i1+1]);\n    }\n\n    for (int i2 = 24; i2 > 0; i2 -= 2)\n    {\n        temp = luma[0];\n        luma[0]    = min(luma[0], luma[i2]);\n        luma[i2]   = max(temp, luma[i2]);\n\n        temp = luma[24];\n        luma[24] = max(luma[24], luma[i2-1]);\n        luma[i2-1] = min(temp, luma[i2-1]);\n    }\n\n    float min_dist  = min(abs(luma[24] - c0_Y), abs(c0_Y - luma[0]));\n    min_dist = min(min_dist, scale_lim*(1.0 - scale_cs) + min_dist*scale_cs);\n\n    // Soft limited anti-ringing with tanh, wpmean to control compression slope\n    sharpdiff = wpmean(max(sharpdiff, 0.0), soft_lim( max(sharpdiff, 0.0), min_dist ), cs.x )\n        - wpmean(min(sharpdiff, 0.0), soft_lim( min(sharpdiff, 0.0), min_dist ), cs.y );\n\n    float sharpdiff_lim = sat(c0_Y + sharpdiff) - c0_Y;\n\n    return sharpdiff_lim + c[0];\n}\n\nvoid DrawScene(inout vec3 color, vec2 p, in AppState s)\n{\n   // color = texture(iChannel1, F.xy/R.xy).rgb; return;\n      \n   float uHue              = 1.00;\n   float uSaturation       = 1.00; // s.roughness; // 1.0;\n   float uValue            = 1.00;\n   float uTonemapping      = 0.00;\n   float uContrast         = 1.00;\n   float uSharpen          = 0.00;\n   float uTemp             = 4500.0;\n   float uFactor           = 0.00;\n   float uSharpenAmount    = 0.00;\n   \n   float uGamma            = 1.00;\n   float uIntensitySigma   = 1.30;\n   float uSpatialSigma     = 1.65;\n   \n   vec2 uv = F.xy/R.xy;\n\n#ifdef MIRROR_CAM\n   uv.x = 1.0 - uv.x;\n#endif\n\n   vec4 tex = texture(uInputTexture, uv);\n   vec2 tex_size = vec2(textureSize(iChannel1, 0));\n   color = tex.rgb;\n   \n    //NoiseReduction\n    //tex = noiseReduction(uGamma, uIntensitySigma, uSpatialSigma, tex, tex_size, uv);\n\n    //Sharpness\n    tex.rgb = sharpen(uSharpenAmount, tex.rgb, uv, tex_size);\n    \n    //ColorTemperature\n    tex.rgb = colorTempWrapper(uTemp, uFactor, tex.rgb);\n\n    // Tonemmaping\n    vec3 ldr = tex.rgb;\n    if (abs(uTonemapping) > kEps) {\n        vec3 hdr = inverse_tonemap_mul(tex.rgb);\n        ldr = tonemap_aces_approx(hdr);\n        ldr = mix(tex.rgb, ldr, uTonemapping);\n    }\n\n    // HSV correction\n    vec3 col = ldr;\n    vec3 hsvFactors = vec3(uHue, uSaturation, uValue);\n    if (abs(dot(hsvFactors, hsvFactors) - 1.) > kEps) {\n        vec3 hsv = HSVFromRGB(ldr);\n        hsv *= hsvFactors;\n        col = RGBFromHSV(hsv);\n    }\n\n    // Contrast\n    if (abs(uContrast - 1.0) > kEps) {\n        col = pow(col, vec3(uContrast));\n    }\n\n    if (F.x/R.x < 0.5)\n        color = col;\n        \n    color *= smoothstep(0.4, 0.5, abs(p.x - 0.5));\n}\n\nvoid SliderText(inout vec3 color, vec2 p, in AppState s)\n{\n    p -= vec2(67, 76);\n    \n    vec2 scale = vec2(4., 8.);\n    vec2 t = floor(p / scale);   \n    \n    uint v = 0u;\n\tv = t.y == 0. ? (t.x < 4. ? 1735749458u : (t.x < 8. ? 1936027240u : 14963u)) : v;\n\tv = t.x >= 0. && t.x < 12. ? v : 0u;\n    \n\tfloat c = float((v >> uint(8. * t.x)) & 255u);\n    \n    vec3 textColor = vec3(.3);\n\n    p = (p - t * scale) / scale;\n    p.x = (p.x - .5) * .5 + .5;\n    float sdf = TextSDF(p, c);\n    if (c != 0.)\n    {\n    \tcolor = mix(textColor, color, smoothstep(-.05, +.05, sdf));\n    } \n}\n\n\nvoid DrawSlider(inout vec3 color, vec2 p, in AppState s)\n{\n    p -= vec2(110, 94.5);\n    \n    p.y += 15.;\n    float c1 = Capsule(p.yx - vec2(0., 20.), 1., 20.);\n    c1 = min(c1, Circle(p - vec2(40. * s.roughness, 0.), 2.5));\n\n\tcolor = mix(color, vec3(0.3), Smooth(-c1 * 2.));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;    \n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1. + 2. * q;\n\tp.x *= iResolution.x / iResolution.y;    \n    p *= 100.;\n    \n    AppState s;\n    LoadState(s);  \n    \n    vec3 color = vec3(p, 0.);    \n    \n    DrawScene(color, p, s);\n    DrawSlider(color, p, s);\n\n    // color = pow(color, vec3(.4545));\n\n\tfragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// control loop\n\nconst float FOCUS_SLIDER = 1.;\nconst float FOCUS_OBJ    = 2.;\n\nstruct AppState\n{\n    float   menuId;\n    float   roughness;\n    float   focus;\n    vec2    focusObjRot;\n    vec2    objRot;\n};\n\nvec4 LoadValue(int x, int y)\n{\n    return texelFetch(iChannel0, ivec2(x, y), 0);\n}\n\nvoid LoadState(out AppState s)\n{\n    vec4 data;\n\n    data = LoadValue(0, 0);\n    s.menuId    = data.x;\n    s.roughness = data.y;\n    s.focus     = data.z;\n    \n    data = LoadValue(1, 0);\n    s.focusObjRot   = data.xy;\n    s.objRot        = data.zw;\n}\n\nvoid StoreValue(vec2 re, vec4 va, inout vec4 fragColor, vec2 fragCoord)\n{\n    fragCoord = floor(fragCoord);\n    fragColor = (fragCoord.x == re.x && fragCoord.y == re.y) ? va : fragColor;\n}\n\nvec4 SaveState(in AppState s, in vec2 fragCoord)\n{\n    if (iFrame <= 0)\n    {\n        s.menuId      = 0.0;\n        s.roughness   = 0.5;\n        s.focus       = 0.0;\n        s.focusObjRot = vec2(0.0);\n        s.objRot      = vec2(0.0);\n    }\n    \n    vec4 ret = vec4(0.);\n    StoreValue(vec2(0., 0.), vec4(s.menuId, s.roughness, s.focus, 0.0), ret, fragCoord);\n    StoreValue(vec2(1., 0.), vec4(s.focusObjRot, s.objRot), ret, fragCoord);\n    return ret;\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (fragCoord.x >= 8. || fragCoord.y >= 8.) \n    {\n        discard;    \n    }\n\n    AppState s;\n    LoadState(s);\n    \n    vec4 q = iMouse / iResolution.xyxy;\n    vec4 m = -1. + 2. * q;\n    m.xz *= iResolution.x / iResolution.y;    \n    m *= 100.;    \n\n    vec4 sliderM = m - vec2(110, 94.5).xyxy;\n    if (sliderM.z >= -4. && sliderM.z < 44. && sliderM.w >= -20. && sliderM.w < -10.)\n    {\n        s.focus = FOCUS_SLIDER;\n    } \n    else if (m.w > -100. && m.w < 40. && abs(m.z + 20.) < 70.)\n    {\n        if (s.focus != FOCUS_OBJ)\n        {\n            s.focusObjRot = s.objRot; \n        }\n        s.focus = FOCUS_OBJ;\n    }\n    else\n    {\n        s.focus = 0.;\n        vec2 mp = (m.xy - vec2(-160, -1));\n        float menuId = mp.x < 40. || (mp.x < 60. && (mp.y > 18. && mp.y < 24.)) ? 10. - floor(mp.y / 8.) : -1.;\n        if (menuId >= 0. && menuId <= 2.)\n        {\n            s.menuId = menuId;\n        }\n    }\n\n    if (s.focus == FOCUS_SLIDER)\n    {\n        s.roughness = sliderM.x / 20.;\n    } \n    if (s.focus == FOCUS_OBJ)\n    {\n        s.objRot = s.focusObjRot + .04 * (m.xy - m.zw);\n    }\n    \n    fragColor = SaveState(s, fragCoord);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define MIRROR_CAM\n\n#define F gl_FragCoord\n#define R iResolution\n#define v_uv (R.xy/R.xy)\n#define uInputTexture iChannel1 // cam\n// #define uInputTexture iChannel2 // britney\n\n#define T iTime\n\nfloat kEps = 0.01;\n\nmat3 YUVFromRGB = mat3(\n    vec3( 0.299, -0.14713,  0.615  ),\n    vec3( 0.587, -0.28886, -0.51499),\n    vec3( 0.114,    0.436, -0.10001)\n);\n\nmat3 RGBFromYUV = mat3(\n    vec3( 1.0,      1.0,   1.0    ),\n    vec3( 0.0,     -0.394, 2.03211),\n    vec3( 1.13983, -0.580, 0.0    )\n);\n\nfloat LumaFromRGB(vec3 c)\n{\n    return c.r * 0.299 + c.g * 0.587 + c.b * 0.114;\n}\n\n// Will it blend by nmz: https://www.shadertoy.com/view/lsdGzN\n// From Sam Hocevar: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 HSVFromRGB( vec3 c )\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 RGBFromHSV( vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// by P Malin https://www.shadertoy.com/view/4lcyD8\nvec3 inverse_tonemap_mul(vec3 vCol )\n{\n    vec3 color = vCol * vCol;\n    float kEnvmapExposure = 0.999;\n    return -log2(1.0 - color * kEnvmapExposure);\n}\n\n// src: https://64.github.io/tonemapping/\n// by K Narkowicz\nvec3 tonemap_aces_approx(vec3 v)\n{\n    v *= 0.6;\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0, 1.0);\n}\n\n// TODO: make sure uInputTexture sampler is CLAMP_TO_EDGE\nvec2 kOffsets[8] = vec2[](\n    vec2( -1.0,  1.0), vec2(  0.0,  1.0), vec2(  1.0,  1.0),\n    vec2( -1.0,  0.0),                    vec2(  1.0,  0.0),\n    vec2( -1.0, -1.0), vec2(  0.0, -1.0), vec2(  1.0, -1.0)\n);\n\n","name":"Common","description":"","type":"common"}]}