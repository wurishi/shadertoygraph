{"ver":"0.1","info":{"id":"DsSGzw","date":"1667353602","viewed":67,"name":"Truncated VS Continuous Cells","username":"Envy24","description":"Drag with mouse to see more difference.\nLeft - scene 3,\nMiddle - scene 1,\nRight  - scene 2.\n\nHow can i achieve right scene without loops (with better performance) ?\nScene 3 is half-solution. Maybe another solution?","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["map","cells","continuous","partition","truncated"],"hasliked":0,"parentid":"DdsGDj","parentname":"Map and inverse map test"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                         ( iResolution )\n#define AR                        ( R.x / R.y )                      // Aspect ratio.\n#define PIXELATE(SC, PS)          ( floor( (SC) / (PS) ) * (PS) )    // PS - pixel size\n\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - R.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool use_mouse)\n{\n    vec2 M = MOUSE_OFFSET * (use_mouse ? 1. : 0.);\n    return ((2. * (SC - M) - R.xy) / R.y) * scale - origin;\n}\nvec2 truncated_centered_cells_map(in vec2 SC, in float scale, in vec2 origin, in bool use_mouse, in float ps_size)\n{\n    return map_to_centered_ndc(PIXELATE(SC, ps_size)+vec2(ps_size*0.5), scale, origin, use_mouse);\n}\n//vec2 truncated_cells_map(in vec2 SC, in float scale, in vec2 origin, in bool use_mouse, in float ps_size)\n//{\n//    return map_to_centered_ndc(PIXELATE(SC, ps_size), scale, origin, use_mouse);\n//}\n\n#define SCENE_SCALE    ( 1.0 )\n#define ORIGIN         ( vec2(0) )\n#define CELL_SIZE_SC   ( 50. )\n#define CELL_SIZE_NDC  ( (2.*CELL_SIZE_SC*SCENE_SCALE) / R.y )\n#define RANGES         ( map_to_centered_ndc(R.xy, SCENE_SCALE, vec2(0), false) )\n\n/* Truncated cells. */\nvec3 scene1(in vec2 SC)\n{   \n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, true),\n         CC = truncated_centered_cells_map(SC, SCENE_SCALE, ORIGIN, false, CELL_SIZE_SC);\n         \n    vec3 color = vec3(0);\n            \n    // Calculate offsets relative to vec2(0)\n    vec2 Bo = vec2(-CELL_SIZE_NDC*0.5, - 3.*CELL_SIZE_NDC),\n         Eo = vec2(+CELL_SIZE_NDC*0.5, + 3.*CELL_SIZE_NDC);\n    // Apply rotation.\n         Bo = rotateAroundZ(Bo, iTime * 0.1);\n         Eo = rotateAroundZ(Eo, iTime * 0.1);\n    // Calculate segment coordinates.       \n    vec2 B = CC - Bo,\n         E = CC - Eo;\n    // Draw segment.\n         color = mix( color, vec3(0,1,0),     smoothstep(4./R.y, 0., segmentSDF_L2(NDC, B, E, 0.)) );\n    // Draw cell center.\n         color = mix( color, vec3(1,0,0),     smoothstep(4./R.y, 0., diskSDF_L2(NDC, CC, 10./R.y)) );\n         \n    return color;\n}\n\n/* \"Continuous\" cells. */\nvec3 scene2(in vec2 SC)\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, true),\n         ranges = RANGES;\n         \n    vec3 color = vec3(0);\n    \n    float x_count = R.x/CELL_SIZE_SC,     y_count = R.y/CELL_SIZE_SC,\n          dx = (ranges.x*2.) / (x_count), dy = (ranges.y*2.) / (y_count);\n    \n    vec2 offset = \n        vec2(CELL_SIZE_NDC*0.5) // cell center offset,\n        - ranges                // center cells grid,\n        - ORIGIN;               // match with NDC coordinates.\n    \n    for (float y = 0.; y < y_count; y += 1.)\n    {       \n        for (float x = 0.; x < x_count; x += 1.)\n        {\n            // Calculate current cell center.\n            vec2 CC = offset + vec2(x*dx, y*dy);\n            \n            /* Optimization. If NDC is far from CC, then skip this cell. *\n            vec2 diff = CC - NDC; \n            if (dot(diff, diff) > CELL_SIZE_NDC) { continue; }\n            /**/\n            \n            // Calculate offsets relative to vec2(0)\n            vec2 Bo = vec2(-CELL_SIZE_NDC*0.5, - 3.*CELL_SIZE_NDC),\n                 Eo = vec2(+CELL_SIZE_NDC*0.5, + 3.*CELL_SIZE_NDC);\n            // Apply rotation.\n                 Bo = rotateAroundZ(Bo, iTime * 0.1);\n                 Eo = rotateAroundZ(Eo, iTime * 0.1);\n            // Calculate segment coordinates.\n            vec2 B = CC - Bo,\n                 E = CC - Eo;\n            // Draw segment.\n                 color = mix( color, vec3(0,1,0),     smoothstep(4./R.y, 0., segmentSDF_L2(NDC, B, E, 0.)) );\n            // Draw cell center.\n                 color = mix( color, vec3(1,0,0),     smoothstep(4./R.y, 0., diskSDF_L2(NDC, CC, 10./R.y)) );                 \n        }\n    }\n    \n    return color;\n}\n\n/* Partially-Truncated cells. */\nvec3 scene3(in vec2 SC)\n{   \n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, true),\n         CC = truncated_centered_cells_map(SC, SCENE_SCALE, ORIGIN, false, CELL_SIZE_SC),\n         ranges = RANGES;\n         \n    vec3 color = vec3(0); \n    vec2 CC_ = CC; float order = 3.;\n         \n    for (float y = -order; y <= order; y += 1.)\n    {       \n        for (float x = -order; x <= order; x += 1.)\n        {\n            // Calculate current cell center.\n            vec2 CC = CC_ + vec2(x*CELL_SIZE_NDC, y*CELL_SIZE_NDC);\n            \n            // Truncate scene.\n            //if (abs(CC.x) > ranges.x || abs(CC.y) > ranges.y) { continue; }\n            \n            /* Optimization. If NDC is far from CC, then skip this cell. *\n            vec2 diff = CC - NDC; \n            if (dot(diff, diff) > CELL_SIZE_NDC) { continue; }\n            /**/\n            \n            // Calculate offsets relative to vec2(0)\n            vec2 Bo = vec2(-CELL_SIZE_NDC*0.5, - 3.*CELL_SIZE_NDC),\n                 Eo = vec2(+CELL_SIZE_NDC*0.5, + 3.*CELL_SIZE_NDC);\n            // Apply rotation.\n                 Bo = rotateAroundZ(Bo, iTime * 0.1);\n                 Eo = rotateAroundZ(Eo, iTime * 0.1);\n            // Calculate segment coordinates.\n            vec2 B = CC - Bo,\n                 E = CC - Eo;\n            // Draw segment.\n                 color = mix( color, vec3(0,1,0),     smoothstep(4./R.y, 0., segmentSDF_L2(NDC, B, E, 0.)) );\n            // Draw cell center.\n                 color = mix( color, vec3(1,0,0),     smoothstep(4./R.y, 0., diskSDF_L2(NDC, CC, 10./R.y)) );                 \n        }\n    }\n         \n    return color;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec3 color = SC.x < R.x*0.33 ? scene3(SC) : SC.x < R.x*0.66 ? scene1(SC) : scene2(SC);\n    //vec3 color = scene1(SC); // fast, but truncated.\n    //vec3 color = scene2(SC); // continuous, but slow.\n    //vec3 color = scene3(SC); // continuous and faster than second scene.\n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float diskSDF_L2(vec2 NDC, vec2 C, float r)\n{\n    return length(C - NDC)-r;\n}\n\nfloat segmentSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E,\n    float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}\n\nvec2 rotateAroundZ(vec2 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    return vec2(\n        p.x * c - p.y * s,\n        p.y * c + p.x * s);\n}","name":"Common","description":"","type":"common"}]}