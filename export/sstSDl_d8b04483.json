{"ver":"0.1","info":{"id":"sstSDl","date":"1636389041","viewed":62,"name":"Fork SDF determ nyriu 252","username":"nyriu","description":"Visualization of touchingBoundingSquare function to understand how it works.\nIn \"March along the edge\" in touchingBoundingSquare I added 2x multiplier to walk along all the border instead only half of it.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdfvoxel"],"hasliked":0,"parentid":"wlyyRc","parentname":"SDF determine voxel state"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * forked to show how touchingBoundingSquare works\n * WIP\n */\n \n \n#define SHOW_EXAMPLE false // show (almost) original example\n                           // set to false to see animation\n#define gridSize1 5.0\n\n\nfloat cornerRadiusMultiplier = 3.-2./sqrt(2.)-sqrt(2.);\n\nfloat sdBox( vec2 uv, vec2 position, in vec2 bounds )\n{\n    vec2 d = abs(position - uv)-bounds;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle(vec2 uv, vec2 pos, float radius) {\n    return length(uv - pos) - radius;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec2 pixelSize() {\n    return 2.0 * ((vec2(iResolution.x, iResolution.y) - (0.5*iResolution.xy))/iResolution.y) / iResolution.xy;\n}\n\nfloat sdf(vec2 uv) {\n\n    vec2 pixelSize = pixelSize();\n    \n    float screenEdgeMargin = 0.1;\n\n    float radius1 = 0.7 * (1.0 + sin(iTime * 0.6));\n    vec2 position1 = vec2(sin(iTime * 0.2) * (iResolution.x / iResolution.y) * (1. - screenEdgeMargin), sin(iTime * 0.10) * (1. - screenEdgeMargin));\n    float circle1 = sdCircle(uv, position1, radius1);   \n    \n    float radius2 = 0.4 * (1.0 + sin(iTime * 0.1));\n    vec2 position2 = vec2(sin(iTime * 0.4) * (iResolution.x / iResolution.y) * (1. - screenEdgeMargin), sin(iTime * 0.8) * (1. - screenEdgeMargin));\n    float circle2 = sdCircle(uv, position2, radius2);      \n    \n    // 1/10th the size of a pixel circles\n    float radius3 = 0.1 * min(pixelSize.x, pixelSize.y); \n    vec2 position3 = vec2(sin(iTime * 0.6) * (iResolution.x / iResolution.y) * (1. - screenEdgeMargin), sin(iTime * 0.6) * (1. - screenEdgeMargin));\n    float circle3 = sdCircle(uv, position3, radius3);   \n    \n    float radius4 = 0.1 * min(pixelSize.x, pixelSize.y); \n    vec2 position4 = vec2(sin(iTime * 0.8) * (iResolution.x / iResolution.y) * (1. - screenEdgeMargin), sin(iTime * 0.4) * (1. - screenEdgeMargin));\n    float circle4 = sdCircle(uv, position4, radius4);   \n    \n    return min(min(min(circle1, circle2), circle3), circle4);\n}\n    \nbool insideBoundingSquare(vec2 position, vec2 bound) {\n\n    vec2 pixelSize = pixelSize();\n\n    // We'll check just outside of the square to catch cases where the sdf resolves in sub-pixel level between\n    // two squares. This means we potentially treat a square as inside/touching when it isn't but better than\n    // artefacts due to this scenario.\n    vec2 adjustedBound = bound + pixelSize;\n\n    // If all points inside the grid's outer circle are negative, then we're definitely inside.\n    float midpointD = sdf(position);\n    if (midpointD < -length(adjustedBound)) {\n        return true;\n    } else if (abs(midpointD) < min(adjustedBound.x, adjustedBound.y)) {\n        // There is an sdf edge inside the inner circle, so must not be completely inside.\n        return false;\n    }\n\n    \n    // For each corner,\n    for (float x = 0.; x < 2.; x++) {\n        for (float y = 0.; y < 2.; y++) {\n            vec2 cornerDirection = normalize(vec2(-1.0 + 2. * x, -1.0 + 2.0 * y)); // -1.0, -1.0 to 1.0, 1.0\n            float r = adjustedBound.x; // Set radius of to radius of inner circle of square.\n            float distFromMidpoint = r; // Total distance from midpoint to corner circle midpoint.\n\n            // Keep shrinking the corner circle until we reach pixel size (or return a value inside).\n            while (r >= min(pixelSize.x, pixelSize.y)) {\n            \n                // Calculate size of inscribed circle in corner.\n                r = cornerRadiusMultiplier * r;\n                distFromMidpoint += r; // Move to midpoint of new circle\n                vec2 cornerCircleMidpoint = position + cornerDirection * distFromMidpoint;\n                distFromMidpoint += r; // Move to edge of circle for next circle\n                \n                // We march in a clock-wise direction around the perimeter.\n                float posOrNeg = 1. - x*2.; // 1 or -1\n                float applyX = abs(x-y); // 1 or 0\n                float applyY = abs(applyX - 1.); // 1 or 0\n                vec2 edgeDirection = vec2(applyX * posOrNeg, applyY * posOrNeg);\n                \n                // March along the edge.\n                for (float i = r; i < adjustedBound.x - r; i = i + r) {\n                    vec2 midpoint = cornerCircleMidpoint + i * edgeDirection;\n                    if (sdf(midpoint) > r) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    \n            \n    return true;\n}\n\nbool touchingBoundingSquare(vec2 position, vec2 bound) {\n\n    vec2 pixelSize = pixelSize();\n\n    // We'll check just outside of the square to catch cases where the sdf resolves in sub-pixel level between\n    // two squares. This means we potentially treat a square as inside/touching when it isn't but better than\n    // artefacts due to this scenario.\n    vec2 adjustedBound = bound + pixelSize;\n\n    // If all points inside the grid's outer circle are outside,\n    // then we're definitely outside and not touching.\n    float midpointD = sdf(position);\n    if (midpointD > length(adjustedBound)) {\n        // Doesn't touch outer circle, so must be completely outside sdf volume.\n        return false;\n    } else if (midpointD < min(adjustedBound.x, adjustedBound.y)) {\n        // Touches inner circle so must be inside square.\n        return true;\n    }\n\n    // For each corner,\n    for (float x = 0.; x < 2.; x++) {\n        for (float y = 0.; y < 2.; y++) {\n            vec2 cornerDirection = normalize(vec2(-1.0 + 2. * x, -1.0 + 2.0 * y)); // -1.0, -1.0 to 1.0, 1.0\n            float r = adjustedBound.x; // Set radius of to radius of inner circle of square.\n            float distFromMidpoint = r; // Total distance from midpoint to corner circle midpoint.\n\n            // Keep going until we reach pixel size or exit condition.\n            while (r >= min(pixelSize.x, pixelSize.y)) {\n            \n                // Calculate size of inscribed circle in corner.\n                r = cornerRadiusMultiplier * r;\n                distFromMidpoint += r; // Move to midpoint of new circle\n                vec2 cornerCircleMidpoint = position + cornerDirection * distFromMidpoint;\n                distFromMidpoint += r; // Move to edge of circle for next circle\n                float posOrNeg = 1. - x*2.; // 1 or -1\n                float applyX = abs(x-y); // 1 or 0\n                float applyY = abs(applyX - 1.); // 1 or 0\n                vec2 edgeDirection = vec2(applyX * posOrNeg, applyY * posOrNeg);\n                // March along the edge.\n                for (float i = r; i < adjustedBound.x - r; i = i + r) {\n                    vec2 midpoint = cornerCircleMidpoint + i * edgeDirection;\n                    if (sdf(midpoint) <= r) {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n\nvec4 original_example(vec2 uv) {\n        // Calculate SDF\n        float d = sdf(uv);\n\n        float gridSize = gridSize1;\n\n        // Bounding Box\n        vec2 voxelMidpoint = vec2((floor(uv.x * gridSize) / gridSize) + (0.5 / gridSize), (floor(uv.y * gridSize) / gridSize) + (0.5 / gridSize));\n        vec2 voxelSize = vec2(0.5 / gridSize, 0.5 / gridSize);\n        vec2 minExtent = voxelMidpoint - voxelSize;\n        vec2 maxExtent = voxelMidpoint + voxelSize;\n        float box1 = sdBox(uv, voxelMidpoint, voxelSize);\n\n        // Work out if the SDF is inside the box or not.\n        bool touching = touchingBoundingSquare(voxelMidpoint, voxelSize);\n        bool inside = false;\n        if (touching) {\n            inside = insideBoundingSquare(voxelMidpoint, voxelSize);\n        }\n\n        bool outside = !touching;\n\n        vec3 statusColor = vec3(1.0, 1.0, 0.0);\n        if (inside) {\n            statusColor = vec3(0.0, 1.0, 0.0);\n        } else if (outside) {\n            statusColor = vec3(1.0, 0.0, 0.0);\n        }\n\n        // Set base colour depending on inside or outside bounding box.\n        vec3 baseColor = vec3(0.1,0.4,0.7);\n        if (uv.x > minExtent.x && uv.x < maxExtent.x && uv.y > minExtent.y && uv.y < maxExtent.y) {\n            baseColor = vec3(0.8,0.2,0.2);\n        }\n\n        // Taken from iq to visualize sdf distances (https://www.shadertoy.com/view/4lcBWn)    \n        vec3 col = vec3(1.0) - sign(d)*baseColor;\n        col *= 1.0 - exp(-3.0*abs(d));\n        col *= 0.8 + 0.2*cos(120.0*d);\n        col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.008,abs(d)));\n\n        // Add the grid\n        col = mix( col, statusColor, 1.0-smoothstep(0.0,0.008,abs(box1)) );\n\n        // Output to screen\n        return vec4(col,1.0);\n}\n\n\nvec4 animation_intro(vec2 uv, float time) {\n    vec2 pixelSize = pixelSize();\n    vec3 baseColor = vec3(0.1,0.4,0.7);\n    vec3 col = baseColor;\n\n    vec2 box_pos = vec2(0,0);\n    vec2 box_bound = vec2(0.5);\n\n    // square\n    float d = sdBox(uv, box_pos, box_bound);\n    col = mix( col, vec3(0), 1.0-smoothstep(0.0,0.008,abs(d)) );\n    \n\n    // square midpoint\n    d = sdCircle(uv, box_pos, 0.007);\n    col = mix( col, vec3(0), 1.0-smoothstep(0.0,0.008,abs(d)) );\n    //if (d < 0.0) col = vec3(0.0);\n    \n    \n    vec3 circleColor = normalize(vec3(80, 142, 67));\n    \n    // radius inner\n    d = sdSegment(uv, box_pos, box_pos+vec2(box_bound.x,0));\n    //d = sdBox(uv, box_pos+vec2(box_bound.x/2.,0), vec2(box_bound.x/2.,0));\n    col = mix( col, circleColor, 1.0-smoothstep(0.0,0.008,abs(d)) );\n\n    // inner circle\n    d = sdCircle(uv, box_pos, min(box_bound.x,box_bound.y));\n    col = mix( col, circleColor, 1.0-smoothstep(0.0,0.008,abs(d)) );\n    \n    \n    circleColor = normalize(vec3(142, 80, 67));\n    \n    // radius outer    \n    d = sdSegment(uv, box_pos, box_pos-box_bound);\n    col = mix( col, circleColor, 1.0-smoothstep(0.0,0.008,abs(d)) );\n\n    // outer circle\n    d = sdCircle(uv, box_pos, length(box_bound));\n    col = mix( col, circleColor, 1.0-smoothstep(0.0,0.008,abs(d)) );\n\n\n\n\n    return vec4(col,1.0);\n}\n\nvec4 animation_touchingBoundingSquare(vec2 uv) {\n    float time =\n        //mod( floor(iDate.w),        60.0 );\n        iTime*1.5;\n    \n    if (time < floor(8.0+time/8.0)/2.)\n        return animation_intro(uv, time);\n\n    vec2 pixelSize = pixelSize();\n    vec3 baseColor = vec3(0.1,0.4,0.7);\n    vec3 col = baseColor;\n\n    vec2 box_pos = vec2(0,0);\n    vec2 box_bound = vec2(0.5);\n\n    // square\n    float d = sdBox(uv, box_pos, box_bound);\n    \n    col = mix( col, vec3(0), 1.0-smoothstep(0.0,0.008,abs(d)) );\n    //if (d == 0.0) col = vec3(0.0);\n\n    // square midpoint\n    d = sdCircle(uv, box_pos, 0.007);\n    col = mix( col, vec3(0), 1.0-smoothstep(0.0,0.008,abs(d)) );\n    //if (d < 0.0) col = vec3(0.0);\n\n    //// square topright corner\n    //d = sdCircle(uv, box_pos+box_bound, 0.01);\n    //if (d < 0.0) col = vec3(0.0);\n\n    // inner circle\n    \n    vec3 circleColor = normalize(vec3(80, 142, 67));\n    d = sdCircle(uv, box_pos, min(box_bound.x,box_bound.y));\n    float delta = 0.004;\n    //if (-delta < d && d < delta) col = vec3(0.0);\n    col = mix( col, circleColor, 1.0-smoothstep(0.0,0.008,abs(d)) );\n\n    // alg visualized\n    vec2 position = box_pos;\n    vec2 bound = box_bound;\n    vec2 adjustedBound = bound + pixelSize;\n\n    \n    //for (float x = 0.; x < 2.; x++) { for (float y = 0.; y < 2.; y++) { // all together\n    //float x = 1., y = 1.; {{                                            // only one corner\n    //float time=iTime/3.0; float x =1.0+floor(sin(time)), y = 1.0+floor(sin(2.0*time)); {{\n    float x = mod(floor((8.0+time)/8.0),2.0), y = mod(floor((4.0+time)/4.0),2.0); {{\n    \n        vec2 cornerDirection = normalize(vec2(-1.0 + 2. * x, -1.0 + 2.0 * y)); // -1.0, -1.0 to 1.0, 1.0\n        float r = adjustedBound.x; // Set radius of to radius of inner circle of square.\n        float distFromMidpoint = r; // Total distance from midpoint to corner circle midpoint.\n\n        vec2 cornerCircleMidpoint = position + cornerDirection * distFromMidpoint;\n        \n        \n        //int while_iters = 1;\n        //int while_iters = int(floor(iTime))%4 + 1;\n        int while_iters = int(mod(floor(time),4.0) + 1.0);\n        \n            while (r >= min(pixelSize.x, pixelSize.y) && while_iters > 0) {\n                // Calculate size of inscribed circle in corner.\n                r = cornerRadiusMultiplier * r;\n                distFromMidpoint += r; // Move to midpoint of new circle\n                cornerCircleMidpoint = position + cornerDirection * distFromMidpoint;\n                distFromMidpoint += r; // Move to edge of circle for next circle\n                while_iters--;\n            }\n            \n            //int for_iters = int(ceil(iTime*5.0))%(int(2.0*(adjustedBound.x - r)/r));\n\n\n            vec3 c= normalize(vec3(200, 55, 40));\n            d = sdCircle(uv, cornerCircleMidpoint, 0.01);\n            if (d < 0.0) col = c;\n            d = sdCircle(uv, cornerCircleMidpoint, r);\n            if (-delta < d && d < delta) col = c;\n\n\n            float posOrNeg = 1. - x*2.; // 1 or -1\n            float applyX = abs(x-y); // 1 or 0\n            float applyY = abs(applyX - 1.); // 1 or 0\n            vec2 edgeDirection = vec2(applyX * posOrNeg, applyY * posOrNeg);\n            \n            vec2 midpoint = cornerCircleMidpoint;\n            // March along the edge.\n            for (float i = r; i < 2.0*(adjustedBound.x - r); i = i + r) {\n                midpoint = cornerCircleMidpoint + i * edgeDirection;\n            \n\n            d = sdCircle(uv, midpoint, 0.01);\n            if (d < 0.0) col = c;\n\n            d = sdCircle(uv, midpoint, r);\n            if (-delta < d && d < delta) col = c;\n            }\n            \n        }\n    }\n\n    // Output to screen\n    return vec4(col,1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from y = -1 to 1 with 0,0 in the center of the screen)\n    vec2 uv = 2.0 * (fragCoord - (0.5*iResolution.xy))/iResolution.y;\n\n    if (SHOW_EXAMPLE) {\n        fragColor = original_example(uv);\n    } else {\n        fragColor = animation_touchingBoundingSquare(uv);\n    }\n    \n    \n    \n}","name":"Image","description":"","type":"image"}]}