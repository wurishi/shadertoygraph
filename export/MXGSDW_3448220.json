{"ver":"0.1","info":{"id":"MXGSDW","date":"1720689279","viewed":211,"name":"Derpy Pigeons","username":"FyKru","description":"Animated birds with domain repetition and random parameters per instance","likes":34,"published":1,"flags":0,"usePreview":0,"tags":["warping","derp","outline","birds","pigeon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//-----COLORS-----\nconst vec3 groundColor = vec3(1.00, 0.53, 0.00);\nconst vec3 lowerBodyColor = vec3(0.43, 0.47, 0.50);\nconst vec3 UpperBodyColor = vec3(0.09, 0.42, 0.70);\n\n\n//-----RAY MARCHING-----\nconst int maxSteps = 256;\nconst float maxDist = 1000.;\nconst float minDist = 0.01;\n\n\nsurf pigeon(in vec3 p, vec2 id, vec3 s)\n{\n    vec3 rand = vec3(random(id),random(id*2.),random(id/3.));\n    vec3 headPos = vec3(cos(iTime*4.*rand.x),5.+rand.y*4.,sin(iTime*4. * rand.z));\n    // BODY\n    surf shp = surfCaps(p, vec3(-1.,2.,0.), vec3(0.,2.,0.), 1., lowerBodyColor);\n    \n    surf nshp = surfSphere(p, vec3(-1.9,3,0.), .25, lowerBodyColor);\n    shp = sminS(shp, nshp, 0.3);\n    \n    //NECK\n    nshp = surfCaps(p, vec3(0.5,2.5,0.), headPos - vec3(0.,1.,0.), 1., UpperBodyColor);\n    shp = sminS(shp, nshp, 0.3);\n    \n    //HEAD\n    nshp = surfSphere(p, headPos, 1., UpperBodyColor);\n    shp = sminS(shp, nshp, 0.3);\n    \n    //EYES\n    nshp = surfEllips(p, headPos + vec3(0.2,0.,1.05) ,vec3(0.5,0.5,0.2), vec3(1.,1.,1.), vec3(.3,-0.3,0.));\n    shp = surfmin(shp, nshp);\n    \n    nshp = surfEllips(p, headPos + vec3(0.2,0.,-1.05),vec3(0.5,0.5,0.2), vec3(1.,1.,1.), vec3(-.3,0.3,0.));\n    shp = surfmin(shp, nshp);\n    \n    \n    nshp = surfEllips(p, headPos + vec3(0.2,0.,1.1) ,vec3(0.2,0.2,0.2), vec3(0.), vec3(.3,-0.3,0.));\n    shp = sminS(shp, nshp, 0.003);\n    nshp = surfEllips(p, headPos + vec3(0.2,0.,-1.1) ,vec3(0.2,0.2,0.2), vec3(0.), vec3(.3,-0.3,0.));\n    shp = sminS(shp, nshp, 0.003);\n    \n    //BEAK\n    nshp = surfBeak(p, headPos + vec3(1.2,-0.2,0.));\n    shp = surfmin(shp, nshp);\n    \n    //LEGS\n    nshp = surfLeg(p, vec3(0.1,1.2,0.7), vec3(0.,.0,.0));\n    shp = sminS(shp, nshp, 0.001);\n    \n    nshp = surfLeg(p, vec3(0.1,1.2,-0.7), vec3(0.,.0,.0));\n    shp = sminS(shp, nshp, 0.001);\n    \n    //Add box around the pigeon to help raymarch during warping\n    float box = sdBox(p - vec3(s.x/2. + 0.2, 0.,0.), vec3(0.005,100.,100.));\n    box = min(box, sdBox(p + vec3(s.x/2. + 0.2, 0.,0.), vec3(0.005,100.,100.)));\n    box = min(box, sdBox(p - vec3(0.,0., s.z/2. + 0.2), vec3(100.,100.,0.005)));\n    box = min(box, sdBox(p + vec3(0.,0., s.z/2. + 0.2), vec3(100.,100.,0.005)));\n    shp.d = min(shp.d, box);\n    \n    surf grd = ground(p, groundColor);\n    \n    shp = surfmin(shp, grd);\n    \n    return shp;\n}\n\n\nsurf world(vec3 p)\n{\n    vec3 s = vec3(5.,10000.,5.);\n    vec2 o = vec2(s.x,0.);\n    vec3 rp = mod(p,s)- vec3(s.x/2.,10,s.z/2.);\n    vec2 id = (p.xz - rp.xz)*1435.12;\n    surf c = pigeon(rp, id, s);\n    return c;\n}\n\n\n\nvec3 rayMarch(in vec3 ro, in vec3 rd)\n{\n    float curDist = 0.;\n    float minDistPassed = 1000.;\n    \n    for(int i = 0; i < maxSteps; ++i)\n    {\n        vec3 curPos = ro + curDist * rd;\n        \n        float closestDist = world(curPos).d;\n        \n        if(minDistPassed < 0.1 && closestDist > minDistPassed)\n            return vec3(0.2);\n        \n        minDistPassed = min(minDistPassed, closestDist);\n        \n        if(closestDist < minDist)\n        {\n            vec3 color = world(curPos).col; \n            float fi = float(i);\n            float fms = float(maxSteps);\n            float fog = max(curDist/maxDist, fi/fms);\n            \n            \n            color = mix(color, groundColor, fog);\n            return color;\n            \n        }\n        if(curDist > maxDist)\n            break;\n             \n        curDist += closestDist;\n    }\n    return groundColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n    vec2 uv = fragCoord/iResolution.x;\n    uv -= vec2(0.5, 0.5 * (iResolution.y/iResolution.x));\n    \n    vec3 camPos = vec3(-iTime*10.,25.,100);\n    vec3 ro = camPos;\n\tvec3 rd = normalize( vec3(p,-2.0) );\n    rd *= rotateY(2.);\n    rd *= rotateZ(.2);\n    \n    vec3 col = rayMarch(ro, rd); \n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nstruct surf\n{\n    vec3 col;\n    float d;\n};\n\nfloat random(vec2 co)\n{\n    co = mod(co, vec2(200.,200.));\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nsurf surfmin(surf a, surf b)\n{\n     float f = clamp(sign(a.d - b.d),0.,1.);\n     return surf(mix(a.col,b.col,f), mix(a.d,b.d,f));\n}\n\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nmat3 rotateEuler(vec3 rot)\n{\n    return rotateX(rot.x) * rotateY(rot.y) * rotateZ(rot.z);\n}\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdSphere(in vec3 p, in vec3 c, float r)\n{\n\treturn length(p - c) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nsurf ground(in vec3 p, in vec3 col)\n{\n    return surf(col, p.y + 0.3);\n}\n\nsurf surfSphere(in vec3 p, in vec3 c, float r, in vec3 col)\n{\n    surf shp;\n    shp.d = length(p - c) - r;\n    shp.col = col;\n    \n    return shp;\n} \n\n\n\n// quartic polynomial\nfloat smin( float a, float b, float k )\n{\n    k *= 16.0/3.0;\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min(a,b) - h*h*h*(4.0-h)*k*(1.0/16.0);\n}\n\nvec2 sminF(float a, float b, float k)\n{\n    float h = 1.0 - min( abs(a-b)/(4.0*k), 1.0 );\n    float w = h*h;\n    float m = w*0.5;\n    float s = w*k;\n    return (a<b) ? vec2(a-s,m) : vec2(b-s,1.0-m);\n}\n\nsurf sminS(surf a, surf b, float k)\n{\n    surf r;\n    r.d = smin(a.d,b.d, k);\n    vec2 colF = sminF(a.d,b.d, k);\n    r.col = mix(a.col, b.col, colF.y);\n    return r;\n}\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 pos, in vec3 r ) \n{\n    vec3 t = p - pos;\n    float k0 = length(t/r);\n    float k1 = length(t/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 pos, in vec3 r , vec3 rot) \n{\n    vec3 t = (p - pos) * rotateEuler(rot);\n    float k0 = length(t/r);\n    float k1 = length(t/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdRoundCone( vec3 p, vec3 a, vec3 b, float r1, float r2 )\n{\n  // sampling independent computations (only depend on shape)\n  vec3  ba = b - a;\n  float l2 = dot(ba,ba);\n  float rr = r1 - r2;\n  float a2 = l2 - rr*rr;\n  float il2 = 1.0/l2;\n    \n  // sampling dependant computations\n  vec3 pa = p - a;\n  float y = dot(pa,ba);\n  float z = y - l2;\n  float x2 = dot2( pa*l2 - ba*y );\n  float y2 = y*y*l2;\n  float z2 = z*z*l2;\n\n  // single square root!\n  float k = sign(rr)*rr*rr*x2;\n  if( sign(z)*a2*z2>k ) return  sqrt(x2 + z2)        *il2 - r2;\n  if( sign(y)*a2*y2<k ) return  sqrt(x2 + y2)        *il2 - r1;\n                        return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec3 pos, in float c, in float ra, in float rb)\n{\n    vec2 sc = vec2(sin(c),cos(c));\n    p -= pos;\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec3 pos, in float c, in float ra, in float rb, vec3 rot)\n{\n    vec2 sc = vec2(sin(c),cos(c));\n    p -= pos;\n    p *= rotateEuler(rot); \n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n\n\n\nsurf surfBeak(vec3 p, vec3 pos)\n{\n    float b = sdRoundCone(p, pos, pos + vec3(0.3,-0.15,0.0),0.2,0.1);\n    surf beak = surf(vec3(1.00, 0.82, 0.02), b);\n    float n = sdCappedTorus(p,pos, 1.3, 0.2,0.1, vec3(0.,1.7,0.));\n    surf nostril = surf(vec3(1.), n);\n    \n    return sminS(beak, nostril, 0.01);\n}\n\n\nsurf surfLeg(vec3 p, vec3 pos, vec3 rot)\n{\n    p = (p - pos) * rotateEuler(rot);\n    vec3 feetPos = - vec3(0.,1.5,0.);\n    \n    float leg = sdCapsule(p, vec3(0.), feetPos, 0.15);\n    float finger = sdCapsule(p, feetPos, feetPos - vec3(.65,0.,0.), 0.1);\n    leg = smin(leg, finger, 0.02);\n    finger = sdCapsule(p, feetPos, feetPos - vec3(-.8,0.,0.), 0.1);\n    leg = smin(leg, finger, 0.02);\n    finger = sdCapsule(p, feetPos, feetPos - vec3(-.7,0.,0.4), 0.1);\n    leg = smin(leg, finger, 0.02);\n    finger = sdCapsule(p, feetPos, feetPos - vec3(-.7,0.,-0.4), 0.1);\n    leg = smin(leg, finger, 0.02);\n    \n    \n    return surf(vec3(1.00, 0.82, 0.02),leg);\n}\n\n\nsurf surfCaps(vec3 p, vec3 a, vec3 b, float r, vec3 col){  return surf(col, sdCapsule(p, a, b, r));  }\n\nsurf surfEllips( in vec3 p, in vec3 pos, in vec3 r, in vec3 col){  return surf(col,sdEllipsoid(p,pos,r));  }\nsurf surfEllips( in vec3 p, in vec3 pos, in vec3 r, in vec3 col, vec3 rot){  return surf(col,sdEllipsoid(p,pos,r,rot));  }","name":"Common","description":"","type":"common"}]}