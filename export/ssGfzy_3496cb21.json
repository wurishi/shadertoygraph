{"ver":"0.1","info":{"id":"ssGfzy","date":"1658689251","viewed":93,"name":"Sphere Reflections","username":"rooby","description":"Reflective Spheres","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["reflection","domainrepetition","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 255\n#define MAX_DIST 100.\n#define MIN_DIST 0.0001\n\n#define PI 3.14159\n\nconst vec3 SUN_DIR = normalize(vec3(2., 0.5, 3.));\n\nconst vec3 SUN_COL = vec3(1.64, 1.27, 0.99);\nconst vec3 SKY_COL = vec3(0.16, 0.20, 0.28);\nconst vec3 IND_COL = vec3(0.40, 0.28, 0.20);\n\nconst vec3 FOG_COL = vec3(0.5, 0.6, 0.7);\n\n// Return 2D rotation matrix of angle a\nmat2 rot(float a)\n{\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n// polynomial smooth min\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\n// Check if the given material is reflective\nbool isReflective(int mat_type)\n{\n    return mat_type == 0;\n}\n\n// Return the material color at the given position in the scene\nvec3 getMaterial(vec3 pos, vec3 normal, int mat_type)\n{\n    vec3 mat;\n    \n    if (mat_type == 0)\n        mat = 0.8*vec3(0.16, 0.24, 0.33);\n    else if (mat_type == 1)\n    {\n        vec3 center = vec3(round(pos.xy/5.)*5., 0);\n        int i = int(100.*(1.+sin(5.*(center.x*center.y)))) % 5;\n    \n        if (i == 0)\n            mat = vec3(0.82, 0.08, 0.12);\n        else if (i == 1)\n            mat = vec3(0.7, 0.7, 0.05);\n        else if (i == 2)\n            mat = vec3(0.65, 0.15, 0.75);\n        else if (i == 3)\n            mat = vec3(0.12, 0.8, 0.1);\n        else if (i == 4)\n            mat = vec3(0.05, 0.2, 0.9);\n    }\n    \n    return mat;\n}\n\n// Return signed distance to nearest object in the scene\n// along with the material type of that object\nvec2 scene(vec3 pos)\n{\n    float d;\n    int mat_type = 0;\n\n    vec3 center = vec3(round(pos.xy/5.)*5., 0);\n\n    float radius = 1. + 0.5*sin(7.*(center.x+center.y));\n    float d_sphere = length(pos - center + vec3(0, 0, 1. - radius)) - radius;\n    \n    float d_ground = pos.z + 1.;\n    \n    d = smin(d_sphere, d_ground, 0.05);\n    \n    if (d == d_sphere)\n        mat_type = 1;\n\n    return vec2(d, mat_type);\n}\n\n// Return the normal vector to the scene at the given position pos\nvec3 getNormal(vec3 pos)\n{\n    vec2 u = vec2(0.0001, 0);\n    return normalize(vec3(scene(pos + u.xyy).x - scene(pos - u.xyy).x,\n                          scene(pos + u.yxy).x - scene(pos - u.yxy).x,\n                          scene(pos + u.yyx).x - scene(pos - u.yyx).x));\n}\n\n// Standard raymarching function\n// Returns depth from rayOrigin along rayDir to closet object,\n// along with material type and soft shadow factor\nvec3 rayMarch(vec3 rayOrigin, vec3 rayDir)\n{\n    float depth = 0.003;\n    float shadow = 1.;\n    float ph = 1e20;\n\n    for (int i=0; i<MAX_STEPS; i++)\n    {\n        vec3 pos = rayOrigin + depth*rayDir;\n        vec2 dist = scene(pos);\n        \n        depth += dist.x;\n        \n        float y = dist.x*dist.x/(2.0*ph);\n        float d = sqrt(dist.x*dist.x-y*y);\n        shadow = min(shadow, 8.*d/max(0.0,depth-y) );\n        \n        if (depth > MAX_DIST) break;\n        if (abs(dist.x) < MIN_DIST) return vec3(depth, dist.y, shadow);\n    }\n    \n    return vec3(-1, 0, shadow);\n}\n\n// Return color at given position\nvec3 getColor(vec3 pos, vec3 normal, int mat_type)\n{\n    vec3 mat = getMaterial(pos, normal, mat_type);\n    \n    // Intensities of different light sources\n    float sun_int = clamp(dot(normal, SUN_DIR), 0., 1.);\n    float sky_int = clamp(0.5 + 0.5*normal.z, 0., 1.);\n    float ind_int = clamp(dot(normal, normalize(vec3(-SUN_DIR.xy, 0))), 0., 1.);\n    \n    // Do shadow\n    vec3 d = rayMarch(pos + 0.003*normal, SUN_DIR);\n    float sha = d.z;\n    \n    // Add lighting\n    vec3 lighting = sha*sun_int*SUN_COL + sky_int*SKY_COL + ind_int*IND_COL;\n    vec3 col = lighting * mat;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in  vec2 fragCoord )\n{\n    // Normalized pixel coordinates\n    vec2 uv = 2.*(fragCoord - .5*iResolution.xy) / iResolution.y;\n\n    // Camera origin and direction\n    vec3 rayOrigin = vec3(0, -3, 0);\n    vec3 rayDir = normalize(vec3(uv.x, 1, uv.y));\n    \n    // Camera rotation\n    mat2 rot_mat = rot(0.2*iTime);\n    rayOrigin += vec3(2.5*sin(iTime/5.*PI), iTime, 0);\n    rayDir = vec3(rot_mat*rayDir.xy, rayDir.z);\n\n    // Do raymarching\n    vec3 d = rayMarch(rayOrigin, rayDir);\n    float depth = d.x;\n    int mat_type = int(d.y);\n    vec3 pos = rayOrigin + depth*rayDir;\n    \n    vec3 col = (1.5 - 0.5*exp(0.35*uv.y)) * vec3(0.09, 0.4, 1.2); // Sky color\n    \n    // If object hit, render it\n    if (depth > 0.)\n    {\n        vec3 normal = getNormal(pos);\n        col = vec3(0.);\n        \n        // Reflect object\n        if (isReflective(mat_type))\n        {\n            vec3 ref = normalize(reflect(rayDir, normal));\n            vec3 ref_d = rayMarch(pos + 0.003*normal, ref);\n            float ref_depth = ref_d.x; int ref_mat_type = int(ref_d.y);\n            vec3 ref_pos = pos + ref_depth*ref;\n            vec3 ref_normal = getNormal(ref_pos);\n            \n            if (ref_depth > 0.)\n                col = 0.35*getColor(ref_pos, ref_normal, ref_mat_type);\n        }\n        \n        col += getColor(pos, normal, mat_type);\n        \n        // Apply fog\n        float fog_int = 1. - exp(-depth*0.02);\n        col = mix(col, FOG_COL, fog_int);\n    }\n\n    // Gamma correction\n    col = pow(col, vec3(1./2.2));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}