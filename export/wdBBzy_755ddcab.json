{"ver":"0.1","info":{"id":"wdBBzy","date":"1590525574","viewed":176,"name":"2d raymarch","username":"thunderklaus","description":"2d visibility demo using ray marching.\nUse your mouse to move the light","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","raymarch","visibility"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_STEPS = 250;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.001;\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\n\n\nfloat opRound(float d, float radius)\n{\n    return d - radius;\n}\n\n\nvec2 opRepeat(vec2 p, vec2 c)\n{\n    vec2 q = mod(p+0.5*c,c)-0.5*c;\n    return q;\n}\n\n\nfloat sdCircle(vec2 p, float r ) \n{\n    return length(p)-r;\n}\n\nfloat sdBox(vec2 p, vec2 size)\n{\n    vec2 d = abs(p)-size;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\nfloat sdScene(vec2 p) {\n    float d = sdCircle(p - vec2(0.25,0.25), 0.2);\n\td = opSmoothUnion(d, opRound(sdBox(p - vec2(1.0,0.25), vec2(0.6,0.05)), 0.02), 0.25);\n    vec2 repP = opRepeat(p, vec2(0.10,0.0));\n    d = opUnion(d, sdCircle(repP - vec2(0.0,0.8), 0.025));\n    return d;\n}\n\nfloat map(vec2 uv, vec2 eye) {\n    vec2 eyeVec = uv - eye;\n\tfloat maxDist = length(eyeVec);\n\tvec2 eyeVecNorm = normalize(eyeVec);\n    float depth = 0.0;\n    for (int i=0; i < MAX_STEPS; ++i) {\n        vec2 p = eye + eyeVecNorm * depth;\n        float dist = sdScene(p);\n        if (dist < EPSILON) {\n            // Return how far the ray entered the wall, negative\n            return depth - maxDist;\n        }\n        depth += dist;\n        if (depth > maxDist) {\n            return MAX_DIST;\n        }\n        if (depth > MAX_DIST) {\n            return MAX_DIST;\n        }\n    }\n    return depth;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 eye = iMouse.xy/iResolution.y;\n    vec2 eyeVec = uv - eye;\n\tfloat maxDist = length(eyeVec);\n\tvec2 eyeVecNorm = normalize(eyeVec);\n    float eyeDist = map(uv, eye);\n    float wallDist = sdScene(uv);\n    bool visible = eyeDist >= 0.0;\n    float w = clamp(1.0-abs(wallDist*100.0), 0.0, 1.0);\n    w += pow(clamp(1.0-maxDist, 0.0, 1.0), 4.0);\n    w *= visible ? 1.0 : 0.0;\n    w = pow(w, 1.0/2.2); // apply gamma correction\n    fragColor = vec4(w,w,w,1.0);\n}\n","name":"Image","description":"","type":"image"}]}