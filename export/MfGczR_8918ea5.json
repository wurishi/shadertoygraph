{"ver":"0.1","info":{"id":"MfGczR","date":"1731400976","viewed":86,"name":"RC Copy from Mathis ","username":"yuletian","description":"RC Copy From  Mathis ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["rc"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nRadiance Cascades 3D\n    Combining radiance cascades with radiosity/irradiance methods\n    This implementation is not perfect, see comments below :)\n\n\nCascades\n    Cubemap layout\n        Traces 1 ray per pixel, smallest probe is a 2x2 quad\n        Like radiosity and irradiance methods, probes/rays exist on the surface of geometry -> good memory scaling\n        5 cascades are used in this shader\n    Ray tracing\n        Rays are traced with different lengths between cascades\n        Their distribution causes the resolution in phi to be a semilinear function of theta -> bins_phi = 4 + 8*theta_bin_index\n    Merging\n        Cascades are merged by linearly interpolating along the parent rays\n        Spatial interpolation is weighted based on local visibility, approximated by the probes traced rays\n    Primary ray sampling\n        Uses normal bilinear interpolation when reading the cascades\n\n\nFlickering\n    A consequence of (mainly) temporally merging cascades and static probe positions\n\n\nLight leaking from interpolation\n    This implementation samples the smallest probes using naive bilinear interpolation, leading\n    to some light leaking close to geometry\n        A solution is to use weighted interpolation here as well\n\n\nThis implementation is pretty simple and should be extended:\n    Dynamic probe positions\n        Moving/complex geometry/light can cause spikes/flickering with static probes\n        A solution like RTXGI could work as an example\n    Can be extended to integrate more complex BRDFs\n        An idea is to importance sample both ray directions and probe positions based on screen space BRDF changes\n        Otherwise hgih frequency detail would be blurred away\n\n\nFeedback is welcome! :)\n\n\nControls\n    Press and move mouse in x-axis to control camera\n*/\n\nvec4 TextureCube(vec2 uv, float lod) {\n    //Samples the cubemap\n    float tcSign = -mod(floor(uv.y*I1024), 2.)*2. + 1.;\n    vec3 tcD = vec3(vec2(uv.x, mod(uv.y, 1024.))*I512 - 1., tcSign);\n    if (uv.y > 4096.) tcD = tcD.xzy;\n    else if (uv.y > 2048.) tcD = tcD.zxy;\n    return textureLod(iChannel3, tcD, lod);\n}\n\nvec3 AcesFilm(vec3 x) {\n    //Aces film curve\n    return clamp((x*(2.51*x + 0.03))/(x*(2.43*x + 0.59) + 0.14), 0., 1.);\n}\n\nvoid GIResultOut(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 Color = vec3(0.);\n    vec3 sunDir = GetSunDirection(iTime);\n    vec3 sunLight = GetSunLight(iTime);\n    \n    float nt = CYCLETIME_OFFSET + iTime*ICYCLETIME;\n    //if (iMouse.z > 0.) nt = nt*0. + (iMouse.x - iMouse.z)*2./(iResolution.x*ICYCLETIME);\n    float cycleTime = (nt - CYCLETIME_OFFSET)*2.;\n    vec3 pPos = vec3(0.5, 0.2, 0.2 + (cos(cycleTime)*0.5 + 0.5)*0.6);\n    float sunA = nt*2.4;\n    vec3 pEyeTarget = vec3(sin(sunA)*0.5 + 0.5, 0.1, cos(sunA)*0.5 + 0.5);\n    vec3 pEye = normalize(pEyeTarget - pPos);\n    vec3 pDir = normalize(vec3((fragCoord*IRES*2. - 1.)*ASPECT, 1.)*TBN(pEye));\n    \n    HIT rayHit = TraceRay(pPos, pDir, 1000000., iTime);\n    if (rayHit.n.x > -15.) {\n        if (rayHit.c.x < -1.5) {\n            //Reflective\n            vec3 rDir = reflect(pDir, rayHit.n);\n            HIT rayHit2 = TraceRay(pPos + pDir*rayHit.t + rayHit.n*0.001, rDir, 1000000., iTime);\n            if (rayHit2.n.x > -15.) {\n                if (rayHit.c.x > 1.) {\n                    //Emissive\n                    Color += rayHit.c;\n                } else if (dot(rayHit2.n, rDir) < 0.) {\n                    vec2 suv = clamp(rayHit2.uv*128., vec2(0.5), rayHit2.res*0.5 - 0.5) + rayHit2.uvo;\n                    Color = TextureCube(suv, 0.).xyz + TextureCube(suv + vec2(rayHit2.res.x*0.5, 0.), 0.).xyz +\n                            TextureCube(suv + vec2(0., rayHit2.res.y*0.5), 0.).xyz + TextureCube(suv + rayHit2.res*0.5, 0.).xyz;\n                    \n                    //Sunlight\n                    vec3 sPos = pPos + pDir*rayHit.t + rayHit.n*0.001 + rDir*rayHit2.t + rayHit2.n*0.001;\n                    if (dot(rayHit2.n, sunDir) > 0.) {\n                        if (TraceRay(sPos, sunDir, 10000., iTime).n.x < -1.5) Color += sunLight*dot(rayHit2.n, sunDir);\n                    }\n\n                    //Color\n                    Color *= rayHit2.c;\n                }\n            } else {\n                Color = GetSkyLight(rDir);\n            }\n        } else if (rayHit.c.x > 1.) {\n            //Emissive\n            Color += rayHit.c;\n        } else {\n            if (dot(rayHit.n, pDir) < 0.) {\n                vec2 suv = clamp(rayHit.uv*128., vec2(0.5), rayHit.res*0.5 - 0.5) + rayHit.uvo;\n                Color = TextureCube(suv, 0.).xyz + TextureCube(suv + vec2(rayHit.res.x*0.5, 0.), 0.).xyz +\n                        TextureCube(suv + vec2(0., rayHit.res.y*0.5), 0.).xyz + TextureCube(suv + rayHit.res*0.5, 0.).xyz;\n            \n                //Sunlight\n                vec3 sPos = pPos + pDir*rayHit.t + rayHit.n*0.001;\n                if (dot(rayHit.n, sunDir) > 0.) {\n                    if (TraceRay(sPos, sunDir, 10000., iTime).n.x < -1.5) Color += sunLight*dot(rayHit.n, sunDir);\n                }\n\n                //Color\n                Color *= rayHit.c;\n            }\n        }\n    } else {\n        Color = GetSkyLight(pDir);\n    }\n    \n    \n    //Visualize cubemap\n    //Color = TextureCube(floor(fragCoord) + 0.5 + vec2(0., max(0., iMouse.y - 100.)*IRES.y*2000.*1. + 243.*0.), 0.).xyz;\n    \n    \n    fragColor = vec4(pow(AcesFilm(max(vec3(0.), Color)), vec3(0.45)), 1.);\n}\n\nvoid GICubeOut(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 Color = TextureCube(floor(fragCoord) + 0.5 + vec2(0., max(0., iMouse.y - 100.)*IRES.y*2000.*1. + 243.*0.), 0.);\n    vec4 PostAcesColor = vec4(pow(AcesFilm(max(vec3(0.), Color.xyz)), vec3(0.45)), 1.);\n    fragColor = PostAcesColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 mousePos = iMouse.xy / iResolution.xy;  // normalize mouse position\n    vec4 GIFragColor = vec4(0,0,0,1);\n    vec4 DebugCube = vec4(0,0,0,1);\n    // calc GI\n    GIResultOut(GIFragColor, fragCoord);\n    GICubeOut(DebugCube, fragCoord);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 ScreenUV = fragCoord/iResolution.xy;\n    if(mousePos.x < ScreenUV.x)\n    {\n        fragColor = GIFragColor;\n    }\n    else\n    {\n        fragColor = DebugCube;\n    }\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//CONST\nconst float ICYCLETIME = 1./5.;\nconst float CYCLETIME_OFFSET = 1.;\nconst float I256 = 1./256.;\nconst float I512 = 1./512.;\nconst float I1024 = 1./1024.;\n\n//DEFINE\n#define RES iResolution.xy\n#define IRES 1./iResolution.xy\n#define ASPECT vec2(iResolution.x/iResolution.y,1.)\n\n//STRUCT\nstruct HIT { float t; vec2 uv; vec2 uvo; vec2 res; vec3 n; vec3 c; };\n\n//SDF\nvec2 Rotate2(vec2 p, float ang) {\n    //Rotates p *ang* radians\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nvec2 Repeat2(vec2 p, float n) {\n    //Repeats p in a PI*2/n segment\n    float ang = 2.*3.141592653/n;\n    float sector = floor(atan(p.x, p.y)/ang + 0.5);\n    return Rotate2(p, sector*ang);\n}\n\nfloat DFBox(vec2 p, vec2 b) {\n    //Distance field to box\n    vec2 d = abs(p - b*0.5) - b*0.5;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat DFBox(vec3 p, vec3 b) {\n    //Distance field to box\n    vec3 d = abs(p - b*0.5) - b*0.5;\n    return min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\n\n//ANIMATED\nvec3 GetSkyLight(vec3 d) {\n    //Sky light function\n    return vec3(0.7, 0.8, 1.)*(1. - d.y*0.5);\n}\n\nvec3 GetSunLight(float t) {\n    //Sun light function\n    float nt = CYCLETIME_OFFSET + t*ICYCLETIME;\n    return vec3(1., 0.9, 0.65)*2.5;\n}\n\nvec3 GetSunDirection(float t) {\n    //Sun direction function\n    float nt = CYCLETIME_OFFSET + t*ICYCLETIME;\n    return normalize(vec3(-sin(nt*2.4), 1., -cos(nt*2.4)));\n}\n\nbool InteriorIntersection(vec3 p) {\n    //Intersection function when tracing interior wall\n    if (length(p.xy - vec2(0.5, 0.)) < 0.25) return true;\n    if (length(p.xy - vec2(0.87, 0.25)) < 0.12) return true;\n    return false;\n}\n\nbool DFIntersection(vec3 p, float t) {\n    //Intersection function when tracing geometry\n    float nt = CYCLETIME_OFFSET + t*ICYCLETIME;\n    \n    vec3 rp = p - vec3(0.21 + (sin(nt)*0.5 + 0.5)*0.58, 0.5, 0.21 + (cos(nt)*0.5 + 0.5)*0.58);\n    vec2 rep = Repeat2(rp.xz, 8.);\n    float r = length(rp.xz);\n    if (p.y > 0.49 && abs(p.z - 0.5) > 0.04 && r < 0.2 && abs(r - 0.1375) > 0.01 &&\n        DFBox(vec2(rep.x + 0.01, rep.y - 0.015), vec2(0.02, 0.3)) > 0.) return true;\n    \n    return false;\n}\n\n//RT\nvec3 AQuad(vec3 p, vec3 d, vec3 vTan, vec3 vBit, vec3 vNor, vec2 pSize) {\n    //Analytic intersection of quad\n    float norDot = dot(vNor, d);\n    float pDot = dot(vNor, p);\n    if (sign(norDot*pDot) < -0.5) {\n        float t = -pDot/norDot;\n        vec2 hit2 = vec2(dot(p + d*t, vTan), dot(p + d*t, vBit));\n        if (DFBox(hit2, pSize) <= 0.) return vec3(hit2, t);\n    }\n    return vec3(-1.);\n}\n\nvec2 ABox(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax) {\n    //Analytc intersection of box\n    vec3 tMin = (bmin - origin)*dir;\n    vec3 tMax = (bmax - origin)*dir;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    return vec2(max(max(t1.x, t1.y), t1.z), min(min(t2.x, t2.y), t2.z));\n}\n\nvec2 ABoxNormal(vec3 origin, vec3 idir, vec3 bmin, vec3 bmax, out vec3 N) {\n    //Returns near/far, near normal as out\n    vec3 tMin = (bmin - origin)*idir;\n    vec3 tMax = (bmax - origin)*idir;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    vec3 signdir = -(max(vec3(0.), sign(idir))*2. - 1.);\n    if (t1.x > max(t1.y, t1.z)) N = vec3(signdir.x, 0., 0.);\n    else if (t1.y > t1.z) N = vec3(0., signdir.y, 0.);\n    else N = vec3(0., 0., signdir.z);\n    return vec2(max(max(t1.x, t1.y), t1.z), min(min(t2.x, t2.y), t2.z));\n}\n\nfloat ASphere(vec3 p, vec3 d, float r) {\n    //Analytic intersection of sphere\n    float a = dot(p, p) - r*r;\n    float b = 2.*dot(p, d);\n    float re = b*b*0.25 - a;\n    if (dot(p, d) < 0. && re > 0.) {\n        float st = -b*0.5 - sqrt(re);\n        return st;\n    }\n    return -1.;\n}\n\nfloat ACylZ(vec3 p, vec3 d, float r) {\n    //Analytic intersection of cylinder along Z\n    float a = (dot(p.xy, p.xy) - r*r)/dot(d.xy, d.xy);\n    float b = 2.*dot(p.xy, d.xy)/dot(d.xy, d.xy);\n    float re = b*b*0.25 - a;\n    if (re > 0.) {\n        float st = -b*0.5 + sqrt(re);\n        return st;\n    }\n    return -1.;\n}\n\nHIT TraceRay(vec3 p, vec3 d, float maxt, float time) {\n    //Ray intersection function\n    HIT info = HIT(maxt, vec2(-1.), vec2(-1.), vec2(-1.), vec3(-20.), vec3(-1.));\n    vec3 uvt, sp;\n    vec2 bb;\n    float st;\n    \n    //Floor\n    uvt = AQuad(p, d, vec3(1., 0., 0.), vec3(0., 0., 1.), vec3(0., 1., 0.), vec2(1., 1.));\n    if (uvt.z > -0.5 && uvt.z < info.t && !DFIntersection(p + d*uvt.z, time))\n        info = HIT(uvt.z, uvt.xy, vec2(0., 0.), vec2(256.), vec3(0., 1., 0.), vec3(0.9));\n    \n    //Ceiling\n    uvt = AQuad(p - vec3(0., 0.5, 0.), d, vec3(1., 0., 0.), vec3(0., 0., 1.), vec3(0., 1., 0.), vec2(1., 1.));\n    if (uvt.z > -0.5 && uvt.z < info.t && !DFIntersection(p + d*uvt.z, time))\n        info = HIT(uvt.z, uvt.xy, vec2(256., 0.), vec2(256.), vec3(0., -1., 0.), vec3(0.9));\n    \n    //Walls X 1 x 0.5\n    uvt = AQuad(p, d, vec3(0., 1., 0.), vec3(0., 0., 1.), vec3(1., 0., 0.), vec2(0.5, 1.));\n    if (uvt.z > -0.5 && uvt.z < info.t && !DFIntersection(p + d*uvt.z, time))\n        info = HIT(uvt.z, uvt.xy, vec2(512., 0.), vec2(128., 256.), vec3(1., 0., 0.), vec3(0.9, 0.1, 0.1));\n    uvt = AQuad(p - vec3(1., 0., 0.), d, vec3(0., 1., 0.), vec3(0., 0., 1.), vec3(-1., 0., 0.), vec2(0.5, 1.));\n    if (uvt.z > -0.5 && uvt.z < info.t && !DFIntersection(p + d*uvt.z, time))\n        info = HIT(uvt.z, uvt.xy, vec2(640., 0.), vec2(128., 256.), vec3(-1., 0., 0.), vec3(0.05, 0.95, 0.1));\n    \n    //Walls Z 1 x 0.5\n    uvt = AQuad(p, d, vec3(0., 1., 0.), vec3(1., 0., 0.), vec3(0., 0., -1.), vec2(0.5, 1.));\n    if (uvt.z > -0.5 && uvt.z < info.t && !DFIntersection(p + d*uvt.z, time))\n        info = HIT(uvt.z, uvt.xy, vec2(768., 0.), vec2(128., 256.), vec3(0., 0., 1.), vec3(0.9));\n    uvt = AQuad(p - vec3(0., 0., 1.), d, vec3(0., 1., 0.), vec3(1., 0., 0.), vec3(0., 0., -1.), vec2(0.5, 1.));\n    if (uvt.z > -0.5 && uvt.z < info.t && !DFIntersection(p + d*uvt.z, time))\n        info = HIT(uvt.z, uvt.xy, vec2(896., 0.), vec2(128., 256.), vec3(0., 0., -1.), vec3(0.9));\n    \n    //Interior wall\n    uvt = AQuad(p - vec3(0., 0., 0.47 - 1./256.), d, vec3(0., 1., 0.), vec3(1., 0., 0.), vec3(0., 0., -1.), vec2(0.5, 1.));\n    if (uvt.z > -0.5 && uvt.z < info.t && !InteriorIntersection(p + d*uvt.z))\n        info = HIT(uvt.z, uvt.xy, vec2(0., 1536), vec2(128., 256.), vec3(0., 0., -1.), vec3(0.99));\n    uvt = AQuad(p - vec3(0., 0., 0.53 - 1./256.), d, vec3(0., 1., 0.), vec3(1., 0., 0.), vec3(0., 0., -1.), vec2(0.5, 1.));\n    if (uvt.z > -0.5 && uvt.z < info.t && !InteriorIntersection(p + d*uvt.z))\n        info = HIT(uvt.z, uvt.xy, vec2(128., 1536.), vec2(128., 256.), vec3(0., 0., 1.), vec3(0.99));\n    sp = p - vec3(0.5, 0., 0.);\n    st = ACylZ(sp, d, 0.25);\n    if (st > 0. && st < info.t && sp.z + d.z*st >= 0.47 - 1./256. && sp.z + d.z*st <= 0.53 - 1./256.)\n        info = HIT(st, vec2(1.), vec2(-1.), vec2(-1.), vec3(-normalize(sp.xy + d.xy*st), 0.), vec3(0.));\n    sp = p - vec3(0.87, 0.25, 0.);\n    st = ACylZ(sp, d, 0.12);\n    if (st > 0. && st < info.t && sp.z + d.z*st >= 0.47 - 1./256. && sp.z + d.z*st <= 0.53 - 1./256.)\n        info = HIT(st, vec2(1.), vec2(-1.), vec2(-1.), vec3(-normalize(sp.xy + d.xy*st), 0.), vec3(0.));\n    \n    \n    //Mirror sphere\n    sp = p - vec3(0.15, 0.1005, 0.3);\n    st = ASphere(sp, d, 0.1);\n    if (st > -0.5 && st < info.t) info = HIT(st, vec2(1.), vec2(-1.), vec2(-1.), normalize(sp + d*st), vec3(-2.));\n    \n    // emissive sphere\n    sp = p - vec3(0.7, 0.1005, 0.1);\n    st = ASphere(sp, d, 0.05);\n    if (st > -0.5 && st < info.t) info = HIT(st, vec2(1.), vec2(-1.), vec2(-1.), normalize(sp + d*st), vec3(2.));\n    \n    //Mirror box\n    vec3 sn;\n    vec3 sd = d;\n    sp = p - vec3(0.86, 0.14, 0.86);\n    sd = normalize(sd);\n    bb = ABoxNormal(sp, 1./sd, vec3(-0.08), vec3(0.08), sn);\n    if (bb.x > 0. && bb.y > bb.x && bb.x < info.t) {\n        info = HIT(bb.x, vec2(1.), vec2(-1.), vec2(-1.), normalize(sn), vec3(-2.));\n    }\n    \n    return info;\n}\n\n//MATH\nmat3 TBN(vec3 N) {\n    //Naive TBN matrix creation\n    vec3 Nb, Nt;\n    if (abs(N.y) > 0.999) {\n        Nb = vec3(1., 0., 0.);\n        Nt = vec3(0., 0., 1.);\n    } else {\n    \tNb = normalize(cross(N, vec3(0., 1., 0.)));\n    \tNt = normalize(cross(Nb, N));\n    }\n    return mat3(Nb.x, Nt.x, N.x, Nb.y, Nt.y, N.y, Nb.z, Nt.z, N.z);\n}\n\nvec3 BRDF_GGX(vec3 w_o, vec3 w_i, vec3 n, float alpha, vec3 F0) {\n    //BRDF GGX\n    vec3 h = normalize(w_i + w_o);\n    float a2 = alpha*alpha;\n    float D = a2/(3.141592653*pow(pow(dot(h, n), 2.)*(a2 - 1.) + 1., 2.));\n    vec3 F = F0 + (1. - F0)*pow(1. - dot(n, w_o), 5.);\n    float k = a2*0.5;\n    float G = 1./((dot(n, w_i)*(1. - k)+k)*(dot(n, w_o)*(1. - k) + k));\n    vec3 OUT = F*(D*G*0.25);\n    return ((isnan(OUT) != bvec3(false)) ? vec3(0.) : OUT);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"//Cascades and merging\n\nvec4 TextureCube(vec2 uv) {\n    //Samples the cubemap\n    float tcSign = -mod(floor(uv.y*I1024), 2.)*2. + 1.;\n    vec3 tcD = vec3(vec2(uv.x, mod(uv.y, 1024.))*I512 - 1., tcSign);\n    if (uv.y > 4096.) tcD = tcD.xzy;\n    else if (uv.y > 2048.) tcD = tcD.zxy;\n    return textureLod(iChannel3, tcD, 0.);\n}\n\nvec4 TextureCube(vec2 uv, float lod) {\n    //Samples the cubemap\n    float tcSign = -mod(floor(uv.y*I1024), 2.)*2. + 1.;\n    vec3 tcD = vec3(vec2(uv.x, mod(uv.y, 1024.))*I512 - 1., tcSign);\n    if (uv.y > 4096.) tcD = tcD.xzy;\n    else if (uv.y > 2048.) tcD = tcD.zxy;\n    return textureLod(iChannel3, tcD, lod);\n}\n\nvec4 WeightedSample(vec2 luvo, vec2 luvd, vec2 luvp, vec2 uvo, vec3 probePos,\n                    vec3 gTan, vec3 gBit, vec3 gPos, float lProbeSize) {\n    //Approximate probe visibility weighting (flatland assumption)\n    vec3 lastProbePos = gPos + gTan*(luvp.x*lProbeSize/256.) + gBit*(luvp.y*lProbeSize/256.);\n    vec3 relVec = probePos - lastProbePos;\n    float theta = (lProbeSize*0.5 - 0.5)/(lProbeSize*0.5)*3.141592653*0.5;\n    float phi = atan(-dot(relVec, gTan), -dot(relVec, gBit));\n    float phiI = floor((phi/3.141592653*0.5 + 0.5)*(4. + 8.*(lProbeSize*0.5 - 1.))) + 0.5;\n    vec2 phiUV;\n    float phiLen = lProbeSize - 1.;\n    if (phiI < phiLen) phiUV = vec2(lProbeSize - 0.5, lProbeSize - phiI);\n    else if (phiI < phiLen*2.) phiUV = vec2(lProbeSize - (phiI - phiLen), 0.5);\n    else if (phiI < phiLen*3.) phiUV = vec2(0.5, phiI - phiLen*2.);\n    else phiUV = vec2(phiI - phiLen*3., lProbeSize - 0.5);\n    float lProbeRayDist = TextureCube(luvo + floor(phiUV)*uvo + luvp).w;\n    if (lProbeRayDist < -0.5 || length(relVec) < lProbeRayDist*cos(3.141592653*0.5 - theta) + 0.01) {\n        vec2 luv = luvo + luvd + clamp(luvp, vec2(0.5), uvo - 0.5);;\n        return vec4(TextureCube(luv).xyz + TextureCube(luv + vec2(uvo.x, 0.)).xyz +\n                    TextureCube(luv + vec2(0., uvo.y)).xyz + TextureCube(luv + uvo).xyz, 1.);\n    }\n    return vec4(0.);\n}\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir) {\n    vec4 Output = texture(iChannel3, rayDir);\n    vec2 UV; vec3 aDir = abs(rayDir);\n    vec4 UVDebugColor = vec4(0,0,0,0);\n    if (aDir.z > max(aDir.x, aDir.y)) {\n        //Z-side\n        UV = floor(((rayDir.xy/aDir.z)*0.5 + 0.5)*1024.) + 0.5;\n        if (rayDir.z < 0.) UV.y += 1024.;\n        UVDebugColor = vec4(1,0,0,0);\n    } else if (aDir.x > aDir.y) {\n        //X-side\n        UV = floor(((rayDir.yz/aDir.x)*0.5 + 0.5)*1024.) + 0.5;\n        if (rayDir.x > 0.) UV.y += 2048.;\n        else UV.y += 3072.;\n        UVDebugColor = vec4(0,1,0,0);\n    } else {\n        //Y-side\n        UV = floor(((rayDir.xz/aDir.y)*0.5 + 0.5)*1024.) + 0.5;\n        if (rayDir.y > 0.) UV.y += 4096.;\n        else UV.y += 5120.;\n        UVDebugColor = vec4(0,0,1,0);\n    }\n    if (DFBox(UV, vec2(1024., (256.*6.)*2.)) < 0.) {\n        //Cascades\n        Output = vec4(0.); \n        vec2 gRes;\n        vec3 gTan, gBit, gNor, gPos;\n        \n        //Hardcoded geometry\n        if (UV.y < 256.*6.) {\n            if (UV.x < 256.) {\n                gTan = vec3(1., 0., 0.);\n                gBit = vec3(0., 0., 1.);\n                gNor = vec3(0., 1., 0.);\n                gPos = vec3(0., 0., 0.);\n                gRes = vec2(256.);\n            } else if (UV.x < 512.) {\n                gTan = vec3(1., 0., 0.);\n                gBit = vec3(0., 0., 1.);\n                gNor = vec3(0., -1., 0.);\n                gPos = vec3(0., 0.5, 0.);\n                gRes = vec2(256.);\n            } else if (UV.x < 640.) {\n                gTan = vec3(0., 1., 0.);\n                gBit = vec3(0., 0., 1.);\n                gNor = vec3(1., 0., 0.);\n                gPos = vec3(0., 0., 0.);\n                gRes = vec2(128., 256.);\n            } else if (UV.x < 768.) {\n                gTan = vec3(0., 1., 0.);\n                gBit = vec3(0., 0., 1.);\n                gNor = vec3(-1., 0., 0.);\n                gPos = vec3(1., 0., 0.);\n                gRes = vec2(128., 256.);\n            } else if (UV.x < 896.) {\n                gTan = vec3(0., 1., 0.);\n                gBit = vec3(1., 0., 0.);\n                gNor = vec3(0., 0., 1.);\n                gPos = vec3(0., 0., 0.);\n                gRes = vec2(128., 256.);\n            } else {\n                gTan = vec3(0., 1., 0.);\n                gBit = vec3(1., 0., 0.);\n                gNor = vec3(0., 0., -1.);\n                gPos = vec3(0., 0., 1.);\n                gRes = vec2(128., 256.);\n            }\n        } else {\n            if (UV.x < 128.) {\n                gTan = vec3(0., 1., 0.);\n                gBit = vec3(1., 0., 0.);\n                gNor = vec3(0., 0., -1.);\n                gPos = vec3(0., 0., 0.47 - 1./256.);\n                gRes = vec2(128., 256.);\n            } else if (UV.x < 256.) {\n                gTan = vec3(0., 1., 0.);\n                gBit = vec3(1., 0., 0.);\n                gNor = vec3(0., 0., 1.);\n                gPos = vec3(0., 0., 0.53 - 1./256.);\n                gRes = vec2(128., 256.);\n            }\n        }\n        \n        //Probe ray distribution\n        vec3 sunDir = GetSunDirection(iTime);\n        vec3 sunLight = GetSunLight(iTime);\n        vec2 modUV = mod(UV, gRes);\n        float probeCascade = floor(mod(UV.y, 1536.)/256.);\n        float probeSize = pow(2., probeCascade + 1.);\n        vec2 probePositions = gRes/probeSize;\n        vec3 probePos = gPos + mod(modUV.x, probePositions.x)*probeSize/256.*gTan +\n                               mod(modUV.y, probePositions.y)*probeSize/256.*gBit;\n        vec2 probeUV = floor(modUV/probePositions) + 0.5;\n        vec2 probeRel = probeUV - probeSize*0.5;\n        float probeThetai = max(abs(probeRel.x), abs(probeRel.y));\n        float probeTheta = probeThetai/probeSize*3.14192653;\n        float probePhi = 0.;\n        if (probeRel.x + 0.5 > probeThetai && probeRel.y - 0.5 > -probeThetai) {\n            probePhi = probeRel.x - probeRel.y;\n        } else if (probeRel.y - 0.5 < -probeThetai && probeRel.x - 0.5 > -probeThetai) {\n            probePhi = probeThetai*2. - probeRel.y - probeRel.x;\n        } else if (probeRel.x - 0.5 < -probeThetai && probeRel.y + 0.5 < probeThetai) {\n            probePhi = probeThetai*4. - probeRel.x + probeRel.y;\n        } else if (probeRel.y + 0.5 > probeThetai && probeRel.x + 0.5 < probeThetai) {\n            probePhi = probeThetai*8. - (probeRel.y - probeRel.x);\n        }\n        probePhi = probePhi*3.141592653*2./(4. + 8.*floor(probeThetai));\n        vec3 probeDir = vec3(vec2(sin(probePhi), cos(probePhi))*sin(probeTheta), cos(probeTheta));\n        probeDir = probeDir.x*gTan + probeDir.y*gBit + probeDir.z*gNor;\n        \n        //RT\n        float tInterval = (1./64.)*probeSize*2.;\n        if (probeCascade > 4.5) tInterval = 10000.;\n        HIT rayHit = TraceRay(probePos + gNor*0.001, probeDir, tInterval, iTime);\n        if (rayHit.n.x > -1.5) {\n            Output.w = rayHit.t;\n            if (rayHit.c.x < -1.5) {\n                //Reflective\n                    //Do nothing\n            } else if (rayHit.c.x > 1.) {\n                //Emissive\n                Output.xyz += rayHit.c;\n            } else {\n                //Geo\n                if (dot(rayHit.n, probeDir) < 0.) {\n                    //*\n                    //Bounce light\n                    vec2 suv = clamp(rayHit.uv*128., vec2(0.5), rayHit.res*0.5 - 0.5) + rayHit.uvo;\n                    Output.xyz = TextureCube(suv, 0.).xyz + TextureCube(suv + vec2(rayHit.res.x*0.5, 0.), 0.).xyz +\n                               TextureCube(suv + vec2(0., rayHit.res.y*0.5), 0.).xyz + TextureCube(suv + rayHit.res*0.5, 0.).xyz;\n                    //Output.xyz = TextureCube(suv, 0.).xyz * 4.0f;\n                    //*/\n                    \n                    //Sunlight\n                    vec3 sNor = rayHit.n;\n                    vec3 sPos = probePos + gNor*0.001 + probeDir*rayHit.t + sNor*0.001;\n                    if (dot(sNor, sunDir) > 0.) {\n                        if (TraceRay(sPos, sunDir, 10000., iTime).n.x < -1.5) Output.xyz += sunLight*dot(sNor, sunDir);\n                    }\n\n                    //Color\n                    Output.xyz *= rayHit.c;\n                }\n            }\n        } else {\n            //Sky\n            Output.w = -1.;\n            Output.xyz = GetSkyLight(probeDir);\n        }\n        \n        //Hemisphere normalized area and BRDF\n        Output.xyz *= (cos(probeTheta - 3.141592653/probeSize) -\n                       cos(probeTheta + 3.141592653/probeSize))/(4. + 8.*floor(probeThetai));\n        Output.xyz *= cos(probeTheta); //Diffuse\n        \n        //*\n        //Merging with weighted bilinear\n        if (probeCascade < 4.5) {\n            float interpMinDist = (1./256.)*probeSize*1.5;\n            float interpMaxInterval = interpMinDist;\n            if (probeCascade < 0.5) { interpMinDist = 0.; interpMaxInterval *= 2.; }\n            float l = 1. - clamp((rayHit.t - interpMinDist)/interpMaxInterval, 0., 1.);\n            vec2 uvo = probePositions*0.5;\n            vec2 lPUVOrigin = floor(UV/gRes)*gRes + vec2(0., gRes.y);\n            vec2 lPUVDirs = floor(modUV/probePositions)*probePositions;\n            vec2 lPUVPos = clamp(mod(modUV, probePositions)*0.5, vec2(0.5), uvo - 0.5);\n            vec2 fPUVPos = fract(lPUVPos - 0.5);\n            vec2 flPUVPos = floor(lPUVPos - 0.5) + 0.5;\n            vec4 S0 = WeightedSample(lPUVOrigin, lPUVDirs, flPUVPos,\n                                     uvo, probePos, gTan, gBit, gPos, probeSize*2.);\n            vec4 S1 = WeightedSample(lPUVOrigin, lPUVDirs, flPUVPos + vec2(1., 0.),\n                                     uvo, probePos, gTan, gBit, gPos, probeSize*2.);\n            vec4 S2 = WeightedSample(lPUVOrigin, lPUVDirs, flPUVPos + vec2(0., 1.),\n                                     uvo, probePos, gTan, gBit, gPos, probeSize*2.);\n            vec4 S3 = WeightedSample(lPUVOrigin, lPUVDirs, flPUVPos + 1.,\n                                     uvo, probePos, gTan, gBit, gPos, probeSize*2.);\n            vec3 lastOutput = mix(mix(S0.xyz, S1.xyz, fPUVPos.x), mix(S2.xyz, S3.xyz, fPUVPos.x), fPUVPos.y)/\n                              max(0.01, mix(mix(S0.w, S1.w, fPUVPos.x), mix(S2.w, S3.w, fPUVPos.x), fPUVPos.y));\n            if (!isnan(lastOutput.x)) //TMP fix\n                Output.xyz = Output.xyz*l + lastOutput*(1. - l);\n        }\n        //Output.xyz = abs(vec3(tInterval));\n    }\n    fragColor = Output;\n}","name":"Cube A","description":"","type":"cubemap"}]}