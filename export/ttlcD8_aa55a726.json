{"ver":"0.1","info":{"id":"ttlcD8","date":"1592436887","viewed":139,"name":"Dodecahedralis VI","username":"sl2c","description":"Similar to the past \"Dodecahedralis\" shaders; this one with a rotating 3d projection of a 6d cohomology class.  Don't like this one as much as some I've made but it looks kind of neat.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["fractal","circles","hyperbolic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright 2020 Google LLC\n// SPDX-License-Identifier: Apache-2.0\n// NOT an official Google project; see Google Open Source guidelines for more info on copyright transfer\n// written by William Cadegan-Schlieper \n\nfloat tau = 6.283185307179586;\nfloat phi = sqrt(1.25) + 0.5;\n\nbool flip(inout vec3 z, in vec2 c, in float r, inout int t, in int k) {\n    z.xy -= c;\n    bool res = (dot(z,z) < r*r) ^^ (r < 0.0);\n    if (res) {\n        z *= r * r / dot(z,z);\n        t = k - t;\n    }\n    z.xy += c;\n    return res;\n}\n\nbool inside(in vec3 z, in vec2 c, in float r, inout float t) {\n    vec3 p = z - vec3(c,0.0);\n    float res = (dot(p,p)-r*r) / (2.0 * abs(r) * p.z);\n    t = min(t, abs(res));\n    return res < 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 z0 = 2.0 * (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    float ds = 1.5 / iResolution.y;\n    vec3 z = vec3(z0,ds);\n    \n    vec2[12] c; float[12] r;\n    float r1 = pow(1.5 + 0.5 * sqrt(5.0) - sqrt(1.5 * sqrt(5.0) + 2.5), 0.5);\n    r[0] = r1; c[0] = vec2(0.0);\n    float r2 = r1 * sqrt(sqrt(5.0));\n    float x2 = sqrt(r1*r1+r2*r2);\n    float r3 = r2 / ( x2 * x2 - r2 * r2);\n    float x3 = -x2 / ( x2 * x2 - r2 * r2);\n    for (int i=0; i<5; i++) {\n        float theta = tau * 0.2 * float(i);\n        vec2 eit = vec2(cos(theta), sin(theta));\n        r[i+1] = r2;\n        c[i+1] = x2 * eit;\n        r[i+6] = r3;\n        c[i+6] = x3 * eit;\n    }\n    float r4 = -1.0 / r1;\n    r[11] = r4; c[11] = vec2(0.0);\n    \n    float period = -8.0 * log(r1);\n    float d = mod(iTime * 0.2, period) - period * 0.5;\n    z *= exp(-d);\n    \n    bool fl = false;\n    float yellow = 0.0;\n    int[6] sv = int[](0,0,0,0,0,0);\n    bool[6] fls = bool[](false,false,false,false,false,false);\n    for (int i=0; i<7; i++) {\n        fls[5] = fls[5] ^^ flip(z, c[0], r[0], sv[5], 1);\n        for (int j=0; j<5; j++) {\n            fls[j] = fls[j] ^^ flip(z, c[j+1], r[j+1], sv[j], 1);\n            fls[j] = fls[j] ^^ flip(z, c[j+6], r[j+6], sv[j], -1);\n        }\n        fls[5] = fls[5] ^^ flip(z, c[11], r[11], sv[5], -1);\n        \n    }\n    for (int j=0; j<6; j++) {\n        if (fls[j]) {\n            sv[j] = -sv[j];\n        }\n    }\n    //float col = 0.0;\n    vec3 col = vec3(0.0);\n    for (int j=0; j<5; j++) {\n        float theta = tau * (0.2 * float(j) + d / period);\n        vec2 eit = vec2(cos(theta), sin(theta));\n        //col += float(sv[j]*sv[j]);\n        col += float(sv[j]) * vec3(cos(theta),sin(theta),0.5) * 2.0 / sqrt(5.0);\n    }\n    float s5 = float(sv[5]) + 4.0 * d / period;\n    col.g += s5;\n    //col += s5 * s5;\n    col = col / (7.0 + col);\n    col = col.rbg;\n    fragColor = vec4(vec3(col),1.0);\n    /*if (sv[5] > 0) {\n        fragColor.r = 1.0;\n        fragColor.g = 0.0;\n    }\n    if (sv[5] < 0) {\n        fragColor.r = 0.0;\n        fragColor.g = 1.0;\n    }*/\n    fragColor = pow(fragColor, vec4(1.0/2.2));\n}","name":"Image","description":"","type":"image"}]}