{"ver":"0.1","info":{"id":"DdtfWS","date":"1697585840","viewed":82,"name":"Blender's 3D Musgrave Texture","username":"sdfgeoff","description":"The 3D ridged-multifractal musgrave texture node from blender's procedural textures.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["noise","blender","gpl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n* ALL OF THIS CODE IS POSSIBLY GPL, PULLED FROM BLENDER's SOURCE CODE:\n* https://github.com/blender/blender/blob/main/source/blender/gpu/shaders/material/gpu_shader_material_tex_musgrave.glsl\n* Header says: \n*   * SPDX-License-Identifier: MIT AND GPL-2.0-or-later\n* But I am not a lawyer.\n*\n*\n* I just wanted to figure out what the musgrave texture actually is.\n* Looking at the header of the file, I also notice:\n*\n* SPDX-FileCopyrightText: 2013 Inigo Quilez\n*\n* Looks like it's taken the long way of getting onto shadertoy\n* ;) ;)\n*\n*/\n\n\n#define FLOORFRAC(x, x_int, x_fract) { float x_floor = floor(x); x_int = int(x_floor); x_fract = x - x_floor; }\n\n#define rot(x, k) (((x) << (k)) | ((x) >> (32 - (k))))\n\n\n#define final(a, b, c) \\\n  { \\\n    c ^= b; \\\n    c -= rot(b, 14); \\\n    a ^= c; \\\n    a -= rot(c, 11); \\\n    b ^= a; \\\n    b -= rot(a, 25); \\\n    c ^= b; \\\n    c -= rot(b, 16); \\\n    a ^= c; \\\n    a -= rot(c, 4); \\\n    b ^= a; \\\n    b -= rot(a, 14); \\\n    c ^= b; \\\n    c -= rot(b, 24); \\\n  }\n\nuint hash_uint3(uint kx, uint ky, uint kz)\n{\n  uint a, b, c;\n  a = b = c = 0xdeadbeefu + (3u << 2u) + 13u;\n\n  c += kz;\n  b += ky;\n  a += kx;\n  final(a, b, c);\n\n  return c;\n}\n\n\nuint hash_int3(int kx, int ky, int kz)\n{\n  return hash_uint3(uint(kx), uint(ky), uint(kz));\n}\n\n\nfloat fade(float t)\n{\n  return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat negate_if(float value, uint condition)\n{\n  return (condition != 0u) ? -value : value;\n}\n\nfloat noise_grad(uint hash, float x)\n{\n  uint h = hash & 15u;\n  float g = float(1u + (h & 7u));\n  return negate_if(g, h & 8u) * x;\n}\n\n/* Trilinear Interpolation:\n *\n *   v6               v7\n *     @ + + + + + + @\n *     +\\            +\\\n *     + \\           + \\\n *     +  \\          +  \\\n *     +   \\ v4      +   \\ v5\n *     +    @ + + + +++ + @          z\n *     +    +        +    +      y   ^\n *  v2 @ + +++ + + + @ v3 +       \\  |\n *      \\   +         \\   +        \\ |\n *       \\  +          \\  +         \\|\n *        \\ +           \\ +          +---------> x\n *         \\+            \\+\n *          @ + + + + + + @\n *        v0               v1\n */\nfloat tri_mix(float v0,\n              float v1,\n              float v2,\n              float v3,\n              float v4,\n              float v5,\n              float v6,\n              float v7,\n              float x,\n              float y,\n              float z)\n{\n  float x1 = 1.0 - x;\n  float y1 = 1.0 - y;\n  float z1 = 1.0 - z;\n  return z1 * (y1 * (v0 * x1 + v1 * x) + y * (v2 * x1 + v3 * x)) +\n         z * (y1 * (v4 * x1 + v5 * x) + y * (v6 * x1 + v7 * x));\n}\n\nfloat noise_grad(uint hash, float x, float y, float z)\n{\n  uint h = hash & 15u;\n  float u = h < 8u ? x : y;\n  float vt = ((h == 12u) || (h == 14u)) ? x : z;\n  float v = h < 4u ? y : vt;\n  return negate_if(u, h & 1u) + negate_if(v, h & 2u);\n}\n\nfloat noise_perlin(vec3 vec)\n{\n  int X, Y, Z;\n  float fx, fy, fz;\n\n  FLOORFRAC(vec.x, X, fx);\n  FLOORFRAC(vec.y, Y, fy);\n  FLOORFRAC(vec.z, Z, fz);\n\n  float u = fade(fx);\n  float v = fade(fy);\n  float w = fade(fz);\n\n  float r = tri_mix(noise_grad(hash_int3(X, Y, Z), fx, fy, fz),\n                    noise_grad(hash_int3(X + 1, Y, Z), fx - 1., fy, fz),\n                    noise_grad(hash_int3(X, Y + 1, Z), fx, fy - 1., fz),\n                    noise_grad(hash_int3(X + 1, Y + 1, Z), fx - 1., fy - 1., fz),\n                    noise_grad(hash_int3(X, Y, Z + 1), fx, fy, fz - 1.),\n                    noise_grad(hash_int3(X + 1, Y, Z + 1), fx - 1., fy, fz - 1.),\n                    noise_grad(hash_int3(X, Y + 1, Z + 1), fx, fy - 1., fz - 1.),\n                    noise_grad(hash_int3(X + 1, Y + 1, Z + 1), fx - 1., fy - 1., fz - 1.),\n                    u,\n                    v,\n                    w);\n\n  return r;\n}\n\nfloat noise_scale3(float result)\n{\n  return 0.9820 * result;\n}\n\n\nfloat snoise(vec3 p)\n{\n  float r = noise_perlin(p);\n  return (isinf(r)) ? 0.0 : noise_scale3(r);\n}\n\n\n\n/* 3D Ridged Multi-fractal Terrain\n *\n * H: fractal dimension of the roughest area\n * lacunarity: gap between successive frequencies\n * octaves: number of frequencies in the fBm\n * offset: raises the terrain from `sea level'\n */\n\nvoid node_tex_musgrave_ridged_multi_fractal_3d(vec3 co,\n                                               float w,\n                                               float scale,\n                                               float detail,\n                                               float dimension,\n                                               float lac,\n                                               float offset,\n                                               float gain,\n                                               out float fac)\n{\n  vec3 p = co * scale;\n  float H = max(dimension, 1e-5);\n  float octaves = clamp(detail, 0.0, 15.0);\n  float lacunarity = max(lac, 1e-5);\n\n  float pwHL = pow(lacunarity, -H);\n  float pwr = pwHL;\n\n  float signal = offset - abs(snoise(p));\n  signal *= signal;\n  float value = signal;\n  float weight = 1.0;\n\n  for (int i = 1; i < int(octaves); i++) {\n    p *= lacunarity;\n    weight = clamp(signal * gain, 0.0, 1.0);\n    signal = offset - abs(snoise(p));\n    signal *= signal;\n    signal *= weight;\n    value += signal * pwr;\n    pwr *= pwHL;\n  }\n\n  fac = value;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    float fac = 0.0;\n    node_tex_musgrave_ridged_multi_fractal_3d(\n       vec3(uv, iTime * 0.1),\n       1.0,\n       4.0,\n       5.0,\n       0.10,\n       2.0,\n       1.0,\n       1.0,\n       fac\n    \n    ); //0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    \n    vec3 col = mix(vec3(0,0,0.1), vec3(0.5,1,1), vec3(fac * 0.3));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}