{"ver":"0.1","info":{"id":"csXcD4","date":"1686812207","viewed":99,"name":"Attractors Plotter (Fake 3D)","username":"Envy24","description":"More attractors: http://www.3d-meier.de/tut19/Seite0.html\n\nUse this plugin for changing number of paint calls:\nhttps://chrome.google.com/webstore/detail/shadertoy-unofficial-plug/ohicbclhdmkhoabobgppffepcopomhgl\n","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["attractor","chaos","dynamic","lorenz"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 O, in vec2 SC )\n{    \n#ifdef FAKE_3D\n    O = vec4(texelFetch(iChannel0, ivec2(SC), 0).w);  \n#else\n    O = texelFetch(iChannel0, ivec2(SC), 0);\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define FAKE_3D\n\n/* Some functions */\nvec3 rotateAroundX(vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    return vec3(\n        p.x,\n        p.y * c - p.z * s,\n        p.z * c + p.y * s);\n}\n\nvec3 rotateAroundY(vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    return vec3(\n        p.x * c - p.z * s,\n        p.y,\n        p.z * c + p.x * s);\n}\n\nvec3 rotateAroundZ(vec3 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    return vec3(\n        p.x * c - p.y * s,\n        p.y * c + p.x * s,\n        p.z);\n}\n\nfloat segmentSDF_L2(in vec2 NDC, in vec2 B, in vec2 E, in float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}\n\n#define X ( P.x )\n#define Y ( P.y )\n#define Z ( P.z )\n\n/* \n    Attractors \n*/\n\n\n/* Lorenz Attractor */\n#define SCENE_SCALE  ( 30. )\n#define ORIGIN       ( vec2(0) )\n#define P0           ( vec3(1) )              // Initial point\n#define SHIFT        ( vec2(0, 0) )\n#define X_ANGLE      ( 0.0 )\n#define Y_ANGLE      ( 0.0 )\n#define Z_ANGLE      ( 0.0 )\n#define ATTRACTOR(P) ( LorenzAttractor(P) )\nvec3 LorenzAttractor(in vec3 P)\n{\n    const float dt = 0.01;\n\tconst float SIGMA = 10.0;   // 1.0\n\tconst float RO = 28.0;     // 16.8\n\tconst float BETA = 8.0 / 3.0;\n\n    return vec3(\n        P.x + SIGMA * (P.y - P.x) * dt,\n\t\tP.y + (P.x * (RO - P.z) - P.y) * dt,\n\t\tP.z + (P.x * P.y - BETA * P.z) * dt\n    );\n}\n/* Aizawa Attractor *\n#define SCENE_SCALE  ( 1.4 )\n#define ORIGIN       ( vec2(0) )\n#define P0           ( vec3(0.1,0,0) )              // Initial point\n#define SHIFT        ( vec2(0, -.6) )\n#define X_ANGLE      ( -120.0 )\n#define Y_ANGLE      ( 0.0 )\n#define Z_ANGLE      ( 0.0 )\n#define ATTRACTOR(P) ( AizawaAttractor(P) )\nvec3 AizawaAttractor(in vec3 P)\n{\n    const float dt = 0.01;   \t\n    const float a = 0.95;\t\n    const float b = 0.7;\n    const float c = 0.6;\n    const float d = 3.5;\n    const float e = 0.25; \t\n    const float f = 0.1;\n        \n    return vec3(\n        P.x + ((P.z - b) * P.x - d * P.y) * dt,\n\t\tP.y + (d * P.x + (P.z - b) * P.y) * dt,\n\t\tP.z + (c + a * P.z - P.z* P.z*P.z/3.0 - (P.x*P.x + P.y*P.y)*(1.0 + e*P.z) + f * P.z * P.x*P.x*P.x) * dt\n    );\n}\n/* Rossler Attractor *\n#define SCENE_SCALE  ( 32. )\n#define ORIGIN       ( vec2(0) )\n#define P0           ( vec3(1,1,1) )              // Initial point\n#define SHIFT        ( vec2(0, -20) )\n#define X_ANGLE      ( 120.0 )\n#define Y_ANGLE      ( 180.0 )\n#define Z_ANGLE      ( 180.0 )\n#define ATTRACTOR(P) ( RosslerAttractor(P) )\nvec3 RosslerAttractor(in vec3 P)\n{\n    const float dt = 0.02;   \t\n    const float a = 0.1;\t\n    const float b = 0.1;\n    const float c = 14.0;\n    \n    return vec3(\n        P.x + (-P.y - P.z) * dt,\n\t\tP.y + (P.x + a * P.y) * dt,\n\t\tP.z + (b + P.z * (P.x - c)) * dt\n    );\n}\n/* Dequan Li Attractor *\n#define SCENE_SCALE  ( 150. )\n#define ORIGIN       ( vec2(0) )\n#define P0           ( vec3(.349,0,-.16) )          // Initial point\n#define SHIFT        ( vec2(0, -95) )\n#define X_ANGLE      ( 0.0 )\n#define Y_ANGLE      ( 0.0 )\n#define Z_ANGLE      ( 0.0 )\n#define ATTRACTOR(P) ( DequanLiAttractor(P) )\nvec3 DequanLiAttractor(in vec3 P)\n{\n    const float dt = 0.0002;   \t\n    const float a = 40.;\t\n    const float c = 1.833;\n    const float d = 0.16;\n    const float e = 0.65;\n    const float k = 55.;\n    const float f = 20.;\n       \n    return vec3(\n        P.x + (a * (P.y - P.x) + d * P.x * P.z) * dt,\n\t\tP.y + (k * P.x + f * P.y - P.x * P.z) * dt,\n\t\tP.z + (c * P.z + P.x * P.y - e * P.x * P.x) * dt\n    );\n}\n/* Halvorsen Attractor *\n#define SCENE_SCALE  ( 13. )\n#define ORIGIN       ( vec2(0) )\n#define P0           ( vec3(1,0,0) )          // Initial point\n#define SHIFT        ( vec2(0, -4) )\n#define X_ANGLE      ( -120.0 )\n#define Y_ANGLE      ( 150.0 )\n#define Z_ANGLE      ( 150.0 )\n#define ATTRACTOR(P) ( HalvorsenAttractor(P) )\nvec3 HalvorsenAttractor(in vec3 P)\n{\n    const float dt = 0.003;   \t\n    const float a = 1.4;\t\n       \n    return vec3(\n        X + (-a * X - 4. * Y - 4. * Z - Y * Y) * dt,\n\t\tY + (-a * Y - 4. * Z - 4. * X - Z * Z) * dt,\n\t\tZ + (-a * Z - 4. * X - 4. * Y - X * X) * dt\n    );\n}\n/**/","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define TO_RAD                      0.017453292519943295        // Convert degrees to radians\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{    \n    // Read previous coordinates\n    vec3 prevP = \n        iFrame == 0 ?\n            P0 :\n            texelFetch(iChannel0, ivec2(SC), 0).xyz;\n    \n    // Make step at attractor.\n    vec3 P = ATTRACTOR(prevP);\n\n    /* Generalized projections (with rotations). */\n    vec3 rP = P;\n    vec3 rpP = prevP;\n#define TO_RAD                      0.017453292519943295        // Convert degrees to radians\n    float const_angle_x_axis = X_ANGLE;\n    float const_angle_y_axis = Y_ANGLE;\n    float const_angle_z_axis = Z_ANGLE;\n    \n    /**/\n    rP = rotateAroundX(rP, const_angle_x_axis * TO_RAD);\n    rpP = rotateAroundX(rpP, const_angle_x_axis * TO_RAD);\n    /**/\n    rP = rotateAroundY(rP, const_angle_y_axis * TO_RAD);\n    rpP = rotateAroundY(rpP, const_angle_y_axis * TO_RAD);\n    /**/\n    rP = rotateAroundZ(rP, const_angle_z_axis * TO_RAD);\n    rpP = rotateAroundZ(rpP, const_angle_z_axis * TO_RAD);\n    /**/\n    \n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, false);\n    vec2 B, E;\n    B = rpP.xy; E = rP.xy; // Orthographic projection at XY plane\n    //B = rpP.xz; E = rP.xz; // Orthographic projection at XZ plane\n    //B = rpP.yz; E = rP.yz; // Orthographic projection at YZ plane\n    \n    B += SHIFT; E += SHIFT;    \n    \n#ifdef FAKE_3D\n#define UNIT                      ( (SCENE_SCALE*5.0) / iResolution.y  )\n#else\n#define UNIT                      ( (SCENE_SCALE*2.0) / iResolution.y  )\n#endif\n\n#define SMAA(d)                   ( smoothstep(UNIT, 0., d) )\n    O = vec4(P, SMAA(segmentSDF_L2(NDC, B, E, 0.)));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 O, in vec2 SC )\n{    \n    if (iFrame == 0) { O = vec4(1); return; }\n\n    O = vec4(texelFetch(iChannel0, ivec2(SC), 0));\n    \n    float sdf = texelFetch(iChannel1, ivec2(SC), 0).w;\n#ifdef FAKE_3D\n    O = mix(O, vec4(0,0,0,sdf), sdf);\n#else\n    O = mix(O, vec4(0), sdf) + 0.00002; \n#endif\n}","name":"Buffer B","description":"","type":"buffer"}]}