{"ver":"0.1","info":{"id":"ll3GDS","date":"1471215798","viewed":406,"name":"SDF shape blending","username":"tiusic","description":"Playing with blending shapes together in an SDF","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float intersectionT;\nvec3 intersectionPoint;\nvec3 intersectionNormal;\nvec3 intersectionColor = vec3(1, 0, 1);\n\nvec3 colorA = vec3(0, 1, 0);\nvec3 colorB = vec3(0, 0, 1);\n\nvec4 blend(float a, float b, float m) {\n    return vec4(min(min(a, b), a * b - m), (a * colorA + b * colorB) / (a + b));\n}\n\nfloat dSphere(vec3 p, vec3 c, float r) {\n    return length(p - c) - r;\n}\n\nfloat dBox(vec3 p, vec3 c, vec3 dimensions, mat3 rot) {\n\tvec3 d = abs((p - c) * rot) - dimensions;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvoid test(inout vec2 distMat, float newDist, int newMat) {\n    if (newDist < distMat.x) {\n        distMat = vec2(newDist, float(newMat));\n    }\n}\n\nfloat shapeSpacing = 3.0 * sin(0.1 * iTime);\nvec2 boxRotor = vec2(cos(iTime), sin(iTime));\nmat3 boxRotation = mat3(1, 0, 0, 0, boxRotor.x, -boxRotor.y, 0, boxRotor.y, boxRotor.x);    \n\nvec4 d(vec3 p) {\n    bool first = true;\n    vec4 mindd;\n    for (float i = 0.0; i <= 1.01; i += 0.1) {\n        vec3 c0 = vec3(30.0 * i, 10, shapeSpacing);\n        vec3 c1 = vec3(30.0 * i, 10, -shapeSpacing);\n        vec4 dd = blend(dSphere(p, c0, 1.0), dBox(p, c1, vec3(1.0, 1.0, 1.0), boxRotation), i);\n        if (first || dd.x < mindd.x) {\n            mindd = dd;\n        }\n        first = false;\n    }\n    return mindd;\n}\n\nvec3 calcNormal(in vec3 pos) {\n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    d(pos+eps.xyy).x - d(pos-eps.xyy).x,\n\t    d(pos+eps.yxy).x - d(pos-eps.yxy).x,\n\t    d(pos+eps.yyx).x - d(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n#define MAX_STEPS 100\n#define MARCH_EPSILON .001\n#define MAX_T 1000.\n\nvoid IntersectScene(vec3 origin, vec3 direction) {\n    float t = 0.;\n    for (int ii = 0; ii < MAX_STEPS; ++ii) {\n        vec3 pos = origin + direction * t;\n        vec4 dd = d(pos);\n        if (dd.x < MARCH_EPSILON) {\n            if (t < MAX_T) {\n\t\t\t\tintersectionNormal = calcNormal(pos);\n            \tintersectionPoint = pos;\n                intersectionT = t;\n                intersectionColor = dd.yzw;\n            }\n            break;\n        }\n        t += dd.x;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfloat aspect = iResolution.x / iResolution.y;\n\tvec2 uv = vec2(aspect, 1.) * (fragCoord.xy / iResolution.xy - .5);\n\tvec3 origin = vec3(15.0, -15.0, 0.0);\n\tvec3 direction = vec3(uv.x, 1, uv.y);\n\tdirection.xz *= .8;\n\tdirection = normalize(direction);\n\tvec3 color = vec3(0);\n    intersectionT = 1e37;\n    IntersectScene(origin, direction);\n    if (intersectionT < MAX_T) {\n        float lightDot = dot(intersectionNormal, normalize(vec3(5000, -5000, 10000)));\n        if (lightDot > 0.0) {\n        \tcolor = mix(intersectionColor, vec3(1, 1, 1), 0.3 * lightDot);\n        } else {\n        \tcolor = mix(intersectionColor, vec3(0, 0, 0), -lightDot);\n        }\n    }\n\tfragColor = vec4(pow(color, vec3(1./2.2)), 1.0);\n}","name":"Image","description":"","type":"image"}]}