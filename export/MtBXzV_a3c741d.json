{"ver":"0.1","info":{"id":"MtBXzV","date":"1444976633","viewed":502,"name":"Simple GI Test","username":"jackdavenport","description":"A test of sampling indirect light in a raytracer (a cheap method for global illumination). Probably pretty crappy but this is my first shot at GI. Change GI_FACTOR on line 3 to 0. for GI pass only.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["gi","global","illumination","indirect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// Realtime Global Illumination\n// by Jack Davenport, 2015\n#define GI_FACTOR .75\n\nstruct Ray {\n\tvec3 ori;\n    vec3 dir;\n};\n    \nstruct RaycastHit {\n   \tvec3 point;\n    vec3 normal;\n    int id;\n};\n    \nconst vec3 sun = vec3(-45., 45., -60.);\nconst vec3 po1 = vec3(5., 7., 6.);\n\nvec3 cameraOrigin;    \n\nRaycastHit intersectSphere(Ray ray, vec3 center, float radius) {\n    \n    float a = dot(ray.dir, ray.dir);\n    float b = 2. * dot(ray.dir, ray.ori - center);\n    float c = dot(ray.ori - center, ray.ori - center) -(radius * radius);\n    float det = (b * b) - 4. * a * c;\n\n\tfloat lambda = (-b -sqrt(det)) / (2. * a);\n\tvec3 p = ray.ori + lambda * ray.dir;\n\tvec3 n = p - center;\n    \n    RaycastHit hit;\n    hit.point = p;\n    hit.normal = normalize(n);\n    hit.id = (det >= 0. && lambda >= 0.) ? 0 : -1;\n    \n    return hit;\n    \n}\n\nRaycastHit intersectPlane(Ray ray, float y, vec3 normal) {\n \n    float num = -dot(normal,ray.ori-vec3(0.,y,0.));\n    float denom = dot(normal, ray.dir);\n\tfloat t = num / denom;\n\t\t\t\n\tvec3 p = ray.ori + ray.dir * t;\t\t\n    \n    RaycastHit hit;\n    hit.point = p;\n    hit.normal = normal;\n    hit.id = t > 0. ? 1 : -1;\n    \n    return hit;\n    \n}\n\nRaycastHit minHit(RaycastHit a, RaycastHit b) {\n \n    float distA = sqrt((cameraOrigin.x * a.point.x) + (cameraOrigin.y * a.point.y) + (cameraOrigin.z * a.point.z));\n    float distB = sqrt((cameraOrigin.x * b.point.x) + (cameraOrigin.y * b.point.y) + (cameraOrigin.z * b.point.z));\n    \n    if(distB < distA) {\n     \n        return b;\n        \n    }\n    \n    return a;\n    \n}\n\nRaycastHit intersectScene(Ray ray) {\n \n    RaycastHit sphere = intersectSphere(ray, vec3(0., .2 * sin(iTime * 3.), 1.), .6);\n    RaycastHit plane = intersectPlane(ray, -1., vec3(0., 1., 0.));\n    \n    if(sphere.id == 0) {\n     \n        return sphere;\n        \n    }\n    \n    return plane;\n    \n}\n\nfloat lighting(RaycastHit hit) {\n \n    const float eps = .001;\n    float sum = .2;\n    \n    // sun\n    Ray shadowRay = Ray(hit.point + (sun * eps), sun);\n    RaycastHit shadow = intersectScene(shadowRay);\n    if(shadow.id == -1) sum += max(dot(normalize(sun), hit.normal), 0.);\n    \n    // po1\n    vec3 l = hit.point - po1;\n    shadowRay = Ray(hit.point + (l * eps), l);\n    shadow = intersectScene(shadowRay);\n    //if(shadow.id == -1) sum += dot(normalize(l), hit.normal);\n    \n    return sum;\n    \n}\n    \nvec4 shadeSphere(Ray ray, RaycastHit hit) {\n    \n    float diffuse = lighting(hit);\n    float specular = pow(max(dot(normalize(sun), hit.normal), 0.), 45.);\n    \n    return (vec4(1., 0., 0., 1.) * diffuse) + specular;\n    \n}\n\nvec4 shadePlane(Ray ray, RaycastHit hit) {\n \n    float diffuse = lighting(hit);\n    vec2 uv = mod(hit.point.xz / 3., vec2(1.));\n    \n    vec3 rd = reflect(ray.dir, hit.normal);\n    Ray rr = Ray(hit.point + (rd * .001), rd);\n    RaycastHit rh = intersectScene(rr);\n    \n    vec4 tex = texture(iChannel1, uv);\n    \n    vec4 rc = rh.id == 0 ? shadeSphere(rr, rh) : texture(iChannel0, rd);\n    vec4 col = tex * diffuse;\n    //return col;\n    float tf = (tex.x + tex.y + tex.z) / 3.;\n    return mix(col, rc, tf);\n    \n}\n\nfloat rand(vec2 p) {\n \n   \tfloat n = fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 43758.5453);\n   \treturn mix(-1., 1., n);\n    \n}\n\nvec4 calcGI(RaycastHit hit) {\n \n    vec4 sum = vec4(0.);\n    int fact = 0;\n    \n    for(int i = 0; i < 64; i++) {\n     \n        float x = rand(hit.point.xz\t\t + float(i));\n        float y = rand(hit.point.xz + 1. + float(i));\n        float z = rand(hit.point.xz + 2. + float(i));\n        \n        vec3 dir = normalize(vec3(x, .01 + abs(y), z));\n        //vec3 dir = hit.normal + vec3(0.4*sin(float(i)+x),0.1*sin(float(i)+y),0.2*sin(float(i)+z));\n        \n        Ray ray = Ray(hit.point + (dir * .01), dir);\n        RaycastHit h = intersectScene(ray);\n        \n        if(h.id == 0) {\n         \n            sum += shadeSphere(ray, h);\n            \n        } else if(h.id == 1) {\n         \n            sum += shadePlane(ray, h);\n            \n        } else {\n         \n            sum += texture(iChannel0, dir);\n        }\n        \n        fact++;\n        \n    }\n    \n    return (sum / float(fact)) * 2.;\n    \n}\n\nvec4 shade(Ray ray) {\n\n    RaycastHit scene = intersectScene(ray);\n    \n    if(scene.id == 0) {\n     \n        return mix(calcGI(scene), shadeSphere(ray, scene), GI_FACTOR);\n        \n    } else if(scene.id == 1) {\n     \n        return mix(calcGI(scene), shadePlane(ray, scene), GI_FACTOR);\n        \n    }\n    \n    return texture(iChannel0, ray.dir);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy / 2.) / iResolution.y;\n\t\n    vec3 ori = cameraOrigin = vec3(0., 0., -3.);\n    vec3 dir = vec3(uv.xy, 1.);\n    \n    Ray ray = Ray(ori, dir);\n    fragColor = shade(ray);\n    \n}","name":"","description":"","type":"image"}]}