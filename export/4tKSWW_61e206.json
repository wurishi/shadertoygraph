{"ver":"0.1","info":{"id":"4tKSWW","date":"1484449106","viewed":487,"name":"Animated pathtrace","username":"KylBlz","description":"Each buffer is rendering 4 frames for a total of 16, they are all put together to form an animation.\nAfter 15 minutes: http://imgur.com/DYpvXcx","likes":14,"published":1,"flags":32,"usePreview":0,"tags":["volume","animated","caustics","trace","path","monte","carlo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//If you dont have a powerful GPU, comment \"#define MULTI 8\" at line 1 of Common\n\n//we have 16 frames\n#define t0(a) texture(iChannel0, a)\n#define t1(a) texture(iChannel1, a)\n#define t2(a) texture(iChannel2, a)\n#define t3(a) texture(iChannel3, a)\n//define the framerate\n#define f floor(float(iFrame)*.25)\n\n// tone mapping https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x) {\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), vec3(0), vec3(1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec4 c;\n    vec2 uv = fragCoord.xy / iResolution.xy * .5;\n    float frame = mod(f, 16.),\n          channel = floor(frame * .25),\n          subframe = frame-channel*4.;\n\t\n    if (subframe == 1.) uv += vec2(.5,0.);\n    else if (subframe == 2.) uv += vec2(0.,.5);\n    else if (subframe == 3.) uv += vec2(.5);\n    \n    if (channel == 0.) c = t0(uv);\n    else if (channel == 1.) c = t1(uv);\n    else if (channel == 2.) c = t2(uv);\n    else if (channel == 3.) c = t3(uv);\n    \n    fragColor.rgb = pow(ACESFilm(c.rgb / c.a), vec3(GAMMA));\n    fragColor.a = 1.;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nconst vec3 INIT_POS = vec3(5.0, 4., 0.),\n    \t   INIT_VEL = vec3(-.125, 0., 0.),\n    \t   INIT_ROT = vec3(-.05, 0., 0.);\n\n//render 4 frames\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //split into 4 windows\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 thisFrame = vec4(render(uv, iResolution.xy, iTime, INIT_POS, INIT_VEL, INIT_ROT), 1.);\n    vec4 lastFrame = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    fragColor = thisFrame + lastFrame;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nconst vec3 INIT_POS = vec3(4.5, 4., 0.),\n    \t   INIT_VEL = vec3(-.125, 0., 0.),\n    \t   INIT_ROT = vec3(-.05, 0., 0.);\n\n//render 4 frames\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //split into 4 windows\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 thisFrame = vec4(render(uv, iResolution.xy, iTime, INIT_POS, INIT_VEL, INIT_ROT), 1.);\n    vec4 lastFrame = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    fragColor = thisFrame + lastFrame;\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\nconst vec3 INIT_POS = vec3(4., 4., 0.),\n    \t   INIT_VEL = vec3(-.125, 0., 0.),\n    \t   INIT_ROT = vec3(-.05, 0., 0.);\n\n//render 4 frames\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //split into 4 windows\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 thisFrame = vec4(render(uv, iResolution.xy, iTime, INIT_POS, INIT_VEL, INIT_ROT), 1.);\n    vec4 lastFrame = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    fragColor = thisFrame + lastFrame;\n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\nconst vec3 INIT_POS = vec3(3.5, 4., 0.),\n    \t   INIT_VEL = vec3(-.125, 0., 0.),\n    \t   INIT_ROT = vec3(-.05, 0., 0.);\n\n//render 4 frames\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //split into 4 windows\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 thisFrame = vec4(render(uv, iResolution.xy, iTime, INIT_POS, INIT_VEL, INIT_ROT), 1.);\n    vec4 lastFrame = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    fragColor = thisFrame + lastFrame;\n}\n","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define MULTI\t\t8\n#define BOUNCE_PXL\t8\n#define GAMMA\t\t1.\n#define EXPOSURE\t.5\n#define _STARTMAT\t_air\n\n\nconst float zfar = 10.,\n\t\t\teps  = 0.0001,\n    \t\tsml  = 0.001,\n    \t\tsc45 = 0.7071067,\n\t\t    pi_5 = 1.5707963,\n            pi   = 3.1415926,\n    \t\tpi2  = 6.2831853,\n    \t\tpi4  = 12.566368,\n\t\t\tpi_rcp = 0.3183098;\n\n//a: Absorb rgb wavelengths\n//e: Emit rgb wavelengths\n//s: Surface roughness (minimum scatter), surface gloss (maximum scatter)\n//u: sUbsurface minimum scatter, subsurface maximum scatter\n//r: Refractive index\n//eu: Emission Uniformity (0 = mostly paralell photons, 1 = total chaos)\n//d: unique iDentifier\nstruct mat { vec3 a, e; vec2 s, u; float r, eu; int d; };\n//Location, Normal, Info(distance, thickness, nothing), material\nstruct hit { vec3 l, n, i; mat m; };\n//Origin, Direction, Color, current material\nstruct ray { vec3 o, d, c; mat m; };\n//center Location, Radius, Material\nstruct sph { vec3 l; float r; mat m; };\n//Location, Normal, Tangent, Info(size x,y,'depth'), Material\nstruct pln { vec3 l, n, t, i; mat m; };\n//aabb miN, maX, Rotation, Material\nstruct box { vec3 n, x; mat3 r; mat m; };\n\n////////////////////// random number (distribution sucks)\nfloat hash12( in vec2 p ) {\n\tfloat h = dot(p,vec2(101.7, 683.11));\n    return fract(sin(h)*467.709);\n}\nfloat hash13( in vec3 p ) {\n\tfloat h = dot(p,vec3(571.127, 467.311, 881.521));\n    return fract(sin(h)*467.197);\n}\nvec2 hash22( in vec2 p ) {\n\tvec2 h = vec2(dot(p,vec2(467.127, 881.311)),\n                  dot(p,vec2(7.101, 11.683)));\n    return fract(sin(h)*467.281);\n}\nvec3 hash33( in vec3 p ) {\n\tvec3 h = vec3(dot(p,vec3(467.127, 881.311, 571.521)),\n                  dot(p,vec3(7.101, 11.683, 13.331)),\n                  dot(p,vec3(683.331, 761.101, 823.127)));\n    return fract(sin(h)*467.281);\n}\n\n////////////////////// normal(ish) distribution\nfloat bell12( in vec2 n ) {\n\tfloat r0 = hash12(n + 0.07),\n\t r1 = hash12(n + 0.11);\n\treturn (r0+r1) * 0.5;\n}\nfloat bell13( in vec3 n ) {\n\tfloat r0 = hash13(n + 0.07),\n\t r1 = hash13(n + 0.11);\n\treturn (r0+r1) * 0.5;\n}\nvec3 bell33( in vec3 n ) {\n\tvec3 r0 = hash33(n + 17.07),\n\t r1 = hash33(n + 13.11);\n\treturn (r0+r1) * 0.5;\n}\n\n////////////////////// perlin noise with scale, smoothsteped to 0. - 1.\nfloat fade(float t) { return t * t * t * (t * (t * 6. - 15.) + 10.); }\nfloat pnoise12(vec2 p, float scl) {\n    vec2 i = floor(p*scl),\n     f = fract(p*scl),\n     u = vec2(fade(f.x), fade(f.y)),\n     o = vec2(0., 1.),\n     g00 = hash22(i).xy, g01 = hash22(i + o.xy).xy,\n     g11 = hash22(i + o.yy).xy, g10 = hash22(i + o.yx).xy,\n     d00 = f, d01 = f - o.xy,\n     d11 = f - o.yy, d10 = f - o.yx;\n    float s00 = dot(g00, d00), s01 = dot(g01, d01),\n     s11 = dot(g11, d11), s10 = dot(g10, d10),\n     x1 = mix(s01,s11, u.x), x2 = mix(s00,s10, u.x);\n    return mix(x2, x1, u.y);\n}\n////////////////////// some tools\nconst mat nullMat = mat(vec3(0.), vec3(0.), vec2(0.), vec2(0.), 0., 0., 0);\nconst hit nullHit = hit(vec3(0.), vec3(0.), vec3(zfar, 0., 0.), nullMat);\n\n#define minPositive(a, b) (a < b)? zfar: (b < 0.)? (a > 0.)? a: zfar: b\n#define vec3max(a) max(a.x, max(a.y, a.z))\n#define vec3min(a) min(a.x, min(a.y, a.z))\n\nvec3 rotateY(vec3 p, float angle) {\n    float c = cos(angle), s = sin(angle);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\nvec3 rotateXY(in vec3 p, in vec2 angle) {\n    vec2 c=cos(angle), s=sin(angle); vec3 o = p;\n    o.yz *= mat2(c.x,s.x,-s.x,c.x);  o.xz *= mat2(c.y,s.y,-s.y,c.y);\n    return o;\n}\nvec3 slerp(in vec3 start, in vec3 end, in float percent) {\n    float dt = dot(start, end), theta = acos(dt)*percent;\n    return start*cos(theta) + normalize(end - start*dt)*sin(theta);\n}\nhit lt(in hit l, in hit r) {\n    if (l.i.x < r.i.x) return l;\n    else return r;\n}\nvec3 rndSphere(in vec3 chaos) {\n    return normalize(bell33(chaos)*2.-1.);\n}\nvec3 rndHemi(in vec3 norm, in vec3 chaos) {\n    vec3 guess = normalize(bell33(chaos + norm)*2.-1.);\n    float negate = step(0., dot(norm, guess))*2.-1.;\n    return guess * negate;\n}\nfloat schlick(in float r1, in float r2, in float vn) {\n    float r0 = (r1 - r2) / (r1 + r2);\n\treturn mix(r0*r0, 1., pow(1. - vn, 5.));\n}\n//use microfacet model?\nfloat getRoughness(in vec3 rd, in mat m, in float rnd) {\n    return clamp(abs(bell13(rd + rnd)*2.-1.) * m.s.y + m.s.x, 0., 1.);\n}\n//need better control\nfloat getEmission(in vec3 rd, in vec3 nrm, in mat m) {\n\treturn pow(clamp(-dot(nrm, rd), m.eu, 1.), 2.);   \n}\n\n////////////////////// Intersection functions\n\n//sphere\nhit trace(in ray r, in sph s) {\n    vec3 oc = r.o - s.l;\n    float c = dot(oc, oc) - s.r * s.r;\n    float b = dot(oc, r.d),\n\t\t  h = sqrt(b * b - c),\n          d = (h > 0.)? minPositive(-b+h,-b-h): zfar;\n    vec3 l = r.d * d + r.o;\n    return hit(l, (l - s.l) / s.r,\n               vec3(max(0., d), h, 0.), s.m);   \n}\nfloat sd(in ray r, in sph s) {\n    vec3 oc = r.o - s.l;\n    return dot(oc, oc) - s.r * s.r;\n}\n\n//plane\nhit trace(in ray r, in pln p) {\n    float a = dot(p.n, r.d),\n    \t  d = dot(p.n, p.l - r.o) / a;\n    d = (d < 0. || d > zfar)? zfar: d;\n    return hit(r.o + r.d * d, p.n,\n               vec3(max(0., d), a + 1.0 + p.i.x, 0.), p.m);\n}\nfloat sd (in ray r, in pln p) {\n    return dot(p.n, p.l - r.o);\n}\n\n//box\nhit trace(in ray r, in box b) {\n    vec3 t1 = (b.n - r.o)/r.d,\n         t2 = (b.x - r.o)/r.d,\n         tn = min(t1, t2), tx = max(t1, t2);\n    float tmin = vec3max(tn),\n    \t  tmax = vec3min(tx),\n   \t\t  f = minPositive(tmax, tmin);\n    vec3 l = r.o + r.d*f*.9999,\n         c = (b.x - b.n)*.5,\n         d = b.n+c-l;\n    return hit(l, step(c,abs(d)), vec3(max(0., f), tmax-tmin, 0.), b.m);\n}\nfloat sd(in ray r, in box b) {\n    vec3 s = (b.x - b.n)*.5, //size\n         c = b.n + s, //center\n         d = abs(c - r.o) - s; //displacement\n    return vec3max(d);\n}\n\n////////////////////// Materials\nconst mat\n//conductors\n    _air = mat(vec3(.5), vec3(0.), vec2(1.), vec2(.2), 1.0003, 0., 0),\n\t_gls = mat(vec3(.8,.8,.99), vec3(0.), vec2(0.,.01), vec2(0.), 1.7, 0., 1),\n//reflective insulator\n    _chr_g = mat(vec3(.8,.99,.6), vec3(0.), vec2(0.), vec2(0.), -1., 0., 10),\n//diffuse insulator\n    _wht = mat(vec3(.3), vec3(0.), vec2(1.), vec2(0.), -1., 0., 20),\n    _cyn = mat(vec3(.01,.02,.03), vec3(0.), vec2(1.), vec2(0.), -1., 0., 21),\n    _blk = mat(vec3(0.005,0.,0.005), vec3(0.), vec2(1.), vec2(0.), -1., 0., 22),\n//emissive\n\t_wht_e = mat(vec3(1.), vec3(999.), vec2(.05,1.), vec2(0.), -1., 0., 30);\n\n////////////////////// Primitives\nsph sph1 = sph(vec3(0.,0.,0.), 1., _gls),\n    sph2 = sph(vec3(2.5*-sc45,2.5*-sc45,0.), .25, _gls),\n//lights\n\tlit1 = sph(vec3(2.,2.,0.), .5, _wht_e);\n//planes\npln pln1 = pln(vec3(0.,-2.5,0.), vec3(0.,1.,0.), vec3(0., 0., -1), vec3(1.,1.,.1), _chr_g);\n//boxes\nbox box1 = box(vec3(-6.,-6.,-6.), vec3(6.,6.,2.), mat3(0.), _blk);\n\n//calculates where the ray intersects\nhit traceScene(in ray r) {\n    //trace objects\n    hit ret = trace(r, box1);\n    ret = lt(ret, trace(r, pln1));\n    ret = lt(ret, trace(r, sph1));\n    ret = lt(ret, trace(r, sph2));\n    ret = lt(ret, trace(r, lit1));\n\t//mirror normal if needed\n    float nmod = step(dot(r.d, ret.n), 0.)*2.-1.;\n    ret.n *= nmod;\n    return ret;\n}\n\n//calculates if the camera is inside anything\n//mat mapScene(in vec3 l) { }\n\n//how the ray behaves\nvoid brdf(inout ray r, inout hit res, in float rnd) {\n    //calculate roughness (randomness) of surface\n    float roughness = getRoughness(r.d, res.m, rnd),\n          //calculate view angle of surface\n          ndotr = dot(res.n, -r.d),\n\t\t  //decide the ray's fate\n          sch = schlick(r.m.r, res.m.r, ndotr),\n\t\t  //reflect or refract chance if \n\t\t  ror = step(hash13(r.d - rnd), sch) * 2. - 1.;\n\t//for insulators reduce roughness instead of refracting?\n\tvec3 newDir = (ror < 0.)? refract(r.d, res.n, r.m.r / res.m.r): reflect(r.d, res.n);\n    //new ray properties\n\tr.o = res.l + res.n*eps*ror;\n\tr.d = normalize(mix(newDir, rndHemi(res.n , res.l + rnd), roughness));\n    r.c *= res.m.a;\n    if(ror < 0.) r.m = res.m;\n}\n\n//render 4 frames\nvec3 render(in vec2 uv, in vec2 iChannelResolution, in float iTime, in vec3 INIT_POS, in vec3 INIT_VEL, in vec3 INIT_ROT) {\n    //split into 4 windows\n    float frame = step(.5,uv.x)+step(.5,uv.y)*2.;\n    uv = fract(uv*2.)-.5;\n    uv.x *= iChannelResolution.x / iChannelResolution.y;\n\t//begin\n    hit res;\n    //final color\n    vec3 final = vec3(0.);\n    vec2 _uv = uv;\n    //find out what material ray is starting in?\n\n#ifdef MULTI\n    for (int j = 0; j < MULTI; j++) {\n        _uv = uv + (vec2(bell12(uv+float(j)-iTime*sml), bell12(uv-float(j)+iTime*sml)) * 2. - 1.) / iChannelResolution.xy;\n#else\n    _uv += (vec2(bell12(uv-iTime*sml), bell12(uv+iTime*sml)) * 2. - 1.) / iChannelResolution.xy;\n#endif\n    lit1.l = INIT_POS.xyz + frame*INIT_VEL.xyz;\n    //start the ray at the camera\n    ray r = ray(vec3(-1., -1., -4.), normalize(rotateXY(normalize(vec3(_uv, 1.)), INIT_ROT.xy)), vec3(1.), _STARTMAT);\n    //bounce around a few times\n    for (int i = 0; i < BOUNCE_PXL; i++) {\n        //new random seed  \n#ifdef MULTI\n        float rnd = float(i + BOUNCE_PXL*j)*iTime*sml;\n#else\n        float rnd = (float(i)+iTime)*sml;\n#endif        \n        //trace scene\n        res = traceScene(r);\n        //chance the air refracts the light\n        float rft = hash13(r.d + rnd);\n        //probability increases with distance\n        if (rft < r.m.u.x) { // * sqrt(res.i.x)\n            //add emmisive color\n            final += r.m.e * r.c * getEmission(r.d, res.n, r.m);\n            //get random point between ro and dist\n            float d = hash13(r.d - rnd)*res.i.x,\n                //how much the air changes the ray\n                roughness = getRoughness(r.d, r.m, rnd);\n            //new origin is randomly along ray\n            r.o = r.o + r.d*d;\n            r.d = slerp(r.d, rndSphere(r.d + r.o - rnd), roughness);\n            r.c *= r.m.a;\n            continue;\n        }\n        //if collision\n        if (res.i.x < zfar) {\n            //add colors\n            final += r.c * res.m.e * getEmission(r.d, res.n, res.m);\n            //modify ray properties\n            brdf(r, res, rnd);\n\n        } else break;\n    }\n#ifdef MULTI\n    }\n#endif\n    return final*EXPOSURE;\n    \n}\n","name":"Common","description":"","type":"common"}]}