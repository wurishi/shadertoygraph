{"ver":"0.1","info":{"id":"cltBDr","date":"1708407255","viewed":62,"name":"Atan remapping","username":"matthatter419","description":"Using the atan(y, x) overload, which has a range of [-PI, PI], we remap the range to [0, 2 * PI], and then to [0, 1], without shifting the phase angle.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["practice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float aspectRatio; // defined in main\nconst float PI = 3.14159;\n\n// Shift UVs into -1:1 domain and scale to aspect ratio\nvec2 scaleUV(in vec2 uv) {\n    return (( -1.0 + 2.0 * uv) * vec2(aspectRatio, 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    aspectRatio = iResolution.x/iResolution.y;\n    vec2 scaledUV = scaleUV(uv);\n\n    float radius = length(scaledUV);\n    // This overload of atan takes the quadrant into consideration, yielding an output\n    // in the range [-PI, PI]. By adding 2*PI, we shift into the positive range, then \n    // by taking the mod 2*PI, we maintain 2*PI wrapping. Finally, we divide by 2PI to \n    // normalize the range to [0, 1). \n    //\n    // (Contrast this method with simply adding PI and dividing by 2PI,\n    // which has the correct resulting range but the wrong phase).\n    float angle = mod(atan(scaledUV.y, scaledUV.x) + 2.0*PI, 2.0*PI) / (2.0 * PI);\n\n    vec3 col = vec3(0.2, 0.8, 0.5);\n    \n    if (radius < 0.5) {\n        col = vec3(angle);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}