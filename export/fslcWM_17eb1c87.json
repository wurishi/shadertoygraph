{"ver":"0.1","info":{"id":"fslcWM","date":"1642171131","viewed":64,"name":"Shader-Studies: Noise","username":"LeyMB","description":"A simple shader I made as part of my studies to improve my shader knowledge. Made as part of an exercise on https://thebookofshaders.com/11/","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Many thanks to Patricio Gonzalez Vivo & Jen Lowe for their tutorials on thebookofshaders.com\n// Their website is an invaluable resource when starting out with learning shaders and has helped me greatly\n\n\n//-- settings\nint ShapeCorners = 5;               // corners of the underlying polar shape\nfloat ShapeRotationSpeed = 1.0;     // modifies the speed of the rotation of the polar shape\n//--\n\n\n// DrawBox function taken from here: https://thebookofshaders.com/09/\nfloat DrawBox(vec2 _st, vec2 _size, float _smoothEdges){\n    _size = vec2(0.5)-_size*0.5;\n    vec2 aa = vec2(_smoothEdges*0.5);\n    vec2 uv = smoothstep(_size,_size+aa,_st);\n    uv *= smoothstep(_size,_size+aa,vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\nvec2 rotate(vec2 Coord, float _angle){\n    Coord -= 0.5;\n    Coord =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * Coord;\n    Coord += 0.5;\n    return Coord;\n}\n\nfloat rand(vec2 coord)\n{\n    return fract(sin(dot(coord.xy, vec2(4.6993, 78.233))) * 97111.7424);\n}\n\nfloat fNoise(float x)\n{\n    float fNoise = 0.0;\n    \n    // get integer component of the floating-point number\n    float intComp = floor(x);\n\n    // get fractional component of the floating-point number\n    float fractComp = fract(x);\n\n    //create curve\n    float curve = fractComp * fractComp * fractComp * fractComp * fractComp * (3.0 - 2.0 * fractComp);\n\n    // use integer component to get pseudo random value\n    fNoise = mix( rand(vec2(intComp)), rand(vec2(intComp) + 3.14159), curve);\n\n    return fNoise;\n}\n\n// my own shape function\nvec3 DrawShape(vec2 fragCoord, int numCorners)\n{\n    float pi = 3.14159265358979;\n\n    float angle = atan(fragCoord.x, fragCoord.y) + pi;\n    float radius = 2.0 * pi/float(numCorners);\n\n    float dist = cos(floor(0.5 + angle / radius) * radius - angle) * length(fragCoord);\n\n    return vec3(1.0-smoothstep(.4,.41,dist));\n}\n\n\nfloat fNoise(vec2 Coord)\n{\n    float fNoise = 0.0;\n    \n    // get integer component of the floating-point number\n    float intCompX = floor(Coord.x);\n    float intCompY = floor(Coord.y);\n\n    // get fractional component of the floating-point number\n    float fractComp = fract(Coord.x);\n\n    //create curve\n    float curve = fractComp * fractComp * fractComp * fractComp * fractComp * (3.0 - 2.0 * fractComp);\n\n    // use integer component to get pseudo random value\n    fNoise = mix( rand(vec2(intCompX)), rand(vec2(intCompY) + 3.14159), curve);\n\n    return fNoise;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord.xy / iResolution.xy;\n    coord = rotate(coord, fNoise(fragCoord.x));\n    coord = rotate(coord, iTime * ShapeRotationSpeed);\n\n\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    vec3 color = vec3(0.0);\n\n    st = rotate(st, fNoise(fragCoord.x));\n    st = rotate(st, iTime * ShapeRotationSpeed);\n\n    // Remap the space to -1. to 1.\n    st = st *2.-1.;\n\n    // Draw Shape\n    color += DrawShape(st, ShapeCorners)\n            * vec3(\n                    fNoise(coord.x) * 10.0, \n                    fNoise(coord.y)* 10.0, \n                    fNoise(smoothstep(0.0, 1.0, smoothstep(coord.x, coord.y, iTime))));\n    \n\n    fragColor = vec4(color, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}