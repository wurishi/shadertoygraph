{"ver":"0.1","info":{"id":"wtS3Dh","date":"1665403592","viewed":123,"name":"CrossEyesStereoTest","username":"hjd3481","description":"Following The Art of Code's tutorials. Ray-marching test. Texture-displacement. Stereo ( cross-eyes ), flip eyeSeparation to make parallax.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","raymarching","marching","theartofcode"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 100.0\n#define MAX_STEPS 30\n\n#define TWOPI \t6.283185307179586476925286766559\n#define HALFPI \t1.5707963267948966192313216916398\n#define TORAD \t0.01745329251994329576923690768489\n\nfloat dToSphere( vec3 inPos, vec4 sPosRad )\n{\n\t   //uv = polar spherical coords\n    \n    vec3 originToPos = inPos-sPosRad.xyz;\n    float len = length(originToPos);\n    \n    originToPos = normalize(originToPos);\n    \n    float u = originToPos.y;\n    \n    //float depth = sin( iTime * 0.3 ) * 0.25;\n    float depth = 0.125;\n    float pan = 0.11010;\n    float dt = (texture(iChannel0, vec2( (iTime*-pan + u), inPos.x)*0.8 ).r) * depth; //ADD\n    dt = max( dt, (texture(iChannel0, vec2( (iTime*pan + u), inPos.z)*0.8 ).r) * depth ); //sub\n\t\n    //dt -= depth * .5;\n        \n    return len-sPosRad.w - dt;\n}\n\nfloat dToFloor( vec3 inPos )\n{\n    return inPos.y;\n}\n\nfloat GetD( vec3 pos )\n{\n    float d = MAX_DIST;\n    \n    d = min( d, dToFloor( pos ) ); //ADD\n      \n    d = min( d, dToSphere( pos, vec4(0.0,1.0,0.0  , 0.7 ) )); //ADD\n    \n    return d;\n}\n\nfloat DoRay( vec3 co, vec3 vd )\n{\n    vec3 p = co;\n    float dc = 0.0;\n    for( int i=0; i < MAX_STEPS; i++)\n    {  \t\n\t\tfloat ds = GetD(p);\n        //move up ray\n        dc += ds;\n        p += vd * ds;\n        if( ds < 0.01 || dc > MAX_DIST )\n        {         \n            break;\n        }        \n    }\n    return dc;\n}\n\nfloat DoRayToSphere( vec3 co, vec3 vd, vec4 SpherePosRadius )\n{\n    vec3 p = co;\n    float dc = 0.0;\n    for( int i=0; i < MAX_STEPS; i++)\n    {  \t\n\t\tfloat ds = dToSphere( p, SpherePosRadius );\n        //move up ray\n        dc += ds;\n        p += vd * ds;\n        if( ds < 0.01 || dc > MAX_DIST )\n        {         \n            break;\n        }        \n    }\n    return dc;\n}\n\nvec3 GetN( vec3 surf_pos )\n{\n    float ds = GetD( surf_pos );\n    float du = GetD( surf_pos - vec3(0.01,0.00,0.00));  \n    float dv = GetD( surf_pos - vec3(0.00,0.01,0.00));\n    float dw = GetD( surf_pos - vec3(0.00,0.00,0.01));\n    \n    vec3 n = ds - vec3(du,dv,dw);\n    return normalize(n);\n}\n\nvec3 Light( vec3 surf_pos, vec3 light_pos, vec3 world_normal, vec3 lightCol )\n{\n    vec3 surf_to_light = light_pos - surf_pos;\n    float light_dist = length(surf_to_light);\n    surf_to_light = normalize(surf_to_light);\n    float I = max( 0.0, dot( world_normal , surf_to_light ));\n    \n    float Imag = max(1.0,1.0/(light_dist * light_dist));\n            \n    return lightCol * I * Imag;\n}\n\nvec3 LightShad( vec3 surf_pos, vec3 light_pos, vec3 world_normal, vec3 lightCol )\n{\n    vec3 surf_to_light = light_pos - surf_pos;\n    float light_dist = length(surf_to_light);\n    surf_to_light = normalize(surf_to_light);\n    float I = max( 0.0, dot( world_normal , surf_to_light ));\n    \n    float Imag = max(1.0,1.0/(light_dist * light_dist));\n    \n    float shad_surf_dist = DoRay( surf_pos + (world_normal * 0.02), surf_to_light );    \n    if( shad_surf_dist < MAX_DIST && shad_surf_dist < light_dist )\n    {\n\t\tI = 0.03;\n    }\n        \n    return lightCol * I * Imag;\n}\n\n\nvec3 Diff( vec3 p, vec3 n)\n{\n    vec3 col = texture( iChannel0, vec2(p.xz) ).xyz;\n    \n    return col;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = (fragCoord.xy-(0.5*iResolution.xy))/iResolution.y;\n    \n    vec2 uv = (fragCoord.xy)/iResolution.xy;\n    \n    uv.x *= 2.0;\n    \n    float xsigndir =  floor(uv.x)*2.0 - 1.0;\n    \n    uv = fract(uv)*2.0-1.0;\n    \n    //fragColor = vec4(uv,0.0,1.0); return;\n    \n    \n    float t = iTime;\n    \n   \n    //Camera\n    float scalex = 1.0;\n    float scaley = 1.0;\n        \n    float orbitDist = 2.0f;\n    float orbitHeight = 1.3f;\n        \n    vec3 cameraPos = vec3( sin(t*0.2)*orbitDist, orbitHeight, cos(t*0.2)*orbitDist );\n      \n    vec3 cameraLookAt = vec3(0.0, 1.0, 0.0);\n    \n    vec3 camz = normalize(cameraLookAt-cameraPos);\n       \n    vec3 sidex = normalize(cross( camz, vec3(0.0, 1.0, 0.0) ));\n    \n    float eyeSeparation = 0.07f;\n    cameraPos -= sidex * xsigndir * eyeSeparation;\n    \n    vec3 up = normalize(cross( sidex, camz ));\n\tvec3 raydir = normalize( camz + (sidex * (uv.x) * scalex) + (up * uv.y * scaley) );\n     \n    //Position\n    float d = DoRay( cameraPos, raydir );\n    vec3 surf_pos = cameraPos + (raydir * d);\n      \n    vec3 world_normal = GetN(surf_pos);\n    \n    // Time varying pixel color\n    \n    vec3 col = vec3(0);\n               \n    //Light\n    const float direcitonalLightBrightness = 1.0;\n    float l1Time = 0.0;//iTime;\n    vec3 light_pos = vec3( sin(l1Time)*2.0, 3.0+sin(l1Time)*0.5+0.5, cos(l1Time)*2.0 );       \n    vec3 lightCol = vec3(1.0,0.9,0.64);\n    col += direcitonalLightBrightness * LightShad( surf_pos, light_pos, world_normal,  lightCol );\n    \n  \n    //camera spotlight\n    const float camSpotBrightness = 1.1f;\n    col += camSpotBrightness*(max(0.0, -dot( world_normal, camz) ) / (d*d));\n    \n    //col *= Diff(surf_pos,world_normal);     //texture\n\n       \n    //specular\n    {\n        vec3 surf_to_light = light_pos - surf_pos;\n        float light_dist = length(surf_to_light);\n        surf_to_light = normalize(surf_to_light);\n        float spec = 0.0;\n        vec3 refl = reflect( -surf_to_light, world_normal );\n        spec = max(0.0, dot( refl, -raydir ));\n        col += direcitonalLightBrightness * vec3(pow( spec, 64.0 )) * lightCol;\n        //col = refl;\n\t}\n    \n    vec4 light2posrad = vec4(light_pos,0.05);\n    \n    //light spot\n    float l2d = DoRayToSphere( cameraPos, raydir, light2posrad );\n    float surfd = dToSphere( cameraPos + raydir * l2d, light2posrad );\n    float lightsphere = step( surfd, 0.01 ); //dist from light sphere surface\n    float infrontofscene = smoothstep(0.0,0.01,d-(l2d));\n    lightsphere *= infrontofscene;\n    col = mix( col, lightCol*2.0, lightsphere); \n    \n    col = min( vec3(1.0), col ); //clamp\n                \n    // Output to screen\n   \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}