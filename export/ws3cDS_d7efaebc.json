{"ver":"0.1","info":{"id":"ws3cDS","date":"1601619739","viewed":144,"name":"cellular-noise-distances","username":"phcs93","description":"cellular noise distance variations","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["noise","worley","cellular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// distance functions source: https://www.shadertoy.com/view/4lccW8\n\nfloat euclidean (vec2 v) {\n    return sqrt(pow(v.x,2.0)+pow(v.y,2.0));\n}\n\nfloat manhattan (vec2 v) {\n    return abs(v.x)+abs(v.y);\n}\n\nfloat chebyshev (vec2 v) {\n    return max(abs(v.x),abs(v.y));\n}\n\nfloat minkowski (vec2 v, float p) {\n    return pow(pow(abs(v.x),p)+pow(abs(v.y),p),1.0/p);\n}\n\nfloat worley (vec2 coord, int type, out float minIndex) {\n    \n\tvec2 i = floor(coord);\n\tvec2 f = fract(coord);\n\t\n\tfloat minDist = 999999.0;\n    //float minIndex = 0.0;\n    \n\tfor (float x = -1.0; x <= 1.0; x++) {\n\t\tfor (float y = -1.0; y <= 1.0; y++) {\n            \n            float speed = iTime * 5.0;\n            vec2 neighbor = vec2(x, y);\n            vec2 index = random(i + neighbor);\n            vec2 node = index + neighbor;\n            node = sin(speed + 6.2831 * node) * 0.5 + 0.5;\n            vec2 v = neighbor + node - f;\n\n            float dist = 0.0;\n\n            if (type == 1) {\n                dist = euclidean(v);\n            } else if (type == 2) {\n                dist = manhattan(v);\n            } else if (type == 3) {\n                dist = chebyshev(v);\n            } else {\n                // power of 1 gives you manhattan pattern\n                // power of 2 gives you euclidean pattern\n                // power of 10 gives you chebychev pattern\n                // power of 1000 gives you a mosaic pattern (index)\n                dist = minkowski(v, 1000.0);\n            }\n            \n            if (dist < minDist) {\n                minDist = dist;                \n                minIndex = index.x + index.y;\n            }\n            \n\t\t}\n\t}\n    \n    minIndex = minIndex * 0.5 + 0.5;\n    \n\treturn minDist;\n    \n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {  \n\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 olduv = uv;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 10.0;\n    \n    bool mobile = iResolution.x < iResolution.y;  \n    \n    int type = 0;\n    \n    if ((mobile ? olduv.y : olduv.x) < 0.25) {\n        type = 1;\n    } else if ((mobile ? olduv.y : olduv.x) < 0.5) {\n        type = 2;\n    } else if ((mobile ? olduv.y : olduv.x) < 0.75) {\n        type = 3;\n    } else {\n        type = 4;\n    }\n    \n    float i = 0.0;\n    \n    float d = worley(uv, type, i);    \n\n    float v = (mobile ? olduv.x : olduv.y) > 0.5 ? d : i;\n\n    fragColor = vec4(vec3(v), 1.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"uint hash (uint v) {\n    v += (v << 10u);\n    v ^= (v >>  6u);\n    v += (v <<  3u);\n    v ^= (v >> 11u);\n    v += (v << 15u);\n    return v;\n}\n\nuint hash (uvec2 v) { return hash(v.x^hash(v.y)); }\nuint hash (uvec3 v) { return hash(v.x^hash(v.y)^hash(v.z)); }\nuint hash (uvec4 v) { return hash(v.x^hash(v.y)^hash(v.z)^hash(v.w)); }\n\nfloat floatConstruct (uint v) {\n    v &= 0x007FFFFFu; // ieee mantissa\n    v |= 0x3F800000u; // ieee one\n    return uintBitsToFloat(v)-1.0;\n}\n\nfloat random (float v) { return floatConstruct(hash(floatBitsToUint(v))); }\n//float random (vec2 v) { return floatConstruct(hash(floatBitsToUint(v))); }\n//float random (vec3 v) { return floatConstruct(hash(floatBitsToUint(v))); }\n//float random (vec4 v) { return floatConstruct(hash(floatBitsToUint(v))); }\n\nvec2 random (vec2 v){\n    v = vec2(random(v.x),random(v.y));\n \tconst vec2 k = vec2(3.1415926,2.71828);\n \tv = v*k+v.yx;\n \treturn -1.0+2.0*fract(2.0*k*fract(v.x*v.y*(v.x+v.y)));\n}\n\n//vec3 random (vec3 v){\n//    v = vec3(random(v.x),random(v.y),random(v.z));\n//    const vec3 k = vec3(3.1415926,2.71828,6.62607015);\n//    v = v*k+v.zyx;\n//    return -1.0+2.0*fract(2.0*k*fract(v.x*v.y*v.z*(v.x+v.y+v.z)));\n//}","name":"Common","description":"","type":"common"}]}