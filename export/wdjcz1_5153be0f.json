{"ver":"0.1","info":{"id":"wdjcz1","date":"1590328460","viewed":330,"name":"Quadratic Filter","username":"spalmer","description":"1d version of paniq's biquadratic filter [url]https://shadertoy.com/view/wtXXDl[/url]\nwhite = quadratic filtered noise, blue = integer cells, green = derivative, red = linear filtered noise for comparison\n","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["filter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 1d version of paniq's biquadratic filter\n// https://shadertoy.com/view/wtXXDl\n// so I can understand it better\n\n// it's a linear filter of a linear filter,\n// so a 2nd order filter. Which makes it quadratic!\n// The effect is not cubic.  Only C1 continuous.\n// (C0? I'm not good with academic continuity)\n\n// As can be seen when used as biquadratic filter on a \n// heightfield (browse my toys), the eye easily picks up\n// the discontinuities in the gradient at\n// grid cell boundaries.  You can't tell here though.\n// Except by looking at the plot of the derivative,\n// which is completely linear, not smooth.\n// And since it's a 1D variant of the 2D bi-quadratic filter,\n// I suppose it should be called simply \"Quadratic Filter\"\n\n// we need 1D noise, but only have 2D noise textures available.\nconst float v = 1.; // which row of the noise texture in iChannel0 to use\n\n#define NZ iChannel0\n#define NR iChannelResolution[0].x\n\n// all these fetches work on all 4 channels\nvec4 fetch(sampler2D ch, int nr, int q)\n{\n    q %= nr; //q = clamp(q, 0, nr-1); //.-1e-4); //mod(q, NR); //\n    return texelFetch(ch, ivec2(q, v), 0);\n}\n\n// given 2 vec4 samples x, interpolate linearly\nvec4 filter_linear(mat2x4 x, float q, out vec4 gradient)\n{\n    float q0 = (1.-q), q1 = q;\n\tgradient = 2.*(x[1] - x[0]);\n    return mix(x[0], x[1], q);\n}\n\nvec4 fetch_linear(sampler2D ch, float res, float u) \n{\n    vec4 g;\n\tconst ivec2 _ = ivec2(0, 1);\n    u *= res;\n    u -= .5; // kludge bias to match quadratic\n    int t = int(u), r = int(res);\n    float q = u - float(t);\n    mat2x4 m = mat2x4(\n      fetch(ch, r, t + _.x)\n    , fetch(ch, r, t + _.y)\n\t);\n    vec4 gr;\n    return filter_linear(m, q, gr);\n//\treturn mix(m[0], m[1], q);\n}\n\n// given 3 vec4 samples x, interpolate quadratically\nvec4 filter_quadratic(mat3x4 x, float q, out vec4 gradient)\n{\n    float q0 = .5 * (q+1.), q1 = .5 * q;\n\tgradient = mix(x[1], x[2], q) - mix(x[0], x[1], q);\n    return mix(mix(x[0], x[1], q0), mix(x[1], x[2], q1), q);\n}\n\n// abstracts the sampling from texture for the quadratic filter\nmat3x4 fetch3(sampler2D ch, float res, float u, out float q)\n{\n\tconst ivec3 _ = ivec3(-1, 0, 1);\n    u *= res;\n    int t = int(u), r = int(res);\n    q = u - float(t);\n    return mat3x4(\n      fetch(ch, r, t + _.x)\n    , fetch(ch, r, t + _.y)\n    , fetch(ch, r, t + _.z)\n      );\n}\n\n// doing both cubic filtered value and the gradient together\n// is superior as it shares all the sampling and most of the setup\nvec4 fetch_quadratic_both(sampler2D ch, float res, float u, out vec4 gradient) \n{\n    float q;\n    mat3x4 x = fetch3(ch, res, u, q);\n    return filter_quadratic(x, q, gradient);\n//\tfloat q0 = .5 * (q+1.), q1 = .5 * q;\n//\tgradient = mix(x[1], x[2], q) - mix(x[0], x[1], q);\n//\treturn mix(mix(x[0], x[1], q0), mix(x[1], x[2], q1), q);\n}\n\nvec4 fetch_quadratic(sampler2D ch, float res, float u) \n{\n    vec4 g;\n\treturn fetch_quadratic_both(ch, res, u, g);\n}\n\nvec4 fetch_quadratic_gradient(sampler2D ch, float res, float u) \n{\n    vec4 g;\n\tvec4 d = fetch_quadratic_both(ch, res, u, g);\n    return g;\n}\n\nfloat graph(float g, float v)\n{\n    return clamp(.5 - .5 * iResolution.y * abs(v - g) \n        / (1. + iResolution.y * abs(dFdx(g)))\n        , 0., 1.);\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    vec2 uv = p/iResolution.xy;\n    float u = uv.x/3. + iTime * .003, g, gd, gg, gl\n        , anim = sin(.5*iTime);\n    vec4 g4;\n    g = fetch_quadratic_both(NZ, NR, u, g4).r;\n    gl = fetch_linear(NZ, NR, u).r;\n    gd = g4.r;\n    gd = gd * .25 + .5; // scale derivative\n    gg = exp2(-.04*iResolution.x*(.5 - abs(.5-fract(u * NR)))); // grid cells\n    gg = max(gg, exp2(-.7*iResolution.y*abs(uv.y-.5)));\n    gg *= 1.-abs(anim);\n    gg *= gg * .5;\n    g  = graph(g , uv.y);\n    gd = graph(gd, uv.y) * max(0., anim);\n    gl = graph(gl, uv.y) * max(0.,-anim);\n    vec3 c = vec3(max(g, gl), max(g, gd), max(g, gg));\n    c = pow(c, vec3(1./2.2));\n    o = vec4(c,1);\n}\n\n","name":"Image","description":"","type":"image"}]}