{"ver":"0.1","info":{"id":"3lSGzc","date":"1560490105","viewed":439,"name":"LiveCoding VJ result","username":"edo_m18","description":"This is a result of a live coding VJ event.","likes":5,"published":1,"flags":96,"usePreview":0,"tags":["vj"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec2 blurCenter = vec2(0.5);\nfloat freq;\n\nvec3 radialEffect(vec2 uv)\n{\n    float s = 10.0;\n    vec2 dir = blurCenter - uv;\n    float dist = length(dir);\n    dir = normalize(dir) * (1.0 / iResolution.xy);\n    float power = freq * 15.0;\n    dir *= power * dist;\n    \n    vec3 col = texture(iChannel1, uv).rgb / s;\n    \n    for (float j = 0.0; j < s; j++)\n    {\n        col.r += texture(iChannel1, uv + (vec2(0.00, 0.00) * freq) + (dir * j)).r / s;\n        col.g += texture(iChannel1, uv + (vec2(0.02, 0.02) * freq) + (dir * j)).g / s;\n        col.b += texture(iChannel1, uv + (vec2(0.05, 0.05) * freq) + (dir * j)).b / s;\n    }\n    \n    return col;\n}\n\nvec3 mosaicEffect(vec2 uv)\n{\n    float s = 1000.0 * freq;\n    vec2 gv = floor(uv * s) / s;\n    \n    return texture(iChannel1, gv).rgb;\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    freq = pow(T(iChannel0, vec2(0.0, 0.85)).x, 3.0);\n    \n    vec2 uv = U / R.xy;\n    \n    float interval = 5.0;\n    float sceneNum = 5.0;\n    float sceneId = mod(iTime / interval, sceneNum);\n    \n    float s = mod(floor(iTime / 2.), 5.);\n    float mask = step(sceneId, 3.0);\n    s = max((s - 1.) * mask, 1.);\n    \n    vec2 gv = fract(uv * s);\n\n    \n    #define USE_FILTER 1\n    \n    #if USE_FILTER == 1\n    vec3 col = radialEffect(gv);\n    #else\n    vec3 col = T(iChannel1, uv).rgb;\n    #endif\n    \n    O = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265358979\n#define PI_TWO 6.283185307179586\n\n#define T(tex, uv) texture(tex, uv)\n#define S(a, b, t) smoothstep(a, b, t)\n#define repeat(pos, span) mod(pos, span) - (span * 0.5)\n#define R iResolution\n#define normal(p, map) normalize(map(p).d - vec3(map(p - eps.xyy).d, map(p - eps.yxy).d, map(p - eps.yyx).d))\n//#define Mod(a, b) fract(abs(a / b)) * abs(b)\n\nconst vec3 UP = vec3(0, 1, 0);\nconst vec3 ROLL = normalize(vec3(0.5, 1.0, 0.0));\n\nfloat[4] freqs;\nconst vec2 eps = vec2(0.0001, 0.0);\n\nstruct Material\n{\n    // distance\n    float d;\n    \n    // type\n    int t;\n};\n\nfloat hash(float n) { return fract(sin(n) * 13.5453123); }\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n                         -0.80,  0.36, -0.48,\n                         -0.60, -0.48,  0.64);\n\nfloat noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    \n    f = f * f * (3.0 - 2.0 * f);\n    \n    float n = p.x + p.y * 57.0 + 113.0 * p.z;\n    \n    float res = mix(mix(mix(hash(n +   0.0), hash(n +   1.0), f.x),\n                                  mix(hash(n +  57.0), hash(n +   58.0), f.x), f.y),\n                            mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n                                   mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);\n    return res;\n}\n\nfloat fbm(vec3 p)\n{\n    float f;\n    f   = 0.5000 * noise(p); p = m * p * 2.02;\n    f += 0.2500 * noise(p); p = m * p * 2.03;\n    f += 0.1250 * noise(p);\n    return f;\n}\n\nfloat rand(vec2 seed)\n{\n\treturn fract(sin(dot(seed, vec2(12.9898, 78.233))) * 43758.5453);\n}\nmat2 rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\t// Inverse matrix.\n    return mat2(s, c, -c, s);\n}\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n\tvec3 a = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat r = 1.0 - c;\n\tmat3 m = mat3(\n\t\t\ta.x * a.x * r + c,\n\t\t\ta.y * a.x * r + a.z * s,\n\t\t\ta.z * a.x * r - a.y * s,\n\t\t\ta.x * a.y * r - a.z * s,\n\t\t\ta.y * a.y * r + c,\n\t\t\ta.z * a.y * r + a.x * s,\n\t\t\ta.x * a.z * r + a.y * s,\n\t\t\ta.y * a.z * r - a.x * s,\n\t\t\ta.z * a.z * r + c\n\t\t     );\n\treturn m * p;\n}\n\nmat3 camera(vec3 ro, vec3 ta, vec3 up)\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cu = normalize(cross(cw, up));\n\tvec3 cv = normalize(cross(cu, cw));\n\treturn mat3(cu, cv, cw);\n}\n\nfloat getTheta(vec2 uv)\n{\n    vec2 nuv = normalize(uv);\n\treturn fract(atan(nuv.y, nuv.x) / PI_TWO);\n}\n\nfloat hexDist(vec2 p)\n{\n    p = abs(p);\n    \n    float c = dot(p, normalize(vec2(1., 1.73)));\n    \n    return max(c, p.x);\n}\n\nvec4 hexCoords(vec2 uv)\n{\n    vec2 r = vec2(1., 1.73);\n    vec2 h = r * 0.5;\n    vec2 a = mod(uv, r) - h;\n    vec2 b = mod(uv - r * 0.5, r) - h;\n    vec2 gv = length(a) < length(b) ? a : b;\n    \n    vec2 id = gv - uv;\n    \n    float x = atan(gv.x, gv.y);\n    float y = 0.5 - hexDist(gv);\n    \n    return vec4(x, y, id);\n}\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp(abs(mod(c.x * 6. + vec3(0, 4, 2), 6.) - 3.) - 1., 0., 1.);\n\treturn c.z * mix(vec3(1), rgb, c.y);\n}\n\nvec3 hue2rgb(float h)\n{\n    return clamp(abs(mod(h * 6. + vec3(0, 4, 2), 6.) - 3.) - 1., 0., 1.);\n}\n\nfloat gray(vec3 c)\n{\n    const vec3 g = vec3(0.2126, 0.7152, 0.722);\n    return dot(c, g);\n}\n\nfloat gray(vec4 c)\n{\n    const vec4 g = vec4(0.2126, 0.7152, 0.722, 0.0);\n    return dot(c, g);\n}\n\nvec3 sobelFilter(sampler2D tex, vec2 uv, float dx, float dy, vec3 col, float i)\n{    \n    //float dx = 1.0 / iResolution.x;\n    //float dy = 1.0 / iResolution.y;\n    \n    float c00 = gray(texture(tex, uv - vec2(-dx, -dy)));\n    float c01 = gray(texture(tex, uv - vec2(-dx, 0.0)));\n    float c02 = gray(texture(tex, uv - vec2(-dx,  dy)));\n    \n    float c10 = gray(texture(tex, uv - vec2(0.0, -dy)));\n    float c12 = gray(texture(tex, uv - vec2(0.0,  dy)));\n    \n    float c20 = gray(texture(tex, uv - vec2(dx, -dy)));\n    float c21 = gray(texture(tex, uv - vec2(dx, 0.0)));\n    float c22 = gray(texture(tex, uv - vec2(dx,  dy)));\n    \n    float sx = -1.0 * c00 + -2.0 * c10 + -1.0 * c20 + c02 + 2.0 * c12 + c22;\n    float sy = -1.0 * c00 + -2.0 * c01 + -1.0 * c02 + c02 + 2.0 * c21 + c22;\n    \n    float g = sqrt(sx * sx + sy * sy);\n    \n    vec4 sobel = g > 0.9 ? vec4(1) : vec4(0);\n    \n    return mix(col, sobel.rgb, i);\n}\n\nMaterial Add(Material a, Material b)\n{\n\tif (a.d < b.d)\n    {\n        return a;\n    }\n    else\n    {\n        return b;\n    }\n}\n\n\nMaterial And(Material a, Material b)\n{\n    if( a.d < b.d)\n    {\n        return b;\n    }\n    else\n    {\n        return a;\n    }\n}\n\n\nvec3 mod289(vec3 x)\n{\n    return x - floor(x / 289.0) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n    return x - floor(x / 289.0) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n    return mod289((x * 34.0 + 1.0) * x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - r * 0.85373472095314;\n}\n\nvec3 snoise_grad(vec3 v)\n{\n    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy));\n    vec3 x0 = v   - i + dot(i, C.xxx);\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n\n    // x1 = x0 - i1  + 1.0 * C.xxx;\n    // x2 = x0 - i2  + 2.0 * C.xxx;\n    // x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy;\n    vec3 x3 = x0 - 0.5;\n\n    // Permutations\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec4 p =\n      permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0))\n                            + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n                            + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    vec4 j = p - 49.0 * floor(p / 49.0);  // mod(p,7*7)\n\n    vec4 x_ = floor(j / 7.0);\n    vec4 y_ = floor(j - 7.0 * x_);  // mod(j,N)\n\n    vec4 x = (x_ * 2.0 + 0.5) / 7.0 - 1.0;\n    vec4 y = (y_ * 2.0 + 0.5) / 7.0 - 1.0;\n\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n\n    //vec4 s0 = vec4(lessThan(b0, 0.0)) * 2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1, 0.0)) * 2.0 - 1.0;\n    vec4 s0 = floor(b0) * 2.0 + 1.0;\n    vec4 s1 = floor(b1) * 2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n    vec3 g0 = vec3(a0.xy, h.x);\n    vec3 g1 = vec3(a0.zw, h.y);\n    vec3 g2 = vec3(a1.xy, h.z);\n    vec3 g3 = vec3(a1.zw, h.w);\n\n    // Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(g0, g0), dot(g1, g1), dot(g2, g2), dot(g3, g3)));\n    g0 *= norm.x;\n    g1 *= norm.y;\n    g2 *= norm.z;\n    g3 *= norm.w;\n\n    // Compute gradient of noise function at P\n    vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);\n    vec4 m2 = m * m;\n    vec4 m3 = m2 * m;\n    vec4 m4 = m2 * m2;\n    vec3 grad =\n      -6.0 * m3.x * x0 * dot(x0, g0) + m4.x * g0 +\n      -6.0 * m3.y * x1 * dot(x1, g1) + m4.y * g1 +\n      -6.0 * m3.z * x2 * dot(x2, g2) + m4.z * g2 +\n      -6.0 * m3.w * x3 * dot(x3, g3) + m4.w * g3;\n    return 42.0 * grad;\n}\n\nvec2 getRotationUV(vec2 uv, float angle, float power) {\n\tvec2 v = vec2(0);\n\tfloat rad = angle * 3.14159265359;\n\t\n\tv.x = uv.x + cos(rad) * power;\n\tv.y = uv.y + sin(rad) * power;\n\n\treturn v;\n}\n\n\n// =============================================================================\n// distance functions\n\nMaterial sdSphere(vec3 p, float s)\n{\n    float d = length(p) - s;\n    return Material(d, 0);\n}\n\nMaterial sdBox(vec3 p, vec3 b)\n{\n    float d = length(max(abs(p) - b, 0.0));\n    return Material(d, 1);\n}\n\nMaterial sdPlane(vec3 p, vec4 n)\n{\n    float d = dot(p, n.xyz) + n.w;\n    return  Material(d, 0);\n}\n\nMaterial sdCylinder(vec3 p, vec3 c)\n{\n    float d = length(p.xz - c.xy) - c.z;\n\treturn Material(d, 0);\n}\n\nMaterial sdPlanes(vec3 p)\n{\n    p = abs(p);\n    \n    float d = max(max(p.x, p.y), p.z) - 0.5;\n\treturn Material(d, 0);\n}\n\nMaterial sdOctahedron( in vec3 p, in float s)\n{\n    p = abs(p);\n    float d = (p.x+p.y+p.z-s)*0.57735027;\n\n\treturn Material(d, 1);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// ================================\n// 1st scene ----------------------\nvoid scene1(out vec4 O, in vec2 U)\n{\n    vec2 uv = U / R.xy;\n    \n    float i = freqs[0] * 0.5;\n\n    uv.y = abs(uv.y * 2. - 1.) * 2.;\n    \n    float s = 100.;\n    vec2 id = floor(uv * s);\n\tfloat mask = float(mod(id.x, 2.) < 1.);\n    id /= s;\n    float mu = texture(iChannel0, id).x;\n    mu = step(0.1, mu - uv.y);\n    vec3 col = vec3(mu * mask);\n\n    vec3 rgb = hue2rgb(uv.x);\n    col *= rgb;\n\n    O = vec4(col, 1.0);\n}\n\n\n\n// ================================\n// 2nd scene ----------------------\nMaterial map2(vec3 p)\n{\n    return sdSphere(p, 0.65);\n}\n\nvoid scene2(out vec4 O, in vec2 U)\n{\n    vec2 uv = (U.xy - 0.5 * R.xy) / R.y;\n    vec2 nuv = normalize(uv);\n    float r = length(uv);\n    float th = fract(atan(nuv.y, nuv.x) / PI_TWO);\n    \n    float c = texture(iChannel0, vec2(th, 0.5)).x;\n    float y = S(0.1, 0.2, c - r);\n    float m = step(0.2, r);\n    \n    float grid = float(mod(th * 360., 3.) < 1.);\n    \n    vec4 col = vec4(y * hue2rgb(th) * grid * m, 1.);\n    \n    // ------\n    \n    vec3 ro = vec3(0, 0, 5);\n    vec3 ta = vec3(0, 0, 0);\n    \n    vec3 ray = camera(ro, ta, UP) * normalize(vec3(uv, 1.5));\n    \n    float d = 0., t = 0.;\n    \n    vec3 p = ro;\n    \n    const int max_march = 64;\n    int march = 0;\n    \n    for (int i = 0; i < max_march; i++)\n    {\n        d = map2(p).d;\n        march = i;\n        \n        if (d < 0.01) break;\n        \n        p += ray * d;\n        t += d;\n    }\n    \n    if (d < 0.01)\n    {\n        vec3 light = normalize(vec3(sin(iTime), 1, cos(iTime)));\n        vec3 n = normal(p, map2);\n        float diff = dot(n, light);\n        col.rgb += vec3(1.0 - d, 0, 0) * diff;\n    }\n    \n    O = col;\n}\n\n\n\n// ================================\n// 3rd scene ----------------------\nMaterial map3(vec3 p)\n{\n    vec3 q = -abs(p) + 1.5;\n    \n    Material m1 = sdPlane(q, vec4(0, 1, 0, 1));\n    \n    float rad = iTime * PI * 0.5;\n    p.xz = repeat(p.xz, 4.5);\n    q = rotate(p, rad, vec3(1));\n    Material m2 = sdOctahedron(q, 1.5 * freqs[2]);\n    \n    return Add(m1, m2);\n}\n\nvoid scene3(out vec4 O, in vec2 U)\n{\n    vec2 uv = (U - 0.5 * R.xy) / R.y;\n\n    vec3 col = vec3(0);\n    \n    float time = iTime * 0.3;\n    vec3 ro = vec3(cos(time) * 20.0, 0, sin(time) * 20.0);\n    vec3 ta = vec3(0, 0, 0);\n    \n    vec3 ray = camera(ro, ta, ROLL) * normalize(vec3(uv, 1.5));\n    \n    vec3 p = ro;\n    \n    float t = 0.0;\n    Material m;\n    for (int i = 0; i < 128; i++)\n    {\n        m = map3(p);\n        \n        if (m.d < 0.01) break;\n        \n        p += ray * m.d;\n        t += m.d;\n    }\n    \n    if (m.d < 0.01)\n    {\n        if (m.t == 0)\n        {\n            vec2 st = p.xz;\n            vec4 hc = hexCoords(st);\n        \n            float time = iTime * 5.0;\n\n            float l = pow(sin((length(hc.zw) - time) * 0.3), 4.0);\n\n            vec3 c = vec3(S(0.01, 0.03, hc.y));\n\n            float f = exp(-t * 0.08);\n\n            col.rgb = c * l * f * hue2rgb(hc.w);\n        }\n        else if (m.t == 1)\n        {\n            vec3 n = normal(p, map3);\n            vec3 light = normalize(vec3(1));\n            float diff = clamp(dot(n, light), 0.1, 1.0);\n            col = vec3(diff) * n;\n        }\n    }\n\n    vec3 fog = vec3(0.5, 0.7, 1.5) * t * 0.015;\n    \n    O = vec4(col + fog,1.0);\n}\n\n\n// ================================\n// 4th scene ----------------------\nMaterial map4(vec3 p)\n{    \n    float h = 1.8;\n    float grid = 1.3;\n    \n    vec3 g = ceil(p / grid);\n    \n    float rxz = rand(g.xz) * freqs[0];\n    \n    p = -abs(p);\n    \n    float d1 = p.y + h + rxz;\n    float d2 = p.x + h * 0.6;\n    \n    vec3 q = repeat(p, vec3(grid));\n    Material mc = sdCylinder(q, vec3(0.1, 0.0, .5));\n    float d = max(max(d1, mc.d), d2);\n    \n    return Material(d, 0);\n}\n\nvoid scene4(out vec4 O, in vec2 U)\n{\n    vec2 uv = (U - 0.5 * R.xy) / R.y;\n\n    vec3 ro = vec3(cos(iTime * 0.1), sin(iTime * 0.1), iTime * 5.);\n    vec3 ta = vec3(cos(iTime), sin(iTime), iTime * 5. + 10.);\n    \n    vec3 ray = camera(ro, ta, ROLL) * normalize(vec3(uv, 1.5));\n    \n    Material m;\n    float t = 0.;\n    \n    vec3 p = ro;\n    \n    const int marx_march = 128;\n    int march = 0;\n    for (int i = 0; i < marx_march; i++)\n    {\n        m = map4(p);\n        \n        march = i;\n        \n        if (m.d < 0.01) break;\n        \n        p += ray * m.d;\n        t += m.d;\n    }\n    \n    vec3 col = vec3(0);\n    \n    if (m.d < 0.01)\n    {\n        vec3 n = normal(p, map4);\n        float v = max(0., dot(n, -ray));\n        col = vec3(v);\n    }\n    \n    float fog = min(1.0, (1.0 / float(marx_march)) * float(march));\n    vec3 rgb = hue2rgb(sin(iTime * 0.1));\n    vec3 fog2 = t * 0.01 * rgb;\n    col = col * fog + fog2;\n    O = vec4(col, 1.0);\n}\n\n\n\n// ================================\n// 5th scene ----------------------\nfloat burn;\n\nMaterial map5(vec3 p)\n{\n    float d1 = length(p) - 1. * freqs[3];\n\n    mat2 r = rot(iTime * 2.0 + length(p));\n    p.xy *= r;\n    p.zy *= r;\n    \n    p = abs(p);\n    p = abs(p - round(p)) *  2.5 * freqs[3];\n    \n    float l1 = length(p.xy);\n    float l2 = length(p.yz);\n    float l3 = length(p.xz);\n    \n    float g = 0.01;\n    float d2 = min(min(l1, l2), l3) + g;\n    \n    burn = pow(d2 - d1, 2.0);\n    \n    float d = min(d1, d2);\n\treturn Material(d, 0);\n}\n\nvoid scene5(out vec4 O, in vec2 U)\n{\n    vec2 uv = (2.0 * U - R.xy) / R.y;\n    vec3 ro = normalize(vec3(uv, 1.5));\n    \n    vec3 ta = vec3(0, 0, -2.5);\n    \n    float t = 0.;\n    for  (int i = 0; i < 30; i++)\n    {\n        t += map5(ta + ro * t).d * 0.5;\n    }\n\n    O = vec4(1.0 - burn, 0, exp(-t), 1.0);\n}\n\n\n\n\n// ==========================================\n// Entry point\n// ==========================================\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    freqs[0] = texture(iChannel0, vec2(0.01, 0.25)).x;\n\tfreqs[1] = texture(iChannel0, vec2(0.07, 0.25)).x;\n\tfreqs[2] = texture(iChannel0, vec2(0.15, 0.25)).x;\n\tfreqs[3] = texture(iChannel0, vec2(0.30, 0.25)).x;\n    \n    float interval = 5.0;\n    float sceneNum = 5.0;\n    float sceneId = mod(iTime / interval, sceneNum);\n\n    #define SCENE 0\n    \n    #if SCENE == 1\n    scene1(O, U);\n    return;\n    #elif SCENE == 2\n    scene2(O, U);\n    return;\n    #elif SCENE == 3\n    scene3(O, U);\n    return;\n    #elif SCENE == 4\n    scene4(O, U);\n    return;\n    #elif SCENE == 5\n    scene5(O, U);\n    return;\n    #else\n    \n    if (sceneId < 1.0)\n    {\n        scene1(O, U);\n    }\n    else if (sceneId < 2.0)\n    {\n        scene2(O, U);\n    }\n    else if (sceneId < 3.0)\n    {\n        scene5(O, U);\n    }\n    else if (sceneId < 4.0)\n    {\n        scene3(O, U);\n    }\n    else\n    {\n        scene4(O, U);\n    }\n    #endif\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XllGR2","filepath":"https://soundcloud.com/elektrik-dreams-music/nicola-cite-borderline-original-mix-out-now-on-beatport","previewfilepath":"https://soundcloud.com/elektrik-dreams-music/nicola-cite-borderline-original-mix-out-now-on-beatport","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 O, in vec2 U )\n{\n    vec2 uv = U.xy / R.xy;\n    O = texture(iChannel0, uv);\n}","name":"Buffer B","description":"","type":"buffer"}]}