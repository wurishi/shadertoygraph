{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#ifdef GL_ES\nprecision highp float;\n#endif\n\n#define resolution iResolution\n#define time iTime\n////include \"tex_bomb.sh\"\n\n//uniform float time;\n//uniform vec2 resolution;\n\n//float time = 10.0;\n\n//vec2 resolution = vec2(800,600);\n\nstruct Cam{\n\tvec3 pos;\n\tvec3 dir;\n\tvec3 up;\n\tvec3 ray;\n};\n\nstruct Disp{\n\tvec3 origin;\n\tvec2 uvpos;\n\tfloat aspectRatio;\n\tvec3 hit;\n};\n\nstruct CastRes {\n\tfloat dist;\n\tvec3 pos;\n\tvec3 color;\n\tfloat id;\n};\n\n#define MAX_DIST 80.0\n#define MAX_ITERATIONS  100\t\n\t\n#define EPS 0.00001\n\n#define ID_NONE 0.\t\n#define ID_PLANE 1.\t\n#define ID_BOX 2.\n#define ID_SPHERE 3.\n#define ID_SNEG 4.\t\n#define ID_CONE 5.\n#define ID_EYE 6.\t\n#define ID_STVOL 7.\n#define ID_ELKA 8.\t\n#define ID_STAR\t9.\n\t\nvec3 lightPos = vec3(10.0, 10.0, 10.0);\nvec3 lightDirP = vec3(0,0,0);\nvec3 lightDir = -normalize(lightDirP - lightPos);\nvec3 lightCol = vec3(0.9, 0.7, 0.9);\t\n\nvec3 CamPos(float t){ // camera position func\n\t//return vec3(0., 1.0, 1.0);\n\t//return vec3(2., 2., 2.);\n\t//return vec3(sin(t*0.45)*2.0 +1.5 ,2.3, cos(t*0.45) * 2.0 +1.5);\n\treturn vec3(1.0 + 2.5*cos(t*0.25), 1.5, 0.0 + 2.5 * sin(t*0.25)); // circle x = x0 + r * cos(phi); y = y0 + r * sin(phi) \n\t//return vec3(sin(t + 1.0)*1.0, 1, cos(t)*1.0);\n}\n\nCam setCam(vec2 fragCoord)\n{\n\tCam cam;\n\tDisp scr;\n  \t\n\tcam.dir = vec3(1,1,0);\t // direction point\n\tcam.pos = CamPos(time); // position \n\tcam.up = vec3(0.0,1.0,0.0);\n  \t\n\t\n\tvec3 look_dir = normalize(cam.dir - cam.pos);\n  \tvec3 plane_left = cross(look_dir, cam.up);\n \tcam.up = cross(plane_left, look_dir);\n\t\n\tscr.origin = (cam.pos + look_dir);\n\tscr.uvpos = -1.0 + 2.0 * fragCoord.xy/resolution.xy; // uv coord\n \tscr.aspectRatio = resolution.x / resolution.y; // aspect ratio\n\tscr.hit = scr.origin + scr.uvpos.x * plane_left * scr.aspectRatio + scr.uvpos.y * cam.up;\n  \n\tcam.ray = normalize(scr.hit - cam.pos);\n\t\n\treturn cam;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand(vec3 co){\n    return fract(sin(dot(co.xyz ,vec3(12.9898,78.233,47.985))) * 43758.5453);\n}\n\n// credit: iq/rgba\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n\n// credit: iq/rgba\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdHPlane( vec3 p, float n)\n{ \n  return p.y + n;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y);\n\t\tfloat t = sin(time)*sin(p.z);\n        return max( max( dot(q,c.xy), p.y), -p.y-c.z );\n}\n\nfloat opU( float d1, float d2)\n{\n    return min(d1,d2);\n}\n\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  return max( length(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n\n// Simple 2d noise algorithm contributed by Trisomie21 (Thanks!)\nfloat snoise( vec2 p ) {\n\tvec2 f = fract(p);\n\tp = floor(p);\n\tfloat v = p.x+p.y*1000.0;\n\tvec4 r = vec4(v, v+1.0, v+1000.0, v+1001.0);\n\tr = fract(100000.0*sin(r*.001));\n\tf = f*f*(3.0-2.0*f);\n\treturn 2.0*(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y))-1.0;\n}\n\n/*float disp(vec3 p)\n{\n\treturn noise(5.*p-vec3(1.5,2.5,3.5))+noise(p*0.4)*0.5;//*sin(time);\n\t//return -sin(0.5* p.x)*sin(0.5 * p.y)*sin(.5*p.z)*sin(time*0.5);\n}*/\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nvec3 sp_pos;\n\nCastRes DistFunc(CastRes d)\n{\n\t#define SEL_OBJ(oid) if(dd < d.dist) {d.dist = dd; d.id = oid;}\n\tfloat dd;\t\t\n\td.id = ID_NONE;\n\td.dist = length(d.pos);\n\t\n\tif(d.pos.y > 5.){\n\t\n\t\treturn d;\n\t}\n\t\n\tdd = sdHPlane(d.pos, 0.0);\n\tfloat wave = cos(d.pos.z)*0.6 + 0.1, wave1 = cos(d.pos.x)*0.5+0.3;\n\tfloat rv = wave  + wave1 + noise(d.pos);\n\tdd += -1.5 + rv + rand(d.pos)*0.00007;//sin(1.1*d.pos.x) * sin(1.1*d.pos.y) * sin(0.7*d.pos.z);\n\tSEL_OBJ(ID_PLANE);\n\tsp_pos = vec3(1.+2.0*cos(time), 1.0 + 1.0*cos(time), 0.0+2.0*sin(time));\n\tdd = sdSphere(d.pos - sp_pos, 0.15);\n\t\n\tSEL_OBJ(ID_SPHERE);\t\n\t\n\tvec3 dt = vec3(0);\n\tdd = opU(opU(sdSphere(d.pos - vec3(1.0, 0, 0.0)+dt, 0.5), sdSphere(dt+d.pos - vec3(1.0, 0.7, 0.0), 0.4)),sdSphere(dt + d.pos - vec3(1.0, 1.3, 0.0),0.3));\n\tdd += rand(d.pos)*0.00001;\n\t \n\tSEL_OBJ(ID_SNEG);\n\t\n\tdd =  sdSphere(dt + d.pos - vec3(1.1, 1.3, 0.3), 0.05);\n\tdd = opU(dd, sdSphere(dt + d.pos - vec3(0.9, 1.3, 0.3), 0.05));\t\t\n\tSEL_OBJ(ID_EYE);\n\t\t\n\tdd = opI( sdCone(dt + d.pos - vec3(1., 1.25, 0.6), normalize(vec2(0.5,0.1))), -sdPlane( dt + d.pos - vec3(2, 2.25, -0.1), normalize(vec4(0 ,0, 0.5, 0))) );\n\tdd = opI(opU(dd, sdCone(dt + d.pos - vec3(1., 2.4, 0), vec3(0.6,0.12, 0.9))), sdPlane(dt +  d.pos - vec3(2, 1.8, -0.1), normalize(vec4(0 ,1, 0.0, 0))));\n\tSEL_OBJ(ID_CONE);\n\t\n\tvec3 q = d.pos; // generate army of fir-tree\n\tq += vec3(-2.0, 0.0, -2.0);\t\n\tq.x = mod(q.x, 4.);\n\tq.z = mod(q.z, 4.);\n    q -= vec3(2.0, 0.0, 2.0);\n\n\tq.x = abs(q.x);  // mirror in X\t\n\n\t\n\tdd = sdCylinder(q - vec3(2.0, 0.0, 0.0), vec2(.2, 2.0));\n\tSEL_OBJ(ID_STVOL);\n\t\n\t\n\tdd = sdCone(q - vec3(2.0, 2.4, 0.0), vec3(0.6,0.4,0.5));\n\tdd = opU(dd, sdCone(q - vec3(2.0, 2.14, 0.0), vec3(0.4,0.3,0.6)));\n\tdd = opU(dd, sdCone(q - vec3(2.0, 1.69, 0.0), vec3(0.3,0.3,0.6)));      \n   \t\t\n\tSEL_OBJ(ID_ELKA);\n\t\nreturn d;\n}\nvec3 getNormal(CastRes res)\n{\n\tCastRes r = res, l = res;\n\t#define DELTA 0.02\n\tvec2 t = vec2(DELTA, 0);\n\tvec3 d;\n\tl.pos = res.pos + t.xyy;\n\tr.pos = res.pos - t.xyy;\n\td.x = DistFunc(l).dist - DistFunc(r).dist;\n\t\n\tl.pos = res.pos + t.yxy;\n\tr.pos = res.pos - t.yxy;\n\td.y = DistFunc(l).dist - DistFunc(r).dist;\n\n\tl.pos = res.pos + t.yyx;\n\tr.pos = res.pos - t.yyx;\n\td.z = DistFunc(l).dist - DistFunc(r).dist;\t\n\t\n\treturn normalize( d );\n}\n\nfloat ambientOcclusion(CastRes res, vec3 n) {\n    float step = 1.;\n    float ao = 0.0;\n    float dist;\n    CastRes cr = res;\n    for (int i = 1; i <= 3; i++) {\n        dist = step * float(i);\n\t cr.pos = res.pos + n * dist;\n\t\tao += max(0.0, (dist - DistFunc(cr).dist) / dist);  \n    }\n    return 1. - ao * 0.1;\n}\n\nvec3 sky(Cam cam, CastRes r)\n{\n\tvec3 color = vec3(0.1,0.2,0.4);\n\tfloat sun = clamp(dot(cam.ray,lightDir),0.3,1.0); // sun orb\n\t\tcolor += 0.8 * lightCol * sun*sun;\n\t\t// something like te aurora\n\t\tfloat c = snoise(vec2((r.pos.xy)*0.5) * 0.2*(sin(time*0.25)*0.5)); //0.1+time*0.5,\n\t\tcolor = mix( color, vec3(0.2, 1.0, 0.7), smoothstep(0.0, 3.5, c) );\n\t\treturn color;\n\n}\n\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )\n{\n    float r = 1.0;\n    float dt = 0.02;\n    float t = mint;\n    CastRes cr;\n    for( float i=0.; i<10.; i++ )\n    {\n        if( t < maxt )\n        {\n          cr.pos = ro + rd*t;\n          float h = DistFunc(cr).dist;\n          r = min( r, k*h/t );\n          t += max( 0.02, r);\n        }\n    }\n    return clamp( r, 0.0, 1.0 );\n\n}\n\nvec3 stars(vec3 d) //render stars \n{\t\n\tfloat s = snoise(d.xy*123.)*snoise(d.xy*345.);\n\ts=pow(s,15.0)*8.0;\n\treturn vec3(s);\n\n}\n\nvec3 GetColor(Cam cam, CastRes res)\n{\n\tvec3 c = vec3(0.5, 0.5, 0.9);\n\t\n\tvec3 norm = getNormal(res);\n\t\n\tvec3 ambcol = vec3(0.05,0.07,0.12)*7.0;\n\tvec3 difcol = vec3(0.9);\n\tvec3 groundcol = (lightCol + ambcol) * 1.0;\t\n\t\n\tfloat dif = clamp(dot(norm,lightDir),0.0,1.0);\t\t// diffuse\t\t\n\tvec3 refl = reflect(cam.ray,norm);\n\tvec3 spec = lightCol * pow(clamp(dot(lightDir,refl),0.0,1.0),2.0) * 0.2;\t\t\n\tvec3 totalspec = vec3(0.0);\t\n\tvec3 totaldif = vec3(0.0);\t\n\t\n\tfloat ao = ambientOcclusion(res, norm);\t\t//ambient oclusion\n\tfloat groundamb = pow(clamp(dot(norm, vec3(0.0,-1.0,0.0)),0.0,1.0),2.0); \n\tfloat shadow = 0.01;\n\t\n\tshadow = softshadow(res.pos, lightDir, 1., 5., 15.);\t\n\t\n\tdif *= shadow;\n\t\n\tvec3 splt = vec3(0.9, 0.4, 0.3);\n\tvec3 spdr = sp_pos - res.pos;\n\tfloat invDist= 0.5 / sqrt( dot(spdr,spdr) );\n\t spdr= spdr * invDist; \t\n\t\n\tfloat shadow2 = 1.0;\n\t\n\tif(res.id == ID_PLANE || res.id == ID_SNEG){\t\t\n\t\tfor(float i=0.0;i < 10.0;i++){\n\t\t\tvec3 p2 = res.pos * 20. + vec3(i*20.0);\n\t\t\tvec3 nor2 = normalize((vec3(noise(p2*1.5),noise(p2*5.),noise(p2*10.))-vec3(0.5)));\n\t\t\tfloat facetint = 0.05 + rand(p2);\t\t\t\n\t\t\tvec3 refl = reflect(cam.ray,nor2);\t\n\t\t\ttotalspec += pow(clamp(dot(lightDir,refl),0.0,1.0),200.0) * (clamp(dot(norm,lightDir)+0.1,0.0,1.0)) * facetint;\n\t\t}\n\t\t\n\t\tc =  splt * clamp(dot(spdr, norm),0.0,1.0) * shadow2 + c  * dif + totalspec*shadow + spec*shadow + ambcol * ao + groundcol * groundamb;\t\n\t\tfloat whitelevel = 1.2;\n\t\tc = (c  * (vec3(1.0) + (c / (whitelevel * whitelevel))  ) ) / (vec3(1.0) + c);\t\n\t\t\n\t\tc = pow(c,vec3(1.0/2.5))*exp(-res.dist*res.dist*0.005);//* (1.05 - res.dist * 0.05);               \t\n\t\n\t\treturn c;\t\t\n\t\n\t}\n\t\n\t\n\tif(res.id == ID_SPHERE){\n\t\tc = vec3(0.9, 0.4, 0.3);\n\t}\n\t\n\tif(res.id == ID_BOX){\n\t\tc = vec3(0.3,0.4,0.5);\n\t}\n\t\n\tif(res.id == ID_EYE)\n\t{\n\t\tc = vec3(0.7, 0.7, 1.0);\n\t}\n\t\n\tif(res.id == ID_CONE)\n\t{\n\t\tc = vec3(0.9, 0.5, 0.2);\n\t}\n\tif(res.id == ID_STVOL)\n\t{\n\t\tfloat ns = noise(res.pos*123.)*noise(res.pos*59.);\n\t\tc = vec3(0.7, 0.4, 0.2)*ns;/* * rand(vec2(res.dist))*0.5*/\n\t\t\n\t}\t\n\tif(res.id == ID_ELKA)\n\t{\n\t\tfloat ns = noise(res.pos*223.)*noise(res.pos*79.)*0.5;\n\t\tc = vec3(0.4, 0.9, 0.5);//*rand(res.pos)*0.2;\t\t\n\t\tc *= ns;\n\t\t\n\t\t\n\t}\t\n\tif(res.id == ID_STAR){\n\t\t//c = vec3(1.0);\n\t\t\n\t\treturn c;\n\t}\n\tif(res.id == ID_NONE) {\n\t\tc = sky(cam, res);\n\t\tc += stars(cam.ray)*0.5;\n\t\treturn c;\n\t}\n\t\n\t\n\t\n\t\n\n\t  \n\t\n\tc = splt * clamp(dot(spdr, norm),0.0,1.0)*0.2 + lightCol * c * dif + spec + ao*vec3(1.)*0.001;//\t+ ao *.1 + groundamb * groundcol * 0.3;\n    \t\n\tc = pow(c,vec3(1.0/2.5)) * exp(-res.dist*res.dist*0.005);// fog\n\t\n\treturn c;\n\t\n\t\n\t\n}\n\nCastRes rayCast(Cam cam)\n{\n\tCastRes res;\n\tres.color = vec3(0.1);\n\t\n\n\n\t\n\tfloat dist = 0.0;\n\n\tfor(int i = 0; i < MAX_ITERATIONS; ++i)\n\t{\n\t\tres.pos = cam.pos + cam.ray * dist;\n\t\tres = DistFunc(res);\n\t\t\n\t\tif(res.dist <= EPS)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tdist += res.dist;\n\t\t\t\t\n\t\tif(dist >= MAX_DIST)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tres.dist = dist;\n\t\n\tres.color = GetColor(cam, res);\n\n\treturn res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tCam camera = setCam(fragCoord);\n\tCastRes cr = rayCast(camera);\n\tfragColor = vec4(cr.color, 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xdf3zX","date":"1375102693","viewed":1052,"name":"snow","username":"uggway","description":"snow, ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raycast","procedural3d"],"hasliked":0,"parentid":"","parentname":""}}