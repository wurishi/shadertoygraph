{"ver":"0.1","info":{"id":"DdSGzV","date":"1674061065","viewed":491,"name":"ColorsShapesExplore00","username":"Pr0fed","description":"Exploring some simple shapes. Fascinated by the unexpected smooth curves appearing here and there. Tried to make a somewhat gradient of colors. ","likes":47,"published":1,"flags":0,"usePreview":0,"tags":["color","generative","shapes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime * 0.5\n\nconst float PI = 3.14159265359;\nconst float TWO_PI = 6.28318530718;\nconst float degreeToRad = 0.0174533;\n\nconst vec3 blackColor = vec3(0.0);\nconst vec3 darkGreyColor = vec3(0.12);\nconst vec3 brightGreyColor = vec3(0.88);\nconst vec3 white = vec3(1.0);\n\nfloat rand(float n)\n{\n \treturn fract(abs(cos(n*72.42))*173.42);\n}\n\nvec2 rotate(vec2 p, float angleDegree)\n{\n    float angleRad = angleDegree * 0.0174533;\n    return p * mat2(cos(angleRad), sin(angleRad),\n                   -sin(angleRad), cos(angleRad));\n}\n\nvec3 square(vec2 uv, vec2 pos, float size, vec3 color)\n{\n    vec3 retCol = vec3(0.0);\n    vec2 dist = abs(uv-pos);\n    if (dist.x < size && dist.y < size )\n    {\n        retCol = vec3(color);\n    }\n    return retCol;\n}\n\nvec3 rect(vec2 uv, vec2 pos, vec2 size, vec3 color)\n{\n    vec3 retCol = vec3(0.0);\n    vec2 dist = abs(uv-pos);\n    if (dist.x < size.x && dist.y < size.y)\n    {\n        retCol = vec3(color);\n    }\n    return retCol;\n}\n\nvec3 circle(vec2 uv, vec2 pos, float size, vec3 color)\n{\n    vec3 retCol = vec3(0.0);\n    if (distance(uv, pos) < size)\n    {\n        retCol = vec3(color);\n    }\n    return retCol;\n}\n\nvec3 triangle(vec2 uv, float size, vec3 color)\n{\n    float a = atan(uv.x, uv.y) + PI;    \n    float r = TWO_PI / float(3);\n    float d = cos(floor(.5 + a / r) * r - a) * length(uv * 2.);\n\n    return vec3(1.0 - smoothstep(size * 0.98, size, d)) * color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord / iResolution.xy);\n    float xOffset = 0.125;\n    uv -= vec2(xOffset, 0.0);\n    uv *= vec2(3.0) * vec2(iResolution.x / iResolution.y, 1.0);\n    \n    vec2 uvf = fract(uv);\n    vec2 uvi = floor(uv);\n    vec2 pos = uvi + vec2(0.5);\n\n    vec3 col = vec3(0.0);\n    // Rect - Column 0, Row 2 (0,0 is lower left corner)\n    if (int(uvi.x) == 0 && int(uvi.y) == 2)\n    {\n        col += square(uvi + uvf, pos, 0.5, darkGreyColor);\n        float angle = 45.0;\n        int stepsCount = 34;\n        vec3 stepColor0 = vec3(0.15, 0.15, 1.65) / float(stepsCount);\n        vec3 stepColor1 = vec3(0.125, 1.426, 0.78) / float(stepsCount);\n        float stepSize = 1.0 / float(stepsCount);\n        for(int i = 0; i < stepsCount; ++i)\n        {\n            vec2 size = vec2(0.37 - float(i) * (stepSize - (rand(pos.x*pos.y) * 0.02)));\n            size *= vec2(0.5 + 0.65 * abs(sin(float(i)* 0.05 + iTime * 0.1)));\n            vec3 finalColor = mix(stepColor0, stepColor1, float(i+1)/float(stepsCount));\n            col += rect(rotate(uvi+uvf, angle), rotate(pos, angle), size, finalColor);\n            angle += cos(iTime + (1.43 * float(i) * 4.1/ float(stepsCount))) * 19.0;\n        }\n    }\n    // Rect - Column 0, Row 1\n    if (int(uvi.x) == 0 && int(uvi.y) == 1)\n    {\n        col += square(uvi + uvf, pos, 0.5, darkGreyColor);\n        float angle = 0.0;\n        int stepsCount = 40;\n        vec3 stepColor0 = vec3(0.3, 0.3, 1.1) / float(stepsCount);\n        vec3 stepColor1 = vec3(0.281, 1.812, 1.7523) / float(stepsCount);\n        float stepSize = 1.0 / float(stepsCount);\n        for(int i = 0; i < stepsCount; ++i)\n        {\n            vec2 size = vec2(0.4 - float(i) * (stepSize - (rand(pos.x*pos.y) * 0.02))) * vec2(0.618, 0.83);\n            vec3 finalColor = mix(stepColor0, stepColor1, float(i)/float(stepsCount));\n            col += rect(rotate(uvi+uvf, angle), rotate(pos, angle), size, finalColor);\n            angle += sin(iTime + (8.2 * float(i)/ float(stepsCount))) * 12.0;\n        }\n    }\n    // Rect - Column 0, Row 0\n    if (int(uvi.x) == 0 && int(uvi.y) == 0)\n    {\n        col += square(uvi + uvf, pos, 0.5, darkGreyColor);\n        float angle = 0.0;\n        int stepsCount = 55;\n        vec3 stepColor0 = vec3(0.75, 0.01, 1.4) / float(stepsCount);\n        vec3 stepColor1 = vec3(0.641, 1.412, 1.3523) / float(stepsCount);\n        float stepSize = 1.0 / float(stepsCount);\n        for(int i = 0; i < stepsCount; ++i)\n        {\n            vec2 size = vec2(0.4 - float(i) * (stepSize - (rand(pos.x*pos.y) * 0.02))) * vec2(0.658, 1.33);\n            vec3 finalColor = mix(stepColor0, stepColor1, float(i)/float(stepsCount));\n            col += rect(rotate(uvi+uvf, angle), rotate(pos, angle), size, finalColor);\n            angle += cos(iTime + (8.0 * float(stepsCount-i)/ float(stepsCount))) * 6.0;\n        }\n    }\n    // Circle - Column 1, Row 2\n    if (int(uvi.x) == 1 && int(uvi.y) == 2)\n    {\n        col += square(uvi + uvf, pos, 0.5, darkGreyColor);\n        int stepsCount = 20;\n        vec3 stepColor0 = vec3(0.121, 0.412, 1.153) / float(stepsCount);\n        vec3 stepColor1 = vec3(0.121, 1.412, 0.753) / float(stepsCount);\n        float stepSize = 1.0 / float(stepsCount);\n        for(int i = 0; i < stepsCount; ++i)\n        {\n            float OneMinusI = float(stepsCount - i);\n            vec3 finalColor = mix(stepColor0, stepColor1, float(i)/float(stepsCount));\n            col += circle(uvi + uvf, pos, OneMinusI * (stepSize * 0.37), finalColor);\n            pos += sin(iTime) * vec2(cos(float(i) + iTime), sin(float(i) + iTime)) * 0.03;\n        }\n    }\n    // Circle - Column 1, Row 1\n    if (int(uvi.x) == 1 && int(uvi.y) == 1)\n    {\n        col += square(uvi + uvf, pos, 0.5, darkGreyColor);\n        int stepsCount = 60;\n        vec3 stepColor0 = vec3(0.25, 0.25, 2.163) / float(stepsCount);\n        vec3 stepColor1 = vec3(1.721, 0.112, 1.153) / float(stepsCount);\n        float stepSize = 1.0 / float(stepsCount);\n        for(int i = 0; i < stepsCount; ++i)\n        {\n            float OneMinusI = float(stepsCount - i);\n            vec3 finalColor = mix(stepColor0, stepColor1, float(i)/float(stepsCount));\n            col += circle(uvi + uvf, pos, OneMinusI * (stepSize * 0.43), finalColor);\n            pos += vec2(sin(0.7*iTime + (1.43 * float(i) * 4.1/ float(stepsCount))), -cos(1.2*iTime + (1.13 * float(i) * 3.1/ float(stepsCount)))) * 0.01;\n        }\n    }\n    // Circle - Column 1, Row 0\n    if (int(uvi.x) == 1 && int(uvi.y) == 0)\n    {\n        col += square(uvi + uvf, pos, 0.5, darkGreyColor);\n        int stepsCount = 70;\n        vec3 stepColor0 = vec3(1.4, 0.12, 0.73) / float(stepsCount);\n        vec3 stepColor1 = vec3(0.5, 1.5, 0.73) / float(stepsCount);\n        float stepSize = 1.0 / float(stepsCount);\n        for(int i = 0; i < stepsCount; ++i)\n        {\n            float OneMinusI = float(stepsCount - i);\n            vec3 finalColor = mix(stepColor0, stepColor1, float(i)/float(stepsCount));\n            col += circle(uvi + uvf, pos, OneMinusI * (stepSize * 0.3), finalColor);\n            pos += 5.0*sin(iTime * 0.1) * vec2(2.0*cos(float(i) + iTime * 0.8), 2.0*sin(float(i) + iTime * 1.2)) * 0.01;\n        }\n    }\n    // Triangle - Column 2, Row 2\n    if(int(uvi.x) == 2 && int(uvi.y) == 2)\n    {\n        col += square(uvi + uvf, pos, 0.5, darkGreyColor);\n        float angle = iTime * 21.0;\n        int stepsCount = 30;\n        vec3 stepColor0 = vec3(0.08, 0.912, 1.3) / float(stepsCount);\n        vec3 stepColor1 = vec3(0.903, 0.612, 0.152) / float(stepsCount);\n        float stepSize = 1.0 / float(stepsCount);\n        for(int i = 0; i < stepsCount; ++i)\n        {\n            vec3 finalColor = mix(stepColor0, stepColor1, float(i)/float(stepsCount));\n            col += triangle(rotate(uvf - vec2(0.5), angle), 0.4 * (abs(sin((float(i) * stepSize * 3.0) + iTime * 0.75))), finalColor);\n            angle += sin(iTime * 0.01) * 20.0;\n        }\n    }\n    // Triangle - Column 2, Row 1\n    if(int(uvi.x) == 2 && int(uvi.y) == 1)\n    {\n        col += square(uvi + uvf, pos, 0.5, darkGreyColor);\n        float angle = -iTime * 14.0;\n        int stepsCount = 70;\n        vec3 stepColor0 = vec3(1.712, 1.402, 0.132) / float(stepsCount);\n        vec3 stepColor1 = vec3(0.712, 0.302, 0.732) / float(stepsCount);\n        float stepSize = 1.0 / float(stepsCount);\n        for(int i = 0; i < stepsCount; ++i)\n        {\n            vec3 finalColor = mix(stepColor0, stepColor1, float(i)/float(stepsCount));\n            col += triangle(rotate(uvf - vec2(0.5), angle), 0.5 * (abs(sin((float(stepsCount-i) * stepSize * 4.0)))), finalColor);\n            angle += cos(0.2*iTime + (4.2 * float(i)/ float(stepsCount))) * 7.0;\n        }\n    }\n    // Triangle - Column 2, Row 0\n    if(int(uvi.x) == 2 && int(uvi.y) == 0)\n    {\n        col += square(uvi + uvf, pos, 0.5, darkGreyColor);\n        float angle = iTime * 17.0;\n        int stepsCount = 50;\n        vec3 stepColor0 = vec3(0.421,0.513,0.662) / float(stepsCount);\n        vec3 stepColor1 = vec3(1.521, 0.112, 0.143) / float(stepsCount);\n        float stepSize = 1.0 / float(stepsCount);\n        for(int i = 0; i < stepsCount; ++i)\n        {\n            vec3 finalColor = mix(stepColor0, stepColor1, float(i)/float(stepsCount));\n            col += triangle(rotate(uvf - vec2(0.5), angle), 0.45 * (abs(sin((float(i) * stepSize * 3.0) + iTime * 0.35))), finalColor);\n            angle += sin(0.4*iTime + (4.4 * float(i) / float(stepsCount))) + sin(1.4*iTime + (10.0 * float(stepsCount - i) / float(stepsCount))) * 4.0;\n        }\n    }\n    // Oval - Column 3, Row 2\n    if (int(uvi.x) == 3 && int(uvi.y) == 2)\n    {\n        col += square(uvi + uvf, pos, 0.5, darkGreyColor);\n        vec2 scale = vec2(2.5, 1.2);\n        vec2 scaledUV = (uvi + uvf) * scale;\n        vec2 scaledPos = pos * scale;\n        float angle = -iTime * 10.0;\n        int stepsCount = 40;\n        float stepSize = 1.0 / float(stepsCount);\n        vec3 stepColor0 = vec3(1.912, 1.412, -0.253) / float(stepsCount);\n        vec3 stepColor1 = vec3(0.502, 0.151, 0.346) / float(stepsCount);\n        for(int i = 0; i < stepsCount; ++i)\n        {\n            vec3 finalColor = mix(stepColor0, stepColor1, float(i)/float(stepsCount));\n            col += circle(rotate(uvi + uvf, angle) * scale, rotate(pos, angle) * scale, 0.5 - float(i) * (stepSize * 0.4), finalColor);\n            angle -= 11.0;\n        }\n    }\n    // Oval - Column 3, Row 1\n    if (int(uvi.x) == 3 && int(uvi.y) == 1)\n    {\n        col += square(uvi + uvf, pos, 0.5, darkGreyColor);\n        vec2 scale = vec2(2.1, 1.1) * 0.75;\n        vec2 scaledUV = (uvi + uvf) * scale;\n        vec2 scaledPos = pos * scale;\n        float angle = iTime * 10.0;\n        int stepsCount = 80;\n        float stepSize = 1.5 / float(stepsCount);\n        vec3 stepColor0 = vec3(1.912, 0.512, -0.253) / float(stepsCount);\n        vec3 stepColor1 = vec3(1.912, 1.402, 0.132) / float(stepsCount);\n        for(int i = 0; i < stepsCount; ++i)\n        {\n            vec3 finalColor = mix(stepColor0, stepColor1, float(i)/float(stepsCount));\n            col += circle(rotate(uvi + uvf, angle) * scale, rotate(pos, angle) * scale, 0.5 - float(i) * (stepSize * 0.4), finalColor);\n            angle += sin(0.3*iTime + (6.1 * float(i)/ float(stepsCount))) * 13.0;\n        }\n    }\n    // Oval - Column 3, Row 0\n    if (int(uvi.x) == 3 && int(uvi.y) == 0)\n    {\n        col += square(uvi + uvf, pos, 0.5, darkGreyColor);\n        vec2 scale = vec2(1.7, 1.3);\n        vec2 scaledUV = (uvi + uvf) * scale;\n        vec2 scaledPos = pos * scale;\n        float angle = iTime * 10.0;\n        int stepsCount = 60;\n        float stepSize = 1.0 / float(stepsCount);\n        vec3 stepColor0 = vec3(2.5, 0.03, 0.03) / float(stepsCount);\n        vec3 stepColor1 = vec3(0.0, 1.53, 0.52) / float(stepsCount);\n        for(int i = 0; i < stepsCount; ++i)\n        {\n            vec3 finalColor = mix(stepColor0, stepColor1, float(i)/float(stepsCount));\n            col += circle(rotate(uvi + uvf, angle) * scale, rotate(pos, angle) * scale, 0.5 - float(i) * (stepSize * 0.55), finalColor);\n            angle += abs(cos(0.2*iTime + (4.0 * float(i) / float(stepsCount)))) * 12.0;\n        }\n    }\n\n    // Oscilate contrast\n    vec3 finalCol = mix(col, pow(col, vec3(1.8)), abs(sin(iTime*0.2)));\n    fragColor = vec4(finalCol,1.0);\n}","name":"Image","description":"","type":"image"}]}