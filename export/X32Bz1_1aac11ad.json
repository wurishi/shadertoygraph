{"ver":"0.1","info":{"id":"X32Bz1","date":"1729203531","viewed":187,"name":"Pulsating Waves","username":"nilberlin","description":"\"This shader now combines the traditional Japanese wave style with modern neon colors, resulting in a unique and captivating visual effect.\"","likes":7,"published":3,"flags":0,"usePreview":0,"tags":["neonpulsating"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Verbesserter Audio-Reaktiver Neon-Japanischer Wellen-Shader mit dynamischeren Wellen\n#define PI 3.14159265359\n\nvec3 neonColors[7] = vec3[7](\n    vec3(1.0, 0.2, 0.6),    // Neon Pink\n    vec3(0.0, 1.0, 0.0),    // Neon Grün\n    vec3(1.0, 1.0, 0.0),    // Neon Gelb\n    vec3(1.0, 0.3, 0.0),    // Neon Orange\n    vec3(0.0, 0.4, 1.0),    // Neon Blau\n    vec3(0.8, 0.0, 1.0),    // Neon Lila\n    vec3(1.0, 0.0, 0.2)     // Neon Rot\n);\n\nvec3 mixNeonColors(float t) {\n    float scaledT = t * float(neonColors.length());\n    int index = int(floor(scaledT));\n    float fraction = fract(scaledT);\n    vec3 color1 = neonColors[index % neonColors.length()];\n    vec3 color2 = neonColors[(index + 1) % neonColors.length()];\n    return mix(color1, color2, fraction);\n}\n\nfloat dynamicJapaneseWave(vec2 uv, float time, float beatIntensity) {\n    // Dynamische Parameter\n    float waveSpeed = 1.5 + sin(time * 0.3) * 0.5; // Geschwindigkeit variiert über die Zeit\n    float waveAmplitude = 0.5 + sin(time * 0.5) * 0.3; // Amplitude variiert\n    float waveFrequency = 3.0 + sin(time * 0.2) * 1.0; // Frequenz variiert\n    float waveHeightOffset = sin(time * 0.1) * 0.3; // Wellenhöhe variiert\n\n    float mainWave = sin(uv.x * waveFrequency - time * waveSpeed) * exp(-time * 0.02) * waveAmplitude;\n    float smallWaves = sin(uv.x * (30.0 + sin(time * 0.4) * 10.0) - time * (4.0 + sin(time * 0.3))) * 0.05 * (1.0 - exp(-time * 0.2));\n    float curve = sin(uv.x * PI + time * 0.2) * 0.2;\n    float wave = mainWave + smallWaves + curve + waveHeightOffset;\n    wave += exp(-time * 0.2) * sin(time * 2.0) * 0.2;\n    return wave * (1.0 + beatIntensity * 0.5);\n}\n\nfloat detectBeat(float time) {\n    float beatTime = 0.1;\n    float intensity = 0.0;\n    for (float t = 0.0; t < beatTime; t += 0.01) {\n        float audioSample = texture(iChannel0, vec2(t, 0.25)).x;\n        intensity += audioSample;\n    }\n    return smoothstep(0.0, 0.5, intensity / beatTime);\n}\n\n// Funktion für ein Gittermuster\nfloat gridPattern(vec2 uv, float scale) {\n    vec2 grid = abs(fract(uv * scale - 0.5) - 0.5) / fwidth(uv * scale);\n    float line = min(grid.x, grid.y);\n    return 1.0 - smoothstep(0.0, 1.0, line);\n}\n\n// Funktion für radiale Verzerrung\nvec2 radialDistortion(vec2 uv, float strength) {\n    float radius = length(uv);\n    float angle = atan(uv.y, uv.x);\n    radius = pow(radius, 1.0 + strength * sin(iTime));\n    return vec2(cos(angle), sin(angle)) * radius;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Anwendung der radialen Verzerrung\n    uv = radialDistortion(uv, 0.1);\n\n    float beatIntensity = detectBeat(iTime);\n    float time = iTime * (1.5 + beatIntensity); // Erhöhte Basisgeschwindigkeit\n\n    float waveHeight = dynamicJapaneseWave(uv, time, beatIntensity);\n    float waveIntensity = smoothstep(-0.2, 1.0, waveHeight);\n\n    float colorIndex = (uv.x + waveHeight + time * 0.2) * 0.3; // Schnellerer Farbwechsel\n    vec3 color = mixNeonColors(fract(colorIndex));\n\n    color = pow(color, vec3(0.8));\n    color *= 1.5 + beatIntensity * 0.7; // Verstärkte Reaktion auf den Beat\n\n    float glow = 0.1 / (abs(uv.y - waveHeight * 0.5) + 0.02);\n    color += glow * mixNeonColors(fract(colorIndex + 0.5)) * (2.0 + beatIntensity * 1.5);\n\n    // Hinzufügen des Gittermusters zum Hintergrund\n    float grid = gridPattern(uv, 20.0 + beatIntensity * 10.0);\n    vec3 gridColor = mix(vec3(0.0), vec3(0.2), grid);\n\n    vec3 bgColor = vec3(0.05, 0.05, 0.05) + gridColor;\n\n    color = mix(bgColor, color, waveIntensity);\n\n    // Hinzufügen von chromatischer Aberration\n    float chroma = 0.005;\n    vec3 chromaColor;\n    chromaColor.r = texture(iChannel0, fragCoord / iResolution.xy + vec2(chroma, 0.0)).r;\n    chromaColor.g = texture(iChannel0, fragCoord / iResolution.xy).g;\n    chromaColor.b = texture(iChannel0, fragCoord / iResolution.xy - vec2(chroma, 0.0)).b;\n    color = mix(color, chromaColor, 0.5);\n\n    color = pow(color, vec3(0.9));\n    color = clamp(color * (1.2 + beatIntensity * 0.5), 0.0, 1.0);\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}