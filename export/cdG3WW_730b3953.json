{"ver":"0.1","info":{"id":"cdG3WW","date":"1678482301","viewed":231,"name":"HXP CTF 2022","username":"sisu","description":"high aesthetics","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["aesthetics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// HXP CTF 2022\n//\n\n\nfloat ball(vec2 p, float fx, float fy, float ax, float ay) {\n        vec2 r = vec2(p.x + fx * ax, p.y + fy * ay);\n        return 0.09 / length(r);\n}\n\nfloat blob(vec2 p) {\n        float col = 0.0;\n        col += ball(p - vec2(.4), 2.0, 2.0, 0.1, 0.5);\n        col += ball(p - vec2(.8), 1.5, 2.5, 0.2, 0.3);\n        col += ball(p - vec2(.2), 1.5, 0.5, 0.6, 0.7);\n        col += ball(p - vec2(.1, .8), 0.1, .5, 0.6, 0.7);\n        col = step(.69, col);\n        return col;\n}\n\nvec2 rotate(vec2 v, float a) {\n        float s = sin(a);\n        float c = cos(a);\n        mat2 m = mat2(c, -s, s, c);\n        return m * v;\n}\n\nfloat flag(vec2 p) {\n        p.x -= .55;\n        p.y -= .2;\n        p = rotate(p, .1);\n        p.y = p.y + sin(p.x * 30.) * .01;\n        float x = step(.1, p.x) * (1. - step(.4, p.x));\n        float y = step(.1, p.y) * (1. - step(.3, p.y));\n\n        float xs = step(.1, p.x) * (1. - step(.12, p.x));\n        float ys = step(.1, p.y) * (1. - step(.48, p.y));\n\n        return clamp(x * y + (xs * ys), .0, 1.0);\n}\n\nfloat hxp(vec2 p) {\n        vec2 porig = p;\n\n        // h\n        p = porig - vec2(.08, .45);\n        float x1 = step(.1, p.x) * (1. - step(.14, p.x));\n        float y1 = step(.1, p.y) * (1. - step(.32, p.y));\n        float x2 = step(.2, p.x) * (1. - step(.24, p.x));\n        float x3 = step(.14, p.x) * (1. - step(.20, p.x));\n        float y3 = step(.18, p.y) * (1. - step(.22, p.y));\n        float h = max(max(x1 * y1, y1 * x2), x3 * y3);\n\n        vec2 p1 = porig - vec2(.4);\n        p1 = rotate(p1, .45);\n        x1 = step(.1, p1.x) * (1. - step(.14, p1.x));\n        y1 = step(.1, p1.y) * (1. - step(.35, p1.y));\n\n        vec2 p2 = porig - vec2(.2, .51);\n        p2 = rotate(p2, -.45);\n        x2 = step(.1, p2.x) * (1. - step(.14, p2.x));\n        float y2 = step(.1, p2.y) * (1. - step(.35, p2.y));\n        float x = max(x1 * y1, x2 * y2);\n\n        float l = .0;\n        vec2 p3 = porig - vec2(.5, .55);\n        float d = length(p3 - vec2(.08, .07));\n        float r = (1. - step(.07, d)) - (1. - step(.035, d));\n        x1 = step(.0, p3.x) * (1. - step(.035, p3.x));\n        y1 = step(.0, p3.y) * (1. - step(.22, p3.y));\n        l = max(r, x1 * y1);\n\n        return max(max(h, x), l);\n}\n\nfloat block(vec2 p) {\n        float x1 = step(.0, p.x) * (1. - step(.55, p.x));\n        float y1 = step(.0, p.y) * (1. - step(.35, p.y));\n        return x1 * y1;\n}\n\nvec3 calcColor(vec2 p) {\n        float off = .2;\n\n        float b = blob(p * 2. - vec2(1.));\n        float f = flag(p - vec2(.0, -.2));\n        float h = hxp(p - vec2(.07, -.05));\n        float bl = block(p - vec2(.2, .42));\n\n        p = vec2(p.x, p.y);\n        vec2 rep = mod(p, vec2(off));\n        vec2 q = step(off * .5, rep);\n        float cbase = uintBitsToFloat(floatBitsToUint(q.x) ^ floatBitsToUint(q.y));\n\n        float m1 = pow(1. - smoothstep(.0, off * .3, mod(p.x, off * .5)), 5.0);\n        vec3 c1 = m1 * (1. - cbase) * vec3(.9,.2,.0);\n\n        float m2 = pow(1. - smoothstep(.0, off * .5, mod(p.x - off, off * .5)), 4.0);\n        vec3 c2 = m2 * (1. - cbase) * vec3(.0,.1,.9);\n\n        vec3 back = vec3(cbase) + c1 + c2;\n        vec3 objects = b * vec3(p.x, p.y, sin(p.x * p.y * 1000.));\n        back = mix(back, objects, b);\n        vec3 g = mix(vec3(222. / 255., 55. / 255., 60. / 255.), vec3(.8,.2,.5), 1. - pow(smoothstep(0.0, .4, p.y), 2.));\n        back = mix(back, g, f);\n\n        vec3 hb = mix(vec3(0. / 255., 153. / 255., 218. / 255.), vec3(0.0 / 255.0, 121.0 / 255.0, 250.0 / 255.0), 1. - pow(smoothstep(.4, .9, p.y), 8.));\n        vec3 hhh = mix(hb, vec3(.2, .2, .8), 1.-h);\n        back = mix(back, hhh, bl * .94);\n\n        return back;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n        // Normalized pixel coordinates (from 0 to 1)\n        vec2 q = fragCoord/iResolution.xy;\n        q = vec2(q.x, 1. - q.y);\n\n        // Time varying pixel color\n        vec4 color = vec4(calcColor(q), 1.);\n\n        // Output to screen\n        fragColor = color;\n}","name":"Image","description":"","type":"image"}]}