{"ver":"0.1","info":{"id":"wdsGDH","date":"1546139672","viewed":225,"name":"ABS Logo","username":"Garm","description":"Arctic Beard Studio's animated logo\ncheck us out at https://www.facebook.com/ArcticBeardStudio","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["logo","animated"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// CONSTANTS //\nconst vec3 colPrim = vec3(0.0, 0.168627450980392, 0.211764705882353);\nconst vec3 colSec = vec3(0.933333333333333, 0.909803921568627, 0.835294117647059);\n\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\n// Perlin simplex noise\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n\t\t\t\t\t -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n//  i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n//  i1.y = 1.0 - i1.x;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n\n// SDF //\nfloat circle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat triangle(vec2 p, float h) {\n    return max(abs(p.x)*0.866025+p.y*0.5,-p.y)-h*0.5;\n}\n\nvec2 translate(vec2 p, vec2 d) {\n    return p - d;\n}\n\nvec2 scale(vec2 p, vec2 s) {\n    return p / s;\n}\n\nfloat crater(vec2 p, float r) {\n    return max(-circle(p+vec2(1.0, -1.0)*(r*.2), r), circle(p, r));\n}\n\n\n// MOON //\nfloat waves(vec2 uv) {\n    vec2 pan = iTime * vec2(0.001, -0.01);\n    pan.x += uv.x * 0.02;\n    pan.y += uv.y * uv.y * 3.0;\n    pan.y *= .8;\n    \n    float mask = clamp(-1.0*(uv.y - 0.55), 0.0, 1.0);\n    mask = sign(mask);\n    \n    float result = snoise(pan * 30.0);\n    result *= 0.1;\n    result *= mask;\n    return result;\n}\n\nfloat moon(vec2 p) {\n    vec2 t = (p - 0.5) * 2.0;\n    t.y += -0.333;\n    t.x += waves(p);\n    \n    vec2 w = p;\n    w.x = 0.0;\n    w.y -= 0.55;\n    w.y = clamp((-1.0*w.y)*1.4, 0.0, 1.0);\n    \n    float result = circle(t + w, 0.5);\n    result = max(-crater(t + vec2(0.2, -0.2), 0.14), result);\n    result = max(-crater(t + vec2(-0.2, -0.15), 0.1), result);\n    return result;\n}\n\n// ICEBERG //\nfloat spike(vec2 p, float b, float h) {\n    p.x /= b;\n   \tp.y -= h*0.5;\n    p.y /= h;\n    return triangle(p, 1.0);\n}\n\nfloat iceberg(vec2 p) {\n    vec2 t = p - vec2(0.5, 0.55);\n    t = scale(t, vec2(1.5, 1.0));\n    float result = spike(t + vec2(0.08, 0.0), .02, .05);\n    result = min(result, spike(t + vec2(-0.08, 0.0), .02, .055));\n    result = min(result, spike(t + vec2(0.05, 0.0), .05, .075));\n    result = min(result, spike(t + vec2(-0.05, 0.0), .05, .07));\n    result = min(result, spike(t + vec2(0.02, 0.0), .05, .1));\n    result = min(result, spike(t + vec2(-0.015, 0.0), .05, .095));\n    \n    t = scale(t, vec2(1.0, -2.0));\n    t = translate(t, vec2(0.0, -0.001));\n    result = min(result, spike(t + vec2(0.08, 0.0), .02, .04));\n    result = min(result, spike(t + vec2(-0.08, 0.0), .02, .055));\n    result = min(result, spike(t + vec2(0.055, 0.0), .04, .07));\n    result = min(result, spike(t + vec2(-0.05, 0.0), .04, .075));\n    result = min(result, spike(t + vec2(0.025, 0.0), .04, .085));\n    result = min(result, spike(t + vec2(-0.025, 0.0), .04, .095));\n    result = min(result, spike(t + vec2(0.0, 0.0), .04, 0.12));\n    return result;\n}\n\n\n// MAIN //\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Normalized pixel coordinates (from 0 to 1)\n    // and compensate with aspect ratio to maintain square 0 to 1\n    float aspectRatio = iResolution.y / iResolution.x;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x -= (1.0-aspectRatio)*0.5;\n    uv.x /= aspectRatio;\n    \n    float logo = max(-iceberg(uv), moon(uv));\n    // estimated aa solution\n    logo = clamp(0.5 - logo * iResolution.y, 0.0, 1.0);\n    \n    vec4 c;\n    c.rgb = mix(colPrim, colSec, logo);\n    c.a = 1.0;\n\n    // Output to screen\n    fragColor = c;\n}","name":"Image","description":"","type":"image"}]}