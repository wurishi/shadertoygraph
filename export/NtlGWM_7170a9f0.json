{"ver":"0.1","info":{"id":"NtlGWM","date":"1622282974","viewed":136,"name":"- EXP - draw antialiased line ","username":"yuempek","description":"drawing the line with anti antialiasing.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["line","antialiasing","weightedline"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    author: https://github.com/yuempek\n*/\n\n#define PI   3.1415926535\n#define PI_2 1.5707963267\n\n//float distToLine(float x, float y, float a, float b, float c){\n//    //https://brilliant.org/wiki/dot-product-distance-between-point-and-a-line/#:~:text=The%20distance%20between%20a%20point,and%20passes%20through%20the%20point.\n//    //distance(point) = a(x0)+b(y0)+c / sqrt(a*a + b*b)\n//    return abs(a*x + b*y + c) / sqrt(a*a+b*b);\n//}\n\nfloat sumPositives(float a, float b, float c, float d){\n    float sump = 0.0;\n    if (a >= 0.0) sump += a;\n    if (b >= 0.0) sump += b;\n    if (c >= 0.0) sump += c;\n    if (d >= 0.0) sump += d;\n    \n    return sump;\n}\n\nfloat sumNegatives(float a, float b, float c, float d){\n    float sump = 0.0;\n    if (a < 0.0) sump += a;\n    if (b < 0.0) sump += b;\n    if (c < 0.0) sump += c;\n    if (d < 0.0) sump += d;\n    \n    return sump;\n}\n\nint countPositives(float a, float b, float c, float d){\n    int cnt = 0;\n    if (a >= 0.0) cnt++;\n    if (b >= 0.0) cnt++;\n    if (c >= 0.0) cnt++;\n    if (d >= 0.0) cnt++;\n    \n    return cnt;\n}\n\nfloat maxest(float a, float b, float c, float d){\n    return max(a,max(b,max(c,d)));\n}\n\nfloat minest(float a, float b, float c, float d){\n    return min(a,min(b,min(c,d)));\n}\n\nvec3 pixelcolor(vec2 unit, vec2 uvLT, vec2 uvRT, vec2 uvLB, vec2 uvRB, float w){\n    int cnt;\n  \n    float D   = 0.0;\n    float DLT = 0.0;\n    float DRT = 0.0;\n    float DLB = 0.0;\n    float DRB = 0.0;\n    \n    DLT = dot(unit, uvLT - unit * w);\n    DRT = dot(unit, uvRT - unit * w);\n    DLB = dot(unit, uvLB - unit * w);\n    DRB = dot(unit, uvRB - unit * w);\n\n    cnt = countPositives(DLT, DRT, DLB, DRB);\n    if (cnt == 4) return vec3(0.0);\n\n    if (cnt > 0) {\n        float k; \n\n        if (cnt == 2) \n            k = (-sumPositives(DLT, DRT, DLB, DRB)/sumNegatives(DLT, DRT, DLB, DRB)); \n        else // if (cnt == 1) or if (cnt == 3) \n            k = (-maxest(DLT, DRT, DLB, DRB)/minest(DLT, DRT, DLB, DRB));\n\n        return vec3(1.0 - k/(k+1.0));\n    }\n    \n    return vec3(1.0);\n}\n    \nvec3 drawLine(vec2 center, float angle, vec2 pixel, float weight, float len){\n    \n    if(distance(center, pixel) > len) return vec3(0);\n    \n    vec2 unit = vec2(cos(angle + PI_2), sin(angle + PI_2));\n    \n    float w = weight;\n    \n    //normilized half weight\n    w = (w / 2.0) / iResolution.x;\n    \n    vec2 aspect = 1.0/iResolution.xx;\n    \n    // find pixel center and corners\n    vec2 uv   = (-center + pixel + vec2(0.5, 0.5)) * aspect;\n    vec2 uvLT = (-center + pixel + vec2(0.0, 0.0)) * aspect;\n    vec2 uvRT = (-center + pixel + vec2(1.0, 0.0)) * aspect;\n    vec2 uvLB = (-center + pixel + vec2(0.0, 1.0)) * aspect;\n    vec2 uvRB = (-center + pixel + vec2(1.0, 1.0)) * aspect;\n    \n    //DLT = distToLine(uvLT.x, uvLT.y, -m, 1.0, 0.0);\n    //DRT = distToLine(uvRT.x, uvRT.y, -m, 1.0, 0.0);\n    //DLB = distToLine(uvLB.x, uvLB.y, -m, 1.0, 0.0);\n    //DRB = distToLine(uvRB.x, uvRB.y, -m, 1.0, 0.0);\n    \n    vec3 col = pixelcolor(unit, uvLT, uvRT, uvLB, uvRB, w);\n    col = min(col, pixelcolor(-unit, uvLT, uvRT, uvLB, uvRB, w));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vars\n    float angle;\n    vec3 col = vec3(0.0);\n\n    //params\n    const int n = 3;\n    float weight = 4.0;\n    float len = 100.0;\n    \n    vec2 pixel = fragCoord.xy;\n    \n    const int linecount = 3;\n    \n    //draw\n    for(float phase = 0.0; phase < float(linecount); phase++){\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                angle = -iTime*1.0 + phase*PI/float(linecount);\n                col = max(col, drawLine(iResolution.xy*vec2(float(i+1), float(j+1))/float(n+1), angle, pixel, weight, len));\n            }\n        }\n    }\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}