{"ver":"0.1","info":{"id":"cdB3Rc","date":"1667922364","viewed":46,"name":"Modular Group PSL(2, Z) Tiling","username":"somenobody","description":"Fundamental domain and the tiling corresponding to the modular group PSL(2, R) acting on the hyperbolic plane, visualized in the Poincare Disk model","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["hyperbolic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Helpers and structure borrowed from https://www.shadertoy.com/view/ssG3DK\n\n#define M_PI 3.1415926535897932384626433832795\n\nstruct mat2i {\n    int a, b, c, d;\n};\n\nmat2i mul(mat2i m, mat2i n) {\n    return mat2i(\n        m.a * n.a + m.b * n.c\n        , m.a * n.b + m.b * n.d\n        , m.c * n.a + m.d * n.c\n        , m.c * n.b + m.d * n.d);\n}\n\nvec2 normalizedFragCoord(vec2 fragCoord) {\n    // Normalized the pixel coordinates (from -0.5 to 0.5)\n    vec2 uv =((fragCoord - vec2(0.5f)) / iResolution.xy - vec2(0.5));\n    \n    float a = iResolution.y / iResolution.x;\n    uv = 4.0 * vec2(1, a) * uv; // [-1, +1]x[-a, a]\n    \n    return uv;\n}\n\nvec2 complexDiv(vec2 num, vec2 denom) {\n    float a = num.x, b = num.y, c = denom.x, d = denom.y;\n    return vec2(a*c + b*d, b*c - a*d) / (c*c + d*d);\n}\n\nvec2 complexMul(vec2 z, vec2 w) {\n    float a = z.x, b = z.y, c = w.x, d = w.y;\n    return vec2(a * c - b * d, b * c + a * d);\n}\n\nvec2 poincareToUHP(vec2 z) {\n    vec2 i = vec2(0.0f, 1.0f);\n    vec2 one = vec2(1.0f, 0.0f);\n    float a = z.x, b = z.y;\n    \n    // return complexDiv(z + i, complexMul(i, z) + one);\n    float D = pow(1.0f - b, 2.0f) + a*a;\n    return vec2(2.0f * (a / D), a / D * a + b / D * b - 1.0f / D);\n}\n\nvec2 uhpToPoincare(vec2 w) {\n    vec2 i = vec2(0.0f, 1.0f);\n    vec2 one = vec2(1.0f, 0.0f);\n    \n    return complexDiv(w - i, complexMul(-i, w) + one);\n}\n\nvec3 poincareToLorentz(vec2 y) {\n    float yy = dot(y, y);\n    vec3 x = vec3((1.0 + yy) / (1.0 - yy), 2.0 * y.x / (1.0 - yy), 2.0 * y.y / (1.0 - yy));\n    return x;\n}\n\nvec3 uhpToLorentz(vec2 uhp) {\n    float a = uhp.x;\n    float b = uhp.y;\n    \n    float z = (-a*a - b*b - 1.0f)/(2.0f*b);\n    float x = -a/b;\n    float y = (a*a + b*b - 1.0f)/(2.0f*b);\n    return vec3(z, x, y);\n}\n\nvec2 uhpApplyPSL2(vec2 z, int A, int B, int C, int D) {\n    float a = float(A);\n    float b = float(B);\n    float c = float(C);\n    float d = float(D);\n    \n    vec2 i = vec2(0.0f, 1.0f);\n    vec2 one = vec2(1.0f, 0.0f);\n    \n    return complexDiv(a * z + one * b, c * z + d * one); \n}\n\nbool isInLTilingFunDom(vec3 lorentz) {\n    float x1 = lorentz.x;\n    float x2 = lorentz.y;\n    float x3 = lorentz.z;\n    \n    return max(2.0 * x2*x2 - x3*x3, 2.0*x3*x3 - x2*x2) < 1.0;\n}\n\nbool isInModularFunDom(vec2 uhp) {\n    return length(uhp) >= 1.0f && abs(uhp.x) <= 0.5f;\n}\n\nvec3 supNormalize(vec3 p) {\n    float m = max(max(p.x, p.y), p.z);\n    return p / m;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = normalizedFragCoord(fragCoord);\n    \n    const int MODEL_DISK = 1; /* Poincare Disk */\n    const int MODEL_UHP = 2; /* Poincare Upper Half-Plane */\n    const int MODEL_SPLIT_VIEW = 3; /* Half screen displays Disk model, half shows UHP */\n    \n    int model = MODEL_DISK;\n    // model = MODEL_UHP;\n    model = MODEL_SPLIT_VIEW;\n    \n    \n    const vec4 BLACK = vec4(0.0, 0.0, 0.0, 1.0);\n    const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);\n    const vec4 YELLOW = vec4(1.0, 1.0, 0.0, 1.0);\n    \n    \n    const int N_PHASES = 4;\n    const float PHASE_LENGTH = 2.0f; // Seconds\n    if (model == MODEL_SPLIT_VIEW) {\n        \n        float phases = iTime / PHASE_LENGTH;\n        \n        \n        float fPhase = mod(phases , float(N_PHASES));\n        int phase = int(fPhase);\n        \n        float angle = -1.0f * M_PI + 4.0f * M_PI * mod(fPhase - 1.0f + float(N_PHASES), 2.0f) / 2.0f;\n        \n        bool left = atan(uv.y, uv.x) > angle;\n        \n        \n        if (phase == 0) {\n            model = MODEL_DISK;\n        } else if (phase == 1) {\n            model = left ? MODEL_DISK : MODEL_UHP;\n        } else if (phase == 2) {\n            model = MODEL_UHP;\n        } else if (phase == 3) {\n            model = left ? MODEL_UHP : MODEL_DISK;\n        } else {\n            fragColor = YELLOW;\n            return;\n        }\n    }\n    \n    vec2 poincare, uhp;\n    vec3 lorentz;\n    \n    if (model == MODEL_DISK) {\n        poincare = uv;\n        lorentz = poincareToLorentz(poincare);\n        uhp = poincareToUHP(poincare);\n    } else if (model == MODEL_UHP) {\n        uhp = uv + vec2(0.0f, 1.25f); // uv * vec2(0.75f, 0.5f) * 4.0f;\n        poincare = uhpToPoincare(uhp);\n        lorentz = poincareToLorentz(poincare);\n        lorentz = uhpToLorentz(uhp);\n    } else {\n        fragColor = RED;\n        return;\n    }\n    \n        \n    bool outOfBounds = false;\n    outOfBounds = outOfBounds || ((model == MODEL_DISK) && (length(poincare) >= 1.0));\n    outOfBounds = outOfBounds || ((model == MODEL_UHP) && (uhp.y < 0.0f));\n    \n    if (outOfBounds) {\n        fragColor = BLACK;\n        return;\n    }\n    \n    mat2i S = mat2i(0, -1, 1, 0);\n    mat2i T = mat2i(1, +1, 0, 1);\n    mat2i ST = mul(S, T);\n    \n    mat2i gg[] = mat2i[] (\n        mat2i(1, 0, 0, 1)\n        , S\n        , T\n        , ST\n        , mul(T, T)\n        , mul(mul(T, T), T)\n        , mul(T, ST)\n        , mul(ST, ST)\n    );\n    \n        \n    vec3 col = vec3(.0, 2.0, 5.0);\n    float minIntensity = 0.0f;\n    \n    for (int i = 0; i < gg.length(); ++i) {\n        mat2i g = gg[i];\n        vec2 uhpPreim = uhpApplyPSL2(uhp, g.a, g.b, g.c, g.d);\n\n        if (isInModularFunDom(uhpPreim)) {\n            col = vec3(5 + i, 2 + i, 5 + i);\n            minIntensity += .5;\n        }\n    }\n    \n    \n    // float r = length(poincare);\n    // float r2 = dot(poincare, poincare);\n    float r = length(vec2(lorentz.y, lorentz.z)) / abs(1.0f + lorentz.x);\n    float r2 = r * r;\n    float d = acosh((1.0 + r2) / (1.0 - r2)); // distance to 0\n    \n    \n    vec3 n = normalize(vec3(-lorentz.x, lorentz.y, lorentz.z));\n    vec3 eye = normalize(lorentz - vec3(-1.0, 0, 0));\n    float cosangle = dot(n, eye);\n    \n    col = minIntensity + .5 * (1.0f\n        + cos(col +  2.0f * M_PI * iTime / PHASE_LENGTH / float(N_PHASES)));\n    // col = col  / (1.0 + d);\n    // col = col  * max(.25, abs(cosangle));\n    col = col * exp(-.05 * lorentz.x);\n    \n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}