{"ver":"0.1","info":{"id":"fdycDy","date":"1655461954","viewed":240,"name":"Layered terrain II","username":"gleboneloner","description":"layered terrain","likes":18,"published":1,"flags":32,"usePreview":0,"tags":["terrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage ( out vec4 color, in vec2 coords ) {\n\n    float IX = coords.x, IY = coords.y;\n    \n    #define TEX(u,v) texelFetch( iChannel0, ivec2(u,v), 0 )\n    \n    float H1 = TEX( IX, IY ).x;\n    \n    float k1 = TEX( IX - 1.0, IY - 1.0 ).y;\n    float k2 = TEX( IX - 1.0, IY + 1.0 ).y;\n    float k3 = TEX( IX + 1.0, IY - 1.0 ).y;\n    float k4 = TEX( IX + 1.0, IY + 1.0 ).y;\n    \n    float k5 = TEX( IX - 1.0, IY ).y;\n    float k6 = TEX( IX + 1.0, IY ).y;\n    float k7 = TEX( IX, IY - 1.0 ).y;\n    float k8 = TEX( IX, IY + 1.0 ).y;\n    \n    float G1 = (k3+k6+k6+k4)-(k1+k5+k5+k2);\n    float G2 = (k2+k8+k8+k4)-(k1+k7+k7+k3);\n    \n    float S1 = length(vec2(G1,G2));\n    \n    color.rgb = mix( map(H1), vec3(0), S1/2.0 );\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage ( out vec4 color, in vec2 coords ) {\n    \n    vec3 E1 = vec3( cos(iTime/2.0), sin(iTime/2.0), 1.2 )*3.0;\n    \n    vec3 I1 = normalize(vec3(0)-E1);\n    vec3 I2 = normalize(cross(I1,vec3(0,0,1)));\n    vec3 I3 = normalize(cross(I2,I1));\n    \n    E1.x += iTime*2.0;\n    \n    vec2 uv = (coords-iResolution.xy/2.0)/iResolution.y;\n    \n    vec3 D1 = normalize( I1 + I2*uv.x + I3*uv.y );\n    \n    vec3 M1 = E1+D1*(((1.0)-E1.z)/D1.z);\n    vec3 M2 = E1+D1*(((0.0)-E1.z)/D1.z);\n    \n    color = vec4(0);\n    \n    for ( float n = 0.0; n <= 1.0; n += 0.01 ) {\n    \n        vec3 M3 = mix(M1,M2,n);\n        \n        float s = texture( iChannel0, M3.xy/10.0 ).x;\n        \n        if ( M3.z < s ) {\n            color.x = M3.z;\n            color.y = distance(M3,E1);\n            return;\n        }\n        \n    }\n    \n    color.xy = vec2( 0, distance(E1,M2) );\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec3 map ( float x ) {\n    \n    const vec3 K1 = vec3( +1.349, -0.071, -0.541 );\n    const vec3 K2 = vec3( -0.439, +0.867, +0.812 );\n    const vec3 K3 = vec3( +0.086, +0.180, +0.220 );\n    \n    return x*(K1*x+K2)+K3;\n    \n}","name":"Common","description":"","type":"common"}]}