{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// Finding intersection points between two quadratic Bézier curves means solving a polynomial of degree 4.\n// The quartic solver is taken from @oneshade: https://www.shadertoy.com/view/fsB3Wt\n// The implicitization of quadratics is borrowed from one of kurbo's examples: https://github.com/linebender/kurbo/blob/main/examples/quad_intersect.rs\n//\n// For better numerical stability, I'd personally work with monotonic quadratics and find the intersections between those.\n// Of course turning them to lines, when appropiate, can also help.\n\n#define PI 3.141592653589\n\nvoid make_quadratic_implicit(in vec2 A, in vec2 B, in vec2 C, out vec4 xy, out vec2 c) {\n    vec3 u = vec3(B.y - C.y, C.x - B.x, B.x * C.y - B.y * C.x);\n    vec3 v = vec3(C.y - A.y, A.x - C.x, C.x * A.y - C.y * A.x);\n    vec3 w = vec3(A.y - B.y, B.x - A.x, A.x * B.y - A.y * B.x);\n    \n    xy.x = 4.0 * (u.x * w.z + u.z * w.x) - 2.0 * v.x * v.z; // x\n    xy.y = 4.0 * (u.y * w.z + u.z * w.y) - 2.0 * v.y * v.z; // y\n    xy.z = 4.0 * u.x * w.x - v.x * v.x; // x2\n    xy.w = 4.0 * u.y * w.y - v.y * v.y; // y2\n    c.x = 4.0 * (u.x * w.y + u.y * w.x) - 2.0 * v.x * v.y; // xy\n    c.y = 4.0 * u.z * w.z - v.z * v.z; // c\n}\n\nfloat eval_implicit_quadratic(in vec2 p, in vec4 xy, in vec2 c) {\n    return xy.z * p.x * p.x + c.x * p.x * p.y + xy.w * p.y * p.y + xy.x * p.x + xy.y * p.y + c.y;\n}\n\nvec4 intersect_quadratics(in vec2 A0, in vec2 B0, in vec2 C0, in vec2 A1, in vec2 B1, in vec2 C1) {\n    vec4 iq_xy = vec4(0.0);\n    vec2 iq_c = vec2(0.0);    \n    make_quadratic_implicit(A0, B0, C0, iq_xy, iq_c);\n\n    vec2 c = A1;\n    vec2 b = 2.0 * (B1 - A1);\n    vec2 a = c - 2.0 * B1 + C1;\n    float c0 = eval_implicit_quadratic(c, iq_xy, iq_c);\n    float c1 = iq_xy.x * b.x\n             + iq_xy.y * b.y \n             + 2.0 * iq_xy.z * (b.x * c.x)\n             + 2.0 * iq_xy.w * (b.y * c.y)\n             + iq_c.x * (b.x * c.y + b.y * c.x);\n    float c2 = iq_xy.x * a.x\n             + iq_xy.y * a.y\n             + iq_xy.z * (2.0 * a.x * c.x + b.x * b.x)\n             + iq_c.x * (a.x * c.y + b.x * b.y + a.y * c.x)\n             + iq_xy.w * (2.0 * a.y * c.y + b.y * b.y);\n    float c3 = iq_xy.z * 2.0 * a.x * b.x + iq_c.x * (a.x * b.y + b.x * a.y) + iq_xy.w * 2.0 * a.y * b.y;\n    float c4 = iq_xy.z * a.x * a.x + iq_c.x * a.x * a.y + iq_xy.w * a.y * a.y;\n\n    vec4 roots = vec4(-1.0);\n    int n = solve_quartic(c4, c3, c2, c1, c0, roots);\n    return roots;\n}\n\nvec2 rotate(in vec2 point, in vec2 pivot, in float rad) {\n    float cosine = cos(rad);\n    float sine = sin(rad);\n\n    point -= pivot;\n\n    vec2 rotated = vec2(\n        point.x * cosine - point.y * sine,\n        point.x * sine + point.y * cosine\n    );\n\n    return rotated + pivot;\n}\n\nvec4 expand(in vec2 A, in vec2 B, float factor) {\n    vec2 pivot = (A + B) * 0.5;\n    vec2 a = A - pivot;\n    vec2 b = B - pivot;\n\n    a *= factor;\n    b *= factor;\n\n    return vec4(a, b) + vec4(pivot, pivot);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float curve_stroke = min(iResolution.x, iResolution.y) / 200.0;\n\n    vec2 scale = iResolution.xy;\n    vec2 pivot = iResolution.xy / 2.0;\n\n    vec2 p0 = vec2(0.6, 0.3); vec2 p1 = vec2(0.05, 0.2); vec2 p2 = vec2(0.6, 0.1);\n    vec2 p3 = vec2(0.4, 0.05); vec2 p4 = vec2(0.5, 0.9); vec2 p5 = vec2(0.6, 0.05);\n\n    p0 *= scale; p1 *= scale; p2 *= scale;\n    p3 *= scale; p4 *= scale; p5 *= scale;\n    \n    p0 = rotate(p0, pivot, iTime); p1 = rotate(p1, pivot, iTime); p2 = rotate(p2, pivot, iTime);\n    p3 = rotate(p3, pivot, -iTime); p4 = rotate(p4, pivot, -iTime); p5 = rotate(p5, pivot, -iTime);\n    \n    float ef = (sin(iTime + PI / 2.0) + 2.0) * 0.5;\n    vec4 e0 = expand(p0, p2, ef);\n    vec4 e1 = expand(p3, p5, ef);\n\n    p0 = e0.xy; p2 = e0.zw;\n    p3 = e1.xy; p5 = e1.zw;\n    \n    vec3 ts0 = nearest_quadratic_points(fragCoord, p0, p1, p2);\n    vec3 ts1 = nearest_quadratic_points(fragCoord, p3, p4, p5);\n\n    bool inside_quadratic = false;\n    bool on_quadratic0 = false;\n    bool on_quadratic1 = false;\n\n    for (int i = 0; i < 3; ++i) {\n        if (ts0[i] >= 0.0 && ts0[i] <= 1.0) {\n            vec2 q = eval_quadratic_at(p0, p1, p2, ts0[i]);\n            float d = distance(fragCoord, q);\n\n            on_quadratic0 = on_quadratic0 || (d <= curve_stroke);\n            inside_quadratic = inside_quadratic || on_quadratic0;\n        }\n        if (ts1[i] >= 0.0 && ts1[i] <= 1.0) {\n            vec2 q = eval_quadratic_at(p3, p4, p5, ts1[i]);\n            float d = distance(fragCoord, q);\n\n            on_quadratic1 = on_quadratic1 || (d <= curve_stroke);\n            inside_quadratic = inside_quadratic || on_quadratic1;\n        }\n    }\n\n    vec4 ts = intersect_quadratics(p0, p1, p2, p3, p4, p5);\n\n    vec2 pts[4];\n    for (int n = 0; n < 4; ++n) {\n        if (ts[n] >= 0.0 && ts[n] <= 1.0) {\n            vec2 q1 = eval_quadratic_at(p3, p4, p5, ts[n]);\n            bool inside_intersection = on_quadratic0 && on_quadratic1;\n            pts[n] = inside_intersection ? q1 : vec2(-1000.0, -1000.0);\n        } else {\n            pts[n] = vec2(-1000.0, -1000.0);\n        }\n    }\n    \n    bool intersection = false;\n    for (int j = 0; j < 4; ++j) {\n        float d = distance(fragCoord, pts[j]);\n        intersection = intersection || (d <= curve_stroke * 2.0);\n    }\n\n    fragColor = intersection ? vec4(1.0, 0.0, 0.0, 1.0) : (inside_quadratic ? vec4(0.0, 0.0, 0.0, 1.0) : vec4(1.0));\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"float cbrt(in float x) {\n    return sign(x) * pow(abs(x), 1.0 / 3.0);\n}\n\nint solve_quartic(in float a, in float b, in float c, in float d, in float e, inout vec4 roots) {\n    // Note: a might be zero. I'm not treating that case here because the examples are hardcoded, but normally it would need to resort to solving a cubic in that case.\n    b /= a; c /= a; d /= a; e /= a;\n\n    // Depress the quartic to x^4 + px^2 + qx + r by substituting x-b/4a\n    // This can be found by substituting x+u and the solving for the value\n    // of u that makes the t^3 term go away\n    float bb = b * b;\n    float p = (8.0 * c - 3.0 * bb) / 8.0;\n    float q = (8.0 * d - 4.0 * c * b + bb * b) / 8.0;\n    float r = (256.0 * e - 64.0 * d * b + 16.0 * c * bb - 3.0 * bb * bb) / 256.0;\n    int n = 0; // Root counter\n\n    // Solve for a root to (t^2)^3 + 2p(t^2)^2 + (p^2 - 4r)(t^2) - q^2 which resolves the\n    // system of equations relating the product of two quadratics to the depressed quartic\n    float ra =  2.0 * p;\n    float rb =  p * p - 4.0 * r;\n    float rc = -q * q;\n\n    // Depress using the method above\n    float ru = ra / 3.0;\n    float rp = rb - ra * ru;\n    float rq = rc - (rb - 2.0 * ra * ra / 9.0) * ru;\n\n    float lambda;\n    float rh = 0.25 * rq * rq + rp * rp * rp / 27.0;\n    if (rh > 0.0) { // Use Cardano's formula in the case of one real root\n        rh = sqrt(rh);\n        float ro = -0.5 * rq;\n        lambda = cbrt(ro - rh) + cbrt(ro + rh) - ru;\n    }\n\n    else { // Use complex arithmetic in the case of three real roots\n        float rm = sqrt(-rp / 3.0);\n        lambda = -2.0 * rm * sin(asin(1.5 * rq / (rp * rm)) / 3.0) - ru;\n    }\n\n    // Newton iteration to fix numerical problems (using Horners method)\n    // Suggested by @NinjaKoala\n    for(int i=0; i < 2; i++) {\n        float a_2 = ra + lambda;\n        float a_1 = rb + lambda * a_2;\n        float b_2 = a_2 + lambda;\n\n        float f = rc + lambda * a_1; // Evaluation of λ^3 + ra * λ^2 + rb * λ + rc\n        float f1 = a_1 + lambda * b_2; // Derivative\n\n        lambda -= f / f1; // Newton iteration step\n    }\n\n    // Solve two quadratics factored from the quartic using the cubic root\n    if (lambda < 0.0) return n;\n    float t = sqrt(lambda); // Because we solved for t^2 but want t\n    float alpha = 2.0 * q / t, beta = lambda + ra;\n\n    float u = 0.25 * b;\n    t *= 0.5;\n\n    float z = -alpha - beta;\n    if (z > 0.0) {\n        z = sqrt(z) * 0.5;\n        float h = +t - u;\n        roots.xy = vec2(h + z, h - z);\n        n += 2;\n    }\n\n    float w = +alpha - beta;\n    if (w > 0.0) {\n        w = sqrt(w) * 0.5;\n        float h = -t - u;\n        roots.zw = vec2(h + w, h - w);\n        if (n == 0) roots.xy = roots.zw;\n        n += 2;\n    }\n\n    return n;\n}\n\n// This is used for drawing the quadratics.\nfloat cos_acos_3(in float x) {\n    x = sqrt(0.5 + 0.5 * x);\n    return x * (x * (x * (x * -0.008972 + 0.039071) - 0.107074) + 0.576975) + 0.5;\n}\n\nvec3 one_root(in float h, in float p, in float q, in float kx) {\n    h = sqrt(h);\n    vec2 x = (vec2(h, -h) - q) / 2.0;\n\n    vec2 uv = sign(x) * pow(abs(x), vec2(1.0 / 3.0));\n    float t = uv.x + uv.y;\n\n    t -= (t * (t * t + 3.0 * p) + q) / (3.0 * t * t + 3.0 * p);\n    t = t - kx;\n\n    return vec3(clamp(t, 0.0, 1.0), -1.0, -1.0);\n}\n\nvec3 three_roots(in float p, in float q, in float kx) {\n    float z = sqrt(-p);\n    float m = cos_acos_3(q / (p * z * 2.0));\n    float n = sqrt(1.0 - m * m);\n\n    n *= sqrt(3.0);\n\n    return clamp(vec3(m + m, -n - m, n - m) * z - kx, vec3(0.0), vec3(1.0));\n}\n\n// Modified from Inigo Quilez's Bézier SDF.\nvec3 nearest_quadratic_points(in vec2 pos, in vec2 A, in vec2 B, in vec2 C) {\n    vec2 a = B - A;\n    vec2 b = A - 2.0 * B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b, b);\n    float kx = kk * dot(a, b);\n    float ky = kk * (2.0 * dot(a, a) + dot(d, b)) / 3.0;\n    float kz = kk * dot(d, a);\n\n    float p  = ky - kx * kx;\n    float q  = kx * (2.0 * kx * kx - 3.0 * ky) + kz;\n    float p3 = p * p * p;\n    float q2 = q * q;\n    float h  = q2 + 4.0 * p3;\n\n    return (h >= 0.0) ? one_root(h, p, q, kx) : three_roots(p, q, kx);\n}\n\nvec2 eval_quadratic_at(in vec2 p0, in vec2 p1, in vec2 p2, in float t) {\n    float mt = 1.0 - t;\n    float mt2 = mt * mt;\n    float t2 = t * t;\n    \n    return mt2 * p0 + 2.0 * mt * t * p1 + t2 * p2;\n}","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4XdcRM","date":"1734895564","viewed":106,"name":"Quadratic/Quadratic Intersect","username":"vg_head","description":"Showcasing how to compute intersection points between two quadratic Bézier curves, which reduces to solving a quartic equation.","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["math","bezier","solver","quartic","equation","polynomial"],"hasliked":0,"parentid":"fsB3Wt","parentname":"Quartic Equation Solver"}}