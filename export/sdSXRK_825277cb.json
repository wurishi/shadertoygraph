{"ver":"0.1","info":{"id":"sdSXRK","date":"1625029507","viewed":200,"name":"Perfect Border Voronoi","username":"RiceFields","description":"Voronoi","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["voronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ref: https://iquilezles.org/articles/voronoilines\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat aastep(float threshold, float value) {\n    float afwidth = 10.0f/iResolution.y; // pixel width for smoothstep edge \n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n}\n\n\nfloat fill(float f, float size) {\n    return 1.-aastep(size, f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.y;\n    \n    uv *= 10.0f;\n    \n    vec2 iuv = floor(uv);\n    vec2 fuv = fract(uv);\n    \n    // miniunm distance feature point\n    vec2 mNeighbour; // feature point cell\n    vec2 mDiff; // vector from current point to feature point\n    float mDist = 2.0f;\n    \n    // first find the least distant feature point\n    for(int j=-1; j<=1; ++j) {\n        for(int i=-1; i<=1; ++i) {\n            vec2 neighbour = vec2(float(i), float(j));\n            vec2 point = random2(iuv + neighbour);\n            // animate\n            point = 0.5f + 0.5f*sin(iTime + 6.2831f*point);\n            \n            vec2 diff = neighbour + point - fuv;\n                        \n            float dist = dot(diff, diff); // lenght^2\n            \n            if(dist < mDist) {\n                mDiff = diff;\n                mNeighbour = neighbour;\n                mDist = dist;\n            }\n        }\n    }\n    \n    mDist = 2.0f;\n    // second, neighbour search centered at cell contaiting least distant feature point\n    for(int j=-2; j<=2; ++j) { \n        for(int i=-2; i<=2; ++i) {\n            // 5x5\n            \n            vec2 neighbour = mNeighbour + vec2(float(i), float(j));\n            vec2 point = random2(iuv + neighbour);\n            // animate\n            point = 0.5f + 0.5f*sin(iTime + 6.2831f*point);\n            \n            vec2 diff = neighbour + point - fuv;\n            \n            float dist = dot(0.5f*(mDiff+diff), normalize(diff-mDiff)); // distance with projection\n    \n            mDist = min(mDist, dist);\n        }\n    }\n    \n    \n   vec3 col = vec3(fill(mDist, 0.02f)); \n\n   fragColor = vec4(1.0f - col,1.0);\n}","name":"Image","description":"","type":"image"}]}