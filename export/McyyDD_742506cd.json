{"ver":"0.1","info":{"id":"McyyDD","date":"1731874095","viewed":42,"name":"bunch of lines rotating","username":"ademdj12","description":"experimental shader","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["procedural"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 newColor = vec4(pointSpace(fragCoord+vec2(100.,0.)*iTime,iTime));\n    fragColor = newColor;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define QuadSize 20.\n\nvec2 rotate(vec2 center, vec2 p, float rot ){\n    float cos_a = p.x / distance(center,p);\n    float sin_a = p.y / distance(center,p);\n    \n    float cos_a_rot = cos_a*cos(rot) - sin_a*sin(rot);\n    float sin_a_rot = sin_a*cos(rot) + cos_a*sin(rot);\n    \n    return vec2(\n        cos_a_rot * distance(center,p) + center.x,\n        sin_a_rot * distance(center,p) + center.y\n    );\n\n}\n\nfloat line_segment(in vec2 p, in vec2 a, in vec2 b) {\n\tvec2 ba = b - a;\n\tvec2 pa = p - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n\treturn length(pa - h * ba);\n}\n\n\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract((vec3(p.xyx)) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\nfloat pointSpace(vec2 pos, float time){\n    vec2 ownerQuadPos = (floor(pos / QuadSize))* QuadSize;\n    vec2 owenerGlobalPointPos = ownerQuadPos + hash22(ownerQuadPos) * QuadSize;\n    \n    float minDistance = QuadSize * 3.;\n    vec2 closestPt = vec2(0);\n    for(int i = 0;i<9;i++){\n        if(i == 4) continue;\n        vec2 offsetCord = vec2( (i % 3) - 1 , floor(float(i)/3.) - 1. );\n        vec2 currentQuadPos = (offsetCord + floor(pos / QuadSize))* QuadSize;\n        vec2 globalPointPos = currentQuadPos + hash22(currentQuadPos) * QuadSize;\n        float d = distance(owenerGlobalPointPos,globalPointPos);\n        if(d < minDistance ){\n            minDistance = d;\n            closestPt = globalPointPos;\n        }\n    }\n    \n    closestPt = rotate(owenerGlobalPointPos, closestPt, time*(.5-hash12(owenerGlobalPointPos)));\n    \n    return line_segment(pos,closestPt,owenerGlobalPointPos) ;\n}","name":"Common","description":"","type":"common"}]}