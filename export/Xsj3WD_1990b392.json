{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define MAX_DEPTH 10\n\n#define MAT_BACKGROUND    0\n#define MAT_GREY_DIFFUSE  1\n#define MAT_CHROME        2\n#define MAT_WAVY_MIRROR   3\n\nint intersectionMaterial;\nfloat intersectionT;\nvec3 intersectionPoint;\nvec3 intersectionNormal;\n\nstruct Intersection\n{\n    bool hit;\n    float t;\n    vec3 normal;\n};\n\nIntersection IntersectSphere(vec3 o, vec3 d, vec3 center, float r)\n{\n\tvec3 to = o - center;\n\t\n    float a = dot(d, d);\n    float b = 2. * dot(d, to);\n    float c = dot(to, to) - (r * r);\n\t\n\tfloat disc = b * b - 4. * a * c;\n\t\n\tif (disc >= 0.)\n\t{\n\t\tfloat distSqrt = sqrt(disc);\n\t\tfloat q;\n\t\tif (b < 0.)\n\t\t\tq = (-b - distSqrt)/2.0;\n\t\telse\n\t\t\tq = (-b + distSqrt)/2.0;\n\n\t\t// compute t0 and t1\n\t\tfloat t0 = q / a;\n\t\tfloat t1 = c / q;\n\t\t\n\t\tfloat closestT = t0;\n\t\t\n\t\tif (t1 > 0. && t1 < closestT)\n\t\t\tclosestT = t1;\n\t\t\n\t\tif (closestT > 0.)\n\t\t{\n            return Intersection(true, closestT, normalize(intersectionPoint - center));\n\t\t}\n\t}\n    \n    return Intersection(false, 0., vec3(0));\n}\n\nvoid IntersectSphere(vec3 o, vec3 d, vec3 center, float r, int material)\n{\n    Intersection i = IntersectSphere(o, d, center, r);\n    \n    if (i.hit && i.t < intersectionT)\n    {\n        intersectionMaterial = material;\n        intersectionT = i.t;\n        intersectionPoint = o + d * intersectionT;\n        intersectionNormal = normalize(intersectionPoint - center);\n\t}\n}\n\nconst float kEarthRadius = 6.371e6;\nconst float kAtmosphereRadius = 6.171e6;\n\nvoid IntersectScene(vec3 o, vec3 d)\n{\n\tIntersectSphere(o, d, vec3(0, 10, 0), 1., MAT_GREY_DIFFUSE);\n\tIntersectSphere(o, d, vec3(1, 10.2 + .5 * sin(5.*iTime), 1), .7, MAT_GREY_DIFFUSE);\n\tIntersectSphere(o, d, vec3(-1, 10.2, 1), .7, MAT_CHROME);\n\tIntersectSphere(o, d, vec3(0, 10, -kEarthRadius - 1.5), kEarthRadius, MAT_WAVY_MIRROR);\n\tIntersectSphere(o, d, vec3(0, 10, 0), 1., MAT_GREY_DIFFUSE);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat aspect = iResolution.x / iResolution.y;\n\t\n\tvec2 uv = vec2(aspect, 1.) * (fragCoord.xy / iResolution.xy - .5);\n\t\n\tvec3 o = vec3(0, 0, 0);\n\t\n\tvec3 d;\n\t\n\td = vec3(uv.x, 1, uv.y);\n\t\n\td.xz *= .8;\n\t\n\td = normalize(d);\n\t\n\tvec3 color = vec3(0);\n\t\n\tbool tracing = true;\n\tfor (int i = 0; i < MAX_DEPTH; ++i)\n\t{\n\t\tintersectionMaterial = MAT_BACKGROUND;\n\t\tintersectionT = 1e37;\n\t\n\t\tIntersectScene(o, d);\n\t\t\n\t\tif (intersectionMaterial == MAT_BACKGROUND)\n\t\t{\n\t\t\tfloat backdrop = dot(d, vec3(0, .7, .7));\n\t\t\tcolor = backdrop * vec3(.5, .3, .3);\n\t\t\t\n\t\t\ttracing = false;\n\t\t}\n\t\telse if (intersectionMaterial == MAT_GREY_DIFFUSE)\n\t\t{\n\t\t\tcolor += .1;\n\t\t\t\n\t\t\tfloat lightDot = dot(intersectionNormal, normalize(vec3(5000, -5000, 10000)));\n\t\t\t\n\t\t\tif (lightDot > 0.)\n\t\t\t{\n\t\t\t\tcolor += .9 * lightDot;\n\t\t\t}\n\t\t\n\t\t\ttracing = false;\n\t\t}\n\t\telse if (intersectionMaterial == MAT_CHROME)\n\t\t{\n\t\t\to = intersectionPoint + intersectionNormal * .001;\n\t\t\td = reflect(d, intersectionNormal);\n\t\t}\n\t\telse if (intersectionMaterial == MAT_WAVY_MIRROR)\n\t\t{\n\t\t\to = intersectionPoint + intersectionNormal * .001;\n\t\t\td = reflect(d, normalize(intersectionNormal + .01 * sin(10.*intersectionPoint + 2.*iTime)));\n\t\t}\n\t\t\n\t\tif (!tracing) break;\n\t}\n\t\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xsj3WD","date":"1388449201","viewed":261,"name":"Ray-Sphere","username":"Cubeleo","description":"First ray tracing shader.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","reflection"],"hasliked":0,"parentid":"","parentname":""}}