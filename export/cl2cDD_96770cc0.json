{"ver":"0.1","info":{"id":"cl2cDD","date":"1691819493","viewed":63,"name":"3D Rotor Interpolation","username":"Dominexis","description":"Made by Dominexis. Complete original work.","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nCONTROLS:\n\nWASD - Forward/Left/Backward/Right movement\nSpace bar/X - Go up/down\n\nArrow keys -  Rotate camera\n\n*/\n\n\n\nconst float pi = 3.14159265;\n\n\n\n// Transforms a vector using a rotor\nvec3 RotTrans( in vec4 r, in vec3 v )\n{\n    return vec3(\n        (\n            (r.w*r.w + r.x*r.x - r.y*r.y - r.z*r.z)*v.x +\n            2.0*(r.y*r.x + r.w*r.z)*v.y +\n            2.0*(r.z*r.x - r.w*r.y)*v.z\n        ),\n        (\n            2.0*(r.x*r.y - r.w*r.z)*v.x +\n            (r.w*r.w - r.x*r.x + r.y*r.y - r.z*r.z)*v.y +\n            2.0*(r.z*r.y + r.w*r.x)*v.z\n        ),\n        (\n            2.0*(r.x*r.z + r.w*r.y)*v.x +\n            2.0*(r.y*r.z - r.w*r.x)*v.y +\n            (r.w*r.w - r.x*r.x - r.y*r.y + r.z*r.z)*v.z\n        )\n    );\n}\n\n// Stacks rotor transformations\nvec4 RotStack( in vec4 a, in vec4 b )\n{\n    return vec4(\n        (a.w*b.x + a.z*b.y - a.y*b.z + a.x*b.w),\n        (a.w*b.y - a.z*b.x + a.y*b.w + a.x*b.z),\n        (a.w*b.z + a.z*b.w + a.y*b.x - a.x*b.y),\n        (a.w*b.w - a.z*b.z - a.y*b.y - a.x*b.x)\n        \n    );\n}\n\n// Takes the inverse of a rotor\nvec4 RotInv( in vec4 r )\n{\n    return vec4( -r.xyz, r.w );\n}\n\n// Converts a rotor to a vector of angular velocity\nvec3 RotToVec( in vec4 r )\n{\n    float l = length(r.xyz);\n    if (l == 0.0) { l = 1.0; }\n    \n    return r.xyz/l *\n    (\n        mod(\n            2.0*atan(l, r.w)\n        + pi, 2.0*pi ) - pi\n    );\n}\n\n// Converts a vector of angular velocity to a rotor\nvec4 VecToRot( in vec3 v )\n{\n    float l = length(v);\n    float a = 0.5*l;\n    if (l == 0.0) { l = 1.0; }\n    \n    return vec4(\n        v*sin(a)/l,\n        cos(a)\n    );\n}\n\n// Converts a rotor to a rotation matrix\nmat3 RotToMat( in vec4 r )\n{\n    return mat3(\n        vec3(\n            (r.w*r.w + r.x*r.x - r.y*r.y - r.z*r.z),\n            2.0*(r.x*r.y - r.w*r.z),\n            2.0*(r.x*r.z + r.w*r.y)\n        ),\n        vec3(\n            2.0*(r.y*r.x + r.w*r.z),\n            (r.w*r.w - r.x*r.x + r.y*r.y - r.z*r.z),\n            2.0*(r.y*r.z - r.w*r.x)\n        ),\n        vec3(\n            2.0*(r.z*r.x - r.w*r.y),\n            2.0*(r.z*r.y + r.w*r.x),\n            (r.w*r.w - r.x*r.x - r.y*r.y + r.z*r.z)\n        )\n    );\n}\n\n\n\nvec4 getData( in int x, in int y )\n{\n    return texture(\n        iChannel0,\n        vec2(\n            float(x)+0.5,\n            float(y)+0.5\n        )/iResolution.xy\n    );\n}\n\nfloat getKey( in int key, in float type )\n{\n    return texture(\n        iChannel1,\n        vec2(\n            (float(key) + 0.5)/256.0,\n            type\n        )\n    ).x;\n}\n\n\n\nmat3 stretchedMat(in float x, in float y, in float z)\n{\n    return mat3(x,0.0,0.0,0.0,y,0.0,0.0,0.0,z);\n}\n\nvec4 applyObject(in vec4 old, in vec4 new)\n{\n    if (new.w < 0.0) { return old; }\n    if (old.w < 0.0) { return new; }\n    if (new.w < old.w) { return new; }\n    return old;\n}\n\nvec4 polygon( in vec3 camPos, in vec3 camRay, in vec3 polyPos, in mat3 polyRot, in vec3 tint, in vec3 light )\n{\n    polyRot = mat3(\n        polyRot[0],\n        polyRot[1],\n        normalize(cross(polyRot[0], polyRot[1]))\n    );\n\n    mat3 invPolyRot = inverse(polyRot);\n    vec3 localCamPos = invPolyRot*(camPos - polyPos);\n    vec3 localCamRay = invPolyRot*camRay;\n    \n    float dist = -1.0;\n    if (localCamRay.z != 0.0) {\n        dist = -localCamPos.z/localCamRay.z;\n    }\n    \n    vec3 point = localCamPos + localCamRay*dist;\n    if (\n        point.x < 0.0 ||\n        point.x > 1.0 ||\n        point.y < 0.0 ||\n        point.y > 1.0\n    ) {\n        dist = -1.0;\n    }\n    \n    return vec4(\n        tint*(dot(polyRot[2], light)*0.25 + 0.75),\n        dist\n    );\n}\n\nvec4 cube( in vec3 camPos, in vec3 camRay, in vec3 cubePos, in mat3 cubeRot, in vec3 tint, in vec3 light )\n{\n    vec4 color = vec4(0.0, 0.0, 0.0, -1.0);\n    color = applyObject(color, polygon(camPos, camRay, cubePos - cubeRot*vec3(0.5), mat3(cubeRot[1], cubeRot[0], cubeRot[2]), tint, light));\n    color = applyObject(color, polygon(camPos, camRay, cubePos - cubeRot*vec3(0.5), mat3(cubeRot[2], cubeRot[1], cubeRot[0]), tint, light));\n    color = applyObject(color, polygon(camPos, camRay, cubePos - cubeRot*vec3(0.5), mat3(cubeRot[0], cubeRot[2], cubeRot[1]), tint, light));\n    color = applyObject(color, polygon(camPos, camRay, cubePos + cubeRot*vec3(0.5), mat3(-cubeRot[0], -cubeRot[1], cubeRot[2]), tint, light));\n    color = applyObject(color, polygon(camPos, camRay, cubePos + cubeRot*vec3(0.5), mat3(-cubeRot[1], -cubeRot[2], cubeRot[0]), tint, light));\n    color = applyObject(color, polygon(camPos, camRay, cubePos + cubeRot*vec3(0.5), mat3(-cubeRot[2], -cubeRot[0], cubeRot[1]), tint, light));\n    return color;\n}\n\nvec4 cubeFrame( in vec3 camPos, in vec3 camRay, in vec3 cubePos, in mat3 cubeRot, in float width, in vec3 tint, in vec3 light )\n{\n    vec4 color = vec4(0.0, 0.0, 0.0, -1.0);\n    for (float i = 0.0; i < 4.0; i++) {\n        float a = mod(i,2.0)*2.0 - 1.0;\n        float b = mod(floor(i/2.0),2.0)*2.0 - 1.0;\n    \n        color = applyObject( color, cube( camPos, camRay, cubePos + cubeRot*vec3(0.0,a,b), cubeRot*stretchedMat(2.0+width,width,width), tint, light ) );\n        color = applyObject( color, cube( camPos, camRay, cubePos + cubeRot*vec3(b,0.0,a), cubeRot*stretchedMat(width,2.0+width,width), tint, light ) );\n        color = applyObject( color, cube( camPos, camRay, cubePos + cubeRot*vec3(a,b,0.0), cubeRot*stretchedMat(width,width,2.0+width), tint, light ) );\n    }\n    return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos = getData(1,0).xyz;\n    mat3 orientation = RotToMat(getData(2,0));\n    \n    float fov = 1.0;\n    vec3 ray = normalize(orientation * vec3( 1.0,\n        fov * (1.0 - (fragCoord.x/iResolution.x)*2.0),\n        fov * ((fragCoord.y/iResolution.x)*2.0 - iResolution.y/iResolution.x)\n    ));\n    \n    vec3 light = vec3(0.0,0.5,1.0);\n    \n    \n    // Rotors\n    vec4 RotA = normalize(vec4(0.2,-0.5,0.3,0.7));\n    vec4 RotB = normalize(vec4(0.4,0.2,0.8,0.3));\n    vec4 RotC = RotStack(VecToRot(RotToVec(RotStack(RotB, RotInv(RotA)))*(cos(iTime)*0.499 + 0.5)), RotA);\n    mat3 MatA = RotToMat(RotA);\n    mat3 MatB = RotToMat(RotB);\n    mat3 MatC = RotToMat(RotC);\n    \n    \n    // Sky color\n    fragColor = vec4(vec3((dot(ray, vec3(0.0,0.0,1.0))*0.2 + 0.6) * vec3(0.3,0.7,1.0)), -1.0);\n    \n    //fragColor = applyObject( fragColor, cube( pos, ray, vec3(0.0,0.0,0.0), stretchedMat(0.1,0.1,0.1), vec3(0.0,0.0,0.0), light ) );\n    //fragColor = applyObject( fragColor, cube( pos, ray, vec3(2.0,0.0,0.0), stretchedMat(4.0,0.1,0.1), vec3(1.0,0.0,0.0), light ) );\n    //fragColor = applyObject( fragColor, cube( pos, ray, vec3(0.0,2.0,0.0), stretchedMat(0.1,4.0,0.1), vec3(0.0,1.0,0.0), light ) );\n    //fragColor = applyObject( fragColor, cube( pos, ray, vec3(0.0,0.0,2.0), stretchedMat(0.1,0.1,4.0), vec3(0.0,0.0,1.0), light ) );\n\n    fragColor = applyObject( fragColor, cubeFrame( pos, ray, vec3(0.0,cos(iTime)*5.0,0.0), MatC*2.0, 0.1, vec3(0.0,0.5,0.0), light ) );\n    fragColor = applyObject( fragColor, cubeFrame( pos, ray, vec3(0.0,-5.0,0.0), MatA*2.0, 0.1, vec3(0.5,0.0,0.0), light ) );\n    fragColor = applyObject( fragColor, cubeFrame( pos, ray, vec3(0.0, 5.0,0.0), MatB*2.0, 0.1, vec3(0.0,0.0,0.5), light ) );\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n\n    Rotors are defined as vec4(ryz, rzx, rxy, r0) to ensure that the index represents the axis perpendicular to the rotation.\n\n*/\n\n\n\nconst float pi = 3.14159265;\n\n\n\n// Transforms a vector using a rotor\nvec3 RotTrans( in vec4 r, in vec3 v )\n{\n    return vec3(\n        (\n            (r.w*r.w + r.x*r.x - r.y*r.y - r.z*r.z)*v.x +\n            2.0*(r.y*r.x + r.w*r.z)*v.y +\n            2.0*(r.z*r.x - r.w*r.y)*v.z\n        ),\n        (\n            2.0*(r.x*r.y - r.w*r.z)*v.x +\n            (r.w*r.w - r.x*r.x + r.y*r.y - r.z*r.z)*v.y +\n            2.0*(r.z*r.y + r.w*r.x)*v.z\n        ),\n        (\n            2.0*(r.x*r.z + r.w*r.y)*v.x +\n            2.0*(r.y*r.z - r.w*r.x)*v.y +\n            (r.w*r.w - r.x*r.x - r.y*r.y + r.z*r.z)*v.z\n        )\n    );\n}\n\n// Stacks rotor transformations\nvec4 RotStack( in vec4 a, in vec4 b )\n{\n    return vec4(\n        (a.w*b.x + a.z*b.y - a.y*b.z + a.x*b.w),\n        (a.w*b.y - a.z*b.x + a.y*b.w + a.x*b.z),\n        (a.w*b.z + a.z*b.w + a.y*b.x - a.x*b.y),\n        (a.w*b.w - a.z*b.z - a.y*b.y - a.x*b.x)\n        \n    );\n}\n\n// Takes the inverse of a rotor\nvec4 RotInv( in vec4 r )\n{\n    return vec4( -r.xyz, r.w );\n}\n\n// Converts a rotor to a vector of angular velocity\nvec3 RotToVec( in vec4 r )\n{\n    float l = length(r.xyz);\n    if (l == 0.0) { l = 1.0; }\n    \n    return r.xyz/l *\n    (\n        mod(\n            2.0*atan(l, r.w)\n        + pi, 2.0*pi ) - pi\n    );\n}\n\n// Converts a vector of angular velocity to a rotor\nvec4 VecToRot( in vec3 v )\n{\n    float l = length(v);\n    float a = 0.5*l;\n    if (l == 0.0) { l = 1.0; }\n    \n    return vec4(\n        v*sin(a)/l,\n        cos(a)\n    );\n}\n\n// Converts a rotor to a rotation matrix\nmat3 RotToMat( in vec4 r )\n{\n    return mat3(\n        vec3(\n            (r.w*r.w + r.x*r.x - r.y*r.y - r.z*r.z),\n            2.0*(r.x*r.y - r.w*r.z),\n            2.0*(r.x*r.z + r.w*r.y)\n        ),\n        vec3(\n            2.0*(r.y*r.x + r.w*r.z),\n            (r.w*r.w - r.x*r.x + r.y*r.y - r.z*r.z),\n            2.0*(r.y*r.z - r.w*r.x)\n        ),\n        vec3(\n            2.0*(r.z*r.x - r.w*r.y),\n            2.0*(r.z*r.y + r.w*r.x),\n            (r.w*r.w - r.x*r.x - r.y*r.y + r.z*r.z)\n        )\n    );\n}\n\n\n\nbool isData( in vec2 fragCoord, in int x, in int y )\n{\n    return \n        int(floor(fragCoord.x)) == x &&\n        int(floor(fragCoord.y)) == y;\n}\n\nvec4 getData( in int x, in int y )\n{\n    return texture(\n        iChannel0,\n        vec2(\n            float(x)+0.5,\n            float(y)+0.5\n        )/iResolution.xy\n    );\n}\n\nfloat getKey( in int key, in float type )\n{\n    return texture(\n        iChannel1,\n        vec2(\n            (float(key) + 0.5)/256.0,\n            type\n        )\n    ).x;\n}\n\nbool isInitial()\n{\n    return getData(0,0).x <= 0.5;\n}\n\n\n\nvec4 tickRotationalVelocity()\n{\n    if (isInitial()) {\n        return vec4(0.0, 0.0, 0.0, 0.0);\n    }\n    \n    return vec4(\n        getData(2,2).xy + (\n            vec2(\n                (getKey(39, 0.0) - getKey(37, 0.0)),\n                (getKey(38, 0.0) - getKey(40, 0.0))\n            )*10.0\n            - 4.0*getData(2,2).xy\n        )*iTimeDelta,\n        0.0,\n        0.0\n    );\n}\n\nvec4 tickRotation()\n{\n    if (isInitial()) {\n        return vec4(-pi, 0.0, 0.0, 0.0);\n    }\n    \n    return vec4(\n        mod(getData(2,1).x + tickRotationalVelocity().x*iTimeDelta, 2.0*pi),\n        min(max(getData(2,1).y + tickRotationalVelocity().y*iTimeDelta, -0.5*pi), 0.5*pi),\n        0.0,\n        0.0\n    );\n}\n\nvec4 tickConvertRotation()\n{\n    return RotStack(\n        vec4(0.0,0.0,sin(tickRotation().x*0.5),cos(tickRotation().x*0.5)),\n        vec4(0.0,sin(tickRotation().y*0.5),0.0,cos(tickRotation().y*0.5))\n    );\n}\n\n\n\nvec4 tickMotion()\n{\n    if (isInitial()) {\n        return vec4(20.0, 0.0, 0.0, 0.0);\n    }\n    \n    return vec4(\n        getData(1,1).xyz +\n        (\n            // Acceleration\n            RotToMat(getData(2,0))*vec3(\n                getKey(87, 0.0) - getKey(83, 0.0),\n                getKey(65, 0.0) - getKey(68, 0.0),\n                getKey(32, 0.0) - getKey(88, 0.0)\n            )*60.0\n            // Dampening\n            - 5.0*getData(1,1).xyz\n        )*iTimeDelta,\n        0.0\n    );\n}\n\nvec4 tickPosition()\n{\n    if (isInitial()) {\n        return vec4(10.0, 0.0, 0.0, 0.0);\n    }\n    \n    return vec4(\n        getData(1,0).xyz +\n        tickMotion().xyz*iTimeDelta,\n        0.0\n    );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Run function based on location of pixel\n    \n    vec4 data = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    if (isData(fragCoord,0,0)) {\n        data = vec4(1.0);\n    }\n    \n    else if (isData(fragCoord,1,0)) {\n        data = tickPosition();\n    }\n    else if (isData(fragCoord,1,1)) {\n        data = tickMotion();\n    }\n    \n    else if (isData(fragCoord,2,0)) {\n        data = tickConvertRotation();\n    }\n    else if (isData(fragCoord,2,1)) {\n        data = tickRotation();\n    }\n    else if (isData(fragCoord,2,2)) {\n        data = tickRotationalVelocity();\n    }\n\n    fragColor = data;\n}","name":"Buffer A","description":"","type":"buffer"}]}