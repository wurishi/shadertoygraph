{"ver":"0.1","info":{"id":"Ntj3Dh","date":"1624354594","viewed":441,"name":"coronavirus in microscope","username":"munrocket","description":".","likes":28,"published":1,"flags":0,"usePreview":0,"tags":["glow","bio","virus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100.\n#define MAX_DIST 2.5\n#define MIN_STEP 0.001\n\nconst float dihedIcos = 0.5 * acos (sqrt (5.) / 3.);\nconst float pentaHeight = 1.5*acos(dot(normalize(vec3(M_PHI+1., 1., M_PHI)), normalize(vec3(.5))));\nconst float nn = 10. * 3.;\nconst float an = 6.2831853 / nn;\nconst float r0 = .7;\nconst float r1 = .16;\nconst float r2 = .008;\nconst float r3 = .005;\n\n/// icosahedral symmetry https://www.shadertoy.com/view/MdXfWS\nvec2 Rot2D (vec2 q, float a) {return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);}\nvec3 IcosSym (vec3 p) {\n  const float dihedIcos = 0.5 * acos (sqrt (5.) / 3.);\n  float a, w;\n  w = 2. * M_PI / 3.;\n  p.z = abs (p.z);\n  p.yz = Rot2D (p.yz, - dihedIcos);\n  p.x = - abs (p.x);\n  for (int k = 0; k < 4; k ++) {\n    p.zy = Rot2D (p.zy, - dihedIcos);\n    p.y = - abs (p.y);\n    p.zy = Rot2D (p.zy, dihedIcos);\n    if (k < 3) p.xy = Rot2D (p.xy, - w);\n  }\n  p.z = - p.z;\n  a = mod (atan (p.x, p.y) + 0.5 * w, w) - 0.5 * w;\n  p.yx = vec2 (cos (a), sin (a)) * length (p.xy);\n  p.x -= 2. * p.x * step (0., p.x);\n  return p;\n}\n///\n\n#define COUNT 3.\n#define MARGIN 1.6\n\nfloat map(vec3 p) {\n    float cube = max(abs(p.x), max(abs(p.y), abs(p.z))) - .5 * COUNT * MARGIN;\n    p.x = MARGIN * (fract(p.x / MARGIN - .5) - .5);\n    \n    p = IcosSym(p.xyz);\n    p.yz = Rot2D (p.yz, -dihedIcos);\n    \n    float d = length(vec3(p.x, p.y, p.z + .65)) - .045;\n    float d2 = sdCapsule(p,  vec3(0), vec3(0., 0., -.65), .02);\n    \n    \n    p.xz = Rot2D (p.xz, pentaHeight);\n    d = min(d, length(vec3(p.x, p.y, p.z + .60)) - .045);\n    d2 = min(d2, sdCapsule(p,  vec3(0), vec3(0., 0., -.60), .02));\n    \n    d = min(d, length(p)-.45);\n    d = opUnion(d2, d, 0.05);\n    d = max(d, -length(p)+.40);\n    \n    d += noise3(p*70.0)*0.008;\n    \n    return max(cube, d);\n}\n\nvec3 march(vec3 camera, vec3 dir, out vec3 pos) {\n    float dist, t = 0.;\n    vec3 col;\n    float zerolvl = 0.1;\n    for(float i = 0.; i < MAX_STEPS; i++) {\n      \tpos = camera + t * dir;\n        dist = 0.65 * map(pos);\n        col += pow(0.002/max(0., dist + .65*zerolvl), 1.1)                 // accum\n             * pow(1. - (t + .5 - length(camera)) / MAX_DIST, 6.)          // fade\n             * mix(vec3(1.,.03,0.), vec3(.05,1.,.01), length(pos)*1.2-.2); //col\n        t += max(MIN_STEP, dist);\n        if(t > MAX_DIST) break;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = (2.*fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 dir = normalize(vec3(uv, -2.5));\n    vec3 camera = vec3(0., 0.04+.04*cos(iTime), 1.65 - .3 * cos(iTime));\n    \n    vec4 mouse = qmouse(iMouse, iResolution, iTime, .1);\n    dir = rotate(dir, mouse);\n    camera = rotate(camera, mouse);\n    \n    vec3 pos, col = vec3(.005, .04, .08);\n    col += march(camera, dir, pos) + 0.1 * noise3(70. * vec3(uv,0) + 100. * iTime);\n    fragColor = vec4(pow(col, vec3(0.99)), .0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define M_PI   3.1415926\n#define M_PHI  1.6180339\n\n/* quaternions */\n\nvec4 qmult(vec4 p, vec4 q) {\n    vec3 pv = p.xyz, qv = q.xyz;\n    return vec4(p.w * qv + q.w * pv + cross(pv, qv), p.w * q.w - dot(pv, qv));\n}\n\nvec4 qrotor(vec3 axis, float phi) {\n    return vec4(sin(phi*0.5) * axis, cos(phi*0.5));\n}\n\nvec4 qmouse(vec4 iMouse, vec3 iResolution, float iTime, float initRotation) {\n    vec2 mouse = mix(vec2(0.5 - initRotation * sin(iTime), 0.5 - initRotation * cos(iTime)),\n                                        iMouse.xy / iResolution.xy, step(0.0027, iMouse.y));\n    vec4 rotY = qrotor(vec3(0., 1., 0.), M_PI - 2.*M_PI * mouse.x);\n    vec4 rotX = qrotor(vec3(1., 0., 0.), M_PI * mouse.y - 0.5*M_PI);\n    return qmult(rotY, rotX);\n}\n\nvec3 rotate(vec3 point, vec4 qrotor) {\n    vec3 rv = qrotor.xyz;\n    return qmult(qrotor, vec4(point * qrotor.w - cross(point, rv), dot(point, rv))).xyz;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat opUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n/* noise */\n\nfloat mod289( float x ) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 mod289( vec4 x ) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 perm(vec4 x) {\n    return mod289(((x * 34.0) + 1.0) * x);\n}\nfloat noise3(vec3 p) {\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}","name":"Common","description":"","type":"common"}]}