{"ver":"0.1","info":{"id":"l3lBzB","date":"1728575162","viewed":186,"name":"Beach Girl","username":"hectobreak","description":"California gurls, we're unforgettable.\nHad fun doing some basic procedural animation. It's always fun to implement things you often take for granted like rigging bone hierarchies.","likes":13,"published":3,"flags":0,"usePreview":0,"tags":["animation","character","modelling","rigging"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float toon_shading = 1.0;\n\nvec4 quat_mult(vec4 a, vec4 b){\n    vec3 ijk = a.xxx * b.yzw + a.yzw * b.xxx + a.zwy * b.wyz - a.wyz * b.zwy;\n    return vec4(\n        a.x * b.x - dot(a.yzw, b.yzw),\n        ijk\n    );\n}\n\nvec4 quat_conj(vec4 q){\n    return vec4(q.x, -q.yzw);\n}\n\nvec3 rotate_by_quat(vec4 quat, vec3 vector){\n    vec4 p = vec4(0.0, vector);\n    vec4 r = quat_mult(quat, quat_mult(p, quat_conj(quat)));\n    return r.yzw;\n}\n\nmat4 rotation_matrix(vec3 dir, float angle){\n    vec3 norm = normalize(dir);\n    float x = cos(angle/2.0);\n    float sin = sin(angle/2.0);\n    vec4 xijk = vec4(x, norm * sin);\n    \n    vec3 col1 = rotate_by_quat(xijk, vec3(1.0, 0.0, 0.0));\n    vec3 col2 = rotate_by_quat(xijk, vec3(0.0, 1.0, 0.0));\n    vec3 col3 = rotate_by_quat(xijk, vec3(0.0, 0.0, 1.0));\n    \n    return mat4(\n        vec4(col1, 0.0),\n        vec4(col2, 0.0),\n        vec4(col3, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}\n\nmat4 translation_matrix(vec3 translate){\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        translate.xyz, 1.0\n    );\n}\n\nmat4 spine_transform = \n    mat4(1.0,0.0,0.0,0.0,\n         0.0,1.0,0.0,0.0,\n         0.0,0.0,1.0,0.0,\n         0.0,1.0,0.0,1.0);\n\nmat4 thigh1_transform = \n    mat4(-1,0.0,0.0,0.0,\n         0.0,-1.0,0.0,0.0,\n         0.0,0.0,1.0,0.0,\n         0.15,0.0,-0.05,1.0);\n\nmat4 calves1_transform = \n    mat4(1,0.0,0.0,0.0,\n         0.0,1.0,0.0,0.0,\n         0.0,0.0,1.0,0.0,\n         0.0,0.7,0.0,1.0);\n\nmat4 thigh2_transform = \n    mat4(-1,0.0,0.0,0.0,\n         0.0,-1.0,0.0,0.0,\n         0.0,0.0,1.0,0.0,\n         -0.15,0.0,-0.05,1.0);\n\nmat4 calves2_transform = \n    mat4(1,0.0,0.0,0.0,\n         0.0,1.0,0.0,0.0,\n         0.0,0.0,1.0,0.0,\n         0.0,0.7,0.0,1.0);\n\nmat4 arm1_transform;\n\nmat4 forearm1_transform = \n    mat4(1.0,0.0,0.0,0.0,\n         0.0,1.0,0.0,0.0,\n         0.0,0.0,1.0,0.0,\n         0.0,0.5,0.0,1.0);\n\nmat4 arm2_transform;\n\nmat4 forearm2_transform = \n    mat4(1.0,0.0,0.0,0.0,\n         0.0,1.0,0.0,0.0,\n         0.0,0.0,1.0,0.0,\n         0.0,0.5,0.0,1.0);\n\nmat4 head_transform = \n    mat4(1.0,0.0,0.0,0.0,\n         0.0,1.0,0.0,0.0,\n         0.0,0.0,1.0,0.0,\n         0.0,1.2,0.0,1.0);\n\nmat4 spine_transform_inverse;\nmat4 thigh1_transform_inverse;\nmat4 calves1_transform_inverse;\nmat4 thigh2_transform_inverse;\nmat4 calves2_transform_inverse;\nmat4 arm1_transform_inverse;\nmat4 forearm1_transform_inverse;\nmat4 arm2_transform_inverse;\nmat4 forearm2_transform_inverse;\nmat4 head_transform_inverse;\n\nfloat smin( float a, float b, float k )\n{\n    k *= 1.0/(1.0-sqrt(0.5));\n    float h = max( k-abs(a-b), 0.0 )/k;\n    const float b2 = 13.0/4.0 - 4.0*sqrt(0.5);\n    const float b3 =  3.0/4.0 - 1.0*sqrt(0.5);\n    return min(a,b) - k*h*h*(h*b3*(h-4.0)+b2);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCappedCone( vec3 p, vec3 a, vec3 b, float ra, float rb )\n{\n  float rba  = rb-ra;\n  float baba = dot(b-a,b-a);\n  float papa = dot(p-a,p-a);\n  float paba = dot(p-a,b-a)/baba;\n  float x = sqrt( papa - paba*paba*baba );\n  float cax = max(0.0,x-((paba<0.5)?ra:rb));\n  float cay = abs(paba-0.5)-0.5;\n  float k = rba*rba + baba;\n  float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n  float cbx = x-ra - f*rba;\n  float cby = paba - f;\n  float s = (cbx<0.0 && cay<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(cax*cax + cay*cay*baba,\n                     cbx*cbx + cby*cby*baba) );\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat hair_sdf(vec3 point){\n    point = (head_transform_inverse * spine_transform_inverse * vec4(point, 1.0)).xyz;\n    float hair1 = 999.0;\n    for(float i = 0.34; i > -1.2; i -= 0.1){\n        float z = -0.22 - 0.15 * (-i + 0.34) * (-i + 0.34);\n        vec3 pbox = point - vec3(0.0, i, z - 0.05 * cos(5.0 * i));\n        pbox = (rotation_matrix(vec3(1.0, 0.0, 0.0), -0.2) * vec4(pbox, 1.0)).xyz;\n        hair1 = smin(hair1, sdBox(pbox, vec3(0.12+0.05*(sin((i - 0.32)*8.0) - 4.0 * i), 0.03, 0.00)), 0.06);\n    }\n    float hair2 = sdSphere(point - vec3(0, 0.35, -0.03), 0.15);\n    float hair3 = sdSphere(point - vec3(0, 0.5, 0.05), 0.1);\n    float hair4 = sdSphere(point - vec3(-0.06, 0.47, 0.20), 0.03);\n    float hair5 = sdSphere(point - vec3(-0.15, 0.43, 0.20), 0.03);\n    float hair6 = sdSphere(point - vec3(-0.22, 0.35, 0.10), 0.03);\n    float hair7 = sdSphere(point - vec3(0.20, 0.4, 0.10), 0.03);\n    \n    float volume = smin(smin(hair5, hair6, 0.03), hair7, 0.03);\n    \n    float hair = smin(smin(smin(hair1, hair2, 0.05), smin(hair3, hair4, 0.03), 0.1), volume, 0.04);\n    return hair;\n}\n\n\nfloat head_sdf(vec3 point){\n    point = (head_transform_inverse * spine_transform_inverse * vec4(point, 1.0)).xyz;\n    float neck = sdCapsule( point, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.3, 0.0), 0.1);\n    float head1 = sdSphere( point - vec3(0.0, 0.33, 0.05), 0.23);\n    float head2 = sdSphere( point - vec3(0.0, 0.13, 0.17), 0.08);\n    \n    return smin(neck, smin(head1, head2, 0.05), 0.02);\n}\n\nfloat forearm2_sdf(vec3 point){\n    point = (forearm2_transform_inverse * arm2_transform_inverse * spine_transform_inverse * vec4(point, 1.0)).xyz;\n    \n    float l1 = sdCappedCone( point, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.25, 0.0), 0.06, 0.065);\n    float l2 = sdCappedCone( point, vec3(0.0, 0.25, 0.0), vec3(0.0, 0.5, 0.0), 0.065, 0.04);\n    float l3 = sdSphere( point+vec3(0.0, -0.02, 0.03), 0.05 );\n    float l4 = sdCapsule( point, vec3(-0.05, 0.6, -0.05), vec3(-0.05, 0.6, 0.05), 0.05);\n    float l5 = sdCapsule( point, vec3(0.0, 0.52, -0.01), vec3(0.0, 0.52, 0.01), 0.05);\n    float l6 = sdCapsule( point, vec3(0.0, 0.57, -0.015), vec3(0.0, 0.57, 0.015), 0.05);\n    float l7 = sdCapsule( point, vec3(-0.05, 0.52, -0.00), vec3(-0.05, 0.52, 0.02), 0.05);\n    \n    float l8 = sdSphere( point, 0.06 );\n    \n    return min(min(smin(min(l1, l2), l3, 0.01),smin(smin(l4, l7, 0.01), smin(l5, l6, 0.01), 0.02)), l8); \n}\n\nfloat arm2_sdf(vec3 point){\n    point = (arm2_transform_inverse * spine_transform_inverse * vec4(point, 1.0)).xyz;\n    float l1 = sdCappedCone( point, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.25, -0.02), 0.07, 0.075);\n    float l2 = sdCappedCone( point, vec3(0.0, 0.25, -0.02), vec3(0.0, 0.5, 0.0), 0.075, 0.06);\n    float l3 = sdSphere( point+vec3(0.0, -0.02, 0.03), 0.1 );\n    float l4 = sdSphere( point - vec3(0.0, 0.25, -0.02), 0.075);\n    \n    return min(smin(min(l1, l2), l3, 0.02), l4);\n}\n\nfloat forearm1_sdf(vec3 point){\n    point = (forearm1_transform_inverse * arm1_transform_inverse * spine_transform_inverse * vec4(point, 1.0)).xyz;\n    \n    float l1 = sdCappedCone( point, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.25, 0.0), 0.06, 0.065);\n    float l2 = sdCappedCone( point, vec3(0.0, 0.25, 0.0), vec3(0.0, 0.5, 0.0), 0.065, 0.04);\n    float l3 = sdSphere( point+vec3(0.0, -0.02, 0.03), 0.05 );\n    float l4 = sdCapsule( point, vec3(0.05, 0.6, -0.05), vec3(0.05, 0.6, 0.05), 0.05);\n    float l5 = sdCapsule( point, vec3(0.0, 0.52, -0.01), vec3(0.0, 0.52, 0.01), 0.05);\n    float l6 = sdCapsule( point, vec3(0.0, 0.57, -0.015), vec3(0.0, 0.57, 0.015), 0.05);\n    float l7 = sdCapsule( point, vec3(0.05, 0.52, -0.00), vec3(0.05, 0.52, 0.02), 0.05);\n    \n    float l8 = sdSphere( point, 0.06 );\n    \n    return min(min(smin(min(l1, l2), l3, 0.01),smin(smin(l4, l7, 0.01), smin(l5, l6, 0.01), 0.02)), l8);\n}\n\nfloat arm1_sdf(vec3 point){\n    point = (arm1_transform_inverse * spine_transform_inverse * vec4(point, 1.0)).xyz;\n    float l1 = sdCappedCone( point, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.25, -0.02), 0.07, 0.075);\n    float l2 = sdCappedCone( point, vec3(0.0, 0.25, -0.02), vec3(0.0, 0.5, 0.0), 0.075, 0.06);\n    float l3 = sdSphere( point+vec3(0.0, -0.02, 0.03), 0.1 );\n    \n    float l4 = sdSphere( point - vec3(0.0, 0.25, -0.02), 0.075);\n    \n    return min(smin(min(l1, l2), l3, 0.02), l4);\n}\n\nfloat calves1_sdf(vec3 point){\n    point = (calves1_transform_inverse * thigh1_transform_inverse * spine_transform_inverse * vec4(point, 1.0)).xyz;\n    float l1 = sdCappedCone( point, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.25, -0.05), 0.09, 0.1);\n    float l2 = sdCappedCone( point, vec3(0.0, 0.25, -0.05), vec3(0.0, 0.7, 0.0), 0.10, 0.07);\n    \n    float l3 = sdCapsule( point, vec3(0.0, 0.7, 0.0), vec3(-0.1, 0.7, 0.18), 0.05);\n    float l4 = sdCapsule( point, vec3(0.0, 0.7, 0.0), vec3(0.0, 0.7, 0.22), 0.05);\n    float l5 = sdSphere( point - vec3(0.0, 0.25, -0.05), 0.1);\n    float l6 = sdSphere( point - vec3(0.0, 0.0, 0.0), 0.09);\n    return min(min(min(l1, l2), smin(l3, l4, 0.02)), min(l5, l6));\n}\n\nfloat thigh1_sdf(vec3 point){\n    point = (thigh1_transform_inverse * spine_transform_inverse * vec4(point, 1.0)).xyz;\n    float l = sdCappedCone( point, vec3(0.0, -0.05, 0.0), vec3(0.0, 0.7, 0.0), 0.13, 0.09);\n    float l2 = sdCapsule(point, vec3(0.0, 0.3, 0.0), vec3(0.0, 0.45, 0.0), 0.00);\n    float a = sdSphere( point - vec3(0.2, -0.1, -0.1), 0.01);\n    return smin(smin(l, l2, 0.06), a, 0.1);\n}\n\nfloat calves2_sdf(vec3 point){\n    point = (calves2_transform_inverse * thigh2_transform_inverse * spine_transform_inverse * vec4(point, 1.0)).xyz;\n    float l1 = sdCappedCone( point, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.25, -0.05), 0.09, 0.1);\n    float l2 = sdCappedCone( point, vec3(0.0, 0.25, -0.05), vec3(0.0, 0.7, 0.0), 0.10, 0.07);\n    float l3 = sdCapsule( point, vec3(0.0, 0.7, 0.0), vec3(0.1, 0.7, 0.18), 0.05);\n    float l4 = sdCapsule( point, vec3(0.0, 0.7, 0.0), vec3(0.0, 0.7, 0.22), 0.05);\n    float l5 = sdSphere( point - vec3(0.0, 0.25, -0.05), 0.1);\n    float l6 = sdSphere( point - vec3(0.0, 0.0, 0.0), 0.09);\n    return min(min(min(l1, l2), smin(l3, l4, 0.02)), min(l5, l6));\n}\n\nfloat thigh2_sdf(vec3 point){\n    point = (thigh2_transform_inverse * spine_transform_inverse * vec4(point, 1.0)).xyz;\n    float l = sdCappedCone( point, vec3(0.0, -0.05, 0.0), vec3(0.0, 0.7, 0.0), 0.13, 0.09);\n    float l2 = sdCapsule(point, vec3(0.0, 0.3, 0.0), vec3(0.0, 0.45, 0.0), 0.00);\n    float a = sdSphere( point - vec3(-0.2, -0.1, -0.1), 0.01);\n    return smin(smin(l, l2, 0.06), a, 0.1);\n}\n\nfloat torso_sdf(vec3 point){\n    point = (spine_transform_inverse * vec4(point, 1.0)).xyz;\n    float shoulders = sdCapsule( point, vec3(-0.2, 1.0, -0.1), vec3(0.2, 1.0, -0.1), 0.02);\n    float back1 = sdCapsule( point, vec3(0.0, 0.15, 0.0), vec3(0.0, 1.0, 0.0), 0.13);\n    float back2 = sdCapsule( point, vec3(-0.15, 0.0, 0.0), vec3(-0.15, 1.0, 0.0), 0.06);\n    float back3 = sdCapsule( point, vec3(0.15, 0.0, 0.0), vec3(0.15, 1.0, 0.0), 0.06);\n    float back = smin(back1, smin(back2, back3, 0.05), 0.05);\n    float t1 = sdSphere( point - vec3(-0.2, 0.8, 0.2), 0.05 );\n    float t2 = sdSphere( point - vec3(0.2, 0.8, 0.2), 0.05 );\n    float t = smin(t1, t2, 0.05);\n    float waist = sdCapsule( point, vec3(-0.2, 0.15, -0.1), vec3(0.2, 0.15, -0.1), 0.04);\n    return smin(waist, smin(t, smin(shoulders, back, 0.1), 0.1), 0.1);\n    \n}\n\nfloat floor_sdf(vec3 point){\n    return sdPlane(point, vec3(0.0, 1.0, 0.0), 0.59);\n}\n\nvec3 flesh(float y){\n    return mix(vec3(0.9, 0.8, 0.8), vec3(0.97, 0.83, 0.83), y * 0.5);\n}\n\nvoid torso_color(vec3 point, inout float dist, inout vec3 color){\n    float d = torso_sdf(point);\n    if(d < dist){\n        dist = d;\n        color = flesh(point.y);\n        vec3 p = (spine_transform_inverse * vec4(point, 1.0)).xyz;\n        float b1 = udTriangle(p, vec3(0.1, 0.7, 0.25), vec3(0.25, 0.9, 0.25), vec3(0.25, 0.7, 0.25)) - 0.06;\n        float b2 = udTriangle(p, vec3(-0.1, 0.7, 0.25), vec3(-0.25, 0.9, 0.25), vec3(-0.25, 0.7, 0.25)) - 0.06;\n        float b3 = sdCappedCone(p, vec3(0.0, 0.7, 0.0), vec3(0.0, 0.701, 0.0), 9.0, 9.0);\n        float b4 = sdCappedCone(p, vec3(0.0, 0.9, 0.0), vec3(0.0, 1.0, 0.15), 0.23, 0.23);\n        if(p.z > 0.1 && abs(p.x) < 0.2) b4 = 999.0;\n        \n        float b5 = sdCappedCone(p, vec3(0.0, 0.2, 0.0), vec3(0.0, 0.0, 0.0), 0.3, 0.1);\n        if(p.z < 0.0 && (p.y + 0.0) * (p.y + 0.0) + (p.z - 0.01) * (p.z - 0.01) > 0.03 && p.y < 0.2) b5 = 0.0;\n        if(min(smin(smin(smin(b1, b2, 0.02), b3, 0.02), b4, 0.01),b5) < 0.02)\n            color = vec3(0.0, 0.0, 0.8);\n    }\n}\n\nvoid thigh1_color(vec3 point, inout float dist, inout vec3 color){\n    float d = thigh1_sdf(point);\n    if(d < dist){\n        dist = d;\n        color = flesh(point.y);\n        \n        vec3 p = (spine_transform_inverse * vec4(point, 1.0)).xyz;\n        if(p.z < 0.0 && 1.5 * (p.y - 0.17) * (p.y - 0.17) + (p.x) * (p.x) < 0.1)\n            color = vec3(0.0, 0.0, 0.8);\n    }\n}\n\nvoid calves1_color(vec3 point, inout float dist, inout vec3 color){\n    float d = calves1_sdf(point);\n    if(d < dist){\n        dist = d;\n        color = flesh(point.y);\n    }\n}\n\nvoid thigh2_color(vec3 point, inout float dist, inout vec3 color){\n    float d = thigh2_sdf(point);\n    if(d < dist){\n        dist = d;\n        color = flesh(point.y);\n        \n        vec3 p = (spine_transform_inverse * vec4(point, 1.0)).xyz;\n        if(p.z < 0.0 && 1.5 * (p.y - 0.17) * (p.y - 0.17) + (p.x) * (p.x) < 0.1)\n            color = vec3(0.0, 0.0, 0.8);\n    }\n}\n\nvoid calves2_color(vec3 point, inout float dist, inout vec3 color){\n    float d = calves2_sdf(point);\n    if(d < dist){\n        dist = d;\n        color = flesh(point.y);\n    }\n}\n\nvoid arm1_color(vec3 point, inout float dist, inout vec3 color){\n    float d = arm1_sdf(point);\n    if(d < dist){\n        dist = d;\n        color = flesh(point.y);\n    }\n}\n\nvoid forearm1_color(vec3 point, inout float dist, inout vec3 color){\n    float d = forearm1_sdf(point);\n    if(d < dist){\n        dist = d;\n        color = flesh(point.y);\n    }\n}\n\nvoid arm2_color(vec3 point, inout float dist, inout vec3 color){\n    float d = arm2_sdf(point);\n    if(d < dist){\n        dist = d;\n        color = flesh(point.y);\n    }\n}\n\nvoid forearm2_color(vec3 point, inout float dist, inout vec3 color){\n    float d = forearm2_sdf(point);\n    if(d < dist){\n        dist = d;\n        color = flesh(point.y);\n    }\n}\n\nvoid hair_color(vec3 point, inout float dist, inout vec3 color){\n    float d = hair_sdf(point);\n    if(d < dist){\n        dist = d;\n        color = vec3(0.7, 0.3, 0.2);\n    }\n}\n\nvoid floor_color(vec3 point, inout float dist, inout vec3 color){\n    float d = floor_sdf(point);\n    if(d < dist){\n        dist = d;\n        color = vec3(0.9, 0.9, 0.8);\n    }\n}\n\n\nvoid head_color(vec3 point, inout float dist, inout vec3 color){\n    float d = head_sdf(point);\n    if(d < dist){\n        dist = d;\n        color = flesh(point.y);\n        vec3 p = (head_transform_inverse * spine_transform_inverse * vec4(point, 1.0)).xyz;\n        float e = 0.16;\n        if(p.y < 0.32){\n            float c1 = distance(p, vec3(e, 0.3, 0.3));\n            if(c1 < 0.1){\n                if(p.y > 0.3 || c1 < 0.09) {\n                    float c3 = distance(p, vec3(e+0.027, 0.28, 0.27));\n                    if(p.y < 0.3 && c3 < 0.07) color = vec3(1.0, 1.0, 1.0);\n                    else color = vec3(0.0, 0.0, 0.0);\n                }\n                else color = vec3(1.0, 1.0, 1.0);\n            } else if(c1 < 0.12)\n                color = vec3(0.0, 0.0, 0.0);\n            float c2 = distance(p, vec3(-e, 0.3, 0.3));\n            if(c2 < 0.1){\n                if(p.y > 0.3 || c2 < 0.09){\n                    float c3 = distance(p, vec3(-e+0.027, 0.28, 0.308));\n                    if(p.y < 0.3 && c3 < 0.07) color = vec3(1.0, 1.0, 1.0);\n                    else color = vec3(0.0, 0.0, 0.0);\n                }\n                else color = vec3(1.0, 1.0, 1.0);\n            } else if(c2 < 0.12)\n                color = vec3(0.0, 0.0, 0.0);\n            \n            float c3 = distance(p, vec3(0, 0.25, 0.3));\n            if(abs(c3 - 0.14) < 0.015 && p.y < 0.16){\n                color = vec3(0.0, 0.0, 0.0);\n            }\n        } else {\n            float c1 = sdCapsule(p, vec3(e + 0.12, 0.42, 0.18), vec3(e - 0.12, 0.36, 0.25), 0.03);\n            if(c1 < 0.0){\n                color = vec3(0.0, 0.0, 0.0);\n            }\n            float c2 = sdCapsule(p, vec3(-e - 0.12, 0.42, 0.18), vec3(-e + 0.12, 0.36, 0.25), 0.03);\n            if(c2 < 0.0){\n                color = vec3(0.0, 0.0, 0.0);\n            }\n        }\n        \n    }\n}\n\nfloat sdf(vec3 point, inout float closest_dist){\n    float d = torso_sdf(point);\n    d = smin(d, thigh1_sdf(point), 0.03);\n    d = min(d, calves1_sdf(point));\n    d = smin(d, thigh2_sdf(point), 0.03);\n    d = min(d, calves2_sdf(point));\n    d = smin(d, arm1_sdf(point), 0.01);\n    d = min(d, forearm1_sdf(point));\n    d = smin(d, arm2_sdf(point), 0.01);\n    d = min(d, forearm2_sdf(point));\n    d = smin(d, head_sdf(point), 0.015);\n    d = min(d, hair_sdf(point));\n    closest_dist = min(d, closest_dist);\n    return d;\n}\n\nvec3 sdf_normal(vec3 point){\n    float _;\n    float dx = 0.0001;\n    float fx = sdf(point, _);\n    float fdx = sdf(point + vec3(dx, 0.0, 0.0), _);\n    float fdy = sdf(point + vec3(0.0, dx, 0.0), _);\n    float fdz = sdf(point + vec3(0.0, 0.0, dx), _);\n    return normalize(vec3(fdx, fdy, fdz));\n}\n\nvoid color(vec3 point, inout float dist, inout vec3 color){\n    vec3 og = color;\n    \n    torso_color(point, dist, color);\n    thigh1_color(point, dist, color);\n    calves1_color(point, dist, color);\n    thigh2_color(point, dist, color);\n    calves2_color(point, dist, color);\n    arm1_color(point, dist, color);\n    forearm1_color(point, dist, color);\n    arm2_color(point, dist, color);\n    forearm2_color(point, dist, color);\n    head_color(point, dist, color);\n    hair_color(point, dist, color);\n    \n    if(toon_shading < 1.0 && color != og){\n        vec3 normal = sdf_normal(point);\n        vec3 light = vec3(2.0, 4.0, 2.0);\n        float ndotl = dot(normal, normalize(light - point));\n        color *= max(ndotl, 0.0) * (1.0 - toon_shading) + toon_shading;\n    }\n}\n\nvoid compute_inverses(){\n    spine_transform_inverse = inverse(spine_transform);\n    thigh1_transform_inverse = inverse(thigh1_transform);\n    calves1_transform_inverse = inverse(calves1_transform);\n    thigh2_transform_inverse = inverse(thigh2_transform);\n    calves2_transform_inverse = inverse(calves2_transform);\n    arm1_transform_inverse = inverse(arm1_transform);\n    forearm1_transform_inverse = inverse(forearm1_transform);\n    arm2_transform_inverse = inverse(arm2_transform);\n    forearm2_transform_inverse = inverse(forearm2_transform);\n    head_transform_inverse = inverse(head_transform);\n}\n\n\nfloat time;\n\nvec3 ray_march(inout vec3 point, in vec3 dir){\n    float lambda = (-0.59 - point.y) / dir.y;\n    vec3 gcol = point + lambda * dir;\n    float bline = gcol.x + 0.4 * sin(gcol.z + time) + 0.15 * sin(2.0 * gcol.z + 3.0 * time);\n    \n    vec3 ret = vec3(0.9, 0.9, 0.8);\n    if(bline > 5.0 + 3.0 * sin(time)) ret = vec3(0.4, 0.4, 0.8);\n    else if(bline > 4.7 + 3.0 * sin(time)) ret = vec3(0.85, 0.9, 0.9);\n    if(dir.y > -0.1) ret = vec3(0.75, 0.9, 0.95);\n    \n    float closest_dist = 999999.0;\n    for(int i = 0; i < 30; ++i){\n        point = point + dir * sdf(point, closest_dist);\n    }\n    float dist = 0.1;\n    if(closest_dist < 0.05)\n        ret = vec3(0.0, 0.0, 0.0);\n    color(point, dist, ret);\n    return ret;\n}\n\nvoid set_transforms(){\n    float spine_angle = -0.1;\n    float wiggle = 0.01 * (2.0 / (1.0 + exp(-10.0 * sin(time * 10.0))) - 1.0);\n    float bounce = 0.02 * (2.0 / (1.0 + exp(-10.0 * sin(time * 10.0))) - 1.0);\n    \n    float langle = (0.02 - bounce) * 4.00;\n    \n    float twist = 0.1 * (2.0 / (1.0 + exp(-10.0 * sin(time * 2.5))) - 1.0) + wiggle;\n    float look = 0.4 * (2.0 / (1.0 + exp(-10.0 * sin(time * 2.5))) - 1.0);\n    float arm1 = 0.3 * (2.0 / (1.0 + exp(-10.0 * sin(time * 2.5)))) + wiggle;\n    float arm2 = 0.6 - arm1;\n    float farm1 = 0.6 * (sin(time * 10.0) + 1.0) * smoothstep(-0.1, 0.7, arm1);\n    float farm2 = 0.6 * (sin(time * 10.0) + 1.0) * smoothstep(-0.1, 0.7, arm2);\n    \n    float lt_mag = 0.5;\n    float leg_twist1 = (1.0 / (1.0 + exp(-10.0 * sin(time * 2.5)))) * lt_mag;\n    float leg_twist2 = - leg_twist1;\n    \n    spine_transform =\n        translation_matrix(vec3(0.0, 1.0 + bounce, 0.0)) *\n        rotation_matrix(vec3(1.0, 0.0, 0.0), spine_angle) * \n        rotation_matrix(vec3(0.0, 1.0, 0.0), twist);\n    arm1_transform = \n        translation_matrix(vec3(0.27, 1.0, -0.04)) *\n        rotation_matrix(vec3(0.0, 0.0, 1.0), -2.4 + farm1 * 0.5) *\n        rotation_matrix(vec3(1.0, 0.0, 0.0), arm1);\n    arm2_transform = \n        translation_matrix(vec3(-0.27, 1.0, -0.04)) *\n        rotation_matrix(vec3(0.0, 0.0, 1.0), 2.4 - farm2 * 0.5) *\n        rotation_matrix(vec3(1.0, 0.0, 0.0), arm2);\n    thigh1_transform =\n        translation_matrix(vec3(0.15, 0.0, -0.05)) *\n        rotation_matrix(vec3(0.0, 0.0, 1.0), 3.141592 ) *\n        rotation_matrix(vec3(0.0, 1.0, 0.0), leg_twist1 ) *\n        rotation_matrix(vec3(1.0, 0.0, 0.0), spine_angle + langle);\n    thigh2_transform =\n        translation_matrix(vec3(-0.15, 0.0, -0.05)) *\n        rotation_matrix(vec3(0.0, 0.0, 1.0), 3.141592) *\n        rotation_matrix(vec3(0.0, 1.0, 0.0), leg_twist2 ) *\n        rotation_matrix(vec3(1.0, 0.0, 0.0), spine_angle + langle);\n    forearm1_transform = \n        translation_matrix(vec3(0.0,0.5,0.0)) *\n        rotation_matrix(vec3(1.0, 0.0, 0.0), farm1);\n    forearm2_transform = \n        translation_matrix(vec3(0.0,0.5,0.0)) *\n        rotation_matrix(vec3(1.0, 0.0, 0.0), farm2);\n    calves1_transform =\n        translation_matrix(vec3(0.0,0.7,0.0)) *\n        rotation_matrix(vec3(1.0, 0.0, 0.0), - 2.0 * langle);\n    calves2_transform =\n        translation_matrix(vec3(0.0,0.7,0.0)) *\n        rotation_matrix(vec3(1.0, 0.0, 0.0), - 2.0 * langle);\n    head_transform =\n        translation_matrix(vec3(0.0,1.06,0.1)) *\n        rotation_matrix(vec3(1.0, 0.0, 0.0), -2.0 * spine_angle) *\n        rotation_matrix(vec3(0.0, 1.0, 0.0), -look);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n    \n    set_transforms();\n    compute_inverses();\n    \n    float cam_angle = 3.14 + iTime * 0.5;\n    float coscam = cos(cam_angle);\n    float sincam = sin(cam_angle);\n    \n    float spread = 0.003;\n    vec3 cam_pos = vec3(0.0, 1.2, -3.0);\n    vec3 pixel_pos = vec3( spread * (fragCoord - iResolution.xy / 2.0) / iResolution.y * 450.0, 1.0 );\n    \n    float cx = cam_pos.x * coscam + cam_pos.z * sincam;\n    float cz = - cam_pos.x * sincam + cam_pos.z * coscam;\n    float px = pixel_pos.x * coscam + pixel_pos.z * sincam;\n    float pz = - pixel_pos.x * sincam + pixel_pos.z * coscam;\n    \n    cam_pos.x = cx;\n    cam_pos.z = cz;\n    pixel_pos.x = px;\n    pixel_pos.z = pz;\n    pixel_pos += cam_pos;\n    \n    vec3 ray = normalize(pixel_pos - cam_pos);\n\n    vec3 col = ray_march(cam_pos, ray);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}