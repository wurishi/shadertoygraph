{"ver":"0.1","info":{"id":"mdG3Wy","date":"1679013816","viewed":1769,"name":"Radioactive [466 Chars]","username":"Xor","description":"Experimenting with Ambient Occlusion in a tiny shader!","likes":58,"published":1,"flags":32,"usePreview":1,"tags":["3d","fractal","raymarch","ao","city","golf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    \"Radioactive\" by @XorDev\n\n    Experimenting with Ambient Occlusion in a tiny shader!\n\n    This pass simply outputs the results from buffer A\n    \n    <512 Chars playlist: shadertoy.com/playlist/N3SyzR\n*/\n\nM;\n    //Output iChannel0 texture\n    O = T;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n    \"Radioactive\" by @XorDev\n\n    A little raymarch loop that switches to a random direction after 100 iterations\n    The distance traveled in this direction determines if the pixel is lit or not.\n    This is a simple way of simulates AO in one pass. I use the backbuffer for TAA.\n*/\n\nM,\n    //Transformed vector for fractal\n    v,\n    //Camera position (approximately 0,0,1)\n    p = 1./r,\n    //Camera ray direction (+z forward, +y up)\n    d = vec3(I+I-r.xy, r);\n    \n    //Clear fragColor\n    O *= 0.;\n    \n    //Initialize raymarch step distance, fractal and raymarcher iterators\n    float s, i, l=0.,\n    //Reset timer every 4 seconds\n    t = modf(iTime/4., s);\n    //Rotate pitch down 0.5 radians\n    d.yz *= R-.5));\n    \n    //Scroll camera forward and raymarch loop\n    for(p *= s/.2; l++<2e2; p += d/length(d)*s)\n    //Fractal loop\n    for(v=p, s=v.y, i=7.; i>.001; i*=.5)\n        //Rotate approximately 45 degrees\n        v.xz *= R+.8)),\n        //Subtract cubes SDFs\n        s = max(s,min(min(v=i*.8-abs(mod(v,i+i)-i), v.y).x, v.z)),\n        //After 100 iterations (AO pass) add raymarch bias\n        l>1e2 ? s += 1e-5,\n        //Randomize ray direction for AO \n        d = texture(iChannel1, t*r.xy + I/1e3).rgb-.5,\n        //Add color\n        O.bgr += s * (d+.3)/1e7 : d;\n    \n    //Blend current frame with backbuffer\n    O = mix(T, clamp(O,0.,3.), .1/++t);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//Rotation matrix trick learned from FabriceNeyret2\n#define R mat2(cos(vec4(0,11,33,0)//\n//\n//Shortened main function with resolution\n#define M void mainImage(out vec4 O, vec2 I) {vec3 r = iResolution//\n//\n//Sample texture0 using screen uvs.\n#define T texture(iChannel0,I/r.xy)","name":"Common","description":"","type":"common"}]}