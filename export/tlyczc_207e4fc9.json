{"ver":"0.1","info":{"id":"tlyczc","date":"1612039698","viewed":42,"name":"Berry dancing","username":"fguinier","description":"A mash up of two other shader to get a dancing berry, because why not.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["berry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGzn","filepath":"/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","previewfilepath":"/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//mix of https://www.shadertoy.com/view/ldcGWH\n//and https://www.shadertoy.com/view/Xds3Rr\n\n//from https://iquilezles.org/articles/distfunctions\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdBerry( vec3 p, float s )\n{\n  vec3 centerCone = p + s*vec3(0,0.03,0);\n  float dRoundCone = sdRoundCone( centerCone, s*0.01, s*0.02, s*0.03 );\n  \n  vec3 centerSmallSphere = p + vec3(0.3,0.02,0.1);\n  float invS = 1.0/s;\n  invS = 1.0;//TOFO?\n  float dSpheres = dot(abs(sin(invS*centerSmallSphere*350.0)), vec3(0.001,0.001,0.004));\n  return dRoundCone - dSpheres;\n}\n\n////////\n////////\nfloat berryScale;\nfloat mapExterior(in vec3 p)\n{\n    float d = sdBerry(p, berryScale);\n\treturn d;\n}\n\nvec3 grad(in vec3 p)\n{\n    vec2 off = vec2(0.0001, 0.0);\n    vec3 g = vec3(mapExterior(p + off.xyy) - mapExterior(p - off.xyy),\n                  mapExterior(p + off.yxy) - mapExterior(p - off.yxy),\n                  mapExterior(p + off.yyx) - mapExterior(p - off.yyx));\n    return normalize(g);\n}\n\nfloat trace(in vec3 p, in vec3 d, out vec3 closestPoint)\n{\n    float closest = 99.0;\n    bool hit = false;\n    for (int i = 0; i < 250; ++i)\n    {\n        float dist = mapExterior(p);\n        if (dist < closest)\n        {\n        \tclosest = dist;\n            closestPoint = p;\n        }\n        \n        if(dist < 0.0)\n        {\n            hit = true;\n            break;\n        }\n        p += d * max(dist * 0.5, 0.00001);\n    }\n    return closest;\n}\n\n// (too much) tweakable parameters.\n// falloff control\nconst float density = 8.;\nconst float ss_pow = 3.; \nconst float ss_scatter = 0.4;\nconst float ss_offset = .5;\n\n// color controls\nconst float ss_intensity = 0.5;\nconst float ss_mix = 0.5;\nconst vec4 ss_color = vec4(.75, .05, .12, 0.0);\n\n// determines how deep from surface to start scattering tracing, not something to tweak really.\nconst float surfaceThickness = 0.008;\n\n// Fresnel\nvec4 rimCol = vec4(1.0, 0.8, 0.8, 1.0);\nfloat rimPow = 3.0;\nfloat rimAmount = 2.;\nfloat F = 2.2;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n/**\n* Gets thickness for subsurface scattering calculation. \n* I first offset the ray hit position a bit along opposite of the surface normal \n* to get a starting position inside the volume.\n* From there I step towards the light and calculate distance travelled inside the negative volume of\n* the distance function.\n* \n* Outer loop is for approximating scattering of the light that travels in the volume,\n* I just offset the light direction by some scatter value for each sample.\n*/\nfloat ssThickness(in vec3 raypos, in vec3 lightdir, in vec3 g, in vec3 rd)\n{\n    vec3 startFrom = raypos + (-g * surfaceThickness);\n    vec3 ro = raypos;\n\t\n    float len = 0.0;\n    const float samples = 12.;\n    const float sqs = sqrt(samples);\n    \n    for (float s = -samples / 2.; s < samples / 2.; s+= 1.0)\n    {\n        vec3 rp = startFrom;\n        vec3 ld = lightdir;\n        \n        ld.x += mod(abs(s), sqs) * ss_scatter * sign(s);\n        ld.y += (s / sqs) * ss_scatter;\n        \n        ld.x += rand(rp.xy * s) * ss_scatter;\n        ld.y += rand(rp.yx * s) * ss_scatter;\n        ld.z += rand(rp.zx * s) * ss_scatter;\n\t\t\n        ld = normalize(ld);\n        vec3 dir = ld;\n\t\t\n        for (int i = 0; i < 50; ++i)\n        {\n            float distExterior = mapExterior(rp);\n            if(distExterior < 0.0) distExterior  = min(distExterior, -0.0001);\n            if(distExterior >= 0.0) break;\n\n            dir = normalize(ld);\n            rp += abs(distExterior * 0.5) * dir;  \n        }\n        len += length(ro - rp);\n    }\n    \n    return len / samples;\n}\n\n//from https://www.shadertoy.com/view/Xds3Rr\nvec3 getColorFromSound(in vec2 fragCoord)\n{\n    // create pixel coordinates\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // the sound texture is 512x2\n    int tx = int(uv.x*512.0);\n    \n\t// first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n\tfloat fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n\n    // second row is the sound wave, one texel is one mono sample\n    float wave = texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\n\t\n\t// convert frequency to colors\n\tvec3 col = vec3( fft, 4.0*fft*(1.0-fft), 1.0-fft ) * fft;\n\n    // add wave form on top\t\n\tcol += 1.0 -  smoothstep( 0.0, 0.15, abs(wave - uv.y) );\n\t\n\t// output final color\n\treturn col;\n}\n\nfloat getBerryScaleFromSound()\n{\n    int numFetch = 25;\n    \n    // the sound texture is 512 pixel wide\n    int stepBetweenFetch = 512/numFetch;\n    float sumfftBass = 0.0;\n    for(int i = 0; i <512; i+=stepBetweenFetch)\n    {\n        float fft = texelFetch( iChannel0, ivec2(i,0), 0 ).x; \n        sumfftBass += fft*fft;\n    }\n\n\t// output final color\n\treturn 3.0f * sumfftBass/float(numFetch);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    uv.y /= iResolution.x / iResolution.y;\n    \n    vec2 m = (iMouse.xy / iResolution.xy) - vec2(0.5);\n    \n    berryScale = (m.x);\n    if(iMouse.z <= 0.0)\n    {\n    \tberryScale = sin(iTime * 0.5) * 0.1 + 0.5;\n        berryScale += getBerryScaleFromSound();\n    }\n\n    fragColor = vec4(0.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 rp = vec3(0.0, -0.01, -.3);\n\n    // closest point is used for antialising outline of object\n    vec3 closestPoint = vec3(0.0);\n    float hit = trace(rp, rd, closestPoint);\n    vec4 color = vec4(.0);\n    rp = closestPoint;\n\n    vec3 ld = normalize( vec3(14.0, 1.0, 20.0) - closestPoint);\n    vec3 g = grad(closestPoint);\n    float d = dot(g, ld);\n    d = clamp(d, 0.0, 1.0);\n\n    //fresnel\n    vec3 r = reflect(-ld, g);\n    float rimd = 1.0 - dot(r, -rd);\n    rimd = clamp(rimd, 0.0, 1.0);\n    rimd = pow(rimd, rimPow);\n\n    float frn = rimd + F * (1.0 - rimd);\n    color += frn * rimCol * rimAmount * d;\n\n    // subsurface        \n    float t = ssThickness(rp, ld, g, rd);\n    t = exp(ss_offset -t * density);\n    t = pow(t, ss_pow);\n \n    vec4 sscol = t * ss_color * ss_intensity;\n    sscol = mix(sscol, ss_color, 1.0 - ss_mix);\n    color += sscol;\n\t\n    fragColor = vec4(getColorFromSound(fragCoord), 1.0);\n    // color + AA\n    fragColor = 0.75*mix(color, fragColor, mix(0.0, 1.0, clamp(hit / surfaceThickness * 16.0, 0.0, 1.0)));\n    \n    // vignette\n    fragColor *= smoothstep(0.55, 0.48, abs(uv.x));\n    fragColor *= smoothstep(0.31, 0.27, abs(uv.y));\n}","name":"Image","description":"","type":"image"}]}