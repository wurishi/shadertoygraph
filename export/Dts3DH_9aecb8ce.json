{"ver":"0.1","info":{"id":"Dts3DH","date":"1672144039","viewed":72,"name":"dna_structure","username":"karanbpathak","description":"dna_structure","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","sin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// inspired by : https://iquilezles.org/articles/distfunctions/\n\n// Rotation matrix around the X axis.\n// inspired by https://inspirnathan.com/posts/54-shadertoy-tutorial-part-8/\nmat3 rx(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 ry(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rz(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Identity matrix.\nmat3 iy() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\nfloat sdSphere(in vec3 p, in vec3 c, float r, vec3 offset, mat3 transform)\n{\n    p = (p - offset) * transform;\n    return length(p - c) - r;\n}\nvec3 sdgCircle( in vec3 p, in vec3 c, in float r, vec3 offset, mat3 transform) \n{\n    p = (p - offset) * transform;\n    float d = length(p-c);\n    return vec3( d-r, (p-c)/d );\n}\nvec3 sdgSegment( in vec3 p, in vec3 a, in vec3 b, in float r )\n{\n    vec3 ba = b-a, pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec3  q = pa-h*ba;\n    float d = length(q);\n    return vec3(d-r,q/d);\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nvec3 sdgSmoothMin( in vec3 a, in vec3 b, in float k )\n{\n    float h = max(k-abs(a.x-b.x),0.0);\n    float m = 0.25*h*h/k;\n    float n = 0.50*  h/k;\n    return vec3( min(a.x,  b.x) - m, \n                 mix(a.yz, b.yz, (a.x<b.x)?n:1.0-n) );\n}\nfloat map(in vec3 p)\n{\n\n    vec3 c = vec3(0.1,0.0,0.1);\n    float t = 10.0;\n    float y = p.y;\n    float x = (sin(0.9*y-iTime*0.5));\n    vec3 p1 = vec3(x+0.1, y, 0.0);\n    vec3 p2 = vec3(-x+0.1, y, 0.0);;\n    vec3 c1 = sdgCircle(p, c+vec3(x,y,.0), 0.05, vec3(0.0,0.01,0.0),iy());\n    vec3 c2 = sdgCircle( p, c+vec3(-x,y,0.), 0.05, vec3(0.0,0.01,0.0), iy());\n    vec3 c3 = sdgSmoothMin(c1, c2,0.2); \n    float py = mod(p.y,0.2);\n    \n    if (py > 0.01 && py < 0.07)\n    {\n        //t = sdgSmoothMin(t, sdCapsule(p, p1, p2,0.03),0.2);\n        c3 = sdgSmoothMin(c3,sdgSegment( p, p1, p2, 0.01 ),0.2);\n    }\n    return c3.x;\n}\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.15*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - occ*1.5, 0.0, 1.0 );\n}\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 3\n#endif\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = .7*iTime;\n\tvec3 ro = vec3( 0.2, 0.2, 2.4);\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n    \n    \n    // render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 p;\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            vec3 lig = normalize(vec3(0.6,0.2,0.4));\n            vec3 hal = normalize(lig-rd);\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            float occ = calcOcclusion( pos, nor );\n            if( dif>0.001 ) dif *= calcSoftshadow( pos, lig, 0.01, 1.0 );\n            float spe = pow(clamp(dot(nor,hal),0.0,1.0),16.0)*dif*(0.04+0.96*pow(clamp(1.0-dot(hal,-rd),0.0,1.0),5.0));\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col =  vec3(0.5,1.0-p.y,0.2-p.x)*amb*occ;\n            col += vec3(2.8,2.2,1.8)*dif;\n            \n            col *= 0.2 ;\n            \n            col += vec3(2.8,2.2,1.8)*spe*3.0;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}