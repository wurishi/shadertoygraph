{"ver":"0.1","info":{"id":"Nd2cDD","date":"1643634485","viewed":90,"name":"FPGA shader","username":"6Kotnk","description":"Simple Phong shading designed to be implemented in FPGA.\nAll constant multiplications are bitshifts and sqrt is only used once.\nThe dot product uses a non normalzed vector so we don't have to square add and divide","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fpga"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define QONE pow(2.0, 16.0)\n#define QCBRT2 pow(2.0, 1.0/3.0) * QONE\n#define PtoL pow(2.0, 8.0)\n#define AMB pow(2.0, 28.0)\n#define DOTtoCOL pow(2.0, 32.0)\n\n\n//Shading algorithm designed for FPGA implementation\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //Light position defined in software\n    vec3 Lp = vec3(\n    QCBRT2 * cos(iTime),\n    QCBRT2,\n    QCBRT2 * sin(iTime)\n    );\n                    \n    // Normalized pixel coordinates \n    vec2 uv = 2.0*(fragCoord.xy - 0.5 * iResolution.xy);\n\n    float x2 = uv.x*uv.x;\n    float y2 = uv.y*uv.y;\n    float x2y2 = x2+y2;\n\n    bool inSphere = x2y2 < QONE;\n    //Z coordinate derived from x and y\n    float z = sqrt(QONE-x2y2);\n    //Position on sphere is also normal of sphere\n    vec3 p = vec3(uv.x*PtoL,uv.y*PtoL,z*PtoL);\n    \n    //Lp-p is light direction from sphere surface \n    float dotNL = dot(p,(Lp - p));\n\n    vec3 col = vec3(dotNL,dotNL,dotNL);\n    //Clamp output for ambient lighting\n    vec3 col_clamped = dotNL < (AMB) ? \n    vec3(AMB,AMB,AMB): \n    vec3(dotNL,dotNL,dotNL);\n\n    vec3 fcol = inSphere ? col_clamped/(DOTtoCOL) : vec3(0.0,0.0,0.0);\n\n    // Output to screen\n    fragColor = vec4(fcol,1.0);\n}","name":"Image","description":"","type":"image"}]}