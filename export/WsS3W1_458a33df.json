{"ver":"0.1","info":{"id":"WsS3W1","date":"1548698654","viewed":126,"name":"MCG: fractals","username":"tale3d","description":"In this lecture we discuss fractals. ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["mandelbrot","fractals","teachingmaterial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n//Here goes the main function, which is applied for every pixel in our window\n//It takes the pixel coordinates as an argument\n//And returns the colour of the given pixel.\n//Below we see how we can define our shape by using mathemaica sn code\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //////////////////////////////////////////////////////\n    //Starting the common section\n    //The lines above are the same for most of the examples. \n    //Basically it is a mapping between pixel coordinates and world coordinates.\n    //We discuss coordinates systems soon. \n    //\n    //taking pixel coordinates in the uv space, range [0,1]\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //map pixel coordinates to [-1,1]\n    vec2 c = 2.0 * uv - 1.0;\n    //adjust coordinates given an aspect ratio\n    float aspect_ratio = iResolution.x/iResolution.y;\n    c.x *= aspect_ratio;\n    //\n    //End of the common section\n    ///////////////////////////////////////////////////////\n    \n    //We are going to map pixel coordinates from [-1,1] to \n    //[central point - size, central point + size]\n    //\n    //The size is time-dependent, so graphically we xoom around centre point.\n    //\n    //The central point is pre-defined in the code to be at the \"edge\" of the set.\n    //You can also try some other ones, like \n    //(-0.745, 0.113)\n    //(0.013, 0.655)\n    //(-0.745, 0.186)\n    //(-1.41, 0.0)\n    \n    float centre_x = -1.41;\n    float centre_y = 0.0;\n\n    //Below we define the size of our area\n    //Some explanations: cos(iTime) creates time-dependent oscillations between -1 and 1\n    //1.0-cos maps that wave to [0,2]\n    //pow(0.003, 1.0-cos) create wave between 0.00009 (which is 0.003^2) and 1.0 (0.003^0)\n    //So eventually by using continuous time variable we oscillate between 1 and 0.00009\n    //\n    //You can try to have something smaller than 0.003, but eventually you hit the floating point limit\n    float zooming_ratio = pow(.003,1.-cos(0.2*iTime));\n    \n    //Finally we map from [-1,1] to [centre_x-zoom, centre_x+zoom]\n    //Position px and py are from the given pixel\n    float cx = centre_x + c.x*zooming_ratio;\n    float cy = centre_y + c.y*zooming_ratio;\n    \n    //z_0 = c\n    //I could use vec2 to pack complex number, but we have not discussed vectors yet.\n    //Instead real part and imaginary part have their own variables\n    float z_re = cx;\n    float z_im = cy;\n    \n\tfloat n = 0.; //iteration number\n \n    vec3 colour = vec3(0.0, 0.0, 0.0); //default colour in this shader is black \n\n    //we have 256 iterations maximum\n    for(int i = 0; i < 256; i++)\n    {\n        //z_n+1 = z_n^2 + c\n        //recall that (a+bi)(c+di) = (ac-bd)+(ad+bc)i\n        //therefore z*z = (z_re*z_re - z_im*z_im) + (z_re*z_im + z_re*z_im)i\n\n        //z*z\n        float zn_re = z_re*z_re - z_im*z_im;\n        float zn_im = 2.0*z_re*z_im;\n\n        //z*z+c\n        zn_re += cx;\n        zn_im += cy;\n        \n        n++;\n        \n        //if the modulus of the point greater than 2, the point is not in Mandelbrot set anymore, stop\n        if(sqrt(zn_re*zn_re+zn_im*zn_im)>2.0)\n        {\n            //assign colour to the pixel given the iteration number\n            //f denotes how many \"palettes\" we have\n            float pn = 10.;\n            //use trigonometry to have rather nice set of \n        \tcolour = vec3(sin(n/pn),cos(n/pn),1.0-sin(n/pn));\n            break;\n        }\n        z_re = zn_re;\n        z_im = zn_im;\n    }\n    \n\tfragColor = vec4(colour,1.0);\n\n\n}","name":"Image","description":"","type":"image"}]}