{"ver":"0.1","info":{"id":"4l3XR4","date":"1478430857","viewed":300,"name":"Mandelbrot Shadow (3D Illusion)","username":"ttoinou","description":"Upgrading https://www.shadertoy.com/view/MttXz8 with a fake 3D depth effect.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["mandelbrot","gradient","illusion","distance","depth","distanceestimator"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 color, in vec2 coord )\n{\n    color = texture(iChannel0,coord/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// modified version of\n// https://www.shadertoy.com/view/lsX3W4\n\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define point1 vec2( -0.7662993197885142,-0.10131480816825633 )\n#define point2 vec2( -1.1999581944285553,-0.15347629517767686 )\n\n// -0.9184593889088466,-0.32950143202488796 \n// -1.7838524432262486,-0.015620174557223324 \n\n#define ITERATIONS 1000\n#define BAILOUT    (128.)\n#define BAILOUT2   (BAILOUT*BAILOUT)\n//#define AA_ENABLE   \n#define AA_FLIPQUAD \n#define AA_RADIUS   3\n\n// doesn't feel like it's doing much good\n//#define AA_RANDOM\n// should be 1.\n#define AA_RANDOMRADIUS (1.)\n\n#define PI (3.14159265359)\n\n// https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\n#define HASHSCALE1 .1031\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat smooth_(float x){\n    return 0.5 - 0.5*cos(x*PI);\n}\n\nvec4 mandelbrot( in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    // animation\n    float speed = 0.05;\n    float phase = 0.6;\n    float tz = 0.5 - 0.5*cos(speed*iTime+phase);\n    float tz2 = 0.5 + 0.5*cos(speed*iTime*.5+phase*.5);\n    float zoo = pow( 0.5, 21.* ( 1. - tz ) + 1.5 );\n    float a = iTime/13.;\n    \n\tvec2 c = mix( point1, point2,\n                  smooth_(smooth_(smooth_( tz2 ))) )\n        + p*zoo*mat2(cos(a),sin(a),-sin(a),cos(a));\n\n    // iterate\n    vec2 z  = vec2(0.0);\n    float m2 = 0.0;\n    vec2 dz = vec2(0.0);\n    int iter = 0;\n    for( int i=0; i<ITERATIONS; i++ )\n    {\n        if( m2>BAILOUT2 ) continue;\n\n\t\t// Z' -> 2Â·ZÂ·Z' + 1\n        dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + vec2(1.0,0.0);\n\t\t\t\n        // Z -> ZÂ² + c\t\t\t\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\t\n        m2 = dot(z,z);\n        iter = i;\n    }\n\tfloat d = 0.5*sqrt(dot(z,z)/dot(dz,dz))*log(dot(z,z));\n\tfloat potential = float(iter) - log( log(length(z)) / log(BAILOUT) )/log(2.);\n\t\n    bool inside = iter == ITERATIONS-1;\n    return vec4( inside ? 0. : (d/zoo) , potential , iter , inside );\n    \n}\n\n\n\nvoid mainImage( out vec4 color, in vec2 coord )\n{\n    vec4 i1,i2;\n    \n    #ifdef AA_ENABLE\n        \n        #ifdef AA_FLIPQUAD\n    \t\t// https://www.shadertoy.com/view/MtSGRG\n        \tvec4 i3,i4;\n        \n            bool xOdd = (floor(mod(coord.x,2.0)) == 1.0);\n            bool yOdd = (floor(mod(coord.y,2.0)) == 1.0);\n\n            vec2 a = vec2(xOdd ? 0.25 : -0.25, yOdd ? -0.5  :  0.5 );\n            vec2 b = vec2(xOdd ? 0.5  : -0.5 , yOdd ?  0.25 : -0.25 );\n            vec2 c = a * vec2(-1);\n            vec2 d = b * vec2(-1);\n\n            i1 = mandelbrot(coord.xy + a);\n            i2 = mandelbrot(coord.xy + b);\n            i3 = mandelbrot(coord.xy + c);\n            i4 = mandelbrot(coord.xy + d);\n\n            i1 = (i1 + i2 + i3 + i4)/4.;\n        #else\n\t\t\t// Brutal AA\n            i1 = mandelbrot(coord);\n\n            vec2 pos;\n            float radius = float(AA_RADIUS);\n\n            for( int i = 0 ; i < AA_RADIUS ; i++ ){\n\n                for( int j = 0 ; j < AA_RADIUS ; j++ ){\n\n                    if( i + j > 0 ){\n\n                        #ifdef AA_RANDOM\n                            pos = vec2(i,j);\n\n                            pos = (pos -\n                              hash23(vec3(coord,\n                                  hash13( vec3(pos,iTime) )\n                              ))*AA_RANDOMRADIUS\n                            )/radius;\n\n                        #else\n                            pos = vec2(i,j)/radius;\n                        #endif\n\n                        i2 = mandelbrot(coord+pos);\n                        i1 += i2;\n                        //if( i2.r > i1.r ){ i1 = i2; }\n                    }\n\n                }\n            }\n\n            i1 /= radius*radius;\n\t\t#endif\n    #else\n        i1 = mandelbrot(coord);\n    #endif\n    \n    color = i1;\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define PI (3.14159265359)\n\n\n#define RADIUS_INT (10)\n#define RADIUS\t   (1.5)\n#define RADIUS2    (RADIUS*RADIUS)\n#define RADIUS22   (2.*RADIUS*RADIUS)\n// very important !\n// controls the 3D effect\n#define GRADIENT_RADIUS_COEFF mix(2.,.25,iMouse.x/iResolution.x)\n\n#define LUMWEIGHT    (vec3(0.2126,0.7152,0.0722))\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 hue = smoothstep(2.,1., abs( mod( c.x*6.+vec3(0,4,2), 6.) -3.) );\n    return c.z * mix( vec3(dot(hue,LUMWEIGHT)) , hue , c.y );\n}\n\nvec4 mandelbrot(vec2 coord){\n   return texture(iChannel0,coord/iResolution.xy);\n}\n\nfloat kernel0(int a,int b){\n    return exp(-float(a*a + b*b)/RADIUS22)/RADIUS;\n}\n\nfloat kernel1(int a,int b){\n    return float(a)*exp(-float(a*a + b*b)/(RADIUS22*GRADIENT_RADIUS_COEFF*GRADIENT_RADIUS_COEFF))/RADIUS;\n}\n\n// 2nd derivative \n// https://en.wikipedia.org/wiki/Mexican_hat_wavelet\nfloat kernel2(int a,int b){\n    float k = float(a)/(2.*RADIUS);\n    return ( 1. - k*k )*exp(-float(a*a + b*b)/(RADIUS22*4.));\n}\n\nfloat distMod(float x, float y, float m){\n    float d = mod(x-y,m);\n    return min( abs(d) , abs(m-d) );\n}\n\nvoid mainImage( out vec4 color, in vec2 coord )\n{\n    vec4 col;\n    vec2 pos;\n    \n    vec4 thisMandel = mandelbrot(coord);\n    \n    float sum0 = 0.;\n    float sum1 = 0.;\n    float sum2 = 0.;\n    \n    vec4 mandel = vec4(0.);\n    float colX = 0.;\n    float colY = 0.;\n    float laplacian = 0.;\n    \n    \n    float coeff0,coeff2;\n    float coeff1X,coeff1Y;\n    \n    for( int i = -RADIUS_INT ; i <= RADIUS_INT ; i++ ){\n    \tfor( int j = -RADIUS_INT ; j <= RADIUS_INT ; j++ ){\n            coeff0  = kernel0(i,j);\n            coeff1X = kernel1(i,j);\n        \tcoeff1Y = kernel1(j,i);\n            coeff2  = kernel2(i,j);\n            \n            sum0 += coeff0;\n            sum2 += abs(coeff2);\n            sum1 += abs(coeff1X);\n            \n            col = clamp(mandelbrot(coord.xy+vec2(i,j)),0.,1.);\n            mandel += coeff0*col;\n            colX += coeff1X*col.r;\n            colY += coeff1Y*col.r;\n            laplacian += coeff2*col.r;\n        }\n        \n    }\n    \n    mandel /= sum0;\n    //laplacian *= sqrt(iResolution.y)*8./sum2;\n    \n    //if( mandel.r < 1e-3 ){ color = vec4(0.); return;}\n    \n    float logDist = log(mandel.r);\n    float magn = sqrt(colX*colX + colY*colY)*iResolution.y/(sum1*sqrt(GRADIENT_RADIUS_COEFF));\n    float spikes = pow(magn*0.18,1.4)*1.5;\n    \n    float sqrtMagn = sqrt(magn);\n    float angle = atan(colY,colX)/PI*0.5+0.5;\n    float showAngle = + iTime*2.;\n    \n    float valleys = pow( clamp( 1. - mandel.r*5. , 0. , 1. ) , 1. );// pow(max(1.2 - laplacian*8.,0.),1.75)+.4;\n    //valleys = 1.;\n    \n    float distAngle = distMod(angle,showAngle,1.);\n    // this coeff is interesting !\n    float angleCoeff = mix(4.,2.,iMouse.y/iResolution.y);\n    \n    float angleMap = clamp(1. - distAngle*angleCoeff,0.,1.);\n    \n    float angleEffect = pow(1.-smoothstep(0.,1.,log(mandel.r*128.)),2.);\n    angleMap = mix(0.,angleMap,angleEffect);\n    \n    float angleMap1 = clamp(1. - distMod(angle,showAngle+0./7.,1.)*2.,0.,1.);\n    float angleMap2 = clamp(1. - distMod(angle,showAngle/2.+1./7.,1.)*3.,0.,1.);\n    float angleMap3 = clamp(1. - distMod(angle,showAngle/3.+2./7.,1.)*5.,0.,1.);\n    \n      /*  \n    color = vec4(angleMap1,angleMap2,angleMap3,1.); \n    color = mix(color,vec4(1.),  pow(magn,1.6)*1.6 );return;\n    */\n    //color = vec4(angleEffect); return;;\n    //color = vec4(valleys); return;\n    //color = vec4(logDist*.5+2.*angle); return;\n    \n    color.rgb = hsl2rgb(vec3(\n        logDist*.5,//logDist*0.8 - iTime/1.5,\n        valleys,\n        smoothstep(0.,1.,pow(magn,.1))\n    ));\n\n    color.rgb *= mix(vec3(1.),angleMap*vec3(0.9,0.5,0.1),angleEffect);\n    //color.rgb = mix(color.rgb,vec3(0.8,0.4,0.),angleEffect*angleMap);\n    \n    \n    color = mix(clamp(color,0.,1.),vec4(1.),  spikes );\n    \n    vec4 previous = texture(iChannel1,coord/iResolution.xy);\n    color = mix(color,previous,0.5);\n    color = clamp(color,0.,1.);\n}\n\n/*\n\n#define PI (3.14159265359)\n\n\n#define RADIUS_INT (10)\n#define RADIUS\t   (1.5)\n#define RADIUS2    (RADIUS*RADIUS)\n#define RADIUS22   (2.*RADIUS*RADIUS)\n\n// https://www.shadertoy.com/view/MsS3Wc\n// HSV to RGB conversion \nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec4 mandelbrot(vec2 coord){\n   return texture(iChannel0,coord/iResolution.xy);\n}\n\nfloat kernel0(int a,int b){\n    return exp(-float(a*a + b*b)/RADIUS22)/RADIUS;\n}\n\nfloat kernel1(int a,int b){\n    return float(a)*exp(-float(a*a + b*b)/(RADIUS22*9.))/RADIUS;\n}\n\n// 2nd derivative \n// https://en.wikipedia.org/wiki/Mexican_hat_wavelet\nfloat kernel2(int a,int b){\n    float k = float(a)/(2.*RADIUS);\n    return ( 1. - k*k )*exp(-float(a*a + b*b)/(RADIUS22*4.));\n}\n\nfloat distMod(float x, float y, float m){\n    float d = mod(x-y,m);\n    return min( abs(d) , abs(m-d) );\n}\n\nvoid mainImage( out vec4 color, in vec2 coord )\n{\n    vec4 col;\n    vec2 pos;\n    \n    vec4 thisMandel = mandelbrot(coord);\n    \n    float sum0 = 0.;\n    float sum1 = 0.;\n    float sum2 = 0.;\n    \n    vec4 mandel;\n    float colX = 0.;\n    float colY = 0.;\n    float laplacian = 0.;\n    \n    \n    float coeff0,coeff2;\n    float coeff1X,coeff1Y;\n    \n    for( int i = -RADIUS_INT ; i <= RADIUS_INT ; i++ ){\n    \tfor( int j = -RADIUS_INT ; j <= RADIUS_INT ; j++ ){\n            coeff0  = kernel0(i,j);\n            coeff1X = kernel1(i,j);\n        \tcoeff1Y = kernel1(j,i);\n            coeff2  = kernel2(i,j);\n            \n            sum0 += coeff0;\n            sum2 += abs(coeff2);\n            sum1 += abs(coeff1X);\n            \n            col = mandelbrot(coord.xy+vec2(i,j));\n            mandel += coeff0*col;\n            colX += coeff1X*col.r;\n            colY += coeff1Y*col.r;\n            laplacian += coeff2*col.r;\n        }\n        \n    }\n    \n    //colX /= RADIUS2;\n    //colY /= RADIUS2;\n    \n    colX /= sum1;\n    colY /= sum1;\n    \n    mandel /= sum0;\n    laplacian *= iResolution.y/sum2;\n    \n    \n    //color = vec4(mandel.r*2.); return;\n    //color = vec4(sqrt(mandel.r)); return;\n    \n    float logDist = log(mandel.r);\n    float magn = sqrt(colX*colX + colY*colY)*iResolution.y/16.;\n    float sqrtMagn = sqrt(magn);\n    float angle = atan(colY,colX)/PI*0.5+0.5;\n    float showAngle = + iTime*2.;\n    \n    // removing colors\n    // in valleys where angle\n    // changes brutally\n    float valleys = magn/(laplacian*.2);\n    //valleys -= smoothstep( 0. , 1. , fwidth(valleys) );\n    //valleys = 1.;\n    \n    float distAngle = distMod(angle,showAngle,1.);\n    float angleCoeff = iMouse.z > .5 ? \n                         iMouse.x/iResolution.y\n        \t\t\t    : mix(1.5,4.,cos(iTime/2.)*.5+.5 );\n    \n    float angleMap = clamp(1. - distAngle*angleCoeff,0.,1.);\n    float angleMap2 = clamp(1. - distAngle*2.,0.,1.);\n    float darkCoeff = 1e4;\n    \n    \n    float saturation = clamp(valleys*angleMap2,0.,1.5);\n        \n    color = vec4(valleys); return;\n    \n    color.rgb = hsv2rgb_smooth(vec3(\n        logDist*.5+2.*angle,//logDist*0.8 - iTime/1.5,\n        saturation,\n        pow( (1. - exp(-magn/darkCoeff))/(1. - exp(-1./darkCoeff)) , 0.4 - angleCoeff/4.*0.2 )\n    ));\n\n    //color.rgb *= clamp(angleMap+laplacian,0.,1.);\n    \n    \n    \n    // lightning impact on spikes\n    // = high duaddy hubbard potential\n    // (like radio antennas ?)\n    //color = mix(color,vec4(1.),  pow(magn,1.3)*1.3 );\n    \n    \n    vec4 previous = texture(iChannel1,coord/iResolution.xy);\n    //color = mix(color,previous,0.2);\n    \n    // dead pixels removal\n    color = (clamp(color,0.,1.));\n}\n*/","name":"Buf B","description":"","type":"buffer"}]}