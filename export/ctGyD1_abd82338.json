{"ver":"0.1","info":{"id":"ctGyD1","date":"1700150209","viewed":59,"name":"Analytic noise ray integral","username":"OscarSaharoy","description":"This type of noise has a closed form expression for line integrals along straight rays through it. So it could be useful for faster volumetric lighting. I think it can be improved with some tweaking to get different textures","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["noise","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// ===== noise =====\n// unused functions, just for reference\n\n\n// vertices of 3 tetrahedra slightly rotated from each other\nvec3 d[12] = vec3[12](\n    vec3(0.076, -0.785, 0.615),\n    vec3(0.625, 0.77, -0.131),\n    vec3(-0.741, 0.512, 0.434),\n    vec3(0.035, -0.411, -0.911),\n    vec3(0.642, 0.458, 0.615),\n    vec3(0.339, 0.236, -0.911),\n    vec3(-0.979, 0.156, -0.131),\n    vec3(-0.0729, -0.898, 0.434),\n    vec3(-0.718, 0.327, 0.615),\n    vec3(0.814, 0.386, 0.434),\n    vec3(-0.374, 0.175, -0.911),\n    vec3(0.354, -0.926, -0.131)\n);\n\n// noise basis function\nfloat b( vec3 p, vec3 d ) {\n    return sin(dot(d, p));\n}\n\n// sum of noise basis function for the directions in d[] -\n// waves going off in different directions like a porcupine\nfloat pine( in vec3 p ) {\n    float r = 0.;\n    for( int i = 0; i < 12; ++i )\n        r += b(p, d[i]);\n    return r / 12. + .5;\n}\n\n// sum of rotated and scaled versions of above function\nfloat fbm( in vec3 p ) {\n    p -= vec3(0,0,iTime/3.); // scroll up with time\n    p *= 8.; // increase frequency\n\n    float r = 0.;\n    int i = 0;\n    for( float f = 1.; f < 10.; f *= 2. ) {\n        p = rotateAngleAxis( p, pi/6., d[i++] );\n        r += 1. / f * pine( p * f );\n    }\n    return r * .5;\n}\n\n// ===== line integral of noise =====\n// these functions are used\n\n\nfloat ib( vec3 ro, vec3 rd, float l, vec3 d ) {\n    return\n        1. / dot(rd, d) *\n        ( cos(dot(ro,d)) - cos(dot(ro,d) + l*dot(rd,d)) );\n}\n\nfloat ipine( vec3 ro, vec3 rd, float l ) {\n    float r = 0.;\n    for( int i = 0; i < 12; ++i )\n        r += ib( ro, rd, l, d[i] );\n    return r / 12. + .5*l;\n}\n\nfloat ifbm( vec3 ro, vec3 rd, float l ) {\n    ro -= vec3(0,0,iTime/3.);\n    ro *= 8.;\n    float r = 0.;\n    int i = 0;\n    for( float f = 1.; f < 10.; f *= 2. ) {\n        ro = rotateAngleAxis( ro, pi/6., d[i] );\n        rd = rotateAngleAxis( rd, pi/6., d[i++] );\n        r += 1. / (f*f) * ipine( ro * f, rd, l*f );\n    }\n    return r;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // ===== camera =====\n\n    vec3 viewPos =\n        getViewPos(iMouse, iTime, iResolution.xyy);\n    vec3 viewDir =\n        getViewDir(fragCoord, viewPos, iResolution.xyy);\n\n    // ===== lighting =====\n\n    vec3 sunPos = vec3( 2.-sin(iTime/3.), 0, 2.+sin(iTime) );\n    vec3 light = vec3(0);\n    vec3 planeLight = vec3(0);\n\n\n    // calculate light hitting ground plane\n\n    vec4 planeIntersect = intersectPlane(\n        viewPos, viewDir, vec3(0,0,1), -2.\n    );\n    if( planeIntersect.w != 0. ) {\n    \n        vec3 toSun =\n            normalize( sunPos - planeIntersect.xyz );\n        vec4 sphereIntersect = intersectSphere(\n            planeIntersect.xyz, toSun, vec3(0), 1.\n        );\n        float shadow = 1.;\n        if(sphereIntersect.w != 0.)\n            shadow *= exp( -ifbm(\n                sphereIntersect.xyz, toSun, sphereIntersect.w\n            ) );\n\n        planeLight += 1.5 * shadow / pow(distance(\n            planeIntersect.xyz, sunPos ), 1.\n        );\n    }\n\n\n    // calculate extinction through noise sphere\n\n    vec4 sphereIntersect = intersectSphere(\n        viewPos, viewDir, vec3(0), 1.\n    );\n    if( sphereIntersect.w != 0. ) {\n        float opticalDepth = ifbm(\n            sphereIntersect.xyz, viewDir, sphereIntersect.w\n        );\n        float transmittance = exp( -opticalDepth );\n        planeLight *= transmittance;\n    }\n\n\n    // add light from plane\n    light += planeLight;\n\n    // add a naive sun glow\n    light += sunGlow( viewPos, viewDir, sunPos );\n\n\n    // ===== display =====\n\n    // tonemap\n    light = 1. - exp( -light );\n\n    // gamma correction\n    light = pow( light, vec3(0.4545) );\n\n    fragColor = vec4( light, 1 );\n}\n\n/* noise explorer\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 p = vec3(fragCoord / iResolution.x, 0.);\n    p -= vec3( .5, .5 * iResolution.y / iResolution.x, 0 );\n    p *= 20.;\n    p = rotateAngleAxis( p, iTime/10., vec3(0,1,0) );\n\n    float i = uv.y > .7\n        ? uv.x > .5\n            ? pine(p*vec3(20,20,6))\n            : pine(p*6.)\n        : fbm(p);\n    fragColor = vec4(vec3(i),1.0);\n}\n*/","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define pi 3.14159265359\n\nvec3 rotateAngleAxis(vec3 p, float an, vec3 ax) {\n    float aligned = dot(p, ax);\n    vec3 perp = p - ax * aligned;\n    vec3 perp2 = cross(ax,perp);\n    return ax * aligned\n        + perp * cos(an)\n        + perp2 * sin(an);\n}\n\nvec3 getViewPos(\n    vec4 iMouse, float iTime, vec3 iResolution\n) {\n\n    float dist = 5.;\n    vec2 mouse = (iMouse.xy - iResolution.xy/2.)\n        / min(iResolution.x, iResolution.y) * 3.;\n    vec3 rotation;\n    if( iMouse.xy == vec2(0) ) mouse = vec2(0);\n    mouse.y = min(-0.25, mouse.y);\n    if( iMouse.z <= 0. )\n        rotation = vec3(\n            sin(iTime*0.25)*cos(mouse.y),\n            cos(iTime*0.25)*cos(mouse.y),\n            -sin(mouse.y)\n        );\n    else\n        rotation = vec3(\n            cos(mouse.x)*cos(mouse.y),\n            sin(mouse.x)*cos(mouse.y),\n            -sin(mouse.y)\n        );\n    return dist * rotation;\n}\n\nvec3 getViewDir(\n    vec2 fragCoord, vec3 viewPos, vec3 iResolution\n) {\n\n    vec3 toward = normalize( -viewPos );\n    vec3 up = vec3( 0, 0, 1 );\n    vec3 right = normalize( cross( toward, up ) );\n    vec3 over = cross( right, toward );\n\n    vec2 uv = (fragCoord - iResolution.xy/2.)\n        / min(iResolution.x, iResolution.y);\n\n    return normalize(\n        0.75 * toward\n        + uv.x * right\n        + uv.y * over\n    );\n}\n\nvec4 intersectSphere(\n    vec3 rayOrigin, vec3 rayDir,\n    vec3 sphereCentre, float sphereRadius\n) {\n\n    vec3 ro = rayOrigin;\n    vec3 rd = rayDir;\n    vec3 c  = sphereCentre;\n    float R = sphereRadius;\n\n    vec4 result = vec4(0.0);\n\n    vec3 ro2c = c - ro;\n    float distToClosest = dot(rd, ro2c);\n    vec3 closestPoint = ro + rd * distToClosest;\n    float centreToClosest = length(\n        closestPoint - sphereCentre\n    );\n\n    if( distToClosest > 0. )\n        result.xyz = closestPoint;\n\n    if( centreToClosest > R )\n        return result;\n\n    float closestToIntersect = sqrt(\n        R*R - centreToClosest*centreToClosest\n    );\n    float distToSphere = distToClosest - closestToIntersect;\n    float distThroughSphere =\n        closestToIntersect * 2. + min(0., distToSphere);\n\n    if( distThroughSphere < 0. )\n        return result;\n\n    vec3 intersect =\n        rayOrigin + max(0., distToSphere) * rayDir;\n\n    result.xyz = intersect;\n    result.w = distThroughSphere;\n\n    return result;\n}\n\nvec4 intersectPlane(\n    vec3 rayOrigin, vec3 rayDir,\n    vec3 planeNormal, float planeOffset\n) {\n\n    vec3 ro = rayOrigin;\n    vec3 rd = rayDir;\n    vec3 N  = planeNormal;\n    float o = planeOffset;\n\n    vec4 result = vec4(0);\n\n    vec3 toPlane = N * (dot( ro, -N ) + o);\n\n    bool belowPlane = dot( toPlane, N ) > 0.;\n    bool noIntersection = dot( -N, rd ) < 0.;\n\n    if ( belowPlane || noIntersection )\n        return result;\n\n    float distToPlane = length( toPlane ) / dot( -N, rd );\n    vec3 intersectionPoint = ro + rd * distToPlane;\n\n    return vec4( intersectionPoint, distToPlane );\n}\n\nvec3 sunGlow( vec3 rayOrigin, vec3 rayDir, vec3 sunPos ) {\n\n    float closestDistToSun = distance(\n        intersectSphere( rayOrigin, rayDir, sunPos, 0.05 ).xyz,\n        sunPos\n    ) - 0.049;\n\n    return vec3( .07 / closestDistToSun );\n}","name":"Common","description":"","type":"common"}]}