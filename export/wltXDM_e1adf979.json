{"ver":"0.1","info":{"id":"wltXDM","date":"1581131206","viewed":214,"name":"Raytracing Test v1","username":"Xaymar","description":"This is actual Ray Tracing with no acceleration, purely in a pixel shader. Very slow, not recommended.\n\nControls:\n- WS/AD/QE: Move\n- Space + Mouse LMB: Turn\n- Shift/Alt: Speed Up/Down","likes":1,"published":3,"flags":48,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Known Bugs:\n// - Box Side detection is just straight up broken.\n//   - Box UVs as a result of that are also broken.\n//   - Both are likely a result of not calulating things in local space.\n// - Shapes have floating point accuracy errors near edges where the GPU optimized \n//     one part of the texel group to have \"hit\" while the rest did not. No known\n//     solutions.\n// - This is incredibly wasteful, why are you looking at this? Look at more talented\n//     people doing this with ray marching in less than the processing power than\n//     this takes.\n//\n// Known \"Solutions\":\n// - This can be made drastically faster by resolving geometry in a rasterization step, and only doing raytracing when needed.\n//   - Prevents the use of Fisheye cameras - but who needs those?\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// ----------------------------------------------------------------------------\n// Math\n// ----------------------------------------------------------------------------\nbool solve_quadratic(float a, float b, float c, out float x0, out float x1) \n{ \n\tfloat discr = b * b - 4. * a * c; \n\tif (discr < 0.) {\n\t\treturn false; \n\t} else if (discr == 0.) {\n\t\tx0 = x1 = - 0.5 * b / a; \n\t} else { \n\t\tfloat q = (b > 0.) ? \n\t\t-0.5 * (b + sqrt(discr)) : \n\t\t-0.5 * (b - sqrt(discr)); \n\t\tx0 = q / a; \n\t\tx1 = c / q; \n\t} \n\n\tif (x0 > x1) {\n\t\tfloat tmp = x1;\n\t\tx1 = x0;\n\t\tx0 = tmp;\n\t}\n\n\treturn true; \n}\n\n\n// ----------------------------------------------------------------------------\n// Line <-> X Intersection\n// ----------------------------------------------------------------------------\n\nbool intersect_line_aabb(float3 aabb_min, float3 aabb_max, float3 line, float3 inv_dir,\n                            out float2 depth) {\n    float tx1 = (aabb_min.x - line.x) * inv_dir.x;\n    float tx2 = (aabb_max.x - line.x) * inv_dir.x;\n    float ty1 = (aabb_min.y - line.y) * inv_dir.y;\n    float ty2 = (aabb_max.y - line.y) * inv_dir.y;\n    float tz1 = (aabb_min.z - line.z) * inv_dir.z;\n    float tz2 = (aabb_max.z - line.z) * inv_dir.z;\n \n    float tmin = min(tx1, tx2);\n    float tmax = max(tx1, tx2); \n    tmin = max(tmin, min(ty1, ty2));\n    tmax = min(tmax, max(ty1, ty2));\n    tmin = max(tmin, min(tz1, tz2));\n    tmax = min(tmax, max(tz1, tz2));\n    \n    depth = float2(tmin, tmax);\n\treturn (tmax >= tmin) && (tmin > 0.);\n}\n\nbool intersect_line_sphere(float3 pos, float3 rot, float radius, \n                           float3 line, float3 dir, out float2 depth) {\n    // OPTIMIZATION: Is a Line-AABB test cheaper to do than the full solving?\n    // if (!intersect_line_aabb(ray, 1.0 / ray_dir, -radius.xxx, radius.xxx)) return false;\n    \n\tfloat t0, t1; // solutions for t if the ray intersects \n\tfloat radius2 = radius * radius;\n\n\t// analytic solution\n\tfloat3 L = line - pos; \n\tfloat a = dot(dir, dir); \n\tfloat b = 2. * dot(dir, L); \n\tfloat c = dot(L, L) - radius2; \n\n\tif (!solve_quadratic(a, b, c, t0, t1)) {\n        depth = float2(0., 0.);\n        return false;\n\t}\n\n\tif (t0 > t1) {\n\t\tfloat tmp = t0;\n\t\tt0 = t1;\n\t\tt1 = tmp;\n\t}\n\n\tif (t0 < 0.) { \n\t\tt0 = t1; // if t0 is negative, let's use t1 instead \n\t\tif (t0 < 0.) {\n            depth = float2(0., 0.);\n\t\t\treturn false; // both t0 and t1 are negative\n\t\t}\n\t} \n\n\tdepth = float2(t0, t1);\n    return true;\n}\n\nfloat3 normal_to_side_normal(float3 normal) {\n    float3 absnm = abs(normal);\n    float x_sc = (absnm.x - absnm.y) + (absnm.x - absnm.z);\n    float y_sc = (absnm.y - absnm.x) + (absnm.y - absnm.z);\n    float z_sc = (absnm.z - absnm.x) + (absnm.z - absnm.y);\n\n    if ((x_sc > y_sc) && (x_sc > z_sc)) {\n        return float3(1., 0., 0.) * sign(normal);\n    } else if ((y_sc > x_sc) && (y_sc > z_sc)) {\n        return float3(0., 1., 0.) * sign(normal);\n    } else {\n        return float3(0., 0., 1.) * sign(normal);\n    }\n}\n\nfloat3 normal_to_side_and_normal(float3 normal, out int side) {\n    float3 norm = normal_to_side_normal(normal);\n    float3 anorm = abs(norm);\n    if (anorm.x > 0.) {\n        if (sign(norm.x) > 0.) {\n            side = SIDE_RIGHT;\n        } else {\n            side = SIDE_LEFT;\n        }\n    } else if (anorm.y > 0.) {\n        if (sign(norm.y) > 0.) {\n            side = SIDE_UP;\n        } else {\n            side = SIDE_DOWN;\n        }        \n    } else {\n        if (sign(norm.z) > 0.) {\n            side = SIDE_FRONT;\n        } else {\n            side = SIDE_BACK;\n        }        \n    }\n    \n    return norm;\n}\n\n\n// ----------------------------------------------------------------------------\n// Raytracing\n// ----------------------------------------------------------------------------\n\n// Material Info (PBR?)\n// - Color\n// - Normal\n// - Specular\n// - Roughness\n// - Metallic\n// - Emissive Color\n// - Translucency?\n// - Index of Refraction\n\nstruct material_data {\n    float3 color; // Unlit Color\n    float3 emissive; // Emissive Color\n    float3 normal; // World Normal\n    float3 spec_rough_metal; // Specular, Roughness, Metalness\n    float opacity;\n    float index_of_refraction;\n};\n\nvoid material_initialize(out material_data mat) {\n    mat.color = float3(0., 0., 0.);\n    mat.emissive = float3(0., 0., 0.);\n    mat.spec_rough_metal = float3(.5, 1., 0.);\n    mat.normal = float3(0., 0., 1.);\n    mat.opacity = 0.;\n    mat.index_of_refraction = 1.;    \n}\n\nstruct ray_hit_data {\n    bool hit;\n    int id;\n    \n    material_data material;\n    \n};\n\nstruct ray_data {\n    // Ray Information\n    float3 pos;\n    float3 dir;\n    float3 inv_dir;\n    float depth;\n    int id_filter;\n    \n    // Hit Information\n    bool hit;\n    int hit_id;\n    float3 hit_normal;\n    float3 hit_pos;\n    float3 hit_uvw;\n    \n    //ray_hit_data bounces[MAX_BOUNCES];\n    //ray_hit_data refractions[MAX_BOUNCES];\n};\n    \nvoid ray_initialize(float2 uv, out ray_data ray) {\n    float aspect = float(iResolution.x) / float(iResolution.y);\n    \n    float3 camera_position = read_camera_position(iChannel3);\n    \n    float3 r_camera = read_camera_rotation(iChannel3);\n    float3x3 m_camera =        \n        axisang_to_float3x3(float3(1.0, 0.0, 0.0), r_camera.x)\n    \t* axisang_to_float3x3(float3(0.0, 1.0, 0.0), r_camera.y)\n    \t* axisang_to_float3x3(float3(0.0, 0.0, 1.0), r_camera.z);\n    float2 suv = (uv * 2.) - 1.;\n    \n    #ifdef CAM_FISHEYE\n    // Fisheye - Curved surface that extends outwards.    \n    float2 view_uv = suv * .5 * camera_fieldofview;\n    float3x3 mview = \n        axisang_to_float3x3(float3(1.0, 0.0, 0.0), -view_uv.y / aspect)\n    \t* axisang_to_float3x3(float3(0.0, 1.0, 0.0), view_uv.x);\n    \n    ray.dir = float3(0., 0., 1.) * mview * m_camera;    \n    ray.pos = camera_position + ray.dir * camera_range.x;\n    #else\n    #ifdef CAM_PERSPECTIVE\n    // Perspective - Flat plane that extends outwards, but respects field of view.\n    \n    // This is interesting to create, as it is actually different to a real camera.\n    // First we calculate the two offsets for the far plane (+X and +Y),\n    // then using these offset we interpolate an actual direction,\n    // which is also used to give the offset to the camera position.\n    // In a sense, perspective isn't truly perspective, but it is closest to what our brain thinks we see.\n    \n    float3 forward = float3(0., 0., 1.);\n    float half_fov = camera_fieldofview * .5;\n    \n    float3x3 m_down = axisang_to_float3x3(float3(-1., 0., 0.), half_fov / aspect);\n    float3x3 m_up = axisang_to_float3x3(float3(1., 0., 0.), half_fov / aspect);\n    float3x3 m_right = axisang_to_float3x3(float3(0., 1., 0.), half_fov);\n    float3x3 m_left = axisang_to_float3x3(float3(0., -1., 0.), half_fov);\n    \n    float3 tl = forward * m_up * m_left;\n    float3 tr = forward * m_up * m_right;\n    float3 bl = forward * m_down * m_left;\n    float3 br = forward * m_down * m_right;\n    \n    ray.dir = lerp(lerp(tl, tr, uv.x), lerp(bl, br, uv.x), uv.y) * m_camera;\n    ray.pos = camera_position;// + (dir * camera_range.x);\n    #else\n    // Orthographic - Flat plane that extends outwards, field of view is used as scale.    \n    ray.dir = float3(0., 0., 1.) * m_camera;\n    ray.pos = camera_position \n        + (float3(suv.x * aspect, suv.y, camera_range.x) * camera_size) * m_camera;    \n    #endif\n    #endif\n    \n    // Ray Data\n    ray.pos = ray.pos;\n    ray.dir = ray.dir;\n    ray.inv_dir = 1. / ray.dir;\n    ray.depth = LARGE_VALUE;\n    ray.id_filter = 0;\n    \n    // Hit\n    ray.hit = false;\n    ray.hit_id = 0;\n    ray.hit_pos = float3(0., 0., 0.);\n    ray.hit_normal = float3(0., 0., 1.);\n    ray.hit_uvw = float3(0., 0., 0.);\n}\n\nvoid ray_initialize_reflect(in ray_data ray_orig, out ray_data ray_new) {    \n    // Ray Data\n    ray_new.dir = reflect(ray_orig.dir, ray_orig.hit_normal);\n    ray_new.pos = ray_orig.hit_pos;// + ray_new.dir * RAY_ERROR_MARGIN;\n    ray_new.inv_dir = 1. / ray_orig.dir;\n    ray_new.depth = LARGE_VALUE;\n    ray_new.id_filter = ray_orig.hit_id;\n    \n    // Hit\n    ray_new.hit = false;\n    ray_new.hit_id = 0;\n    ray_new.hit_pos = float3(0., 0., 0.);\n    ray_new.hit_normal = float3(0., 0., 1.);\n    ray_new.hit_uvw = float3(0., 0., 0.);\n}\n\nbool ray_test_box(inout ray_data ray,\n                  in float3 position, in float3 rotation, in float3 size) {\n    // Steps to actually get an intersection:\n    // 1. Turn everything so that the box is aligned.\n    // 2. Do the ray test with the box.\n    // 3. ???\n    // 4. Profit.\n    \n    float3x3 mrot = axisang_to_float3x3(float3(1.0, 0.0, 0.0), rotation.x);\n    mrot *= axisang_to_float3x3(float3(0.0, 1.0, 0.0), rotation.y);\n    mrot *= axisang_to_float3x3(float3(0.0, 0.0, 1.0), rotation.z);\n    \n    float3 vray = (ray.pos - position) * mrot;\n    float3 vray_dir_inv = 1.0 / (ray.dir * mrot);\n    float3 aabb = size;\n    float2 depth = float2(ray.depth, ray.depth);\n    if (intersect_line_aabb(-aabb, +aabb, vray, vray_dir_inv, depth) && (min(depth.x, depth.y) < ray.depth)) {\n        ray.depth = min(depth.x, depth.y);\n        \n        ray.hit = true;\n        ray.hit_pos = ray.dir * ray.depth + ray.pos;\n\n        int side;\n        float3 rel_pos = (ray.hit_pos - position) / size;\n        ray.hit_normal = normal_to_side_and_normal(rel_pos, side);\n        \n        if (side == SIDE_LEFT) {\n            ray.hit_uvw = float3(rel_pos.zy * float2(-1., 1.), 1.);\n        } else if (side == SIDE_FRONT) {\n            ray.hit_uvw = float3(rel_pos.xy * float2(-1., 1.), 1.);\n        } else if (side == SIDE_RIGHT) {\n            ray.hit_uvw = float3(rel_pos.zy * float2(1., 1.), 1.);\n        } else if (side == SIDE_BACK) {\n            ray.hit_uvw = float3(rel_pos.xy * float2(1., 1.), 1.);\n        } else if (side == SIDE_UP) {\n            ray.hit_uvw = float3(rel_pos.xz * float2(1., 1.), 1.);\n        } else if (side == SIDE_DOWN) {\n            ray.hit_uvw = float3(rel_pos.xz * float2(1., 1.), 1.);\n        }\n        ray.hit_uvw *= .5;\n        ray.hit_uvw += .5;\n        \n        return true;\n    } else {\n        return false;\n    }\n}\n\nbool ray_test_cube(inout ray_data ray,\n                  in float3 position, in float3 rotation, in float size) {\n    return ray_test_box(ray, position, rotation, float3(size));\n}\n\nbool ray_test_sphere(inout ray_data ray,\n                     in float3 position, in float3 rotation, in float size) {\n    return false;\n}\n\n#define SCENE_MIRROR_0 1000\n#define SCENE_MIRROR_1 1001\n#define SCENE_CUBE_1 2001\n\nvoid scene(inout ray_data ray, out bool bounced) {\n    if ((ray.id_filter != SCENE_MIRROR_0) && ray_test_box(ray, float3(0., 0., -100.), float3(0., 0., 0.), float3(LARGE_VALUE, LARGE_VALUE, .01))) {\n        ray.hit_id = SCENE_MIRROR_0;\n        ray.hit_normal = normalize(ray.hit_normal\n                                   + float3(\n                                       (texture(iChannel2, ray.hit_uvw.xy * LARGE_VALUE / 16.).yx - .5) * .1,\n                                       .01)\n                                  );\n    }\n    if ((ray.id_filter != SCENE_MIRROR_1) && ray_test_box(ray, float3(0., 10., 0.), float3(0., iTime, iTime * 2.), float3(1., 10., 10.))) {\n        ray.hit_id = SCENE_MIRROR_1;\n        ray.hit_normal = normalize(ray.hit_normal\n                                   + float3(\n                                       (texture(iChannel1, ray.hit_uvw.xy * 2.).yx - .5) * .1,\n                                       .01)\n                                  );\n    }\n    if ((ray.id_filter != SCENE_CUBE_1) && ray_test_box(ray, float3(0., 0, 0.), float3(cos(iTime), 0., 0.), float3(50., 1., 50.))) {\n        ray.hit_id = SCENE_CUBE_1;\n        \n    }\n    \n    bounced = false;\n    switch (ray.hit_id) {\n        case SCENE_MIRROR_0:\n        case SCENE_MIRROR_1:\n            ray_data ref_ray;\n            ray_initialize_reflect(ray, ref_ray);\n        \tray = ref_ray;\n        \tbounced = true;\n        \tbreak;\n    }\n}\n\nfloat4 solve(float2 uv) {\n    // Initialize Ray\n    ray_data ray;    \n    ray_initialize(uv, ray);\n    \n    // Raytracing requires additional solving.\n    for (int bounce = 0; bounce < MAX_BOUNCES; bounce++) {\n    \tbool bounced = false;\n        scene(ray, bounced);\n        \n        if (!bounced)\n            break;\n    }\n    \n    if (ray.hit) {\n   \t\treturn texture(iChannel1, ray.hit_uvw.xy);\n    } else {\n        return texture(iChannel0, ray.dir);\n    }    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = solve(fragCoord/iResolution.xy);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// ----------------------------------------------------------------------------\n// HLSL Type/Function redefines\n// ----------------------------------------------------------------------------\n#define float2\t\tvec2\n#define float3\t\tvec3\n#define float4\t\tvec4\n#define float3x3\tmat3x3\n#define float3x4\tmat3x4\n#define float4x3\tmat4x3\n#define float4x4\tmat4x4\n#define int2\t\tivec2\n#define int3\t\tivec3\n#define int4\t\tivec4\n#define lerp\t\tmix\n\n#define PI\t\t\t3.1415926535897932384626433832795\n#define PI2\t\t\t6.2831853071795864769252867665590\n#define _1_BY_PI\t.31830988618379067153776752674503\n#define _1_BY_PI2\t.15915494309189533576888376337251\n#define PI_BY_180\t.01745329251994329576923690768489\n#define PI_BY_360   .00872664625997164788461845384244\n#define _180_BY_PI  57.295779513082320876798154814105\n#define _360_BY_PI  114.59155902616464175359630962821\n#define LARGE_VALUE\t32768.0\n\n#define TO_RAD(v) (v * PI_BY_180)\n#define TO_DEG(v) (v * _180_BY_PI)\n\n// ----------------------------------------------------------------------------\n// Options (only modify this)\n// ----------------------------------------------------------------------------\n\n/// Settings\n#define CAM_SPEED\t\t\t20.0\n#define CAM_SPEED_SHIFT\t\t5.0 // Multiplier\n#define CAM_SPEED_CONTROL \t0.1 // Multiplier\n#define CAM_TURN_SPEED\t\t180.0 // In Degrees\n#define MAX_BOUNCES\t\t\t5\n\n/// Camera Modes\n//#define CAM_FISHEYE\t\t\t// Fisheye/Pinhole camera, curved near and far.\n#define CAM_PERSPECTIVE\t\t// Perspective camera, flat near and far, but uses fieldofview to determine far plane.\n//#define CAM_ORTHOGRAPHIC\t\t// Orthographic camera, flat near and far. (Default if nothing is defined)\n\n/// Camera Settings\nconst float2 camera_range = float2(1., 1000.);\nconst float camera_fieldofview = TO_RAD(90.0); // Perspective and Fisheye, horizontal dominant.\nconst float camera_size = 10.0; // Orthographic\n\n/// Debug Mode\n\n// ----------------------------------------------------------------------------\n// Keyboard\n// ----------------------------------------------------------------------------\n#define KEY_RESERVED_0 0 // All Media Keys happen here.\n#define KEY_RESERVED_1 1\n#define KEY_RESERVED_2 2\n#define KEY_RESERVED_3 3\n#define KEY_RESERVED_4 4\n#define KEY_RESERVED_5 5\n#define KEY_RESERVED_6 6\n#define KEY_RESERVED_7 7\n#define KEY_BACKSPACE 8\n#define KEY_TAB 9\n#define KEY_RESERVED_10 10\n#define KEY_RESERVED_11 11\n#define KEY_CLEAR 12 // Numpad 5 without NumLock\n#define KEY_ENTER 13\n#define KEY_RESERVED_14 14\n#define KEY_RESERVED_15 15\n#define KEY_SHIFT 16\n#define KEY_CONTROL 17\n#define KEY_ALT 18\n#define KEY_PAUSE 19\n#define KEY_CAPSLOCK 20\n#define KEY_RESERVED_21 21\n#define KEY_RESERVED_22 22\n#define KEY_RESERVED_23 23\n#define KEY_RESERVED_24 24\n#define KEY_RESERVED_25 25\n#define KEY_RESERVED_26 26\n#define KEY_ESCAPE 27\n#define KEY_RESERVED_28 28\n#define KEY_RESERVED_29 29\n#define KEY_RESERVED_30 30\n#define KEY_RESERVED_31 31\n#define KEY_SPACE 32\n#define KEY_PAGE_UP 33\n#define KEY_PAGE_DOWN 34\n#define KEY_END 35\n#define KEY_POS1 36\n#define KEY_ARROW_LEFT 37\n#define KEY_ARROW_UP 38\n#define KEY_ARROW_RIGHT 39\n#define KEY_ARROW_DOWN 40\n#define KEY_RESERVED_41 41\n#define KEY_RESERVED_42 42\n#define KEY_RESERVED_43 43\n#define KEY_RESERVED_44 44\n#define KEY_INSERT 45\n#define KEY_DELETE 46\n#define KEY_RESERVED_47 47\n#define KEY_0 48\n#define KEY_1 49\n#define KEY_2 50\n#define KEY_3 51\n#define KEY_4 52\n#define KEY_5 53\n#define KEY_6 54\n#define KEY_7 55\n#define KEY_8 56\n#define KEY_9 57\n#define KEY_RESERVED_58 58\n#define KEY_BRACKET_LEFT 59 // Ü (German)\n#define KEY_INTL_BACKLASH 60 // < (German)\n#define KEY_RESERVED_61 61\n#define KEY_RESERVED_62 62\n#define KEY_MINUS 63 // ß (German)\n#define KEY_RESERVED_64 64\n#define KEY_A 65\n#define KEY_B 66\n#define KEY_C 67\n#define KEY_D 68\n#define KEY_E 69\n#define KEY_F 70\n#define KEY_G 71\n#define KEY_H 72\n#define KEY_I 73\n#define KEY_J 74\n#define KEY_K 75\n#define KEY_L 76\n#define KEY_M 77\n#define KEY_N 78\n#define KEY_O 79\n#define KEY_P 80\n#define KEY_Q 81\n#define KEY_R 82\n#define KEY_S 83\n#define KEY_T 84\n#define KEY_U 85\n#define KEY_V 86\n#define KEY_W 87\n#define KEY_X 88\n#define KEY_Y 89\n#define KEY_Z 90\n#define KEY_OS 91\n#define KEY_RESERVED_92 92\n#define KEY_MENU 93\n#define KEY_RESERVED_94 94\n#define KEY_RESERVED_95 95\n#define KEY_NUMPAD_0 96\n#define KEY_NUMPAD_1 97\n#define KEY_NUMPAD_2 98\n#define KEY_NUMPAD_3 99\n#define KEY_NUMPAD_4 100\n#define KEY_NUMPAD_5 101\n#define KEY_NUMPAD_6 102\n#define KEY_NUMPAD_7 103\n#define KEY_NUMPAD_8 104\n#define KEY_NUMPAD_9 105\n#define KEY_NUMPAD_MULTIPLY 106\n#define KEY_NUMPAD_ADD 107\n#define KEY_RESERVED_108 108\n#define KEY_NUMPAD_SUBTRACT 109\n#define KEY_NUMPAD_COMMA 110\n#define KEY_NUMPAD_DIVIDE 111\n#define KEY_F1 112\n#define KEY_F2 113\n#define KEY_F3 114\n#define KEY_F4 115\n#define KEY_F5 116\n#define KEY_F6 117\n#define KEY_F7 118\n#define KEY_F8 119\n#define KEY_F9 120\n#define KEY_F10 121\n#define KEY_F11 122\n#define KEY_F12 123\n#define KEY_F13 124\n#define KEY_F14 125\n#define KEY_F15 126\n#define KEY_F16 127\n#define KEY_F17 128\n#define KEY_F18 129\n#define KEY_F19 130\n#define KEY_F20 131\n#define KEY_F21 132\n#define KEY_F22 133\n#define KEY_F23 134\n#define KEY_F24 135\n#define KEY_NUMPAD 144\n#define KEY_SCROLLOCK 145\n#define KEY_BACKQUOTE 160 // ^ (German)\n#define KEY_RESERVED_161 161\n#define KEY_RESERVER_162 162\n#define KEY_BACKSLAHS 163 // # (German)\n#define KEY_BRACKET_RIGHT 171 // + (German)\n#define KEY_RESERVED_172 172\n#define KEY_SLASH 173 // - (German)\n#define KEY_AUDIO_VOLUME_MUTE 181\n#define KEY_AUDIO_VOLUME_DOWN 182\n#define KEY_AUDIO_VOLUME_UP 183\n#define KEY_COMMA 188\n#define KEY_PERIOD 190\n#define KEY_RESERVED_191 191\n#define KEY_EQUAL 192 // ´ (German)\n#define KEY_SEMICOLON 192 // Ö (German)\n#define KEY_QUOTE 222 // Ä (German)\n\nbool key_down(int key, sampler2D tex) {\n    return texelFetch(tex, int2(key, 0), 0).x > .5;    \n}\n\nbool key_hit(int key, sampler2D tex) {\n    return texelFetch(tex, int2(key, 1), 0).x > .5;    \n}\n\nbool key_toggled(int key, sampler2D tex) {\n    return texelFetch(tex, int2(key, 2), 0).x > .5;    \n}\n\n// ----------------------------------------------------------------------------\n// Buffer D States\n// ----------------------------------------------------------------------------\n#define SET_CAMERA_POSITION int2(0, 0)\n#define SET_CAMERA_ROTATION int2(1, 0)\n#define SET_FRAMETIME int2(0, 1)\n\nfloat3 read_camera_position(sampler2D sampler) {\n    return texelFetch(sampler, SET_CAMERA_POSITION, 0).xyz;\n}\n\nfloat3 read_camera_rotation(sampler2D sampler) {\n    return texelFetch(sampler, SET_CAMERA_ROTATION, 0).xyz;\n}\n\nfloat read_weighted_frametime(sampler2D sampler) {\n    return texelFetch(sampler, SET_FRAMETIME, 0).x;\n}\n\n\n// ----------------------------------------------------------------------------\n// Axis-Angle Math\n// ----------------------------------------------------------------------------\nfloat3x3 axisang_to_float3x3(float3 axis, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return float3x3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nfloat3 axisang_rotate_float3(float3 v, float3 axis, float angle) {\n    \n    //axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return (float4(v,1.) * float4x4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0)).xyz;    \n}\n\n// ----------------------------------------------------------------------------\n// Math Stuff\n// ----------------------------------------------------------------------------\n#define SIDE_LEFT 0\n#define SIDE_FRONT 1\n#define SIDE_RIGHT 2\n#define SIDE_BACK 3\n#define SIDE_DOWN 4\n#define SIDE_UP 5\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Input Handler & other stuff\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float2 ruv = floor(fragCoord);\n    int2 xy = int2(ruv.x, ruv.y);\n    float time_delta = read_weighted_frametime(iChannel0);\n    \n    if (xy == SET_CAMERA_POSITION) {\n        float3 pos = read_camera_position(iChannel0);\n        float3 rot = read_camera_rotation(iChannel0);\n        \n        float3x3 m_rot = \n            axisang_to_float3x3(float3(1., 0., 0.), rot.x)\n            * axisang_to_float3x3(float3(0., 1., 0.), rot.y)\n            * axisang_to_float3x3(float3(0., 0., 1.), rot.z);\n        \n        float3 fw = float3(0., 0., 1.) * m_rot;\n        float3 rg = float3(1., 0., 0.) * m_rot;\n        float3 up = float3(0., 1., 0.) * m_rot;\n        float3 delta = float3(0.);\n        \n        if (key_down(KEY_A, iChannel1)) {\n            delta -= rg;\n        } else if (key_down(KEY_D, iChannel1)) {\n            delta += rg;\n        }        \n        if (key_down(KEY_S, iChannel1)) {\n            delta -= fw;\n        } else if (key_down(KEY_W, iChannel1)) {\n            delta += fw;\n        }        \n        if (key_down(KEY_Q, iChannel1)) {\n            delta -= up;\n        } else if (key_down(KEY_E, iChannel1)) {\n            delta += up;\n        }\n        \n        if (length(delta) > 0.1) {\n        \tdelta = normalize(delta) * CAM_SPEED;\n            if (key_down(KEY_SHIFT, iChannel1)) {\n                delta *= CAM_SPEED_SHIFT;\n            }\n            if (key_down(KEY_ALT, iChannel1)) {\n                delta *= CAM_SPEED_CONTROL;\n            }\n        \tpos += delta * time_delta;\n        }\n        \n        fragColor.rgb = pos;\n    } else if (xy == SET_CAMERA_ROTATION) {\n        float3 rot = read_camera_rotation(iChannel0);\n        \n        if (key_down(KEY_SPACE, iChannel1)) {\n            //float2 delta = iMouse.xy - iMouse.zw;\n            float2 delta = (iMouse.xy / iResolution.xy) - .5;\n            float2 deltasign = sign(delta);\n            delta = delta * delta;\n            delta *= iResolution.xy * deltasign;\n        \t\n            float speed = TO_RAD(CAM_TURN_SPEED) * time_delta;\n        \n        \trot.x += -(float(delta.y) / float(iResolution.y)) * 2. * speed;\n        \trot.y += (float(delta.x) / float(iResolution.x)) * 2. * speed;\n        }\n        \n        fragColor.rgb = rot;\n    } else if (xy == SET_FRAMETIME) {\n        if (iTime <= 1.) {\n            fragColor.r = iTimeDelta;\n        } else {\n            fragColor.r = read_weighted_frametime(iChannel0) * 0.9 + iTimeDelta * 0.1;\n        }        \n    }\n}","name":"Buffer D","description":"","type":"buffer"}]}