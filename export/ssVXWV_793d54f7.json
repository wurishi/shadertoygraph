{"ver":"0.1","info":{"id":"ssVXWV","date":"1635470646","viewed":58,"name":"MB 1","username":"Livie","description":"Metaballs sketch 1","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["metaballs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float CLOSE_ENOUGH = 0.001;\nconst float RENDER_DISTANCE = 30.0;\nconst vec3 COLOR = vec3(227., 186., 129.)/255.;\nconst vec3 BG_COLOR = vec3(.05,.7,.025);\nconst vec3 SHADOW_COLOR = vec3(.1,.9,.8);\n\nconst vec2 v1params = vec2(1.0,  .5);\nconst vec2 v2params = vec2(2.0, 1.3);\nconst vec2 v3params = vec2(1.5,  .6);\nconst vec2 v4params = vec2(0.5,  .3);\nconst vec2 v5params = vec2(0.75,1.0);\n\n//  HSB fns from IÃ±igo Quiles @ https://www.shadertoy.com/view/MsS3Wc\nvec3 rgb2hsb( in vec3 c ) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\nvec3 hsb2rgb( in vec3 c ) {\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0), 6.0)-3.0)-1.0, 0.0, 1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nstruct sphere\n{\n\tvec3 c;\n    float r;\n};\n\n\nfloat sphereDist(vec3 p, sphere s)\n{\n\treturn distance(p, s.c) - s.r;\n}\n\n//from iq : https://iquilezles.org/articles/distfunctions\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat sdf(vec3 p)\n{\n    float returnVal = .0;\n    \n    \n    //vec3 rep = vec3(4.0, 2., 1.);\n\tvec3 pr = p;//mod(p, rep) - .5 * rep; \n        \n    sphere s1 = sphere(vec3(sin(iTime*v1params.x), sin(iTime*v1params.y), 1.), .3);\n    sphere s2 = sphere(vec3(sin(iTime*v2params.x), sin(iTime*v2params.y), 1.), .4);\n    sphere s3 = sphere(vec3(sin(iTime*v3params.x), sin(iTime*v3params.y), 1.), .45);\n    sphere s4 = sphere(vec3(sin(iTime*v4params.x), sin(iTime*v4params.y), 1.), .2);\n    sphere s5 = sphere(vec3(sin(iTime*v5params.x), sin(iTime*v5params.y), 1.), .2);\n    \n    float smoothness = .2;\n    returnVal = opSmoothUnion(sphereDist(pr, s1), sphereDist(pr,s2), smoothness);\n    returnVal = opSmoothUnion(returnVal, sphereDist(pr, s3), smoothness);\n    returnVal = opSmoothUnion(returnVal, sphereDist(pr, s4), smoothness);\n    returnVal = opSmoothUnion(returnVal, sphereDist(pr, s5), smoothness);\n    \n\treturn returnVal; \n}\n\n//from iq https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 p )\n{\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sdf( p + k.xyy*CLOSE_ENOUGH ) + \n                      k.yyx*sdf( p + k.yyx*CLOSE_ENOUGH ) + \n                      k.yxy*sdf( p + k.yxy*CLOSE_ENOUGH ) + \n                      k.xxx*sdf( p + k.xxx*CLOSE_ENOUGH ) );\n}\n\n// Inverse Distance Weighting - for color interpolation\nvec3 calculateIDW(vec2 p) {\n    vec3 v1 = vec3(sin(iTime*v1params.x), sin(iTime*v1params.y), 1.);\n    vec3 v2 = vec3(sin(iTime*v2params.x), sin(iTime*v2params.y), 1.);\n    vec3 v3 = vec3(sin(iTime*v3params.x), sin(iTime*v3params.y), 1.);\n    vec3 v4 = vec3(sin(iTime*v4params.x), sin(iTime*v4params.y), 1.);\n    vec3 v5 = vec3(sin(iTime*v5params.x), sin(iTime*v5params.y), 1.);\n       \n    // Shepard's method\n    // https://en.wikipedia.org/wiki/Inverse_distance_weighting\n    float powerParam = 5.;\n    float w1 = 1./pow(distance(vec3(p.x, p.y, 1.), v1), powerParam);\n    float w2 = 1./pow(distance(vec3(p.x, p.y, 1.), v2), powerParam);\n    float w3 = 1./pow(distance(vec3(p.x, p.y, 1.), v3), powerParam);\n    float w4 = 1./pow(distance(vec3(p.x, p.y, 1.), v4), powerParam);\n    float w5 = 1./pow(distance(vec3(p.x, p.y, 1.), v5), powerParam);\n    vec3 u1 = vec3(.4,  1., 1.);\n    vec3 u2 = vec3(.7,  1., 1.);\n    vec3 u3 = vec3(.8,  1., 1.);\n    vec3 u4 = vec3(.89,  1., 1.);\n    vec3 u5 = vec3(.5,  1., 1.);\n    \n    vec3 u = (w1*u1 + w2*u2 + w3*u3 + w4*u4 + w5*u5)/(w1+w2+w3+w4+w5);\n    return u;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n\tvec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\n         uv.x *= iResolution.x / iResolution.y;\n\tvec3 cameraPos = vec3(.0, .0, .0);//vec3(.0,sin(iTime)*.5,.0);// + iTime);\n    \n    // Time varying pixel color\n    vec3 ro = vec3(cameraPos.x + uv.x, cameraPos.y + uv.y, cameraPos.z);\n\tvec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n    vec3 col = hsb2rgb(BG_COLOR);\n    //col = calculateIDW(uv.xy); \n    float dist = .0;\n    \n    float pWidth = .005;\n    if (false) {\n        /*distance(uv.xy*2., vec2(sin(iTime*v1params.x), sin(iTime*v1params.y))) < pWidth ||\n        distance(uv.xy*2., vec2(sin(iTime*v2params.x), sin(iTime*v2params.y))) < pWidth ||\n        distance(uv.xy*2., vec2(sin(iTime*v3params.x), sin(iTime*v3params.y))) < pWidth ||\n        distance(uv.xy*2., vec2(sin(iTime*v4params.x), sin(iTime*v4params.y))) < pWidth ||\n        distance(uv.xy*2., vec2(sin(iTime*v5params.x), sin(iTime*v5params.y))) < pWidth) {\n        fragColor = vec4(1.,1.,1., 1.0);*/\n    }\n    else{    \n        vec3 lightDir = normalize(vec3(sin(iTime*0.125), sin(iTime*0.25), -1.0));\n\n        while(dist < RENDER_DISTANCE)\n        {\n            float d = sdf(ro + rd * dist);\n            if(d < CLOSE_ENOUGH)\n            {\n\n\n                vec3 hit = ro + rd * dist;\n                col = calculateIDW(hit.xy);//BLUE; \n                col *= mix(hsb2rgb(SHADOW_COLOR), col, max(dot(calcNormal(hit), lightDir), .0));\n                col = hsb2rgb(col);\n                break;\n            }\n            dist += d;\n        }\n\n        // Output to screen\n        fragColor = vec4(col, 1.0);\n        }\n}","name":"Image","description":"","type":"image"}]}