{"ver":"0.1","info":{"id":"3s2Bzd","date":"1590623534","viewed":154,"name":"Iris polar","username":"Vectornaut","description":"Testing a routine for making phase plots of meromorphic functions, adapted from endolith's complex_colormap code.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["cielab","holomorphic","phaseplot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//----------------------sRGB----------------------\n// from nmz's 3d color space visualization\n// https://www.shadertoy.com/view/XddGRN\n\n// map colors from RGB space to sRGB space. in RGB space, color value is\n// proportional to light intensity, so linear color-vector interpolation\n// corresponds to physical light mixing. in sRGB space, the color encoding\n// used by many monitors, we use more of the value interval to represent low\n// intensities, and less of the interval to represent high intensities. this\n// improves color quantization. see explore-lab/explore-lab-l.frag to learn more\n\nfloat sRGB(float t){ return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n//----------------------CIE Lab----------------------\n// from nmz's 3d color space visualization\n// https://www.shadertoy.com/view/XddGRN\n\n// map colors from Lab space to RGB space. see explore-lab/explore-lab-l.frag\n// to learn more\n\nconst vec3 wref =  vec3(.95047, 1.0, 1.08883);\n\nfloat xyzR(float t){ return mix(t*t*t , 0.1284185*(t - 0.139731), step(t,0.20689655)); }\n\nvec3 lab2rgb(in vec3 c)\n{\n    float lg = 1./116.*(c.x + 16.);\n    vec3 xyz = vec3(wref.x*xyzR(lg + 0.002*c.y),\n                    wref.y*xyzR(lg),\n                    wref.z*xyzR(lg - 0.005*c.z));\n    vec3 rgb = xyz*mat3( 3.2406, -1.5372,-0.4986,\n                        -0.9689,  1.8758, 0.0415,\n                         0.0557, -0.2040, 1.0570);\n    return rgb;\n}\n\n// --- chromasphere ---\n// adapted from endolith's complex_colormap code\n// https://github.com/endolith/complex_colormap/tree/master/complex_colormap\n\n// endolith created this palette for phase plots of complex functions, like the\n// ones in this article. (the article uses a different palette---possibly based\n// on a CMYK color wheel?)\n// https://www.ams.org/notices/201106/rtx110600768p.pdf\n\n// at each lightness `l`, we want to use a constant-chroma color wheel with the\n// most saturated colors an RGB monitor can display. this function approximates\n// the radius of that color wheel using an efficient piecewise-linear formula\nfloat appx_chromawheel(in float l) {\n    if (l <= 0.0 || 100.0 <= l) return 0.0;\n    float lpts [5];\n    float cpts [5];\n    lpts[0] =   0.0; lpts[1] =   9.2; lpts[2] =  73.8; lpts[3] =  90.0; lpts[4] = 100.0;\n    cpts[0] =   0.0; cpts[1] =  10.8; cpts[2] =  39.9; cpts[3] =  12.5; cpts[4] =   0.0;\n    float lbot; float ltop;\n    float cbot; float ctop;\n    if      (l < lpts[1]) { lbot = lpts[0]; ltop = lpts[1]; cbot = cpts[0]; ctop = cpts[1]; }\n    else if (l < lpts[2]) { lbot = lpts[1]; ltop = lpts[2]; cbot = cpts[1]; ctop = cpts[2]; }\n    else if (l < lpts[3]) { lbot = lpts[2]; ltop = lpts[3]; cbot = cpts[2]; ctop = cpts[3]; }\n    else                  { lbot = lpts[3]; ltop = lpts[4]; cbot = cpts[3]; ctop = cpts[4]; }\n    float t = (l - lbot) / (ltop - lbot);\n    return (1.0-t)*cbot + t*ctop;\n}\n\n// this should return false for +Inf, -Inf, NaN, and enormous numbers\nbool in_range(float t) {\n    return -1.0e38 < t && t < 1.0e38;\n}\n\n// translate a complex number `z` into a color. the lightness shows the absolute\n// value of `z`, and the hue shows the phase of `z`\nvec3 chromasphere(vec2 z) {\n    if (in_range(z.x) && in_range(z.y)) {\n        float r = length(z);\n        vec2 u = z/r;\n        float l = 100.*(1. - 1./(1. + pow(r, 1./3.)));\n        return lab2rgb(vec3(l, appx_chromawheel(l)*u));\n    } else {\n        return vec3(1.);\n    }\n}\n\n// --- complex arithmetic ---\n\nconst vec2 ONE = vec2(1., 0.);\nconst vec2 I   = vec2(0., 1.);\n\n//  the complex conjugate of `z`\nvec2 conj(vec2 z) {\n    return vec2(z.x, -z.y);\n}\n\n// the product of `z` and `w`\nvec2 mul(vec2 z, vec2 w) {\n    return mat2(z, conj(z).yx) * w;\n}\n\n// the reciprocal of `z`\nvec2 rcp(vec2 z) {\n    // 1/z = z'/(z'*z) = z'/|z|^2\n    return conj(z) / dot(z, z);\n}\n\n// --- main ---\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 root = sin(iTime)*(ONE*cos(iTime) + I*sin(iTime));\n    vec2 z = 1.25*2.*(fragCoord/iResolution.yy - vec2(0.5*iResolution.x/iResolution.y, 0.5));\n    vec2 z_sq = mul(z ,z);\n    vec2 z_cb = mul(z, z_sq);\n    vec2 w = mul(z_sq, rcp(root - z_cb));\n    fragColor = vec4(sRGB(chromasphere(w)), 1.);\n}","name":"Image","description":"","type":"image"}]}