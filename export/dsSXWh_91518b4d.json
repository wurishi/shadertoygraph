{"ver":"0.1","info":{"id":"dsSXWh","date":"1670212917","viewed":341,"name":"Voxel DDA 2","username":"JuanDeager","description":"Adds transparency and normals to the famous branchless voxel raycasting shader.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","raycasting","oxel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Branchless Voxel Raycasting\" by fb39ca4. https://shadertoy.com/view/4dX3zl\n// 2022-12-05 01:02:24\n\n//The raycasting code is somewhat based around a 2D raycasting toutorial found here: \n//http://lodev.org/cgtutor/raycasting.html\n\n#define MAT_AIR 0\n#define MAT_GLASS 1\n#define MAT_STONE 2\n#define MAT_RGB_GLASS 3\n\nconst int MAX_RAY_STEPS = 150;\n\t\n\t\nfloat de( vec3 pos ) {\n    #define SCALE 2.8\n    #define MINRAD2 .25\n    #define scale (vec4(SCALE, SCALE, SCALE, abs(SCALE)) / minRad2)\n    float minRad2 = clamp(MINRAD2, 1.0e-9, 1.0);\n    float absScalem1 = abs(SCALE - 1.0);\n    float AbsScale = pow(abs(SCALE), float(1-10));\n    vec4 p = vec4(pos,1);\n    vec4 p0 = p;\n    for (int i = 0; i < 2; i++)\n    {\n        p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;\n        float r2 = dot(p.xyz, p.xyz);\n        p *= clamp(max(minRad2/r2, minRad2), 0.0, 1.0);\n        p = p*scale + p0;\n    }\n    return ((length(p.xyz) - absScalem1) / p.w - AbsScale);\n}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat sdSphere(vec3 p, float d)\n{\n    return length(p) - d;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nint getVoxel2(ivec3 c)\n{\n\tvec3 p = vec3(c) + vec3(0.5);\n    if (max(-sdSphere(p, 19.5), sdBox(p, vec3(16.0))) < 0.0)\n    {\n        return MAT_GLASS;\n    }\n    if (de(p*.255) < 0.0)\n    {\n        return MAT_RGB_GLASS;\n    }\n    if (-sdSphere(p, 50.0) < 0.0)\n    {\n        return MAT_STONE;\n    }\n    \n    return MAT_AIR;\n}\n\nvec2 rotate2d(vec2 v, float a)\n{\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tvec3 cameraDir = vec3(0.0, 0.0, 0.8);\n\tvec3 cameraPlaneU = vec3(1.0, 0.0, 0.0);\n\tvec3 cameraPlaneV = vec3(0.0, 1.0, 0.0) * iResolution.y / iResolution.x;\n\tvec3 rayDir = cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;\n    vec3 origin = vec3(0.0, 2.0 * sin(iTime * 2.7), -29.0);\n\tvec3 rayPos = origin;\n    \n\trayPos.xz = rotate2d(rayPos.xz, iTime * .33);\n\trayDir.xz = rotate2d(rayDir.xz, iTime * .33);\n\t\n\tivec3 mapPos = ivec3(floor(rayPos));\n\n\tvec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);\n\t\n\tivec3 rayStep = ivec3(sign(rayDir));\n\n\tvec3 sideDist = (sign(rayDir) * (vec3(mapPos) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist;\n\t\n\tbvec3 mask;\n    \n    vec3 lightMask = vec3(1.0);\n    vec3 color = vec3(0.0);\n    vec3 norm = vec3(0.0);\n    \n\tfor (int i = 0; i < MAX_RAY_STEPS; i++)\n    {\n        mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n        sideDist += vec3(mask) * deltaDist;\n        norm = vec3(ivec3(vec3(mask))) * vec3(rayStep);\n        mapPos += ivec3(norm);\n        norm *= -1.0;\n     \n        //float minComp = min(sideDist.x, min(sideDist.y, sideDist.z));\n        //vec3 hit = origin + rayDir * minComp;\n        \n        int voxel = getVoxel2(mapPos);\n\t\tif (voxel == MAT_AIR)\n        {\n            continue;\n        }\n        else if (voxel == MAT_GLASS)\n        {\n            lightMask *= .75;\n            continue;\n        }\n        else if (voxel == MAT_RGB_GLASS)\n        {\n            vec3 c = vec3(rand(float(mapPos.x)), rand(float(mapPos.y)), rand(float(mapPos.z)));\n            c = normalize(c);\n            lightMask *= c;\n        }\n        else if (voxel == MAT_STONE)\n        {\n            color = vec3(1.0);\n            break;\n        }\n\t}\n\t\n\tif (mask.x) {\n\t\tcolor *= vec3(0.5);\n\t}\n\tif (mask.y) {\n\t\tcolor *= vec3(0.8);\n\t}\n\tif (mask.z) {\n\t\tcolor *= vec3(0.75);\n\t}\n    color += 0.2 * (norm * .5 + .5);\n    color *= lightMask;\n\tfragColor.rgb = color;\n}","name":"Image","description":"","type":"image"}]}