{"ver":"0.1","info":{"id":"Ddc3zr","date":"1676871559","viewed":147,"name":"Picnic in the park","username":"ianertson","description":"Look around with the mouse :)\nNo textures used! Except for a single noise texture.","likes":7,"published":1,"flags":32,"usePreview":1,"tags":["3d","raytracing","raymarching","raymarch","sdf","nature","picnic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 getColor(vec2 uv) { return texture(iChannel0, uv).rgb; }\n\nvec3 getSmooth(vec2 uv) {    \n    vec2 dx = dFdx(uv)*10.;\n    vec2 dy = dFdy(uv)*10.;\n    vec2 dir1x = vec2(1, 0) * dx;\n    vec2 dir1y = vec2(1, 1) * dy;\n    \n    vec2 dir2x = vec2(1, 1) * dx;\n    vec2 dir2y = vec2(0, 1) * dy;\n\n    vec3 a = textureGrad(iChannel0, uv, dir1x, dir1y).rgb;\n    vec3 b = textureGrad(iChannel0, uv, dir2x, dir2y).rgb;\n    \n    return mix(a, b, 0.5);\n}\n\nfloat estimateNoise(vec3 col, vec2 uv) {\n    vec2 e = vec2(1.0) / R.xy;\n    vec3 a = vec3(\n        luma(getColor(uv + vec2(e.x, 0))),\n        luma(getColor(uv + vec2(0, e.y))),\n        luma(getColor(uv + vec2(e.x, e.y)))\n    );\n    \n    float l = luma(col);\n    float n1 = abs(l - ((a.x+a.y+a.z)/3.));\n    float n2 = abs(a.x - a.y);\n    float n3 = abs(a.x - a.z);\n    float n4 = abs(a.y - a.z);\n    float n5 = fwidth(l);\n    \n    float n = (n1+n2+n3+n4+n5)/5.0;\n    return clamp(n*M_PI, 0.0, 1.0);\n}\n\nvec3 shade(vec2 uv) {\n    vec3 col = getColor(uv);\n    float depth = texture(iChannel0, uv).a;\n    float noiseEst = estimateNoise(col, uv);\n    \n    vec3 smoothCol = getSmooth(uv);\n    \n    float bright = luma(col);\n    \n    col = mix(col, smoothCol, clamp(noiseEst+(bright*0.5), 0.0, 0.4));\n    col = mix(col, smoothCol, clamp((depth*(0.11+depth))*12., 0.0, 1.0));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = fc/R.xy;\n    \n    col = shade(uv);\n    \n    O = vec4(clamp(col, 0.0, 1.0), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R (iResolution.xy)\n#define T ((iFrame <= 1 || iTime <= 0.0001) ? 16.77 : iTime)\n#define M_PI (3.1416)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) max(0.0, dot(a, b))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n#define ang2(a) (vec2(cos(a), sin(a)))\n\nmat2 rot(float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\n#define ESTIMATE_BUMP_FOR(var_, uv_, clr_, wn_, texfunc_, z_, scale_, mixf_, op_, err_)\\\n    {\\\n        float l = op_(clr_);\\\n        float ex = dFdx(l)*scale_;\\\n        float ey = dFdy(l)*scale_;\\\n        var_ = correctBump(wn_, normalize(l - vec3(\\\n            op_(texfunc_(uv_ + vec2(ex, 0))),\\\n            op_(texfunc_(uv_ + vec2(0, ey))),\\\n            z_\\\n        )), mixf_, err_);\\\n    }\n\n#define SAMPLE(var, id_) if (data.skip != id_ && var < dist) { data.id = id_; dist = var; }\n\nstruct Material {\n    float rough;\n    float spec;\n    float ior;\n};\n\n#define NEW_MATERIAL Material(1.0, 1.0, 0.0)\n\nstruct Data {\n    vec3 p;\n    vec3 n;\n    vec2 uv;\n    float d;\n    int id;\n    Material m;\n    float sig;\n    int skip;\n};\n\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), vec2(0.0), FAR, 0, NEW_MATERIAL, 1.0, 0)\n\nstruct Light {\n    vec3 p;\n    vec3 d;\n    vec3 c;\n    float s;\n    int type;\n};\n\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\n\nvec3 getLightDir(in Light light, in vec3 p) {\n    switch (light.type) {\n        case LIGHT_AMBIENT: return normalize(light.p); break;\n        case LIGHT_POINT: return normalize(light.p - p); break;\n        case LIGHT_DIR: return normalize(light.d); break;\n    }\n    return vec3(0.0);\n}\n\nvec3 getLightAtt(in Light light, vec3 p, vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = cdot(n, L);\n    \n    switch (light.type) {\n        case LIGHT_AMBIENT: {\n            return light.c * light.s * NdotL;\n        }; break;\n        case LIGHT_POINT: {\n            float d = distance(light.p, p);\n            return light.c * NdotL * (pow(light.s, 2.0) / max(0.0001, pow(d, 2.0)));\n        }; break;\n        case LIGHT_DIR: {\n            const float cutoff = 0.8;\n            vec3 ld = light.d;\n            vec3 sd = normalize(light.p - p);\n            float cone = dot(sd, ld);\n            return light.c * light.s * NdotL * smoothstep(cutoff, 1.0, cone);\n        }; break;\n    }\n    \n    return vec3(0.0);\n}\n\nvec2 boxUv(vec3 p, vec3 n) {\n    vec2 uv = vec2(0.0);\n    uv = mix(uv, p.xy, adot(n, vec3(0, 0, 1)));\n    uv = mix(uv, p.xz, adot(n, vec3(0, 1, 0)));\n    uv = mix(uv, p.yz, adot(n, vec3(1, 0, 0)));\n    return uv;\n}\n\nvec2 sphereUv(vec3 p) {\n    vec2 uv = vec2(0.0);\n    uv.y = acos(p.x);\n    uv.x = atan(p.y, p.z);\n    uv = uv * 2.0 - 1.0;\n    uv.x = 0.5 + uv.x / (M_PI);\n    uv.y = 0.5 - uv.y / M_PI;\n    return uv;\n}\n\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\n\nfloat violet(vec3 color) { return dot(color, vec3(0.607843, 0.149019, 0.713725));}\n\nvec3 correctBump(in vec3 wn, in vec3 n, float mixf, float allowedError) {\n    vec3 t = cross(wn, vec3(0, 1, 0));\n    vec3 b = vec3(0.0);\n    if (abs(length(t)) == 0.0) t = cross(wn, vec3(0, 0, 1));\n    t = normalize(t);\n    b = normalize(cross(wn, t));\n    mat3 tbn = mat3(t, b, -wn);\n    n = normalize((tbn)*n);\n    return normalize(mix(wn, n, mixf*max(allowedError, dot(wn, n))));\n}\n\nfloat rgbToHue(vec3 color) {\n  float minVal = min(min(color.r, color.g), color.b);\n  float maxVal = max(max(color.r, color.g), color.b);\n  float delta = maxVal - minVal;\n  float hue = 0.0;\n  hue += step(color.g, color.b) * 2.0 + step(color.b, color.g) * 4.0;\n  hue -= step(color.b, color.r) * 2.0 + step(color.r, color.b) * 4.0;\n  hue += (color.r - color.g) * 0.5 / delta + step(hue, 0.0) * 6.0;\n  hue *= 60.0;\n  hue = fract(hue * (1.0 / 360.0));\n  return hue;\n}\n\nvec3 look(vec2 uv, vec3 point, vec3 ro) {\n    vec3 lookAt = point;\n    float zoom = 1.;\n    vec3 camForward = normalize(lookAt - ro);\n    vec3 camRight = -normalize(cross(camForward, vec3(0, 1, 0)));\n    vec3 camUp = -normalize(cross(camRight, camForward));\n    vec3 screenCenter = ro + camForward * zoom;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) *\n                  pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 EnvBRDFApprox(vec3 specularColor, float roughness, float ndotv) {\n  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * ndotv)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  return specularColor * AB.x + AB.y;\n}\n\n\nfloat onCycle(float from, float to, float time, float nrSteps, float transTime, float frame) {\n    float cycle = mod(time, nrSteps + transTime);\n    return mix(from, to, smoothstep(frame - transTime, frame + transTime, cycle));\n}\n\nvec3 onCycle(vec3 from, vec3 to, float time, float nrSteps, float transTime, float frame) {\n    float cycle = mod(time, nrSteps + transTime);\n    return mix(from, to, smoothstep(frame - transTime, frame + transTime, cycle));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 O, in vec2 fc )\n{\n    vec4 col = vec4(0.0);\n    vec2 uv = fc/R.xy;\n    \n    ivec2 C = ivec2(fc);\n    \n    switch (int(fc.x)) {\n        case 0: {\n            vec4 oldMouse = texelFetch(iChannel0, ivec2(0), 0);\n            vec4 nextMouse = iMouse;\n            col = mix(oldMouse, nextMouse, 0.33);\n        }; break;\n\n    }\n    \n    O = col;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define NEAR 0.003\n#define FAR 100.0\n#define STEPS 100\n\n#define ID_NONE 0\n#define ID_GROUND 1\n#define ID_WALL 2\n#define ID_BOX 3\n#define ID_TABLE 4\n#define ID_CHAIR 5\n#define ID_STOOL 6\n#define ID_PLATE 7\n#define ID_APPLE 8\n#define ID_APPLE_STEM 9\n#define ID_TREE_STEM 10\n#define ID_TREE_LEAFS 11\n#define ID_BOTTLE 12\n#define ID_BOTTLE_CAP 13\n\n\n#define SCENE_CENTER vec3(0, 0, -4.)\n#define PLATE_POS vec3(-2., 0.89-0.04, -2.)\n#define TREE_POS  vec3(1.6, 0, -5.4)\n#define BOTTLE_POS (PLATE_POS + vec3(0.59, 0.0, 0.0))\n#define TREE_HEIGHT 3.3\n\n\nvec3 noise(vec2 p, float seed, float freq) {\n    p /= 256.0;\n    p += seed / 256.0;\n    float amp = 1.0;\n    float div = 0.0;\n    vec3 n = vec3(0.0);\n    #define ADV n += amp * textureLod(iChannel3, p * freq, 0.0).xyz; div += amp; amp /= 2.0; freq *= 2.0;\n    ADV; ADV; ADV; ADV;\n    #undef ADV\n    return n / div;\n}\n\nvec3 noise6(vec2 p, float seed, float freq) {\n    p /= 256.0;\n    p += seed / 256.0;\n    float amp = 1.0;\n    float div = 0.0;\n    vec3 n = vec3(0.0);\n    #define ADV n += amp * textureLod(iChannel3, p * freq, 0.0).xyz; div += amp; amp /= 2.0; freq *= 2.0;\n    ADV; ADV; ADV; ADV; ADV; ADV;\n    #undef ADV\n    return n / div;\n}\n\n\nfloat boxSDF(in vec3 p, in vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat cylSDF(in vec3 p, vec3 a, vec3 b, float t) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h)-t;\n}\n\nfloat sphereSDF(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat groundSDF(in vec3 p) {\n    vec3 n = noise6(p.xz/2., 5.5315, 0.3);\n    \n    float h = n.y*(1.0+clamp(distance(p.xz, SCENE_CENTER.xz), 0.0, 2.0));\n    \n    h *= smoothstep(9.0-1.0, 9.0+6.0, distance(p.xz, SCENE_CENTER.xz));\n    \n    return p.y - h;\n}\n\nfloat wallSDF(in vec3 p) {\n    float t = 0.2;\n    float w = 4.0;\n    float h = w * 16.0 / 9.0;\n    float top = boxSDF(p - vec3(0, 0.5, 0), vec3(w, 0.5, t));\n    float bot = boxSDF(p - vec3(0, 0.5, -h), vec3(w, 0.5, t));\n    float left = boxSDF(p - vec3(-(w-t), 0.5, -h/2.), vec3(t, 0.5, h/2.));\n    float right = boxSDF(p - vec3((w-t), 0.5, -h/2.), vec3(t, 0.5, h/2.));\n    \n    float opening = boxSDF(p - vec3(-w, 0.5, -((h/2.)+0.25)), vec3(1.));\n    \n    left = max(left, -opening);\n    \n    return min(min(left, right), min(top, bot));\n}\n\nfloat tableSDF(in vec3 p) {\n    float dist = FAR;\n    float scale = 0.8;\n    float sx = 1.2 * scale;\n    float sz = 0.6 * scale;\n    float h = 1.0 * scale;\n    float boardT = 0.05 * scale;\n    \n    \n    float board = boxSDF(p - vec3(0, h, 0), vec3(sx, boardT, sz));\n    float leg = cylSDF(vec3(abs(p.x), p.y, abs(p.z)) - vec3(abs(-sx*0.9), 0.0, abs(-sz/2.)), vec3(0, 0, 0), vec3(0, h-(0.09*scale), 0), 0.1*scale);\n\n    dist = min(board, leg);\n    \n    return dist;\n}\n\nfloat chairSDF(in vec3 p) {\n    float dist = FAR;\n    float scale = 0.5;\n    float sx = 0.6 * scale;\n    float sz = 0.6 * scale;\n    float h = 1.0 * scale;\n    float boardT = 0.05 * scale;\n    float bsx = boardT;\n    float bsz = 0.6*scale;\n    float bh = h/1.7;\n    \n    \n    float board = boxSDF(p - vec3(0, h, 0), vec3(sx, boardT, sz)) - (0.01 + (0.06*max(0.0, -p.x)));\n    float leg = cylSDF(vec3(abs(p.x), p.y, abs(p.z)) - vec3(abs(-sx*0.7), 0.0, abs(-sz/2.)), vec3(0, 0, 0), vec3(0, h-(0.09*scale), 0), 0.1*scale);\n\n    float back = boxSDF(p - vec3(sx-bsx, h+bh, 0), vec3(bsx, bh, bsz)) - 0.01;\n    back += (0.01*max(0.0, p.y));\n    dist = min(min(board, leg), back);\n    \n    return dist;\n}\n\nfloat stoolSDF(in vec3 p) {\n    float dist = FAR;\n    float scale = 0.5;\n    float sx = 0.6 * scale;\n    float sz = 0.6 * scale;\n    float h = 1.0 * scale;\n    float boardT = 0.05 * scale;\n\n    float board = max(length(p.xz)-0.34, distance(vec3(0, p.y, 0), vec3(0, h, 0))-0.02);\n    float leg = cylSDF(vec3(abs(p.x), p.y, abs(p.z)) - vec3(abs(-sx*0.7), 0.0, abs(-sz/2.)), vec3(0, 0, 0), vec3(0, h-(0.09*scale), 0), 0.1*scale);\n\n    dist = min(board, leg);\n    \n    return dist;\n}\n\nfloat plateSDF(in vec3 p, float r, float h) {\n    float d1 = (max(-0.05, -p.y)+max(length(p.xz)-r, distance(vec3(0, p.y, 0), vec3(0, 0, 0))-h));\n    float d2 = (max(-0.05, -(p.y-0.01))+max(length(p.xz)-(r*0.9), distance(vec3(0, p.y-0.01, 0), vec3(0, 0, 0))-(h*0.9)));\n    return max(d1, -d2);\n}\n\nfloat appleSDF(in vec3 p, float r, inout int part) {\n    part = ID_APPLE;\n    float d = sphereSDF(p, r);\n    float d2 = sphereSDF(p-vec3(0, r*0.9, 0.), (r*0.45));\n    d = max(d, -d2);\n    \n    float stem = cylSDF(p-vec3(0, r*0.4, 0), vec3(0, 0, 0), vec3(0, r+0.02, cos(p.y*20.)*0.04), 0.005);\n    if (stem < d) { d = stem; part = ID_APPLE_STEM; }\n    return d;\n}\n\nfloat treeSDF(in vec3 p, inout int part) {\n    part = ID_TREE_STEM;\n    float h = TREE_HEIGHT;\n    float thick = 0.2;\n    float leafR = 0.9;\n    \n    //vec2 uv = sphereUv(p);\n    vec3 ra = noise(vec2(p.xz+(p.y*0.5))*16., 4.5551, 0.1);\n    \n    float v = ((ra.x+ra.y+ra.z)/3.)*1.2;\n    leafR = mix(leafR, leafR+0.7, v);\n    \n    float stem = cylSDF(p, vec3(0, 0, 0), vec3(0, h, 0), thick);\n    float dist = stem;\n    \n    float leafs = sphereSDF(p - vec3(0, h, 0), leafR);\n    \n    if (leafs < dist) { part = ID_TREE_LEAFS; dist = leafs; }\n    \n    \n    return dist;\n}\n\n\nfloat bottleSDF(inout int part, vec3 p) {\n    float thick = 0.08;\n    float h = 0.4;\n    \n    float neckStart = h-0.16;\n    float neckEnd = h;\n    \n    thick *= max(0.3, (1.0 - smoothstep(neckStart, neckEnd, max(0.0, p.y))));\n    float body = cylSDF(p, vec3(0, 0, 0), vec3(0, h, 0), thick);\n    body = max(body-0.002, (p.y-(h*0.98))-distance(vec3(0, 0.0, 0), vec3(0, p.y-(h*0.99), 0)));\n    float cap = cylSDF(p, vec3(0, h, 0), vec3(0, h+0.02, 0), thick*0.6);\n    cap = max(cap, (p.y-((h+0.03)*0.98))-distance(vec3(0, 0.0, 0), vec3(0, p.y-((h+0.03)*0.99), 0)));\n\n    float dist = body;\n    \n    if (cap < dist) { part = ID_BOTTLE_CAP; dist = cap; }\n    \n    return dist;\n}\n\nfloat getDist(inout Data data, in vec3 p) {\n    float dist = FAR;\n    \n    float ground = groundSDF(p);\n    float wall = wallSDF(p);\n    float table = tableSDF(p - vec3(-2., 0, -2));\n    float chair = chairSDF(p - vec3(-0.5, 0, -2.));\n    float stool = stoolSDF(p - vec3(-2., 0, -2.9));\n    \n    vec3 platePos = PLATE_POS;\n    float plate = plateSDF(p - platePos, 0.24, 0.01);\n    int applePart = ID_APPLE;\n    float apple = appleSDF((p - platePos) - vec3(0, 0.064, 0.0), 0.065, applePart);\n    int treePart = ID_TREE_STEM;\n    float tree = treeSDF(p - TREE_POS, treePart);\n      \n    \n    SAMPLE(wall, ID_WALL);\n    SAMPLE(ground, ID_GROUND);\n    SAMPLE(table, ID_TABLE);\n    SAMPLE(chair, ID_CHAIR);\n    SAMPLE(stool, ID_STOOL);\n    SAMPLE(plate, ID_PLATE);\n    SAMPLE(apple, applePart);\n    SAMPLE(tree, treePart);\n    \n    if (!(data.skip == ID_BOTTLE || data.skip == ID_BOTTLE_CAP)) {\n        int bottlePart = ID_BOTTLE;\n        float bottle = bottleSDF(bottlePart, p - BOTTLE_POS);\n        SAMPLE(bottle, bottlePart);\n    }\n    \n    return dist;\n}\n\nbool march(inout Data data, in vec3 ro, in vec3 rd) {\n    float dist = 0.0;\n    float sig = data.sig;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = sig * getDist(data, p);\n        dist += next;\n        if (abs(next) <= NEAR) break;\n        if (abs(dist) >= FAR) return false;\n    }\n    \n    vec3 p = ro+rd*dist;\n    data.p = p;\n    data.d = abs(dist);\n    float distCenter = distance(p.xz, SCENE_CENTER.xz);\n    vec2 e = vec2(data.id == ID_TREE_LEAFS ? 0.1 : data.id == ID_GROUND ? (0.01 + (0.08*smoothstep(5.0, 9.0, distCenter))) :  0.001, 0.0);\n    data.n = normalize(getDist(data, p) - vec3(\n        getDist(data, p - e.xyy),\n        getDist(data, p - e.yxy),\n        getDist(data, p - e.yyx)\n    ));\n    data.uv = boxUv(data.p, data.n);\n    \n    return true;\n}\n\nfloat getShadow(in vec3 ro, in vec3 rd, in float near, in float far) {\n    float dist = 0.0;\n    \n    Data data = NEW_DATA;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p);\n        dist += next;\n        if (abs(next) <= min(near, NEAR)) break;\n        if (abs(dist) >= min(far, FAR)) return 1.0;\n    }\n    \n    dist = abs(dist);\n    \n    return clamp(dist / max(1., (1.+abs(near))), 0.0, 0.8);\n}\n\nvec3 cloudTexture(in vec2 uv) {\n    vec3 col = vec3(0.0);\n    \n    float t = T*0.1;\n    float z = (0.5+(0.5*cos(t)));\n    vec3 ln = noise(uv, 1.1315, 0.6);\n    vec3 cancel = noise(uv + ang2(-t+(ln.x+ln.y+ln.z)), 33.0392815, 0.6);  \n    ln = max(vec3(0.0), ln - cancel);\n    \n    vec2 shift = ang2(t+(cancel.x+cancel.y+cancel.z+ln.x+ln.y+ln.z));\n    \n    vec3 hf = noise((uv*2.0) + shift, 4.49281, 2.5);\n    \n    float cycleF = 0.5;\n    float cycle = mod(t*(1.6+(cancel.z*0.005)), 3.0+cycleF);\n    float clouds = ln.x;\n    clouds = mix(clouds, ln.z, smoothstep(1.0 - cycleF, 1.0 + cycleF, cycle));\n    clouds = mix(clouds, ln.y, smoothstep(2.0 - cycleF, 2.0 + cycleF, cycle));\n    clouds = mix(clouds, ln.x, smoothstep(3.0 - cycleF, 3.0 + cycleF, cycle));\n    \n    cycle = mod(t*2., 3.0+cycleF);\n    float hc = hf.x;\n    hc = mix(hc, hf.z, smoothstep(1.0 - cycleF, 1.0 + cycleF, cycle));\n    hc = mix(hc, hf.y, smoothstep(2.0 - cycleF, 2.0 + cycleF, cycle));\n    hc = mix(hc, hf.x, smoothstep(3.0 - cycleF, 3.0 + cycleF, cycle));\n    \n    hc = pow(hc, 1.6);\n    clouds += hc;\n    \n    clouds = clamp(clouds, 0.0, 1.0);\n    return vec3(clouds);\n}\n\nvec3 getSky(in vec3 ro, in vec3 rd, in Light light) {\n    vec3 col = rgb(20, 134, 197);\n    vec2 uv = rd.xz / rd.y;\n    \n    vec3 L = getLightDir(light, ro);\n    float VdotL = cdot(rd, L);\n    \n    vec3 clouds = cloudTexture(uv);\n    col = mix(col, vec3(1.0), clouds.r);\n\n    vec3 lightContrib = light.c * light.s * pow(VdotL, 32.0) * pow(luma(col), 2.0);\n    col += lightContrib;\n    \n    col /= vec3(1.0) + col;\n    col = pow(col, vec3(1.0 / 0.7));\n    return col;\n}\n\n\n\nvec3 mudTexture(in vec2 uv, out float wetPart) {\n    vec3 col = vec3(0.0);\n    vec2 p = uv;\n    \n    vec2 id = floor(uv*8.0);\n    vec2 lv = fract(uv*8.0);\n    vec2 sv = lv*lv*(3.0-2.0*lv);\n    \n    float freq = 6.3;\n    float seed = 2.223459;\n    vec3 a = noise(id, seed, freq);\n    vec3 b = noise(id + vec2(1, 0), seed, freq);\n    vec3 c = noise(id + vec2(0, 1), seed, freq);\n    vec3 d = noise(id + vec2(1, 1), seed, freq);\n    \n    vec3 it = mix(mix(a, b, sv.x), mix(c, d, sv.x), sv.y);\n    \n    \n    float scratches1 = max(0.0, 1.0 - 60.0*abs(it.x - it.y));\n    uv.xy *= rot(it.z*0.3);\n    vec3 pat = textureLod(iChannel3, uv*0.1, 0.0).rgb;\n    \n    float scratches2 = max(0.0, 1.0 - 6.0*abs(pat.x - pat.y));\n    \n    float scratches = mix(scratches1, scratches2, it.z);\n    \n    vec3 c1 = rgb(88, 78, 69);\n    vec3 c2 = rgb(105, 86, 67); // wet\n    vec3 c3 = rgb(145, 117, 85);\n    \n    col = mix(col, c1*c1, pat.x);\n    col = mix(col, c2*c2, pat.y);\n    col = mix(col, c3, pat.z);\n    \n    vec3 wet = noise(p + (vec2(pat.x, pat.y)*0.1+(pat.z*0.1)), 7.75421, 6.5);\n    wet = max(vec3(0.0), wet - (wet.z*0.2));\n    float w = smoothstep(0.44, 0.5, wet.x);\n    col = mix(col, c2*c2*c2, w);\n    \n    wetPart = w;\n    return col;\n}\n\nvec3 appleTexture(in vec2 uv) {\n    vec3 col = vec3(0.0);\n    \n    vec3 c1 = rgb(152, 2, 14);\n    vec3 c2 = rgb(251, 83, 56);\n    vec3 c3 = rgb(168, 42, 46);\n    vec3 c4 = rgb(239, 175, 58);\n    \n    vec3 ra = noise(uv, 12.12, 32.0);\n    vec3 spots = noise(uv, 7.654, 4.0);\n    \n    spots = abs(spots-(ra.x*spots.y));\n    spots = pow(spots, vec3(4.0));\n    \n    col = mix(col, c1, ra.x);\n    col = mix(col, c2, ra.y*0.4);\n    col = mix(col, c3, ra.z*0.3);\n    \n    col = mix(col, vec3(1, 0, 0), 0.4);\n    \n    col += textureLod(iChannel3, ra.xz*0.05, 0.).r*ra.z*0.16;\n    \n    col = col*col;\n    \n    col = mix(col, c4, spots.x);\n    \n    return col;\n}\n\nvec3 marbleTexture(in vec2 uv) {\n    vec3 col = vec3(0.0);\n    \n    vec3 c1 = rgb(163, 152, 125);\n    vec3 c2 = rgb(229, 227, 226);\n    vec3 c3 = rgb(55, 56, 58);\n    \n    \n    vec3 spread = noise(uv, 3.9281, 32.0);\n    vec3 patterns = noise(uv + spread.xz*0.09+spread.y*0.06, 7.7721, 10.1);\n    \n    float pat = pow(patterns.x, 2.0);\n    pat = abs(pat - (patterns.y*0.5));\n    pat = max(0.0, 1.0-smoothstep(0.002, 0.04, pat));\n\n    \n    col = mix(col, c1, spread.x);\n    col = mix(col, c2, spread.y);\n    col = mix(col, c3*pat*c3, clamp(pat*spread.z, 0.0, 1.0));\n    col += luma(col);\n    col += spread.y*c1;\n    col *= (0.5+spread.x*0.5);\n    \n    return col;\n}\n\n\nvec3 woodTexture(in vec2 uv) {\n    vec3 col = vec3(0.0);\n    \n    vec3 c1 = rgb(176, 142, 115);\n    vec3 c2 = rgb(74, 48, 42);\n    vec3 c3 = rgb(195, 135, 90);\n    vec3 c4 = rgb(86, 51, 29);\n    \n    vec3 alt = noise(uv, 8.83159, 128.);\n    \n    col = mix(col, c1, alt.x);\n    col = mix(col, c2, alt.y);\n    col = mix(col, c3, alt.z);\n    \n    float lines = ((alt.z+alt.x+alt.y)/3.)*cos((uv.x-sin(uv.y*TAU))*TAU+cos((uv.x-uv.y)*TAU));\n    lines = pow(max(0.0, 0.7*(1.0-abs(lines))), 3.0);\n    \n    col = mix(col, c2*c2*c2, lines*alt.y);\n    col = mix(col, c4, clamp(0.1*fract(10.38921*(tan(lines*6.831)+cos(alt.x+alt.y+alt.z))), 0.0, 1.0));\n    col += luma(col);\n    col = col*col*col*col;\n    return col;\n}\n\nvec3 brickTexture(in vec2 uv) {\n    vec3 col = vec3(0.0);\n    vec2 id = floor(uv);\n    vec2 lv = fract(uv);\n    \n    vec3 alt = noise(id, 1.931, 10.0);\n    vec3 nh = noise(uv*2.0-1.0, 3.91851, 20.0);\n    nh = clamp(pow(nh, vec3(2.0))*2., 0.0, 1.0);\n    \n    vec3 c1 = rgb(147, 84, 62);\n    vec3 c2 = rgb(138, 85, 60);\n    vec3 c3 = rgb(181, 61, 8);\n    \n    col = mix(col, c2, alt.x);\n    col = mix(col, c1, nh.x);\n    col = mix(col, c3*c3, nh.y*0.3);\n    \n    float g = max(0.0, 1.0 - ceil(min(lv.x+(nh.x*0.01), lv.y+(nh.y*0.01)) - (0.04 + (nh.z*0.1))));\n    \n    col += g * alt.z*alt.y*(0.5+(nh.x));\n   \n    col *= (0.8 + (nh.z*0.2));\n    \n    return col;\n}\n\nvec3 grassTexture(in vec2 uv) {\n    vec3 col = vec3(0.0);\n    vec3 n = noise(uv, 0.0, 9.5);\n    vec3 nh = noise(uv*2.0, 3.981, 20.0);\n    \n    vec3 c1 = rgb(75, 84, 35);\n    vec3 c2 = rgb(79, 146, 56);\n    vec3 c3 = rgb(103, 91, 19);\n    vec3 c4 = rgb(85, 79, 24);\n    vec3 c5 = rgb(107, 64, 0);\n    \n    col = mix(col, c1, n.x);\n    col = mix(col, c2, n.y);\n    col = mix(col, c3, n.z);\n    \n    col = mix(col, c4*c4, nh.x);\n    col = mix(col, c5, nh.y*nh.z);\n    \n    float amp = (n.x + n.y + n.z + nh.x + nh.y + nh.z) / 6.0;\n    \n    col *= (0.5+nh.z*0.5);\n    col += nh.x/M_PI;\n    col *= (0.4+nh.y*0.5);\n    \n    return col;\n}\n\n\n\nvec3 leafTexture(in vec2 uv, out float leafs) {\n    vec3 col = vec3(0.0);\n    vec3 n = noise(uv, 2.1981, 9.2);\n    float pa = abs(n.x-n.y);\n    pa = smoothstep(0.09, 0.9, pa);\n    \n    vec3 le = noise(uv*1.6, 1.62321, 20.0);\n    float ll = abs(le.y-(le.z*0.7));\n    ll = pow(ll, 2.0);\n    ll = smoothstep(0.01, 0.7, ll);\n    vec3 nh = noise(uv*2.0, 3.981, 20.0);\n    \n    vec3 c1 = rgb(52, 114, 0);\n    vec3 c2 = rgb(136, 188, 5);\n    vec3 c3 = rgb(17, 75, 0);\n    vec3 c4 = rgb(16, 28, 14);\n    vec3 c5 = rgb(107, 64, 0);\n    \n    col = mix(col, c3, pa);\n    col = mix(col, c1, 0.2*nh.x*max(0.0, 1.0-pa*90.));\n    col = mix(col, c2*c2*c2, 0.3*(n.y*nh.y*nh.x*nh.z));\n    \n    float gloss = pow(pa, 3.0)*2.;\n    \n    col += gloss;\n    col += c5*pow(n.x, 5.0);\n    col = mix(col, c4*0.9*c4*c4, pow(max(0.0, 1.0-ll), 32.0));\n    leafs = ll;\n    \n    col += col;\n    \n    return clamp(col, 0., 1.);\n}\n\n\nvec3 corkTexture(in vec2 uv) {\n    vec3 col = vec3(0.0);\n    \n    vec3 c1 = rgb(194, 114, 56);\n    vec3 c2 = rgb(208, 177, 126);\n    vec3 c3 = rgb(164, 107, 55);\n    \n    vec3 alt = textureLod(iChannel3, uv*0.2, 0.0).rgb;\n    \n    col = mix(col, c1, alt.x);\n    col = mix(col, c2, alt.y);\n    col = mix(col, c3, alt.z);\n    \n    col *= ((alt.y+alt.x+alt.z)/2.);\n    \n    return col;\n}\n\nvec3 getAlbedoBox(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec2 uv = data.uv;\n    \n    uv *= 4.0;\n    \n    col += brickTexture(uv);\n    \n    vec3 bump = vec3(0.0);\n    ESTIMATE_BUMP_FOR(bump, uv, col, data.n, brickTexture, 0.5, 0.6, 0.8, violet,0.0);\n    \n    data.n = bump;\n    \n    data.m.spec = max(luma(col), 1.0 - distance(col, vec3(0.77)));\n    \n    return col;\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec2 uv = data.uv;\n    \n    col += grassTexture(uv);\n        \n    vec3 bump = vec3(0.0);\n    ESTIMATE_BUMP_FOR(bump, uv, col, data.n, grassTexture, 0.5, 1., 0.9, violet, 0.0);\n    \n    \n    vec3 mudOffset = textureLod(iChannel3, uv*0.09, 0.0).rgb;\n    vec3 p = data.p;\n    float distTree = distance(p.xz + vec2(-0.4, 0.4), TREE_POS.xz);\n    \n    float mudRad = 2.0 + (mudOffset.x*2.0-1.0);\n    float mf = max(0.0, 1.0 - smoothstep(mudRad - 0.1, mudRad + 0.1, distTree));\n    \n    float wetPart = 0.0;\n    vec3 mud = mudTexture(uv*0.2, wetPart);\n    col = mix(col, mud*mud, mf);\n    \n    float nextRough = max(0.3, 1.0 - (wetPart*0.3));\n    float nextSpec = max(wetPart*0.6, nextRough*0.2);\n    data.m.spec = mix(data.m.spec, nextSpec, mf);\n    data.m.rough = mix(data.m.rough, nextRough, mf);\n    \n    bump = normalize(mix(bump, data.n, wetPart*mf));\n    \n    data.n = bump;\n    \n    return col;\n}\n\nvec3 getAlbedoTable(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec2 uv = data.uv * 2.;\n    \n    col += woodTexture(uv);\n        \n    vec3 bump = vec3(0.0);\n    ESTIMATE_BUMP_FOR(bump, uv, col, data.n, woodTexture, 0.5, 0.2, 0.7, luma, 0.0);\n\n    data.n = bump;\n\n\n    return col;\n}\n\nvec3 getAlbedoStool(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec2 uv = data.uv * 2.;\n    \n    col += woodTexture(uv);\n        \n    vec3 bump = vec3(0.0);\n    ESTIMATE_BUMP_FOR(bump, uv, col, data.n, woodTexture, 0.5, 0.2, 0.6, luma, 0.0);\n\n    data.n = bump;\n    \n\n    return col;\n}\n\nvec3 getAlbedoChair(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec2 uv = data.uv * 2.;\n    \n    col += woodTexture(uv);\n        \n    vec3 bump = vec3(0.0);\n    ESTIMATE_BUMP_FOR(bump, uv, col, data.n, woodTexture, 0.5, 0.2, 0.6, luma, 0.0);\n\n    data.n = bump;\n    data.m.rough = 1.0;\n\n\n    return col;\n}\n\nvec3 getAlbedoPlate(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec2 uv = data.uv;\n    \n    col += marbleTexture(uv);\n\n    data.m.rough = distance(col, vec3(0.99));\n    data.m.spec = luma(col)*2.;\n\n    return col;\n}\n\nvec3 getAlbedoApple(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec2 uv = sphereUv(data.n)*0.2;//data.uv*0.5;\n    \n    col += appleTexture(uv);\n    data.m.rough = max(0.9, 1.0-luma(col));\n\n\n    return col;\n}\n\nvec3 getAlbedoTreeLeafs(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec2 uv = mix(data.uv, sphereUv(data.n), 0.8)*2.;\n    \n    float leafs = 0.0;\n    col += leafTexture(uv, leafs);\n    data.m.rough = clamp((col.g+(col.b*0.5)+(col.r*0.1))*9., max(0.1, 1.0-leafs*4.), 1.0);\n    data.m.spec = clamp(pow(leafs, 2.0)*32., 0.0, 0.8);\n    \n    col = mix(col, grassTexture(uv*0.5), 0.3);\n\n    return col;\n}\n\nvec3 getAlbedoTreeStem(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec2 uv = vec2(acos(data.n.y), atan(data.p.x, data.p.z));\n    uv = ((data.n.xz*2.) * (data.p.y/2.))*0.5;\n    //mix(data.uv, sphereUv(data.n), 0.3)*0.4;\n    \n    col += woodTexture(uv);\n    col = (col*col)/2.;\n        \n    vec3 bump = vec3(0.0);\n    ESTIMATE_BUMP_FOR(bump, uv, col, data.n, woodTexture, 0.5, 0.2, 0.7, luma, 0.0);\n\n    data.n = bump;\n    data.m.rough = 1.0;\n    data.m.spec = luma(col)+col.r+col.b;\n\n\n    return col;\n}\n\nvec3 getAlbedoBottle(inout Data data) {\n    vec2 uv = data.uv;\n    vec3 col = vec3(0.0);\n\n    vec3 c1 = rgb(56, 129, 24);\n    \n    col += c1*c1*c1;\n\n    data.m.ior = 1.47;\n    \n    return col;\n}\n\nvec3 getAlbedoBottleCap(inout Data data) {\n    vec2 uv = data.uv;\n    vec3 col = vec3(0.0);\n\n    col = corkTexture(uv);\n\n    return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_BOX: return getAlbedoBox(data); break;\n        case ID_WALL: return getAlbedoBox(data); break;\n        case ID_GROUND: return getAlbedoGround(data); break;\n        case ID_APPLE_STEM: return getAlbedoGround(data); break;\n        case ID_TABLE: return getAlbedoTable(data); break;\n        case ID_STOOL: return getAlbedoStool(data); break;\n        case ID_CHAIR: return getAlbedoChair(data); break;\n        case ID_PLATE: return getAlbedoPlate(data); break;\n        case ID_APPLE: return getAlbedoApple(data); break;\n        case ID_TREE_LEAFS: return getAlbedoTreeLeafs(data); break;\n        case ID_TREE_STEM: return getAlbedoTreeStem(data); break;\n        case ID_BOTTLE: return getAlbedoBottle(data); break;\n        case ID_BOTTLE_CAP: return getAlbedoBottleCap(data); break;\n    }\n    \n    return vec3(0.77);\n}\n\nvec3 forEachLight(inout Data data, in Light light, in vec3 ro, in vec3 rd) {\n    vec3 col = vec3(0.0);\n    vec3 albedo = getAlbedo(data);\n    vec3 diffuse = albedo / M_PI;\n    vec3 n = data.n;\n    vec3 p = data.p;\n    vec3 L = getLightDir(light, p);\n    vec3 ref = reflect(L, n);\n    float VdotR = cdot(rd, ref);\n    float spec = data.m.spec * pow(VdotR, 32.0);\n    vec3 att = getLightAtt(light, p, n);\n    \n    float shadow = getShadow(p+(n*NEAR*2.), L, data.d, (\n        light.type == LIGHT_AMBIENT ? FAR : distance(p, light.p)\n    ));\n    \n    col += (diffuse + spec) * att * shadow;\n    \n    return col;\n}\n\nvec3 simpleRender(inout Data data, in Light light, in vec3 ro, in vec3 rd) {\n    if (march(data, ro, rd)) return forEachLight(data, light, ro, rd);\n    return vec3(0.0);\n}\n\nvec3 lightEffect(inout Data data, in Light light, in vec3 ro, in vec3 rd) {\n    vec3 col = vec3(0.0);\n    \n    vec3 L = getLightDir(light, ro);\n    float VdotL = cdot(rd, L);\n    \n    vec3 lightContrib = light.c * light.s * pow(VdotL, 24.0);\n    \n    col += lightContrib;\n    \n    return col;\n}\n\n#define NUM_LIGHTS 1\n\nvec3 renderRefract(in Light light, float ior, vec3 rd, vec3 p, vec3 n) {\n    vec3 enterColor = vec3(0.0);\n    vec3 exitColor = vec3(0.0);\n    \n    Data enterData = NEW_DATA;\n\n    Data exitData = NEW_DATA;\n    \n    vec3 rEnter = (refract(rd, n, 1.0/ior));\n    \n    enterData.sig = -1.;\n    \n    enterColor += simpleRender(enterData, light, p - (n*NEAR*2.), rEnter);\n    \n    vec3 rExit = (refract(rEnter, -enterData.n, ior));\n    \n    if (length(rExit) <= 0.0001) {\n        rExit = reflect(rEnter,-enterData.n);\n    }\n    \n    exitData.skip = enterData.id;\n    exitData.sig = 1.0;\n    \n    exitColor += simpleRender(exitData, light, enterData.p, rExit);\n\n    \n    \n    return enterColor+exitColor;\n}\n\nvec3 render(inout Data data, in vec3 ro, in vec3 rd, inout float depth) {\n    vec3 col = vec3(0.0);\n    Light lights[NUM_LIGHTS];\n    lights[0] = Light(vec3(1, 2, -3), vec3(0.0), vec3(1, 0.97, 0.725), 2.0, LIGHT_AMBIENT);\n    \n    \n    float rough = 0.0;\n    vec3 mixf = vec3(1.0);\n    float primDist = FAR;\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    float primIor = 0.0;\n    vec3 primP = vec3(0.0);\n    vec3 primN = vec3(0.0);\n    vec3 primRo = ro;\n    vec3 primRd = rd;\n    bool hit = false;\n    \n    for (int j = ZERO; j < 2; j++) {\n        if (j > 0) {\n            mixf = vec3(1.0) * max(0.0, 1.0 - rough);\n            \n            vec3 f0 = vec3(0.04);\n            float NdotV = abs(dot(data.n, rd));\n            vec3 F = fresnelSchlickRoughness(NdotV, f0, rough);\n            vec3 E = EnvBRDFApprox(vec3(0.2), rough*rough, NdotV);\n            mixf *= (F * E.x + E.y);\n            \n           // mixf *= F;\n        }\n    \n        if (march(data, ro, rd)) {\n            hit = true;\n            if (j <= 0) {\n                primDist = data.d;\n                primP = data.p;\n                primRo = ro;\n                primRd = rd;\n            }\n            for (int i = ZERO; i < NUM_LIGHTS; i++) {\n                Light light = lights[i];\n                col += forEachLight(data, light, ro, rd) * mixf;\n                col += lightEffect(data, light, ro, rd) * mixf;\n                if (j <= 0) {\n                    primIor = data.m.ior;\n                    primN = data.n;\n                }\n            }\n            \n            rough = data.m.rough;\n            rd = reflect(rd, data.n);\n            ro = data.p+(data.n*NEAR*2.);\n            if (rough >= 0.99) break;\n        } else {\n            col += getSky(ro, rd, lights[0])*mixf;\n\n            for (int i = ZERO; i < NUM_LIGHTS; i++) {\n                Light light = lights[i];\n                col += lightEffect(data, light, ro, rd) * mixf;\n            }\n        }\n    }\n\n    if (hit && primIor > 0.01) {\n        col += renderRefract(lights[0], primIor, primRd, primP, primN);\n    }\n    \n    depth = primDist/FAR;\n    \n    col += smoothstep(0.05, 1.0, depth)* max(0.0, 1.0 - (dotup*3.));\n    \n    return col;\n}\n\n\nvec4 getMouseDelta() {\n    return texelFetch(iChannel0, ivec2(0), 0).rgba;\n}\n\n\nvec3 avoidPoint(vec3 ro, vec3 p) {\n    float dist = distance(ro, p);\n    vec3 dir = normalize(p - ro);\n    float idist = max(0.0, 1.0-smoothstep(2.1-0.5, 2.1+0.5, dist));\n    ro = mix(ro, ro-(dir*2.+(idist*0.9)), idist);\n    ro.y = mix(ro.y, clamp(idist*3., 0.05, 16.0), idist);\n    return ro;\n}\n\nvoid getRay(in vec2 uv, in vec2 m, inout vec3 ro, inout vec3 rd) {\n    ro = vec3(0, 1.6, -4.0);\n    rd = normalize(vec3(uv.xy, 1.0));\n    \n    vec4 md = getMouseDelta();\n    \n    m.x = (md.x-0.5/R.x) / R.y;\n    m.y = (md.y-0.5*R.y) / R.y;\n    \n    \n//    rd = look(uv, PLATE_POS, ro);\n\n    \n    //ro.y += 6.0;\n    \n   // rd = look(uv, vec3(0.0), ro);\n    \n    if ((md.z > 0.0 || md.x > 0.0) && md.z > 0.0) {\n      //  ro.yz *= rot(m.y*TAU);\n     //   ro.xz *= rot(m.x*TAU);\n        \n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n    } else {\n        ro.y += 1.0;\n        float a = T*0.2;\n        vec3 lookp = SCENE_CENTER;\n        vec3 movement = vec3(cos(a), 0, sin(a))*6.0;\n        vec3 ogMovement = movement;\n        \n        \n        float mf = (0.5+(0.5*cos((T+3.9981)*0.2)));\n        float mfy = (0.5+(0.5*sin(T*0.5)));\n        \n        \n        mf = mix(mf, 0.0, mfy*0.3);\n        \n      //  lookp = mix(lookp, PLATE_POS, mf);\n        \n      \n        \n        ro.y = mix(ro.y, 4.0, mfy);\n        \n        \n        vec3 treePos = TREE_POS;\n        vec3 leafPos = TREE_POS + vec3(0, TREE_HEIGHT, 0);\n        \n        \n        float nrSteps = 6.0;\n        float transTime = 0.9;\n        \n        float time = T*0.2;\n        \n        vec3 platePos = PLATE_POS + vec3(0, 0.1, 0);\n        vec3 bottlePos = BOTTLE_POS;\n        float frame = 1.0;\n        vec3 ogRo = ro;\n        \n        lookp = onCycle(lookp, platePos, time, nrSteps, transTime, frame);\n        movement = onCycle(movement, normalize(platePos - ro), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        lookp = onCycle(lookp, platePos, time, nrSteps, transTime, frame);\n        movement = onCycle(movement, normalize(platePos - ro)*1.6, time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        lookp = onCycle(lookp, bottlePos, time, nrSteps, transTime, frame);\n        movement = onCycle(movement, normalize(bottlePos - ro), time, nrSteps, transTime, frame);\n        ro = onCycle(ro, bottlePos - vec3(-1., -0.63, -2.), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        lookp = onCycle(lookp, TREE_POS, time, nrSteps, transTime, frame);\n        movement = onCycle(movement, normalize(TREE_POS - ro)*0.7, time, nrSteps, transTime, frame);\n        ro = onCycle(ro, ogRo, time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        lookp = onCycle(lookp, SCENE_CENTER, time, nrSteps, transTime, frame);\n        movement = onCycle(movement, ogMovement + vec3(0, 9, 0), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        lookp = onCycle(lookp, SCENE_CENTER, time, nrSteps, transTime, frame);\n        movement = onCycle(movement, ogMovement, time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro += movement;\n        \n        \n        ro = avoidPoint(ro, treePos);\n        ro = avoidPoint(ro, leafPos);\n        \n        \n        rd = look(uv, lookp, ro);\n    }\n    \n    ro.y = max(0.5, ro.y);\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec2 m = (iMouse.xy-0.5*R.xy)/R.y;\n    \n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    getRay(uv, m, ro, rd);\n    Data data = NEW_DATA;\n    \n    float depth = 1.0;\n    \n    #ifdef DEBUG_TEXTURE\n    col += DEBUG_TEXTURE(fc.xy/R.xy);\n    #else\n    col += render(data, ro, rd, depth);\n    #endif\n    \n    col += (col*luma(col));\n    //col += luma(col)/TAU;\n    \n    col /= vec3(1.0) + col;\n    col = pow(col, vec3(1.0 / 2.2));\n    \n    O = vec4(clamp(col, 0.0, 1.0), depth);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}