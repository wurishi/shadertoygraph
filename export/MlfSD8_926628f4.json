{"ver":"0.1","info":{"id":"MlfSD8","date":"1436278406","viewed":134,"name":"REND1","username":"dennixtreme","description":"x","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["workshop"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\n// --- Maths\n// -----------------------------------------------------------------------------------------------\n//\n\nvec3 Rotate(vec3 p, float x, float y, float z)\n{\n    vec4 pos = vec4(p, 1.0);\n    \n    // --- EX3: implement rotation transforms using vec4 !!!\n\tmat4 rx = mat4(1.0,    0.0,    0.0,  0.0,\n                   0.0, cos(x), -sin(x), 0.0,\n                   0.0, sin(x),  cos(x), 0.0,\n                   0.0,    0.0,     0.0, 1.0);\n    \n\tmat4 ry = mat4(cos(y), 0.0, -sin(y), 0.0,\n                      0.0, 1.0,     0.0, 0.0,\n                   sin(y), 0.0,  cos(y), 0.0,\n                      0.0, 0.0,     0.0, 1.0);\n    \n\tmat4 rz = mat4(cos(z), -sin(z), 0.0, 0.0,\n                   sin(z),  cos(z), 0.0, 0.0,\n                      0.0,     0.0, 1.0, 0.0,\n                      0.0,     0.0, 0.0, 1.0);\n\n\tvec4 rpos = pos * rz * ry * rx;\n    return rpos.xyz;\n}\n\nvec3 Scale(vec3 p, float sx, float sy, float sz)\n{\n    vec4 pos = vec4(p, 1.0);\n    \n    // --- EX2: implement scale transform using vec4 !!!\n    mat4 s = mat4(sx, 0.0, 0.0, 0.0, \n                  0.0, sy, 0.0, 0.0, \n                  0.0, 0.0, sz, 0.0, \n                  0.0, 0.0, 0.0, 1.0);\n    vec4 spos = s * pos;\n    return spos.xyz;\n}\n\nvec3 Translate(vec3 p, float tx, float ty, float tz)\n{\n    vec4 pos = vec4(p, 1.0);\n    \n    // --- EX1: implement translation tranform using vec4 !!!\n    mat4 t = mat4(1.0, 0.0, 0.0, tx,\n                  0.0, 1.0, 0.0, ty,\n                  0.0, 0.0, 1.0, tz,\n                  0.0, 0.0, 0.0, 1.0);\n    vec4 tpos = pos * t;\n    return tpos.xyz;\n}\n\n// --- SDF shapes\n// -----------------------------------------------------------------------------------------------\n//\n\nfloat Sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat Torus(vec3 p, vec2 r)\n{\n  vec2 q = vec2(length(p.xz) - r.x, p.y);\n  return length(q) - r.y;\n}\n\n// --- SDF operations\n// -----------------------------------------------------------------------------------------------\n//\n\nvec2 Union(vec2 d1, vec2 d2)\n{\n    return d1.x < d2.x ? d1 : d2;\n}\n\n// --- main stuff\n// -----------------------------------------------------------------------------------------------\n//\n\nvec2 Scene(vec3 p)\n{\n    // --- initial positions\n    vec3 ps1 = p;\n    vec3 ps2 = p - vec3(2.0, 0.0, 0.0);\n    vec3 pt = p + vec3(2.0, 0.0, 0.0);\n    \n    // --- update positions\n    float stime = sin(iTime);\n    float ctime = cos(iTime);\n    float sf = 1.0 - abs(stime) * 0.5;\n    ps1 = Scale(ps1, sf, sf, sf);\n    \n    float rfx = stime;\n    float rfy = stime;\n    float rfz = ctime;\n    pt = Rotate(pt, rfx, rfy, rfz);\n    \n    ps2 = Translate(ps2, 0.0, stime, 0.0);\n    \n    // --- compute shapes (SDF estimation, material index)\n    vec2 torus = vec2(Torus(pt, vec2(0.55, 0.1)), 1.0);\n    vec2 sphere0 = vec2(Sphere(ps1, 0.25), 2.0);\n    vec2 sphere1 = vec2(Sphere(ps2, 0.25), 3.0);\n    \n    // --- compute SDF for scene\n    return Union(torus, Union(sphere0, sphere1));\n}\n\nvec3 RayMarch(vec3 origin, vec3 direction)\n{\n    float maxDist = 200.0;\n    float totalDistance = 0.0;\n    int totalSteps = 0;\n    float selectedMaterial = 0.0;\n    for (int steps = 0; steps < 100; ++steps)\n    {\n        vec3 point = origin + totalDistance * direction;\n        vec2 dist = Scene(point);\n        if (dist.x < 0.0002 || totalDistance > maxDist)\n            break;\n        totalDistance += dist.x;\n        totalSteps++;\n        selectedMaterial = dist.y;\n    }\n    if (totalDistance > maxDist)\n    \tselectedMaterial = 0.0;\n    return vec3(totalDistance, selectedMaterial, float(totalSteps) / 200.0);\n}\n\nvec3 Normal(vec3 pos)\n{\n    vec3 eps = vec3(0.0001, 0.0, 0.0);\n    vec3 pos00 = (pos + eps.xyy);\n    vec3 pos01 = (pos - eps.xyy);\n    vec3 pos10 = (pos + eps.yxy);\n    vec3 pos11 = (pos - eps.yxy);\n    vec3 pos20 = (pos + eps.yyx);\n    vec3 pos21 = (pos - eps.yyx);\n\tvec3 normal = vec3(Scene(pos00).x - Scene(pos01).x, \n                       Scene(pos10).x - Scene(pos11).x, \n                       Scene(pos20).x - Scene(pos21).x);\n\treturn normalize(normal);\n}\n\nvec3 Render(vec3 origin, vec3 direction, vec2 uv)\n{\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    vec3 res = RayMarch(origin, direction);\n    \n    // --- background\n    color = mix(vec3(1.00, 0.90, 0.60), vec3(0.50, 0.70, 1.00), pow(uv.y * 0.5 + 0.5, 0.5)) * 0.7;\n    \n    // --- if we have a material\n    if (res.y > 0.0)\n    {\n        // --- get surface normal\n    \tvec3 newPos = origin + res.x * direction;\n    \tvec3 normal = Normal(newPos);\n        \n        // --- ambient color\n        vec3 ambient = vec3(0.50, 0.70, 1.00) * 0.1;\n        vec3 lightDirection = normalize(vec3(0.6, 0.7, 0.5));\n        \n        // --- diffuse lighting\n        vec3 diffuse = vec3(1.0);\n        float ndotl = clamp(dot(normal, lightDirection), 0.0, 1.0);\n        \n        // --- EX4: compute diffuse lighting with given direction and color !!!\n        \n        if (res.y > 0.95)\n            diffuse *= vec3(0.7, 0.0, 0.0) * texture(iChannel0, newPos.xy).rgb;\n       \tif (res.y > 1.95)\n           diffuse = vec3(0.0);\n        if (res.y > 2.95)\n            diffuse = vec3(0.0);\n        \n        diffuse *= ndotl;\n        // --- half-vector\n        vec3 halfVector = normalize(lightDirection - direction);\n        \n        // --- fresnel\n        vec3 reflectance = vec3(0.0);\n        vec3 fresnel = vec3(0.0);\n        \n        // --- material specific stuff for the torus\n        if (res.y > 0.95)\n            reflectance = vec3(0.04); // plastic\n        if (res.y > 1.95)\n            reflectance = vec3(1.022, 0.782, 0.344); // gold\n        if (res.y > 2.95)\n            reflectance = vec3(0.955, 0.638, 0.538); // copper\n                 \n        float ldoth = 1.0 - dot(normal, halfVector);\n        fresnel = reflectance + (1.0 - reflectance) * pow(ldoth, 5.0);\n        // --- EX5: compute fresnel !!!\n        \n        // --- NDF stuff\n        float ndoth = clamp(dot(normal, halfVector), 0.0, 1.0);\n        \n        float roughness = 0.0;\n        if (res.y > 0.95)\n            roughness = 0.4;\n        if (res.y > 1.95)\n            roughness = 0.4;\n        if (res.y > 2.95)\n            roughness = 0.2;\n        \n        float atrsqr = pow(roughness, 4.0);\n        float num = pow((pow(ndoth, 2.0) * (atrsqr - 1.0) + 1.0), 2.0);\n        // --- EX6: compute NDF !!!!\n\t\tfloat D = atrsqr/(num*3.1415926535);\n       \tvec3 specular = vec3(D);\n        \n        // --- final color\n        color = diffuse + specular * fresnel * ndotl;\n        //color = fresnel;\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 offsets[5];\n    offsets[0] = vec2(0.0, 0.0);\n    offsets[1] = vec2(0.5, 0.0);\n    offsets[2] = vec2(-0.5, -0.0);\n    offsets[3] = vec2(0.0, 0.5);\n    offsets[4] = vec2(0.0, -0.5);\n    \n    vec2 mo = iMouse.xy / iResolution.xy;\n    \n    vec3 cam_pos = vec3(-0.3 + mo.x * 2.0, -0.2 + mo.y * 2.0, 3.0);\n    vec3 cam_up = vec3(0.0, 1.0, 0.0);\n    vec3 cam_right = vec3(1.0, 0.0, 0.0);\n    vec3 cam_forward = normalize(cross(cam_up, cam_right));\n    float focal_length = 1.77;\n    vec3 color = vec3(0.0);\n    \n    for (int i = 0; i < 1; ++i)\n    {\n        vec2 coords_ss = (fragCoord.xy + offsets[i]) / iResolution.xy;\n    \tvec2 coords_cs = 2.0 * coords_ss - 1.0;\n   \t \tcoords_cs.x *= iResolution.x / iResolution.y;\n        \n        vec3 ray_d = normalize(cam_forward * focal_length + cam_right * coords_cs.x + cam_up * coords_cs.y);\n    \tvec3 ray_o = cam_pos;\n    \n        color += Render(ray_o, ray_d, coords_cs);\n    }\n    \n    //color /= 5.0;\n\tcolor = pow(color, vec3(0.4545));\n\n    fragColor = vec4(color, 1.0);\n}\n\n","name":"","description":"","type":"image"}]}