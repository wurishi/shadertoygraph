{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n\n  More info here:\n  http://blog.demofox.org/2012/06/18/diy-synth-3-sampling-mixing-and-band-limited-wave-forms/\n\n  There's probably some better ways to do this without so much branching logic, but\n  doing it this way for clarity.  If you know of better branchless ways, feel free to\n  comment!!\n*/\n\n#define PI\t\t\t\t\t\t3.14159265359\n#define TWO_PI \t\t\t\t\t(2.0 * PI)\n#define TWO_OVER_PI     \t\t(2.0 / PI)\n#define FOUR_OVER_PI   \t\t\t(4.0 / PI)\n#define EIGHT_OVER_PI_SQUARED \t(8.0 / (PI * PI))\n\n// the frequency of the tone\n#define TONE_FREQUENCY \t440.0  //A4\n\n// how long each tone plays, in seconds\n#define TONE_LENGTH 2.0\n\n// how long to fade in and out each wave form\n#define ENVELOPE_SIZE 0.2\n\n// how many harmonics (sine waves) for each bandlimited wave form\n#define NUM_HARMONICS_TRIANGLE\t3\n#define NUM_HARMONICS_SAW \t\t9\n#define NUM_HARMONICS_SQUARE \t11\n\n//========================= BANDLIMITED WAVE FORMS\n\nfloat makeTriangleBL(float time)\n{\n    float value = 0.0;\n    \n    float signflip = 1.0;\n    \n    for (int index = 0; index < NUM_HARMONICS_TRIANGLE; ++index) {\n        float harmonicIndex = float(index) * 2.0 + 1.0;\n        value += sin(TONE_FREQUENCY*TWO_PI*time*harmonicIndex) / (harmonicIndex * harmonicIndex) * signflip;\n        signflip *= -1.0;\n    }\n    \n    return value * EIGHT_OVER_PI_SQUARED;\n}\n\n\nfloat makeSawBL(float time)\n{\n    float value = 0.0;\n    \n    for (int index = 1; index <= NUM_HARMONICS_SAW; ++index) {\n        float harmonicIndex = float(index);\n        value += sin(TONE_FREQUENCY*TWO_PI*time*harmonicIndex) / harmonicIndex;\n    }\n    \n    return value * TWO_OVER_PI;\n}\n\nfloat makeSquareBL(float time)\n{\n    float value = 0.0;\n    \n    for (int index = 0; index < NUM_HARMONICS_SQUARE; ++index) {\n        float harmonicIndex = float(index) * 2.0 + 1.0;\n        value += sin(TONE_FREQUENCY*TWO_PI*time*harmonicIndex) / harmonicIndex;\n    }\n    \n    // the 0.9 shouldn't be needed, but for some reason the amplitude seems wrong\n    // without it...\n    return value * FOUR_OVER_PI * 0.9;\n}\n\n//========================= WAVE FORMS\n\nfloat makeTriangle(float time)\n{\n    return abs(fract(time * TONE_FREQUENCY)-.5)*4.0-1.0;\n}\n\nfloat makeSaw(float time)\n{\n    return 2.0 - (mod(time * TONE_FREQUENCY, 1.0) * 2.0) - 1.0;\n}\n\nfloat makeSquare(float time)\n{\n    return step(fract(time * TONE_FREQUENCY), 0.5)*2.0-1.0;\n}\n\n//========================= DRIVER CODE\n\nfloat makeSound(float time)\n{   \n    // figure out how much to scale the volume to account for envelope\n    // on the front and back of each wave form    \n    float noteTime = mod(iTime, TONE_LENGTH);\n    float envelope = 1.0;\n    if (noteTime < ENVELOPE_SIZE)\n        envelope = noteTime / ENVELOPE_SIZE;\n    else if (noteTime > (TONE_LENGTH - ENVELOPE_SIZE))\n        envelope = 1.0 - ((noteTime - (TONE_LENGTH - ENVELOPE_SIZE)) / ENVELOPE_SIZE);\n    \n    // play the apropriate wave form based on time\n    float mode = mod(iTime / TONE_LENGTH, 6.0);\n    if (mode > 5.0)\n        return makeSquareBL(time) * envelope;\n    else if (mode > 4.0)\n        return makeSquare(time) * envelope;    \n    else if (mode > 3.0)\n        return makeSawBL(time) * envelope;  \n    else if (mode > 2.0)\n        return makeSaw(time) * envelope;\n    else if (mode > 1.0)\n        return makeTriangleBL(time) * envelope;        \n    else\n        return makeTriangle(time) * envelope;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 percent = (fragCoord.xy / iResolution.xy);\n    percent.x /= 256.0;\n    percent.y = (percent.y) * 2.2 - 1.1;\n    \n    // calculate a time offset to show the wave form moving across the screen\n    float timeOffset = mod(iTime / 200.0, TONE_LENGTH);\n    float value = makeSound(percent.x + timeOffset);\n\n    if (abs(percent.y-value) < 0.01)\n        fragColor = vec4(0.0,1.0,0.0,1.0);\n    else\n    {\n        float value2 = makeSound(percent.x + timeOffset - 0.00001);\n        \n        if ((percent.y > value && percent.y < value2) ||\n            (percent.y < value && percent.y > value2))\n        \tfragColor = vec4(0.0,1.0,0.0,1.0);\n       \telse\n\t\t\tfragColor = vec4(0.0,0.0,0.0,1.0);\n    }\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n\n  More info here:\n  http://blog.demofox.org/2012/06/18/diy-synth-3-sampling-mixing-and-band-limited-wave-forms/\n\n  There's probably some better ways to do this without so much branching logic, but\n  doing it this way for clarity.  If you know of better branchless ways, feel free to\n  comment!!\n*/\n\n#define PI\t\t\t\t\t\t3.14159265359\n#define TWO_PI \t\t\t\t\t(2.0 * PI)\n#define TWO_OVER_PI     \t\t(2.0 / PI)\n#define FOUR_OVER_PI   \t\t\t(4.0 / PI)\n#define EIGHT_OVER_PI_SQUARED \t(8.0 / (PI * PI))\n\n// the frequency of the tone\n#define TONE_FREQUENCY \t440.0  //A4\n\n// how long each tone plays, in seconds\n#define TONE_LENGTH 2.0\n\n// how long to fade in and out each wave form\n#define ENVELOPE_SIZE 0.2\n\n// how many harmonics (sine waves) for each bandlimited wave form\n#define NUM_HARMONICS_TRIANGLE\t3\n#define NUM_HARMONICS_SAW \t\t9\n#define NUM_HARMONICS_SQUARE \t11\n\n//========================= BANDLIMITED WAVE FORMS\n\nfloat makeTriangleBL(float time)\n{\n    float value = 0.0;\n    \n    float signflip = 1.0;\n    \n    for (int index = 0; index < NUM_HARMONICS_TRIANGLE; ++index) {\n        float harmonicIndex = float(index) * 2.0 + 1.0;\n        value += sin(TONE_FREQUENCY*TWO_PI*time*harmonicIndex) / (harmonicIndex * harmonicIndex) * signflip;\n        signflip *= -1.0;\n    }\n    \n    return value * EIGHT_OVER_PI_SQUARED;\n}\n\n\nfloat makeSawBL(float time)\n{\n    float value = 0.0;\n    \n    for (int index = 1; index <= NUM_HARMONICS_SAW; ++index) {\n        float harmonicIndex = float(index);\n        value += sin(TONE_FREQUENCY*TWO_PI*time*harmonicIndex) / harmonicIndex;\n    }\n    \n    return value * TWO_OVER_PI;\n}\n\nfloat makeSquareBL(float time)\n{\n    float value = 0.0;\n    \n    for (int index = 0; index < NUM_HARMONICS_SQUARE; ++index) {\n        float harmonicIndex = float(index) * 2.0 + 1.0;\n        value += sin(TONE_FREQUENCY*TWO_PI*time*harmonicIndex) / harmonicIndex;\n    }\n    \n    // the 0.9 shouldn't be needed, but for some reason the amplitude seems wrong\n    // without it...\n    return value * FOUR_OVER_PI * 0.9;\n}\n\n//========================= WAVE FORMS\nfloat makeSine(float time)\n{\n    return sin(TONE_FREQUENCY*TWO_PI*time);\n}\n\nfloat makeTriangle(float time)\n{\n    return abs(fract(time * TONE_FREQUENCY)-.5)*4.0-1.0;\n}\n\nfloat makeSaw(float time)\n{\n    return (mod(time * TONE_FREQUENCY, 1.0) * 2.0) - 1.0;\n}\n\nfloat makeSquare(float time)\n{\n    return step(fract(time * TONE_FREQUENCY), 0.5)*2.0-1.0;\n}\n\n//========================= DRIVER CODE\n\nfloat makeSound(float time)\n{\n    // figure out how much to scale the volume to account for envelope\n    // on the front and back of each wave form\n    float noteTime = mod(time, TONE_LENGTH);\n    float envelope = 1.0;\n    if (noteTime < ENVELOPE_SIZE)\n        envelope = noteTime / ENVELOPE_SIZE;\n    else if (noteTime > (TONE_LENGTH - ENVELOPE_SIZE))\n        envelope = 1.0 - ((noteTime - (TONE_LENGTH - ENVELOPE_SIZE)) / ENVELOPE_SIZE);\n    \n    // play the apropriate wave form based on time       \n    float mode = mod(time / TONE_LENGTH, 6.0);\n    if (mode > 5.0)\n        return makeSquareBL(time) * envelope;\n    else if (mode > 4.0)\n        return makeSquare(time) * envelope;    \n    else if (mode > 3.0)\n        return makeSawBL(time) * envelope;  \n    else if (mode > 2.0)\n        return makeSaw(time) * envelope;\n    else if (mode > 1.0)\n        return makeTriangleBL(time) * envelope;        \n    else\n        return makeTriangle(time) * envelope;        \n}\n\nvec2 mainSound( in int samp,float time)\n{\n    // generate a mono channel sound\n    float monoSound = makeSound(time);\n    \n    // return our mono sound as a stereo sound, using it for both channels\n    return vec2(monoSound);\n}","name":"Sound","description":"","type":"sound"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":true,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldlSD2","date":"1407115291","viewed":1855,"name":"Bandlimited Audio Wave Forms","username":"demofox","description":"Saw, triangle and square waves.  Bandlimited versions which hurt the ears less and don't have aliasing problems. \nMore info here:\nhttp://blog.demofox.org/2012/06/18/diy-synth-3-sampling-mixing-and-band-limited-wave-forms/","likes":33,"published":1,"flags":8,"usePreview":0,"tags":["sound","triangle","square","saw","bandlimited"],"hasliked":0,"parentid":"","parentname":""}}