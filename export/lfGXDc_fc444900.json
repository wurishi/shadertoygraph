{"ver":"0.1","info":{"id":"lfGXDc","date":"1715858891","viewed":95,"name":"Physics playground spinning top","username":"kastorp","description":"set FrictionConstant=0. and see collision point rotation","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["3d","collision","simulation","physics","mpr","verlet","rigidbody"],"hasliked":0,"parentid":"4ftXWf","parentname":"Physics engine playground"},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Physics playground spinning top\" by kastorp\n//-------------------------------------------------\n\nvec3 rayPos,rayDir;\nfloat minDist;\nvec3 minDistNormal;\nfloat minDistMaterial;\nvec2 minDistUv;\n\nvoid renderBox(int ci){\n     vec4 q =\n         getCubeQuat(ci),\n         qi=vec4(-q.xyz,q.w);\n     vec3 pos = getCubePos(ci);     \n     vec3 b =size(ci);\n     int sh = shape(ci);\n\n \n     float d;\n     int iter;   \n     obj oo;\n     oo.b= size(ci);\n     oo.s=sh;\n     oo.c=pos;\n     oo.r=q;\n     \n     vec2 t= iSupportFunction( rayPos-pos, rayDir, oo,oNor);\n     if( minDist>t.x && t.x>0. ){\n         minDist=t.x-.0002;\n         minDistNormal= oNor;\n         minDistMaterial= sh>0?float(sh)+2.: material(ci);  \n         vec3 lp=rotateInv(q,rayPos+t.x*rayDir-pos);\n         minDistUv=lp.xy;\n     }\n}\n\nvoid renderScene()\n{\n    minDist = 1e30;   \n    for(int i=0;i<(CUBECOUNT);i++)\n    {       \n        //bounding sphere\n        if ( length(cross(getCubePos(i)-rayPos,rayDir))<=length(size(i)))\n        {\n            renderBox(i);\n        }\n    }\n}\n\nvec3 getDiffuse()\n{\n    vec3 difColor;\n    if (minDistMaterial==0.) difColor = texture(iChannel0,rayPos.zx/8.0).xyz; // floor\n    else if(minDistMaterial==1.) difColor =  texture(iChannel1,minDistUv/2.).xyz; // floor\n    else if(minDistMaterial>=2.) difColor = texture(iChannel2,minDistUv/2.).xyz;\n    else difColor=vec3(1,0,0);\n    \n    if(minDistMaterial==3.) difColor = difColor.zyx;\n    if(minDistMaterial==4.) difColor = difColor.yxz;\n    if(minDistMaterial==5.) difColor = difColor.xyz;\n    if(minDistMaterial==6.) difColor = difColor.zxy;\n    if(minDistMaterial==7.) difColor = difColor.yzx;\n    return difColor;\n}\n\nvec3 backGround(vec3 dir,vec3 pos)\n{\n\tfloat f = max(dir.y,0.0)*0.5+0.5;\n\tvec3 color = 1.0-vec3(1,0.85,0.7)*f;\n\tcolor *= dir.x*-0.3+1.0;\n\t\n\tif (dot(sunDir,dir)>0.0) // sun reflected on cubes\n\t{\n\t f = max(length(cross(sunDir,dir))*10.0,1.0);\n\t\t\n\t color += vec3(1,0.9,0.7)*40.0/(f*f*f*f);\n\t}\n\treturn color;\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t\t r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    float a =sin(iTime*.2),d=22.;\n    if(iMouse.z>0.){ a = iMouse.x/iResolution.x*4.-2.; d*=iMouse.y/iResolution.y+.8;}\n\tvec3 campos = vec3(-d*sin(a),15.,-d*cos(a));   \n    vec2 uv= (fragCoord-iResolution.xy*.5)/iResolution.y*.8;\n    vec3 pdir = getRayDir(campos,vec3(0,2.5,0), uv); \n\n    rayPos = campos;\n    rayDir=pdir;\n\n    renderScene();\n           \n    if (minDist<1e30)\n    {\n        minDistNormal = normalize(minDistNormal);\n        const vec3 sunColor = vec3(1.0,0.8,0.5)*1.0;\n        const vec3 skyColor = vec3(1.0,1.2,1.5)*0.6;\n        rayPos += rayDir*minDist;\n        vec3 firstHitPos = rayPos;\n        vec3 refdir = reflect(rayDir,minDistNormal);\n        float f = 1.-max(dot(minDistNormal,-rayDir),0.);\n        float fresnel = 0.65*f*f*f*f*f+0.05;\n\n        vec3 difColor =getDiffuse();\n        \n        fragColor = vec4(difColor*skyColor*((minDistNormal).y*0.5+0.5),0.);\n        float suncos = dot((minDistNormal),sunDir);\n        if (suncos>0.0)\n        {\n            // spot sun light pointing on the thrown cube.\n            vec3 v = cross(sunDir,rayPos-vec3(0))/20.;\n            suncos *= max(0.,1.0-dot(v,v));\n            rayDir = sunDir;\n    \t    renderScene();\n\t        if (minDist==1e30) \n            {\n                fragColor.xyz += difColor * suncos * sunColor;\n            }\n        }\n        \n        rayPos = firstHitPos;\n        rayDir = refdir;\n        renderScene();\n        \n        vec3 refColor;\n        if (minDist<1e30)\n        {\n            rayPos += rayDir * minDist;\n            vec3 difColor = getDiffuse();\n            \n            refColor = difColor*(normalize(minDistNormal).y*0.5+0.5);\n        }\n        else\n        {\n            refColor = backGround(rayDir,rayPos);\n        }\n        fragColor.xyz = mix(fragColor.xyz,refColor,fresnel);\n    }\n    else\n    {\n\t\tfragColor = vec4(backGround(pdir,campos),0.0);\n    }\n \n}\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    int ci = int(fragCoord.x);\n    int cj = int(fragCoord.y);\n    int k= 0;\n\n    bool intersect =false;\n    float idepth;\n    vec3 idir,ipos;\n    \n    obj o1,o2;\n    o1.c= getCubePos(ci); \n    o1.b= size(ci);\n    o1.s= shape(ci);\n    o1.r= getCubeQuat(ci);\n\n    o2.c= getCubePos(cj); \n    o2.b= size(cj);\n    o2.s= shape(cj);\n    o2.r= getCubeQuat(cj);\n    \n  if(length(getCubePos(ci)-getCubePos(cj))>length(size(ci))+length(size(cj))) intersect=false;\n  else intersect =  MPRPenetration( o1 ,  o2 , idepth,  idir,   ipos )>=0;\n    \n    \n    fragColor = vec4(intersect?ipos:vec3(0),intersect);\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nvec3 pos;\nvec4 quat;\nvec3 vel;\nvec3 rotvel;\n\n\nvec4 findSepPlane(int cia,int cib)\n{\n\n    if (cia>= CUBECOUNT) discard;\n    if (cib>=cia) discard;\n    float best=1e30;\n    vec4 bestsep=vec4(0,1,0,0);\n    \n    bool intersect ;\n    float idepth;\n    vec3 idir,ipos;\n    \n    obj o1,o2;\n    o1.c= getCubePos(cia); \n    o1.b= size(cia);\n    o1.s=shape(cia);\n    o1.r= getCubeQuat(cia);\n\n    o2.c= getCubePos(cib); \n    o2.b= size(cib);\n    o2.s= shape(cib);\n    o2.r= getCubeQuat(cib);\n    \n    if(getCollPos(cia,cib)==vec3(0.)) return vec4(0,1,0,0); \n    int res=  MPRPenetration( o1 , o2 , idepth,  idir,   ipos );\n    if(res>=0)\n    {\n         bestsep.w = idepth;\n         bestsep.xyz = -idir;       \n    }\n\n    return vec4(normalize(bestsep.xyz),bestsep.w);;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int pixelx = int(fragCoord.x);\n    int pixely = int(fragCoord.y);\n    \n    fragColor = vec4(0.0,0.0,0.0,0.0);\n    \n    if (pixelx<CUBECOUNT) \n    {\n    \n        fragColor = findSepPlane(pixelx,pixely);\n        return;\n    }\n    if (pixely>=4 || pixely<2) discard; // just output velocity and rotational velocity\n    int cubei = pixelx-CUBECOUNT;\n    \n    \n    pos = getCubePos(cubei);\n    quat = getCubeQuat(cubei);\n    vel = getCubeVel(cubei);\n    rotvel = getCubeRotVel(cubei);\n    \n    if (cubei>=STATIC_CUBE_COUNT)\n    {\n    // apply forces (just the changes)\n    for(int i=0;i<int(CUBECOUNT)-1;i++)\n    {\n        int ci,cj;\n        float scaler;\n        if (i<cubei)\n        {\n\t        ci = cubei;\n            cj = i;\n            scaler  = 1.0;\n\t\t // if the other cube cannot be pushed away, because its's the floor or other unmovable, \n          // this one moves double amount\n            if (cj< STATIC_CUBE_COUNT) scaler = 2.0; \n        }\n        else\n        {\n           ci = i+1;\n           cj = cubei;\n           scaler = -1.0; // applying the opposite forces on the cube pair\n        }\n        if (!(length(getCubePos(ci)-getCubePos(cj))>length(size(ci))+length(size(cj)) && cj!=0)) // bounding check\n        //for(uint j=0u;j<uint(CP);j++)\n        {\n            vec3 forcepos = getCollPos(ci,cj).xyz;\n            if (forcepos.x!=0.0)\n            {\n\t            vec3 force = getForce(ci,cj).xyz;\n                \n                force *= scaler*FS;\n                vel += dt*force;\n                rotvel -= dt* cross(forcepos-pos,force)/RotationalImmobilityTensor;\n            }\n        }\n    }\n    \n\n    }\n    \n    fragColor = vec4(vel, 0.0);\n    if (pixely==3) fragColor = vec4(rotvel, 0.0);\n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\nvec3 getCubeVelQP(int ci,vec3 querypos)\n{\n    return cross(querypos-getCubePos(ci),\n    \n    getCubeTempRotVel(ci)) + getCubeTempVel(ci);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n  \n    int ci = int(fragCoord.x);\n    int cj = int(fragCoord.y);\n    \n    if (cj>=ci) discard;\n    if (ci>=CUBECOUNT) discard;\n    \n    if ((length(getCubePos(ci)-getCubePos(cj))>length(size(ci))+length(size(cj))&& cj!=0))  // bounding check\n    {\n        fragColor = vec4(0.,0.,0.,0.);\n        return;\n    }\n    \n\n    vec3 totalForce  =  getForce(ci,cj).xyz;\n    vec3 collpos =   getCollPos(ci,cj).xyz;\n\n\n    if (collpos.xyz!=vec3(0.)) // x==0 means no collision at the force denoted by this pixel\n    {\n        vec3 veldiff = getCubeVelQP(cj,collpos)-getCubeVelQP(ci,collpos);\n\n        vec3 collisNormal = getCollNorm(ci,cj).xyz;\n\n        totalForce += veldiff*elasticConstant*dt;\n\n        float perpart = dot(collisNormal,totalForce);\n        vec3 tangentialpart = totalForce-collisNormal*perpart;\n\n        if (length(tangentialpart)>perpart*FrictionConstant)\n        {\n            tangentialpart *= (perpart*FrictionConstant)/length(tangentialpart);\n            totalForce = tangentialpart + collisNormal*perpart;\n        }\n\n        if (perpart<0.0) totalForce = vec3(0.);\n        \n    }\n    else totalForce= vec3(0.);\n     \n    if (INIT) totalForce = vec3(0.);\n    fragColor = vec4(totalForce,1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\nvec3 pos;\nvec4 quat;\nvec3 vel;\nvec3 rotvel;\n\nvoid initScene(int cubei)\n{\n        vel = vec3(0.,0.,0.);\n        rotvel = vec3(0.,0.,0.);\n        quat = vec4(0.0,0.0,0.0,1.0);\n        if (cubei<STATIC_CUBE_COUNT) // static floor\n        {\n            pos = vec3(0,-1,0);\n\n            if(cubei==0){\n                vec3 ro = vec3(SLOPE,0,0.);\n                quat = rotateRotation(normalize(vec4(0.0,0.0,0.0,1.0)),ro);\n                \n            }\n            if(cubei>0){\n                vec3 ro = vec3(0.,PI*(float(cubei)*2.0)/4.,0.);\n                pos = rotateAxis(ro,   vec3(0,0,20));\n                quat = rotateRotation(normalize(vec4(0.0,0.0,0.0,1.0)),ro);\n            }\n            return;\n        }\n    \n    \tcubei-=STATIC_CUBE_COUNT;\n        float cubeif = float(cubei);\n    \tint div = CUBE_PILES;\n    \tvec3 ro = vec3(PI*.55,0.,0.);\n    \tpos = vec3(0.1,3,.1) + vec3(cubei/3,0,cubei%3)*4.5 ;\n    \n        quat = rotateRotation(normalize(vec4(0.0,0.0,0.0,1.0)),ro);\n    \n        vel = -vec3(cubei ,0.0,0.00)*.02;\n        rotvel = vec3(0,.5,0)*float(cubei%2*2-1);// vec3(cubeif*-0.0001*cos(float(iFrame)),0.0,cubeif*-0.0001); // randomize start setup        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int pixelx = int(fragCoord.x);\n    int pixely = int(fragCoord.y);\n    \n    fragColor = vec4(0.0,0.0,0.0,0.0);\n    \n    if (pixely>=4) discard;\n    if (pixelx>=(CUBECOUNT)) discard;\n    int cubei = pixelx;\n    \n    \n    pos =  getCubePos(cubei);\n    quat = getCubeQuat(cubei);\n    vel = getCubeVel(cubei);\n    rotvel = getCubeRotVel(cubei);\n    int ncoll=0;\n    \n    if (cubei>=STATIC_CUBE_COUNT)\n    {\n        // apply forces (just the changes)\n    \n        for(int i=0;i<CUBECOUNT-1;i++)\n        {\n            int ci,cj;\n            float scaler;\n            if (i<cubei)\n            {\n                ci = cubei;\n                cj = i;\n                scaler  = 1.0;\n             // if the other cube cannot be pushed away, because its's the floor or other unmovable, \n              // this one moves double amount\n                if (cj<STATIC_CUBE_COUNT) scaler = 2.0; \n            }\n            else\n            {\n               ci = i+1;\n               cj = cubei;\n               scaler = -1.0; // applying the opposite forces on the cube pair\n            }\n\n           if (!(length(getCubePos(ci)-getCubePos(cj))>length(size(ci))+length(size(cj)) && cj>=STATIC_CUBE_COUNT)) // bounding check\n            {\n                vec3 forcepos = getCollPos(ci,cj).xyz;\n                if (forcepos!=vec3(0))\n                {\n                    vec3 force = getForce(ci,cj);\n                    ncoll++;\n                    // add repulsive force\n                    vec4 collisnormal = getCollNorm(ci,cj);\n                    force += collisnormal.xyz*collisnormal.w*repulsion*dt;\n\n\n                    force *= scaler*FS;\n                    vel += dt*force;\n                    //vec3 t =normalize(cross(forcepos-pos,force));\n                    //float ri = max(.1, dot(RotationalImmobilityTensor,t*t));\n                    rotvel -= dt*cross(forcepos-pos,force)/(RotationalImmobilityTensor);\n                }\n            }\n        }\n    \n        // move by adding velocity to position, and rotate\n        pos += dt*vel;\n        quat = rotateRotation(quat,rotvel*dt);\n        vel.y += dt*gravity;\n        if(length(vel)>2.) vel*=.98;\n    }\n\n    if(INIT)  initScene(cubei);\n    \n    fragColor = vec4(pos, ncoll);\n    if (pixely==1) fragColor = quat;\n    if (pixely==2) fragColor = vec4(vel, 0.0);\n    if (pixely==3) fragColor = vec4(rotvel, 0.0);\n    \n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define CUBECOUNT 11\n#define STATIC_CUBE_COUNT 5\n#define CUBE_PILES 10\n#define INIT (iFrame%(60*18)==0)\n\nconst float PI = 3.141592653;\nconst float gravity = -0.004;\nconst float repulsion = 0.003;\nconst float FrictionConstant = 0.9;\nconst float elasticConstant = 0.004;\nconst float FS = 50.;\nconst float dt=1.; //if dt is lower, you can increase both elasticConstant and repulsion\nconst vec3 sunDir = normalize(vec3(0.8,.8,-0.3));\nconst float RotationalImmobilityTensor =(1.8);    // vec3(sz.y*sz.y+sz.z*sz.z,sz.x*sz.x+sz.z*sz.z,sz.x*sz.x+sz.y*sz.y);\n\nvec3  size( int i) { return int(i)==0?vec3(30,1,30):i<STATIC_CUBE_COUNT?vec3(20,6,.5) : vec3(2.);}\nint shape(int i) {return i<STATIC_CUBE_COUNT?0:i<8?3:4;}\nfloat material(int i) {return i<STATIC_CUBE_COUNT?0.:i<15? 2.: 1.;}\n#define SLOPE 0.\n\n\n//---------------------------------------------\n\nvec4 readTex(sampler2D ch, int cx,int cy)  { return texelFetch(ch,ivec2(cx,cy),0);}\nvec3 getCubePos(sampler2D ch,int ci)       { \n    vec3  p=  readTex(ch,ci,0).xyz;\n    return mod( p+vec3(50),vec3(100.))-vec3(50);\n}\nint  getNColl(sampler2D ch,int ci)         { return int(readTex(ch,ci,0).w);}\nvec4 getCubeQuat(sampler2D ch, int ci)     { return readTex(ch, ci,1).xyzw;}\nvec3 getCubeVel(sampler2D ch,int ci)       { return readTex(ch,ci,2).xyz;}\nvec3 getCubeRotVel(sampler2D ch,int ci)    { return readTex(ch,ci,3).xyz;}\nvec3 getCubeTempVel(sampler2D ch,int ci)   { return readTex(ch,ci+(CUBECOUNT),2).xyz;}\nvec3 getCubeTempRotVel(sampler2D ch,int ci){ return readTex(ch,ci+(CUBECOUNT),3).xyz;}\n\n#define  getCollPos(ci,cj) readTex(iChannel0, ci,cj).xyz\n#define  getCollNorm(ci,cj) readTex(iChannel1, ci,cj)\n#define  getForce(ci,cj) readTex(iChannel2, ci,cj).xyz\n#define  getCubePos( ci) getCubePos(iChannel3, ci)\n#define  getNColl(  ci) getNColl(iChannel3, ci)\n#define  getCubeQuat( ci) getCubeQuat(iChannel3, ci)\n#define  getCubeTempVel( ci) getCubeTempVel(iChannel1, ci)\n#define  getCubeVel(  ci) getCubeVel(iChannel3, ci)\n#define  getCubeRotVel( ci) getCubeRotVel(iChannel3, ci)\n#define  getCubeTempRotVel( ci) getCubeTempRotVel(iChannel1, ci)\n\nvec3 rotateAxisAngle(vec3 axis,float angle,vec3 v)\n{\n\treturn v*cos(angle) + axis*((v*axis) * (1.0-cos(angle))) + cross(v,axis)*sin(angle);\n}\n\nvec3 rotateAxis(vec3 axis,vec3 v)\n{\n    float len = length(axis);\n    if (len==0.0) return v;\n    else return rotateAxisAngle(normalize(axis),len,v);\n}\n\nvec3 rotate(vec4 quat,vec3 v)\n{\n    float sinsqr = (1.0-quat.w*quat.w);\n    if (sinsqr!=0.0)\n    {\n        v=v*quat.w + quat.xyz*((dot(v,quat.xyz)*(1.0-quat.w))*(1.0/sinsqr)) + cross(v,quat.xyz);\n        v=v*quat.w + quat.xyz*((dot(v,quat.xyz)*(1.0-quat.w))*(1.0/sinsqr)) + cross(v,quat.xyz);\n    }\n    return v;\n}\n\nvec3 rotateInv(vec4 quat,vec3 v)\n{\n    quat.xyz*=-1.;\n    return rotate( quat, v);\n}\n\n\nvec4 getRotation(vec3 x,vec3 y,vec3 z){\n    // convert back to quaternion\n\tfloat trace = x.x + y.y + z.z;\n    vec4 q;\n\tif( trace > 0.0 ) {\n\t\tfloat s = 0.5 / sqrt(trace+ 1.0);\n\t\tq=vec4(( z.y - y.z ) * s,( x.z - z.x ) * s,( y.x - x.y )*s, 0.25 / s);\t\t\n\t} else {\n\t\tif ( x.x > y.y && x.x > z.z ) {\n\t\t    float s = 2.0 * sqrt( 1.0 + x.x - y.y - z.z);\n\t\t\tq =vec4( 0.25 * s,(x.y + y.x ) / s,(x.z + z.x ) / s,(z.y - y.z ) / s);\n\t\t} else if (y.y > z.z) {\n\t\t\tfloat s = 2.0 * sqrt( 1.0 + y.y - x.x - z.z);\n\t\t\tq = vec4((x.y + y.x ) / s,0.25 * s, (y.z + z.y ) / s,(x.z - z.x ) / s);\n\t\t} else {\n\t\t\tfloat s = 2.0 * sqrt( 1.0 + z.z - x.x - y.y ); \n\t\t\tq= vec4((x.z + z.x ) / s,(y.z + z.y ) / s,0.25 * s,(y.x - x.y ) / s);\n\t\t}\n\t}   \n    return normalize(q); \n}\n\nvec4 rotateRotation(vec4 q,vec3 axis) {\n    vec3 x,y,z; // conversion to 3 perpendicular vectors, and rotation\n    x = rotateAxis(axis,rotate(q,vec3(1.0,0.0,0.0)));\n    y = rotateAxis(axis,rotate(q,vec3(0.0,1.0,0.0)));\n    z = rotateAxis(axis,rotate(q,vec3(0.0,0.0,1.0)));\n    return getRotation(x,y,z);\n}  \n#define NOHIT 1e30\nvec3 oFuv; \nvec3 oNor;\n\n//----------------------------------\n\nstruct obj{\n    vec3 c; //center\n    vec3 b; //bounding box\n    vec4 r; //rotation quat\n    int s; //shape (0=box,1=sphere,2=cylinder,3=cone, 5=segment)\n};\n\nobj _ob1,_ob2;\nvec3 a,b,c,d; //difference simplex\nvec3 a1,b1,c1,d1; //obj1 simplex\nvec3 a2,b2,c2,d2; //obj2 simplex\n\n//-------------------\n\nvec3 supMax(vec3 d, vec3 a, vec3 b)\n{\n    return dot(d,a) > dot(d,b) ? a : b;\n}\n\n\nvec3 support(vec3 dir, obj o){\n    const float h=(sqrt(5.)-1.)*.5,h2=h*h;\n    if(o.s==1) //SPHERE\n        return normalize(dir)*(o.b.x);\n    else if(o.s==3) //CONE\n        return  \n             supMax( dir,\n            vec3(normalize(dir.xy)*o.b.z, .5*o.b.z) ,\n            vec3(0.,0,-o.b.z));\n    else if(o.s==4) //DOUBLE CONE\n        return  supMax(dir,\n           vec3(0,0,-o.b.z),\n             supMax( dir,\n            vec3(normalize(dir.xy)*o.b.z, 0.) ,\n            vec3(0,0,o.b.z)));\n#if 0            \n    else  if(o.s==5){ //OLOID\n        if(dir.x>0.) return  supMax(dir, vec3(0,0,-o.b.z), supMax( dir,\n             vec3(normalize(dir.xy)*o.b.z, 0.) ,vec3(0,0,o.b.z)));\n         else return supMax(dir, vec3(0,-o.b.z,0), supMax( dir,\n            vec3(normalize(dir.xz).x, 0.,normalize(dir.xz).y)*o.b.z ,vec3(0,o.b.z,0)));  \n    } \n    else  if(o.s==6){ //HEXASPHERICON\n        if(dir.x<0.) dir.yz*=mat2(.5,-sqrt(.75),sqrt(.75),.5);\n        vec3 s =  supMax(dir,\n             supMax( dir,  vec3(normalize(dir.xy)*o.b.z*sqrt(.75), o.b.z *.5) , vec3(0,0,o.b.z)),\n             supMax( dir,  vec3(normalize(dir.xy)*o.b.z*sqrt(.75) , -o.b.z*.5) , vec3(0,0,-o.b.z))\n             );\n        if(dir.x<0.) s.yz*=mat2(.5,sqrt(.75),-sqrt(.75),.5);     \n        return s;\n    } \n#endif            \n   else return sign(dir)*o.b; // BOX (DEFAULT)\n} \n\nvec3 supportr(vec3 dir, obj o, mat3 rm){\n    dir=dir*rm;\n    vec3 s= support(dir,  o);\n    return s *transpose(rm)+ o.c ;\n}\n\n//Minkowsky difference support function\nvec3 support(vec3 dir,out vec3  s1, out vec3 s2){\n\n    //mat3 rt = mrot(_ob1.r);\n    vec4 q =_ob1.r;\n    s1 = support(rotateInv(q,dir),_ob1);   \n    s1=  rotate(q, s1 +rotateInv(q,_ob1.c)); \n    \n    q = (_ob2.r);\n    s2 = support(rotateInv(q,-dir),_ob2);\n    s2=  -rotate(q,s2 +rotateInv(q,_ob2.c));\n    \n    return s1+s2;\n}\n\n\n\n//------------------------------------\n\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n// Iq:  https://www.shadertoy.com/view/ttfGWl\nfloat  PointTriDist2(in vec3 p,  in vec3 v0, in vec3 v1, in vec3 v2, out vec3 dir  )\n{\n    vec3 v10 = v1 - v0; vec3 p0 = p - v0;\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v02 = v0 - v2; vec3 p2 = p - v2;\n    vec3 nor = cross( v10, v02 );\n\n    if( dot(cross(v10,nor),p0)<0.0 ) dir=  v0 + v10*clamp( dot(p0,v10)/dot2(v10), 0.0, 1.0 );\n    else if( dot(cross(v21,nor),p1)<0.0 ) dir= v1 + v21*clamp( dot(p1,v21)/dot2(v21), 0.0, 1.0 );\n    else if( dot(cross(v02,nor),p2)<0.0 ) dir= v2 + v02*clamp( dot(p2,v02)/dot2(v02), 0.0, 1.0 );\n    else dir= p - nor*dot(nor,p0)/dot2(nor);\n    return dot2(p-dir);  \n}\n\n\nint MPRPenetration(obj o1 , obj o2 , out float depth, out vec3 dir, out vec3 pos)\n{\n    \n    int res=0;\n    _ob1 =o1;\n    _ob2 =o2;\n    \n    dir= vec3(0,1,0);\n    // Phase 1: Portal discovery\n    //---------------------------------\n\n   \n    // vertex a is center of portal\n    a1=_ob1.c;a2=-_ob2.c; a= a1+a2; \n    \n    if (a==vec3(0)) {a1+= vec3(1e-3,0,0); a+=vec3(1e-3,0,0);}\n\n    // vertex b = support in direction of origin\n\tdir= -normalize(a);  \n    b = support(dir,b1,b2);\n\n    // test if origin isn't outside of b\n    if ( dot(b, dir) <=0.) return -1;\n\n    // vertex c\n\tdir = cross(a, b);\t\t\t\t\t \t\t\t\t\t   \n    if (length(dir)==0.){\n        if (b == (_ob1.c-_ob2.c)) {\n            // origin lies on b\n            // Touching contact on portal's b - so depth is zero and direction\n            // is unimportant and pos can be guessed\n            depth = 0.;\n            dir= vec3(0,1,0); \n            pos=(b1+b2)*.5;\n            return 1;\n        }\n        else {\n            // Origin lies on a-b segment.\n            // Depth is distance to b, direction also and position must be\n            // computed\n             pos=(b1+b2)*.5;\n             depth = length(b);\n             dir =normalize(b);\n             return 2;\n        }\n    }\n    \n\tc= support(normalize(dir),c1,c2);\n    if ( dot(c, dir) <=0.) return -1;\n\n    // vertex d direction\n\tdir= normalize(cross(b-a,c-a));\n\n    // it is better to form portal faces to be oriented \"outside\" origin\n    if (dot(dir, a) > 0.){\n        vec3 t =b; b=c;c=t; t =b1; b1=c1;c1=t; t =b2; b2=c2;c2=t;//swap\n        dir *=-1.;\n    }\n        \n    int iter=0;\n    while ( iter <20){\n        \n\t\td= support(dir,d1,d2);        \n        if (dot(d, dir) <=0.) return -1;\n       \n        // test if origin is outside (b, a, d) - set c as d and continue\n        if ( dot(cross (b,d), a)  < 0. ){c=d;c1=d1;c2=d2; }\n        // test if origin is outside (d, a, c) - set b as d and continue\n        else if (dot(cross (d,c), a) < 0. ){ b=d;b1=d1;b2=d2; }\n        else break;\n        \n        dir =normalize(cross( b-a, c-a));\n        iter++;\n    }\n       \n    \n    // Phase 2: Portal refinement\n    //---------------------------------\n    vec3 v4,v41,v42;\n    iter=2;   \n    while (iter<20){\n        iter++;\n        // compute direction outside the portal (from v0 throught v1,v2,v3 face)\n        dir= normalize(cross( c-b, d-b));\n\n        // test if origin is inside the portal\n        if ( dot(dir, b)>= 0.) {res= iter;break;}\n\n        // get next support point\n        v4 = support(dir,v41,v42);\n\n        // find the smallest dot product of dir and {a-v4, b-v4, c-v4}\n        float dv1 = dot(a, dir);\n        float dv2 = dot(b, dir);\n        float dv3 = dot(c, dir);\n        float dv4 = dot(v4, dir);\n        bool portalReachTolerance=   (min(min(dv4 - dv1, dv4 - dv2),dv4 - dv3)  <= 1e-4);\n\n        // test if v4 can expand portal to contain origin and if portal\n        // expanding doesn't reach given tolerance\n        if ( dot(v4, dir)<0.  || portalReachTolerance)  return  -iter;\n\n        // expandPortal( v4);\n        // b-c-d triangle must be rearranged to face outside Minkowski\n        // difference (direction from a).     \n        vec3 v4a =cross( v4,a);   \n        if (dot(b, v4a) > 0.) {\n            if(dot (c, v4a) > 0.) {b=v4;b1=v41;b2=v42;}\n            else  {d=v4;d1=v41;d2=v42;}\n        }\n        else{\n            if(dot(d, v4a) > 0.)  {c=v4;c1=v41;c2=v42;}\n            else {b=v4;b1=v41;b2=v42;}\n        }        \n    }\n\n    // Phase 3. Penetration info\n    //---------------------------------\n    iter = 0;\n    while (true){\n        // compute portal direction and obtain next support point\n        dir= normalize(cross( c-b, d-b));\n        v4 =support(dir,v41,v42);\n\n        float dv1 = dot(a, dir);\n        float dv2 = dot(b, dir);\n        float dv3 = dot(c, dir);\n        float dv4 = dot(v4, dir);\n        bool portalReachTolerance=   (min(min(dv4 - dv1, dv4 - dv2),dv4 - dv3)  <= 1e-4);\n\n        // reached tolerance -> find penetration info\n        if (portalReachTolerance|| iter > 10){\n            depth = PointTriDist2(vec3(0) ,b,c,d, dir);\n            depth = sqrt(depth);\n            if (depth==0.){\n                // If depth is zero, then we have a touching contact.\n                // So following findPenetrTouch(), we assign zero to\n                // the direction vector (it can actually be anything\n                // according to the decription of ccdMPRPenetration\n                // function).\n                dir=vec3(0,1,0);\n            }else{\n                dir=normalize(dir);\n            }\n\n            // barycentric coordinates:\n            //findPos(pos);\n            float k0,k1,k2,k3, sum;\n\n            dir= normalize(cross( c-b, d-b));\n\n            // use barycentric coordinates of tetrahedron to find origin    \n            k0 = dot(cross(b,c),d);\n            k1 = dot(cross(d,c),a);\n            k2 = dot(cross(a,b),d); \n            k3 = dot(cross(c,b),a);  \n\n            sum = k0 + k1 + k2 + k3;\n            if (sum<=0.){\n                k0 = 0.;\n                k1 = dot(cross(b,c),dir);  \n                k2 = dot(cross(d,b),dir);  \n                k3 = dot(cross(b,c),dir);   \n                sum = k1 + k2 + k3;\n            }\n\n            vec3 p1= a1*k0+b1*k1+c1*k2+d1*k3;\n            vec3 p2= a2*k0+b2*k1+c2*k2+d2*k3;\n\n            pos=.5*(p1-p2)/sum;\n\n            return 0;\n        }\n\n        //ExpandPortal(v4)\n        // b-c-d triangle must be rearranged to face outside Minkowski\n        // difference (direction from a).     \n        vec3 v4a =cross( v4,a);   \n        if (dot(b, v4a) > 0.) {\n            if(dot (c, v4a) > 0.) {b=v4;b1=v41;b2=v42;}\n            else  {d=v4;d1=v41;d2=v42;}\n        }\n        else{\n            if(dot(d, v4a) > 0.)  {c=v4;c1=v41;c2=v42;}\n            else {b=v4;b1=v41;b2=v42;}\n        } \n        iter++;\n    }\n\n    \n    return 0;\n}\n\n\n//----------\n#define TOLERANCE 1e-6\n#define ITERATIONS 20\n#define VAXIS vec3(0,1,0)\n// adapted from:  https://www.shadertoy.com/view/wstyRB\n//  Casts ray in rd direction from ro, estimates depth and normal \nvec2 iSupportFunction( in vec3 ro, in vec3 rd, obj o,out vec3 normal)\n{   \n\n    vec3 dir, tmp;   \n    vec3 a,b,c,d;\n     float d0=- dot(ro,rd);  \n    //RX=horizontal axis, RY=vertical axis\n    rd=normalize(rd);\n    vec3 rx =normalize(cross(rd,VAXIS)),ry=cross(rx,rd);\n    //switch to local coordinates\n   normal=vec3(0,1,0);\n   oFuv=vec3(0);\n   \n    //rd*=-1.;\n    vec4 q= getRotation( rx,ry,-rd );\n    mat3 rmai=mat3(\n        rotate(q,vec3(1,0,0)),\n        rotate(q,vec3(0,1,0)),\n        rotate(q,vec3(0,0,-1))\n    ), rma=transpose(rmai);\n\n    ro*=rmai;\n    \n    \n    mat3 rm= rma *\n    mat3(\n        rotate(o.r,vec3(1,0,0)),\n        rotate(o.r,vec3(0,1,0)),\n        rotate(o.r,vec3(0,0,-1))\n    );  \n    o.c =  cross(cross(vec3(0,0,-1),ro),vec3(0,0,-1)); \n    //o.r=o2.r;\n    \n    #define perp2d(v)  ((v).yx*vec2(-1,1))  //(cross(v,vec3(0,0,-1)).xy) \n    a=o.c;\n    \n    b=supportr(vec3(-a.xy, 0.),o,rm);\n    if (dot(-a.xy, b.xy) <= 0.) return vec2(NOHIT);\n    \n    dir = vec3(perp2d(b-a),0.);\n    if (dot(dir.xy, a.xy) >= 0.)\n    {\n        dir.xy *= -1.;\n        tmp = a; a = b; b = tmp;\n    }\n    c=supportr(dir,o,rm);\n    if (dot(c.xy, dir.xy) <= 0.)\n        return vec2(NOHIT);\n    \n    for (int i = 0;; ++i)\n    {\n        \n        if (i == 6) return vec2(NOHIT);\n        if (dot(dir.xy = perp2d(c-a), c.xy) < 0.)\n            {b = c;}\n        else if (dot(dir.xy = perp2d(b-c), c.xy) < 0.)\n             {a = c;}\n        else break; // Origin in triangle -> intersection!\n        \n        c=supportr(dir,o,rm);    \n        if (dot(c.xy, dir.xy) <= 0.)\n            return vec2(NOHIT);\n    }\n  \n    float iN=NOHIT,iF=NOHIT;\n    int j= 0;\n    //for(int j= 0;j<=1;j++){\n        for (int i = 0; i < ITERATIONS; ++i)\n        {\n\n            dir = normalize(cross(b-a, c-a));\n            if(j>0) dir*=-1.; // uncomment to get exit point\n            d=supportr(dir,o,rm);\n\n            if (abs(dot(dir, d) - dot(dir, a)) < TOLERANCE)break;\n\n            // xd = origin left of xd line\n            bool ad = dot(perp2d(d-a),d.xy) > 0.;\n            bool bd = dot(perp2d(d-b), d.xy) > 0.;\n            bool cd = dot(perp2d(d-c), d.xy) > 0.;\n\n            // Choose triangle that intersects z-axis furthest in z direction\n            if (ad && !bd) {c = d;}\n            else if (bd && !cd) {a = d;}\n            else if (cd && !ad) {b = d;}\n            else break; // Should not happen\n\n        }\n\n       if(j==0){\n            normal = -normalize(cross(b-a, c-a));\n            //\n        }\n        float depth = a.z + dot(a.xy, normal.xy)/normal.z ;\n        \n        float t= (  -depth +d0); //todo uv\n        if(j==0) iN=t;\n        else iF=t;\n        //}\n    \n    normal=normal*rma;\n\n    return  vec2(iN,iF); \n}\n\n","name":"Common","description":"","type":"common"}]}