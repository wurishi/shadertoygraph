{"ver":"0.1","info":{"id":"wdSczR","date":"1586529175","viewed":222,"name":"Eye/pupil reaction","username":"winlandiano","description":"Eye reacts according to lighting intensity, FBM procedural iris texture. simple environment reflection on iris. Change macro for different iris color.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["eye","animation","pupil"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\tvec3 col = texture(iChannel0, uv).xyz;\n    float gamma = 2.2;\n    col = pow(col, vec3(1. / gamma));\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// https://www.shadertoy.com/view/wdSczR#\n\n// The MIT License\n// Copyright Â© 2020 Ridge/winlandiano\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n// documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright\n// notice and this permission notice shall be included in all copies or substantial portions of the Software. THE\n// SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Eye reacts according to lighting intensity, FBM procedural iris texture. simple environment reflection on iris. Change macro for different iris color.\n\n//#define HAZEL_IRIS\n#define SAPHIR_IRIS\n\n#define PI 3.14159265359\n#define PI2 1.57079632679\n\n// https://www.shadertoy.com/view/4djSRW by David Hoskins\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // Four corners in 2D of a tile\n    float a = hash12(i);\n    float b = hash12(i + vec2(1., 0.));\n    float c = hash12(i + vec2(0., 1.));\n    float d = hash12(i + vec2(1., 1.));\n\n    vec2 u = f * f * (3. - 2. * f);\n\n    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n}\n\nfloat fbm(vec2 p) {\n    float v = 0.;\n    v += noise(p) * .5\t   ; p *= 2.01;\n    v += noise(p) * .25   ; p *= 2.02;\n    v += noise(p) * .125  ; p *= 2.03;\n    v += noise(p) * .0625 ; p *= 2.04;\n    v += noise(p) * .03125;\n    return v / .96875;\n}\n\n// exponentialy increase and decrease between 0 and 1\n// x follows sine wave\nfloat damping_step(float edge, float x) {\n    edge = clamp(edge, 0., 1.);\n    float f = smoothstep(-edge, edge, sin(x));\n    float loose = log(max(f, 1e-7)) * .15 + 1.;\n    float tight = -log(max(1. - f, 1e-7)) * .15;\n    f = step(0., cos(x)); // use derivative to determin convex direction\n    float v = mix(tight, loose, f);\n    v = clamp(v, 0., 1.);\n    return v;\n}\n\nconst float eye_r = 1.5;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv * 2. - 1.;\n    p.x *= iResolution.x / iResolution.y;\n    float time = iTime;\n    \n    vec3 ro = vec3(0, 0, 3.);\n    vec3 target = vec3(0, 0, -1);\n    vec3 right = normalize(cross(target, vec3(0., 1., 0.)));\n    vec3 up = normalize(cross(right, target));\n    right = normalize(cross(target, up));\n\tvec3 rd = normalize((p.x*right + p.y*up) + target);\n    \n\n    \n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float va = a;\n    float f;\n    \n    float light_intensity = .1 + .6 * step(0., sin(time));\n    // reaction delay\n    const float REACT_TIME = .6 + PI;\n    time -= REACT_TIME;\n    float pupil_var = .2 + damping_step(.5, time) * .2;\n    time += REACT_TIME;\n\n    \n    // iris texture\n    vec3 col, inner_col, outter_col;\n#ifdef HAZEL_IRIS\n    va = fbm(vec2(20. * a, r));\n   \toutter_col = mix (vec3(.4, .15, .07), vec3(.35, .15, .02), fbm(vec2(2. * va, 20. * r)));\n    outter_col = mix(vec3(.1, .06, .02), outter_col, fbm(vec2(20. * va, r)));\n    inner_col = mix (vec3(.25, .15, .1), vec3(.45, .25, .02), fbm(vec2(1.5 * va, .5 * r)));\n    inner_col = mix(vec3(.1, .06, .02), inner_col, fbm(vec2(5. * va, 2. * r)));\n#endif\n#ifdef SAPHIR_IRIS\n    outter_col = mix (vec3(.1,.24,.7), vec3(.1,.5, 0.7), fbm(vec2(2. * va, 20. * r)));\n    outter_col = mix(vec3(.3,.45,.7), outter_col, fbm(vec2(20. * va, r)));\n    inner_col = mix (vec3(.18,.14,.7), vec3(.1,.5, .7), fbm(vec2(1.5 * va, .5 * r)));\n    f = 1. - smoothstep(0., .4 + .8 * pupil_var, r);\n    inner_col = mix(inner_col, vec3(.6, .8, .6), f);\n    f = smoothstep(.3, 1., fbm(vec2(20. * a, 6. * r)));\n    inner_col = mix(inner_col, vec3(.4,.6, 0.8), f);\n#endif\n    float rim_var = fbm(3. * p); // inner and outer iris edge\n    rim_var *= rim_var;\n    col = mix( inner_col, outter_col, smoothstep(.4, .55, r + .1 * rim_var));\n    col *= min(light_intensity + .3, 1.);\n    \n    // spot\n    f = smoothstep(.05, .25, fbm((20. - 3. * pupil_var / (r * r))* p));\n    col = mix(vec3(.04), col, f);\n    \n    // pupil\n    rim_var = .7 * fbm(p);\n    rim_var *= rim_var;\n    col = mix(vec3(0.), col, smoothstep(.015 + pupil_var * .9, .025 + pupil_var, r + .3 * rim_var));\n    \n    // spark\n    if (r < eye_r) {\n        vec3 N = normalize(vec3(p,sqrt(eye_r * eye_r - r * r)));\n        vec3 R = normalize(reflect(rd, N));\n\n        vec3 spark = texture(iChannel0, R).rgb;\n        spark = vec3(spark.r + spark.g + spark.b) * 0.3;\n        spark = pow(3. * spark, vec3(10.)) * .00002;\n        col += clamp(spark, 0., 1.) * light_intensity;\n    }\n    \n    // rim\n    col = mix(col, vec3(0.), smoothstep(.65, .8, r));\n    \n    // bkg\n    vec3 bkg_col = mix(vec3(1.), vec3(.4), smoothstep(.2, 4., r)) * light_intensity;\n    col = mix(col, bkg_col, smoothstep(.72, .8, r));\n\n    fragColor = vec4(col, 1.);\n}","name":"Buffer A","description":"","type":"buffer"}]}