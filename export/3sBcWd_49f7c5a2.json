{"ver":"0.1","info":{"id":"3sBcWd","date":"1587589966","viewed":151,"name":"Raymarch (smooth boolean union)","username":"Magicdri","description":"Raymarching tests - Smooth boolean union","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","tests","smooth","boolean","union"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 300\n#define SURF_DIST 0.01\n#define CONNECT_DIST 0.1\n\n//enum shapeType\n#define SPHERE 0\n#define PLANE 1\n\nstruct Shape\n{\n    int type;\n    vec3 pos;\n    float size;\n    vec3 color;\n};\nShape shapes[3];\n\nstruct Light\n{\n\tvec3 pos;\n\tvec3 color;\n};\nLight lights[1];\n\nstruct HitPoint\n{\n    bool hit;\n    vec3 pos;\n    vec3 normal;\n    vec3 color;\n};\n\nvec3 cameraPos = vec3(0.0,1.0,0.0);\n    \nfloat sphereDist(Shape sphere, vec3 point)\n{\n    return length(point-sphere.pos)-sphere.size;\n}\n\nfloat planeDist(Shape plane, vec3 point)\n{\n    return point.y - plane.pos.y;\n}\n    \n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0,1.0);\n    return mix(b, a, h)-k*h*(1.0-h);\n}\n\nHitPoint RayMarch(vec3 origin, vec3 ray)\n{\n    float d0 = 0.0;\n    HitPoint ret;\n    ret.hit = false;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 point = origin + ray*d0;\n        float dS = -1.0;\n        int shapeIndex = -1;\n        float ratio = 0.0;\n        vec3 color = vec3(0.0);\n        vec3 pos = vec3(0.0);\n        vec3 normal = vec3(0.0);\n        for(int j = 0; j < shapes.length(); j++)\n        {\n            float shapeDist = 0.0;\n            switch(shapes[j].type)\n            {\n            case PLANE:\n                shapeDist = planeDist(shapes[j], point);\n                break;\n            case SPHERE:\n                shapeDist = sphereDist(shapes[j], point);\n                break;\n            }\n            \n            if (dS == -1.0)\n            {\n                dS = shapeDist;\n                shapeIndex = j;\n            }\n            else\n            {\n                float k = 1.0;\n                float mixedDist = smin(dS, shapeDist, k);\n                ratio = clamp( 0.5+0.5*(shapeDist-dS)/k, 0.0, 1.0 );\n                dS = mixedDist;\n                \n            }\n            if (ratio < 1.0)\n            {\n            \tcolor = mix(shapes[j].color, color, ratio);            \n            \tswitch(shapes[j].type)\n            \t{\n            \tcase PLANE:\n                \tvec3 planeProj = point;\n                \tplaneProj.y -= 2.0; //For some reason, this value works pretty well\n                \tpos = mix(planeProj, pos, ratio);            \t\t\n                \tbreak;\n            \tcase SPHERE:\n                \tpos = mix(shapes[j].pos, pos, ratio);\n                \tbreak;\n            \t}\n                normal = normalize(point-pos);\n            }\n        }\n        d0 += dS;\n        \n        if (dS < SURF_DIST && dS >= 0.0)\n        {\n            ret.hit = true;\n            ret.pos = point;\n            ret.normal = normal;         \n            ret.color = color;\n            break;\n        }\n    }\n    \n    return ret;\n}\n\nvoid createShapes()\n{    \n    shapes[0].type = SPHERE;\n    shapes[0].pos = vec3(sin(iTime*0.75)-1.0,cos(iTime*0.75)*2.0,6.0);\n    shapes[0].size = 1.0;\n    shapes[0].color = vec3(1.0,0.0,0.0);\n    \n    shapes[1].type = SPHERE;\n    shapes[1].pos = vec3((sin(iTime*0.75)-1.0)*-1.0,cos(iTime*0.75)*2.0,6.0);\n    shapes[1].size = 1.0;\n    shapes[1].color = vec3(0.0,0.0,1.0);\n    \n    shapes[2].type = PLANE;\n    shapes[2].pos = vec3(0.0,0.0,0.0);\n    shapes[2].color = vec3(0.5,0.5,0.5);\n}\n\nvoid createLights()\n{\n\tlights[0].pos = vec3(0.0,5.0,-2.0);\n\tlights[0].color = vec3(1.0,1.0,1.0);\n}\n\nvec3 PhongShading(in HitPoint hitPoint, in vec3 origin, in vec3 pixelColor)\n{\n\tvec3 ambient = vec3(0.2);\n\tvec3 diffuse = vec3(0.0);\n\tvec3 specular = vec3(0.0);\n    \n\tfor(int i = 0; i < lights.length(); ++i)\n\t{   \n    \tvec3 ray = normalize(lights[i].pos-hitPoint.pos);\n   \t \n    \tdiffuse += max(dot(ray, hitPoint.normal),0.0)*lights[i].color;\n   \t \n    \tif (length(diffuse) > 0.0)\n    \t{\n        \tvec3 R = reflect(-ray, hitPoint.normal); //Reflected light vector\n        \tvec3 V = normalize(origin-hitPoint.pos); //Vector to viewer\n   \t \n        \tfloat specFactor = max(dot(R,V),0.0);\n        \tspecular += pow(specFactor, 32.0)*lights[i].color;\n    \t}\n\t}\n    \n\treturn (ambient+diffuse+specular)*pixelColor;\n}\n\nvec3 Render(in HitPoint hitPoint)\n{\n    vec3 pixelColor = vec3(0.8,0.85,1.0); //SKY COLOR\n    \n    if (hitPoint.hit)\n    {\n        pixelColor = PhongShading(hitPoint, cameraPos, hitPoint.color);\n        //pixelColor = hitPoint.normal; //Used for testing\n    }\n    \n    return pixelColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    createShapes();\n    createLights();\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;      \n\n    vec3 ro = cameraPos;\n    vec3 rd = normalize(vec3(uv.x,uv.y, 1));\n    \n    vec3 col = Render(RayMarch(ro, rd));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}