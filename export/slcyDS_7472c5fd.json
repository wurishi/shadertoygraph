{"ver":"0.1","info":{"id":"slcyDS","date":"1660439138","viewed":289,"name":"Leniency (sound)","username":"athibaul","description":"A new song for GPU! Also with waveform visualization.","likes":24,"published":1,"flags":8,"usePreview":1,"tags":["fm","synthesis","synthesis","synth","synthesizer","song","gpusound","frequencymodulation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 O, in vec2 U )\n{\n    // Fake dithering\n    float phi31 = 1.324717957;\n    U.x += -0.5 + fract(phi31*U.y + phi31*phi31*float(iFrame));\n    vec2 uv = (2.*U - iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    \n    vec2 env = 0.4*sqrt(fullSong(iTime + 4.*uv.x).e);\n    vec2 env_zoom = sqrt(fullSong(iTime + 0.3*uv.x).e);\n    vec2 d0 = abs(uv.y-vec2(0.5,-0.5));\n    vec2 d = d0 - env;\n    vec2 dz = d0 - env_zoom;\n    \n    //col += smoothstep(0.01, 0.0, d.x) * pow(vec3(0.2,0.5,0.7), vec3(20.*d0.x)) * 3.*pow(env.x, 0.5);\n    col += smoothstep(0.01, 0.0, dz.x) * pow(vec3(0.2,0.5,0.7), vec3(1.+20.*d0.x)) * 5.*pow(env_zoom.x, 0.5);\n    //col += vec3(1) * smoothstep(0.01, 0.0, d.y);\n    col += smoothstep(0.01, 0.0, d.y) * pow(vec3(0.2,0.5,0.7), vec3(1.+20.*d0.y)) * 5.*pow(env.y, 0.5);\n    col = mix(col, vec3(1,0,1), smoothstep(0.01, 0.0, abs(uv.x)));\n\n    float vignette = 0.5*smoothstep(0., 5., length((2.*U-iResolution.xy)/iResolution.xy));\n    col += vignette * (0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)));\n\n    // ACES tone mapping\n    // https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n    // Used in https://www.shadertoy.com/view/ts3Bz7\n    col = (col*(2.51*col+0.03))/(col*(2.43*col+0.59)+0.14);\n\n    O = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// See \"Common\" tab","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"#define TWOPI (2.*3.1415926)\n#define N(nn) (440.*exp2((nn-9.)/12.))\n#define msin(x,m) sin(TWOPI*fract(x)+(m))\n#define B(nn,dur) if(t<(dur)) { return vec2(nn, t); } t -= dur;\n\n// Sig : 2-channel sound signal + 2-channel energy envelope\n// This allows to display the waveform of the signal!\nstruct Sig { vec2 s; vec2 e; };\n\nconst Sig ZERO = Sig(vec2(0), vec2(0));\n\n// Default constructor for a signal without envelope\nSig S(vec2 s) { return Sig(s, vec2(1)); }\nSig S(float s) { return Sig(vec2(s), vec2(1)); }\nvoid Add( inout Sig a, in Sig b) { a = Sig(a.s+b.s, a.e+b.e); }\n// Apply envelope to a signal\nSig E(Sig a, vec2 env){ return Sig(a.s*env, a.e*env*env); }\nSig E(Sig a, float env){ return Sig(a.s*env, a.e*env*env); }\nSig E(vec2 a, float env){ return E(S(a),vec2(env)); }\nSig E(float a, float env){ return E(S(a),vec2(env)); }\nSig E(float a, vec2 env){ return E(S(a),env); }\n\n// =====================\n// ====== SIGNALS ======\n// =====================\n\nfloat fakeLPFSaw1(float x, float fc)\n{\n    float tau = min(0.5, 0.75/fc);\n    x -= round(x);\n    return mix(-1.-2.*x, 1.-2.*x, smoothstep(-tau, tau, x));\n}\n\nfloat fakeLPFSaw(float f, float t, float fc)\n{\n    // frequency f\n    // time t\n    // cutoff frequency fc\n    return fakeLPFSaw1(fract(f*t), fc/f);\n}\n\n\nfloat rand(float p)\n{\n    // Hash function by Dave Hoskins\n    // https://www.shadertoy.com/view/4djSRW\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat noise(float s){\n    // Noise is sampled at every integer s\n    // If s = t*f, the resulting signal is close to a white noise\n    // with a sharp cutoff at frequency f.\n    \n    // For some reason float(int(x)+1) is sometimes not the same as floor(x)+1.,\n    // and the former produces fewer artifacts?\n    int si = int(floor(s));\n    float sf = fract(s);\n    sf = sf*sf*(3.-2.*sf); // smoothstep(0,1,sf)\n    return mix(rand(float(si)), rand(float(si+1)), sf) * 2. - 1.;\n}\n\n\nfloat coloredNoise(float t, float fc, float df)\n{\n    // Noise peak centered around frequency fc\n    // containing frequencies between fc-df and fc+df\n    \n    // Assumes fc is an integer, to avoid problems with sin(large number).\n    \n    // Modulate df-wide noise by an fc-frequency sinusoid\n    return sin(TWOPI*fc*fract(t))*noise(t*df);\n}\n\nvec2 coloredNoise2(float t, float fc, float df)\n{\n    // Noise peak centered around frequency fc\n    // containing frequencies between fc-df and fc+df\n    \n    // Assumes fc is an integer, to avoid problems with sin(large number).\n    \n    // Modulate df-wide noise by an fc-frequency sinusoid\n    return sin(TWOPI*fract(fc*t))*vec2(noise(t*df),noise(-1000.-t*df));\n}\n\nfloat curve(float x, float a, float b, float curvature)\n{\n    // When x is on the a-side, outputs 0\n    // When x is on the b-side, outputs 1\n    // When x is between a and b, interpolates.\n    // curvature = 0 -> linear interpolation\n    // Negative curvature gives lower values, positive gives higher values.\n    x = (x-a)/(b-a);\n    x = clamp(x, 0., 1.);\n    return pow(x, exp(-curvature));\n}\n\n// =========================\n// ====== INSTRUMENTS ======\n// =========================\n\nSig pluckyBass(float f, float t, float tenv)\n{\n    Sig sig = ZERO;\n    float f0 = (f > 150.) ? f*0.5 : f;\n    Add(sig, E(fakeLPFSaw(f0, t+1., 20000.*exp(-8.*4.*tenv)), vec2(0.05,0.02)));\n    Add(sig, E(fakeLPFSaw(f0-.618, t+5., 20000.*exp(-8.*4.*tenv)), vec2(0.02,0.05)));\n    Add(sig, E(fakeLPFSaw(0.5*f0, t, 20000.*exp(-10.*4.*tenv)+200.), 0.1));\n    Add(sig, E(sin(TWOPI*0.5*f0*t), 0.05));\n    return E(sig,smoothstep(0.,0.001,tenv));\n}\n\n\nSig kick(float t, float dt, float dur)\n{\n    float f0=49., f1=300.;\n    // Running freq = f0 + (f1-f0)*exp(-t/dt)\n    float intfreq = f0*t - (f1-f0)*exp(-t/dt)*dt;\n    float phase = TWOPI*fract(intfreq);\n    float sig = sin(phase);\n    float env = smoothstep(dur,0.7*dur,t) * smoothstep(0., 0.001, t);\n    return E(sig,env*0.1);\n}\n\nSig click(float t, float dur)\n{\n    // Exponential sweep from 20kHz to 20Hz in \"dur\" seconds\n    // Running freq: 20000*exp(-t/dt)\n    // freq=20 at t=dur  ==>  20 = 20000*exp(-dur/dt)\n    //                   ==>  exp(-dur/dt) = 1/1000\n    //                   ==>  -dur/dt = log(1/1000)\n    //                   ==>  dt = dur/log(1000)\n    float dt = dur/log(1e3);\n    float intfreq = 20000.*exp(-t/dt)*dt;\n    float phase = TWOPI*fract(intfreq);\n    float sig = sin(phase);\n    float env = step(0., t) * smoothstep(dur, 0.7*dur, t);\n    return E(sig,env*0.1);\n}\n\nSig fatkick(float t)\n{\n    Sig sig = ZERO;\n    Add(sig, kick(t, 0.035, 0.3));\n    Add(sig, E(kick(2.*t, 0.03, 0.3), 0.25));\n    Add(sig, E(kick(4.*t, 0.03, 0.1), 0.25));\n    Add(sig, E(kick(16.*t, 0.03, 0.1), 0.0625));\n    Add(sig, E(kick(50.*t, 0.1, 0.3), 1./32.));\n    return sig;\n}\n\n\nSig snare(float t, float atk)\n{\n    // Snare is \"body\" + \"white noise\" + \"click\"\n    float wnoise = noise(20000.*t) + coloredNoise(t, 6500.,1000.)*0.3;\n    float nenv = exp(-15.*t) * smoothstep(0.160,0.0,t) * 0.5;\n    \n    float spd = 200.;\n    float phase = TWOPI*197.*t + TWOPI*80./spd * (1.-exp(-t*spd));\n    Sig body = E(sin(phase), 1.5 * smoothstep(0.,0.005,t) * smoothstep(0.035,0.,t));\n    Sig v = E(wnoise,nenv);\n    Add(v,body);\n    v.s /= 1. + abs(v.s);\n    v.e /= 1. + abs(v.e);\n    \n    Sig click = E(noise(20000.*t), exp(-600.*t));\n    Add(v, E(click, 0.4));\n    \n    return E(v ,smoothstep(-1e-6,atk,t));\n}\n\n\nSig hihat(float te)\n{\n    Sig sig = E(coloredNoise(te, 12000., 15000.) + coloredNoise(te, 3000., 6000.), 0.1);\n    //float env = smoothstep(0.0,0.0002,te) * (smoothstep(0.05,0.0,te) + 0.5*smoothstep(0.01,0.,te));\n    float env = smoothstep(0.0,0.0002,te) * (curve(te, 0.2,0.0,-2.) + 0.5*smoothstep(0.01,0.,te));\n    return E(sig, env);\n}\n\n\nSig hat1(float t)\n{\n    // Smooth hi-hat, almost shaker-like\n    return E(coloredNoise2(t, 10000., 5000.), smoothstep(0.,0.05,t) * smoothstep(0.08,0.01,t) * 0.1);\n}\n\nSig epiano(float freq, float t, float nuance)\n{\n    // freq : frequency of note\n    // t : time since beginning of note\n    // nuance : 1 is mezzo-forte, smaller is piano, larger is forte\n    vec2 f0 = vec2(freq*0.998, freq*1.002);\n    \n    // Glassy attack : slightly sharp,\n    // modulated at 14 * base frequency with a sharply decaying envelope\n    // and with a relatively fast decay\n    Sig glass = E(msin((f0+3.)*t, msin(14.*f0*t,0.) * exp(-30.*t) * nuance), exp(-4.*t)  * nuance);\n    glass.s = sin(glass.s); // Distort at high nuances\n    glass.e = tanh(glass.e);\n    \n    // Body of the sound : perfectly in tune,\n    // index of modulation depends on nuance and is boosted a bit for low notes\n    Sig body = E(msin(f0*t, msin(f0*t,0.) * exp(-0.5*t) * nuance * pow(440./f0.x, 0.5)), exp(-t) * nuance);\n    \n    // Pan the attack depending on which note it is\n    float panDir = clamp(log2(freq/400.)/2., -1., 1.); // -1 is left, 1 is right\n    vec2 pan = normalize(vec2(0.5-0.5*panDir, 0.5+0.5*panDir));\n    \n    Add(body, E(glass,pan));\n    return E(body, 0.05 * smoothstep(0.,0.001,t));\n}\n\n\nSig crashCymbal(float t, float atk)\n{\n    float reson = sin(TWOPI*429.*t + 5.*sin(TWOPI*1120.*t) + 5.*sin(TWOPI*1812.*t));\n    Sig sig = S(coloredNoise2(t, 7150., 10000.));\n    Add(sig, E(reson,0.1*smoothstep(0.,0.05,t)));\n    float env = curve(t, 15.0, 0.0,-3.) * curve(t, 0.0, 0.08, 1.);\n    env *= (1. + smoothstep(0.02,0.0,t) * 2.);\n    env *= (1. - smoothstep(0.0,0.05,t)*smoothstep(0.5,0.0,t) * 0.5);\n    env *= smoothstep(0., atk, t);\n    return E(sig, env * 0.2);\n}\n\n\n// ======================\n// ====== PATTERNS ======\n// ======================\n\nvec4 chordNotes(float t)\n{\n    t = mod(t, 16.);\n    if(t < 8.)\n    { \n        t = mod(t, 4.);\n        if(t < 0.75) return vec4(-3.,-1.,0.,4.); t -= 0.75;\n        if(t < 1.00) return vec4(-5.,-1.,2.,4.); t -= 1.00;\n        return vec4(-7., -3., 0., 4.);\n    }\n    t -= 8.;\n    if(t > 0.75 && t < 1.75) return vec4(-8.,-5.,-1.,2.);\n    if(t > 1.75 && t < 4.) return vec4(-7., -3., 0., 2.);\n    if(t > 6.25) return vec4(-5., -1., 2., 5.);\n    return vec4(-10., -3., 0., 5.);\n}\n\nSig sawChords(float t)\n{\n    vec4 nn = chordNotes(t);\n    Sig sig = ZERO;\n    float fc = 2000. + 300.*sin(1.3*t);\n    Add(sig, E(fakeLPFSaw(N(nn.x), t, fc), 0.05 * sin(t)));\n    Add(sig, E(fakeLPFSaw(N(nn.y), t, fc), 0.05 * cos(t*0.618)));\n    Add(sig, E(fakeLPFSaw(N(nn.z), t, fc),  0.05 * (-sin(t*1.414)) ));\n    Add(sig, E(fakeLPFSaw(N(nn.w), t, fc),  0.05 * (-cos(t*1.32)) ));\n    \n    Add(sig, E(fakeLPFSaw(N(nn.x)-0.618, t, fc), 0.05 * cos(t*1.718) * vec2(1,0.1)  ));\n    Add(sig, E(fakeLPFSaw(N(nn.y)+0.618, t, fc), 0.05 * sin(t*1.56) * vec2(0.7,0.3) ));\n    Add(sig, E(fakeLPFSaw(N(nn.z)-0.73, t, fc),   0.05 * (-cos(t)) * vec2(0.7,0.7)   ));\n    Add(sig, E(fakeLPFSaw(N(nn.w)-0.4142, t, fc), 0.05 * (-sin(t)) * vec2(0.1,1)     ));\n    \n    // Fade in and out to avoid clicks\n    float tenv = mod(t, 4.);\n    tenv = (tenv > 0.75) ? tenv-0.75 : tenv;\n    tenv = (tenv > 1.) ? tenv-1. : tenv;\n    tenv = (mod(t,16.) > 14.25) ? mod(t, 16.)-14.25 : tenv;\n    float t2 = 16.-mod(t,16.);\n    float tenv2 = mod(t2, 4.);\n    tenv2 = (tenv2 > 3.25) ? tenv2-3.25 : tenv2;\n    tenv2 = (tenv2 > 2.25) ? tenv2-2.25 : tenv2;\n    tenv2 = (t2 > 1.75) ? min(tenv2, t2-1.75) : tenv2;\n    float env = smoothstep(0.,0.1,tenv) * smoothstep(0., 0.1, tenv2);\n    return E(sig,env);\n}\n\nvec2 epianoNotes(float t)\n{\n    // Return vec2(note number, time since start)\n    t = max(t, 0.);\n    t = mod(t, 16.);\n    float noi=0.5, cr = 0.25, dcr = 0.125;\n    if(t < 8.-cr)\n    {\n        t = mod(t, 4.);\n        B(12., cr) B(14., cr) B(16.,cr) B(11.,noi) B(14.,cr) B(16.,cr) B(9.,2.) B(9.,dcr) B(11.,dcr)\n    }\n    t -= (8.-cr);\n    B(7.,cr);\n    float sh = 0.; // Shift 2nd part of melody by a fourth\n    if(t > 4.) { sh = 5.; t -= 4.; }\n    B(sh+9.,cr) B(sh+11.,cr) B(sh+12.,cr) B(sh+7.,noi) B(sh+11.,cr) B(sh+12.,cr)\n    B((6./5.*sh)+5.,2.)\n    if(sh==0.)\n    {\n    B(11.,dcr) B(12.,dcr)\n    }\n    \n    return vec2(0., 0.);\n}\n\nSig epianoMelody(float t)\n{\n    vec2 note = epianoNotes(t);\n    float vel = 0.7 + 0.1 * sin(0.25*TWOPI*t) - 0.2*cos(2.*TWOPI*t) - 0.1*cos(0.0625*TWOPI*t);\n    vel += 0.3*smoothstep(0.1,0.0,mod(t,16.));\n    return epiano(N(note.x), note.y, vel);\n}\n\nSig pluckyBassPat(float t)\n{\n    t = max(t,0.);\n    t = mod(t, 16.);\n    vec4 chord = chordNotes(t);\n    return pluckyBass(N(chord.x),t,mod(t,0.25));\n}\n\nSig shakerPat(float t)\n{\n    t = max(t, 0.);\n    t = mod(t, 0.5);\n    t -= 0.005;\n    Sig sig = ZERO;\n    Add(sig, hat1(t));\n    Add(sig, E(hat1(0.95*(t-0.13)), 0.6));\n    Add(sig, E(hat1(0.98*(t-0.25)), 0.5));\n    Add(sig, E(hat1(0.93*(t-0.37)), 0.3));\n    return sig;\n}\n\n// ======================\n// ======= EFFECTS ======\n// ======================\n\nSig sawChordsVerb(float t)\n{\n    Sig sig = ZERO;\n    Add(sig, sawChords(t));\n    Add(sig, E(sawChords(t-0.25), vec2(0.3,-0.3)));\n    Add(sig, E(sawChords(t-1.25), vec2(-0.1,-0.1)));\n    return sig;\n}\n\nSig epianoMelodyVerb(float t)\n{\n    Sig sig = ZERO;\n    Add(sig, epianoMelody(t));\n    Add(sig, E(epianoMelody(t-0.25), vec2(0.4,-0.3)));\n    Add(sig, E(epianoMelody(t-0.325), vec2(-0.3,0.3)));\n    Add(sig, E(epianoMelody(t-0.625), vec2(-0.2,0.3)));\n    Add(sig, E(epianoMelody(t-1.125), vec2(0.2,-0.2)));\n    Add(sig, E(epianoMelody(t-1.5), vec2(-0.1,-0.15)));\n    Add(sig, E(epianoMelody(t-1.825), vec2(-0.1,-0.15)));\n    return sig;\n}\n\nSig crashCymbalVerb(float t)\n{\n    Sig sig = ZERO;\n    Add(sig, crashCymbal(t, 0.001));\n    Add(sig, E(crashCymbal(t-0.375, 0.1), vec2(0.7,0.3)));\n    Add(sig, E(crashCymbal(t-0.75, 0.3), vec2(0.1,0.4)));\n    return sig;\n}\n\nSig snareVerb(float time)\n{\n    Sig v = snare(time, 0.001);\n    // Two early reflections, with suppressed attack\n    Add(v, E(snare(time-0.010, 0.005), vec2(0.5,-0.3)));\n    Add(v, E(snare(time-0.017, 0.005), vec2(-0.2,0.4)));\n    \n    // Late reflections\n    /*\n    for(float dly=0.01; dly<1.0; dly+=0.03)\n    {\n        float th = TWOPI*60.*dly;\n        vec2 direction = vec2(cos(th),sin(th));\n        Add(v, E(snare(time-dly, 0.1), direction * exp(-5.*dly) * noise(5000.*dly)));\n    }\n    */\n    return v;\n}\n\n\nSig fullVerse(float t)\n{\n    \n    Sig sig = ZERO;\n    t = max(t,0.);\n    \n    \n    \n    \n    float pump = 0.5;\n    if(t > 32.)\n        pump = smoothstep(0.05,0.15,mod(t,0.5)) * smoothstep(0.5,0.49,mod(t,0.5));\n    \n    float tdrums = mod(t, 32.);\n    float stopdrums = smoothstep(30.,30.-0.01,tdrums);\n    \n    vec4 chord = chordNotes(t);\n    \n    if(t > 0.)\n    {\n        Add(sig, E(epianoMelodyVerb(t), 1.));\n    }\n    if(t > 0. && t < 5.*16. || t > 5.*16.+8.)\n    {\n        float env = step(t, 5.*16.) + smoothstep(5.*16.+8., 6.*16., t);\n        Add(sig, E(sawChordsVerb(t), mix(pump,1.,0.5)*0.6*env));\n    }\n    if(14. < t && t < 16.)\n    {\n        // Fade in bass with reverse note\n        float t2 = 16. - t;\n        Add(sig, E(pluckyBass(N(7.),t2,t2*0.3), smoothstep(2.,0.,t2)*0.5));\n        Add(sig, E(pluckyBass(N(-5.),t2,t2), smoothstep(0.3,0.7,t2)*0.5));\n    }\n    if(t > 16.)\n    {\n        Add(sig, E(pluckyBassPat(t), mix(pump, 1., 0.3)));\n    }\n    if(t > 32.)\n    {\n        Add(sig, E(fatkick(mod(t, 0.5)),1.3*stopdrums));\n    }\n    \n    if(t > 48.)\n    {\n        Add(sig, E(snareVerb(mod(t-0.503,1.)), 0.3 * stopdrums));\n    }\n    if(t > 64.)\n    {\n        float tHat = mod(mod(t-0.375,0.5),0.375);\n        Add(sig, E(hihat(tHat), vec2(0.5,1.5)*0.15 * stopdrums));\n        Add(sig, E(shakerPat(t), vec2(1.0,0.3)*stopdrums));\n        Add(sig, E(crashCymbalVerb(mod(t, 16.)), 0.5));\n    }\n    \n    return E(sig, 0.5);\n}\n\n\nSig outro(float t)\n{\n    vec4 nn = vec4(-3., -1., 0., 4.);\n    Sig sig = ZERO;\n    Add(sig, epiano(N(nn.x-12.), t, 1.0));\n    Add(sig, epiano(N(nn.x), t-0.01, 0.5));\n    Add(sig, epiano(N(nn.y), t-0.024, 0.4));\n    Add(sig, epiano(N(nn.z), t-0.07, 0.6));\n    Add(sig, epiano(N(nn.w), t-0.12, 0.8));\n    Add(sig, epiano(N(9.), t-0.2, 1.1));\n    \n    sig = E(sig, 0.3);\n    \n    Add(sig, E(crashCymbalVerb(0.5*t), 0.3));\n    \n    return sig;\n}\n\nSig fullSong(float t)\n{\n\n    t -= 2.;\n    //t += 40.;\n    t = max(t,0.);\n    \n    Sig sig = ZERO;\n    if(t < 96.)\n    {\n        Add(sig, fullVerse(t));\n        Add(sig, E(crashCymbal(96.-t,0.01), 0.15));\n    }\n    else\n    {\n        Add(sig, outro(t-96.));\n    }\n        \n    return E(sig, 4.0);\n}\n\n\nvec2 mainSound( int samp, float t )\n{\n    return fullSong(t).s;\n}","name":"Common","description":"","type":"common"}]}