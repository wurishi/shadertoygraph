{"ver":"0.1","info":{"id":"tssBzs","date":"1588901350","viewed":188,"name":"diffusion curve","username":"hclarke","description":"diffusion curve primitive: a bezier with parametric blur and colours\n\ncurve sdf from: https://www.shadertoy.com/view/ltXSDB\ncircle stepping based on: https://www.shadertoy.com/view/WsXBzl","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["2d","montecarlo","pde"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const mat3 XYZ_to_RGB = mat3(\n    3.2406, -0.9689, 0.0557,\n    -1.5372, 1.8758, -0.2040,\n    -0.4986, 0.0415, 1.0570);\n\nconst vec3 D65_XYZ = vec3(.95047, 1.0, 1.08883);\nconst vec3 D65_xyY = vec3(0.31271, 0.32902, 1.0);\nconst vec3 D65_Yuv = vec3(1.0, 0.19784, 0.46834);\nconst vec3 ONE = vec3(1.0,1.0,1.0);\n\nvec3 XYZ_to_xyY(vec3 XYZ) {\n \tfloat inv_sum = 1.0/dot(XYZ,ONE);\n    return XYZ.xyy * vec3(inv_sum,inv_sum,1.0);\n}\n\nvec3 xyY_to_XYZ(vec3 xyY) {\n \tfloat s = xyY.z/xyY.y;\n    float z = 1.0-dot(vec2(1.0,1.0), xyY.xy);\n    return vec3(xyY.x, xyY.z, z) * vec3(s,1.0,s);\n}\n\nvec3 LUV_to_XYZ(vec3 LUV) {\n    vec2 uv = LUV.yz / (13.0*LUV.x) + D65_Yuv.yz;\n    float Y = LUV.x > 8.0 ? \n        D65_Yuv.x * pow((LUV.x+16.0)/116.0, 3.0) : \n    \tLUV.x * D65_Yuv.x * 0.00110705645;\n    float X = Y * 9.0 * uv.x / (4.0*uv.y);\n    float Z = Y * (12.0-3.0*uv.x-20.0*uv.y)/(4.0*uv.y);\n    return vec3(X,Y,Z);\n}\n\nvec3 XYZ_to_LUV(vec3 XYZ) {\n \tvec3 xyY = XYZ_to_xyY(XYZ);\n    float e = 0.008856;\n    float k = 903.3;\n    vec2 mul = vec2(4.0, 9.0);\n    float div = dot(XYZ, vec3(1.0, 15.0, 3.0));\n    \n    vec2 uv_ = XYZ.xy * mul / div;\n    float y_ = XYZ.y / D65_Yuv.x;\n    float L = y_ > e ? \n        116.0 * pow(y_, 1./3.) - 16. :\n\t\tk*y_;\n    return vec3(L, 13. * L * (uv_ - D65_Yuv.yz));\n\n}\n\nvec3 RGB_to_LUV(vec3 RGB) {\n \treturn XYZ_to_LUV(inverse(XYZ_to_RGB) * RGB);   \n}\n\nvec3 LUV_to_RGB(vec3 LUV) {\n \treturn XYZ_to_RGB * LUV_to_XYZ(LUV);   \n}\n\nvec3 LUV_to_HCL(vec3 LUV) {\n \tfloat H = atan(LUV.z, LUV.y);\n    float C = length(LUV.yz);\n    return vec3(H, C, LUV.x);   \n}\n\nvec3 HCL_to_LUV(vec3 HCL) {\n    float u = cos(HCL.x);\n    float v = sin(HCL.x);\n    vec2 uv = vec2(u,v);\n    return vec3(HCL.z, uv * HCL.y);\n}\n\nvec3 RGB_to_HCL(vec3 RGB) {\n \tvec3 LUV = RGB_to_LUV(RGB);\n    return LUV_to_HCL(LUV);\n}\n\nvec3 HCL_to_RGB(vec3 HCL) {\n \tvec3 LUV = HCL_to_LUV(HCL);\n    return LUV_to_RGB(LUV);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec4 col = texture(iChannel0, uv);\n\tvec3 c = col.xyz/col.w;\n    c = LUV_to_RGB(c);\n    // Output to screen\n    fragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"int rand_key = 1;\nint rand_state = 0;\n\nint rand() {\n  int val = rand_state;\n\n  int x = val ^ rand_key;\n  x *= 0xad8c49f5;\n  rand_state = x;\n\n  val ^= val>>16;\n  return val & 0xffff;\n}\n\nvoid init(int key) {\n  rand_key = key;\n  rand_state = 123456;\n  rand();\n  rand();\n}\n\nvec2 onCircle() {\n \tfloat r = float(rand())/float(0xffff) * 3.14195 * 2.;\n    return vec2(sin(r), cos(r));\n}\n\n// curve from here: https://www.shadertoy.com/view/ltXSDB\n// Test if point p crosses line (a, b), returns sign of result\nfloat testCross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat signBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{ \n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0, \n        step(testCross(A, B, p) * testCross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * testCross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 solveCubic(float a, float b, float c)\n{\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a bezier curve\nvec2 sdBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{    \n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);      \n    vec3 t = clamp(solveCubic(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return vec2(dis * signBezier(A, B, C, p), t);\n}\n\n\nstruct Curve {\n    vec2 A,B,C; // control points\n    float bA, bB, bC; // control points for blur\n    vec3 cpA, cpC, cnA, cnC; // interpolated color on pos/neg sides\n};\n\nvec4 pde_curve(vec2 p, Curve c) {\n \tvec2 sdt = sdBezier(c.A, c.B, c.C, p);\n    \n    float t = sdt.y;\n    float b = mix(mix(c.bA, c.bB, t), mix(c.bB, c.bC, t), t);\n    vec3 cA = c.cpA;\n    vec3 cC = c.cpC;\n    float sd = sdt.x;\n    if(sd < 0.) {\n        cA = c.cnA;\n        cC = c.cnC;\n    }\n    vec3 col = mix(cA, cC, t);\n    float bl = mix(mix(c.bA, c.bB, t), mix(c.bB, c.bC, t), t);\n    sd = abs(sd)-bl;\n    return vec4(sd, col);\n}\n\nvec4 scene(vec2 p) {\n    vec3 cnA = vec3(85., 20., 90.);\n    vec3 cnC = vec3(85., -30., -50.);\n    vec3 cpA = vec3(75., 65., -20.);\n    vec3 cpC = vec3(75., -30., 50.);\n    Curve cur;\n    cur.cnA = cnA;\n    cur.cnC = cnC;\n    cur.cpA = cpA;\n    cur.cpC = cpC;\n    cur.bA = 0.1;\n    cur.bB = -0.1;\n    cur.bC = 0.1;\n    cur.A = vec2(-1.2, -0.6);\n    cur.B = vec2(0.0, 1.4);\n    cur.C = vec2(1.3, -0.4);\n    vec4 res = pde_curve(p, cur);\n    return res;\n}\n\nvec3 march(vec2 p) {\n    for(int i = 0; i < 32; ++i) {\n    \tfloat d = scene(p).x;\n        p += d * onCircle();\n    }\n    return scene(p).yzw;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int x = int(fragCoord.x);\n    int y = int(fragCoord.y);\n    init(x + y * int(iResolution.x) + iFrame * int(iResolution.x*iResolution.y));\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    vec4 prev = texture(iChannel0, uv);\n    \n    \n    vec4 c = prev;\n    c += vec4(march(p),1.);\n    \n    fragColor = c;\n}","name":"Buffer A","description":"","type":"buffer"}]}