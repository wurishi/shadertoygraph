{"ver":"0.1","info":{"id":"wslSRn","date":"1553480647","viewed":1241,"name":"Ray marched Caustics0","username":"bearworks","description":"A Fake Caustics Effect by InvertAO.... For Fun","likes":32,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","distancefields","primitives","caustics","ambientocclusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nBased on https://www.shadertoy.com/view/Xds3zN\n\nA Fake Caustics Effect by Ray marched Invert ambient occlusion\n\n*/\n\n#define SAMPLES 32\n#define MAXDEPTH 10\n\n#if 1 \n#define INVERSEAO 1      //0, 1 for ao or caustics\n#define MINWEIGHTMODE 0  //0, 1, 2 for weaker, normal, stronger value\n#define WEIGHTMODE 1     //0, 1 for normal, stronger value\n#else\n#define INVERSEAO 0\n#define MINWEIGHTMODE 1\n#define WEIGHTMODE 0\n#endif\n\n\nfloat sdPlane( vec3 p )\n{\n    return p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdPryamid4(vec3 p, vec3 h ) // h = { cos a, sin a, height }\n{\n    // Tetrahedron = Octahedron - Cube\n    float box = sdBox( p - vec3(0,-2.0*h.z,0), vec3(2.0*h.z) );\n    float d = 0.0;\n    d = max( d, abs( dot(p, vec3( -h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  h.x, h.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y, h.x )) ));\n    d = max( d, abs( dot(p, vec3(  0, h.y,-h.x )) ));\n    float octa = d - h.z;\n    return max(-box,octa); // Subtraction\n}\n\nfloat length2( vec2 p )\n{\n    return sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n    p = p*p*p; p = p*p;\n    return pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n    p = p*p; p = p*p; p = p*p;\n    return pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\n//------------------------------------------------------------------\n\nfloat map( in vec3 pos )\n{\n    vec2 res = opU( vec2( sdPlane(     pos), 1.0 ),\n                    vec2( sdSphere(    pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 ) );\n    res = opU( res, vec2( sdBox(       pos-vec3( 1.0,0.25, 0.0), vec3(0.25) ), 3.0 ) );\n    res = opU( res, vec2( udRoundBox(  pos-vec3( 1.0,0.25, 1.0), vec3(0.15), 0.1 ), 41.0 ) );\n    res = opU( res, vec2( sdTorus(     pos-vec3( 0.0,0.25, 1.0), vec2(0.20,0.05) ), 25.0 ) );\n    res = opU( res, vec2( sdCapsule(   pos,vec3(-1.3,0.10,-0.1), vec3(-0.8,0.50,0.2), 0.1  ), 31.9 ) );\n    res = opU( res, vec2( sdTriPrism(  pos-vec3(-1.0,0.25,-1.0), vec2(0.25,0.05) ),43.5 ) );\n    res = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.30,-1.0), vec2(0.1,0.2) ), 8.0 ) );\n    res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.50,-1.0), vec3(0.8,0.6,0.3) ), 55.0 ) );\n    res = opU( res, vec2( sdTorus82(   pos-vec3( 0.0,0.25, 2.0), vec2(0.20,0.05) ),50.0 ) );\n    res = opU( res, vec2( sdTorus88(   pos-vec3(-1.0,0.25, 2.0), vec2(0.20,0.05) ),43.0 ) );\n    res = opU( res, vec2( sdCylinder6( pos-vec3( 1.0,0.30, 2.0), vec2(0.1,0.2) ), 12.0 ) );\n    res = opU( res, vec2( sdHexPrism(  pos-vec3(-1.0,0.20, 1.0), vec2(0.25,0.05) ),17.0 ) );\n    res = opU( res, vec2( sdPryamid4(  pos-vec3(-1.0,0.15,-2.0), vec3(0.8,0.6,0.25) ),37.0 ) );\n    res = opU( res, vec2( opS( udRoundBox(  pos-vec3(-2.0,0.2, 1.0), vec3(0.15),0.05),\n                               sdSphere(    pos-vec3(-2.0,0.2, 1.0), 0.25)), 13.0 ) );\n    res = opU( res, vec2( opS( sdTorus82(  pos-vec3(-2.0,0.2, 0.0), vec2(0.20,0.1)),\n                               sdCylinder(  opRep( vec3(atan(pos.x+2.0,pos.z)/6.2831, pos.y, 0.02+0.5*length(pos-vec3(-2.0,0.2, 0.0))), vec3(0.05,1.0,0.05)), vec2(0.02,0.6))), 51.0 ) );\n    res = opU( res, vec2( 0.5*sdSphere(    pos-vec3(-2.0,0.25,-1.0), 0.2 ) + 0.03*sin(50.0*pos.x)*sin(50.0*pos.y)*sin(50.0*pos.z), 65.0 ) );\n    res = opU( res, vec2( 0.5*sdTorus( opTwist(pos-vec3(-2.0,0.25, 2.0)),vec2(0.20,0.05)), 46.7 ) );\n    res = opU( res, vec2( sdConeSection( pos-vec3( 0.0,0.35,-2.0), 0.15, 0.2, 0.1 ), 13.67 ) );\n    res = opU( res, vec2( sdEllipsoid( pos-vec3( 1.0,0.35,-2.0), vec3(0.15, 0.2, 0.05) ), 43.17 ) );\n        \n    return res.x;\n}\n\nfloat castRay( in vec3 ro, in vec3 rd, float tmax)\n{\n    float tmin = 1.0;\n    \n    float t = tmin;\n    float precis = 0.0005;\n    for( int i=0; i<64; i++ )\n    {\n        float res = map( ro+rd*t );\n        if( res<precis || t>tmax ) break;\n        t += res;\n    }\n    return t;\n}\n\nfloat castRayAO( in vec3 ro, in vec3 rd)\n{\n    float tmin = 0.1;\n    \n    float t = tmin;\n    float precis = 0.005;\n    for( int i=0; i<MAXDEPTH; i++ )\n    {\n        float res = map( ro+rd*t );\n        if( res<precis  ) \n        {\n#if MINWEIGHTMODE>1\n        return max(res, 0.0);\n#elif MINWEIGHTMODE>0\n        return 1. / max(t, 1.001);\n#else\n        return max(t, 0.0);\n#endif\n        }\n\n        t += res;\n    }\n#if WEIGHTMODE>0\n    return 1. / max(t, 0.001);\n#else\n    return 1. / max(t, 1.001);\n#endif\n\n}\n\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) +\n                      e.yyx*map( pos + e.yyx ) +\n                      e.yxy*map( pos + e.yxy ) +\n                      e.xxx*map( pos + e.xxx ) );\n}\n\n#define PI 3.1415926535897932384626\nfloat seed = 0.;\nfloat rand() { return fract(sin(seed++)*43758.5453123); }\n\nvec3 jitter(vec3 d, float phi, float sina, float cosa) {\n    vec3 w = normalize(d), u = normalize(cross(w.yzx, w)), v = cross(w, u);\n    return (u*cos(phi) + v*sin(phi)) * sina + w * cosa;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float ao = .0;\n    for( int i=0; i<SAMPLES; i++ )\n    {\n        float r2 = rand();\n        vec3 d = jitter(nor, 2.*PI*rand(), sqrt(r2), sqrt(1. - r2));\n        \n        ao += castRayAO(pos, d);\n    }\n    ao /= float(SAMPLES);\n#if INVERSEAO > 0\n    return clamp( ao, 0.0, 1.0 ); \n#else\n    return clamp( 1. - ao, 0.0, 1.0 ); \n#endif\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    float t = castRay(ro,rd, 20.0);\n    \n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal( pos );\n        \n    float occ = calcAO( pos, nor );\n    return vec3(occ, occ, occ);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n    float time = 15.0 + iTime;\n\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    // camera    \n    vec3 ro = vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.0*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( -0.5, -0.4, 0.5 );\n    \n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    // ray direction\n    vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n     // render    \n     fragColor.rgb = render( ro, rd );\n}","name":"Image","description":"","type":"image"}]}