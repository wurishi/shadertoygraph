{"ver":"0.1","info":{"id":"fdVSRG","date":"1634840502","viewed":94,"name":"Balllll2","username":"drone1","description":"What's w/ the band/shadow that appears on the object? I set the shadow calculation to start at t=0.1 but am still seeing it. Must be a bug somewhere.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["ball"],"hasliked":0,"parentid":"ssVXWw","parentname":"Ballllll"},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAIN_MATERIAL 0.0\n#define FOG_END 8.0\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat noise1( sampler3D tex, in vec3 x )\n{\n    return textureLod(tex,(x+0.5)/32.0,0.0).x;\n}\nfloat noise1( sampler2D tex, in vec2 x )\n{\n    return textureLod(tex,(x+0.5)/64.0,0.0).x;\n}\nfloat fbm( sampler2D tex, in vec2 x )\n{\n    float f = 0.0;\n    f += 0.5000*noise1(tex,x); x*=2.01;\n    f += 0.2500*noise1(tex,x); x*=2.01;\n    f += 0.1250*noise1(tex,x); x*=2.01;\n    f += 0.0625*noise1(tex,x);\n    f = 2.0*f-0.9375;\n    return f;\n}\nfloat fbm( sampler3D tex, in vec3 x )\n{\n    float f = 0.0;\n    f += 0.5000*noise1(tex,x); x*=2.01;\n    f += 0.2500*noise1(tex,x); x*=2.01;\n    f += 0.1250*noise1(tex,x); x*=2.01;\n    f += 0.0625*noise1(tex,x);\n    return f;\n}\n\n// n must be normalized\nfloat sdPlane( vec3 p, vec3 n, float h ) {\n  return dot(p,n) + h;\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere(in vec3 p, float r) {\n    return length(p)-r;\n}\n\nconst float s = 10.;\n\nfloat thing(in vec3 p, in float tt) {\n    vec3 bob = vec3(0.,0.2*sin(1.0*tt),0.);\n    vec3 pp = bob+p+vec3(0.05,0.,-.5+0.05*sin(tt));\n    vec3 c = vec3(0.12);\n    pp = mod(pp+0.5*c,c)-0.5*c;\n    float f = 2.0+8.0*(0.5+0.5*sin(tt*1.5));\n    float s = 0.1*sin(f*p.x)*cos(f*p.y);\n    float ff = 20.0*f;\n    float ss = 0.01*sin(ff*p.x)*cos(ff*p.y);\n    return max(\n        s+sdSphere(p+bob,0.5) + .02*sin(tt+s*p.x)*cos(0.63*tt+s*p.z),\n        ss-sdSphere(pp, 0.001+0.01*(0.5+0.5*sin(tt+pp.x*5.0)))\n    );\n}\n\nvec2 map(in vec3 p) {\n    float tt = 0.1*iTime;\n    vec3 p2 = p;\n    \n   // float b = 0.5*pow(.2*(0.5+0.5*sin(100.*(tt*0.1+p.x))), 2.0);\n    float b = (abs(mod(p.x, 0.2)) < 0.005 ? 0.01 : 0.0) +\n        (abs(mod(p.z, 0.05)) < 0.005 ? 0.01 : 0.0);\n    float d = smin(\n        thing(p, tt),\n        sdPlane(p2, vec3(0.,1.,0.), 0.5)+0.01*sin(p.x)*cos(p.z),\n        0.6*(0.5+0.5*cos(tt))\n    );\n    return vec2(d, MAIN_MATERIAL);\n}\n\nfloat march(in vec3 eye, in vec3 dir) {\n    float t = 0.0;\n    \n    for (int i=0; i<100; ++i) {\n        vec3 p = eye + t*dir;\n        vec2 res = map(p);\n        float d = res.x;\n        float mat = res.y;\n\n        if (t > 1000.0)\n            return -1.0;\n        else if (d < 0.001)\n            break;\n\n        t += d;\n    }\n    \n    return t;\n}\n\nvec3 norm( in vec3 p) \n{\n\tvec3 eps = vec3(0.001, 0.0, 0.0 );\n\n\treturn normalize( vec3( map(p+eps.xyy).x - map(p-eps.xyy).x,\n\t\t\t\tmap(p+eps.yxy).x - map(p-eps.yxy).x,\n\t\t\t\tmap(p+eps.yyx).x - map(p-eps.yyx).x ) );\n}\n\nfloat skyTex(in vec3 uv) {\n    vec3 np = 5.0*uv+ \n        vec3(iTime*.02,13423.0,234.0);\n    return fbm(iChannel0,np);\n}\n\nvec3 skyNorm( in vec3 p) \n{\n\tvec3 eps = vec3(0.05, 0.0, 0.0 );\n\n\treturn normalize( vec3( skyTex(p+eps.xyy) - skyTex(p-eps.xyy),\n\t\t\t\tskyTex(p+eps.yxy) - skyTex(p-eps.yxy),\n\t\t\t\tskyTex(p+eps.yyx) - skyTex(p-eps.yyx) ) );\n}\n\nfloat sky(in vec3 eye, in vec3 dir, in vec2 uv) {\n    float g = (uv.x+2.0)*pow(dir.y*1.1,1.2); // gradient\n    vec3 p = vec3(0.5*uv,-20.0);\n    vec3 sn = skyNorm(p);\n    vec3 moonPos = normalize(vec3(1.0));\n    float diff = max(0., dot(sn,moonPos));\n    return pow(\n        min(\n            g*.8*pow(skyTex(p),0.2)*(.8+0.2*diff),\n            2.0\n        )*.85,\n        1.25\n    );\n}\n\nfloat shadow(in vec3 startPos, in vec3 dir, in vec3 lp) {\n    float t = 0.1;\n    float distToLight = length(lp-startPos);\n    \n    for (int i=0;i<100;++i) {\n        vec3 p = startPos + t*dir;\n        vec2 h = map(p);\n        \n        if (h.x >= distToLight)\n            return 1.0;\n        \n        if (h.x < 0.001)\n            break;\n        \n        t += h.x;\n    }\n    \n    if (t >= 0.1)\n        return 0.5;\n\n    return 1.0;\n}\n\nvec3 light(in vec3 eye, in vec3 dir, in vec3 p) {\n    vec3 amb = vec3(0.08);\n    vec3 n = norm(p);\n    vec3 light_pos = vec3(1.0);\n    vec3 diff = 0.5*vec3(max(0.0,dot(normalize(light_pos-p),n)));\n    float h = pow(max(0.0,p.y+0.49),0.3);\n    diff.r += h;\n    diff.g += 0.4*h;\n    diff.b += 0.6*h;\n    diff = pow(diff, vec3(2.0-p.y));\n    diff += p.x*-p.z*0.05;\n    vec3 spec = vec3(pow(\n        max(0.0,dot(n, normalize(-light_pos))),\n            .01\n        ));\n    float fog = 1.0-min(FOG_END, length(p-eye))/FOG_END;\n    float sk = sky(eye, dir, p.xz);\n    \n    vec3 o = amb+min(1.0,0.3+n.y)*fog*(min(1.0,0.2+.8*sk)*spec+diff);\n    \n    // LIGHT2 - LEFT\n    o += max(0.0, dot(n, normalize(vec3(-1.0,-.1,-0.2)))) *\n        5.0*vec3(0.137,0.137,0.20);\n        \n    // SHADOW\n    float sh = shadow(p, normalize(light_pos-p), light_pos);\n    o *= sh;\n    \n    return o;\n}\n\nvec3 render(in vec2 uv) {\n    vec3 eye = vec3(0.,0.,0.8);\n    vec3 dir = normalize(vec3(uv.xy,0.0)-eye);\n    float t = march(eye, dir);\n    if (t < 0.0) {\n        return sky(eye, dir, uv) *\n            5.0*vec3(0.1-.02*(uv.x-1.3),0.11,0.12+0.01*uv.y);\n    }\n    vec3 col = light(eye, dir, eye+t*dir);\n    col = pow(col, vec3(1.1));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x/iResolution.y;\n    vec2 uv = (-1.+2.*fragCoord/iResolution.xy);\n    uv.x *= aspect;\n    vec3 col = render(uv);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}