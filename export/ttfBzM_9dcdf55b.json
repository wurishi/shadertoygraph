{"ver":"0.1","info":{"id":"ttfBzM","date":"1676473819","viewed":63,"name":"Raytracing example","username":"JoeAN","description":"Raytracing example","likes":0,"published":1,"flags":16,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define N 2\n#define KEY_LEFT 37\n#define KEY_RIGHT 39\n\nvec3 rotateY(vec3 v, float a) {\n    vec4 v4 = vec4(v, 1);\n    mat4 m;\n    m[0] = vec4(cos(a), 0, -sin(a), 0);\n    m[1] = vec4(0);\n    m[2] = vec4(sin(a), 0, cos(a), 0);\n    m[3] = vec4(0, 0, 0, 1);\n    \n    return (v4*m).xyz;\n}\n\nstruct Camera {\n    vec3 forward;\n    float fov;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n    vec3 color;\n    int m; // 0 = Diffuse, 1 = Specular, 2 = Reflective\n};\n    \nstruct HitRecord {\n    float t;\n\tvec3 p;\n    vec3 n;\n    vec3 c;\n    int m;\n};\n\nvec3 lerp(float t, vec3 v1, vec3 v2) {\n    return (1. - t)*v1 + t*v2;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 pointAt(Ray r, float t) {\n\treturn r.origin + r.direction*t;\n}\n\nbool hitSphere(Ray r, Sphere s, inout HitRecord rec) {\n    float t = dot(s.center - r.origin, r.direction); //intersection mid\n    vec3 p = pointAt(r, t);\n    \n    float y = length(s.center - p);\n    if (y < s.radius) { // there is intersection   \n        float x = sqrt(s.radius*s.radius - y*y);\n        float t1 = t-x;\n        float t2 = t+x;\n        \n        rec.t = min(t1, t2);\n        rec.p = pointAt(r, rec.t);\n        rec.n = normalize(rec.p - s.center);\n        rec.c = s.color;\n        rec.m = s.m;\n \n        return true;\n    } \n    \n    return false;\n}\n\nbool hitSphereList(Ray r, Sphere[N] spheres, inout HitRecord rec) {\n    float minT = 9999.;\n    bool hitAnything = false;\n    \n    for (int i = 0; i < N; i++) {\n        if (hitSphere(r, spheres[i], rec)) {\n            hitAnything = true;\n            if (rec.t < minT) {\n                minT = rec.t;\n            }\n        }\n    }\n            \n    return hitAnything;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n#define DEG2RAG 3.14/180. \n\nvec4 colorFromRay(Ray r, vec3 l, Sphere[N] spheres, HitRecord rec) {\n    vec3 col;\n    int depth = 1;\n    \n    while (depth > 0) {\n        if (hitSphereList(r, spheres, rec)) {\n            if (rec.m == 0) { // Diffuse shading\n                float diffuse = max(0., dot(-l, rec.n));\n\n                col += rec.c * diffuse;\n\n            } else if (rec.m == 1) { // Specular shading\n                vec3 h = normalize(-l - rec.p);\n                float specular = pow(max(0., dot(h, rec.n)), 64.0);\n                float diffuse = max(0., dot(-l, rec.n));\n\n                col += rec.c * diffuse + specular;\n\n            } else if (rec.m == 2) {\n\n                col += rec.c * refract(r.direction, rec.n, acos(dot(r.direction, rec.n)));\n            }\n\n            Ray reflected = Ray(rec.p, reflect(r.direction, rec.n));\n\n        } else {\n            return texture(iChannel0, r.direction);\n        }\n        \n        r = Ray(rec.p, reflect(r.direction, rec.n));\n        depth--;\n\t}\n    \n    return vec4(col, 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - .5*iResolution.xy) / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec3 col = lerp(uv.y, vec3(1, 1, 1), vec3(0.25, .35, 1));\n    \n    HitRecord rec;\n    \n    vec3 l = vec3(0.5, -0.5, 0.5);\n    //l = rotateY(l, iTime);\n    \n    vec3 lookFrom = vec3(0, 0, -4);\n    vec3 lookAt = vec3(0, 0, 0);\n    Camera cam = Camera(normalize(lookAt-lookFrom), 60.);\n    \n    vec3 rayDir = normalize(cam.forward + vec3(uv,0) * cam.fov* DEG2RAG);\n    Ray r = Ray(lookFrom, rayDir);\n    \n    Sphere[] spheres = Sphere[] (\n        Sphere(vec3(mouse, 4), 1.5, vec3(0, 1, 1), 0),\n        //Sphere(vec3(0, 0, 4), 1.5, vec3(0, 1, 0), 2),\n        Sphere(vec3(2, 0, 4), 1.5, vec3(1, 0, 0), 1)\n    );\n    \n    if (texelFetch(iChannel1, ivec2(KEY_LEFT,0), 0).x != 0.) {\n        spheres[0].center.x -= 1.;\n    \n    } else if (texelFetch(iChannel1, ivec2(KEY_RIGHT,0), 0).x != 0.) {\n     \tspheres[0].center.x += 1.;   \n    }\n    \n    fragColor = colorFromRay(r, l, spheres, rec);\n}","name":"Image","description":"","type":"image"}]}