{"ver":"0.1","info":{"id":"tlcGz4","date":"1575726489","viewed":120,"name":"Capsule SpongeV1","username":"jorge2017a1","description":"a menger sponge with cylinders, Capsule  instead of cubes.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["capsulesponge"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//modificado por jorge flores.p --2019-dic-07\n//Gracias a ....Created by russ in 2017-03-06\n//https://www.shadertoy.com/view/XsfczB\n    \n\nconst int iter =100;\nconst float eps = 0.001, far = 30.;\nvec3 lDir0 = normalize(vec3(1,2,1)), lDir1 = normalize(vec3(-1,1.0,-2));\nvec3 lCol0 = vec3(1,.8,.5), lCol1 = vec3(.6,0.8,1); \n\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\n\nfloat cylUnion(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(min(xy,min(xz,yz))) - 1.;\n}\n\nfloat cylIntersection(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(max(xy,max(xz,yz))) - 1.;\n}\n\n\n//-------------------------------------------\n\nfloat dsSphere(vec3 center, float r, vec3 point)// basic sphere SDF\n{\n    // point is point pos in space, center is sphere's center, r is its radius\n    return length(point - center) - r;\n}\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.0, 1.0);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\nfloat dsTorus(vec3 center, float r1, float r2, vec3 point)\n{\n \tfloat x = length(point.xz - center.xz) - r1;\n    float y = point.y - center.y;\n    float dist = length(vec2(x,y)) - r2;\n    return dist;\n}\n//--------------------------------------------\n\n\nfloat DE(vec3 p){\n    \n    //float d = cylIntersection(p);\n\tfloat d;\n    float distToCapsule = dsCapsule(vec3(-0.0,0.0,0.0), vec3(2.0,1.0,0.1), 1.0, p);    \n    \n    d=distToCapsule;\n    \n    float s = 1.;\n    \n    \n    for(int i = 0;i<5;i++){\n        p *= 3.;\n    \ts*=3.;\n    \tfloat d2 = cylUnion(p) / s;\n        \n        \n        float d3=sdBox(p, vec3(2.0,1.0,2.5));\n        //d2=d2*d3/2.0;\n            \n        //float m = texelFetch(iChannel0, ivec2(32, 0), 0).x * 2. - 1.;\n        float m = -1.0;\n        \n    \td = max(d,m*d2);\n   \t \tp = mod(p+1. , 2.) - 1.; \t\n    }\n    return d;\n}\n\nvec2 march(vec3 ro, vec3 rd){\n\tfloat t=0. , d = far, it = 0.;\n    for (int i=0;i<iter;i++){\n     \tt += (d = DE(ro+t*rd));\n        if(d<eps || t> far) break;\n        it += 1.;\n    }\n    return vec2(t,it/float(iter));\n}\n\nfloat getShadow(vec3 p, vec3 n, vec3 ld){\n    p +=  2. * eps * n;\n    float t=0.,d=far;\n    for(int i=0;i<50;i++){\n        t += (d=DE(p + t*ld));\n        if (d<eps || t>3.) break;\n    }\n    return t<=3. ? 0.1 : 1. ;\n}\n\nvec3 getRay(vec3 ro, vec3 look, vec2 uv){\n    vec3 f = normalize(look - ro);\n    vec3 r = normalize(vec3(f.z,0,-f.x));\n    vec3 u = cross (f,r);\n    return normalize(f + uv.x * r + uv.y * u);\n}\n\nvec3 getNorm(vec3 p){\n    vec2 e = vec2(eps, 0);\n    return normalize(vec3(DE(p+e.xyy)-DE(p-e.xyy),DE(p+e.yxy)-DE(p-e.yxy),DE(p+e.yyx)-DE(p-e.yyx)));\n}\n\nvec3 light(vec3 p, vec3 n){\n    vec3 col = vec3(0);\n    for(int i=0;i<2;i++){\n        vec3 ld = (i==0) ? lDir0 : lDir1;\n        float diff = max(dot(n, (ld)),0.);\n        diff *= getShadow(p, n, ld);\n        col += diff * (i==0 ? lCol0 : lCol1);\n    }\n    return col * .7;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //float time = iTime * .04;\n    float time = iTime * .6;\n    \n    \n\tvec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n    float s1 = sin(time), c1 = cos(time);\n    float arg = 1.5*sin(time*.7894)*.5 + .5;\n    float s2 = sin(arg), c2 = cos(arg);\n    \n    vec3 ro = vec3(0, .2, 1)*2.5;\n    \n    \n    ro.yz = mat2(c2,-s2,s2,c2)*ro.yz;\n    ro.xz = mat2(c1,s1,-s1,c1)*ro.xz;\n    \n    vec3 rd = getRay(ro, vec3(0.), uv);\n    vec2 hit = march(ro, rd);\n    vec3 p = ro + hit.x*rd;\n    vec3 col = hit.x<far ? light(p, getNorm(p)) : vec3(.1*(1.-length(uv)));\n    col += pow(hit.y,3.);\n\tfragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"}]}