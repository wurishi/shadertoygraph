{"ver":"0.1","info":{"id":"Mcd3W4","date":"1718890934","viewed":112,"name":"MineCart","username":"_TAU_","description":"Shader used as a background visual for my jungle track : \n\nhttps://youtu.be/s8Wu1zK9OBM","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["reflection","refraction","water","cave","drone"],"hasliked":0,"parentid":"Ms2yR1","parentname":"Green Grotto"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Green Grotto\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Remixed by _TAU_\n\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nconst float pi = 3.14159;\n\n//light position\nvec3 ltPos[2];\n//other\nfloat dstFar, tCur, htWat;\nbool uWat;\n\n\nvec3 TrackPath (float t)\n{\n   \n  return vec3 (4.7 * sin (t * 0.15) + 2.7 * cos (t * 0.19), 0., t);\n}\n\n//cave distance function\nfloat CaveDf (vec3 p)\n{\n  float s, d;\n  s = p.y - htWat;// ground plane\n  p.xy -= TrackPath(p.z).xy;// this somehow create a cave from the path\n   //adding detail to the cayve first term is the \"bumpness\"\n  p += 0.1 * (1. - cos (2. * pi * (p + 0.2 * (1. - cos (2. * pi * p.zxy)))));\n  d = 0.7 * (length (cos (0.48 * p - 0.31 * sin (1.35 * p.zxy +\n     0.4 * cos (2.7 * p.yzx)))) - 1.1);\n  if (! uWat) d = min (d, s);\n  return d;\n}\n\nfloat CaveRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 200; j ++) {\n    d = CaveDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nfloat CaveAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (int j = 0; j < 8; j ++) {\n    d = float (j + 1) / 8.;\n    ao += max (0., d - 3. * CaveDf (ro + rd * d));\n  }\n  return clamp (1. - 0.2 * ao, 0., 1.);\n}\n\n// returns normal to the surface \nvec3 CaveNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.007, -0.007, 0.);\n  v = vec4 (CaveDf (p + e.xxx), CaveDf (p + e.xyy),\n     CaveDf (p + e.yxy), CaveDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat CaveSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 16; j ++) {\n    h = CaveDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.2, 0.1 * d);\n    if (sh < 0.005) break;\n  }\n  return 0.4 + 0.6 * sh;\n}\n\n\nvec3 CaveCol (vec3 ro, vec3 rd, vec3 vn, vec3 ltDir, float atten)\n{\n  vec3 col;\n  col = vec3 (0.28, 0.38, 0.47);\n  if (! uWat) col = mix (col, vec3 (0.2, 0.4, 0.2), smoothstep (0.2, 0.8, vn.y));\n  col *= (0.2 + 0.8 * max (dot (vn, ltDir), 0.) +\n     0.5 * pow (max (dot (reflect (ltDir, vn), rd), 0.0), 64.)) *\n     (0.1 + 0.9 * atten * min (CaveSShadow (ro, ltDir), CaveAO (ro, vn)));\n  return col;\n}\n\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, colR, bgCol, ltVec, roo, rdo, row, vnw;\n  float dstCave, atten, frFac;\n  float texture_freq_cave, texture_bump_cave;\n  // water variables\n  bool hitWat;\n  roo = ro;\n  rdo = rd;\n  uWat = false;\n  hitWat = false;\n  //colors\n  bgCol = (abs (rd.y) < 0.5) ? vec3 (0.04, 0.05, 0.07) : vec3 (0.01);\n  texture_freq_cave = 7.;//2.\n  texture_bump_cave = 7.; //10.\n  // cave raymarch - getDistance\n  dstCave = CaveRay (ro, rd);\n  // check if water is hit\n  if (dstCave < dstFar && ro.y + rd.y * dstCave < htWat + 0.001) {\n    hitWat = true;\n    ro += rd * dstCave;\n    row = ro;\n    //get water texture\n    vnw = VaryNf (1.5 * ro, vec3 (0., 1., 0.), 0.1);\n    rd = reflect (rd, vnw);\n    ro += 0.01 * rd;\n    dstCave = CaveRay (ro, rd);\n  }\n  //otherwise\n  if (dstCave < dstFar) {\n    // handle lighting\n    ltVec = roo + 2. * ltPos[0] - ro;\n    atten = 1. / (0.8 + 0.01 * dot (ltVec, ltVec));\n    ltVec = normalize (ltVec);\n    //set ro to position on the cave surface\n    ro += rd * dstCave;\n    \n    col = CaveCol (ro, rd,\n                   VaryNf (texture_freq_cave * ro, CaveNf (ro), texture_bump_cave),\n                   ltVec, atten);\n\n  } else col = bgCol;\n  if (hitWat) {\n    frFac = rdo.y * rdo.y;\n    frFac *= frFac;\n    if (frFac > 0.005) {\n      rd = refract (rdo, vnw, 1./1.333);\n      ro = row + 0.01 * rd;\n      uWat = true;\n      dstCave = CaveRay (ro, rd);\n      if (dstCave < dstFar) {\n        ltVec = roo + 2. * ltPos[1] - ro;\n        atten = 1. / (0.8 + 0.01 * dot (ltVec, ltVec));\n        ltVec = normalize (ltVec);\n        ro += rd * dstCave;\n        colR = CaveCol (ro, rd, VaryNf (5. * ro, CaveNf (ro), 10.), ltVec, atten);\n        colR = mix (colR, bgCol, smoothstep (0.45, 0.99, dstCave / dstFar));\n      } else colR = bgCol;\n      col = mix (col, colR * vec3 (0.4, 1., 0.6) * exp (0.02 * ro.y), frFac);\n    }\n  }\n  //add color filter\n  col = pow (clamp (col, 0., 1.), vec3 (0.8));\n  return vec3(col);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  //-----------------------------INIT------------------------------------------\n  // NORMALIZED PIXEL coordinates:\n  // (y in {-1 ; 1} x in { -(resolution.x/resolution.y) ; (resolution.x/resolution.y)})\n  vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;  \n  vec2 canvas = iResolution.xy;\n  //---------------------------------------------------------------------------\n  \n  mat3 vuMat;\n  vec3 ro, rd, fpF, fpB, vd;\n  vec2 ori, ca, sa;\n  float el, az, t, tt, a;\n  //float cam movement parameters\n  float vtilt = .25;\n\n  tCur = iTime;\n  t = 4. * tCur;\n  az = 0.;\n  el = 0.;\n\n  tt = mod (floor (0.05 * tCur), 4.);\n  a = vtilt * pi * SmoothBump (0.8, 0.95, 0.05, mod (0.05 * tCur, 1.));\n  if (tt < 2.) el = (2. * tt - 1.) * a;\n  else az = (2. * tt - 5.) * a;\n  \n  // set ray origin along the track\n  fpF = TrackPath (t + 0.1);\n  fpB = TrackPath (t - 0.1);\n  ro = 0.5 * (fpF + fpB);\n  \n  // set ray direction using motion and 3D rotation matrix\n  vd = fpF - fpB;\n  ori = vec2 (el, az + ((length (vd.xz) > 0.) ? atan (vd.x, vd.z) : 0.5 * pi));\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 1.5));\n  \n  // light position\n  ltPos[0] = vuMat * normalize (vec3 (0., 1., -1.));\n  ltPos[1] = vuMat * normalize (vec3 (0., -1., -1.));\n  //set water height\n  htWat = -1.2;\n  //ligth dist\n  dstFar = 30.;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst float pattern = 57.; // appears to be a magic number\nconst vec4 cHashA4 = vec4 (0., 1., pattern, 58.);\nconst vec3 cHashA3 = vec3 (1., pattern, 113.); \nconst float cHashM = 43758.54; // huge sine wave amplitude for pseudo-random generation\n\n// generate a pseudo-random 4D vectors by taking \n//the fractional part of a huge amplitude sine\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n      //s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    s += a * vec3 (Noisefv2 (p.xy), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n)) * (1. / 1.9375);\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s, Fbmn (p + e.yxy, n) - s,\n     Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n","name":"Image","description":"","type":"image"}]}