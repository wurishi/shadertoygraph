{"ver":"0.1","info":{"id":"XflcWM","date":"1721195470","viewed":41,"name":"scene object distinction","username":"akr51","description":"fairly painless way to do scene object distinction see map function line 107 ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define ITR 120\n#define DST 90.0\n#define SRF 0.001\n\n// signed distance functions: https://iquilezles.org/articles/distfunctions/\n\nmat2 rt(float t)\n{\n\n\n    float c = cos(t);\n    float s = sin(t);\n    return mat2(c, -s, s, c);\n\n\n}\n\n\n\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\n\n\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n  // sampling independent computations (only depend on shape)\n  float w = sqrt(r*r-h*h);\n  \n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : \n                          abs(length(q)-r) ) - t;\n}\n\n\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n\nfloat mapplane(vec3 sp)\n{\n\n\n\n    float d = sp.y + 0.5;\n    return d;\n\n}\n\n\n\n\nfloat mapprism(vec3 sp)\n{\n    sp.y -= 0.25;\n    sp.xy *= rt(iTime);\n    sp.zy *= rt(iTime);\n    return sdHexPrism(sp, vec2(0.5, 0.1));\n\n\n}\n\n\n\n\nfloat mapCutHollowSphere(vec3 sp)\n{\n\n    vec3 sps = sp + vec3(2.1, -0.6, -1.0);\n    sps.xy *= rt(iTime);\n    sps.zy *= rt(iTime);\n    return sdCutHollowSphere(sps, 0.7, 0.3, 0.1);\n \n}\n\n\n\nfloat mapOctahedron(vec3 sp)\n{\n\n\n    vec3 spo = sp + vec3(-2.1, -0.6, -1.0);\n    spo.xy *= rt(iTime);\n    spo.zy *= rt(iTime);\n    \n    return sdOctahedron(spo, 1.0);\n\n}\n\n// here\nvec2 map(vec3 sp)\n{\n\n    float dst[4];\n    \n    dst[0] = mapplane(sp);\n    dst[1] = mapprism(sp);\n    dst[2] = mapCutHollowSphere(sp);\n    dst[3] = mapOctahedron(sp);\n    \n    float id = 0.0;\n    \n    for (int i = 1; i < 4; i++) \n    {\n        \n        if (dst[i] < dst[0])\n        {\n        \n            dst[0] = dst[i];\n            id = float(i);\n        \n        }\n    \n    }\n    \n    return vec2(dst[0], id);\n    \n}\n\n\n\nvec2 mrch(vec3 ro, vec3 rd)\n{\n    \n\n    float d0 = 0.0;\n    float id = 0.0;\n    for (int i = 0; i < ITR; i++)\n    {\n    \n        vec3 sp = ro + rd * d0;\n        \n        vec2 ds = map(sp);\n        id = ds.y;\n        d0 += ds.x;\n        if (d0 > DST || abs(ds.x) < SRF) break;\n    \n    \n    }\n    \n    \n    return vec2(d0, id);\n    \n\n}\n\n\n\nvec3 nml(vec3 p)\n{\n\n\n    vec2 d = vec2(0.001, 0.0);\n    return normalize(map(p).x - vec3(map(p - d.xyy).x, map(p - d.yxy).x, map(p - d.yyx).x));\n    \n\n}\n\n\n\nfloat lighting(vec3 p, vec3 lp)\n{\n\n\n    vec3 l = normalize(lp - p);\n    vec3 n = nml(p);\n    float df = clamp(dot(n, l), 0.0, 1.0);\n    \n    vec2 ds = mrch(p + n * 0.02, l);\n    \n    if (ds.x < length(lp - p))\n    {\n    \n        \n        df *= 0.1;\n    \n    }\n    \n    return df;\n\n\n}\n\n\n\nvec3 dir(vec2 uv, vec3 ro, vec3 fx)\n{\n\n\n    vec3 w = normalize(fx - ro);\n    vec3 u = normalize(cross(w, vec3(0.0, 1.0, 0.0)));\n    vec3 v = normalize(cross(u, w));\n    return mat3(u, v, w) * normalize(vec3(uv, 2.5));\n    \n\n}\n\n\n\nvoid mainImage(out vec4 c_out, in vec2 u)\n{\n    \n    \n    vec2 rr = iResolution.xy, uv = (u + u - rr) / rr.y;\n    vec3 ro = vec3(0.0, 0.5, -5.0);\n    vec3 fx = vec3(0.0, 0.0, 0.0);\n    vec3 rd = dir(uv, ro, fx);\n    \n    vec3 cl = vec3(0.0);\n    \n    vec2 d0 = mrch(ro, rd);\n    \n    vec3 cl1 = vec3(0.86, 0.64, 0.9);\n    vec3 cl2 = vec3(1.0, 0.86, 0.5);\n    vec3 cl3 = vec3(2.0, 1.0, 0.96);\n    vec3 cl4 = vec3(0.7, 2.0, 3.0);\n    vec3 colors[4] = vec3[4](cl1, cl2, cl3, cl4);\n    \n    if (d0.x > 0.0)\n    {\n    \n    \n        vec3 sp = ro + rd * d0.x;\n        float lt = lighting(sp, vec3(0.25, 0.65, -4.0));\n        cl += lt * colors[int(d0.y)];\n        \n    \n    }\n    \n    \n    c_out = vec4(cl, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}