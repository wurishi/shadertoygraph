{"ver":"0.1","info":{"id":"NdfXWS","date":"1619114845","viewed":99,"name":"Learn buffer load and save","username":"lexi4","description":"Test\nWASD controls","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["2d","geometry","keyboard","buffer"],"hasliked":0,"parentid":"4dXXRr","parentname":"A Simple Rectangle"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"//Visual based on https://www.shadertoy.com/view/lldcDf\n//Buffer's based on https://www.shadertoy.com/view/Xst3zX\n\nfloat sphereSDF(vec2 p, float size) {\n\treturn length(p) - size;\n}\n\nfloat boxSDF(vec2 p, vec2 size) {\n\tvec2 r = abs(p) - size;\n    return min(max(r.x, r.y),0.) + length(max(r,vec2(0,0)));\n}\n\nvoid AddObj(inout float dist, inout vec3 color, float d, vec3 c) {\n    if (dist > d) {\n        dist = d;\n        color = c;\n    }\n}\n\nvec2 map(vec2 value, vec2 inMin, vec2 inMax, vec2 outMin, vec2 outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\nvec4 LoadData(vec2 DATA_ID){\n    return texelFetch( iChannel1, ivec2(DATA_ID), 0);\n}\n\n\nvoid scene(in vec2 pos, out vec3 color, out float dist) {\n    dist = 1e9; color = vec3(0,0,0);\n    AddObj(dist, color, sphereSDF(pos - vec2(3,1), 1.), vec3(1,.9,.8));\n    \n    //GET POSITION FROM BUFFER AND APPLY\n    vec2 LightPositionFromBuffer = LoadData(CHARACTER_SAVE).xy;\n    vec2 ProvidedPos = map(LightPositionFromBuffer, vec2(0.0), vec2(iResolution), vec2(0.0), vec2(1.0));\n\n    AddObj(dist, color, sphereSDF(pos - ProvidedPos, 0.5),vec3(0.1,0.1,0.1));\n}\n\nvoid trace(vec2 p, vec2 dir, out vec3 c) {\n    for (;;) {\n        float d;\n        scene(p, c, d);\n        if (d < 1e-3) return;\n        if (d > 1e1) break;\n        p += dir * d;\n    }\n    c = vec3(0,0,0);\n}\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n        vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n#define SAMPLES 64\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 UiUV = fragCoord.xy / iResolution.xy;\n    vec2 uv = (fragCoord-(iResolution.xy/2.f))/iResolution.y*10.f;\n    vec3 col = vec3(0,0,0);\n    for (int i = 0; i < SAMPLES; i++) {\n        float t = (float(i) + random(uv+float(i)+iTime)) / float(SAMPLES) * 2. * 3.1415;\n        vec3 c;\n        trace(uv, vec2(cos(t), sin(t)), c);\n        col += c;\n    }\n    col /= float(SAMPLES);\n    fragColor = vec4(col*2.,1.0) + texture(iChannel2, UiUV);\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Load & Save data into buffer\nvec4 load(in vec2 fragCoordRead)\n{\n    return texture(iChannel0, (0.5 + fragCoordRead) / iChannelResolution[0].xy, -100.0 );\n}\n\nfloat isInside( vec2 p, vec2 c ) \n{ \n    vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); \n}\n\nvoid store( in vec2 fragCoordWrite, in vec4 value, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = (isInside(fragCoord, fragCoordWrite) > 0.0) ? value : fragColor;\n}\n\nbool isKeyPressed(float key)\n{\n\treturn texture( iChannel1, vec2(key, 0) ).x > 0.0;\n}\n\nbool isInitial()\n{\n    return iFrame == 0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 CharacterPosition = isInitial() ? \n                             ScreenCenter : vec2(load(CHARACTER_SAVE).xy);\n\n    vec2 CharacterAccel = isInitial() ? \n                             vec2(0.0) : vec2(load(CHARACTER_SAVE).zw);\n    \n    float ImpulsePower = 400.0 * iTimeDelta;\n    float DecelerationFactor = 0.99;\n\n\n    //Handle input and move\n    if(isKeyPressed(KEY_D))\n    {\n       CharacterAccel.x += ImpulsePower;\n    }\n    if(isKeyPressed(KEY_A))\n    {\n       CharacterAccel.x -= ImpulsePower;\n    }\n    if(isKeyPressed(KEY_W))\n    {\n       CharacterAccel.y += ImpulsePower;\n    }\n    if(isKeyPressed(KEY_S))\n    {\n       CharacterAccel.y -= ImpulsePower;\n    }\n    \n    \n    CharacterAccel *= DecelerationFactor;\n    CharacterPosition += CharacterAccel;\n    clamp(CharacterPosition,vec2(0),vec2(fragCoord));\n\n\tfragColor = texture(iChannel0, DATA_BUFFER_RES);\n    \n    vec4 CharacterInfo = vec4(CharacterPosition.xy, CharacterAccel.xy);\n    store(CHARACTER_SAVE, CharacterInfo, fragColor, fragCoord);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//Input\nconst float KEY_SP    = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\nconst float KEY_A     = 65.5/256.0;\nconst float KEY_D     = 68.5/256.0;\nconst float KEY_S     = 83.5/256.0;\nconst float KEY_W     = 87.5/256.0;\n\n\n//Save slots and my custom vars\nconst vec2 CHARACTER_SAVE = vec2(2,2);\nconst vec2 ScreenCenter = vec2(0.5);\n\nconst ivec2 RECT_POS_DATAID = ivec2(2,2);\n\n#define DATA_BUFFER_RES iChannelResolution[1].xy\n#define PI 3.14159265359\n\nvec4 LoadData(sampler2D Texture, vec2 DATA_ID){\n    return texelFetch(Texture, ivec2(DATA_ID), 0);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// ----------------\n// DEBUG TEXT!\n// ----------------\n\n// From: https://www.shadertoy.com/view/4sBfRd\nvec4 char(vec2 p, int c) {\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\n//From: https://www.shadertoy.com/view/3dyyRh\nfloat printNumber(vec2 fragCoord, float number) {\n\tfloat fontSize = 16.;\n\t// init digits\n\tint digits[12];\n\t// numbers start at 48 in font map\n\tfor(int i = 0; i <= 9; i++) digits[i] = 48 + i;\n\tdigits[10] = 46; // .\n\tdigits[11] = 45; // -\n\n\tint a[15]; // array for digits of number\n\tint c = 0; // counter for array = length\n\tfloat tmp = abs(number);\n\t// do not display numbers higher than this due to precision issues\n\tif (tmp > 999999.) {\n\t\twhile(c < 8) a[c++] = 11; // --------\n\t} else {\n\t\tif(number < 0.) a[c++] = 11; // add - if number is negative\n\t\tint v; // current digit\n\t\tbool f; // true if first digit > 0 found\n\t\tfor(int i = 8; i >= -4; i--) {\n\t\t\tv = int(tmp / pow(10., float(i))); // calculate digit\n\t\t\t// omit leading zeros\n\t\t\tif(v > 0 || f) {\n\t\t\t\ta[c++] = v; // add digits 0-9\n\t\t\t\ttmp -= float(v) * pow(10., float(i)); // subtract\n\t\t\t\tf = true;\n\t\t\t}\n\t\t\t//decimal point\n\t\t\tif(i == 0 && abs(number) < 1.) a[c++] = 0; // add 0\n\t\t\tif(i == 0) a[c++] = 10; // add .\n\t\t}\n\t\twhile(a[c-1] == 0) c--; // strip 0\n\t\tif(a[c-1] == 10) c--; // strip .\n\t}\n\t// coordinate system that starts at bottom left\n\t// which is independent of aspect ratio\n\tvec2 p = fragCoord.xy / iResolution.y;\n\tfloat result;\n\t// output number\n\tfor(int i = 0; i < c; i++) {\n\t\tresult += char(p * 256. / fontSize + vec2(-.5 * float(i), 0.0), digits[a[i]]).x;\n\t}\n\treturn result;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 col;\n\tcol = mix(col, vec3(1.,1.,1.), printNumber(fragCoord, iChannelResolution[1].x));\n\tfragColor = vec4(col, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}