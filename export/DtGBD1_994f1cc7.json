{"ver":"0.1","info":{"id":"DtGBD1","date":"1702013852","viewed":33,"name":"HEXAWORM","username":"snail_god","description":"A nice little HEXAWORM swimming in a circle. Look at it go! Looks like it's from an alien planet, or perhaps it's like those pictures of viruses very close up. My inaugural non-hello-world glsl project.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","signeddistance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// thanks inigo\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 st = (2. * uv - 1.) * vec2(iResolution.x / iResolution.y, 1.);\n\n    // To mess with the signed distance function to make it glow\n    float shine = 0.4 + 0.1 * pow(sin(0.600*iTime),2.);\n    \n    // To spin in place\n    float a = .19 * iTime;\n    mat2 post_rotation = mat2(-cos(a), sin(a),\n                        sin(a) ,    cos(a));\n\n    // Dist needs to be initialized outisde of for loop for scope\n    // because we are composing multiple signed distance functions.\n    float dist = 1.;\n    // Make a bunch of hexagons:\n    for (float i = 0.; i < 2.; i+=.1) { // TODO: make the loop conditions parameterized\n\n        // To orbit center\n        float b = i + iTime * 0.5;\n        mat2 pre_rotation = mat2(-cos(b), sin(b),\n                            sin(b) ,    cos(b));\n        \n        // Find the center of the hexagon:\n        // Rotate about origin, offset, and change that offset depending on\n        // the time and where you are in the worm, for that sweet undulating motion.\n        vec2 p = st + vec2(.5 + 0.05 * sin(6. * i + iTime * 5.)) * pre_rotation;\n        \n        // Calculate the distance function for this hexagon.\n        // The distance function is then taken to the shine'th power\n        // (with a few tweaks for where you are in the worm).\n        // This ends up giving the outline, but only if we use the magnitude of the\n        // distance function as a threshold instead of the actual sign. (See below.)\n        float segment_dist =  pow(sdHexagon(p * post_rotation, .1), 0.8 * i * shine);\n        \n        // Take the minimum of the current distance function and the old one to\n        // compose the shapes.\n        // Helpful link: https://numfactory.upc.edu/web/Geometria/signedDistances.html\n        dist = min(dist,segment_dist);\n    }\n    \n    // Decide on the g component depending on a hard threshold on the distance function.\n    // This gives the crisp cyan of the hexagons.\n    \n    // If the condition on dist was dist == 0, nothing would show up.\n    // Not sure entirely why! Do you know? \n    float g;\n    if (dist < 0.1) {\n        g = 1.;\n    } else {\n        g = 0.2;\n    }\n    \n    // The b component instead depends on 1/dist, which gives the snazzy dark blue glow.\n    float b = pow(0.4 / dist, 2.);\n    \n    // Output to screen\n    fragColor = vec4(\n        .0, g * 0.4 , b,1.\n    );\n\n}\n","name":"Image","description":"","type":"image"}]}