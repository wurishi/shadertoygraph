{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"video","id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define MAX_STEPS 100\n#define R 0.5\n\nfloat max_distance = 100.0;\nfloat epsilon = 0.0001;\nfloat bump_factor = 0.025;\n\nfloat hash(float x)\n{\n\treturn fract(21654.6512 * sin(385.51 * x));\n}\n\nfloat hash(vec2 p)\n{\n\treturn fract(1654.65157 * sin(15.5134763 * p.x + 45.5173247 * p.y+ 5.21789));\n}\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p+4.5476351));\n}\nvec2 add = vec2(1.0, 0.0);\n\nvec2 noise2(vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    vec2 res = mix(mix( hash2(p),          hash2(p + add.xy),f.x),\n                    mix( hash2(p + add.yx), hash2(p + add.xx),f.x),f.y);\n    return res;\n}\n\nvec2 fbm2(vec2 x)\n{\n    vec2 r = vec2(0.0);\n    float a = 1.0;\n    \n    for (int i = 0; i < 8; i++)\n    {\n        r += noise2(x) * a;\n        x *= 2.;\n        a *= .5;\n    }\n     \n    return r;\n}\n\nfloat clouds(vec3 z)\n{\n    float alt = 10.;\n    \n    float thickness = 2.;\n    \n    if (abs(z.y-alt) > thickness)\n        return 0.;\n    else\n    {\n        return .3;\n    }\n}\n\nfloat march(vec3 ro,vec3 rd)\n{\n    float d = 0.;\n    for (int i = 0; i < 100; i++)\n    {\n//        float s = \n    }\n    \n    return 100.;\n}\n\n\nfloat getDistance(vec3 point)\n{\t\n  float bump = 0.0;\n  if ( length(point) < R + bump_factor) {\n    bump = bump_factor * texture(iChannel0, point.xy*vec2(1.,-1.)+vec2(0.5,0.5)).r;\n  }\n  return length(point) - R - bump;  \n}\n\nfloat raycast(vec3 start_pos, vec3 ray_dir)\n{\n\tfloat d = 0.0;\n\t\n\tfor (int i = 0; i < MAX_STEPS; i++)\n\t{\n\t\tvec3 ray_pos = start_pos + ray_dir*d;\n\t\tfloat s = getDistance(ray_pos);\n\t\t\n\t\t if (s < epsilon)\n\t\t\treturn d;\t\n\t\t\n\t\td += s;\n\t\t\n\t\tif (d > max_distance)\n\t\t\tbreak;\n\t\t\n\t}\n\t\n\treturn max_distance;\n}\n\nfloat rep(float var, float mag, float bandwidth, bool center_on_zero) {\n    float val = mag*fract(var/bandwidth);\n    if (center_on_zero) val -= mag*.5;\n    return val;\n}\n\nvec3 getNormal(vec3 point)\n{\n  float d0 = getDistance(point);\n  float dX = getDistance(point - vec3(epsilon, 0.0, 0.0));\n  float dY = getDistance(point - vec3(0.0, epsilon, 0.0));\n  float dZ = getDistance(point - vec3(0.0, 0.0, epsilon));\n\t\n  vec3 r = vec3(dX-d0, dY-d0, dZ-d0);\n  vec3 norm = -normalize(r);\n  return norm;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0*fragCoord.xy / iResolution.xy - 1.0;\n\t\t\n\tfloat dist = .85;\n\n\tvec3 eye_pos = vec3(0.0, 0.0, dist);\n\tvec3 ray_dir = normalize(vec3(uv,-1.));\n\n\tfloat d = raycast(eye_pos, ray_dir);\n\tvec3 point = eye_pos + ray_dir*d;\n\tif (d < max_distance)\n\t{\n\t\tvec3 normal = getNormal(point);\n\n\t\tvec3 light = vec3(-0.307, -.707, -.20);\n\t\t\t\t\n\t\tvec3 diff_color = vec3(1.0, 0.3, 0.3);\n\t\tfloat diffuse = max(0.0, dot(-light, normal));\n\t\tvec3 eye_vec = ray_dir;\n\t\tvec3 halfa = normalize(eye_vec + light);\n        vec3 spec_color = vec3(.5, .5, .1);\n\t\tfloat sdot = dot(halfa, normal);\n\t\tfloat specular = pow(sdot, 10.0);\n\t\tvec3 color =  (diffuse*diff_color + spec_color*vec3(specular));\n\t\n\t\tfragColor = vec4(color, 1.0);\n\t}\n\telse\n\t{\n        vec2 offset = vec2(0.,-iTime);\n        fragColor = vec4(fbm2(uv+offset)/(1.-uv.y),0.,1.0);\n\t}\n        \n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldXXzs","date":"1405651202","viewed":327,"name":"Demonic Britney","username":"dirkadirkadan","description":"demonic britney","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","bumpmapping"],"hasliked":0,"parentid":"","parentname":""}}