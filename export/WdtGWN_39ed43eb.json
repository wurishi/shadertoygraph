{"ver":"0.1","info":{"id":"WdtGWN","date":"1568983529","viewed":1053,"name":"Sketched Geometric Pattern","username":"Shane","description":"A simple geometric pattern with some optional compiler directives.","likes":36,"published":3,"flags":0,"usePreview":0,"tags":["abstract","square","sketch","pencil","pattern","hatch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n\tSketched Geometric Pattern\n\t--------------------------\n\n    A geometric pattern rendered in a pseudo sketch style. The example itself\n    isn't cutting edge, but there are a heap of other define options below that \n    seek to demonstrate how various changes can effect the look and feel of a \n    basic geometric rendering.\n\n\tI have a lot of examples lying around that are only mildly interesting, but \n\tmight be of use to people, so I might start putting them up.\n\n\tIf I had the time, I could quite happily submit simple geometric patterns\n\tall day. One of the things I like to do is render some simplistic objects in\n\ta grid, relate them to one another in some way, then start adding rendering\n\tlayers, such as shadows, strokes, highlights, etc.\n\n\tGeometrically speaking, this example is about as easy as it gets. I'd \n    originally given the smaller squares some animation, but decided to \n    concentrate on the rendering side of things instead. The individual \n    postprocessing functions aren't that taxing either. However, when you put it \n    all together, the code blows out a little. Having said that, this isn't \n    really a treatise on shader coding, but rather a rendering style \n    demonstration.\n\n\n    Similar Examples:\n\n\tThere are too many to list, but Fabrice Neyret has heaps of cool little \n\texamples that cover various grid patterns.\n\n*/\n\n\n// Postprocessing directives. Turning most of these on or off can completely\n// change the feel of the image.\n\n// Simple overlays. To see the sketch properly, set the color option to \n// grayscale. The sketch algorithm itself is just a cheap substandard \n// process, based on Flockaroo's fancy one. Having said that, it's still\n// reasonably effective.\n#define SKETCH\n//#define LINE_OVERLAY \n//#define NAIVE_HATCH // I made this up a while back, and find it useful.\n#define PAPER_GRAIN\n\n// Shadows almost always look better, but there are times when they might\n// overcook things a little. I think they enhance this example, but it's\n// all a matter of personal requirements. Turning them off gives it a \n// fresher, more naive, rendering style, which can sometimes be preferable.\n#define SHADOWS\n\n// Highlights -- Usually performed by taking a nearby sample, then adding a\n// variation on the difference.\n#define HIGHLIGHTS\n\n// Palettes: Not many, but I might add more.\n//#define GRAYSCALE\n//#define GRAY_WITH_COLOR\n//#define CANDY_PALETTE\n#define RANDOM_COLOR_FLIP\n//#define VARIED_PALETTE\n//#define REVERSE_PALETTE\n\n// The object shape. Just three, but I might add others in due course.\n// 0: Slightly rounded square, 1: Circle, 2: Octagon, of sorts.\n#define SHAPE 0\n\n// Picture frame variation.\n//#define FRAMES\n\n// Display mazelines or partial lines. The partial lines look more sketch-like, \n// so they're on by default. They're rendered in a cell offset fashion\n// reminiscent of Voronoi.\n//#define MAZELINES\n#define PARTIAL_LINES\n\n// Display the square cell grid boundaries. It's there for debug purposes,\n// but has a certain aesthetic appeal.\n//#define SHOW_GRID\n\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(27, 57)));\n    return fract(vec2(262144, 32768)*n)*2. - 1.; \n    \n    // Animated.\n    //p = fract(vec2(262144, 32768)*n);\n    //return sin(p*6.2831853 + iTime); \n    \n}\n\n// Based on IQ's gradient noise formula.\nfloat n2D3G( in vec2 p ){\n   \n    vec2 i = floor(p); p -= i;\n    \n    vec4 v;\n    v.x = dot(hash22(i), p);\n    v.y = dot(hash22(i + vec2(1, 0)), p - vec2(1, 0));\n    v.z = dot(hash22(i + vec2(0, 1)), p - vec2(0, 1));\n    v.w = dot(hash22(i + 1.), p - 1.);\n\n#if 1\n    // Quintic interpolation.\n    p = p*p*p*(p*(p*6. - 15.) + 10.);\n#else\n    // Cubic interpolation.\n    p = p*p*(3. - 2.*p);\n#endif\n\n    return mix(mix(v.x, v.y, p.x), mix(v.z, v.w, p.x), p.y);\n    //return v.x + p.x*(v.y - v.x) + p.y*(v.z - v.x) + p.x*p.y*(v.x - v.y - v.z + v.w);\n}\n\n// A hatch-like algorithm, or a stipple... or some kind of textured pattern.\nfloat doHatch(vec2 p, float res){\n    \n    \n    // The pattern is physically based, so needs to factor in screen resolution.\n    p *= res/16.;\n\n    // Random looking diagonal hatch lines.\n    float hatch = clamp(sin((p.x - p.y)*3.14159*200.)*2. + .5, 0., 1.); // Diagonal lines.\n\n    // Slight randomization of the diagonal lines, but the trick is to do it with\n    // tiny squares instead of pixels.\n    float hRnd = hash21(floor(p*6.) + .73);\n    if(hRnd>.66) hatch = hRnd;  \n\n\n    return hatch;\n\n    \n}\n\n// IQ's box function with a smoothing factor added.\nfloat sBoxS(in vec2 p, in vec2 b, in float rf){\n  \n    vec2 d = abs(p) - b + rf;\n  \treturn min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;\n}\n\n// IQ's standard box function.\nfloat sBox(in vec2 p, in vec2 b){\n   \n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n// This will draw a box (no caps) of width \"ew\" from point \"a \"to \"b\". I hacked\n// it together pretty quickly. It seems to work, but I'm pretty sure it could be\n// improved on. In fact, if anyone would like to do that, I'd be grateful. :)\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew){\n    \n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n\n    vec2 l = vec2(length(b - a), ew);\n    return sBox(p, (l + ew)/2.) ;\n}\n\n// A distance function containing some basic shapes.\nfloat dist(in vec2 p, in vec2 b){\n    \n    // Just in case the shape directive is accidentally commented out.\n    #ifdef SHAPE\n    \n    #if SHAPE == 0\n    // Slightly rounded square.\n    return sBoxS(p, b, sqrt(b.x)*.1);\n    #elif SHAPE == 1\n    // Circle.\n    return length(p) - b.x*1.05;\n    #else\n    // Octagon, of sorts.\n    p = abs(p);\n    return max(max(p.x, p.y), (p.x + p.y)*.7071 - b.x/6.) - b.x;\n    #endif\n    \n    #else\n    return sBoxS(p, b, sqrt(b.x)*.1);\n    #endif\n}\n\n\n\n// Hacky global scale and global ID... I must've been in a hurry when putting \n//this together. :)\nconst float gSc = 5.5;\nvec2 gID;\n\nvec3 pattern(vec2 p){\n    \n    \n    // Grid ID and local coordinates.\n    vec2 ip = floor(p);\n    p -= ip + .5;\n    \n    \n    // Distance field container. One for the lines, one for the larger objects,\n    // and another for the smaller objects rendered over the top.\n    vec3 d = vec3(1e5);\n    \n    \n    // Render some boxes with various sizes in a checkboard fashion.\n    float w = (mod(ip.x + ip.y, 2.)>.5)? .28 : .44;\n    float s = dist(p, vec2(w));\n    d.y = min(d.y, s);\n    \n    #ifdef FRAMES\n    float ody = d.y;\n    d.y = max(d.y, -(d.y + .15)); // Picture frame variation.\n    #endif\n    \n    \n    // Randomly offset the smaller boxes.\n    vec2 rnd = hash22(ip);\n    // Random offset factor.\n    const float rF = .125;\n    \n    // Smaller boxes over the top of the larger boxes.\n    if(mod(ip.x + ip.y, 2.)<.5){\n        \n        w = .2;\n        s = dist(p - rnd*rF, vec2(w));\n\n        d.z = min(d.z, s);\n        #ifdef FRAMES\n        d.z = max(d.z, -(d.z + .15)); // Picture frame variation.\n        //d.z = max(d.z, -(d.z + .18)); \n        #endif\n        \n    }\n    \n    // Line thickness.\n    float ew = .011;\n       \n    \n    // Render some lines. It looks more difficult than it is. Basically, read\n    // the offset position to each of the four cell neighbors, then render a\n    // line between them. There's a maze variation in there too.\n    if(mod(ip.x + ip.y, 2.)<.5){\n        \n        #ifdef MAZELINES\n        float rnd3L = hash21(ip + vec2(-1, 0));\n        float rnd3T = hash21(ip + vec2(0, 1));\n        float rnd3R = hash21(ip + vec2(1, 0));\n        float rnd3B = hash21(ip + vec2(0, -1));\n        \n        if(rnd3L<.5) d.x = min(d.x, lBox(p, vec2(-1, 0), rnd*rF, ew/2.));\n        if(rnd3T>=.5) d.x = min(d.x, lBox(p, vec2(0, 1), rnd*rF, ew/2.));\n        if(rnd3R<.5) d.x = min(d.x, lBox(p, vec2(1, 0), rnd*rF, ew/2.));\n        if(rnd3B>=.5) d.x = min(d.x, lBox(p, vec2(0, -1), rnd*rF, ew/2.)); \n        #else\n        #ifndef PARTIAL_LINES\n        d.x = min(d.x, lBox(p, vec2(-1, 0), rnd*rF, ew/2.));\n        d.x = min(d.x, lBox(p, vec2(0, 1), rnd*rF, ew/2.));\n        d.x = min(d.x, lBox(p, vec2(1, 0), rnd*rF, ew/2.));\n        d.x = min(d.x, lBox(p, vec2(0, -1), rnd*rF, ew/2.));\n        #endif\n        #endif\n        \n        \n    }\n    else {\n        \n        vec2 rndL = hash22(ip + vec2(-1, 0));\n        vec2 rndT = hash22(ip + vec2(0, 1));\n        vec2 rndR = hash22(ip + vec2(1, 0));\n        vec2 rndB = hash22(ip + vec2(0, -1));\n\n        \n        #ifdef MAZELINES\n        float rnd3 = hash21(ip);\n        if(rnd3<.5){\n            d.x = min(d.x, lBox(p, vec2(-1, 0) + rndL*rF, vec2(0), ew/2.));\n            d.x = min(d.x, lBox(p, vec2(1, 0) + rndR*rF, vec2(0), ew/2.));\n            \n        }    \n        else {\n            d.x = min(d.x, lBox(p, vec2(0, 1) + rndT*rF, vec2(0), ew/2.));\n            d.x = min(d.x, lBox(p, vec2(0, -1) + rndB*rF, vec2(0), ew/2.));\n        }\n        #else\n        d.x = min(d.x, lBox(p, vec2(-1, 0) + rndL*rF, vec2(0), ew/2.));\n        d.x = min(d.x, lBox(p, vec2(1, 0) + rndR*rF, vec2(0), ew/2.));\n        d.x = min(d.x, lBox(p, vec2(0, 1) + rndT*rF, vec2(0), ew/2.));\n        d.x = min(d.x, lBox(p, vec2(0, -1) + rndB*rF, vec2(0), ew/2.));\n        #endif\n        \n        \n    }\n      \n    // Straight lines.\n    //d.x = min(d.x, lBox(p, vec2(0, -.5), vec2(0, .5), ew/2.));\n    //d.x = min(d.x, lBox(p, vec2(-.5, 0), vec2(.5, 0), ew/2.)); \n    \n    // Cut away the lines from the middle of the frame. You don't have to,\n    // but I prefer it.\n    #ifdef FRAMES\n    d.x = max(d.x, -ody);\n    #endif\n    \n    // Set the global ID to the cell object ID. Hacky coding --- There are\n    // better ways to do this. :)\n    gID = ip;\n    \n    // Return the distance functions.\n    return d;\n}\n\n\n// The square grid.\nfloat gridField(vec2 p){\n    \n    p = abs(fract(p) - .5);\n    float grid = abs(max(p.x, p.y) - .5) - .015;\n    \n    return grid;\n}\n\n\nvec3 pencil(vec3 col, vec2 p){\n    \n    // Rough pencil color overlay... The calculations are rough... Very rough, in fact, \n    // since I'm only using a small overlayed portion of it. Flockaroo does a much, much \n    // better pencil sketch algorithm here:\n    //\n    // When Voxels Wed Pixels - Flockaroo \n    // https://www.shadertoy.com/view/MsKfRw\n    //\n    // Anyway, the idea is very simple: Render a layer of noise, stretched out along one \n    // of the directions, then mix a similar, but rotated, layer on top. Whilst doing this,\n    // compare each layer to it's underlying greyscale value, and take the difference...\n    // I probably could have described it better, but hopefully, the code will make it \n    // more clear. :)\n    // \n    // Tweaked to suit the brush stroke size.\n    vec2 q = p*4.;\n    //q += vec2(n2D3G(oP*1.5), n2D3G(oP*1.5 + 7.3))*.1;\n    q *= rot2(-3.14159/2.5);\n    // I always forget this bit. Without it, the grey scale value will be above one, \n    // resulting in the extra bright spots not having any hatching over the top.\n    col = min(col, 1.);\n    // Underlying grey scale pixel value -- Tweaked for contrast and brightness.\n    float gr = (dot(col, vec3(.299, .587, .114)));\n    // Stretched fBm noise layer.\n    float ns = (n2D3G(q*4.*vec2(1./3., 3))*.64 + n2D3G(q*8.*vec2(1./3., 3))*.34)*.5 + .5;\n    // Compare it to the underlying grey scale value.\n    ns = gr - ns;\n    //\n    // Repeat the process with a couple of extra rotated layers.\n    q *= rot2(3.14159/2.);\n    float ns2 = (n2D3G(q*4.*vec2(1./3., 3))*.64 + n2D3G(q*8.*vec2(1./3., 3))*.34)*.5 + .5;\n    ns2 = gr - ns2;\n    q *= rot2(-3.14159/5.);\n    float ns3 = (n2D3G(q*4.*vec2(1./3., 3))*.64 + n2D3G(q*8.*vec2(1./3., 3))*.34)*.5 + .5;\n    ns3 = gr - ns3;\n    //\n    // Mix the two layers in some way to suit your needs. Flockaroo applied common sense, \n    // and used a smooth threshold, which works better than the dumb things I was trying. :)\n    ns = smoothstep(0., 1., min(min(ns, ns2), ns3)*2. + .25); // Rough pencil sketch layer.\n    //\n    // Mix in a small portion of the pencil sketch layer with the clean colored one.\n    //col = mix(col, col*(ns + .3), .75);\n    // Has more of a colored pencil feel. \n    col *= vec3(.8)*ns + .5;    \n    // Using Photoshop mixes, like screen, overlay, etc, gives more visual options. Here's \n    // an example, but there's plenty more. Be sure to uncomment the \"softLight\" function.\n    //col = softLight(col, vec3(ns)*.75);\n    // Uncomment this to see the pencil sketch layer only.\n    //if(mod(ip.x + ip.y, 2.)<.5) \n    // Grayscale override.\n    #ifdef GRAYSCALE\n    col = vec3(ns); \n    #endif\n    \n    #ifdef GRAY_WITH_COLOR\n    col = vec3(ns); \n    #endif\n    \n    return col;\n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n\n    // Aspect correct screen coordinates.\n    float iRes = min(iResolution.y, 750.);\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iRes;\n    \n    // Scaling and translation.\n    //\n    // You could rotate also, if you felt like it: rot2(a)*uv...\n    // Depending on perspective; Moving the oject toward the bottom left, \n    // or the camera to the north east (top right) direction. \n    vec2 p = uv*gSc - vec2(-1, -.5)*iTime;\n    \n    // Keeping a copy of the background vector.\n    vec2 oP = p;\n\n    // The smoothing factor -- based on scale.\n    float sf = 1./iResolution.y*gSc;\n  \n    // Wobbling the coordinates, just a touch, in order to give a subtle hand drawn appearance.\n    p += vec2(n2D3G(p*3.5), n2D3G(p*3.5 + 7.3))*.02;\n    \n    // Optional cell boundary display.\n    #ifdef SHOW_GRID\n    float grid = gridField(p);\n    #endif\n    \n    // Take two pattern samples, and save the IDs. I made the IDs global out\n    // of sheer laziness. :D\n    vec3 d = pattern(p);\n    vec2 ip = gID;\n    vec3 d2 = pattern(p - vec2(.05, -.05));\n    vec2 ip2 = gID;\n    //col = mix(col2, col.xzy, dot(col2, vec3(.299, .587, .114)));\n \n    // Highlighting the large and smaller objects. How you do that is up to you, but you\n    // have to produce two samples, then take the difference. Here, I've mixed the \n    // distance field value with a blurrier smoothstepped version of it, then compared\n    // it to the other sample. You have to keep the resultant value above zero, since \n    // negative highlight values don't make a lot of physical sense.\n    float ba = mix(d.y, smoothstep(0., sf*4., d.y), .35);\n    float bb = mix(d2.y, smoothstep(0., sf*4., d2.y), .35);\n    float b = max(bb - ba, 0.)/.07;\n    ba = mix(d.z, smoothstep(0., sf*4., d.z), .35);\n    bb = mix(d2.z, smoothstep(0., sf*4., d2.z), .35);\n    float b2 = max(bb - ba, 0.)/.07;\n    \n    \n\n    // Set the background to a... brown paper bag color? It must've been in \n    // style at the time. :)\n    vec3 col = vec3(.725, .7, .675);\n    \n    // Add a very subtle portion of the highlights to the background.\n    #ifdef HIGHLIGHTS\n    col *= (1. + (b)*.03);\n    #endif\n    \n    // Apply the line shadows and the fist layer object shadows.\n    #ifdef SHADOWS\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*1.65, d2.x))*.9);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, d2.y))*.9);\n    #endif\n    \n    \n    // Some random numbers, for random palette production and so forth.\n    vec2 rnd = hash22(ip)*.5 + .5;\n    vec2 rndb = hash22(ip + .25)*.5 + .5;\n    vec2 rndc = hash22(ip + .35)*.5 + .5;\n    \n    \n    // Use the random numbers above to produce a couple of varying layer palettes.\n    //\n    // First layer color.\n    vec3 lCol = vec3(1, .25 + rndb.x*.55, .2 + rndb.y*.6);\n    \n    // Second layer color.\n    vec3 lCol2 = (vec3(1, .5 + rndc.y*.5, .2 + rndc.x*.5)*.8 + .2);\n    \n    #ifdef CANDY_PALETTE\n    // Fabrices candy colored palette.\n    lCol = .65 + .3*cos(6.3*rndb.x + vec3(0, 23, 21));\n    lCol2 = .65 + .3*cos(6.3*rndb.x + vec3(0, 23, 21) + .5);\n    #endif\n    \n    #ifdef VARIED_PALETTE\n    lCol = (1. - vec3(1, .25 + rndb.x*.75, .2 + rndb.y*.8).zyx*.5);\n    #endif\n\n\n    #ifdef RANDOM_COLOR_FLIP\n    // Flip the colors on some tiles.\n    //if(mod(ip.x + ip.y, 2.)<.5){ \n    \tif(rnd.x<.35) lCol = lCol.xzy;\n    //}\n    \n        if(rnd.y<.35) lCol2 = lCol2.xzy;\n    #endif\n    \n    #ifdef HIGHLIGHTS\n    lCol *= (.95 + b*.25);\n    lCol2 *= (.95 + b2*.25); \n    #endif\n    //lCol2 = vec3(1)*dot(lCol2, vec3(.299, .587, .114));\n\n    // Edge width.\n    float ew = .0175;\n    \n    // The background lines.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*1.65, d.x)));\n  \n    \n    // The larger outer objects.\n    col = mix(col, vec3(0), (1. - smoothstep(-sf, sf, d.y - ew)));\n    col = mix(col, lCol, (1. - smoothstep(-sf, sf, d.y + ew)));\n   \n    // The smaller object overlays.\n    #ifdef SHADOWS\n    col = mix(col, vec3(0), (1. - smoothstep(-sf, sf, d2.z - ew))*.9);\n    #endif\n    col = mix(col, vec3(0), (1. - smoothstep(-sf, sf, d.z - ew)));\n    col = mix(col, lCol2, (1. - smoothstep(-sf, sf, d.z + ew)));\n    \n    \n    #ifdef SHOW_GRID\n    // Display the grid boundaries. Usually used for debug purposes.\n    col = mix(col, vec3(1), (1. - smoothstep(0., sf*2., grid - .02))*.35);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, grid)));\n    #endif\n    \n    \n    // POST PROCESSING\n    \n    #ifdef SKETCH\n    // Applying a very basic pencil shading look.\n    // Based on one of Flockaroo's pencil sketch algorithms.\n    col = pencil(col, oP);\n    #else    \n        #ifdef GRAYSCALE\n        col = vec3(1)*dot(col, vec3(.289, .597, .114));\n        #endif\n        #ifdef GRAY_WITH_COLOR\n        col = vec3(1)*dot(col, vec3(.289, .597, .114));\n       #endif\n    #endif\n    \n\n    #ifdef GRAY_WITH_COLOR\n    vec3 svCol = col;\n    \n    float rndh = hash21(ip + .17);\n    if(mod(ip.x + ip.y, 2.)>.5 && rndh<.5) col = mix(col, col*vec3(.5, .8, 1), 1. - smoothstep(0., sf, d.y));\n    if(rndh<.35) col = mix(col, svCol*vec3(1, .2, .4), 1. - smoothstep(0., sf, d.z));\n    \n    //if(hash21(ip + .17)<.3)col = mix(col, svCol*vec3(.5, .8, 1), 1. - smoothstep(0., sf, d.z));\n    //else if(hash21(ip + .17)<.6) col = mix(col, svCol*vec3(1, .2, .4), 1. - smoothstep(0., sf, d.z));\n    #endif\n\n    #ifdef LINE_OVERLAY\n    // Just some line overlays.\n    vec2 pt = p;\n    float offs = -.5;\n    //if(i<.5) offs += 2.;//pt.xy = -pt.xy;\n    pt = rot2(6.2831/3.)*pt;\n    float pat2 = clamp(cos(pt.x*6.2831*28. - offs)*2. + 1.5, 0., 1.);\n    col *= pat2*.4 + .7;\n    #endif\n    \n    #ifdef NAIVE_HATCH\n    float hatch = doHatch(oP/gSc, iRes);\n    col *= hatch*.5 + .7;\n    #endif\n    \n    #ifdef PAPER_GRAIN\n    // Cheap paper grain.\n    oP = floor(oP/gSc*1024.);\n    vec3 rn3 = vec3(hash21(oP), hash21(oP + 2.37), hash21(oP + 4.83));\n    col *= .9 + .1*rn3.xyz  + .1*rn3.xxx;\n    #endif\n    \n    col *= vec3(1.1, 1, .9);\n    \n    #ifdef REVERSE_PALETTE\n    col = col.zyx;\n    #endif\n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= min(pow(16.*(1. - uv.x)*(1. - uv.y)*uv.x*uv.y, 1./8.)*1.2, 1.);\n    \n    // Output to screen\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}","name":"Image","description":"","type":"image"}]}