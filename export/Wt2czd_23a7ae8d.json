{"ver":"0.1","info":{"id":"Wt2czd","date":"1595122067","viewed":138,"name":"Random connection grid","username":"HalbFettKaese","description":"The screen is split into grids with each one having a random point assigned to it. All points are connected to neighbours within a certain distance.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["grid","perlin","connections"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash31(vec3 p) {\n    float n = sin(dot(p + vec3(6421., 534.46, 146.42), vec3(417, 28906.34, 583421.7))+432.);\n    return fract(262144.*n); \n}\n\nvec2 hash22(vec2 p) { \n    float n = sin(548.86+dot(p, vec2(41, 289)));\n    return fract(vec2(262144, 32768)*n); \n}\n\nfloat fade(float t) {\n\treturn t * t * t * (t * (t * 6. - 15.) + 10.);\n}\n\nfloat lerp(float a, float b, float t) { return a + fade(t) * (b - a); }\n\n\nfloat perlin1D(float p, vec2 uv) {\n    float frp = fract(p);\n    float flp = floor(p);\n    vec2 v = vec2(0, 1);\n    float c1 = (frp - 0.) * hash31(vec3(flp + 0., uv));\n    float c2 = (frp - 1.) * hash31(vec3(flp + 1., uv));\n    return (1. + \n           \tlerp(c1, c2, frp)\n           )/2.;\n}\nvec2 layeredPerlin12(float p, vec2 uv, int layerNum, float fade, float fShift) {\n\tvec2 result = vec2(0);\n    float scale = 0.;\n    float frequency = 1.;\n    float weight = 1.;\n    for (int i = 0; i < layerNum; i++) {\n        result += vec2(\n            perlin1D(p*frequency, hash22(fract(uv*434.24)))*weight,\n            perlin1D(p*frequency, hash22(fract(uv*4623.75)))*weight\n        );\n    \tscale += weight;\n        weight *= fade;\n        frequency *= fShift;\n    }\n    \n    return (result/scale - .5)*8. + .5;\n}\n\nfloat distToLineSegment(vec2 v, vec2 w, vec2 p) {\n  // Return minimum distance between line segment vw and point p\n  float l2 = dot(v-w, v-w);  // i.e. |w-v|^2 -  avoid a sqrt\n  if (l2 == 0.0) return distance(p, v);   // v == w case\n  // Consider the line extending the segment, parameterized as v + t (w - v).\n  // We find projection of point p onto the line. \n  // It falls where t = [(p-v) . (w-v)] / |w-v|^2\n  // We clamp t from [0,1] to handle points outside the segment vw.\n  float t = max(0., min(1., dot(p - v, w - v) / l2));\n  vec2 projection = v + t * (w - v);  // Projection falls on the segment\n  return distance(p, projection);\n}\n\nvec2 currentPos(vec2 uv) {\n\treturn floor(uv) + layeredPerlin12(iTime/5., floor(uv), 10, .5, .5);\n}\n\nfloat line(vec2 pos1, vec2 pos2, vec2 uv, float cutoff) {\n    if (distance(pos1, pos2) > sqrt(2.)/cutoff) return 0.;\n\treturn smoothstep(.1, -.1,\n                     \tdistToLineSegment(\n                            pos1,\n                            pos2,\n                        \tuv\n                        )\n                      );\n}\n\nfloat net(vec2 uv) {\n\n    float col = 0.;\n    \n    vec2 fuv = fract(uv);\n    \n    col += smoothstep(.1, -.1, length(currentPos(uv) - fuv));\n    for (float x = -1.; x <= 1.; x += 1.) {\n        for (float y = -1.; y <= 1.; y += 1.) {\n            if (x == 0. && y == 0.) continue;\n            \n            vec2 pos1 = currentPos(uv);\n            vec2 pos2 = currentPos(uv + vec2(x, y));\n            if (x != 0. && y != 0.) {\n            \tcol = max(col, \n            \t          line(pos1, pos2, uv, 1.0)\n            \t         );\n                col = max(col,\n                          line(currentPos(uv + vec2(x, 0)), currentPos(uv + vec2(0, y)), uv, 1.0)\n                         );\n                continue;\n            }\n            col = max(col, \n                      line(pos1, pos2, uv, 1.5)\n                     );\n        }\n    }\n    return col;\n\t\n}\n\nmat2 rot(float angle) {\n\treturn mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x;\n    \n    uv *= 20.;\n    \n    vec2 M = -iMouse.xy/iResolution.xy;\n    \n    M *= 10.;\n    \n    vec3 col = vec3(0);\n    \n    for (float i = 0.1; i <= 1.; i *= 1.75) {\n        float scale = mix(6., .1, i);\n        float brightness = mix(0., 1., i);\n        vec2 p = (M + uv * scale)*rot(iTime/20.) + i * 3613.4 + iTime;\n    \tcol = mix(col, max(sin(vec3(.6, .3, .9)*iTime * i), vec3(.4)) * brightness, net(p));\n    }\n    \n    //if (fuv.x > .95 || fuv.y > .95) col.r = 1.;\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}