{"ver":"0.1","info":{"id":"dtsfWs","date":"1694027096","viewed":23,"name":"segment with holo","username":"tomcat7479","description":"通过线段的SDF函数绘制的发光的线段体/交替波动","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","segmentsdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n    R^2中线段的符号距离函数\n\n    分析\n        对于R^2中的线段而言，其符号距离我们需要分两种情况考虑：1. 外点对于线段的垂线恰好过线段本身 2. 外点对于线段的垂线在线段的外部\n    \n        假设线段的两个顶点分别为A,B, 外点为P, 下面我们分类考虑上述的两种情况:\n            1. P做AB的垂线, 且与AB交于点D\n               设向量AP = P - A, AB = B - A, AP与AB的夹角为theta, 则cos(theta) = <AB, AP>/|AB|*|AP|\n               则AP在AB上的投影AD的模|AD| = |AP|*cos(theta) = |AP|*<AB,AP>/|AB|*|AP| = <AB,AP>/|AB|\n               则向量AD = (|AD|/|AB|) * AB = (<AB, AP> / |AB|^2) * AB = <AB,AP>/<AB,AB> * AB\n               则垂线PD向量等于AP - AD = AP - <AB, AP>/<AB, AB> * AB, 令h = <AB, AP>/<AB, AB>, 则最终\n               我们得出：PD = AP - h*AB, 其长度|PD| = |AP - h * AB|\n               下面我们考虑一下h的取值范围:\n                    h = <AB, AP> / <AB, AB>, 从h的含义出发，实际上h表示的就是AD的模与AB的模的一个比例关系，如果此时\n                D恰好落在AB线段上，则AD的模的取值范围就一定在0到|AD|之间，故最终我们知道h的范围在[0, 1]\n\n            2. P做AB的垂线, 且与AB交于AB的延长线于D点, 此时D在线段AB的外部, 这里我们需要分两种情况: \n                1. AB从B开始延长, 按照这种情况, AD的模大于AB的模, 此时h > 1\n                2. AB从A开始延长, 按照这种情况, AD的模存在大于AB的情况，也存在小于AB的情况，但是注意此时的h是小于0的\n                   因为AD与AB的方向是相反的        \n                对于下面这两种情况，我们可以丢弃掉，因为其垂点并不在我们考虑的线段集合内部，按照SDF的含义：在空间中的\n                一个有限区域上确定一个点到区域边界的距离并同时对距离的符号进行定义：点在区域边界外部为正，内部为负，位\n                于边界上时为0\n\n            综上所述：h = clamp(dot(AP, AB) / dot(AB, AB), 0.0, 1.0)\n                     d = length(AP - h * AB)    \n*/\n\n\nfloat sdfSegment(vec2 p, vec2 a, vec2 b) {\n    vec2 ap = p - a;\n    vec2 ab = b - a;\n    float h = clamp(dot(ap,ab) / dot(ab,ab), 0.0, 1.0);\n    return length(ap -h * ab);  \n}\n\nvoid plot_segment(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float d = sdfSegment(uv, vec2(0.0), vec2(1.0));\n    vec3 color = vec3(smoothstep(1e-3, 1e-3 - 1e-4, d));\n    fragColor = vec4(color, 1.0);\n}\n\nvoid holo_segment(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 a = vec2(-0.6, 0.0);\n    vec2 b = vec2(0.6, 0.0);\n\n    float d = sdfSegment(uv, a, b);\n    float c = smoothstep(0.2, 0.2 - 0.01, d);\n\n    vec3 color = 1.0 - sign(c) * vec3(0.4, 0.5, 0.6);\n\n    color *= exp(-(1.0 + 4.0 * sin(iTime)) * d);\n\n    fragColor = vec4(color, 1.0);\n}\n\nvoid alternate_segment(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 a = vec2(-0.6, 0.0);\n    vec2 b = vec2(0.6, 0.0);\n\n    float d = sdfSegment(uv, a, b);\n    float c = smoothstep(0.2, 0.2 - 0.01, d);\n\n    vec3 color = 1.0 - sign(c) * vec3(0.4, 0.5, 0.6);\n\n    color *= 1.0 - exp(-5.0 * abs(d));\n    color *= 0.7 + 0.2 * sin(180.0 * d * sin(iTime));\n\n    fragColor = vec4(color, 1.0);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    alternate_segment(fragColor, fragCoord);\n}","name":"Image","description":"","type":"image"}]}