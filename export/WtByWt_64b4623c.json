{"ver":"0.1","info":{"id":"WtByWt","date":"1595651080","viewed":75,"name":"Rotating normal small objects","username":"akanarika","description":"Small objects showing normal color","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","normal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec2 getBall(vec3 p) {\n    vec3 c = vec3(5, 0, 0);\n    return vec2(length(p - c) - 1., 1.);\n}\n\nvec2 getBox(vec3 p) {\n    vec3 size = vec3(1, 1, 2);\n    vec3 c = vec3(-5, 0, 0);\n    return vec2(length(max(abs(p - c) - size, 0.)), 2.);\n}\n\nvec2 getTorus(vec3 p) {\n\tvec3 c = vec3(0, 0, 5);\n    float r1 = 1.5;\n    float r2 = 1.;\n    vec3 pxz = vec3(p.x, 0, p.z);\n    vec3 pxzc = c - pxz;\n    float lpxzc = length(pxzc);\n    vec3 q = pxz + pxzc * (lpxzc - r1) / lpxzc;\n    return vec2(length(q - p) - r2, 3.);\n}\n\nvec2 getCapsule(vec3 p) {\n\tvec3 a = vec3(1, 2, -2);\n    vec3 b = vec3(-1, 0, -5);\n    float r = 1.;\n    vec3 ba = a - b;\n    vec3 pa = a - p;\n    float t = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    return vec2(length(pa - t * ba) - r, 4.);\n}\n\nvec2 getPlane(vec3 p) {\n    return vec2(p.y + 1., 5.);\n}\n\nvec2 getDist(vec3 p) {\n    float d = 1000000.;\n    float id = -1.;\n    vec2 res = getBall(p);\n    if (res.x < d) {\n        d = res.x;\n        id = res.y;\n    }\n    res = getBox(p);\n    if (res.x < d) {\n        d = res.x;\n        id = res.y;\n    }\n    res = getTorus(p);\n    if (res.x < d) {\n        d = res.x;\n        id = res.y;\n    }\n    res = getCapsule(p);\n    if (res.x < d) {\n        d = res.x;\n        id = res.y;\n    }\n    res = getPlane(p);\n    if (res.x < d) {\n        d = res.x;\n        id = res.y;\n    }\n    return vec2(d, id);\n}\n\nvec3 getNorm(vec3 p) {\n\tfloat eps = 0.001;\n    return normalize(vec3(getDist(vec3(p.x + eps, p.y, p.z)).x - getDist(vec3(p.x - eps, p.y, p.z)).x,\n                          getDist(vec3(p.x, p.y + eps, p.z)).x - getDist(vec3(p.x, p.y - eps, p.z)).x,\n                          getDist(vec3(p.x, p.y, p.z + eps)).x - getDist(vec3(p.x, p.y, p.z - eps)).x));\n}\n\nvec2 rayMarch(in vec3 ro, in vec3 rd) {\n\tfloat t = 0.;\n    float id = -1.;\n    for (int i = 0; i < 100; i++) {\n    \tvec3 p = ro + t * rd;\n        float h = getDist(p).x;\n        id = getDist(p).y;\n        t += h;\n        if (t > 300. || h < 0.001) break; \n    }\n    if (t > 300.) {\n        t = -1.;\n        id = -1.;\n    }\n    return vec2(t, id);\n}\n\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nmat3 v(vec3 ri, vec3 up, vec3 forw) {\n    return transpose(mat3(ri, up, forw));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\n    vec3 ro = vec3(0, 10, 30);\n    vec3 target = vec3(0, 0, 0);\n    vec3 rd = normalize(vec3(uv.x , uv.y + .1, -1));\n    \n    if (iMouse.z > 0.) ro.xz *= rot(iMouse.x * 10. / iResolution.x);\n    else ro.xz *= rot(iTime * .5);\n    \n    vec3 up = normalize(vec3(0, 1, 0));\n    vec3 forw = normalize(ro - target);\n    vec3 ri = normalize(cross(up, forw));\n    rd *= v(ri, up, forw);\n\n    vec2 rm = rayMarch(ro, rd);\n    vec3 p = ro + rm.x * rd;\n    \n    vec3 col = rm.x > 0. ? vec3(getNorm(p)) : vec3(.4, .7, .8);\n    if (rm.y > 4.5) {\n    \tcol = vec3(.8, .8, .3);\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}