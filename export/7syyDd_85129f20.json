{"ver":"0.1","info":{"id":"7syyDd","date":"1655831409","viewed":236,"name":"Internet Memories","username":"panna_pudi","description":"Sorry for long notice. Internet Explorer cameo ","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["2d","loading"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define C(c) U.x -= .5; O += char(U, 64 + c)\n\nvec4 char(vec2 p, int c) {\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\nfloat frame(vec2 p) {\n    float d = 1e9;\n    float height = 0.45, width = 0.75;\n\n    float frame = sd_box(p, vec2(0., height), vec2(0., -height), width);\n    frame = abs(frame + 0.03) - 0.035;\n\n    float line = crosss(p);\n    d = max(frame, -line + 0.003);\n\n    float inner = sd_box(p, vec2(0., height - 0.08), vec2(0., -(height - 0.08)), width - 0.16);\n    inner = abs(inner) - 0.0007;\n    d = min(d, inner);\n\n    vec2 q = p - vec2(0., 0.02);\n    inner = sd_box(q, vec2(0., height - 0.22), vec2(0., -(height - 0.22)), width - 0.32);\n    inner = abs(inner) - 0.0006;\n    d = min(d, inner);\n\n    float stripe = sd_box(vec2(abs(q.x), q.y), vec2(0.43, 0.), vec2(0.04, 0.5), 0.095);\n    d = max(d, -stripe);\n\n    stripe = sd_box(vec2(abs(q.x), q.y - 0.022), vec2(0.43, 0.), vec2(0.04, 0.5), 0.04);\n    stripe = min(stripe, sd_box(vec2(abs(q.x), q.y + 0.05), vec2(0.43, 0.), vec2(0.04, 0.5), 0.005));\n    stripe = max(stripe, sd_box(p, vec2(0.0, height + 0.005), vec2(0.0, -height), width + 0.01));\n    d = min(d, stripe);\n\n    return d;\n}\n\nfloat logo(vec2 p) {\n    float d = 1e9;\n    p *= 0.77;\n    {\n        vec2 p = p - vec2(0.04, 0.);\n        float base = length(p) - 0.13;\n        d = base;\n        d = max(d, -sd_ellipse(p, vec2(0.072, 0.08)));\n\n        vec2 q = p;\n        q *= rot(PI / 4.);\n        float ring = sd_ellipse(q - vec2(-0.02, 0.), vec2(0.08, 0.19));\n        ring = max(ring, -sd_ellipse(q - vec2(-0.006, 0.), vec2(0.055, 0.17)));\n        ring = max(ring, -base);\n        d = min(d, ring);\n    }\n    float w = 0.03;\n    d = min(d, sd_box(p - vec2(0.030, -0.00), vec2(-0.11, 0.), vec2(0.13, 0.), w));\n    d = max(d, -sd_box(p - vec2(0.16, -0.0276), vec2(-0.08, 0.), vec2(0.05, 0.), 0.025));\n\n    float trig =\n        sd_triangle(p, vec2(-0.15, 0.), vec2(-0.031, 0.078), vec2(-0.094, -0.01));\n    d = max(d, -trig);\n    return d;\n}\n\n// iq's abs\nfloat polyAbs(float x) {\n    const float m = 2.;\n    const float n = 0.05;\n\n    x = abs(x);\n    if(x > m) return x;\n    float a = 2.0*n - m;\n    float b = 2.0*m - 3.0*n;\n    float t = x / m;\n    return (a*t + b)*t*t + n;\n}\n\nfloat seigaiha(vec2 uv) {\n    float d = 1e9;\n\n    float rep = 0.29;\n\n    for (int i = 0; i < 4; ++i) {\n        vec2 p = uv;\n        p -= vec2(0.15, -0.15) * float(i);\n        p.x = p.x - rep * clamp(round(p.x / rep), -1., 1.);\n\n        float c = sd_circle(p, 0.15);\n        float b = c < 0. ? polyAbs(smod(c + 0.02, 0.05)) - 0.05 : c;\n        \n        d = max(d, -sd_circle(p, 0.17));\n        d = min(d, b);\n}\n\n    return d;\n}\n\nvec3 draw(vec2 uv, vec2 fragCoord) {\n    float d = frame(uv);\n    d = min(d, logo(uv + vec2(0.04, -0.01)));\n    \n    vec2 p = abs(uv) * 1.5 - vec2(1.027, 0.85);\n    d = min(d, seigaiha(p));\n\n    vec3 col = mix(vec3(0.), vec3(1.), AAstep(0., d));\n\n    // Text\n    vec4 O = vec4(0.0); vec2 position = vec2(.62, 0.22);\n    float font_size = 3.5;\n    uv = fragCoord / iResolution.y;\n    vec2 U = (uv - position) * 64.0 / font_size;\n    C(9);C(46);C(52);C(37);C(50);C(46);C(37);C(52);C(-32);\n    C(5);C(56);C(48);C(44);C(47);C(50);C(37);C(50);\n    uv = fragCoord / iResolution.y; font_size = 4.;\n    position = vec2(0.7, 0.15);\n    U = (uv - position) * 64.0 / font_size;\n    C(-15);C(-7);C(-7);C(-11);C(-19);C(-14);C(-16);C(-14);C(-14);\n    col -= O.x;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n\n    vec3 col = draw(uv, fragCoord);\n    col = mix(col, col + .13, hash21(uv));\n    \n    float time = mod(iTime, 100.); \n    float process = time / 15.;\n    if (time > 6.7) { process = .435 + time / 450.; }\n    if (time > 57.7){ process = 0.564; }\n    \n    float cells = 30.;\n    uv = vec2(fragCoord.x, iResolution.y - fragCoord.y);\n    float size = iResolution.x / cells;\n    vec2 cp = floor(uv / size);\n    float id = cp.x + cp.y * cells;\n    float loading = id / (cells * cells);\n    loading = step(process, loading);\n    \n    col = mix(col, vec3(hash21(uv * 20.)), loading);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = acos(-1.);\n\n#define AAstep(x0, x) clamp(((x) - (x0)) / (2. / iResolution.y), 0., 1.)\n#define S(v) smoothstep(0., 30. / iResolution.x, v)\n#define smod(x, k) S(k / 4. - abs(mod(x - k / 4., k) - k / 2.))\n#define xord(a, b, c) min(max(a, -(b) + c), max(b, -(a)))\n\nfloat hash21(vec2 p) {\n    return fract(sin(dot(p, vec2(23.43, 84.21))) * 4832.3234);\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sd_circle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat sd_box(in vec2 p, in vec2 a, in vec2 b, float th) {\n    float l = length(b - a);\n    vec2 d = (b - a) / l;\n    vec2 q = (p - (a + b) * 0.5);\n    q = mat2(d.x, -d.y, d.y, d.x) * q;\n    q = abs(q) - vec2(l, th) * 0.5;\n    return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0);\n}\n\nfloat sd_ellipse(in vec2 p, in vec2 ab) {\n    p = abs(p);\n    if (p.x > p.y) {\n        p = p.yx;\n        ab = ab.yx;\n    }\n    float l = ab.y * ab.y - ab.x * ab.x;\n    float m = ab.x * p.x / l; float m2 = m * m;\n    float n = ab.y * p.y / l; float n2 = n * n;\n    float c = (m2 + n2 - 1.0) / 3.0; float c3 = c * c * c;\n    float q = c3 + m2 * n2 * 2.0;\n    float d = c3 + m2 * n2;\n    float g = m + m * n2;\n    float co;\n    if (d < 0.0) {\n        float h = acos(q / c3) / 3.0;\n        float s = cos(h);\n        float t = sin(h) * sqrt(3.0);\n        float rx = sqrt(-c * (s + t + 2.0) + m2);\n        float ry = sqrt(-c * (s - t + 2.0) + m2);\n        co = (ry + sign(l) * rx + abs(g) / (rx * ry) - m) / 2.0;\n    } else {\n        float h = 2.0 * m * n * sqrt(d);\n        float s = sign(q + h) * pow(abs(q + h), 1.0 / 3.0);\n        float u = sign(q - h) * pow(abs(q - h), 1.0 / 3.0);\n        float rx = -s - u - c * 4.0 + 2.0 * m2;\n        float ry = (s - u) * sqrt(3.0);\n        float rm = sqrt(rx * rx + ry * ry);\n        co = (ry / sqrt(rm - rx) + 2.0 * g / rm - m) / 2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0 - co * co));\n    return length(r - p) * sign(p.y - r.y);\n}\n\nfloat sd_triangle(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2) {\n    vec2 e0 = p1 - p0, e1 = p2 - p1, e2 = p0 - p2;\n    vec2 v0 = p - p0, v1 = p - p1, v2 = p - p2;\n    vec2 pq0 = v0 - e0 * clamp(dot(v0, e0) / dot(e0, e0), 0.0, 1.0);\n    vec2 pq1 = v1 - e1 * clamp(dot(v1, e1) / dot(e1, e1), 0.0, 1.0);\n    vec2 pq2 = v2 - e2 * clamp(dot(v2, e2) / dot(e2, e2), 0.0, 1.0);\n    float s = sign(e0.x * e2.y - e0.y * e2.x);\n    vec2 d = min(min(vec2(dot(pq0, pq0), s * (v0.x * e0.y - v0.y * e0.x)),\n                     vec2(dot(pq1, pq1), s * (v1.x * e1.y - v1.y * e1.x))),\n                     vec2(dot(pq2, pq2), s * (v2.x * e2.y - v2.y * e2.x)));\n    return -sqrt(d.x) * sign(d.y);\n}\n\nfloat sd_segment(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nfloat crosss(vec2 p) {\n    p.y -= 0.075;\n    p.x = abs(p.x);\n    float line = sd_segment(p, vec2(-1.0), vec2(1.));\n    p *= rot(PI / 2.);\n    p.y += 0.15;\n    line = min(line, sd_segment(p, vec2(1.0), vec2(-1.))) - 0.002;\n    return line;\n}","name":"Common","description":"","type":"common"}]}