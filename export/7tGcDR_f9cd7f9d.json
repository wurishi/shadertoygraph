{"ver":"0.1","info":{"id":"7tGcDR","date":"1661244733","viewed":115,"name":"Simplifed Concentric Circles ","username":"cnlohr","description":"A new take on the optical illusion from https://twitter.com/Rainmaker1973/status/1561322229559726080","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["spiral","illusion"],"hasliked":0,"parentid":"ftyyWR","parentname":"Spiral Optical Illusion"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Illusion based on https://twitter.com/Rainmaker1973/status/1561322229559726080\n\nconst bool grey_bars = false;\n\nvec3 CalcColor( vec2 uvz )\n{\n\n    bool showdiamonds = true; //fract(iTime*0.1)>0.5;\n    \n    // THIS LINE is really cool.  The diamonds are what are **the key** to this illusion.\n    bool checkdiamonds = true;// fract(iTime*0.1)>0.5;   //XXX HEY, YOU!!! PLAY WITH TURNING THIS ON AND OFF.\n    \n    float segshift = 0.25;\n    \n    float spin_speed = 0.1;\n    float zoom_speed = -0.1;\n    const float segpairs = 18.0;\n    \n    vec2 thetar = vec2(atan( uvz.x, uvz.y ), length( uvz ) );\n\n    const float PI = 3.14159265;\n    const float TAU = PI * 2.0;\n    \n    thetar.x += PI;\n    \n    thetar.x += (iTime+iMouse.y*.1)*spin_speed;\n    \n    float segno;\n    float segplace = (thetar.x * segpairs / TAU);\n    segplace = modf( segplace, segno );\n\n    // For debugging\n    //return vec3( thetar.y );\n    float oneoverr = mix( 40.0, 1.0, pow( 1.0/thetar.y, 0.07) );\n    oneoverr += 0.5;\n    \n    \n    oneoverr += ( iTime + iMouse.x*.5) * zoom_speed;\n    \n    float oneoverrf = fract( oneoverr );\n\n    // For debugging\n    //return vec3( offset) ;\n\n    vec3 col = vec3( 1.0 );\n    float microseg = fract( segplace * 2.0 );\n    float segm = fract( oneoverrf - microseg*segshift );\n    float offset = floor(fract(oneoverr/2.0-segm/2.0)*2.0)*0.5;\n\nif( segm < 0.5 )\n    {\n        col = (fract( segplace + offset ) > 0.5)?vec3( 1.0, 1.0, 1.0 ):vec3( 0.0, 0.0, 0.0 );\n    }\n    else\n    {\n       col = (fract( segplace + offset + 0.25 ) > 0.5)?vec3( 0.1, 0.6, 1.0 ):vec3( 0.1, 0.6, 1.0 );\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvz = uv * 2. - 1.;\n    \n    // Grey bars on the sides.\n    if( grey_bars )\n        if( uvz.x < -iResolution.y/iResolution.x || uvz.x > iResolution.y/iResolution.x ) { fragColor = vec4( 0.5); return; }\n    \n    // Make it square.\n    uvz.x *= iResolution.x/iResolution.y;\n \n    vec3 col = vec3( 0.0 );\n    float count = 0.0;\n    \n    // Anti-alias it to mush.\n    vec2 uvofsl = vec2(1.3/iResolution.xy);\n    vec2 ofs = -uvofsl;\n    for( ; ofs.x <= uvofsl.x; ofs.x += uvofsl.x*0.3 )\n    {\n        for( ofs.y = -uvofsl.y; ofs.y <= uvofsl.y; ofs.y += uvofsl.y*0.3 )\n        {\n            col += CalcColor( uvz+ofs );\n            count ++;\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(col/count,1.0);\n}","name":"Image","description":"","type":"image"}]}