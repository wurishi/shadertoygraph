{"ver":"0.1","info":{"id":"XsVczh","date":"1521339717","viewed":218,"name":"EnhancedPhasePortrait","username":"soma_arc","description":"Hello, Phase Portrait\nReference:\nVisual Complex Functions: An Introduction with Phase Portraits by Elias Wegert","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","complex","phaseportrait"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec3 hsv2rgb(vec3 c) {\n    const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nconst float GAMMA_COEFF = 2.2;\nconst float DISPLAY_GAMMA_COEFF = 1. / GAMMA_COEFF;\n\n// Suggestions by FabriceNeyret2. Thank you.\n#define gammaCorrect(rgb)  min( pow( rgb, vec3(DISPLAY_GAMMA_COEFF) ), 1.)\n#define degamma(rgb)       min( pow( rgb, vec3(GAMMA_COEFF) ), 1.)\n#define compProd(a,b)      mat2(a,-a.y,a.x) * b\n#define compQuot(a,b)      mat2(a,(a).y,-(a).x)  * (b) / dot(b, b)\n#define hue(h)  ( .6 + .6 * cos( 6.3 *  (h)  + vec4(0,23,21,0)  ) )\n\n/*\nvec3 gammaCorrect(vec3 rgb) {\n  return min(pow(rgb, vec3(DISPLAY_GAMMA_COEFF)), 1.);\n}\n\nvec3 degamma(vec3 rgb) {\n  return min(pow(rgb, vec3(GAMMA_COEFF)), 1.);\n}\n\n/*\nvec2 compProd(const vec2 a, const vec2 b){\n\treturn vec2(a.x * b.x - a.y * b.y,\n                a.x * b.y + a.y * b.x);\n}\n\nvec2 compQuot(const vec2 a, const vec2 b){\n\tfloat denom = dot(b, b);\n    return vec2((a.x * b.x + a.y * b.y) / denom,\n                (a.y * b.x - a.x * b.y) / denom);\n}\n*/\n\nconst float PI = 3.141592;\nconst float TWO_PI = 2. * PI;\nconst int SAMPLE_NUM = 20;\nconst float GRAY_SCALE = 0.6;\nconst float CANVAS_SCALE = 4.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 sum = vec3(0);\n    vec2 initPosition = 2. * ( (fragCoord.xy - (iResolution.xy * 0.5)) / iResolution.y );\n    \n    for(int i = 0 ; i < SAMPLE_NUM ; i++){\n        vec2 position = initPosition + 2. * rand2n(fragCoord.xy, float(i)) / iResolution.y;\n        position = position * CANVAS_SCALE;\n        \n        position = compQuot(position - vec2(1. + sin(iTime), 0.4 + cos(iTime)),\n                            compProd(position, position) + position + vec2(1, 0)); \n        //position = compQuot(position - vec2(1., 0.), compProd(position, position) + position + vec2(1, 0)); \n        \n        float absModulus = 2. * log(length(position));\n        float modulusG = mix(1., fract(absModulus), GRAY_SCALE);\n        \n        float arg = atan(position.y, position.x) / TWO_PI;\n        float argG = mix(1., fract(arg * 10.), GRAY_SCALE);\n        sum += hsv2rgb(vec3(arg, 1., argG * modulusG));\n    }\n    fragColor = vec4((sum/float(SAMPLE_NUM)), 1.);\n}","name":"Image","description":"","type":"image"}]}