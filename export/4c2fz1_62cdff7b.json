{"ver":"0.1","info":{"id":"4c2fz1","date":"1724661594","viewed":58,"name":"Motion in electromagnetic field","username":"Kfirl","description":"Three particles moving under external+internal electromagnetic field, with verlet integration.\nKeys (see Common) control fields and charges, mouse moves camera.\nProject for ICP course.","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["simulation","physics","electromagnetism"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"makeStr  (printTitleCenterParticle) _C _E _N _T _E _R __ _P _A _R _T _I _C _L _E __ _C _H _A _R _G _E _S _COL _end\nmakeStrF (printQe) _Q _e __ _EQ __ _num_  _endNum\nmakeStrF (printQm) _Q _m __ _EQ __ _num_  _endNum\nmakeStr  (printTitleE) _E __ _EQ __ _LPR _end\nmakeStr  (printTitleB) _B __ _EQ __ _LPR _end\nmakeStr  (printTitleR1) _R _1 __ _EQ __ _LPR _end\nmakeStr  (printTitleV1) _V _1 __ _EQ __ _LPR _end\nmakeStr  (printTitleR2) _R _2 __ _EQ __ _LPR _end\nmakeStr  (printTitleV2) _V _2 __ _EQ __ _LPR _end\nmakeStr  (printTitleR3) _R _3 __ _EQ __ _LPR _end\nmakeStr  (printTitleV3) _V _3 __ _EQ __ _LPR _end\n\nmakeStrF (printNum) _num_  _endNum\nmakeStr  (printComma) _COM __ _end\nmakeStr  (printEnd) _RPR _end\nmakeStrF (printP1Q) _Q _1 __ _EQ __ _num_  _endNum\nmakeStrF (printP2Q) _Q _2 __ _EQ __ _num_  _endNum\nmakeStrF (printP3Q) _Q _3 __ _EQ __ _num_  _endNum\nmakeStr  (printTitleISF) _I _n _v _e _r _s _e _SUB _S _q _u _a _r _e __ _R _a _d _i _a _l __ _E _SUB _M __ _F _i _e _l _d _s _end\nmakeStr  (printTitleRF) _R _a _d _i _a _l __ _E _SUB _M __ _F _i _e _l _d _s _end\nmakeStr  (printTitleHF) _H _e _l _i _c _a _l __ _E _SUB _M __ _F _i _e _l _d _s _end\nmakeStr  (printTitleLF) _L _i _n _e _a _r __ _E _SUB _M __ _F _i _e _l _d _s _end\nmakeStr  (printTitlePC) _P _a _r _t _i _c _l _e _s _QT __ _C _h _a _r _g _e _s _end\n\n\nvec4 loadValue( in ivec2 coordIndex )\n{\n    return texelFetch( iChannel0, coordIndex, 0 );\n}\n\n\nfloat particlesMap(vec3 p, out vec3 color)\n{\n    \n    vec3  col0 = vec3(.8, .8, .2);\n    float dParticle0 = Sphere(p, CENTER_PARTICLE_POSITION, CENTER_PARTICLE_MASS * .1);\n    \n    vec3  col1 = vec3(.6, .2, .6);\n    vec3  P1R  = loadValue(txP1R.xy).xyz;\n    float P1M  = loadValue(txP1M.xy).x;\n    float dParticle1 = Sphere(p, P1R, P1M * 0.2);\n    \n    vec3  col2 = vec3(.2, .8, .8);\n    vec3  P2R  = loadValue(txP2R.xy).xyz;\n    float P2M  = loadValue(txP2M.xy).x;\n    float dParticle2 = Sphere(p, P2R, P2M * 0.2);\n    \n    vec3  col3 = vec3(.4, .4, .6);\n    vec3  P3R  = loadValue(txP3R.xy).xyz;\n    float P3M  = loadValue(txP3M.xy).x;\n    float dParticle3 = Sphere(p, P3R, P3M * 0.2);\n    \n    float d = min(min(min(dParticle0, dParticle1), dParticle2), dParticle3);\n    //float d = min(min(dParticle0, dParticle1), dParticle2);\n    //float d = min(dParticle0, dParticle1);\n    \n    if (d == dParticle0) {\n        color = col0;\n        return dParticle0;\n    }\n    else if (d == dParticle1) {\n        color = col1;\n        return dParticle1;\n    } \n    else if (d == dParticle2) {\n        color = col2;\n        return dParticle2;\n    }\n    else {\n        color = col3;\n        return dParticle3;\n    } \n}\n\n\nfloat cageMap(vec3 p, float wallSize, out vec3 color) \n{\n    vec3 xWallsColor = vec3(.5, 0., 0.);\n    vec3 yWallsColor = vec3(0., .5, 0.);\n    vec3 zWallsColor = vec3(0., 0., .5);\n    \n    float r = .5;\n\n    float dxWallP = sdPlain(p, vec3( wallSize, 0., 0.), vec3(-1.0, 0.0, 0.0)); // wall in the +X side\n    float dxWallN = sdPlain(p, vec3(-wallSize, 0., 0.), vec3( 1.0, 0.0, 0.0)); // wall in the -X side\n    float dyWallP = sdPlain(p, vec3(0.,  wallSize, 0.), vec3( 0.0,-1.0, 0.0)); // wall in the +Y side\n    float dyWallN = sdPlain(p, vec3(0., -wallSize, 0.), vec3( 0.0, 1.0, 0.0)); // wall in the -Y side\n    float dzWallP = sdPlain(p, vec3(0., 0.,  wallSize), vec3( 0.0, 0.0,-1.0)); // wall in the +Z side\n    float dzWallN = sdPlain(p, vec3(0., 0., -wallSize), vec3( 0.0, 0.0, 1.0)); // wall in the -Z side\n    \n    float d = min(min(min(min(min(dxWallP, dxWallN), dyWallP), dyWallN), dzWallP), dzWallN);\n    if (d == dxWallP || d == dxWallN)\n        color = xWallsColor;\n    else if (d == dyWallP || d == dyWallN)\n        color = yWallsColor;\n    else\n        color = zWallsColor;\n    \n    return d;\n}\n\n// Main map\nfloat map(vec3 p, out vec3 color) \n{\n\n    // Load Spheres\n    vec3 particlesColor;\n    float dParticles = particlesMap(p, particlesColor);\n\n    // Create Cage\n    vec3 cageColor;\n    float cageSize = SCENE_SIZE;\n    float dCage = cageMap(p, cageSize, cageColor);\n    \n    // Evaluate and return colored distance\n    float d = min(dCage, dParticles);\n    \n    if (d == dCage) {\n        color = cageColor;\n        return dCage;\n    }\n    else if (d == dParticles) {\n        color = particlesColor;\n        return dParticles;\n    }\n    \n    return d;\n}\n\n    // raymarching\nfloat RayMarch(vec3 ro, vec3 rd, out vec3 color) \n{    \n    float t = 0.;\n    for (int i = 0; i < 40; i++)\n    {\n        vec3 p = ro + rd * t;\n        \n        float d = map(p, color);\n\n        t += d;\n        \n        if (d<0.01 || t > 100.)\n            break;\n     }\n    return t;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec3 dummy;\n\tfloat d = map(p, dummy);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        map(p-e.xyy, dummy),\n        map(p-e.yxy, dummy),\n        map(p-e.yyx, dummy));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) \n{\n    float lightWallDist = 0.65;\n    vec3 lightPos = vec3(-SCENE_SIZE * lightWallDist, SCENE_SIZE * lightWallDist, - SCENE_SIZE * lightWallDist);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    vec3 dummy;\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*0.01*2., l, dummy);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. -iResolution.xy) / iResolution.y; // x -> <-2,2>, y -> <-1,1>\n    vec2 m =  (iMouse.xy * 2. -iResolution.xy) / iResolution.y;\n    \n    // Initialize RayMarching\n    vec3 ro = vec3(0., 0., -SCENE_SIZE * 0.8); // ray origin\n    vec3 rd = normalize(vec3(uv, 1.)); // ray direction\n    \n   \n    // Camera Rotation\n    ro.xz *= rot2D(-m.x);\n    rd.xz *= rot2D(-m.x);\n    ro.yz *= rot2D(-m.y);\n    rd.yz *= rot2D(-m.y);\n    \n    vec3 col = vec3(0.);\n\n    vec3 color;\n    float t = RayMarch(ro, rd, color);\n    \n    // For Lighting\n    vec3 p = ro + rd * t;\n    float dif = GetLight(p);\n    \n    col = color * dif;\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    \n    // ---------- //\n    // --- UI --- // \n    // ---------- //\n    \n    if (bool(loadValue(txUI).x) == true) \n    {\n    \n        vec4 E  = loadValue(txE);\n        vec4 B  = loadValue(txB);\n        vec4 Qe = loadValue(txQe);\n        vec4 Qm = loadValue(txQm);\n\n        vec4 P1Q = loadValue(txP1Q);\n        vec4 P1R = loadValue(txP1R);\n        vec4 P1V = loadValue(txP1V);\n\n        vec4 P2Q = loadValue(txP2Q);\n        vec4 P2R = loadValue(txP2R);\n        vec4 P2V = loadValue(txP2V);\n\n        vec4 P3Q = loadValue(txP3Q);\n        vec4 P3R = loadValue(txP3R);\n        vec4 P3V = loadValue(txP3V);\n\n        // Output to screen\n\n        uv.y -= .9;                  // Start writing from top\n        uv = uv * .5 - vec2(.6, .6); // Font size + padding left\n\n        vec3 yellow = vec3(.8, .8, .2);\n        vec3 red = vec3(.8, 0.0, 0.0);\n        vec3 green = vec3(0.0, 0.7, 0.0);\n        vec3 blue = vec3(0.0, 0.2, 0.8);\n\n        float x0 = 1.95;\n        col += yellow * printTitleLF(uv*1.35 + vec2(x0       ,  1.75));\n        col += yellow * printTitleE(uv*1.35  + vec2(x0       ,  1.85));\n        col += red    * printNum(uv*1.35     + vec2(x0 - .150,  1.85) , E.x, 1);\n        col += yellow * printComma(uv*1.35   + vec2(x0 - .273,  1.85));\n        col += green  * printNum(uv*1.35     + vec2(x0 - .303,  1.85) , E.y, 1);\n        col += yellow * printComma(uv*1.35   + vec2(x0 - .425,  1.85));\n        col += blue   * printNum(uv*1.35     + vec2(x0 - .455,  1.85) , E.z, 1);\n        col += yellow * printEnd(uv*1.35     + vec2(x0 - .580,  1.85));\n\n        col += yellow * printTitleB(uv*1.35  + vec2(1.95,   1.95) );\n        col += red    * printNum(uv*1.35     + vec2(1.8,    1.95)  , B.x, 1);\n        col += yellow * printComma(uv*1.35   + vec2(1.677,  1.95) );\n        col += green  * printNum(uv*1.35     + vec2(1.647,  1.95)  , B.y, 1);\n        col += yellow * printComma(uv*1.35   + vec2(1.525,  1.95) );\n        col += blue   * printNum(uv*1.35     + vec2(1.495,  1.95)  , B.z, 1);\n        col += yellow * printEnd(uv*1.35     + vec2(1.37,   1.95) );\n\n        col += yellow * printTitleISF(uv*1.35 + vec2(1.95,   0.85));\n        col += yellow * printQe(uv*1.35       + vec2(1.95,   0.93) , Qe.x, 1);\n        col += yellow * printQm(uv*1.35       + vec2(1.60,   0.93) , Qm.x, 1);\n        col += yellow * printTitleRF(uv*1.35  + vec2(1.95,   1.05));\n        col += yellow * printQe(uv*1.35       + vec2(1.95,   1.13) , Qe.y, 1);\n        col += yellow * printQm(uv*1.35       + vec2(1.60,   1.13) , Qm.y, 1);\n        col += yellow * printTitleHF(uv*1.35  + vec2(1.95,   1.25));\n        col += yellow * printQe(uv*1.35       + vec2(1.95,   1.33) , Qe.z, 1);\n        col += yellow * printQm(uv*1.35       + vec2(1.60,   1.33) , Qm.z, 1);\n\n\n        // P1\n        x0 = 0.35;\n        float y0 = 0.85;\n\n        col += yellow * printTitlePC(uv*1.35 + vec2(x0             , y0      ));\n        col += yellow * printP1Q(uv*1.35     + vec2(x0             , y0 + .08) , P1Q.x, 1);\n\n        col += yellow * printTitleR1(uv*1.35 + vec2(x0 - .0        , y0 + .16));\n        col += red    * printNum(uv*1.35     + vec2(x0 - .150 - .03, y0 + .16) , P1R.x, 1);\n        col += yellow * printComma(uv*1.35   + vec2(x0 - .273 - .06, y0 + .16));\n        col += green  * printNum(uv*1.35     + vec2(x0 - .303 - .06, y0 + .16) , P1R.y, 1);\n        col += yellow * printComma(uv*1.35   + vec2(x0 - .425 - .09, y0 + .16));\n        col += blue   * printNum(uv*1.35     + vec2(x0 - .455 - .09, y0 + .16) , P1R.z, 1);\n        col += yellow * printEnd(uv*1.35     + vec2(x0 - .580 - .12, y0 + .16));\n\n        col += yellow * printTitleV1(uv*1.35 + vec2(x0  -.0        , y0 + .24));\n        col += red    * printNum(uv*1.35     + vec2(x0 - .150 - .03, y0 + .24) , P1V.x, 1);\n        col += yellow * printComma(uv*1.35   + vec2(x0 - .273 - .06, y0 + .24));\n        col += green  * printNum(uv*1.35     + vec2(x0 - .303 - .06, y0 + .24) , P1V.y, 1);\n        col += yellow * printComma(uv*1.35   + vec2(x0 - .425 - .09, y0 + .24));\n        col += blue   * printNum(uv*1.35     + vec2(x0 - .455 - .09, y0 + .24) , P1V.z, 1);\n        col += yellow * printEnd(uv*1.35     + vec2(x0 - .580 - .12, y0 + .24));\n\n        // P2\n        y0 = y0 + .34;\n        col += yellow * printP2Q(uv*1.35     + vec2(x0             , y0       ), P2Q.x, 1);\n\n        col += yellow * printTitleR2(uv*1.35 + vec2(x0  -.0        , y0 + .08));\n        col += red    * printNum(uv*1.35     + vec2(x0 - .150 - .03, y0 + .08) , P2R.x, 1);\n        col += yellow * printComma(uv*1.35   + vec2(x0 - .273 - .06, y0 + .08));\n        col += green  * printNum(uv*1.35     + vec2(x0 - .303 - .06, y0 + .08) , P2R.y, 1);\n        col += yellow * printComma(uv*1.35   + vec2(x0 - .425 - .09, y0 + .08));\n        col += blue   * printNum(uv*1.35     + vec2(x0 - .455 - .09, y0 + .08) , P2R.z, 1);\n        col += yellow * printEnd(uv*1.35     + vec2(x0 - .580 - .12, y0 + .08));\n\n        col += yellow * printTitleV2(uv*1.35 + vec2(x0  -.0        , y0 + .16));\n        col += red    * printNum(uv*1.35     + vec2(x0 - .150 - .03, y0 + .16) , P2V.x, 1);\n        col += yellow * printComma(uv*1.35   + vec2(x0 - .273 - .06, y0 + .16));\n        col += green  * printNum(uv*1.35     + vec2(x0 - .303 - .06, y0 + .16) , P2V.y, 1);\n        col += yellow * printComma(uv*1.35   + vec2(x0 - .425 - .09, y0 + .16));\n        col += blue   * printNum(uv*1.35     + vec2(x0 - .455 - .09, y0 + .16) , P2V.z, 1);\n        col += yellow * printEnd(uv*1.35     + vec2(x0 - .580 - .12, y0 + .16));\n\n\n        // P3\n        y0 = y0 + .26;\n\n        col += yellow * printP3Q(uv*1.35     + vec2(x0             , y0      ) , P3Q.x, 1);\n\n        col += yellow * printTitleR3(uv*1.35 + vec2(x0  -.0        , y0 + .08));\n        col += red    * printNum(uv*1.35     + vec2(x0 - .150 - .03, y0 + .08) , P3R.x, 1);\n        col += yellow * printComma(uv*1.35   + vec2(x0 - .273 - .06, y0 + .08));\n        col += green  * printNum(uv*1.35     + vec2(x0 - .303 - .06, y0 + .08) , P3R.y, 1);\n        col += yellow * printComma(uv*1.35   + vec2(x0 - .425 - .09, y0 + .08));\n        col += blue   * printNum(uv*1.35     + vec2(x0 - .455 - .09, y0 + .08) , P3R.z, 1);\n        col += yellow * printEnd(uv*1.35     + vec2(x0 - .580 - .12, y0 + .08));\n\n        col += yellow * printTitleV3(uv*1.35 + vec2(x0  -.0        , y0 + .16));\n        col += red    * printNum(uv*1.35     + vec2(x0 - .150 - .03, y0 + .16) , P3V.x, 1);\n        col += yellow * printComma(uv*1.35   + vec2(x0 - .273 - .06, y0 + .16));\n        col += green  * printNum(uv*1.35     + vec2(x0 - .303 - .06, y0 + .16) , P3V.y, 1);\n        col += yellow * printComma(uv*1.35   + vec2(x0 - .425 - .09, y0 + .16));\n        col += blue   * printNum(uv*1.35     + vec2(x0 - .455 - .09, y0 + .16) , P3V.z, 1);\n        col += yellow * printEnd(uv*1.35     + vec2(x0 - .580 - .12, y0 + .16));\n    } \n    \n    // Final Output\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 loadValue( in ivec2 coordIndex )\n{\n    return texelFetch(iChannel0, coordIndex, 0 );\n}\n\nvoid storeValue(in ivec2 coordIndex, in vec4 coordValue, inout vec4 fragColor, in ivec2 fragCoord)\n{\n    fragColor = (coordIndex.x==fragCoord.x && coordIndex.y==fragCoord.y) ? coordValue : fragColor;\n}\n\n\n// 3 Particles\nvec3 ApplyForces3(vec3 R, vec3 V, float Q, float M, vec3 R1, float Q1, vec3 R2, float Q2)\n{\n    vec4 E = loadValue(txE);\n    vec4 B = loadValue(txB);\n    vec4 Qe = loadValue(txQe);\n    vec4 Qm = loadValue(txQm);\n    vec3 a = vec3(0.);\n    \n    // Culomb's law\n    // Electric fields induced by particles are included, but magnetic fields due to their (slow) motions are neglected.\n    a += (1./M) * (Fculomb(R, Q, R2, Q2) + Fculomb(R, Q, R2, Q2));\n    \n    // Linear E-M Field\n    a += (Q/M) * (E.xyz + cross(V, B.xyz));\n    \n    // Inverse-Squared Radial E-M Field\n    a += (Q/M) * (InverseSquareRadialField(R,Qe.x) + cross(V,InverseSquareRadialField(R,Qm.x)));\n    \n    // Radial E-M Field\n    a += (Q/M) * (RadialField(R, Qe.y) + cross(V, RadialField(R, Qm.y)));\n    \n    // Helical E-M Field\n    a += (Q/M) * (HelicalField(R, Qe.z) + cross(V, HelicalField(R, Qm.z)));\n    \n    return a;\n}\n\n/*\n// 2 Particles\nvec3 ApplyForces2(vec3 R, vec3 V, float Q, float M, vec3 R1, float Q1)\n{\n    vec4 E = loadValue(txE);\n    vec4 B = loadValue(txB);\n    vec4 Qe = loadValue(txQe);\n    vec4 Qm = loadValue(txQm);\n    vec3 a = vec3(0.);\n    \n    // Culomb's law\n    // Electric fields induced by particles are included, but magnetic fields due to their (slow) motions are neglected.\n    a += (1./M) * (Fculomb(R, Q, R1, Q1));\n    \n    // Linear E-M Field\n    a += (Q/M) * (E.xyz + cross(V, B.xyz));\n    \n    // Inverse-Squared Radial E-M Field\n    a += (Q/M) * (InverseSquareRadialField(R,Qe.x) + cross(V,InverseSquareRadialField(R,Qm.x)));\n    \n    // Radial E-M Field\n    a += (Q/M) * (RadialField(R, Qe.y) + cross(V, RadialField(R, Qm.y)));\n    \n    // Helical E-M Field\n    a += (Q/M) * (HelicalField(R, Qe.z) + cross(V, HelicalField(R, Qm.z)));\n    \n    return a;\n}\n\n\n// 1 Particle\nvec3 ApplyForces1(vec3 R, vec3 V, float Q, float M)\n{\n    vec4 E = loadValue(txE);\n    vec4 B = loadValue(txB);\n    vec4 Qe = loadValue(txQe);\n    vec4 Qm = loadValue(txQm);\n    vec3 a = vec3(0.);\n    \n    // Linear E-M field\n    a += (Q/M) * (E.xyz + cross(V, B.xyz));\n    \n    // Inverse-Squared Radial E-M Field\n    a += (Q/M) * (InverseSquareRadialField(R,Qe.x) + cross(V,InverseSquareRadialField(R,Qm.x)));\n    \n    // Radial E-M Field\n    a += (Q/M) * (RadialField(R, Qe.y) + cross(V, RadialField(R, Qm.y)));\n    \n    // Helical E-M Field\n    a += (Q/M) * (HelicalField(R, Qe.z) + cross(V, HelicalField(R, Qm.z)));\n    \n    return a;\n}\n*/\n\n// Motion Limits: Walls and max speed limitation\nvoid MotionLimits(in vec3 R, in vec3 V, in vec3 A, float M, inout vec3 newR, inout vec3 newV, inout vec3 newA)\n{\n    // Avoid Walls\n    if (abs(newR.x) > (SCENE_SIZE/1. - M * .1)) {\n        newR.x = R.x;\n        newV.x = 0.;\n        newA.x = 0.;\n    }\n    if (abs(newR.y) > (SCENE_SIZE/1. - M * .1)) {\n        newR.y = R.y;\n        newV.y = 0.;\n        newA.y = 0.;\n    }\n    if (abs(newR.z) > (SCENE_SIZE/1. - M * .1)) {\n        newR.z = R.z;\n        newV.z = 0.;\n        newA.z = 0.;\n    }\n    \n    // Limit Velocity\n    if (abs(newV.x) > MAX_VELOCITY) {\n        newV.x = MAX_VELOCITY;\n    }\n    if (abs(newV.y) > MAX_VELOCITY) {\n        newV.y = MAX_VELOCITY;\n    }\n    if (abs(newV.z) > MAX_VELOCITY) {\n        newV.z = MAX_VELOCITY;\n    }\n    \n    // Limit Acceleration\n    if (abs(newA.x) > MAX_ACCELERATION) {\n        newA.x = MAX_ACCELERATION;\n    }\n    if (abs(newA.y) > MAX_ACCELERATION) {\n        newA.y = MAX_ACCELERATION;\n    }\n    if (abs(newA.z) > MAX_ACCELERATION) {\n        newA.z = MAX_ACCELERATION;\n    }\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (any(lessThan(vec2(txP3M+1), fragCoord))) discard;\n    \n    // --------------------- //\n    // -- Initializiation -- //\n    // --------------------- //\n    \n    if( iFrame == 0)\n    {\n        fragColor = vec4(0.);\n        \n        storeValue(txP1R, initP1R, fragColor, ivec2(fragCoord));\n        storeValue(txP1Q, initP1Q, fragColor, ivec2(fragCoord));\n        storeValue(txP1V, initP1V, fragColor, ivec2(fragCoord));\n        storeValue(txP1A, initP1A, fragColor, ivec2(fragCoord));\n        storeValue(txP1M, initP1M, fragColor, ivec2(fragCoord));\n        \n        storeValue(txP2R, initP2R, fragColor, ivec2(fragCoord));\n        storeValue(txP2Q, initP2Q, fragColor, ivec2(fragCoord));\n        storeValue(txP2V, initP2V, fragColor, ivec2(fragCoord));\n        storeValue(txP2A, initP2A, fragColor, ivec2(fragCoord));\n        storeValue(txP2M, initP2M, fragColor, ivec2(fragCoord));\n        \n        storeValue(txP3R, initP3R, fragColor, ivec2(fragCoord));\n        storeValue(txP3Q, initP3Q, fragColor, ivec2(fragCoord));\n        storeValue(txP3V, initP3V, fragColor, ivec2(fragCoord));\n        storeValue(txP3A, initP3A, fragColor, ivec2(fragCoord));\n        storeValue(txP3M, initP3M, fragColor, ivec2(fragCoord));\n        \n        storeValue(txE,   initE,   fragColor, ivec2(fragCoord));\n        storeValue(txB,   initB,   fragColor, ivec2(fragCoord));\n        storeValue(txQe,  initQe,  fragColor, ivec2(fragCoord));\n        storeValue(txQm,  initQm,  fragColor, ivec2(fragCoord));\n        \n        storeValue(txUI, vec4(float(initUI), vec3(.0)) , fragColor, ivec2(fragCoord));\n        storeValue(txPrevFrameTime, vec4(iTime, vec3(0.)), fragColor, ivec2(fragCoord));\n    }\n\n    else\n    {\n        bool UIflag = bool(loadValue(txUI).x);\n        float prevFrameTime = loadValue(txPrevFrameTime).x;\n        float dt = iTime - prevFrameTime;\n        \n        // ------------------- //\n        // -- Update Params -- //\n        // ------------------- //\n\n        // Load Parameters\n        vec3  P1R = loadValue(txP1R).xyz;\n        vec3  P1V = loadValue(txP1V).xyz;\n        vec3  P1A = loadValue(txP1A).xyz;\n        float P1Q = loadValue(txP1Q).x;\n        float P1M = loadValue(txP1M).x;\n        \n        vec3  P2R = loadValue(txP2R).xyz;\n        vec3  P2V = loadValue(txP2V).xyz;\n        vec3  P2A = loadValue(txP2A).xyz;\n        float P2Q = loadValue(txP2Q).x;\n        float P2M = loadValue(txP2M).x;\n        \n        vec3  P3R = loadValue(txP3R).xyz;\n        vec3  P3V = loadValue(txP3V).xyz;\n        vec3  P3A = loadValue(txP3A).xyz;\n        float P3Q = loadValue(txP3Q).x;\n        float P3M = loadValue(txP3M).x;\n        \n        vec4 E = loadValue(txE);\n        vec4 B = loadValue(txB);\n        \n        vec4 Qe = loadValue(txQe);\n        vec4 Qm = loadValue(txQm);\n\n        // Evaluate Motion (Velocity Verlet)\n        vec3 newP1A = ApplyForces3(P1R, P1V, P1Q, P1M, P2R, P2Q, P3R, P3Q);\n        //vec3 newP1A = ApplyForces2(P1R, P1V, P1Q, P1M, P2R, P2Q);\n        //vec3 newP1A = ApplyForces1(P1R, P1V, P1Q, P1M);\n        vec3 newP1V = P1V + dt * .5 * (P1A + newP1A);\n        vec3 newP1R = P1R + dt * P1V + .5 * pow(dt,2.) * P1A;\n        \n        vec3 newP2A = ApplyForces3(P2R, P2V, P2Q, P2M, P1R, P1Q, P3R, P3Q);\n        //vec3 newP2A = ApplyForces2(P2R, P2V, P2Q, P2M, P1R, P1Q);\n        vec3 newP2V = P2V + dt * .5 * (P2A + newP2A);\n        vec3 newP2R = P2R + dt * P2V + .5 * pow(dt,2.) * P2A;\n\n        vec3 newP3A = ApplyForces3(P3R, P3V, P3Q, P3M, P1R, P1Q, P2R, P2Q);\n        vec3 newP3V = P3V + dt * .5 * (P3A + newP3A);\n        vec3 newP3R = P3R + dt * P3V + .5 * pow(dt,2.) * P3A;\n        \n        MotionLimits(P1R, P1V, P1A, P1M, newP1R, newP1V, newP1A);\n        MotionLimits(P2R, P2V, P2A, P2M, newP2R, newP2V, newP2A);\n        MotionLimits(P3R, P3V, P3A, P3M, newP3R, newP3V, newP3A);\n        \n        // Read User Input\n        float newP1Q = P1Q +  texelFetch(iChannel1, ivec2(KEY_7, 0), 0).x *  .1 * SCALE_SPEED \n                           +  texelFetch(iChannel1, ivec2(KEY_U, 0), 0).x * -.1 * SCALE_SPEED;\n        float newP2Q = P2Q +  texelFetch(iChannel1, ivec2(KEY_8, 0), 0).x *  .1 * SCALE_SPEED \n                           +  texelFetch(iChannel1, ivec2(KEY_I, 0), 0).x * -.1 * SCALE_SPEED;\n        float newP3Q = P3Q +  texelFetch(iChannel1, ivec2(KEY_9, 0), 0).x *  .1 \n                           +  texelFetch(iChannel1, ivec2(KEY_O, 0), 0).x * -.1;\n        vec4 newE    = E   + (texelFetch(iChannel1, ivec2(KEY_1, 0), 0).x *  vec4(.1, 0., 0., 0.) \n                           +  texelFetch(iChannel1, ivec2(KEY_2, 0), 0).x *  vec4(0., .1, 0., 0.)\n                           +  texelFetch(iChannel1, ivec2(KEY_3, 0), 0).x *  vec4(0., 0., .1, 0.)\n                           +  texelFetch(iChannel1, ivec2(KEY_Q, 0), 0).x * -vec4(.1, 0., 0., 0.) \n                           +  texelFetch(iChannel1, ivec2(KEY_W, 0), 0).x * -vec4(0., .1, 0., 0.)\n                           +  texelFetch(iChannel1, ivec2(KEY_E, 0), 0).x * -vec4(0., 0., .1, 0.)) * SCALE_SPEED;\n        vec4 newB    = B   + (texelFetch(iChannel1, ivec2(KEY_A, 0), 0).x *  vec4(.1, 0., 0., 0.) \n                           +  texelFetch(iChannel1, ivec2(KEY_S, 0), 0).x *  vec4(0., .1, 0., 0.)\n                           +  texelFetch(iChannel1, ivec2(KEY_D, 0), 0).x *  vec4(0., 0., .1, 0.)\n                           +  texelFetch(iChannel1, ivec2(KEY_Z, 0), 0).x * -vec4(.1, 0., 0., 0.) \n                           +  texelFetch(iChannel1, ivec2(KEY_X, 0), 0).x * -vec4(0., .1, 0., 0.)\n                           +  texelFetch(iChannel1, ivec2(KEY_C, 0), 0).x * -vec4(0., 0., .1, 0.)) * SCALE_SPEED;\n        vec4 newQe   = Qe  + (texelFetch(iChannel1, ivec2(KEY_4, 0), 0).x *  vec4(.1, 0., 0., 0.) \n                           +  texelFetch(iChannel1, ivec2(KEY_5, 0), 0).x *  vec4(0., .1, 0., 0.)\n                           +  texelFetch(iChannel1, ivec2(KEY_6, 0), 0).x *  vec4(0., 0., .1, 0.)\n                           +  texelFetch(iChannel1, ivec2(KEY_R, 0), 0).x * -vec4(.1, 0., 0., 0.) \n                           +  texelFetch(iChannel1, ivec2(KEY_T, 0), 0).x * -vec4(0., .1, 0., 0.)\n                           +  texelFetch(iChannel1, ivec2(KEY_Y, 0), 0).x * -vec4(0., 0., .1, 0.)) * SCALE_SPEED;\n        vec4 newQm   = Qm  + (texelFetch(iChannel1, ivec2(KEY_F, 0), 0).x *  vec4(.1, 0., 0., 0.) \n                           +  texelFetch(iChannel1, ivec2(KEY_G, 0), 0).x *  vec4(0., .1, 0., 0.)\n                           +  texelFetch(iChannel1, ivec2(KEY_H, 0), 0).x *  vec4(0., 0., .1, 0.)\n                           +  texelFetch(iChannel1, ivec2(KEY_V, 0), 0).x * -vec4(.1, 0., 0., 0.) \n                           +  texelFetch(iChannel1, ivec2(KEY_B, 0), 0).x * -vec4(0., .1, 0., 0.)\n                           +  texelFetch(iChannel1, ivec2(KEY_N, 0), 0).x * -vec4(0., 0., .1, 0.)) * SCALE_SPEED;                           \n        \n        bool newUIflag = bool(texelFetch(iChannel1, ivec2(KEY_SPACE, 0), 0).x);\n        if (newUIflag == true) {\n            UIflag = !UIflag;\n        }\n        \n        \n        // Store all values\n        fragColor = vec4(.0);\n        storeValue(txP1R, vec4(newP1R,      0. ), fragColor, ivec2(fragCoord));\n        storeValue(txP1V, vec4(newP1V,      0. ), fragColor, ivec2(fragCoord));\n        storeValue(txP1A, vec4(newP1A,      0. ), fragColor, ivec2(fragCoord));\n        storeValue(txP1Q, vec4(newP1Q, vec3(0.)), fragColor, ivec2(fragCoord));\n        storeValue(txP1M, vec4(P1M   , vec3(0.)), fragColor, ivec2(fragCoord));\n        \n        storeValue(txP2R, vec4(newP2R,      0. ), fragColor, ivec2(fragCoord));\n        storeValue(txP2V, vec4(newP2V,      0. ), fragColor, ivec2(fragCoord));\n        storeValue(txP2A, vec4(newP2A,      0. ), fragColor, ivec2(fragCoord));\n        storeValue(txP2Q, vec4(newP2Q, vec3(0.)), fragColor, ivec2(fragCoord));\n        storeValue(txP2M, vec4(P2M   , vec3(0.)), fragColor, ivec2(fragCoord));\n        \n        storeValue(txP3R, vec4(newP3R,      0. ), fragColor, ivec2(fragCoord));\n        storeValue(txP3V, vec4(newP3V,      0. ), fragColor, ivec2(fragCoord));\n        storeValue(txP3A, vec4(newP3A,      0. ), fragColor, ivec2(fragCoord));\n        storeValue(txP3Q, vec4(newP3Q, vec3(0.)), fragColor, ivec2(fragCoord));\n        storeValue(txP3M, vec4(P3M   , vec3(0.)), fragColor, ivec2(fragCoord));\n        \n        storeValue(txE,   vec4(newE)            , fragColor, ivec2(fragCoord));\n        storeValue(txB,   vec4(newB)            , fragColor, ivec2(fragCoord));\n        storeValue(txQe,  vec4(newQe)           , fragColor, ivec2(fragCoord));\n        storeValue(txQm,  vec4(newQm)           , fragColor, ivec2(fragCoord));\n\n        storeValue(txUI, vec4(float(UIflag), vec3(0.)), fragColor, ivec2(fragCoord));\n        storeValue(txPrevFrameTime, vec4(iTime, vec3(0.)), fragColor, ivec2(fragCoord));\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// --------------- //\n// -- Constants -- //\n// --------------- //\n\nconst float SCENE_SIZE = 35.;\nconst float MAX_VELOCITY = 100.;\nconst float MAX_ACCELERATION = 100.;\nconst float SCALE_SPEED = 1.;\n\nconst vec3 CENTER_PARTICLE_POSITION = vec3(.0, .0, .0);\nconst float CENTER_PARTICLE_MASS = 1.; // used to determine the size of the particle for the function that creates the particles.\n\n\n// ------------------------- //\n// -- Define Key Bindings -- //\n// ------------------------- //\n\nconst int KEY_1 = 49; // increase Ex // --------------------------- //\nconst int KEY_2 = 50; // Increase Ey // --------------------------- //\nconst int KEY_3 = 51; // Increase Ez // --------------------------- //\n                                     // -- Linear Electric Field -- //\nconst int KEY_Q = 81; // Decrease Ex // --------------------------- //\nconst int KEY_W = 87; // Decrease Ey // --------------------------- //\nconst int KEY_E = 69; // Decrease Ez // --------------------------- //\n \nconst int KEY_A = 65; // Increase Bx // --------------------------- //\nconst int KEY_S = 83; // Increase By // --------------------------- //\nconst int KEY_D = 68; // Increase Bz // --------------------------- //\n                                     // -- Linear Magnetic Field -- //\nconst int KEY_Z = 90; // Decrease Bx // --------------------------- //\nconst int KEY_X = 88; // Decrease By // --------------------------- //\nconst int KEY_C = 67; // Decrease Bz // --------------------------- //\n\nconst int KEY_4 = 52; // Increase Qe - ISR (Inverse-Squared Radial Elecric Field)\nconst int KEY_5 = 53; // Increase Qe - R (Radial Electric Field)\nconst int KEY_6 = 54; // Increase Qe - H (Helical Electric Field)\n\nconst int KEY_R = 82; // Decrease Qe - ISR (Inverse-Squared Radial Electric Field)\nconst int KEY_T = 84; // Decrease Qe - R (Radial Electric Field)\nconst int KEY_Y = 89; // Decrease Qe - H (Helical Electric Field)\n\nconst int KEY_F = 70; // Increase Qm - ISR (Inverse-Squared Radial Magnetic Field)\nconst int KEY_G = 71; // Increase Qm - R (Radial Magnetic Field)\nconst int KEY_H = 72; // Increase Qm - H (Helical Magnetic Field)\n\nconst int KEY_V = 86; // Decrease Qm - ISR (Inverse-Squared Radial Magnetic Field)\nconst int KEY_B = 66; // Decrease Qm - R (Radial Magnetic Field)\nconst int KEY_N = 78; // Decrease Qm - H (Helical Magnetic Field)\n\nconst int KEY_7 = 55; // Increase Q1\nconst int KEY_8 = 56; // Increase Q2\nconst int KEY_9 = 57; // Increase Q3\n\nconst int KEY_U = 85; // Decrease Q1\nconst int KEY_I = 73; // Decrease Q2\nconst int KEY_O = 79; // Decrease Q3\n\nconst int KEY_SPACE = 32; // Show or Hide UI\n\n\n// --------------- //\n// -- functions -- //\n// --------------- //\n\n// Fields\n\n// Inverse-Squared Radial E-M Field.           = Q * 1/r^2\nvec3 InverseSquareRadialField(vec3 r, float Q) \n{ \n    if (abs(r.x) <= 0.01) {\n        if(r.x != 0.) {\n            r.x = 0.01 * sign(r.x);\n        }\n        else r.x = 0.01;\n    }\n    if (abs(r.y) <= 0.01) {\n        if(r.y != 0.) {\n            r.y = 0.01 * sign(r.y);\n        }\n        else r.y = 0.01;\n    }\n    if (abs(r.z) <= 0.01) {\n        if(r.z != 0.) {\n            r.z = 0.01 * sign(r.z);\n        }\n        else r.z = 0.01;\n    }\n    return Q * (normalize(r)/pow(length(r), 2.));\n}\n\n// Radial vector field.                        = Q * r.\nvec3 RadialField(vec3 r, float Q)\n{\n    return Q * r;\n}\n\n// Helical vector field.                       = Q (-z + x, y, x + z)\nvec3 HelicalField(vec3 r, float Q)\n{\n    return Q * vec3(-r.z + r.x, r.y, r.x + r.z);\n}\n\n// Culomb's force: \n// Same as the Inverse Sqsuared-Radial Electric Field, from source q2 at r2, that affects q at r.\nvec3 Fculomb(vec3 r, float q, vec3 r2, float q2)\n{\n    return q * InverseSquareRadialField(r - r2, q2);\n}\n\n\n// A Magnetic Field I made for debugging.\n/*\nvec3 BField(vec3 r) \n{\n    vec3 field = vec3(r.x/max(r.y, 0.1), r.y/max(r.z, 0.1), r.z/max(r.x, 0.1));\n    float maxFieldStrength = 5.0;  // Adjust this value as needed\n    return normalize(field) * min(length(field), maxFieldStrength);\n    //return vec3(min(r.x, 500.)/max(r.y, 0.1), min(r.y, 500.)/max(r.z, 0.1), min(r.z, 500.)/max(r.x, 0.1));\n    //return vec3(0.);\n}\n*/\n\n\n//------------------------------------------ //\n// -- Define Texels / Variables' Adresses -- //\n// ----------------------------------------- //\n\nconst ivec2 txPrevFrameTime    = ivec2(1, 1);\nconst ivec2 txUI   = ivec2(1, 3);\n\nconst ivec2 txP1R  = ivec2(31, 1); // Texel of particle 1's coordinate\nconst ivec2 txP1Q  = ivec2(31, 3); // Texel of particle 1's Charge\nconst ivec2 txP1V  = ivec2(31, 5); // Texel of particle 1's Velocity\nconst ivec2 txP1A  = ivec2(31, 7); // Texel of particle 1's Acceleration\nconst ivec2 txP1M  = ivec2(31, 9); // Texel of particle 1's Mass (size and mass correlate in this simulation)\n\nconst ivec2 txP2R  = ivec2(31,13);\nconst ivec2 txP2Q  = ivec2(31,15);\nconst ivec2 txP2V  = ivec2(31,17);\nconst ivec2 txP2A  = ivec2(31,19);\nconst ivec2 txP2M  = ivec2(31,21);\n\nconst ivec2 txP3R  = ivec2(31,23);\nconst ivec2 txP3Q  = ivec2(31,25); \nconst ivec2 txP3V  = ivec2(31,27);\nconst ivec2 txP3A  = ivec2(31,29);\nconst ivec2 txP3M  = ivec2(31,31); \n\nconst ivec2 txE    = ivec2(29,1);  // (Ex, Ey, Ez, null),      while Qe = electric charge of the particle at the center.\nconst ivec2 txB    = ivec2(29,3);  // (Bx, By, Bz, null),      while Qm = magnetic charge of the particle at the center.\nconst ivec2 txQe   = ivec2(29,5);  // (QeISR, QeR, QeH, null), Qe magnitude parameter of the electric fields (for ISR it's the source). (as if made by a charged particle). ISR - Inverse-Squared Radial (E(r) = Qe/r^2), R - Radial (E(r) = Qe*r), H - Helical (E(r) = Qe * (-z+x, y, x+z)).\nconst ivec2 txQm   = ivec2(29,7);  // (QmISR, QmR, QmH, null), Qm magnitude parameter of the magnetic fields. - same as in the electric fields.\n\n\n// --------------------------- //\n// -- Define Initial Values -- //\n// --------------------------- //\n\nconst vec4 initP1R  = vec4(vec3(5.0, 0.0, .0), 0.);\nconst vec4 initP1Q  = vec4(1., vec3(0.));\nconst vec4 initP1V  = vec4(vec3(0.0, 0., 0.), 0.);\nconst vec4 initP1A  = vec4(vec3(0.0, 0., 0.), 0.);\nconst vec4 initP1M  = vec4(5., vec3(0.));\n\nconst vec4 initP2R  = vec4(vec3(0.0, -2.0, 1.0), 0.);\nconst vec4 initP2Q  = vec4(2., vec3(0.));\nconst vec4 initP2V  = vec4(vec3(0.0, 0., 0.), 0.);\nconst vec4 initP2A  = vec4(vec3(0.0, 0., 0.), 0.);\nconst vec4 initP2M  = vec4(2., vec3(0.));\n\nconst vec4 initP3R  = vec4(vec3(-3.0, 0.0, 2.0), 0.);\nconst vec4 initP3Q  = vec4(3., vec3(0.));\nconst vec4 initP3V  = vec4(vec3(0.0, 0., 0.), 0.);\nconst vec4 initP3A  = vec4(vec3(0.0, 0., 0.), 0.);\nconst vec4 initP3M  = vec4(7., vec3(0.));\n\nconst bvec4 initUI           = bvec4(true, vec3(false));\nconst vec4 initPrevFrameTime = vec4(0., vec3(0.));\n\n// Linear E-M Fields\nconst vec4 initE   = vec4(0.9,  0.0, 0.0,  0.0);\nconst vec4 initB   = vec4(0.0,  0.0, 3.0,  0.0);\n\n// Other E-M Fields: (revs-squared-radial, radial, helical, none).\nconst vec4 initQe  = vec4(0.0,  0.0, 0.0,  0.0);\nconst vec4 initQm  = vec4(0.0,  0.0, 0.0,  0.0);\n\n\n// --------------- //\n// -- Rotations -- //\n// --------------- //\n\nmat2 rot2D(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n\n// ------------ //\n// -- Shapes -- //\n// ------------ //\n\n// Plain/Wall\nfloat sdPlain(vec3 p, vec3 pos, vec3 normal)\n{\n    vec3 n = normalize(normal);\n    return dot(p - pos, n);\n}\n\n// Sphere\nfloat Sphere(vec3 p, vec3 position, float radius)\n{\n    return length(p - position) - radius;\n}\n\n/*\nThese Shapes are not in use\n\n// Cylinder SDF\nfloat sdCylinder(vec3 p, vec3 dir, float radius, float height) \n{\n    dir = normalize(dir);\n    p = p - dir * height / 1.;\n    vec2 d = abs(vec2(length(cross(p, dir)), dot(p, dir))) - vec2(radius, height);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// Box frame SDF\nfloat sdBoxFrame(vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// Box/Wall\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b + r;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n// Cone\n//float sdCone( vec3 p, vec2 c, float h ) // either\nfloat sdCone( vec3 p, vec3 dir, vec2 q)\n{\n  \n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  //vec2 q = h*vec2(c.x/c.y,-1.0); testing their suggestion\n    dir = -normalize(dir);\n    vec3 axis = normalize(cross(vec3(0.0, 1.0, 0.0), dir)); // Axis of rotation\n    float angle = acos(dot(vec3(0.0, 1.0, 0.0), dir));      // Angle of rotation\n    mat3 rotationMatrix = mat3(\n    cos(angle) + axis.x * axis.x * (1.0 - cos(angle)), axis.x * axis.y * (1.0 - cos(angle)) - axis.z * sin(angle), axis.x * axis.z * (1.0 - cos(angle)) + axis.y * sin(angle),\n    axis.y * axis.x * (1.0 - cos(angle)) + axis.z * sin(angle), cos(angle) + axis.y * axis.y * (1.0 - cos(angle)), axis.y * axis.z * (1.0 - cos(angle)) - axis.x * sin(angle),\n    axis.z * axis.x * (1.0 - cos(angle)) - axis.y * sin(angle), axis.z * axis.y * (1.0 - cos(angle)) + axis.x * sin(angle), cos(angle) + axis.z * axis.z * (1.0 - cos(angle))\n    );\n\n    // Rotate the point `p`\n    p = rotationMatrix * p;\n  \n  \n  vec2 w = vec2(length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\n// axis\nfloat axisDistance(vec3 p, out vec3 axisColor) \n{\n    // Small distance value for thin lines\n    float thickness = 0.02;\n\n    // Distance to x-axis (line along the y and z coordinates)\n    float dX = length(p.yz) - thickness;\n    // Distance to y-axis (line along the x and z coordinates)\n    float dY = length(p.xz) - thickness;\n    // Distance to z-axis (line along the x and y coordinates)\n    float dZ = length(p.xy) - thickness;\n\n    // Find the minimum distance and set the corresponding axis color\n    if (dX < dY && dX < dZ) {\n        axisColor = vec3(1.0, 0.0, 0.0);  // Red for x-axis\n        return dX;\n    } else if (dY < dZ) {\n        axisColor = vec3(0.0, 1.0, 0.0);  // Green for y-axis\n        return dY;\n    } else {\n        axisColor = vec3(0.0, 0.0, 1.0);  // Blue for z-axis\n        return dZ;\n    }\n}\n\n// Arrow \nfloat renderArrow(vec3 p, vec3 pos, vec3 vect) \n{\n\n    //float len = min(length(vect), 5.);\n    float len = 1.;\n    vec3 dir = normalize(vect);\n    float radShaft = .04;\n    float lenHead = .3;\n    float radHead = .7 * lenHead;\n    \n    float dShaft = sdCylinder(p - pos, dir, radShaft, len);\n    float dHead = sdCone(p - (pos + len * normalize(dir) * (2. * len/5.)), dir, vec2(radHead, lenHead));\n    \n    // Combine them\n    return min(dShaft, dHead);\n    \n}\n*/\n\n\n// ------------- //\n// -- UI Code -- //\n// ------------- //\n\n// Credits: \n// I used Kishimisu's code for the UI: https://www.shadertoy.com/view/43t3WX\n\n/*** Settings ***/\n\n#define FONT_TEXTURE iChannel2 // Set to the iChannel containing the alphabet texture\n\n#define FONT_SPACING 2.        // Horizontal character spacing [1 - 2.5]\n\n\n/* ### How to use this shader ? ###\n   \n   === Setup ===\n   \n   0. Copy the content of the \"Common\" tab inside your shader\n   1. Make sure the FONT_TEXTURE #define is set to the iChannel \n      containing the alphabet texture\n      \n      Also make sure the texture filter type is set to \"linear\"  \n      (not \"mipmap\", which creates horizontal lines between the characters)\n   \n   === Declare String ===\n   \n   2. Use makeStr to declare a new string (needs to be done outside any function)\n   3. Write your text using _ before each char, and __ for spaces\n   4. Finish your string with the _end keyword\n   \n       makeStr(printExample) _A _n _o _t _h _e _r __ _E _x _a _m _p _l _e    _end\n          \n   === Print String ===\n   \n   5. Call the new function by passing it your uvs. It returns a grayscale value.\n   \n       finalCol += printExample(uv);\n   \n   - Note that you are responsible for scaling/offsetting the uvs \n     to control the text placement before calling the function.\n   \n   - If you want to print float or integer variables, see below.\n   \n   \n   ###### Printing variables ######\n   \n   In order to print int & float variables, you can call two other functions instead of makeStr:\n   \n     - makeStrI (for integers) & makeStrF (for floats).\n     \n   [ IMPORTANT ]: When using makeStrI or makeStrF, you MUST use _endNum instead of _end \n                  to terminate a string.\n                  \n                  If you're seeing many errors when trying to compile, it's probably\n                  because you're using the wrong terminator for the current string type (_end/_endNum)\n   \n   === Declare Strings ===\n   \n   - In both cases, the variable will be displayed at the position of the _num_ keyword:\n   \n       makeStrI(print_my_int)   _M _y __ _I _n _t _e _g _e _r       _num_            _endNum\n       makeStrF(print_my_float) _F _l _o _a _t  _num_  _A _d _d _i _t _i _o _n _a _l _endNum\n   \n    - print_my_int   will be (vec2 uv, int num)\n    - print_my_float will be (vec2 uv, float num, int number_of_decimals)\n      \n   === Print Strings ===\n\n       print_my_int(uv, 42);          // will print \"My Integer 42\"\n       print_my_float(uv, 42.123, 2); // will print \"Float 42.12 Additional\"\n       \n    - A limitation of this version compared to the previous one is that you can only display\n      one variable per string definition (so only one _num_ keyword is allowed per string).\n   \n   === Debug variables without makeStr ===\n  \n   A handy thing you can do in your Image tab is to create \n   the following debugInt & debugFloat helpers:\n  \n       makeStrF(debugFloat) _num_ _endNum\n       makeStrI(debugInt) _num_ _endNum\n       \n   Defining these two helpers allow to quickly debug int/float variables, \n   without the need to create a full string definition every time using makeStr().\n \n      color += debugInt(uv, 42);\n      color += debugFloat(uv, 3.14, 2);\n \n \n   ### Characters available ###\n   \n   uppercase: _A _B _C ...\n   lowercase: _a _b _c ...\n   digits   : _0 _1 _2 ...\n   special  : _ADD _SUB _DOT ... (see \"Special Characters\" below)\n   \n   \n   ### Javascript string generator helper ###\n    \n    Even if this framework allow for easier string editing, it can still be a bit tedious to create\n    long strings with special characters, so I've also made a javascript function that you can run\n    in your developer console to easily create strings:\n\n    function createString(str) {\n        const special_chars = {\n            \" \": \"_\", \"!\": \"EX\", \"\\\"\":\"DBQ\", \"#\": \"NUM\", \"$\": \"DOL\", \"%\": \"PER\",  \"&\": \"AMP\", \n            \"\\'\":\"QT\", \"(\": \"LPR\", \")\": \"RPR\", \"*\": \"MUL\", \"+\": \"ADD\", \",\": \"COM\", \"-\": \"SUB\", \n            \".\": \"DOT\", \"/\": \"DIV\", \":\": \"COL\", \";\": \"SEM\", \"<\": \"LES\", \"=\": \"EQ\", \">\": \"GE\", \n            \"?\": \"QUE\", \"@\": \"AT\", \"[\": \"LBR\", \"\\\\\": \"ANTI\", \"]\": \"RBR\",  \"_\": \"UN\", \n        };\n        const num = str.indexOf('_num_');\n        const end = num == -1 ? ' _end' : ' _endNum';\n        str = str.replace('_num_', '').split('').map(e =>  '_' + (special_chars[e] || e));\n        if (num != -1) str = str.slice(0, num).concat( '_num_', str.slice(num));\n        return str.join(' ') + end;\n    }\n\n    Usage (static): \n        > createString(\"Hello World!\") \n        '_H _e _l _l _o __ _W _o _r _l _d _EX _end'\n           \n    Usage (variable): \n        > createString(\"My Number is _num_!\")\n        '_M _y __ _N _u _m _b _e _r __ _i _s __ _num_ _EX _endNum'\n*/\n\n// Special characters\n#define __    32,\n#define _EX   33, // \" ! \"\n#define _DBQ  34, // \" \" \"\n#define _NUM  35, // \" # \"\n#define _DOL  36, // \" $ \"\n#define _PER  37, // \" % \"\n#define _AMP  38, // \" & \"\n#define _QT   39, // \" ' \"\n#define _LPR  40, // \" ( \"\n#define _RPR  41, // \" ) \"\n#define _MUL  42, // \" * \"\n#define _ADD  43, // \" + \"\n#define _COM  44, // \" , \"\n#define _SUB  45, // \" - \"\n#define _DOT  46, // \" . \"\n#define _DIV  47, // \" / \"\n#define _COL  58, // \" : \"\n#define _SEM  59, // \" ; \"\n#define _LES  60, // \" < \"\n#define _EQ   61, // \" = \"\n#define _GE   62, // \" > \"\n#define _QUE  63, // \" ? \"\n#define _AT   64, // \" @ \"\n#define _LBR  91, // \" [ \"\n#define _ANTI 92, // \" \\ \"\n#define _RBR  93, // \" ] \"\n#define _UN   95, // \" _ \"\n\n// Digits\n#define _0 48,\n#define _1 49,\n#define _2 50,\n#define _3 51,\n#define _4 52,\n#define _5 53,\n#define _6 54,\n#define _7 55,\n#define _8 56,\n#define _9 57,\n// Uppercase\n#define _A 65,\n#define _B 66,\n#define _C 67,\n#define _D 68,\n#define _E 69,\n#define _F 70,\n#define _G 71,\n#define _H 72,\n#define _I 73,\n#define _J 74,\n#define _K 75,\n#define _L 76,\n#define _M 77,\n#define _N 78,\n#define _O 79,\n#define _P 80,\n#define _Q 81,\n#define _R 82,\n#define _S 83,\n#define _T 84,\n#define _U 85,\n#define _V 86,\n#define _W 87,\n#define _X 88,\n#define _Y 89,\n#define _Z 90,\n// Lowercase\n#define _a 97,\n#define _b 98,\n#define _c 99,\n#define _d 100,\n#define _e 101,\n#define _f 102,\n#define _g 103,\n#define _h 104,\n#define _i 105,\n#define _j 106,\n#define _k 107,\n#define _l 108,\n#define _m 109,\n#define _n 110,\n#define _o 111,\n#define _p 112,\n#define _q 113,\n#define _r 114,\n#define _s 115,\n#define _t 116,\n#define _u 117,\n#define _v 118,\n#define _w 119,\n#define _x 120,\n#define _y 121,\n#define _z 122,\n\n// ======  utils  ======\n\n#define print_char(i) \\\n    texture(FONT_TEXTURE, u + vec2(float(i)-float(x)/FONT_SPACING + FONT_SPACING/8., 15-(i)/16) / 16.).r\n\n// ======  makeStr()  ======\n\n// Function start\n#define makeStr(func_name)                               \\\n    float func_name(vec2 u) {                            \\\n        if (u.x < 0. || abs(u.y - .03) > .03) return 0.; \\\n        const int[] str = int[](                         \\\n\n// Function end\n#define _end  0);                                        \\\n    int x = int(u.x * 16. * FONT_SPACING);               \\\n    if (x >= str.length()-1) return 0.;                  \\\n    return print_char(str[x]);                           \\\n}\n\n\n// -------------------------------------------------------------------\n//    If you only plan to display static characters (no variables) \n//    you don't need to include anything below this disclaimer\n// -------------------------------------------------------------------\n\n// ======  makeStrFloat() & makeStrInt() ======\n\n#define log10(x) int(ceil(.4342944819 * log(x + x*1e-5)))\n#define _num_ 0); const int[] str2 = int[]( \n\n// makeStrFloat() start\n#define makeStrF(func_name)                              \\\n    float func_name(vec2 u, float num, int dec) {        \\\n        if (u.x < 0. || abs(u.y - .03) > .03) return 0.; \\\n        const int[] str1 = int[](\n\n// makeStrInt() start\n#define makeStrI(func_name)                              \\\n    float func_name(vec2 u, int num_i) {                 \\\n        if (u.x < 0. || abs(u.y - .03) > .03) return 0.; \\\n        float num = float(num_i);                        \\\n        const int dec = -1;                              \\\n        const int[] str1 = int[](\n\n// makeStrFloat & makeStrInt end\n#define _endNum  0);                            \\\n    const int l1 = str1.length() - 1;           \\\n    int x = int(u.x * 16. * FONT_SPACING);      \\\n    if (x < l1) return print_char(str1[x]);     \\\n    int neg = 0;                                \\\n    if (num < 0.) {                             \\\n        if (x == l1) return print_char(45);     \\\n        num = abs(num);                         \\\n        neg = 1;                                \\\n    }                                           \\\n    int pre = neg + max(1, log10(num));         \\\n    int s2 = l1 + pre + dec + 1;                \\\n    if (x >= s2) {                              \\\n        if (x >= s2+str2.length()-1) return 0.; \\\n        int n2 = str2[x - s2];                  \\\n        return print_char(n2);                  \\\n    }                                           \\\n    float d = float(l1 + pre - x);              \\\n    if (d == 0.) return print_char(46);         \\\n    d = pow(10., d < 0.  ? ++d : d);            \\\n    int n = 48 + int(10.*fract(num/.999999/d)); \\\n    return print_char(n);                       \\\n}\n\n/* === Curious about how makeStrI() and makeStrF() work ? ===\n\nHere is a broken-down and commented version of the following syntax:\n\n    makeStrF(print_string_with_float) _H _e _l _l _o _num_ _W _o _r _l _d _endNum\n    \nThis will translate exactly to the following code:\n\nfloat print_string_with_float(vec2 u, float num, int decimals) \n{\n    if (u.x < 0. || abs(u.y - .03) > .03) return 0.;\n    \n    // The number (num) will be displayed between these two strings.\n    // The separation is handled by the #define \"_num_\"\n    const int[] str1 = int[]( _H _e _l _l _o  0);\n    const int[] str2 = int[]( _W _o _r _l _d  0);\n    \n    const int str1_length = str1.length() - 1;\n    \n    int x = int(u.x * 16. * SPACING);\n    \n    // Print char from 1st string (before number)\n    if (x < str1_length) {\n        int n1 = str1[x];\n        return print_char(n1);\n    }\n    \n    // Handle negative numbers\n    int is_negative = 0;\n    if (num < 0.) {        \n        // Print a minus sign\n        if (x == str1_length) return print_char(45);\n        \n        num = abs(num);\n        is_negative = 1;\n    }\n        \n    int digit_count = is_negative + max(1, log10(num)); // Number of characters before decimal point\n    int num_length  = digit_count + decimals + 1;       // Total number of characters for the number\n    int str2_start  = str1_length + num_length;\n    \n    // Print char from 2nd string (after number)\n    if (x >= str2_start) {\n        const int str2_length = str2.length() - 1;\n        int n2 = str2[x - str2_start];\n        if (x >= str2_start + str2_length) return 0.; // right bound\n        return print_char(n2);\n    }\n        \n    // Print the decmial separator (dot)\n    if (x == str1_length + digit_count) {\n        return print_char(46);\n    }\n    \n    // Get current digit\n    int digit_index = x - str1_length;\n    if (digit_index > digit_count) {\n        // Offset by 1 for digits located after the decimal point\n        digit_index--;\n    }\n    float exponent = float(digit_count - digit_index);\n    int n = 48 + int(10.*fract(num/.999999/pow(10., exponent)));\n        \n    // Print digit\n    return print_char(n);\n}\n*/\n","name":"Common","description":"","type":"common"}]}