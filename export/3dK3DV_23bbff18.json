{"ver":"0.1","info":{"id":"3dK3DV","date":"1571006142","viewed":418,"name":"Refractive Objects","username":"nr4","description":"Texture and transparent objects similiar to scene shown in PC-64k intro 'Hardcyber' by Team210 at Deadline 2k19.","likes":24,"published":1,"flags":32,"usePreview":0,"tags":["fractal","refraction","demoscene"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Diamond Tricks as shown in Hardcyber by Team210 at Deadline 2k19\n * Copyright (C) 2019 Alexander Kraus <nr4@z10.info>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\nconst float fsaa = 64.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.);\n    float bound = sqrt(fsaa)-1.;\n   \tfor(float i = -.5*bound; i<=.5*bound; i+=1.)\n        for(float j=-.5*bound; j<=.5*bound; j+=1.)\n        {\n     \t\tcol += texture(iChannel0, fragCoord/iResolution.xy+vec2(i,j)*mix(3.,20.,2.*abs(fragCoord.y/iResolution.y-.5))*exp(-abs(1.e-2*length(fragCoord.xy)/iResolution.y-.5))/max(bound, 1.)/iResolution.xy).xyz;\n        }\n    col /= fsaa;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* Diamond Tricks similiar to scene in PC-64k intro 'Hardcyber' by Team210 at Deadline 2k19\n * Copyright (C) 2019 Alexander Kraus <nr4@z10.info>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n// Global constants\nconst float pi = acos(-1.);\nconst vec3 c = vec3(1.0, 0.0, -1.0);\nfloat a = 1.0;\nconst float ra = .5;\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nvoid hash22(in vec2 p, out vec2 d)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    d = fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvoid hash12(in vec2 p, out float d)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    d = fract((p3.x + p3.y) * p3.z);\n}\n// End of David Hoskins' code\n\nvoid lfnoise(in vec2 t, out float n)\n{\n    vec2 i = floor(t);\n    t = fract(t);\n    t = smoothstep(c.yy, c.xx, t);\n    vec2 v1, v2;\n    hash12(1.e3*i, v1.x);\n    hash12(1.e3*(i+c.xy), v1.y);\n    hash12(1.e3*(i+c.yx), v2.x);\n    hash12(1.e3*(i+c.xx), v2.y);\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    n = mix(v1.x, v1.y, t.x);\n}\n\nvoid dbox3(in vec3 x, in vec3 b, out float d)\n{\n  vec3 da = abs(x) - b;\n  d = length(max(da,0.0))\n         + min(max(da.x,max(da.y,da.z)),0.0);\n}\n\nvoid add(in vec2 sda, in vec2 sdb, out vec2 sdf)\n{\n    sdf = (sda.x<sdb.x)?sda:sdb;\n}\n\nvoid sub(in vec2 sda, in vec2 sdb, out vec2 sdf)\n{\n    sdf = (sda.x>sdb.x)?abs(sda):abs(sdb)*c.zx;\n}\n\nvoid dist(in vec2 a, in vec2 b, out float d)\n{\n    d = length(b-a);\n}\n\nvoid nearest_controlpoint(in vec2 x, out vec2 p)\n{\n    float dmin = 1.e5, \n        d;\n    vec2 dp,\n        y = floor(x);\n    \n    float i = 0.;\n    for(float i = -1.; i <= 1.; i += 1.)\n        for(float j = -1.; j <= 1.; j += 1.)\n        {\n            hash22(y+vec2(i,j), dp);\n            dp += y+vec2(i,j);\n            dist(x, dp, d);\n            if(d<dmin)\n            {\n                dmin = d;\n                p = dp;\n            }\n        }\n}\n\nvoid dvoronoi(in vec2 x, out float d, out vec2 p, out float control_distance)\n{\n    d = 1.e4;\n    vec2 y,\n        dp;\n    \n    nearest_controlpoint(x, p);\n    y = floor(p);\n    \n    control_distance = 1.e4;\n    \n    for(float i = -2.; i <= 2.; i += 1.)\n        for(float j = -2.; j <= 2.; j += 1.)\n        {\n            if(i==0. && j==0.) continue;\n            hash22(y+vec2(i,j), dp);\n            dp += y+vec2(i,j);\n            vec2 o = p - dp;\n            float l = length(o);\n            d = min(d,abs(.5*l-dot(x-dp,o)/l));\n            control_distance = min(control_distance,.5*l);\n        }\n}\n\nvoid rot3(in vec3 p, out mat3 rot)\n{\n    rot = mat3(c.xyyy, cos(p.x), sin(p.x), 0., -sin(p.x), cos(p.x))\n        *mat3(cos(p.y), 0., -sin(p.y), c.yxy, sin(p.y), 0., cos(p.y))\n        *mat3(cos(p.z), -sin(p.z), 0., sin(p.z), cos(p.z), c.yyyx);\n}\n\nmat3 gR;\nvec2 ind = c.yy;\nvoid scene(in vec3 x, out vec2 sdf)\n{\n    vec3 y = x;\n    x.xy += vec2(cos(.3*iTime), sin(.3*iTime));\n    \n    sdf.x = x.z;\n    sdf.y = 0.;\n    \n    float db = abs(length(y-.1*c.yyx)-.2), \n        dc;\n    dbox3(gR * (y-.1*c.yyx), .2*c.xxx/sqrt(2.), dc);\n    db = mix(db, abs(dc)-.001,step(fract(.25*iTime),.5));\n    add(sdf, vec2(db,1.), sdf);\n}\n\nvoid texture_scene(in vec3 x, out vec2 sdf)\n{\n    vec3 y = x;\n    x.xy += vec2(cos(.3*iTime), sin(.3*iTime));\n    \n    sdf.x = x.z;\n    sdf.y = 0.;\n    \n    float res = 8.;\n    vec2 sdb = c.xy;\n    for(float f = 0.; f < 6.; f += 1.)\n    {\n        float v, vp;\n        vec2 vi;\n        dvoronoi(res*x.xy, v, vi, vp);\n        vp /= res;\n        vi /= res;\n        v /= res;\n        add(sdb, vec2(length(x-vec3(vi,0.))-.5*vp, 0.), sdb);\n        res *= 2.;\n        \n        ind += vi/res;\n    }\n    sub(sdf, sdb, sdf);\n    \n    float db = abs(length(y-.1*c.yyx)-.2), \n        dc;\n    dbox3(gR * (y-.1*c.yyx), .2*c.xxx/sqrt(2.), dc);\n    db = mix(db, abs(dc)-.001, step(fract(.25*iTime),.5));\n    add(sdf, vec2(db,1.), sdf);\n}\n\nvoid normal(in vec3 x, out vec3 n, in float dx)\n{\n    vec2 s, na;\n    \n    scene(x,s);\n    scene(x+dx*c.xyy, na);\n    n.x = na.x;\n    scene(x+dx*c.yxy, na);\n    n.y = na.x;\n    scene(x+dx*c.yyx, na);\n    n.z = na.x;\n    n = normalize(n-s.x);\n}\n\nvoid texture_normal(in vec3 x, out vec3 n, in float dx)\n{\n    vec2 s, na;\n    \n    texture_scene(x,s);\n    texture_scene(x+dx*c.xyy, na);\n    n.x = na.x;\n    texture_scene(x+dx*c.yxy, na);\n    n.y = na.x;\n    texture_scene(x+dx*c.yyx, na);\n    n.z = na.x;\n    n = normalize(n-s.x);\n}\n\nvoid palette(in float scale, out vec3 col)\n{\n    scale = clamp(scale, 1.e-2,.99);\n    const int N = 5;\n    vec3 colors[N] = vec3[N](\nmix(vec3(0.20,0.27,0.35),vec3(1.00,0.00,0.47), step(fract(.25*iTime),.5)),\nmix(vec3(0.29,0.37,0.45),vec3(0.80,0.00,0.47), step(fract(.25*iTime),.5)),\nmix(vec3(0.36,0.65,0.64),vec3(0.60,0.00,0.47), step(fract(.25*iTime),.5)),\nmix(vec3(0.66,0.85,0.80),vec3(0.40,0.00,0.47), step(fract(.25*iTime),.5)),\nmix(vec3(0.95,0.92,0.82),c.yyy,step(fract(.5*iTime),.25))\n    );\n\tfloat index = floor(scale*float(N)), \n        remainder = scale*float(N)-index;\n    col = mix(colors[int(index)],colors[int(index)+1], remainder);\n}\n\nfloat sm(in float d)\n{\n    return smoothstep(1.5/iResolution.y, -1.5/iResolution.y, d);\n}\n\nvoid analytical_box(in vec3 o, in vec3 dir, in vec3 size, out vec2 d)\n{\n    vec3 tlo = min((size-o)/dir,(-size-o)/dir),\n        thi = max((size-o)/dir,(-size-o)/dir);\n    vec2 abxlo = abs(o.yz + tlo.x*dir.yz),\n        abylo = abs(o.xz + tlo.y*dir.xz),\n        abzlo = abs(o.xy + tlo.z*dir.xy),\n        abxhi = abs(o.yz + thi.x*dir.yz),\n        abyhi = abs(o.xz + thi.y*dir.xz),\n        abzhi = abs(o.xy + thi.z*dir.xy);\n    vec4 dn = 1.e4*c.xyyy;\n    \n    dn = mix(dn, vec4(tlo.x,c.xyy), float(all(lessThan(abxlo,size.yz)))*step(tlo.x,dn.x));\n    dn = mix(dn, vec4(tlo.y,c.yxy), float(all(lessThan(abylo,size.xz)))*step(tlo.y,dn.x));\n    dn = mix(dn, vec4(tlo.z,c.yyx), float(all(lessThan(abzlo,size.xy)))*step(tlo.z,dn.x));\n\n    d.x = dn.r;\n    \n    dn = 1.e4*c.xyyy;\n    dn = mix(dn, vec4(thi.x,c.xyy), float(all(lessThan(abxhi,size.yz)))*step(thi.x,dn.x));\n    dn = mix(dn, vec4(thi.y,c.yxy), float(all(lessThan(abyhi,size.xz)))*step(thi.y,dn.x));\n    dn = mix(dn, vec4(thi.z,c.yyx), float(all(lessThan(abzhi,size.xy)))*step(thi.z,dn.x));\n    \n    d.y = dn.r;\n}\n\nvoid analytical_sphere(in vec3 o, in vec3 dir, in float R, out vec2 d)\n{\n    float a = dot(dir,dir),\n        b = 2.*dot(o,dir),\n        cc = dot(o,o)-R*R,\n        dis = b*b-4.*a*cc;\n    vec2 dd = (dis<0.)?1.e4*c.xx:(c.xz*sqrt(dis)-b)/2./a;\n    d = vec2(min(dd.x, dd.y), max(dd.x, dd.y));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Set up global variables\n    rot3(vec3(1.1,1.3,1.5)*iTime, gR);\n    \n    // Set up coordinates and camera\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y,\n        s,\n        dd;\n    uv *= .5;\n    vec3 col = c.yyy,\n        o = c.yyx+.4*c.yzy,\n        r = c.xyy,\n        t = c.yyy, \n        u = cross(normalize(t-o),-r),\n        dir,\n        n, \n        x,\n        c1 = c.yyy,\n        l;\n    int N = 150,\n        i;\n    float d;\n    \n    t = uv.x * r + uv.y * u;\n    dir = normalize(t-o);\n\n    // Bounding objects\n    if(fract(.25*iTime) > .5)\n        analytical_sphere(o-.1*c.yyx, dir, .2, dd);\n    else\n\t    analytical_box(gR*(o-.1*c.yyx), gR*dir, .2*c.xxx/sqrt(2.), dd);\n    d = dd.x;\n    \n    if(d>1.e1) // Ray intersects outside of the refracting object\n    {\n        d = -o.z/dir.z;\n        col = c.xxx;\n    }\n    else // Ray intersects the refracting object\n    {\n        x = o + d * dir;\n        normal(x, n, 1.e-5);\n        \n        // Outside color\n        l = x+c.yxy+.5*c.yyx;\n        col = 3.*c.xxx;\n        col = .3*col \n       \t \t+ .5*col*dot(-l, n)\n        \t+ 3.7*col*pow(abs(dot(reflect(l,n),dir)),2.);\n        \n        dir = refract(dir, n, ra);\n        o = x;\n        \n        // Bounding objects again, but from the inside\n        if(fract(.25*iTime) > .5)\n            analytical_sphere(o-.1*c.yyx, dir, .2, dd);\n        else\n            analytical_box(gR*(o-.1*c.yyx), gR*dir, .2*c.xxx/sqrt(2.), dd);\n        d = dd.y;\n        \n        x = o + d * dir;\n        normal(x, n, 1.e-5);\n        \n        // Inside color\n        l = x+c.yxy+.5*c.yyx;\n        c1 = c.xxx;\n        c1 = .3*c1 \n       \t \t+ .5*c1*dot(-l, n)\n        \t+ 1.7*c1*pow(abs(dot(reflect(l,n),dir)),2.);\n        col = mix(col, c1, .7);\n        \n        dir = refract(dir, n, ra);\n        o = x;\n        \n        d = -o.z/dir.z;\n        x = o + d * dir;\n        normal(x, n, 1.e-5);\n    }\n    \n    // Raymarch texture\n    for(i = 0; i<N; ++i)\n    {\n        x = o + d * dir;\n        texture_scene(x,s);\n        if(s.x < 1.e-5)break;\n        d += s.x;\n    }\n     \n    // Colorize texture\n\tl = x+c.yxy+.5*c.yyx;\n    texture_normal(x,n, 2.e-5);\n        \n    float na;\n    lfnoise(ind-iTime, na);\n    palette(.5+.5*na, c1);\n        \n    c1 = .3*c1 \n        + .5*c1*dot(-l, n)\n        + .7*c1*pow(abs(dot(reflect(l,n),dir)),2.);\n    col = mix(col, c1, .9);\n    \n    // Post process\n    float da = 1.;\n\n    scene(vec3(uv,.1), s);\n    da = abs(s.x)-.003;\n\n    col = mix(col, 8.*col, sm(da/10.));\n    col = 2.*col*col*col;\n    \n    fragColor = vec4(clamp(col,0.,1.),1.);\n}\n","name":"Buf A","description":"","type":"buffer"}]}