{"ver":"0.1","info":{"id":"ws2SRV","date":"1554395694","viewed":141,"name":"Nova19GR_2","username":"gilesruscoe","description":"test shader for Nova demo party that I never used.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["blobs","twister","sludge","dots","colour","twist","tar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//// TONS OF COPY PASTE \n\n\n#define DISPLAY_GAMMA 1.8\n\n#define GOLDEN_ANGLE 2.39996323\n#define MAX_BLUR_SIZE 17.0\n\n// Smaller = nicer blur, larger = faster\n#define RAD_SCALE .55\n\n#define uFar 2.0\n\nfloat getBlurSize(float depth, float focusPoint, float focusScale)\n{\n\tfloat coc = clamp((1.0 / focusPoint - 1.0 / depth)*focusScale, -1.0, 1.0);\n    return abs(coc) * MAX_BLUR_SIZE;\n}\n\nvec3 depthOfField(vec2 texCoord, float focusPoint, float focusScale)\n{\n    vec4 Input = texture(iChannel0, texCoord).rgba;\n    float centerDepth = Input.a * uFar;\n    float centerSize = getBlurSize(centerDepth, focusPoint, focusScale);\n    vec3 color = Input.rgb;\n    float tot = 1.0;\n    \n    vec2 texelSize = 1.0 / iResolution.xy;\n\n    float radius = RAD_SCALE;\n    for (float ang = 0.0; radius < MAX_BLUR_SIZE; ang += GOLDEN_ANGLE)\n    {\n        vec2 tc = texCoord + vec2(cos(ang), sin(ang)) * texelSize * radius;\n        \n        vec4 sampleInput = texture(iChannel0, tc).rgba;\n\n        vec3 sampleColor = sampleInput.rgb;\n        float sampleDepth = sampleInput.a * uFar;\n        float sampleSize = getBlurSize(sampleDepth, focusPoint, focusScale);\n        \n        if (sampleDepth > centerDepth)\n        {\n        \tsampleSize = clamp(sampleSize, 0.0, centerSize*2.0);\n        }\n\n        float m = smoothstep(radius-0.5, radius+0.5, sampleSize);\n        color += mix(color/tot, sampleColor, m);\n        tot += 1.0;\n        radius += RAD_SCALE/radius;\n    }\n    \n    return color /= tot;\n}\n\nvec3 hueShift( vec3 color, float hueAdjust ){\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI      = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ      = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR     = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG     = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB     = vec3 (1.0, -1.107, 1.704);\n\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I       = dot (color, kRGBToI);\n    float   Q       = dot (color, kRGBToQ);\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    hue += hueAdjust;\n\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n\n    return vec3( dot (yIQ, kYIQToR), dot (yIQ, kYIQToG), dot (yIQ, kYIQToB) );\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = 2.0 * uv - 1.0;\n    uv *= 1.0/2.5;\n    uv = uv * 0.5 + 0.5;\n    vec4 color = texture(iChannel0, uv).rgba;\n    //fragColor = color;\n    //return;\n    float focusPoint = 3.1;// - (sin(iTime * 14.0) * 0.5 + 0.5) * 0.025;\n    float focusScale =  4.5;//(0.5 + sin(iTime * 0.5) * 0.5) * 8.0;\n    \n    color.rgb = depthOfField(uv, focusPoint, focusScale);\n\n    //tone mapping\n    //color.rgb = vec3(1.0, 1.0, 1.0) * color.rgb / (1.0 + color.rgb);\n    color.rgb = hueShift(vec3(2.0, 2.8, 3.5), iTime * 2.0) * color.rgb / (1.0 + color.rgb);\n    //inverse gamma correction\n\tfragColor = vec4(pow(color.rgb, vec3(1.0 / DISPLAY_GAMMA)), 1.0);\n    \n    //Vignette\n    vec2 vigUV = (uv - 0.5) * (iResolution.x/iResolution.y) * 2.0;\n    float Falloff = 0.75;\n    float rf = sqrt(dot(vigUV, vigUV)) * Falloff;\n    float rf2_1 = rf * rf + 1.0;\n    float e = 1.0 / (rf2_1 * rf2_1);\n    fragColor.rgb *= e;\n    // Debug depth\n    //fragColor.rgb = vec3(color.a)*0.015;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGzn","filepath":"/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","previewfilepath":"/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 hashCurl( vec3 p )\n{\n\n    \n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\tp = -1.0 + 2.0*fract(sin(p)*43758.5453123);\n#if 1\n\tfloat t=iTime*3.;\n\tmat2 m=mat2(vec2(cos(t),-sin(t)), vec2(sin(t),cos(t)));//it should be a mat3 but this just works.\n\tp.xz=m*p.xz;\n#endif\n\treturn p;\n}\n\nfloat noiseD( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hashCurl( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hashCurl( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hashCurl( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hashCurl( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hashCurl( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hashCurl( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hashCurl( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hashCurl( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nvec3 opTwist(in vec3 p, float k)\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return q;\n}\n\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0);// -(noise(p*150.0)*0.0025)-(noise(p*500.0)*0.001); // remove this line for an only partially signed sdf \n}\n\nfloat sdCloth( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0) -(noise(p*150.0)*0.0025)-(noise(p*500.0)*0.001); // remove this line for an only partially signed sdf \n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;//-(noise(p*150.0)*0.002);\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xy)-2.0*ra+rb, abs(p.z) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n// x = trace y = matID\nvec2 map(vec3 p)\n{\n    \n    //float time = min(2.0 + (length(p) * 5.0), iTime);\n    \n    // TIME PAUSE FEATURE TEST\n    float time = 2.0 * (sin(p.y * 1.0 + iTime * 2.0) * 0.5 + 0.5);//clamp(sin(iTime * .5) * 1.5, 0.0, 1.0);\n          time = smoothstep(time - 0.5, time + 0.5, 0.5);\n    time = min(2.0 + time, iTime);\n    \n    // Temp time instead of pause\n    //float time = iTime;\n    \n    // Audio tests\n    int tx = 1;\n\t// first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n\t//float fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n\n    // second row is the sound wave, one texel is one mono sample\n    //float wave = texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\n    float sound = texelFetch(iChannel1, ivec2(8, 1), 0).x;// * 0.85;\n    float sound2 = texelFetch(iChannel1, ivec2(8, 0), 0).x;// * 0.85;\n    sound *= 0.75;\n    sound2 *= 0.75;\n    \n    //time += sound * 0.15;\n    vec3 sp = p;\n    p = opTwist(p, sin(time * 0.25) *12.0);   \n    sp.xy = p.xy;\n    sp.z += time * 0.5;\n    //sp.xyz *= noise(sp) * 0.30;\n    if(abs(sp.x) < 2.0 + sin(time) * 1.0)\n    \tsp.xz = (fract(sp.xz * 10.0) - 0.5);\n    //sp.xy *= 3.0;\n    sp.x += 0.15;\n    sp.y += 0.2; \n   \tfloat sphere = sdSphere(sp, 0.035);\n    //return vec2(sphere, 0);\n    //\n    //\n    //p.y += sin(p.x * 44.0 - time * 0.5) * 0.0185;\n    //p.y += sin(p.x * 35.0 + time * 0.95) * 0.025;\n    //p.y += sin(p.x * 80.0 - time * 1.252) * 0.0008;\n    //p.y += sin(p.x * 92.0 + time * 2.2) * 0.00064;\n    //p.y += sin(p.x * 10.0 + time * 1.2) * 0.1;\n    \n    //p.z += sin(p.x * 12.0) * 0.05;\n    \n    float f = 0.0;\n    float sf = mix(1., 15.0, length(p) * 0.75);\n    vec3 q2 = sf*p;\n            f  = 0.5000*noiseD( q2 ); q2 = m*q2*2.01;\n            f += 0.2500*noiseD( q2 ); q2 = m*q2*2.02;\n            f += 0.1250*noiseD( q2 ); q2 = m*q2*2.03;\n            //f += 0.0625*noiseD( q2 ); q2 = m*q2*2.01;\n    vec3 p3 = p;\n    p3.y += f * 2.;// * 2.0 - 1.0;// .71;\n    float cloth = sdCloth(p3, vec3(0.85, 0.0, 0.5), 0.0);\n    \n    //This is cool dont know how\n    vec3 tubePos = p;\n    tubePos.x += sin(tubePos.x * (10.0 * sound2) + time * 2.0) * (sin(time * 1.0) * 0.5 + 0.5) * sound2;\n    //\n    tubePos.x -= 0.1;\n    tubePos.y += 0.05 + (sound * abs(tubePos.x * 10.0) * 0.5);\n    float tube = sdRoundedCylinder(tubePos, 0.005, 0.025, 0.8);\n    tubePos.x += 0.1;\n    tube = min(tube, sdRoundedCylinder(tubePos, 0.005, 0.025, 0.8));\n    tubePos.x += 0.1;\n    tube = min(tube, sdRoundedCylinder(tubePos, 0.005, 0.025, 0.8));\n    \n    //return tube;\n    tube = min(tube, sphere);\n    int id = tube < cloth ? 0 : 1;\n    return vec2(min(tube, cloth), id);\n    \n    //float a = atan(p.z, p.x);\n    //vec3 p1 = p.xyz;\n    //float distY = 1.0- clamp(abs(p.y * p.y) * 4.0, 0.0, 1.0);\n    //p1 *= 1.0 + sin(iTime * 7.0 + a * 10.0) * 0.1 * distY;\n    //p1 *= 1.0 + sin(iTime * 12.0 + a * 80.0) * 0.005 * distY;\n    //vec3 p2 = p.xyz;\n    //p2.xz *= 1.0 + sin(iTime * 5.0 + p.y * 20.0) * 0.15;\n    //p2.xz *= 1.0 + sin(iTime * 15.0 + p.y * 30.0) * 0.05;\n    //\n    //p = mix(p1, p2, clamp(sin(iTime * .5) * 1.5, 0.0, 1.0));\n    //return sdSphere(p, 0.5);\n    //return sdBox(p, vec3(0.5, 0.25, 0.25));\n}\n\n\nvec3 calcNormal( in vec3 p) // for function f(p)\n{\n    const float eps = 0.0001; // or some other value\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(map(p+h.xyy).x - map(p-h.xyy).x,\n                           map(p+h.yxy).x - map(p-h.yxy).x,\n                           map(p+h.yyx).x - map(p-h.yyx).x ) );\n}\n\nfloat GGXSpec(float Roughness, float NH)\n{\n    float a = Roughness * Roughness;\n    float a2 = a * a;\n    float pi = 3.141592f;\n    float denom = NH * NH * (a2-1.0) + 1.0f;\n    return a2/(pi * denom * denom);\n}\n\nfloat Direct_Light(float Roughness, float RoL) //RoL == Dot(ReflectVector, LightDir)\n{\n    float a = Roughness * Roughness;\n    float a2 = a * a;\n    float rcp_a2 = 1.0/(a2 + 0.001);\n    float c = 0.72134752 * rcp_a2 + 0.39674113;\n    return (rcp_a2 * exp2(c * RoL - c)) * 0.157;\n}\n\nfloat BRDF_Unreal( float Roughness, float RoL )\n{\n\tfloat a = Roughness * Roughness;\n\tfloat a2 = a * a;\n\tfloat rcp_a2 = 1.0/a2;\n\t// 0.5 / ln(2), 0.275 / ln(2)\n\tfloat c = 0.72134752 * rcp_a2 + 0.39674113;\n\treturn rcp_a2 * exp2( c * RoL - c );\n}\nvec3 hueShift( vec3 color, float hueAdjust ){\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI      = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ      = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR     = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG     = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB     = vec3 (1.0, -1.107, 1.704);\n\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I       = dot (color, kRGBToI);\n    float   Q       = dot (color, kRGBToQ);\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    hue += hueAdjust;\n\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n\n    return vec3( dot (yIQ, kYIQToR), dot (yIQ, kYIQToG), dot (yIQ, kYIQToB) );\n\n}\n\nvec4 trace2(vec3 o, vec3 r)\n{\n    float t = 0.0;\n    float stepSize = 0.5;\n    #define DMAX 3.\n    for (int i = 0; i < 25; ++i)\n    {\n        vec3 p = o + r * t;\n        vec2 d = map(p);\n        if(d.x > DMAX)\n            break;\n        if(d.x < 0.05)\n        {\n          //Tubes are unlit\n          if(d.y < 1.0)\n          {\n              vec3 lineCol = hueShift(vec3(0.2, 1.0, 0.52), iTime * 2.0 + p.y * 3.0);\n              return vec4(lineCol, t);\n          }\n          // Hit surface, calc shading:   \n          vec3 n = calcNormal(p);\n          vec3 refl = reflect(-r, n);\n            \n          // For spinning light source\n          float the = iTime * 0.5;\n    \t  float ct = cos(the);\n          float st = sin(the);\n          mat2 rotmat = mat2(ct, -st, st, ct);\n            \n          vec3 lightDir = normalize(vec3(-0.5, -1.0, 0.5));\n          lightDir.xz *= rotmat;\n            \n          // Vectors\n          float RoL = dot(refl, lightDir);\n          vec3 halfNL = normalize(r + lightDir);\n          float NH = dot(n, halfNL);\n            \n          // Debug, lerp between two material value sets\n          float matSwap = sin(p.y * 1.0 + iTime) * 0.5 + 0.5;//clamp(sin(iTime * .5) * 1.5, 0.0, 1.0);\n          matSwap = smoothstep(matSwap - 0.1, matSwap + 0.1, 0.5);\n          float metalness = matSwap;\n          vec3 baseCol = vec3(0.05, 0.35, 0.4);\n          vec3 baseColAlt = vec3(0.05, 0.05, 0.05);\n          float roughness = mix(0.85, 0.15, metalness);\n          float specroughness = mix(0.55, 0.15, metalness);\n          baseCol = mix(baseCol,baseColAlt, metalness);\n          vec3 specular = mix(vec3(0.04), baseCol, metalness);\n            \n          \n            \n          // IBL TO BE REPLACED BY MARCHED REFLECTIONS\n          vec3 radiance = textureLod(iChannel0, -refl, roughness * 10.0).xyz;\n            \n          float diffuseLight = Direct_Light(roughness, RoL);\n          float specLight = GGXSpec(specroughness, NH) * (1.0-roughness);\n          \n          vec4 result = vec4(baseCol, 1.0);\n          \n          // Diffuse\n          result.xyz = mix(result.xyz * diffuseLight, vec3(0.005), metalness);\n          // Spec\n          result.xyz += mix(vec3(specLight), baseCol * specLight, metalness);\n          // Environment\n          result.xyz += radiance * specular;\n            \n          // Store depth in alpha channel\n          result.w = t;\n          return result;\n        }\n        t += d.x * stepSize;\n    }\n    return vec4(0.01, 0.01, 0.01, t);\n}\n\nvec4 traceTest(vec3 o, vec3 d)\n{\n\tfloat omega = 0.15;\n    float t_min = 0.0;\n    float t_max = 20.0;\n\tfloat t = t_min;\n\tfloat candidate_error = 1000000.0;\n\tfloat candidate_t = t_min;\n\tfloat previousRadius = 0.0;\n\tfloat stepLength = 0.0;\n\tfloat functionSign = map(o).x < 0.0 ? -1.0 : +1.0;\n    float pixelRadius = 0.05;\n    bool forceHit = false;\n    \n\tfor (int i = 0; i < 40; ++i) \n    {\n\t\tfloat signedRadius = functionSign * map(d*t + o).x;\n\t\tfloat radius = abs(signedRadius);\n\t\tbool sorFail = omega > 1.0 && (radius + previousRadius) < stepLength;\n    \t    \n\t\tif (sorFail) \n    \t{\n\t\t\tstepLength -= omega * stepLength;\n\t\t\tomega = 1.0;\n\t\t} \n    \telse \n    \t{\n\t\t\tstepLength = signedRadius * omega;\n\t\t}\n\t\tpreviousRadius = radius;\n\t\tfloat error = radius / t;\n\t\tif (!sorFail && error < candidate_error) \n        {\n\t\t\tcandidate_t = t;\n\t\t\tcandidate_error = error;\n\t\t}\n        \n\t\tif (!sorFail && error < pixelRadius || t > t_max)\n\t\t\tbreak;\n\t\tt += stepLength;\n\t}\n    \n\tif ((t > t_max || candidate_error > pixelRadius) && !forceHit)\n        return vec4(10000.0, 10000.0, 10000.0, t);\n\treturn vec4(candidate_t);\n}\n\nvec3 shade(vec3 p)\n{\n    return vec3(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    float bounds = iResolution.x / iResolution.y;\n    uv *=2.5;\n    if (uv.x < -bounds || uv.x > bounds || uv.y < -bounds || uv.y > bounds) \n    {\n    \tfragColor = vec4(0.0);\n        return;\n    }\n    // Setup\n    vec3 r = normalize(vec3(uv, 2.0));\n    float camAnim = clamp(sin(iTime * 0.75), 0.0, 0.2);\n    float the = camAnim * -2.399;//iTime * 0.25;\n    float ct = cos(the);\n    float st = sin(the);\n    mat2 rotmat = mat2(ct, -st, st, ct);\n    vec3 o = vec3(0.0, 0.0, -1.5);\n    \n    o.z -= camAnim;\n    o.yx *= rotmat;\n    r.yx *= rotmat;\n    //Space manipulation\n    //o.xz *= rotmat;\n    //r.xz *= rotmat;\n    //o.yz *= rotmat;\n    //r.yz *= rotmat;\n    \n    // Trace\n    //float t = trace(o, r);\n    //vec4 traceResult = traceTest(o,r) - 0.75;//trace2(o,r);\n    vec4 traceResult = trace2(o,r);//.wwww;\n    //float depth = 1.0 / (1.0 + traceResult.w * traceResult.w * 0.1);\n    //depth = pow(depth, 8.0) * 2.0;\n    fragColor.xyzw = traceResult.xyzw;\n    //fragColor.w = (traceResult.w - 0.8) * .2;//depth * 1.0;\n    //fragColor.w = min(0.75, fragColor.w);\n    return;\n    //float fog = 1.0 / (1.0 + t * t * 0.1);\n    \n    //vec3 fc = vec3(fog * 2.0);\n    \n    //vec3 tint = vec3(0.9,0.5,0.2);\n\t//fragColor = vec4(fc * tint, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}