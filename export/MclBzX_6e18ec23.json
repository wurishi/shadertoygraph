{"ver":"0.1","info":{"id":"MclBzX","date":"1724140652","viewed":61,"name":"Walk on circles Sampling","username":"alpers_shadertoy","description":"Alternates between two non-water-tight polygons. Shades the pixels from blue to yellow colormap if the points are inside. The process is designed as a Monte Carlo process.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["2d","montecarlo","pointcontainment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 col=texture(iChannel0, fragCoord.xy / iResolution.xy).xyz;\n  \n     \n  \n\tfragColor = vec4(tanh(2.0*col), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float PI = 3.14159265359;\nconst float DELTA = 1e-6;\n\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }\n\nvec3 plasma(float t) {\n    t = clamp(t, 0.0, 1.0);\n\n    const vec3 c[10] = vec3[10](\n        vec3(0.050383, 0.029803, 0.527975),\n        vec3(0.274191, 0.012109, 0.622722),\n        vec3(0.447714, 0.002080, 0.660240),\n        vec3(0.610667, 0.090204, 0.619951),\n        vec3(0.740143, 0.213864, 0.524216),\n        vec3(0.846788, 0.342551, 0.420579),\n        vec3(0.928329, 0.472975, 0.326067),\n        vec3(0.983041, 0.624131, 0.227937),\n        vec3(0.991209, 0.790537, 0.149377),\n        vec3(0.940015, 0.975158, 0.131326)\n    );\n\n    // Scale t to the range [0, 9]\n    float scaledT = t * 9.0;\n    \n    // Find the indices of the two colors to interpolate between\n    int idx = int(floor(scaledT));\n    float frac = fract(scaledT);\n    \n    // Interpolate between the two colors\n    return mix(c[idx], c[idx + 1], frac);\n}\n\n\nvec2 sampleUniformCircle(vec2 uv) {\n    // sample a point on a unit circle\n    float theta = 2.0 * PI * rand(vec3(uv.xy, iTime));\n    return vec2(cos(theta), sin(theta));\n}\n\n\nvec2 rayIntersectsSegment(vec2 o, vec2 d, vec2 a, vec2 b) {\n    vec2 ao = o - a;// v1\n    vec2 ab = b - a;// v2 and d is v3\n    float denom = dot(ab, d);\n    if (abs(denom) < 1e-6) return vec2(-1.0);\n    float t = (ab.x * ao.y - ab.y * ao.x) / denom;// v2 X v1\n    float u = dot(ao, d) / denom;// v1 . v3\n    if(t >= 0.0 && u >= 0.0 && u <= 1.0) return vec2(t,u);\n    else return vec2(-1.0);\n}\n\nconst int NUM_VERT_A = 8;\nconst int NUM_VERT_B = 10;\nbool renderingFirst = true;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Define the vertices of the non-convex polygon\n    vec2 verticesA[NUM_VERT_A];\n    verticesA[0] = vec2(0.3, 0.24);\n    verticesA[1] = vec2(0.1, 0.1);\n    verticesA[2] = vec2(0.9, 0.1);\n    verticesA[3] = vec2(0.46, 0.5);\n    verticesA[4] = vec2(0.54, 0.5);\n    verticesA[5] = vec2(0.9, 0.9);\n    verticesA[6] = vec2(0.1, 0.9);\n    verticesA[7] = vec2(0.28, 0.32);\n    \n    vec2 verticesB[NUM_VERT_B];\n    verticesB[0] = vec2(0.15, 0.1);\n    verticesB[1] = vec2(0.95, 0.1);\n    verticesB[2] = vec2(0.75, 0.95);\n    verticesB[3] = vec2(0.56, 0.95);\n    verticesB[4] = vec2(0.80, 0.25);\n    verticesB[5] = vec2(0.52, 0.22);\n    verticesB[6] = vec2(0.5, 0.24);\n    verticesB[7] = vec2(0.3, 0.2);\n    verticesB[8] = vec2(0.53, 0.95);\n    verticesB[9] = vec2(0.35, 0.95);\n   \n    \n    int numVertices;\n    float timeElapsed = mod(iTime, 40.0);\n    // Toggle the variable every 10 seconds\n    renderingFirst = timeElapsed < 20.0;\n    if(renderingFirst)\n    {\n        numVertices = NUM_VERT_A;\n    }\n    else\n    {\n        numVertices = NUM_VERT_B;\n    }\n    \n    vec3 colors[max(NUM_VERT_A,NUM_VERT_B)];\n    //create a color for each vertex\n    for (int i = 0; i < numVertices; i++) {\n        float t = float(i) / float(numVertices-1);\n        colors[i] = plasma(t);\n    }\n    \n    // Normalize fragCoord to the range [0, 1]\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 pos =uv;\n    \n    //sample a random direction\n    vec2 rayDir = sampleUniformCircle(uv);\n    float curRayT=1e20;\n    float minRayT=1e20;\n    \n    \n    vec3 col = vec3(0.0,0.0,0.0);\n    bool contains = false;\n    vec2 hit;\n    \n    for (int i = 0; i < numVertices; i++) {\n        if((!renderingFirst && (i==5)) \n            || (renderingFirst && (i==3 || i == 7)) )\n            continue;\n        vec2 v0 = renderingFirst ? verticesA[i] : verticesB[i];\n        vec2 v1 = renderingFirst ? verticesA[(i+1)%numVertices] : verticesB[(i+1)%numVertices];\n        \n        hit = rayIntersectsSegment(pos, rayDir, v1, v0);\n        \n        if (hit.x > 0.0 && hit.x < minRayT) {\n            minRayT = hit.x;\n            if(dot(v1-v0, rayDir) > 0.0)\n            {\n                col = mix(colors[i], colors[(i+1)%numVertices], hit.y);\n                contains = true;\n            }\n            else\n                contains = false;\n        }\n    }\n    \n    if(contains)\n    {\n        while (hit.x > DELTA)\n        {\n            //sample a random direction\n            vec2 rayDir = sampleUniformCircle(pos);\n            //update the point position\n            pos += hit.x * rayDir;\n            for (int i = 0; i < numVertices; i++) {\n                if((!renderingFirst && (i==5)) \n                    || (renderingFirst && (i==3 || i == 7)) )\n                    continue;\n                vec2 v0 = renderingFirst ? verticesA[i] : verticesB[i];\n                vec2 v1 = renderingFirst ? verticesA[(i+1)%numVertices] : verticesB[(i+1)%numVertices];\n        \n\n                hit = rayIntersectsSegment(pos, rayDir, v1, v0);\n\n                if (hit.x < minRayT)\n                {\n                    minRayT = hit.x;\n                    if(dot(v1-v0, rayDir) > 0.0)\n                        col = mix(colors[i], colors[(i+1)%numVertices], hit.y);\n                }\n            }\n        }\n    }\n    else\n        col = vec3(0.0);\n    \n        \n    vec4 prev=texture(iChannel0, uv);\n    prev.w*=0.985;\n    \n    vec4 finalColor = vec4(prev.xyz*prev.w, prev.w) + vec4(col,0.8);\n    fragColor = vec4(finalColor.xyz/finalColor.w, finalColor.w);\n}","name":"Buffer A","description":"","type":"buffer"}]}