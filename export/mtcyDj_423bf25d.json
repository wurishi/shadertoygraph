{"ver":"0.1","info":{"id":"mtcyDj","date":"1712146416","viewed":120,"name":"Quadratic outline SDF","username":"Envy24","description":"Slightly rewrited code from this shader: https://www.shadertoy.com/view/dls3Wr\nOther sources: \nhttps://www.shadertoy.com/view/ltXSDB\nhttps://www.shadertoy.com/view/wdBXRW","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["sdf","bezier","distance","linear","equation","segment","parametric","metric","euclid","l2"],"hasliked":0,"parentid":"7sGyWd","parentname":"Quadratic Bezier SDF With L2"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCENE_SCALE               ( 3.0 )\n#define AA_UNIT                   ( (SCENE_SCALE*4.0) / iResolution.y  )\n#define SMAA(d)                   ( smoothstep(AA_UNIT, 0., d) )\n#define INITIALLY_FAR               9e30\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\n/* Source: https://www.shadertoy.com/view/ltXSDB */\n// Test if point p crosses line (a, b), returns sign of result\nfloat testCross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n// Determine which side we're on (using barycentric parameterization)\nfloat signBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{ \n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0, \n        step(testCross(A, B, p) * testCross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * testCross(A, C, B);\n}\n/**/\n\n/* Solution from https://www.desmos.com/calculator/ccomgdgvis */\n#define P(t) (P0*(1.-t)*(1.-t)+2.*P1*t*(1.-t)+P2*t*t)\nfloat quadraticBezierSegmentSDF_L2(\n    vec2 NDC,\n    vec2 P0,\n    vec2 P1,\n    vec2 P2)\n{\n    vec2 C = P2 - 2.*P1 + P0;\n    vec2 D = 2.*(P1 - P0);\n    vec2 E = P0 - NDC;\n\n    float coef[4] = float[4](\n        2. * dot(C, C),\n        3. * dot(C, D),\n        2. * dot(C, E) + dot(D, D),\n        dot(D, E)\n    );\n    \n    vec2 T[3];\n    float minSqDist = INITIALLY_FAR;\n    int num = solve(T, coef);\n    //int num = solveCubicVieta(T, coef);\n    \n    for (int i = 0; i < num; ++i)\n    {\n        float t = clamp(T[i].x, 0.0, 1.0);\n        vec2 diff = P(t) - NDC;\n        \n        minSqDist = min(minSqDist, dot(diff, diff));\n    }\n      \n    return sqrt(minSqDist);\n}\n\n/* https://www.shadertoy.com/view/ddfGz2 */\nvec3 colorize_field(float dist, vec3 color)\n{    \n    float F = 30., freq = F*dist, aa = 1./F, C = 0.7, amp = 0.2, width = F*0.01, //0.3\n          waves_sdf = C + amp*smoothstep(8./iResolution.y, 0., (width+cos(freq)) * aa),\n          exp_raise = 1. - exp(-4.*abs(dist));\n        \n    color = 1.0 - sign(dist) * color; // Change color if dist is negative. \n    color *= exp_raise;               // Attenuate color around edges.     \n    color *= waves_sdf;               // Add waves.\n    \n    return mix(color, vec3(1), smoothstep(8./iResolution.y, 0., abs(dist)) );\n}\n\nconst int num_of_curves = 4;\nconst int path_length = 3 * num_of_curves;\nvec2 path[path_length] = vec2[path_length](\n    vec2(-1,  0), vec2(-4,  1), vec2( 0,  1),\n    vec2( 0,  1), vec2( 1,  4), vec2( 1,  0),\n    vec2( 1,  0), vec2( 4, -1), vec2( 0, -1),\n    vec2( 0, -1), vec2(-1, -4), vec2(-1,  0)\n);\n\n// Source: https://www.shadertoy.com/view/wdBXRW\n//         http://geomalgorithms.com/a03-_inclusion.html\nfloat isLeft(vec2 P0, vec2 P1, vec2 P2)\n{\n       return \n           ( (P1.x - P0.x) * (P2.y - P0.y)\n           - (P2.x - P0.x) * (P1.y - P0.y) );\n}\nfloat winding_sign(in vec2 p, in vec2 a, in vec2 b)\n{\n    if (p.y >= a.y) \n    {\n        if (p.y < b.y)                 // an upward crossing\n            if (isLeft(a, b, p) > 0.)  // P left of  edge\n                return -1.;            // have  a valid up intersect\n    }\n    else\n    {               \n        if (p.y >= b.y)                // a downward crossing\n            if (isLeft(a, b, p) < 0.)  // P right of  edge\n                return -1.;            // have  a valid down intersect\n    }\n    return 1.;\n}\n// Source: https://www.shadertoy.com/view/dtX3WH\nfloat compositeSDF(vec2 p)\n{\n    float d = 1e10;\n    float winding = 1.0;\n    for (int i=0; i < num_of_curves; i++) {\n        vec2 v0 = path[i * 3],\n             v1 = path[i * 3 + 1],\n             v2 = path[i * 3 + 2];\n\n        float sd = quadraticBezierSegmentSDF_L2(p, v0, v1, v2);\n        d = min(d, abs(sd));\n\n        vec2 a = v1 - v2, b = v1 - v0;\n                \n        if (signBezier(v0, v1, v2, p) != sign(a.x * b.y - a.y * b.x)) {\n            winding *= winding_sign(p, v0, v1);\n            winding *= winding_sign(p, v1, v2);\n        } else {\n            winding *= winding_sign(p, v0, v2);\n        }\n    }\n    \n    return d * winding;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0), false);\n    \n    float offs = sinOSC(-0.5, 0.5, iTime * 0.5);\n    path[1] = rotateAroundZ(path[1], iTime * 0.1) + vec2(2.*offs, -offs);\n    path[4] = rotateAroundZ(path[4], iTime * 0.1) + vec2(-6.*offs, 0.0);\n    path[7] = rotateAroundZ(path[7], iTime * 0.1) + vec2(-offs, offs);\n    path[10] = rotateAroundZ(path[10], iTime * 0.1) + vec2(-offs*3., offs);\n    \n    float min_d = compositeSDF(NDC);\n\n    vec3 color = colorize_field(min_d, vec3(0.1, 0.4, 0.7));\n\n    O = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nvec2 rotateAroundZ(vec2 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    return vec2(\n        p.x * c - p.y * s,\n        p.y * c + p.x * s);\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float r)\n{\n    return length(C - NDC)-r;\n}\n\n/*\n    Return value:\n        0 - two complex roots;\n        1 - one real root, but root[0] == root[1];\n        2 - two real roots;\n*/\nint solveQuadratic(\n    inout vec2[2] roots,\n    in float[3] coefs)\n{\n    float discriminant = coefs[1] * coefs[1] - 4.0 * coefs[0] * coefs[2];\n\n    if (discriminant < 0.0)\n    {\n        float INVa = 1.0 / (2. * coefs[0]);\n        float SQRT = sqrt(-discriminant);\n\n        roots[0].x = -coefs[1] * INVa;\n        roots[0].y = SQRT * INVa;\n        roots[1].x = -coefs[1] * INVa;\n        roots[1].y = -SQRT * INVa;\n\n        return 0;\n    }\n\n    if (discriminant == 0.0)\n    {\n        float Re = -coefs[1] / (2. * coefs[0]);\n\n        roots[0].x = Re;\n        roots[0].y = 0.0;\n        roots[1].x = Re;\n        roots[1].y = 0.0;\n\n        return 1;\n    }\n\n    float INVa = 1.0 / (2. * coefs[0]);\n    float SQRT = sqrt(discriminant);\n\n    roots[0].x = (SQRT - coefs[1]) * INVa;\n    roots[0].y = 0.0;\n    roots[1].x = (-coefs[1] - SQRT) * INVa;\n    roots[1].y = 0.0;\n\n    return 2;\n}\n\n/*\n    Return value:\n        1 - one real, two complex roots;\n        2 - three real roots, but root[1] == root[2];\n        3 - three real roots.\n*/\nint solveCubicVieta(\n    inout vec2[3] roots,\n    in float[4] coef)\n{\n    const float oneThird = 0.33333333333333331;\n    const float TAU = 6.2831853071795862;\n\n    float a = coef[1] / coef[0];\n    float b = coef[2] / coef[0];\n    float c = coef[3] / coef[0];\n\n    float Q = (a * a - 3.0 * b) / 9.0;\n    float R = (2.0 * a * a * a - 9.0 * a * b + 27.0 * c) / 54.0;\n\n    float S = Q * Q * Q - R * R;\n\n    if (S > 0.0)\n    {\n        float phi = oneThird * acos(R / sqrt(Q * Q * Q));\n        float Re = -2.0 * sqrt(Q);\n\n        roots[0].x = Re * cos(phi) - a * oneThird;\n        roots[0].y = 0.0;\n        roots[1].x = Re * cos(phi + TAU * oneThird) - a * oneThird;\n        roots[1].y = 0.0;\n        roots[2].x = Re * cos(phi - TAU * oneThird) - a * oneThird;\n        roots[2].y = 0.0;\n\n        return 3;\n    }\n\n    if (S < 0.0 && Q > 0.0)\n    {\n        float phi = oneThird * acosh(abs(R) / sqrt(Q * Q * Q));\n        float signR = R < 0.0 ? -1.0 : 1.0;\n\n        float sqrtQ = sqrt(Q);\n        float Re = signR * sqrtQ * cosh(phi);\n        float Im = sqrtQ * sinh(phi);\n        float sqrt3 = 1.7320508075688772;\n\n        roots[0].x = -2.0 * Re - a * oneThird;\n        roots[0].y = 0.0;\n        roots[1].x = Re - a * oneThird;\n        roots[1].y = sqrt3 * Im;\n        roots[2].x = Re - a * oneThird;\n        roots[2].y = -sqrt3 * Im;\n\n        return 1;\n    }\n\n    if (S < 0.0 && Q < 0.0)\n    {\n        float phi = oneThird * asinh(abs(R) / sqrt(abs(Q * Q * Q)));\n        float signR = R < 0.0 ? -1.0 : 1.0;\n\n        float sqrtQ = sqrt(abs(Q));\n        float Re = signR * sqrtQ * sinh(phi);\n        float Im = sqrtQ * cosh(phi);\n        float sqrt3 = 1.7320508075688772;\n\n        roots[0].x = -2.0 * Re - a * oneThird;\n        roots[0].y = 0.0;\n        roots[1].x = Re - a * oneThird;\n        roots[1].y = sqrt3 * Im;\n        roots[2].x = Re - a * oneThird;\n        roots[2].y = -sqrt3 * Im;\n\n        return 1;\n    }\n    \n    if (Q == 0.0)\n    {\n        float Re = -pow(c - a * a * a / 27.0, 1./3.) - a / 3.0;\n        float Im = sqrt(abs(a - 3.0 * Re) * (a + Re) - 4.0 * b) * 0.5;\n\n        roots[0].x = Re;\n        roots[0].y = 0.0;\n        roots[1].x = -(a + Re) * 0.5;\n        roots[1].y = Im;\n        roots[2].x = -(a + Re) * 0.5;\n        roots[2].y = Im;\n\n        return 1;\n    }\n\n    float signR = R < 0.0 ? -1.0 : 1.0;\n    float Re = signR * sqrt(Q);\n\n    roots[0].x = -2.0 * Re - a * oneThird;\n    roots[0].y = 0.0;\n    roots[1].x = Re - a * oneThird;\n    roots[1].y = 0.0;\n    roots[2] = roots[1];\n\n    return 2;\n}\n\n/*\n    Returns number of finded real roots.\n*/\nint solve(\n    inout vec2[3] roots,\n    in float[4] coef)\n{\n    // Quadratic equation?\n    if (coef[0] == 0.0)\n    {\n        // Linear equation?\n        if (coef[1] == 0.0)\n        {\n            // Constant?\n            if (coef[2] == 0.0) { return 0; }\n            \n            // Solve linear.\n            roots[0].x = -coef[3]/coef[2];\n            roots[0].y = 0.0;\n\n            return 1;\n        }\n        \n        vec2 r[2];\n        float c[3] = float[3](\n            coef[1],\n            coef[2],\n            coef[3]\n        );\n        \n        int num = solveQuadratic(r, c);\n        roots[0] = r[0];\n        roots[1] = r[1];\n        \n        return num;\n    }\n    \n    return solveCubicVieta(roots, coef);\n}","name":"Common","description":"","type":"common"}]}