{"ver":"0.1","info":{"id":"csKcDm","date":"1700977544","viewed":58,"name":"watercolor mandelbrot","username":"HalbFettKaese","description":"Inspired by iq's One Sample Blur: https://www.shadertoy.com/view/MsdGD2\n\nHold Space to switch to random blur\nHold R to reset blur","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["mandelbrot","blur","painting","watercolor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159265359\n\nvec3[] colors = vec3[](\n    vec3(66, 30, 15)/255.,\n    vec3(25, 7, 26)/255.,\n    vec3(9, 1, 47)/255.,\n    vec3(4, 4, 73)/255.,\n    vec3(0, 7, 100)/255.,\n    vec3(12, 44, 138)/255.,\n    vec3(24, 82, 177)/255.,\n    vec3(57, 125, 209)/255.,\n    vec3(134, 181, 229)/255.,\n    vec3(211, 236, 248)/255.,\n    vec3(241, 233, 191)/255.,\n    vec3(248, 201, 95)/255.,\n    vec3(255, 170, 0)/255.,\n    vec3(204, 128, 0)/255.,\n    vec3(153, 87, 0)/255.,\n    vec3(106, 52, 3)/255.\n);\nvec3 getColor(float f) {\n    f *= iFrame==0 ? 3. : iTime;\n    int i = int(floor(f));\n    int n = colors.length();\n    vec3 c1 = colors[i % n];\n    vec3 c2 = colors[(i+1) % n];\n    return mix(c1, c2, fract(f));\n}\n\n#define ITERATIONS 50.\n// bailout\n#define B 100.\nvec3 mandelbrot(vec2 uv) {\n    uv = uv * 2. - vec2(1.5, 1.);\n    uv *= 1.2;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 c = uv;\n    vec2 p = vec2(0.);\n    float i;\n    for (i = 0.; i < ITERATIONS; i++) {\n        p = vec2(p.x * p.x - p.y * p.y, 2.*p.x*p.y) + c;\n        if (length(p) > B)\n            break;\n    }\n    if (i==ITERATIONS) {\n        return vec3(0);\n    } else {\n        // magic formula - thanks wikipedia\n        float f = i-log2(log(length(p)) / log(B));\n        return getColor(f);\n    }\n}\nfloat hash31(vec3 p) { \n    float n = sin(dot(p, vec3(13., 193., 677.)));    \n    return fract(69872.*n); \n}\n\nvec2 disc(vec2 uv, float t) {\n    float c = hash31(vec3(uv, t));\n    float r = 1./sqrt(2.);\n    float theta = (floor(c * 4.)+0.5) * PI*0.5;\n    \n    return r * vec2(cos(theta), sin(theta));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    bool space = texelFetch(iChannel1, ivec2(0x20, 0), 0).x == 1.;\n    bool r = texelFetch(iChannel1, ivec2(0x52, 0), 0).x == 1.;\n    \n    if (iFrame == 0 || r) {\n        vec3 col = mandelbrot(uv);\n        fragColor = vec4(col, 1.0);\n    } else {\n        vec2 uv2 = clamp(uv + disc(uv, space ? iTime : 0.0) * dFdx(uv.x), 0., 1.);\n        vec3 col = texture(iChannel0, uv2).rgb;\n        fragColor = vec4(col, 1.);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}