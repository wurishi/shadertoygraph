{"ver":"0.1","info":{"id":"XfySWd","date":"1716765710","viewed":38,"name":"Raymarching studies - 01","username":"zschzen","description":"a simple studie","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","studies"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS    50\n#define SURFACE_DIST 0.001\n#define MAX_DIST     100.0\n\n// Signed distance function for the scene\nfloat\nsceneSDF( vec3 p )\n{\n    p.z += iTime * .4; // Forward movement\n    \n    // Space repetition\n    p.xy = fract(p.xy) - .5;     // spacing: 1\n    p.z =  mod(p.z, .25) - .125; // spacing: .25\n\n    return sdSphere( p, .1 );\n}\n\n// Ray marching algorithm to find intersection with the scene\nfloat\nRayMarch( vec3 ro, vec3 rd, vec2 m )\n{\n    float t = 0.;  // Initialize ray march distance\n    for ( int i = 0; i < MAX_STEPS; ++i )\n    {\n        vec3  p = ro + t * rd;    // Current point along the ray\n\n        p.xy *= rot2D( t * .15 * m.x );     // rotate ray around z-axis\n\n        p.y += sin( t * ( m.y + 1. ) * .5 ) * .35;  // wiggle ray\n\n        float d = sceneSDF( p );  // Distance to the scene\n\n        if ( d < SURFACE_DIST ) break;\n\n        t += d;                   // Advance the ray\n\n        // Break if the ray hits the object or goes beyond max distance\n        if ( t > MAX_DIST ) break;\n    }\n    return t;\n}\n\nvoid\nmainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized coordinates\n    vec2 uv = ( fragCoord * 2. - iResolution.xy ) / iResolution.y;\n    vec2 m  = ( iMouse.xy * 2. - iResolution.xy ) / iResolution.y;\n    \n    // Initialize ray origin and direction\n    vec3 ro = vec3( 0.0, 0.0, -3. );\n    vec3 rd = normalize( vec3( uv, 1.0 ) );\n\n    // Apply camera rotations based on mouse position\n    {\n        mat2 r = rot2D(-m.y);\n        // Vertical rotation\n        ro.yz *= r; rd.yz *= r;\n        r = rot2D(-m.x);\n        // Horizontal rotation\n        ro.xz *= r; rd.xz *= r;\n    }\n\n    // Perform ray marching\n    float t  = RayMarch( ro, rd, m );\n    vec3 col = palette(t*.05);\n    \n    // Set the fragment color\n    fragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI  3.1415925359\n#define TAU 6.2831852\n\n//------------------------------------------------------------------\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length( p ) - s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b + r;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nvec3 palette( float t )\n{\n    // Dracula Theme Colors\n    vec3 draculaBackground = vec3(40, 42, 54) / 255.0;\n    vec3 draculaCurrentLine = vec3(68, 71, 90) / 255.0;\n    vec3 draculaForeground = vec3(248, 248, 242) / 255.0;\n    vec3 draculaComment = vec3(98, 114, 164) / 255.0;\n    vec3 draculaCyan = vec3(139, 233, 253) / 255.0;\n    vec3 draculaGreen = vec3(80, 250, 123) / 255.0;\n    vec3 draculaOrange = vec3(255, 184, 108) / 255.0;\n    vec3 draculaPink = vec3(255, 121, 198) / 255.0;\n    vec3 draculaPurple = vec3(189, 147, 249) / 255.0;\n    vec3 draculaRed = vec3(255, 85, 85) / 255.0;\n    vec3 draculaYellow = vec3(241, 250, 140) / 255.0;\n\n    // Adjust the base color and phase shifts to match Dracula colors\n    vec3 baseColor = mix(draculaRed, draculaBackground, t);\n    vec3 phaseShift = vec3( .3, .416, .557 ); // Adjust phase shifts as needed\n\n    return baseColor + .5 * cos( 6.28318 * ( t + phaseShift ) );\n}\n\n//------------------------------------------------------------------\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nmat2 rot2D( float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    \n    return mat2( c, -s, s, c );\n}\n\n// Rodrigues rotation formula\nvec3 rot3D( vec3 p, vec3 axis, float angle )\n{\n    return mix( dot( axis, p ) * axis, p, cos( angle ) )\n            + cross( axis, p ) * sin( angle );\n}","name":"Common","description":"","type":"common"}]}