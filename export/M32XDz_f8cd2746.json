{"ver":"0.1","info":{"id":"M32XDz","date":"1710495240","viewed":79,"name":"Circular Weave Distance + Parity","username":"nr4","description":"This is a 2D distance function to a circular weave with correct parity at the intersections.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","distance","geometry","circular","weave","sacred","parity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Distance to circular weave with correct parity\n * Copyright (C) 2024 Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nconst vec3 c = vec3(1,0,-1);\nconst float pi = 3.14159;\n\n// Created by David Hoskins and licensed under MIT.\n// See https://www.shadertoy.com/view/4djSRW.\n// vec2->float hash function\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Created by David Hoskins and licensed under MIT.\n// See https://www.shadertoy.com/view/4djSRW.\n// vec2->vec2 hash function\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat scene(vec2 uv) {\n    float s = .1;\n    const int N = 3;\n    float R = 1. + .2 * float(N);\n    float p = atan(uv.y, uv.x);\n    float ps = 2. * pi / float(N);\n    float dp = mod(p + ps / 4., ps);\n    float pj = p - dp;\n    float d = 1.e3;\n    float dj[N];\n    \n    for(int j = 0; j < N; ++j) {\n        vec2 _pj = .4*R * vec2(cos(pj + float(j) * ps), sin(pj + float(j) * ps));\n        vec2 uvj = uv - _pj;\n\n        dj[j] = abs(length(uvj) - .6*R) -  s;\n    }\n    \n    float sig = 1.;\n    for(int j = 0; j < N + 1; ++j) {\n        for(int k = 1; k < N-1 ; ++k) {\n            d = min(d, max(dj[j % N], -dj[(j+N-k) % N]));\n            sig *= -1.;\n        }       \n    }\n\n    d = abs(d);\n    return d;\n}\n\nvec3 cmap_CielabCielab(float t) {\n    return vec3(0.06,0.12,0.12)\n        +t*(vec3(1.04,-3.88,-5.84)\n        +t*(vec3(22.06,45.29,69.99)\n        +t*(vec3(-106.79,-170.24,-293.90)\n        +t*(vec3(214.67,321.12,582.27)\n        +t*(vec3(-203.05,-294.29,-536.21)\n        +t*(vec3(72.12,101.99,183.68)\n    ))))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float scale = 3.6;\n    vec2 uv = scale * (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    uv += .15 * c.yx;\n    vec2 mouse = scale * (iMouse.xy - .5 * iResolution.xy) / iResolution.y;\n    float px = 1.0 / iResolution.y;\n    float d = scene(uv)/scale;\n    vec3 col = (d > 0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65, 0.85, 1.0);\n\tcol *= 1.0 - exp2(-12.0 * abs(d));\n\tcol *= 0.7 + 0.2 * cos(150.0 * d);\n    col = cmap_CielabCielab((length(col) / sqrt(3.)));\n\tcol = mix( col, vec3(1.0), 1.0 - smoothstep(0.0, 3.0 * px, (d)));\n    \n    d = scene(mouse);\n    float l = length(uv - mouse);\n    col = mix(col, vec3(1.0, 1.0, 1.0), 1.0 - smoothstep(0.0, 2.0 * px, (abs(l - abs(d))-.001 * scale) / scale));\n    col = mix(col, vec3(1.0, 1.0, 1.0), 1.0 - smoothstep(0.0, 2.0 * px, (l - px*3.0)));\n\tfragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}