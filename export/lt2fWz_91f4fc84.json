{"ver":"0.1","info":{"id":"lt2fWz","date":"1515442786","viewed":313,"name":"Funky Spheres","username":"jchabin1","description":"Raymarching Spheres!\nYou can use your mouse to look around a little.\n\n","likes":6,"published":1,"flags":64,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsBXzw","filepath":"https://soundcloud.com/musicaholic/unity-beat-the-fat-rat","previewfilepath":"https://soundcloud.com/musicaholic/unity-beat-the-fat-rat","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.1415926535897932384626433832795;\nconst float EPSILON = 0.00001;\n\nfloat sphere(vec3 p, vec3 pos, float size){\n    return length(p - pos) - size;\n}\n\nfloat box(vec3 p, vec3 pos, vec3 size){\n    return length(max(abs(p - pos) - size, 0.0));\n}\n\nvec3 rotateX(vec3 p, float r){\n    return vec3(p.x, p.y * cos(r) - p.z * sin(r), p.y * sin(r) + p.z * cos(r));\n}\n\nvec3 rotateY(vec3 p, float r){\n    return vec3(p.x * cos(r) - p.z * sin(r), p.y, p.x * sin(r) + p.z * cos(r));\n}\n\nvec3 rotateZ(vec3 p, float r){\n    return vec3(p.x * cos(r) - p.y * sin(r), p.x * sin(r) + p.y * cos(r), p.z);\n}\n\nfloat smin(float a, float b, float k){\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat sceneDist(vec3 pos){\n    float squares = 10.0;\n    vec3 p = vec3(pos.x, pos.y, pos.z);\n    float d = distance(vec2(p.x, p.z), vec2(0.0));\n    p = rotateZ(p, 0.03 * d * cos(iTime * 0.03));\n    p = rotateY(p, 0.1 * d * sin(iTime * 0.07));\n    p = rotateX(p, 0.05 * d);\n    //p = rotateZ(p, 0.05 * d * texelFetch(iChannel1, ivec2(0, 0), 0).x);\n    vec4 sound = texelFetch(iChannel1, ivec2(mod(floor(p.z / 3.0) * 150.0 + 200.0, 512.0), 0), 0);\n    p.y -= pow(sound.x, 5.0) * 1.0;\n    float dist = sphere(vec3(mod(p.x + iTime * 5.0 + pow(sound.x, 5.0) * 10.0, 3.0), p.y, mod(p.z, 3.0)), vec3(1.5, 0.0, 1.5), 0.7 + sound.x);\n    p = vec3(pos.x, pos.y, pos.z);\n    return dist;\n}\n\nvec3 getNormal(vec3 p){\n    float EPSILON = EPSILON * 100.0;\n    return normalize(vec3(\n        sceneDist(vec3(p.x + EPSILON, p.y, p.z)) - sceneDist(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneDist(vec3(p.x, p.y + EPSILON, p.z)) - sceneDist(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneDist(vec3(p.x, p.y, p.z  + EPSILON)) - sceneDist(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 mouse;\n    if(iMouse.z > 0.0)\n    \tmouse = vec2(iMouse.x / iResolution.x * 2.0 - 1.0, iMouse.y / iResolution.y * 2.0 - 1.0);\n    else\n        mouse = vec2(0.0);\n\tvec3 camera = vec3(0.0, 6.0, 0.0);\n    float fov = PI / 2.0;\n    vec2 cameraAngle = vec2(iTime * 0.5 + mouse.x * fov, 0.0 + mouse.y * fov);\n    \n    vec4 sound = texelFetch(iChannel1, ivec2(0, 0), 0);\n    vec4 sound1 = texelFetch(iChannel1, ivec2(512 / 4, 0), 0);\n    vec4 sound2 = texelFetch(iChannel1, ivec2(512 / 2, 0), 0);\n    vec4 sound3 = texelFetch(iChannel1, ivec2(512 - 512 / 4, 0), 0);\n    \n    vec4 color = vec4(sound1.x, sound2.x, sound3.x, 1.0);\n    color *= sound.x * sin(uv.x + iTime) * cos(uv.y + iTime) + sound3.x;\n    \n    vec2 pos = vec2((2.0 * (fragCoord.x / iResolution.x) - 1.0), (2.0 * (fragCoord.y / iResolution.y) - 1.0) / iResolution.x * iResolution.y);\n    \n    float t = 0.0;\n    vec3 direction = normalize(vec3(sin(pos.x * fov + cameraAngle.x), sin(pos.y * fov + cameraAngle.y), cos(pos.x * fov + cameraAngle.x) * cos(pos.y * fov + cameraAngle.y)));\n    vec3 p = camera;\n    vec3 light = vec3(-1.0, 1.0, -1.0);\n    for(t = 0.0; t < 100.0; t++){\n        float dist = sceneDist(p);\n        if(dist < EPSILON * distance(camera, p)){\n            if(dist < 0.0)\n                p = p + dist * direction;\n            vec3 normal = getNormal(p);\n            color += pow(dot(normalize(light), normal), 2.0) * 0.5;\n            //color = clamp(color, 0.0, 1.0);\n            color += max(pow(dot(reflect(normalize(light), normal), normalize(p - camera)), 10.0) * (1.0 + sound3.x), 0.0);\n            //color += pow(dot(reflect(normalize(vec3(1.0)), normal), normalize(p - camera)), 10.0) * sound.x;\n            //color = clamp(color, 0.0, 1.0);\n           // if(p.y + 10.0 >= EPSILON * 10.0)\n            \tcolor += texture(iChannel0, reflect(normalize(p - camera), normal)) * 0.3;\n            color *= clamp(20.0 / distance(p, camera), 0.0, 1.0);\n            //color = vec4(normal, 1.0);\n            break;\n        }\n        dist = clamp(dist * 0.6, 0.01, 1.5);\n        p = p + dist * direction;\n    }\n    color.a = 1.0;\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}