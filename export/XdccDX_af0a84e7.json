{"ver":"0.1","info":{"id":"XdccDX","date":"1521019866","viewed":269,"name":"Penrose Triangle II","username":"Ultraviolet","description":"A  Penrose triangle using the deformation technique.\nClick to move cam.\nNot very fast, sorry (you can deactivate AA for speedup if needed).","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["triangle","illusion","penrose"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Penrose Triangle\" by Ultraviolet. https://shadertoy.com/view/Xd3yDX\n// 2018-03-06 11:53:59\n\n\n#define PI\t\t\t\t3.1415926535\n#define ABSORBANCE\t\t1.0\n#define LIGHT_DIR\t\tnormalize(vec3(1., 2., 1.5))\n\n#define CAM_PARAM\t\tsmoothstep( 0., 1., max(mod(iTime*.2, 1.)-.8, 0.)*5.)\n#define CAM_POS \t\tvec3(2./sqrt(2.)*1.5*cos(CAM_PARAM*2.*PI+PI*.25), 1.5, 2./sqrt(2.)*1.5*sin(CAM_PARAM*2.*PI+PI*.25))\n\n#define WIDTH\t.1\n#define SIZE\t1.25\n\n#define AA\t\t2.\n\n\nvec2 sdBeam(vec3 p, vec3 p0, vec3 p3, out vec3 n)\n{\n    vec3 disp = vec3(1.);\n    vec3 diff = (p3-p0);\n    disp *= max(max(diff.x, diff.y), diff.z);\n    \n    vec3 p2 = p0+disp;\n    vec3 p1 = p3-disp;\n    \n    float fact = .5*length(diff);\n    p2 = mix(p3, p2, fact);\n    p1 = mix(p0, p1, fact);\n    \n    p0 += normalize(p1-p0)*.1;\n    p3 += normalize(p2-p3)*.1;\n    \n    \n    Bezier4 b = Bezier4(p0, p1, p2, p3);\n    \n    float t = closest(b, p);\n    \n    vec3 proj = getPt(b, t);\n    \n    vec3 Z  = normalize(getDir(b, t));\n    \n    vec3 X  = getCur(b, t);\n        \n    vec3 Y  = normalize(cross(Z, X));\n    X = cross(Y, Z);\n    X = normalize(X+Y);\n    Y  = normalize(cross(Z, X));\n      \n    vec3 d = abs(vec3(dot(proj-p, X), dot(proj-p, Y), dot(proj-p, Z)));\n    \n    float dd;\n    float mat;\n    \n    if(d.x>d.y && d.x>d.z)\n    {\n        dd = d.x;\n        n = X;\n        mat = 0.;\n    }\n    else if(d.y>d.z)\n    {\n        dd = d.y;\n        n = Y;\n        mat = 1.;\n    }\n    else\n    {\n        dd = d.z;\n        n = Z;\n        mat = 2.;\n    }\n    \n    if(dot(vec3(1.), n)<0.)\n        n*=-1.;\n    \n    return vec2(dd-WIDTH, mat);\n    \n}\n\n\nvec2 sdCube(vec3 p, vec3 pc, out vec3 n)\n{\n    vec3 d = abs(p-pc);\n    \n    float dd;\n    float mat;\n    if(d.x>d.y && d.x>d.z)\n    {\n        dd = d.x;\n        n = vec3(1.,0.,0.);\n        mat = 0.;\n    }\n    else if(d.y>d.z)\n    {\n        dd = d.y;\n        n = vec3(0.,1.,0.);\n        mat = 1.;\n    }\n    else\n    {\n        dd = d.z;\n        n = vec3(0.,0.,1.);\n        mat = 2.;\n    }\n    \n    return vec2(dd-WIDTH, mat);\n}\n\n\n\nvec2 map(vec3 p, out vec3 n )\n{\n    vec3 p0 = vec3(.8, -.2, -.2) + vec3(.4);\n    vec3 p1 = vec3(.4);\n    vec3 p2 = vec3(1., 1., 0.);\n    \n    vec3 c = (p0+p1+p2)/3.;\n    p0 -= c;\n    p1 -= c;\n    p2 -= c;\n    \n    p0 *= SIZE;\n    p1 *= SIZE;\n    p2 *= SIZE;\n    \n    vec2 res = vec2( 1000., 1.0 );\n    vec3 n0, n1, n2;\n    float mat;\n    \n    vec2 d0, d1, d2;\n    d0 = sdBeam(p, p0, p1, n0);\n    d1 = sdBeam(p, p1, p2, n1);\n    d2 = sdBeam(p, p2, p0, n2);\n    \n    \n    vec3 d = vec3(d0.x, d1.x, d2.x);\n    \n    if(res.x > d.x)\n    {\n        res.x = d.x;\n        n = n0;\n        mat = mod(d0.y+1., 3.);\n    }\n    if(res.x > d.y)\n    {\n        res.x = d.y;\n        n = n1;\n        mat = d1.y;\n    }\n    if(res.x > d.z)\n    {\n        res.x = d.z;\n        n = n2;\n        //mat = d2.y;\n        mat = mod(d2.y+2., 3.);\n    }\n    \n    d0 = sdCube(p, p0, n0);\n    d1 = sdCube(p, p1, n1);\n    d2 = sdCube(p, p2, n2);\n    d = vec3(d0.x, d1.x, d2.x);\n    \n    if(res.x > d.x)\n    {\n        res.x = d.x;\n        n = n0;\n        mat = d0.y;\n    }\n    if(res.x > d.y)\n    {\n        res.x = d.y;\n        n = n1;\n        mat = d1.y;\n    }\n    if(res.x > d.z)\n    {\n        res.x = d.z;\n        n = n2;\n        mat = d2.y;\n    }\n    \n    res.y = mat;\n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, out vec3 n )\n{\n    float tmin = 1.;\n    float tmax = 7.0;\n   \n    float t = tmin;\n    float tbk;\n    float m = -1.0;\n    for( int i=0; i<64; i++ )\n    {\n\t    float precis = 0.0005*t;\n\t    vec2 res = map( ro+rd*t, n );\n        if( res.x<precis || t>tmax ) break;\n        tbk = t;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    \n    return vec2( t, m );\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 col = .6+.4*vec3(pow(max(0., dot(rd, LIGHT_DIR)), 2.));\n    \n    vec3 nor;\n    vec2 res = castRay(ro,rd, nor);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        if(res.y < .5)\n            col = vec3(1., 0., 0.);\n        else if(res.y < 1.5)\n            col = vec3(0., 1., 0.);\n        else\n            col = vec3(0., 0., 1.);\n        \n        col = (.2+.8*max(0., dot(nor, LIGHT_DIR))) * (.2+.8*col);\n    }\n    \n    \n    return col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/ iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n        \n    // mouse camera control\n    float phi = (iMouse.x-0.5)/iResolution.x * PI * 2.0;\n    float psi = -((iMouse.y-0.5)/iResolution.y-0.5) * PI;\n    \n    if(iMouse.x<1.0 && iMouse.y < 1.0)\n    {\n        phi = iTime * PI * 2.0*0.1;\n        psi = cos(iTime*PI*2.0*0.1)*PI*0.25;\n    }\n    \n    // ray computation\n    vec3 ro = vec3(0.,1.,0.) + 2.*vec3(cos(mo.x*PI*2.)*cos((1.-mo.y*2.)*.5*PI), sin((1.-mo.y*2.)*.5*PI), sin(mo.x*PI*2.)*cos((1.-mo.y*2.)*.5*PI));\n    if(iMouse.z < 0.5)\n        ro = CAM_POS;\n    \n    vec3 ta = vec3(0.);\n    mat3 m = setCamera(ro, ta, 0.0);\n    vec3 rd = m*normalize(vec3(p, 2.));\n    \n    ro = 2.*ro + m[0]*p.x + m[1]*p.y;\n    rd = m[2];\n    \n    // scene rendering (using oversampling)\n    vec3 col;\n    \n    \n    for(float ii=0.; ii<AA; ii+=1.)\n    for(float jj=0.; jj<AA; jj+=1.)\n    {\n    \tcol += render( ro, rd+(m[0]*ii+m[1]*jj)/AA/iResolution.y/2.);\n    }\n    col /= AA*AA;\n    \n    // gamma correction\n    col = sqrt(col);\n    \n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nstruct Segment\n{\n    vec3 A;\n    vec3 B;\n};\n\nfloat proj(Segment s, vec3 p)\n{\n\tvec3 pa = p-s.A, ba = s.B-s.A;\n\treturn clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n}\n\nfloat dist(Segment s, vec3 p)\n{\n\tvec3 pa = p-s.A, ba = s.B-s.A;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n\nfloat dist(vec3 s, vec3 p)\n{\n\treturn length(p-s);\n}\n\n\n\n\n\nstruct Bezier4\n{\n    vec3 A;\n    vec3 B;\n    vec3 C;\n    vec3 D;\n};\n    \nvec3 getPt(Bezier4 c, float t)\n{\n    return mix(mix(mix(c.A, c.B, t), mix(c.B, c.C, t), t), mix(mix(c.B, c.C, t), mix(c.C, c.D, t), t), t);\n}\n    \nvec3 getDir(Bezier4 B, float t)\n{\n    //return normalize(getPt(B, t+0.01)-getPt(B, t-0.01));\n    return (getPt(B, t+0.01)-getPt(B, t-0.01));\n}\n    \nvec3 getCur(Bezier4 B, float t)\n{\n    //return normalize(getPt(B, t+0.01)-2.*getPt(B, t)+getPt(B, t-0.01));\n    return (getPt(B, t+0.01)-2.*getPt(B, t)+getPt(B, t-0.01));\n}\n\nfloat closest(Bezier4 BB, vec3 p)\n{\n    vec3 A = BB.A, B = BB.D;\n    \n    float ppt;\n    float At = .0;\n    float Bt = 1.;\n    \n    vec3 pp;\n    \n    float dis = dist(pp, p);\n    \n    for(int i=0; i<5; ++i)\n    {\n        //ppt = (At+Bt)*.5;\n        ppt = mix(At, Bt,.25+.5*proj(Segment(A, B), p));\n        pp = getPt(BB, ppt);\n        \n        if(dist(Segment(A, pp), p) < dist(Segment(pp, B), p))\n        {\n            Bt = ppt;\n        \tB = getPt(BB, Bt);\n        }\n        else\n        {\n            At = ppt;\n        \tA = getPt(BB, At);\n        }\n            \n    }\n    \n    //return .5*(At+Bt);\n    \n\t//vec3 pa = p-A, ba = B-A;\n\t//float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    //return mix(At, Bt, h);\n    return mix(At, Bt,proj(Segment(A, B), p));\n}\n","name":"Common","description":"","type":"common"}]}