{"ver":"0.1","info":{"id":"ld3fWn","date":"1660428215","viewed":331,"name":"Nohohon Zoku","username":"Ping2_0","description":"I love this little guy !\n\nYou can play with right & left arrow keys to change sunlight direction.","likes":39,"published":1,"flags":16,"usePreview":0,"tags":["3d","raymarching","nohohon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * 2022-08-13\n *\n * Tomy's Nohohon Zoku \n * \"Sitting on my fridge since 2002 and still smiling\"\n * \n * ---------------------------------------------------\n *\n * Most of the functions come from https://iquilezles.org/articles/\n * I also used elements from other shaders, including :\n * - Happy Jumping                  https://www.shadertoy.com/view/3lsSzf\n * - Raymarching - Primitives       https://www.shadertoy.com/view/Xds3zN\n * - Snail                          https://www.shadertoy.com/view/ld3Gz2\n *\n */\n\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else \n#define AA 2\n#endif\n\n#define ZERO (min(iFrame,0))\n\n\n\nstruct Result \n{\n    int id;\n    float dist;\n    vec3 spos;\n};\n\n\nstruct Anim\n{\n    float ti;\n    float respi;\n    float headAngle;\n    float headMoveAmpl;\n    float feetAngle;\n    \n    float respiLittle;\n    \n} anim;\n\nvoid animate() \n{\n    const float headSpeed =  3.2;\n    float headMove = sin(iTime * headSpeed);\n    anim.ti = (sin(iTime*0.1 - 1.57)+1.)*0.5;\n    anim.respi = sin(iTime)*0.018;\n    anim.headAngle =  headMove * mix(0.06,0.3,smoothstep(0.05,0.2,anim.ti));\n    anim.headMoveAmpl = headMove * mix(0.001,0.01,smoothstep(0.05,0.3,anim.ti));\n    anim.feetAngle = -0.45 - (sin(iTime*4.1) +1.) * 0.15; \n    \n    anim.respiLittle = (0.5 + sin(iTime * 1.1)) * 0.08;         \n}\n\n\n/* https://iquilezles.org/articles/smin/ */\nfloat smin(in float a, in float b, in float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n/* https://iquilezles.org/articles/smin/ */\nfloat smax(in float a, in float b, in float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\nvoid opu( inout Result a, in Result b )\n{\n    if ( b.dist < a.dist )\n        a = b;\n}\n\nvoid opu( inout Result a, in Result b, float k )\n{\n    float d  = smin(a.dist, b.dist, k);\n    if ( b.dist < a.dist )\n        a = b;\n    a.dist = d;\n}\n\n/* https://iquilezles.org/articles/distfunctions/ */\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n#if 1\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;    \n#else \n    vec3 m = p * r.yyy/r;\n    return length(m) - r.y;\n#endif\n}\n\n/* https://iquilezles.org/articles/distfunctions/ */\nfloat sdBox( in vec3 p, in vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n/* from Happy Jumping - iq */\nfloat sdStick(in vec3 p, in vec3 a, in vec3 b, in float r1, in float r2)\n{\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - mix(r1,r2,h*h*(3.0-2.0*h));\n    // return vec2( length( pa - ba*h ) - mix(r1,r2,h*h*(3.0-2.0*h)), h );\n}\n\n/* https://iquilezles.org/articles/distfunctions/ */\nfloat sdHorizontalCapsule( in vec3 p, in float h, in float r )\n{\n    p.x -= clamp( p.x, 0.0, h );\n    return length( p ) - r;\n}\n\n/* https://iquilezles.org/articles/distfunctions/ */\nfloat opExtrusion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\n/* https://iquilezles.org/articles/distfunctions2d/ */\nfloat sdMoon(in vec2 p, in float d, in float ra, in float rb )\n{\n    p.y = abs(p.y);\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(p.x*b-p.y*a) > d*d*max(b-p.y,0.0) )\n          return length(p-vec2(a,b));\n    return max( (length(p          )-ra),\n               -(length(p-vec2(d,0))-rb));\n}\n\n/* https://iquilezles.org/articles/distfunctions/ */\nvec3 opCheapBend( in vec3 p , in float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nvec2 gro(in vec2 p, in vec2 v)\n{\n    vec2 uu = normalize(v);\n    vec2 vv = vec2(-uu.y, uu.x);\n    return vec2( dot(uu,p.xy), dot(vv,p.xy) );\n}\n\n/* https://iquilezles.org/articles/distfunctions/ */\nfloat sdCutSphere(in vec3 p, in float r, in float h )\n{\n  // sampling independent computations (only depend on shape)\n  float w = sqrt(r*r-h*h);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.xy), -p.z );\n  float s = max( (h-r)*q.x*q.x+w*w*(h+r-2.0*q.y), h*q.x-w*q.y );\n  return (s<0.0) ? length(q)-r :\n         (q.x<w) ? h - q.y     :\n                   length(q-vec2(w,h));\n}\n\nfloat sdFoot(in vec3 p, in vec3 r, in float rd) \n{\n#if 1\n    /* Diff : Sphere - Box */\n    vec3 m = p * r.zzz/r;\n    float d = length(m) - r.z;\n    vec3 q = abs(p - vec3(0., 0., r.z )) - r * vec3(1.1,1.1,1.);\n    return smax(d, -(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0)), rd);  \n#else\n    r*=0.77;\n    return sdCutSphere(p* r.zzz/r, r.z, .01) - rd*0.5;\n#endif\n}\n\n/*\nmat3 rotateX(const in float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(const in float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(const in float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n*/\n\n\n\n\n\n// Modelling\n// ---------\n\n\nResult littleGuy(in vec3 p)\n{\n    Result res;\n    res.id = 13;\n\n    // Orientation - same as : p = rotateX(-2.5)*rotateZ(1.2)*rotateY(-1.8)*p;\n    p = mat3(-0.122758, 0.429655, 0.89461, 0.841471, -0.43286, 0.323356, 0.526172, 0.792483, -0.308405)*p;\n    res.spos = p;\n\n    // Head\n    float d = length(p) -0.13;\n    \n    // Body\n    vec3 r = p - vec3(0.01, -0.22, -0.03);  \n    r.xy = gro(r.xy, vec2( 1.0, 0.25));\n    float d2 = length(r * vec3(1.12, 0.556, 1. - anim.respiLittle)) - 0.103; \n    d2 = smin(d2, length(p - vec3(-0.06, -0.23,-0.015)) - 0.1, 0.04);\n    d = smin(d, d2, 0.0075);    \n    \n    // Feet\n#if 0\n    r = p - vec3(-0.03, -0.32, 0.08);\n    r =  rotateX(0.1) * rotateY(0.1) * rotateZ(-.276) *  r;\n    float sright = (-sign(r.x) + 1.)*0.5;\n    r.xy = vec2(abs(r.x)-0.14, -r.y);  \n    r = rotateZ(.26)*rotateX(-.55)*rotateY(.4)*r;\n    r =  rotateX(sright * .2) * rotateZ(sright * .8) * r;\n    r += sright * vec3(0.02, 0.02, 0.02);\n    d = smin(d, sdFoot(r, vec3(0.065, 0.09, 0.06), 0.03), 0.01);\n#else\n    r = p - vec3(0.12, -0.38,0.05);\n    r.xy = gro(r.xy, vec2(.5, -1.));\n    r.xz = gro(r.xz, vec2(1., -.8));\n     // r.yz = gro(r.yz, vec2(1., .40));\n    d = smin(d, sdFoot(r, vec3(0.065, 0.09, 0.06), 0.03), 0.02);    \n\n    r = p - vec3(-.16, -0.24,0.09);\n    r.xy = gro(r.xy, vec2(1., .7));\n    r.zy = gro(r.zy, vec2(1., .3));\n    r.xz = gro(r.xz, vec2(1., .3));\n    d = smin(d, sdFoot(r, vec3(0.065, 0.09, 0.06), 0.03), 0.02);         \n#endif\n     \n    // arms\n    d2 = sdStick(p, vec3(-0.11, -0.135, -0.05), vec3(-0.21, -0.12, 0.1), 0.045, 0.025);\n    d2 = min(d2, sdStick(opCheapBend(p, 1.), vec3(0.06, -0.13, -0.07), vec3(0.17, -0.25, -0.0875), 0.045, 0.025));\n    d = smin(d, d2, 0.001);\n    \n    res.dist = d;\n    return res;\n}\n\nResult bigGuy(in vec3 pos)\n{   \n    Result res;\n    res.id = 10;\n\n    vec3 q = pos;\n    const vec2 uu = normalize(vec2( 1.0, .10 ));\n    const vec2 vv = vec2(-uu.y, uu.x);\n    q.yz = vec2( dot(uu,q.yz), dot(vv,q.yz) );\n \n    // body\n    res.spos = q;\n    float d = sdEllipsoid(q, vec3(0.33, 0.26 + anim.respi, 0.37));\n    float d2 = sdEllipsoid( q-vec3(0.0 + anim.headMoveAmpl,0.15,-0.11), vec3(0.25, 0.25, 0.25));\n    d = smin(d, d2, 0.05);\n    res.dist = d;\n    \n    // arms\n    Result resArms;\n    resArms.id = 11;\n    \n    vec3 r = opCheapBend(q, .85);\n    r.x=abs(r.x);\n    resArms.spos = r;\n    resArms.dist = sdStick(r, vec3(0.23 + anim.headMoveAmpl*sign(q.x), 0.15, -0.19), vec3(0.35, -0.28, -0.35), 0.07, 0.07);\n    opu(res, resArms, 0.01);\n    \n\n    // head\n    Result resHead;\n    resHead.id = 12;\n    \n    r = q -vec3(0.0, 0.575, -0.12);\n    r.yx = gro(r.yx + vec2(0.2,0.) , vec2(1., - anim.headAngle)) - vec2(0.2,0.);\n    resHead.spos = r;\n    \n    d2 = length(r) - 0.4;\n    float f = -0.0007*(smoothstep(1.,.993,1.-abs(r.z))); // :)\n    d2+=f;\n    resHead.dist = d2;\n    opu(res, resHead, 0.02);\n\n\n    // feet\n    Result resFeet;\n    resFeet.id = 11;\n    r = vec3(abs(q.x), q.yz) - vec3(0.09,-.09,0.45);\n    r.yz  = gro (r.yz, vec2(1., 0.8));\n    r.xz  = gro (r.xz, vec2(1.,-.18));\n    r.xy  = gro (r.xy + vec2(0., 0.24), vec2(1., anim.feetAngle)) -  vec2(0., 0.24);\n    resFeet.spos = r;\n    resFeet.dist = sdFoot(r, vec3(0.16, 0.23, 0.15), 0.05);\n    opu(res, resFeet);\n\n    return res;\n}\n\n/* \n * Inspired by the mapLeaf function in the Snail shader. \n * (Snail by iq - https://www.shadertoy.com/view/ld3Gz2)\n */\nResult leaf( in vec3 p, in float time)\n{\n    p.y += .2*exp2(-abs(2.*p.x) );\n    float b = p.z  +(sin(time*4.)*sin(time+1.5+p.x*7.)*.3-.43)*(p.z+.2);\n    p.y += .5 * b*b;\n\n    const float r=.25;\n    float d = sdEllipsoid( p, vec3(.2,0.4*r,r) );\n    float d2 = p.y-.02;\n    return Result(14, smax( d, -d2, 0.03 ), p);\n}\n\n\nvoid map(in vec3 pos, in bool drawCharacters, in bool drawLeaves, in bool drawStone, out Result result) \n{\n    vec3 p = pos;\n    result.dist = 1e10;    \n \n    // Characters\n    // ----------\n    if(drawCharacters)\n    {\n            p.y -=.15;\n            result =  bigGuy(p);\n\n            p -= vec3( .48, -0.10, 0.14);\n            float bb = length(p  - vec3( -0.08, 0.09, -0.1)) - 0.27;\n            if (bb  < result.dist)\n                opu(result, littleGuy(p));\n    } \n    \n    // Leaves\n    // ------\n    if(drawLeaves) \n    {\n        p = vec3(abs(pos.x), pos.yz);\n#if 0\n#define BBL\n        float bs = sdBox(p - vec3(0.45, -0.165, 0.71), vec3(0.29, 0.125, 0.25));\n        if(bs < result.dist)\n        {\n#endif\n            const float a1 = .5;\n            const float a2 = 1.3;\n            const mat3 mtl1 = mat3(cos(a2), 0, sin(a2), 0, 1, 0, -sin(a2), 0, cos(a2)) * \\\n                              mat3(1, 0, 0, 0, cos(a1), -sin(a1), 0, sin(a1), cos(a1));\n            const mat3 mtl2 = mat3(1, 0, 0, 0, cos(-.2), -sin(-.2), 0, sin(-.2), cos(-.2)) * \\\n                              mat3(cos(-.8), 0, sin(-.8), 0, 1, 0, -sin(-.8), 0, cos(-.8)) ;\n\n            p = mtl1 * (p - vec3(0.5, -0.03, 0.7)); \n            Result rLeaf = leaf(p,iTime + sign(pos.x));\n            opu(rLeaf, leaf(mtl2 * (p-vec3(-0.12,0.07,-0.12)), iTime + 1.2 + sign(pos.x)));\n            opu(result, rLeaf);\n#ifdef BBL        \n        }\n#endif        \n    }\n    \n    // Stone \n    // -----\n    if(drawStone)\n    {    \n        p = pos - vec3( -0.1, -0.3 , 0.15 );\n        const vec2 uu = normalize(vec2( 1.0, 0.10 ));\n        const vec2 vv = vec2(-uu.y, uu.x);\n        p.yz = vec2( dot(uu,p.yz), dot(vv,p.yz) );\n\n        float d = sdMoon(p.xz, -0.95, 0.57 - (p.y-0.1)*0.5, .8)-0.2;\n        d = opExtrusion( p.xzy, d, 0.1 - p.z * 0.1 ) - 0.1 + p.z * p.z * 0.1;\n        d -= 0.02 * (smoothstep(-2., 2., sin(50. * pos.y) - sin(10. * pos.x) + 0.5 * sin(pos.z * 12. + 4.75 )));\n\n        // Bottom\n        vec2 t = max(sin(p.xz * 2.24 + vec2(1.3, 1.65)) * 0.85, 0.);\n        d -= t.x * t.y * 0.45 * smoothstep(0., -0.2, p.y);\n        \n        // need to adjust\n        d*=.56;\n                \n        if(d < result.dist)\n            result = Result(15, d, p);\n      }\n}\n\n\n\n\n\n// Raymarching\n// -----------\n\n\n/* \n * https://iquilezles.org/articles/boxfunctions/\n * see function : vec2 boxIntersection( in vec3 ro, in vec3 rd, in vec3 rad, out vec3 oN )\n */\nvec2 boxIt(in vec3 ro, in vec3 rd, in vec3 rdInv, in vec3 rad ) \n{\n   // vec3 m = 1.0/rd;\n    vec3 n = rdInv*ro;\n    vec3 k = abs(rdInv)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    \n    // oN = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    return vec2( tN, tF );\n}\n\n\nvec4 testMapBb(in vec3 ro, in vec3 rd)\n{   \n    vec3 rdInv = 1./rd;\n    vec2 gbb = boxIt(ro - vec3(0.1, 0.15, 0.1), rd, rdInv, vec3(0.9, 1., 0.9));\n    vec4 r = vec4(gbb.x, 0., 0., 0.);\n    if(gbb.x > 0.)\n        r.yzw = vec3(boxIt(ro - vec3(0.05, 0.5, 0.04), rd, rdInv, vec3(0.57, 0.65, 0.51)).x,      // characters\n                     boxIt(ro - vec3(0., -0.14, 0.75), rd, rdInv, vec3(.75, 0.11, 0.27)).x,       // leaves\n                     boxIt(ro - vec3(0.1, -0.4, 0.1), rd, rdInv, vec3(.9, .42, .9)).x);           // stone\n    return r;\n    /*\n    vec3 rdInv = 1./rd;\n    vec2 gbb = boxIt(ro - vec3(0.1, 0.15, 0.1), rd, rdInv, vec3(0.9, 1., 0.9));\n    return vec4(gbb.x, 1., 1., 1.);\n    */\n}\n\nvec3 testMapShadowBb(in vec3 ro, in vec3 rd)\n{    \n    vec3 rdInv = 1./rd;\n    return vec3(boxIt(ro - vec3(0.05, 0.5, 0.04), rd, rdInv, vec3(0.57, 0.65, 0.51)).y,      // characters\n                boxIt(ro - vec3(0., -0.14, 0.75), rd, rdInv, vec3(.75, 0.11, 0.27)).y,       // leaves\n                boxIt(ro - vec3(0.1, -0.4, 0.1), rd, rdInv, vec3(.9, .42, .9)).y);           // stone\n}\n\nvoid raycast(in vec3 ro, in vec3 rd, out Result result )\n{\n    const float tmax = 6.5;\n    result.id = -1;\n    \n    vec4 bb = testMapBb(ro, rd);\n    \n    if(bb.x > 0.)\n    {\n        animate();\n        bvec3 hitest = greaterThan(bb.yzw, vec3(0.));\n        // bvec3 hitest = bvec3(true); // No improvement ?\n        Result r;\n        //float t = min(bb.y, min(bb.z, bb.w));\n        float t = bb.x;\n\n#if 0\n        result.dist = bb.x; \n        result.id = 1;\n      \n        if(bb.y >= result.dist)\n        {\n                result.dist = bb.y;\n                result.id = 10;\n        }\n\n        if(bb.z >= result.dist )\n        {\n                result.dist = bb.z;\n                result.id = 14;\n        }\n       \n         if(bb.w >= result.dist)\n        {\n                result.dist = bb.w;\n                result.id = 15;\n        }\n#endif        \n        \n        for( int i=0; i<256 && t<tmax; i++ )\n        {\n            map( ro+rd*t, hitest.x, hitest.y, hitest.z , r);\n            if( abs(r.dist)<(0.0005*t) )\n            { \n                result = r;\n                result.dist = t;\n                break;\n            }\n            t += r.dist;\n        }\n    }    \n} \n\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n \n    Result result;\n    const float tmin = 0.02;\n    float tmax = .7;\n    \n    #if 1\n    float tp = (.5-ro.y)/rd.y; // raytrace bounding plane\n    if( tp>0.0 ) tmax = min( tmax, tp );\n\t#endif    \n\n    \n    bvec3 bb = greaterThan(testMapShadowBb(ro, rd), vec3(0));\n\n    float t =tmin; \n    for( int i=ZERO; i<24; i++ )\n    {\n      #if 0\n        map( ro+rd*t, bb.x, bb.y, /*bb.z*/ false, result);\n        float s = clamp(8.0*result.dist/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( result.dist, 0.02, 0.2 );\n        if( res<0.005 || t>tmax ) break;\n      #else\n        map( ro+rd*t, bb.x, bb.y, /*bb.z*/ false , result);\n        res = min( res, mix(1.0,16.0*result.dist/t, 0.5) );\n        t += clamp( result.dist, .02, 0.4 );\n        if( res<.005 || t>tmax ) break;\n      #endif\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 pos, in int mat)\n{\n    bvec3 b = bvec3(mat < 14, mat == 14, mat ==15);\n#if 0\n    Result r1, r2, r3, r4;\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    map( pos + e.xyy , b.x, b.y, b.z, r1);\n    map( pos + e.yyx , b.x, b.y, b.z, r2);\n    map( pos + e.yxy , b.x, b.y, b.z, r3);\n    map( pos + e.xxx , b.x, b.y, b.z, r4);\n\n    return normalize( e.xyy*r1.dist + e.yyx*r2.dist + e.yxy*r3.dist + e.xxx*r4.dist)  ;\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    Result result;\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        map(pos+0.0005*e, b.x, b.y, b.z, result);\n        n += e*result.dist;\n    }\n    return normalize(n);\n#endif    \n    \n}\n\nfloat calcAO(const in vec3 pos, const in vec3 nor)\n{\n    bvec3 b = greaterThan(testMapShadowBb(pos, nor), vec3(0));\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    Result result;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        map( pos + h*nor, b.x, b.y, true, result);\n        occ += (h - result.dist)*sca;\n        sca *= 0.95;\n        if( occ>.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n//    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 lighting(in vec3 pos, in vec3 nor, in vec3 rd, in float ks, in vec3 ref, in vec3 col, in float t, in float fspe, in float occ) \n{\n    vec3 lin = vec3(0.0);\n\n    // sun\n    {\n        vec3  lig = normalize( vec3(0.3, 0.35, 0.5) );\n        vec3 kbl = vec3(texelFetch( iChannel1, ivec2(39,2),0).r * -2. + 1., 1., texelFetch( iChannel1, ivec2(37,2),0).r * -2. +1.);\n        lig *= kbl;\n        \n        vec3  hal = normalize( lig-rd );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        dif *= calcSoftshadow( pos, lig);\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),fspe);\n        spe *= dif;\n        spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n                \n        lin += col*2.20*dif*vec3(1.30, 1.0,.70); \n        lin +=     20.00*spe*vec3(1.30,1.00,0.70)*ks; \n    }\n    \n    // sky\n    {\n        float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n        dif *= occ;\n        float spe = smoothstep( -0.2, 0.2, ref.y );\n        spe *= dif;\n        spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n        spe *= calcSoftshadow( pos, ref);\n        lin += col*.60*dif*vec3(0.40,0.60,1.15);\n        lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\n    }\n    \n    \n    // back\n    {\n        float dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        dif *= occ;\n        lin += col*.55*dif*vec3(0.25,0.25,0.25);\n\n    }\n    \n    // sss\n    {\n        float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n        dif *= occ;\n        lin += col*0.25*dif*vec3(1.00,1.00,1.00);\n    }\n    \n\tcol = col * 0.3 + lin;\n    return col;\n}\n\n// https://iquilezles.org/articles/smin\nvec3 smax( vec3 a, vec3 b, float k )\n{\n    vec3 h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n/*\n * Taken from Snail shader (function background) but use triplanar mapping\n * and change color from green (bottom) to blue (top)\n */\nvec3 back( in vec3 d )\n{\n    vec3 n = abs(d);\n    vec3 uvs = d * .34;\n    \n    // fancy blur\n    vec3  col = vec3( 0.0 );\n    for( int i=ZERO; i<50; i++ )\n    {\n        float h = float(i)/50.0;\n        float an = 31.0*6.2831*h;\n        vec2  of = vec2( cos(an), sin(an) ) * h * 0.0075;\n        \n        vec3 tmp =  mat3(texture(iChannel2, uvs.yz + of, 4.).grb,\n                         texture(iChannel2, uvs.xz + of, 4.).grb,\n                         texture(iChannel2, uvs.xy + of, 4.).grb)\n                    * n;\n        col = smax( col, tmp, 0.7 );                \n    }\n    \n    // blue up & green down\n    float al  = (1.+ d.y) *.5;\n    col = mix(col, col.bgg*1.23, smoothstep(.35, 1., al));\n    // perturbations\n    float f = (1.2+sin(iTime*2.5 + (d.x*15.5+sin(d.y+iTime*.5)*5.))*0.1);\n    return pow(col,vec3(3.5,3.0,6.0) * f)*0.12;\n}\n\n/*\n * Triplanar mapping\n * for the stone\n */\nvec3 tpm(in sampler2D sa, in vec3 p, in vec3 n)\n{\n    return  mat3(\n        texture(sa, p.yz).rgb,\n        texture(sa, p.xz).rgb,\n        texture(sa, p.xy).rgb\n        ) * abs(n);\n}\n\n\nvec3 render( in vec3 ro, in vec3 rd)\n{ \n    // Background\n    vec3 col = back( rd );\n  \n    // raycast scene\n    Result result; \n    raycast(ro,rd, result);\n  \n    float t = result.dist;\n\n    if(result.id > 0)\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, result.id);\n        vec3 ref = reflect( rd, nor );\n        float occ =  calcAO( pos, nor ); \n    \n        // material        \n        float ks = 1.;\n        float fspe = 16.;\n       \n\n        if( !(result.id < 10 || result.id > 13))\n        {\n            // Characters\n            // ----------\n            \n            float r = 1.;\n            \n            if(result.id == 10)\n            {\n                // Main character body\n                // -------------------\n                \n                // spots\n                float d = length(result.spos - vec3(-0.1, 0.17 + anim.respi, 0.3)) - 0.088;\n                d = min(d, sdEllipsoid(result.spos - vec3(0.01, 0.18 + anim.respi, 0.18), vec3(0.045, 0.065, 0.07)));\n                d = min(d, length(result.spos - vec3(0.08, 0.15 + anim.respi, 0.3)) - 0.06);\n                \n                r = smoothstep(0.0, 0.01, d);\n            }\n/*\n            else if(result.id == 11)\n            {\n                // Main character Feet & Arms\n                // --------------------------\n\n            }\n*/\n            else if(result.id == 12)\n            {\n                // Main character Head\n                // -------------------\n                \n                // eyes\n                vec3 p = vec3(abs(result.spos.x), result.spos.yz);\n                float d = length(p.xyz - vec3(0.18, 0.14, 0.32)) - 0.026;\n\n                // mouth\n                float mlength = mix(0.005, 0.25, smoothstep(0.05, 0.065, anim.ti));\n                float mthickness = mix(0.025, 0.006, smoothstep(0.05, 0.057, anim.ti));\n                p = opCheapBend(p - vec3(0., 0., 0.4 - p.x * p.x * 1.4), 0.65);\n                d = min(d, sdHorizontalCapsule(p, mlength, mthickness));\n                \n                r = smoothstep(0.0, 0.01, d);\n            }\n            else if(result.id == 13)\n            {\n                // Little character\n                // ----------------\n                \n                // mouth\n                vec3 q = result.spos;\n                q.xz = gro(q.xz, vec2(1., -0.6));\n                vec3 p = opCheapBend(q - vec3(0., 0., 0.127), 3.);\n                float d = sdHorizontalCapsule(p - vec3(-0.07, 0.01, 0.004 - p.x * p.x * 4.), 0.15, 0.0012);\n\n                // eyes    \n                p = vec3(abs(q.x), q.yz) - vec3(0.005, 0.093, 0.112);    \n                // p = rotateY(0.3)*rotateZ(-0.9)*p;\n                p = opCheapBend(mat3(0.593847, 0.783327, 0.183698, -0.748341, 0.62161, -0.231489, -0.29552, 0, 0.955337) * p, 6.);\n                d = min(d, sdHorizontalCapsule(p - vec3(0., 0., 0.01 - p.x * p.x * 1.8), 0.1, 0.0016));\n\n                r = smoothstep(0., 0.007, d);\n            }\n        \n            col = mix(vec3(0.), vec3(0.24, 0.3, 0.3),  r);\n\n            // Specific lighting\n            // -----------------\n            float fresnel = pow(clamp(1. - dot(nor, -rd), 0., 1.), 6.0);\n            const vec3 rimColor = vec3(0.2, 0.5, 1.);\n            col +=  fresnel * rimColor * (0.5 + 0.5 * occ);\n\n            ks = mix(0.2, 0.5, r);\n            fspe = mix(8., 64., r);\n        }\n        else if(result.id == 14)\n        {\n            // Leaves\n            // ------\n            \n            col = vec3(0.01, 0.1, 0.00625);\n            col += 0.042*(1.4*smoothstep(0.85,1.35,2.*sin(22.0*result.spos.x-1.57)+sin(64.0*result.spos.y)+sin(85.0*result.spos.z))-1.);\n            \n            ks = 0.2; \n            fspe = 16.;\n        }\n        else if(result.id == 15)\n        {\n            // Stone\n            // -----\n            \n            vec3 nd = -1. + 2.*tpm(iChannel0, result.spos*3. , nor);\n            col = vec3(.02, 0.036,0.038);\n            float fresnel = pow(clamp(1. - dot(nor, -rd), 0., 1.), 8.0);\n            const vec3 rimColor = vec3(.02, 0.06,.12);\n            col +=  fresnel * rimColor * (0.5 + 0.5 * occ);;\n\n            ks=0.02+nd.x*nd.y*nd.z*nd.z*0.13;\n            fspe = 4.;\n        }\n\n        // lighting\n        col = lighting(pos, nor, rd, ks, ref, col, t, fspe, occ);\n    }\n   \n\treturn col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\n// from Happy Jumping\nvoid gcg(inout vec3 col) \n{\n  // color grading\n  col = col*vec3(1.11,0.89,0.79);\n\n  // compress        \n  //col = 1.35*col/(1.0+col);\n  col = 3.*col/(2.5+col);\n        \n  // gamma\n  col = pow( col, vec3(0.4545) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\n    // camera\t\n    vec3 ta = vec3( 0., 0.25, 0.);\n    vec3  ro = ta + vec3( 4.5*cos(7.0*mo.x + 1.76),  -1.+4.0*mo.y, 4.5*sin( 7.0*mo.x + 1.76)  );\n\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - .5;\n        vec2 p = (2.0*(fragCoord+o /* *8.*sin(iTime) */ )-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n        // focal length\n        float fl = 3.5; //  + mo.x*3.;\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,fl) );\n\n        // render\t\n         vec3 col = render( ro, rd);\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n  gcg(tot);\n  \n  // s-surve    \n  tot = clamp(tot,0.0,1.0);\n  tot = tot*tot*(3. - 2.*tot);\n\n  // vignetting        \n  vec2 q = fragCoord/iResolution.xy;\n  tot *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.25);\n\n  fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}