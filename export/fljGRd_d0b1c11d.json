{"ver":"0.1","info":{"id":"fljGRd","date":"1624518731","viewed":236,"name":"Point to Point","username":"Yusef28","description":"Named after [Point to Point ~ Animals as Leaders] \nYou can change the number of points in the define at the top\nIt's faster with less points","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["wave","line","circle","sine","curve","segment","linesegments"],"hasliked":0,"parentid":"ftS3zV","parentname":"Line Segment Sine Wave"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define numSegments 23.\n#define showSeg\n#define PI 3.141592653589793238462643\n\n#define bgCol   vec3(60, 47, 47)/255.*0.9\n#define lineCol vec3(130., 144., 121.)/255.\n#define circleCol vec3(237., 227., 185.)/255.*0.6\n\nmat2 rot(float a){\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat dotLineDist(vec2 A, vec2 B, vec2 p){\n\n    vec2 pa = p - A;\n    vec2 AB = B - A;\n    \n    //clamp = segment!\n    float t = clamp(dot(pa, AB)/dot(AB,AB), 0., 1.);\n    \n    vec2 normal = pa - t*AB;\n    float dist = length(normal);\n   \n    return dist;\n}\n\nvec3 drawRing(float radius, float thickness, vec2 p, vec2 off, vec3 col){\n    \n    p -= off;\n    \n    float eps = 1./min(iResolution.x,iResolution.y);\n    \n    float circle = 1.-smoothstep(-eps, eps, \n    abs(radius - length(p))-thickness);\n    \n    col = mix(col, circleCol, circle);\n    \n    return col;\n}\n\nvec3 drawLine(vec2 A, vec2 B, vec2 p, vec3 col){\n    \n    float dist = dotLineDist(A,B,p);\n    //dist = 1.0-smoothstep(0.001, 0.002, dist);\n    dist = abs(1.0-smoothstep(0., fwidth(dist), dist - 0.0012));\n    return mix(col, lineCol, dist);\n}\n\nvec3 drawGradedLine(vec2 A, vec2 B, vec2 p, vec3 gradient, vec3 col){\n    \n    float dist = dotLineDist(A,B,p);\n    \n    //dist = 1.0-smoothstep(0.001, 0.002, dist);\n    dist = abs(1.0-smoothstep(0., fwidth(dist), dist - 0.0012));\n    return mix(col, gradient, dist);\n}\n\n/*\n\n//loopless version by oneshade using floor to create cells\n//because every point is fixed on the x axis\n//Just need to make it aligned to start and end of screen\n//for any number of segments.\nvec3 drawSegments(vec2 viewDim, vec2 uv) {\n    \n    float aspect = viewDim.x/viewDim.y;\n    vec3 col = bgCol;\n\n    float dt = aspect / numSegments;\n    uv.x += fract(0.5 * numSegments) * dt;\n    col = drawLine(vec2(0.0, -0.25), vec2(0.0, 0.25), uv, col);\n\n    float cell = floor(uv.x / dt) * dt;\n    vec2 p1 = vec2(cell, sin(2.25 * PI * cell + iTime) * 0.25);\n    vec2 p2 = vec2(cell + dt, sin(2.25 * PI * (cell + dt) + iTime) * 0.25);\n    col = drawLine(p1, p2, uv, col);\n\n    #ifdef showSeg\n    col = drawRing(0.01, 0.003, uv, p1, col);\n    col = drawRing(0.01, 0.003, uv, p2, col);\n    #endif\n\n    return col;\n}\n*/\n//Original version\n\nvec3 drawSegments(vec2 viewDim, vec2 uv, float r){\n\n    float aspect = viewDim.x/viewDim.y;\n    vec3 col = bgCol;\n    float dx;\n\n    float dt;\n    vec2 firstPoint = vec2(r, 0);\n    vec2 lastPoint = vec2(r, 0);\n\n    vec2 tmp;\n    float t = 0.;\n    \n    for(float i = 1.; i <= numSegments; i++){\n        \n        dt = 2.*PI*(i/numSegments)+3.*PI/2.;\n        //t = dt;\n        //dx = (aspect*dt-aspect/2.);\n\n        vec2 newPoint = rot(dt)*firstPoint;\n        \n        col = drawLine(lastPoint, newPoint, uv, col);\n        \n        #ifdef showSeg\n        col = drawRing(0.01, 0.003, uv, newPoint, col);\n        #endif\n        \n        \n        for(float i = 1.; i <= numSegments; i++){\n        \n            dt = 2.*PI*(i/numSegments);//+iTime/16.;\n            tmp = rot(dt)*newPoint;\n            col = drawGradedLine(newPoint, tmp, uv, cos(lineCol+dt*2.+vec3(0,2,4)/4.+iTime*2.)*0.5+0.75, col);\n            }\n        //t += numSegments;\n        lastPoint = newPoint;\n        \n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n\n    vec3 col = drawSegments(iResolution.xy, uv, .6);\n   \n    //col = pow(col, vec3(0.75));\n   \n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    \n    vig = pow(vig, 0.15); // change pow for modifying the extend of the  vignette\n\n\n    fragColor = vec4(col*vig,1.0);\n}","name":"Image","description":"","type":"image"}]}