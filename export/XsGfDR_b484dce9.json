{"ver":"0.1","info":{"id":"XsGfDR","date":"1528206076","viewed":129,"name":"Eksamens_graf_progr","username":"unity115","description":"Autors: Jazeps Reinis Bumbiers, IT3","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["lightpointgrid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// nosakām gaismas punkta lielumu\n\nfloat create(vec3 point) { \n    vec3 a = fract(point) * 2.0 - 1.0;\n\treturn length(a) - 0.025;\n    \n}\n\n// izvietojam gaismas punktus uz ekrāna\nfloat trace(vec3 a, vec3 b) { \n    \n    float c = 0.25;\n    \n    for(int i = 0; i < 100; ++i){\n        vec3 pos = a + b * c;\n        float d = create(pos);\n        c += d * 0.10;\n    }\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = uv * 2.0 - 1.0;\n    \n    uv.x =  uv.x * iResolution.x / iResolution.y;\n    \n    vec3 a = vec3(0.0, iTime, iTime);\n       \n    vec3 b = normalize(vec3(uv, 0.5));\n    \n    // nosakam ekrana rotacijas atrumu\n    \n    float time = iTime * 0.25;\n    \n    // nosakam rotacijas virzienu\n    \n    b.xz *= mat2(cos(time),-sin(time), sin(time), cos(time));\n    \n    float c = trace(a,b);\n    \n    float lights = 1.0 / (1.0 + c * c * 0.1);\n        \n    vec3 grid = vec3(lights);\n    \n    grid.b = 0.25;\n\n    fragColor = vec4(grid, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}