{"ver":"0.1","info":{"id":"Xf33Ds","date":"1712241426","viewed":33,"name":"Voronoi CRT Defrag & Refrag","username":"PG_TG","description":"Description","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["tag"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*-----------------------------\n  VORONOI CRT DEFRAG & REFRAG\n-----------------------------*/\n\n// RANDOM FUNCTION (FLOAT)\nfloat random(float x) {\n    return fract(tan(x) * 1e3);\n}\n\n// RANDOM FUNCTION (VECTOR 2)\nvec2 random(vec2 uv) {\n    return fract(\n        vec2(\n            cos(dot(uv.xy, vec2(12.9898, 78.2337))),\n            sin(dot(uv.yx, vec2(86.2361, 55.5983)))\n        ) * 81839.41256\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Secondary UV for vignette\n    vec2 uv2 = uv;\n    uv2 *= 1.0 - uv2.yx;\n    \n    // Tertiary UV for scanlines\n    vec2 uv3 = uv;\n    uv3 = uv3 * 2. - 1.;\n    uv3.x *= iResolution.x/iResolution.y;\n\n    // Pixelation Filter\n    float pixelation = 4.0;\n    uv = (ceil(fragCoord.xy/pixelation + 0.5) * pixelation)/iResolution.xy;\n\n    // Aspect Ratio Fix\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // Scale\n    uv *= sin(iTime)/2. + 6.;\n\n    // Fract and Integer versions of UV\n    vec2 iuv = floor(uv);\n    vec2 fuv = fract(uv);\n\n    // Voronoi point construction\n    float minDist = 0.6;  // minimum distance\n    vec2 minPoint;        // minimum point\n    \n    for (int i = -1 ; i <= 1; i++) {\n        for (int j = -1 ; j <= 1 ; j++) {\n            vec2 neighbour = vec2(float(i),float(j));\n            vec2 point = vec2(random(iuv + neighbour));\n            point = 0.5 + (sin(iTime)/2. + 0.5) * cos(iTime + 8.6236 * point);\n            vec2 diff = neighbour + point - fuv;\n            float dist = length(diff);\n\n            if( dist < minDist ) {\n                minDist = dist;\n                minPoint = point;\n            }\n        }\n    }\n\n    vec3 color = vec3(0.);\n\n    // Colour by distance\n    color.xy += dot(minPoint,vec2(.25,.75));\n\n    // Edge shading\n    color.x -= abs(sin(3.* minDist))*0.25;\n\n    // Centre dots\n    color.y += 1.0 - step(0.15 - sin(iTime)/10., minDist);\n    color.xz += 0.75 - step(0.15 - sin(iTime)/10., minDist);\n    \n    // Background\n    vec4 background = vec4(color, 1.);\n    \n    // Vignette Layer\n    float vig = uv2.x * uv2.y * 10.;\n    vig = pow(vig, 0.666);\n    vec4 foreground = vec4(vig);\n    \n    // Saturation + Contrast increase\n    foreground.xyz -= abs(sin(0.5)) * 0.333;\n    \n    // Scanlines\n    float count = iResolution.y * 32.;\n    vec2 sl = vec2(sin(uv3.y * count), cos(uv3.y * count));\n\tvec3 scanlines = vec3(sl.x, sl.y, sl.x);\n    foreground = mix(foreground, vec4(scanlines, 1.0), foreground.a);\n    \n    // Output to screen\n    fragColor = mix(foreground, background, foreground.a);\n}","name":"Image","description":"","type":"image"}]}