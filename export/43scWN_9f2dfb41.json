{"ver":"0.1","info":{"id":"43scWN","date":"1726197449","viewed":57,"name":"Fork Raymarch b Soliform 835","username":"Soliform","description":"It is raymarched beams. Inspired by https://akari.lusion.co/#home\nForked","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","pathtracing"],"hasliked":0,"parentid":"cttcDN","parentname":"Raymarch beams"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Light {\n    vec3 color;\n\t\n    float constant;\n    float linear;\n    float quadratic;\n};\n\nstruct Line {\n    vec2 point1;\n    vec2 point2;\n    float stroke;\n    \n    Light light;\n};\n\nstruct Sphere {\n    vec2 position;\n    float radius;\n    \n    Light light;\n};\n\nstruct Shape {\n    int shapeType;\n    bool emissive;\n    \n    Light light;\n    \n    Line line;\n    Sphere sphere;\n};\n\nconst float distanceX = 100.0;\n\n// If your PC is struggling with performance, try lowering step count to 64 or 32.\n// Also try setting the max trace distance higher, to something like .2 or .4\nconst int STEP_COUNT = 256;\nconst float MIN_HIT_DIST = 0.01;\nconst float MAX_TRACE_DIST = 0.1; \nconst float SHADOW_SOFTNESS = 0.35; // the lower the sharper. 0.3 is ideal\nconst vec3 BACKGROUND_COLOR = vec3(0.01,0.02,0.05);\n\n\nconst int SHAPE_COUNT = 9;\n\nShape shapes[SHAPE_COUNT];\n\nvec2 convertPixelToPos(vec2 pixel) {\n    return ((pixel / iResolution.xy) - 0.5 ) * vec2(distanceX, distanceX * (iResolution.y / iResolution.x));\n}\n\nvec3 getAttenuation(Shape shape, vec2 lightDirection, float dist) {\n    float multiplier = 1.0;\n    \n    /*if (shape.shapeType == 0) {\n        vec2 normal = normalize(shape.line.point1 - shape.line.point2);\n        normal = vec2(-normal.y, normal.x);\n        multiplier = abs(dot(lightDirection, normal));\n        multiplier = 1.0 - 0.4 * exp(-0.8 * multiplier) * (1.0 - multiplier);\n    }*/\n    \n    return shape.light.color * multiplier * (1.0 / (shape.light.constant + shape.light.linear * dist + \n    \t\t    shape.light.quadratic * (dist * dist)));\n}\n\nvec2 getClosestPointOnLine(Line line, vec2 p) {\n    vec2 ba = line.point2-line.point1;\n    vec2 pa = p-line.point1;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n      \n    return line.point1 + h*ba;\n}\n\nfloat segmentSDF(vec2 p, Shape shape) {\n    vec2 ba = shape.line.point2 - shape.line.point1;\n    vec2 pa = p - shape.line.point1;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    \n    return length(pa-h*ba) - shape.line.stroke;\n}\n\nfloat sphereSDF(vec2 p, Shape shape) {\n    return distance(p, shape.sphere.position) - shape.sphere.radius;\n}\n\nfloat getDistance(vec2 p, Shape shape) {\n    switch(shape.shapeType) {\n        case 0:\n            return segmentSDF(p, shape);\n        case 1:\n            return sphereSDF(p, shape);\n    }\n}\n\nvec2 segmentCP(vec2 p, Shape shape) {\n    vec2 ba = shape.line.point2 - shape.line.point1;\n    vec2 pa = p - shape.line.point1;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n      \n    return shape.line.point1 + h*ba;\n}\n\nvec2 sphereCP(vec2 p, Shape shape) {\n    vec2 dir = normalize(shape.sphere.position - p);\n    return shape.sphere.position + dir * shape.sphere.radius;\n}\n\nvec2 getClosestPoint(vec2 p, Shape shape) {\n    switch(shape.shapeType) {\n        case 0:\n            return segmentCP(p, shape);\n        case 1:\n            return sphereCP(p, shape);\n    }\n}\n\nfloat getNearestDist(vec2 position, int ignoreIndex) {\n    float smallestDist = 10000.0;\n    \n    for (int i = 0; i < SHAPE_COUNT; i++) {\n        if (i == ignoreIndex) continue;\n    \n        smallestDist = min(smallestDist, getDistance(position, shapes[i]));\n    }\n    \n    return smallestDist;\n}\n\n\nvec3 getShapeEmission(int shapeIndex, vec2 position) {\n    Shape shape = shapes[shapeIndex];\n    \n    float distToLight = getDistance(position, shape);\n    \n    // Totally legit anti aliasing\n    if (distToLight <= 0.0) {\n        if (abs(distToLight) <= 0.05) {\n            float t = (distToLight + 0.05) / 0.1;\n            return mix(vec3(1.0,1.0,1.0), getAttenuation(shape, vec2(5.0,5.0), 0.0), 1.0-(1.0-t)*(1.0-t));\n        } else {\n            return vec3(1.0,1.0,1.0);\n        }\n    }\n    \n    vec2 lightPosition = getClosestPoint(position, shape);\n    vec2 rayDir = (lightPosition - position) / distToLight;\n    \n    float res = 1.0;\n    float ph = 1e20;\n    float t = MIN_HIT_DIST;\n    \n    for (int i = 0; i < STEP_COUNT; i++) {\n        vec2 pos = position + rayDir * t;\n        float h = getNearestDist(pos, shapeIndex);\n        \n        res = min(res, h/(SHADOW_SOFTNESS*t));\n        t += clamp(h, MIN_HIT_DIST, MAX_TRACE_DIST);\n        \n        if( res<-1.0 || t>distToLight) break;\n    }\n    \n    res = max(res,-1.0);\n    res = 0.25*(1.0+res)*(1.0+res)*(2.0-res);\n    \n    \n    vec3 attenuation = getAttenuation(shape, rayDir, distToLight);\n       \n    return attenuation * res;\n}\n\nbool flicker(float seed, float speed) {\n    seed = seed / speed;\n    seed += iTime;\n    return cos( sin(seed / (0.1 * radians(180.0))) + cos(1.5 * seed) ) + sin(seed / (radians(180.0)) + cos(10.0 * seed)) > 1.9;\n}\n\nvec2 imageToPos(vec2 coords) {\n    return (coords / vec2(183.0,-183.0) + vec2(-0.5,0.5)) * distanceX * 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Red line\n    /*Light lineLight0;\n    lineLight0.constant = 1.0;\n    lineLight0.linear = 0.5;\n    lineLight0.quadratic = 0.03;\n    lineLight0.color = vec3(0.95,0.2,0.3);\n    \n    float xOffset = sin(iTime*0.1);\n    xOffset = xOffset * xOffset * xOffset;\n    \n    shapes[0].shapeType = 0;\n    shapes[0].emissive = !flicker(0.0, 35.0);\n    shapes[0].light = lineLight0;\n    shapes[0].line.point1 = vec2(-15.0 + xOffset*50.0,8.0);\n    shapes[0].line.point2 = vec2(15.0 + xOffset*50.0,8.0);\n    shapes[0].line.stroke = 0.1;\n    \n    */\n    \n    \n    Light maizeLight;\n    maizeLight.constant = 1.3;\n    maizeLight.linear = 1.5;\n    maizeLight.quadratic = 0.05;\n    maizeLight.color = vec3(0.996,0.8039,0.03);\n    \n    Light blueLight;\n    blueLight.constant = maizeLight.constant;\n    blueLight.linear = maizeLight.linear;\n    blueLight.quadratic = maizeLight.quadratic;\n    blueLight.color = vec3(69., 86., 209.) / 255.0;\n    \n    // W \n    \n    shapes[0].shapeType = 0;\n    shapes[0].emissive = !flicker(234.31, 76.0);\n    shapes[0].light = maizeLight;\n    shapes[0].line.point1 = imageToPos(vec2(26., 50.));\n    shapes[0].line.point2 = imageToPos(vec2(26., 135.));\n    shapes[0].line.stroke = 0.1;\n    \n    shapes[1].shapeType = 0;\n    shapes[1].emissive = !flicker(234.31, 76.0);\n    shapes[1].light = maizeLight;\n    shapes[1].line.point1 = imageToPos(vec2(32., 139.));\n    shapes[1].line.point2 = imageToPos(vec2(53., 68.));\n    shapes[1].line.stroke = 0.1;\n    \n    shapes[2].shapeType = 0;\n    shapes[2].emissive = !flicker(234.31, 76.0);\n    shapes[2].light = maizeLight;\n    shapes[2].line.point1 = imageToPos(vec2(56., 69.));\n    shapes[2].line.point2 = imageToPos(vec2(75., 165.));\n    shapes[2].line.stroke = 0.1;\n    \n    shapes[3].shapeType = 0;\n    shapes[3].emissive = !flicker(234.31, 76.0);\n    shapes[3].light = maizeLight;\n    shapes[3].line.point1 = imageToPos(vec2(82., 169.));\n    shapes[3].line.point2 = imageToPos(vec2(82., 86.));\n    shapes[3].line.stroke = 0.1;\n    \n    // S\n   \n    \n    shapes[4].shapeType = 0;\n    shapes[4].emissive = !flicker(1847.5, 39.0);\n    shapes[4].light = blueLight;\n    shapes[4].line.point1 = imageToPos(vec2(156., 50.));\n    shapes[4].line.point2 = imageToPos(vec2(94., 87.));\n    shapes[4].line.stroke = 0.1;\n    \n    shapes[5].shapeType = 0;\n    shapes[5].emissive = !flicker(1847.5, 39.0);\n    shapes[5].light = blueLight;\n    shapes[5].line.point1 = imageToPos(vec2(94., 91.));\n    shapes[5].line.point2 = imageToPos(vec2(94., 125.));\n    shapes[5].line.stroke = 0.1;\n    \n    shapes[6].shapeType = 0;\n    shapes[6].emissive = !flicker(1847.5, 39.0);\n    shapes[6].light = blueLight;\n    shapes[6].line.point1 = imageToPos(vec2(94., 129.));\n    shapes[6].line.point2 = imageToPos(vec2(156., 92.));\n    shapes[6].line.stroke = 0.1;\n    \n    shapes[7].shapeType = 0;\n    shapes[7].emissive = !flicker(1847.5, 39.0);\n    shapes[7].light = blueLight;\n    shapes[7].line.point1 = imageToPos(vec2(156., 96.));\n    shapes[7].line.point2 = imageToPos(vec2(156., 130.));\n    shapes[7].line.stroke = 0.1;\n    \n    shapes[8].shapeType = 0;\n    shapes[8].emissive = !flicker(1847.5, 39.0);\n    shapes[8].light = blueLight;\n    shapes[8].line.point1 = imageToPos(vec2(156., 134.));\n    shapes[8].line.point2 = imageToPos(vec2(94., 172.));\n    shapes[8].line.stroke = 0.1;\n    \n    \n    vec2 position = convertPixelToPos(fragCoord);\n    vec3 color = BACKGROUND_COLOR;\n    \n    \n    for (int i = 0; i < SHAPE_COUNT; i++) {\n        if (shapes[i].emissive) {\n            color += getShapeEmission(i, position);\n        }\n    }\n    \n    fragColor = vec4(color.rgb,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}