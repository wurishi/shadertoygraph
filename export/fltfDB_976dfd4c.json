{"ver":"0.1","info":{"id":"fltfDB","date":"1663792100","viewed":136,"name":"shader book bg","username":"grrrwaaa","description":"shading","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["signals"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// t, p and q run from 0.0 to 1.0\n\nfloat fun1(in float t, in float p, in float q) {\n    return sin(t * PI * 3.*(sin(q)+1.) + PI * p)\n        * cos(4.*t * PI * 4.*(p-1.) + PI * q)\n     ;\n}\n\nfloat fun(in float t, in float p, in float q) {\n\n    float r = triangle(phasor(p+q), 0.5);\n    float ph = phasor(t*4.+q);\n    \n    float tri = triangle(ph, triangle(phasor(p+q), 0.5));\n    \n    //return lfo(tri, r);\n    float trap = trapezoid(tri, p, q);\n    //return sigmoid(trap, q*10.);\n    //return tri;\n    //return expo(tri, 0.5);\n    return sinc(tri * 8., r*0.9);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv1 = uv; \n    uv1 = rotate(uv-0.5, -PI)*0.9+0.5;;\n    uv1 = rotate(uv-0.5, PI * -1.1)*0.7+0.5;\n    \n    vec3 c = vec3(0);\n    float blur = 0.5;\n    \n    #define STEPS 1600\n\n    float q = mod(iTime / 4., 1.);\n    int start = 0;\n    int end = STEPS;\n    if (uv.x > 1.9) {\n        start = int(float(STEPS)*0.5);\n        end = start+100;\n    }\n    for (int i=start; i<STEPS; i++) {\n    \n        float p = float(i)/float(STEPS);\n        \n        vec3 c1 = texture(iChannel0, vec2(p*3.9+0.1)).brg;\n        //c1 += 0.08*(clamp(random(vec2(float(i+10), uv1.x*float(STEPS))),0.,1.));\n        //c1 = vec4( clamp(random(vec2(float(i), uv1.x*float(STEPS))), 0., 1.) );\n        float amp = 0.055;\n        float y; // = amp * fun(uv1.x, p, q) + p;\n        \n        \n        y = p + amp * (1.-texture(iChannel1, vec2(uv1.x, p)).r);\n        \n        float d = max(y - uv1.y, 0.); // -1 to 1, but probably much smaller\n        float blend = exp(-d * iResolution.y/blur);\n        blend = clamp(1. - d*iResolution.y * 2.*(1.-abs(0.75-uv1.y)), 0., 1.);\n        \n        c = mix(c, c1, blend);\n        \n        //c += c1 * blend;\n    }\n    \n    \n    // Output to screen\n    fragColor = iMouse.z > 0. ? texture(iChannel1, uv) : vec4(vec3(c),1.);\n    //fragColor = a;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926535897932384626433832795\n#define TWOPI (2.*PI)\n#define HALFPI (0.5*PI)\n\nfloat PHI = 1.61803398874989484820459;  // Î¦ = Golden Ratio   \n\n// a modulo operation that handles negative n more appropriately\n// e.g. wrap(-1, 3) returns 2\n// see http://en.wikipedia.org/wiki/Modulo_operation\n// see also http://jsperf.com/modulo-for-negative-numbers \nfloat wrap(float n, float m) {\n\treturn mod(mod(n, m)+m, m);\n}\n\nfloat scale(float t, float a, float b, float x, float y, float p) {\n    return pow((t-a)/(b-a), 1.) * (y-x) + x;\n}\n\nfloat phasor(in float phase) {\n    return mod(phase, 1.);\n}\n\nfloat pulse(in float phase, in float duty) {\n    return (phase + duty - 1. > 0.0)  \n    ?  1.0\n    :  0.0;\n}\n\nfloat triangle(in float phase, in float duty) {\n    return (phase < duty) \n    ?  phase / duty\n    :  (1.-phase)/(1.-duty);\n}\n\nfloat power(in float phase, in float shape) {\n    return pow(phase, tan((1.-shape)*HALFPI));\n}\n\nfloat arc(in float phase, in float shape) {\n    bool rise = shape < 0.5;\n    float a = rise ? 1.0 : 0.0;\n    float nota = 1.0 - a;\n    \n    float curve = tan( (1.-shape) * HALFPI );\n    float rcurve = 1./curve;\n    \n    float x1 = (phase - nota) / (a - nota);\n    float x2 = pow(x1, rise ? curve : rcurve);\n    float x3 = pow(1.-x2, rise ? rcurve : curve);\n    \n    float x4 = a + x3 * (nota-a);\n    return x4;\n}\n\nfloat lfo(in float phase, in float shape) {\n    float curve = pow(1.-shape, 0.884);\n    return mix(round(phase), phase, arc(triangle(phase, 0.5), curve));\n}\n\nfloat trapezoid(in float phase, in float duty, in float shape) {\n    float phase1 = phase + duty - 1.;\n    if (shape >= 1.) return phase1 > 0. ? 1. : 0.;\n    \n    float shape1 = 1./(1.-shape);\n    \n    return clamp(phase1*shape1 + 1.-duty, 0., 1.);\n}\n\nfloat elastic(in float phase, in float shape) {\n    float si = 1.-shape;\n    float p = phase > si ? 1. : 0.;\n    float x1 = (phase-p)/(si-p);\n    \n    float x2 = exp2((x1-1.)*10.) * sin(HALFPI*13.*x1);\n    \n    return x2*(si-p)+p;\n}\n\nfloat expo(in float phase, in float shape) {\n    float si = 1.-shape;\n    float p = phase > si ? 1. : 0.;\n    float x1 = (phase-p)/(si-p);\n     \n    float x2 = exp2((x1-1.)*10.);\n    \n    return x2*(si-p)+p;\n}\n\nfloat sine(in float phase) {\n    return sin(TWOPI * phase)*0.5+0.5;\n}\n\nfloat sigmoid(in float bi, in float shape) {\n    float shape1 = scale(shape, 1.00001, -0.00001, -1., 0., -1.);\n    float bi1 = bi * shape1;\n    return tanh(bi1) / tanh(shape1);\n    //return (bi1/(abs(bi1)+1.)) * ((shape1+1.)/shape1);\n    //return (bi1/(sqrt(bi1*bi1+1.))) / (sqrt(shape1*shape1+1.)/shape1);\n}\n\nfloat cycle(in float phase) {\n    return sin(TWOPI * phase);\n}\n\nfloat sinc(in float phase, in float shape) {\n    float n = tan((shape)*HALFPI);\n    float p1 = phase * 0.5 * n;\n    return phase == 0. ? 1. : sin(p1)/p1;\n}\n\n\nfloat seed = 1.;\nfloat random(in vec2 xy) {\n       return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n}\n\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float noise(in vec2 p, in float lod) {\n    return texture(iChannel1, p, lod).r;\n}\n\nfloat noise2(in vec2 p, in float lod) {\n    float n = \n        (0.1*texture(iChannel1, p, lod+0.).r+\n        0.2*texture(iChannel1, p, lod+1.).r+\n        0.3*texture(iChannel1, p, lod+2.).r+\n        0.4*texture(iChannel1, p, lod+3.).r);\n    return clamp(sigmoid((n-0.3)*5., 1.)*0.5+0.5, 0., 1.);\n}\n\nfloat fun(in float t, in float p, in float q) {\n\n    q = 0.4+0.1*iTime;\n    float o;\n    float n = noise2(vec2((t+q)*-0.5, p), 4.);\n    float n2 = noise2(vec2((t+q)*3.9, p), 4.);\n    //return n;\n\n    float ph1 = phasor(t*(2.+pow(p, 4.)*2.5));\n    float ph2 = phasor(t*(2.+pow(p, 4.)*7.));\n    //return sine(ph) * sine(ph2);\n    \n    float ph3 = sine(q + phasor((1.1+1.0*n) * sine(q + ph2) + ph1)) * sine(q + ph1);\n    return ph3+n2*0.5;\n    \n    //float r = triangle(phasor(t+q), 0.5);\n    //return r;\n    \n    //float tri = triangle(ph1, triangle(phasor(p+q), 0.5)*0.5+0.25);\n    //return tri;\n    //return lfo(tri, r*0.5+0.2);\n    //float trap = trapezoid(tri, p, q);\n    //return sine(trap);\n    //return sigmoid(trap, q*10.);\n    //return tri;\n    //return expo(tri, 0.5);\n    //return sinc(tri, 10.);\n    \n    //o = n;\n    //return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float c = 0.0;\n    float blur = 0.5;\n    \n    #define STEPS 800\n\n    float t = uv.x;\n    float p = 1.-uv.y;\n    float q = iTime / 10.;\n    q = phasor(q);\n    \n    \n    \n    //q = noise2(vec2(q+t, p), 2.);\n    float y = fun(t, p, q);\n    \n    fragColor = vec4(y);\n}","name":"Buffer A","description":"","type":"buffer"}]}