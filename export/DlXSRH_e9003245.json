{"ver":"0.1","info":{"id":"DlXSRH","date":"1675520479","viewed":267,"name":"Chaos corrects itself","username":"shau","description":"Hello :) More cubes!\n","likes":29,"published":1,"flags":32,"usePreview":0,"tags":["3d","sparcegridmarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\nconst float GA = 2.399; \n\n// simplified version of Dave Hoskins blur from Virgill\nvec3 dof(sampler2D tex, vec2 uv, float rad) {\n\tvec3 acc = vec3(0);\n    vec2 pixel = vec2(.002*R.y/R.x, .002), angle = vec2(0, rad);;\n    rad = 1.;\n\tfor (int j=ZERO;j<80;j++) {  \n        rad += 1. / rad;\n\t    angle *= rot(GA);\n        vec4 col=texture(tex,uv + pixel*(rad-1.)*angle);\n\t\tacc += col.xyz;\n\t}\n\treturn acc/80.;\n}\n\nvoid mainImage(out vec4 C, vec2 U) {\n    \n    vec2 uv = U / R;\n    C = vec4(vec4(dof(iChannel0, uv, texture(iChannel0, uv).w), 1.).xyz, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by SHAU - 2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n//Nimitz\n//https://www.shadertoy.com/view/XlfGDs\nconst float c = 1.0;\nconst float ch = c*0.5;\nconst float ch2 = ch + 0.01;\nfloat dBox(vec3 ro, vec3 rd)  \n{\n    vec3 m = 1./rd;\n    vec3 t = -m*ro + abs(m)*ch2;\n\treturn min(min(t.x,t.y),t.z);\n}\n\n//Dave Hoskins - Hash without sin\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3*.1031);\n    p3 += dot(p3,p3.zyx + 31.32);\n    return fract((p3.x+p3.y)*p3.z);\n}\n\n//Shane IQ\nfloat n3D(vec3 p) {    \n\tconst vec3 s = vec3(7,157,113);\n\tvec3 ip = floor(p); \n    p -= ip; \n    vec4 h = vec4(0.,s.yz,s.y + s.z) + dot(ip,s);\n    p = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.5453),fract(sin(h + s.x)*43758.5453),p.x);\n    h.xy = mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z);\n}\n\n//IQ\n//https://iquilezles.org\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nvec2 map(vec3 p, vec3 rd, inout vec3 mqd) \n{    \n    //movement\n    float ar = 0.2 + sin(T*0.37*sign(p.x))*0.07,\n          a1 = (floor(p.z/c) + 0.5)*0.179*sign(p.x) + (T*0.41) + 0.67,\n          a2 = (floor(p.y/c) + 0.5)*0.23*sign(p.x) + (T*0.89) - 1.53;\n    p.x += sin(a1+a2);\n    //sparse grid marching\n    vec3 qd = fract(p/c)*c -ch,\n         qid = floor(p/c);\n    float l = hash13(qid),\n          t = dBox(qd, rd); //Base distance is cell exit distance\n    //draw a cube\n    if (abs(p.x)>3.0 && abs(p.x)<4.0)\n    {\n        //rotate cube\n        qd.xz *= rot(cos(a1)*ar);\n        qd.xy *= rot(cos(a2)*ar);\n        mqd = qd+mod(qid,20.0);\n        t = min(t, sdRoundBox(qd, vec3(0.32), 0.05));\n    }\n    return vec2(t, l>0.9 ? 1.0 : 0.0);\n}\n\n//IQ\nvec3 normal(vec3 p, vec3 rd) \n{  \n    vec4 n = vec4(0.0);\n    vec3 mqd = vec3(0.0);\n    for (int i=ZERO; i<4; i++) \n    {\n        vec4 s = vec4(p,0.0);\n        s[i] += EPS;\n        n[i] = map(s.xyz,rd,mqd).x;\n    }\n    return normalize(n.xyz-n.w);\n}\n\nstruct SN\n{\n    vec3 pc; //pixel colour\n    float t; //distance\n    float hl; //hit light\n    float nz; //surface noise\n};\n\nSN pass(vec3 ro, vec3 rd, vec3 lp) \n{\n    vec3 pc = vec3(0.0),\n         mqd = vec3(0.0);\n    float t=0.0, l=0.0, nz=0.0, hl=0.0;\n    for (int i=ZERO;i<280;i++)\n    {\n        vec2 ns = map(ro + rd*t,rd,mqd);\n        if (ns.x<EPS) \n        {\n            l = ns.y;\n            break;\n        }\n        t += ns.x;\n        if (t>FAR)\n        {\n            t = -1.0;\n            break;\n        }\n    }\n    \n    if (t>0.0)\n    {\n        vec3 p = ro + rd*t,\n             n = normal(p,rd),\n             ld = normalize(lp-p);\n        float dif = max(0.0,dot(ld,n)),\n             spec = pow(max(dot(reflect(-ld,n),-rd),0.0),32.0);\n        nz = smoothstep(0.6,1.0,\n             min(n3D(mqd*vec3(7.0,11.0,9.0)) + \n                 n3D(mqd*vec3(31.0,36.0,23.0))*0.7,1.0));\n        if (l>0.0)\n        {\n            //light\n            hl = 1.0;\n            pc = vec3(1.0)/(1.0 + t*t*0.005);\n        } \n        else\n        {\n            pc = (vec3(0.04)*dif+ \n                 vec3(1.0)*spec*nz)/\n                 (1.0 + t*t*0.03);\n        }\n        \n    }\n    \n    return SN(pc,t,hl,nz);\n}\n\nvec4 render(vec3 ro, vec3 rd) \n{\n    SN sn = SN(vec3(0),0.0,0.0,0.0);\n    vec3 lp = ro+vec3(0.0,3.0,-8.0),\n         pc = vec3(0);\n    float mt = 0.0;\n    sn = pass(ro,rd,lp);\n    pc = sn.pc;\n    if (sn.t>0.0)\n    {\n        mt = sn.t/200.0; //dof\n        if (sn.hl==0.0)\n        {\n            //reflection\n            vec3 pc2 = vec3(0),\n                 p = ro + rd*sn.t,\n                 n = normal(p,rd),\n                 rrd = reflect(rd,n);\n            SN rsn = pass(p-rd*EPS,rrd,lp);\n            pc += rsn.pc/(1.0 + mt*mt*0.13)*max(0.1,sn.nz)*0.2;\n        }\n    }\n    pc = pow(pc,vec3(0.4545));\n    return vec4(pc,mt);\n}\n\n//IQ\nmat3 camera(vec3 la, vec3 ro, float cr)\n{\n\tvec3 cw = normalize(la - ro),\n\t     cp = vec3(sin(cr),cos(cr),0.0),\n\t     cu = normalize(cross(cw,cp)),\n\t     cv =          (cross(cu,cw));\n    return mat3(cu,cv,cw); \n}\n\nvoid mainImage( out vec4 C, vec2 U )\n{\n    float AT = T*-8.0,\n          mt = mod(T,40.0),\n          AT2 = (smoothstep(17.0,20.0,mt) - smoothstep(37.0,40.0,mt))*1.5707,\n          fl = 1.0;\n    vec3 la = vec3(0.0,3.0,-10.0 + AT),\n         ro = vec3(sin(T*0.18)*1.6,sin((T - 31.3)*0.53)*2.8,AT);\n    mat3 cam = camera(la,ro,AT2 + sin(T*0.73)*0.2);\n    vec2 uv = (2.0*(U) - R.xy)/R.y;\n    vec3 rd = cam*normalize(vec3(uv,fl));  \n    C = vec4(render(ro,rd));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Created by SHAU - 2023\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define R iResolution.xy\n#define ZERO (min(iFrame,0))\n#define EPS .002\n#define FAR 100.\n#define T iTime\n\n//Fabrice - compact rotation\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}","name":"Common","description":"","type":"common"}]}