{"ver":"0.1","info":{"id":"tdVBWV","date":"1616798350","viewed":108,"name":"Micro-Projet ","username":"Mehdix92i","description":"Micro projet synthèse d'image\nTentative motion blur et antialiasing sans succès","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["lightingraytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float     FLT_MAX                   = 1.0 / 0.0;    \n\nconst int       MAX_NB_BOUNCES            = 5;\n\nconst int       NB_LIGHTS                 = 2;\n\nconst int       TIME_SAMPLING_SIZE        = 5;\nconst float     TIME_SAMPLING_OFFSET_TIME = 0.075;\n\nstruct Material\n{\n    float Ka;\t// ambiant        coefficient\n    float Kd;\t// diffuse        coefficient\n    float Ks;\t// specular       coefficient\n    float Kn;\t// specular power coefficient\n};\n\nstruct ShaderInfo\n{\n    vec3 shaderCol;\n    float Ks;\n};\n\nstruct LightInfo\n{\n    vec3 pos;\n    vec3 col;\n    float power;\n};\n    \n    //_________________________________________________________________________________\n        \n// Camera parameters\n      vec3\t   cameraPos    = vec3(6,  3.5, -5);\nconst vec3\t   cameraTarget = vec3(3,  1, -8);\nconst float    cameraFovY   = 80.0;\t\t\t\t// NOTE: angle in degree\n\n// Sky parameters\nconst vec3     skyCol       = vec3(0.3,0.4,1);\t\t\t\nconst int      skyId        = 0;\n\n// Sphere parameters\n      vec3     spherePos    = cameraTarget + vec3(0, 1, 2);\nconst float    sphereRadius = 1.0;\nconst vec3     sphereCol    = vec3(1,0,0);\t\t// red\nconst Material sphereMat    = Material(0.2/*Ka*/, 0.7/*Kd*/, 1.0/*Ks*/, 50.0/*Kn*/);\nconst int      sphereId     = 1;\n\n// Plane parameters\nconst vec3     planePos     = vec3(0, 0.1, 0);\nconst vec3     planeNormal  = vec3(0, 1.0, 0);\nconst vec3     planeCol1    = vec3(1.0);\t\t\nconst vec3     planeCol2    = vec3(0.1);\t\t\nconst Material planeMat     = Material(0.2/*Ka*/, 1.0/*Kd*/, 0.2/*Ks*/,  5.0/*Kn*/);\nconst int      planeId      = 2;\n\n// Light(s) parameters\nconst vec3     ambiantCol   = vec3(0,0,0);\t\t\nconst vec3     light1Col     = vec3(1,1,1);\t\t// white\n      vec3     light1Pos     = vec3(8, 10, -12);\nconst float    light1Pow    = 0.8;\nconst vec3     light2Col   = vec3(1,0.4,1);    //purple\n      vec3     light2Pos    = vec3(3, 10, 1);\nconst float    light2Pow    = 0.5; \n\nLightInfo lights[NB_LIGHTS];\n\n//##############################################################################################\n\n\nfloat raySphere(    vec3 rayPos    ,     vec3 rayDir, vec3 spherePos, float sphereRadius,\n                out vec3 intersecPt, out vec3 normal)\n{   \n    vec3 diff = rayPos - spherePos;\n    \n    float a =       dot(rayDir, rayDir);\n    float b = 2.0 * dot(diff  , rayDir);\n    float c =       dot(diff  , diff  ) - sphereRadius * sphereRadius;\n    \n    float di = b*b - 4.0*a*c;\n    \n    if (di >= 0.0)\n    {\n        float sdi = sqrt(di);\n        float den = 1. / (2.0 * a);\n        float t1  = (-b - sdi) * den;\n        float t2  = (-b + sdi) * den;\n\n        float t = -1.0;\n        float dir = 1.0;\n        if (t1 > 0.0)\n        \tt = t1;\n        else if (t2 > 0.0)\n        {\n            t = t2;\n            dir = -1.0;\n        }\n        else\n            return t;\n        \n        intersecPt = rayPos + t * rayDir;\n\n        normal     = normalize(intersecPt - spherePos) * dir;\n        \n        return t;\n    }\n    \n    return -1.0;\n}\n\n\n//----------------------------------------------------------------------------------------------\n\n\n\nfloat rayPlane(    vec3 rayPos    ,     vec3 rayDir, vec3 planePos, vec3 planeNormal,\n               out vec3 intersecPt, out vec3 normal)\n{\n    \n    float den = dot(planeNormal, rayDir);\n    \n    if (abs(den) <= 0.000001)\t// To avoid numerical instabilities we consider the ray to be \n        return -1.0;\t\t\t// parallel if the angle between the normal and the ray is\n        \t\t\t\t\t\t// ALMOST zero.\n        \t\t\t\t\t\n    float t = dot(planeNormal, planePos - rayPos) / den;\n    \n   \n    intersecPt = rayPos + t * rayDir;\n    \n   \n    normal = -sign(den) * planeNormal;\n    \n    return t;\n}\n\n\n//----------------------------------------------------------------------------------------------\n\n\nvoid computeCameraRayFromPixel( in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir)\n{\n\n    float focal = 1.0 / tan(radians(cameraFovY) / 2.0);\n    \n    vec3 cz = normalize(cameraTarget - cameraPos);\n    \n    \n    vec3 up = vec3(0,1,0);\t\t\t\t\t\t\t// perfect up vector\n    vec3 cx = normalize(cross(-up, cz));\n    \n\n    vec3 cy = normalize(cross( cz, cx));\n    \n    vec2 pt = (2.*pixCoord - iResolution.xy) / iResolution.y;\n    \n    rayPos = cameraPos;\n    rayDir = normalize(pt.x * cx - pt.y * cy + focal * cz);\n}\n\n\n//----------------------------------------------------------------------------------------------\n\n\n// The aim of this routine is to find the nearest intersection the ray has with ALL the objects\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir,\n                                 out int objectId, out vec3 intersecI, out vec3 normalI)\n{\n    // Set the default value when no intersection is found: we hit the 'sky'\n    float minDist  = FLT_MAX;\n          objectId = skyId;\n    \n    // Test the sphere\n    vec3 intersecS, normalS;\n    float distS = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    if ((distS > 0.0) && (distS < minDist))\n    {\n        objectId  =  sphereId;\n        minDist   =     distS;\n        intersecI = intersecS;\n          normalI =   normalS;\n    }\n    \n    // Test the plane\n    vec3 intersecP, normalP;\n    float distP =  rayPlane(rayPos, rayDir,  planePos,  planeNormal, intersecP, normalP);\n    if ((distP > 0.0) && (distP < minDist))\n    {\n        objectId  =   planeId;\n        minDist   =     distP;\n\t    intersecI = intersecP;\n    \t  normalI =   normalP;\n    }\n    \n    // To remain coherent with the raySphere & rayPlane function that returns -1 when no\n    // intersetion is found, we add the following two lines:\n    if (objectId == skyId)\n        minDist = -1.0;\n    \n    return minDist;\n}\n\n\n//----------------------------------------------------------------------------------------------\n\n\nvec3 getSphereColorAtPoint(vec3 pt)\n{\n    return sphereCol;\n}\n\n\n//----------------------------------------------------------------------------------------------\n\n\n// pt is assumed to be on the plane surface\nvec3 getPlaneColorAtPoint(vec3 pt)\n{\n\n    vec3 worldX = vec3(1,0,0);\n    vec3 axisX  = normalize(worldX - dot(worldX, planeNormal) * planeNormal);\n    \n    // We then find the plane Y-axis thanks to the cross-product\n    // properties with orthonormal basis\n    vec3 axisY  = normalize(cross(planeNormal, axisX));\n\n    // Now, find the coordinate of the input point according to this texture coordinate frame\n    vec3 diff = pt - planePos; \n    float u = dot(diff, axisX);\n    float v = dot(diff, axisY);\n \n //Antialiasing\n    //return smoothstep( pct-0.02, pct, v) - smoothstep( pct, pct+0.02, v);\n    \n    // Finally, apply the checkboard pattern by using this very concise formula:\n    return mod(floor(u * 0.5) + floor(v * 0.5), 2.0) < 1.0  ? planeCol1 : planeCol2;\n}\n\n\n//----------------------------------------------------------------------------------------------\n\n\nvec3 getObjectColorAtPoint(int objectId, vec3 pt, out Material objectMat)\n{\n    if (objectId == sphereId)\n    {\n        objectMat = sphereMat;\n        return getSphereColorAtPoint(pt);\n    }\n    else if (objectId == planeId)\n    {\n        objectMat = planeMat;\n        return getPlaneColorAtPoint(pt);\n    }\n        \n    return skyCol;\n}\n\n\n//----------------------------------------------------------------------------------------------\n\n\nfloat getShadowFactorAtPoint(vec3 I, vec3 N, Material objectMat, vec3 L, float Ldist)\n{\n    \n    vec3  shadowRayStart = I + 0.0001 * N;\t// Move the surface point a little outward\n    \t\t\t\t\t\t\t\t\t\t// (along its normal) to ensure it is a bit\n    \t\t\t\t\t\t\t\t\t\t// above the surface.\n\n\t\n    vec3  shadowRayDir   = L;\n    \n    int   unusedInt;\n    vec3  unusedVec1, unusedVec2;\n    float shadowRes = computeNearestIntersection(shadowRayStart, shadowRayDir,\n                                                 unusedInt, unusedVec1, unusedVec2);\n    \n    float shadowFactor = (shadowRes < 0.0 || shadowRes >= Ldist) ? 1.0 : objectMat.Ka;\n    \n    return shadowFactor;\n}\n\n\n//----------------------------------------------------------------------------------------------\n\n\nvec3 computePhongShading(vec3 objectCol, Material objectMat,\n                         float shadowFactor, vec3 N, int indL, vec3 L, vec3 R, vec3 V)\n{   \n    vec3 ambiant  = objectMat.Ka * ambiantCol;\n    vec3 diffuse  = objectMat.Kd *  objectCol * lights[indL].col * lights[indL].power *   max(dot(N,L), 0.);\n    vec3 specular = objectMat.Ks *              lights[indL].col * lights[indL].power *   pow(max(dot(R,V), 0.), objectMat.Kn);\n    \n    float shadowFactorSpec = shadowFactor < 1.0 ? 0.0 : 1.0;\n    \n    vec3 phongCol = ambiant + (diffuse * shadowFactor) + (specular * shadowFactorSpec);\n\n    return phongCol;\n}\n\n\n//----------------------------------------------------------------------------------------------\n\n\nvoid AnimateScene(float time)\n{\n    // Animate the sphere position\n    const float pi           = 3.1415926535;\n    const float rs           = 2.0;\n    const float spr          = 5.0;\n    float       as           = 2.0 * pi * time / spr;\n\t    // NOTE: at time=0, the sphere position is the same than the default one defined at\n    \t//       the top of this source code.\n    spherePos = cameraTarget + rs * vec3(-sin(as), 0.0, cos(as)) + vec3(0,1,0);\n    \n    // Animate the light position\n    // NOTES: - light will move up and down from height of 1 to 20.\n    //        - again we made our formula so that the position is the default one at time=0.\n    light1Pos += vec3(0, 10.5 + 9.5 * cos(time) - 10., 0);\n    \n    // Animate the camera\n    // NOTE: again we made our formula so that the position is the default one at time=0.\n    float targetDist = length(cameraTarget - cameraPos);\n    cameraPos -= vec3(0, 0, targetDist);\n    cameraPos += targetDist*vec3(sin(time),max(sin(time*0.5),0.),cos(time));\n}\n\n\n\n//----------------------------------------------------------------------------------------------\n\n\nvoid AnimateScene2(float time, float dtime)\n{\n    // Animate the sphere position\n    const float pi           = 3.1415926535;\n    const float rs           = 2.0;\n    const float spr          = 5.0;\n    float       as           = 2.0 * pi * time / spr;\n        // NOTE: at time=0, the sphere position is the same than the default one defined at\n        //       the top of this source code.\n    spherePos = cameraTarget + rs * vec3(-sin(as), 0.0, cos(as)) + vec3(0,1,0);\n}\n\n\n//----------------------------------------------------------------------------------------------\n\n\nvoid AnimateScene2Blur(float time, float dtime)\n{\n    // Animate the sphere position\n    const float pi           = 3.1415926535;\n    const float rs           = 2.0;\n    const float spr          = 5.0;\n    float       as           = 2.0 * pi * time / spr;\n        // NOTE: at time=0, the sphere position is the same than the default one defined at\n        //       the top of this source code.\n    spherePos = cameraTarget + rs * vec3(-sin(as), 0.0, cos(as)) + vec3(0,1,0);\n}\n\n\n//----------------------------------------------------------------------------------------------\n\nfloat integrate(vec2 pos1, vec2 pos2)\n{\n    vec2 D = pos2 - pos1; \n    \n    float t0 = 0.;\n    float t1 = 1.;\n    \n    \n    return 0.0;\n}\n\n//----------------------------------------------------------------------------------------------\n\n\nvec3 RaycastAtPixelCoord(vec2 pixCoord)\n{\n    // Set the time used for the animation\n    float time = iTime;\n    float dtime = iTimeDelta;\n    \n    \n    // Animate scene objects\n    AnimateScene2Blur(time,dtime);\n    AnimateScene2Blur(time + 10.0,dtime);\n    \n    // Compute the ray to be casted through the pixel towards the 3D scene\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(pixCoord, rayPos, rayDir);\n    \n\t// Test ray-objetcs intersections and find the nearest one\n    // (with its associated intersection point and normal at the object surface)\n    int  objectId;\n    vec3 intersecI, normalI;\n    float distI = computeNearestIntersection(rayPos, rayDir, objectId, intersecI, normalI);\n    \n    // Apply the shading to the points that are on the sphere surface and seen by the camera\n    if (distI > 0.0)\n    {\n        // unit-vector going from the surface point toward the light and\n        // length of the segment between the two points\n\t    vec3 L = light1Pos - intersecI;\n        float Ldist = length(L);\n        L = L / Ldist;\n        \n        // unit-vector of the reflection direction of the light at the surface point\n    \tvec3 R = 2.0 * dot(normalI, L) * normalI - L;\n        \n        // unit-vector going from the surface point toward the camera \n        vec3 V = -rayDir;\n        \n        // Get the diffuse color at the intersection point\n        Material objectMat;\n        vec3 objectCol = getObjectColorAtPoint(objectId, intersecI, objectMat);\n        \n\t\t// Find the factor of light attenuation that results\n        // from the intersection point being visible from the light source or in shadow.\n        float shadowFactor = getShadowFactorAtPoint(intersecI, normalI, objectMat, L, Ldist);\n        \n        // Apply the Phong shading to compute the color\n        // of the surface point as seen from the camera\n    \treturn vec3(computePhongShading(objectCol, objectMat,\n                                             shadowFactor, normalI, 0/*light1*/,  L, R, V));\n    }\n    else\t// We did not hit the sphere, so we have the sky color (here: black)\n     \treturn vec3(skyCol);\n}\n\n\n//----------------------------------------------------------------------------------------------\n\n\nvec3 RaytraceAtPixelCoord(vec2 pixCoord)\n{\n\n    //Set the time used for the animation\n    float time = iTime;\n    float dtime = iTimeDelta;\n    \n    \n    // Animate scene objects\n    AnimateScene2Blur(time,dtime);\n    AnimateScene2Blur(time/2.0,dtime);\n    \n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(pixCoord,rayPos, rayDir);\n    \n    ShaderInfo infos[MAX_NB_BOUNCES];\n    int nbBounces = 0;\n    do\n    {\n        int objectId;\n        vec3 intersecI, normalI;\n        float distI = computeNearestIntersection(rayPos, rayDir, objectId, intersecI, normalI);\n        if (distI <= 0.0)\n        {\n            infos[nbBounces].shaderCol = skyCol;\n            infos[nbBounces].Ks        = 0.0;\n            break;\n        }\n        //AMBIANTE 1X\n        for (int i=0; i<NB_LIGHTS; i++)\n        {\n            vec3 L = lights[i].pos - intersecI;\n            float Ldist = length(L);\n            L = L / Ldist;\n            vec3 R = 2.0 * dot(normalI, L) * normalI - L;\n            vec3 V = -rayDir;\n\n            Material objectMat;\n            vec3 objectCol = getObjectColorAtPoint(objectId, intersecI, objectMat);\n            float shadowFactor = getShadowFactorAtPoint(intersecI, normalI, objectMat, L, Ldist);\n            infos[nbBounces].shaderCol += computePhongShading(objectCol, objectMat, shadowFactor, normalI, i, L, R, V);\n            infos[nbBounces].Ks        = objectMat.Ks;\n        }  \n        \n        rayPos = intersecI + normalI * 0.001;\n        rayDir = reflect(rayDir, normalI);\n        nbBounces ++;\n        \n    }while (nbBounces < MAX_NB_BOUNCES);\n    \n    if (nbBounces == 0) return skyCol;\n    \n    vec3 resCol = infos[nbBounces - 1].shaderCol;\n    \n    \n    for(int i = nbBounces-2; i>=0; i--)\n    {\n        resCol = resCol * infos[i].Ks + infos[i].shaderCol;\n    }\n    \n  \n    return resCol;\n}\n\n\n//##############################################################################################\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    lights[0].pos = light1Pos;\n    lights[0].col = light1Col;\n    lights[0].power = light1Pow;\n    lights[1].pos = light2Pos;\n    lights[1].col = light2Col;\n    lights[1].power = light2Pow;\n\n    //vec3 resCol = RaycastAtPixelCoord(fragCoord);\n        \n    \n    vec3 resCol = RaytraceAtPixelCoord(fragCoord);\n    \n    \n    fragColor = vec4(resCol, 1.0);\n}","name":"Image","description":"","type":"image"}]}