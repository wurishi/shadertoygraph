{"ver":"0.1","info":{"id":"NslczM","date":"1641875967","viewed":65,"name":"super simple shifting shapes","username":"hlw","description":"diamond-based shapes moving along rows and columns. Change macro values to modify visual attributes.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["pattern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// increase to increase the number of tiles on the y-axis\n#define NUMTILE         10.\n// precondition: W > 0.0 \n// increase to enlarge shape drawn on tile\n#define W               1.5\n// increase to make shape drawn on tile taller and thinner\n#define SLOPE           1.2\n// precondition: 0.0 < R <= 1.0, 0.0 < G <= 1.0, 0.0 < B <= 1.0\n#define COL             vec3(1.0, 1.0, 1.0)\n// precondition: 0.0 <= XPOS <= 1.0, 0.0 <= YPOS <= 1.0\n#define DRAWCENTER      vec2(0.5, 0.5)\n// increase to speed up tile movement\n#define SPEED           0.25\n// precondition: ANTIALIAS >= 0 and ANTIALIAS <= LINERADIUS / 2\n#define ANTIALIAS       1.0\n\nfloat drawOneThing(vec2 center, vec2 uv, float w)\n{\n    float halfW = w / 2.;\n    float b = center.y - SLOPE * center.x;\n    float aa = ANTIALIAS / iResolution.y;\n    float belowTop;\n    float aboveBottom;\n    \n    if (uv.x < center.x)\n    {\n        belowTop = smoothstep(uv.y - aa, uv.y + aa, SLOPE * uv.x + b + halfW);\n        aboveBottom = smoothstep(-1. * SLOPE * uv.x - b + 2. * center.y - halfW - aa, -1. * SLOPE * uv.x - b + 2. * center.y - halfW + aa, uv.y);\n    } else {\n        belowTop = smoothstep(uv.y - aa, uv.y + aa, -1. * SLOPE * uv.x - b + 2. * center.y + halfW);\n        aboveBottom = smoothstep(SLOPE * uv.x + b - halfW - aa, SLOPE * uv.x + b - halfW + aa, uv.y);\n    }\n    /*\n    // split the thing across tiles\n    uv.x = abs(uv.x - center.x);\n    belowTop = step(uv.y, SLOPE * uv.x + b + halfW);\n    aboveBottom = step(-1. * SLOPE * uv.x - b + 2. * center.y - halfW, uv.y);\n    */\n    \n    return aboveBottom * belowTop;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates\n    vec2 uv = fragCoord/iResolution.y;\n    \n    uv = uv * NUMTILE;\n    \n    // Move tile based on tile pos and time\n    float spd = SPEED * iTime;\n    if (mod(spd, 2.) >= 1.) {\n        if (mod(uv.y, 2.) >= 1.) {\n            uv.x += spd; // vec2(uv.x + spd, uv.y);\n        } else {\n            uv.x -= spd; // vec2(uv.x - spd, uv.y);\n        }\n    } else {\n        if (mod(uv.x, 2.) >= 1.) {\n            uv.y += spd; // vec2(uv.x, uv.y + spd);\n        } else {\n            uv.y -= spd; // vec2(uv.x, uv.y - spd);\n        }\n    }\n    \n    uv = fract(uv);\n    \n    float c = drawOneThing(DRAWCENTER, uv, W);\n\n    vec3 col = c * COL;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}