{"ver":"0.1","info":{"id":"lsdSWS","date":"1461301255","viewed":149,"name":"exprend","username":"visy","description":"rexpend","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["exprend"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// bind roughness   {label:\"Roughness\", default:0.25, min:0.1, max:1, step:0.001}\n// bind dcolor      {label:\"Diffuse Color\",  r:1.0, g:1.0, b:1.0}\n// bind scolor      {label:\"Specular Color\", r:1.0, g:1.0, b:1.0}\n// bind intensity   {label:\"Light Intensity\", default:4, min:0, max:10}\n// bind width       {label:\"Width\",  default: 4, min:0.1, max:15, step:0.1}\n// bind height      {label:\"Height\", default: 4, min:0.1, max:15, step:0.1}\n\nfloat roughness =1.;\nvec3  dcolor = vec3(0.0001,0.0001,0.0001);\nvec3  scolor = vec3(0.0001,0.0001,0.0001);\n\nfloat intensity =0.2;\nfloat width = 0.0;\nfloat height = 6.0;\n\nmat4 view = mat4(\n    vec4(1.0, 0.0, 0.0, 0.0),\n    vec4(0.0, 1.0, 0.0, 0.0),\n    vec4(0.0, 0.0, 1.0, 0.0),\n    vec4(0.0, 0.0, 0.0, 2.0)\n);\nint   sampleCount = 10;\n\nconst int   NUM_SAMPLES = 10;\nconst float LUT_SIZE  =264.0;\nconst float LUT_SCALE = (LUT_SIZE - 1.0)/LUT_SIZE;\nconst float LUT_BIAS  = 0.5/LUT_SIZE;\nconst float pi = 3.14159265;\n\n// See \"Building an orthonormal basis from a 3d unit vector without normalization\"\n// Frisvad, Journal of Graphics Tools, 2012.\nmat3 CreateBasis(vec3 v)\n{\n    vec3 x, y;\n\n    if (v.z < -0.999999)\n    {\n        x = vec3( 0, -1, 0);\n        y = vec3(-1,  0, 0);\n    }\n    else\n    {\n        float a = 1.0 / (1.0 + v.z);\n        float b = -v.x*v.y*a;\n        x = vec3(1.0 - v.x*v.x*a, b, -v.x);\n        y = vec3(b, 1.0 - v.y*v.y*a, -v.y);\n    }\n\n    return mat3(x, y, v);\n}\n\n// Tracing and intersection\n///////////////////////////\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct Rect\n{\n    vec3  origin;\n    vec4  plane;\n    float sizex;\n    float sizey;\n};\n\nbool RayPlaneIntersect(Ray ray, vec4 plane, out float t)\n{\n    t = -dot(plane, vec4(ray.origin, 1.0))/dot(plane.xyz, ray.dir);\n    return t > 0.0;\n}\n\nbool RayRectIntersect(Ray ray, Rect rect, out float t)\n{\n    bool intersect = RayPlaneIntersect(ray, rect.plane, t);\n    if (intersect)\n    {\n        vec3 pos = ray.origin + ray.dir*t;\n        vec3 lpos = pos - rect.origin;\n        if (abs(lpos.x) > rect.sizex || abs(lpos.y) > rect.sizey)\n            intersect = false;\n    }\n\n    return intersect;\n}\n\nstruct SphQuad\n{\n    vec3 o, x, y, z;\n    float z0, z0sq;\n    float x0, y0, y0sq;\n    float x1, y1, y1sq;\n    float b0, b1, b0sq, k;\n    float S;\n};\n\nSphQuad SphQuadInit(vec3 s, vec3 ex, vec3 ey, vec3 o)\n{\n    SphQuad squad;\n    \n    squad.o = o;\n    float exl = length(ex);\n    float eyl = length(ey);\n    \n    // compute local reference system â€™Râ€™\n    squad.x = ex / exl;\n    squad.y = ey / eyl;\n    squad.z = cross(squad.x, squad.y);\n    \n    // compute rectangle coords in local reference system\n    vec3 d = s - o;\n    squad.z0 = dot(d, squad.z);\n    \n    // flip â€™zâ€™ to make it point against â€™Qâ€™\n    if (squad.z0 > 0.0)\n    {\n        squad.z  *= -1.0;\n        squad.z0 *= -1.0;\n    }\n\n    squad.z0sq = squad.z0 * squad.z0;\n    squad.x0 = dot(d, squad.x);\n    squad.y0 = dot(d, squad.y);\n    squad.x1 = squad.x0 + exl;\n    squad.y1 = squad.y0 + eyl;\n    squad.y0sq = squad.y0 * squad.y0;\n    squad.y1sq = squad.y1 * squad.y1;\n    \n    // create vectors to four vertices\n    vec3 v00 = vec3(squad.x0, squad.y0, squad.z0);\n    vec3 v01 = vec3(squad.x0, squad.y1, squad.z0); \n    vec3 v10 = vec3(squad.x1, squad.y0, squad.z0); \n    vec3 v11 = vec3(squad.x1, squad.y1, squad.z0);\n\n    // compute normals to edges\n    vec3 n0 = normalize(cross(v00, v10));\n    vec3 n1 = normalize(cross(v10, v11));\n    vec3 n2 = normalize(cross(v11, v01));\n    vec3 n3 = normalize(cross(v01, v00));\n\n    // compute internal angles (gamma_i)\n    float g0 = acos(-dot(n0, n1));\n    float g1 = acos(-dot(n1, n2));\n    float g2 = acos(-dot(n2, n3));\n    float g3 = acos(-dot(n3, n0));\n    \n    // compute predefined constants\n    squad.b0 = n0.z;\n    squad.b1 = n2.z;\n    squad.b0sq = squad.b0 * squad.b0;\n    squad.k = 2.0*pi - g2 - g3;\n    \n    // compute solid angle from internal angles\n    squad.S = g0 + g1 - squad.k;\n\n    return squad;\n}\n\nvec3 SphQuadSample(SphQuad squad, float u, float v)\n{\n    // 1. compute 'cu'\n    float au = u * squad.S + squad.k;\n    float fu = (cos(au) * squad.b0 - squad.b1) / sin(au);\n    float cu = 1.0 / sqrt(fu*fu + squad.b0sq) * (fu > 0.0 ? 1.0 : -1.0);\n    cu = clamp(cu, -1.0, 1.0); // avoid NaNs\n    \n    // 2. compute 'xu'\n    float xu = -(cu * squad.z0) / sqrt(1.0 - cu * cu);\n    xu = clamp(xu, squad.x0, squad.x1); // avoid Infs\n    \n    // 3. compute 'yv'\n    float d = sqrt(xu * xu + squad.z0sq);\n    float h0 = squad.y0 / sqrt(d*d + squad.y0sq);\n    float h1 = squad.y1 / sqrt(d*d + squad.y1sq);\n    float hv = h0 + v * (h1 - h0), hv2 = hv * hv;\n    float yv = (hv2 < 1.0 - 1e-6) ? (hv * d) / sqrt(1.0 - hv2) : squad.y1;\n    \n    // 4. transform (xu, yv, z0) to world coords\n    return squad.o + xu*squad.x + yv*squad.y + squad.z0*squad.z;\n}\n\n// Sample generation\n////////////////////\n\nfloat Halton(int index, float base)\n{\n    float result = 0.0;\n    float f = 1.0/base;\n    float i = float(index);\n    for (int x = 0; x < 8; x++)\n    {\n        if (i <= 0.0) break;\n\n        result += f*mod(i, base);\n        i = floor(i/base);\n        f = f/base;\n    }\n\n    return result;\n}\n\nvoid Halton2D(out vec2 s[NUM_SAMPLES], int offset)\n{\n    for (int i = 0; i < NUM_SAMPLES; i++)\n    {\n        s[i].x = Halton(i + offset, 2.0);\n        s[i].y = Halton(i + offset, 3.0);\n    }\n}\n\n// Adapted from:\n// https://www.shadertoy.com/view/4djSRW\nfloat hash(float x, float y)\n{\n    vec2 p = vec2(x, y);\n    p  = fract(p * vec2(443.8975, 397.2973));\n    p += dot(p.xy, p.yx + 19.19);\n    return fract(p.x + p.y);\n}\n\n// Camera functions\n///////////////////\n\nRay GenerateCameraRay(float u1, float u2,vec2 uv)\n{\n    Ray ray;\n\n    // Random jitter within pixel for AA\n    vec2 xy = 2.0*(uv)/iResolution .xy- vec2(1.0);\n\n    ray.dir = normalize(vec3(xy, 2.0));\n\n    float focalDistance = 2.0;\n    float ft = focalDistance/ray.dir.z;\n    vec3 pFocus = ray.dir*ft;\n\n    ray.origin = vec3(0);\n    ray.dir    = normalize(pFocus - ray.origin);\n\n    // Apply camera transform\n    ray.origin = (view*vec4(ray.origin, 1)).xyz;\n    ray.dir    = (view*vec4(ray.dir,    0)).xyz;\n\n    return ray;\n}\n\nvec3 mul(mat3 m, vec3 v)\n{\n    return m * v;\n}\n\nmat3 mul(mat3 m1, mat3 m2)\n{\n    return m1 * m2;\n}\n\nint modi(int x, int y)\n{\n    return int(mod(float(x), float(y)));\n}\n\nmat3 transpose(mat3 v)\n{\n    mat3 tmp;\n    tmp[0] = vec3(v[0].x, v[1].x, v[2].x);\n    tmp[1] = vec3(v[0].y, v[1].y, v[2].y);\n    tmp[2] = vec3(v[0].z, v[1].z, v[2].z);\n\n    return tmp;\n}\n\n// Linearly Transformed Cosines\n///////////////////////////////\n\nfloat IntegrateEdge(vec3 v1, vec3 v2)\n{\n    float cosTheta = dot(v1, v2);\n    cosTheta = clamp(cosTheta, -0.9999, 0.9999);\n\n    float theta = acos(cosTheta);    \n    float res = cross(v1, v2).z * theta / sin(theta);\n\n    return res;\n}\n\nvoid ClipQuadToHorizon(inout vec3 L[5], out int n)\n{\n    // detect clipping config\n    int config = 0;\n    if (L[0].z > 0.0) config += 1;\n    if (L[1].z > 0.0) config += 2;\n    if (L[2].z > 0.0) config += 4;\n    if (L[3].z > 0.0) config += 8;\n\n    // clip\n    n = 0;\n\n    if (config == 0)\n    {\n        // clip all\n    }\n    else if (config == 1) // V1 clip V2 V3 V4\n    {\n        n = 3;\n        L[1] = -L[1].z * L[0] + L[0].z * L[1];\n        L[2] = -L[3].z * L[0] + L[0].z * L[3];\n    }\n    else if (config == 2) // V2 clip V1 V3 V4\n    {\n        n = 3;\n        L[0] = -L[0].z * L[1] + L[1].z * L[0];\n        L[2] = -L[2].z * L[1] + L[1].z * L[2];\n    }\n    else if (config == 3) // V1 V2 clip V3 V4\n    {\n        n = 4;\n        L[2] = -L[2].z * L[1] + L[1].z * L[2];\n        L[3] = -L[3].z * L[0] + L[0].z * L[3];\n    }\n    else if (config == 4) // V3 clip V1 V2 V4\n    {\n        n = 3;\n        L[0] = -L[3].z * L[2] + L[2].z * L[3];\n        L[1] = -L[1].z * L[2] + L[2].z * L[1];\n    }\n    else if (config == 5) // V1 V3 clip V2 V4) impossible\n    {\n        n = 0;\n    }\n    else if (config == 6) // V2 V3 clip V1 V4\n    {\n        n = 4;\n        L[0] = -L[0].z * L[1] + L[1].z * L[0];\n        L[3] = -L[3].z * L[2] + L[2].z * L[3];\n    }\n    else if (config == 7) // V1 V2 V3 clip V4\n    {\n        n = 5;\n        L[4] = -L[3].z * L[0] + L[0].z * L[3];\n        L[3] = -L[3].z * L[2] + L[2].z * L[3];\n    }\n    else if (config == 8) // V4 clip V1 V2 V3\n    {\n        n = 3;\n        L[0] = -L[0].z * L[3] + L[3].z * L[0];\n        L[1] = -L[2].z * L[3] + L[3].z * L[2];\n        L[2] =  L[3];\n    }\n    else if (config == 9) // V1 V4 clip V2 V3\n    {\n        n = 4;\n        L[1] = -L[1].z * L[0] + L[0].z * L[1];\n        L[2] = -L[2].z * L[3] + L[3].z * L[2];\n    }\n    else if (config == 10) // V2 V4 clip V1 V3) impossible\n    {\n        n = 0;\n    }\n    else if (config == 11) // V1 V2 V4 clip V3\n    {\n        n = 5;\n        L[4] = L[3];\n        L[3] = -L[2].z * L[3] + L[3].z * L[2];\n        L[2] = -L[2].z * L[1] + L[1].z * L[2];\n    }\n    else if (config == 12) // V3 V4 clip V1 V2\n    {\n        n = 4;\n        L[1] = -L[1].z * L[2] + L[2].z * L[1];\n        L[0] = -L[0].z * L[3] + L[3].z * L[0];\n    }\n    else if (config == 13) // V1 V3 V4 clip V2\n    {\n        n = 5;\n        L[4] = L[3];\n        L[3] = L[2];\n        L[2] = -L[1].z * L[2] + L[2].z * L[1];\n        L[1] = -L[1].z * L[0] + L[0].z * L[1];\n    }\n    else if (config == 14) // V2 V3 V4 clip V1\n    {\n        n = 5;\n        L[4] = -L[0].z * L[3] + L[3].z * L[0];\n        L[0] = -L[0].z * L[1] + L[1].z * L[0];\n    }\n    else if (config == 15) // V1 V2 V3 V4\n    {\n        n = 4;\n    }\n    \n    if (n == 3)\n        L[3] = L[0];\n    if (n == 4)\n        L[4] = L[0];\n}\n\n\nvec3 LTC_Evaluate(\n    vec3 N, vec3 V, vec3 P, mat3 Minv, vec3 points[4], bool twoSided)\n{\n    // construct orthonormal basis around N\n    vec3 T1, T2;\n    T1 = normalize(V - N*dot(V, N));\n    T2 = cross(N, T1);\n\n    // rotate area light in (T1, T2, R) basis\n    Minv = mul(Minv, transpose(mat3(T1, T2, N)));\n\n    // polygon (allocate 5 vertices for clipping)\n    vec3 L[5];\n    L[0] = mul(Minv, points[0] - P);\n    L[1] = mul(Minv, points[1] - P);\n    L[2] = mul(Minv, points[2] - P);\n    L[3] = mul(Minv, points[3] - P);\n\n    int n;\n    ClipQuadToHorizon(L, n);\n    \n    if (n == 0)\n        return vec3(0, 0, 0);\n\n    // project onto sphere\n    L[0] = normalize(L[0]);\n    L[1] = normalize(L[1]);\n    L[2] = normalize(L[2]);\n    L[3] = normalize(L[3]);\n    L[4] = normalize(L[4]);\n\n    // integrate\n    float sum = 0.0;\n\n    sum += IntegrateEdge(L[0], L[1]);\n    sum += IntegrateEdge(L[1], L[2]);\n    sum += IntegrateEdge(L[2], L[3]);\n    if (n >= 4)\n        sum += IntegrateEdge(L[3], L[4]);\n    if (n == 5)\n        sum += IntegrateEdge(L[4], L[0]);\n\n    sum = twoSided ? abs(sum) : max(0.0, -sum);\n\n    vec3 Lo_i = vec3(sum, sum, sum);\n\n    return Lo_i;\n}\n\n\n// Misc. helpers\n////////////////\n\nfloat saturate(float v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\nvec3 PowVec3(vec3 v, float p)\n{\n    return vec3(pow(v.x, p), pow(v.y, p), pow(v.z, p));\n}\n\nconst float gamma = 0.1;\n\nvec3 ToLinear(vec3 v) { return PowVec3(v,     gamma); }\nvec3 ToSRGB(vec3 v)   { return PowVec3(v, 1.0/gamma); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 seq[NUM_SAMPLES];\n    Halton2D(seq, sampleCount);\n\n    vec3 col = vec3(0);\n\n    width = iTime * 0.1+cos(iTime+fragCoord.y*0.01)*5.;\n    intensity = iTime *0.1;\n    \n    // Scene info\n    Rect rect;\n    vec3 rectNormal = vec3(0, -cos(iTime+cos(fragCoord.y*iTime*0.1)*0.1), -1.+abs(sin(iTime))*0.95);\n    rect.origin = vec3(0, cos(iTime*0.9)*3., 32);\n    rect.plane  = vec4(rectNormal, -dot(rectNormal, rect.origin));\n    rect.sizex  = width;\n    rect.sizey  = height;\n\n    vec4 plane = vec4(cos(iTime)*0.2, iTime*0.1, 0,iTime*0.2);\n\n    vec3 lcol = vec3(intensity);\n    vec3 dcol = ToLinear(dcolor);\n    vec3 scol = ToLinear(scolor);\n\n        Ray ray = GenerateCameraRay(0.0, 0.0, fragCoord);\n\n        float distToFloor;\n        bool hitFloor = RayPlaneIntersect(ray, plane, distToFloor);\n        if (hitFloor)\n        {\n            vec3 pos = ray.origin + ray.dir*distToFloor;\n\n            vec3 N = plane.xyz;\n            vec3 V = -ray.dir;\n\n            vec3 ex = vec3(1, 0, 0)*rect.sizex;\n            vec3 ey = vec3(0, 1, 0)*rect.sizey;\n    \n            vec3 p1 = rect.origin - ex + ey;\n            vec3 p2 = rect.origin + ex + ey;\n            vec3 p3 = rect.origin + ex - ey;\n            vec3 p4 = rect.origin - ex - ey;\n            \n            vec3 points[4];\n            points[0] = p1;\n            points[1] = p2;\n            points[2] = p3;\n            points[3] = p4;\n            \n            float theta = acos(dot(N, V));\n            vec2 uv = vec2(roughness, theta/(0.5*pi));\n            uv = uv*LUT_SCALE + LUT_BIAS;\n            \n\t\t\tvec4 tt;\n            \n            tt = texture(iChannel0, fragCoord);\n            \n            mat3 Minv = mat3(\n                vec3(  1,   0, tt.y),\n                vec3(  0, tt.z,   0),\n                vec3(tt.y,   0, tt.x)\n            );\n            \n            vec3 spec = lcol*scol*LTC_Evaluate(N, V, pos, Minv, points, false);\n            spec *= texture(iChannel1, uv).r;\n            \n            vec3 diff = lcol*dcol*LTC_Evaluate(N, V, pos, mat3(1), points, false); \n            \n            col  = spec + diff;\n            col /= 2.0*pi;\n        }\n\n        float distToRect;\n        if (RayRectIntersect(ray, rect, distToRect))\n            if ((distToRect < distToFloor) || !hitFloor)\n                col = lcol;\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}