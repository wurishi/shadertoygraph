{"ver":"0.1","info":{"id":"Dsj3Rh","date":"1669886014","viewed":67,"name":"Hello World shaders","username":"daniluciocobo","description":"Hello World","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["university"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord.xy-0.5),0).rgba;\n    \n    \n    data.rgb *= 1.0/data.a;\n    \n    //output to screen\n    fragColor = vec4(pow(data.rgb,vec3(1.0 / 2.2)),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//void mainImage( out vec4 fragColor, in vec2 fragCoord )\n//{\n//    fragColor = vec4(0.0,0.0,1.0,1.0);\n//}\n\nfloat t=0.0;\nfloat hit=0.0;\nvec3 ro=vec3(0.0,0.0,2.0);\n\nint i;\nvec3 p;\nfloat d_sphere;\nvec3 c=vec3(0.0,0.0,0.0);\nfloat r=1.0;\nfloat d;\nfloat hp=-1.0;\nbool hit2;\nvec3 p_trans;\nfloat d_plane;\n//float sdTorus;\nfloat d_Torus;\nvec2 t_tor=vec2(0.2,0.1);\nvec2 dist;\nvec3 diffuse_color;\nfloat pi=3.141517;\nint MAX_BOUNCES=20;\n \n    \n\n float sdTorus( vec3 p, vec2 t )\n    {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec2 sdf_scene(vec3 p){\n    d_sphere= length(p-c)-r; \n    p_trans=p;p_trans.x-=0.5;p_trans.y-=1.0;\n    p_trans = p_trans.xzy;\n    d_Torus=sdTorus(p_trans,t_tor); \n    d_plane= p.y-hp; \n    d=min(d_Torus,d_sphere);\n    d=min(d,d_plane);\n    if(d_plane == d) return vec2(d, 0.0);\n    else return vec2(d, 1.0);\n    \n\n}\n\n\nvec2 cast_ray(vec3 ray_origin, vec3 ray_direction){\n    hit=0.0;\n    t = 0.0;\n    for(i=0; i< 210;i++){\n    p = ray_origin+t*ray_direction;\n    dist=vec2(sdf_scene(p));\n    \n    if(dist[0]<0.0005 && dist[1]==1.0){\n    hit=1.0;\n    break;\n    }\n    if(dist[0]<0.0005 && dist[1]==0.0){  //to saw the plane descommit this\n    hit=2.0;\n    break;\n    }\n    \n    t=t+d;\n    }\n    vec2 f=vec2(t,hit);\n    return f;\n}\nvec3 calculate_normal(vec3 p)\n{\n\nvec2 e = vec2(0.001, 0.0);\nreturn normalize(vec3(sdf_scene(p + e.xyy)[0] - sdf_scene(p - e.xyy)[0],\nsdf_scene(p + e.yxy)[0] - sdf_scene(p - e.yxy)[0],\nsdf_scene(p + e.yyx)[0] - sdf_scene(p - e.yyx)[0]));\n}\n\nfloat pdf(vec3 next_direction, vec3 p_normal){\nvec3 n=calculate_normal(next_direction);\nfloat pdf_result=max(dot(p_normal,n),0.0)/(pi);\nreturn pdf_result;\n}\n\nvec4 fotograma_calc(vec3 current_color,vec2 fragCoord){\n \n    if(iFrame >=2 && iMouse.z < 0.0 ){\n    \n    vec4 old_data = texelFetch(iChannel0, ivec2(fragCoord - 0.5), 0);\n    vec4 fotogramaColor = old_data + vec4(current_color,1.0);\n    return fotogramaColor;\n    }\n    else{\n    vec4 fotogramaColor=vec4(current_color,1.0);\n    return fotogramaColor;\n   }\n\n}\n\nuvec4 pcg4d(inout uvec4 v){\n//random Generator\nv = v * 1664525u + 1013904223u;\nv += v.yzxy*v.wxyz;\nv ^= v >> 16u;\nv += v.yzxy*v.wxyz;\nreturn v;\n\n}\n\nmat3 create_tangent_space(vec3 normal){\nconst float one_over_sqrt_3 = 1.0 / sqrt(3.0);\nvec3 major;\nif(abs(normal.x)< one_over_sqrt_3) major = vec3(1,0,0);\nelse if(abs(normal.y)< one_over_sqrt_3) major = vec3(0,1,0);\nelse major = vec3(0,0,1);\n\nvec3 tangent = normalize(cross(normal,major));\nvec3 bitangent = cross(normal,tangent);\n\nreturn mat3(tangent, bitangent, normal);\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect_ratio=iResolution.x/iResolution.y;\n    \n    // Rescale x and y to a range between -1 and 1 and set z to -1\n    vec3 raydir = vec3(uv * 2.f - 1.f, -1.0);\n    \n    // Scale the x-axis by the aspect ratio\n    raydir.x *= aspect_ratio;\n    // Normalize the ray direction\n    raydir = normalize(raydir);\n    //SDF\n    vec3 rd=raydir;\n    vec3 lightDir=vec3(0,1,1);\n    float gamma= 1.0/(2.2);\n      \n    \n    //vec2 funct2=vec2(cast_ray(p_intersection+p_normal*0.01,lightDir));\n    \n    \n    //seed Generator\n    uvec4 seed = uvec4(fragCoord.xy, iFrame, 0);\n    //rand generator\n    vec4 rand = vec4(pcg4d(seed))/float(0xffffffffu);\n    \n    \n    //for ?? \n    vec3 color = vec3(0,0,0);\n    vec3 attenuation = vec3(1,1,1);\n    for(int bounce = 0; bounce < MAX_BOUNCES; bounce++){\n\n\n        vec2 funct1=vec2(cast_ray(ro,rd));\n        vec3 p_intersection=ro+funct1.x*rd;\n        vec3 p_normal=calculate_normal(p_intersection);\n        vec3 next_direction;\n\n        if(funct1.y!=0.0){\n            vec3 albedo=vec3(0,0,0);\n            if(funct1[1]==1.0){\n                albedo=vec3(0.36,0.76,0.72); //albedo=diffuse_color\n                next_direction = create_tangent_space(p_normal)*vec3(sqrt(rand.x)*cos(2.0*pi*rand.y),sqrt(rand.x)*sin(2.0*pi*rand.y),sqrt(1.0-rand.x));\n                //vec3 current_color = max(dot(p_normal, lightDir), 0.0) * diffuse_color;\n                //fragColor = vec4(color,1);\n                //fragColor= fotograma_calc(current_color,fragCoord);\n\n            }\n            else if(funct1[1]==2.0){\n                albedo=vec3(0.5,0.72,0.45);\n                //vec3 current_color = max(dot(p_normal, lightDir), 0.0) * diffuse_color;\n                //fragColor= fotograma_calc(current_color,fragCoord);\n                //fragColor = vec4(color,1);\n                \n                vec3 reflect_col=reflect(rd,p_normal);\n                 next_direction=reflect_col;\n\n            }\n            albedo = vec3(albedo) / pi;\n            \n            vec3 point=ro+rd*funct1[0];\n            vec3 sun_dist= normalize(vec3(0.5,1,1));\n            vec2 funct2=cast_ray(point+p_normal*0.01,sun_dist);\n            if(funct2[1]==0.0){\n                color+= attenuation * albedo * vec3(0.57,0.73,0.51) * max(dot(sun_dist, p_normal), 0.0);\n                \n            }\n            //vec3 color += attenuation * 0\n            rand = vec4(pcg4d(seed))/float(0xffffffffu);\n            //vec3 next_direction = create_tangent_space(p_normal)*vec3(sqrt(rand.x)*cos(2.0*pi*rand.y),sqrt(rand.x)*sin(2.0*pi*rand.y),sqrt(1.0-rand.x));\n            \n            //attenuation *= albedo/pi;\n             //attenuation *= abs(dot(next_direction, p_normal));\n             //attenuation /= pdf(next_direction,p_normal);\n             attenuation *= vec3(albedo) / pi;\n             \n            ro= p_intersection+p_normal*0.01 ;\n            rd = normalize(next_direction);\n            color += attenuation * albedo; \n        }\n        else{\n        vec3 envmap_color = texture(iChannel1, rd).rgb;\n        vec3 envmap_color_gamma = vec3(pow(envmap_color.x,gamma),pow(envmap_color.y,gamma),pow(envmap_color.z,gamma));\n            color += attenuation * vec3(envmap_color_gamma) ;//read_environment_map(rd);\n            break;\n        }\n    }\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord.xy-0.5),0).rgba;\n    fragColor =data+ vec4(color,1);\n    \n   \n    \n//??\n    \n    // Output to screen\n   // if(funct1[1]==1.0){\n   // diffuse_color=vec3(0.36,0.76,0.72);\n   //\n    //vec3 current_color = max(dot(p_normal, lightDir), 0.0) * diffuse_color;\n    //fragColor = vec4(color,1);\n    //fragColor= fotograma_calc(current_color,fragCoord);\n    \n    //}\n    \n    //else if(funct1[1]==2.0){\n    //diffuse_color=vec3(0.5,0.72,0.45);\n    //vec3 current_color = max(dot(p_normal, lightDir), 0.0) * diffuse_color;\n    //fragColor= fotograma_calc(current_color,fragCoord);\n    //fragColor = vec4(color,1);\n\n    //}\n    \n    //else if(funct2[1]!=0.0){\n    //vec3 current_color=vec3(0,0,0);\n    //fragColor=vec4(0,0,0,0);\n    //}\n    \n    //else{\n    //vec3 current_color=vec3(1,1,1);\n    //fragColor= fotograma_calc(current_color,fragCoord);\n    //fragColor = vec4(1,1,1,0);\n    //}\n    \n   \n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}","name":"Cube A","description":"","type":"cubemap"}]}