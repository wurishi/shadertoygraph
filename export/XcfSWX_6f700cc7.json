{"ver":"0.1","info":{"id":"XcfSWX","date":"1705767903","viewed":118,"name":"COD Heartbeat Sensor","username":"xTyler73","description":"Heartbeat sensor from Call of Duty: Modern Warfare 2 (the first one)\n\nYou can change some of the variables in the defines at the top of the code.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["radar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ss(a, b, t) smoothstep(a, b, t)\n#define sat(x) clamp(x, 0., 1.)\n\n#define PULSE_FREQ  3.0 /* [0.01, n]  - How often to send out a heartbeat pulse, in seconds */\n#define CAMPERS     0.8 /* [0.0, 1.0] - 0.0 means they have marathon/lightweight pro, 1.0 means their controller batteries died, 0.8 means somewhere in between */\n#define MAP_SIZE    0.8 /* [0.8, 2.0] - 0.8 means Rust, 2.0 means Derail */\n#define NUM_ENEMIES 9   /* [0, n]     - 1 means cage match, 6 TDM etc, 9 ground war, 99 fortnite. None of the enemies have ninja as their third perk */\n\n\nfloat N21(vec2 p) {\n    p = fract(p*vec2(1337.42, 420.007));\n    p += dot(p, p+42.808);\n    return fract(p.x*p.y);\n}\n\nvec2 N22(vec2 p) {\n    float noise = N21(p);\n    return vec2(noise, N21(p+noise));\n}\n\nvec2 getPos(vec2 id, float t) {\n    vec2 noise = N22(id);\n    \n    float steppedTime = floor(t/PULSE_FREQ) * PULSE_FREQ;  // keep enemy move speed consistent regardless of pulse freq\n    float movement = steppedTime*(1.-CAMPERS)/MAP_SIZE*.4; // keep enemy move speed consistent regardless of map size\n    movement += 144.; // in case CAMPERS is 1\n    \n    float x = cos(movement*(noise.x+.1));\n    float y = cos(movement*(noise.y+.1)); // these +.1 in case noise is close to 0\n    \n    x = x*pow(abs(x),.2); // bias towards 0 (center) a bit\n    y = (abs(y)-.2)*1.25; // bias up\n   \n    return vec2(x, y)*MAP_SIZE;\n}\n\nvec3 enemy(vec2 uv, vec2 p, float inPulse) {\n    vec3 r = vec3(0.95, 0.05, 0.05);\n    vec3 w = vec3(.9, .65, .65);\n    \n    float topMask = step(.0166, p.y); // bit more than 0 looks nicer\n        \n    float d = length(uv-p);\n    float bright = pow(sat(1.1-length(p)), .9);\n\n    float enemy = ss(.05, 1., .02/d)*1.2;\n    \n    float tNorm = mod(iTime, PULSE_FREQ)/PULSE_FREQ;    \n    float decayLerp = mix(.5, .75, length(p));\n    float decay = ss(decayLerp+.125, decayLerp, tNorm);\n    \n    return enemy*mix(r, (r+w)*.9, enemy) * bright * inPulse * decay * topMask;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy-vec2(0.5,0.06)*iResolution.xy)/iResolution.y;\n    float t = iTime;\n        \n    float upDistort = .04;\n    uv *= .82-(uv.y*upDistort);\n    \n    float d = min(length(uv), .7);\n    float circles = sin(d*10.4*3.);\n    float lastCircle = step(.6, d)*.04;\n    circles = ss(.97-lastCircle, 1.-lastCircle, circles) + ss(-.97, -1., circles)*.5;\n    \n    float topMask = ss(.01, .02, uv.y);\n    float boxMask = ss(.467, .464, abs(uv.x));\n    \n    float btmHalfFill = ss(.047, .044, d) * ss(0.001, -0.001, uv.y) * .56;\n    float centerDot = ss(.02, .015, length(uv));\n    \n    float diag = ss(.008, .005, abs(abs(uv.x) - uv.y*.95));\n    float vert = ss(.008, .005, abs(uv.x));\n    float linesCutoff = ss(.655, .643, d);\n    \n    vec3 lightBlueBG = (vec3(63.-N21(uv)*5., 118.-N21(uv+1.)*5., 130.-N21(uv+2.)*5.)/255.) - (1.-d)*.08;\n    vec3 lightBlueLines = vec3(0.580, 0.855, 0.863); // RGB: 148, 218, 220\n    \n    float firstCircleMask = step(d, .1);\n    float circlesMask = circles*boxMask*sat(topMask + firstCircleMask);\n    \n    vec3 col = lightBlueBG;\n    col = mix(col, lightBlueLines, circlesMask);\n    col = mix(col, lightBlueLines, btmHalfFill); \n    col = mix(col, lightBlueLines, diag * linesCutoff);\n    col = mix(col, lightBlueLines, vert * linesCutoff * topMask * .5); \n    col += centerDot;\n    \n    \n    // pulse:\n    vec2 uv_pulse = vec2(uv.x*.9, uv.y);\n    vec3 blue = vec3(0.4, 0.5, 0.9);\n    float tNorm = mod(t, PULSE_FREQ)/PULSE_FREQ;\n    float r = tNorm * 4.; // go beyond as the waiting period\n    \n    float d1 = ss(0.024, .03, length(uv_pulse)-r); // outer\n    float d2 = ss(-.021, .02, length(uv_pulse*1.05)-(r*1.05)); // inner, keep width consistent at larger dists\n    \n    float bright = (ss(.6, 0.1, abs(uv_pulse.x))*.6+.4) * ss(1., .8, length(uv_pulse));\n    float diff = d2-d1;\n    col += diff*blue*bright * topMask;\n    \n    \n    for (int i = 1; i <= NUM_ENEMIES; ++i) { // start at 1 to avoid calling noise with a 0\n        vec2 p = getPos(vec2(i), t);\n        vec3 e = enemy(uv, p, 1.-d1);\n        col += e*ss(-.8, 1., 1.-circlesMask); // avoid super bright on the lines, especially where fading\n    }\n    \n    vec2 uv_corners = (fragCoord/iResolution.xy) * 2.;\n    uv_corners = fract(uv_corners) - step(1., uv_corners);\n    float corners = sat((pow(.03/(length(uv_corners)+.2), .1)-.7)*1.5);\n    col += corners*lightBlueLines;\n    \n    float scan = pow(sat(abs(tan(uv.y-(t*.4))*.03)), 2.5);\n    col += scan*lightBlueLines*0.05;\n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}