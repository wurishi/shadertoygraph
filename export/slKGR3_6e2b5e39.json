{"ver":"0.1","info":{"id":"slKGR3","date":"1638115271","viewed":139,"name":"Burning Ship + Mandelbrot Set","username":"Spi3lot","description":"Burning Ship + Mandelbrot Set","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["fractal","mandelbrot","burning","burningship","ship"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITERATIONS clamp(iFrame, 60, 3600)\n#define ICON_POS vec2(0.583, 0.37)\n\n// 0... Mandelbrot Set\n// 1... Burning Ship\n// 2... Chirikov Map (not working yet)\n#define FRACTAL 0\n#define SHOW_WHERE_YOU_ZOOM_AT false\n\n\nint iterations(vec2 c) {\n    vec2 z = vec2(0, 0);\n    \n    // Temporary variables (not really necessary but they improve the overview)\n    #if FRACTAL != 2\n    float z_a;\n    float z_b;\n    #endif\n\n    //for (int i = 0; i < MAX_ITERATIONS; i++) {\n    for (int i = 1; i <= MAX_ITERATIONS; i++) {\n        // dot(z, z) = z.x * z.x + z.y * z.y\n        if (dot(z, z) > 4.0)\n            return 0xFFFFFF / i;\n            // return i;\n\n        #if FRACTAL == 0\n        z_a = z.x * z.x - z.y * z.y;\n        z_b = 2.0 * z.x * z.y;\n        z = c + vec2(z_a, z_b);\n\n        #elif FRACTAL == 1\n        z_a = z.x * z.x - z.y * z.y;\n        z_b = 2.0 * abs(z.x * z.y);\n        z = c + vec2(z_a, z_b);\n\n        #elif FRACTAL == 2\n        z.y += c.y * sin(z.x);\n        z.x += c.x * z.y;\n\n        #endif\n    }\n\n    return 0;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 mandelCoord = 0.5 + fragCoord / iResolution.x;\n    vec2 mandelMouse = iMouse.xy / iResolution.x;\n\n    vec2 mouse = (iMouse.xy == vec2(0)) ? ICON_POS : iMouse.xy / iResolution.xy;\n\n    vec2 c;\n     \n    if (SHOW_WHERE_YOU_ZOOM_AT && iMouse.z > 0.0) {\n        c = mix(mini, maxi, mandelCoord - vec2(0.5, 0.25));\n\n    } else {\n        vec4 mini_maxi = zoom(iTime, complexFromPixel(mouse, mini, maxi));\n\n        mini = mini_maxi.xy;\n        maxi = mini_maxi.zw;\n\n        //c = mini + (maxi - mini) * (mandelCoord - mandelMouse);\n        c = mix(mini, maxi, mandelCoord - mandelMouse);\n    }\n\n    int iter = iterations(c);\n\n    //float shade = float(iter) / float(MAX_ITERATIONS);\n    //fragColor = vec4(shade, shade, shade, 1.0);\n\n    fragColor = rgba(\n        iter>>8 & 0xFF,\n        iter>>4 & 0xFF,\n        iter>>2 & 0xFF,\n        255\n    );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#ifdef GL_ES\nprecision highp float;\n#endif\n\n\n/*TODO: STORE IN BUFFER*/\nvec2 mini = vec2(-4, 4);\nvec2 maxi = vec2(4, -4);\n/**/\n\nvec4 rgba(int r, int g, int b, int a) {\n    return vec4(r, g, b, a) / 255.0;\n}\n\n\nvec2 complexFromPixel(vec2 px, vec2 mini, vec2 maxi) {\n    //return mini + px * (maxi - mini);\n    return mix(mini, maxi, px);\n}\n\nvec4 zoom(float level, vec2 point) {\n    float zoom = exp2(-level);\n\n    vec2 mini = mix(point, mini, zoom);\n    vec2 maxi = mix(point, maxi, zoom);\n  \n    return vec4(mini, maxi);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// TODO: STORE mini AND maxi IN BUFFER\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n}\n","name":"Buffer A","description":"","type":"buffer"}]}