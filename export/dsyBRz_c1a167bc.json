{"ver":"0.1","info":{"id":"dsyBRz","date":"1697943572","viewed":107,"name":"Rasterized triangle","username":"dimitr","description":"Rasterize triangle on canvas, using modified DDA algorithm for line segments.\nHeavy calculations for large triangles ;)","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["triangle","rasterization","canvas"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 lineColor = vec4(1.0f, 0.0f, 0.0f, 1.0f);\n    vec4 mouseColor = vec4(0.0f, 0.8f, 0.2f, 1.0f);\n    \n    vec2 a = vec2(55.5f * ENLARGED_CELL_SIZE.x, 35.5f * ENLARGED_CELL_SIZE.y);\n    vec2 b = vec2(75.5f * ENLARGED_CELL_SIZE.x, 35.5f * ENLARGED_CELL_SIZE.y);\n    //vec2 c = vec2(50.5f * ENLARGED_CELL_SIZE.x, 65.5f * ENLARGED_CELL_SIZE.y);\n    vec2 c = iMouse.xy;\n\n    vec4 mouseCell = getCell(iMouse.xy);\n    vec4 curCell = getCell(fragCoord);\n    float insideCell = isCellPixel(fragCoord);\n    float insideMouseCell = vecEqual(mouseCell.xy, curCell.xy);\n    vec4 insideMouseCellColor = insideMouseCell * mouseColor;\n    float insideTriangleCell = isTrianglePixel(fragCoord, a, b, c);\n    vec4 triangleColor = insideTriangleCell * lineColor;\n    float colorized = float(insideTriangleCell + insideMouseCell > 0.0f);\n    vec4 color = insideMouseCell * mouseColor +  (1.0f - insideMouseCell) * insideTriangleCell * lineColor;\n    vec4 finalColor = colorized * color + (1.0f - colorized) * CANVAS_COLOR;\n    fragColor = finalColor * insideCell + (1.0f - insideCell) * GAP_COLOR;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const vec4 CANVAS_COLOR = vec4(0.4f, 0.4f, 0.4f, 1.0f);\nconst vec2 CELL_SIZE = vec2(5.0f, 5.0f);\n\nconst vec4 GAP_COLOR = vec4(0.0f, 0.0f, 0.0f, 1.0f);\nconst vec2 GAP_SIZE = vec2(1.0f, 1.0f);\n\nconst vec2 ENLARGED_CELL_SIZE = CELL_SIZE + GAP_SIZE;\n\nfloat vecEqual(vec2 v0, vec2 v1)\n{\n    vec2 v = v1 - v0;\n    float vDist = dot(v, v);\n    return float(vDist < 0.01f);\n}\n\nvec4 getCell( vec2 pixelFragCoord )\n{\n    vec2 fullCell = CELL_SIZE + GAP_SIZE;\n    vec2 cellIdx = floor(pixelFragCoord / fullCell);\n    vec4 cellBounds = vec4(0.0f, 0.0f, 1.0f, 1.0f); // just spaceholder\n    cellBounds.x = cellIdx.x * fullCell.x;\n    cellBounds.y = cellIdx.y * fullCell.y;\n    cellBounds.z = cellBounds.x + fullCell.x;\n    cellBounds.w = cellBounds.y + fullCell.y;\n    return cellBounds;\n}\n\nfloat isCellPixel( vec2 pixelFragCoord )\n{\n    vec4 cell = getCell(pixelFragCoord);\n    float insideCell = float(!(pixelFragCoord.x >= cell.z - GAP_SIZE.x || pixelFragCoord.y >= cell.w - GAP_SIZE.y));\n    return insideCell;\n}\n\nfloat isLinePixel (vec2 pixelFragCoord, vec2 startCell, vec2 stopCell)\n{\n    // DDA\n    vec4 pixelCell = getCell(pixelFragCoord);\n    vec2 cellCenter = pixelCell.xy + CELL_SIZE * 0.5f;\n    vec2 v = (stopCell - startCell) / (CELL_SIZE + GAP_SIZE);\n    vec2 startCenter = startCell + CELL_SIZE * 0.5f;\n    vec2 stopCenter = stopCell + CELL_SIZE * 0.5f;\n    float insideLine = 0.0f;\n    vec2 enlargedStep = CELL_SIZE + GAP_SIZE;\n\n    if (abs(v.x) < 0.001f && abs(v.y) < 0.001f)\n    {\n        // just point\n        return vecEqual(pixelCell.xy, startCell);\n    }\n    if (abs(v.x) > abs(v.y))\n    {\n        // use tanQ\n        float tanQ = v.y / v.x;\n        float steps = floor(abs(v.x));\n        float stepSign = v.x / abs(v.x);\n        for (float i = 0.0f; i < steps + 0.001f; i += 1.0f)\n        {\n            float curX = i * enlargedStep.x * stepSign - GAP_SIZE.x * stepSign;\n            float curY = curX * tanQ;\n            vec2 curCoord = vec2(startCenter.x + curX, startCenter.y + curY);\n            vec4 curCell = getCell(curCoord);\n            insideLine += vecEqual(curCell.xy, pixelCell.xy);\n        }\n    }\n    else {\n        // use cotanQ\n        float cotanQ = v.x / v.y;\n        float steps = floor(abs(v.y));\n        float stepSign = v.y / abs(v.y);\n        for (float i = 0.0f; i < steps + 0.001f; i += 1.0f)\n        {\n            float curY = i * enlargedStep.y * stepSign - GAP_SIZE.y * stepSign;\n            float curX = curY * cotanQ;\n            vec2 curCoord = vec2(startCenter.x + curX, startCenter.y + curY);\n            vec4 curCell = getCell(curCoord);\n            insideLine += vecEqual(curCell.xy, pixelCell.xy);\n        }\n    }\n    return insideLine;\n}\n\nvec2 getLineCell(vec2 startCell, vec2 stopCell, float curStep)\n{\n    // DDA\n    vec2 v = (stopCell - startCell) / (CELL_SIZE + GAP_SIZE);\n    vec2 startCenter = startCell + CELL_SIZE * 0.5f;\n    vec2 stopCenter = stopCell + CELL_SIZE * 0.5f;\n    vec2 enlargedStep = CELL_SIZE + GAP_SIZE;\n\n    if (abs(v.x) < 0.001f && abs(v.y) < 0.001f)\n    {\n        // just point, return start cell in all cases\n        return startCell;\n    }\n    if (abs(v.x) > abs(v.y))\n    {\n        // use tanQ\n        float tanQ = v.y / v.x;\n        float steps = floor(abs(v.x));\n        float stepSign = v.x / abs(v.x);\n        if (curStep > steps)\n        {\n            curStep = steps - 1.0f;\n        }\n        float curX = curStep * enlargedStep.x * stepSign - GAP_SIZE.x * stepSign;\n        float curY = curX * tanQ;\n        vec2 curCoord = vec2(startCenter.x + curX, startCenter.y + curY);\n        vec4 curCell = getCell(curCoord);\n        return curCell.xy;\n    }\n    else {\n        // use cotanQ\n        float cotanQ = v.x / v.y;\n        float steps = floor(abs(v.y));\n        if (curStep > steps)\n        {\n            curStep = steps - 1.0f;\n        }\n        float stepSign = v.y / abs(v.y);\n        float curY = curStep * enlargedStep.y * stepSign - GAP_SIZE.y * stepSign;\n        float curX = curY * cotanQ;\n        vec2 curCoord = vec2(startCenter.x + curX, startCenter.y + curY);\n        vec4 curCell = getCell(curCoord);\n        return curCell.xy;\n    }\n}\n\nfloat isHorizontalLinePixel (vec2 pixelFragCoord, vec2 startCell, vec2 stopCell)\n{\n    vec4 pixelCell = getCell(pixelFragCoord);\n    if (startCell.x > stopCell.x)\n    {\n        vec2 tmp = startCell;\n        startCell = stopCell;\n        stopCell = tmp;\n    }\n    float inX = float(pixelCell.x >= startCell.x && pixelCell.x <= stopCell.x);\n    float inY = float(abs(pixelCell.y - startCell.y) < 0.001f);\n    return inX * inY;\n}\n\nfloat isAnglePixel(vec2 pixelFragCoord, vec2 a, vec2 b, vec2 c)\n{\n    // choose first point as common\n    vec2 ab = b - a;\n    vec2 ac = c - a;\n    ab = abs(ab);\n    ac = abs(ac);\n    vec2 ec = ENLARGED_CELL_SIZE;\n    float abSteps = ab.x > ab.y ? ab.x / ec.x : ab.y / ec.y;\n    float acSteps = ac.x > ac.y ? ac.x / ec.x : ac.y / ec.y;\n    float abCurStep = 0.0f;\n    float acCurStep = 0.0f;\n    vec2 abCell = getLineCell(a, b, 0.0f);\n    vec2 acCell = getLineCell(a, c, 0.0f);\n    vec2 abNextCell = abCell;\n    vec2 acNextCell = acCell;\n    float minDif = ec.y * 0.5f;\n    float insideAngle = 0.0f;\n    abSteps += 1.0f;\n    acSteps += 1.0f;\n    while (abCurStep < abSteps && acCurStep < acSteps)\n    {\n        while (abCurStep < abSteps && abs(abNextCell.y - abCell.y) < minDif)\n        {\n            abCurStep += 1.0f;\n            abNextCell = getLineCell(a, b, abCurStep);\n        }\n        while (acCurStep < acSteps && abs(acNextCell.y - acCell.y) < minDif)\n        {\n            acCurStep += 1.0f;\n            acNextCell = getLineCell(a, c, acCurStep);\n        }\n        if (abCurStep < abSteps && acCurStep < acSteps) \n        {\n            insideAngle += isHorizontalLinePixel(pixelFragCoord, abNextCell, acNextCell);\n            abCell = abNextCell;\n            acCell = acNextCell;\n        }\n    }\n    return float(insideAngle > 0.0f);\n}\n\nfloat isTrianglePixel(vec2 pixelFragCoord, vec2 a, vec2 b, vec2 c) \n{\n    // convert to precise cell\n    vec4 aCell = getCell(a);\n    vec4 bCell = getCell(b);\n    vec4 cCell = getCell(c);\n    a = aCell.xy;\n    b = bCell.xy;\n    c = cCell.xy;\n    float insideTriangle = 0.0f;\n    // use variation of DDA\n    // expensive check from each angle\n    insideTriangle += isAnglePixel(pixelFragCoord, a, b, c);\n    insideTriangle += isAnglePixel(pixelFragCoord, b, a, c);\n    insideTriangle += isAnglePixel(pixelFragCoord, c, a, b);\n    // draw boundaries\n    insideTriangle += isLinePixel(pixelFragCoord, a, b);\n    insideTriangle += isLinePixel(pixelFragCoord, a, c);\n    insideTriangle += isLinePixel(pixelFragCoord, b, c);\n    return float(insideTriangle > 0.001f);\n}\n","name":"Common","description":"","type":"common"}]}