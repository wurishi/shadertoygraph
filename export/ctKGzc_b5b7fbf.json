{"ver":"0.1","info":{"id":"ctKGzc","date":"1684366278","viewed":65,"name":"Distance between line segments","username":"jozxyqk","description":"Testing different functions to compute the closest distance between two line segments.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["distance","linesegment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Pyarelal Knowles 2023\n\n\n// https://www.shadertoy.com/view/tslXRj\n// Seems to work in most cases but doesn't quite handle points behind the ray\nfloat RayLineSegmentDistance(vec3 rP, vec3 rD, vec3 lS, vec3 lE)\n{\n\tfloat bL = length(lE-lS);\n\tvec3 bD = (lE-lS)/bL;\n\tvec3 tD = lS-rP;\n\tfloat aDb = dot(rD,bD);\n\tfloat aDt = dot(rD,tD);\n\tfloat bDt = dot(bD,tD);\n\tfloat u = (aDt-bDt*aDb)/(1.-aDb*aDb);\n\tfloat v = max(min(u*aDb-bDt,bL),0.);\n\tu = max(min(v*aDb+aDt,1e6),0.);\n\treturn length((rP+rD*u)-(lS+bD*v));\n}\n\n// My attempt\n// Extended from https://math.stackexchange.com/a/4347294/91472\n// and taking ideas from https://zalo.github.io/blog/closest-point-between-segments/\n// I hope this can be celaned up. Ping-ponging scalar projection feels wrong.\nfloat rayLineSegmentDistance(vec3 r0, vec3 rd, vec3 l0, vec3 l1)\n{\n    vec3 ld = l1 - l0; // line direction\n    vec3 od = l0 - r0; // ray origin to line origin\n\n    float rr = dot(rd, rd);\n    float ll = dot(ld, ld);\n    float rl = dot(rd, ld);\n    float denom = rl * rl - rr * ll;\n    \n    float ro = dot(rd, od);\n    float lo = dot(ld, od);\n    \n    // closest point on ray, r0 + rd * s\n    // I chose to ignore this as clamping t along the segment renders it useless\n    //float s = (rl * lo - ro * ll) / denom;\n    \n    // closest point on line, l0 + ld * t\n    float t = -(rl * ro - lo * rr) / denom;\n    \n    // clamp t to the line segment\n    t = clamp(t, 0.0, 1.0);\n    \n    // closest point on line segment\n    vec3 lc = l0 + ld * t;\n    \n    // project the line closest point to the ray\n    float s = dot(lc - r0, rd) / dot(rd, rd);\n    \n    // clamp to a positive ray direction\n    s = max(s, 0.0);\n    \n    // closest point on the ray\n    vec3 rc = r0 + rd * s;\n    \n    // project back again as clamping s may affect t\n    t = dot(rc - l0, ld) / dot(ld, ld);\n    \n    // clamp t again and recompute lc\n    t = clamp(t, 0.0, 1.0);\n    lc = l0 + ld * t;\n    \n    // return the distance\n    return length(rc - lc);\n}\n\n// https://math.stackexchange.com/a/4289668/91472\n// Just clamping s and t doesn't work\nfloat rayLineSegmentDistance2(vec3 r0, vec3 rd, vec3 l0, vec3 l1)\n   {\n    vec3 p1 = r0;\n    vec3 p2 = r0 + rd * 100.0;\n    vec3 p3 = l0;\n    vec3 p4 = l1;\n   \n    vec3 P1 = p1;\n    vec3 P2 = p3;\n    vec3 V1 = p2 - p1;\n    vec3 V2 = p4 - p3;\n    vec3 V21 = P2 - P1;\n\n    float v22 = dot(V2, V2);\n    float v11 = dot(V1, V1);\n    float v21 = dot(V2, V1);\n    float v21_1 = dot(V21, V1);\n    float v21_2 = dot(V21, V2);\n    float denom = v21 * v21 - v22 * v11;\n\n    float s = (v21_2 * v21 - v22 * v21_1) / denom;\n    float t = (-v21_1 * v21 + v11 * v21_2) / denom;\n\n    s = max(min(s, 1.), 0.);\n    t = max(min(t, 1.), 0.);\n\n    vec3 p_a = P1 + s * V1;\n    vec3 p_b = P2 + t * V2;\n\n    return length(p_a - p_b);\n}\n\n// https://zalo.github.io/blog/closest-point-between-segments/\n// This looks cool, but doesn't work. Maybe I messed up the conversion?\nvec3 constrainToSegment(vec3 position, vec3 a, vec3 b) {\n    vec3 ba = b - a;\n    float t = dot(position - a, ba) / dot(ba, ba);\n    return mix(a, b, clamp(t, 0.0, 1.0));\n}\nfloat rayLineSegmentDistance3(vec3 r0, vec3 rd, vec3 l0, vec3 l1)\n{\n    vec3 segA = r0;\n    vec3 segB = r0 + rd * 100.0;\n    vec3 segC = l0;\n    vec3 segD = l1;\n    vec3 segDC = segD-segC;\n    float lineDirSqrMag = dot(segDC, segDC);\n    vec3 inPlaneA = segA-((dot(segA-segC, segDC)/lineDirSqrMag)*segDC);\n    vec3 inPlaneB = segB-((dot(segB-segC, segDC)/lineDirSqrMag)*segDC);\n    vec3 inPlaneBA = inPlaneB-inPlaneA;\n    float denom = dot(inPlaneBA, inPlaneBA);\n    float t = dot(segC-inPlaneA, inPlaneBA)/denom;\n    t = denom > 1e-6 ? t : 0.0; // Zero's t if parallel\n    vec3 segABtoLineCD = mix(segA, segB, clamp(t, 0.0, 1.0));\n    vec3 segCDtoSegAB = constrainToSegment(segABtoLineCD, segC, segD);\n    vec3 segABtoSegCD = constrainToSegment(segCDtoSegAB, segA, segB);\n    return length(segABtoSegCD);\n}\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Projection\n    vec3 rayPosition = vec3(0.0);\n    vec2 center = fragCoord.xy - iResolution.xy * 0.5;\n    vec3 rayTarget = vec3((center / iResolution.y) * 2.0, 2.0f);\n    vec3 rayDir = normalize(rayTarget - rayPosition);\n    \n    // Camera\n    vec3 orbitPos = vec3(0.0, 0.0, 1.0);\n    mat3 camera = rotateY(iMouse.x * 0.01) * rotateX(iMouse.y * 0.01);\n    vec3 osDir = camera * rayDir;\n    vec3 osPos = -camera * orbitPos;\n    \n    vec3 l0 = vec3(0.1);\n    vec3 l1 = vec3(0.8);\n    float d0 = RayLineSegmentDistance(osPos, osDir, l0, l1);\n    float d1 = rayLineSegmentDistance(osPos, osDir, l0, l1);\n    float d2 = rayLineSegmentDistance2(osPos, osDir, l0, l1);\n    float d3 = rayLineSegmentDistance3(osPos, osDir, l0, l1);\n    \n    float c = 1.0 - d1 * 10.0;\n    \n    fragColor = vec4(c, c, c, 1.0);\n}","name":"Image","description":"","type":"image"}]}