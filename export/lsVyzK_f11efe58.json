{"ver":"0.1","info":{"id":"lsVyzK","date":"1588529159","viewed":195,"name":"4d voxel raytracing","username":"Azorlogh","description":"experimental method of rendering a 4D voxel world by drawing opposing rotated slices as red and green","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["4d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\n\n\n// THIS IS NOT MY CODE\n//////////////////////////////////////////////////////////////\n//\tSimplex 4D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nfloat permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nfloat taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec4 grad4(float j, vec4 ip){const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);vec4 p,s;p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;p.w = 1.5 - dot(abs(p.xyz), ones.xyz);s = vec4(lessThan(p, vec4(0.0)));p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;return p;}float snoise(vec4 v){const vec2  C = vec2( 0.138196601125010504,0.309016994374947451);vec4 i  = floor(v + dot(v, C.yyyy) );vec4 x0 = v -   i + dot(i, C.xxxx);vec4 i0;vec3 isX = step( x0.yzw, x0.xxx );vec3 isYZ = step( x0.zww, x0.yyz );i0.x = isX.x + isX.y + isX.z;i0.yzw = 1.0 - isX;i0.y += isYZ.x + isYZ.y;i0.zw += 1.0 - isYZ.xy;i0.z += isYZ.z;i0.w += 1.0 - isYZ.z;vec4 i3 = clamp( i0, 0.0, 1.0 );vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );vec4 x1 = x0 - i1 + 1.0 * C.xxxx;vec4 x2 = x0 - i2 + 2.0 * C.xxxx;vec4 x3 = x0 - i3 + 3.0 * C.xxxx;vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;i = mod(i, 289.0);float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);vec4 j1 = permute( permute( permute( permute (i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))+ i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))+ i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))+ i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;vec4 p0 = grad4(j0,   ip);vec4 p1 = grad4(j1.x, ip);vec4 p2 = grad4(j1.y, ip);vec4 p3 = grad4(j1.z, ip);vec4 p4 = grad4(j1.w, ip);vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));p0 *= norm.x;p1 *= norm.y;p2 *= norm.z;p3 *= norm.w;p4 *= taylorInvSqrt(dot(p4,p4));vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);m0 = m0 * m0;m1 = m1 * m1;return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))+ dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;}\n//\n//////////////////////////////////////////////////////////////\n\n#define normalize(a) normalize(a+1e-5) \n\nvec4 rotateXY(vec4 v, float a) {float c = cos(a), s = sin(a);return mat4(c, s, 0, 0,-s, c, 0, 0,0, 0, 1, 0,0, 0, 0, 1)*v;}\nvec4 rotateXZ(vec4 v, float a) {float c = cos(a), s = sin(a);return mat4(c, 0, s, 0,0, 1, 0, 0,-s, 0, c, 0,0, 0, 0, 1)*v;}\nvec4 rotateXW(vec4 v, float a) {float c = cos(a), s = sin(a);return mat4(c, 0, 0, s,0, 1, 0, 0,0, 0, 1, 0,-s, 0, 0, c)*v;}\nvec4 rotateYZ(vec4 v, float a) {float c = cos(a), s = sin(a);return mat4(1, 0, 0, 0,0, c, s, 0,0, -s, c, 0,0, 0, 0, 1)*v;}\nvec4 rotateYW(vec4 v, float a) {float c = cos(a), s = sin(a);return mat4(1, 0, 0, 0,0, c, 0, s,0, 0, 1, 0,0, -s, 0, c)*v;}\nvec4 rotateZW(vec4 v, float a) {float c = cos(a), s = sin(a);return mat4(1, 0, 0, 0,0, 1, 0, 0,0, 0, c, s,0, 0, -s, c)*v;}\n\n\nfloat sdTorus( vec4 p, vec2 t )\n{\n  vec3 q = vec3(length(p.xw)-t.x, p.y, p.z);\n  return length(q)-t.y;\n}\n\n\nfloat terrain(vec4 pos) {\n    return snoise(pos*2.);\n    //return .5-length(pos-.5);\n    //return -sdTorus(pos-.5, vec2(.4,.2));\n}\n\nfloat intersection(vec4 b0, vec4 b1, vec4 ro, vec4 rid) {\n    float tx1 = (b0.x - ro.x)*rid.x;\n    float tx2 = (b1.x - ro.x)*rid.x;\n    float tmin = min(tx1, tx2);\n    float tmax = max(tx1, tx2);\n    float ty1 = (b0.y - ro.y)*rid.y;\n    float ty2 = (b1.y - ro.y)*rid.y;\n    tmin = max(tmin, min(ty1, ty2));\n    tmax = min(tmax, max(ty1, ty2));\n    float tz1 = (b0.z - ro.z)*rid.z;\n    float tz2 = (b1.z - ro.z)*rid.z;\n    tmin = max(tmin, min(tz1, tz2));\n    tmax = min(tmax, max(tz1, tz2));\n    float tw1 = (b0.w - ro.w)*rid.w;\n    float tw2 = (b1.w - ro.w)*rid.w;\n    tmin = max(tmin, min(tw1, tw2));\n    tmax = min(tmax, max(tw1, tw2));\n    return (tmax >= tmin && tmin > 0.) ? tmin : -1.;\n}\n\nvec4 computeNormal(vec4 inter, vec4 center) {\n  vec4 a = inter - center;\n  a = abs(a);\n  return vec4(greaterThanEqual(a.xyzw, max(a.yzwx, max(a.zwxy, a.wxyz))));\n}\n\n#define GRID_SIZE 16.\n\nvec4 trace(vec4 ro, vec4 rd, inout float t) {\n    vec4 rid = 1./rd;\n    if (ro != clamp(ro, 0., 1.)) {\n        float tmin = intersection(vec4(0), vec4(1), ro, rid);\n        if (tmin == -1.) {return vec4(0.);}\n        ro = ro + rd*(tmin+1e-4);\n        t += tmin;\n    }\n    vec4 grid = floor( ro*GRID_SIZE );\n    vec4 grid_step = sign( rd );\n\tvec4 corner = max( grid_step, vec4(0) );\n\n    vec4 inv = vec4( 1.0 ) / rd;\n\tvec4 ratio = ( grid + corner - ro*GRID_SIZE ) * inv;\n\tvec4 ratio_step = grid_step * inv;\n\n    vec4 mask = computeNormal(ro, vec4(.5));\n\n    for (int i=0; i<32; i++) {\n        if (grid != clamp(grid, 0., GRID_SIZE-1.)) {return vec4(0.);}\n        if (terrain(vec4(grid)/GRID_SIZE) > 0.) {\n            t += dot( ratio - ratio_step, mask )/GRID_SIZE;\n            return mask*grid_step;\n        }\n        \n        mask = vec4(lessThanEqual(ratio.xyzw,min(ratio.yzwx, min(ratio.zwxy, ratio.wxyz))));\n\t\tgrid  += grid_step  * mask;\n\t\tratio += ratio_step * mask;\n    }\n    return vec4(0.);\n}\n\nvec4 sunDir = normalize(vec4(4,8,6,7));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 pos = (fragCoord - iResolution.xy/2.) / (iResolution.y/2.);\n\n   \tfloat time=3.8+cos(iTime)*.5;\n    \n    vec4 ro = vec4(cos(time)*1.5+.5,1.5,sin(time)*1.5+.5,cos(iTime)*.4+.5);\n    vec4 rd = normalize(vec4(pos, 1, 0));\n    rd = rotateYZ(rd, .3);\n    rd = rotateXZ(rd, time+3.14/2.);\n\n    vec3 col = vec3(0);\n    \n    for (int i=-1; i<=1; i++) {\n        float t=0.0;\n    \tvec4 normal = trace(ro+vec4(0,0,0,i)*.1, rd, t);\n    \tif (length(normal) != .0) {\n        \tfloat d = clamp(dot(normal, sunDir), 0., 1.);\n        \tcol += vec3(d) * (vec3(i>=0 ? 1./float(i*2+1) : 0., -i>=0 ? 1./float(-i*2+1) : 0., i==0 ? 1 : 0));\n    \t}\n    }\n    \n    fragColor = vec4(col, 1);\n}\n","name":"Image","description":"","type":"image"}]}