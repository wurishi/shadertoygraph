{"ver":"0.1","info":{"id":"dsXGR2","date":"1672426998","viewed":191,"name":"Bezier Extrusion Spline w/ Norms","username":"myth0genesis","description":"Just punting my analytic solution to normals with a Bezier spline extrusion of a 3D box. It's not by any means perfect; there are still discontinuities and the normals at the adjoining point have a bit of a bump. Sorry for the mess!","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["3d","d","bezier","normals","spline","curve","normal","analytic","3","3dimensional","extrude","dimensional","extrusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2022 myth0genesis\n\n#define AA 2\n\nconst int maxstps = 100;\nconst float maxdst = 100.0;\nconst float mindst = 0.001;\nconst float pi = 3.1415927410125732421875;\nconst float tau = 6.283185482025146484375;\nconst float i3 = 1.0 / 3.0;\nconst float sqrt3 = sqrt(3.0);\nvec3 strtpnt;\nvec3 ctrl0;\nvec3 ctrl1;\nvec3 midpnt;\nvec3 endpnt;\n\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2( c, s,\n                -s, c);\n}\n\n// iq's implementation: https://www.shadertoy.com/view/DdlGD8\nvec4 sdBezier(vec3 pos, vec3 A, vec3 B, vec3 C) {    \n    vec3 a = B - A;\n    vec3 b = A - 2.0 * B + C;\n    vec3 c = a * 2.0;\n    vec3 d = A - pos;\n\n    float kk = 1.0 / dot(b, b);\n    float kx = kk * dot(a, b);\n    float ky = kk * (2.0 * dot(a, a) + dot(d, b)) / 3.0;\n    float kz = kk * dot(d, a);      \n\n    vec4 res;\n\n    float p  = ky - kx * kx;\n    float q  = kx * (2.0 * kx * kx - 3.0 * ky) + kz;\n    float p3 = p * p * p;\n    float q2 = q * q;\n    float h  = q2 + 4.0 * p3;\n    float t;\n    float t0;\n    vec2 t1;\n\n    if(h >= 0.0) {   \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n\n        if(abs(p) < 0.15) {\n            float k = (1.0-p3/q2)*p3/q;\n            x = vec2(k, -k - q);\n        }\n        \n        vec2 uv = sign(x) * pow(abs(x), vec2(1.0 / 3.0));\n        t0 = clamp(uv.x + uv.y - kx, 0.0, 1.0);\n        vec3  q = d + (c + b * t0) * t0;\n        res = vec4(dot(q, q), q);\n        t = t0;\n    } else {   \n        float z = sqrt(-p);\n        float v = acos(q / (p * z * 2.0)) / 3.0;\n        float m = cos(v);\n        float n = sin(v) * 1.732050808;\n        t1 = clamp(vec2(m + m, -n - m) * z - kx, 0.0, 1.0);\n        vec3 qx = d + (c + b * t1.x) * t1.x;\n        float dx = dot(qx, qx);\n        vec3 qy = d + (c + b * t1.y) * t1.y;\n        float dy = dot(qy, qy);\n        res = (dx < dy) ? vec4(dx, qx) : vec4(dy, qy);\n        t = (dx < dy) ? t1.x : t1.y;\n    }\n    \n    res.x = sqrt(res.x);\n    res.yzw /= -res.x;\n    \n    return vec4(t, res.yzw);\n}\n\nvec4 sdgBox(in vec3 p, in vec3 b, mat3 bmm) {\n    vec3 bn = bmm[0];\n    vec3 n = bmm[1];\n    vec3 t = bmm[2];\n    vec3 w = abs(p)-b;\n    vec3 s = 2.0 * ceil(0.5 * sign(p)) - 1.0;\n    \n    \n    float g = max(max(w.x,w.y), w.z);\n\tvec3  q = max(w,0.0);\n    float l = length(q);\n    vec4 grad = (g > 0.0) ? vec4(l, normalize(max(w, 0.0))) :\n        vec4(g, step(w.yzx, w.xyz) * step(w.zxy, w.xyz));\n    grad.yzw = -(s * grad.yzw) * transpose(bmm);\n    return grad;\n}\n\n// Del's method for extruding along a Bezier curve: https://www.shadertoy.com/view/7dyBz3\nvec4 sdBezierExtrude(vec3 pos, vec3 A, vec3 B, vec3 C, out vec3 n, out mat3 bmm) {\n    vec4 t = sdBezier(pos, A, B, C);\n    \n    vec3 _tan = normalize((2.0 - 2.0 * t.x) * (B - A) + 2.0 * t.x * (C - B));\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 forward = vec3(0.0, 0.0, 1.0);\n    vec3 right = vec3(1.0, 0.0, 0.0);\n    vec3 binormal = normalize(cross(up, _tan));\n    vec3 _normal = cross(_tan, binormal);\n    mat3 mm = mat3(binormal, _normal, _tan);\n    pos.xyz = mix(mix(A, B, t.x), mix(B, C, t.x), t.x) - pos;\n    bmm = mm;\n    return vec4(pos.xyz * mm, t.x);\n}\n\nvec4 map(in vec3 pos) {\n    vec3 norm0;\n    mat3 bmm0;\n    vec4 bz0 = sdBezierExtrude(pos, strtpnt, ctrl0, midpnt, norm0, bmm0);\n    vec3 norm1;\n    mat3 bmm1;\n    vec4 bz1 = sdBezierExtrude(pos, midpnt, ctrl1, endpnt, norm1, bmm1);\n    \n    vec4 dst0 = sdgBox(bz0.xyz, vec3(1.0, 0.2, 0.01), bmm0);\n    vec4 dst1 = sdgBox(bz1.xyz, vec3(1.0, 0.2, 0.01), bmm1);\n    vec4 dst = (dst0.x < dst1.x) ? dst0 : dst1;\n    \n    return vec4((dst.x - 0.05), dst.yzw);\n}\n\nvec2 getLight(vec3 p, vec3 rd, vec3 n, vec3 lightPos) {\n\tvec3 l = normalize(lightPos - p);\n\tfloat a = 0.4;\n\tfloat difdot = dot(n, l);\n    float dif = mix(a, 1.0, difdot);\n    float pspec = clamp(dot(-rd, normalize(reflect(-l, n))), 0.0, 1.0);\n    pspec = pspec * pspec * pspec;\n    float spec = step(-difdot, 0.0) * pspec;\n\treturn vec2(dif, spec);\n}\n\nvec4 rayMarch(vec3 ro, vec3 rd) {\n\tfloat dO = 0.0;\n    vec4 res;\n    \n    for(int i = 0; i < maxstps; i++) {\n    \tvec3 p = ro + rd * dO;\n        res = map(p);\n        float dS = res.x;\n        dO += dS;\n        if(dO > maxdst || abs(dS) < mindst) break;\n    }\n    \n    return vec4(dO, res.yzw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float tm = iTime;\n    strtpnt = sin(tm * vec3(1.148, 1.043, 0.857) + vec3(1.573, 2.883, 0.968)) * 1.25 + vec3(-8.0, 0.0, 0.0);\n    endpnt = sin(tm  * vec3(0.817, 1.155, 0.973)+ vec3(0.847, 3.856, 4.227)) * 1.25 + vec3(8.0, 0.0, 0.0);\n    ctrl0 = sin(tm * vec3(1.174, 0.889, 1.035) + vec3(1.827, 2.111, 1.842)) * 1.25 + vec3(-3.75, 0.0, 0.0);\n    ctrl1 = sin(tm * vec3(1.021, 0.937, 0.879) + vec3(5.558, 6.013, 3.289)) * 1.25 + vec3(3.75, 0.0, 0.0);\n    midpnt = 0.5 * (ctrl0 + ctrl1);\n\tvec2 m = iMouse.xy/ iResolution.xy;\n    vec3 ro = vec3(0.0, 7.0, -12.0);\n    mat2 rmxz = rot(m.x * tau);\n    mat2 rmyz = rot(m.y * tau + pi);\n    ro.yz *= rmyz;\n    ro.xz *= rmxz;\n    vec3 lp = normalize(vec3(1.0, 1.0, 0.0)) * 50.0;\n    lp.yz *= rmyz;\n    lp.xz *= rmxz;\n    vec3 col = vec3(0.0);\n    \n    for(int x = 0; x < AA; x++) {\n        for(int y = 0; y < AA; y++) {\n            vec2 offs = vec2(x, y)/float(AA) -.5;\n            vec2 uv = (fragCoord + offs - 0.5 * iResolution.xy) / iResolution.y;\n            vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n            rd.yz *= rot(-0.5);\n            rd.yz *= rmyz;\n            rd.xz *= rmxz;\n            \n            vec4 res = rayMarch(ro, rd);\n            \n            if(res.x < maxdst) {\n                vec3 p = ro + rd * res.x;\n                \n                vec3 n = res.yzw;\n                vec2 difspec = getLight(p, rd, n, lp);\n                col += difspec.x * vec3(0.4, 0.0, 0.8) + difspec.y * vec3(1.0);\n            }\n        }\n    }\n    \n    col /= float(AA * AA);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}