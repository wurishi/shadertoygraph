{"ver":"0.1","info":{"id":"3sjcDV","date":"1587363334","viewed":615,"name":"Rainbow Temple - 277 chars","username":"GregRostami","description":"All credits goes to @yosshin4004.\nhttps://twitter.com/yosshin4004/status/1251357672504360966\nThis is a fork of vahidk's Infinite Tunnel.\nI just LOVE the shadows!\n\nA BIG thanks to Fabrice for helping me reduce the original shader.","likes":17,"published":3,"flags":64,"usePreview":0,"tags":["raymarching","2tweets","short","golf","infinitetunnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Ml23WW","filepath":"https://soundcloud.com/filipnikolaevic/jean-michel-jarre-oxygen-8-magnetik-rmx","previewfilepath":"https://soundcloud.com/filipnikolaevic/jean-michel-jarre-oxygen-8-magnetik-rmx","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Infinite Tunnel\" by vahidk. https://shadertoy.com/view/tdSyDG\n// 2020-04-20 06:00:14\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    vec3  R = iResolution,\n          d = vec3((U+U-R.xy)/R.y, 1),\n          q, p=R-R;\n    for (p.z = .1*iTime; R.z++ < 1e2;\n         p += .5*d * min( .65-length(fract(p+.5)-.5), p.y + .3) )\n         R.z==65. ? q = p -= d*.01, d += 1.-d : q;\n    ivec3 u = ivec3(q*5e2) & 255;\n    O = vec4( u.yzx ^ u.zxy, 0) / 1e3\n        * (length(p-q)+.8) + p.z*.1-.01*iTime;\n}\n\n// 263 chars - Thanks to Fabrice, everything gets shorter!!\n/*\n#define mainImage(O,U)                                            \\\n    vec3  R = iResolution,                                        \\\n          d = vec3((U+U-R.xy)/R.y, 1),                            \\\n          q, p=R-R;                                               \\\n    for (p.z = .1*iTime; O.a++ < 99.;                             \\\n         p += .5*d * min( .65-length(fract(p+.5)-.5), p.y + .3) ) \\\n         O.a==65. ? q = p -= d*.01, d += 1.-d : q;                \\\n    ivec3 u = ivec3(q*5e2) & 255;                                 \\\n    O = vec4( u.yzx ^ u.zxy, 0) / 1e3                             \\\n        * (length(p-q)+.8) + p.z*.1-.01*iTime\n\n\n// 259 chars - Shortest version, but I don't like the floor.\n\n#define mainImage(O,U)                                            \\\n    vec3  R = iResolution,                                        \\\n          d = vec3((U+U-R.xy)/R.y, 1),                            \\\n          q, p=R-R;                                               \\\n    for (p.z = .1*iTime; O.a++ < 99.;                             \\\n         p += .5*d * min( .65-length(fract(p+.5)-.5), p.y + .3) ) \\\n         O.a==65. ? q = p -= d*.01, d += 1.-d : q;                \\\n    ivec3 u = ivec3(q*5e2) & 255;                                 \\\n    O = vec4( u ^ u.zxy, 0) / 1e3                             \\\n        * (length(p-q)+.9) + p.z*.1-.01*iTime\n\n\n// 278 chars - Greg's Original Fork\n\n#define mainImage(O,U)                                                           \\\n    vec3 R = iResolution, d = vec3((U+U-R.xy)/R.y, 1), q, p=d-d; p.z = iTime*.1; \\\n    for (int i=0; i++<99; p += .5*d* min( .65-length(fract(p+.5)-.5), p.y + .3)) \\\n        i==60 ? q = p -= d*.01, d += 1.-d : q;                                   \\\n    ivec3 u = ivec3(q*5e2) & 255;                                                \\\n    O = vec4(u.x^u.y,u.y^u.z,u.x^u.z,0)/2e3 * (length(p-q)+.9) + (p.z-iTime*.1)*.1\n*/","name":"Image","description":"","type":"image"}]}