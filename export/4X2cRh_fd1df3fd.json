{"ver":"0.1","info":{"id":"4X2cRh","date":"1730507073","viewed":121,"name":"Echo: Boulder","username":"pyBlob","description":"Collection of boulder groups for [url=https://www.shadertoy.com/playlist/cXj3DV]Echo Arena[/url].","likes":12,"published":3,"flags":32,"usePreview":0,"tags":["echo","reproduction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Echo Playlist: https://www.shadertoy.com/playlist/cXj3DV\n//\n// The goal is to reconstruct a 3D video game from a screen capture.\n// This shader draws some of the boulder groups found in that game.\n\nfloat boulder(vec3 x, mat3 R);\n\nconst float r45 = sqrt(2.) / 2.;\nconst mat3\n    v1 = mat3(1,0,0, 0,1,0, 0,0,1),\n    vx = mat3(0,-1,0, 1,0,0, 0,0,1),\n    vz = mat3(1,0,0, 0,0,1, 0,-1,0),\n    dy = mat3(r45,0,-r45, 0,1,0, r45,0,r45),\n    dz = mat3(1,0,0, 0,0,-1, 0,1,0) * mat3(r45,0,-r45, 0,1,0, r45,0,r45),\n    vl = mat3(r45,r45,0, -r45,r45,0, 0,0,1),\n    vr = mat3(r45,-r45,0, r45,r45,0, 0,0,1);\n\nmat3 R; mat2x3 drd; vec3 ro, rd; float r, i;\nstruct Hit { float t, u, v, mat, d; vec3 q, v0, v1, v2, n; } hit;\nvoid norm1(inout vec3 r, inout mat2x3 dr);\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    ro = vec3(cos(iTime / 3.) * 1.4, 1.5, -4.);\n    //ro = vec3(0, 1.1, -3);\n\n    vec3 look = vec3(0, 0, 0);\n    vec3 fw = normalize(look - ro);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(up, fw));\n    up = cross(fw, right);\n    rd = vec3(fragCoord - iResolution.xy / 2., iResolution.y);\n    drd = mat2x3(1, 0, 0, 0, 1, 0);\n    norm1(rd, drd);\n    R = mat3(right, up, fw);\n    rd = R * rd;\n    drd = R * drd;\n\n    R = mat3(1);\n    float a = sin(iTime) * -.5;\n    R = mat3(vec3(cos(a),-sin(a),0), vec3(sin(a),cos(a),0), vec3(0,0,1));\n    R = mat3(vec3(cos(a),0,-sin(a)), vec3(0,1,0), vec3(sin(a),0,cos(a)));\n    ro = ro * R;\n    rd = rd * R;\n    drd = transpose(R) * drd;\n\n    hit.t = 1e10;\n    hit.mat = 0.;\n    \n    r = smoothstep(.02, .1, abs(fract(iTime / 5.) - .5));\n    i = mod(round(iTime / 5.), 5.);\n    if (i == 0.)\n        boulder(vec3(0), v1);\n    if (i == 1.)\n        r *= .73,\n        boulder(vec3(0, 1, 0), dz),\n        boulder(vec3(0, -1, 0), dz);\n    if (i == 2.)\n        boulder(vec3(-r45, 0, 0), vl),\n        boulder(vec3(r45, 0, 0), vr);\n    if (i == 3.)\n        boulder(vec3(.97, 0, 0), vx),\n        boulder(vec3(-.97, 0, 0), vx);\n    if (i == 4.)\n        boulder(vec3(-3, 0, 0), vx),\n        boulder(vec3(-2, -1, 0), v1),\n        boulder(vec3(3, 0, 0), vx),\n        boulder(vec3(2, -1, 0), v1);\n\n    vec3 col = vec3(0, .02, .1);\n    if (hit.mat == 1.)\n    {\n        vec2 f = vec2(iResolution.y / iResolution.x, 1);\n\n        vec2 dd = - hit.d * hit.d * (hit.n * drd);\n        mat2x3 dq = mat2x3(cross(hit.v0, drd[0]), cross(hit.v0, drd[1]));\n        vec2 du = dd * dot(-hit.q, hit.v2) - hit.d * hit.v2 * dq;\n        vec2 dv = dd * dot( hit.q, hit.v1) + hit.d * hit.v1 * dq;\n        hit.u = (hit.u + hit.v / 2.) * sqrt(2.);\n        du = (du + dv / 2.) * sqrt(2.);\n        vec2 px = vec2(du.x, dv.x);\n        vec2 py = vec2(du.y, dv.y);\n        col = textureGrad(iChannel0, vec2(hit.u, hit.v) * f, px * f, py * f).rgb;\n    }\n\n    fragColor = vec4(sqrt(col), 1);\n}\n\nvoid record(Hit _hit)\n{\n    if (_hit.t > 0. && _hit.t < hit.t)\n        hit = _hit;\n}\n\nvoid tri(vec3 x, mat3 R, vec3 v0, vec3 v1, vec3 v2)\n{\n    // https://iquilezles.org/articles/intersectors/\n    v1 = R * (v1 - v0);\n    v2 = R * (v2 - v0);\n    v0 = ro - (R * v0 + x);\n    vec3  n = cross(v1, v2);\n    vec3  q = cross(v0, rd);\n    float d = 1.0 / dot(rd, n);\n    float u = d*dot(-q, v2);\n    float v = d*dot( q, v1);\n    float t = d*dot(-n, v0);\n    // if( u<0.0 || v<0.0 || (u+v)>1.0 ) t = -1.0;\n    // return vec3(t, u, v);\n    t = u>0.0 && v>0.0 && (u+v)<1.0 ? t : -1.0;\n    record(Hit(t, u, v, 1., d, q, v0, v1, v2, n));\n}\n\nfloat boulder(vec3 x, mat3 R)\n{\n    R *= r;\n    tri(x, R, vec3(-1, 0, -1), vec3( 1, 0, -1), vec3(0,  1, 0));\n    tri(x, R, vec3( 1, 0, -1), vec3( 1, 0,  1), vec3(0,  1, 0));\n    tri(x, R, vec3( 1, 0,  1), vec3(-1, 0,  1), vec3(0,  1, 0));\n    tri(x, R, vec3(-1, 0,  1), vec3(-1, 0, -1), vec3(0,  1, 0));\n    tri(x, R, vec3(-1, 0, -1), vec3( 1, 0, -1), vec3(0, -1, 0));\n    tri(x, R, vec3( 1, 0, -1), vec3( 1, 0,  1), vec3(0, -1, 0));\n    tri(x, R, vec3( 1, 0,  1), vec3(-1, 0,  1), vec3(0, -1, 0));\n    tri(x, R, vec3(-1, 0,  1), vec3(-1, 0, -1), vec3(0, -1, 0));\n    return 0.;\n}\n\nvoid norm1(inout vec3 r, inout mat2x3 dr)\n{\n    float f = length(r);\n    r /= f;\n    dr /= f;\n    dr -= mat2x3(r * dot(dr[0], r), r * dot(dr[1], r));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    float v = fragCoord.y / iResolution.y;\n    float u = fragCoord.x / iResolution.y / sqrt(2.) - v / 2.;\n\n    vec3 col;\n    vec3 x = mat3(2, 0, 0, 1, 1, 1, -1, 0, -1) * vec3(u, v, 1);\n    x = abs(x);\n    float a = max(x.x, x.z);\n    float b = min(x.x, x.z);\n    col = mix(vec3(0,.06,.15), vec3(0,0,.01), clamp(length(x-vec3(0,0,.3)), 0., .85));\n    if (.05 < x.y && .09 < a-b && (u+v) < 1. && u>0. && (abs(x.y-.49) < .01 || x.y < .07 || a-b < .13 || abs(a+b-.93) < .02))\n        col = vec3(.1, .6, 1);\n\n    fragColor = vec4(col, 1);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}