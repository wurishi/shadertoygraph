{"ver":"0.1","info":{"id":"DdtfDX","date":"1699955210","viewed":88,"name":"Lighter","username":"mefisto","description":"point light with SSAO, PBR, PBS, IBL, soft shadows","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["pointlight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926538\n\nfloat METALLNESS = .2;\nfloat ROUGTHNESS = .5;\nfloat ALBEDO = 1.;\nfloat LIGHTER_HEIGHT = .6;\nfloat LIGHTER_SIZE = 10.;\nfloat SCALE = 2.;\nfloat BUMP_SCALE = 10.;\n\nfloat get_texture(vec2 xy)\n{\n\treturn texture(iChannel0, SCALE * xy/ iResolution.xy).r;\n}\n\nvec3 calculate_normal(vec2 fragCoord)\n{\n    float c = get_texture(fragCoord);\n    float cy = get_texture(fragCoord + vec2(0,-1));\n\tfloat cx = get_texture(fragCoord + vec2(1,0));\n    \n    float dx = (c - cx) * BUMP_SCALE;\n    float dy = (c - cy) * BUMP_SCALE;\n    \n    return normalize(vec3(dy, dx, 1.));\n}\n\nfloat GGX_Distribution(float cosThetaNH)\n{\n    float roug_sqr = ROUGTHNESS * ROUGTHNESS;\n    float alpha2 = roug_sqr * roug_sqr;\n    float NH_sqr = clamp(cosThetaNH * cosThetaNH, 0., 1.);\n    float den = NH_sqr * (alpha2 - 1.) + 1.;\n    return alpha2 / ( PI * den * den );\n}\n\nfloat GGX_GeometrySchlick(float NV)\n{\n    float k = (ROUGTHNESS*ROUGTHNESS) / 2.;\n    float den = NV * (1. - k) + k;\n\t\n    return NV / den;\n}\n\nfloat GeometrySmith(float NV, float NL)\n{\n    float ggx_NV  = GGX_GeometrySchlick(NV);\n    float ggx_NL  = GGX_GeometrySchlick(NL);\n\t\n    return ggx_NV * ggx_NL;\n}\n\nvec3 FresnelSchlick_Routhness(vec3 F0, float cosTheta)\n{\n    return F0 + (max(vec3(1. - ROUGTHNESS), F0) - F0) * pow(1. - clamp(cosTheta, 0., 1.), 5.);\n}\n\nvec3 FresnelSchlick(vec3 F0, float cosTheta)\n{\n    return F0 + (1. - F0) * pow(1. - clamp(cosTheta, 0., 1.), 5.);\n}\n\nfloat SSAO(vec2 frag_coord)\n{\n    float depth = get_texture(frag_coord);\n    int samples = 2;\n    float ssao = 0.;\n    for(int i = -samples; i < samples; i++) {\n    \tfor(int j = -samples; j < samples; j++) {\n        \tssao += (get_texture(frag_coord + vec2(i,j)) >= depth ? 1. : 0.);  \n        }\n    }\n    return 1. - ssao / (4. * 4.);\n}\n\nfloat ShadowCalculation(vec3 light_pos, vec3 uv, vec3 normal)\n{\n    vec3 light_dir = normalize(light_pos - uv);\n    float bias = max(.05 * (1. - dot(normal, light_dir)), .005);\n    float samples = 3.;\n    \n    float closest_depth = get_texture((uv.xy)*iResolution.xy);\n    vec3 curr_pos = uv + light_dir * bias;\n\n    float shadow = 0.;\n    for (float s = 0.; s < LIGHTER_SIZE; s++)\n    {\n        for(float i = 0.; i < samples; i++)\n        {\n            vec2 cp = curr_pos.xy + vec2(i/2. - samples/2., samples/2. - i/2.) / iResolution.xy;\n            float curr_depth = get_texture((cp)*iResolution.xy);\n            if(curr_depth - bias > closest_depth)\n            {\n                shadow++;\n            }\n        }\n        curr_pos += light_dir * bias;\n    }\n    return clamp(1. - shadow/max(samples * LIGHTER_SIZE, 1.), .3, 1.);\n}\n\nvec3 BRDF_light(vec3 light, vec3 uv, vec3 normal_dir, float ao, float shadow)\n{\n    vec3 view_dir = normalize(vec3(uv.xy, 1.)); \n    vec3 light_dir = normalize(light - uv);\n    vec3 h = normalize(light_dir + view_dir);\n    \n    float NV = max(dot(normal_dir, view_dir), 0.);\n    float NL = max(dot(normal_dir, light_dir), 0.);\n    float HV = max(dot(h, view_dir), 0.);\n    \n    //PBR\n    float G = GeometrySmith(NL, NV);\n    float D = GGX_Distribution(max(dot(normal_dir, h), 0.));\n\tvec3 F0 = mix(vec3(.04), vec3(ALBEDO), METALLNESS);\n    vec3 F = FresnelSchlick(F0, HV);\n    vec3 f_specular = D*G*F/ max((4. * NV), .001);\n    \n    vec3 k_spec = FresnelSchlick_Routhness(F0, HV);;\n    vec3 k_diffuse = vec3(1.) - k_spec;\n    vec3 irradiance = texture(iChannel1, normal_dir).rgb;\n    k_diffuse *= 1. - METALLNESS;\n    vec3 f_diffuse = k_diffuse * ALBEDO * irradiance * ao / PI;\n    \n    \n    float distance = length(light - uv);\n    float attenuation = 1. / (distance * distance);\n    vec3 ambient = 0.1 * vec3(ALBEDO);\n    \n    return (f_diffuse + f_specular) * attenuation * shadow + ambient;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 LIGHTER_POS = vec2(iMouse);\n    \n    vec3 uv = vec3(fragCoord/iResolution.xy - .5, 0.);\n    vec3 normal = calculate_normal(fragCoord);\n    vec3 lighter = vec3(LIGHTER_POS/iResolution.xy - 0.5, LIGHTER_HEIGHT);\n    float shadow = dot(lighter, normal) > 0. ? ShadowCalculation(lighter, uv, normal) : 1.;\n    \n\n    fragColor = vec4(BRDF_light(lighter, uv, normal, SSAO(fragCoord), shadow), 1.);\n}","name":"Image","description":"","type":"image"}]}