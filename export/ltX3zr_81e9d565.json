{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define BALL_COUNT 8\n#define RAY_MAX_DIST 8.0\n#define MAX_RAY_STEPS 80\n#define SURFACE_THRESHOLD 0.18\n#define MAX_RAY_BOUNCES 2\n\n\nvec4 metaballs[BALL_COUNT];\n\n\nvec3 gammaCorrect(vec3 c)\n{\n    return pow(c, vec3(0.454545));\n}\n\nvec3 gammaToLinear(vec3 c)\n{\n    return pow(c, vec3(2.2));\n}\n\n\nfloat rand(float v)\n{\n    return fract(sin(v * 3.453) * 342.56434);\n}\n\n//perlin approx\nfloat calculateBallCoeff(float d)\n{\n\treturn d * d * d * (d * (d * 6.0 - 15.0) + 10.0);   \n}\n\n\nvoid generateSurfaces(float t, vec3 mpos)\n{\n    float MIN_RAD = 1.0;\n    float MAX_RAD = 2.0;\n    vec3 PATH_RAD = vec3(2,2,1);\n    vec3 PATH_OFFSET = vec3(0.0, 0.0, -3.0);\n   \tfloat SPEED_MIN = 0.1;\n    float SPEED_MAX = 0.4;\n    \n    \n    for(int i = 1; i < BALL_COUNT; ++i)\n    {\n        float j = float(i) + 1.0;\n        float speed = SPEED_MIN + abs(rand(j * 453.534)) * (SPEED_MAX - SPEED_MIN);\n        \n        vec3 pos = vec3(sin(rand(j) * t  * speed  ) * PATH_RAD.x, sin(rand(j * 234.542) * t * speed )  *  PATH_RAD.y, sin(rand(j * 349.5435) * t * speed)  * PATH_RAD.z) + PATH_OFFSET;\n        \n    \tvec4 ball = vec4(pos, mix(MIN_RAD, MAX_RAD,rand(j * 42.253)));\n        metaballs[i] = ball;\n    }\n    \n    \n    //one ball to control with mouse\n    metaballs[0] =  vec4(mpos, mix(MIN_RAD, MAX_RAD,0.5));\n    \n}\n\n\nvec3 fresnel(vec3 spec,vec3 viewDir ,vec3 normal, float roughness)\n{\n    return spec + ( max(spec, (1.0 - roughness) ) - spec) * pow(1.0 - clamp(dot(viewDir, normal), 0.0, 1.0), 5.0);\n}\n\nvec3 calculateLighting(vec3 diff, vec3 spec, vec3 reflCol, float r, vec3 v, vec3 n, vec3 p )\n{\n    \n    \n    \n    vec3 color = vec3(0.0 ,0.0, 0.0);\n    color += diff * max(dot(n, normalize(vec3(-0.5, -0.3, 0.3))),0.0) * 0.9;\n    color += diff * max(dot(n,normalize(vec3(0.7, 0.6, -0.3))),0.0) * 0.7;\n    \n    vec3 f = fresnel(spec, v, n, r);\n            \n    return pow(color + reflCol * f, vec3(3.0));\n}\n\nvec3 getBallColor(int i)\n{\n    float v = (float(i) + 0.245) * 0.345;\n    vec3 c1 = vec3( 0.4, 0.2, 0.05);\n    vec3 c2 = vec3( 0.25, 0.4, 0.25 );\n    float t = fract(v);\n    return mix(c1,c2,t);\n}\n\nvec4 getBallSpecularAndRoughness(int i)\n{\n    float t = abs(rand((float(i) + 1.43)* 2.0));\n    float mispec = 0.01;\n    float maspec = 0.2;\n    \n    float mirough = 0.001;\n    float marough = 0.3;\n    \n    return vec4(vec3(0.9, 0.3, 0.0) * mix(mispec,maspec,t) , mix(mirough, marough,t));\n}\n\nfloat sampleMetaballCoeffs(vec3 p)\n{\n    float sum = 0.0;\n    for(int i = 0; i < BALL_COUNT; ++i)\n    {\n    \tvec4 metaball = metaballs[i];\n        float len = length( metaball.xyz - p );\n       \n        if( len < metaball.w )\n        {\n            float rcp = len / metaball.w;\n        \tsum += calculateBallCoeff( 1.0 - rcp );\n        } \n    }\n    return sum;\n}\n\nvoid sampleBlobNormalAndMaterial(vec3 p, out vec3 normal, out vec3 color, out vec4 spec)\n{\n    vec3 n = vec3(0.0, 0.0, 0.0);\n    vec3 c = vec3(0.0, 0.0, 0.0);\n    vec4 s = vec4(0.0, 0.0, 0.0, 0.0);\n    float sum = 0.0;\n    for(int i = 0; i < BALL_COUNT; ++i)\n    {\n    \tvec4 metaball = metaballs[i];\n        float len = length( metaball.xyz - p );\n        \n        if( len < metaball.w )\n        {\n            float rcp = len / metaball.w;\n        \tfloat coeff= calculateBallCoeff( 1.0 - rcp );\n            n += normalize(metaball.xyz - p) * coeff;\n            c += getBallColor(i) * coeff;\n            s += getBallSpecularAndRoughness(i) * coeff;\n            sum += coeff;\n        } \n    }\n    normal = normalize(n);\n    color = c / sum;\n    spec = s / sum;\n}\n\nvec3 sampleBlobNormal(vec3 p)\n{\n    vec3 n = vec3(0.0, 0.0, 0.0);\n    for(int i = 0; i < BALL_COUNT; ++i)\n    {\n    \tvec4 metaball = metaballs[i];\n        float len = length( metaball.xyz - p );\n        \n        if( len < metaball.w )\n        {\n            float rcp = len / metaball.w;\n        \tfloat coeff= calculateBallCoeff( 1.0 - rcp );\n            n += normalize(metaball.xyz - p) * coeff;\n        } \n    }\n    return normalize(n);\n\n}\n\nfloat interpolateDistField(float prevCoeff, float currentCoeff, float prevVal, float currVal)\n{\n    //linearly interpolate to find the border (inaccurate/incorrect but seems to work ok)\n    float t = (SURFACE_THRESHOLD - prevCoeff) / ( currentCoeff - prevCoeff);\n   \treturn prevVal * (1.0 - t) + currVal * t;\n}\n\nvec2 raymarch(vec3 ro, vec3 rd)\n{\n    float sl = RAY_MAX_DIST / float(MAX_RAY_STEPS);\n\tfloat d = 0.0;\n    float didHit = -1.0;\n    float prevCoeff = 0.0;\n    for(int i = 0; i < MAX_RAY_STEPS; ++i)\n    {\n        \n    \tfloat coeff = sampleMetaballCoeffs( ro + rd * d);\n        if(coeff > SURFACE_THRESHOLD)\n        {\n            \n            d = interpolateDistField(prevCoeff, coeff, d - sl, d);\n            didHit = 1.0;\n        \tbreak;\n        }\n        prevCoeff = coeff;\n        d += sl;\n    }\n    return vec2(d, didHit);\n}\n\n\n\nvec3 calculateColor(vec3 origin, vec3 dir)\n{\n    vec3 ro = origin;\n    vec3 rd = dir;\n    \n    \n\tvec3 col = vec3(0.0, 0.0, 0.0);\n\tvec2 res = raymarch(ro, rd);\n    \n    if(res.y > 0.0)\n    {\n        \n    \tvec3 pos = ro + rd * res.x;\n           \n    \tvec3 normal;\n    \tvec3 color;\n        vec4 spec;\n        sampleBlobNormalAndMaterial(pos, normal, color, spec);\n        \n        vec3 reflCol;\n        if(MAX_RAY_BOUNCES <= 1)\n        {\n            vec3 reflDir = reflect(rd, normal);\n        \treflCol = gammaToLinear(texture( iChannel0, reflDir).xyz);\n        } else{\n            //simple reflections, don't calculate lighting/shading in reflections\n            float sl = RAY_MAX_DIST / float(MAX_RAY_STEPS);\n            vec3 p = ro + rd * (res.x - sl);\n            vec3 dir = reflect(rd, normal);\n       \t\tfor( int i = 1; i < MAX_RAY_BOUNCES; ++i )\n            {\n            \tvec2 r = raymarch(p, dir);\n                if(r.y < 0.0)\n    \t\t\t{\n                \tbreak;\n                } else\n                {\n                    vec3 temp = p + dir * r.x;\n                    dir = reflect(dir, sampleBlobNormal(temp)); \n                \tro = temp;\n                    \n                }\n                    \n            }\n            reflCol = gammaToLinear(texture( iChannel0, dir).xyz);\n        }\n        \n        col += calculateLighting(color,spec.xyz,reflCol, spec.w, rd,normal, pos);\n            \n    } else {\n\t\tcol = gammaToLinear(texture( iChannel0, rd ).xyz);\n    }    \n\n    return col;\n}\n\n\n\n\nvec3 viewCoordinatesToRayDir(vec3 eyeDir, vec3 eyeUp,  float fovy, float near, float aspect, vec2 screen_coord) \n{\n\n\tfloat projY = tan(fovy * 0.5) * 2.0 * near;\n\tfloat projX = projY * aspect;\n  \n\n\tvec3 right = normalize( cross(eyeDir, eyeUp) );\n  \n\n\tfloat dx = projX * (screen_coord.x - 0.5);\n\tfloat dy = projY * (screen_coord.y - 0.5);\n  \n\treturn normalize( eyeDir * near + dx * right + dy * eyeUp);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vp = fragCoord.xy / iResolution.xy;\n    vec2 mp = iMouse.xy / iResolution.xy;\n    vec3 eyeDir = vec3(0.0, 0.0, -1.0);\n    vec3 eyePos = vec3(0.0, 0.0, 2.0);\n    vec3 eyeUp = vec3(0.0, 1.0, 0.0);\n    float near = 0.01;\n    float fovy = radians(60.0);\n    float aspect =iResolution.x / iResolution.y;\n    \n    \n    vec3 rd = viewCoordinatesToRayDir(eyeDir, eyeUp, fovy, near, aspect, vp);\n    vec3 ro = eyePos;\n    \n    vec3 mrd = viewCoordinatesToRayDir(eyeDir, eyeUp, fovy, near, aspect, mp);\n    \n\tgenerateSurfaces(iTime + 40.0, ro + mrd * 4.5);\n    fragColor = vec4(gammaCorrect(calculateColor(ro,rd)), 1.0); \n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ltX3zr","date":"1417968581","viewed":245,"name":"Yet Another Metaball impl","username":"Mana","description":"experiment with metaballs","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","metaball","isosurface"],"hasliked":0,"parentid":"","parentname":""}}