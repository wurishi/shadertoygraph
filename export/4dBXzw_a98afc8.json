{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// \"Holographic\" by Alexander Alekseev aka TDM - 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//#define PIXELIZE\n#define CAMERA_CHANGE\n\nconst int NUM_STEPS = 64;\nconst int AO_SAMPLES = 4;\nconst float AO_RADIUS = 1.3;\nconst float AO_DARKNESS = 3.5;\nconst float INV_AO_SAMPLES = 1.0 / float(AO_SAMPLES);\nconst float TRESHOLD \t= 0.001;\nconst float EPSILON \t= 1e-5;\nconst float PI \t\t\t= 3.1415;\nconst float HPI \t\t= PI * 0.5;\nconst float LIGHT_INTENSITY = 0.37;\nconst vec3 RED \t\t= vec3(1.0,0.7,0.7) * LIGHT_INTENSITY;\nconst vec3 ORANGE \t= vec3(1.0,0.67,0.43) * LIGHT_INTENSITY;\nconst vec3 BLUE \t= vec3(0.54,0.77,1.0) * LIGHT_INTENSITY;\nconst vec3 WHITE \t= vec3(1.0,0.99,0.98) * LIGHT_INTENSITY;\n#define WEIGHT (2.0 / iResolution.x)\n\n// holo\nconst vec2 HOLO_SIZE \t= vec2(0.79,0.49);\nconst float HOLO_ASPECT = HOLO_SIZE.x / HOLO_SIZE.y;\nconst int HOLO_LINES \t= 8;\nconst vec2 dxdy \t\t= HOLO_SIZE / float(HOLO_LINES/2);\nconst float HOLO_DEPTH \t= 5.0;\nconst float HOLO_DDEPTH = HOLO_DEPTH / float(HOLO_LINES-1);\n\n#ifdef PIXELIZE\nconst vec2 HOLO_RESOLUTION = vec2(20.0,16.0);\n#endif\n\n// math\nmat4 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat4 m;\n    m[0] = vec4(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x,0.0);\n\tm[1] = vec4(-a2.y*a1.x,a1.y*a2.y,a2.x,0.0);\n\tm[2] = vec4(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y,0.0);\n\tm[3] = vec4(0.0,0.0,0.0,1.0);\n\treturn m;\n}\nmat4 getPosMatrix(vec3 p) {   \n    mat4 ret;\n    ret[0] = vec4(1.0,0.0,0.0,p.x);\n    ret[1] = vec4(0.0,1.0,0.0,p.y);\n    ret[2] = vec4(0.0,0.0,1.0,p.z);   \n    ret[3] = vec4(0.0,0.0,0.0,1.0);\n    return ret;\n}\nvec3 rotate(vec3 v, mat4 m) {\n    return vec3(dot(v,m[0].xyz),dot(v,m[1].xyz),dot(v,m[2].xyz));\n}\nvec3 intersectPlane(vec3 o,vec3 d,vec4 p) {\n    float t = (dot(p.xyz,o)-p.w) / dot(p.xyz,d);\n    return o - d * t;    \n}\n\n// rasterize\nfloat line(vec2 p, vec2 p0, vec2 p1) {\n    vec2 d = p1 - p0;\n    float t = clamp(dot(d,p-p0) / dot(d,d), 0.0,1.0);\n    vec2 proj = p0 + d * t;\n    float dist = length(p - proj);\n    dist = 1.0/dist*WEIGHT;\n    return min(dist*dist,1.0);\n}\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) { return pow(dot(n,l) * 0.4 + 0.6,p); }\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// distance functions\nfloat plane(vec3 gp, vec4 p) {\n\treturn dot(p.xyz,gp+p.xyz*p.w);\n}\nfloat sphere(vec3 p,float r) {\n\treturn length(p)-r;\n}\nfloat capsule(vec3 p,float r,float h) {\n    p.y -= clamp(p.y,-h,h);\n\treturn length(p)-r;\n}\nfloat cylinder(vec3 p,float r,float h) {\n\treturn max(abs(p.y/h),capsule(p,r,h));\n}\nfloat box(vec3 p,vec3 s) {\n\tp = abs(p)-s;\n    return max(max(p.x,p.y),p.z);\n}\nfloat rbox(vec3 p,vec3 s) {\n\tp = abs(p)-s;\n    return length(p-min(p,0.0));\n}\nfloat quad(vec3 p,vec2 s) {\n\tp = abs(p) - vec3(s.x,0.0,s.y);\n    return max(max(p.x,p.y),p.z);\n}\n\n// boolean operations\nfloat boolUnion(float a,float b) { return min(a,b); }\nfloat boolIntersect(float a,float b) { return max(a,b); }\n\n// world\nfloat map(vec3 p) {\n    float d = plane(p,vec4(0.0,1.0,0.0,1.0));\n    d = boolUnion(d,plane(p,vec4(0.0,-1.0,0.0,4.0))); \n    d = boolUnion(d,plane(p,vec4(0.0,0.0,1.0,5.0)));\n    d = boolUnion(d,plane(p,vec4(0.0,0.0,-1.0,5.0)));  \n    d = boolUnion(d,plane(p,vec4(1.0,0.0,0.0,8.0)));\n    d = boolUnion(d,plane(p,vec4(-1.0,0.0,0.0,8.0)));  \n    \n    d = boolUnion(d,rbox(vec3(0.75,-0.51,0.45)-p,vec3(0.1,0.5,0.1)));    \n    d = boolUnion(d,rbox(vec3(0.75,-0.51,-0.45)-p,vec3(0.1,0.5,0.1)));\n    d = boolUnion(d,rbox(vec3(-0.75,-0.51,0.45)-p,vec3(0.1,0.5,0.1)));    \n    d = boolUnion(d,rbox(vec3(-0.75,-0.51,-0.45)-p,vec3(0.1,0.5,0.1)));\n    d = boolUnion(d,rbox(vec3(0.0,-0.06,0.0)-p,vec3(0.85,0.05,0.55)));\n    \n    d = boolUnion(d,quad(vec3(0.0,0.0,0.0)-p,HOLO_SIZE));\n    return d;\n}\n\n// tracing\nvec3 getNormal(vec3 p, float dens) {\n    vec3 n;\n    n.x = map(vec3(p.x+EPSILON,p.y,p.z));\n    n.y = map(vec3(p.x,p.y+EPSILON,p.z));\n    n.z = map(vec3(p.x,p.y,p.z+EPSILON));\n    return normalize(n-dens);\n}\nfloat getAO(vec3 p,vec3 n) {\n    float r = 0.0;\n    for(int i = 0; i < AO_SAMPLES; i++) {\n        float f = float(i)*INV_AO_SAMPLES;\n        float h = 0.01+f*AO_RADIUS;\n        float d = map(p + n * h) - TRESHOLD;\n        r += clamp(h-d,0.0,1.0) * (1.0-f);\n    }    \n    return pow(clamp(1.0-r*INV_AO_SAMPLES*AO_DARKNESS,0.0,1.0),0.5);\n}\nfloat spheretracing(vec3 ori, vec3 dir, out vec3 p) {\n    float t = 0.0;\n    float d = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) {\n        p = ori + dir * t;\n        d = map(p);\n        if(d < TRESHOLD) break;\n        t += max(d-TRESHOLD,EPSILON);\n    } \n    return d;\n}\n\n// holo\nfloat projectLine(vec3 o, vec2 uv, vec3 v0,vec3 v1) {\n    v0 = intersectPlane(o,v0-o,vec4(0.0,1.0,0.0,0.0));\n    v1 = intersectPlane(o,v1-o,vec4(0.0,1.0,0.0,0.0));\n    v0.xy = v0.xz / HOLO_SIZE; v1.xy = v1.xz / HOLO_SIZE;\n    v0.x *= HOLO_ASPECT; v1.x *= HOLO_ASPECT;\n    return line(uv,v0.xy,v1.xy);\n}\n\nvoid projectCircle(vec3 o,vec2 uv,vec3 v,inout vec3 c){\n    vec3 d = v-o;\n    v = intersectPlane(o,d,vec4(0.0,1.0,0.0,0.0));\n    v.xz /= HOLO_SIZE; v.x *= HOLO_ASPECT;\n    \n    float r = length(uv-v.xz) * length(d) * 0.75;\n    float circle = clamp(sin(r*40.0) * 5.0 * 0.5 + 0.5, 0.0,1.0);\n    c = mix(c, vec3(1.0,circle,circle), smoothstep(0.50,0.48,r));\n}\n\nvec3 holoGetColor(mat4 head, vec2 p) {\n    float time = iTime * 0.3;\n    vec2 uv = p; uv.x *= HOLO_ASPECT;    \n    vec3 pos = vec3(head[0][3],head[1][3],head[2][3]);\n    \n#ifdef PIXELIZE\n    uv = floor(uv*HOLO_RESOLUTION) / HOLO_RESOLUTION;\n#endif\n    \n    float i = 0.0;    \n    for(int it = 0; it < HOLO_LINES; it++) {\n        // vertical\n        vec3 v0 = vec3(-HOLO_SIZE.x + dxdy.x * float(it+1),0.0,-HOLO_SIZE.y);\n        vec3 v1 = vec3(v0.x,-HOLO_DEPTH,v0.z);\n    \ti += projectLine(pos,uv,v0,v1);\n        \n        v0 = vec3(-HOLO_SIZE.x + dxdy.x * float(it),0.0, HOLO_SIZE.y);\n        v1 = vec3(v0.x,-HOLO_DEPTH,v0.z);\n    \ti += projectLine(pos,uv,v0,v1);      \n        \n        v0 = vec3(-HOLO_SIZE.x, 0.0, -HOLO_SIZE.y + dxdy.y * float(it));\n        v1 = vec3(v0.x,-HOLO_DEPTH,v0.z);\n    \ti += projectLine(pos,uv,v0,v1);  \n        \n        v0 = vec3(HOLO_SIZE.x, 0.0, -HOLO_SIZE.y + dxdy.y * float(it+1));\n        v1 = vec3(v0.x,-HOLO_DEPTH,v0.z);\n    \ti += projectLine(pos,uv,v0,v1);\n        \n        // horizontal\n        float h = -float(it)*HOLO_DDEPTH;\n        v0 = vec3(-HOLO_SIZE.x,h,-HOLO_SIZE.y);\n        v1 = vec3(-v0.x,v0.y,v0.z);\n    \ti += projectLine(pos,uv,v0,v1);\n        \n        v0 = vec3(-HOLO_SIZE.x,h,HOLO_SIZE.y);\n        v1 = vec3(-v0.x,v0.y,v0.z);\n    \ti += projectLine(pos,uv,v0,v1);\n        \n        v0 = vec3(-HOLO_SIZE.x,h,-HOLO_SIZE.y);\n        v1 = vec3(v0.x,v0.y,-v0.z);\n    \ti += projectLine(pos,uv,v0,v1);\n        \n        v0 = vec3(HOLO_SIZE.x,h,-HOLO_SIZE.y);\n        v1 = vec3(v0.x,v0.y,-v0.z);\n    \ti += projectLine(pos,uv,v0,v1);       \n    }\n    \n    vec3 color = vec3(min(i,1.0));    \n    projectCircle(pos,uv,vec3(-0.5,-3.0,0.0),color);\n    projectCircle(pos,uv,vec3( 0.5,-1.0,0.0),color);\n    projectCircle(pos,uv,vec3( 0.0, 1.0,0.0),color);\n    color += texture(iChannel0,uv*0.5).z * 0.3;\n    return color;\n}\n\nvec3 holoGetColor(mat4 head, vec3 p) {\n    return holoGetColor(head,p.xz / HOLO_SIZE);\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n    float time = iTime * 0.3;\n        \n    // ray\n    vec3 ang = vec3(0.0,0.7,time);\n    if(iMouse.z > 0.0) ang = vec3(0.0,clamp(2.0-iMouse.y*0.01,-0.3,PI),iMouse.x*0.01);\n\tmat4 rot = fromEuler(ang);\n    \n    vec3 ori = vec3(0.0,0.0,2.0+sin(time)*0.5);\n    vec3 dir = normalize(vec3(uv.xy,-2.0));    \n    ori = rotate(ori,rot);\n    dir = rotate(dir,rot);\n    mat4 head = rot * getPosMatrix(ori);\n    \n    // change camera\n#ifdef CAMERA_CHANGE\n    rot = fromEuler(vec3(0.0,1.0,0.0));\n    vec3 ori2 = vec3(0.0,0.0,2.0);\n    vec3 dir2 = normalize(vec3(uv.xy,-2.0));    \n    ori2 = rotate(ori2,rot);\n    dir2 = rotate(dir2,rot);\n    \n    float camera_change_factor = clamp((sin(time)-0.8)*10.0,-1.0,1.0) * 0.5 + 0.5;\n    ori = mix(ori,ori2,camera_change_factor);\n    dir = normalize(mix(dir,dir2,camera_change_factor));\n#endif\n    \n    // tracing\n    vec3 p;\n    float dens = spheretracing(ori,dir,p);\n    vec3 n = getNormal(p,dens);\n    float ao = getAO(p,n);\n         \n    // color\n    vec3 color = vec3(0.6+texture(iChannel0,(p.xz+p.y*0.2)*0.1).x * 0.05);\n    if(p.y >= -EPSILON && dot(p.xz,p.xz) < 1.0) color = holoGetColor(head,p);\n    color *= 1.0-pow(dot(p,p)*0.01,0.4);\n    \n    // lighting\n    vec3 l0 = normalize(vec3(0.0,0.5,0.7));\n    vec3 l1 = normalize(vec3(0.5,0.5,-0.7));    \n    color += vec3((diffuse(n,l0,3.0) + specular(n,l0,dir,20.0)) * RED);\n    color += vec3((diffuse(n,l1,3.0) + specular(n,l1,dir,20.0)) * BLUE);    \n    color = clamp(color*ao*0.9,0.0,1.0);\n    color = mix(vec3(0.3),color,step(dens,1.0));\n        \n    //color = vec3(ao);\n    //color = n * 0.5 + 0.5;\n\t\n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dBXzw","date":"1410357276","viewed":3258,"name":"Holographic","username":"TDM","description":"Inspired by Johnny Lee VR work. 3D effect on flat surface.","likes":72,"published":1,"flags":0,"usePreview":0,"tags":["projection","table","holographic","kinect"],"hasliked":0,"parentid":"","parentname":""}}