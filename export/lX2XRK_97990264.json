{"ver":"0.1","info":{"id":"lX2XRK","date":"1710832248","viewed":50,"name":"The Eye of the Sun Ra","username":"akr51","description":"Made using ray marching thanks to The Art of Code yt channel","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define EPSILON 0.001\n#define MAXDEPTH 120.0\n#define ITERATIONS 100\n\n\nfloat chaos2_random_factor(vec2 p, float x1, float x2, float x3)\n{\n\n    return fract(sin(dot(p.xy, vec2(x1, x2))) * x3);\n\n\n}\n\n\nfloat chaos2(vec2 p)\n{\n\t\n\treturn sin(dot(p.xy, vec2(11.012842, 13.23))) * 0.09;\n    return chaos2_random_factor(p, 34.012842, 34.23, 34.0);\n\t\n}\n\n\n\n\nfloat sphere(vec3 p, float radius)\n{\n\n\n    return length(p) - radius;\n\n}\n\n\nfloat plane(vec3 p, vec3 normal)\n{\n\n\n    return dot(p, normal);\n\n}\n\n\n\nfloat map(vec3 p)\n{\n\n\n\n    float s0 = sphere(p + vec3(0.0, -0.1, 0.7), 0.1);\n    \n    vec3 q = vec3(0.0, 0.01, 0.0);\n    float s1 = plane(p + q, vec3(0.0, 1.0, 0.0));\n    return min(s1, s0);\n\n}\n\n\n\nvec3 normal(vec3 p)\n{\n    \n\n    float d = map(p);\n    \n    vec2 e = vec2(0.01, 0.0);\n    \n    vec3 n = d - vec3(map(p - e.xyy), map(p - e.yxy), map(p - e.yyx));\n    \n    return normalize(n);\n\n}\n\n\n\n\nfloat rayMarch(vec3 ro, vec3 rd)\n{\n\n    \n    float t = 0.0;\n    float d = 0.0;\n    \n    for (int i = 0; i < ITERATIONS; i++)\n    {\n    \n    \n        d = map(ro + t * rd);\n        t += d;\n         \n        if (d < EPSILON || d > MAXDEPTH)\n        {\n        \n            break;\n        \n        }\n       \n    \n    }\n   \n    return t;\n}\n\n\n\nfloat illuminate(vec3 p)\n{\n    \n\n    vec3 l_pos = vec3(0.0, 0.4, sin(iTime * 0.5) * 2.0 - 2.0);\n    vec3 l = normalize(l_pos - p);\n    vec3 n = normal(p);\n    \n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    \n    float d = rayMarch(p + n * 0.01, l);\n     \n    if (d < length(l_pos - p))\n    {\n    \n        dif *= 0.1;\n    \n    }\n     \n    \n    return dif * 0.5;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    \n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= (iResolution.x / iResolution.y);\n    \n    vec3 ro = vec3(0.0, 0.1, -1.0);\n    vec3 rd = normalize(vec3(uv + chaos2(uv + vec2(iTime, iTime)) * 0.1, 1.0));\n    \n    \n    float f = rayMarch(ro, rd);\n  \n    vec3 surf_p = ro + f * rd;\n\n    \n    float i = illuminate(surf_p) * 2.5;\n    i = pow(i, 15.0);\n            \n    \n    fragColor = vec4(vec3(i * vec3(6.0, 2.1, 0.75)) + vec3(0.01, 0.01, 0.02), 1.0);\n    \n   \n}","name":"Image","description":"","type":"image"}]}