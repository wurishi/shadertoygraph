{"ver":"0.1","info":{"id":"ddGfDw","date":"1698265282","viewed":25,"name":"Waveform Aliasing Demo","username":"foodini","description":"Just a visual to show what happens when your (ideally) analog signal frequency gets too close to your sampling frequency.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["aliasing","audio"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime * iTime/1000.0;\n    fragColor = vec4(0.0);\n    for(float dx=-2.0; dx <= 2.0; dx+=1.0) {\n        float x = (fragCoord.x + dx) * t;\n\n        float y = sin(x) * iResolution.y/2.0 + iResolution.y/2.0; \n\n        if(abs(y-fragCoord.y) < 3.0) {\n            fragColor += vec4(1.0);\n        } else {\n            fragColor += vec4(0.0);\n        }\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\nd88888b  .d88b.  d8b   db d888888b .d8888.\n88'     .8P  Y8. 888o  88 `~~88~~' 88'  YP\n88ooo   88    88 88V8o 88    88    `8bo.\n88~~~   88    88 88 V8o88    88      `Y8b.\n88      `8b  d8' 88  V888    88    db   8D\nYP       `Y88P'  VP   V8P    YP    `8888Y'\n*/\n\n//TODO:\n//* Have the float's width take an ivec2 in printf %5.12f fashion.\n\n#define DC(name, val) const int name = val\n\nDC(_NULL,127); //I may want as non-null since the font has a character there.\n\nDC(_SPACE,32); DC(_BANG,33); DC(_QUOTE,34); DC(_HASH,35); \nDC(_DOLLAR,36); DC(_PERCENT,37); DC(_AMPERSAND,38); DC(_APOSTROPHE,39); \nDC(_PREN,40); DC(_NERP,41); DC(_STAR,42); DC(_PLUS,43); \nDC(_COMMA,44); DC(_MINUS,45); DC(_PERIOD,46); DC(_SLASH,47);\n\nDC(_0,48); DC(_1,49); DC(_2,50); DC(_3,51);\nDC(_4,52); DC(_5,53); DC(_6,54); DC(_7,55);\nDC(_8,56); DC(_9,57); DC(_COLON,58); DC(_SEMICOLON,59);\nDC(_LFTANGL,60); DC(_EQUAL,61); DC(_RGTANGL,62); DC(_QUESTION,63);\n\nDC(_AT,64); DC(_A,65); DC(_B,66); DC(_C,67); \nDC(_D,68); DC(_E,69); DC(_F,70); DC(_G,71); \nDC(_H,72); DC(_I,73); DC(_J,74); DC(_K,75); \nDC(_L,76); DC(_M,77); DC(_N,78); DC(_O,79); \n\nDC(_P,80); DC(_Q,81); DC(_R,82); DC(_S,83); \nDC(_T,84); DC(_U,85); DC(_V,86); DC(_W,87); \nDC(_X,88); DC(_Y,89); DC(_Z,90); DC(_LFTSQR,91); \nDC(_BACKSLASH,92); DC(_RGTSQR,93); DC(_CARET,94); DC(_UNDERSCORE,95); \n\nDC(_GRAVE,96); DC(_a,97); DC(_b,98); DC(_c,99); \nDC(_d,100); DC(_e,101); DC(_f,102); DC(_g,103); \nDC(_h,104); DC(_i,105); DC(_j,106); DC(_k,107); \nDC(_l,108); DC(_m,109); DC(_n,110); DC(_o,111); \n\nDC(_p,112); DC(_q,113); DC(_r,114); DC(_s,115); \nDC(_t,116); DC(_u,117); DC(_v,118); DC(_w,119); \nDC(_x,120); DC(_y,121); DC(_z,122); DC(_LFTSQUIG,123); \nDC(_PIPE,124); DC(_RGTSQUIG,125); DC(_TILDE,126);\n\nDC(_alpha,128); DC(_beta,129); DC(_gamma,130); DC(_delta,131); \nDC(_epsilon,132); DC(_theta,133); DC(_lambda,134); DC(_mu,135); \nDC(_xi,136); DC(_pi,137); DC(_rho, 138); DC(_sigma,139); \nDC(_tau,140); DC(_phi,141); DC(_psi,142); DC(_omega,143); \n\nDC(_GAMMA,144); DC(_DELTA,145); DC(_THETA,146); DC(_LAMBDA,147); \nDC(_PI,148); DC(_SIGMA,149); DC(_PHI,150); DC(_PSI,151); \nDC(_OMEGA,152); DC(_INFINITY,153); DC(_FORTE,154); DC(_degrees,155); \nDC(_INTEGRAL, 156); DC(_PARTIAL_DIFF, 157); DC(_NABLA,158); DC(_SQRT, 159); \n\n                     DC(_GNAB,161); DC(_CENT,162); DC(_POUND,163); \nDC(_VECTOR_OUT,164); DC(_YEN,165); DC(_BROKEN_PIPE,166); DC(_CONTOUR_INTEGRAL,167); \n                     DC(_COPYRIGHT,169); DC(_superscript_a,170); DC(_LEFT_SHIFT,171); \n                                         DC(_REGISTERED,174); DC(_OVERBAR,175); \n                                         \nDC(_DEGREES, 176); DC(_PLUSMINUS,177); DC(_superscript2,178); DC(_superscript3,179); \nDC(_ACCENT, 180); DC(_MU,181); DC(_PARAGRAPH,182); DC(_DOT,183);\n                  DC(_superscript_1,185); DC(_superscript_0,186); DC(_RIGHT_SHIFT,187); \nDC(_QUARTER,188); DC(_HALF,189); DC(_THREE_QUARTERS,190); DC(_NOITSEUQ,191); \n\n\n\n\nvec4 print_char(sampler2D font_channel, int c, float size, vec2 char_pos, vec2 uv) {\n    //This took me a while to get my brain around: uv and char_pos are in the same\n    //vector space. What that space is is irrelevant. It can be fragCoord, a\n    //square-pixel uv, a 0->1 by 0->1 uv, a -1->1 by -1->1 uv, or anything else. The\n    //only thing that matters is whether uv is within a box \"size\" units on a side.\n    //Check to make sure that uv lies within the extents of the character to be printed:\n\n    //font_uv_offset goes from -1.0->1.0 in both dimensions and is the position \n    //within the rendered character of uv.\n    vec2 font_uv_offset = (uv - char_pos) / size;\n    \n    if(font_uv_offset.x < -1.0 ||\n       font_uv_offset.x >  1.0 ||\n       font_uv_offset.y < -1.0 ||\n       font_uv_offset.y >  1.0) {\n        return vec4(0.0);\n    }\n    \n    \n    float row = float(15 - c/16);\n    float col = float(c%16);\n    \n    const float half_char_width = 1.0/32.0;\n    const float char_width = 1.0/16.0;\n    \n    vec2 font_uv = \n        vec2(half_char_width + char_width * col, half_char_width + char_width * row); \n    font_uv += font_uv_offset * half_char_width;\n    \n    return texture(font_channel, font_uv);\n}\n\nconst float log10 = log(10.0);\nint digits(int i) {\n    i = abs(i);\n    int retval = 0;\n    //TODO: this might be faster as a for loop with a break because of the way\n    //      for loops are unrolled? It would certainly be faster with a binary\n    //      search of ifs.\n    do {\n        retval++;\n        i /= 10;\n    } while(i > 0);\n    return retval;\n}\n\nvec4 print_int(sampler2D font_channel, int i, float size, vec2 pos, vec2 uv, \n               bool right, out int count) {\n    vec4 retval = vec4(0.0);\n    bool neg = i<0;\n    i = abs(i);\n    \n    if(!right) {\n        pos.x += size * (float(digits(i) - 1));\n        if(neg) {\n            pos.x += size;\n        }\n    }\n\n    count = 0;\n    do {\n        int c = 48 + i%10;\n        i /= 10;\n        retval += print_char(font_channel, c, size, pos, uv);\n        pos.x -= size;\n        count ++;\n    } while(i > 0);\n\n    if(neg) {\n        retval += print_char(font_channel, 45, size, pos, uv);\n        count++;\n    }\n    return retval;\n}\nvec4 print_int(sampler2D font_channel, int i, float size, vec2 pos, vec2 uv, \n               bool right) {\n    int _count;\n    return print_int(font_channel, i, size, pos, uv, right, _count);\n}\n\nvec4 print_float(sampler2D font_channel, float f, float size, vec2 pos, vec2 uv, \n                 bool right, int frac_digits, out int count) {\n    vec4 retval = vec4(0.0);\n    count = 0;\n    bool neg = false;\n\n    if(f < 0.0) {\n        neg = true;\n        f = abs(f);\n    }\n    \n    int frac_int = int(0.001 + fract(f) * pow(10.0, float(frac_digits)));\n    int mant_int = int(f);\n    \n    if(!right) {\n        int width = (neg?1:0) + digits(mant_int);\n        if(frac_digits > 0) {\n            width += 1 + frac_digits;\n        }\n        pos.x += size * float(width-1);\n\n        //retval += print_int(font_channel, digits(frac_int), size/2.0, pos + vec2(0.0, size), uv, true, tmp); \n    }\n    \n    \n    if(frac_digits > 0) {\n        retval += print_int(font_channel, frac_int, size, pos, uv, true, count);\n        pos.x -= size * float(count);\n        while(count < frac_digits) {\n            retval += print_char(font_channel, 48, size, pos, uv);\n            pos.x -= size;\n            count ++;\n        }\n        retval += print_char(font_channel, 46, size, pos, uv);\n        pos.x -= size;\n    }\n    int printed;\n    retval += print_int(font_channel, mant_int, size, pos, uv, true, printed);\n    count += printed;\n    if(neg) {\n        pos.x -= size * float(printed);\n        retval += print_char(font_channel, 45, size, pos, uv);\n        count ++;\n    }\n   \n    return retval;\n}\nvec4 print_float(sampler2D font_channel, float f, float size, vec2 pos, vec2 uv, \n                 bool right, int frac_digits) {\n    int _count;\n    return print_float(font_channel, f, size, pos, uv, right, frac_digits, _count);\n}\n\nfloat accumulating_left;\nvec2 accumulating_pos;\nfloat accumulating_size;\nvoid init_printing(vec2 pos, float size) {\n    accumulating_pos = pos;\n    accumulating_left = pos.x;\n    accumulating_size = size;\n}\n\nvoid newline() {\n    accumulating_pos.x = accumulating_left;\n    accumulating_pos.y -= accumulating_size*1.5;\n}\n\nconst float tab_width = 8.0;\nvoid tab() {\n    float x = accumulating_pos.x;\n    float printed = (x-accumulating_left)/accumulating_size;\n    float dx = tab_width - mod(printed, tab_width);\n    accumulating_pos.x += accumulating_size * dx;\n}\n\nvec4 print(sampler2D font_channel, int i, vec2 uv) {\n    int printed;\n    vec4 retval;\n    retval = print_int(font_channel, i, accumulating_size, accumulating_pos, uv, false, printed);\n    accumulating_pos.x += float(printed) * accumulating_size;\n    \n    return retval;\n}\n\nvec4 print(sampler2D font_channel, float f, vec2 uv, int frac_digits) {\n    int printed;\n    vec4 retval;\n    //return print_float(font_channel, f, size, pos, uv, right, frac_digits, _count);\n    retval = print_float(font_channel, f, accumulating_size, accumulating_pos, \n                         uv, false, frac_digits, printed);\n    accumulating_pos.x += float(printed+1) * accumulating_size;\n    \n    return retval;\n}\n\n#define DECL_PRINT_STRING(len) \\\nvec4 print(sampler2D font_channel, int c[len], vec2 uv) { \\\n    vec4 retval; \\\n    for(int i=0; i<len; i++) { \\\n        retval += print_char(font_channel, c[i], accumulating_size, accumulating_pos, uv); \\\n        accumulating_pos.x += accumulating_size; \\\n    } \\\n    return retval; \\\n}\n\n","name":"Common","description":"","type":"common"}]}