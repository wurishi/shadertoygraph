{"ver":"0.1","info":{"id":"MtyGz3","date":"1476566252","viewed":307,"name":"Diggy","username":"Belocio","description":"Modelling of Diamond Digger's main character","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","diamond","modelling","digger","diggy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime * 0.5\n#define lampLightIntensity abs(2.0*sin(time*5.0))\n\nconst float PI=3.14159265;\nconst float PIH = PI*0.5;\nconst int MAX_ITER = 40;\nconst float EPSILON = 0.00001;\nvec3 lightDir = normalize(vec3(0, 1, 0.75)); \nfloat lightIntensity=0.5;\nvec3 ambientLight=vec3(0.1,0.1,0.1);\n\nfloat bgMatType = 0.0;\nfloat PlaneMatType = 1.0;\nfloat BodyMatType = 2.0;\nfloat DressMatType = 3.0;\nfloat LampMatType = 4.0;\nfloat EyesMatType = 5.0;\nfloat TeethMatType = 6.0;\n\nvec3 skyColor = vec3(1.0,1.0,1.0);\nvec3 planeColor = vec3(1.0,1.0,1.0);\nvec3 bodyColor = vec3(0.89,0.74,0.15);\nvec3 dressColor = vec3(0.83,0.52,0.05);\nvec3 lampColor = vec3(0.63,0.99,0.99);\nvec3 eyesColor = vec3(0);\nvec3 teethColor = vec3(1.0,1.0,1.0);\n\n#define jumpFreq iTime * 2.5\nvec3 lampLightColor = vec3(0.63,0.99,0.99);\n#define posDispl vec3(0.0, -abs(sin(jumpFreq)*0.1), 0.0)\n#define lampDispl vec3(-0.1, sin(jumpFreq*2.0+PI*1.2)*0.15, 0.0)\nvec3 lampPos = vec3(0.0, 0.74, 0.15);\nfloat lampLightAtt = 1.5;\n\n//#define SELF_SHADOW\n#define CHEAP_AO\n\n// Thanks iq! https://www.shadertoy.com/view/ld3Gz2\n// http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec3 getClosest( vec2 b0, vec2 b1, vec2 b2 ) \n{\n    float a =     det(b0,b2);\n    float b = 2.0*det(b1,b0);\n    float d = 2.0*det(b2,b1);\n    float f = b*d - a*a;\n    vec2  d21 = b2-b1;\n    vec2  d10 = b1-b0;\n    vec2  d20 = b2-b0;\n    vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n    vec2  pp = -f*gf/dot(gf,gf);\n    vec2  d0p = b0-pp;\n    float ap = det(d0p,d20);\n    float bp = 2.0*det(d10,d0p);\n    float t = clamp( (ap+bp)/(2.0*a+b+d), 0.0 ,1.0 );\n    return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\n\nvec4 sdBezier( vec3 a, vec3 b, vec3 c, vec3 p )\n{\n\tvec3 w = normalize( cross( c-b, a-b ) );\n\tvec3 u = normalize( c-b );\n\tvec3 v = normalize( cross( w, u ) );\n\n\tvec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n\tvec2 b2 = vec2( 0.0 );\n\tvec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n\tvec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n\tvec3 cp = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy );\n\n\treturn vec4( sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z), cp.z, length(cp.xy), p3.z );\n}\n\n//---------------------------------------------\nvec3 rotationCoordY(vec3 n, float t)\n{\n vec3 result;\n\n   vec2 sc = vec2(sin(t), cos(t));\n   mat3 rotate;\n\n      rotate = mat3( sc.y,  0.0, -sc.x,\n                     0.0,   1.0,  0.0,\n                     sc.x,  0.0, sc.y);   \n\n  result = n * rotate;\n  return result;\n}\n\n//---------------------------------------------\nvec3 rotationCoordX(vec3 n, float t)\n{\n vec3 result;\n\n   vec2 sc = vec2(sin(t), cos(t));\n   mat3 rotate;\n\n      rotate = mat3( 1.0,  0.0,  0.0,\n                     0.0,  sc.y, -sc.x,\n                     0.0, sc.x, sc.y);   \n\n  result = n * rotate;\n  return result;\n}\n\n//------------------------------------------\nfloat sdPlaneY( vec3 p )\n{\n\treturn p.y;\n}\n\n//----------------------------------------------------\nfloat sdSphere(vec3 p, float r)\n{\n   return length(p) - r;\n}\n\n//----------------------------------------------------\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n//----------------------------------------------------------------\nvec3 InstantiateRotY(vec3 p, float inPiFrac)\n{\n\tfloat rad\t\t= mod(atan(p.x, p.z) +  PIH*inPiFrac, PI*inPiFrac) - PIH*inPiFrac;\n\tp.xz\t\t\t= vec2(sin(rad), cos(rad)) * length(p.xz);\n\treturn p;\n}\n\n//--------------------------------------------------\nfloat smin( float a, float b, float k ) \n{\n   float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n   return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//---------------------------------------------\nvec2 minDistMat(vec2 curDist, vec2 dist)\n{\n   \tif (dist.x < curDist.x) \n   \t{\n    \treturn dist;\n   \t}\n   \treturn curDist;\n}\n\n//---------------------------------------------\nfloat body(in vec3 p) {\n    float d = sdSphere(p*vec3(0.85,1.0,1.2), 0.2);\n    d = smin(d, sdSphere(p*vec3(0.95,1.0,1.2)+vec3(0,-0.22,0), 0.05), 0.22);\n    d = smin(d, sdSphere(p*vec3(0.75,1.5,0.7)+vec3(0,0.15,0), 0.1), 0.3);\n    return d;\n}\n\n//---------------------------------------------\nvec2 diggy(in vec3 p, bool includeLamp) {\n    // body\n    vec2 d = vec2(body(p), DressMatType);\n    float dSmall = body((p+vec3(0.0,-0.05,-0.15))/0.8)*0.8;\n    d.x=max(-dSmall,d.x);\n    \n    // Lamp neck\n    vec3 curLampDispl = vec3(0.0,0.4, 0.2) + lampDispl;\n    vec4 b = sdBezier( vec3(0.0, 0.2, 0.0), vec3(0.0,0.7, 0.0), curLampDispl, p);\n    d.x = smin(d.x, b.x - (0.04 - 0.02*b.y), 0.1);\n    \n    // legs\n    vec3 symYPos = p;\n   \tsymYPos.x = abs(symYPos.x);  \n    d.x = smin(d.x, sdSphere(symYPos * vec3(1.4, mix(0.8, 0.72, abs(sin(jumpFreq))), 1.4) + vec3(-0.25, 0.2, 0.05), 0.1), 0.22); \n    \n    //d=200.0;\n    // arms\n    vec3 armsPos = symYPos + vec3(-0.26, -0.1, 0.0) + posDispl*0.3;\n    b = sdBezier( vec3(0.05, 0.1, 0.0), vec3(0.01, 0.0, 0.0), vec3(-0.05, -0.1, 0.0), armsPos);\n    d.x = smin(d.x, b.x - (0.1*sqrt(b.y)), 0.01);\n    \n    // eyes\n    vec3 eyesPos = symYPos + vec3(-0.08, -0.08, -0.135);\n    b = sdBezier( vec3(0.05, 0.0, -0.02), vec3(0.0, 0.06, -0.01), vec3(-0.05, 0.0, 0.01), eyesPos);\n    d = minDistMat(d, vec2(b.x - 0.01, EyesMatType)); \n    \n    // Lamp\n    if(includeLamp) {\n    \td = minDistMat(d, vec2(sdSphere(p-curLampDispl, 0.05), LampMatType));\n    }\n    \n    // Body inside dress\n    d = minDistMat(d, vec2(body(p/0.95)*0.95, BodyMatType));\n    \n    // Mouth\n    vec3 mouthPos = p + vec3(0.0, 0.06, -0.165);\n    mouthPos = rotationCoordX(mouthPos, -0.6);\n    float dMouth = udRoundBox(mouthPos, vec3(0.15, 0.08, 0.05), 0.01);\n    dMouth = max(sdSphere(p*vec3(0.6, 0.93, 0.85) + vec3(0.0, 0.02, -0.1), 0.1), dMouth);\n    d = max(d, -dMouth);\n    \n    \n    // Teeth\n    vec3 teethPos = symYPos + vec3(-0.036, -0.01, -0.17);\n    teethPos = rotationCoordX(teethPos, 0.47);\n    teethPos = rotationCoordY(teethPos, 0.12);\n    d = minDistMat(d, vec2(udRoundBox(teethPos, \n                                      vec3(0.02+0.008*smoothstep(-0.035, 0.035, teethPos.y), 0.035, 0.005), 0.01), TeethMatType));\n    \n    return d;\n    \n}\n\n//--------------------------------------------------\nvec2 map(in vec3 p, bool includeLamp)\n{\n   \tvec3 pos = p;\n        \n   \tvec2 d = vec2(1.0, bgMatType);\n    \n    d = minDistMat(d, diggy(pos + vec3(0.0, -0.365, 0.0) + posDispl, includeLamp));\n    \n    // Planes\n    d = minDistMat(d, vec2(sdPlaneY(pos), PlaneMatType));\n        \n\treturn d; \n}\n\n//------------------------------------------------- \nvec3 getNormal(in vec3 p)\n{\n\n   vec3 e = vec3( EPSILON, 0., 0. );\n   vec3 nor = vec3(\n       map(p+e.xyy, true).x - map(p-e.xyy, true).x,\n       map(p+e.yxy, true).x - map(p-e.yxy, true).x,\n       map(p+e.yyx, true).x - map(p-e.yyx, true).x);\n   return normalize(nor);  \n\n}\n\n//------------------------------------------\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<10; i++ )\n    {        \n\t\tfloat h = map( ro + rd*t, false ).x;\n        res = min( res, 10.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<EPSILON || t>tmax ) break;\n    }\n    return clamp(res, 0.0, 1.0 );\n}\n\n//------------------------------------------\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n#ifdef CHEAP_AO\n    return mix(0.5, 1.0, clamp((nor.y + 1.0) * 0.5, 0.0, 1.0)); \n#else\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n    \tfloat hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( pos, false ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 0.5*occ, 0.0, 1.0 );   \n#endif\n}\n\n\n//------------------------------------------\nvec3 illum(in vec3 pos, in vec3 rd ,in vec3 nor, in vec3 lig, in vec3 col, in float t, in float mat, in vec3 add)\n{\n    // lighitng \n    vec3 ref = reflect( rd, nor );\n    float occ = calcAO( pos, nor );  \n    \n    vec3 pointLigDir = (lampPos+lampDispl+posDispl)-pos;\n    float distToPointLig = length(pointLigDir);\n    pointLigDir /= distToPointLig;\n    \n\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 )*lightIntensity;\n    float difPoint = clamp( dot( nor, pointLigDir ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n    float dom = smoothstep( -0.1, 0.1, ref.y );\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),1.0);\n    \n    float pointLightInt = clamp(lampLightIntensity-distToPointLig*lampLightAtt,0.0, lampLightIntensity);\n    difPoint *= pointLightInt;\n        \n#ifndef SELF_SHADOW\n    if(mat == PlaneMatType) \n    {\n#endif\n    \tdif *= softshadow( pos, lig, 0.1, 10.0 );\n        difPoint *= softshadow( pos, pointLigDir, 0.1, 10.0 );\n#ifndef SELF_SHADOW\n    }\n#endif\n    \n    vec3 brdf = vec3(0.0);\n    brdf += dif*vec3(1,1,1)+difPoint*lampLightColor;\n    brdf += 0.5*(spe*vec3(1,1,1)*dif+spe*difPoint*lampLightColor);\n    brdf += 0.30*amb*ambientLight*occ;\n    brdf += 0.10*dom*ambientLight*occ;\n    brdf += 1.0*bac*vec3(0.25,0.25,0.25)*occ;\n   \tbrdf += clamp(lightIntensity+pointLightInt*0.2,0.0,1.0)*fre*vec3(1.00,1.00,1.00)*occ;\n    brdf += 0.02;\n\tcol = col*brdf;\n    \n    return col + add;\n}\n//----------------------------------------------------------------------\nvec3 getColor(inout vec3 ro, vec3 rd, vec2 t)\n{\n  \tvec3 color = skyColor; \n \n   \tfloat mat =  t.y;\n   \tif (mat > 0.0) \n   \t{\n        vec3 hitPos = ro + rd * t.x;\n  \t\tvec3 normal = vec3(1,0,0);\n        vec3 add = vec3(0);\n        \n        if(mat == PlaneMatType)\n        {\n            normal = vec3(0,1,0);\n            color = planeColor;\n        }\n        else \n        {\n        \tnormal = normalize(getNormal(hitPos)); \n            add = vec3(smoothstep(0.6, 0.8, 1.0 - max(dot(-rd, normal), 0.0))); \n   \t\t\tif (mat == BodyMatType) \n   \t\t\t{\n\t\t    \tcolor = bodyColor;\n   \t\t\t}\n        \telse if(mat == DressMatType)\n        \t{\n            \tcolor = dressColor;\n        \t}\n        \telse if(mat == LampMatType)\n        \t{\n            \tfloat intensity = smoothstep(0.0, 2.0, lampLightIntensity);\n            \tfloat diff = max(clamp(intensity, 0.2, 1.0), dot(normal, lightDir));\n    \t\t\tfloat back = max(clamp(intensity, 0.2, 1.0), dot(normal, -lightDir));\n    \t\t\tfloat spec = pow(clamp(dot(lightDir, reflect(rd, normal)), 0.0, 1.0), 32.0);\n            \n            \tvec3 mate = lampLightColor * 0.9;\n            \tcolor = (diff + 0.5 * back) * mate + spec * vec3(1.0);\n        \t}\n        \telse if (mat == EyesMatType)\n        \t{\n            \tcolor = eyesColor;\n        \t}\n        \telse if (mat == TeethMatType)\n        \t{\n            \tcolor = teethColor;\n        \t}\n        }\n        \n        if(mat != LampMatType) {\t    \n    \t\tcolor = illum(hitPos, rd, normal, lightDir, color.rgb, t.x, mat, add);                   \n       \t}\n    }\n   \n  \treturn color;\n}\n\n//-------------------------------------------------\nvec2 render(in vec3 posOnRay, in vec3 rayDir)\n{ \n    vec2 t = vec2(0.0, bgMatType);\n    float maxDist = 25.0;\n    for(int i=0; i<MAX_ITER; ++i)\n    {\n        vec2 d = map(posOnRay + t.x*rayDir, true); \n        if (abs(d.x) < EPSILON || t.x > maxDist) \n            break;\n        t.x += d.x;\n        t.y = d.y;\n    }\n    return t;\n}\n//------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos     =  fragCoord.xy / iResolution.xy * 2. - 1.;\n    pos.x *= iResolution.x / iResolution.y;  \n       \n    vec3 camP = rotationCoordY(vec3(0., 0.4, 1.8), time);\n    vec3 camUp = vec3(0. , 1., 0.);\n    vec3 camDir = normalize(vec3(0.0, 0.3, 0.0)-camP);\n    vec3 u = normalize(cross(camUp,camDir));\n    vec3 v = cross(camDir,u);\n    vec3 rayDir = normalize(2. * camDir + pos.x * u + pos.y * v);  \n   \t \n    vec2 t =  render(camP, rayDir);  \n    vec3 color = getColor(camP, rayDir, t); \n    \n    // gamma\n\tcolor = pow( clamp( color, 0.0, 1.0 ), vec3(0.45) );\n    \n    // vignetting\n    pos*=0.35;\n    float distSqr = dot(pos, pos);\n\tfloat vignette = 1.0 - distSqr;\n    color *=  vignette;\n    \n    fragColor = vec4(color, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}