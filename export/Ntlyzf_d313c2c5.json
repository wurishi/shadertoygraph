{"ver":"0.1","info":{"id":"Ntlyzf","date":"1648451202","viewed":105,"name":"Fork GraphingSh MrHAX00 985","username":"MrHAX00","description":"A fork of my equation grapher that is plotting a song as if it was an equation after messing with coordinates a bit to get an interesting shape.","likes":3,"published":1,"flags":64,"usePreview":0,"tags":["math","visualizer","graphing","calculator","graphingcalculator","songvisualizer"],"hasliked":0,"parentid":"7djfzd","parentname":"GraphingShader"},"renderpass":[{"inputs":[{"id":"MlsSDs","filepath":"https://soundcloud.com/thatindiegamer/a-hat-in-time-ost-peace-and?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","previewfilepath":"https://soundcloud.com/thatindiegamer/a-hat-in-time-ost-peace-and?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define Zoom .5\n\n#define PlotColor vec3(1., 0., 1.)\n#define BgColor vec3(0.)\n#define GridColor vec3(.3, .5, .3)\n\n//Default equation and its variables:\n#define Equation texelFetch(iChannel0, ivec2(abs(uv.x) * 128., 0), 0).x\n\n//What the equation equals to:\n#define Equals length(vec2(mod(abs(uv.x), abs(uv.y)) * 10., uv.y * .1)) //this can be a number if you're trying to outline a shape\n\nbool RunEquation(vec2 fragCoord)\n{\n    bool HasNegative;\n    bool HasPositive;\n    \n    for (int X = -1; X < 2 && !(HasNegative && HasPositive); X += 2) {\n        for (int Y = -1; Y < 2 && !(HasNegative && HasPositive); Y += 2) {\n            vec2 uv = (fragCoord.xy + vec2(X, Y)) / iResolution.xy;\n            float AspectRatio = iResolution.x / iResolution.y;\n            uv.x *= AspectRatio;\n            uv -= vec2(AspectRatio * .5, .5);\n            uv /= Zoom;\n            uv *= 2.;\n            \n            float Result = Equation;\n            \n            HasNegative = HasNegative || (Result <= Equals);\n            HasPositive = HasPositive || (Result >= Equals);\n        }\n    }\n    \n    return HasNegative && HasPositive;\n}\n\nbool Grid(vec2 fragCoord)\n{\n    bool HasNegative;\n    bool HasPositive;\n    \n    for (int X = -1; X < 2 && !(HasNegative && HasPositive); X += 2) {\n        for (int Y = -1; Y < 2 && !(HasNegative && HasPositive); Y += 2) {\n            vec2 uv = (fragCoord.xy + vec2(X, Y)) / iResolution.xy;\n            float AspectRatio = iResolution.x / iResolution.y;\n            uv.x *= AspectRatio;\n            uv -= vec2(AspectRatio * .5, .5);\n            uv *= 2.;\n            uv /= Zoom;\n            uv = mod(uv, 2.) * 2. - 2.;\n            \n            float Result = uv.x * uv.y;\n            \n            HasNegative = HasNegative || (Result <= 0.);\n            HasPositive = HasPositive || (Result >= 0.);\n        }\n    }\n    \n    return HasNegative && HasPositive;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (RunEquation(fragCoord)) {\n        fragColor = vec4(PlotColor, 1.);\n    } else if (Grid(fragCoord)) {\n        fragColor = vec4(GridColor,1.);\n    } else {\n        fragColor = vec4(BgColor,1.);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define pi 3.14159","name":"Common","description":"","type":"common"}]}