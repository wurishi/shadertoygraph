{"ver":"0.1","info":{"id":"MtySzD","date":"1483739869","viewed":284,"name":"Spinning Top","username":"TekF","description":"A little experiment in non-realtime rendering - accumulate multiple passes in Buffer A with 1 trace per pass.\n\nGif of the result is here: http://68.media.tumblr.com/e8ef65794a5fbc3d65a96fc54c9ec2c7/tumblr_ojb81bxM8y1qkvfz2o1_400.gif","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","motionblur","offlinerender"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n\tfragColour = texture(iChannel0,fragCoord/iResolution.xy);\n    if ( fragColour.a < 1. ) discard;\n\tfragColour = pow(fragColour,vec4(1./2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int FRAME_PASSES = 32; // 3 at 60fps = realtime (50ms duration!)\nconst float FRAME_DURATION = 50./1000.; // animation wraps in 2 seconds\nconst float SHUTTER = FRAME_DURATION;//.88; // hide artefact I don't understand\n\nconst float tau = 6.2831853;\n\n\nmat3 TopTransform( in float time )\n{\n    float spin = time*tau*4.;\n    float precess = time*tau*.5;\n    \n    float judder = cos(spin*2.)*(cos(precess*3.+.6)*.5+.5); // should probably be == spin, but if we increase spin we lose detail in the blur - artistic license\n    \n    float tilt = .1+.02*judder;\n    \n    mat3 spinRot;\n    spinRot[0] = vec3( cos(spin), 0, sin(spin) );\n    spinRot[1] = vec3( 0, 1, 0 );\n    spinRot[2] = vec3(-sin(spin), 0, cos(spin) );\n    \n    mat3 tiltRot;\n    tiltRot[0] = vec3( cos(tilt),-sin(tilt), 0 );\n    tiltRot[1] = vec3( sin(tilt), cos(tilt), 0 );\n    tiltRot[2] = vec3( 0, 0, 1 );\n    \n    mat3 precessRot;\n    precessRot[0] = vec3( cos(precess), 0, sin(precess) );\n    precessRot[1] = vec3( 0, 1, 0 );\n    precessRot[2] = vec3(-sin(precess), 0, cos(precess) );\n    \n    return precessRot * tiltRot * spinRot;\n}\n\n\nfloat Top( out vec3 col, out float roughness, in vec3 pos, in float time )\n{\n    pos = pos * TopTransform( time );\n    \n    vec2 polar = vec2(length(pos.xz),pos.y);\n\n    float r = ( pos.y > .0 ) ? .6 : 1.5;\n    \n   \tfloat dist = pow(dot(pow(abs(polar),vec2(r)),vec2(1)),1./r)-.5;\n    \n    dist *= .2; // correct precision errors\n    \n    float blemishes = cos(pos.z*11.)*.5+.5;\n    float woodGrain = cos(pos.x*200.)*.5+.5;\n    \n    dist += blemishes*.0025;\n\n    dist = max( dist, pos.y-.4 ); // flatten spike\n    dist = max( dist, (polar.x+polar.y-.49)/2. ); // bevel\n\n    float a = atan(pos.x,pos.z);\n    col = cos(floor(-pos.y/.1-.01)*vec3(1,3,5)+vec3(0,0,3))*.5+.5;\n    \n    // pattern designed to look nice when motion-blurred!\n    float pattern = abs(abs(polar.x-.36)-abs(sin(a*1.5)+.3*sin(a*16.5))*.08)-.015;\n    col = mix( col, vec3(1), step( pattern, .0 ) );\n//\tcol = cos(floor(-(max(polar.x,polar.y) + abs(fract(8.*a/tau)-.5)*2.*.1)/.1-.03)*vec3(1,3,5)+vec3(0,0,3))*.5+.5;\n    \n    col *= mix( .6, 1., blemishes ); // blemishes\n    col *= mix( .9, 1., woodGrain ); // wood grain\n\n\troughness = mix( .0, .1, blemishes ) + mix( .0, .5, woodGrain );\n    \n//dist = length(pos)-.5;\n    return dist;\n}\n\n\nfloat hash( vec3 p )\n{\n\tp = fract(p/256.0);\n\n//\tfloat h = dot(p,(vec3(0.0,1.0,2.0)+phi))*tau;\n\tfloat h = dot(p,vec3(127.1,311.7,201.3));\n\t\n    return fract(sin(h)*43758.5453123);\n}\n\n\nvec3 Sky( vec3 r, float blurRadius )\n{\n    vec3 col = mix( vec3(0), vec3(2), exp2(-abs(r.y)/vec3(.1,.2,.5)) );\n    col = mix( vec3(.5), col, smoothstep(-blurRadius-.01,blurRadius+.01,r.y) );\n    col = mix( vec3(.1), col, smoothstep(-.5,-.45,r.y) ); // shadow of the top on the ground\n    return col;\n}\n\nvec3 Shade( vec3 p, vec3 n, vec3 i, vec3 albedo, float roughness, vec2 jitter, float time )\n{\n    vec3 sun = normalize(vec3(-2,2,2));\n    vec3 sunCol = vec3(1.5,1.3,1.15);\n\n    // shadow\n    jitter = (jitter-.5)*.1;\n    vec3 ii = normalize(cross(sun,vec3(0,1,0)));\n    vec3 jj = normalize(cross(sun,i));\n    vec3 shadowRay = sun + jitter.x*ii + jitter.y*jj;\n    float t=.1/dot(-i,n); // had some major self shadow problems but this seems to fix it\n\tfloat df=.0;\n    vec3 ignore; float ignore2;\n    for ( int i=0; i < 50; i++ )\n    {\n        df = Top( ignore, ignore2, p+shadowRay*t, time );\n        t += df;\n        if ( df < .01 || t > 4. ) break;\n    }\n\t\n    float shadow = step( .01, df );\n    \n    vec3 h = normalize(sun-i);\n    float specPower = exp2((1.-roughness)*12.);\n    float spec = pow(max(dot(h,n),.0),specPower) * specPower/32.0;\n    \n    vec3 ref = Sky(reflect(i,n),roughness);\n    ref += spec*sunCol*shadow;\n    \n    vec3 light = max(dot(n,sun),.0) * shadow * sunCol + vec3(.15,.2,.25);\n    \n    vec3 col = mix( albedo*light, ref, (1.-roughness)*mix( .01, 1., min( pow(dot(n,i)+1.,5.), 1. ) ) );\n//    col += spec*sunCol; //seems to disappear if I apply fresnel\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    int frame = iFrame/FRAME_PASSES;\n    int pass = iFrame - frame*FRAME_PASSES;\n    \n    float time = float(frame)*FRAME_DURATION;\n\ttime += (float(pass) + hash(vec3(fragCoord,pass)))*SHUTTER/float(FRAME_PASSES);\n\t// ^ why does pass - randomly distributed taps - get smoother result than frame? => phasing\n    \n    vec2 jitter = vec2( hash(vec3(fragCoord,pass).yzx), hash(vec3(fragCoord,pass).zxy) );\n    \n    vec3 ray;\n    ray.xy = (fragCoord.xy+jitter-.5-iResolution.xy*.5)/iResolution.y;\n//    if ( max(abs(ray.x),abs(ray.y)) > .5 ) discard;\n    ray.z = 2.5;\n    ray = normalize(ray);\n    \n    vec3 pos = vec3(0,1,-3);\n\n    vec3 target = vec3(0,0,0);\n\n    vec3 forward = normalize(target-pos);\n    vec3 right = normalize(cross(vec3(0,1,0),forward));\n    vec3 up = cross(forward,right);\n    ray = ray.x*right + ray.y*up + ray.z*forward;\n    \n    float tMax = 100000.;\n    float tGround = (-.5-pos.y)/ray.y;\n    \n    if ( tGround < .0 ) tGround = tMax;\n    \n    float t = length(pos)-1.; // I know I'm marching an object inside 1m from 0,0,0\n    float h = tMax;;\n    vec3 col = vec3(0);\n    float roughness = .0;\n    for ( int i=0; i < 200; i++ )\n    {\n        h = Top( col, roughness, pos+ray*t, time );\n        t += h;\n        if ( h < .001 || t > tGround ) break;\n    }\n    \n    pos = pos+ray*(min(t,tGround));\n    \n    vec3 n = vec3(0,1,0); // ground\n    if ( h < .001 )\n    {\n\t    vec2 d = vec2(-1,1)*.0001;\n        vec3 ignore; float ignore2;\n\t    n = normalize(\n            \t\tTop(ignore,ignore2,pos+d.xxx,time)*d.xxx +\n            \t\tTop(ignore,ignore2,pos+d.yyx,time)*d.yyx +\n            \t\tTop(ignore,ignore2,pos+d.yxy,time)*d.yxy +\n            \t\tTop(ignore,ignore2,pos+d.xyy,time)*d.xyy\n            \t);\n\t}\n    else\n    {\n        //if ( t < tMax )\n        col = vec3(.5);\n        roughness = .5;\n        //else col = vec3(.2,.4,1);\n    }\n\n\tcol = Shade( pos, n, ray, col, roughness, jitter, time );\n\n    \n/*    float t;\n    vec3 col;\n    Top(t,col,vec3(ray.xy,.0),iTime);\n    col = mix( col, vec3(1), smoothstep(-.1,.1,t) );*/\n    \n\tfragColour = texture(iChannel0,fragCoord/iResolution.xy);\n    if ( pass == 0 ) fragColour = vec4(0);\n    fragColour += vec4(col / float(FRAME_PASSES),1.0);\n    \n    fragColour.a = 0.;\n    if ( pass == FRAME_PASSES-1 ) fragColour.a = 1.;\n}\n\n\n","name":"Buf A","description":"","type":"buffer"}]}