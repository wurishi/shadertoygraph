{"ver":"0.1","info":{"id":"fsf3W7","date":"1616016359","viewed":100,"name":"Pathtracing Example","username":"bobcao3","description":"An small example pathtracer","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["pathtracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nstruct Ray\n{\n    vec3 o;\n    vec3 dir;\n    float min_t;\n    float max_t;\n};\n\nstruct Sphere\n{\n    vec3 o;\n    float r;\n    \n    vec3 albedo;\n    vec3 emission;\n};\n\nstruct Plane\n{\n    vec3 p;\n    vec3 n;\n\n    vec3 albedo;\n    vec3 emission;\n};\n\nstruct Intersection\n{\n    vec3 pos;\n    vec3 normal;\n    vec3 albedo;\n    vec3 emission;\n};\n\nbool sphere_intersection_test(in Sphere s, in Ray r, inout float t1, inout float t2) {\n    float a = dot(r.dir, r.dir);\n    float b = dot(2.0 * (r.o - s.o), r.dir);\n    float c = dot((r.o - s.o), (r.o - s.o)) - s.r * s.r;\n    float det = b * b - 4.0 * a * c;\n    \n    if (det >= 0.0)\n    {\n        float t_pls = (-b + sqrt(det)) / (2.0 * a);\n        float t_min = (-b - sqrt(det)) / (2.0 * a);\n\n        if (t_pls < t_min)\n        {\n            t1 = t_pls;\n            t2 = t_min;\n        } else {\n            t1 = t_min;\n            t2 = t_pls;\n        }\n        return true;\n    }\n\n    return false;\n}\n\n\nbool intersect_sphere(in Sphere s, inout Ray r, out Intersection i) {\n    float t1, t2;\n\n    if (!sphere_intersection_test(s, r, t1, t2)) return false;\n    t1 = t1 < r.min_t ? t2 : t1;\n    if (t1 < r.min_t || t1 > r.max_t) return false;\n\n    i.pos = r.o + r.dir * t1;\n    i.normal = normalize(i.pos - s.o);\n    r.max_t = t1;\n    i.albedo = s.albedo;\n    i.emission = s.emission;\n\n    return true;\n}\n\nbool intersect_plane(in Plane p, inout Ray r, out Intersection i)\n{\n    if (dot(p.n, r.dir) == 0.0) return false;\n    \n    float t = -dot(p.n, r.o - p.p) / dot(p.n, r.dir);\n    \n    if (t < r.min_t || t > r.max_t) return false;\n    \n    i.pos = r.o + r.dir * t;\n    i.normal = p.n;\n    r.max_t = t;\n    i.albedo = p.albedo;\n    \n    return true;\n}\n\nvoid generate_camera_ray(in vec2 imageCoord, out Ray r)\n{\n\n    vec3 camera_origin = vec3(0.0, 0.0, -4.0);\n    vec3 camera_direction = vec3(0.0, 0.0, -1.0);\n    vec3 camera_up_vec = vec3(0.0, 1.0, 0.0);\n    vec3 camera_right_vec = cross(camera_direction, camera_up_vec);\n    \n    float fov = 70.0;\n\n    imageCoord /= iResolution.xy;\n    imageCoord = imageCoord * 2.0 - 1.0;\n    imageCoord.y *= iResolution.y / iResolution.x;\n\n    vec3 camera_space_pixel = vec3(imageCoord * tan(fov * 0.5), -1.0);\n    r.o = camera_origin;\n    r.dir = mat3(camera_right_vec, camera_up_vec, camera_direction) * normalize(camera_space_pixel);\n    r.min_t = 0.0001;\n    r.max_t = 1000.0;\n}\n\nvoid intersect_scene(inout Ray r, inout Intersection i)\n{\n    Sphere s0;\n    s0.o = vec3(-0.3, -0.3, 0.0);\n    s0.r = 0.3;\n    s0.albedo = vec3(0.8);\n    s0.emission = vec3(0.0);\n\n    Sphere s1;\n    s1.o = vec3(0.5, -0.2, -0.1);\n    s1.r = 0.4;\n    s1.albedo = vec3(0.0, 0.4, 1.0);\n    s1.emission = vec3(0.0);\n    \n    Sphere s2;\n    s2.o = vec3(0.0, 0.7, -0.1);\n    s2.r = 0.2;\n    s2.albedo = vec3(0.0);\n    s2.emission = vec3(10.0);\n    \n    Plane p1;\n    p1.p = vec3(0.0, -0.55, 0.0);\n    p1.n = vec3(0.0, 1.0, 0.0);\n    p1.albedo = vec3(0.9, 0.7, 0.5);\n    p1.emission = vec3(0.0);\n\n    intersect_sphere(s0, r, i);\n    intersect_sphere(s1, r, i);\n    intersect_sphere(s2, r, i);\n    intersect_plane(p1, r, i);\n}\n\nfloat seed;\n\nvec3 skyColor = vec3(0.0);\n\nvec3 lambertian_bsdf(vec3 albedo)\n{\n    return albedo / PI;\n}\n\nvec3 est_radiance_global_illumination(in Intersection i)\n{\n    int depth = 0;\n    \n    const int max_depth = 5;\n    \n    if (i.emission.r > 0.0) return i.emission;\n        \n    vec3 pos = i.pos;\n    vec3 normal = i.normal;\n    vec3 albedo = i.albedo;\n    vec3 Li = vec3(0.0);\n    \n    vec3 L_out = vec3(1.0);\n    \n    while (depth < max_depth)\n    {\n        Intersection i_next;\n        Ray r_next;\n\n        vec2 uniform_2d_sample = hash21(seed); seed++;\n        vec3 hemisphere_sample = uniform_sample_hemisphere(uniform_2d_sample);\n        \n        float pdf = 1.0 / (2.0 * PI);\n\n        mat3 o2w = make_coord_space(normal);\n\n        r_next.o = pos;\n        r_next.dir = o2w * hemisphere_sample;\n        r_next.min_t = 0.0001;\n        r_next.max_t = 1000.0;\n\n        intersect_scene(r_next, i_next);\n\n        depth++;\n        \n        bool terminate = false;\n\n        // No intersection\n        if (r_next.max_t >= 1000.0)\n        {\n            Li = skyColor;\n            terminate = true;\n        }\n        else\n        {\n            Li = i_next.emission;\n            if (Li.r > 0.0) terminate = true;\n        }\n\n        L_out *= lambertian_bsdf(albedo) * hemisphere_sample.z / pdf;\n\n        pos = i_next.pos;\n        normal = i_next.normal;\n        albedo = i_next.albedo;\n\n        if (terminate) break;\n    }\n    \n    return L_out * Li;\n}\n\nvec3 raytrace_pixel(in vec2 imageCoord)\n{\n    vec3 sum = vec3(0.0);\n    \n    const int num_samples = 16;\n    \n    for (int k = 0; k < num_samples; k++)\n    {\n        vec2 random_offset = hash23(vec3(imageCoord, k + (iFrame & 0xFF)));\n    \n        Ray r;\n        generate_camera_ray(imageCoord + random_offset, r);\n\n        Intersection i;\n\n        intersect_scene(r, i);\n\n        if (r.max_t >= 1000.0)\n        {\n            sum += skyColor;\n        }\n        else\n        {\n            sum += est_radiance_global_illumination(i);\n        }\n    }\n    \n    return sum / float(num_samples);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = hash13(vec3(fragCoord, iFrame));\n    fragColor = vec4(pow(raytrace_pixel(fragCoord), vec3(1.0 / 2.2)), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Hash functions. Credit : 2014 David Hoskins.\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n// Sampling functions\n\nconst float PI = 3.1415926;\n\nvec3 uniform_sample_hemisphere(vec2 u)\n{\n    float r = sqrt(1.0f - u.x * u.x);\n    float phi = 2.0 * PI * u.y;\n \n    return vec3(cos(phi) * r, sin(phi) * r, u.x);\n}\n\nmat3 make_coord_space(vec3 n) {\n    vec3 h = n;\n    if (abs(h.x) <= abs(h.y) && abs(h.x) <= abs(h.z))\n        h.x = 1.0;\n    else if (abs(h.y) <= abs(h.x) && abs(h.y) <= abs(h.z))\n        h.y = 1.0;\n    else\n        h.z = 1.0;\n\n    vec3 y = normalize(cross(h, n));\n    vec3 x = normalize(cross(n, y));\n\n    return mat3(x, y, n);\n}","name":"Common","description":"","type":"common"}]}