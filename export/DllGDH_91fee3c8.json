{"ver":"0.1","info":{"id":"DllGDH","date":"1673164306","viewed":94,"name":"Ocean t1","username":"Rugged","description":"try one with ocean sdf","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\nfloat hash3(vec2 xy){\n    xy = mod(xy, .19);\n    float h = dot(xy.yyx, vec3(.013, 27.15, 2027.3));\n    h *= h;\n    h *= fract(h);\n    \n    return fract(h);\n}\n\n\n\nfloat waveFunction(vec3 p){\n    p.xy += mod(iTime, 12.56);\n    return (.2 * (sin(p.x) * sin(p.y))) + (.05 * sin(2. * p.x) * sin(4. * p.y) + (1. * sin(.5 * p.x))) + cos(.5 * p.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvc = 2. * (uv - .5);\n    \n    \n    vec4 col = vec4(0.);\n\n    \n    \n    \n    \n    \n    \n    \n    //get the mouse location for look direction unless mouse is not down\n    vec2 muv = iMouse.z > 0.0 ? iMouse.xy / iResolution.xy : vec2(0.5, 0.5);\n    \n        \n    \n    float screenRatio = iResolution.y / iResolution.x;\n    \n    //Setting up the ray directions and other information about the point and camera\n    //##############################################################################\n    \n    \n    //camera direction angles phi (xy plane) and theta (xz plane)\n    //float phi = radians(180.);\n    //float theta = radians(105.);\n    float phi = radians(360. * (muv.x - 1.));\n    float theta = radians(180. * (1. - muv.y));\n\n    //get the camera direction as the basis for the rotation (each ray direction is a rotation of the camera direciton vector)\n    //it is in quarternion form here so its a vec4 instead of a vec3\n    vec4 camD = vec4(0., cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta));\n    \n    \n    \n    \n    \n    \n    vec3 p = vec3(10., 0., 1.);\n\n    \n    \n    //rayD efficient\n    vec3 up = vec3(0., 0., 1.);\n    \n    vec3 U = normalize(cross(up, camD.yzw));\n    vec3 V = normalize(cross(camD.yzw, U));\n    \n    vec3 rayD = normalize(camD.yzw + uvc.x*U + uvc.y*V);\n    \n    \n    //###############################\n    \n    \n    \n    \n    vec4 water = 1.5 * vec4(.3, .65, .8, 1.);//2.35 * vec4(.0, .5059, .6157, 1.);\n    \n    vec4 sky = vec4(.5, .65, .9, 1.);\n    \n    \n    \n    col = sky * (1.4 - abs(dot(rayD, vec3(0., 0., 1.))));\n    \n    \n    vec3 lightD = normalize(vec3(1., 1., 1.));//normalize(vec3(sin(iTime), cos(iTime), 1.));\n    \n    \n    \n    vec3 rightep = vec3(.00001, .0, .0);\n    vec3 forep = vec3(.0, .00001, .0);\n    \n    vec3 center = vec3(-1., 0., 0.);\n    \n    \n    float amp = 1.;\n    \n    vec3 h;\n    \n    for(int i = 0; i < 1000; i++){\n        p += rayD * (float(i) * .01);\n        \n        h = vec3(p.xy, waveFunction(p));\n        \n        \n        \n        if(p.z < h.z){\n            \n            \n            vec3 hr = vec3(p.xy + rightep.xy, waveFunction(p + rightep));\n            vec3 hf = vec3(p.xy + forep.xy, waveFunction(p + forep));\n        \n            vec3 norm = normalize(cross(hr - h, hf - h));\n            \n            col = (water + vec4(max(h.z, -.5))) * (dot(norm, lightD) + .1);//pow(dot(normalize(vec3(amp * cos(p.x) * sin(p.y), amp * sin(p.x) * cos(p.y), 1.)), lightD), 2.);\n            break;\n        }\n        \n    }\n    \n    \n    \n    \n    \n    //col = uv.y > .9 ? vec4(iFrameRate / 144.) : col;\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}