{"ver":"0.1","info":{"id":"l33SR8","date":"1718575500","viewed":67,"name":"Real-Time 2D SDF Generation","username":"MediocreProgrammer","description":"New version at https://www.shadertoy.com/view/lX3Sz8\nGenerates a signed distance field for a texture. This only works well if you only need a limited range (e.g., distances clamped between -40 and 40). Hopefully this is fast enough to run in real time.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nBasic idea:\nThis uses a \"kernel\" based on the formula (254/255)^x^2. The idea\nis to apply this kernel in the x direction and then in the y direction,\nsimilar to a two-pass Gaussian blur filter. We then compute the distance\nusing the same principle as the fact that e^x^2 * e^y^2 = e^r^2, where\nr is distance.\n\nInstead of taking a weighted sum, we take the maximum of the weighted\nvalues.\n*/\n\n/* JavaScript code to compute the kernel:\nRANGE = 40\nf = (x) => (254 / 255) ** x ** 2\nmiddleValue = f(0)\nkernel = []\nfor (let x = 0; x <= RANGE; ++x) {\n    kernel.push(f(x) / middleValue)\n}\nconsole.log(JSON.stringify(kernel))\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 distance = min(sqrt(log(texture(iChannel0, uv).rgb) / log(254.0 / 255.0)), 40.0);\n    float signedDistance = max(0.0, distance.r - 0.5) - max(0.0, distance.g - 0.5);\n    \n    // Display different effects\n    \n    vec3 color;\n    if (uv.x >= 0.5)\n    {\n        if (uv.y >= 0.5)\n        {\n            color = vec3(clamp(signedDistance - 14.5, 0.0, 1.0));\n            color = pow(color, vec3(1.0 / 2.2)); // Adjust for gamma\n            color = 0.5 * (1.0 - color);\n            color = max(color, texture(iChannel1, uv).b);\n        }\n        else\n        {\n            float edgeDistance = 38.5 * sin(iTime);\n            color = vec3(clamp(signedDistance - edgeDistance, 0.0, 1.0));\n            color = pow(color, vec3(1.0 / 2.2));\n        }\n    }\n    else\n    {\n        color = vec3(signedDistance / 80.0 + 0.5);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n    color = fract(color + 0.05 * iTime);\n    vec3 quantized = round(color);\n    float level = max(quantized.r, max(quantized.g, quantized.b));\n    quantized = vec3(level, 1.0 - level, level);\n    fragColor = vec4(quantized, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 step = vec2(1.0, 0.0) / iResolution.xy;\n\n    vec3 mult = KERNEL[0] * texture(iChannel0, uv).rgb;\n    for (int i = 1; i < KERNEL.length(); ++i)\n    {\n        vec2 offset = float(i) * step;\n        mult = max(mult, KERNEL[i] * texture(iChannel0, uv + offset).rgb);\n        mult = max(mult, KERNEL[i] * texture(iChannel0, uv - offset).rgb);\n    }\n    \n    fragColor = vec4(mult, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 step = vec2(0.0, 1.0) / iResolution.xy;\n\n    vec3 mult = KERNEL[0] * texture(iChannel0, uv).rgb;\n    for (int i = 1; i < KERNEL.length(); ++i)\n    {\n        vec2 offset = float(i) * step;\n        mult = max(mult, KERNEL[i] * texture(iChannel0, uv + offset).rgb);\n        mult = max(mult, KERNEL[i] * texture(iChannel0, uv - offset).rgb);\n    }\n    \n    fragColor = vec4(mult, 1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"precision highp float;\n\nconst float KERNEL[41] = float[](\n    1.0,0.996078431372549,0.9844057566951817,0.9652544793290659,0.9390669996041341,0.9064386277579967,0.8680950957248768,0.8248657535527912,0.777653831132208,0.7274052497361709,0.6750774769775312,0.6216098368991172,0.5678965244368839,0.5147633463191046,0.46294893830396855,0.413090913182315,0.3657170968801502,0.32124173124212957,0.27996627840760907,0.24208426559417132,0.20768946824538442,0.17678664663893723,0.14930402439549423,0.1251067212415627,0.104010418333296,0.08579463209583527,0.07021509078781903,0.05701483601901422,0.045933799439480005,0.03671672463332555,0.029119409736391436,0.022913333420282594,0.0178887936502542,0.013856734842271522,0.010649465991656655,0.008120482370291164,0.006143599509285771,0.004611593714839341,0.0034345216041370523,0.0025378651315172817,0.0018606209110409485\n);\n","name":"Common","description":"","type":"common"}]}