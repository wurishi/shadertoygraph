{"ver":"0.1","info":{"id":"WlySRw","date":"1584694230","viewed":157,"name":"Budgeted Disk Sampling Pattern","username":"iradicator","description":"Construction of a normalized uniform disk sampling pattern while conforming to a given tap budget.\n\nFor more details, check out my blog post: https://iradicator.com/normalized-uniform-disk-pattern/","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","math","sampling","pattern","disk"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define MAX_FLT 3.402823e+38\n#define EPSILON 1.192093e-07\n\n//////////////\n// Controls //\n//////////////\n\nint T = 150; // 1, 7, 19, 37, 61, 91, 127 ...\nint S = 6;\n\n////////////////////\n// Final Approach //\n////////////////////\n\nint N(int L, int S)\n{\n    return ((L * L + L) >> 1) * S + 1;\n}\n\nint ring_index(int i, int S)\n{\n    int x2S = 2 * i - 2;\n    int l = int(sqrt(max(0.0, float(x2S) / float(S))));    \n    if (x2S >= ((l * l + l) * S)) ++l;\t\n    return l;\n}\n\nvec2 disk(int i, int L, int S)\n{    \n\tint l = ring_index(i, S);\n    float r = float(l) / (float(L-1) + EPSILON);       \n    float theta = (2.0 * PI * float(i)) / (float(S * l) + EPSILON);\n    return r * vec2(cos(theta), sin(theta));    \n}\n\n////////////////////\n// Driver Program //\n////////////////////\n\nfloat sdDisk(vec2 p, int L, int S)\n{\n    float d = MAX_FLT;    \n    for (int i = 0; i < N(L-1,S); ++i)\n    {                     \n        vec2 q = disk(i, L, S);\n        d = min(d, length(p - q));        \n    }\n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat aspect = iResolution.x / iResolution.y;\n    vec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n    uv *= 1.2 * vec2(aspect, 1.0);\n\n    // Finds the ring count within a maximum tap budget T.\n    int L = ring_index(max(1,T), S);\n    \n    float d = sdDisk(uv, L, max(1,S));\n    d = step(0.01, d);\n\t\n    vec3 bg_col = vec3(61, 15, 43) / 255.0;\n    vec3 fg_col = vec3(255, 246, 143) / 255.0;\n    vec3 col = mix(fg_col, bg_col, d);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}