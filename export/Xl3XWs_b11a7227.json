{"ver":"0.1","info":{"id":"Xl3XWs","date":"1619216927","viewed":66,"name":"specular curved box..","username":"bolloxim","description":"specular highlight on curved edged","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["specular","box","curved"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Andi Smithers \n// button shader for smooth border edges\n// could also add shadow and shine effect as well using \n\nfloat Specular (vec3 normal)\n{\n    vec3 vLight = normalize(vec3(0.2,1.0,-0.2));\n    \n    float sp = pow(clamp(dot(vLight,reflect(vec3(0.0,0.0,1.0),normal)),0.0,1.0),25.0);\n    return sp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uniforms\n    float borderSize = 0.15;\n    float antiAliasSize = 0.02;\n    vec4 borderColor = vec4(0.8,0.9,1.0, 1);\n    vec4 centreColor = vec4(0.1,0.5,0.9,1);\n    float wobbly = iTime;\n\tfloat rounding = sin(wobbly)*3.0+4.0;\n    vec2 shadowVec = vec2(-0.05, 0.15);\n    float scaleBox = 1.2;\n\n    // alias thickness\n    float aascalar = 1.0 / antiAliasSize;\n    float outerAlias = 1.0 - antiAliasSize;\n\n    // convert UV into normalized coord\n    vec2 iuv = fragCoord.xy / iResolution.xy;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    vec2 uvUnit = (uv*2.0-1.0) * scaleBox;\n    vec2 signUv = sign(uvUnit);\n    vec2 shadowUnit = uvUnit + shadowVec;\n\n    // rounded edge - have to abs the value incase shader doesnt support negative powers\n    uvUnit = pow(abs(uvUnit), vec2(rounding)) * signUv;\n    shadowUnit = pow(abs(shadowUnit), vec2(rounding));\n    \n    // compute border\n    float borderEdge = pow(1.0-borderSize, rounding);\n    float borderAlias = borderEdge - antiAliasSize;\n    \n    // edge\n    float edge = length(uvUnit);\n    float outer = 1.0-(clamp(edge, outerAlias, 1.0)-outerAlias) * aascalar;\n    float inner = 1.0-(clamp(edge, borderAlias, borderEdge)-borderAlias) * aascalar;\n    float shadowInner = 1.0-(clamp(length(shadowUnit), borderAlias, borderEdge)-borderAlias) * aascalar;\n    float shadowOuter = 1.0-(clamp(length(shadowUnit), outerAlias, 1.0)-outerAlias) * aascalar;\n    \n    // blow out outer then chose minimum this ensures a mask around the alpha output\n    float outermask = min(outer*1000.0, 1.0);\n    \n    // fetch image and poor mans chromakey alpha\n    vec4 image = texture(iChannel0, iuv);\n    float alpha = length(image.rgb-vec3(0,1,0));\n    alpha = alpha> 0.5 ? 1.0 : 0.0;\n\n    // shadow\n    float shade = shadowInner<0.9 ? 0.8 + shadowInner*0.2: 1.0;\n    float shadeOut = shadowOuter>0.5 ? 0.0 + shadowOuter*0.2: 0.0;\n\t\n        \n    // blend inner/outer and image with image alpha\n    vec4 color = (centreColor*inner*(1.0-alpha)+image*alpha*inner)*shade + borderColor*(1.0-inner)*outermask;\n    color.a =  max(outer, shadeOut);\n    \n    // blend against a background texture - because shadertoy\n    vec4 background = texture(iChannel1, iuv);\n        \n    vec3 vNormal = normalize(vec3(uvUnit.x*inner,uvUnit.y*inner,sqrt(clamp(1.0-uvUnit.x*uvUnit.x+uvUnit.y*uvUnit.y,0.0,1.0))));\n    float spec = Specular(vNormal);\n    // and set the final color \n    fragColor = (color*color.a) + background*(1.0-color.a) + spec*vec4(1.0,1.0,1.0,0.0);\n}","name":"Image","description":"","type":"image"}]}