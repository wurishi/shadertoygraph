{"ver":"0.1","info":{"id":"wlcXRS","date":"1581184885","viewed":1325,"name":"Basic : Voronoi Tracking 1buff","username":"FabriceNeyret2","description":"Variant of Gijs' [url]https://shadertoy.com/view/WltSz7[/url]\nusing one single buffer, with only 2 small zones used for particles and Voronoi buffer. ( #iRes1/2 in Common)\nCan also choose the length of closest lists stored ( #LIST in Common ). default: 2","likes":39,"published":3,"flags":32,"usePreview":0,"tags":["2d","voronoi","simulation","particles","voronoiparticlestracking"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of Gijs' https://shadertoy.com/view/WltSz7\n// using one single buffer (  with only 2 small zones used for particles and Voronoi buffer: #iRes1/2 in Common)\n// Can also choose the length of closest lists stored ( #LIST in Common )\n// (see discussion for limits).\n\n// === Display\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    \n    fragColor = vec4(0);\n\n    //get the id's of the 4 particles that (should be) closest.\n    //the 4 ids are stored in .x, .y, .z, .w\n    ivec4 ids = getClosestS(ivec2(fragCoord));\n    \n    //draw the particles\n        for(int i = 0; i < 4; i++){\n            //get the particles position\n            int id = ids[i];\n            vec2 pos = getParticle(id).xy;\n\n            //get the distance to the particle\n            float d = distance(fragCoord,pos);\n\n            //color it\n            fragColor += .3/(d*d);\n        }\n    \n    //draw voronoi outlines\n        //get the position of the closest particle\n    \tvec2  p1 = getParticle(ids.x).xy;\n        //get the position of the second closest particle\n\t\tvec2  p2 = getParticle(ids.y).xy;\n        //get the distance to voronoi edge\n        float r = dot(fragCoord-(p1+p2)/2.,normalize(p2-p1));\n        fragColor += smoothstep(2.,0.,abs(r))*.3;\n    \n    //fragColor += vec4(ids/float(PARTICLES));\n    \n    vec2  _m0 = fragCoord-iResolution1, _m = fragCoord-ofs2-iResolution2;  // display maps\n    if ( max(_m0.x,_m0.y) < 0. || ( fragCoord.x>iResolution1.x && max(_m.x,_m.y) < 0.) )\n        fragColor += (1.-fragColor.a) * .5*texelFetch(iChannel0, ivec2(fragCoord), 0) \n                                            / ( fragCoord.x < ofs2.x ? .2*iResolution.x: float(PARTICLES) )\n                     + vec4(0,0,.3,0);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// one single buffer Fork of Gijs' https://shadertoy.com/view/WltSz7\n\n// The code is not optimized for speed; it turns out programming with integers can be slow on some GPU's.\n// The reason I still use them is readability of the code.\n\n//amount of particles\nconst int PARTICLES = 1000; \n\n//percentage of maximum allowed speed\nconst float SPEED = 1.;\n\n\n#define iResolution1 (iResolution.xy/4.)  // slot allocated for Particle Buffer \n#define iResolution2 (iResolution.xy/4.)  // slot allocated for Voronoi Buffer\n#define ofs2     vec2(iResolution1.x,0)\n// --- chose length of closest LIST\n//#define LIST xxxx    //  1 (not enough for repulsion & draw voronoi)\n  #define LIST xyyy    //  2\n//#define LIST xyzz    //  3\n//#define LIST xyzw    //  4\n\n// --- Particle Buffer part:\n// in this buffer every pixel represents a particle\n// the particles positions is stored in .xy\n//           its velocity  is stored in .zw\n// Only the first PARTICLES amount of pixels are actually used.\n\n// --- Voronoi Buffer part:\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\n\n//returns the ids of the four closest particles from the input\n//    if (xy != ivec2(clamp(vec2(xy),vec2(0),iResolution2)) ) return ivec4(0);\n#define getClosest(xy) /* xy: location within Voronoi Buffer */ \\\n    ivec4(texelFetch(iChannel0, ivec2(ofs2+vec2(xy)), 0).LIST) // was channel1\n\n#define getClosestS(pos) getClosest(ivec2(vec2(pos)/iResolution.xy*iResolution2))\n        \n//returns the location of the particle within the particle buffer corresponding with the input id \n#define locFromID(id) ivec2( (id) % int(iResolution1.x), (id) / int(iResolution1.x))\n\n//get the particle corresponding to the input id\n#define getParticle(id) texelFetch(iChannel0, locFromID(id), 0)\n\n\n\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// one single buffer Fork of Gijs' https://shadertoy.com/view/WltSz7\n\nfloat distance2Particle(int id, vec2 worldCoord){ // screen coords\n    if(id==-1) return 1e20;\n    vec2 delta = getParticle(id).xy-worldCoord;\n    return dot(delta, delta);\n}\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_){\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n    i = i.LIST; d = d.LIST;\n}\n\n// =========================================================\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    ivec2 iFragCoord = ivec2(fragCoord);\n\n// === main Particle Buffer part\nvec2 _m = fragCoord.xy-iResolution1; if (max(_m.x,_m.y)<0.) {\n        \n    //we only simulate PARTICLES amount of particles\n    int id = iFragCoord.x + iFragCoord.y*int(iResolution1.x);\n    if(id>=PARTICLES) return;\n    \n    vec4 prev = texelFetch( iChannel0, ivec2(fragCoord), 0 );\n    vec2 pos = prev.xy;   // screen coords\n    vec2 vel = prev.zw;\n     \n    if(iFrame==0){\n       \t//pick a \"random\" starting position\n        float h1 = hash(id);\n        float h2 = hash(int(h1*41343.));\n        pos = vec2(h1,h2)*iResolution.xy;  // screen coordinates\n        //fragColor = vec4(pos, 0,0); return;\n    }\n\n    //gather forces\n    vec2 force = vec2(0);\n    \n        //friction\n        force -= vel*0.2;\n\n        //interaction\n        if(iMouse.z > 0.){\n            vec2 delta = pos-iMouse.xy;\n            float dis = length(delta);\n            force += delta/(dis*dis) * 10.;\n        }\n\n       //repulsion from others\n        ivec4 closest = getClosest(ivec2(pos/iResolution.xy*iResolution2)); // conv to voronoi coord\n        for(int i = 0; i < 4; i++){\n            int cid = closest[i];\n            if(cid==id) continue; // not always working ? (but for list length<3)\n            \n            vec2 delta = pos-getParticle(cid).xy;\n            float dis = length(delta)+1e-5; // was sometime 0 !\n            force += delta /(dis*dis*dis) * 30.;\n        }\n    \n    \t//repulsion from walls\n    \tvec2 dis = max(iResolution.xy-pos, vec2(1));\n    \tforce -= 1./(dis*dis) * 10.;\n    \t     dis = max(pos, vec2(1));\n    \tforce += 1./(dis*dis) * 10.;\n\n    //integrate forces\n    vel += force;\n    \n    //cap velocity at max speed\n    float dv = length(vel);\n    if(dv>SPEED) vel *= SPEED/dv;\n    \n    //integrate velocity\n    pos += vel;\n    \n    fragColor = vec4(pos,vel); return;\n}\n\n// === main Voronoi Buffer part\n_m = fragCoord.xy-ofs2-iResolution2; if (fragCoord.x>=iResolution1.x && max(_m.x,_m.y)<0.) {   \n    \n    //if(iFrame==0){ fragColor = vec4(0); return; }\n    ivec2 iFragCoord = ivec2(fragCoord-ofs2);\n    vec2 worldCoord = (fragCoord-ofs2)/iResolution2 * iResolution.xy;\n    \n    //in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    //in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e20);\n    \n    //get all known closest particles from old self and neighbours\n    ivec4 old   = getClosest( iFragCoord + ivec2( 0, 0) );            \n    ivec4 east  = getClosest( iFragCoord + ivec2( 1, 0) );\n\tivec4 north = getClosest( iFragCoord + ivec2( 0, 1) );\n    ivec4 west  = getClosest( iFragCoord + ivec2(-1, 0) );\n    ivec4 south = getClosest( iFragCoord + ivec2( 0,-1) );\n    //collect them in a array so we can loop over it\n    ivec4[5] candidates = ivec4[5](old, east, north, west, south); \n    \n    for(int i=0; i<5; i++){\n        for(int j=0; j<4; j++){\n            int id = candidates[i][j];\n            float dis2 = distance2Particle(id, worldCoord); // to screen\n            insertion_sort( new, dis, id, dis2 );\n        }\n    }\n    \n    for(int k = 0; k < 1; k++){\n        //random hash. We should make sure that two pixels in the same frame never make the same hash!\n        float h = hash(\n            iFragCoord.x + \n            iFragCoord.y*int(iResolution2.x) + \n            iFrame*int(iResolution2.x*iResolution2.y) +\n            k\n        );\n        //pick random id of particle\n        int p = int(h*float(PARTICLES));\n        insertion_sort(new, dis, p, distance2Particle(p, worldCoord) );\n    }\n    \n    fragColor = vec4(new);   \n}\n}","name":"Buffer A","description":"","type":"buffer"}]}