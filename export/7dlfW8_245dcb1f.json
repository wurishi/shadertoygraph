{"ver":"0.1","info":{"id":"7dlfW8","date":"1644828775","viewed":290,"name":"loopless convol/filter w. MIPmap","username":"FabriceNeyret2","description":"loopless filter:\nGenerates 32x32 imagelets of F1 * F2 with the different offsets, with F1 and F2 two 32x32 images.\nMIPmap level 6 automatically does the sum.\nYou could easily adapt for bigger image * smaller filter.\nClick to see the buffer content.\n","likes":7,"published":3,"flags":0,"usePreview":0,"tags":["filter","convolution","loopless","gpmipmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// === display result of convolution, or buffer content if click.\n// loop version for comparison: see https://www.shadertoy.com/view/7ssfDH\n\nvoid mainImage( out vec4 O, vec2 u ) \n{\n    vec2  R = iResolution.xy,\n          U = ( 2.*u - R ) / R.y;\n          \n    O = textureLod( iChannel0, vec3(U,1), iMouse.z<=0. ? 6. : 0. );\n    \n    if ( iMouse.z<=0. ) O /= 1.1*textureLod( iChannel0, vec3(0,0,1), 10.).a;\n    // don't put the .a if you want normalization per channel\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"// select your images to convolute. or image + filter\n\n//#define F1(U)  vec4(1)\n  #define F1(U)  texture(iChannel2, U )\n//#define F1(U)  texture(iChannel2, clamp(U,0.,1.))\n  \n//#define F2(U)  vec4( smoothstep(.5,0.,  length(U-.5) ) ) // ~Gaussian\n  #define F2(U)  vec4( smoothstep(.25,0., abs( length(U-.5) -.25 ) ) ) // ring\n\n\nvoid mainCubemap( out vec4 O, vec2 U, vec3 o, vec3 D )\n{\n    O-=O;\n    if ( D.z < max(abs(D.x),abs(D.y)) ) return;\n    U.y = 1024. - U.y;               // like buffA, but 1024 x 1024.\n//  --------------------------------\n\n    vec4 f1 = F1( fract(U/32.) ),\n       //f2 = F2( floor(U/32.)/32.*2.-1. + fract(-U/32.));\n         f2 = F2( fract(U/32.)*2.-1. + 1.-floor(U/32.)/32.);\n    O = f1*f2;                       // convolution contribution\n                                     // sum in MIPmap LOD 6\n                                     \n    O.a = max(O.r, max(O.g,O.b));    // for normalization\n // f2 = F2( fract(U/32.) );\n // O.a = max(f2.r, max(f2.g,f2.b)); // for normalization\n}","name":"Cube A","description":"","type":"cubemap"}]}