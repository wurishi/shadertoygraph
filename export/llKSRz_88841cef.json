{"ver":"0.1","info":{"id":"llKSRz","date":"1482607278","viewed":192,"name":"Basic : Voronoi","username":"Gijs","description":"For pedagocical uses.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","basic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define sqrt2 1.41421356237\n\n//hash function\nvec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\n\n//creates voronoi pattern with points spread in cells of size 1 (notice how there is always a point in a cell)\nvec3 voronoi( in vec2 x ){\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tfloat dis          = 4.;\n    vec2  voronoipoint = vec2(0);\n    \n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\t\n        //cell around\n        vec2  g = vec2(i,j);\n        \n        //o MUST be a point between (0,0) and (1,1) for the algorithm to work\n      \tvec2  o = hash( n + g );//random number between (0,0) and (1,1) corresponding to cellid = n+g\n        \n              o = -cos(o*iTime)*.5+.5;//animation(notice how it keeps o between (0,0) and (1,1))\n        \t\t\t\t\t\t\t\t\t//it also maps (0,0) back to (0,0) on purpose\n        \n        vec2  delta = g+o-f;//delta between (n+g+o = voronoi_point) and (n+f = x)\n        \n      \t\n      //float d = max(abs(delta.x)*.866025403785+delta.y*.5,-delta.y);;//triangular distance metric\n\t  //float d = abs(delta.x)+abs(delta.y);//manhattan distance metric\n        float d = sqrt(dot(delta,delta));//euclidian distance metric\n      \n        \n        if( d<dis ){\n            dis          = d;\n            voronoipoint = n+g+o;\n        }\n\n    }\n\n    return vec3( dis, voronoipoint );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float MinRes = min(iResolution.x,iResolution.y);\n    float Scale  = 5.;\n    \n    vec2 p = fragCoord.xy/MinRes*Scale;\n    \n    //compute voronoi pattern\n    vec3 c = voronoi( p );\n\n    // colorize\n\n    fragColor = vec4(pow(c.x/sqrt2,.3));//color distance\n    \n    if(distance(p,c.yz)<Scale/MinRes)              fragColor = vec4(0,1,0,1);//color voronoi points green\n    if(fract(p.x)<Scale/MinRes || fract(p.y)<Scale/MinRes) fragColor = vec4(1,0,0,1);//color cell edges red\n    \n}","name":"Image","description":"","type":"image"}]}