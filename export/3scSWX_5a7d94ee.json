{"ver":"0.1","info":{"id":"3scSWX","date":"1575208051","viewed":257,"name":"Kernel convolution","username":"csblo","description":"Test convolution","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["convolution","kernel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// author : csblo\n// Work made just by consulting :\n// https://en.wikipedia.org/wiki/Kernel_(image_processing)\n\n#define identity mat3(0, 0, 0, 0, 1, 0, 0, 0, 0)\n#define edge0 mat3(1, 0, -1, 0, 0, 0, -1, 0, 1)\n#define edge1 mat3(0, 1, 0, 1, -4, 1, 0, 1, 0)\n#define edge2 mat3(-1, -1, -1, -1, 8, -1, -1, -1, -1)\n#define sharpen mat3(0, -1, 0, -1, 5, -1, 0, -1, 0)\n#define box_blur mat3(1, 1, 1, 1, 1, 1, 1, 1, 1) * 0.1111\n#define gaussian_blur mat3(1, 2, 1, 2, 4, 2, 1, 2, 1) * 0.0625\n\n\n\n// Custom kernels\n#define brute_edge mat3(1, 2, 4, 8, -31, 8, 4, 2, 1)\n#define edge5x5 mat5(-1., -1., -1., -1., -1., -1., -1., -1., -1., -1., -1., -1., 24., -1., -1., -1., -1., -1., -1., -1., -1., -1., -1., -1., -1.)\n#define brute_sharpen mat3(-1, -1, 0, -1, 7, -1, 0, -1, -1)\n#define death_blur mat5(0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04,0.04)\n\n\nuniform struct mat5\n{\n    float _0; float _1; float _2; float _3; float _4;\n    float _5; float _6; float _7; float _8; float _9;\n    float _10; float _11; float _12; float _13; float _14;\n    float _15; float _16; float _17; float _18; float _19;\n    float _20; float _21; float _22; float _23; float _24;\n};\n    \n    \nmat5 _matrixCompMult(const mat5 m1, const mat5 m2)\n{    \n\n    return mat5(\n        m1._0 * m2._0, m1._1 * m2._1, m1._2 * m2._2, m1._3 * m2._3, m1._4 * m2._4,\n        m1._5 * m2._5, m1._6 * m2._6, m1._7 * m2._7, m1._8 * m2._8, m1._9 * m2._9,\n        m1._10 * m2._10, m1._11 * m2._11, m1._12 * m2._12, m1._13 * m2._13, m1._14 * m2._14,\n        m1._15 * m2._15, m1._16 * m2._16, m1._17 * m2._17, m1._18 * m2._18, m1._19 * m2._19,\n        m1._20 * m2._20, m1._21 * m2._21, m1._22 * m2._22, m1._23 * m2._23, m1._24 * m2._24\n    );\n}\n\n\n// Find coordinate of matrix by index and it's size\nvec2 kpos(int index, int size)\n{\n    // convert int to float for computations\n    float findex = float(index);\n    float fsize = float(size);\n    \n    // Get bounds of matrix\n    // for example with a matrix 3x3 : [-1, 1]\n    float bounds = 0.5 * float(size) - 0.5;\n    \n    // Compute coordinate in matrix from given index\n    int x = int(mod(findex, fsize) - bounds);\n    int y = int(float(index / size) - bounds);\n    \n    // \n\treturn vec2(x, y) / iResolution.xy;\n}\n\n\n// Extract region of dimension 3x3 from sampler centered in uv\n// sampler :\n// uv :\n// return : an array of mat3, each index corresponding with a color channel\nmat3[3] region3x3(sampler2D sampler, vec2 uv)\n{\n    vec4[9] region;\n    \n    for (int i = 0; i < 9; i++)\n        region[i] = texture(sampler, uv + kpos(i, 3));\n\n    mat3[3] mRegion;\n    \n    for (int i = 0; i < 3; i++)\n        mRegion[i] = mat3(\n        \tregion[0][i], region[1][i], region[2][i],\n        \tregion[3][i], region[4][i], region[5][i],\n        \tregion[6][i], region[7][i], region[8][i]\n    \t);\n    \n    return mRegion;\n\n}\n\nmat5[3] region5x5(sampler2D sampler, vec2 uv)\n{\n    vec4[25] region;\n    \n    for (int i = 0; i < 25; i++)\n        region[i] = texture(sampler, uv + kpos(i, 5));\n    \n    mat5[3] mRegion;\n    \n    for (int i = 0; i < 3; i++)\n        mRegion[i] = mat5(\n        \tregion[0][i], region[1][i], region[2][i], region[3][i], region[4][i], \n            region[5][i], region[6][i], region[7][i], region[8][i], region[9][i], \n            region[10][i], region[11][i], region[12][i], region[13][i], region[14][i], \n            region[15][i], region[16][i], region[17][i], region[18][i], region[19][i], \n            region[20][i], region[21][i], region[22][i], region[23][i], region[24][i]\n    \t);\n    \n    return mRegion;\n}\n\n\n\nvec3 convolution(mat3 kernel, sampler2D sampler, vec2 uv)\n{\n    vec3 fragment;\n    \n    mat3[3] region = region3x3(iChannel0, uv);\n    \n    for (int i = 0; i < 3; i++)\n    {\n        mat3 rc = region[i];\n        mat3 c = matrixCompMult(kernel, rc);\n        float r = c[0][0] + c[1][0] + c[2][0]\n                + c[0][1] + c[1][1] + c[2][1]\n                + c[0][2] + c[1][2] + c[2][2];\n        \n        fragment[i] = r;\n    }\n    \n    return fragment;    \n\n}\n\nvec3 convolution(mat5 kernel, sampler2D sampler, vec2 uv)\n{\n    vec3 fragment;\n    \n    mat5[3] region = region5x5(iChannel0, uv);\n    \n    for (int i = 0; i < 3; i++)\n    {\n        mat5 rc = region[i];\n        mat5 c = _matrixCompMult(kernel, rc);\n        float r = \n            \tc._0 + c._1 + c._2 + c._3 + c._4 +\n            \tc._5 + c._6 + c._7 + c._8 + c._9 +\n            \tc._10 + c._11 + c._12 + c._13 + c._14 +\n            \tc._15 + c._16 + c._17 + c._18 + c._19 +\n            \tc._20 + c._21 + c._22 + c._23 + c._24;\n        \n        fragment[i] = r;\n    }\n    \n    return fragment;    \n\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n     \n    vec3 col = convolution(brute_edge, iChannel0, uv);\n    \n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}