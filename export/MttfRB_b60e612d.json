{"ver":"0.1","info":{"id":"MttfRB","date":"1540157745","viewed":256,"name":"Draag","username":"hypothete","description":"Draag from the movie Fantastic Planet. Distance functions from iq and hg_sdf","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON 0.001\n#define MAXSTEPS 128\n#define NEAR 0.5\n#define FAR 50.0\n#define TWOPI 6.28319\n\nprecision mediump float;\n\nstruct Camera {\n    vec3 pos;\n    vec3 dir;\n};\n\nfloat sdfSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat fCapsule(vec3 p, float r, float c) {\n\treturn mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat moveSphere (vec3 p, vec3 q, float r) {\n    mat4 m = mat4(\n    \t1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        q.x, q.y, q.z, 1.0\n    );\n    vec4 s = inverse(m)*vec4(p, 1.0);\n    return sdfSphere(s.xyz, r);\n}\n\nfloat moveCapsule(vec3 p, vec3 q, float a, float b) {\n    mat4 m = mat4(\n    \t1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        q.x, q.y, q.z, 1.0\n    );\n    vec4 s = inverse(m)*vec4(p, 1.0);\n\treturn fCapsule(s.xyz, a, b);\n}\n\nfloat moveTorus(vec3 p, vec3 q, float a, float b) {\n    mat4 m = mat4(\n    \t1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        q.x, q.y, q.z, 1.0\n    );\n    vec4 s = inverse(m)*vec4(p, 1.0);\n    return fTorus(s.xyz, a, b);\n}\n\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat sceneSDF(vec3 p, out vec3 col) {\n    \n    vec3 q = p + vec3(0.0, -1.0, -2.0);\n    col = vec3(0);\n    float d = 1.0;\n    \n    pMod1(q.x, 4.0); // repeat x\n    \n    // face\n    \n    vec3 skincol = vec3(0.5, 0.6, 1.5);\n\n    float c2 = moveSphere(q, vec3(0.0, 1.5, 0.0), 1.5);\n    d = smin(d, c2, 0.5);\n    d = smin(d, moveSphere(q, vec3(0.0, 0.4, -0.3), 1.0), 0.5);\n    d = smin(d, moveCapsule(q, vec3(0.0, 0.4, -1.2), 0.2, 0.2), 0.5);\n    d = smin(d, moveSphere(q, vec3(-0.4, 0.75, -1.1), 0.1), 0.5);\n    d = smin(d, moveSphere(q, vec3(0.4, 0.75, -1.1), 0.1), 0.5);\n    \n    // nose\n    d = smin(d, moveCapsule(q, vec3(0.0, 0.9, -1.42), 0.07, 0.1), 0.15);\n    d = smin(d, moveSphere(q, vec3(0.1, 0.75, -1.5), 0.04), 0.05);\n    d = smin(d, moveSphere(q, vec3(-0.1, 0.75, -1.5), 0.04), 0.05);\n    d = smin(d, moveSphere(q, vec3(0.0, 0.75, -1.52), 0.06), 0.05);\n    \n    // mouth\n    d = smin(d, moveTorus(q, vec3(0.0, 0.50, -1.3), 0.01, 0.2), 0.1);\n    d = smin(d, moveTorus(q, vec3(0.0, 0.40, -1.3), 0.022, 0.2), 0.05);\n    \n    // ears\n    d = smin(d, udTriangle(q,\n                          vec3(-0.6, 1.0, -1.2),\n                          vec3(-1.5, 1.2, -0.5),\n                          vec3(-1.3, 0.5, -0.5)), 0.1);\n    d = smin(d, udTriangle(q,\n                          vec3(0.6, 1.0, -1.2),\n                          vec3(1.5, 1.2, -0.5),\n                          vec3(1.3, 0.5, -0.5)), 0.1);\n    \n    // body\n    d = smin(d, moveCapsule(q, vec3(0.0, -1.0, -0.3), 0.6, 0.6), 0.25);\n    d = smin(d, moveSphere(q, vec3(1.7, -1.5, -0.2), 0.6), 0.9);\n    d = smin(d, moveSphere(q, vec3(-1.7, -1.5, -0.2), 0.6), 0.9);\n    d = smin(d, moveSphere(q, vec3(0.0, -1.6, -0.3), 0.8), 0.9);\n    \n    // eyes\n    \n    vec3 eyecol = vec3(1.0, 0.3, 0.01);\n    vec3 pupilcol = vec3(0.01);\n    \n    float c5 = moveSphere(q, vec3(-0.35, 1.0, -1.3), 0.2);\n    d = min(d, c5);\n    \n    float c6 = moveSphere(q, vec3(0.35, 1.0, -1.3), 0.2);\n    d = min(d, c6);\n    \n    float cb = moveSphere(q, vec3(-0.35, 1.0, -1.5), 0.02);\n    d = min(d, cb);\n    \n    float cc = moveSphere(q, vec3(0.35, 1.0, -1.5), 0.02);\n    d = min(d, cc);\n    \n    col = mix(skincol, col, c2);\n    col = mix(eyecol, col, step(EPSILON, c5));\n    col = mix(eyecol, col, step(EPSILON, c6));\n    col = mix(pupilcol, col, step(EPSILON, cb));\n    col = mix(pupilcol, col, step(EPSILON, cc));\n    \n    return d;\n}\n\nvec3 sceneNormal(vec3 p) {\n    vec3 col;\n    float baseSDF = sceneSDF(p, col);\n    vec3 unNorm = vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z), col) - baseSDF,\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z), col) - baseSDF,\n        sceneSDF(vec3(p.x, p.y, p.z + EPSILON), col) - baseSDF\n    );\n    return normalize(unNorm);\n}\n\nfloat distToSurface(vec3 pos, vec3 dir, out vec3 ip, out vec3 col) {\n    float depth = NEAR;\n    for (int i=0; i<MAXSTEPS; i++) {\n        ip = pos + dir * depth;\n        float distToScene = sceneSDF(ip, col);\n        if (distToScene < EPSILON) {\n            return depth;\n        }\n        depth += distToScene;\n        if (depth >= FAR) {\n            return FAR;\n        }\n    }\n    return depth;\n}\n\nfloat lambert(vec3 norm, vec3 lpos) {\n    return max(dot(norm, normalize(lpos)), 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 nrmDir = normalize(vec3(uv, 1.0));\n   \tvec2 mouse = vec2(\n    \t4.0 * (iMouse.x/iResolution.x) - 2.0,\n        2.0 + (iMouse.y/iResolution.y) - 0.2\n    );\n    Camera camera = Camera(vec3(mouse, -1.0), nrmDir);\n    vec3 endPt;\n    vec3 shapecol;\n    float t = distToSurface(camera.pos, camera.dir, endPt, shapecol);\n    vec3 ambi = vec3(0.01, 0.01, 0.03);\n    vec3 sky = vec3(smoothstep(1.0, 0.0, uv.y / 2.0 + 0.5));\n    vec3 col = sky;\n\n    if (t < FAR) {\n        vec3 nrm = sceneNormal(endPt);\n        vec3 lpos = vec3(-5.0, 20.0, -14.0);\n        vec3 toL = vec3(lpos - endPt);\n        col = ambi + shapecol * lambert(nrm, toL);\n        if (endPt.y < 10.0) {\n        \tcol = mix(col, sky, length(endPt) / FAR);\n        }\n        else {\n            col = sky;\n        }\n    }\n\n    col = pow(col, vec3(1.0 / 2.2));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}