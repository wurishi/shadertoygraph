{"ver":"0.1","info":{"id":"lfcBDn","date":"1732916154","viewed":20,"name":"GLSL_TEST12_rubic ","username":"changlezeng","description":"TEST12","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["test12"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 计算点 p 到盒子中心的距离\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// 旋转函数：将点 p 绕指定轴旋转指定角度\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    vec3 u = normalize(axis);\n\n    mat3 rot = mat3(\n        c + u.x * u.x * (1.0 - c), u.x * u.y * (1.0 - c) - u.z * s, u.x * u.z * (1.0 - c) + u.y * s,\n        u.y * u.x * (1.0 - c) + u.z * s, c + u.y * u.y * (1.0 - c), u.y * u.z * (1.0 - c) - u.x * s,\n        u.z * u.x * (1.0 - c) - u.y * s, u.z * u.y * (1.0 - c) + u.x * s, c + u.z * u.z * (1.0 - c)\n    );\n\n    return rot * p;\n}\n\n// 场景中包含多个物体，定义距离场景中最近物体的距离\nfloat sceneSDF(vec3 pos)\n{\n    float t = iTime; // 时间\n    float pc = 1.0 * sin(t);  // 偏移量\n    vec3 boxSize = vec3(0.3 * sin(t + 0.2)); // 盒子半尺寸\n\n    // 定义偏移数组\n    float zOffsets[3] = float[](0.0, pc, -pc);\n    float yOffsets[3] = float[](0.0, pc, -pc);\n    float xOffsets[3] = float[](0.0, pc, -pc);\n\n    // 初始化最小距离\n    float minDist = 1e9;\n    float rotationAngle = t;\n    \n    float number[7] = float[](-3.0,-2.0,-1.0,1.0,2.0,3.0,0.0);\n    float interval = 2.0;\n    int index = int(mod(floor(t / interval), 7.0));\n    \n    float rotationNum = number[index];\n    \n    \n    \n\n    // 遍历所有盒子计算最小距离\n    for (int z = 0; z < 3; z++) {\n        for (int y = 0; y < 3; y++) {\n            for (int x = 0; x < 3; x++) {\n                // 计算未旋转的盒子中心点\n                vec3 center = vec3(xOffsets[x], yOffsets[y], zOffsets[z]);\n\n                // 根据当前时间段选择旋转轴\n                if (xOffsets[x] == pc && rotationNum == 1.0) {\n                    center = rotate(center, rotationAngle, vec3(1.0, 0.0, 0.0)); // 绕 X 轴旋转\n                }\n                if (xOffsets[x] == pc && rotationNum == -1.0) {\n                    center = rotate(center, rotationAngle, vec3(-1.0, 0.0, 0.0)); // 绕 X 轴旋转\n                }\n                else if (yOffsets[y] == pc && rotationNum == 2.0) {\n                    center = rotate(center, rotationAngle, vec3(0.0, 1.0, 0.0)); // 绕 Y 轴旋转\n                }\n                else if (yOffsets[y] == pc && rotationNum == -2.0) {\n                    center = rotate(center, rotationAngle, vec3(0.0, -1.0, 0.0)); // 绕 Y 轴旋转\n                }\n                else if (zOffsets[z] == pc && rotationNum == 3.0) {\n                    center = rotate(center, rotationAngle, vec3(0.0, 0.0, 1.0)); // 绕 Z 轴旋转\n                }\n                 else if (zOffsets[z] == pc && rotationNum == -3.0) {\n                    center = rotate(center, rotationAngle, vec3(0.0, 0.0, -1.0)); // 绕 Z 轴旋转\n                }\n\n                // 计算点到当前盒子的距离\n                float dist = sdBox(pos - center, boxSize);\n\n                // 更新最小距离\n                minDist = min(minDist, dist) ;\n            }\n        }\n    }\n\n    return minDist;\n}\n\n// 主函数，计算每个像素的颜色\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 ro = vec3(2.0, 2.0, 2.0);\n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n\n    vec3 rd = normalize(uv.x * right + uv.y * up + forward);\n\n    const int maxsteps = 128;\n    const float epsilon = 0.001;\n    const float maxdist = 10.0;\n    float totaldist = 0.0;\n    bool hit = false;\n\n    for (int i = 0; i < maxsteps; i++)\n    {\n        vec3 pos = ro + rd * totaldist;\n        float dist = sceneSDF(pos);\n\n        if (dist < epsilon)\n        {\n            hit = true;\n            break;\n        }\n\n        totaldist += dist;\n\n        if (totaldist > maxdist)\n        {\n            break;\n        }\n    }\n\n    vec3 col = vec3(0.0);\n    if (hit)\n    {\n        col = vec3(0.0, 1.0 - totaldist / maxdist, 0.6); // 根据距离生成颜色\n    }\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}