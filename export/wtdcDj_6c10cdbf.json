{"ver":"0.1","info":{"id":"wtdcDj","date":"1610483189","viewed":188,"name":"learning_process_13","username":"lossushi","description":"Last exercise from https://thebookofshaders.com/08/\nfake UI (use mouse for control)","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["beginner"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433832795\n\nconst float outerCircle = .98;\n\n// from https://thebookofshaders.com/edit.php#09/dots5.frag\nvec2 tile(in vec2 st, in float zoom){\n    st *= zoom;\n    return fract(st);\n}\n\n// box and cross from https://thebookofshaders.com/08/\nfloat box(in vec2 _st, in vec2 _size){\n    _size = vec2(0.5) - _size*0.5;\n    vec2 uv = smoothstep(_size,\n                        _size+vec2(0.001),\n                        _st);\n    uv *= smoothstep(_size,\n                    _size+vec2(0.001),\n                    vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\nfloat crosses(in vec2 _st, in float _size){\n    return  box(_st, vec2(_size,_size/5.)) +\n            box(_st, vec2(_size/5.,_size));\n}\n\nvec3 ruler(in vec2 st, in vec2 size){\n    vec3 color = vec3(box(st, size));\n    for(float i = -.95; i <= .95; i += .19){\n        color += vec3(box(st+vec2(.0, i), vec2(.05,.012)));\n    }\n    return color;\n}\n\nfloat polygon(in vec2 st, in int N, in float angle){\n    st = st *2.-1.;\n    float a = atan(st.x,st.y)+PI+angle;\n  \tfloat r = PI*2./float(N);\n    float d = cos(floor(.5+a/r)*r-a)*length(st)+.35;\n    return 1.0-smoothstep(.4,.41,d);\n}\n\n// https://thebookofshaders.com/08/\nmat2 rotate2d(float _angle){\n    _angle *= 1.57;\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nmat2 revRotate2d(float _angle){\n    _angle *= 1.57;\n    return mat2(cos(_angle),sin(_angle),\n                -sin(_angle),cos(_angle));\n}\n\nfloat circle(in vec2 uv, in float radius, in float width){\n    float l = length(uv);\n    return 1. - smoothstep(radius, radius+.01, l) - smoothstep(radius-width, radius-width-.01, l);\n}\n\nfloat lineCircle(in vec2 uv, in float l, in float angle, in float start, in float end){\n    uv = rotate2d(cos(PI*iMouse.x/iResolution.x)) * uv;\n    float theta0 = angle;\n    vec2 p = l * vec2(cos(theta0), -sin(theta0));\n    float radius = length( uv - p*clamp( dot(uv,p)/dot(p,p), start, end) );\n    float w = 0.001;\n    return 1. - smoothstep(w, w+.01, radius);\n}\n\nfloat compass(in vec2 uv, in vec2 pos, in float radius){\n    uv = rotate2d( cos( PI* (iMouse.x/iResolution.x) ) ) * uv;\n    float l = length(uv+pos);\n    return 1. - smoothstep(radius, radius+.01, l) - smoothstep(radius-radius, radius-radius-.01, l);\n}\n\nfloat quarterScreen(in float uvAxis, in float width){\n    return 1. - smoothstep(width, width+.001, uvAxis) - smoothstep(width, width+.001, -uvAxis);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 col;\n    \n    // background picture\n    uv = rotate2d( cos( PI* (iMouse.x/iResolution.x) ) ) * uv;\n    col = texture(iChannel0, uv * .27 + vec2(.5) ).rgb * vec3(.3);\n    uv = revRotate2d( cos( PI* (iMouse.x/iResolution.x) ) ) * uv;\n    \n    // grid and its crosses\n    vec2 grid1 = tile(uv, 3.);\n    col += vec3(crosses(grid1, .2));\n    \n    // vertical rulers and their dashes\n    vec2 rulerVertical = vec2(.01,1.9);\n    col += vec3(ruler(uv+vec2(2.18,.5), rulerVertical));\n    col += vec3(ruler(uv+vec2(-1.18,.5), rulerVertical));\n    \n    // triangles next to rulers\n    float mouseXOffset = iMouse.x/iResolution.x*2.-1.;\n    col += vec3(polygon(uv+vec2(2.08, cos( PI*iMouse.y/iResolution.y +mouseXOffset)/1.05+.5), 3, PI/2.));\n    col += vec3(polygon(uv+vec2(-1.08, cos(PI*iMouse.y/iResolution.y -mouseXOffset)/1.05+.5), 3, PI/6.));\n    \n    // outer circle and its dashes\n    col += vec3(circle(uv, outerCircle, .005));\n    for(float i = 0.; i < PI*2.; i+=PI/18.){\n        col += vec3(lineCircle(uv, outerCircle-.01, i, .96, 1.));\n    }\n    \n    // circle pointing to north\n    col += vec3(compass(uv, vec2(.0,-outerCircle), .05));\n    \n    // fat white\n    col += vec3(circle(uv, .38, .09));\n    \n    // dashes in circle\n    for(float i = 0.; i < PI*2.; i+=PI/48.){\n        col += vec3(lineCircle(uv, .8, i, .52, .64));\n    }\n        \n    // quarter the screen\n    col += vec3(box(uv+vec2(.5,.5), vec2(3.6,.01)));\n    col += vec3(box(uv+vec2(.5,.5), vec2(.01, 2.)));\n    \n    // colored diagonals\n    col = mix(col, vec3(1.,.0,.0), lineCircle(uv, outerCircle-.01, PI/4., .43, 1.3));\n    col = mix(col, vec3(.0,1.,.0), lineCircle(uv, outerCircle-.01, 3.*PI/4., .43, 1.3));\n    col = mix(col, vec3(.0,.0,1.), lineCircle(uv, outerCircle-.01, 5.*PI/4., .43, 1.3));\n    col = mix(col, vec3(1.,.0,1.), lineCircle(uv, outerCircle-.01, 7.*PI/4., .43, 1.3));\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}