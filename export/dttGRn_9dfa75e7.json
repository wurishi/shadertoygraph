{"ver":"0.1","info":{"id":"dttGRn","date":"1682202702","viewed":35,"name":"RaytracingSDF_Test","username":"GoldenThumbs","description":"Just a dumb little raytracer.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["sdf","lighting","sphere"],"hasliked":0,"parentid":"ssSSWm","parentname":"Melting Spheres_gld"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float GAMMA = 2.2;\nconst float INV_GAMMA = 1.0 / GAMMA;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    fragColor = vec4(pow(color, vec3(INV_GAMMA)), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// #define NO_DRAW_BOX\n// #define NO_DRAW_LIGHT\n// #define NO_DRAW_SCENE\n// #define FURNACE_TEST\n\n#ifdef FURNACE_TEST\n    #define NO_DRAW_BOX\n    #define NO_DRAW_LIGHT\n    #define NO_DRAW_SCENE\n#endif\n\nconst int MAX_SCENE = 16;\nconst int MAX_STEPS = 64;\nconst int NUM_RAYS = 1;\nconst int NUM_BOUNCES = 2;\nconst int NUM_SAMPLES = 64;\nconst float NEAR_CLIP = 0.01;\nconst float FAR_CLIP = 32.0;\nconst float EPSILON = 0.00001;\n\nconst int SDF_PLANE = 0;\nconst int SDF_QUAD = 1;\nconst int SDF_SPHERE = 2;\nconst int SDF_BOX = 3;\n\nstruct Camera\n{\n    vec3 position;\n    vec3 target;\n    vec3 ray;\n};\n\nstruct Material\n{\n    float rough;\n    float metal;\n    float ior;\n    float refr;\n    vec3 albedo;\n    vec3 emit;\n    float emitValue;\n};\n\nstruct Desc\n{\n    int type;\n    vec3 position;\n    vec3 scale;\n    vec3 rotation;\n};\n\nstruct Object\n{\n    Desc desc;\n    Material mat;\n};\n\nstruct Info\n{\n    float dist;\n    Material mat;\n};\n\nstruct RayMeta\n{\n    bool isLight;\n    bool isSpec;\n    bool isCam;\n    int bounceIdx;\n    int rayIdx;\n    vec3 color;\n};\n\nstruct Ray\n{\n    vec3 position;\n    vec3 dir;\n    RayMeta meta;\n};\n\nstruct RayResult\n{\n    bool hit;\n    float dist;\n    vec3 position;\n    vec3 normal;\n    Material mat;\n};\n\nstruct Scene\n{\n    int count;\n    Object objs[MAX_SCENE];\n};\n\nRay defRay(vec3 position, vec3 dir)\n{\n    return Ray(position, dir, RayMeta(false, false, false, 0, 0, vec3(0.0)));\n}\n\nvoid addSceneObject(inout Scene scene, Desc desc, Material mat)\n{\n    if (scene.count < MAX_SCENE)\n    {\n        scene.objs[scene.count] = Object(desc, mat);\n        scene.count++;\n    }\n}\n\nMaterial emitMaterial(vec3 emit, float brightness)\n{\n    return Material(\n        0.2,\n        0.0,\n        1.45,\n        0.0,\n        emit,\n        emit,\n        brightness\n    );\n}\n\nMaterial flatMaterial(vec3 color)\n{\n    return Material(\n        1.0,\n        0.0,\n        1.45,\n        0.0,\n        color,\n        vec3(0.0),\n        0.0\n    );\n}\n\nmat4 viewMatrix(Camera camera)\n{\n\tvec3 axis[3];\n    axis[2] = normalize(camera.target - camera.position);\n    axis[0] = normalize(cross(axis[2], vec3(0, 1, 0)));\n    axis[1] = cross(axis[0], axis[2]);\n    \n    return mat4(\n         axis[0].x, axis[0].y, axis[0].z, 0.0,\n         axis[1].x, axis[1].y, axis[1].z, 0.0,\n        -axis[2].x,-axis[2].y,-axis[2].z, 0.0,\n         0.0,       0.0,       0.0,       1.0);\n}\n\nvoid initScene(inout Scene scene)\n{\n    // Cornell Box\n    #ifndef NO_DRAW_BOX\n    addSceneObject(scene,\n        Desc(\n            SDF_QUAD,\n            vec3(0,-4, 0),\n            vec3(8, 1, 8),\n            vec3(0, 0, 0)\n        ),\n        flatMaterial(vec3(0.8))\n    );\n    addSceneObject(scene,\n        Desc(\n            SDF_QUAD,\n            vec3(-4, 0, 0),\n            vec3(8, 1, 8),\n            vec3(0, 0, 90)\n        ),\n        flatMaterial(vec3(1.0, 0.0, 0.0))\n    );\n    addSceneObject(scene,\n        Desc(\n            SDF_QUAD,\n            vec3(0, 4, 0),\n            vec3(8, 1, 8),\n            vec3(0, 0, 180)\n        ),\n        flatMaterial(vec3(0.8))\n    );\n    addSceneObject(scene,\n        Desc(\n            SDF_QUAD,\n            vec3(4, 0, 0),\n            vec3(8, 1, 8),\n            vec3(0, 0, 270)\n        ),\n        flatMaterial(vec3(0.0, 0.6, 0.1))\n    );\n    addSceneObject(scene,\n        Desc(\n            SDF_QUAD,\n            vec3(0, 0, -4),\n            vec3(8, 1, 8),\n            vec3(-90, 0, 0)\n        ),\n        flatMaterial(vec3(0.8))\n    );\n    #endif\n    \n    \n    // Objects in Box   \n    #ifndef NO_DRAW_LIGHT\n    // addSceneObject(scene,\n    //     Desc(\n    //         SDF_SPHERE,\n    //         vec3(5, 10, 20),\n    //         vec3(6, 1, 1),\n    //         vec3(0, 0, 0)\n    //     ),\n    //     emitMaterial(vec3(1.0), 15.0)\n    // );\n    \n    addSceneObject(scene,\n        Desc(\n            SDF_QUAD,\n            vec3(0, 3.5, 2),\n            vec3(8, 1, 1),\n            vec3(45, 0, 0)\n        ),\n        emitMaterial(vec3(1.0), 8.0)\n    );\n    #endif\n    \n    #ifndef NO_DRAW_SCENE\n    addSceneObject(scene,\n        Desc(\n            SDF_SPHERE,\n            vec3(-1.25,-0.5, 0),\n            vec3(1, 1, 1),\n            vec3(0, 0, 0)\n        ),\n        Material(0.45, 0.0, 1.5, 0.0, vec3(0.5, 0.2, 0.1), vec3(0), 0.0)\n    );\n    addSceneObject(scene,\n        Desc(\n            SDF_SPHERE,\n            vec3(1.25,-0.5, 0),\n            vec3(1, 1, 1),\n            vec3(0, 0, 0)\n        ),\n        Material(0.1, 0.0, 1.5, 0.0, vec3(0.1, 0.2, 0.3), vec3(0), 0.0)\n    );\n    addSceneObject(scene,\n        Desc(\n            SDF_SPHERE,\n            vec3(0, 1.5, 0),\n            vec3(1, 1, 1),\n            vec3(0, 0, 0)\n        ),\n        Material(0.3, 1.0, 1.5, 0.0, vec3(0.9, 0.5, 0.3), vec3(0), 0.0)\n    );\n    #endif\n    \n    #ifdef FURNACE_TEST\n    addSceneObject(scene,\n        Desc(\n            SDF_SPHERE,\n            vec3(0, 0, 0),\n            vec3(2, 1, 1),\n            vec3(0, 0, 0)\n        ),\n        Material(0.7, 0.0, 1.5, 0.0, vec3(1.0), vec3(0), 0.0)\n    );\n    #endif\n}\n\nInfo processObject(Object obj, vec3 position)\n{\n    Info result;\n    result.dist = 0.0;\n    result.mat = obj.mat;\n    \n    switch (obj.desc.type)\n    {\n        case SDF_PLANE:\n            {\n                vec3 n = normalize(rotateMatrix(obj.desc.rotation) * vec3(0, 1, 0));\n                result.dist = sdfPlane(position, obj.desc.position, n);\n                break;\n            }\n        case SDF_QUAD:\n            {\n                result.dist = sdfQuad(position, obj.desc.position, obj.desc.scale.xz, obj.desc.rotation);\n                break;\n            }\n        case SDF_SPHERE:\n            {\n                result.dist = sdfSphere(position, obj.desc.position, obj.desc.scale.x);\n                break;\n            }\n        case SDF_BOX:\n            {\n                result.dist = sdfBox(position, obj.desc.position, obj.desc.scale, 0.1);\n                break;\n            }\n            \n    };\n    \n    return result;\n}\n\nInfo processScene(Scene scene, vec3 position)\n{\n    Info result;\n    result.dist = FAR_CLIP;\n    \n    for (int i=0; i<scene.count; i++)\n    {\n        Info obj = processObject(scene.objs[i], position);\n        \n        if (obj.dist < result.dist)\n        {\n            result.dist = obj.dist;\n            result.mat = obj.mat;\n        }\n    }\n    \n    return result;\n}\n\nvec4 surfaceDistInfo(Scene scene, Ray ray, out Material mat, out bool hit)\n{\n    float dist = NEAR_CLIP;\n    hit = false;\n    \n    for (int i=0; i<MAX_STEPS; i++)\n    {\n        vec3 p = ray.position + dist * ray.dir;\n        Info info = processScene(scene, p);\n        mat = info.mat;\n        \n        if ((dist >= FAR_CLIP) || (info.dist < EPSILON))\n            break;\n        dist += info.dist;\n    }\n    \n    dist = min(dist, FAR_CLIP);\n    hit = (dist < FAR_CLIP - EPSILON);\n    \n    return vec4(ray.position + dist * ray.dir, dist);\n}\n\nfloat surfaceDist(Scene scene, Ray ray)\n{\n    Material tmp_m;\n    bool tmp_b;\n    return surfaceDistInfo(scene, ray, tmp_m, tmp_b).w;\n}\n\nvec3 getNormal(Scene scene, Ray ray)\n{\n    vec3 p = ray.position;\n    vec3 d = ray.dir;\n    \n    const vec2 k = vec2(1.0,-1.0);\n    const vec2 e = k * 0.0001;\n    float n_0 = surfaceDist(scene, defRay(p + e.xyy, d));\n    float n_1 = surfaceDist(scene, defRay(p + e.yyx, d));\n    float n_2 = surfaceDist(scene, defRay(p + e.yxy, d));\n    float n_3 = surfaceDist(scene, defRay(p + e.xxx, d));\n    return normalize(\n        k.xyy * n_0 +\n        k.yyx * n_1 +\n        k.yxy * n_2 +\n        k.xxx * n_3 );\n}\n\nRayResult checkRay(Scene scene, Ray ray)\n{    \n    RayResult result;\n    \n    vec4 srf = surfaceDistInfo(scene, ray, result.mat, result.hit);\n    \n    result.dist = srf.w;\n    result.position = srf.xyz;\n    result.normal = getNormal(scene, defRay(ray.position, normalize(result.position - ray.position)));\n\n    return result;\n}\n\nvec3 pbrSpec(vec3 n, vec3 v, vec3 l, vec3 h, Material mat)\n{\n    float rough = pow(mat.rough * 0.99 + 0.01, 2.0);\n    vec3 f0 = mix(vec3(1.0), mat.albedo, mat.metal);\n\n    float NdV = abs(dot(n, v)) + EPSILON;\n    float NdL = clamp(dot(n, l), EPSILON, 1.0);\n    float NdH = clamp(dot(n, h), EPSILON, 1.0);\n    \n    float D = distribution_GGX(NdH, rough);\n    float V = visibility_SmithGGX(NdV, NdL, rough);\n    \n    float pdf = 4.0 * NdV * NdL;\n    return ((f0*D*V) / pdf) * NdL;\n}\n\nvec3 pbrDiff(vec3 n, vec3 v, vec3 l, vec3 h, Material mat)\n{\n    float NdL = clamp(dot(n, l), EPSILON, 1.0);\n    \n    float kd = 1.0 - mat.metal;\n    \n    float pdf = NdL * M_INV_PI;\n    return ((NdL * M_INV_PI) * (kd * mat.albedo)) / pdf;\n}\n\nvec3 traceRay(Scene scene, Ray ray, inout uint seed)\n{\n    vec3 color = vec3(0.0);\n    \n    Ray bounce = ray;\n    for (int i=0; i<=NUM_BOUNCES; i++)\n    {\n        bounce.meta.bounceIdx = i;\n        \n        RayResult bounceHit = checkRay(scene, bounce);\n        \n        if (bounceHit.hit)\n        {\n            vec2 rnd = randomValue2(vec2(1.0, 2.0), seed);\n            \n            Material mat = bounceHit.mat;\n            float rough = pow(mat.rough * 0.99 + 0.01, 2.0);\n            float metal = mat.metal;\n            vec3 n = bounceHit.normal;\n            vec3 v = -bounce.dir;\n            \n            float NdV = abs(dot(n, v)) + EPSILON;\n            \n            float r0 = getR0(1.0, mat.ior);\n            float f0 = mat.metal * (1.0 - r0) + r0;\n            float F = fresnel_Schlick(NdV, f0, 1.0);\n            //float refl = rough * (1.0 - F) + F;\n            \n            vec3 surfColor = vec3(0.0);\n            \n            bounce.meta.isSpec = (rnd.y <= F) || (rnd.y <= mat.metal);\n            if (!bounce.meta.isSpec)\n            {\n                vec3 lDiff = lambertNoTangent(n, vec2(1.0, 2.0), seed);\n                vec3 hDiff = normalize(v + lDiff);\n                \n                surfColor = pbrDiff(n, v, lDiff, hDiff, mat);\n                \n                bounce.position = bounceHit.position + lDiff * 0.001; \n                bounce.dir = lDiff;\n            } else {\n                vec3 hSpec = microfacet_GGXVNDF(n, v, rough, randomValue2(vec2(1.0, 2.0), seed));\n                vec3 lSpec = reflect(-v, hSpec);\n                \n                surfColor = pbrSpec(n, v, lSpec, hSpec, mat);\n                float weight = clamp(dot(n, lSpec), EPSILON, 1.0);\n                for (int j=0; j<NUM_SAMPLES; j++)\n                {\n                    vec3 hScatter = microfacet_GGXVNDF(n, v, rough, randomValue2(vec2(1.0, 2.0), seed));\n                    vec3 lScatter = reflect(-v, hScatter);\n                    float NdL = clamp(dot(n, lScatter), EPSILON, 1.0);\n                    if (NdL > 0.0)\n                    {\n                        surfColor += pbrSpec(n, v, lScatter, hScatter, mat);\n                        weight += NdL;\n                    }\n                }\n                \n                surfColor /= weight;\n                \n                bounce.position = bounceHit.position + lSpec * 0.001; \n                bounce.dir = lSpec;\n            }\n            color += bounce.meta.color * mat.emit * mat.emitValue;\n            bounce.meta.color *= surfColor;\n            \n            float bright = \n                max(max(bounce.meta.color.r, bounce.meta.color.g), max(bounce.meta.color.b, EPSILON));\n            \n            if (randomValue(1.0, seed) > bright)\n                break;\n            \n            bounce.meta.color *= 1.0 / bright;\n        } else {\n            color += texture(iChannel1, bounce.dir).rgb * bounce.meta.color;\n            break;\n        }\n    }\n    \n    return color;\n}\n\nvec3 cameraDir(float fov, vec2 resolution, vec2 fragCoord)\n{\n    vec2 xy = fragCoord - resolution * 0.5;\n    float z = resolution.y / tan(radians(fov) * 0.5);\n    return normalize(vec3(xy, -z));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    uint seed = 0x915f77f5u * uint(iFrame) + uint(fragCoord.y * iResolution.x + fragCoord.x);\n    seed = hash_XORShift(seed);\n    \n    Scene _scene;\n    _scene.count = 0;\n    \n    const float angle = radians(0.0);\n    vec2 rot = vec2(sin(angle), cos(angle)) * 13.0;\n    \n    Camera _camera;\n    _camera.position = vec3(rot.x, 4.0, rot.y);\n    _camera.target = vec3(0.0, 0.25, 0.0);\n    \n    mat4 view = viewMatrix(_camera);\n    _camera.ray = vec3(view * vec4(cameraDir(45.0, iResolution.xy, fragCoord), 0.0));\n    \n    initScene(_scene);\n    Ray ray = defRay(_camera.position, _camera.ray);\n    \n    vec2 pixScale = 0.5 / iResolution.xy;\n    \n    vec3 litColor = vec3(0.0);\n    for (int i=0; i<NUM_RAYS; i++)\n    {\n        //seed = hash(seed);\n        vec2 circle = vec2(\n            randomValue(1.0, seed),\n            randomValue(2.0, seed)) * 2.0 - 1.0;\n        ray.dir = _camera.ray + (circle.x * view[0].xyz * pixScale.x + circle.y * view[1].xyz * pixScale.y);\n        ray.meta = RayMeta(false, false, true, 0, i, vec3(1.0));\n        litColor += traceRay(_scene, ray, seed);\n    }\n    litColor *= 1.0 / vec3(NUM_RAYS);\n    \n    vec3 lastFrame = texture(iChannel0, fragCoord.xy / iResolution.xy).rgb;\n    vec3 color = mix(lastFrame, litColor, 1.0 / float(iFrame + 1));\n    \n    fragColor = vec4(color, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define M_PI 3.14159265358979323846\n#define M_TAU 6.283185307179586\n#define M_INV_PI 1.0 / M_PI\n#define M_EPS 1e-8\n\n// Misc Math Utils\n\nbool zeroApprox(vec3 v)\n{\n    v = abs(v);\n    return\n        (v.x < M_EPS) &&\n        (v.y < M_EPS) &&\n        (v.x < M_EPS);\n}\n\nmat3 orthonormal(vec3 n)\n{\n    vec3 t;\n    vec3 b;\n    if (n.z < 0.0)\n    {\n        float a1 = 1.0 / (1.0 - n.z);\n        float a2 = n.x * n.y * a1;\n        t = vec3(1.0 - n.x*n.x * a1, -a2, n.x);\n        b = vec3(a2, n.y*n.y * a1 - 1.0, -n.y);\n    } else {\n        float a1 = 1.0 / (1.0 + n.z);\n        float a2 = -n.x * n.y * a1;\n        t = vec3(1.0 - n.x*n.x * a1, a2, -n.x);\n        b = vec3(a2, 1.0 - n.y*n.y * a1, -n.y);\n    }\n    return mat3(t, b, n);\n}\n\nvec3 sphereToCartesian(float theta, float phi)\n{\n    return vec3(sin(phi) * vec2(cos(theta), sin(theta)), cos(phi));\n}\n\nmat3 rotateXMatrix(float angle)\n{\n    angle = radians(angle);\n    vec2 a = vec2(cos(angle), sin(angle));\n    \n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, a.x, a.y,\n        0.0,-a.y, a.x\n    );\n}\n\nmat3 rotateYMatrix(float angle)\n{\n    angle = radians(angle);\n    vec2 a = vec2(cos(angle), sin(angle));\n    \n    return mat3(\n        a.x, 0.0,-a.y,\n        0.0, 1.0, 0.0,\n        a.y, 0.0, a.x\n    );\n}\n\nmat3 rotateZMatrix(float angle)\n{\n    angle = radians(angle);\n    vec2 a = vec2(cos(angle), sin(angle));\n    \n    return mat3(\n        a.x, a.y, 0.0,\n       -a.y, a.x, 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\nmat3 rotateMatrix(vec3 angle)\n{\n    angle = radians(angle);\n    \n    vec2 a[3];\n    a[0] = vec2(cos(angle.x), sin(angle.x));\n    a[1] = vec2(cos(angle.y), sin(angle.y));\n    a[2] = vec2(cos(angle.z), sin(angle.z));\n    \n    return mat3(\n        a[2].x * a[1].x,\n        (a[2].x * a[1].y * a[0].y) - (a[2].y * a[0].x),\n        (a[2].x * a[1].y * a[0].x) + (a[2].y * a[0].y),\n        \n        a[2].y * a[1].x,\n        (a[2].y * a[1].y * a[0].y) + (a[2].x * a[0].x),\n        (a[2].y * a[1].y * a[0].x) - (a[2].x * a[0].y),\n        \n        -a[1].y,\n        a[1].x * a[0].y,\n        a[1].x * a[0].x\n    );\n}\n\n// Randomness\n\nuint hash_XORShift(uint x)\n{\n    x ^= x << 13;\n    x ^= x >> 17;\n    x ^= x << 5;\n    return x;\n}\n\nfloat createFloat(uint x)\n{\n\tconst uint ieee_mantissa = 8388607u;\n\tconst uint ieee_one = 1065353216u;\n\tx &= ieee_mantissa;\n\tx |= ieee_one;\n\t\n\tfloat f = uintBitsToFloat(x);\n\treturn f - 1.0;\n}\n\nfloat createFloatSimple(uint x)\n{\n    const float toFloat = 1.0 / float(0xffffffffU);\n    return float(x) * toFloat;\n}\n\nfloat randomValue(float offset, inout uint seed)\n{\n\tuint bits = floatBitsToUint(offset);\n    seed = 0x915f77f5u * seed + bits;\n    \n\treturn createFloatSimple(seed);\n}\n\nvec2 randomValue2(vec2 offset, inout uint seed)\n{\n    return vec2(\n        randomValue(offset.x, seed),\n        randomValue(offset.y, seed)\n    );\n}\n\nvec3 randomDir(vec2 offset, inout uint seed)\n{\n    vec2 rnd = randomValue2(offset, seed);\n    float phi = M_TAU * rnd.x;\n    float theta = acos(1.0 - 2.0 * rnd.y);\n    return sphereToCartesian(theta, phi);\n}\n\nvec3 randomHemiNAlign(vec3 n, vec2 offset, inout uint seed)\n{\n    vec3 point = randomDir(offset, seed);\n    return point * sign(dot(point, n));\n}\n\nvec3 lambertNoTangent(vec3 n, vec2 offset, inout uint seed)\n{\n    vec2 rnd = randomValue2(offset, seed);\n    float theta = M_TAU * rnd.x;\n    float a = rnd.y * 2.0 - 1.0;\n    vec3 point = vec3(sqrt(1.0 - a*a) * vec2(cos(theta), sin(theta)), a);\n    return normalize(n + point);\n}\n\nfloat seq_Halton(int i, int base)\n{\n    float f = 1.0 / float(base);\n    float res = 0.0;\n    while (i > 0)\n    {\n        res += f * float(i % base);\n        f *= 1.0 / float(base);\n        i /= base;\n    }\n    return res;\n}\n\nfloat radicalInverse(uint bits)\n{\n    bits = (bits << 16u) | (bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n\nvec2 set_Hammersley(int i, int base)\n{\n    return vec2(float(i) / float(base), radicalInverse(uint(i)));\n}\n\n// Shading\n\nfloat getR0(float n1, float n2)\n{\n    float r0 = (n1 - n2) / (n1 + n2);\n    return r0*r0;\n}\n\nfloat distribution_GGX(float NdH, float rough)\n{\n    float a = NdH * rough;\n    float k = rough / (1.0 - NdH*NdH + a*a);\n    return k*k * M_INV_PI;\n}\n\nfloat visibility_SmithGGX(float NdV, float NdL, float rough)\n{\n    float a2 = rough*rough;\n    float ggxv = NdL * sqrt((NdV - a2 * NdV) * NdV + a2);\n    float ggxl = NdV * sqrt((NdL - a2 * NdL) * NdL + a2);\n    return 0.5 / (ggxv + ggxl);\n}\n\nvec3 fresnel_Schlick(float u, vec3 f0)\n{\n    float f = pow(1.0 - u, 5.0);\n    return f + f0 * (1.0 - f);\n}\n\nvec3 fresnel_Schlick(float u, vec3 f0, float f90)\n{\n    return f0 + (vec3(f90) - f0) * pow(1.0 - u, 5.0);\n}\n\nfloat fresnel_Schlick(float u, float f0, float f90)\n{\n    return f0 + (f90 - f0) * pow(1.0 - u, 5.0);\n}\n\nvec3 fresnel_RoughSchlick(float u, vec3 f0, float rough)\n{\n    vec3 fr = max(vec3(1.0 - rough), f0) - f0;\n    return f0 + fr * pow(1.0 - u, 5.0);\n}\n\nfloat fresnel_RoughSchlick(float u, float f0, float rough)\n{\n    float fr = max(1.0 - rough, f0) - f0;\n    return f0 + fr * pow(1.0 - u, 5.0);\n}\n\nfloat diff_Burley(float NdV, float NdL, float LdH, float rough)\n{\n    float f90 = 0.5 + 2.0 * rough * LdH*LdH;\n    float lScatter = fresnel_Schlick(NdL, 1.0, f90);\n    float vScatter = fresnel_Schlick(NdV, 1.0, f90);\n    return lScatter * vScatter * M_INV_PI;\n}\n\nvec3 microfacet_GGX(vec3 n, float rough, vec2 rnd)\n{\n    mat3 tbn = orthonormal(n);\n    \n    float a = rough*rough;\n    float phi = M_TAU * rnd.x;\n    float cosTheta = sqrt(max((1.0 - rnd.y) / ((a - 1.0) * rnd.y + 1.0), 0.0));\n    float sinTheta = sqrt(max(1.0 - cosTheta*cosTheta, 0.0));\n    \n    return \n        tbn[0] * (sinTheta * cos(phi)) +\n        tbn[1] * (sinTheta * sin(phi)) +\n        tbn[2] * cosTheta;\n}\n\nvec3 microfacet_GGXVNDF(vec3 n, vec3 v, float rough, vec2 rnd)\n{\n    mat3 tbn = orthonormal(n);\n    v = vec3(dot(tbn[0], v), dot(tbn[1], v), dot(tbn[2], v));\n    vec3 V = normalize(vec3(rough * v.x, rough * v.y, v.z));\n    \n    vec3 T1 = (V.z < 0.9999) ? normalize(cross(V, vec3(0, 0, 1))) : vec3(1, 0, 0);\n    vec3 T2 = cross(T1, V);\n    \n    float a = 1.0 / (1.0 + V.z);\n    float r = sqrt(rnd.x);\n    float phi = (rnd.y < a) ? (rnd.y / a * M_PI) : (M_PI + (rnd.y - a) / (1.0 - a) * M_PI);\n    float cosPhi = r * cos(phi);\n    float sinPhi = r * sin(phi) * ((rnd.y < a) ? 1.0 : V.z);\n    vec3 N = cosPhi * T1 + sinPhi * T2 + sqrt(max(0.0, 1.0 - cosPhi*cosPhi - sinPhi*sinPhi)) * V;\n    N = normalize(vec3(rough * N.x, rough * N.y, max(0.0, N.z)));\n    \n    return \n        tbn[0] * N.x +\n        tbn[1] * N.y +\n        tbn[2] * N.z;\n}\n\n// SDF Utilities\n\nfloat dot2(vec2 v) { return dot(v,v); }\nfloat dot2(vec3 v) { return dot(v,v); }\n\nfloat sdfPlane(vec3 global, vec3 pos, vec3 n)\n{\n    float sdf = dot(global - pos, n);\n    return sdf;\n}\n\nfloat sdfQuad(vec3 global, vec3 pos, vec2 bounds, vec3 rot)\n{\n    mat3 rotMat = rotateMatrix(rot);\n    vec2 extents = bounds * 0.5;\n    vec3 corners[4];\n    corners[0] = rotMat * vec3(-extents.x, 0.0,-extents.y) + pos;\n    corners[1] = rotMat * vec3( extents.x, 0.0,-extents.y) + pos;\n    corners[2] = rotMat * vec3( extents.x, 0.0, extents.y) + pos;\n    corners[3] = rotMat * vec3(-extents.x, 0.0, extents.y) + pos;\n    \n    vec3 vertDeriv[4];\n    vertDeriv[0] = corners[1] - corners[0];\n    vertDeriv[1] = corners[2] - corners[1];\n    vertDeriv[2] = corners[3] - corners[2];\n    vertDeriv[3] = corners[0] - corners[3];\n    \n    vec3 nrm = cross(vertDeriv[0], vertDeriv[3]);\n    \n    vec3 wrldDeriv[4];\n    wrldDeriv[0] = global - corners[0];\n    wrldDeriv[1] = global - corners[1];\n    wrldDeriv[2] = global - corners[2];\n    wrldDeriv[3] = global - corners[3];\n    \n    float h[4];\n    h[0] = clamp(dot(vertDeriv[0], wrldDeriv[0]) / dot2(vertDeriv[0]), 0.0, 1.0);\n    h[1] = clamp(dot(vertDeriv[1], wrldDeriv[1]) / dot2(vertDeriv[1]), 0.0, 1.0);\n    h[2] = clamp(dot(vertDeriv[2], wrldDeriv[2]) / dot2(vertDeriv[2]), 0.0, 1.0);\n    h[3] = clamp(dot(vertDeriv[3], wrldDeriv[3]) / dot2(vertDeriv[3]), 0.0, 1.0);\n    \n    vec2 seg[4];\n    seg[0] = vec2(dot2(vertDeriv[0] * h[0] - wrldDeriv[0]), sign(dot(cross(vertDeriv[0], nrm), wrldDeriv[0])));\n    seg[1] = vec2(dot2(vertDeriv[1] * h[1] - wrldDeriv[1]), sign(dot(cross(vertDeriv[1], nrm), wrldDeriv[1])));\n    seg[2] = vec2(dot2(vertDeriv[2] * h[2] - wrldDeriv[2]), sign(dot(cross(vertDeriv[2], nrm), wrldDeriv[2])));\n    seg[3] = vec2(dot2(vertDeriv[3] * h[3] - wrldDeriv[3]), sign(dot(cross(vertDeriv[3], nrm), wrldDeriv[3])));\n    \n    float sdf = min(min(seg[0].x, seg[1].x), min(seg[2].x, seg[3].x));\n    float s = seg[0].y + seg[1].y + seg[2].y + seg[3].y;\n    return sqrt((s < 3.0) ? sdf : (dot(wrldDeriv[0], nrm)*dot(wrldDeriv[0], nrm)/dot2(nrm)));\n}\n\nfloat sdfSphere(vec3 global, vec3 pos, float radius)\n{\n    float sdf = length(global - pos) - radius;\n    return sdf;\n}\n\nfloat sdfBox(vec3 global, vec3 pos, vec3 bounds, float radius)\n{\n    vec3 q = abs(global - pos) - bounds;\n    float sdf = length(max(q, 0.0)) + min(max(q.x,max(q.y,q.z)), 0.0) - radius;\n    return sdf;\n}\n\n\nfloat opUnion(float d1, float d2)\n{\n    return min(d1, d2);\n}\n\nfloat opUnionSmooth(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k*h*(1.0-h);\n}\n\nfloat opSubtract(float d1, float d2)\n{\n    return max(-d1, d2);\n}\n\nfloat opSubtractSmooth(float d1, float d2, float k)\n{\n    float h = clamp(0.5 - 0.5*(d2+d1)/k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k*h*(1.0-h);\n}\n\nfloat opIntersect(float d1, float d2)\n{\n    return max(d1, d2);\n}\n\nfloat opRound(float d, float h)\n{\n    return d-h;\n}\n\nfloat opOnion(float d, float h)\n{\n    return abs(d) - h;\n}\n","name":"Common","description":"","type":"common"}]}