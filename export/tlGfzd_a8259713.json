{"ver":"0.1","info":{"id":"tlGfzd","date":"1614874565","viewed":10370,"name":"Liberation of the True Self","username":"Kali","description":"Result of a shader coding jam with my friend JPupper","likes":213,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflections"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define resolution iResolution\n#define time iTime\n\n\nvec3 objcol;\n\n// by Dave_Hoskins\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nmat2 rot(float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat de(vec3 pos)\n{\n    float t = mod(time,17.);\n    float a=smoothstep(13.,15.,t)*8.-smoothstep(4.,0.,t)*4.;\n    float f=sin(time*5.+sin(time*20.)*.2);\n    pos.xz *= rot(time+.5);\n    pos.yz *= rot(time);\n    vec3 p = pos;\n    float s=1.;\n    for (int i=0; i<4; i++){\n        p=abs(p)*1.3-.5-f*.1-a;\n        p.xy*=rot(radians(45.));\n        p.xz*=rot(radians(45.));\n        s*=1.3;\n    }\n    float fra = length(p)/s-.5;\n    pos.xy *= rot(time);\n    p = abs(pos) - 2. - a;\n    float d = length(p) - .7;\n    d = min(d, max(length(p.xz)-.1,p.y));\n    d = min(d, max(length(p.yz)-.1,p.x));\n    d = min(d, max(length(p.xy)-.1,p.z));\n    p = abs(pos);\n    p.x -= 4.+a+f*.5;\n    d = min(d, length(p) - .7);\n    d = min(d, length(p.yz-abs(sin(p.x*.5-time*10.)*.3)));\n    p = abs(pos);\n    p.y -= 4.+a+f*.5;\n    d = min(d, length(p) - .7);\n    d = min(d, max(length(p.xz)-.1,p.y));\n    d = min(d, fra);\n    objcol = abs(p);\n    if (d==fra) objcol=vec3(2.,0.,0.);\n    return d;\n}\n\n\nvec3 normal(vec3 p) {\n    vec2 d = vec2(0., .01);\n    return normalize(vec3(de(p+d.yxx), de(p+d.xyx), de(p+d.xxy))-de(p));\n}\n\n\nvec3 march(vec3 from, vec3 dir)\n{\n    float d = 0., td = 0., maxdist = 30.;\n    vec3 p = from, col = vec3(0.);\n    for (int i = 0; i<100; i++)\n    {\n        float d2 = de(p) * (1.-hash12(gl_FragCoord.xy+time)*.2);\n        if (d2<0.)\n        {\n            vec3 n = normal(p);\n            dir = reflect(dir, n);\n            d2 = .1;\n          \n        }\n        d = max(.01, abs(d2));\n        p += d * dir;\n        td += d;\n        if (td>maxdist) break;\n        col += .01 * objcol;\n    }\n    return pow(col, vec3(2.));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / resolution.xy - .5;\n    uv.x *= resolution.x / resolution.y;\n    vec3 from = vec3(0.,0.,-10.);\n    vec3 dir = normalize(vec3(uv, 1.));\n    vec3 col = march(from, dir);\n\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}