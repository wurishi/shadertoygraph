{"ver":"0.1","info":{"id":"MllBR7","date":"1511521892","viewed":1188,"name":"M.A.M. Stairs","username":"leon","description":"Another raymarching sketch inspired by Marc-Antoine Mathieu.","likes":54,"published":1,"flags":0,"usePreview":0,"tags":["stairs","book"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// M.A.M. Stairs by Leon Denise aka ponk\n// another raymarching sketch inspired by Marc-Antoine Mathieu.\n// using code from IQ, Mercury, LJ, Duke, Koltes\n// made with Atom Editor GLSL viewer (that's why there is 2 space tabulations)\n// 2017-11-24\n\n#define STEPS 50.\n#define VOLUME 0.01\n#define PI 3.14159\n#define TAU (2.*PI)\n#define time iTime\n#define repeat(v,c) (mod(v,c)-c/2.)\n#define sDist(v,r) (length(v)-r)\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat rng (vec2 seed) { return fract(sin(dot(seed*.1684,vec2(32.649,321.547)))*43415.); }\nfloat sdBox( vec3 p, vec3 b ) { vec3 d = abs(p) - b; return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)); }\nfloat amod (inout vec2 p, float count) { float an = TAU/count; float a = atan(p.y,p.x)+an/2.; float c = floor(a/an); c = mix(c,abs(c),step(count*.5,abs(c))); a = mod(a,an)-an/2.; p.xy = vec2(cos(a),sin(a))*length(p); return c; }\nfloat aindex (vec2 p, float count) { float an = TAU/count; float a = atan(p.y,p.x)+an/2.; float c = floor(a/an); return mix(c,abs(c),step(count*.5,abs(c))); }\nfloat map (vec3);\nvec3 getNormal (vec3 p) { vec2 e = vec2(.001,0); return normalize(vec3(map(p+e.xyy)-map(p-e.xyy),map(p+e.yxy)-map(p-e.yxy),map(p+e.yyx)-map(p-e.yyx))); }\nfloat hardShadow (vec3 pos, vec3 light) {\n    vec3 dir = normalize(light - pos);\n    float maxt = length(light - pos);\n    float t = .02;\n    for (float i = 0.; i <= 1.; i += 1./30.) {\n        float dist = map(pos + dir * t);\n        if (dist < VOLUME) return 0.;\n        t += dist;\n        if (t >= maxt) break;\n    }\n    return 1.;\n}\n\nfloat map (vec3 pos) {\n  float scene = 1000.;\n  float wallThin = .2;\n  float wallRadius = 8.;\n  float wallOffset = .2;\n  float wallCount = 10.;\n  float floorThin = .1;\n  float stairRadius = 5.;\n  float stairHeight = .4;\n  float stairCount = 40.;\n  float stairDepth = .31;\n  float bookCount = 100.;\n  float bookRadius = 9.5;\n  float bookSpace = 1.75;\n  vec3 bookSize = vec3(1.,.2,.2);\n  vec3 panelSize = vec3(.03,.2,.7);\n  vec2 cell = vec2(1.4,3.);\n  float paperRadius = 4.;\n  vec3 paperSize = vec3(.3,.01,.4);\n  vec3 p;\n\n  // move it\n  pos.y += time;\n\n  // twist it\n  // pos.xz *= rot(pos.y*.05+time*.1);\n  // pos.xz += normalize(pos.xz) * sin(pos.y*.5+time);\n\n  // holes\n  float holeWall = sDist(pos.xz, wallRadius);\n  float holeStair = sDist(pos.xz, stairRadius);\n\n  // walls\n  p = pos;\n  amod(p.xz, wallCount);\n  p.x -= wallRadius;\n  scene = min(scene, max(-p.x, abs(p.z)-wallThin));\n  scene = max(scene, -sDist(pos.xz, wallRadius-wallOffset));\n\n  // floors\n  p = pos;\n  p.y = repeat(p.y, cell.y);\n  float disk = max(sDist(p.xz, 1000.), abs(p.y)-floorThin);\n  disk = max(disk, -sDist(pos.xz, wallRadius));\n  scene = min(scene, disk);\n\n  // stairs\n  p = pos;\n  float stairIndex = amod(p.xz, stairCount);\n  p.y -= stairIndex*stairHeight;\n  p.y = repeat(p.y, stairCount*stairHeight);\n  float stair = sdBox(p, vec3(100,stairHeight,stairDepth));\n  scene = min(scene, max(stair, max(holeWall, -holeStair)));\n  p = pos;\n  p.xz *= rot(PI/stairCount);\n  stairIndex = amod(p.xz, stairCount);\n  p.y -= stairIndex*stairHeight;\n  p.y = repeat(p.y, stairCount*stairHeight);\n  stair = sdBox(p, vec3(100,stairHeight,stairDepth));\n  scene = min(scene, max(stair, max(holeWall, -holeStair)));\n  p = pos;\n  p.y += stairHeight*.5;\n  p.y -= stairHeight*stairCount*atan(p.z,p.x)/TAU;\n  p.y = repeat(p.y, stairCount*stairHeight);\n  scene = min(scene, max(max(sDist(p.xz, wallRadius), abs(p.y)-stairHeight), -holeStair));\n\n  // books\n  p = pos;\n  p.y -= cell.y*.5;\n  vec2 seed = vec2(floor(p.y/cell.y), 0);\n  p.y = repeat(p.y, cell.y);\n  p.xz *= rot(PI/wallCount);\n  seed.y += amod(p.xz, wallCount)/10.;\n  seed.y += floor(p.z/(bookSize.z*bookSpace));\n  p.z = repeat(p.z, bookSize.z*bookSpace);\n  float salt = rng(seed);\n  bookSize.x *= .5+.5*salt;\n  bookSize.y += salt;\n  bookSize.z *= .5+.5*salt;\n  p.x -= bookRadius + wallOffset;\n  p.x += cos(p.z*2.) - bookSize.x - salt * .25;\n  p.x += .01*smoothstep(.99,1.,sin(p.y*(1.+10.*salt)));\n  scene = min(scene, max(sdBox(p, vec3(bookSize.x,100.,bookSize.z)), p.y-bookSize.y));\n\n  // panel\n  p = pos;\n  p.y = repeat(p.y, cell.y);\n  p.xz *= rot(PI/wallCount);\n  amod(p.xz, wallCount);\n  p.x -= wallRadius;\n  float panel = sdBox(p, panelSize);\n  float pz = p.z;\n  p.z = repeat(p.z, .2+.3*salt);\n  panel = min(panel, max(sdBox(p, vec3(.1,.1,.04)), abs(pz)-panelSize.z*.8));\n  scene = min(scene, panel);\n\n  // papers\n  p = pos;\n  p.y -= stairHeight;\n  p.y += time*2.;\n  p.xz *= rot(PI/stairCount);\n  float ry = 8.;\n  float iy = floor(p.y/ry);\n  salt = rng(vec2(iy));\n  float a = iy;\n  p.xz -= vec2(cos(a),sin(a))*paperRadius;\n  p.y = repeat(p.y, ry);\n  p.xy *= rot(p.z);\n  p.xz *= rot(PI/4.+salt+time);\n  scene = min(scene, sdBox(p, paperSize));\n\n  return scene;\n}\n\nvec3 getCamera (vec3 eye, vec2 uv) {\n  vec3 lookAt = vec3(0.);\n  float click = clamp(iMouse.w,0.,1.);\n  lookAt.x += mix(0.,((iMouse.x/iResolution.x)*2.-1.) * 10., click);\n  lookAt.y += mix(0.,iMouse.y/iResolution.y * 10., click);\n  float fov = .65;\n  vec3 forward = normalize(lookAt - eye);\n  vec3 right = normalize(cross(vec3(0,1,0), forward));\n  vec3 up = normalize(cross(forward, right));\n  return normalize(fov * forward + uv.x * right + uv.y * up);\n}\n\nfloat getLight (vec3 pos, vec3 eye) {\n  vec3 light = vec3(-.5,7.,1.);\n  vec3 normal = getNormal(pos);\n  vec3 view = normalize(eye-pos);\n  float shade = dot(normal, view);\n  shade *= hardShadow(pos, light);\n  return shade;\n}\n\nvec4 raymarch () {\n  vec2 uv = (gl_FragCoord.xy-.5*iResolution.xy)/iResolution.y;\n  float dither = rng(uv+fract(time));\n  vec3 eye = vec3(0,5,-4.5);\n  vec3 ray = getCamera(eye, uv);\n  vec3 pos = eye;\n  float shade = 0.;\n  for (float i = 0.; i <= 1.; i += 1./STEPS) {\n    float dist = map(pos);\n\t\tif (dist < VOLUME) {\n\t\t\tshade = 1.-i;\n\t\t\tbreak;\n\t\t}\n    dist *= .5 + .1 * dither;\n    pos += ray * dist;\n  }\n\n  vec4 color = vec4(shade);\n  color *= getLight(pos, eye);\n  color = smoothstep(.0, .5, color);\n  color = sqrt(color);\n  return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = raymarch();\n}","name":"Image","description":"","type":"image"}]}