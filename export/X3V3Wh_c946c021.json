{"ver":"0.1","info":{"id":"X3V3Wh","date":"1717765452","viewed":75,"name":"Simple Ray Marched Reflections","username":"Great_King_Rat","description":"Simple Ray marching shader with ray marched reflections.","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["raytracing","raymarching","reflections","art"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define LIGHTDIRECTION vec3(-0.7f,0.5f,-0.7)\n#define MESHCOLOR vec3(0.855f,0.34f,0.1f)\n#define LIGHTCOLOR vec3(1.0f,1.0f,1.0f)\n#define SKYCOLOR vec3(0.0f,0.9f,1.0f)\n#define FARPLANE 1000.0f\n#define PI 3.14159f\n#define Epsilon 0.001\n\n#define UP_VECTOR vec3(0.0f,1.0f,0.0f)\n\n//Define to disable camera animation\n#define NO_ANIMATION\n\nfloat MeshRoughness = 1.0f;\n\nfloat SphereSDF(vec3 Point,vec3 Center, float Radius)\n{\n   return distance(Point , Center) - Radius;\n}\n\nfloat CubeSDF(vec3 Point,vec3 Size,vec3 Position,float Smoothness,mat3 Transformation)\n{\n   vec3 d = abs((Transformation * (Point - Position))) - Size + Smoothness;\n   return length(max(d,0.0f)) + min(max(d.x,max(d.y,d.z)),0.0f) - Smoothness;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}  \n\nmat3 GetIdentityMatrix()\n{\n   return mat3(\n      vec3(1.0f,0.0f,0.0f),\n      vec3(0.0f,1.0f,0.0f),\n      vec3(0.0f,0.0f,1.0f)\n   );\n}\n\nmat3 RotateY(float theta)\n{\n   float c = cos(theta);\n   float s = sin(theta);\n   return mat3(\n      vec3(c,0.0f,s),\n      vec3(0.0f,1.0f,0.0f),\n      vec3(-s,0.0f,c)\n   );\n}\n\nmat3 RotateX(float theta)\n{\n   float c = cos(theta);\n   float s = sin(theta);\n   return mat3(\n      vec3(1.0f,0.0f,0.0f),\n      vec3(0.0f,c,-s),\n      vec3(0.0f,s,c)\n   );\n}\n\nmat3 RotateZ(float theta)\n{\n   float c = cos(theta);\n   float s = sin(theta);\n   return mat3(\n      vec3(c,-s,0.0f),\n      vec3(s,c,0.0f),\n      vec3(0.0f,0.0f,1.0f)\n   );\n}\n\nvec4 WorldShading(vec3 CurrentPosition)\n{\n    mat3 Rotation = RotateY(iTime * 0.5f);\n\n    float Plane0 = sdPlane(CurrentPosition ,vec4(0.0f,1.0f,0.0f,0.3f)); \n    float Distance = Plane0; \n    float Sphere0 = SphereSDF(CurrentPosition , vec3(1.9f,0.15f,0.5f),0.3f);\n    float Sphere1 = SphereSDF(CurrentPosition , vec3(1.0f,0.2f,1.0f),0.5f);\n    float Cube0 = CubeSDF(CurrentPosition , vec3(1.1f,1.1f,1.1f),vec3(0.0f,0.801f,3.0f),0.2f,Rotation);\n    float Cube1 = CubeSDF(CurrentPosition , vec3(0.55f),vec3(3.5f,1.0f,3.0f),0.3f,Rotation);\n\n    Distance = min(Distance,Sphere0);\n    Distance = min(Distance,Cube1);\n    Distance = min(Distance,Sphere1);\n    Distance = min(Distance,Cube0);\n\n    vec3 ObjectColor = MESHCOLOR;\n    if(Distance >= Sphere0)\n    {\n       ObjectColor = vec3(0.3f,0.1f,0.0f);\n       MeshRoughness = 0.5f;\n    }\n    else if(Distance >= Sphere1)\n    {\n       ObjectColor = vec3(0.1f,0.4f,0.3f);\n       MeshRoughness = 0.3f;\n    }\n    else if(Distance >= Cube0)\n    {\n       ObjectColor = vec3(0.8f,0.0f,0.1f);\n       MeshRoughness = 0.3f;\n    }\n    else if(Distance >= Cube1)\n    {\n       ObjectColor = vec3(0.5f,0.0f,0.1f);\n       MeshRoughness = 0.6f;\n    }\n    else if(Distance >= Plane0)\n    {\n       ObjectColor = vec3(0.15f,0.1f,0.15f);\n       MeshRoughness = 0.3f;\n    }\n\n    return vec4(Distance,ObjectColor);\n}\n\nfloat World(vec3 CurrentPosition)\n{\n    mat3 Rotation = RotateY(iTime * 0.5f);\n\n    float Plane0 = sdPlane(CurrentPosition ,vec4(0.0f,1.0f,0.0f,0.3f)); \n    float Distance = Plane0; \n    float Sphere0 = SphereSDF(CurrentPosition , vec3(1.9f,0.15f,0.5f),0.3f);\n    float Sphere1 = SphereSDF(CurrentPosition , vec3(1.0f,0.2f,1.0f),0.5f);\n    float Cube0 = CubeSDF(CurrentPosition , vec3(1.1f,1.1f,1.1f),vec3(0.0f,0.801f,3.0f),0.2f,Rotation);\n    float Cube1 = CubeSDF(CurrentPosition , vec3(0.55f),vec3(3.5f,1.0f,3.0f),0.3f,Rotation);\n\n    Distance = min(Distance,Sphere0);\n    Distance = min(Distance,Cube1);\n    Distance = min(Distance,Sphere1);\n    Distance = min(Distance,Cube0);\n\n    return Distance;\n}\n\nfloat GetShadow(vec3 CurrentPosition,vec3 LightDirection,int ShadowSteps)\n{\n    float shadow = 1.0;\n    const float SHADOW_STEP_SIZE = 0.08f; \n    float TotalDistance = 0.0f;\n    vec3 ShadowOrigin = CurrentPosition + 0.05f * LightDirection;\n        \n    for(int i = 0;i < ShadowSteps;i++)\n    {\n       vec3 CurrentPos = ShadowOrigin + float(i) * SHADOW_STEP_SIZE * LightDirection;\n       float DistanceToClosest = World(CurrentPos);\n       \n       if(DistanceToClosest < Epsilon)\n       {\n         return 0.0f;\n       }\n       shadow = min(shadow,80.0f * (DistanceToClosest/TotalDistance));\n       TotalDistance += DistanceToClosest;\n    }\n    return shadow;\n}\n\nvec3 GetNormals(vec3 CurrentPosition)\n{\n   const vec3 Step = vec3(0.001, 0.0, 0.0);\n   \n   float nX = World(CurrentPosition + Step.xyy) - World(CurrentPosition - Step.xyy); \n   float nY = World(CurrentPosition + Step.yxy) - World(CurrentPosition - Step.yxy);\n   float nZ = World(CurrentPosition + Step.yyx) - World(CurrentPosition - Step.yyx);\n \n   return normalize(vec3(nX,nY,nZ));\n}\n\n\nvec3 GetShading(vec3 CurrentPosition,vec3 CameraPosition,vec3 ObjectColor,inout vec3 HitNormals,int ShadowSteps)\n{\n   vec3 N = GetNormals(CurrentPosition);\n   \n   HitNormals = N;\n   \n   vec3 L = LIGHTDIRECTION;\n   L.x *= -sin(iTime / 2.0f);\n   L = normalize(L);\n   \n   vec3 V = normalize(CameraPosition - CurrentPosition);\n   vec3 H = normalize(V + L); \n   \n   float specular = pow(max(dot(H,N),0.0f), 100.0f - (100.0f * MeshRoughness));\n      \n   float NdotL = max(dot(N,L) * 0.8f,0.0f);\n   float Ambient = 0.01f;\n    \n   vec3 F0 = vec3(0.04);\n   float roughness = clamp(pow(MeshRoughness * MeshRoughness,0.1f),0.0f,1.0f);\n   vec3 fresnel = F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(clamp(1.0 - max(dot(N,V),0.0f),0.0,1.0),5.0); \n    \n   float Depth = pow(distance(CameraPosition,CurrentPosition) / (FARPLANE * 0.1f),0.55f); \n   float shadow = GetShadow(CurrentPosition,L,ShadowSteps);\n   \n   vec3 OutColor = clamp(ObjectColor + (NdotL + specular) * shadow + fresnel,0.0f,1.0f);\n   return mix(OutColor.xyz,SKYCOLOR,Depth *0.7f);\n}\n\nvec3 RayMarchReflections(vec3 ro , vec3 rd,int IterationCount,inout vec3 HitPosition,inout vec3 HitNormals,inout bool HitOnObject)\n{\n    float DistanceTraveled = 0.0f;\n    \n    for(int i = 0;i < IterationCount;i++)\n    {\n       vec3 CurrentPos = ro + rd * DistanceTraveled;\n       \n       vec4 DistanceColor = WorldShading(CurrentPos);\n       float DistanceToClosest = DistanceColor.x;\n      \n       if(DistanceToClosest < Epsilon)\n       {\n          HitOnObject = true;\n          HitPosition = CurrentPos;\n          return GetShading(CurrentPos,ro,DistanceColor.yzw,HitNormals,IterationCount / 2);\n       }\n       \n       if(DistanceTraveled > FARPLANE)\n       {\n          break;\n       }\n       \n       DistanceTraveled += DistanceToClosest; \n    }\n    HitOnObject = false;\n    HitNormals = vec3(0.0f);\n    HitPosition = vec3(0.0f);\n    //return vec3(0.0f);\n    return SKYCOLOR * (1.0f-(dot(vec3(0.0,1.0f,0.0f),rd) * 0.5f + 0.5f)) * 2.0f;\n}\n\n\nvec3 RayMarch(vec3 ro , vec3 rd,int IterationCount,inout vec3 HitPosition,inout vec3 HitNormals,inout bool HitOnObject)\n{\n    float DistanceTraveled = 0.0f;\n    \n    for(int i = 0;i < IterationCount;i++)\n    {\n       vec3 CurrentPos = ro + rd * DistanceTraveled;\n       \n       vec4 DistanceColor = WorldShading(CurrentPos);\n       float DistanceToClosest = DistanceColor.x;\n       \n       \n       if(DistanceToClosest < Epsilon)\n       {\n          HitOnObject = true;\n          HitPosition = CurrentPos;\n          return GetShading(CurrentPos,ro,DistanceColor.yzw,HitNormals,100);\n       }\n       \n       if(DistanceTraveled > FARPLANE)\n       {\n          break;\n       }\n       \n       DistanceTraveled += DistanceToClosest; \n    }\n    HitOnObject = false;\n    HitNormals = vec3(0.0f);\n    HitPosition = vec3(0.0f);\n    return SKYCOLOR * (1.0f-(dot(vec3(0.0,1.0f,0.0f),rd) * 0.5f + 0.5f)) * 2.0f;\n}\n\nvec3 CameraRay(vec3 CameraDirection,vec2 UV,float FOV,vec3 UpVector)\n{\n    vec3 CameraRight = cross(UpVector,CameraDirection);\n    vec3 CameraUp = cross(CameraRight,CameraDirection);\n    float fovScale = tan(radians(FOV) / 2.0);\n    return normalize(CameraDirection + (UV.x * CameraRight + UV.y * -CameraUp) * fovScale);\n}\n\nvec2 GetKeyCoord() {\n    return vec2(\n    \ttexelFetch(iChannel0, ivec2(0, 0), 0).r,\n        texelFetch(iChannel0, ivec2(1, 0), 0).r\n    );\n}\n\nvec2 randomVector(vec2 Point)\n{\n\tPoint += 0.1f;\n\tfloat x = dot(Point,vec2(128.0f,256.0f));\n\tfloat y = dot(Point,vec2(256.0f,228.0f));\n\n\tvec2 Gradient = vec2(x,y);\n\tGradient = sin(Gradient);\n\tGradient *= 4542455.0f;\n\tGradient = sin(Gradient);\n\treturn Gradient;\n}\n\nfloat Noise(vec2 UV,float NoiseSize)\n{\n  vec2 chunksUV = fract(UV * NoiseSize);\n  vec2 chunkID = floor(UV * NoiseSize);\n  \n  vec2 corner0 = chunkID + vec2(0.0f,0.0f);\n  vec2 corner1 = chunkID + vec2(1.0f,0.0f);\n  vec2 corner2 = chunkID + vec2(0.0f,1.0f);\n  vec2 corner3 = chunkID + vec2(1.0f,1.0f);\n  \n  vec2 d0 = chunksUV - vec2(0.0f,0.0f);\n  vec2 d1 = chunksUV - vec2(1.0f,0.0f);\n  vec2 d2 = chunksUV - vec2(0.0f,1.0f);\n  vec2 d3 = chunksUV - vec2(1.0f,1.0f);\n    \n  vec2 r0 = randomVector(corner0);\n  vec2 r1 = randomVector(corner1);\n  vec2 r2 = randomVector(corner2);\n  vec2 r3 = randomVector(corner3);\n    \n  float f0 = dot(d0 , r0);\n  float f1 = dot(d1 , r1);\n  float f2 = dot(d2 , r2);\n  float f3 = dot(d3 , r3);\n  \n  chunksUV = smoothstep(0.0f,1.0f,chunksUV);\n\n  float a = mix(f0,f1,chunksUV.x);\n  float b = mix(f2,f3,chunksUV.x);\n  float noise = mix(a,b,chunksUV.y);\n  \n  return noise;\n}\n\nvec3 SampleSemiSphere(vec2 seed,vec3 Normal)\n{\n    float phi = 2.0f * PI * seed.x;\n    float cosTheta = sqrt(1.0f - seed.y);\n    float sinTheta = sqrt(seed.y);\n\n    vec3 SampledVector = vec3(cos(phi) * sinTheta,\n                              sin(phi) * sinTheta,\n                              cosTheta);\n    \n    vec3 Tangent = normalize(cross(UP_VECTOR,Normal));\n    vec3 Bitangent = normalize(cross(Tangent,Normal));\n                              \n    return normalize(SampledVector.x * Tangent + SampledVector.y * Bitangent + SampledVector.x * Normal);\n}\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy ,vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 MonteCarloTrace(vec3 ro , vec3 rd,vec2 uv,inout vec3 HitPosition,inout vec3 HitNormals,inout bool HitOnObject)\n{ \n    int SAMPLE_COUNT = 10;\n    vec3 IntegratedColor = vec3(0.0f);\n    for(int i = 0;i < SAMPLE_COUNT;i++)\n    {\n      vec2 seed = vec2(sqrt(rand(uv)),sqrt(rand(uv)));\n      IntegratedColor += RayMarch(ro,SampleSemiSphere(seed,rd),100,HitPosition,HitNormals,HitOnObject);\n    }\n    \n    IntegratedColor /= vec3(SAMPLE_COUNT);\n    return IntegratedColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy; \n    vec2 UVndc = uv * 2.0f - 1.0f;\n    UVndc.x *= iResolution.x / iResolution.y;\n\n    vec2 KeyInputs = GetKeyCoord();\n    vec2 MouseCoords = (iMouse.xy / iResolution.xy) * 2.0f - 1.0f;\n    MouseCoords *= vec2(2.0f * PI,PI);\n    \n    mat3 RotationMatrix;\n    \n    if(iMouse.xy != vec2(0.0f))\n    {\n      RotationMatrix = RotateX(MouseCoords.y) * RotateY(MouseCoords.x);\n    }\n    else\n    {\n      RotationMatrix = GetIdentityMatrix();\n    }\n    \n#ifndef NO_ANIMATION\n    \n    float Radius = 6.0f;\n    vec3 CameraPosition = vec3(cos(iTime / Radius) * Radius,1.0f,sin(iTime / Radius)* Radius) + vec3(0.0f,0.0f,3.0f) + vec3(KeyInputs,0.0f);\n    vec3 CameraDirection = normalize(-CameraPosition) * RotationMatrix;\n\n#else\n  \n    vec3 CameraPosition = vec3(1.5f,1.0f,-2.0f) + vec3(KeyInputs,0.0f);\n    vec3 CameraDirection = normalize(vec3(0.0f,0.0f,1.0f)) * RotationMatrix;\n    \n#endif\n\n    CameraDirection = CameraRay(CameraDirection,UVndc,60.0f,vec3(0.0f,1.0f,0.0f));\n    bool HitOnObject;\n    vec3 ReflectedNormal;\n    vec3 ReflectedPosition;\n    //vec3 CorePass = RayMarch(CameraPosition,CameraDirection,300,ReflectedPosition,ReflectedNormal,HitOnObject);\n    vec3 CorePass =  MonteCarloTrace(CameraPosition,CameraDirection,uv,ReflectedPosition,ReflectedNormal,HitOnObject);\n\n    vec3 OutColor = CorePass;\n    float SurfaceRoughness = MeshRoughness;\n    vec3 CameraRay = CameraDirection;\n    \n    //uv.x *= iResolution.x / iResolution.y;\n    //vec3 TriplanerNormal = abs(ReflectedNormal);\n\n    //vec3 NoiseColor = vec3(Noise((ReflectedPosition.yz * 0.5f + 0.5f) * TriplanerNormal.x ,15.0f));\n    //NoiseColor += vec3(Noise((ReflectedPosition.xz * 0.5f + 0.5f) * TriplanerNormal.y ,15.0f));\n    //NoiseColor += vec3(Noise((ReflectedPosition.xy * 0.5f + 0.5f) * TriplanerNormal.z ,15.0f));\n\n \n    int BounceCount = 10;\n    for(int i = 0;i < BounceCount;i++)\n    {\n      if(HitOnObject)\n      {\n        ReflectedNormal = reflect(CameraRay,ReflectedNormal);\n        CameraRay = ReflectedNormal;\n        //vec3 ReflectionPass = RayMarchReflections(ReflectedPosition + ReflectedNormal * 0.005f,ReflectedNormal,int(150.0f / float(i + 1)),ReflectedPosition,ReflectedNormal,HitOnObject);\n        vec3 ReflectionPass = MonteCarloTrace(ReflectedPosition + ReflectedNormal * 0.005f,ReflectedNormal,uv,ReflectedPosition,ReflectedNormal,HitOnObject);\n        if(i == 0)\n        {\n          MeshRoughness = SurfaceRoughness;\n        }\n        OutColor = clamp(mix(OutColor,ReflectionPass,(SurfaceRoughness * MeshRoughness) / float(i + 1)),0.0f,1.0f);\n        \n        //OutColor += ReflectionPass;\n      }\n    }\n    \n   \n        \n    float Gamma = 0.7f;\n    OutColor = clamp(pow(OutColor.xyz,vec3(1.0f / Gamma)),0.0f,1.0f);\n    \n    \n    fragColor = vec4(OutColor,1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst float speed = 10.0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float outData = 0.0;\n    \n    switch(int(fragCoord.x)) {\n        case 0:\n        \toutData = texelFetch(iChannel0, ivec2(0), 0).r +\n                (iTimeDelta * speed) * texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).r -\n                (iTimeDelta * speed) * texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).r;\n        \tbreak;\n        \n        case 1:\n        \toutData = texelFetch(iChannel0, ivec2(1, 0), 0).r +\n                (iTimeDelta * speed) * texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).r -\n        \t\t(iTimeDelta * speed) * texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).r;\n        \tbreak;\n    }\n    \n    fragColor = vec4(outData, 0.0, 0.0, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}