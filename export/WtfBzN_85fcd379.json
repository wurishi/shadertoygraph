{"ver":"0.1","info":{"id":"WtfBzN","date":"1596095572","viewed":181,"name":"2D plotting","username":"nikat","description":"Demonstrates different approaches to plotting.\n\nPurple — compare |f(x)-y| to epsilon.\nBlue —  same, but correct epsilon by derivative value.\nRed —  sampling without epsilon-comparison.\n\nInspired by https://www.shadertoy.com/view/4scSz4\n","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","function","plot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Created by Nikita Miropolskiy, nikat/2020\n\n\tinspired by this shader https://www.shadertoy.com/view/4scSz4\n\n */\n\nvec3 colBackground1 = vec3( 0.92, 0.96, 0.9);\nvec3 colBackground2 = vec3( 0.87, 0.93, 0.83);\nvec3 colAxes        = vec3( 0.1,  0.1,  0.1);\nvec3 colNaive       = vec3( 0.5,  0.0,  0.5);\nvec3 colDerivative  = vec3( 0.1,  0.0,  0.7);\nvec3 colSampling    = vec3( 0.7,  0.0,  0.0);\n\n// This is a function that we want to plot.\nfloat f(float x) {\n    //return sin(x);\n    return sin(10.0*sin(iTime*0.33) + 3.0*x*sin(x));\n}\n\n// This is the algebraic derivative of f function\n// for example go to www.wolframalpha.com and search \"sin(c + 3.0*x*sin(x))'\"\n//float df(float x) {\n//    return 3.0*(sin(x) + x*cos(x))*cos(10.0*sin(iTime*0.33) + 3.0*x*sin(x));\n//}\n\nvec2 frag2point(in vec2 frag) {\n    return 4.0*(frag - 0.5*iResolution.xy)/iResolution.yy;\n}\n\nfloat samples2stroke(float ratio) {\n    return 1.0 - smoothstep(0.0, 0.5, ratio)*smoothstep(1.0, 0.5, ratio);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // draw grid\n\tvec2 p = frag2point(fragCoord);\n    vec3 col = mix(colBackground1, colBackground2, mod(floor(p.x)+floor(p.y), 2.0));\n    \n    // naive comparison\n    float epsilon = 0.01;\n    float plotNaive = smoothstep(0.0, 2.0*epsilon, abs(p.y - f(p.x)));\n    \n    // algebraic derivative calculation\n    // float dy = df(p.x);\n    \n    // numeric derivative calculation\n    float dy = (f(p.x+epsilon*0.5)-f(p.x-epsilon*0.5))/epsilon;\n    \n    // comparsion with derivative correction\n    float plotDerivative = smoothstep(0.0, 2.0*epsilon*sqrt(1.0+dy*dy), abs(p.y - f(p.x)));\n    \n    // sampling\n    float pixSample = 0.5;\n    float pixWidth = 1.0;\n    float plot = 0.0, axes = 0.0;\n    float total = 0.0;\n    for (float sx = fragCoord.x-pixWidth; sx <= fragCoord.x+pixWidth; sx += pixSample) {\n        for (float sy = fragCoord.y-pixWidth; sy <= fragCoord.y+pixWidth; sy += pixSample) {\n            total++;\n            vec2 s = frag2point(vec2(sx, sy));\n            if ( f(s.x) > s.y ) plot++;\n            if ( s.x*s.y > 0.0 ) axes++;            \n        }\n    }\n    float plotAxes = samples2stroke(axes/total);\n    float plotSampling = samples2stroke(plot/total);\n    \n    // draw axes\n    col = mix(colAxes, col, plotAxes);\n    \n    // draw plot depending on fragCoord.x\n    if (fragCoord.x < 0.33*iResolution.x) {\n        // naive approach\n    \tcol = mix(colNaive, col, plotNaive);\n    } else if (fragCoord.x < 0.67*iResolution.x)  {\n        // derivative calculation\n\t   \tcol = mix(colDerivative, col, plotDerivative);\n    } else {\n    \t// sampling\n\t\tcol = mix(colSampling, col, plotSampling);\n    }\n    \n    // vignetting\t\n\tcol *= 1.0 - 0.1*length(p);\n    \n    // output\n    fragColor = vec4(col, 1.0);  \n}","name":"Image","description":"","type":"image"}]}