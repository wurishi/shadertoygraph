{"ver":"0.1","info":{"id":"7t3yR2","date":"1660169510","viewed":528,"name":"Multi Sampling Anti-Aliasing","username":"GCScholar","description":"A Ray traces scene that implements MSAA Multisampling anti-aliasing, note how the shperes boundaries on the right show less alias than the ones on the left.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["aliasing","antialiasing","msaa","alias","multisampling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ray traced scene that demonstrate the use of MSAA MULTISAMPLING ANTI-ALIASING\n//\n// Some spheres are ray traced. The intersection of the ray with the scene objects is super-sampled\n// while the shading is computed only once if all the samples hit the same object.\n// Otherwise the shading is computed for each object under the pixel and averaged.\n\n// Note how the spheres boundaries on the right show less alias than the ones on the left.\n\n// MSAA sub samples number\n#define MSAA_NX 16\n\n#define INF 10E5\n#define FOCAL_LENGTH 1.5\n#define N_SPHERES 50\n\n\n// Color palette\nvec3 samplePalette(float t)\n{\n     vec3 a = vec3(0.5,0.5,0.5);\n     vec3 b = vec3(.5,0.5,0.5);\n     vec3 c = vec3(1.0,1.0,1.0);\n     vec3 d = vec3(0.,0.2,0.4);\n     \n     return getColor(a,b,c,d,t);\n}    \n\nstruct Hit \n{\n    float t;\n    vec3 point;\n    vec3 normal;\n    int objId;\n};\n\nstruct Material \n{\n\tfloat shininess;\n    vec3 fresnelR0;\n    vec3 diffuseAlbedo;\n};\n\nMaterial getMaterial(Hit hit)\n{\n    Material mat;\n    mat.shininess = 0.1;\n    mat.fresnelR0 =\tvec3(0.3);\n    mat.diffuseAlbedo = samplePalette(float(hit.objId*10)/800.);   \n    return mat;\n}\n\nbool traceSphere(vec3 eye, vec3 ray, vec3 center, float radius, out Hit hit)\n{ \n    float t0, t1;\n\n    vec3 L = eye-center;\n    float a = dot(ray,ray);\n    float b = 2. * dot(ray,L); \n    float c = dot(L,L) - (radius*radius);\n    if (!solveQuadratic(a, b, c, t0, t1)) return false; \n    \n    if (t0 > t1) swap(t0, t1); \n\n    if (t0 < 0.) \n    { \n        t0 = t1;  //if t0 is negative, let's use t1 instead \n        if (t0 < 0.) return false;  //both t0 and t1 are negative \n    } \n\n    hit.t = t0;\n    hit.point = eye + t0*ray;\n    hit.normal = normalize(hit.point - center);\n    \n    return true; \n} \n\n// ILLUMINATION MODEL\n\nvec3 SchlickFresnel(vec3 R0, vec3 N, vec3 L)\n{\n\t\n\tfloat f0 = 1.0f - max(dot(N, L), 0.0);\n    return R0 + (1.0f - R0)*(f0*f0*f0*f0*f0);\n}\n\nvec3 BlinnPhong(vec3 lightStrength, vec3 L, vec3 N, vec3 V, Material mat)\n{\n    vec3 H = normalize(L+V);\t// Half vector between View and Light vector\n\t\n    float m = mat.shininess * 256.0;\n    float roughnessFactor = ((m + 8.0)*pow(max(dot(H,N),0.0), m))/8.0;\t// Controls how much smooth is the material, taking into account normalization for energy conservation    \n\tvec3 fresnelFactor = SchlickFresnel(mat.fresnelR0, H, L);\n    vec3 specAlbedo = fresnelFactor*roughnessFactor;\n    specAlbedo = specAlbedo / (specAlbedo + 1.0f);\t// the formula goes outside [0,1]\n    return (mat.diffuseAlbedo.rgb + specAlbedo) * lightStrength;\n}\n\nvec4 render(Hit hit, vec3 eye)\n{\n    if(hit.objId == -1) return vec4(1); // Background\n    \n    // Material properties\n    Material mat = getMaterial(hit);\n   \t\n    vec3 V = normalize(eye - hit.point);\t// Vector from surface point to the camera\n\tvec3 N = hit.normal; \n    vec3 R = reflect(-V,N);\t\t// Reflected light vector respect to N\n    \n    \n    vec3 light1Color = vec3(0.9);\n    vec3 toLight1Dir = normalize(hit.point - vec3(-0.5, 0.5, 0.5));\n\n    vec3 light2Color = vec3(0.2);\n    vec3 toLight2Dir = normalize(vec3(0., -0.5, 0.5));\n    \n    vec3 light3Color = vec3(0.9);\n    vec3 toLight3Dir = normalize(vec3(0., 0.5, 0.0));\n    \n    \n    // Lambert-law attenuation\n    vec3 light1Strength = max(dot(toLight1Dir,N),0.0)*light1Color;\n    vec3 C_light1 = BlinnPhong(light1Strength, toLight1Dir, N, V, mat);\n    \n    vec3 light2Strength = max(dot(toLight2Dir,N),0.0)*light2Color;\n    vec3 C_light2 = BlinnPhong(light2Strength, toLight2Dir, N, V, mat);\n\n    vec3 light3Strength = max(dot(toLight3Dir,N),0.0)*light3Color;\n    vec3 C_light3 = BlinnPhong(light3Strength, toLight3Dir, N, V, mat);\n\n    return vec4(C_light1 + C_light2 + C_light3,1.0);\n}\n\nHit traceScene(vec3 ray, vec3 eye)\n{\n    Hit hit; \n    float minT = INF;\n    \n    for(int i=0; i<N_SPHERES; i++)\n    {\n        float id = float(i);\n        float a = 3.;\n        vec3 pos = vec3(a*sin(float(iFrame)/200.+id*244.),a*cos(float(iFrame)/200.+id*17.),a*sin(float(iFrame)/100.+id*1724.)) * 2.;\n        pos.z = pos.z + mod(float(i),3.) * 3.;\n        \n        Hit objHit;\n        if(traceSphere(eye, ray, pos, 0.5, objHit) && hit.t < minT)\n        {\n            minT = hit.t = objHit.t;\n            hit.point = objHit.point;\n            hit.normal = objHit.normal;\n            hit.objId = i;\n        }\n    }\n    \n    if(minT == INF) hit.objId = -1; // No hit\n    \n    return hit;\n}\n\n// The filter is a square grid of dimension filterSize X filterSize\nvec4 MultiSamplingNX(int filterSize, vec3 eye, vec3 target, vec3 ww, vec3 vv, vec3 uu, vec2 U)\n{\n    int nSteps = int(sqrt(float(filterSize)));\n    \n    vec4 color;\n    vec3 ray;\n\n    float pixelSize = 1./(0.5*iResolution.x);\n    float filterStep = pixelSize/float(nSteps);\n        \n            \n    // SUB SAMPLING THE PIXEL\n    Hit hits[MSAA_NX];\n    for(int i=0; i<nSteps; i++)\n    {\n        for(int j=0; j<nSteps; j++)\n        {\n            Hit hit;\n            vec3 xx = (U.x-float(pixelSize)/2.+filterStep*float(i)) * vv;\n            vec3 yy = (U.y-float(pixelSize)/2.+filterStep*float(j)) * uu;\n            vec3 zz = FOCAL_LENGTH * ww;\n            ray = normalize(xx + yy - zz);\n            hit = traceScene(ray, eye);\n            hits[i*nSteps+j] = hit;\n        }\n    }\n    \n    // Only render if there are different samples\n    vec4 s = render(hits[0], eye);\n    for(int i=1; i<MSAA_NX; i++)\n    {\n        if(hits[i].objId != hits[0].objId)\n        {\n            color += render(hits[i], eye);\n        }\n        else\n        {\n           color += s;\n        }\n    }\n    color /= float(MSAA_NX);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 U = (2.*fragCoord-iResolution.xy)/(iResolution.x);\n    vec3 eye = vec3(15.0*sin(0.),0.,15.0*cos(0.));\n    vec3 target = vec3(0.,1.,0.);\n   \t\n    // Reference frame\n    vec3 ww = normalize(eye-target);\n    vec3 vv = normalize(cross(vec3(0.,1.,0.), ww));\n    vec3 uu = normalize(cross(ww, vv));\n    \n    \n    float sepLine = abs(iResolution.x/2.);\n    float center = step(2., abs(sepLine - fragCoord.x));\n    if(center == 0.)\n    {\n        fragColor = vec4(0);\n    }\n    else \n    {\n        if(fragCoord.x > sepLine)\n        {\n            // Right: With MSAA\n            fragColor = MultiSamplingNX(MSAA_NX, eye, target, ww, vv, uu, U);\n        }\n        else \n        {\n            // Left: Without MSAA\n            vec3 ray = normalize(U.x*vv + U.y*uu - FOCAL_LENGTH*ww);       \n            Hit hit;\n            hit = traceScene(ray, eye);\n            if(hit.objId == -1) fragColor = vec4(1);\n            else fragColor = render(hit, eye);\n        }\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI acos(-1.)\n\n// Palette generator tnx Iq\nvec3 getColor(vec3 a, vec3 b, vec3 c, vec3 d, float t)\n{\n    return a + b*cos(2.*PI*(t*c+d));\n}\n\nvoid swap(inout float x0, inout float x1)\n{\n    float tmp = x0;\n    x0=x1;\n    x1=tmp;\n}\n\nbool solveQuadratic(float a, float b, float c, out float x0, out float x1) \n{ \n    float delta = b*b-4.*a*c; \n    if (delta < 0.) return false; \n    else if (delta == 0.) \n    {\n        x0 = x1 = -0.5*b/a; \n    }\n    else \n    { \n        float q = (b > 0.) ? -0.5 * (b + sqrt(delta)) : -0.5 * (b - sqrt(delta)); \n        x0 = q/a; \n        x1 = c/q; \n    } \n    \n    return true; \n} ","name":"Common","description":"","type":"common"}]}