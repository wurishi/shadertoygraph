{"ver":"0.1","info":{"id":"NdKGWD","date":"1631645306","viewed":78,"name":"Rotating cylinder","username":"erikwolf","description":"Rotating cylinder","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["rotating","cylinder"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXH 8\n#define RAD 1.5\n#define MAXC 14\n#define CAM_DIST 1.5\n\nmat4 transZMatrix(float zValue) {\n    return mat4(1., 0., 0., 0.,\n                0., 1., 0., 0.,\n                0., 0., 1., 0.,\n                0., 0., zValue, 1.);\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Normalized pixel coordinates (from -.5 to .5)\n    uv -= .5;\n\n    // Isotropic (x: -.8889 .. .8889, y: -.5 to .5) for iResolution = <800, 450>\n    uv.x *= iResolution.x/iResolution.y;\n\n    // Define points in space\n    vec3 points[MAXH*MAXC];\n    for (int h = 0; h < MAXH; ++h) {\n       float y = -3. + 6.*float(h)/float(MAXH - 1);\n       for (int i = 0; i < MAXC; ++i) {\n          float angle = float(i)/float(MAXC)*2.*radians(180.);\n          float x = RAD * cos(angle);\n          float z = RAD * sin(angle) - 12.;\n          points[h*MAXC + i] = vec3(x, y, z);\n       }\n    }\n\n    mat4 m = transZMatrix(-12.) * rotationMatrix(vec3(-1.,0.,1.), iTime) * transZMatrix(12.);\n    for (int i = 0; i < MAXH*MAXC; ++i) {\n       points[i] = (m * vec4(points[i], 1.)).xyz;\n    }\n    \n    // Camera position, ray to screen & color\n    vec3 camPos = vec3(0, 0, CAM_DIST);\n    vec3 rayToScreen = vec3(uv.xy, 0) - camPos;\n    vec3 clr = vec3(0., 0., 0.);\n    \n    for (int h = 0; h < MAXH; ++h) {\n        float q = 0.;\n        float g = float(h)/float(MAXH-1);\n        for (int i = 0; i < MAXC; ++i) {\n           vec3 pis = points[h*MAXC + i];  // Point in space\n\n           float parallelogramArea = length(cross(rayToScreen, pis - camPos));\n           float distanceFromRay = parallelogramArea / length(rayToScreen);\n\n           q = max(q, smoothstep(.15, .1, distanceFromRay));\n           clr = mix(clr, vec3(.9,g,0.), q);\n        }\n    }\n    fragColor = vec4(clr,1.0);\n}\n","name":"Image","description":"","type":"image"}]}