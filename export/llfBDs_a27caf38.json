{"ver":"0.1","info":{"id":"llfBDs","date":"1513904950","viewed":191,"name":"2 balls","username":"saidwho12","description":"just 2 balls.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","phong","ray","spheretracing","blinn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITERATIONS 256\n\n#define RAY_T_MIN 0.001\n#define RAY_T_MAX 1.0e30\n\n#define EPSILON 0.01\n\n// Polynomial smooth minimum by iq\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n  return mix(a, b, h) - k*h*(1.0-h);\n}\n\nstruct Light\n{\n    vec3 point;\n};\n\nstruct Material \n{\n    float ambient;\n\tfloat diffuse;\n    float specular;\n    float a; // a >> 1.0\n};\n\n\nfloat phong (in vec3 L, in vec3 N, in vec3 R, in vec3 V, in Light light, in Material mat)\n{\n    float diffuse = mat.diffuse*dot(L, N);\n    float specular = mat.specular*pow(dot(R, V), mat.a);\n\n\treturn diffuse + specular + mat.ambient;\n}\n\nstruct Sphere \n{\n\tvec3 center;\n    float r;\n};\n\n    \nstruct Plane\n{\n    vec3 center;\n    vec3 normal;\n};\n    \nfloat opU(float d1, float d2)\n{\n    return min(d1,d2);\n}\n\nfloat opS( float d1, float d2)\n{\n    return max(-d1,d2);\n}\n\nfloat opI(float d1, float d2)\n{\n    return max(d1,d2);\n}\n\nfloat sphereSDF (vec3 point, Sphere s)\n{\n\treturn distance(point, s.center)-s.r;\n}\n\nfloat opBlendSS (vec3 p, Sphere s1, Sphere s2, float k)\n{\n    float d1 = sphereSDF(p, s1);\n    float d2 = sphereSDF(p, s2);\n    return smin(d1, d2, k);\n}\n\nfloat sceneSDF (vec3 p)\n{\n    Sphere s1 = Sphere(vec3(sin(-iTime)*3., 1.5, 0), 2.0);\n    Sphere s2 = Sphere(vec3(sin(iTime)*3., -1.5, 0), 2.0);\n    vec3 c = vec3(15.,15.,15.);\n    vec3 q = mod(p,c)-0.5*c;\n    return opBlendSS(q, s1, s2, 1.5);\n}\n\nvec3 estimateNormal(vec3 point) {\n    return normalize(vec3(\n        sceneSDF(vec3(point.x + EPSILON, point.y, point.z)) - sceneSDF(vec3(point.x - EPSILON, point.y, point.z)),\n        sceneSDF(vec3(point.x, point.y + EPSILON, point.z)) - sceneSDF(vec3(point.x, point.y - EPSILON, point.z)),\n        sceneSDF(vec3(point.x, point.y, point.z  + EPSILON)) - sceneSDF(vec3(point.x, point.y, point.z - EPSILON))\n    ));\n}\n\nfloat trace (vec3 eye, vec3 dir)\n{\n    \n    float t = RAY_T_MIN;\n    int i = 0;    \n    while(i < MAX_ITERATIONS && t < RAY_T_MAX)\n    {\n        float radius = sceneSDF(eye + (dir*t));\n        if (radius < RAY_T_MIN)\n        {\n            break;\n        }\n        t += radius;\n        i++;\n        \n    if (i==MAX_ITERATIONS || t == RAY_T_MAX)\n        return RAY_T_MAX;\n    }\n    \n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    const float PI = 3.14159;\n    \n    vec3 eye = vec3(0,0,5);\n    \n    vec3 forward = vec3(0,0,-1);\n    vec3 up = vec3(0,1,0);\n    vec3 right = cross(forward, up);\n    \n    float fov = PI/4.0;\n    \n    float aspect = iResolution.y / iResolution.x;\n    \n    float w = tan(fov);\n    float h = w * aspect;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 point = uv*2.0-1.0;\n        \n    vec3 dir = normalize(forward + point.x * w * right + point.y * h * up);\n    \n    Light light = Light(vec3(.0, .0, 3.));\n    \n    Material mat = Material(0.0, 0.3, 0.7, 10.0);\n    \n    float t = trace(eye, dir);\n    vec3 P = eye + (dir*t); // P is point of intersection\n    \n    vec3 L = normalize(light.point - P);\n    vec3 V = dir;\n    vec3 N = estimateNormal(P);\n    vec3 R = reflect(N, L);\n   \n    vec3 color = vec3(phong(L, N, R, V, light, mat));\n    \n    /*\n    if (!(trace(P + N*0.01, L) == RAY_T_MAX))\n    {\n        color *= vec3(0.13);\n    }\n\t*/\n\t\n    //color = N+1.0 /2.0;\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}