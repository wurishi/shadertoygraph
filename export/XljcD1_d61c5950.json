{"ver":"0.1","info":{"id":"XljcD1","date":"1508546072","viewed":2767,"name":"Spell Demon Souls","username":"leon","description":"A sketch inspired by Dark Souls. Sometime you can see the twisted souls emerging from the distorted shapes. I could tweak this for days and nights...","likes":106,"published":1,"flags":0,"usePreview":1,"tags":["spell"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define STEPS 1./50.\n#define VOLUME_BIAS 0.01\n#define MIN_DIST 0.005\n#define STEP_DAMPING .9\n#define PI 3.14159\n#define TAU PI*2.\n\n// raymarch toolbox\nfloat rng (vec2 seed) { return fract(sin(dot(seed*.1684,vec2(54.649,321.547)))*450315.); }\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat sdSphere (vec3 p, float r) { return length(p)-r; }\nfloat sdCylinder (vec2 p, float r) { return length(p)-r; }\nfloat sdIso(vec3 p, float r) { return max(0.,dot(p,normalize(sign(p))))-r; }\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat amod (inout vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an/2.;\n    float c = floor(a/an);\n    a = mod(a,an)-an/2.;\n    p.xy = vec2(cos(a),sin(a))*length(p);\n    return c;\n}\n\nfloat repeat (float v, float c) { return mod(v,c)-c/2.; }\nfloat smin (float a, float b, float r) {\n    float h = clamp(.5+.5*(b-a)/r, 0., 1.);\n    return mix(b,a,h)-r*h*(1.-h);\n}\n\n// geometry for spell\nfloat tubes (vec3 pos) {\n    \n    // cylinder made of 8 tube\n    float cylinderRadius = .02; // change shape\n    vec3 p = pos;\n    p.xz *= rot(p.y*.5); // twist amount\n    float c = amod(p.xz, 8.); // amount of tubes\n    p.x -= 2.; // tube cylinder radius\n    float tube = sdCylinder(p.xz, cylinderRadius);\n    \n    // another cylinder made of tubes 16\n    p = pos;\n    p.xz *= rot(-p.y*.5); // twist amount\n    c = amod(p.xz, 16.); // amount of tubes\n    p.x -= 2.; // tube cylinder radius\n    tube = smin(tube, sdCylinder(p.xz, cylinderRadius), .15);\n    return tube;\n}\n\n// geometry for spell\nfloat disks (vec3 pos) {\n    float radius = 1.5;\n    float radiusInner = .57;\n    float thin = .01;\n    float repeatY = 2.;\n    float cellY = floor(pos.y/repeatY);\n    float a = atan(pos.z,pos.x)-iTime*.3+cellY*.1;\n    vec3 p = pos;\n    p.y += sin(a*6.)*.1;\n    p.y = repeat(p.y, repeatY);\n    float disk = max(-sdCylinder(p.xz, radiusInner), sdCylinder(p.xz, radius));\n    disk = max(abs(p.y)-thin,disk);\n    return disk;\n}\n\nvec3 anim1 (vec3 p) {\n    float t = iTime*.5;\n    p.xz *= rot(t);\n    p.xy *= rot(t*.7);\n    p.yz *= rot(t*.5);\n    return p;\n}\n\nvec3 anim2 (vec3 p) {\n    float t = -iTime*.4;\n    p.xz *= rot(t*.9);\n    p.xy *= rot(t*.6);\n    p.yz *= rot(t*.3);\n    return p;\n}\n\nfloat map (vec3 pos) {\n    float scene = 1000.;\n    \n    // ground and ceiling\n    float bump = texture(iChannel0, pos.xz*.1).r;\n    float ground = 2. - bump*.1;\n    scene = min(scene, pos.y+ground);\n    scene = min(scene, -(pos.y-ground));\n    \n    // spell geometry 1\n    vec3 p = pos;\n    p.y += sin(atan(p.z,p.x)*10.)*3.; // change numbers to get new distortion\n    p.xz *= rot(p.y*.2-iTime);\n    p = anim1(p);\n    p.x = length(p.xyz)-3.;\n    scene = smin(scene, tubes(p), .5);\n    scene = smin(scene, disks(p), .5);\n    \n    // spell geometry 2\n    p = pos;\n    p.y += sin(atan(p.z,p.x)*3.)*2.; // change numbers to get new distortion\n    p = anim2(p);\n    p.xz *= rot(p.y+iTime);\n    p.x = length(p.xyz)-3.;\n    scene = smin(scene, tubes(p), .3);\n    scene = smin(scene, disks(p), .3);\n    \n    return scene;\n}\n\nvoid camera (inout vec3 p) {\n    p.xz *= rot((-PI*(iMouse.x/iResolution.x-.5)));\n}\n\nvoid mainImage( out vec4 color, in vec2 uv )\n{\n\tuv = (uv.xy-.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    vec3 eye = vec3(0.,0.,-7.+mouse.y*3.);\n    vec3 ray = normalize(vec3(uv,.7));\n    camera(eye);\n    camera(ray);\n    vec3 pos = eye;\n    float shade = 0.;\n    for (float i = 0.; i <= 1.; i += STEPS) {\n        float dist = map(pos);\n        if (dist < VOLUME_BIAS) {\n            shade += STEPS;\n        }\n        if (shade >= 1.) break;\n        dist *= STEP_DAMPING + .1 * rng(uv+fract(iTime));\n        dist = max(MIN_DIST, dist);\n        pos += dist * ray;\n    }\n\tcolor = vec4(1);\n    color.rgb *= shade;\n}","name":"Image","description":"","type":"image"}]}