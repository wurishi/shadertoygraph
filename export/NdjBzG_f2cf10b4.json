{"ver":"0.1","info":{"id":"NdjBzG","date":"1646538772","viewed":89,"name":"dance_circle_test","username":"xuxu1702","description":"dance_circle_test","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 20.0;\nconst float EPSILON = 0.0001;\n\nstruct Torus{vec3 center;vec2 radiance;};\n\nfloat shortestDis_torus(vec3 eye, vec3 marchingDirection, float start, float end,Torus torus) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 p=(eye + depth * marchingDirection)-torus.center;//当前观测点位置\n        vec2 q = vec2(length(p.xz)-torus.radiance.x,p.y);\n        float dist=length(q)-torus.radiance.y;\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n//p为被观测点的坐标，dist为相机到被观测点的距离，camPos为相机位置\nvec3 NDir(vec3 p,float dist,vec3 camPos){\n    vec3 ndir=vec3(length(vec3(p.x+EPSILON,p.y,p.z))-length(vec3(p.x-EPSILON,p.y,p.z)),\n    length(vec3(p.x,p.y+EPSILON,p.z))-length(vec3(p.x,p.y-EPSILON,p.z)),\n    length(vec3(p.x,p.y,p.z+EPSILON))-length(vec3(p.x,p.y,p.z-EPSILON))\n    );\n    return normalize(ndir);\n}\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //基础变量------------------------------------------\n    vec3 vDir = rayDirection(45.0, iResolution.xy, fragCoord);//视线方向,指向物体\n    vec3 camPos = vec3(0.0, 0.0,8.0);//相机位置\n    vec3 lPos=vec3(10.0,10.0,10.0);//光源位置\n    vec3 d_col=vec3(0.764,0.666,0.447);//漫反射颜色\n    vec3 a_col=vec3(0.0,0.1,0.0);//环境颜色\n    vec3 col_back=vec3(137., 95., 97.)/255.;//背景颜色\n    const int n=6;//层数\n    Torus torus[2*n];\n    for (int i=0;i<n;i++){\n        float radiance1=sqrt(1.0-pow(float(i)/float(n)+1.0/float(n)*0.5,2.0));\n        vec2 radiance=vec2(radiance1,0.05);\n        vec3 center=vec3(0.,float(i)/float(n)+1.0/float(n)*0.5,0.);\n        torus[n-i-1]=Torus(center,radiance);\n        vec3 center2=vec3(0.,center.y*(-1.0),0.);\n        torus[n+i]=Torus(center2,radiance);\n    }\n    vec3 cols[2*n];\n    cols[0]=vec3(0.764,0.666,0.447);\n    cols[1]=vec3(201.0,104.0,119.)/255.;\n    cols[2]=vec3(45.,81.,93.)/255.;\n    cols[3]=vec3(202.,141.,120.)/255.;\n    cols[4]=vec3(118.,164.,151.)/255.;\n    cols[5]=vec3(175.,93.,72.)/255.;\n    cols[6]=vec3(19.,53.,65.)/255.;\n    cols[7]=vec3(148.,95.,96.)/255.;\n    cols[8]=vec3(76.,108.,97.)/255.;\n    cols[9]=vec3(162.,99.,82.)/255.;\n    cols[10]=vec3(204.,185.,129.)/255.;\n    cols[11]=vec3(100.,27.,28.)/255.;\n\n    //运动与变换----------------------------------------\n    //模型变换\n    //t1.center=vec3(1.0*sin(iTime),t1.center.yz);\n    float tr0=0.2*sin(iTime);\n    torus[0].center=vec3(0.2*sin(0.6*iTime),torus[0].center.yz);\n    torus[2].center=vec3(0.3*sin(2.0*iTime),torus[2].center.yz);\n    torus[4].center=vec3(0.4*sin(iTime),torus[4].center.yz);\n    torus[6].center=vec3(0.6*sin(1.5*iTime+1.0),torus[6].center.yz);\n    torus[8].center=vec3(0.4*sin(0.8*iTime+1.0),torus[8].center.yz);\n    torus[10].center=vec3(0.25*sin(1.2*iTime+1.0),torus[10].center.yz);\n    //视角变换\n    float cam_rotate=iTime;\n    mat4 trans_rotate=mat4(cos(cam_rotate),0.,sin(cam_rotate),0.0,\n                            0.0,1.0,0.0,0.0,\n                            -sin(cam_rotate),0.,cos(cam_rotate),0.,\n                            0.0,0.0,0.0,1.0\n    );\n    vDir=(trans_rotate*vec4(vDir,1.0)).xyz;\n    camPos=(trans_rotate*vec4(camPos,0.0)).xyz;\n    float light_rotate=iTime*2.0;\n    mat4 trans_rotate_l=mat4(cos(light_rotate),-sin(light_rotate),0.,0.0,\n                            sin(light_rotate),cos(light_rotate),0.,0.,\n                             0.0,0.0,1.0,0.0,\n                            0.0,0.0,0.0,1.0\n    );\n    lPos=(trans_rotate_l*vec4(lPos,1.0)).xyz;\n    //计算过程向量----------------------------------------\n    float dists[2*n];\n    for(int i=0;i<2*n;i++){\n        dists[i]=shortestDis_torus(camPos, vDir, MIN_DIST, MAX_DIST ,torus[i]);\n    }\n    float dist=dists[0];\n    for(int i=1;i<2*n;i++){\n        dist=unionSDF(dist,dists[i]);\n    }\n    if (dist > MAX_DIST - EPSILON) {//没有物体的像素颜色变为黑色\n        fragColor = vec4(col_back, 1.0);\n\t\treturn;\n    }\n    for(int i=0;i<n;i++){\n        if (dists[i] < MAX_DIST - EPSILON) {\n            d_col=cols[i];\n        }\n    }\n    for(int i=11;i>n/2;i--){\n        if (dists[i] < MAX_DIST - EPSILON) {\n            d_col=cols[i];\n        }\n    }\n    vec3 p=camPos+vDir*dist;//看到的物体上的点\n    vec3 nDir=NDir(p,dist,camPos);//法线方向\n    vec3 lDir=normalize(lPos-p);//光方向，指向光源\n    vec3 lrDir=normalize(reflect(lDir,nDir));//反射光方向\n    //着色模型---------------------------------------------\n    float lambert=clamp(dot(nDir,lDir),0.0,1.0);\n    lambert=0.5*lambert+0.5;\n    float phong=pow(dot(-lrDir,-vDir),200.0);\n    phong=clamp(phong,0.01,1.0);\n    vec3 diffuse=lambert*d_col;//漫反射光\n    vec3 phong_col=phong*col_back;\n\n    vec3 col=vec3(diffuse)+a_col;\n    //vec3 col=vec3(diffuse+phong_col)+a_col;\n \n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}