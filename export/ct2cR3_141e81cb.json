{"ver":"0.1","info":{"id":"ct2cR3","date":"1692105130","viewed":407,"name":"LiveCoding VJ 2023-08-14","username":"FoRenard","description":"1h\nhttps://youtu.be/oa_5EYnFlvw","likes":26,"published":1,"flags":32,"usePreview":0,"tags":["livecoding","practice","vj"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0,uv).rgb;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define time iTime\n#define resolution iResolution\n#define backbuffer iChannel0\n\n#define PI acos(-1.)\n#define TAU (2.*PI)\n\n#define sat(x) clamp(x,0.,1.)\n#define rep(i,n) for(int i=0;i<n;i++)\n\n\nfloat Time;\nint Mat;\nvec3 RO;\nmat2 rot(float a)\n{\n    float c=cos(a),s=sin(a);\n    return mat2(c,-s,s,c);\n}\nvec3 hash33(vec3 p)\n{\n    uvec3 x=floatBitsToUint(p);\n    const uint k=1892563894u;\n    x=((x>>8U)^x.yzx)*k;\n    x=((x>>8U)^x.yzx)*k;\n    x=((x>>8U)^x.yzx)*k;\n    return vec3(x)/float(0xffffffffu);\n}\nmat3 orth(vec3 z)\n{\n    z=normalize(z);\n    vec3 up=abs(z.y)>.999?vec3(0,0,1):vec3(0,1,0);\n    vec3 x=normalize(cross(up,z));\n    return mat3(x,cross(z,x),z);\n}\nvec3 cyc(vec3 p)\n{\n    float q=2.;\n    vec4 s=vec4(0);\n    mat3 b=orth(vec3(1,2,3));\n    rep(i,5)\n    {\n        p*=b;\n        p+=sin(p.yzx);\n        s+=vec4(cross(cos(p),sin(p.zxy)),1);\n        s*=q;\n        p*=2.;\n    }\n    return s.xyz/s.w;\n}\n\nfloat box(vec3 p,vec3 b)\n{\n    vec3 q=abs(p)-b;\n    return length(max(q,0.))+min(0.,max(q.x,max(q.y,q.z)));\n}\n\nfloat cap(vec3 p)\n{\n    float h=.2,r=.01;\n    p.x-=clamp(p.x,-h,h);\n    return length(p)-r;\n}\nfloat plus(vec3 p)\n{\n    vec3 i=floor(p);\n    p=fract(p)-.5;\n    float lt=floor(Time*5.);\n\n    float d=cap(p);\n    d=min(d,cap(p.zxy));\n    d=min(d,cap(p.yzx));\n\n    if(hash33(vec3(i+lt)).x<.9)d=-box(p,vec3(.65));\n\n    return d;\n}\n\nfloat sdf(vec3 p)\n{\n    float d=1e9,tmp;\n    int i=0;\n    Mat=0;\n    #define opMin(s)if(d>(tmp=s))d=tmp,Mat=i;i++;\n\n    float z=p.z-RO.z;\n    p.xy*=rot(z*.05);\n\n    opMin(-box(p-cyc(p)*.5,vec3(2,4,1e9))*.5);\n    opMin(plus(p));\n    vec3 p0=p;p0.z=mod(p0.z,10.)-5.;\n    opMin(length(p0-vec3(0,3,0))-.3);\n\n    return d;\n}\n\nvoid march(inout vec3 rp,vec3 rd,vec3 ro)\n{\n    float d=1e9,l=0.;\n    rep(i,256)\n    {\n        if(l>100.||d<1e-3)return;\n        rp=rd*l+ro;\n        l+=d=sdf(rp);\n    }\n}\n\nvec3 normal(vec3 p)\n{\n    float e=1e-4;\n    vec2 k=vec2(1,-1);\n    return normalize(\n        k.xyy*sdf(p+k.xyy*e)+\n        k.yxy*sdf(p+k.yxy*e)+\n        k.yyx*sdf(p+k.yyx*e)+\n        k.xxx*sdf(p+k.xxx*e)\n    );\n}\n\nfloat atten(float l){return 1./(1.+l*l);}\nvec3 shade(vec3 d,vec3 s,vec3 l,vec3 v,vec3 n)\n{\n    vec3 h=normalize(l+v);\n    float noh=sat(dot(n,h));\n    float nol=sat(dot(n,l));\n    return (d+s*pow(noh,50.))*nol;\n}\n\nvec3 getCol(vec3 p,vec3 rd,vec3 n)\n{\n    float z=p.z-RO.z;\n    p.xy*=rot(z*.05);\n\n    p.z=mod(p.z,10.)-5.;\n\n    vec3 dcol,scol;\n    if(Mat==0)\n    {\n        dcol=vec3(.5);\n        scol=vec3(1);\n    }\n    else if(Mat==1)\n    {\n        return vec3(2,.2,.2);\n    }\n    else if(Mat==2)\n    {\n        return vec3(2);\n    }\n\n    vec3 col=vec3(0);\n    vec3 v=-rd;\n\n    vec3 lp,l,lcol;\n    float len;\n    lp=vec3(0,3,0);\n    l=normalize(lp-p);\n    len=length(lp-p);\n    lcol=vec3(5)*atten(len)*pow(smoothstep(5.,0.,len),.5);\n    col+=shade(dcol,scol,l,v,n)*lcol;\n\n    // line\n    float sf=.1;\n    lp=vec3(-2.+sf,-4.+sf,p.z);\n    l=normalize(lp-p);\n    len=length(lp-p);\n    lcol=vec3(2)*atten(len);\n    col+=shade(dcol,scol,l,v,n)*lcol;\n\n    lp=vec3(2.-sf,-4.+sf,p.z);\n    l=normalize(lp-p);\n    len=length(lp-p);\n    lcol=vec3(2)*atten(len);\n    col+=shade(dcol,scol,l,v,n)*lcol;\n\n    return col;\n}\n\nfloat ao(vec3 p,vec3 n){return sat(sdf(p+n*.1)/.1);}\n\n\n\nfloat qt(vec2 uv)\n{\n    vec3 s;\n    int i=0,n=3;\n    for(;i<n;i++)\n    {\n        s=vec3(floor(uv),i);\n        if(hash33(s).x<.5)break;\n        uv*=2.;\n    }\n    s=vec3(floor(uv),i);\n    uv=fract(uv);\n\n    s=hash33(s);\n\n    float c=0.;\n\n    if(s.z<.5)\n    {\n        uv=(uv-.5)*rot(PI*.25)*sqrt(2.)+.5;\n    }\n\n    vec2 auv=abs(uv-.5);\n    s.y*=1.25;\n    if(s.y<.1)\n    {\n        vec2 a=auv-.3;\n        c+=float(a.x>0.||a.y>0.);\n    }\n    else if(s.y<.2)\n    {\n        c+=float(auv.x<.05||auv.y<.05);\n    }\n    else if(s.y<.4)\n    {\n        float l=abs(length(uv-.5)-.35);\n        c+=smoothstep(.05,.03,l);\n    }\n    else if(s.y<.5)\n    {\n        c+=sat(dot(vec3(1./3.),abs(cyc(vec3(uv,Time)))));\n    }\n\n    c=sat(c);\n    if(s.y<.5&&s.x<.1)\n    {\n        c=1.-c;\n    }\n\n    c*=float(auv.x<.4&&auv.y<.4);\n    return c;\n}\n\nvec3 wcol(vec3 p,vec3 n)\n{\n    // get uv\n    vec2 uv;\n    int ui=0;\n    rep(i,3)\n    {\n        if(abs(n[i])<.5)\n        uv[ui++]=p[i];\n    }\n    uv=-uv.yx;\n\n    vec3 c=vec3(0);\n    vec2 fuv=fract(uv*.5);\n\n    c+=qt(uv);\n\n    return c;\n}\n\nvec3 render(vec3 rd,vec3 ro)\n{\n    vec3 col=vec3(0);\n    vec3 rp;\n    march(rp,rd,ro);\n    vec3 n=normal(rp);\n    float depth=length(rp-ro);\n    float ao=ao(rp,n);\n    col+=getCol(rp,rd,n)+wcol(rp,n);\n\n    float fs=mix(pow(1.-sat(dot(-rd,n)),5.),1.,.15);\n    rd=reflect(rd,n);\n    ro=rp+n*1e-3;\n    march(rp,rd,ro);\n    n=normal(rp);\n    vec3 lcol=getCol(rp,rd,n)+wcol(rp,n);\n    float l=length(rp-ro);\n    col+=lcol*fs/(1.+l*l);\n    \n    col*=ao*exp(-depth*.05);\n    return col;\n}\n\nvec3 spect(float n)\n{\n    return .5+.5*cos(TAU*(n+vec3(0,.33,.67)));\n}\n\nvoid uvbakibaki(inout vec2 uv)\n{\n    int n=12;\n    rep(i,n)\n    {\n        float lt=Time*3.+float(i);\n        float li=floor(lt),lf=fract(lt);\n        lf=smoothstep(0.,1.,pow(lf,.3));\n        float ins=((i==0)?1.0-lf:(i==n-1)?lf:1.0);\n\n        vec3 s=hash33(vec3(42.42,2.4,li));\n\n        vec3 c=(hash33(s*42.1231+.12)-.5)*ins;\n        if(s.x<.6)\n        {\n            float a=PI*c.x*.5;\n            vec2 of=c.yz;\n            vec2 p=vec2(cos(a),sin(a));\n            uv-=of;\n            uv-=2.0*min(0.,dot(uv,p))*p;// fold\n            uv+=of;\n        }\n        else\n        {\n            uv*=c.z+1.;\n        }\n    }\n}\n\n\n//#define ClomaticMotion\n//#define UVbakibaki\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 fc = fragCoord, res = resolution.xy;\n    vec2 uv = fc / res, suv = (fc * 2. - res) / res.y;\n    vec3 col = vec3(0);\n\n    #ifdef ClomaticMotion\n    vec3 h3=hash33(vec3(fc,time*144.));\n    Time=time+(h3.x-.5)*.1;\n    #else\n    Time=time;\n    #endif\n\n    float sp=smoothstep(0.,1.,sat(pow(sin(Time*.05*TAU)*.5+.6,20.)));\n    \n    #ifdef UVbakibaki\n    uvbakibaki(suv);\n    #endif\n\n    float fov=mix(90.,170.,sp);\n    vec3 ro=vec3(0,0,Time*2.),z=vec3(0,0,1),y=vec3(0,1,0),x=normalize(cross(y,z));\n    y=normalize(cross(z,x));\n    vec3 rd=normalize(mat3(x,y,z)*vec3(suv,1./tan(fov*PI/360.)));\n\n    RO=ro;\n    col=render(rd,ro);\n    \n    #ifdef ClomaticMotion\n    col*=spect(h3.x)*1.5;//??\n    #endif\n\n    // post\n    col=sat(col);\n    col.r=smoothstep(.05,1.05,col.r);\n    col.g=smoothstep(.0,1.,col.g);\n    col.b=smoothstep(-.05,.95,col.b);\n\n    col=pow(col,vec3(.4545));\n\n    // ema\n    vec3 bcol=texture(backbuffer,uv).rgb;\n    col=mix(col,bcol,mix(.5,.9,sp));\n\n    fragColor = vec4(col, 1);\n}","name":"Buffer A","description":"","type":"buffer"}]}