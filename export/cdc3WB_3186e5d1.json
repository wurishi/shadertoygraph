{"ver":"0.1","info":{"id":"cdc3WB","date":"1677743863","viewed":96,"name":"水银流动3","username":"sqraaa","description":"撒地方","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["a"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float densityMin = 5.0;\n\n\n\nfloat smoothing = 0.1;\nfloat ballradius = 0.0;\nfloat metaPow = 1.0;\n\nfloat densityMax= 7.0;\nfloat densityEvolution = 0.4;\nfloat rotationSpeed = 0.005;\nvec2 moveSpeed = vec2(0.1,0.0);\nfloat distortion = 0.05;\nfloat nstrenght = 1.0;\nfloat nsize = 1.0;\nvec3 lightColor = vec3(7.0,8.0,10.0);\n\nfloat saturate1(float x)\n{\n    return clamp(x, 0.0, 1.0);\n}\nvec2 rotuv(vec2 uv, float angle, vec2 center)\n{    \n   \treturn mat2(cos(angle), -sin(angle), sin(angle), cos(angle)) * (uv - center) + center;\n}\nfloat hash(float n)\n{\n   return fract(sin(dot(vec2(n,n) ,vec2(12.9898,78.233))) * 43758.5453);  \n}  \n\nfloat metaBall(vec2 uv)\n{\n\treturn length(fract(uv) - vec2(0.5))  * 0.8;\n}\n\nfloat metaNoiseRaw(vec2 uv, float density)\n{\n    float v = 0.99;\n    float r0 = hash(2015.3548);\n    float s0 = iTime*(r0-0.5)*rotationSpeed;\n    vec2 f0 = iTime*moveSpeed*r0;\n    vec2 c0 = vec2(hash(31.2), hash(90.2)) + s0;   \n    vec2 uv0 = rotuv(uv*(1.0+r0*v), r0*360.0 + s0, c0) + f0;    \n    float metaball0 = saturate1(metaBall(uv0)*density);\n    \n    for(int i = 0; i < 15; i++)\n    {\n        float inc = float(i) * 3.0 + 1.0;\n    \tfloat r1 = hash(2015.3548*inc);\n        float s1 = iTime*(r1-0.5)*rotationSpeed;\n        vec2 f1 = iTime*moveSpeed*r1;\n    \tvec2 c1 = vec2(hash(31.2*inc), hash(90.2*inc))*100.0 + s1;   \n    \tvec2 uv1 = rotuv(uv*(1.0+r1*v), r1*360.0 + s1, c1) + f1 - metaball0*distortion;    \n    \tfloat metaball1 = saturate1(metaBall(uv1)*density);\n        \n        metaball0 *= metaball1;\n    }\n    \n    return pow(metaball0, metaPow);\n}\n\nfloat metaNoise(vec2 uv)\n{ \n    float density = densityMin; mix(densityMin,densityMax,sin(iTime*densityEvolution)*0.5+0.5);\n    return 1.0 - smoothstep(ballradius, ballradius+smoothing, metaNoiseRaw(uv, density));\n}\n\nvec4 calculateNormals(vec2 uv, float s)\n{\n    float offsetX = nsize*s/iResolution.x;\n    float offsetY = nsize*s/iResolution.y;\n\tvec2 ovX = vec2(0.0, offsetX);\n\tvec2 ovY = vec2(0.0, offsetY);\n    \n\tfloat X = (metaNoise(uv - ovX.yx) - metaNoise(uv + ovX.yx)) * nstrenght;\n    float Y = (metaNoise(uv - ovY.xy) - metaNoise(uv + ovY.xy)) * nstrenght;\n    float Z = sqrt(1.0 - saturate1(dot(vec2(X,Y), vec2(X,Y))));\n    \n    float c = abs(X+Y);\n\treturn normalize(vec4(X,Y,Z,c));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 uv2 = uv;\n   \n  \n    vec2 sphereUvs = uv - vec2(0.5);\n    float vign = length(sphereUvs);\n  \n    \n    float noise = metaNoise(uv2);\n    \n    vec4 n = calculateNormals(uv2, smoothstep(0.0, 0.5, 1.0 - vign));\n    vec3 lDir = normalize(vec3(1.0,1.0,0.0));\n    float l = max(0.0, dot(n.xyz, lDir));\n      \n    vec4 tex = texture(iChannel0, uv).rgba;\n   \n \n\t  //tex *= 1.0 - vign;\n    \n    vec3 col = tex.rgb;// mix(tex.xyz*0.75, tex.xyz+l*lightColor, noise);\n    \n\tfragColor = vec4(n.w*col*5.0 + col, 1.0);\n}","name":"Image","description":"","type":"image"}]}