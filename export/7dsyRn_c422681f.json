{"ver":"0.1","info":{"id":"7dsyRn","date":"1641617162","viewed":209,"name":"Voxel Sneak","username":"panna_pudi","description":"Old sketch of mine. And form of some shader... I'll update later when i get access to the internet next time","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["voxels"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fork of https://www.shadertoy.com/view/ldjXz1\n\n#define EPS vec3(0., 0.001, 0.0001)\n#define PI acos(-1.)\n#define time iTime\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax, p) * ax, p, cos(ro)) + sin(ro) * cross(ax, p);\n}\n\nfloat smin(float a, float b, float k) {\n    float res = exp2(-k * a) + exp2(-k * b);\n    return -log2(res) / k;\n}\n\n\nfloat sdSphere(in vec3 p, in float d) {\n    return length(p) - d;\n}\n\nfloat sdTorus(in vec3 p, in vec2 t) {\n    vec2 q = vec2( length( p.xz ) - t.x, p.y );\n    return length( q ) - t.y;\n}\n\nvec2 rotate(in vec2 p, in float t) {\n    return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 rotate(in vec3 p, in vec3 t) {\n    p.yz = rotate(p.yz, t.x);\n    p.zx = rotate(p.zx, t.y);\n    p.xy = rotate(p.xy, t.z);\n    return p;\n}\n\nfloat map(vec3 p) {\n    float size = 2.0;\n    vec3 ps = p;\n    ps = rotate(ps, vec3(0.2, time * 0.2, -time * 0.3));\n    float sphere = sdSphere(ps, size);\n    sphere = max(sphere, abs(fract(ps.x + time * 0.3)) - .8);\n\n    float size_tor = size * 1.5;\n    vec3 p1 = p;\n    p1.xy = rotate(p1.xy, -time * 0.2);\n    float torus1 = sdTorus(p1, vec2(size_tor, 0.2));\n\n    vec3 p2 = p;\n    p2.xy = rotate(p2.xy, time * 0.2);\n    p2.xy = rotate(p2.xy, PI / 2.);\n    float torus2 = sdTorus(p2, vec2(size_tor, 0.2));\n\n    float torus = smin(torus1, torus2, 1.7);\n\n    float res = min(sphere, torus);\n\n    return res;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p, p, p) - mat3(EPS.y);\n    return normalize(vec3(map(p)) - vec3(map(k[0]), map(k[1]), map(k[1])));\n}\n\nvec3 hsv(float h, float s, float v) {\n    return mix(vec3(1.0),\n               clamp((abs(fract(h + vec3(3.0, 2.0, 1.0) / 3.0) * 6.0 - 3.0) - 1.0)\n                    , 0.0, 1.0), s) * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = (fragCoord/iResolution.xy * 2. - 1.)\n            * vec2(aspect, 1.);\n\n    vec2 mouse = (iMouse.xy / iResolution.xy * 2. - 1.) * vec2(aspect, 1);\n    if (distance(mouse, uv) < 0.4) {\n        uv *= 0.5 + dot(uv * .3, uv * .3);\n    }\n\n    vec3 rd = normalize(vec3(uv, -1.8));\n    vec3 ro = vec3(0., 0., 7.);\n\n    vec3 rot = vec3(1.4, 0.2, 0.1);\n    rot = vec3(0.5 + time * 0.2, 0.3 + time * 0.2, 0.2);\n    ro = rotate(ro, rot);\n    rd = rotate(rd, rot);\n\n    float s = fract(abs(sin(time * 0.1))) * 8. + 2.;\n    s = 10.;\n    ro *= s;\n\n    vec3 grid = floor(ro);\n    vec3 grid_step = sign(rd);\n    vec3 delta = (-fract(ro) + 0.5 * (grid_step + 1.0)) / rd;\n    vec3 delta_step = 1.0 / abs(rd);\n    vec3 mask = vec3(.0);\n\n    float dist = EPS.y;\n    bool hit = false;\n    vec3 pos = vec3(EPS.y);\n    for (int i = 0; i < 160; ++i) {\n        pos = (grid + 0.5) / s;\n        if (map(pos) < 0.0) {\n            hit = true;\n            break;\n        }\n        vec3 c = step(delta, delta.yzx);\n        mask = c * (1.0 - c.zxy);\n        grid += grid_step * mask;\n        delta += delta_step * mask;\n    }\n    vec3 col = vec3(0.3 + 0.15 * uv.x);\n    if (hit) {\n        vec3 normal = norm(pos);\n        normal = erot(normal, normalize(vec3(-1, 1, 0)), .96);\n        float light = dot(max(normal, 0.), vec3(.4));\n\n        vec3 p = pos;\n        col = hsv(0.5 * length(pos), 0.5, 0.9);\n        col += vec3(light) * 0.2;\n\n        float br = dot(vec3(0.5, 0.9, 0.7), mask);\n\n        float depth = dot(delta - delta_step, mask);\n        float fog = min(1.0, 2000.0 / depth / depth);\n\n        vec3 uvw = fract(ro + rd * depth);\n        vec2 uu = vec2(dot(uvw.yzx, mask), dot(uvw.zxy, mask));\n        uu = abs(uu - vec2(0.5));\n        float gr = 1.0 - 0.1 * smoothstep(0.4, 0.5, max(uu.x, uu.y));\n\n        col *= br * fog * gr;\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}