{"ver":"0.1","info":{"id":"3sdfWf","date":"1606155255","viewed":127,"name":"Raymarching soft shadow sampling","username":"me_123","description":"the shadows have a random offset for every pixel.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\t\n*/\nfloat lightSample = 10.;\nfloat lightSize = 2.;\n\nfloat max_steps = 100.;\nfloat max_dist = 300.;\nfloat e = 0.00001;\nvec3 lightPos = vec3(sin(0.0)*10.,1, cos(1.0)*10.);\nvec3 rep( in vec3 p, in float c, in vec3 l)\n{\n    vec3 q = p-c*clamp(round(p/c),-l,l);\n    return q;\n}\n\nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nmat2 rot(float a) {\n\tfloat s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\nfloat sphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat hash(vec2 p) {\n    p = 50.*fract(p*0.3183099);\n    return fract(p.x*p.y*(p.x+p.y));\n}\nfloat SDF(vec3 p) {\n    vec3 np = p;\n   \tnp = rep(np, 5., vec3(2, 0, 2));\n\tfloat sp = smax(-sphere(np, 0.8), box(np, vec3(0.8)), 0.4);\n    //float sp = sphere(p, 1.0);\n    return smin(sp, p.y+0.8, 0.2);\n}\nfloat getDist(vec3 ro, vec3 rd) {\n    float d0 = 0.001;\n    vec3 roo = ro;\n    vec3 rdd = rd;\n    float steps = 0.0; \n    vec3 c = vec3(0);\n    for (float i = 0.0; i < max_steps; i += 1.0) {\n        steps += 1.0;\n        vec3 p = roo + rdd*d0;\n        float ds = SDF(p);\n        d0 += ds;\n        if (ds<e||ds>max_dist) {\n            break;\n        };\n       \tc = p;\n    }\n    \n    return d0;\n}\nvec2 getL(vec3 ro, vec3 rd) {\n    float d0 = 0.001;\n    vec3 roo = ro;\n    vec3 rdd = rd;\n    float steps = 0.0; \n    vec3 c = vec3(0);\n    for (float i = 0.0; i < 25.; i += 1.0) {\n        steps += 1.0;\n        vec3 p = roo + rdd*d0;\n        float ds = length(p-lightPos)-0.5;\n        d0 += ds;\n        if (ds<e||ds>max_dist) {\n            break;\n        };\n       \tc = p;\n    }\n    \n    return vec2(1000.0, d0);\n}\nvec3 getNormal(vec3 p) {\n    float d = SDF(p);\n    vec2 e = vec2(.01, 0);\n    vec3 n = d-vec3(\n    \tSDF(p-e.xyy),\n    \tSDF(p-e.yxy),\n    \tSDF(p-e.yyx)\n    );\n    return normalize(n);\n}\nvec3 tex(vec3 p) {\n    vec3 t = vec3((mod(floor(p*4.), 2.)));\n    t = vec3(t.x+t.z, t.x, t.y);\n    t = vec3(1.0);\n    return clamp(t, 0.0, 1.0);\n}\nvec3 getLight(vec3 p, vec3 lightPos, vec3 rd, vec3 ro, float dist) {\n    vec3 lp = normalize(lightPos-p);\n    vec3 norm = getNormal(p);\n    float l = length(p-lightPos)-1.0;\n    vec2 li = getL(ro, rd);\n    float dif = dot(norm, lp)/clamp(l/1., 1., 100.0)*6.;\n    float reflected = clamp(float((dot(reflect(rd, norm), lightPos)) - 8.0), 0.0, 1.0);\n    dif = (dif+(reflected/(l/2.)));\n    for (float i = 0.; i < lightSample; i += 1.) {\n    \tfloat d = getDist(p+(norm*e), lp+vec3(\n            hash(p.yz*(i+1.))/lightSize,\n            hash(p.yz*(i+100.))/lightSize,\n            hash(p.yz*(i+1000.))/lightSize\n        ));\n        if (d < length((lightPos)-p)) {\n            dif *= 1.-(2./lightSample);\n        }\n    }\n    if (li.y < dist && dist < max_dist) {\n\t    dif = (clamp(li.x, 0.0, 100.0)/100.);\n    }\n    return tex(p)*vec3(clamp(dif, 0.0, 1.0));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    lightPos = vec3(sin(iTime)*10.,5, cos(iTime)*10.);\n    \n    vec2 mouse = ((iMouse.xy-.5*iResolution.xy)/iResolution.xy)*5.;\n    mouse.x *= iResolution.x/iResolution.y;\n    vec2 uv = ((fragCoord-.5*iResolution.xy)/iResolution.xy);\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 ro = vec3(sin(iTime)*10., 10., cos(iTime)*10.);\n    vec3 at = vec3(0, 0, 0);\n    vec3 c_z = normalize(at-ro);\n    vec3 c_x = normalize(cross(vec3(0,1,0), c_z));\n    vec3 c_y = cross(c_z, c_x);\n    vec3 rd = normalize(uv.x * c_x + uv.y * c_y + 1.73 * c_z);\n    float dist = getDist(ro, rd);\n    vec3 fog = vec3(-0.4, -0.4, -0.4);\n    vec3 col = fog;\n    vec3 p = ro+rd*dist;\n    vec3 light = getLight(p, lightPos, rd, ro, dist);\n    col = (light*0.95)+0.05;\n    //col += (fog)*(dist/1000.);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}