{"ver":"0.1","info":{"id":"WsVyWD","date":"1602868675","viewed":66,"name":"UPBP 0.1 - Scene","username":"rory618","description":"https://cs.dartmouth.edu/~wjarosz/publications/krivanek14upbp.html","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","lighttransport"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 O, in vec2 I )\n{\n    vec2 uv = (I*2.-iResolution.xy)/iResolution.y/1.8;\n    vec3 r0 = vec3(17,1,8);\n    vec3 forward = normalize(vec3(3,17,3)-r0);\n    vec3 right = normalize(cross(forward,vec3(0,0,1)));\n    vec3 up = cross(right,forward);\n    vec3 rd = normalize(forward + right*uv.x + up*uv.y);\n    surface_intersection i = ray_scene(r0, rd);\n    O = (i.type==1)?vec4(1):vec4(i.normal*.5+.5,1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"struct surface_intersection {\n    vec3 coord;\n    vec3 normal;\n    float d;\n    int type;\n};\n\nstruct AABB {\n    vec3 a;\n    vec3 b;\n};\n    \nAABB[] walls = AABB[] (\n\tAABB(vec3(0,0,0),vec3(20,20,12)),\n\tAABB(vec3(0,3,0),vec3(3,20,12)),\n\tAABB(vec3(17,3,0),vec3(20,20,12)),\n\tAABB(vec3(8,10,0),vec3(10,12,12)),\n\tAABB(vec3(3,19,0),vec3(6,20,12)),\n\tAABB(vec3(9,19,0),vec3(11,20,12)),\n\tAABB(vec3(14,19,0),vec3(17,20,12)),\n\tAABB(vec3(6,19.4,0),vec3(9,20,3)),\n\tAABB(vec3(6,19.4,9),vec3(9,20,12)),\n\tAABB(vec3(11,19.4,0),vec3(14,20,3)),\n\tAABB(vec3(11,19.4,9),vec3(14,20,12))\n);\n\nAABB[] lights = AABB[] (\n\tAABB(vec3(6,19.9,3),vec3(9,20,9)),\n\tAABB(vec3(11,19.9,3),vec3(14,20,9))\n);\n    \nbool inAABB(AABB box, vec3 p){\n    return (p.x>box.a.x && p.y>box.a.y && p.z>box.a.z && \n            p.x<box.b.x && p.y<box.b.y && p.z<box.b.z);\n}\n\nsurface_intersection ray_AABB(vec3 r0, vec3 rd, AABB box){\n    \n    vec3 tMin = (box.a - r0) / rd;\n    vec3 tMax = (box.b - r0) / rd;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    \n    vec3 nNear = vec3(equal(t1,vec3(tNear)));\n    vec3 nFar = vec3(equal(t2,vec3(tFar)));\n    \n    \n    if(inAABB(box,r0)){\n    \treturn surface_intersection(r0 + rd*length(rd*tFar), -nFar*sign(rd),length(rd*tFar),0);\n    } else{\n    \tif(tNear>tFar || tNear < 1e-8){\n        return surface_intersection(r0,vec3(0),1e8,0);\n    \t} else{\n            return surface_intersection(r0 + rd*length(rd*tNear),-nNear*sign(rd),length(rd*tNear),0);\n        }\n    }\n}\n\nsurface_intersection ray_scene(vec3 r0, vec3 rd){\n    surface_intersection intersect_final = ray_AABB(r0,rd,walls[0]);\n    for(int i = 1; i < walls.length(); i++){\n        surface_intersection intersect = ray_AABB(r0,rd,walls[i]);\n        if(intersect.d<intersect_final.d){\n            intersect_final = intersect;\n        }\n    }\n    for(int i = 0; i < lights.length(); i++){\n        surface_intersection intersect = ray_AABB(r0,rd,lights[i]);\n        if(intersect.d<intersect_final.d){\n            intersect_final = intersect;\n            intersect_final.type = 1;\n        }\n    }\n    return intersect_final;\n}","name":"Common","description":"","type":"common"}]}