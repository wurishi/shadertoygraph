{"ver":"0.1","info":{"id":"4t3czN","date":"1531710465","viewed":437,"name":"Point In Triangle Test","username":"Wunkolo","description":"\"Point In Triangle\" tests using several methods.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["math","rasterization"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float Pi = 3.1415926535897932384626433832795;\n\n// Barycentric Method\nbool PointInTriangleBarycentric(\n    in vec2 Triangle[3],\n    in vec2 Point\n)\n{\n    mat3 Barycentric = inverse(\n        mat3(\n    \t\tTriangle[0], 1.0f,\n        \tTriangle[1], 1.0f,\n        \tTriangle[2], 1.0f\n    \t)\n    );\n\n    vec3 Weights = Barycentric * vec3( Point, 1.0f);\n\n    if(\n        // Weights.x >= 0.0f &&\n        // Weights.y >= 0.0f &&\n        // Weights.z >= 0.0f\n        all( greaterThanEqual( Weights, vec3(0.0f) ) )\n    )\n    {\n        return true;\n    }\n    \n    return false;\n}\n\n// Paremetric Method\nbool PointInTriangleParametric(\n    in vec2 Triangle[3],\n    in vec2 Point\n)\n{\n\tvec2 V0 = Triangle[2] - Triangle[0]; // Vert 0 to Vert 2\n\tvec2 V1 = Triangle[1] - Triangle[0]; // Vert 0 to Vert 1\n\tvec2 V2 = Point       - Triangle[0]; // Vert 0 to Point\n\n\tfloat Dot00 = dot(V0, V0);\n\tfloat Dot01 = dot(V0, V1);\n\tfloat Dot11 = dot(V1, V1);\n    float Dot02 = dot(V0, V2);\n\tfloat Dot12 = dot(V1, V2);\n\n\tfloat Area = (Dot00 * Dot11 - Dot01 * Dot01);\n\tfloat U = (Dot11 * Dot02 - Dot01 * Dot12);\n\tfloat V = (Dot00 * Dot12 - Dot01 * Dot02);\n\n\t// Convert to local plane's Barycentric coordiante system\n\treturn\n\t\t(U >= 0.0f) &&\n\t\t(V >= 0.0f) &&\n\t\t(U + V < Area);\n}\n\n// Cross Product Method\nbool PointInTriangleCross(\n    in vec2 Triangle[3],\n    in vec2 Point\n)\n{\n    vec2 EdgeDir[3] = vec2[](\n    \tTriangle[1] - Triangle[0],\n        Triangle[2] - Triangle[1],\n        Triangle[0] - Triangle[2]\n\t);\n    \n    vec2 PointDir[3] = vec2[](\n    \tPoint - Triangle[0],\n        Point - Triangle[1],\n        Point - Triangle[2]\n\t);\n\n    vec3 Crosses = vec3(\n    \tcross( vec3( EdgeDir[0], 0.0f ), vec3( PointDir[0], 0.0f ) ).z,\n        cross( vec3( EdgeDir[1], 0.0f ), vec3( PointDir[1], 0.0f ) ).z,\n        cross( vec3( EdgeDir[2], 0.0f ), vec3( PointDir[2], 0.0f ) ).z\n\t);\n\n    if(\n        // Area1 >= 0.0f &&\n        // Area1 >= 0.0f &&\n        // Area2 >= 0.0f\n        all( greaterThanEqual( Crosses, vec3(0.0f) ) )\n    )\n    {\n        return true;\n    }\n\n    return false;\n}\n\n// Cross Product Method (Optimized)\nbool PointInTriangleCrossOpt(\n    in vec2 Triangle[3],\n    in vec2 Point\n)\n{\n    vec2 EdgeDir[3] = vec2[](\n    \tTriangle[1] - Triangle[0],\n        Triangle[2] - Triangle[1],\n        Triangle[0] - Triangle[2]\n\t);\n    \n    vec2 PointDir[3] = vec2[](\n    \tPoint - Triangle[0],\n        Point - Triangle[1],\n        Point - Triangle[2]\n\t);\n    \n    vec3 Crosses = vec3(\n        // EdgeDir[0].x * PointDir[0].y - EdgeDir[0].y * PointDir[0].x,\n        // EdgeDir[1].x * PointDir[1].y - EdgeDir[1].y * PointDir[1].x,\n        // EdgeDir[2].x * PointDir[2].y - EdgeDir[2].y * PointDir[2].x,\n        // GLSL declares matrices by columns\n        // The determinant of a square matrix is the same as the determinant of its transpose.\n        // So this works too!\n        determinant( mat2( EdgeDir[0], PointDir[0] ) ),\n\t\tdeterminant( mat2( EdgeDir[1], PointDir[1] ) ),\n\t\tdeterminant( mat2( EdgeDir[2], PointDir[2] ) )\n    );\n    \n    if(\n        // Area0 >= 0.0f &&\n        // Area1 >= 0.0f &&\n        // Area2 >= 0.0f\n        all( greaterThanEqual( Crosses, vec3(0.0f) ) )\n    )\n    {\n        return true;\n    }\n    \n    return false;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvec2 Rotate(in vec2 Point, float Angle)\n{\n\tfloat RotSine = sin(Angle);\n\tfloat RotCosine = cos(Angle);\n    \n\treturn mat2(\n        RotCosine, -RotSine,\n        RotSine  ,  RotCosine\n    ) * Point;\n}\n\nvoid mainImage( out vec4 FragColor, in vec2 FragCoord )\n{\n    vec2 UV = -1.0 + 2.0 * (FragCoord/iResolution.xy);\n    UV.x *= iResolution.x/iResolution.y;\n    \n    vec2 Tri[3] = vec2[](\n    \tvec2( -1.5f, -0.5f ),\n    \tvec2(  1.5f, -0.5f ),\n    \tvec2(  1.5f,  0.5f )\n\t);\n    \n    for( int i = 0; i < 3; ++i )\n    {\n        Tri[i] = Rotate( Tri[i], iTime * Pi * 1.0f/25.0f );\n    }\n    \n    const vec4 ColorLut = vec4( 1.0f, 0.5f, 0.25f, 0.0f );\n    vec3 CurColor = vec3( 0.25f );\n    switch( int(FragCoord) / (int(iResolution.x)/4) )\n    {\n        case 0:\n        {\n            CurColor = PointInTriangleBarycentric( Tri, UV ) ? ColorLut.rbr : CurColor;\n            break;\n        }\n        case 1:\n        {\n            CurColor = PointInTriangleParametric( Tri, UV ) ? ColorLut.rgr : CurColor;\n            break;\n        }\n        case 2:\n        {\n            CurColor = PointInTriangleCross( Tri, UV )       ? ColorLut.gra : CurColor;\n            break;\n        }\n        case 3:\n        {\n            CurColor = PointInTriangleCrossOpt( Tri, UV )    ? ColorLut.bgr : CurColor;\n            break;\n        }\n    }\n    \n    FragColor = vec4(\n        CurColor,\n        1.0\n    );\n}","name":"Image","description":"","type":"image"}]}