{"ver":"0.1","info":{"id":"XttXzM","date":"1478745462","viewed":176,"name":"Volumestone","username":"VoidChicken","description":"A stone that has transparent layers. Raycasting the ground. (Earlier: Pretty laggy on weak GPUs.)","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","volume","raymarch","raycast","ao","wood"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NORM(R) R=normalize(R);\n#define MAP(V) df = map(V);\n#define FPLANE(V) (V.x+V.y)\n#define LOP(X) for (int unsd = 0; unsd < X; ++unsd)\n#define TRACE(R,O) t=trace(R, O); v = ro+rd*t;\n#define FLR FPLANE(vec2(v.y,2.))\nvec2 uvx (vec3 p) {\n\tfloat x = p.x;\n    float y = p.y;\n    float z = p.z;\n    float u = atan(x, z) / (2. * 3.14159265358979) + .5;\n    float v = asin(y) / (3.14159265358979) + .5;\n    return vec2(u,v);\n}\nmat3 rmx(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c        \n                );\n}\n\nfloat map ( vec3 v ) {\n    float stn = length(v-vec3(0,1,0))-(2.+length(atan(v*sin(v))));\n    \n    return stn;\n}\nfloat map2 ( vec3 v ) {\n\treturn min(map(v),FLR);    \n}\nfloat trace( vec3 ro, vec3 rd ) {\n    \n\tfloat t = 0.;\n    LOP (32) {\n        float df;\n        MAP( (ro + t * rd))\n        if ( t > 30. ) break;\n        t += df * .8;\n    }\n    return t;\n}\nvec3 normal( in vec3 x )\n{\n    vec2 e = vec2( .01, 0.0 );\n    return normalize( vec3( map2(x+e.xyy) - map2(x-e.xyy),\n                            map2(x+e.yxy) - map2(x-e.yxy),\n                            map2(x+e.yyx) - map2(x-e.yyx) ) );\n}\n\nvec3 denstex ( vec3 v , vec3 rd ) {\n    vec3 u = v;\n    mat3 rot = rmx(vec3(0,1,0), iTime/2.5);\n    u*=rot;\n    vec3 col = vec3(0);\n    for (int i = 0; i < 5; ++i ) {\n     \n        float trans = texture(iChannel2, uvx(u*vec3(1,.1,1))*float(i)+float(i)*2.31).r;\n        u+=rd*rot/4.1252;\n        col=mix(col, vec3(.4, .8, .5)*trans, trans);\n    }\n    return col;\n}\nvoid render  ( vec2 s, out vec4 c ) {\n\tvec3 col = vec3(1);\n    vec3 ro = vec3 ( 0, 6.-(1.-iMouse.y/iResolution.y)*7., -8. );\n    ro*=rmx(vec3(0,1,0),iTime/6.+iMouse.x/iResolution.x*3.-1.5) ;\n    vec3 rd = vec3 ( s*2.-1., .8);\n    \n    rd.x*=iResolution.x/iResolution.y;\n    NORM(rd);\n    rd*=rmx(vec3(1, 0, 0),3.14/6.);\n    rd*=rmx(vec3(0,1,0),iTime/6.+iMouse.x/iResolution.x*3.-1.5) ;\n    float t = 0.;\n    vec3 v;\n    \n    \n    TRACE( ro, rd );\n    \n    bool ht = map(v)<.5;\n    bool fl;// = map(v)==FLR;\n    vec3 nrm = normal(v);\n    vec3 dor = vec3(1);\n    float ptd = 100.;\n    \n    //Plane intersect\n    vec3 plt;\n    if (rd.y<0.) {\n\n        ptd = ((ro.y+2.)/(-rd.y));\n        plt = ro+rd*ptd;\n     \n      //  col=plt.xzx;\n        dor = texture(iChannel0, plt.xz/10.).rgb;\n    }  \n    if (ht) {\n        col = denstex(v,rd);\n        float ao = pow(abs(map2(v)-map2(v+nrm)), .9);\n        col*=clamp((1.-dot(nrm,v-vec3(0, 5, 0)))/distance(v,vec3(0,5,0)), .5, 1.); \n        col=mix(col, vec3(1), t/30.);\n        col*=min(1.,ao);\n    }\n    if (ptd<t||t>30.) {\n   \t\tcol = dor;\n        float ao = pow(abs(map2(v)-map2(v+nrm)),.9);\n          col*=clamp((1.-dot(normal(plt),plt-vec3(0, 5, 0)))/distance(plt,vec3(0,5,0)), 0., 1.); \n        TRACE(plt, normalize(vec3(0,8,0)-plt));\n        if (t<=30.)\n            col *= t/30.;\n        col=mix(col, vec3(1), min(ptd,50.)/50.);\n        col*=min(1.,ao);\n      \t\n    }\n    \n   \n    col*=pow(1.-length(s-.5), 1./4.);\n    col*=min(iTime,1.);\n    c=col.xyzz;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\trender(uv, fragColor);\n}","name":"Image","description":"","type":"image"}]}