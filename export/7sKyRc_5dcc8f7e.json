{"ver":"0.1","info":{"id":"7sKyRc","date":"1665670661","viewed":67,"name":"Bicubic JD","username":"jdmichaud","description":"description","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["tag"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float T_DIV_2 = 3. / 2.;\nconst float F_DIV_2 = 5. / 2.;\n\nfloat getVoxel(sampler2D channel, vec2 voxel, vec2 resolution) {\n  vec2 squareSize = resolution / 8.0;\n  return texture(channel, (squareSize * (voxel - .5)) / resolution).r;\n}\n\nfloat cubic(float p0, float p1, float p2, float p3, float x) {\n  float x2 = x * x;\n  float x3 = x * x * x;\n  float a = -.5 * p0 + T_DIV_2 * p1 - T_DIV_2 * p2 + .5 * p3;\n  float b =       p0 - F_DIV_2 * p1 +     2.  * p2 - .5 * p3;\n  float c = -.5 * p0 +              +      .5 * p2          ;\n  float d =                      p1                         ;\n  \n  return a * x3 + b * x2 + c * x + d;\n}\n\nfloat bicubic(sampler2D channel, vec2 voxel, vec2 resolution) {\n  float x0 = (floor(voxel.x) - 1.);\n  float y0 = (floor(voxel.y) - 1.);\n  float x1 =  floor(voxel.x)      ;\n  float y1 =  floor(voxel.y)      ;\n  float x2 =   ceil(voxel.x)      ;\n  float y2 =   ceil(voxel.y)      ;\n  float x3 = ( ceil(voxel.x) + 1.);\n  float y3 = ( ceil(voxel.y) + 1.);\n  float fractx = fract(voxel.x);\n  float fracty = fract(voxel.y);\n\n  float p00 = getVoxel(channel, vec2(x0, y0), resolution);\n  float p10 = getVoxel(channel, vec2(x1, y0), resolution);\n  float p20 = getVoxel(channel, vec2(x2, y0), resolution);\n  float p30 = getVoxel(channel, vec2(x3, y0), resolution);\n  float p0 = cubic(p00, p10, p20, p30, fractx);\n\n  float p01 = getVoxel(channel, vec2(x0, y1), resolution);\n  float p11 = getVoxel(channel, vec2(x1, y1), resolution);\n  float p21 = getVoxel(channel, vec2(x2, y1), resolution);\n  float p31 = getVoxel(channel, vec2(x3, y1), resolution);\n  float p1 = cubic(p01, p11, p21, p31, fractx);\n\n  float p02 = getVoxel(channel, vec2(x0, y2), resolution);\n  float p12 = getVoxel(channel, vec2(x1, y2), resolution);\n  float p22 = getVoxel(channel, vec2(x2, y2), resolution);\n  float p32 = getVoxel(channel, vec2(x3, y2), resolution);\n  float p2 = cubic(p02, p12, p22, p32, fractx);\n\n  float p03 = getVoxel(channel, vec2(x0, y3), resolution);\n  float p13 = getVoxel(channel, vec2(x1, y3), resolution);\n  float p23 = getVoxel(channel, vec2(x2, y3), resolution);\n  float p33 = getVoxel(channel, vec2(x3, y3), resolution);\n  float p3 = cubic(p03, p13, p23, p33, fractx);\n\n  //return getVoxel(channel, voxel, resolution);\n  return cubic(p0, p1, p2, p3, fracty);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    // Compute voxel coordinate (0, 0) being the center of the first square\n    vec2 squareSize = iResolution.xy / 8.0;\n    vec2 voxel = fragCoord.xy / squareSize.xy + .5;\n\n    fragColor = vec4(vec3(bicubic(iChannel0, voxel, iResolution.xy)), 1.0);\n}","name":"Image","description":"","type":"image"}]}