{"ver":"0.1","info":{"id":"4f3GDl","date":"1712774400","viewed":57,"name":"shader2_fsr","username":"renderlast","description":"praktikum 2)","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["renderlast"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdSphere( vec3 p, float s){\n    return length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 b){\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nmat2 rot2D(float angle){\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nvec4 map(vec3 p){\n    vec3 sphere1Pos = vec3(sin(iTime)*3., 0, 0);\n    vec4 sphere1 = vec4(50.*sphere1Pos.x, 0, 50, sdSphere(p - sphere1Pos, 0.5));\n    \n    vec3 sphere2Pos = vec3(0.0 + 1. * sin(iTime), 0.0 + 1. * cos(iTime), 0);\n    vec4 sphere2 = vec4(30, 0, 30, sdSphere(p - sphere2Pos, 0.5));\n    \n    vec3 sphere3Pos = vec3(0.0 + 2. * sin(iTime), 0, 0.0 + 2. * cos(iTime));\n    vec4 sphere3 = vec4(100, 50, 50, sdSphere(p - sphere3Pos, 0.3));\n    \n    vec3 sphere4Pos = vec3(0, 0, sin(iTime)*3.);\n    vec4 sphere4 = vec4(30, 30, 30, sdSphere(p - sphere4Pos, 0.5));\n    \n    vec3 q = p;\n    \n    q.xy *= rot2D(iTime);\n    \n    vec4 box = vec4(50, 0, 0, sdBox(q, vec3(.70)));\n    \n    vec4 ground = vec4(100, 100, 100, p.y + .75);\n    \n    vec4 res = vec4(0, 0, 0, 0);\n    float dist = min(ground.w, min(min(min(sphere1.w, sphere2.w), min(sphere3.w, sphere4.w)), box.w));\n    if(ground.w == dist){\n        res = ground;\n    } else if(sphere1.w == dist){\n        res = sphere1;\n    } else if(sphere2.w == dist){\n        res = sphere2;\n    } else if(sphere3.w == dist){\n        res = sphere3;\n    } else if(sphere4.w == dist){\n        res = sphere4;\n    } else if(box.w == dist){\n        res = box;\n    }\n        \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2. - iResolution.xy) / iResolution.y;\n    vec2 m = (iMouse.xy * 2. - iResolution.xy) / iResolution.y;\n    \n    //инициализация\n    vec3 ro = vec3(0, 0, -3); //изначальное положение луча\n    vec3 rd = normalize(vec3(uv, 1)); //направление луча\n    vec3 col = vec3(0); //финальный цвет пикселей\n    \n    float t = 0.; //пройденное расстояние\n    \n    //вертикальное вращение камеры\n    ro.yz *= rot2D(-m.y);\n    rd.yz *= rot2D(-m.y);\n    \n    //горизонтальное вращение камеры\n    ro.xz *= rot2D(-m.x);\n    rd.xz *= rot2D(-m.x);\n    \n    //реймарчинг\n    int i, f=0;\n    for(i=0; i<80; i++){\n        vec3 p = ro + rd * t; //расположение на прямой\n    \n        vec4 v = map(p); //вектор луча\n        \n        t += v.w; //марш (marching) луча\n        \n        col = vec3(v.rgb) / 80.;\n        \n        if(v.w<.001 || t>100.) break;\n    }\n    \n    //расцветка\n    //col = vec3(t * .1); //цвет, взависимости от расстояния\n    \n    if(t<100.){\n        \n    }\n    \n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}