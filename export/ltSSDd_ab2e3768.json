{"ver":"0.1","info":{"id":"ltSSDd","date":"1447356453","viewed":835,"name":"Cylindrical objects","username":"TomF","description":"Let's not render these things with polygonal objects - it looks terrible! They're easy to raytrace, so just render a bounding box and do it right.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raytrace","cylinder","bullet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"\n\n// Equation of a general cone.\n// Radius at z=Z0 is R0\n// Radius at z=Z1 is R1\n// Therefore r = R0 + ((z-Z0)/(Z1-Z0))*(R1-R0)\n//             = sqrt(x^2+y^2)\n//\n// Simplify the first line a bit:\n// Zo = R0 - ((Z0)/(Z1-Z0))*(R1-R0)\n// Zs =          1/(Z1-Z0))*(R1-R0)\n// Therefore:\n//   r = Zo + z*Zs = sqrt(x^2+y^2)\n//\n// Line equation for the ray we're casting is (xyz) = p + d*v\n//\n// Substitute one in the other, solve for d:\n//\n// (p.x + d*v.x)^2+(p.y + d*v.y)^2\n//     = (Zo + (p.z+d*v.z)*Zs)^2\n//     = (Zo + p.z*Zs + d*v.z*Zs)^2\n//\n// Gather by powers of d:\n//\n// 0 =\n//     d^2 * (v.x^2+v.y^2 - (v.z*Zs)^2)\n//   + d   * 2*(p.x*v.x + p.y*v.y - v.z*Zs*(Zo + p.z*Zs))\n//   +       (p.x^2 + p.y^2 - (Zo + p.z*Zs)^2\n\nstruct Cone\n{\n    float Z0, Z1;\n    float R0, R1;\n    int Material;\n    float Zo, Zs;\n};\n\nvoid PrecomputeCone ( inout Cone cn )\n{\n    cn.Zs = (cn.R1-cn.R0)/(cn.Z1-cn.Z0);\n    cn.Zo = cn.R0 - (cn.Z0*cn.Zs);\n}\n\n// Returns both distances to cone given a ray origin p, direction v\nvec2 ConeDistances ( in Cone cone, in vec3 p, in vec3 v )\n{\n    // Convert to standard form A(d^2) + Bd + C = 0\n    float t0 = v.z * cone.Zs;\n    float t1 = cone.Zo + p.z*cone.Zs;\n    float A = (v.x*v.x + v.y*v.y - t0*t0);\n    float B = 2.0*(p.x*v.x + p.y*v.y - v.z*cone.Zs*t1);\n    float C = (p.x*p.x + p.y*p.y - t1*t1);\n\n\t// Then solve, paying attention to numerical stability as shown in\n\t// https://en.wikipedia.org/wiki/Loss_of_significance#A_better_algorithm\n\t// x1 = (-B-sgn(B)*sqrt(B^2-4AC))/2A\n    // x2 = C/(Ax1)\n    float discriminant = B*B-4.0*A*C;\n\tif ( discriminant < 0.0 )\n    {\n        return vec2(-1.0,-1.0);\n    }\n\tfloat d1 = (-B-sign(B)*sqrt(discriminant))/(2.0*A);\n    float d2 = C/(A*d1);\n    vec2 res = vec2(d1, d2);\n\treturn res;\n}\n\nconst int NumCones = 13;\n\nCone cones[NumCones];\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Yes, I am nerdy enough to have made sure these dimensions are correct!\n    // Thanks Wikipedia! https://upload.wikimedia.org/wikipedia/commons/4/41/9x19mm_Parabellum.svg\n    float q = -12.0;\n    cones[ 0] = Cone(q+ 0.00,0.0, 0.00*0.5,0.0, 0, 0.0,0.0);\n    cones[ 1] = Cone(q+ 0.00,0.0, 9.36*0.5,0.0, 0, 0.0,0.0);\n    cones[ 2] = Cone(q+ 0.30,0.0, 9.96*0.5,0.0, 0, 0.0,0.0);\n    cones[ 3] = Cone(q+ 1.27,0.0, 9.96*0.5,0.0, 0, 0.0,0.0);\n    cones[ 4] = Cone(q+ 1.27,0.0, 8.79*0.5,0.0, 0, 0.0,0.0);\n    cones[ 5] = Cone(q+ 2.17,0.0, 8.79*0.5,0.0, 0, 0.0,0.0);\n    cones[ 6] = Cone(q+ 2.98,0.0, 9.93*0.5,0.0, 0, 0.0,0.0);\n    cones[ 7] = Cone(q+19.15,0.0, 9.65*0.5,0.0, 0, 0.0,0.0);\n    cones[ 8] = Cone(q+19.15,0.0, 9.03*0.5,0.0, 1, 0.0,0.0);\n    cones[ 9] = Cone(q+21.50,0.0, 8.80*0.5,0.0, 1, 0.0,0.0);\n    cones[10] = Cone(q+25.00,0.0, 7.40*0.5,0.0, 1, 0.0,0.0);\n    cones[11] = Cone(q+28.00,0.0, 4.50*0.5,0.0, 1, 0.0,0.0);\n    cones[12] = Cone(q+29.40,q+29.69, 2.00*0.5,0.0, 1, 0.0,0.0);\n\t\n\tfor ( int cn = 0; cn < NumCones; cn++ )\n\t{\n        if ( cn < NumCones-1 )\n        {\n        \tcones[cn].Z1 = cones[cn+1].Z0;\n            cones[cn].R1 = cones[cn+1].R0;\n        }\n\t\tPrecomputeCone ( cones[cn] );\n\t}\n\t\n\tvec3 pos;\n\tvec3 vec;\n    \n    \n    vec2 angles;\n    angles.x = 0.02 * iMouse.x + 0.5*iTime;\n    angles.y = 0.02 * iMouse.y;\n    \n    float viewdist = 40.0;\n    \n\tpos.x = viewdist*sin(angles.x) * cos(angles.y);\n\tpos.z = viewdist*cos(angles.x) * cos(angles.y);\n    pos.y = viewdist*                sin(angles.y);\n    \n\tvec3 lookat = vec3(0.0,0.0,0.0);\n\tvec3 viewz = normalize(lookat-pos);\n\tvec3 viewx = normalize(cross(vec3(0.0,1.0,0.0),viewz));\n\tvec3 viewy = normalize(cross(viewz,viewx));\n    \n    vec3 lightpos;\n\tlightpos.x = viewdist*sin(0.5*iTime);\n\tlightpos.z = viewdist*cos(0.5*iTime);\n\tlightpos.y = viewdist*2.0;\n    vec3 lightvec = normalize(lightpos);\n    \n\tfloat tanfov = 0.6;\n    \n    vec2 ndc = fragCoord.xy - 0.5*iResolution.xy;\n    ndc *= 2.0/iResolution.x;\n\tndc *= tanfov;\n\tvec3 dirn = normalize(viewz + viewx*ndc.x + viewy*ndc.y);\n    \n\tint closestCn = -1;\n    Cone closestCone;\n\tfloat closestDist = 1000000000.0;\n\tvec3 hitpos = vec3(0.0,0.0,10000000.0);\n    vec3 normal;\n\tfor ( int cn = 0; cn < NumCones; cn++ )\n\t{\n        if ( cones[cn].Z0 == cones[cn].Z1 )\n        {\n            // Flat disc section.\n            // Intersect view vector with plane at Z0\n            // Z0 = pos.z + dirn.z * dist;\n            // dist = (Z0-pos.z)/dirn.z;\n            float Z0 = cones[cn].Z0;\n            float dist = ( Z0 - pos.z ) / dirn.z;\n            if ( dist > 0.0 )\n            {\n                float R0 = cones[cn].R0;\n                float R1 = cones[cn].R1;\n                vec2 hit = pos.xy + dirn.xy * dist;\n                float radius2 = hit.x*hit.x + hit.y*hit.y;\n                if ( R0 > R1 )\n                {\n                    if ( ( radius2 < (R0*R0) ) && ( radius2 > (R1*R1) ) )\n                    {\n\t                    if ( closestDist > dist )\n    \t                {\n        \t                closestDist = dist;\n            \t            closestCn = cn;\n                \t        closestCone = cones[cn];\n                    \t    hitpos = vec3 ( hit, Z0 );\n                        \tnormal = vec3 ( 0.0, 0.0, 1.0 );\n                    \t}\n                    }\n                }\n                else\n                {\n                    if ( ( radius2 < (R1*R1) ) && ( radius2 > (R0*R0) ) )\n                    {\n\t                    if ( closestDist > dist )\n    \t                {\n        \t                closestDist = dist;\n            \t            closestCn = cn;\n                \t        closestCone = cones[cn];\n                    \t    hitpos = vec3 ( hit, Z0 );\n                        \tnormal = vec3 ( 0.0, 0.0, 1.0 );\n                    \t}\n                    }\n                }\n            }\n        }\n        else\n        {\n            vec2 dist = ConeDistances ( cones[cn], pos, dirn );\n            float dists[2];\n            dists[0] = dist.x;\n            dists[1] = dist.y;\n            for ( int i = 0; i < 2; i++ )\n            {\n                vec3 hit = pos + dirn * dists[i];\n                if ( ( dists[i] > 0.0 ) && ( hit.z < cones[cn].Z1 ) && ( hit.z > cones[cn].Z0 ) )\n                {\n                    if ( closestDist > dists[i] )\n                    {\n                        closestDist = dists[i];\n                        closestCn = cn;\n                        closestCone = cones[cn];\n                        hitpos = hit;\n                        normal.xy = normalize(hitpos.xy);\n                        normal.z = -closestCone.Zs;\n                    }\n                }\n            }\n        }\n\t}\n\t\n\tif ( closestCn < 0 )\n\t{\n        vec2 uv = fragCoord.xy / iResolution.xx;\n\t\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\t}\n\telse\n\t{\n\t\tnormal = normalize(normal);\n\t\t\n        // wraparound diffuse\n\t\tfloat shade = dot(lightvec,normal);\n\t\tshade = shade * 0.5 + 0.5;\n        \n        vec3 col = vec3(1.0,1.0,1.0);\n        float specshade = 1.0;\n        if      ( closestCone.Material == 0 ) { col = vec3(1.0,1.0,0.5); specshade = 0.3; }\n        else if ( closestCone.Material == 1 ) { col = vec3(0.3,0.3,0.3); specshade = 0.4; }\n            \n        col *= shade;\n        //vec4 tex = texture ( iChannel0, vec2(hitpos.x, hitpos.z));\n        //col *= tex.xyz;\n\n        // Blinn-Phong specular\n        vec3 lightvec = normalize(lightpos-hitpos);\n        vec3 halfvec = normalize(lightvec-viewz);\n        float spec = dot(halfvec,normal);\n        if ( spec > 0.0 )\n        {\n\t        col += pow(spec,10.0) * specshade;\n        }\n\n\t\tfragColor = vec4(col, 1.0);\n\t}\n}\n\n\n\n\n\n\n\n","name":"","description":"","type":"image"}]}