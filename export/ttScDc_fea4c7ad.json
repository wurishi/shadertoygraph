{"ver":"0.1","info":{"id":"ttScDc","date":"1608716797","viewed":1737,"name":"AURORA","username":"alro","description":"Use mouse to look around.","likes":71,"published":1,"flags":32,"usePreview":0,"tags":["sky","stars","night","lights","aurora","snow","northern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ray marched northern lights over a field of snow before dawn.\n// Is there a fast LUT based 3D gradient noise approach?\n\n#define PI 3.14159\n#define TWO_PI 2.0*PI\n\n//Aurora\nconst float STEPS = 32.0;\nconst float auroraSpeed = 0.5;\nconst float strengthMultiplier = 0.015;\nconst vec3 baseColour = vec3(0.35, 1, 0.01);\nconst vec3 highColour = vec3(0.5, 0.0, 0.2);\n\nconst float auroraStart = 50.0;\nconst float aabbHeight = 75.0;\nconst vec3 minCorner = vec3(-250.0, auroraStart, -500.0);\nconst vec3 maxCorner = vec3(250.0, auroraStart + aabbHeight, 500.0);\n\n//Stars\nconst float flickerSpeed = 5.0;\n\n//Azimuth\nfloat sunLocation = 0.5;\n//0: horizon\nfloat sunHeight = -3.9;\n\nconst vec3 skyColour = vec3(0.45, 0.7, 1.0);\n//Mountains and distant snow\nconst vec3 distantColour = 0.04 * skyColour;\n\n//Offset the sample point by blue noise every frame to get rid of banding\n#define DITHERING\nconst float goldenRatio = 1.61803398875;\n\nvec3 rayDirection(float fieldOfView, vec2 fragCoord) {\n    vec2 xy = fragCoord - iResolution.xy / 2.0;\n    float z = (0.5 * iResolution.y) / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n//https://www.geertarien.com/blog/2017/07/30/breakdown-of-the-lookAt-function-in-OpenGL/\nmat3 lookAt(vec3 camera, vec3 targetDir, vec3 up){\n  vec3 zaxis = normalize(targetDir);    \n  vec3 xaxis = normalize(cross(zaxis, up));\n  vec3 yaxis = cross(xaxis, zaxis);\n\n  return mat3(xaxis, yaxis, -zaxis);\n}\n\nfloat getGlow(float dist, float radius, float intensity){\n    dist = max(dist, 1e-7);\n\treturn pow(radius/dist, intensity);\t\n}\n\n//---------------------------- 3D Perlin noise ----------------------------\n//Used to shape aurora\n//https://www.shadertoy.com/view/4sfGzS\n\nfloat noise( in vec3 x ){  \n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (i.xy+vec2(37.0,17.0)*i.z) + f.xy;\n\tvec2 rg = textureLod( iChannel2, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat fbm3D(vec3 pos, int limit){\n\n\tfloat sum = 0.0;\n\tfloat weightSum = 0.0;\n\tfloat weight = 1.0;\n    float frequency = 1.0;\n\tfor(int oct = 0; oct < 3; oct++){\n\n        vec3 p = pos * frequency;\n        float val = noise(p * frequency);\n        sum += (1.0-abs(val)) * weight;\n        weightSum += weight;\n\n        weight *= 0.5;\n        frequency *= 2.0;\n\t}\n\n    float noise = sum / weightSum;\n\tnoise = clamp(noise, 0.0, 1.0);\n\treturn noise;\n}\n\n//---------------------------- 1D Perlin noise ----------------------------\n//Used to shape aurora and mountains\n//https://www.shadertoy.com/view/lt3BWM\n\n#define HASHSCALE 0.1031\n\nfloat hash(float p){\n    vec3 p3  = fract(vec3(p) * HASHSCALE);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat fade(float t) { return t*t*t*(t*(6.*t-15.)+10.); }\n\nfloat grad(float hash, float p){\n    int i = int(1e4*hash);\n    return (i & 1) == 0 ? p : -p;\n}\n\nfloat perlinNoise1D(float p){\n    float pi = floor(p), pf = p - pi, w = fade(pf);\n    return mix(grad(hash(pi), pf), grad(hash(pi + 1.0), pf - 1.0), w) * 2.0;\n}\n\nfloat fbm(float pos, int octaves, float persistence){\n    float total = 0.0, frequency = 1.0, amplitude = 1.0, maxValue = 0.0;\n    for(int i = 0; i < octaves; ++i){\n        total += perlinNoise1D(pos * frequency) * amplitude;\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= 2.0;\n    }\n    return total / maxValue;\n}\n\n//https://gist.github.com/DomNomNom/46bb1ce47f68d255fd5d\n//Compute the near and far intersections using the slab method.\n//No intersection if tNear > tFar.\nvec2 intersectAABB(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {\n    vec3 tMin = (boxMin - rayOrigin) / rayDir;\n    vec3 tMax = (boxMax - rayOrigin) / rayDir;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    return vec2(tNear, tFar);\n}\n\nbool insideAABB(vec3 p){\n    float eps = 1e-4;\n\treturn  (p.x > minCorner.x-eps) && (p.y > minCorner.y-eps) && (p.z > minCorner.z-eps) && \n\t\t\t(p.x < maxCorner.x+eps) && (p.y < maxCorner.y+eps) && (p.z < maxCorner.z+eps);\n}\n\nbool getAABBIntersection(vec3 org, vec3 dir, out float distToStart, out float totalDistance){\n\tvec2 intersections = intersectAABB(org, dir, minCorner, maxCorner);\n\t\n    if(insideAABB(org)){\n        intersections.x = 1e-4;\n    }\n    \n    distToStart = intersections.x;\n    totalDistance = intersections.y - intersections.x;\n    return intersections.x > 0.0 && (intersections.x < intersections.y);\n}\n\n//-------------------------- Aurora --------------------------\n\nvec3 auroraColour(float h){\n    return mix(baseColour, highColour, h);\n}\n\nvec3 getAuroraPosition(vec3 position, float speed){\n    \n    //Normalised height of sample point in AABB\n    float h = (position.y-auroraStart)/aabbHeight;\n    //Stretch in the z direction and add movement in y and z directions\n    vec3 pos = 0.042*vec3(position.x, 2.0*speed, 0.225*position.z+speed*0.5);\n    //Large arc shape with higher points tilted\n    pos.x += 0.3*h + 5.5*cos(0.005*position.z);\n    //Smaller waves\n    pos.x += 0.02*perlinNoise1D(0.1*position.z+speed*2.0);\n\n    return pos;\n}\n\nfloat getAuroraDensity(vec3 position){\n\n    float speed = iTime * auroraSpeed;\n    vec3 pos = getAuroraPosition(position, speed);\n    float noise = fbm3D(pos, 3);\n  \n    vec3 p = vec3(noise, position.y-minCorner.y, noise);\n    \n    //Stretch in the y direction\n    vec3 a = p * vec3(1.0, 0.006, 1.0);\n    \n    //The nice glow behaviour occurs away from 0 so raise the sample point\n    a.y += 0.48;\n\n    //Add horizontally moving strength differences\n    a.y += 0.015*perlinNoise1D(1.0*speed + pos.z);\n    a.y += 0.015*perlinNoise1D(-2.0*speed + pos.z);\n    \n\tfloat density = getGlow(length(a), 0.7, 10.0);\n    \n    //Cut away parts of AABB not along the main arc shape\n    density *= cos(0.13*pos.x);\n    \n    return max(0.0, density);\n}\n\nvec3 getAuroraColour(vec3 org, vec3 dir, float offset){\n\n    vec3 colour = vec3(0);\n    float density = 0.0;\n    //The distance at which to start ray marching.\n    float distToStart = 0.0;\n    \n    //The length of the intersection.\n    float totalDistance = 0.0;\n\n    //Determine if ray intersects bounding volume.\n\t//Set ray parameters in the aurora aabb.\n\tbool renderAurora = getAABBIntersection(org, dir, distToStart, totalDistance);\n\n\tif(!renderAurora){\n\t\treturn colour;\n    }\n\n\t//Sampling step size.\n    float stepSize = totalDistance / float(STEPS); \n    \n    //Offset the starting point by blue noise.\n    distToStart += stepSize * offset;\n\n\t//Initialise sampling point.\n\tvec3 p = org + distToStart * dir;\n    float dist = distToStart;\n    vec3 col = vec3(0);\n    \n    for(float i = 0.0; i < STEPS; i++){\n    \tdensity = getAuroraDensity(p);\n        col += density * auroraColour((p.y-minCorner.y)/(maxCorner.y-minCorner.y));\n        dist += stepSize;\n\n\t\t//Step along ray.\n\t\tp = org + dir * dist;\n    }\n    \n\treturn strengthMultiplier * col * stepSize;\n}\n\n\n//-------------------------- Sky --------------------------\n\nvec3 rand33(vec3 p3){\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//Get star colour from view direction.\n//Technique from https://www.shadertoy.com/view/XtGGRt\nfloat getStars(vec3 rayDir){\n\n    float scale = 112.0;\n    vec3 id = floor(rayDir * scale);\n    float d = length(scale * rayDir - (id + 0.5));\n\n    float stars = 0.0;\n    //rand33 returns better random number for view directions across the 0-planes\n    vec3 rnd = rand33(id);\n    if(rnd.x > 0.92 && d < 0.15){\n        stars = getGlow(d, 0.075, 2.5 - 2.0 * sin(rnd.y * flickerSpeed * iTime));\n    }\n    return stars;\n}\n\nvec3 getSkyColour(vec3 rayDir){\n    \n    vec3 sunDirection = normalize(vec3(cos(sunLocation), sunHeight, sin(sunLocation)));\n    float halo = dot(rayDir, sunDirection);\n    float mu = 0.5+0.5*halo;\n    \n    //Reddish pre-dawn glow on the horizon\n    vec3 sunColour = vec3(1.0, 0.25, 0.01);\n    vec3 sun = 0.15 * sunColour * getGlow(max(1.0-mu, 0.1), 0.39, 10.0);\n    \n    //White-blue gradient around the sun\n    vec3 blue = mix(vec3(1), skyColour, smoothstep(1.0, -0.5, halo));\n    blue = mix(blue, vec3(0), smoothstep(1.0, -0.75, halo));\n    \n    //Flickering stars\n    vec3 stars = vec3(0);\n    stars = vec3(getStars(rayDir));\n    stars = mix(stars, blue, mu);\n    \n    //Two bright planets\n    vec3 planetDirection = -normalize(vec3(1,1,0));\n    float planet = 0.5+0.5*dot(rayDir, planetDirection);\n    stars += 0.1*getGlow(planet, 5e-6, 0.95);\n    \n    planetDirection = -normalize(vec3(0.3, 0.25, 1.0));\n    planet = 0.5+0.5*dot(rayDir, planetDirection);\n    stars += 0.1*getGlow(planet, 5e-6, 0.95);\n    \n    //Mix the sun, haze and stars with a red-blue gradient around the horizon\n    return mix(0.5*stars, sun, mu) \n        + 0.04*mix(vec3(1.0,0.5,0.3), 0.5*skyColour, smoothstep(0.4, 0.57, 0.5+0.5*rayDir.y));\n}\n\n//----------------------- Ground shading ----------------------\n\n//Lighting for snow. Constant blue light from directly above and light from the aurora\nvec3 shading(vec3 org, vec3 position, vec3 normal, vec3 rayDir){\n    \n    vec3 auroraColour = 0.75*baseColour;\n    vec3 specularColour = vec3(1);\n    \n    float ambientStrength = 0.1;\n    \n    float specularStrength = 0.005;\n    float shininess = 1.0;\n    \n    vec3 ambientColour = vec3(0.1);\n    vec3 diffuseColour = vec3(1.15);\n\n    //Light comes from a thin line along the main arc\n    vec3 lightPos = vec3(-120.0*cos(0.005*position.z), auroraStart, position.z);\n    vec3 lightDirection = normalize(lightPos-position);\n\n    if(length(lightPos - org) > 1500.0){\n        auroraColour = vec3(0);\n    }\n    \n\tvec3 halfwayDir = normalize(lightDirection - rayDir);  \n\tfloat spec = pow(max(dot(normal, halfwayDir), 0.0), shininess);\n\n\t//Colour of light sharply reflected into the camera\n\tvec3 specular = spec * specularColour * auroraColour;\n    \n\t//How much a fragment faces the aurora\n\tfloat aurora = max(dot(normal, lightDirection), 0.0);\n    vec3 auroraLight = aurora * auroraColour;\n    \n    //How much the fragment faces up\n    float sky = max(dot(normal, vec3(0,1,0)), 0.0);\n    //Sky light. A blue light from directly above.\n\tvec3 skyLight = sky * skyColour;\n    \n\tvec3 result = vec3(0.0); \n    \n    //Combine light\n    result += 0.03 * auroraLight;\n    result += 0.035 * skyLight;\n    \n    //Light and material interaction\n    result *= diffuseColour;\n    result += ambientStrength * ambientColour + specularStrength * specular;\n    \n    float fade = clamp(length(position-org)/900.0, 0.0, 1.0);\n\n    return  mix(result, distantColour, smoothstep(0.35, 1.0, fade));\n}\n\nfloat getHeight(vec3 p){\n    //Two layers for driven snow look with surface detail\n    return 2.5 * texture(iChannel3, 0.004*p.xz).r\n         + 0.002 * texture(iChannel2, 0.25*p.xz).r;\n}\n\nvec3 getNormal(vec3 p, float t){\n    float eps = 0.001 * t;\n    return normalize(vec3( \n            getHeight(vec3(p.x-eps, p.y, p.z)) \n            - getHeight(vec3(p.x+eps, p.y, p.z)),\n\n            2.0*eps,\n\n            getHeight(vec3(p.x, p.y, p.z-eps)) \n            - getHeight(vec3(p.x, p.y, p.z+eps)) \n        ));\n}\n\n//From Scratchpixel\n//Assume normalised vectors.\nbool getPlaneIntersection(vec3 org, vec3 ray, vec3 planePoint, vec3 normal, out float t){\n    float denom = dot(normal, ray); \n    if (denom > 1e-6) { \n        vec3 p0l0 = planePoint - org; \n        t = dot(p0l0, normal) / denom; \n        return (t >= 0.0); \n    } \n \n    return false; \n}\n\nvec3 getGround(vec3 org, vec3 rayDir, float t){\n    vec3 p = org + t * rayDir;\n    vec3 normal = getNormal(p, t);\n    return shading(org, p, normal, rayDir);\n}\n\nvec3 getMountains(vec3 rayDir, vec3 sky){\n\n    //Angle around the horizon\n    float phi = atan(rayDir.x, rayDir.z);\n\n    //Sine wave mountains\n    float offset = -0.06*(0.5+0.5*sin(6.0*phi));\n\n    //Add fbm detail\n    float detail = 0.045*fbm(phi, 6, 0.55);\n\n    //Remove detail around the -PI -> PI transition to avoid a jump\n    float limit = PI*0.99;\n    float span = PI - limit;\n    if(phi > limit || phi < -limit){\n        detail *= -(sign(phi)*phi - PI)/span;\n    }\n    \n    //Shift down\n    detail += 0.005;\n    \n    //Apply detail\n    offset += detail;\n    \n    //Smooth edge transition to sky colour\n    return mix(distantColour, sky, smoothstep(0.0, 0.003, rayDir.y+offset));\n}\n\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x){\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    //Get the default direction of the ray (along the negative Z direction)\n    vec3 rayDir = rayDirection(60.0, fragCoord);\n   \n    //----------------- Define a camera -----------------\n    \n    vec3 cameraPos = vec3(0,10,0);\n\t\n    vec3 targetDir = texelFetch(iChannel0, ivec2(0.5, 1.5), 0).xyz;\n    \n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    //Get the view matrix from the camera orientation\n    mat3 viewMatrix = lookAt(cameraPos, targetDir, up);\n    \n    //Transform the ray to point in the correct direction\n    rayDir = normalize(viewMatrix * rayDir);\n    \n    //---------------------------------------------------\n   \n    float offset = 0.0;\n    #ifdef DITHERING\n    //Sometimes the blue noise texture is not immediately loaded into iChannel1\n    //leading to jitters.\n    if(iChannelResolution[1].xy == vec2(1024)){\n        //From https://blog.demofox.org/2020/05/10/ray-marching-fog-with-blue-noise/\n        //Get blue noise for the fragment.\n        float blueNoise = texture(iChannel1, fragCoord / 1024.0).r;\n        offset = fract(blueNoise + float(iFrame%32) * goldenRatio);\n    }\n    #endif\n\n    vec3 colour = getAuroraColour(cameraPos + rayDir * 10.0, rayDir, offset);; \n\n    vec3 background;\n    if(rayDir.y > 0.0){\n        background = getSkyColour(rayDir);\n        background = getMountains(rayDir, background);\n    }\n    \n    float t = 0.0;\n    if(getPlaneIntersection(cameraPos, rayDir, vec3(0), vec3(0,-1,0), t)){\n        background = getGround(cameraPos, rayDir, t);\n    }\n    \n    colour += background;\n   \n    //Tonemapping\n    colour = ACESFilm(colour);\n\n    //Gamma correction 1.0/2.2 = 0.4545...\n    colour = pow(colour, vec3(0.4545));\n\n    //Output to screen\n    fragColor = vec4(colour, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Track mouse movement and resolution change between frames and set camera position.\n\n#define PI 3.14159\n#define EPS 1e-4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    //Work with just the first four pixels.\n    if((fragCoord.x == 0.5) && (fragCoord.y < 4.0)){\n        \n        vec4 oldMouse = texelFetch(iChannel0, ivec2(0.5), 0).xyzw;\n        vec4 mouse = (iMouse / iResolution.xyxy); \n        vec4 newMouse = vec4(0);\n\n        float mouseDownLastFrame = texelFetch(iChannel0, ivec2(0.5, 3.5), 0).x;\n        \n        //If mouse button is down and was down last frame\n        if(iMouse.z > 0.0 && mouseDownLastFrame > 0.0){\n            \n            //Difference between mouse position last frame and now.\n            vec2 mouseMove = mouse.xy-oldMouse.zw;\n            newMouse = vec4(oldMouse.xy + vec2(3.5, 2.5)*mouseMove, mouse.xy);\n            \n        }else{\n            newMouse = vec4(oldMouse.xy, mouse.xy);\n        }\n        newMouse.x = mod(newMouse.x, 2.0*PI);\n        newMouse.y = min(0.999, max(-0.999, newMouse.y));\n\n        //Store mouse data in the first pixel of Buffer B.\n        if(fragCoord == vec2(0.5, 0.5)){\n            //Set value at first frames\n            if(iFrame < 5){\n                newMouse = vec4(3.3, 0.4, 0.0, 0.0);\n            }\n            fragColor = vec4(newMouse);\n        }\n\n        //Store camera position in the second pixel of Buffer B.\n        if(fragCoord == vec2(0.5, 1.5)){\n            //Set camera position from mouse information\n            vec3 targetDir = vec3(sin(newMouse.x), newMouse.y, -cos(newMouse.x));\n            fragColor = vec4(targetDir, 1.0);\n        }\n        \n        //Store resolution change data in the third pixel of Buffer B.\n        if(fragCoord == vec2(0.5, 2.5)){\n            float resolutionChangeFlag = 0.0;\n            //The resolution last frame.\n            vec2 oldResolution = texelFetch(iChannel0, ivec2(0.5, 2.5), 0).yz;\n            \n            if(iResolution.xy != oldResolution){\n            \tresolutionChangeFlag = 1.0;\n            }\n            \n        \tfragColor = vec4(resolutionChangeFlag, iResolution.xy, 1.0);\n        }\n           \n        //Store whether the mouse button is down in the fourth pixel of Buffer A\n        if(fragCoord == vec2(0.5, 3.5)){\n            if(iMouse.z > 0.0){\n            \tfragColor = vec4(vec3(1.0), 1.0);\n            }else{\n            \tfragColor = vec4(vec3(0.0), 1.0);\n            }\n        }\n        \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\n    Copyright (c) 2020 al-ro\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/","name":"Common","description":"","type":"common"}]}