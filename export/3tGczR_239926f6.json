{"ver":"0.1","info":{"id":"3tGczR","date":"1610299964","viewed":1131,"name":"Simple Signed Distance Fields","username":"AmonAhmed","description":"Trying out signed distance field functions","likes":4,"published":1,"flags":0,"usePreview":1,"tags":["math","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Resources used:\n//https://iquilezles.org/articles/distfunctions\n//http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n#define MAX_RAY_DISTANCE 1e10\n#define MAX_RAY_STEPS 100\n#define MAX_PRIMITIVES 64\n#define MAX_ARGS 16\n\n#define T_CUBE 0\n#define T_SPHERE 1\n#define T_TORUS 2\n#define T_CYLINDER 3\n\n#define T_INTERSECT 0\n#define T_UNION 1\n#define T_DIFFERENCE 2\n\n#define T_SMOOTH_INTERSECT 3\n#define T_SMOOTH_UNION 4\n#define T_SMOOTH_DIFFERENCE 5\n\nstruct Primitive{\n    Material material;\n    vec3 scale;\n    vec3 position;\n    vec3 angles;\n    int type;\n    int CSG;\n    float k;\n    vec2 vec2Args[MAX_ARGS];\n};\n\nstruct Sphere{\n    vec3 c;\n    float r;\n};\n\nstruct Cube{\n    vec3 scale;\n    vec3 position;\n    vec3 angles;\n};\n\nstruct Scene{\n    Primitive primitives[MAX_PRIMITIVES];\n    int primitive_n;\n};\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nfloat smoothUnionSDF( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat smoothDifferenceSDf( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat smoothIntersectSDF( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nfloat CSG(float distA, float distB, int CSG, float k){\n    if(distA<MAX_RAY_DISTANCE){\n        if(CSG==T_INTERSECT) return intersectSDF(distA,distB);\n        if(CSG==T_UNION) return unionSDF(distA,distB);\n        if(CSG==T_DIFFERENCE) return differenceSDF(distA,distB);\n        if(CSG==T_SMOOTH_INTERSECT) return smoothIntersectSDF(distA,distB,k);\n        if(CSG==T_SMOOTH_UNION) return smoothUnionSDF(distA,distB,k);\n        if(CSG==T_SMOOTH_DIFFERENCE) return smoothDifferenceSDf(distA,distB,k);\n    }else{\n        return distB;\n    }\n}\n\n\nfloat SphereSDF(vec3 p){\n    return length(p)-1.0;\n}\n\nfloat CubeSDF(vec3 p) {\n    vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    float outsideDistance = length(max(d, 0.0));\n    \n    return (insideDistance + outsideDistance);\n}\n\nfloat TorusSDF( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat CylinderSDF( vec3 p )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(1.0,0.5);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat SDF(vec3 p, Scene s){\n    float t = MAX_RAY_DISTANCE;\n    for(int i = 0; i<s.primitive_n; i++){\n        Primitive primitive = s.primitives[i];\n        vec3 pt=p;\n        pt-=primitive.position;\n        pt*=rotateX(-primitive.angles.x);\n        pt*=rotateY(-primitive.angles.y);\n        pt*=rotateZ(-primitive.angles.z);\n        pt/=primitive.scale;\n        float tp = t;\n        if(primitive.type == T_SPHERE) tp=SphereSDF(pt);\n        else if (primitive.type == T_CUBE)tp=CubeSDF(pt);\n        else if (primitive.type == T_TORUS)tp=TorusSDF(pt,primitive.vec2Args[0]);\n        else if (primitive.type == T_CYLINDER)tp=CylinderSDF(pt);\n        tp*=min(primitive.scale.x,min(primitive.scale.y,primitive.scale.z));\n        t=CSG(t,tp,primitive.CSG,primitive.k);\n    }\n    return t;\n}\n\n\n\n\nfloat RayMarch(vec3 ro, vec3 rd, Scene s, out float tMin){\n    float depth = 0.0;\n    tMin = MAX_RAY_DISTANCE;\n    for(int i = 0; i<MAX_RAY_STEPS; i++){\n        float t = SDF(ro+rd*depth, s);\n        tMin=min(tMin,t);\n        if(t<=EPSILON)\n        {\n            return depth;\n        }\n        depth+=t;\n        if(depth>=MAX_RAY_DISTANCE){\n            return MAX_RAY_DISTANCE;\n        }\n        \n    }\n}\n\nvec3 ApproximateNormal(vec3 p, Scene s, float o){\n    return normalize(vec3(\n        SDF(vec3(p.x + o, p.y, p.z),s) - SDF(vec3(p.x - o, p.y, p.z),s),\n        SDF(vec3(p.x, p.y + o, p.z),s) - SDF(vec3(p.x, p.y - o, p.z),s),\n        SDF(vec3(p.x, p.y, p.z  + o),s) - SDF(vec3(p.x, p.y, p.z - o),s)\n    ));\n\n}\n\nvoid CreateSpheres(inout Primitive[MAX_PRIMITIVES] p, inout int n){\n    vec2 vec2Args[MAX_ARGS];\n    Material m = Material(vec3(0.0,0.5,0.2),vec3(0.0,1.0,0.4),vec3(1.0,1.0,1.0),4.0);\n    p[n]=Primitive(m,vec3(1.0),vec3(0.0),vec3(0.0),T_SPHERE, T_SMOOTH_DIFFERENCE,0.0,vec2Args);\n    n++;\n    return;\n}\n\nvoid CreateCubes(inout Primitive[MAX_PRIMITIVES] p, inout int n){\n    vec2 vec2Args[MAX_ARGS];\n    Material m = Material(vec3(0.0,0.3,0.1),vec3(0.0,0.9,0.3),vec3(1.0,1.0,1.0),32.0);\n    p[n]=Primitive(m,abs(vec3(sin(iTime),sin(iTime),0.5*sin(iTime))),vec3(3.0*sin(iTime),0.0,0.0),vec3(2.0*PI*sin(iTime)),T_CUBE, T_SMOOTH_UNION,0.0, vec2Args);\n    n++;\n    return;\n}\n\nvoid CreateTorus(inout Primitive[MAX_PRIMITIVES] p, inout int n){\n    vec2 vec2Args[MAX_ARGS];\n    vec2Args[0]=vec2(0.9,0.1);\n    Material m = Material(vec3(0.3,0.3,0.1),vec3(0.9,0.9,0.3),vec3(1.0,1.0,1.0),16.0);\n    p[n]=Primitive(m,vec3(max(1.5,3.0*sin(iTime)),1.5,1.5),vec3(0.0,0.0,0.0),vec3(2.0*PI*sin(iTime),0.0,0.0),T_TORUS, T_SMOOTH_UNION, 0.5,vec2Args);\n    n++;\n    return;\n}\n\nvoid CreateCylinder(inout Primitive[MAX_PRIMITIVES] p, inout int n){\n    vec2 vec2Args[MAX_ARGS];\n    Material m = Material(vec3(0.25,0.25,0.25),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),4.0);\n    p[n]=Primitive(m,vec3(1.0,2.0,1.0),vec3(0.0,-2.0,0.0),vec3(0.0,0.0,0.0),T_CYLINDER, T_SMOOTH_UNION, 0.5,vec2Args);\n    n++;\n    return;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Creating ray\n    //Current ray grid point\n    vec2 p = (-iResolution.xy + 2.0*(fragCoord))/iResolution.y;\n    //Camera origin\n    vec3 ro = vec3(2.0, 2.0, 5.0 );\n    vec3 ta = vec3(0.0,0.0,1.0);\n    //Camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n    //Camera direction\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n    \n    \n    \n    //Creating Primitives\n    int n =0;\n    Primitive primitives[MAX_PRIMITIVES];\n    //Spheres\n    CreateSpheres(primitives,n);\n    //Cubes\n    CreateCubes(primitives,n);\n    //Torus\n    CreateTorus(primitives,n);\n    //Cylinder\n    CreateCylinder(primitives,n);\n    //Scene\n    Scene s = Scene(primitives,n);\n    \n    \n    //Render Scene\n    vec3 color = vec3(1.0,1.0,1.0);\n    Material material = Material(vec3(0.3,0.1,0.1),vec3(0.9,0.3,0.1),vec3(1.0,1.0,1.0),4.0);\n    Light light = Light(vec3(3.0, 3.0, 3.0 ),vec3(0.3),vec3(1.0),vec3(0.5));\n    \n    float t;\n    float depth = RayMarch(ro,rd,s, t);\n    if(t<EPSILON){\n        vec3 normal = ApproximateNormal(ro+rd*depth, s,0.01);\n        color = Lighting(ro,ro+rd*depth, normal, light,material);\n    }\n    else {\n        color = mix(vec3(0.0,0.4,0.5),color,t*8.0);\n    }\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define EPSILON 1e-3\n#define PI 3.14\n/**\n * Rotation matrix around the X axis.\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Rotation matrix around the Z axis.\n */\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nstruct Material{\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float shininess;\n};\n\nstruct Light{\n    vec3 position;\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n};\n\n\nvec3 Lighting(vec3 viewPos,vec3 fragPos, vec3 normal, Light light, Material material  ){\n     \n     // ambient\n    vec3 ambient = light.ambient * material.ambient;\n  \t\n    // diffuse \n    vec3 lightDir = normalize(light.position - fragPos);\n    float diff = max(dot(normal, lightDir), 0.0);\n    vec3 diffuse = light.diffuse * (diff * material.diffuse);\n    \n    // specular\n    vec3 viewDir = normalize(viewPos - fragPos);\n    vec3 reflectDir = reflect(-lightDir, normal);  \n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);\n    vec3 specular = light.specular * (spec * material.specular);  \n        \n    vec3 result = ambient + diffuse + specular;\n    return result;\n}","name":"Common","description":"","type":"common"}]}