{"ver":"0.1","info":{"id":"7l2SzR","date":"1626975191","viewed":37,"name":"phllpbll189/lab3","username":"phllpbll189","description":"no","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["tag"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float length_squared(in vec3 e){\n    return e.x * e.x + e.y * e.y + e.z * e.z;\n}\nconst float pos_infinity = intBitsToFloat(0x7F80000);\n\n//========================= RAY STRUCT =========================\n//Data Structure to hold our Ray. eg: Direction and Origin.\nstruct sRay\n{\n       //Should I store these as vec3 or vec4?\n       //seems like I have to convert them a lot.\n       vec4 direction;\n       vec4 origin;\n};\n\n\n//HELPER \n//function so that we can turn vec3 to a vec4 with num as W.\nvec4 mutate(in vec3 rayType, float num){\n    return vec4(rayType, num);\n}\n\n\n//CONSTRUCTOR\n//makes ray with specs provided\nsRay initRay(in vec3 direction, in vec3 origin)\n{\n    sRay temp;\n        // w = 0 because it represents a direction;\n    temp.direction = mutate(direction, 0.0);\n        // w = 1 because it represents a point; \n    temp.origin = mutate(origin, 1.0);\n    return temp;\n}\n\n\n//HELPER\n//returns a position on the plane where the ray is at.\nvec3 at(float t, sRay ray){\n    return ray.direction.xyz * t + ray.origin.xyz;\n}\n\n//==============================================================\n\n//========================== HIT RECORD=========================\n//Structure to keep track of things i assume\n//part of me wonders if this is necessarily needed\nstruct hit_record{\n    vec3 p;\n    vec3 normal;\n    float t;\n    bool front_face;\n};\n\n\n// Setting up facing direction\nvoid set_face_normal(in sRay ray, vec3 outward_normal, in hit_record rec){\n    if( dot(ray.direction.xyz, outward_normal) < 0.0){\n        rec.front_face = true;\n        rec.normal = outward_normal;\n    } else {\n        rec.front_face = false;\n        rec.normal = -outward_normal;\n    }\n}\n//================================================================\n\n//=========================== SPHERE STUFF ============================\n//Structure to hold sphere and is also list of hittablews\nstruct Sphere {\n    vec3 center;\n    float radius;\n};\n\n\n//CONSTRUCTOR\n//makes sphere with specs provided\nSphere initSphere(in vec3 center, in float radius){\n    Sphere temp;\n    temp.center = center;\n    temp.radius = radius;\n    return temp;\n}\n\n//does the ray hit the sphere?\n//From Peter Shirley's Ray Tracing in One Weekend.\n\nfloat hit_sphere(in vec3 center, in float radius, in sRay ray){\n\n    vec3 oc = ray.origin.xyz - center;\n    \n    float a = length_squared(ray.direction.xyz);\n    float b = dot(oc, ray.direction.xyz);\n    float c = length_squared(oc) - radius * radius;\n    float descriminant = b*b - a*c;\n    \n    if(descriminant < 0.0)\n    {\n        return -1.0;\n    }\n    return(-b - sqrt(descriminant)) / a;\n}//updated overloaded version below\n\n\n//peter Shirely's sphere::hit() implementation\n//updates hit_record while returning if ray hit an object or not\n//overloaded function; Math may be wrong but It looks good so far\n\nbool hit_sphere(in sRay ray, in float t_min, in float t_max, in hit_record rec, in Sphere sphere)\n{\n    \n    vec3 oc = ray.origin.xyz - sphere.center;\n    float a = length_squared(ray.direction.xyz);\n    float b = dot(oc, ray.direction.xyz);\n    float c = length_squared(oc) - sphere.radius * sphere.radius;\n    \n    float descriminant = b*b - a*c;\n    if(descriminant < 0.0){ return false; }\n    float sqrtd = sqrt(descriminant);\n    \n    float root = (-b - sqrtd) / a;\n    if(root < t_min || t_max < root){\n        root = (-b + sqrtd) / a;\n        if(root < t_min || t_max < root){ return false; }\n    }\n    \n    rec.t = root;\n    rec.p = at(rec.t, ray);\n    vec3 outward_normal = (rec.p - sphere.center) / sphere.radius;\n    set_face_normal(ray, outward_normal, rec);\n    return true;\n}\n\n\n//====================================================================\n\n//========================= HITTABLE =================================\nstruct hittable_list{\n    //cant find a data type like a c++ vector\n    //seems like we have to use an arbitrary amount\n    Sphere hittable_list[4];\n    int amount;\n    \n};\n\n\n//structure to hold onto the spheres that we make\n//and keep track of the amount in them since\n//we dont have vector storage\nhittable_list initHitList(in Sphere S){\n   hittable_list temp;\n   temp.hittable_list[0] = S;\n   temp.amount = 1;\n   return temp;\n}\n\n\n//should clear out the list but i want to implement everything else before that\nvoid clear(in hittable_list h){\n    Sphere tempList[4];\n    h.hittable_list = tempList;\n}\n\n\n//adds a sphere to the list in hittable_list\nvoid add(in hittable_list h, in Sphere S){\n    h.hittable_list[h.amount] = S;\n    h.amount+=1;\n}\n\n//see what gets hit with rays in the scene\n//Hittable_list: list of hittable items\n//Ray: rays sent into scene\n//max: closest thing to rays, IE what is blocking rays\n//min: furthest thing that returns a ray.\n//rec: recording things that \n\nbool hit(in sRay ray, in float t_min, in float t_max, in hit_record rec, in hittable_list h){\n    hit_record temp_rec;\n    bool hit_anything = false;\n    float closest = temp_rec.t;\n    \n    //Go through objects in world and see if they are getting hit by rays\n    for( int i = 0; i < h.amount; i++){\n        if(hit_sphere(ray, t_min, t_max, rec, h.hittable_list[0])){\n            hit_anything = true;\n            closest = temp_rec.t;\n            rec = temp_rec;\n        }\n   }\n    return hit_anything;\n}\n\n\n//====================================================================\n\n//======================= CALC FUNCTIONS =============================\n// calcViewport: calculate the viewing plane (viewport) coordinate\n//    viewport:       output viewing plane coordinate\n//    ndc:            output normalized device coordinate\n//    uv:             output screen-space coordinate\n//    aspect:         output aspect ratio of screen\n//    resolutionInv:  output reciprocal of resolution\n//    viewportHeight: input height of viewing plane\n//    fragCoord:      input coordinate of current fragment (in pixels)\n//    resolution:     input resolution of screen (in pixels)\nvoid calcViewport(out vec2 viewport, out vec2 ndc, out vec2 uv,\n                  out float aspect, out vec2 resolutionInv,\n                  in float viewportHeight, in vec2 fragCoord, in vec2 resolution)\n{\n    // inverse (reciprocal) resolution = 1 / resolution\n    resolutionInv = 1.0 / resolution;\n    \n    // aspect ratio = screen width / screen height\n    aspect = resolution.x * resolutionInv.y;\n\n    // uv = screen-space coordinate = [0, 1) = coord / resolution\n    uv = fragCoord * resolutionInv;\n\n    // ndc = normalized device coordinate = [-1, +1) = uv*2 - 1\n    ndc = uv * 2.0 - 1.0;\n\n    // viewport: x = [-aspect*h/2, +aspect*h/2), y = [-h/2, +h/2)\n    viewport = ndc * (vec2(aspect, 1.0) * (viewportHeight * 0.5));\n}\n\n\n\n// calcRay: calculate the ray direction and origin for the current pixel\n//    rayDirection: output direction of ray from origin\n//    rayOrigin:    output origin point of ray\n//    viewport:     input viewing plane coordinate (use above function to calculate)\n//    focalLength:  input distance to viewing plane\n\n// returns the result of shooting out a ray. Does it hit anything?\nvoid calcRay(out sRay ray, in vec2 viewport, in float focalLength)\n{     //Calculate a ray with viewport and focal length\n      //to make direction and origin\n    \n    ray = initRay(vec3(viewport.xy, -focalLength), vec3(0.0, 0.0, 0.0));\n}\n\n\n\n// calcColor: calculate the color of a pixel given a ray\n//    rayDirection: input ray direction\n//    rayOrigin:    input ray origin\n//OLD FUNCTION BUT WORKS FOR COLOR MAP\n\nvec4 calcColor(in sRay ray, Sphere S)\n{\n    hit_record rec;\n    //does it hit the sphere?\n    float t = hit_sphere(S.center, S.radius,  ray);\n    if(t > 0.0){\n       //return normal map\n       vec3 N = normalize(at(t, ray) - vec3(0.0, 0.0, -1.0));\n       return 0.5*vec4(vec3(N.x+1.0, N.y+1.0, N.z+1.0), 0.0);\n        \n    } else {\n    \n    //if not return blue gradient\n    vec4 unit_direction = normalize(ray.direction);\n    float t = 0.5*(unit_direction.y + 1.0);\n    return vec4((1.0-t) * vec3(1.0,1.0,1.0) + t * vec3(0.5,0.7,1.0), 0.0);\n    }\n\n}\n\n\nvec4 calcColor(in sRay ray, in hittable_list h)\n{\n   \n    //does it hit the sphere?\n    //float t = hit_sphere(S.center, S.radius,  ray);\n    \n    hit_record rec;\n    if(hit(ray, 0.0, pos_infinity, rec, h)){\n       //return normal map\n       //vec3 N = normalize(at(t, ray) - vec3(0.0, 0.0, -1.0));\n       return 0.5 * vec4(rec.normal + vec3(1.0,1.0,1.0), 0.0);\n        //rec.normal + color(1,1,1)\n        //vec3(N.x+1.0, N.y+1.0, N.z+1.0), 0.0\n    } else {\n    \n    //if not return blue gradient\n    vec4 unit_direction = normalize(ray.direction);\n    float t = 0.5*(unit_direction.y + 1.0);\n    return vec4((1.0-t) * vec3(1.0,1.0,1.0) + t * vec3(0.5,0.7,1.0), 0.0);\n    }\n\n}\n\n\n//============================================================\n\n\n\n//===================== MAIN FUNCTION ========================\n// mainImage: process the current pixel (exactly one call per pixel)\n//    fragColor: output final color for current pixel\n//    fragCoord: input location of current pixel in image (in pixels)\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    // viewing plane (viewport) info\n    //float inf = 1.0/0.0;\n    vec2 viewport, ndc, uv, resolutionInv;\n    float aspect;\n    const float viewportHeight = 2.0, focalLength = 1.0;\n    \n    //initiate hit list and then add to it\n    hittable_list world = initHitList(initSphere(vec3(0.0, 0.0, -1.0), 0.5));\n    add(world, initSphere(vec3(0.0, -100.5, -1.0), 100.0));\n\n    // ray\n    sRay ray;\n\n    // setup\n    calcViewport(viewport, ndc, uv, aspect, resolutionInv,\n                 viewportHeight, fragCoord, iResolution.xy);\n    calcRay(ray, viewport, focalLength);\n\n    // color\n   Sphere S = initSphere(vec3(0.0, 0.0, -1.0), 0.5);\n   \n   //2 different calcColor\n   fragColor = calcColor(ray, S);\n   \n   //overloaded to take a list of Spheres rather than one\n   //fragColor = calcColor(ray, world);\n\n    // TEST COLOR:\n    //  -> what do the other things calculated above look like?\n    //fragColor = vec4(viewport, 0.0, 0.0);\n    //fragColor = vec4(ndc, 0.0, 0.0);\n    //fragColor = vec4(uv, 0.0, 0.0);\n}","name":"Image","description":"","type":"image"}]}