{"ver":"0.1","info":{"id":"4dlcDn","date":"1487747572","viewed":124,"name":"TriangleAndHexagon","username":"Longinus","description":"Triangle and Hexagon shaders with distance to two closest points and id of cells.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["triangle","worley","hexagon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float M_PI6 = 3.14159265359/6.0;\nconst float M_PI3 = 3.14159265359/3.0;\nconst float sqrt32 = 2.0/sqrt(3.0);\nconst float sr = sqrt(3.0)/2.0;\nconst vec2 rat = vec2(1.0,sr);\n\nfloat hash(vec2 v) { return dot(v,vec2(1., -1178.65)); }\n\nvec4 HexagonWithId(vec2 uv){\n    vec2 uv2 = (uv)/rat;\n    float dmin = 1e9, d2min=1e9, nmin=-1., nmin2 = -1.;\n    for (int i=0; i<7; i++)\n    {\n        float r = float(i)*M_PI3-M_PI6;\n        vec2 uv3 = uv2-vec2(0.5,0.75)+((i!=6)?vec2(sin(r),cos(r)*sqrt32):vec2(0.0,0.0));\n        vec2 hexas = uv3+vec2(floor(uv3.y)*0.5,1.0);      \n        vec2 c = uv3+vec2(1.0,1.0)-fract(hexas);\n        float n = hash(floor(hexas));\n        vec2 dv = (c-uv2)*rat;\n        float d = length(dv);\n        if (d<dmin) { d2min=dmin; dmin=d; nmin2=nmin; nmin=n; }\n        else if (d<d2min) { d2min=d; nmin2=n; }\n    }\n    return vec4(dmin,d2min,nmin,nmin2);\n}\n\nvec4 TriangularWithId(vec2 uv){\n  \tvec2 uv2 = (uv)/rat;\n  \tfloat dmin = 1e9, d2min=1e9, nmin=-1., nmin2 = -1.;\n    vec2 c =  (uv2+uv2.y*vec2(-0.5,1.0))*vec2(1.0,0.5);  \n    vec2 fr =fract(c);\n    float even = floor(fr.x+ fr.y);\n    float fix = floor(fract(uv2.y*0.5)*2.0)*0.5;\n    vec2 c2 = uv2-mod(c,vec2(1.0,1.0));\n    vec2 p = floor(c2)+vec2(0.5+fix,1.0/3.0);\n    vec2 dv = (p-uv2)*rat;\n\n    float d =length(dv);\n    dmin =d;\n    nmin= hash(floor(p+20.0));\n    p = (floor(c2)+vec2(1.0+fix,2.0/3.0));\n    dv = (p-uv2)*rat;\n    d =length(dv);\n    if(dmin>d) {\n        d2min=dmin;\n        dmin=d;\n        nmin2 = nmin;\n        nmin = hash(floor(p));\n    }\n    else {\n        d2min=d;\n        nmin2 = hash(floor(p));\n    }\n    for(int i=0; i<2;i++)\n    {\n        p = (floor(c2)+vec2(even+fix+0.5*float(i),2.0/3.0-float(i)*1.0+2.0/3.0*even));\n        dv = (p-uv2)*rat;\n        d =length(dv);\n        if (d<d2min) { d2min=d; nmin2=hash(floor(p+even*20.0));; }\n    }\n  return vec4(dmin,d2min,nmin,nmin2);\n}\n\nfloat rnd(float x) { return fract(1000.*sin(234.56*x)); }\nvec3 rnd3(float x) { return vec3(rnd(x),rnd(x+.1),rnd(x+.2)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float dz = (sin(iTime*0.057843));\n    float dw = (sin(iTime*0.084532)+1.0);\n    float dv = (sin(iTime*0.07328834));\n\tvec2 uv = vec2(fragCoord.xy / iResolution.xy)*\n      vec2(iResolution.x/iResolution.y,1.0); //scale to normal width\n    float r = iTime*0.054387;\n    float sr= sin(r);\n    float cr= cos(r);\n    float zx= 8.0-6.0*dz;\n    uv= uv- vec2(iResolution.x/iResolution.y, 1.0)*0.5;\n    uv= uv* mat2(sr,cr,-cr,sr)*zx;\n    uv= uv + vec2(iResolution.x/iResolution.y,1.0)*0.5;\n    vec3 color= vec3(0.0,0.0,0.0);\n    float bw = 0.0;\n    vec4 he=(((fragCoord.y/iResolution.y)-fragCoord.x/iResolution.x)<dv)?TriangularWithId(uv+vec2(0.5,0.0)):HexagonWithId(uv);\n    float dx = (sin(iTime)+1.0)*0.5;\n    float dy = (sin(0.52344*iTime)+1.0)*0.5;\n    if(fragCoord.x>iResolution.x*dy){\n        if(fragCoord.y>iResolution.y*dx) {\n          bw =he.z;\n    \t  color = rnd3(bw)*vec3(0.75,1.0,0.75);\n        }\n        else\n        {\n           bw =he.w;\n    \t   color = rnd3(bw)*vec3(0.75,1.0,0.75);\n        }\n    }\n    else{\n        if(fragCoord.y>iResolution.y*(1.0-dx)) {\n        \tbw = he.x;\n        \tcolor = vec3(bw);\n        }else{\n           bw =he.y;\n    \t   color = vec3(bw);\n        }\n    }\n    color = (abs(he.x-he.y) > 0.02 ||  (fragCoord.y/iResolution.y+fragCoord.x/iResolution.x)<dw)?color:vec3(0.0,0.0,0.0);\n\tfragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}