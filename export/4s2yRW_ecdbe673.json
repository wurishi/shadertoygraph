{"ver":"0.1","info":{"id":"4s2yRW","date":"1491145758","viewed":136,"name":"Schottky Orange","username":"soma_arc","description":"Volume rendered kissing Schottky orbit of spheres.\nLooks delicious!","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d","volume","schottky"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nCreated by soma_arc - 2017\nThis work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported.\n*/\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n\tvec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n\t// implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                 fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nconst float EPSILON = 0.0001;\nconst float PI = 3.14159265;\nconst float PI_2 = 3.14159265 / 2.;\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n  float imagePlane = (height * .5) / tan(fov * .5);\n  vec3 v = normalize(target - eye);\n  vec3 xaxis = normalize(cross(v, up));\n  vec3 yaxis =  normalize(cross(v, xaxis));\n  vec3 center = v * imagePlane;\n  vec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));\n  return normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));\n}\n\nconst vec4 K = vec4(1.0, .666666, .333333, 3.0);\nvec3 hsv2rgb(const vec3 c){\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nbool intersectBox(vec3 rayOrg, vec3 rayDir, vec3 boxMin, vec3 boxMax,\n                  out float hit0, out float hit1) {\n\tfloat t0 = -10000.0, t1 = 10000.0;\n    hit0 = t0;\n    hit1 = t1;\n    \n    vec3 tNear = (boxMin - rayOrg) / rayDir;\n    vec3 tFar  = (boxMax - rayOrg) / rayDir;\n    \n    if (tNear.x > tFar.x) {\n        float tmp = tNear.x;\n        tNear.x = tFar.x;\n        tFar.x = tmp;\n    }\n    t0 = max(tNear.x, t0);\n    t1 = min(tFar.x, t1);\n\n    if (tNear.y > tFar.y) {\n        float tmp = tNear.y;\n        tNear.y = tFar.y;\n        tFar.y = tmp;\n    }\n    t0 = max(tNear.y, t0);\n    t1 = min(tFar.y, t1);\n\n    if (tNear.z > tFar.z) {\n        float tmp = tNear.z;\n        tNear.z = tFar.z;\n        tFar.z = tmp;\n    }\n    t0 = max(tNear.z, t0);\n    t1 = min(tFar.z, t1);\n\n    if (t0 <= t1) {\n        hit0 = t0;\n        hit1 = t1;\n        return true;\n    }\n    return false;\n}\n\nconst vec3 SPHERE_POS1 = vec3(100, 100, 0);\nconst vec3 SPHERE_POS2 = vec3(100, -100, 0);\nconst vec3 SPHERE_POS3 = vec3(-100, 100, 0);\nconst vec3 SPHERE_POS4 = vec3(-100, -100, 0);\nconst vec3 SPHERE_POS5 = vec3(0, 0, 141.42);\nconst vec3 SPHERE_POS6 = vec3(0, 0, -141.42);\nconst float SPHERE_R = 100.;\nconst float SPHERE_R2 = SPHERE_R * SPHERE_R;\n\nvec3 sphereInvert(vec3 pos, vec3 circlePos, float circleR){\n  return ((pos - circlePos) * circleR * circleR)/(distance(pos, circlePos) * distance(pos, circlePos) ) + circlePos;\n}\n\nconst float MAX_KLEIN_ITARATION = 30.;\nfloat IIS(vec3 pos){\n  float loopNum = 0.;\n  float dr = 1.;\n  bool loopEnd = true;\n  for(float i = 0. ; i < MAX_KLEIN_ITARATION ; i++){\n    loopEnd = true;\n    if(distance(pos, SPHERE_POS1) < SPHERE_R){\n      pos = sphereInvert(pos, SPHERE_POS1, SPHERE_R);\n      loopEnd = false;\n      loopNum++;\n    }else if(distance(pos, SPHERE_POS2) < SPHERE_R){\n      pos = sphereInvert(pos, SPHERE_POS2, SPHERE_R);\n      loopEnd = false;\n      loopNum++;\n    }else if(distance(pos, SPHERE_POS3) < SPHERE_R){\n      pos = sphereInvert(pos, SPHERE_POS3, SPHERE_R);\n      loopEnd = false;\n      loopNum++;\n    }else if(distance(pos, SPHERE_POS4) < SPHERE_R){\n      pos = sphereInvert(pos, SPHERE_POS4, SPHERE_R);\n      loopEnd = false;\n      loopNum++;\n    }else if(distance(pos, SPHERE_POS5) < SPHERE_R){\n      pos = sphereInvert(pos, SPHERE_POS5, SPHERE_R);\n      loopEnd = false;\n      loopNum++;\n    }else if(distance(pos, SPHERE_POS6) < SPHERE_R){\n      pos = sphereInvert(pos, SPHERE_POS6, SPHERE_R);\n      loopEnd = false;\n      loopNum++;\n    }\n    if(loopEnd == true) break;\n  }\n  \n  return loopNum;\n}\n\n\nvec4 sampleVolume(vec3 p) {\n    float itCount, minDist, maxDist;\n    float loopNum = IIS(p);\n    if(loopNum == 0.) return vec4(0);\n\treturn vec4(hsv2rgb(vec3(2.5 * loopNum / MAX_KLEIN_ITARATION , 1., 1.)), \n                pow(loopNum / MAX_KLEIN_ITARATION, 1.4));\n}\n\nvec3 calcColor(float time, vec3 eye, vec3 ray){\n  \tvec4 l = vec4(0);\n\n\tfloat t0, t1;\n   \tbool hit = intersectBox(eye, ray, \n                    \t\tvec3(-250), vec3(250),\n                    \t\tt0, t1);\n    \n    if(!hit) return l.rgb;\n    \n    const float MAX_SAMPLES = 150.;\n    float t = t0;\n    float tStep = (t1 - t0) / MAX_SAMPLES;\n    \n    vec3 p0 = eye + t0 * ray;\n    vec3 p1 = eye + t1 * ray;\n    vec3 distP = p0 - p1;\n    float dist = abs(dot(vec3(1, 0, 0), distP));\n    dist = max(dist, abs(dot(vec3(0, 1, 0), distP)));\n    dist = max(dist, abs(dot(vec3(0, 0, 1), distP)));\n    float sliceWidth = .05;\n    float samples = floor(dist / sliceWidth) + 1.;\n    //tStep = (t1 - t0) / samples;\n    samples = MAX_SAMPLES;\n    for (float i = 0.; i < MAX_SAMPLES; i++){\n    \tif((min(min(l.x, l.y), l.z)) > 1.0 ||\n           l.w > 0.999 ||\n           t >= t1 ||\n          samples < i) break;\n        \n        vec3 p = eye + t * ray;\n        \n        vec4 volCol = sampleVolume(p);\n        volCol.a *= 1.;\n        volCol.rgb *= volCol.a;\n        l = (1. - l.a) * volCol + l;\n        \n        t += tStep; \n    }\n    \n  \treturn l.rgb;\n}\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n  return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nconst vec3 target = vec3(0, 0, 0);\nconst vec3 up = vec3(0, 1, 0);\nfloat fov = radians(60.);\n\nconst float SAMPLE_NUM = 2.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float r = 400.;\n    vec3 eye = vec3(r * sin(iTime) , r/1.5 * sin(iTime), \n                    r * cos(iTime) );\n  \tvec3 sum = vec3(0);\n    float t = iTime;\n  \tfor(float i = 0. ; i < SAMPLE_NUM ; i++){\n    \tvec2 coordOffset = rand2n(gl_FragCoord.xy, i);\n          \n    \tvec3 ray = calcRay(eye, target, up, fov,\n        \t               iResolution.x, iResolution.y,\n            \t           gl_FragCoord.xy + coordOffset);\n          \n    \tsum += calcColor(t, eye, ray);\n  \t}\n \tvec3 col = (sum/SAMPLE_NUM);\n  \n    \n  \tfragColor = vec4(gammaCorrect(col), 1.);\n}","name":"Image","description":"","type":"image"}]}