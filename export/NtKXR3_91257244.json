{"ver":"0.1","info":{"id":"NtKXR3","date":"1641153065","viewed":284,"name":"Rolling Star Polygon","username":"Azai","description":"Based on this Mathologer video:\n[url]https://www.youtube.com/watch?v=oEN0o9ZGmOM[/url]","likes":28,"published":1,"flags":32,"usePreview":0,"tags":["star","polygon","rolling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\n// Go to the Common tab above to change the star polygon!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = texture(iChannel0, uv).xyz;\n    color =\n        color.x * vec3(0.9, 0.85, 0.8)\n      + color.y * vec3(0.9, 0.5, 0.1)\n      + color.z * vec3(0.1, 0.5, 0.9);\n    color += vec3(0.05, 0.07, 0.1);\n    float gamma = 1.0 / 1.95;\n    color = pow(color, vec3(gamma));\n    fragColor = vec4(color, 1.);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n\n// Change the grey line below to change the type of star polygon.\n// For example, to change it to the polygon {10 / 3}, change the line to:\n// #define starPolygon ivec2(10, 3)\n\n#define starPolygon ivec2(7, 3)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfloat tau = 6.28318530717958;\n\nconst int c = starPolygon.x;\nconst int a = starPolygon.y;\nconst int b = c-a;\nconst float fa = float(a)/float(c);\nconst float fb = float(b)/float(c);\n\nvec2 rotate(vec2 vector, float rotations) {\n    float c = cos(tau * rotations);\n    float s = sin(tau * rotations);\n    return c * vector + s * vec2(-vector.y, vector.x);\n}\n\nvec2 pointPos(int i, int j, float animTime) {\n    vec2 e = vec2(1, 0);\n    float fi = float(i)/float(a);\n    float fj = float(j)/float(b);\n    return (\n        rotate(e, fi + animTime * fb) * fa * fa\n      + rotate(e, fj - animTime * fa) * fb * fb\n    ) / (fa * fa + fb * fb);\n}\n\nfloat Point(vec2 p, int i, int j, float animTime) {\n    return distance(p, pointPos(i, j, animTime));\n}\n\nfloat Points(vec2 p, float animTime) {\n    \n    float dist = 1000000.0;\n    \n    for (int i = 0; i < a; i++)\n    for (int j = 0; j < b; j++) {\n        dist = min(dist, Point(p, i, j, animTime));\n    }\n    return dist;\n}\n\nfloat Line(vec2 p, int i, int j, float animTime, bool type) {\n\n    vec2 end1 = pointPos(i, j, animTime);\n    if (type) j++; else i++;\n    vec2 end2 = pointPos(i, j, animTime);\n    \n    p -= end1;\n    end2 -= end1;\n    end1 = vec2(0.0);\n    \n    float len = length(end2);\n    vec2 xAxis = end2 / len;\n    vec2 yAxis = xAxis.yx * vec2(-1, 1);\n    \n    p = vec2(dot(p, xAxis), dot(p, yAxis));\n    \n    if (p.x > 0.0 && p.x < len)\n        return abs(p.y);\n    if (p.x <= 0.0)\n        return distance(p, vec2(0, 0));\n    return distance(p, vec2(len, 0));\n}\n\nfloat Lines(vec2 p, float animTime, bool type) {\n\n    float dist = 1000000.0;\n    \n    for (int i = 0; i < a; i++)\n    for (int j = 0; j < b; j++)\n        dist = min(dist, Line(p, i, j, animTime, type));\n    \n    return dist;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n\n// Go to the Common tab above to change the star polygon!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord - iResolution.xy*0.5) / iResolution.y * 2.4;\n    p = rotate(p, -0.25);\n    \n    float animTime = iTime / 2.0;\n    \n    float threshold = 0.3 / float(starPolygon);\n    float value = 1.0 - smoothstep(threshold - 0.01, threshold + 0.01, Points(p, animTime));\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float previous = texture(iChannel0, uv).r;\n    \n    previous = min(previous, 0.5);\n    \n    value = max(value, previous) * 0.96;\n    \n    vec3 color = vec3(value, 0, 0);\n    \n    float lineAnimTime = animTime / 10.0;\n    \n    color.g += (1.0 - smoothstep(0.005, 0.015, Lines(p, animTime, false))) * smoothstep(0.0, 0.4, -sin(lineAnimTime*2.0 * tau));\n    color.b += (1.0 - smoothstep(0.005, 0.015, Lines(p, animTime, true ))) * smoothstep(0.0, 0.2, -sin(lineAnimTime * tau));\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}