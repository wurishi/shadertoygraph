{"ver":"0.1","info":{"id":"Nt2XRR","date":"1649743070","viewed":118,"name":"Ryan Polyhedra","username":"rmccampbell7","description":"Platonic, archimedean and catalan solids","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["polyhedra","platonicsolid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n//#define ORTHO\n\nconst float FOV = radians(45.);\nconst float ORTHO_SIZE = 12.;\n\nconst float PI = 3.1415927;\nconst float PHI = (1.+sqrt(5.))/2.;\n\n#define clamp01(x) clamp(x, 0., 1.)\n\nstruct DistId {\n    float dist;\n    int matId;\n};\n\nstruct Material {\n    vec3 diff_color;\n    vec3 spec_color;\n    float shininess;\n};\n\n\nfloat sdPlane(vec3 pos, vec3 norm, float d) {\n    return dot(pos, norm) - d;\n}\n\nfloat sdPlaneN(vec3 pos, vec3 norm, float d) {\n    return (dot(pos, norm) - d) / length(norm);\n}\n\nfloat sdSphere(vec3 pos, float radius) {\n    return length(pos) - radius;\n}\n\nfloat sdBox(vec3 pos, vec3 bounds) {\n    return length(max(abs(pos) - bounds, 0.));\n}\n\nfloat sdTetrahedron(vec3 pos, float r) {\n    pos.xz = abs(pos.xz);\n    vec3 n = normalize(vec3(0, sqrt(.5), 1));\n    return max(sdPlane(pos, n.xyz, r),\n               sdPlane(pos, n.zyx*vec3(1,-1,1), r));\n}\n\nfloat sdOctahedron(vec3 pos, float r) {\n    return sdPlane(abs(pos), normalize(vec3(1)), r);\n}\n\nfloat sdDodecahedron(vec3 pos, float r) {\n    pos = abs(pos);\n    vec3 n = normalize(vec3(0, 1, PHI));\n    float d =  sdPlane(pos, n.xyz, r);\n    d = max(d, sdPlane(pos, n.yzx, r));\n    d = max(d, sdPlane(pos, n.zxy, r));\n    return d;\n}\n\nfloat sdIcosahedron(vec3 pos, float r) {\n    pos = abs(pos);\n    vec3 n = normalize(vec3(0, 1./PHI, PHI));\n    float d =  sdPlane(pos, normalize(vec3(1)), r);\n    d = max(d, sdPlane(pos, n.xyz, r));\n    d = max(d, sdPlane(pos, n.yzx, r));\n    d = max(d, sdPlane(pos, n.zxy, r));\n    return d;\n}\n\nfloat sdRhombicDodecahedron(vec3 pos, float r) {\n    pos = abs(pos);\n    vec3 n = normalize(vec3(1, 1, 0));\n    float d =  sdPlane(pos, n.xyz, r);\n    d = max(d, sdPlane(pos, n.yzx, r));\n    d = max(d, sdPlane(pos, n.zxy, r));\n    return d;\n}\n\nfloat sdRhombicuboctahedron(vec3 pos, float r) {\n    pos = abs(pos);\n    vec3 n = normalize(vec3(1, 1, 0));\n    float d = max(max(pos.x, pos.y), pos.z) - r;\n    d = max(d, sdPlane(pos, n.xyz, r));\n    d = max(d, sdPlane(pos, n.yzx, r));\n    d = max(d, sdPlane(pos, n.zxy, r));\n    d = max(d, sdPlaneN(pos, vec3((2.*sqrt(2.)+1.)/7.), r));\n    return d;\n}\n\nfloat sdCuboctahedron(vec3 pos, float r) {\n    pos = abs(pos);\n    vec3 n = vec3(1, 0, 0);\n    float d =  sdPlaneN(pos, vec3(.5), r);\n    d = max(d, sdPlane(pos, n.xyz, r));\n    d = max(d, sdPlane(pos, n.yzx, r));\n    d = max(d, sdPlane(pos, n.zxy, r));\n    return d;\n}\n\n\nfloat opUnion(float a, float b) {\n    return min(a, b);\n}\n\nfloat opIntersect(float a, float b) {\n    return max(a, b);\n}\n\nfloat opSubtract(float a, float b) {\n    return max(a, -b);\n}\n\nDistId opUnion(DistId a, DistId b) {\n    if (a.dist < b.dist)\n        return a;\n    else\n        return b;\n}\n\n\nMaterial getMaterial(int matId) {\n    switch (matId) {\n    case 0:\n        return Material(vec3(.5), vec3(.8), 35.);\n    case 1:\n        return Material(vec3(1, 0, 0)*.9, vec3(.8), 20.);\n    case 2:\n        return Material(vec3(0, 1, 0)*.9, vec3(.8), 20.);\n    case 3:\n        return Material(vec3(0, 0, 1)*.9, vec3(.8), 20.);\n    case 4:\n        return Material(vec3(0, .9, 1), vec3(.8), 15.);\n    case 5:\n        return Material(vec3(1, 0, 1), vec3(.8), 15.);\n    case 6:\n        return Material(vec3(1, .8, 0), vec3(.8), 15.);\n    case 7:\n        return Material(vec3(.4, 0, 1), vec3(.8), 15.);\n    case 8:\n        return Material(vec3(1, .3, 0), vec3(.8), 15.);\n    case 9:\n        return Material(vec3(0, .3, 1), vec3(.8), 15.);\n    default:\n        return Material(vec3(.25), vec3(0), 0.);\n    }\n}\n\n\nDistId map(vec3 pos) {\n    DistId res = DistId(sdPlane(pos, vec3(0,1,0), -6.), 0);\n    res = opUnion(res, DistId(sdBox(pos - vec3(-16,0,8), vec3(3)), 6));\n    res = opUnion(res, DistId(sdTetrahedron(pos - vec3(0,0,8), 2.), 9));\n    res = opUnion(res, DistId(sdOctahedron(pos - vec3(16,0,8), 3.), 8));\n    res = opUnion(res, DistId(sdIcosahedron(pos - vec3(-8,0,0), 4.), 1));\n    res = opUnion(res, DistId(sdDodecahedron(pos - vec3(8,0,0), 4.), 3));\n    res = opUnion(res, DistId(sdRhombicDodecahedron(pos - vec3(-16,0,-8), 4.), 2));\n    res = opUnion(res, DistId(sdRhombicuboctahedron(pos - vec3(0,0,-8), 4.), 7));\n    res = opUnion(res, DistId(sdCuboctahedron(pos - vec3(16,0,-8), 4.), 4));\n    // res = opUnion(res, DistId(sdSphere(abs(pos) - vec3(16,0,4), 4.01), 7));\n    return res;\n}\n\n\nDistId castRay(vec3 origin, vec3 dir) {\n    float minDist = 1.;\n    float maxDist = 100.;\n\n    float t = minDist;\n    int matId = -1;\n    for (int i=0; i<128; i++) {\n        float eps = 1e-4*t;\n        DistId res = map(origin + dir*t);\n        matId = res.matId;\n        if (res.dist < eps || t > maxDist) break;\n        t += res.dist;\n    }\n    if (t > maxDist)\n        matId = -1;\n    return DistId(t, matId);\n}\n\n\nvec3 calcNormal(vec3 pos) {\n    vec2 e = vec2(1.0, -1.0) * 1e-3;\n    return normalize(e.xyy * map(pos + e.xyy).dist +\n                     e.yxy * map(pos + e.yxy).dist +\n                     e.yyx * map(pos + e.yyx).dist +\n                     e.xxx * map(pos + e.xxx).dist);\n}\n\n\nvec3 shade(vec3 origin, vec3 dir, float dist, int matId) {\n    vec3 pos = origin + dist*dir;\n    vec3 normal = calcNormal(pos);\n    Material mat = getMaterial(matId);\n    float ambient = .12*(1.0 + .6*normal.y);\n    \n    vec3 light1 = normalize(vec3(1, 1, .75));\n    float diffuse = clamp01(dot(normal, light1));\n    float specular = pow(clamp01(dot(reflect(-light1, normal), -dir)), mat.shininess);\n\n    vec3 light2 = normalize(vec3(1, .5, -2));\n    diffuse += .8 * clamp01(dot(normal, light2));\n    specular += .8 * pow(clamp01(dot(reflect(-light2, normal), -dir)), mat.shininess);\n\n    float total = diffuse + ambient;\n    vec3 col = clamp01(total)*mat.diff_color;\n    col += clamp01(specular)*mat.spec_color;\n    return clamp01(col);\n}\n\n\nvec3 render(vec3 origin, vec3 dir) {\n    vec3 col = vec3(.5, .8, 1.)*(1.+1.5*dir.y);\n    DistId res = castRay(origin, dir);\n    if (res.matId >= 0) {\n        col = shade(origin, dir, res.dist, res.matId);\n    }\n    return col;\n}\n\n\nmat3 lookAt(vec3 cameraPos, vec3 center, vec3 up) {\n    vec3 forward = normalize(center - cameraPos);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    return mat3(right, up, forward);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 mouse = iMouse.xy == vec2(0) ?\n        vec2(0,-.4) : (2.*iMouse.xy - iResolution.xy) / iResolution.xy;\n\n    float r = 35.;\n    float theta = 2.*PI*(iTime/10. + mouse.x*.5 + .25);\n    float phi = -mouse.y*PI/2.;\n    vec3 cameraPos = vec3(r*cos(theta)*cos(phi), r*sin(phi), r*sin(theta)*cos(phi));\n    vec3 center = vec3(0, 0, 0);\n    mat3 cameraRot = lookAt(cameraPos, center, vec3(0, 1, 0));\n\n    float screenDist = 1. / tan(FOV/2.);\n\n    vec3 col = vec3(0);\n    for (int i=0; i<AA; i++) {\n        for (int j=0; j<AA; j++) {\n            vec2 pix = fragCoord + (vec2(i, j)+.5)/float(AA) - .5;\n            vec2 uv = (2.*pix - iResolution.xy) / iResolution.y;\n            #ifdef ORTHO\n            vec3 rayPos = cameraPos + cameraRot * vec3(uv, 0) * ORTHO_SIZE;\n            vec3 rayDir = cameraRot * vec3(0, 0, 1);\n            #else\n            vec3 rayPos = cameraPos;\n            vec3 rayDir = cameraRot * normalize(vec3(uv, screenDist));\n            #endif\n            col += render(rayPos, rayDir);\n        }\n    }\n    col /= float(AA*AA);\n\n    // gamma\n    col = pow(col, vec3(1./2.2));\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}