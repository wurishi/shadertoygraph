{"ver":"0.1","info":{"id":"clG3DD","date":"1683985656","viewed":137,"name":"New way to gen terrain noise","username":"sjz1","description":"use fbm & jacobian determinant to generate an interesting terrain noise (more reality)","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["noise","terrain","jacobian"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 noised(vec2 pos);\n\n//this terrain noise contains various landforms,such as plains,hills and mountains\nmat2 m0=mat2(0.6,0.8,-0.8,0.6);\nfloat terrain(vec2 p){\n    p*=0.3;\n\n    const int S=20;\n    vec3 A0=noised(p*0.5)*vec3(1,0.5,0.5)*1.25;//random value and its partial derivative\n    float A=A0.x;\n    \n    float B=0.8;//scale\n    const float scale_A=0.5;\n    const float scale_B=1.475;\n    \n    vec2 p1x=vec2(1,0),p1y=vec2(0,1);\n    mat2 m_x=mat2(cos(0.3),sin(0.3),-sin(0.3),cos(0.3));\n    mat2 m_y=inverse(m_x);\n    mat2 m=mat2(1,0,0,1);\n    mat2 m1=mat2(0,0,0,0);\n    for(int i=0;i<S;i++){\n    \n        //here we generate a \"path\" of the original coord\n        //u.x is the offset of x,and u.yz is the partial derivative of u.x\n        vec2 k=vec2(cos(float(i)*10.),sin(float(i)*10.))*5.;\n        m1=m*B;\n        vec3 u=noised(m1*(p+m_x*k));\n        u.yz*=m1;\n        m1*=m0;\n        vec3 v=noised(m1*(p+m_y*k));\n        v.yz*=m1;\n        u*=PI;v*=PI;\n        \n        //choose x'=x+A*cos(PI*u.x)\n        //then the partial derivative is px'=px-A*u.yz*PI*sin(u.x*PI)+A0.yz*cos(u.x*PI)\n        \n        p1x+=-A*u.yz*qSin(u.x)+A0.yz*qCos(u.x);\n        p1y+=-A*v.yz*qSin(v.x)+A0.yz*qCos(v.x);\n        \n        //fbm\n        A*=scale_A;\n        A0*=scale_A;\n        B*=scale_B;\n        m*=m0;\n        \n        //p+=1.;\n    }\n    \n    //then we get the final \"path\" and its partial derivative\n    //just use Jacobian determinant to calculate the density of the \"path\"\n    \n    float s=p1x.x*p1y.y-p1x.y*p1y.x;//Jacobian determinant\n    \n    s=s/(1.+0.025*abs(s));//limit the height\n    return s;\n}\n\n#define USE_SMOOTH_NOISE 1   // enable to prevent discontinuities\n\n\n// value noise, and its analytical derivatives\nvec3 noised( in vec2 x )\n{\n    vec2 f = fract(x);\n    #if USE_SMOOTH_NOISE==0\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n    #else\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n    #endif\n\n#if 0\n    // texel fetch version\n    ivec2 p = ivec2(floor(x));\n    float a = texelFetch( iChannel0, (p+ivec2(0,0))&255, 0 ).x;\n\tfloat b = texelFetch( iChannel0, (p+ivec2(1,0))&255, 0 ).x;\n\tfloat c = texelFetch( iChannel0, (p+ivec2(0,1))&255, 0 ).x;\n\tfloat d = texelFetch( iChannel0, (p+ivec2(1,1))&255, 0 ).x;\n#else    \n    // texture version    \n    vec2 p = floor(x);\n\tfloat a = textureLod( iChannel0, fract((p+vec2(0.5,0.5))/256.0), 0.0 ).x;\n\tfloat b = textureLod( iChannel0, fract((p+vec2(1.5,0.5))/256.0), 0.0 ).x;\n\tfloat c = textureLod( iChannel0, fract((p+vec2(0.5,1.5))/256.0), 0.0 ).x;\n\tfloat d = textureLod( iChannel0, fract((p+vec2(1.5,1.5))/256.0), 0.0 ).x;\n#endif\n    \n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\tdu*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y*=iResolution.y/iResolution.x;\n    // Time varying pixel color\n    float h=terrain(uv*40.+float(iTime)*2.)+1.;\n    \n    vec3 col = vec3(0.1)*h;//hsv2rgb(vec3(fract(floor(h*256.)/256.),1.,fract(h)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvec3 rgb2hsv(vec3 c){\n\n    const vec4 k=vec4(0.0,-1.0/3.0,2.0/3.0,-1.0);\n    vec4 p=mix(vec4(c.bg,k.wz),vec4(c.gb,k.xy),step(c.b,c.g));\n    vec4 q=mix(vec4(p.xyw,c.r),vec4(c.r,p.yzx),step(p.x,c.r));\n    float d=q.x-min(q.w,q.y);\n    return vec3(abs(q.z+(q.w-q.y)/(6.*d+0.001)),d/(q.x+0.001),q.x);\n\n}\nconst float PI=3.14159265358;\nfloat qCos(float x){//quick cosine\n    x=fract(x*0.25*0.636619772368)*4.;\n    x=abs(x-2.)-1.;\n    float x2=x*x;\n    return 1.57079632679*x*(1.+x2*(-0.408450569081+0.0450703414486*x2));\n\n}\n\nfloat qSin(float x){\n    return qCos(x-1.57079632679);\n\n}","name":"Common","description":"","type":"common"}]}