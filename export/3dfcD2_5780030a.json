{"ver":"0.1","info":{"id":"3dfcD2","date":"1661392162","viewed":218,"name":"floorsp","username":"mirumoreem","description":"temp","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["temp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 sky(vec3 rd) {\n  float n = max(0., rd.y);\n  n +=1.0;\n  return mix(vec3(1.0), vec3(0.7, 0.8, 0.9), n);\n}\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat noise21 (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\nfloat fbm21 ( in vec2 _st) {\n    float v = 0.0;\n    float a = 0.6;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < 5; ++i) {\n        v += a * noise21(_st+iTime*0.1);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nfloat mixfbm(vec2 p){\n    vec2 q = vec2( fbm21( p + vec2(0.0,0.0) ),\n                   fbm21( p + vec2(5.2,1.3) ) );\n\n    vec2 r = vec2( fbm21( p + 4.0*q + vec2(1.7,9.2) ),\n                   fbm21( p + 4.0*q + vec2(8.3,2.8) ) );\n\n    //return fbm21( p + 4.0*r );\n    return fbm21(q);\n}\n\n//////////\n\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 33.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nfloat fbm(vec3 x) {\n    \n\tfloat v = 0.0;\n\tfloat a = 1.0;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < 5; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * (1.0) + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\n////////\n\nvec3 twist(vec3 p, float power){\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m * p;\n}\n\nvec3 twistX(vec3 p, float power){\n    float s = sin(power * p.x);\n    float c = cos(power * p.x);\n    mat3 m = mat3(\n        1.0, 0.0, 0.0,\n        0.0,   c,   s,\n        0.0,  -s,   c\n    );\n    return m * p;\n}\n\n\n\n/////\nfloat distPlane(in vec3 p, vec4 n)\n{\n    return dot(p, n.xyz) + n.w;\n}\n\nvec4 plane = vec4(0.0, 0.8, 0.0, 0.8);\n\nfloat distHeight(in vec3 p)\n{\n    float d = distPlane(p, plane);\n    //float tex = texture(iChannel0, mod(p.xz * 0.2, 1.0));\n    float tex = mixfbm(p.xz);\n    tex *= 1.0;\n\treturn  d- tex;\n}\n\n\n/////\n\nfloat sphere_d(vec3 pos, float s){\n    \n    return length(pos) - s;\n}\n\nfloat box_d(vec3 pos, vec3 size){\n    vec3 q = abs(pos) - size;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat smin(float d1, float d2, float k ){\n    float res = exp(-k * d1) + exp(-k * d2);\n    return -log(res) / k;\n}\n\nfloat object_d(vec3 pos){\n    //vec3 p = mod(pos, 4.0) - 2.0;\n    vec3 move =  vec3(0.0, 4.0, 0.0);\n    vec3 twistpos = twist(pos - move, 0.2+ (0.1+0.5*sin(iTime*0.5)));\n    twistpos = twistX(pos - move , 0.2+(0.1+0.5*cos(iTime*0.5)));\n  \n    //float n =  length(fbm(pos)-.15+sin(iTime)*.05 )-.1;\n    float n = sphere_d(twistpos, 4.5)+fbm(twistpos);\n    float m = distHeight(pos);\n    n = min(n,m);\n    return  n; \n}\n\n    \nvec3 getNormal(vec3 pos){\n    float d = 0.001;\n    return normalize(vec3(\n        object_d(pos + vec3(  d, 0.0, 0.0)) - object_d(pos + vec3( -d, 0.0, 0.0)),\n        object_d(pos + vec3(0.0,   d, 0.0)) - object_d(pos + vec3(0.0,  -d, 0.0)),\n        object_d(pos + vec3(0.0, 0.0,   d)) - object_d(pos + vec3(0.0, 0.0,  -d))\n    ));\n}\n\n\nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n};\n    \n    \nmat3 x_axis_rot(float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c); \n \n}\n\nmat3 y_axis_rot(float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0,  c);\n}\n    \n    \n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 pos = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 color = vec3(0.0);\n    \n    vec2 mouse_pos =  (iMouse.xy/iResolution.xy-.5) * 2.;\n    \n    \n    \n    vec3 camera_pos = vec3(0.0, 0.5, -10.0);\n    vec3 camera_up = vec3(0.0, 1.0, 0.0);\n    vec3 camera_dir = vec3(0.0, 0.0, 1.0);\n    vec3 camera_side = cross(camera_up, camera_dir);\n    \n    Ray ray;\n    ray.pos = camera_pos;\n    ray.dir = normalize(pos.x * camera_side + pos.y * camera_up + camera_dir);\n    \n    mat3 rot = x_axis_rot(0.0) * y_axis_rot(0.0);\n    \n    \n    float t = 0.0, d;\n    float b = 0.0;\n    for(int i = 0; i < 128; i++){\n        d = object_d(rot*ray.pos);\n        \n        if (d < 0.001){\n            break;\n        }\n        t += d;\n        ray.pos = camera_pos + t*ray.dir;\n        b += 1./100.;\n    } \n    \n    \n    vec3 light_dir = normalize(vec3(-1.0, 1.0 , -1.0));\n    vec3 light2_dir = normalize(vec3(1.0, -1.0 , 1.0));\n    vec3 normal = getNormal(rot*ray.pos);\n    \n    float L = dot(normal, light_dir);\n    float L2 = dot(normal, light2_dir);\n    \n    \n   \n    L = max(L, L2);  ///maxにすると良い\n    \n    \n    \n    //b = pow(b,2.0);\n    //L = min(b,L);\n    vec3 blue = vec3(0.1, 0.3, 0.8)*4.0;\n    vec3 green = vec3(0.0, 0.05, 0.1);\n    vec3 b3 = b* blue;\n    \n    \n    if(d < 0.001){\n        color = max(vec3(L*0.0), b3);;\n    } else{\n        color =sky(ray.dir);\n    }\n    \n    \n    \n    fragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"}]}