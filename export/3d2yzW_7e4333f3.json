{"ver":"0.1","info":{"id":"3d2yzW","date":"1586205308","viewed":64,"name":"menger--v4-sdCylinder","username":"jorge2017a1","description":"menger--v4-sdCylinder","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["mengerv4sdcylinder"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////modificado por jorge flores.p --\n//Gracias a ....Created by russ in 2017-04-06\n//https://www.shadertoy.com/view/XsfczB\n    \n\nconst int iter =100;\nconst float eps = 0.001, far = 20.;\nvec3 lDir0 = normalize(vec3(1,2,1)), lDir1 = normalize(vec3(-1,1.0,-2));\nvec3 lCol0 = vec3(1,.8,.5), lCol1 = vec3(.6,0.8,1); \n\n\n#define PI 3.1415926\n\n///-------------------------------------\nconst int MAX_RAY_STEPS = 64;\nconst float RAY_STOP_TRESHOLD = 0.0001;\nconst int MENGER_ITERATIONS = 5;\n///-------------------------------------\n\nfloat NumCol;\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\n//-------------------------------------------\n\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\nfloat sdCross(vec3 p) {\n\tp = abs(p);\n\tvec3 d = vec3(max(p.x, p.y),\n\t\t\t\t  max(p.y, p.z),\n\t\t\t\t  max(p.z, p.x));\n\treturn min(d.x, min(d.y, d.z)) - (1.0 / 3.0);\n}\n\nfloat sdCrossRep(vec3 p) {\n\tvec3 q = mod(p + 1.0, 2.0) - 1.0;\n\treturn sdCross(q);\n}\n\nfloat sdCrossRepScale(vec3 p, float s) {\n\treturn sdCrossRep(p * s) / s;\t\n}\n\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n//---------------------\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n\nfloat diso( vec3 p)\n{\n    \n    vec2 res=vec2(9999.,0.0);\n    float dif1;\n   \n    p.z=mod(p.z,2.0);\n    float sdcy1 =sdCylinder(  p.yzx, vec2(6.0,6.0) ) ;\n    float sdcy2 =sdCylinder(  p.yzx, vec2(4.7,6.78) ) ;\n   \tfloat sdb1 =sdBox( p, vec3(5.0,-1.0,6.0) );\n    \n    dif1 = differenceSDF(sdcy1,sdcy2);\n    dif1 = differenceSDF(dif1,sdb1);\n    \n    \n    res=opU(res, vec2(dif1,9.0) );\n   \n    return res.x;\n}  \n\n//--------------------------\nfloat DE(vec3 p) {\n\t\n    \n    float scale = 0.35;\n    vec2 res=vec2(9999.9,0.0) ;\n\n    float dist, dist1;\n     dist=-999.0;\n     dist =diso(p);\n \n\tfor (int i = 0; i < MENGER_ITERATIONS; i++) {\n\t\tdist = max(dist, -sdCrossRepScale(p, scale));\n\t\tscale *= 3.0;\n\t}\n\n\t\n    \n    \n    if (mod(iTime, 10.0)>0.5 )\n    {\n    \tres=opU(res, vec2(dist,8.0) );\n\t}\n    else\n    {\n    \tres=opU(res, vec2(dist,11.0) );\n\t}   \n    \n    \n    NumCol =res.y;\n    \n\treturn res.x;\n}\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\n\n\n\nvec2 march(vec3 ro, vec3 rd){\n\tfloat t=0. , d = far, it = 0.;\n    for (int i=0;i<iter;i++){\n     \tt += (d = DE(ro+t*rd));\n        if(d<eps || t> far) break;\n        it += 1.;\n    }\n    return vec2(t,it/float(iter));\n}\n\nfloat getShadow(vec3 p, vec3 n, vec3 ld){\n    p +=  2. * eps * n;\n    float t=0.,d=far;\n    for(int i=0;i<50;i++){\n        t += (d=DE(p + t*ld));\n        if (d<eps || t>3.) break;\n    }\n    return t<=3. ? 0.1 : 1. ;\n}\n\nvec3 getRay(vec3 ro, vec3 look, vec2 uv){\n    vec3 f = normalize(look - ro);\n    vec3 r = normalize(vec3(f.z,0,-f.x));\n    vec3 u = cross (f,r);\n    return normalize(f + uv.x * r + uv.y * u);\n}\n\nvec3 getNorm(vec3 p){\n    vec2 e = vec2(eps, 0);\n    return normalize(vec3(DE(p+e.xyy)-DE(p-e.xyy),DE(p+e.yxy)-DE(p-e.yxy),DE(p+e.yyx)-DE(p-e.yyx)));\n}\n\nvec3 light(vec3 p, vec3 n){\n    vec3 col = vec3(0.01);\n    for(int i=0;i<2;i++){\n        vec3 ld = (i==0) ? lDir0 : lDir1;\n        float diff = max(dot(n, (ld)),0.);\n        diff *= getShadow(p, n, ld);\n        col += diff * (i==0 ? lCol0 : lCol1);\n    }\n    return col * .7;\n}\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n\n//-----------------------------------\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        return vec3(0.,0.,0.);\n    }\n    \n    if(i== 1 )\n    {\n        \n        return vec3(0.,0.,1.);\n    } \n    if(i== 2 )\n    {\n       return vec3(0.,1.,0.);\n    } \n    if(i== 3 )\n    {\n        return vec3(0.,1.,1.);\n    } \n    if(i== 4 )\n    {\n        return vec3(1., 0., 0.);\n    } \n    \n    if(i== 5 )\n    {\n        return vec3(1., 0.,1.);\n        } \n    if(i== 6 )\n    {\n        \n    \t//return vec3(1., 1., 0.);\n         \n    } \n        \n    if(i== 7 )\n    {\n        return vec3(1., 1., 1.);\n       } \n    if(i== 8 )\n    {\n       \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    \n    if(i== 11 )\n    {\n        return  vec3(0.5, 0.8, 0.9);;\n    } \n    \n    \n    \n  \n    \t\n}\n\n\n//----------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float time = iTime * 0.5;\n   \n\tvec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n  \n    \n    \n \n   \n    vec3 ro = vec3(0.0,5.0+0.5*sin(iTime),-5.0+iTime);\n    \n   \n    vec3 rd =normalize(vec3(uv,1.0) );\n    \n    vec2 hit = march(ro, rd);\n    vec3 p = ro + hit.x*rd;\n    \n    vec3 col = hit.x<far ? light(p, getNorm(p)) : vec3(.1*(1.-length(uv)));\n    \n    vec3 colobj=getSphereColor( int( NumCol));\n    col *=colobj;\n    \n    \n    col += pow(hit.y,3.);\n\tfragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"}]}