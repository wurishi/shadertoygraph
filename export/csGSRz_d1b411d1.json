{"ver":"0.1","info":{"id":"csGSRz","date":"1686089980","viewed":60,"name":"3D Julia but wrong????","username":"rucksack","description":"please send help idk what went wrong here?","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"csGGWz","parentname":"Raymarching Template 2.0"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Raymarching parameters\nconst int MAX_STEPS = 300;\nconst float TOO_FAR = 10.;\nconst float NEAR_ENOUGH  = .001;\nconst float NORMAL_DELTA = .01;\nconst float FUDGE = 1.;\n\n// Lighting parameters\nconst float DIFFUSE_RATIO = .5;\nconst float BECKMANN_ALPHA = .2; // = roughness^2\nconst float INDEX_OF_REFRACTION = .001;\nconst float LIGHT_INTENSITY = 1.3;\nconst float SHADOW_RATIO = .9;\n\n// Colors\nconst vec3 BACKGROUND_COLOR = .1*vec3(0.97255,0.95686,0.94118);\nconst vec3 SHADOW_COLOR     = .1*vec3(0.35686,0.14902,0.20392);\nconst vec3 TINT_COLOR       = .4*vec3(0.95686,0.14902,0.40392);\nconst vec3 SPECULAR_COLOR   = vec3(1);\n\nconst float PI = 3.14159265359;\n\nconst int MAX_ITERATIONS = 50;\n\n\n//#define SHADOWS\n\nmat3 rotateY(float a) {\n    return mat3(\n        -sin(a), 0, cos(a),\n              0, 1, 0,\n         cos(a), 0, sin(a)\n    );\n}\n\nmat3 rotateX(float a) {\n    return mat3(\n        1,       0,      0,\n        0, -sin(a), cos(a),\n        0,  cos(a), sin(a)\n    );\n}\n\nfloat rand(vec2 uv) {\n    return fract(sin(dot(uv, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat dither(vec2 uv) {\n  return (rand(uv)*2. - 1.) / 156.;\n}\n\nfloat cube(vec3 point, vec3 center, float size) {\n    vec3 q = abs(point - center) - size;\n    return max(q.x, max(q.y, q.z));\n}\n\n// f_n(z) = f_n-1(z)^2 + c, f_0(z) = z\nvec4 next(vec4 z, vec4 c) {\n    return qmul(z, z) + c;\n    return qpow(z, 8) + z;\n}\n\n// f'_n(z) = 2*f_n-1(z)*f'_n-1(z), f'_0(z) = 1\nvec4 derivative(vec4 z, vec4 dr) {\n    return 2.*qmul(z, dr);\n    return 8.*qmul(qpow(z, 7), dr);\n}\n\n// TODO avoid doing actual derivative, only update norms!\nfloat derivative(float r, float dr) {\n    return 4.*r*dr;\n}\n\nfloat map(vec4 z, vec4 c, out int i) {\n    i = 0;\n    float dr = 3.;\n    float r = qnorm(z);\n    for (; i < MAX_ITERATIONS && r < 2.*qnorm(c); i++) {\n        z = next(z, c);\n        dr = derivative(r, dr);\n        r = qnorm(z);\n    }\n    return .5 * log(r) * sqrt(r/max(0.000001, dr));\n}\n\nfloat distance_from_everything(vec3 pos) {\n    int i;\n    return map(vec4(pos, sin(iTime)), vec4(1, vec3(-.3)), i); \n}\n\nfloat ray_march(vec3 ray_origin, vec3 ray_direction, out int steps, out float mindist) {\n    float d = 0.0;\n    steps = 0;\n    mindist = TOO_FAR;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 point = ray_origin + ray_direction*d;\n        float current_distance = distance_from_everything(point);\n        mindist = min(mindist, current_distance);\n        d += current_distance*FUDGE;\n        steps++;\n        if (current_distance < NEAR_ENOUGH || d > TOO_FAR)\n            break;\n    }\n    return d;\n}\n\n// Approach taken from https://iquilezles.org/articles/rmshadows\nfloat ray_shadow(vec3 ray_origin, vec3 ray_direction, vec3 light_position) {\n    // Start some distance along the rain to avoid counting shadow because we're close to the surface\n    float d = NEAR_ENOUGH;\n    float shade = 1.0;\n    float shadow_factor = 32.;\n    // Sign of the direction we're travelling,\n    // if this changes we know that we passed the light source.\n    vec3 side = sign(light_position - ray_origin);\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 point = ray_origin + ray_direction*d;\n        float current_distance = distance_from_everything(point);\n        d += current_distance;\n        // Update to more significant shadow value\n        shade = min(shade, shadow_factor * current_distance / d);\n        // Only check if we've gone too far or gone beyond the light source\n        if (d > TOO_FAR || sign(light_position - point) != side)\n            break;\n    }\n    return max(shade, 0.);\n}\n\n// Estimate ambient occlusion using n steps along the normal\nfloat ray_occlusion(vec3 ray_origin, vec3 ray_direction) {\n    float k = 70.;\n    float delta = 7.*NEAR_ENOUGH;\n    float dist = delta;\n    float occlusion = 0.;\n    float decay = 0.5;\n    for (int i = 0; i < 5; i++) {\n        vec3 point = ray_origin + ray_direction * dist;\n        float current_distance = distance_from_everything(point);\n        occlusion += k * decay * (dist - current_distance);\n        decay *= 0.5;\n        dist += delta;\n    }\n    return 1. - occlusion;\n}\n\n// See https://iquilezles.org/articles/normalsSDF\nvec3 estimate_normal(vec3 point) {\n    vec2 e = vec2(NORMAL_DELTA, 0); // x smol, y none\n    // Find normal as tangent of distance function\n    return normalize(vec3(\n        distance_from_everything(point + e.xyy) - distance_from_everything(point - e.xyy),\n        distance_from_everything(point + e.yxy) - distance_from_everything(point - e.yxy),\n        distance_from_everything(point + e.yyx) - distance_from_everything(point - e.yyx)\n    ));\n}\n\nfloat beckmann_distribution(vec3 n, vec3 c, vec3 l, float m) {\n    vec3 h = (c + l) / 2.;\n    float a = acos(dot(n, h));\n    return exp(-pow(tan(a), 2.)/(m*m))/(PI*m*m*pow(abs(cos(a)), 4.));\n}\n\nfloat cook_torrance_specular(vec3 n, vec3 v, vec3 l) {\n    vec3 h = (v + l) / 2.;\n    float D = beckmann_distribution(n, v, l, BECKMANN_ALPHA);\n    float n2 = INDEX_OF_REFRACTION;\n    float reflectance = (1. - n2)/(1. + n2) * (1. - n2)/(1. + n2);\n    float theta = acos(dot(n, v));\n    float F = reflectance + (1. - reflectance)*pow(1. - cos(theta), 5.);\n    float G = min(1., min(2.*dot(h, n)*dot(v, n)/dot(v, h), 2.*dot(h, n)*dot(l, n)/dot(v, h)));\n    // Note that dot(n, l) is typically in the divisor here, but it serves only to cancel the diffuse dot(n, l)\n    return D*F*G/(4.*dot(v, n));\n}\n\nvec3 light_contribution(vec3 light_position, float light_intensity, vec3 light_color, vec3 surface_color, vec3 point, vec3 n, vec3 c) {\n    vec3 l = normalize(light_position-point);\n    // Cook-Torrance lighting\n    vec3 specular = cook_torrance_specular(n, c, l) * light_color;\n    vec3 light = light_intensity * (max(dot(n, l), 0.) * DIFFUSE_RATIO * surface_color + (1. - DIFFUSE_RATIO) * specular);\n\n    // Find soft shadow factor by marching from where you stand\n#ifdef SHADOWS\n    float shade = ray_shadow(point, l, light_position);\n    return mix(SHADOW_COLOR, light, shade * SHADOW_RATIO + (1. - SHADOW_RATIO));\n#else\n    return light;\n#endif\n}\n\nvec3 lighting(vec3 point, vec3 camera, vec3 ray_direction, float dist, int steps, float mindist) {\n    if (length(point - camera) > TOO_FAR*0.99) {\n        return BACKGROUND_COLOR + .04*log(1./(.3*mindist));\n    }\n\n    vec3 n = estimate_normal(point);\n    vec3 c = normalize(camera-point);\n\n    vec3 surface_color = vec3(1, 1, .07*log(1./mindist));\n    float ambient_occlusion = ray_occlusion(point, n);\n\n    vec3 color = mix(SHADOW_COLOR, .3*surface_color, ambient_occlusion);\n    color += light_contribution(vec3(-2.5, 1., -5.), 1.2, SPECULAR_COLOR, surface_color, point, n, c);\n    color += light_contribution(vec3(3., 4., 5.), .4, vec3(1,0,0), surface_color, point, n, c);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 xy = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    mat3 rot = rotateX(m.y*PI) * rotateY(m.x*PI*2.);\n\n    vec3 camera = vec3(0, 0, -3.5) * rot;\n    vec3 ray_direction = vec3(xy, 1) * rot;\n\n    int steps;\n    float mindist;\n    float dist = ray_march(camera, ray_direction, steps, mindist);\n    vec3 point = camera + ray_direction * dist;\n\n    vec3 base_color = lighting(point, camera, ray_direction, dist, steps, mindist);\n\n    fragColor = vec4(base_color + dither(fragCoord), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Multiplication obeys a set of laws for i, j and k\nvec4 qmul(in vec4 a, in vec4 b) {\n    return vec4(a.s*b.s - a.t*b.t - a.p*b.p - a.q*b.q,\n                a.s*b.t + a.t*b.s + a.p*b.q - a.q*b.p,\n                a.s*b.p + a.p*b.s + a.q*b.t - a.t*b.q,\n                a.s*b.q + a.q*b.s + a.t*b.p - a.p*b.t);\n}\n\nvec4 qpow(in vec4 q, in int p) {\n    vec4 result = q;\n    for (int i = 0; i < p; i++) {\n        result = qmul(result, q);\n    }\n    return result;\n}\n\n// Norm is simply the sum of squares of its components\nfloat qnorm(in vec4 q) {\n    return q.s*q.s + q.t*q.t + q.p*q.p + q.q*q.q;\n}","name":"Common","description":"","type":"common"}]}