{"ver":"0.1","info":{"id":"tljBDz","date":"1598929078","viewed":153,"name":"Capillary Wave Reflection Pool","username":"slickytail","description":"A simulation of ripples on water that reflects an image","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","reflection","effect","animated"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON 0.01\n// The physically accurate value of SR for water is 0.0204\n// I increased it to make the water more reflective.\n#define SR 0.1\n\nconst float angle = 1.;\nconst mat2 m = mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\nconst vec3 cam = vec3(0, vec2(0, 15)*m);\n\n// Both of these upper bounds depend on the height_scale\n// But I'm too lazy to compute the actual least bounds.\n\n// zUB is actually an underestimate\n// In theory, 20 ripples could pop up in the exact same place at the exact same time.\n// Which would result in a maximum height of 20 * height_scale / 1.5 ~= 1.33\nconst float zUB = .2;\nconst float slopeUB = 1.;\n\nconst float g = sin(atan(1.,slopeUB));\n\nconst vec4 watercolor = vec4(.5, .75, .9, 1);\nconst vec4 deepwater = vec4(0.1, 0.17, 0.21, 1);\nconst vec4 sky = vec4(.7, .83, .9, 1);\n\nvec4 heightMap(vec2 p) {\n    // We want to transform the range (-15, 15) x (-7, 25) into (0, 1) x (0, 1)\n    vec2 pp = (p + vec2(15, 7)) / 30.;\n   \t// Essentially, we're scaling the model up by 30 times. \n    // This means we have to scale up the height as well!\n    // Otherwise the normals will be wrong\n    return (texture(iChannel0, pp) * 2. - vec4(1)) * vec4(30., vec3(1));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    // Raymarch, using the generated ripples as a heightmap\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 rt = vec3(10.*uv, 2);\n    // Apply the angle transformation to the camera\n    rt.yz *= m;\n    // Raymarching a Lipschitz-continuous heightfield, from user TheKing\n   \tvec3 rd = normalize(rt - cam);\n    \n    // We're going to jump the ray to the height upper bound,\n    // which should save us a few marching steps.\n    vec3 p = cam + rd*(zUB - cam.z)/rd.z;\n    \n    for (int step = 0; step < 20; step++) {\n        float d = (p.z - heightMap(p.xy).x)*g;\n        p += rd*d;\n        if (d < EPSILON || p.y > 27.) break;\n    }\n    vec3 normal = heightMap(p.xy).yzw;\n    \n    vec3 reflectdir = reflect(rd, normal);\n    // Shlick Fresnel\n    float R = SR + (1. - SR)*pow(1. + min(0., dot(rd, normal)), 5.);\n    // Compute reflection\n    float t = (27. - p.y) / reflectdir.y;\n    vec3 hitpos = p + reflectdir * t;\n    vec2 tex = hitpos.xz/50.;\n    \n    // Unfortunately, I think the ternary operator branches.\n    vec4 reflectcolor = tex.y >= 1. || t <= 0.\n        ? sky\n        // This is the furthest you can possible get from PBR - I just picked it because it looks nice\n        // I don't want to do more raymarching so assume that secondary rays cannot be reflected\n        // Instead, they just go into the water and are therefore darkened.\n        // The further into the water they go the darker i guess\n        : mix(deepwater, texture(iChannel1, tex), smoothstep(-.3, 0., tex.y));\n    \n\tfragColor = mix(watercolor, reflectcolor, R);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define g 9.81\n#define sigma 0.072\n#define rho 998.\nconst float sr = sigma/rho;\n\n#define pi 3.1415926535\n\nfloat omega(float k) {\n    return sqrt(g*k + pow(k, 3.)*sr);\n}\n\nfloat cp(float k) {\n    return omega(k)/k;\n}\nfloat cg(float k) {\n    // = d omega / d k\n    return ( g + 3.*pow(k, 2.)*sr ) / (2. * omega(k));\n}\nfloat phi(float x, float s) {\n    return exp(-x*x/s/s);\n}\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\nconst float sample_period = 10.;\nconst float pw = 0.3;\nconst float height_scale = 0.1;\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n    // This change of coordinates just makes it easier to visualize the real space!\n    vec2 texSq = 10. * fragCoord / iResolution.xy;\n    \n    // Initiailize the space to a flat surface\n    float height = 0.;\n    vec2 grad = vec2(0);\n    // Compute the ripple history\n    float block = floor(iTime / sample_period);\n    float time_into_block = mod(iTime, sample_period);\n    for (float l = 0.; l < 20.; l += 1.) {\n        // Compute a whole bunch of random parameters\n        // We say this ripple started at time (block + random)\n        // Let there be rippled that started before the block\n        float t = time_into_block - random(vec2(l+block, l)) * sample_period + 3.;\n        // The wavenumber of this ripple -- maybe just make this a constant?\n\t\tfloat k = random(vec2(l, l+block)) * 20. + 20.;\n        vec2 pos = vec2(random(vec2(block, l)), random(vec2(l, block))) * vec2(10., 7.);\n        float x = length(texSq - pos);\n        // The height of this ripple\n        // Flatten out the \n        float a = (0.5 + random(vec2(l+block, -l))) * height_scale / pow(abs(t)+1.5, 2.);\n        // Done computing our random parameters. Time to compute the actual heightmap and derivative\n        float cgg = cg(k);\n        float packet = phi(x - cgg*t, pw);\n        \n        // If we're mostly outside the packet, don't bother computing its contribution \n        // Should result in a decent performance increase\n        // Unfortunately we still have to do all the hashing to compute the random variables\n        if (packet < 0.005)\n        \tcontinue;\n        \n        float cpp = cp(k);\n        float h = a*packet*cos(k*(x - cpp*t));\n        height += h;\n        // We also compute the derivative\n        float ddr = a*k*packet*sin(k*(x - cpp*t)) + 2.*(x - cgg*t)*h / pw / pw;\n        // This is d/dr.\n        // And here we can compute d/dx and d/dy\n        grad += normalize(texSq - pos) * ddr;\n        \n    }\n    vec3 normal = normalize(vec3(grad, 1));\n    // Pack the height and the normal to (0, 1)\n    fragColor = (vec4(height/10., normal) + vec4(1)) / 2.;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// This is the maximum mipmap of buffer A, the heightfield\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 d = 2. * vec3(1, 1, 0) / iResolution;\n    vec2 uv = fragCoord / iResolution.y;\n    \n    if (uv.x < 1.) {\n        // This will be the bilinear patch map\n        // Each pixel here represents four pixels from the heightmap\n        // But they're at the corners, so they overlap\n        // So bilinear patch layer is the same size as the real heightmap (minus one row and col?)\n        /*\t^\n\t\t\t| b a\n\t\t  y | r g\n\t\t\to ---> \n\t\t\t   x\n\t\t\t\n\t\t*/\n        fragColor = vec4(\n            texture(iChannel1, uv).r,\n            texture(iChannel1, uv + d.xz).r,\n            texture(iChannel1, uv + d.zy).r,\n            texture(iChannel1, uv + d.xy).r\n        );\n    }\n    else {\n        // Calculate the rest of the mipmaps\n        // Our mipmap level depends on the Y-coordinate.\n        // Level 0 is on the left\n        // Level 1 is 0-0.5\n        // Level 2 is .5-.75\n        float level = 1. - log2(1. - uv.y);\n        float level_width = pow(2., -floor(level));\n        vec2 tex = vec2(\n            (uv.x - 1.) / level_width,\n        \tfract(uv.y / level_width));\n        fragColor = vec4(tex, 0, 1);\n        // Compute the real location of tex on the next level down\n        vec2 next = level < 2. ? tex : uv * 2. - vec2(1);\n        next *= vec2(iResolution.y / iResolution.x, 1);\n        fragColor = vec4(next, 0, 1);\n        \n        vec4 tl = texture(iChannel0, next);\n        vec4 reads = level < 2.\n            // This is not quite correct --\n            // Level 1 should be the same size as level 0\n            // Maybe this approach isn't needed?\n            ? tl\n            : vec4(\n            \ttl.r,\n            \ttexture(iChannel0, next + d.xz).r,\n            \ttexture(iChannel0, next + d.zy).r,\n            \ttexture(iChannel0, next + d.xy).r);\n        float m = max(max(reads.x, reads.y), max(reads.z, reads.w));\n        fragColor = vec4(m);\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}