{"ver":"0.1","info":{"id":"NtKXWt","date":"1641513861","viewed":210,"name":"Aperture uniform distribution","username":"stduhpf","description":"I wanted to experiment with [url=https://www.shadertoy.com/view/7lGXWK]Uniform Random Showcase 2D [/url]'s code, by [url=https://www.shadertoy.com/user/harry7557558]harry7557558[/url], so I came up with this. It could be useful for physically-based DOF.","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["bokeh","distributions"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//code in bufferA\n//settings in common\n\nvec4 aperture_mechansim(float n,vec2 uv, float aperture){\n    if(length(uv)>1.)\n        return vec4(exp2(-dot(uv,uv)*2.));\n    float a2 = 2.*PI/n;\n    mat2 m2 = mat2(cos(a2),-sin(a2),sin(a2),cos(a2));\n    mat2 m = m2;\n    vec4 col = vec4(0);\n\n        \n    float arcLength = sin(PI/n);\n    float arcAngle = asin(aperture*arcLength);\n    \n\n    vec2 c = vec2(cos(arcAngle)-aperture * sqrt(1.-arcLength*arcLength),0);\n    if(fract(n*.5)<.5)\n        m*= mat2(cos(a2*.5),-sin(a2*.5),sin(a2*.5),cos(a2*.5));\n    for(float i=0.;i<SIDE_COUNT;i++){\n        vec2 p = uv*m;\n        vec2 np = p*m2;\n        if(distance(p,c)>=1. && distance(np,c)<=1.)\n            col = texture(iChannel1,p-c) * smoothstep(0.,-.05,distance(np,c)-1.);\n        \n        m *= m2;\n    }\n    \n    \n    return col*smoothstep(0.,-.05,length(uv)-1.);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n     fragColor = texture(iChannel0,uv);\n\n    const float N = STEPS;\n    const float M = 2.*N;\n    uv*=N;\n    \n    float index = dot(floor(uv),vec2(1,N));\n    vec2 uv2 = 2.*(fract(uv)-.5)*iResolution.xy/iResolution.y;\n    float aperture = (index+1.)/(N*N);\n\n    fragColor+=aperture_mechansim(SIDE_COUNT,uv2/SCALE,aperture);\n    \n    /*\n    if(iTime<.5*PI){\n        fragColor=aperture_mechansim(SIDE_COUNT,2.*(fract(uv/N)-.5)*iResolution.xy/iResolution.y,.5+.5*cos(iTime*4.));\n    }\n    */\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// massively inspired by harry7557558's Uniform Random Showcase 2D: https://www.shadertoy.com/view/7lGXWK\n// uniform distribution on a mechanical aperture, can be used to reproduce a physical camera's bokeh\n\n\nvec2 randAperture(float n, float aperture, float rand1, float rand2){\n    //basically a regular polygon with fixed-radius disc segments stuck to each edge\n\n    vec2 ret = vec2(0);\n    \n    float u = n*rand1;\n    \n    float ui = floor(u);  // index of triangle\n    float uf = fract(u);  // interpolating in triangle\n\n    \n    float triArea = 0.5*sin(2.*PI/n);\n    \n    float outerRad = 1./aperture;\n        \n    float arcLength = 2.*sin(PI/n);\n    float arcAngle = 2.*asin(arcLength/(2.*outerRad));\n    float segArea = (arcAngle-sin(arcAngle))*outerRad*outerRad/2.;\n    \n    \n    float v = rand2 * (segArea + triArea)/triArea;\n    \n    if(arcAngle<.102){\n        // when the arc is too small there is sometimes issues with precision,\n        // so we discard it and sample in polygon only (it won't make a big difference anyways)\n        v = rand2;\n    }\n    \n    if(v<=1.){\n        //the polygon part, from harry7557558\n        v=(v);\n        vec2 v0 = vec2(cos(2.*PI*ui/n), sin(2.*PI*ui/n));  // triangle edge #1\n        vec2 v1 = vec2(cos(2.*PI*(ui+1.)/n), sin(2.*PI*(ui+1.)/n));  // triangle edge #2\n        ret = sqrt(v) * mix(v0, v1, uf);  // sample inside triangle\n    }else{\n        //the disc segments part (modified from harry7557558's randIntersection)\n        v=((v-1.)*triArea/segArea);\n        u = uf;\n        float c = outerRad*cos(arcAngle/2.);\n        float r = outerRad;\n        \n        float x1 = sqrt(r*r-c*c);  // x range [-x1, x1]\n        float i1 = 0.5*r*r*asin(x1/r)+0.5*x1*sqrt(r*r-x1*x1)-c*x1;  // area under the curve from 0 t0 x1\n        u = 2.0*i1*u - i1;  // u = Integral[0,x1,sqrt(x^2+y^2-c)]\n        float x = 0.0;  // solve for the x-coordinate\n        for (int iter=0; iter<6; iter++) {  // Newton-Raphson\n            float cdf = 0.5*(r*r*asin(x/r)+x*sqrt(r*r-x*x))-c*x;\n            float pdf = sqrt(r*r-x*x)-c;\n            x -= (cdf-u)/pdf;\n        }\n        float y = (sqrt(r*r-x*x)-c) * v;  // y-coordinate\n        vec2 p =  vec2(x, y);\n\n        vec2 off = 1.*vec2(.5+cos(2.*PI/n)*.5,.5*sin(2.*PI/n));\n        float a =-PI*.5 + PI/n;\n        mat2 m1 = mat2(cos(a),-sin(a),sin(a),cos(a));\n        p = p*m1+off;\n        float a2 = 2.*PI*ui/n;\n        mat2 m2 = mat2(cos(a2),-sin(a2),sin(a2),cos(a2));\n        ret = p*m2;\n    }\n    return ret*aperture; //remove *aperture to get only the shape without scaling\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    const float N = STEPS;\n    const float M = 2.*N;\n    uv*=N;\n    \n    float index = dot(floor(uv),vec2(1,N));\n    vec2 uv2 = fract(uv)*iResolution.xy/N-iResolution.xy/M;\n    float aperture = (index+1.)/(N*N);\n\n    \n    if(iFrame == 0)\n        fragColor = vec4(0);\n    vec2 noise = fract((iTime*vec2(.01,(1.+sqrt(5.))/200.))+ // add changing float offset because of low texture bit depth\n                        texture(iChannel1,floor(float(iFrame)*vec2(1,1./iChannelResolution[1].x))/iChannelResolution[1].xy).xy);\n    vec2 p = SCALE*randAperture(SIDE_COUNT,aperture,noise.x,noise.y)*iResolution.y/M;\n    \n    if(distance(uv2,p)<1./sqrt(2.))\n        fragColor++;\n        //fragColor= texture(iChannel2,noise);\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n#define SIDE_COUNT 5.\n#define STEPS 4.\n#define SCALE .75\n\nconst float PI = acos(-1.);","name":"Common","description":"","type":"common"}]}