{"ver":"0.1","info":{"id":"XcfXWX","date":"1707732467","viewed":25,"name":"[inspirnathan] 04 - SDFop&shapes","username":"hrst4","description":"[inspirnathan] 04 - SDFop&shapes","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["inspirnathan"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This a french translation of the highly educational Nathan Vaughn's tutorials.\n// Un grand merci √† lui !\n// his website: https://inspirnathan.com/\n// original:\n//from https://inspirnathan.com/posts/51-shadertoy-tutorial-part-5\n\n#define PART 24\n/*\nSalutations, chers amis ! Dans ce tutoriel, j'expliquerai comment utiliser les op√©rations SDF 2D \npour cr√©er des formes plus complexes √† partir de formes primitives, \net comment dessiner d'autres formes 2D primitives, notamment des c≈ìurs et des √©toiles. \nJe vous aiderai √† utiliser cette liste de SDF 2D qui a √©t√© popularis√©e par le talentueux Inigo Quilez,\nl'un des co-cr√©ateurs de Shadertoy. C'est parti !\n\n# Combinaison d'op√©rations SDF 2D\n\nDans les tutoriels pr√©c√©dents, nous avons vu comment dessiner des formes 2D primitives\ntelles que des cercles et des carr√©s, mais nous pouvons utiliser les op√©rations SDF 2D pour cr√©er \ndes formes plus complexes en combinant des formes primitives.\n\nCommen√ßons par un code standard simple pour les formes 2D :\n*/\n\n#if PART == 1\nvec3 getBackgroundColor(vec2 uv) {\n  uv = uv * 0.5 + 0.5; // remap uv from <-0.5,0.5> to <0.25,0.75>\n  vec3 gradientStartColor = vec3(1., 0., 1.);\n  vec3 gradientEndColor = vec3(0., 1., 1.);\n  return mix(gradientStartColor, gradientEndColor, uv.y); // gradient goes from bottom to top\n}\n\nfloat sdCircle(vec2 uv, float r, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return length(vec2(x, y)) - r;\n}\n\nfloat sdSquare(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return max(abs(x), abs(y)) - size;\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = getBackgroundColor(uv);\n  float d1 = sdCircle(uv, 0.1, vec2(0., 0.));\n  float d2 = sdSquare(uv, 0.1, vec2(0.1, 0));\n\n  float res; // result\n  res = d1;\n\n  res = step(0., res); // Same as res > 0. ? 1. : 0.;\n\n  col = mix(vec3(1,0,0), col, res);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  fragColor = vec4(col,1.0); // Output to screen\n}\n\n/*\nNotez que j'utilise maintenant sdCircle pour le nom de la fonction au lieu de sdfCircle\n(qui √©tait utilis√© dans les tutoriels pr√©c√©dents).\nLe site web d'Inigo Quilez utilise g√©n√©ralement sd devant le nom de la forme, \nmais j'ai utilis√© sdf pour qu'il soit clair qu'il s'agit de champs de distance sign√©s (SDF).\n\nLorsque vous ex√©cutez le code, vous devriez voir un cercle rouge avec une couleur de fond d√©grad√©e,\nsimilaire √† ce que nous avons appris dans le tutoriel pr√©c√©dent.\n\nPr√™tez attention √† l'endroit o√π nous utilisons la fonction mix :\ncol = mix(vec3(1,0,0), col, res);\n\nCette ligne indique qu'il faut prendre le r√©sultat et choisir la couleur rouge \nou la valeur de col (actuellement la couleur de fond) en fonction de la valeur de res (le r√©sultat).\n\nExaminons maintenant les diff√©rentes op√©rations SDF qui peuvent √™tre effectu√©es.\nNous allons examiner l'interaction entre un cercle et un carr√©.\n\n\n*/\n\n// Union : combiner deux formes ensemble.\n#elif PART == 2 \nvec3 getBackgroundColor(vec2 uv) {\n  uv = uv * 0.5 + 0.5; // remap uv from <-0.5,0.5> to <0.25,0.75>\n  vec3 gradientStartColor = vec3(1., 0., 1.);\n  vec3 gradientEndColor = vec3(0., 1., 1.);\n  return mix(gradientStartColor, gradientEndColor, uv.y); // gradient goes from bottom to top\n}\n\nfloat sdCircle(vec2 uv, float r, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return length(vec2(x, y)) - r;\n}\n\nfloat sdSquare(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return max(abs(x), abs(y)) - size;\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = getBackgroundColor(uv);\n  float d1 = sdCircle(uv, 0.1, vec2(0., 0.));\n  float d2 = sdSquare(uv, 0.1, vec2(0.1, 0));\n\n  float res; // result\n  res = min(d1, d2); // union\n\n  res = step(0., res); // Same as res > 0. ? 1. : 0.;\n\n  col = mix(vec3(1,0,0), col, res);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  fragColor = vec4(col,1.0); // Output to screen\n}\n//Soustraction : soustraire d1 de d2.\n#elif PART == 3 \n\nvec3 getBackgroundColor(vec2 uv) {\n  uv = uv * 0.5 + 0.5; // remap uv from <-0.5,0.5> to <0.25,0.75>\n  vec3 gradientStartColor = vec3(1., 0., 1.);\n  vec3 gradientEndColor = vec3(0., 1., 1.);\n  return mix(gradientStartColor, gradientEndColor, uv.y); // gradient goes from bottom to top\n}\n\nfloat sdCircle(vec2 uv, float r, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return length(vec2(x, y)) - r;\n}\n\nfloat sdSquare(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return max(abs(x), abs(y)) - size;\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = getBackgroundColor(uv);\n  float d1 = sdCircle(uv, 0.1, vec2(0., 0.));\n  float d2 = sdSquare(uv, 0.1, vec2(0.1, 0));\n\n  float res; // result\n  res = max(d1, d2); // subtraction - subtract d1 from d2\n\n  res = step(0., res); // Same as res > 0. ? 1. : 0.;\n\n  col = mix(vec3(1,0,0), col, res);\n  return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  fragColor = vec4(col,1.0); // Output to screen\n}\n\n//Soustraction : soustraire d2 de d1.\n#elif PART == 4 \n\nvec3 getBackgroundColor(vec2 uv) {\n  uv = uv * 0.5 + 0.5; // remap uv from <-0.5,0.5> to <0.25,0.75>\n  vec3 gradientStartColor = vec3(1., 0., 1.);\n  vec3 gradientEndColor = vec3(0., 1., 1.);\n  return mix(gradientStartColor, gradientEndColor, uv.y); // gradient goes from bottom to top\n}\n\nfloat sdCircle(vec2 uv, float r, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return length(vec2(x, y)) - r;\n}\n\nfloat sdSquare(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return max(abs(x), abs(y)) - size;\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = getBackgroundColor(uv);\n  float d1 = sdCircle(uv, 0.1, vec2(0., 0.));\n  float d2 = sdSquare(uv, 0.1, vec2(0.1, 0));\n\n  float res; // result\n  res = max(-d1, d2); // subtraction - subtract d1 from d2\n\n  res = step(0., res); // Same as res > 0. ? 1. : 0.;\n\n  col = mix(vec3(1,0,0), col, res);\n  return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  fragColor = vec4(col,1.0); // Output to screen\n}\n\n// XOR : une op√©ration \"OR\" exclusive prend les parties des deux formes qui ne se croisent pas.\n#elif PART == 5 \n\nvec3 getBackgroundColor(vec2 uv) {\n  uv = uv * 0.5 + 0.5; // remap uv from <-0.5,0.5> to <0.25,0.75>\n  vec3 gradientStartColor = vec3(1., 0., 1.);\n  vec3 gradientEndColor = vec3(0., 1., 1.);\n  return mix(gradientStartColor, gradientEndColor, uv.y); // gradient goes from bottom to top\n}\n\nfloat sdCircle(vec2 uv, float r, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return length(vec2(x, y)) - r;\n}\n\nfloat sdSquare(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return max(abs(x), abs(y)) - size;\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = getBackgroundColor(uv);\n  float d1 = sdCircle(uv, 0.1, vec2(0., 0.));\n  float d2 = sdSquare(uv, 0.1, vec2(0.1, 0));\n\n  float res; // result\n  res = max(min(d1, d2), -max(d1, d2)); // xor\n\n  res = step(0., res); // Same as res > 0. ? 1. : 0.;\n\n  col = mix(vec3(1,0,0), col, res);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  fragColor = vec4(col,1.0); // Output to screen\n}\n\n/*\nNous pouvons √©galement cr√©er des op√©rations SDF 2D \"smooth\" qui m√©langent en douceur les \nbords autour de l'endroit o√π les formes se rencontrent.\nCes op√©rations s'appliquent davantage aux formes 3D, mais elles fonctionnent √©galement en 2D !\n\nAjoutez les fonctions suivantes au d√©but de votre code :\n// smooth min\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// smooth max\nfloat smax(float a, float b, float k) {\n  return -smin(-a, -b, k);\n}\n\n\nUnion lisse : combiner deux formes ensemble, mais estomper les bords √† l'endroit o√π ils se rencontrent.\n\n*/\n\n#elif PART == 6 \n// smooth min\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// smooth max\nfloat smax(float a, float b, float k) {\n  return -smin(-a, -b, k);\n}\n\n\nvec3 getBackgroundColor(vec2 uv) {\n  uv = uv * 0.5 + 0.5; // remap uv from <-0.5,0.5> to <0.25,0.75>\n  vec3 gradientStartColor = vec3(1., 0., 1.);\n  vec3 gradientEndColor = vec3(0., 1., 1.);\n  return mix(gradientStartColor, gradientEndColor, uv.y); // gradient goes from bottom to top\n}\n\nfloat sdCircle(vec2 uv, float r, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return length(vec2(x, y)) - r;\n}\n\nfloat sdSquare(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return max(abs(x), abs(y)) - size;\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = getBackgroundColor(uv);\n  float d1 = sdCircle(uv, 0.1, vec2(0., 0.));\n  float d2 = sdSquare(uv, 0.1, vec2(0.1, 0));\n\n  float res; // result\n  res = smin(d1, d2, 0.05); // smooth union\n\n  res = step(0., res); // Same as res > 0. ? 1. : 0.;\n\n  col = mix(vec3(1,0,0), col, res);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  fragColor = vec4(col,1.0); // Output to screen\n}\n\n/*\nIntersection lisse : ne prenez que les deux parties o√π les deux formes se croisent,\nmais estompez les bords √† l'endroit o√π ils se rencontrent.\n*/\n\n#elif PART == 7 \n// smooth min\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// smooth max\nfloat smax(float a, float b, float k) {\n  return -smin(-a, -b, k);\n}\n\n\nvec3 getBackgroundColor(vec2 uv) {\n  uv = uv * 0.5 + 0.5; // remap uv from <-0.5,0.5> to <0.25,0.75>\n  vec3 gradientStartColor = vec3(1., 0., 1.);\n  vec3 gradientEndColor = vec3(0., 1., 1.);\n  return mix(gradientStartColor, gradientEndColor, uv.y); // gradient goes from bottom to top\n}\n\nfloat sdCircle(vec2 uv, float r, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return length(vec2(x, y)) - r;\n}\n\nfloat sdSquare(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return max(abs(x), abs(y)) - size;\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = getBackgroundColor(uv);\n  float d1 = sdCircle(uv, 0.1, vec2(0., 0.));\n  float d2 = sdSquare(uv, 0.1, vec2(0.1, 0));\n\n  float res; // result\n  res = smax(d1, d2, 0.05); // smooth intersection\n\n  res = step(0., res); // Same as res > 0. ? 1. : 0.;\n\n  col = mix(vec3(1,0,0), col, res);\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  fragColor = vec4(col,1.0); // Output to screen\n}\n\n/*\nOp√©rations positionnelles 2D SDF\n\nLa page SDF 3D d'Inigo Quilez d√©crit un ensemble d'op√©rations SDF 3D positionnelles,\nmais ces op√©rations peuvent √©galement √™tre utilis√©es en 2D. \nJ'aborde les op√©rations SDF 3D plus loin, dans la partie 14.\n\nDans ce tutoriel, je vais passer en revue les op√©rations SDF 2D positionnelles qui peuvent nous aider\n√† gagner du temps et √† am√©liorer les performances lorsque nous dessinons des formes 2D.\n\nSi vous dessinez une sc√®ne sym√©trique, il peut √™tre utile d'utiliser l'op√©ration opSymX.\nCette op√©ration cr√©e une forme 2D dupliqu√©e le long de l'axe x √† l'aide du SDF que vous avez fourni.\nSi nous dessinons un cercle avec un d√©calage de vec2(0,2, 0), \nun cercle √©quivalent sera dessin√© √† vec2(-0,2, 0).\n*/\n\n#elif PART == 8 \n// smooth min\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// smooth max\nfloat smax(float a, float b, float k) {\n  return -smin(-a, -b, k);\n}\n\n\n\n\nvec3 getBackgroundColor(vec2 uv) {\n  uv = uv * 0.5 + 0.5; // remap uv from <-0.5,0.5> to <0.25,0.75>\n  vec3 gradientStartColor = vec3(1., 0., 1.);\n  vec3 gradientEndColor = vec3(0., 1., 1.);\n  return mix(gradientStartColor, gradientEndColor, uv.y); // gradient goes from bottom to top\n}\n\nfloat sdCircle(vec2 uv, float r, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return length(vec2(x, y)) - r;\n}\n\nfloat opSymX(vec2 p, float r)\n{\n  p.x = abs(p.x);\n  return sdCircle(p, r, vec2(0.2, 0));\n}\n\nfloat sdSquare(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return max(abs(x), abs(y)) - size;\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = getBackgroundColor(uv);\n\n  float res; // result\n  res = opSymX(uv, 0.1);\n\n  res = step(0., res);\n  col = mix(vec3(1,0,0), col, res);\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  fragColor = vec4(col,1.0); // Output to screen\n}\n\n/*\nNous pouvons √©galement effectuer une op√©ration similaire sur l'axe des ordonn√©es. \nEn utilisant l'op√©ration opSymY, si nous dessinons un cercle avec un d√©calage de vec2(0, 0,2),\nun cercle √©quivalent sera dessin√© √† vec2(0, -0,2).\n*/\n\n#elif PART == 9 \n// smooth min\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// smooth max\nfloat smax(float a, float b, float k) {\n  return -smin(-a, -b, k);\n}\n\nvec3 getBackgroundColor(vec2 uv) {\n  uv = uv * 0.5 + 0.5; // remap uv from <-0.5,0.5> to <0.25,0.75>\n  vec3 gradientStartColor = vec3(1., 0., 1.);\n  vec3 gradientEndColor = vec3(0., 1., 1.);\n  return mix(gradientStartColor, gradientEndColor, uv.y); // gradient goes from bottom to top\n}\n\nfloat sdCircle(vec2 uv, float r, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return length(vec2(x, y)) - r;\n}\n\nfloat opSymX(vec2 p, float r)\n{\n  p.x = abs(p.x);\n  return sdCircle(p, r, vec2(0.2, 0));\n}\n\nfloat opSymY(vec2 p, float r)\n{\n  p.y = abs(p.y);\n  return sdCircle(p, r, vec2(0, 0.2));\n}\n\nfloat sdSquare(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return max(abs(x), abs(y)) - size;\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = getBackgroundColor(uv);\n\n  float res; // result\n  res = opSymY(uv, 0.1);\n\n  res = step(0., res);\n  col = mix(vec3(1,0,0), col, res);\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  fragColor = vec4(col,1.0); // Output to screen\n}\n\n/*\nSi vous souhaitez dessiner des cercles le long de deux axes au lieu d'un seul, \nvous pouvez utiliser l'op√©ration opSymXY. \nCette op√©ration cr√©e un double le long de l'axe x et de l'axe y, ce qui donne quatre cercles. \nSi nous dessinons un cercle avec un d√©calage de vec2(0,2, 0), un cercle sera dessin√© √† \nvec2(0,2, 0,2), vec2(0,2, -0,2), vec2(-0,2, -0,2) et vec2(-0,2, 0,2).\n*/\n\n#elif PART == 10 \n// smooth min\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// smooth max\nfloat smax(float a, float b, float k) {\n  return -smin(-a, -b, k);\n}\n\nvec3 getBackgroundColor(vec2 uv) {\n  uv = uv * 0.5 + 0.5; // remap uv from <-0.5,0.5> to <0.25,0.75>\n  vec3 gradientStartColor = vec3(1., 0., 1.);\n  vec3 gradientEndColor = vec3(0., 1., 1.);\n  return mix(gradientStartColor, gradientEndColor, uv.y); // gradient goes from bottom to top\n}\n\nfloat sdCircle(vec2 uv, float r, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return length(vec2(x, y)) - r;\n}\n\nfloat opSymX(vec2 p, float r)\n{\n  p.x = abs(p.x);\n  return sdCircle(p, r, vec2(0.2, 0));\n}\n\nfloat opSymY(vec2 p, float r)\n{\n  p.y = abs(p.y);\n  return sdCircle(p, r, vec2(0, 0.2));\n}\n\nfloat opSymXY(vec2 p, float r)\n{\n  p = abs(p);\n  return sdCircle(p, r, vec2(0.2));\n}\n\nfloat sdSquare(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return max(abs(x), abs(y)) - size;\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = getBackgroundColor(uv);\n\n  float res; // result\n  res = opSymXY(uv, 0.1);\n\n  res = step(0., res);\n  col = mix(vec3(1,0,0), col, res);\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  fragColor = vec4(col,1.0); // Output to screen\n}\n\n/*\nIl peut arriver que vous souhaitiez cr√©er un nombre infini d'objets 2D sur un ou plusieurs axes.\nVous pouvez utiliser l'op√©ration opRep pour r√©p√©ter des cercles le long des axes de votre choix. \nLe param√®tre c est un vecteur utilis√© pour contr√¥ler l'espacement entre les objets 2D le long de chaque axe.\n*/\n\n#elif PART == 11 \n// smooth min\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// smooth max\nfloat smax(float a, float b, float k) {\n  return -smin(-a, -b, k);\n}\n\nvec3 getBackgroundColor(vec2 uv) {\n  uv = uv * 0.5 + 0.5; // remap uv from <-0.5,0.5> to <0.25,0.75>\n  vec3 gradientStartColor = vec3(1., 0., 1.);\n  vec3 gradientEndColor = vec3(0., 1., 1.);\n  return mix(gradientStartColor, gradientEndColor, uv.y); // gradient goes from bottom to top\n}\n\nfloat sdCircle(vec2 uv, float r, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return length(vec2(x, y)) - r;\n}\n\nfloat opSymX(vec2 p, float r)\n{\n  p.x = abs(p.x);\n  return sdCircle(p, r, vec2(0.2, 0));\n}\n\nfloat opSymY(vec2 p, float r)\n{\n  p.y = abs(p.y);\n  return sdCircle(p, r, vec2(0, 0.2));\n}\n\nfloat opSymXY(vec2 p, float r)\n{\n  p = abs(p);\n  return sdCircle(p, r, vec2(0.2));\n}\n\nfloat opRep(vec2 p, float r, vec2 c)\n{\n  vec2 q = mod(p+0.5*c,c)-0.5*c;\n  return sdCircle(q, r, vec2(0));\n}\n\nfloat sdSquare(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return max(abs(x), abs(y)) - size;\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = getBackgroundColor(uv);\n\n  float res; // result\n  res = opRep(uv, 0.05, vec2(0.2, 0.2));\n\n  res = step(0., res);\n  col = mix(vec3(1,0,0), col, res);\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  fragColor = vec4(col,1.0); // Output to screen\n}\n\n/*\nSi vous souhaitez r√©p√©ter les objets 2D seulement un certain nombre de fois au lieu d'un nombre infini,\nvous pouvez utiliser l'op√©ration opRepLim. \n\nLe param√®tre c est maintenant une valeur flottante et contr√¥le toujours l'espacement entre chaque objet 2D\nr√©p√©t√©. \nLe param√®tre l est un vecteur qui vous permet de contr√¥ler combien de fois la forme doit √™tre r√©p√©t√©e \nle long d'un axe donn√©. \nPar exemple, une valeur de vec2(2, 2) dessine un cercle suppl√©mentaire le long des axes x et y positif\net n√©gatif.\n*/\n\n#elif PART == 12 \n// smooth min\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// smooth max\nfloat smax(float a, float b, float k) {\n  return -smin(-a, -b, k);\n}\n\nvec3 getBackgroundColor(vec2 uv) {\n  uv = uv * 0.5 + 0.5; // remap uv from <-0.5,0.5> to <0.25,0.75>\n  vec3 gradientStartColor = vec3(1., 0., 1.);\n  vec3 gradientEndColor = vec3(0., 1., 1.);\n  return mix(gradientStartColor, gradientEndColor, uv.y); // gradient goes from bottom to top\n}\n\nfloat sdCircle(vec2 uv, float r, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return length(vec2(x, y)) - r;\n}\n\nfloat opSymX(vec2 p, float r)\n{\n  p.x = abs(p.x);\n  return sdCircle(p, r, vec2(0.2, 0));\n}\n\nfloat opSymY(vec2 p, float r)\n{\n  p.y = abs(p.y);\n  return sdCircle(p, r, vec2(0, 0.2));\n}\n\nfloat opSymXY(vec2 p, float r)\n{\n  p = abs(p);\n  return sdCircle(p, r, vec2(0.2));\n}\n\nfloat opRep(vec2 p, float r, vec2 c)\n{\n  vec2 q = mod(p+0.5*c,c)-0.5*c;\n  return sdCircle(q, r, vec2(0));\n}\n\nfloat opRepLim(vec2 p, float r, float c, vec2 l)\n{\n  vec2 q = p-c*clamp(round(p/c),-l,l);\n  return sdCircle(q, r, vec2(0));\n}\n\nfloat sdSquare(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return max(abs(x), abs(y)) - size;\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = getBackgroundColor(uv);\n\n  float res; // result\n  res = opRepLim(uv, 0.05, 0.15, vec2(2, 2));\n\n  res = step(0., res);\n  col = mix(vec3(1,0,0), col, res);\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  fragColor = vec4(col,1.0); // Output to screen\n}\n\n/*\nVous pouvez √©galement d√©former ou distordre un SDF en manipulant la valeur de p,\nla coordonn√©e uv, et en l'ajoutant √† la valeur renvoy√©e par un SDF.\nDans l'op√©ration opDisplace, vous pouvez cr√©er n'importe quel type d'op√©ration math√©matique\npour d√©placer la valeur de p, puis ajouter ce r√©sultat √† la valeur originale renvoy√©e par un SDF.\n*/\n\n#elif PART == 13 \n// smooth min\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// smooth max\nfloat smax(float a, float b, float k) {\n  return -smin(-a, -b, k);\n}\n\nvec3 getBackgroundColor(vec2 uv) {\n  uv = uv * 0.5 + 0.5; // remap uv from <-0.5,0.5> to <0.25,0.75>\n  vec3 gradientStartColor = vec3(1., 0., 1.);\n  vec3 gradientEndColor = vec3(0., 1., 1.);\n  return mix(gradientStartColor, gradientEndColor, uv.y); // gradient goes from bottom to top\n}\n\nfloat sdCircle(vec2 uv, float r, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return length(vec2(x, y)) - r;\n}\n\nfloat opSymX(vec2 p, float r)\n{\n  p.x = abs(p.x);\n  return sdCircle(p, r, vec2(0.2, 0));\n}\n\nfloat opSymY(vec2 p, float r)\n{\n  p.y = abs(p.y);\n  return sdCircle(p, r, vec2(0, 0.2));\n}\n\nfloat opSymXY(vec2 p, float r)\n{\n  p = abs(p);\n  return sdCircle(p, r, vec2(0.2));\n}\n\nfloat opRep(vec2 p, float r, vec2 c)\n{\n  vec2 q = mod(p+0.5*c,c)-0.5*c;\n  return sdCircle(q, r, vec2(0));\n}\n\nfloat opRepLim(vec2 p, float r, float c, vec2 l)\n{\n  vec2 q = p-c*clamp(round(p/c),-l,l);\n  return sdCircle(q, r, vec2(0));\n}\n\nfloat opDisplace(vec2 p, float r)\n{\n  float d1 = sdCircle(p, r, vec2(0));\n  float s = 0.5; // scaling factor\n\n  float d2 = sin(s * p.x * 1.8); // Some arbitrary values I played around with\n\n  return d1 + d2;\n}\n\nfloat sdSquare(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return max(abs(x), abs(y)) - size;\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = getBackgroundColor(uv);\n\n  float res; // result\n  res = opDisplace(uv, 0.1); // Kinda looks like an egg\n\n  res = step(0., res);\n  col = mix(vec3(1,0,0), col, res);\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  fragColor = vec4(col,1.0); // Output to screen\n}\n\n/*\n# Anti-aliasing\n\nSi vous souhaitez ajouter un anticr√©nelage, vous pouvez utiliser la fonction smoothstep \npour lisser les bords de vos formes. La fonction smoothstep(edge0, edge1, x) \naccepte trois param√®tres et effectue une interpolation d'Hermite entre z√©ro et un lorsque edge0 < x < edge1 .\n\nedge0: Specifies the value of the lower edge of the Hermite function.\nedge1: Specifies the value of the upper edge of the Hermite function.\nx: Specifies the source value for interpolation.\nt = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\nreturn t * t * (3.0 - 2.0 * t);\n\n## TIP\nLa documentation indique que si le edge0 est sup√©rieur ou √©gal au edge1, la fonction smoothstep \nrenvoie une valeur ind√©finie. Cependant, cela est incorrect. \nLe r√©sultat de la fonction smoothstep est toujours d√©termin√© par la fonction d'interpolation Hermite, \nm√™me si le edge0 est sup√©rieur au edge1.\n\nSi vous n'√™tes toujours pas convaincu, cette page du Book of Shaders peut vous aider √† visualiser \nla fonction smoothstep.\nEssentiellement, elle se comporte comme la fonction step avec quelques √©tapes suppl√©mentaires \n(sans jeu de mots)\n\nRempla√ßons la fonction step par la fonction smoothstep pour voir comment se comporte\nle r√©sultat entre l'union d'un cercle et d'un carr√©.\n*/\n#elif PART == 14\n\nvec3 getBackgroundColor(vec2 uv) {\n  uv = uv * 0.5 + 0.5; // remap uv from <-0.5,0.5> to <0.25,0.75>\n  vec3 gradientStartColor = vec3(1., 0., 1.);\n  vec3 gradientEndColor = vec3(0., 1., 1.);\n  return mix(gradientStartColor, gradientEndColor, uv.y); // gradient goes from bottom to top\n}\n\nfloat sdCircle(vec2 uv, float r, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return length(vec2(x, y)) - r;\n}\n\nfloat sdSquare(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return max(abs(x), abs(y)) - size;\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = getBackgroundColor(uv);\n  float d1 = sdCircle(uv, 0.1, vec2(0., 0.));\n  float d2 = sdSquare(uv, 0.1, vec2(0.1, 0));\n\n  float res; // result\n  res = min(d1, d2); // union\n\n  res = smoothstep(0., 0.02, res); // antialias entire result\n\n  col = mix(vec3(1,0,0), col, res);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  fragColor = vec4(col,1.0); // Output to screen\n}\n\n/*\nNous obtenons une forme dont les bords sont l√©g√®rement flous.\n\nLa fonction smoothstep nous aide √† cr√©er des transitions douces entre les couleurs,\nce qui est utile pour mettre en ≈ìuvre l'anticr√©nelage.\nVous pouvez √©galement voir des personnes utiliser la fonction smoothstep pour cr√©er des objets \n√©missifs ou des effets de lueur n√©on. Elle est tr√®s souvent utilis√©e dans les shaders.\n*/\n\n/*\n# Dessiner un coeur\n\nDans cette section, je vais vous apprendre √† dessiner un c≈ìur √† l'aide de Shadertoy.\nGardez √† l'esprit qu'il existe plusieurs styles de coeurs. \nJe vous montrerai comment cr√©er un seul style de c≈ìur en utilisant une √©quation de Wolfram MathWorld.\nhttps://inspirnathan.com/_nuxt/img/img-16.8143671.png\nSi nous voulons appliquer un d√©calage √† cette courbe de coeur, \nnous devons le soustraire de la composante x et de la composante y avant de leur appliquer\ntoute sorte d'op√©ration (telle que l'exponentiation).\n\ns = x - offsetX\nt = y - offsetY\n\n(s^2 + t^2 - 1)^3 - s^2 * t^3 = 0\n\nx = x-coordinate on graph\ny = y-coordinate on graph\n\nVous pouvez jouer avec les d√©calages sur une courbe de c≈ìur en utilisant le graphique que j'ai cr√©√© sur Desmos.\n\nMaintenant, comment cr√©er un SDF pour un coeur dans Shadertoy ? \nIl suffit de mettre le c√¥t√© gauche (LHS) de l'√©quation √©gal √† la distance, d. \nEnsuite, il s'agit du m√™me processus que celui que nous avons appris dans la partie 4.\n\n*/\n\n#elif PART == 15\n\nfloat sdHeart(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n  float xx = x * x;\n  float yy = y * y;\n  float yyy = yy * y;\n  float group = xx + yy - size;\n  float d = group * group * group - xx * yyy;\n  \n  return d;\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = vec3(1);\n  float heart = sdHeart(uv, 0.05, vec2(0.,-.2));\n\n  col = mix(vec3(1, 0, 0), col, step(0., heart));\n\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  // Output to screen\n  fragColor = vec4(col,1.0);\n}\n\n/*\nVous pouvez jouer avec les d√©calages sur une courbe de coeur en utilisant le graphique que j'ai cr√©√© sur Desmos.\nhttps://www.desmos.com/calculator/1ihio0t4bb\n\n# Comprendre la fonction pow\n\nVous vous demandez peut-√™tre pourquoi j'ai cr√©√© la fonction sdHeart d'une mani√®re aussi bizarre. \nPourquoi ne pas utiliser la fonction pow qui est √† notre disposition ? \nLa fonction pow(x,y) prend une valeur, x, et l'√©l√®ve √† la puissance de y.\n\nSi vous essayez d'utiliser la fonction pow, vous verrez tout de suite √† quel point le c≈ìur\nse comporte bizarrement.\n*/\n\n#elif PART == 16\n\nfloat sdHeart(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n  float group = pow(x,2.) + pow(y,2.) - size;\n  float d = pow(group,3.) - pow(x,2.) * pow(y,3.);\n\n  return d;\n}\n\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = vec3(1);\n  float heart = sdHeart(uv, 0.05, vec2(0.,-.2));\n\n  col = mix(vec3(1, 0, 0), col, step(0., heart));\n\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  // Output to screen\n  fragColor = vec4(col,1.0);\n}\n\n/*\n√áa n'a pas l'air correct ü§î. \nSi vous envoyez cela √† quelqu'un le jour de la Saint-Valentin, il pourrait penser qu'il s'agit\nd'un test de tache d'encre.\n\nPourquoi la fonction pow(x,y) se comporte-t-elle de mani√®re si √©trange ?\nSi vous regardez de plus pr√®s la documentation de cette fonction, vous verrez qu'elle renvoie une\nvaleur ind√©finie si x est inf√©rieur √† z√©ro ou si x est √©gal √† z√©ro et si y est inf√©rieur ou √©gal √† z√©ro.\n\nGardez √† l'esprit que l'impl√©mentation de la fonction pow varie en fonction du compilateur \net du mat√©riel, il se peut donc que vous ne rencontriez pas ce probl√®me lorsque vous d√©veloppez\ndes shaders pour d'autres plateformes en dehors de Shadertoy, ou que vous rencontriez d'autres probl√®mes.\n\nComme notre syst√®me de coordonn√©es est configur√© pour avoir des valeurs n√©gatives pour x et y, \nnous obtenons parfois des valeurs ind√©finies √† la suite de l'utilisation de la fonction pow.\nDans Shadertoy, le compilateur utilisera undefined dans les op√©rations math√©matiques,\nce qui entra√Ænera des r√©sultats confus.\n\nNous pouvons exp√©rimenter le comportement de undefined avec diff√©rentes op√©rations \narithm√©tiques en d√©boguant le canevas √† l'aide de la couleur. Essayons d'ajouter un nombre √† undefined :\n(...)\n\nD'apr√®s les observations que nous avons recueillies, nous pouvons conclure que undefined \nest trait√© comme une valeur de z√©ro lorsqu'il est utilis√© dans des op√©rations arithm√©tiques.\n\nCependant, cela peut encore varier en fonction du compilateur et du mat√©riel graphique.\nPar cons√©quent, vous devez faire attention √† la mani√®re dont vous utilisez la fonction pow\ndans votre code shader.\n\nSi vous souhaitez √©lever une valeur au carr√©, une astuce courante consiste √† utiliser \nla fonction dot pour calculer le produit de points entre un vecteur et lui-m√™me. \nCela nous permet de r√©√©crire la fonction sdHeart pour qu'elle soit un peu plus propre :\n\nfloat sdHeart(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n  float group = dot(x,x) + dot(y,y) - size;\n  float d = group * dot(group, group) - dot(x,x) * dot(y,y) * y;\n  \n  return d;\n}\n\nAppeler dot(x,x) revient √† √©lever au carr√© la valeur de x,\nmais vous n'avez pas √† vous pr√©occuper des probl√®mes de la fonction pow.\n\n# Utilisation du SDF sdStar5\n\nInigo Quilez a cr√©√© de nombreux SDF 2D et SDF 3D que les d√©veloppeurs de Shadertoy utilisent. \nDans cette section, je vais voir comment nous pouvons utiliser sa liste de SDF 2D \navec les techniques que nous avons apprises dans la partie 4 de ma s√©rie Shadertoy\npour dessiner des formes 2D.\n\nLorsque l'on cr√©e des formes √† l'aide de SDF, on les appelle commun√©ment des \"primitives\"\ncar elles constituent les √©l√©ments de base pour cr√©er des formes plus abstraites.\nEn 2D, il est assez simple de dessiner des formes sur le canevas, mais cela deviendra\nplus complexe lorsque nous aborderons les formes 3D.\n\nEntra√Ænons-nous avec une √©toile SDF, parce que dessiner des √©toiles, \nc'est toujours amusant. \nNaviguez sur le site d'Inigo Quilez et descendez jusqu'au FSD appel√© \"√âtoile 5 - exacte\".\nIl devrait avoir la d√©finition suivante :\n\nfloat sdStar5(in vec2 p, in float r, in float rf)\n{\n  const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n  const vec2 k2 = vec2(-k1.x,k1.y);\n  p.x = abs(p.x);\n  p -= 2.0*max(dot(k1,p),0.0)*k1;\n  p -= 2.0*max(dot(k2,p),0.0)*k2;\n  p.x = abs(p.x);\n  p.y -= r;\n  vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n  float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n  return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nNe vous pr√©occupez pas des qualificatifs in dans la fonction. \nVous pouvez les supprimer si vous le souhaitez, car in est le qualificatif\npar d√©faut si aucun n'est sp√©cifi√©.\n\nCr√©ons un nouveau shader Shadertoy avec le code suivant :\n\n\n*/\n\n#elif PART == 17\n\nfloat sdStar5(in vec2 p, in float r, in float rf)\n{\n  const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n  const vec2 k2 = vec2(-k1.x,k1.y);\n  p.x = abs(p.x);\n  p -= 2.0*max(dot(k1,p),0.0)*k1;\n  p -= 2.0*max(dot(k2,p),0.0)*k2;\n  p.x = abs(p.x);\n  p.y -= r;\n  vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n  float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n  return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = vec3(0);\n  float star = sdStar5(uv, 0.16, 0.50);\n  \n  col = mix(vec3(1, 1, 0), col, step(0., star));\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  // Output to screen\n  fragColor = vec4(col,1.0);\n}\n\n/*\nIl manque cependant une chose. Nous devons ajouter un offset au d√©but de la fonction sdStar5 \nen d√©calant l√©g√®rement les coordonn√©es UV. \nNous pouvons ajouter un nouveau param√®tre appel√© offset, et nous pouvons soustraire cet offset du vecteur, p,\nqui repr√©sente les coordonn√©es UV que nous avons pass√©es dans cette fonction.\n\nNotre code fini devrait ressembler √† ceci :\n\n*/\n\n#elif PART == 18\nfloat sdStar5(in vec2 p, in float r, in float rf, vec2 offset)\n{\n  p -= offset; // This will subtract offset.x from p.x and subtract offset.y from p.y\n  const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n  const vec2 k2 = vec2(-k1.x,k1.y);\n  p.x = abs(p.x);\n  p -= 2.0*max(dot(k1,p),0.0)*k1;\n  p -= 2.0*max(dot(k2,p),0.0)*k2;\n  p.x = abs(p.x);\n  p.y -= r;\n  vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n  float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n  return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = vec3(0);\n  float star = sdStar5(uv, 0.12, 0.45, vec2(0.2, 0)); // Add an offset to shift the star's position\n  \n  col = mix(vec3(1, 1, 0), col, step(0., star));\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  // Output to screen\n  fragColor = vec4(col,1.0);\n}\n\n/*\n# Utilisation du SDF sdBox\nIl est assez courant de dessiner des bo√Ætes/rectangles,\nnous allons donc s√©lectionner le SDF intitul√© \"Bo√Æte - exacte\". Sa d√©finition est la suivante :\nfloat sdBox( in vec2 p, in vec2 b )\n{\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nNous ajouterons un param√®tre offset √† la d√©claration de la fonction.\n\nfloat sdBox( in vec2 p, in vec2 b, vec2 offset )\n{\n  p -= offset;\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nMaintenant, nous devrions √™tre en mesure de rendre la bo√Æte et l'√©toile sans aucun probl√®me :\n\n*/\n#elif PART == 19\n\nfloat sdBox( in vec2 p, in vec2 b, vec2 offset )\n{\n  p -= offset;\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdStar5(in vec2 p, in float r, in float rf, vec2 offset)\n{\n  p -= offset; // This will subtract offset.x from p.x and subtract offset.y from p.y\n  const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n  const vec2 k2 = vec2(-k1.x,k1.y);\n  p.x = abs(p.x);\n  p -= 2.0*max(dot(k1,p),0.0)*k1;\n  p -= 2.0*max(dot(k2,p),0.0)*k2;\n  p.x = abs(p.x);\n  p.y -= r;\n  vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n  float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n  return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = vec3(0);\n  float box = sdBox(uv, vec2(0.2, 0.1), vec2(-0.2, 0));\n  float star = sdStar5(uv, 0.12, 0.45, vec2(0.2, 0));\n  \n  col = mix(vec3(1, 1, 0), col, step(0., star));\n  col = mix(vec3(0, 0, 1), col, step(0., box));\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  // Output to screen\n  fragColor = vec4(col,1.0);\n}\n\n/*\nAvec seulement quelques petites modifications, nous pouvons choisir de nombreux SDF 2D \nsur le site web d'Inigo Quilez et les dessiner sur le canevas avec un d√©calage.\n\nNotez cependant que certains SDF n√©cessitent des fonctions d√©finies sur la page SDF 3D \ndu site d'Inigo Quilez :\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n# Utilisation du SDF sdSegment\n\nCertains des SDF 2D figurant sur le site web d'Inigo Quilez concernent des segments ou des courbes, \nde sorte que nous devrons peut-√™tre modifier l√©g√®rement notre approche.\nExaminons le SDF intitul√© \"Segment - exact\". Sa d√©finition est la suivante :\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\nEssayons d'utiliser ce FSD et voyons ce qui se passe.\n\n*/\n\n#elif PART == 20\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = vec3(0);\n  float segment = sdSegment(uv, vec2(0, 0), vec2(0, .2));\n\n  col = mix(vec3(1, 1, 1), col, step(0., segment));\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  // Output to screen\n  fragColor = vec4(col,1.0);\n}\n\n/*\nLorsque nous ex√©cutons ce code, nous voyons une toile compl√®tement noire. \nCertains SDF exigent que nous examinions le code d'un peu plus pr√®s. \nActuellement, le segment est trop fin pour √™tre visible dans notre canvas. \nPour lui donner un peu d'√©paisseur, nous pouvons soustraire une valeur √† la distance renvoy√©e.\n*/\n\n#elif PART == 21\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = vec3(0);\n  float segment = sdSegment(uv, vec2(0, 0), vec2(0, 0.2));\n\n  col = mix(vec3(1, 1, 1), col, step(0., segment - 0.02)); // Subtract 0.02 from the returned \"signed distance\" value of the segment\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  // Output to screen\n  fragColor = vec4(col,1.0);\n}\n\n/*\nMaintenant, nous pouvons voir notre segment appara√Ætre ! \nIl commence √† la coordonn√©e (0, 0) et se termine √† (0, 0.2). Jouez avec les vecteurs d'entr√©e, a et b,\n√† l'int√©rieur de l'appel √† la fonction sdSegment pour d√©placer le segment et l'√©tirer de diff√©rentes mani√®res.\nVous pouvez remplacer 0,02 par un autre nombre si vous souhaitez que le segment soit plus fin ou plus large.\nVous pouvez √©galement utiliser la fonction smoothstep pour rendre le segment flou sur les bords.\n*/\n\n#elif PART == 22\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = vec3(0);\n  float segment = sdSegment(uv, vec2(0, 0), vec2(0, .2));\n\n  col = mix(vec3(1, 1, 1), col, smoothstep(0., 0.02, segment));\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  // Output to screen\n  fragColor = vec4(col,1.0);\n}\n\n/*\n# Utiliser la SDF sdBezier\nLe site d'Inigo Quilez propose √©galement un SDF pour les courbes de B√©zier. Plus pr√©cis√©ment, il propose un FSD pour une courbe de B√©zier quadratique.\nCherchez le SDF intitul√© \"Quadratic Bezier - exact\". Il contient la d√©finition suivante :\n\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res );\n}\n\nC'est une fonction assez importante ! \nNotez que cette fonction utilise une fonction utilitaire, dot2. \nCette fonction est d√©finie sur sa page 3D SDF.\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nLes courbes de B√©zier quadratiques acceptent trois points de contr√¥le. \nEn 2D, chaque point de contr√¥le sera une valeur vec2 avec une composante x et une composante y. \nVous pouvez jouer avec les points de contr√¥le en utilisant un graphique que j'ai cr√©√© sur Desmos.\nhttps://www.desmos.com/calculator/xdhowj4wkk\nComme pour le sdSegment, nous devrons soustraire une petite valeur √† la \"distance sign√©e\" \nretourn√©e pour voir la courbe correctement. Voyons maintenant comment dessiner une courbe\nde B√©zier quadratique √† l'aide du code GLSL :\n*/\n\n#elif PART == 23\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res );\n}\n\nvec3 drawScene(vec2 uv) {\n    vec3 col = vec3(0);\n    vec2 A = vec2(0, 0);\n    vec2 B = vec2(0.2, 0);\n    vec2 C = vec2(0.2, 0.2);\n    float curve = sdBezier(uv, A, B, C);\n\n    col = mix(vec3(1, 1, 1), col, step(0., curve - 0.01));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n    uv -= 0.5; // <-0.5,0.5>\n    uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n\n    vec3 col = drawScene(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n/*\nEssayez de jouer avec les points de contr√¥le ! N'oubliez pas ! Vous pouvez utiliser mon graphique Desmos\npour vous aider !\n\nVous pouvez utiliser les op√©rations 2D avec les courbes de B√©zier pour cr√©er des effets int√©ressants.\nNous pouvons soustraire deux courbes de B√©zier d'un cercle pour obtenir une sorte de balle de tennis.\n√Ä vous d'explorer tout ce que vous pouvez cr√©er avec les outils qui vous sont pr√©sent√©s !\n\nVous trouverez ci-dessous le code fini utilis√© pour fabriquer la balle de tennis :\n\n*/\n\n#elif PART == 24\nvec3 getBackgroundColor(vec2 uv) {\n  uv = uv * 0.5 + 0.5; // remap uv from <-0.5,0.5> to <0.25,0.75>\n  vec3 gradientStartColor = vec3(1., 0., 1.);\n  vec3 gradientEndColor = vec3(0., 1., 1.);\n  return mix(gradientStartColor, gradientEndColor, uv.y); // gradient goes from bottom to top\n}\n\nfloat sdCircle(vec2 uv, float r, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return length(vec2(x, y)) - r;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res );\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = getBackgroundColor(uv);\n  float d1 = sdCircle(uv, 0.2, vec2(0., 0.));\n  vec2 A = vec2(-0.2, 0.2);\n  vec2 B = vec2(0, 0);\n  vec2 C = vec2(0.2, 0.2);\n  float d2 = sdBezier(uv, A, B, C) - 0.03;\n  float d3 = sdBezier(uv*vec2(1,-1), A, B, C) - 0.03;\n\n  float res; // result\n  res = max(d1, -d2); // subtraction - subtract d2 from d1\n  res = max(res, -d3); // subtraction - subtract d3 from the result\n\n  res = smoothstep(0., 0.01, res); // antialias entire result\n\n  col = mix(vec3(.8,.9,.2), col, res);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  fragColor = vec4(col,1.0); // Output to screen\n}\n\n\n/*\n# Conclusion\n\nDans ce tutoriel, nous avons appris √† montrer plus d'amour √† nos shaders en dessinant un coeur ‚ù§Ô∏è \net d'autres formes. Nous avons appris √† dessiner des √©toiles, des segments et des courbes de B√©zier\nquadratiques. \n\nBien s√ªr, ma technique pour dessiner des formes avec des SDF 2D n'est qu'une pr√©f√©rence personnelle.\nIl existe de nombreuses fa√ßons de dessiner des formes 2D sur le canvas.\nNous avons √©galement appris √† combiner des formes primitives pour cr√©er des formes plus complexes.\nDans le prochain article, nous commencerons √† apprendre √† dessiner des formes et des sc√®nes en 3D\n√† l'aide du raymarching !\n*/\n\n#endif","name":"Image","description":"","type":"image"}]}