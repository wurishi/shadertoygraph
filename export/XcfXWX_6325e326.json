{"ver":"0.1","info":{"id":"XcfXWX","date":"1707732467","viewed":25,"name":"[inspirnathan] 04 - SDFop&shapes","username":"hrst4","description":"[inspirnathan] 04 - SDFop&shapes","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["inspirnathan"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This a french translation of the highly educational Nathan Vaughn's tutorials.\n// Un grand merci à lui !\n// his website: https://inspirnathan.com/\n// original:\n//from https://inspirnathan.com/posts/51-shadertoy-tutorial-part-5\n\n#define PART 24\n/*\nSalutations, chers amis ! Dans ce tutoriel, j'expliquerai comment utiliser les opérations SDF 2D \npour créer des formes plus complexes à partir de formes primitives, \net comment dessiner d'autres formes 2D primitives, notamment des cœurs et des étoiles. \nJe vous aiderai à utiliser cette liste de SDF 2D qui a été popularisée par le talentueux Inigo Quilez,\nl'un des co-créateurs de Shadertoy. C'est parti !\n\n# Combinaison d'opérations SDF 2D\n\nDans les tutoriels précédents, nous avons vu comment dessiner des formes 2D primitives\ntelles que des cercles et des carrés, mais nous pouvons utiliser les opérations SDF 2D pour créer \ndes formes plus complexes en combinant des formes primitives.\n\nCommençons par un code standard simple pour les formes 2D :\n*/\n\n#if PART == 1\nvec3 getBackgroundColor(vec2 uv) {\n  uv = uv * 0.5 + 0.5; // remap uv from <-0.5,0.5> to <0.25,0.75>\n  vec3 gradientStartColor = vec3(1., 0., 1.);\n  vec3 gradientEndColor = vec3(0., 1., 1.);\n  return mix(gradientStartColor, gradientEndColor, uv.y); // gradient goes from bottom to top\n}\n\nfloat sdCircle(vec2 uv, float r, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return length(vec2(x, y)) - r;\n}\n\nfloat sdSquare(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return max(abs(x), abs(y)) - size;\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = getBackgroundColor(uv);\n  float d1 = sdCircle(uv, 0.1, vec2(0., 0.));\n  float d2 = sdSquare(uv, 0.1, vec2(0.1, 0));\n\n  float res; // result\n  res = d1;\n\n  res = step(0., res); // Same as res > 0. ? 1. : 0.;\n\n  col = mix(vec3(1,0,0), col, res);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  fragColor = vec4(col,1.0); // Output to screen\n}\n\n/*\nNotez que j'utilise maintenant sdCircle pour le nom de la fonction au lieu de sdfCircle\n(qui était utilisé dans les tutoriels précédents).\nLe site web d'Inigo Quilez utilise généralement sd devant le nom de la forme, \nmais j'ai utilisé sdf pour qu'il soit clair qu'il s'agit de champs de distance signés (SDF).\n\nLorsque vous exécutez le code, vous devriez voir un cercle rouge avec une couleur de fond dégradée,\nsimilaire à ce que nous avons appris dans le tutoriel précédent.\n\nPrêtez attention à l'endroit où nous utilisons la fonction mix :\ncol = mix(vec3(1,0,0), col, res);\n\nCette ligne indique qu'il faut prendre le résultat et choisir la couleur rouge \nou la valeur de col (actuellement la couleur de fond) en fonction de la valeur de res (le résultat).\n\nExaminons maintenant les différentes opérations SDF qui peuvent être effectuées.\nNous allons examiner l'interaction entre un cercle et un carré.\n\n\n*/\n\n// Union : combiner deux formes ensemble.\n#elif PART == 2 \nvec3 getBackgroundColor(vec2 uv) {\n  uv = uv * 0.5 + 0.5; // remap uv from <-0.5,0.5> to <0.25,0.75>\n  vec3 gradientStartColor = vec3(1., 0., 1.);\n  vec3 gradientEndColor = vec3(0., 1., 1.);\n  return mix(gradientStartColor, gradientEndColor, uv.y); // gradient goes from bottom to top\n}\n\nfloat sdCircle(vec2 uv, float r, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return length(vec2(x, y)) - r;\n}\n\nfloat sdSquare(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return max(abs(x), abs(y)) - size;\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = getBackgroundColor(uv);\n  float d1 = sdCircle(uv, 0.1, vec2(0., 0.));\n  float d2 = sdSquare(uv, 0.1, vec2(0.1, 0));\n\n  float res; // result\n  res = min(d1, d2); // union\n\n  res = step(0., res); // Same as res > 0. ? 1. : 0.;\n\n  col = mix(vec3(1,0,0), col, res);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  fragColor = vec4(col,1.0); // Output to screen\n}\n//Soustraction : soustraire d1 de d2.\n#elif PART == 3 \n\nvec3 getBackgroundColor(vec2 uv) {\n  uv = uv * 0.5 + 0.5; // remap uv from <-0.5,0.5> to <0.25,0.75>\n  vec3 gradientStartColor = vec3(1., 0., 1.);\n  vec3 gradientEndColor = vec3(0., 1., 1.);\n  return mix(gradientStartColor, gradientEndColor, uv.y); // gradient goes from bottom to top\n}\n\nfloat sdCircle(vec2 uv, float r, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return length(vec2(x, y)) - r;\n}\n\nfloat sdSquare(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return max(abs(x), abs(y)) - size;\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = getBackgroundColor(uv);\n  float d1 = sdCircle(uv, 0.1, vec2(0., 0.));\n  float d2 = sdSquare(uv, 0.1, vec2(0.1, 0));\n\n  float res; // result\n  res = max(d1, d2); // subtraction - subtract d1 from d2\n\n  res = step(0., res); // Same as res > 0. ? 1. : 0.;\n\n  col = mix(vec3(1,0,0), col, res);\n  return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  fragColor = vec4(col,1.0); // Output to screen\n}\n\n//Soustraction : soustraire d2 de d1.\n#elif PART == 4 \n\nvec3 getBackgroundColor(vec2 uv) {\n  uv = uv * 0.5 + 0.5; // remap uv from <-0.5,0.5> to <0.25,0.75>\n  vec3 gradientStartColor = vec3(1., 0., 1.);\n  vec3 gradientEndColor = vec3(0., 1., 1.);\n  return mix(gradientStartColor, gradientEndColor, uv.y); // gradient goes from bottom to top\n}\n\nfloat sdCircle(vec2 uv, float r, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return length(vec2(x, y)) - r;\n}\n\nfloat sdSquare(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return max(abs(x), abs(y)) - size;\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = getBackgroundColor(uv);\n  float d1 = sdCircle(uv, 0.1, vec2(0., 0.));\n  float d2 = sdSquare(uv, 0.1, vec2(0.1, 0));\n\n  float res; // result\n  res = max(-d1, d2); // subtraction - subtract d1 from d2\n\n  res = step(0., res); // Same as res > 0. ? 1. : 0.;\n\n  col = mix(vec3(1,0,0), col, res);\n  return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  fragColor = vec4(col,1.0); // Output to screen\n}\n\n// XOR : une opération \"OR\" exclusive prend les parties des deux formes qui ne se croisent pas.\n#elif PART == 5 \n\nvec3 getBackgroundColor(vec2 uv) {\n  uv = uv * 0.5 + 0.5; // remap uv from <-0.5,0.5> to <0.25,0.75>\n  vec3 gradientStartColor = vec3(1., 0., 1.);\n  vec3 gradientEndColor = vec3(0., 1., 1.);\n  return mix(gradientStartColor, gradientEndColor, uv.y); // gradient goes from bottom to top\n}\n\nfloat sdCircle(vec2 uv, float r, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return length(vec2(x, y)) - r;\n}\n\nfloat sdSquare(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return max(abs(x), abs(y)) - size;\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = getBackgroundColor(uv);\n  float d1 = sdCircle(uv, 0.1, vec2(0., 0.));\n  float d2 = sdSquare(uv, 0.1, vec2(0.1, 0));\n\n  float res; // result\n  res = max(min(d1, d2), -max(d1, d2)); // xor\n\n  res = step(0., res); // Same as res > 0. ? 1. : 0.;\n\n  col = mix(vec3(1,0,0), col, res);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  fragColor = vec4(col,1.0); // Output to screen\n}\n\n/*\nNous pouvons également créer des opérations SDF 2D \"smooth\" qui mélangent en douceur les \nbords autour de l'endroit où les formes se rencontrent.\nCes opérations s'appliquent davantage aux formes 3D, mais elles fonctionnent également en 2D !\n\nAjoutez les fonctions suivantes au début de votre code :\n// smooth min\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// smooth max\nfloat smax(float a, float b, float k) {\n  return -smin(-a, -b, k);\n}\n\n\nUnion lisse : combiner deux formes ensemble, mais estomper les bords à l'endroit où ils se rencontrent.\n\n*/\n\n#elif PART == 6 \n// smooth min\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// smooth max\nfloat smax(float a, float b, float k) {\n  return -smin(-a, -b, k);\n}\n\n\nvec3 getBackgroundColor(vec2 uv) {\n  uv = uv * 0.5 + 0.5; // remap uv from <-0.5,0.5> to <0.25,0.75>\n  vec3 gradientStartColor = vec3(1., 0., 1.);\n  vec3 gradientEndColor = vec3(0., 1., 1.);\n  return mix(gradientStartColor, gradientEndColor, uv.y); // gradient goes from bottom to top\n}\n\nfloat sdCircle(vec2 uv, float r, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return length(vec2(x, y)) - r;\n}\n\nfloat sdSquare(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return max(abs(x), abs(y)) - size;\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = getBackgroundColor(uv);\n  float d1 = sdCircle(uv, 0.1, vec2(0., 0.));\n  float d2 = sdSquare(uv, 0.1, vec2(0.1, 0));\n\n  float res; // result\n  res = smin(d1, d2, 0.05); // smooth union\n\n  res = step(0., res); // Same as res > 0. ? 1. : 0.;\n\n  col = mix(vec3(1,0,0), col, res);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  fragColor = vec4(col,1.0); // Output to screen\n}\n\n/*\nIntersection lisse : ne prenez que les deux parties où les deux formes se croisent,\nmais estompez les bords à l'endroit où ils se rencontrent.\n*/\n\n#elif PART == 7 \n// smooth min\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// smooth max\nfloat smax(float a, float b, float k) {\n  return -smin(-a, -b, k);\n}\n\n\nvec3 getBackgroundColor(vec2 uv) {\n  uv = uv * 0.5 + 0.5; // remap uv from <-0.5,0.5> to <0.25,0.75>\n  vec3 gradientStartColor = vec3(1., 0., 1.);\n  vec3 gradientEndColor = vec3(0., 1., 1.);\n  return mix(gradientStartColor, gradientEndColor, uv.y); // gradient goes from bottom to top\n}\n\nfloat sdCircle(vec2 uv, float r, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return length(vec2(x, y)) - r;\n}\n\nfloat sdSquare(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return max(abs(x), abs(y)) - size;\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = getBackgroundColor(uv);\n  float d1 = sdCircle(uv, 0.1, vec2(0., 0.));\n  float d2 = sdSquare(uv, 0.1, vec2(0.1, 0));\n\n  float res; // result\n  res = smax(d1, d2, 0.05); // smooth intersection\n\n  res = step(0., res); // Same as res > 0. ? 1. : 0.;\n\n  col = mix(vec3(1,0,0), col, res);\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  fragColor = vec4(col,1.0); // Output to screen\n}\n\n/*\nOpérations positionnelles 2D SDF\n\nLa page SDF 3D d'Inigo Quilez décrit un ensemble d'opérations SDF 3D positionnelles,\nmais ces opérations peuvent également être utilisées en 2D. \nJ'aborde les opérations SDF 3D plus loin, dans la partie 14.\n\nDans ce tutoriel, je vais passer en revue les opérations SDF 2D positionnelles qui peuvent nous aider\nà gagner du temps et à améliorer les performances lorsque nous dessinons des formes 2D.\n\nSi vous dessinez une scène symétrique, il peut être utile d'utiliser l'opération opSymX.\nCette opération crée une forme 2D dupliquée le long de l'axe x à l'aide du SDF que vous avez fourni.\nSi nous dessinons un cercle avec un décalage de vec2(0,2, 0), \nun cercle équivalent sera dessiné à vec2(-0,2, 0).\n*/\n\n#elif PART == 8 \n// smooth min\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// smooth max\nfloat smax(float a, float b, float k) {\n  return -smin(-a, -b, k);\n}\n\n\n\n\nvec3 getBackgroundColor(vec2 uv) {\n  uv = uv * 0.5 + 0.5; // remap uv from <-0.5,0.5> to <0.25,0.75>\n  vec3 gradientStartColor = vec3(1., 0., 1.);\n  vec3 gradientEndColor = vec3(0., 1., 1.);\n  return mix(gradientStartColor, gradientEndColor, uv.y); // gradient goes from bottom to top\n}\n\nfloat sdCircle(vec2 uv, float r, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return length(vec2(x, y)) - r;\n}\n\nfloat opSymX(vec2 p, float r)\n{\n  p.x = abs(p.x);\n  return sdCircle(p, r, vec2(0.2, 0));\n}\n\nfloat sdSquare(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return max(abs(x), abs(y)) - size;\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = getBackgroundColor(uv);\n\n  float res; // result\n  res = opSymX(uv, 0.1);\n\n  res = step(0., res);\n  col = mix(vec3(1,0,0), col, res);\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  fragColor = vec4(col,1.0); // Output to screen\n}\n\n/*\nNous pouvons également effectuer une opération similaire sur l'axe des ordonnées. \nEn utilisant l'opération opSymY, si nous dessinons un cercle avec un décalage de vec2(0, 0,2),\nun cercle équivalent sera dessiné à vec2(0, -0,2).\n*/\n\n#elif PART == 9 \n// smooth min\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// smooth max\nfloat smax(float a, float b, float k) {\n  return -smin(-a, -b, k);\n}\n\nvec3 getBackgroundColor(vec2 uv) {\n  uv = uv * 0.5 + 0.5; // remap uv from <-0.5,0.5> to <0.25,0.75>\n  vec3 gradientStartColor = vec3(1., 0., 1.);\n  vec3 gradientEndColor = vec3(0., 1., 1.);\n  return mix(gradientStartColor, gradientEndColor, uv.y); // gradient goes from bottom to top\n}\n\nfloat sdCircle(vec2 uv, float r, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return length(vec2(x, y)) - r;\n}\n\nfloat opSymX(vec2 p, float r)\n{\n  p.x = abs(p.x);\n  return sdCircle(p, r, vec2(0.2, 0));\n}\n\nfloat opSymY(vec2 p, float r)\n{\n  p.y = abs(p.y);\n  return sdCircle(p, r, vec2(0, 0.2));\n}\n\nfloat sdSquare(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return max(abs(x), abs(y)) - size;\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = getBackgroundColor(uv);\n\n  float res; // result\n  res = opSymY(uv, 0.1);\n\n  res = step(0., res);\n  col = mix(vec3(1,0,0), col, res);\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  fragColor = vec4(col,1.0); // Output to screen\n}\n\n/*\nSi vous souhaitez dessiner des cercles le long de deux axes au lieu d'un seul, \nvous pouvez utiliser l'opération opSymXY. \nCette opération crée un double le long de l'axe x et de l'axe y, ce qui donne quatre cercles. \nSi nous dessinons un cercle avec un décalage de vec2(0,2, 0), un cercle sera dessiné à \nvec2(0,2, 0,2), vec2(0,2, -0,2), vec2(-0,2, -0,2) et vec2(-0,2, 0,2).\n*/\n\n#elif PART == 10 \n// smooth min\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// smooth max\nfloat smax(float a, float b, float k) {\n  return -smin(-a, -b, k);\n}\n\nvec3 getBackgroundColor(vec2 uv) {\n  uv = uv * 0.5 + 0.5; // remap uv from <-0.5,0.5> to <0.25,0.75>\n  vec3 gradientStartColor = vec3(1., 0., 1.);\n  vec3 gradientEndColor = vec3(0., 1., 1.);\n  return mix(gradientStartColor, gradientEndColor, uv.y); // gradient goes from bottom to top\n}\n\nfloat sdCircle(vec2 uv, float r, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return length(vec2(x, y)) - r;\n}\n\nfloat opSymX(vec2 p, float r)\n{\n  p.x = abs(p.x);\n  return sdCircle(p, r, vec2(0.2, 0));\n}\n\nfloat opSymY(vec2 p, float r)\n{\n  p.y = abs(p.y);\n  return sdCircle(p, r, vec2(0, 0.2));\n}\n\nfloat opSymXY(vec2 p, float r)\n{\n  p = abs(p);\n  return sdCircle(p, r, vec2(0.2));\n}\n\nfloat sdSquare(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return max(abs(x), abs(y)) - size;\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = getBackgroundColor(uv);\n\n  float res; // result\n  res = opSymXY(uv, 0.1);\n\n  res = step(0., res);\n  col = mix(vec3(1,0,0), col, res);\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  fragColor = vec4(col,1.0); // Output to screen\n}\n\n/*\nIl peut arriver que vous souhaitiez créer un nombre infini d'objets 2D sur un ou plusieurs axes.\nVous pouvez utiliser l'opération opRep pour répéter des cercles le long des axes de votre choix. \nLe paramètre c est un vecteur utilisé pour contrôler l'espacement entre les objets 2D le long de chaque axe.\n*/\n\n#elif PART == 11 \n// smooth min\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// smooth max\nfloat smax(float a, float b, float k) {\n  return -smin(-a, -b, k);\n}\n\nvec3 getBackgroundColor(vec2 uv) {\n  uv = uv * 0.5 + 0.5; // remap uv from <-0.5,0.5> to <0.25,0.75>\n  vec3 gradientStartColor = vec3(1., 0., 1.);\n  vec3 gradientEndColor = vec3(0., 1., 1.);\n  return mix(gradientStartColor, gradientEndColor, uv.y); // gradient goes from bottom to top\n}\n\nfloat sdCircle(vec2 uv, float r, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return length(vec2(x, y)) - r;\n}\n\nfloat opSymX(vec2 p, float r)\n{\n  p.x = abs(p.x);\n  return sdCircle(p, r, vec2(0.2, 0));\n}\n\nfloat opSymY(vec2 p, float r)\n{\n  p.y = abs(p.y);\n  return sdCircle(p, r, vec2(0, 0.2));\n}\n\nfloat opSymXY(vec2 p, float r)\n{\n  p = abs(p);\n  return sdCircle(p, r, vec2(0.2));\n}\n\nfloat opRep(vec2 p, float r, vec2 c)\n{\n  vec2 q = mod(p+0.5*c,c)-0.5*c;\n  return sdCircle(q, r, vec2(0));\n}\n\nfloat sdSquare(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return max(abs(x), abs(y)) - size;\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = getBackgroundColor(uv);\n\n  float res; // result\n  res = opRep(uv, 0.05, vec2(0.2, 0.2));\n\n  res = step(0., res);\n  col = mix(vec3(1,0,0), col, res);\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  fragColor = vec4(col,1.0); // Output to screen\n}\n\n/*\nSi vous souhaitez répéter les objets 2D seulement un certain nombre de fois au lieu d'un nombre infini,\nvous pouvez utiliser l'opération opRepLim. \n\nLe paramètre c est maintenant une valeur flottante et contrôle toujours l'espacement entre chaque objet 2D\nrépété. \nLe paramètre l est un vecteur qui vous permet de contrôler combien de fois la forme doit être répétée \nle long d'un axe donné. \nPar exemple, une valeur de vec2(2, 2) dessine un cercle supplémentaire le long des axes x et y positif\net négatif.\n*/\n\n#elif PART == 12 \n// smooth min\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// smooth max\nfloat smax(float a, float b, float k) {\n  return -smin(-a, -b, k);\n}\n\nvec3 getBackgroundColor(vec2 uv) {\n  uv = uv * 0.5 + 0.5; // remap uv from <-0.5,0.5> to <0.25,0.75>\n  vec3 gradientStartColor = vec3(1., 0., 1.);\n  vec3 gradientEndColor = vec3(0., 1., 1.);\n  return mix(gradientStartColor, gradientEndColor, uv.y); // gradient goes from bottom to top\n}\n\nfloat sdCircle(vec2 uv, float r, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return length(vec2(x, y)) - r;\n}\n\nfloat opSymX(vec2 p, float r)\n{\n  p.x = abs(p.x);\n  return sdCircle(p, r, vec2(0.2, 0));\n}\n\nfloat opSymY(vec2 p, float r)\n{\n  p.y = abs(p.y);\n  return sdCircle(p, r, vec2(0, 0.2));\n}\n\nfloat opSymXY(vec2 p, float r)\n{\n  p = abs(p);\n  return sdCircle(p, r, vec2(0.2));\n}\n\nfloat opRep(vec2 p, float r, vec2 c)\n{\n  vec2 q = mod(p+0.5*c,c)-0.5*c;\n  return sdCircle(q, r, vec2(0));\n}\n\nfloat opRepLim(vec2 p, float r, float c, vec2 l)\n{\n  vec2 q = p-c*clamp(round(p/c),-l,l);\n  return sdCircle(q, r, vec2(0));\n}\n\nfloat sdSquare(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return max(abs(x), abs(y)) - size;\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = getBackgroundColor(uv);\n\n  float res; // result\n  res = opRepLim(uv, 0.05, 0.15, vec2(2, 2));\n\n  res = step(0., res);\n  col = mix(vec3(1,0,0), col, res);\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  fragColor = vec4(col,1.0); // Output to screen\n}\n\n/*\nVous pouvez également déformer ou distordre un SDF en manipulant la valeur de p,\nla coordonnée uv, et en l'ajoutant à la valeur renvoyée par un SDF.\nDans l'opération opDisplace, vous pouvez créer n'importe quel type d'opération mathématique\npour déplacer la valeur de p, puis ajouter ce résultat à la valeur originale renvoyée par un SDF.\n*/\n\n#elif PART == 13 \n// smooth min\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// smooth max\nfloat smax(float a, float b, float k) {\n  return -smin(-a, -b, k);\n}\n\nvec3 getBackgroundColor(vec2 uv) {\n  uv = uv * 0.5 + 0.5; // remap uv from <-0.5,0.5> to <0.25,0.75>\n  vec3 gradientStartColor = vec3(1., 0., 1.);\n  vec3 gradientEndColor = vec3(0., 1., 1.);\n  return mix(gradientStartColor, gradientEndColor, uv.y); // gradient goes from bottom to top\n}\n\nfloat sdCircle(vec2 uv, float r, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return length(vec2(x, y)) - r;\n}\n\nfloat opSymX(vec2 p, float r)\n{\n  p.x = abs(p.x);\n  return sdCircle(p, r, vec2(0.2, 0));\n}\n\nfloat opSymY(vec2 p, float r)\n{\n  p.y = abs(p.y);\n  return sdCircle(p, r, vec2(0, 0.2));\n}\n\nfloat opSymXY(vec2 p, float r)\n{\n  p = abs(p);\n  return sdCircle(p, r, vec2(0.2));\n}\n\nfloat opRep(vec2 p, float r, vec2 c)\n{\n  vec2 q = mod(p+0.5*c,c)-0.5*c;\n  return sdCircle(q, r, vec2(0));\n}\n\nfloat opRepLim(vec2 p, float r, float c, vec2 l)\n{\n  vec2 q = p-c*clamp(round(p/c),-l,l);\n  return sdCircle(q, r, vec2(0));\n}\n\nfloat opDisplace(vec2 p, float r)\n{\n  float d1 = sdCircle(p, r, vec2(0));\n  float s = 0.5; // scaling factor\n\n  float d2 = sin(s * p.x * 1.8); // Some arbitrary values I played around with\n\n  return d1 + d2;\n}\n\nfloat sdSquare(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return max(abs(x), abs(y)) - size;\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = getBackgroundColor(uv);\n\n  float res; // result\n  res = opDisplace(uv, 0.1); // Kinda looks like an egg\n\n  res = step(0., res);\n  col = mix(vec3(1,0,0), col, res);\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  fragColor = vec4(col,1.0); // Output to screen\n}\n\n/*\n# Anti-aliasing\n\nSi vous souhaitez ajouter un anticrénelage, vous pouvez utiliser la fonction smoothstep \npour lisser les bords de vos formes. La fonction smoothstep(edge0, edge1, x) \naccepte trois paramètres et effectue une interpolation d'Hermite entre zéro et un lorsque edge0 < x < edge1 .\n\nedge0: Specifies the value of the lower edge of the Hermite function.\nedge1: Specifies the value of the upper edge of the Hermite function.\nx: Specifies the source value for interpolation.\nt = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\nreturn t * t * (3.0 - 2.0 * t);\n\n## TIP\nLa documentation indique que si le edge0 est supérieur ou égal au edge1, la fonction smoothstep \nrenvoie une valeur indéfinie. Cependant, cela est incorrect. \nLe résultat de la fonction smoothstep est toujours déterminé par la fonction d'interpolation Hermite, \nmême si le edge0 est supérieur au edge1.\n\nSi vous n'êtes toujours pas convaincu, cette page du Book of Shaders peut vous aider à visualiser \nla fonction smoothstep.\nEssentiellement, elle se comporte comme la fonction step avec quelques étapes supplémentaires \n(sans jeu de mots)\n\nRemplaçons la fonction step par la fonction smoothstep pour voir comment se comporte\nle résultat entre l'union d'un cercle et d'un carré.\n*/\n#elif PART == 14\n\nvec3 getBackgroundColor(vec2 uv) {\n  uv = uv * 0.5 + 0.5; // remap uv from <-0.5,0.5> to <0.25,0.75>\n  vec3 gradientStartColor = vec3(1., 0., 1.);\n  vec3 gradientEndColor = vec3(0., 1., 1.);\n  return mix(gradientStartColor, gradientEndColor, uv.y); // gradient goes from bottom to top\n}\n\nfloat sdCircle(vec2 uv, float r, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return length(vec2(x, y)) - r;\n}\n\nfloat sdSquare(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return max(abs(x), abs(y)) - size;\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = getBackgroundColor(uv);\n  float d1 = sdCircle(uv, 0.1, vec2(0., 0.));\n  float d2 = sdSquare(uv, 0.1, vec2(0.1, 0));\n\n  float res; // result\n  res = min(d1, d2); // union\n\n  res = smoothstep(0., 0.02, res); // antialias entire result\n\n  col = mix(vec3(1,0,0), col, res);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  fragColor = vec4(col,1.0); // Output to screen\n}\n\n/*\nNous obtenons une forme dont les bords sont légèrement flous.\n\nLa fonction smoothstep nous aide à créer des transitions douces entre les couleurs,\nce qui est utile pour mettre en œuvre l'anticrénelage.\nVous pouvez également voir des personnes utiliser la fonction smoothstep pour créer des objets \némissifs ou des effets de lueur néon. Elle est très souvent utilisée dans les shaders.\n*/\n\n/*\n# Dessiner un coeur\n\nDans cette section, je vais vous apprendre à dessiner un cœur à l'aide de Shadertoy.\nGardez à l'esprit qu'il existe plusieurs styles de coeurs. \nJe vous montrerai comment créer un seul style de cœur en utilisant une équation de Wolfram MathWorld.\nhttps://inspirnathan.com/_nuxt/img/img-16.8143671.png\nSi nous voulons appliquer un décalage à cette courbe de coeur, \nnous devons le soustraire de la composante x et de la composante y avant de leur appliquer\ntoute sorte d'opération (telle que l'exponentiation).\n\ns = x - offsetX\nt = y - offsetY\n\n(s^2 + t^2 - 1)^3 - s^2 * t^3 = 0\n\nx = x-coordinate on graph\ny = y-coordinate on graph\n\nVous pouvez jouer avec les décalages sur une courbe de cœur en utilisant le graphique que j'ai créé sur Desmos.\n\nMaintenant, comment créer un SDF pour un coeur dans Shadertoy ? \nIl suffit de mettre le côté gauche (LHS) de l'équation égal à la distance, d. \nEnsuite, il s'agit du même processus que celui que nous avons appris dans la partie 4.\n\n*/\n\n#elif PART == 15\n\nfloat sdHeart(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n  float xx = x * x;\n  float yy = y * y;\n  float yyy = yy * y;\n  float group = xx + yy - size;\n  float d = group * group * group - xx * yyy;\n  \n  return d;\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = vec3(1);\n  float heart = sdHeart(uv, 0.05, vec2(0.,-.2));\n\n  col = mix(vec3(1, 0, 0), col, step(0., heart));\n\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  // Output to screen\n  fragColor = vec4(col,1.0);\n}\n\n/*\nVous pouvez jouer avec les décalages sur une courbe de coeur en utilisant le graphique que j'ai créé sur Desmos.\nhttps://www.desmos.com/calculator/1ihio0t4bb\n\n# Comprendre la fonction pow\n\nVous vous demandez peut-être pourquoi j'ai créé la fonction sdHeart d'une manière aussi bizarre. \nPourquoi ne pas utiliser la fonction pow qui est à notre disposition ? \nLa fonction pow(x,y) prend une valeur, x, et l'élève à la puissance de y.\n\nSi vous essayez d'utiliser la fonction pow, vous verrez tout de suite à quel point le cœur\nse comporte bizarrement.\n*/\n\n#elif PART == 16\n\nfloat sdHeart(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n  float group = pow(x,2.) + pow(y,2.) - size;\n  float d = pow(group,3.) - pow(x,2.) * pow(y,3.);\n\n  return d;\n}\n\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = vec3(1);\n  float heart = sdHeart(uv, 0.05, vec2(0.,-.2));\n\n  col = mix(vec3(1, 0, 0), col, step(0., heart));\n\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  // Output to screen\n  fragColor = vec4(col,1.0);\n}\n\n/*\nÇa n'a pas l'air correct 🤔. \nSi vous envoyez cela à quelqu'un le jour de la Saint-Valentin, il pourrait penser qu'il s'agit\nd'un test de tache d'encre.\n\nPourquoi la fonction pow(x,y) se comporte-t-elle de manière si étrange ?\nSi vous regardez de plus près la documentation de cette fonction, vous verrez qu'elle renvoie une\nvaleur indéfinie si x est inférieur à zéro ou si x est égal à zéro et si y est inférieur ou égal à zéro.\n\nGardez à l'esprit que l'implémentation de la fonction pow varie en fonction du compilateur \net du matériel, il se peut donc que vous ne rencontriez pas ce problème lorsque vous développez\ndes shaders pour d'autres plateformes en dehors de Shadertoy, ou que vous rencontriez d'autres problèmes.\n\nComme notre système de coordonnées est configuré pour avoir des valeurs négatives pour x et y, \nnous obtenons parfois des valeurs indéfinies à la suite de l'utilisation de la fonction pow.\nDans Shadertoy, le compilateur utilisera undefined dans les opérations mathématiques,\nce qui entraînera des résultats confus.\n\nNous pouvons expérimenter le comportement de undefined avec différentes opérations \narithmétiques en déboguant le canevas à l'aide de la couleur. Essayons d'ajouter un nombre à undefined :\n(...)\n\nD'après les observations que nous avons recueillies, nous pouvons conclure que undefined \nest traité comme une valeur de zéro lorsqu'il est utilisé dans des opérations arithmétiques.\n\nCependant, cela peut encore varier en fonction du compilateur et du matériel graphique.\nPar conséquent, vous devez faire attention à la manière dont vous utilisez la fonction pow\ndans votre code shader.\n\nSi vous souhaitez élever une valeur au carré, une astuce courante consiste à utiliser \nla fonction dot pour calculer le produit de points entre un vecteur et lui-même. \nCela nous permet de réécrire la fonction sdHeart pour qu'elle soit un peu plus propre :\n\nfloat sdHeart(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n  float group = dot(x,x) + dot(y,y) - size;\n  float d = group * dot(group, group) - dot(x,x) * dot(y,y) * y;\n  \n  return d;\n}\n\nAppeler dot(x,x) revient à élever au carré la valeur de x,\nmais vous n'avez pas à vous préoccuper des problèmes de la fonction pow.\n\n# Utilisation du SDF sdStar5\n\nInigo Quilez a créé de nombreux SDF 2D et SDF 3D que les développeurs de Shadertoy utilisent. \nDans cette section, je vais voir comment nous pouvons utiliser sa liste de SDF 2D \navec les techniques que nous avons apprises dans la partie 4 de ma série Shadertoy\npour dessiner des formes 2D.\n\nLorsque l'on crée des formes à l'aide de SDF, on les appelle communément des \"primitives\"\ncar elles constituent les éléments de base pour créer des formes plus abstraites.\nEn 2D, il est assez simple de dessiner des formes sur le canevas, mais cela deviendra\nplus complexe lorsque nous aborderons les formes 3D.\n\nEntraînons-nous avec une étoile SDF, parce que dessiner des étoiles, \nc'est toujours amusant. \nNaviguez sur le site d'Inigo Quilez et descendez jusqu'au FSD appelé \"Étoile 5 - exacte\".\nIl devrait avoir la définition suivante :\n\nfloat sdStar5(in vec2 p, in float r, in float rf)\n{\n  const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n  const vec2 k2 = vec2(-k1.x,k1.y);\n  p.x = abs(p.x);\n  p -= 2.0*max(dot(k1,p),0.0)*k1;\n  p -= 2.0*max(dot(k2,p),0.0)*k2;\n  p.x = abs(p.x);\n  p.y -= r;\n  vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n  float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n  return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nNe vous préoccupez pas des qualificatifs in dans la fonction. \nVous pouvez les supprimer si vous le souhaitez, car in est le qualificatif\npar défaut si aucun n'est spécifié.\n\nCréons un nouveau shader Shadertoy avec le code suivant :\n\n\n*/\n\n#elif PART == 17\n\nfloat sdStar5(in vec2 p, in float r, in float rf)\n{\n  const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n  const vec2 k2 = vec2(-k1.x,k1.y);\n  p.x = abs(p.x);\n  p -= 2.0*max(dot(k1,p),0.0)*k1;\n  p -= 2.0*max(dot(k2,p),0.0)*k2;\n  p.x = abs(p.x);\n  p.y -= r;\n  vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n  float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n  return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = vec3(0);\n  float star = sdStar5(uv, 0.16, 0.50);\n  \n  col = mix(vec3(1, 1, 0), col, step(0., star));\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  // Output to screen\n  fragColor = vec4(col,1.0);\n}\n\n/*\nIl manque cependant une chose. Nous devons ajouter un offset au début de la fonction sdStar5 \nen décalant légèrement les coordonnées UV. \nNous pouvons ajouter un nouveau paramètre appelé offset, et nous pouvons soustraire cet offset du vecteur, p,\nqui représente les coordonnées UV que nous avons passées dans cette fonction.\n\nNotre code fini devrait ressembler à ceci :\n\n*/\n\n#elif PART == 18\nfloat sdStar5(in vec2 p, in float r, in float rf, vec2 offset)\n{\n  p -= offset; // This will subtract offset.x from p.x and subtract offset.y from p.y\n  const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n  const vec2 k2 = vec2(-k1.x,k1.y);\n  p.x = abs(p.x);\n  p -= 2.0*max(dot(k1,p),0.0)*k1;\n  p -= 2.0*max(dot(k2,p),0.0)*k2;\n  p.x = abs(p.x);\n  p.y -= r;\n  vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n  float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n  return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = vec3(0);\n  float star = sdStar5(uv, 0.12, 0.45, vec2(0.2, 0)); // Add an offset to shift the star's position\n  \n  col = mix(vec3(1, 1, 0), col, step(0., star));\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  // Output to screen\n  fragColor = vec4(col,1.0);\n}\n\n/*\n# Utilisation du SDF sdBox\nIl est assez courant de dessiner des boîtes/rectangles,\nnous allons donc sélectionner le SDF intitulé \"Boîte - exacte\". Sa définition est la suivante :\nfloat sdBox( in vec2 p, in vec2 b )\n{\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nNous ajouterons un paramètre offset à la déclaration de la fonction.\n\nfloat sdBox( in vec2 p, in vec2 b, vec2 offset )\n{\n  p -= offset;\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nMaintenant, nous devrions être en mesure de rendre la boîte et l'étoile sans aucun problème :\n\n*/\n#elif PART == 19\n\nfloat sdBox( in vec2 p, in vec2 b, vec2 offset )\n{\n  p -= offset;\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdStar5(in vec2 p, in float r, in float rf, vec2 offset)\n{\n  p -= offset; // This will subtract offset.x from p.x and subtract offset.y from p.y\n  const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n  const vec2 k2 = vec2(-k1.x,k1.y);\n  p.x = abs(p.x);\n  p -= 2.0*max(dot(k1,p),0.0)*k1;\n  p -= 2.0*max(dot(k2,p),0.0)*k2;\n  p.x = abs(p.x);\n  p.y -= r;\n  vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n  float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n  return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = vec3(0);\n  float box = sdBox(uv, vec2(0.2, 0.1), vec2(-0.2, 0));\n  float star = sdStar5(uv, 0.12, 0.45, vec2(0.2, 0));\n  \n  col = mix(vec3(1, 1, 0), col, step(0., star));\n  col = mix(vec3(0, 0, 1), col, step(0., box));\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  // Output to screen\n  fragColor = vec4(col,1.0);\n}\n\n/*\nAvec seulement quelques petites modifications, nous pouvons choisir de nombreux SDF 2D \nsur le site web d'Inigo Quilez et les dessiner sur le canevas avec un décalage.\n\nNotez cependant que certains SDF nécessitent des fonctions définies sur la page SDF 3D \ndu site d'Inigo Quilez :\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n# Utilisation du SDF sdSegment\n\nCertains des SDF 2D figurant sur le site web d'Inigo Quilez concernent des segments ou des courbes, \nde sorte que nous devrons peut-être modifier légèrement notre approche.\nExaminons le SDF intitulé \"Segment - exact\". Sa définition est la suivante :\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\nEssayons d'utiliser ce FSD et voyons ce qui se passe.\n\n*/\n\n#elif PART == 20\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = vec3(0);\n  float segment = sdSegment(uv, vec2(0, 0), vec2(0, .2));\n\n  col = mix(vec3(1, 1, 1), col, step(0., segment));\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  // Output to screen\n  fragColor = vec4(col,1.0);\n}\n\n/*\nLorsque nous exécutons ce code, nous voyons une toile complètement noire. \nCertains SDF exigent que nous examinions le code d'un peu plus près. \nActuellement, le segment est trop fin pour être visible dans notre canvas. \nPour lui donner un peu d'épaisseur, nous pouvons soustraire une valeur à la distance renvoyée.\n*/\n\n#elif PART == 21\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = vec3(0);\n  float segment = sdSegment(uv, vec2(0, 0), vec2(0, 0.2));\n\n  col = mix(vec3(1, 1, 1), col, step(0., segment - 0.02)); // Subtract 0.02 from the returned \"signed distance\" value of the segment\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  // Output to screen\n  fragColor = vec4(col,1.0);\n}\n\n/*\nMaintenant, nous pouvons voir notre segment apparaître ! \nIl commence à la coordonnée (0, 0) et se termine à (0, 0.2). Jouez avec les vecteurs d'entrée, a et b,\nà l'intérieur de l'appel à la fonction sdSegment pour déplacer le segment et l'étirer de différentes manières.\nVous pouvez remplacer 0,02 par un autre nombre si vous souhaitez que le segment soit plus fin ou plus large.\nVous pouvez également utiliser la fonction smoothstep pour rendre le segment flou sur les bords.\n*/\n\n#elif PART == 22\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = vec3(0);\n  float segment = sdSegment(uv, vec2(0, 0), vec2(0, .2));\n\n  col = mix(vec3(1, 1, 1), col, smoothstep(0., 0.02, segment));\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  // Output to screen\n  fragColor = vec4(col,1.0);\n}\n\n/*\n# Utiliser la SDF sdBezier\nLe site d'Inigo Quilez propose également un SDF pour les courbes de Bézier. Plus précisément, il propose un FSD pour une courbe de Bézier quadratique.\nCherchez le SDF intitulé \"Quadratic Bezier - exact\". Il contient la définition suivante :\n\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res );\n}\n\nC'est une fonction assez importante ! \nNotez que cette fonction utilise une fonction utilitaire, dot2. \nCette fonction est définie sur sa page 3D SDF.\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nLes courbes de Bézier quadratiques acceptent trois points de contrôle. \nEn 2D, chaque point de contrôle sera une valeur vec2 avec une composante x et une composante y. \nVous pouvez jouer avec les points de contrôle en utilisant un graphique que j'ai créé sur Desmos.\nhttps://www.desmos.com/calculator/xdhowj4wkk\nComme pour le sdSegment, nous devrons soustraire une petite valeur à la \"distance signée\" \nretournée pour voir la courbe correctement. Voyons maintenant comment dessiner une courbe\nde Bézier quadratique à l'aide du code GLSL :\n*/\n\n#elif PART == 23\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res );\n}\n\nvec3 drawScene(vec2 uv) {\n    vec3 col = vec3(0);\n    vec2 A = vec2(0, 0);\n    vec2 B = vec2(0.2, 0);\n    vec2 C = vec2(0.2, 0.2);\n    float curve = sdBezier(uv, A, B, C);\n\n    col = mix(vec3(1, 1, 1), col, step(0., curve - 0.01));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n    uv -= 0.5; // <-0.5,0.5>\n    uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n\n    vec3 col = drawScene(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n/*\nEssayez de jouer avec les points de contrôle ! N'oubliez pas ! Vous pouvez utiliser mon graphique Desmos\npour vous aider !\n\nVous pouvez utiliser les opérations 2D avec les courbes de Bézier pour créer des effets intéressants.\nNous pouvons soustraire deux courbes de Bézier d'un cercle pour obtenir une sorte de balle de tennis.\nÀ vous d'explorer tout ce que vous pouvez créer avec les outils qui vous sont présentés !\n\nVous trouverez ci-dessous le code fini utilisé pour fabriquer la balle de tennis :\n\n*/\n\n#elif PART == 24\nvec3 getBackgroundColor(vec2 uv) {\n  uv = uv * 0.5 + 0.5; // remap uv from <-0.5,0.5> to <0.25,0.75>\n  vec3 gradientStartColor = vec3(1., 0., 1.);\n  vec3 gradientEndColor = vec3(0., 1., 1.);\n  return mix(gradientStartColor, gradientEndColor, uv.y); // gradient goes from bottom to top\n}\n\nfloat sdCircle(vec2 uv, float r, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n\n  return length(vec2(x, y)) - r;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res );\n}\n\nvec3 drawScene(vec2 uv) {\n  vec3 col = getBackgroundColor(uv);\n  float d1 = sdCircle(uv, 0.2, vec2(0., 0.));\n  vec2 A = vec2(-0.2, 0.2);\n  vec2 B = vec2(0, 0);\n  vec2 C = vec2(0.2, 0.2);\n  float d2 = sdBezier(uv, A, B, C) - 0.03;\n  float d3 = sdBezier(uv*vec2(1,-1), A, B, C) - 0.03;\n\n  float res; // result\n  res = max(d1, -d2); // subtraction - subtract d2 from d1\n  res = max(res, -d3); // subtraction - subtract d3 from the result\n\n  res = smoothstep(0., 0.01, res); // antialias entire result\n\n  col = mix(vec3(.8,.9,.2), col, res);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n  uv -= 0.5; // <-0.5,0.5>\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n  vec3 col = drawScene(uv);\n\n  fragColor = vec4(col,1.0); // Output to screen\n}\n\n\n/*\n# Conclusion\n\nDans ce tutoriel, nous avons appris à montrer plus d'amour à nos shaders en dessinant un coeur ❤️ \net d'autres formes. Nous avons appris à dessiner des étoiles, des segments et des courbes de Bézier\nquadratiques. \n\nBien sûr, ma technique pour dessiner des formes avec des SDF 2D n'est qu'une préférence personnelle.\nIl existe de nombreuses façons de dessiner des formes 2D sur le canvas.\nNous avons également appris à combiner des formes primitives pour créer des formes plus complexes.\nDans le prochain article, nous commencerons à apprendre à dessiner des formes et des scènes en 3D\nà l'aide du raymarching !\n*/\n\n#endif","name":"Image","description":"","type":"image"}]}