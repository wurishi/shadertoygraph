{"ver":"0.1","info":{"id":"XlccRB","date":"1532962002","viewed":694,"name":"Crazy Universe","username":"LIYUNSHANG","description":"amazing world\nDisco ball was from knarkowicz \nStarry night was from the art of code on YouTube","likes":14,"published":1,"flags":64,"usePreview":0,"tags":["3dballs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdjXDG","filepath":"https://soundcloud.com/imaginetunez/acreix-visions","previewfilepath":"https://soundcloud.com/imaginetunez/acreix-visions","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//============================================================================\n// PROJECT ID: <your Project ID is an integer equal to 62 + group_no.>\n//\n// GROUP NUMBER:\n//\n// STUDENT NAME: \n// NUS User ID.: \n//\n// STUDENT NAME: \n// NUS User ID.: \n//\n// STUDENT NAME: \n// NUS User ID.: \n//\n// COMMENTS TO GRADER: \n//\n//============================================================================\n\n\n// FRAGMENT SHADER FOR SHADERTOY\n// Run this at https://www.shadertoy.com/new\n// See documentation at https://www.shadertoy.com/howto\n\n// Your browser must support WebGL 2.0.\n// Check your browser at http://webglreport.com/?v=2\n\n\n//============================================================================\n// Constants.\n//============================================================================\n#define S(a,b,t) smoothstep(a,b,t)\nconst int NUM_LIGHTS = 2;\nconst int NUM_MATERIALS =6;\nconst int NUM_PLANES = 5;\nconst int NUM_SPHERES = 5;\nconst float pi=3.1415926;\nconst vec3 BACKGROUND_COLOR = vec3(0.1, 0.2, 0.6);\n\n// Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * 3.1415926535 / 180.0;\n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\n\n\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n\tvec3 o;  // Ray Origin.\n\tvec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n\t// The plane equation is Ax + By + Cz + D = 0.\n\tfloat A, B, C, D;\n\tint materialID;\n};\n\nstruct Sphere_t {\n\tvec3 center;\n\tfloat radius;\n\tint materialID;\n};\n\nstruct Light_t\n{\n\tvec3 position;  // Point light 3D position.\n\tvec3 I_a;       // For Ambient.\n\tvec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n\tvec3 k_a;   // Ambient coefficient.\n\tvec3 k_d;   // Diffuse coefficient.\n\tvec3 k_r;   // Reflected specular coefficient.\n\tvec3 k_rg;  // Global reflection coefficient.\n\tfloat n;    // The specular reflection exponent. Ranges from 0.0 to 128.0. \n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that on Slides 8 and 12 of \n// Lecture 11 (Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS { \n//                   I_a * k_a + \n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene()\n{\n\t// Horizontal plane.\n\tPlane[0].A = 0.0;\n\tPlane[0].B = 1.0;\n\tPlane[0].C = 0.0;\n\tPlane[0].D = 0.0;\n\tPlane[0].materialID = 0;\n\n\t// Vertical plane.\n\tPlane[1].A = 0.0;\n\tPlane[1].B = 0.0;\n\tPlane[1].C = 0.5;\n\tPlane[1].D = 3.5;\n\tPlane[1].materialID = 0;\n    \n    Plane[2].A = 0.5;\n\tPlane[2].B = 0.0;\n\tPlane[2].C = 0.0;\n\tPlane[2].D = 3.5;\n\tPlane[2].materialID = 0;\n    \n    Plane[3].A = 0.0;\n\tPlane[3].B = 0.0;\n\tPlane[3].C = -0.5;\n\tPlane[3].D = 3.5;\n\tPlane[3].materialID = 0;\n\t\n    Plane[4].A = -0.5;\n\tPlane[4].B = 0.0;\n\tPlane[4].C = 0.0;\n\tPlane[4].D = 3.5;\n\tPlane[4].materialID = 0;\n\t// Center bouncing sphere.\n\tSphere[0].center = vec3(0.0, abs(cos(1.7 * iTime)) + 1.0, 0.0);\n\tSphere[0].radius = 1.0;\n\tSphere[0].materialID = 0;\n    \n    \n\t//small balls\n    if(iTime<5.0*pi)\n    {\n    Sphere[1].center = vec3(-1.2 * cos(3.0*iTime),2.0*abs(sin(2.0* iTime))+0.1 ,1.2 * sin(3.0*iTime));\n\tSphere[1].radius = 0.1;\n\tSphere[1].materialID = 1;\n    \n    \n   \n\n    Sphere[3].center = vec3(1.2 * cos(3.0*iTime),2.0*abs(cos(1.5* iTime))+0.1 ,1.2 * sin(3.0*iTime));\n\tSphere[3].radius = 0.1;\n\tSphere[3].materialID = 3;\n\n    \n    \n    }\n    // Circling sphere.\n    else\n    {\n    Sphere[1].center = vec3(-1.2 * cos(3.0*iTime),2.0*abs(sin(2.0* iTime))+0.1 ,1.2 * sin(3.0*iTime));\n\tSphere[1].radius = 0.1;\n\tSphere[1].materialID = 1;\n        \n    \n    \n    Sphere[3].center = vec3(1.2 * cos(15.0*pi),(2.0*abs(sin(7.5*pi))+1.1)*abs(sin(2.0*iTime)),1.2 * sin(15.0*pi));\n\tSphere[3].radius = 0.1;\n\tSphere[3].materialID = 3;\n    }\n    Sphere[4].center = vec3(1.2 * cos(3.0*iTime),2.0*abs(sin(2.5* iTime))+0.1 ,-1.2 * sin(3.0*iTime));\n\tSphere[4].radius = 0.1;\n    Sphere[4].materialID = 5;\n    \n    \t\n    Sphere[2].center = vec3(-1.2 * cos(15.0*pi),(2.0*abs(cos(5.0*pi))+1.1)*abs(sin(2.0*iTime)) ,-1.2 * sin(15.0*pi));\n\tSphere[2].radius = 0.1;\n\tSphere[2].materialID = 2;   \n        \n   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\t// Silver material.\n\tMaterial[0].k_d = vec3(0.1, 0.1, 0.1);\n\tMaterial[0].k_a = 0.2 * Material[0].k_d;\n\tMaterial[0].k_r =2.0 * Material[0].k_d;\n\tMaterial[0].k_rg = 0.5 * Material[0].k_r;\n\tMaterial[0].n = 64.0;\n\n\t// Gold material.\n\tMaterial[1].k_d = vec3(1.0, 0.7, 0.4);\n\tMaterial[1].k_a = 0.2 * Material[1].k_d;\n\tMaterial[1].k_r = 2.0 * Material[1].k_d;\n\tMaterial[1].k_rg = 0.5 * Material[1].k_r;\n\tMaterial[1].n = 64.0;\n\n\t// Green plastic material.\n\tMaterial[2].k_d = vec3(1.0, 0.39, 0.25);\n\tMaterial[2].k_a = 0.2 * Material[2].k_d;\n\tMaterial[2].k_r = vec3(0.5, 1.0, 2.0);\n\tMaterial[2].k_rg = 0.2 * Material[2].k_r;\n\tMaterial[2].n = 128.0;\n    \n    Material[3].k_d = vec3(0.8, 0.36, 0.36);\n\tMaterial[3].k_a = 0.2 * Material[3].k_d;\n\tMaterial[3].k_r = vec3(0.5, 1.0, 2.0);\n\tMaterial[3].k_rg = 0.2 * Material[3].k_r;\n\tMaterial[3].n = 128.0;\n    \n    Material[4].k_d = vec3(1.0, 0.6, 0.8);\n\tMaterial[4].k_a = 0.2 * Material[4].k_d;\n\tMaterial[4].k_r = vec3(0.5, 1.0, 2.0);\n\tMaterial[4].k_rg = 0.2 * Material[4].k_r;\n\tMaterial[4].n = 128.0;\n\t\n    Material[5].k_d = vec3(1.0, 1.0, 0.6);\n\tMaterial[5].k_a = 0.2 * Material[5].k_d;\n\tMaterial[5].k_r = vec3(0.5, 1.0, 2.0);\n\tMaterial[5].k_rg = 0.5 * Material[5].k_r;\n\tMaterial[5].n = 64.0;\n    \n    \n    \n    \n    // Light 0.\n\tLight[0].position = vec3(4.0, 3.0, -3.0);\n\tLight[0].I_a = vec3(0.05, 0.05, 0.05);\n\tLight[0].I_source = vec3(1.0,1.0,1.0);\n\n\t// Light 1.\n\tLight[1].position = vec3(4.0,4.0,0.0 );\n\tLight[1].I_a = vec3(0.08, 0.08, 0.08);\n\tLight[1].I_source = vec3(1.0, 1.0, 1.0);\n    \n    \n    \n}\n\n\nfloat DistLine(vec2 p,vec2 a,vec2 b)    //point start point end\n{\n\tvec2 pa=p-a;\n\tvec2 ba=b-a;\n\tfloat t=clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n\treturn length(pa-ba*t);\n}\n//get random number\nfloat N21(vec2 p)\n{\n\tp=fract(p*vec2(12.45,6.78));\n\tp+=dot(p,p+12.32);\n\treturn fract(p.x*p.y);\n}\nvec2 N22(vec2 p)\n{\n\tfloat n=N21(p);\n\treturn vec2(n,N21(p+n));\n}\nvec2 GetPos(vec2 id,vec2 offset)\n{\n\tvec2 n=N22(id+offset)*iTime;\n\treturn offset+sin(n)*.4;\n}\nfloat Line(vec2 p,vec2 a,vec2 b)\n{\n\tfloat d=DistLine(p,a,b);\n\tfloat m=S(.03,.01,d);\n\tm*= S(1.2,.8,length(a-b));\n\treturn m;\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection \n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane(in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n\tout float t, out vec3 hitPos, out vec3 hitNormal)\n{\n\tvec3 N = vec3(pln.A, pln.B, pln.C);\n\tfloat NRd = dot(N, ray.d);\n\tfloat NRo = dot(N, ray.o);\n\tfloat t0 = (-pln.D - NRo) / NRd;\n\tif (t0 < tmin || t0 > tmax) return false;\n\n\t// We have a hit -- output results.\n\tt = t0;\n\thitPos = ray.o + t0 * ray.d;\n\thitNormal = normalize(N);\n\treturn true;\n}\n\nvec3 textureBox( sampler2D sam, in vec3 pos, in vec3 nor )\n{\n    vec3 w = abs(nor);\n    return (w.x*texture( sam, pos.yz ).xyz + \n            w.y*texture( sam, pos.zx ).xyz + \n            w.z*texture( sam, pos.xy ).xyz ) / (w.x+w.y+w.z);\n}\nfloat RaySphere( vec3 rayOrigin, vec3 rayDir, vec3 spherePos, float sphereRadius )\n{\n\tvec3 oc = rayOrigin - spherePos;\n\t\n\tfloat b = dot( oc, rayDir );\n\tfloat c = dot( oc, oc ) - sphereRadius * sphereRadius;\n\tfloat h = b * b - c;\n\tfloat t;\n\tif ( h < 0.0 )\n\t\tt = -1.0;\n\telse\n\t\tt = ( -b - sqrt( h ) );\n\treturn t;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane(in Plane_t pln, in Ray_t ray, in float tmin, in float tmax)\n{\n\tvec3 N = vec3(pln.A, pln.B, pln.C);\n\tfloat NRd = dot(N, ray.d);\n\tfloat NRo = dot(N, ray.o);\n\tfloat t0 = (-pln.D - NRo) / NRd;\n\tif (t0 < tmin || t0 > tmax) return false;\n\treturn true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the \n// smaller t, the position of the intersection (hitPos) and the normal \n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere(in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n\tout float t, out vec3 hitPos, out vec3 hitNormal)\n{\n\t/////////////////////////////////\n\tfloat a=1.0;\n\tfloat b=2.0*dot(ray.d,(ray.o-sph.center));\n\tfloat c = dot((ray.o - sph.center), (ray.o - sph.center)) - sph.radius * sph.radius;\n    float d = b * b - 4.0 * a * c;\n\tif(d<0.0)\n\t\treturn false;\n\tfloat t0 = (-b - sqrt(d)) / (2.0 * a);\n\tfloat t1 = (-b + sqrt(d)) / (2.0 * a);\n\tif (t0 < tmin || t0 > tmax)\n\t{\n\t\tif (t1 < tmin || t1 > tmax)\n\t\t\treturn false;\n\t\tt = t1;\n\t}\n\telse\n\t\tt = t0;\n\thitPos = ray.o + t * ray.d;\n\thitNormal = normalize(ray.o - sph.center + t0 * ray.d );\n\treturn true;\n\t/////////////////////////////////\n\n\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere(in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax)\n{\n\t/////////////////////////////////\n\tfloat a=1.0;\n\tfloat b=2.0*dot(ray.d,(ray.o-sph.center));\n\tfloat c = dot((ray.o - sph.center), (ray.o - sph.center)) - sph.radius * sph.radius;\n    float d = b * b - 4.0 * a * c;\n\tif(d<0.0)\n\t\treturn false;\n\tfloat t0 = (-b - sqrt(d)) / (2.0 * a);\n\tfloat t1 = (-b + sqrt(d)) / (2.0 * a);\n\tif (t0 < tmin || t0 > tmax)\n\t{\n\t\tif (t1 < tmin || t1 > tmax)\n\t\t\treturn false;\n\t}\n\treturn true;\n\t/////////////////////////////////\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting(in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n\tin Material_t mat, in Light_t light)\n{\n\tif (inShadow) {\n\t\treturn light.I_a * mat.k_a;\n\t}\n\telse {\n\t\tvec3 R = reflect(-L, N);\n\t\tfloat N_dot_L = max(0.0, dot(N, L));\n\t\tfloat R_dot_V = max(0.0, dot(R, V));\n\t\tfloat R_dot_V_pow_n = (R_dot_V == 0.0) ? 0.0 : pow(R_dot_V, mat.n);\n\n\t\treturn light.I_a * mat.k_a +\n\t\t\tlight.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n\t}\n}\n\nvec3 Lighting(in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n\tin vec3 diffuseColor, in Light_t light)\n{\n\tif (inShadow) {\n\t\treturn light.I_a;\n\t}\n\telse {\n\t\tvec3 R = reflect(-L, N);\n\t\tfloat N_dot_L = max(0.0, dot(N, L));\n\t\tfloat R_dot_V = max(0.0, dot(R, V));\n\t\tfloat R_dot_V_pow_n = (R_dot_V == 0.0) ? 0.0 : pow(R_dot_V, 0.0);\n\n\t\treturn light.I_a  +\n\t\t\tlight.I_source * (diffuseColor * N_dot_L + diffuseColor * R_dot_V_pow_n);\n\t}\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay(in Ray_t ray,\n\tout bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg)\n{\n\t// Find whether and where the ray hits some object. \n\t// Take the nearest hit point.\n\n\tbool hasHitSomething = false;\n    bool hasHitPlane=false;\n\tbool hasHitPlanexy=false;\n\tbool hasHitPlaneyz=false;\n\tbool hasHitMainSphere=false;\n\tfloat nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n\tvec3 nearest_hitPos;              // 3D position of the nearest hit point.\n\tvec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n\tint nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n\tfloat temp_t;\n\tvec3 temp_hitPos;\n\tvec3 temp_hitNormal;\n\tbool temp_hasHit;\n    bool temp_hitPlane;\n\tbool temp_hitMainSphere;\n\tbool temp_hitPlanexy;\n\tbool temp_hitPlaneyz;\n\t/////////////////////////////////////////////////////////////////////////////\n\t// TASK:\n\t// * Try interesecting input ray with all the planes and spheres,\n\t//   and record the front-most (nearest) interesection.\n\t// * If there is interesection, need to record hasHitSomething,\n\t//   nearest_t, nearest_hitPos, nearest_hitNormal, nearest_hitMatID.\n\t/////////////////////////////////////////////////////////////////////////////\n\n\t/////////////////////////////////\n\tfor (int i = 0;i < NUM_SPHERES;i++)\n\t{\n\t\tif (IntersectSphere(Sphere[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal))\n\t\t{\n\t\t\thasHitSomething = true;\n\t\t\tif (temp_t < nearest_t)\n\t\t\t{\n                temp_hitPlane=false;\n\t\t\t\tif(i==0)\n\t\t\t\t\ttemp_hitMainSphere=true;\n\t\t\t\telse\n\t\t\t\t\ttemp_hitMainSphere=false;\n\t\t\t\ttemp_hitPlanexy=false;\n\t\t\t\ttemp_hitPlaneyz=false;\n                nearest_t=temp_t;\n\t\t\t\tnearest_hitPos = temp_hitPos;\n\t\t\t\tnearest_hitNormal = temp_hitNormal;\n\t\t\t\tnearest_hitMatID = Sphere[i].materialID;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0;i < NUM_PLANES;i++)\n\t{\n\t\tif (IntersectPlane(Plane[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal))\n\t\t{\n\t\t\thasHitSomething = true;\n\t\t\tif (temp_t < nearest_t)\n\t\t\t{\n\t\t\t\tif(i==0)\n\t\t\t\t{\n\t\t\t\t\ttemp_hitPlane=true;\n\t\t\t\t\ttemp_hitPlanexy=false;\n\t\t\t\t\ttemp_hitPlaneyz=false;\n\t\t\t\t}\n\t\t\t\telse if(i==1||i==3)\n\t\t\t\t{\n\t\t\t\t\ttemp_hitPlane=false;\n\t\t\t\t\ttemp_hitPlanexy=true;\n\t\t\t\t\ttemp_hitPlaneyz=false;\n\t\t\t\t}\n\t\t\t\telse if(i==2||i==4)\n\t\t\t\t{\n\t\t\t\t\ttemp_hitPlane=false;\n\t\t\t\t\ttemp_hitPlanexy=false;\n\t\t\t\t\ttemp_hitPlaneyz=true;\n\t\t\t\t}\n\t\t\t\ttemp_hitMainSphere=false;\n                nearest_t=temp_t;\n\t\t\t\tnearest_hitPos = temp_hitPos;\n\t\t\t\tnearest_hitNormal = temp_hitNormal;\n\t\t\t\tnearest_hitMatID = Plane[i].materialID;\n\t\t\t}\n\t\t}\n\t}\n    \n\t/////////////////////////////////\n\n\n\n\t// One of the output results.\n\thasHit = hasHitSomething;\n    \n\tif (!hasHitSomething) return BACKGROUND_COLOR;\n\n\tvec3 I_local = vec3(0.0);  // Result color will be accumulated here.\n\t\n\t/////////////////////////////////////////////////////////////////////////////\n\t// TASK:\n\t// * Accumulate lighting from each light source on the nearest hit point. \n\t//   They are all accumulated into I_local.\n\t// * For each light source, make a shadow ray, and check if the shadow ray\n\t//   intersects any of the objects (the planes and spheres) between the \n\t//   nearest hit point and the light source.\n\t// * Then, call PhongLighting() to compute lighting for this light source.\n\t/////////////////////////////////////////////////////////////////////////////\n\n\t/////////////////////////////////\n\tRay_t shadowRay;\n\tshadowRay.o = nearest_hitPos;\n\tfor (int i = 0;i < NUM_LIGHTS;i++)\n\t{\n\t\tshadowRay.d = normalize(Light[i].position - nearest_hitPos);\n\t\tbool inshadow = false;\n\t\tfor (int j = 0;j < NUM_SPHERES;j++)\n\t\t{\n\t\t\tif (IntersectSphere(Sphere[j], shadowRay, DEFAULT_TMIN, DEFAULT_TMAX))\n\t\t\t\tinshadow = true;\n\t\t}\n        for (int i = 0;i < NUM_SPHERES;i++)\n\t\t{\n\t\t\tif (IntersectSphere(Sphere[i], shadowRay, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal))\n\t\t\t{\n\t\t\t\thasHitSomething = true;\n\t\t\t\tif (temp_t < nearest_t)\n\t\t\t\t{\n\t\t\t\t\tif(i==0)\n\t\t\t\t\t\ttemp_hitMainSphere=true;\n\t\t\t\t\telse\n\t\t\t\t\t\ttemp_hitMainSphere=false;\n\t\t\t\t\ttemp_hitPlane=false;\n\t\t\t\t\ttemp_hitPlanexy=false;\n\t\t\t\t\ttemp_hitPlaneyz=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0;i < NUM_PLANES;i++)\n\t\t{\n\t\t\tif (IntersectPlane(Plane[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal))\n\t\t\t{\n\t\t\t\thasHitSomething = true;\n\t\t\t\tif (temp_t < nearest_t)\n\t\t\t\t{\n\t\t\t\t\tif(i==0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp_hitPlane=true;\n\t\t\t\t\t\ttemp_hitPlanexy=false;\n\t\t\t\t\t\ttemp_hitPlaneyz=false;\n\t\t\t\t\t}\n\t\t\t\t\telse if(i==1||i==3)\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp_hitPlane=false;\n\t\t\t\t\t\ttemp_hitPlanexy=true;\n\t\t\t\t\t\ttemp_hitPlaneyz=false;\n\t\t\t\t\t}\n\t\t\t\t\telse if(i==2||i==4)\n\t\t\t\t\t{\n\t\t\t\t\t\ttemp_hitPlane=false;\n\t\t\t\t\t\ttemp_hitPlanexy=false;\n\t\t\t\t\t\ttemp_hitPlaneyz=true;\n\t\t\t\t\t}\n\t\t\t\t\ttemp_hitMainSphere=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        hasHitPlane=temp_hitPlane;\n\t\thasHitMainSphere=temp_hitMainSphere;\n\t\thasHitPlanexy=temp_hitPlanexy;\n\t\thasHitPlaneyz=temp_hitPlaneyz;\n        if(!hasHitPlane&&!hasHitMainSphere&&!hasHitPlanexy&&!hasHitPlaneyz)\n\t\tI_local += PhongLighting(shadowRay.d, nearest_hitNormal, normalize(reflect(shadowRay.d,nearest_hitNormal)), inshadow,Material[nearest_hitMatID], Light[i]);\n        else if(hasHitMainSphere)\n\t\t{\n\t\t\tfloat sphereAngle = -0.5 * iTime; \n\t\t\tvec3 color = vec3( 0 );\n\t\t\tfloat sphereRadius = 1.0;\n\t\t\tfloat t = RaySphere( ray.o, ray.d, Sphere[0].center, sphereRadius );\n\t\t\tif ( t > 0.0 )\n\t\t\t{\n\t\t\t\tvec3 pos = ray.o + t * ray.d-Sphere[0].center;\n       \n\t\t\t\tfloat tileSize \t= 0.12;        \n\t\t\t\tvec2 phiTheta\t= vec2( atan( pos.z, pos.x ) + sphereAngle, acos( pos.y / sphereRadius ) );\n\t\t\t\tvec2 tileId \t= floor( phiTheta / tileSize );\n\t\t\t\tvec2 tilePos\t= ( phiTheta - tileId * tileSize ) / tileSize;\n\t\t\t\tphiTheta\t\t= tileId * tileSize;\n\t\t\t\tphiTheta.x\t\t= phiTheta.x - sphereAngle;\n        \n\t\t\t\tvec2 edge = min( clamp( ( tilePos ) * 10.0, 0.0, 1.0 ), clamp( ( 1.0 - tilePos ) * 10.0, 0.0, 1.0 ) );       \n\t\t\t\tfloat bump = clamp( min( edge.x, edge.y ), 0.0, 1.0 );\n        \n\t\t\t\tvec3 bumpPos;\n\t\t\t\tbumpPos.x = sphereRadius * sin( phiTheta.y ) * cos( phiTheta.x );\n\t\t\t\tbumpPos.y = sphereRadius * cos( phiTheta.y );\n\t\t\t\tbumpPos.z = sphereRadius * sin( phiTheta.y ) * sin( phiTheta.x );\n\t\t\t\tbumpPos.y += ( 1.0 - bump ) * 0.1;\n\t\t\t\n\t\t\t\tvec3 normal = normalize( bumpPos );\n\n\t\t\t\tvec3 refl = reflect( ray.d, normal );\n\t\t\t\tcolor = texture( iChannel1, refl).xyz;\n\t\t\t\tcolor = color * color;\n\t\t\t\tcolor *= vec3( bump ) * 5.0;\n\t\t\t}\n             \n             I_local+=Lighting(shadowRay.d, nearest_hitNormal, normalize(reflect(shadowRay.d,nearest_hitNormal)), inshadow,color, Light[i]);\n\t\t}\n        else if(hasHitPlanexy||hasHitPlaneyz)\n\t\t{\n\t\t\tvec2 uv;\n\t\t\tif(hasHitPlanexy)\n\t\t\t\tuv = nearest_hitPos.xy/3.;\n\t\t\telse if(hasHitPlaneyz)\n\t\t\t\tuv = nearest_hitPos.yz/3.;\n   \t\t\tuv*=5.;\n\t\t\tfloat m=0.;\n\t\t\tvec2 gv=fract(uv)-.5;\n\t\t\tvec2 id=floor(uv);\n\t\t\tvec2 p[9];\n\t\t\tint i=0;\n\t\t\tfor(float y=-1.;y<=1.;y++)\n\t\t\t{\n\t\t\t\tfor(float x=-1.;x<=1.;x++)\n\t\t\t\t{\n\t\t\t\t\tp[i++]=GetPos(id,vec2(x,y));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<9;i++)\n\t\t\t{\n\t\t\t\tvec2 j=(p[i]-gv)*20.;\n\t\t\t\tfloat sparkle=1./dot(j,j);\n\t\t\t\tm+=sparkle*(sin(iTime*10.+p[i].x*10.)*.5+.5);\n\t\t\t}\n\t\t\tvec3 color = vec3(m);\n\t\t\tI_local+=Lighting(shadowRay.d, nearest_hitNormal, normalize(reflect(shadowRay.d,nearest_hitNormal)), inshadow, color, Light[i]);\n\t\t}\n\t\telse\n        {\n\t\t\tvec2 uv = nearest_hitPos.xz/3.;\n   \t\t\tuv*=5.;\n\t\t\tfloat m=0.;\n\t\t\tvec2 gv=fract(uv)-.5;\n\t\t\tvec2 id=floor(uv);\n\t\t\tvec2 p[9];\n\t\t\tint i=0;\n\t\t\tfor(float y=-1.;y<=1.;y++)\n\t\t\t{\n\t\t\t\tfor(float x=-1.;x<=1.;x++)\n\t\t\t\t{\n\t\t\t\t\tp[i++]=GetPos(id,vec2(x,y));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<9;i++)\n\t\t\t{\n\t\t\t\tm+=Line(gv,p[4],p[i]);\n\t\t\t\tvec2 j=(p[i]-gv)*20.;\n\t\t\t\tfloat sparkle=1./dot(j,j);\n\t\t\t\tm+=sparkle*(sin(iTime*10.+p[i].x*10.)*.5+.5);\n\t\t\t}\n\t\t\tm+=Line(gv,p[1],p[3]);\n\t\t\tm+=Line(gv,p[1],p[5]);\n\t\t\tm+=Line(gv,p[7],p[3]);\n\t\t\tm+=Line(gv,p[7],p[5]);\n\t\t\tvec3 color = vec3(m);\n\t\t\tI_local+=Lighting(shadowRay.d, nearest_hitNormal, normalize(reflect(shadowRay.d,nearest_hitNormal)), inshadow, color, Light[i]);\n        }\n        \n        \n    }\n    \n\n\t/////////////////////////////////\n\n\n\n// Populate output results.\n\thitPos = nearest_hitPos;\n\thitNormal = nearest_hitNormal;\n\tk_rg = Material[nearest_hitMatID].k_rg;\n\n\treturn I_local;\n}\nmat3 setCamera( in vec3 cam_pos, in vec3 com_lookat, in vec3 cam_up_vec)\n{\n    vec3 cz = normalize(com_lookat-cam_pos);\n\tvec3 cx = normalize( cross(cam_up_vec,cz) );\n    vec3 cy = normalize( cross(cz,cx) );\n    return mat3( cx, cy, cz );\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nmat3 setLightPos(in vec3 ro,in vec3 ta,float cr)\n{\n    vec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tInitScene();\n\n\t// Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n\tvec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec2 mo =iMouse.xy/iResolution.xy;\n    float time = 15.0+iTime;\n\t// Position the camera.\n\t//vec3 cam_pos = vec3(2.5, 1.0, 2.5);\n\t//vec3 cam_lookat = vec3(0.25, 1.0, 0.0);\n\t//vec3 cam_up_vec = vec3(0.0, 1.0, 0.0);\n\t// Set up camera coordinate frame in world space.\n\t//vec3 cam_z_axis = normalize(cam_pos - cam_lookat);\n\t//vec3 cam_x_axis = normalize(cross(cam_up_vec, cam_z_axis));\n\t//vec3 cam_y_axis = normalize(cross(cam_z_axis, cam_x_axis));\n \tfloat d= 2.5*2.5+2.5*2.5;\n    vec3 com_pos=vec3(1.5*sqrt(d)*cos(0.1*time + 2.0*mo.x),3.5+2.0*mo.y,1.5*sqrt(d)*sin(0.1*time + 2.0*mo.x));\n    Light[0].position=com_pos;\n    vec3 com_lookat=vec3(0.25,1.0,0.0);\n    vec3 com_up_vec= vec3(0.0, 1.0, 0.0);\n    mat3 ca = setCamera( com_pos, com_lookat, 0.0 );\n    vec3 rd = ca* normalize( vec3(pixel_pos.xy,2.0) );\n    float t=4.0*4.0+6.0*6.0;\n    vec3 light_pos=vec3(1.5*sqrt(t)*cos(0.1*time + 2.0*mo.x),3.5+2.0*mo.y,1.5*sqrt(t)*sin(0.1*time + 2.0*mo.x));\n\t// Create primary ray.\n\tfloat pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n\tRay_t pRay;\n\tpRay.o = com_pos;\n\tpRay.d = rd;\n\n\t// Start Ray Tracing.\n\t// Use iterations to emulate the recursion.\n\n\tvec3 I_result = vec3(0.0);\n\tvec3 compounded_k_rg = vec3(1.0);\n\tRay_t nextRay = pRay;\n\n\tfor (int level = 0; level <= NUM_ITERATIONS; level++)\n\t{\n\t\tbool hasHit;\n\t\tvec3 hitPos, hitNormal, k_rg;\n\n\t\tvec3 I_local = CastRay(nextRay, hasHit, hitPos, hitNormal, k_rg);\n\n\t\tI_result += compounded_k_rg * I_local;\n\n\t\tif (!hasHit) break;\n\n\t\tcompounded_k_rg *= k_rg;\n\n\t\tnextRay = Ray_t(hitPos, normalize(reflect(nextRay.d, hitNormal)));\n\t}\n\n\tfragColor = vec4(I_result, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}