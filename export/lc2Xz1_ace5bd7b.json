{"ver":"0.1","info":{"id":"lc2Xz1","date":"1731870045","viewed":58,"name":"Basic Pathtracer","username":"pg_dev","description":"A very simple path-tracer ","likes":3,"published":3,"flags":32,"usePreview":0,"tags":["3d","raytracer","pathtracer","rendering","renderer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 linearToSRGB(vec3 rgb) {\n    rgb = clamp(rgb, 0.0, 1.0);\n    return mix(\n        pow(rgb, vec3(1.0 / 2.4)) * 1.055 - 0.055,\n        rgb * 12.92,\n        vec3(lessThan(rgb, vec3(0.0031308)))\n    );\n}\n\nvec3 sRGBToLinear(vec3 rgb) {\n    rgb = clamp(rgb, 0.0, 1.0);\n    return mix(\n        pow((rgb + 0.055) / 1.055, vec3(2.4)),\n        rgb / 12.92,\n        vec3(lessThan(rgb, vec3(0.04045)))\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 colSrc = texture(iChannel0, fragCoord / iResolution.xy);\n    vec3 col = (colSrc.xyz / colSrc.w);// * 0.8;\n    \n    //col.x = pow(col.x, 1.0 / 2.2);\n    //col.y = pow(col.y, 1.0 / 2.2);\n    //col.z = pow(col.z, 1.0 / 2.2);\n    \n    fragColor = vec4(linearToSRGB(col), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct Ray\n{\n    vec3 orig;\n    vec3 dir;\n};\n\nstruct Sphere\n{\n    vec3 pos;\n    float radius;\n};\n\nstruct Triangle {\n    vec3 v0;\n    vec3 v1;\n    vec3 v2;\n    bool isDoubleSided;\n};\n\nstruct Box {\n    vec3 position;\n    vec3 size;\n    vec3 rotation;\n    bool isDoubleSided;\n};\n\nstruct HitInfo\n{\n    float dist;\n    vec3 normal;\n    bool isFrontFace;\n};\n\nconst float minRayTHitTime = 1.0 / 128.0;\nconst float maxRayTHitTime = 1024.0;\n\nconst float pi = 3.14159265358979;\nconst float tau = 6.28318530717958;\nconst float fov = 60.0;\n\nuint pcgHash(uint seed) {\n\tuint state = seed * 747796405u + 2891336453u;\n\tuint result = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n\treturn (result >> 22u) ^ result;\n}\n\nfloat randomValue(inout uint state) {\n\t// state = state * uint(747796405) + uint(2891336453) * state;\n\t// state = state * uint(747796405) + uint(1);\n\tstate = pcgHash(state);\n\treturn float(state) / 4294967295.0;\n\n\t// state *= state * (state + uint(2143215748)) * (state + uint(98763)) + state * state + state;\n\t// return float(state) / 4294967295.0;\n}\n\nvec3 randomPointInSphere(in vec3 pos, in float radius, inout uint state) {\n    float u = randomValue(state);\n    float v = randomValue(state);\n    float theta = 2.0 * pi * u;\n    float phi = acos(2.0 * v - 1.0);\n    float px = pos.x + (radius * sin(phi) * cos(theta));\n    float py = pos.y + (radius * sin(phi) * sin(theta));\n    float pz = pos.z + (radius * cos(phi));\n    return vec3(px, py, pz);\n}\n\nvec2 randomPointInDisk(float radius, inout uint rngS) {\n    float angle = randomValue(rngS) * tau;\n    float r = sqrt(randomValue(rngS)) * radius;\n\n    float x = cos(angle) * r;\n    float y = sin(angle) * r;\n\n    return vec2(x, y);\n}\n\nmat4 getCameraMatrix(vec3 position, vec3 rotation) {\n\tmat4 camRotationXMat = mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(rotation.x), -sin(rotation.x), 0.0, 0.0, sin(rotation.x), cos(rotation.x), 0.0, 0.0, 0.0, 0.0, 1.0);\n\tmat4 camRotationYMat = mat4(cos(rotation.y), 0.0, sin(rotation.y), 0.0, 0.0, 1.0, 0.0, 0.0, -sin(rotation.y), 0.0, cos(rotation.y), 0.0, 0.0, 0.0, 0.0, 1.0);\n\tmat4 camRotationZMat = mat4(cos(rotation.z), -sin(rotation.z), 0.0, 0.0, sin(rotation.z), cos(rotation.z), 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n\tmat4 camPosMat = mat4(1.0, 0.0, 0.0, position.x, 0.0, 1.0, 0.0, position.y, 0.0, 0.0, 1.0, position.z, 0.0, 0.0, 0.0, 1.0);\n\n\treturn camPosMat * ((camRotationZMat * camRotationYMat) * camRotationXMat);\n}\n\nmat3 getRotationMatrix(vec3 rotation) {\n    float cx = cos(rotation.x);\n    float sx = sin(rotation.x);\n    float cy = cos(rotation.y);\n    float sy = sin(rotation.y);\n    float cz = cos(rotation.z);\n    float sz = sin(rotation.z);\n\n    mat3 rotationX = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cx, -sx,\n        0.0, sx, cx\n    );\n\n    mat3 rotationY = mat3(\n        cy, 0.0, sy,\n        0.0, 1.0, 0.0,\n        -sy, 0.0, cy\n    );\n\n    mat3 rotationZ = mat3(\n        cz, -sz, 0.0,\n        sz, cz, 0.0,\n        0.0, 0.0, 1.0\n    );\n\n    // Return Z * Y * X for standard rotation order\n    return rotationZ * rotationY * rotationX;\n}\n\nbool hitSphere(in Ray r, inout HitInfo info, in Sphere sphere)\n{\n\tvec3 m = r.orig - sphere.pos;\n\tfloat b = dot(m, r.dir);\n\tfloat c = dot(m, m) - sphere.radius * sphere.radius;\n\n\tfloat discr = b * b - c;\n\n\tif(discr < 0.0) {\n\t\treturn false;\n    }\n    \n    bool fromInside = false;\n\tfloat dist = -b - sqrt(discr);\n    //if (dist < 0.0)\n    //{\n    //    fromInside = true;\n    //    dist = -b + sqrt(discr);\n    //}\n    \n\tif (dist >= minRayTHitTime && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normalize((r.orig + r.dir * dist) - sphere.pos) * (fromInside ? -1.0 : 1.0);\n        info.isFrontFace = fromInside;\n        return true;\n    }\n    \n    return false;\n}\n\nbool hitTriangle(in Ray r, inout HitInfo info, in Triangle triangle) {\n    vec3 v0 = triangle.v0;\n    vec3 v1 = triangle.v1;\n    vec3 v2 = triangle.v2;\n\n\tvec3 v0v1 = v1 - v0;\n\tvec3 v0v2 = v2 - v0;\n\tvec3 normal = normalize(cross(v0v1, v0v2));\n\n\tfloat normalDotRayDirection = dot(r.dir, normal);\n\n    float nT = -1.0;\n\tvec3 nNormal = normal;\n\n\tif (normalDotRayDirection >= 0.0) {\n\t\tif (triangle.isDoubleSided == true) {\n\t\t\tnNormal *= -1.0;\n\t\t} else {\n            return false;\n\t\t}\n\t}\n\n\tfloat d = -dot(normal, v0);\n\n    // Compute t (equation 3)\n\tfloat t = -(dot(normal, r.orig) + d) / normalDotRayDirection;\n\n    // Compute the intersection point using equation 1\n\tvec3 p = r.orig + t * r.dir;\n\n\tnT = t;\n\n    // Step 2: Inside-Outside Test\n\tvec3 ne; // Vector perpendicular to triangle's plane\n\n    // Test sidedness of P w.r.t. edge v0v1\n\tvec3 v0p = p - v0;\n\tne = cross(v0v1, v0p);\n\tif (dot(normal, ne) < 0.0) {\n        return false;\n\t}\n\n    // Test sidedness of P w.r.t. edge v2v1\n\tvec3 v2v1 = v2 - v1;\n\tvec3 v1p = p - v1;\n\tne = cross(v2v1, v1p);\n\tif (dot(normal, ne) < 0.0) {\n        return false;\n\t}\n\n    // Test sidedness of P w.r.t. edge v2v0\n\tvec3 v2v0 = v0 - v2;\n\tvec3 v2p = p - v2;\n\tne = cross(v2v0, v2p);\n\tif (dot(normal, ne) < 0.0) {\n        return false;\n\t}\n    \n    if (nT >= minRayTHitTime && nT < info.dist) {\n        info.dist = nT;\n        info.normal = nNormal;\n        info.isFrontFace = true;\n        \n        return true; // The ray hits the triangle\n    }\n    \n    return false;\n}\n\nbool hitBox(in Ray r, inout HitInfo info, in Box box) {\n    // Transform ray to the box's local coordinate system\n    mat3 rotationMatrix = getRotationMatrix(box.rotation);\n    mat3 inverseRotationMatrix = inverse(rotationMatrix);\n    vec3 localRayOrigin = inverseRotationMatrix * (r.orig - box.position);\n    vec3 localRayDirection = inverseRotationMatrix * r.dir;\n\n    // Compute box boundaries in local space\n    vec3 minBound = -box.size * 0.5;\n    vec3 maxBound = box.size * 0.5;\n\n    // Compute intersections with the slabs\n    vec3 tMin = (minBound - localRayOrigin) / localRayDirection;\n    vec3 tMax = (maxBound - localRayOrigin) / localRayDirection;\n\n    // Swap tMin and tMax where necessary\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n\n    // Find the largest entry time and smallest exit time\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n\n    // Check if the ray intersects the box\n    if (tNear > tFar || tFar < 0.0) {\n        return false; // No intersection\n    }\n\n    // Update hit info if closer intersection is found\n    if (tNear >= minRayTHitTime && tNear < info.dist) {\n        info.dist = tNear;\n        vec3 localHitPoint = localRayOrigin + tNear * localRayDirection;\n\n        // Determine the normal in local space\n        vec3 localNormal = vec3(0.0);\n        if (abs(localHitPoint.x - minBound.x) < 1e-4) localNormal = vec3(-1, 0, 0);\n        else if (abs(localHitPoint.x - maxBound.x) < 1e-4) localNormal = vec3(1, 0, 0);\n        else if (abs(localHitPoint.y - minBound.y) < 1e-4) localNormal = vec3(0, -1, 0);\n        else if (abs(localHitPoint.y - maxBound.y) < 1e-4) localNormal = vec3(0, 1, 0);\n        else if (abs(localHitPoint.z - minBound.z) < 1e-4) localNormal = vec3(0, 0, -1);\n        else if (abs(localHitPoint.z - maxBound.z) < 1e-4) localNormal = vec3(0, 0, 1);\n\n        // Handle double-sided box\n        if (box.isDoubleSided) {\n            // Flip the normal if needed\n            if (dot(r.dir, localNormal) > 0.0) {\n                localNormal = -localNormal;\n            }\n        } else {\n            // For single-sided, flip normal if ray is hitting the back side\n            if (dot(r.dir, localNormal) > 0.0) {\n                localNormal = -localNormal;\n            }\n        }\n\n        // Transform normal back to world space\n        info.normal = transpose(inverseRotationMatrix) * localNormal;\n\n        // Ensure the normal is always facing the ray's direction\n        //if (dot(r.dir, info.normal) > 0.0) {\n            info.normal *= -1.0;\n        //}\n\n        info.isFrontFace = dot(r.dir, info.normal) < 0.0;\n        if (!info.isFrontFace) {\n            info.normal = -info.normal;\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n\n\n// From demofox\nfloat fresnelReflectAmount(float n1, float n2, vec3 normal, vec3 incident, float f0, float f90) {\n    float r0 = (n1 - n2) / (n1 + n2);\n    r0 *= r0;\n    float cosX = -dot(normal, incident);\n\n    if (n1 > n2) {\n        float n = n1 / n2;\n        float sinT2 = n * n * (1.0 - cosX * cosX);\n\t\t\n        if (sinT2 > 1.0) {\n            return f90;\n\t\t}\n\n        cosX = sqrt(1.0 - sinT2);\n    }\n\n    float x = 1.0 - cosX;\n    float ret = r0 + (1.0 - r0) * x * x * x * x * x;\n \n    return mix(f0, f90, ret);\n}\n\nfloat maxBounceCount = 8.0;\nfloat rayPerPix = 8.0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 ndc = (uv - 0.5);\n    \n    float aspectRatio = iResolution.x / iResolution.y;\n    \n    uint rngState = floatBitsToUint(1.0 + uv.x * 7109.0 + uv.y * 8887.0 * float(float(iFrame) + 18329.0 / (uv.x + 22973.0 * uv.y)));\n    \n    int pixelIdx = int(fragCoord.x + fragCoord.y * iResolution.x);\n    \n    if (iFrame < 64) {\n        rngState = pcgHash(uint(iFrame));\n    }\n    \n    vec2 mousePos = (iMouse.xy / iResolution.xy) - 0.5;\n    float theta = -mousePos.x * tau;\n    float phi = -mousePos.y * pi;\n\n    vec3 lookTarget = vec3(0.0, 32.0, 0.0);\n    \n    vec3 rayOrig = vec3(\n        256.0 * cos(phi) * sin(theta),\n        256.0 * sin(phi),\n        -256.0 * cos(phi) * cos(theta)\n    ) + lookTarget;\n\n    \n    float fovRadians = radians(fov);\n\tfloat screenWidth = 2.0 * tan(fovRadians / 2.0);\n\tfloat screenHeight = screenWidth / aspectRatio;\n\n    vec3 cameraRotation = vec3(-phi, theta, 0.0);\n    \n\tmat4 camMat = getCameraMatrix(rayOrig, cameraRotation);\n    \n    Sphere tstSphere = Sphere(vec3(64.0, 128.0, -64.0), 32.0);\n    Sphere tstSphere2 = Sphere(vec3(64.0, 32.0, 0.0), 32.0);\n    Sphere tstSphere3 = Sphere(vec3(-64.0, 32.0, 0.0), 32.0);\n    \n    vec3 fv1 = vec3(-512.0, 0.0, 512.0);\n    vec3 fv2 = vec3(512.0, 0.0, 512.0);\n    vec3 fv3 = vec3(512.0, 0.0, -512.0);\n    vec3 fv4 = vec3(-512.0, 0.0, -512.0);\n    \n    Triangle tstTriangle1 = Triangle(fv1, fv2, fv3, false);\n    Triangle tstTriangle2 = Triangle(fv3, fv4, fv1, false);\n    \n    Box tstBox1 = Box(vec3(0.0, 32.0, 128.0), vec3(512.0, 256.0, 64.0), vec3(0.0, 0.0, 0.0), true);\n    \n    vec3 avgRayPixCol = vec3(0.0, 0.0, 0.0);\n    \n    for (float j = 0.0; j < rayPerPix; j++) {\n        vec2 aandc = ((fragCoord + randomPointInDisk(1.0, rngState)) / iResolution.xy) - 0.5;\n        \n        vec3 rayDirLocal = normalize(vec3(aandc.x * screenWidth, aandc.y * screenHeight, 1.0));\n        \n        vec3 rayDir = normalize((camMat * normalize(vec4(rayDirLocal, 0.0))).xyz);\n        \n        Ray ry = Ray(rayOrig, rayDir);\n    \n        vec3 rayColor = vec3(1.0, 1.0, 1.0);\n        vec3 incomingLight = vec3(0.0, 0.0, 0.0);\n    \n        for (float i = 0.0; i <= maxBounceCount; i++) {\n            HitInfo hInfo;\n            hInfo.dist = maxRayTHitTime;\n            \n            bool isSpecular = false;\n            float specularRoughness = 0.0;\n        \n            vec3 emissionColor = vec3(0.0, 0.0, 0.0);\n            float emissionStrength = 0.0;\n            vec3 attenuation = vec3(1.0, 1.0, 1.0);\n        \n            bool tS = hitSphere(ry, hInfo, tstSphere);\n            bool tS2 = hitSphere(ry, hInfo, tstSphere2);\n            bool tS3 = hitSphere(ry, hInfo, tstSphere3);\n            bool tT1 = hitTriangle(ry, hInfo, tstTriangle1);\n            bool tT2 = hitTriangle(ry, hInfo, tstTriangle2);\n            bool tB1 = hitBox(ry, hInfo, tstBox1);\n        \n            bool hitSomething = false;\n        \n            if (tS == true)\n            {\n                hitSomething = true;\n                attenuation = vec3(0.0, 0.0, 0.0);\n                isSpecular = false;\n                emissionColor = vec3(1.0, 1.0, 1.0);\n                emissionStrength = 8.0;\n                specularRoughness = 0.0;\n            }\n            \n            if (tS2 == true)\n            {\n                hitSomething = true;\n                attenuation = vec3(0.3, 0.8, 0.6);\n                isSpecular = true;\n                emissionColor = vec3(0.0, 0.0, 0.0);\n                emissionStrength = 0.0;\n                specularRoughness = 0.0;\n            }\n        \n            if (tS3 == true)\n            {\n                hitSomething = true;\n                attenuation = vec3(0.9, 0.9, 0.9);\n                isSpecular = false;\n                emissionColor = vec3(0.0, 0.0, 0.0);\n                emissionStrength = 0.0;\n                specularRoughness = 0.0;\n            }\n            \n            if (tT1 == true)\n            {\n                hitSomething = true;\n                isSpecular = randomValue(rngState) < fresnelReflectAmount(1.0, 1.0, hInfo.normal, ry.dir, 0.0625, 1.0);\n                attenuation = isSpecular ? vec3(0.95) : texture(iChannel1, abs(ry.orig + (ry.dir * hInfo.dist)).xz / 128.0).xyz;\n                emissionColor = vec3(0.0, 0.0, 0.0);\n                emissionStrength = 0.0;\n                specularRoughness = 0.0625;\n            }\n            \n            if (tT2 == true)\n            {\n                hitSomething = true;\n                isSpecular = randomValue(rngState) < fresnelReflectAmount(1.0, 1.0, hInfo.normal, ry.dir, 0.0625, 1.0);\n                attenuation = isSpecular ? vec3(0.95) : texture(iChannel1, abs(ry.orig + (ry.dir * hInfo.dist)).xz / 128.0).xyz;\n                emissionColor = vec3(0.0, 0.0, 0.0);\n                emissionStrength = 0.0;\n                specularRoughness = 0.0625;\n            }\n            \n            if (tB1 == true)\n            {\n                hitSomething = true;\n                attenuation = (hInfo.normal * 0.5 + 0.5) * 0.95;//vec3(0.5, 0.5, 0.5);\n                isSpecular = true;\n                emissionColor = vec3(0.0, 0.0, 0.0);\n                emissionStrength = 0.0;\n                specularRoughness = 0.0;\n            }\n            \n            if (hitSomething == false)\n            {\n                float gradientVal = (ry.dir.y + 1.0) / 2.0;\n                vec3 emittedLight = mix(vec3(1.0), vec3(0.5, 0.7, 1.0), gradientVal);\n                incomingLight += emittedLight * rayColor;\n                break;\n            }\n            \n            ry.orig = ry.orig + (ry.dir * hInfo.dist);\n            \n            if (isSpecular == false) {\n                ry.dir = normalize(randomPointInSphere(vec3(0.0, 0.0, 0.0), 1.0, rngState) + hInfo.normal);\n            } else {\n                ry.dir = normalize(mix(reflect(ry.dir, hInfo.normal), normalize(randomPointInSphere(vec3(0.0, 0.0, 0.0), 1.0, rngState) + hInfo.normal), specularRoughness));\n            }\n            \n            //incomingLight = vec3(0.5);\n            //break;\n        \n            vec3 emittedLight = emissionColor * emissionStrength;\n            incomingLight += emittedLight * rayColor;\n            rayColor *= attenuation;\n        }\n        \n        avgRayPixCol += incomingLight;\n    }\n    \n    avgRayPixCol /= rayPerPix;\n    \n    vec4 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy);\n\n    //avgRayPixCol = mix(lastFrameColor, avgRayPixCol, 1.0);// / float(iFrame + 1));\n\n    fragColor = float((iMouse.z < 0.0) && (iFrame > 0)) * lastFrameColor + vec4(avgRayPixCol, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}