{"ver":"0.1","info":{"id":"mlfGDS","date":"1672653606","viewed":43,"name":"Flooded mountains","username":"Carl","description":"Raymarching","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float pos = 0.;\n\nfloat getKey(int keyCode) {\n    return texelFetch(iChannel0, ivec2(keyCode,0), 0).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 offset = texelFetch( iChannel0, ivec2(0,0), 0 ).xy;\n\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    cameraPos = CAM_POS;\n    mat4 rotationMat = trMat(vec3(offset.x, 0.,offset.y)) * trMat(vec3(2.,0.,-2.))\n        * rotYMat(-2.3) * rotYMat(-m.x * 8.5) * rotXMat(-1.19) * rotXMat(-m.y * 1.4 + 1.5);\n    cameraPos =  rotationMat * cameraPos;\n    vec4 rayDir = uvRayDirection(uv);\n    rayDir = rotationMat * rayDir;\n    \n    vec3 col = render(cameraPos.xyz, rayDir.xyz);\n    fragColor = vec4(col ,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//general\n#define MAX_STEPS 400\n#define MIN_DIST 0.01\n#define MAX_DIST 250.        //if bigger, the sky dissapears\n#define MARCH_QUALITY 0.5\n#define SHADOW_QUALITY 0.4    //1 is default, the lower the better quality\n#define NORMAL_QUALITY 0.001   //0.01 is default,  the lower the better quality\n\n//trees\n#define TREES_MAX_STEPS 250\n#define TREES_MIN_DIST 0.001\n#define TREES_MAX_DIST 50.\n#define TREE_MARCH_QUALITY 0.45\n#define TREES_DENSITY 0.22\n#define TREE_NORMAL_QUALITY 0.001\n#define TREE_SIZE vec3(0.085,0.3,0.085)\n\n#define CAM_POS vec4(0.0, 1.0, -6.0, 1.0)\n#define SUN_VEC1 normalize(vec3(0.7, 1.4, 0.5))\n\n#define SUN_VEC2 normalize(vec3(0.55, 0.8, 0.5))//y is height\n#define RED_MIRROR_COL vec3(0.78,0.32,0.23)\n#define DIRT_COL vec3(0.60,0.46,0.32)\n#define GRASS_COL vec3(0.34,0.6,.25)\n#define TREE_COL1 vec3(0.44,0.7,.35)\n#define TREE_COL2 vec3(0.74,0.7,.35)\n\n#define WATER_LEVEL -0.1 //-0.1 is default\n\nstruct RayHit\n{\n    float dist;\n};\n\nstruct Material\n{\n    vec3 color;\n    float roughness;\n    float reflectance;\n    float metallic;\n};\n\nvec4 cameraPos;\n\n//===========================================================================================\n//------------------------------------------ UTILS ------------------------------------------\n//===========================================================================================\nfloat hash13(vec3 point)\n{\n    return fract(sin(dot(point, vec3(129.45658, 37.6323, 68.2347))) * 31778.2563);\n}\n\nfloat hash12(vec2 point)\n{\n    return fract(sin(dot(point, vec2(129.45658, 37.6323))) * 31778.2563);\n}\n\nfloat hash11(float val)\n{\n    return fract(sin(val) * 14658.2353);\n}\n\nfloat linearstep(float edge0, float edge1, float x)\n{\n    return clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n}\n\nvec3 saturate(vec3 v)\n{\n\treturn clamp(v,vec3(0,0,0),vec3(1,1,1));\n}\n\nfloat saturate(float v)\n{\n\treturn clamp(v,0.,1.);\n}\n\nvec2 fade(vec2 t)\n{\n    return t * t * t * (t * (t * 6. - 15.) + 10.);\n}\nvec3 fade(vec3 t)\n{\n    return t * t * t * (t * (t * 6. - 15.) + 10.);\n}\n\nvec2 fadeDeriv(vec2 t)\n{\n    return 30.0 * t * t * (t * (t - 2.0) + 1.0);\n}\nvec3 fadeDeriv(vec3 t)\n{\n    return 30.0 * t * t * (t * (t - 2.0) + 1.0);\n}\n\nvec2 randomVector(vec2 point)\n{\n    float angle = hash12(point)* radians(360.);\n    return vec2(cos(angle), sin(angle));\n}\n\nvec3 randomVector(vec3 point)\n{\n    float angle = hash13(point)* radians(360.);\n    //float angle2 = hash13(point.zyx)* radians(360.);\n    return vec3(cos(angle), sin(angle), cos(angle));\n}\n\nfloat perlinNoise(vec2 uv)\n{\n    vec2 intPoint = floor(uv);\n    vec2 vec00 = randomVector(vec2(mod(intPoint+vec2(0.,0.),64.)));\n    vec2 vec01 = randomVector(vec2(mod(intPoint+vec2(1.,0.),64.)));\n    vec2 vec10 = randomVector(vec2(mod(intPoint+vec2(0.,1.),64.)));\n    vec2 vec11 = randomVector(vec2(mod(intPoint+vec2(1.,1.),64.)));\n    vec2 fractPoint = fract(uv);\n    vec2 fade = fade(fractPoint);\n    float dot00 = dot(vec00, fractPoint - vec2(0.0, 0.0));\n    float dot01 = dot(vec01, fractPoint - vec2(1.0, 0.0));\n    float dot10 = dot(vec10, fractPoint - vec2(0.0, 1.0));\n    float dot11 = dot(vec11, fractPoint - vec2(1.0, 1.0));\n        \n    return mix(mix(dot00, dot01, fade.x),\n        mix(dot10, dot11, fade.x),fade.y) * 1.414213;\n}\n\nvec3 perlinNoiseDeriv(vec2 uv)\n{\n    vec2 intPoint = floor(uv);\n    vec2 vec00 = randomVector(vec2(mod(intPoint+vec2(0.,0.),64.)));\n    vec2 vec01 = randomVector(vec2(mod(intPoint+vec2(1.,0.),64.)));\n    vec2 vec10 = randomVector(vec2(mod(intPoint+vec2(0.,1.),64.)));\n    vec2 vec11 = randomVector(vec2(mod(intPoint+vec2(1.,1.),64.)));\n    vec2 fractPoint = fract(uv);\n    vec2 fade = fade(fractPoint);\n    vec2 fadeDeriv = fadeDeriv(fractPoint);\n    float dot00 = dot(vec00, fractPoint - vec2(0.0, 0.0));\n    float dot01 = dot(vec01, fractPoint - vec2(1.0, 0.0));\n    float dot10 = dot(vec10, fractPoint - vec2(0.0, 1.0));\n    float dot11 = dot(vec11, fractPoint - vec2(1.0, 1.0));\n        \n    return vec3((dot00+fade.x*(dot01-dot00)+fade.y*(dot10-dot00)\n            +fade.x*fade.y*(dot00-dot01-dot10+dot11))*1.414213,\n            (vec00 + fade.x*(vec01-vec00) + fade.y*(vec10-vec00) + fade.x*fade.y*(vec00-vec01-vec10+vec11) +  // derivatives\n                 fadeDeriv * (fade.yx*(dot00-dot01-dot10+dot11) + vec2(dot01,dot10) - dot00))*1.414213);\n}\n\nfloat perlinNoise(vec3 point)//refactor\n{\n    vec3 intPoint = floor(point);\n    vec3 fractPoint = fract(point);\n \n    float dot000 = dot(randomVector(intPoint), fractPoint);\n\tfloat dot100 = dot(randomVector(intPoint + vec3(1.0, 0.0, 0.0)),\n                 fractPoint - vec3(1.0, 0.0, 0.0));\n\tfloat dot001 = dot(randomVector(intPoint + vec3(0.0, 0.0, 1.0)),\n                 fractPoint - vec3(0.0, 0.0, 1.0));\n\tfloat dot101 = dot(randomVector(intPoint + vec3(1.0, 0.0, 1.0)), \n                 fractPoint - vec3(1.0, 0.0, 1.0));\n\tfloat dot010 = dot(randomVector(intPoint + vec3(0.0, 1.0, 0.0)), \n                 fractPoint - vec3(0.0, 1.0, 0.0));\n\tfloat dot110 = dot(randomVector(intPoint + vec3(1.0, 1.0, 0.0)), \n                 fractPoint - vec3(1.0, 1.0, 0.0));\n\tfloat dot011 = dot(randomVector(intPoint + vec3(0.0, 1.0, 1.0)), \n                 fractPoint - vec3(0.0, 1.0, 1.0));\n\tfloat dot111 = dot(randomVector(intPoint + 1.0), fractPoint - 1.0);   \n    vec3 fade = fade(fractPoint);\n    \n    float y0 = mix(dot000, dot100, fade.x);\n    float y1 = mix(dot001, dot101, fade.x);\n    float y2 = mix(dot010, dot110, fade.x);\n    float y3 = mix(dot011, dot111, fade.x);   \n\tfloat z0 = mix(y0, y2, fade.y);\n    float z1 = mix(y1, y3, fade.y);    \n    return mix(z0, z1, fade.z);\n}\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nmat4 trMat(vec3 tr)\n{\n\treturn mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                tr.x, tr.y, tr.z, 1.0);\n}\n\nmat4 rotXMat(float angle)\n{\n\treturn mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, cos(angle), sin(angle), 0.0,\n                0.0, -sin(angle), cos(angle), 0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 rotYMat(float angle)\n{\n\treturn mat4(cos(angle), 0.0, sin(angle), 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                -sin(angle), 0.0, cos(angle), 0.0,\n                0.0, 0.0, 0.0, 1.0);  \n}\n\nmat4 rotZMat(float angle)\n{\n\treturn mat4(cos(angle), sin(angle), 0.0, 0.0,\n                -sin(angle), cos(angle), 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\nvec4 uvRayDirection(vec2 uv)\n{\n    return normalize(vec4(uv.xy, 1., 0.));\n}\n\n//===========================================================================================\n//------------------------------------------ SDFs -------------------------------------------\n//===========================================================================================\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat pol(float val)\n{\n    return 3.*val*val - 2.*val*val*val;\n}\n\nfloat sdSinCos(vec2 point)\n{\n    return sin(point.x) + cos(point.y);\n}\n\n//https://iquilezles.org/articles/ellipsoids/\nfloat sdbEllipsoidV2( in vec3 p, in vec3 r )\n{\n    float k1 = length(p/r);\n    float k2 = length(p/(r*r));\n    return k1*(k1-1.0)/k2;\n}\n\n//===========================================================================================\n//---------------------------------------------- SCENE --------------------------------------\n//===========================================================================================\n\nfloat fbmTree(vec3 point)\n{   \n    float dist = distance(cameraPos.xyz, point);\n    int distFactor = int(ceil(saturate((TREES_MAX_DIST - dist-10.)/(TREES_MAX_DIST-10.)) * 4.));\n\n    float height = 0.0;\n    float ex = exp2(-0.5);\n    float freq = 0.5;\n    float ampl = 1.5;\n    \n    mat4 rot = rotYMat(0.296);\n    vec4 p = vec4(point, 0.1);\n    for( int i=0; i<4; i++ )\n    {   \n        float noise = ampl*perlinNoise(freq*(rot * p).xyz*25.);\n        height += noise;      \n        freq *= 2.;\n        ampl *= -ex;       \n        if (i >= distFactor - 1)//LOD\n            break;\n    }\n    return height;\n}\n\nfloat fbm3(vec3 point, float ampScale, int octaves)\n{   \n    //float dist = distance(cameraPos.xyz, point);\n    //int distFactor = int(ceil(saturate((MAX_DIST - dist-100.)/(MAX_DIST-100.)) * float(octaves)));   \n    point *= 0.05;\n    float height = 0.0;\n    float freq = 1.;\n    float ampl = perlinNoise(point.xz * 0.15 + 0.45) * 43.;    \n    mat4 rot = rotYMat(0.296);\n    vec4 p = vec4(point, 0.1);\n    for( int i=0; i<octaves; i++ )\n    {   \n        float noise = ampl*perlinNoise(freq*(rot * p).xz);\n        //vec3 perlinDer = ampl*perlinNoiseDeriv(freq*(rot * p).xz);\n        //float noise = perlinDer.x;\n        height += noise;       \n        freq *= 2.;\n        ampl *= -0.45;\n        //if (i >= distFactor - 1)//LOD\n            //break;\n    }\n    return height;\n}\n\nvec3 fbm3D(vec3 point, float ampScale, int octaves)\n{   \n    //float dist = distance(cameraPos.xyz, point);\n    //int distFactor = int(ceil(saturate((MAX_DIST - dist-100.)/(MAX_DIST-100.)) * float(octaves)));   \n    point *= 0.05;\n    float height = 0.0;\n    float freq = 1.;\n    float ampl = perlinNoise(point.xz * 0.15 + 0.45) * 43.;    \n    mat4 rot = rotYMat(0.296);\n    vec4 p = vec4(point, 0.1);\n    vec2 deriv = vec2(0.);\n    for( int i=0; i<octaves; i++ )\n    {   \n        //float noise = ampl*perlinNoise(freq*(rot * p).xz);\n        vec3 perlinDer = ampl*perlinNoiseDeriv(freq*(rot * p).xz);\n        float noise = perlinDer.x;\n        deriv += perlinDer.yz * freq;\n        height += noise;       \n        freq *= 2.;\n        ampl *= -0.45;\n        //if (i >= distFactor - 1)//LOD\n            //break;\n    }\n    return vec3(height, deriv);\n}\n\nfloat terrain1(vec3 point)\n{\n    return point.y - fbm3(point, 2., 12);\n}\n\nfloat terrainSimple(vec3 point)\n{\n    return point.y - fbm3(point, 2., 8);\n}\n\nfloat scene1(vec3 point)\n{\n    float sphere1 = sdSphere(point + vec3(0.0, -1.0 * sin(1.), 0.0), 1.);\n    float torus = sdTorus(point + vec3(0.0, -0.0, 0.0), vec2(1.0, 1.0));\n    float plane = point.y;\n    float box = sdBox(point + vec3(0.0, -1.0, 4.0), vec3(1.0, 1.0, 1.0));  \n    float comb = opSmoothUnion(sphere1, torus, 0.5);\n    float sphere2 = sdSphere(point + vec3(0.0, -4.0 * sin(1.), 0.0), 1.);\n    return min(min(sphere2, comb), min(box,plane));\n}\n\nfloat sceneDist(vec3 point, int iterations)\n{\n    return point.y - fbm3(point, 2., iterations);\n}\n\nfloat sceneDistDeriv(vec3 point, int iterations, out vec3 normal)\n{\n    vec3 fbmRes = fbm3D(point, 2., iterations);\n    normal = normalize(vec3(-fbmRes.y,20.0,-fbmRes.z));   \n    return point.y - fbmRes.x;\n}\n\n//===========================================================================================\n//------------------------------------------ RAYMARCH ---------------------------------------\n//===========================================================================================\n\nvec3 raymarch(vec3 point, vec3 dir)\n{\n    float dist = 0.;\n    float currDist = 0.;\n    int i = 0;\n    float treeAreaDist = -100.;\n    float prevAreaDist = -100.;\n    float prevDist = 0.;\n    float treeCurrDist = 0.;\n    for (i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 currentPoint = point + dist * dir;\n        currDist = min(sceneDist(currentPoint, 12), currentPoint.y - WATER_LEVEL);\n        if (currDist <= 0.1 && treeAreaDist <  0.)\n        {\n            prevAreaDist = currDist;\n            treeAreaDist = dist;\n            treeCurrDist = currDist;\n        }\n            \n        dist +=  MARCH_QUALITY*currDist;\n        if (currDist < MIN_DIST || dist > MAX_DIST)\n            break;\n        prevDist = dist;\n    }\n    \n    if (i == MAX_STEPS)\n        return vec3(MAX_DIST, i, treeCurrDist);\n    return vec3(dist, treeAreaDist, treeCurrDist);\n}\n\nfloat treesDist(vec3 point, float terrainHeight, vec3 treeCenter)\n{\n    float m = TREES_DENSITY;\n    vec3 spherePos = abs(mod(point - m*0.5, m) - m*0.5);\n    //spherePos += vec3(0.05, 0., 0.);//randomize size here\n    spherePos.y = point.y + terrainHeight;\n    vec3 treeSize = TREE_SIZE;\n    //treeSize.x += (hash12(vec2(treeCenter.x, treeCenter.y))) * 0.005;\n    //treeSize.z += (hash12(vec2(treeCenter.y, treeCenter.z))) * 0.005;\n    //treeSize.y += (hash12(vec2(treeCenter.x, treeCenter.z))-0.5) * 0.3;\n    //return sdbEllipsoidV2(spherePos, TREE_SIZE);\n    return sdbEllipsoidV2(spherePos, TREE_SIZE) + fbmTree(point)*0.03;\n\n}\n\nvec3 calcTreeCenter(vec3 point)\n{\n    return vec3(point.x + TREES_DENSITY*0.5 - \n           mod(point.x + TREES_DENSITY*0.5, TREES_DENSITY), \n           0., point.z + TREES_DENSITY*0.5 - \n           mod(point.z + TREES_DENSITY*0.5, TREES_DENSITY));\n}\n\nvec3 calcNormal(vec3 point, int iterations, float cameraDist)\n{\n    //float distC = distance(cameraPos.xyz, point);\n    //int distFactor = int(ceil(saturate((MAX_DIST - distC)/(MAX_DIST)) * float(iterations))); \n    vec2 derivs = fbm3D(point, 2., iterations).yz;\n    return normalize( vec3(-derivs.x,20.0,-derivs.y));\n        \n    float dist = sceneDist(point, iterations);\n    vec2 shift = vec2(NORMAL_QUALITY * cameraDist, 0.0);\n    return normalize(dist - vec3 (sceneDist(point - shift.xyy, iterations),\n                sceneDist(point - shift.yxy, iterations), \n                sceneDist(point - shift.yyx, iterations)));\n}\n\nvec3 calcNormalTrees(vec3 point, vec3 offset, float cameraDist)\n{\n    vec3 centerPos = calcTreeCenter(point + offset);\n    float centerDist = sceneDist(centerPos, 10);\n    float dist = treesDist(point + offset, centerDist, centerPos);\n    vec2 shift = vec2(TREE_NORMAL_QUALITY, 0.0);\n    //vec2 shift = vec2(TREE_NORMAL_QUALITY * cameraDist, 0.0);\n    \n    vec3 centerPos1 = calcTreeCenter(point - shift.xyy + offset);\n    float centerDist1 = sceneDist(centerPos1, 10);\n    vec3 centerPos2 = calcTreeCenter(point - shift.yxy + offset);\n    float centerDist2 = sceneDist(centerPos2, 10);\n    vec3 centerPos3 = calcTreeCenter(point - shift.yyx + offset);\n    float centerDist3 = sceneDist(centerPos3, 10);\n        \n    return normalize(dist - vec3(treesDist(point - shift.xyy + offset, centerDist1, centerPos1),\n                treesDist(point - shift.yxy + offset, centerDist2, centerPos2), \n                treesDist(point - shift.yyx + offset, centerDist3, centerPos3)));\n}\n\nfloat mapTrees(vec3 point, out vec3 offset, out vec3 center, float cameraDist)\n{\n    vec3 trueCenter = calcTreeCenter(point);\n    offset = (vec3(hash12(vec2(trueCenter.z,trueCenter.x)), \n              0., hash12(vec2(trueCenter.x,trueCenter.z))) -0.5) * 0.2;\n    vec3 centerPos = calcTreeCenter(point + offset);\n    \n    //float centerDist = sceneDist(centerPos, 10);\n    vec3 normal;\n    float centerDist = sceneDistDeriv(centerPos, 10, normal);\n    center = centerPos;\n    center.y = centerDist;      \n    float dist = treesDist(point + offset, centerDist, centerPos);\n    \n    if (dist < 0.1 && (hash13(center) > (0.8 - smoothstep(1., 6., abs(center.y))*0.8) \n        || center.y > WATER_LEVEL || normal.y < 0.65))\n    {\n        return 0.1;\n    }\n    \n    return dist;\n}\n\nvec2 raymarchTrees(vec3 point, vec3 dir, vec3 terrainHit, float terrainDist, out vec3 offset, out vec3 center)\n{\n    float dist = 0.;\n    float currDist = 0.;\n    int i = 0;\n    offset = vec3(0.);\n    \n    for (i = 0; i < TREES_MAX_STEPS; i++)\n    {\n        vec3 currentPoint = point + dist * dir;       \n        currDist = mapTrees(currentPoint, offset, center, dist);       \n        dist +=  TREE_MARCH_QUALITY*currDist;\n        \n        if (dist > terrainDist + 0.5)\n            return vec2(MAX_DIST, i);       \n        if (currDist < TREES_MIN_DIST || dist > TREES_MAX_DIST)\n            break;\n    }\n    \n    if (i == TREES_MAX_STEPS || dist > (terrainDist + 0.1) || dist >= TREES_MAX_DIST)\n        return vec2(MAX_DIST, i);\n    return vec2(dist, i);\n}\n\nfloat schlickApprox(float f90, float dotHalfCam)\n{\n    return 1. + (f90 - 1.) * pow(1.-dotHalfCam, 5.);\n}\n\n//https://media.disneyanimation.com/uploads/production/publication_asset/48/asset/s2012_pbs_disney_brdf_notes_v3.pdf\nfloat burleyDiffuse(float dotLightHalf, float dotNLight, float dotNCam)\n{\n    float diffRoughness = 1.0;   \n    float fd90 = .5 + 2.*diffRoughness*dotLightHalf*dotLightHalf - 0.5;\n    return schlickApprox(fd90, dotNLight)*schlickApprox(fd90, dotNCam)*(1./3.1415);\n}\n\n//http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\nfloat cookTorranceSpecular(float dotNHalf, float dotNCam, float dotNLight, float dotHalfCam)\n{\n    float roughness = 1.0;\n    float specularRefl = 8.;\n    //G\n    float g1 = 2. * dotNHalf * dotNLight / dotHalfCam;\n    float g2 = 2. * dotNHalf * dotNCam / dotHalfCam;\n    float G = min(1., min(g1, g2));\n    //D\n    float dotNHalf2 = dotNHalf*dotNHalf;\n    float roughness2 = roughness*roughness;\n    float D = exp((dotNHalf2-1.)/(roughness2*dotNHalf2))/3.1415*roughness2*dotNHalf2*dotNHalf2;\n    //F\n    float F = specularRefl + (1. - specularRefl) * pow(1. - dotNCam, 5.);\n    return G*D*F/(4.*dotNCam*dotNLight);\n}\n\nfloat softShadow(vec3 point, vec3 lightVec, vec3 normal)\n{\n    float intensity = 1.0;\n    point = point + MIN_DIST*normal*2.;\n    float dist = MIN_DIST * 2.;\n    float prevDist = 1e20;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 currentPoint = point + dist * lightVec;\n        float currDist = sceneDist(currentPoint, 10);\n        \n        //-------- trees ---------\n        vec3 offset;\n        vec3 center;\n        currDist = min(currDist, mapTrees(currentPoint, offset, center, dist));\n              \n        if (currDist < MIN_DIST)\n            return 0.0;             \n        if ((dist + currDist) > MAX_DIST)\n            return intensity;           \n        //intensity = min(intensity, hardness*currDist/dist);  \n        float y = currDist*currDist/(2.0*prevDist);\n        float d = sqrt(currDist*currDist-y*y);\n        intensity = min( intensity, 10.0*d/max(0.0,dist-y) );\n        prevDist = currDist;            \n        dist +=  currDist* SHADOW_QUALITY;\n    }\n}\n\n// Karis 2014, \"Physically Based Material on Mobile\"\nvec2 prefilteredDFG_Karis(float roughness, float NoV) {\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\nfloat calcLightSoft(vec3 point, vec3 cameraPos, vec3 normal)\n{   \n    vec3 lightPos = vec3(5.0, 6.0, 0.0);\n    vec3 lightVec = normalize(lightPos - point);\n    lightVec = SUN_VEC2;\n    vec3 cameraVec = normalize(cameraPos - point);\n    vec3 halfVector = normalize( lightVec + cameraVec );\n    \n    float dotNHalf = max((dot(normal, halfVector)), 0.001);\n\tfloat dotNCam = max((dot(normal, cameraVec)), 0.001);\n\tfloat dotNLight = max((dot(normal, lightVec)), 0.);\n\tfloat dotHalfCam = max((dot(halfVector, cameraVec)), 0.001);\n    float dotLightHalf = saturate(dot(lightVec, halfVector));\n    \n    float specular = cookTorranceSpecular(dotNHalf, dotNCam, dotNLight, dotHalfCam); \n    float diffuse = burleyDiffuse(dotLightHalf, dotNLight, dotNCam); \n    \n    //blinn-phong\n    //float diffuse = saturate(dot(lightVec, normal));\n    //vec3 reflectionVec = -reflect(lightVec, normal);\n    //float specular = 0.2 * pow(saturate(dot(reflectionVec, cameraVec)), 8.);\n    \n    float intensity = softShadow(point, lightVec, normal);\n    //intensity = clamp(intensity, 0.1,1.);//ambient\n    intensity = clamp(intensity, 0.,1.);\n    intensity += 0.1;\n    return saturate(intensity * saturate(diffuse + specular) * dotNLight);//check out why this saturate is needed\n}\n\nvec3 skyColor(float y)\n{\n    return vec3(0.52,0.71,1.2) - 0.5*(y/MAX_DIST);\n}\n\nvec3 applyFog(float dist, vec3 pixelColor, vec3 fogColor, float strength)\n{\n    //vec3 ex = exp2(-strength * dist * vec3(1, 1.5, 3));\n    //return ex * pixelColor + (1. - ex) * fogColor;\n    float fogStr = 1.0-exp(-pow(strength*dist,1.45));\n    vec3 fogCol = 0.72*fogColor;\n    return mix(pixelColor,fogCol,fogStr);\n}\n\nvec3 applyReflections(vec3 sceneCol, vec3 pixelColor, vec3 normal, vec3 hitPoint\n    , vec3 rayDir, vec3 camPos, float dist)\n{\n    vec3 reflDir = reflect(rayDir.xyz, normal);\n    hitPoint += normal*MIN_DIST*2.;\n    float reflectionDist = raymarch(hitPoint, reflDir).x;\n    vec3 reflHitPoint = hitPoint + reflDir * reflectionDist;\n    vec3 reflNormal = calcNormal(reflHitPoint, 10, dist); \n    float reflIntensity = calcLightSoft(reflHitPoint, camPos.xyz, reflNormal);   \n    float metallic = 1.0;\n    float reflectionRoughness = 1.0;\n    vec3 f0 = 0.04 * (1.0 - metallic) + sceneCol * metallic;\n    float dotNCam = max((dot(normal, normalize(camPos - hitPoint))), 0.001);\n    vec2 dfg = prefilteredDFG_Karis(reflectionRoughness, dotNCam);\n    vec3 reflSpecular = f0 * dfg.x + dfg.y;\n    vec3 reflColor = reflIntensity* sceneCol;\n    return pixelColor + reflSpecular * reflColor;\n}\n\nvec3 render(vec3 camPos, vec3 rayDir)\n{\n    vec3 color;\n    vec3 sceneCol = DIRT_COL;\n    vec3 raymarchResult = raymarch(camPos, rayDir);\n    float dist = raymarchResult.x;       \n    vec3 hitPoint = camPos.xyz + rayDir.xyz * dist;\n    vec3 normal = calcNormal(hitPoint, 12, dist); \n       \n    //-------- trees --------\n    vec3 treeAreaHitPoint = camPos.xyz + rayDir.xyz * raymarchResult.y;\n    vec3 offset, center;   \n    float treeDist = raymarchTrees(camPos, rayDir, treeAreaHitPoint,\n                     max(raymarchResult.y, dist), offset, center).x;\n    if (treeDist < TREES_MAX_DIST)\n    {\n        vec3 treeHitPoint = camPos.xyz + rayDir.xyz * treeDist;\n        vec3 treeNormal = calcNormalTrees(treeHitPoint, offset, treeDist);\n        hitPoint = treeHitPoint;\n        normal = treeNormal;\n    }\n    else\n    {\n        //------- water --------\n        if (hitPoint.y <= WATER_LEVEL + 0.1)\n        {\n            color = applyReflections(vec3(0.0, 0.4, 0.5),vec3(0.0, 0.4, 0.5),\n                    vec3(0.,1.,0), hitPoint,rayDir,camPos,dist);      \n            return applyFog(min(treeDist,dist), color, vec3(0.4, 0.65, 0.95), 0.04);;\n        }\n\n        if (dist >= MAX_DIST)//pass this to reflections\n            return skyColor((camPos.xyz + rayDir.xyz * MAX_DIST).y);\n    }\n    \n    float lightIntensity = calcLightSoft(hitPoint, camPos.xyz, normal);\n    if (treeDist < TREES_MAX_DIST)\n    {\n        lightIntensity += 0.025;//tree ambient TODO add this to trees shadows\n        vec3 treeCol = mix(TREE_COL1, TREE_COL2, hash13(offset));\n        color = treeCol * clamp(lightIntensity, 0.0, 1.);\n    }\n    else\n    {\n        treeDist = dist;\n        color = lightIntensity* sceneCol;\n        if (abs(normal.y) > 0.6)\n            color = lightIntensity* mix(DIRT_COL, GRASS_COL, normal.y* 0.8);\n        if (hitPoint.y > 2.8)\n            color += lightIntensity*vec3(1.,1.,1.)*0.6*(hitPoint.y - 2.8);\n    }  \n    \n    color = applyFog(min(treeDist,dist), color, vec3(0.4, 0.65, 0.95), 0.04);      \n    color = pow( color, vec3(0.85) );//gamma\n    return color;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_W = 87;\nconst int KEY_S = 83;\nconst int KEY_A = 65;\nconst int KEY_D = 68;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 offset = texelFetch( iChannel0, ivec2(0, 0), 0).xy;  \n    float speed = 0.5;   \n    vec2 up = texelFetch(iChannel1, ivec2(KEY_W,0), 0).x * vec2(-1, 0);\n    vec2 down = texelFetch(iChannel1, ivec2(KEY_S,0), 0).x * vec2(1, 0);\n    vec2 left = texelFetch(iChannel1, ivec2(KEY_A, 0), 0).x * vec2(0, -1);\n    vec2 right = texelFetch(iChannel1, ivec2(KEY_D, 0), 0).x * vec2(0, 1);\n    offset += (up + down + left + right) * speed;\n    fragColor = vec4(offset, 0, 0);\n}","name":"Buffer A","description":"","type":"buffer"}]}