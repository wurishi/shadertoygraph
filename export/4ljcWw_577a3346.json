{"ver":"0.1","info":{"id":"4ljcWw","date":"1508812268","viewed":446,"name":"Atmosphere Scattering Optimized","username":"bobcao3","description":"Adapted from https://www.shadertoy.com/view/ldS3Wm\n\nAn optimized version, uses much less samples (32 times less iterations, similar result)","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","scattering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ============\nconst float R0 = 600e3;\nconst float Ra = 670e3;\nconst int steps = 2;\nconst int stepss = 2;\nconst float g = .76;\nconst float g2 = g * g;\nconst float Hr = 15e3;\nconst float Hm = 2.6e3;\nconst vec3 I = vec3(10.0);\n\n#define t iTime\n\nconst vec3 C = vec3(0., -R0, 0.);\nconst vec3 bM = vec3(31e-6);\nconst vec3 bR = vec3(5.8e-6, 13.5e-6, 33.1e-6);\nvec3 Ds = normalize(vec3(0., .09, -1.));\n\n\nvoid densities(in vec3 pos, out float rayleigh, out float mie) {\n\tfloat h = length(pos - C) - R0;\n\trayleigh =  exp(-h/Hr);// + exp(-max(0.0, (h - 35e3)) /  5e3) * exp(-max(0.0, (35e3 - h)) / 15e3) * 0.2;\n\tmie = exp(-h/Hm);\n}\n\nfloat escape(in vec3 p, in vec3 d, in float R) {\n\tvec3 v = p - C;\n\tfloat b = dot(v, d);\n\tfloat c = dot(v, v) - R*R;\n\tfloat det2 = b * b - c;\n\tif (det2 < 0.) return -1.;\n\tfloat det = sqrt(det2);\n\tfloat t1 = -b - det, t2 = -b + det;\n\treturn (t1 >= 0.) ? t1 : t2;\n}\n\n// this can be explained: http://www.scratchapixel.com/lessons/3d-advanced-lessons/simulating-the-colors-of-the-sky/atmospheric-scattering/\nvec3 scatter(vec3 o, vec3 d) {\n\tfloat L = escape(o, d, Ra);\t\n\tfloat mu = dot(d, Ds);\n\tfloat opmu2 = 1. + mu*mu;\n\tfloat phaseR = .0596831 * opmu2;\n\tfloat phaseM = .1193662 * (1. - g2) * opmu2 / ((2. + g2) * pow(1. + g2 - 2.*g*mu, 1.5));\n\t\n\tfloat depthR = 0., depthM = 0.;\n\tvec3 R = vec3(0.), M = vec3(0.);\n    \n    float u0 = -(L - 100.0) / (1.0 - exp2(float(steps)));\n    \n\tfor (int i = 0; i < steps; ++i) {\n        float dl = u0 * exp2(float(i));\n\t\tfloat l = - u0 * (1.0 - exp2(float(i + 1)));\n\t\tvec3 p = o + d * l;\n\n\t\tfloat dR, dM;\n\t\tdensities(p, dR, dM);\n\t\tdR *= dl; dM *= dl;\n\t\tdepthR += dR;\n\t\tdepthM += dM;\n\n\t\tfloat Ls = escape(p, Ds, Ra);\n\t\tif (Ls > 0.) {\n\t\t\tfloat dls = Ls / float(stepss);\n\t\t\tfloat depthRs = 0., depthMs = 0.;\n\t\t\tfor (int j = 0; j < stepss; ++j) {\n\t\t\t\tfloat ls = float(j) * dls;\n\t\t\t\tvec3 ps = p + Ds * ls;\n\t\t\t\tfloat dRs, dMs;\n\t\t\t\tdensities(ps, dRs, dMs);\n\t\t\t\tdepthRs += dRs;\n\t\t\t\tdepthMs += dMs;\n\t\t\t}\n            depthRs *= dls;\n            depthMs *= dls;\n\t\t\t\n\t\t\tvec3 A = exp(-(bR * (depthRs + depthR) + bM * (depthMs + depthM)));\n\t\t\tR += A * dR;\n\t\t\tM += A * dM;\n\t\t} else {\n\t\t\treturn vec3(0.);\n\t\t}\n\t}\n\t\n\treturn I * (R * bR * phaseR + M * bM * phaseM);\n}\n\nvoid ACEStonemap(inout vec3 color) {\n\tconst float a = 2.51f;\n\tconst float b = 0.03f;\n\tconst float c = 2.43f;\n\tconst float d = 0.59f;\n\tconst float e = 0.14f;\n\tcolor = (color*(a*color+b))/(color*(c*color+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tDs = normalize(vec3(iMouse.x / iResolution.x - .5, sin(t * 0.5), cos(t * 0.5)));\n\t\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n\tuv.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 O = vec3(0., 0., 0.);\n\tvec3 D = normalize(vec3(uv, -2.));\n\t\n\tfloat att = 1.;\n    if (D.y < 0.0) {\n        D.y = 0.0016 / (-D.y + 0.04) - 0.04;\n    }\n\n    vec3 color = att * scatter(O, D);\n\tACEStonemap(color);\n\tfragColor = vec4(pow(color, vec3(.454545)), 1.);\n}","name":"Image","description":"","type":"image"}]}