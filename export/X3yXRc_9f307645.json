{"ver":"0.1","info":{"id":"X3yXRc","date":"1720239242","viewed":52,"name":"minion","username":"rahul897","description":"despicable me 4","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["minionraymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.12, .35, .52);\nconst vec3 COLOR_AMBIENT = vec3(0.42, 0.20, 0.1);\n\nstruct Material{\n    vec3 diffuseColor;\n    vec3 ambientColor;\n    vec3 specularColor;\n    float alpha;\n};\n\nstruct Surface{\n    float sd;\n    Material mat;\n};\n\nSurface opUnion(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2;\n  return obj1;\n}\n\nSurface opIntersection(Surface obj1, Surface obj2) {\n  if (obj2.sd > obj1.sd) return obj2;\n  return obj1;\n}\n\nSurface opSmoothUnion( Surface d1, Surface d2, float k ) {\n    Surface s;\n    float h = clamp( 0.5 + 0.5*(d2.sd-d1.sd)/k, 0.0, 1.0 );\n    s.sd = mix( d2.sd, d1.sd, h ) - k*h*(1.0-h);\n    s.mat.diffuseColor = mix( d2.mat.diffuseColor, d1.mat.diffuseColor, h ) - k*h*(1.0-h);\n    s.mat.ambientColor = mix( d2.mat.ambientColor, d1.mat.ambientColor, h ) - k*h*(1.0-h);\n    s.mat.specularColor = mix( d2.mat.specularColor, d1.mat.specularColor, h ) - k*h*(1.0-h);\n    s.mat.alpha = mix( d2.mat.alpha, d1.mat.alpha, h ) - k*h*(1.0-h);\n    return s;\n}\n\nSurface opSmoothIntersection( Surface d1, Surface d2, float k ) {\n    Surface s;\n    float h = clamp( 0.5 - 0.5*(d2.sd-d1.sd)/k, 0.0, 1.0 );\n    s.sd = mix( d2.sd, d1.sd, h ) - k*h*(1.0-h);\n    s.mat.diffuseColor = mix( d2.mat.diffuseColor, d1.mat.diffuseColor, h ) - k*h*(1.0-h);\n    s.mat.ambientColor = mix( d2.mat.ambientColor, d1.mat.ambientColor, h ) - k*h*(1.0-h);\n    s.mat.specularColor = mix( d2.mat.specularColor, d1.mat.specularColor, h ) - k*h*(1.0-h);\n    s.mat.alpha = mix( d2.mat.alpha, d1.mat.alpha, h ) - k*h*(1.0-h);\n    return s;\n}\n\nMaterial yellow() {\n  vec3 aCol =  vec3(0.9, 0.9, 0);\n  vec3 dCol = 0.4 * vec3(0.7, 0.7, 0);\n  vec3 sCol = 0.02 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial blue() {\n  vec3 aCol =  vec3(0.0, 0.1, 0.8);\n  vec3 dCol = 0.3 * vec3(0., 0.1, 0.7);\n  vec3 sCol = 0.02 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial red() {\n  vec3 aCol =  vec3(0.7, 0.0, 0.1);\n  vec3 dCol = 0.3 * vec3(0.7, 0.1, 0.);\n  vec3 sCol = 0.02 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial white() {\n  vec3 aCol =  vec3(1);\n  vec3 dCol = 0.3 * vec3(1);\n  vec3 sCol = 0.02 * vec3(1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial black() {\n  vec3 aCol =  vec3(0.1);\n  vec3 dCol = 0.3 * vec3(0.1);\n  vec3 sCol = 0.02 * vec3(1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial gold() {\n  vec3 aCol = 0.5 * vec3(0.7, 0.5, 0);\n  vec3 dCol = 0.6 * vec3(0.7, 0.7, 0);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial silver() {\n  vec3 aCol = 0.4 * vec3(0.8);\n  vec3 dCol = 0.5 * vec3(0.7);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial checkerboard(vec3 p) {\n  vec3 aCol = vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0)) * 0.3;\n  vec3 dCol = vec3(0.3);\n  vec3 sCol = vec3(0);\n  float a = 1.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nmat3 camera(vec3 ro, vec3 lp){\n    vec3 cd = normalize(lp - ro);\n    vec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n    vec3 cu = normalize(cross(cd, cr));\n\n    return mat3(-cr, cu, -cd);\n}\n\nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nSurface sfFloor(vec3 p){\n    return Surface(p.y+2., checkerboard(p));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCylinderxy( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinderxz( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nSurface sfSpec(vec3 p){\n    vec3 x =vec3(0., 0.05, 0.4);\n    Surface res = Surface(sdCylinderxy(p-x, 0.2, 0.3), silver());\n    Surface r2 = Surface(-sdCylinderxy(p-x, 0.21, 0.23), silver());\n    Surface band = Surface(sdCylinderxz(p-vec3(0.,0.06,0.), 0.07, 0.5)-0.01, black());\n    res = opIntersection(r2, res);\n    res = opUnion(res, band);\n    return res;\n}\n\nSurface sfHand(vec3 p){\n    vec3 ep;\n    if(p.x<0.){\n      ep = vec3(0.35,0.2+ 0.2*sin(iTime*5.), 0.);\n    } else {\n      ep = vec3(0.1,-0.4, 0.);\n    }\n    p.x = abs(p.x);\n    p = p-vec3(0.525,-0.655,0.);\n    Surface res = Surface(sdCapsule(p, vec3(0., 0., 0.), ep, 0.08), yellow());\n    Surface glove = Surface(sdSphere(p, 0.15, ep), black());\n    res = opUnion(res, glove);\n    return res;\n}\n\nSurface sfLeg(vec3 p){\n    p.x = abs(p.x);\n    p = p-vec3(0.1,-0.9,0.);\n    Surface res = Surface(sdCapsule(p, vec3(0.05, -0.4, 0.), vec3(0.,0.3, 0.), 0.1), blue());\n    Surface shoe = Surface(sdCapsule(p, vec3(0.05, -0.5, -0.02), vec3(0.2,-0.5, 0.2), 0.1), black());\n    res = opUnion(res, shoe);\n    return res;\n}\n\nSurface sfBody(vec3 p){\n    Surface b1 = Surface(sdCapsule(p, vec3(0., -0.6, 0.), vec3(0., 0., 0.), 0.5), yellow());\n    Surface b3 = Surface(sdCapsule(p, vec3(0., -0.8, 0.), vec3(0., 0., 0.), 0.53), blue());\n    Surface b4 = Surface(-sdSphere(p, 0.65, vec3(0.,0.,0.12)), blue());\n    Surface b5 = Surface(-sdSphere(p, 0.65, vec3(0)), blue());\n    Surface b2 = Surface(-sdBox(p- vec3(0.,-1.8,0.),vec3(0.8, 0.7, 0.9)), blue());\n    Surface bs1 = Surface(-sdBox(p- vec3(0.,-0.65,0.),vec3(0.8, 0.15, 0.25))+0.02, blue());\n    Surface res2 = opIntersection(b4, b3);\n    res2 = opIntersection(res2,b5);\n    res2 = opIntersection(res2, b2);\n    res2 = opIntersection(res2, bs1);\n    Surface mouth = Surface(-sdEllipsoid(p -vec3(0.,-0.4,0.4), vec3(0.1+0.05*cos(iTime*5.),0.05,0.2)), red());\n    b1 = opIntersection(b1, mouth);\n    Surface teeth = Surface(sdCylinderxz(p -vec3(0.,-0.38,0.33) , 0.03, 0.15), white());\n    b1 = opUnion(b1, teeth);\n\n    Surface res = opUnion(b1, res2);\n    return res;\n}\n\nSurface sfEye(vec3 p){\n    vec3 x =vec3(0., 0.05, 0.4);\n    Surface res = Surface(sdCylinderxy(p-x, 0.15, 0.23), white());\n    Surface r2 = Surface(sdCylinderxy(p-x, 0.151, 0.1), black());\n    res = opUnion(r2, res);\n    return res;\n}\n\nSurface sfMinion(vec3 p){\n    Surface sb = sfBody(p);\n    Surface spec = sfSpec(p);\n    Surface eye = sfEye(p);\n    Surface hand = sfHand(p);\n    Surface leg = sfLeg(p);\n\n    Surface res = opUnion(sb, spec);\n    res = opUnion(res, hand);\n    res = opUnion(res, leg);\n    res = opUnion(res, eye);\n\n    return res;\n}\n\nSurface scene(vec3 p){\n    Surface sf = sfFloor(p);\n\n    Surface sm = sfMinion(p-vec3(0));\n\n    return opUnion(sf, sm);\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy).sd +\n      e.yyx * scene(p + e.yyx).sd +\n      e.yxy * scene(p + e.yxy).sd +\n      e.xxx * scene(p + e.xxx).sd);\n}\n\nSurface rayMarch(vec3 ro, vec3 rd){\n    float depth = MIN_DIST;\n    Surface res;\n\n    for (int i=0;i<MAX_MARCHING_STEPS;i++){\n        vec3 p = ro+rd*depth;\n        res = scene(p);\n        depth += res.sd;\n        if(depth<MIN_DIST || depth>MAX_DIST) break;\n    }\n    res.sd = depth;\n    return res;\n}\n\n\nvec3 phong(vec3 lightDir, vec3 normal, vec3 rd, Material mat) {\n  // ambient\n  vec3 ambient = mat.ambientColor;\n\n  // diffuse\n  float dotLN = clamp(dot(lightDir, normal), 0., 1.);\n  vec3 diffuse = mat.diffuseColor * dotLN;\n\n  // specular\n  float dotRV = clamp(dot(reflect(lightDir, normal), -rd), 0., 1.);\n  vec3 specular = mat.specularColor * pow(dotRV, mat.alpha);\n\n  return ambient + diffuse ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n\n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0); // lookat point\n  vec3 ro = vec3(0, 0, 4); // ray origin that represents camera position\n  ro = vec3(4.*cos(iTime/2.), 1.*abs(sin(iTime/2.)), 4.*abs(sin(iTime/2.)));\n\n\n  // float cameraRadius = 2.;\n  // ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  // ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n  \n  Surface s = rayMarch(ro, rd);\n  if(s.sd>MAX_DIST){\n    col= COLOR_BACKGROUND;\n  } else {\n    vec3 p = ro+rd*s.sd;\n    vec3 normal = calcNormal(p);\n\n    vec3 lightPosition1 = vec3(0, 2, 3);\n    vec3 lightDirection1 = normalize(lightPosition1 - p);\n    float lightIntensity1 = 1.;\n\n    col = lightIntensity1 * phong(lightDirection1, normal, rd, s.mat);\n    // col = lightIntensity1 * clamp(dot(lightDirection1, normal), 0., 1.) * vec3(0.2,0.2,0.2) ;\n  }\n\n  fragColor = vec4(col,1.0); // Output to screen\n}\n","name":"Image","description":"","type":"image"}]}