{"ver":"0.1","info":{"id":"ddj3W3","date":"1668273491","viewed":297,"name":"Abstract City","username":"Poisson","description":"A test of my pathtraced clouds.","likes":21,"published":1,"flags":32,"usePreview":1,"tags":["3d","raymarching","noise","ray","volume","raymarch","fbm","gi","cloud","color","raymarcher","path"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 col = data.rgb/data.a;\n      \n    // color grade\n    col = pow(col, vec3(.8,.95,.86));\n    col = mix(col, dot(col, vec3(1))/vec3(3), -.75); // boost the saturation\n    \n    // vignette\n    vec2 p = fragCoord/iResolution.xy;\n    col *= .2+.8*pow(64. * p.x*p.y*(1.-p.x)*(1.-p.y), .1);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float seed; // randoms seed\n\n// hash funcions by me\nfloat hash1() {return fract(sin(seed+=.1)*4561.7564);}\n\nvec2 hash2() {return fract(sin(seed+=.1)*vec2(8472.5636,9854.4213));}\n\nvec3 hash3() {return fract(sin(seed+=.1)*vec3(7653.1285,6912.8512,5914.7134));}\n\n// generate normalized random 3d vector\nvec3 uniformVector() {\n    vec3 v = hash3()*2.-1.;\n    return normalize(v);\n}\n\n// diffuse BRDF\nvec3 cosineDirection(vec3 n) {\n  \tvec2 r = hash2();\n    \n\tvec3 u = normalize(cross(n, vec3(0,1,1)));\n\tvec3 v = cross(u, n);\n\t\n\tfloat ra = sqrt(r.y);\n\tfloat rx = ra*cos(2.*3.141592*r.x); \n\tfloat ry = ra*sin(2.*3.141592*r.x);\n\tfloat rz = sqrt(1.-r.y);\n\treturn normalize(rx*u + ry*v + rz*n);\n}\n\n// hash21\nfloat hash(vec2 p) {\n    p = fract(p*vec2(345.193,493.184));\n    p += dot(p, p+123.547);\n    return fract(p.x*p.y);\n}\n\n// noise function by me\nfloat noise(vec2 p) {\n    vec2 q = floor(p);\n    vec2 f = fract(p);\n    f = f*f*(3.-2.*f);\n    return mix(mix(hash(q+vec2(0)),hash(q+vec2(1,0)),f.x),\n               mix(hash(q+vec2(0,1)),hash(q+vec2(1,1)),f.x),f.y);\n}\n\n// fractal noise\nfloat fbm(vec2 p) {\n    float a = .3;\n    mat2 m = mat2(cos(a),-sin(a),sin(a),cos(a)); // rotation matrix\n    float f = 0.;\n    f += noise(p); p *= m;\n    f += .5*noise(p*2.); p *= m;\n    f += .25*noise(p*4.); p *= m;\n    f += .2*noise(p*8.); p *= m;\n    f += .15*noise(p*16.); p *= m;\n    return f/2.;\n}\n\n// box SDF\nfloat sdBox(vec3 p, vec3 s) {\n    vec3 q = abs(p) - s;\n    return length(max(q,0.))+min(0.,max(q.x,max(q.y,q.z)));\n}\n\n// scene\nfloat map(vec3 p) {\n    float d = 1e10;\n    \n    d = min(d, (p.y+2.*fbm(p.xz)-.1)*.5+.3*hash1()); // clouds\n    \n    d = min(d, sdBox(p-vec3(0,-.3,0), vec3(.5,1,.5)));\n    d = min(d, sdBox(p-vec3(0,.8,0), vec3(.4,.1,.4)));\n    d = min(d, sdBox(p-vec3(0,1,0), vec3(.3,.1,.3)));\n    d = min(d, sdBox(p-vec3(0,1.2,0), vec3(.2,.1,.2)));\n    d = min(d, sdBox(p-vec3(0,1.4,0), vec3(.1,.1,.1)));\n    d = min(d, sdBox(p-vec3(0,1.6,0), vec3(.02,.15,.02)));\n    \n    d = min(d, sdBox(p-vec3(1,-.6,1.3), vec3(.4,1,.4)));\n    d = min(d, sdBox(p-vec3(1,.45,1.3), vec3(.3,.05,.3)));\n    \n    d = min(d, sdBox(p-vec3(-.6,-.8,1.9), vec3(.35,.6,.35)));\n    d = min(d, sdBox(p-vec3(-.6,-.15,1.9), vec3(.25,.05,.25)));\n    \n    d = min(d, sdBox(p-vec3(-.4,-.9,-1.7), vec3(.35,1,.35)));\n    d = min(d, sdBox(p-vec3(-.4,.15,-1.7), vec3(.25,.05,.25)));\n    \n    d = min(d, sdBox(p-vec3(.7,-.9,-1.15), vec3(.3,1,.3)));\n    d = min(d, sdBox(p-vec3(.7,.15,-1.15), vec3(.2,.05,.2)));\n    \n    d = min(d, sdBox(p-vec3(-1.3,-.9,.35), vec3(.3,.65,.3)));\n    d = min(d, sdBox(p-vec3(-1.3,-.2,.35), vec3(.2,.05,.2)));\n\n    return d;\n}\n\n// raymarching loop\nfloat intersect(vec3 ro, vec3 rd) {\n    float t = 0.;\n    for (int i=0; i<256 && t<24.; i++) {\n        vec3 p = ro + rd*t;\n        float h = map(p);\n        if (h<.0001) break;\n        t += h;\n    }\n    return t;\n}\n\n// shadow function\nfloat shadow(vec3 ro, vec3 rd) {\n    for (float t=0.; t<12.;) {\n        vec3 p = ro + rd*t;\n        float h = map(p);\n        if (h<.001) return 0.;\n        t += h;\n    }\n    return 1.;\n}\n\nvec3 calcNormal(vec3 p) {\n    float h = map(p);\n    const vec2 e = vec2(.0001,0);\n    return normalize(h - vec3(map(p-e.xyy),\n                              map(p-e.yxy),\n                              map(p-e.yyx)));\n}\n\n// rendering function\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 sunDir = normalize(vec3(1,1.7,1)+.05*uniformVector()); // sun direction\n    vec3 sunCol = vec3(1,.9,.6);\n    \n    vec3 col = vec3(0);\n    vec3 emit = vec3(1);\n    \n    vec3 trd = rd; // save the first ray direction\n    float tt = 24.;\n    \n    for (int i=0; i<10; i++) { // GI bounces\n        float t = intersect(ro, rd);\n        if (i==0) tt = t;\n        if (t<24.) {\n            vec3 p = ro + rd*t; // point on surface\n            vec3 n = calcNormal(p); // surface normal\n            \n            // coloring\n            vec3 mat = .5+.5*vec3(noise(p.xz),noise(2.*p.xz+5345.376),noise(2.*p.xz-9325.34));\n            emit *= mix(mat,vec3(1),smoothstep(-.2,.2,p.y+.2));\n            \n            ro = p+n*.01;\n            rd = cosineDirection(n);\n            \n            float dif = clamp(dot(n, sunDir), 0., 1.); // diffuse light\n            float sha = shadow(ro, sunDir); // shadow\n            \n            col += emit*4.*sunCol*dif*sha; // sun light\n            \n            // sky light\n            sha = shadow(ro, rd);\n            col += emit*.2*vec3(.6,.8,1)*sha;\n        } else {\n            break;\n        }\n    }\n    // fog\n    vec3 fog = 1.-exp(-tt*tt*tt*.0003*vec3(.5,.7,1));\n    col = mix(col, 2.*mix(vec3(.8,.9,1),vec3(.5,.7,1),.5+.5*rd.y), fog);\n    // sun glare\n    col += sunCol*12.*pow(clamp(dot(trd, sunDir),0.,1.),4.);\n        \n    return col;\n}\n\n// camera matrix\nmat3 setCamera(vec3 ro, vec3 ta) {\n    vec3 w = normalize(ta - ro);\n    vec3 u = normalize(cross(w, vec3(0,1,0)));\n    vec3 v = cross(u, w);\n    return mat3(u, v, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = iTime+dot(sin(fragCoord),vec2(443.712,983.234)); // init randoms seed\n    seed += hash1()*434.251;\n    \n    vec2 of = hash2()-.5; // antialiasing offset\n    vec2 p = (fragCoord+of - .5*iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(-3.4,1.5,.8); // ray origin\n    vec3 ta = vec3(0); // target\n    mat3 ca = setCamera(ro, ta); // camera matrix\n    \n    vec3 rd = ca * normalize(vec3(p,1)); // ray direction\n\n    vec3 col = render(ro, rd);\n    col = col*1.4/(1.+col); // tonemapping\n\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    data += vec4(col,1);\n\n    // output\n    fragColor = data;\n}","name":"Buffer A","description":"","type":"buffer"}]}