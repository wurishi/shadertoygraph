{"ver":"0.1","info":{"id":"cly3Wd","date":"1685044715","viewed":122,"name":"infinit cube wave","username":"ChGrenier","description":"My first test of rendering using raymarching","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* raymarching rendering based on jlfwong tutorial\n * https://www.shadertoy.com/user/jlfwong\n * https://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n */\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.;\nconst float MAX_DIST = 100.;\nconst float EPSILON = 0.0005;\nconst float PRECISION = 0.001;\n\n\n\n\n\nvec2 SDFscene(vec3 sampleCoords) \n{\n    sampleCoords.xz -= vec2(2.4,2.1)*iTime;\n    \n    vec3 position = sampleCoords;\n    float base = 0.24;\n    float space = 0.08;\n    \n    float box_tot_size = base + space;\n    \n    vec2 box_id = floor((sampleCoords.xz+box_tot_size)/(2.*box_tot_size));\n    float MatId = length(hash(vec3(box_id.x, space, box_id.y)));\n    \n    \n    position.y += 0.12*sin(box_id.x - box_id.y + 1.2*iTime);\n    position.y += 0.15*cos(box_id.x + box_id.y + 0.8*iTime);\n    \n    position.xz = OpRepetition(position.xz, 2.*box_tot_size);\n    \n    float radius = base * (0.5 * cos(0.8*iTime+3.14) + 0.5);\n    \n    float box = sdRoundBox(position, vec3(base-radius), radius);\n    \n    \n    return vec2(box, MatId);\n}\n\n\n\n\n\nmat3 TexturesScene(float MatId)\n{\n    vec3 K_a = vec3(.1);\n    vec3 K_d = normalize(hash(vec3(MatId, 0.24*MatId, 1.2*MatId)));\n    float K_s = 1.;\n    float shininess = 1.;\n    \n    \n    return mat3(K_a, K_d, vec3(K_s, shininess, 0.));\n\n}\n\n\n\n\n\n\n\nvec2 shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end)\n{\n    float depth = start;\n    vec2 surfaceInformation;\n    vec3 marchingPos;\n    \n    for(int i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n        marchingPos = eye + depth * marchingDirection;\n        surfaceInformation = SDFscene(marchingPos);\n        \n        depth += surfaceInformation.x;\n        \n        if(surfaceInformation.x < EPSILON || depth > end) break;\n    }\n    \n    surfaceInformation.x = depth;\n    \n    return surfaceInformation;\n}\n\n\n\n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord)\n{\n    vec2 xy = fragCoord - size / 2.;\n    float z = size.y / tan(radians(fieldOfView)/2.);\n    return normalize(vec3(xy,-z));\n}\n\n\n\n\nvec3 estimateNormal(vec3 sampleCoords)\n{\n    float dSDFdx = SDFscene(vec3(sampleCoords.x + EPSILON, sampleCoords.y, sampleCoords.z)).x - SDFscene(vec3(sampleCoords.x - EPSILON, sampleCoords.y, sampleCoords.z)).x;\n    float dSDFdy = SDFscene(vec3(sampleCoords.x, sampleCoords.y + EPSILON, sampleCoords.z)).x - SDFscene(vec3(sampleCoords.x, sampleCoords.y - EPSILON, sampleCoords.z)).x;\n    float dSDFdz = SDFscene(vec3(sampleCoords.x, sampleCoords.y, sampleCoords.z + EPSILON)).x - SDFscene(vec3(sampleCoords.x, sampleCoords.y, sampleCoords.z - EPSILON)).x;\n    \n    return normalize(vec3(dSDFdx, dSDFdy, dSDFdz));\n}\n\n\n\n\n\n\n// https://iquilezles.org/articles/rmshadows/\nfloat softshadow(vec3 LightPos, vec3 ScenePos, float start, float end, float LightAngle) \n{\n    float res = 1.0;\n    float depth = start;\n\n    vec3 N = estimateNormal(ScenePos);\n    vec3 L = LightPos - ScenePos;\n\n    vec3 LightDirection = normalize(L);\n\n\n    for(int i = 0; i < MAX_MARCHING_STEPS ; i++) \n    {\n      float surfaceInformation = SDFscene(ScenePos + LightDirection * depth).x;\n\n      res = min(res, surfaceInformation/(LightAngle*depth));\n      \n      depth += clamp(surfaceInformation, PRECISION, 0.5);\n\n      if(res < -1. || depth > end) break;\n    }\n\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res);\n}\n\n\n\n\n\n\n\nvec3 LightContributionPhong(vec3 k_d, vec3 k_s, float alpha, vec3 LightPos, vec3 ScenePos, vec3 EyePos)\n{\n\tvec3 N = estimateNormal(ScenePos);\n\tvec3 L = normalize(LightPos - ScenePos);\n\tvec3 V = normalize(EyePos - ScenePos);\n\tvec3 H = normalize(L + V);\n\n    // shadows\n    float shadows = softshadow(LightPos, ScenePos, 0.1, 3., 0.06);\n    \n    // lighting\n    float dotLN = max(dot(N, L), 0.);\n    float dotHN = max(dot(H, N), 0.);\n    \n\tvec3 diffuse = k_d * dotLN;\n\tvec3 speculaire = k_s * pow(dotHN, alpha);\n\n\treturn shadows*(diffuse + speculaire);\n}\n\n\n\n\nvec3 PhongIlluminationModel(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 ScenePos, vec3 EyePos)\n{\n\t// ambiant light\n\tvec3 ambiantLight = vec3(0.5);\n\tvec3 color = ambiantLight * k_a;\n\n\t// adding light\n    vec3 LightPos = vec3(0.5, 4., 6.);;\n\tvec3 LightIntensity = vec3(0.5);\n    \n\tcolor += LightIntensity * LightContributionPhong(k_d, k_s, alpha, LightPos, ScenePos, EyePos);\n    \n\treturn color;\n}\n\n\n\n\nmat4 LookAt(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.)\n    );\n}\n\n\n\n\n\n// ================================================\n// =============== final rendering ================\n// ================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // ray direction it the view reference\n    vec3 ViewDir = rayDirection(45., iResolution.xy, fragCoord); \n    \n    // camera parameter\n    vec3 eye = 3.*vec3(3., 2.4, 6.); \n    vec3 center = vec3(0.);\n    vec3 up = vec3(0., 1., 0.);\n    \n    mat4 ViewToScene = LookAt(eye, center, up);\n    \n    // ray direction in the scene reference\n    vec3 SceneDir = (ViewToScene * vec4(ViewDir, 1.)).xyz; \n    \n    \n    // distance and material id\n    vec2 SceneInfo = shortestDistanceToSurface(eye, SceneDir, MIN_DIST, MAX_DIST);\n    float dist = SceneInfo.x; \n    \n    // no element found\n    if(dist > MAX_DIST - EPSILON) \n    {\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    // point on the scene\n    vec3 pointPos = eye + dist * SceneDir;\n    \n    // textures\n    mat3 MatInfo = TexturesScene(SceneInfo.y); // mat3(K_a, K_d, vec3(K_s, shininess, 0.))\n    vec3 K_a = MatInfo[0];\n    vec3 K_d = MatInfo[1];\n    vec3 K_s = vec3(MatInfo[2].x);\n    float shininess = MatInfo[2].y;\n    \n    // light\n    vec3 color = PhongIlluminationModel(K_a, K_d, K_s, shininess, pointPos, eye);\n    \n    \n    // final color\n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec2 OpRepetition(vec2 pos, float interval)\n{\n    return pos - interval * round(pos/interval);\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )// https://iquilezles.org/articles/distfunctions/\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\n\nvec3 uhash3( uvec3 x ) // iq version\n{\n    uint k = 1103515245U;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)/float(0xffffffffU);\n}\n\n\n\nvec3 hash( vec3 f ) //  FabriceNeyret2 version\n{ \n    return uhash3( uvec3( floatBitsToUint(f.x),\n                          floatBitsToUint(f.y),\n                          floatBitsToUint(f.z) ) );\n}","name":"Common","description":"","type":"common"}]}