{"ver":"0.1","info":{"id":"Dt2yDh","date":"1691769723","viewed":48,"name":"Space separation for finite cone","username":"Envy24","description":"See Image tab header.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","space","cone","separation","finite"],"hasliked":0,"parentid":"DlScWz","parentname":"Ray-Finite Cone (2d slice)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Scene defined in 3d, but you see just a slice for some z value.\n    Mouse.y changes z coordinate for slice.\n    Only lower cone are visible.\n*/\n\n#define ORIGIN                    ( vec2(0) )\n#define SCENE_SCALE               ( 2.5 )\n#define UNIT                      ( 4.0*SCENE_SCALE / iResolution.y )          // Affects AA and thickness\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale - origin;\n}\n \nint func_idx = 0;\nfloat implicit(float x, float y, float z) \n{   \n    vec3 N = vec3(0,1,0);\n    if (y <= 0.)\n    {\n        if (func_idx == 0)\n            return x*x + z*z - y*y;\n        else\n            return (-N.y*y-1.) * float(x*x + z*z <= y*y);\n    }\n    else\n        return 0.;\n        \n}\nfloat implicitAA( in vec3 P )\n{\n    float coverage = 0., // You can cheat and set this variable to some negative value.\n          th = 6.,        // thickness\n          c = implicit(P.x, P.y, P.z) >= 0. ? 1. : -1.; // only sign\n    \n    vec2 ps = vec2(0.35*SCENE_SCALE/iResolution.y); // affects thickness and artifacts\n   \n    // Supersampling.\n    for (float y = -th; y <= th; y += 1.)\n        for (float x = -th; x <= th; x += 1.)\n        {\n            vec3 p = P + vec3(x, y, 0)*vec3(ps, 0);\n            float n = implicit(p.x, p.y, p.z);\n            \n            /* 1. Filled shape *\n            coverage += n >= 0.0 ? 0.0 : 1.0;\n            /* 2. Shape contour */\n            n = n >= 0.0 ? 1. : -1.;\n            coverage += c == n ? 0. : 1.;\n            /**/\n        }\n  \n    // Convert coverage into intensity (.35 is arbitrary weight for AA).\n    return smoothstep(0., th*th, coverage*0.35);\n}\n\nvec3 separate_space(vec3 P)\n{\n    vec3 color = vec3(1);\n    \n    if (P.y < -1.) // Below cone?\n    {\n        if (dot(P.xz, P.xz) <= P.y*P.y) // Below, in range of disk radius?\n            color = vec3(1,0,0); // Disk hit or nothing.\n        else\n            color = vec3(0,0,1); // Disk, cone, or nothing.\n    }\n    else if (P.y >= -1. && P.y <= 0.) // Looking at cone from side?\n    {\n        if (dot(P.xz, P.xz) <= 1.) // In range of cone radius?\n        {\n            if (dot(P.xz, P.xz) < P.y*P.y) // inside?\n                color = vec3(0,1,1); // Nothing.\n            else \n                color = vec3(1, 1, 0); // Cone or nothing.\n        }\n        else\n        {\n            color = vec3(1,0,1); // Cone or nothing\n        }\n    }      \n    else // Above cone?\n    {        \n        if (dot(P.xz, P.xz) <= 1.)\n        {\n            color = vec3(0.5,0.5,0); // Cone or nothing\n        }\n        else\n        {\n            color = vec3(0,1,0); // Cone or nothing\n        }       \n    }\n    \n    return color;\n}\n \nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, false),\n         MP = iMouse.xy == vec2(0) ? vec2(0) :  \n              map_to_centered_ndc(iMouse.xy, SCENE_SCALE, ORIGIN, false);\n\n    // Z for slice.\n    float //z_coord = 0.;\n          z_coord = MP.y;\n    vec3 point3d = vec3(NDC, z_coord);\n\n    vec3 color = separate_space(point3d);\n         color = mix( color, vec3(0.8), SMAA(cellsSDF(NDC)) );\n         //color = mix( color, vec3(0), SMAA(x_axisSDF(NDC)) );\n         //color = mix( color, vec3(0), SMAA(y_axisSDF(NDC)) );\n      \n    // Draw 2d slice.  \n    if (abs(point3d.x) < 1. && abs(point3d.y) <= 1. && abs(point3d.z) <= 1.)\n    {       \n        func_idx = 0; color = mix(color, vec3(0,0,1), implicitAA(point3d));\n        func_idx = 1; color = mix(color, vec3(0,0,1), implicitAA(point3d));\n    }\n    \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float y_axisSDF(vec2 NDC) { return abs(NDC.x); }\nfloat x_axisSDF(vec2 NDC) { return abs(NDC.y); }\nfloat vertical_lineSDF(vec2 NDC, float x0) { return abs(NDC.x-x0); }\nfloat horizontal_lineSDF(vec2 NDC, float y0) { return abs(NDC.y-y0); }\nfloat cellsSDF(vec2 NDC)\n{\n    //NDC *= 2.; // Finer cell\n    NDC = fract(NDC);\n    NDC = fract(min(NDC, 1. - NDC));\n    return\n        min(vertical_lineSDF(NDC, 0.), horizontal_lineSDF(NDC, 0.));\n}\nfloat diskSDF(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\nfloat segmentSDF(in vec2 NDC, in vec2 B, in vec2 E, in float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}\nfloat arrowSDF(\n    in vec2 NDC,\n    in vec2 B,\n    in vec2 E,\n    in float R)\n{\n    float len = length(B-E);    \n    vec2 dir = normalize(E-B),\n         //up = cross(vec3(dir, 0.), vec3(0, 0, -1)).xy,   \n         up = vec2(-dir.y, dir.x),\n         C = E - dir * 0.0475, //      U--\n         U = C + up  * 0.030,  // B----C----E\n         D = C - up  * 0.030;  //      D--\n    \n    vec3 BARY = inverse(mat3(\n            U.x, U.y, 1.0,\n            D.x, D.y, 1.0,\n            E.x, E.y, 1.0)) * vec3(NDC.x, NDC.y, 1.0);\n    \n    float sign = \n        BARY.x >= 0.0 &&    \n        BARY.y >= 0.0 && \n        BARY.z >= 0.0 ?  // inside triangle?\n            -1. : 1.;\n    \n    float d = segmentSDF(NDC, U, D, 0.);\n          d = min(d, segmentSDF(NDC, U, E, 0.));\n          d = min(d, segmentSDF(NDC, D, E, 0.));\n          d = \n              len < 0.0475 ? \n                  d :\n                  min(d, segmentSDF(NDC, B, C, 0.));\n    \n    return sign*d-R;           \n}\n\n/**\nvec3 separate_space(vec3 P)\n{\n    vec3 color = vec3(1);\n    \n    if (P.y < -1.) // Below cone?\n    {\n        if (dot(P.xz, P.xz) <= P.y*P.y) // Below, in range of disk radius?\n            color = vec3(1,0,0); // Disk hit or nothing.\n        else\n            color = vec3(0,0,1); // Disk, cone, or nothing.\n    }\n    else if (P.y >= -1. && P.y <= 0.) // Looking at cone from side?\n    {\n        if (dot(P.xz, P.xz) <= 1.) // In range of cone radius?\n        {\n            if (dot(P.xz, P.xz) < P.y*P.y) // inside?\n                color = vec3(0,1,1); // Nothing.\n            else \n                color = vec3(1, 1, 0); // Cone or nothing.\n        }\n        else\n        {\n            color = vec3(1,0,1); // Cone or nothing\n        }\n    }      \n    else // Above cone?\n    {        \n        if (dot(P.xz, P.xz) <= 1.)\n        {\n            color = vec3(1,1,0);\n        }\n        else\n        {\n            color = vec3(0,1,0);\n        }       \n    }\n    \n    return color;\n}\n/**/","name":"Common","description":"","type":"common"}]}