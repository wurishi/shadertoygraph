{"ver":"0.1","info":{"id":"l3XGRj","date":"1707671029","viewed":76,"name":"Journey through Electric Fields","username":"AntoineGPoulin","description":"Walking through large fields of spheres, reacting to unseen waves of cosmic energy","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["lattice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Code mostly built from following this tutorial\nhttps://inspirnathan.com/posts/51-shadertoy-tutorial-part-5\n*/\n\nconst int   MAX_STEPS = 255;\nconst float PRECISION = 0.001;\nconst float MIN_DEPTH = 0.;\nconst float MAX_DEPTH = 30.;\n\nvec3 nrSphere(vec3 p, vec3 center, float radius)\n{\n  return normalize(p - center);\n}\n\nfloat sdSphere(vec3 p, vec3 center, float radius)\n{\n  return length(p - center) - radius;\n}\n\nfloat sdLattice(vec3 p, float radius)\n{\n    vec3 torus = mod(p + 0.5, 1.) - 0.5;\n    return sdSphere(torus, vec3(0.), radius);\n}\n\nvec3 nrLattice(vec3 p, float radius)\n{\n  vec3 torus = mod(p + 0.5, 1.) - 0.5;\n  return nrSphere(torus, vec3(0.), radius);\n}\n\n\nfloat rayMarch(vec3 ro, vec3 rd)\n{\n  float depth = MIN_DEPTH;\n  for(int i = 0; i < MAX_STEPS; i++){\n    vec3 p = ro + depth * rd;\n    float d = sdLattice(p, 0.1);\n    // float d = sdSphere (p,vec3(0.), 0.1);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DEPTH) break;\n  }\n  return depth;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float c = cos(iTime);\n    float s = sin(iTime);\n    mat3 megarot = mat3(c * c, s*c*(s - 1.), s*(c*c + s),c*s, s*s*s + c * c, c*s*(s - 1.), -s, s*c, c*c)  ;  \n        \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.);\n        \n    vec3 lightSource = vec3(1.+ 0.1 * iTime, 3.+ 0.3*iTime, -4.);    \n       \n    vec3 ro = vec3(0.3 + 0.1 * iTime, 0.4 + 0.3*iTime, -2. + 0.1*iTime);\n    vec3 rd = normalize(vec3(uv, 1));\n    \n    float d = rayMarch(ro, rd);\n    \n    \n    if (d > MAX_DEPTH) {\n      col = vec3(0.);\n    } else {\n      vec3 p = ro + d * rd;\n      vec3 nor = nrLattice(p, 0.1);\n      vec3 light = normalize(lightSource - p);\n      float diff = dot(nor, light);\n      col = diff * megarot * abs(vec3(sin(0.1 * p.x), cos(0.15 * p.y), sin(0.7 * p.z)));\n      col = mix(col, vec3(0.), (d/MAX_DEPTH)*(d/MAX_DEPTH));\n    \n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}