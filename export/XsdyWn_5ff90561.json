{"ver":"0.1","info":{"id":"XsdyWn","date":"1518470330","viewed":240,"name":"Raymarched Pulse 0.3","username":"AustinSpafford","description":"Visualizing what raymarched rays look like as they travel through a scene. Experimenting with ideas for rendering an echolocation-like experience.\n- Mouse click+drag orbits the camera.\n- Spacebar manually fires a new pulse.","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["raymarch","simulation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ENABLE_DEPTH_VISUALIZATION\n#define ENABLE_PROXIMITY_VISUALIZATION\n\nfloat RandomFloat(\n\tvec2 testCoord)\n{\n\t// From: https://www.shadertoy.com/view/Xd23Dh\n\t// (just removed some dimensions)\n\tfloat testCoordInGeneratorSpace = \n\t\tdot(testCoord, vec2(127.1, 311.7));\n\n\treturn fract(sin(testCoordInGeneratorSpace) * 43758.5453);\n}\n\nvoid mainImage(\n    out vec4 outFragColor, \n    in vec2 fragCoord)\n{   \n    vec4 fragState = texture(iChannel0, (fragCoord.xy / iResolution.xy));\n    \n    outFragColor.rgb = vec3(1.0);\n    \n    #ifdef ENABLE_DEPTH_VISUALIZATION\n    outFragColor.rgb *= sqrt(1.0 / (1.0 + (1.0 * fragState.r)));\n    #endif\n    \n    #ifdef ENABLE_PROXIMITY_VISUALIZATION\n    outFragColor.rgb *= sqrt(1.0 - (1.0 / (1.0 + max(0.0, fragState.g))));\n    #endif\n    \n    outFragColor.rgb = sqrt(outFragColor.rgb); // Convert linear-color to gamma-color.\n    outFragColor.rgb += (mix(-0.5, 0.5, RandomFloat(fragCoord.xy)) / 256.0); // Dither the final output to avoid banding.\n\toutFragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Buffer format:\n// R - Ray distance from camera.\n// G - Ray distance to the scene surface.\n\n#define ENABLE_AUTO_PULSES\n#define ENABLE_SCENE_LUMPINESS\n//#define ENABLE_BLOB_SMOOTH_ANIMATION\n#define ENABLE_BLOB_STEPPED_ANIMATION\n#define ENABLE_RAY_SLOWDOWN\n//#define ENABLE_RAY_STEP_NOISE\n//#define ENABLE_RAY_MAX_STEP_SIZE\n\nconst float k_pi = 3.14159265359;\nconst float k_tau = 6.28318530718;\n\nconst int k_blobletCount = 16;\nconst float k_raymarchPrecision = 0.001;\nconst float k_raymarchEscapeDistance = 10.0;\n\nconst float k_raymarchMaxStepDistance = 0.04;\n\nconst float k_autoPulsePeriod = 5.0;\n\nconst float k_keySpace = (32.5 / 256.0);\n\nvec4 s_bloblets[k_blobletCount]; // (position, strength)\nvec2 s_mouseFractions;\n\nmat3 RotationMatrixX(\n\tfloat theta)\n{\n    float cosTheta = cos(theta);\n    float sinTheta = sin(theta);\n    \n    return mat3(\n    \t1.0, 0.0, 0.0, // x-basis\n        0.0, cosTheta, sinTheta, // y-basis\n        0.0, (-1.0 * sinTheta), cosTheta); // z-basis\n}\n\nmat3 RotationMatrixY(\n\tfloat theta)\n{\n    float cosTheta = cos(theta);\n    float sinTheta = sin(theta);\n    \n    return mat3(\n    \tcosTheta, 0.0, (-1.0 * sinTheta), // x-basis\n        0.0, 1.0, 0.0, // y-basis\n        sinTheta, 0.0, cosTheta); // z-basis\n}\n\nmat3 RotationMatrixZ(\n\tfloat theta)\n{\n    float cosTheta = cos(theta);\n    float sinTheta = sin(theta);\n    \n    return mat3(\n    \tcosTheta, sinTheta, 0.0, // x-basis\n        (-1.0 * sinTheta), cosTheta, 0.0, // y-basis\n        0.0, 0.0, 1.0); // z-basis\n}\n\nfloat RandomFloat(\n\tvec2 testCoord)\n{\n\t// From: https://www.shadertoy.com/view/Xd23Dh\n\t// (just removed some dimensions)\n\tfloat testCoordInGeneratorSpace = \n\t\tdot(testCoord, vec2(127.1, 311.7));\n\n\treturn fract(sin(testCoordInGeneratorSpace) * 43758.5453);\n}\n\nfloat TextureNoise3D(\n    vec3 x)\n{\n    // From: https://www.shadertoy.com/view/4sfGzS\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod(iChannel2, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat HackyTextureNoise4D(\n\tvec4 testCoord)\n{\n    // Warp the w-dimension to avoid synchronizing changes across xyz.    \n    float wShifted = (\n        testCoord.w + \n\t\tTextureNoise3D(testCoord.xyz + vec3(0.5)));\n    \n    vec3 layeringAxis = vec3(1.274, 2.832, 3.233);\n\n    float prevValue = TextureNoise3D(testCoord.xyz + fract(layeringAxis * floor(wShifted)));    \n    float nextValue = TextureNoise3D(testCoord.xyz + fract(layeringAxis * ceil(wShifted)));\n    \n    float rawBlendingFraction = fract(wShifted);\n    float blendingFraction = mix(rawBlendingFraction, smoothstep(0.0, 1.0, rawBlendingFraction), 0.5);\n    \n    return mix(prevValue, nextValue, blendingFraction);\n}\n\nfloat SceneNoise(\n    vec3 testPoint)\n{\n    float attenuationFraction = smoothstep(25.0, 5.0, length(testPoint));\n    float rawNoise = \n        (0.66 * TextureNoise3D(6.0 * testPoint)) +\n        (0.33 * TextureNoise3D(12.0 * testPoint));\n    \n    return (attenuationFraction * rawNoise);\n}\n\nfloat SmoothMin(\n    float firstValue,\n    float secondValue,\n    float smoothingDistance)\n{\n    // Credit: https://iquilezles.org/articles/smin\n    float blendFraction = clamp((0.5 + (0.5 * ((firstValue - secondValue) / smoothingDistance))), 0.0, 1.0);\n    return (\n        mix(firstValue, secondValue, blendFraction) - \n        (smoothingDistance * (blendFraction * (1.0 - blendFraction))));\n}\n\nfloat SampleSphereDistance(\n\tvec3 testPoint,\n    vec4 spherePosRadius)\n{\n    return (distance(testPoint, spherePosRadius.xyz) - spherePosRadius.w);\n}\n\nfloat SampleBlobBoundsDistance(\n\tvec3 testPoint)\n{\n    float result = 100.0;\n    \n    for (int blobletIndex = 0; blobletIndex < k_blobletCount; blobletIndex++)\n\t{\n        float blobletDistance = SampleSphereDistance(testPoint, s_bloblets[blobletIndex]);\n        \n        result = SmoothMin(result, blobletDistance, 0.1);\n    }\n    \n    return result;\n}\n\nfloat SampleGroundDistance(\n\tvec3 testPoint)\n{\n    float groundY = -1.2;\n    return (testPoint.y - groundY);\n}\n\nfloat SampleSceneDistance(\n\tvec3 testPoint)\n{\n    float result = 10000.0;\n    \n\tresult = min(result, SampleBlobBoundsDistance(testPoint));\n\tresult = min(result, SampleGroundDistance(testPoint));\n        \n    #ifdef ENABLE_SCENE_LUMPINESS\n    result += (0.1 * SceneNoise(testPoint));\n    #endif\n    \n    return result;\n}\n\nvec3 ComputeSceneGradient(\n\tvec3 testPoint)\n{\n    vec3 xStep = vec3(k_raymarchPrecision, 0.0, 0.0);\n    vec3 yStep = xStep.yxy;\n    vec3 zStep = xStep.yyx;\n    \n    return (1.0 / k_raymarchPrecision) * vec3(\n    \t(SampleSceneDistance(testPoint + xStep) - SampleSceneDistance(testPoint - xStep)),\n        (SampleSceneDistance(testPoint + yStep) - SampleSceneDistance(testPoint - yStep)),\n    \t(SampleSceneDistance(testPoint + zStep) - SampleSceneDistance(testPoint - zStep)));\n}\n\nvec2 GetAspectRatioCorrectionScalars(\n\tvec2 textureResolution)\n{\n    vec2 result = vec2(1.0);\n    \n\tfloat textureAspectRatio = (textureResolution.x / textureResolution.y);\n        \n    // Perform basic aspect-ratio correction.\n\tresult.x *= max(1.0, textureAspectRatio);\n    result.y *= max(1.0, (1.0 / textureAspectRatio));\n    \n    // Crop down until the artwork is touching at least one pair of edges.\n    {\n        float artworkAspectRatio = 1.0;\n        \n        //artworkAspectRatio = textureAspectRatio; // Zoom in until the artwork fills the frame.\n        \n        if ((artworkAspectRatio > 1.0) && (textureAspectRatio > 1.0))\n        {\n            result /= min(artworkAspectRatio, textureAspectRatio);\n        }\n        else if ((artworkAspectRatio < 1.0) && (textureAspectRatio < 1.0))\n        {\n            result *= max(artworkAspectRatio, textureAspectRatio);\n        }\n    }\n    \n    return result;\n}\n\nbool KeyIsPressed(\n    float keyCode)\n{\n\treturn (texture(iChannel1, vec2(keyCode, 0.5)).x > 0.0);\n}\n\nvoid mainImage(\n    out vec4 outFragColor, \n    in vec2 fragCoord)\n{\n\ts_mouseFractions = (iMouse.xy / iResolution.xy);\n    \n    float currentPulseIndex = floor(iTime / k_autoPulsePeriod);\n    float previousPulseIndex = floor((iTime - iTimeDelta) / k_autoPulsePeriod);\n    \n\t// Compute the blob parameters.\n    {\n        float blobTime = 27.0; // Just pushing out from the initial mono-blob.\n        \n        #ifdef ENABLE_BLOB_SMOOTH_ANIMATION\n        blobTime += iTime;\n        #endif\n        \n        #ifdef ENABLE_BLOB_STEPPED_ANIMATION\n        blobTime += (2.0 * currentPulseIndex);\n        #endif\n        \n        for (int blobletIndex = 0; blobletIndex < k_blobletCount; blobletIndex++)\n        {\n            vec3 blobletMovementRates =\n                vec3(\n                    mix(0.02, 0.1, RandomFloat(vec2(float(blobletIndex), 0.0))),\n                    mix(0.02, 0.1, RandomFloat(vec2(float(blobletIndex), 0.1))),\n                    mix(0.02, 0.1, RandomFloat(vec2(float(blobletIndex), 0.2))));\n\n            s_bloblets[blobletIndex] = vec4(\n                (0.75 * vec3(1.0, 1.0, 1.0) * sin(k_tau * blobletMovementRates * blobTime)),\n                (0.6 * mix(0.25, 1.0, RandomFloat(vec2(float(blobletIndex), 0.3)))));\n        }\n    }\n        \n\tvec2 rayUv = (\n        mix(vec2(-1.0), vec2(1.0), (fragCoord.xy / iResolution.xy)) *\n        GetAspectRatioCorrectionScalars(iResolution.xy));\n    \n    vec3 rayOrigin = vec3(0.0, 0.0, 2.5);\n    vec3 rayDirection = normalize(vec3(rayUv, -1.5));\n    \n    // Camera-pitch.\n    {     \n        float pitchFraction = mix(0.25, -0.05, ((s_mouseFractions.xy == vec2(0.0)) ? 0.7 : s_mouseFractions.y));\n        mat3 transform = RotationMatrixX(pitchFraction * k_tau);\n        rayOrigin *= transform;\n        rayDirection *= transform;\n    }\n    \n    // Camera-yaw.\n    {\n        float yawFraction = mix(-0.5, 0.5, ((s_mouseFractions.xy == vec2(0.0)) ? 0.25 : s_mouseFractions.x));               \n        mat3 transform = RotationMatrixY(yawFraction * k_tau);\n        rayOrigin *= transform;\n        rayDirection *= transform;\n    }\n    \n    vec4 fragState = texture(iChannel0, (fragCoord.xy / iResolution.xy));\n    \n    bool shouldAutoPulse = false;\n    #ifdef ENABLE_AUTO_PULSES\n    shouldAutoPulse = (previousPulseIndex != currentPulseIndex);\n    #endif\n    \n    // If this is a new pulse.\n    if (shouldAutoPulse || KeyIsPressed(k_keySpace))\n    {\n        fragState.r = 0.0;\n        fragState.g = 10000.0;\n    }\n    \n    // Advance the ray.\n    {\n        vec3 rayPosition = (rayOrigin + (rayDirection * fragState.r));\n        \n        float sceneDistance = SampleSceneDistance(rayPosition);\n        \n        float advancementDistance = sceneDistance;\n        \n        #ifdef ENABLE_RAY_SLOWDOWN\n        advancementDistance *= 0.3;\n        #endif\n        \n        #ifdef ENABLE_RAY_STEP_NOISE\n        advancementDistance *= mix(0.33, 1.0, SceneNoise(rayPosition));\n        #endif\n        \n        #ifdef ENABLE_RAY_MAX_STEP_SIZE\n        advancementDistance = min(k_raymarchMaxStepDistance, advancementDistance);\n        #endif\n        \n        fragState.r += advancementDistance;\n        fragState.g = sceneDistance;\n    }\n    \n    outFragColor = fragState;\n}","name":"Buf A","description":"","type":"buffer"}]}