{"ver":"0.1","info":{"id":"3ld3D4","date":"1576376804","viewed":465,"name":"Explorable Buddhabrot","username":"rory618","description":"Using a cubemap mip buffer to create a probability distribution to sample points along the edge of the mandelbrot set. These points create the orbits that contribute the most to images of the Buddhabrot. The result is good enough to zoom into.","likes":16,"published":1,"flags":48,"usePreview":0,"tags":["2d","fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Deterministic particle sorting algorithm\n//using 7 stage 3x3 strided sorting stages split over 8 frames, in total just 36 or 27 calls to texelFetch per frame\n//Non recurrent, each frame is computed independent of the last, particles can jump around quickly with no adverse effects\n//Running at half speed, takes two frames to draw the image. I'm starting to like this approach, d 30 fps on shadertoy\n//feels a lot more than twice as powerful.\n//All that is done is getting particles to the closest pixel.\n//Particles affecting more than a single pixel are out of scope here for now.\n\n//Still no gaurentee that a pixel doesnt come up empty when there is a particle there, but chances of that happening\n//are reduced compared to previous approaches\n\n//See https://www.shadertoy.com/view/XsjyRm for another use of strided sort\n\n//No spatial decorrelation, sorting directly in image space to make for easy drawing of big particles.\n\n\n//Rendering in buf A\n\nconst vec2 viewportLoc = vec2(0.5,0.5);\nconst vec2 mouseLoc = vec2(0.5,1.5);\n\nvec4 load(vec2 a) {\n    return texture( iChannel0, (a) / iChannelResolution[0].xy, -100.0 );\n}\n/*vec2 uvtoc(vec2 center, vec2 up, vec2 right, vec2 uv ) {\n    return center + right * uv.x + up * uv.y;\n}*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 viewport = load(viewportLoc);\n    vec4 mouse = load(mouseLoc);\n    \n    vec2 center = viewport.xy;\n    vec2 up = viewport.zw;\n    vec2 right = vec2(up.y, -up.x) * iResolution.x / iResolution.y;\n    \n    vec2 p = uvtoc(center, up, right, 2.0*(uv-vec2(.5)));\n    \n    fragColor = texture(iChannel1, uv);\n    \n    fragColor/=texture(iChannel1, vec2(.5)).w;\n    \n    fragColor = pow(fragColor,vec4(.45));\n    \n    vec2 nup = mouse.xy - mouse.zw;\n    vec2 nright = vec2(nup.y, -nup.x) * iResolution.x / iResolution.y;\n    \n\t\n    \n    vec2 o = (fragCoord - mouse.zw);\n    \n    float z = max(0.0, min(1.0, 1.0-\n    min(\n    \tmin(\n        \tabs( dot(o, nup)/length( nup) - length( nup)) , \n            abs( dot(o,-nup)/length(-nup) - length(-nup)) \n        ), min(\n            abs( dot(o, nright)/length( nright) - length( nright)) ,\n         \tabs( dot(o,-nright)/length(-nright) - length(-nright)) \n        )\n    )));\n    \n    if(iMouse.z>.1 && mouse.z != 0.0)\n        fragColor += z;//*fragColor + (z);\n    \n    \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Simple newtonian particles\n//Use O.w for render pass\n\n//Uncomment to see the decorrelated image that is getting rendered\n//#define show_decorrelated\n\n//Drawing a particle\n//Need another pass or bigger output pass to draw bigger particles\n//For now just light up the pixel it lands in\n\n\nvec2 sampleXY(int seed){\n    vec2 c = vec2(1,-1);\n    vec2 p = vec2(0);\n    float lod = 9.;\n    float os = .5;\n    float v0 = textureLod(iChannel2,vec3( p + c.xx*os ,1.),lod).x;\n    float v1 = textureLod(iChannel2,vec3( p + c.xy*os ,1.),lod).x;\n    float v2 = textureLod(iChannel2,vec3( p + c.yx*os ,1.),lod).x;\n    float v3 = textureLod(iChannel2,vec3( p + c.yy*os ,1.),lod).x;\n    float s = v0+v1+v2+v3;\n    \n    float r = Hash(seed);\n    for(int i = 0; i < 12; i++){\n        seed = IHash(seed);\n\n        if(r<v0/s){ \n            p += c.xx*os; \n        } else if(r<(v0+v1)/s){ \n            p += c.xy*os; \n        } else if(r<1.-v3/s){\n            p += c.yx*os;\n        } else {\n            p += c.yy*os;\n        }\n        os *= .5;\n        lod -= 1.;\n        v0 = textureLod(iChannel2,vec3( p + c.xx*os ,1.),lod).x;\n        v1 = textureLod(iChannel2,vec3( p + c.xy*os ,1.),lod).x;\n        v2 = textureLod(iChannel2,vec3( p + c.yx*os ,1.),lod).x;\n        v3 = textureLod(iChannel2,vec3( p + c.yy*os ,1.),lod).x;\n        s = v0+v1+v2+v3;\n        r = Hash(seed);\n    }\n    p += (rand2(IHash(seed))-.5)/1024.;\n    return coord2viewport((p/2.+.5),  vec2(1), vec2(-.75,0), vec2(3,0));\n}\n\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    vec2 uv = I/R.xy;\n    vec3 r = rand3(IHash3(iFrame,I.x,I.y));\n    vec2 c = sampleXY(IHash3(iFrame,I.x,I.y));\n    vec2 z = vec2(0);\n    int j;\n    //Find a convergent or divergent orbit\n    for(j = 0;  j < 512; j++) {\n        z = mat2(z, -z.y, z.x) * z + c;\n        if(dot(z,z)>1e3){\n            break;\n        }\n    }\n    //After finding it, pick a random starting point somewhere in the orbit\n    //Then the next 16 points from that starting point will get drawn\n    //Too expensive to draw length 512 orbits all at once, but reasonable to do\n    //draw 8 iterations per particle at once, and just precalculate a starting point\n    //once per particle\n    if (j>=412) {\n        \n        int n = int((r.z)*float(j-16));\n    \tvec2 z = vec2(0);\n        for(j = 0;  j < 512; j++) {\n        \tz = mat2(z, -z.y, z.x) * z + c;\n        }\n        \n        //Save a particle as a C value defining the orbit, and a start value at iteration n\n        O = (n<1)?vec4(0):vec4(c,z);\n    } else {\n        O = vec4(0);             \n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define R iResolution\n#define iR ivec3(R)\n#define uR uvec3(R)\n#define IHash3(x,y,z) IHash(int(x)^IHash(int(y)^IHash(int(z))))\n#define dot2(o) dot((o),(o))\n#define tx(ch,p,R) texelFetch(ch, Zmod(p,iR.xy),0)\n\n//Roboust/universal integer modulus function\n#define Zmod(x,y) (((x)+(y)+(y)+(y))-(((x)+(y)+(y)+(y))/(y))*(y))\n//#define Zmod(x,y) ((x+y*10)%y)\n\nint mandelIter(inout vec2 z, vec2 c, int iters, float b){\n    for(int j = 0;  j < iters; j++) {\n        z = mat2(z, -z.y, z.x) * z + c;\n        if(dot(z,z)>b)\n            return j;\n    }\n    return iters;\n}\n\nvec2 coord2viewport(vec2 coord, vec2 s, vec2 center, vec2 scale) {\n    return center + mat2(scale, -scale.y, scale.x) * (coord-s/2.)/max(s.x,s.y);\n}\n\nfloat packVec2(vec2 x){\n    return uintBitsToFloat(packSnorm2x16(x/10.));\n}\nvec2 umpackVec2(float x){\n    return unpackSnorm2x16(floatBitsToUint(x))*10.;\n}\n\nbool inbounds(vec2 x, vec2 y){\n    return (x.x>0.&&x.y>0.&&x.x<y.x&&x.y<y.y);\n}\n\n//RNG\nint IHash(int a){\n\ta = (a ^ 61) ^ (a >> 16);\n\ta = a + (a << 3);\n\ta = a ^ (a >> 4);\n\ta = a * 0x27d4eb2d;\n\ta = a ^ (a >> 15);\n\treturn a;\n}\n\nfloat Hash(int a){\n\treturn float(IHash(a)) / float(0x7FFFFFFF);\n}\nvec4 rand4(int seed){\n    return vec4(Hash(seed^0x34F85A93),\n                Hash(seed^0x85FB93D5),\n                Hash(seed^0x6253DF84),\n                Hash(seed^0x25FC3625));\n}\nvec3 rand3(int seed){\n    return vec3(Hash(seed^0x348CD593),\n                Hash(seed^0x8593FD5),\n                Hash(seed^0x62A5D384));\n}\nvec2 rand2(int seed){\n    return vec2(Hash(seed^0x348C5F93),\n                Hash(seed^0x8593D5BB));\n}\n\n\nvec2 randn(vec2 randuniform){\n    vec2 r = randuniform;\n    r.x = sqrt(-2.*log(1e-9+abs(r.x)));\n    r.y *= 6.28318;\n    r = r.x*vec2(cos(r.y),sin(r.y));\n    return r;\n}\n\n\n\n\n\n//Distance to mandelbrot set orbit\nfloat orbitDist(vec2 start, vec2 c, vec2 p, int iters){\n    //return length(c-p);\n    float d = 1e9;\n    vec2 z = start;\n    int j = 0;\n    for(j = 0;  j < iters; j++) {\n        z = mat2(z, -z.y, z.x) * z + c;\n        d = min(d,length(z-p));\n        //if(dot(z,z)>1e3)\n        //    return d;\n    }\n    return(d);\n    \n}\n\nvec2 Ptoc(vec2 p, vec3 R){\n    return (p-R.xy/2.)/R.y*2. + vec2(-.25,0);\n}\n\nvec2 uvtoc(vec2 center, vec2 up, vec2 right, vec2 uv ) {\n    return center + right * uv.x + up * uv.y;\n}\n\n//Define a particle as a vec 4 containing the C value for an orbit and the initial z value\nfloat score(vec4 p, vec2 I, vec3 R, vec4 viewport){\n    if( p==vec4(0)) return 1e9;\n    \n    vec2 center = viewport.xy;\n    vec2 up = viewport.zw;\n    vec2 right = vec2(up.y, -up.x) * R.x / R.y;\n    \n   \n    return max(0.,orbitDist(p.zw, p.xy, uvtoc(center,up,right,(I*2.-R.xy)/R.xy), 32)/1./length(up)*R.y-1.);\n}\n\nvoid updateRank(vec4 t, inout vec4 O, inout float s, vec2 I, vec3 R, vec4 viewport){\n    float sp = score(t,I,R, viewport);\n    if(sp<s){\n        s=sp;\n        O=t;\n    }\n}\n\n//Update ranking, save a list of two particle xy indices. O.xy is better particle, O.zw is a different not as good one\n/*void updateRank2x(vec2 t, inout vec4 O, inout float s0, inout float s1, vec2 I, vec3 R){\n    float sp = score(t,I,R);\n    if(sp<s0){\n        //Shift down the line\n        s1=s0;\n        O.zw=O.xy;\n        s0=sp;\n        O.xy=t;\n    } else if(sp<s1){\n        //Bump off the bottom one\n        s1=sp;\n        O.zw=t;\n        \n    }\n}*/","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Strided sort summarry:\n//Each pass looks at 9 xy locations stored in the previous pass and selects the closest one\n//The locations sampled are arranged in a 3x3 with the center located at I, and the spacing\n//a power of 3\n//Total 7 passes over two frames sized large to small\n//A->B->C->D->B->C->D->Image\n//Spacing 3^6 ..., 3^1, 3^0\n//I think this gives an optimal data path from each pixel to each other pixel under the constraint of 7 passes\n\n//In each buffer, the pixel to get drawn at index is saved in xy and the exact particle location is saved in zw.\n//For more complex particles zw should instead be a pointer to the particle\n//zw is unused for sorting, sort only based on xy\n\nconst vec2 viewportLoc = vec2(0.5,0.5);\n\nvec4 load(vec2 a) {\n    return texture( iChannel2, (a) / iChannelResolution[0].xy, -100.0 );\n}\n//large to small\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    vec4 viewport = load(viewportLoc);\n    //Split frames into two stages\n    int stage = iFrame%7;\n    \n    int size = (int[](729, 243, 81, 27, 9, 3, 1))[stage]; //729=3^6\n    float s0;\n    //init with top left corner and center\n    if(stage==0){\n        vec4 t0 = tx(iChannel0, ivec2(I)-size,R);\n                                                                         \n        s0 = score(t0,I,R,viewport);\n        \n        O=t0==vec4(0)?vec4(0):t0;\n        \n    } else {\n        O = tx(iChannel1, ivec2(I)-size,R );\n        s0 = score(O,I,R,viewport);\n    }\n    for(int i = 1; i < 9; i++){\n        if(stage==0){\n        \tvec4 t = tx(iChannel0,ivec2(I)-size+size*ivec2(i/3,i%3),R);\n            \n            updateRank(t,O,s0,I,R,viewport);\n            \n        } else {\n        \tvec4 t;\n            t = tx(iChannel1,ivec2(I)-size+size*ivec2(i/3,i%3),R); \n            updateRank(t,O,s0,I,R,viewport);\n        }\n        \n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"const vec2 viewportLoc = vec2(0.5,0.5);\n\nvec4 load(vec2 a) {\n    return texture( iChannel2, (a) / iChannelResolution[0].xy, -100.0 );\n}\n\nvoid splat(inout vec3 O, vec2 I, vec4 p, vec4 viewport){\n    \n    float d2 = score(p,I,R,viewport);//max(0.,dot2(ip-p)-12.);\n    //COlor points based on the starting point associated with the particle\n    O += float(d2<0.5) *(.5+.5*cos(vec3(dot(abs(p.zw),vec2(1,2)), dot(abs(p.zw),vec2(2,3)), dot(abs(p.zw),vec2(3,2.5)))));\n    \n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    vec2 uv = I/R.xy;\n    vec2 r = rand2(IHash3(iFrame,I.x,I.y));\n    \n    O = vec4(0,0,0,0);\n    \n    vec4 viewport = load(viewportLoc);\n    \n    \n    //for(int i = 0; i < 9; i++){\n        vec4 t = texelFetch(iChannel0,ivec2(I),0);\n        \n        splat(O.xyz,I,t,viewport);\n    //}\n    \n    //Accumulate over time\n    \n    int stage = iFrame%7;\n    if(stage!=6){\n        O = texelFetch(iChannel1,ivec2(I),0);\n    }\n    else {\n        O += texelFetch(iChannel1,ivec2(I),0);\n    }\n    \n    O.w = max(O.w,max(max(O.x,O.y),O.z));\n    O.w = max(O.w,texture(iChannel1, r).w);\n    \n    if(texelFetch(iChannel3, ivec2(82,1),0).x>.5){O*=0.;}\n    if(texelFetch(iChannel3, ivec2(87,1),0).x>.5){O*=0.;}\n    \n    //O.w = texelFetch(iChannel1,ivec2(I),0).w*10.;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"#define Azp(d) texture(iChannel0,vec3((I.xy+d)/R.xy*2.-1.,1))\nvoid mainCubemap( out vec4 O, in vec2 I, in vec3 rayOri, in vec3 rayDir )\n{\n    if(rayDir.z>abs(rayDir.x) && rayDir.z>abs(rayDir.y)){\n        O = Azp(0.);\n        if(iFrame<1000){ \n            vec2 H = rand2(1024*1024*iFrame+1024*int(I.x)+int(I.y));\n            vec2 C = coord2viewport(I+H-.5,  R.xy, vec2(-.75,0), vec2(3,0));\n            vec2 Z = vec2(0);\n            int i = mandelIter(Z,C,64,64.);\n            if(i>16 && dot(Z,Z)>16.){\n                O.x=1.;\n            }\n            if(iFrame<3){\n                O.xy = vec2(0);\n            }\n        }\n    }\n}","name":"Cube A","description":"","type":"cubemap"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"const vec2 viewportLoc = vec2(0.5,0.5);\nconst vec2 mouseLoc = vec2(0.5,1.5);\n\nconst vec2 param1Loc = vec2(0.5,2.5);\nconst vec2 param2Loc = vec2(0.5,3.5);\nconst vec2 param3Loc = vec2(0.5,4.5);\nconst vec2 param4Loc = vec2(0.5,5.5);\nconst vec2 param5Loc = vec2(0.5,6.5);\n\n\nconst float KEY_W  = 87.5/256.0;\nconst float KEY_R  = 82.5/256.0;\n\nconst float KEY_0 = 48.5/256.0;\nconst float KEY_1 = 49.5/256.0;\nconst float KEY_2 = 50.5/256.0;\nconst float KEY_3 = 51.5/256.0;\nconst float KEY_4 = 52.5/256.0;\nconst float KEY_5 = 53.5/256.0;\n\n\nvec4 load(vec2 a) {\n    return texture( iChannel0, (a) / iChannelResolution[0].xy, -100.0 );\n}\nvec4 save(vec4 v, vec2 a, vec2 c) {\n    return length(c-a)<.5 ? v : vec4(0);\n}\nbool keyIsDown( float key ) {\n    return texture( iChannel1, vec2(key,0.25) ).x > .5;\n}\n/*vec2 uvtoc(vec2 center, vec2 up, vec2 right, vec2 uv ) {\n    return center + right * uv.x + up * uv.y;\n}*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 viewport = load(viewportLoc);\n    vec4 mouse = load(mouseLoc);\n    \n    vec4 param1 = load(param1Loc);\n    vec4 param2 = load(param2Loc);\n    vec4 param3 = load(param3Loc);\n    vec4 param4 = load(param4Loc);\n    vec4 param5 = load(param5Loc);\n    \n    vec2 center = viewport.xy;\n    vec2 up = viewport.zw;\n    vec2 right = vec2(up.y, -up.x) * iResolution.x / iResolution.y;\n        \n    if (iMouse.z < 0.1) {\n        mouse.zw = -iMouse.xy;\n    } else if(mouse.z < 0.0) {\n        mouse.zw = iMouse.xy;\n    }\n    \n    mouse.xy = iMouse.xy;\n    if (iMouse.z > 0.1 && mouse.z != 0.0) {\n    \tif ( keyIsDown(KEY_W) && mouse.xy != mouse.zw ) {\n        \tvec2 ncenter = uvtoc(center, up, right, (mouse.zw / iResolution.xy - vec2(.5))*2.0);\n            vec2 nup = uvtoc(center, up, right, (mouse.xy / iResolution.xy - vec2(.5))*2.0) - ncenter;\n            center = ncenter;\n            up = nup;\n            mouse.z = 0.0;\n    \t}\n    }\n    \n    viewport = vec4(center, up);\n    \n    if ( keyIsDown(KEY_R) || iFrame <= 1) {\n        viewport = vec4(-0.4,0.0,-1.6,0.0);\n        //param1=vec4(1);\n        //param2=vec4(0);\n        //param3=vec4(0);\n        //param4=vec4(0);\n        //param5=vec4(0);\n    }\n    \n    fragColor = vec4(0);\n    \n    if (keyIsDown(KEY_1)){param1.xy=mouse.xy;}\n    if (keyIsDown(KEY_2)){param2.xy=mouse.xy;}\n    if (keyIsDown(KEY_3)){param3.xy=mouse.xy;}\n    if (keyIsDown(KEY_4)){param4.xy=mouse.xy;}\n    if (keyIsDown(KEY_5)){param5.xy=mouse.xy;}\n    \n    fragColor += save(param1,param1Loc,fragCoord);\n    fragColor += save(param2,param2Loc,fragCoord);\n    fragColor += save(param3,param3Loc,fragCoord);\n    fragColor += save(param4,param4Loc,fragCoord);\n    fragColor += save(param5,param5Loc,fragCoord);\n    \n    fragColor += save(viewport,viewportLoc,fragCoord);\n    fragColor += save(mouse,mouseLoc,fragCoord);\n}\n","name":"Buffer D","description":"","type":"buffer"}]}