{"ver":"0.1","info":{"id":"3lfGD7","date":"1556469131","viewed":166,"name":"Gamma and Digamma","username":"tpfto","description":"Plots of the gamma and digamma functions.\nBoth functions have singularities at the nonpositive integers, so the plots look strange on the left side.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["2d","math","specialfunctions"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// plotter forked from https://www.shadertoy.com/view/4tB3WV\n// gamma function from https://www.shadertoy.com/view/WtlGDN\n\n#define PI 3.14159265359\n\n// dark and light colors from Solarized (https://ethanschoonover.com/solarized/)\n#define DARK vec3(0., 0.169, 0.212)\n#define LIGHT vec3(0.992, 0.965, 0.89)\n#define GRAY vec3(0.396, 0.482, 0.514)\n\n// Solarized \"accent colors\"\n#define YELLOW vec3(0.71, 0.537, 0.)\n#define BLUE vec3(0.149, 0.545, 0.824)\n\n// comment out to switch to light mode\n#define DARK_MODE\n\n// XY range of the display.\n#define DISP_SCALE 8.0 \n\n// Line thickness (in pixels).\n#define LINE_SIZE 2.0\n\n// Tick thickness (in pixels).\n#define TICK_SIZE 1.0\n\n// Tick length.\n#define TICK_LENGTH 0.025 * DISP_SCALE\n\n// Grid line & axis thickness (in pixels).\n#define GRID_LINE_SIZE 1.0\n#define GRID_AXIS_SIZE 2.0\n\n// Number of grid lines per unit.\n#define GRID_LINES 1.0\n\nconst vec2 GRADH = vec2(0.01, 0);\n\n// central differences\n#define GRAD(f, p) (0.5 * vec2(f(p - GRADH.xy) - f(p + GRADH.xy), f(p - GRADH.yx) - f(p + GRADH.yx)) / GRADH.xx)\n\n// PLOT(Function, Color, Destination, Screen Position)\n#define PLOT(f, c, d, p) d = mix(c, d, smoothstep(0.0, (LINE_SIZE / iResolution.y * DISP_SCALE), abs(f(p) / length(GRAD(f,p)))))\n\n// Constants for gamma function approximation\n\n#define LG 5.65\n#define P0 2.506628275635\n#define P1 225.525584619175\n#define P2 -268.295973841305\n#define P3 80.9030806934622\n#define P4 -5.007578639705\n#define P5 0.0114684895435\n\n// gamma and digamma functions, Lanczos approximation (https://doi.org/10.1137/0701008) with Toth's coefficients (https://www.rskey.org/gamma.htm)\n\nfloat Gamma( float x )\n{\n    float xx = (x >= 1.0) ? (x) : (1.0 - x);\n    float sum = P0 + P1/(xx + 1.0) + P2/(xx + 2.0) + P3/(xx + 3.0) + P4/(xx + 4.0) + P5/(xx + 5.0);\n    float xh = xx + LG;\n    float y = exp(log(sum) + (xx + 0.5) * log(xh) - log(xx) - xh);\n\n    return ((x >= 1.0) ? y : (PI/(y * sin(PI * x))));\n}\n\nfloat Psi( float x )\n{\n    float xx = (x >= 1.0) ? (x) : (1.0 - x);\n    float sum1 = P1/((xx + 1.0) * (xx + 1.0)) + P2/((xx + 2.0) * (xx + 2.0)) + P3/((xx + 3.0) * (xx + 3.0)) + P4/((xx + 4.0) * (xx + 4.0)) + P5/((xx + 5.0) * (xx + 5.0));\n    float sum2 = P0 + P1/(xx + 1.0) + P2/(xx + 2.0) + P3/(xx + 3.0) + P4/(xx + 4.0) + P5/(xx + 5.0);\n    float xh = xx + LG;\n    float y = log(xh) - (xh + (LG - 0.5) * xx)/(xx * xh) - sum1/sum2;\n\n    return ((x >= 1.0) ? y : y - PI * cos(PI * x)/sin(PI * x));\n}\n\nfloat GammaPlot(vec2 p)\n{\n\treturn p.y - Gamma(p.x);\n}\n\nfloat PsiPlot(vec2 p)\n{\n\treturn p.y - Psi(p.x);\n}\n\n#define MAKETICK(c) (clamp(1.0 + 0.5 * TICK_LENGTH - abs(c), 0.0, 1.0))\n\nfloat grid(vec2 p, bool showAxes, bool showTicks, bool showGrid)\n{\n\tvec2 uv = mod(p, 1.0 / GRID_LINES);\n\tfloat halfScale = 0.5 / GRID_LINES;\n    \n    float grid = 1.0;\n    float tick = 1.0;\n    float axis = 1.0;\n\t\n    if (showTicks) {\n\tfloat tickRad = (TICK_SIZE / iResolution.y) * DISP_SCALE;\n\ttick = halfScale - max( MAKETICK(p.y) * abs(uv.x - halfScale), MAKETICK(p.x) * abs(uv.y - halfScale));\n\ttick = smoothstep(0.0, tickRad, tick);\n    }\n    \n    if (showGrid) {\n\tfloat gridRad = (GRID_LINE_SIZE / iResolution.y) * DISP_SCALE;\n\tgrid = halfScale - max(abs(uv.x - halfScale), abs(uv.y - halfScale));\n\tgrid = smoothstep(0.0, gridRad, grid);\n    }\n\t\n    if (showAxes) {\n\tfloat axisRad = (GRID_AXIS_SIZE / iResolution.y) * DISP_SCALE;\n\taxis = min(abs(p.x), abs(p.y));\n\taxis = smoothstep(axisRad-0.05, axisRad, axis);\n    }\n\t\n\treturn min(tick, min(grid, axis));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 aspect = iResolution.xy / iResolution.y;\n\tvec2 uv = ( fragCoord.xy / iResolution.y ) - aspect / 2.0;\n\tuv *= DISP_SCALE;\n\t\n    vec3 col = vec3(1.0);\n    \n    // color transition\n    float f = 0.01;\n    float pt = smoothstep(10.0 - f, 10.0 + f, iTime) + smoothstep(30.0 - f, 30.0 + f, 50.0 - f - iTime);\n    float gt = smoothstep(-f, f, iTime - f) + smoothstep(10.0 - f, 10.0 + f, 20.0 - iTime);\n\n    #ifdef DARK_MODE\n    col = mix(GRAY, DARK, grid(uv, true, true, false)); // set up axes and ticks\n    #else\n    col = mix(GRAY, LIGHT, grid(uv, true, true, false));\n    #endif\n    \n    PLOT(PsiPlot, mix(vec3(0.5), BLUE, pt), col, uv); \n    PLOT(GammaPlot, mix(vec3(0.5), YELLOW, gt), col, uv);\n\t\n\tfragColor = vec4( vec3(col), 1.0 );\n}","name":"Image","description":"","type":"image"}]}