{"ver":"0.1","info":{"id":"l3BcWh","date":"1728847742","viewed":196,"name":"Barycentric 2D Texture Filtering","username":"gehtsiegarnixan","description":"Comparison of vanilla, manual trilinear, and 2x barycentric filtering methods and performance testing.","likes":7,"published":3,"flags":0,"usePreview":0,"tags":["test","texture","filtering","barycentric","mip","sample","trilinear","hexagonal","bilinear","tetra"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright Â© 2024 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nComparison of Texture Filtering Methods\n\nLeft: Vanilla trilinear filtering (8 samples)\nRight: Two barycentric filtering (6 samples)\n?: 3D Simplex is 4 samples and should be possible ...\n\nLower sampling may look odd up close but appears similar from a normal \ndistance.\n\nIn theory, fewer texel fetches should be faster, but in practice, they \nare not. This is likely due to GPU hardware optimizations for native \nfunctions, which manual functions do not leverage. This is evident in \nthe comparison between vanilla texture filtering and my manual version, \nwhich perform similarly but the manual version is much slower.\n\nThis shader has mouse controls and several settings in the global \nconstants below. Mouse.x controls the border, while Mouse.y controls \nthe camera height. You can also try the performance test for yourself.\n \nThe test measures frames per second (FPS) on Shadertoy. To ensure valid \nresults, we repeat the test function with varying values and accumulate \ntheir results into a final image.\n\nSteps:\n- Increase REPEAT until the FPS drops below your monitor's refresh rate \n    (likely between 60-144 fps).\n- Modify the TEST value to switch between test cases.\n- The highest FPS indicates the fastest implementation.\n- Celebrate your contribution to SCIENCE!\n*/\n\n// Number of repeats of the test, 3000 should be enough for RTX3080, \n// 1 is comparison view of all 2\n#define REPEAT 1\n\n/* Switch this parameter to change which function is performance tested\nHEABILY depends on the COUNT which makes it also way slower so try gently\n0 = Vanilla Texture Filtering              ~ 104 fps\n1 = Manual Trilinear Texture Filtering     ~ 21 fps\n2 = 2 Barycentric Texture Filtering        ~ 19 fps\n3 = Texel Fetch (no filtering)             ~ 93 fps*/\n#define TEST 0\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    #if REPEAT == 1\n        // Normalized pixel coordinates (from 0 to 1)\n        vec2 uv = fragCoord/iResolution.x;\n\n        // If the mouse was not clicked, animate\n        float border = 0.5;\n        float zoom = 10.0;\n        if (iMouse.x > 0.0) {\n\n            // scale mouse coords to 0-1 range of screen\n            vec2 mouse = iMouse.xy / iResolution.x;\n\n            // Stepped zoom control\n            float zoomSteps = 10.0;\n            zoom = mix(2.0, 800.0, pow((floor(mouse.y * zoomSteps) + \n                               smoothstep(0.75, 1.0, fract(mouse.y * zoomSteps))) \n                               / zoomSteps, 2.0));\n            border = mouse.x;\n        }\n    #else\n        float zoom = 800.0;\n    #endif\n        \n    // Calculate ray direction\n    vec3 ray = vec3(fragCoord / iResolution.xy * 2.0 - vec2(1, 2.0), 1.0);\n\n    // Calculate intersection point on the floor\n    vec2 groundUV = ray.y != 0.0 ? -ray.xz / ray.y : vec2(0);\n        \n    // Find the texture resolution\n    vec2 texSize = vec2(textureSize(iChannel0, 0));\n    \n    // Zoom level\n    groundUV *= zoom / texSize;\n    \n    // Animation for the movement\n    vec2 myTime = iTime / texSize * 2.0;\n    groundUV += vec2(sin(myTime.x), cos(myTime.y));\n\n    // Rotate the coordinates arbitrarily\n    groundUV = rotateUV(groundUV, normalize(vec2(1, 2)));\n    \n    #if REPEAT > 1\n        // if you get around 144 fps use a higher repeat value\n        vec3 color;\n        for(int i=0; i<REPEAT; i++) {\n\n            // unique permutation each iteration        \n            groundUV = fract(groundUV + (float(i)/float(REPEAT)));\n\n            // use which ever you wish to test\n            #if TEST == 0\n                // Vanilla Texture Sample\n                color += texture(iChannel0, groundUV).xyz;            \n            #elif TEST == 1\n                // Manual Trilinear Texture Sample\n                color += trilinearTexture(iChannel0, groundUV).xyz;\n            #elif TEST == 2\n                // 2 Barycentric Texfiltering\n                color += BiBaryTexture(iChannel0, groundUV).xyz;\n            #elif TEST == 3\n                // Texel Fetch (No filtering)\n                color += simpleTexture(iChannel0, groundUV).xyz;\n            #endif\n        }\n        \n        // Ensure test vector stays in visible range\n        color = fract(color);\n        \n    #else\n        // Choose interpolation method based on the x-coordinate\n        vec3 color;\n        if (uv.x < border) {\n            // Left side\n            color = trilinearTexture(iChannel0, groundUV).xyz;\n            //color = texture(iChannel0, groundUV).xyz; // or default texture\n        } else {\n            // Right side\n            color = BiBaryTexture(iChannel0, groundUV).xyz;\n        }\n\n        // Calculate anti-aliasing effect\n        vec2 uvFwidth = fwidth(uv);\n        float aa = max(uvFwidth.x, uvFwidth.y);\n\n        // Add a dividing line\n        float line = 0.002;\n        color -= smoothstep(line+aa, line-aa, abs(uv.x - border));\n    #endif\n\n    // Output to screen\n    fragColor = vec4(color,1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Optional Contrast for nicer noise transitions, but images become worse\n//#define CONTRAST 1.6\n\n// GENERAL FUNCTIONS _____________________________________________________\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See: https://www.desmos.com/calculator/hs1nsjb32q\nfloat smoothContrast(float alpha, float contrast) {\n    // increase steepness using power\n    float powAlpha = pow(alpha, contrast);\n    float powInvAlpha = pow(1.-alpha, contrast);\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha + powInvAlpha);\n}\n\nvec2 smoothContrast(vec2 alpha, float contrast) {\n    // increase steepness using power\n    vec2 powAlpha = pow(alpha, vec2(contrast));\n    vec2 powInvAlpha = pow(1.-alpha, vec2(contrast));\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha + powInvAlpha);\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See: https://www.desmos.com/calculator/n23ntt1nys\nvec3 smoothContrast(vec3 alpha, float contrast) {\n    // increase steepness using power\n    vec3 powAlpha = pow(alpha, vec3(contrast));\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha.x + powAlpha.y + powAlpha.z);\n}\n\n// Rotate UV in vector direction\nvec2 rotateUV(vec2 uv, vec2 direction) {\n\n    // Calculate the rotation matrix\n    mat2 rotationMatrix = mat2( direction.y, direction.x,\n                                -direction.x, direction.y );\n\n    // Rotate the UV coordinates\n    return rotationMatrix * uv;\n}\n\n// TEXTURE FILTERING FUNCTIONS __________________________________________\n\n// Function to calculate the mip level and max mip level\nfloat getMipLevel(sampler2D sam, vec2 uv) {\n\n    // Adjust mip level based on your texture size\n    vec2 texSize = vec2(textureSize(sam, 0));  \n\n    // Scale the partial derivatives by the texture size\n    vec2 scaledDDX = dFdx(uv) * texSize;\n    vec2 scaledDDY = dFdy(uv) * texSize;\n\n    // Find the largest rate of change\n    float maxDDLength = max(dot(scaledDDX, scaledDDX), dot(scaledDDY, scaledDDY));\n\n    // Calculate the mip level based on the rate of change\n    float mipLevel = log2(sqrt(maxDDLength));\n\n    // Find the maximum dimension of the texture\n    float maxDimension = max(texSize.x, texSize.y);\n    \n    // Calculate the highest mip level using the logarithm base 2\n    float highestMipLevel = log2(maxDimension);\n\n    // Return both the mip level and the maximum mip level\n    return clamp(mipLevel, 0., highestMipLevel);\n}\n\n// Bilinear filtering function (4 samples)\nvec4 bilinearTexture(sampler2D tex, vec2 uv, int mip) {\n\n    // Find the texture resolution\n    vec2 texSize = vec2(textureSize(tex, mip));\n\n    // Generate texture coordinates\n    vec2 coords = uv * texSize - 0.5;\n    vec2 id = floor(coords); // Cell id\n    vec2 weights = coords - id; // Technically also the grid\n\n    #ifdef CONTRAST \n        weights = smoothContrast(weights, CONTRAST); // optional\n    #endif\n\n    // Sample the 4 corners of the texture\n    vec4 a = texelFetch(tex, ivec2(mod(id,              texSize)), mip);\n    vec4 b = texelFetch(tex, ivec2(mod(id + vec2(1, 0), texSize)), mip);\n    vec4 c = texelFetch(tex, ivec2(mod(id + vec2(0, 1), texSize)), mip);\n    vec4 d = texelFetch(tex, ivec2(mod(id + vec2(1, 1), texSize)), mip);\n\n    // Bilinear interpolation between the 4 corners\n    return mix(mix(a, b, weights.x), mix(c, d, weights.x), weights.y);\n}\n\n// Manual texture sampling with trilinear filtering (8 samples)\nvec4 trilinearTexture(sampler2D tex, vec2 uv) {\n\n    // Calculate the mip level\n    float mipLevel = getMipLevel(tex, uv);\n\n    // Get the integer and fractional parts of the mip level\n    int mipA = int(floor(mipLevel));\n    float weight = mipLevel - float(mipA);\n\n    // If mip level is an integer, perform bilinear filtering at that mip level\n    if (weight == 0.0) {\n        return bilinearTexture(tex, uv, mipA);\n    }\n\n    #ifdef CONTRAST \n        weight = smoothContrast(weight, CONTRAST); // optional\n    #endif\n\n    // Perform bilinear filtering on the two mip levels\n    vec4 color0 = bilinearTexture(tex, uv, mipA);\n    vec4 color1 = bilinearTexture(tex, uv, mipA + 1);\n\n    // Interpolate between the two mip levels\n    return mix(color0, color1, weight);\n}\n\n// Barycentric filtering function (3 samples)\nvec4 barycentricFilter(sampler2D tex, vec2 uv, int mip) {\n\n    // Find the texture resolution\n    vec2 texSize = vec2(textureSize(tex, mip));\n\n    // Generate texture coordinates\n    #if 0\n        // ++Square pattern (Mirrored)\n        vec2 coords = uv * texSize * 0.5 + 0.25;\n        vec2 id = floor(coords);\n        vec2 grid = abs((coords - id) * 2.0 - 1.0);        \n        vec2 offsetC = (grid.x < grid.y) ? vec2(0, 0.5) : vec2(0.5, 0);\n    \n        ivec2 idA = ivec2(mod((floor(coords + vec2(0.5)) -vec2(0.5)) *2.0, texSize));\n        ivec2 idB = ivec2(mod( floor(coords)                         *2.0, texSize));\n        ivec2 idC = ivec2(mod((floor(coords + offsetC)   -offsetC)   *2.0, texSize));\n\n    #else \n        // Hexagon pattern\n        vec2 coords = uv * texSize - 0.5;\n        vec2 id = floor(coords);\n        vec2 grid = coords - id;\n        vec2 offsetC = (grid.x < grid.y) ? vec2(0, 1) : vec2(1, 0);\n    \n        ivec2 idA = ivec2(mod(id + vec2(1), texSize));\n        ivec2 idB = ivec2(mod(id          , texSize));\n        ivec2 idC = ivec2(mod(id + offsetC, texSize));\n    #endif\n\n    // Sample the 3 corners of the pattern\n    vec4 colorA = texelFetch(tex, idA, mip);\n    vec4 colorB = texelFetch(tex, idB, mip);\n    vec4 colorC = texelFetch(tex, idC, mip);\n\n    // Barycentric Weights\n    float weightA = min(grid.x, grid.y);\n    float weightB = min(1.0 - grid.x, 1.0 - grid.y);\n    vec3 weights = vec3(weightA, weightB, 1.0 - weightA - weightB);\n\n    #ifdef CONTRAST \n        weights = smoothContrast(weights, CONTRAST); // optional\n    #endif\n\n    // Barycentric interpolation between the 3 corners\n    return colorA * weights.x + colorB * weights.y + colorC * weights.z; \n}\n\n// texture filtering with two barycentric filterings (6 samples)\nvec4 BiBaryTexture(sampler2D tex, vec2 uv) {\n\n    // Calculate the mip level\n    float mipLevel = getMipLevel(tex, uv);\n\n    // Get the integer and fractional parts of the mip level\n    int mipA = int(floor(mipLevel));\n    float weight = mipLevel - float(mipA);\n\n    // If mip level is an integer, perform barycentric filtering at that mip level\n    if (weight == 0.0) {\n        return barycentricFilter(tex, uv, mipA);\n    }\n\n    #ifdef CONTRAST \n        weight = smoothContrast(weight, CONTRAST); // optional\n    #endif\n\n    // Perform barycentric filtering on the two mip levels\n    vec4 color0 = barycentricFilter(tex, uv, mipA);\n    vec4 color1 = barycentricFilter(tex, uv, mipA + 1);\n\n    // Interpolate between the two mip levels\n    return mix(color0, color1, weight);\n}\n\n// Manual texture sampling without filtering (1 sample)\nvec4 simpleTexture(sampler2D tex, vec2 uv) {\n\n    // Calculate the mip level\n    float mipLevel = getMipLevel(tex, uv);\n\n    // Get the integer part of the mip level\n    int mip = int(floor(mipLevel));\n\n    // Perform a single texel fetch at the calculated mip level\n    return texelFetch(tex, ivec2(uv * vec2(textureSize(tex, mip))), mip);\n}","name":"Common","description":"","type":"common"}]}