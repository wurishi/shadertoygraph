{"ver":"0.1","info":{"id":"7sSXRR","date":"1619785828","viewed":215,"name":"Refractive Superellipsoid","username":"Holeum","description":"Refractive Superellipsoid formula visualization (convex case).","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","reflection","refraction","cornell","superformula","fresnel","superellipse","superquadric","supershape","superellipsoid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n  Written by Ivan Shevchenko\n  \n  Superellipsoid without refraction: https://www.shadertoy.com/view/4dcBDH\n*/\n\n#pragma optionNV(fastmath off)\n#pragma optionNV(fastprecision off)\nprecision highp float;\n\n#define M_PI 3.1415926535\n#define M_EPSILON pow(2.0, -10.0)\n#define M_SAFE_DISTANCE 10.0 * M_EPSILON\n#define M_TOLERANCE 0.00001\n\n#define MAXIters 24\n#define InitialStepFactor 1.0 / 128.0\n#define TorchColor vec3(1.0, 1.0, 1.0)\n\nconst vec3 PLANECOLOR[6] = vec3[6](vec3(180.0, 16.0 , 18.0 ) / 255.0,  // right\n                                   vec3(51.0 , 180.0, 50.0 ) / 255.0,  // left\n                                   vec3(241.0, 241.0, 212.0) / 255.0,  // top\n                                   vec3(241.0, 241.0, 212.0) / 255.0,  // bottom\n                                   vec3(180.0, 180.0, 180.0) / 255.0,  // near\n                                   vec3(54.0 , 117.0, 135.0) / 255.0); // far\n\n\n// ------------------ Miscellaneous ----------------------\nfloat deg2rad(float deg)\n{\n    return(deg * M_PI / 180.0);\n}\n\nfloat infinite2Unit(float x)\n{\n    x = abs(x);\n    return(sqrt(x / (1.0 + x)));\n}\n\nvec3 snell(in vec3 s, in vec3 n, in float n1, in float n2) {\n\tfloat r1 = n1 / n2;\n\tfloat r2 = r1 * r1;\n\tfloat d = dot(n, s);\n\n    vec3 v1 = (s - (d * n)) *  r1;\n    vec3 v2 = sqrt(1.0 - r2 * (1.0f - d * d)) * n;\n    \n    vec3 r = v1 - v2;\n\treturn(r);\n}\n\n// Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nvec3 Linear2sRGB(const vec3 linear)\n{\n    return pow(linear, vec3(1.0 / 2.2));\n}\n// ------------------ Miscellaneous ----------------------\n\n\n// ------------------ BLAS/LAPACK elements ----------------------\nmat4 QuaternionToMatrix(vec4 q)\n{\n    mat4 m1 = mat4( q.w,  q.z, -q.y, q.x,\n                   -q.z,  q.w,  q.x, q.y,\n                    q.y, -q.x,  q.w, q.z,\n                   -q.x, -q.y, -q.z, q.w);\n\n    mat4 m2 = mat4( q.w,  q.z, -q.y, -q.x,\n                   -q.z,  q.w,  q.x, -q.y,\n                    q.y, -q.x,  q.w, -q.z,\n                    q.x,  q.y,  q.z,  q.w);\n\n    mat4 m = m1 * m2;\n\n    return(m);\n}\n\nmat4 AxisAngleToMatrix(vec3 axis, float angle)\n{\n    float s = sin(angle / 2.0);\n    float c = cos(angle / 2.0);\n\n    vec4 q = vec4(s, s, s, c);\n    q.x *= axis.x;\n    q.y *= axis.y;\n    q.z *= axis.z;\n\n    mat4 m = QuaternionToMatrix(q);\n    return(m);\n}\n\n// pitch (attitude) - rotation around X-axis\n// yaw (heading)    - rotation around Y-axis\n// roll (bank)      - rotation around Z-axis\nmat4 EulerToMatrix(float pitch, float yaw, float roll)\n{\n    // The definition can be found in glm/gtc/quaternion.hpp\n    vec3 c = vec3(cos(pitch / 2.0), cos(yaw / 2.0), cos(roll / 2.0));\n    vec3 s = vec3(sin(pitch / 2.0), sin(yaw / 2.0), sin(roll / 2.0));\n\n    vec4 q = vec4(0.0);\n\n    // XYZ ordering\n    q.x = s.x * c.y * c.z - c.x * s.y * s.z;\n    q.y = c.x * s.y * c.z + s.x * c.y * s.z;\n    q.z = c.x * c.y * s.z - s.x * s.y * c.z;\n    q.w = c.x * c.y * c.z + s.x * s.y * s.z;\n\n    //q = normalize(q);\n    mat4 m = QuaternionToMatrix(q);\n    return(m);\n}\n// ------------------ BLAS/LAPACK elements ----------------------\n\n\n// ------------------ Ray ------------------\nstruct Ray\n{\n\tvec3 Origin;\n\tvec3 Direction;\n};\n\nRay rayConstruct(vec2 uv, mat4 invProj, mat4 invView)\n{\n    // Ray in screen space\n    vec2 sXY = 2.0 * uv - 1.0;\n    vec4 sP0 = vec4(sXY, -1.0, 1.0);\n    vec4 sP1 = vec4(sXY,  1.0, 1.0);\n\n    // Ray in world space\n    vec4 wP0 = invProj * sP0; wP0 /= wP0.w;\n    vec4 wP1 = invProj * sP1; wP1 /= wP1.w;\n   \n    wP0 = invView * wP0;\n    wP1 = invView * wP1;\n    \n    Ray ray = Ray(invView[3].xyz, normalize(wP1.xyz - wP0.xyz));\n    return(ray);\n}\n// ------------------ Ray ------------------\n\n\n// ------------------ Plane ------------------\nstruct Plane\n{\n\tvec3 M;\n\tvec3 Normal;\n};\n\nPlane planeConstruct(vec3 point, vec3 normal)\n{\n    Plane pl;\n    pl.M = point;\n    pl.Normal = normal;\n   \n    return(pl);\n}\n\nbool planeIntersect(Plane pl, Ray ray)\n{\n    float denom = dot(ray.Direction, pl.Normal);\n    if(abs(denom) < M_EPSILON)\n    {\n        return(false);\n    }\n\n    float t = dot((pl.M - ray.Origin), pl.Normal) / denom;\n    if(t < 0.0)\n    {\n        return(false);\n    }\n\n    return(true);\n}\n\nbool planeIntersect(Plane pl, Ray ray, out vec3 ipos, out vec3 norm)\n{\n    float denom = dot(ray.Direction, pl.Normal);\n    if(abs(denom) < M_EPSILON)\n    {\n        return(false);\n    }\n\n    float t = dot((pl.M - ray.Origin), pl.Normal) / denom;\n    if(t < 0.0)\n    {\n        return(false);\n    }\n\n    ipos = ray.Origin + t * ray.Direction;\n    norm = pl.Normal;\n\n    return(true);\n}\n// ------------------ Plane ------------------\n\n\n// ------------------ Box ------------------\nstruct Box\n{\n\tvec3 Center;\n\tvec3 HalfExtents;\n    mat3 Orientation;\n};\n\nBox boxConstruct(in vec3 center, in vec3 halfextents)\n{\n    Box box;\n    box.Center = center;\n    box.HalfExtents = halfextents;\n    box.Orientation = mat3(1.0);\n    \n    return(box);\n}\n\nbool boxIntersect(in Box box, in Ray ray, out vec3 ipoint, out vec3 inormal)\n{\n    // OBB -> AABB\n    vec3 bmin = -box.HalfExtents;\n    vec3 bmax =  box.HalfExtents;\n\n    // Ray vs OBB -> Ray vs AABB\n    mat3 invm = transpose(box.Orientation);\n    vec3 pos = invm * (ray.Origin - box.Center);\n    vec3 dir = invm * ray.Direction;\n    \n    // Hit points with AABB\n    vec3 isign = vec3((dir.x < 0.0)? -1.0: 1.0, (dir.y < 0.0)? -1.0: 1.0, (dir.z < 0.0)? -1.0: 1.0);\n    vec3 idir = vec3((abs(dir.x) > M_EPSILON)? 1.0f / dir.x: isign.x / M_EPSILON,\n                     (abs(dir.y) > M_EPSILON)? 1.0f / dir.y: isign.y / M_EPSILON,\n                     (abs(dir.z) > M_EPSILON)? 1.0f / dir.z: isign.z / M_EPSILON);\n    \n    vec3 v1 = (bmin - pos) * idir;\n    vec3 v2 = (bmax - pos) * idir;\n    vec3 n = min(v1, v2);\n    vec3 f = max(v1, v2);\n\n    float tn = max(n.x, max(n.y, n.z));\n    float tf = min(f.x, min(f.y, f.z));\n    if(tf < 0.0 || tn > tf)\n    {\n        return(false);\n    }\n\n    float t = min(mix(tf, tn, step(0.0, tn)), mix(tn, tf, step(0.0, tf)));\n    vec3 lp = pos + t * dir;\n\n    vec3 d = abs(abs(lp) - box.HalfExtents);\n    float nx = (d.x > M_EPSILON)? 0.0: sign(lp.x);\n    float ny = (d.y > M_EPSILON)? 0.0: sign(lp.y);\n    float nz = (d.z > M_EPSILON)? 0.0: sign(lp.z);\n    vec3 ln = -vec3(nx, ny, nz);\n\n    ipoint = box.Orientation * lp + box.Center;\n    inormal = box.Orientation * ln;\n\n    return(t >= 0.0);\n}\n\nbool boxIntersect(in Box box, in Ray ray)\n{\n    // OBB -> AABB\n    vec3 bmin = -box.HalfExtents;\n    vec3 bmax =  box.HalfExtents;\n\n    // Ray vs OBB -> Ray vs AABB\n    mat3 invm = transpose(box.Orientation);\n    vec3 ori = invm * (ray.Origin - box.Center);\n    vec3 dir = invm * ray.Direction;\n    \n    // Hit points with AABB\n    vec3 v1 = (bmin - ori) / dir;\n    vec3 v2 = (bmax - ori) / dir;\n    vec3 n = min(v1, v2);\n    vec3 f = max(v1, v2);\n\n    float tn = max(n.x, max(n.y, n.z));\n    float tf = min(f.x, min(f.y, f.z));\n    if(tf < 0.0 || tn > tf)\n    {\n        return(false);\n    }\n\n    float t = min(mix(tf, tn, step(0.0, tn)), mix(tn, tf, step(0.0, tf)));\n    return(t >= 0.0);\n}\n\nvec3 boxSideColor(in Box box, in vec3 P, in vec3 N)\n{\n    int xindex = (N.x > 1.0 - M_EPSILON)? 2: ((N.x < -1.0 + M_EPSILON)? 1: 0);\n    int yindex = (N.y > 1.0 - M_EPSILON)? 4: ((N.y < -1.0 + M_EPSILON)? 3: 0);\n    int zindex = (N.z > 1.0 - M_EPSILON)? 6: ((N.z < -1.0 + M_EPSILON)? 5: 0);\n    int index = max(xindex, max(yindex, zindex)) - 1;\n\n    P -= box.Center;\n\n    float a = 1.0;\n    if(index == 3) {\n        float f = mod(floor(6.0 * P.z) + floor(6.0 * P.x), 2.0);\n        a = 0.2 + f * 0.8;\n    }\n    \n    P = min(vec3(1.0), abs(P) / box.HalfExtents);\n    float b = max(P.x, P.y);\n    float c = max(P.y, P.z);\n    float d = max(P.z, P.x);\n    float e = mix(1.0, 0.25, pow(b * c * d, 64.0));\n\n    return(PLANECOLOR[index] * a * e);\n}\n// ------------------ Box ------------------\n\n\n// ------------------ Medium ------------------\nstruct Medium\n{\n    float RefractiveIndex;\n};\n\nMedium mediumConstruct(float n)\n{\n    Medium me;\n    me.RefractiveIndex = n;\n    return(me);\n}\n// ------------------ Medium ------------------\n\n\n// ------------------ Superellipsoid ------------------\nstruct Superellipsoid\n{\n    float RefractiveIndex;\n    vec3 ReflectColor;\n    vec3 RefractColor;\n\n    vec3 Center;\n\tvec3 Radius;\n    vec2 Exponent;\n    mat3 Orientation;    \n};\n\nSuperellipsoid superellipsoidConstruct(in float etha, in vec3 reflectColor, in vec3 refractColor, in vec3 pos, in vec3 radius)\n{\n    vec3 arg = 0.5 + 0.5 * sin(vec3(iTime) / vec3(2.0, 4.0, 3.0));\n    \n    // 0.1 - near to square form, 2.00 - diamond form\n    vec2 e = mix(vec2(0.1), vec2(2.0), arg.xy);\n    \n    vec3 axis0 = vec3(1.0, 0.0, 0.0);\n    vec3 axis1 = vec3(0.0, 1.0, 1.0);\n    vec3 axis2 = vec3(0.0, 0.0, 1.0);\n    vec3 axis = mix(axis0, mix(axis1, axis2, max(0.0, 2.0 * arg.z - 1.0)), min(1.0, 2.0 * arg.z));\n    mat4 o = AxisAngleToMatrix(normalize(axis), deg2rad(360.0 * mod(0.05 * iTime, 1.0)));\n    \n    Superellipsoid se;\n    se.RefractiveIndex = etha;\n    se.ReflectColor = reflectColor;\n    se.RefractColor = refractColor;\n    se.Center = pos;\n    se.Radius = radius;\n    se.Exponent = e;\n    se.Orientation = mat3(o);\n    \n    return(se);\n}\n\n// Superellipsoid Inside-Outside Function\nfloat superellipsoidIOF(vec3 pos, vec3 dir, float t, Superellipsoid se)\n{\n    vec3 e = vec3(vec2(1.0) / se.Exponent.xy, se.Exponent.x / se.Exponent.y);\n    vec3 invr = vec3(1.0) / se.Radius;\n    vec3 p = pos + t * dir;\n\n    vec3 A = p * invr;\n    vec3 B = pow(A * A, e.xxy);\n    float E = B.x + B.y;\n    float F = pow(E, e.z);\n    float P = F + B.z;\n\n    float K = P - 1.0;\n    return(K);\n}\n\nvec3 superellipsoidNormal(vec3 p, Superellipsoid se)\n{\n    vec3 e = vec3(vec2(1.0) / se.Exponent.xy, se.Exponent.x / se.Exponent.y);\n    vec3 g = 2.0 * e;\n    vec3 invr = vec3(1.0) / se.Radius;\n\n    vec3 A = p * invr;\n    vec3 B = pow(A * A, e.xxy);\n    vec3 C = B / A;\n\n    float E = B.x + B.y;\n    float F = pow(E, e.z);\n    float G = e.z * (F / E);\n\n    vec3 n = g.xxy * C * invr;\n    n.xy *= G;\n\n    n = normalize(n);\n    return(n);\n}\n\nbool superellipsoidIntersect(Superellipsoid se, Ray ray, float tolerance)\n{\n    // OBB -> AABB\n    vec3 vmin = -se.Radius;\n    vec3 vmax =  se.Radius;\n\n    // Ray vs OBB -> Ray vs AABB\n    mat3 invm = transpose(se.Orientation);\n    vec3 pos = invm * (ray.Origin - se.Center);\n    vec3 dir = invm * ray.Direction;\n    \n    // Hit points with AABB\n    vec3 isign = vec3((dir.x < 0.0)? -1.0: 1.0, (dir.y < 0.0)? -1.0: 1.0, (dir.z < 0.0)? -1.0: 1.0);\n    vec3 idir = vec3((abs(dir.x) > M_EPSILON)? 1.0f / dir.x: isign.x / M_EPSILON,\n                     (abs(dir.y) > M_EPSILON)? 1.0f / dir.y: isign.y / M_EPSILON,\n                     (abs(dir.z) > M_EPSILON)? 1.0f / dir.z: isign.z / M_EPSILON);\n    \n    vec3 v1 = (vmin - pos) * idir;\n    vec3 v2 = (vmax - pos) * idir;\n    vec3 n = min(v1, v2);\n    vec3 f = max(v1, v2);\n\n    float tn = max(n.x, max(n.y, n.z));\n    float tf = min(f.x, min(f.y, f.z));\n    if(tf < 0.0 || tn > tf)\n    {\n        return(false);\n    }\n    \n    // Iterative proceduare of finding intersection point with superellipsoid    \n    float dt = InitialStepFactor * (tf - tn);\n    float t0 = -2.0 * dt + ((tn < 0.0)? tf: tn);\n    float t1 = -1.0 * dt + ((tn < 0.0)? tf: tn);\n\n    // secant method of root refinement\n    float S0 = superellipsoidIOF(pos, dir, t0, se);\n    float S1 = superellipsoidIOF(pos, dir, t1, se);\n\n    bool success = false;\n    for(int i = 0; i < MAXIters; i++)\n    {\n        float t = t0 - S0 * (t1 - t0) / (S1 - S0);\n\n        t0 = t1;\n        t1 = t;\n\n        S0 = S1;\n        S1 = superellipsoidIOF(pos, dir, t1, se);\n\n        float t_error = abs(t1 - t0) / max(10.0 * tolerance, max(t0, t1));\n        float s_error = S1 * S1;\n        if(t_error < tolerance && s_error < tolerance)\n        {\n            success = true;\n            break;\n        }\n    }    \n    return(success);\n}\n\nbool superellipsoidIntersect(Superellipsoid se, Ray ray, float tolerance, out vec3 ipos, out vec3 norm)\n{\n    // OBB -> AABB\n    vec3 vmin = -se.Radius;\n    vec3 vmax =  se.Radius;\n\n    // Ray vs OBB -> Ray vs AABB\n    mat3 invm = transpose(se.Orientation);\n    vec3 pos = invm * (ray.Origin - se.Center);\n    vec3 dir = invm * ray.Direction;\n    \n    // Hit points with AABB\n    vec3 isign = vec3((dir.x < 0.0)? -1.0: 1.0, (dir.y < 0.0)? -1.0: 1.0, (dir.z < 0.0)? -1.0: 1.0);\n    vec3 idir = vec3((abs(dir.x) > M_EPSILON)? 1.0f / dir.x: isign.x / M_EPSILON,\n                     (abs(dir.y) > M_EPSILON)? 1.0f / dir.y: isign.y / M_EPSILON,\n                     (abs(dir.z) > M_EPSILON)? 1.0f / dir.z: isign.z / M_EPSILON);\n    \n    vec3 v1 = (vmin - pos) * idir;\n    vec3 v2 = (vmax - pos) * idir;\n    vec3 n = min(v1, v2);\n    vec3 f = max(v1, v2);\n\n    float tn = max(n.x, max(n.y, n.z));\n    float tf = min(f.x, min(f.y, f.z));\n    if(tf < 0.0 || tn > tf)\n    {\n        return(false);\n    }\n    \n    // Iterative proceduare of finding intersection point with superellipsoid\n    float dt = InitialStepFactor * (tf - tn);\n    float t0 = -2.0 * dt + ((tn < 0.0)? tf: tn);\n    float t1 = -1.0 * dt + ((tn < 0.0)? tf: tn);\n\n    // secant method of root refinement\n    float S0 = superellipsoidIOF(pos, dir, t0, se);\n    float S1 = superellipsoidIOF(pos, dir, t1, se);\n\n    bool success = false;\n    for(int i = 0; i < MAXIters; i++)\n    {\n        float t = t0 - S0 * (t1 - t0) / (S1 - S0);\n\n        t0 = t1;\n        t1 = t;\n\n        S0 = S1;\n        S1 = superellipsoidIOF(pos, dir, t1, se);\n\n        float t_error = abs(t1 - t0) / max(10.0 * tolerance, max(t0, t1));\n        float s_error = S1 * S1;\n        if(t_error < tolerance && s_error < tolerance)\n        {\n            success = true;\n        \n            vec3 lpos = pos + t1 * dir;\n            norm = superellipsoidNormal(lpos, se);\n            ipos = se.Orientation * lpos + se.Center;\n            norm = se.Orientation * norm;\n            break;\n        }\n    }\n\n    return(success);\n}\n// ------------------ Superellipsoid ------------------\n\n\n// ------------------ Camera ----------------------\nstruct Camera\n{\n    mat4 invProj;\n    mat4 invView;\n};\n\nCamera cameraConstruct(float fovy, float aspect, float near, float far)\n{\n    fovy = deg2rad(fovy);\n\n    Camera camera;\n    camera.invView = mat4(1.0);\n\n    float d = 1.0 / tan(0.5 * fovy);\n    camera.invProj = mat4(aspect / d, 0.0,      0.0, 0.0,\n                          0.0,   1.0 / d,  0.0, 0.0,\n                          0.0,   0.0,      0.0, (near - far) / (2.0 * near * far),\n                          0.0,   0.0,     -1.0, (near + far) / (2.0 * near * far));\n\n    return(camera);\n}\n\nvoid cameraSetOrientation(inout Camera camera, float pitch, float yaw, float roll)\n{\n    pitch = deg2rad(pitch);\n    yaw = deg2rad(yaw);\n    roll = deg2rad(roll);\n    \n    mat4 m = camera.invView;\n    camera.invView = EulerToMatrix(pitch, yaw, roll);\n    camera.invView[3] = m[3];\n}\n\nvoid cameraSetPosition(inout Camera camera, vec3 origin)\n{\n    camera.invView[3] = vec4(origin, 1.0);\n}\n\nRay cameraGetRay(Camera camera, vec2 uv)\n{\n    Ray ray = rayConstruct(uv, camera.invProj, camera.invView);\n    return(ray);\n}\n// ------------------ Camera ----------------------\n\n\n// ------------------ Lighting ------------------\nstruct PointLight\n{\n\tvec3 Color;\n\tvec3 Position;\n    float a; // const attenuation factor\n    float b; // linear attenuation factor\n    float c; // exponential attenuation factor\n};\n\nPointLight constructPointLight(vec3 color, vec3 pos, float a, float b, float c) {\n    PointLight light;\n    light.Color = color;\n    light.Position = pos;\n    light.a = a;\n    light.b = b;\n    light.c = c;\n    return(light);\n}\n\nvoid pointLightParams(PointLight light, vec3 dst, out vec3 color, out vec3 dir) {\n    dir = light.Position - dst;\n    float dist = length(dir);\n    dir.xyz /= dist;    \n\n    color = light.Color / (light.a + dist * (light.b + light.c * dist));\n}\n\nfloat Fresnel(in float etha_i, in float etha_t, in float cos_theta)\n{\n    float cos_i = cos_theta;\n\n    // Compute sin_t using Snell's law    \n    float sin_t = (etha_i / etha_t) * sqrt(max(0.0, 1.0 - cos_i * cos_i)); \n\n    float F = 1.0; // Total internal reflection\n    if(sin_t < 1.0)\n    { \n        float cos_t = sqrt(max(0.0, 1.0 - sin_t * sin_t)); \n        cos_i = abs(cos_i); \n        float Rs = ((etha_t * cos_i) - (etha_i * cos_t)) / ((etha_t * cos_i) + (etha_i * cos_t)); \n        float Rp = ((etha_i * cos_i) - (etha_t * cos_t)) / ((etha_i * cos_i) + (etha_t * cos_t)); \n        F = (Rs * Rs + Rp * Rp) / 2.0; \n    }\n    return(F);\n}\n\nvec3 lambert(vec3 I, vec3 L, vec3 N) {\n    float NdotL = dot(N, L);\n    vec3 brightness = max(0.0, NdotL) * (I / M_PI);\n    return(brightness);\n}\n\nvec3 normalized_blinn_phong(vec3 I, vec3 L, vec3 V, vec3 N, float etha_i, float etha_t, float alpha)\n{\n    vec3 H = normalize(L + V);\n    float NdotL = dot(N, L);\n    float NdotH = dot(N, H);\n    float LdotH = dot(L, H);\n    float F = Fresnel(etha_i, etha_t, LdotH);\n\n    vec3 brightness = ((alpha + 2.0) / 8.0) * pow(max(NdotH, 0.0), alpha) * F * (max(0.0, NdotL) * I);\n    return(brightness);\n}\n\nfloat calcShadowAttenuation(vec3 P, vec3 Ld, Superellipsoid se)\n{\n    Ray ray = Ray(P, Ld);\n    bool isIntersect = superellipsoidIntersect(se, ray, 1.0e-06);\n    \n    return((isIntersect)? 0.25: 1.0);\n}\n// ------------------ Lighting ------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 P = vec3(0.0, 0.0, 1.05); // default viewer position\n    float aspect = iResolution.x / iResolution.y;\n    float near = 0.1;\n    float far = 32.0;\n\n    Camera camera = cameraConstruct(90.0, aspect, near, far);\n    cameraSetOrientation(camera, 0.0, 0.0, 0.0);\n    cameraSetPosition(camera, P);\n\n    vec2 uv = fragCoord / iResolution.xy;\n    Ray ray = cameraGetRay(camera, uv);\n\n    // scene rendering\n    Box cornellBox;\n    cornellBox.Center = vec3(0.0, 0.0, 0.0);\n    cornellBox.HalfExtents = vec3(1.1, 1.1, 1.1);\n    cornellBox.Orientation = mat3(1.0);\n\n    vec3 pos = vec3(0.0, 0.0, 0.0);\n    vec3 radius = vec3(7.0 / 24.0, 7.0 / 24.0, 7.0 / 24.0);\n    Superellipsoid se = superellipsoidConstruct(1.5, vec3(1.0), vec3(0.53, 0.81, 0.92), pos, radius);\n    \n    Medium me = mediumConstruct(1.0); // medium\n    \n    PointLight light = constructPointLight(TorchColor, vec3(0.75, 0.75, 1.0), 0.0, 0.0, 0.15);\n    vec3 Lc, Ld;\n\n    // ray vs superellipsoid\n    vec3 ipoint = ray.Direction * far;\n    vec3 normal = vec3(0.0);\n    \n    vec3 color = vec3(0.0);\n    vec3 rl_brightness = vec3(0.0);\n    vec3 rr_brightness = vec3(0.0);\n\n    bool isIntersect = superellipsoidIntersect(se, ray, M_TOLERANCE, ipoint, normal);\n    if(isIntersect)\n    {\n        // reflective part\n        pointLightParams(light, ipoint, Lc, Ld);\n        rl_brightness += normalized_blinn_phong(Lc, Ld, -ray.Direction, normal, 1.0, 1.5, 256.0);\n\n        Ray ray2 = Ray(ipoint, reflect(ray.Direction, normal));\n        vec3 ipoint2 = vec3(0.0);\n        vec3 normal2 = vec3(0.0);\n\n        //ray vs box\n        isIntersect = boxIntersect(cornellBox, ray2, ipoint2, normal2);\n        if(isIntersect)\n        {\n            pointLightParams(light, ipoint2, Lc, Ld);\n            rl_brightness += boxSideColor(cornellBox, ipoint2, normal2) * lambert(Lc, Ld, normal2);\n        }\n\n        // refractive part\n        vec3 inormal = normal;\n        vec3 iraydir = -ray.Direction;\n        \n        ray.Direction = snell(ray.Direction, normal, me.RefractiveIndex, se.RefractiveIndex);\n        ray.Origin = ipoint + M_SAFE_DISTANCE * ray.Direction;\n\n        isIntersect = superellipsoidIntersect(se, ray, M_TOLERANCE, ray.Origin, normal);\n\n        vec3 onormal = -normal;\n        vec3 oraydir = -ray.Direction;\n        \n        ray.Direction = snell(ray.Direction, -normal, se.RefractiveIndex, me.RefractiveIndex);\n        ray.Origin = ray.Origin + M_SAFE_DISTANCE * ray.Direction;\n\n        isIntersect = boxIntersect(cornellBox, ray, ipoint, normal);\n        if(isIntersect)\n        {\n            // account sun lighting\n            pointLightParams(light, ipoint, Lc, Ld);\n            vec3 brightness = lambert(Lc, Ld, normal);\n            vec3 box_albedo = boxSideColor(cornellBox, ipoint, normal);\n            rr_brightness += box_albedo * brightness;\n\n            // shadow\n            float attenuation = calcShadowAttenuation(ipoint, Ld, se);\n            rr_brightness *= attenuation;\n\n            float Fi = Fresnel(me.RefractiveIndex, se.RefractiveIndex, max(0.0, dot(inormal, iraydir)));\n            float Fo = Fresnel(se.RefractiveIndex, me.RefractiveIndex, max(0.0, dot(onormal, oraydir)));\n            rr_brightness *= (1.0 - Fi) * (1.0 - Fo);\n        }\n\n        // final color\n        color = se.ReflectColor * rl_brightness + se.RefractColor * rr_brightness;\n    }\n    else\n    {\n        //ray vs box\n        isIntersect = boxIntersect(cornellBox, ray, ipoint, normal);\n        if(isIntersect)\n        {\n            // account sun lighting\n            pointLightParams(light, ipoint, Lc, Ld);\n            vec3 brightness = lambert(Lc, Ld, normal);\n            \n            vec3 box_albedo = boxSideColor(cornellBox, ipoint, normal);\n            color = box_albedo * brightness;\n\n            // shadow\n            float attenuation = calcShadowAttenuation(ipoint, Ld, se);\n            color *= attenuation;\n        }\n    }\n\n    // Tone mapping\n    color = ACESFilm(color);\n\n    // Gamma correction\n    color = Linear2sRGB(color);\n\n    float vignette = pow(32.0 * uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y), 0.05);\n    fragColor = vec4(color * vignette, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}