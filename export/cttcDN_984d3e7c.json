{"ver":"0.1","info":{"id":"cttcDN","date":"1699222296","viewed":205,"name":"Raymarch beams","username":"Soliform","description":"It is raymarched beams. Inspired by https://akari.lusion.co/#home\nNow updated!","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Light {\n    vec3 color;\n\t\n    float constant;\n    float linear;\n    float quadratic;\n};\n\nstruct Line {\n    vec2 point1;\n    vec2 point2;\n    float stroke;\n    \n    Light light;\n};\n\nstruct Sphere {\n    vec2 position;\n    float radius;\n    \n    Light light;\n};\n\nstruct Shape {\n    int shapeType;\n    bool emissive;\n    \n    Light light;\n    \n    Line line;\n    Sphere sphere;\n};\n\nconst float distanceX = 50.0;\n\n// If your PC is struggling with performance, try lowering step count to 64 or 32.\n// Also try setting the max trace distance higher, to something like .2 or .4\nconst int STEP_COUNT = 256;\nconst float MIN_HIT_DIST = 0.001;\nconst float MAX_TRACE_DIST = 0.1; \nconst float SHADOW_SOFTNESS = 0.3; // the lower the sharper. 0.3 is ideal\nconst vec3 BACKGROUND_COLOR = vec3(0.01,0.02,0.05);\n\n\nconst int SHAPE_COUNT = 4;\n\nShape shapes[SHAPE_COUNT];\n\nvec2 convertPixelToPos(vec2 pixel) {\n    return ((pixel / iResolution.xy) - 0.5 ) * vec2(distanceX, distanceX * (iResolution.y / iResolution.x));\n}\n\nvec3 getAttenuation(Shape shape, vec2 lightDirection, float dist) {\n    float multiplier = 1.0;\n    \n    if (shape.shapeType == 0) {\n        vec2 normal = normalize(shape.line.point1 - shape.line.point2);\n        normal = vec2(-normal.y, normal.x);\n        multiplier = abs(dot(lightDirection, normal));\n        multiplier = 1.0 - exp(-multiplier) * (1.0 - multiplier);\n    }\n    \n    return shape.light.color * multiplier * (1.0 / (shape.light.constant + shape.light.linear * dist + \n    \t\t    shape.light.quadratic * (dist * dist)));\n}\n\nvec2 getClosestPointOnLine(Line line, vec2 p) {\n    vec2 ba = line.point2-line.point1;\n    vec2 pa = p-line.point1;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n      \n    return line.point1 + h*ba;\n}\n\nfloat segmentSDF(vec2 p, Shape shape) {\n    vec2 ba = shape.line.point2 - shape.line.point1;\n    vec2 pa = p - shape.line.point1;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    \n    return length(pa-h*ba) - shape.line.stroke;\n}\n\nfloat sphereSDF(vec2 p, Shape shape) {\n    return distance(p, shape.sphere.position) - shape.sphere.radius;\n}\n\nfloat getDistance(vec2 p, Shape shape) {\n    switch(shape.shapeType) {\n        case 0:\n            return segmentSDF(p, shape);\n        case 1:\n            return sphereSDF(p, shape);\n    }\n}\n\nvec2 segmentCP(vec2 p, Shape shape) {\n    vec2 ba = shape.line.point2 - shape.line.point1;\n    vec2 pa = p - shape.line.point1;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n      \n    return shape.line.point1 + h*ba;\n}\n\nvec2 sphereCP(vec2 p, Shape shape) {\n    vec2 dir = normalize(shape.sphere.position - p);\n    return shape.sphere.position + dir * shape.sphere.radius;\n}\n\nvec2 getClosestPoint(vec2 p, Shape shape) {\n    switch(shape.shapeType) {\n        case 0:\n            return segmentCP(p, shape);\n        case 1:\n            return sphereCP(p, shape);\n    }\n}\n\nfloat getNearestDist(vec2 position, int ignoreIndex) {\n    float smallestDist = 10000.0;\n    \n    for (int i = 0; i < SHAPE_COUNT; i++) {\n        if (i == ignoreIndex) continue;\n    \n        smallestDist = min(smallestDist, getDistance(position, shapes[i]));\n    }\n    \n    return smallestDist;\n}\n\n\nvec3 getShapeEmission(int shapeIndex, vec2 position) {\n    Shape shape = shapes[shapeIndex];\n    \n    float distToLight = getDistance(position, shape);\n    \n    // Totally legit anti aliasing\n    if (distToLight <= 0.0) {\n        if (abs(distToLight) <= 0.05) {\n            float t = (distToLight + 0.05) / 0.1;\n            return mix(vec3(1.0,1.0,1.0), getAttenuation(shape, vec2(5.0,5.0), 0.0), 1.0-(1.0-t)*(1.0-t));\n        } else {\n            return vec3(1.0,1.0,1.0);\n        }\n    }\n    \n    vec2 lightPosition = getClosestPoint(position, shape);\n    vec2 rayDir = (lightPosition - position) / distToLight;\n    \n    float res = 1.0;\n    float ph = 1e20;\n    float t = MIN_HIT_DIST;\n    \n    for (int i = 0; i < STEP_COUNT; i++) {\n        vec2 pos = position + rayDir * t;\n        float h = getNearestDist(pos, shapeIndex);\n        \n        res = min(res, h/(SHADOW_SOFTNESS*t));\n        t += clamp(h, MIN_HIT_DIST, MAX_TRACE_DIST);\n        \n        if( res<-1.0 || t>distToLight) break;\n    }\n    \n    res = max(res,-1.0);\n    res = 0.25*(1.0+res)*(1.0+res)*(2.0-res);\n    \n    \n    vec3 attenuation = getAttenuation(shape, rayDir, distToLight);\n       \n    return attenuation * res;\n}\n\nbool flicker(float seed, float speed) {\n    seed = seed / speed;\n    seed += iTime;\n    return cos( sin(seed / (0.1 * radians(180.0))) + cos(1.5 * seed) ) + sin(seed / (radians(180.0)) + cos(10.0 * seed)) > 1.9;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Red line\n    Light lineLight0;\n    lineLight0.constant = 1.0;\n    lineLight0.linear = 0.5;\n    lineLight0.quadratic = 0.03;\n    lineLight0.color = vec3(0.95,0.2,0.3);\n    \n    float xOffset = sin(iTime*0.1);\n    xOffset = xOffset * xOffset * xOffset;\n    \n    shapes[0].shapeType = 0;\n    shapes[0].emissive = !flicker(0.0, 35.0);\n    shapes[0].light = lineLight0;\n    shapes[0].line.point1 = vec2(-15.0 + xOffset*50.0,8.0);\n    shapes[0].line.point2 = vec2(15.0 + xOffset*50.0,8.0);\n    shapes[0].line.stroke = 0.1;\n    \n    \n    // Green line\n    Light lineLight1;\n    lineLight1.constant = 1.0;\n    lineLight1.linear = 0.5;\n    lineLight1.quadratic = 0.03;\n    lineLight1.color = vec3(0.3,0.7,0.3);\n    \n    xOffset = cos(iTime*0.25);\n    xOffset = xOffset * xOffset * xOffset;\n    \n    shapes[1].shapeType = 0;\n    shapes[1].emissive = !flicker(7.0, 49.0);\n    shapes[1].light = lineLight1;\n    shapes[1].line.point1 = vec2(-10.0 + xOffset * 50.0,-2.0);\n    shapes[1].line.point2 = vec2(15.0 + xOffset * 50.0,-2.0);\n    shapes[1].line.stroke = 0.1;\n    \n    \n    // Blue line\n    Light lineLight2;\n    lineLight2.constant = 1.0;\n    lineLight2.linear = 0.5;\n    lineLight2.quadratic = 0.03;\n    lineLight2.color = vec3(0.15,0.4,0.7);\n    \n    xOffset = sin(iTime * 0.3 + 0.5);\n    xOffset = xOffset * xOffset * xOffset;\n    \n    shapes[2].shapeType = 0;\n    shapes[2].emissive = !flicker(24.0, 69.0);\n    shapes[2].light = lineLight2;\n    shapes[2].line.point1 = vec2(-14.0 + xOffset * 50.0,-7.0);\n    shapes[2].line.point2 = vec2(13.0 + xOffset * 50.0,-7.0);\n    shapes[2].line.stroke = 0.1;\n    \n    \n    // sphere\n    Light sphereLight0;\n    sphereLight0.constant = 0.8;\n    sphereLight0.linear = 0.15;\n    sphereLight0.quadratic = 0.005;\n    sphereLight0.color = vec3(0.5,0.4,0.1);\n    \n\n    shapes[3].shapeType = 1;\n    shapes[3].emissive = true;\n    shapes[3].light = sphereLight0;\n    shapes[3].sphere.position = convertPixelToPos(iMouse.xy);\n    shapes[3].sphere.radius = 1.;\n    \n    vec2 position = convertPixelToPos(fragCoord);\n    vec3 color = BACKGROUND_COLOR;\n    \n    \n    for (int i = 0; i < SHAPE_COUNT; i++) {\n        if (shapes[i].emissive) {\n            color += getShapeEmission(i, position);\n        }\n    }\n    \n    fragColor = vec4(color.xyz, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}