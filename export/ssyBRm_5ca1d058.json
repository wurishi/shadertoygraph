{"ver":"0.1","info":{"id":"ssyBRm","date":"1657912447","viewed":144,"name":"Gas Giant Shader","username":"trelane1701","description":"gas giant","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["gasgiant"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"    \n    uniform float     seed;\n    uniform int index;\n    uniform float resolution;\n     vec2 vUv;\n     vec3 vPosition;\n     vec3 vNormal;\n    vec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+10.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n// number of octaves of fbm\n#define NUM_NOISE_OCTAVES 10\n\n// size of the planet\n#define PLANET_SIZE\t\t1.0\n// uncomment to use a simple sharpen filter\n// #define SHARPEN\n// simple and fast smoothing of outside border\n#define SMOOTH\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// Noise functions:\n//////////////////////////////////////////////////////////////////////////////////////\n\n// Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\n\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    float n = dot(i, step);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat fbm(vec3 x,float seed) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(seed);\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * noise(x *4.0);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n        \n\t}\n\treturn v;\n}\n\n//////////////////////////////////////////////////////////////////////////////////////\n// Visualization:\n//////////////////////////////////////////////////////////////////////////////////////\n\nconst float pi          = 3.1415926535;\nconst float inf         = 9999999.9;\nfloat square(float x) { return x * x; }\nfloat infIfNegative(float x) { return (x >= 0.0) ? x : inf; }\n\n// C = sphere center, r = sphere radius, P = ray origin, w = ray direction\nfloat intersectSphere(vec3 C, float r, vec3 P, vec3 w) {\t\n\tvec3 v = P - C;\n\tfloat b = -dot(w, v);\n\tfloat c = dot(v, v) - square(r);\n\tfloat d = (square(b) - c);\n\tif (d < 0.0) {d=-d;} //{ return inf; }\t\n\tfloat dsqrt = sqrt(d);\n\t\n    float inter = min(((b - dsqrt)), ((b + dsqrt)));\n    if (inter<0.0) {inter=-inter;}\n    return inter;\n\t// Choose the first positive intersection\n\treturn min(infIfNegative((b - dsqrt)), infIfNegative((b + dsqrt)));\n}\n\n// returns max of a single vec3\nfloat max3 (vec3 v) {\n  return max (max (v.x, v.y), v.z);\n}\n\n\n\n\nvec3 getColorForCoord(vec3 fragCol,vec2 fragCoord,float seed) {\n    // (intermediate) results of fbm\n    vec3 q = vec3(0.0);\n    vec3 r = vec3(0.0);\n    vec3 d =vec3(0.0);\n\tfloat v = 0.0;\n    float bcn=0.0;\n    vec3 color = fragCol;//vec3(0.0);\n\n    // planet rotation\n    float theta = iTime * 0.15;  \n    mat3 rot = mat3(\n        cos(theta), 0, sin(theta),\t// column 1\n        0, 1, 0,\t                // column 2\n        -sin(theta), 0, cos(theta)\t// column 3\n    );\n\n    // Ray-sphere\n    const float verticalFieldOfView = 360.0; //* pi / 360.0;\n\n    // position of viewpoint (P) and ray of vision (w)\n    vec3 P = vec3(0.0, 0.0, 5.0);\n    vec3 w = normalize(vec3(fragCoord.xy - iResolution.xy * 0.5, (iResolution.y) / (-2.0 * tan(verticalFieldOfView / 2.0))));\n\n    // calculate intersect with sphere (along the \"line\" of w from P)\n    float t = intersectSphere(vec3(0, 0, 0), PLANET_SIZE, P, w);\n       \n    // calculate point of intersection on the sphere\n    //t=0.2;\n    vec3 X = P + w*t*(0.5);\n\n    // apply rotation matrix\n   // X = rot*X;\n\n    // calculate fbm noise (3 steps)\n    q = vec3(fbm(X + 0.05*iTime,seed), fbm(X,seed), fbm(X,seed));\n    r = vec3(fbm(X + 1.0*q + 0.01*iTime,seed), fbm(X + q,seed), fbm(X + q,seed));\n  //  bcn = basecnoise(r,0.01*iTime,0.3);\n   // d = vec3(bcn,bcn,bcn);\n    v = fbm(X + 5.0*r + iTime*0.005,seed);\n\n    \n    // convert noise value into color\n    // three colors: top - mid - bottom (mid being constructed by three colors)\n//    vec3 col_top = vec3(1.0, 1.0, 1.0);\n//    vec3 col_bot = vec3(0.0, 0.0, 0.0);\n//    vec3 col_mid1 = vec3(0.1, 0.2, 0.0);\n//    vec3 col_mid2 = vec3(0.7, 0.4, 0.3);\n//    vec3 col_mid3 = vec3(1.0, 0.4, 0.2);\n\n\n     vec3 col_top = vec3(0.0, 0.5, 0.0);\n     vec3 col_bot = vec3(0.0, 1.0, 1.0);\n     vec3 col_mid1 = vec3(0.0, 1.0, 0.0);\n     vec3 col_mid2 = vec3(0.0, 0.0, 1.0);\n     vec3 col_mid3 = vec3(0.0, 0.0, 1.0);\n    // mix mid color based on intermediate results\n    vec3 col_mid = mix(col_mid1, col_mid2, clamp(r, 0.0, 1.0));\n    col_mid = mix(col_mid, col_mid3, clamp(q, 0.0, 1.0));\n    col_mid = col_mid;\n\n    // calculate pos (scaling betwen top and bot color) from v\n    float pos = v * 2.0 - 1.0;\n    \n    color = mix(col_mid, col_top, clamp(pos, 0.0, 1.0));\n    color = mix(color, col_bot, clamp(-pos, 0.0, 1.0));\n\n    // clamp color to scale the highest r/g/b to 1.0\n    color = color / max3(color);\n      \n    // create output color, increase light > 0.5 (and add a bit to dark areas)\n    color = (clamp((0.4 * pow(v,3.) + pow(v,2.) + 0.5*v), 0.0, 1.0) * 0.9 + 0.1) * color;\n    \n    // apply diffuse lighting  \n    float diffuse = 0.0;//max(0.0, dot(P + w*t, vec3(1.0, sqrt(0.5), 0.7)));\n    float ambient = 0.1;\n    color *= clamp((diffuse + ambient), 0.0, 1.0);\n    \n#ifdef SMOOTH\n    // apply a smoothing to the outside\n    color *= (P + w*t).z * 2.0;\n#endif    \n    \n    return color;\n}\n//va/rying vec3 vNormal;\n//varying vec3 vPosition;\nfloat nnoise(vec3 position, int octaves, float frequency, float persistence) {\n    float total = 0.0; // Total value so far\n    float maxAmplitude = 0.0; // Accumulates highest theoretical amplitude\n    float amplitude = 1.0;\n    for (int i = 0; i < octaves; i++) { // Get the noise sample\n    total += snoise(position * frequency*seed) * amplitude; // Make the wavelength twice as small\n    frequency *= 2.0; // Add to our maximum possible amplitude\n    maxAmplitude += amplitude; // Reduce amplitude according to persistence for the next octave\n    amplitude *= persistence;\n    } // Scale the result by the maximum amplitude\n    return total / maxAmplitude;\n}\n\nfloat ridgedNoise(vec3 position, int octaves, float frequency, float persistence) {\n    float total = 0.0; // Total value so far\n    float maxAmplitude = 0.0; // Accumulates highest theoretical amplitude\n    float amplitude = 1.0;\n    for (int i = 0; i < octaves; i++) { // Get the noise sample\n    total += ((1.0 - abs(snoise(position * frequency))) * 2.0 - 1.0) * amplitude;\n    frequency *= 2.0; // Add to our maximum possible amplitude\n    maxAmplitude += amplitude; // Reduce amplitude according to persistence for the next octave\n    amplitude *= persistence;\n    } // Scale the result by the maximum amplitude\n    return total / maxAmplitude;\n}\n\nvec3 addDistortions(vec3 fragColor)\n{\n    vec3 position = vNormal + vec3(iTime, 0.0, (iTime/10.0)); // Base noise\n    float n1 = nnoise(position , 6, 10.0, 0.8) * 0.01;\n    float n2 = ridgedNoise(position , 5, 5.8, 0.75) * 0.015 - 0.01; // Get the three threshold samples\n    float s = 0.6;\n    float t1 = snoise(position * 2.0) - s;\n    float t2 = snoise((position + 800.0) * 2.0) - s;\n    float t3 = snoise((position + 1600.0) * 2.0) - s; // Intersect them and get rid of negatives\n    float threshold = max(t1 * t2 * t3, 0.0); // Storms\n    float n3 = snoise(position * 0.1) * threshold;\n    float n = n1 + n2 + n3;\n    n=n/1.0;\n    fragColor.r=fragColor.r;\n    fragColor.g=fragColor.g+n;//+(n/5.0);//;+t2;\n    fragColor.b=fragColor.b+n;//+t3;\n    \n    return fragColor;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor.rgb = getColorForCoord(fragColor.rgb,fragCoord,9.7);\n   // fragColor.rgb = addDistortions(fragColor.rgb);\n    fragColor.a =1.0;\n}\n","name":"Image","description":"","type":"image"}]}