{"ver":"0.1","info":{"id":"wld3W4","date":"1576421983","viewed":124,"name":"tests with sdfs, leech teeth","username":"sasha_sortai","description":"a test to see how sdfs combine, coded in Bozomatic","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI acos(-1.)\n//prototypes\nmat3 cspace(vec3);\nmat3 inter(vec3, vec3);\nfloat de(vec3);\nvec3 grade(vec3);\nfloat cir(vec3, float);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  float period = 360.;\n  float time = fract(iTime/period)*period;\n  vec3 col;\n  vec2 uv = (gl_FragCoord.xy-.5*iResolution.xy)*2./min(iResolution.x,iResolution.y); //the (-1;1)^2 square is always inside the initial screen coordinates\n  uv = (uv*2.+vec2(0,0)); //remapping to whatever patch we need\n  \n  //camera setup\n  vec3 cpos = vec3(cos(time*PI/8.),sin(time*PI/8.),1.25)*sqrt(.5)*12.;\n  vec3 tpos = vec3(0,0,-1.5);\n  mat3 ctra = cspace(normalize(tpos-cpos));\n  vec3 ray = normalize(ctra*vec3(uv,2.6));\n  \n  mat3 mr = inter(cpos,ray);\n  \n  if (mr[2]==vec3(-1)) col = vec3(.1,.2,.3)*.7;\n  else\n  {\n    col = (normalize(mr[1])+1.)/2.;\n    col *= max(0.,dot(normalize(mr[1]),normalize(vec3(5)-mr[0])))+.5*dot(normalize(mr[1]),normalize(vec3(1,-.3,0)))+.05;\n  }\n  \n  //col = pow(col,vec3(1.5+sin(time*2.*PI/24.)));\n  \n  if (1!=1)\n  {\n    int np = 10;\n    col *= float(float(np))-.5;\n    col = floor(col);\n    col /= float(np);\n  }\n  \n  fragColor = vec4(col,1);\n}\n\n\nmat3 cspace(vec3 fo)\n{\n  mat3 res;\n  res[2] = fo;\n  res[0] = cross(fo, vec3(0,0,1));\n  res[1] = cross(res[0],fo);\n  return res;\n}\n\nmat3 inter(vec3 cpos, vec3 ray)\n{\n  mat3 res = mat3(0);\n  int hit = 0;\n  float h; float t = 0.;\n  for (int i = 0; i<250; i++)\n  {\n    h = de(cpos+t*ray);\n    if (h<.0005)\n    {\n      hit = 1;\n      break;\n    }\n    t+=h;\n  }\n  res[0] = cpos+t*ray;\n  res[1] = grade(cpos+t*ray);\n  if (hit==0) res[2] = vec3(-1);\n  return res;\n}\n\nfloat de(vec3 p)\n{\n  /*\n  p = abs(p);\n  vec3 q = vec3(min(p.x,1.), min(p.y,1.), min(p.z,1.));\n  return distance(p,q)-1.;\n  */\n  \n  float r=sin(iTime*PI/2.)*4.;\n  float t = 0.;\n  for (int i = 0; i<3; i++)\n  {\n    //t+=1./distance(p,r*vec3(cos(PI*2.*i/6.), sin(PI*2.*i/6.),0));\n    t+=exp(-distance(p,r*vec3(cos(PI*2.*float(i)/3.), sin(PI*2.*float(i)/3.),0)));\n  }\n  \n  return -log(exp(-max(-log(t)-1.,abs(p.z)-.1))+exp(.5-cir(p,4.)));\n  \n}\n\nvec3 grade(vec3 p)\n{\n  vec3 e = vec3(.001,0,0);\n  return vec3(\n    de(p+e.xyz)-de(p-e.xyz),\n    de(p+e.zxy)-de(p-e.zxy),\n    de(p+e.yzx)-de(p-e.yzx)\n  )/(e.x*2.);\n}\n\nfloat cir(vec3 p, float r)\n{\n  vec3 q = vec3(p.xy/length(p.xy),0);\n  return distance(p, r*q);\n}","name":"Image","description":"","type":"image"}]}