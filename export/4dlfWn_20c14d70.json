{"ver":"0.1","info":{"id":"4dlfWn","date":"1496353504","viewed":315,"name":"HyperSphere 5x5x5","username":"JCDjcd","description":"4D sphere with 5 wires along each angle alpha,beta,gamma (parameterizing the hypersphere).\nAlpha (resp. beta and gamma) wires are displayed in red (resp. green and blue).\nIntersections of 2 wires (different color) are yellow, cyan or purple... 3 is white.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["sphere","4d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//--------------------------------------------------------------------------\n#define TWOPI \t\t\t(2.0*3.1415926535)\n#define ROTATION(alpha) mat2(cos(alpha),-sin(alpha),sin(alpha),cos(alpha))\n#define COLORIZATION(h)\tclamp(abs(fract(h+vec4(3.0,2.0,1.0,0.0)/3.0)*6.0-3.0)-1.0,0.0,1.0)\n\n//--------------------------------------------------------------------------\n// Ray is defined by M(t1,t2) = P + t1.d1 + t2.d2\nvec4 compute(vec4 P,vec4 d1,vec4 d2,int method /* 0-left or 1-right */)\n{    \n\t// compute the intersections with the hypersphere\n    // it turns out that it is specifically a circle\n    float t1_center = -dot(P,d1);\n    float t2_center = -dot(P,d2);\n    float r2 \t\t= 1.0 + t1_center*t1_center + t2_center*t2_center - dot(P,P);\n    \n    if(r2 < 0.0)\n    {\n        return vec4(0.0,0.0,0.0,1.0);\n    }\n    else\n    {\n        float r \t= sqrt(r2);\n        int N \t\t= 200+int(400.0*r);\n        vec4 color \t= vec4(0.0,0.0,0.0,1.0);\n        for(int i=0;i<=N;i++)\n        {\n            // angle along the circle within the (z,w) plan\n            float q  = TWOPI*float(i)/float(N);\n            float t1 = t1_center+r*cos(q); // z\n            float t2 = t2_center+r*sin(q); // w\n            \n            vec4 M    = P + t1*d1 + t2*d2;\n            M \t\t  = M/sqrt(dot(M,M)); // solve roudning issue => slight renormalization to 1\n            \n            float gamma = acos(M.w);\n            float beta \t= atan(sqrt(M.x*M.x+M.y*M.y),M.z);\n            float alpha\t= atan(M.y,M.x);\n            \n            float repeat    = 7.0;\n            float threshold = 0.98;\n            int bool_alpha \t= cos(alpha*repeat) > threshold ? 1 : 0;\n            int bool_beta\t= cos( beta*repeat) > threshold ? 1 : 0;\n            int bool_gamma\t= cos(gamma*repeat) > threshold ? 1 : 0;\n            \n            //bool_alpha = 0;\n            //bool_beta = 0;\n            //bool_gamma = 0;\n            vec4 c = vec4(0.0,0.0,0.0,1.0);\n            if(0 == method)\n            {\n                int sum = bool_alpha+bool_beta+bool_gamma;\n                if(sum >= 1)\n                {\n                    c = vec4(float(bool_alpha),float(bool_beta),float(bool_gamma),1.0);\n                    \n                    // highlight higher-order intersections\n                    if(sum == 2)\n                        c *= 2.0;\n                    else if(sum == 3)\n                        c *= 100.0;\n                    \n                    c *= 1.0/float(N)*7.0*r;\n                }\n            }\n            else\n            {\n                int sum = bool_alpha+bool_beta+bool_gamma;\n                if(sum >= 1)\n                {\n                    c = vec4(float(bool_alpha),float(bool_beta),float(bool_gamma),1.0);\n\n                    if(sum == 1)\n                        c *= 0.0; // don't display simple intersection (order 1)\n                    else if(sum == 3)\n                        c *= 100.0;\n                    \n                    c *= 1.0/float(N)*30.0*r;\n                }\n            }\n            \n            color += c;\n            //color += c*(0.75+0.25*cos(q));\n\n        } // for()\n        return vec4(color.rgb,1.0);\n    }\n} // compute()\n\nvec4 transform(vec4 X)\n{\n    float alpha1\t= iTime*TWOPI/51.0;\n    float alpha2\t= iTime*TWOPI/45.0;\n    float beta1\t\t= iTime*TWOPI/31.0;\n    float beta2\t\t= iTime*TWOPI/37.0;\n    float beta3\t\t= iTime*TWOPI/43.0;\n    \n    vec4 Y = X;\n    Y.xw *= ROTATION(beta1);\n    Y.yw *= ROTATION(beta2);\n    Y.zw *= ROTATION(beta3);\n    Y.xy *= ROTATION(alpha1);\n    Y.zx *= ROTATION(alpha2);\n\treturn Y;\n} // transform()\n\n//--------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor,vec2 fragCoord)\n{\n    float m \t\t= iResolution.x/4.0;\n\tvec2 uvLeft\t\t= (fragCoord.xy/m - vec2(1.0,1.0))*1.2;\n\tvec2 uvRight\t= (fragCoord.xy/m - vec2(3.0,1.0))*1.2;\n    vec4 d1      \t= transform(vec4(0.0,0.0,1.0,0.0)); // direction along z\n    vec4 d2      \t= transform(vec4(0.0,0.0,0.0,1.0)); // direction along w\n    if(dot(uvLeft,uvLeft)<=1.0)\n    {\n        vec4 P \t\t\t= transform(vec4(uvLeft,0.0,0.0));\n        fragColor = compute(P,d1,d2,0);\n    }\n    else if(dot(uvRight,uvRight)<=1.0)\n    {\n        vec4 P \t\t\t= transform(vec4(uvRight,0.0,0.0));\n        fragColor = compute(P,d1,d2,1);\n    }\n\n} // mainImage()\n\n","name":"Image","description":"","type":"image"}]}