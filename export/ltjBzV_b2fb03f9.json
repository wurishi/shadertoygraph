{"ver":"0.1","info":{"id":"ltjBzV","date":"1516599717","viewed":122,"name":"Hello World - UP","username":"up209d","description":"Hello World !!!","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["helloworld","hello","world"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float config_ANTIALIAS = 2.;\n\nfloat Circle(vec2 uv, float radius, vec2 position) \n{\n   // length of uv will be a range from 0. to 1. \n   float distance = length(uv-position);\n    \n   // Smooth or antialias factor\n   // 1x 2x 4x will be calculate by those number / the bigger resolution screen dimension ( iResolution x or y )\n   float antialias = config_ANTIALIAS/iResolution.y;\n    \n   // smoothstep generate a smooth interpolate value from a value to a value\n   // smoothstep(valueStart,valueEnd,valueMiddle);\n   float circle = smoothstep(-antialias,antialias,radius-distance);\n   \n   // doing smoothstep(-antialias,antialias,radius-distance), so mean\n   // everytime a pixel which is has distance to the center longer than the radius a smaller number than -antialias\n   // it will be 0 (black), if the distance is short the radius a bigger number than antialias it will be 1 (white)\n    \n   // uv *= 2; this wont mutate the variable outside of this scope\n   // if you want to mutate you have to do outside scope like uv = change_UV_Value(uv);\n    \n   return circle;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // REMEMBER !!!\n    // UV or fragCoord which has start point from bottom left -> move up / right to increase value\n\t// vec2 uv = fragCoord.xy / iResolution.xy;\n    // uv = uv*2. - 1.;\n    // uv.x *= iResolution.x / iResolution.y;\n    \n    // In shorthand    \n    vec2 uv = ( fragCoord*2. - iResolution.xy ) / iResolution.y;\n    \n        \n    float face = Circle(uv,.75,vec2(.0,.0));\n    \n    float mouth = Circle(uv,.6,vec2(.0,.0)) - Circle(uv,0.625,vec2(.0,0.075 + 0.025*abs(sin(iTime))));\n    \n    float eyeLeft = Circle(uv,.15,vec2(-.3,.185));\n    float eyeRight = Circle(uv,.15,vec2(+.3,.185));\n   \n    face -= mouth + eyeLeft + eyeRight;\n    \n\t// Get rid all of value which is out of bound 0.0 -> 1.0 when it come to fragColor    \n    // if (face > 1.) face = 1.;\n    // if (face < 0.) face = 0.;\n    \n    // In short hand\n    face = clamp(face,0.,1.);\n    \n    // Output some color to the top left pixels, so can be used for debugging value\n    if (\n        (fragCoord.x <= 10.) &&\n        (fragCoord.y >= iResolution.y - 10.)\n       ) {\n    \t//fragColor = vec4(vec3(abs(sin(iTime)),0.,0.),1.0);\n    } else {\n    \t//fragColor = vec4(1.0);\n    }\n    \n    // fragColor must always exist in the end of this function. Some system might generate noise if not.\n    fragColor = vec4(uv+0.5,0.5+0.5*sin(iTime),1.0) * face;\n}","name":"Image","description":"","type":"image"}]}