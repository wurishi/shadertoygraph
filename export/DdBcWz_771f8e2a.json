{"ver":"0.1","info":{"id":"DdBcWz","date":"1687554352","viewed":96,"name":"dot product demonstration","username":"boytoy","description":"i made this to show someone how the dot product behaves across 2d space","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["math"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 coordinates(vec2 st){ // Coordenadas de rectángulo centrado en (0.,0.)\n    st   *= 2.;\n    st   -= 1.;\n    st.x *= iResolution.x/iResolution.y;\n    st   *= 1.3;\n    return st;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Coordenadas de rectángulo centrado en (0.,0.)\n    vec2 uv = coordinates(fragCoord/iResolution.xy);\n\n    // color default\n    fragColor = vec4(0.,0.,0.,1.);\n    \n    \n    // un vector\n    vec2 miVector = coordinates(iMouse.xy/iResolution.xy);\n    miVector = normalize(miVector);\n    \n    // iluminamos en las coordenadas uv según el dotProduct entre uv y miVector\n    fragColor.rgb = vec3(\n        dot(miVector,uv) + 0.5\n     );\n    // aquí, los vectores perpendiculares serían = 0.5 (gris medio)\n    // más blanco -> paralelo a mivector y potencia depende según del largo\n    // más negro  -> más opuesto\n    \n    // dirección de crecimiento con coseno!           // <= DESCOMENTA ESTOO\n    //fragColor.rgb = vec3(\n    //    cos(20. * dot(miVector,uv) )\n    //);\n    \n    \n    // línea de dot(uv,mivector)==0 (perpendicular)\n    float l_perpendicular = 0.005;\n    if(abs(dot(uv,miVector))<l_perpendicular){fragColor = vec4(vec3(0.),1.);}\n    // línea del vector\n    float l_colineal = 0.0001;\n    float largo      = 0.7;\n    vec3 col_vector  = vec3(1.,0.,0.);\n    bool colorear =\n        (abs(dot(normalize(uv),miVector)-1.)*length(uv)*length(uv)<l_colineal); // extremely sus mathemagic\n    colorear = colorear && (length(uv) < largo);\n    if(colorear){fragColor = vec4(col_vector,1.);}\n    \n    // (omíteme) agrego el cuadrado [-1,1] x [-1,1] y los ejes\n    // (y le pongo fractal brownian motion porque soy sensual)\n    //vec2 xy = abs(uv+0.02*ufbm(uv+iTime));\n    vec2 xy = abs(uv);\n    float inner = 1.;\n    float outer = inner+0.05;\n    if( ((xy.x>inner) || (xy.y>inner)) && (max(xy.x,xy.y) < outer )){\n        fragColor=vec4(0.9);\n        }\n    float d = 0.005;\n    if((xy.x<d)|| (xy.y<d) ){\n        fragColor=vec4(0.9);}\n        \n    //agColor = vec4(iMouse.xy/iResolution.xy,1.,1.);\n    //vec4(uv,1.,1.);\n       \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define OCTAVES 6\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nfloat ufbm(in vec2 st){return fbm(st)*2.-1.;}","name":"Common","description":"","type":"common"}]}