{"ver":"0.1","info":{"id":"ctjBz1","date":"1693833866","viewed":23,"name":"3 cylinders  and sphere","username":"nenuser","description":"3 cylinders ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3cylinders"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nstruct Camera \n{\n    vec3 position;\n    vec3 direction;\n    float zoom; \n} camera;\n\nstruct Sphere\n{\n    vec3 color;\n    vec3 position;\n    float radius;     \n} sphere;\n\nstruct Light\n{\n\tvec3 direction;    \n} light;\n\nstruct Plane\n{\n    vec3 point;\n    vec3 normal;\n    vec3 color;\n}plane;\n\nstruct Cylinder\n{\n    vec3 color;\n    vec3 position;\n    vec3 axis;   // normalized direction of the cylinder's axis\n    float diameter;\n    float height;\n};\n\nconst int numCylinders = 3; // Or however many cylinders you need\nCylinder cylinders[numCylinders];\n\nconst int numSpheres = 2;  // or any number you'd like\nSphere spheres[numSpheres];\n\nvoid setupScene()\n{\n    camera.position = vec3(0., 0., 3.5);\n     camera.direction = vec3(0., 0., 2.0);\n    camera.zoom = 2.3;\n    \n      // Initialize the first cylinder\n    cylinders[0].position = vec3(0.1, 0.06, 2.2);\n    cylinders[0].axis = normalize(vec3(1.7, 0.8, -2.));\n    cylinders[0].diameter = 0.2;\n    cylinders[0].height = 1.;\n    cylinders[0].color = vec3(0.1, 0.0, 1.0);\n\n    // Initialize the second cylinder\n    cylinders[1].position = vec3(-0.3, 0.2, 2.1);\n    cylinders[1].axis = normalize(vec3(-0.5, 0.5, 1.0));\n    cylinders[1].diameter = 0.1;\n    cylinders[1].height = 0.5;\n    cylinders[1].color = vec3(1.0, 0.0, 0.0);\n\n    // Initialize the third cylinder\n    cylinders[2].position = vec3(0.0, -0.5, 0.0);\n    cylinders[2].axis = normalize(vec3(1.0, 1.0, 1.0));\n    cylinders[2].diameter = 0.15;\n    cylinders[2].height = 0.7;\n    cylinders[2].color = vec3(0.0, 1.0, 0.0);\n    \n    plane.point = vec3(0., -0.5, 0.);\n    plane.normal = vec3(0., 1., 0.);\n    plane.color = vec3(0.5, 0.5, 0.5);  // Plane color is grey\n    \n     \n\n    spheres[1].position = vec3(0.5, 0.5, 1.);\n    spheres[1].radius = 0.3;\n    spheres[1].color = vec3(0.2, 0.9, 0.3);\n    \n    light.direction = normalize(vec3(0., -1., -0.78));\n}\n\nbool solveQuadratic(float a, float b, float c, out float t0, out float t1)\n{\n    float disc = b * b - 4. * a * c;\n    \n    if (disc < 0.)\n    {\n        return false;\n    } \n    \n    if (disc == 0.)\n    {\n        t0 = t1 = -b / (2. * a);\n        return true;\n    }\n    \n    t0 = (-b + sqrt(disc)) / (2. * a);\n    t1 = (-b - sqrt(disc)) / (2. * a);\n    return true;    \n}\n\nmat3 rotationToY(vec3 dir)\n{\n    vec3 yAxis = vec3(0.0, 1.0, 0.0);\n    vec3 v = cross(dir, yAxis);\n    float s = length(v);\n    float c = dot(dir, yAxis);\n    \n    mat3 vMat = mat3(0, -v.z, v.y,\n                     v.z, 0, -v.x,\n                     -v.y, v.x, 0);\n\n    return mat3(1.0) + vMat + vMat * vMat * ((1.0 - c) / (s * s));\n}\n\nbool intersectCaps(Cylinder cylinder, vec3 rayOriginLocal, vec3 rayDirLocal, out vec3 surfaceNormal, out float tHit)\n{\n    // Check bottom cap (y = 0 in the local coordinate system)\n    float tBottom = -rayOriginLocal.y / rayDirLocal.y;\n    vec3 pBottom = rayOriginLocal + tBottom * rayDirLocal;\n    if (tBottom > 0.0 && pBottom.x * pBottom.x + pBottom.z * pBottom.z <= (cylinder.diameter * 0.5) * (cylinder.diameter * 0.5))\n    {\n        tHit = tBottom;\n        surfaceNormal = vec3(0.0, -1.0, 0.0);\n        return true;\n    }\n    \n    // Check top cap (y = height in the local coordinate system)\n    float tTop = (cylinder.height - rayOriginLocal.y) / rayDirLocal.y;\n    vec3 pTop = rayOriginLocal + tTop * rayDirLocal;\n    if (tTop > 0.0 && pTop.x * pTop.x + pTop.z * pTop.z <= (cylinder.diameter * 0.5) * (cylinder.diameter * 0.5))\n    {\n        tHit = tTop;\n        surfaceNormal = vec3(0.0, 1.0, 0.0);\n        return true;\n    }\n    \n    return false;\n}\n\nbool intersect(Cylinder cylinder, vec3 direction, out vec3 surfaceNormal, out float tHit)\n{\n    mat3 rotationMatrix = rotationToY(cylinder.axis);\n    mat3 inverseRotation = transpose(rotationMatrix); // Since it's a rotation matrix, transpose is its inverse\n    \n    vec3 rayOriginLocal = inverseRotation * (camera.position - cylinder.position);\n    vec3 rayDirLocal = inverseRotation * direction;\n\n    float r = cylinder.diameter * 0.5;\n\n    float a = rayDirLocal.x * rayDirLocal.x + rayDirLocal.z * rayDirLocal.z;\n    float b = 2.0 * (rayOriginLocal.x * rayDirLocal.x + rayOriginLocal.z * rayDirLocal.z);\n    float c = rayOriginLocal.x * rayOriginLocal.x + rayOriginLocal.z * rayOriginLocal.z - r * r;\n\n    float t0, t1;\n    if (solveQuadratic(a, b, c, t0, t1))\n    {\n           tHit = min(t0, t1);\n        float t = min(t0, t1);\n        vec3 PhitLocal = rayOriginLocal + t * rayDirLocal;\n\n        float yDiff = PhitLocal.y;\n        if(yDiff < 0.0 || yDiff > cylinder.height)\n        {\n            // If there's no intersection with the cylindrical part, check the caps\n            if(intersectCaps(cylinder,rayOriginLocal, rayDirLocal, surfaceNormal, t))\n            {\n                return true;\n            }\n            return false;\n        }\n\n        vec3 Phit = rotationMatrix * PhitLocal + cylinder.position;\n        surfaceNormal = normalize(rotationMatrix * vec3(PhitLocal.x, 0.0, PhitLocal.z));\n\n        if (abs(yDiff) < 0.0001 || abs(yDiff - cylinder.height) < 0.0001)\n        {\n            surfaceNormal.y = -sign(yDiff - (0.5 * cylinder.height));\n        }\n        \n        return true;\n    }\n    return false;\n}\n\n\n\nbool intersect_sphere(Sphere sphere, vec3 direction, out vec3 surfaceNormal, out float tHit)\n{\n    vec3 L = camera.position - sphere.position;\n    \n    float a = dot(direction, direction);\n    float b = 2. * dot(direction, L);\n    float c = dot(L, L) - pow(sphere.radius, 2.);\n    \n    float t0, t1;\n    \n    if (solveQuadratic(a, b, c, t0, t1))\n    {\n        tHit = t0;\n        if (t1 < t0)\n        {\n            tHit = t1;\n        }\n        \n        vec3 Phit = camera.position + tHit * direction;\n        surfaceNormal = normalize(Phit - sphere.position);\n        \n        return true;\n    }  \n     \n    return false;\n}\n\n\n\nbool intersectPlane(vec3 direction, out vec3 Phit)\n{\n    float denom = dot(plane.normal, direction);\n    if (abs(denom) < 0.0001) return false;  // parallel to the plane\n    \n    float tTemp = dot(plane.point - camera.position, plane.normal) / denom;\n    if (tTemp >= 0.) {\n        Phit = camera.position + direction * tTemp;\n        return true;\n    }\n    \n    return false;\n}\n\nvec3 rayTrace(vec3 direction)\n{\n    vec3 closestSurfaceNormal;\n    vec3 closestColor = vec3(0.0, 0.0, 0.0); // default to black\n    float closestT = 1e8; // Initialize with a high value\n\n    // Loop over all cylinders\n    for (int i = 0; i < numCylinders; ++i)\n    {\n        vec3 surfaceNormal;\n        float tHit;\n        Cylinder currentCylinder = cylinders[i];\n\n        if (intersect(currentCylinder, direction, surfaceNormal, tHit))\n        {\n            if (tHit < closestT)\n            {\n                closestT = tHit;\n                float coeff = -dot(light.direction, surfaceNormal);\n                closestColor = coeff * currentCylinder.color;\n                closestSurfaceNormal = surfaceNormal;\n            }\n        }\n    }\n    \n    // Loop over all spheres\n    for (int i = 0; i < numSpheres; ++i)\n    {\n        vec3 surfaceNormal;\n        float tHit;\n        Sphere currentSphere = spheres[i];\n\n        if (intersect_sphere(currentSphere, direction, surfaceNormal, tHit))\n        {\n            if (tHit < closestT)\n            {\n                closestT = tHit;\n                float coeff = -dot(light.direction, surfaceNormal);\n                closestColor = coeff * currentSphere.color;\n                closestSurfaceNormal = surfaceNormal;\n            }\n        }\n    }\n    vec3 Phit;\n    if (intersectPlane(direction, Phit))\n    {\n        float tHit = length(Phit - camera.position);\n        if (tHit < closestT)\n        {\n             return plane.color;\n        }\n    }\n\n    return closestColor;\n}\n\n \n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{        \n    setupScene();\n    \n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= (iResolution.x / iResolution.y); \n    \n    vec3 direction = normalize(vec3(uv, camera.zoom) - camera.position);\n    \n    \n    \n    light.direction.x = -(iMouse.x / iResolution.x - 0.5);\n    light.direction.y = -(iMouse.y / iResolution.y - 0.5);\n    light.direction = normalize(light.direction);\n    \n    \n    \n    vec3 col = rayTrace(direction);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}