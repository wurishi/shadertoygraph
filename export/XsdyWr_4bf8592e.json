{"ver":"0.1","info":{"id":"XsdyWr","date":"1518560501","viewed":5087,"name":"Milo's Rose","username":"miloyip","description":"Happy Valentine's Day 2018~\n\nC version as ASCII art: https://github.com/miloyip/misc/blob/master/rose/rose.c","likes":43,"published":1,"flags":0,"usePreview":0,"tags":["flower","rose"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ray marching\nconst int max_iterations = 128;\nconst float stop_threshold = 0.01;\nconst float grad_step = 0.01;\nconst float clip_far = 10.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float PI2 = 6.28318530718;\nconst float DEG_TO_RAD = PI / 180.0;\n\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\n// distance function\n\nfloat opI(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat opU(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat opS(float d1, float d2) {\n    return max(-d1, d2);\n}\n\nfloat sdPetal(vec3 p, float s) {\n    p = p * vec3(0.8, 1.5, 0.8) + vec3(0.1, 0.0, 0.0);\n    vec2 q = vec2(length(p.xz), p.y);\n    \n    float lower = length(q) - 1.0;\n    lower = opS(length(q) - 0.97, lower);\n    lower = opI(lower, q.y);\n    \n    float upper = length((q - vec2(s, 0)) * vec2(1, 1)) + 1.0 - s;\n    upper = opS(upper, length((q - vec2(s, 0)) * vec2(1, 1)) + 0.97 - s);\n    upper = opI(upper, -q.y);\n    upper = opI(upper, q.x - 2.0);\n    \n    float region = length(p - vec3(1.0, 0.0, 0.0)) - 1.0;\n\n    return opI(opU(upper, lower), region);\n}\n\nfloat map(vec3 p) {\n    float d = 1000.0, s = 2.0;\n    mat3 r = rotationXY(vec2(0.1, PI2 * 0.618034));\n    r = r * mat3(1.08,0.0,0.0 ,0.0,0.995,0.0, 0.0,0.0,1.08);\n    for (int i = 0; i < 21; i++) {\n        d = opU(d, sdPetal(p, s));\n        p = r * p;\n        p += vec3(0.0, -0.02, 0.0);\n        s *= 1.05;\n    }\n    return d;\n}\n\n// get gradient in the world\nvec3 gradient( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tmap( pos + dx ) - map( pos - dx ),\n\t\t\tmap( pos + dy ) - map( pos - dy ),\n\t\t\tmap( pos + dz ) - map( pos - dz )\t\t\t\n\t\t)\n\t);\n}\n\n// ray marching\nfloat ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\tfloat depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n\t\tfloat dist = map( origin + dir * depth );\n\t\tif ( dist < stop_threshold ) {\n\t\t\treturn depth;\n\t\t}\n\t\tdepth += dist * 0.3;\n\t\tif ( depth >= end) {\n\t\t\treturn end;\n\t\t}\n\t}\n\treturn end;\n}\n\nconst vec3 light_pos = vec3( 20.0, 50.0, 20.0 );\n\nvec3 shading(vec3 v, vec3 n, vec3 eye) {\n\tvec3 ev = normalize(v - eye);\n    vec3 mat_color = vec3(0.65,0.0,0.0);\n \n    vec3 vl = normalize(light_pos - v);\n\n    float diffuse = dot(vl, n) * 0.5 + 0.5;\n    vec3 h = normalize(vl - ev);\n    float rim = pow(1.0 - max(dot(n, -ev), 0.0), 2.0) * 0.15;\n    float ao = clamp(v.y * 0.5 + 0.5, 0.0, 1.0);\n    return (mat_color * diffuse + rim) * ao;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// default ray dir\n\tvec3 dir = ray_dir(45.0, iResolution.xy, fragCoord.xy);\n\t\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 0.0, 5.0 );\n\n\t// rotate camera\n\tmat3 rot = rotationXY(vec2(-1.0, 1.0));\n    if (iMouse.x > 0.0)\n\t\trot = rotationXY(iMouse.yx / iResolution.yx * vec2(PI, -2.0 * PI) + vec2(PI * -0.5, PI));\n    \n\tdir = rot * dir;\n\teye = rot * eye;\n\t\n\t// ray marching\n\tfloat depth = ray_marching(eye, dir, 0.0, clip_far);\n    vec3 pos = eye + dir * depth;\n    vec3 c;\n    if (depth >= clip_far) {\n\t\tc = vec3(0.2, 0.0, 0.1);\n    }\n    else {\n        // shading\n        vec3 n = gradient( pos );\n        c = shading(pos, n, eye);\n    }\n    \n    float r = 1.2 - length((fragCoord.xy / iResolution.xy) - 0.5) * 1.0;\n    fragColor = vec4(c * r, 1.0);\n}","name":"Image","description":"","type":"image"}]}