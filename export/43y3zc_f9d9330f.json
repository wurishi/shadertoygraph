{"ver":"0.1","info":{"id":"43y3zc","date":"1717975262","viewed":45,"name":"Noise Colorization","username":"gllama","description":"Applying colorization techniques from https://www.shadertoy.com/view/ltdcD7 onto 4D perlin noise. Mapped equirectangular for texture on a 3D sphere or round object.\n\nCC0-1.0 licensed ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["perlin","cc0","equirectangular","4dperlin"],"hasliked":0,"parentid":"M3y3zK","parentname":"Equirectangular Perlin Noise"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ðŸ“º Equirectangular Perlin Noise\n// License CC0-1.0\n#define NUM_OCTAVES 7\n#define PI 3.1415926535897932384626433832795\n// Permute function for vec4\nvec4 permute(vec4 x) { \n    return mod(((x*34.0)+1.0)*x, 289.0); \n}\n\n// Fade function for vec3\nvec3 fade(vec3 t) {\n    return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Periodic 4D-Perlin noise\nfloat pnoise(vec3 P, vec3 rep) {\n    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo repetition\n    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, modulo repetition\n    vec3 Pf0 = fract(P); // Fractional part\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.y, Pi0.y, Pi1.y, Pi1.y);\n    vec4 iz0 = vec4(Pi0.z, Pi0.z, Pi0.z, Pi0.z);\n    vec4 iz1 = vec4(Pi1.z, Pi1.z, Pi1.z, Pi1.z);\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = inversesqrt(vec4(dot(g000,g000), dot(g010,g010), dot(g100,g100), dot(g110,g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = inversesqrt(vec4(dot(g001,g001), dot(g011,g011), dot(g101,g101), dot(g111,g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n    return 2.2 * n_xyz;\n}\n// UV coords to 3D space\nvec3 uvToCartesian3D(vec2 uv) {\n    // Convert UV to spherical coords\n    float theta = uv.x * 2.0 * 3.14159265359; // Longitude\n    float phi = uv.y * 3.14159265359; // Latitude\n    // Convert Spherical Coords to XYZ\n    float x = sin(phi) * cos(theta);\n    float y = sin(phi) * sin(theta);\n    float z = cos(phi);\n    return vec3(x, y, z);\n}\n\nconst mat3 rot = mat3(\n    cos(0.5), sin(0.5), 0.0,\n    -sin(0.5), cos(0.5), 0.0,\n    0.0, 0.0, 1.0\n);\n\n// Modified version of function from https://www.shadertoy.com/view/ltdcD7 - License Unkown\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\t// Rotate to reduce axial bias\n\tfor (int i = 0; i < NUM_OCTAVES; ++i) {\n\t\tv += a * pnoise(x,vec3(5.0, 5.0, 5.0));\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy; \n\n    \n    vec3 pos = uvToCartesian3D(uv);\n    \n    // Add movement to noise\n    pos.z += iTime * 0.1; \n    \n    //vec3 rep = vec3(5.0, 5.0, 5.0); // Periodic repetition for seamlessness\n    float f = fbm(pos);\n    //float noise = pnoise(pos * 5.0, rep);\n\n    float marble = f;//tan(pos.z * 5.0 + noise * 5.0) * 0.5 + 0.5;\n    float r = smoothstep(.0, 0.4, marble);\n    float g = smoothstep(.3, 0.7, marble);\n    float b = smoothstep(.6, 1., marble);\n    \n    vec3 col = vec3(r, g, b);\n    float f2 = .5 - marble;\n    \n\tr = smoothstep(.0, .6, f2);\n    g = smoothstep(.3, .9, f2);\n    b = smoothstep(.4, 1., f2);\n    \n    vec3 col2 = vec3(r, g, b);    \n    col = mix(col, col2, f2);\n    col=vec3(1.)-col;\n    // Trippy but not useful here\n    //if(mod(fragCoord.x+fragCoord.y,128.)<56.){\n    //    col = vec3(1.0)-col;\n    //}\n    //vec3 color = mix(vec3(1,0,1), vec3(1.0), marble);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}