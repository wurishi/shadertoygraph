{"ver":"0.1","info":{"id":"fltcWN","date":"1659834504","viewed":98,"name":"Cellular Automata SDF","username":"mattdeeds","description":"I use a cellular automata to fill in a signed distance field.  You draw the manifold, and it figures out the distances.  Press the space bar to enter the 3D view.  Use the mouse to draw more manifold.  The 3D mode is buggy right now.","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["sdf","cellularautomata"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define kDistanceToScreen 2.0\n#define kOutsideSteps 64\n\nconst int kSpace = 32;\n\nfloat sdfPlane(vec3 pos, vec3 normal, float offset) {\n  return dot(pos, normal) - offset;\n}\n\nfloat sdfTex(vec3 pos, vec3 duv) {\n  vec2 uv = vec2(0.5 + pos.x * duv.x * 100.0, -pos.z * duv.y * 100.0);\n  return texture(iChannel0, uv).x;\n}\n\n\nfloat sdf(vec3 pos, vec3 duv) {\n  float t = sdfTex(pos, duv);\n  float top = sdfPlane(pos, vec3(0.0, 1.0, 0.0), 0.2);\n  float bot = sdfPlane(pos, vec3(0.0, -1.0, 0.0), 0.2);\n  \n  return max(t, max(top, bot));\n}\n\n\n// https://michaelwalczyk.com/blog-ray-marching.html\nvec3 calculate_normal(in vec3 pos, vec3 duv)\n{\n  // If this is too large, you will see a bright color between parallel surfaces\n  // e.g. the bottom of the spheres.  Try 0.1 to see what I mean.\n  const vec3 del = vec3(0.03, 0.0, 0.0);\n\n  vec3 normal = vec3(\n    sdf(pos + del.xyy, duv) - sdf(pos - del.xyy, duv),\n    sdf(pos + del.yxy, duv) - sdf(pos - del.yxy, duv),\n    sdf(pos + del.yyx, duv) - sdf(pos - del.yyx, duv));\n  return normalize(normal);\n}\n\nvec2 getDepth(vec3 ray_origin, vec3 ray_direction, float end, vec3 duv) {\n  float depth = 0.0;\n  vec3 ray_position = ray_origin;\n  for (int i = 0; i < kOutsideSteps; ++i) {\n      float distance = sdf(ray_position, duv);\n      depth += distance;\n      if (distance < 0.003) {\n       return vec2(depth, float(i));\n      }\n      if (depth >= end) {\n        return vec2(end, float(i));\n      }\n      ray_position += ray_direction * distance;\n  }\n  return vec2(depth, float(kOutsideSteps));\n}\n\nconst vec3 directSource = normalize(vec3(1.0, 0.5, 0.5));\n\nfloat directLight(vec3 pos, vec3 n, vec3 duv) {\n  pos += 0.02 * n;\n  vec2 depth = getDepth(pos, directSource, 10.0, duv);\n  if (depth.x >= 10.0) {\n    return clamp(dot(n, directSource), 0.0, 1.0);\n  } else {\n    return 0.0;\n  }\n  //return depth.y / float(kOutsideSteps);\n}\n\nfloat ambientLight(vec3 pos, vec3 n, vec3 duv) {\n  float al = 0.0;\n  float epsilon = 0.1;\n  vec3 step = epsilon * n;\n  for (int i = 0; i < 6; ++i) {\n    pos += step;\n    al += 1.0 - (epsilon * float(i) - sdf(pos, duv));\n  }\n  al /= 6.0;\n  al = pow(al, 3.2);\n  return clamp(al, 0.0, 1.0);\n}\n\nvec4 render(vec2 fragCoord, vec3 duv) {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = 2.0 * (fragCoord - (iResolution.xy * 0.5)) / iResolution.yy;\n  vec3 view = normalize(vec3(uv.x, uv.y, -kDistanceToScreen));\n  vec3 origin = vec3(0.0);\n  \n  float t = iTime * 0.5;\n  mat3 rot = mat3(-sin(t), cos(t), 0.0, cos(t), sin(t), 0.0, 0.0,0.0, 1.0);\n  \n  origin += vec3(0.0, 0.0, 0.9);\n  origin.zyx = origin.zyx * rot;\n  // view.zyx = view.zyx * rot;\n  origin -= vec3(0.0, 0.0, 0.9);\n  \n  \n  vec2 depth = getDepth(origin, view, 10.0, duv);\n    \n    vec3 normal = calculate_normal(view * depth.x, duv);\n    vec3 pos = origin + depth.x * view;\n\n    vec3 direct = vec3(1.0, 0.5, 0.0) * directLight(pos, normal, duv);\n    \n    // float glow = smoothstep(float(kOutsideSteps) * 0.8, float(kOutsideSteps), depth.y);\n\n    vec3 col = vec3(0.0);\n    if (depth.x < 10.0) {\n      col += vec3(0.0, 0.5, 1.0) * (ambientLight(pos, normal, duv));\n      col += direct;\n    } else {\n      col = vec3(0.5, 0.75, 1.0);\n    }\n    return vec4(col,1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec3 duv = vec3(1.0 / iResolution.xy, 0);\n   \n  if (texelFetch(iChannel1, ivec2(kSpace, 0), 0).r > 0.0) {\n    fragColor = render(fragCoord, duv);\n  } else {  \n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n  }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define kInitialPause 0.1\n\nfloat minPlusR(float dd, vec2 uv, vec3 duv) {\n  float d = dd;\n  for (float i = -3.0; i <= 3.0; ++i) {\n    for (float j = -3.0; j <= 3.0; ++j) {\n      float r = length(0.01 * vec2(i, j));\n      vec2 p = uv + vec2(i, j) * duv.xy;\n      d = min(d, texture(iChannel0, p).x + r);\n    }\n  }\n  return d;\n}\n\nfloat maxMinusR(vec2 uv, vec3 duv) {\n  float d = -1.0;\n  for (float i = -3.0; i <= 3.0; ++i) {\n    for (float j = -3.0; j <= 3.0; ++j) {\n      float r = length(0.01 * vec2(i, j));\n      if (r > 0.0) {\n        vec2 p = uv + vec2(i, j) * duv.xy;\n        d = max(d, texture(iChannel0, p).x - r);\n      }\n    }\n  }\n  return d;\n}\n\nfloat maxBox(float dd, vec2 uv, vec3 duv) {\n  float d = dd;\n  d = max(d, texture(iChannel0, uv + duv.xz).x);\n  d = max(d, texture(iChannel0, uv + duv.zy).x);\n  d = max(d, texture(iChannel0, uv - duv.xz).x);\n  d = max(d, texture(iChannel0, uv - duv.zy).x);\n  return d;\n}\n\n\nfloat pixelDistance(vec2 uv1, vec2 uv2, vec3 duv) {\n  vec2 difference = uv1 - uv2;\n  return length(difference / duv.xy);\n}\n\n// We could make this more circular if we do a larger patch.\nfloat updatePixel(vec2 uv, vec3 duv) {\n  float d = texture(iChannel0, uv).x;\n  \n  if (d == 0.0 && maxBox(d, uv, duv) > 0.0) {\n    // Manifold (edge) case\n    return 0.0;\n  } else if (d > 0.0) {\n    // Outside case.\n    d = minPlusR(d, uv, duv);\n  } else {\n    // Inside case.\n    d = maxMinusR(uv, duv);\n    // d = -0.5;\n  }\n  return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord / iResolution.xy;\n  vec3 duv = vec3(1.0 / iResolution.xy, 0);\n  \n  vec2 cursorUV = vec2(cos(iTime * 0.5) * 0.3 + 0.5, sin(iTime) * 0.4 + 0.5);\n  \n  if (length(iMouse.xy) > 20.0) {\n    cursorUV = iMouse.xy / iResolution.xy;\n  }\n  \n  if (pixelDistance(uv, cursorUV, duv) < 10.0) {\n    fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n    return;\n  }\n  \n  if (iTime < kInitialPause) {\n    fragColor = vec4(1.0);\n  } else {\n    float d = updatePixel(uv, duv);\n    if (d == 0.0) {\n      fragColor = vec4(d, 1.0, 0.0, 1.0);  // Manifold\n    } else if (d > 0.0) {\n      fragColor = vec4(d, 0.0, 0.0, 1.0);\n    } else {\n      fragColor = vec4(vec3(d, 0, -2.0 * d), 1.0);\n    }\n  }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"","name":"Common","description":"","type":"common"}]}