{"ver":"0.1","info":{"id":"MlGczy","date":"1536775722","viewed":323,"name":"Möbius Transform Visualizer","username":"ptrgags","description":"I'm trying to learn about Möbius transforms, so here's a shader where I can play with the parameters.\n\nEdit the parameters to visualize different transforms.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["transformations","mibus","fractalmath"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CENTER (iResolution.xy / 2.0)\n\n// Complex multiplication a * b\nvec2 c_mult(vec2 a, vec2 b) {\n   \tfloat x = a.x * b.x - a.y * b.y;\n    float y = a.y * b.x + a.x * b.y;\n    return vec2(x, y);\n}\n\n// Complex conjugate\nvec2 c_conj(vec2 z) {\n    return vec2(z.x, -z.y);\n}\n\n// Complex division a / b\nvec2 c_div(vec2 a, vec2 b) {\n    // top is a * conj(b)\n    vec2 top = c_mult(a, c_conj(b));\n    \n    // bottom is b * conj(b) = |b|^2 = b dot b\n    float bottom = dot(b, b);\n    \n    // Scale the top by the bottom.\n    return top / bottom;\n}\n\n/**\n * A Möbius transformation is defined as\n * \n * f(z) = (az + b)/(cz + d)\n *\n * Where all variables are complex. With some algebra,\n * we can find the inverse:\n *\n * f^(-1)(z) = (dz - b) / (a - cz);\n */\nvec2 inv_mobius(vec2 z, vec2 a, vec2 b, vec2 c, vec2 d) {\n    vec2 top = c_mult(d, z) - b;\n    vec2 bottom = a - c_mult(c, z);\n    return c_div(top, bottom);\n}\n\n// length() in the max distance metric (aka chessboard distance)\nfloat chessboard_length(vec2 z) {\n    return max(abs(z.x), abs(z.y));\n}\n\nvec2 animate_param(vec2 start, vec2 finish, float speed) {\n    float interp_val = 0.5 + 0.5 * sin(iTime * speed);\n    return mix(start, finish, interp_val);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized, centered coordinates with square aspect ratio\n    vec2 uv = (fragCoord - CENTER)/iResolution.y;\n    \n    // Zoom out a bit\n    uv *= 4.0;\n    \n    // Identity transformation\n    const vec2 A0 = vec2(1, 0);\n    const vec2 B0 = vec2(0, 0);\n    const vec2 C0 = vec2(0, 0);\n    const vec2 D0 = vec2(1, 0);\n    \n    // ------------------------------------------------------\n    // Tweak these parameters to visualize a Möbius transform\n    // of the form\n    // f(z) = (az + b) / (cz + d)\n    // where a, b, c, d, z are complex numbers\n    // -------------------------------------------------------\n    // animation speed\n    const float SPEED = 0.5;\n    vec2 a = animate_param(A0, vec2(1.0, 0.0), SPEED);\n    vec2 b = animate_param(B0, vec2(0.0, 0.0), SPEED);\n    vec2 c = animate_param(C0, vec2(4.0, 0.0), SPEED);\n    vec2 d = animate_param(D0, vec2(1.0, 0.0), SPEED);\n    vec2 before = inv_mobius(uv, a, b, c, d);\n    \n    // Make a grid in the before picture\n    const float CELL_SIZE = 10.0;\n    vec2 cell_uv = fract(CELL_SIZE * before);\n    vec2 cell_id = floor(CELL_SIZE * before);\n    \n    // Compute where grid lines go\n    vec2 lines = step(0.1, cell_uv);\n    float line_mask = min(lines.x, lines.y);\n    \n    // Brightness is based on distance from center in the grid\n    float brightness = 1.0 - chessboard_length(cell_id) / CELL_SIZE;\n    \n    // Texture the plane\n    vec4 color = texture(iChannel0, before / 2.0 + 0.5);\n    \n    // I want to put dots at 0 and 1\n    const float RADIUS = 0.1;\n    float origin = 1.0 - step(RADIUS, length(before));\n    float unity = 1.0 - step(RADIUS, length(before - vec2(1.0, 0.0)));\n    \n    // Color around infinity\n    float infinity = step(20.0, length(before));\n    \n    // And color the unit circle\n    float unit_circle = smoothstep(0.02, 0.01, abs(length(before) - 1.0));\n    \n    // And color the axes\n    float real_line = smoothstep(0.02, 0.01, abs(before.x));\n    float imag_line = smoothstep(0.02, 0.01, abs(before.y));\n    \n    \n    // Output to screen\n    fragColor = vec4(line_mask * color);\n    // Draw the real line and imaginary line\n    fragColor = mix(fragColor, vec4(1.0, 0.5, 0.0, 1.0), real_line);\n    fragColor = mix(fragColor, vec4(0.0, 0.5, 1.0, 1.0), imag_line);\n    // Draw the unit circle\n    fragColor = mix(fragColor, vec4(0.0, 0.0, 1.0, 1.0), unit_circle);\n\t// Plot some points\n    fragColor = mix(fragColor, vec4(1.0, 0.0, 0.0, 1.0), origin);\n\tfragColor = mix(fragColor, vec4(0.0, 1.0, 0.0, 1.0), unity);\n    fragColor = mix(fragColor, vec4(0.5, 0.0, 1.0, 1.0), infinity);\n    \n}\n\n","name":"Image","description":"","type":"image"}]}