{"ver":"0.1","info":{"id":"tsBGDV","date":"1550006302","viewed":61,"name":"RaytracingSphere","username":"temportalflux","description":"raytracing a sphere","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nstruct Camera\n{\n    vec3 position;\n    float focalLength;\n};\n\nstruct Sphere\n{\n    vec3 position;\n    float radius;\n    vec3 color;\n};\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 dir;\n};\n    \nstruct Light\n{\n    vec3 position;\n    float intensity;\n};\n    \nSphere orb = Sphere(vec3(0.0, 0.0, 10.0), 2.0, vec3(1, 0, 0));\nCamera camera = Camera(vec3(0, 0, 0), -1.0);\nLight light = Light(vec3(0, 0, 5), 2.0);\n\n// https://yduf.github.io/my-tracer/\n// https://www.shadertoy.com/view/ldS3DW\n// https://www.shadertoy.com/view/ldScDc\n// http://www.lighthouse3d.com/tutorials/maths/ray-sphere-intersection/\nfloat sphereIntersect(vec3 rayOrigin, vec3 rayDir, vec3 center, float radius)\n{\n\tvec3 rc = rayOrigin-center;\n\tfloat c = dot(rc, rc) - (radius*radius);\n\tfloat b = dot(rayDir, rc);\n\tfloat d = b*b - c;\n\tfloat t = -b - sqrt(abs(d));\n\tfloat st = step(0.0, min(t,d));\n\treturn mix(-1.0, t, st);\n}\n\nRay makeRay(Camera camera, vec2 uv)\n{\n    return Ray(\n        camera.position,\n        normalize(vec3(uv, -camera.focalLength))\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Alter the lights position on a sinusoidal wave, in x y and z\n    light.position += vec3(-cos(iTime * 2.), sin(iTime * 2.), cos(iTime * 3.0)) * vec3(0, 0, 5);\n    //camera.position = vec3(-cos(iTime), sin(iTime), 1) * vec3(5, 5, 0) + vec3(0, 0, -10) + orb.position;\n    \n    // ----------------------------------------------\n    // UVs\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv * 2.0) - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    fragColor = vec4(0, 0, 0, 1);\n    \n    // ----------------------------------------------\n    // Orb Draw\n    \n    // Raytrace to the sphere\n    Ray ray = makeRay(camera, uv);\n    // Determine how close to the center of the sphere the ray hit\n    // -1 is no hit\n    // 0 is at center\n    // 1 is at radius of the sphere/orb\n    float hitRadiusRatio = sphereIntersect(ray.origin, ray.dir, orb.position, orb.radius);\n    // Determine if a color should be rendered for the sphere (only has alpha if hit was on sphere)\n    float alpha = clamp(hitRadiusRatio, 0.0, 1.0);\n    // Make an output color for the sphere, based on sphere albedo and how transparent it is\n    vec4 fragColorForOrb = vec4(alpha * orb.color, alpha);\n    \n    // Lighting\n    // Determine the hit offset from the camera\n    vec3 rayEndWrtOrb = ray.origin + ray.dir * hitRadiusRatio;\n    // Calculate the normal for the hit location\n    vec3 orbNormal = normalize(rayEndWrtOrb - orb.position);\n    // Calculate light direction based on the hit location\n    vec3 hitLightDir = normalize(light.position - rayEndWrtOrb);\n    float nDotL = dot(orbNormal, hitLightDir);\n    \n    // Diffuse lighting\n    fragColorForOrb.rgb *= light.intensity * max(0.0, nDotL);\n    \n    // Apply color for the orb\n    fragColor += vec4(fragColorForOrb.rgb, 1.0);\n    \n    // ----------------------------------------------\n    // Background\n    \n    float notIntersecting = 1.0 - fragColorForOrb.a;\n    vec3 col = 0.5 + 0.5 * cos(iTime + (fragCoord / iResolution.xy).xyx + vec3(0,2,4));\n    fragColor += notIntersecting * vec4(col, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}