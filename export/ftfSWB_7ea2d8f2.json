{"ver":"0.1","info":{"id":"ftfSWB","date":"1626405721","viewed":162,"name":"Single-Sqrt SDF construction","username":"rodolphito","description":"Spoiler: it ends up performing worse! But i still had fun thinking about it and figuring it out :)","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["sqrt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The idea is to defer sqrts needed by distance calculations by\n// instead storing squared distances and seeing how far the sqrt\n// can be pushed. An issue crops up when combining two primitives,\n// however, because constant isoline offsets like sphere radii\n// cannot be added into a squared distance. The solution taken\n// here is to store (squaredDistance, offset) in vec2 and use\n// custom primitive combination ops instead of just plain min/max.\n// The reason this works out is because min(a,b) just needs to\n// choose either a or b, sqrts arent actually needed. In practice,\n// figuring out which (square, offset) tuple is smaller is quite\n// complicated. Custom functions are prefixed with r because its\n// sort of a \"rational\"/radical-free approach to sdf construction.\n// Theoretically any number of primitives could be combined with\n// this method, while using only one sqrt per scene evaluation.\n// In practice, this is actually slower, i've found. Anyhow, for\n// posterity here is my attempt so everyone else is spared from\n// trying to derive it themselves.\n\n// I could have made a custom struct for (square, offset)\n// but thats clunky and annoying. \n\n// Convert a rational vector to a distance\nfloat rtod(vec2 r)\n{\n    return sqrt(r.x) + r.y;\n}\n\nvec2 dtor(float d)\n{\n    return vec2(0.0, d);\n}\n\n// Compare two rational vectors and return a discriminant\n// Return value has the same sign as (rtod(a) - rtod(b))\nfloat rcmp(vec2 a, vec2 b)\n{\n    // equivalent: \n    //return rtod(a) - rtod(b);\n    \n    // Superficially these equations make no sense, at least to me.\n    // They are just the result of inlining and simplifying the above.\n    vec2 c = a - b;\n    c.y  = sign(c.x)* c.y*abs(c.y) + a.x+b.x;\n    return sign(c.x)*(c.y*abs(c.y) - a.x*b.x*4.0);\n}\n\nvec2 rmin(vec2 a, vec2 b)\n{\n    // equivalent:\n    //return dtor(min(rtod(a), rtod(b)));\n    return rcmp(a, b) < 0.0 ? a : b;\n}\n\nvec2 rmax(vec2 a, vec2 b)\n{\n    // equivalent:\n    //return dtor(max(rtod(a), rtod(b)));\n    return rcmp(a, b) > 0.0 ? a : b;\n}\n\n// I only implemented spheres, but almost any primitive, 2d or 3d,\n// is trivial to convert to this format. Bonus is that it can\n// eliminate branching inside primitives.\nvec2 sdSphere(vec2 p, vec2 pos, float r)\n{\n    vec2 d = p - pos;\n    return vec2(dot(d,d),r);\n}\n\nfloat sdMap( in vec2 p, in vec2 p1, in float r1, in vec2 p2, in float r2 )\n{\n    vec2 a = sdSphere(p, p1, r1);\n    vec2 b = sdSphere(p, p2, r2);\n    \n    vec2 c = rmin(a, b);\n    // viola, only one sqrt\n    // sqrt can't be pushed further because we have to advance the\n    // ray by a distance, not a squared distance.\n    return rtod(c);\n}\n\n// IQ-style 2d prim rendering\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n \n    // animation\n    float time = iTime;\n    float r1 = -0.25+0.25*cos(time*0.2);\n    float r2 = -0.25+0.25*cos(time*0.3);\n    vec2 p1 = 0.5*cos(time*vec2(0.7,1.1));\n    vec2 p2 = 0.5*cos(time*vec2(0.5,1.3));\n    \n    // distance\n    float d = sdMap(p, p1, r1, p2, r2);\n    \n    // coloring\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(128.0*abs(d));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    float d = sdMap(m, p1, r1, p2, r2);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}