{"ver":"0.1","info":{"id":"tltXRS","date":"1581260914","viewed":396,"name":"Polygon Analytic Motion Blur 2","username":"fizzer","description":"This is a more complicated variant of my [url=https://www.shadertoy.com/view/tldSzS]previous shader[/url] which does analytic motionblur. This one accounts for self-intersection of the polygon (it uses the XOR rule).","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["motionblur","analytic","polygon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// Analytic Linear Motion Blur Series:\n//\n// Self-Intersecting Polygon (XOR Rule) - https://www.shadertoy.com/view/tltXRS\n// Concave Polygon - https://www.shadertoy.com/view/tldSzS\n// Square - https://www.shadertoy.com/view/wtcSzB\n// Checkerboard - https://www.shadertoy.com/view/tlcXRX\n//\n\nconst int numPolygonCorners = 5;\n\nvec2 screenToPolygonTransform(vec2 p, float t)\n{\n    float a = t * 4.;\n    mat2 m = mat2(cos(a), sin(a), -sin(a), cos(a));\n    return m * (p - vec2(cos(t * 14.)*.5, 0.));\n}\n\nvec2 polygonCorner(int i)\n{\n    const float thd = acos(-1.) * 4. / float(numPolygonCorners);\n    float r = .8;\n    return vec2(cos(float(i) * thd), sin(float(i) * thd)) * r;\n}\n\nfloat integratePolygon(vec2 sa, vec2 sb)\n{\n    vec2 sd = sb - sa;\n    float sum = 0.;\n    int e = 0;\n    \n    float ts[numPolygonCorners];\n\n    int endPointInOut = 0;\n    int startPointInOut = 0;\n\n    vec2 pa = polygonCorner(0);\n    for(int i = 1; i <= numPolygonCorners; ++i)\n    {\n        vec2 pb = polygonCorner(i);\n        vec2 d = pb - pa;\n        vec2 n = vec2(d.y, -d.x);\n        \n        float dotsdn = dot(sd, n);\n        float t = dot(pa - sa, n) / dotsdn;\n        float u = dot(sa + sd * t - pa, d);\n        \n        ts[i - 1] = -1.;\n        \n        if(u > 0. && u <= dot(d, d))\n        {\n            if(t > 0. && t <= 1.)\n                ts[i - 1] = t;\n            if(t > 1.)\n                endPointInOut ^= 1;\n            if(t < 0.)\n                startPointInOut ^= 1;\n        }\n        \n        pa = pb;\n    }\n    \n    // The signs of the intersection distances to be added together\n    // unfortunately are order-dependent. So all intersections are needed first\n    // and then their relative order defines the sign.\n    for(int i = 0; i < numPolygonCorners; ++i)\n    {\n        int e = 0;\n        float ti = ts[i];\n        \n        for(int j = 0; j < numPolygonCorners; ++j)\n        {\n            float tj = ts[j];\n            \n            if(tj > 0. && tj < ti)\n            \te ^= 1;\n        }\n        \n        if(ts[i] > 0.)\n            sum += e != 0 ? ts[i] : -ts[i];\n    }\n    \n    if(startPointInOut != 0)\n        sum = -sum;\n\n    if(endPointInOut != 0)\n        sum += 1.;\n    \n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y * 2.;\n\n    float t = iTime;\n    \n    vec3 col = vec3(1. / 9.);\n\n\tvec2 uv0 = screenToPolygonTransform(uv, t);\n\tvec2 uv1 = screenToPolygonTransform(uv, t - 1. / 30.);\n\n\tfloat sum = integratePolygon(uv0, uv1);\n\n    col = mix(col, vec3(.9), sum);\n    \n    fragColor = vec4(pow(col, vec3(1. / 2.2)),1.0);\n}","name":"Image","description":"","type":"image"}]}