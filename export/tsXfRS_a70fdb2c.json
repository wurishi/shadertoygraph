{"ver":"0.1","info":{"id":"tsXfRS","date":"1588734598","viewed":487,"name":"Animal Crossing","username":"TauntyBird","description":"Mitzi from Animal Crossing! She is my favorite villager :D Click and drag to look around.","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright Â© 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n//------------------------------------------------------------------\n\n#define AA 1   // antialiasing if AA > 1, but it takes a while to compile and can crash your browser :(\n#define CLOUDS_ON 1\t\t//1 if you want clouds, 0 if you don't. It's much faster without clouds...\n\n//------------------------------------------------------------------\n\n//COLOR PALETTE\n\nconst vec3 black = vec3(0., 0., 0.);\nconst vec3 white = vec3(1., 1., 1.);\nconst vec3 cream = vec3(.99, .98, .88);\nconst vec3 orange = vec3(1., .26, .08);\nconst vec3 lightBlue = vec3(.33, .56, .72);\nconst vec3 darkBlue = vec3(0.07, 0.27, 0.43);\nconst vec3 darkSeaGreen = vec3(0.12, 0.44, 0.26);\nconst vec3 brightPink = vec3(.85, .05, .85);\nconst vec3 lightPink = vec3(.85, .50, .8);\n\n//------------------------------------------------------------------\n\n//MAIN PARTS (used for coloring later)\n\n#define HEAD 11\n#define OUTER_EAR 12\n#define INNER_EAR 13\n#define DRESS 14\n#define BODY 15\n#define ARM_LEFT 16\n#define ARM_RIGHT 17\n#define LEG_LEFT 18\n#define LEG_RIGHT 19\n#define TAIL 20\n#define POINT 21\n#define FLOOR 22\n#define LIGHTBLUE 23\n#define BRIGHTPINK 24\n#define ORANGE 25\n#define LIGHTPINK 26\n\n//------------------------------------------------------------------\n\n//NOISE\n\nfloat random1( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(729.5, 653.54)),\n                          dot(p,vec2(269.5, 765.54))))\n                 *43758.5453).x;\n}\n\n//------------------------------------------------------------------\n\n//TRANSFORMATIONS\n\nvec3 rotateX(vec3 p, float a) {\n    return vec3(p.x, cos(a) * p.y - sin(a) * p.z, sin(a) * p.y + cos(a) * p.z);\n}\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvec3 rotateZ(vec3 p, float a) {\n    return vec3(cos(a) * p.x - sin(a) * p.y, sin(a) * p.x + cos(a) * p.y, p.z);\n}\n\n//------------------------------------------------------------------\n\n//SHAPE SDFS\n// https://iquilezles.org/articles/distfunctions\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n//------------------------------------------------------------------\n\n//CSG OPERATIONS (+ more shape manipulation!)\n\n//union\nvec2 opU( vec2 d1, vec2 d2 )\n{\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\n//subtraction (difference)\nvec2 opS( vec2 d1, vec2 d2 )\n{\n    return (-d2.x>d1.x) ? vec2(-d2.x, d2.y) : d1;\n}\n\n//intersection\nvec2 opI( vec2 d1, vec2 d2 )\n{\n    return (d1.x>d2.x) ? d1 : d2;\n}\n\n//bend\nvec3 opCheapBend( in vec3 p )\n{\n    const float k = 1.; // or some other amount\n    float c = cos(k*(p.x - .5));\n    float s = sin(k*(p.x - .5));\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\n\n//infinite repetition\nvec3 opRep( in vec3 p, in vec3 c )\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return q;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\n//SMOOTH BLEND\n//https://iquilezles.org/articles/smin\n\nfloat smin( float a, float b, float k)\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//------------------------------------------------------------------\n\n//RENDERING\n\nvec2 clouds(in vec3 pos, in vec3 offset, in vec3 cv, in int color, in vec2 resO, in vec2 res2O) {\n\tvec2 res = resO;\n    vec2 res2 = res2O;\n    vec3 q; vec2 t;\n    \n    q = opRep(pos-vec3( 0.0,0.9, 0.0) + offset, cv);\n    t =  vec2( sdSphere( q, 0.25 ), color );\n    res2 = res;\n    res = t;\n    res = vec2( smin(res.x, res2.x, .1), res.x < res2.x ? res.y : res2.y);\n\n    q = opRep(pos-vec3( 0.0,1.0, -0.2) + offset, cv);\n    t =  vec2( sdSphere( q, 0.2 ), color );\n    res2 = res;\n    res = t;\n    res = vec2( smin(res.x, res2.x, .1), res.x < res2.x ? res.y : res2.y);\n\n    q = opRep(pos-vec3( -0.1,0.8, 0.0) + offset, cv);\n    t =  vec2( sdSphere( q, 0.15 ), color );\n    res2 = res;\n    res = t;\n    res = vec2( smin(res.x, res2.x, .1), res.x < res2.x ? res.y : res2.y);\n\n    q = opRep(pos-vec3( 0.0,1.1, 0.2) + offset, cv);\n    t =  vec2( sdSphere( q, 0.1 ), color );\n    res2 = res;\n    res = t;\n    res = vec2( smin(res.x, res2.x, .1), res.x < res2.x ? res.y : res2.y);\n\n    q = opRep(pos-vec3( 0.0,1.15, -0.1) + offset, cv);\n    t =  vec2( sdSphere( q, 0.1 ), color );\n    res2 = res;\n    res = t;\n    res = vec2( smin(res.x, res2.x, .1), res.x < res2.x ? res.y : res2.y);\n\n    q = opRep(pos-vec3( 0.0,0.9, -0.45) + offset, cv);\n    t =  vec2( sdSphere( q, 0.12 ), color );\n    res2 = res;\n    res = t;\n    res = vec2( smin(res.x, res2.x, .1), res.x < res2.x ? res.y : res2.y);\n\n    q = opRep(pos-vec3( 0.1,0.8, -0.25) + offset, cv);\n    t =  vec2( sdSphere( q, 0.12 ), color );\n    res2 = res;\n    res = t;\n    res = vec2( smin(res.x, res2.x, .1), res.x < res2.x ? res.y : res2.y);\n\n    q = opRep(pos-vec3( 0.1,0.9, 0.3) + offset, cv);\n    t =  vec2( sdSphere( q, 0.15 ), color );\n    res2 = res;\n    res = t;\n    res = vec2( smin(res.x, res2.x, .1), res.x < res2.x ? res.y : res2.y);\n\treturn res;\n}\n\nvec2 map( in vec3 pos )\n{ \n    \n    vec2 res = vec2( 1e10, 0.0 );\n    vec2 res2 = vec2( 1e10, 0.0 );\n    vec2 t;\n    vec3 q;\n    \n    \n    //Mitzi from Animal Crossing + ground platform\n    if( pos.x>-3.0 && pos.x<3.0 && pos.z>-3.0 && pos.z<3.0 && pos.y>-5.0 && pos.y<5.0)\n    {\n        \n        //head\n        t = vec2( sdEllipsoid( pos- rotateY(rotateZ(rotateX(vec3( 0.0,0.93, 0.0), .01 * sin(iTime * 5.)), .01 * sin(iTime * 3.)), .01 * sin(iTime * 3.)), vec3(0.25, 0.22, 0.25) ), HEAD );\n        if (res.x >= t.x) {\n            res2 = t;\n            res = t; \n        }\n\n        //body\n        t = vec2( sdRoundCone( pos-vec3( 0.0,0.40, 0.0), 0.15, 0.06, 0.3 ), BODY );\n        if (res.x >= t.x) {\n            res2 = t;\n            res = t; \n        }\n\n\n        //arms, symmetrical\n        t = vec2( sdCapsule(   vec3(pos.x, pos.y, abs(pos.z))-vec3( 0.0,0.35, 0.0), rotateY(vec3(0.0,0.05,0.3), .15 * sin(iTime * 5.)), vec3(0.0, 0.3, 0.07), 0.045  ), ARM_LEFT );\n        if (res.x >= t.x) {\n            res2 = res;\n            res = t; \n            if (pos.y <= 0.5) {\n                res.y = float(POINT);\n            }\n        }\n\n        //tail\n        q = opCheapBend(pos- vec3( 0.0,0.15, 0.0));\n            t = vec2( sdCapsule(  q,\n                            rotateY(rotateZ(rotateX( vec3(0.5,0.0,0.0), .018 * sin(iTime * 5.)), .01 * sin(iTime * 3.)), .4 * sin(iTime * 3.)),\n                            //vec3(0.5,0.0,0.0), \n                            vec3(0.0, 0.3, 0.0), 0.035  ), TAIL );\n\n        if (res.x >= t.x) {\n            res2 = res;\n            res = t; \n            if (pos.x >= .0 && pos.x <= .22 || pos.x >= .32 && pos.x <= .42) {\n                res.y = float(LIGHTBLUE);\n            }\n        }\n\n        //earLeft\n        t = opS( vec2( sdCone( pos-\n                             // vec3( 0.04,1.45, 0.1)\n                              rotateY(rotateZ(rotateX( vec3( 0.04,1.45, 0.1), .008 * sin(iTime * 5.)), .01 * sin(iTime * 3.)), .01 * sin(iTime * 3.))\n                              , vec3(1.1,0.3,0.5) ), OUTER_EAR ),\n                 vec2( sdCone( pos-\n                             // vec3( -0.02,1.45, 0.1)\n                              rotateY(rotateZ(rotateX( vec3( -0.02,1.45, 0.1), .01 * sin(iTime * 5.)), .01 * sin(iTime * 3.)), .01 * sin(iTime * 3.))\n                              , vec3(1.1,0.3,0.5) ), INNER_EAR ));\n        if (res.x >= t.x) {\n            res2 = res;\n            res = t; \n        }\n\n        //earRight\n            t = opS( vec2( sdCone( pos-\n                             // vec3( 0.04,1.45, -0.1)\n                              rotateY(rotateZ(rotateX( vec3( 0.04,1.45, -0.1), .008 * sin(iTime * 5.)), .01 * sin(iTime * 3.)), .01 * sin(iTime * 3.))\n                              , vec3(1.1,0.3,0.5) ), OUTER_EAR ),\n                 vec2( sdCone( pos-\n                             // vec3( -0.02,1.45, -0.1)\n                              rotateY(rotateZ(rotateX( vec3( -0.02,1.45, -0.1), .01 * sin(iTime * 5.)), .01 * sin(iTime * 3.)), .01 * sin(iTime * 3.))\n                              , vec3(1.1,0.3,0.5) ), INNER_EAR ));\n        if (res.x >= t.x) {\n            res2 = res;\n            res = t; \n        }\n\n        //legs, symmetrical\n        t = vec2( sdRoundCone( vec3(pos.x, pos.y, abs(pos.z))-vec3( 0.0,0.05, 0.07), 0.04, 0.07, 0.3 ), LEG_LEFT );\n        if (res.x >= t.x) {\n            res2 = res;\n            res = t; \n            if (pos.y <= 0.2) {\n                res.y = float(POINT);\n            }\n        }\n\n        //dress\n          t = opS( vec2( sdCone( pos-vec3(  0.0,0.9, 0.0), vec3(1.1,0.4,0.6) ), DRESS ),\n                   vec2( sdBox( pos-vec3( 0.0,0.12, 0.0), vec3(0.25) ), DRESS ));\n        if (res.x >= t.x) {\n            res = t;\n        }\n\n\n        //floor\n        t = opS(\n                vec2( sdBox( pos-vec3( 0.0,-0.79, 0.0), vec3(0.8) ), FLOOR ),\n                vec2( sdBox( pos-vec3( 0.0,-0.99, 0.0), vec3(0.82) ), FLOOR )\n                );\n        if (res.x >= t.x) {\n            res = t;\n        }\n       \n        \n    } \n    \n    #if CLOUDS_ON\n    //Cloud generation\n    float radius = 1.; //so we dont spawn clouds on Mitzi\n    vec3 offset = vec3(0.); //to give the clouds movement\n    vec3 cv = vec3(5.); //changing spawn ratio\n    int color = LIGHTBLUE;\n    if (pos.x < -radius || pos.x > radius || pos.y < -radius * 2. || pos.y > radius * 2. || pos.z < -radius || pos.z > radius )\n    {\n        //CLOUDS 1 (light pink)\n        \n        offset = vec3(1.5 + cos(iTime) * .05, 3. + sin(iTime) * .05, 1.5 * iTime * .1) ;\n        cv = vec3(5.);\n        color = LIGHTPINK;\n\t\tres = clouds(pos, offset, cv, color, res, res2);\n        \n        //CLOUDS 2 (cream)\n        \n        offset = vec3(1.5 + sin(iTime) * .05, 1.5 + cos(iTime) * .05, 1.5 * iTime * .2) ;\n        cv = vec3(4.);\n        color = BODY;\n        res = clouds(pos, offset, cv, color, res, res2);\n        \n        //CLOUDS 3 (light blue)\n        \n        offset = vec3(2.5 + cos(iTime) * .05, 2.5 + sin(iTime) * .05, 2.5 * iTime * .05) ;\n        cv = vec3(6.);\n        color = LIGHTBLUE;\n        res = clouds(pos, offset, cv, color, res, res2);\n    }\n    #else\n    #endif\n    \n    return res;\n}\n\nconst float maxHei = 0.8;\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n    {\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n    \n} \n\n\n// https://iquilezles.org/articles/rmshadows\n//Penumbra Shadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n#if 0    \n    vec3 eps = vec3(0.002,0.0,0.0);\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.002*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\n//Ambient Occlusion, 2 different ways\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    #if 0\n    \n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n\n    #else\n    vec3 p = pos;\n    vec3 n = nor;\n    float k = 2.0;\n    float AO_DIST = .015;\n        float aoSum = 0.0;\n    for(float i = 0.0; i < 5.0; ++i) {\n        float coeff = 1.0 / pow(2.0, i);\n        vec2 res = map(p + n * i * AO_DIST);\n        aoSum += coeff * (i * AO_DIST - res.x);\n    }\n    return 1.0 - k * aoSum;\n    #endif\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    vec3 col = vec3(.53, .76, .92) + max(rd.y,0.0)*0.5; //slight gradient, lighter towards top\n    \n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    vec3 colOrig;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.2 + 0.18*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        //col = vec3(0.2);\n        col = 0.2 + 0.18*sin( m*2.0 + vec3(0.0,0.5,1.0) );\n        \n        int im = int(m);\n        switch(im) {\n            case POINT:\n        \t//case ARM_LEFT:\n        \t//case ARM_RIGHT:\n            //case LEG_LEFT:\n            //case LEG_RIGHT:\n            case OUTER_EAR:\n            case TAIL:\n        \t\tcol = darkBlue;\n            \tbreak;\n            case INNER_EAR:\n            \tcol = orange;\n            \tbreak;\n            case DRESS:\n            \t//map texture from buffer A, plane projection\n            \tcol = texture(iChannel0, (pos.yz + (-2.5, .2)) / 2.).rgb;\n            \tbreak;\n            case HEAD:\n            \t//map texture from buffer C, spherical projection\n                vec3 pt = (pos - rotateY(rotateZ(rotateX(vec3( 0.0,0.93, 0.0), .01 * sin(iTime * 5.)), .01 * sin(iTime * 3.)), .01 * sin(iTime * 3.))) / .25;\n                float phi = atan(pt.z, pt.x);\n                if (phi < 0.) phi += 2. * 3.14159;\n                float theta = acos(pt.y);\n                col = texture(iChannel2, vec2(1. - phi / (2. * 3.14159), 1. - theta /  3.14159)).rgb;\n            \tbreak;\n            case FLOOR:\n            \t//map texture from buffer D, plane projection\n            \tcol = texture(iChannel3, (pos.xz + vec2(.8, .8)) * .5).rgb;\n            \tbreak;\n            case LIGHTBLUE:\n            \tcol = lightBlue;\n            \tbreak;\n            case ORANGE:\n            \tcol = orange;\n            \tbreak;\n            case BRIGHTPINK:\n            \tcol = brightPink;\n            \tbreak;\n            case LIGHTPINK:\n            \tcol = lightPink;\n            \tbreak;\n            default:\n            \tcol = cream;\n        }\n        \n        colOrig = col;\n        \n        // lighting, from https://www.shadertoy.com/view/Xds3zN\n        float occ = calcAO( pos, nor ); //ambient occlusion\n\t\tvec3  lig = normalize( vec3(-0.5, 0.4, -0.6) ) * .2; //light position\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 )); //add darker shading \n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 ); //make slightly diffuse?\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0); //makes slightly darker\n        float dom = smoothstep( -0.2, 0.2, ref.y ); //main shadows\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 ); //\"bounce\" light\n        \n        //penumbra shadows\n        dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 3.80*dif*vec3(1.30,1.00,0.70);\n        lin += 0.55*amb*vec3(0.40,0.60,1.15)*occ;\n        lin += 0.85*dom*vec3(0.40,0.60,1.30)*occ;\n        lin += 0.55*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin; //adjust color according to lighting\n\n        col = mix( col, vec3(.53, .76, .92), 1.0-exp( -0.0001*t*t*t ) ); //mix resulting color with some of the background sky\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n    //return vec3( clamp(colOrig,0.0,1.0) ); //flat shading\n}\n\n//set up camera axes\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //use mouse to move around scene\n    //taken from https://www.shadertoy.com/view/Xds3zN\n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n    //smooth rotation around y axis\n    //mo.y = .0;\n    //mo.x = sin(iTime / 10000.) * iResolution.x;\n    \n\tfloat time = 15.0 + iTime*1.5;\n\n    // camera\t\n    vec3 ta = vec3( 0.0, 0.7, 0.0 );\n    vec3 ro = ta + vec3( 2.5*cos(0.1 + 6.0*mo.x), 0.0 + 4.0*(mo.y), 2.5*sin(0.1 + 6.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    //ANTI-ALIASING\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,2.5) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,2.5) );\n        vec3 rdy = ca * normalize( vec3(py,2.5) );\n        \n        // render\t\n        vec3 col = render( ro, rd, rdx, rdy );\n        \n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n} \n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//DRESS PATTERN\n\nconst vec3 a = vec3(0.5, 0.5, 0.5);\nconst vec3 b = vec3(0.5, 0.5, 0.5);\nconst vec3 c = vec3(1.0, 1.0, 1.0);\nconst vec3 d = vec3(0.0, 0.1, 0.2);\n\nvec3 colorPalette(float t) {\n    return a + b * cos(6.28 * (t * c + d));\n}\n\nvec2 random2( vec3 p , vec3 randoNums ) {\n    return fract(sin(vec2(dot(p,vec3(randoNums.x, 311.7, randoNums.z)),\n                          dot(p,vec3(269.5, randoNums.y, 765.54))))\n                 *43758.5453);\n}\n\nfloat WorleyNoise2D(vec2 p, out float dist, in int layer) {\n    float tileSize = 1.;\n    int ts = 1;\n    vec2 pointFract = vec2(mod(p.x, tileSize),mod(p.y, tileSize));\n    vec2 pointInt = p - pointFract;\n\n    vec2 theNeighbor = vec2(0.);\n    float minDist = tileSize;\n    for(int y = -ts; y <= ts; y+=ts)\n    {\n        for(int x = -ts; x <= ts; x+=ts)\n        {\n            vec2 neighbor = vec2(float(x), float(y));\n            \n            //difference noise results for different layers of dots\n            vec2 point;\n            switch(layer) {\n                case 0:\n                \tpoint = random2(vec3(pointInt + neighbor,0.), vec3(124.7, 983.2, 584.6));\n                break;\n                case 1:\n                \tpoint = random2(vec3(pointInt + neighbor,0.), vec3(824.7, 283.2, 184.6));\n                break;\n                case 2:\n                \tpoint = random2(vec3(pointInt + neighbor,0.), vec3(864.7, 238.2, 984.6));\n                break;\n                case 3:\n                \tpoint = random2(vec3(pointInt + neighbor,0.), vec3(235.7, 433.2, 894.6));\n                break;\n            }\n            \n\n            // Animate the point\n            point = 0.5 + 0.5 * sin(iTime + 6.2831 * point) * .5; // 0 to 1 range\n            \n            vec2 diff = neighbor + point - pointFract;\n            float dist = length(diff);\n            if (dist < minDist) {\n                minDist = dist;\n                theNeighbor = neighbor + point;\n            }\n            //minDist = min(minDist, dist);\n        }\n    }\n    //return minDist;\n    dist = minDist;\n    return theNeighbor.x + theNeighbor.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv = uv * 7.;\n    \n    float dist;\n    float res = WorleyNoise2D(uv, dist, 0);\n    float dist2;\n    float res2 = WorleyNoise2D(uv, dist2, 1);\n    float dist3;\n    float res3 = WorleyNoise2D(uv, dist3, 2);\n    float dist4;\n    float res4 = WorleyNoise2D(uv, dist4, 3);\n    \n    //color the dot based on what layer can see it, prioritizing bright pink first and green last\n    if (dist <= .3) {\n        //bright pink\n        fragColor = vec4(.85, .05, .85,0.);\n    } else if (dist2 <= .3) {\n        //light pink\n        fragColor = vec4(.85, .50, .8,0.);\n    } else if (dist3 <= .3) {\n        //orange\n        fragColor = vec4(1., .26, .08, 0.);\n    } else if (dist4 <= .3) {\n        //green\n        fragColor = vec4(0.12, 0.44, 0.26,0.);\n    } else {\n        fragColor = vec4(.9, .9, .9, 0.);\n    }\n    \n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//MITZI'S FACE\n\nconst vec3 black = vec3(0., 0., 0.);\nconst vec3 white = vec3(1., 1., 1.);\nconst vec3 cream = vec3(.99, .98, .88);\nconst vec3 orange = vec3(.96, .56, .08);\nconst vec3 lightBlue = vec3(.33, .56, .72);\nconst vec3 darkBlue = vec3(0.07, 0.27, 0.43);\n\nvec2 random2( vec3 p , vec3 randoNums ) {\n    return fract(sin(vec2(dot(p,vec3(randoNums.x, 311.7, randoNums.z)),\n                          dot(p,vec3(269.5, randoNums.y, 765.54))))\n                 *43758.5453);\n}\n\nvec3 getColor( vec2 coords) {\n    float x = coords.x;\n    float y = coords.y +.1; //oops\n    vec2 c;\n    float a;\n    float b;\n    float yy;\n    \n    //whew I drew this all out on graph paper first... feels like I'm drawing on a calculator\n    \n    //nose\n    if (x >= -.025 && x <= .025 && y >= -.075 && y <= -.022) {\n        return black;\n    }\n    \n    //mouth\n    yy = .1 * sin((x-.02)*15.) - .05;\n    if (abs(y - yy) <= .02 && x >= -.15 && x <= 0.) {\n        return black;\n    }\n    yy = .1 * sin((x-.02)*15.) - .05;\n    if (abs(y - yy) <= .02 && x >= -.15 && x <= 0.) {\n        return black;\n    }\n \n    //eyeCenterRight\n    c = vec2(-.15, .208);\n    a = .05;\n    b = .085;\n    if ( pow(x - c.x, 2.) / (a * a) + pow(y - c.y, 2.) / (b * b) <= 1.) {\n        return black;\n    }\n    //eyeWhiteRight\n    if (-x >= .075 && -x <= .225 && y >= .084 && y <= .208) {\n        return white;\n    }\n    c = vec2(-.15, .208);\n    a = .075;\n    b = .2;\n    if (y >= .2 && pow(x - c.x, 2.) / (a * a) + pow(y - c.y, 2.) / (b * b) <= 1.) {\n        return white;\n    }\n    //eyeOutlineRight\n    if (-x >= .05 && -x <= .25 && y >= .042 && y <= .25) {\n        return darkBlue;\n    }\n    c = vec2(-.15, .25);\n    a = .1;\n    b = .2;\n    if (y >= .2 && pow(x - c.x, 2.) / (a * a) + pow(y - c.y, 2.) / (b * b) <= 1.) {\n        return darkBlue;\n    }\n\n    //facePoint\n    c = vec2(0., 0.);\n    a = .3;\n    b = .4;\n    if (pow(x - c.x, 2.) / (a * a) + pow(y - c.y, 2.) / (b * b) <= 1.) {\n        return lightBlue;\n    }\n    return cream;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //now -1 to 1\n\tuv = uv * 2.0 - 1.0;\n    \n    vec2 uv2 = vec2(-abs(uv.x), uv.y);\n    fragColor = vec4(getColor(uv2), 0.0);\n    \n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//GRASS PATTERN\n\nconst vec3 black = vec3(0., 0., 0.);\nconst vec3 white = vec3(1., 1., 1.);\nconst vec3 cream = vec3(.99, .98, .88);\nconst vec3 lightBlue = vec3(.33, .56, .72);\nconst vec3 darkBlue = vec3(0.07, 0.27, 0.43);\nconst vec3 darkSeaGreen = vec3(0.12, 0.44, 0.26);\nconst vec3 lightSeaGreen = vec3(0.125, 0.69, 0.6);\nconst vec3 lightYellowGreen = vec3(0.27, 0.69, 0.125);\n\nfloat random1( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(729.5, 653.54)),\n                          dot(p,vec2(269.5, 765.54))))\n                 *43758.5453).x;\n}\n\nfloat random1again( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(472.5, 583.54)),\n                          dot(p,vec2(962.5, 547.54))))\n                 *43758.5453).x;\n}\n\nvec2 random2( vec3 p , vec3 randoNums ) {\n    return fract(sin(vec2(dot(p,vec3(randoNums.x, 311.7, randoNums.z)),\n                          dot(p,vec3(269.5, randoNums.y, 765.54))))\n                 *43758.5453);\n}\nvec3 translate(vec3 pos, vec3 move) {\n    return vec3(pos.x + move.x, pos.y + move.y, 1.);\n}\n\n\nvec3 rotate(vec3 pos, float theta) {\n    return vec3(pos.x * cos(theta) - pos.y * sin(theta), pos.x * sin(theta) + pos.y * cos(theta), 1.);\n}\n\nvec3 scale(vec3 pos, vec3 move) {\n    return vec3(pos.x * move.x, pos.y * move.y, 1.);\n}\n\nvec3 getColor( vec2 coords) {\n    float x = coords.x;\n    float y = coords.y;\n    vec2 c;\n    float a;\n    float b;\n    float yy;\n    \n    //basically a bunch of transformations with slightly random rotation, placed in a pattern\n    //each nested for loop is just another size of square scattered around evenly\n    \n    for (float xx = -2.5; xx <= 2.5; xx+= .5) {\n        for (float yy = -1.; yy <= 1.; yy+= .5) {\n            float rand = random1(vec2(xx, yy)) * 2. - 1.;\n            vec3 newCoords = rotate(translate(vec3(x, y, 1.), vec3(xx, yy, 1.)), rand);\n            float tx = newCoords.x;\n            float ty = newCoords.y;\n            float radius = .1;\n            if (tx >= -radius && tx <= radius && ty >= -radius && ty <= radius) {\n                if (rand >= 0.)\n                \treturn lightSeaGreen;\n                else return lightYellowGreen;\n            }\n    \t}\n    }\n    \n    for (float xx = -2.25; xx <= 2.25; xx+= .5) {\n        for (float yy = -1.25; yy <= 1.25; yy+= .5) {\n            float rand = random1(vec2(xx, yy)) * 2. - 1.;\n            vec3 newCoords = rotate(translate(vec3(x, y, 1.), vec3(xx, yy, 1.)), rand);\n            float tx = newCoords.x;\n            float ty = newCoords.y;\n            float radius = .075;\n            if (tx >= -radius && tx <= radius && ty >= -radius && ty <= radius) {\n                if (rand <= 0.)\n                \treturn lightSeaGreen;\n                else return lightYellowGreen;\n            }\n    \t}\n    }\n    \n    for (float xx = -2.37; xx <= 2.37; xx+= .5) {\n        for (float yy = -1.37; yy <= 1.37; yy+= .5) {\n            float rand = random1(vec2(xx, yy)) * 2. - 1.;\n            vec3 newCoords = rotate(translate(vec3(x, y, 1.), vec3(xx, yy, 1.)), rand);\n            float tx = newCoords.x;\n            float ty = newCoords.y;\n            float radius = .05;\n            if (tx >= -radius && tx <= radius && ty >= -radius && ty <= radius) {\n                if (rand <= 0.)\n                \treturn lightSeaGreen;\n                else return lightYellowGreen;\n            }\n    \t}\n    }\n    \n    for (float xx = -2.13; xx <= 2.13; xx+= .5) {\n        for (float yy = -1.13; yy <= 1.13; yy+= .5) {\n            float rand = random1(vec2(xx, yy)) * 2. - 1.;\n            vec3 newCoords = rotate(translate(vec3(x, y, 1.), vec3(xx, yy, 1.)), rand);\n            float tx = newCoords.x;\n            float ty = newCoords.y;\n            float radius = .05;\n            if (tx >= -radius && tx <= radius && ty >= -radius && ty <= radius) {\n                if (rand <= 0.)\n                \treturn lightSeaGreen;\n                else return lightYellowGreen;\n            }\n    \t}\n    }\n    \n    for (float xx = -2.33; xx <= 2.33; xx+= .5) {\n        for (float yy = -1.13; yy <= 1.13; yy+= .5) {\n            float rand = random1(vec2(xx, yy)) * 2. - 1.;\n            vec3 newCoords = rotate(translate(vec3(x, y, 1.), vec3(xx, yy, 1.)), rand);\n            float tx = newCoords.x;\n            float ty = newCoords.y;\n            float radius = .05;\n            if (tx >= -radius && tx <= radius && ty >= -radius && ty <= radius) {\n                if (rand <= 0.)\n                \treturn lightSeaGreen;\n                else return lightYellowGreen;\n            }\n    \t}\n    }\n    \n    for (float xx = -2.13; xx <= 2.13; xx+= .5) {\n        for (float yy = -1.33; yy <= 1.33; yy+= .5) {\n            float rand = random1(vec2(xx, yy)) * 2. - 1.;\n            vec3 newCoords = rotate(translate(vec3(x, y, 1.), vec3(xx, yy, 1.)), rand);\n            float tx = newCoords.x;\n            float ty = newCoords.y;\n            float radius = .025;\n            if (tx >= -radius && tx <= radius && ty >= -radius && ty <= radius) {\n                if (rand <= 0.)\n                \treturn lightSeaGreen;\n                else return lightYellowGreen;\n            }\n    \t}\n    }\n    \n    for (float xx = -2.25; xx <= 2.25; xx+= .5) {\n        for (float yy = -1.5; yy <= 1.5; yy+= .5) {\n            float rand = random1(vec2(xx, yy)) * 2. - 1.;\n            vec3 newCoords = rotate(translate(vec3(x, y, 1.), vec3(xx, yy, 1.)), rand);\n            float tx = newCoords.x;\n            float ty = newCoords.y;\n            float radius = .065;\n            if (tx >= -radius && tx <= radius && ty >= -radius && ty <= radius) {\n                if (rand >= 0.)\n                \treturn lightSeaGreen;\n                else return lightYellowGreen;\n            }\n    \t}\n    }\n    \n    for (float xx = -2.5; xx <= 2.5; xx+= .5) {\n        for (float yy = -1.25; yy <= 1.25; yy+= .5) {\n            float rand = random1(vec2(xx, yy)) * 2. - 1.;\n            vec3 newCoords = rotate(translate(vec3(x, y, 1.), vec3(xx, yy, 1.)), rand);\n            float tx = newCoords.x;\n            float ty = newCoords.y;\n            float radius = .065;\n            if (tx >= -radius && tx <= radius && ty >= -radius && ty <= radius) {\n                if (rand >= 0.)\n                \treturn lightSeaGreen;\n                else return lightYellowGreen;\n            }\n    \t}\n    }\n    \n    return darkSeaGreen;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    //now -1 to 1\n    uv = vec2( uv.x * 2. - 2.569, uv.y * 2.0 - 1.0); //so its not stretched\n    \n    fragColor = vec4(getColor(uv), 0.0);\n}\n\n\n","name":"Buffer D","description":"","type":"buffer"}]}