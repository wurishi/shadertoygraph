{"ver":"0.1","info":{"id":"MclXRS","date":"1705442647","viewed":57,"name":"Accidental Artwork","username":"DwayneBrah","description":"Accidental Artwork while debugging a raindrop fluid-dynamics experment!","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["poppywatersim"],"hasliked":0,"parentid":"XffXD8","parentname":"poppy water sim"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pix_size = vec2(1.0, 1.0) / iResolution.xy;\n    vec2 uv_drops = uv;\n    vec4 col_out;\n    \n    vec4 col_a = texture(iChannel0, uv_drops);\n    vec4 col_b = texture(iChannel1, uv);\n    vec4 col_c = texture(iChannel2, uv);\n    \n    vec2 uv_mouse = iMouse.xy/iResolution.xy;\n    \n    if (iMouse.x <= 1.0) {\n        uv_mouse = vec2(0.5, 0.5);\n    };\n    \n    if (uv.x > uv_mouse.x) {\n        \n        \n        \n        \n        if (uv.y > uv_mouse.y) {\n            \n            fragColor = col_white*col_a.r;\n            if (col_a.r > 0.0 && mod(col_a.r,1.0) < 0.1) {\n                fragColor.r = 0.44;\n                fragColor.g = 0.11;\n                fragColor.b = 0.11;\n            };\n            if (col_a.g > 0.0 && mod(col_a.g,1.0) < 0.1) {\n                fragColor *= 0.66;\n                fragColor.g = 1.00;\n            };\n            if (col_a.g < 0.0) {\n                fragColor *= 0.66;\n                fragColor.r = 1.00;\n            };\n            if (col_a.r < 0.0) {\n                fragColor *= 0.66;\n                fragColor.b = 1.00;\n            };\n            \n        } else {\n            \n            fragColor = col_a;\n\n        };\n        \n        \n        // SHOW DIVIDER //\n        fragColor = mix(col_gray, fragColor, clamp(uv.x*70.0 - (iMouse.x/iResolution.x)*70.0 + 0.60, 0.0, 1.00)); \n        fragColor = mix(col_gray, fragColor, 0.2+clamp(abs(uv.y*140.0 - (iMouse.y/iResolution.y)*140.0 +  0.60), 0.1, 1.00)); \n        // SHOW DIVIDER //\n\n        \n        \n    } else {\n        \n        if (uv.y < uv_mouse.y) {\n            \n            fragColor = col_white*col_c;\n            \n        } else {\n            \n            fragColor = col_white*col_a.r;\n            \n        };        \n        \n    };\n     \n\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nfloat size_min  = 0.010;\nfloat size_max  = 0.040;\n\nfloat water_loss = 0.001;\nfloat water_loss_thresh = 0.20;\nfloat water_evaporate = 0.004;\nfloat water_evaporate_thresh = 0.10;\n\nfloat drop_volume = 1.00;\nfloat drop_duty = 0.02;\nint drop_count = 3;\n\n\nfloat dropoff_loss = 0.10;\nfloat drop_spread = 0.099;\n\nvec2 drop_mover = vec2(0.0, 0.001);\nfloat drop_mixer = 0.24; // THIS SHOULD KEEP THE EQUILIVRIUM - NOT ADD UP TO OUT OF CONTROL!\nfloat dry_resistance = 0.02;\n\n\nfloat drop_edge = 0.20;\nfloat haze_edge = 0.04;\n\n//float overload_thresh = 1.10;\nfloat fast_movement_thresh = 1.00;\nfloat surface_tension_thresh = 0.33;\nfloat movement_thresh = 0.24;\nfloat movement_stop = 1.10;\n\n\nfloat image_gamma = 0.66;\nfloat image_brightness = 0.99;\n\n\n\n// COLOURS //\nvec4 col_white = vec4(1.0, 1.0, 1.0, 1.0);\nvec4 col_gray = vec4(0.33, 0.33, 0.33, 0.33);\nvec4 col_black = vec4(0.0, 0.0, 0.0, 0.0);\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//////////////////////////////////////////////////////////////////////\nuint seed = 0u;\nvoid hash(){\n    seed ^= 2747636419u;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n}\nvoid initRandomGenerator(vec2 fragCoord){\n    seed = uint(fragCoord.y*iResolution.x + fragCoord.x)+uint(iFrame)*uint(iResolution.x)*uint(iResolution.y);\n}\n\nfloat random(){\n    hash();\n    return float(seed)/4294967295.0;\n}\n/////////////////////////////////////////////////////////////////////\n\nfloat noise( vec2 p ) {\n\tvec2 f = fract(p);\n\tp = floor(p);\n\tfloat v = p.x+p.y*1000.0;\n\tvec4 r = vec4(v, v+1.0, v+1000.0, v+1001.0);\n\tr = fract(10000.0*sin(r*.001));\n\tf = f*f*(3.0-2.0*f);\n\treturn 2.0*(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y))-1.0;\n}\n\nfloat loss = 0.0;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 pix_size = vec2(1.0, 1.0) / iResolution.xy;\n    vec2 ar = vec2(iResolution.x/iResolution.y, 1.0);\n    \n    vec4 col_a = texture(iChannel0, uv);\n    \n    \n    vec4 col_out = col_a;\n    \n    \n    if (true) {\n    \n        //float dif_owed = col_a.g;\n        //col_a.r -= dif_owed;\n        \n        vec2 dist = vec2(1.0);\n\n        // SURROUNDING SAMPLES //\n        vec4 col_a_up = texture(iChannel0, uv + pix_size*vec2(0.0, 1.0)*dist);\n        vec4 col_a_right = texture(iChannel0, uv + pix_size*vec2(1.0, 0.0)*dist);\n        vec4 col_a_down = texture(iChannel0, uv + pix_size*vec2(0.0, -1.0)*dist);\n        vec4 col_a_left = texture(iChannel0, uv + pix_size*vec2(-1.0, 0.0)*dist);\n        vec4 col_avarage = (col_a_up+col_a_right+col_a_down+col_a_left)/4.0;\n        \n        // REBALANCING //\n        float owed_avarage = col_avarage.g;\n        float calculated_depth = col_a.r - owed_avarage*0.70;\n        if (calculated_depth > 0.0) {\n            col_a.r -= owed_avarage*0.70;\n            col_a.g = owed_avarage*0.30;\n        } else {\n            col_a.g = owed_avarage;\n        };\n        \n        // DIMINISHING/EVAPORATION //\n        if (col_a.r < 0.20) {\n            col_a.r *= 0.99; \n        };\n        \n        \n        //col_a.r -= owed_avarage*0.70;\n        //col_a.g = owed_avarage*0.30;\n        \n        float dif = col_avarage.r - col_a.r;\n        float transfer_rate = 0.0;\n\n        // ONLY IF THE NEIGHBOURS ARE BIGGER?\n        if (dif < 0.0) {\n            transfer_rate = 0.30;\n        };\n        if (dif > 0.0) {\n            transfer_rate = 0.15;\n        };\n\n        // IF WE EXPECT TO BE IN THE POSITIVE FROM NEIGHBORS AND THE NEIGHBOURS VOL IS ABOVE //\n        if (col_avarage.r > 0.20 && dif > -0.003) {\n            transfer_rate += 0.20;\n        };\n\n        float amount_to_transfer = dif*transfer_rate;\n        \n\n        // IF CONTRAST IS WAY BIG ??\n        \n        \n        col_out = col_a;\n        col_out.r += amount_to_transfer;\n        col_out.g += amount_to_transfer;\n\n    };\n\n    initRandomGenerator(vec2(iFrame) );\n    float rand = mod(random(), 1.0);\n    if (rand < drop_duty) {\n        \n        vec2 uv_drop;\n        float drop_size = mod(random(),size_max-size_min) + size_min;\n        drop_size += size_min;\n        \n        float size_normalized = (drop_size / size_max);\n        \n        for (int x = 0; x < drop_count; x++) {\n            \n            uv_drop = vec2(mod(random(),1.0), mod(random(), 1.0));\n            uv_drop.x *= ar.x;\n\n            float d = distance(uv_drop, uv*ar);\n            if (d < drop_size) {\n                \n                float from_center = (drop_size - d) / drop_size;\n\n                \n                //\n                if (int(rand*2.0)%2 == 0) {\n                    initRandomGenerator(vec2(iFrame) + fragCoord);\n                    col_out += vec4(mod(random(),1.0), 0.0, 0.0, 1.0);\n                } else {\n                    col_out += vec4(1.0, 0.0, 0.0, 1.0) * from_center * drop_volume;\n                };\n                //col_out += vec4(mod(random(),1.0), 0.0, 0.0, 1.0) * from_center * drop_volume;\n\n            };\n\n            \n            \n        };\n        \n    };\n    \n    \n    \n    \n    fragColor = col_out;\n\n    \n    \n    \n    \n}\n\n\n\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 pix_size = vec2(1.0, 1.0) / iResolution.xy;\n    vec2 ar = vec2(iResolution.x/iResolution.y, 1.0);\n    \n    vec4 col_background = texture(iChannel3, uv);\n    vec4 col_a = texture(iChannel0, uv);\n    \n    float dist = 1.0;\n    vec4 col_a_right = texture(iChannel0, uv + pix_size*vec2(1.0, 0.0)*dist);\n    vec4 col_a_up = texture(iChannel0, uv + pix_size*vec2(0.0, 1.0)*dist);\n    \n    \n    vec2 surface = vec2 (col_a.r/col_a_right.r, col_a.r/col_a_up.r);\n    vec2 surface_2 = vec2 (col_a.r-col_a_right.r, col_a.r-col_a_up.r);\n    float depth = col_a.r;\n    \n    \n    vec2 uv_warp = uv + (surface*surface_2);\n    \n    \n    vec4 col_background_warped = texture(iChannel3, uv_warp);\n    \n    \n    vec4 col_out = col_background_warped; \n    \n    \n    \n    fragColor = col_out;\n\n    \n    \n}","name":"Buffer C","description":"","type":"buffer"}]}