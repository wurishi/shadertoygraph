{"ver":"0.1","info":{"id":"NsySDd","date":"1635470484","viewed":53,"name":"bitwise & sierpinski triangle","username":"HalbFettKaese","description":"Uses the & operation to render a Sierpinski triangle.\nI was inspired to make this by this video:\nhttps://youtu.be/5nuYD2M2AX8","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sierpinski","bitwise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592653589793\n#define invln2 1.4426950408889634\n\nconst float zoom = 3.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.xx;\n    uv *= zoom; // zoom out\n    uv += .5; // recenter the image around (.5, .5)\n    float px = zoom/iResolution.y; // The size of one pixel\n\n    // Resulting pixel color\n    vec3 col = vec3(.5+.5*uv, 0);\n    // triangle shape\n    col *= \n        smoothstep(-.5*px, .5*px, uv.x) * // Lower border\n        smoothstep(-.5*px, .5*px, uv.y) * // Left border\n        smoothstep(1. + px, 1., uv.x + uv.y); // Upper-right border\n    // Sierpinski triangle pattern\n    float detail = 1.+floor(-log(px)*invln2);\n    ivec2 iuv = ivec2(uv * pow(2., detail)); // Consider number of binary digits corresponding to amount of detail\n    if ((iuv.x & iuv.y) != 0)\n        col *= 0.;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}