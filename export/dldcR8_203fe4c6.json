{"ver":"0.1","info":{"id":"dldcR8","date":"1698947430","viewed":66,"name":"Rect Intersection or Distance","username":"kastorp","description":"mouseable","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["intersection","rectangle","distance","box"],"hasliked":0,"parentid":"cdcfzB","parentname":"Squares Intersection or distance"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Rect Intersection || distance \n//----------------------------------------\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    \n    #define ROT(a) mat2(cos(a),sin(a),-sin(a),cos(a))    \n    #define gBox( p, b ) sign(p)*(max(abs(p)-b,0.))\n    #define dBox( p, b ) length(max(abs(p)-b,0.))\n     \n    vec2 R= iResolution.xy;\n    vec2 uv = (I- R*.5)/R.y, m =(iMouse.xy- R*.5)/R.y;\n   \n    // RECTANGLE  positions and rotations\n    vec2 La =vec2(.02,.25), Lb=vec2(.08,.15);\n    float EPS=.001;\n    \n    float t =float(iFrame)/60.;\n    vec2  a =La *ROT(-t*.3)*.5, \n          b = iMouse.z>0. ?m: vec2(cos(t*.5),sin(t*.5))*vec2(6,2)*Lb*ROT(t*.05) ;\n    float ra= -t*.2,\n          rb=  t*.6;\n          \n   \n    mat2 rota=ROT(ra),rotb=ROT(rb);\n\n    //LOGIC:\n#if 1\n    //optimized, evaluate 2 vertexes for each box\n    //but performances are almost identical\n    vec2 va= a+ rota* (La* sign((b-a)*rota)) , //closest vertex of A\n         vb= b+ rotb* (Lb *sign((a-b)*rotb));  //closest vertex of B     \n    vec2 sb= sign((vb-b)*rotb)*sign((va-b)*rotb)*sign((a-b)*rotb), \n         sa= sign((va-a)*rota)*sign((vb-a)*rota)*sign((b-a)*rota);\n    vec2 vb2=  b+ rotb* (Lb *sb);\n    vec2 va2=  a+ rota* (La *sa);       \n    if(dBox((va2-b)*rotb,Lb)<dBox((va-b)*rotb,Lb)){va=va2;}  \n    if(dBox((vb2-a)*rota,La)<dBox((vb-a)*rota,La)){vb=vb2;}  \n#else\n    //brute force, evaluate 4 vertexes for each box\n    vec2 va,vb; float da=1e5, db=1e5;\n    for(float x=-1.;x<=1.;x+=2.) for(float y=-1.;y<=1.;y+=2.){\n        vec2 va2= a+ rota* (La* vec2(x,y)),\n             vb2= b+ rotb* (Lb* vec2(x,y));\n        float da2= dBox((va2-b)*rotb,Lb),\n              db2= dBox((vb2-a)*rota,La);\n        if(da2< da) { va=va2; da=da2;} \n        if(db2< db) { vb=vb2; db=db2;}\n    }\n#endif\n    vec2  ga= gBox((va-b)*rotb,Lb),  \n          gb= gBox((vb-a)*rota,La);  \n    vec2  vab =va-rotb*ga, // closest point to VA\n          vba =vb-rota*gb; // closest point to VB   \n    float dc = length(ga)-length(gb);   \n    \n    if(abs(dc)<EPS && length(vb-vab)>EPS){vb+=(vab-vb)*.5;va+=(vba-va)*.5;} \n    else  if(dc<=0.) vb=vab;\n    else va=vba;\n    \n    bool intersect=  min(length(ga),length(gb))<=0. || length(va-a)>length(vb-a) || length(vb-b)>length(va-b)  ;\n       \n    //VISUALIZATION \n    float d= dBox((uv-b)*rotb,Lb)-dBox((uv-a)*rota,La);\n           d=d/fwidth(d) *100./R.y;\n    vec3 col = //0.5 + 0.1*cos(iTime+uv.xyx+vec3(0,2,4));  // background\n          0.5 + .2*exp(-abs(d)*.3)*cos(d +vec3(0,2,4));  // background\n    if(dBox((uv-a)*rota,La)<=0.) col=intersect? vec3(.2,.8,.8):vec3(.1,.4,.4);\n    if(dBox((uv-b)*rotb,Lb)<=0.) col=intersect? vec3(.8,.2,.2):vec3(.4,.1,.1); \n\n    #define seg(pa,ba) length( (pa) - (ba)*clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 ) )\n    if(seg(uv-va,vb-va)<.005) col=vec3(0,.5,0);\n    if(length(uv-va)<.01  ) col =vec3(1,1,0); \n    if(length(uv-vb)<.01 ) col =vec3(1,1,0); \n   \n          \n    // Output to screen\n    O = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}