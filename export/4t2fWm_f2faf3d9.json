{"ver":"0.1","info":{"id":"4t2fWm","date":"1516434055","viewed":219,"name":"Pathtrace Normals","username":"shemit","description":"Getting normals to begin path tracing, saving separately to keep for future reference.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["pathtracingnormals"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SAMPLES 1\n#define PI 3.141592653589793\n\nstruct Sphere {\n    float radius;\n    vec3 position;\n    float emission;\n    vec3 color;\n};\n\nstruct Camera {\n\tvec3 position;\n    vec3 direction;\n    vec3 up;\n    float fov;\n};\n    \nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nvec2 gridify(vec2 uv, float split) {\n    return ceil(uv * split) / split;\n}\n\nvec3 getNormal(Ray ray) {\n    return vec3(0.0, 0.0, 0.0);\n}\n\nRay makeRay(vec2 uv, Camera camera) {\n    // simplify the sensor width to be res.x / res.y\n    // simplify the sensor height to be 1.0\n    \n    // first solve for near clip plane:\n    // tan(FOV / 2.0) = midx / adj\n    // adj = (uv.x / 2.0) / tan(FOV / 2.0)\n    \n    float midx = 0.5 * iResolution.x / iResolution.y;\n    float midy = 0.5;\n    float clipDistance = midx / tan(camera.fov / 2.0);\n    \n    // origin of ray at clipDistance location will be:\n    // (clipDistance, 0.0, 0.0)\n    // i.e.\n    // f(midx, midy) = Ray(origin: 0.0, direction: 1.0)\n    \n    // 1. tackle the origin of the ray\n    // we make the assumption that up is orthogonal to \n    // diretion (should add in a check for this later)\n    // we are left to find the remaining basis, which is\n    // the cross product of the two\n    vec3 xbasis = normalize(cross(camera.direction, camera.up));\n    vec3 ybasis = camera.up;\n    vec3 zbasis = camera.direction;\n    \n    // multiply sensor dimensions by basis to get position of pixel\n    // in world space\n    vec3 x = (uv.x - midx) * xbasis;\n    vec3 y = (uv.y - midy) * ybasis;\n    vec3 z = clipDistance * zbasis;\n   \n    // add these all together\n    vec3 position = x + y + z;\n    \n    // normalize to get a unit vector from the position\n    vec3 direction = normalize(position);\n    \n    // then, add the camera position\n    vec3 origin = position + camera.position;\n    \n    \n    Ray ray = Ray(origin, direction);\n    return ray;\n}\n\nfloat intersect(Ray ray, Sphere sphere) {\n    float eps = 0.0000001;\n    float t = 0.0;\n\n    vec3 offset = sphere.position - ray.origin;\n    vec3 direction = ray.direction;\n    float dist = dot(offset, ray.direction);\n    \n    // Quadratic equation to solve for hit distance\n    float discriminant = dist * dist - \n        dot(offset, offset) + \n        sphere.radius * sphere.radius;\n    \n    if (discriminant < 0.0) {\n        return 99999999999.0;\n    } else {\n        discriminant = sqrt(discriminant);\n        t = dist - discriminant;\n        if (t > eps) {\n        \treturn t;   \n        } else {\n         \tt = dist + discriminant;\n            if (t > eps) {\n             \treturn t;   \n            }\n        }\n    }\n    \n    return 99999999999.0;\n}\n\nvec3 pathtrace(vec2 uv, Camera camera, Sphere spheres[6]) {\n    float r = 1.0;\n    float g = 1.0;\n    float b = 1.0;\n    \n    float x = uv.x;\n    float y = uv.y;\n    \n    \n    // TODO: Loop through this by samples/pixel\n    Ray ray = makeRay(uv, camera);\n    \n    // begin firing rays\n    \n    float minDistance = 999999999999999.0;\n    int closestIdx = -1;\n    vec3 hitLocation = vec3(0.0, 0.0, 0.0);\n    vec3 normal = vec3(0.0, 0.0, 0.0);\n    for (int i = 0; i < 6; i++) {\n        Sphere sphere = spheres[i];\n        float d = intersect(ray, sphere);\n        if (d < minDistance) {\n            minDistance = d;\n            closestIdx = i;\n            hitLocation = ray.origin + (ray.direction * minDistance);\n    \t\tnormal = normalize(hitLocation - sphere.position);\n            \n            // Flip normals if we are inside of the sphere\n            if (length(sphere.position - ray.origin) < sphere.radius) {\n                normal = normal * -1.0;\n            }\n        }\n    }\n    \n    \n    vec3 color = normal;\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 res = iResolution.xy;\n\tvec2 uv = fragCoord / res.y;\n    \n    float split = 40.0;\n    \n    vec3 position = vec3(0.0, 0.0, 0.0);\n    vec3 direction = vec3(0.0, 0.0, 1.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    // We set the FOV to be 90 degrees\n    Camera camera = Camera(position, direction, up, PI / 2.0);\n    \n    // Scene setup\n    Sphere ceiling = Sphere(\n    \t1000.0,\n        vec3(0.0, -997.0, 0.0),\n        0.0,\n        vec3(1.0, 1.0, 1.0)\n    );\n    Sphere left = Sphere(\n    \t1000.0,\n        vec3(-995.0, 0.0, 0.0),\n        0.0,\n        vec3(1.0, 1.0, 1.0)\n    );\n    Sphere right = Sphere(\n    \t1000.0,\n        vec3(995.0, 0.0, 0.0),\n        0.0,\n        vec3(1.0, 1.0, 1.0)\n    );\n    Sphere bottom = Sphere(\n    \t1000.0,\n        vec3(0.0, 997.0, 0.0),\n        0.0,\n        vec3(1.0, 1.0, 1.0)\n    );\n    Sphere back = Sphere(\n    \t1000.0,\n        vec3(0.0, 0.0, -990.0),\n        0.0,\n        vec3(1.0, 1.0, 1.0)\n    );\n    Sphere front = Sphere(\n    \t1000.0,\n        vec3(0.0, 0.0, -990.0),\n        0.0,\n        vec3(1.0, 1.0, 1.0)\n    );\n    Sphere middle = Sphere(\n    \t0.5,\n        vec3(0.0, 0.0 + sin(3.0 * iTime), 3.0),\n        0.0,\n        vec3(1.0, 1.0, 1.0)\n    );\n    Sphere spheres[6];\n    spheres[0] = middle;\n    spheres[1] = back;\n    spheres[2] = left;\n    spheres[3] = right;\n    spheres[4] = ceiling;\n    spheres[5] = bottom;\n    \n    \n    \n    \n    vec2 grid = gridify(uv, split);\n    vec3 result = pathtrace(grid, camera, spheres);\n    \n    \n\tfragColor = vec4(result, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}