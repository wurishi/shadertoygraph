{"ver":"0.1","info":{"id":"7dXSRn","date":"1618172399","viewed":50,"name":"raymarching 123456","username":"speediplayz","description":"click on screen to move red ball","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define minDist 0.05\n#define maxDist 512.0\n#define maxSteps 512.0\n\n#define FOV 90.0\n\nstruct Sphere{\n    vec3 pos;\n    vec4 color;\n    float rad;\n};\n\nstruct Hit{\n    bool hit;\n    vec3 pos;\n    float dist;\n    float minimum;\n    float steps;\n    Sphere sphere;\n};\n\nconst float sphereCount = 4.0;\nSphere[int(sphereCount)] spheres;\n\nfloat distToSphere(vec3 pos, vec3 origin, float rad){\n    return length(origin-pos)-rad;\n}\n\nHit rayMarch(vec3 origin, vec3 dir){\n    \n    Hit hit;\n    float d = 0.0;\n    vec3 pos = origin;\n    float minimum = maxDist;\n    \n    for(float i = 0.0; i < maxSteps; i++){\n        float dist = distToSphere(pos, spheres[0].pos, spheres[0].rad);\n        Sphere hitSphere = spheres[0];\n        for(float i = 0.0; i < sphereCount; i++){\n            float sphereDist = distToSphere(pos, spheres[int(i)].pos, spheres[int(i)].rad);\n            if(sphereDist <= dist){\n                dist = sphereDist;\n                if(dist < minimum) minimum = dist;\n                hitSphere = spheres[int(i)];\n            }\n        }\n        \n        d += dist;\n        pos += dir * dist;\n        \n        if(dist < minDist){\n            hit.dist = d / maxDist;\n            hit.minimum = minimum;\n            hit.pos = pos;\n            hit.hit = true;\n            hit.steps = i;\n            hit.sphere = hitSphere;\n            return hit;\n        }\n        if(d > maxDist){\n            hit.dist = maxDist;\n            hit.minimum = minimum;\n            hit.pos = dir * maxDist;\n            hit.hit = false;\n            hit.steps = i;\n            hit.sphere = hitSphere;\n            return hit;\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    spheres[0].pos = vec3(0,0,125);\n    spheres[0].color = vec4(0.1,0.1,0.625,1);\n    spheres[0].rad = 50.0;\n    \n    spheres[1].pos = vec3(-35.0 + (iMouse.x/iResolution.x) * 50.0, (iMouse.y/iResolution.y) * 50.0, 62.5);\n    spheres[1].color = vec4(0.625,0.25,0.3,1);\n    spheres[1].rad = 10.0;\n    \n    spheres[2].pos = vec3(32,10.0+sin(2.0*iTime)*10.0,75);\n    spheres[2].color = vec4(0.7,0.625,0.05,1);\n    spheres[2].rad = 15.0;\n    \n    spheres[3].pos = vec3(-5,35,95);\n    spheres[3].rad = 15.0;\n    spheres[3].color = vec4(1,0.5,0.5,1);\n    \n    vec2 uv = (fragCoord-(iResolution.xy*0.5))/iResolution.y;\n    \n    vec3 cam = vec3(0,0,-0.15);\n    \n    vec3 light = vec3(-15,50,50);\n    \n    vec3 dir = normalize(vec3(uv.xy, cam.z + 90.0/FOV));\n    \n    Hit hit = rayMarch(cam, dir);\n    \n    //fragColor = vec4(hit.steps/maxSteps, hit.steps/maxSteps, hit.steps/maxSteps, 1) * 4.0;\n    \n    if(hit.hit) {\n        vec3 lightDir = normalize(light - hit.pos);\n        vec3 normal = normalize(hit.pos - hit.sphere.pos);\n        Hit lightMarch = rayMarch(hit.pos + normal * 0.1, lightDir);\n        \n        if(lightMarch.hit) {\n            vec4 color = vec4(0.2,0.2,0.2,1);\n            fragColor = color * hit.sphere.color;\n        }\n        else {\n            float lightLevel = dot(normal, lightDir) + 1.0;\n            vec4 color = hit.sphere.color * lightLevel;\n            fragColor = color * 0.5;\n        }\n    }\n    else{\n        float glow = (hit.minimum / maxDist) * 64.0 ;\n        fragColor = vec4(glow, 1, 1, 1);\n    }\n}\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}