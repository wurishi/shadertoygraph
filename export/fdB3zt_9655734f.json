{"ver":"0.1","info":{"id":"fdB3zt","date":"1617792321","viewed":374,"name":"glowing Mandelbulb ","username":"Felox","description":"colored 3D mandelbrot set ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","mandelbulb","glow","ambientocclusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEP 100\n#define MAX_DIST 100.\n#define SURFACE_DIST .01\n#define PI 3.141592653589793238462643\n\nvec3 RayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    float minDist = MAX_DIST;\n    float nbSteps = 0.;\n    \n    for (int i=0;i<MAX_STEP;i++) {\n        nbSteps += 1.;\n        vec3 p = ro + rd * dO;\n        float dS = DE(p,iTime);\n        dO += dS;\n        if (dS<minDist) minDist = dS;\n        if (dS<=SURFACE_DIST) minDist = 1.;\n        if (i>=MAX_STEP || dS<=SURFACE_DIST ) break;\n    }\n    return vec3(dO,minDist,nbSteps);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(1,0,-3.);\n    vec3 rd = normalize(vec3(uv.x-0.65, uv.y, 1.));\n\n    vec3 col = vec3(0.);\n    \n    vec3 RM = RayMarch(ro,rd);\n    vec2 dif = vec2(1.-(RM.x/10.), RM.y);\n\n    vec3 glowmap = vec3(0.,0.,pow(1.-dif.y,5.));\n    \n    vec3 difMap = vec3(dif.x*10.-7.,0.,dif.x*10.-8.);  //MANDELBULB RÃ‰GLAGES\n    float ambiantOccl = (1.-(1.-RM.z/15.))*(max(RM.y, .99)-.99)*100.;\n    \n    col = max(difMap*ambiantOccl,glowmap);\n    //vec3(RM.z/10.)\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.141592653589793238462643\n#define Iterations 6\n#define Bailout 10.\n\nfloat DE(vec3 pos, float time) {\n    float Power = cos(time/PI)/2.+3.5;\n\tvec3 z = pos;\n\tfloat dr = 1.7;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < Iterations ; i++) {\n\t\tr = length(z);\n\t\tif (r>Bailout) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r) * Power;\n\t\tfloat phi = atan(z.y,z.x) * Power;\n\t\tdr =  pow( r, Power-1.)*Power*dr + 1.;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}","name":"Common","description":"","type":"common"}]}