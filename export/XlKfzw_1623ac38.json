{"ver":"0.1","info":{"id":"XlKfzw","date":"1545230519","viewed":96,"name":"Activit√©s 7 et 8","username":"Elra","description":"Antialiazing + Reflexion par ray-tracing","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["act78"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FLT_MAX = 1000000.0; \nstruct Material {\n    float Ka; //ambiant coef\n    float Kd; //diffuse coef\n    float Ks; //specular coef\n    float Kn; //specular power coef\n};\n\n//sky parameters\nconst vec3 skyCol = vec3(0); //black\nconst int skyId = 0;\n    \n//Camera parameters\nvec3 cameraPos = vec3(6,4,-5);\nvec3 cameraTarget = vec3(3,1,-8);\nconst vec3 ScameraTarget = vec3(3,1,-8);\nconst float cameraFovY = 80.0;\n\n//Sphere parammeters\nconst int sphereId = 1;\nvec3 spherePos = ScameraTarget + vec3(0,1,2);\nconst float sphereRadius = 1.0;\nconst vec3 sphereCol = vec3(1,0,0); //red\nconst Material sphereMat = Material(0.2, 0.7, 1.0, 50.0);\n\n// Light(s) parameters\nconst vec3 ambiantCol = vec3(0,0,1);\n \nconst vec3 lightCol = vec3(1,1,1); //white\nvec3 lightPos = vec3(8, 10, -12);\nconst float lightPow = 0.8;\n\nconst int MAX_NB_BOUNCES = 4;\n\n//Plane parameters\nconst vec3 planePos = vec3(0.,0.1,0.);\nconst vec3 planeNormal = vec3(0.,1.0,0);\nconst vec3 planeCol1 = vec3(1.0); //white\nconst vec3 planeCol2 = vec3(0.4); //gray\nconst Material planeMat = Material(0.2,0.5,0.5,15.0);\nconst int planeId = 2;\n\nfloat f, delta, a , b, c, t, t1, t2;\nvec2 pt;\nvec3 PT, cz, PO, cyT, cxT, cx, cy, OS, PS, SP, SO;\nfloat res;\n\n\n    \nstruct ShadeInfo{\n    vec3 shadedCol;\n    float Ks;\n};\n\nvec2 transform_to_apply(vec2 fragCoord){\n    vec2 pt;\n    pt = (2.0*fragCoord.xy - iResolution.xy) / iResolution.y;\n    return pt;\n}\n\nvoid computeCameraRayFromPixel(in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir){\nrayPos = cameraPos;\nf = 1.0/tan(radians(cameraFovY) / 2.0);\nPT = cameraTarget - cameraPos;\n\ncz = normalize(PT);\nPO = f * cz;\ncyT = vec3(0.0, -1.0, 0.0);\ncxT = cross(cyT, cz);\ncx = normalize(cxT);\ncy = cross(cz, cx);\npt = transform_to_apply(pixCoord);\nOS = pt.x * cx - pt.y * cy;\nPS = PO + OS;\nrayDir = normalize(PS);\n}\n\nfloat raySphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float sphereRadius, out vec3 intersecS,out vec3 normalS){\n    SO = rayPos - spherePos;\n    a = dot(rayDir, rayDir);\n    b = 2.0* dot(SO, rayDir);\n    c = dot(SO, SO) - dot ( sphereRadius, sphereRadius);\n    delta = b*b - 4.0*a*c;\n    if (delta <= 0.0){\n        res = -1.0;\n    }\n  \n    if (delta > 0.0){\n        t1 = (-b + sqrt(delta)) / 2.0*a;\n        t2 = (-b - sqrt(delta)) / 2.0*a;\n        if (t1 >=0.0 && t2 >=0.0){\n            res = t2;\n        }else {\n            res = -1.0;\n        }\n    }\n    return res;\n}\n\nvec3 computePhongShading(vec3 objectCol, Material objectMat,float shadowFactor, vec3 N, vec3 L, vec3 R, vec3 V){\n    vec3 ambiant = objectMat.Ka * ambiantCol;\n    vec3 diffuse  = objectMat.Kd * objectCol * lightCol * max(dot(N,L), 0.);\n    vec3 specular = objectMat.Ks * lightCol * pow(max(dot(R,V), 0.), objectMat.Kn);\n    \n    float shadowFactorSpec = shadowFactor < 1.0 ? 0.0 : 1.0;\n    \n    vec3 phongCol = ambiant + (diffuse * shadowFactor) + (specular * shadowFactorSpec);\n\n    return phongCol;\n}\n\nfloat rayPlane ( vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal, out vec3 intersecPt, out vec3 normalPt){\n            \n    if (dot(planeNormal, rayDir) == 0.0f)\n        return -1.0;\n    \n    float t = dot(planePos - rayPos,planeNormal) / dot(planeNormal, rayDir); \n    \n    intersecPt = rayPos + t * rayDir;\n    normalPt = -sign(dot(planeNormal, rayDir)) * planeNormal;\n    \n    return t;\n}\n\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir,out int objectId, out vec3 intersecI, out vec3 normalI){\n    float minDist  = FLT_MAX;\n    objectId = skyId;\n    \n    // Sphere\n    vec3 intersecS, normalS;\n    float distS = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    intersecS = rayPos + distS * rayDir;\n    normalS = normalize(intersecS - spherePos);\n    if ((distS > 0.0) && (distS < minDist))\n    {\n        objectId = sphereId;\n        minDist = distS;\n        intersecI = intersecS;\n        normalI = normalS;\n    }\n    \n    // Plane\n    vec3 intersecPt, normalPt;\n    float distP =  rayPlane(rayPos, rayDir,  planePos,  planeNormal, intersecPt, normalPt);\n    if ((distP > 0.0) && (distP < minDist))\n    {\n        objectId = planeId;\n        minDist = distP;\n\t    intersecI = intersecPt;\n    \tnormalI = normalPt;\n    }\n    \n    if (objectId == skyId)\n        minDist = -1.0;\n    \n    return minDist;\n}\n\n\nvec3 getSphereColorAtPoint(vec3 pt){\n    return sphereCol;\n}\n\nvec3 getPlaneColorAtPoint(vec3 pt){\n    vec3 worldX = vec3(1,0,0);\n    vec3 axisX  = normalize(worldX - dot(worldX, planeNormal) * planeNormal);\n    vec3 axisY  = normalize(cross(planeNormal, axisX));\n\n    vec3 diff = pt - planePos; \n    float u = dot(diff, axisX);\n    float v = dot(diff, axisY);\n    \n    return mod(floor(u * 0.5) + floor(v * 0.5), 2.0) < 1.0  ? planeCol1 : planeCol2;\n\n}\n\nvec3 getObjectColorAtPoint(int objectId, vec3 pt, out Material objectMat){\n\tif (objectId == sphereId)\n    {\n        objectMat = sphereMat;\n        return getSphereColorAtPoint(pt);\n    }\n    else if (objectId == planeId)\n    {\n        objectMat = planeMat;\n        return getPlaneColorAtPoint(pt);\n    }\n        \n    return skyCol;\n}\n\nfloat getShadowFactorAtPoint(vec3 I, vec3 N, Material objectMat, vec3 L, float Ldist){\n\tfloat shadow;\n    int objectId;\n    vec3 intersectI;\n    vec3 normalI;\n    float nearest = computeNearestIntersection(I,L,objectId,intersectI,normalI);\n    if (nearest <= Ldist && nearest>0.0){\n        shadow = objectMat.Ka;\n    }else{\n        shadow = 1.0;\n    }    \n   return shadow;\n}\n\nvoid AnimateScene(float time){\n    // Animate the sphere position\n    const float pi           = 3.1415926535;\n    const float rs           = 2.0;\n    const float spr          = 5.0;\n    float       as           = 2.0 * pi * time / spr;\n\t    // NOTE: at time=0, the sphere position is the same than the default one defined at\n    \t//       the top of this source code.\n    spherePos = cameraTarget + rs * vec3(-sin(as), 0.0, cos(as)) + vec3(0,1,0);\n    \n    // Animate the light position\n    // NOTES: - light will move up and down from height of 1 to 20.\n    //        - again we made our formula so that the position is the default one at time=0.\n    lightPos += vec3(0, 10.5 + 9.5 * cos(time) - 10., 0);\n    \n    // Animate the camera\n    // NOTE: again we made our formula so that the position is the default one at time=0.\n    float targetDist = length(cameraTarget - cameraPos);\n    cameraPos -= vec3(0, 0, targetDist);\n    cameraPos += targetDist*vec3(sin(time),max(sin(time*0.5),0.),cos(time));\n}\n\nvec2 noise2 (vec2 location,  vec2 delta){\n    const vec2 c = vec2(12.9898, 78.233);\n    const float m = 43758.5453;\n\treturn vec2(\n        fract(sin(dot(location + delta , c)) * m),\n        fract(sin(dot(location + vec2(delta.y, delta.x), c)) *m)\n    );\n}\n    \nvec3 RaycastAtPixelCoord(vec2 pixCoord){\n    //compute the ray to be casted through the pixel towards the 3D scene\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(pixCoord, rayPos, rayDir);\n    //test ray-objects intersections and find the nearest one\n    int objectId;\n    vec3 intersecI, normalI;\n    float distI = computeNearestIntersection(rayPos, rayDir, objectId, intersecI, normalI);\n    \n    //we dis dont hit the sphere, so we have the sky color\n    if (distI <= 0.0){\n        return skyCol;\n    }\n    //apply the shading to the points that are on the sphere surface and seen by the camera\n    vec3 L = lightPos - intersecI;\n    float Ldist = length(L);\n    L = L/Ldist;\n    \n    vec3 R = 2.0 * dot(normalI, L) * normalI - L;\n    vec3 V = -rayDir;\n    Material objectMat;\n    vec3 objectCol = getObjectColorAtPoint(objectId, intersecI, objectMat);\n    \n    vec3 ptI = intersecI + normalI * 0.001;    \n    float shadowFactor = getShadowFactorAtPoint(ptI, normalI, objectMat, L, Ldist);\n    vec3 resCol = computePhongShading(objectCol, objectMat, shadowFactor, normalI, L, R, V);\n    \n    return resCol;\n}\n\nvec3 RaytraceAtPixelCoord(vec2 pixCoord){\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(pixCoord, rayPos, rayDir);\n    \n    ShadeInfo infos[MAX_NB_BOUNCES];\n    int nbBounces = 0;\n    do {\n        int objectId;\n        vec3 intersecI, normalI;\n        float distI = computeNearestIntersection(rayPos, rayDir, objectId, intersecI, normalI);\n        \n        if (distI <= 0.0){\n            infos[nbBounces].shadedCol = skyCol;\n            infos[nbBounces].Ks = 0.0;\n            break;\n        }\n        \n        \n           \n            //apply the shading to the points that are on the surface and seen by the camera\n            vec3 L = lightPos - intersecI;\n            float Ldist = length(L);\n            L = L/Ldist;\n\n            vec3 R = 2.0 * dot(normalI, L) * normalI - L;\n            vec3 V = -rayDir;\n            Material objectMat;\n            vec3 objectCol = getObjectColorAtPoint(objectId, intersecI, objectMat);\n\n            vec3 ptI = intersecI + normalI * 0.001;    \n            float shadowFactor = getShadowFactorAtPoint(ptI, normalI, objectMat, L, Ldist);\n            vec3 P = computePhongShading(objectCol, objectMat, shadowFactor, normalI, L, R, V);\n        \n            //Store the information we gathered for that surface point\n            infos[nbBounces].shadedCol = P;\n            infos[nbBounces].Ks = objectMat.Ks;\n\n            //bounce from the surface towards the reflected direction of the ray\n            rayPos = intersecI + normalI * 0.001; \n            rayDir = 2.0 * dot(normalI, V) * normalI - V;\n         \n        nbBounces++;\n    }\n    while (nbBounces < MAX_NB_BOUNCES);\n    \n    vec3 resCol = vec3(0);\n    //boucle for qui deroule la liste\n    for (int i=0; i<= nbBounces; i++){\n    \tresCol = infos[nbBounces-1-i].shadedCol + infos[nbBounces-1-i].Ks * resCol ;\n    }\n    \n    return resCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\tvec3 sum = vec3(0);\n    \n    for (int i=0;i<20;i++){\n        //fragColorList[i] = RaycastAtPixelCoord(fragCoord);\n        vec2 delta = noise2(fragCoord, vec2(i,i+1));\n        sum += RaytraceAtPixelCoord(vec2(fragCoord[0]+delta[0], fragCoord[1]+delta[1]));\n    }\n    sum = sum/20.0;\n\tfragColor = vec4(sum, 1);\n\n}","name":"Image","description":"","type":"image"}]}