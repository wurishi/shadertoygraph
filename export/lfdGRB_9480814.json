{"ver":"0.1","info":{"id":"lfdGRB","date":"1711854430","viewed":52,"name":"black and white cube plane scene","username":"akr51","description":"Finally got reflections working. Any tips would be appreciated. Feel free to steal code.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflections"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ITERATIONS 99\n#define MAXDIST    233.0\n#define SURF_DIST  0.001\n#define PI         3.14159\n#define TAU        2.0 * PI\n\nvec3 rot3(vec3 axis, vec3 p, float theta)\n{\n    return mix(dot(axis, p) * axis, p, cos(theta)) + cross(axis, p) * sin(theta);\n}\n\nfloat plane(vec3 p, vec3 n)\n{\n    return dot(p, n);\n}\n\nfloat cube(vec3 p, vec3 s)\n{\n    vec3 rp = rot3(vec3(0.0, 1.0, 0.0), p, iTime * 0.5);\n    rp = rot3(vec3(0.0, 0.0, 1.0), rp, iTime * 0.75);\n    rp = abs(rp) - s;\n    return length(max(rp, 0.0)) + min(max(rp.x, max(rp.y, rp.z)), 0.0);\n}\n\nfloat map(vec3 p)\n{\n    vec3 cdsp = vec3(0.0, 0.5, 0.0);\n    float d = cube(p - cdsp, vec3(1.0));\n    vec3 pdsp = vec3(0.0, -4.5, 0.0);\n    return min(d, plane(p - pdsp, vec3(0.0, 1.0, 0.0)));\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 d = vec2(0.001, 0.0);\n    return normalize(map(p) - vec3(map(p - d.xyy), map(p - d.yxy), map(p - d.yyx)));\n}\n\nvec3 rayd(vec2 uv, vec3 ro)\n{\n    vec3 fx = vec3(0.0);\n    float z = 1.0;\n    vec3 f, r, u, c, i;\n    f = normalize(fx - ro);\n    r = normalize(cross(vec3(0.0, 1.0, 0.0), f));\n    u = cross(f, r);\n    c = f * z;\n    return normalize(c + uv.x * r + uv.y * u);\n}\n\nfloat march(vec3 ro, vec3 rd)\n{\n    float d0 = 0.0;\n    \n    for (int i = 0; i < ITERATIONS; i++)\n    {\n        vec3 p = ro + rd * d0;\n        float ds = map(p);\n        d0 += ds;\n        if (d0 > MAXDIST || abs(ds) < SURF_DIST)\n        {\n            break;\n        }\n    }\n    \n    return d0;\n}\n\n\nfloat illuminate(vec3 p)\n{\n    \n\n    vec3 l_pos = vec3(2.0, 1.6, -0.8);\n    vec3 l = normalize(l_pos - p);\n    vec3 n = normal(p);\n    \n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    \n    float d = march(p + n * 0.02, l);\n    \n    if (d < length(l_pos - p))\n    {\n    \n    \n        dif *= 0.1;\n    \n    }\n    \n    return dif;\n\n}\n\n\n\nvec3 trace(vec3 ro, vec3 rd)\n{\n    vec3 color = vec3(0.0);\n    vec3 accumulatedColor = vec3(0.0);\n    vec3 accumulatedReflection = vec3(1.0);\n\n    for (int i = 0; i < 3; i++)\n    {\n        float d = march(ro, rd);\n        \n        if (d < MAXDIST)\n        {\n            vec3 p = ro + rd * d;\n            vec3 n = normal(p);\n            vec3 reflectionRay = reflect(rd, n);\n            \n            // Attenuate reflection\n            accumulatedReflection *= 0.5;\n            \n            ro = p + 0.01 * reflectionRay;\n            rd = reflectionRay;\n            \n            float dif = illuminate(p);\n            color += accumulatedReflection * vec3(dif);\n        }\n        else\n        {\n            break;\n        }\n    }\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 c, in vec2 u )\n{\n    vec2 r = iResolution.xy, uv = (u + u - r) / r.y;\n    vec3 ro = vec3(0.0, 3.0, -3.0);\n    vec3 rd = rayd(uv, ro);\n    vec3 color = trace(ro, rd);\n    c = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}