{"ver":"0.1","info":{"id":"WssBW7","date":"1588396529","viewed":205,"name":"IceWalker","username":"antoinefortin","description":"Ice","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["ice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define HALFPI 1.57079632679\n#define farClipPlane 35.\n#define nearClipPlane 0.001\n#define normalEpsilon 0.0021\n\nvec2 rotate(vec2 pos, float angle)\n{\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    \n    return mat2(c,s,-s,c) * pos;\n\n}\n\n\n\nfloat plane(vec3 pos)\n{\t\n    \n    vec3 q = pos;\n    \n\treturn q.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + .25;\n    \n  p.xz =abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2  ) * sign(max(q.z,-p.y));\n}\n\n\nvec2 sdObj1(vec3 pos)\n{\n    \n    /*\n\tpos.y -= 4.;\n    pos.xz = rotate(pos.xz, iTime);\n    pos.yz = rotate(pos.yz, iTime * 0.5);\n    float d = sdBox(pos, vec3(2.0));\n\t*/\n     \n    \n    vec3 q = pos;\n   \n    q.z = mod(q.z+ 5.0, 10.) -5.;\n\tq.x = mod(q.x+ 2.5, 5.) -2.5;\n  \n   \t//q.xy = rotate(q.yz, iTime * sin(iTime * .005));\n    \n    /*\n    q.xz = rotate(q.xz, iTime);\n\tq.xz = rotate(q.xz, iTime);\n    q.xz = rotate(q.xz, iTime);\n\t*/    \n   \t//q.xy = rotate(q.xy,);\n    \n    float cp1 = 2.0;\n    q.y -= cp1;\n\tq.yz = rotate(q.yz, iTime);\n    q.xz = rotate(q.xz, iTime * 2.);\n    \n    float p1 = sdPyramid(q,1.);\n    q.xy = rotate(q.xy, 3.1415);\n   \t\n    q.xz = rotate(q.xz, iTime * 2.);\n    float p2 = sdPyramid(q,1.);\n    \n    ;\n    float d  = min(p1, p2);\n    \n    vec2 res = vec2(d, 12.0);\n    \n    return res;\n}\n\nfloat sphere(vec3  pos, float radius)\n{\t\n    pos.y -= 4.0;\n    return length(pos) - radius;\n}\n\nvec2 map(vec3 pos)\n{\n    \n    //float d2 = plane(pos);\n    vec2 d1 = sdObj1(pos);\n    float d2 = pos.y; \n    \n    \n    \n    return (d2 < d1.x) ? vec2(d2, 1.0) : d1;\n    \n}\n\nvec2 castRay(vec3 ro, vec3 rd)\n{\t\n    float m = -1.0;\n    float t = 0.0;\n    for(int i = 0; i < 256; i++)\n    {\n    \tvec3 pos = ro + t * rd;\n        \n        vec2 h = map(pos);\n        \n        m = h.y;\n        if(h.x < 0.001)\n        {\n        \tbreak;\n        }\n        t += h.x;\n        \n        if(t > farClipPlane) break;\n        \n    }\n    \n    if(t > farClipPlane) m = -1.0;\n    \n    return vec2(t,m);\n}\n\n\n\nvec3 computeNormal(vec3 pos)\n{\n    vec2 eps = vec2(0.1, 0.0);\n    return normalize(vec3(\n        map(pos + eps.xyy).x - map(pos - eps.xyy).x,\n        map(pos + eps.yxy).x - map(pos - eps.yxy).x,\n        map(pos + eps.yyx).x - map(pos - eps.yyx).x\n    ));\n}\n\nvec3 material(vec3 pos)\n{\n    return vec3(smoothstep(0.4, 0.41, fract(pos.x + sin(pos.z * 0.4 + iTime))));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    vec2 uv = (fragCoord -.5 * iResolution.xy) / iResolution.y;\n    \n    \n\tif(uv.y < 0.)\n    {\n    \tvec2 p = vec2(uv);    \n        float ba = texture(iChannel0, p * 1.).x;    \n        \n        ba *= .5 * 2.;\n    \tuv.y = abs(uv.y * 1.5) * ba ;\n        uv.y += sin(uv.y);\n    }\n    \n    \n   // uv.y = abs(uv.y);\n\t//uv.x = abs(uv.x);\n    float angle = iTime;\n    \n    vec3 ro = vec3(iTime + abs(sin(iTime)), 1.0, iTime *5.5);\n    \n    // Rayon que l'on envoie dans l'espace pour chacuns des pixels\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));    \n    \n    \n\n     vec3 col = vec3(0.4, 0.75, 1.0) - 0.7 * rd.y;\n               \n\tvec2 tm = castRay(ro, rd);\n\n\t\t// If material is positive\n        if(tm.y > 0.)\n        {\n\t\t\t\n\n            float t = tm.x;\n            vec3 pos = ro + t * rd;\n            vec3 nor = computeNormal(pos);\n            vec3 sunPosition = vec3(1.,12.,-12.);\n            vec3 sundir = normalize(sunPosition);\n            vec3 mate = vec3(.15);\n\n\n            float sundif = clamp(dot(nor, sundir), 0.0, 1.0);\n            float sun_sha = smoothstep(castRay(pos + nor * 0.001, sundir).y, 0.0, 1.0);\n            float sky_dif = clamp(0.5 + 0.5 * dot(nor,vec3(0.0,1.0,0.0)), 0.0, 1.0);\n            float bou_dif = clamp(0.5 + 0.5 *dot(nor,vec3(0.0,-1.0,0.0)), 0.0, 1.0);\n\n            col = mate * vec3(t * 0.5, t * 0.25, 1.0) * (sundif) * sun_sha;\n            col += mate * vec3(0.0075, 0.0008, 0.09) * sky_dif;\n            col += mate * vec3(0.075, 0.003, 0.02) * bou_dif;\t\n            \n            //col *= 1.25;\n\t\t\t// Floor material\n           \tif(tm.y == 1.0)\n            {\n                \n            \tcol += vec3(.24, 0.8,.5);\n                float f = sin(5.0 * pos.x) * sin(5.0 * pos.z);\n                col += f;\n            }\n            // Cube Material\n            if(tm.y == 12.0)\n            {\n                \n                //col = vec3(smoothstep(0.4, 0.241, fract(pos.x + sin(pos.y * 0.4 + iTime))));\n            \t//col = mate;\n                col += mate;\n                col += (sky_dif * mate);\n            }\n            \n            \n            \n        }\n\n    \n    \t//vec3 depth = castRay(ro,rd).x;\n\t\n    // Calculation de fog biwn ghetto (Plus c'est loin plus ces tdark)\n\t// float fog = 1.0 / (1.0 + depth.x * depth.x * 0.1);\n\t\n    //frag color\n    float t = castRay(ro, rd).x;\n    \n    float fog = 1.0 / t;\n    \n    vec3 fogc = vec3(0.0, 0.0, (sin(iTime) + 2. ) / 2.) * fog;\n    \n    // Output to screen\n    fragColor = vec4(sqrt(col), 1.0);\n}","name":"Image","description":"","type":"image"}]}