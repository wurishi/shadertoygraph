{"ver":"0.1","info":{"id":"Md2yWh","date":"1491933559","viewed":476,"name":"Tileable noise","username":"noby","description":"A quick utility for creating procedural noise textures that tile decently.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["fractal","noise","fbm","tileable","tile"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// License: use however and where ever you like,\n// but I'd appreciate a credit or mention somewhere :)\n\nfloat hash(vec2 p){\n    // thanks dave\n\tvec3 p3  = fract(vec3(p.xyx) * 0.1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nconst vec2 add = vec2(1.0, 0.0);\nfloat noise(vec2 x){\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float res = mix(mix(hash(p),          hash(p + add.xy),f.x),\n                    mix(hash(p + add.yx), hash(p + add.xx),f.x),f.y);\n    return res;\n}\n\nfloat fnoise(vec2 uv){\n    // thanks iq\n    float f = 0.0;\n\tmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf  = 0.5000*noise( uv ); uv = m*uv;\n\tf += 0.2500*noise( uv ); uv = m*uv;\n\tf += 0.1250*noise( uv ); uv = m*uv;\n\tf += 0.0625*noise( uv ); uv = m*uv;\n    return f;\n}\n\nconst float f = 0.5*(1.0+sqrt(2.0));\nfloat repeat;\nfloat lerpx(vec2 uv){\n    // replace fnoise() with your own function\n    float v = fnoise(uv+vec2(-repeat*0.5,0))*((uv.x)/repeat);\n          v +=fnoise(uv+vec2( repeat*0.5,0))*((repeat-uv.x)/repeat);\n    // overlaying non-correlated noise reduces variance around repetition edges\n    // factor f scales it back\n    return mix(v, f*pow(v, f), 4.0*((uv.x)/repeat)*((repeat-uv.x)/repeat));\n}\n\nfloat lerpy(vec2 uv){\n    float v = lerpx(uv+vec2(0,-repeat*0.5))*((uv.y)/repeat);\n          v +=lerpx(uv+vec2(0, repeat*0.5))*((repeat-uv.y)/repeat);\n    // same scaling in y dimension\n    return mix(v, f*pow(v, f), 4.0*((uv.y)/repeat)*((repeat-uv.y)/repeat));\n}\n\nvec3 noisetile(vec2 uv){\n    // clamp probably not (and shouldn't be) needed but anyway\n    return vec3(clamp(lerpy(uv), 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // \"consts\" for size and repeatition\n    const float scale = 49.0;\n    float rc = 2.0+1.5*sin(iTime*0.13);\n    float sc = 1.5+0.9*cos(iTime*0.08);\n    if(iMouse.z > 0.0)\n    {\n        rc = iMouse.x/iResolution.x;\n        sc = iMouse.y/iResolution.y;\n    }\n    repeat = 2.0+(scale-1.0)*pow(rc, 2.0);\n    float size = 1.0+scale*pow(sc, 2.0);\n    \n    // coords, repeat\n\tvec2 uv = -1.0+2.0*fragCoord.xy / iResolution.xy;\n    uv = mod(uv*size, repeat);\n    \n    fragColor.rgb = noisetile(uv);\n}","name":"Image","description":"","type":"image"}]}