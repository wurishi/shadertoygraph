{"ver":"0.1","info":{"id":"Xd3yDX","date":"1520332211","viewed":366,"name":"Penrose Triangle","username":"Ultraviolet","description":"A simple Penrose triangle using the beam cutting technique.\nClick to move cam.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["triangle","illusion","penrose"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI\t\t\t\t3.1415926535\n#define ABSORBANCE\t\t1.0\n//#define LIGHT_DIR\t\tnormalize(vec3(cos(-iTime*.3+PI*.5), 1.0, sin(-iTime*.3+PI*.5)))\n#define LIGHT_DIR\t\tnormalize(vec3(1., 2., 1.))\n//#define CAM_POS \t\tvec3(4.*cos(-iTime*.3), 4.0, 4.*sin(-iTime*.3))\n\n#define CAM_PARAM\t\tsmoothstep( 0., 1., max(mod(iTime*.2, 1.)-.8, 0.)*5.)\n#define CAM_POS \t\tvec3(2./sqrt(2.)*1.5*cos(CAM_PARAM*2.*PI+PI*.25), 1.5, 2./sqrt(2.)*1.5*sin(CAM_PARAM*2.*PI+PI*.25))\n\n#define AA\t\t4.\n\n\n//from https://iquilezles.org/articles/boxfunctions\nvec2 boxIntersection( vec3 ro, vec3 rd, \n                      vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN > tF || tF < 0.0) return vec2(-1.0); // no intersection\n    \n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    return vec2( tN, tF );\n}\n\n// simple shapes combination\nvec2 intersectBeam(vec3 ro, vec3 rd, out vec3 n)\n{\n    float d = 1000.;\n    \n    vec3 n1, n2, n3;\n    \n    float dist = 0.7;\n    float dist2 = 0.1;\n        \n    vec3 pos = .5*dist*vec3(-.5, 0.5, -1.5);\n    \n    vec2 res1 = boxIntersection(ro-vec3(dist-dist2, 0., 2.*dist-2.*dist2) -pos, rd, vec3(dist, dist2, dist2), n1);\n    if(res1.x>0.)\n    {\n        vec3 oo = vec3(-dist2, -dist2, dist2)+pos;\n        vec3 nn = normalize(vec3(1., 0., -1.));\n        \n    \tfloat dd = dot(oo-ro, nn)/dot(rd,nn);\n        \n        \n        if(dot(nn, ro+rd*res1.x-oo)<0.)\n        {\n            d = res1.x;\n            n=n1;\n        }\n        else if(dd>res1.x && dd<res1.y)\n        {\n            d = dd;\n            n = nn;\n        }\n    }\n    \n    vec2 res2 = boxIntersection(ro+vec3(0., dist-dist2, 0.)-pos, rd, vec3(dist2, dist, dist2), n2);\n    if(d>res2.x && res2.x>0.)\n    {\n        d = res2.x;\n        n=n2;\n    }\n    \n    vec2 res3 = boxIntersection(ro-vec3(0., 0., dist-dist2)-pos, rd, vec3(dist2, dist2, dist), n3);\n    if(d>res3.x && res3.x>0.)\n    {\n        d = res3.x;\n        n=n3;\n    }\n    \n    return vec2(d, max(0., dot(n, LIGHT_DIR)));\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 col = .6+.4*vec3(pow(max(0., dot(rd, LIGHT_DIR)), 2.));\n    \n    vec3 n;\n    \n    vec2 i = intersectBeam(ro, rd, n);\n    \n    if(i.x>0. && i.x<10.)\n    {\n        col = (.2+.8*max(0., dot(n, LIGHT_DIR))) * (.2+.8*abs(n));\n    }\n        \n    return col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/ iResolution.y;\n        \n    // mouse camera control\n    float phi = (iMouse.x-0.5)/iResolution.x * PI * 2.0;\n    float psi = -((iMouse.y-0.5)/iResolution.y-0.5) * PI;\n    \n    if(iMouse.x<1.0 && iMouse.y < 1.0)\n    {\n        phi = iTime * PI * 2.0*0.1;\n        psi = cos(iTime*PI*2.0*0.1)*PI*0.25;\n    }\n    \n    // ray computation\n    vec3 ro = 2.6*vec3(cos(phi)*cos(psi), sin(psi), sin(phi)*cos(psi));\n    if(iMouse.z < 0.5)\n        ro = CAM_POS;\n    \n    vec3 ta = vec3(0.);\n    mat3 m = setCamera(ro, ta, 0.0);\n    vec3 rd = m*normalize(vec3(p, 2.));\n    \n    ro = 2.*ro + m[0]*p.x + m[1]*p.y;\n    rd = m[2];\n    \n    // scene rendering (using oversampling)\n    vec3 col;\n    \n    \n    //for(float ii=-AA/2.+.5; ii<AA/2.; ii+=1.)\n    //for(float jj=-AA/2.+.5; jj<AA/2.; jj+=1.)\n    for(float ii=0.; ii<AA; ii+=1.)\n    for(float jj=0.; jj<AA; jj+=1.)\n    {\n    \tcol += render( ro, rd+(m[0]*ii+m[1]*jj)/AA/iResolution.y/2.);\n    }\n    col /= AA*AA;\n    \n    // gamma correction\n    col = sqrt(col);\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}