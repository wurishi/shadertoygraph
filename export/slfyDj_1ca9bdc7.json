{"ver":"0.1","info":{"id":"slfyDj","date":"1650301148","viewed":26,"name":"Expérimentation 3D Tex","username":"HanoRobelthon","description":"Expérimentation en 3D","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["lifgraphique"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n//=====Structure=====//\n\nObjet colonne(in vec3 pos, in float height, in float width, in vec3 point) {\n    Objet res = cylindre(pos, vec3(0, 1, 0), height, width*0.8, point, WHITE, vec3(0), vec3(0));\n    \n    vec3 p = abs(point);\n    p.y = point.y;\n    \n    float angle = -PI * 0.5 / 2.;\n    \n    for(int i = 0; i <= 2; i++) {\n        vec3 pp = rotaY(p, angle * float(i), vec3(0));\n        res = opP(res, cylindre(vec3(width*0.8, 0, 0), vec3(0, 1, 0), 0.15 * width, pp, WHITE, vec3(0), vec3(0)));\n    }\n    \n   \n    p.y= abs(point.y + height * 0.65);\n    p = translat(p, vec3(0, height * 0.4, 0));\n    res = opU(res, box(vec3(0, 0, 0), vec3(height * 0.4, height * 0.1, height * 0.4), p, WHITE, vec3(0), vec3(0)));\n    \n    return res;\n}\n\nObjet bonhommeDeNeige(in vec3 pos, in float size, in vec3 point) {\n    vec3 body = pos + vec3(0,  size, 0);\n    vec3 head = pos + vec3(0, 2.3 * size, 0);\n    \n    return opU(\n        opU(\n            sphere(body, size, point, WHITE, vec3(0), vec3(0)),\n            sphere(head, 0.60 * size, point, WHITE, vec3(0), vec3(0))\n        ),\n        opU(\n            opU(\n                cone(head + vec3(0, 0, -0.58 * size), head + vec3(0, 0, -size * 1.2), size / 8.f, 0., point, RED, vec3(0), vec3(0)),\n                tore(head + vec3(0, size * 1.f, 0), vec3(0, 1, 0), 0.5 * size, 0.1 * size, point, BLUE, vec3(0), vec3(0))\n            ),\n            opU(\n                gellule(body + vec3(size * 0.5, 0, 0), body + vec3(size * 2.f, size * 0.75, 0), size * 0.05, point, WHITE, vec3(0), vec3(0)),\n                gellule(body + vec3(-size * 0.5, 0, 0), body + vec3(-size * 2.f, size * 0.75, 0), size * 0.05, point, WHITE, vec3(0), vec3(0))\n            )\n        )\n    );\n}\n\nObjet piseTop(in float height, in float width, in vec3 point, in int iTex) {\n    float epaisseur = 5.;\n    float voute_level = height * 0.75;\n    \n    //\n    Objet res = tube(vec3(0, 0, 0), vec3(0, 1, 0), height, width, epaisseur, point, iTex, vec3(0), vec3(0));\n    \n    //couronne étage\n    res = opU(res, cylindre(vec3(0, 0, 0), vec3(0, 1, 0), height * 0.05, width * 1.6, point, iTex, vec3(0), vec3(0)));\n    \n    //couronne toit\n    res = opU(res, tube(vec3(0, height, 0), vec3(0, 1, 0), height * 0.05, width * 1.05, epaisseur * 1.1, point, iTex, vec3(0), vec3(0)));\n    \n    //couronne sous voute\n    res = opU(res, tube(vec3(0, voute_level - height * 0.02, 0), vec3(0, 1, 0), height * 0.02, width * 1.04, epaisseur * 1.1, point, iTex, vec3(0), vec3(0)));\n    \n    //On envoie le point dans le quart + + du plan xz\n    vec3 p = abs(point);\n    p.y = point.y;\n    \n    \n    int nbCol = 3;\n    float angle = -(PI * 0.5) / float(nbCol);\n    vec3 pp;\n    \n    \n    \n    vec3 baseCol = vec3(width, 0, 0);\n    Objet supr_voute = Objet(1000., 0, vec3(0), vec3(0));\n    \n    for(int i = 0; i <= nbCol; i++) {\n        //on aura 3 division de quart de cercle\n    \n        pp = rotaY(p, angle * float(i), vec3(0, 0, 0));\n        if(i%3 != 0) {//Ne pas mettre la colonne centrale\n            res = opU(res, cylindre(baseCol, vec3(0, 1, 0), voute_level, width * 0.03 / 0.6, pp, iTex, vec3(0), vec3(0)));\n        }\n        else if(i%3 == 0) {\n            res = opP(res, box(baseCol + vec3(0, height * 0.3, 0), vec3(epaisseur * 1.5, width * 0.3, width * 0.3), pp, iTex, vec3(0), vec3(0)));\n            res = opP(res, cylindre(baseCol + vec3(0, height * 0.3 + width * 0.3, 0), vec3(1, 0, 0), width*0.3, pp, iTex, vec3(0), vec3(0)));\n        }\n        \n        res = opU(res, box(baseCol + vec3(0, voute_level - 0.5, 0), vec3(1, 0.5, 1), pp, iTex, vec3(0), vec3(0)));\n        \n        pp = rotaY(pp, angle * 0.5, vec3(0, 0, 0));\n        supr_voute = opU(supr_voute, cylindre(baseCol + vec3(0, voute_level, 0), vec3(1, 0, 0), width * .18, pp, RED, vec3(0), vec3(0)));\n        \n        if(i%3 == 1) {\n            res = opP(res, box(baseCol + vec3(0, voute_level - width * .295, 0), vec3(epaisseur * 1.5, width * .3, width * .18), pp, iTex, vec3(0), vec3(0)));\n        }\n    }\n    supr_voute = opI(supr_voute,\n        demiEspace(vec3(0, voute_level, 0), vec3(0, -1, 0), point, iTex, vec3(0), vec3(0))\n    );\n    res = opP(res, supr_voute);\n    \n    \n    return res;\n}\n\nObjet etage(in float height, in float width, in vec3 point, in int iTex) {\n    float separation_height = height * 0.05;\n\n //tour centrale\n    Objet res = cylindre(vec3(0, 0, 0), vec3(0, 1, 0), height, width * 0.8, point, iTex, vec3(0), vec3(0));\n    \n //couronne étage\n    res = opU(res, cylindre(vec3(0, 0, 0), vec3(0, 1, 0), separation_height, width, point, iTex, vec3(0), vec3(0)));\n    \n //colonnes\n    \n    //On envoie le point dans le quart + + du plan xz\n    vec3 p = abs(point);\n    p.y = point.y;\n    \n    int nbCol = 6;\n    float angle = -(2. * PI) / (float(nbCol) * 4.);\n    float col_height = height * 0.56;\n    float bloc_height = height * 0.05;\n    \n    float voute_level = separation_height + 3. * bloc_height + col_height;\n    float voute_height = height - voute_level + 2. * bloc_height;\n    \n    vec3 baseCol = vec3(width * 0.9, separation_height, 0);\n    \n    //voute\n    Objet supr_voute = tube(vec3(0, voute_level, 0), vec3(0, 1, 0), voute_height, width * 0.9 + bloc_height, bloc_height * 2., point, iTex, vec3(0), vec3(0));\n    \n    for(int i = 0; i<=nbCol; i++) {\n     //colonne\n       vec3 pp = rotaY(p, angle * float(i), vec3(0, 0, 0));\n       res = opU(res, cylindre(baseCol + vec3(0, bloc_height, 0), vec3(0, 1, 0), col_height, width * 0.03, pp, iTex, vec3(0), vec3(0)));\n       res = opU(res, box(baseCol, vec3(bloc_height), pp, iTex, vec3(0), vec3(0)));\n       res = opU(res, box(baseCol + vec3(0, col_height + bloc_height * 2., 0), vec3(bloc_height), pp, iTex, vec3(0), vec3(0)));\n     //voutes\n       pp = rotaY(pp, angle * 0.5, vec3(0, 0, 0));\n       \n       supr_voute = opP(supr_voute,\n           cylindre(baseCol + vec3(-1., voute_level - bloc_height, 0), vec3(1, 0, 0), voute_height * 0.4, pp, iTex, vec3(0), vec3(0)));\n    }\n    res = opU(res, supr_voute);\n    \n    return res;\n}\n\nObjet rdc(in float height, in float width, in vec3 point, in int iTex) {\n    //le demi espace permet de résoudre un problème à la jonction entre rdc et étages\n    Objet res = demiEspace(height + vec3(0, .01, 0), vec3(0, 1, 0), point, iTex, vec3(0), vec3(0));\n    \n    int nbCol = 3;\n    float angle = -(2. * PI) / (float(nbCol) * 4.);\n    \n    //On envoie le point dans le quart + + du plan xz\n    vec3 p = abs(point);\n    p.y = point.y;\n    \n    float col_height = height * 0.56;\n    float bloc_height = height * 0.04;\n    \n    float voute_level = col_height + 2. * bloc_height;\n    float voute_height = height - voute_level;\n    \n    vec3 baseCol = vec3(width * 0.92, 0, 0);\n    \n    //tour centrale\n    res = cylindre(vec3(0, 0, 0), vec3(0, 1, 0), height, width * 0.9, point, iTex, vec3(0), vec3(0));\n    \n    //voutes\n    Objet supr_voute = cylindre(vec3(0, voute_level - .6 * bloc_height, 0), vec3(0, 1, 0), voute_height + .6 * bloc_height, width * 0.9 + bloc_height * .75, point, iTex, vec3(0), vec3(0));\n    \n    \n    for(int i =0; i<=nbCol; i++) {\n      //colonne\n       vec3 pp = rotaY(p, angle * float(i), vec3(0, 0, 0));\n       \n       res = opU(res, cylindre(baseCol + vec3(0, bloc_height, 0), vec3(0, 1, 0), col_height, width * 0.05, pp, iTex, vec3(0), vec3(0)));\n       res = opU(res, box(baseCol, vec3(bloc_height), pp, iTex, vec3(0), vec3(0)));\n       res = opU(res, box(baseCol + vec3(0, col_height + bloc_height * 1.4, 0), vec3(bloc_height, bloc_height * 0.4, bloc_height), pp, iTex, vec3(0), vec3(0))); \n       \n      //voutes\n       pp = rotaY(pp, angle * 0.5, vec3(0, 0, 0));\n       \n       supr_voute = opP(supr_voute,\n           cylindre(baseCol + vec3(-1., voute_level - bloc_height, 0), vec3(1, 0, 0), voute_height * 0.4, pp, iTex, vec3(0), vec3(0)));\n    }\n    \n    res = opU(res, supr_voute);\n    \n    return res;\n}\n\nObjet pise(in float height, in vec3 point, in int iTex) {\n    Objet res;\n    int nb_etage = 6;\n\n    //étage   haut <--------------------> bas\n    //ratio pise: 1.5, 1, 1, 1, 1, 1, 1, 2\n    float ratio_height = height / 9.5;\n    float top_height = 1.5 * ratio_height;\n    float rdc_height = 2. * ratio_height;\n    float etage_height = ratio_height;\n    \n    float width = height * 0.3 * 0.5;\n\n  //segmentation de la tour (optimisation)\n    if(length(point.xz) < width + 0.5) { //Si le point testé est à l'intérieur d'un cylindre autour de la tour\n\n//Rez de chaussée---------------------------------------------------------------------------------------------------------\n        if(point.y <= rdc_height) { \n            res = rdc(rdc_height, width, point, iTex);\n        }\n//Etages---------------------------------------------------------------------------------------------------------\n       else if(point.y > rdc_height && point.y <= rdc_height + float(nb_etage) * etage_height) { \n            vec3 p = point;\n            p.y = (point.y - rdc_height); //ramène le point à sa hauteur par rapport au bas d'un étage\n            int rep = int(p.y / etage_height); // |coorespond au modulo\n            p.y -= float(rep) * etage_height;  // |\n\n            //l'union avec un demi espace permet de résoudre un problème à la jonction des répétitions\n            res = opU(etage(etage_height, width, p, iTex),\n                    demiEspace(vec3(0, etage_height + 0.1, 0), vec3(0, -1, 0), p, iTex, vec3(0), vec3(0))\n            );\n        }\n//Top---------------------------------------------------------------------------------------------------------\n        else if(point.y > rdc_height + float(nb_etage) * etage_height) { \n            res = piseTop(top_height, width * 0.6, point - vec3(0, height - top_height, 0), iTex);\n        }\n\n    }\n//Sinon calculer la distance au cylindre\n    else {\n        res = Objet(length(point.xz) - width, WHITE, vec3(0), vec3(0));\n    }\n    return res;\n}\n\nObjet penguin(in vec3 pos, in float size, in vec3 point) {\n    //corps\n    Objet res = opULisse(\n        sphere(pos + vec3(0, size, 0), size, point, BLACK, vec3(0), vec3(0)),\n        sphere(pos + vec3(0, size * 2.7, 0), size * 0.75, point, BLACK, vec3(0), vec3(0)),\n        size * 3.\n    );\n    //yeux\n    res = opU(res, sphere(pos + vec3(size * 0.5, size*2.8, -size*0.8), size*0.12, point, GREEN, vec3(0), vec3(0)));\n    res = opU(res, sphere(pos + vec3(-size * 0.5, size*2.8, -size*0.8), size*0.12, point, GREEN, vec3(0), vec3(0)));\n    //bec\n    vec3 p = scale(point, vec3(4, 1.3, 1), pos + vec3(0, size*2.7, -size*1.7));\n    res = opU(res, cone(pos + vec3(0, size*2.7, -size*1.7), pos + vec3(0, size * 2.7, -size * 0.7), size * 0.03, size * 0.1, p, ORANGE, vec3(0), vec3(0)));\n    //pattes\n    p = scale(point, vec3(5, 1, 1), pos + vec3(size *0.5, size*0.1, -size*1.));\n    res = opU(res, cone(pos + vec3(size * 0.5, size*0.1, -size*1.), \n                        pos + vec3(size * 0.5, size * 0.1, size*0.2), \n                        size * 0.09, size * 0.01, p, ORANGE, vec3(0), vec3(0)));\n                        \n    p = scale(point, vec3(5, 1, 1), pos + vec3(-size *0.5, size*0.1, -size*1.));\n    res = opU(res, cone(pos + vec3(-size * 0.5, size*0.1, -size*1.), \n                        pos + vec3(-size *0.5, size * 0.1, size*0.2), \n                        size * 0.09, size * 0.01, p, ORANGE, vec3(0), vec3(0)));\n    //ventre\n    p = scale(point, vec3(2, 3, 1), pos + vec3(0, size, 0));\n    res = opU(res, sphere(pos + vec3(0, size*1.1, -size*0.85), size * 0.33, p, WHITE, vec3(0), vec3(0)));\n    \n    //ailes\n    p = scale(point, vec3(2, 10, 5), pos + vec3(-size, size * 1.5, 0));\n    res = opU(res, sphere(pos + vec3(-size, size * 1.5, 0), size * 0.1, p, BLACK, vec3(0), vec3(0)));\n    \n    p = scale(point, vec3(2, 10, 5), pos + vec3(size, size * 1.5, 0));\n    res = opU(res, sphere(pos + vec3(size, size * 1.5, 0), size * 0.1, p, BLACK, vec3(0), vec3(0)));\n    \n    \n    return res;\n}\n\nObjet tas_de_sable(vec3 pos, float size, vec3 point) {\n    Objet res;\n    \n    vec3 p = point + vec3(0, 5. * (cos((point.x ) * 0.1) + cos((point.z + 20.) * 0.1)), 0);\n    res = field(p, 5, 5., 32., SABLE, pos, vec3(0));\n    \n    res.dist += distance(pos, p) * 0.2;\n    res.dist /= sqrt(2.) / 0.2;\n    \n    res = opI(res,\n            sphere(pos, size, point, WHITE, vec3(0), vec3(0)));\n    \n    return res;\n\n}\n\n//=====Code=====//\n\n//1: Saint-Homme Neige\n//2: Bille qui roule\n//3: Tests\n//4: Pise\n//5: Pingouin\n//6: Materiau\n\n#define RENDERED_WORLD 6\n\n\nObjet World(in vec3 point) {\n    vec3 p;\n    switch(RENDERED_WORLD) {\n    case 1:\n        return opU(\n           colonne(vec3(0, -14, 0), 12.f, 6.f, point),\n          opU(\n              bonhommeDeNeige(vec3(0, -3, 0), 4.f, point)\n              ,demiEspace(vec3(0, -14, 0), vec3(0, 1, 0), point, WHITE, vec3(0), vec3(0))//-14\n          )\n        );\n        break;\n    case 2:\n        Objet res;\n        float planche_angle = -PI * 0.08;\n        \n        float bille_perimetre = 2. * PI * 5.;\n        \n        \n      //[ physique ]\n        vec3 bille_pos;\n        vec3 bille_speed;\n        vec3 bille_acc;\n        vec3 pente = normalize(vec3(1, tan(planche_angle), 0));\n        \n        //permet d'avoir 2 phase au mouvement: pente & sol\n        float timeReset = 0.;\n        \n        //Initialisation en haut de la planche\n        //Roule le long de la planche\n        bille_pos = vec3(-17., 16.5, 0);\n        bille_speed = vec3(0);\n        bille_acc = pente * dot(pente, vec3(0, -9.81, 0));\n        \n        float dist = 0.;\n        \n        if(iTime > 4.4) {\n            //Initialisation en bas de la planche\n            //Roule sur le sol\n            dist = updatePos(bille_pos, bille_speed, bille_acc, 4.4); //On atteint le bas de la planche à 6.8\n            \n            bille_speed = vec3(dot(bille_speed, vec3(1, 0, 0)) ,0 ,0);\n            bille_acc = vec3(-0.4, 0, 0);\n            \n            timeReset = 4.4;\n        }\n        \n        //actualise la position et récupère la distance parcouru\n        dist = updatePos(bille_pos, bille_speed, bille_acc, iTime - timeReset) + dist;\n        //calcul de combien la texture doit tourner pour correspondre au déplacement \n        float bille_rot = -(dist / bille_perimetre) * 2. * PI;\n\n        \n        \n        \n      //[ affichage ]\n        //sol\n        res = cylindre(vec3(0, -5, 0), vec3(0, 1, 0), 5., 100., point, NICE_GREEN, vec3(0), vec3(0));\n        //boite\n        res = opU(res, box(vec3(-20, 5, 0), vec3(5), point, DAMIER, vec3(-20, 5, 0), vec3(0)));\n        //planche\n        p = rotaZ(point, planche_angle, vec3(-20, 5, 0));\n        res = opU(res, box(vec3(0, 11, 0), vec3(20, 1, 7), p, BOIS, vec3(0), vec3(0, 0, planche_angle + PI * 0.5)  ));\n        //bille\n        res = opU(res, sphere(bille_pos, 5., point, ROUILLE, bille_pos, vec3(0, 0, bille_rot)));\n        //vitre\n        res = opU(res, box(vec3(0, 15, -90), vec3(20, 15, 1), point, VERRE, vec3(0), vec3(0)));\n        res = opU(res, cylindre(vec3(-23, 0, -90), vec3(0, 1, 0), 30., 3., point, BOIS, vec3(-23, 0, -90), vec3(0))); \n        res = opU(res, cylindre(vec3(23, 0, -90), vec3(0, 1, 0), 30., 3., point, BOIS, vec3(23, 0, -90), vec3(0))); \n        //marbre\n        res = opU(res, sphere(vec3(-50, 20, 50), 20., point, MARBRE, vec3(0), vec3(0)));\n        //marbre noir\n        res = opU(res, sphere(vec3(-70, 15, 15), 15., point, MARBRE_NOIR, vec3(0), vec3(0)));\n        //metal\n        res = opU(res, sphere(vec3(-80, 10, -15), 10., point, METAL, vec3(0), vec3(16. * RAD, 0, 0))); \n        \n        //tube point\n        res = opU(res, tube(vec3(50, 0, 50), vec3(0, 1, 0), 10., 20., 1., point, POINT, vec3(0), vec3(0)));\n        \n        //field sable\n        p = translat(point, vec3(0, 8, 0));\n        res = opU(res, \n            opI(field(p, 1, 2., 5., SABLE, vec3(0), vec3(0)),\n                cylindre(vec3(50, 0, 50), vec3(0, 1, 0), 15., 19., point, SABLE, vec3(0), vec3(0))\n            ));\n        \n        //Objet field(in vec3 p, in int o, in float ampl, in float lambda, in int iTex, vec3 texPos, in vec3 texAngle) {\n        return res;\n        break;\n    case 3:\n        return opU(cone(vec3(0, 0, 3), vec3(4, 9, 4), 5.f, 7.f, point, GREEN, vec3(0), vec3(0)),\n                demiEspace(vec3(0, -5, 0), vec3(0, 1, 0), point, WHITE, vec3(0), vec3(0))\n        );\n        break;\n    case 4:\n        p = rotaZ(point, 6.0 * RAD, vec3(0, 0, 0));\n        p = translat(p, vec3(0, -5, 0));\n        return opU(pise(50.f, p, MARBRE),\n                demiEspace(vec3(0), vec3(0, 1, 0), point, WHITE, vec3(0), vec3(0))\n        );\n        break;\n    case 5:\n        return opU(penguin(vec3(0, 20, 0), 5.f, point),\n            demiEspace(vec3(0, 20, 0), vec3(0, 1, 0), point, WHITE, vec3(0), vec3(0))\n        );\n        break;\n   case 6:\n       p = rotaZ(point, -30. * RAD * iTime, vec3(iTime * 3., 0, 0));\n       //return box(vec3(iTime * 3., 0, 0), vec3(10), p, MARBRE_NOIR, vec3(iTime * 3., 0, 0), vec3(0));\n       return sphere(vec3(iTime * 3., 0, 0), 40.f, p, ROUILLE, vec3(iTime * 3., 0, 0), vec3(0));\n       break;\n   case 7:\n       \n       p = point;\n       p.y = fract(point.y * .7) * 0.5;// * Noise(p * .1);\n       return opI(plan(vec3(0, -5, 0), vec3(0, 1, 0), 5.1, p, ROUILLE, vec3(100, 20, 30), vec3(0)),\n           sphere(vec3(0), 40., point, ROUILLE, vec3(0), vec3(0))\n       );\n       break;\n   }\n}\n\n\n/*\n\n\nSource:\n    https://reindernijhoff.net/2017/07/raymarching-distance-fields/\n*/\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.005;\n    return normalize(\n        e.xyy * World(p + e.xyy).dist +\n        e.yyx * World(p + e.yyx).dist +\n        e.yxy * World(p + e.yxy).dist +\n        e.xxx * World(p + e.xxx).dist);\n}\n\n\nObjet SphereTracing(in vec3 ray, in vec3 dir, in float renderDistance) {\n    float t = 1.f;\n    Objet step;\n    \n    do {\n    \n        step = World(ray + dir * t);\n        step.dist = abs(step.dist); //Gère la transparence\n        t += max(step.dist, 0.01);\n        \n    } while(step.dist > 0.01 && t < renderDistance);\n    \n    return Objet(t, step.iTex, step.texPos, step.texAngle);\n}\n\n\n\nfloat Shadow(in vec3 rayStart, in vec3 l, in float renderDistance) {\n    Objet o = SphereTracing(rayStart, l, renderDistance);\n    \n    if(o.dist < renderDistance - 0.1)\n        return 0.;\n    return 1.;\n}\n\n#define GAMMA_IN(x) pow(x, vec3(2.2))\n#define GAMMA_OUT(x) pow(x, vec3(1. / 2.2))\n\n\nvec3 castRay(inout vec3 rayPos, inout vec3 rayDir, Light light[2], float renderDistance, out float reflectance, out float transparency, in bool only_pos) {\n\n    Objet impact = SphereTracing(rayPos, rayDir, renderDistance);\n    vec3 col;\n    \n    \n    if(impact.dist < renderDistance) {\n        vec3 impactPos = rayPos + impact.dist * rayDir;\n        \n        \n        if(!only_pos) { //si on veut connaitre les informations de texture\n        \n            //On calcule les différents vecteurs\n            vec3 n = calcNormal(impactPos);\n            vec3 r = reflect(rayDir, n);\n            vec3 v = normalize(rayPos - impactPos);\n            vec3 l1 = normalize(light[0].pos - impactPos);\n            vec3 l2 = normalize(light[1].pos - impactPos);\n        \n        \n          //Rotation et translation de la texture\n            vec3 texPos = rota(impactPos, impact.texAngle, impact.texPos);\n            texPos = texPos - impact.texPos;\n\n          //On récupère la texture\n            Texture tex = Tex(texPos, impact.iTex);\n\n          \n\n\n          //speculaire\n            vec3 specCol = max(tex.col, vec3(1) - tex.col);\n            vec3 spec1 = tex.specCoeff * specCol * light[0].col * pow(max(dot(r, l1), 0.), tex.specIndex) * light[0].intensity;\n            vec3 spec2 = tex.specCoeff * specCol * light[1].col * pow(max(dot(r, l2), 0.), tex.specIndex) * light[1].intensity;\n\n\n          //diffus\n            vec3 diffus1 = tex.col * light[0].col * max(dot(n, l1), 0.) * light[0].intensity;\n            vec3 diffus2 = tex.col * light[1].col * max(dot(n, l2), 0.) * light[1].intensity;\n\n\n          //ambiant\n            vec3 ambiant = tex.col * light[0].col * light[1].col * 0.5;\n\n\n          //shadow\n            float shadow1 = Shadow(impactPos, l1, renderDistance);\n            float shadow2 = Shadow(impactPos, l2, renderDistance);\n\n\n          //Gamma correction\n          //https://developer.nvidia.com/gpugems/gpugems3/part-iv-image-effects/chapter-24-importance-being-linear\n            spec1 = GAMMA_IN(spec1);\n            spec2 = GAMMA_IN(spec2);\n            diffus1 = GAMMA_IN(diffus1);\n            diffus2 = GAMMA_IN(diffus2);\n            ambiant = GAMMA_IN(ambiant);\n\n\n          //Calcul finale\n            col = ambiant + shadow1 * (diffus1 + spec1) + shadow2 * (diffus2 + spec2);\n\n\n          //Update les paramètres pour la réflexion et/ou transparence (donnée-résultat)\n            reflectance = tex.reflectCoeff;\n            transparency = tex.transparency;\n            rayDir = r;\n        }\n        rayPos = impactPos;\n        \n        \n    }\n    else { //Trop loin\n        col = GAMMA_IN(SKY);\n        reflectance = 0.;\n        transparency = 0.;\n    }\n    \n    \n    return col;\n}\n\n#define DEBUG true\n\nvec4 render(vec3 rayPos, vec3 rayDir, Light light[2], float renderDistance) {\n    vec3 col;\n    float reflectance = 0.;\n    float transparency = 0.;\n    float NULL;\n    \n    vec3 reflectPos = rayPos;\n    vec3 reflectDir = rayDir;\n    \n  //On récupère la couleur direct de l'objet, et la positions d'impact et la direction du reflet (inout)\n    vec3 Impact = castRay(reflectPos, reflectDir, light, renderDistance, reflectance, transparency, false);\n    \n    rayPos = reflectPos;\n    \n  //Si l'objet réfléchie la lumière\n    vec3 Reflet = vec3(0);\n    if(!DEBUG && reflectance > 0.) {\n        Reflet = castRay(reflectPos, reflectDir, light, renderDistance, NULL, NULL, false);\n        col = Reflet;\n    }\n    \n    vec3 transPos = rayPos + rayDir; //Entrer dans l'objet pour la transparence\n    //vec3 transDir = rayDir;\n    \n    //rayDir = -rayDir;\n    vec3 Transparence = vec3(0);\n    if(!DEBUG && transparency > 0.) {\n        Transparence = castRay(transPos, rayDir, light, renderDistance, NULL, NULL, true);\n        transPos += rayDir;\n        Transparence = castRay(transPos, rayDir, light, renderDistance, NULL, NULL, false);\n        \n        col = mix(Reflet, Transparence, length(Reflet));\n    }\n    \n  //Couleur finale\n    col = mix(Impact, col, reflectance);\n    \n  //Gamma correction\n  //https://developer.nvidia.com/gpugems/gpugems3/part-iv-image-effects/chapter-24-importance-being-linear\n    col = GAMMA_OUT(col);\n    return vec4(col, 1.);\n}\n\n\n\n//=====Main=====//\n\n\n//Camera\nvec3 camPos = vec3(0.f, 10.f, 0.f);\n//x: verticale, y: horizontal\nvec2 camAngle = vec2(0.f, 0.f);\nvec3 camDir;\nvec3 camCross;\nvec3 camTop;\n\nfloat camDist = 105.f; //gère la distance du near field\n\nfloat renderDistance = 200.f;\nvec2 screenSize = vec2(8.f, 4.5) * 20.f; //gère l'éloignement de la caméra\n\n\n\nvoid processInput() {\n    float dx = iMouse.x - abs(iMouse.z);\n    float dy = iMouse.y - abs(iMouse.w);\n    //dx = iTime * 40.;\n    camAngle = vec2(dy * 0.005, dx * 0.01);\n}\n\nvoid processCam() {\n    camDir = vec3(       \n        cos(camAngle.x) * sin(camAngle.y),\n        sin(camAngle.x),\n        cos(camAngle.x) * cos(camAngle.y)\n    );\n    camCross = vec3(\n        sin(camAngle.y + PI * 0.5),\n        0.f,\n        cos(camAngle.y + PI * 0.5)\n    );\n    camTop = cross(camDir, camCross);\n\n    camPos += -camDir * camDist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    processInput();\n    processCam();\n\n    vec3 lightPos = vec3(50, 200, -120);\n\n    vec3 baseCoord = vec3(fragCoord.xy / iResolution.xy - 0.5, 0.f) * vec3(screenSize, 0);\n\n    vec3 rayStart = camPos + vec3(0, 0, 1) + camCross * baseCoord.x + camTop * baseCoord.y;\n\n\n    Light light[2] = Light[2](\n        Light(normalize(vec3(1, 10, 4.5)) * 1000., vec3(1., 1., 1.), 1.),\n        Light(normalize(vec3(.5, 5, -4.)) * 1000., vec3(0.5, 0.5, 0.6), .9)\n        \n    );\n    \n    \n    fragColor = render(rayStart, camDir, light, renderDistance);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926538\n#define RAD PI / 180.\n#define BLACK 0\n#define WHITE 1\n#define RED 2\n#define GREEN 3\n#define BLUE 4\n#define ORANGE 5\n#define NICE_GREEN 6\n#define NICE_PURPLE 7\n#define YELLOWISH_WHITE 8\n#define DAMIER 9\n#define POINT 10\n#define BOIS 11\n#define MARBRE 12\n#define DAMIER_DEF 13\n#define SABLE 14\n#define ROUILLE 15\n#define MARBRE_NOIR 16\n#define VERRE 17\n#define METAL 18\n\n#define SKY vec3(190. / 255., 133. / 255., 204. / 255.)\n\n\n\nstruct Objet {\n    float dist;\n    int iTex;\n    vec3 texPos;\n    vec3 texAngle;\n};\n\nstruct Texture {\n    vec3 col;\n    float specCoeff;\n    float specIndex;\n    float reflectCoeff;\n    float transparency;\n};\n\nstruct Light {\n    vec3 pos;\n    vec3 col;\n    float intensity;\n};\n\n//specCoeff, specIndex\n#define mat 0., 1., 0., 0.\n#define brillant 1., 15., 0.01, 0.\n#define transparent 0.25, 15., 0.01, 0.5\n\n\n/*\nTextures\n*/\nTexture Damier(vec3 p, float size, vec3 displacement);\nTexture DamierDef(in vec3 p, in vec2 defCoeff, in float size, in vec3 displacement);\nTexture Point(vec3 p);\nTexture Bois(vec3 p);\nTexture Marbre(vec3 p);\nTexture Sable(vec3 p);\nTexture Metal(vec3 p);\nTexture Rouille(vec3 p);\nTexture MarbreNoir(vec3 p);\nTexture Verre(vec3 p);\n\nTexture Tex(vec3 p, int iTex) {\n    switch(iTex) {\n    case BLACK: \n        return Texture(vec3(0.2, 0.2, 0.2), brillant);\n        break;\n    case WHITE: \n        return Texture(vec3(1., 1., 1.), mat);\n        break;\n    case RED: \n        return Texture(vec3(1., 0., 0.), mat);\n        break;\n    case GREEN: \n        return Texture(vec3(0., 1., 0.), brillant);\n        break;\n    case BLUE: \n        return Texture(vec3(0., 0., 1.), brillant);\n        break;\n    case ORANGE: \n        return Texture(vec3(230. / 255., 150. / 255., 40. / 255.), mat);\n        break;\n    case NICE_GREEN: \n        return Texture(vec3(134. / 255., 205. / 255., 162. / 255.), mat);\n        break;\n    case NICE_PURPLE: \n        return Texture(vec3(190. / 255., 133. / 255., 204. / 255.), mat);\n        break;\n    case YELLOWISH_WHITE: \n        return Texture(vec3(233. / 255., 210. / 255., 210. / 255.), mat);\n        break;\n    case DAMIER:\n        return Damier(p, 25., vec3(0));\n        break;\n    case DAMIER_DEF:\n        return DamierDef(p, vec2(5., 3.), 25., vec3(0));\n        break;\n    case POINT:\n        return Point(p);\n        break;\n    case BOIS:\n        return Bois(p);\n        break;\n    case MARBRE:\n        return Marbre(p);\n        break;\n    case SABLE:\n        return Sable(p);\n        break;\n    case ROUILLE:\n        return Rouille(p);\n        break;\n    case MARBRE_NOIR:\n        return MarbreNoir(p);\n        break;\n    case VERRE:\n        return Verre(p);\n        break;\n    case METAL:\n        return Metal(p);\n        break;\n    }\n}\n\n\n\n//=====Opérateurs=====//\n\n\nObjet opU(in Objet a, in Objet b) {\n    if(a.dist < b.dist)\n        return a;\n    return b;\n    //return a.dist < b.dist ? a : b;\n}\n\nObjet opI(in Objet a, in Objet b) {\n    if(a.dist > b.dist)\n        return a;\n    a.dist = b.dist;\n    return a;\n}\n\nObjet opP(in Objet a, in Objet b) {\n    if(a.dist > -b.dist)\n        return a;\n    a.dist = -b.dist;\n    return a;\n}\n\nObjet opULisse(in Objet a, in Objet b, in float r) {\n    Objet res = opU(a, b);\n    \n    float h = max(r - length(a.dist - b.dist), 0.f) / r;\n    res.dist -= (1.f/6.f) * r * h * h * h;\n    return res;\n}\n\nvec3 translat(vec3 P, vec3 dir) {\n    return P - dir;\n}\n\n\nvec3 rotaX(in vec3 P, in float angle, in vec3 orig) {\n    float cosA =  cos(-angle);\n    float sinA = sin(-angle);\n\n    mat3 xRot;\n    xRot[0] = vec3(1,  0, 0);\n    xRot[1] = vec3(0, cosA, sinA);\n    xRot[2] = vec3(0, -sinA, cosA);\n\n    P = translat(P, orig);\n    P = xRot * P;\n    return translat(P, -orig);\n}\n\nvec3 rotaY(in vec3 P, in float angle, in vec3 orig) {\n    float cosA =  cos(-angle);\n    float sinA = sin(-angle);\n\n\n    mat3 yRot;\n    yRot[0] = vec3(cosA,  0, -sinA);\n    yRot[1] = vec3(0, 1, 0);\n    yRot[2] = vec3(sinA, 0,  cosA);\n\n    P = translat(P, orig);\n    P = yRot * P;\n    return translat(P, -orig);\n}\n\nvec3 rotaZ(in vec3 P, in float angle, in vec3 orig) {\n    float cosA =  cos(-angle);\n    float sinA = sin(-angle);\n\n    mat3 zRot;\n    zRot[0] = vec3(cosA,  sinA, 0);\n    zRot[1] = vec3(-sinA, cosA, 0);\n    zRot[2] = vec3(0, 0,  1);\n\n    P = translat(P, orig);\n    P = zRot * P;\n    return translat(P, -orig);\n}\n\nvec3 rota(in vec3 P, in vec3 angle, in vec3 orig) {\n    vec3 cosA =  vec3(cos(-angle.x), cos(-angle.y), cos(-angle.z));\n    vec3 sinA = vec3(sin(-angle.x), sin(-angle.y), sin(-angle.z));\n    \n    mat3 xRot;\n    xRot[0] = vec3(1,  0, 0);\n    xRot[1] = vec3(0, cosA.x, sinA.x);\n    xRot[2] = vec3(0, -sinA.x, cosA.x);\n    \n    mat3 yRot;\n    yRot[0] = vec3(cosA.y,  0, -sinA.y);\n    yRot[1] = vec3(0, 1, 0);\n    yRot[2] = vec3(sinA.y, 0,  cosA.y);\n    \n    mat3 zRot;\n    zRot[0] = vec3(cosA.z,  sinA.z, 0);\n    zRot[1] = vec3(-sinA.z, cosA.z, 0);\n    zRot[2] = vec3(0, 0,  1);\n    \n    P = translat(P, orig);\n    P = xRot * yRot * zRot * P;\n    return translat(P, -orig);\n}\n\nvec3 scale(in vec3 P, in vec3 factor, in vec3 orig) {\n    P = translat(P, orig);\n    P /= factor;\n    return translat(P, -orig);\n}\n\n\n\n//===================//\n// Fonction de bruit //\n//===================//\n//récupéré du TP 3\n\n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in space\nfloat Hash(in vec3 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// Procedural value noise with cubic interpolation\n// x : Point \nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix(mix( Hash(i+vec3(0,0,0)), \n                        Hash(i+vec3(1,0,0)),f.x),\n                   mix( Hash(i+vec3(0,1,0)), \n                        Hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( Hash(i+vec3(0,0,1)), \n                        Hash(i+vec3(1,0,1)),f.x),\n                   mix( Hash(i+vec3(0,1,1)), \n                        Hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n\nfloat fbm(vec3 p, int octave, float ampl, float lambda) {\n    float res = 0.;\n    float div;\n    for(int i = 0; i < octave; i++) {\n        div = pow(2., float(i));\n        res += (ampl / div) * Noise(p / (lambda / div));\n    }\n    return res;\n}\n\n\n//===============//\n//               //\n//   Primitive   //\n//               //\n//===============//\n\n\n/*Liste des primitives\nObjet sphere(in vec3 centre, in float rayon, in vec3 point, in int iTex)\nObjet demiEspace(in vec3 a, in vec3 n, in vec3 point, in int iTex)\nObjet plan(in vec3 a, in vec3 n, in float e, in vec3 point, in int iTex)\nObjet box2(in vec3 c, in vec3 len, in vec3 point, in int iTex)\nObjet box(in vec3 c, in vec3 len, in vec3 point, in int iTex)\nObjet gellule(in vec3 A, in vec3 B, in float rayon, in vec3 point, in int iTex)\nObjet tore(in vec3 c, in vec3 n, in float r, in float ri, in vec3 point, in int iTex)\nObjet disque(in vec3 c, in vec3 n, in float r, in float ri, in vec3 point, in int iTex)\nObjet cylindre(vec3 point, int iTex)\nObjet cylindre(vec3 c, vec3 n, float r, vec3 point, int iTex)\nObjet cylindre(vec3 b, vec3 n, float length, float r, vec3 point, int iTex)\nObjet tube(in vec3 A, in vec3 n, float length, in float r, in float epaisseur, in vec3 point, in int iTex)\nObjet cone(in vec3 A, in vec3 B, in float radiusBottom, in float radiusTop, in vec3 point, in int iTex)\n*/\n\n/*\nParam:\n    centre: centre de la sphère\n    rayon: rayon de la sphère\n\nRésultat:\n    la coordonnée x représente la distance à la sphère paramétrée.\n*/\nObjet sphere(in vec3 centre, in float rayon, in vec3 point, in int iTex, vec3 texPos, in vec3 texAngle) {\n    return Objet(distance(centre, point) - rayon, iTex, texPos, texAngle);\n}\n\n/*\nParam:\n    a: un point à la surface du demi-espace\n    n: un vecteur normale pointant à l'extérieur de la surface\n\nRésultat:\n    la coordonnée x représente la distance au demi-espace paramétrée\n*/\nObjet demiEspace(in vec3 a, in vec3 n, in vec3 point, in int iTex, vec3 texPos, in vec3 texAngle) {\n    n = normalize(n);\n    return Objet(dot(point - a, n), iTex, texPos, texAngle);\n}\n\n/*\nParam:\n    a: un point contenu dans le plan\n    n: la normale au plan\n    e: demi-épaisseur du plan\n    \nRésultat:\n    la coordonnée x représente la distance au plan\n    \nDesc:\n    On donne une épaisseur à un plan, comme une planche infini\n*/\nObjet plan(in vec3 a, in vec3 n, in float e, in vec3 point, in int iTex, vec3 texPos, in vec3 texAngle) {\n    n = normalize(n);\n    return Objet(abs(dot(point - a, n)) - e, iTex, texPos, texAngle);\n}\n\n/*\nParam:\n    c: barycentre de la boite\n    len: longueur des côté\n    \nRésultat:\n    la coordonnée x représente la distance à une boite de barycentre c, de côté len\n    \nSource:\n    Inigo Quilez: https://www.youtube.com/watch?v=62-pRVZuS5c\n*/\nObjet box2(in vec3 c, in vec3 len, in vec3 point, in int iTex, vec3 texPos, in vec3 texAngle) {\n    return Objet(length(max(abs(point - c) - len, 0.f)), iTex, texPos, texAngle);\n}\n\n/*\nParam:\n    c: barycentre de la boite\n    len: longueur des côté\n    \nRésultat:\n    la coordonnée x représente la distance à une boite de barycentre c, de côté len\n    Fonctionne mieux avec le calcul de normal\n*/\nObjet box(in vec3 c, in vec3 len, in vec3 point, in int iTex, vec3 texPos, in vec3 texAngle) {\n    return opI(\n        opI(\n            plan(c, vec3(0, 1, 0), len.y, point, iTex, texPos, texAngle),\n            plan(c, vec3(0, 0, 1), len.z, point, iTex, texPos, texAngle)\n        ),\n        plan(c, vec3(1, 0, 0), len.x, point, iTex, texPos, texAngle)\n    );\n}\n\n\n/*\nParam:\n    A: Première extrémité du segement\n    B: Deuxième extrémité du segment\n    rayon: rayon d'épaisseur autour du segment\n    \nRésultat:\n    la coordonnée x représente la distance à un segment d'épaisseur rayon\n*/\nObjet gellule(in vec3 A, in vec3 B, in float rayon, in vec3 point, in int iTex, vec3 texPos, in vec3 texAngle) {\n    vec3 AP = point - A;\n    vec3 AB = B - A;\n    if(dot(AB, AP) < 0.f) {\n        return Objet(length(AP) - rayon, iTex, texPos, texAngle);\n    }\n    if(dot(AB, point - B) > 0.f) {\n        return Objet(length(point - B) - rayon, iTex, texPos, texAngle);\n    }\n    else {\n        float baseTri = dot(AP, normalize(B - A));\n        return Objet(sqrt(length(AP) * length(AP) - baseTri * baseTri) - rayon, iTex, texPos, texAngle);\n    }\n}\n\n/*\nParam:\n    c: centre du cercle\n    n: normale au cercle\n    r: rayon du cercle\n    ri: rayon intérieur de l'épaisseur du cercle\n    \nRésultat:\n    la coordonnée x représente la distance à un cercle d'épaisseur ri\n*/\nObjet tore(in vec3 c, in vec3 n, in float r, in float ri, in vec3 point, in int iTex, vec3 texPos, in vec3 texAngle) {\n    vec3 CP = point - c;\n    float distPlan = dot(CP, n);\n    float baseTri = sqrt(length(CP) * length(CP) - distPlan * distPlan) - r;\n    return Objet(sqrt(distPlan * distPlan + baseTri * baseTri) - ri, iTex, texPos, texAngle);\n}\n\n/*\nParam:\n    c: centre du disque\n    n: normale au disque\n    r: rayon du disque\n    ri: rayon intérieur de l'épaisseur du disque\n    \nRésultat:\n    la coordonnée x représente la distance à un disque d'épaisseur ri\n*/\nObjet disque(in vec3 c, in vec3 n, in float r, in float ri, in vec3 point, in int iTex, vec3 texPos, in vec3 texAngle) {\n    vec3 CP = point - c;\n    float distPlan = dot(CP, n);\n    float baseTri = sqrt(length(CP) * length(CP) - distPlan * distPlan) - r;\n    if(baseTri < 0.f)\n        return Objet(abs(distPlan) - ri, iTex, texPos, texAngle);\n    return Objet(sqrt(distPlan * distPlan + baseTri * baseTri) - ri, iTex, texPos, texAngle);\n}\n\n/*\nRésultat:\n    la coordonnée x représente la distance à un cylindre de rayon 0.5 (diamètre 1.f), infini.\n*/\nObjet cylindre(vec3 point, int iTex, vec3 texPos, in vec3 texAngle) {\n    float baseTri = dot(vec3(0, 1, 0), point);\n    return Objet(\n        sqrt(length(point) * length(point) - baseTri * baseTri) - 0.5,\n        iTex, texPos, texAngle\n    );\n}\n\n/*\nParam:\n    c: barycentre du cylindre (infini)\n    n: vecteur directeur du cylindre\n    r: rayon de l'épaisseur du cylindre\n\nRésultat:\n    la coordonnée x représente la distance à un cylindre infini parametré\n*/\nObjet cylindre(vec3 c, vec3 n, float r, vec3 point, int iTex, vec3 texPos, in vec3 texAngle) {\n    n = normalize(n);\n    point = (point - c);\n    float baseTri = dot(n, point);\n    return Objet(\n        sqrt(length(point) * length(point) - baseTri * baseTri) - r,\n        iTex, texPos, texAngle\n    );\n}\n\n/*\nParam:\n    b: point à la base du cylindre\n    n: vecteur normale à la base (pointe vers l'intérieur du cylindre)\n    height: hauteur du cylindre\n    r: rayon de l'épaisseur dy cylindre\n    \nRésultat:\n    la coordonnée x renvoie la distance à un cylindre paramétré de longueur length\n\n*/\nObjet cylindre(vec3 b, vec3 n, float length, float r, vec3 point, int iTex, vec3 texPos, in vec3 texAngle) {\n    n = normalize(n);\n    return \n        opI(\n            cylindre(b, n, r, point, iTex, texPos, texAngle),\n            plan(b + 0.5 * length, n, 0.5 * length, point, iTex, texPos, texAngle)\n        );\n}\n\n/*\nParam:\n    A: point à la base\n\n*/\nObjet tube(in vec3 A, in vec3 n, float length, in float r, in float epaisseur, in vec3 point, in int iTex, vec3 texPos, in vec3 texAngle) {\n    return opP(\n        cylindre(A, n, length, r, point, iTex, texPos, texAngle),\n        cylindre(A, n, r - epaisseur, point, iTex, texPos, texAngle)\n    );\n}\n\n/*\nParam:\n    A: Base du cone\n    B: Haut du cone\n    radiusBottom: rayon de la base\n    radisuTop: rayon du haut\n    \nRésultat:\n    la coordonnée x représente la distance à un cone paramétré\n    \nDesc:\n    la pente est donné par une interpolation linéaire entre le rayon de la base et au sommet\n    La distance n'est pas exact, puisque la distance se fait perpendiculairement à AB et non pas à la pente.\n\n*/\nObjet cone(in vec3 A, in vec3 B, in float radiusBottom, in float radiusTop, in vec3 point, in int iTex, vec3 texPos, in vec3 texAngle) {\n    Objet res;\n    vec3 norm = normalize(B - A);\n    \n    vec3 AP = point - A;\n    \n    float projP = dot(AP, norm);\n\n    \n    float heightRatio = projP / distance(A, B);\n    res = Objet(\n        sqrt(length(AP) * length(AP) - projP * projP) - (heightRatio * radiusTop + (1.f - heightRatio) * radiusBottom),\n        iTex, texPos, texAngle\n    );\n    \n    return opI(res, \n        plan(A + 0.5 * length(B - A), norm, 0.5*length(B-A), point, iTex, texPos, texAngle)\n    );\n}\n\nObjet field(in vec3 p, in int o, in float ampl, in float lambda, in int iTex, vec3 texPos, in vec3 texAngle) {\n    Objet res;\n    \n    res.dist = p.y - fbm(vec3(p.x, 0., p.z), o, ampl, lambda);\n    res.dist /= ampl * sqrt(2.);\n    res.iTex = iTex;\n    res.texPos = texPos;\n    res.texAngle = res.texAngle;\n    \n    //res = Objet(distance(vec3(0), p) - 5., WHITE, vec3(0));\n    \n    return res;\n}\n\n\n//=============//\n//             //\n//   TEXTURE   //\n//             //\n//=============//\n\n\n\nTexture Damier(in vec3 p, in float size, in vec3 displacement) {\n    //float size = 25.;\n    //vec3 displacement = vec3(0, 0, 0);\n    \n    int r = int(floor(displacement + p.x / size)) + int(floor(displacement + p.z / size)) + int(floor(displacement + p.y / size));\n    if(r % 2 == 0)\n        return Texture(vec3(0.2, 0.2, 0.2), mat);\n    return Texture(vec3(1, 1, 1), mat);\n}\n\nTexture DamierDef(in vec3 p, in vec2 defCoeff, in float size, in vec3 displacement) {\n    float def = Noise(p / defCoeff.x) * defCoeff.y;\n    p.x += def;\n    p.y += def;\n    p.z += def;\n    \n    return Damier(p, size, displacement);\n}\n\nTexture Point(in vec3 p) {\n    float size = 10.;\n    p += vec3(5.);\n    p = vec3(fract(p.x / size), fract(p.y / size), fract(p.z / size));\n    \n    p -= vec3(0.5);\n    \n    if(length(p.xyz) < 0.2)\n        return Texture(vec3(0.2, 0.2, 0.2), mat);\n    return Texture(vec3(1, 1, 1), mat);   \n}\n\nTexture Bois(in vec3 p) {\n    float freq = 3.;\n\n\n    p *= freq;\n    float d = length(p.xz) + 3. * Noise(vec3(p.x, 0, p.z) / 6.);\n    d = pow(cos(d), 6.) * .5;\n    \n    vec3 colB = vec3(169,137,86) / 255.;\n    vec3 colA = vec3(96,76,49) / 255.;\n    \n    Texture res;\n    res.specIndex = 1.;\n    res.specCoeff = 0.25;\n    res.reflectCoeff = 0.;\n    res.transparency = 0.;\n    res.col = mix(colB, colA, d);\n    \n    return res;\n}\n\nTexture Marbre(in vec3 p) {\n    Texture res;\n    vec3 colA = vec3(230)/255.;\n    vec3 colB = vec3(200)/255.;\n    vec3 colD = vec3(100, 85,75)/255.;\n\n    float freq = 0.4;\n    float ampl = 4.;\n    \n\n    float height = p.y + Noise(p * freq) * ampl;\n    float noise = Noise(vec3(height) / freq);\n    \n    float d = plan(vec3(0), vec3(0, 1, 0), 0.25, fract(vec3(height + noise * 3.) / 10.), WHITE, vec3(0), vec3(0)).dist;\n    //d *= (Noise(p) > 0.5) ? 0. : 1.;\n    if(d < -0.2)\n        res.col = colD;\n    else\n        res.col = mix(colA, colB, noise);\n   \n    \n    //sans gamma correction mix(0.25, 0., noise)\n    res.specCoeff = mix(1., 0.25, noise);\n    res.reflectCoeff = mix(.05, 0., noise);\n    res.transparency = 0.;\n    res.specIndex = 30.;\n    return res;\n}\n\nTexture MarbreNoir(in vec3 p) {\n    Texture res;\n    \n    //veine principalement repris de Maxime\n    float height = fract(p.y*Noise(p/16.) * 0.2)*Noise(p/16.);\n    \n    float plan = plan(vec3(0.,0.,0.), vec3(0, 1, 0), 0.02, vec3(p.x, height, p.z), WHITE, vec3(0), vec3(0)).dist;\n\n    \n    if(plan <= 0.) { //veine\n    \n    \n        res.col = vec3(0.7);\n        res.specCoeff = 0.25;\n        res.specIndex = 1.;\n        res.transparency = 0.;\n        res.reflectCoeff = 0.;\n        \n        \n    }\n    else { //marbre\n    \n    \n        vec3 colClair = vec3(66) / 255.;\n        vec3 colSombre = vec3(30) / 255.;\n    \n        float BigNoise = Noise(p * 0.15);\n        float SmallNoise = Noise(p * 10.);\n    \n        float rep = 0.2;\n    \n        vec3 background_color = mix(\n                mix(colSombre, colClair, BigNoise),\n                mix(colClair, colSombre, SmallNoise),\n                rep);\n    \n        float background_index = mix(\n                mix(30., 5., BigNoise),\n                mix(5., 30., SmallNoise),\n                rep);\n        \n        res.col = background_color;\n        res.specCoeff = 0.5;\n        res.specIndex = background_index;\n        res.reflectCoeff = 0.05;\n        res.transparency = 0.;\n        \n        \n    }\n    \n    return res;\n}\n\nTexture Sable(in vec3 p) {\n    Texture res;\n    \n    float freq = 8.;\n    \n    float noise = Noise(p * freq);\n    \n    vec3 colA = vec3(227,222,187) / 255.;\n    vec3 colB = vec3(150,152,105) / 255.;\n\n    res.col = mix(colA, colB, noise);\n    res.specIndex = mix(5., 0., noise);\n    res.specCoeff = mix(0.75, 0.25, noise);\n    res.transparency = 0.;\n   \n    return res;\n}\n\nTexture Rouille(in vec3 p) {\n    Texture res;\n    \n    vec3 clair = vec3(0.75);\n    vec3 sombre = vec3(0.65);\n    vec3 rouilleO = vec3(154,97,63)/255.;\n    vec3 rouilleB = vec3(111,73,61) /255.;\n    \n    \n    float repartition = 0.6;\n    //turbulence avec 2 niveau de bruit\n    float noise =  Noise(p * 0.2) * repartition + Noise(p * 8.) * (1. - repartition) ;\n    \n    \n    //couleur  specIndex specCoeff relfectCoeff\n    //clair     25.       1.        0.1 \n    //sombre    5.        1.        0.05\n    //rouilleO  5.        0.25      0.\n    //rouilleB  1.        0.        0.\n    \n    //         vvv    Coeff de rouille: 0 = entièrement rouillé\n    if(noise > 0.4) { //rouille\n        res.col = mix(sombre, mix(rouilleO, rouilleB, noise), noise);\n        res.specIndex = mix(5., mix(5., 1., noise), noise);\n        res.specCoeff = mix(1., mix(0.25, 0., noise), noise);\n        res.reflectCoeff = mix(0.1, 0., noise);\n        res.transparency = 0.;\n        \n    } else { //background: rayure\n        noise = Noise(vec3(p.y) * 10.);\n        res.col = mix(clair, sombre, noise);\n        res.specIndex = mix(25., 5., noise);\n        res.specCoeff = 1.;\n        res.reflectCoeff = mix(0.1, 0.05, noise);\n        res.transparency = 0.;\n    }\n    \n    \n    \n    return res;\n}\n\nTexture Metal(in vec3 p) {\n    Texture res;\n    \n    vec3 clair = vec3(0.75);\n    vec3 sombre = vec3(0.65);\n    \n    float noise = Noise(vec3(p.y) * 10.);\n    res.col = mix(clair, sombre, noise);\n    res.specIndex = mix(25., 5., noise);\n    res.specCoeff = 1.;\n    res.reflectCoeff = mix(0.1, 0.05, noise);\n    res.transparency = 0.;\n    \n    \n    \n    \n    return res;\n}\n\nTexture Verre(in vec3 p) {\n    Texture res;\n    res.col = vec3(0.8);\n    res.specIndex = 20.;\n    res.specCoeff = 0.25;\n    res.reflectCoeff = 0.1;\n    res.transparency = 0.1;\n    return res;\n}\n\n//===============//\n//               //\n//   Animation   //\n//               //\n//===============//\n\n\n//retourne la distance parcourue\nfloat updatePos(inout vec3 pos, inout vec3 speed, in vec3 acc, in float dt) {\n    vec3 dist = pos;\n    pos = pos + speed * dt + acc * dt * dt;\n    speed = speed + acc * dt;\n    dist -= pos;\n    return length(dist);\n}\n\n","name":"Common","description":"","type":"common"}]}