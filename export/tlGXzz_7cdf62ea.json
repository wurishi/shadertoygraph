{"ver":"0.1","info":{"id":"tlGXzz","date":"1582055031","viewed":168,"name":"EditDSF BlobForest","username":"clark_eagling","description":"change ray direction number to negative to look up / rotate t'other way","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["editsdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SHADERTOY\n#define SHADERTOY_ZOOM 2.0\nprecision mediump float;\nuniform vec3 uOrigin;\nuniform mat3 uView;\nuniform vec2 uInvSize;\n\n\n#define PI 3.141592653589793\n#define PI_2 1.5707963267948966\n#define SQRT1_2 0.7071067811865476\n#define SQRT2 1.4142135623730951\n\n// raymarching code from https://www.shadertoy.com/view/Xds3zN\n\n// blend color for chamfer and round operators (sd is simple operator distance)\nvec3 colorBlending(const in float sd, const in vec4 a, const in vec4 b) {\n  float ra = clamp(sd / a.x, 0.0, 1.0);\n  float rb = clamp(sd / b.x, 0.0, 1.0);\n  return (a.yzw * ra + b.yzw * rb) / (ra + rb);\n}\n\nvec3 colorUnion(const in vec4 a, const in vec4 b){\n#ifdef BLEND_COLOR\n  return colorBlending(min(a.x, b.x), a, b);\n#else\n  return (a.x < b.x) ? a.yzw : b.yzw;\n#endif\n}\n\nvec3 colorInter(const in vec4 a, const in vec4 b){\n#ifdef BLEND_COLOR\n  return colorBlending(max(a.x, b.x), a, b);\n#else\n  return (a.x < b.x) ? a.yzw : b.yzw;\n#endif\n}\n\nvec2 pR45(const in vec2 p) {\n  return (p + vec2(p.y, -p.x)) * SQRT1_2;\n}\n\n/////////////\n// PRIMITIVES\n/////////////\n\nfloat cullPlane(const in vec3 p) {\n  return p.y >= -0.502 ? p.y + 0.5 : 20.0;\n}\n\nfloat sdSphere(const in vec3 p, const in float s) {\n  return length(p) - s;\n}\n\nfloat sdBox(const in vec3 p, const in vec4 b) {\n  vec3 d = abs(p) - b.xyz;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - b.w;\n}\n\nfloat sdTorus(const in vec3 p, const in vec2 t) {\n  return length(vec2(length(p.xz) - t.x, p.y)) - t.y;\n}\n\nfloat sdCapsule(const in vec3 p, const in vec2 rh) {\n  return mix(length(p.xz) - rh.x, length(vec3(p.x, abs(p.y) - rh.y, p.z)) - rh.x, step(rh.y, abs(p.y)));\n}\n\nfloat sdEllipsoid(const in  vec3 p, const in vec3 r) {\n  return (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\n///////////////\n// COMBINATIONS\n///////////////\n\n// UNION\nfloat opUnion(const in float a, const in float b) {\n  return min(a, b);\n}\nvec4 opUnion(const in vec4 a, const in vec4 b) {\n  return (a.x < b.x) ? a : b;\n}\n\n// INTER\nfloat opInter(const in float a, const in float b) {\n  return max(a, b);\n}\nvec4 opInter(const in vec4 a, const in vec4 b) {\n  return (a.x > b.x) ? a : b;\n}\n\n// SUB\nfloat opSub(const in float a, const in float b) {\n  return max(-b, a);\n}\nvec4 opSub(const in vec4 a, const in vec4 b) {\n  // to keep b material on diff intersection instead of a mat\n  // return (-b.x > a.x) ? vec4(-b.x, b.yzw) : a);\n  return vec4(max(-b.x, a.x), a.yzw);\n}\n\n// see hg_sdf.glsl\n/////////////////////\n// COMBINATIONS ROUND\n/////////////////////\n\n// UNION ROUND (soft media mol version)\nfloat opUnionRound(const in float a, const in float b, const in float r) {\n  float e = max(r - abs(a - b), 0.0);\n  return min(a, b) - e * e * 0.25 / r;\n}\nvec4 opUnionRound(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opUnionRound(a.x, b.x, r), colorUnion(a, b));\n}\n\n// INTER ROUND\nfloat opInterRound(const in float a, const in float b, const in float r) {\n  vec2 u = max(vec2(r + a, r + b), vec2(0.0));\n  return min(-r, max(a, b)) + length(u);\n}\nvec4 opInterRound(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opInterRound(a.x, b.x, r), colorInter(a, b));\n}\n\n// SUB ROUND\nfloat opSubRound(const in float a, const in float b, const in float r) {\n  return opInterRound(a, -b, r);\n}\nvec4 opSubRound(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opInterRound(a.x, -b.x, r), a.yzw);\n}\n\n///////////////////////\n// COMBINATIONS CHAMFER\n///////////////////////\n\n// UNION CHAMFER\nfloat opUnionChamfer(const in float a, const in float b, const in float r) {\n  return min(min(a, b), (a - r + b) * SQRT1_2);\n}\nvec4 opUnionChamfer(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opUnionChamfer(a.x, b.x, r), colorUnion(a, b));\n}\n\n// INTER CHAMFER\nfloat opInterChamfer(const in float a, const in float b, const in float r) {\n  return max(max(a, b), (a + r + b) * SQRT1_2);\n}\nvec4 opInterChamfer(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opInterChamfer(a.x, b.x, r), colorInter(a, b));\n}\n\n// SUB CHAMFER\nfloat opSubChamfer(const in float a, const in float b, const in float r) {\n  return opInterChamfer(a, -b, r);\n}\nvec4 opSubChamfer(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opInterChamfer(a.x, -b.x, r), a.yzw);\n}\n\n//////////////////////\n// COMBINATION COLUMNS\n//////////////////////\n\n// UNION COLUMNS\nfloat opUnionColumns(const in float a, const in  float b, const in vec2 rn) {\n  float r = rn.x;\n  float n = rn.y;\n  if((a < r) && (b < r)) {\n    vec2 p = vec2(a, b);\n    float columnradius = r * SQRT2 / ((n - 1.0) * 2.0 + SQRT2);\n    p = pR45(p);\n    p.x -= SQRT1_2 * r;\n    p.x += columnradius * SQRT2;\n    if(mod(n, 2.0) == 1.0) {\n      p.y += columnradius;\n    }\n    // At this point, we have turned 45 degrees and moved at a point on the\n    // diagonal that we want to place the columns on.\n    // Now, repeat the domain along this direction and place a circle.\n    p.y = mod(p.y + columnradius, columnradius * 2.0) - columnradius;\n    float result = length(p) - columnradius;\n    result = min(result, p.x);\n    result = min(result, a);\n    return min(result, b);\n  } \n\n  return min(a, b);\n}\nvec4 opUnionColumns(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(opUnionColumns(a.x, b.x, rn), colorUnion(a, b));\n}\n\n// SUB COLUMNS\nfloat opSubColumns(const in float ain, const float b, const vec2 rn) {\n  float a = -ain;\n  float r = rn.x;\n  float n = rn.y;\n  float m = min(a, b);\n  //avoid the expensive computation where not needed (produces discontinuity though)\n  if((a < r) && (b < r)) {\n    vec2 p = vec2(a, b);\n    float columnradius = r * SQRT2 / n / 2.0;\n    columnradius = r * SQRT2 / ((n - 1.0) * 2.0 + SQRT2);\n\n    p = pR45(p);\n    p.y += columnradius;\n    p.x -= SQRT1_2 * (r + columnradius);\n\n    if(mod(n, 2.0) == 1.0) {\n      p.y += columnradius;\n    }\n    p.y = mod(p.y + columnradius, columnradius * 2.0) - columnradius;\n\n    float result = -length(p) + columnradius;\n    result = max(result, p.x);\n    result = min(result, a);\n    return -min(result, b);\n  }\n\n  return -m;\n}\nvec4 opSubColumns(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(opSubColumns(a.x, b.x, rn), a.yzw);\n}\n\n// INTER COLUMNS\nfloat opInterColumns(const in float a, const in float b, const in vec2 rn) {\n  return opSubColumns(a, -b, rn);\n}\nvec4 opInterColumns(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(opSubColumns(a.x, -b.x, rn), colorInter(a, b));\n}\n\n/////////////////////\n// COMBINATION STAIRS\n/////////////////////\n// UNION STAIRS\nfloat opUnionStairs(const in float a, const in float b, const in vec2 rn) {\n  float s = rn.x / rn.y;\n  float u = b - rn.x;\n  return min(min(a, b), 0.5 * (u + a + abs((mod(u - a + s, 2.0 * s)) - s)));\n}\nvec4 opUnionStairs(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(opUnionStairs(a.x, b.x, rn), colorUnion(a, b));\n}\n\n// INTER STAIRS\nfloat opInterStairs(const in float a, const in float b, const in vec2 rn) {\n  return -opUnionStairs(-a, -b, rn);\n}\nvec4 opInterStairs(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(-opUnionStairs(-a.x, -b.x, rn), colorInter(a, b));\n}\n\n// SUB STAIRS\nfloat opSubStairs(const in float a, const in float b, const in vec2 rn) {\n  return -opUnionStairs(-a, b, rn);\n}\nvec4 opSubStairs(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(-opUnionStairs(-a.x, b.x, rn), a.yzw);\n}\n\n/////////////\n// REPETITION\n/////////////\n\nvec3 pMod(const in vec3 p, const in vec3 size) {\n  vec3 pmod = p;\n  if(size.x > 0.0) pmod.x = mod(p.x + size.x * 0.5, size.x) - size.x * 0.5;\n  if(size.y > 0.0) pmod.y = mod(p.y + size.y * 0.5, size.y) - size.y * 0.5;\n  if(size.z > 0.0) pmod.z = mod(p.z + size.z * 0.5, size.z) - size.z * 0.5;\n  return pmod;\n}\n\n////////////\n// HELPERS\n////////////\nvec4 mapDistanceColor(const in vec3 point) {\n  vec4 tmpPrim_118 = vec4(cullPlane(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.30000001192092896,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0))) * 1.0, vec3(0.1) * (mod(floor(5.0 * point.z) + floor(5.0 * point.x), 2.0)) + 0.4);\nvec4 tmpPrim_119 = vec4(sdEllipsoid(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(5.0,5.0,5.0)), vec3(0.2,0.4,0.8)) * 1.0, vec3(0.5,0.5,1.0));\nvec4 tmpComb_337 = opUnionRound(tmpPrim_118, tmpPrim_119, 1.0);\nvec4 tmpPrim_120 = vec4(sdEllipsoid(pMod((mat4(0.5548762679100037,0.5650126934051514,-0.5693203210830688,0.0,-0.6958704590797424,0.6833863854408264,4.5188969011178415e-8,0.0,0.39891016483306885,0.4061973989009857,0.7919134497642517,0.0,-0.4681593179702759,-0.47671157121658325,0.4803459942340851,1.0) * vec4(point, 1.0)).xyz, vec3(4.8500000000000005,4.72,4.98)), vec3(0.2,0.4,0.8)) * 1.0253025730826635, vec3(1.0,0.5,0.7999999999999998));\nvec4 tmpComb_338 = tmpComb_337;\nvec4 tmpComb_339 = opUnionRound(tmpComb_338, tmpPrim_120, 1.0);\nvec4 tmpPrim_121 = vec4(sdSphere(pMod((mat4(0.8272493481636047,0.0,0.0,0.0,0.0,0.8272493481636047,0.0,0.0,0.0,0.0,0.8272493481636047,0.0,0.8155362010002136,-0.3699759840965271,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(4.98,4.98,5.23)), 0.4) * 1.2088253498077393, vec3(0.5,1.0,0.5499999999999998));\nvec4 tmpComb_340 = tmpComb_339;\nvec4 tmpComb_341 = opUnionRound(tmpComb_340, tmpPrim_121, 1.0);\nvec4 tmpPrim_122 = vec4(sdEllipsoid(pMod((mat4(1.0305591821670532,-0.6961436867713928,0.5479406118392944,0.0,0.7607165575027466,1.1261518001556396,-1.2500748880484025e-8,0.0,-0.45405444502830505,0.30671417713165283,1.243651270866394,0.0,-1.5283113718032837,-1.0519088506698608,-0.298557311296463,1.0) * vec4(point, 1.0)).xyz, vec3(5.1000000000000005,5.1000000000000005,5.3)), vec3(0.2,0.4,0.33)) * 0.7358299267032258, vec3(0.5,0.97,1.0));\nvec4 tmpComb_342 = tmpComb_341;\nvec4 tmpComb_343 = opUnionRound(tmpComb_342, tmpPrim_122, 0.97);\nvec4 tmpPrim_123 = vec4(sdSphere(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.5729847550392151,-1.037184238433838,-1.7758475542068481,1.0) * vec4(point, 1.0)).xyz, vec3(4.72,4.72,4.8500000000000005)), 0.26) * 1.0, vec3(0.96,0.5,1.0));\nvec4 tmpComb_344 = tmpComb_343;\nvec4 tmpComb_345 = opUnionRound(tmpComb_344, tmpPrim_123, 1.17);\nvec4 tmpPrim_124 = vec4(sdEllipsoid(pMod((mat4(0.6799264550209045,-0.62980717420578,-0.47884735465049744,0.0,0.37898901104927063,0.813499391078949,-0.5318251252174377,0.0,0.6944921016693115,0.17266610264778137,0.759024977684021,0.0,2.51404070854187,-1.3622883558273315,0.8606699705123901,1.0) * vec4(point, 1.0)).xyz, vec3(5.62,5.68,5.62)), vec3(0.3,0.19,0.18)) * 0.9585952476652823, vec3(0.00341093750000002,0.0840605312499999,0.37));\nvec4 tmpComb_346 = tmpComb_345;\nvec4 tmpComb_347 = opUnionRound(tmpComb_346, tmpPrim_124, 2.08);\nvec4 tmpPrim_125 = vec4(sdTorus(pMod((mat4(-0.20544157922267914,-0.9786693453788757,0.0,0.0,0.9786693453788757,-0.20544157922267914,0.0,0.0,0.0,0.0,1.0,0.0,-0.972653865814209,3.1288809776306152,-3.057844400405884,1.0) * vec4(point, 1.0)).xyz, vec3(5.36,5.42,5.68)), vec2(0.4,0.05)) * 1.000000026423471, vec3(0.31778906250000005,0.91,0.51914078125));\nvec4 tmpComb_348 = tmpComb_347;\nvec4 tmpComb_349 = opUnionRound(tmpComb_348, tmpPrim_125, 2.08);\nreturn tmpComb_349;\n}\n\nfloat mapDistance(const in vec3 point) {\n  float tmpComb_350 = opUnionRound(cullPlane(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.30000001192092896,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0))) * 1.0, sdEllipsoid(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(5.0,5.0,5.0)), vec3(0.2,0.4,0.8)) * 1.0, 1.0);\nfloat tmpComb_351 = tmpComb_350;\nfloat tmpComb_352 = opUnionRound(tmpComb_351, sdEllipsoid(pMod((mat4(0.5548762679100037,0.5650126934051514,-0.5693203210830688,0.0,-0.6958704590797424,0.6833863854408264,4.5188969011178415e-8,0.0,0.39891016483306885,0.4061973989009857,0.7919134497642517,0.0,-0.4681593179702759,-0.47671157121658325,0.4803459942340851,1.0) * vec4(point, 1.0)).xyz, vec3(4.8500000000000005,4.72,4.98)), vec3(0.2,0.4,0.8)) * 1.0253025730826635, 1.0);\nfloat tmpComb_353 = tmpComb_352;\nfloat tmpComb_354 = opUnionRound(tmpComb_353, sdSphere(pMod((mat4(0.8272493481636047,0.0,0.0,0.0,0.0,0.8272493481636047,0.0,0.0,0.0,0.0,0.8272493481636047,0.0,0.8155362010002136,-0.3699759840965271,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(4.98,4.98,5.23)), 0.4) * 1.2088253498077393, 1.0);\nfloat tmpComb_355 = tmpComb_354;\nfloat tmpComb_356 = opUnionRound(tmpComb_355, sdEllipsoid(pMod((mat4(1.0305591821670532,-0.6961436867713928,0.5479406118392944,0.0,0.7607165575027466,1.1261518001556396,-1.2500748880484025e-8,0.0,-0.45405444502830505,0.30671417713165283,1.243651270866394,0.0,-1.5283113718032837,-1.0519088506698608,-0.298557311296463,1.0) * vec4(point, 1.0)).xyz, vec3(5.1000000000000005,5.1000000000000005,5.3)), vec3(0.2,0.4,0.33)) * 0.7358299267032258, 0.97);\nfloat tmpComb_357 = tmpComb_356;\nfloat tmpComb_358 = opUnionRound(tmpComb_357, sdSphere(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.5729847550392151,-1.037184238433838,-1.7758475542068481,1.0) * vec4(point, 1.0)).xyz, vec3(4.72,4.72,4.8500000000000005)), 0.26) * 1.0, 1.17);\nfloat tmpComb_359 = tmpComb_358;\nfloat tmpComb_360 = opUnionRound(tmpComb_359, sdEllipsoid(pMod((mat4(0.6799264550209045,-0.62980717420578,-0.47884735465049744,0.0,0.37898901104927063,0.813499391078949,-0.5318251252174377,0.0,0.6944921016693115,0.17266610264778137,0.759024977684021,0.0,2.51404070854187,-1.3622883558273315,0.8606699705123901,1.0) * vec4(point, 1.0)).xyz, vec3(5.62,5.68,5.62)), vec3(0.3,0.19,0.18)) * 0.9585952476652823, 2.08);\nfloat tmpComb_361 = tmpComb_360;\nfloat tmpComb_362 = opUnionRound(tmpComb_361, sdTorus(pMod((mat4(-0.20544157922267914,-0.9786693453788757,0.0,0.0,0.9786693453788757,-0.20544157922267914,0.0,0.0,0.0,0.0,1.0,0.0,-0.972653865814209,3.1288809776306152,-3.057844400405884,1.0) * vec4(point, 1.0)).xyz, vec3(5.36,5.42,5.68)), vec2(0.4,0.05)) * 1.000000026423471, 2.08);\nreturn tmpComb_362;\n}\n    \nvec4 castRay(const in vec3 ro, const in vec3 rd) {\n  float t = 1.0;\n  float tmax = 50.0;\n\n  float precis = 0.002;\n  for(int i = 0; i < 50; i++) {\n    float dist = mapDistance(ro + rd * t);\n    if(dist < precis || t > tmax)\n      break;\n    t += dist;\n  }\n\n  vec3 m = t > tmax ? vec3(-1.0) : mapDistanceColor(ro + rd * t).yzw;\n  return vec4(t, m);\n}\n\nfloat softshadow(const in vec3 ro, const in vec3 rd) {\n  float t = 0.02;\n  float tmax = 2.5;\n  float precis = 0.001;\n  float res = 1.0;\n  for(int i = 0; i < 32; i++) {\n    float h = mapDistance(ro + rd * t);\n    res = min(res, 20.0 * h / t);\n    t += clamp( h, 0.02, 0.10 );\n    if(h < 0.001 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 calcNormal(const in vec3 pos) {\n  vec3 eps = vec3(0.001, 0.0, 0.0);\n  vec3 nor = vec3(\n      mapDistance(pos + eps.xyy) - mapDistance(pos - eps.xyy),\n      mapDistance(pos + eps.yxy) - mapDistance(pos - eps.yxy),\n      mapDistance(pos + eps.yyx) - mapDistance(pos - eps.yyx));\n  return normalize(nor);\n}\n\nfloat calcAO(const in vec3 pos, const in vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for(int i = 0; i < 5; i++) {\n      float hr = 0.01 + 0.03 * float(i);\n      vec3 aopos = nor * hr + pos;\n      occ += (hr - mapDistance(aopos)) * sca;\n      sca *= 0.95;\n  }\n  return clamp( 1.0 - 3.0 * occ, 0.0, 1.0 );    \n}\n\nvec3 render(const in vec3 ro, const in vec3 rd) {\n  vec3 col = vec3(0.5, 0.5, 0.5);\n  vec4 res = castRay(ro, rd);\n\n  if(res.y >= 0.0) {\n    vec3 pos = ro + res.x * rd;\n    vec3 nor = calcNormal(pos);\n\n    vec3 ref = reflect( rd, nor );\n    float occ = calcAO( pos, nor );\n    vec3  lig = normalize(vec3(-0.6, 0.7, -0.5));\n    float amb = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n    float dif = clamp(dot(nor, lig), 0.0, 1.0);\n    float bac = clamp(dot(nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0 ) * clamp( 1.0 - pos.y, 0.0, 1.0);\n    float dom = smoothstep(-0.1, 0.1, ref.y);\n    float fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n    float spe = pow(clamp(dot(ref, lig), 0.0, 1.0),16.0);\n        \n    dif *= softshadow(pos, lig);\n    dom *= softshadow(pos, ref);\n\n    vec3 lin = vec3(0.0);\n    lin += 1.20 * dif * vec3(1.00, 0.85, 0.55);\n    lin += 1.20 * spe * vec3(1.00, 0.85, 0.55) * dif;\n    lin += 0.20 * amb * vec3(0.50, 0.70, 1.00) * occ;\n    lin += 0.30 * dom * vec3(0.50, 0.70, 1.00) * occ;\n    lin += 0.30 * bac * vec3(0.25, 0.25, 0.25) * occ;\n    lin += 0.40 * fre * vec3(1.00, 1.00, 1.00) * occ;\n\n    col = res.yzw * lin;\n  }\n\n  return clamp(col, 0.0, 1.0);\n}\n\n#ifdef SHADERTOY\nmat3 setCamera( const in vec3 ro, const in vec3 ta, const float cr ){\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr),0.0);\n  vec3 cu = normalize( cross(cw,cp) );\n  vec3 cv = normalize( cross(cu,cw) );\n  return mat3( cu, cv, cw );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 q = fragCoord.xy / iResolution.xy;\n  vec2 p = -1.0 + 2.0 * q;\n  p.x *= iResolution.x / iResolution.y;\n  vec2 mo = iMouse.xy / iResolution.xy;\n  float time = 6.0 + iTime;\n\tfloat supersin = sin(2.3) + cos(0.7);\n    \n  // camera \n  vec3 ro = SHADERTOY_ZOOM * vec3( -0.2 + 4.5 * cos(0.1 * time + supersin * mo.x), 1.0 + 2.0 * mo.y, 0.3 + 3.5 * sin(0.1 * time + 6.0 * mo.x));\n  vec3 ta = vec3(-0.3, -0.8, 0.8);\n\n  // camera-to-world transformation\n  mat3 ca = setCamera(ro, ta, tan(-0.3));\n\n  // ray direction\n  vec3 rd = ca * normalize(vec3(p.xy, -1.1));\n\n  fragColor = vec4(render(ro, rd), 1.0);\n}\n\n#else\n\nvec3 raymarch(const in vec3 origin, const in mat3 view, const in vec2 uv, const in vec2 invSize) {\n  vec2 p = -1.0 + 2.0 * uv;\n  p.x *= invSize.y / invSize.x;\n  vec3 rd = normalize(view * vec3(p, 2.0));\n  return render(origin, rd);\n}\n\nvoid main() {\n  gl_FragColor = vec4(raymarch(uOrigin, uView, gl_FragCoord.xy * uInvSize, uInvSize), 1.0);\n}\n\n#endif\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}