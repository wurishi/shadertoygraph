{"ver":"0.1","info":{"id":"Wd33z7","date":"1568059917","viewed":132,"name":"Mandelbrot from TAOC","username":"GreenMoonMoon","description":"Mandelbrot shader acheived by following TheArtOfCode.\nThe formula itself, despite sensible explanations form AOC, still sounds like magic to me. It's fun to play with it nonetheless.\nAOC tutorial: https://www.youtube.com/watch?v=kY7liQVPQSc&t=275s\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["mandelbrot","theartofcode","taoc"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ASPECT iResolution.x/iResolution.y\n#define MAXSTEP 100.0\n\n// Simple rotation algorithm\nvec2 rotate(vec2 position, vec2 pivot, float angle){\n\tfloat s = sin(angle);\n    float c = cos(angle);\n    position -= pivot;\n    position = vec2(position.x * c - position.y * s, position.x * s + position.y * c);\n    position += pivot;\n    \n    return position;\n}\n\n// The mandlebrot implementation;\n// f(z) = z^2 + c\n// z is the starting position and c is the center.\n// Once the length of z goes above a threshold, the loop breaks and the result is returned.\n// The value is then normlalized and used to depict and image.\nvec2 mandelbrot(vec2 z, vec2 c){\n    float iter = 0.0; //The number of iteration counted before z length goes abobe threshold.\n    float smoothIter = 0.0;\n    \n    // The r and r2 enable us to figure out the distance between the edge of the threshold and the start.\n    // Use this is get a smooth interpolation between steps.\n    float r = 4.0;\n    float r2 = r * r;\n    \n    // The  main loop.\n\tfor(float i = 0.0; i < MAXSTEP; i++){\n        vec2 oz = z;\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n        // if(length(z) > r) break; // Original escape clause.\n        if(dot(z, oz) > r) break; // idk how that work exactly, but AOC does it and it's really nice.\n        \n        float dist = length(z);\n    \t//float fractIter = fract((dist - r) / (r2 -r)); //Linear interpolation\n        float fractIter = log(dist) / log(r) - 1.0; //Smooth interpolation\n        smoothIter -= fractIter;\n        iter++;\n    }\n    \n    //Here I return the step value as well as the smooth interpolated step value.\n    return vec2(iter/MAXSTEP, smoothIter/MAXSTEP);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize coordinate and setup aspect ratio.\n    vec2 uv = 1.0 - fragCoord.xy/iResolution.xy * 2.0;\n    uv.x *= ASPECT;\n\tvec2 mouse = (iMouse.xy/iResolution.xy);\n    mouse.x *= ASPECT;\n    \n    // Small function to get a smooth zoom over time.\n    float timeFactor = pow(iTime, -iTime * 0.1);\n    \n    vec2 zoom = vec2(timeFactor);\n    vec2 center = vec2(-0.7869340, -0.163849);\n    vec2 c = uv * zoom + center;\n    c = rotate(c, center, iTime  * 0.1);\n    \n    vec2 z = vec2(0.0);\n    vec2 f = mandelbrot(z, c);\n    \n    // Colorize\n    vec3 lum = sin(vec3(f.y) * 2.0);\n    vec3 albedo = sin(f.x * vec3(0.3, 0.63, 0.94) * 20.0 + (iTime * 0.5));\n    vec3 color = albedo * smoothstep(0.0, 0.5, sqrt(f.y));\n     \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}