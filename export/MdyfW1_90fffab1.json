{"ver":"0.1","info":{"id":"MdyfW1","date":"1528581645","viewed":408,"name":"Step Inside and Bask in Luxury","username":"blackle","description":"partycoded 4k\n\nthis code is garbage please do not read it too closely\n\nThe imagery for my demo was inspired by the photograph \"Wind Farm Star Trails\" by Matt James, which was the runner up in the 2014 Royal Museums Greenwich Astronomy Photographer of the ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["atparty"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n// HEY!! LOOK OVER HERE!!!\n// you may notice there are no stars, that is because shadertoy defaults to \"play\" mode\n// and the shitty star drawing loop will kill your machine\n// set this define to true if you want stars and have paused the player\n#define GIVEMESTARS false\n\nvec2 projectToSegment(vec2 p, vec2 p0, vec2 p1) {\n\tvec2 v = p1 - p0;\n\tvec2 w = p - p0;\n\t\n\tfloat b = dot(v,w)/dot(v,v);\n\tfloat dist = distance(p, p0 + v * clamp(b, 0.0, 1.0));\n\treturn vec2(b, dist);\n}\n\n//antialiases a distance value to an edge\nfloat aaEdge(float edge) {\n\tfloat pixelSize = 16.0/1080.0;\n\treturn clamp(edge/pixelSize, 0.0, 1.0);\n}\n\nfloat light(vec2 p) {\n\treturn 1.0/pow((1.0+length(p)), 2.0);\n}\n\nfloat lighthouse(vec2 p) {\n\tfloat ret = 0.0;\n\tret += light(p - vec2(0.0, 0.5));\n\tvec2 rod = projectToSegment(p, vec2(0.0, 0.5), vec2(0.0, -0.5));\n\tret += clamp(aaEdge(0.02-rod.y) * rod.x, 0.0, 1.0);\n\treturn ret;\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 ridge(vec2 p) {\n\tvec2 top = vec2(0.0, 0.5);\n\tvec2 p1 = vec2(-0.45, -0.5);\n\tvec2 p2 = vec2( 0.45, -0.5);\n\n\tfloat mask = aaEdge(smin(dot(p, p1-top), dot(p, p2-top), 0.5));\n\tfloat shade = min(mask, pow(clamp(1.0-dot(p, mix(p1, p2, 0.3)-top), 0.0, 1.0), 2.0));\n\treturn vec2(mask, shade);\n}\n\nfloat star_streak(vec2 p) {\n\tvec2 streak = projectToSegment(p, vec2(-4.50, 10.50), vec2(4.5, -10.5));\n\treturn clamp(1.0/pow((1.0+streak.y*30.0), 2.0)*1.1, 0.0, 1.0);\n}\n\n//http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nvoid stepState(inout uint state)\n{\n\tstate = (state ^ 61u) ^ (state >> 16u);\n\tstate *= 9u;\n\tstate = state ^ (state >> 4u);\n\tstate *= 0x27d4eb2du;\n\tstate = state ^ (state >> 15u);\n}\n\nvoid feed(inout uint state, float value)\n{\n\tstate ^= floatBitsToUint(value);\n\tstepState(state);\n}\n\nfloat getFloat(inout uint state) {\n\tstepState(state);\n\treturn uintBitsToFloat( (state & 0x007FFFFFu) | 0x3F800000u ) - 1.0;\n}\n\nfloat checkerboard(vec2 p, float loc) {\n    float iso = sin(p.x) * sin(p.y);\n    float gradmag = mix(1.0, sqrt((1.0 - cos(2.0*p.x) * cos(2.0*p.y))*0.5), pow(clamp(loc, 0.0, 1.0),2.0));\n    return clamp((iso/gradmag*loc)*0.5 + 0.5, 0.0, 1.0);\n}\n\n\nvec3 castToPlane(vec3 dir) {\n    return dir * -0.5 / dir.z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy)/iResolution.yy * 0.55;\n \n\tfloat mountains_mask = 0.0;\n\tfloat mountains = 0.0;\n\n\tfor (float x = -3.0; x <= 3.0; x+=0.5) {\n\t\tuint rand = 0xD1ADBEEFu;\n\t\tfeed(rand, x);\n\t\tfloat x_offset = getFloat(rand)*2.0-1.0;\n\t\tfloat y_offset = getFloat(rand)*2.0-1.0;\n\t\tvec2 myridge = ridge(uv*10.0 + vec2(x*2.0 + x_offset*0.5,1.3+y_offset*0.5));\n\t\tmountains_mask = max(mountains_mask, myridge.x);\n\t\tmountains = max(mountains, myridge.y);\n\t}\n\n\t// Time varying pixel color\n\tfloat col = mountains*0.40 + mountains_mask*0.15;\n\n\tfor (float x = -1.9; x <= 1.9; x+=0.25) {\n\t\tuint rand = 0xDEADBEEFu;\n\t\tfeed(rand, x);\n\t\tfloat x_offset = getFloat(rand)*2.0-1.0;\n\t\tfloat y_offset = getFloat(rand)*2.0-1.0;\n\t\tcol += lighthouse(uv*(30.0) + vec2(x*8.5+x_offset, 6.0+y_offset));\n\t}\n\n\tfloat stars = 0.0;\n    if (GIVEMESTARS) {\n\tfor (float x = -6.0; x <= 6.0; x+=0.015) {\n\t\tvec2 p = uv;\n\t\tp.x += -pow(p.y*0.5+0.5, 2.0)*0.2;\n\t\tuint rand = 0x77B02DE2u;\n\t\tfeed(rand, x);\n\t\tfloat x_offset = (getFloat(rand)*2.0-1.0)*0.5;\n\t\tfloat y_offset = (getFloat(rand)*2.0-1.0)*30.0;\n\t\tfeed(rand, x);\n\t\tfloat rand_intensity = pow(getFloat(rand)*getFloat(rand)*1.1 + 0.1, 2.0)*1.25;\n\t\tstars += star_streak(p*(20.0) + vec2(x*2.5+x_offset+1.0,-10.0+y_offset+x*1.5)) * rand_intensity;\n\t}\n}\n\tcol += min(pow(1.0-mountains_mask, 4.0), mix(0.0, stars, clamp((0.18 + uv.y)*3.0, 0.0, 1.0)));\n\n\n\tvec3 origin = vec3(0.0, 0.0, 1.0);\n\tvec3 dir = vec3(1.0, 0.0, 0.0);\n\tvec3 intersect = castToPlane(dir + vec3(0.0, (uv + vec2(0.0,0.26))*1.35));\n\n\tfloat checkers = checkerboard(intersect.xy*15.0, 1000.0/pow(abs(intersect.x),3.0));\n\n\tcol += mix(0.0, checkers, clamp(-(0.3 + uv.y)*2.0, 0.0, 1.0))*1.7;\n\n\tcol *= 1.0 - pow(length(uv)*1.2, 4.0);\n\n\tuint rand = 11992019u;\n\tfeed(rand, uv.x);\n\tfeed(rand, uv.y);\n\n\tfloat rnd = getFloat(rand);\n\tcol += rnd*0.1;\n\n\tcol = pow(col*0.5, 1.5);\n\n\t// Output to screen\n\tfragColor = vec4(vec3(col), 1.0);\n\n\tif (abs(uv.x) > 0.499 || abs(uv.y) > 0.499) {\n\t\tfragColor = vec4(0.0);\n\t}\n\n\tif (abs(uv.x) > 0.5 || abs(uv.y) > 0.5) {\n\t\tfragColor = vec4(mix(vec3(0.0, 0.26, 0.22), vec3(0.11, 0.80, 0.29), uv.y*0.5+0.5+rnd*0.1), 1.0);\n\t}\n}","name":"Image","description":"","type":"image"}]}