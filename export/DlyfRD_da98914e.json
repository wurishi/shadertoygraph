{"ver":"0.1","info":{"id":"DlyfRD","date":"1701873950","viewed":36,"name":"Depixelizer","username":"lieks","description":"An algorithm I saw a long time ago and couldn't find again.\nIt was designed so that you could get away with very low-res textures and still look sharp, as long as you avoided the artifacts.\nThe original page had a much more efficient implementation.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["pixel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float howsimilar(vec4 a, vec4 b)\n{\n    vec4 yc = vec4(0.2126/2.0, 0.7152/2.0, 0.0722/2.0, 1.0);\n    return abs(dot(a, yc) - dot(b, yc));\n}\n\nbool similar(vec4 a, vec4 b)\n{\n    return howsimilar(a, b) < 0.1;\n}\n\nvec4 texturec4(sampler2D tex, vec2 uv)\n{\n    vec2 iuv = floor(uv*iChannelResolution[0].xy-0.5);\n    vec2 fuv = uv*iChannelResolution[0].xy-iuv-0.5;\n\n    vec4 a = texture(tex, (0.5 + iuv + vec2(0, 0))/iChannelResolution[0].xy);\n    vec4 b = texture(tex, (0.5 + iuv + vec2(1, 0))/iChannelResolution[0].xy);\n    vec4 c = texture(tex, (0.5 + iuv + vec2(0, 1))/iChannelResolution[0].xy);\n    vec4 d = texture(tex, (0.5 + iuv + vec2(1, 1))/iChannelResolution[0].xy);\n\n    if (similar(a, b) && similar(b, c) && similar(c, d) && similar(a, d))\n        return texture(tex, uv);\n    if (similar(a, b) && similar(b, c) && similar(c, a)) {\n        if (-fuv.x < fuv.y - 1.5)\n            return d;\n        else\n            return mix(mix(a, b, fuv.x), c, fuv.y);\n    }\n    if (similar(b, c) && similar(c, d) && similar(d, b)) {\n        if (-fuv.x > fuv.y - 0.5)\n            return a;\n        else\n            return mix(mix(b, c, fuv.y), d, fuv.x);\n    }\n    if (similar(a, c) && similar(c, d) && similar(d, a)) {\n        if (fuv.x - 0.5 > fuv.y)\n            return b;\n        else\n            return mix(mix(a, c, fuv.y), d, fuv.x);\n    }\n    if (similar(a, b) && similar(b, d) && similar(d, a)) {\n        if (fuv.x + 0.5 < fuv.y)\n            return c;\n        else\n            return mix(mix(a, b, fuv.x), d, fuv.y);\n    }\n    if (similar(a, b) && similar(c, d)) {\n        if (fuv.y < 0.5)\n            return mix(a, b, fuv.x);\n        else\n            return mix(c, d, fuv.x);\n    }\n    if (similar(a, c) && similar(b, d)) {\n        if (fuv.x < 0.5)\n            return mix(a, c, fuv.y);\n        else\n            return mix(b, d, fuv.y);\n    }\n    if (similar(a, d) && howsimilar(a, d) < howsimilar(b, c)) {\n        if (fuv.x - fuv.y > 0.5)\n            return b;\n        else if (fuv.x - fuv.y < -0.5)\n            return c;\n        else\n            return mix(a, d, (fuv.x + fuv.y)/2.0);\n    }\n    if (similar(b, c) && howsimilar(b, c) < howsimilar(a, d)) {\n        if (fuv.x + fuv.y < 0.5)\n            return a;\n        else if (fuv.x + fuv.y > 1.5)\n            return d;\n        else\n            return mix(b, c, (-fuv.x + 1.0 + fuv.y)/2.0);\n    }\n    return texture(tex, (0.5 + iuv + round(fuv))/iChannelResolution[0].xy);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec2 uvo = vec2(trunc(fract(iTime*2.0)*6.0)/6.4, 0.0);\n\n    // Output to screen\n    fragColor = texturec4(iChannel0, vec2(uv.x/6.0, uv.y)+uvo);\n}","name":"Image","description":"","type":"image"}]}