{"ver":"0.1","info":{"id":"XttfzN","date":"1538858821","viewed":297,"name":"Conway's Game of Life tutorial","username":"vchizhov","description":"A tutorial on how to make a simple version of Conway's game of life in shadertoy. LMB to create. Improvement suggestions are welcome (in terms of making it easier to understand).","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["tutorial","automata","conway","gameoflife"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // just read bufferA's current state and draw it\n    vec3 col = texelFetch(iChannel0,ivec2(fragCoord), 0).xyz;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MARGIN ivec2(10)\n\n\n// click near the end of the board to see the effect of wrapping\n#define TOROIDAL 1\n\n#if TOROIDAL == 0\nivec2 toroidal(in ivec2 c) { return c; }\nivec2 dist(in ivec2 a, in ivec2 b) { return abs(a-b); }\n#else\n// wraps a pixel coord outside of the board on the other side (as if the array is glued with itself\n// on every side\nivec2 toroidal(in ivec2 c)\n{\n    ivec2 playingBoardLowerLeftCorner = MARGIN;\n    ivec2 playingBoardUpperRightCorner = ivec2(iResolution.xy)-MARGIN;\n    ivec2 o = c;\n    \n    // if the pixel's x coordinate is below the minimum x of the board, wrap it to the other side\n    if(c.x<playingBoardLowerLeftCorner.x) \n    {\n        o.x = playingBoardUpperRightCorner.x - (playingBoardLowerLeftCorner.x-c.x);\n    }\n    // if the pixel's x coordinate is above the maximum x of the board, wrap it to the other side\n    else if(c.x>playingBoardUpperRightCorner.x) \n    {\n        o.x = playingBoardLowerLeftCorner.x + (c.x - playingBoardUpperRightCorner.x);\n    }\n    // if the pixel's y coordinate is below the minimum y of the board, wrap it to the other side\n    if(c.y<playingBoardLowerLeftCorner.y) \n    {\n        o.y = playingBoardUpperRightCorner.y - (playingBoardLowerLeftCorner.y-c.y);\n    }\n    // if the pixel's y coordinate is above the maximum y of the board, wrap it to the other side\n    else if(c.y>playingBoardUpperRightCorner.y) \n    {\n        o.y = playingBoardLowerLeftCorner.y + (c.y - playingBoardUpperRightCorner.y);\n    }\n    return o;\n}\n// shortest distance in the toroidal space\nivec2 dist(in ivec2 a, in ivec2 b) \n{ \n    ivec2 playingBoardLowerLeftCorner = MARGIN;\n    ivec2 playingBoardUpperRightCorner = ivec2(iResolution.xy)-MARGIN;\n    ivec2 d = abs(a-b);\n    ivec2 d1 = min(abs(a-playingBoardLowerLeftCorner), abs(a-playingBoardUpperRightCorner));\n    ivec2 d2 = min(abs(b-playingBoardLowerLeftCorner), abs(b-playingBoardUpperRightCorner));\n    return min(d,d1+d2);\n}\n#endif\n\n// macro to save typing, returns the red value for the pixel with coordinates (coord + (X,Y)) as an integer\n#define P(X,Y) int(texelFetch(iChannel3, toroidal(coord+ivec2(X,Y)),0).x)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // the coordinates of our pixel in screen resolution as integers\n    ivec2 coord = ivec2(fragCoord.xy);\n    \n    // the sum of all neighbours (for each neighbour alive that sum increases by 1\n    int sum = P(-1, 1) + P( 0, 1) + P( 1, 1) + \n              P(-1, 0)            + P( 1, 0) +\n        \t  P(-1,-1) + P( 0,-1) + P( 1,-1);\n    \n    // whether the cell at this specific pixel is alive\n\tbool alive = P(0,0)==1;\n    \n    // if the cell is alive and has 2 or 3 live neighbours, it remains alive\n    // if the cell is allive and has less than 2 or more than 3 live neighbours it dies\n    // if the cell is dead and it has 3 live neighbours it beomces alive\n    bool result = alive ? (sum==3 || sum==2) : (sum==3);\n    \n    // half length of the sides of our brush (in pixels)\n    ivec2 r = ivec2(20);\n    // interaction: iMouse.z>0.0 only when a mouse button is down\n    if(iMouse.z>0.0)\n    {\n        // if |x-mx| < rx and |y-my| < ry -> make the cell live\n        // this is equivalent to: if (x,y) \\in [mx-rx, mx+rx]x[my-ry,my+ry]\n        // in other words, if this pixel is inside the rectangle centered at the mouse coordinates\n        // with sides length 2*rx and 2*ry then it becomes alive, otherwise it remains untouched\n        ivec2 d = dist(coord,ivec2(iMouse.xy));\n        result = all(lessThan(d,r)) ? true : result;\n    }\n    \n    // we play the game on a board with margins from each side:\n    ivec2 playingBoardLowerLeftCorner = MARGIN;\n    ivec2 playingBoardUpperRightCorner = ivec2(iResolution.xy)-MARGIN;\n    vec3 col;\n    // if the current pixel is outside the board just draw green\n    if(any(lessThan(coord,playingBoardLowerLeftCorner)) || any(greaterThan(coord,playingBoardUpperRightCorner)))\n    {\n        col = vec3(0.0,1.0,0.0);\n        fragColor = vec4(col,1.0);\n    }\n    else\n    {\n        // update the buffer for next step\n        vec3 col = vec3(result); // white color for live cells, black color for dead\n        fragColor = vec4(col,1.0);\n    }\n    \n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\n\tA 'tutorial' on how to code a simple version of Conway's game of life in shadertoy.\n\n\tFor more info on the game: https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\n\n\tConway's game of life is played on a 2d array, with each cell being either on (alive) or off(dead).\n\tEach cell has eight neighbours, the pixel with offset (0,0) is the current pixel:\n\t(-1, 1)   ( 0, 1)   ( 1, 1)\n    (-1, 0)   ( 0, 0)   ( 1, 0)\n\t(-1,-1)   ( 0,-1)   ( 1,-1)\n\t\n\tEach step all cells are updated based on the following rules:\n\t1. A dead cell becomes alive if it has exactly 3 neighbours that are alive.\n\t2. A cell that is alive and has less than 2 or more than 3 live neighbours dies.\n\n\tNote that each cell queries the old state of the array (from the current step only).\n\tSo even if we are using only bufferA, we are actually writing to a separate buffer, and \n\tat the end of the frame it is swapped with bufferA.\n\n\tWe will use bufferA to keep the current state of the array. Each frame would constitute one step.\n\tA cell would have a value of 1.0 if it is alive and 0.0 if it is dead.\n\n\tTOROIDAL 1 makes the terrain repeat infinitely (it's glued to itself at the edges)\n*/","name":"Common","description":"","type":"common"}]}