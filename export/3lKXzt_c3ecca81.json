{"ver":"0.1","info":{"id":"3lKXzt","date":"1583622876","viewed":128,"name":"Zeta heart for my wife.","username":"Logos","description":"08.03 - International Women's Day!\n\nI dedicate this shader to my wonderful wife Agnes (the pink one :D) <3\n\nYou have to be patient due to long converge time (300 seconds is ok)...","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["sdf","heart","zeta","riemann"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Robert Śmietana (Logos) - 08.03.2020\n// Bielsko-Biała, Poland, UE, Earth, Sol, Milky Way, Local Group, Laniakea :)\n\n// Dedicated to my wife Agness.\n\n\n//--- get animated nyan cat ---//\n\nvec4 getNyanCat(vec2 p)\n{\n    float t = floor(mod(16.0*iTime, 6.0));\n\tfloat w = 40.0/256.0;\n    \n    p = clamp(p, 0.0, 1.0);\n    p = vec2(clamp(p.x*w + t*w, 0.0, 1.0), p.y);\n    \n    return texture(iChannel1, p);\n}\n\n\n//--- main ---//\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    //-- initializations ---//\n    \n\tvec2 uv = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n\tvec3 c  = vec3(0.84 - 0.3*uv.y);\n\n    c.r    -= 0.2*uv.x;\n    c.g    -= 0.1*abs(uv.x);\n    c.b    -= 0.3*uv.y;\n    \n    uv.y   += 0.05;\n    uv     *= 1.8;\n    \n    \n    //--- draw hearts ---//\n    \n    int heart_count = int(data(0, 0).x);\n    for (int x = 0; x < heart_count; x++)\n    {\n        \n        //--- get heart ---//\n        \n        vec4 u = heart(x);\n     \n        \n\t    //--- animate it ---//\n    \n\t    float time\t\t= 0.1*iTime + 0.05*uv.x - 0.1*uv.y;\n\t    float t\t\t\t= fract(time);\n    \n\t    if (t > 0.8)\n    \t{\n            t = TAU * 5.0*(t - 0.8);\n            \n            u.z *= 1.0 + 0.5*sin(t);\n\t    }\n\n        \n        //--- construct heart elements ---//\n        \n        vec2 bp1, bp2, bp3;\n        vec2 bc1, bc2;\n        \n        setHeart(u.xy, u.z, u.w, bp1, bp2, bp3, bc1, bc2);\n        \n            \n        //--- paint heart ---//\n            \n        if (isInsideHeart(uv, bp1, bp2, bp3, bc1, bc2, u.z))\n        {\n\t\t\tfloat oot = float(x) / float(heart_count);\n            \n            oot = 1.0 - 0.5*oot;\n\n            c = vec3(0.9*oot + cos(iTime), 0.7*oot, 0.8 + 0.2*sin(iTime - float(x))*oot);\n            c = vec3(1.0);\n            break;\n        }\n    }    \n\n    \n    //--- draw nyan cats ---//\n\n    vec4 nc;\n    float time = 0.7*iTime;\n    float t = fract(time);\n\n    if (t > 0.8 && uv.x < 0.0)\n    {\n        t = PI * 5.0*(t - 0.8);\n\n        uv.y -= 0.5*abs(sin(t));\n    }\n    else if (t > 0.3 && t < 0.5 && uv.x > 0.0)\n    {\n        t = PI * 5.0*(t - 0.3);\n\n        uv.y -= 0.5*abs(sin(t));\n    }\n    \n    vec2 ncAgnes = vec2(0.8, 1.2) * (uv + vec2(1.6, 0.966));\n    nc = getNyanCat(ncAgnes);\n\tc = mix(c, 1.2*nc.xyz, nc.w);\n    \n    vec2 ncRobert = uv + vec2(-0.5, 1.0);\n    ncRobert.x = 1.0 - ncRobert.x;\n    nc = getNyanCat(ncRobert);\n\tc = mix(c, 0.6*nc.zxx, nc.w);\n\n    \n    //--- yield output color ---//\n    \n\tfragColor = vec4(c, 1.0); \n    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Calculation buffer.\n// Stores hearts.\n// Adds hearts with areas fit via Riemann zeta function (to cover all space).\n// Hearts do not collide of course :)\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    //--- data memory dimensions (40*40 = 1600 possible hearts) ---//\n    \n    int x = int(fragCoord.x);\n    if (x >= 40) return;\n\n    int y = int(fragCoord.y);\n\tif (y >= 41) return;\t\t// first row is for global variables \n    \n    \n    //--- initialization ---//\n    \n\tfloat initial_area = (1.0 + QUARTER_PI) * 0.12415775;\n\n    if (iFrame == 0)\n    {\n\t\tfragColor = vec4(0.0, initial_area, 0.0, 0.0);\n        \n        return;\n    }\n\n    \n    //--- generation of consecutive hearts ---//\n    \n    fragColor = data(x, y);\n        \n  \tint\t  visible_count = int(data(0, 0).x);\n    float object_area = initial_area * pow(5.0 + float(visible_count), -1.016);\n\n    float hr = 0.5*sqrt(object_area/(0.5 + QUARTER_PI));\n    float hx = 2.0*(hash12(fragCoord*1.11 + iTime)*iResolution.x/iResolution.y - 0.5);\n    float hy = 2.0*(hash12(fragCoord*2.39 - 0.3*iTime) - 0.5);\n    float ha = (atan(hy, hx));// TAU*hash12(fragCoord*2.222);\n    \n    \n    //-- construct new heart ---//\n\n    vec2 ap1, ap2, ap3;\n    vec2 ac1, ac2;\n    \n\tsetHeart(vec2(hx, hy), hr, ha, ap1, ap2, ap3, ac1, ac2);\n\n    \n    //--- check if new heart resides inside mother heart ---//\n    \n    if (!resideInsideMotherHeart(vec2(hx, hy))) return;\n    \n    \n    //--- check if new heart collides with other hearts ---//\n    \n    bool collide = false;\n    \n    for (int i = 0; i < visible_count; i++)\n    {\n        vec4 u = heart(i);\n        \n        vec2 bp1, bp2, bp3;\n        vec2 bc1, bc2;\n        \n        setHeart(u.xy, u.z, u.w, bp1, bp2, bp3, bc1, bc2);\n        \n\n        if (ifHeartHeart(ap1, ap2, ap3, bp1, bp2, bp3, ac1, ac2, bc1, bc2, hr, u.z))\n        {\n           collide = true;\n           break;\n        }\n    }\n\n    \n    //--- save the triangle if there was no collision ---//\n    \n    if (!collide)\n    {\n        if (x == 0 && y == 0)\t// increment visible_count\n        {\n            if (visible_count < 1600)\n            {\n                fragColor = vec4(float(visible_count+1), 0.0, 0.0, 0.0);\n            }\n        }\n            \n        \n        else if (y > 0)\t\t\t// save triangle\n        {\n            if (x == (visible_count % 40) && y == (1 + visible_count / 40))\n            {\n            \tfragColor = vec4(hx, hy, hr, ha);\n            }\n        }\n    }\n    \n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI\t\t\t3.1415926535\n#define TAU\t\t\t2.00 * PI\n#define HALF_PI\t\t0.50 * PI\n#define QUARTER_PI\t0.25 * PI\n\n#define data(x, y)\ttexelFetch(iChannel0, ivec2(x, y), 0)\n#define heart(i)\ttexelFetch(iChannel0, ivec2(i % 40, 1 + i / 40), 0)\n\n\n//--- auxiliary functions ---//\n\nfloat hash12(vec2 p)\n{\n\tfloat h = dot(p, vec2(127.1,311.7));\t\n    return fract(abs(sin(h)*43758.5453123));\n}\n\n\nbool isInsideBB(vec2 p, vec2 bbA, vec2 bbB)\n{\n  return\n    p.x >= min(bbA.x, bbB.x) &&\n    p.x <= max(bbA.x, bbB.x) &&\n    p.y >= min(bbA.y, bbB.y) &&\n    p.y <= max(bbA.y, bbB.y); \n}\n\n\nfloat cross2d(vec2 a, vec2 b)\n{\n\treturn a.x * b.y - a.y * b.x;\n}\n\n\nbool ifDiscDisc(vec2 c1, float r1, vec2 c2, float r2)\n{\n  vec2 p = c1 - c2;\n    \n  return dot(p, p) < (r1+r2) * (r1+r2);\n}\n\n\nbool ifSegmentSegment(vec2 l1a, vec2 l1b, vec2 l2a, vec2 l2b)\n{\n  float d = cross2d(l1a - l1b, l2a - l2b);\n  if (0.0 == d) return false;\n   \n  float l1c = cross2d(l1a, l1b);\n  float l2c = cross2d(l2a, l2b);\n   \n  vec2 intersectionPoint = vec2(\n      \t(l1c*(l2a.x-l2b.x) - l2c*(l1a.x-l1b.x)) / d,\n        (l1c*(l2a.y-l2b.y) - l2c*(l1a.y-l1b.y)) / d);\n  \n  return isInsideBB(intersectionPoint, l1a, l1b)\n      && isInsideBB(intersectionPoint, l2a, l2b);   \n}\n\n\nbool isInsideCircle(vec2 p, vec2 c, float r)\n{\n    vec2 pc = c - p;\n    \n    return dot(pc, pc) < r*r;\n}\n\n\nbool isInsideTriangle(vec2 p, vec2 A, vec2 B, vec2 C)\n{\n    vec3 s = vec3\n    (\n\t\tcross2d(B - A, p - A),\n\t\tcross2d(C - B, p - B),\n\t\tcross2d(A - C, p - C)\n    );\n\n    return all(greaterThan(s, vec3(0.0))) || all(lessThan(s, vec3(0.0)));\n}\n\n\nbool isInsideHeart(vec2 p, vec2 p1, vec2 p2, vec2 p3, vec2 c1, vec2 c2, float r)\n{\n    if (isInsideTriangle(p, p1, p2, p3)) return true;\n    \n    if (isInsideCircle(p, c1, r)) return true;\n    if (isInsideCircle(p, c2, r)) return true;\n        \n    return false;\n}\n\n\nbool ifTriangleTriangle(vec2 ap1, vec2 ap2, vec2 ap3, vec2 bp1, vec2 bp2, vec2 bp3)\n{\n    if (isInsideTriangle(ap1, bp1, bp2, bp3)) return true;    \n    if (isInsideTriangle(ap2, bp1, bp2, bp3)) return true;    \n    if (isInsideTriangle(ap3, bp1, bp2, bp3)) return true;\n    if (isInsideTriangle(bp1, ap1, ap2, ap3)) return true;\n    if (isInsideTriangle(bp2, ap1, ap2, ap3)) return true;\n    if (isInsideTriangle(bp3, ap1, ap2, ap3)) return true;\n\n    if (ifSegmentSegment(ap1, ap2, bp1, bp2)) return true;\n    if (ifSegmentSegment(ap2, ap3, bp1, bp2)) return true;\n    if (ifSegmentSegment(ap3, ap1, bp1, bp2)) return true;\n    if (ifSegmentSegment(ap1, ap2, bp2, bp3)) return true;\n    if (ifSegmentSegment(ap2, ap3, bp2, bp3)) return true;\n    if (ifSegmentSegment(ap3, ap1, bp2, bp3)) return true;\n    if (ifSegmentSegment(ap1, ap2, bp3, bp1)) return true;\n    if (ifSegmentSegment(ap2, ap3, bp3, bp1)) return true;\n    if (ifSegmentSegment(ap3, ap1, bp3, bp1)) return true;\n\n    return false;\n}\n\n\nbool ifDiscSegment(vec2 c, float r, vec2 a, vec2 b)\n{\n    vec2 ba = b - a;\n    vec2 ca = c - a;\n    float h = clamp(dot(ca, ba) / dot(ba, ba), 0.0, 1.0);\n\n    ba *=h;\n    ca -= ba;\n\n    return dot(ca, ca) < r*r;\n}\n\n\nbool ifDiscTriangle(vec2 d, float r, vec2 a, vec2 b, vec2 c)\n{\n    if (ifDiscSegment(d, r, a, b)) return true;\n    if (ifDiscSegment(d, r, b, c)) return true;\n    if (ifDiscSegment(d, r, c, a)) return true;\n\n    return false;\n}\n\n\nbool ifHeartHeart(vec2 ap1, vec2 ap2, vec2 ap3, vec2 bp1, vec2 bp2, vec2 bp3,\n                  vec2 ac1, vec2 ac2, vec2 bc1, vec2 bc2, float ra, float rb)\n{\n    if (ifDiscDisc(ac1, ra, bc1, rb)) return true;\n    if (ifDiscDisc(ac1, ra, bc2, rb)) return true;\n    if (ifDiscDisc(ac2, ra, bc1, rb)) return true;\n    if (ifDiscDisc(ac2, ra, bc2, rb)) return true;\n\n    if (ifDiscTriangle(ac1, ra, bp1, bp2, bp3)) return true;\n    if (ifDiscTriangle(ac2, ra, bp1, bp2, bp3)) return true;\n    if (ifDiscTriangle(bc1, rb, ap1, ap2, ap3)) return true;\n    if (ifDiscTriangle(bc2, rb, ap1, ap2, ap3)) return true;\n\n    if (ifTriangleTriangle(ap1, ap2, ap3, bp1, bp2, bp3)) return true;\n\n    return false;\n}\n\n\nvoid setHeart(vec2 p, float r, float rotation, out vec2 p1, out vec2 p2, out vec2 p3,\n              out vec2 c1, out vec2 c2)\n{\n    float ccr = sqrt(2.0)*r;\n    float A = HALF_PI;\n    \n    p1 = vec2(p.x + ccr * cos(rotation),         p.y + ccr * sin(rotation));\n    p3 = vec2(p.x + ccr * cos(rotation - 2.0*A), p.y + ccr * sin(rotation - 2.0*A));\n    p2 = vec2(p.x + ccr * cos(rotation - 3.0*A), p.y + ccr * sin(rotation - 3.0*A));\n    c1 = vec2(p.x +   r * cos(rotation + 2.0*A + QUARTER_PI), p.y + r * sin(rotation + 2.0*A + QUARTER_PI));\n    c2 = vec2(p.x +   r * cos(rotation + 2.0*A + HALF_PI + QUARTER_PI), p.y + r * sin(rotation + 2.0*A + HALF_PI + QUARTER_PI));\n}\n\n\nbool resideInsideMotherHeart(vec2 p)\n{\n    if (p.x - p.y > +0.5*sqrt(2.0)) return false;\n    if (p.x + p.y < -0.5*sqrt(2.0)) return false;\n\tif (isInsideCircle(p, vec2( 0.25, 0.25)*sqrt(2.0), 0.5)) return true;\n\tif (isInsideCircle(p, vec2(-0.25, 0.25)*sqrt(2.0), 0.5)) return true;\n\tif (p.y > 0.0) return false;\n    \n    return true;\n}\n","name":"Common","description":"","type":"common"}]}