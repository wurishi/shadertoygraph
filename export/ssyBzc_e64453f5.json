{"ver":"0.1","info":{"id":"ssyBzc","date":"1662781803","viewed":117,"name":"10021","username":"sqraaa","description":"Art ^^ ! Just for the mega fun GLSL","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["wave","music","art"],"hasliked":0,"parentid":"7dGfDm","parentname":"10018"},"renderpass":[{"inputs":[{"id":"XsXGzn","filepath":"/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3","previewfilepath":"/media/ap/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define u_resolution iResolution \n#define jtextureId_texture iChannel0\n#define texture2D texture\n#define u_time iTime\n#define SHADERMCFX  1\n\n\nfloat movex = 0.0;\nfloat movey = 0.0;\nfloat scalexy = 1.0;\n\n\n//demo\n const float freq_range  =1.0;\n const float radius = 0.22;\n const float brightness = 0.21;\n const float speed  = 0.5;\n//demo\n\n\n//const\n#define PI  3.14159265359\n#define BEATMOVE 1\n\n\n\n//convert HSV to RGB\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat getfrequency(float x) {\n  return texture2D(jtextureId_texture, vec2(floor(x * freq_range + 1.0) / freq_range, 0.25)).x  + 0.06;\n}\n\nfloat getfrequency_smooth(float x) {\n  float index = floor(x * freq_range) / freq_range;\n    float next = floor(x * freq_range + 1.0) / freq_range;\n  return mix(getfrequency(index), getfrequency(next), smoothstep(0.0, 1.0, fract(x * freq_range)));\n}\n\nfloat getfrequency_blend(float x) {\n    return mix(getfrequency(x), getfrequency_smooth(x), 0.35);\n}\n\nvec3 doHalo(vec2 fragment, float radius) {\n  float dist = length(fragment);\n  float ring = 1.0 / abs(dist - radius);\n  \n  float b = dist < radius ? brightness * 0.3 : brightness;\n  \n  vec3 col = vec3(0.0);\n  \n  float angle = atan(fragment.x, fragment.y);\n  col += hsv2rgb( vec3( ( angle + u_time * 0.25 ) / (PI * 2.0), 1.0, 1.0 ) ) * ring * b;\n  \n  float frequency = max(getfrequency_blend(abs(angle / PI)) - 0.02, 0.0);\n  col *= frequency*1.2;\n  \n  // Black halo\n  col *= smoothstep(radius * 0.5, radius, dist);\n  \n  return col;\n}\n\nvec3 doLine(vec2 fragment, float radius, float x) {\n  vec3 col = hsv2rgb(vec3(x * 0.23 + u_time * 0.12, 1.0, 1.0));\n  \n  float freq = abs(fragment.x * 0.1);\n  \n  col *= (1.0 / abs(fragment.y)) * brightness * getfrequency(freq); \n\n  \n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv =  fragCoord.xy / u_resolution.xy; \n    vec2 fragPos = fragCoord.xy / u_resolution.xy;\n   fragPos = (fragPos - 0.5) * 2.0;\n    fragPos.x *= u_resolution.x / u_resolution.y;\n    \n    \n     fragPos.x =  fragPos.x - movex/2.0;\n     fragPos.y =  fragPos.y - movey;\n     \n     fragPos = fragPos / scalexy;\n  \n  vec3 color = vec3(0.0134, 0.052, 0.1);\n  color += doHalo(fragPos, radius);\n\n    float c = cos(u_time * speed);\n    float s = sin(u_time * speed);\n    vec2 rot = mat2(c,s,-s,c) * fragPos;\n \n  \n  color += max(luma(color) - 1.0, 0.0);\n  \n\n    \n  fragColor = vec4(color, 0.0);\n}\n\n\n\n\n#ifndef SHADERMCFX\nvoid main() { \n    vec2 fragCoord = gl_FragCoord.xy; \n    vec2 uv =  fragCoord / u_resolution; \n    vec4 color = vec4(0.0);\n    mainImage(color, fragCoord);\n    gl_FragColor = vec4(color.rgb,0.0);\n}\n#endif\n","name":"Image","description":"","type":"image"}]}