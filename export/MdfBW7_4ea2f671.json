{"ver":"0.1","info":{"id":"MdfBW7","date":"1497132900","viewed":182,"name":"1D Automata","username":"mhnewman","description":"CLICK ME!\n* Click the LEFT SIDE to randomly generate a new rule\n* Click the RIGHT SIDE to keep the same rule and randomly generate a new initial condition\nSee the code for a more detailed description","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["1d","automata","life","cellular","automaton","artificial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n#################\n##             ##\n##  CLICK ME!  ##\n##             ##\n#################\n\n * Click the LEFT SIDE to randomly generate a new rule\n\n * Click the RIGHT SIDE to keep the same rule and\n   randomly generate a new initial condition\n\n\nABOUT THE RULES:\n\nEach rule can have 2, 3, 4, or 5 states.\nStates are colored black, white, red, green, and blue respectively.\n\nEach rule defines an output state for every possible triple of three states.\nThe states of each pixel are determined by its previous state and the previous\nstates of its left and right neighbors.\n*/\n\n//#define ZOOM_IN\n\nconst mat4 m = mat4(1.0, 16.0 / 3.0, 3.75, 0.0,\n                    5.0 / 12.0, -20.0 / 3.0, -3.875, 0.0,\n                    -0.5, 8.0 / 3.0, 1.25, 0.0,\n                    1.0 / 12.0, -1.0 / 3.0, -0.125, 0.0);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n#ifdef ZOOM_IN\n    vec4 s = texture(iChannel0, (floor(0.25 * fragCoord) + 0.5) / iResolution.xy);\n#else\n    vec4 s = texture(iChannel0, fragCoord / iResolution.xy);\n#endif\n    s.y = s.x * s.x;\n    s.zw = s.y * s.xy;\n    fragColor = m * s;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define p fragCoord\n#define r iResolution.x\n\n#define states floor(2.0 + 4.0 * hash(s.y - 1.0))\n\n#define sample(x, y) texture(iChannel0, vec2(x, y) / iResolution.xy)\n\nfloat hash(float f) {\n    vec2 v = fract(f * vec2(443.8975, 397.2973));\n    v += dot(v.xy, v.yx + 19.19);\n    return fract(v.x * v.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (p.y < 1.0) {\n        vec4 s = sample(p.x, p.y);\n        if (iFrame == 0 || (iMouse.z < 0.5 && s.z > 0.5)) {\n            if (iFrame == 0 || iMouse.x < 0.5 * r)\n                s.y = hash(0.012345 * float(iFrame) + 0.11);\n            s.x = floor(hash(fragCoord.x + 0.02468 * float(iFrame)) * states);\n        } else {\n            float t = s.y + s.x +\n                      5.0 * sample(mod(p.x + 1.0, r), p.y).x +\n                      25.0 * sample(mod(p.x + r - 1.0, r), p.y).x;\n            s.x = floor(hash(t) * states);\n        }\n        s.z = iMouse.z;\n        fragColor = s;\n    } else {\n        fragColor = sample(p.x, p.y - 1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}