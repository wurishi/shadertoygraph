{"ver":"0.1","info":{"id":"ft23Ry","date":"1624146230","viewed":104,"name":"Line Distance Heron's Formula","username":"Yusef28","description":"https://www.cuemath.com/herons-formula/\nThe line extends to infinitely beyond the line points so it's not a \"segment\".","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","triangle","line","area","semi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//Update 29-05-2021: 1 sqrt Heron's version from IQ added\n\n#define BG   vec3(0.0745, 0.0862, 0.1058)*0.95;\n#define COL0 vec3(236./255., 200./255., 146./255.)*0.7\n#define COL1 vec3(30./255.,132./255.,127./255.)*1.3\n#define COL3 vec3(1.)\n\n\n//based on one by 4rknova: https://www.shadertoy.com/view/Ml23Dt\nfloat circleUnfilled(float r, vec2 p){\n\n    float eps = 1./min(iResolution.x, iResolution.y);\n    float in_out_cut = 0.01;\n    return smoothstep(-eps, +eps, abs(r - length(p))-in_out_cut );\n    }\n\n\nfloat DistToLine(vec2 p, vec2 start, vec2 ende){\n    //area of a triangle is half the base X the height\n    //we know this because if we take a square and cut it in\n    //half on the diagonal we get half two triangles we can\n    //then place side by side. This gives us a triangle\n    //with a base = 2 X the length of one side of the square\n    //this works for any triangle\n    \n    //here base is the distance between two points on the line in question\n    float base = length(start - ende);\n    \n    //the other two sides then are\n    float side2 = length(start-p);\n    float side3 =  length(ende-p);\n    \n    //with all three sides known we calculate semi perimeter (s)\n    //https://www.cuemath.com/measurement/area-of-equilateral-triangle/\n    float s = (base+side2+side3)/2.;\n    //Then area of triangle using Heron's formula\n    float area = sqrt(s*(s-base)*(s-side2)*(s-side3));\n    \n    //cool\n    //then with area we find the height of the triangle\n    //and in our case that means the distance of our input point\n    //to the base (the shortest distance to be exact)\n    \n    //IQ's Heron's Version with only 1 squareroot\n    //https://iquilezles.org/articles/trianglearea/trianglearea.htm\n    //https://iquilezles.org/blog/?p=1579\n    vec2 pp = start - ende;\n    vec2 si2 = start-p;\n    vec2 si3 = ende-p;\n    \n    float A = pp.x*pp.x + pp.y*pp.y;\n    float B = si2.x*si2.x + si2.y*si2.y;\n    float C = si3.x*si3.x + si3.y*si3.y;\n    float s2 = (2.*A*B + 2.*B*C + 2.*C*A - A*A - B*B - C*C)/16.;\n    area = sqrt(s2);\n    \n    //a = (h*b)/2. -> (a*2.)/b = h\n    float dist = (area*2.)/base;\n    return dist;\n\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)*2./iResolution.y;\n\n\n    \n    vec2 lineA = vec2(0.4, 0.5);\n    vec2 lineB = vec2(-0.5, -0.5);\n    \n    //and let's animate them because that's cool\n    lineA += vec2(sin(iTime/2.),cos(iTime/2.))/5.;\n    lineB += vec2(sin(iTime/2.+9.),cos(iTime/2.+9.))/5.;\n    //let's plot the points first so we know what we're talking about\n    float pointA = circleUnfilled(0.03, uv-lineA);\n    float pointB = circleUnfilled(0.03, uv-lineB);//smoothstep(0.05, 0.055, length(uv-lineB));\n    \n    vec3 col = BG;\n    col = mix(col, COL0, 1.0-pointA);\n    col = mix(col, COL0, 1.0-pointB);\n    \n    //now let's get our line\n    float dists = DistToLine(uv, lineA, lineB);\n    float line = smoothstep(0.008, 0.01, dists);\n    col = mix(col, COL1, 1.0-line);\n    \n    //vignette\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    \n    vig = pow(vig, 0.15); // change pow for modifying the extend of the  vignette\n\n    fragColor = vec4(col*vig,1.0);\n}","name":"Image","description":"","type":"image"}]}