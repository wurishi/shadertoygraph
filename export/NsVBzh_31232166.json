{"ver":"0.1","info":{"id":"NsVBzh","date":"1657821978","viewed":135,"name":"A Dyson Sphere","username":"magix","description":"This is my first time doing Raymarching and SDF's, so it may be a bit messy.\n\nI think the code could be optimized a lot so if you have any idea, I'll appreciate it.\n\nAny feedback or recomendations are welcome.\n\nHope you like it!\n","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdfs","dysonsphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST 0.01\n\n#define PI 3.14159265359\n\nvec2 Noise(vec2 p)\n{\n\tvec3 a = fract(p.xyx * vec3(123.34, 234.45, 345.56));\n\ta += dot(a, a + 34.45f);\n\treturn fract(vec2(a.x * a.y, a.y * a.z));\n}\n\nfloat d2r(float a)\n{\n    return a*(PI/180.);\n}\n\nmat2 Rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec2 opRevolution( in vec3 p, float w )\n{\n    return vec2( length(p.xz) - w, p.y );\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdBox(vec2 pos, vec2 r)\n{\n\tvec2 q = abs(pos) - r;\n\treturn length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nfloat sdRing(vec3 pos, float r, float height, float thickness)\n{\n    pos.zy = opRevolution(pos, r);\n    return sdBox(vec2(pos.z, pos.y), vec2(thickness, height));\n}\n\nfloat InnerSphereA(vec3 p, vec3 sp, float r, float startAngle)\n{    \n    vec3 rp = sp;\n    rp.yz *= Rot(0.);\n    float rd1 = sdRing(rp, r, 0.025, 0.015);\n    \n    vec3 rp2 = sp;\n    rp2.yz *= Rot(d2r(startAngle + 45.));\n    float rd2 = sdRing(rp2, r, 0.025, 0.015);\n \n    vec3 rp3 = sp;\n    rp3.yz *= Rot(d2r(startAngle + 90.));\n    float rd3 = sdRing(rp3, r, 0.025, 0.015);\n    \n    vec3 rp4 = sp;\n    rp4.yz *= Rot(d2r(startAngle + 135.));\n    float rd4 = sdRing(rp4, r, 0.025, 0.015);\n \n    float d = min(rd1, rd2);\n    d = min(d, rd3);\n    d = min(d, rd4);\n\n    return d;\n}\n\nfloat InnerSphereB(vec3 p, vec3 sp, float r, float startAngle)\n{\n    vec3 rp = sp;\n    rp.xy *= Rot(d2r(startAngle + 91.));\n    float rd1 = sdRing(rp, r, 0.025, 0.015);\n    \n    vec3 rp2 = sp;\n    rp2.xy *= Rot(d2r(startAngle + 45.));\n    float rd2 = sdRing(rp2, r, 0.025, 0.015);\n \n    vec3 rp3 = sp;\n    rp3.xy *= Rot(d2r(startAngle + 90.));\n    float rd3 = sdRing(rp3, r, 0.025, 0.015);\n    \n    vec3 rp4 = sp;\n    rp4.xy *= Rot(d2r(startAngle + 135.));\n    float rd4 = sdRing(rp4, r, 0.025, 0.015);\n    \n    float d = min(rd1, MAX_DIST);\n    d = min(d, rd2);\n    d = min(d, rd3);\n    d = min(d, rd4);\n    \n    return d;\n}\n\nfloat DysonRings(vec3 p, vec3 sp, float r, float startAngle)\n{\n    float innerSphereA = InnerSphereA(p, sp, r, startAngle);\n    float innerSphereB = InnerSphereB(p, sp, r, startAngle);\n    \n    return min(innerSphereA, innerSphereB);\n}\n\nfloat Map(vec3 p)\n{\n    float t = iTime;\n    \n    vec3 sp = p;\n    float sd = sdSphere(sp, 0.3);\n    sp.xz *= Rot(t*.5);\n\n    float innerSphere = DysonRings(p, sp, 1., 0.);\n    float outterSphere = DysonRings(p, sp, 1.5, 0.);\n    \n    float d = min(sd, innerSphere);\n    d = min(d, outterSphere);\n\n    return d;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = Map(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        Map(p-e.xyy),\n        Map(p-e.yxy),\n        Map(p-e.yyx));\n        \n    return normalize(n);\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd)\n{\n    float dO = 0.;\n    \n    vec3 p = vec3(0);\n    for(int i = 0; i < MAX_STEPS; ++i)\n    {\n        p = ro + rd*dO;\n        float dS = Map(p);\n        dO += dS;\n        \n        if(dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    \n    return vec4(dO, GetNormal(p));\n}\n\n\nfloat GetLight(vec3 p)\n{\n    vec3 lightPos = vec3(0,1,-4);\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    float dif = dot(n, l);\n    float d = RayMarch(p + n*SURF_DIST*2., l).x;\n    \n    if(d < length(lightPos)) dif = 0.25;\n    \n    return dif;\n}\n\n// Voronoi but taking the points as stars\nvec3 Background(vec2 uv)\n{\n    float m = 0.;\n\tfloat minDist = MAX_DIST;\n    \n    uv.x /= iResolution.x / iResolution.y;\n    \n    for (int i = 0; i < 150; ++i)\n\t{\n\t\tvec2 n = Noise(vec2(i));\n\t\tvec2 p = vec2(n.x-.5, n.y-.5);\n\t\tfloat d = length(uv - p);\n\t\tm += smoothstep(0.0005, 0.0004, d);\n\n\t\tif (d < minDist)\n\t\t{\n\t\t\tminDist = d;\n\t\t}\n\t}\n    \n    return vec3(m);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //-1 to 1 uv's\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Background\n    vec3 col = Background(uv);\n    \n    // Simple camera\n    vec3 ro = vec3(0,0,-3.5);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n    \n    // Raymarch the scene\n    vec4 raymarch = RayMarch(ro, rd);\n    float d = raymarch.x;\n    vec3 normal = raymarch.yzw;\n    \n    // If we hit something, apply color and light\n    if(d < MAX_DIST)\n    {    \n        vec3 p = ro + rd*d;\n        float len = length(p);\n        \n        float diff = dot(normalize(-p), normal);\n    \n        vec3 blue = vec3(0.05,0.95,1.);\n        col = vec3(diff) * blue;\n        \n        col = mix(col, blue, 1.-smoothstep(0.31,0.312,len));\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}