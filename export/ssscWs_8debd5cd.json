{"ver":"0.1","info":{"id":"ssscWs","date":"1642946766","viewed":118,"name":"Lots of beziers speed test","username":"aidanHall","description":"The mouse.y position sets the size of the grid - ranging from 2 to 100  => 4  to 10,000 curves\n\nUsing a fast approximation of the distance field for a quadratic Bezier curve.\nFrom http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","distancefield","bezier"],"hasliked":0,"parentid":"XsX3zf","parentname":"Quadratic Bezier Stroke"},"renderpass":[{"inputs":[],"outputs":[],"code":"float det(vec2 a, vec2 b) { return a.x * b.y - b.x * a.y; }\n\nvec2 closestPointInSegment( vec2 a, vec2 b )\n{\n  vec2 ba = b - a;\n  return a + ba*clamp( -dot(a,ba)/dot(ba,ba), 0.0, 1.0 );\n}\n\n// From: http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\nvec2 get_distance_vector(vec2 b0, vec2 b1, vec2 b2) {\n  float a=det(b0,b2), b=2.0*det(b1,b0), d=2.0*det(b2,b1); // 𝛼,𝛽,𝛿(𝑝)\n  //if( abs(2.0*a+b+d) < 1000.0 ) return closestPointInSegment(b0,b2);\n  float f=b*d-a*a; // 𝑓(𝑝)\n  vec2 d21=b2-b1, d10=b1-b0, d20=b2-b0;\n  vec2 gf=2.0*(b*d21+d*d10+a*d20);\n  gf=vec2(gf.y,-gf.x); // ∇𝑓(𝑝)\n  vec2 pp=-f*gf/dot(gf,gf); // 𝑝′\n  vec2 d0p=b0-pp; // 𝑝′ to origin\n  float ap=det(d0p,d20), bp=2.0*det(d10,d0p); // 𝛼,𝛽(𝑝′)\n  float t=clamp((ap+bp)/(2.0*a+b+d), 0.0 ,1.0);\n  return mix(mix(b0,b1,t),mix(b1,b2,t),t); // 𝑣𝑖=𝑏(𝑡̅)\n\n}\n\nfloat approx_distance(vec2 p, vec2 b0, vec2 b1, vec2 b2) {\n  return length(get_distance_vector(b0-p, b1-p, b2-p));\n}\n\n//  vec2 b1 = vec2(0.5, .75 + .1*sin(iTime)) * iResolution.xy;\n\t\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 xy = fragCoord.xy;\n    float d=1.;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n \tvec2 c0  ;\n\tvec2 c1;//\n\tvec2 c2 ;\n    vec2 mouse;\n    mouse.x = (iMouse.x/iResolution.y)/4.0+0.01;\n    mouse.y = (iMouse.y/iResolution.y)/4.0+0.01;\n    float size=2.0 + 98.0*iMouse.y/iResolution.y;\n    float spacing =9./size;\n    for (float y=1.;y<=size;y++){\n        for (float x=1.;x<=size*1.2;x++){\n            vec2 c0 = vec2(0.15*spacing*x, 0.1*spacing*y) ;\n            vec2 c1 =c0 + vec2(0.15*spacing*sin(4.0*iTime*y/size ),- 0.1*spacing*sin(4.0*iTime*x/size));//\n            vec2 c2 = c0+vec2(.1*spacing,0) ;\n            d = min( approx_distance(uv, c0, c1, c2),d );\n        }\n    }\n\tfloat thickness=1.0 ;//(100.-size)/20.0;\n\tfloat antialiasThickness=2.0;\n    float density=smoothstep(thickness/iResolution.y, \n                        (thickness+antialiasThickness)/iResolution.y, d);\n    fragColor = vec4(vec3(density),\n                        density);\n}","name":"Image","description":"","type":"image"}]}