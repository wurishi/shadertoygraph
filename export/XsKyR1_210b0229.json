{"ver":"0.1","info":{"id":"XsKyR1","date":"1521036795","viewed":344,"name":"Wind barbs","username":"Ultraviolet","description":"Standard quiver plot is limited in terms of amplitude: long arrows tend to cover large area, covering other arrows and making their location ambiguous.\nFor that reason, wind is classically represented using wind barbs.","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["2d","field","quiver","wind","barbs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Random velocity quiver\" by Ultraviolet. https://shadertoy.com/view/XdtcDf\n// 2018-03-14 13:25:41\n\n#define NB\t20.\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1., 0., 1. );\n    rgb = rgb*rgb*(3.-2.*rgb);\n    return c.z * mix( vec3(1.), rgb, c.y);\n}\n\nvec2 cart2pol(vec2 v)\n{\n    float amplitude = length(v);\n    float phase = atan(v.y,v.x);\n    \n    return vec2(amplitude, phase);\n}\n\nvec2 pol2cart(vec2 v)\n{\n    return v.x*vec2(cos(v.y), sin(v.y));\n}\n\nvec3 speed2col(vec2 speed)\n{\n    speed = cart2pol(speed);\n    return hsv2rgb(vec3(speed.y/2./PI, 0.5, speed.x));\n}\n\nvec2 avgSpeed(vec2 uv, vec2 cell)\n{\n    vec2 s = vec2(0.);\n    float  Ni=cell.x*iResolution.x, Nj=cell.y*iResolution.y;\n    \n    for(float i=0.; i<Ni; ++i)\n    {\n        for(float j=0.; j<Nj; ++j)\n        {\n    \t\ts += texture(iChannel0, uv+vec2(i,j)/vec2(Ni,Nj)*cell).xy;\n        }\n    }\n    \n    return s/Ni/Nj;\n}\n\nvoid mainImage( out vec4 Output, in vec2 C )\n{\n\tvec2 r  = iResolution.xy;\n\tvec2 uv = C / r;\n    \n    vec2 ratio = vec2(1., r.y/r.x);\n    vec2 uv_ = floor(uv*NB*ratio)/NB/ratio;\n    vec2 s = avgSpeed(uv_, ratio/NB);\n    \n    vec3 col = vec3(1.);    \n    \n    float dx = .5/NB;\n    \n    vec2 O = vec2(dx);\n    vec2 X = normalize(s)*dx*.7;\n    vec2 Y = X.yx*vec2(-1., 1.);\n    \n    vec2 uv_c = (uv-uv_)*ratio;\n    \n    int k = int(floor(length(s)/5.));\n    \n    if(k == 0)\n    {\n\t\tDRAW_C(Circle(O, dx*.2),uv_c,vec3(0.1),1.,col);\n\t\tDRAW_C(Circle(O, dx*.1),uv_c,vec3(0.1),.8,col);\n    }\n    else\n    {\n        if(k > 9)\n\t\t\tDRAW_C(Segment(O, O-X*1.3),uv_c,vec3(0.1),1.,col);\n        else\n\t\t\tDRAW_C(Segment(O, O-X),uv_c,vec3(0.1),1.,col);\n            \n        float pos = 1.;\n        \n        while(k > 9)\n        {\n            DRAW(Tri(O-X*pos, O-X*pos-X*.4-Y*.4, O-X*pos-X*.4),uv_c,vec3(0.1),col);\n            k -= 10;\n            pos -= 0.22;\n        }\n        while(k > 1)\n        {\n            DRAW_C(Segment(O-X*pos, O-X*pos-X*.3-Y*.3),uv_c,vec3(0.1),1.,col);\n            k -= 2;\n            pos -= 0.22;\n        }\n        while(k > 0)\n        {\n            DRAW_C(Segment(O-X*pos, O-X*pos-X*.15-Y*.15),uv_c,vec3(0.1),1.,col);\n            k -= 1;\n            pos -= 0.22;\n        }\n    }\n    \n    \n    \n        \n    Output = vec4(col, 0.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PERIOD\t1.\n#define EPSILON\t0.05\n\n#define SPEED\t.5\n#define SCALE\t.5\n\n// from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec3 hash(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0*fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n// from https://www.shadertoy.com/view/Xsl3Dl\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\n\nvec2 speed(vec2 uv)\n{\n    float ratio = iResolution.y/iResolution.x;\n    uv = uv*10.*vec2(1., ratio);\n    return vec2(noise(vec3(uv*SCALE, iTime*SPEED)), noise(vec3(uv*SCALE + vec2(12.10135, 1354.2435), iTime*SPEED)));\n}\n\nvoid mainImage( out vec4 O, in vec2 C )\n{\n\tvec2 r  = iResolution.xy;\n\tvec2 uv = C / r;\n    vec2 s = speed(uv);\n    \n    //s = vec2(cos(iTime), sin(iTime));\n    s *= 150.;\n    \n    O = vec4(s, 0., 0.);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI\t3.1415926535\n\n//---------------------------------------\n// Utils\n\n\nfloat angle(vec2 p)\n{\n    return atan(p.y, p.x);\n}\n\nfloat angle(vec2 p0, vec2 p1)\n{\n    float a =  angle(p1) - angle(p0);\n    a = mod(a-PI, 2.*PI)-PI;\n    \n    return a;\n}\n\n\n//---------------------------------------\n// Segment\n\nstruct Segment\n{\n    vec2 A;\n    vec2 B;\n};\n\nvec2 getPt(Segment c, float t)\n{\n    return mix(c.A, c.B, t);\n}\n\nfloat dist(Segment s, vec2 p)\n{\n\tvec2 pa = p-s.A, ba = s.B-s.A;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n//---------------------------------------\n// Circle\n\nstruct Circle\n{\n    vec2 ctr;\n    float rad;\n};\n\nvec2 getPt(Circle c, float t)\n{\n    return c.ctr + c.rad*vec2(cos(t*PI*2.), sin(t*PI*2.));\n}\n    \nfloat dist(Circle c, vec2 p)\n{\n    return (length(c.ctr-p)-c.rad);\n}\n\n\n//---------------------------------------\n// Triangle\n\nstruct Tri\n{\n    vec2 A;\n    vec2 B;\n    vec2 C;\n};\n\nfloat winding(Tri q,vec2 p)\n{\n    float w = 0.0;\n    \n    w += angle(q.A-p, q.B-p);\n    w += angle(q.B-p, q.C-p);\n    w += angle(q.C-p, q.A-p);\n    \n    return w;\n}\n\nbool isInside(Tri q,vec2 p)\n{\n    float w = winding(q, p);\n    return abs(w)>0.001;\n}\n\nfloat dist(Tri q, vec2 p)\n{\n    float d = min(min(dist(Segment(q.A, q.B), p), \n                      dist(Segment(q.B, q.C), p)),  \n                  dist(Segment(q.C, q.A), p));\n    if(isInside(q,p))\n        d *= -1.;\n    return d;\n}\n\n\n\n\n//---------------------------------------\n// Drawing Macros\n\n// draw the inside of the shape\n#define DRAW(O,P,C,CC)\tCC=mix(CC,C,mix(1.,0.,clamp(dist(O,P)*iResolution.x*2., -1., 1.)*.5+.5))\n\n// draw the contour of the shape \n#define DRAW_C(O,P,C,W,CC)\tCC=mix(CC,C,mix(1.,0.,clamp(abs(dist(O,P))*iResolution.x*2.-W, -1., 1.)*.5+.5))\n\n// draw the contour of the shape with alpha\n#define DRAW_CA(O,P,C,W, CC)\tCC=mix(CC,C.rgb,(mix(1.,0.,clamp(abs(dist(O,P))*iResolution.y/2. -  W, -1., 1.)*.5+.5))*(1.-C.a))\n\n\n\n\n","name":"Common","description":"","type":"common"}]}