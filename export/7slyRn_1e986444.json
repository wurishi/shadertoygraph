{"ver":"0.1","info":{"id":"7slyRn","date":"1641616899","viewed":249,"name":"super simple shooting star","username":"hlw","description":"glowing dot moving along a sinusoidal path, illuminated by a glowy tail. Change macro values to modify visual attributes.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["star","sinusoidal","shootingstar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// increase to horizontally compress star path\n#define SQUISH_H        4.5\n// precondition: abs(SQUISH_V) <= 1.0\n// increase in magnitude to vertically expand star path\n#define SQUISH_V        0.3\n// increase to widen star tail\n#define LINERADIUS      0.005\n// increase to compress star body (including glow)\n#define CENTERPOWER     300.\n// precondition: TWINKLECAP >= 0.0\n// increase to increase maximum twinkle size\n#define TWINKLECAP      200.\n// precondition: CENTERBASE > 1.0\n// increase to make glow more solid (less glowy) \n#define CENTERBASE      1.5\n// decrease to shorten star tail\n#define ERASEPOWER      -3.\n// precondition: ERASEBASE <= 1.0\n// decrease to shorten star tail\n#define ERASEBASE       0.5\n// precondition: 0.0 < R <= 1.0\n#define R               1.0\n// precondition: 0.0 < G <= 1.0\n#define G               1.0\n// precondition: 0.0 < B <= 1.0\n#define B               1.0\n// precondition: 0.0 <= XPOS <= 1.0\n#define XPOS            1.0\n// precondition: 0.0 <= YPOS <= 1.0\n#define YPOS            0.5\n// precondition: SPEED != 0\n// increase to speed up star oscillation\n#define SPEED           1.5\n// precondition: ANTIALIAS >= 0 and ANTIALIAS <= LINERADIUS / 2\n#define ANTIALIAS       1.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    // vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.y;\n    \n    // Coords of sinusoidal curve\n    vec2 xy = vec2(uv.x, SQUISH_V * cos(SQUISH_H * uv.x + SPEED * iTime) + YPOS);\n    \n    // Color pixels on curve\n    // float aboveBottom = step(xy.y - LINERADIUS, uv.y);\n    // float belowTop = step(uv.y, xy.y + LINERADIUS);\n    // float isLeft = step(uv.x, XPOS);\n    float edgeTransW = ANTIALIAS / iResolution.y;\n    float abEdge = xy.y - LINERADIUS;\n    float aboveBottom = smoothstep(abEdge - edgeTransW, abEdge + edgeTransW, uv.y);\n    float belowTop = smoothstep(uv.y - edgeTransW, uv.y + edgeTransW, xy.y + LINERADIUS);\n    float isLeft = smoothstep(uv.x - edgeTransW, uv.x + edgeTransW, XPOS);\n    float bc = aboveBottom * belowTop * isLeft;\n    // vec3 baseColor = vec3(R * bc, G * bc, B * bc); \n    \n    // Coords of point in H center on curve\n    vec2 cen = vec2(XPOS, SQUISH_V * cos(SQUISH_H * XPOS + SPEED * iTime) + YPOS);\n    \n    // Color pixels on or near center\n    float cDistance = distance(uv, cen);\n    float twinkle = abs(fract(iTime) - 0.5);\n    float cd = pow(CENTERBASE, CENTERBASE - (CENTERPOWER - TWINKLECAP * twinkle) * cDistance);\n    \n    // Erasing color of pixels far from center\n    float chDistance = abs(XPOS - uv.x);\n    float ed = pow(ERASEBASE, ERASEPOWER * chDistance) - 1.;\n\n    // vec3 col = baseColor + vec3(R * cd, G * cd, B * cd) - vec3(ed, ed, ed);\n    vec3 col = vec3(R, G, B) * (bc + cd) - ed;\n\n    // Output to screen\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}