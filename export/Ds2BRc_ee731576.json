{"ver":"0.1","info":{"id":"Ds2BRc","date":"1690560748","viewed":309,"name":"Lens flare using 3d coordinates","username":"Toiture","description":"A Lens flare shader that use 3d coordinates instead of uv. ","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["sun","postprocessing","lensflare"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//TODO : add chromatic abberation and dirty lens\n/*\n    Feel free to use this code for your own shader. \n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=.5;\n    uv.x*=iResolution.x/iResolution.y ;\n    \n    float time = iTime*0.5 ;\n    \n    vec3 rd = normalize(vec3(uv.x+sin(time-90.)*0.5,uv.y-0.2, 1.)) ;\n    vec3 focus = normalize(vec3(0.+sin(time-90.)*0.5 ,-0.2,1.)) ;\n    \n    vec3 sundir= normalize(vec3(-0.,0.,1.));\n    vec3 col = vec3(0.);\n    \n    //sun\n    col +=0.05/length(rd-sundir)*vec3(1.) ;\n    //sun halo\n    col+=0.06/length(sundir-rd)*0.1*vec3(1.,0.5,0.) ;\n    \n    //focus/sundir vector\n    vec3 dir = sundir-focus;\n    float size = length(dir) ;\n    \n    //define Lens size and step length\n    float lenses = 3. ;\n    float stepL = size*3./lenses ;\n    \n    //firts Lens \n    vec3 pos = sundir+dir*stepL*0.5;\n    vec3 roP = normalize(pos) ;\n    \n    float halo = smoothstep(0.5,0.49,length(rd-roP)/0.5);\n    halo-=smoothstep(0.5,0.4,length(rd-roP)/0.49);\n    col+=max(halo,0.)*0.2*vec3(0.4,0.8,1.);\n    \n    pos +=dir*stepL;\n    roP = normalize(pos) ;\n    col+=smoothstep(0.999,1.,dot(rd,roP))*vec3(1.,0.6,0.)*0.6;\n    \n    pos+=dir*stepL*2. ;\n    roP = normalize(pos);\n    col+=smoothstep(0.5,0.4,length(rd-roP)/0.3)*vec3(0.6,1.,0.4)*0.2 ;\n    col-=smoothstep(0.9,.0,length(rd-roP)/0.2)*vec3(0.6,1.,0.4)*0.1 ;\n    \n    //go to other side of the sun\n    pos = sundir ;\n    pos+=-dir*stepL ;\n    roP = normalize(pos);\n    col+=smoothstep(0.6,0.4,length(rd-roP)/0.07) *vec3(1.,0.6,0.0)*0.6;\n    \n    pos+=-dir*stepL*0.25 ;\n    roP = normalize(pos);\n    col+=0.02/length(rd-roP)*vec3(0.2,0.6,1.)*0.6 ;\n    \n    pos+=-dir*stepL*0.5;\n    roP = normalize(pos);\n    col+=0.015/length(rd-roP)*vec3(0.4,0.8,1.)*0.6 ;\n    \n    pos+=-dir*stepL*0.25 ;\n    roP = normalize(pos);\n    col+=smoothstep(0.6,0.4,length(rd-roP)/0.1)*vec3(1.,0.6,0.0)*0.4;\n    \n    pos+=-dir*stepL*0.25 ;\n    roP = normalize(pos) ;\n    col+=0.007/length(rd-roP)*vec3(0.4,1.,0.8)*0.6;\n    \n    pos+=-dir*stepL*0.25 ;\n    roP = normalize(pos);\n    col+=smoothstep(0.5,0.4,length(rd-roP)/0.3)*vec3(0.6,1.,0.4)*0.2 ;\n    col-=smoothstep(0.9,.0,length(rd-roP)/0.2)*vec3(0.6,1.,0.4)*0.1 ;\n    \n    pos+=-dir*stepL ;\n    roP = normalize(pos);\n    col+=smoothstep(0.6,0.4,length(rd-roP)/0.2)*vec3(1.,0.6,0.0)*0.6;\n    \n    pos+=-dir*stepL*0.5 ;\n\n    roP = normalize(pos);\n    col+=0.003/length(rd-roP)*vec3(0.4,1.,0.8)*0.6;\n    \n    pos+=-dir*stepL*1.5 ;\n    roP = normalize(pos);\n    float haloF = smoothstep(0.5,0.49,length(rd-roP)/0.7);\n    haloF-=smoothstep(0.5,0.4,length(rd-roP)/0.69);\n    col+=max(haloF,0.)*0.2*vec3(0.4,0.8,1.);\n    \n    //post processing\n    col=clamp(col, 0.,1.);\n    col=pow(col,vec3(0.8)) ; //gamma correction\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}