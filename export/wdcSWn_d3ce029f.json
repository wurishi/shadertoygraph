{"ver":"0.1","info":{"id":"wdcSWn","date":"1571756062","viewed":112,"name":"Test SDF Material","username":"snolot","description":"test sdf material with reflect and refract","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf","material","reflect","refract"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ZERO min(u_frame,0)\n#define PI 3.141592\n\nvec3 lightPos = vec3(5.0, 0.0, 5.0);\nvec3 sunDir = normalize(vec3(0., 0., .5));\nvec3 col_water = vec3(.3, .7, 1.);\nfloat spokes, sph;\nfloat g1 = 0.0;\n#define tt (iTime*2.*PI)\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvoid moda (inout vec2 p, float rep)\n{\n    float per = 2.*PI/rep;\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a, per)-per*0.5;\n    p = vec2(cos(a),sin(a))*l;\n}\n\n\nvec3 rotateX(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n/*\nfloat sdBox(vec3 p, vec3 b){\n\tvec3 d = abs(p) - b;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}*/\n\nfloat pyramid( vec3 p, float h) {\n\tvec3 q=abs(p);\n\treturn max(-p.y, (q.x*1.5+q.y+q.z*1.5-h)/3.0 );\n}\n\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n// iq\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\n// iq\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\n// iq\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\n// Smooth max\nfloat smax(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (a - b) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// Smooth min\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// iq\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.yz)-t.x,p.x);\n  return length(q)-t.y;\n}\n\n// iq\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.yz)-t.x,p.x);\n  return length8(q)-t.y;\n}\n\n// rotate 2d space with given angle\nvoid tRotate(inout vec2 p, float angel) {\n    float s = sin(angel), c = cos(angel);\n\tp *= mat2(c, -s, s, c);\n}\n\n// divide 2d space into s chunks around the center\nvoid tFan(inout vec2 p, float s) {\n    float k = s / PI / 2.;\n    tRotate(p, -floor((atan(p.y, p.x)) * k + .5) / k);\n}\n\n// box distance\nfloat sdBox(vec3 p, vec3 r) {\n    p = abs(p) - r;\n\treturn min(max(p.x, max(p.y, p.z)), 0.) + length(max(p, 0.));\n}\n\n// union\nfloat opU(float a, float b) {\n    return min(a, b);\n}\n\n// intersection\nfloat opI(float a, float b) {\n    return max(a, b);\n}\n\n// substraction\nfloat opS(float a, float b) {\n    return max(a, -b);\n}\n\n// smooth union\nfloat opSU(float a, float b, float k)\n{\n    float h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat cyl (vec3 p, float r, float h){\n\treturn max(length(p.yz)-r, abs(p.x)-h);\n}\n\n\n/*float vine(vec3 p, float r){\n    return cyl(p+vec3(cos(p.y+r),0.,sin(p.y+r)),vec3(1.,1.,.5*cos(clamp(0.0-p.y/5.+1.,-2.,0.))));\n}\n*/\nmat2 rot2(float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n//----------------------------------------------------------\nconst int MAX_MARCHING_STEPS = 128;\nconst float MIN_DIST = 3.2, MAX_DIST = 5.5, EPSILON = 0.0001;\nconst float ANI_DUR = 20.0, SLIDE_DUR = 2.0, FADE_DUR = 5.0;\nmat4 paletteVal;\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 doPalette( in float val , in mat4 pType ){\n  return palette( val ,  pType[0].xyz , pType[1].xyz , pType[2].xyz , pType[3].xyz );\n}\n\n\n\n\nfloat map(vec3 p){\n\t//tFan(p.xz, 6.);\n  \tp = rotateX(p, iTime);\n  \tp = rotateY(p, iTime * .2);\n\n  \tfloat d = smin(sdTorus82(p, vec2(.55, .15)), cyl(p, clamp(.05 + sin(iTime * .8) * .2, .05, 1.), .1)/*sdBox(p, vec3(sin(iTime * .8) * .15) )*/, .55);// \n\n    //d = opS(d, \tsdCross(p, vec3(3.) ));\n  \t//float d = sdBoat(p);\n\treturn d;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor ){\n\tfloat ao = 0.0;\n\n\tvec3 v = normalize(vec3(0.7,0.5,0.2));\n\tfor( int i=0; i<12; i++ )\n\t{\n\t\tfloat h = abs(sin(float(i)));\n\t\tvec3 kv = v + 2.0*nor*max(0.0,-dot(nor,v));\n\t\tao += clamp( map(pos+nor*0.01+kv*h*0.2)*3.0, 0.0, 1.0 );\n\t\tv = v.yzx; if( (i&2)==2) v.yz *= -1.0;\n\t}\n\tao /= 12.0;\n\tao = ao + 2.0*ao*ao;\n\treturn clamp( ao*2.5, 0.0, 1.0 );\n}\n\nvec3 calcNormal(vec3 p) {\n\tfloat eps = 0.01;\n\tconst vec3 v1 = vec3( 1.0,-1.0,-1.0);\n\tconst vec3 v2 = vec3(-1.0,-1.0, 1.0);\n\tconst vec3 v3 = vec3(-1.0, 1.0,-1.0);\n\tconst vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\treturn normalize( v1 * map( p + v1*eps ) +\n\t\t\t\t\t  v2 * map( p + v2*eps ) +\n\t\t\t\t\t  v3 * map( p + v3*eps ) +\n\t\t\t\t\t  v4 * map( p + v4*eps ) );\n}\n\nfloat calcShadow( in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n    float k = 20.;\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h < .5 ) return res;\n        \n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n\nfloat intersect(vec3 ro, vec3 rd, in vec2 uv, out float raylength, out float drift){\n\t// raymarch\n    const float tmax = 3.5;\n    float hz = 0.0;\n\n    float l = 99999.9;\n    //float t = 0.5;\n    float d = 0.0;\n    float res;\n\n    float m = 0.0;\n    vec3 lc = vec3(0.0);\n\n    for( int i=0; i<256; i++ )\n    {\n        vec3 pos = ro + d*rd;\n        res = map(pos);\n        \n        if( res<0.001 || d>110. ) break;\n        //t += h;\n        \n        raylength = distance(ro,pos);\n        d += min(res*.65 + d * .002, 4.0);\n    }\n    return d;\n}\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n    // Note the \"1-tex.\" That's just for this particular example. Normally, the \"1\" isn't there.\n  return -(texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\nvec3 render(vec3 ro, vec3 rd, in vec2 uv){\n\tfloat raylength = 0.0;\n  \tfloat fg;\n\tfloat t = intersect(ro, rd, uv,  raylength, fg);\n\n\tvec3 col = vec3(0.);\n\n\tfloat fre = 0.0;\n\tconst float tmax = 35.5;\n\n\tif( t<tmax){\n\t\tvec3 pos = ro + t * rd;\n\t\tvec3 nor = calcNormal(pos);\n    \t\n    \tfloat ml = calcShadow(pos, lightPos, .1, 30.);\n\n\t\tfre = clamp(1.0+dot(nor, rd), 0.0, 1.0);\n\t\tfloat occ = calcAO(pos, nor);\n\t    float amb = 0.5 + 0.5*nor.y;\n\t    //vec3 mat = vec3(1.6, 1.6, 1.6);\n\t    vec3 mat = 0.5 + 0.5*mix( sin( vec3(1.2,1.1,1.0)*nor.y*3.0 ), sin( vec3(1.2,1.1,1.0)*nor.y*6.0 ), 1.0-abs(nor.y) );\n\t    mat += 0.05*nor;\n\t    \n\t    // lighting\n\t    float diff = max( dot(nor, normalize(lightPos-pos)), 0.0);\n\t    col = mat*1.5*occ*vec3(amb+fre*fre*col*0.5) ;\n\t    \n\t    col *= 0.4;\n\t    col += fre*occ*0.2*vec3(.3,0.5,.8)*smoothstep(0.0,0.02,reflect(rd,nor).y);\n\t    col *= diff;\n\n\t    //vec3 rr = refract( rd , nor , 1. / 1.1 );\n\t    //vec3 refr = refract( rd , nor , 1. / 1.1 );\n        vec3 refl = reflect( rd , nor );\n\n        refl = normalize( refl );\n        \n        //vec3 refrCol = texture( u_image, refr ).xyz;\n        vec3 reflCol = texture( iChannel0, refl ).xyz;\n        \n     \n        //col.xyz += .5 * pow(texture(u_image, refl), vec3(2.)).r;\n        col += mix(reflCol, refl, .3);//+  (palCol  * refrCol);\n        \n        // light emmission\n        /*col += vec3(0.7+pos.x*0.5,0.7,0.5)*0.4;\n    \tfloat ad = length(ro-pos);\n    \tcol = mix(col, vec3(0.,0.15,0.35), 1.-exp(-0.008*ad*ad));*/\n\t}\n\n\tcol *= vec3(1.0, .7, .1);\n\t//col *= vec3(.3, .7, 1.);\n\t\n\n\tcol = sqrt( col );\n  \n\treturn col;\n}\n\nvec2 path(float z)\n{\n    z *= 0.25;\n    vec4 s0 = sin(vec4(z*0.5, z*0.3 + 1.5, z*0.4 + 0.5, z*0.6 + 2.0));\n    vec4 s1 = vec4(z) + s0;\n    vec4 s = sin(vec4(s1.x, s1.y+2.0, s1.z+0.5, s1.w+3.0) - vec4(1.6, 1.7, 1.3, 1.5));\n    \n    return vec2(s.x + s.y, s.z + s.w);\n}\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\tpaletteVal = mat4( .5 , .5 , .5 , 0. \n\t         , .5 , .5 , .5 , 0.\n\t         , 2. , 1. , 0. , 0.\n\t         , .5 , .2 , .25 , 0.\n\t         );\t\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\t\n  \t// camera animation\n  \tfloat an = 0.1*(iTime-4.0);\n  \n\tvec3 ro = vec3( 2.*cos(an * .6), 0.0, 2.*sin(an * .6) );\n  \tvec3 ta = vec3( 0., 0., 0.3 );\n  \tro.xy += ro.z;\n  \tta.xy += ta.z;\n\n  \t// camera matrix\n  \tvec3 ww = normalize( ta - ro );\n  \tvec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n  \tvec3 vv = ( cross(uu,ww));\n\n  \tmat3 m = mat3(uu, vv, ww);\n  \tvec3 rd = normalize(m*vec3(p, 1.97));\n  \t\n  \tvec3 col = render(ro, rd, gl_FragCoord.xy);\n  \t\n\n\tfragColor = vec4(col, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}