{"ver":"0.1","info":{"id":"3tBSDR","date":"1565772704","viewed":226,"name":"Anisotropic & Diffract Color","username":"bearworks","description":"Based on https://www.shadertoy.com/view/4sSSW3 and GPU Gems Chapter 8. Simulating Diffraction","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["anisotropic","diffract","tangentspace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Based on Cheap orthonormal basis by nimitz\n//and GPU Gems Chapter 8. Simulating Diffraction\n\n//#define HANDLE_SINGULARITY\n\n#define ITR 80\n#define FAR 10.\n#define time iTime\n#define Diffract 1\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nfloat map(vec3 p)\n{\n\tp.x += sin(p.z*5.+sin(p.y*5.))*0.3;\n    return (length(p)-1.)*0.7;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float d = 0.;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    float res = map(ro+rd*d);\n        h = res;\n    }\n\treturn d;\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.005;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n//http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content\nvoid basis(in vec3 n, out vec3 f, out vec3 r)\n{\n    #ifdef HANDLE_SINGULARITY\n    if(n.z < -0.999999)\n    {\n        f = vec3(0 , -1, 0);\n        r = vec3(-1, 0, 0);\n    }\n    else\n    {\n    \tfloat a = 1./(1. + n.z);\n    \tfloat b = -n.x*n.y*a;\n    \tf = vec3(1. - n.x*n.x*a, b, -n.x);\n    \tr = vec3(b, 1. - n.y*n.y*a , -n.y);\n    }\n    #else\n    float a = 1./(1. + n.z);\n    float b = -n.x*n.y*a;\n    f = vec3(1. - n.x*n.x*a, b, -n.x);\n   \tr = vec3(b, 1. - n.y*n.y*a , -n.y);\n    #endif\n}\n\nvec3 blend3 (vec3 x)\n{\n    vec3 y = 1. - x * x;\n    y = max(y, vec3 (0., 0., 0.));\n    return (y);\n}\n\nvec3 colormap(float u)\n{\n   if (u < 0.) u = -u;\n\n   vec3 cdiff = vec3(0., 0., 0.);\n   for (float n = 1.; n < 8.; n+=1.)\n   {\n     float y = 2. * u / n - 1.;\n     cdiff += blend3(vec3(0.85 * (y - 0.75), 2.6 * (y - 0.5),\n                                0.95 * (y - 0.25)));\n   }\n    \n    return cdiff;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(0.8,0.1):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n\t//camera\n\tvec3 ro = vec3(0.,0.,4.5);\n    vec3 rd = normalize(vec3(p,-1.5));\n    vec3 rd2 = vec3(0,0.,-1);\n    mat2 mx = mm2(mo.x*6.);\n    mat2 my = mm2(mo.y*6.); \n    ro.xz *= mx;rd.xz *= mx;rd2.xz *= mx;\n    ro.xy *= my;rd.xy *= my;rd2.xy *= my;\n\t\n    vec3 ligt = normalize( vec3(-.5* cos(time), 0.2, -0.2 * sin(time)) );\n    vec3 lcol = vec3(1.00,0.90,0.75);\n    float rdl = clamp(dot(rd,ligt),0.,1.);\n    vec3 col = lcol*pow(rdl,50.) + vec3(0.1,0.2,0.3)*0.5;\n    \n\tfloat rz = march(ro,rd);\n    \n    if ( rz < FAR )\n    {\n        vec3 pos = ro+rz*rd;\n        vec3 nor= normal(pos);\n        vec3 r = vec3(0);vec3 f = vec3(0);\n        basis(nor,f,r);\n        \n        float dif = clamp( dot(nor, ligt), 0., 1. );\n        float bac = clamp( dot(nor, -ligt),0., 1.);\n        float fre = 0.6*pow( clamp(1. + dot(nor,rd),0.0,1.0), 2.);\n        vec3 brdf = 1.0*vec3(0.10,0.11,0.13);\n        brdf += 2.*bac*vec3(0.15,0.15,0.15);\n        brdf += 1.50*dif*lcol;\n        col = vec3(0.3,0.3,0.3);\n        #if Diffract\n        float e1 = dot(normalize(rd + ligt), f) / dot(reflect(rd,nor), ligt);\n        float spe1 = exp(-e1*e1);\n        float e = dot(normalize(rd + ligt), f);\n        float spe = e;\n        col = col*brdf + col*(colormap(spe) + spe1*vec3(1.5,0.4,1.3)) + fre*col;\n        #else\n        float spe = pow(clamp(dot(normalize(rd + ligt), f) / dot(reflect(rd,nor), ligt), 0., 1.),10.);\n        col = col*brdf + col*spe + fre*col;\n        #endif\n    }\n    \n    \n\n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}