{"ver":"0.1","info":{"id":"cs3BWM","date":"1697203104","viewed":137,"name":"gabor patch","username":"altunenes","description":"yet another gabor patch for shadertoy... :love: \n\nsee more about: https://en.wikipedia.org/wiki/Gabor_filter\n\ngabors are commonly using for studying visual cortex in vision science. :)","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["gabor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.1415926535897932384626433832795;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * (fragCoord/iResolution.xy) - 1.0;\n    \n    // Parameters the Gabor function\n    float lambda = 0.1;  // wavelength\n    float theta = iMouse.x / iResolution.x * PI;  // orientation\n    float psi = iTime*5.5;  // phase offset\n    float sigma = 0.1;  // sd of Gaussian\n    float gamma = 1.0;  // spatial aspect ratio\n    \n    // Rotation transformation\n    float xp = 2.0*uv.x * cos(theta) - uv.y * sin(theta);\n    float yp = 2.0*uv.x * sin(theta) + uv.y * cos(theta);\n    \n    // Gabor function (ref: https://en.wikipedia.org/wiki/Gabor_filter)\n    float envelope = exp(-((xp*xp) + (gamma*gamma * yp*yp)) / (2.0 * sigma * sigma));\n    \n    float carrier = cos(2.0 * PI * xp / lambda + psi);\n    float gabor = envelope * carrier;\n  \n    vec3 colorModulation = vec3(0.5) + vec3(0.5) * cos(1.5 * PI* xp / lambda + vec3(0, 2, 4));  \n    vec3 col = 0.5 + 0.5 * gabor * colorModulation;\n    // set cutoff for patch:  any pixels outside this radius are set to a uniform gray color, removing the faint waves/lines outside the central region of the patch.)\n    // /float radius = 0.2;\n    //if(length(uv) > radius) {\n    //    col = vec3(0.5);}    \n    // Output to screen: colorful Gabor patch\n    fragColor = vec4(col, 1.0);\n    // or just uncomment to use this plain gabor\n    //fragColor = vec4(vec3(0.5 + 0.5 * gabor), 1.0);\n\n}\n\n/*\n-------------------   LOOP VERSION   -----------------------\n\nconst float PI = 3.1415926535897932384626433832795;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * (fragCoord/iResolution.xy) - 1.0;\n    \n    float lambda = 0.06;\n    float sigma = 0.03;  \n    float gamma = 1.0;\n    \n    vec3 col = vec3(0.5);\n    int numPatchesX = 12;\n    int numPatchesY = 7;\n    \n    for(int i = 0; i < numPatchesX; ++i)\n    {\n        for(int j = 0; j < numPatchesY; ++j)\n        {\n            float xOffset = float(i) * 0.2 - 1.0;\n            float yOffset = float(j) * 0.2 - 0.6;\n            \n            float theta = (iMouse.x / iResolution.x + float(i) * 0.1) * PI;  // Vary orientation using 'i'\n            if (j % 2 == 1) {\n                theta = -theta;\n            }\n            \n            float psi = iTime * 5.5 + float(j) * PI/5.0 + float(i) * PI/10.0;  // Vary phase using both 'i' and 'j'\n            \n            vec2 uvPatch = vec2(uv.x - xOffset, uv.y - yOffset);\n            \n            float xp = 2.0*uvPatch.x * cos(theta) - uvPatch.y * sin(theta);\n            float yp = 2.0*uvPatch.x * sin(theta) + uvPatch.y * cos(theta);\n            \n            float envelope = exp(-((xp*xp) + (gamma*gamma * yp*yp)) / (2.0 * sigma * sigma));\n            float carrier = cos(2.0 * PI * xp / lambda + psi);\n            float gabor = envelope * carrier;\n            \n            vec3 colorModulation = vec3(0.5) + vec3(3.5) * cos(1.9 * PI * xp / lambda + vec3(0, 2, 4));  \n            col += 0.5 * gabor * colorModulation;\n        }\n    }\n    \n    fragColor = vec4(col, 1.0);\n}\n*/","name":"Image","description":"","type":"image"}]}