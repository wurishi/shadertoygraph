{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"float TWOPI = 6.28318530718;\n\nfloat DrawCircle(vec2 uv, vec2 p, float r) {\n    float d = r - length(p - uv);\n    return smoothstep(0.0, 1.5 / iResolution.y, d);\n}\n\nfloat distanceToLine(vec2 z1, vec2 z2, vec2 uv){\n    float d = abs(uv.y - (z2.y - z1.y)/(z2.x - z1.x) * (uv.x - z1.x) - z1.y);\n\n    return d;\n}\n\n\nvec3 palette(float t){\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(1.0,1.0,1.0);\n    vec3 d = vec3(0.8,0.5,0.1);\n    \n    return a + b*cos(6.28318530718*(c*t + d));\n}\n\nvec2 square(vec2 z){ return vec2(z.x*z.x - z.y*z.y , 2.0*z.x*z.y);}\n\nvec3 getIndex(vec2 uv, vec2 c, vec2 m, int maxIter, float threshold){\n    float index = 0.0; vec2 tempm = m; float iterColor = 0.0; vec2 initialuv = uv; float zoom = pow(10.0, -iTime/3.0);\n    vec2 temp;\n    float norm; float maxnorm = 0.0;\n    for (int i = 0; i < maxIter; i++){\n        index = float(i);\n        iterColor += DrawCircle(initialuv, m, 0.01*pow(10.0,-iTime/5.0))/(0.3*log(float(i))+1.0);\n        uv = square(uv) + c;\n        m = square(m) + tempm;\n        temp = uv - initialuv;\n        maxnorm = max( dot(temp,temp)    , maxnorm);\n        \n        if( dot(uv,uv) > threshold ){\n            break;\n        }\n    }\n    return vec3(index, iterColor, maxnorm/2.0);\n}\n\nvec3 getJuliaIndex(vec2 uv, vec2 c, vec2 m, int maxIter, float threshold){\n    float index = 0.0; vec2 tempm = c; float iterColor = 0.0; vec2 initialuv = uv; float zoom = pow(10.0, -iTime/3.0);\n    vec2 temp;\n    float norm; float maxnorm = 0.0;\n    for (int i = 0; i < maxIter; i++){\n        index = float(i);\n        iterColor += DrawCircle(initialuv, m, 0.015)/(0.3*log(float(i))+1.0);\n        uv = square(uv) + c;\n        m = square(m) + tempm;\n        temp = uv - initialuv;\n        maxnorm = max( dot(temp,temp)    , maxnorm);\n        \n        if( dot(uv,uv) > threshold ){\n            break;\n        }\n    }\n    return vec3(index, iterColor, maxnorm/2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 4.0*(fragCoord - 0.5 * iResolution.xy) / iResolution.y; vec2 initialuv = uv;\n    vec2 m = 4.0*(iMouse.xy - 0.5 * iResolution.xy) / iResolution.y; m.x = (1.5 - abs(m.x));\n    float zoom = pow(10.0, -iTime/3.0); vec2 zoomPoint = vec2(-0.813,0.19); m *= zoom;\n    int maxIter = 4000; float threshold = pow(10.0,2.0);\n    vec3 color;\n    if(uv.x < 0.0)\n    {\n        uv.x = (1.5 - abs(uv.x)); ;\n        uv *= zoom;\n        uv += zoomPoint; m += zoomPoint;\n\n        vec2 c = uv;\n        vec3 result = getIndex(uv,c,m,maxIter,threshold);\n        if(int(result.x) < maxIter - 1){\n        float index = 1.0 - result.x/float(maxIter); \n        color = palette(300.0*index) + vec3(result.y);\n        }\n        else{color += vec3(result.y) + vec3(result.z)/4.0;}\n        fragColor = vec4(color,1.0);\n    }\n    else\n    {\n        uv.x = (1.5 - abs(uv.x));\n        uv.x += 0.8;\n        uv += zoomPoint; m += zoomPoint;\n\n        vec2 c = m;\n        vec3 result = getJuliaIndex(uv,c,m,maxIter,threshold);\n        if(int(result.x) < maxIter - 1){\n        float index = 1.0 - result.x/float(maxIter); \n        color = palette(300.0*index) + vec3(result.y);\n        }\n        else{color += vec3(result.y) + vec3(result.z)/4.0;}\n        fragColor = vec4(color,1.0);\n    \n    }\n    fragColor.xyz *= smoothstep(1.0,0.0, 5.0*(0.05 - abs(initialuv.x)) );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4cyfWG","date":"1734389988","viewed":34,"name":"Orbit visualisation Mandelbrot","username":"Elyades","description":"Orbit visualisation Mandelbrot","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["orbitvisualisationmandelbrot"],"hasliked":0,"parentid":"","parentname":""}}