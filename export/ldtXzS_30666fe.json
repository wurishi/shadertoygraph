{"ver":"0.1","info":{"id":"ldtXzS","date":"1460135877","viewed":163,"name":"Space Tiling","username":"akohdr","description":"Tiling of 3-space with six symmetries of Isohedral Tetrahedron\nMouse X overrides rotation, Mouse Y overrides lattice offsets","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["voxel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// this is REALLY SLOW approach but found it useful as tool for investigating tilings\n// specifically figuring out the six symmetries of Isohedral Tetrahedron (below)\n\n// Lattice loop bounds (larger tilings get slow really quickly!)\nconst int a = 0, b = 0; \n#define MAX_RAY 150\n\n//const int a = 0, b = 1;\n//#define MAX_RAY 250\n\n// Almost unusable(!)\n//const int a = 2, b = 4;\n//#define MAX_RAY 250\n\n// Sizes Unit (u), Half-side(s)\nconst float s = 5., u = 2.*s;\n\n// smooths jittery float at give resolution\n#define SMOOTH(f,v) floor(f*v)/f\n\n// scaled mouse overridable variable\n#define MOUSEVC(d,v) MOUSEV(d,v,2.,100.)\n#define MOUSEV(d,a,c,s) (iMouse.z>0. ? (iMouse.a-iResolution.a/c)/s : d)\n\n#define BOB_H 3.\n#define EYE_D 70.\n\nvoid isoTet(inout vec4 c,        // has to be inout hmmmm\n         const in vec3 p, \n         const in vec3 x, \n        const in float s, \n         const in vec4 C) {\n    vec3 d = (x-p), \n         a = abs(d);\n    if(a.x<(d.y+s) && a.z<(s-d.y)) c = C;\n}\n\n// YMMV quick return trick seems to slow down on some drivers\n//#define ISOTET(c,p,v,s,C) {isoTet(c,p,v,s,C); if(c.w>0.) return;}\n#define ISOTET isoTet\n\nvoid cVoxel(inout vec4 c, const in vec4 P) {\n\n    const vec4 RED = vec4(.7,.0,.0,.2),\n               GRN = vec4(.0,.7,.0,.2),\n               BLU = vec4(.0,.0,.7,.2),\n               CYN = vec4(.0,.7,.7,.2),\n               YEL = vec4(.7,.7,.0,.2),\n               PRP = vec4(.7,.0,.7,.2);\n\n    const vec3 O = vec3(0),\n               u1 = vec3(-u),\n               u2 = vec3(u,-u,-u),\n               u3 = vec3(u,u,-u),\n               vo = vec3(-u,0,u);\n\n    float off = MOUSEVC(1.-cos(P.w), y);\n\n    for(int i=a; i<=b; i++){\n        vec3 vi = (float(i)+off)*u1;\n    \tfor(int j=a; j<=b; j++){\n        \tvec3 vj = (float(j)+off)*u2;\n    \t\tfor(int k=a; k<=b; k++){\n                vec3 v = O + vi + vj + (float(k)+off)*u3;\n                    // swizzle/offset for positioning various symmetries    \n\t                ISOTET(c,P.xyz,v,s,RED);\n                    ISOTET(c,P.yxz,vec3(v.x+s,v.y-s,v.z),s,GRN);\n                    ISOTET(c,P.zxy,vec3(v.x,s+v.yz),s,YEL);\n                    ISOTET(c,P.xzy,vec3(v.x,v.y+s,v.z+u+s),s,CYN);\n                    ISOTET(c,P.zyx,vec3(v.x,v.y+u,v.z),s,BLU);\n                    ISOTET(c,P.yzx,vec3(v.x-s,v.y-s,v.z),s,PRP);\n    }}}\n}\n\nvoid mainImage(out vec4 fc, in vec2 P) {\n    fc = vec4(0);  // must remember to init\n    \n    float T = MOUSEVC(1.7*iTime-iTimeDelta, x);\n    T = SMOOTH(8.,T);\n    vec3 t = vec3(sin(T), 0, cos(T));\n    \n    const vec3 vEye = -vec3(EYE_D, BOB_H, EYE_D),\n               B0 = vec3(0), B1 = vec3(.6), B2 = vec3(.3);\n\n\tfloat ar = (iResolution.y/iResolution.x);\n    vec2 uv = (3.*P/iResolution.xy)-1.6;\n    vec3 l = vec3(uv,1)*ar,\n         r = (t + l.xzx*vec3(t.z, l.y, -t.x)),\n         o = t.xxz * vEye,\n         d = abs(length(r)/r),\n         q = sign(r),\n         s = d*(q*fract(o)+(.5*q)+.5),\n         m;\n\n    for(int i=MAX_RAY; i>0; i--) {\n\n        cVoxel(fc, vec4(o, T));\n        if(fc.w>.0){\n        \tfc.xyz += m.x>0. ? B0 : m.y>0. ? B1 : B2;\n            return; // early exit\n        }\n\n        bvec3 a = lessThan(s,s.yzx),\n              b = lessThanEqual(s,s.zxy);\n        \n        m = vec3(a.x && b.x, a.y && b.y, a.z && b.z);  //a && b\n        \n        o += 1.33*m*q;\n        s += 1.33*m*d;\n\n        // interesting blocky/resolve effect        \n\t    //    o += SMOOTH(2.,m*q); \n    \t//    s += SMOOTH(2.,m*d);\n    }\n    \n    // not hit default\n    fc = texture(iChannel0, P/iResolution.xy);\n}\n","name":"Image","description":"","type":"image"}]}