{"ver":"0.1","info":{"id":"MffSDN","date":"1705271277","viewed":99,"name":"Group flight","username":"gest","description":"No comments","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raytrace","flight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SHADERTOY\n\n#ifdef SHADERTOY\n    #define main() mainImage( out vec4 fragColor, in vec2 fragCoord )\n    #define u_canvas iResolution\n    #define u_mouse iMouse\n    #define u_time iTime\n    #define gl_FragCoord fragCoord\n    #define gl_FragColor fragColor\n\t#define texture2D texture\n\t#define textureCube texture\n\t#define u_texture0 iChannel0\n\t#define u_texture1 iChannel1\n\t#define u_textureCube0 iChannel0\n\t#define u_textureCube1 iChannel1\n#endif\n\n//#define SUPER_GRAPHIC_CARD\n\n#ifdef SUPER_GRAPHIC_CARD\n\t#define SOFT_WATER\n\t#define SOFT_SHADOW\n#endif\n\n//# define OR min\n//# define AND max\n\n#if 1\n\tfloat hash(vec2 p) {\n\t\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n\t\tp3 += dot(p3, p3.yzx + 33.33);\n\t\treturn fract((p3.x + p3.y) * p3.z);\n\t}\n\t\n\t\n\tfloat noise( in vec2 p ) {\n\t\tvec2 i = floor( p );\n\t\tvec2 f = fract( p );\n\t\tvec2 u = f*f*(3.0-2.0*f);\n\t\treturn mix( mix( hash( i + vec2(0.0,0.0) ), \n\t\t\t\t\t\t hash( i + vec2(1.0,0.0) ), u.x),\n\t\t\t\t\tmix( hash( i + vec2(0.0,1.0) ), \n\t\t\t\t\t\t hash( i + vec2(1.0,1.0) ), u.x), u.y);\n\t}\n#else\n\tfloat noise(vec2 p) {\n\t  \treturn fract(sin(dot(p.xy, vec2(12.9898, 78.233))) * 43758.5453);\n\t}\n#endif\n\n\n#define FAR 1000.\n#define ID_NONE -1.\n#define ID_GROUND 0.\n#define ID_WATER 1.\n#define ID_TRACK 2.\n#define ID_NOISE 3.\n#define ID_FLYER 4.\n#define ID_BRIDGE 5.\n\nfloat time_explode;\nbool isExplode = false;\n\nvec3 posFlyer;\nmat3 matFlyer_X, matFlyer_Y, matFlyer_Z;\n\nfloat glow = 0.;\nbool calcGrow = true;\nbool calcFlyer = true;\n\nfloat angleY;\n\nconst vec3 lightDir = normalize(vec3(0,1,-1));\n\nvec3 Path (float t) {\n  \treturn vec3 (\n\t\tsin (0.005 * t) * cos (0.005 * t)*60., \n\t\t0.5, \n\t\tt\n\t);\n}\n\n////https://www.shadertoy.com/view/4dGcDh\nvec3 PathOrt(float t, float dt) {\n\tvec3 posF = Path(t + dt);\n\tvec3 posB = Path(t - dt);\n\tvec3 dir = posF - posB;\n\tvec3 vel = dir / (2. * dt);\n\tvel.y = 0.;\n\tvec3 acc = (posF - 2. * Path(t) + posB) / (dt * dt);\n\tacc.y = 0.;\n\tvec3 va = cross (acc, vel) / length (vel);\n\tfloat anX = asin (vel.y / length (vel));\n\tfloat anY = atan(dir.z, dir.x) - 0.5*PI;\n\tfloat anZ = 40. * length (va) * sign (va.y);\n\treturn vec3(anX, anY, anZ);\n}\n\nmat3 PathMatrix(float t, float dt) {\n\tvec3 ort = PathOrt(t, dt);\n\treturn TF_ROTATE_Z(ort.z) * TF_ROTATE_X(ort.x) * TF_ROTATE_Y(ort.y);\n}\n\nfloat smoothGroundPath(vec2 p, float h, float pathH, float pathW) {\n\tvec3 path = Path (p.y);\n\tfloat f = smoothstep (0., 1., abs (p.x - path.x)/pathW);\n\treturn min (abs(h), mix(pathH, h, f));\n}\n\nfloat GrndHt(vec2 p) {\n\tfloat h = (sin(0.1*(p.x))*cos(0.02*(p.y)))*20. + 5.*sin(u_time/20.);\n\treturn smoothGroundPath(p, h, 0., 40.);\n}\n\n//Idea from https://www.shadertoy.com/view/ddByWm\nvoid TransformExplode(inout vec3 q, float time) {\n\t//Вреия процесса\n\tfloat time_explode_quick = pow(time, 0.3)*3.5;\n\t#if 0\n\t\t//Ограничение процесса\n\t\ttime_explode_quick = clamp(time_explode_quick, 0., 4.5);\n\t#endif\n\t//Уверичиваем в размерах\n\tq -= q*time_explode_quick*vec3(0.1,0.01,0.1);\n\t//роняем\n\tq.y += (1.8+q.y)*time_explode_quick*sin(-clamp(mod(time_explode_quick,2.*PI), 0., 4.*PI/3.))*0.15;\n\t//Вращаем\n\tfloat an = clamp(time*time_explode_quick*q.y, 0., PI/18.);\n\tq *= TF_ROTATE_Y(an);\n\t//Фрагментируем\n\tfloat rnd = noise(floor(q.xy*5.) + floor(q.z*5.));\n\tq += rnd*time_explode_quick*vec3(0.1);\n}\n\nfloat map(vec3 p, inout Object object) {\n\tvec3 q, qq;\n\tfloat d;\n\t\n\tfloat h = GrndHt(p.xz);\n\tvec3 path = Path(p.z);\n\t\n\tobject = Object(FAR, ID_NONE, p);\n\n\tObject GROUND = Object(FAR, ID_GROUND, p);\n\t{\n\t\tq = p;\n\t\t//Перемнщаем в центр пути\n\t\tTF_TRANSLATE(q.x, path.x)\n\t\t//Периодичность расположения тоннеля\n\t\tTF_TRANSLATE(q.z, -30.);\n\t\tfloat id = TF_REPLICA(q.z, 300.);\n\t\t//Расстояние до поверхности\n\t\td = TF_BEFORE(q.y, h);\n\t\t//Тоннель\n\t\tfloat d_cut = max(\n\t\t\tTF_BALL(q.yz - vec2(5,0), 4.), \n\t\t\tTF_AFTER(q.y, 5.)\n\t\t);\n\t\t//Вырезаем со сглаживанием\n\t\tGROUND.distance = AND(d, -d_cut, 2.);\n\t\tGROUND.position = q;\n\t}\n\tobject = OR(object, GROUND);\n\n\t#ifdef SOFT_WATER\n\t\tObject WATER = Object(FAR, ID_WATER, p);\n\t\t{\n\t\t\tq = p;\n\t\t\tWATER.distance = TF_BEFORE(q.y, -0.2);\n\t\t\tWATER.position = q;\n\t\t}\n\t\tobject = OR(object, WATER);\n\t#endif\n\t\n\tfloat d_laser = FAR;\n\tvec3 p_laser = p;\n\t\n\tObject FLYER = Object(FAR, ID_FLYER, p);\n\t{\n\t\tq = p;\n\t\t//Прижимвем к земле\n\t\tTF_TRANSLATE(q.y, h - 0.25);\n\t\t//Перемещаемся в центр oбъекта\n\t\tTF_TRANSLATE(q, posFlyer);\n\t\t\n\t\t#if 1\n\t\t\t//Корректировка углов\n\t\t\tq = matFlyer_Y * q;\n\t\t\t//Размножаем 5 объектов по сторонам\n\t\t\tfloat id = TF_REPLICA_LIMIT(q.x, 1.5, -2., 2.);\n\t\t\t//Разносим объекты по направлению движения и по высоте\n\t\t\tTF_TRANSLATE(q.z, 1.5*pow(abs(id), 2.));\n\t\t\tTF_TRANSLATE(q.y, 0.1*pow(abs(id), 2.)*(1. - sin(0.5*u_time*id)));\n\t\t\t//Корректировка углов\n\t\t\tq = matFlyer_Z * matFlyer_X * q;\n\t\t#else\n\t\t\t//Размножаем 5 объектов по сторонам\n\t\t\tfloat id = TF_REPLICA_LIMIT(q.x, 1.5, -2., 2.);\n\t\t\t//Разносим объекты по направлению движения\n\t\t\tTF_TRANSLATE(q.z, 1.5*pow(abs(id), 2.));\n\t\t\t//Корректировка углов\n\t\t\tq = matFlyer_Z * matFlyer_X * matFlyer_Y * q;\n\t\t#endif\n\t\t\n\t\t//Расстояние до эллипса\n\t\td = TF_ELLIPSE(q, vec3(0.5, 0.08, 0.5));\n\t\t//Добавляем кабину\n\t\tfloat d1 = max(\n\t\t\tTF_BALL(q.xz, 0.05), \n\t\t\tTF_BETWEEN2(q.y, -0.05, 0.00)\n\t\t);\n\n\t\tFLYER.distance = OR(d, d1, 0.2);\n\t\tFLYER.position = q;\n\t\t\n\t\t//Свечение\n\t\td_laser = max( TF_BALL(q.xz, 0.3), TF_BETWEEN2(q.y, -0.15, -0.1));\n\t\tp_laser = q;\n\t\t\n\t}\n\tobject = OR(object, FLYER);\n\t\n\tObject BRIDGE = Object(FAR, ID_BRIDGE, p);\n\t{\n\t\tq = p;\n\t\t//Перемнщаем в центр пути\n\t\tTF_TRANSLATE(q.x, path.x);\n\t\t//Периодичность расположения моста\n\t\tTF_TRANSLATE(q.z, -30.);\n\t\tTF_REPLICA(q.z, 300.);\n\t\t//Стена\n\t\td = max(\n\t\t\tTF_BETWEEN(q.z, 2.), \n\t\t\tTF_BEFORE(q.y, 5.)\n\t\t);\n\t\t//Перидичность вырезов\n\t\tTF_REPLICA(q.x, 15.);\n\t\t//Вырезы\n\t\tfloat d_cut = TF_BOX_ROUND(q.xy - vec2(0, -4), vec2(0, 1), 7.);\n\n\t\tBRIDGE.distance = max(d, -d_cut);\n\t\tBRIDGE.position = q - vec3(0,5.,0); //Верхняя позация, центр проемов\n\t}\n\tobject = OR(object, BRIDGE);\n\n\n\tif (distance(posFlyer, p) > 80.) {\n\t\ttime_explode = 0.;\n\t\tisExplode = false;\n\t}\n\t\n\t//Отладка\n\t#if 0\n\t\ttime_explode = 0.;\n\t\tisExplode = false;\n\t#endif\n\t\n\tObject NOISE = Object(FAR, ID_NOISE, p);\n\t{\n\t\tq = p;\n\t\t//Перемнщаем в центр пути\n\t\tTF_TRANSLATE(q.x, path.x);\n\t\t//Прижимвем к земле\n\t\tTF_TRANSLATE(q.y, h);\n\t\t//Периодичность расположения препятствий\n\t\tTF_TRANSLATE(q.z, -30.);\n\t\tfloat id = TF_REPLICA(q.z, 150.);\n\t\t//Эффект разрушения\n\t\tTransformExplode(q, time_explode);\n\t\t//Стена\n\t\td = TF_BOX3D(q, vec3(4,1.1,2));\n\t\t//Симметрия\n\t\tTF_MIRROR(q.x, 3.);\n\t\t//Добавляем башни со сглаживанием\n\t\td = OR(d, TF_BALL(q - vec3(0,2,0), 1.0), 0.8);\n\t\t\n\t\tNOISE.distance = d;\n\t\tNOISE.position = q;\n\t}\n\tobject = OR(object, NOISE);\n\t\n\t//Дорога\n\tObject TRACK = Object(FAR, ID_TRACK, p);\n\t{\n\t\tq = p;\n\t\t//Перемнщаем в центр пути\n\t\tTF_TRANSLATE(q.x, path.x);\n\t\tTRACK.distance = TF_BOX2D(q.xy, vec2(1, 0.1));\n\t\tTRACK.position = q;\n\t}\n\tobject = OR(object, TRACK);\n\t\n\n\t//Свечение препятствия и лазера\n\tif (calcGrow) {\n\t\tif (NOISE.distance < d_laser) {\n\t\t\td = NOISE.distance;\n\t\t\tq = NOISE.position;\n\t\t\tglow += 0.05/(0.1 + d*d)*exp(-.001*length(q))*exp(-2.*time_explode);\n\t\t} else {\n\t\t\td = d_laser;\n\t\t\tq = p_laser;\n\t\t\tglow += 0.005/(0.15 + d*d)*exp(-.001*length(q))*exp(-2.*time_explode);\n\t\t}\n\t}\n\n    return object.distance;\n}\n\nfloat map ( in vec3 p ) {\n\tObject object;\n\treturn map (p, object);\n}\n\nvec3 mapNormal(vec3 p, float eps) {\n    vec2 e=vec2(0.,eps);\n    return normalize(vec3(\n\t\tmap(p+e.yxx),\n\t\tmap(p+e.xyx),\n\t\tmap(p+e.xxy)\n\t)-map(p));\n}\n\nfloat rayMarch(inout Ray ray) {\n\tray.distance = ray.near;\n\tfloat steps;\n\tfor (float i = 0.; i < 250.; ++i) {\n\t\tray.position = ray.origin + ray.direction * ray.distance;\n\t\tray.object.distance = map(ray.position, ray.object);\n\t\tray.hit = ray.object.distance < ray.epsilon;\n\t\tif (ray.hit) break;\n\t\tray.distance += ray.object.distance*ray.swing;\n\t\tif (ray.distance>ray.far) break;\n\t\tsteps = i + 1.;\n\t\tif (steps>ray.steps) break;\n\t}\n\treturn steps;\n}\n\nfloat softShadow( Ray ray, float k ) {\n    float shade = 1.0;\n    ray.distance = ray.near;    \n\tfloat steps = 1.;\n    for ( int i = 0; i < 50; i++ ) {\n\t\tray.position = ray.origin + ray.direction * ray.distance;\n        ray.object.distance = map(ray.position);\n        shade = min( shade, smoothstep( 0.0, 1.0, k * ray.object.distance / ray.distance)); \n\t\tray.hit = ray.object.distance < ray.epsilon;\n\t\tif (ray.hit) break;\n        ray.distance += min( ray.object.distance, ray.far / ray.steps * 2. ); \n        if (ray.distance > ray.far ) break; \n\t\tsteps++;\n\t\tif (steps>ray.steps) break;\n    }\n    return min( max( shade, 0.0 ) + 0.5, 1.0 ); \n}\n\n//https://www.shadertoy.com/view/MlSXRR\nvec4 GrndCol (Ray ray) {\n\tvec3 p = ray.position;\n\tvec3 n = ray.normal;\n\tconst vec3 \n\t\tgCol1 = vec3 (0.6, 0.7, 0.7), gCol2 = vec3 (0.2, 0.1, 0.1),\n\t \tgCol3 = vec3 (0.4, 0.3, 0.3), gCol4 = vec3 (0.1, 0.2, 0.1),\n\t \tgCol5 = vec3 (0.7, 0.7, 0.8), gCol6 = vec3 (0.05, 0.3, 0.03),\n\t\tgCol7 = vec3 (0.02, 0.1, 0.02), gCol8 = vec3 (0.1, 0.08, 0.);\n\tvec2 q = p.xz;\n\tfloat f, d;\n\tfloat cSpec = 0.;\n\tf = 0.5 * (clamp (noise (0.1 * q), 0., 1.) +\n\t  0.8 * noise (0.2 * q + 2.1 * n.xy + 2.2 * n.yz));\n\tvec3 col = f * mix (f * gCol1 + gCol2, f * gCol3 + gCol4, 0.65 * f);\n\tif (n.y < 0.5) {\n\t\tf = 0.4 * (noise (0.4 * q + vec2 (0., 0.57 * p.y)) +\n\t\t   0.5 * noise (6. * q));\n\t\td = 4. * (0.5 - n.y);\n\t\tcol = mix (col, vec3 (f), clamp (d * d, 0.1, 1.));\n\t\tcSpec += 0.1;\n\t}\n\tif (p.y > 22.) {\n\t\tif (n.y > 0.25) {\n\t\t  f = clamp (0.07 * (p.y - 22. - noise (0.2 * q) * 15.), 0., 1.);\n\t\t  col = mix (col, gCol5, f);\n\t\t  cSpec += f;\n\t\t}\n\t} else {\n\t\tif (n.y > 0.45) {\n\t\t  vec3 c = (n.y - 0.3) * (gCol6 * vec3 (noise (0.4 * q),\n\t\t\t noise (0.34 * q), noise (0.38 * q)) + gCol7);\n\t\t  col = mix (col, c, smoothstep (0.45, 0.65, n.y) *\n\t\t\t (1. - smoothstep (15., 22., p.y - 1.5 + 1.5 * noise (0.2 * q))));\n\t\t}\n\t\tif (p.y < 0.65 && n.y > 0.4) {\n\t\t  d = n.y - 0.4;\n\t\t  col = mix (col, d * d + gCol8, 2. * clamp ((0.65 - p.y -\n\t\t\t 0.35 * (noise (0.4 * q) + 0.5 * noise (0.8 * q) +\n\t\t\t 0.25 * noise (1.6 * q))), 0., 0.3));\n\t\t  cSpec += 0.1;\n\t\t}\n\t}\n\treturn vec4 (pow(col, vec3(0.5)), cSpec);\n}\n\n//https://www.shadertoy.com/view/Mtf3zM\nfloat Brick (vec2 p) {\n\tvec2 q = p / vec2 (2., 1.);\n\tvec2 i = floor (q);\n\tif (2. * floor (i.y / 2.) != i.y) {\n\t\tq.x += 0.5;\n\t\ti = floor (q);\n\t}\n\tq = smoothstep (0.02, 0.04, abs (fract (q + 0.5) - 0.5));\n\treturn q.x*q.y;\n}\n\nvec3 getMaterial(Ray ray) {\n\tvec3 m_color = vec3(1);\n\n\tvec3 q = ray.object.position;\n\tvec3 p = ray.position;\n\tvec3 n = ray.normal;\n\tif (ray.object.id==ID_NOISE) {\n\t\tif (isExplode) {\n\t\t\tm_color = vec3(1,1,0.);\n\t\t} else {\n\t\t\tm_color = vec3 (0.5, 0.4, 0.3);\n\t\t\tvec3 n1 = abs(n);\n\t\t\tm_color *= Brick(q.yz/0.5)*n1.x + Brick(q.xz/0.5)*n1.y + Brick(q.xy/0.5)*n1.z;\n\t\t\tif (q.y>1.3) m_color = vec3(0.8,0.3,0.0);\n\t\t}\n\t} else if (ray.object.id==ID_TRACK) {\n\t\tm_color = vec3(0.4,0.4,0.5);\n\t\tvec3 qq = abs(q)-0.01;\n\t\tif (TF_BETWEEN2(qq.x, 0.02, 0.05)<0.) m_color = vec3(1);\n\t\tqq = abs(q) - 0.9;\n\t\tif (TF_BETWEEN(qq.x, 0.02)<0.) m_color = vec3(1,1,0);\n\t} else if (ray.object.id==ID_GROUND) {\n\t\tm_color = vec3(0.4,0.8,0.0);\n\t\tm_color = GrndCol(ray).rgb;\n\t\tif (n.y<0.) m_color = vec3(1);\n\t} else if (ray.object.id==ID_BRIDGE) {\n\t\tm_color = vec3(1);\n\t\tif (TF_AFTER(q.y, -0.25)<0.) m_color = vec3(0.4,0.4,0.5); \n\t\tif (TF_BALL(q.xy - vec2(0,-9.+0.25), 8.)<0.) m_color = vec3 (0.5, 0.75, 1.); \n\t\tif (n.y<0.) m_color = vec3(1);\n\t} else if (ray.object.id==ID_FLYER) {\n\t\tm_color = vec3 (0.5, 0.75, 1.);\n\t\tTF_REPLICA_ANGLE(q.xz, 12.,0.);\n\t\tif (TF_BALL(q.yx, 0.05)<0.) m_color = vec3(0.9,0.2,0.2);\n\t\tif (isExplode && n.y<0.) m_color = vec3(1,1,0.);\n\t}\n\treturn m_color;\n}\n\nvec3 BgCol(vec3 rd) {\n\treturn mix(vec3(1), vec3 (0.5, 0.75, 1.), rd.y+0.1);\n}\n\nvec3 lighting(Ray ray, vec3 lightDir, vec3 m_color) {\n\tfloat sh = 1.;\n\t#ifdef SOFT_SHADOW\n\t\tRay ray1 = ray;\n\t\t{\n\t\t\tray1.origin = ray.position;\n\t\t\tray1.direction = lightDir;\n\t\t\tray1.steps = 30.;\n\t\t\tray1.far = 10.;\n\t\t}\n\t\tsh = softShadow(ray1, 10.);\n\t#endif\n\tfloat back = max (dot (ray.normal, - normalize (vec3 (lightDir.x, 0., lightDir.z))), 0.);\n\tfloat diff = max (dot(lightDir, ray.normal), 0.0);\n\tfloat spec = pow (clamp(dot(normalize((ray.direction + lightDir) / 2.0), ray.normal), 0.0, 1.0),64.);\n\treturn m_color * (0.2 + 0.2*back + sh*0.8*diff) + sh*0.5*spec;\n}\n\n\nvoid main() {\n\tfloat aspect = u_canvas.x/u_canvas.y;\n    vec2 uv = gl_FragCoord.xy / u_canvas.xy;\n   \tuv = uv - 0.5;\n\n\tfloat time = 30.*u_time;\n    time_explode = max(0., mod(u_time,5.)-2.);\n\tisExplode = time_explode>0.;\n\t\n\tvec2 mouse = u_mouse.xy / u_canvas.xy - 0.5;\n\tif (u_mouse.xy==vec2(0)) mouse = vec2(0);\n\t\n    vec2 ori = vec2(\n        u_mouse.z==0. ? 0. : mouse.y*PI*2.,\n        u_mouse.z==0. ? 0. : mouse.x*PI*2.\n    );\n\tori.x = clamp(ori.x, -PI, PI);\n\n\tposFlyer = Path(time + 15.) - vec3(0.5, 0., 0);\n\t\n\tvec3 ort = PathOrt(time + 15., 2.);\n\tmatFlyer_X = TF_ROTATE_X(ort.x);\n\tmatFlyer_Y = TF_ROTATE_Y(ort.y);\n\tmatFlyer_Z = TF_ROTATE_Z(ort.z);\n\t\n\n\tfloat time_cam = time + 12. + u_mouse.z;//8\n\tvec3 pos_cam = Path(time + 10.) - vec3(0.5, 0., 0);\n\t\n\tCamera cam;\n\t{\n\t\tcam.fov     = 45. ;\n\t\tcam.aspect\t= aspect;\n\t\tcam.origin  = pos_cam;\n\t\tcam.target\t= posFlyer; //Path(time_cam + 1.) - vec3(0.5, 0.+u_mouse.z, 0);\n\t\tcam.target.y = cam.origin.y;\n\t\tcam.up \t\t= vec3(0, 1, 0);\n\t\tcam.vMat \t= TF_ROTATE_Y(ori.y) * TF_ROTATE_X(ori.x);\n\t\tcam.tMat\t= mat3(1);//TF_ROTATE_Y(ori.y) * TF_ROTATE_X(ori.x);\n\t}\n\n\tRay ray = lookAt(uv, cam);\n\t{\n\t\tray.near \t= 0.01;\n\t\tray.far  \t= FAR;\n\t\tray.epsilon = 0.0001;\n\t\tray.swing\t= 1.;\n\t\tray.steps \t= 250.;\n\t}\n\tcalcGrow = true;\n\trayMarch(ray);\n\t\n    vec3 col = vec3(0.);\n\n\tfloat refl = 1.;\n\t\n\t#ifdef SOFT_WATER\n\t\tif (ray.distance<ray.far && ray.object.id==ID_WATER) {\n\t\t\tcalcGrow = false;\n\t\t\tray.normal = vec3(0,1,0);//mapNormal(ray.position, 0.001);\n\t\t\t//ray.normal = mapNormal_water (ray.position.xz, ray.epsilon*10.);\n\t\t\t\n\t\t\trefl *=0.8;\n\t\t\tray.origin = ray.position;\n\t\t\tray.direction = reflect(ray.direction, ray.normal);\n\t\t\tcalcGrow = true;\n\t\t\trayMarch(ray);\n\t\t}\n\t#endif\n\t\n\tif (ray.distance<ray.far && ray.object.id!=ID_WATER) {\n\t\tcalcGrow = false;\n        ray.normal = mapNormal(ray.position, 0.001);\n\t\tif (ray.object.id==ID_FLYER && ray.normal.y>0.) {\n\t\t\tvec3 p = ray.object.position;\n\t\t\tTF_REPLICA_ANGLE(p.xz, 12., 0.);\n\t\t\tTF_ROTATE(ray.normal.xy, 1.5 * PI * p.x/length(p.xyz));\n\t\t}\n\t\tvec3 m_color = getMaterial(ray);\n\t\tcol = lighting(ray, lightDir, m_color);\n    } else {\n\t\tcol = BgCol(ray.direction);\n\t}\n\n\tif (refl<1.) {\n\t\tcol *= refl;\n\t\tcol.gb += vec2(0.1, 0.3);\n\t}\n\t\n\t//Мигание\n    col += step(abs(time_explode-0.03),0.02);\n\t//Свечение\n    col += glow*vec3(1.,.5,.2)*step(0.001,time_explode);\n\t\n\t//Туман\n\tif (ray.distance<ray.far) {\n\t\tconst float fogStart = 200.;\n\t\tconst vec3 fogColor = vec3(2);\n\t\tcol = mix(col, fogColor, clamp((ray.distance-fogStart)/(ray.far-fogStart), 0., 1.));\n\t}\n\n    gl_FragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = radians(180.);\n//Камера\nstruct Camera {\n\t//Задаваемые параметры\n\tfloat fov, aspect;\n\tvec3  origin, target, up;\n\tmat3 vMat, tMat;\n\t//Расчетные параметры\n\tfloat factor;\n\tvec3  forward, right, position, coord;\n\tmat3 pMat, uMat;\n};\n\n//Параметры объекта\nstruct Object {\n\tfloat   distance;\t//Последнее приближение к объекту сцены\n\tfloat \tid;\t\t\t//id найденого объека сцены\n\tvec3 \tposition;\t//Координатв поверхности объекта\n};\n\n//Луч\nstruct Ray {\n\t//Задаваемые параметры\n\tvec3  origin;\t\t//Начало луча\n\tvec3  direction;\t//Направление луча\n\tfloat near;\t\t\t//Минимальное расстояние от камеры (начало сцены)\n\tfloat far;\t\t\t//Максивальное расстояние от камеры (конец сцены)\n\tfloat epsilon;\t\t//Точность обнаружения поверхности\n\tfloat steps;\t\t//Максимальное число итераций\n\tfloat swing;\t\t//\"+\" -колебание в найденной точке, \"-\"\n\t//Вычисляемые параметры\n\tfloat distance; \t//Расстояние до объекта сцены от ray.origin в направлении ray.direction\n\tvec3  position; \t//Точка поверхности\n\tvec3  normal;\t\t//Нормаль в точке поверхности\n\tbool  hit;\t\t\t//Флаг нахождения точки поверхности с заданной точностью\n\tObject object;\t\t//Параметры объекта (можно формировать непосредственно в карте расстояний)\n};\n//Формирование луча камеры\nRay lookAt (in vec2 uv, inout Camera cam) {\n\t//Расчетные характеристики камеры\n\tcam.factor\t\t= 1.0/tan(radians(cam.fov/2.));\n\tcam.forward \t= normalize(cam.target-cam.origin); \n\tcam.right \t\t= normalize(cross(cam.forward, cam.up));\n\tcam.up \t\t\t= cross(cam.right, cam.forward);\n\tcam.position \t= cam.origin + cam.factor * cam.forward;\n\tcam.coord \t\t= cam.position + uv.x * cam.right*cam.aspect + uv.y * cam.up;\n\tcam.pMat \t\t= mat3(cam.right, cam.up, cam.forward);\n\tvec3 u \t\t\t= - cam.forward.y * cam.forward;\n\tfloat f \t\t= 1. / sqrt (1. - cam.forward.y * cam.forward.y);\n\tcam.uMat \t\t= mat3 (\n\t\tf * vec3 (- cam.forward.z, 0., cam.forward.x), \n\t\tf * vec3 (u.x, 1. + u.y, u.z), \n\t\tvec3 (cam.forward.x, cam.forward.y, cam.forward.z)\n\t);\n\t//Формирование луча\n\tRay ray;\n\t{\n\t\tray.origin \t\t= cam.tMat * cam.origin;\n\t\tray.direction \t= cam.tMat * normalize( cam.pMat * cam.vMat * vec3(uv.x*cam.aspect, uv.y, cam.factor));\n\t\t//Умолчания\n\t\tray.near\t\t= 0.01;\n\t\tray.far\t\t\t= 100.;\n\t\tray.epsilon\t\t= 0.001;\n\t\tray.swing\t\t= 1.0;\n\t\tray.steps\t\t= 200.;\n\t}\n\treturn ray;\n}\n//-------------------функции трансформации и позиционирования объектов сцены\n//Допустимая ошибка (для удаления артефактов) 1./min(u_canvas.x, u_canvas.y)\nfloat EPS = 0.1;\n//Функция расстояния до фигуры со скругленными ребрами (объединение и сглаживание с увеличением на R)\n//float d - сглаживание фигуры\n//vec2 d - объединение и сглаживание двух фигур\n//vec3 d - объединение и сглаживание трех фигур\n//vec4 d - объединение и сглаживание четырех фигур\n#define TF_ROUND(d, R) (length(max(d, 0.)) - (R))\n//Функция расстояния до бокса (p vec3) или прямоугольника (p vec2) со скругленными ребрами\n//Функция расстояния до капсулы, если два размера 0\n#define TF_BOX_ROUND(p, S, R) TF_ROUND(abs(p)-(S), R)\n#define TF_BOX_ROUND1(p, S, R) TF_ROUND(abs(p)-(S) + R, R)\n//Функция расстояния до бокса (p vec3) или прямоугольника (p vec2)\n#define TF_BOX(p, S) TF_ROUND(abs(p) - (S) + EPS, EPS)\n#define TF_BOX1(p, S) TF_ROUND(abs(p) - (S), 0.)\n#define TF_BOX3D(p, S) max(abs((p).x)-(S).x, max(abs((p).y)-(S).y, abs((p).z)-(S).z))\n#define TF_BOX2D(p, S) max(abs(p.x)-S.x, abs(p.y)-S.y)\n//Функция расстояния до шара (p vec3) или круга (p vec2)\n#define TF_BALL(p, R) TF_ROUND(abs(p), R)\n//Эллипс\n#define TF_ELLIPSE(p, r) min ((r).x, min((r).y, (r).z)) * TF_BALL(p/(r), 1.)\n//Функция расстояния до пространства ДО p1\n#define TF_BEFORE(p, p1) p - (p1)\n#define TF_BEFORE1(p, p1) TF_ROUND(p - (p1) + EPS, EPS)\n//Функция расстояния до пространства ПОСЛЕ p1\n#define TF_AFTER(p, p1) TF_ROUND(-p + (p1) + EPS, EPS)\n//Функция расстояния до симметричного пространства МЕЖДУ -p1 и +p1\n//#define TF_BETWEEN(p, p1) TF_ROUND(abs(p) - (p1) + EPS, EPS)\n#define TF_BETWEEN(p, p1) abs(p) - (p1)\n//Функция расстояния до несимметричного пространства МЕЖДУ p1 и p2\n#define TF_BETWEEN2(p, p1, p2) TF_ROUND( abs(p - 0.5*(p1+p2)) - 0.5*(p2-p1) + EPS, EPS)\n//Перемещение пространства p (float p...vec4 p)\n#define TF_TRANSLATE(p, d) p -= d;\n//Масштаб\n#define TF_SCALE(p, s) p /= s\n//Вращение пространства p (vec2 p)\n#if 0\n\t#define TF_ROTATE(p, a) p = mat2(cos(a), sin(a), -sin(a), cos(a)) * p\n#else\n\t#define TF_ROTATE(p, a) p = p.xy * cos (a) * vec2 (1., 1.) + p.yx * sin (a) * vec2 (-1., 1.)\n#endif\n#define TF_ROTATE_MAT2(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define TF_ROTATE_X(a) mat3(1.0,    0.0, 0.0,       0.0, cos(a), -sin(a),   0.0, sin(a), cos(a))\n#define TF_ROTATE_Y(a) mat3(cos(a), 0.0, -sin(a),   0.0, 1.0, 0.0,   \t    sin(a), 0.0, cos(a))\n#define TF_ROTATE_Z(a) mat3(cos(a), -sin(a), 0.0,   sin(a), cos(a), 0.0,   \t0.0, 0.0, 1.0)\n//Отражение пространства p (float p...vec4 p)\n#define TF_MIRROR(p, d) p = abs(p) - (d)\n//Разбиение пространства на повторяющиеся. Возвращает id центра ячейки\n//float p - пространство 1D\n//vec2 p - пространство 2D\n//vec3 p - пространство 3D\n#define TF_REPLICA(p, d) \\\n\tfloor((p/d) + 0.5);\\\n\tp = mod(p + (0.5*d), d) - (0.5*d)\n//Разбиение пространства на повторяющиеся в диапазоне id от ida до idb включительно. Возвращает id центра ячейки\n#define TF_REPLICA_LIMIT(p, d, ida, idb) \\\n\tfloor(p/d + 0.5);\\\n\tp = p-(d)*clamp(floor((p)/(d) + 0.5), ida, idb)\n//Разбиение пространства на повторяющиеся сектора в плоскости vec2 p. Возвращает id сектора\t\n#if 0\n\t#define TF_REPLICA_ANGLE(p, n, off) \\\n\t\tfloor(mod(atan(p.x, p.y) + PI /n + off, 2.*PI)/(2.* PI /n));\\\n\t\tfloat _p_ = mod(atan(p.x, p.y) + PI /n + off, 2.* PI /n) - PI /n;\\\n\t\tp = length(p.xy) * vec2(sin(_p_),cos(_p_))\n#else\n\t#define TF_REPLICA_ANGLE(p, n, off) \\\n\t\tfloor(mod(atan(p.x, p.y) + PI /(n) + off, 2.*PI)/(2.* PI /(n)));\\\n\t\tTF_ROTATE(p.xy, -off);\\\n\t\tTF_ROTATE(p.xy, (2.* PI /(n)) * floor ( atan(p.x, p.y)/(2.* PI /(n)) + 0.5 ) )\n#endif\t\n\n//Возвращает для момента u_time номер отрезка времени 0,1,2...\n//      -------         -------\n//     |       |       |       |\n//_____|       |_______|       |\n#define TF_TIMER(u_time, intervalCount, intervalDuration) mod(floor(u_time/(intervalDuration)), (intervalCount))\n\n//-------------------Функции сочетания расстояний до объектов сцены\n//# define OR min\n//# define AND max\n// Минимальная функция сглаживания. Есть бесчисленное множество статей, но IQ объясняет это лучше всего здесь:\n// http://iquilezles.org/www/articles/smin/smin.htm\n//Гладкое сложение / Объединение / ИЛИ (k==0 без)\nfloat OR( float distA, float distB, float k ) {\n\tfloat h = clamp( 0.5 + 0.5*(distB-distA)/k, 0., 1. );\n\treturn mix( distB, distA, h ) - k*h*(1.-h);\n}\n//Гладкое умножение / Пересечение / И (k==0 без)\n#if 0\n\tfloat AND( float distA, float distB, float k ) {\n\t\tfloat h = clamp( 0.5 - 0.5*(distB-distA)/k, 0., 1. );\n\t\treturn mix( distB, distA, h ) + k*h*(1.-h);\n\t}\n#else\n\tfloat AND( float distA, float distB, float k ) {\n\t\treturn - OR (- distA, - distB, k);\n\t}\n#endif\n//Исключение / НЕ\nfloat NOT(float dist) {\n\treturn -dist;\n}\n//-------------------Функции сочетания объектов сцены\n//Сложение / Объединение / ИЛИ\n//object = OR(objectA, objectB)\nObject OR(Object objectA, Object objectB) {\n\tif (objectB.distance<objectA.distance) return objectB;\n\treturn objectA;\n}\n//Мягкое Сложение / Объединение / ИЛИ  \n//object = OR(objectA, objectB, k)\nObject OR(Object objectA, Object objectB, float k) {\n\tObject object = objectA;\n\tif (objectB.distance<objectA.distance) object = objectB;\n\tif (k!=0.) object.distance = OR(objectA.distance, objectB.distance, k);\n\treturn object;\n}\n//Умножение / Пересечение / И\n//object = AND(objectA, objectB)\nObject AND(Object objectA, Object objectB) {\n\tif (objectB.distance>objectA.distance) return objectB;\n\treturn objectA;\n}\n//Мягкое Умножение / Пересечение / И\n//object = AND(objectA, objectB, k)\nObject AND(Object objectA, Object objectB, float k) {\n\tObject object = objectA;\n\tif (objectB.distance>objectA.distance) object = objectB;\n\tif (k!=0.) object.distance = AND(objectA.distance, objectB.distance, k);\n\treturn object;\n}\n//Исключение / НЕ\n//object = NOT(objectA)\nObject NOT(Object object) {\n\tobject.distance = -object.distance;\n\treturn object;\n}\n","name":"Common","description":"","type":"common"}]}