{"ver":"0.1","info":{"id":"WtVBRy","date":"1614606799","viewed":305,"name":"Light rays[SC]","username":"Beshelmek","description":"Test","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["lightrays"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\nconst float PI = 3.141592654;\nconst float side = 0.3;\nconst float angle = PI*1.0/3.0;\nconst float sinA = 0.86602540378;\nconst float cosA = 0.5;\nconst vec3 zero = vec3(0.0);\nconst vec3 one = vec3(1.0);\n\n// generates the colors for the rays in the background\nvec4 rayColor(vec2 fragToCenterPos, vec2 fragCoord) {\n\tfloat d = length(fragToCenterPos);\n\tfragToCenterPos = normalize(fragToCenterPos);\n\t\t\n\tfloat multiplier = 0.0;\n\tconst float loop = 60.0;\n\tconst float dotTreshold = 0.90;\n\tconst float timeScale = 0.75;\n\tconst float fstep = 10.0;\n\t\n\t// generates \"loop\" directions, summing the \"contribution\" of the fragment to it. (fragmentPos dot direction)\n\tfloat c = 0.5/(d*d);\n\tfloat freq = 0.25;\t\t\n\tfor (float i = 1.0; i < loop; i++) {\n\t\tfloat attn = c;\n\t\tattn *= 1.85*(sin(i*0.3*iTime)*0.5+0.5);\n\t\tfloat t = iTime*timeScale - fstep*i;\n\t\tvec2 dir = vec2(cos(freq*t), sin(freq*t));\n\t\tfloat m = dot(dir, fragToCenterPos);\n\t\tm = pow(abs(m), 4.0);\n\t\tm *= float((m) > dotTreshold);\n\t\tmultiplier += 0.5*attn*m/(i);\n\t}\n\n\t// radius for the rings around the triforce\n\tconst float r0 = 0.345;\n\tconst float r1 = r0 + 0.02;\n\tconst float r2 = r1 + 0.005;\n\t\n\t// \"f\" controls the intensity of the ray color\n\tfloat f = 1.0;\n\t//if (d < r0) f = smoothstep(0.0, 1.0, d/r0);\n\t//else if (d < r1) f = 0.75;//(d - r0) / (r1 - r0);\n\t//else if (d < r2) f = 1.2;\n\t\t\n\n\tconst vec4 rayColor = vec4(0.9, 0.7, 0.3, 1.0);\n\t\t\n\t// Applies the pattern\n\tfloat pat = abs(sin(10.0*mod(fragCoord.y*fragCoord.x, 1.5)));\n\tf += pat;\n\tvec4 color = f*multiplier*rayColor;\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat aspect = iResolution.x / iResolution.y;\t\n\tvec3 pos = vec3(fragCoord.xy / iResolution.xy, 1.0);\n\tpos.x *= aspect;\n\t\n\tvec2 fragToCenterPos = vec2(pos.x - 0.5*aspect, pos.y - 0.5);\n\tvec4 rayCol = rayColor(fragToCenterPos,fragCoord);\n\t\n\t// barycentric coordinates of pos with respect to the triangle of the triforce it lies inside\n\tfloat u, v, w;\n\t//float c = insideTriforce(pos, aspect, u, v, w);\t\n\n\tfloat lim = 0.075;\n\t\n\tvec3 normal = vec3(0.0, 0.0, 1.0);\n\tvec3 uNormalContrib = vec3(0.0);\n\tvec3 vNormalContrib = vec3(0.0);\n\tvec3 wNormalContrib = vec3(0.0);\n\t\t\n\t// on the edge of each triangle, \"bend\" the normal in the direction of the edge\n\tif (u < lim) {\n\t\tfloat uNorm = u/lim;\n\t\tfloat offset = cos(0.5*PI*uNorm);\n\t\toffset *= offset;\n\t\tuNormalContrib = vec3(0.0, -offset, 0.0);\n\t}\n\tif (v < lim) {\n\t\tfloat vNorm = v/lim;\n\t\tfloat offset = -cos(0.5*PI*vNorm);\n\t\toffset *= offset;\n\t\tvNormalContrib = vec3(offset*cosA, offset*sinA, 0.0);\n\t}\n\tif (w < lim) {\n\t\tfloat wNorm = w/lim;\n\t\tfloat offset = cos(0.5*PI*wNorm);\n\t\toffset *= offset;\n\t\twNormalContrib = vec3(-offset*cosA, offset*sinA, 0.0);\n\t}\n\t\n\t// sums all the contributions to form the normal\n\tnormal += uNormalContrib + vNormalContrib + wNormalContrib;\n\tnormal = normalize(normal);\n\t\n\t// generate a position for the view: on a circle around the center of the screen\n\tfloat freq = 1.5*iTime;\n\tvec3 view = vec3(0.5, 0.5, 0.0) + vec3(sin(freq), cos(freq), 2.0);\n\tview = normalize(view);\n\t\n\t// Apply lambertian light\n\tfloat light = dot( view, normal );\n\t\n\t// when the barycentric coordinate falls into the [minW, maxW] interval, shade with a lighter tone\n\tfloat minW = mod(1.15*iTime, 4.0);\n\tfloat maxW = minW + 0.3;\n\tfloat s = 1.0;\n\tif (w > minW && w < maxW)\n\t\ts += 0.1;\n\n\tfragColor = rayCol;\n}\n\n","name":"Image","description":"","type":"image"}]}