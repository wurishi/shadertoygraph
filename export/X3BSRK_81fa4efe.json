{"ver":"0.1","info":{"id":"X3BSRK","date":"1710772217","viewed":49,"name":"Camera Test Framework By Smokey","username":"LilSmokeyBacon","description":"Just testing some loading and reading camera pos, based on code from David Hoskins \nbut with some slight improvements and cleaned-up code.\n","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["cameramovement"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sword(vec3 p) {\n    vec3 q = p;\n    float blade = length(q.xy) - 0.05;\n    float handle = max(abs(q.x)-0.02, abs(q.y)-0.1);\n    return min(blade, handle) - q.z;\n}\n\n\n    //rot = iFrame < 2 ? loadValue2(rotationStore) : vec2(.2, 0.);\n\n//vec2 camStore = vec2(0.0,  0.0);\n//vec3 loadValue3( in vec2 re )\n//{\n//    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 ).xyz;\n//}\n//vec2 loadValue2( in vec2 re )\n//{\n//    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 ).xy;\n//}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // We need to load in data everywhere before we can use it\n    //CREATE_LOAD(vec3, camPos2, camStore);\n    //camPos = bool(iFrame) ? camPos2 : camPos;\n    LOAD(camStore, camPos, vec3);\n    LOAD(rotationStore, rot, vec2);\n\nvec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    //vec2 mouse = iMouse.xy / iResolution.xy;\n    //mouse.y = 1.0 - mouse.y;\n    //mouse = mouse * 2.0 - 1.0;\n    //mouse.x *= iResolution.x / iResolution.y;\n\n    vec3 rayDir = normalize(vec3(uv, 1.0));\n\n    // Camera Dir\n    rot *= PI2;\n    mat3 mZ = RotationMatrix(vec3(.0, .0, 1.0), sin(iTime*.2)*.1); // More realistic camera by making it slightly move if you want to disable this set to 0.\n    mat3 mX = RotationMatrix(vec3(1.0, .0, .0),  rot.y);\n    mat3 mY = RotationMatrix(vec3(.0, 1.0, 0.0),-rot.x);\n    mX = mY * mX * mZ;\n    vec3 dir = vec3(uv.x, uv.y, 1.2);\n    dir = mX * normalize(dir);\n\n    float t = 0.0;\n    for(int i = 0; i < 64; i++)\n    {\n        vec3 p = camPos + dir * t;\n        float d = length(p) - 0.5;\n        if(d < 0.01)\n        {\n            vec3 n = normalize(vec3(length(p + vec3(0.01, 0.0, 0.0)) - length(p),\n                                    length(p + vec3(0.0, 0.01, 0.0)) - length(p),\n                                    length(p + vec3(0.0, 0.0, 0.01)) - length(p)));\n            vec3 lightDir = normalize(vec3(0.6, 0.7, -0.3));\n            float diff = clamp(dot(n, lightDir), 0.0, 1.0);\n            fragColor = vec4(vec3(diff), 1.0);\n            return;\n        }\n        t += d;\n    }\n    fragColor = vec4(vec3(0.0), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"bool isKeyDown(float key)\n{\n\treturn texture( iChannel1, vec2(key, 0.25) ).x > .0;\n}\n\nvec4 loadValue( in ivec2 dataLoc)\n{\n    return texelFetch(iChannel0, dataLoc, 0);\n}\nvoid loadValue( in ivec2 dataLoc, out vec4 ret )\n{\n    ret = texelFetch(iChannel0, dataLoc, 0);\n}\nvoid loadValue( in ivec2 dataLoc, out vec3 ret )\n{\n    ret = texelFetch(iChannel0, dataLoc, 0).xyz;\n}\nvoid loadValue( in ivec2 dataLoc, out vec2 ret )\n{\n    ret = texelFetch(iChannel0, dataLoc, 0).xy;\n}\nvoid loadValue( in ivec2 dataLoc, out float ret )\n{\n    ret = texelFetch(iChannel0, dataLoc, 0).x;\n}\n\nvoid storeValue( in ivec2 dataLoc, in vec4 val, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = (ivec2(fragCoord) == dataLoc) ? val : fragColor;\n}\nvoid storeValue( in ivec2 dataLoc, in vec3 val, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = (ivec2(fragCoord) == dataLoc) ? vec4(val, 0.0) : fragColor;\n}\nvoid storeValue( in ivec2 dataLoc, in vec2 val, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = (ivec2(fragCoord) == dataLoc) ? vec4(val, .0, .0) : fragColor;\n}\nvoid storeValue( in ivec2 dataLoc, in float val, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = (ivec2(fragCoord) == dataLoc) ? vec4(val, .0, .0, .0) : fragColor;\n}\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n   \tfragColour = vec4(0);\n    \n    float click = 0.0;\n    float oldClick = loadValue(clickStore).x;\n    if (iFrame == 0) oldClick = 0.0;\n        \n    if (iMouse.z > 0.0)\n   \t{\n      if (oldClick == .0)\n        click = 1.0;\n    }\n  \n\tstoreValue(clickStore, click,  fragColour, fragCoord);\n    \n\tvec2 tempStart = loadValue(startStore).xy;\n    float time = loadValue(timeStore).x;\n    \n    if(iFrame > 1)\n    {\n        loadValue(camStore, camPos);\n        loadValue(rotationStore, rot);\n    }\n\n    vec4 mouse = iMouse /iResolution.xyxy;\n    \n    // Oscillating saving mouse pos to move by delta mouse or something\n    if (click > 0.0)\n    {\n    \ttempStart = mouse.xy;// First clicked\n    }\n    if (mouse.z > 0.0)\n    \trot += mouse.xy - tempStart;\n    \n    \n\tstoreValue(startStore, tempStart,  fragColour, fragCoord);\n\tstoreValue(rotationStore, rot,  fragColour, fragCoord);\n    \n    rot*= PI2;\n    mat3 mX = RotationMatrix(vec3(1.0, .0, .0), rot.y);\n    mat3 mY = RotationMatrix(vec3(.0, 1.0, 0.0), -rot.x);\n    mX = mY * mX;\n\t\n    time = iTime - time;\n    float speed = time*.4;\n    if (isKeyDown(KEY_SPACE) || isKeyDown(KEY_SHIFT)) \n        speed*=2.0;\n    if (isKeyDown(KEY_W) || isKeyDown(KEY_UP))\n\t{\n\t\tcamPos += mX * vec3(0,0,1)* speed;\n\t}\n    if (isKeyDown(KEY_S) || isKeyDown(KEY_DOWN))\n\t{\n\t\tcamPos += mX * vec3(0,0,-1)* speed;\n    }\n  \tif (isKeyDown(KEY_D) || isKeyDown(KEY_RIGHT))\n\t{\n\t\tcamPos += mX * vec3(1,0,0)* speed;\n\t}\n\tif (isKeyDown(KEY_A) || isKeyDown(KEY_LEFT))\n\t{\n\t\tcamPos += mX * vec3(-1,0,0) * speed;\n\t}\n    storeValue(camStore, camPos,  fragColour, fragCoord);\n    storeValue(timeStore, iTime,  fragColour, fragCoord);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI2 6.28318530718\n// Makes it easier to load variables in Image or any other buffer tab, just make sure you have set Buffer B to iChannel0\n//#define LOAD(storePos, value, type) value = bool(iFrame) ? type(texture( iChannel0, (0.5+storePos) / iChannelResolution[0].xy, -100.0 )) : value;\n#define LOAD(storePos, value, type) value = bool(iFrame) ? type(texelFetch(iChannel0, storePos, 0)) : value;\n#define CREATE_LOAD(type, value, storePos) type value = type(texelFetch(iChannel0, storePos, 0));\n\n// Keyboard\nconst float KEY_W\t\t= 87.5/256.0;\nconst float KEY_A\t\t= 65.5/256.0;\nconst float KEY_S\t\t= 83.5/256.0;\nconst float KEY_D\t\t= 68.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\nconst float KEY_SPACE\t= 32.5/256.0;\nconst float KEY_SHIFT\t= 16.5/256.0;\n\n// Saveing and Reading\nvec3 camPos = vec3(0.0, .0, -1.0);\nvec2 rot = vec2(-1.0, 0.);\n\nivec2 camStore       = ivec2(0, 0);\nivec2 rotationStore\t = ivec2(1, 0);\nivec2 mouseStore     = ivec2(2, 0);\nivec2 startStore\t = ivec2(3, 0);\nivec2 clickStore     = ivec2(4, 0);\nivec2 timeStore      = ivec2(6, 0);\n\n// Probably could be done simpler but checks if a point is inside of a pixel at c (center)\n//float isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\n\nvec2 rot2D(inout vec2 p, float a)\n{\n    return cos(a)*p - sin(a) * vec2(p.y, -p.x);\n}\n\nmat3 RotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n","name":"Common","description":"","type":"common"}]}