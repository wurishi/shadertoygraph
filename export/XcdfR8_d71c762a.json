{"ver":"0.1","info":{"id":"XcdfR8","date":"1732712391","viewed":28,"name":"Sphere Intersection (Ray Tracer)","username":"Lounarisnia","description":"I have no idea why the shadows are pointing that way, something to do with the random function.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nvec3 at(ray r, float t) {\n    return r.origin + t*r.direction;\n}\n\nstruct sphere {\n    vec3 center;\n    float radius;\n};\n\nstruct hitRecord {\n    float t;\n    bool hit;\n};\n\nhitRecord intersect(sphere s, ray r, float tMax) {\n    vec3 center = s.center - r.origin;\n    float a = dot(r.direction, r.direction);\n    float b = dot(r.direction, center) * -2.0;\n    float c = dot(center, center) - (s.radius*s.radius);\n    \n    float discriminant = b*b - 4.0*a*c;\n    if (discriminant < 0.0) {\n        return hitRecord(0.0, false);\n    }\n    float root = (-b - sqrt(discriminant)) / (2.0*a);\n    if (root <= 0.001 || root >= tMax) {\n        root = (-b + sqrt(discriminant)) / (2.0*a);\n        if (root <= 0.001 || root >= tMax) {\n            return hitRecord(0.0, false);\n        }\n    }\n    \n    return hitRecord(root, true);\n}\n\nfloat random (vec2 uv) {\n    return fract(sin(dot(uv.xy,\n        vec2(12.9898,78.233))) * 43758.5453123);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 origin = vec3(0.0, 0.0, 0.0);\n    float focalLength = 1.0;\n    \n    float aspectRatio = iResolution.x/iResolution.y;\n    float u = 3.5;\n    float v = u / aspectRatio;\n    \n    vec3 viewportU = vec3(u, 0.0, 0.0);\n    vec3 viewportV = vec3(0.0, v, 0.0);\n    \n    vec3 upperLeft = origin - vec3(0.0, 0.0, focalLength) - viewportU/2.0 - viewportV/2.0;\n    \n    vec3 pixelDeltaU = viewportU / iResolution.x;\n    vec3 pixelDeltaV = viewportV / iResolution.y;\n    \n    vec3 pixel00 = upperLeft + 0.5*(pixelDeltaU+pixelDeltaV);\n    \n    vec3 pixelCenter = pixel00 + (pixelDeltaU*fragCoord.x) + (pixelDeltaV*fragCoord.y);\n    \n    vec3 rayDirection = normalize(pixelCenter-origin);\n    ray r = ray(origin, rayDirection);\n    \n    //sphere s = sphere(vec3(0.0, 0.0, -1.0), 0.5);\n    sphere[2] spheres = sphere[2](sphere(vec3(0.0, 0.0, -1.0), 0.5), sphere(vec3(0.0, -1000.5, 0.0), 1000.0));\n    //spheres[0].center.y = sin(iTime);\n    float tMax = 999999999.0;\n    vec3 accumulatedColor = vec3(1.0, 1.0, 1.0);\n    for (int i = 0; i < 10; i++) {\n        //tMax = 999999999.0; // Reset tMax for each bounce\n        hitRecord rec = hitRecord(0.0, false);\n        bool hasHit = false;\n        sphere hitSphere;\n        for (int j = 0; j < 2; j++) {\n            sphere s = spheres[j];\n            hitRecord rec2 = intersect(s, r, tMax);\n            if (rec2.hit) {\n                hasHit = true;\n                tMax = rec2.t;\n                hitSphere = s;\n                rec = rec2;\n            }\n         }\n         if (hasHit) {\n                vec3 intersectionPoint = at(r, rec.t);\n                vec3 normal = normalize(intersectionPoint-hitSphere.center);\n                vec3 lightDir = normalize(vec3(random(vec2(0.0, 100.0)), random(vec2(0.0, 100.0)), random(vec2(0.0, 100.0))));\n                //vec3 lightDir = normalize(vec3(0.0, 1.0, 1.5));\n                accumulatedColor *= max(dot(normal, lightDir), 0.0);\n                r = ray(intersectionPoint, normalize(lightDir + normal));\n         } else {\n                // Output to screen\n                float a = 0.5*(r.direction.y+1.0);\n                vec3 bgColor = (1.0-a)*vec3(1.0, 1.0, 1.0)+a*vec3(0.5, 0.7, 1.0);\n                accumulatedColor *= bgColor;\n                break;\n         }\n     }\n     fragColor = vec4(accumulatedColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}