{"ver":"0.1","info":{"id":"4fXXDB","date":"1705632317","viewed":101,"name":"Encandeia 3","username":"Elsio","description":"tentando entender a matemática por trás do dda. ","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["tutorial","voxel","cubes","dda","sub900ch"],"hasliked":0,"parentid":"lflXW4","parentname":"DDA is NOT simple"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define Q(z) P((z), .2, 3., .3, 2., 0.) // golfing FabriceNeyret2\n#define      P( z,   a,  b,  c, d,   e) vec3(sin(z * a) * b, cos(z * c) * d - e, z)\n\nvoid mainImage(out vec4 o, vec2 u) {\n    float t = 2. * iTime, i, s = .5;    // res\n    vec3  a = Q(t),                     // ro\n          D = normalize(Q(t + 1.) - a), // fw \n          d = vec3(D.z, 0, -D),         // rt\n          p = floor(a /= s), q,\n          R = iResolution;\n    D += mat2x3(d, cross(D, d))         // D = fw + (u.x * rt + u.y * up) / 1.2;\n            * (u - .5 * R.xy) / R.y / 1.2;\n    \n    // -----------------------------------------------\n    \n    R = abs(D);\n    a = (p - a  + .5) / D + .5 / R;\n    \n    while( q = p * s,\n           i++ < 58. && \n           \n           // 1.5 - map(p) < 0\n           min( \n               length(q - Q(q.z)),\n               min(\n                   length(q - P(q.z, .2, 1., .3, 4., 1.)),\n                   length(q - P(q.z, .3, 3., .2, 1., 1.))\n               )) < 1.5)\n           //\n          \n           a += d = step(a, a.yzx) * step(a, a.zxy) / R,\n           p += d * D;\n          \n    // -----------------------------------------------\n    \n    o = vec4(2, 1, 0, 0) * i / 58.;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* original @Elsio 570ch \n#define Q(z) P((z), .2, 3., .3, 2., 0.)\n#define P(z, a, b, c, d, e) vec3(sin(z * a) * b, cos(z * c) * d - e, z)\n#define map(p)                                                      \\\n            1.5 - min(                                              \\\n                      length(p - Q(p.z)),                           \\\n                      min(                                          \\\n                          length(p - P(p.z, .2, 1., .3, 4., 1.)),   \\\n                          length(p - P(p.z, .3, 3., .2, 1., 1.))))\n\nvoid mainImage(out vec4 o, vec2 u) {\n    vec2 R  = iResolution.xy; u = (u - .5 * R) / R.y;\n    float t = 2. * iTime, res = .5, i, far = 58.;\n    vec3 d, a, p, q, \n         ro = Q(t),\n         fw = normalize(Q(t + 1.) - ro),\n         rt = vec3(fw.z, 0, -fw.x),\n         up = cross(fw, rt),\n         D = fw + (u.x * rt + u.y * up) / 1.2;\n    \n    ro /= res;\n    p = floor(ro);\n    a = ((sign(D) * ((p - ro)  + .5) + .5) / abs(D));\n    \n    while (i++ < far && map((p * res)) > .0)\n        o = vec4(2, 1, 0, 0) * i / far,\n        d = step(a, a.yzx) * step(a, a.zxy) / abs(D),\n        p += d * D,\n        a += d;\n}\n\n*/\n","name":"Image","description":"","type":"image"}]}