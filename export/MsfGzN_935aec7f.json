{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"cubemap","id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":3,"type":"musicstream","id":"lsSSWc","filepath":"https://soundcloud.com/bob-toscano/live-303-house-ja","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"#define FIXED_STEP 0.01\n\n#define CUBEMAP iChannel0\n#define TIME iTime\n#define TRACK iChannel3\n\nmat3 rotate3DX(float a) { return mat3(1.,0.,0.,0.,cos(a),-sin(a),0,sin(a),cos(a));}\nmat3 rotate3DY(float a) { return mat3(cos(a),0.,sin(a),0.,1.,0.,-sin(a),0.,cos(a));}\nmat3 rotate3DZ(float a) { return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\nmat3 rotate3D(float x,float y,float z) { return rotate3DX(x)*rotate3DY(y)*rotate3DZ(z); }\n\n\nfloat box(vec3 o, vec3 d, float r) {\n\treturn length(max(abs(o)-d,0.0))-r;\t\n}\n\nfloat f(vec3 o) {\n\tfloat a = textureLod(TRACK,vec2(0.,1.),0.0).x*0.1-0.05;\n\tvec3 s = vec3(0.5+pow(textureLod(TRACK,vec2(0.0,0.0),0.0).x,2.0)/2.0);\n\n\tfloat f;\n\to.z -= 7.;\n\n\tmat3 r = rotate3D(TIME/3., TIME/2., TIME);\n\t\n\tvec3 br = o, bg = o, bb = o;\n\tbr.y += 1.+a*2.5;\n\tbr.x += 3.;\n\tbr*=r;\n\tf = box(br,s,0.1);\n\n\tbg.z += 1.;\n\tbg.y += a*2.5;\n\tbg*=r;\n\tf = min(f,box(bg,s,0.1));\n\n\tbb.y += 1.+a*2.5;\n\tbb.x -= 3.;\n\tbb*=r;\n\tf = min(f,box(bb,s,0.1));\n\t\n\treturn f;\n}\n\nstruct collision {\n\tbool collided;\n\tvec3 o,n;\n};\n\t\nstruct ray {\n\tvec3 o,d;\n};\n\t\ncollision trace(ray r, float s) {\n\tcollision c;\n\tc.collided = false;\n\n\tfloat t = 0.;\n\tfor (int i=0; i < 40; i++) {\n\t\tfloat ds = s*f(r.o+r.d*t);\n\t\tif (ds <= 0.) {\n\t\t\tfloat a=t-FIXED_STEP,b=t;\n\t\t\tfor(int i=0; i<8;i++) {\n\t\t\t\tt=(a+b)/2.;\n\t\t\t\tif(f(r.o+r.d*t)<=0.) b=t;\n\t\t\t\telse a=t;\n\t\t\t}\n\t\t\tvec3 x = vec3(.005,0.,0.),y = x.yxy, z = x.yyx;\n\t\t\tc.o = r.o+r.d*t;\n\t\t\tc.n = normalize(vec3(f(c.o+x)-f(c.o-x),f(c.o+y)-f(c.o-y),f(c.o+z)-f(c.o-z)));;\n\t\t\tc.collided = true;\n\t\t\tbreak;\n\t\t}\n\t\tt += ds+FIXED_STEP;\n\t}\n\t\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tvec3 col = vec3(((1.+texture(TRACK,vec2(0.,.5)).x)*0.075)/length(p));\n\tcol += vec3(((1.+texture(TRACK,vec2(0.,.5)).x)*0.075)/length(p-vec2(0.85,-0.3)));\n\tcol += vec3(((1.+texture(TRACK,vec2(0.,.5)).x)*0.075)/length(p-vec2(-0.85,-0.3)));\n\tray r = ray(vec3(0.),normalize(vec3(p,2.)));\n\n\tfloat t = mod(TIME,10.);\n\tfloat transition = smoothstep(2.,4.,t)-smoothstep(6.,8.,t);\n\t\n\tcollision c;\n\tc = trace(r,1.);\n\n\tif (c.collided) {\n\t\tvec3 n = refract(r.d,c.n,0.5);\n\t\tray r1 = ray(c.o+n*FIXED_STEP,n);\n\t\tcollision c1 = trace(r1,-1.);\n\t\tcol = mix(col,vec3(1.),distance(c1.o,c.o)/3.);\n\n\t\tvec3 reflection = texture(CUBEMAP,reflect(r.d,c.n)).xyz;\n\t\tn = reflect(r.d,c.n);\n\t\tr1 = ray(c.o+n*FIXED_STEP,n);\n\t\tc1 = trace(r1,1.);\n\t\tif (c1.collided) reflection = mix(reflection,texture(CUBEMAP,reflect(r1.d,c1.n)).xyz,0.5);\n\t\t\n\t\tcol = mix(col,reflection,transition*0.5+0.5);\n\t}\n\n\tcol *= vec3(mix(1.75,1.,transition));\n\t\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":true},"info":{"id":"MsfGzN","date":"1365732785","viewed":2906,"name":"Glass Cubes","username":"Danguafer","description":"Glassy and classic cubes :)\n\nI was trying to implement the refractions but let's Angle get fixed first.","likes":58,"published":1,"flags":64,"usePreview":0,"tags":["reflection","cube","light","glass","transparent"],"hasliked":0,"parentid":"","parentname":""}}