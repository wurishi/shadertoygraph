{"ver":"0.1","info":{"id":"flt3Rs","date":"1636553968","viewed":75,"name":"Fork Procedural gchipunov 955","username":"gchipunov","description":"Simple procedural grass no hash2","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","grass","animated","wind"],"hasliked":0,"parentid":"ldjBR3","parentname":"Procedural grass"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define scaleFactor 45.0\n#define noiseFactor 0.8\n#define windFactor 0.8\n#define grassHeight 5.0\n#define grassWidth 0.3\n\n\n//vec2 hash2( vec2 p )\n//{\n    // procedural white noise by iq\n//\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453)*noiseFactor;\n//}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col=vec3(0.0);\n    vec2 pG=fragCoord.xy / iResolution.xx * scaleFactor;\n    vec2 n=floor(pG);\n    vec2 f=fract(pG);\n\n    for (int j= 0;j>= -8;j--)\n        for (int i= -3;i<=3;i++)\n        {\n            vec2 g=vec2(float(i),float(j));\n            vec2 growFrom=n+g;//hash2(n+g)*0.8;\n\n            vec2 growTo=growFrom+windFactor*vec2(sin(0.7*iTime )); //+ (n+g).x/10.0,0);\n\n            if (pG.y>growTo.y || pG.y<growFrom.y) continue;\n\n            float rely=(pG.y-growFrom.y)/(growTo.y-growFrom.y);\n\n            float gr=log2(2.0-abs(rely))*grassWidth;\n            float dx= -pow(rely,2.0)*(growTo.x-growFrom.x);\n            #define ival 0.08\n            col=mix(col,vec3(0.0,0.0,0.0)*rely,smoothstep(gr+2.0*ival,gr,abs(growFrom.x+dx-pG.x)));\n            col=mix(col,vec3(0.0,1.0,0.0)*rely,smoothstep(gr+ival,gr-ival,abs(growFrom.x+dx-pG.x)));\n        }\n\n    fragColor=vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}