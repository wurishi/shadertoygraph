{"ver":"0.1","info":{"id":"tdXfRM","date":"1587897159","viewed":71,"name":"First 3D Shader","username":"Mocadium","description":"My first 3D Shader, there are probably tonnes of things wrong with this but I'n proud of it nonetheless :)","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.1\n\nfloat SDWave (vec3 pos) {\n    return pos.y+(sin(pos.z-6.0+(iTime*7.0))*1.2);\n}\n\nvec2 GetDist(vec3 p) {\n    vec2 plane = vec2(SDWave(p), 0.0);\n    vec2 sphere = vec2(SDSphere(p-vec3(0.0, 1.0+sin(iTime*7.0)*1.2, 4.0), 2.0), 1.0);\n\n    return compareSDF(plane, sphere);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p).x;\n    vec2 w = vec2(0.01, 0.0);\n    return normalize(d-vec3(GetDist(p-w.xyy).x,\n                  GetDist(p-w.yxy).x,\n                  GetDist(p-w.yyx).x));\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\n    float d = 0.0;\n    vec2 res = vec2(-1.0, -1.0);\n    \n    for (int i=0; i<MAX_STEPS && d<MAX_DIST; i++) {\n        vec2 dS = GetDist(ro+(d*rd));\n        d += dS.x;\n        if (abs(dS.x) < SURF_DIST) {\n        \tres = vec2(d, dS.y);\n            break;\n        }\n    }\n\treturn res;\n}\n\nfloat CalcSoftShadows(vec3 ro, vec3 rd){\n    float k = 4.0;\n    float n = 1.0;\n    for(float t = 0.02; t < MAX_DIST;){\n        float h = GetDist(ro + t*rd).x;\n        \n        if(h < SURF_DIST){\n            return 0.0;\n        }\n        n = min(n, h*k/t);\n        t += h;\n    }\n\n    return n;\n}\n         \nfloat GetLight(vec3 p) {\n    vec3 light = vec3(-2.0, 7.0, -2.0);\n    vec3 vLight = normalize(light-p);\n    vec3 vNormal = GetNormal(p);\n    float l = clamp(dot(vLight, vNormal), 0.0, 1.0);\n    float d = length(light-p);\n    l *= CalcSoftShadows(p+(vNormal*(SURF_DIST*2.0)), vLight);\n    return l;\n}\n\nfloat GetLightDir(vec3 p) {\n    vec3 light = vec3(1.0, 0.4, 0.0);\n    vec3 vLight = normalize(light);\n    vec3 vNormal = GetNormal(p);\n    float l = clamp(dot(vLight, vNormal), 0.0, 1.0);\n    float d = length(light);\n    l *= CalcSoftShadows(p+(vNormal*(SURF_DIST*2.0)), vLight);\n    return l;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-(iResolution.xy*0.5))/iResolution.y;\n    vec3 ro = vec3(0.0, 3.0, -7.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    vec2 hit = RayMarch(ro, rd);\n    \n    if (hit.y > -1.0) {\n        float d = hit.x;\n        vec3 oCol = vec3(0.0, 0.0, 0.0);\n        switch(int(hit.y)) {\n            case 0:\n                oCol = vec3(0.4, 0.4, 0.8);\n                break;\n            case 1:\n                oCol = vec3(1.0, 0.0, 0.0);\n                break;\n        }\n        vec3 al = vec3(0.1);\n        vec3 dl = vec3(GetLightDir(ro+(rd*d)))*0.4;\n        vec3 pl = vec3(GetLight(ro+(rd*d)))*0.8;\n\n        col = oCol*(al+pl+dl);\n        \n    }\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float SDSphere (vec3 pos, float r) {\n    return length(pos)-r;\n}\n\nvec2 compareSDF (vec2 a, vec2 b) {\n\treturn a.x < b.x ? a : b;   \n}","name":"Common","description":"","type":"common"}]}