{"ver":"0.1","info":{"id":"sdBfDd","date":"1647963693","viewed":118,"name":"Volumetric Sphere test 3","username":"MatheoMoinet","description":"Basic volumetric rendering while trying to be correct regarding physics","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"ssBfR3","parentname":"Volumetric Sphere test 2"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 1000\n#define MAX_DIST 100.\n#define SURF_DIST .0001\n#define BBOX_SIZE vec3(5.,4.5,5.)\n\n#define LIGHT_MARCH_STEP_SIZE 0.1\n#define LIGHT_MARCH_SAMPLING_STEP_SIZE 0.2\n#define VOLUME_MARCH_STEP_SIZE 0.01\n#define TRANSPARENCY_STOP_THRESHOLD 0.01\n\n#define WHITE_BACKGROUND 0\n#define NO_LIGHT 0\n#define TEST_ON 1\n#define USE_ALBEDO 0\n\n#if USE_ALBEDO == 1  //  Either set the albedo value (which corresponds to the material color)\nconst vec3 albedo = vec3(1.,1.,0.1);  //Portion of light returning to the observer\nconst vec3 sigma_t = vec3(0.9, 0.5, 0.5);  //Portion of light that keeps going after traversing the volume\nconst vec3 sigma_s = albedo*(1.-sigma_t);\nconst vec3 sigma_a = (1.-albedo)*(1.-sigma_t);\n\n#else  // Or set the sigma_t and sigma_a values\n// sigma_s + sigma_a +  sigma_t MUST be equal to vec3(1.)\nconst vec3 sigma_s = vec3(.1,.2,.3);  //Portion of light scattered back when traversing the volume\nconst vec3 sigma_a = vec3(.1);  //Portion of light absorbed by the material\nconst vec3 sigma_t = 1.-sigma_a-sigma_s;  //Portion of light that keeps going after traversing the volume\n\n#endif\n\nfloat unit_density = 1.;\nvec3 lightColor = vec3(2.);\n\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdSphere(vec3 p, vec3 center, float radius){\n    return distance(p,center)-radius;\n}\n\nfloat GetDist(vec3 p) {\n    float d = sdBox(p, BBOX_SIZE);\n    //d += sdBox(p, vec3(2.,2.,2.));\n\n    return d;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\n\nfloat RayMarchInside(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float last_dS = 0.;\n    float lastdS = 0.;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += abs(dS);\n \n        if (dO>MAX_DIST || abs(dS)<SURF_DIST*10.0 && last_dS<dS){\n            break;\n        }\n        last_dS = dS;\n    }\n    \n    return dO;\n}\n\n\nvec2 RayMarchVolume(vec3 ro, vec3 rd) {\n    if (GetDist(ro) < 0.){\n        return vec2(0.,RayMarchInside(ro,rd) );\n    }\n\n\tfloat dO=0.;\n    \n    bool is_inside = false;\n    float in_dist = 0.;\n    float out_dist = 0.;\n    float last_dS = 0.;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += abs(dS);\n \n        if (dO>MAX_DIST){\n            break;\n        }\n        if (abs(dS)<SURF_DIST){\n            if (is_inside == false){\n                in_dist = dO;\n                is_inside = true;\n            } else if (last_dS<dS){\n                out_dist = dO;\n                return vec2(in_dist,out_dist);\n            }\n            dO+= SURF_DIST;//SURF_DIST*2.-dS;\n        }\n        last_dS = dS;\n    }\n    return vec2(dO);\n}\n\n\n\nfloat occupancyFunction(vec3 p){\n    float sphere1 = step(0., -sdSphere(p,vec3(0.5,-0.5,0.),  2.));\n    float sphere2 = step(0., -sdSphere(p,vec3(-0.5,0.,0.),  2.));\n    float sphere3 = step(0., -sdSphere(p,-vec3(cos(iTime)*2.,3.,0.),  0.5));\n    float objects = min (1., sphere1 + sphere2 + sphere3);//\n    return objects;\n}\n\n\nfloat GetLocalDensity(vec3 p, float len){\n    float occupancy = occupancyFunction(p);\n    return occupancy*unit_density;\n}\n\nvec3 calculateTransparency(float len, float density){\n    return exp(-len *density * (1.-sigma_t) );\n}\n\n\nvec4 GetVolumeColor(vec3 ro, vec3 rd, float dist_start, float dist_end,vec3 lightDir, vec3 background){\n    if (dist_end-dist_start == 0.){\n        return vec4(0.);\n    }\n    \n    vec3 color = vec3(0.); //accumulated color as we move into the volume\n    vec3 T_acc = vec3(1.); //accumulated transparency as we move into the volume\n    vec3 localTransparency;\n\n    float total_dist = dist_end-dist_start;\n    float step_size = VOLUME_MARCH_STEP_SIZE;\n\n    float localDensity;\n    vec3 p;\n    \n    vec3 albedo = sigma_s / (sigma_s + sigma_a);\n    \n    for (float dist=0.; dist<total_dist; dist+=step_size){\n        p = ro + rd*(dist_start+dist); //p += rd*dist;\n        localDensity = GetLocalDensity(p, step_size);\n        \n        if (localDensity>0.){\n            localTransparency = calculateTransparency(step_size, localDensity);\n            vec3 localOpacity = 1.-localTransparency;\n            vec3 phase = vec3(1.);  //Fraction of light reflected depending on the angle to the light, per color. 1. for now\n            vec3 illum = lightColor * phase; //Should actually compute how much light reaches through the volume\n            \n            vec3 lightReachingPoint = illum * phase * T_acc;\n            //vec3 lightReachingPoint = illum * phase ;\n            vec3 materialLocalColor = albedo * localOpacity;\n            color+= T_acc * materialLocalColor * lightReachingPoint ;\n            \n            T_acc*=localTransparency; //The probability to have light through multiple slices is the multiplication of the probability of the slices\n            \n            if ((T_acc.x + T_acc.y + T_acc.z) < TRANSPARENCY_STOP_THRESHOLD){\n                st_assert(false);\n                return vec4(color,T_acc) ;//break;\n            }\n            \n        }\n        step_size = VOLUME_MARCH_STEP_SIZE*max(0.05,sqrt(dist)); //max to avoid infinite loop when dist = 0\n\n    }\n\n    color = color + T_acc * background;\n    return vec4(color,T_acc) ;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.*(fragCoord.xy-(0.5*iResolution.xy))/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    #if NO_LIGHT\n        lightColor *= vec3(uv.y<0.);\n    #endif\n\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 background = vec3(0.);\n    #if WHITE_BACKGROUND\n        background = vec3(uv.x>0.);\n    #endif\n    vec3 col = background;\n   \n    vec2 distances = RayMarchVolume(ro, rd);\n    float d = distances.x;\n    \n    vec3 lightPos = vec3(sin(iTime),1.,cos(iTime));\n\n    \n    if(d<MAX_DIST) {\n        vec3 lightDir = normalize(lightPos);\n        vec4 volumeColor = GetVolumeColor(ro,rd,distances.x,distances.y, lightDir, col);\n        col = volumeColor.xyz;\n    }\n    \n    \n    col = pow(col,vec3(1./2.2));\n    fragColor = vec4( col ,1.0);\n\n    #if TEST_ON == 1\n        st_assert( length((sigma_s + sigma_a + sigma_t) - 1.) < 1e-5);\n\n    #endif\n    \n}","name":"Image","description":"","type":"image"}]}