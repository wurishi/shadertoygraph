{"ver":"0.1","info":{"id":"sdfcRB","date":"1642286702","viewed":93,"name":"2D Box: Area Based Anti-aliasing","username":"sowi","description":"Draws a simple box, perfectly anti-aliased: analytical formula for coverage of each pixel.\n\nSince it's my first try with ShaderToy, I'll stop at the trivial case of a box oriented square to the pixel grid - rotation will come in another Toy.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","antialiasing","box","area"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 px2uv(in vec2 px) { return 2.0 * px / iResolution.y; }\nvec2 uv2px(in vec2 uv) { return 0.5 * uv * iResolution.y; }\n\n// Returns area of pixel at center 'p' covered by the box\nfloat boxArea(in vec2 p, vec2 boxP, vec2 boxS)\n{\n    boxP -= p;  // move box origin to 'p'\n    // Calculate intersection between pixel square and the box\n    vec2 bl = max(-px2uv(vec2(0.5)), boxP);\n    vec2 tr = min( px2uv(vec2(0.5)), boxP+boxS);\n    vec2 s = uv2px(max(tr - bl, 0.));  // size of the intersection\n    return s.x * s.y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    const vec2 off  = vec2(130, 60);\n    const vec2 size = vec2(250, 150);\n    \n    // Normalized square pixels in (-1, 1) range\n    vec2 p = (2.*fragCoord - iResolution.xy) / iResolution.y;\n    \n    // Move the box around slowly to show anti-aliasing\n    vec2 move = vec2(cos(0.1*iTime), sin(0.05*iTime));\n    vec2 boxP = px2uv(move * off - size*0.5);\n    vec2 boxS = px2uv(size);\n\n    // Time varying background color\n    vec3 col = 0.8 + 0.2*cos(iTime + p.xyx + vec3(1,2,4));\n    \n    float area = boxArea(p, boxP, boxS); // calculate pixel coverage\n    col = mix(col, vec3(0.), area);  // alpha-blend with background\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}