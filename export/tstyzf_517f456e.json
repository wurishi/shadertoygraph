{"ver":"0.1","info":{"id":"tstyzf","date":"1601460744","viewed":221,"name":"Raytracing - Ripples","username":"shadermonkey","description":"Use raytracing technique to perform refraction for ripples","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","reflection","ripples","wave","refraction","water","glass","transparent","physics","simulate","shadermonkey"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.141529\nfloat f = 1.; //frequency\nfloat n = 1.33; // water refractive index\nfloat c = 1.; // wave Max Height constant\nfloat k = 4.; //wave speed\nfloat dr = .001; //get slope of wave precision\nfloat floorHeight = 0.; //background texture height\nfloat waterThickness = 3.; \nfloat rainDropPerSec = 5.;\n\nstruct Ray{\n    vec3 o;\n    vec3 d;\n};\n    \nfloat Random(float n){\n    return fract(cos(n*89.42)*343.42);\n}\nvec3 ClosestPoint(Ray r, vec3 p) {\n    // returns the closest point on ray r to point p\n    return r.o + max(0., dot(p-r.o, r.d))*r.d;\n}\n\nfloat DistRay(Ray r, vec3 p) {\n\treturn length(p-ClosestPoint(r, p));\n}\n\nRay GetRay(vec2 uv, vec3 camPos, vec3 dir, float zoom){\n    Ray r;\n    r.o = camPos;\n    vec3 f = normalize(dir);\n    vec3 right = cross(vec3(.0,1.,.0), f);\n    vec3 u = cross(f,right);\n    \n    vec3 c = r.o + f*zoom;\n    vec3 i = c + uv.x *right + uv.y *u;\n    r.d = normalize(i -r.o);\n    return r;\n}\n\n\nfloat Map(float v, vec2 org, vec2 new){\n    if(v <= org.x) return new.x;\n    if(v >= org.y) return new.y;\n    return (v-org.x)/(org.y-org.x)*(new.y-new.x) + new.x;\n}\n\nmat3 Rotate(float t, vec3 u){\n    float a = 1.-cos(t);\n    return mat3(cos(t) + u.x*u.x*a, u.x*u.y*a - u.z*sin(t), u.x*u.z*a + u.y*sin(t),\n                u.y*u.x*a + u.z*sin(t), cos(t)+u.y*u.y*a, u.y*u.z*a - u.x*sin(t),\n                u.z*u.x*a - u.y*sin(t), u.z*u.y*a+u.x*sin(t), cos(t) + u.z*u.z*a);\n}\nRay Rand(){\n    Ray r;\n    r.o = vec3(10.);\n    r.d= vec3(10.);\n    return r;\n}\n\nfloat GetRefractedAngle(float ni, float thetai, float nf){\n    return asin(ni/nf*sin(thetai));\n}\n\nRay GetRipplesRefractedRay(Ray r, float H, float A, float slopeAngle, float d){\n    float eta = slopeAngle;\n    float theta = acos(dot(r.d, vec3(.0,.0,1.))); // rayAngle\n    float l = H/cos(theta);\n    vec3 incidentPoint = r.o + r.d*l;\n    \n    float Anglei = theta;\n    \n    if (slopeAngle < 0.){\n        eta = - eta;\n    }\n    Anglei = abs(eta - theta);\n    \n    float phi = GetRefractedAngle(1.,Anglei, n); //refracted angle\n    \n    vec3 refractedDir = normalize(r.d*Rotate(Anglei-phi, normalize(cross(r.d,vec3(0.,0.,1.)))));\n    \n    Ray ray;\n    ray.o = incidentPoint - refractedDir *l*n;\n    ray.d = refractedDir;\n\treturn ray;\n}\n\nfloat GetSlope(float dy, float dx){\n    return atan(dy/dx);\n}\n\nfloat GetWaveAmplitude(float t, float r){\n    if( t - r <= 0.1 ) return 0.;\n    float A2 = cos((t-r)*2. * pi * f);\n    float A = exp(-(t-r))*A2;//Amplitude\n    return c *A/(r+1.)/(r+1.);//intensity\n}\n\nvec3 GetTextureWithRay(Ray r, vec4 rect, float z){\n    //rect = (left.x, right.x, down.y, up.y)\n    float dz = (z - r.o.z);\n    float dx = r.d.x/r.d.z*dz;\n    float dy = r.d.y/r.d.z*dz;\n    \n    float x = Map(dx + r.o.x, vec2(rect.x, rect.y), vec2(-.5, .5));\n    float y = Map(dy + r.o.y, vec2(rect.z, rect.w),  vec2(-.5, .5));\n    \n    if(x > .5 || x < -.5 || y > .5 || y < -.5) {\n        return vec3(0.);\n    } else return texture(iChannel0, vec2(x,y)).xyz;\n}\n\nfloat GetRipplesRadius(Ray ray, float H, vec3 c){\n    float dx = ray.d.x/ray.d.z*H;\n    float dy = ray.d.y/ray.d.z*H;\n    vec2 p = ray.o.xy + vec2(dx,dy);\n    vec3 p2 = vec3(p.x,p.y,c.z); // rendering point\n    return length(c-p2); //radius of circle\n}\n\nvec2 GetRipplesHeightNSlope(Ray ray, float r, float t){\n    float A = GetWaveAmplitude(t, r);\n    float Aplus = GetWaveAmplitude(t, r+dr);\n    float Aminus = GetWaveAmplitude(t, r - dr);\n    float slopeAngle = GetSlope(Aplus - Aminus, 2.*dr);\n    return vec2(A,slopeAngle);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //if(Random(3.) > .38) return ;\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv -= vec2(.5);\n    \n    //Define\n    vec3 col = vec3(0.);\n    float t = iTime*k;\n    \n    //GetRefractedRayvec3(-4.,-3.,-8.)\n    Ray ray = GetRay(uv, vec3(-4.,-3.,-8.), vec3(0.,1.,1.), 1.);\n    float z = floorHeight - waterThickness;\n    float H = abs(z - ray.o.z); //Height from ray origin to water level\n    float di = k/rainDropPerSec;\n    \n    vec2 wave = vec2(0.);\n    for(float i = 0.; i < 1000.; i+= di){\n        if(t - i <= 0.) break;\n        float x = Map(Random(8.*i), vec2(-0.,1.), vec2(-8., 23.5));\n        //if(Random(-56.*i) < 0.01 ) return; \n        float y = Map(Random(-56.*i), vec2(-0.,1.), vec2(-8.,8.));\n        vec3 c = vec3(x,y,z);\n        float r = GetRipplesRadius(ray, H, c);\n        if(r >= 10.) continue;\n    \twave += GetRipplesHeightNSlope(ray, r, t-i);\n    }\n    \n    ray = GetRipplesRefractedRay(ray, H, wave.x, wave.y, waterThickness);\n    \n    \n    //Display background texture\n    col += GetTextureWithRay(ray, vec4(-10.,25.5,-10.,10.), floorHeight);\n    if(ray.o.x == 10.) col = vec3(1.0,0.,0.);\n    \n    fragColor = vec4(col,1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}