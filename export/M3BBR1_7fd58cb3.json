{"ver":"0.1","info":{"id":"M3BBR1","date":"1729181951","viewed":105,"name":"PinkTunel","username":"louijoe","description":"PinkTunel","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["love"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 'Warp Speed 2' - 爱情粉红优化版（去除过曝白斑）\n// David Hoskins 2015.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Fork of:-   https://www.shadertoy.com/view/Msl3WH\n//----------------------------------------------------------------------------------------\n\n#define PI 3.1415926535897932384626433832795\n\n// 简单噪声函数\nfloat noise(vec2 p)\n{\n    return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// HSV到RGB转换函数\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Reinhard色调映射函数，用于压制高光\nvec3 toneMapping(vec3 color)\n{\n    return color / (color + vec3(1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float s = 0.0, v = 0.0;\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    float time = (iTime - 2.0) * 58.0;\n    vec3 col = vec3(0);\n    vec3 init = vec3(sin(time * 0.0032) * 0.3, 0.35 - cos(time * 0.005) * 0.3, time * 0.002);\n    \n    for (int r = 0; r < 100; r++) \n    {\n        vec3 p = init + s * vec3(uv, 0.05);\n        p.z = fract(p.z);\n        // 混沌循环\n        for (int i = 0; i < 10; i++) p = abs(p * 2.04) / dot(p, p) - 0.9;\n        v += pow(dot(p, p), 0.7) * 0.06;\n        \n        // 使用HSV色彩空间生成粉红色调，加入噪声\n        float hue = 0.85 + 0.23 * noise(vec2(s, iTime * 0.05)); // 0.85 ~ 0.87\n        float saturation = 0.9 + 0.3 * sin(iTime * 0.3 + s * 5.0); // 动态饱和度\n        // 限制明度的最大值，防止过曝\n        float value = clamp(0.5 + 0.5 * v, 0.0, 0.9); // 动态亮度，最大限制为0.9\n        \n        vec3 hsv = vec3(hue, saturation, value);\n        vec3 rgb = hsv2rgb(hsv);\n        \n        // 降低颜色累积的强度，防止颜色过高\n        col += rgb * v * 0.00115; // 从0.0001减小到0.00005\n        s += 0.045;\n    }\n    \n    // 应用渐变效果\n    float gradient = smoothstep(-1.0, 1.0, uv.y);\n    col *= gradient;\n    \n    // 应用色调映射，进一步压制高光\n    col = toneMapping(col);\n    \n    // 最终颜色限制在0到1之间\n    fragColor = vec4(clamp(col, 0.0, 1.0), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}