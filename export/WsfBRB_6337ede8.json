{"ver":"0.1","info":{"id":"WsfBRB","date":"1588454968","viewed":108,"name":"Simple raymarch + materials","username":"blepfo","description":"Super simple raymarched scene with multiple materials. \nFeedback is appreciated","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Reference Articles: \n// www.michaelwalczyk.com/blog/2017/5/25/ray-marching\n// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n// https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n// https://learnopengl.com/Lighting/Materials\n//\n// Reference ShaderToys for code structure\n// https://www.shadertoy.com/view/Xtd3z7\n// https://www.shadertoy.com/view/4lBBz1\n// https://www.shadertoy.com/view/Xld3z7\n\n\n#define MAX_RAY_STEPS (128)\n#define MIN_HIT_DISTANCE (0.01)\n#define MAX_TRACE_DIST (1000.)\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Material {\n\tvec3 diffuse;\n    vec3 specular;\n    float shiny;\n};\n\nstruct SceneObj {\n    float sdf;\n    Material material;\n};\n\nstruct PhongLight {\n    vec3 origin;\n    vec3 intensity;\n};\n\n\nmat3 rotateZ(float theta) {\n    return mat3(\n        cos(theta), -sin(theta), 0,\n        sin(theta), cos(theta), 0,\n        0., 0., 1.\n    );\n}\n\nmat3 rotateX(float theta) {\n    return mat3(\n        1, 0, 0,\n        0, cos(theta), -sin(theta),\n        0, sin(theta), cos(theta)\n    );\n}\n\n\nSceneObj objUnion(SceneObj s1, SceneObj s2) {\n    if (s1.sdf < s2.sdf) {\n        return s1;\n    } else {\n        return s2;\n    }\n}\n\n// Perturbed sphere with associated material\nSceneObj sphereSdf(vec3 p, float r, float blobScale, Material m) {\n    float displacement = sin(10. * p.x) * sin(10. * p.y) * sin(10. * p.z) * blobScale;\n    return SceneObj(\n        length(p) - r + displacement,\n        m\n    );\n} \n\n// Define the scene\nSceneObj map(vec3 p) {\n    Material m1 = Material(\n        vec3(0.111,0.694,0.820),\n        vec3(0.078,0.166,0.275),\n        0.1\n    );\n    vec3 sphereP1 = rotateX(iTime)*rotateZ(iTime)*(p + vec3(-3, -1., -0.5));\n    SceneObj s1 = sphereSdf(sphereP1, 2., 0.1, m1);\n    \n    Material m2 = Material(\n        vec3(0.086,0.385,0.087),\n        vec3(0.280,0.505,0.326),\n        3.\n    );\n    vec3 sphereP2 = (rotateZ(-iTime)*rotateX(-iTime*.5)*.7)*(p - vec3(-2.5, -1. ,-1.300));\n    SceneObj s2 = sphereSdf(sphereP2, 1.5, 0.1, m2);\n    \n    return objUnion(s1, s2);\n}\n\n// SDF of scene used for normal calculation\nfloat sceneSdf(vec3 p) {\n    SceneObj s = map(p);\n    return s.sdf;\n}\n\n// Approximate normal using SDF gradient\n// https://iquilezles.org/articles/normalsSDF\nvec3 sceneNormal(vec3 p) {\n    const vec2 epsilon = vec2(0.001, 0.);\n    float gx = sceneSdf(p + epsilon.xyy) - sceneSdf(p - epsilon.xyy);\n    float gy = sceneSdf(p + epsilon.yxy) - sceneSdf(p - epsilon.yxy);\n    float gz = sceneSdf(p + epsilon.yyx) - sceneSdf(p - epsilon.yyx);\n    vec3 g = vec3(gx, gy, gz);\n    return normalize(g);\n}\n\n// Find distance to intersection with scene along ray\nfloat rayMarch(Ray r) {\n\tfloat distanceTraveled = 0.;\n    for(int i = 0; i < MAX_RAY_STEPS; i++) {\n        vec3 p = r.origin  + (r.direction * distanceTraveled);\n        float d = sceneSdf(p);\n        distanceTraveled += d;\n        if ((d < MIN_HIT_DISTANCE) \n            || (distanceTraveled >= MAX_TRACE_DIST)) {\n            return distanceTraveled;\n        }\n    }\n    return MAX_TRACE_DIST; \n}\n\n// Intensity of Phong light at position p\nvec3 phongIlluminate(PhongLight l, vec3 p, vec3 eye) {\n    Material material = map(p).material;\n\t// Calculate diffuse + specular lighting at p\n    vec3 normal = sceneNormal(p);\n    vec3 lightDirection = normalize(p - l.origin);\n    vec3 reflectDirection = normalize(reflect(lightDirection, normal));\n\tvec3 viewerDirection = normalize(p - eye); \n    float diffuseIntensity = max(0., dot(normal, lightDirection));\n    float specularIntensity = pow(max(dot(reflectDirection, viewerDirection), 0.), material.shiny);\n\t\n    \n    return \n        (l.intensity * diffuseIntensity * material.diffuse)\n        + (l.intensity * specularIntensity * material.specular);\n}\n\n\n// Returns color for scene by marching along ray r from camera position eye\nvec3 renderScene(Ray r, vec3 eye) {\n    // Setup Lighting\n    vec3 l1Pos = vec3(10, -5, -3);\n    vec3 l1Intensity = vec3(1.25);\n    PhongLight l1 = PhongLight(l1Pos, l1Intensity); \n    \n    vec3 l2Pos = vec3(-5, 3, -1);\n    vec3 l2Intensity = vec3(0.9);\n    PhongLight l2 = PhongLight(l2Pos, l2Intensity);\n    \n    float sceneDist = rayMarch(r);\n    if (sceneDist >= MAX_TRACE_DIST) {\n        // Background\n        return vec3(0.1);\n    } else {\n        vec3 p = r.origin + (r.direction*sceneDist);\n        \n    \tvec3 lighting = \n            phongIlluminate(l1, p, eye)\n            + phongIlluminate(l2, p, eye);\n        return lighting;\n    }  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    // Move to [-.5, -.5.] x [.5, .5]\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    // Remap to [-1, -1] x [1, 1]\n    uv *= 2.;\n    \n    vec3 cameraPos = vec3(0., 0., -6);\n    vec3 rd = vec3(uv, 1.);\n\tRay r = Ray(cameraPos, rd);\n    vec3 color = renderScene(r, cameraPos);\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}