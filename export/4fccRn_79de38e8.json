{"ver":"0.1","info":{"id":"4fccRn","date":"1730134824","viewed":157,"name":"1 light source per color channel","username":"aerowave","description":"by rendering a scene with lights of pure red, green and blue, you can control which light source is active by multiplying the original image with red, green or blue\n\nclick to see the original rendered image\n\nWASD + arrow keys to move camera (resets image)","likes":8,"published":3,"flags":48,"usePreview":0,"tags":["raytracing","intersection","pathtracing","channel","rgba"],"hasliked":0,"parentid":"l3fyDM","parentname":"raytracer rework"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 hsv2rgb(vec3 c){\n\tvec4 K=vec4(1.,2./3.,1./3.,3.);\n\treturn c.z*mix(K.xxx,clamp(abs(fract(c.x+K.xyz)*6.-K.w)-K.x,0.0,1.0),c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    if (iMouse.z <= 0.0) {\n        col = (\n            col.r * vec3(hsv2rgb(vec3(iTime * 0.2,1,1))) +\n            col.g * vec3(1,0,0) +\n            col.b * vec3(1)\n        );\n    }\n\n    // hdr to rgb\n    col = col / (col + 0.8);\n    col = pow(col, vec3(0.454545454));\n    \n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// 0 is regular noise, 1 is same values regardless of pixel\n#define NOISE_STYLE 1\n#define SAMPLES 16\n#define REFLECTIONS 4\n#define SUBPIXEL\n\nconst float EPSILON = 0.001;\nconst float PI = asin(1.0) * 2.0;\n\nvoid rotate(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nstruct Material {\n    vec3 color;\n    vec3 emission;\n    float roughness;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    float length;\n};\n\nstruct HitInfo {\n    bool hit;\n    float dist;\n    vec3 position;\n    vec3 normal;\n    int ID;\n    bool backfacing;\n    Ray ray;\n};\n\nMaterial getMaterial(HitInfo info) {\n    int ID = info.ID;\n    if (ID == 0) return Material(vec3(1), vec3(0), 0.02);\n    if (ID == 1) return Material(vec3(1), vec3(10,0,0), 1.0);\n    if (ID == 2) return Material(vec3(1), vec3(0,10,0), 1.0);\n    if (ID == 3) return Material(vec3(1), vec3(0,0,10), 1.0);\n    \n    //if (ID == 5) return Material(vec3(0), vec3(info.backfacing), 1.0);\n    else return Material(vec3(0.9), vec3(0), 1.0);\n}\n\nvec3 skyColor(vec3 n) {\n    return mix(\n        mix(vec3(1), vec3(0,0,1), n.y),\n        mix(vec3(0), vec3(1,0,1), -n.y),\n        clamp(-n.y * 100.0 * 50.0, 0.0, 1.0)\n    ) * 2.0;\n}\n\n// normal and intersection functions\nHitInfo sphere(Ray ray, vec3 pos, float radius) {\n    HitInfo info;\n    // intercection code from iq\n\tvec3 oc = ray.origin - pos;\n\tfloat b = dot(oc, ray.direction);\n\tfloat c = dot(oc, oc) - radius * radius;\n\tfloat h = b*b - c;\n\tif (h > 0.0) {\n        info.dist = -b-sqrt(h);\n        info.backfacing = info.dist < 0.0;\n        if (info.backfacing) info.dist = -b+sqrt(h);\n        info.position = ray.origin + ray.direction * info.dist;\n        info.normal = (info.position-pos)/radius;\n        if (info.backfacing) info.normal *= -1.0;\n        info.hit = true;\n    }\n    return info;\n}\n\nHitInfo plane(Ray ray, vec3 dir, float offset) {\n    HitInfo info;\n    // intercection code from iq\n    info.dist = (-offset - dot(dir,ray.origin)) / dot(dir, ray.direction);\n    \n    if (info.dist > 0.0) {\n        info.hit = true;\n        info.position = ray.origin + ray.direction * info.dist;\n        info.normal = dir;\n        info.backfacing = dot(ray.direction, dir) < 0.0;\n    }\n    return info;\n}\n\nHitInfo box(Ray ray, vec3 pos, vec3 rad) {\n    HitInfo info;\n    vec3 m = 1.0/ray.direction;\n    vec3 n = m*(ray.origin - pos);\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if(tN<tF && tF>0.0) {\n        if (tN > 0.0) {\n            info.backfacing = true;\n            info.dist = tN;\n            info.normal = -sign(ray.direction)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n        } /*else {\n            info.dist = tF;\n            info.normal = sign(ray.direction)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n        }*/\n        \n        info.position = ray.origin + ray.direction * info.dist;\n        \n        info.hit = true;\n    };\n    return info;\n}\n\nuvec3 murmurHash31(uint src) {\n    const uint M = 0x5bd1e995u;\n    uvec3 h = uvec3(1190494759u, 2147483647u, 3559788179u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 3 outputs, 1 input\nvec3 hash31(float src) {\n    uvec3 h = murmurHash31(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuvec3 murmurHash33(uvec3 src) {\n    const uint M = 0x5bd1e995u;\n    uvec3 h = uvec3(1190494759u, 2147483647u, 3559788179u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 3 outputs, 3 inputs\nvec3 hash33(vec3 src) {\n    uvec3 h = murmurHash33(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n// hash functions\nuvec2 murmurHash21(uint src) {\n    const uint M = 0x5bd1e995u;\n    uvec2 h = uvec2(1190494759u, 2147483647u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 2 outputs, 1 input\nvec2 hash21(float src) {\n    uvec2 h = murmurHash21(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// camera controller\n\nconst int KEY_W = 87;\nconst int KEY_A = 65;\nconst int KEY_S = 83;\nconst int KEY_D = 68;\n\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\n\nconst int KEY_SPACE = 32;\n\nconst float CAMERA_SPEED = 1.0;\n\nint isPressed(int key) {\n    return int(texelFetch(iChannel1, ivec2(key, 0), 0).x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0);\n    \n    // ignore unused pixels\n    if (fragCoord.y > 1.0) return;\n    \n    // get data from previous frame\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    /* POSITION */\n    if (fragCoord.x == 0.5) {\n    \n        // initial data\n        if (iFrame == 0) fragColor = vec4(-4.0,4.0,1,0);\n        \n        vec3 rotation = texelFetch(iChannel0, ivec2(1,0), 0).xyz;\n        vec3 velocity = vec3(\n            sin(PI * rotation.z) * float(isPressed(KEY_S) - isPressed(KEY_W)) * cos(PI * rotation.x) - cos(PI * -rotation.z) * float(isPressed(KEY_A) - isPressed(KEY_D)),\n            sin(PI * rotation.x) * float(isPressed(KEY_S) - isPressed(KEY_W)),\n            cos(PI * rotation.z) * float(isPressed(KEY_S) - isPressed(KEY_W)) * cos(PI * rotation.x) - sin(PI * -rotation.z) * float(isPressed(KEY_A) - isPressed(KEY_D))\n        ) * 4.0;\n\n        fragColor.xyz += velocity * CAMERA_SPEED * iTimeDelta;\n        return;\n    }\n    \n    /* DIRECTION */\n    if (fragCoord.x == 1.5) {\n    \n        // initial data\n        if (iFrame == 0) fragColor = vec4(0.18,0,-0.3,0);\n        \n        // arrow keys\n        fragColor.x -= float(isPressed(KEY_UP) - isPressed(KEY_DOWN)) * iTimeDelta;\n        fragColor.z -= float(isPressed(KEY_RIGHT) - isPressed(KEY_LEFT)) * iTimeDelta;\n        \n        // clamp\n        if (fragColor.x > 0.5) fragColor.x = 0.5;\n        if (fragColor.x < -0.5) fragColor.x = -0.5;\n        \n        return;\n    }\n    \n    /* RENDER TIME */\n    if (fragCoord.x == 2.5) {\n        fragColor.x += 1.0;\n        \n        // initial data\n        if (isPressed(KEY_W) + isPressed(KEY_A) + isPressed(KEY_S) + isPressed(KEY_D) + isPressed(KEY_UP) + isPressed(KEY_DOWN) + isPressed(KEY_LEFT) + isPressed(KEY_RIGHT) > 0 || iFrame == 0) fragColor = vec4(0);\n        \n        return;\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void intersect(HitInfo obj, inout HitInfo info, int ID) {\n    if (obj.hit && obj.dist > 0.0) {\n        info.hit = true;\n        if (obj.dist < info.dist) {\n            info.ID = ID;\n            info.dist = obj.dist;\n            info.normal = obj.normal;\n            info.backfacing = obj.backfacing;\n        }\n    }\n}\n\nHitInfo traceRay(Ray ray) {\n    HitInfo info;\n    info.ID = -1;\n    info.dist = 2e38;\n    info.hit = false;\n    \n    // world\n    intersect(sphere(ray, vec3(0,1,-2), 1.0), info, 0);\n    intersect(sphere(ray, vec3(2,1,-3), 1.0), info, 1);\n    intersect(sphere(ray, vec3(-2,1,-3), 1.0), info, 2);\n    intersect(sphere(ray, vec3(1000,500,1000), 400.0), info, 3);\n    intersect(box(ray, vec3(5,1,0), vec3(1,1,1)), info, 4);\n    intersect(plane(ray, vec3(0,1,0), 0.0), info, 5);\n    \n    \n    info.position = ray.origin + ray.direction * info.dist;\n    \n    return info;\n}\n\nvec3 render(vec2 fragCoord, int samples) {\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy ) / iResolution.y\n        #ifdef SUBPIXEL\n        + (hash21(iTime) - 0.5) / iResolution.y;\n        #endif\n        ;\n\n    Ray ray;\n    ray.origin = texelFetch(iChannel1, ivec2(0,0), 0).xyz;\n    //ray.origin = vec3(cos(iTime * PI * 0.125), 0.75, sin(iTime * PI * 0.125)) * 3.0;\n    \n    ray.direction = normalize(vec3(uv, 0) - vec3(0,0,1));\n    vec3 camRotation = texelFetch(iChannel1, ivec2(1,0), 0).xyz;\n    \n    //camRotation.x = 0.2;\n    //camRotation.z = -iTime * 0.125 +  0.5;\n    \n    rotate(ray.direction.yz, camRotation.x * PI);\n    rotate(ray.direction.xz, camRotation.z * PI);\n    \n    vec3 color = vec3(1);\n    vec3 light = vec3(0);\n    \n    HitInfo info;\n    int reflections = 0;\n    while (reflections < REFLECTIONS) {\n        info = traceRay(ray);\n        info.ray = ray;\n        Material material = getMaterial(info);\n        \n        ray.origin = info.position + info.normal * EPSILON;\n        \n        if (info.hit) {\n            light += material.emission * color;\n            color *= material.color;\n            \n            // random vector (cube)\n            #if NOISE_STYLE == 0\n            vec3 diffuse = hash33(vec3(samples, uv));\n            vec3 mystery = hash33(vec3(float(samples) * 528.7 - 438961.7, uv));\n            #else\n            vec3 diffuse = hash31(float(samples));\n            vec3 mystery = hash31(float(samples) * 528.7 - 438961.7);\n            #endif\n\n            // ???? wtf is this dark magic\n            vec3 theta = 2.0 * PI * diffuse;\n            vec3 rho = sqrt(-2.0 * log(mystery));\n            diffuse = rho * cos(theta);\n            \n            // cosine weighted rays (also evil magic)\n            diffuse = normalize(diffuse + info.normal);\n            \n            // reverse ray if towards surface (don't use with cosine rays)\n            //diffuse *= sign(dot(info.normal, diffuse));\n            \n            // mix between specular and diffuse directions\n            ray.direction = normalize(mix(diffuse, reflect(ray.direction, info.normal), 1.0 - material.roughness));\n        } else {\n            break;\n        }\n        reflections++;\n    }\n    light += color * 0.0;// * texture(iChannel3, ray.direction).rgb;\n    \n    return light;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor.rgba = vec4(0,0,0,1);\n    \n    for (int i = 0; i < SAMPLES; i++) {\n        fragColor.rgb += render(fragCoord, i + iFrame * SAMPLES);\n    }\n    fragColor.rgb /= float(SAMPLES);\n    \n    float renderFrame = texelFetch(iChannel1, ivec2(2,0), 0).x + 1.0;\n    fragColor.rgb = mix(texelFetch(iChannel0, ivec2(fragCoord), 0).rgb, fragColor.rgb, 1.0/renderFrame);\n}","name":"Buffer B","description":"","type":"buffer"}]}