{"ver":"0.1","info":{"id":"NlK3Wy","date":"1700999162","viewed":39,"name":"RAX-Text_SDF-1","username":"Raxmo","description":"Testing for text,\n\nAlso, not suuuuuper happy with the gradient magnetude of the SDF quite yet, but it works for now.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf","text","testbed"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float Pi = atan(0.0, -1.0);\nconst float Tau = Pi * 2.0;\n\nvec2 dline(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 d = vec2(0.0);\n\n    vec2 line = b - a;\n    vec2 delta = p - a;\n    vec2 perp = vec2(line.y, -line.x);\n    \n    \n    \n    return d;\n}\n\nvec2 dsegment(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 d = vec2(0.0);\n    \n    vec2 seg = b - a;\n    vec2 q = p - a;\n    vec2 perp = vec2(-seg.y, seg.x);\n    \n    float t = dot(seg, q) / dot(seg, seg);\n    t = clamp(t, 0.0, 1.0);\n    vec2 nearest = a + seg * t;\n    vec2 delta = p - nearest;\n    \n    d.y = length(delta);\n    \n    return d;\n}\n\nfloat distsegment(in vec2 p, in vec2 a, in vec2 b)\n{\n    return dsegment(p, a, b).y;\n}\n\n#define dseg(p, a, b) distsegment(p, a, b)\n\nfloat distCircSeg(in vec2 p, in vec2 center, in float radius, in float start, in float end)\n{\n    float d = 0.0;\n    //========================================//\n    \n    vec2 delta = p - center;\n    vec2 uv = delta;\n    uv.x = 1.0 - fract((1.0-(atan(delta.y, delta.x) / Tau + 0.5)) + start + (end - start) / 2.0);\n    uv.y = length(delta);\n    \n    uv.x = uv.x * 2.0 - 1.0;\n    uv.x = uv.x / (end - start);\n    uv.x = clamp(uv.x, -1.0, 1.0) * 0.5 + 0.5;\n    \n    float astart = start * Tau;\n    float aend = end * Tau;\n    \n    float adelta = aend - astart;\n    float theta = adelta * uv.x + astart;\n    \n    vec2 nearest = center + vec2(cos(theta) * radius, sin(theta) * radius);\n    \n    delta = p - nearest;\n    \n    d = length(delta);\n    \n    //========================================//\n    return d;\n}\n\n#define dcirc(p, center, radius, start, end) distCircSeg(p, center, radius, start, end)\n\nfloat distelipse(in vec2 p, in vec2 center, in float radius, in float start, in float end, in vec2 aspect)\n{\n    float d = 0.0;\n    //========================================//\n    \n    vec2 delta = p - center;\n    vec2 uv = delta;\n    uv.x = 1.0 - fract((1.0-(atan(delta.y, delta.x) / Tau + 0.5)) + start + (end - start) / 2.0);\n    uv.y = length(delta);\n    \n    uv.x = uv.x * 2.0 - 1.0;\n    uv.x = uv.x / (end - start);\n    uv.x = clamp(uv.x, -1.0, 1.0) * 0.5 + 0.5;\n    \n    float astart = start * Tau;\n    float aend = end * Tau;\n    \n    float adelta = aend - astart;\n    float theta = adelta * uv.x + astart;\n    \n    vec2 nearest = center + vec2(cos(theta) * radius, sin(theta) * radius) * aspect;\n    \n    delta = p - nearest;\n    \n    d = length(delta);\n    \n    //========================================//\n    return d;\n}\n\nfloat A_dist(in vec2 p, in vec2 o, in float size)\n{\n    float d = 1.0 / 0.0;\n    vec2 q = (p - o);\n    float r = 5.0;\n    //===========================================//\n    \n    vec2 p1 = size * vec2(0.0);\n    vec2 p2 = size * vec2(2.0, 5.0) / r;\n    vec2 p3 = size * vec2(4.0, 0.0) / r;\n    vec2 p4 = size * vec2(1.0, 2.5) / r;\n    vec2 p5 = size * vec2(3.0, 2.5) / r;\n    \n    //-------------------------------------------//\n    \n    d = min(d, distsegment(q, p1, p2));\n    d = min(d, distsegment(q, p2, p3));\n    d = min(d, distsegment(q, p4, p5));\n    \n    //===========================================//\n    return d;\n}\n\nfloat B_dist(in vec2 p, in vec2 o, in float size)\n{\n    float d = 1.0 / 0.0;\n    vec2 q = p - o;\n    float r = 5.0;\n    //============================================//\n    \n    vec2 p1 = size * vec2(0.0);\n    vec2 p2 = size * vec2(0.0, 5.0) / r;\n    vec2 p3 = size * vec2(2.0, 0.0) / r;\n    vec2 p4 = size * vec2(1.0, 3.0) / r;\n    vec2 p5 = size * vec2(2.0, 3.0) / r;\n    vec2 p6 = size * vec2(2.0, 5.0) / r;\n    vec2 p7 = size * vec2(0.0, 3.0) / r;\n    \n    vec2 c1 = size * vec2(2.0, 1.5) / r;\n    vec2 c2 = size * vec2(2.0, 4.0) / r;\n    \n    //--------------------------------------------//\n    \n    d = min(d, dseg(q, p1, p2));\n    d = min(d, dseg(q, p1, p3));\n    d = min(d, dseg(q, p7, p5));\n    d = min(d, dseg(q, p2, p6));\n    \n    d = min(d, dcirc(q, c1, 1.5 / r, -0.25, 0.25));\n    d = min(d, dcirc(q, c2, 1.0 / r, -0.25, 0.25));\n    \n    //============================================//\n    return d;\n}\n\nfloat C_dist(in vec2 p, in vec2 o, in float size)\n{\n    float d = 1.0 / 0.0;\n    vec2 q = p - o;\n    float r = 5.0;\n    //===============================================//\n    \n    vec2 c1 = size * vec2(2.0, 2.5) / r;\n    \n    //-----------------------------------------------//\n    \n    d = min(d, distelipse(q, c1, 0.5 * size, 0.125, 0.875, vec2(0.8, 1.0)));\n    \n    //===============================================//\n    return d;\n}\n\nfloat N_dist(in vec2 p, in vec2 o, in float size)\n{\n    float d = 1.0 / 0.0;\n    vec2 q = p - o;\n    float r = 5.0;\n    //================================================//\n    \n    vec2 p1 = size / r * vec2(0.0);\n    vec2 p2 = size / r * vec2(0.0, 5.0);\n    vec2 p3 = size / r * vec2(4.0, 0.0);\n    vec2 p4 = size / r * vec2(4.0, 5.0);\n    \n    //------------------------------------------------//\n    \n    d = min(d, dseg(q, p1, p2));\n    d = min(d, dseg(q, p2, p3));\n    d = min(d, dseg(q, p3, p4));\n    \n    //================================================//\n    return d;\n}\n\nfloat Q_dist(in vec2 p, in vec2 o, in float size)\n{\n    float d = 1.0 / 0.0;\n    vec2 q = p - o;\n    float r = 5.0;\n    //=============================================//\n    \n    vec2 c1 = size * vec2(2.0, 2.5) / r;\n    \n    vec2 p1 = size * vec2(3.0, 1.0) / r;\n    vec2 p2 = size * vec2(4.0, 0.0) / r;\n    \n    \n    //---------------------------------------------//\n    \n    d = min(d, distelipse(q, c1, 0.5 * size, 0.0, 1.0, vec2(0.8, 1.0)));\n    \n    d = min(d, dseg(q, p1, p2));\n    \n    //=============================================//\n    return d;\n}\n\nfloat R_dist(in vec2 p, in vec2 o, in float size)\n{\n    float d = 1.0 / 0.0;\n    vec2 q = p - o;\n    float r = 5.0;\n    //==============================================//\n    \n    vec2 p1 = size * vec2(0.0, 0.0) / r;\n    vec2 p2 = size * vec2(0.0, 5.0) / r;\n    vec2 p3 = size * vec2(0.0, 2.0) / r;\n    vec2 p4 = size * vec2(2.0, 2.0) / r;\n    vec2 p5 = size * vec2(3.5, 0.0) / r;\n    vec2 p6 = size * vec2(2.0, 5.0) / r;\n    \n    vec2 c1 = size * vec2(2.0, 3.5) / r;\n    \n    //----------------------------------------------//\n    \n    d = min(d, dseg(q, p1, p2));\n    d = min(d, dseg(q, p3, p4));\n    d = min(d, dseg(q, p4, p5));\n    d = min(d, dseg(q, p2, p6));\n    \n    d = min(d, dcirc(q, c1, 1.5 * size / r, -0.25, 0.25));\n    \n    //==============================================//\n    return d;\n}\n\n\n\nfloat Clip(in float v, in float t, in float w)\n{\n    float val = 0.0;\n    \n    val = (v - t) / w;\n    \n    return clamp(val, 0.0, 1.0);\n}\n\nconst float Phi = (1.0 + sqrt(5.0)) / 2.0;\n\nfloat noise(in vec2 xy)\n{\n\treturn fract(tan(distance(xy * Phi, xy) * float(iFrame / 3 + 3)) * xy.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1, 1)\n    vec2 uv = 2.0 * (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 col = vec3(0.0);\n    \n    float dist = distsegment(uv, vec2(-0.5, -0.5), vec2(0.5, 0.5));\n    float circ = distCircSeg(uv, vec2(0.0, 0.0), 0.5, 0.1250, 0.25);\n    \n    float val = 1.0 / 0.0;\n    \n    float Q = Q_dist(uv, vec2( -1.0, -0.25), 0.5);\n    float R = R_dist(uv, vec2(-0.25, -0.25), 0.5);\n    float N = N_dist(uv, vec2(  0.5, -0.25), 0.5);\n    \n    val = min(val, Q);\n    val = min(val, R);\n    val = min(val, N);\n    \n    val = Clip(val, 0.05, 0.5);\n    \n    val = pow(0.101, val);\n    \n    val = clamp(val, 0.01, 0.99);\n    \n    val = float(noise(ceil(fragCoord)) < val);\n    \n    col = vec3(val);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}