{"ver":"0.1","info":{"id":"lXXyzl","date":"1726612572","viewed":13,"name":"Torus Snake","username":"DarkReaper231","description":"Game of Snake on a torus\nIt barely works, please someone build upon this to make it better","likes":0,"published":3,"flags":48,"usePreview":0,"tags":["game","torus","snake"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const ivec2 ptrSnakeInfo   = ivec2(0,0); // xy:head pos, z:total length, w:current direction\nconst ivec2 ptrFruit       = ivec2(1,0);\nconst ivec2 ptrSnakeBuffer = ivec2(3,0); // xy:pos\n\nconst int gridSize = 24;\nconst vec3 backdropColor = vec3(0.1);\nconst vec3 gridBackColor = vec3(0.2, 0.2, 0.4);\nconst vec3 snakeColor = vec3(0.0, 0.8, 0.2);\nconst vec3 fruitColor = vec3(1.0, 0.2, 0.2);\n\nvec4 loadValue(in ivec2 ptr)\n{\n    return texelFetch(iChannel0, ptr, 0);\n}\n\nvec3 rotateY(vec3 v, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    mat3 m = mat3(c, 0, s, 0, 1, 0, -s, 0, c);\n    \n    return m * v;\n}\n\nvec3 rotateX(vec3 v, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    mat3 m = mat3(1, 0, 0, 0, c, -s, 0, s, c);\n    \n    return m * v;\n}\n\nvec2 mapToTorus(vec3 p, float R, float r) {\n    vec2 uv;\n    uv.x = atan(p.z, p.x) / (2.0 * 3.14159) + 0.5;\n    float d = length(p.xz) - R;\n    uv.y = atan(p.y, d) / (2.0 * 3.14159) + 0.5;\n    \n    return uv;\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    \n    return length(q) - t.y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float R = 0.7; // outer radius\n    float r = 0.3; // inner radius\n    \n    vec3 ro = vec3(0.0, 0.0, -2.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    float rotY = (mouseUV.x - 0.5) * 3.14159 * 2.0;\n    float rotX = (mouseUV.y - 0.5) * 3.14159 * 1.0;\n    \n    ro = rotateY(ro, rotY);\n    ro = rotateX(ro, rotX);\n    rd = rotateY(rd, rotY);\n    rd = rotateX(rd, rotX);\n    \n    float t = 0.0;\n    float d = 0.0;\n    vec3 p;\n    \n    for(int i = 0; i < 80; i++) {\n        p = ro + rd * t;\n        d = sdTorus(p, vec2(R, r));\n        if(abs(d) < 0.001) break;\n        t += d;\n        if(t > 10.0) break;\n    }\n    \n    vec3 col = backdropColor;\n    \n    if(d < 0.001) {\n        vec2 torusUV = mapToTorus(p, R, r);\n        col = gridBackColor;\n        \n        vec4 snakeInfo = loadValue(ptrSnakeInfo);\n        int snakeLength = int(snakeInfo.z);\n        vec2 snakeHead = snakeInfo.xy / float(gridSize);\n        \n        float snakeDist = length(torusUV - snakeHead);\n        for(int i = 0; i < snakeLength; i++) {\n            vec2 segment = loadValue(ptrSnakeBuffer + ivec2(i,0)).xy / float(gridSize);\n            snakeDist = min(snakeDist, length(torusUV - segment));\n        }\n        \n        if(snakeDist < 0.02) {\n            col = snakeColor;\n        }\n        \n        vec2 fruitPos = loadValue(ptrFruit).xy / float(gridSize);\n        if(length(torusUV - fruitPos) < 0.02) {\n            col = fruitColor;\n        }\n        \n        // lighting\n        vec3 normal = normalize(vec3(\n            sdTorus(p + vec3(0.001, 0.0, 0.0), vec2(R, r)) - d,\n            sdTorus(p + vec3(0.0, 0.001, 0.0), vec2(R, r)) - d,\n            sdTorus(p + vec3(0.0, 0.0, 0.001), vec2(R, r)) - d\n        ));\n        \n        float diff = max(dot(normal, normalize(vec3(1.0, 1.0, 1.0))), 0.0);\n        col *= 0.1 + 0.9 * diff;\n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Credits: https://www.shadertoy.com/view/wlSGWV\n\nconst ivec2 ptrSnakeInfo   = ivec2(0,0); // xy:head pos, z:total length, w:current direction\nconst ivec2 ptrFruit       = ivec2(1,0);\nconst ivec2 ptrTimer       = ivec2(2,0);\nconst ivec4 ptrSnakeBuffer = ivec4(3,0,600,0); // xy:pos\n\nconst int gridSize = 25;\n\nconst ivec2 ptrLast = ivec2(600,0);\n\nconst vec2 directions[5] = vec2[5]( vec2(1,0), vec2(0,1), vec2(-1,0), vec2(0,-1), vec2(0,0) );\n\nconst int DIR_RIGHT = 0;\nconst int DIR_UP    = 1;\nconst int DIR_LEFT  = 2;\nconst int DIR_DOWN  = 3;\nconst int DIR_NONE  = 4;\n\nconst int VK_SPACE = 32;\nconst int VK_LEFT  = 37;\nconst int VK_UP    = 38;\nconst int VK_RIGHT = 39;\nconst int VK_DOWN  = 40;\nconst int VK_G     = 71;\n\nvec4 loadValue(in ivec2 ptr)\n{\n    return texelFetch(iChannel0, ptr, 0);\n}\n\nvoid storeValue(in ivec2 ptr, in vec4 value, inout vec4 color, in ivec2 coord)\n{\n    color = (ptr==coord) ? value : color;\n}\n\nvoid storeValue(in ivec4 ptr, in vec4 value, inout vec4 color, in ivec2 coord)\n{\n    color = (coord.x>=ptr.x && coord.y>=ptr.y && coord.x<=ptr.z && coord.y<=ptr.w) ? value : color;\n}\n\nfloat hash1(in float n ) { return fract(sin(n)*138.5453123); }\n\nbool isKeyDown(in int key)\n{\n    return texelFetch( iChannel1, ivec2(key,1), 0 ).x > 0.5;\n}\n\nvec2 newFruit(in vec2 head, in int len)\n{\n    vec2 pos;\n    bool success = true;\n    int offset = 0;\n    do\n    {\n        pos =\n            vec2(\n                floor( float(gridSize) * hash1(\n                    iDate.w + 7.1*float(iFrame+offset)\n                )),\n                floor( float(gridSize) * hash1(\n                    iDate.w + 9.3*float(iFrame+3*offset)\n                ))\n            );\n        success = (pos!=head);\n        for(int i=0; (i<len) && success; ++i)\n        {\n            success = (pos!=loadValue( ptrSnakeBuffer.xy + ivec2(i,0)).xy);\n        }\n        offset++;\n    } while(!success);\n    \n    return pos;\n}\n\nvoid init(\n    out vec2 snakeHead,\n    out int  snakeLength,\n    out int  snakeDir, \n    out vec2 fruitPos, \n    out vec2 snakeBuffer,\n    out float currentTime)\n{\n    snakeHead = vec2(gridSize/2,gridSize/2);\n    snakeLength = 1;\n    snakeDir = DIR_RIGHT;\n    fruitPos = newFruit(snakeHead,snakeLength);\n    snakeBuffer = snakeHead;\n    currentTime = 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 pixel = ivec2( fragCoord - 0.5 );\n    \n    // don't compute gameplay outside of the data area\n    if (pixel.x>ptrLast.x || pixel.y>ptrLast.y)\n    {\n        discard;\n    }\n    \n    vec4 snakeInfo = loadValue( ptrSnakeInfo);\n    vec2 fruitPos = loadValue( ptrFruit ).xy;\n    vec2 timer = loadValue( ptrTimer ).xy;\n    vec2 snakeBuffer = loadValue( pixel ).xy;\n    \n    vec2 snakeHead = snakeInfo.xy;\n    int len = int(snakeInfo.z); \n    int dir = int(snakeInfo.w);    \n    float currentTime = timer.x;\n    \n    if (iFrame == 0)\n    {\n        init(snakeHead, len, dir, fruitPos, snakeBuffer, currentTime);\n    }\n    \n    if ( dir != DIR_NONE )\n    {\n        bool moveUp    = isKeyDown(VK_UP)    && dir!=DIR_DOWN;\n        bool moveDown  = isKeyDown(VK_DOWN)  && dir!=DIR_UP;\n        bool moveLeft  = isKeyDown(VK_LEFT)  && dir!=DIR_RIGHT;\n        bool moveRight = isKeyDown(VK_RIGHT) && dir!=DIR_LEFT;\n        \n        currentTime += iTimeDelta;\n        \n        if (currentTime > 0.1 || moveUp || moveDown || moveLeft || moveRight )\n        {\n            currentTime = 0.;\n            \n            if (moveUp)\n                dir = DIR_UP;\n            if (moveDown)\n                dir = DIR_DOWN;\n            if (moveLeft)\n                dir = DIR_LEFT;\n            if (moveRight)\n                dir = DIR_RIGHT;\n            \n            if (snakeHead != fruitPos)\n            {\n                // no food evolution\n                int offset = pixel.x - ptrSnakeBuffer.x;\n\n                if (offset>=0 && offset<len)\n                {\n                    if (offset == len-1)\n                        snakeBuffer.xy = snakeHead;\n                    else\n                        snakeBuffer = loadValue( pixel + ivec2(1,0) ).xy;\n                }\n            }\n            else\n            {\n                // food evolution\n                if (pixel.x - ptrSnakeBuffer.x == len)\n                    snakeBuffer.xy = snakeHead;\n                len++;\n                fruitPos = newFruit(snakeHead,len);\n            }\n            snakeHead += directions[ dir ];\n            snakeHead = mod(snakeHead, float(gridSize)); // wrap around torus\n\n            // check head against tail\n            for(int i=0; i<len; ++i)\n            {\n                if ( loadValue( ptrSnakeBuffer.xy + ivec2(i,0) ).xy == snakeHead )\n                {\n                    dir = DIR_NONE; // game over\n                }\n            }\n        }\n    }\n    else\n    {\n        if (isKeyDown(VK_SPACE)) \n        {\n            init(snakeHead, len, dir, fruitPos, snakeBuffer, currentTime);\n        }\n    }\n\n    fragColor = vec4(0);\n    \n    storeValue( ptrSnakeInfo,   vec4(snakeHead, float(len), float(dir)), fragColor, pixel );\n    storeValue( ptrFruit,       vec4(fruitPos, 0, 0),                    fragColor, pixel );\n    storeValue( ptrTimer,       vec4(currentTime, 0, 0, 0 ),             fragColor, pixel );\n    storeValue( ptrSnakeBuffer, vec4(snakeBuffer, 0, 0),                 fragColor, pixel ); \n}","name":"Buffer A","description":"","type":"buffer"}]}