{"ver":"0.1","info":{"id":"4t3cDn","date":"1532124000","viewed":115,"name":"Snowy Moutains","username":"CALI","description":"Work in progress","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["mountains","snowy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int NUM_STEPS = 300; //how many spheres are shown\nconst float EPSILON\t= 1e-4;\nconst float hesitate =.7;\nconst float pearl = 2.;\nconst float COMPACT =0.0; //change this for fun effect.\n\nfloat rand(float n){\n\treturn fract(sin(n)*43758.5453123);\n}\n\nfloat rand2(vec2 v){\n    return rand(v.x+rand(v.y));\n}\nfloat noise1(float p){\n\n    float f1 = floor(p/pearl)*pearl;\n    float fc = fract(p/pearl);\n    \n    return 5.5*mix(rand(f1),rand(f1+pearl),fc);\n\n}\n\n\nfloat cubeRoot(float x){\n\treturn pow(abs(x),1.0/1.5)*sign(x);\n}\n\nfloat smoothy(float x, float y, float f){\n\treturn mix(x,y,sin((f-.5)*3.14159)/2.0+.5);\n}\n\n\nfloat noise2(vec2 uv){\n\tfloat ix = floor(uv.x);\n    float iy = floor(uv.y);\n    float fx = fract(uv.x);\n    float fy = fract(uv.y);\n    return smoothy(smoothy(rand2(vec2(ix,iy)),rand2(vec2(ix+1.,iy)),fx),\n                      smoothy(rand2(vec2(ix,iy+1.)),rand2(vec2(ix+1.,iy+1.)),fx),fy);\n    return rand2(vec2(ix,iy))*(1.-fx)*(1.-fy)+rand2(vec2(ix+1.,iy))*(fx)*(1.-fy)\n        +rand2(vec2(ix,iy+1.))*(1.-fx)*(fy)+rand2(vec2(ix+1.,iy+1.))*(fx)*(fy);\n\t\n}\n\nfloat dist(vec3 p){ //distance funtion goes here - this generates the spheres\n   return (noise2(p.xz*.015)*11.+noise2(p.xz*.08)*1.8+noise2(p.xz*0.4)*.19+noise2(p.xz*1.0)*.11+noise2(p.xz*3.0)*.03)*5.+p.y;\n\n}\n\n\n\nvec3 getNormal(vec3 p, float eps) { //this function generates the normal vec for the object\n    vec3 n;\n   \n    n.x = dist(vec3(p.x+eps,p.y,p.z));\n\tn.y = dist(vec3(p.x,p.y+eps,p.z));\n    n.z = dist(vec3(p.x,p.y,p.z+eps));\n\n    return normalize(n-vec3(1,1,1)*dist(p));\n}\n\nvec3 march(vec3 ori, vec3 dir, out vec3 p) {  //this is the main raymarching function, give a ray to get a color\n    vec3 center = vec3(0,0,0);\n    vec3 light = 200.*normalize(vec3(cos(1.*iTime),1.1,sin(1.0*iTime)));\n\n    \n    for(int i = 0; i < NUM_STEPS; i++) {   \n        float tmid = dist(ori);\n        ori = ori + dir * tmid * hesitate;                   \n        \n\t\tif(abs(tmid)< EPSILON) {\n            p = getNormal(ori,1e-1);\n            vec3 pl = normalize(light-p);\n            vec3 gCol = mix(vec3(.39,.26,.13),vec3(1,1,1),smoothstep(-.0,1.0,normalize(p).y*3.-1.5-.3));\n            return gCol*.1+gCol*max(0.0,(dot(p,pl)*.7))+vec3(1,1,.3)*pow(max(0.,dot(p,pl)),30.)*.2;\n            \n            \n\t\t\tp.x = p.x/2.0 +.5;\n            p.y = p.y/2.0 +.5;\n            p.z = p.z/2.0 +.5;\n            //return 1.0;\n        }\n    }\n    return vec3(.6,.6,1)*.8;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy/iResolution.xy - vec2(0.5, 0.);\n    if(iMouse.xy == vec2(0.))mouse = vec2(0.5, 0.);\n    mouse.x*=5.;\n    mouse.x += iTime*0.051;\n    mouse.y*=2.;\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv-=0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    float groundHeight = 0.;\n    float angle = mouse.x;\n    float fov = 0.5;\n    float bigness = 2.;\n    float camDist = mouse.y+bigness*2.;\n    vec3 ori = vec3(cos(mouse.x)*camDist, 25.+sin(mouse.x/2.)*cos(mouse.x / 3.3)*3.4, sin(mouse.x)*camDist);\n    vec3 dir = vec3(-cos(mouse.x+uv.x*fov)*2., -0.4+sin(mouse.x)*cos(mouse.x)*.4+uv.y, -sin(mouse.x+uv.x*fov)*2.);\n    dir = normalize(dir);\n\t\n    vec3 p;\n\t//all above code is just to decide camera pos, then color is decided below\n    vec3 color = march(ori,dir,p);\n    \n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}