{"ver":"0.1","info":{"id":"wlyXWz","date":"1582521990","viewed":77,"name":"thebookofshaders-matrix","username":"enigmawxy","description":"matrix part for the book of shaders","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["color","shader","matrix"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 0\n#define PI 3.14159265359\n\n// YUV to RGB matrix\nmat3 yuv2rgb = mat3(1.0, 0.0, 1.13983,\n                    1.0, -0.39465, -0.58060,\n                    1.0, 2.03211, 0.0);\n\n// RGB to YUV matrix\nmat3 rgb2yuv = mat3(0.2126, 0.7152, 0.0722,\n                    -0.09991, -0.33609, 0.43600,\n                    0.615, -0.5586, -0.05639);\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat box(in vec2 _st, in vec2 _size){\n    _size = vec2(0.5) - _size*0.5;\n    vec2 uv = smoothstep(_size,\n                        _size+vec2(0.001),\n                        _st);\n    uv *= smoothstep(_size,\n                    _size+vec2(0.001),\n                    vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\nfloat mycross(in vec2 _st, float _size){\n    return  box(_st, vec2(_size,_size/4.)) +\n            box(_st, vec2(_size/4.,_size));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *=iResolution.x/iResolution.y;\n    vec3 color = vec3(0.0);\n\n    if(AA==0) {\n        // To move the cross we move the space\n    \tvec2 translate = vec2(cos(iTime),sin(iTime));\n    \tst += translate*0.25;\n\n    \t// Show the coordinates of the space on the background\n    \tcolor = vec3(st.x,st.y,.3);\n\n    \t// Add the shape on the foreground\n    \tcolor += vec3(mycross(st,0.3));\n    }\n    if(AA==1) {\n        // move space from the center to the vec2(0.0)\n    \tst -= vec2(0.5);\n    \t// rotate the space\n    \tst = rotate2d( sin(iTime)*PI ) * st;\n    \t// move it back to the original place\n    \tst += vec2(0.5);\n\n    \t// Show the coordinates of the space on the background\n    \t// color = vec3(st.x,st.y,0.0);\n\n    \t// Add the shape on the foreground\n    \tcolor += vec3(mycross(st,0.4));\n    }\n    if(AA==2) {\n        st -= vec2(0.5);\n        st = scale( vec2(sin(iTime)+1.0) ) * st;\n        st += vec2(0.5);\n\n        // Show the coordinates of the space on the background\n        color = vec3(st.x,st.y,0.0);\n\n        // Add the shape on the foreground\n        color += vec3(mycross(st,0.2));\n    }\n    \n    if(AA==3) {\n        // UV values goes from -1 to 1\n    \t// So we need to remap st (0.0 to 1.0)\n    \tst -= 0.5;  // becomes -0.5 to 0.5\n    \tst *= 2.0;  // becomes -1.0 to 1.0\n        \n    \t// we pass st as the y & z values of\n    \t// a three dimensional vector to be\n    \t// properly multiply by a 3x3 matrix\n    \tcolor = yuv2rgb * vec3(0.6, st.x, st.y);\n    }\n    \n    if(AA==4) {\n        // UV values goes from -1 to 1\n    \t// So we need to remap st (0.0 to 1.0)\n    \tst -= 0.5;  // becomes -0.5 to 0.5\n    \tst *= 2.0;  // becomes -1.0 to 1.0\n\n        st *= rotate2d(sin(iTime)*PI/3.);\n        \n    \t// we pass st as the y & z values of\n    \t// a three dimensional vector to be\n    \t// properly multiply by a 3x3 matrix\n    \tcolor = yuv2rgb * vec3(0.6, st.x, st.y);\n    }\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}