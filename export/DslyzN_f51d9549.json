{"ver":"0.1","info":{"id":"DslyzN","date":"1686629945","viewed":134,"name":"Mountain Flight","username":"sjz1","description":"my first realtime 3D shader","likes":7,"published":1,"flags":32,"usePreview":1,"tags":["4k","realtime","atmosphere","scatter","mountain","ggx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float gamma=2.2;\n\n\nvec3 ACESFilm( vec3 x )\n{\n    float tA = 2.51;\n    float tB = 0.03;\n    float tC = 2.43;\n    float tD = 0.59;\n    float tE = 0.14;\n    return clamp((x*(tA*x+tB))/(x*(tC*x+tD)+tE),0.0,1.0);\n}\n\nvec2 uv00;\nvec4 Load(){\n    return texture(iChannel0,uv00);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv00=uv;\n    vec4 tc0=Load();\n    tc0.xyz/=tc0.w;\n    vec3 tc=tc0.xyz;\n    tc=ACESFilm(tc);tc=pow(tc,vec3(1./gamma));\n    fragColor=vec4(tc,1);\n   \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"struct object{\n    float d;float d2;int id;int i_id;int s;\n};\nstruct material{\n    vec3 Cs;vec3 Cd;vec2 S;vec4 R;vec3 light;\n};\n\nfloat rand(vec2 pos){\n    return fract(sin(dot(pos.xy*0.123 ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 cMul(vec2 a, vec2 b) {\n\treturn vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);\n}\nvec2 cLog(vec2 a) {\n\tfloat b =  atan(a.y,a.x);\n\tif (b<0.0) b+=2.0*3.1415926535;\n\treturn vec2(log(length(a)),b);\n}\nvec2 cExp(vec2 z) {\n\treturn exp(z.x) * vec2(cos(z.y), sin(z.y));\n}\nvec2 cPow(vec2 z, vec2 a) {\n\treturn cExp(cMul(cLog(z), a));\n}\nvec2 cDiv(vec2 a, vec2 b){\n  float d = dot(b,b);\n  return vec2(dot(a,b),a.y*b.x-a.x*b.y)/d;\n}\n\nvec2 rot(vec2 a,float theata){\n    return a.xx*vec2(cos(theata),sin(theata))+a.yy*vec2(-sin(theata),cos(theata));\n}\nvec3 rot(vec3 a,vec3 range){\n    a.yz=rot(a.yz,range.x);\n    a.xz=rot(a.xz,range.y);\n    a.xy=rot(a.xy,range.z);\n    return a; \n}\nfloat mix2(float A,float B,float x){\n    return (B-A)*x+A;\n}\n\nfloat mix2(int A,float B,float x){\n    return (B-float(A))*x+float(A);\n}\n\nobject newObj(float d,float d2,int id,int i_id,int s){\n    object o;o.d=d;o.d2=d2;o.id=id;o.i_id=i_id;o.s=s;\n    return o;\n}\nobject near(object A,vec3 B){\n    object c;\n    c.d2=A.d>abs(B.y)?B.y:A.d2;\n    float tmp=mix2(A.i_id,B.z,float(B.y<0.));\n    c.s=A.s+int(B.y<0.);\n    B.y=abs(B.y);\n    c.id=int(mix2(A.id,B.x,float(A.d>B.y)));\n    c.d=min(A.d,B.y);\n    c.i_id=int(tmp);\n    return c;\n}\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdSphere(vec3 p,float r){\n    return length(p)-r;\n}\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n  p=abs(p)-b;\n  vec3 q=abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n\tvec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat dSphere(vec3 p,vec3 rd,float r){\n    float d0=sdSphere(p,r);\n    float b=dot(p,rd);\n    float c=dot(p,p)-r*r;\n    float h=b*b-c;\n    h = h>=0.?sqrt( h ):1e20;\n    float d1=abs(-b-sign(d0)*h);\n    d1-=1e-5;\n    d1=max(d1,0.);\n    d1*=sign(d0);\n    return rd==vec3(0)?d0:d1;\n}\nfloat dPlane(vec3 p,vec3 rd,vec4 n){\n    float d0=dot(n,vec4(p,1))/length(n.xyz);\n    float d1=-abs(d0)/dot(rd,normalize(n.xyz));\n    d1=d1>=0.?d1:1e20;\n    d1-=1e-5;\n    d1*=sign(d0);\n    return rd==vec3(0)?d0:d1;\n}\nfloat dBox(vec3 ro,vec3 rd,vec3 boxSize){\n    float d0=sdBox(ro,boxSize);    \n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    float d1=d0>=0.?tN:tF;//vec2( tN, tF );\n    d1=tN>tF || tF<0.0?1e20:d1;\n    d1-=1e-5;\n    d1*=sign(d0);\n    return rd==vec3(0)?d0:d1;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float EPSILONS = 0.002;\nconst float EPSILONS_MIN = 0.005;\nconst int MaxRayStep=256;\nconst float Far=8000.0;\nconst float gamma=2.2;\nconst float FogS=30.;\nconst float FOV=0.5;\nconst float Marching_S=1.;\nconst float omega_0=1.5;\nconst float PI=3.14159265358;\nvec3 lightDir=-normalize(vec3(0.5,-0.25,0.5));//Sun light direction\n\n\nmat2 m0=mat2(0.6,0.8,-0.8,0.6);\nfloat qCos(float x){\n    x=fract(x*0.25*0.636619772368)*4.;\n    x=abs(x-2.)-1.;\n    float x2=x*x;\n    return 1.57079632679*x*(1.+x2*(-0.408450569081+0.0450703414486*x2));\n\n}\n\nfloat qSin(float x){\n    return qCos(x-1.57079632679);\n\n}\n\n#define USE_SMOOTH_NOISE 0   // enable to prevent discontinuities\n\n\n// value noise, and its analytical derivatives\nvec3 noised( in vec2 x )\n{\n    vec2 f = fract(x);\n    #if USE_SMOOTH_NOISE==0\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n    #else\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n    #endif\n\n#if 0\n    // texel fetch version\n    ivec2 p = ivec2(floor(x));\n    float a = texelFetch( iChannel1, (p+ivec2(0,0))&255, 0 ).x;\n\tfloat b = texelFetch( iChannel1, (p+ivec2(1,0))&255, 0 ).x;\n\tfloat c = texelFetch( iChannel1, (p+ivec2(0,1))&255, 0 ).x;\n\tfloat d = texelFetch( iChannel1, (p+ivec2(1,1))&255, 0 ).x;\n#else    \n    // texture version    \n    vec2 p = floor(x);\n\tfloat a = textureLod( iChannel1, fract((p+vec2(0.5,0.5))/256.0), 0.0 ).x;\n\tfloat b = textureLod( iChannel1, fract((p+vec2(1.5,0.5))/256.0), 0.0 ).x;\n\tfloat c = textureLod( iChannel1, fract((p+vec2(0.5,1.5))/256.0), 0.0 ).x;\n\tfloat d = textureLod( iChannel1, fract((p+vec2(1.5,1.5))/256.0), 0.0 ).x;\n#endif\n    \n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\tdu*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nconst mat2 m3 = mat2(0.8,-0.6,0.6,0.8);\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*texture( iChannel1, fract(p/256.0 )).x; p = m3*p*2.02;\n    f += 0.2500*texture( iChannel1, fract(p/256.0 )).x; p = m3*p*2.03;\n    f += 0.1250*texture( iChannel1, fract(p/256.0 )).x; p = m3*p*2.01;\n    f += 0.0625*texture( iChannel1, fract(p/256.0 )).x; p = m3*p*2.01;\n    f += 0.03125*texture( iChannel1, fract(p/256.0 )).x; p = m3*p*3.07;\n    f += 0.03125*texture( iChannel1, fract(p/256.0 )).x;// p = m3*p*2.01;\n    return f/(0.9375+0.03125+0.03125);\n}\n\nfloat terrainM(vec2 p){\n    p*=0.3;\n    vec2 p0=p,p1=p;\n    const int S=14;\n    vec3 A0=noised(p*0.5)*vec3(1,0.5,0.5)*1.25;\n    float A=A0.x;float B=0.8;//float C=0.3;\n    vec2 p1x=vec2(1,0),p1y=vec2(0,1);\n    mat2 m_x=mat2(cos(0.3),sin(0.3),-sin(0.3),cos(0.3));\n    mat2 m_y=inverse(m_x);\n    mat2 m=mat2(1,0,0,1);\n    mat2 m1=mat2(0,0,0,0);\n    for(int i=0;i<S;i++){\n        vec2 k=vec2(qCos(float(i*10)),qSin(float(i*10)))*5.;\n        m1=m*B;\n        vec3 u=noised(m1*(p+m_x*k));\n        u.yz*=m1;\n        m1*=m0;\n        vec3 v=noised(m1*(p+m_y*k));\n        v.yz*=m1;\n        u*=PI;v*=PI; \n        p1x+=-A*u.yz*qSin(u.x)+A0.yz*qCos(u.x);\n        p1y+=-A*v.yz*qSin(v.x)+A0.yz*qCos(v.x);\n        A*=0.5;\n        A0*=0.5;\n        B*=1.47;\n        m*=m0;\n    }\n    float s=(p1x.x*p1y.y-p1x.y*p1y.x);\n    s=s/(1.+0.025*abs(s));\n    return s+20.;\n}\nfloat terrainH(vec2 p){\n    p*=0.3;\n    vec2 p0=p,p1=p;\n    const int S=24;\n    vec3 A0=noised(p*0.5)*vec3(1,0.5,0.5)*1.25;\n    float A=A0.x;float B=0.8;//float C=0.3;\n    vec2 p1x=vec2(1,0),p1y=vec2(0,1);\n    mat2 m_x=mat2(cos(0.3),sin(0.3),-sin(0.3),cos(0.3));\n    mat2 m_y=inverse(m_x);\n    mat2 m=mat2(1,0,0,1);\n    mat2 m1=mat2(0,0,0,0);\n    for(int i=0;i<S;i++){\n        //float time=0;\n        vec2 k=vec2(qCos(float(i*10)),qSin(float(i*10)))*5.;\n        m1=m*B;\n        vec3 u=noised(m1*(p+m_x*k));\n        u.yz*=m1;\n        m1*=m0;\n        vec3 v=noised(m1*(p+m_y*k));\n        v.yz*=m1;\n        u*=PI;v*=PI; \n        p1x+=-A*u.yz*qSin(u.x)+A0.yz*qCos(u.x);\n        p1y+=-A*v.yz*qSin(v.x)+A0.yz*qCos(v.x);\n        A*=0.5;\n        A0*=0.5;\n        B*=1.47;\n        m*=m0;\n    }\n    float s=(p1x.x*p1y.y-p1x.y*p1y.x);\n    s=s/(1.+0.025*abs(s));\n    return s+20.;\n}\nfloat terrainL(vec2 p){\n    p*=0.3;\n    vec2 p0=p,p1=p;\n    const int S=8;\n    vec3 A0=noised(p*0.5)*vec3(1,0.5,0.5)*1.25;\n    float A=A0.x;float B=0.8;//float C=0.3;\n    vec2 p1x=vec2(1,0),p1y=vec2(0,1);\n    mat2 m_x=mat2(cos(0.3),sin(0.3),-sin(0.3),cos(0.3));\n    mat2 m_y=inverse(m_x);\n    mat2 m=mat2(1,0,0,1);\n    mat2 m1=mat2(0,0,0,0);\n    for(int i=0;i<S;i++){\n        //float time=0;\n        vec2 k=vec2(qCos(float(i*10)),qSin(float(i*10)))*5.;\n        m1=m*B;\n        vec3 u=noised(m1*(p+m_x*k));\n        u.yz*=m1;\n        m1*=m0;\n        vec3 v=noised(m1*(p+m_y*k));\n        v.yz*=m1;\n        u*=PI;v*=PI; \n        p1x+=-A*u.yz*qSin(u.x)+A0.yz*qCos(u.x);\n        p1y+=-A*v.yz*qSin(v.x)+A0.yz*qCos(v.x);\n        A*=0.5;\n        A0*=0.5;\n        B*=1.47;\n        m*=m0;\n    }\n    float s=(p1x.x*p1y.y-p1x.y*p1y.x);\n    s=s/(1.+0.025*abs(s));\n    return s+20.;\n}\nfloat fbm2( vec2 p )\n{\n    return fbm(p)*0.75+fbm(p*5.)*0.25;\n}\nfloat snow_S(vec3 n,vec3 w,vec3 g,float a){\n    float tanA=sqrt(pow(dot(n,w),-2.)-1.);\n    float tanB=sqrt(pow(dot(n,g),-2.)-1.);\n    float a2=a*a;\n    float t=sqrt(tanB*tanB+a2);\n    return float(dot(n,g)<0.)*2.*a2/\n        ((1.+sqrt(1.+a2*tanA*tanA))*(tanB+t)*t);\n}\nvec3 mcolor(vec3 p,vec3 n,out vec4 s){\n    float t=p.y*2.5+80.;\n    vec3 c=vec3(0.3)*(fbm(p.xz*0.2)*0.3+1.);\n    vec3 dirt=mix(vec3(0.55,0.35,0.25),vec3(0.55,0.35,0.25)*1.5,fbm(p.xz*0.01)+fbm(p.xz*0.1)*0.4);\n    float snow_S=clamp(10.*snow_S(n,normalize(vec3(0,1,0)),vec3(0,-1,0),1.)+0.5*smoothstep(80.,140.,t),0.,1.);\n    float s_S=clamp(smoothstep(30.,100.+fbm(p.xz*0.1)*100.,t)*snow_S,0.,1.);\n    c=mix(c,vec3(1),s_S);\n    s=mix(vec4(c,0),vec4(0.9),s_S);\n    \n    c=mix(vec3(0.11,0.12,0.1),c,smoothstep(-20.,50.,t+fbm(p.xz*0.05)*50.));\n    vec3 grass=mix(dirt,vec3(0.1,0.2,0.12),clamp(smoothstep(-100.,-200.,t)*0.6+fbm(p.xz*0.5),0.,1.));\n    c=mix(grass,c,smoothstep(-50.-fbm(m3*p.xz*0.1)*50.,0.,t));  \n    \n    c=mix(vec3(0.35,0.4,0.3),c,smoothstep(-100.-fbm(m3*p.xz*0.15)*50.,-90.,t)) ; \n    return c;\n}\n\nfloat mapL(vec2 pos){\n    return terrainL(pos*0.00625*0.25)*40.;\n}\nfloat mapM(vec2 pos){\n    return terrainM(pos*0.00625*0.25)*40.;\n}\nfloat mapH(vec2 pos){\n    return terrainH(pos*0.00625*0.25)*40.;\n}\n\nobject DE(vec3 pos,vec3 rd) {\n    object hit0=newObj(Far,Far,-1,-1,0);\n    vec3 pos0=pos;\n    \n    float d=dPlane(pos,rd,vec4(0,1,0,30));\n    if(rd==vec3(0)||d<1.){\n        if(rd==vec3(0))\n            hit0=near(hit0,vec3(1,mapH(pos.xz)+pos.y,1));\n        else\n            hit0=near(hit0,vec3(1,(mapM(pos.xz)+pos.y)*0.75,1));\n    }else{\n        hit0=near(hit0,vec3(1,d,1));\n    }\n\n\n    return hit0;\n}\nmaterial newMaterial(vec3 Cs,vec3 Cd,vec2 S,vec4 R,vec3 light){\n    material a;a.Cs=Cs;a.Cd=Cd;a.S=S;a.R=R;a.light=light;return a;\n}\nmaterial Material(vec3 pos,vec3 nor,object o){\n    if(o.id==1){\n        pos*=0.1;\n        vec4 s=vec4(0);\n        vec3 c=mcolor(pos*4.+vec3(0,225.+fbm(pos.xz*0.1)*100.,0),nor,s);\n        return newMaterial(s.xyz,c,vec2(s.w,0),vec4(0.7,1,2,1.9),vec3(0));\n    }\n\n    return newMaterial(vec3(0.1),vec3(0.9,0.9,0.9),vec2(1,0),vec4(0,1,2,1),vec3(0));\n}\n\nvec3 pos_0;\nvec2 Projection(vec2 p,float S){\n    #ifdef SphereProjection\n        if(length(p)==0) return p;\n        return normalize(p)*tan(length(p)*S);\n    #else\n        return p*S;\n    #endif\n}\nvec3 ACESFilm( vec3 x )\n{\n    float tA = 2.51;\n    float tB = 0.03;\n    float tC = 2.43;\n    float tD = 0.59;\n    float tE = 0.14;\n    return clamp((x*(tA*x+tB))/(x*(tC*x+tD)+tE),0.0,1.0);\n}\n\n\nconst vec3 b_P=vec3(30000);//atmosphere thickness\nconst float b_k=0.25;//mix\n\n \nconst vec3 Mie=vec3(0.2);\n\nconst vec3 Rayleigh=2e10*pow(vec3(1./700.,1./520.,1./450.),vec3(4));\n  \nconst vec3 b_k0=mix(Rayleigh,Mie,b_k);\n\nconst vec3 b_Q=b_k0/(b_P*b_P);//absorption\nconst vec3 b_Sun=2.*vec3(10,10,10);//sun color\nconst vec3 b_g0=mix(Rayleigh*0.01,vec3(0.9),b_k);//single scatter\nvec4 background(in vec3 pos, in vec3 n,in vec3 lightDir ) {\n    vec3 n0=n;\n\n    n.y=max(n.y,1e-5);\n    vec3 g=3./(8.*PI)*(1.+pow(dot(n,lightDir),2.))*(1.-b_g0*b_g0)/(2.+b_g0*b_g0)/pow(1.+b_g0*b_g0-2.*b_g0*dot(lightDir,n),vec3(1.5));\n    vec3 t=b_Q*0.5*(b_P-pos.y)*(b_P-pos.y);\n    vec3 c=b_Sun*g*(exp(-t/n.y)-exp(-t/lightDir.y))/(n.y-lightDir.y)*max(lightDir.y,0.);\n\n    c+=exp(-t/n.y)*b_Sun*smoothstep(0.997,0.9975,dot(n0,lightDir));\n\t return vec4(clamp(c,0.,50.),1);\n}\nvec4 background(in vec3 pos, in vec3 n,in vec3 lightDir,float s,vec3 col ) {\n    vec3 n0=n;\n    if(n.y>0.) s=min((b_P.x-pos.y)/n.y,s);\n    vec3 g=3./(8.*PI)*(1.+pow(dot(n,lightDir),2.))*(1.-b_g0*b_g0)/(2.+b_g0*b_g0)/pow(1.+b_g0*b_g0-2.*b_g0*dot(lightDir,n),vec3(1.5));\n    vec3 t=b_Q*0.5*(b_P-pos.y)*(b_P-pos.y);\n    vec3 s1=exp(b_Q*s*(0.5*s*n.y-(b_P-pos.y))*(1.-n.y/lightDir.y));\n    vec3 c=b_Sun*g*exp(-t/lightDir.y)*(1.-s1)/(-n.y+lightDir.y)*max(lightDir.y,0.);\n    c=abs(c);\n    c=clamp(c,0.,50.);\n    c+=exp(b_Q*0.5*n.y*s*s-b_Q*(b_P-pos.y)*s)*col;\n\t return vec4(c,1);\n}\n\nvec3 estimateNormal(vec3 pos) {\n    float EPSILON=EPSILONS*distance(pos,pos_0);\n    vec2 e = vec2(1.0,-1.0)*0.5773*EPSILON;\n    vec3 rd=vec3(0,0,0);\n    return normalize( e.xyy*DE( pos + e.xyy ,rd).d2 + \n\t\t\t\t\t  e.yyx*DE( pos + e.yyx ,rd).d2 + \n\t\t\t\t\t  e.yxy*DE( pos + e.yxy ,rd).d2 + \n\t\t\t\t\t  e.xxx*DE( pos + e.xxx ,rd).d2 );\n}\n\nvec3 raycast(vec3 ro,vec3 rd,out float distance_){\n    float lastd0=0.;\n    bool hit00=false;\n    vec3 ro0=ro,ro1=ro;\n    vec3 rd0=rd;\n    float t=0.;\n    float Marching_S_2=1.;\n    int sgn =DE(ro,rd).s;\n    float lastR=0.;\n    float lastR0=0.;\n    float omega=omega_0;\n    for(int i=0;i<MaxRayStep;i++){\n//        iteration+=1;\n        object o=DE(ro,rd);\n        if(o.s!=sgn){\n            ro=ro0;rd=rd0;\n            Marching_S_2*=0.75;\n            continue;\n        }\n\n        float d0=o.d;\n        \n        float EPSILON=max(EPSILONS*distance(ro,pos_0),EPSILONS_MIN);\n        bool c=d0<=EPSILON&&d0<lastd0||Marching_S_2<=EPSILONS_MIN;\n        if(c||distance(ro,pos_0)>Far){\n            hit00=c; break;\n        }\n        float d_d0=d0*Marching_S*Marching_S_2;\n        float d_d=d_d0*omega;\n\n        if(omega>1.&&d_d0+lastR0<lastR){\n            ro=ro0;rd=rd0;omega=max(omega*0.85,1.);continue;\n        }\n        ro0=ro;rd0=rd;\n        lastd0=d0;ro+=d_d*rd;t+=d_d;\n        lastR=d_d;\n        lastR0=d_d0;\n    }\n    distance_=mix2(-1,distance(ro,ro1),float(hit00));\n    return ro;\n}\nvec3 CameraPath(float time){\n    time+=295.;\n    const float a=-0.025;\n    vec2 p=vec2(cos(time*a),sin(time*a)+2.*sin(time*a*0.48))*1000.;\n    float h=mapL(p);\n    return vec3(p.x,-h+40.,p.y);\n}\nvoid XYZ(vec3 dir,out vec3 X,out vec3 Y){\n    Y.y=-length(dir.xz);\n    Y.x=0.;\n    if(length(dir.xz)<=0.)\n        Y.xz=vec2(1,0);\n    else\n        Y.xz=normalize(dir.xz)*dir.y;\n    X=cross(dir,Y);\n}\nvoid SetCamera(float time,vec2 uv0,out vec3 ro,out vec3 rd){\n    ro=CameraPath(time);\n    vec3 lD=normalize(CameraPath(time+5.)-ro);\n    vec3 X;vec3 Y;\n    XYZ(lD,X,Y);\n\n    vec2 uv=Projection(uv0,FOV);\n    rd=lD+uv.x*X-uv.y*Y;\n    rd=normalize(rd);\n}\n\nfloat hash( vec2 p )\n{   p+=vec2(4215);\n    p=50.0*fract(p*0.3183099);\n    return fract(p.x*p.y*(p.x+p.y));\n}\nfloat hash(float n){return fract(sin(n)*753.5453123);}\nvec3 forwardSF(float i,float n){\n    const float PI=3.1415926535897;\n    const float PHI=1.618033988749;\n    float phi=2.*PI*fract(i/PHI);\n    float zi=1.0-(2.0*i+1.0)/n;\n    float sinTheta=sqrt(1.0-zi*zi);\n    return vec3(cos(phi)*sinTheta,sin(phi)*sinTheta,zi);\n}\nfloat calcAO(vec3 pos,vec3 nor){\n    float ao=0.0;\n    for(int i=0;i<32;i++){\n        vec3 ap=forwardSF(float(i),32.);\n        float h=hash(float(i));\n        ap*=sign(dot(ap,nor))*h*25.;\n        ao+=clamp(DE(pos+nor*0.001+ap,vec3(0)).d*0.1,0.,1.);\n    }\n    ao/=32.0;\n    return clamp(ao*2.0,0.,1.);\n}\n\nfloat shadow(vec3 pos0,int MaxStep,vec3 lightDir){\n    vec3 pos=pos0;\n    float s00=1.0;float lo=DE(pos,vec3(0)).d;\n    pos+=lo*lightDir;int j=0;\n    float ph=1e20;\n    for(float i=0.01;i<=Far&&j<MaxStep;j++){\n        object o=DE(pos,lightDir);\n        float EPSILON=max(EPSILONS*distance(pos,pos_0),EPSILONS_MIN);\n        if(o.d<=EPSILON&&lo>=o.d) return 0.;\n        o.d*=0.5;\n        float y=o.d*o.d/(2.0*ph);\n        float d0=sqrt(max(o.d*o.d-y*y,0.));\n        s00=mix(min(s00,16.0*d0/max(1e-5,i-y)),s00,float(lo<o.d));\n        pos+=o.d*lightDir;\n        ph=o.d;\n        lo=o.d;i+=o.d;\n    }\n    return clamp(s00,0.,1.);\n}\nfloat luma(vec3 c){\n    return dot(c,vec3(0.299,0.587,0.114));\n}\nvec4 rColor(vec3 c,float cosA){\n    cosA=abs(cosA);\n    vec3 A0=1.-sqrt(c);vec3 A1=1.+sqrt(c);\n    vec3 B=sqrt(4.*sqrt(c)+cosA*cosA*pow(A0,vec3(2)));\n    vec3 s0=(cosA*A0-B)/max(cosA*A0+B,1e-5);\n    vec3 s1=(B*A0-cosA*A1*A1)/max(B*A0+cosA*A1*A1,1e-5);\n    vec3 R=0.5*(s0*s0+s1*s1);\n    return vec4(R,luma(R));\n}\n\nfloat HGGX_Lamda(float VoN,float a,vec2 g){\n    float tan2=1./(VoN*VoN)-1.;\n    vec2 A=sqrt(1.+g*a*a*tan2);\n    return (log((1.+A.y)/(1.+A.x))-A.y+A.x)/log(g.x/g.y);\n}\n\nfloat HGGX_G2(float VoN,float LoN,float a,vec2 g){\n    float L1=HGGX_Lamda(VoN,a,g);float L2=HGGX_Lamda(LoN,a,g);\n    return clamp((1.+L1)/(1.+L2+L1),0.,1.);\n}\n\nfloat HGGXdf(float theta,float fai,float a,vec2 g){\n    float a2=a*a;\n    float cos2=cos(theta);\n    vec2 A=1.+(g*a2-1.)*cos2;\n    return 1.-log(A.x/A.y)/log(g.x/g.y);\n}\nfloat HGGXpdf(float theta,float fai,float a,vec2 g){\n    float a2=a*a;\n    float cos2=cos(theta);\n    vec2 A=1.+(g*a2-1.)*cos2;\n    return a2*(g.x-g.y)*cos(theta)/(log(g.x/g.y)*PI*A.x*A.y);\n}\nvec4 frag_0;\nvoid Store(vec4 c){\n    frag_0=c;\n}\nvec2 uv00;\nvec4 Load(){\n    return texture(iChannel0,uv00);\n}\nvoid Entry(float x,float y){\n    if(abs(y)>1./2.31) {Store(vec4(0,0,0,1));return;}\n    vec3 ro,rd;\n    SetCamera(iTime,vec2(x,y),ro,rd);\n    vec3 atmosphere=background(ro,rd,lightDir).xyz;\n    float depth;\n    pos_0=ro;\n    vec3 color=atmosphere;\n    vec3 hitP=raycast(ro,rd,depth);\n    if(depth>-0.5){\n        object A=DE(hitP,vec3(0));\n        float EPSILON=max(EPSILONS*distance(hitP,pos_0),EPSILONS_MIN);\n        vec3 normal=estimateNormal(hitP);\n        //normal=faceforward(normal,normal,rd);\n        float AO=1.;//calcAO(hitP,normal);\n        material mat=Material(hitP,normal,A);\n        vec3 diffuse;\n        float Shadow=shadow(hitP,MaxRayStep/2,lightDir);\n        diffuse=background(ro,-lightDir,lightDir).xyz;\n        diffuse*=mat.Cd*max(dot(normal,lightDir),0.)*Shadow;\n        diffuse+=mat.Cd*vec3(0.1,0.15,0.2)*2.;\n        diffuse*=AO;\n        vec4 spec=mix(vec4(0),rColor(mat.Cs,dot(rd,normal)),mat.S.x);\n        vec3 X,Y;\n        XYZ(normal,X,Y);\n        float beta=acos(clamp(dot(lightDir,normal),0.,1.));\n        float alpha=0.;\n        vec3 spec0=1.-spec.xyz;\n        spec.xyz*=10.*background(ro,-lightDir,lightDir).xyz\n            *HGGXpdf(beta,alpha,mat.R.x,mat.R.zw)\n            *HGGX_G2(abs(dot(normal,rd)),abs(dot(normal,lightDir)),mat.R.x,mat.R.zw)\n            *float(dot(normal,lightDir)>0.);\n        spec*=Shadow;\n        color=spec.xyz+spec0*diffuse;\n        \n        color=background(ro,rd,lightDir,FogS*depth,color).xyz;\n    }\n    if(iFrame<=1){\n        Store(vec4(color,1));\n    }else{\n        const int blur=3;\n        vec4 temp0=Load();\n        temp0*=min(temp0.w,float(blur-1))/(temp0.w+1.);\n        vec4 a=temp0+vec4(color,1);\n        a.w=min(a.w,float(blur));\n        Store(a);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv00=uv;\n    Entry(2.*uv.x-1.,(2.*uv.y-1.)/iResolution.x*iResolution.y);\n\n    fragColor = frag_0;\n}","name":"Buffer A","description":"","type":"buffer"}]}