{"ver":"0.1","info":{"id":"csV3zR","date":"1732801849","viewed":22,"name":"Sphere effect","username":"Anoukh","description":"RayMarcher","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarcher"],"hasliked":0,"parentid":"DtSXzw","parentname":"Fork Cube and s Anoukh 525"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 1000;\nconst float PRECISION = 0.001;\nconst float MIN_ILLUMINATION = 0.0;\nconst vec3 BG_COLOR = vec3(5., 20., 50.)/255.;\nconst vec3 GREEN = vec3(85, 170, 85)/255.;\nconst vec3 BLUE = vec3(34, 102, 102)/255.;\nconst vec3 BALL_COLOR = GREEN;\nconst vec3 PLANE_COLOR = vec3(0.1,0.1,0.1);\n\nconst vec3 BALLPOS = vec3(0.,0.,-1.);\nconst float R = 0.2;\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat max3(vec3 p){\n    return (max(max(p.x,p.y),p.z));\n}\n\nvec4 DFball(vec3 p, vec3 bp, float r, vec3 col){\n    //float dist = 3.;\n    //vec3 offset = vec3(dist/2.);\n    //p = mod(p+offset,dist)-offset;\n    return vec4(length(p-bp) - r,col);  \n}\n\nvec4 DFcube(vec3 p, vec3 bp, float s, vec3 col){\n    return vec4(max3(abs(p-bp)) - s,col);\n}\n\nvec4 DFplane(vec3 p, float h){\n    const vec3 c1 = vec3(170., 57., 57.)/255.;\n    const vec3 c2 = vec3(170., 108., 57.)/255.;\n    vec3 floorColor = mix(c1,c2,vec3(mod(floor(p.x) + floor(p.z), 2.0)*2.));\n    return vec4(p.y - h,floorColor);  \n}\n\nvec4 minDF(vec4 a, vec4 b){\n    if (a.x < b.x){\n        return a;\n    }\n    return b;\n}\n\nvec4 DFscene(vec3 p){\n    return minDF(minDF(minDF(\n                DFball(p,BALLPOS,R,BALL_COLOR), \n                DFplane(p,-0.3)),\n                DFball(p,BALLPOS+vec3(0.4,0.5,0.4),R,BLUE)),\n                DFcube(p,vec3(-0.2,0.,0.),R,BLUE)\n           );\n}\n\nvec3 Normal(vec3 p) {\n  vec2 e = vec2(1.0, -1.0) * 0.00005; // epsilon\n  return normalize(\n    e.xyy * DFscene(p + e.xyy).x +\n    e.yyx * DFscene(p + e.yyx).x +\n    e.yxy * DFscene(p + e.yxy).x +\n    e.xxx * DFscene(p + e.xxx).x);\n}\n\nvec4 RayTrace(vec3 ro, vec3 rd, float mint, float maxt, inout float closest){\n    closest = maxt;\n    float depth = mint;\n    vec4 Ray = vec4(depth,0,0,0);\n    int i;\n    for( i= 0; i<MAX_MARCHING_STEPS;i++){\n        vec3 p = ro + rd*depth;\n        vec4 distF = DFscene(p);\n        if(closest <distF.x){\n            closest= distF.x;\n        }\n        depth += distF.x;\n        if (distF.x <= PRECISION || depth >maxt){\n            Ray = vec4(depth,distF.yzw);\n            break;\n        }\n    }\n    if (i>=MAX_MARCHING_STEPS){\n        return vec4(maxt+1.,0.,0.,0.);\n    }\n    return Ray;\n}\n\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr)); // camera up\n\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    float closest = 0.;\n    vec3 lightPosition = vec3(2.+sin(iTime)*5., 8., 3.);\n    const float camR = 2.;\n    const float camSp = 0.1;\n    vec3 lp = vec3(0.,0.,0.);\n    vec3 ro = vec3(cos(iTime*camSp),0.,sin(iTime*camSp))*camR;\n    ro.y = 0.7;\n    vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1));\n    //rd *= rotateX(iTime);\n    vec3 col = BG_COLOR;\n    const float MAX_DIST = 500.;\n    vec4 Ray = RayTrace(ro,rd,0.01,MAX_DIST,closest);\n    \n    if (Ray.x <= MAX_DIST){\n        col = Ray.yzw;\n        vec3 p = ro + rd * Ray.x;\n        vec3 bn = Normal(p);\n        vec3 lr = normalize(lightPosition-p);\n        float dif = clamp(dot(bn, lr), MIN_ILLUMINATION, 1.);\n        col *= dif;\n        \n        //Ombre\n        vec3 ro2 = p + bn*PRECISION*2.;\n        vec3 rdn2=lightPosition-ro2;\n        float lightdist = length(rdn2);\n        vec3 rd2 = normalize(rdn2);\n        vec4 Ray2 = RayTrace(ro2,rd2,0.01,lightdist,closest);\n        if (Ray2.x < lightdist && Ray2.x>0.05) col*=0.1;\n        \n        //col = mix(col,BG_COLOR,pow(Ray.x/MAX_DIST,0.5));\n        col = mix(col, BG_COLOR, 1.0 - exp(-0.0002 * Ray.x * Ray.x * Ray.x));\n        \n    }\n    col = pow(col, vec3(1.9/2.2));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}