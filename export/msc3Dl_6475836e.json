{"ver":"0.1","info":{"id":"msc3Dl","date":"1689192290","viewed":80,"name":"volumetric clouds test procedura","username":"lukasino1214","description":"volumetric","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ABSORPTION 2.5\n#define MIN_MARCH_DIST 0.001\n#define MAX_MARCH_DIST 20.\n#define MAX_MARCH_STEPS 200\n#define MAX_VOLUMETRIC_STEPS 64.\n\n#define M_PI 3.14159265359\n\n/*float HenyeyGreenstein(float g, float costh) {\n    return (1.0 - g * g) / (4.0 * M_PI * pow(1.0 + g * g - 2.0 * g * costh, 3.0/2.0));\n}*/\n\n/*float HenyeyGreenstein(float g, float costh) {\n    return (1.0 / (4.0 * M_PI)) * ((1.0 - g * g) / pow(1.0 + g * g - 2.0 * g * costh, 1.5));\n}*/\n\nfloat beers_law(float dis) { return exp(-dis * ABSORPTION); }\nfloat powders_law(float dis) { return 1.0 - exp(-2.0 * dis * ABSORPTION); }\nfloat beers_powders_law(float dis) { return beers_law(dis) * powders_law(dis); }\n\nconst vec3 LIGHT_DIR = -normalize(vec3(0.0, 1.0, 0.0));\nconst vec3 LIGHT_POS = vec3(1.25, -1.25, -1.25);\n\nfloat light(vec3 ray_dir, vec3 ray_pos) {\n    /*vec3 ldir = normalize(LIGHT_POS - ray_pos);\n    float dis = length(LIGHT_POS - ray_pos);\n    return dot(ldir, normalize(ray_dir)) * (1.0 / (dis*dis));*/\n    //return dot(LIGHT_DIR, normalize(ray_dir));\n    return 1.0;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nvec3 get_sky_color(vec3 ray_dir) {\n    return mix(vec3(1), vec3(.3, .4, 1), (normalize(ray_dir).y + 1.0));\n}\n\nfloat get_noise(vec3 p) {\n    return texture(iChannel0, p * 0.2 + vec3(0.15, 0.0, 0.0) * iTime * 0.5).r * 0.1;\n}\n\nvec3 ACESFilm(vec3 x){\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\nvec3 ray_march(vec3 camera_pos, vec3 ray_dir) {\n    float ss = length(ray_dir);\n    const float ldt = 0.5;\n    float t = 0.0;\n    for(int i = 0; i < MAX_MARCH_STEPS; i++) {\n        vec3 ray = camera_pos + ray_dir * t;\n        float d = sdBox(ray, vec3(1.0));\n        \n        if(d < 0.0) {\n            float v = t;\n            for(int j = 0; j < MAX_MARCH_STEPS; j++) {\n                ray = camera_pos + ray_dir * v;\n                if(sdBox(ray, vec3(1.0)) < 0.0) { v += 0.05 * get_noise(ray) * ss * ldt; } else { break; }\n            }\n \n            return mix(vec3(1.0) * light(ray_dir, ray), get_sky_color(ray_dir), beers_law(v - t));\n        }\n        \n        t += 0.025;\n    }\n    return get_sky_color(ray_dir);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 cameraPos=vec3(3.0,1.5,2.0);\n\n    //let's normalize the point on the view plane to -1-1 coordinates, center is 0,0\n    vec2 planeCoord = (fragCoord.xy/iResolution.xy)*2.0-1.0;\n    //we need to fix one dimension\n    planeCoord.x *= iResolution.x/iResolution.y;\n    vec3 rayDirection = vec3(planeCoord.xy, - (1.0 / tan(radians(30.0))));\n    rayDirection = normalize(rayDirection);\n    mat4 rrr = lookAt(cameraPos,vec3(0.0,0.0,0.0), vec3(0.0,-1.0,0.0));\n    //apply it to the rays that are coming out of it, result in world space\n    rayDirection = (rrr*vec4(rayDirection,0.0)).xyz;\n    \n    vec3 color = ray_march(cameraPos, rayDirection);\n    //color = ACESFilm(color);\n    //color = pow(color, vec3(0.4545));\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n\nfloat GetIntegerNoise(vec2 p)  // replace this by something better, p is essentially ivec2\n{\n    p  = 53.7 * fract( (p*0.3183099) + vec2(0.71,0.113));\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat Hash(float f)\n{\n    return fract(sin(f)*43758.5453);\n}\n\nfloat Hash21(vec2 v)\n{\n    return Hash(dot(v, vec2(253.14, 453.74)));\n}\n\nfloat Hash31(vec3 v)\n{\n    return Hash(dot(v, vec3(253.14, 453.74, 183.3)));\n}\n\nvec3 Random3D( vec3 p ) {\n    return fract(sin(vec3(dot(p,vec3(127.1,311.7,217.3)),dot(p,vec3(269.5,183.3,431.1)), dot(p,vec3(365.6,749.9,323.7))))*437158.5453);\n}\n\nvec2 Rotate2D(vec2 v, float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    \n    mat2 rotMat = mat2(c,s,-s,c);\n    return rotMat * v;\n}\n\nvec4 GetWorleyNoise3D(vec3 uvw)\n{\n    float noise = 0.0;\n    \n    vec3 p = floor(uvw);\n    vec3 f = fract(uvw);\n    \n    vec4 res = vec4(1.0);\n    for(int x = -1; x <=1; ++x)\n    {\n        for(int y = -1; y <=1; ++y)\n        {\n            for(int z = -1; z <=1; ++z)\n            {\n                vec3 gp = p + vec3(x, y, z);\t//grid point\n\n                vec3 v = Random3D(gp);\n\n\t\t\t\tvec3 diff = gp + v - uvw;\n                \n                float d = length(diff);\n                \n                if(d < res.x)\n                {\n                    res.xyz = vec3(d, res.x, res.y);\n                }\n                else if(d < res.y)\n                {\n                    res.xyz = vec3(res.x, d, res.y);\n                }\n                else if(d < res.z)\n                {\n                    res.z = d;\n                }\n                \n                res.w = Hash31(gp);\n            }\n        }\n    }\n\n    return res;\n}\n\nfloat fBMWorley(vec3 x, float lacunarity, float gain, int numOctaves)\n{\n    float total = 0.0;\n    float frequency = 1.0;\n    float amplitude = 1.0;\n\tfloat totalAmplitude = 0.0;\n    for(int i = 0; i < numOctaves; ++i)\n    {\n        totalAmplitude += amplitude;\n        \n        vec4 n = GetWorleyNoise3D(x * frequency);\n        total += amplitude * n.x;\n        \n        frequency *= lacunarity;\n        amplitude *= gain;\n    }\n    \n    return total/totalAmplitude;\n}\n\nmat4 lookAt(vec3 cam, vec3 focusPoint, vec3 up) {\n    vec3 z = normalize(focusPoint-cam);\n    vec3 x = cross(z, up);\n    vec3 y = cross(z,x);\n    return mat4(vec4(x, 0.0),vec4(y, 0.0),vec4(-z, 0.0),vec4(0.0, 0.0, 0.0, 1));\n}","name":"Common","description":"","type":"common"}]}