{"ver":"0.1","info":{"id":"ssdGRM","date":"1638342368","viewed":84,"name":"Test 314","username":"SpencerKuan","description":"Simple ray-marching scene with (bad) reflections and shadows. ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nMy first shadertoy program :)\n\nThe code is not new, but from a project\nI wrote on Khan Academy.\n\n*/\n\n#define eps 0.01\n#define pi 3.1415926\n        \nprecision lowp float;\nuniform float u_time;\n\nvec3 cam = vec3(0, 100, -700);\nvec3 lightPos = vec3(500, 1000, 300);\n\n//sdBox from Inigo Quilez's article on distance functions\nfloat box(vec3 p, vec3 b){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat sdf( vec3 p )\n{\n    p = vec3(mod(p.x, 400.) - 200., p.y, mod(p.z, 400.) - 200.);\n\n    float bottom = p.y;\n    float sphere = length(p + vec3(0, -120, 0)) - 150.;\n    float box = box(p + vec3(0, -120, 0), vec3(120, 120, 120)) - 1.0;\n\n    return min(max(-sphere, box), bottom);\n}\n\nvec3 getNormal(vec3 ray)\n{\n    float sdfr1 = sdf(ray);\n    \n    float xn = sdf(vec3(ray.x + eps, ray.y, ray.z)) - sdfr1;\n    float yn = sdf(vec3(ray.x, ray.y + eps, ray.z)) - sdfr1;\n    float zn = sdf(vec3(ray.x, ray.y, ray.z + eps)) - sdfr1;\n\n    return normalize(vec3(xn, yn, zn));\n}\n\nvec3 getColor(vec3 ray)\n{\n    bool checkerX = floor(mod(ray.x, 800.) / 400.) == 1.0;\n    bool checkerY = floor(mod(ray.z, 800.) / 400.) == 1.0;\n    bool checker = checkerX ^^ checkerY;\n\n    if(checker ^^ (ray.y < 1.0)){\n        return vec3(0.6, 0.5, 0.9);\n    }\n    return vec3(0, 1, 1);\n}\n\nvec3 raymarch(inout vec3 ray, vec3 dir)\n{\n    for(int i = 0; i < 100; i++) { \n        float dist = sdf(ray + dir);\n\n        if(dist < eps){\n            return getColor(ray);\n        }\n\n        ray += dir * dist;\n    }\n\n    return vec3(0, 0, 0);\n}\n\nfloat shadowmarch(vec3 ray, vec3 light)\n{\n    for(int i = 0; i < 100; i++) { \n        float dist = sdf(ray);\n\n        if(dist < eps){\n            return 0.1;\n        }\n\n        ray += light * dist;\n    }\n\n    return 1.0;\n}\n\nvec3 bounceMarch(vec3 ray, vec3 dir)\n{\n    vec3 col = vec3(0, 0, 0);\n    float traveled = 0.0;\n\n    for(int i = 0; i < 100; i++) { \n        float dist = sdf(ray);\n        traveled += dist;\n\n        if(dist < eps){\n            vec3 normal = getNormal(ray);\n            ray -= dir * 0.1;\n            dir = reflect(dir, normal);\n\n            col += getColor(ray) / max(traveled * 0.02, 1.0);\n        }\n\n        ray += dir * dist;\n    }\n\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float inc = abs(mod(iTime * 0.001, 50.) - 25.);\n\n    vec2 uv = fragCoord/iResolution.x;\n    \n    vec3 dir = normalize(vec3(uv, -1));\n    vec3 ray = vec3(sin(iTime) * 10.0, 100.0, cos(iTime) * 10.0);\n    \n    vec3 col = raymarch(ray, dir) + bounceMarch(ray, dir);\n\n    vec3 light = normalize(lightPos - ray);\n\n    vec3 norm = getNormal(ray);\n\n    float shadow = shadowmarch(ray, light);\n\n    float dif = max(dot(light, norm), 0.0);\n\n    float spec = max(dot(reflect(light, norm), dir), 0.0);\n    spec = pow(spec, 32.0);\n\n    float fog = clamp(200.0 / length(ray), 0.0, 1.0);\n\n    float shading = shadow * (dif + spec) + 0.2;\n\n    fragColor = vec4((col * shading) * fog, 1);\n}","name":"Image","description":"","type":"image"}]}