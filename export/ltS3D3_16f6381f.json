{"ver":"0.1","info":{"id":"ltS3D3","date":"1432968613","viewed":296,"name":"Cell Noise Waves","username":"joeedh","description":"Waves with cell noise","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["cellnoisevoronoiwves"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"float noise(vec2 xy) {\n    xy = mod(xy, 1.0) + xy*0.01;\n    //xy *= fract(1.0/(0.01*length(xy)));\n    \n    return fract(1.0/(0.0001*length(xy)))-0.5;\n    \n    //float t = texture(iChannel0, xy)[1];\n    //return t-0.5;\n    \n    \n    //xy *= 0.2;\n    \n    //float t = xy[0]*xy[1]*542.2344 + 1.0/(0.00005 + xy[0]*xy[0]*xy[1]*xy[1]);\n    //t = abs(fract(1.0001/cos(t)));//*0.5+0.5;\n    //return (t-0.5);\n}\n\nvec2 noise2(vec2 xy) {\n    float a = noise(xy), b = noise(vec2(a+xy[1], a-xy[0]));\n\treturn normalize(vec2(a, b))*0.35;\n}\n\nfloat smoothstep2(float a, float b, float t) {\n    float t3=t*t*t, t4=t3*t, t5=t4*t;\n    \n    t = 6.0*t5 - 15.0*t4 + 10.0*t3;\n    return a + (b - a)*t;\n}\nfloat pnoise(vec2 uv, float sz) {\n    float u = uv[0]/sz, v = uv[1]/sz, fu = floor(u), fv = floor(v);\n    \n    float c1 = noise(vec2(fu, fv)*sz); \n    float c2 = noise(vec2(fu, fv+1.0)*sz); \n    float c3 = noise(vec2(fu+1.0, fv+1.0)*sz); \n    float c4 = noise(vec2(fu+1.0, fv)*sz); \n    \n    u -= fu; v -= fv;\n    \n    u = smoothstep(0.0, 1.0, u);\n    v = smoothstep(0.0, 1.0, v);\n    \n    float r1 = c1 + (c2 - c1)*v;\n    float r2 = c4 + (c3 - c4)*v;\n    \n    float r = r1 + (r2 - r1)*u;\n    \n    return r; //r*0.2 + r*r*0.2 + r*r*r*0.2;\n}\n\nfloat atan2(float x, float y) {\n    if (x > 0.0) {\n        return atan(y / x);\n    } else if (y >= 0.0 && x < 0.0) {\n        return atan(y/x) + 3.14159;\n    } else if (y < 0.0 && x < 0.0) {\n        return atan(y/x) - 3.14159;\n    } else if (y > 0.0 && x == 0.0) {\n        return 3.14159*0.5;\n    } else if (y < 0.0 && x == 0.0) {\n        return -3.14159*0.5;\n    } else {\n    \treturn 0.0;\n    }\n}\n\nfloat atan2(vec2 xy) {\n    return atan2(xy[1], xy[0]);\n}\n\nfloat manlen(vec2 vec) {\n    vec = abs(vec);\n    return vec[1]+vec[0];\n}\n\nvec2 dorot(vec2 v) {\n    float s = 0.0; //(iTime*0.5);\n    \n    float a = atan2(v);\n    \n    return vec2(sin(a+s), cos(a+s))*length(v);\n}\n\nfloat dolen(vec2 uv, vec2 v, vec2 ov) {\n    float len = length(uv-v); //acos(dot(normalize(v-uv), normalize(v))); //abs(manlen(v - uv)-length(v-uv))*10.0;\n    \n    //float a = (3.1-atan2(ov))+3.141;\n    \n    //return len;\n    return smoothstep(0.0, 1.0, pow(len, 0.85));\n}\n\nvec3 docell(float x, float y, float fu, float fv, float u, float v, float sz, vec3 cur) {\n    float smul = 0.9 - 0.75*iMouse[0]/iResolution[0];\n   \tvec2 hvec = vec2(0.0, 0.0);\n    \n    vec2 cc = noise2(vec2(fu+x, fv+y)*sz); \n    cc = dorot(cc-hvec)+hvec;\n\n    vec2 cc2 = (vec2(fu+x, fv+y)+cc*smul) - vec2(fu, fv);\n    float ss = dolen(vec2(u, v), cc2, cc), ss1=ss;\n\tss = pow(ss, 0.7);\n    float tm = iTime*8.0;\n    \n    ss = sin(ss*55.0-tm)*0.5+0.5;\n    //ss /= abs(1.0-ss1);\n    \n    if (ss1 > 0.99) ss = 1.0;\n    \n    //cur[0] = ss;\n    float last = cur[0];\n    return vec3((cur[0]+ss), max(cur[1], ss), ss1);\n}\n\nfloat voronoi(vec2 uv) {\n    uv *= 0.7;\n\tvec2 ouv = uv;\n    \n    //uv[0] *= 1.5;\n    \n    float y2 = uv[1] + fract(iTime*0.05)*7.0;\n    vec2 uv2 = vec2(uv[0], y2);\n    \n    float sz=0.08;\n\tfloat sz2 = 0.005; //sz/0.105; //0.4;\n    \n    float u = uv[0]/sz, v = uv[1]/sz, fu = floor(u), fv = floor(v);\n    \n    u -= fu; v -= fv;\n    \n    float c;\n    \n    float smul = 0.9 - 0.75*iMouse[0]/iResolution[0]; //0.75;\n   \tvec2 hvec = vec2(0.0, 0.0);\n    \n    c = 5.0;\n    float d3=-5.0;\n    vec3 mm = vec3(5.0, -5.0, 0.0);\n    vec4 dv = vec4(0.0,0.0,0.0, 0.0);\n    \n    for (int i=0; i<4; i++) {\n        float fi = float(i);\n        float fi2 = float(i/2);\n        float fi3 = float((i+1)/2);\n        \n        float x = mod(fi2+2.0, 2.0);\n        float y = mod(fi3+2.0, 2.0);\n        x = floor(x);\n        y = floor(y);\n        \n        //dv = docell_dv(x, y, fu, fv, u, v, sz, mm, dv);\n        mm = docell(x, y, fu, fv, u, v, sz, mm);\n    }\n    \n    return mm[0]; //ret*p;// ret;//(mm[2]/3.0);\n}\n\n\n\n/*\non factor;\noff period;\n\nf1 := u*ax + v*bx + (1.0-u-v)*cx - px;\nf2 := u*ay + v*by + (1.0-u-v)*cy - py;\n\nf := solve({f1, f2}, {u, v});\n*/\nvec2 get_uv(vec2 a, vec2 b, vec2 c, vec2 p) {\n    float u = (c.x*p.y-c.y*p.x+(c.y-p.y)*b.x-(c.x-p.x)*b.y)/(b.x*c.y-b.y*c.x+(b.y-c.y)*a.x-(b.x-c.x)*a.y);\n    float v = (-(c.x*p.y-c.y*p.x+(c.y-p.y)*a.x)+(c.x-p.x)*a.y)/(b.x*c.y-b.y*c.x+(b.y-c.y)*a.x-(b.x-c.x)*a.y);\n    return vec2(u, v);\n}\n\n#define DF 0.00001\nvec2 get_dv(vec2 uv) {\n    float c = voronoi(uv);\n    float dx = voronoi(vec2(uv[0]+DF, uv[1]))-c;\n    float dy = voronoi(vec2(uv[0], uv[1]+DF))-c;\n    \n    return vec2(dx, dy)/DF;\n}\n#undef DF\n\nfloat shade_sample1(vec2 uv) {\n    float cs = voronoi(uv);\n    float c2 = 1.0 - pow(cs, 9.0)*0.8;\n    c2 += (1.0-sqrt(cs))*0.9;\n    return c2;\n}\n\nfloat shade_sample(vec2 uv) {\n    float cs = voronoi(uv);\n    //float c2 = 1.0 - pow(cs, 9.0)*0.8;\n    float c2 = 1.0 - cs;\n    //c2 += (1.0-sqrt(cs))*0.9;\n    //c2 *= 0.5;\n    \n    //c2 = exp(c2*0.05);\n    return c2; //smoothstep(0.0, 1.0, c2);\n}\n\nfloat pnoiseA(vec2 p, float sz) {\n    float c1 = pow(pnoise(p*1.5+22.534, sz)+0.5, 0.2);\n    float c2 = pnoise(p+c1*0.05, sz);\n    \n    c1 = c2+c1*c2;\n    return pow(c1+1.0, 4.0)*1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv[0] *= 1.5;\n    \n    float tm = iTime*2.0;\n\n    float b = 1.0-voronoi(uv*0.2+0.5);\n    float b2 = b;\n    float dx = 155.0*dFdx(b)/iResolution.x;\n    float dy = 155.0*dFdy(b)/iResolution.y;\n\n    vec3 view = normalize(vec3(uv, 3.0));\n    vec3 light = normalize(vec3(cos(tm)*0.1, sin(tm)*0.1, 0.4));\n    \n    vec3 dv = normalize(vec3(dx, dy, 0.15*sqrt(1.0-dx*dx-dy*dy)));\n    \n    vec3 h = normalize(dv+view);\n    b = max(dot(light, h), 0.0);\n    b = pow(abs(b), 50.0)*0.3;\n    \n    b = b2*0.0 + b + abs(dot(dv, light))*0.2;\n    \n    //dv.xy = vec2(dv.y, -dv.x)*0.5;\n    //dv[0] = -dv[0];\n    //uv[0] *= 0.2;\n    float a = texture(iChannel0, uv+0.05*dv.xy+0.5)[0];\n    b = b*0.9*a + b*0.2;\n    vec3 clr1 = vec3(b, b+0.05, b+0.2);\n    \n    vec3 clr = texture(iChannel0, uv+0.1*dv.xy+0.5).xyz;\n    clr = clr1 + clr;\n    \n    //b = b2;\n    //b = b*b;\n    //b = sin(b*50.0-iTime*50.0);\n    fragColor = vec4(clr, 1.0);\n    \n}","name":"","description":"","type":"image"}]}