{"ver":"0.1","info":{"id":"mtcyzl","date":"1699532459","viewed":49,"name":"Non-zero two paths fil (with AA)","username":"Envy24","description":"Shows how to apply anti-aliasing to previous shader.\nLMB down => with antialiasing,\nLMB up     => without.\nBetter version: https://www.shadertoy.com/view/dtdyRl","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fill","zero","shape","odd","even","non"],"hasliked":0,"parentid":"ct3yRs","parentname":"Non-zero two paths fill"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCENE_SCALE               ( 1.2 )\n#define AA_UNIT                   ( (SCENE_SCALE*4.0) / iResolution.y  )\n#define SMAA(d)                   ( smoothstep(AA_UNIT, 0., d) )\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nint is_inside_two_path_shape(vec2 P)\n{\n    int winding = 0;\n\n    for (int p = 0; p < path_length; ++p)\n    {      \n        int pn = (p + 1) % path_length;\n    \n        // Check path A.\n        float x1 = pathA[p].x,  y1 = pathA[p].y,\n              x2 = pathA[pn].x, y2 = pathA[pn].y,\n              ratio = (P.y - y1) / (y2 - y1);\n        \n        // Ray intersects with segment?\n        if ( ( (P.y < y1) != (P.y < y2) ) && ( P.x < (x1 + ratio * (x2 - x1)) ) )\n        {\n            // Segment goes down?\n            if (y1 > y2)\n                winding += 1;\n            else\n                winding -= 1;\n        }\n        \n        // Check path B.\n        x1 = pathB[p].x,  y1 = pathB[p].y,\n        x2 = pathB[pn].x, y2 = pathB[pn].y,\n        ratio = (P.y - y1) / (y2 - y1);\n        \n        // Ray intersects with segment?\n        if ( ( (P.y < y1) != (P.y < y2) ) && ( P.x < (x1 + ratio * (x2 - x1)) ) )\n        {\n            // Segment goes down?\n            if (y1 > y2)\n                winding += 1;\n            else \n                winding -= 1;\n        }\n    }\n\n    return int(winding != 0); // Non-zero rule\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    init_paths();\n    //randomizeA(iTime);\n    //randomizeB(iTime);\n\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0), false),\n         MP = iMouse.xy == vec2(0) ? vec2(0) :\n             map_to_centered_ndc(iMouse.xy, SCENE_SCALE, vec2(0), false);\n    \n    float min_d = 9e5;\n    vec3 color = is_inside_two_path_shape( NDC ) == 0 ? vec3(1) : vec3(1,0,0);\n    if (iMouse.z < 0.)\n    {\n        /* Path A. */\n        min_d = path_SDF(NDC, pathA);\n        color = mix( color, vec3(1,0,0), SMAA(min_d) );\n        /* Path B. */\n        min_d = path_SDF(NDC, pathB);\n        color = mix( color, vec3(1,0,0), SMAA(min_d) );\n    }\n    /* Blue ray. */\n    min_d = segmentSDF( NDC, MP, -vec2(100,0), 0. ) + 0.004;\n    color = mix( color, vec3(0,0,1), SMAA( min_d ));\n    /* Circle sample. */\n    min_d = circleSDF( NDC, MP, 0.014 );\n    vec3 circle_col = is_inside_two_path_shape( MP ) == 1 ? 1.-vec3(1,0,0) : vec3(0);\n    color = mix( color, circle_col, SMAA( min_d ));\n    /**/\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float circleSDF(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\nfloat segmentSDF(in vec2 NDC, in vec2 B, in vec2 E, in float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}\n// Points exactly at point E.\nfloat arrowSDF(\n    in vec2 NDC,\n    in vec2 B,\n    in vec2 E,\n    in float R)\n{\n    float len = length(B-E);    \n    vec2 dir = normalize(E-B),\n         //up = cross(vec3(dir, 0.), vec3(0, 0, -1)).xy,   \n         up = vec2(-dir.y, dir.x),\n         C = E - dir * 0.05, //      U--\n         U = C + up  * 0.020,  // B----C----E\n         D = C - up  * 0.020;  //      D--\n    \n    vec3 BARY = inverse(mat3(\n            U.x, U.y, 1.0,\n            D.x, D.y, 1.0,\n            E.x, E.y, 1.0)) * vec3(NDC.x, NDC.y, 1.0);\n    \n    float sign = \n        BARY.x >= 0.0 &&    \n        BARY.y >= 0.0 && \n        BARY.z >= 0.0 ?  // inside triangle?\n            -1. : 1.;\n    \n    float d = segmentSDF(NDC, U, D, 0.);\n          d = min(d, segmentSDF(NDC, U, E, 0.));\n          d = min(d, segmentSDF(NDC, D, E, 0.));\n          d = \n              len < 0.05 ? \n                  d :\n                  min(d, segmentSDF(NDC, B, C, 0.));\n    \n    return sign*d-R;           \n}\n\nconst int path_length = 8;\nvec2 pathA[path_length];\nvec2 pathB[path_length];\n\nvoid init_paths()\n{\n    pathA[0] = vec2(-0.5, 0.3); \n    pathA[1] = vec2(-0.5, 1);\n    pathA[2] = vec2(0.5, 1);\n    pathA[3] = vec2(0.5, 0.3);\n    \n    pathA[4] = vec2(-0.25, -0.15); \n    pathA[5] = vec2(-0.25, -0.7);\n    pathA[6] = vec2(0.25, -0.7);\n    pathA[7] = vec2(0.25, -0.15);\n    \n    for (int i = 0; i < path_length; ++i)\n    {\n        pathB[i] = pathA[path_length - 1 - i] * vec2(1, -1) + vec2(0, 0.15);\n    }\n}\nfloat path_SDF(vec2 NDC, vec2 path[path_length])\n{\n    float min_d = 9e5;\n    for (int p = 0; p < path_length - 1; ++p)\n    {\n        min_d = min( min_d, segmentSDF(NDC, path[p], path[p + 1], 0.) );\n    }\n    min_d = min( min_d, segmentSDF(NDC, path[path_length - 1], path[0], 0.) );\n    \n    return min_d;\n}\n\n/* \n    Returns random vec2([-1.0; 1.0], [-1.0; 1.0]).\n*/\nvec2 h2to2(\n    const uint x,\n    const uint y)\n{\n    // Pick some seed source values.\n    const uint seed0 = 123u;\n    const uint seed1 = 456u;\n    const uint seed2 = 789u;\n\n    uint value0 = y * seed2 + x;\n    uint value1 = x * seed2 + y;\n\n    // Calculate hash.\n\tvalue0 += seed1; value0 *= 445593459u; value0 ^= seed0;\n    value1 += seed1; value1 *= 445593459u; value1 ^= seed0;\n    \n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n\n    return \n        vec2(\n            float(value0 * value0 * value0) * 4.6566128730773926e-10f - 1.0f,\n            float(value1 * value1 * value1) * 4.6566128730773926e-10f - 1.0f);\n}\n\nvoid randomizeA(float time)\n{\n    time *= 0.5;\n    float t = fract(time);\n    uint T = uint(time);\n\n    for (int k = 0; k < path_length; ++k)\n    {\n        uint x = T + uint(k);\n        uint y = 2u * T + uint(k * 2);\n        vec2 c = 1.2*h2to2(x, y);\n        vec2 n = 1.2*h2to2(x + 1u, y + 2u);\n    \n        pathA[k] = c * (1. - t) + n * t;\n    }\n}\nvoid randomizeB(float time)\n{\n    time += 100.;\n    time *= 0.5;\n    float t = fract(time);\n    uint T = uint(time);\n\n    for (int k = 0; k < path_length; ++k)\n    {\n        uint x = T + uint(k);\n        uint y = 2u * T + uint(k * 2);\n        vec2 c = 1.2*h2to2(x, y);\n        vec2 n = 1.2*h2to2(x + 1u, y + 2u);\n    \n        pathB[k] = c * (1. - t) + n * t;\n    }\n}","name":"Common","description":"","type":"common"}]}