{"ver":"0.1","info":{"id":"mtsfRM","date":"1692869527","viewed":40,"name":"Fractal layered noise visualiser","username":"Tribal_Talker","description":"Quality visualiser for fractally layered, cosine-interpolated second-order noise. Shows six levels of detail, from 2-layer noise at the bottom up to 7-layer noise at the top. Calculation overhead scales linearly with layer count.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["fractal","noise","texture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nAll code by Tribal_Talker except where noted.\nAugust 2023\n\nReference for this code:\nhttps://www.shadertoy.com/view/mtsfRM\nUser: Tribal_Talker\n\nCreative Commons License\nThis work is licensed under a Creative Commons \nAttribution-NonCommercial-ShareAlike 3.0 Unported License.\n(This is the default ShaderToy user license)\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // vec2 uv = fragCoord.xy/min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n    float t = iTime/50.0;\n    \n    vec2 p = uv;\n    p.y -= t; // vertical scroll\n\n    float detail_stepper = 2.0 + floor(6.0*fragCoord.y/iResolution.y);\n    float noise = mutator(p, vec3(detail_stepper));\n    \n    // applies a tint to the mono texture\n    vec3 col = hsv2rgb(fract(0.3+0.65*p.x), 0.65, 1.1*noise);\n    \n    // transition markers\n    vec2 pl = fragCoord/iResolution.xy;\n    pl.y = fract(pl.y*6.0);\n    float line = smoothstep(0.025, 0.0, length(pl.yy));\n    col = mix(col, vec3(line), abs(uv.x)-0.3);\n    \n    fragColor = vec4(col, 1.0);;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\nAll code by Tribal_Talker except where noted.\nBuilt: August 2023\n\nBase reference for this library:\nhttps://www.shadertoy.com/view/dlffDH\nUser: Tribal_Talker\n\nCreative Commons License\nThis work is licensed under a Creative Commons \nAttribution-NonCommercial-ShareAlike 3.0 Unported License.\n(This is the default ShaderToy user license)\n*/\n\n#define PI  3.14159265359\n#define TAU 6.28318530718 // 2 * PI\n\n\n// ---------------------------------------------------- //\n// Dave Hoskins: https://www.shadertoy.com/view/4djSRW\n// MIT License. Copyright (c)2014 David Hoskins.\n// Note: this function appears in the \"Common\" tab of\n// the referenced shader code, alongside other useful\n// hashing functions.\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n// ---------------------------------------------------- //\n\n\n// ---------------------------------------------------- //\n// Tribal ## Utility Library ##\n// ---------------------------------------------------- //\n\n// Approximate HSV to RGB using clamped cosine waves.\n// Normalised inputs: hue 0..1, sat 0..1, val 0..1\n// Returns normalised RGB ready for display.\nvec3 hsv2rgb(float hue, float sat, float val)\n{\n    vec3 rgb = clamp(vec3(0.5) + cos(vec3(hue*TAU, (hue+0.66667)*TAU, (hue+0.33333)*TAU)), 0.0, 1.0);\n    return val * mix(vec3(1.0), rgb, sat);\n}\n\nvec3 hsv2rgb(vec3 hsv)\n{\n    vec3 rgb = clamp(vec3(0.5) + cos(vec3(hsv.x*TAU, (hsv.x+0.66667)*TAU, (hsv.x+0.33333)*TAU)), 0.0, 1.0);\n    return hsv.y * mix(vec3(1.0), rgb, hsv.z);\n}\n\n// Polar transformation of coords for general coords.\n// Angle zero is at 3 o'clock, angles go counter-clockwise.\nvec2 toPolarV2(vec2 uv)\n{\n    return vec2( (0.5 + atan(-uv.y, -uv.x) / TAU), length(uv) );\n}\n\n// Cosine interpolation (smoother than plain LERP)\n// Modeled on the MIX function: float mix(float start, float end, float range);\n// Interpolates between two values but uses cosines for smoothness.\n// NB range is a positive fractional value.\nfloat cosine_mix(float y1, float y2, float range)\n{\n    return y1 + (y2-y1) * (1.0 - cos(range*PI)) * 0.5;\n}\n\n// ---------------------------------------------------- //\n// Generic Noise Functions\n// ---------------------------------------------------- //\n\n// Grabs one value per user specified block of coordinates.\n// Generates a blocky noise texture.\n// Wraps around so that there are only a \"tile_count\" number\n// of values possible to generate in the x-direction, so that\n// textures generated wrap seamlessly in x.\nfloat chunky_noise(vec2 p, vec2 ofs, float tile_count)\n{\n    // coordinate wrapping inside a [tile_count * tile_count] square\n    p = fract(p + vec2(ofs/tile_count));\n    vec2 block = p * tile_count;\n    // return hash12(block - fract(block));\n    return hash12(floor(block));\n}\n\n// Generates a 2x2 set of chunky noise values and smooths them out.\n// Cosine interpolated value noise.\nfloat smoothed_chunks(vec2 p, float tile_count)\n{\n    vec2 fine = fract(p * tile_count);\n    vec3 offset = vec3(1.0, 1.0, 0.0);\n\n    float t1 = chunky_noise(p, offset.zz, tile_count);\n    float t2 = chunky_noise(p, offset.xz, tile_count);\n    float g1 = cosine_mix(t1, t2, fine.x);\n\n    float b1 = chunky_noise(p, offset.zy, tile_count);\n    float b2 = chunky_noise(p, offset.xy, tile_count);\n    float g2 = cosine_mix(b1, b2, fine.x);\n\n    return cosine_mix(g1, g2, fine.y);\n}\n\n// Generates layers of \"fractally scaled\" noise for a better look.\nfloat layered_noise(vec2 p, float tile_count, float layers)\n{\n    float grey = 0.5 * smoothed_chunks(p, tile_count);\n\n    // 4, 8, 16, 32, 64\n    for(float f=4.0; f<exp2(floor(layers)); f*=2.0)\n    {\n        p += vec2(0.5/tile_count);\n        tile_count *= 2.0;\n        grey += smoothed_chunks(p, tile_count) / f;\n    }\n\n    return grey;\n}\n\n// Feeds the layered noise with coordinates generated by\n// layered noise.\n// depth values should be [2..8], lower=faster, higher=detailed\nfloat mutator(vec2 p, vec3 depth)\n{\n    vec3 offs = vec3(0.01, 0.01, 0.0);\n\n    float nx = layered_noise(p+offs.zz, 15.0, depth.x);\n    float ny = layered_noise(p+offs.xz, 11.0, depth.y);\n    \n    return layered_noise(vec2(nx,ny), 13.0, depth.z);\n}\n\n// ---------------------------------------------------- //\n","name":"Common","description":"","type":"common"}]}