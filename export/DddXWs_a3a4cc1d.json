{"ver":"0.1","info":{"id":"DddXWs","date":"1680581096","viewed":116,"name":"Tron Shader","username":"JaminV","description":"Tron Shader using gradient edge detection\nbest viewed on fullscreen","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["tron"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//resources used: \n//https://cse.usf.edu/~r1k/MachineVisionBook/MachineVision.files/MachineVision_Chapter5.pdf\n//http://blog.geveo.com/Image-Smoothing-Algorithms\n#define LISTSIZE 9\n\nfloat medianFunc(float list[LISTSIZE]){\n\n    for(int i=0; i<LISTSIZE-1; i++)\n    {\n        if (list[i] > list[i + 1])\n        {\n            // Swapping the elements.\n            float temp = list[i];\n            list[i] = list[i + 1];\n            list[i + 1] = temp;\n             \n            i = -1;\n        }\n    }\n    //return median\n    return(list[LISTSIZE/2]);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    \n    //blue line smoothing\n    if(col.z > col.x && col.z > col.y){\n        float offset = 1.;\n\n        //get neighboring normalized coordinates\n        vec2 uvUp        = (fragCoord+(0.,offset))/iResolution.xy;\n        vec2 uvDown      = (fragCoord-(0.,offset))/iResolution.xy;\n        vec2 uvLeft      = (fragCoord-(offset,0.))/iResolution.xy;\n        vec2 uvRight     = (fragCoord+(offset,0.))/iResolution.xy;\n        vec2 uvUpRight   = (fragCoord+(offset,offset))/iResolution.xy;\n        vec2 uvUpLeft    = (fragCoord+(-offset,offset))/iResolution.xy;\n        vec2 uvDownRight = (fragCoord+(offset,-offset))/iResolution.xy;\n        vec2 uvDownLeft  = (fragCoord-(offset,offset))/iResolution.xy;\n\n        vec4 colList[LISTSIZE];\n        //get neighboring colors\n        colList[0] = col;\n        colList[1] = texture(iChannel0, uvUp);\n        colList[2] = texture(iChannel0, uvDown);\n        colList[3] = texture(iChannel0, uvLeft);\n        colList[4] = texture(iChannel0, uvRight);\n        colList[5] = texture(iChannel0, uvUpRight);\n        colList[6] = texture(iChannel0, uvUpLeft);\n        colList[7] = texture(iChannel0, uvDownRight);\n        colList[8] = texture(iChannel0, uvDownLeft);\n\n        //Change these values to compare between mean, median or no smoothing\n        bool isSmooth   = true; //true = turn on smoothing\n        bool smoothMean = true;  //true = turn on mean, false = turn on median \n        \n        //mean filter\n        if(isSmooth && smoothMean){\n            vec3 colTotal = vec3(0.,0.,0.);\n            for(int i=0;i<LISTSIZE;i++){\n                colTotal += colList[i].xyz;\n            }\n            //find mean of values\n            col.xyz = colTotal/float(LISTSIZE);\n        }\n        \n        //median filter\n        if(isSmooth && !smoothMean){\n        \n            //divide rgb values\n            float colListR[LISTSIZE];\n            float colListG[LISTSIZE];\n            float colListB[LISTSIZE];\n\n            for(int i=0;i<LISTSIZE;i++){\n                colListR[i] = colList[i].x;\n                colListG[i] = colList[i].y;\n                colListB[i] = colList[i].z;\n            }\n\n            col.x = medianFunc(colListR);\n            col.y = medianFunc(colListG);\n            col.z = medianFunc(colListB);\n        }\n    }\n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //get current color value from input\n    vec4 col = texture(iChannel0, uv);\n    \n    //apply light blue filter\n    col.xyz += vec3(0.05, 0.05, 0.2);\n    \n    //edge detection\n    \n    //increase value for increasing neighbor range\n    float offset = 3.;\n    \n    //get neighboring normalized coordinates\n    vec2 uvUp    = (fragCoord+(0.,offset))/iResolution.xy;\n    vec2 uvDown  = (fragCoord-(0.,offset))/iResolution.xy;\n    vec2 uvLeft  = (fragCoord-(offset,0.))/iResolution.xy;\n    vec2 uvRight = (fragCoord+(offset,0.))/iResolution.xy;\n    \n    //get neighboring colors\n    vec4 colUp    = texture(iChannel0, uvUp);\n    vec4 colDown  = texture(iChannel0, uvDown);\n    vec4 colLeft  = texture(iChannel0, uvLeft);\n    vec4 colRight = texture(iChannel0, uvRight);\n    \n    //calculate gradient\n    vec4 gradient = abs(colUp - colDown) + abs(colLeft - colRight);\n    \n    //decrease value to increase sensitivity of detecting an edge\n    float margin = 0.15;\n    \n    //check if edge is detected\n    if(gradient.x > margin || gradient.y > margin || gradient.z > margin){\n        //add neon blue outline when significant edge is found\n        col = vec4(0., 0.7, 1., 1.);\n    }\n    //if not part of the edge turn to grayscale\n    else{\n        //weighted method of grayscale conversion\n        col = vec4(vec3(0.299*col.x + 0.587*col.y + 0.114*col.z),col.a);\n    }\n\n    //Output to screen\n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"}]}