{"ver":"0.1","info":{"id":"ctKyRd","date":"1700606779","viewed":22,"name":"Cloudy Mountains","username":"serioux666","description":"Simple terrain, colors not really pretty, no textural details, lighting is bad, camera is flown by someone with a fear of flying","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","terrain","clouds","shakycamera","okayish"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\n\nconst int ANTIALIASING = 0;\n#define USE_SMOOTH_NOISE 1\n#define USE_SHADOWED_CLOUDS 1\n\nconst vec3 c = vec3(1.,0.,-1.);\nconst float pi = 3.14159265359;\nconst float MAX_DEPTH = 250.;\nconst vec3 LIGHT_DIR = normalize(vec3(2.0, 1.0, 2.0));\nconst vec3 COLOR_GRASS = vec3(0.4, 0.7, 0.23);\nconst vec3 COLOR_DIRT = vec3(0.4, 0.4, 0.0);\nconst vec3 COLOR_SNOW = vec3(0.95, 0.95, 1.0);\nconst vec3 COLOR_STONE = vec3(0.6, 0.6, 0.4);\nconst vec3 COLOR_FOG = vec3(0.7, 0.7, 1.0);\nconst vec3 COLOR_SKY = vec3(0.4, 0.5, .8);\nconst float CLOUD_FLOOR = 10.;\nconst float CLOUD_CEIL = CLOUD_FLOOR + 100.;\n\n// Created by David Hoskins and licensed under MIT.\n// See https://www.shadertoy.com/view/4djSRW.\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract(dot(p3.xy, p3.zz));\n}\n\nfloat lnoise(vec2 t)\n{\n    vec2 i = floor(t);\n    t = c.xx * smoothstep(0., 1., fract(t));\n    vec2 v1 = 2. * mix(vec2(hash12(i), hash12(i + c.xy)), vec2(hash12(i + c.yx), hash12(i + c.xx)), t.y) - 1.;\n    return mix(v1.x, v1.y, t.x);\n}\n\n// iq's elevated\nvec3 noised( in vec2 x )\n{\n    vec2 f = fract(x);\n    #if USE_SMOOTH_NOISE==0\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n    #else\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n    #endif\n\n#if 1\n    // texel fetch version\n    ivec2 p = ivec2(floor(x));\n    float a = texelFetch( iChannel0, (p+ivec2(0,0))&255, 0 ).x;\n\tfloat b = texelFetch( iChannel0, (p+ivec2(1,0))&255, 0 ).x;\n\tfloat c = texelFetch( iChannel0, (p+ivec2(0,1))&255, 0 ).x;\n\tfloat d = texelFetch( iChannel0, (p+ivec2(1,1))&255, 0 ).x;\n#else    \n    // texture version    \n    vec2 p = floor(x);\n\tfloat a = textureLod( iChannel0, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\n\tfloat b = textureLod( iChannel0, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\n\tfloat c = textureLod( iChannel0, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\n\tfloat d = textureLod( iChannel0, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\n#endif\n    \n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\tdu*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nmat3 rotationX( float angle ) {\n\tfloat ca = cos( angle );\n\tfloat sa = sin( angle );\n\t\n\treturn mat3(\n\t\t1., 0., 0.,\n        0., ca, sa,\n        0.0, -sa, ca\n\t);\n}\n\nconst mat2 m = mat2(0.8, -0.6, 0.6, 0.8);\nconst mat3 m3d = mat3(1., 0., 0., 0., 0.8, -0.6, 0., 0.6, 0.8);\n\nfloat fbmBiome(vec2 p)\n{\n    float f = 0.;\n    float a = 1.;\n    p /= 20.;\n\tfor(int i = 0; i < 3; ++i) {\n        f += a *  noised(p).x,\n        p *= 1.1;\n        a *= .2;\n        p = m * p;\n    }\n\treturn f;\n}\n\nconst float TERRAIN_SIZE = 15.;\nconst float TERRAIN_GAIN = 0.5;\nconst float TERRAIN_LACUNARITY = 1.9;\nconst float TERRAIN_SNOW_HEIGHT = 20.0;\nconst float TERRAIN_EXPONENT = 2.5;\nconst float TERREIN_SNOW_HEIGHT_BIOME_FACTOR = 7.0;\n\n\nfloat cloudFbm(vec3 p)\n{\n    float f = 0.;\n    float a = 1.;\n    //p /= 256.0 * 4.;\n    p /= 1000.;\n\tfor(int i = 0; i < 2; ++i) {\n        f += a *  texture(iChannel1, p).r,\n        p = m3d * p * 3.3;\n        a *= 0.35;\n    }\n    return f;\n}\n\nfloat cloudDensity(vec3 p)\n{\n    const float threshold = 0.8;\n    float density = cloudFbm(p + c.xyy * iTime * 2.4 + 20.0 * cloudFbm(p + iTime * .4 + 20.0 * cloudFbm(p + iTime * 1.)));\n    float bound = smoothstep(CLOUD_FLOOR, CLOUD_FLOOR + 2., p.y) * smoothstep(CLOUD_CEIL, CLOUD_CEIL - 2., p.y);\n    return max(0., density - threshold) / (1. - threshold) * bound * 1.0;\n}\n\nfloat cloudCast(vec3 p, vec3 dir, int N, out float opaque, float max_depth)\n{\n    opaque = 0.0;\n    float t = 0.;\n    float tm = max_depth;\n    if(abs(dir.y) < 0.001 && (p.y < CLOUD_FLOOR || p.y > CLOUD_CEIL)) {\n        return 0.;\n    } else if(abs(dir.y) > 0.001) {\n        t = max(min((CLOUD_FLOOR - p.y) / dir.y, (CLOUD_CEIL - p.y) / dir.y), 0.);\n        tm = min(max((CLOUD_FLOOR - p.y) / dir.y, (CLOUD_CEIL - p.y) / dir.y), max_depth);\n    }\n    if(tm < 0.0) {\n        return 0.;\n    }\n    opaque = 0.0;\n    float dt = (tm - t) / float(N);\n    float max_density = 0.0;\n    for(int i = 0; i < N && t < tm && opaque < 1.0; ++i) {\n        float density = cloudDensity(p + t * dir) / float(N);\n        max_density = max(density, max_density);\n        opaque += density * dt;\n        dt = (1.0 - density) * (tm - t) / float(N - i);\n        t += dt;\n    }\n    return max_density;\n}\n\nfloat calcTerrainShadow(vec3 p0, vec3 dir, int N, float max_depth);\n\nfloat shadowedCloudCast(vec3 p, vec3 dir, int N, out float opaque, out float lightness, float max_depth)\n{\n    opaque = 0.0;\n    float t = 0.;\n    float tm = max_depth;\n    if(abs(dir.y) < 0.001 && (p.y < CLOUD_FLOOR || p.y > CLOUD_CEIL)) {\n        return 0.;\n    } else if(abs(dir.y) > 0.001) {\n        t = max(min((CLOUD_FLOOR - p.y) / dir.y, (CLOUD_CEIL - p.y) / dir.y), 0.);\n        tm = min(max((CLOUD_FLOOR - p.y) / dir.y, (CLOUD_CEIL - p.y) / dir.y), max_depth);\n    }\n    if(tm < 0.0) {\n        return 0.;\n    }\n    opaque = 0.0;\n    lightness = 0.0;\n    float dt = (tm - t) / float(N);\n    float max_density = 0.0;\n    for(int i = 0; i < N && t < tm && opaque < 1.0; ++i) {\n        vec3 ps = p + t * dir;\n        float density = cloudDensity(ps) / float(N);\n        max_density = max(density, max_density);\n        lightness += dt * calcTerrainShadow(ps, LIGHT_DIR, 16, 50.) * density;\n        opaque += density * dt;\n        dt = (1.0 - density) * (tm - t) / float(N - i);\n        t += dt;\n    }\n    if(opaque > 0.) {\n        lightness = max(0.3, lightness / opaque);\n    }\n    return max_density;\n}\n\nfloat terrainFbm(vec2 p, int N)\n{\n    float f = 0.;\n    float a = 1.;\n    //p /= 256.0 * 4.;\n    p /= 100.;\n\tfor(int i = 0; i < N; ++i) {\n        f += a *  noised(p).x,\n        p = m * p * TERRAIN_LACUNARITY;\n        a *= TERRAIN_GAIN;\n    }\n    return f;\n}\n\n\nfloat terrainHeight(vec2 p, int n)\n{\n\treturn pow(terrainFbm(p + terrainFbm(p, 4) * 5., n), TERRAIN_EXPONENT) * TERRAIN_SIZE;\n}\n\nfloat terrainHeightCoarse(vec2 p)\n{\n\n\treturn terrainHeight(p, 5);\n}\n\n\nfloat terrainHeightMedium(vec2 p)\n{\n\n\treturn terrainHeight(p, 8);\n}\n\nfloat terrainHeightFine(vec2 p)\n{\n\treturn terrainHeight(p, 14);\n}\n\nvec3 terrainNormal(vec3 p, float depth, int n)\n{\n    vec2 epsilon = vec2(0.001 * depth, 0.);\n    return normalize(vec3(\n        terrainHeight(p.xz - epsilon.xy, n) - terrainHeight(p.xz + epsilon.xy, n),\n        2. * epsilon.x,\n        terrainHeight(p.xz - epsilon.yx, n) - terrainHeight(p.xz + epsilon.yx, n)));\n}\n\n\nfloat raycastTerrain(vec3 p0, vec3 dir, out vec3 p)\n{\n    /* see iq's elevated */\n    float t = 0.;\n    for(int i = 0; i < 128 && t < MAX_DEPTH; ++i) {\n        p = p0 + t * dir;\n        float dh = p.y - terrainHeightMedium(p.xz);\n        if(abs(dh) < 0.001 * t) {\n            break;\n        }\n        t += 0.5 * dh;\n    }\n    \n    return t;\n}\n\nfloat calcTerrainShadow(vec3 p0, vec3 dir, int N, float max_depth)\n{\n    float t = 0.4;\n    float lightness = 1.0;\n    const float k = 3.0;\n    for(int i = 0; i < N && t < max_depth; ++i) {\n        vec3 p = p0 + t * dir;\n        float h = p.y - terrainHeightMedium(p.xz);\n        float dt = 0.8 * h;\n        lightness = min(lightness, max(0., k * h / t));\n        t += 0.8 * h;\n    }\n    return lightness;\n}\n\n\nfloat calcCloudShadow(vec3 p0, vec3 dir)\n{\n\n    float cloud_density;\n    float max_density = cloudCast(p0, LIGHT_DIR, 6, cloud_density, MAX_DEPTH);\n    return clamp(1. - max_density, 0.4, 1.0);\n}\n\nvec4 renderClouds(vec3 eye, vec3 dir, float max_depth)\n{\n    /* cloud layer */\n    float density;\n    float lightness = 1.;\n#if USE_SHADOWED_CLOUDS==1\n    float greyness = shadowedCloudCast(eye, dir, 64, density, lightness, max_depth);\n#else\n    float greyness = cloudCast(eye, dir, 64, density, max_depth);\n#endif\n    greyness = min(1., greyness + density * 0.4);\n    //max_density += min(1.0, density + 0.4);\n    vec3 col = mix(c.xxx, c.xxx * 0.6, smoothstep(0.2, 1., greyness));\n    //col = mix(col, COLOR_FOG, smoothstep(MAX_DEPTH * 0.5, MAX_DEPTH * 4.7, dist));\n    return vec4(col * lightness, density);\n}\n\nvec3 render(vec3 eye, vec3 dir)\n{\n    vec3 col = COLOR_FOG;\n    vec3 p_terrain;\n    float ambient = 0.15;\n    float dist_terrain = raycastTerrain(eye, dir, p_terrain);\n    if(dist_terrain < MAX_DEPTH) {\n        /* terrain */\n        float biome = fbmBiome(p_terrain.xz + fbmBiome(p_terrain.xz));\n        vec3 n_terrain = terrainNormal(p_terrain, dist_terrain, 14);\n        vec3 n_snow = terrainNormal(p_terrain, dist_terrain, 12);\n        float occlusion = clamp(sqrt(p_terrain.y / 10.) + 0.5, 0.0, 1.0); // extremely fake!!\n        occlusion = 1.0;\n        float shadow = min(1., calcTerrainShadow(p_terrain, LIGHT_DIR, 32, MAX_DEPTH) * calcCloudShadow(p_terrain, LIGHT_DIR) + ambient);\n        vec3 col_ground = mix(COLOR_GRASS, COLOR_DIRT, smoothstep(0.3, 0.8, biome));\n        col_ground = mix(COLOR_STONE, col_ground, smoothstep(0.9, .95, n_terrain.y));\n        col_ground *= clamp(dot(n_terrain, LIGHT_DIR), 0.0, 1.0);\n        vec3 col_snow = mix(COLOR_STONE, COLOR_SNOW, smoothstep(0.4, .7, n_terrain.y));\n        col_snow *= clamp(dot(n_snow, LIGHT_DIR) + 2. * ambient, 0.0, 1.0);\n        col = mix(col_ground, col_snow, smoothstep(TERRAIN_SNOW_HEIGHT, TERRAIN_SNOW_HEIGHT + abs(biome) * 5., p_terrain.y + biome * TERREIN_SNOW_HEIGHT_BIOME_FACTOR));\n        col *= occlusion * shadow;\n        col = mix(col, COLOR_FOG, smoothstep(MAX_DEPTH * 0.2, MAX_DEPTH * 1.3, dist_terrain));\n        //col = c.xxx * biome;\n    } else {\n        dist_terrain = MAX_DEPTH;\n    }\n    vec4 cloud = renderClouds(eye, dir, dist_terrain);\n    col = mix(col, cloud.rgb, cloud.a);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord - iResolution.xy / 2. ;\n    float z = iResolution.y * tan((90. - 45./2.)/180.* pi) * 0.5;\n    vec3 col;\n    float speed = 8.5;\n    vec3 eye = vec3(0.0, 3., iTime * speed);\n    vec3 eye_next = eye + c.yyx * speed;\n    vec3 eye_prev = eye - c.yyx * speed;\n    eye_prev += terrainHeightCoarse(eye_prev.xz) * 1.5;\n    eye.y += terrainHeightCoarse(eye.xz);\n    eye_next += terrainHeightCoarse(eye_next.xz) * 1.5;\n    mat3 M_pitch = rotationX(-0.0 + -0.5 * asin((eye_next.y - eye_prev.y) / length(eye_next - eye_prev)));\n    eye.y = (eye.y + eye_next.y + eye_prev.y) / 3.;\n\n    // super duper super sampling    \n    const float dss = 1. / float(ANTIALIASING + 1);\n    for(float xss = 0.; xss < 1.0; xss += dss) {\n        for(float yss = 0.; yss < 1.0; yss += dss) {\n            vec3 dir = normalize(vec3(xy, z) + vec3(xss, yss, 0.));\n            dir = M_pitch * dir;\n\n            col += render(eye, dir);\n        }\n    }\n    // Output to screen\n    fragColor = vec4(col * dss * dss, 1.0);\n}","name":"Image","description":"","type":"image"}]}