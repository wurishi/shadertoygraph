{"ver":"0.1","info":{"id":"4l3cRN","date":"1531693056","viewed":118,"name":"GNoise 2d","username":"TinyTexel","description":"shader","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["shader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// GNoise 2d\n// Created by TinyTexel\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n\n/*\ntilable 2d gradient noise \n*/\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\n#define Frame float(iFrame)\n#define Time iTime\n#define PixelCount iResolution.xy\n#define OUT\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat Pow(float x, float e) {return pow(x, e);}\nvec2 Pow(vec2 x, float e) {return pow(x, vec2(e));}\nvec3 Pow(vec3 x, float e) {return pow(x, vec3(e));}\nvec4 Pow(vec4 x, float e) {return pow(x, vec4(e));}\n\nfloat GammaDecode(float x) {return pow(x,      2.2) ;}\nvec2  GammaDecode(vec2  x) {return pow(x, vec2(2.2));}\nvec3  GammaDecode(vec3  x) {return pow(x, vec3(2.2));}\nvec4  GammaDecode(vec4  x) {return pow(x, vec4(2.2));}\n\nfloat GammaEncode(float x) {return pow(x,      1.0 / 2.2) ;}\nvec2  GammaEncode(vec2  x) {return pow(x, vec2(1.0 / 2.2));}\nvec3  GammaEncode(vec3  x) {return pow(x, vec3(1.0 / 2.2));}\nvec4  GammaEncode(vec4  x) {return pow(x, vec4(1.0 / 2.2));}\n\n\n#define FUNC4_UINT(f)\t\t\t\t\t\t\t\t\\\nuvec2 f(uvec2 v) {return uvec2(f(v.x ), f(v.y ));}\t\\\nuvec3 f(uvec3 v) {return uvec3(f(v.xy), f(v.z ));}\t\\\nuvec4 f(uvec4 v) {return uvec4(f(v.xy), f(v.zw));}\t\\\n    \n\n// single iteration of Bob Jenkins' One-At-A-Time hashing algorithm:\n//  http://www.burtleburtle.net/bob/hash/doobs.html\n// suggested by Spatial on stackoverflow:\n//  http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nuint BJXorShift(uint x) \n{\n    x += x << 10u;\n    x ^= x >>  6u;\n    x += x <<  3u;\n    x ^= x >> 11u;\n    x += x << 15u;\n\t\n    return x;\n}\n\nFUNC4_UINT(BJXorShift)    \n    \n\n// xor-shift algorithm by George Marsaglia\n//  https://www.thecodingforums.com/threads/re-rngs-a-super-kiss.704080/\n// suggested by Nathan Reed:\n//  http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nuint GMXorShift(uint x)\n{\n    x ^= x << 13u;\n    x ^= x >> 17u;\n    x ^= x <<  5u;\n    \n    return x;\n}\n\nFUNC4_UINT(GMXorShift) \n    \n// hashing algorithm by Thomas Wang \n//  http://www.burtleburtle.net/bob/hash/integer.html\n// suggested by Nathan Reed:\n//  http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nuint WangHash(uint x)\n{\n    x  = (x ^ 61u) ^ (x >> 16u);\n    x *= 9u;\n    x ^= x >> 4u;\n    x *= 0x27d4eb2du;\n    x ^= x >> 15u;\n    \n    return x;\n}\n\nFUNC4_UINT(WangHash) \n\n//#define Hash BJXorShift\n#define Hash WangHash\n//#define Hash GMXorShift\n\n// \"floatConstruct\"          | renamed to \"ConstructFloat\" here \n// By so-user Spatial        | http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// used under CC BY-SA 3.0   | https://creativecommons.org/licenses/by-sa/3.0/             \n// reformatted and changed from original to extend interval from [0..1) to [-1..1) \n//-----------------------------------------------------------------------------------------\n// Constructs a float within interval [-1..1) using the low 23 bits + msb of an uint.\n// All zeroes yields -1.0, all ones yields the next smallest representable value below 1.0. \nfloat ConstructFloat(uint m) \n{\n\tfloat flt = uintBitsToFloat(m & 0x007FFFFFu | 0x3F800000u);// [1..2)\n    float sub = (m >> 31u) == 0u ? 2.0 : 1.0;\n    \n    return flt - sub;// [-1..1)             \n}\n\nvec2 ConstructFloat(uvec2 m) { return vec2(ConstructFloat(m.x), ConstructFloat(m.y)); }\nvec3 ConstructFloat(uvec3 m) { return vec3(ConstructFloat(m.xy), ConstructFloat(m.z)); }\nvec4 ConstructFloat(uvec4 m) { return vec4(ConstructFloat(m.xyz), ConstructFloat(m.w)); }\n\n\nuint Hash(uint  v, uint  r) { return Hash(v ^ r); }\nuint Hash(uvec2 v, uvec2 r) { return Hash(Hash(v.x , r.x ) ^ (v.y ^ r.y)); }\nuint Hash(uvec3 v, uvec3 r) { return Hash(Hash(v.xy, r.xy) ^ (v.z ^ r.z)); }\nuint Hash(uvec4 v, uvec4 r) { return Hash(Hash(v.xy, r.xy) ^ Hash(v.zw, r.zw)); }\n\n// Pseudo-random float value in interval [-1:1).\nfloat Hash(float v, uint  r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec2  v, uvec2 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec3  v, uvec3 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec4  v, uvec4 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\n\n\nfloat HashFlt(uint   v, uint  r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec2  v, uvec2 r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec3  v, uvec3 r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec4  v, uvec4 r) { return ConstructFloat(Hash(v, r)); }\n\nuint HashUInt(float v, uint  r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec2  v, uvec2 r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec3  v, uvec3 r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec4  v, uvec4 r) { return Hash(floatBitsToUint(v), r); }\n\n\nfloat NormGrad(float x)\n{\n    return x / length(vec2(dFdx(x), dFdy(x)));\n}\n\nfloat GraphMask(float x)\n{\n    return clamp01(1.0 - abs(NormGrad(x)));\n}\n\nfloat GraphMask2(float x)\n{\n    return clamp01(NormGrad(x));\n}\n\n\nfloat Root4(float x)\n{\n    return rsqrt(rsqrt(x));\n}\n\n\nfloat SCurveCos(float x)\n{\n    return cos(x * Pi)*-.5+.5;\n}\n\nfloat SCurveC1(float x)\n{\n    return (x * -2.0 + 3.0) * x*x;\n}\n\nfloat SCurveC2(float x)\n{\n    return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x;\n}\n\n#define mad(x, m, a) ((x) * (m) + (a))\nfloat SCurveC2D1(float x) \n{ \n\tfloat x2 = x * x; \n\t\n\t// return x2 * (30.0 * x2 - 60.0 * x + 30.0);\n\treturn x2 * (mad(x2, 30.0, mad(x, -60.0, 30.0)));\n}\n\n// a.xyz: gradient | a.w: value\nvec3 Mul(vec3 a, vec3 b) { return vec3(a.zz * b.xy + a.xy * b.zz, a.z * b.z); }\n        \n\nfloat Sign(float x) {return x < 0.0 ? -1.0 : 1.0;}\n\n\nfloat GNoise(vec2 uv, uvec2 seed)\n{\n    vec2 iuv = floor(uv);\n    vec2 fuv = uv - iuv;\n    \n    vec2 fo = vec2(1.0 - SCurveC2(fuv.x), 1.0 - SCurveC2(fuv.y));   \n\n    float res = 0.0;\n\n    for(float i = 0.0; i < 2.0; ++i)    \n    {\n        for(float j = 0.0; j < 2.0; ++j)    \n        {\n            vec2 vert = vec2(i, j);\n            \n            vec2 vert2 = vert + iuv;\n            \n            float ang = Hash(vert2 * 1.257713 + 0.351831, seed);\n\n            vec2 g = AngToVec(ang * Pi);\n\n            vec2 vec = fuv - vert;\n\n\t\t\tfloat w = abs(i - fo.x) * abs(j - fo.y);\n\t\t\t\t\t\n            float v = dot(vec, g);\n\n            res += w * v;\n        }\n    }\n    \n    return res;\n}\n\nfloat GNoise(vec2 uv, ivec2 cells, uvec2 seed)\n{\n    vec2 iuv = floor(uv);\n    vec2 fuv = uv - vec2(iuv);\n    \n    ivec2 Iuv = ivec2(iuv);\n    \n    vec2 fo = vec2(1.0 - SCurveC2(fuv.x), 1.0 - SCurveC2(fuv.y));\n    \n    float res = 0.0;\n\n    int I, J = 0;\n    for(float i = 0.0; i < 2.0; ++i, ++I)    \n    {\n        for(float j = 0.0; j < 2.0; ++j, ++J)   \n        {\n            vec2 vert = vec2(i, j);\n            \n            ivec2 vert2 = (Iuv + ivec2(I, J)) % cells;\n            vert2.x = vert2.x < 0 ? vert2.x + cells.x : vert2.x;\n            vert2.y = vert2.y < 0 ? vert2.y + cells.y : vert2.y;\n            \n            float ang = Hash(vec2(vert2) * 1.257713 + 0.351831, seed);\n\n            vec2 g = AngToVec(ang * Pi);\n\n            vec2 vec = fuv - vert;\n\n\t\t\tfloat w = abs(i - fo.x) * abs(j - fo.y);\t\t\n            float v = dot(vec, g);\n\n            res += w * v;\n        }\n        \n        J = 0;\n    }\n    \n    return res;\n}\n\nvec3 GNoise2(vec2 uv, ivec2 cells, uvec2 seed)\n{\n    vec2 iuv = floor(uv);\n    vec2 fuv = uv - iuv;\n\n    ivec2 Iuv = ivec2(iuv);\n    \n    vec2 fo = vec2(1.0 - SCurveC2(fuv.x), 1.0 - SCurveC2(fuv.y));\n    vec2 foD = vec2(SCurveC2D1(fuv.x), SCurveC2D1(fuv.y));\n    \n    float aw = 0.0;\n    vec3 res = vec3(0.0);\n\n    int I, J = 0;\n    for(float i = 0.0; i < 2.0; ++i, ++I)    \n    {\n        for(float j = 0.0; j < 2.0; ++j, ++J)    \n        {\n            vec2 vert = vec2(i, j);\n\n            ivec2 vert2 = (Iuv + ivec2(I, J)) % cells;\n            vert2.x = vert2.x < 0 ? vert2.x + cells.x : vert2.x;\n            vert2.y = vert2.y < 0 ? vert2.y + cells.y : vert2.y;\n            \n            float ang = Hash(vec2(vert2) * 1.257713 + 0.351831, seed);\n\n            vec2 g = AngToVec(ang * Pi);\n\n            vec2 vec = fuv - vert;\n\t\t\t\t \n            float v = dot(vec, g);\n\t\t\t\n            vec = 1.0 - abs(vec);\n            \n            res += Mul(vec3(g, v), Mul(vec3(     foD.x * (i * 2.0 - 1.0), 0.0, abs(i - fo.x)),\n                                       vec3(0.0, foD.y * (j * 2.0 - 1.0),      abs(j - fo.y))));\n        }\n        \n        J = 0;\n    }\n\n    return res;\n}\n\nvec3 GNoise2(vec2 uv, uvec2 seed)\n{\n    vec2 iuv = floor(uv);\n    vec2 fuv = uv - iuv;\n\n    vec2 fo = vec2(1.0 - SCurveC2(fuv.x), 1.0 - SCurveC2(fuv.y));\n    vec2 foD = vec2(SCurveC2D1(fuv.x), SCurveC2D1(fuv.y));\n    \n    float aw = 0.0;\n    vec3 res = vec3(0.0);\n\n    for(float i = 0.0; i < 2.0; ++i)    \n    {\n        for(float j = 0.0; j < 2.0; ++j)    \n        {\n            vec2 vert = vec2(i, j);\n            \n            float ang = Hash((vert + iuv) * 1.257713 + 0.351831, seed);\n\n            vec2 g = AngToVec(ang * Pi);\n\n            vec2 vec = fuv - vert;\n\t\t\t\t \n            float v = dot(vec, g);\n\t\t\t\n            vec = 1.0 - abs(vec);\n            \n            res += Mul(vec3(g, v), Mul(vec3(     foD.x * (i * 2.0 - 1.0), 0.0, abs(i - fo.x)),\n                                       vec3(0.0, foD.y * (j * 2.0 - 1.0),      abs(j - fo.y))));\n        }\n    }\n\n    return res;\n}\n\nfloat GNoise(vec2 uv) { return GNoise(uv, uvec2(0x0D66487Cu, 0x9A19276Bu)); }\nfloat GNoise(vec2 uv, ivec2 cells) { return GNoise(uv, cells, uvec2(0x0D66487Cu, 0x9A19276Bu)); }\n\nvec3 GNoise2(vec2 uv) { return GNoise2(uv, uvec2(0x0D66487Cu, 0x9A19276Bu)); }\nvec3 GNoise2(vec2 uv, ivec2 cells) { return GNoise2(uv, cells, uvec2(0x0D66487Cu, 0x9A19276Bu)); }\n\n\nfloat Fbm(vec2 uv, uvec2 seed)\n{\n    const float count = 8.0;\n    \n    float res = 0.0;\n    float accu_w = 0.0;\n    float w = 1.0;\n    //float rs = 0.2;\n    \n    for(float i = 0.0; i < count; ++i)\n    {\n        vec2 off = vec2(HashFlt(seed.x, 0xE263C49Cu), HashFlt(seed.y, 0x786D0D5Fu)); \n        \n        float v = GNoise(uv + off, seed);\n        \n        res += v * w;\n        \n        accu_w += w;\n        \n      \n        w *= 0.45;\n        uv *= 2.0;\n        \n        seed.x = GMXorShift(seed.x);\n        seed.y = GMXorShift(seed.y);        \n    }\n    \n    res /= accu_w;\n    \n    return res;\n}\n\n\nfloat EvalNoise(vec2 uv)\n{\n    uvec2 seed = uvec2(0xCFD58FE0u, 0xCC0AC93Bu);\n    \n    #if 0\n    float v = GNoise(uv, seed);\n\t#else\n    float v = Fbm(uv, seed);\n    #endif\n    \n    return v*.5+.5;\n}\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{     \n    vec2 uv = uv0.xy - 0.5;\n\tvec2 tex = uv0.xy / PixelCount;\n    vec2 tex21 = tex * 2.0 - vec2(1.0);\n      \n\n    uv *= 0.02;\n  \n    #if 1\n    float o = 0.0001;\n    outCol = vec4(\n        (GNoise(uv + vec2(o, 0.0)) - GNoise(uv - vec2(o, 0.0))) / (2.0 * o), \n        (GNoise(uv + vec2(0.0, o)) - GNoise(uv - vec2(0.0, o))) / (2.0 * o), 0.0, 1.0);\n    #endif\n    \n    outCol = vec4(GNoise2(uv, ivec2(8)).xy, 0.0, 1.0);\nreturn;\n    \n    outCol = vec4(GNoise(uv));\n    \n    float v = GNoise(uv) * GNoise(uv + vec2(0.5), uvec2(0x61043D72u, 0xFE817952u)) * 0.5 + 0.5;\n    \n    v = SCurveC2(v);\n    v = SCurveC2(v);\n\n    v = GNoise(uv - vec2(4.0), ivec2(3));\n    v = GNoise(uv - vec2(4.0));\n    \n    //v = float(int(uv.x - 4.0)) * 0.1;\n    //v = EvalNoise(uv);\n    \n    outCol = vec4(v);\n    \t\n    \n    #if 0   \n    float plotH = 100.0;\n    \n    if(uv.y > PixelCount.y - plotH)\n    {\n        float v = 0.0;\n        \n        vec2 texP = vec2(uv.x, uv.y - (PixelCount.y - plotH)) / plotH;\n    \n        //v = EvalNoise(vec2(texP.x, 0.0)) - texP.y > 0.0 ? 1.0 : 0.0; \n        v = GraphMask2(EvalNoise(vec2(texP.x, 0.0)) - texP.y);\n\n        outCol = vec4(v);\n    }\n    #endif\n}\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}