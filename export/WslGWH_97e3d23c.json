{"ver":"0.1","info":{"id":"WslGWH","date":"1546034654","viewed":377,"name":"Ball of fuzz","username":"slimyfrog","description":"Playing with displacement using textures.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["displacement","texture","fur","uvanim"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DISTANCE  30.0\n#define MIN_DISTANCE   0.00001\n\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nfloat sphereDf(vec3 p, vec3 spherePos, float radius, out vec3 color)\n{    \n    vec2 uv = vec2(p.x + iTime * 0.2, p.y);\n    vec3 displacement = vec3(texture(iChannel0, uv));\n    \n    color.r = texture(iChannel0, uv * 0.4).x;\n    color.g = texture(iChannel1, uv * 0.15).x;\n    color.b = texture(iChannel2, uv).x;\n    \n    float dist =  length(spherePos + p) - radius;\n    dist += dot(displacement, displacement) * (sin(iTime) * 0.2);\n    return dist;\n}\n\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nfloat sceneDf(vec3 p, out vec3 color)\n{\n    //sphere position\n    vec3 spherePosition = vec3(0, 0, 0);\n    float dist = sphereDf(p, spherePosition, 2.0, color);\n    return dist;\n}\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nvec3 calcNormal(vec3 p)\n{\n    float e = 0.3;\n    \n    vec3 normal;\n    vec3 i;\n    normal.x = sceneDf(vec3(p.x + e,p.y,p.z), i) - sceneDf(vec3(p.x - e, p.y, p.z), i);\n    normal.y = sceneDf(vec3(p.x,p.y + e,p.z), i) - sceneDf(vec3(p.x, p.y - e, p.z), i);\n    normal.z = sceneDf(vec3(p.x,p.y,p.z + e), i) - sceneDf(vec3(p.x, p.y, p.z - e), i);\n    \n    return normalize(normal);\n}\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nvec3 processLighting(vec3 baseColor, vec3 eyePos, vec3 surfacePoint)\n{\n    vec3 diffuseDir = normalize(vec3(-1,0, -1));\n    \n    vec3 normal = calcNormal(surfacePoint);\n    float diffDot = max(dot(-diffuseDir, normal), 0.0);\n    return  0.1 + vec3(diffDot) * baseColor;\n}\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nvec3 marchRay(vec3 eyePos,vec3 dir)\n{\n    vec3 color = vec3(0);\n    vec3 currentPoint = eyePos;\n    while(length(currentPoint) < MAX_DISTANCE)\n    {\n        float intensity;\n        vec3 sceneCol;\n        float dist = sceneDf(currentPoint, sceneCol);\n        if(dist <= MIN_DISTANCE)\n        {\n            color = processLighting(sceneCol, eyePos, currentPoint);\n            break;\n        }\n        currentPoint += (dist * dir);\n    }\n    return color;\n}\n\n\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera\t\n\tvec3 eye = vec3(0.0, 0.0, 6.0 );\n    vec3 lookat = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 forward = normalize( lookat - eye );\n    vec3 right = normalize( cross(forward,vec3(0.0,1.0,0.0) ) );\n    vec3 up = normalize( cross(right, forward));\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    // create view ray\n    vec3 dir = normalize( p.x*right + p.y*up + 2.5*forward );\n       \n    vec3 color = marchRay(eye, dir);\n    \n    fragColor = vec4(color,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}