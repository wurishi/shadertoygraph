{"ver":"0.1","info":{"id":"Dtffzf","date":"1693245787","viewed":66,"name":"infinite 3d plinko","username":"Amita","description":"balls colliding","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarching","infinite"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592653589793\n\n// number of steps before raymarching gives up\n#define ITER 700\n\n// distance raymarching considers close enough\n#define THRESHOLD 0.01\n\n// how light full shadows are\n#define FULLDARK 0.2\n\n// camera distance to tracked ball\n#define SCALE 0.5\n\n// FOV in arbitrary units\n#define FOV 1.0\n\n// direction where the light comes from\nconst vec3 lightDir = vec3(3.0,-12.0,4.0)/13.0;\n\n// color of the tracked ball\nconst vec3 playerColor = vec3(1.0,0.8,0.8);\n\n// color of the infinitely repeating balls\nconst vec3 obstaColor  = vec3(0.8,1.0,0.8);\n\n\nmat3 curRot() {\n    vec2 angle = PI*vec2(2.0*iMouse.x/iResolution.x - 1.0, iMouse.y/iResolution.y - 0.5);\n    return mat3(\\\n        1.0,     0.0    ,     0.0     ,\\\n        0.0,cos(angle.y),-sin(angle.y),\\\n        0.0,sin(angle.y), cos(angle.y) \\\n      )*mat3(\\\n        cos(angle.x),0.0,-sin(angle.x),\\\n            0.0     ,1.0,       0.0   ,\\\n        sin(angle.x),0.0, cos(angle.x)); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { \n    vec3 origin = texelFetch(iChannel0, ivec2(0,0), 0).xyz*UNIT;\n    \n    vec3 dir = -vec3((fragCoord - iResolution.xy/2.0)*FOV/iResolution.y,1.0)*curRot()*SCALE;\n    vec3 pos = origin + dir;\n    dir = normalize(dir + vec3(0.0,0.0,2.0*SCALE)*curRot());\n    \n    for (int i = 0; i < ITER; i++) {\n        vec3 player = texelFetch(iChannel0, ivec2(0,0), 0).xyz*UNIT;\n        vec3 distPlayer = toPlayer(pos,player);\n        vec3 distObstac = closeObstacle(pos);\n        float dist = min(length(distPlayer),length(distObstac));\n        \n        if (dist < THRESHOLD) {\n            if (length(distPlayer) < length(distObstac)) {\n                float reflection = dot(reflect(dir,normalize(distPlayer)), lightDir)*0.5 + 0.5;\n                fragColor = vec4(playerColor*(FULLDARK + (1.0-FULLDARK)*reflection*reflection),1.0);\n            } else {\n                float reflection = dot(reflect(dir,normalize(distObstac)), lightDir)*0.5 + 0.5;\n                fragColor = vec4(obstaColor*(FULLDARK + (1.0-FULLDARK)*reflection*reflection),1.0);\n            }\n            return;\n        } else {\n            pos += dir*dist;\n        }\n    }\n    fragColor = vec4(0.2,0.7,0.9,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// size (m) of the repetition cell = distance between two neighboring balls out of the infinite balls\n#define UNIT 2.0\n\n// size of the infinite obstacle balls\n#define ORADIUS 0.6\n\n// size of the ball you follow\n#define PRADIUS 0.2 \n\n// difference between maximum negative speed and maximum positive speed (m/s) in an axis\n#define SPEEDAMPLIT 20.0\n// for SPEEDAMPLIT == 20.0, the set of all possible speeds is [-SPEEDAMPLIT/2, SPEEDAMPLIT/2]\n\n\nvec3 toOriginCell(vec3 x) {\n    return mod(mod(x,UNIT) + vec3(UNIT),UNIT);\n}\n\nvec3 closeObstacleCenter(vec3 x) {\n    return toOriginCell(x) - vec3(UNIT/2.0);\n}\n\nvec3 closeObstacle(vec3 x) {\n    vec3 y = closeObstacleCenter(x);\n    return y*(1.0 - ORADIUS/length(y));\n}\n\n\n\nvec3 toPlayer(vec3 x,vec3 plPos) {\n    vec3 y = x - plPos;\n    return y*(1.0 - PRADIUS/length(y));\n}\n\n//bijection [0,1]³ <-> [-SPEEDLIMIT/2,SPEEDLIMIT/2]³\n\nvec3 recover(vec3 x) {\n    return (x - vec3(0.5))*SPEEDAMPLIT;\n}\n\nvec3 store(vec3 x) {\n    return clamp(x/SPEEDAMPLIT + vec3(0.5),vec3(0.0),vec3(1.0));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// gravity (m/s²)\n#define GRAV 3.0\n\n// how much momentum is conserved on collisions (always positive and preferrably lower than 1.0)\n#define COLCONST 1.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 lastColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if (lastColor.w == 0.0) {\n        if (fragCoord.x < 1.0 && fragCoord.y < 1.0) {\n            fragColor = vec4(0.0,0.0,0.0,1.0);\n        } else {\n            fragColor = vec4(0.4,0.3,0.48,1.0);\n        }\n    } else if (fragCoord.x < 1.0 && fragCoord.y < 1.0) {\n        //position\n        vec4 sadf = texelFetch(iChannel0, ivec2(1,0), 0);\n        vec3 speed = recover(sadf.xyz);\n        vec3 curPos = lastColor.xyz*UNIT;\n        vec3 dist = closeObstacleCenter(curPos);\n        if (length(dist) <= ORADIUS + PRADIUS) {\n            //collision\n            vec3 normal = normalize(dist);\n            curPos = vec3(UNIT/2.0) + normal*(ORADIUS+PRADIUS);\n            speed -= COLCONST*normal*dot(speed,normal);\n            fragColor = vec4(toOriginCell(curPos + speed*iTimeDelta)/UNIT,0.5);\n        } else {\n            fragColor = vec4(toOriginCell(curPos + speed*iTimeDelta)/UNIT,(sadf.w == 0.5 ? 1.0 : lastColor.w));\n        }\n    } else if (fragCoord.x < 2.0 && fragCoord.y < 1.0) {\n        //velocity\n        vec3 speed = recover(lastColor.xyz) + vec3(0.0,GRAV*iTimeDelta,0.0);\n        vec4 curPos = texelFetch(iChannel0, ivec2(0,0), 0);\n        if (curPos.w == 0.5 && dot(curPos.xyz - vec3(0.5), speed) < 0.0) {\n            vec3 normal = normalize(curPos.xyz - vec3(0.5));\n            speed -= COLCONST*2.0*normal*dot(speed,normal);\n        } \n        fragColor = vec4(store(speed),curPos.w);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}