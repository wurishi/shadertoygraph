{"ver":"0.1","info":{"id":"M3X3DN","date":"1712050555","viewed":27,"name":"3D Red Sphere","username":"Samuix","description":"Displaying 3D Red Sphere with light source and blue glowing and shader light in dark bg","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["lightingeffects"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// We can define a structure that will contain the parameters needed\n// by an object to specify its shading according to Phong shading.\nstruct Material\n{\n    float Ka;   // ambiant        coefficient\n    float Kd;   // diffuse        coefficient\n    float Ks;   // specular       coefficient\n    float Kn;   // specular power coefficient\n};\n\n\nfloat ratio = 300.0;\nfloat depth = 1.0;\n    // ~ ~ ~ ~ ~ ~ ~ ~ \n        \n// Camera parameters\nconst vec3      cameraPos    = vec3(6,  4, -5);\n//const vec3     cameraPos    = vec3(3,  2, -3);\nconst vec3      cameraTarget = vec3(3,  1, -8);\nconst float     cameraFovY   = 80.0;             // NOTE: angle in degree\n\n// Sphere parameters\nconst vec3 offsetCam = vec3(0, 1, 2);\nconst vec3      spherePos    = cameraTarget + offsetCam;\nconst float     sphereRadius = 1.0;\nconst vec3      sphereCol    = vec3(1,0,0);       // red\nconst Material  sphereMat    = Material(0.2/*Ka*/, 0.7/*Kd*/, 1.0/*Ks*/, 51.0/*Kn*/);\n\n// Light(s) parameters\nconst vec3      ambiantCol   = vec3(0,0,1);      // blue\nconst vec3      lightCol     = vec3(1,1,1);      // white\nvec3            lightPos     = vec3(8, 10, -12);\n\n//##############################################################################################\n\nfloat raySphere( vec3 rayPos ,vec3 rayDir, vec3 spherePos, float sphereRadius, out vec3 intersecPt, out vec3 normal)\n{\n    float I = 0.0;\n\n    //vec3 CA = rayPos - spherePos;\n    vec3 AC = spherePos - rayPos;\n\n\n    // R² - ((AC.AC) - v²)\n    // v² = dot(CA,rayDir)*dot(CA,rayDir)\n    \n    float V = dot(AC,rayDir);\n    float disc = sphereRadius * sphereRadius - (dot(AC,AC) - V*V);\n    \n    if(disc >= 0.0)\n    {\n        float d = sqrt(disc);\n        intersecPt = rayPos + (V - d)*rayDir;\n        normal = normalize(intersecPt - spherePos);\n\n    }\n    \n    return disc;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvoid computeCameraRayFromPixel( in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir)\n{\n    //axes of the camera\n    vec3 cz = normalize(cameraPos - cameraTarget); // camera looking at, on the z axe so -> its the z axe for the rayDir\n    vec3 cx = normalize(cross(cz,vec3(0,1,0))); // X axe determined by a temporary axe and cross product\n    vec3 cy = normalize(cross(cz,cx)); // Y axe calculed by cross product\n    \n    // focal distance\n    float f = depth/(tan(cameraFovY/2.0));\n    \n    // rayPos -> where the ray start (from the cam)\n    rayPos = cameraPos; // from where the ray starts\n\n   // pixCoord = vec2(f*pixCoord.x/,f*pixCoord.y)\n    //rayDirpixCoord\n    vec3 PO = f*cz;\n    vec3 OS = pixCoord.x*cx - pixCoord.y*cy;\n    \n    rayDir = normalize(PO + OS);\n}\n\n//----------------------------------------------------------------------------------------------\n\nvec3 computePhongShading(vec3 objectCol, Material objectMat, vec3 N, vec3 L, vec3 R, vec3 V)\n{\n    vec3 Ia = ambiantCol * objectMat.Ka;\n    vec3 Id = lightCol * objectCol * objectMat.Kd * max(dot(L,N),0.0);\n    vec3 Is = lightCol * objectMat.Ks * pow(max(dot(R,V),0.0),objectMat.Kn);\n    //vec3 Is = vec3(0.,0.,0.);\n\n    vec3 I = Ia + Id + Is;\n    \n    return I;\n}\n\n//##############################################################################################\n//##############################################################################################\n\nvec2 apply_transform(vec2 point)\n{\n    //return vec2((iResolution.x/2.0 - point.x)/ratio, (iResolution.y/2.0 - point.y)/ratio);\n    return vec2((iResolution.x/2.0 - point.x)/iResolution.y, (iResolution.y/2.0 - point.y)/iResolution.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    lightPos.z = cameraPos.x + apply_transform(iMouse.xy).x*iResolution.y;\n    lightPos.y = cameraPos.y + apply_transform(iMouse.xy).y*iResolution.y;\n\n    fragCoord = apply_transform(fragCoord.xy);\n    // Compute the ray to be casted through the pixel towards the 3D scene\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(fragCoord, rayPos, rayDir);\n    \n    // Test ray-sphere intersection and get the intersection point and associated normal\n    vec3 intersecS, normalS;\n    float distS = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    \n    // Apply the shading to the points that are on the sphere surface and seen by the camera\n    if (distS > 0.0)\n    {\n        // unit-vector going from the surface point toward the light\n        vec3 L = normalize(lightPos - intersecS);\n        \n        // unit-vector of the reflection direction of the light at the surface point\n        vec3 R = normalize(2.0 * normalS * dot(normalS, L) - L);\n        \n        // unit-vector going from the surface point toward the camera \n        vec3 V = -normalize(rayDir);\n        \n        // Apply the Phong shading to compute the color\n        // of the surface point as seen from the camera\n        fragColor = vec4(computePhongShading(sphereCol, sphereMat, normalS, L, R, V), 1);\n        //fragColor = vec4(1, 0, 0, 1);\n\n    }\n    else    // We did not hit the sphere, so we have the sky color (here: black)\n        fragColor = vec4(0,0,0, 1);\n    //fragColor = vec4((distS > 0.0 ? 1.0 : 0.0), 0, 0, 1);\n\n}\n","name":"Image","description":"","type":"image"}]}