{"ver":"0.1","info":{"id":"Xdlyz4","date":"1487279541","viewed":222,"name":"Turmites","username":"pixartist","description":"A turmite with multiple steps per frame, making use of the new webGL2 features. \nMultiple states and colors can be set.\nPaint additional ants with the mouse","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["turmite","glsl3"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int R = 3;\nconst int W = 2*R+1;\nconst int S = W*W;\nconst int M = S/2;\n\nconst int STATES = 1;\nconst int COLORS = 2;\n\n#define COLOR(c) clamp(int(c.x), 0, COLORS-1)\n#define ISTERMITE(c) c.y > 0.0\n#define STATE(c) clamp(int(c.y)-1,0,STATES-1)\n#define ROTATION(c) int(c.z)\n#define TURN(c, r) c.z = mod(c.z+float(r),4.0)\n#define FLIP(c, cn) c.x = float(cn);\n#define SWITCH(c, s) c.y = float(s+1);\n\nconst ivec2 DIR[] = ivec2[] (ivec2(0,1), ivec2(1,0), ivec2(0,-1), ivec2(-1,0));\n\n\nstruct Change\n{\n    int state;\n    int color;\n    int rotation;\n};\nstruct ColorChange\n{\n    Change color[COLORS];\n};\nColorChange state[STATES];\n\nvoid rules()\n{\n    state[0].color[0].state = 0;\n    state[0].color[0].color = 1;\n    state[0].color[0].rotation = 1;\n    \n    state[0].color[1].state = 0;\n    state[0].color[1].color = 0;\n    state[0].color[1].rotation = -1;\n}\nbool getIndex(int x, int y, out int index)\n{\n    index = (x+R) + (y+R)*W;\n    return abs(x) <= R && abs(y) <= R;\n}\nbool getIndex(ivec2 p, out int index)\n{\n    index = (p.x+R) + (p.y+R)*W;\n    return abs(p.x) <= R && abs(p.y) <= R;\n}\nivec2 getCoord(int index)\n{\n    return ivec2(index%W - R, index/W - R);\n}\n\nbool readField(vec2 fragCoord, out vec4[S] field, out int[R*R] ants, out int c)\n{\n    bool found = false;\n    int lim = R*R;\n    c = 0;\n    for(int x = -R; x <= R; x++)\n    {\n        for(int y = -R; y <= R; y++)\n        {\n            if(x*x+y*y <= lim)\n            {\n                vec4 col = texelFetch(iChannel0, ivec2(mod(fragCoord+vec2(x,y), iResolution.xy)), 0);\n                int index;\n                getIndex(x,y, index); \n                field[index] = col;\n                if(ISTERMITE(col))\n                {\n                    ants[c] = index;\n                    c++;\n                    found = true;\n                }\n            }   \n        }\n    }\n    return found;\n}\nvoid play(inout vec4[S] field, int[R*R] ants, int c)\n{\n    bool valid[R*R];\n    for(int i = 0; i < c; i++)\n    \tvalid[i] = true;\n    for(int i = 0 ; i < R; i++)\n    {\n        for(int k = 0; k < c; k++)\n        {\n            if(valid[k])\n            {\n                vec4 f = field[ants[k]];\n                if(ISTERMITE(f))\n                {\n                    Change newState = state[STATE(f)].color[COLOR(f)];\n                    TURN(f, newState.rotation);\n                    FLIP(f, newState.color);\n                    SWITCH(f, newState.state);\n                    int nextIndex;\n                    valid[k] = getIndex(getCoord(ants[k]) + DIR[ROTATION(f)], nextIndex);\n\n                    if(valid[k])\n                    {\n\n                        field[nextIndex].y = f.y;\n                        field[nextIndex].z = f.z;\n                        f.y = 0.0;\n                        f.z = 0.0;\n                        field[ants[k]] = f;\n                    }\n                    ants[k] = nextIndex;\n                }\n                else\n                {\n                    valid[k] = false;\n                }\n            }\n        }\n    }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    rules();\n   \tint i;\n    int[R*R] ants;\n    int c;\n    vec4[S] field;\n    if(readField(fragCoord, field, ants, c))\n    {\n   \t\tplay(field, ants, c);\n        //field[M] = vec4(1.0);\n    }\n    \n    if((iFrame < 1 && distance(floor(fragCoord), floor(iResolution.xy * 0.5)) < .5) ||\n       (iMouse.z > 0.0 && distance(iMouse.xy, floor(fragCoord)) < 0.5))\n    {\n        field[M].y = 1.0;\n    }\n       \n    fragColor = field[M];\n}","name":"Buf A","description":"","type":"buffer"}]}