{"ver":"0.1","info":{"id":"ldc3D2","date":"1452562523","viewed":253,"name":"BDRF practice","username":"hypothete","description":"Familiarizing myself with BDRF","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","bdrf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define minStep 1.\n#define maxStep 10.0\n#define delta 0.01\n#define damping 0.9\n#define numSteps 100\n\nstruct camera {\n    vec3 position;\n    vec3 direction;\n};\n    \nstruct pointLight {\n\tvec3 position;\n    float intensity;\n    vec3 color;\n};\n\nconst vec3 worldUp = vec3(0.0,1.0,0.0);\n\n\nmat3 getViewMatrix (vec3 t, vec3 d, vec3 k) // position, direction, worldUp\n{\n\tvec3 z = normalize(d);\n    vec3 x = normalize(cross(d,k));\n    vec3 y = -normalize(cross(z,x));\n    return mat3(x,y,z);\n}\n\nfloat sdSphere( vec3 p, float s ) //sphere distf\n{\n  return length(p)-s;\n}\n\nfloat distf (vec3 pos) //scene distance function\n{\n    vec3 spherePos = vec3(sin(iTime),0,cos(iTime));\n    float dist = sdSphere(pos + spherePos,1.);\n\treturn dist;\n}\n\nvec3 normal (vec3 p) //borrowed from https://www.shadertoy.com/view/ltfXDM\n{\n    vec2 h = vec2(delta, -delta);\n\treturn normalize (\n\t\th.xxx * distf(p + h.xxx) +\n\t\th.xyy * distf(p + h.xyy) +\n\t\th.yxy * distf(p + h.yxy) +\n\t\th.yyx * distf(p + h.yyx)\n\t);\n}\n\nfloat castRay ( vec3 pos, vec3 dir, out vec3 norm)\n{\n    float dist = minStep;\n    for(int step = 0; step < numSteps; step++)\n    {\n        norm = pos + dir*dist;\n        float normL = distf(norm);\n        if(normL > delta || dist > maxStep){\n            dist += normL*damping;\n        }\n    }\n    return dist;\n}\n\nfloat lum (vec3 rgb){\n\treturn 0.2126*rgb.r + 0.7152*rgb.g + 0.0722*rgb.b;\n}\n\nvec4 texInterp(samplerCube tx1, samplerCube tx2, vec3 st, float x){\n\treturn mix(texture(tx1, st), texture(tx2, st),smoothstep(0., 1., x));\n}\n\n\nvec4 render(in vec2 xy)\n{\n    camera myCam = camera( \n    \tvec3(0,0.,-3.),\n    \tvec3( 3.14*(2.*iMouse.x/iResolution.x - 1.), -(2.*iMouse.y/iResolution.y - 1.), 1.0)\n\t);\n    vec3 spherePos = vec3(sin(iTime),0,cos(iTime));\n    \n    //BDRF stuff adapted from http://ruh.li/GraphicsCookTorrance.html\n    float roughness = 0.2;\n    float f0 = 1.2; //dilectric fresnel\n    float k = 0.9; //diffuse reflection strength\n    float specular = 0.6;\n    vec3 diffuseColor = vec3(0.8,0.4,0.4);\n    \n    //camera\n    mat3 viewMatrix = getViewMatrix(myCam.position, myCam.direction, worldUp);\n\tvec3 rayDir = viewMatrix * normalize(vec3(xy, 1.0));\n    vec3 ro = vec3(0.0,0.0,0.0);\n    vec4 colToRtn = vec4(0,0,1.,1.);\n    float histDistanceFunction = castRay(myCam.position, rayDir, ro);\n    vec3 nml = normal(ro);\n    \n    //more BDRF\n    vec3 lightDir = vec3(0,1.,-0.6);// normalize(ro+spherePos) ;\n    float NdotL = max(dot(nml, lightDir),0.);\n    \n    //reflected light from envMap - working toward IBL\n    vec4 rLight = vec4(1.);\n    //rLight = textureLodEXT(iChannel1, reflect(rayDir,nml), 100.0);\n    float rLightIntensity = lum(rLight.xyz);\n    \n    if(NdotL > 0.){\n        vec3 eyeDir = -normalize(rayDir);\n        vec3 halfVector = normalize(lightDir+eyeDir);\n    \tfloat NdotH = max(dot(nml,halfVector),0.);\n        float NdotV = max(dot(nml,eyeDir),0.);\n        float VdotH = max(dot(eyeDir, halfVector),0.);\n        float mSquared = roughness * roughness;\n        \n        //geometric attenuation\n        float NH2 = 2. * NdotH;\n        float g1 = (NH2 * NdotV) / VdotH;\n        float g2 = (NH2 * NdotL) / VdotH;\n        float geoAtt = min(1., min(g1, g2));\n        \n        //roughness\n        float r1 = 1. / (4. * mSquared * pow(NdotH, 4.));\n        float r2 = (NdotH * NdotH - 1.) / (mSquared * NdotH * NdotH);\n        float finalRough =  r1 * exp(r2);\n        \n        //fresnel\n        float fresnel = pow(1. - VdotH, 5.);\n        fresnel *= 1. - f0;\n        fresnel += f0;\n        \n        specular = (fresnel * geoAtt * finalRough) / (NdotV * NdotL * 3.14); \n    }\n    \n    vec3 finalBDRF = diffuseColor * rLight.xyz * rLightIntensity * NdotL * (k + specular * (1. - k));\n    \n    //choose which sampler we use based on our distf result\n    if(histDistanceFunction < maxStep){\n        \n\t\tcolToRtn.xyz = finalBDRF;\n    }\n    else{\n        colToRtn = texture(iChannel0, rayDir);\n    }\n    return colToRtn;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    fragColor = render(uv);\n}","name":"","description":"","type":"image"}]}