{"ver":"0.1","info":{"id":"3tK3zt","date":"1593964220","viewed":209,"name":"VctrPortrait","username":"kvick","description":"portrait, unfinished, may never finish :|","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["portrait"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358979\n\n//--------------------------------------------------------------------------------\n//  1 out, 1 in...\n#define HASHSCALE .1031\nfloat Hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//--------------------------------------------------------------------------------\nfloat Linear(float x, float v0, float v1) \n{\n\treturn (v1-v0)*x + v0;\n}\n\nfloat Line(vec2 st, vec2 a, vec2 b, float w)\n{\n \tvec2 ab = b - a;\n    vec2 aToST = st - a;\n    float t = clamp(dot(aToST, ab) / dot(ab, ab), 0., 1.);\n    float d = length(aToST - ab * t) - w * 0.5;\n    return d;\n}\n\nfloat distToLine(vec2 st, vec2 a, vec2 b)\n{\n\tvec2 ab = b - a;\n    vec2 aToST = st - a;\n    float t = clamp(dot(ab, aToST) / dot(ab, ab), 0., 1.);\n    float d = length(a + ab * t - st);\n    \n    //doing some fudging to achieve the falloff line look for vectrex\n    //d /= t * 1.;\n    \n    return d;\n}\n\nfloat getLine(vec2 st, vec2 start, vec2 end)\n{\n    float jitterIntensity = 0.001;\n    float jitter = Hash(sin(iTime * 250.)) * jitterIntensity;\n    \n    float f = 0.;\n    float dist2Line = distToLine(st, start, end) + jitter;\n    \n    f = (0.01 / (dist2Line));\n    \n    f *= 0.1;\n    \n    return clamp(f, 0., 1.);\n}\n\nvec3 rotX(vec3 b, float d)\n{\n    mat3 A = mat3(\n        cos(d),\t-sin(d), \t0.,\n        sin(d), cos(d), \t0.,\n        0., \t1., \t\t0.\n        );\n    \n    vec3 result = (A * b);\n    return result;\n}\n\nvec3 rotY(vec3 b, float d)\n{\n    mat3 A = mat3(\n        cos(d), \t\t0., \tsin(d), \n        0., \t\t\t1., \t0., \n        -sin(d), \t\t0., \tcos(d)\n        );\n    \n    vec3 result = (A * b);\n    return result;\n}\n\nvec3 rotZ(vec3 b, float d)\n{\n    mat3 A = mat3(\n        0., \t1., \t\t0.,\n        0.,\t\tcos(d),\t\tsin(d),\n        0.,\t\t-sin(d), \tcos(d)\n        );\n    \n    vec3 result = (A * b);\n    return result;\n}\n\nvec2 pToS(vec3 p)\n{\n    vec3 pCenter = vec3(-0., 0., 1.0);\n    p += pCenter;\n    \n    return vec2(p.x / p.z, p.y / p.z);\n}\n\nvec3 face(vec2 st)\n{\n    vec3 color = vec3(0.);\n    float flipOver = 5.;\n    float viewAngle = iMouse.x * 0.001;mod(iTime * 0.1, flipOver) - (flipOver * 0.5);\n    vec3 hillColor = vec3(0.5, 0., 0.);\n    //Horizon\n    color += hillColor * getLine(vec2(st.x, st.y), vec2(-1., 0.0), vec2(1., 0.0));\n    return color;\n}\n\n#define cp(a) (a), (a+1),\n#define ep(a) (a), (a+1)\n\n//================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n\tuv.x *= aspect;\n\tvec2 st = uv;\n    st -= vec2(0.5 * aspect, 0.5);\n    \n\tfloat f;\n    \n    float iTime = iTime * 1.0;\n    vec3 color = vec3(0.);\n    \n    const int kPointCount = 28;\n    vec3[kPointCount] p = vec3[kPointCount](\n        //Face\n        \n        (vec3(-0.09,  0.28, 0)), // forehead\n        (vec3(-0.115,  0.175, 0)), // brow\n        (vec3(-0.109,  0.135, 0)), // bridge\n        (vec3(-0.095,  0.135, 0)),\n        (vec3(-0.109,  0.135, 0)), // bridge\n        (vec3(-0.175,  0.0, 0)), //nose tip\n    \t(vec3(-0.155,  -0.02, 0)), //nose tip lower\n        (vec3(-0.105,  -0.025, 0)), //nose base\n        (vec3(-0.101,  -0.048 , 0)), \n        (vec3(-0.110,  -0.10, 0)), //lip tip\n        (vec3(-0.090,  -0.11, 0)), //lip middle\n        (vec3(-0.070,  -0.119, 0)), //lip middle deep\n        (vec3(-0.090,  -0.11, 0)), //lip middle\n        (vec3(-0.100,  -0.125, 0)), //lip bottom\n        (vec3(-0.080,  -0.138, 0)), \n        (vec3(-0.085,  -0.19, 0)), //chin\n        (vec3(-0.045,  -0.21, 0)),\n        (vec3(0.06,  -0.2, 0)), //neck top\n        (vec3(0.1,  -0.32, 0)), //neck bottom\n        (vec3(0.225,  -0.26, 0)), //neck back\n        \n        //Hair\n        (vec3(0.3,  -0.4, 0)),\n        (vec3(0.5,  -0.5, 0)),\n        (vec3(0.6,  0.0, 0)),\n        (vec3(0.3,  0.4, 0)),\n        (vec3(-0.1,  0.4, 0)),\n        (vec3(-0.15,  0.3, 0)),\n        (vec3(-0.05,  0.3, 0)),\n        (vec3(0.3,  -0.4, 0))\n    );\n    \n    int edgeCounter = 0;\n    const int k_edgeMax = (kPointCount - 1) * 2;\n    const int k_lineCount = k_edgeMax / 2;\n    int[k_edgeMax] edges;\n    for (int n = 0; n < k_lineCount; n++) //Draw a continual line\n    {\n\t\tedges[edgeCounter] = edgeCounter - n;  edgeCounter++;\n        edges[edgeCounter] = edgeCounter - n;  edgeCounter++;\n    }\n    \n    /*\n\tedges[edgeCounter] = edgeCounter - 0;edgeCounter++;edges[edgeCounter] = edgeCounter - 0 ;edgeCounter++;lineCounter++;\n\tedges[edgeCounter] = edgeCounter - 1;edgeCounter++;edges[edgeCounter] = edgeCounter - 1 ;edgeCounter++;lineCounter++;\n    edges[edgeCounter] = edgeCounter - 2;edgeCounter++;edges[edgeCounter] = edgeCounter - 2 ;edgeCounter++;lineCounter++;\n    edges[edgeCounter] = edgeCounter - 3;edgeCounter++;edges[edgeCounter] = edgeCounter - 3 ;edgeCounter++;lineCounter++;\n\t*/\n        \n    //edges[edgeCounter] = edgeCounter;edges[edgeCounter + 1] = edgeCounter + 1;edgeCounter++;\n    //Face\n        //cp(0)cp(1)cp(2)cp(3)cp(4)cp(5)cp(6)cp(7)cp(8)cp(9)cp(10)cp(11)cp(12)cp(13)cp(14)cp(15)cp(16)cp(17)cp(18)cp(19)\n        //cp(20)cp(21)cp(22)cp(23)cp(24)cp(25)cp(26)cp(27)\n        //ep(k_edgeMax - 1)\n        \n        //Hair\n    \n    /*\n    const int k_edgeMax = (kPointCount - 1) * 2;\n    int[] edges = int[](\n        //Face\n        cp(0)cp(1)cp(2)cp(3)cp(4)cp(5)cp(6)cp(7)cp(8)cp(9)cp(10)cp(11)cp(12)cp(13)cp(14)cp(15)cp(16)cp(17)cp(18)cp(19)\n        cp(20)cp(21)cp(22)cp(23)cp(24)cp(25)cp(26)cp(27)\n        ep(k_edgeMax - 1)\n        \n        //Hair\n    );\n\t*/\n    \n    vec2[kPointCount] p_;\n    for (int i = 0 ; i < kPointCount; ++i)\n    {\n        p_[i] = pToS(p[i]);\n    }\n    \n    \n    for (int i = 0; i < k_edgeMax; i += 2)\n    {\n        const float jitterIntensity = 0.003;//pow(sin(iTime), 3.);\n        const float halfJitter = jitterIntensity * 0.5;\n        vec2 randPointA = vec2(Hash(iTime + float(i + 34)), Hash(iTime + float(i + 3424))) * jitterIntensity - halfJitter;\n        vec2 randPointB = vec2(Hash(iTime + float(i * 2 + 34)), Hash(iTime + float(i * 24))) * jitterIntensity - halfJitter;\n        \n        vec2 pointA = p_[edges[i]] + randPointA;\n        vec2 pointB = p_[edges[i + 1]] + randPointB;\n        \n        f += getLine(st, pointA, pointB);\n    }\n    \n    //Color\n    color += vec3(0., 0.3, 0.8) * f * 1.;\n    \n    color += face(st);\n    \n    //Grid\n    vec3 gridColor = vec3(0.9, 0., 0.1) * 0.15;\n    float gridSpacing = 0.2;\n    color += gridColor * getLine(vec2(st.x, mod(st.y + 0.5, gridSpacing)), vec2(-1., 0.), vec2(1., 0.));\n    \n    float gamma = 0.59;\n    color = vec3(pow(color.x, gamma), pow(color.y, gamma), pow(color.z, gamma));\n    \n    //Invert colors\n    //color = vec3(1.0 - color.z);\n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}