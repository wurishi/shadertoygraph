{"ver":"0.1","info":{"id":"ltXSzr","date":"1434047494","viewed":286,"name":"Rotating 4D Cube","username":"Justaway","description":"Rotating 4D cube.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define MAXITER 50\n#define FOV 0.3\n#define MINDIST 0.001\n#define NORMALSAMPLE 0.1\n\n/* 3d rotations*/\nmat3 rotX(float a);\nmat3 rotY(float a);\nmat3 rotZ(float a);\nmat3 rot(vec3 z,float a);\n\n/* 4d rotations */\nmat4 rotXY(float t);\nmat4 rotYZ(float t);\nmat4 rotZX(float t);\nmat4 rotXW(float t);\nmat4 rotYW(float t);\nmat4 rotZW(float t);\n\n/* raymarch functions*/\nfloat dist(vec4 p);\nvec4 normal(vec4 p, float d);\n\nmat4 rotXY(float t)\n{\n    float ct = cos(t);\n    float st = sin(t);\n    return mat4(\n        ct,st,0.0,0.0,\n        -st,ct,0.0,0.0,\n        0.0,0.0,1.0,0.0,\n        0.0,0.0,0.0,1.0\n    );\n}\n\nmat4 rotYZ(float t)\n{\n    float ct = cos(t);\n    float st = sin(t);\n    return mat4(\n        1.0,0.0,0.0,0.0,\n        0.0,ct,st,0.0,\n        0.0,-st,ct,0.0,\n        0.0,0.0,0.0,1.0\n    );\n}\n        \nmat4 rotZX(float t)\n{\n    float ct = cos(t);\n    float st = sin(t);\n    return mat4(\n        ct,0.0,-st,0.0,\n        0.0,1.0,0.0,0.0,\n        st,0.0,ct,0.0,\n        0.0,0.0,0.0,1.0\n    );\n}\n        \nmat4 rotXW(float t)\n{\n    float ct = cos(t);\n    float st = sin(t);\n    return mat4(\n        ct,0.0,0.0,st,\n        0.0,1.0,0.0,0.0,\n        0.0,0.0,1.0,0.0,\n        -st,0.0,0.0,ct\n    );\n}\n\nmat4 rotYW(float t)\n{\n    float ct = cos(t);\n    float st = sin(t);\n    return mat4(\n        1.0,0.0,0.0,0.0,\n        0.0,ct,0.0,-st,\n        0.0,0.0,1.0,0.0,\n        0.0,st,0.0,ct\n    );\n}\n\nmat4 rotZW(float t)\n{\n    float ct = cos(t);\n    float st = sin(t);\n    return mat4(\n        1.0,0.0,0.0,0.0,\n        0.0,1.0,0.0,0.0,\n        0.0,0.0,ct,-st,\n        0.0,0.0,st,ct\n    );\n}\n\nfloat dist(vec4 a)\n{\n    vec4 p = a \n        * rotXW(iTime*0.3)\n        * rotYW(iTime*0.35)\n        * rotZW(iTime*0.4)\n        * rotXY(iTime*0.45)\n        * rotYZ(iTime*0.5)\n        * rotZX(iTime*0.55);\n    return max(abs(p.x),max(abs(p.y),max(abs(p.z),abs(p.w))))-0.8;\n}\n\nvec4 normal(vec4 p)\n{\n    float d = dist(p);\n    vec4 s=vec4(NORMALSAMPLE,0.0,0.0,0.0);    \n    return normalize(vec4(\n        dist(p+s.xyyy-d),\n        dist(p+s.yxyy-d),\n        dist(p+s.yyxy-d),\n        dist(p+s.yyyx-d)\n    ));\n}\n\n\nmat3 rotX(float a)\n{\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(1.0,0.0,0.0,0.0,c,-s,0.0,s,c);\n}\n\nmat3 rotY(float a)\n{\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(c,0.0,s,0.0,1.0,0.0,-s,0.0,c);\n}\n\nmat3 rotZ(float a)\n{\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat3(c,-s,0.0,s,c,0.0,0.0,0.0,1.0);\n}\n\nmat3 rot(vec3 z,float a)\n{\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\tfloat ic=1.0-c;\n\treturn mat3(\n\t\tic*z.x*z.x+c,ic*z.x*z.y-z.z*s,ic*z.z*z.x+z.y*s,\n\t\tic*z.x*z.y+z.z*s,ic*z.y*z.y+c,ic*z.y*z.z-z.x*s,\n\t\tic*z.z*z.x-z.y*s,ic*z.y*z.z+z.x*s,ic*z.z*z.z+c);\n}\n\nvec4 background(vec4 v)\n{\n    return vec4(smoothstep(0.0, 1.0, 1.0-abs(v.y)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 sc = fragCoord.xy/iResolution.xy;\n    sc = (sc-0.5)*2.0;\n\tsc.x *= float(iResolution.x)/float(iResolution.y);\n    \n    vec4 eye = vec4(0.0,0.0,-5.0,0.0);\n    \n    //eye.xyz *= rotX(0.5*sin(0.33*iTime));\n    //eye.xyz *= rotY(sin(0.66*iTime));\n    \n    vec4 left = vec4(0.0);\n    vec4 camUp = vec4(0.0);\n    \n    vec4 up = vec4(0.0,-1.0,0.0,0.0);\n    vec4 look = vec4(0.0);\n \tvec4 dir = normalize(look - eye);\n    left.xyz = normalize(cross(up.xyz,dir.xyz));\n    camUp.xyz = normalize(cross(dir.xyz,left.xyz));\n    \n    dir.xyz *= rot(camUp.xyz,sc.x*FOV);\n    dir.xyz *= rot(left.xyz,sc.y*FOV);\n    \n    bool hit = false;\n    vec4 p = eye;\n    float d;\n    vec4 color;\n    vec4 n;\n    \n    for(int i = 0; i < MAXITER; i++)\n    {\n        if(!hit)\n        {\n        \td = dist(p);\n            if(d < 0.0)\n            {\n                n = normal(p);\n                hit = true;\n            }\n        \td = max(MINDIST,d);\n            p += dir*d;\n        }\n    }\n    \n    \n    if(hit)\n    {\n        color = vec4(abs(dot(dir,n)));\n    }\n    else\n    {\n        color = background(dir);\n    }\n    \n    fragColor = color;\n}","name":"","description":"","type":"image"}]}