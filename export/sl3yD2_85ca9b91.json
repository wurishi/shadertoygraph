{"ver":"0.1","info":{"id":"sl3yD2","date":"1660556702","viewed":139,"name":"HPG22 Submission","username":"ishaanshah","description":"Final submission for HPG22 student competition. If the results are blocky, please reload and wait for the noise texture to load. \nClick and drag to compare.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["pathtracing","hpgconf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The following built-in quality knobs are available:\n//\n// (1) Uncomment the preprocessor definition FULL_SCENE to get the full scene.\n// (2) Set NUM_SAMPLES to increase the number of rays per pixel.\n// \n// We will judge your submitted shader as follows:\n// \n//  - Shader run time must not exceed 2x of our baseline shader \n//    with FULL_SCENE and NUM_SAMPLES==1\n//\n//  - Final image quality will be measured using SSIM against a reference \n//    with FULL_SCENE and NUM_SAMPLES==100000\n// \n// Note: Changing these definitions will increase shader compilation times.\n// \n// Windows users will need to configure their browser to use the native OpenGL backend.\n//\n// If you are using Chrome:\n//  - Go to chrome://flags and search for \"Angle\"\n//  - Change backend from \"Default\" to \"OpenGL\"\n//  - Restart your browser\n//\n\n\n// Description of improvements made:\n// - While choosing which light to sample, we only choose lights which are on the correct side of the shading point, i.e. dot(cube_pos.xyz - shade_point, normal) > 0.\n// - We choose the light to be sampled with a probability proportional to I/r2.\n// - While choosing the face from which to sample, we check in which octant the shading point lies in w.r.t to the light cubes coordinate frame. We only sample from the 3 surface which are visible from the shading point.\n// - We sample from the BRDF using the VNDF technique described in https://jcgt.org/published/0007/04/01/.\n// - We perform intersection tests in two stages, first, we intersect with bounding boxes surrounding the letters and if the intersection is successful then we perform the intersection with individual components.\n// - We apply Russian Roulette to terminate paths which won't contribute much to the final image early.\n// - We use more samples for Next Event Estimation, i.e. from each point we cast 2 light rays instead of 1.\n// - We use the blue noise texture to generate random numbers as it is more efficient and distributes the error better.\n// - We focused on keeping the renderer unbiased.\n\nvoid\nmainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if(abs(fragCoord.x - iMouse.x) < 2.f)\n        fragColor = vec4(1);\n    else if(iMouse.x > fragCoord.x)\n        fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    else\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// The following built-in quality knobs are available:\n//\n// (1) Uncomment the preprocessor definition FULL_SCENE to get the full scene.\n// (2) Set NUM_SAMPLES to increase the number of rays per pixel.\n// \n// We will judge your submitted shader as follows:\n// \n//  - Shader run time must not exceed 2x of our baseline shader \n//    with FULL_SCENE and NUM_SAMPLES==1\n//\n//  - Final image quality will be measured using SSIM against a reference \n//    with FULL_SCENE and NUM_SAMPLES==100000\n// \n// Note: Changing these definitions will increase shader compilation times.\n// \n// Windows users will need to configure their browser to use the native OpenGL backend.\n//\n// If you are using Chrome:\n//  - Go to chrome://flags and search for \"Angle\"\n//  - Change backend from \"Default\" to \"OpenGL\"\n//  - Restart your browser\n//\n#define FULL_SCENE\n#define NUM_SAMPLES 5\n\n#define VERSION 2\n\n#define INFINITY 9999999.0 // sorry, webgl doesn't allow to use proper float infinity :(\n#define PI 3.141592653589\n#define EPS 1e-6\n\n#ifdef FULL_SCENE\n#define NUM_BOUNCES 8\n#else\n#define NUM_BOUNCES 2\n#endif\n\n#define MAT_LEFT        0\n#define MAT_RIGHT       1\n#define MAT_CEILING     2\n#define MAT_FLOOR       3\n#define MAT_BACK        4\n#define MAT_H           5\n#define MAT_P           6\n#define MAT_G           7\n#define MAT_2           8\n#define MAT_LIGHT0      9\n#define MAT_LIGHT1      10\n#define MAT_LIGHT2      11\n#define MAT_LIGHT3      12\n#define MAT_LIGHT4      13\n#define MAT_LIGHT5      14\n#define MAT_LIGHT6      15\n#define MAT_LIGHT7      16\n#define MAT_LIGHT8      17\n\nstruct Ray\n{\n\tvec3 origin, dir;\n};\n\nstruct AABB\n{\n\tvec3 min_, max_;\n};\n\nstruct MaterialSample\n{\n\tvec3 color;\n\tfloat roughness;\n\tbool is_light;\n    int light_idx;\n};\n\nint seed;\nvec2 frag_coord;\n\nconst float cube_light_size = 0.08;\nconst vec4 cube_light_pos[4] = vec4[4](\n\tvec4(  -0.9, -1.0 + cube_light_size * 0.495,  0.6, 0.4),\n\tvec4(  0.3, -1.0 + cube_light_size * 0.495,  0.2, 0.8),\n\tvec4(  1.0 - 2.0 * cube_light_size, -1.0 + 2.0 * cube_light_size, -1.0 + 5.0 * cube_light_size, 0.0),\n\tvec4(  -1.0 + 2.0 * cube_light_size, -1.0 + 2.0 * cube_light_size, -0.6, 0.0)\n);\n\nconst vec3 light_color[4] = vec3[4](\n\tvec3(5),\n\tvec3(5),\n\tvec3(80.0, 50, 30),\n\tvec3(30, 30, 80.0)\n);\n\n\n// H\nconst vec4 coordinates_H[3] = vec4[3](\nvec4(0.000, 0.000, 0.200, 0.750),\nvec4(0.427, 0.000, 0.627, 0.750),\nvec4(0.116, 0.310, 0.516, 0.450));\n// P\nconst vec4 coordinates_P[4] = vec4[4](\nvec4(0.000, 0.000, 0.200, 0.750),\nvec4(0.400, 0.360, 0.540, 0.675),\nvec4(0.044, 0.288, 0.471, 0.428),\nvec4(0.000, 0.610, 0.471, 0.750));\n// G\nconst vec4 coordinates_G[6] = vec4[6](\nvec4(0.000, 0.060, 0.200, 0.670),\nvec4(0.425, 0.060, 0.625, 0.265),\nvec4(0.425, 0.520, 0.625, 0.670),\nvec4(0.100, 0.000, 0.625, 0.140),\nvec4(0.315, 0.265, 0.625, 0.405),\nvec4(0.077, 0.610, 0.550, 0.750));\n// 2\nconst vec4 coordinates_2[5] = vec4[5](\nvec4(0.000, 0.000, 0.140, 0.365) * 0.5,\nvec4(0.474, 0.365, 0.614, 0.680) * 0.5,\nvec4(0.044, 0.000, 0.614, 0.140) * 0.5,\nvec4(0.044, 0.288, 0.544, 0.428) * 0.5,\nvec4(0.044, 0.610, 0.544, 0.750) * 0.5);\n\n// TNB, sorry!\nmat3\nconstruct_ONB_frisvad(vec3 normal)\n{\n\tmat3 ret;\n\tret[1] = normal;\n\tif(normal.z < -0.999805696) {\n\t\tret[0] = vec3(0.0, -1.0, 0.0);\n\t\tret[2] = vec3(-1.0, 0.0, 0.0);\n\t}\n\telse {\n\t\tfloat a = 1.0 / (1.0 + normal.z);\n\t\tfloat b = -normal.x * normal.y * a;\n\t\tret[0] = vec3(1.0 - normal.x * normal.x * a, b, -normal.x);\n\t\tret[2] = vec3(b, 1.0 - normal.y * normal.y * a, -normal.y);\n\t}\n\treturn ret;\n}\n\nvec2\nget_random() {\n    // Use blue noise texture\n    vec2 rng = texelFetch(iChannel0, (ivec2(frag_coord) + 10*seed) % ivec2(iChannelResolution[0].xy), 0).rg;\n    seed += 1;\n    return rng;\n}\n\n\n// adapted from https://cwyman.org/code/dxrTutors/tutors/Tutor14/tutorial14.md.html\nfloat\nggxNormalDistribution(float NdotH, float roughness)\n{\n\tfloat a2 = roughness * roughness;\n\tfloat d = ((NdotH * a2 - NdotH) * NdotH + 1.0);\n\treturn a2 / (d * d * PI);\n}\n\nfloat\nschlickMaskingTerm(float NdotL, float NdotV, float roughness)\n{\n\t// Karis notes they use alpha / 2 (or roughness^2 / 2)\n\tfloat k = roughness*roughness / 2.0;\n\n\t// Compute G(v) and G(l).  These equations directly from Schlick 1994\n\t//     (Though note, Schlick's notation is cryptic and confusing.)\n\tfloat g_v = NdotV / (NdotV*(1.0 - k) + k);\n\tfloat g_l = NdotL / (NdotL*(1.0 - k) + k);\n\treturn g_v * g_l;\n}\n\nfloat schlickSingleMask(float NdotV, float roughness)\n{\n    float k = roughness*roughness / 2.0;\n    return NdotV / (NdotV*(1.0-k) + k);\n}\n\nvec3\nschlickFresnel(vec3 f0, float lDotH)\n{\n\treturn f0 + (vec3(1.0, 1.0, 1.0) - f0) * pow(1.0 - lDotH, 5.0);\n}\n\nmat4\nrotate_y(float a)\n{\n\tmat4 ret = mat4(1.0);\n\tret[0][0] = ret[2][2] = cos(a);\n\tret[0][2] = sin(a);\n\tret[2][0] = -ret[0][2];\n\treturn ret;\n}\n\nmat4\nlook_at(vec3 eye, vec3 center, vec3 up)\n{\n\tmat4 ret;\n\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, normalize(up)));\n\tvec3 u = cross(s, f);\n\n\tret[0][0] = s[0];\n\tret[1][0] = s[1];\n\tret[2][0] = s[2];\n\n\tret[0][1] = u[0];\n\tret[1][1] = u[1];\n\tret[2][1] = u[2];\n\n\tret[0][2] = -f[0];\n\tret[1][2] = -f[1];\n\tret[2][2] = -f[2];\n\n\tret[0][3] = ret[1][3] = ret[2][3] = 0.0;\n\n\tret[3][0] = -dot(s, eye);\n\tret[3][1] = -dot(u, eye);\n\tret[3][2] =  dot(f, eye);\n\n\tret[3][3] = 1.0;\n\treturn ret;\n}\n\nbool\nintersect_aabb(in Ray ray, in AABB aabb, inout float t_min, inout float t_max)\n{\n\tvec3 div = 1.0 / ray.dir;\n\tvec3 t_1 = (aabb.min_ - ray.origin) * div;\n\tvec3 t_2 = (aabb.max_ - ray.origin) * div;\n\n\tvec3 t_min2 = min(t_1, t_2);\n\tvec3 t_max2 = max(t_1, t_2);\n\n\tt_min = max(max(t_min2.x, t_min2.y), max(t_min2.z, t_min));\n\tt_max = min(min(t_max2.x, t_max2.y), min(t_max2.z, t_max));\n\n\treturn t_min < t_max;\n}\n\nvec3\nray_at(in Ray ray, float t)\n{\n\treturn ray.origin + t * ray.dir;\n}\n\nfloat\nintersect_plane(\n\tRay ray,\n    vec3 center,\n    vec3 normal)\n{\n    float denom = dot(ray.dir, normal);\n    float t = dot(center - ray.origin, normal) / denom;\n\treturn t > 0.0 ? t : INFINITY;\n}\n\nfloat\nintersect_box(Ray ray, out vec3 normal, vec3 position_min, vec3 position_max)\n{\n\tfloat t_min = 0.0;\n\tfloat t_max = 999999999.0;\n\tif(intersect_aabb(ray, AABB(position_min, position_max), t_min, t_max)) {\n\t\tvec3 p = ray_at(ray, t_min);\n\n\t\tvec3 center = (position_min + position_max) * 0.5;\n\n\t\tnormal = p - center;\n\n\t\tvec3 an = abs(normal) / (position_max - position_min);\n\n\t\tif(an.x > an.y && an.x > an.z) {\n\t\t\tnormal = vec3(normal.x > 0.0 ? 1.0 : -1.0, 0, 0);\n\t\t}\n\t\tif(an.y > an.x && an.y > an.z) {\n\t\t\tnormal = vec3(0, normal.y > 0.0 ? 1.0 : -1.0, 0);\n\t\t}\n\t\tif(an.z > an.x && an.z > an.y) {\n\t\t\tnormal = vec3(0, 0, normal.z > 0.0 ? 1.0 : -1.0);\n\t\t}\n\n\t\treturn t_min;\n\t}\n\n\treturn INFINITY;\n}\n\nfloat\nintersect(Ray ray, bool shadow, inout vec3 p, inout vec3 normal, out MaterialSample ms)\n{\n\tfloat t_min = INFINITY;\n\n\tint material = -1;\n{\n    vec3 normal_tmp;\n    Ray ray_tmp = ray;\n    mat4 r = rotate_y(-0.35);\n    ray_tmp.origin -= vec3(-0.9, -1, 0.0);\n    ray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n    ray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n    float H_intersect = intersect_box(ray_tmp, normal_tmp, vec3(0.0, 0.0, 0.0), vec3(0.627, 0.750, 0.150));\n    \n    if (H_intersect != INFINITY)\n\tfor(int i = 0; i < coordinates_H.length(); i++) {\n\t\tvec3 box_origin = vec3(coordinates_H[i].xy, 0.0);\n\t\tvec3 box_size = vec3(coordinates_H[i].zw - coordinates_H[i].xy, 0.15);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, box_origin, box_origin + box_size);\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_H;\n\t\t\tnormal = vec3(transpose(r) * vec4(normal_tmp, 0.0));\n\t\t}\n\t}\n}\n\n{\n    vec3 normal_tmp;\n    Ray ray_tmp = ray;\n    mat4 r = rotate_y(0.75);\n    ray_tmp.origin -= vec3(-0.28, -1, 0.2);\n    ray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n    ray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n    float P_intersect = intersect_box(ray_tmp, normal_tmp, vec3(0.0, 0.0, 0.0), vec3(0.540, 0.750, 0.150));\n\n    if (P_intersect != INFINITY)\n\tfor(int i = 0; i < coordinates_P.length(); i++) {\n\t\tvec3 box_origin = vec3(coordinates_P[i].xy, 0.0);\n\t\tvec3 box_size = vec3(coordinates_P[i].zw - coordinates_P[i].xy, 0.15);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, box_origin, box_origin + box_size);\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_P;\n\t\t\tnormal = vec3(transpose(r) * vec4(normal_tmp, 0.0));\n\t\t}\n\t}\n}\n\n{\n    vec3 normal_tmp;\n    Ray ray_tmp = ray;\n    mat4 r = rotate_y(-0.4);\n    ray_tmp.origin -= vec3(0.35, -1, -0.20);\n    ray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n    ray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n    float G_intersect = intersect_box(ray_tmp, normal_tmp, vec3(0.0, 0.0, 0.0), vec3(0.625, 0.750, 0.150));\n\n    if (G_intersect != INFINITY)\n\tfor(int i = 0; i < coordinates_G.length(); i++) {\n\t\tvec3 box_origin = vec3(coordinates_G[i].xy, 0.0);\n\t\tvec3 box_size = vec3(coordinates_G[i].zw - coordinates_G[i].xy, 0.15);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, box_origin, box_origin + box_size);\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_G;\n\t\t\tnormal = vec3(transpose(r) * vec4(normal_tmp, 0.0));\n\t\t}\n\t}\n}\n\n#ifdef FULL_SCENE\n{\n    vec3 normal_tmp;\n    Ray ray_tmp = ray;\n    mat4 r = rotate_y(0.0);\n    ray_tmp.origin -= vec3(0.1, -0.2, -1.0);\n    ray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n    ray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n    float TWO_intersect = intersect_box(ray_tmp, normal_tmp, vec3(0.0, 0.0, 0.0) * 0.5, vec3(0.614, 0.750, 0.125) * 0.5);\n\n    if (TWO_intersect != INFINITY);\n\tfor(int i = 0; i < coordinates_2.length(); i++) {\n\t\tvec3 box_origin = vec3(coordinates_2[i].xy, 0.0);\n\t\tvec3 box_size = vec3(coordinates_2[i].zw - coordinates_2[i].xy, 0.125);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, box_origin, box_origin + box_size);\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_2;\n\t\t\tnormal = vec3(transpose(r) * vec4(normal_tmp, 0.0));\n\t\t}\n\t}\n}\n\n{\n    vec3 normal_tmp;\n    Ray ray_tmp = ray;\n    mat4 r = rotate_y(0.0);\n    ray_tmp.origin -= vec3(0.45, -0.2, -1.0);\n    ray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n    ray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n    float TWO_intersect = intersect_box(ray_tmp, normal_tmp, vec3(0.0, 0.0, 0.0) * 0.5, vec3(0.614, 0.750, 0.125) * 0.5);\n\n    if (TWO_intersect != INFINITY);\n\tfor(int i = 0; i < coordinates_2.length(); i++) {\n\t\tvec3 box_origin = vec3(coordinates_2[i].xy, 0.0);\n\t\tvec3 box_size = vec3(coordinates_2[i].zw - coordinates_2[i].xy, 0.125);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, box_origin, box_origin + box_size);\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_2;\n\t\t\tnormal = vec3(transpose(r) * vec4(normal_tmp, 0.0));\n\t\t}\n\t}\n}\n#endif\n\n\n\t// cube light sources\n\tfor(int i = 0; i < cube_light_pos.length(); i++) {\n\t\tvec3 normal_tmp;\n\t\tRay ray_tmp = ray;\n\t\t//mat4 r = rotate_y(scene_time);\n\t\tmat4 r = rotate_y(-cube_light_pos[i].w);\n\t\tray_tmp.origin -= cube_light_pos[i].xyz;\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp,\n\t\t\t\tvec3(-cube_light_size * 0.5),\n\t\t\t\tvec3(cube_light_size * 0.5));\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_LIGHT0 + i;\n\t\t\tnormal = vec3(transpose(r) * vec4(normal_tmp, 0.0));\n\t\t}\n\t}\n    \n    if (!shadow) {\n        // left\n        {\n            vec3 n = vec3(1, 0, 0);\n            float t = intersect_plane(ray, vec3(-1, 0, 0), n);\n            if(t < t_min) {\n                vec3 p_tmp = ray_at(ray, t);\n                if(all(lessThanEqual(p_tmp.yz, vec2(1))) && all(greaterThanEqual(p_tmp.yz,\n                                vec2(-1))))\n                {\n                    normal = n;\n                    p = p_tmp;\n\n                    t_min = t;\n\n                    material = MAT_LEFT;\n                }\n            }\n        }\n        // right\n        {\n            vec3 n = vec3(-1, 0, 0);\n            float t = intersect_plane(ray, vec3(1, 0, 0), n);\n            if(t < t_min) {\n                vec3 p_tmp = ray_at(ray, t);\n                if(all(lessThanEqual(p_tmp.yz, vec2(1))) && all(greaterThanEqual(p_tmp.yz,\n                                vec2(-1))))\n                {\n                    normal = n;\n                    p = p_tmp;\n\n                    t_min = t;\n\n                    material = MAT_RIGHT;\n                }\n            }\n        }\n        // floor\n        {\n            vec3 n = vec3(0, 1, 0);\n            float t = intersect_plane(ray, vec3(0, -1, 0), n);\n            if(t < t_min) {\n                vec3 p_tmp = ray_at(ray, t);\n                if(all(lessThan(p_tmp.xz, vec2(1))) && all(greaterThan(p_tmp.xz,\n                                vec2(-1))))\n                {\n                    normal = n;\n                    p = p_tmp;\n\n                    t_min = t;\n                    material = MAT_FLOOR;\n                }\n            }\n        }\n        // ceiling\n        {\n            vec3 n = vec3(0, -1, 0);\n            float t = intersect_plane(ray, vec3(0, 1, 0), n);\n            if(t < t_min) {\n                vec3 p_tmp = ray_at(ray, t);\n                if(all(lessThan(p_tmp.xz, vec2(1))) && all(greaterThan(p_tmp.xz,\n                                vec2(-1))))\n                {\n                    normal = n;\n                    p = p_tmp;\n                    material = MAT_CEILING;\n\n                    t_min = t;\n                }\n            }\n        }\n        // back wall\n        {\n            vec3 n = vec3(0, 0, 1);\n            float t = intersect_plane(ray, vec3(0, 0, -1), n);\n            if(t < t_min) {\n                vec3 p_tmp = ray_at(ray, t);\n                if(all(lessThan(p_tmp.xy, vec2(1))) && all(greaterThan(p_tmp.xy,\n                                vec2(-1))))\n                {\n                    normal = n;\n                    p = p_tmp;\n                    material = MAT_BACK;\n\n                    t_min = t;\n                }\n            }\n        }\n\t}\n\n    switch(material) {\n\tcase MAT_LEFT   : ms = MaterialSample(vec3(0.9, 0.1, 0.1), 0.5,  false, -1); break;\n\tcase MAT_RIGHT  : ms = MaterialSample(vec3(0.1, 0.9, 0.1), 0.5,  false, -1); break;\n\tcase MAT_CEILING: ms = MaterialSample(vec3(0.7, 0.7, 0.7), 0.25, false, -1); break;\n\tcase MAT_FLOOR  : ms = MaterialSample(vec3(0.7, 0.7, 0.7), 0.12, false, -1); break;\n\tcase MAT_BACK   : ms = MaterialSample(vec3(0.7, 0.7, 0.7), 0.25, false, -1); break;\n\tcase MAT_H      : ms = MaterialSample(vec3(1.0, 0.0, 0.0), 0.10, false, -1); break;\n\tcase MAT_P      : ms = MaterialSample(vec3(0.0, 0.7, 0.7), 0.10, false, -1); break;\n\tcase MAT_G      : ms = MaterialSample(vec3(0.1, 0.1, 0.7), 0.10, false, -1); break;\n\tcase MAT_2      : ms = MaterialSample(vec3(0.8, 0.8, 0.8), 0.55, false, -1); break;\n\tdefault         : ms = MaterialSample(light_color[material - MAT_LIGHT0], 0.0, true, material - MAT_LIGHT0); break;\n\t}\n\n\tnormal = normalize(normal);\n\n\treturn t_min;\n}\n\n\nbool\ntest_visibility(vec3 p1, vec3 p2)\n{\n\tconst float eps = 1e-5;\n\n\tRay r = Ray(p1, normalize(p2 - p1));\n\tr.origin += eps * r.dir;\n\n\tvec3 n, p;\n\tMaterialSample ms;\n\tfloat t_shadow = intersect(r, true, p, n, ms);\n\n\treturn t_shadow > distance(p1, p2) - 2.0 * eps;\n}\n\nivec3\nvalid_surfaces(vec3 point)\n{\n    if (point.x >= 0.0 && point.y >= 0.0 && point.z >= 0.0)\n        return ivec3(1, 3, 5);\n    if (point.x >= 0.0 && point.y >= 0.0 && point.z <= 0.0)\n        return ivec3(1, 2, 5);\n    if (point.x >= 0.0 && point.y <= 0.0 && point.z >= 0.0)\n        return ivec3(0, 3, 5);\n    if (point.x >= 0.0 && point.y <= 0.0 && point.z <= 0.0)\n        return ivec3(0, 2, 5);\n    if (point.x <= 0.0 && point.y >= 0.0 && point.z >= 0.0)\n        return ivec3(1, 3, 4);\n    if (point.x <= 0.0 && point.y >= 0.0 && point.z <= 0.0)\n        return ivec3(1, 2, 4);\n    if (point.x <= 0.0 && point.y <= 0.0 && point.z >= 0.0)\n        return ivec3(0, 3, 4);\n    if (point.x <= 0.0 && point.y <= 0.0 && point.z <= 0.0)\n        return ivec3(0, 2, 4);\n}\n\nvec3\nsample_light(vec4 rng, vec3 shade_normal, vec3 shade_point, out vec3 normal, out float pdf, out vec3 Le)\n{   \n    // Choose light based on distance i.e. closer lights are sampled with more probability\n    const int num_lights = cube_light_pos.length();\n\tfloat distances_pdf[num_lights];\n    float distances_cdf[num_lights];\n    float distances_sum = 0.f;\n    \n    // Calculate distance based PDF of selecting lights\n    int valid_lights[4] = int[4](-1, -1, -1, -1);\n    int valid_light_cnt = 0;\n    for(int i=0; i<num_lights; i++) {\n        vec3 dir = cube_light_pos[i].xyz - shade_point;\n        if (dot(dir, shade_normal) < 0.0) {\n            continue;\n        }\n        valid_lights[valid_light_cnt] = i;\n        float dist = length(dir);\n\n        distances_pdf[i] = length(light_color[i]) / (dist*dist);\n        distances_sum += distances_pdf[i];\n        \n        if(i == 0) {\n            distances_cdf[i] = distances_pdf[i];\n        } else {\n            distances_cdf[i] = distances_cdf[i-1] + distances_pdf[i];\n        }\n        valid_light_cnt += 1;\n    }\n    \n    // No lights on side of normal\n    if (valid_light_cnt == 0) {\n        pdf = 0.0;\n        Le = vec3(0.0);\n        return vec3(0.0, 0.0, 0.0);\n    }\n    \n    int cube_idx = -1;\n    for(int i=0; i<valid_light_cnt;i++) {\n        // Normalize PDF\n        distances_pdf[i] /= distances_sum;\n        distances_cdf[i] /= distances_sum;\n        if(i == 0) {\n            if(rng.z <= distances_cdf[i]) {\n                cube_idx = i;\n                break;\n            }\n        }\n        else {\n            if(rng.z > distances_cdf[i-1] && \n                    rng.z <= distances_cdf[i]) {\n                cube_idx = i;\n                break;\n            }\n        }\n    }\n    \n    cube_idx = valid_lights[cube_idx];\n    Le = light_color[cube_idx];\n    \n    // Randomly choose a face on which to sample a point\n    int face_idx = int(rng.w * 3.0);\n    if (face_idx == 3) {\n        face_idx -= 1;\n    }\n    \n    // Choose point according to octant that shading point lies in\n    mat4 rotation_mat = rotate_y(cube_light_pos[cube_idx].w);\n    vec3 new_p = (rotate_y(-cube_light_pos[cube_idx].w) * vec4(shade_point - cube_light_pos[cube_idx].xyz, 1.0)).xyz;\n    ivec3 val_faces = valid_surfaces(new_p);\n    face_idx = val_faces[face_idx];\n    \n    vec3 n, p;\n    switch(face_idx) {\n        case 0:\n            p = vec3(rng.x, 0, rng.y);\n            n = vec3( 0, -1,  0); \n            break;\n        case 1:\n            p = vec3(rng.x, 1, rng.y);\n            n = vec3( 0, 1,  0); \n            break;\n        case 2:\n            p = vec3(rng.x, rng.y, 0);\n            n = vec3( 0, 0, -1); \n            break;\n        case 3:\n            p = vec3(rng.x, rng.y, 1);\n            n = vec3( 0, 0, 1); \n            break;\n        case 4:\n            p = vec3(0, rng.x, rng.y);\n            n = vec3( -1,  0,  0); \n            break;\n        case 5:\n            p = vec3(1, rng.x, rng.y);\n            n = vec3( 1,  0,  0); \n            break;\n    }\n    p -= vec3(0.5);\n\tp = (rotation_mat * vec4(p, 1.0)).xyz;\n\tn = (rotation_mat * vec4(n, 0.0)).xyz;\n\tp *= cube_light_size;\n    pdf = (1.0 / (3.0 * cube_light_size * cube_light_size)) * distances_pdf[cube_idx];\n    normal = n;\n    return p + cube_light_pos[cube_idx].xyz;\n}\n\nfloat\nget_light_pdf(vec3 shade_point, int light_idx)\n{\n    const int num_lights = cube_light_pos.length();\n\tfloat distances_pdf[num_lights];\n    float distances_sum = 0.f;\n    \n    for(int i=0; i<num_lights; i++) {\n        float dist = length(cube_light_pos[i].xyz - shade_point);\n        \n        distances_pdf[i] = length(light_color[i]) / (dist*dist);\n        distances_sum += distances_pdf[i];\n    }\n    \n    return (distances_pdf[light_idx] / distances_sum) * (1.0 / (3.0 * cube_light_size * cube_light_size));\n}\n\n\nfloat\npdf_a_to_w(float pdf, float dist2, float cos_theta)\n{\n    float abs_cos_theta = abs(cos_theta);\n    if(abs_cos_theta < 1e-8)\n        return 0.0;\n\n    return pdf * dist2 / abs_cos_theta;\n}\n\n// Adapted from https://jcgt.org/published/0007/04/01/\nvec3 sampleGGXVNDF(vec3 V, float roughness, vec2 rng, mat3 onb)\n{\n    V = vec3(dot(V, onb[0]), dot(V, onb[2]), dot(V, onb[1]));\n    \n\t// Section 3.2: transforming the view direction to the hemisphere configuration\n\tV = normalize(vec3(roughness * V.x, roughness * V.y, V.z));\n    \n\t// Section 4.1: orthonormal basis (with special case if cross product is zero)\n\tfloat lensq = V.x * V.x + V.y * V.y;\n\tvec3 T1 = lensq > 0. ? vec3(-V.y, V.x, 0) * inversesqrt(lensq) : vec3(1,0,0);\n\tvec3 T2 = cross(V, T1);\n    \n\t// Section 4.2: parameterization of the projected area\n\tfloat r = sqrt(rng.x);\t\n\tfloat phi = 2.0 * PI * rng.y;\n    // float phi = 2.0  * rng.y;\n\tfloat t1 = r * cos(phi);\n\tfloat t2 = r * sin(phi);\n\tfloat s = 0.5 * (1.0 + V.z);\n\tt2 = (1.0 - s)*sqrt(1.0 - t1*t1) + s*t2;\n    \n\t// Section 4.3: reprojection onto hemisphere\n\tvec3 Nh = t1*T1 + t2*T2 + sqrt(max(0.0, 1.0 - t1*t1 - t2*t2))*V;\n\t// Section 3.4: transforming the normal back to the ellipsoid configuration\n\tvec3 Ne = normalize(vec3(roughness * Nh.x, max(0.0, Nh.z), roughness * Nh.y));\t\n\treturn normalize(onb * Ne);\n}\n\nfloat GGX_VNDF_PDF(float VdotH, float D) {\n    return (VdotH > 0.0) ? D / (4.0 * VdotH) : 0.0;\n}\n\nvec3\npt_mis(Ray ray)\n{\n\tvec3 contrib = vec3(0);\n\tvec3 tp = vec3(1.0);\n\n\tvec3 position, normal;\n\tMaterialSample ms;\n\tfloat t = intersect(ray, false, position, normal, ms);\n\n\tif(t == INFINITY)\n\t\treturn vec3(0.0);\n\n\tif(ms.is_light) { /* hit light source */\n\t\treturn ms.color;\n\t}\n\n\tfor(int i = 0; i < NUM_BOUNCES; i++) {\n\t\tmat3 onb = construct_ONB_frisvad(normal);\n\n\t\tfloat NdotV = max(1e-4, dot(normal, -ray.dir));\n        \n\t\t{ /* NEE */\n            vec3 c = vec3(0.0);\n            int calc = 0;\n            int light_samples;\n            if (i < 4) {\n                light_samples = 2;\n            } else {\n                light_samples = 1;\n            }\n            for (int j = 0; j < light_samples; j += 1) {\n                vec3 light_normal;\n                float light_pdf;\n                vec3 Le;\n                vec3 pos_ls = sample_light(vec4(get_random(), get_random()), normal, position, light_normal, light_pdf, Le);\n                if (light_pdf > EPS && test_visibility(position, pos_ls)) {\n                    vec3 l_nee = pos_ls - position;\n                    float rr_nee = dot(l_nee, l_nee);\n                    l_nee /= sqrt(rr_nee);\n\n\n                    vec3 H = normalize(-ray.dir + l_nee);\n                    vec3 V = -ray.dir;\n                    float NdotH = max(0.0, dot(normal, H));\n                    float LdotH = max(0.0, dot(l_nee, H));\n                    float NdotL = max(1e-6, dot(normal, l_nee));\n                    float VdotH = max(1e-6, dot(V, H));\n\n                    float D = ggxNormalDistribution(NdotH, ms.roughness);\n                    float G = schlickMaskingTerm(NdotL, NdotV, ms.roughness);\n                    vec3  F = schlickFresnel(ms.color, LdotH);\n\n                    vec3 brdf = D * G * F / (4.0 * NdotV  * NdotL );\n                    float brdf_pdf = GGX_VNDF_PDF(VdotH, D);\n                    float light_pdf_w = pdf_a_to_w(light_pdf, rr_nee, -dot(l_nee, light_normal));\n                    float w = 1.0 / (light_pdf_w + brdf_pdf);\n                    c += tp * Le * brdf * w;\n                    calc += 1;\n                } \n            }\n            if (calc > 0) {\n                contrib += c / float(calc);\n            }\n\t\t}\n\t\t\n\t\t{ /* brdf */\n\t\t\t// Randomly sample the NDF to get a microfacet in our BRDF\n            vec3 V = -ray.dir;\n\t\t\tvec3 H = sampleGGXVNDF(V, ms.roughness, get_random(), onb);\n\t\t\t// Compute outgoing direction based on this (perfectly reflective) facet\n\t\t\tvec3 L = normalize(reflect(ray.dir, H));\n\t\t\tray = Ray(position + L * 1e-5, L);\n\n\t\t\tvec3 position_next, normal_next;\n\t\t\tMaterialSample ms_next;\n\t\t\tfloat t = intersect(ray, false, position_next, normal_next, ms_next);\n\n\t\t\tif(t == INFINITY) {\n\t\t\t\tbreak;\n            }\n\n\t\t\t// Compute some dot products needed for shading\n\t\t\tfloat  NdotL = max(1e-6, dot(normal, L));\n\t\t\tfloat  LdotH = max(1e-6, dot(L, H));\n            \n\t\t\t// Evaluate our BRDF using a microfacet BRDF model\n\t\t\tvec3 F = schlickFresnel(ms.color, LdotH);                 \n\t\t\t        \n            if(ms_next.is_light) {\n                float  NdotH = max(1e-6, dot(normal, H));\n                float  VdotH = max(1e-6, dot(V, H));\n                float  NdotV = max(1e-6, dot(normal, V));\n                \n                float D = ggxNormalDistribution(NdotH, ms.roughness);          \n                float G = schlickMaskingTerm(NdotL, NdotV, ms.roughness); \n                \n                // What's the probability of sampling vector H from sampleGGXVNDF()?\n                float brdf_pdf = GGX_VNDF_PDF(VdotH, D);\n                vec3  brdf = D * G * F / (4.0 * NdotL * NdotV);\n                \n                float light_pdf_a = get_light_pdf(position, ms_next.light_idx);\n                float light_pdf_w = pdf_a_to_w(light_pdf_a, t * t, -dot(ray.dir, normal_next));\n                float w = 1.0 / (brdf_pdf + light_pdf_w);\n                contrib += tp * (ms_next.color * w * brdf);\n                break;\n            };\n\t\t\ttp *= F * schlickSingleMask(NdotL, ms.roughness);\n\n\t\t\tposition = position_next;\n\t\t\tnormal = normal_next;\n\t\t\tms = ms_next;\n\t\t}\n        \n        // Russian roulette\n        if (i > 2) {\n            float p = max(max(tp.x, tp.y), tp.z);\n            if (get_random().x > p) {\n                break;\n            }\n            tp *= 1.0 / p;\n        }\n    }\n\n\treturn contrib;\n}\n\n\nvoid\nmainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tseed = iFrame * NUM_SAMPLES;\n    frag_coord = fragCoord;\n\tvec2 p = fragCoord.xy / vec2(iResolution) - vec2(0.5);\n\tfloat a = float(iResolution.x) / float(iResolution.y);\n\tif(a < 1.0)\n\t\tp.y /= a;\n\telse\n\t\tp.x *= a;\n\n\t//vec3 cam_center = vec3(0, 0.2, 6.0);\n    vec3 cam_center = vec3(sin(iTime) * 0.25, sin(iTime * 0.7345) * 0.4 + 0.2, 6.0);\n\tvec3 cam_target = vec3(0, -0.1, 0);\n\n\tmat4 cam = transpose(look_at(cam_center, cam_target, vec3(0, 1, 0)));\n\n\tvec3 s = vec3(0);\n    float exposure = 2.0;\n    for(int i = 0; i < NUM_SAMPLES; i++) {\n\t\tRay ray;\n\t\tray.origin = cam_center;\n\t\tvec2 r = get_random();\n\t\tvec3 ray_dir = normalize(vec3(p + r.x * dFdx(p) + r.y * dFdy(p), -2.5));\n\t\tray.dir = vec3(cam * vec4(ray_dir, 0.0));\n\t\tvec3 c = clamp(pt_mis(ray), 0.0, 1.0);\n\t\ts += c;\n\t}\n    \n\tfragColor = vec4(pow(exposure * s / float(NUM_SAMPLES), vec3(1.0 / 2.2)), 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// The following built-in quality knobs are available:\n//\n// (1) Uncomment the preprocessor definition FULL_SCENE to get the full scene.\n// (2) Set NUM_SAMPLES to increase the number of rays per pixel.\n// \n// We will judge your submitted shader as follows:\n// \n//  - Shader run time must not exceed 2x of our baseline shader \n//    with FULL_SCENE and NUM_SAMPLES==1\n//\n//  - Final image quality will be measured using FLIP against a reference \n//    with FULL_SCENE and NUM_SAMPLES==100000\n// \n// Note: Changing these definitions will increase shader compilation times.\n// \n// Windows users will need to configure their browser to use the native OpenGL backend.\n//\n// If you are using Chrome:\n//  - Go to chrome://flags and search for \"Angle\"\n//  - Change backend from \"Default\" to \"OpenGL\"\n//  - Restart your browser\n//\n#define FULL_SCENE\n#define NUM_SAMPLES 1\n\n#define VERSION 2\n\n// Changelog:\n//\n// Update (2022-06-14): We have updated the quality evaluation metric to\n//                      FLIP (Andersson et al., HPG 2020) instead of SSIM\n//\n// Version 2:\n//   NEE computation: added epsilon for NdotL, commented in NdotL in BRDF term\n//   Thanks to Arthur Firmino for the bug report!\n\n\n// If you have developed your solution with the old code, and cannot update your\n// submission with reasonable effort, we will grade your solution against our version 1\n// renderer.\n\n#define INFINITY 9999999.0 // sorry, webgl doesn't allow to use proper float infinity :(\n#define PI 3.141592653589\n\n#ifdef FULL_SCENE\n#define NUM_BOUNCES 8\n#else\n#define NUM_BOUNCES 2\n#endif\n\n#define MAT_LEFT        0\n#define MAT_RIGHT       1\n#define MAT_CEILING     2\n#define MAT_FLOOR       3\n#define MAT_BACK        4\n#define MAT_H           5\n#define MAT_P           6\n#define MAT_G           7\n#define MAT_2           8\n#define MAT_LIGHT0      9\n#define MAT_LIGHT1      10\n#define MAT_LIGHT2      11\n#define MAT_LIGHT3      12\n#define MAT_LIGHT4      13\n#define MAT_LIGHT5      14\n#define MAT_LIGHT6      15\n#define MAT_LIGHT7      16\n#define MAT_LIGHT8      17\n\nstruct Ray\n{\n\tvec3 origin, dir;\n};\n\nstruct AABB\n{\n\tvec3 min_, max_;\n};\n\nstruct MaterialSample\n{\n\tvec3 color;\n\tfloat roughness;\n\tbool is_light;\n};\n\nint seed;\nint flat_idx;\n\nconst float cube_light_size = 0.08;\nconst vec4 cube_light_pos[4] = vec4[4](\n\t\tvec4(  -0.9, -1.0 + cube_light_size * 0.495,  0.6, 0.4),\n\t\tvec4(  0.3, -1.0 + cube_light_size * 0.495,  0.2, 0.8),\n\t\tvec4(  1.0 - 2.0 * cube_light_size, -1.0 + 2.0 * cube_light_size, -1.0 + 5.0 * cube_light_size, 0.0),\n\t\tvec4(  -1.0 + 2.0 * cube_light_size, -1.0 + 2.0 * cube_light_size, -0.6, 0.0)\n\t\t);\n\nconst vec3 light_color[4] = vec3[4](\n\t\tvec3(5),\n\t\tvec3(5),\n\t\tvec3(80.0, 50, 30),\n\t\tvec3(30, 30, 80.0)\n\t\t);\n\n\n// H\nconst vec4 coordinates_H[3] = vec4[3](\nvec4(0.000, 0.000, 0.200, 0.750),\nvec4(0.427, 0.000, 0.627, 0.750),\nvec4(0.116, 0.310, 0.516, 0.450));\n// P\nconst vec4 coordinates_P[4] = vec4[4](\nvec4(0.000, 0.000, 0.200, 0.750),\nvec4(0.400, 0.360, 0.540, 0.675),\nvec4(0.044, 0.288, 0.471, 0.428),\nvec4(0.000, 0.610, 0.471, 0.750));\n// G\nconst vec4 coordinates_G[6] = vec4[6](\nvec4(0.000, 0.060, 0.200, 0.670),\nvec4(0.425, 0.060, 0.625, 0.265),\nvec4(0.425, 0.520, 0.625, 0.670),\nvec4(0.100, 0.000, 0.625, 0.140),\nvec4(0.315, 0.265, 0.625, 0.405),\nvec4(0.077, 0.610, 0.550, 0.750));\n// 2\nconst vec4 coordinates_2[5] = vec4[5](\nvec4(0.000, 0.000, 0.140, 0.365) * 0.5,\nvec4(0.474, 0.365, 0.614, 0.680) * 0.5,\nvec4(0.044, 0.000, 0.614, 0.140) * 0.5,\nvec4(0.044, 0.288, 0.544, 0.428) * 0.5,\nvec4(0.044, 0.610, 0.544, 0.750) * 0.5);\n\n// TNB, sorry!\nmat3\nconstruct_ONB_frisvad(vec3 normal)\n{\n\tmat3 ret;\n\tret[1] = normal;\n\tif(normal.z < -0.999805696) {\n\t\tret[0] = vec3(0.0, -1.0, 0.0);\n\t\tret[2] = vec3(-1.0, 0.0, 0.0);\n\t}\n\telse {\n\t\tfloat a = 1.0 / (1.0 + normal.z);\n\t\tfloat b = -normal.x * normal.y * a;\n\t\tret[0] = vec3(1.0 - normal.x * normal.x * a, b, -normal.x);\n\t\tret[2] = vec3(b, 1.0 - normal.y * normal.y * a, -normal.y);\n\t}\n\treturn ret;\n}\n\nvoid\nencrypt_tea(inout uvec2 arg)\n{\n\tuvec4 key = uvec4(0xa341316c, 0xc8013ea4, 0xad90777d, 0x7e95761e);\n\tuint v0 = arg[0], v1 = arg[1];\n\tuint sum = 0u;\n\tuint delta = 0x9e3779b9u;\n\n\tfor(int i = 0; i < 32; i++) {\n\t\tsum += delta;\n\t\tv0 += ((v1 << 4) + key[0]) ^ (v1 + sum) ^ ((v1 >> 5) + key[1]);\n\t\tv1 += ((v0 << 4) + key[2]) ^ (v0 + sum) ^ ((v0 >> 5) + key[3]);\n\t}\n\targ[0] = v0;\n\targ[1] = v1;\n}\n\nvec2\nget_random()\n{\n  \tuvec2 arg = uvec2(flat_idx, seed++);\n  \tencrypt_tea(arg);\n  \treturn fract(vec2(arg) / vec2(0xffffffffu));\n}\n\n// adapted from https://cwyman.org/code/dxrTutors/tutors/Tutor14/tutorial14.md.html\nfloat\nggxNormalDistribution(float NdotH, float roughness)\n{\n\tfloat a2 = roughness * roughness;\n\tfloat d = ((NdotH * a2 - NdotH) * NdotH + 1.0);\n\treturn a2 / (d * d * PI);\n}\n\nfloat\nschlickMaskingTerm(float NdotL, float NdotV, float roughness)\n{\n\t// Karis notes they use alpha / 2 (or roughness^2 / 2)\n\tfloat k = roughness*roughness / 2.0;\n\n\t// Compute G(v) and G(l).  These equations directly from Schlick 1994\n\t//     (Though note, Schlick's notation is cryptic and confusing.)\n\tfloat g_v = NdotV / (NdotV*(1.0 - k) + k);\n\tfloat g_l = NdotL / (NdotL*(1.0 - k) + k);\n\treturn g_v * g_l;\n}\n\nvec3\nschlickFresnel(vec3 f0, float lDotH)\n{\n\treturn f0 + (vec3(1.0, 1.0, 1.0) - f0) * pow(1.0 - lDotH, 5.0);\n}\n\n// When using this function to sample, the probability density is:\n//      pdf = D * NdotH / (4 * HdotV)\nvec3\ngetGGXMicrofacetTS(vec2 randVal, float roughness, vec3 hitNorm)\n{\n\t// GGX NDF sampling\n\tfloat a2 = roughness * roughness;\n\tfloat cosThetaH = sqrt(max(0.0, (1.0 - randVal.x) / ((a2 - 1.0) * randVal.x + 1.0)));\n\tfloat sinThetaH = sqrt(max(0.0, 1.0 - cosThetaH * cosThetaH));\n\tfloat phiH = randVal.y * PI * 2.0;\n\n\t// Get our GGX NDF sample (i.e., the half vector)\n\treturn vec3(sinThetaH * cos(phiH), cosThetaH, sinThetaH * sin(phiH));\n}\n\nmat4\nrotate_y(float a)\n{\n\tmat4 ret = mat4(1.0);\n\tret[0][0] = ret[2][2] = cos(a);\n\tret[0][2] = sin(a);\n\tret[2][0] = -ret[0][2];\n\treturn ret;\n}\n\nmat4\nlook_at(vec3 eye, vec3 center, vec3 up)\n{\n\tmat4 ret;\n\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, normalize(up)));\n\tvec3 u = cross(s, f);\n\n\tret[0][0] = s[0];\n\tret[1][0] = s[1];\n\tret[2][0] = s[2];\n\n\tret[0][1] = u[0];\n\tret[1][1] = u[1];\n\tret[2][1] = u[2];\n\n\tret[0][2] = -f[0];\n\tret[1][2] = -f[1];\n\tret[2][2] = -f[2];\n\n\tret[0][3] = ret[1][3] = ret[2][3] = 0.0;\n\n\tret[3][0] = -dot(s, eye);\n\tret[3][1] = -dot(u, eye);\n\tret[3][2] =  dot(f, eye);\n\n\tret[3][3] = 1.0;\n\treturn ret;\n}\n\n\nvec3\nsample_light(vec3 rng, out vec3 normal, out float pdf, out vec3 Le)\n{\n\tint face_idx = int(rng.z * float(cube_light_pos.length()) * 6.0);\n\tint cube_idx = face_idx / 6;\n\tface_idx %= 6;\n\n\tLe = light_color[cube_idx];\n\n\tvec3 p, n;\n\tswitch(face_idx) {\n\tdefault:\n\tcase 0: p = vec3(rng.x, 0, rng.y); n = vec3( 0, -1,  0); break; \n\tcase 1: p = vec3(rng.x, 1, rng.y); n = vec3( 0,  1,  0); break; \n\tcase 2: p = vec3(rng.x, rng.y, 0); n = vec3( 0,  0, -1); break; \n\tcase 3: p = vec3(rng.x, rng.y, 1); n = vec3( 0,  0,  1); break; \n\tcase 4: p = vec3(0, rng.x, rng.y); n = vec3(-1,  0,  0); break; \n\tcase 5: p = vec3(1, rng.x, rng.y); n = vec3( 1,  0,  0); break; \n\t}\n\n\tp -= vec3(0.5);\n\tp = (rotate_y(cube_light_pos[cube_idx].w) * vec4(p, 1.0)).xyz;\n\tn = (rotate_y(cube_light_pos[cube_idx].w) * vec4(n, 0.0)).xyz;\n\tp *= cube_light_size;\n\n\tnormal = n;\n\n\tpdf = 1.0 / (float(cube_light_pos.length()) * 6.0 * cube_light_size * cube_light_size);\n\n\treturn p + cube_light_pos[cube_idx].xyz;\n}\n\nfloat\nget_light_pdf()\n{\n    return 1.0 / (float(cube_light_pos.length()) * 6.0 * cube_light_size * cube_light_size);\n}\n\n// convert pdf from area measure to solid angle\nfloat\npdf_a_to_w(float pdf, float dist2, float cos_theta)\n{\n    float abs_cos_theta = abs(cos_theta);\n    if(abs_cos_theta < 1e-8)\n        return 0.0;\n\n    return pdf * dist2 / abs_cos_theta;\n}\n\nbool\nintersect_aabb(in Ray ray, in AABB aabb, inout float t_min, inout float t_max)\n{\n\tvec3 div = 1.0 / ray.dir;\n\tvec3 t_1 = (aabb.min_ - ray.origin) * div;\n\tvec3 t_2 = (aabb.max_ - ray.origin) * div;\n\n\tvec3 t_min2 = min(t_1, t_2);\n\tvec3 t_max2 = max(t_1, t_2);\n\n\tt_min = max(max(t_min2.x, t_min2.y), max(t_min2.z, t_min));\n\tt_max = min(min(t_max2.x, t_max2.y), min(t_max2.z, t_max));\n\n\treturn t_min < t_max;\n}\n\nvec3\nray_at(in Ray ray, float t)\n{\n\treturn ray.origin + t * ray.dir;\n}\n\nfloat\nintersect_plane(\n\tRay ray,\n    vec3 center,\n    vec3 normal)\n{\n    float denom = dot(ray.dir, normal);\n    float t = dot(center - ray.origin, normal) / denom;\n\treturn t > 0.0 ? t : INFINITY;\n}\n\nfloat\nintersect_box(Ray ray, out vec3 normal, vec3 position_min, vec3 position_max)\n{\n\tfloat t_min = 0.0;\n\tfloat t_max = 999999999.0;\n\tif(intersect_aabb(ray, AABB(position_min, position_max), t_min, t_max)) {\n\t\tvec3 p = ray_at(ray, t_min);\n\n\t\tvec3 center = (position_min + position_max) * 0.5;\n\n\t\tnormal = p - center;\n\n\t\tvec3 an = abs(normal) / (position_max - position_min);\n\n\t\tif(an.x > an.y && an.x > an.z) {\n\t\t\tnormal = vec3(normal.x > 0.0 ? 1.0 : -1.0, 0, 0);\n\t\t}\n\t\tif(an.y > an.x && an.y > an.z) {\n\t\t\tnormal = vec3(0, normal.y > 0.0 ? 1.0 : -1.0, 0);\n\t\t}\n\t\tif(an.z > an.x && an.z > an.y) {\n\t\t\tnormal = vec3(0, 0, normal.z > 0.0 ? 1.0 : -1.0);\n\t\t}\n\n\t\treturn t_min;\n\t}\n\n\treturn INFINITY;\n}\n\nfloat\nintersect(Ray ray, inout vec3 p, inout vec3 normal, out MaterialSample ms)\n{\n\tfloat t_min = INFINITY;\n\n\tint material = -1;\n\n\tfor(int i = 0; i < coordinates_H.length(); i++) {\n\t\tvec3 normal_tmp;\n\n\t\tRay ray_tmp = ray;\n\t\tmat4 r = rotate_y(-0.35);\n\t\tray_tmp.origin -= vec3(-0.9, -1, 0.0);\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\n\t\tvec3 box_origin = vec3(coordinates_H[i].xy, 0.0);\n\t\tvec3 box_size = vec3(coordinates_H[i].zw - coordinates_H[i].xy, 0.15);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, box_origin, box_origin + box_size);\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_H;\n\t\t\tnormal = vec3(transpose(r) * vec4(normal_tmp, 0.0));\n\t\t}\n\t}\n\n\tfor(int i = 0; i < coordinates_P.length(); i++) {\n\t\tvec3 normal_tmp;\n\n\t\tRay ray_tmp = ray;\n\t\tmat4 r = rotate_y(0.75);\n\t\tray_tmp.origin -= vec3(-0.28, -1, 0.2);\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\n\t\tvec3 box_origin = vec3(coordinates_P[i].xy, 0.0);\n\t\tvec3 box_size = vec3(coordinates_P[i].zw - coordinates_P[i].xy, 0.15);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, box_origin, box_origin + box_size);\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_P;\n\t\t\tnormal = vec3(transpose(r) * vec4(normal_tmp, 0.0));\n\t\t}\n\t}\n\n\tfor(int i = 0; i < coordinates_G.length(); i++) {\n\t\tvec3 normal_tmp;\n\n\t\tRay ray_tmp = ray;\n\t\tmat4 r = rotate_y(-0.4);\n\t\tray_tmp.origin -= vec3(0.35, -1, -0.20);\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\n\t\tvec3 box_origin = vec3(coordinates_G[i].xy, 0.0);\n\t\tvec3 box_size = vec3(coordinates_G[i].zw - coordinates_G[i].xy, 0.15);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, box_origin, box_origin + box_size);\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_G;\n\t\t\tnormal = vec3(transpose(r) * vec4(normal_tmp, 0.0));\n\t\t}\n\t}\n\n#ifdef FULL_SCENE\n\tfor(int i = 0; i < coordinates_2.length(); i++) {\n\t\tvec3 normal_tmp;\n\n\t\tRay ray_tmp = ray;\n\t\tmat4 r = rotate_y(0.0);\n\t\tray_tmp.origin -= vec3(0.1, -0.2, -1.0);\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\n\t\tvec3 box_origin = vec3(coordinates_2[i].xy, 0.0);\n\t\tvec3 box_size = vec3(coordinates_2[i].zw - coordinates_2[i].xy, 0.125);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, box_origin, box_origin + box_size);\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_2;\n\t\t\tnormal = vec3(transpose(r) * vec4(normal_tmp, 0.0));\n\t\t}\n\t}\n\n\tfor(int i = 0; i < coordinates_2.length(); i++) {\n\t\tvec3 normal_tmp;\n\n\t\tRay ray_tmp = ray;\n\t\tmat4 r = rotate_y(0.0);\n\t\tray_tmp.origin -= vec3(0.45, -0.2, -1.0);\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\n\t\tvec3 box_origin = vec3(coordinates_2[i].xy, 0.0);\n\t\tvec3 box_size = vec3(coordinates_2[i].zw - coordinates_2[i].xy, 0.125);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, box_origin, box_origin + box_size);\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_2;\n\t\t\tnormal = vec3(transpose(r) * vec4(normal_tmp, 0.0));\n\t\t}\n\t}\n#endif\n\n\n\t// cube light sources\n\tfor(int i = 0; i < cube_light_pos.length(); i++) {\n\t\tvec3 normal_tmp;\n\t\tRay ray_tmp = ray;\n\t\t//mat4 r = rotate_y(scene_time);\n\t\tmat4 r = rotate_y(-cube_light_pos[i].w);\n\t\tray_tmp.origin -= cube_light_pos[i].xyz;\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp,\n\t\t\t\tvec3(-cube_light_size * 0.5),\n\t\t\t\tvec3(cube_light_size * 0.5));\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\tmaterial = MAT_LIGHT0 + i;\n\t\t\tnormal = vec3(transpose(r) * vec4(normal_tmp, 0.0));\n\t\t}\n\t}\n\t// left\n\t{\n\t\tvec3 n = vec3(1, 0, 0);\n\t\tfloat t = intersect_plane(ray, vec3(-1, 0, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThanEqual(p_tmp.yz, vec2(1))) && all(greaterThanEqual(p_tmp.yz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\n\t\t\t\tt_min = t;\n\n\t\t\t\tmaterial = MAT_LEFT;\n\t\t\t}\n\t\t}\n\t}\n\t// right\n\t{\n\t\tvec3 n = vec3(-1, 0, 0);\n\t\tfloat t = intersect_plane(ray, vec3(1, 0, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThanEqual(p_tmp.yz, vec2(1))) && all(greaterThanEqual(p_tmp.yz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\n\t\t\t\tt_min = t;\n\n\t\t\t\tmaterial = MAT_RIGHT;\n\t\t\t}\n\t\t}\n\t}\n\t// floor\n\t{\n\t\tvec3 n = vec3(0, 1, 0);\n\t\tfloat t = intersect_plane(ray, vec3(0, -1, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThan(p_tmp.xz, vec2(1))) && all(greaterThan(p_tmp.xz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\n\t\t\t\tt_min = t;\n\t\t\t\tmaterial = MAT_FLOOR;\n\t\t\t}\n\t\t}\n\t}\n\t// ceiling\n\t{\n\t\tvec3 n = vec3(0, -1, 0);\n\t\tfloat t = intersect_plane(ray, vec3(0, 1, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThan(p_tmp.xz, vec2(1))) && all(greaterThan(p_tmp.xz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\t\t\t\tmaterial = MAT_CEILING;\n\n\t\t\t\tt_min = t;\n\t\t\t}\n\t\t}\n\t}\n\t// back wall\n\t{\n\t\tvec3 n = vec3(0, 0, 1);\n\t\tfloat t = intersect_plane(ray, vec3(0, 0, -1), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThan(p_tmp.xy, vec2(1))) && all(greaterThan(p_tmp.xy,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\t\t\t\tmaterial = MAT_BACK;\n\n\t\t\t\tt_min = t;\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch(material) {\n\tcase MAT_LEFT   : ms = MaterialSample(vec3(0.9, 0.1, 0.1), 0.5,  false); break;\n\tcase MAT_RIGHT  : ms = MaterialSample(vec3(0.1, 0.9, 0.1), 0.5,  false); break;\n\tcase MAT_CEILING: ms = MaterialSample(vec3(0.7, 0.7, 0.7), 0.25, false); break;\n\tcase MAT_FLOOR  : ms = MaterialSample(vec3(0.7, 0.7, 0.7), 0.12, false); break;\n\tcase MAT_BACK   : ms = MaterialSample(vec3(0.7, 0.7, 0.7), 0.25, false); break;\n\tcase MAT_H      : ms = MaterialSample(vec3(1.0, 0.0, 0.0), 0.10, false); break;\n\tcase MAT_P      : ms = MaterialSample(vec3(0.0, 0.7, 0.7), 0.10, false); break;\n\tcase MAT_G      : ms = MaterialSample(vec3(0.1, 0.1, 0.7), 0.10, false); break;\n\tcase MAT_2      : ms = MaterialSample(vec3(0.8, 0.8, 0.8), 0.55, false); break;\n\tdefault         : ms = MaterialSample(light_color[material - MAT_LIGHT0], 0.0, true); break;\n\t}\n\n\tnormal = normalize(normal);\n\n\treturn t_min;\n}\n\nbool\ntest_visibility(vec3 p1, vec3 p2)\n{\n\tconst float eps = 1e-5;\n\n\tRay r = Ray(p1, normalize(p2 - p1));\n\tr.origin += eps * r.dir;\n\n\tvec3 n, p;\n\tMaterialSample ms;\n\tfloat t_shadow = intersect(r, p, n, ms);\n\n\treturn t_shadow > distance(p1, p2) - 2.0 * eps;\n}\n\nvec3\npt_mis(Ray ray)\n{\n\tvec3 contrib = vec3(0);\n\tvec3 tp = vec3(1.0);\n\n\tvec3 position, normal;\n\tMaterialSample ms;\n\tfloat t = intersect(ray, position, normal, ms);\n\n\tif(t == INFINITY)\n\t\treturn vec3(0.0);\n\n\tif(ms.is_light) { /* hit light source */\n\t\treturn ms.color;\n\t}\n\n\n\tfor(int i = 0; i < NUM_BOUNCES; i++) {\n\t\tmat3 onb = construct_ONB_frisvad(normal);\n\n\t\tfloat NdotV = max(1e-4, dot(normal, -ray.dir));\n\n\t\t{ /* NEE */\n\t\t\tvec3 light_normal;\n\t\t\tfloat light_pdf;\n\t\t\tvec3 Le;\n\t\t\tvec3 pos_ls = sample_light(vec3(get_random(), get_random().x), light_normal, light_pdf, Le);\n\t\t\tvec3 l_nee = pos_ls - position;\n\t\t\tfloat rr_nee = dot(l_nee, l_nee);\n\t\t\tl_nee /= sqrt(rr_nee);\n\n\t\t\tvec3 H = normalize(-ray.dir + l_nee);\n\t\t\tfloat NdotH = max(0.0, dot(normal, H));\n\t\t\tfloat LdotH = max(0.0, dot(l_nee, H));\n\t\t\tfloat NdotL = max(1e-6, dot(normal, l_nee));\n\n\t\t\tfloat D = ggxNormalDistribution(NdotH, ms.roughness);\n\t\t\tfloat G = schlickMaskingTerm(NdotL, NdotV, ms.roughness);\n\t\t\tvec3  F = schlickFresnel(ms.color, LdotH);\n\n\t\t\t{\n\t\t\t\tvec3 brdf = D * G * F / (4.0 * NdotV  * NdotL );\n                float brdf_pdf = D * NdotH / (4.0 * LdotH);\n                \n                float light_pdf_w = pdf_a_to_w(light_pdf, rr_nee, -dot(l_nee, light_normal));\n                float w = light_pdf / (light_pdf_w + brdf_pdf);\n\n\t\t\t\tif(test_visibility(position, pos_ls)) {\n\t\t\t\t\tcontrib += w * tp * (Le * brdf) / light_pdf;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t{ /* brdf */\n\t\t\t// Randomly sample the NDF to get a microfacet in our BRDF \n\t\t\tvec3 H = onb * getGGXMicrofacetTS(get_random(), ms.roughness, normal);\n\n\t\t\t// Compute outgoing direction based on this (perfectly reflective) facet\n\t\t\tvec3 L = normalize(reflect(ray.dir, H));\n\n\t\t\t// Compute some dot products needed for shading\n\t\t\tfloat  NdotL = max(1e-6, dot(normal, L));\n\t\t\tfloat  NdotH = max(1e-6, dot(normal, H));\n\t\t\tfloat  LdotH = max(1e-6, dot(L, H));\n\n\t\t\t// Evaluate our BRDF using a microfacet BRDF model\n\t\t\tfloat D = ggxNormalDistribution(NdotH, ms.roughness);          \n\t\t\tfloat G = schlickMaskingTerm(NdotL, NdotV, ms.roughness); \n\t\t\tvec3  F = schlickFresnel(ms.color, LdotH);                 \n\t\t\tvec3  brdf = D * G * F / (4.0 * NdotL * NdotV);        \n\n\t\t\t// What's the probability of sampling vector H from getGGXMicrofacet()?\n\t\t\tfloat brdf_pdf = D * NdotH / (4.0 * LdotH);\n\n\t\t\tray = Ray(position + L * 1e-5, L);\n\n\t\t\tvec3 position_next, normal_next;\n\t\t\tMaterialSample ms_next;\n\t\t\tfloat t = intersect(ray, position_next, normal_next, ms_next);\n\n\t\t\tif(t == INFINITY)\n\t\t\t\tbreak;\n\n            if(ms_next.is_light) {\n\t\t\t\tfloat light_pdf_a = get_light_pdf();\n\t\t\t\tfloat light_pdf_w = pdf_a_to_w(light_pdf_a, t * t, -dot(ray.dir, normal_next));\n\t\t\t\tfloat w = brdf_pdf / (brdf_pdf + light_pdf_w);\n\t\t\t\tcontrib += tp * (ms_next.color * w * brdf) / brdf_pdf;\n\t\t\t\tbreak;\n            }\n\n\t\t\ttp *= NdotL * brdf / brdf_pdf;\n\n\t\t\tposition = position_next;\n\t\t\tnormal = normal_next;\n\t\t\tms = ms_next;\n\t\t}\n\t}\n\n\treturn contrib;\n}\n\nvoid\nmainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tseed = iFrame * NUM_SAMPLES;\n\tflat_idx = int(dot(gl_FragCoord.xy, vec2(1, 4096)));\n\n\tvec2 p = fragCoord.xy / vec2(iResolution) - vec2(0.5);\n\tfloat a = float(iResolution.x) / float(iResolution.y);\n\tif(a < 1.0)\n\t\tp.y /= a;\n\telse\n\t\tp.x *= a;\n\n\t//vec3 cam_center = vec3(0, 0, 3.0);\n\tvec3 cam_center = vec3(sin(iTime) * 0.25, sin(iTime * 0.7345) * 0.4 + 0.2, 6.0);\n\tvec3 cam_target = vec3(0, -0.1, 0);\n\n\tmat4 cam = transpose(look_at(cam_center, cam_target, vec3(0, 1, 0)));\n\n\tvec3 s = vec3(0);\n    float exposure = 2.0;\n\tfor(int i = 0; i < NUM_SAMPLES; i++) {\n\t\tRay ray;\n\t\tray.origin = cam_center;\n\t\tvec2 r = get_random();\n\t\tvec3 ray_dir = normalize(vec3(p + r.x * dFdx(p) + r.y * dFdy(p), -2.5));\n\t\tray.dir = vec3(cam * vec4(ray_dir, 0.0));\n\t\tvec3 c = pt_mis(ray);\n\t\ts += c;\n\t}\n\tfragColor = vec4(pow(exposure * s / float(NUM_SAMPLES), vec3(1.0 / 2.2)), 1.0);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}