{"ver":"0.1","info":{"id":"3tfcDM","date":"1592168449","viewed":114,"name":"distance-based collision detecti","username":"stb","description":"Distance-based collision detection using marching squares.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["collision","sdf","detection","distance","function","signed"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tdistance-based collision detection\n\t2020 stb (2015 BeyondTheStatic)\n\n\tThe white dot represents the ball's unmodified poition.\n*/\n#define pixelize 16.\t\t\t// comment to disable pixelization\nconst float worldScale\t= .15;\t// zoom\nconst float ballRad\t\t= .5;\t// ball radius, range: >0.0 to <=0.5\n\n#define clamp_(a) clamp(a, 0., 1.)\n\nfloat brick(vec2 p){ return 2. * min(abs(fract(p.x+.5*float(mod(p.y+.5, 2.)>1.))-.5), abs(fract(p.y)-.5)); }\nfloat grid(vec2 p){ return 2. * min(abs(fract(p.x)-.5), abs(fract(p.y)-.5)); }\nfloat rand(vec2 p){ return fract(sin(dot(p, vec2(12.9898, 78.233)))*43758.5453); }\n\n// shape of the landscape\nint binLand(in vec2 p) {\n    p = floor(p) + .5;\n    float land = 1.5 * abs(p.y+1.*cos(p.x*2.)) * rand(p-1.);\n    return (land > .75 ? 1 : 0);\n}\n\n// tile definitions\nfloat tileEmpty(vec2 p) {\n    return 1.;\n}\nfloat tileFilled(vec2 p) {\n    return -1.;\n}\nfloat tileCornerIn(vec2 p) {\n    return 1.-length(p-1.);\n}\nfloat tileCornerOut(vec2 p) {\n    return length(p);\n}\nfloat tileWall(vec2 p) {\n    return p.y;\n}\nfloat tileJoin(in vec2 p) {\n    p = (p.x<p.y ? vec2(1.-p.x, p.y) : vec2(p.x, 1.-p.y));\n    return 1.-length(p-1.);\n}\n\n// get landscape (there must be a simpler way)\nfloat getLand(in vec2 p) {   \n    // get decimal value from 2x2 neighborhood of binLand()\n    int dec = 0;\n    vec2 co = vec2(.5, -.5);\n    dec += binLand(p-co.xx);\n    dec += binLand(p-co.yx) * 2;\n    dec += binLand(p-co.xy) * 4;\n    dec += binLand(p-co.yy) * 8;\n    \n    p = fract(p+.5);\n    \n    // choose tile depending on decimal value\n    float f;\n    if(dec==0)\n        f = tileEmpty(p);\n\telse if(dec==1)\n        f = tileCornerOut(p);\n    else if(dec==2)\n        f = tileCornerOut(vec2(1.-p.x, p.y));\n\telse if(dec==3)\n        f = tileWall(p);\n    else if(dec==4)\n        f = tileCornerOut(vec2(p.x, 1.-p.y));\n\telse if(dec==5)\n        f = tileWall(vec2(p.y, p.x));\n    else if(dec==6)\n        f = tileJoin(vec2(1.-p.x, p.y));\n\telse if(dec==7)\n        f = tileCornerIn(p);\n    else if(dec==8)\n        f = tileCornerOut(vec2(1.-p));\n\telse if(dec==9)\n        f = tileJoin(p);\n\telse if(dec==10)\n        f = tileWall(vec2(p.y, 1.-p.x));\n    else if(dec==11)\n        f = tileCornerIn(vec2(1.-p.x, p.y));\n\telse if(dec==12)\n        f = tileWall(vec2(p.x, 1.-p.y));\n    else if(dec==13)\n        f = tileCornerIn(vec2(p.x, 1.-p.y));\n\telse if(dec==14)\n        f = tileCornerIn(vec2(1.)-p);\n    else if(dec==15)\n        f = tileFilled(p);\n\treturn 2. * (f-.5);\n}\n\nvec2 getNorm(vec2 p) {\n    vec3 acc = .0001 * vec3(0., -1., 1.);\n    return\n        normalize(\n            vec2(\n                getLand(p-acc.zx) - getLand(p-acc.yx),\n                getLand(p-acc.xz) - getLand(p-acc.xy)\n            )\n        );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 res\t= iResolution.xy;\n\tvec2 uv\t\t= (fragCoord-0.5*res) / res.y;\n    vec2 mPos\t= (iMouse.xy-0.5*res) / res.y;\n    \n    #ifdef pixelize\n    \tuv = floor(uv*pixelize/worldScale) / pixelize * worldScale;\n    #endif\n    \n    vec2  ballPos = vec2(iMouse.z>0. ? mPos : vec2(0.));\n    \n    uv\t\t/= worldScale;\n    ballPos\t/= worldScale;\n    \n    // ball/camera movement\n    vec2 move = vec2(2.*iTime, 0.);\n    ballPos += move;\n    uv += move;\n    \n    // unmodified ball position\n    vec2 ballPos_ = ballPos;\n    \n    // attempting to fix collision errors\n    ballPos = floor(ballPos*res.y) / res.y;\n    \n    float ballHit = getLand(ballPos);\n\tvec2  hitNorm = getNorm(ballPos);\n    \n    // collision detection\n    if(ballHit<ballRad*2.)\n        ballPos -= hitNorm * (ballRad-ballHit/2.);\n    \n    // a big old mess of draw commands\n    float landMask = getLand(uv);\n    float ballMask = clamp_(1.-length(uv-ballPos)/ballRad);\n    vec3 ballCol = (.5+ballMask) * vec3(.1, 1., .1) + .5*vec3(ballHit<ballRad*2.);\n    vec3 landCol = mix(vec3(0.5, .75, 1.)*(.5+.5*clamp_(landMask)), clamp_(-2.*landMask)*vec3(1.5, .8, .5)*vec3(brick(vec2(2., 4.)*uv)), clamp_(1.-8.*landMask));\n    vec3 RGB;\n    RGB = mix(landCol, ballCol, clamp_(16.*ballMask));\n    RGB = mix(RGB, vec3(1.), clamp_(2.*clamp_(1.-length(uv-ballPos_)/ballRad*3.)));\n    RGB = mix(RGB, vec3(1.), .5*clamp_(1.-7.*grid(uv)));\n    fragColor = vec4(RGB, 1.0);\n}","name":"Image","description":"","type":"image"}]}