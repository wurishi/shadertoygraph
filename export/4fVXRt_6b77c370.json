{"ver":"0.1","info":{"id":"4fVXRt","date":"1715625546","viewed":101,"name":"First Shader (following vid)","username":"Saw8888","description":"My First Shader","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["trippy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 palleteGenerator( float t ){\n    vec3 a = vec3(0.508, 0.558, 0.080);\n    vec3 b = vec3(-0.422, 0.428, 0.638);\n    vec3 c = vec3(1.468, -2.472, 3.138);\n    vec3 d = vec3(1.968, 0.478, 5.362);\n    return a + b*cos(6.28318*(c*t+d));\n}\n\n\n\n//[[0.508 0.558 0.080] [-0.422 0.428 0.638] [1.468 -2.472 3.138] [1.968 0.478 5.362]]\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){ //You recieve the coordenate of a pixel and return its colour. This function is run for every pixel.\n    vec2 uv = fragCoord.xy / iResolution.xy; //This normalizes the canvas so that it ranges from 0-1 not from 0 to sizeX\n    \n    uv = (uv - 0.5)*2.0;//Makes (0,0) the center of the screen\n    uv.x *= iResolution.x / iResolution.y;//Makes the image be the same no matter the aspect ratio\n    \n    vec2 OGuv = uv;\n    \n    vec3 finalColor = vec3(0.0);\n    \n    for(float i=0.0;i<3.0;i++){\n        uv *= 2.; // We grow the coordenate system from 0-1 to 0-2 in order to increase the segments\n        uv = fract(uv); //Segments the screen because it returns de decimals of a number and also allways returns positive numbers, thus the\n                        //negative side of the screen is cloned\n        uv -= 0.5; // We center all the values to the center of their segment\n\n        float d = length(uv) * exp(-length(OGuv)); //SDF length *\n\n        vec3 color = palleteGenerator(length(OGuv) + i*.4 + iTime/2.);\n\n        d = sin(d*9. + iTime)/9.;//In shadertoy, sin ignores cartesian coordenates and instead just functions like a weird osscilator. \n                         //We multiply by 8 to increase the frequency and divide by 8 in order to prevent stretching\n        d = abs(d);\n\n        d = pow(0.01 / d,1.2); // Used an inverse function in order to create a neon look\n                      // We divide by 0.02becasue d is between 0-1 and 1 / 0-1 is allways 1\n\n        finalColor += color * d;\n    }\n    fragColor = vec4(finalColor,1.);\n}","name":"Image","description":"","type":"image"}]}