{"ver":"0.1","info":{"id":"XddfDH","date":"1524955043","viewed":94,"name":"Julia Set Fractal - Self moving","username":"Alazorth","description":"Attempting a Julia Set Fractal with smooth coloring.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractal","juliaset"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#ifdef GL_ES\n#define MAX_ITER 1000\n\n\n//z starts with an initial value of the pixel(c1) and then you \n//add c2 in the iteration which can \n//be a constant or mouse position\n\nfloat fJulia(vec2 c1, vec2 c2){\n    float l = 0.;\n    vec2 z = c1;\n    float B = 256.;\n    for(float i=0.;i<float(MAX_ITER);i++) {\n        if (z.x*z.x + z.y*z.y > 4.) {\n        \treturn l;\n            break;\t\n        }\n        float xtemp = z.x*z.x-(z.y*z.y);\n        z.y = 2.*z.x*z.y + c2.y;\n        z.x = xtemp + c2.x;\n        l+=1.;\n    }\n    float sl = l - log(log(length(z))/log(B))/log(2.0);\n    return sl;\n    //return l;\n}\n\nvec3 trueCmap(float n)\t{  \n    // GLSL has it's own syntax for creating arrays . . .\n    if (n == float(MAX_ITER)){\n    \tvec3 black = vec3(0.,0.,0.); \n        return black;\n    }\n    vec3 cMap[7] = vec3[7](vec3(0.,0.,0.), vec3(1.,0.,1.), vec3(0.,0.,1.), vec3(0.,1.,0.), vec3(1.,1.,0.), vec3(1.,0.5,0.), vec3(0.,0.,0.)) ;\n    \n    float quotient = float(cMap.length()) * n / float(MAX_ITER);\n    float lowerIndex = floor(quotient);\n    float upperIndex = ceil(quotient);\n    highp int lIndex = int(lowerIndex);\n    highp int uIndex = int(upperIndex);\n    float fraction = quotient - lowerIndex;\n    vec3 c = cMap[lIndex] + fraction * (cMap[uIndex] - cMap[lIndex]);\n    \nreturn c;\n}\n\n\nvec4 nmap(float n) {\n\tvec3 colmap;\n    if (float(n) <= float(MAX_ITER)) {\n        float quotient = float(n) / float(MAX_ITER);\n        float color = clamp(quotient,0.,1.);\n        \tif (quotient > 0.5) {\n        \t// Close to the mandelbrot set the color changes from green to white \n \t\t\t\tcolmap = vec3(0.); //(color,1.,color);\n        \t}\n        \telse {\n                colmap = vec3(0.,color,0.);\n            }\n    }\n    return vec4(colmap,1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = fragCoord.xy/iResolution.xy;\n    //float aspect = iResolution.y/iResolution.x;\n    //vec2 p = uv*2.-1.;\n    //p.y*=aspect;\n    //float n = fJulia(p*2.);\n    vec2 p = (2.*fragCoord - iResolution.xy)/iResolution.x;\n    vec2 mousein = (2.*iMouse.xy - iResolution.xy)/iResolution.x;\n    vec2 automove = vec2(sin(iTime*.5)-0.3,cos(iTime*.5))*3./4.; //vec2(sin(0.1*iTime),cos(0.1*iTime));\n    //vec2 c2 = vec2(-0.88,-0.23);\n    float iCount = fJulia(2.*p, automove);\n    fragColor = vec4(trueCmap(iCount*2.),1.);\n \t//fragColor = nmap(iCount*2.),1.;   \n}","name":"Image","description":"","type":"image"}]}