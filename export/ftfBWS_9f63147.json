{"ver":"0.1","info":{"id":"ftfBWS","date":"1651341668","viewed":191,"name":"Segmented ellipse distance","username":"gleboneloner","description":"Numerical approximation of a shortest distance to ellipse, that uses bisection method and some interpolation.\nVisual artifacts are almost completely excluded in the work of this method.\nWorks great for all ellipse dimensions including line and point.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["sdf","numerical","ellipse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float ellipse ( vec2 ab, vec2 uv ) {\n    \n    uv = abs(uv); vec2 N1 = ab*ab, N2 = ab*uv;\n    \n    float U1 = N2.y/2.0;  float U2 = N1.y-N1.x;\n    float U3 = N2.x-U2;   float U4 = N2.x+U2;\n    float s1 = 0.0;       float s2 = 1.0;\n\n    for ( int i = 0; i < 6; i ++ ) {\n\n        float s3 = (s1+s2)/2.0;\n        \n        float H1 = s3*(s3*s3*(U1*s3+U3)+U4)-U1;\n        \n        H1 < 0.0 ? s1 = s3 : s2 = s3;\n\n    }\n\n    vec2 E1 = vec2(1.0-s1*s1,2.0*s1)/(s1*s1+1.0);\n    vec2 E2 = vec2(1.0-s2*s2,2.0*s2)/(s2*s2+1.0);\n\n    vec2 B1 = uv-E1*ab, B2 = (E2-E1)*ab;\n    float K1 = clamp( dot(B1,B2)/dot(B2,B2), 0.0, 1.0 );\n    return length( B1 - B2*K1 );\n\n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 ab = iMouse.xy-iResolution.xy/2.0;\n\n    if ( iMouse.z == 0.0 ) ab = vec2( 140, 80 );\n\n    vec2 uv = fragCoord-iResolution.xy/2.0;\n\n \tfloat d = ellipse( abs(ab), uv );\n    \n    vec4 color = mix( vec4(0.4,0.6,0.8,1), vec4(0.6,0.2,0.3,1), step( 0.0, cos(d/1.2) ) );\n\n    color = color * min(abs(cos(d/1.2)*1.2),1.0) * (1.4-1.2/exp(d/40.0));\n    \n    fragColor = mix( vec4(1), color, smoothstep( 0.0, 1.8, d ) );\n\n}","name":"Image","description":"","type":"image"}]}