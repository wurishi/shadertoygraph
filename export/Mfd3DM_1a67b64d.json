{"ver":"0.1","info":{"id":"Mfd3DM","date":"1711791262","viewed":149,"name":"Progressive Blurs","username":"xioxin","description":"This is a port of a Gaussian blur shader originally written in Metal by Jo√£o Gabriel Pozzobon dos Santos for WWDCApp. The code has been transformed to GLSL to be compatible with ShaderToy. The shader applies a Gaussian blur effect in both the X and Y dire","likes":1,"published":1,"flags":32,"usePreview":1,"tags":["blur"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 size = vec2(iResolution.x, iResolution.y);\n    fragColor = blurY(fragCoord, iChannel0, size, RADIUS, OFFSET, INTERPOLATION, DIRECTION, DISPLAY_SCALE);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define kernelSize (64)\n#define RADIUS 17.0\n#define OFFSET 0.3\n#define INTERPOLATION 1.0\n#define DIRECTION 1.0\n#define DISPLAY_SCALE 1.0\n\n\nfloat mapRadius(vec2 position,\n                vec2 size,\n                float offset,\n                float interpolation,\n                float radius,\n                float direction,\n                float displayScale) {\n    float mapped;\n    \n    if (direction == 0.0) {\n        mapped = max((position.y/size.y*displayScale-offset)/interpolation, 0.0);\n    } else if (direction == 1.0) {\n        mapped = max(0.5-(position.y/size.y*displayScale-offset)/interpolation, 0.0);\n    } else if (direction == 2.0) {\n        mapped = max((position.x/size.x*displayScale-offset)/interpolation, 0.0);\n    } else if (direction == 3.0) {\n        mapped = max(0.5-(position.x/size.x*displayScale-offset)/interpolation, 0.0);\n    }\n    \n    return min(mapped*radius, radius);\n}\n\nvoid calculateGaussianWeights(float radius,\n                              out float weights[kernelSize]) {\n    float sum = 0.0;\n    \n    for (int i = 0; i < kernelSize; ++i) {\n        float x = float(i-(kernelSize-1)/2);\n        weights[i] = exp(-(x*x)/(2.0*radius*radius));\n        sum+= weights[i];\n    }\n    \n    for (int i = 0; i < kernelSize; ++i) {\n        weights[i]/= sum;\n    }\n}\n\nvec4 blurX(vec2 position,\n           sampler2D tex,\n           vec2 size,\n           float radius,\n           float offset,\n           float interpolation,\n           float direction,\n           float displayScale) {\n    float r = mapRadius(position,\n                        size,\n                        offset, interpolation,\n                        radius,\n                        direction,\n                        displayScale);\n    \n    if (r == 0.0) {\n        return texture(tex, position / size);\n    }\n    \n    float weights[kernelSize];\n    calculateGaussianWeights(r, weights);\n    \n    vec4 result = vec4(0.0);\n    for (int i = 0; i < kernelSize; ++i) {\n        float offset = float(i-(kernelSize-1)/2);\n        float x = clamp(position.x+offset, 0.0, size.x-1.0);\n        \n        result+= texture(tex, vec2(x, position.y) / size)*weights[i];\n    }\n    \n    return result;\n}\n\nvec4 blurY(vec2 position,\n           sampler2D tex,\n           vec2 size,\n           float radius,\n           float offset,\n           float interpolation,\n           float direction,\n           float displayScale) {\n    float r = mapRadius(position,\n                        size,\n                        offset, interpolation,\n                        radius,\n                        direction,\n                        displayScale);\n    \n    if (r == 0.0) {\n        return texture(tex, position / size);\n    }\n    \n    float weights[kernelSize];\n    calculateGaussianWeights(r, weights);\n    \n    vec4 result = vec4(0.0);\n    for (int i = 0; i < kernelSize; ++i) {\n        float offset = float(i-(kernelSize-1)/2);\n        float y = clamp(position.y+offset, 0.0, size.y-1.0);\n        \n        result+= texture(tex, vec2(position.x, y) / size)*weights[i];\n    }\n    \n    return result;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 size = vec2(iResolution.x, iResolution.y);\n    fragColor = blurX(fragCoord, iChannel0, size, RADIUS, OFFSET, INTERPOLATION, DIRECTION, DISPLAY_SCALE);\n}","name":"Buffer A","description":"","type":"buffer"}]}