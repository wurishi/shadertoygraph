{"ver":"0.1","info":{"id":"MdjBzh","date":"1505557951","viewed":109,"name":"Simple Distance Field Shader #1","username":"pmpod","description":"Simple distance field shader.\n- shading (coloring?) is based on a marching step number\n- I will use this shader in future to test different effects like AA, texture noise etc.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["simpledistancefield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ----------------------------------------\n// The MIT License\n// Copyright Â© 2017 Piotr Podziemski \n// ----------------------------------------\n\n// A first shader - commented heavily for myself and others at begginer level\n\n//GLOSSARY\n//ro: ray origin    - position of camera\n//rd: ray direction - direction of ray from the position of camera\n\n//-----------------------------------------------------------\n// Helper functions\n//-----------------------------------------------------------\nvec3 rgbNormalized(float r, float g, float b) \n{\n\treturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\n//-----------------------------------------------------------\n// Distance field functions\n//-----------------------------------------------------------\nfloat distSphere(vec3 p, float radius) \n{\n    return length(p) - radius;\n}\n\n//-----------------------------------------------------------\n// [0] main fragment shader function \n//-----------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 eye = vec3(0, 0, -3);\n    vec3 up = vec3(0, 1, 0)*iResolution.y/ iResolution.x ;\n    vec3 right = vec3(1, 0, 0);\n    \n    vec3 focalLength = vec3(0, 0, 1);\n\n    vec4 color = vec4(rgbNormalized(10.0, 20.0, 30.0), 1.0);// Sky color\n \tfloat radius = 0.5; //sphere radius\n    \n    \n    //[1] Coordinates of the fragment we are dealing with right now\t\n    float u = gl_FragCoord.x * 2.0 / iResolution.x - 1.0;\n    float v = gl_FragCoord.y * 2.0 / iResolution.y - 1.0;\n    \n    //[2] Position of ray origin and ray direction\n    vec3 ro = eye+right * u + up * v;           // ro = start position for casted ray\n    vec3 rd = normalize(cross(right, up));  // rd = direction for casted ray\n    \n    //[3] Maximum steps of ray marching through distance field\n    const int maxSteps = 32;                // limit of ray marched steps number\n\n    float deltaR = 0.0;                          //  deltaR = current distance along the ray\n    for(int i = 0; i < maxSteps; ++i)\n    {\n        vec3 p = ro + rd * deltaR;        //current position along the ray\n        float d = distSphere(p,  radius);  // Distance to sphere of radius 0.5\n        float d2 = distSphere(p+vec3(0.35,0.25,0.45),  radius/2.0);  // Distance to small red sphere of radius 0.25\n        float minD = min(d,d2);\n        \n        bool col1 = d < d2 ? true : false;\n        float i_float = float(i);\n        float ms = float(maxSteps);\n        \n        if (minD < 0.00001)\n        {\n            color = vec4(1.0-i_float/(ms*2.0),0.0,0.0, 1.0); // Sphere color\n            if(col1) color = vec4(0.4-i_float/(ms*4.0),0.4-i_float/(ms*4.0),0.4-i_float/(ms*4.0), 1.0); // Sphere color\n            break;\n        }\n\n        deltaR += minD;\n    }\n\n    fragColor = color;\n    \n}\n\n\n","name":"Image","description":"","type":"image"}]}