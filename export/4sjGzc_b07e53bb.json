{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":3,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Created by Ramon Viladomat\n\n// Comment this if the shader renders slow\n#define DRAW_RED_MAGIC \n#define DRAW_GREEN_MAGIC \n#define DRAW_BLUE_MAGIC \n#define DRAW_YELLOW_MAGIC \n\n///////////////////////////////////\n//\n// 3D Out of the screen effect \n//\n///////////////////////////////////\n//\n// Controls:\n//\n// Mouse (X Axis): Rotates camera\n// T: Enables/Disables White Bars\n// S: Enables/Disables Outside the screen shadows\n//\n///////////////////////////////////\n\n\n#define PI 3.1415\n#define EPSILON 0.002\n\n#define SATELITE_RADIUS 4.0\n#define MAGIC_RADIUS\t3.3\n#define SATELLITE_RADIUS 0.5\n#define PLANET_RADIUS \t3.0\n\n#define CAM_ROTATION_SPEED 0.1\n#define SAT_ROTATION_SPEED 1.5\n\n#define SOFTSHADOW_BANDWIDTH 0.5\n\n#define BAR_SEPARATION 0.7\n#define BAR_WIDTH 0.05\n#define BAR_DEPTH 4.1\n\nvec3 ballPos = vec3(0.0);\n\n///////////////\n// MATERIALS //\n///////////////\n\nvec2 GetNormalMap(in sampler2D s, in vec2 resolution, in vec2 uv)\n{\n\tvec3 eps=vec3(1.0/resolution,0.0);\n\tvec2 norm = vec2(length(texture(s,uv+eps.xz)) - length(texture(s,uv-eps.xz)),\n\t\t\t\t\t length(texture(s,uv+eps.zy)) - length(texture(s,uv-eps.zy)));\n\t\n\treturn norm;\n}\t\n\nvec4 calcColor( in vec3 pos, in vec3 nor, in float material, out vec3 normal )\n{\n\tvec4 materialColor = vec4(0.0);\n\t\n\tvec3 q = pos - mix(ballPos,vec3(0.0),material);\n\tfloat radius = mix(0.5,3.0,material);\n\tvec2 angles = vec2(atan(abs(q.z)/abs(q.x)),acos(q.y/radius));\n\t\n\tfloat mixer = step(1.0,material);\n\t\n\tmaterialColor = mix(vec4(vec3(1.0,0.2,0.2)*texture(iChannel2,angles).xyz,0.05),vec4(texture(iChannel0,angles).xyz,0.30),mixer);\t\n\tvec2 normalMap = mix(4.0*GetNormalMap(iChannel2,iChannelResolution[2].xy,angles),GetNormalMap(iChannel0,iChannelResolution[0].xy,angles),mixer);\n\t\t\n\tvec3 left = normalize(cross(vec3(0.0,1.0,0.0),nor));\n\tvec3 up = normalize(cross(left,nor));\n\tnormal = normalize(normalMap.x*left + nor + normalMap.y*up);\n\t\n\treturn materialColor;\n}\n\nfloat GetTrail(in vec3 pos, in float angle, in vec3 movement, in vec3 params, in vec2 sine)\n{\n\tfloat rotAngle = movement.x+iTime*movement.y;\n\tvec2 refPos = MAGIC_RADIUS*vec2(sin(rotAngle),cos(rotAngle));\n\tvec2 refFwd = vec2(-refPos.y,refPos.x);\n\t\n\tfloat hVert = pos.y - movement.z;\n\tfloat hDist = length(pos.xz - refPos);\n\t\n\tfloat fl = max(dot(pos.xz,refFwd),0.0)*(1.0 - smoothstep(0.0,params.x,hDist));\n\tfloat fh = 1.0 - smoothstep(0.0,params.y,abs(hVert+params.z*sin(sine.x*angle+sine.y)));\n\t\n\treturn fl*fh;\n}\n\nvec3 GetAlphaColor(in vec3 pos)\n{\n\tvec3 ret = vec3(0.0);\n\tfloat angle = atan(pos.z/pos.x);\n\t\n#ifdef DRAW_RED_MAGIC\n\tret += vec3(1.0,0.0,0.0)*GetTrail(pos,angle,vec3(0.0,1.1, 0.0),vec3(8.0,0.1,0.5),vec2(4.0,0.0));\n#endif\n#ifdef DRAW_GREEN_MAGIC\n\tret += vec3(0.0,1.0,0.0)*GetTrail(pos,angle,vec3(0.5,2.1, 0.5),vec3(8.0,0.1,0.8),vec2(2.0,1.0));\n#endif\n#ifdef DRAW_BLUE_MAGIC\n\tret += vec3(0.0,0.0,1.0)*GetTrail(pos,angle,vec3(0.9,3.7,-1.0),vec3(8.0,0.1,0.2),vec2(6.0,2.0));\n#endif\n#ifdef DRAW_YELLOW_MAGIC\n\tret += vec3(1.0,1.0,0.0)*GetTrail(pos,angle,vec3(0.1,1.7,0.5),vec3(8.0,0.1,1.0),vec2(2.0,9.0));\t\n#endif\n\treturn ret;\n}\n\n/////////////////\n// RAY METHODS //\n/////////////////\n\nfloat raySphereIntersection( in vec3 ro, in vec3 rd, in vec3 center, in float radius, float multiplier)\n{\n\tfloat res = 9999.0;\n\tvec3 oc = ro - center;\n\tfloat b = dot(rd,oc); //should be 2*rd*oc but the 2 gets eliminated after expanding the quadratic equation\n\tfloat c = dot(oc,oc)-(radius*radius);\n\t\n\tfloat bminac = (b*b)-c;\n\tif (bminac >= 0.0)\n\t{\n\t\t//intersection\n\t\tfloat sqrtbminac = sqrt(bminac);\n\t\tfloat t = (-b + multiplier*sqrtbminac);\n\t\tres = mix(res,t,step(0.0,t));\n \t}\n\t\n\treturn res;\n\t\n}\n\nfloat shadowRaySphere(in vec3 ro, in vec3 rd, vec4 sphere)\n{\n\tfloat lambda = dot(-(ro - sphere.xyz),rd);\n\tfloat dist = length((ro+rd*lambda)-sphere.xyz)-sphere.w;\n\treturn mix(9999.0,dist,step(0.0,lambda)); \n}\n\n////////////////\n// RAY TRACER //\n////////////////\n\nvec2 intersect( in vec3 ro, in vec3 rd)\n{\n\tvec2 res = vec2(9999.0,-1.0);\n\t\n\tvec2 centerSatellite = vec2(raySphereIntersection(ro,rd,ballPos,SATELLITE_RADIUS,-1.0),0.0);\n\tvec2 centerPlanet = vec2(raySphereIntersection(ro,rd,vec3(0.0),PLANET_RADIUS,-1.0),1.0);\n\t\n\tif (centerSatellite.x < res.x) res = centerSatellite; \n\tif (centerPlanet.x < res.x) res = centerPlanet; \n\t\n\treturn res;\n}\n\nfloat GetShadows( in vec3 ro, in vec3 rd)\n{\n\tfloat shadowSatellite = shadowRaySphere(ro,rd,vec4(ballPos,SATELLITE_RADIUS));\n\tfloat shadowPlanet = shadowRaySphere(ro,rd,vec4(0.0,0.0,0.0,PLANET_RADIUS));\n\t\n\treturn smoothstep(0.0,SOFTSHADOW_BANDWIDTH,min(shadowSatellite,shadowPlanet));\n}\n\nvec3 GetTransparency( in vec3 ro, in vec3 rd, float depth)\n{\n\tfloat back = raySphereIntersection(ro,rd,vec3(0.0),MAGIC_RADIUS,1.0);\n\tfloat front = raySphereIntersection(ro,rd,vec3(0.0),MAGIC_RADIUS,-1.0);\n\n\treturn GetAlphaColor(ro+rd*back)*step(back,depth) + GetAlphaColor(ro+rd*front)*step(front,depth);\n}\n\n//////////////////////\n// MAIN RAY/SHADING //\n//////////////////////\n\nvec3 calcNormal( in vec3 pos, in vec2 tmat)\n{\n\treturn normalize(pos-mix(ballPos,vec3(0.0),tmat.y));\n}\n\nfloat softShadow( in vec3 ro, in vec3 rd )\n{\n\tfloat scene = GetShadows(ro,rd);\n\tfloat alpha = 1.0 - 0.8*clamp(length(GetTransparency(ro,rd,9999.0)),0.0,1.0);\n    return min(alpha,scene);\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\t\n\t// Compute Camera\n\tvec2 mousePos = iMouse.xy/iResolution.xy;\n\t\n\t//move camera when clicking\n\tfloat animatedCamAngle = -0.7 + iTime*CAM_ROTATION_SPEED;\n\tfloat inputCamAngle = PI + 2.0*PI*mousePos.x;\n\t\n\tfloat camAngle = mix(animatedCamAngle,inputCamAngle,clamp(iMouse.z,0.0,1.0));\n\tfloat camDist = 7.0; \n\t\n    vec3 camPosition = camDist*normalize(vec3(sin(camAngle), 0.0, cos(camAngle)));\n    vec3 camTarget\t = vec3( 0.0, 0.0, 0.0 );\n    vec3 camFront \t = normalize( camTarget - camPosition );\n    vec3 camRight \t = normalize( cross(camFront,vec3(0.0,1.0,0.0) ) );\n    vec3 camUp \t\t = normalize( cross(camRight,camFront));\n\tvec3 rayRaw \t = p.x*camRight + p.y*camUp + 2.0*camFront;\n    vec3 rayDir \t = normalize( rayRaw );\n\t\n\t// light compute (fake fire light)\n\tvec3 lightPos1 = vec3(100.0,50.0,100.0);\n\tvec3 lightColor1 = vec3(1.0,0.7,0.0);\n\t\n\t//Update World\n\tfloat rotAngle = PI + SAT_ROTATION_SPEED * iTime; \n\tballPos = SATELITE_RADIUS * vec3(sin(rotAngle),0.0,cos(rotAngle));\n\t\t\n\t//Compute Screen Shadow\n\tvec3 barPos = camPosition + rayRaw*0.5*BAR_DEPTH;\n\tvec3 lightDirExt = normalize(camPosition - barPos);\n\tfloat screen_shadow = GetShadows(barPos,lightDirExt);\n\t\n\t//Start Ray\n    vec3 finalcolor = vec3(0.0);\n\tfloat attenuation = 1.0;\n\tfloat depth = 9999.0;\n\tfor( int reflectCount=0; reflectCount<2; reflectCount++ )\n\t{\n\t\tfloat isFirst = min(float(reflectCount),1.0);\n\t\t\n\t\t// Compute color for single ray\n    \tvec2 tmat = intersect(camPosition,rayDir);\n\t\tvec3 alpha = GetTransparency(camPosition,rayDir,tmat.x);\n\t\t\n\t\tfinalcolor += attenuation*alpha;\n\t\t\n\t\tif (tmat.y > -0.5)\n\t\t{\n\t\t\tdepth = mix(tmat.x,depth,isFirst);\n\t\t\t\n\t\t\t// results extraction\n\t\t\tvec3 position \t= camPosition + tmat.x*rayDir;\n\t\t\tvec3 normal \t= calcNormal(position,tmat);\n\t\t\t\n\t\t\t// lights and materials \n\t\t\tvec3 normalMod = vec3(0.0);\n\t\t\tvec4 materialColor \t= calcColor( position, normal, tmat.y , normalMod);\n\t\t\tnormal = normalMod;\n\t\t\t\n\t\t\tfloat ambient  \t\t= 0.7 + 0.3*normal.y;\n\t\t\tvec3 ambientColor \t= ambient*materialColor.rgb;\n\t\t\t\n\t\t\t//light 1 ( specular computed through reflections )\n\t\t\tvec3 lightDir1 \t= normalize(lightPos1 - position);\n\t\t\t\n\t\t\tfloat diffuse1  = max(dot(normal,lightDir1),0.0);\n\t\t\tfloat shadow1   = softShadow( position, lightDir1 );\n\t\t\t\n\t\t\tvec3 diffuseColor1 = diffuse1*lightColor1*materialColor.rgb;\n\t\t\tvec3 ilumColor1 = shadow1*diffuseColor1;\n\t\t\t\n\t\t\t// mixing lights\n\t\t\tfinalcolor += attenuation*mix(ambientColor,ilumColor1,0.8);\n\t\t\t\n\t\t\t// prepare next ray for reflections \n\t\t\trayDir = reflect(rayDir,normal);\n\t\t\tattenuation *= 2.0*materialColor.w;\n\t\t\tcamPosition = position + EPSILON*normal;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//stars achieved via noise texture\n\t\t\tvec2 angles = vec2(atan(rayDir.z/abs(rayDir.x)),acos(rayDir.y));\t\n\t\t\tfloat a1 = texture(iChannel1,angles).x;\n\t\t\tfloat a2 = texture(iChannel1,angles*2.0+0.01).x;\n\t\t\tfloat a3 = texture(iChannel1,angles*2.1+0.07).x;\n\t\t\tfloat a4 = texture(iChannel1,angles*5.0+0.03).x;\n\t\t\t\n\t\t\tfloat stars = smoothstep(0.1,1.0,a1*a2*a3*a4);\n\t\t\tfloat sun = 10.0 * pow(max(dot(normalize(lightPos1 - camPosition),rayDir),0.0),200.0);\n\t\t\t\n\t\t\tfinalcolor += attenuation*(lightColor1*sun + stars*vec3(0.5));\n\t\t\tattenuation = 0.0;\n\t\t}\n\t\t\t\t\t\n\t}\n\t\n\t// vignette\n\tfinalcolor *= mix(vec3(1.0),vec3(0.6,0.2,0.2),length(p)*0.5);\n\t\n\t// 3D magic trick - white bars\n\tdepth = mix(depth,0.0,texture( iChannel3, vec2(84.5/256.0,0.75) ).x); // toggle T key\n\tscreen_shadow = mix(0.2+0.8*screen_shadow,1.0,texture( iChannel3, vec2(83.5/256.0,0.75) ).x); //Toggle S Key\n\t\n\tfloat barFactor = 1.0 - smoothstep(0.0,0.01,abs((abs(p.x)-BAR_SEPARATION))-BAR_WIDTH);\n\tfloat depthFactor = step(BAR_DEPTH,depth);\n\tvec3 barColor = vec3(0.6)*screen_shadow;\n\tfinalcolor = mix(finalcolor,barColor,depthFactor*barFactor);\n\t\n\t// desaturation, gamma correction\n\tfinalcolor = pow(mix( finalcolor, vec3(dot(finalcolor,vec3(0.33))), 0.3 ), vec3(0.45));\n\n    fragColor = vec4( finalcolor, 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":true,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sjGzc","date":"1392057885","viewed":1228,"name":"3D Planet Illusion","username":"Ramocles","description":"Inspired by ( http://www.wikitree.us/story/2052 ) I wanted to give the effect of a 3D satellite going out of the screen. Test for raytrace, normalmap and alpha elements. \ncontrols: mouse (X: rotation), keyboard (T: 3d effect bars, S: Bars shadows) ","likes":39,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","transparency","normalmap","illusion"],"hasliked":0,"parentid":"","parentname":""}}