{"ver":"0.1","info":{"id":"lcfBR7","date":"1723504202","viewed":27,"name":"Hyperbolic_Tetrahedron_6","username":"afoksha","description":"Renders tesselation of the hyperbolic space by tetrahedron with dihedral angle 2π/6. This tetrahedron is ideal, e.g. has vertices at ∞.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["dodecahedron","hyperbolicspace","lorentzspace","hyperboloidmodel"],"hasliked":0,"parentid":"MfXBR7","parentname":"Hyperbolic_Octahedron_4"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//==========================================================================================================================\n//  Created by Alexander Foksha\n//\n//  Do with this or without this code whatever you wish at your own risk.\n//  You have been warned !!\n//==========================================================================================================================\n\nfloat hyp_dot(vec4 u, vec4 v)\n    { return dot(u.xyz, v.xyz) - u.w * v.w; }\n    \nvec4 normalize_t(vec4 v)\n{\n    float inv_l = 1.0f / sqrt(-hyp_dot(v, v));\n    return inv_l * v;\n}\n\nfloat arccosh(float q)\n{\n    q = max(q, 1.0f);\n    float s = q + sqrt(q * q - 1.0f);\n    return log(s);\n}\n\nfloat arccosh_sqrt(float q)\n{\n    q = max(q, 1.0f);\n    float s = sqrt(q) + sqrt(q - 1.0f);\n    return log(s);\n}\n\n/* space-like vector normalization :: scales the vector to get\n   xx + yy + zz - ww = +1. Tangent directions to H^3 are space-like 4-vectors */\nvec4 normalize_s(vec4 v)\n{\n    float norm = dot(v.xyz, v.xyz) - v.w * v.w;\n    float inv_l = 1.0f / sqrt(norm);\n    return inv_l * v;\n}\n\nconst float beta   = 0.4330127018922193f;           /* sqrt(3) / 4 */\nconst float gamma  = 1.25f;                         /* 5 / 4 */\nconst float psi    = 0.6123724356957945f;           /* sqrt(3) / (2 * sqrt(2)) */\nconst float chi    = 0.3535533905932738f;           /* 1 / (2 * sqrt(2)) */\nconst float mu     = 0.7071067811865475f;           /* 1 / sqrt(2) */\nconst float tau    = 1.2247448713915890f;           /* sqrt(3) / sqrt(2) */\nconst float omega  = 1.7320508075688773f;           /* sqrt(3) */\nconst float lambda = 0.8660254037844386f;           /* sqrt(3) / 2 */\n\n//==========================================================================================================================\n//      The main function: finds the point in the orbit of p under the action of hyperbolic reflections\n// group closest to the origin, or, the same, finds point equivalent to p in the main fundamental tetrahedron\n//==========================================================================================================================\n/*  Reflection directions ::\n\n    {  psi,  psi, -psi, chi }\n    { -psi,  psi,  psi, chi }\n    {  psi, -psi,  psi, chi }\n    { -psi, -psi, -psi, chi }\n*/\nvec4 bounce(vec4 P)\n{\n    int k = 0;\n\n    /* lambda = sqrt(2) * psi */\n    const vec3 K = vec3(lambda, -lambda, 0.5f);\n    /* to avoid possible infinite loops for points lying on the faces of the main tetrahedron */\n    while (k < 12)\n    {\n        vec4 q = P.x * K.xyxy + P.y * K.xxyy + P.z * K.yxxy;\n        vec2 m = max(q.xy, q.zw);\n        float M = max(m.x, m.y);\n\n        /* maximal hyperbolic dot product of P with reflection vectors (scaled by sqrt(2)) */\n        float dp = M - K.z * P.w;\n\n        if (dp <= 0.0f) break;\n\n        if (q.w >= M)           /* -psi * p.x - psi * p.y - psi * p.z is maximal */\n            P -= dp * K.yyyz;\n        else if (q.x >= M)      /*  psi * p.x + psi * p.y - psi * p.z is maximal */\n            P -= dp * K.xxyz;\n        else if (q.y >= M)      /* -psi * p.x + psi * p.y + psi * p.z is maximal */\n            P -= dp * K.yxxz;\n        else                    /*  psi * p.x - psi * p.y + psi * p.z is maximal */\n            P -= dp * K.xyxz;\n\n        ++k;\n    }\n\n    return P;\n}\n\nfloat spheric_sdf(vec4 p)\n{\n    p = bounce(p);\n    float d = arccosh(p.w);\n    float sdf0 = d - 0.13f;\n    float sdf1 = 0.561f - d;\n    return min(sdf0, sdf1);\n}\n\n/*  Centers of the neighbouring fundamental domains ::\n\n    {  beta,  beta, -beta, gamma }\n    { -beta,  beta,  beta, gamma }\n    {  beta, -beta,  beta, gamma }\n    { -beta, -beta, -beta, gamma }\n*/\nfloat face_sdf(vec4 p)\n{\n    p = bounce(p);\n    float d0 = arccosh(p.w);\n\n    vec2 c = vec2(beta, -beta);\n    vec4 q = p.x * c.xyxy + p.y * c.xxyy + p.z * c.yxxy;\n    vec2 s = max(q.xy, q.zw);\n\n    float dp = gamma * p.w - max(s.x, s.y);\n    float d1 = arccosh(dp);\n\n    float b_sdf = 0.507f - d0;\n    float f_sdf = 0.5f * (d1 - d0 - 0.016f);\n\n    return max(b_sdf, f_sdf);\n}\n\n/*  Centers of edges and rays tangent to edges at center ::\n\n        { +mu,   0,   0, tau }  {   0, +mu, +mu, 0 }\n        {   0, +mu,   0, tau }  { +mu,   0, +mu, 0 }\n        {   0,   0, +mu, tau }  { +mu, +mu,   0, 0 }\n\n        { -mu,   0,   0, tau }  {   0, -mu, +mu, 0 }\n        {   0, -mu,   0, tau }  { +mu,   0, -mu, 0 }\n        {   0,   0, -mu, tau }  { -mu, +mu,   0, 0 }\n\n    Squared hyperbolic cosines of the distances to the edges ::\n    [ omega = sqrt(3) ]\n\n        ((x - omega * w)^2 - (y + z)^2) / 2 = 0.5 + ww + xx - (omega * xw + yz)\n        ((y - omega * w)^2 - (z + x)^2) / 2 = 0.5 + ww + yy - (omega * yw + zx)\n        ((z - omega * w)^2 - (x + y)^2) / 2 = 0.5 + ww + zz - (omega * zw + xy)\n\n        ((x + omega * w)^2 - (y - z)^2) / 2 = 0.5 + ww + xx + (omega * xw + yz)\n        ((y + omega * w)^2 - (z - x)^2) / 2 = 0.5 + ww + yy + (omega * yw + zx)\n        ((z + omega * w)^2 - (x - y)^2) / 2 = 0.5 + ww + zz + (omega * zw + xy)\n*/\nfloat edge_sdf(vec4 p)\n{\n    p = bounce(p);\n    float r = omega * p.w;\n    vec3 Q = p.xyz * p.xyz - abs(r * p.xyz + p.yzx * p.zxy);\n    float q = 0.5f + p.w * p.w + min(Q.x, min(Q.y, Q.z));\n\n    float a = arccosh_sqrt(q);\n\n    float e_sdf = a - 0.0475f;\n    return e_sdf;\n}\n\nfloat edge_face_sdf(vec4 p)\n{\n    p = bounce(p);\n\n    /* edge sdf */\n    float r = omega * p.w;\n    vec3 Q = p.xyz * p.xyz - abs(r * p.xyz + p.yzx * p.zxy);\n    float q = 0.5f + p.w * p.w + min(Q.x, min(Q.y, Q.z));\n    float a = arccosh(sqrt(q));\n    float e_sdf = a - 0.1275f;\n\n    /* face sdf */\n    float d0 = arccosh(p.w);\n    vec2 c = vec2(beta, -beta);\n    vec4 s = p.x * c.xyxy + p.y * c.xxyy + p.z * c.yxxy;\n    s.xy = max(s.xy, s.zw);\n    float dp = gamma * p.w - max(s.x, s.y);\n    float d1 = arccosh(dp);\n    float b_sdf = 0.507f - d0;\n    float f_sdf = 0.5f * (d1 - d0 - 0.016f);\n    f_sdf = max(b_sdf, f_sdf);\n\n    return min(e_sdf, f_sdf);\n}\n\nfloat sdf(vec4 p)\n{\n    //return spheric_sdf(p);\n    //return face_sdf(p);\n    //return edge_sdf(p);\n    return edge_face_sdf(p);\n}\n\nvec4 raymarch(vec4 origin, vec4 ray, out float dist)\n{\n    const float eps = 0.0005f;\n    dist = -1.0f;\n\n    vec4 p = origin;\n    float d = sdf(p);\n    float t = 0.0f;\n\n    const int MAX_ITERATIONS = 64;\n\n    int i = 0;\n    while ((i < MAX_ITERATIONS) && (d > eps) && (t < 32.0))\n    {\n        t += d;\n        float s = sinh(t);\n        float c = cosh(t);\n        p = c * origin + s * ray;\n        d = sdf(p);\n        ++i;\n    }\n\n    if (d < 0.05f)\n        dist = t;\n\n    return p;\n}\n//==============================================================================================================================================================\n//      SDF gradient :: standard 6-point evaluation\n//      Standard orthonormal basis at origin parallel translated along the geodesic into a generic point P = { x, y, z, w }\n//  looks like:\n//\n//       X = { 1.0f + (x * x) / (w + 1),        (x * y) / (w + 1),        (x * z) / (w + 1), x },\n//       Y = {        (y * x) / (w + 1), 1.0f + (y * y) / (w + 1),        (y * z) / (w + 1), y },\n//       Z = {        (z * x) / (w + 1),        (z * y) / (w + 1), 1.0f + (z * z) / (w + 1), z },\n//\n//      They are normalized, orthogonal among themselves and orthogonal to P.\n//==============================================================================================================================================================\nvec4 hyperbolic_gradient6(vec4 p)\n{\n    float x = p.x;\n    float y = p.y;\n    float z = p.z;\n    float inv_w = 1.0f / (1.0f + p.w);\n\n    vec4 X = vec4(1.0f + inv_w * x * x,        inv_w * x * y,        inv_w * x * z, x);\n    vec4 Y = vec4(       inv_w * y * x, 1.0f + inv_w * y * y,        inv_w * y * z, y);\n    vec4 Z = vec4(       inv_w * z * x,        inv_w * z * y, 1.0f + inv_w * z * z, z);\n\n    const float eps = 0.00625f;\n\n    float di = sdf(normalize_t(p + eps * X)) - sdf(normalize_t(p - eps * X));\n    float dj = sdf(normalize_t(p + eps * Y)) - sdf(normalize_t(p - eps * Y));\n    float dk = sdf(normalize_t(p + eps * Z)) - sdf(normalize_t(p - eps * Z));\n\n    vec4 g = di * X + dj * Y + dk * Z;\n    return normalize_s(g);\n}\n\n/* distance to origin :: arccosh(2) = 1.316958 */\nconst vec4 light_ws[8] = vec4[]\n(\n    vec4(+1, +1, +1, 2),\n    vec4(+1, +1, -1, 2),\n    vec4(+1, -1, +1, 2),\n    vec4(+1, -1, -1, 2),\n    vec4(-1, +1, +1, 2),\n    vec4(-1, +1, -1, 2),\n    vec4(-1, -1, +1, 2),\n    vec4(-1, -1, -1, 2)\n);\n\n//==============================================================================================================================================================\n//   Computes direction in 4-space hyperbolic-orthogonal to P, A, and B\n//   Note: if P is time-like (e.g. represents a point), and A, B are \n// space-like (e.g. represent directions) then cross-product is also space-like, \n// so is space-like normalizable\n//==============================================================================================================================================================\nvec4 hyp_cross(vec4 P, vec4 A, vec4 B)\n{\n    /* six 2x2 minors constructed from the rows A and B */\n    vec4 det2x2_1 = A * B.yzwx - B * A.yzwx;       /* xy, yz, zw, wx */\n    vec2 det2x2_2 = A.xy * B.zw - B.xy * A.zw;     /* xz, yw */\n\n    return vec4( \n        +P.y * det2x2_1.z - P.z * det2x2_2.y + P.w * det2x2_1.y,\n        -P.z * det2x2_1.w - P.w * det2x2_2.x - P.x * det2x2_1.z,\n        +P.w * det2x2_1.x + P.x * det2x2_2.y + P.y * det2x2_1.w,\n        +P.x * det2x2_1.y - P.y * det2x2_2.x + P.z * det2x2_1.x\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 1.77f * (fragCoord - 0.5f * iResolution.xy) / iResolution.y;\n\n    float t = 0.97f * iTime;\n\n    float t0 = 0.375f * t -  0.213f;\n    float t1 = 0.151f * t +  2.091f;\n    float t2 = 0.253f * t - 11.512f;\n    float t3 = 0.853f * t +  3.277f;\n\n    float c0 = cos(t0);\n    float s0 = sin(t0);\n    float c1 = cos(t1);\n    float s1 = sin(t1);\n    float c2 = cos(t2);\n    float s2 = sin(t2);\n    float c3 = cos(t3);\n    float s3 = sin(t3);\n    \n    float R = 1.32f + 0.32f * c1 + 0.371f * s0;\n    float W = sqrt(1.0f + R * R);\n    vec3 camera_xyz = R * normalize(vec3(-c1 * s0, s1 *  c0 * s2, s0 * c2));\n    vec4 camera_ws = vec4(camera_xyz, W);\n\n    /* compute some random directions in 3 space, lift them to hyperboloid and \n       apply Gram-Schmidt orthogonalization process on the fly */\n\n    float r = 0.75f;                                 /* look at close to origin */\n    vec3 z = camera_xyz + r * vec3(s1 * c0, -s0 * c2, s3 *  c1 * s2); \n    vec4 Z = vec4(z, dot(camera_xyz, z) / W);        /* lift it up to hyperboloid tangent space, Z is orthogonal to camera_ws */\n    Z = normalize_s(Z);                              /* normalize */\n    \n    vec3 x = vec3(s2 * c0, -s1 * c1, c2);            /* generate some random direction */\n    vec4 X = vec4(x, dot(camera_xyz, x) / W);        /* lift it up to hyperboloid tangent space, X is orthogonal to camera_ws */\n    X = X - hyp_dot(X, Z) * Z;                       /* make it hyperbolic-orthogonal to Z, it should remain orthogonal to camera_ws */\n    X = normalize_s(X);                              /* normalize */\n\n    vec4 Y = hyp_cross(camera_ws, Z, X);             /* compute the last basis vector as a cross product */\n    Y = normalize_s(Y);                              /* normalize, should not be needed */\n\n    vec4 view_ray = uv.x * X + uv.y * Y - Z;\n    view_ray = normalize_s(view_ray);\n\n    float dist;\n    vec4 position = raymarch(camera_ws, view_ray, dist);\n    vec3 color = vec3(0.0f);\n\n    if (dist >= 0.0f && dist < 7.2f)\n    {\n        float W = position.w;\n        vec4 n = hyperbolic_gradient6(position);\n        \n        const vec3 hue = vec3(1.41f, 1.73f, 2.72f);\n        float c = 1.0 / (1.0f + 0.175f * sqrt(position.w));\n        vec3 rgb = pow(vec3(c), 4.0f * hue);\n\n        vec3 view = camera_ws.xyz - position.xyz;\n        vec4 v = vec4(view, dot(view, position.xyz) / W);\n        v = normalize_s(v);                                     /* unit view vector at tangent space at position */\n\n        color = 0.225f * rgb;                                   /* ambient */\n\n        for (int i = 0; i < 8; ++i)\n        {\n            vec4 light = light_ws[i];\n            float dp = dot(light.xyz, position.xyz);\n            float hyp_dp = W * light.w - dp;                    /* ch(distance), can be used directly for attenuation */\n\n            /* lift of the light direction to the hyperboloid */\n            vec4 l = vec4(light.xyz - position.xyz, -W + ((dp + 1.0f) / W));\n            l = normalize_s(l);                                 /* unit light vector at tangent space at position */\n\n            float a = 0.75f / (1.0f + 0.025f * hyp_dp);\n\n            float cos_theta = max(hyp_dot(l, n), 0.0f);\n            vec4 h = normalize_s(l + v);\n\n            float cos_alpha = max(hyp_dot(h, n), 0.0f);\n            vec3 diffuse  = (0.475f * cos_theta) * rgb;\n            vec3 specular = vec3(0.562f) * pow(cos_alpha, 88.0f);\n\n            color += a * (diffuse + specular);\n        }\n    }\n\n    fragColor = vec4(color, 1.0f);\n}","name":"Image","description":"","type":"image"}]}