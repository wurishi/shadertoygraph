{"ver":"0.1","info":{"id":"7ddGWN","date":"1629910582","viewed":244,"name":"Metallic Menger Sponge","username":"otkazano","description":"Menger Sponge with simple reflection.","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractals","reflections","mengersponge"],"hasliked":0,"parentid":"fdc3D8","parentname":"Menger Test 1.001"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nMenger Sponge with simple reflection.\nNO OPTIMIZED!\n*/\n\n//scene params\n#define SpongeMaxIterations 5\n#define CyclePeriod 10.0\n#define IdlePeriod 6.0\n#define SolidPeriod 4.0\n\n//quality params\n#define subSamples 5\n\n//uv screen params\n#define du 0.5\n#define dv 0.5\n#define iR vec2(1.0/iResolution.x, 1.0/iResolution.y)\n//camera params\n#define CameraZoom 0.75\n#define CameraDistance 5.0\n//mice params\n#define miceFactor vec2(-9.0, 3.0)\n//march tracing params\n#define MarchMaxDistance 1e3\n#define MarchSteps 80\n#define MarchThreshold 1e-3\n#define MarchNormalPrecision 0.03/float(SpongeMaxIterations+1)\n\n\n\nfloat mtf;\n\nmat2 rotate(float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\nfloat sdSphere(vec3 orgn, vec3 pos, float r){\n    return length(pos-orgn)-r;\n}\nfloat sdBox(vec3 orgn, vec3 pos, vec3 size){\n    vec3 p = abs(pos-orgn)-size;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n    \n}\nfloat crosshair(vec3 orgn, float size){\n    float far = 200.0;\n    return min(min(sdBox(orgn,vec3(0.0),vec3(far,size,size)), sdBox(orgn,vec3(0.0),vec3(size,far,size))),sdBox(orgn,vec3(0.0),vec3(size,size,far)));\n}\nfloat mengerSponge(vec3 orgn, vec3 pos,float size, int iterations){\n    pos = pos-orgn;\n    vec3 c = abs(pos)-size;\n    float dist = max(max(c.x,c.y),c.z);\n    \n    vec3 p = pos;\n    float space;\n    float ii;\n    for(int i=1; i<=iterations; i++){\n        ii = float(i);\n        p = pos;\n        space = size*pow(1.0/3.0,ii-1.0) * 2.0;\n        p = mod(p+space*0.5,space);\n        p = p-space*0.5;\n        dist = max(-crosshair(p, size*pow(1.0/3.0,ii)), dist);\n    }\n    return dist;\n}\n\n\nfloat distMap(vec3 pos){\n    float initSize = 0.5;\n    \n    //distField optomize\n    float phase1 = sdSphere(pos, vec3(0.0), 1.75*initSize*pow(pow(27.0/20.0,float(SpongeMaxIterations)),1.0/3.0));\n    if(phase1 > MarchThreshold*10.0){\n        return phase1;\n    }\n    \n    int it1 = 0;\n    int it2 = 0;\n    int maxIterations = SpongeMaxIterations;\n\n\n    \n    float period = CyclePeriod;\n    float idle = IdlePeriod;\n    float solid = SolidPeriod;\n    float fullPeriod = period * float(SpongeMaxIterations+1);\n    \n    float transFunction = min(mod(iTime,period)/(period-idle),1.0);\n    float solidFunction = max((min(abs(-2.0*(mod(iTime,period)-(period-idle)-idle/2.0)/idle),1.0)-1.0)*(2.0/(idle-solid))+1.0, 0.0);\n    float influFunction = pow(smoothstep(0.0,1.0,transFunction),1.0);\n    mtf = solidFunction;\n\n    it1 = int(mod(iTime/period,float(maxIterations+1)));\n    it2 = int(mod((iTime+period)/period,float(maxIterations+1)));\n    \n    \n    float influence = pow(pow(27.0/20.0,1.0/3.0),float(it1)+influFunction);\n\n\n    \n\n    if(it2==0){\n        mtf = 1.0;\n        influence = mix(pow(pow(27.0/20.0,1.0/3.0),float(maxIterations)),1.0,1.0-pow(smoothstep(1.0,0.0,transFunction),3.0));\n    }\n    \n    float fig1 = mengerSponge(pos, vec3(0.0,0.0,0.0), initSize*influence, it1);\n    float fig2 = mengerSponge(pos, vec3(0.0,0.0,0.0), initSize*influence, it2);\n    \n    return mix(fig1, fig2, smoothstep(0.0,1.0,transFunction)) + (0.01*sin(length(pos)*9.0-iTime*3.9)/(influence+1.0) + (sin(pos.x*15.7+iTime*9.0)+sin(pos.y*16.1+iTime*7.0)+sin(pos.z*17.2+iTime*8.0))*0.001)*(pow(mtf,3.0))/float(it1+1);\n}\nvec3 getNormal(vec3 pos){\n    float e = MarchNormalPrecision;\n    int id;\n    vec3 options;\n    float anchor = distMap(pos);\n    return normalize(vec3(\n        anchor - distMap(pos-vec3(e,0.0,0.0)),\n        anchor - distMap(pos-vec3(0.0,e,0.0)),\n        anchor - distMap(pos-vec3(0.0,0.0,e))\n     ));\n}\n\nvec4 rayMarch(vec3 position, vec3 direction, float dirFactor, out float pathLen){\n    float dist = 0.0;\n    pathLen = 0.0;\n    for(int i=0; i<MarchSteps; i++){\n        dist = distMap(position);\n        pathLen += dist;\n        if(dist<=MarchThreshold || dist>=MarchMaxDistance) break;\n        position += direction*dirFactor*dist;\n    }\n    return vec4(position, dist);\n}\n\nvec2 mice(){\n    return vec2(iMouse.x/iResolution.x-.5,iMouse.y/iResolution.y-.5);\n}\n\nvec3 getDirection(vec2 uv, vec2 angle, float zoom, out vec3 pos){\n    vec3 n = normalize(vec3(uv.x,-uv.y,zoom));\n    pos = vec3(0.0, 0.0, -CameraDistance);\n    pos.yz *= rotate(angle.y);\n    pos.xz*= rotate(angle.x);\n    n.yz*= rotate(angle.y);\n    n.xz*= rotate(angle.x);\n    return n;\n}\n\nvec4 sky(vec3 dir, float k, float sh){\n    float sharpness = 1.0-sh;\n    vec3 upCol = mix(vec3(0.7,0.8,0.9)*1.5,vec3(0.6,0.75,0.9),(1.0+dir.z)*0.5);\n    vec3 dnCol = mix(vec3(0.2,0.4,0.7),vec3(0.2,0.3,0.5)*.6,(1.0+dir.z)*0.5);\n    return vec4(vec3(mix(upCol,dnCol,(mix(dir.y,pow(abs(dir.y),sharpness)*sign(dir.y), k)+1.0)*0.5)),1.0);\n}\nvec3 frameSubProcessing(vec2 uv){\n    vec3 pos;\n    vec3 dir = getDirection(uv, mice()*miceFactor, CameraZoom, pos);\n    vec3 norm;\n    float pathLen;\n        \n    vec4 d = rayMarch(pos, dir, 1.0, pathLen);  \n    norm = getNormal(d.xyz);\n    \n    vec3 mat1_Col = vec3(0.99,0.99,0.99)*.9;\n    vec3 mat2_Col = vec3(0.99,0.85,0.80)*.9;\n    \n    if(d.w < MarchMaxDistance){\n        return sky(reflect(dir,norm),mix(0.22,.99,mtf),mix(0.1,.99,mtf)).rgb * mix(mat1_Col,mat2_Col,mtf);\n    }\n    return sky(dir,0.99,.9).rgb;\n}\nvec3 frameProcessing(vec2 uv){\n    float ss = float(subSamples);\n    vec3 c = vec3(0.0);\n    float delta = 1.0/(ss+1.0), pixSize = 1.0/iResolution.x;\n    delta *= pixSize;\n    float dx, dy;\n    dy = 0.0;\n    for(int y=0; y<subSamples; y++){\n        dy += delta;\n        dx = 0.0;\n        for(int x=0; x<subSamples; x++){\n            dx += delta;\n            c += frameSubProcessing(uv+vec2(dx,dy));\n        }\n    }\n    return c/float(subSamples*subSamples);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = vec2(fragCoord.x * iR.x - du, (fragCoord.y * iR.y - dv)*iR.x*iResolution.y);\n    vec3 rgb = frameProcessing(uv);\n    fragColor = vec4(rgb,1.0);\n}","name":"Image","description":"","type":"image"}]}