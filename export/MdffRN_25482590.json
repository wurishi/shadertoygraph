{"ver":"0.1","info":{"id":"MdffRN","date":"1495045624","viewed":344,"name":"Bluish Noise","username":"TinyTexel","description":"top: white noise\nbottom: bluish noise \n        high-pass filtered white noise\n        filtering results in non-uniform distribution\n        -> requires re-mapping to uniform distr. using s-scurve:\n           https://www.shadertoy.com/view/MsXBzM","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["noise","dithering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n\n/*\ntop: white noise\nbottom: bluish noise \n        high-pass filtered white noise; uses 4 direct neighbors per pixel\n        filtering results in non-uniform distribution\n        -> requires re-mapping to uniform distr. using s-scurve (analytical cummulative histogram):\n           https://www.shadertoy.com/view/MsXBzM\n\nspectrum plot: https://www.shadertoy.com/view/MtdBzB\n*/\n\n//#define GRADIENT\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\n#define Frame float(iFrame)\n#define Time iTime\n#define PixelCount iResolution.xy\n#define OUT\n\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\nconst float Pi2 = Pi * 2.0;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat Pow(float x, float e) {return pow(x, e);}\nvec2 Pow(vec2 x, float e) {return pow(x, vec2(e));}\nvec3 Pow(vec3 x, float e) {return pow(x, vec3(e));}\nvec4 Pow(vec4 x, float e) {return pow(x, vec4(e));}\n\nfloat GammaDecode(float x) {return pow(x,      2.2) ;}\nvec2  GammaDecode(vec2  x) {return pow(x, vec2(2.2));}\nvec3  GammaDecode(vec3  x) {return pow(x, vec3(2.2));}\nvec4  GammaDecode(vec4  x) {return pow(x, vec4(2.2));}\n\nfloat GammaEncode(float x) {return pow(x,      1.0 / 2.2) ;}\nvec2  GammaEncode(vec2  x) {return pow(x, vec2(1.0 / 2.2));}\nvec3  GammaEncode(vec3  x) {return pow(x, vec3(1.0 / 2.2));}\nvec4  GammaEncode(vec4  x) {return pow(x, vec4(1.0 / 2.2));}\n\n\nfloat CheapHash(float v)\n{\n    return fract(sin(v) * 43758.5453) * 2.0 - 1.0;\n}\n\nfloat CheapHash(vec2 v)\n{\n\treturn CheapHash(v.y + v.x * 12.9898);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//=============================================================================================================================================//\n// \"Hash without Sine\"        | https://www.shadertoy.com/view/4djSRW \n//  Created by David Hoskins  | \n//  used under CC BY-SA 4.0   | https://creativecommons.org/licenses/by-sa/4.0/             \n//  reformatted from original |              \n//---------------------------------------------------------------------------------------------------------------------------------------------//\n\n// Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\nfloat Hash11I(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nfloat Hash12I(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nfloat Hash13I(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nvec2  Hash21I(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec2  Hash22I(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec2  Hash23I(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec3  Hash31I(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xxy  + p3.yzz ) * p3.zyx );}\nvec3  Hash32I(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE3); p3 += dot(p3, p3.yxz  + 19.19); return fract((p3.xxy  + p3.yzz ) * p3.zyx );}\nvec3  Hash33I(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE3); p3 += dot(p3, p3.yxz  + 19.19); return fract((p3.xxy  + p3.yxx ) * p3.zyx );}\nvec4  Hash41I(float p ){vec4 p4 = fract(vec4(p     ) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash42I(vec2  p ){vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash43I(vec3  p ){vec4 p4 = fract(vec4(p.xyzx) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash44I(vec4  p4){     p4 = fract(    (p4    ) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\n \n#undef HASHSCALE1\n#undef HASHSCALE3\n#undef HASHSCALE4\n\n//---------------------------------------------------------------------------------------------------------------------------------------------//\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\n\nfloat Hash11F(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nfloat Hash12F(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nfloat Hash13F(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nvec2  Hash21F(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec2  Hash22F(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec2  Hash23F(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec3  Hash31F(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xxy  + p3.yzz ) * p3.zyx );}\nvec3  Hash32F(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE3); p3 += dot(p3, p3.yxz  + 19.19); return fract((p3.xxy  + p3.yzz ) * p3.zyx );}\nvec3  Hash33F(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE3); p3 += dot(p3, p3.yxz  + 19.19); return fract((p3.xxy  + p3.yxx ) * p3.zyx );}\nvec4  Hash41F(float p ){vec4 p4 = fract(vec4(p     ) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash42F(vec2  p ){vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash43F(vec3  p ){vec4 p4 = fract(vec4(p.xyzx) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash44F(vec4  p4){     p4 = fract(    (p4    ) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\n\n#undef HASHSCALE1\n#undef HASHSCALE3\n#undef HASHSCALE4\n\n//=============================================================================================================================================//\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n//=======================================================================//\n///////////////////////////////////////////////////////////////////////////\n\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\n// shoulder of the ground truth s-curve\nfloat SCurveU_Sh(float x)\n{\n    float a = x < 0.25 ?   0.0        :\n              x < 0.5  ? - 1.0 / 60.0 :\n              x < 0.75 ?  47.0 / 60.0 :\n                         -49.0 / 15.0 ;\n    \n    float b = x < 0.25 ?   2.0        :\n              x < 0.5  ?   7.0 /  3.0 :\n              x < 0.75 ? -17.0 /  3.0 :\n                          64.0 /  3.0 ; \n\n    float c = x < 0.25 ?   0.0        :\n              x < 0.5  ? - 8.0 /  3.0 :\n              x < 0.75 ?  88.0 /  3.0 :\n                         -128.0/  3.0 ; \n\n    float d = x < 0.25 ?   0.0        :\n              x < 0.5  ?  32.0 /  3.0 :\n              x < 0.75 ? -160.0/  3.0 :\n                          128.0/  3.0 ; \n    \n    float e = x < 0.25 ?   0.0        :\n              x < 0.5  ? -64.0 /  3.0 :\n              x < 0.75 ?  128.0/  3.0 :\n                         -64.0 /  3.0 ;    \n    \n    float f = x < 0.25 ? -64.0 / 15.0 :\n              x < 0.5  ?  64.0 /  5.0 :\n              x < 0.75 ? -64.0 /  5.0 :\n                          64.0 / 15.0 ;  \n    \n    float r = a + x*(b + x*(c + x*(d + x*(e + x*f))));   \n    \n    return r;\n}\n\n// ground truth s-curve [-1..1]\nfloat SCurveU(float x)\n{\n   float s = x < 0.0 ? -1.0 : 1.0;\n    \n   return SCurveU_Sh(abs(x)) * s;\n}\n\n// ground truth s-curve [0..1]\nfloat SCurveU01(float x)\n{\n    return SCurveU(x * 2.0 - 1.0) * 0.5 + 0.5;\n}\n\n\n// shoulder of the approx s-curve\nfloat SCurveUA0_Sh(float x)\n{\n    float a, b, c, d, e;\n    \n    if(x < 0.5)\n    {\n        a = 0.0;\n        b = 2.0;\n        c = 0.0;\n        d = 4.0/15.0;\n        e =-12.0/5.0;\n    }\n    else\n    {\n        a =-17.0/15.0;\n        b = 44.0/ 5.0;\n        c =-68.0/ 5.0;\n        d = 28.0/ 3.0;\n        e =-12.0/ 5.0;\n    }\n    \n    return a + x*(b + x*(c + x*(d + x*e)));\n}\n\n// approx s-curve [-1..1]\nfloat SCurveUA0(float x)\n{\n   float s = x < 0.0 ? -1.0 : 1.0;\n    \n   return SCurveUA0_Sh(abs(x)) * s;\n}\n\n// approx s-curve [0..1]\nfloat SCurveU01A0(float x)\n{\n    return SCurveUA0(x * 2.0 - 1.0) * 0.5 + 0.5;\n}\n\n\n// high-pass filtered white noise with remapping\nfloat BNoise0(vec2 uv)\n{\n    float v = Hash12I(uv);\n    \n    float v0 = Hash12I(uv + vec2(-1.0, 0.0));\n    float v1 = Hash12I(uv + vec2( 1.0, 0.0));\n    float v2 = Hash12I(uv + vec2( 0.0,-1.0));\n    float v3 = Hash12I(uv + vec2( 0.0, 1.0));\n    \n    //float vf = v*0.5 - (v0+v1+v2+v3)*0.125 + 0.5;    \n    float vf = ((v0+v1+v2+v3) * -0.25 + v) * 0.5 + 0.5;    \n\n    #if 0\n    return SCurveU01(abs(mod(uv.x + mod(uv.y, 2.0), 2.0) - ((v0+v1+v2+v3) * 0.25 + v) * 0.5));    \n    #else\n    //return mod(uv.x + mod(uv.y, 2.0), 2.0);\n    return SCurveU01(vf);  \n    #endif\n}\n\n// experimental stuff\nfloat SCurveC2(float x) { return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x; }\nvec2 Dir(float x) {x += float(iFrame) * 1.03; return vec2(cos(x * Pi2), sin(x * Pi2));}\nfloat BNoise1(vec2 uv)\n{\n    float v = Hash12I(uv);\n    \n    float v0 = Hash12I(uv + vec2(-1.0, 0.0));\n    float v1 = Hash12I(uv + vec2( 1.0, 0.0));\n    float v2 = Hash12I(uv + vec2( 0.0,-1.0));\n    float v3 = Hash12I(uv + vec2( 0.0, 1.0));\n\n    float v4 = Hash12I(uv + vec2(-1.0, 1.0));\n    float v5 = Hash12I(uv + vec2( 1.0, 1.0));\n    float v6 = Hash12I(uv + vec2(-1.0,-1.0));\n    float v7 = Hash12I(uv + vec2( 1.0,-1.0));\n\n    float v8 =  Hash12I(uv + vec2(-2.0, 0.0));\n    float v9 =  Hash12I(uv + vec2( 2.0, 0.0));\n    float v10 = Hash12I(uv + vec2( 0.0,-2.0));\n    float v11 = Hash12I(uv + vec2( 0.0, 2.0));\n    \n    //float vf = v*0.5 - (v0+v1+v2+v3)*0.125 + 0.5;    \n    float vf = ((v0+v1+v2+v3) * -0.25 + v) * 0.5 + 0.5; \n    \n    vec2 d  = Dir(v);\n    vec2 d0 = Dir(v0);\n\tvec2 d1 = Dir(v1);\n\tvec2 d2 = Dir(v2);\n\tvec2 d3 = Dir(v3);\n    vec2 d4 = Dir(v4);\n\tvec2 d5 = Dir(v5);\n\tvec2 d6 = Dir(v6);\n\tvec2 d7 = Dir(v7);\n\tvec2 d8 = Dir(v8);\n\tvec2 d9 = Dir(v9);\n\tvec2 d10 = Dir(v10);\n\tvec2 d11 = Dir(v11);\n    \n    \n    vec2 o = normalize((d0+d1+d2+d3) - d*4.0);\n    \n    {\n        o = vec2(0.0);\n        \n        float count = 3.0;\n        for(float y = -count; y <= count; ++y)\n        for(float x = -count; x <= count; ++x)\n        {\n            float w = exp2(-(x*x + y*y) * 0.);\n            \n            o += Dir(Hash12I(vec2(uv.x + x, uv.y + y))) * w;\n        }\n        \n        o = normalize(o);\n        o = normalize(Dir(Hash12I(uv)) - o*0.35);\n    }\n         //o = normalize((d4+d5+d6+d7) + (d0+d1+d2+d3) * 2.0 - d*12.0);\n         //o = normalize((d8+d9+d10+d11) + (d4+d5+d6+d7)*2.0 - (d0+d1+d2+d3)*8.0 + d*20.0);\n         //o = normalize(                  (d4+d5+d6+d7)*2.0 - (d0+d1+d2+d3)*8.0 + d*20.0);        \n\n    float h = ((v8+v9+v10+v11) + (v4+v5+v6+v7)*2.0 - (v0+v1+v2+v3)*8.0 + v*20.0) / (4.0 + 4.0*2.0 + 4.0*8.0 + 20.0);\n    h += 0.5;\n    //h = SCurveU01(h);\n    //h = h*h*(3.0-2.0*h);\n    h=SCurveC2(h);\n    h=SCurveC2(h);\n\n    //h = SCurveU01(h); \n    \n    #if 0\n    return h;\n    #else\n    return acos(o.x)/Pi;\n    #endif\n}\n\n#define BNoise BNoise0\n\n#if 0\n#define GRADIENT\n#endif\n\n/*\nfloat SCurveE(float x)\n{\n    if(x < 0.0)\n    {\n        x += 1.0;\n        x *= x;\n        x -= 1.0;\n    }\n    else\n    {\n        x = 1.0 - x;\n        x *= x;\n        x = 1.0 - x;               \n    }\n    \n    return x;\n}\n\nfloat BNoise2(vec2 uv)\n{\n    float v = Hash12I(uv);\n    \n    float v0 = Hash12I(uv + vec2(-1.0, 0.0));\n    float v1 = Hash12I(uv + vec2( 1.0, 0.0));\n    float v2 = Hash12I(uv + vec2( 0.0,-1.0));\n    float v3 = Hash12I(uv + vec2( 0.0, 1.0));\n    \n    v  = v  * 2.0 - 1.0;\n    v0 = v0 * 2.0 - 1.0;\n    v1 = v1 * 2.0 - 1.0;\n    v2 = v2 * 2.0 - 1.0;\n    v3 = v3 * 2.0 - 1.0;\n\n    float vf = SCurveE((SCurveE((v0 + v1)*.5) + SCurveE((v2 + v3)*.5))*.5);\n    vf = SCurveE((v - vf)*.5);\n\n    vf = vf * 0.5 + 0.5;\n    \n    return vf;\n}\n*/\n\n//=======================================================================//\n///////////////////////////////////////////////////////////////////////////\n\n//float InvLerp(float a, float b, float y){return (y - a) / (b - a);}\n\nfloat median(float a, float b, float c)\n{\n    return (a + b + c) - min(min(a,b),c) - max(max(a,b),c);\n}\n\nfloat median(float a, float b, float c, float d)\n{\n    return (a + b + c + d - min(min(a,b),min(c,d)) - max(max(a,b),max(c,d)))*0.5;\n}\n\nfloat BNoiseF(vec2 uv)\n{\n   #define MAP BNoise\n   return (MAP(uv+vec2(1.0,1.0))+MAP(uv+vec2(-1.0,1.0))+MAP(uv+vec2(-1.0,1.0))+MAP(uv+vec2(-1.0,-1.0)))*0.25;\n}\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    vec2 uv = uv0.xy - 0.5;\n\tvec2 tex = uv0.xy / PixelCount;\n    \n\n    if(tex.y <= 0.5) uv.y += PixelCount.y * 0.5;\n    \n    \n    float noiseW = Hash12I(uv);\n\n    float noiseB = BNoise(uv);\n    \n    // denoising attempts\n    //noiseB = (median(noiseB,BNoise(uv+vec2(1.0,0.0)),BNoise(uv+vec2(-1.0,0.0))) + median(noiseB,BNoise(uv+vec2(.0,1.0)),BNoise(uv+vec2(.0,-1.0))))*0.5;\n    //noiseB = mix(noiseB, median(BNoiseF(uv+vec2(1.0,1.0)),BNoiseF(uv+vec2(-1.0,1.0)),BNoiseF(uv+vec2(-1.0,1.0)),BNoiseF(uv+vec2(-1.0,-1.0))), 1.0);\n    //noiseB = mix(noiseB, (BNoiseF(uv+vec2(1.0,1.0))+BNoiseF(uv+vec2(-1.0,1.0))+BNoiseF(uv+vec2(-1.0,1.0))+BNoiseF(uv+vec2(-1.0,-1.0)))*0.25, 1.0);\n    //noiseB = mix(noiseB, (BNoise(uv+vec2(1.0,1.0))+BNoise(uv+vec2(-1.0,1.0))+BNoise(uv+vec2(-1.0,1.0))+BNoise(uv+vec2(-1.0,-1.0)))*0.25, 1.0);\n    //noiseB = mix(BNoiseF(uv), (BNoiseF(uv+vec2(1.0,0.0))+BNoiseF(uv+vec2(-1.0,0.0))+BNoiseF(uv+vec2(.0,1.0))+BNoiseF(uv+vec2(.0,-1.0)))*0.25, 0.99);\n    //noiseB = mix(noiseB, median(BNoise(uv+vec2(1.0,0.0)),BNoise(uv+vec2(-1.0,0.0)),BNoise(uv+vec2(.0,1.0)),BNoise(uv+vec2(.0,-1.0))), .75);\n    //noiseB = (median(noiseB,BNoise(uv+vec2(1.0,0.0)),BNoise(uv+vec2(-1.0,0.0))) + median(noiseB,BNoise(uv+vec2(1.0,0.0).yx),BNoise(uv+vec2(-1.0,0.0).yx)))*0.5;\n    //noiseB = median(median(noiseB,BNoise(uv+vec2(1.0,0.0)),BNoise(uv+vec2(-1.0,0.0))), \n    //                median(noiseB,BNoise(uv+vec2(0.0,1.0)),BNoise(uv+vec2(0.0,-1.0))),\n    //                median(noiseB,BNoise(uv+vec2(1.0,1.0)),BNoise(uv+vec2(-1.0,-1.0))),\n    //                median(noiseB,BNoise(uv+vec2(-1.0,1.0)),BNoise(uv+vec2(1.0,-1.0))));\n    \n    #if 0\n    noiseW = (noiseW * 2.0 - 1.0)*16.0 * 0.5 + 0.5;    \n    noiseB = (noiseB * 2.0 - 1.0)*16.0 * 0.5 + 0.5;\n    #endif\n    \n    #if 0\n    noiseB = fract(noiseB + 1.61803398875f *float(iFrame*0+3));//animation attempt\n    #endif\n    \n    #ifdef GRADIENT\n    if(tex.y > 0.5)\n        outCol = vec4(tex.x > noiseW ? 1.0 : 0.0);// top\n    else\n        outCol = vec4(tex.x > noiseB ? 1.0 : 0.0);// bottom\n    #else\n    if(tex.y > 0.5)\n        outCol = vec4(noiseW);// top\n        //outCol = vec4(tex.x > noiseB ? 1.0 : 0.0);\n    else\n        outCol = vec4(noiseB);// bottom\n    #endif\n    \n    outCol = vec4(GammaEncode(clamp01(outCol.rgb)), 0.0);\n}","name":"Image","description":"","type":"image"}]}