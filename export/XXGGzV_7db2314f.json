{"ver":"0.1","info":{"id":"XXGGzV","date":"1717880530","viewed":35,"name":"Spot noise","username":"magandalf","description":"It like value noise, there square cells replaced by spots.\nit looks good even on small iterations.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise","spot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* FUNCTIONS HELP:\n    \n    clamp(x, minv, maxv) -> if x less minv, x = minv, if x more maxv x = maxv\n    fract(x) -> x - floor(x)\n    mix(x, y, a)  ->  linear interpolation\n    step(edge, x) -> x >= edje ? 1 : 0\n    smoothstep(edge0, edge1, x) =\n        x < edge0 -> 0\n        x > edge1 -> 1\n        else: smooth interpolation 2x^2-x^3\n    \n    lenght(vec) -> Euclidian length\n    distance(v1, v2) -> distance\n    dot(v1, v2)\n    cross(v1, v2)\n    normalize(vec)\n    faceforward(vec, vec, vec) ????????\n    reflect(vec, norm) reflection vector from surface with normale norm\n    refract(vec, nrom, eta) refration vector on surface with normale \n                                    norm and refration coefficient eta\n    \n    inverse(mat) -> inverse matrix\n    matrixCompMult(mat, mat) -> multiplicate matrix by elements (not math)\n    \n*/\n\n#define DEPTH 4\n\nconst int SEED = 0;\n#define M1 (1719413*929)\n#define M2 (10000079 * 11)\n#define M3 (140473*2467*11)\n\n\n\nvec4 fzmsin(vec4 x)\n{\n    x = fract(x);\n    x -= 0.5;\n    x *= 2.0;\n    x = x - x * x * x;\n    return x + 0.5;\n}\n\n\nvec4 hash( mat4 q )\n{\n\n    vec4 r;\n    \n    r = vec4(10.23526, 3.125125, 3.23632, 1.12509);\n    r = r * q;\n    \n    return fract(fzmsin(r) * r);\n}\n\n\n\nfloat noise_base(vec3 xyz)\n{\n    vec4 ixyz = floor(xyz).xyzz;\n    vec3 frac = fract(xyz);\n    \n    frac = frac * frac * (3.0 - frac * 2.0);\n    \n    vec4 val1, val2;\n    //   x y z\n    val1 = hash(mat4(\n        ixyz + vec4(0, 0, 0, 0),\n        ixyz + vec4(1, 0, 0, 0),\n        ixyz + vec4(0, 1, 0, 0),\n        ixyz + vec4(1, 1, 0, 0)\n    ));\n    val2 = hash(mat4(\n        ixyz + vec4(0, 0, 1, 1),\n        ixyz + vec4(1, 0, 1, 1),\n        ixyz + vec4(0, 1, 1, 1),\n        ixyz + vec4(1, 1, 1, 1)\n    ));\n    \n    val1 = mix(val1, val2, frac.z);\n    \n    val1.xy = mix(val1.xy, val1.zw, frac.y);\n    \n    return mix(val1.x, val1.y, frac.x);\n}\n\n\nvec3 fzmsin(vec3 x)\n{\n    x = fract(x);\n    x -= 0.5;\n    x *= 2.0;\n    x = x - x * x * x;\n    return x + 0.5;\n}\n\n\nvec3 fmsin(vec3 x)\n{\n    ivec3 l = ivec3(floor(x));\n    x = fract(x / 2.0);\n    x -= 0.5;\n    x = 1.0 - x * x * 4.0;\n    x = x * vec3(1 - (l & ivec3(2, 2, 2)));\n    return x * x * x;\n}\n\nvec3 msin(vec3 x)\n{\n    vec3 f = sin(x*3.1415926*0.5);\n    return f * f * f;\n}\n\n\nfloat noise3d(vec3 xyz)\n{\n    float a, b;\n    vec3 p, q, k, v1, v2, v3;\n    \n    a = b = 1.5;\n   \n    p = xyz / a;\n    q = p / a;\n    k = q / a;\n    v1 = fzmsin(p.yxz);\n    v2 = fzmsin(q.xzy);\n    v3 = fzmsin(k.zyx);\n    xyz += v1 * v2 * v3 * b;\n    \n    \n    xyz = xyz.yxz;\n    \n\n    a = b = 2.1;\n    \n    p = xyz / a;\n    q = p / a;\n    k = q / a;\n    v1 = fzmsin(p.yxz);\n    v2 = fzmsin(q.xzy);\n    v3 = fzmsin(k.zyx);\n    xyz += v1 * v2 * v3 * b;\n    \n    \n    a = b = 3.1;\n    \n    p = xyz / a;\n    q = p / a;\n    k = q / a;\n    v1 = fzmsin(p.yxz);\n    v2 = fzmsin(q.xzy);\n    v3 = fzmsin(k.zyx);\n    xyz += v1 * v2 * v3 * b;\n    \n    return noise_base(xyz);\n}\n\n\nfloat noise(vec3 xyz)\n{\n    mat3 m = mat3(\n        vec3(0.5501241,  0.0852899,  0.8307160),\n        vec3(-0.8130569,  -0.1722604,  0.5561158),\n        vec3(0.1905305,  -0.9813522,  -0.0254190)\n    );\n    m *= 2.0;\n    float amp = 1.0;\n    float fin = 0.0;\n    float div = 0.0;\n   \n    \n    for (int i = 0; i < DEPTH; ++i)\n    {\n        div += amp;\n        fin += amp * noise3d(xyz);\n        xyz *= m;\n        amp /= 1.4;\n    }\n    \n    return fin / div;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / sqrt(iResolution.x * iResolution.y);\n\n    // Time varying pixel color\n    float grey = noise(vec3(1000.0, 1000.0, 1000.0) + vec3(uv * 6.5, 0.1 * float(iTime)));\n\n    vec3 col = vec3(grey);\n\n    if (0.0 <= grey && grey < 0.5) // water\n        { col = mix(vec3(0.000,0.000,0.000), vec3(0.000,0.000,1.000), (grey - 0.0) / 0.5); }\n    else if (0.5 <= grey && grey < 0.53) // sand\n        { col = mix(vec3(1.000,0.784,0.000), vec3(1.000,0.969,0.000), (grey - 0.5) / 0.03); }\n    else if (0.53 <= grey && grey < 0.75) // grass\n        { col = mix(vec3(0.086,0.400,0.000), vec3(0.773,1.000,0.141), (grey - 0.53) / 0.22); }\n    else if (0.75 <= grey && grey < 0.85) // rocks\n        { col = mix(vec3(0.580,0.580,0.580), vec3(0.243,0.243,0.255), (grey - 0.75) / 0.1); }\n    else if (0.85 <= grey && grey <= 1.0) // snow\n        { col = mix(vec3(0.894,0.906,0.902), vec3(1.000,1.000,1.000), (grey - 0.85) / 0.15); }\n    else { col = vec3(1.000,0.000,0.000); }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}