{"ver":"0.1","info":{"id":"4tV3Rm","date":"1473884496","viewed":191,"name":"What a world 2","username":"Draedrus","description":"What a world 2, a little bit optimized version from the previous What a World shader. Including some HDR functions I've added to my Fresh Water shader. As usual, still in progress","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["procedural","water","islands"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/***********************************************************************\n * author: pierre.plans@gmail.com\n ***********************************************************************/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy /iResolution.xy;\n    float eps = 0.0005;\n    vec4 color = vec4(0.0);\n    color += texture(iChannel0, uv+vec2(+eps, 0.0));\n    color += texture(iChannel0, uv+vec2(-eps, 0.0));\n    color += texture(iChannel0, uv+vec2(0.0, +eps));\n    color += texture(iChannel0, uv+vec2(0.0, -eps));\n    color/=4.0;\n    fragColor = vec4(color.rgb, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/***********************************************************************\n * author: pierre.plans@gmail.com\n ***********************************************************************/\n\n//#define SET_NIGHT\n\n/**\n * RENDERING OPTION GLOBALS\n **/\n\n#define RAYMARCHING_NUM_STEPS 100\n#define RAYMARCHING_REFL_NUM_STEPS 20\n#define RAYMARCHING_REFR_NUM_STEPS 20\n#define SOFTSHADOW_STEPS 8\n\n#define SAND_OCTAVES 6\n#define SAND_GRAINS 1\n#define LIGHTSPEED 1.0\n#define MOONSPEED 0.5\n#define AURORABOREALISSPEED 3.0\n\n// 0.4 default only for OLDLIGHTING\n#define VAR_REFL_OVER_REFR_PERCT 0.5\n\n#define VAR_MOUNTAIN_LEVEL 5.0\n#define VAR_MOUNTAIN_AMP 8.0\n#define VAR_MOUNTAIN_FREQ 0.2\n#define VAR_MOUNTAIN_LIGHTING_KD 0.4\n#define VAR_MOUNTAIN_LIGHTING_KS 1.5\n/*\n\tA variation I liked, with greater islands/continents\n\n#define VAR_TERRAIN_LEVEL 9.0\n#define VAR_TERRAIN_AMP 12.5\n#define VAR_TERRAIN_FREQ 0.05\n*/\n/*\n\tDefault variation\n#define VAR_TERRAIN_LEVEL 5.0\n#define VAR_TERRAIN_AMP 8.5\n#define VAR_TERRAIN_FREQ 0.2\n*/\n// 5.0\n#define VAR_TERRAIN_LEVEL 5.0\n// 8.5\n#define VAR_TERRAIN_AMP 8.5\n// 0.2\n#define VAR_TERRAIN_FREQ 0.2\n#define VAR_TERRAIN_LIGHTING_KD 1.0\n#define VAR_TERRAIN_LIGHTING_KS 0.0\n#define VAR_TREE_LIGHTING_KD 1.0\n#define VAR_TREE_LIGHTING_KS 0.0\n\n#define VAR_WATER_LEVEL 0.0\n// 0.08 - 0.1 is a good value for VAR_WATER_AMP\n#define VAR_WATER_AMP 0.08\n#define VAR_WATER_FREQ 1.2\n#define VAR_WATER_SPEED 0.8\n#define VAR_WATER_LIGHTING_KD 0.4\n#define VAR_WATER_LIGHTING_KS 1.0\n\n#define VAR_FRESNEL_BIAS 0.2\n#define VAR_FRESNEL_SCALE 1.0\n#define VAR_FRESNEL_POW 2.0\n\n// old\n//#define VAR_MOONRADIUS 1.0\n#define VAR_MOONRADIUS 200.0\n// old\n#define ASTRALMAXDIST 4000.0\n//#define MOONPOS vec3(-10.0, 20.0, 50.0)\n#define MOONPOS normalize(vec3(4000.0, 400.0, 2000.0))*ASTRALMAXDIST\n#define LIGHTPOS normalize(vec3(-2000.0, 2000.0, -2000.0))*ASTRALMAXDIST\n\n//#define COLORROCK vec3(0.5, 0.5, 0.6)\n#define COLORROCK vec3(0.8, 0.8, 0.7)\n#define COLORGRASS vec3(0.5, 0.7, 0.5)\n#define COLORTREE vec3(0.0, 0.2, 0.0)\n#define COLORSAND vec3(0.9, 0.9, 0.5)\n#define COLORWATER vec3(0.1, 0.5, 0.7)\n#define COLORSKYDAY vec3(0.5, 0.5, 1.0)\n#define COLORSKYDAWN vec3(1.0, 0.6, 0.5)\n#define COLORSKYNIGHT vec3(0.1, 0.2, 0.4)\n\n#define TYPE_TERRAIN 0.0\n#define TYPE_WATER 1.0\n#define TYPE_TREES 2.0\n#define TYPE_MOUNTAIN 3.0\n\nstruct Light {\n    vec3 o;\n    vec3 d;\n    vec4 diffuseColor;\n    float shininess;\n\tfloat power;\n};\n    \n#ifdef OLDLIGHTING\n\nLight _light = Light(\n    LIGHTPOS,\n    normalize(TARGETPOS-LIGHTPOS),\n    vec4(1.0, 1.0, 1.0, 1.0),\n    16.01,\n    1.5);\n\nLight _moon = Light(\n    MOONPOS,\n    normalize(TARGETPOS-MOONPOS),\n    vec4(1.0, 1.0, 1.0, 1.0),\n    2.01,\n    1.5);\n\n#else\n\nLight _light = Light(\n    LIGHTPOS,\n    normalize(TARGETPOS-LIGHTPOS),\n    vec4(1.0, 1.0, 0.7, 1.0),\n    16.0,\n    1.0);\n\nLight _moon = Light(\n    MOONPOS,\n    normalize(TARGETPOS-MOONPOS),\n    vec4(1.0, 1.0, 1.0, 1.0),\n    16.01,\n    4.0);\n\n#endif\n\n/**\n * PRIMITIVES\n **/\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float r )\n{\n    return length(p)-r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdCappedCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n/**\n * (Distance, Type) with Type =\n * 0.0 == Nthg\n **/\n\n/***********************\n * PRIMITIVE OPERATIONS\n ***********************/\n\n// polynomial smooth min (k = 0.1);\nvec2 polsmin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return vec2(mix( b.x, a.x, h ) - k*h*(1.0-h), floor(mix( b.y, a.y, h )*2.0));\n}\n\n// polynomial smooth min (k = 0.1);\nvec2 polsmax( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return vec2(mix( b.x, a.x, 1.0-h ) - k*h*(1.0-h), floor(mix( b.y, a.y, 1.0-h )*2.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opI( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x>d2.x) ? d1 : d2;\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<-d2.x) ? d1 : d2;\n}\n\n/*******************\n * MAP ACTUAL ELEMENTS\n *******************/\n\nfloat heightMap(vec3 p, float s, float f) {\n    float h = 0.0;\n    float a = s;\n    for(int i=0;i<4;++i) {\n        h += waterNoise(p.xz*f)*a;\n        //h += (1.0-voronoi2D(p.xz*f))*a;\n        a *= 0.22;\n        f *= 1.9;\n    }\n    return h;\n}\n\nfloat heightMapMountain(vec3 p, float s, float f) {\n    float h = 0.0;\n    float a = s;\n    for(int i=0;i<6;++i) {\n        h += waterNoise(p.xz*f)*a;\n        //h += (1.0-voronoi2D(p.xz*f))*a;\n        a *= 0.22;\n        f *= 1.9;\n    }\n    return h;\n}\n\nfloat mapTerrain(vec3 p, float hm, float fbm) {\n    float t = sdPlane(p)+hm+fbm;\n    return t;\n}\n\nfloat mapMountain(vec3 p, float hm, float fbm) {\n    float t = sdPlane(p)+hm+fbm;\n    return t;\n}\n\nfloat mapTrees(vec3 p, float hm, float fbm) {\n    /*p.x = sin(p.x)+1.0;\n    p.z = cos(p.z)+1.0;*/\n    vec3 m = vec3(0.2, 0.2, 0.1);// ok\n    //vec3 m = vec3(0.2+fract(p.x)*0.2, 0.2+fract(p.y)*0.2, 0.1+fract(p.z)*0.1);// noisy\n    vec3 p2 = mod(p-vec3(0.0, 0.2, 0.0), m)-0.5*m;\n    return sdPlane(p)+hm+fbm+sdSphere(p2, 0.2);\n}\n\nvec2 mapWorld(vec3 p, float s) {\n    float hmTerrain = heightMap(p, s, VAR_TERRAIN_FREQ);\n    #ifdef USE_HD_MOUNTAIN\n    float hmMountain = heightMapMountain(p-vec3(0.0, VAR_MOUNTAIN_LEVEL, 0.0), VAR_MOUNTAIN_AMP, VAR_MOUNTAIN_FREQ);\n    float fbmMountain = fbm3DMountain(p*0.5);\n    #endif\n    float fbmTerrain = fbm3DTerrain(p*0.5);\n    float t = mapTerrain(p, hmTerrain, fbmTerrain);\n    float ts = mapTrees(p, hmTerrain, fbmTerrain);\n    \n    if(waterNoise(p.xz*0.3)>0.5 &&\n       p.y>=(VAR_WATER_LEVEL-(VAR_TERRAIN_LEVEL-1.0-noise3D(p)))) {\n        return opU(vec2(t, TYPE_TERRAIN), vec2(ts, TYPE_TREES));\n    }\n    else\n    {\n        return opU(vec2(t, TYPE_TERRAIN),\n        \t#ifdef USE_HD_MOUNTAIN\n        \tvec2(mapMountain(p, hmMountain, fbmMountain), TYPE_MOUNTAIN)\n        \t#else\n        \tvec2(mapMountain(p, hmTerrain, fbmTerrain)+(1.0-2.0*waterNoise(p.xz)), TYPE_MOUNTAIN)\n        \t#endif\n                );\n    }\n}\n\nfloat heightMapSand(vec3 p, float s) {\n    float h = 0.0;\n    float a = s;\n    float f = 0.2;\n    for(int i=0;i<SAND_OCTAVES;++i) {\n        h += snoise(p.xz*f)*a;\n        a *= 0.22;\n        f *= 1.9;\n    }\n    for(int i=0;i<SAND_GRAINS;++i) {\n        h += hash3D(p.xyz*f)*a;\n        a *= 0.22;\n        f *= 1.9;\n    }\n    return h;\n}\n\nfloat mapSand(vec3 p, float s) {\n\treturn sdPlane(p)+heightMapSand(p, s);\n}\n\n\n/*******************\n * MAP ACTUAL\n *******************/\n\nvec2 map(vec3 p) {\n    vec2 d = vec2(-1.0, -1.0);\n    //d = vec2(mapTerrain(p-vec3(0.0, VAR_TERRAIN_LEVEL, 0.0), VAR_TERRAIN_AMP), TYPE_TERRAIN);\n    p = p-vec3(0.0, VAR_TERRAIN_LEVEL, 0.0);\n    d = mapWorld(p, VAR_TERRAIN_AMP);\n    //d = opU(vec2(mapWater(p-vec3(0.0, VAR_WATER_LEVEL, 0.0), VAR_WATER_AMP), TYPE_WATER), d);\n    return d;\n}\n\nvec2 mapRefl(vec3 p) {\n    return mapWorld(p-vec3(0.0, VAR_TERRAIN_LEVEL, 0.0), VAR_TERRAIN_AMP);\n}\n\nvec3 mapNormal(vec3 pt, float e) {\n    vec3 normal;\n    normal.y = map(pt).x;\n    normal.x = map(vec3(pt.x+e,pt.y,pt.z)).x - normal.y;\n    normal.z = map(vec3(pt.x,pt.y,pt.z+e)).x - normal.y;\n    normal.y = e;\n    return normalize(normal);\n}\n\nvec3 mapNormalRefl(vec3 pt, float e) {\n    vec3 normal;\n    normal.y = mapRefl(pt).x;\n    normal.x = mapRefl(vec3(pt.x+e,pt.y,pt.z)).x - normal.y;\n    normal.z = mapRefl(vec3(pt.x,pt.y,pt.z+e)).x - normal.y;\n    normal.y = e;\n    return normalize(normal);\n}\n\n\n/**********************\n * RAYMARCHING\n **********************/\n\nvec2 raymarch(vec3 ro, vec3 rd, in float tmin, in float tmax) {\n    vec2 m = vec2(-1.0, -1.0);\n    vec2 res = vec2(tmin, -1.0);\n\tfor( int i=0; i<RAYMARCHING_NUM_STEPS; i++ )\n\t{\n        m = map(ro + res.x*rd);\n\t\tif( abs(m.x)<tmin || res.x>tmax ) break;\n\t\tres.x += 0.5*m.x;\n        res.y = m.y;\n\t}\n    if( res.x>tmax ) res.y=-1.0;\n\treturn res;\n}\n\n// the reflection one\nvec2 raymarchPlane(vec3 ro, vec3 rd, in float tmin, in float tmax) {\n    vec2 m = vec2(-1.0, -1.0);\n    vec2 res = vec2(tmin, -1.0);\n\tfor( int i=0; i<RAYMARCHING_REFL_NUM_STEPS; i++ )\n\t{\n        m = vec2((ro + res.x*rd).y, 0.0);\n\t\tif( abs(m.x)<tmin || res.x>tmax ) break;\n\t\tres.x += 0.5*m.x;\n        res.y = m.y;\n\t}\n    if( res.x>tmax ) res.y=-1.0;\n\treturn res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy /iResolution.xy;\n    vec2 pixel = -1.0 + 2.0*uv;// vec2(iResolution.x*0.6, iResolution.y);\n\tpixel.x *= iResolution.x/iResolution.y;\n    \n    vec2 mv = -1.0 + 2.0*iMouse.xy/iResolution.xy+vec2(1.0, 0.0);\n    float Time = mod(iTime*CAMROTSPEED, 360.0);\n    pixel.x *= 0.6;\n\n    \n    vec3 ro = CAMPOS;\n    vec3 rd = normalize(vec3(pixel, 1.0));\n    GetCamera(uv,pixel,iTime,ro,rd);\n\n    vec2 rm = vec2(FAR, -1.0), rmp = vec2(FAR, -1.0);\n    rm = raymarch(ro, rd, NEAR, FAR);\n    rmp = raymarchPlane(ro, rd, NEAR, FAR);\n\n    fragColor = vec4(rm.x, rm.y, rmp.x, 0.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/***********************************************************************\n * author: pierre.plans@gmail.com\n ***********************************************************************/\n\n//#define SET_NIGHT\n\n/**\n * RENDERING OPTION GLOBALS\n **/\n// wanna see only the depth camera ? Okay !\n//#define USE_DEPTHMODE\n// make the setting more realistic with a few computing performance\n#define USE_SOFTSHADOWS\n// this makes shader crashing under firefox\n//#define USE_SOFTSHADOWS_ON_REFLECTION\n// defines if the algorithm will use a rotating (X axis) light around 0.0, 0.0, 0.0\n// using LIGHTSPEED\n#define USE_LIGHTMOVING\n// defines if the algorithm will use a rotating (Y axis) moon around 0.0, 0.0, 0.0\n// using MOONSPEED\n//#define USE_MOONMOVING\n// defines if the clouds are animated or not, using CLOUDSPEED\n#define USE_ANIMATECLOUDS\n// defines that the algorithm will perform water reflection (costs a lot)\n#define USE_WATER_REFLECTION\n// defines that the algorithm will perform water refraction (costs a few)\n#define USE_WATER_REFRACTION\n// defines that the algorithm will perform day&night simulation\n#define USE_DAYANDNIGHT\n// defines that the algorithm will use a better noise for the star generation\n//#define USE_HD_STARNOISE\n// defines if the algorithm will draw the sun\n#define DRAW_SUN\n// defines if the algorithm will draw the moon\n#define DRAW_MOON\n// old looking lighting without moon light and not accurate lighting\n//#define OLDLIGHTING\n#define USE_BOREALS\n// define if we are going to have more rocks or not\n#define USE_MORE_ROCKY\n// have the mountains noise different from terrain one\n#define USE_HD_MOUNTAIN\n// USE_HD_MOUNTAIN_NOISE has a priority over USE_FAST_HD_TERRAIN_NOISE, so chose only one\n// Use a voronoi 3D noise for the rocky bump map (costs a lot)\n//#define USE_HD_MOUNTAIN_NOISE\n// Use a voronoi 2D noise for the rocky bump map (costs a little bit less than USE_HD_TERRAIN_NOISE)\n#define USE_FAST_HD_MOUNTAIN_NOISE\n// USE_HD_TERRAIN_NOISE has a priority over USE_FAST_HD_TERRAIN_NOISE, so chose only one\n// Use a simplex 3D noise for the terrain bump map (costs a lot)\n//#define USE_HD_TERRAIN_NOISE\n// Use a simplex 2D noise for the terrain bump map (costs a little bit less than USE_HD_TERRAIN_NOISE)\n#define USE_FAST_HD_TERRAIN_NOISE\n\n#define RAYMARCHING_NUM_STEPS 40\n#define RAYMARCHING_REFL_NUM_STEPS 20\n#define RAYMARCHING_REFR_NUM_STEPS 20\n#define SOFTSHADOW_STEPS 8\n\n#define SAND_OCTAVES 6\n#define SAND_GRAINS 1\n#define CAMDIST 8.0\n#define CAMROTSPEED 0.2\n#define LIGHTSPEED 1.0\n#define MOONSPEED 0.5\n#define CLOUDSPEED 0.1\n#define AURORABOREALISSPEED 3.0\n\n// 0.4 default only for OLDLIGHTING\n#define VAR_REFL_OVER_REFR_PERCT 0.5\n\n#define VAR_MOUNTAIN_LEVEL 5.0\n#define VAR_MOUNTAIN_AMP 8.0\n#define VAR_MOUNTAIN_FREQ 0.2\n#define VAR_MOUNTAIN_LIGHTING_KD 0.4\n#define VAR_MOUNTAIN_LIGHTING_KS 1.5\n/*\n\tA variation I liked, with greater islands/continents\n\n#define VAR_TERRAIN_LEVEL 9.0\n#define VAR_TERRAIN_AMP 12.5\n#define VAR_TERRAIN_FREQ 0.05\n*/\n/*\n\tDefault variation\n#define VAR_TERRAIN_LEVEL 5.0\n#define VAR_TERRAIN_AMP 8.5\n#define VAR_TERRAIN_FREQ 0.2\n*/\n// 5.0\n#define VAR_TERRAIN_LEVEL 5.0\n// 8.5\n#define VAR_TERRAIN_AMP 8.5\n// 0.2\n#define VAR_TERRAIN_FREQ 0.2\n#define VAR_TERRAIN_LIGHTING_KD 1.0\n#define VAR_TERRAIN_LIGHTING_KS 0.0\n#define VAR_TREE_LIGHTING_KD 1.0\n#define VAR_TREE_LIGHTING_KS 0.0\n\n#define VAR_WATER_LEVEL 0.0\n// 0.08 - 0.1 is a good value for VAR_WATER_AMP\n#define VAR_WATER_AMP 0.08\n#define VAR_WATER_FREQ 1.2\n#define VAR_WATER_SPEED 0.8\n#define VAR_WATER_LIGHTING_KD 0.4\n#define VAR_WATER_LIGHTING_KS 1.0\n\n#define VAR_FRESNEL_BIAS 0.2\n#define VAR_FRESNEL_SCALE 1.0\n#define VAR_FRESNEL_POW 2.0\n\n// old\n//#define VAR_MOONRADIUS 1.0\n#define VAR_MOONRADIUS 200.0\n// old\n#define ASTRALMAXDIST 4000.0\n//#define MOONPOS vec3(-10.0, 20.0, 50.0)\n#define MOONPOS normalize(vec3(4000.0, 400.0, 2000.0))*ASTRALMAXDIST\n#define LIGHTPOS normalize(vec3(-2000.0, 2000.0, -2000.0))*ASTRALMAXDIST\n\n//#define COLORROCK vec3(0.5, 0.5, 0.6)\n#define COLORROCK vec3(0.8, 0.8, 0.7)\n#define COLORGRASS vec3(0.5, 0.7, 0.5)\n#define COLORTREE vec3(0.0, 0.2, 0.0)\n#define COLORSAND vec3(0.9, 0.9, 0.5)\n#define COLORWATER vec3(0.1, 0.5, 0.7)\n#define COLORSKYDAY vec3(0.5, 0.5, 1.0)\n#define COLORSKYDAWN vec3(1.0, 0.6, 0.5)\n#define COLORSKYNIGHT vec3(0.1, 0.2, 0.4)\n\n#define TYPE_TERRAIN 0.0\n#define TYPE_WATER 1.0\n#define TYPE_TREES 2.0\n#define TYPE_MOUNTAIN 3.0\n\nstruct Light {\n    vec3 o;\n    vec3 d;\n    vec4 diffuseColor;\n    float shininess;\n\tfloat power;\n};\n    \n#ifdef OLDLIGHTING\n\nLight _light = Light(\n    LIGHTPOS,\n    normalize(TARGETPOS-LIGHTPOS),\n    vec4(1.0, 1.0, 1.0, 1.0),\n    16.01,\n    1.5);\n\nLight _moon = Light(\n    MOONPOS,\n    normalize(TARGETPOS-MOONPOS),\n    vec4(1.0, 1.0, 1.0, 1.0),\n    2.01,\n    1.5);\n\n#else\n\nLight _light = Light(\n    LIGHTPOS,\n    normalize(TARGETPOS-LIGHTPOS),\n    vec4(1.0, 1.0, 0.7, 1.0),\n    16.0,\n    1.0);\n\nLight _moon = Light(\n    MOONPOS,\n    normalize(TARGETPOS-MOONPOS),\n    vec4(1.0, 1.0, 1.0, 1.0),\n    16.01,\n    4.0);\n\n#endif\n\n/**\n * PRIMITIVES\n **/\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float r )\n{\n    return length(p)-r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdCappedCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n/**\n * (Distance, Type) with Type =\n * 0.0 == Nthg\n **/\n\n/***********************\n * PRIMITIVE OPERATIONS\n ***********************/\n\n// polynomial smooth min (k = 0.1);\nvec2 polsmin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return vec2(mix( b.x, a.x, h ) - k*h*(1.0-h), floor(mix( b.y, a.y, h )*2.0));\n}\n\n// polynomial smooth min (k = 0.1);\nvec2 polsmax( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return vec2(mix( b.x, a.x, 1.0-h ) - k*h*(1.0-h), floor(mix( b.y, a.y, 1.0-h )*2.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opI( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x>d2.x) ? d1 : d2;\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<-d2.x) ? d1 : d2;\n}\n\n/*******************\n * MAP ACTUAL ELEMENTS\n *******************/\n\nfloat heightMap(vec3 p, float s, float f) {\n    float h = 0.0;\n    float a = s;\n    for(int i=0;i<4;++i) {\n        h += waterNoise(p.xz*f)*a;\n        //h += (1.0-voronoi2D(p.xz*f))*a;\n        a *= 0.22;\n        f *= 1.9;\n    }\n    return h;\n}\n\nfloat heightMapWater(vec3 p, float s) {\n    float h = 0.0;\n    float a = s;\n    float f = VAR_WATER_FREQ;\n    for(int i=0;i<10;++i) {\n        h += waterNoise(p.xz*f+iTime*VAR_WATER_SPEED)*a;\n        h -= waterNoise(p.xz*f-iTime*VAR_WATER_SPEED)*a;\n        a *= 0.6;\n        f *= 1.4;\n    }\n    return h;\n}\n\nfloat heightMapMountain(vec3 p, float s, float f) {\n    float h = 0.0;\n    float a = s;\n    for(int i=0;i<6;++i) {\n        h += waterNoise(p.xz*f)*a;\n        //h += (1.0-voronoi2D(p.xz*f))*a;\n        a *= 0.22;\n        f *= 1.9;\n    }\n    return h;\n}\n\nfloat mapWater(vec3 p, float a) {\n    return sdPlane(p)+heightMapWater(p, a);\n}\n\nfloat mapTerrain(vec3 p, float hm, float fbm) {\n    float t = sdPlane(p)+hm+fbm;\n    return t;\n}\n\nfloat mapMountain(vec3 p, float hm, float fbm) {\n    float t = sdPlane(p)+hm+fbm;\n    return t;\n}\n\nfloat mapTrees(vec3 p, float hm, float fbm) {\n    /*p.x = sin(p.x)+1.0;\n    p.z = cos(p.z)+1.0;*/\n    vec3 m = vec3(0.2, 0.2, 0.1);// ok\n    //vec3 m = vec3(0.2+fract(p.x)*0.2, 0.2+fract(p.y)*0.2, 0.1+fract(p.z)*0.1);// noisy\n    vec3 p2 = mod(p-vec3(0.0, 0.2, 0.0), m)-0.5*m;\n    return sdPlane(p)+hm+fbm+sdSphere(p2, 0.2);\n}\n\nvec2 mapWorld(vec3 p, float s) {\n    float hmTerrain = heightMap(p, s, VAR_TERRAIN_FREQ);\n    #ifdef USE_HD_MOUNTAIN\n    float hmMountain = heightMapMountain(p-vec3(0.0, VAR_MOUNTAIN_LEVEL, 0.0), VAR_MOUNTAIN_AMP, VAR_MOUNTAIN_FREQ);\n    float fbmMountain = fbm3DMountain(p*0.5);\n    #endif\n    float fbmTerrain = fbm3DTerrain(p*0.5);\n    float t = mapTerrain(p, hmTerrain, fbmTerrain);\n    float ts = mapTrees(p, hmTerrain, fbmTerrain);\n    if(waterNoise(p.xz*0.3)>0.5 &&\n       p.y>=(VAR_WATER_LEVEL-(VAR_TERRAIN_LEVEL-1.0-noise3D(p)))) {\n        return opU(vec2(t, TYPE_TERRAIN), vec2(ts, TYPE_TREES));\n    }\n    else\n    {\n        return opU(vec2(t, TYPE_TERRAIN),\n        \t#ifdef USE_HD_MOUNTAIN\n        \tvec2(mapMountain(p, hmMountain, fbmMountain), TYPE_MOUNTAIN)\n        \t#else\n        \tvec2(mapMountain(p, hmTerrain, fbmTerrain)+(1.0-2.0*waterNoise(p.xz)), TYPE_MOUNTAIN)\n        \t#endif\n                );\n    }\n}\n\n\n/*******************\n * MAP ACTUAL\n *******************/\n\nvec2 map(vec3 p) {\n    vec2 d = vec2(-1.0, -1.0);\n    //d = vec2(mapTerrain(p-vec3(0.0, VAR_TERRAIN_LEVEL, 0.0), VAR_TERRAIN_AMP), TYPE_TERRAIN);\n    d = mapWorld(p-vec3(0.0, VAR_TERRAIN_LEVEL, 0.0), VAR_TERRAIN_AMP);\n    //d = opU(vec2(mapWater(p-vec3(0.0, VAR_WATER_LEVEL, 0.0), VAR_WATER_AMP), TYPE_WATER), d);\n    return d;\n}\n\nvec3 mapNormal(vec3 pt, float e) {\n    vec3 normal;\n    normal.y = map(pt).x;\n    normal.x = map(vec3(pt.x+e,pt.y,pt.z)).x - normal.y;\n    normal.z = map(vec3(pt.x,pt.y,pt.z+e)).x - normal.y;\n    normal.y = e;\n    return normalize(normal);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /*vec2 uv = fragCoord.xy /iResolution.xy;\n    vec4 point = texture(iChannel0, uv);*/\n    \n    vec2 uv = fragCoord.xy /iResolution.xy;\n    vec2 pixel = -1.0 + 2.0*uv;// vec2(iResolution.x*0.6, iResolution.y);\n\tpixel.x *= iResolution.x/iResolution.y;\n    \n    vec2 mv = -1.0 + 2.0*iMouse.xy/iResolution.xy+vec2(1.0, 0.0);\n    float Time = mod(iTime*CAMROTSPEED, 360.0);\n    pixel.x *= 0.6;\n\n    \n    vec3 ro = CAMPOS;\n    vec3 rd = normalize(vec3(pixel, 1.0));\n    \n    /*#ifdef SET_CAMERA_TARGET_ROTATION\n    ro.x = TARGETPOS.x+cos(Time*CAMROTSPEED)*CAMDIST;\n    ro.z = TARGETPOS.z+sin(Time*CAMROTSPEED)*CAMDIST;\n    mat3 ca = setCamera(ro, TARGETPOS, vec3(0.0, 1.0, 0.0));\n    rd = ca*normalize(vec3(pixel.xy, 2.0));\n    #else\n    \t#ifdef USE_MARCH\n    \t/*vec3 campath = vec3(\n            cos(iTime*CAMROTSPEED)*CAMDIST,\n            0.0,\n            sin(iTime*CAMROTSPEED)*CAMDIST+Time*30.0);\n        ro += campath;\n        mat3 ca = setCamera(ro, ro+campath, vec3(0.0, 1.0, 0.0));\n        rd = ca*normalize(vec3(pixel.xy, 2.0));*//*\n    \tro.x = iTime*2.0;\n    \tro.z = iTime*2.0;\n        mat3 ca = setCamera(ro, ro+vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 0.0));\n        rd = ca*normalize(vec3(pixel.xy, 2.0));\n    \t\n    \t#else\n            mat3 ca = setCamera(ro, ro+vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 0.0));\n            rd = ca*normalize(vec3(pixel.xy, 2.0));\n    \t#endif\n    #endif\n    #ifdef SET_CAMERA_DEFAULT_ROTATION\n        rd = RotYV3(rd, Time*CAMROTSPEED);\n    #endif\n    #ifdef SET_CAMERA_SUNDOWN\n    \trd = RotYV3(rd, -1.0);\n    #endif\n    #ifdef SET_CAMERA_SUNRISE\n    \trd = RotYV3(rd, 3.10);\n    #endif*/\n    \n    GetCamera(uv,pixel,iTime,ro,rd);\n    \n    float depth = texture(iChannel0, uv).r;\n    vec3 point = ro+rd*depth;\n    \n   \tfragColor = vec4(mapNormal(point.xyz, 0.01), 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/***********************************************************************\n * author: pierre.plans@gmail.com\n ***********************************************************************/\n\n/**\n * RENDERING OPTION GLOBALS\n **/\n// wanna see only the depth camera ? Okay !\n//#define USE_DEPTHMODE\n// make the setting more realistic with a few computing performance\n#define USE_SOFTSHADOWS\n// this makes shader crashing under firefox\n//#define USE_SOFTSHADOWS_ON_REFLECTION\n// defines if the algorithm will use a rotating (X axis) light around 0.0, 0.0, 0.0\n// using LIGHTSPEED\n#define USE_LIGHTMOVING\n// defines if the algorithm will use a rotating (Y axis) moon around 0.0, 0.0, 0.0\n// using MOONSPEED\n//#define USE_MOONMOVING\n// defines if the clouds are animated or not, using CLOUDSPEED\n#define USE_ANIMATECLOUDS\n// defines that the algorithm will perform water reflection (costs a lot)\n#define USE_WATER_REFLECTION\n// defines that the algorithm will perform water refraction (costs a few)\n#define USE_WATER_REFRACTION\n// defines that the algorithm will perform day&night simulation\n#define USE_DAYANDNIGHT\n// defines that the algorithm will use a better noise for the star generation\n//#define USE_HD_STARNOISE\n// defines if the algorithm will draw the sun\n#define DRAW_SUN\n// defines if the algorithm will draw the moon\n#define DRAW_MOON\n// old looking lighting without moon light and not accurate lighting\n//#define OLDLIGHTING\n#define USE_BOREALS\n// define if we are going to have more rocks or not\n#define USE_MORE_ROCKY\n// have the mountains noise different from terrain one\n#define USE_HD_MOUNTAIN\n// USE_HD_MOUNTAIN_NOISE has a priority over USE_FAST_HD_TERRAIN_NOISE, so chose only one\n// Use a voronoi 3D noise for the rocky bump map (costs a lot)\n//#define USE_HD_MOUNTAIN_NOISE\n// Use a voronoi 2D noise for the rocky bump map (costs a little bit less than USE_HD_TERRAIN_NOISE)\n#define USE_FAST_HD_MOUNTAIN_NOISE\n// USE_HD_TERRAIN_NOISE has a priority over USE_FAST_HD_TERRAIN_NOISE, so chose only one\n// Use a simplex 3D noise for the terrain bump map (costs a lot)\n//#define USE_HD_TERRAIN_NOISE\n// Use a simplex 2D noise for the terrain bump map (costs a little bit less than USE_HD_TERRAIN_NOISE)\n#define USE_FAST_HD_TERRAIN_NOISE\n\n#define RAYMARCHING_NUM_STEPS 40\n#define RAYMARCHING_REFL_NUM_STEPS 20\n#define RAYMARCHING_REFR_NUM_STEPS 20\n#define SOFTSHADOW_STEPS 8\n\n#define SAND_OCTAVES 6\n#define SAND_GRAINS 1\n#define CAMDIST 8.0\n#define CAMROTSPEED 0.2\n#define LIGHTSPEED 1.0\n#define MOONSPEED 0.5\n#define CLOUDSPEED 0.1\n#define AURORABOREALISSPEED 3.0\n\n// 0.4 default only for OLDLIGHTING\n#define VAR_REFL_OVER_REFR_PERCT 0.5\n/*\n\tA variation I liked, with greater islands/continents\n\n#define VAR_TERRAIN_LEVEL 9.0\n#define VAR_TERRAIN_AMP 12.5\n#define VAR_TERRAIN_FREQ 0.05\n*/\n/*\n\tDefault variation\n#define VAR_TERRAIN_LEVEL 5.0\n#define VAR_TERRAIN_AMP 8.5\n#define VAR_TERRAIN_FREQ 0.2\n*/\n// 5.0\n#define VAR_TERRAIN_LEVEL 5.0\n// 8.5\n#define VAR_TERRAIN_AMP 8.5\n// 0.2\n#define VAR_TERRAIN_FREQ 0.2\n#define VAR_TERRAIN_LIGHTING_KD 1.0\n#define VAR_TERRAIN_LIGHTING_KS 1.0\n#define VAR_TREE_LIGHTING_KD 1.0\n#define VAR_TREE_LIGHTING_KS 1.0\n\n#define VAR_WATER_LEVEL 0.4\n// 0.08 - 0.1 is a good value for VAR_WATER_AMP\n#define VAR_WATER_AMP 0.001\n#define VAR_WATER_FREQ 4.0\n#define VAR_WATER_SPEED 1.5\n\n#define WATER_DEPTH_VISIBILITY 0.6\n#define WATER_DEPTH_MAX 20.0\n\n#define REFLREFR_FRESNEL_BIAS 0.18\n#define REFLREFR_FRESNEL_SCALE 1.0\n#define REFLREFR_FRESNEL_EXPO 0.8\n\n// water info\n#define WATER_REFR_INDEX 1.0/1.33\n\n// old\n//#define VAR_MOONRADIUS 1.0\n#define VAR_MOONRADIUS 200.0\n\n#define VAR_MOUNTAIN_LIGHTING_KD 1.0\n#define VAR_MOUNTAIN_LIGHTING_KS 1.0\n\n\n//#define COLORROCK vec3(0.5, 0.5, 0.6)\n#define COLORROCK vec3(0.8, 0.8, 0.7)\n#define COLORGRASS vec3(0.5, 0.9, 0.5)\n#define COLORTREE vec3(0.0, 0.4, 0.0)\n#define COLORSAND vec3(0.9, 0.9, 0.5)\n#define COLORWATER vec3(0.02, 0.05, 0.1)\n#define COLORSKYDAY vec3(0.5, 0.5, 1.0)\n#define COLORSKYDAWN vec3(1.0, 0.6, 0.5)\n#define COLORSKYNIGHT vec3(0.1, 0.2, 0.4)\n\n#define TYPE_TERRAIN 0.0\n#define TYPE_WATER 1.0\n#define TYPE_TREES 2.0\n#define TYPE_MOUNTAIN 3.0\n\n// HDR sky parameters\n#define SCALE_HEIGHT\t\t 8000.0\n#define SUNDIST \t149597870700.0\n#define EARTHRADIUS\t\t\t 6360e3\n#define ATMOSPHERERADIUS \t6420e3\n#define SUNINTENSITY\t\t 20.0\n#define SUNRADIUS \t  695700000.0\n#define MOONRADIUS \t\t1737400.0\n#define EARTHPOS vec3(0.0, 0.0, 0.0)\n\n#define SUNPOS normalize(vec3(1.0, 1.0, 1.0))*149597870700.0\n#define MOONPOS normalize(vec3(1.0, 0.5, 0.7))*384467700.0\n\nstruct Light {\n    vec3 o;\n    vec3 d;\n    vec4 diffuseColor;\n    vec4 specularColor;\n    float shininess;\n\tfloat power;\n};\n\nLight _light = Light(\n    SUNPOS,\n    normalize(EARTHPOS-SUNPOS),\n    vec4(1.0, 1.0, 0.8, 1.0),\n    vec4(1.0, 1.0, 0.8, 1.0),\n    2.0,\n    SUNINTENSITY);\n\nLight _moon = Light(\n    MOONPOS,\n    normalize(EARTHPOS-MOONPOS),\n    vec4(1.0, 1.0, 0.8, 1.0),\n    vec4(1.0, 1.0, 0.8, 1.0),\n    2.0,\n    1.0);\n\nfloat IntersectSphere(vec3 ro, vec3 rd, vec3 sc, float sr, out float tmin, out float tmax) {\n    vec3 Z = ro-sc;\n    float B = 2.0 * dot(rd, Z);\n    float C = Z.x*Z.x+Z.y*Z.y+Z.z*Z.z-sr*sr;\n    float D = B*B - 4.0*C;\n    float d = -1.0;\n    if(D>=0.0) {\n        if(C==0.0) {\n            tmax = -B/2.0;\n            d = 0.0;\n        }else{\n            tmin = (-B-sqrt(D))/2.0;\n            tmax = (-B+sqrt(D))/2.0;\n            d = 1.0;\n        }\n    }\n    return d;\n}\n/**\n * PRIMITIVES\n **/\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float r )\n{\n    return length(p)-r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdCappedCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n/**\n * (Distance, Type) with Type =\n * 0.0 == Nthg\n **/\n\n/***********************\n * PRIMITIVE OPERATIONS\n ***********************/\n\n// polynomial smooth min (k = 0.1);\nvec2 polsmin( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return vec2(mix( b.x, a.x, h ) - k*h*(1.0-h), floor(mix( b.y, a.y, h )*2.0));\n}\n\n// polynomial smooth min (k = 0.1);\nvec2 polsmax( vec2 a, vec2 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    return vec2(mix( b.x, a.x, 1.0-h ) - k*h*(1.0-h), floor(mix( b.y, a.y, 1.0-h )*2.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opI( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x>d2.x) ? d1 : d2;\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<-d2.x) ? d1 : d2;\n}\n\n/*******************\n * MAP ACTUAL ELEMENTS\n *******************/\n\nfloat getWaterLevel(vec3 p)\n{\n    float h = VAR_WATER_LEVEL;\n    float a = VAR_WATER_AMP;\n    float f = VAR_WATER_FREQ;\n    for(int i=0;i<2;++i) {\n        h += fbm_hash(p.xz*f+iTime*VAR_WATER_SPEED)*a;\n        h += fbm_hash(p.xz*f-iTime*VAR_WATER_SPEED)*a;\n        a *= 0.6;\n        f *= 1.4;\n    }\n    //\n    f *= 0.01;\n    float t = iTime*VAR_WATER_SPEED*0.1;\n    //float n = (hash(p.xz+t)+hash(p.xz-t));\n    //float n = 0.005*(fbm_hash(3.0*p.xz+t)+fbm_hash(3.0*p.xz-t));\n    float n = 0.05*fbm_hash(0.5*p.xz+t)+fbm_hash(0.5*p.xz-t);\n    return h+n;\n    return (h+a*(fbm_hash(f*p.xz+t)+fbm_hash(f*p.xz-t)));\n    //\n    return h;\n}\n\nfloat getWaterLevelDetails(vec3 p)\n{\n    float h = VAR_WATER_LEVEL;\n    float a = VAR_WATER_AMP;\n    float f = VAR_WATER_FREQ;\n    for(int i=0;i<2;++i) {\n        h += fbm_hash(p.xz*f+iTime*VAR_WATER_SPEED)*a;\n        h += fbm_hash(p.xz*f-iTime*VAR_WATER_SPEED)*a;\n        a *= 0.6;\n        f *= 1.4;\n    }\n    //\n    //#define showwaternormal\n    f *= 0.01;\n    float t = iTime*VAR_WATER_SPEED*0.1;\n    //float n = (hash(p.xz+t)+hash(p.xz-t));\n    //float n = 0.005*(fbm_hash(3.0*p.xz+t)+fbm_hash(3.0*p.xz-t));\n    float n = 0.05*(fbm_hash(2.0*p.xz+t)+fbm_hash(2.0*p.xz-t));\n    return h+n;\n    return (h+a*(fbm_hash(f*p.xz+t)+fbm_hash(f*p.xz-t)));\n    //\n    return h;\n}\n\n/*******************\n * MAP ACTUAL\n *******************/\n\nvec3 mapNormalWater(vec3 pt, float e) {\n    #define highdefnormal\n    #ifdef highdefnormal\n    vec3 normalbase;\n    normalbase.y = pt.y+getWaterLevel(pt);\n    normalbase.x = pt.y+getWaterLevel(vec3(pt.x+e,pt.y,pt.z)) - normalbase.y;\n    normalbase.z = pt.y+getWaterLevel(vec3(pt.x,pt.y,pt.z+e)) - normalbase.y;\n    normalbase.y = e;\n    #endif\n    vec3 normal;\n    normal.y = pt.y+getWaterLevelDetails(pt);\n    normal.x = pt.y+getWaterLevelDetails(vec3(pt.x+e,pt.y,pt.z)) - normal.y;\n    normal.z = pt.y+getWaterLevelDetails(vec3(pt.x,pt.y,pt.z+e)) - normal.y;\n    normal.y = e;\n    return normalize(normalbase+normal);\n}\n\n/************************\n * RENDERING\n ************************/\n\nfloat fresnel(vec3 I, vec3 N, float B, float S, float E)\n{\n    return B+S*pow(max(0.0, 1.0+dot(I,N)),E);\n}\n\nfloat clouds(in vec3 ro, in vec3 rd)\n{\n    float sum = 0.0;\n    rd = rd*100.0;\n    sum = pow(fbm3D(ro*0.4+rd/rd.y*0.6, iTime), 4.0)*10.0;\n    sum *= rd.y/length(rd);\n    return sum;\n}\n\nvec3 lighting(vec3 rd, vec3 n, float Kd, float Ks) {\n    vec3 lightingComp = vec3(0.0);\n    float limit = 0.15;\n    \n    vec3 lightingCompDay = Kd*max(0.0, dot(-_light.d, n))*_light.diffuseColor.rgb;\n    if(Ks>0.0)\n    {\n        float sT = dot(rd, -reflect(_light.d, n));\n        lightingCompDay += Ks*pow(sT, _light.shininess);\n    }\n    return lightingCompDay;\n}\n\nfloat Fresnel_Schlick(float n1, float n2, float NdotV)\n{\n    float R0 = (n1-n2)/(n1+n2);\n    R0 *= R0;\n    return R0+(1.0-R0)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV);\n}\n\nfloat beckmannDistribution(float roughness, float NdotH)\n{\n    float r1 = 1.0 / ( 4.0 * roughness * roughness * pow(NdotH, 4.0));\n    float r2 = (NdotH * NdotH - 1.0) / (roughness * roughness * NdotH * NdotH);\n    return r1 * exp(r2);\n}\n\n// https://github.com/stackgl/glsl-specular-cook-torrance/blob/master/index.glsl\nfloat cookTorranceSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float fresnel) {\n\n  float VdotN = max(dot(viewDirection, surfaceNormal), 0.0);\n  float LdotN = max(dot(lightDirection, surfaceNormal), 0.0);\n\n  //Half angle vector\n  vec3 H = normalize(lightDirection + viewDirection);\n\n  //Geometric term\n  float NdotH = max(dot(surfaceNormal, H), 0.00001);\n  float VdotH = max(dot(viewDirection, H), 0.000001);\n  float LdotH = max(dot(lightDirection, H), 0.000001);\n  float G1 = (2.0 * NdotH * VdotN) / VdotH;\n  float G2 = (2.0 * NdotH * LdotN) / LdotH;\n  float G = min(1.0, min(G1, G2));\n  \n  //Distribution term\n  float D = beckmannDistribution(roughness, NdotH);\n\n  //Fresnel term\n  float F = pow(1.0 - VdotN, fresnel);\n\n  //Multiply terms and done\n  return  G * F * D / max(3.14159265 * VdotN * LdotN, 0.000001);\n}\n\nvec3 brdf(\n    float Ks,\n    float Kd,\n    float roughness,\n    float opacity,\n    vec3 specularColor,\n    vec3 diffuseColor,\n    vec3 I,\n    vec3 N,\n    vec3 L)\n{\n    vec3 Vn = -I;\n    float NdotV = dot(Vn, N);\n    vec3 C = vec3(0.0);\n    float Oi = opacity;\n    float spec = 0.0;\n    if(NdotV>0.0)\n    {\n        float F = Fresnel_Schlick(1.0, 1.0, NdotV);\n        spec = cookTorranceSpecular(L, Vn, N, roughness, F);\n    }\n    return (Kd*diffuseColor*max(0.0, NdotV)+Ks*specularColor*spec) * Oi;\n}\n\n\n// terrence cook\n// https://renderman.pixar.com/view/cook-torrance-surface-shader-code\n// http://www.trentreed.net/blog/physically-based-shading-and-image-based-lighting/\n/*vec3 brdf(\n          float Ks,\n          float Kd,\n          float roughness,\n          float opacity,\n          vec3 specularColor,\n          vec3 diffuseColor,\n          float gaussConstant,\n         vec3 I,\n         vec3 N,\n         vec3 L){\n    // illuminance\n    vec3 Vn = -I;\n    float NdotV = dot(Vn, N);\n    vec3 C = vec3(0.0);\n    float Oi = opacity;\n    if(NdotV>0.0)\n    {\n        float F = Fresnel_Schlick(1.0, 1.0, NdotV);\n        //float F = fresnel(Vn, N, 0.0, 1.0, 1.0);\n        vec3 H = normalize(Vn+L);\n        float NdotH = dot(N, H);\n        float NdotL = dot(N, L);\n        float VdotH = dot(Vn, H);\n        if(NdotL>0.0)\n        {\n            // G\n            float G = min(1.0, min(2.0*NdotH*NdotV/VdotH, 2.0*NdotH*NdotL/VdotH));\n            // Microfacet slope distribution D\n            float alpha = acos(NdotH);\n            float D = gaussConstant*exp(-(alpha*alpha)/(roughness*roughness));\n            // cook\n            C = _light.diffuseColor.rgb*(F*D*G)/(3.14*NdotV);\n            C /= 3.14;\n        }\n    }\n    return (Kd*diffuseColor*max(0.0, NdotV)+Ks*specularColor*C) * Oi;\n}*/\n\nfloat fractWave(float x)\n{\n    return abs(2.0*fract(x-0.5));\n}\n// From http://www.scratchapixel.com/old/lessons/3d-advanced-lessons/simulating-the-colors-of-the-sky/atmospheric-scattering/\nvec3 getSkyLight(vec3 ro, vec3 rd, vec3 L)\n{\n    vec3 light = vec3(0.0);\n    float tmin = 0.0;\n    float tmax = 0.0;\n    float d = IntersectSphere(ro, rd, EARTHPOS, ATMOSPHERERADIUS, tmin, tmax);\n    vec3 Pa = ro+rd*tmax;\n    /*if(d>0.0)\n        Pa = ro+rd*(tmax-tmin);*/\n    float RdotL = dot(rd, L);\n    float tCurrent = 0.0;\n    float segL = tmax/16.0;\n    /*if(d>0.0)\n        segL = (tmax-tmin)/16.0;*/\n    float g = 0.76; // 0.76\n    float g2 = g*g;\n    float hr = 7994.0; // 7994\n    float hm = 300.0; // 1200\n    // Rayleigh\n    vec3 sumR = vec3(0.0);\n    float phaseR = 3.0/(16.0*3.14)*(1.0+RdotL*RdotL);\n    vec3 betaR = vec3(5.5e-6, 13.0e-6, 22.4e-6);\n    float opticalDepthR = 0.0;\n    // Mie\n    vec3 sumM = vec3(0.0);\n    //float phaseM = 3.0/(8.0*3.14)*((1.0-g*g)+(1.0+RdotL*RdotL))/((2.0+g*g)+pow(1.0+g*g-2.0*g*RdotL, 1.5));\n    // correction thanks to from http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter16.html\n    // my implementation has an error with the first terms in the equation\n    float phaseM = (\n        \t\t\t(3.0*(1.0-g2))/\n        \t\t\t(2.0*(2.0+g2))\n        \t\t\t)*\n        \t\t\t(\n                        (1.0+RdotL*RdotL)/\n                        pow(1.0+g2-2.0*g*RdotL, 1.5)\n                    );\n    vec3 betaM = vec3(21e-6);\n    float opticalDepthM = 0.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        vec3 X = ro+rd*(tCurrent+0.5*segL);\n        float h = length(X) - EARTHRADIUS;\n        float _hr = exp(-h/hr)*segL;\n        float _hm = exp(-h/hm)*segL;\n        opticalDepthR += _hr;\n        opticalDepthM += _hm;\n        vec3 lRay = L;//normalize((SUNDIST*L)-X);\n        float tlmin = 0.0;\n        float tlmax = 0.0;\n        float dl = IntersectSphere(X, L, EARTHPOS, ATMOSPHERERADIUS, tlmin, tlmax);\n        float segLLight = tlmax/8.0;\n        float tCurrentLight = 0.0;\n        float opticalDepthLightR = 0.0;\n        float opticalDepthLightM = 0.0;\n        bool ended = true;\n        for (int j = 0; j < 8; ++j)\n        {\n            vec3 samplePositionLight = X+L*(tCurrentLight + 0.5 * segLLight);\n            float hLight = length(samplePositionLight) - EARTHRADIUS;\n            if (hLight < 0.0)\n            {\n                ended = false;\n                break;\n            }\n            opticalDepthLightR += exp(-hLight / hr) * segLLight;\n            opticalDepthLightM += exp(-hLight / hm) * segLLight;\n            tCurrentLight += segLLight;\n        }\n        if (ended)\n        {\n            vec3 tau = betaR * (opticalDepthR + opticalDepthLightR) + betaM * 1.1 * (opticalDepthM + opticalDepthLightM);\n            vec3 attenuation = vec3(exp(-tau.x), exp(-tau.y), exp(-tau.z));\n            sumR += _hr * attenuation;\n            sumM += _hm * attenuation;\n        }\n        tCurrent += segL;\n    }\n    return SUNINTENSITY * (sumR * phaseR * betaR + sumM * phaseM * betaM);\n}\n\nvec3 getNightLight(vec3 ro, vec3 rd, vec3 L)\n{\n    vec3 light = vec3(0.0);\n    float tmin = 0.0;\n    float tmax = 0.0;\n    float d = IntersectSphere(ro, rd, EARTHPOS, ATMOSPHERERADIUS, tmin, tmax);\n    vec3 Pa = ro+rd*tmax;\n    /*if(d>0.0)\n        Pa = ro+rd*(tmax-tmin);*/\n    float RdotL = dot(rd, L);\n    float tCurrent = 0.0;\n    float segL = tmax/16.0;\n    /*if(d>0.0)\n        segL = (tmax-tmin)/16.0;*/\n    float g = 0.76; // 0.76\n    float g2 = g*g;\n    float hr = 7994.0; // 7994\n    float hm = 60.0; // 1200\n    // Rayleigh\n    vec3 sumR = vec3(0.0);\n    float phaseR = 3.0/(60.0*3.14)*(1.0+RdotL*RdotL);\n    vec3 betaR = vec3(0.8e-6, 0.5e-6, 1.0e-6);\n    float opticalDepthR = 0.0;\n    // Mie\n    vec3 sumM = vec3(0.0);\n    float phaseM = (\n        \t\t\t(3.0*(1.0-g2))/\n        \t\t\t(2.0*(2.0+g2))\n        \t\t\t)*\n        \t\t\t(\n                        (1.0+RdotL*RdotL)/\n                        pow(1.0+g2-2.0*g*RdotL, 1.5)\n                    );\n    vec3 betaM = vec3(1e-6);\n    float opticalDepthM = 0.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        vec3 X = ro+rd*(tCurrent+0.5*segL);\n        float h = length(X) - EARTHRADIUS;\n        float _hr = exp(-h/hr)*segL;\n        float _hm = exp(-h/hm)*segL;\n        opticalDepthR += _hr;\n        opticalDepthM += _hm;\n        vec3 lRay = L;//normalize((SUNDIST*L)-X);\n        float tlmin = 0.0;\n        float tlmax = 0.0;\n        float dl = IntersectSphere(X, L, EARTHPOS, ATMOSPHERERADIUS, tlmin, tlmax);\n        float segLLight = tlmax/8.0;\n        float tCurrentLight = 0.0;\n        float opticalDepthLightR = 0.0;\n        float opticalDepthLightM = 0.0;\n        bool ended = true;\n        for (int j = 0; j < 8; ++j)\n        {\n            vec3 samplePositionLight = X+L*(tCurrentLight + 0.5 * segLLight);\n            float hLight = length(samplePositionLight) - EARTHRADIUS;\n            if (hLight < 0.0)\n            {\n                ended = false;\n                break;\n            }\n            opticalDepthLightR += exp(-hLight / hr) * segLLight;\n            opticalDepthLightM += exp(-hLight / hm) * segLLight;\n            tCurrentLight += segLLight;\n        }\n        if (ended)\n        {\n            vec3 tau = betaR * (opticalDepthR + opticalDepthLightR) + betaM * 1.1 * (opticalDepthM + opticalDepthLightM);\n            vec3 attenuation = vec3(exp(-tau.x), exp(-tau.y), exp(-tau.z));\n            sumR += _hr * attenuation;\n            sumM += _hm * attenuation;\n        }\n        tCurrent += segL;\n    }\n    return SUNINTENSITY * (sumR * phaseR * betaR/* + sumM * phaseM * betaM*/);\n}\n\nfloat cloudScattering(vec3 O, vec3 E, vec3 L)\n{\n    float scat = 0.0;\n    float g = 0.76; // 0.76\n    float g2 = g*g;\n    float f=0.000002;\n    float T = iTime;\n    for(int i=0;i<4;++i)\n    {\n        float tmin, tmax;\n        float d = IntersectSphere(O, E, EARTHPOS, ATMOSPHERERADIUS, tmin, tmax);\n        if(tmax>0.0)\n        {\n            vec3 P = (O+E*tmax)*f+vec3(iTime, 0.0, iTime);\n            float c = waterNoise((P/P.y*1.0).xz+T)*(1.0-voronoi3D(P/P.x*0.4))*(P.y*0.2);\n            float EdotL = max(0.0, dot(E, L));\n            float phaseR = 3.0/(16.0*3.14)*(1.0+EdotL*EdotL);\n            float phaseM = (\n                (3.0*(1.0-g2))/\n                (2.0*(2.0+g2))\n                )*\n                (\n                    (1.0+EdotL*EdotL)/\n                    pow(1.0+g2-2.0*g*EdotL, 1.5)\n                );\n                    // absorbtion\n            scat -= phaseR*c;\n            // scattering\n            scat += phaseM*c;\n        }\n        f*=1.01;\n    }\n    \n    \n    return scat;\n}\n\nvec3 getSkyColor(vec3 ro, vec3 rd)\n{\n    vec3 color = getSkyLight(ro+vec3(0.0, EARTHRADIUS, 0.0), rd, -_light.d);\n    float daynight = max(0.0, dot(vec3(0.0, 1.0, 0.0), -_light.d));\n    color = mix(\n        getNightLight(ro+vec3(0.0, EARTHRADIUS, 0.0), rd, -_moon.d),\n        color,\n        daynight\n        );\n    vec3 L = mix(-_moon.d, -_light.d, daynight);\n\n    float tmin = 0.0;\n    float tmax = 0.0;\n    float sunGrad = 0.0;\n    float moonGrad = 0.0;\n    float d = 0.0;\n    vec3 mn = vec3(0.0);\n    vec3 sn = vec3(0.0);\n    if(rd.y<0.0)\n        return color;\n    // sun\n    vec3 betaR = vec3(0.8e-6, 0.5e-6, 1.0e-6);\n    d = IntersectSphere(ro, rd, _light.o, SUNRADIUS*10.0, tmin, tmax);\n    if(tmin>0.0)\n    {\n        sn = normalize(ro+rd*tmin-_light.o);\n        sunGrad = _light.power;//pow(max(0.0, dot(-rd, sn)), 4.0);\n    }\n    vec3 sunhalo = \n        vec3(pow(max(0.0, dot(rd, normalize(_light.o-ro))), 258.0));\n    \n    // moon\n   \td = IntersectSphere(ro, rd, _moon.o, MOONRADIUS*10.0, tmin, tmax);\n    if(tmin>0.0)\n    {\n   \t\t//moonGrad = pow(max(0.0, dot(rd, -_moon.d)), 1.0);\n        mn = normalize(ro+rd*tmin-_moon.o);\n        moonGrad = max(0.0, dot(-rd, mn));\n    }\n    vec3 moonhalo = mix(\n        vec3(pow(max(0.0, dot(rd, normalize(_moon.o-ro))), 258.0)),\n        vec3(0.0),\n        daynight\n        );\n    \n    //color = mix(color, vec3(sunGrad), sunhalo);\n    //color += sunhalo+sunGrad;\n    color = mix(color, texture(iChannel2, rd.xy*vec2(0.4, 0.3)).rgb*moonGrad+moonhalo, moonhalo);\n    \n    // \"cheap clouds\"\n    vec2 seed = 1000.0*rd.xy/iResolution.xy;\n    // c4 => 8 freq\n    // cs => 8 freq\n    // cv => 100 freq\n    // end compo => 20 freq\n    float c4 = 2.0*(-0.5+fbm_hash(2.0*(seed+iTime*0.05)));\n    float cs = fbm_hash(2.0*(seed+vec2(0.5))-iTime*0.05);\n    float clouds = smoothstep(0.0, 1.0, c4*cs);\n    float cv = max(0.8, 1.0-voronoi2D(25.0*(seed+c4*cs)));\n    clouds += cv*clouds*fbm_hash(5.0*(seed-iTime*0.05));\n    for(int i = 0; i < 4; ++i)\n    {\n        \n    }\n    clouds = max(0.0, clouds);\n    color += vec3(\n            2.0*clouds*(max(0.0, dot(normalize(rd-L), rd))-0.4*clouds)\n    );\n    //color+=cloudScattering(ro, rd, _light.d);\n    // end \"cheap clouds\"\n    \n    return clamp(color, 0.0, 1.0);\n}\n    \nvec3 texturing(vec4 pointAndType, vec3 rd, vec3 n, float specOpacity, vec3 L)\n{\n    vec3 c = vec3(0.0);\n    if(pointAndType.w==TYPE_TERRAIN) {\n        c = mix(COLORSAND,\n                      COLORGRASS*(hash2D(pointAndType.xz)+8.0)*0.09,\n                      min(1.0, max(0.0, (pointAndType.y+VAR_WATER_LEVEL)*VAR_TERRAIN_LEVEL*0.2))\n                     )*texture(iChannel2, pointAndType.xz).rgb;\n        c = brdf(VAR_TERRAIN_LIGHTING_KS*specOpacity, VAR_TERRAIN_LIGHTING_KD,\n                 1.0, // roughness\n                 0.8, // opacity\n                 vec3(0.5), // specular\n                 c, // diffuse\n                 rd,\n                 n,\n                 L);\n        //c+=lighting(rd, n, VAR_TERRAIN_LIGHTING_KD, VAR_TERRAIN_LIGHTING_KS);\n\n    }else if(pointAndType.w == TYPE_TREES)\n    {\n        c = COLORTREE*hash2D(pointAndType.xz);\n        c = brdf(VAR_TREE_LIGHTING_KS*specOpacity, VAR_TREE_LIGHTING_KD,\n                 1.0, // roughness\n                 0.6, // opacity\n                 vec3(1.0), // specular\n                 c, // diffuse\n                 rd,\n                 n,\n                 L); \n    }\n    else if(pointAndType.w == TYPE_MOUNTAIN)\n    {\n        c = COLORROCK*max(0.8, hash2D(pointAndType.xz));\n        c = brdf(VAR_MOUNTAIN_LIGHTING_KS*specOpacity, VAR_MOUNTAIN_LIGHTING_KD,\n                 0.2, // roughness\n                 0.4, // opacity\n                 vec3(1.0), // specular\n                 c, // diffuse\n                 rd,\n                 n,\n                 L);\n        //c += lighting(rd, n, VAR_MOUNTAIN_LIGHTING_KD, VAR_MOUNTAIN_LIGHTING_KS);\n    }\n    return c;\n}\n\n// https://www.shadertoy.com/view/lstSRS\nvec3 tonemapping(vec3 color)\n{\n    //Tonemapping and color grading\n    color = pow(color, vec3(1.5));\n    color = color / (1.0 + color);\n    color = pow(color, vec3(1.0 / 1.5));\n\n    \n    color = mix(color, color * color * (3.0 - 2.0 * color), vec3(1.0));\n    color = pow(color, vec3(1.3, 1.20, 1.0));    \n\n\tcolor = clamp(color * 1.01, 0.0, 1.0);\n    \n    color = pow(color, vec3(0.7 / 2.2));\n    return color;\n}\n\nvec3 rendering(mat3 view, vec3 ro, vec3 rd, vec4 rm, vec2 uv, vec3 normal) {\n    vec3 p = ro+rd*rm.x;\n    vec4 point = vec4(p, rm.y);\n    vec3 n = normalize(normal.xyz);\n    vec3 color = vec3(0.0);\n    float daynight = max(0.0, dot(vec3(0.0, 1.0, 0.0), -_light.d));\n    vec3 L = mix(_moon.d, _light.d, daynight);\n    \n    vec3 H = normalize(-rd-L);\n    /*vec3 L = _light.d;\n    if(dot(_light.d, vec3(0.0, 1.0, 0.0))>0.0)\n        L = _moon.d;*/\n    #ifdef USE_DEPTHMODE\n    color.r = color.g = color.b = (FAR-rm.x)/(FAR-NEAR);\n    #else\n    float waterLevel = getWaterLevel(p);\n    if(p.y>waterLevel)\n    {\n        color = texturing(point, rd, n, 1.0, L);\n    }\n    else\n    {\n        // new point in space\n        vec4 wp = vec4(ro+rd*rm.z, rm.y);\n        wp.y = waterLevel;\n        vec3 wn = mapNormalWater(wp.xyz, 0.01);\n        vec3 rdr = refract(rd, wn, WATER_REFR_INDEX);\n        vec3 rdrfl = reflect(rd, wn);\n        if(rdrfl.y<0.0) rdrfl.y = -rdrfl.y; // -rdrfl\n        \n        vec3 refrcolor = texturing(wp+0.01*vec4(rdr.xy, 0.0, 0.0), rdr, n, 1.0, L);\n        vec3 reflcolor = getSkyColor(wp.xyz, rdrfl);\n        \n        float f = clamp(fresnel(rd, wn, REFLREFR_FRESNEL_BIAS, REFLREFR_FRESNEL_SCALE, REFLREFR_FRESNEL_EXPO), 0.0, 1.0);\n        //f = Fresnel_Schlick(1.0, 1.33, max(0.0, dot(rd, wn)));\n        float depth = wp.y-p.y;\n        float dt=clamp(depth/WATER_DEPTH_VISIBILITY, 0.0, 1.0);\n        \n        //reflcolor = clamp(log(reflcolor), 0.0, 1.0);\n        color = mix(refrcolor*(1.0-dt), reflcolor*mix(1.0, 0.2, dt), dt*f);\n        color *= max(0.0, dot(H, 2.0*wn));\n        //color = wn;\n        //color *=(1.0-depth/3.0);\n        #ifdef showwaternormal\n        return wn;\n        #endif\n    }\n    \n    // shadows\n    /*vec3 wp = point.xyz;\n    for(int i = 1; i < 4; ++i)\n    {\n        wp += -L;\n        vec3 vp = normalize(inverse(view)*(point.xyz-ro));\n        float d = texture(iChannel0, vp.xy).r;\n        if(d<length(point.xyz-ro))\n            color = vec3(0.0);\n    }*/\n    \n    // real shadows\t\n    /*float res = 1.0;\n    float t = 0.001;\n\tfor( int i=0; i<80; i++ )\n\t{\n\t    vec3  p = ro + t*rd;\n        float h = p.y - textureLod( iChannel0, fract(p.xz), 0.0).x*.15;\n\t\tres = min( res, 20.*h/t );\n\t\tt += h;\n\t\tif( res<0.001) break;\n\t}\n\tcolor *= clamp( res, 0.1, 1.0 );*/\n    \n    // fog :)\n    for(int i = 1; i < 4; ++i)\n    {\n        color += pow(1.0-abs(rd.y), 64.0)*fbm_hash(0.4*vec2(0.0, iTime)+rd.xy*float(i)*10.0);\n    }\n    \n    //color *= (FAR-length(point.xyz))/(FAR-NEAR);\n\n    color += getSkyColor(ro ,rd);\n    #endif\n    return tonemapping(color);\n}\n\nvoid lightPos(float t, out vec3 lPos) {\n    mat3 rotX = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(t), -sin(t),\n        0.0, sin(t), cos(t));\n    mat3 rotY = mat3(\n        cos(t), 0.0, sin(t),\n        0.0, 1.0, 0.0,\n        -sin(t), 0.0, cos(t));\n    mat3 rotZ = mat3(\n        cos(t), -sin(t), 0.0,\n        sin(t), cos(t), 0.0,\n    \t0.0, 0.0, 1.0);\n    lPos = lPos*rotZ*rotX;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy /iResolution.xy;\n    vec2 pixel = -1.0 + 2.0*uv;// vec2(iResolution.x*0.6, iResolution.y);\n\tpixel.x *= iResolution.x/iResolution.y;\n    \n    vec2 mv = -1.0 + 2.0*iMouse.xy/iResolution.xy;\n    float Time = mod(iTime*CAMROTSPEED, 360.0);\n    //pixel.x *= 0.6;\n\n    \n    vec3 ro = CAMPOS;\n    vec3 rd = normalize(vec3(pixel, 1.0));\n    \n    mat3 ca = GetCamera(uv,pixel,iTime,ro,rd);\n\n    #ifdef USE_LIGHTMOVING\n    \t_light.o = RotXV3(_light.o, Time*LIGHTSPEED);\n    #endif\n    #ifdef USE_MOONMOVING\n    \t_moon.o = RotZV3(_moon.o, Time*MOONSPEED);\n    #endif\n    _light.d = normalize(EARTHPOS-_light.o);\n    _moon.d = normalize(EARTHPOS-_moon.o);\n    \n    vec4 rm = texture(iChannel0, uv);\n    vec3 normal = normalize(texture(iChannel1, uv).xyz);\n    vec3 color = rendering(ca, ro, rd, rm, uv, normal);\n    //color = normal;\n    fragColor = vec4(color, 1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n\n/**\n * RENDERING OPTION GLOBALS\n **/\n\n//#define USE_MARCH\n\n#define FAR 400.0\n#define NEAR 0.002\n\n#define CAMDIST 8.0\n#define CAMROTSPEED 0.2\n#define CAMPOS vec3(0.0, 10.0, 0.0)\n#define TARGETPOS vec3(-30.0, -5.0, -30.0)\n\n// camera rotation around TARGETPOS using CAMROTSPEED+CAMDIST, disable USE_MARCH\n//#define SET_CAMERA_TARGET_ROTATION\n// default camera rotation (look around)\n//#define SET_CAMERA_DEFAULT_ROTATION\n// setup the camera to see the sundawn\n#define SET_CAMERA_SUNDOWN\n// setup the camera to see the sunrise\n//#define SET_CAMERA_SUNRISE\n\n#define CLOUDSPEED 0.1\n\n// wanna see only the depth camera ? Okay !\n//#define USE_DEPTHMODE\n// make the setting more realistic with a few computing performance\n#define USE_SOFTSHADOWS\n// this makes shader crashing under firefox\n//#define USE_SOFTSHADOWS_ON_REFLECTION\n// defines if the algorithm will use a rotating (X axis) light around 0.0, 0.0, 0.0\n// using LIGHTSPEED\n#define USE_LIGHTMOVING\n// defines if the algorithm will use a rotating (Y axis) moon around 0.0, 0.0, 0.0\n// using MOONSPEED\n//#define USE_MOONMOVING\n// defines if the clouds are animated or not, using CLOUDSPEED\n#define USE_ANIMATECLOUDS\n// defines that the algorithm will perform water reflection (costs a lot)\n#define USE_WATER_REFLECTION\n// defines that the algorithm will perform water refraction (costs a few)\n#define USE_WATER_REFRACTION\n// defines that the algorithm will perform day&night simulation\n#define USE_DAYANDNIGHT\n// defines that the algorithm will use a better noise for the star generation\n//#define USE_HD_STARNOISE\n// defines if the algorithm will draw the sun\n#define DRAW_SUN\n// defines if the algorithm will draw the moon\n#define DRAW_MOON\n// old looking lighting without moon light and not accurate lighting\n//#define OLDLIGHTING\n#define USE_BOREALS\n// define if we are going to have more rocks or not\n#define USE_MORE_ROCKY\n// have the mountains noise different from terrain one\n#define USE_HD_MOUNTAIN\n// USE_HD_MOUNTAIN_NOISE has a priority over USE_FAST_HD_TERRAIN_NOISE, so chose only one\n// Use a voronoi 3D noise for the rocky bump map (costs a lot)\n//#define USE_HD_MOUNTAIN_NOISE\n// Use a voronoi 2D noise for the rocky bump map (costs a little bit less than USE_HD_TERRAIN_NOISE)\n#define USE_FAST_HD_MOUNTAIN_NOISE\n// USE_HD_TERRAIN_NOISE has a priority over USE_FAST_HD_TERRAIN_NOISE, so chose only one\n// Use a simplex 3D noise for the terrain bump map (costs a lot)\n//#define USE_HD_TERRAIN_NOISE\n// Use a simplex 2D noise for the terrain bump map (costs a little bit less than USE_HD_TERRAIN_NOISE)\n#define USE_FAST_HD_TERRAIN_NOISE\n\n#define OCTAVES 4\n\n/*******************\n * TOOLS\n *******************/\n\nvec2 UVTwist(in vec2 uv, float a, float T) {\n    float cA = cos(a+T);\n    float sA = sin(a+T);\n\treturn uv*mat2(cA, -sA, sA, cA);   \n}\n\nvec3 RotXV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(1.0, 0.0, 0.0, 0.0, cA, -sA, 0.0, sA, cA);\n}\nvec3 RotYV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(cA, 0.0, -sA, 0.0, 1.0, 0.0, sA, 0.0, cA);\n}\nvec3 RotZV3(in vec3 P, float A)\n{\n    float cA = cos(A), sA = sin(A);\n    return P*mat3(cA, -sA, 0.0, sA, cA, 0.0, 0.0, 0.0, 1.0);\n}\n\nfloat IntersectSphere(vec3 ro, vec3 rd, vec3 sc, float sr) {\n    vec3 Z = ro-sc;\n    float B = 2.0 * dot(rd, Z);\n    float C = Z.x*Z.x+Z.y*Z.y+Z.z*Z.z-sr*sr;\n    float D = B*B - 4.0*C;\n    float d = -1.0;\n    if(D>=0.0) {\n        if(C>0.0) {\n            d = (-B-sqrt(D))/2.0;\n        }else{\n            d = (-B+sqrt(D))/2.0;\n        }\n    }\n    return d;\n}\n\n/********************\n * NOISES\n ********************/\n\n/** HASH **/\n\nvec2 rot(vec2 X, float a)\n{\n \tfloat s = sin(a); float c = cos(a);\n    return mat2(c, -s, s, c)*X;\n}\n\nfloat hash(vec2 uv)\n{\n \tvec2 suv = sin(uv);\n    suv = rot(suv, uv.x);\n    return fract(mix(suv.x*13.13032942, suv.y*12.01293203924, dot(uv, suv)));\n}\n\nfloat custom_perlin_hash(vec2 uv)\n{\n \tvec2 lower\t= floor(uv);\n    vec2 frac \t= fract(uv);\n    vec2 f = frac*frac*(3.0-2.0*frac);\n    \n    return mix(\n        \tmix(hash(lower+vec2(0.0, 0.0)), hash(lower+vec2(1.0, 0.0)), f.x),\n        \tmix(hash(lower+vec2(0.0, 1.0)), hash(lower+vec2(1.0, 1.0)), f.x),\n        \tf.y);\n}\n\nfloat fbm_hash(vec2 uv)\n{\n    float total = 0.0;\n    total += 0.5000*custom_perlin_hash(uv); uv*=2.001;\n    total += 0.2500*custom_perlin_hash(uv); uv*=2.003;\n    total += 0.1250*custom_perlin_hash(uv); uv*=2.002;\n    total += 0.0625*custom_perlin_hash(uv); uv*=2.001;\n    return clamp(total, 0.0, 1.0);\n}\n\nfloat hash1D(float x) {\n\treturn fract(((x+124.2394943)*134.400594)*((x+7.13571113)*1.13497));\n}\n\nfloat hash2D(vec2 x) {\n\treturn fract(sin(dot(x, vec2(13.454, 7.405)))*12.3043);\n}\n\nfloat hash3D(vec3 x) {\n\treturn fract(dot(x, vec3(0.4955, 490.4294, 0.40594))*13.4959451);    \n}\n\nfloat voronoi2D(vec2 uv) {\n    vec2 fl = floor(uv);\n    vec2 fr = fract(uv);\n    float res = 1.0;\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec2 p = vec2(i, j);\n            float h = hash2D(fl+p);\n            vec2 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 16.0); // 8\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nfloat voronoi3D(vec3 uv) {\n    vec3 fl = floor(uv);\n    vec3 fr = fract(uv);\n    float res = 1.0;\n    for(int k=-1;k<=1;k++)\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec3 p = vec3(i, j, k);\n            float h = hash3D(fl+p);\n            vec3 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\n/**\n * noise and smoothNoise function were inspired by common knowledge found in internet.\n **/\nfloat hash2(float x) {\n    return fract(sin(x)*556858.4905705783);\n}\n\n/**\n * Inspired from a noisy function in \"Seascape\" by TDM\n **/\nfloat smoothNoise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 n = fract(x);\n    vec3 f = n*n*(3.0-2.0*n);\n    float winy = 157.0;\n    float winz = 113.0;\n    \n    float wx = p.x+winy*p.y+winz*p.z;\n    return mix(\n        \tmix(\n                mix(hash2(wx+0.0)     , hash2(wx+1.0), f.x),\n                mix(hash2(wx+0.0+winy), hash2(wx+1.0+winy), f.x),\n                f.y),\n        \tmix(\n                mix(hash2(wx+0.0+winz)     , hash2(wx+1.0+winz), f.x),\n                mix(hash2(wx+0.0+winy+winz), hash2(wx+1.0+winy+winz), f.x),\n                f.y)\n        , f.z);\n}\n\nfloat noise3D(vec3 x) {\n    vec3 p = floor(x);\n    vec3 n = fract(x);\n    vec3 f = n*n*(3.0-2.0*n);\n    float winx = 1.0;\n    float winy = 1.0;\n    float winz = 1.0;\n    \n    return mix(\n        \tmix(\n                mix(hash3D(p)     \t\t\t\t  , hash3D(p+vec3(winx, 0.0, 0.0)), f.x),\n                mix(hash3D(p+vec3(0.0, winy, 0.0)), hash3D(p+vec3(winx, winy, 0.0)), f.x),\n                f.y),\n        \tmix(\n                mix(hash3D(p+vec3(0.0, 0.0, winz)), hash3D(p+vec3(winx, 0.0, winz)), f.x),\n                mix(hash3D(p+vec3(0.0, winy, winz)), hash3D(p+vec3(winx, winy, winz)), f.x),\n                f.y),\n        \tf.z);\n}\n\nfloat waterNoise(vec2 x) {\n    vec2 p = floor(x);\n    vec2 n = fract(x);\n    vec2 f = n*n*(3.0-2.0*n);\n    float winx = 1.0;\n    float winy = 1.0;\n    \n    return mix(\n                mix(hash2D(p)     , hash2D(p+vec2(winx, 0.0)), f.x),\n                mix(hash2D(p+vec2(0.0, winy)), hash2D(p+vec2(winx, winy)), f.x),\n                f.y);\n}\n\nfloat noise1D(float x) {\n    float p = floor(x);\n    float n = fract(x);\n    float f = n*n*(3.0-2.0*n);\n    float winx = 1.0;\n    float winy = 2.0;\n    \n    return mix(\n                mix(hash1D(p)     , hash1D(p+winx), f),\n                mix(hash1D(p+winy), hash1D(p+winx+winy), f),\n                f);\n}\n\n// Simplex 2D noise\n// sources: Ian McEwan - https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl\n// sources: Patricio Gonzalez Vivo - https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\nfloat snoise(vec2 v){\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n                        -0.577350269189626, 0.024390243902439);\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod(i, 289.0);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n                     + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n                            dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n//  Simplex 3D Noise \n//  by Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //  x0 = x0 - 0. + 0.0 * C \n    vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n    vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n    vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n    // Permutations\n    i = mod(i, 289.0 ); \n    vec4 p = permute( permute( permute( \n        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                              + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n                     + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients\n    // ( N*N points uniformly over a square, mapped onto an octahedron.)\n    float n_ = 1.0/7.0; // N=7\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                 dot(p2,x2), dot(p3,x3) ) );\n}\n\n/**\n * This one is inspired by IQ code from this website.\n **/\nfloat fbm2D(vec2 p, float seed) {\n    float total = 0.0;\n    #ifdef USE_ANIMATECLOUDS\n    \tp.y += seed*CLOUDSPEED;\n    #endif\n    total  = 0.5000* snoise(p); p = p*2.0;\n    total += 0.2500* snoise(p); p = p*2.0;\n    total += 0.1250* snoise(p); p = p*2.0;\n    total += 0.0625* snoise(p); p = p*2.0;\n    return total;\n}\n\nfloat fbm3D(vec3 p, float seed) {\n    float total = 0.0;\n    /*total += 0.5000*smoothNoise(p*2.0);\n    total += 0.2500*smoothNoise(p*2.01);\n    total += 0.1250*smoothNoise(p*2.02);\n    total += 0.0625*smoothNoise(p*2.04);*/\n    #ifdef USE_ANIMATECLOUDS\n    \tp.y += seed*CLOUDSPEED;\n    #endif\n    total  = 0.5000* noise3D(p); p = p*2.0;\n    total += 0.2500* noise3D(p); p = p*2.0;\n    total += 0.1250* noise3D(p); p = p*2.0;\n    total += 0.0625* noise3D(p); p = p*2.0;\n    return total;\n}\n\nfloat fbm3DTerrain(vec3 p) {\n    float total = 0.0;\n    #ifdef USE_HD_TERRAIN_NOISE\n    total  = 0.5000* snoise(p); p = p*2.0;\n    total += 0.2500* snoise(p); p = p*2.0;\n    total += 0.1250* snoise(p); p = p*2.0;\n    total += 0.0625* snoise(p); p = p*2.0;\n    #else\n    \t#ifdef USE_FAST_HD_TERRAIN_NOISE\n        p*=0.8;\n        total  = 0.5000* snoise(p.xz); p = p*2.0;\n        total += 0.2500* snoise(p.xz); p = p*2.0;\n        total += 0.1250* snoise(p.xz); p = p*2.0;\n        total += 0.0625* snoise(p.xz); p = p*2.0;\n   \t \t#else\n        total  = 0.5000* noise3D(p); p = p*2.0;\n        total += 0.2500* noise3D(p); p = p*2.0;\n        total += 0.1250* noise3D(p); p = p*2.0;\n        total += 0.0625* noise3D(p); p = p*2.0;\n    \t#endif\n    #endif\n    return total;\n}\n\nfloat fbm3DMountain(vec3 p) {\n    float total = 0.0;\n    #ifdef USE_HD_MOUNTAIN_NOISE\n    p*=2.0;\n    total  = 0.5000* voronoi3D(p); p = p*2.0;\n    total += 0.2500* voronoi3D(p); p = p*2.0;\n    total += 0.1250* voronoi3D(p); p = p*2.0;\n    total += 0.0625* voronoi3D(p); p = p*2.0;\n    #else\n    \t#ifdef USE_FAST_HD_MOUNTAIN_NOISE\n        p*=2.0;\n        total  = 0.5000* voronoi2D(p.xz); p = p*2.0;\n        total += 0.2500* voronoi2D(p.xz); p = p*2.0;\n        total += 0.1250* voronoi2D(p.xz); p = p*2.0;\n        total += 0.0625* voronoi2D(p.xz); p = p*2.0;\n   \t \t#else\n        total  = 0.5000* waterNoise(p.xz); p = p*2.0;\n        total += 0.2500* waterNoise(p.xz); p = p*2.0;\n        total += 0.1250* waterNoise(p.xz); p = p*2.0;\n        total += 0.0625* waterNoise(p.xz); p = p*2.0;\n    \t#endif\n    #endif\n    return total;\n}\n\nfloat perlin(vec3 V) {\n    float total = 0.0;\n    for(int i=2;i<OCTAVES+2;i++) {\n        total += (1.0/float(i))*smoothNoise(V);\n        V*=2.0+(float(i)/100.0);\n    }\n    return total;\n}\n\n// the camera construction method is inspired by the one from IQ\nmat3 setCamera( in vec3 origin, in vec3 target, vec3 viewUp )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cu = normalize( cross(cw,viewUp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid camPos(float t, in vec3 rdi, in vec3 roi, out vec3 ro, out vec3 rd) {\n    mat3 rotX = mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(t), -sin(t),\n        0.0, sin(t), cos(t));\n    mat3 rotY = mat3(\n        cos(t), 0.0, sin(t),\n        0.0, 1.0, 0.0,\n        -sin(t), 0.0, cos(t));\n    mat3 rotZ = mat3(\n        cos(t), sin(t), 0.0,\n        -sin(t), cos(t), 0.0,\n    \t0.0, 0.0, 1.0);\n    \n    ro = roi;\n\trd = normalize(rdi*rotY);\n}\n\nmat3 GetCamera(in vec2 uv, in vec2 pixel, in float T, out vec3 outRO, out vec3 outRD)\n{\n    outRO = CAMPOS;\n    outRD = normalize(vec3(pixel, 1.0));\n    \n    #ifdef SET_CAMERA_TARGET_ROTATION\n    outRO.x = TARGETPOS.x+cos(Time*CAMROTSPEED)*CAMDIST;\n    outRO.z = TARGETPOS.z+sin(Time*CAMROTSPEED)*CAMDIST;\n    mat3 ca = setCamera(outRO, TARGETPOS, vec3(0.0, 1.0, 0.0));\n    outRD = ca*normalize(vec3(pixel.xy, 2.0));\n    #else\n    \t#ifdef USE_MARCH\n    \toutRO.x = T*2.0;\n    \toutRO.z = T*2.0;\n        mat3 ca = setCamera(outRO, outRO+vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 0.0));\n        outRD = ca*normalize(vec3(pixel.xy, 2.0));\n    \t\n    \t#else\n            mat3 ca = setCamera(outRO, outRO+vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 0.0));\n            outRD = ca*normalize(vec3(pixel.xy, 2.0));\n    \t#endif\n    #endif\n    #ifdef SET_CAMERA_DEFAULT_ROTATION\n        outRD = RotYV3(outRD, Time*CAMROTSPEED);\n    #endif\n    #ifdef SET_CAMERA_SUNDOWN\n        outRD = RotYV3(outRD, -0.6);\n    #endif\n    #ifdef SET_CAMERA_SUNRISE\n    \toutRD = RotYV3(outRD, 3.10);\n    #endif\n    return ca;\n}\n","name":"Common","description":"","type":"common"}]}