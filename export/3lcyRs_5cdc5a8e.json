{"ver":"0.1","info":{"id":"3lcyRs","date":"1609693317","viewed":150,"name":"Clouds from Above","username":"tomolt","description":"Attempting to mimic clouds seen on satellite images of earth.\nMy plan is to combine this with a simple sphere tracer and some procedural terrain color\nto produce some kind of earth-like planet.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["clouds"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Written by Thomas Oltmann, placed into the public domain.\n\n#define TAU 6.283185307179586476925286766559 // tau is two times pi\n#define RR2 0.707106781186547524400844362105 // reciprocal of square root of 2\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat evolve(float v) {\n    v = v*100.0+iTime*1.5;\n    v = sin(v/9.9)*sin(v/7.0);\n    v = v*0.5+0.5;\n    return v;\n}\n\nvec2 swirlgen(vec2 co) {\n    float r1 = rand(co);\n    float r2 = rand(co+vec2(12.0,21.0));\n    r1 = evolve(r1);\n    r2 = evolve(r2);\n    float angle = r1*TAU;\n    float len = r2;\n    return vec2(sin(angle),cos(angle))*len;\n}\n\nvec2 swirloct(vec2 co) {\n    vec2 i = floor(co);\n    vec2 f = co-i;\n    vec2 t = smoothstep(0.0,1.0,f);\n    vec2 ll = swirlgen(i+vec2(0.0,0.0));\n    vec2 lh = swirlgen(i+vec2(0.0,1.0));\n    vec2 hl = swirlgen(i+vec2(1.0,0.0));\n    vec2 hh = swirlgen(i+vec2(1.0,1.0));\n    return mix(\n        mix(ll, hl, t.x),\n        mix(lh, hh, t.x),\n        t.y);\n}\n\nvec2 swirl(vec2 co) {\n    vec2 val = vec2(0.0);\n    float freq = 1.0;\n    float ampl = 1.0;\n    for (int i = 0; i < 8; ++i) {\n        val += ampl*swirloct(co*freq);\n        freq *= 2.0;\n        ampl *= 0.5;\n    }\n    return val;\n}\n\nfloat noisegen(vec2 co) {\n    float val = rand(co);\n    //val = evolve(val);\n    return val;\n}\n\nvec3 noiseoct(vec2 co) {\n    vec2 i = floor(co);\n    vec2 f = co-i;\n    vec2 t = -2.0*f*f*f+3.0*f*f;\n    float ll = noisegen(i+vec2(0.0,0.0));\n    float lh = noisegen(i+vec2(0.0,1.0));\n    float hl = noisegen(i+vec2(1.0,0.0));\n    float hh = noisegen(i+vec2(1.0,1.0));\n    vec3 val;\n    val.z = mix(\n        mix(ll, hl, t.x),\n        mix(lh, hh, t.x),\n        t.y);\n    val.x = (mix(hl, hh, t.y) - mix(ll, lh, t.y)) * (-6.0*f.x*f.x+6.0*f.x);\n    val.y = (mix(lh, hh, t.x) - mix(ll, hl, t.x)) * (-6.0*f.y*f.y+6.0*f.y);\n    return val;\n}\n\nvec3 noise(vec2 co) {\n    vec3 val = vec3(0.0);\n    float freq = 1.0;\n    float ampl = 1.0;\n    for (int i = 0; i < 8; ++i) {\n        val += ampl*noiseoct(co*freq);\n        freq *= 1.995;\n        ampl *= 0.5;\n    }\n    return val;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv *= 7.0;\n    \n    uv += 0.3*swirl(uv);\n    \n    vec3 n = noise(uv+vec2(0.11,0.04)*iTime);\n    \n    vec3 norm = normalize(vec3(-n.xy, 0.3));\n    \n    vec3 light = normalize(vec3(1.0, 1.0, 2.0));\n    float diff = max(dot(norm,light),0.0);\n    \n    vec3 col;\n    col = mix(vec3(0.0,0.7,0.8), vec3(0.9,0.9,0.8), diff);\n    col = mix(vec3(0.05,0.15,0.2), col, max(n.z*1.5-1.6,0.0));\n    //col = vec3(n.x*0.5+0.5, n.y*0.5+0.5,n.z);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}