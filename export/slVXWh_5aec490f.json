{"ver":"0.1","info":{"id":"slVXWh","date":"1641754117","viewed":192,"name":"RIOW - First try!","username":"curvedcubes","description":"Simple ray tracer implemented based on Peter Shirley's \"Ray Tracing in One Weekend\" (https://raytracing.github.io). Functions in Common are from blackle (https://suricrasia.online/demoscene/functions/). ","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","weekend","riow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Important structs\nstruct Ray {\n    vec3 ro;\n    vec3 rd;\n};\n\nstruct Material {\n    int kind;\n    vec3 albedo;\n    float reflectance;\n    float param;\n};\n\nstruct Sphere {\n    vec3 m;\n    float r;\n    Material mat;\n};\n\n// sphere intersection test\nfloat hit_sphere(Ray r, Sphere s){\n    vec3 oc = r.ro - s.m;\n    float a = dot(r.rd, r.rd);\n    float b = dot(r.rd, oc);\n    float c = dot(oc, oc) - s.r*s.r;\n    float d = b*b-a*c;\n    \n    float t = (d > 0.0) ? -b-sqrt(abs(d)) / a : INFINITY;\n    //float t = (d > 0.0) ? -b-sqrt(max(d, 0.0)) / a : INFINITY;\n    return (t > 0.0) ? t : INFINITY;\n}\n\n// sphere normal, hit is hit point, m is sphere center\nvec3 sphere_normal(vec3 hit, Sphere s){\n    return normalize(hit-s.m);\n}\n\n// checks if ray is outside or inside a surface with normal vector n\nbool front_facing(Ray r, vec3 n){\n    return dot(r.rd, n) > 0.0;\n}\n\n// Schlick approximation\nfloat schlick(float cos_theta, float refr_ratio){\n    float r0 = (1.0-refr_ratio) / (1.0+refr_ratio);\n    r0 = r0 * r0;\n    return r0 + (1.0-r0)*pow(1.0-cos_theta, 5.0);\n}\n\n// redirects the ray depending on the material\nvec3 reflection(Ray r, vec3 n, Material hit){\n    if (hit.kind == LAMBERTIAN) {\n        return normalize(n + normalize(tan(random3(gl_FragCoord.x, gl_FragCoord.y+iTime))));\n    }\n    if (hit.kind == METAL) {\n        vec3 refl = reflect(r.rd, n);\n        return normalize(refl + hit.param*normalize(tan(random3(gl_FragCoord.x, gl_FragCoord.y+iTime))));\n    }\n    if (hit.kind == DIELECTRIC) {\n        float refr_ratio = front_facing(r, n) ? hit.param : (1.0/hit.param);\n        float cos_theta = min(dot(-r.rd, n), 1.0);\n        bool can_refract = (sqrt(1.0-cos_theta*cos_theta) >= 1.0) || \n                            schlick(cos_theta, refr_ratio) < \n                            0.5*random(gl_FragCoord.x, gl_FragCoord.y+iTime)+0.45;\n        vec3 dir = can_refract ? refract(r.rd, n, refr_ratio) : reflect(r.rd, n);\n        return dir;\n    }\n    if (hit.kind == DIEL_HOLLOW) {\n        float refr_ratio = front_facing(r, n) ? (1.0/hit.param) : hit.param;\n        float cos_theta = min(dot(-r.rd, n), 1.0);\n        bool can_refract = (sqrt(1.0-cos_theta*cos_theta) >= 1.0) || \n                            schlick(cos_theta, refr_ratio) < \n                            0.5*random(gl_FragCoord.x, gl_FragCoord.y+iTime)+0.45;\n        vec3 dir = can_refract ? refract(r.rd, n, refr_ratio) : reflect(r.rd, n);\n        return dir;\n    }\n    \n}\n\n// ray coloring\nvec3 ray_color(Ray r, Material hit, vec3 prev_color){\n    if (hit.kind == LAMBERTIAN || hit.kind == METAL){\n        float t = 0.5*(r.rd.y + 1.0);\n        return prev_color * hit.reflectance * \n               ((1.0-t) * normalize(hit.albedo) + t * hit.albedo);\n    }\n    if (hit.kind == DIELECTRIC){\n        return prev_color * hit.albedo;\n    }\n    if (hit.kind == DIEL_HOLLOW){\n        return prev_color;\n    }\n}\n\n\n\n\n// ========================== CLEAN STUFF FROM HERE ON =============================//\n\n\n\n\nconst Material[] materials = Material[5]( Material(METAL, vec3(1.0, 0.8, 0.4), 0.95, 0.55), \n                                          Material(LAMBERTIAN, vec3(0.4, 0.5, 1), 0.8, 0.0),\n                                          Material(LAMBERTIAN, vec3(1.4, 0.2, 0.5), 0.55, 0.0),\n                                          Material(DIELECTRIC, vec3(1.0), 1.0, 1.45),\n                                          Material(DIEL_HOLLOW, vec3(1.0), 1.0, 1.45)\n                                        );\n\nconst Sphere[] objects = Sphere[5]( Sphere(vec3(0), 2.0, materials[0]),\n                                    Sphere(vec3(3.0, -1., -1.5), 1.0, materials[1]),\n                                    Sphere(vec3(-1.7, -1.0, -3), 1.0, materials[3]),\n                                    Sphere(vec3(-1.7, -1.0, -3), 0.97, materials[4]),\n                                    Sphere(vec3(0, -1000, 0), 998.0, materials[2])\n                                  );\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // UV + AA\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy)/iResolution.y;\n    uv += 0.5*random2(uv.x, uv.y+iTime)/iResolution.y;\n    \n    // Ray setup\n    vec3 cam = normalize(vec3(uv, FOV));\n    Ray r = Ray(vec3(0, 0, -10), cam);\n    \n    // Ray tracing\n    vec3 col = SKY_COLOR;\n    bool hit = false;\n    int hit_count = 0;\n    for(int i=1; i<=BOUNCES; i++){\n    \n        float t = INFINITY; float t_prev; int hit_id = 0;\n        for(int n=0; n<objects.length(); n++){\n            t = min(t, hit_sphere(r, objects[n]));\n            hit_id = (t<t_prev) ? n : hit_id;\n            t_prev = t;\n        }\n        \n        hit = (t != INFINITY && !isnan(t));\n        if (!hit) break;\n        hit_count += 1;\n        \n        vec3 p = r.ro + t*r.rd + 0.0001*r.rd;\n        vec3 n = sphere_normal(p, objects[hit_id]);\n        \n        r.ro = p;\n        r.rd = reflection(r, n, objects[hit_id].mat);\n        \n        col = ray_color(r, objects[hit_id].mat, col);\n    }\n    col = (hit_count != 0) ? col : mix(SKY_COLOR, vec3(0.4, 0.6, 1.0), 5.0*r.rd.y-.5);\n    col = sqrt(col);\n               \n    // accumulating frames\n    vec3 prev = texture(iChannel0, fragCoord.xy/iResolution.xy).rgb;\n    fragColor.rgb = (float(iFrame)*prev + col) / float(iFrame + 1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926\n#define INFINITY 3.4e38\n\n#define FOV 1.4\n#define BOUNCES 20\n#define SKY_COLOR vec3(0.65, 0.75, 1.0)\n\n// Materials\n#define LAMBERTIAN  0\n#define METAL       1\n#define DIELECTRIC  2\n#define DIEL_HOLLOW 3\n\n\n// Random functions based on: https://suricrasia.online/demoscene/functions/\nfloat random(float a, float b){\n    int x = floatBitsToInt(cos(a))^floatBitsToInt(a);\n    int y = floatBitsToInt(cos(b))^floatBitsToInt(b);\n    return float((x-y*y)*(x*x+y)-x)/2147483648.0;\n}\n\nvec2 random2(float a, float b){\n    int x = floatBitsToInt(cos(a))^floatBitsToInt(a);\n    int y = floatBitsToInt(cos(b))^floatBitsToInt(b);\n    return vec2(float((x-y*y)*(x*x+y)-x), float(x*y^(x-y)))/2147483648.0;\n}\n\nvec3 random3(float a, float b){\n    int x = floatBitsToInt(cos(a))^floatBitsToInt(a);\n    int y = floatBitsToInt(cos(b))^floatBitsToInt(b);\n    int z = floatBitsToInt(cos(b))^floatBitsToInt(a);\n    return vec3(float((x-y*y)*(x*x+y)-x), float(x*y^(x-y)), float((z-y*y)*(z*z+y)-z))/2147483648.0;\n}\n\n// Rodrigues' rotation formula from: https://suricrasia.online/demoscene/functions/\nvec3 rot(vec3 p, vec3 ax, float an){\n    return mix(dot(ax, p)*ax, p, cos(an)) + cross(ax, p)*sin(an);\n}\n","name":"Common","description":"","type":"common"}]}