{"ver":"0.1","info":{"id":"sdXyWf","date":"1642789640","viewed":2938,"name":"Skinball","username":"tdhooper","description":"I've been working on a skin shader, and thought I'd test it on some polyhedral geometry I have lying around. [url=https://twitter.com/tdhooper/status/1484561188231032835]Animated render here[/url]\n","likes":53,"published":1,"flags":32,"usePreview":1,"tags":["sss","pathtrace","skin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec4 tex = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    vec3 col = tex.rgb / tex.a;\n\n    col = aces(col);\n    col = pow( col, vec3(1./2.2) );\n    \n    fragColor = vec4(col, 1);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//#define ANIMATE\n//#define DOF\n\n// Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n    p += 1.61803398875; // fix artifacts when reseeding\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Dave_Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// iq https://www.shadertoy.com/view/tl23Rm\nvec2 rndunit2(vec2 seed ) {\n    vec2 h = seed * vec2(1,6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r*vec2(sin(phi),cos(phi));\n}\n\n#define PI 3.14159265359\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat smin(float a, float b, float k){\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\n// iq https://www.shadertoy.com/view/Xds3zN\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdRoundCone(vec3 p, vec3 dir, float r1, float r2, float h) {\n    p = reflect(p, normalize(mix(vec3(0,1,0), -dir, .5)));\n    return sdRoundCone(p, r1, r2, h);\n}\n\n\n// Icosahedral domain mirroring\n// knighty https://www.shadertoy.com/view/MsKGzw\n\n#define PI 3.14159265359\n\nvec3 facePlane;\nvec3 uPlane;\nvec3 vPlane;\n\nint Type=5;\nvec3 nc;\nvec3 pab;\nvec3 pbc;\nvec3 pca;\n\nvoid init() {\n    float cospin=cos(PI/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n    nc=vec3(-0.5,-cospin,scospin);\n    pbc=vec3(scospin,0.,0.5);\n    pca=vec3(0.,scospin,cospin);\n    pbc=normalize(pbc); pca=normalize(pca);\n\tpab=vec3(0,0,1);\n    \n    facePlane = pca;\n    uPlane = cross(vec3(1,0,0), facePlane);\n    vPlane = vec3(1,0,0);\n}\n\nvec3 fold(vec3 p) {\n\tfor(int i=0;i<5 /*Type*/;i++){\n\t\tp.xy = abs(p.xy);\n\t\tp -= 2. * min(0., dot(p,nc)) * nc;\n\t}\n    return p;\n}\n\nvec3 sfold(vec3 p, float s) {\n\tfor(int i=0;i<5 /*Type*/;i++){\n        p.xy = sqrt(p.xy * p.xy + s);\n\t\tp -= 2. * min(0., dot(p,nc)) * nc;\n\t}\n    return p;\n}\n\n\n// Triangle tiling\n// mattz https://www.shadertoy.com/view/4d2GzV\n\nconst float sqrt3 = 1.7320508075688772;\nconst float i3 = 0.5773502691896258;\n\nconst mat2 cart2tri = mat2(1, 0, i3, 2. * i3);\nconst mat2 tri2cart = mat2(1, 0, -.5, .5 * sqrt3);\n\nvec2 pick3(vec2 a, vec2 b, vec2 c, float u) {\n\tfloat v = fract(u * 0.3333333333333);\n\treturn mix(mix(a, b, step(0.3, v)), c, step(0.6, v));\n}\n\nvec2 closestHex(vec2 p) {\n    p = cart2tri * p;\n\tvec2 pi = floor(p);\n\tvec2 pf = fract(p);\n\tvec2 nn = pick3(\n        vec2(0, 0),\n        vec2(1, 1),\n        vec2(1, 0),\n        pi.x + pi.y\n    );\n\tvec2 hex = mix(nn.xy, nn.yx, step(pf.x, pf.y)) + pi;\n    hex = tri2cart * hex;\n    return hex;\n}\n\n\n// Geodesic tiling\n// tdhooper https://www.shadertoy.com/view/llGXWc\n\nvec3 intersection(vec3 n, vec3 planeNormal, float planeOffset) {\n    float denominator = dot(planeNormal, n);\n    float t = (dot(vec3(0), planeNormal) + planeOffset) / -denominator;\n    return n * t;\n}\n\nvec2 icosahedronFaceCoordinates(vec3 p) {\n    vec3 i = intersection(normalize(p), facePlane, -1.);\n    return vec2(dot(i, uPlane), dot(i, vPlane));\n}\n\nvec3 faceToSphere(vec2 facePoint) {\n\treturn normalize(facePlane + (uPlane * facePoint.x) + (vPlane * facePoint.y));\n}\n\nconst float edgeLength = 1. / ((sqrt(3.) / 12.) * (3. + sqrt(5.)));\nconst float faceRadius = (1./6.) * sqrt(3.) * edgeLength;\n\nvec3 geodesicTri(vec3 p, float subdivisions) {\n\tfloat uvScale = subdivisions / faceRadius;\n    vec2 uv = icosahedronFaceCoordinates(p);\n    uvScale /= 1.3333;\n    vec2 closest = closestHex(uv * uvScale); \n    return faceToSphere(closest / uvScale);\n}\n\n\n\n//========================================================\n// Modeling\n//========================================================\n\n\nstruct Material {\n    vec3 albedo;\n    float specular;\n    float roughness;\n    bool sss;\n};\n\nstruct Model {\n    float d;\n    vec3 uvw;\n    vec3 albedo;\n    int id;\n};\n\nMaterial shadeModel(Model model, inout vec3 nor) {\n    vec3 skin = pow(vec3(0.890,0.769,0.710), vec3(2.2));\n\n    if (model.id == 1)\n        return Material(skin, .025, .3, true);\n\n    return Material(vec3(.02), .01, .2, false);\n}\n\nfloat sin3(vec3 x) {\n    return sin(x.x) * sin(x.y) * sin(x.z);\n}\n\nfloat ball(vec3 p, float hs, float rep, float radius) {\n\n    float o = sin3( (p + sin(p * 10. * .66)) * 100.) * .0001 * 2.;\n    o += sin3( (p + cos(p * 18. * .66)) * 132.) * .00005 * 2.;\n\n    float d = length(p) - (radius + .01 * hs);\n    \n    vec3 sp = sfold(p, .00005);\n    p = fold(p);\n    \n    vec3 spp = p;\n    \n    vec3 point = geodesicTri(p, rep);\n\n    p -= point * radius;\n    sp -= point * radius;\n    \n    float d2 = length(sp) - .02 * hs;\n\n    d = smin(d, d2, .05 * hs);\n    d = smax(d, -d2, .03 * hs);\n    \n    d2 += .01 * hs;\n    d2 = smin(d2, sdRoundCone(sp, normalize(point), .01 * hs, .000, .125 * hs * radius), .03 * hs);\n    \n    d = min(d, d2);\n    \n    d += o;\n    \n    return d;\n}\n\nconst float boundRadius = .3;\n\nModel map(vec3 p) {\n    int id = 1;\n    \n    vec2 rot = vec2(.0);\n    \n    if (iMouse.x > 0.) {\n        rot = (.5 - iMouse.yx / iResolution.yx + vec2(0,0)) * PI * vec2(1., 2.);\n    }\n    \n    rot.x = -.45;\n    rot.y = .85;\n    \n    pR(p.yz, rot.x);\n    pR(p.xz, rot.y);\n\n    float t = iTime * 3.;\n    \n    #ifndef ANIMATE\n    t = 1.25;\n    #endif\n    \n    float b = sin(dot(normalize(p), pbc) * 8. + t) * .5 + .5;\n    float b2 = sin(dot(normalize(p), pbc) * 4. + t) * .5 + .5;\n    \n    float s = 1.2 - .1 * b2;\n    p /= s;\n\n    float d = ball(p, 3.1, 1.5, .175);\n    float d2 = ball(p, 1.2, 2.5, .2);\n\n    d = mix(d, d2, b);\n\n    return Model(d * s, p, vec3(.5), id);\n}\n\n\n//========================================================\n// Rendering\n//========================================================\n\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float h = 0.0001;      // replace by an appropriate value\n    #define ZERO (min(iFrame,0)) // non-constant zero\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*h).d;\n    }\n    return normalize(n);\n}\n\n\nvec3 sunPos = normalize(vec3(-1,1,-.75)) * 100.;\nvec3 skyColor = vec3(0.50,0.70,1.00);\nvec3 sunColor = vec3(8.10,6.00,4.20) * 3.;\n\n\nvec3 env(vec3 dir, bool includeSun) {\n   vec3 col = mix(vec3(.5,.7,1) * .0, vec3(.5,.7,1) * 1., smoothstep(-.2, .2, dir.y));\n   return col * .5;\n}\n\nstruct Hit {\n    Model model;\n    vec3 pos;\n};\n\nHit march(vec3 origin, vec3 rayDirection, float maxDist, float understep) {\n\n    vec3 rayPosition;\n    float rayLength, dist = 0.;\n    Model model;\n\n    for (int i = 0; i < 200; i++) {\n        rayPosition = origin + rayDirection * rayLength;\n        model = map(rayPosition);\n        rayLength += model.d * understep;\n\n        if (model.d < .0002) break;\n\n        if (rayLength > maxDist || length(rayPosition) > (boundRadius + .001)) {\n            model.id = 0;\n            break;\n        }\n    }\n    return Hit(model, rayPosition);\n}\n\n\n// tracing/lighting setup from yx\n// https://www.shadertoy.com/view/ts2cWm\nvec3 ortho(vec3 a){\n    vec3 b=cross(vec3(-1,-1,.5),a);\n    // assume b is nonzero\n    return (b);\n}\n\n// re-borrowed from yx from\n// http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec3 getSampleBiased(vec3 dir, float power, vec2 seed) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = seed;\n\tr.x=r.x*2.*PI;\n\tr.y=pow(r.y,1.0/(power+1.0));\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\nvec3 getConeSample(vec3 dir, float extent, vec2 seed) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r =  seed;\n\tr.x=r.x*2.*PI;\n\tr.y=1.0-r.y*extent;\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\n// Walk on spheres subsurface scattering\n// inspired by blackle https://www.shadertoy.com/view/wsfBDB\nHit walkOnSpheres(vec3 origin, vec3 normal, float startdepth, inout vec2 seed) {\n    Model model;\n    \n    vec2 lastSeed = seed;\n    seed = hash22(seed);\n    normal = normalize(tan(vec3(seed.x, seed.y, lastSeed.x) * 2. - 1.));\n    \n    model = map(origin - normal * startdepth);\n    origin -= normal * abs(model.d);\n    \n    for (int v = 0; v < 250; v++) {\n        model = map(origin);\n\n        if (abs(model.d) < .00002) break;\n        \n        vec2 lastSeed = seed;\n        seed = hash22(seed);\n        vec3 dir = normalize(tan(vec3(seed.x, seed.y, lastSeed.x) * 2. - 1.));\n        \n        origin += dir * abs(model.d);\n    }\n    return Hit(model, origin);\n}\n\nvec3 sampleDirect(Hit hit, vec3 nor, vec3 throughput, inout vec2 seed) {\n    vec3 col = vec3(0);\n    vec3 lightDir = (sunPos - hit.pos);\n    vec3 lightSampleDir = getConeSample(lightDir, .0005, seed);\n    seed = hash22(seed);\n    float diffuse = dot(nor, lightSampleDir);\n    vec3 shadowOrigin = hit.pos + nor * (.0002 / abs(dot(lightSampleDir, nor)));\n    if (diffuse > 0.) {\n        Hit sh = march(shadowOrigin, lightSampleDir, 1., 1.);\n        if (sh.model.id == 0) {\n            col += throughput * sunColor/10. * diffuse;\n        }\n    }\n    return col;\n}\n\nfloat G1V(float dnv, float k){\n    return 1.0/(dnv*(1.0-k)+k);\n}\n\n// noby https://www.shadertoy.com/view/lllBDM\nfloat ggx(vec3 nor, vec3 rayDir, vec3 l, float rough, float f0){\n    float alpha = rough*rough;\n    vec3 h = normalize(-rayDir + l);\n    float dnl = clamp(dot(nor,l), 0.0, 1.0);\n    float dnv = clamp(dot(nor,rayDir), 0.0, 1.0);\n    float dnh = clamp(dot(nor,h), 0.0, 1.0);\n    float dlh = clamp(dot(l,h), 0.0, 1.0);\n    float f, d, vis;\n    float asqr = alpha*alpha;\n    const float pi = 3.14159;\n    float den = dnh*dnh*(asqr-1.0)+1.0;\n    d = asqr/(pi * den * den);\n    dlh = pow(1.0-dlh, 5.0);\n    f = f0 + (1.0-f0)*dlh;\n    float k = alpha/1.0;\n    vis = G1V(dnl, k)*G1V(dnv, k);\n    float spec = dnl * d * f * vis;\n    return spec;\n}\n\nvec3 sphereLight(vec3 lightPos, float radius, vec3 pos, vec3 rayDir, vec3 nor) {\n    vec3 L = (lightPos - pos);\n    vec3 ref = reflect(rayDir, nor);\n    vec3 centerToRay = dot(L, ref) * ref - L;\n    vec3 closestPoint = L + centerToRay * clamp(radius / length(centerToRay), 0., 1.);\n    return closestPoint;\n}\n\nvec3 sampleDirectSpec(Hit hit, vec3 rayDir, vec3 nor, float rough, inout vec2 seed) {\n    vec3 lpos = sphereLight(sunPos, 5., hit.pos, rayDir, nor);\n    \n    vec3 lightDir = normalize(lpos - hit.pos);\n    vec3 h = normalize(rayDir + lightDir);\n    float specular = pow(clamp(dot(h, nor), 0., 1.), 64.0);\n\n    vec3 col = vec3(0);\n\n    float fresnel = pow(max(0., 1. + dot(nor, rayDir)), 5.);\n    specular = ggx(nor, rayDir, lightDir, rough, fresnel);\n\n    vec3 shadowOrigin = hit.pos + nor * (.0002 / abs(dot(lightDir, nor)));\n    if (specular > 0.) {\n        Hit sh = march(shadowOrigin, lightDir, 1., 1.);\n        if (sh.model.id == 0) {\n            col += sunColor * 10. * specular;\n        }\n    }\n    return col;\n}\n\n// origin sphere intersection\n// returns entry and exit distances from ray origin\nvec2 iSphere( in vec3 ro, in vec3 rd, float r )\n{\n\tvec3 oc = ro;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - r*r;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n\th = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\n// main path tracing loop, based on yx's\n// https://www.shadertoy.com/view/ts2cWm\n// with a bit of demofox's\n// https://www.shadertoy.com/view/WsBBR3\nvec4 draw(vec2 fragCoord, int frame) {\n\n    vec2 p = (-iResolution.xy + 2.* fragCoord) / iResolution.y;\n    //p /= 2.;\n   \n    vec2 seed = hash22(fragCoord + (float(frame)) * sqrt3);\n    \n    // jitter for antialiasing\n    p += 2. * (seed - .5) / iResolution.xy;\n\n    vec3 col = vec3(0);\n\n    float focalLength = 6.;\n    vec3 camPos = vec3(0,0,.4) * focalLength * 1.;\n    vec3 camTar = vec3(0);\n    \n    vec3 ww = normalize(camTar - camPos);\n    vec3 uu = normalize(cross(vec3(0,1,0),ww));\n    vec3 vv = normalize(cross(ww,uu));\n    mat3 camMat = mat3(-uu, vv, ww);\n    \n    vec3 rayDir = normalize(camMat * vec3(p.xy, focalLength));\n    vec3 origin = camPos;\n\n    #ifdef DOF\n    float fpd = .37 * focalLength;\n    vec3 fp = origin + rayDir * fpd;\n    origin = origin + camMat * vec3(rndunit2(seed), 0.) * .05;\n    rayDir = normalize(fp - origin);\n    #endif\n\n    vec2 bound = iSphere(origin, rayDir, boundRadius);\n    if (bound.x < 0.) {\n    \treturn vec4(col, 1);\n    }\n\n    Hit hit;\n    vec3 nor, ref;\n    Material material;\n    vec3 throughput = vec3(1);\n    vec3 bgCol = skyColor;\n    bool doSpecular = true;\n\n    const int MAX_BOUNCE = 2;\n    \n    origin += rayDir * bound.x;\n\n    for (int bounce = 0; bounce < MAX_BOUNCE; bounce++) {\n   \n        hit = march(origin, rayDir, 1., 1.);\n   \n        if (hit.model.id == 0)\n        {\n            if (bounce > 0)\n                col += env(rayDir, doSpecular) * throughput;\n            break;\n        }\n\n        nor = calcNormal(hit.pos);\n        material = shadeModel(hit.model, nor);\n\n        // calculate whether we are going to do a diffuse or specular reflection ray \n        seed = hash22(seed);\n        doSpecular = hash12(seed) < material.specular;\n        \n        bool doSSS = material.sss && bounce < 1 && ! doSpecular;\n        if (doSSS) {\n            seed = hash22(seed);\n            doSSS = hash12(seed) < .9;\n        }\n        \n        if ( ! doSpecular) {\n            // update the colorMultiplier\n            throughput *= material.albedo;\n        }\n\n        if (doSSS) {\n            origin = hit.pos;\n            \n            seed = hash22(seed);\n            hit = walkOnSpheres(origin, nor, .075, seed);\n            nor = calcNormal(hit.pos);\n\n            float extinctionDist = distance(origin, hit.pos) * 10.;\n            vec3 extinctionCol = material.albedo;\n            extinctionCol = mix(mix(extinctionCol, vec3(0,0,1), .25), vec3(1,0,0), clamp(extinctionDist - 1., 0., 1.));\n            vec3 extinction = (1. - extinctionCol);\n            extinction = 1. / (1. + (extinction * extinctionDist));\t\n            extinction = clamp(extinction, vec3(0), vec3(1));\n            throughput *= extinction;\n        }\n\n        // Calculate diffuse ray direction\n        seed = hash22(seed);\n        vec3 diffuseRayDir = getSampleBiased(nor, 1., seed);\n\n        if ( ! doSpecular)\n        {\n            seed = hash22(seed);\n            col += sampleDirect(hit, nor, throughput, seed);\n            rayDir = diffuseRayDir;\n        }\n        else\n        {\n            if (bounce == 0) { // fix fireflies from diffuse-bounce specular\n                seed = hash22(seed);\n                col += sampleDirectSpec(hit, rayDir, nor, material.roughness, seed) * throughput;\n            }\n            \n            // Calculate specular ray direction\n            vec3 specularRayDir = reflect(rayDir, nor);\n            rayDir = normalize(mix(specularRayDir, diffuseRayDir, material.roughness * material.roughness));\n        }\n\n        // offset from sufrace https://www.shadertoy.com/view/lsXGzH\n        origin = hit.pos + nor * (.0002 / abs(dot(rayDir, nor)));\n    }\n\n    return vec4(col, 1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    init();\n\n    #ifdef ANIMATE\n        vec4 col = vec4(0.);\n        const int c = 3;\n        for (int i = 0; i < c; i++) {\n            col += draw(fragCoord, iFrame * c + i);\n        }\n        col /= float(c);\n    #else\n        vec4 col = draw(fragCoord, iFrame);\n        if (iFrame > 0 && iMouse.z <= 0.) {\n            vec4 lastCol = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n            col += lastCol;\n        }\n    #endif\n    \n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"}]}