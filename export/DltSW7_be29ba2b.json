{"ver":"0.1","info":{"id":"DltSW7","date":"1686263732","viewed":65,"name":"seashell","username":"yudemente","description":"seashell","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","distancefield","sdf","spiral","sphere","sphere","primitives","cut"],"hasliked":0,"parentid":"7lVXRt","parentname":"DeathStar - distance 3D"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.1415926535897932384626433832795\n\n/*\n * seashell\n *\n * this shader is an implementation of the Euclidean signed distance\n * to the \"seashell\"\n * (https://en.wikipedia.org/wiki/Seashell_surface)\n *\n * usually, it is difficult to deduce the distance function\n * from implicit and parametric representations\n *\n * for this reason, in this shader I tried to break the problem:\n * - define the seashell with a cone and a spiral\n * - find the closest point in the surface of the cone\n * - project this point a plane H\n * - find the closest point to the spiral in H\n * - project this point to the surface of the cone\n */\n\n/*\n * given a line defined by `a` and `b`\n * returns  0.0 if `p` in on the line\n * returns +1.0 if `p` is on the left side\n * returns -1.0 if `p` is on the right side\n */\nfloat side(vec2 a, vec2 b, vec2 p)\n{\n    float ar = (b.x - a.x) * (p.y - a.y) - (p.x - a.x) * (b.y - a.y);\n    return ar < 0.0\n      ? -1.\n      : ((ar > 0.0) ? +1. : 0.0);\n}\n\n/*\n * given a triangle defined by `a`, `b`, and `c`\n * returns -1.0 if `p` is inside the triangle\n * returns +1.0 if `p` is outside the triangle\n */\nfloat triangle_sign(vec2 a, vec2 b, vec2 c, vec2 p)\n{\n    float abp = side(a, b, p);\n    float bcp = side(b, c, p);\n    float cap = side(c, a, p);\n    return ((abp <= 0.0 && bcp <= 0.0 && cap <= 0.0)\n            || (abp >= 0.0 && bcp >= 0.0 && cap >= 0.0))\n      ? -1.\n      : +1.;\n}\n\nvec2 segment_closest_point(vec2 a, vec2 b, vec2 p)\n{\n    vec2 ba = b-a;\n    float t = clamp(dot(p-a, ba) / (dot(ba, ba)), 0.0, 1.0);\n    return a + (b-a)*t;\n}\n\nvec2 triangle_closest_point(vec2 a, vec2 b, vec2 c, vec2 p)\n{\n    vec2 ab = segment_closest_point(a, b, p);\n    vec2 bc = segment_closest_point(b, c, p);\n    vec2 ca = segment_closest_point(c, a, p);\n    \n    float dab = dot(ab - p, ab - p);\n    float dbc = dot(bc - p, bc - p);\n    float dca = dot(ca - p, ca - p);\n    \n    return (dab <= dbc && dab <= dca)\n        ? ab\n        : ((dbc <= dab && dbc <= dca) ? bc : ca);\n}\n\nvoid cone_closest_point_at_surface(\n    in float h, in float r, in vec3 p,\n    out float s, out vec3 pas)\n{\n    // 2d projection\n    vec2 w = vec2(length(p.xz), p.y);\n    vec2 ta = vec2(r,-h);\n    vec2 tb = vec2(0.0, 0.0);\n    vec2 tc = vec2(-r, -h);\n\n    // point at the triangle 2d\n    vec2 pas2d = triangle_closest_point(ta, tb, tc, w);\n\n    // retrieving the 3d base of the cone\n    vec3 o = vec3(0.0, 0.0, 0.0);\n    vec3 c = h*vec3(0.0, -1.0, 0.0);\n    vec3 n = cross(normalize(o-p), normalize(c-p));\n    vec3 j = normalize(o-c);\n    vec3 i = normalize(cross(j, n));\n\n    // constructing the point in surface for 3d\n    pas = pas2d.x * i + pas2d.y * j;\n    s = triangle_sign(ta, tb, tc, w);\n}\n\nvec2 pc_convert_to_polar(vec2 p)\n{\n    return vec2(sqrt(dot(p, p)), atan(p.y, p.x));\n}\n\nvec2 pc_convert_to_euclidean(vec2 p)\n{\n    return p.x * vec2(cos(p.y), sin(p.y));\n}\n\nvec2 pc_add(vec2 p, vec2 q)\n{\n    vec2 p_conv = pc_convert_to_euclidean(p);\n    vec2 q_conv = pc_convert_to_euclidean(q);\n    return pc_convert_to_polar(p_conv + q_conv);\n}\n\nfloat pc_euclidean_distance(vec2 p, vec2 q)\n{\n    return sqrt(p.x*p.x + q.x*q.x - 2.*p.x*q.x*cos(p.y-q.y));\n}\n\nfloat pc_sdf_circle(vec2 c, float r,  vec2 p)\n{ \n    return sqrt(p.x*p.x - 2.*p.x*c.x*cos(p.y - c.y) + c.y*c.y) - r;\n}\n\nfloat pc_sdf_spiral_compute_turn(float a, float b, vec2 p)\n{\n    return ceil((p.x - a - p.y*b)/(2.*b*M_PI));\n}\n\nvoid pc_thin_spiral_closest_points(\n    float a, float b, vec2 p,\n    out vec2 c0,\n    out vec2 c1)\n{\n    float r = p.x;\n    float turn = pc_sdf_spiral_compute_turn(a, b, p);\n\n    float angle_before = turn * 2. * M_PI + p.y;\n    c0 = vec2(a+b*angle_before, angle_before);\n    float angle_after = (turn-1.0) * 2. * M_PI + p.y;\n    c1 = vec2(a+b*angle_after, angle_after);\n}\n\nvoid thin_spiral_closest_points(\n    float a,\n    float b,\n    vec2 p,\n    out vec2 c0,\n    out vec2 c1)\n{\n    vec2 pc0, pc1;\n    pc_thin_spiral_closest_points(a, b, pc_convert_to_polar(p), pc0, pc1);\n    c0 = pc_convert_to_euclidean(pc0);\n    c1 = pc_convert_to_euclidean(pc1);\n}\n\nfloat pc_sdf_thin_spiral(float a, float b, vec2 p)\n{\n    float r = p.x;\n    float turn = pc_sdf_spiral_compute_turn(a, b, p);\n\n    float angle_before = turn * 2. * M_PI + p.y;\n    vec2 qb = vec2(a+b*angle_before, angle_before);\n    float angle_after = (turn-1.0) * 2. * M_PI + p.y;\n    vec2 qa = vec2(a+b*angle_after, angle_after);\n    return min(\n            pc_euclidean_distance(p, qb),\n            pc_euclidean_distance(p, qa));\n}\n\nfloat pc_sdf_spiral(float a, float b, vec2 p, float thick)\n{\n    return pc_sdf_thin_spiral(a, b, p) - thick;\n}\n\n/*\n * given a definition of an Archimedean spiral defined by `a` and `b`\n * and a cone defined by `h` and `r`\n * this function will compute the closest point in the surface of the cone\n * to the point `p` and output it in `ssp` and the distance in `dist`\n */\nvoid seashell_closest_point(\n    in float a, in float b, in float h, in float r, in vec3 p,\n    out float dist, out vec3 ssp)\n{\n    float cone_sign;\n    vec3 cone_pas;\n    cone_closest_point_at_surface(h, r, p, cone_sign, cone_pas);\n\n    vec2 ts0, ts1;\n    thin_spiral_closest_points(a, b, cone_pas.xz, ts0, ts1);\n\n    vec3 c = h*vec3(0.0, -1.0, 0.0);\n    vec3 q0 = vec3(ts0.x, c.y + h * (1. - length(ts0)/r), ts0.y);\n    vec3 q1 = vec3(ts1.x, c.y + h * (1. - length(ts1)/r), ts1.y);\n\n    float d0 = length(q0 - p);\n    float d1 = length(q1 - p);\n    \n    if(d0 < d1) {\n        dist = d0;\n        ssp = q0;\n    }else{\n        dist = d1;\n        ssp = q1;\n    }\n}\n\nfloat sdf_seashell(\n    in float a,\n    in float b,\n    in float h,\n    in float r,\n    in float min_thick,\n    in float max_thick,\n    in vec3 p)\n{\n    float dist;\n    vec3 ssp;\n    seashell_closest_point(a, b, h, r, p, dist, ssp);\n    float thick = min_thick\n      + (-clamp(ssp.y, -h, 0.0)/h)\n      * (max_thick-min_thick);\n    return dist - thick;\n}\n\nfloat map( in vec3 pos )\n{\n    // spiral arguments\n    float a = 0.0;\n    float b = 1./(7.*M_PI);\n    \n    // cone arguments\n    float h = 2.;\n    float r = 1.;\n    float min_thick = 0.0;\n    float max_thick = .2;\n    return sdf_seashell(a, b, h, r, min_thick, max_thick, pos);\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n\tfloat res = 1.0;\n    float t = tmin;\n    for( int i=0; i<64; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.003, 0.10 );\n        if( res<0.002 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n            e.yyx*map( pos + e.yyx*eps ) + \n            e.yxy*map( pos + e.yxy*eps ) + \n            e.xxx*map( pos + e.xxx*eps ) );\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 3\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera movement\n    float an_x = (sin(iTime/10.)+1.0)/2.;\n    float an_y = -(sin(iTime/10.)+1.0)*3.*M_PI;\n    \n    mat3 rotx = mat3(\n        1.0, 0.0,       0.0,\n        0.0, cos(an_x), -sin(an_x),\n        0.0, sin(an_x), cos(an_x));\n    mat3 roty = mat3(\n        cos(an_y), 0.0, -sin(an_y),\n        0.0,       1.0, 0.0,\n        sin(an_y), 0.0, cos(an_y));\n\n    vec3 po = vec3( 0.0, 0.0, (sin(iTime)+1.0)/2. + 1.0);\n    vec3 ro = roty*rotx*po;\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n\n    vec3 tot = vec3(0.0);\n\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif \n\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.*ww );\n\n        // raymarch\n        const float tmax = 100.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h/2.5;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            vec3 lig = vec3(0.57703);\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            if( dif>0.001 ) dif *= calcSoftshadow( pos+nor*0.001, lig, 0.001, 1.0, 32.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n        tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}