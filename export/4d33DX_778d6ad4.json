{"ver":"0.1","info":{"id":"4d33DX","date":"1452375756","viewed":305,"name":"Immersive Wordtoy","username":"germangb","description":"Original from @poljere ---> https://www.shadertoy.com/view/Xst3zX\n\nCLICK&DRAG to look around\nWASD/ARROWS to move (while CLICK&DRAGging)","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["3d","keyboard","word","characters","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FAR 8.0\n#define NEAR 0.00001\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nmat3 rotY (float t) {\n \treturn mat3(vec3(cos(t), 0.0, sin(t)),\n                vec3(0.0, 1.0, 0.0),\n                vec3(-sin(t), 0.0, cos(t)));   \n}\n\nfloat scene (vec3 p) {\n   // return length(p) - 1.0;\n    vec3 box = vec3(1.25, 1.0, 0.5);\n    float s = 0.0;\n    vec3 boxS = vec3(1.0 - s, 0.75 - s, 2.0);\n    float sc = opS(udRoundBox(p-vec3(0.0, 0.0, -2.35), boxS, 0.05), udRoundBox(p, box, 0.05));\n    sc = min(sc, udRoundBox(rotY(-0.2) * p - vec3(2.25, -0.5, 0.0), vec3(0.5, 1.0, 1.0), 0.05));\n    sc = min(sc, udRoundBox(rotY(0.2) * p - vec3(0.0, -1.5, -1.75), vec3(1.25, 0.025, 0.5), 0.025));\n    sc = min(sc, udRoundBox(p - vec3(0.0,0.0,0.5), box - vec3(0.25, 0.25, 0.0), 0.05));\n    return min(min(sc, udRoundBox(p - vec3(0.0, -1.5, 0.0), vec3(0.5, 0.05, 0.5), 0.05)), udRoundBox(p - vec3(0.0, -0.5, 0.0), vec3(0.2, 1.0, 0.2), 0.05));\n}\n\nvec3 grad (vec3 p) {\n \tvec2 eps = vec2(0.0001, 0.0);\n    return vec3(\n    \tscene(p - eps.xyy) - scene(p + eps.xyy),\n        scene(p - eps.yxy) - scene(p + eps.yxy),\n        scene(p - eps.yyx) - scene(p + eps.yyx)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(uv*0.21, 0.0);\n    vec3 rd = normalize(vec3(uv * 0.5, 1.0));\n    \n    vec3 pos = vec3(0,0.5,0)+vec3(texture(iChannel0, vec2(0.0)).g, 0.0, texture(iChannel0, vec2(0.0)).r);\n    float yaw = texture(iChannel0, vec2(0.0)).b;\n    float pitch = texture(iChannel0, vec2(0.0)).a;\n    \n    float siny = sin(yaw);\n    float cosy = cos(yaw);\n    float sinp = sin(pitch);\n    float cosp = cos(pitch);\n    \n    vec3 up = vec3(-siny*sinp, cosp, -cosy*sinp);\n    vec3 front = normalize(vec3(siny*cosp, sinp, cosy*cosp));\n    vec3 left = cross(up, front);\n    mat3 trans = mat3(left, up, front);\n    \n    ro = pos + trans * ro;\n    rd = trans * rd;\n    \n    float h = 0.0;\n    vec3 color = vec3(mix(.5, 0.025, fragCoord.y/iResolution.y));\n    int count = 0;\n    for (int i = 0; i < 64; ++i) {\n        count++;\n\t\tvec3 p = ro + h*rd;\n        float test = scene(p);\n        h += test;\n        if (h < NEAR || h > FAR) break;\n        if (test < 0.001) {\n            vec3 normal = normalize(grad(p));\n            float diff = clamp(dot(normal, vec3(1.0, -2.0, 1.0)), 0.0, 1.0);\n            color = vec3(0.85 * smoothstep(-2.0, 3.0, p.y)) * mix(0.5, 1.0, diff);\n            color += texture(iChannel3, normal).rgb * 0.125;\n            \n            if (p.z < 0.1) {\n                float scale = smoothstep(1.0, 1.5, iTime);\n                float s = 1.0;\n            \tfloat ed = smoothstep(0.975*scale, 1.0*scale, max(abs(p.y/0.75), abs(p.x)));\n            \tfloat ed2 = smoothstep(s, s+0.05, max(abs(p.y/0.75), abs(p.x)));\n            \tvec2 uv = (p.xy + vec2(1.0, 0.75)*scale) / vec2(2.0, 0.75*2.*scale);\n            \tcolor = mix(vec3(0.05), color, ed2);\n            \tcolor = mix(texture(iChannel1, uv).rgb * mix(1.0, 1.125, sin(iTime * 64.0)*0.5+0.5), color, ed);\n                h = mix(-1.0, h, smoothstep(0.975, 1.0, ed));\n            }\n            break;\n        }\n    }\n    \n    if (h > 0.0) {\n        float a = smoothstep(0.05, 1.0, float(count)/64.0);\n        color += color * 4.0 * a;\n    }\n    \n    fragColor = vec4(sqrt(color) + texture(iChannel2, uv).rgb * 0.025, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by Pol Jeremias - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n/////////////////////////////////////////////////////////////\n// INPUT AND MEMORY CODE \n//\n// This pass reads the keyboard and stores every key in a \n// texture that later on is use to recreate the text\n/////////////////////////////////////////////////////////////\n\n// Keyboard constants definition\nconst float KEY_BSP   = 8.5/256.0;\nconst float KEY_SP    = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\nconst float KEY_A     = 65.5/256.0;\nconst float KEY_B     = 66.5/256.0;\nconst float KEY_C     = 67.5/256.0;\nconst float KEY_D     = 68.5/256.0;\nconst float KEY_E     = 69.5/256.0;\nconst float KEY_F     = 70.5/256.0;\nconst float KEY_G     = 71.5/256.0;\nconst float KEY_H     = 72.5/256.0;\nconst float KEY_I     = 73.5/256.0;\nconst float KEY_J     = 74.5/256.0;\nconst float KEY_K     = 75.5/256.0;\nconst float KEY_L     = 76.5/256.0;\nconst float KEY_M     = 77.5/256.0;\nconst float KEY_N     = 78.5/256.0;\nconst float KEY_O     = 79.5/256.0;\nconst float KEY_P     = 80.5/256.0;\nconst float KEY_Q     = 81.5/256.0;\nconst float KEY_R     = 82.5/256.0;\nconst float KEY_S     = 83.5/256.0;\nconst float KEY_T     = 84.5/256.0;\nconst float KEY_U     = 85.5/256.0;\nconst float KEY_V     = 86.5/256.0;\nconst float KEY_W     = 87.5/256.0;\nconst float KEY_X     = 88.5/256.0;\nconst float KEY_Y     = 89.5/256.0;\nconst float KEY_Z     = 90.5/256.0;\nconst float KEY_COMMA = 188.5/256.0;\nconst float KEY_PER   = 190.5/256.0;\n\n//Automatically generated from a sprite sheet.\nfloat ch_sp = 0.0;\nfloat ch_a = 712557.0;\nfloat ch_b = 1760622.0;\nfloat ch_c = 706858.0;\nfloat ch_d = 1760110.0;\nfloat ch_e = 2018607.0;\nfloat ch_f = 2018596.0;\nfloat ch_g = 706922.0;\nfloat ch_h = 1498989.0;\nfloat ch_i = 1909911.0;\nfloat ch_j = 1872746.0;\nfloat ch_k = 1498477.0;\nfloat ch_l = 1198375.0;\nfloat ch_m = 1571693.0;\nfloat ch_n = 1760109.0;\nfloat ch_o = 711530.0;\nfloat ch_p = 711972.0;\nfloat ch_q = 711675.0;\nfloat ch_r = 1760621.0;\nfloat ch_s = 2018927.0;\nfloat ch_t = 1909906.0;\nfloat ch_u = 1497963.0;\nfloat ch_v = 1497938.0;\nfloat ch_w = 1498109.0;\nfloat ch_x = 1496429.0;\nfloat ch_y = 1496210.0;\nfloat ch_z = 2004271.0;\nfloat ch_1 = 730263.0;\nfloat ch_2 = 693543.0;\nfloat ch_3 = 693354.0;\nfloat ch_4 = 1496649.0;\nfloat ch_5 = 1985614.0;\nfloat ch_6 = 707946.0;\nfloat ch_7 = 1873042.0;\nfloat ch_8 = 709994.0;\nfloat ch_9 = 710250.0;\nfloat ch_0 = 711530.0;\nfloat ch_per = 2.0;\nfloat ch_que = 693378.0;\nfloat ch_exc = 599170.0;\nfloat ch_com = 10.0;\nfloat ch_scl = 65556.0;\nfloat ch_col = 65552.0;\nfloat ch_usc = 7.0;\nfloat ch_crs = 11904.0;\nfloat ch_dsh = 3584.0;\nfloat ch_ast = 21824.0;\nfloat ch_fsl = 304292.0;\nfloat ch_bsl = 1189001.0;\nfloat ch_lpr = 346385.0;\nfloat ch_rpr = 1118804.0;\nfloat ch_lba = 862355.0;\nfloat ch_rpa = 1647254.0;\n\n\n/////////////////////////////////\n// Memory Locations\n/////////////////////////////////\nvec2 fragCoordNumChars = vec2(0.0, 0.0);\n\n\n/////////////////////////////////\n// Memory Management\n/////////////////////////////////\nvec4 load(in vec2 fragCoordRead)\n{\n    return texture(iChannel0, (0.5 + fragCoordRead) / iChannelResolution[0].xy, -100.0 );\n}\n\nfloat isInside( vec2 p, vec2 c ) \n{ \n    vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); \n}\n\nvoid store( in vec2 fragCoordWrite, in vec4 value, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = (isInside(fragCoord, fragCoordWrite) > 0.0) ? value : fragColor;\n}\n\nfloat isKeyPressed(float key)\n{\n    if (iMouse.z > 0.5) return 0.0;\n\treturn texture( iChannel1, vec2(key, 0.5) ).x;\n}\n\n/////////////////////////////////\n// Store information\n/////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Read the last mode selected\n    int numChars = int( load(fragCoordNumChars).w );\n    vec4  history= load( fragCoord.xy-0.5 );\n    float char   = history.x + history.a;\n    \n    // Initialize variables\n    if (iFrame == 0)\n    {\n        history = vec4(0.0);\n        numChars = 0;\n        char = 0.0;\n    }\n    \n    // Check if the user has changed selection (Thanks Inigo)\n    float ochar = char;\n    char = mix( char, ch_q, step(0.5,isKeyPressed(KEY_Q)) );\n    char = mix( char, ch_w, step(0.5,isKeyPressed(KEY_W)) );\n    char = mix( char, ch_e, step(0.5,isKeyPressed(KEY_E)) );\n    char = mix( char, ch_r, step(0.5,isKeyPressed(KEY_R)) );\n    char = mix( char, ch_t, step(0.5,isKeyPressed(KEY_T)) );\n    char = mix( char, ch_y, step(0.5,isKeyPressed(KEY_Y)) );\n    char = mix( char, ch_u, step(0.5,isKeyPressed(KEY_U)) );\n    char = mix( char, ch_i, step(0.5,isKeyPressed(KEY_I)) );\n    char = mix( char, ch_o, step(0.5,isKeyPressed(KEY_O)) );\n    char = mix( char, ch_p, step(0.5,isKeyPressed(KEY_P)) );\n\n    char = mix( char, ch_a, step(0.5,isKeyPressed(KEY_A)) );\n    char = mix( char, ch_s, step(0.5,isKeyPressed(KEY_S)) );\n    char = mix( char, ch_d, step(0.5,isKeyPressed(KEY_D)) );\n    char = mix( char, ch_f, step(0.5,isKeyPressed(KEY_F)) );\n    char = mix( char, ch_g, step(0.5,isKeyPressed(KEY_G)) );\n    char = mix( char, ch_h, step(0.5,isKeyPressed(KEY_H)) );\n    char = mix( char, ch_j, step(0.5,isKeyPressed(KEY_J)) );\n    char = mix( char, ch_k, step(0.5,isKeyPressed(KEY_K)) );\n    char = mix( char, ch_l, step(0.5,isKeyPressed(KEY_L)) );\n\n    char = mix( char, ch_z, step(0.5,isKeyPressed(KEY_Z)) );\n    char = mix( char, ch_x, step(0.5,isKeyPressed(KEY_X)) );\n    char = mix( char, ch_c, step(0.5,isKeyPressed(KEY_C)) );\n    char = mix( char, ch_v, step(0.5,isKeyPressed(KEY_V)) );\n    char = mix( char, ch_b, step(0.5,isKeyPressed(KEY_B)) );\n    char = mix( char, ch_n, step(0.5,isKeyPressed(KEY_N)) );\n    char = mix( char, ch_m, step(0.5,isKeyPressed(KEY_M)) );\n\tchar = mix( char, ch_com, step(0.5,isKeyPressed(KEY_COMMA)) );\n    char = mix( char, ch_per, step(0.5,isKeyPressed(KEY_PER)) );\n    \n    char = mix( char, ch_sp, step(0.5,isKeyPressed(KEY_SP)) );\n    if( abs(ochar-char)>0.01 ) numChars++;\n    \n    // Store new data\n    float numCharsf = float(numChars);\n    vec2 fragCoordChar = vec2(  mod(numCharsf, iChannelResolution[0].x), \n                              floor(numCharsf / iChannelResolution[0].x));\n    \n    if(isKeyPressed(KEY_BSP)> 0.0){ char = 0.0; numCharsf = numCharsf - 1.0; } \n    \n    fragColor = history;          \n    store( fragCoordNumChars, vec4(0.0,0.0,0.0,numCharsf), fragColor, fragCoord );\n    store( fragCoordChar,     vec4(char,0.0,0.0,0.0),      fragColor, fragCoord );\n}\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Created by Pol Jeremias - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n/////////////////////////////////////////////////////////////\n// UI CODE \n//\n// This pass reads the data stored by the first buffer\n// and writes the characters that are required.\n//\n// SPECIAL THANKS to Flyguy for the font rendering\n//     (https://www.shadertoy.com/view/XtsGRl)\n/////////////////////////////////////////////////////////////\n\n\n/////////////////////////////////\n// Chars rendering\n/////////////////////////////////\n#define CHAR_SIZE vec2(3, 7)\n#define CHAR_SPACING vec2(16, 24)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\n/*\nTop left pixel is the most significant bit.\nBottom right pixel is the least significant bit.\n\n â–ˆ     010    \nâ–ˆ â–ˆ    101    \nâ–ˆ â–ˆ    101    \nâ–ˆâ–ˆâ–ˆ -> 111 -> 010 101 101 111 101 101 101 -> 712557\nâ–ˆ â–ˆ    101    \nâ–ˆ â–ˆ    101    \nâ–ˆ â–ˆ    101    \n*/\n\n//Automatically generated from a sprite sheet.\nfloat ch_sp = 0.0;\nfloat ch_a = 712557.0;\nfloat ch_b = 1760622.0;\nfloat ch_c = 706858.0;\nfloat ch_d = 1760110.0;\nfloat ch_e = 2018607.0;\nfloat ch_f = 2018596.0;\nfloat ch_g = 706922.0;\nfloat ch_h = 1498989.0;\nfloat ch_i = 1909911.0;\nfloat ch_j = 1872746.0;\nfloat ch_k = 1498477.0;\nfloat ch_l = 1198375.0;\nfloat ch_m = 1571693.0;\nfloat ch_n = 1760109.0;\nfloat ch_o = 711530.0;\nfloat ch_p = 711972.0;\nfloat ch_q = 711675.0;\nfloat ch_r = 1760621.0;\nfloat ch_s = 2018927.0;\nfloat ch_t = 1909906.0;\nfloat ch_u = 1497963.0;\nfloat ch_v = 1497938.0;\nfloat ch_w = 1498109.0;\nfloat ch_x = 1496429.0;\nfloat ch_y = 1496210.0;\nfloat ch_z = 2004271.0;\nfloat ch_1 = 730263.0;\nfloat ch_2 = 693543.0;\nfloat ch_3 = 693354.0;\nfloat ch_4 = 1496649.0;\nfloat ch_5 = 1985614.0;\nfloat ch_6 = 707946.0;\nfloat ch_7 = 1873042.0;\nfloat ch_8 = 709994.0;\nfloat ch_9 = 710250.0;\nfloat ch_0 = 711530.0;\nfloat ch_per = 2.0;\nfloat ch_que = 693378.0;\nfloat ch_exc = 599170.0;\nfloat ch_com = 10.0;\nfloat ch_scl = 65556.0;\nfloat ch_col = 65552.0;\nfloat ch_usc = 7.0;\nfloat ch_crs = 11904.0;\nfloat ch_dsh = 3584.0;\nfloat ch_ast = 21824.0;\nfloat ch_fsl = 304292.0;\nfloat ch_bsl = 1189001.0;\nfloat ch_lpr = 346385.0;\nfloat ch_rpr = 1118804.0;\nfloat ch_lba = 862355.0;\nfloat ch_rpa = 1647254.0;\n\n// Extracts bit b from the given number.\nfloat extract_bit(float n, float b)\n{\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n// Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(float spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0)));\n    bounds = bounds && all(lessThan(uv,size));\n    \n    return bounds ? extract_bit(spr, bit) : 0.0;\n}\n\n// Prints a character.\nfloat char(float ch, vec2 uv, inout vec2 cursor)\n{\n    float c = sprite(ch, CHAR_SIZE, 0.5 * (uv - cursor));\n    cursor += vec2(CHAR_SPACING.x, 0.0);\n    return c;\n}\n\nvec3 ui(in vec2 fragCoord, inout vec2 cursor)\n{\n\t// Draw UI\n    return vec3(char(ch_w, fragCoord, cursor) + char(ch_o, fragCoord, cursor) +\n           char(ch_r, fragCoord, cursor) + char(ch_d, fragCoord, cursor) +\n           char(ch_t, fragCoord, cursor) + char(ch_o, fragCoord, cursor)+\n           char(ch_y, fragCoord, cursor) + char(ch_sp, fragCoord, cursor)+\n           char(ch_v, fragCoord, cursor) + char(ch_1, fragCoord, cursor));\n}\n\n\n/////////////////////////////////\n// Memory Management\n/////////////////////////////////\nvec4 load(in vec2 fragCoordRead)\n{\n    return texture(iChannel0, (0.5 + fragCoordRead) / iChannelResolution[0].xy, -100.0 );\n}\n\n\n/////////////////////////////////\n// Utils\n/////////////////////////////////\nfloat hash1( float n ) \n{ \n    return fract(sin(n)*138.5453123); \n}\n\n\n/////////////////////////////////\n// Draw letters!\n/////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Read the character from the image buffer\n    vec2 bucket = floor(vec2(fragCoord.x / CHAR_SPACING.x,\n                             ((iResolution.y - fragCoord.y) / CHAR_SPACING.y)));\n    \n    float numCharsRow = floor(iResolution.x / CHAR_SPACING.x);\n    \n    float texelIdBuffA = bucket.y * numCharsRow + bucket.x;\n    \n    vec2  fragCoordBuffA= vec2(  mod(texelIdBuffA, iChannelResolution[0].x),\n    \t\t\t\t\t\t\t floor(texelIdBuffA / iChannelResolution[0].x));\n    \n    vec4 charId = load( fragCoordBuffA );\n    \n    \n    // Draw the chars\n    vec4 c = vec4(0.0); \n    vec2 cursor = floor(vec2(fragCoord.x / CHAR_SPACING.x, fragCoord.y / CHAR_SPACING.y)) * CHAR_SPACING;\n    c += vec4(0.1, 1.0, 0.1, 0.0) * char(charId.x, fragCoord, cursor);\n    \n    \n    // Draw the selection - Read the number of chars and calculate the last char\n    float lastChar = 1.0 + load(vec2(0.0)).w;\n    c.xyz += (1.0 - step(0.5, abs(lastChar - texelIdBuffA))) * vec3(0.1, 1.0, 0.1) *\n             (0.5 + 0.5 *sin(iTime * 15.0));\n\n    \n    // Draw the UI\n    cursor = 0.5 * vec2(iResolution.x - STRWIDTH(20.0), STRHEIGHT(1.0));\n    c.xyz += vec3(0.2, 0.1, 0.1) * ui(floor(fragCoord/2.0), cursor);\n    \n    \n    // Draw the background color\n    c.xyz += vec3(0.15,0.15,0.15);\n        \n    //c += vec4(hash1(charId.x));\n    \n    fragColor = c;\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Created by Pol Jeremias - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n/////////////////////////////////////////////////////////////\n// POST PROCESS\n//\n// This pass adds post processing effects on top of the rest.\n/////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iChannelResolution[0].xy;\n    vec3 col = vec3(0.01, 0.05,0.01) + 0.025*sin(iTime * 2.0 + fragCoord.y * 0.75);\n\n    float amount = 0.002 * length(uv - vec2(0.5,0.5));\n    col.r += texture( iChannel0, vec2(uv.x+amount,uv.y) ).r;\n    col.g += texture( iChannel0, uv ).g;\n    col.b += texture( iChannel0, vec2(uv.x-amount,uv.y) ).b;\n    vec3 ghost = texture(iChannel1, uv).rgb;\n    fragColor = vec4(col, 1.0);\n}","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"const float KEY_W     = 87.5/256.0;\nconst float KEY_A     = 65.5/256.0;\nconst float KEY_S     = 83.5/256.0;\nconst float KEY_D     = 68.5/256.0;\n\nconst float KEY_SP    = 32.5/256.0;\n\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\nfloat isKeyPressed(float key)\n{\n\treturn texture( iChannel0, vec2(key, 0.0) ).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    if (iFrame == 0) {\n        fragColor = vec4(-4.0, 0.0, 0.0, 0.0);\n    } else {\n        // defaults\n        fragColor = texture(iChannel1, fragCoord / iResolution.xy);\n\n        if (fragCoord.x/iResolution.x < 0.25) {\n    \t\t\n            // position\n            fragColor.b = 6.28*(iMouse.x / iResolution.x * 2.0 - 1.0);\n            fragColor.a = 3.14*(iMouse.y / iResolution.y * 2.0 - 1.0);\n            float yaw = fragColor.b;\n            float v = 0.05;\n            if (iMouse.z > 0.5) {\n            if (isKeyPressed(KEY_W) > 0.0 || isKeyPressed(KEY_UP) > 0.0) {\n                fragColor.r += cos(yaw) * v;\n                fragColor.g += sin(yaw) * v;\n            } else if (isKeyPressed(KEY_S) > 0.0 || isKeyPressed(KEY_DOWN) > 0.0) {\n                fragColor.r -= cos(yaw) * v;\n                fragColor.g -= sin(yaw) * v;\n            }\n            \n            if (isKeyPressed(KEY_A) > 0.0 || isKeyPressed(KEY_LEFT) > 0.0) {\n                fragColor.r += sin(yaw) * v;\n                fragColor.g -= cos(yaw) * v;\n            } else if (isKeyPressed(KEY_D) > 0.0 || isKeyPressed(KEY_RIGHT) > 0.0) {\n                fragColor.r -= sin(yaw) * v;\n                fragColor.g += cos(yaw) * v;\n            }\n            }\n        }\n    }\n    \n}","name":"Buf D","description":"","type":"buffer"}]}