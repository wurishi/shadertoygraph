{"ver":"0.1","info":{"id":"3llGW2","date":"1557773246","viewed":149,"name":"Permutation 042 Imitation","username":"nr4","description":"Inspiration:\nhttps://scontent-frt3-1.xx.fbcdn.net/v/t1.0-9/59933637_2319374184987503_4222565795340746752_n.jpg?_nc_cat=107&_nc_ht=scontent-frt3-1.xx&oh=bf43655462c85224f3046852ed730b23&oe=5D6660F8","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["graph","extrusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Permutation 042 Imitation\n * Copyright (C) 2019  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nconst float fsaa = 25.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.);\n    float bound = sqrt(fsaa)-1.;\n   \tfor(float i = -.5*bound; i<=.5*bound; i+=1.)\n        for(float j=-.5*bound; j<=.5*bound; j+=1.)\n        {\n     \t\tcol += texture(iChannel0, fragCoord/iResolution.xy+vec2(i,j)*3./max(bound, 1.)/iResolution.xy).xyz;\n        }\n    col /= fsaa;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* Permutation 042 Imitation\n * Copyright (C) 2019  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n// Global constants\nconst float pi = acos(-1.);\nconst vec3 c = vec3(1.0, 0.0, -1.0);\nfloat a = 1.0;\n\n// Hash function\nvoid rand(in vec2 x, out float num)\n{\n    x += 400.;\n    num = fract(sin(dot(sign(x)*abs(x) ,vec2(12.9898,78.233)))*43758.5453);\n}\n\n// Extrusion\nvoid zextrude(in float z, in float d2d, in float h, out float d)\n{\n    vec2 w = vec2(-d2d, abs(z)-0.5*h);\n    d = length(max(w,0.0));\n}\n\n// 2D box\nvoid dbox(in vec2 p, in vec2 b, out float dst)\n{\n  \tvec2 d = abs(p) - b;\n  \tdst = length(max(d,0.0)) + min(max(d.x,d.y),0.0); \n}\n\n// Scene\nvoid scene(in vec3 x, out vec2 d)\n{\n    float phi = .1*iTime;\n    mat2 R = mat2(cos(phi), sin(phi), -sin(phi), cos(phi));\n    x.xy = R * x.xy;\n    x.z *= .6;\n    \n    // Floor\n    d = vec2(x.z,1.);\n    \n    // Chocolate\n    float size = .1;\n    vec2 dc = mod(x.xy-.5*size, size)-.5*size, ind = (x.xy-dc)/size;\n    \n    if((abs(ind.x-.5) < 5.) && (abs(ind.y-.5) < 5.))\n    {\n        // Lower box extrusion (\"Chocolate bar\")\n\t\tvec2 da;\n        dbox(dc, .5*size*mix(c.xx,c.yy,clamp(x.z/.1, 0.,1.)), da.x);\n        zextrude(x.z, -da.x, .1, da.x);\n        da.y = 2.;\n\t    d = mix(d, da, step(da.x,d.x));\n\n        // Upper box pattern\n        float r;\n        rand(ind-floor(iTime), r);\n        float phi = pi/4.;\n        mat2 RR = mat2(cos(phi),sin(phi),-sin(phi),cos(phi));\n        if(r<.25)\n\t        dbox(RR*(dc-.71*size),size*c.xx,da.x);\n        else if(r<.5)\n            dbox(RR*(dc.yx+.71*size),size*c.xx,da.x);\n        else if(r<.75)\n            dbox(RR*(dc*c.xz+.71*size),size*c.xx,da.x);\n        else if(r<1.)\n            dbox(RR*(dc.yx*c.xz+.71*size),size*c.xx,da.x);\n        \n        zextrude(x.z,-da.x,.12,da.x);\n        da.x = abs(da.x)-.001;\n        float db;\n        dbox(dc, .485*size*c.xx, db);\n        zextrude(x.z, -db, .12, db);\n        da.x = max(da.x,db);\n        if(r<1.)\n            d = mix(d, da, step(da.x,d.x));\n    }\n    \n    d.x -= .001;\n}\n\n// Normal\nconst float dx = 5.e-4;\nvoid normal(in vec3 x, out vec3 n)\n{\n    vec2 s, na;\n    scene(x,s);\n    scene(x+dx*c.xyy, na);\n    n.x = na.x;\n    scene(x+dx*c.yxy, na);\n    n.y = na.x;\n    scene(x+dx*c.yyx, na);\n    n.z = na.x;\n    n = normalize(n-s.x);\n}\n\n// Texture\nvoid colorize(in vec2 x, out vec3 col)\n{\n    float phi = .1*iTime;\n    mat2 R = mat2(cos(phi), sin(phi), -sin(phi), cos(phi));\n    x.xy = R * x.xy;\n    \n    vec3 white = vec3(0.69,0.69,0.69),\n        gray = vec3(0.55,0.55,0.55);\n    if(abs(x.x-.05)<.5&&abs(x.y-.05)<.5)\n    {\n        col = white;\n        return;\n    }\n    float size = .1;\n    vec2 y = mod(x,size)-.5*size;\n    y = abs(y)-.001;\n    \n    float d = min(y.x,y.y);\n    col = mix(white, gray, smoothstep(1.5/iResolution.y, -1.5/iResolution.y, d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // Set up coordinates\n    a = iResolution.x/iResolution.y;\n    vec2 uv = fragCoord/iResolution.yy-0.5*vec2(a, 1.0);\n    vec3 col = c.yyy;\n    \n    // Camera setup\n    float pp = .3*iTime;\n    vec3 o = c.xzx+.05*c.xxy, \n        t = c.yyy+.05*c.xxy,\n        dir = normalize(t-o),\n        r = 1.1*normalize(c.xxy),\n        u = 1.1*normalize(c.yyx + .1*c.yxy),\n        n,\n        x;\n    t += uv.x*r + uv.y*u;\n    dir = normalize(t-o);\n    vec2 s;\n    float d = -(o.z-.12)/dir.z;\n    int N = 250,\n        i;\n    \n    // Raymarching\n    for(i=0; i<N; ++i)\n    {\n        x = o + d * dir;\n        scene(x,s);\n        if(s.x < 1.e-4) break;\n        d += min(s.x,.001);\n    }\n    \n    // Illumination\n    vec3 l = normalize(x+c.yxx);\n    if(i<N)\n    {\n\t    normal(x,n);\n        colorize(x.xy, col);\n    }\n    else\n    {\n        d = -o.z/dir.z;\n        x = o + d * dir;\n        n = c.yyx;\n        colorize(x.xy, col);\n    }\n    \n    col = .2*col\n            + .9*col*abs(dot(l,n))\n           +.4*col*abs(pow(dot(reflect(-l,n),dir),3.));\n    fragColor = clamp(vec4(col,1.0),0.,1.);\n}","name":"Buffer A","description":"","type":"buffer"}]}