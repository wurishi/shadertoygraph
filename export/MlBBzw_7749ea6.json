{"ver":"0.1","info":{"id":"MlBBzw","date":"1525557647","viewed":100,"name":"bez dist error","username":"dahart","description":"Visualize the error between approximate (Hoppe) and exact bezier distance forumulas. See the code comments.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["bezier","distance","quadratic","error"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Visualize the error between approximate (Hoppe) and exact bezier distance forumulas\n// For ray marching, the distance needs to be conservative, i.e., never over-estimate\n// Unfortunately the Hoppe method overestimates, so we're looking for error bounds, and/or\n// ways to reduce the error.\n// Here I'm trying 0.5*approx, and it looks like there's a large envelope\n// where it's safe to use, but there are still unsafe areas. Trying even\n// smaller constants, it appears that there's no upper bound to the error,\n// so never completely safe. But the curves have to be pretty sharp to see badness.\n// \n// Forked from:\n// https://www.shadertoy.com/view/XsX3zf\n// and https://www.shadertoy.com/view/XdB3Ww\n\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\nvec2 closestPointInSegment( vec2 a, vec2 b )\n{\n  vec2 ba = b - a;\n  return a + ba*clamp( -dot(a,ba)/dot(ba,ba), 0.0, 1.0 );\n}\n\n// From: http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\nvec2 get_distance_vector(vec2 b0, vec2 b1, vec2 b2) {\n\t\n  float a=det(b0,b2), b=2.0*det(b1,b0), d=2.0*det(b2,b1); // ð›¼,ð›½,ð›¿(ð‘)\n  \n  if( abs(2.0*a+b+d) < 1000.0 ) return closestPointInSegment(b0,b2);\n\t\n  float f=b*d-a*a; // ð‘“(ð‘)\n  vec2 d21=b2-b1, d10=b1-b0, d20=b2-b0;\n  vec2 gf=2.0*(b*d21+d*d10+a*d20);\n  gf=vec2(gf.y,-gf.x); // âˆ‡ð‘“(ð‘)\n  vec2 pp=-f*gf/dot(gf,gf); // ð‘â€²\n  vec2 d0p=b0-pp; // ð‘â€² to origin\n  float ap=det(d0p,d20), bp=2.0*det(d10,d0p); // ð›¼,ð›½(ð‘â€²)\n  // (note that 2*ap+bp+dp=2*a+b+d=4*area(b0,b1,b2))\n  float t=clamp((ap+bp)/(2.0*a+b+d), 0.0 ,1.0); // ð‘¡Ì…\n  vec2 bb = mix(mix(b0,b1,t),mix(b1,b2,t),t);\n  return bb;\n}\n\nfloat approx_distance(vec2 p, vec2 b0, vec2 b1, vec2 b2) {\n  return length(get_distance_vector(b0-p, b1-p, b2-p));\n}\n\n#define dd(a) dot(a,a)\nfloat addv(vec2 a) { return a.x + a.y; }\n\n//Find roots using Cardano's method. http://en.wikipedia.org/wiki/Cubic_function#Cardano.27s_method\nvec2 solveCubic2(vec3 a)\n{\n\tfloat p = (a.y - a.x*a.x/3.)/3.;\n\tfloat p3 = p*p*p;\n\tfloat q = a.x*(2.*a.x*a.x-9.*a.y)/27.+a.z;\n\tfloat d = q*q+4.*p3;\n\tif(d>.0)\n\t{\n\t\tvec2 x = (vec2(1,-1)*sqrt(d)-q)*.5;\n  \t\treturn vec2(addv(sign(x)*pow(abs(x),vec2(1./3.)))-a.x/3.);\n  \t}\n        \n \tfloat v = acos(-sqrt(-1./p3)*q*.5)/3.;\n \tfloat m = cos(v);\n \tfloat n = sin(v)*sqrt(3.);//1.732050808;\n\treturn vec2(m+m,-n-m)*sqrt(-p)-a.x/3.;\n}\n\n//Find roots using Cardano's method. http://en.wikipedia.org/wiki/Cubic_function#Cardano.27s_method\nvec2 solveCubic2a(vec3 a)\n{\n\tfloat p = a.y-a.x*a.x/3.;\n\tfloat p3 = p*p*p;\n\tfloat q = a.x*(2.*a.x*a.x-9.*a.y)/27.+a.z;\n\tfloat d = q*q+4.*p3/27.;\n\tif(d>.0)\n\t{\n\t\tvec2 x = (vec2(1,-1)*sqrt(d)-q)*.5;\n  \t\treturn vec2(addv(sign(x)*pow(abs(x),vec2(1./3.)))-a.x/3.);\n  \t}\n    \n    float x = -sqrt(-27./p3)*q*.5;\n\treturn vec2( sqrt((1.075+x)/8.)+.5, -(sqrt((1.075-x)/8.)+.5) ) * 2. * sqrt(-p/3.) - a.x/3.;\n\n    /*\n \tfloat v = acos(-sqrt(-27./p3)*q*.5)/3.;\n \tfloat m = cos(v);\n \tfloat n = sin(v)*1.732050808;\n\treturn vec2(m+m,-n-m)*sqrt(-p/3.)-a.x/3.;\n\t*/\n}\n\n// How to solve the equation below can be seen on this image.\n// http://www.perbloksgaard.dk/research/DistanceToQuadraticBezier.jpg\nfloat calculateDistanceToQuadraticBezier(vec2 p, vec2 a, vec2 b, vec2 c)\n{\n\tb = mix(b+vec2(1e-4),b,abs(sign(b*2.-a-c)));\n\tvec2 A = b-a;\n\tvec2 B = c-b-A;\n\tvec2 C = p-a;\n\tvec2 D = A*2.;\n\tC = clamp((solveCubic2(vec3(-3.*dot(A,B),dot(C,B)-2.*dd(A),dot(C,A))/-dd(B))),0.,1.);\n\ta -= p;\n\treturn sqrt(min(dd((D+B*C.x)*C.x+a),dd((D+B*C.y)*C.y+a)));\n}\n\n\n// How to solve the equation below can be seen on this image.\n// http://www.perbloksgaard.dk/research/DistanceToQuadraticBezier.jpg\nfloat calculateDistanceToQuadraticBezier2a(vec2 p, vec2 a, vec2 b, vec2 c)\n{\n\tb = mix(b+vec2(1e-4),b,abs(sign(b*2.-a-c)));\n\tvec2 A = b-a;\n\tvec2 B = c-b-A;\n\tvec2 C = p-a;\n\tvec2 D = A*2.;\n\tC = clamp((solveCubic2a(vec3(-3.*dot(A,B),dot(C,B)-2.*dd(A),dot(C,A))/-dd(B))),0.,1.);\n\ta -= p;\n\treturn sqrt(min(dd((D+B*C.x)*C.x+a),dd((D+B*C.y)*C.y+a)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 xy = fragCoord.xy;\n\t\n\tvec2 b0 = vec2(0.4, .5) * iResolution.xy;\n\t//vec2 b1 = vec2(0.5, .75 + .1*sin(iTime)) * iResolution.xy;\n\tvec2 b1 = iMouse.xy;\n\tvec2 b2 = vec2(.6, .5) * iResolution.xy;\n\tvec2 mid = .5*(b0+b2) + vec2(0.0,0.01);\n\t\n\tfloat approx_d = .95*calculateDistanceToQuadraticBezier2a(xy, b0, b1, b2);\n    float exact_d = calculateDistanceToQuadraticBezier(xy, b0, b1, b2);\n    \n    //fragColor = vec4(vec3(fract(exact_d/20.)), 1.);\n    //return;\n    \n    float safe_d = float(approx_d <= exact_d);\n    float danger_d = 1. - safe_d;\n    \n    if (exact_d < 5.) fragColor = vec4(0.);\n    else {\n        fragColor = vec4(0.);\n        fragColor += danger_d * vec4(1., .1, .1, 1.);\n        fragColor += mod(exact_d/30.,1.) * vec4(.1, 1., .1, 1.);\n        fragColor += mod(approx_d/30.,1.) * vec4(.1, .3, 1., 1.);\n    }\n}","name":"Image","description":"","type":"image"}]}