{"ver":"0.1","info":{"id":"3dGBRw","date":"1606760803","viewed":309,"name":"Voxellizator","username":"knighty","description":"Getting an SDF from a voxellisation of an SDF. Not very fast but works fine.\nUI is from FabriceNeyret2's [url=https://www.shadertoy.com/view/MdKGRw]shader[/url].\nRendering code is from gaz's [url=https://www.shadertoy.com/view/XtXGRS#]shader[/url].","likes":19,"published":1,"flags":32,"usePreview":0,"tags":["sdf","voxel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// --- sliders and mouse widgets -------------------------------------------\n//Adapted from FabriceNeyret2: https://www.shadertoy.com/view/MdKGRw\n\nvec2 R;// = iResolution.xy;\n#define UI(x) texture(iChannel0,(vec2(x,0)+.5)/R)\n#define Swidth  .004\n#define Sradius .02\n#define Bradius .04\n#define Mradius .02\n\nvec4 affMouse(vec2 uv)  { // display mouse states ( color )\n    vec4 mouse = UI(33);                       // current mouse pos\n    float k = length(mouse.xy/R.y-uv)/Mradius,\n          s = sign(mouse.z);\n\tif (k<1.) \n\t    if (k>.8) return vec4(1e-10);\n\t\t   else   return vec4(s,1.-s,0,1); \n\t\n    k = length( UI(34).xy/R.y-uv)/Mradius;     // prev mouse pos \n\tif (k<1.) \n\t    if (k>.8) return vec4(1e-10);\n\t\t   else   return vec4(0,0,1,1); \n            \n    k = length(abs(mouse.zw)/R.y-uv)/Mradius;  // drag start  mouse pos \n\tif (k<1.) \n\t    if (k>.8) return vec4(1e-10);\n\t\t   else   return vec4(0,.4,s,1); \n\t\n\treturn vec4(0);\n}\n\nfloat aff_sliders(vec2 U) { // display sliders ( grey level or 0.)\n    for (float i=0.; i<16.; i++) {\n        if (i>=UI(0).x) break;\n        vec4 S = UI(i+1.);\n        float l = abs(S.z);\n        if (S.z>0. && abs(U.y-S.y)<Swidth && abs(U.x-S.x-l/2.)<l/2. ) return 1.;\n        if (S.z<0. && abs(U.x-S.x)<Swidth && abs(U.y-S.y-l/2.)<l/2. ) return 1.;\n        if (S.z>0. && length(U-S.xy-vec2(S.a*l,0))<Sradius ) return 1.;\n        if (S.z<0. && length(U-S.xy-vec2(0,S.a*l))<Sradius ) return 1.;\n    }\n    return 0.;       \n}\n\nfloat aff_buttons(vec2 U) { // display buttons ( grey level or 0.)\n    for (float i=0.; i<16.; i++) {\n        if (i>=UI(0).y) break;\n        vec4 S = UI(i+17.);\n        float l = length(U-S.xy);\n        if (l < Bradius) \n            if (S.a>0.) return 1.; \n            else return .3+smoothstep(.7,1.,l/Bradius);\n    }\n    return 0.;\n}        \n\n//------------------------------------------------------------------------------------\n#define PI\t3.14159265359\n#define PI2\t( PI * 2.0 )\n\n//Dynamic variables\nbool DisplayOriginal = false;\n\nfloat halfWidth = 0.5, SFactor=1., RFactor=0., Radius=1.;\nvec3 Offset = vec3(0);\n\nvoid init() {//setup folding planes and vertex\n\tfloat t=iTime;\n    halfWidth=0.1*UI(1).a;// Voxel width / 2.\t\t\tLeftmost slider\n    SFactor  =UI(2).a;// Shrink factor of Voxels\n    RFactor  =UI(3).a;// Roundness of Voxels\n    Offset.x =UI(4).a;// Voxel offset\n    Offset.y =UI(5).a;\n    Offset.z =UI(6).a;\n    \n    Radius   =UI(7).a * 2.;\n    \n    DisplayOriginal = UI(17).a < 0.;\n}\n\nvec3 getColor(vec3 pos){\n\n\treturn vec3(.8,0.3,0.);\n}\n\n//Voxelizator code -------------------------------------------------\nfloat DEbox(vec3 p, float a){\n\tp = abs( p );\n\tp = p - vec3( a );\n\tfloat d = max( p.x, max( p.y, p.z ) );\n\tif( d > 0. ) d = length( max( p, vec3( 0. ) ) ); \n\treturn d;\n}\n\nfloat DEsphere(vec3 p){\n\treturn length( p ) - Radius;\n}\n\nfloat DEbase(vec3 p){\t\t\t\t\t\t\t\t\t\t\t//<---- This is The base SDF. Feel free to modify it \n\treturn max( DEbox( p, 0.65 ) - 0.2, -DEsphere( p ) );\n}\n\nfloat DEboxH(vec3 p, float h, float a){\n\tp = abs( p );\n\tvec3 pp = min( p, vec3( a - a * RFactor ) );\n\n\tif( h < 0. )\n\t\th = 0.;\n\telse\n\t\th = max( h, 2. * halfWidth );\n\n\treturn length( vec4( ( p - pp ), h ) ) - RFactor * a;\n}\n\nfloat vWidthMod(vec3 p, float hw){\n#if 0\n\tvec3 m = ( 0.5 * sin( SFactor * p + 3. * time ) + 0.5 ) * 0.3 ;\n\treturn clamp( m.x + m.y + m.z, 0., 1. ) * hw;\n#else\n\treturn clamp( SFactor, 0., 1.) * hw;\n#endif\n}\n\nvec3 roundit(vec3 p){\n\treturn 2.* halfWidth * floor( 0.5 / halfWidth * ( p - halfWidth * ( Offset - vec3( 1. ) ) ) ) + halfWidth * Offset;\n}\n\nfloat DEvox(vec3 p){\n\tfloat HWS = sqrt(3.) * halfWidth;\n\t\n\tfloat d = DEbase( p );\n\tif( d > HWS*2.) return d - HWS;\n\td = max( halfWidth, d - HWS );\n\tfloat d0 = d;\n\tvec3 p0 = roundit( p );\n\tvec3 delta = sign( p - p0 ) * 2.* halfWidth;\n\tvec3 p1 = p0;\n\tfor(int h = 0; h < 2; h++) {\n\t\tp1.z = p0.z + float( h ) * delta.z;\n\t\tfor(int j = 0; j < 2; j++){\n\t\t\tp1.y = p0.y + float( j ) * delta.y;\n\t\t\tfor(int i = 0; i < 2; i++){\n\t\t\t\tp1.x = p0.x + float( i ) * delta.x;\n\t\t\t\tfloat d1 = DEboxH( p - p1, DEbase( p1 ), vWidthMod( p1, halfWidth) );\n\t\t\t\td0 = min( d0, d1);\n\t\t\t}\n\t\t}\n\t}\n\treturn d0;\n}\n\n//End of voxelizator code ------------------------------------------\n\n//------------------------------------------------------------------\n//From gaz's : https://www.shadertoy.com/view/XtXGRS#\nvec2 rotate(in vec2 p, in float t)\n{\n\treturn p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nfloat map(in vec3 p)\n{\n    if(!DisplayOriginal)\n        return DEbase(p);\n    return DEvox(p);\n}\n\nvec3 calcNormal(in vec3 p)\n{\n\tconst vec2 e = vec2(0.0001, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy) - map(p - e.xyy),\n\t\tmap(p + e.yxy) - map(p - e.yxy),\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 5.0;\n\tconst float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 1.0;\n\tfloat res = -1.0;\n    for(int i = 0; i < 256; i++)\n    {\n        if(h < precis*t || t > maxd) break;\n\t    h = map(ro + rd * t);\n        t += h;\n    }\n    if(t < maxd) res = t;\n    return res;\n}\n\nvec3 transform(in vec3 p)\n{\n    vec4 mouse = UI(35);//R.y;\n    //mouse.xy = clamp(mouse.xy, vec2(-180.,-90.), vec2(180.,90.));\n    \n    p.zx = rotate(p.zx, iTime * 0. - (mouse.x)*PI/360.);\n    p.yz = rotate(p.yz, iTime * 0. + (mouse.y)*PI/360.);\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//Global variable init\n    R = iResolution.xy;\n    //--------------------\n    vec2 uv = fragCoord.xy/R.y;\n    //vec4 mouse = UI(33)/R.y;\n    \n\t// display sliders and buttons \n\t{ float s = aff_sliders(uv); if (s>0.) { fragColor = s*vec4(1,.2,0,1); return;}}\n    { float s = aff_buttons(uv); if (s>0.) { fragColor = s*vec4(0,.2,1,1); return;}}\n    \n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = vec3(0.3 + p.y * 0.1);\n   \tvec3 rd = normalize(vec3(p, -1.8));\n\tvec3 ro = vec3(0.0, 0.0, 2.5);\n    vec3 li = normalize(vec3(0.5, 0.8, 3.0));\n    ro = transform(ro);\n\trd = transform(rd);\n\tli = transform(li);\n    init();\n    float t = march(ro, rd);\n    if(t > -0.001)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 n = calcNormal(pos);\n\t\tfloat dif = clamp(dot(n, li), 0.0, 1.0);\n        col = getColor(pos) * dif + .5*pow(dif, 200.);\n        col = pow(col, vec3(0.45));\n\t}\n   \tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//By FabriceNeyret2: https://www.shadertoy.com/view/MdKGRw\n//With some modifications\n\n// only line 0, pixels 0 to 33 of bufA are used\n// if you need the full buffer but the .a components, you might adapt this util to use only .a \n\n#define FAKE_MOUSE 1 // fake mouse motion if no user input\n#define Sradius .02  // influence radius for sliders\n#define Bradius .04  // influence radius for buttons\n\n#define HORIZ   1.\n#define VERTIC -1.\n\n\nvec2 R;// = iResolution.xy;\n#define UI(x) texture(iChannel0,(vec2(x,0)+.5)/R)\n\n#define add_slider(x,y,d,l,v0) { nbS++; if (U==vec2(nbS,0.))    O = vec4(x,y,(l)*(d),v0); }\n#define add_button(x,y,v0)     { nbB++; if (U==vec2(nbB+16,0.)) O = vec4(x,y,0,v0);       }\n\nbool insideSlider(vec2 U, vec4 S){\n        float l = abs(S.z);\n        if (S.z>0. && abs(U.y-S.y)<Sradius && abs(U.x-S.x-l/2.)<l/2. ) return true;\n        if (S.z<0. && abs(U.x-S.x)<Sradius && abs(U.y-S.y-l/2.)<l/2. ) return true;\n        if (S.z>0. && length(U-S.xy-vec2(S.a*l,0))<Sradius ) return true;\n        if (S.z<0. && length(U-S.xy-vec2(0,S.a*l))<Sradius ) return true;\n    return false;       \n}\n\nvoid mainImage( out vec4 O,  vec2 U )\n{\n    R = iResolution.xy;\n    \n    O = texture(iChannel0,U/R);\n    U -= .5;\n    \n    if (iFrame==0) {\n        int nbS = 0, nbB = 0;\n        \n        add_slider (.05,.05,VERTIC,.5,.5); // --- define your sliders here ---\n        add_slider (.10,.05,VERTIC,.5,.8); // read value [0,1] in UI(i).a  , i=1..16\n        add_slider (.15,.05,VERTIC,.5,.5);\n        \n        add_slider (.25,.05,VERTIC,.5,.0);\n        add_slider (.30,.05,VERTIC,.5,.0);\n        add_slider (.35,.05,VERTIC,.5,.0);\n        \n        add_slider (float(iResolution.x)/float(iResolution.y)-.05,.05,VERTIC,.5,.5);\n        \n        add_button ( .05,.95, -1.);          // --- define your buttons here ---\n        //add_button ( .15,.95, -1.);        // read value {-1,1} in UI(i+16).a , i=1..16\n        \n        \n        if (U==vec2(0,0)) O = vec4(nbS, nbB, 0., 0.);\n        if (U==vec2(35,0)) O = vec4(0.);\n        return;\n    }\n    \n    if (U==vec2(33,0)) {  // previous mouse state (for BufA) our mouse state (other shaders)\n        vec4 m = iMouse;\n#if FAKE_MOUSE\n        if (length(m.xy)==0. && m.z<=0.) { // fake mouse motion if no user input\n\t        float t = iTime;         // you can reset this state by putting the mouse back in the corner\n\t        m.xy = (.5+.4*vec2(cos(t),sin(t)))*R;\n\t    }   \n#endif\n        O = m;\n        return; \n    }              \n    \n    if (U==vec2(34,0)) { O = UI(33); return; } // previous mouse state (for other shaders)\n    \n    if (U==vec2(35,0)){\n        if(iMouse.z/iResolution.y > 0.4 && iMouse.z/iResolution.y < float(iResolution.x)/float(iResolution.y)-.1)\n            O.xy = O.zw + iMouse.xy - iMouse.zw;\n        else O = O.xyxy;\n        return;\n    }\n    \n    \n    if (iMouse.z>0. && U.y==0.) {          // --- let mouse trigers the right slider or button\n       \tvec2 M = iMouse.xy/iResolution.y;\n        if (U.x <= UI(0).x) {\n\t        vec4 S = UI(U.x);\n    \t    float l = abs(S.z);\n        \tvec2 m = iMouse.xy/iResolution.y;\n\t        if (S.z>0. && abs(M.y-S.y)<Sradius && abs(M.x-S.x-l/2.)<l/2. ) O.a = (M.x-S.x)/l;\n    \t    if (S.z<0. && abs(M.x-S.x)<Sradius && abs(M.y-S.y-l/2.)<l/2. ) O.a = (M.y-S.y)/l;\n    \t}\n        else if (UI(33).z<0. &&  U.x>16. && U.x<=16.+UI(0).y ) {\n\t        vec4 S = UI(U.x);\n            if (length(M-S.xy)<Bradius) O.a *= -1.;\n        }\n    }\n        \n}","name":"Buffer A","description":"","type":"buffer"}]}