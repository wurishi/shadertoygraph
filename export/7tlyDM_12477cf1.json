{"ver":"0.1","info":{"id":"7tlyDM","date":"1648136615","viewed":73,"name":"SphereGaussian","username":"Yon","description":"https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.21.8495&rep=rep1&type=pdf\nhttps://therealmjp.github.io/posts/sg-series-part-2-spherical-gaussians-101/\nI can't understand how inverse sphere gaussian come like this.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sg","isg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct ray{\n    vec3 ori;\n    vec3 dir;\n};\n\nstruct SG\n{\n  vec3 Axis;\n  float Sharpness;\n};\n\n//this come from the normal gaussian function mapping on sphere\nvec3 EvaluateSG(in SG sg, in vec3 dir)\n{\n  float cosAngle = dot(dir, sg.Axis);\n  return vec3(exp(sg.Sharpness * (cosAngle - 1.0f)));\n}\n\n//TODO : derive the formula for code below\nvec3 EvaluateISG(in SG sg, in vec3 dir)\n{\n  float cosAngle = dot(dir, sg.Axis);\n  float sinAngle = sqrt(1.-cosAngle*cosAngle);\n  //can also dot(cross(dir,sg.Axis),cross(dir,sg.Axis))/(dot(dir,dir)*dot(sg.Axis,sg.Axis));\n  float cot = -cosAngle /(sinAngle*sg.Sharpness);\n  return vec3(exp(cot));\n}\n\nfloat hit_sphere(vec3 center, float radius, ray r){\n    vec3 oc = r.ori - center;\n    float a = dot(r.dir,r.dir);\n    float b = 2.*dot(oc,r.dir);\n    float c = dot(oc,oc)- radius*radius;\n    float discriminant = b*b - 4.*a*c;\n    if (discriminant < 0.) {\n        return -1.0;\n    } else {\n        return (-b - sqrt(discriminant) ) / (2.0*a);\n    }\n}\n\nvec3 ray_background(ray r){\n    float t = hit_sphere(vec3(0.,0.,-1.),0.5,r);\n    if (t > 0.0) {\n        vec3 N = normalize (r.ori + r.dir*t - vec3(0.,0.,-1));\n        SG sg;\n        sg.Axis = normalize(vec3(5,5,5));\n        sg.Sharpness = 1.;\n        return EvaluateISG(sg,N);\n    }    \n    vec3 dir = normalize(r.dir);\n    t = 0.5*(dir.y + 1.0);\n    return (1.-t)*vec3(1.,1.,1.) + t*vec3(0.5,0.7,1.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //window\n    const float aspect_ratio = 768./432.;\n    const float image_width = 768.;\n    const float image_height = image_width/aspect_ratio;\n    \n    //Camera\n    //near plane ?\n    float viewport_height = 2.0;\n    float viewport_width = aspect_ratio*viewport_height;\n    float focal_length = 1.0;\n    \n    vec3 origin = vec3(0.,0.,0.);\n    vec3 horizontal = vec3(viewport_width,0.,0.);\n    vec3 vertical = vec3(0.,viewport_height,0.);\n    vec3 lower_left_corner = origin - vec3(horizontal.x/2.,vertical.y/2.,focal_length);\n    \n    ray r;\n    r.ori = origin;\n    r.dir = lower_left_corner + uv.x*horizontal+uv.y*vertical - origin;\n    \n    vec3 color = ray_background(r);\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}