{"ver":"0.1","info":{"id":"wst3zX","date":"1571322728","viewed":113,"name":"Voronoi Shader with max 8 player","username":"wouter140","description":"Voronoi Shader with max 8 player, easily set by changing the N_PLAYERS define.\n\nExpanded from https://www.shadertoy.com/view/4sVXR1 ","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["voronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Screen coords:\n//   vec2 in \"screen units\" relative to the center of viewport\n//   y axis pointing up, x axis pointing to the right\n//   screen units are chosen so that a square [-1, 1] x [-1, 1] fits into the screen\n// World coords: vec2 in units.\n// Cameras: vec3, .xy is world coords of the center of the camera, .z is \"zoom\" (in screen units per world unit)\n\n\n#define PI 3.1415926535897932384626433832795\n\n#define CAMERA_ZOOM_MIN 0.6\n#define CAMERA_ZOOM_MAX 1.0\n\n#define N_PLAYERS 8\n\nvec3 playersColor[N_PLAYERS];\nvec3 playersBgColor[N_PLAYERS];\n\n\n// Inputs of the shader.\nvec2 playersPos[N_PLAYERS];  // player positions in world coordinates\nvec3 globalCam;             // global camera (zoomed out camera that sees all players)\nvec3 playersCam[N_PLAYERS];  // positions of cameras for each player\n\n\n// *****************************************************\n//  Utility functions\n// *****************************************************\n\nfloat atan2(float y, float x) {\n\t// For some reason GLSL's atan doesn't work as atan2\n    // and only returns angles [0, PI).\n    if (y > 0.0) {\n        return atan(y, x);\n    } else {\n        return PI + atan(-y, -x);\n    }\n}\n\nvec2 camScreen2World(vec3 cam, vec2 screenCoord) {\n    return cam.xy + screenCoord / cam.z;\n}\n\nfloat camScreen2World(vec3 cam, float screenLength) {\n    return screenLength / cam.z;\n}\n\nvec2 camWorld2Screen(vec3 cam, vec2 worldCoord) {\n    return (worldCoord - cam.xy) * cam.z;\n}\n\nfloat camWorld2Screen(vec3 cam, float worldLength) {\n    return worldLength * cam.z;\n}\n\nfloat screen2px(float x) {\n    return x * 0.5 * min(iResolution.x, iResolution.y);\n}\n\nfloat camWorld2Px(vec3 cam, float worldLength) {\n    return screen2px(camWorld2Screen(cam, worldLength));\n}\n\n// Weighted aggregation of the color information for overlapping objects on the same layer.\n// The resulting color is a weighted average of all aggreageted colors.\nvoid aggregateColorSiblings(inout vec4 aggColor, inout float aggWeight, vec4 addedColor) {\n    if (addedColor.w > 0.0001) {\n        float opacity = max(aggColor.w, addedColor.w);        \n        aggWeight += addedColor.w;\n        aggColor = vec4(mix(aggColor.xyz, addedColor.xyz, addedColor.w / aggWeight), opacity);\n    }    \n}\n\n// *****************************************************\n//  Scene rendering (demo vesion)\n// *****************************************************\n\nvec3 renderBackgroundRadialChecker(vec3 cam, vec2 screenCoord) {\n    vec2 worldCoord = camScreen2World(cam, screenCoord);\n    \n    float radius = length(worldCoord.xy);\n    float angularD = atan2(worldCoord.y, worldCoord.x) * radius;\n    \n    const float rowWidthGrowthPow = 2.5;    \n    const float rowRadiusScale = 100.0;\n    // index of a radial checker row.\n    float row = ceil(pow(radius * rowRadiusScale, 1.0 / rowWidthGrowthPow));\n    \n    float rowOuterRadius = pow(row, rowWidthGrowthPow) / rowRadiusScale;    \n    float radialBorderD = abs(radius - rowOuterRadius);\n    float columns = 10.0;\n    const float minRow = 2.0;\n    if (row < minRow + 0.1) {\n        row = minRow;\n        columns = 4.0;\n    } else {\n  \t\tfloat rowInnerRadius = pow(row - 1.0, rowWidthGrowthPow) / rowRadiusScale;\n        radialBorderD = min(radialBorderD, abs(radius - rowInnerRadius));\n        \n        columns = 10.0;        \n    }\n    \n    // index of a concentric checker column.\n    float columnWidth = (radius * 2.0 * PI) / columns;\n    float col = ceil(angularD / columnWidth);\n    \n    float concentricBorderD = abs(mod(angularD / columnWidth + 0.5, 1.0) - 0.5) * columnWidth;\n    \n    \n    const vec3 white = vec3(1.0);\n    const vec3 black = vec3(0.0);\n    vec3 midColor = 0.5 * (black + white);\n    \n    vec3 color;\n    if (mod(row + col, 2.0) > 0.5) {\n        color = white;\n    } else {\n        color = black;\n    }\n    \n    float borderDPx = camWorld2Px(cam, min(radialBorderD, concentricBorderD));\n    float aaColorWeight = smoothstep(0.0, 0.6, borderDPx);\n    \n    return mix(midColor, color, aaColorWeight);\n}\n\nvec4 renderPlayers(vec3 cam, vec2 screenCoord) {\n    vec2 worldCoord = camScreen2World(cam, screenCoord);\n    \n    // Player is a 10px at furthest possible zoom and gets bigger when gets closer.\n    float radiusPx = 10.0 * max(cam.z, CAMERA_ZOOM_MIN) / CAMERA_ZOOM_MIN;\n    const float radiusAaPx = 1.0;\n    \n    vec4 color = vec4(0.0);\n    float weight = 0.0;\n    for(int i = 0; i < N_PLAYERS; i++) {\n    \tfloat distPx = camWorld2Px(cam, length(worldCoord - playersPos[i]));\n        \n        float playerWeight = 1.0 - smoothstep(radiusPx, radiusPx + radiusAaPx, distPx);\n        vec4 playerColor = vec4(playersColor[i], playerWeight);\n        aggregateColorSiblings(color, weight, playerColor);\n  \t}    \n    return color;\n}\n\nvec3 renderScene(vec3 cam, vec2 screenCoord) {\n    vec3 color = renderBackgroundRadialChecker(cam, screenCoord);\n    vec4 playersColor = renderPlayers(cam, screenCoord);\n    color = mix(color, playersColor.xyz, playersColor.w);\n    \n    return color;\n}\n\n// *****************************************************\n//  Screen partitioning\n// *****************************************************\n\n// Returns a number that is guaranteed to be higher than any\n// of the distances within Global Camera.\nfloat maxGlobalDist() {\n    return camScreen2World(globalCam, 100.0);\n}\n\nint closestPlayer(vec2 screenCoord) {\n    vec2 worldCoord = camScreen2World(globalCam, screenCoord);\n\n    int minPlayer = 0;\n    float minDist = maxGlobalDist();\n    for(int i = 0; i < N_PLAYERS; i++) {\n    \tfloat dist = length(worldCoord - playersPos[i]);\n        \n        if (dist < minDist) {\n            minDist = dist;\n            minPlayer = i;\n        }\n  \t}\n    \n    return minPlayer;\n}\n\n\n// *****************************************************\n//  Faking inputs\n// *****************************************************\n\nvec2 initPlayerPos(vec2 basePos, float radius, float basePhase, float timeC) {\n    vec2 center = basePos - radius * vec2(cos(basePhase), sin(basePhase));\n    float phase = basePhase + iTime * timeC;\n    return center + radius * vec2(cos(phase), sin(phase));\n}\n\nvoid fakePlayers() {\n    const float timeScale = 0.2;\n    \n    for(int i = 0; i < N_PLAYERS; i++) {\n        switch(i) {\n            case 0:\n            playersColor[i] = vec3(0.957, 0.263, 0.212);  // red\n            playersPos[i] = initPlayerPos(vec2(0.2, 0.1), 2.0, PI, 1.0 * timeScale);\n            break;\n            \n            case 1:\n            playersColor[i] = vec3(0.129, 0.588, 0.953);  // blue\n            playersPos[i] = initPlayerPos(vec2(-0.2, 0.1), 1.0, 3.0 * PI * 0.5, 3.0 * timeScale);\n            break;\n            \n            case 2:\n            playersColor[i] = vec3(0.298, 0.686, 0.314);  // green\n            playersPos[i] = initPlayerPos(vec2(-0.2, -0.1), 3.0, 0.0, 0.5 * timeScale);\n            break;\n            \n            case 3:\n            playersColor[i] = vec3(0.612, 0.153, 0.69);   // purple\n            playersPos[i] = initPlayerPos(vec2(0.2, -0.1), 2.0, 3.0 * PI / 4.0, 1.0 * timeScale);\n            break;\n            \n            \n            case 4:\n            playersColor[i] = vec3(1, 0.153, 0.69);   \n            playersPos[i] = initPlayerPos(vec2(0.2, -0.1), 2.0, 3.0 * PI / 5.0, 1.0 * timeScale);\n            break;\n            \n            case 5:\n            playersColor[i] = vec3(0.612, 1, 0.69);   \n            playersPos[i] = initPlayerPos(vec2(0.2, -0.1), 1.0, 3.0 * PI / 10.0, 1.0 * timeScale);\n            break;\n            \n            case 6:\n            playersColor[i] = vec3(0.612, 0.153, 1);   \n            playersPos[i] = initPlayerPos(vec2(0.2, -0.1), 3.0, 3.0 * PI / 14.0, 1.0 * timeScale);\n            break;\n            \n            case 7:\n            playersColor[i] = vec3(0.612, 0.553, 1);   \n            playersPos[i] = initPlayerPos(vec2(0.2, -0.1), 2.0, 3.0 * PI / 34.0, 1.0 * timeScale);\n            break;\n            \n            \n            case 8:\n            playersColor[i] = vec3(0.957, 0.263, 0.212);  // red\n            playersPos[i] = initPlayerPos(vec2(0.8, 0.5), 2.0, PI, 1.0 * timeScale);\n            break;\n            \n            case 9:\n            playersColor[i] = vec3(0.129, 0.588, 0.953);  // blue\n            playersPos[i] = initPlayerPos(vec2(-0.8, -0.1), 1.0, -3.0 * PI * 0.5, 3.0 * timeScale);\n            break;\n            \n            case 10:\n            playersColor[i] = vec3(0.298, 0.686, 0.314);  // green\n            playersPos[i] = initPlayerPos(vec2(-0.3, 0.1), 3.0, 0.0, 0.5 * timeScale);\n            break;\n            \n            case 11:\n            playersColor[i] = vec3(0.612, 0.153, 0.69);   // purple\n            playersPos[i] = initPlayerPos(vec2(-0.4, 0.1), 2.0, 3.0 * PI / -4.0, 1.0 * timeScale);\n            break;\n            \n            case 12:\n            playersColor[i] = vec3(1, 0.153, 0.69);   \n            playersPos[i] = initPlayerPos(vec2(0.3, -0.7), 2.0, -3.0 * PI / 5.0, 1.0 * timeScale);\n            break;\n            \n            case 13:\n            playersColor[i] = vec3(0.612, 1, 0.69);   \n            playersPos[i] = initPlayerPos(vec2(-0.92, -0.1), 1.0, -3.0 * PI / -10.0, 1.0 * timeScale);\n            break;\n            \n            case 14:\n            playersColor[i] = vec3(0.612, 0.153, 1);   \n            playersPos[i] = initPlayerPos(vec2(0.29, 0.1), 3.0, 3.0 * PI / -4.0, 1.0 * timeScale);\n            break;\n            \n            case 15:\n            playersColor[i] = vec3(0.612, 0.553, 1);   \n            playersPos[i] = initPlayerPos(vec2(0.62, -0.31), 2.0, 3.0 * PI / 44.0, 1.0 * timeScale);\n            break;\n        }\n    }\n}\n\n\nvoid fakeGlobalCamera() {\n    vec2 minPlayerCoord = playersPos[0];\n    vec2 maxPlayerCoord = playersPos[0];\n    for(int i = 1; i < N_PLAYERS; i++) {\n        minPlayerCoord = min(minPlayerCoord, playersPos[i]);\n        maxPlayerCoord = max(maxPlayerCoord, playersPos[i]);\n  \t}\n    const float cameraMarginScreen = 0.4;\n    // (maxPlayerCoord.x - minPlayerCoord.x) * zoom + 2.0 * cameraMarginScreen = iResolution.x / screen2px(1.0);\n    vec2 zoom = (iResolution.xy / screen2px(1.0) - 2.0 * cameraMarginScreen) / (maxPlayerCoord - minPlayerCoord);\n\tglobalCam = vec3((minPlayerCoord + maxPlayerCoord) * 0.5, min(min(zoom.x, zoom.y), CAMERA_ZOOM_MAX));\n}\n\nvoid fakePlayerCameras() {\n    if (globalCam.z > CAMERA_ZOOM_MIN) {\n        for(int i = 0; i < N_PLAYERS; i++) {\n            playersCam[i] = globalCam;\n        }\n    } else {\n        for(int i = 0; i < N_PLAYERS; i++) {\n            vec2 playerPosScreen = camWorld2Screen(globalCam, playersPos[i]);\n            playersCam[i] = vec3(playersPos[i] - playerPosScreen / CAMERA_ZOOM_MIN, CAMERA_ZOOM_MIN);\n        }\n    }\n}\n\nvoid adjustPlayerCameras(float uniformCamZoom) {\n    \n    for(int i = 0; i < N_PLAYERS; i++) {\n        playersBgColor[i] = playersColor[i];\n    }\n    float mergeDistMin = 0.6 * CAMERA_ZOOM_MIN;\n    float mergeDistMax = 0.8 * CAMERA_ZOOM_MIN;\n    for (int k = 0; k < 2; k++) {\n        // Moving cameras closer to each other.\n        for(int i = 0; i < N_PLAYERS; i++) {\n            for(int j = 0; j < N_PLAYERS; j++) {\n                if (i < j) {\n                    vec2 camPosI = playersCam[i].xy;\n                    vec2 camPosJ = playersCam[j].xy;\n                    float camDistScreen = length(camPosI - camPosJ) * uniformCamZoom;\n                    float mergeWeight = 0.5 * (1.0 - pow(smoothstep(mergeDistMin, mergeDistMax, camDistScreen), 4.0));\n                    playersCam[i].xy = mix(camPosI, camPosJ, mergeWeight);\n                    playersCam[j].xy = mix(camPosJ, camPosI, mergeWeight);\n\n                    vec3 bgColorI = playersBgColor[i];\n                    vec3 bgColorJ = playersBgColor[j];\n                    playersBgColor[i] = mix(bgColorI, bgColorJ, mergeWeight);\n                    playersBgColor[j] = mix(bgColorJ, bgColorI, mergeWeight);\n                }            \n            }\n        }\n        mergeDistMin *= 0.5;\n        mergeDistMax *= 0.5;\n    }\n}\n\n// *****************************************************\n//  Demos\n// *****************************************************\n\nvec4 mainSimpleDemo(vec2 screenCoord) {\n    fakePlayers();    \n    \n    float zoom = (CAMERA_ZOOM_MAX + CAMERA_ZOOM_MIN) * 0.5; // x axis spans [-10, 10]\n    zoom = zoom - (CAMERA_ZOOM_MAX - CAMERA_ZOOM_MIN) * 0.5 * cos(iTime * 0.3);  // animate zoom\n    const float camRadius = 0.2;\n\tvec3 camera = vec3(camRadius * cos(iTime), camRadius * sin(iTime), zoom);\n    \n    return vec4(renderScene(camera, screenCoord), 1.0);\n}\n\nvec4 mainGlobalCameraDemo(vec2 screenCoord) {\n    fakePlayers();    \n    fakeGlobalCamera();\n    \n    vec3 color = renderScene(globalCam, screenCoord);\n    int player = closestPlayer(screenCoord);\n    for(int i = 0; i < N_PLAYERS; i++) {\n        if (player == i) {\n        \tcolor = mix(color, playersColor[i], 0.4);\n        }\n    }\n    \n    return vec4(color, 1.0);\n}\n\nvec4 mainSplitScreenDemo(vec2 screenCoord) {\n    fakePlayers();    \n    fakeGlobalCamera();\n    fakePlayerCameras();\n\n    // We assume that all player cams have the same zoom.\n    float uniformCamZoom = playersCam[0].z;\n    adjustPlayerCameras(uniformCamZoom);\n    \n    int player = closestPlayer(screenCoord);\n    vec3 color;\n    for(int i = 0; i < N_PLAYERS; i++) {\n        if (player == i) {\n        \tcolor = renderScene(playersCam[i], screenCoord);\n        \tcolor = mix(color, playersBgColor[i], 0.4);\n        }\n    }\n    \n    return vec4(color, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCoord = (fragCoord.xy - 0.5 * iResolution.xy) / screen2px(1.0);\n    // vec4 color = mainSimpleDemo(screenCoord);\n    // vec4 color = mainGlobalCameraDemo(screenCoord);\n    vec4 color = mainSplitScreenDemo(screenCoord);\n\tfragColor = vec4(color.xyz, 1.0);\n}","name":"Image","description":"","type":"image"}]}