{"ver":"0.1","info":{"id":"ssyyR3","date":"1655289319","viewed":71,"name":"mnikn-dragonball-radar","username":"mnikn","description":"radar","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["radar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"# define PI 3.14159\n\nfloat circle(vec2 uv, float radius) {\n    return smoothstep(radius+0.005, radius, length(uv));\n}\n\nfloat circle_outline(vec2 uv, float radius, float outline_size) {\n    float out_c = circle(uv, radius);\n    float in_c = circle(uv, radius-outline_size);\n    return out_c - in_c;\n}\n\nfloat sat(float t) {\n    return clamp(t, 0.0, 1.0);\n}\n\nfloat remap01(float a, float b, float t) {\n    return sat((t - a) / (b - a));\n}\n\nfloat remap(float a, float b, float c, float d, float t) {\n    return remap01(a, b, t) * (d - c) + c;\n}\n\nfloat grid(vec2 uv, float n, float size) {\n    uv *= n;\n    float r = step(fract(uv.x), 1.0 - size);\n    r *= step(fract(uv.y), 1.0 - size);\n    return r;\n}\n\nvec3 gold_ball(vec2 uv, vec3 col) {\n    float radius = 0.01 * abs(sin(iTime*2.0));\n    float blur = 0.005;\n    col = mix(col, vec3(0.3), smoothstep(radius+blur*4.0, radius, length(uv)));\n    float b = smoothstep(radius+blur, radius, length(uv));\n    col = mix(col, vec3(1.0, 0.85, 0.4), b);\n    return col;\n}\n\nfloat polygon(vec2 uv, int n, float size) {\n    float a = atan(uv.y, uv.x);\n    float r = 2.0 * PI / float(n);\n    \n    float d = cos(floor(0.5 + a / r) * r - a) * length(uv);\n    d = smoothstep(size+0.005, size, d);\n    return d;\n}\n\nvec2 rotate2d(vec2 uv, float a) {\n    mat2 r = mat2(cos(a), sin(a), -sin(a), cos(a)) * mat2(uv.x, uv.y, 0, 0);\n    return vec2(r[0][0], r[0][1]);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    \n    float out_circle = circle(uv, 0.5);\n    col += out_circle * vec3(0.9);\n    \n    float t = remap(0.0, 1.0, 1.0, 0.6, abs(uv.x));\n    float outer_gradient1 = circle_outline(uv, 0.44, 0.03);\n    col = mix(col, vec3(0.8) * t, outer_gradient1);\n    float outer_gradient2 = circle_outline(uv, 0.45, 0.01);\n    col = mix(col, vec3(1.0) * t, outer_gradient2);\n    \n    \n    vec3 rada_color = vec3(0.2, 0.55, 0.2);\n    float inner1 = circle(uv, 0.4);\n    col = mix(col, rada_color, inner1);\n    \n    float inner_gradient = circle_outline(uv, 0.42, 0.025);\n    col = mix(col, rada_color * remap(0.0, 1.0, 1.0, 0.3, abs(uv.y)), inner_gradient);\n    \n    float gridlines = grid(uv, 6.0, 0.03);\n    if (inner1 + inner_gradient >= 0.5) {\n        col = mix(col, vec3(0.2), 1.0 - gridlines);\n    }\n    \n    \n    // render ball\n    col = gold_ball(vec2(uv.x+0.22,uv.y+0.2), col);\n    col = gold_ball(vec2(uv.x-0.2,uv.y-0.03), col);\n    col = gold_ball(vec2(uv.x+0.2,uv.y-0.1), col);\n    col = gold_ball(vec2(uv.x-0.25,uv.y+0.14), col);\n    \n\n    uv = rotate2d(uv, PI/2.0);\n    float pointer_radius = 0.025 * abs(sin(iTime*2.0));\n    float pointer = polygon(uv*2.0,3,pointer_radius);\n    col = mix(col, vec3(1.0, 0.3, 0.1), pointer);\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}