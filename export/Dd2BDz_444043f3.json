{"ver":"0.1","info":{"id":"Dd2BDz","date":"1689607791","viewed":75,"name":"Duck on the sea","username":"cosmo_brain","description":"it's a duck and a Charmander\nthis is an extension of my \"Boat on the sea\" project\nthat duck took ages to draw\ninspiration for the waves came from Just Shapes and Beats2","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["duck"],"hasliked":0,"parentid":"mdSBRR","parentname":"Boat on the sea"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU (3.1415926*2.)\n#define PI 3.1415926\n#define S(a, b, t) smoothstep(a, b, t)\n\nvec2 rotate(vec2 v, float theta) {\n    float s = sin(theta);\n    float c = cos(theta);\n    mat2x2 rotation = mat2x2(c, s, -s, c);\n    return rotation*v;\n}\n\nfloat map(float v, float min1, float max1, float min2, float max2) {\n    return (v-min1)/(max1-min1) * (max2-min2) + min2;\n}\n\nfloat TaperBox(vec2 uv, float bottomWidth, float topWidth, float height, float offset, float blur) {\n    float percentageUp = (uv.y+height/2.)/height;\n    float width = mix(bottomWidth, topWidth, percentageUp);\n    float currentOffset = mix(-offset/2., offset/2., percentageUp);\n    float leftRight = smoothstep(blur, -blur, abs(uv.x-currentOffset)-width/2.);\n    float topBottom = smoothstep(blur, -blur, abs(uv.y)-height/2.);\n    return leftRight*topBottom;\n}\n\nfloat Circle(vec2 uv, float radius, float blur) {\n    return smoothstep(blur, -blur, length(uv)-radius);\n}\n\nfloat SemiCircle(vec2 uv, float radius, float blur) {\n    return S(-blur, blur, uv.y)*S(blur, -blur, length(uv)-radius);\n}\n\nfloat RoundedRectangle(vec2 uv, float width, float thickness, float blur) {\n    float rectangle = TaperBox(uv, width, width, thickness, 0.0, blur);\n    float right = Circle(uv-vec2(width/2., 0.0), thickness/2., blur);\n    float left = Circle(uv-vec2(-width/2., 0.0), thickness/2., blur);\n    return max(max(rectangle, right), left);\n}\n\nvoid colour(inout vec3 col, vec3 colour, float influence) {\n    col = mix(col, colour, influence);\n}\n\nfloat height(float x, float t) {\n    return sin((x+t)*10.2)*0.04 + sin((x+2.*t)*20.32)*0.02 - 0.05;\n}\n\nfloat Ground(vec2 uv, float t, float blur) {\n    return smoothstep(blur, -blur, uv.y-height(uv.x, t));\n}\n\nfloat GroundFancy(vec2 uv, float t, float blur) {\n    float sideLineSize = 0.0; // this doesn't quite work properly idk why \n    float lineWidth = 0.04;\n\n    float id = floor(uv.x/lineWidth + 0.5);\n    uv.x = fract(uv.x/lineWidth + 0.5)-0.5; // -0.5 to 0.5\n    float y = height(lineWidth*(id-0.5), t);\n    \n    // below circle centre (0, y)\n    // uv.x*uv.x + (y-uv.y)*(y-uv.y)/(0.05*0.05) = 0.5*0.5\n    float currentPointHeight = y + sqrt((lineWidth*lineWidth/4.) * (0.4*0.4-uv.x*uv.x));\n    float sideLines = smoothstep(-blur, blur, (0.5-sideLineSize/2.)-abs(uv.x));\n    \n    return smoothstep(blur, -blur, uv.y-currentPointHeight)*sideLines;\n}\n\nfloat GroundFancySaved(vec2 uv, float t, float blur) {\n    float id = floor(uv.x/0.1 + 0.5);\n    uv.x = fract(uv.x/0.1 + 0.5)-0.5; // -0.5 to 0.5\n    float y = height(0.1*(id-0.5), t);\n    \n    // below circle centre (0, y)\n    // uv.x*uv.x + (y-uv.y)*(y-uv.y)/(0.05*0.05) = 0.5*0.5\n    float currentPointHeight = y + sqrt((0.05*0.05) * (0.4*0.4-uv.x*uv.x));\n    float sideLines = smoothstep(-blur, blur, 0.4-abs(uv.x));\n    \n    return smoothstep(blur, -blur, uv.y-currentPointHeight)*sideLines;\n}\n\n\nvoid Boat(inout vec3 col, vec2 uv, float t, float blur) {\n    float minBound = 0.0;\n    float maxBound = 0.9;\n\n    float mastShadow = map(TaperBox(uv-vec2(0.025-0.007, 0.05), 0.01, 0.01, 0.1, 0.0, blur), 0., 1., 1., 0.8);\n    float flag = TaperBox(uv-vec2(0.025, 0.05 + sin((uv.x+t)*36.31)*0.005*S(0., 0.1, uv.x)), 0.1, 0.0, 0.1, -0.05, blur);\n    // if (flag < maxBound && flag > minBound) colour(col, vec3(0), 1.);\n    /* else */ colour(col, vec3(247, 95, 82)/255. * mastShadow, flag);\n    \n    // colour(col, vec3(181, 103, 14)/255., TaperBox(uv, 0.03, 0.03, 0.2, 0.0, blur));\n    float mastShadowOnMast = map(\n        RoundedRectangle(rotate(uv-vec2(.0080, .0), PI/2.), 0.2, 0.016, blur),\n        0., 1., 1., .8);\n    float mast = RoundedRectangle(rotate(uv, PI/2.), 0.2, 0.03, blur);\n    // if (mast < maxBound && mast > minBound) colour(col, vec3(0.), 1.);\n    /* else */ colour(col, vec3(219, 143, 11)/255. * mastShadowOnMast, mast);\n    \n    \n    /*colour(col, vec3(201, 116, 18)/255., RoundedRectangle(uv-vec2(0.0, -0.1), 0.45, 0.03, blur));\n    colour(col, vec3(201, 116, 18)/255., RoundedRectangle(uv-vec2(0.0, -0.128), 0.35, 0.03, blur));\n    colour(col, vec3(201, 116, 18)/255., RoundedRectangle(uv-vec2(0.0, -0.146), 0.25, 0.03, blur));*/\n    \n    float circle = SemiCircle(rotate(uv-vec2(0.0, -0.1), PI)*vec2(0.6, 1.0), 0.1, blur);\n    float circleShadow = map(TaperBox(uv-vec2(0.0, -0.3), 0.5, 0.5, 0.38, 0.0, blur), 0., 1., 1., .8);\n    // if (circle < maxBound && circle > minBound) colour(col, vec3(0.), 1.);\n    /* else */ colour(col, vec3(219, 143, 11)/255. * circleShadow, circle);\n    \n    float nose = RoundedRectangle(uv-vec2(0.14, -0.11), 0.15, 0.02, blur);\n    colour(col, vec3(219, 143, 11)/255. * circleShadow, nose);\n    \n    float line;\n    for (float i=0.; i<1.; i+=1./8.) {\n        line = TaperBox(uv-vec2(0., -0.11-.1*i + .0*abs(uv.x)*abs(uv.x)), 0.5, 0.5, 0.003, 0.0, blur);\n        colour(col, vec3(0.), line*max(circle, nose));\n    }\n    \n    float highest = max(circle, max(mast, max(nose, flag)));\n    // if (highest < maxBound && highest > minBound) colour(col, vec3(0.), 1.);\n}\n\nfloat angle(float x, float t, float delta) {\n    return atan(height(x+delta/2., t)-height(x-delta/2., t), delta);\n}\n\nfloat Ellipse(vec2 uv, float width, float height, float blur) {\n    return S(blur, -blur, length(vec2(uv.x/width, uv.y/height))-1.);\n}\n\nfloat random(inout float seed) {\n    float result = abs(fract(sin(seed*2314.341239+2.1938)*12.1234920));\n    seed = abs(fract(sin(seed*293.1920304+102.392483)*295.123957));\n    return result;\n}\n\nfloat Cloud(vec2 uv, float seed, int circles, float blur) {\n    float col = float(0.);\n    col += Ellipse(uv, 0.2, 0.1, blur);\n    for (int i=0; i<circles; i++) {\n        float r1 = random(seed);\n        float r2 = random(seed);\n        float r3 = random(seed);\n        \n        col += Ellipse(uv-(vec2(r1, r2)*0.3-.15), mix(.1, .2, r3), mix(.1, .2, r3), blur);\n    }\n    // col /= float(circles);\n    return col;\n}\n\nfloat CloudLayer(vec2 uv, float t, vec2 cloudSize) {\n    float id = floor((uv.x+t*0.5)/0.5/cloudSize.x);\n    float unusedID = id;\n    uv.x = fract((uv.x+t*0.5)/0.5/cloudSize.x);\n    float cloud = Cloud((uv*vec2(1., 4./cloudSize.y)-vec2(0.5+(random(unusedID)-.5)*.2, 1.2+(random(unusedID)-.5)*.5)), id, 6, 0.5);\n    return min(max(cloud, 0.), 1.);\n}\n\nfloat tail(vec2 uv, float blur) {\n    float left = S(-blur, blur, uv.x-.25);\n    float right = S(blur, -blur, uv.x-1.);\n    float top = S(blur, -blur, uv.y-sin(TAU*uv.x)/13. - .5);\n    float bottom = S(-blur, blur, uv.y-pow(max(0., 2.*(uv.x-.5)), 5.8)/2.);\n    return left*right*top*bottom;\n}\n\nfloat lowerBeak(vec2 uv, float blur) {\n    float right = S(blur, -blur, uv.x-1.);\n    float left = S(-blur, blur, uv.x+sin(3./2. * PI * uv.y*uv.y));\n    float top = S(blur, -blur, uv.y);\n    float bottom = S(-blur, blur, uv.y+1.);\n    return right*left*bottom*top;\n}\n\nfloat topBeak(vec2 uv, float blur) {\n    float top = S(blur, -blur, uv.y-1.);\n    float to_square = sqrt(uv.x+.1-.1*uv.y) - .5;\n    float bottom = S(-blur, blur, uv.y-to_square*to_square*4.);\n    return max(top*bottom, TaperBox(uv-vec2(.5, 1.5), 1., 1., 1.5, 0.0, blur));\n}\n\nfloat body(vec2 uv, float blur) {\n    float height = (sin(PI/2.)/13. + .5)/2.;\n    float front = SemiCircle(rotate(uv-vec2(0.22, height)*vec2(1./(3.*height), 1.), -PI/2.), height, blur);\n    float back = tail(uv, blur);\n    return max(back, front);\n}\n\nvec4 eye(vec2 uv, float blur) {\n    vec3 col = vec3(0.);\n\n    float whites = Circle(uv, 0.05, blur);\n    col = mix(col, vec3(1.), whites);\n    float pupil = Circle(uv, 0.035, blur);\n    col = mix(col, vec3(0.), pupil);\n    float highlight = Circle(uv-vec2(-0.01, 0.01), 0.01, blur);\n    col = mix(col, vec3(1.), highlight);\n    \n    return vec4(col.rgb, max(max(whites, pupil), highlight));\n}\n\nfloat fire(vec2 uv, float time, float blur) {\n    float width = 0.4*sin(PI*sqrt(uv.y));\n    float offset = 0.15*uv.y*sin(0.75*TAU*uv.y + time);\n    float sides = S(blur, -blur, abs(uv.x-offset)-width);\n    return sides*S(blur, -blur, abs(uv.y-.5)-.5);\n}\n\nvoid Duck(inout vec3 col, vec2 uv, float t, float blur) {\n    vec3 bodyColour = vec3(245, 213, 5)/255.;\n    vec3 beakColour = vec3(242, 129, 7)/255.;\n    vec3 armColour = vec3(245, 213, 5)/255.;\n\n    col = mix(col, beakColour, lowerBeak((uv - vec2(-0.55, 0.3))*10.*vec2(1.3, 1.), blur));\n    col = mix(col, beakColour, topBeak(rotate(uv - vec2(-0.625, 0.33), 90.*PI/180.)*10., blur));\n    \n    col = mix(col, bodyColour, Circle(uv+vec2(.5, .5)-vec2(0.3, 0.8), 0.3, blur)); // head\n    col = mix(col, bodyColour, body(uv+vec2(.5, .5), blur));\n\n    vec2 offset = vec2(-0.2, 0.05);\n    float correctionWidth = 0.5;\n    float correctionHeight = 0.15;\n    float headTailFix = TaperBox(uv-offset, correctionWidth*0.9,correctionWidth*0.9, correctionHeight, 0.0, blur);\n    headTailFix *= 1.-Circle(uv-offset-vec2(correctionWidth/2., 0.), correctionHeight/2., blur);\n    headTailFix *= 1.-Circle(uv-offset-vec2(-correctionWidth/2., 0.), correctionHeight/2., blur);\n    col = mix(col, vec3(bodyColour), headTailFix);\n\n    // col = mix(col, vec3(bodyColour)*.7, body((uv-vec2(-.12, -.37))/.5, blur));\n    col = mix(col, vec3(0.), tail((uv-vec2(-.12, -.37))/.5, blur));\n    col = mix(col, armColour, tail((uv-vec2(-.09, -.36))/.45, blur));\n    col = mix(col, armColour, TaperBox(uv-vec2(0.0, -.23), 0.05,0.05, 0.26, 0.0, blur));\n    col = mix(col, bodyColour, TaperBox(uv-vec2(0.0, -.23)-vec2(-0.026/2., 0.), 0.035,0.035, 0.27, 0.0, blur));\n    col = mix(col, armColour, SemiCircle(rotate(uv-vec2(0.04/2.-0.026/2., -.23), -90.*PI/180.), 0.26/2., blur));\n\n    // vec4 leftEye = eye(, blur);\n    uv = (uv-vec2(-.275, .35))/1.7;\n    float whites = Circle(uv, 0.05, blur*.5);\n    col = mix(col, vec3(1.), whites);\n    float pupil = Circle(uv, 0.035, blur*.5);\n    col = mix(col, vec3(0.), pupil);\n    float highlight = Circle(uv-vec2(-0.014, 0.014), 0.01, blur*.5);\n    col = mix(col, vec3(1.), highlight);\n    // col = mix(col, leftEye.rgb, leftEye.a);\n    uv = (uv*1.7+vec2(-.275, .35));\n\n    vec2 firePosition = vec2(0.48, -0.02);\n    col = mix(col, vec3(1., 0., 0.), fire(rotate((uv-firePosition)*7., 45.*PI/180.), t, blur));\n    col = mix(col, beakColour, fire(rotate((uv-firePosition)*10., 45.*PI/180.), t, blur));\n    col = mix(col, vec3(240, 207, 24)/255., fire(rotate((uv-firePosition)*15., 45.*PI/180.), t, blur));\n    col = mix(col, vec3(245, 223, 100)/255., fire(rotate((uv-firePosition)*20., 45.*PI/180.), t, blur));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime*0.1;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    // uv.x /= resolution.y/resolution.x;\n    \n    float blur = 0.001;\n    float boatAngleCoefficient = 1.3;\n    float boatHeightChangeCoefficient = 1.;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.);\n    // colour(col, mix(vec3(48, 160, 240)/255., vec3(0.0, 0.4, 1.0), S(0.0, -0.5, uv.y)), GroundFancy(uv-vec2(0.0, -0.1), t, blur));    \n    \n    float sunBrightness = smoothstep(0., 0.5, length(uv-vec2(-0.4, 0.4)));\n    col = mix(vec3(161, 232, 237)/255., vec3(43, 144, 252)/255., sunBrightness);\n    // col *= mix(0.2, 0.85, S(1., 0., -uv.y*2.*1.1));\n    col *= mix(1., 2.*sin(PI*(.5-uv.y))*sin(PI*(.5-uv.y)), S(0., 1., .5-uv.y));\n    col = min(col, vec3(1.));\n    colour(col, vec3(245, 236, 108)/255., Circle(uv-vec2(-0.4, 0.4), 0.1, blur * mix(8., 20., S(-1., 1., sin(t*2.3))) ));\n    \n    float cloudBrightness = map(pow(sunBrightness, .4), 0., 1., 1., .9);\n    colour(col, vec3(cloudBrightness*.9), CloudLayer(uv*1.8-vec2(0.0, -0.3), t*3., vec2(2.3, 3.)));\n    colour(col, vec3(cloudBrightness*.9), CloudLayer(uv*1.8-vec2(0.8, -0.3), t*3., vec2(2.3, 3.)));\n    colour(col, vec3(cloudBrightness), CloudLayer(uv, t, vec2(1., 1.)));\n    colour(col, vec3(cloudBrightness), CloudLayer(uv-vec2(0.8, 0.05), t, vec2(1., 1.)));\n    \n    // Boat(col, rotate(uv/0.8-vec2(0.0, 0.04+height(-0.1, t)*boatHeightChangeCoefficient), 0.03-angle(0.025, t, 0.5)*boatAngleCoefficient), t, blur*2.);\n    Duck(col, rotate(uv*vec2(-1., 1.)/0.4-vec2(0.0, 0.04+height(-0.1, t)*boatHeightChangeCoefficient), -0.03+angle(0.025, t, 0.5)*boatAngleCoefficient), t*20., blur*2.);\n    // Boat(col, rotate(uv-vec2(0.0, 0.08+height(-0.1, t)*boatHeightChangeCoefficient), -angle(0.025, t, 0.5)*boatAngleCoefficient), t, blur);\n    colour(col, mix(vec3(31, 193, 242)/255., vec3(0.0, 0.0, 0.0), S(-0.05, -0.5, uv.y)), GroundFancy(uv-vec2(0.0, -0.1), t, blur)*0.8);\n    \n    \n    // col *= 0.;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}