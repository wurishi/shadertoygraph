{"ver":"0.1","info":{"id":"ssKcWW","date":"1655039481","viewed":215,"name":"Fractal Tower","username":"snolot","description":"The basic sdf come from Kali. this is a learning exercise  to understand how fractals works.","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"sdKcD1","parentname":"basic_sdf_template"},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"    float rBox( vec3 p, vec3 b, float r ){\n        return length(max(abs(p)-b,0.0))-r;\n    }\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nvec3 rotateX(vec3 pos, float alpha) {\nmat4 trans= mat4(1.0, 0.0, 0.0, 0.0, 0.0, cos(alpha), -sin(alpha), 0.0, 0.0, sin(alpha), cos(alpha), 0.0, 0.0, 0.0, 0.0, 1.0);\nreturn vec3(trans * vec4(pos, 1.0));\n}\n\nvec3 rotateY(vec3 pos, float alpha) {\nmat4 trans2= mat4(cos(alpha), 0.0, sin(alpha), 0.0, 0.0, 1.0, 0.0, 0.0,-sin(alpha), 0.0, cos(alpha), 0.0, 0.0, 0.0, 0.0, 1.0);\nreturn vec3(trans2 * vec4(pos, 1.0));\n}\n\n// https://iquilezles.org/articles/smin\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0);\n    return min(a, b) - 0.25*h*h/k;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0);\n    return max(a, b) + 0.25*h*h/k;\n}\n\nfloat box(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return max(q.x, max(q.y, q.z));\n}\n\nfloat box(vec2 p, vec2 b) {\n    vec2 q = abs(p) - b;\n    return max(q.x, q.y);\n}\n//Render\n\t#define DETAIL       1.5\n    #define MAX_STEPS    128\n    #define MAX_DEPTH    3\n    #define MAX_MARCH    30.\n\n//constants\n    #define PI  3.14159\n    #define TAU 6.28318\n\n//floor\n\t#define FLOOR\n\t#define FLOOR_HEIGHT 0.\n\n//Fractal\n\t#define FRACTAL\n    #define ITERATIONS 10\n    #define TRANS \t   vec3(0.036500000, -1.861300000, 0.036500000)\n    #define SCALE      2.043480000\n    #define RADIUS     0.349200000\n    #define JULIA      vec3(-0.5, -1.302800000, -0.5)\n\n\n//Palette\n\t#define PALETTE_BIAS        vec3(0.5)\n    #define PALETTE_AMPLITUDE   vec3(0.5)\n    #define PALETTE_FREQUENCIES vec3(.4,.2,.3)\n\t#define PALETTE_OFFSET      vec3(0,.25,.2)\n\t#define PALETTE_G_FREQUENCY 1.\n\t#define PALETTE_G_OFFSET    .1\n\n\n//Palette Creator\nvec3 getPaletteColor( in float t){\n    return PALETTE_BIAS + \n           PALETTE_AMPLITUDE*cos(TAU*(\n               PALETTE_G_FREQUENCY*PALETTE_FREQUENCIES*t + \n               PALETTE_OFFSET+PALETTE_G_OFFSET\n           ));\n}\n\n//rotates vector around another\nvec3 rotate(vec3 p, float angle, vec3 v){\n\tfloat c = cos(angle);\n\tvec3 s = sin(angle) * v;\n\tvec3 d =  (1.0 - c) * v;\n    return dot(p,d)*v + p*mat3(c,-s.z,s.y, s.z,c,-s.x, -s.y,s.x,c);\n}\n\n\nconst float R1 = abs(SCALE - 1.0);\nconst float R2 = pow(abs(SCALE), float(1-ITERATIONS));\n\nvec2 kaliBox(vec3 pos) {\n\tvec3 p = pos;\n    p = rotate(p, iTime *.2, vec3(0.0,1.,0.0));\n    \n    float orbit = 1e20;\n    float s = 2.;\n\t\n    vec3 TRANS2 = vec3(0.036500000, -1.861300000, 0.036500000);\n    \n    \n\tfor (int i=0; i<ITERATIONS; i++) {\n        orbit = min(orbit,dot(p,p));\n        \n       // p.y -= sin(iTime*.1)*.1;\n        //Fold\n\t\tp = abs(p);\n        \n        \n        //Offset\n        p += TRANS2;\n        \n        //Sphere Inversion\n\t\tfloat r2 = dot(p, p);\n        float k = clamp(max(RADIUS/r2, RADIUS), 0.0, 1.0);\n        \n\t\tp *= k;\n        s *= k;\n        \n        //Scaling\n\t\tp = p*SCALE/RADIUS;\n        s *= abs(SCALE)/RADIUS;\n        \n        //Julia\n        p += JULIA;\n        //s += 1.;\n\t\n\t}\n    \n    float dis = (length(p) - R1) / s - R2;\n\treturn vec2(dis,sqrt(orbit));\n}\n\n\nvec2 shape(vec3 p) {\n   \n    float a = box(p, vec3(.5)); // plastic box.\n    \n    p = -abs(p) + vec3(.5); // mirror space to save on distance evaluations\n    float ce = 0.01;\n\t// edges.\n    float b = box(p - vec3(.5, 0, 0), vec3(.5 + ce, ce, ce));\n    float c = box(p - vec3(0, 0, .5), vec3(ce, ce, .5 + ce));\n    float d = box(p - vec3(0, .5, 0), vec3(ce, .5 + ce, ce));\n    \n    vec2 s = vec2(a, 2.0); // 2.0 == material id for white plastic.\n    vec2 t = vec2(min(min(b, c), d), 3.0); // 1.0 == material id for metal.\n    \n    return s.x < t.x ? s : t;\n}\n\nvec2 map( in vec3 p ){\n    float distance = MAX_MARCH;\n    float closest= 0.0;\n    vec2 d = vec2(distance,  closest);\n    \n    #ifdef FLOOR\n        float floorDistance = p.y-FLOOR_HEIGHT;\n        distance = min(distance,floorDistance);\n        d = vec2(distance,  0.0);\n        \n    #endif\n    \n    \n    #ifdef FRACTAL\n        float fractalDistance = kaliBox(p).x;\n        distance = min(distance,fractalDistance);\n\n        d = d.x > distance ? vec2(distance,  3.) : d;\n\t#endif\n     //d.x = max(d.x,  -length(p) -.2);\n     \n    return d;\n}\n\n\nvec3 getColor(vec3 p){\n    float distance     = MAX_MARCH;\n    vec3  color        = vec3(1);\n\n    #ifdef FLOOR\n        float floorDistance = p.y-FLOOR_HEIGHT;\n        if(floorDistance<distance){\n            distance = floorDistance;\n            color    = vec3(.9);\n        }\n    #endif\n    \n    #ifdef FRACTAL\n        vec2  fractalInfo = kaliBox(p);\n        float fractalDistance = fractalInfo.x;\n        if(fractalDistance<distance){\n            distance = fractalDistance;\n            color    = color    = getPaletteColor(fractalInfo.y);\n        }\n\t#endif\n    return color;\n} \nvec2 intersect( in vec3 ro, in vec3 rd )\n{\n\t// `maxd` is the maximum distance after which we'll stop the\n    // raymarching. This means that if we haven't interesected\n    // with anything after 10.0 world units of iteration, we'll stop.\n    const float maxd = 50.0;\n    \n    // `h` is the temporary value that we'll use to store the\n    // distance to objects in the scene. We could initialize it at any\n    // value > 0.001 (the intersection threshold).\n\tfloat h          = 1.0;\n    float id = 1.0;\n    \n    // `t` will hold the final result of the raymarching, returning\n    // the distance marched on the ray before reaching an intersection.\n    float t          = 0.0;\n    \n    // The number of iterations is limited to 50. I guess this should\n    // be adjusted depending on the scene.\n    for( int i=0; i<150; i++ )\n    {\n        // We break if h is below the threshold (ie, we've nearly\n        // intersected a scene object), or that we've exceeded the\n        // marching distance.\n        if( h<0.0001 || t>maxd ) break;\n        // We get the distance between the current raymarched point \n\t\t// and the union of all objects in the scene. The value returned\n        // is the distance to the closest object in the scene.\n        vec2 v = map( ro+rd*t );\n\t    \n        h = v.x;\n        id = v.y;\n \t\t// We add that to the current walking distance. If at the next\n        // iteration map returns a value close to 0, it means we'll have\n        // intersected, otherwise we'll need to continue.\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n\t\n    return vec2(t, id);\n}\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep ).x );\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nfloat calcAO(in vec3 pos, in vec3 nor) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i < 5; i++) {\n        float hr = 0.01 + 0.12 * float(i) / 4.0;\n        vec3 aopos = nor * hr + pos;\n        float dd = map(aopos).x;\n        occ += -(dd - hr) * sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nvec3 tex3D(vec3 p, vec3 n, sampler2D s) {\n    vec3 m = pow(abs(n), vec3(10.0));\n    m /= dot(m, vec3(1));\n    \n    vec3 x = texture(s, p.yz).rgb;\n    vec3 y = texture(s, p.xz).rgb;\n    vec3 z = texture(s, p.xy).rgb;\n    \n    return m.x*x*x + m.y*y*y + m.z*z*z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0,2.05 - sin(iTime*.25) * 1.5, 2.);\n    //dir*=rotateY(iTime*0.5);eye*=rotateY(iTime*0.5);\n    vec3 color=vec3(0.0);\n    vec2 v = intersect(eye, dir);\n    float sdf = v.x;\n    float closest = v.y;\n    vec3 normal = calcNormal(eye+dir*sdf);\n    \n    \n    vec3 refl = reflect(dir, normal);\n    vec3 r = texture(iChannel0,refl).rgb;\n    float fre = pow( clamp( 1. + dot(normal,dir),0.0,1.0), 2. ); \n    \n    if(closest == 0.0 || sdf <= 0.0){\n        color =  vec3(1.3,.7,.4) * .5;//vec3(0.,0.,0.) ;\n    }\n    \n    if(closest == 1.0){\n        color =  vec3(.8, 1.,.3);\n    }\n    if(closest == 2.0){\n        color =  vec3(1.,.7,0.);\n    }\n    if(closest == 3.0){\n        vec3 p = eye+dir*sdf;\n        float ao = calcAO(p, normalize(normal));\n        //vec3 grunge = texture( iChannel1, fragCoord/iChannelResolution[1].xy + vec2(.7549,.5698)*float(iFrame) ).rgb;\n           //vec3 c = getColor(p);\n         //  vec3 c = tex3D(p, normal, iChannel1);\n        color =  vec3(1.3,.7,.4) * vec3(ao*4.) + fre -  r * .5;\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(color ,1.0);\n    \n    fragColor.rgb *= smoothstep( 1.5, 0.4, length(fragCoord.xy-iResolution.xy*.5)/length(iResolution.xy*.5) );\n    \n}","name":"Image","description":"","type":"image"}]}