{"ver":"0.1","info":{"id":"dttBzB","date":"1701540651","viewed":123,"name":"SDF Spheremy","username":"ZeroreZ","description":"first sdf project, thanks to Darko Supe","likes":10,"published":1,"flags":0,"usePreview":1,"tags":["sdf","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n\n#define MAX_DIST 100.\n#define MIN_DIST 0.0012\n\nfloat sdfSphere(vec3 c,float r, vec3 p)\n{\n    return distance(p,c)-r + texture(iChannel1, p.xy).r/(abs(sin(iTime)*40.));\n}\n\nfloat getDist(vec3 p)\n{\n    // Setup scene\n    return sdfSphere(vec3(0.), 0.8, p);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) //Основная функция RayMarching для расчета дистанции\n{\n    float dist = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 itPos = ro + rd * dist;\n        float itDist = getDist(itPos);\n        \n        dist += itDist;\n        \n        if (dist > MAX_DIST || dist < MIN_DIST)  \n            break;\n    }    \n    \n    return dist;\n}\nvec3 getNormal(vec3 point) // Получение нормали вектора\n{\n    vec2 epsylon = vec2(0.01,0.);\n    vec3 normal = normalize(vec3(getDist(point + epsylon.xyy),getDist(point + epsylon.yxy),getDist(point + epsylon.yyx)));\n    return normal; \n}\n\nfloat getLight(vec3 point)\n{\n    vec3 lightPos = vec3(sin(iTime*2.),3.,-2.3);\n    vec3 lightDir = normalize(point - lightPos); //Направление света относительно точки на поверхности сферы\n    \n    return -dot(getNormal(point), lightDir);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float focalDist = 0.6;\n    vec3 ro = vec3(0., 0., -1.5);\n    vec3 rd = vec3(uv.x, uv.y, focalDist);   \n    \n    vec3 col = vec3(0.);\n    \n    float dist = rayMarch(ro, rd);\n    if (dist < MAX_DIST)\n    {\n        col = vec3(0.5, 0.6, 0.6);\n        vec3 pointHit = ro + rd * dist;\n        col = vec3(0.5,0.6,0.6);\n        col *= vec3(getLight(pointHit)+ vec3(0.1));\n    }    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}