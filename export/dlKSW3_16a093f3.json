{"ver":"0.1","info":{"id":"dlKSW3","date":"1686428899","viewed":567,"name":"GM Shaders: Chromatic Motion","username":"Xor","description":"Written for my [url=https://mini.gmshaders.com]mini tutorial series[/url].","likes":27,"published":1,"flags":32,"usePreview":1,"tags":["postprocessing","tutorial","tut"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    \"Chromatic Motion\" by @XorDev\n    \n    An fun little technique to add color and motion blur\n    Works best with grayscale animations.\n    The concept is simple:\n    Set the red channel to the desired brightness\n    Set the GB channels to the RG of the last frame\n    This cycles the colors as the frames pass\n    \n    Note: Results depend on frame rate!\n*/\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    //Shader resolution for computing uv coordinates\n    vec2 res = iResolution.xy;\n    //Compute uv coordinates from frag coordinates\n    vec2 uv = fragCoord / res;\n\t\n    //Output Buf A results\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n    The concept is simple:\n    Set the red channel to the desired brightness\n    Set the GB channels to the RG of the last frame\n    This cycles the colors as the frames pass\n    \n    Additionally, I add some temporal noise for smoother transitions\n*/\n\n#define MOTION_NOISE 4.0\n//Try 0.0 also!\n\n//Simple macro for tracing circles\n#define CIRCLE(R,P) max(R*res.y - length(pix-res*.5+res*P), 0.0)\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord)\n{\n    //Shader resolution and pixel coordinates\n    vec2 res = iResolution.xy;\n    vec2 pix = fragCoord;\n    \n    //Time with added temporal noise\n    float noise = fract(cos(dot(pix,pix/res)+iTime)*4e3);\n    float time = iTime + iTimeDelta * noise * MOTION_NOISE;\n    \n    //Sample for background texturing (details aren't important here)\n    float gray = pow(texture(iChannel1,pix/res.y+cos(pix.yx/res+time)+time*vec2(1,4)).r,4.)*.8;\n    //Add 3 circles for example\n    gray += CIRCLE(.10, .4*cos(time*vec2(3.9,5)));\n    gray += CIRCLE(.07, .3*cos(time*vec2(3.7,4)));\n    gray += CIRCLE(.05, .2*sin(time*vec2(5.3,4)));\n    \n    \n    //Set the red channel and blend with last frame\n    fragColor = vec4(gray, texture(iChannel0, pix/res));\n    \n    //Other variants are possible here!\n\n    //Blue to red:\n    //fragColor = vec4(texture(iChannel0, pix/res).gb, gray, 1);\n    \n    //Green to magenta:\n    //fragColor = vec4(texture(iChannel0, pix/res).gg, gray, 1).rbga;\n}","name":"Buffer A","description":"","type":"buffer"}]}