{"ver":"0.1","info":{"id":"XddczM","date":"1519525010","viewed":208,"name":"Hopf Fibers","username":"Ebanflo","description":"For a much smoother version with interactivity and more in-depth explanation check out\n[url=http://ebencowley.com/resources/docs/projects/hopfFibers.html]my article about it[/url].","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","4d","tori"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*MATH!\n\nhttps://en.wikipedia.org/wiki/Hopf_fibration\n\nThe Hopf Fibration is a continuous surjective (onto) function from the unit 3-sphere to\nthe unit 2-sphere such that the preimage of every point on the 2-sphere is a circle on\nthe 3-sphere.\n\nIf we represent a point in 4D space as a pair of complex numbers: (z1, z2) and a point\nin 3d space as a complex number with a real number: (z0, x). The map is given by:\n\n(z1, z2) -> (2(z1)(z2)*, (z1)(z1)* - (z2)(z2)*)\n\nwhere I've used * to represent complex conjugation.\n\nHere's how we see that the preimage of any point is exactly a circle:\nThink of the orthogonal transformation v -> qvq^-1 for some vec3 v and unit quaternion q\nIf we write down the matrix representation for this transformation in terms of the\ncomponents of q we see that the image of (1,0,0) under this transformation is the Hopf\nmap applied to the unit quaternion! This means that the pre-image of p on the 2-sphere\nis all the quaternions which rotate (1,0,0) to p. We can construct a quaternion which\nrotates (1,0,0) directly to p and then pre-compose that quaternion with any quaternion\nrepresenting a rotation about the x-axis. The group of rotations about the x-axis is a \ncircle, so we see that every \"fiber\" is a circle. A special case must be considered for\nthe rotation to (-1,0,0), but it still works.\n\nCall the quaternion which rotates (1,0,0) directly to p q_p and the quaternion which\nrotates about the x-axis by angle t q_t. Then (q_p)(q_t) gives us the pre-image of p\nparametrized with respect to t.\n\nMy method for rendering the Hopf fibration is as follows:\nFor a point on the 2-sphere, compute three points on the pre-image and then \nstereographically project these points to get a triangle in 3D. Compute the orthocenter\nof each triangle and the radius of the circle that it defines and use this information\nto raymarch a torus with the given center and radius. The color of the torus is based on\nthe position of the corresponding point on the 2-sphere.\n\nA major problem with the Shader Toy implementation is that pre-image computation,\nstereographic projection, and orthocenter calculation are all performed for every torus\nfor every step of the ray. I tried to store all of this information in a buffer, but to\nno avail. This is why I'm not using the torus normals at all, its already very slow on\nmy machine.\n\nI also have a WebGL version that uses uniforms wo speed everything up, but I want to get\nrid of this stupid artifacting before I publish it on my website.\n\n*/\n#define thickness 0.03\n#define longitudinalSamps 1\n#define lattitudinalSamps 16\n#define steps 40\n#define far 20.0\n#define threshold 0.01\nconst float piT = 8.0*atan(1.0);\nconst float pi  = 0.5*piT;\nconst float pi2 = 0.5*pi;\nconst float isqrt2 = inversesqrt(2.0);\n\nstruct Line{vec3 o; vec3 d;};\n\nvec3 intersectLines(Line l1, Line l2){\n    vec3 C = l1.o + l1.d;\n    vec3 D = l2.o + l2.d;\n    vec3 g = D - C;\n    vec3 fcg = cross(l2.d, g);\n    vec3 fce = cross(l2.d, l1.d);\n    return C + sign(dot(fcg, fce))*length(fcg)*l1.d*inversesqrt(dot(fce,fce));}\n\nfloat sdTorus(vec3 p, float r){return length(vec2(length(p.xz) - r, p.y)) - thickness;}\n\nvec3 nTorus(vec3 pos, float r){\n    return normalize(pos*(dot(pos,pos)- thickness*thickness - r*r*vec3(1.0,1.0,-1.0)));}\n\nfloat sdSphere(vec3 p, vec3 c){return distance(p, c) - thickness;}\n\nvec3 r(vec3 v, vec2 r){//rodolphito's rotation\n    vec4 t = sin(vec4(r, r + pi2));\n    float g = dot(v.yz, t.yw);\n    return vec3(v.x * t.z - g * t.x,\n                v.y * t.w - v.z * t.y,\n                v.x * t.x + g * t.z);}\n\nvec3 unitVector(vec2 angles){\n    vec2 t1 = sin(angles.x + vec2(0, pi2));\n    vec2 t2 = sin(angles.y + vec2(0, pi2));\n    return vec3(t1.x*t2.y, t1.y*t2.y, t2.x);}\n\nmat3 rotateTo(vec3 v){\n    vec4 quat = vec4(0.0, v.z, -v.y, sqrt(1.0 + v.x));\n    return\n    mat3(\n      1.0 - (quat.y*quat.y + quat.z*quat.z), quat.w*quat.z, -quat.w*quat.y,\n      -quat.w*quat.z, 1.0 - quat.z*quat.z, quat.y*quat.z,\n      quat.w*quat.y, quat.y*quat.z, 1.0 - quat.y*quat.y);}\n\nvec3 stereoProj(vec4 v){return v.xyz/(1.0 - v.w);}\n\nvec4 getFiber(vec3 p, float t){\n    p.z++;\n    vec2 trig = sin(t + vec2(0, pi2));\n    return inversesqrt(2.0*p.z)*vec4(p.z*trig.y,\n                                     p.x*trig.x - p.y*trig.y,\n                                     p.x*trig.y + p.y*trig.x,\n                                     p.z*trig.x);}\n\nvec4 sdf(vec3 p){\n    float d = 9e9;\n    vec3 col;\n    for(int i = 0; i < longitudinalSamps; i++){\n        for(int j = 0; j < lattitudinalSamps; j++){\n            vec3 unit = unitVector(\n                vec2(float(i + 1)/float(longitudinalSamps)*piT,\n                     float(j + 1)/float(lattitudinalSamps + 1)*pi - pi2));\n            unit = r(unit, 0.1*iTime + (2.0*iMouse.xy - iResolution.xy)/iResolution.y);\n            vec3 v1 = stereoProj(getFiber(unit, 0.0));\n            vec3 v2 = stereoProj(getFiber(unit, pi2)) - v1;\n            vec3 v3 = stereoProj(getFiber(unit, pi)) - v1;\n            vec3 dir = normalize(cross(v2, v3));\n            vec3 center = intersectLines(Line(v1 + 0.5*v2, cross(dir, v2)),\n                                         Line(v1 + 0.5*v3, cross(dir, v3)));\n            float torus = sdTorus(rotateTo(dir)*p - center, distance(center, v1));\n            if(torus < d){\n                d = torus;\n                col = 0.5 + 0.5*unit;\n            }\n        }\n    }\n    return vec4(col, d);}\n\nvec3 raymarch(vec3 ro, vec3 rd){\n    float t = 0.0;\n    vec3 p = ro;\n    bool hit = false;\n    vec3 col;\n    for(int i = 0; i < steps; i++){\n        vec4 colAndDist = sdf(p);\n        if(colAndDist.w < threshold){\n            hit = true;\n            col = colAndDist.rgb;\n            break;\n        }\n        if(t > far) break;\n        float d = 0.5*colAndDist.w;\n        t += d;\n        p += d*rd;\n    }\n    if(hit) return col;\n    return vec3(0);}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    fragColor = vec4(0);\n    vec2 xy = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0,0,-5);\n    vec3 rd = normalize(vec3(xy, 2));\n    fragColor.rgb = raymarch(ro, rd);\n}","name":"Image","description":"","type":"image"}]}