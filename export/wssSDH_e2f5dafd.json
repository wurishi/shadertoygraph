{"ver":"0.1","info":{"id":"wssSDH","date":"1551218848","viewed":97,"name":"преломление, (дополнение №2)","username":"nirvanabc","description":"f","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define OBJECT_MAP_FUNCTION map1\n\n#define calcRecursion rec3 // use n rays levels (rays1 to rays6): total  RAY_COUNT = 2^n-1\n#define DIST_EPSILON 0.005\n\n#define ID_SKY 2.\n#define ID_FLOOR 1.\n#define ID_LIGHT 1.\n#define ID_GLASS_WALL 2.0\n#define ETA 0.9\n#define M_PI\t\t\t\t3.1416\n\n#define DENSITY_MIN 0.1\n#define DENSITY_MAX 0.1\n#define MATERIAL_COLOR vec3(0.5,0.8,1)*0.1\n#define AIR_COLOR vec3(0.5,0.8,1)*0.1\n\n#define SURFACE_COLOR vec3(0.8,0.3,0.7)\nvec3 LIGHT_DIR = normalize(vec3(-0.6,0.7,-0.3));\n\nstruct CP {\n    float dist;\n    vec3 normal;\n    float mat;\n    vec3 p;\n};\n    \n    \nstruct Ray {\n    vec3 rd;\n    CP cp;\n    vec3 col;\n    float share;\n    float eta;\n};\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec3 opU( vec3 d1, vec3 d2 )\n{\n   \n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 map1(in vec3 pos) {\n    vec3 res = vec3(sdTorus(pos.yxz-vec3(0.3,0.,-0.7),vec2(0.2,0.1)), ID_GLASS_WALL, ETA);\n    res.x =abs(res.x);\n   \n \treturn res;\n}\n\nvec3 map(in vec3 pos) {\n    vec3 res = vec3(sdPlane(pos), ID_FLOOR, 1.);\n\treturn opU(res, OBJECT_MAP_FUNCTION(pos));    \n}\n\n//-------------------------------------------------------------------------------\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n    float d = map(pos).x;\n    return normalize( vec3(\n\t    map(pos+eps.xyy).x - d,\n\t    map(pos+eps.yxy).x - d,\n\t    map(pos+eps.yyx).x - d)\n\t);\n}\n\n              \nCP findIntersection(vec3 p, vec3 rd) {\n     \n    float tmin = 0.0;\n    float tmax = 50.0;\n    \n\tfloat precis = DIST_EPSILON;\n    float t = tmin;\n    float eta = -1.;\n    vec3 res;\n    for( int i=0; i<50; i++ )\n    {\n\t  \tres = map(p+rd*t);\n        eta = res.z;\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n    }\n    \n    p+=rd*t;\n    // calculate normal in the father point to avoid artifacts\n    vec3 n = calcNormal(p-rd*(precis-res.x));\n    CP cp = CP(t, n, res.y, p);\n\n    return cp;\n}\n\nvec3 refractCaustic(vec3 p, vec3 rd, vec3 ld, float eta) {\n     vec3 cl = vec3(1);\n    for(int j = 0; j < 2; ++j) {\n\n        CP cp = findIntersection(p, rd);\n        if (length(cp.p) > 2.) {\n            break;\n        }\n        cl *= SURFACE_COLOR;\n        vec3 normal = sign(dot(rd, cp.normal))*cp.normal;\n        rd = refract(rd, -normal, eta);\n\n        p = cp.p;\n        eta = 1./eta;\n        p += normal*DIST_EPSILON*2.;\n    }\n     float d = clamp( dot( rd, ld ), 0.0, 1.0 );\n     return smoothstep(0.99, 1., d)*cl;\n}\n\nvec3 caustic(vec3 p,vec3 ld, Ray ray) {\n    vec3 VX = normalize(cross(ld, vec3(0,1,0)));\n\tvec3 VY = normalize(cross(ld, VX));     \n    vec3 c = vec3(0);\n    \n    const int N =3;\n    p += ray.cp.normal*DIST_EPSILON;\n   \n    for(int i = 0; i < N;++i) {\n        \n        float n1 = 0.;\n        float n2 = 0.;\n\n        vec3 rd = ld+(VX*(n1)+VY*(n2))*0.41;\n       // rd = ld;\n        rd = normalize(rd);\n\n \t\tvec3 cl = refractCaustic(p, rd, ld, ray.eta);\n        \n      \tc += cl* dot(rd,ray.cp.normal);\n    }\n    return c*3./float(N);\n}\n\nvec3 getFloorColor(in Ray ray) {\n    \n    vec3 col = vec3(0);\n    vec3 pos = ray.cp.p;\n    vec3 ref = reflect( ray.rd, ray.cp.normal );\n    \n    float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n    col = 0.4 + 0.1*f*vec3(1.0);\n\n    float dif = clamp( dot( ray.cp.normal, LIGHT_DIR ), 0.0, 1.0 );\n    vec3 brdf = vec3(0.0);\n    brdf += caustic(pos, LIGHT_DIR, ray);\n    brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n    col = col*brdf;\n    col *= (ID_GLASS_WALL-ray.cp.mat);\n\n    return col;\n}\n    \n\nvec3 getColor(in Ray ray) {\n\n    vec3 p = ray.cp.p ;\n    vec3 c1 = ray.col * SURFACE_COLOR;\n    vec3 c2 = getFloorColor(ray);\n    return mix(c2, c1, ray.cp.mat - ID_FLOOR);\n\n}    \n\nvec3 getRayColor(Ray ray) {\n\n\n    float d = mix(DENSITY_MIN, DENSITY_MAX, (ray.eta - ETA)/(1./ETA-ETA));\n    vec3 matColor = mix(AIR_COLOR, MATERIAL_COLOR, (ray.eta - ETA)/(1./ETA-ETA));\n    vec3 col = getColor(ray);\n\n    float q = exp(-d*ray.cp.dist);\n    col = col*q+matColor*(1.-q);\n    return col*ray.share;\n}\n\nvoid getRays(inout Ray ray, out Ray r1, out Ray r2) {\n     vec3 p = ray.cp.p;\n    float cs = dot(ray.cp.normal, ray.rd);\n    float fresnel = 1.0-abs(cs);\n    float r = ray.cp.mat - ID_FLOOR;\n     vec3 normal = sign(cs)*ray.cp.normal;\n    vec3 refr = refract(ray.rd, -normal, ray.eta);\n    vec3 refl = reflect(ray.rd, ray.cp.normal);\n    vec3 z = normal*DIST_EPSILON*2.;\n    p += z;\n    r1 = Ray(refr, findIntersection(p, refr),  vec3(0),(1.-fresnel)*r, 1./ray.eta);\n    p -= 2.*z;\n    r2 = Ray( refl, findIntersection(p, refl), vec3(0),r*fresnel, ray.eta);\n}\n\nvoid rec1(inout Ray ray) {\n    ray.col += getRayColor(ray);\n}\n\n\nvoid rec2(inout Ray ray) {\n\t\n    Ray r1,r2;\n    getRays(ray, r1, r2);\n\n    ray.col += getRayColor(r1);\n    ray.col += getRayColor(r2);\n}\n\nvoid rec3(inout Ray ray) {\n    \n    Ray r1,r2;\n    getRays(ray, r1, r2);\n    \n    rec2(r1);\n    ray.col += getRayColor(r1);\n    rec2(r2);\n    ray.col += getRayColor(r2);\n}\n\n\nvec3 castRay(vec3 p, vec3 rd) {\n    CP cp = findIntersection(p, rd);\n   \n    Ray ray = Ray( rd, cp, vec3(0), 1., ETA);\n    calcRecursion(ray);\n    ray.col = getRayColor(ray);\n\treturn ray.col;\n    \n}\n\nvec3 render(vec3 p, vec3 rd) {\n    vec3 col= castRay(p, rd);\n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy-0.35;\n\n    uv.x*=iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    // this strange construction is used to define initial view angle\n    mo = mix(vec2(0.16,0.3),mo, sign(mo.x+mo.y));\n\n\tmo.y *=2.57;\n    float time =0.;\n    float R = 4.3;\n    \n    float Y = sin(mo.y);\n    float X = cos(mo.y);\n\tvec3 ro = vec3(cos(mo.x)*X, Y, X*sin(mo.x))*R;\n\tvec3 ta = vec3( 0,0.4,0);\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0. );\n   \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(uv.xy,2.5) );\n    \n    vec3 c = render(ro, rd);\n\n\tfragColor = vec4(c, 1);\n}","name":"Image","description":"","type":"image"}]}