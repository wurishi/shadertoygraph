{"ver":"0.1","info":{"id":"3lj3WG","date":"1560951420","viewed":1030,"name":"Volumetric Lighting Experiment","username":"SSHantaram","description":"Volumetric absorption and scattering","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","volume","lighting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.01;\nconst float VOLUME_STEP = 0.03;\nconst float VOLUME_STEP_LIGHT = 0.1;\nconst float VOLUME_DENSITY = 0.04;\nconst float LIGHT_INTESITY = 0.03;\n\n\n// 3D hash function\nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// 3D precedural noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    // interpolate between hashes of adjacent grid points\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// 3D noise layered in several octaves\nfloat layeredNoise(in vec3 x) {\n    x += vec3(10.0, 5.0, 6.0);\n    return 0.6*noise(x*5.0) + 0.4*noise(x*10.0) + 0.2*noise(x*16.0) - 0.2;\n}\n\n// singed distance function of the y=0 plane\nfloat planeSDF(vec3 p) {\n    return p.y;\n}\n\nfloat sphereSDF(vec3 p, vec3 center, float r) {\n    return length(center - p) - r;\n}\n\nfloat boxSDF(vec3 p, vec3 size) {\n    vec3 d = abs(p) - (size / 2.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n// singed distance function to enire scene\nfloat sceneSDF(vec3 samplePoint) {\n   \t//float sphere = sphereSDF(samplePoint, vec3(0.0, 0.0, 0.0), 1.0);\n    float box = boxSDF(samplePoint, vec3(1.5, 1.0, 1.5));\n    //return sphere;\n    return box;\n}\n\nfloat sampleVolume(vec3 p, float densityMultiplier) {\n    return layeredNoise(p)*densityMultiplier;\n}\n\n// integrate density along ray\nfloat marchDensity(vec3 startPoint, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float density = 0.0;\n    float d;\n    vec3 samplePoint;\n    \n    while (depth < end) {\n        samplePoint = startPoint + depth * marchingDirection;\n    \td = sceneSDF(samplePoint);\n        // outside volume\n        if (d > EPSILON) {\n            depth += d;\n        }\n        // inside volume\n        else {\n            // sum desity values\n         \tdensity += sampleVolume(samplePoint, VOLUME_DENSITY)*min(-d, VOLUME_STEP_LIGHT);\n            depth += VOLUME_STEP_LIGHT;\n        }\n        // opaque: stop early\n        if (density >= 1.0) return 1.0;\n    }\n    return density;\n}\n\nfloat volumeAbsorption(float lightIntensity, float acumulatedDensityToPoint) {\n    return max(0.0, lightIntensity - acumulatedDensityToPoint);\n}\n\n// integrate illumination along ray\nfloat marchVolumetricLighting(vec3 eye, vec3 marchingDirection, vec3 lightPos, float start, float end) {\n    float depth = start;\n    float accumulatedDensity = 0.0;\n    float brightness = 0.0;\n    float d;\n    vec3 samplePoint;\n    \n    while (depth < end) {\n        samplePoint = eye + depth * marchingDirection;\n    \td = sceneSDF(samplePoint);\n        // outside volume\n        if (d > EPSILON) {\n            depth += d;\n        }\n        // inside volume\n        else {\n            float densityAtPosition = sampleVolume(samplePoint, VOLUME_DENSITY);\n            // integrated density between eye and point\n            accumulatedDensity += densityAtPosition*min(-d, VOLUME_STEP);\n            // get integrated density between point and light\n            vec3 lightRay = vec3(lightPos - samplePoint);\n            float acumulatedDensityToLight = marchDensity(samplePoint, normalize(lightRay), start, end);\n            // point brightness is dimmed by volume between eye and point\n            float pointBrightness = volumeAbsorption(LIGHT_INTESITY, acumulatedDensityToLight);\n            // sum up brightness values along ray\n            brightness += volumeAbsorption(pointBrightness, accumulatedDensity);\n            depth += VOLUME_STEP;\n        }\n        if (brightness >= 1.0) return 1.0;\n    }\n    return brightness;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n// estimate normal by aproximatind the first deriviative of the sceneSDF\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n// generate camera transform\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n   \t//vec3 eye = vec3(0.0, -5.0, -6.0);\n    vec3 eye = vec3(6.0*cos(iTime*0.1), -3.0, 6.0*sin(iTime*0.1));\n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = viewToWorld * viewDir;\n    vec3 lightPos = vec3(1.2*cos(iTime), 1.0, 1.2*sin(iTime));\n    \n    float brightness = marchVolumetricLighting(eye, worldDir, lightPos, MIN_DIST, MAX_DIST);\n\n    \n    vec3 color = vec3(1.0, 1.0, 1.0)*brightness;\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}