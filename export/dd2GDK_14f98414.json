{"ver":"0.1","info":{"id":"dd2GDK","date":"1668190650","viewed":356,"name":"Frog eyes","username":"Alpaga","description":"Change focus point using mouse.","likes":33,"published":1,"flags":32,"usePreview":1,"tags":["raymarching","eye","frog"],"hasliked":0,"parentid":"cdS3Rt","parentname":"Frog eye"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Cheap depth of field.\n// Blur the image, using a dispersion factor depending on the depth.\n\n//const float blur[5] = float[](.0625,.25,.375,.25,.0625);\nconst float blur[7] = float[](.006,.061,.242,.383,.242,.061,.006);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec4 tex = texture(iChannel0,uv);\n    float depth = tex.a;\n    \n    // Depth where the focus is.\n    float focusDepth = 4.9;\n    if(iMouse.z>0.) {\n        focusDepth = texture(iChannel0,iMouse.xy/iResolution.xy).a;\n    }\n    \n    // Dispersion factor.\n    float dispersion = (1.-exp(-abs(depth-focusDepth)))*iResolution.y/200.;\n    \n    vec3 color = vec3(0);\n    \n    // Blur\n    int k=0,l;\n    for(float i=-3.; i<=3.; i++) {\n        l = 0;\n        for(float j=-3.; j<=3.; j++) {\n            vec2 p = (fragCoord + dispersion*vec2(i,j))/iResolution.xy;\n            color += blur[k]*blur[l]*texture(iChannel0, p).rgb;\n            l++;\n        }\n        k++;\n    }\n    \n    // Vignette\n    uv *=  1. - uv.yx;\n    color *= pow(uv.x*uv.y * 15.0, 0.25);\n    \n    // Gamma\n    color = pow(color,vec3(1./2.2));\n        \n    fragColor = vec4(color,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Voronoise texture of the frog, precomputed for efficiency.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = fragCoord/iResolution.xy;\n    fragColor = vec4(.5*pow(1.-voronoise(p,50.),2.));\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Uncomment if your machine is powerful enough.\n\n#define SHADOWS\n//#define AA\n\nconst float fov = 40.0;\n\nconst int EYE = 0;\nconst int BODY = 1;\n\nstruct Material {\n    vec3 albedo;\n    float specular;\n};\n\nvec3 ambient = vec3(0.1);\nvec3 lightDirection = normalize(vec3(3,5,4));\nconst vec3 lightCol = vec3(1,1,.3);\n\nvec2 delta = vec2(0.0,0.001);\n\nfloat time;\n\n// Triplanar or boxmapping\n// From iq\n// https://www.shadertoy.com/view/MtsGWH\nfloat boxmap(in vec3 p, in vec3 n, in float k )\n{\n    // project+fetch\n\tfloat x = texture(iChannel1, p.yz).r;\n\tfloat y = texture(iChannel1, p.zx).r;\n\tfloat z = texture(iChannel1, p.xy).r;\n    \n    // and blend\n    vec3 m = pow( abs(n), vec3(k) );\n\treturn (x*m.x + y*m.y + z*m.z) / (m.x + m.y + m.z);\n}\n\n// Bumps on the frog's skin\nfloat bumps(vec3 p, vec3 n) {\n    return boxmap(.2*p,n,5.);\n}\n\nfloat halfSpace(vec3 p, vec3 a, vec3 n) {\n    return dot(p-a-.7*n,n);\n}\n\n// *** Signed distance fields ***\n\n// Eye = sphere\nfloat sdEye(vec3 p) {\n    p.xz -= 2.12;\n    return length(p)-1.;\n}\n\n// Body without bumps\nfloat sdPlainBody(vec3 p) {\n   // Orbit: smooth difference of 2 spheres\n    vec3 q = p;\n    q.xz -= 2.12;\n    q.xz *= mat2(.7,-.7,.7,.7);\n    float orbit = smin(length(q)-1.1, 1.-length(q-vec3(0,0,1)),-.3);\n\n    // Head: smoothmax of several halfspaces\n    float k = -.5;\n    // Top\n    float head = halfSpace(p,vec3(1,-.3,0),vec3(.1,.8,0));\n    // Top behind\n    head = smin(head,halfSpace(p,vec3(1,.2,0),vec3(-.3,.6,0)),k);\n    // Side\n    head = smin(head,halfSpace(p,vec3(0,0,3),vec3(.3,.1,.5)),k);\n    // Front\n    head = smin(head,halfSpace(p,vec3(4.3,0,0),vec3(.7,.2,0)),k);\n    // Bottom\n    head = smin(head,halfSpace(p,vec3(0,-2.3+.5*(p.y+1.5),0),vec3(.2,-.6,0)),-.3);\n    \n    // Inflating neck\n    head = smin(head,length((p-vec3(-1,-2.,0))*vec3(.2,1,.2))-.03*pow(1.+.5*cos(5.*iTime),4.),1.);\n    \n    // Mouth\n    head = smin(head, smin(head,abs(halfSpace(p,vec3(0,-2.,0),vec3(.2,-.6,0)))-.0,-.3)-.1,.1);\n    head = smin(head,-abs(halfSpace(p,vec3(0,-2.,0),vec3(.2,-.6,0))),-.1);\n    \n    // Nostrils\n    head = smin(head,length(p-vec3(4.3,-.35,.65))-.12,.2);\n    head = smin(head,.08-length(p-vec3(4.3,-.35,.75)),-.1);\n\n    // Merge head and orbit\n    return smin(head, orbit, .2);\n}\n\n// Body with bumps: sdPlainBody + bumps\nfloat sdBody(vec3 p) {\n    // Compute distance and normal to plain body\n    float d = sdPlainBody(p);\n    vec3 n = normalize(vec3(\n        sdPlainBody(p+delta.yxx),\n        sdPlainBody(p+delta.xyx),\n        sdPlainBody(p+delta.xxy))-d);\n    \n    // Compute bumps, using the normal\n    float no = .01*bumps(p,n);\n    \n    // \"Add\" the bumps\n    return d - no;\n}\n\n// Pupil opening depending on time\nfloat pupil() {\n    float t = mod(iTime,5.);\n    return .1+.1*(smoothstep(1.,1.5,t)-smoothstep(3.,3.5,t));\n}\n\n// Iris\nfloat sdIris(vec3 p) {\n    p.z = abs(p.z);\n\n    p.xz -= 2.12;\n    p.xz *= mat2(.7,-.7,.7,.7);\n\n    vec2 r = p.xy;\n    r.x = abs(r.x)+pupil()+.02*noise(10.*p.xy);\n    float d = length(r*vec2(1.4,1));\n    float l = length(p);\n    return min(l-.68,smin(l-.7,.4-d,-.07));\n}\nfloat sd(vec3 p, out int id) {\n    float d,minD = 1e6;\n    vec2 pos,dir;\n    int tmp;\n\n    p.z = abs(p.z);\n//        p.y -= .003*pow(1.+.5*cos(5.*iTime),4.);\n\n    // Eye\n    d = sdEye(p);\n    if(d<minD) {\n        id = EYE;\n        minD = d;\n    }\n    \n    // Body\n    d = sdBody(p);\n    if(d<minD) {\n        id = BODY;\n        minD = d;\n    }\n   \n    return minD;\n}\n\n// Smoothly sets col to target if l>a, smoothness controlled by s.\nvoid setColor(inout vec3 col, float l, float a, float s, vec3 target) {\n    col = mix(col, target, smoothstep(a-s,a+s,l));\n}\nMaterial irisMaterial(vec3 p) {\n    vec3 alb;\n    float spe;\n    \n    // Symmetry\n    p.z = abs(p.z);\n    \n    // To eye center\n    p.xz -= 2.12;\n    p.xz *= mat2(.7,-.7,.7,.7);\n\n    float a = atan(p.y,p.x);\n    float l = length(p.xy);\n\n    vec2 q = vec2(a,l);\n\n    vec2 r = p.xy;\n    r.x = abs(r.x) + pupil() + .02*noise(10.*p.xy);;\n    // Measure how far we are from pupil\n    float d = length(r*vec2(1.4,1));\n\n    // Ratio between red and yellow\n    float x = pow(1.3*fbm(20.*vec2(1,.75)*q + vec2(0,5.*pupil())),8.);\n    // More red inside\n    x = smoothstep(.3,.9,d)*x;\n    // More red outside\n    x = smoothstep(.8,.6,l)*x;\n\n    vec3 col = mix(vec3(1,0,0),vec3(1,1,0),x);\n\n    alb = vec3(0);\n    setColor(alb,d,.42,.01,col);\n    setColor(alb,l,.67,.05,vec3(0));\n\n    spe = .1*step(.4,d);\n            \n    return Material(alb,spe);\n}\nMaterial bodyMaterial(vec3 p) {\n    vec3 alb;\n    float spe = .1;\n\n    p.z = abs(p.z);\n\n    // Green modulated by bumps\n    float d = sdPlainBody(p);\n    vec3 nor = normalize(vec3(\n        sdPlainBody(p+delta.yxx),\n        sdPlainBody(p+delta.xyx),\n        sdPlainBody(p+delta.xxy))-d);\n\n    float n = .5+.5*bumps(p,nor);\n    vec3 green = vec3(.4*n,n,.1*n);\n\n    vec3 q = p;\n    q.xz -= 2.12;\n    // Distance to eye center\n    float l = length(q);\n\n    // Circles around eye\n    alb = vec3(0.2);\n    setColor(alb, l, 1.02, .02, vec3(1));\n    setColor(alb, l, 1.04, .02, green);\n\n    // Darker in nostrils\n    setColor(alb,.1,length(p-vec3(4.3,-.35,.75)),.005,.8*green);\n\n    // Yellowish neck\n    float x = halfSpace(p,vec3(0,-2.,0),vec3(.2,-.6,0));\n    setColor(alb,x,0.,.01,vec3(1,.8,.5));\n        \n    return Material(alb,spe);\n}\n\nvec3 normal(vec3 p) {\n    int id;\n    float d = sd(p,id);\n    return normalize(vec3(\n        sd(p+delta.yxx,id),\n        sd(p+delta.xyx,id),\n        sd(p+delta.xxy,id))-d);\n}\nvec3 normalIris(vec3 p) {\n    float d = sdIris(p);\n    return normalize(vec3(\n        sdIris(p+delta.yxx),\n        sdIris(p+delta.xyx),\n        sdIris(p+delta.xxy))-d);\n}\nfloat march(vec3 start, vec3 dir, out int id) {\n\tfloat total = 0.0, d = 1.0;\n    float epsilon = 0.5/iResolution.y;\n    int i=0;\n    for(; i<100; i++) {\n        if(d<epsilon*total || total>30.) break;\n        d = sd(start + total*dir,id);\n        total += d;\n    }\n    if(total>30. || i==100) id = -100;\n    return total;\n}\nfloat marchIris(vec3 start, vec3 dir) {\n\tfloat total = 0.0, d = 1.0;\n    float epsilon = 0.5/iResolution.y;\n    int i=0;\n    for(; i<100; i++) {\n        if(d<epsilon*total || total>30.) break;\n        d = sdIris(start + total*dir);\n        total += d;\n    }\n    return total;\n}\n\nfloat lightMarch(vec3 start, vec3 dir) {\n\tfloat d = 1.0, total = 0.0;\n    float epsilon = 0.5/iResolution.y;\n    float minD = 1000.0;\n    int id;\n    for(int i=0; i<100; i++) {\n        if(d<epsilon*total || total>5.) break;\n        d = sd(start + total*dir, id);\n        total += d;\n        minD = min(minD,d);\n    }\n    return minD;\n}\nfloat shadow(vec3 p, vec3 toLight) {\n    float minD = lightMarch(p+0.05*toLight, toLight);\n    return smoothstep(0.0,0.04,minD);\n}\nvec3 environment(vec3 dir) {\n    dir.y +=.25;\n    const float a = 1., ca = cos(a), sa = sin(a);\n    const mat2 rot = mat2(ca,-sa,sa,ca);\n    dir.xz *= rot;//mat2(.6,-.8,.8,.6);\n    vec3 env = texture(iChannel0,dir).rgb;\n    return pow(env, vec3(2.2));// Gamma\n}\n\nvec4 rayColor(vec3 start, vec3 dir) {\n    vec3 color = vec3(0);\n    float depth;\n    \n    int id;\n    \n    float d = march(start, dir, id);\n    depth = d;\n    \n    if(id == -100) {//No ray intersection\n        vec3 env = environment(dir);\n        return vec4(env,10.);\n    } else if(id == EYE) {\n        vec3 p = start + d * dir;\n\n        vec3 n = normal(p);\n        \n        // Specular\n        vec3 h = normalize(lightDirection-dir);\n        float spec = pow(max(dot(h,n),0.0), 300.0);\n        color = spec*lightCol;\n        \n        // Reflection of environment\n        vec3 ref = reflect(dir, n);\n        ref.xz *= mat2(.6,-.8,.8,.6);\n        \n        vec3 env = environment(ref);\n        color += .12 * env;\n\n        // Iris\n        dir = refract(dir,n,.7);\n        \n        d = marchIris(p, dir);\n        p += d*dir;\n        \n        n = normalIris(p);\n        Material mat = irisMaterial(p);\n\n        color += ambient*mat.albedo;\n\n        // Diffuse\n        vec3 diff = mat.albedo * max(dot(lightDirection, n), 0.0);\n        // Specular\n        h = normalize(lightDirection-dir);\n        spec = 10.*mat.specular * pow(max(dot(h,n),0.0), 300.0);\n\n        color += (diff + spec)*lightCol;\n    \n    } else { // Body\n    \n        vec3 p = start + d * dir;\n\n        vec3 normal = normal(p);\n        Material mat = bodyMaterial(p);\n\n        color += ambient*mat.albedo;\n\n        // Diffuse\n        vec3 diff = mat.albedo * max(dot(lightDirection, normal), 0.0);\n        // Specular\n        vec3 h = normalize(lightDirection-dir);\n        float spec = 10.*mat.specular * pow(max(dot(h,normal),0.0), 300.0);\n\n        #ifdef SHADOWS\n        // Shadow\n        float sh = shadow(p, lightDirection);\n        #else\n        float sh = 1.;\n        #endif\n            \n        color += sh*(diff + spec)*lightCol;\n\n        // Reflection of environment\n        vec3 ref = reflect(dir, normal);\n        \n        vec3 env = environment(ref);\n        \n        #ifdef SHADOWS\n        // Shadow\n        sh = shadow(p, ref);\n        #else\n        sh = 1.;\n        #endif\n        \n        color += sh * vec3(mat.specular) * env;\n    }\n    return vec4(color,depth);\n}\n\nmat3 setupCamera(vec3 cam, vec3 center, vec3 up) {\n \tvec3 w = normalize(cam-center);\n    vec3 u = normalize(cross(up, w));\n    vec3 v = cross(w, u);\n    \n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    time = .8;//1*iTime;\n    lightDirection = normalize(vec3(cos(time),sin(time),.1));\n    \n    vec3 center = vec3(2.,-.7,0);\n    vec3 cam = vec3(6.8,.3,4.8);\n\n    // Slow camera motion\n    cam.x += .2*cos(.1*iTime);\n    \n    // A cheap way of moving the frog vertically\n    cam.y -= .003*pow(1.+.5*cos(5.*iTime),4.);\n    center.y -= .003*pow(1.+.5*cos(5.*iTime),4.);\n    \n    mat3 m = setupCamera(cam, center, vec3(0,1,0));\n    \n    vec4 color = vec4(0.0);\n\n    vec2 uv;\n    #ifdef AA\n    for(float i=-0.25; i<0.5; i+=0.5) {\n        for(float j=-0.25; j<0.5; j+=0.5) {\n            uv = 2.0*(fragCoord + vec2(i,j) - 0.5 * iResolution.xy)/iResolution.y;\n            vec3 pix = vec3(tan(0.5*fov*0.01745)*uv,-1.0);\n    \n            vec3 dir = normalize(m*pix);\n    \n            color += rayColor(cam, dir);\n        }\n    }\n    color /= 4.0;\n    #else\n    uv = 2.0*(fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    vec3 pix = vec3(tan(0.5*fov*0.01745)*uv,-1.0);\n    vec3 dir = normalize(m*pix);\n\n    color = rayColor(cam, dir);\n    #endif\n        \n    fragColor = color;\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Hash functions from Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Fbm for the eye\nfloat noise(vec2 p) {\n    vec2 fl = floor(p);\n    vec2 fr = p-fl;\n    \n    return mix(\n        mix(hash12(fl),hash12(fl+vec2(1,0)),fr.x),\n        mix(hash12(fl+vec2(0,1)),hash12(fl+vec2(1,1)),fr.x),fr.y);\n}\nfloat fbm(vec2 p) {\n    float h = 0., f = 1., a = 1.;\n    for(int i=0; i<4; i++) {\n        h += a*noise(f*p);\n        f *= 2.5;\n        a *= .5;\n    }\n    return .5*h;\n}\n\n// Seamless periodic voronoise, with period vec2(a,a).\nfloat voronoise(vec2 p, float a) {\n    p *= a;\n    p = mod(p, a);\n    vec2 fl = floor(p);\n    \n    float d = 1e6;\n    for(float i=-1.; i<=1.; i++) {\n        for(float j=-1.; j<=1.; j++) {\n            vec2 q = fl+vec2(i,j);;\n            q += hash22(mod(q,a));\n            d = min(d,length(p-q));\n        }\n    }\n    return d;\n}\n\n// Taken from vgs\n// https://www.shadertoy.com/view/Ml3Gz8\n// Polynomial smooth min (for copying and pasting into your shaders)\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n","name":"Common","description":"","type":"common"}]}