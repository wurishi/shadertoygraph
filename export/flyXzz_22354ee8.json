{"ver":"0.1","info":{"id":"flyXzz","date":"1640057954","viewed":340,"name":"dda voxel world","username":"wigglewiggle","description":"my first attempt at voxel raytracing using the dda algorithm in 3d","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["none"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nmove with wasd look with arrows\nspace and shift to go up and down\n\n*/\nconst int viewDistance=350;\nconst float blockSize=20.0;\nconst int reflectionBounces=0;\nfloat hillsAtSpot(in float x,in float y){\nreturn (sin(x/10.0)+cos(y/10.0)+sin((y)/17.0)+cos((x)/15.0))*5.0;\n}\nvec3 skyColor=vec3(0,0.1,1);\nvec4[4] colors=vec4[](vec4(0.8,0.9,1,0.0),vec4(0.9,0.9,0.9,0.0),vec4(0.6,1,0.6,0.0),vec4(1,1,1,0.0));\n\n\n\nint gridSpot(in vec3 checkSpot){\nint a=0;\n    \n    if(hillsAtSpot(checkSpot.x/3.0,checkSpot.z/3.0)*5.0>=checkSpot.y||checkSpot.y<=0.0){\n    if(checkSpot.y==0.0)\n    {\n    a=1;\n        if(mod(floor(checkSpot.x/5.0)+mod(floor(checkSpot.z/5.0),2.0),2.0)==0.0){\n    a=4;//1\n    }else{\n    a=4;}\n    }else\n    if(mod(checkSpot.x,3.0)==0.0||mod(checkSpot.z,5.0)==0.0){\n    a=4;//3\n    }else\n    if(mod(checkSpot.z,2.0)==0.0||mod(checkSpot.z,2.0)==0.0){\n    a=4;\n    }else\n    if(mod(checkSpot.y,2.0)==0.0){\n    a=0;//2\n    }else{\n    a=4;//3\n     }\n    }else if(checkSpot.y==15.0&&abs(mod(checkSpot.x,4.0)-mod(checkSpot.z,8.0))<=1.0&&mod(checkSpot.z,16.0)<=8.0&&mod(checkSpot.x,16.0)<=8.0){\n    a=1;//1\n    }else if((abs(checkSpot.x)>=15.0||abs(checkSpot.z)>=15.0)&&checkSpot.y<=10.0){\n    if(mod(checkSpot.y,2.0)==0.0){\n    a=0;//1\n    }else{\n    a=0;//4 \n    }\n    }else{\n    a=0;\n    }\n    if(checkSpot.y==0.0)\n    {\n        a=1;\n    }\n    return a;\n}\n\nvec3 normalizeVector(vec3 inputVector){\nfloat d=sqrt(inputVector.x*inputVector.x+inputVector.y*inputVector.y+inputVector.z*inputVector.z);\nvec3 outputVector=vec3(inputVector.x/d,inputVector.y/d,inputVector.z/d);\nreturn outputVector;\n}\n\n\n//x=1 means it hit y=x hit spot z=y hit spot w=z hit spot\nvec4[3] raycast3d(vec3 inputPos, vec3 inputDir, int inputLength){\n    float x=inputPos.x/blockSize;\n    float y=inputPos.y/blockSize;\n    float z=inputPos.z/blockSize;\n\n    float dx=inputDir.x; \n    float dy=inputDir.y;\n    float dz=inputDir.z;\n    float c=sqrt(dx*dx+dy*dy+dz*dz);\n    \n    float sx=abs(1.0/dx);\n    float sy=abs(1.0/dy);\n    float sz=abs(1.0/dz);\n\n    vec3 stepDir=vec3(0,0,0);  \n    float lengthX=0.0, lengthY=0.0, lengthZ=0.0;\n    vec3 blockOn=vec3(floor(x),floor(y),floor(z));\n    vec3 side=vec3(0,0,0);\n    float travelDist=0.0;\n    \n    \n    bool hit=false;\n    //starting distances\n    {\n    if(inputDir.x<0.0){\n        stepDir.x=-1.0;\n        lengthX=(x-floor(x))*sx;\n    }else{\n        stepDir.x=1.0;\n        lengthX=(floor(x+1.0)-x)*sx;\n    }\n    if(inputDir.y<0.0){\n        stepDir.y=-1.0;\n        lengthY=(y-floor(y))*sy;\n    }else{\n        stepDir.y=1.0;\n        lengthY=(floor(y+1.0)-y)*sy;\n    }\n    if(inputDir.z<0.0){\n        stepDir.z=-1.0;\n        lengthZ=(z-floor(z))*sz;\n    }else{\n        stepDir.z=1.0;\n        lengthZ=(floor(z+1.0)-z)*sz;\n    }\n    }\n    \n    \n    vec3 hitSpot=vec3((inputPos.x+inputDir.x*travelDist*blockSize),(inputPos.y+inputDir.y*travelDist*blockSize),(inputPos.z+inputDir.z*travelDist*blockSize));\n    for(int i=0;i<inputLength;i++){\n      \n        if(lengthX<lengthY){\n            if(lengthX<lengthZ){\n            blockOn.x+=stepDir.x;\n            travelDist=lengthX;\n            lengthX+=sx;\n            side=vec3(-1,1,1);\n            }else{\n            blockOn.z+=stepDir.z;\n            travelDist=lengthZ;\n            lengthZ+=sz;\n            side=vec3(1,1,-1);\n            }\n        }else{\n            if(lengthY<lengthZ){\n                blockOn.y+=stepDir.y;\n            travelDist=lengthY;\n            lengthY+=sy;\n            side=vec3(1,-1,1);\n        }else{\n            blockOn.z+=stepDir.z;\n            travelDist=lengthZ;\n            lengthZ+=sz;\n            side=vec3(1,1,-1);\n                \n            }\n        }\n        if(gridSpot(blockOn)>=1){\n            hit=true;\n            i=inputLength+10;\n              hitSpot=vec3((inputPos.x+inputDir.x*travelDist*blockSize),(inputPos.y+inputDir.y*travelDist*blockSize),(inputPos.z+inputDir.z*travelDist*blockSize));\n       \n        }\n   \n    }\n    int ahit=0;\n    if(hit){\n    ahit=1;\n    }\n    vec4[3] outputVal=vec4[](vec4(ahit,blockOn),vec4(travelDist,hitSpot),vec4(side,0));\n    return outputVal;//vec4(ahit,blockOn);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n// skyColor=vec3(abs(sin(iTime/10.0+1.0)),0.1,abs(sin(iTime/10.0)));\n   \n     vec2 rot=texelFetch( iChannel1, ivec2(0,0), 0 ).xy;//vec2((iResolution.y*0.5-iMouse.y)/iResolution.y*2.0,iTime/2.0+(iResolution.x*0.5-iMouse.x)/iResolution.x*2.0);\n    vec3 pos= texelFetch( iChannel0, ivec2(0,0), 0 ).xyz;//vec3(sin(iTime/10.0)*10.0*blockSize,10.0*blockSize,cos(iTime/10.0)*10.0*blockSize);\n    //pos.y=max(gridSpot(pos*blockSize).y,pos.y);\n  \n    float fov=180.0;\n   \n    float d=0.0;\n    vec4[3] hit;\n    vec4[3] lightHit;\n    vec4[3] reflectionHit;\n    vec3 rayDir;\n    float coy = cos(rot.y),\n            soy = sin(rot.y),\n            cop = cos(rot.x),\n            sop = sin(rot.x);\n   \n    vec3 color;\n    vec3 lightDir=vec3(sin(iTime/10.0),1,cos(iTime/10.0));\n    lightDir=normalizeVector(lightDir);\n    float uvY=iResolution.y;\n    float dx =(fragCoord.x-iResolution.x/2.0)/iResolution.x*fov/100.0*(iResolution.x/iResolution.y), \n            dy = (fragCoord.y-uvY/2.0)/uvY*fov/100.0,\n            dz = 1.0;\n        \n            \n    float  svx = dx, svy = dy;\n            dy = svy * cop - dz * sop;\n            dz = dz * cop + svy * sop;\n            dx = svx * coy - dz * soy;\n            dz = dz * coy + svx * soy;\n            rayDir=vec3(dx,dy,dz);\n            \n            \n    hit=raycast3d(pos,rayDir,viewDistance);\n    vec3 textureSpot;\n  // textureSpot=vec3(mod(hit[1].y-hit[0].y,blockSize)/blockSize*hit[2].x,mod(hit[1].z-hit[0].z,blockSize)/blockSize*hit[2].y,mod(hit[1].w-hit[0].w,blockSize)/blockSize*hit[2].z);\n    textureSpot=vec3(mod((hit[1].y*blockSize*0.1-hit[0].y)/blockSize,blockSize)/blockSize*hit[2].x,\n    mod((hit[1].z*blockSize*0.1-hit[0].z)/blockSize,blockSize)/blockSize*hit[2].y,\n    mod((hit[1].w*blockSize*0.1-hit[0].w)/blockSize,blockSize)/blockSize*hit[2].z);\n    vec3 unscaledTextureSpot;\n    unscaledTextureSpot=vec3(mod((hit[1].y*blockSize-hit[0].y)/blockSize,blockSize)/blockSize*hit[2].x,\n    mod((hit[1].z*blockSize-hit[0].z)/blockSize,blockSize)/blockSize*hit[2].y,\n    mod((hit[1].w*blockSize-hit[0].w)/blockSize,blockSize)/blockSize*hit[2].z);\n  //  textureSpot=vec3(max(max(textureSpot.x,textureSpot.y),textureSpot.z),max(max(textureSpot.x,textureSpot.y),textureSpot.z),max(max(textureSpot.x,textureSpot.y),textureSpot.z));\n   if(hit[2].y==-1.0){ \n    textureSpot=vec3(textureSpot.x,textureSpot.z,0.0);\n   }else\n   if(hit[2].x==-1.0){ \n    textureSpot=vec3(textureSpot.z,textureSpot.y,0.0);\n   }\n   \n   if(hit[2].y==-1.0){ \n    unscaledTextureSpot=vec3(unscaledTextureSpot.x,unscaledTextureSpot.z,0.0);\n   }else\n   if(hit[2].x==-1.0){ \n    unscaledTextureSpot=vec3(unscaledTextureSpot.z,unscaledTextureSpot.y,0.0);\n   }\n    //textureSpot*=vec3(1,1,1)*hit[2].z;\n    \n   vec4 textureColor=texture(iChannel3,vec2(textureSpot.x,textureSpot.y));\n    \n    vec4 hit1=hit[0];\n    if(hit1.x==1.0){\n    \n    \n              vec4 hit2=hit[1];\n              vec4 hit3=hit[2];\n              vec3 newPos=vec3(hit2.y-rayDir.x*0.001,hit2.z-rayDir.y*0.001,hit2.w-rayDir.z*0.001);\n              lightHit=raycast3d(newPos,lightDir,viewDistance);\n              vec4 lightHit1=lightHit[0];\n             // vec4 lightHit1=lightHit[1];\n             vec3 colorPos=vec3(hit1.y,hit1.z,hit1.w);\n             if(gridSpot(colorPos)==4){\n             textureColor=texture(iChannel2,vec2(textureSpot.x,textureSpot.y));\n    \n             }\n              // d=min(0.1*(float(viewDistance)/(sqrt((xx-colorPos.x)*(xx-colorPos.x)+(yy-colorPos.y)*(yy-colorPos.y)+(zz-colorPos.z)*(zz-colorPos.z)))),1.0);\n            d=0.9;\n            vec3 reflectionDir=vec3(rayDir.x*hit3.x,rayDir.y*hit3.y,rayDir.z*hit3.z+0.0);\n              if(lightHit1.x==1.0){\n              d/=2.0;\n              }\n              \n           float bounces=0.0;\n           float rd=1.0;\n           vec3 reflectionColor=vec3(0,0,0);\n           vec3 lastSpot=vec3(hit1.y,hit1.z,hit1.w);\n           if(colors[gridSpot(vec3(lastSpot.x,lastSpot.y,lastSpot.z))-1].w>0.0){\n         for(int i=0;i<reflectionBounces;i++){\n          if(colors[gridSpot(vec3(lastSpot.x,lastSpot.y,lastSpot.z))-1].w>0.0){\n         \n        reflectionHit=raycast3d(newPos,reflectionDir,viewDistance);\n            newPos=vec3(reflectionHit[1].y-rayDir.x*0.001,reflectionHit[1].z-rayDir.y*0.001,reflectionHit[1].w-rayDir.z*0.001);\n           \n            if(reflectionHit[0].x>=1.0){\n            bounces+=1.0;\n             lightHit=raycast3d(newPos,lightDir,viewDistance);\n            if(lightHit[0].x>=1.0){\n            rd=0.5;}else{\n            rd=1.0;}\n             \n               reflectionColor+=colors[gridSpot(vec3(reflectionHit[0].y,reflectionHit[0].z,reflectionHit[0].w))-1].xyz*colors[gridSpot(vec3(lastSpot.x,lastSpot.y,lastSpot.z))-1].w*rd;\n              reflectionDir=vec3(reflectionDir.x*reflectionHit[2].x,reflectionDir.y*reflectionHit[2].y,reflectionDir.z*reflectionHit[2].z);\n            \n             lastSpot=vec3(reflectionHit[0].y,reflectionHit[0].z,reflectionHit[0].w);\n           }else{\n           i=reflectionBounces;\n           bounces++;\n           reflectionColor+=vec3(skyColor);\n            \n            }\n           }\n           else{\n           i=reflectionBounces;\n           }\n            }}\n            reflectionColor/=max(bounces,1.0);\n            \n                color=colors[gridSpot(vec3(hit1.y,hit1.z,hit1.w))-1].xyz*d*(1.0-colors[gridSpot(vec3(hit1.y,hit1.z,hit1.w))-1].w)+reflectionColor*colors[gridSpot(vec3(hit1.y,hit1.z,hit1.w))-1].w;\n    color*=vec3(textureColor.x,textureColor.y,textureColor.z);\n   //color=textureSpot;\n    if(unscaledTextureSpot.x<0.1||unscaledTextureSpot.x>0.9||unscaledTextureSpot.y<0.1||unscaledTextureSpot.y>0.9){\n       // color*=0.5;\n    }\n    \n    }else{\n             color=vec3(skyColor);   \n            }\n  \n    \n \n    \n    \n      vec3 spot=vec3(fragCoord.x*0.1,sin(iTime),fragCoord.y*0.1);\n    int c=gridSpot(spot);\n\n\nfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_A  = 65;\nconst int KEY_W    = 87;\nconst int KEY_D = 68;\nconst int KEY_S  = 83;\nconst int KEY_SPACE=32;\nconst int KEY_SHIFT=16;\nconst float pi=3.14;\nvec3 updatePos(vec3 pos){\nvec2 rot=texelFetch(iChannel2, ivec2(0, 0), 0).xy;\nvec3 left = texelFetch(iChannel1, ivec2(KEY_A, 0), 0).x * vec3(-cos(rot.y),0, -sin(rot.y));\n    vec3 up = texelFetch(iChannel1, ivec2(KEY_W,0), 0).x * vec3(cos(rot.y+0.5*pi),0, sin(rot.y+0.5*pi));\n    vec3 right = texelFetch(iChannel1, ivec2(KEY_D, 0), 0).x * vec3(cos(rot.y),0, sin(rot.y));\n    vec3 down = texelFetch(iChannel1, ivec2(KEY_S, 0), 0).x * vec3(-cos(rot.y+0.5*pi),0, -sin(rot.y+0.5*pi));\n    vec3 space = texelFetch(iChannel1, ivec2(KEY_SPACE, 0), 0).x * vec3(0,2,0);\n    vec3 shift = texelFetch(iChannel1, ivec2(KEY_SHIFT, 0), 0).x * vec3(0,-2,0);\npos+=(left+up+right+down+space+shift)*10.0;\nreturn pos;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec3 pos= texelFetch( iChannel0, ivec2(0,0), 0 ).xyz;\npos=updatePos(pos);\n//pos.x=max(min(pos.x,14.0*10.0),-14.0*10.0);\n//pos.z=max(min(pos.z,14.0*10.0),-14.0*10.0);\n // pos.y=max(min(pos.y,10.0*10.0),50.0);\n  \n  if(pos.y==0.0){\n  pos.y=22.0*20.0;\n  }\n  fragColor = vec4(pos,1.0);\n \n\n  \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nvec2 updateRot(vec2 rot){\nvec2 left = texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x * vec2(0, 2);\n    vec2 up = texelFetch(iChannel1, ivec2(KEY_UP,0), 0).x * vec2(-2, 0);\n    vec2 right = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x * vec2(0, -2);\n    vec2 down = texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x * vec2(2, 0);\n\nrot+=(left+up+right+down)*0.1;\nreturn rot;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 rot= texelFetch( iChannel0, ivec2(0,0), 0 ).xy;\n\n  rot=updateRot(rot);\n//rot.y+=0.01;\n  fragColor = vec4(rot,0.1,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}