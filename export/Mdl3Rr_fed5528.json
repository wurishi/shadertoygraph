{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Robert Cupisz 2013\n// Creative Commons Attribution-ShareAlike 3.0 Unported\n//\n// Bits of code taken from Inigo Quilez, including fbm(), impulse()\n// and friends, sdCone() and friends; also box() by Simon Green.\n\n#define BRUTE_FORCE_AA 1\n\n#if BRUTE_FORCE_AA\n#define AA_SAMPLES 4\n#define INSCATTER_STEPS 30\n#define NOISE_AMPLITUDE 0.1\n#else\n#define INSCATTER_STEPS 50\n#define NOISE_AMPLITUDE 0.05\n#endif\n\n#define INF 1.0e38\n#define HIT(x) hit = min(hit, x)\n\n// Shadow rays can make things faster if there are big occluders\n// but kinda ugly with no #include statement\n//#define HIT(x) if (x < INF) return 0.0\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n\t\t\t  -0.80,  0.36, -0.48,\n\t\t\t  -0.60, -0.48,  0.64 );\n\nfloat hash (float n)\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat noise (in vec3 x)\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\n\tf = f*f*(3.0-2.0*f);\n\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\n\tfloat res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n\t\t\t\t\t\tmix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n\t\t\t\t\tmix(mix( hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t\t\t\tmix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n\treturn res;\n}\n\nfloat fbm (vec3 p)\n{\n\tfloat f;\n\tf  = 0.5000*noise( p ); p = m*p*2.02;\n\tf += 0.2500*noise( p ); p = m*p*2.03;\n\tf += 0.1250*noise( p ); //p = m*p*2.01;\n\t//f += 0.0625*noise( p );\n\treturn f;\n}\n\nfloat box(vec3 org, vec3 dir, vec3 size, out float far)\n{\n\t// compute intersection of ray with all six bbox planes\n\tvec3 invR = 1.0 / dir;\n\tvec3 tbot = invR * (-0.5*size - org);\n\tvec3 ttop = invR * (0.5*size - org);\n\t\n\t// re-order intersections to find smallest and largest on each axis\n\tvec3 tmin = min (ttop, tbot);\n\tvec3 tmax = max (ttop, tbot);\n\t\n\t// find the largest tmin and the smallest tmax\n\tvec2 t0 = max (tmin.xx, tmin.yz);\n\tfloat near;\n\tnear = max (t0.x, t0.y);\n\tt0 = min (tmax.xx, tmax.yz);\n\tfar = min (t0.x, t0.y);\n\n\t// check for hit\n\treturn near < far && far > 0.0 ? near : INF;\n}\n\nfloat box(vec3 org, vec3 dir, vec3 size)\n{\n\tfloat far;\n\treturn box(org, dir, size, far);\n}\n\nfloat impulse (float k, float x)\n{\n\tfloat h = k * x;\n\treturn h * exp (1.0 - h);\n}\n\nfloat impulse2 (float k0, float k1, float x)\n{\n\tfloat k = k0;\n\tif (x > 1.0/k0)\n\t{\n\t\tx += 1.0/k1 - 1.0/k0;\n\t\tk = k1;\n\t}\n\tfloat h = k * x;\n\treturn h * exp (1.0 - h);\n}\n\nfloat cubicPulse (float w, float x)\n{\n\tx = abs (x);\n\tif (x > w)\n\t\treturn 0.0;\n\tx /= w;\n\treturn 1.0 - x * x * (3.0 - 2.0 * x);\n}\n\nmat2 rot(float angle)\n{\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\treturn mat2(c,-s,s,c);\n}\n\n// rd doesn't have to be normalized\nfloat sphere(vec3 ro, vec3 rd, float r)\n{\n\tfloat b = dot(ro, rd);\n\tfloat c = dot(ro, ro) - r * r;\n\tfloat a = dot(rd, rd);\n\t// Exit if râ€™s origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif (c > 0.0 && b > 0.0)\n\t\treturn INF;\n\tfloat discr = b*b - a*c;\n\t// A negative discriminant corresponds to ray missing sphere\n\tif (discr < 0.0)\n\t\treturn INF;\n\t// Ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat t = - b - sqrt(discr);\n\tt /= a;\n\t// If t is negative, ray started inside sphere so clamp t to zero\n\tt = max(0.0, t);\n\treturn t;\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n\t// c must be normalized\n\tfloat q = length(p.xy);\n\treturn dot(c,vec2(q,p.z));\n}\n\nfloat sdPlane (vec3 p, vec4 n)\n{\n\t// n must be normalized\n\treturn dot(p,n.xyz) + n.w;\n}\n\nfloat sdSphere (vec3 p, float s)\n{\n\treturn length(p)-s;\n}\n\nvec3 animateTentacle (vec3 p)\n{\n\tfloat t = 0.8*iTime + 2.6;\n\tfloat pi = 3.1415;\n\tfloat pi4 = pi*4.0;\n\t\n\t// major up and down\n\tfloat offset = 1.05;\n\tp.z += offset;\n\tfloat a = 0.6;\n\ta += 0.1*sin(1.33*t - 0.7);\n\ta += 0.15*sin(2.0*t);\n\ta -= 1.2*impulse2(3.0, 1.1, mod(pi4 - t, pi4));\n\ta *= 0.8*max(-0.1, p.z) + 0.1;\n\tmat2 m = rot(a);\n\tp = vec3(m*p.yz,p.x).zxy;\n\tp.z -= offset;\n\t\n\t// ripples\n\tfloat ripplesPos = p.z + 0.5*mod(t, pi4) - 0.3;\n\tfloat ripples = 0.003*sin(80.0*ripplesPos)*cubicPulse(0.15, ripplesPos + 0.7);\n\tp.y += ripples;\n\tp.x += ripples;\n\t\n\t// whiplash\n\tp.y += 0.06*smoothstep(-0.6, -0.3, p.z)*impulse(25.0, mod(t - 0.01, pi4));\n\t\n\treturn p;\n}\n\nfloat sdTentacle (vec3 p)\n{\n\tp += vec3(-0.6,0.52,-0.06);\n\t\n\t// bend\n\tp.y -= smoothstep(0.95, 1.1, -p.z)*(p.z + 0.9)*0.5;\n\t\n\t// animate\n\tp = animateTentacle(p);\n\t\n\t// wavy\n\tp.y += 0.02*sin(13.0*p.z + iTime + 3.0);\n\tp.x += 0.01*cos(17.0*p.z);\n\t\n\t// primitives\n\tfloat d = sdCone(p, vec2(0.99, 0.12));\n\td = max(d, -sdPlane(p, vec4(0,0,1,1.135)));\n\td = max(d, -sdPlane(p, vec4(0,0,-1,-0.4)));\n\td = min(d, sdSphere(p + vec3(0.0, 0.0, 0.41), 0.05));\n\t\n\treturn d;\n}\n\nfloat tentacle (vec3 ro, vec3 rd)\n{\n\tfloat far;\n\tvec3 bboxpos = vec3(-0.6,0.51,0.69);\n\tvec3 bboxsize = vec3(0.25, 0.66, 0.79);\n\tfloat near = box (ro + bboxpos, rd, bboxsize);\n\tif(near == INF)\n\t\treturn INF;\n\t//return near;\n\t\n\tnear = max(0.0, near);\n\t\n\tro += near*rd;\n\tfloat t = 0.0;\n\tfloat hit = -1.0;\n\tfor(int i=0; i < 24; i++)\n\t{\n\t\tfloat h = sdTentacle(ro + rd*t);\n\t\t// We will be overwriting the hit multiple times once\n\t\t// we're close to the surface, but it actually gives\n\t\t// a better result than the first below threshold\n\t\t// and we can't break anyway.\n\t\tif (h < 1e-5)\n\t\t\thit = t;\n\t\tt += h;\n\t}\n\t\n\treturn hit > -1.0 ? hit + near : INF;\n}\n\nfloat roof(vec3 ro, vec3 rd)\n{\n\tfloat hit = -ro.y/rd.y;\n\t// An offset, so that shadow rays starting from the roof don't\n\t// think they're unoccluded\n\tif (hit < -0.1)\n\t\treturn INF;\n\t\n\t// We've hit the plane. If we've hit the window, but\n\t// not the beams, return no hit.\n\tvec2 pos = ro.xz + hit*rd.xz;\n\tvec2 window = abs(pos) - 0.81;\n\t// single beams\n\t//vec2 beams = 0.02 - abs(pos);\n\t// double beams\n\tvec2 beams = 0.015 - abs(mod(pos, 0.54) - 0.27);\n\tif (max(max(window.x, window.y), max(beams.x, beams.y)) < 0.0)\n\t\treturn INF;\n\n\treturn hit;\n}\n\nfloat monsterBox(vec3 ro, vec3 rd)\n{\n\tfloat hit = INF;\n\tfloat size = 0.33;\n\tfloat halfSize = 0.5*size;\n\tHIT(box (ro, rd, vec3(size)));\n\t\n\tro.y -= halfSize;\n\tro.z += halfSize;\n\tmat2 m = rot(0.017*(sin(iTime) - 48.0));\n\tro.yz = m*ro.yz;\n\trd.yz = m*rd.yz;\n\tro.z -= halfSize;\n\t\n\tHIT(box (ro, rd, vec3(size, 0.04, size)));\n\treturn hit;\n}\n\nfloat ship (vec3 ro, vec3 rd)\n{\n\tfloat pi = 3.1415;\n\tfloat pihalf = 0.5*pi;\n\tfloat t = 0.8*iTime + 3.0;\n\tfloat angle = 0.0;\n\t\n\t// tilting back and forth\n\tfloat tiltt = t + 0.3;\n\tfloat tiltAmp = - 0.14 * sign(fract((tiltt + pihalf)/(2.0*pi)) - 0.5);\n\tangle += tiltAmp*cubicPulse(1.2, mod(tiltt + pihalf, pi) - pihalf);\n\t\n\t// running away\n\tangle += 0.7*impulse(3.0, mod(t + 0.08, 4.0*pi));\n\tfloat post = mod(t, 2.0*pi);\n\tpost += impulse(1.0, mod(t, 4.0*pi));\n\tro += vec3(-0.6, 0.5, 0.3*cos(post) - 0.08);\n\t\n\t// rotate\n\tmat2 m = rot(angle);\n\tro.yz = m*ro.yz;\n\trd.yz = m*rd.yz;\n\n\t// intersect\n\tfloat hit = INF;\t\n\tHIT(sphere (ro + vec3(0.0, -0.025, 0.0), rd, 0.05));\n\tfloat flatten = 4.0;\n\tro.y *= flatten;\n\trd.y *= flatten;\n\tHIT(sphere (ro, rd, 0.17));\n\treturn hit;\n}\n\n#define ROOFPOS vec3(0,-1,0.01)\n\nfloat intersect (vec3 ro, vec3 rd)\n{\n\tfloat hit = INF;\n\n\t// tentacle\n\tHIT(tentacle(ro, rd));\n\t\n\t// ship\n\tHIT(ship(ro, rd));\n\t\n\t// stuff\n\tHIT(box (ro + vec3(0.5,0.5,0), rd, vec3(0.4,2,1)));\n\tHIT(sphere (ro + vec3(0.3,0.8,0.65), rd, 0.25));\n\tmat2 m = rot(3.5);\n\tvec3 rorot = ro + vec3(0.4,-0.6,0.3);\n\tvec3 rdrot = rd;\n\trorot.xz = m*rorot.xz;\n\trdrot.xz = m*rdrot.xz;\n\tHIT(box (rorot, rdrot, vec3(0.35,0.2,0.35)));\n\t\n\t// roof\n\trorot = ro + ROOFPOS;\n\trdrot = rd;\n\t// reuse the previous rotation matrix\n\trorot.xy = m*rorot.xy;\n\trdrot.xy = m*rdrot.xy;\n\tHIT(roof(rorot, rdrot));\n\n\t// monster box\n\tm = rot(-0.175);\n\trorot = ro + vec3(-0.6,0.78,1.0);\n\trdrot = rd;\n\trorot.xz = m*rorot.xz;\n\trdrot.xz = m*rdrot.xz;\n\tHIT(monsterBox(rorot, rdrot));\n\t\n\t// floor\n\tfloat floorHit = -(ro.y + 0.95)/rd.y;\n\tif (floorHit < 0.0)\n\t\tfloorHit = INF;\n\tHIT(floorHit);\n\n\treturn hit;\n}\n\nfloat particles (vec3 p)\n{\n\tvec3 pos = p;\n\tpos.y -= iTime*0.02;\n\tfloat n = fbm(20.0*pos);\n\tn = pow(n, 5.0);\n\tfloat brightness = noise(10.3*p);\n\tfloat threshold = 0.26;\n\treturn smoothstep(threshold, threshold + 0.15, n)*brightness*90.0;\n}\n\nfloat transmittance (vec3 p)\n{\n\treturn exp (0.4*p.y);\n}\n\nvec3 inscatter (vec3 ro, vec3 rd, vec3 roLight, vec3 rdLight, vec3 lightDir, float hit, vec2 screenPos)\n{\n\tfloat far;\n\tfloat near = box(roLight + vec3(0.0, 1.0, 0.0), rdLight, vec3(1.5, 3.0, 1.5), far);\n\tif(near == INF || hit < near)\n\t\treturn vec3(0);\n\t\n\tfloat distAlongView = min(hit, far) - near;\n\tfloat oneOverSteps = 1.0/float(INSCATTER_STEPS);\n\tvec3 step = rd*distAlongView*oneOverSteps;\n    vec3 pos = ro + rd*near;\n\tfloat light = 0.0;\n    \n    // add noise to the start position to hide banding\n    // TODO: blue noise\n\tpos += rd*noise(vec3(2.0*screenPos, 0.0))*NOISE_AMPLITUDE;\n\n\tfor(int i = 0; i < INSCATTER_STEPS; i++)\n\t{\n\t\tfloat l = intersect(pos, lightDir) == INF ? 1.0 : 0.0;\n\t\tl *= transmittance(pos);\n\t\tlight += l;\n\t\tlight += particles(pos)*l;\n\t\tpos += step;\n\t}\n\n\tlight *= oneOverSteps * distAlongView;\n\treturn light*vec3(0.6);\n}\n\nvec3 rot (vec3 v, vec3 axis, vec2 sincosangle)\n{\n\treturn v*sincosangle.y + cross(axis, v)*sincosangle.x + axis*(dot(axis, v))*(1.0 - sincosangle.y);\n}\n\nvec3 surface(vec2 fragCoord, vec3 ro, vec3 u, vec3 v, vec3 w, vec3 lightRotAxis, vec2 lightAngleSinCos, vec3 lightDir)\n{\n    vec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 p = -1.0 + 2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\n\tvec3 rd = normalize( p.x*u + p.y*v + 1.5*w );\n\n\t// raycast the scene\n\tfloat hit = intersect(ro,rd);\n\tvec3 hitPos = ro + hit * rd;\n\t\n\t// white window\n\tif (hit == INF)\n\t\treturn vec3(1.0);\n\t\n\t// direct light (screw shading!)\n\tvec3 c = vec3(0.0);\n    float shadowBias = 1.0e-4;\n\tif (intersect(hitPos + lightDir*shadowBias, lightDir) == INF)\n\t\tc = vec3(0.9);\n    \n    lightAngleSinCos.x *= -1.0; // rev angle\n\tvec3 roLight = rot(ro + ROOFPOS, lightRotAxis, lightAngleSinCos);\n\tvec3 rdLight = rot(rd, lightRotAxis, lightAngleSinCos);\n\tc += inscatter(ro, rd, roLight, rdLight, lightDir, hit, fragCoord);\n    \n    // color correction - Sherlock color palette ;)\n\tc.r = smoothstep(0.0, 1.0, c.r);\n\tc.g = smoothstep(0.0, 1.0, c.g - 0.1);\n\tc.b = smoothstep(-0.3, 1.3, c.b);\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\n\tvec3 ro = normalize(vec3(1.0,-0.1,0.1));\n\tfloat cameraAngle = iMouse.x/iResolution.x - 0.5;\n\tif(iMouse.z < 0.5)\n\t\tcameraAngle = 0.5*sin(0.1*iTime);\n\tfloat cca = cos(cameraAngle);\n\tfloat sca = sin(cameraAngle);\n\tmat2  m = mat2(cca,-sca,sca,cca);\n\tro = vec3(m*ro.xz,ro.y).xzy;\n\tvec3 w = -ro;\n\tro *= 2.5;\n\tvec3 u = normalize(cross( vec3(0.0,1.0,0.0), w ));\n\tvec3 v = normalize(cross(w,u));\n    \n    // light\n    vec3 lightRotAxis = vec3(0.707,0,0.707); //1,0,1 normalized\n\tvec2 lightAngleSinCos = vec2(sin(0.28), cos(0.28));\n\tvec3 lightDir = rot(vec3(0,1,0), lightRotAxis, lightAngleSinCos);\n    \n#if BRUTE_FORCE_AA\n    float invAA = 1.0 / float(AA_SAMPLES);\n    vec3 c = vec3(0);\n    vec2 offset = vec2(-0.5, -0.5);\n    for (int i=0; i < AA_SAMPLES; i++)\n    {\n        for (int j=0; j < AA_SAMPLES; j++)\n        {\n            c += surface(fragCoord + offset, ro, u, v, w, lightRotAxis, lightAngleSinCos, lightDir);\n            offset.y += invAA;\n        }\n        offset.x += invAA;\n        offset.y = -0.5;\n    }\n    c *= invAA * invAA;\n#else\n    vec3 c = surface(fragCoord, ro, u, v, w, lightRotAxis, lightAngleSinCos, lightDir);\n#endif\n    \n\tfragColor = vec4(c, 0.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Mdl3Rr","date":"1363453092","viewed":13819,"name":"attic","username":"robertcupisz","description":"Click and drag to rotate the camera.\n\nThe tentacle is a raymarched distance field, the rest of the scene is raycast. The inscattered light/volumetric shadows is just stepping through the volume and casting a shadow ray at every step.","likes":272,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","raycast","volumetric"],"hasliked":0,"parentid":"","parentname":""}}