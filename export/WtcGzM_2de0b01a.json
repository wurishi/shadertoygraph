{"ver":"0.1","info":{"id":"WtcGzM","date":"1575854997","viewed":192,"name":"Naive Bounce Lighting","username":"VoidChicken","description":"A naive approach to realistic lighting.\nUncomment #define MEDIAN to enable denoising","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["bounce"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define MEDIAN\nvec4 k[5*5];\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    vec4 c = texture(iChannel1, uv);\n    #ifdef MEDIAN\n    vec2 px = 1./iChannelResolution[1].xy;\n    \n    for (int i = -2; i <= 2; i++)\n    {\n         for (int j = -2; j <= 2; j++)\n         {\n             int q = (i+2)+(j+2)*5;\n             k[q] = texture(iChannel1, uv+px*vec2(i, j));\n         }\n    }\n    \n    \n    //bubble sort (yeah i know, its bad but i couldn't think of a better sorting algorithm that unrolls properly. just a prototype anyway)\n    \n    for (int q = 0; q < 20; q++)\n    {\n    \tfor (int l = 0; l < 20; l++)\n        {\n         \tif (length(k[l]) > length(k[l+1]))\n            {\n             \tvec4 t = k[l];\n                k[l] = k[l+1];\n                k[l+1] = t;\n            }\n        }\n    }\n    \n    c=k[12];\n    #endif\n    fragColor = c;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define RT_STEPS 20\n#define RT_HIT 0.1\n#define RT_AOD 0.1\n#define RT_AOM 0.6\n#define RT_BOUNCESAMPLES 200\n\nfloat hash(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvec3 rand(vec3 p, vec3 n, float i)\n{\n    float x = hash(p.yz+hash(i*n.yz)*n.yz);\n    float y = hash(p.zx+hash(i*n.zx)*n.zx);\n    float z = hash(p.xy+hash(i*n.xy)*n.xy);\n    vec3 v = vec3(x, y, z)*2.-1.;\n    v=normalize(v);\n    float dp = dot(v, n);\n    if(dp<0.0)\n        v=reflect(v, n);\n    return v;\n}\n\n\n\nvec2 mmin(vec2 a, vec2 b)\n{\n\tif (a.x<b.x)\n    \treturn a;\n    return b;\n}\n\nfloat sdPlaneY(vec3 p, float h)\n{\n\treturn p.y-(sin(p.x*5.)*cos(p.z*5.))/5.;    \n}\n\nfloat sdSphere(vec3 p, vec3 o, float r)\n{\n\treturn length(p-o)-r;    \n}\n\nvec2 map(vec3 o)\n{\n\tvec2 m = iMouse.xy/iResolution.xy*4.-2.;\n    return mmin(\n        mmin( vec2(sdPlaneY(o, 0.), 0),\n             vec2(sdSphere(o, vec3(1.+m.x, 1.+m.y,-1.), 0.5), 3)),\n        mmin(\n            vec2(sdSphere(o, vec3(-1.5+cos(iTime),1.,sin(iTime)), 0.2), 1),\n            vec2(sdSphere(o, vec3(1.5+sin(iTime),1.,cos(iTime)), .5), 2)\n        ));\n}\n\nbool isHit(vec3 p)\n{\n\treturn map(p).x < RT_HIT;\n}\n\nvec2 trace(vec3 o, vec3 d)\n{\n \tvec2 t = vec2(0);\n    for (int i = 0; i < RT_STEPS; i++)\n    {\n        vec2 m = map(o+d*t.x);\n        t.x+=m.x;\n        t.y=m.y;\n    }\n    return t;\n}\n/*\nvec4 triplanar(sampler2D channel, vec3 p, vec3 n)\n{\n    n=abs(n);\n    n/=(n.x+n.y+n.z);\n\tvec4 x = texture(channel, p.yz);\n\tvec4 y = texture(channel, p.zx);\n\tvec4 z = texture(channel, p.xy); \n    return n.x*x+n.y*y+n.z*z;\n}*/\n\nvec4 getColor(float mat, vec3 pos)\n{\n    if (mat == 0.0)\n        return vec4(vec3(1, 1, max((pow(sin(pos.x)*cos(pos.z*10.)/2.+0.5,13.))*10., 1.)),1.0);\n    if (mat == 1.0)\n        return vec4((sin(iTime*10.)/2.+1.3)*10., 0, 0, 1);\n    if (mat == 2.0)\n        return vec4(0, 5, 0, 1);\n    if (mat == 3.0)\n        return vec4(vec3(0.5), 1.);\n    return vec4(0);\n}\n\nvec4 getEmission(vec4 color)\n{\n\treturn max(color - 1.0, 0.0);    \n}\n\nfloat aov(vec3 p, vec3 n)\n{\n\tvec3 aoCheck = p + n * RT_AOD;\n    float aoDist = map(aoCheck).x;\n    return min(mix(RT_AOM, 1., aoDist / RT_AOD), 1.);\n}\n\n//calcNormal used from iq's directional derivative blog\n//https://iquilezles.org/articles/derivative\nvec3 calcNormal(vec3 x)\n{\n    float eps = RT_HIT;\n    vec2 e = vec2(eps, 0.0);\n    return normalize(vec3(map(x+e.xyy).x - map(x-e.xyy).x,\n                          map(x+e.yxy).x - map(x-e.yxy).x,\n                          map(x+e.yyx).x - map(x-e.yyx).x ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n\n\tvec4 col = vec4(0);\n    \n    vec3 o = vec3(0, 1, -3);\n    \n    vec3 d = vec3(uv*2.-1.,1.);\n    d.x*=iResolution.x/iResolution.y;\n    d=normalize(d);\n    \n    vec2 t = trace(o, d);\n    vec3 h = o+d*t.x;\n    vec3 n = calcNormal(h);\n    \n\tif (isHit(h))\n    {\n        //float ao = aov(h, n);\n\t\tvec4 bcol = vec4(0);\n        float samples = 0.0;\n        for (int i = 0; i < RT_BOUNCESAMPLES; i++) {\n            vec3 rd = rand(h, n, float(i));\n            vec2 rt = trace(h+n*RT_HIT, rd);\n            vec3 rh = h+rd*rt.x;\n            if (isHit(rh)) {\n                bcol += getEmission(getColor(rt.y, rh)) / rt.x  * max(dot(n, rd),0.);\n                samples++;\n            }\n        }\n        bcol/= samples;\n        \n        col = max(getColor(t.y, h) * bcol, 0.0) + getEmission(getColor(t.y, h));\n    }\n    \n    \n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"}]}