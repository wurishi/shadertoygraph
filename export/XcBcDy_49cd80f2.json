{"ver":"0.1","info":{"id":"XcBcDy","date":"1722891676","viewed":112,"name":"Editable Physics Environment","username":"chronos","description":"particle simulation with jump flood based distance field drawing.\nMouse to draw\nPress R to reset particles\nHold SPACE while drawing to erase","likes":14,"published":1,"flags":48,"usePreview":0,"tags":["basic","simulation","sdf","distance","field","physics","flood","jump","particle","signed","interior","flooding","jfa"],"hasliked":0,"parentid":"McByRd","parentname":"Dynamic SDF Jump Flood"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n    Editable Physics Environment by chronos\n    ---------------------------------------------------------------------------\n    \n    Combined 'Particle simulation' shader (https://www.shadertoy.com/view/DsfyR7)\n    with the Dynamic SDF Jump Flood shader to create editable obstacles/wall/boundaries/environment\n    for a simple physics particle simulation.\n    \n    mouse to draw\n    press R to reset particles\n    hold SPACE while drawing to erase\n    \n    Forked Shader description:\n\n        Dynamic SDF Jump Flood by chronos\n        ---------------------------------------------\n\n        Just drawing a sign value in Buffer A, and then flooding with different offsets\n        Jump flooding implementation is updated from one of my previous JF shaders to\n        handle correct interior distances and dynamic updates of arbitrary fields.\n\n        There is a similar shader to this by @fenix: https://www.shadertoy.com/view/ct2cDV\n        thanks to @MysteryPancake for making me aware of it.\n        I didn't know about it before starting this, so I think this one likely works somewhat differently.\n\n        In any case, this one works by keeping track of an offset, fill and sign for each pixel.\n\n        - The offset represents the vector from this pixel to the nearest sign change (zero crossing),\n            the distance is the length of this vector.\n        - The fill represents whether or not the current pixel has found any valid sign changes yet.\n        - The sign is just a channel where you draw the interior (-1) or exterior (+1).\n\n        Then, if a pixel changes sign, it is 'invalidated' by resetting it's fill and other properties.\n        Or, if the offset target pixel pixel changes sign, then this pixel is also invalidated.\n\n        If a pixel is invalidated, it has to perform the search anew, and always maintain an unfilled state until\n        it finds an offset to an explicit pixel of differing sign. So it will eventually be valid again.\n\n        If a pixel didn't change sign itself, but has an offset to a target pixel that has changed sign,\n        then it should be invalidated itself, but it is not necessary to check for pointing to a pixel that has been invalidated, \n        since if it is a target pixel it must have opposite sign, and therefore the __validity only applies to the chain of differing sign__,\n        meaning it will not affect this pixel. So pixels shouldn't get stuck with stale targets.\n\n        The jump flood iteration is modified to that it only accepts a target if it is either of a different sign,\n        meaning the jump distance itself is the distance, or the target is filled, meaning that the target itself\n        has a valid path that leads to a different sign.\n\n        You can hold spacebar to erase / draw exterior (+1 sign). By default it draws interior (-1 sign).\n\n*/\n\n\nfloat mapEnvironment(in vec2 p) {\n\n    vec4 bufA = texture(iChannel1, (p*iResolution.y + .5 * iResolution.xy)/iResolution.xy);\n    return length(bufA.rg)*bufA.b / iResolution.y; \n}\n\nfloat movingDisk(in vec2 p, in vec2 o, in float r, in vec2 v, in float dt) {\n    vec2 p0 = p - o, p1 = v * dt;\n\n    float a = dot(p1, p1);\n    float b = dot(p0, p1);\n    float c = dot(p0, p0) - r * r;\n\n    float h = b * b - a * c;\n    if (h > 0.0) {\n        vec2 t = clamp((vec2(-1.0, 1.0) * sqrt(h) - b) / a, 0.0, 1.0);\n        return t.y - t.x;\n    }\n\n    return 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n\n\n    float distanceField = mapEnvironment(uv);\n    \n    \n    vec4 samp = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    float dist = length(samp.rg);\n    vec3 color =  vec3(0.) //samp.b * (1.-exp(-dist*0.1)) + step(0.,-samp.b) * vec3(.9,.6,.9)\n    +\n    vec3(.3,.6,.9)*dot(vec3(1.+normalize(samp.rg), tanh(dist) / 500.), vec3(.2))\n    ;\n    \n    fragColor = vec4(vec3(smoothstep(unit, 0.0, distanceField)), 1.0);\n    fragColor.rgb *= color;\n    \n    for(int i = 0; i < BALL_COUNT_X; ++i)\n    for(int j = 0; j < BALL_COUNT_Y; ++j)\n    {\n    \n        vec2 ballPos = getBallPos(ivec2(i,j));\n        float disk = movingDisk(uv, ballPos, BALL_RADIUS, getBallVel(ivec2(i,j)), iTimeDelta * TIME_SCALE);\n        fragColor.rgb = mix(vec3(fragColor.rgb), vec3(1), disk);\n    }\n    \n    \n    fragColor.rgb = sqrt(fragColor.rgb) * (1.-0.2*length(uv));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ij = ivec2(fragCoord);\n\n    const int N = 13;\n\n    vec2 uv = (2.*fragCoord-iResolution.xy) / iResolution.y;\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy) / iResolution.y;\n    bool mouse_down = iMouse.z > 0.;\n\n    // Initialize variables\n    float current_dist = 9e9;\n    vec2 current_offset = vec2(9e9);\n    float current_fill = 0.;\n    float current_sign = 1.;\n\n    if(iFrame == 0) // Initial pattern\n    {\n        if(min(1.5-length(uv), length(uv)-0.125 + .5*sin(5.*atan(uv.y,uv.x))) < 0.) \n        {\n            current_sign = -1.;\n        }\n    }\n    else // Jump flood\n    {\n        // pow2, e.g.: 256, 128, 64, 32, 16, 8, 4, 2, 1\n        // jump_size for iFrame%N == N-1 should be 1,\n        // therefore  min(iFrame%N + 1, N) should be N\n        int jump_size = (1 << N) >> min(iFrame % N + 1, N);\n\n        // Track if this pixel changes sign this frame,\n        // If it does, then the JFA would find itself or a previous neighbor in the search,\n        // so we skip JFA search for a frame if this happens.\n        bool sign_change_this_frame = false;\n    \n        vec4 prev = texelFetch(iChannel0, ij, 0);\n       \n        current_dist = length(prev.rg);\n        current_offset = prev.rg;\n        current_sign = prev.b;    // -1 or 1\n        current_fill = prev.a;    // 0 or 1\n        \n        if(length(uv-mouse) < 0.125 && mouse_down) \n        {\n            current_sign = -1. + 2. * texelFetch(iChannel3, ivec2(32. ,0), 0).r ;\n        }\n\n        vec4 prev_target = texelFetch(iChannel0, ij + ivec2(prev.rg), 0);\n\n        sign_change_this_frame = current_sign != prev.b;\n\n        // If this pixel sign or if the target solution fill value changed/no longer matches...\n        if(sign_change_this_frame || current_sign == prev_target.b) \n        {// ... Then we need to reset this pixel:\n                current_dist = 9e9;\n                current_offset = vec2(9e9);\n                current_fill = 0.;\n                sign_change_this_frame = true;\n        }\n    \n\n        if(!sign_change_this_frame)\n        for(int x = -1; x <= 1; ++x)\n        for(int y = -1; y <= 1; ++y)\n        {\n            ivec2 jump = jump_size * ivec2(x,y);\n            ivec2 coord = ij + jump;\n            if(coord.x < 0 || coord.y < 0 || coord.x >= int(iResolution.x) || coord.y >= int(iResolution.y))\n            {\n                continue;\n            }\n\n            vec4 samp = texelFetch(iChannel0, coord, 0);\n\n            bool samp_fill = samp.a > .5;\n            bool samp_sign_match = samp.b == current_sign;\n\n            vec2 samp_offset = samp.rg;\n            vec2 candidate_offset = samp_sign_match ? vec2(jump) + samp_offset : vec2(jump);\n            float candidate_dist = length(candidate_offset);\n\n            if (candidate_dist < current_dist && (samp_fill || !samp_sign_match) )\n            {\n                current_dist = candidate_dist;\n                current_offset = candidate_offset;\n                current_fill = 1.;\n            }\n        }\n    }\n    // save offset, sign and fill\n    fragColor = vec4(current_offset, current_sign, current_fill);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float mapEnvironment(in vec2 p) {\n\n    vec4 bufA = texture(iChannel3, (p*iResolution.y + .5 * iResolution.xy)/iResolution.xy);\n    return length(bufA.rg)*bufA.b / iResolution.y; \n}\n\nvec2 getNormal(in vec2 p) {\n    return normalize(vec2(mapEnvironment(p + vec2(0.001, 0.0)) - mapEnvironment(p - vec2(0.001, 0.0)),\n                          mapEnvironment(p + vec2(0.0, 0.001)) - mapEnvironment(p - vec2(0.0, 0.001))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {   \n    ivec2 ij = ivec2(fragCoord);\n    fragColor = vec4(0,0,0,1);\n    if(ij.x > BALL_COUNT_X || ij.y > BALL_COUNT_Y) return;\n    \n    // Init\n    vec4 noise = texelFetch(iChannel1, ij, 0);\n    fragColor = noise / 100. + vec4(vec2(-0.6,  0.33), 0, 0);\n\n    // Simulate\n    bool reset = texture( iChannel2, vec2(KEY_R,0.5) ).x > 0.5 || length(getBallPos(ij)) > 10.;\n    \n    if (iFrame > 0 && !reset)\n    {\n      \n            float dt = iTimeDelta * TIME_SCALE;\n      \n            vec2 ballPos = getBallPos(ij);\n            vec2 ballVel = getBallVel(ij);\n\n            const vec2 gravity = vec2(0, -0.001);\n            vec2 force = gravity;\n            \n            // integrate\n            ballVel += force * dt;\n            ballPos += ballVel * dt;\n\n            float distToEnv = mapEnvironment(ballPos);\n            if (distToEnv <= BALL_RADIUS) {\n                    vec2 hitNormal = getNormal(ballPos);\n                    ballPos += hitNormal * (BALL_RADIUS - distToEnv);\n                    ballVel = 0.95 * reflect(ballVel, hitNormal);\n            }\n            ballVel *= 0.9999;\n            \n            fragColor = vec4(ballPos, ballVel);\n      \n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define BALL_COUNT_X 20\n#define BALL_COUNT_Y 20\n#define TIME_SCALE 30.\n\n#define BALL_RADIUS 0.005\n\n#define getBallPos(ij) texelFetch(iChannel0, ij, 0).xy\n#define getBallVel(ij) texelFetch(iChannel0, ij, 0).zw\n\nconst float KEY_SPACE  = 32.5/256.0;\nconst float KEY_R  = 82.5/256.0;\n","name":"Common","description":"","type":"common"}]}