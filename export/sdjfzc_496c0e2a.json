{"ver":"0.1","info":{"id":"sdjfzc","date":"1646816619","viewed":132,"name":"HSL/HSV color picker distortion","username":"Tenoch","description":"Shows how the rectangular color pickers distort the color space (lesser resolution towards dark and light). Triangles display a uniform resolution over the entire space.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["colorspace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float EPSILON = 1e-10;\n\nvec3 HUEtoRGB(in float hue)\n{\n    // Hue [0..1] to RGB [0..1]\n    // See http://www.chilliant.com/rgb2hsv.html\n    vec3 rgb = abs(hue * 6. - vec3(3, 2, 4)) * vec3(1, -1, -1) + vec3(-1, 2, 2);\n    return clamp(rgb, 0., 1.);\n}\n\nvec3 RGBtoHCV(in vec3 rgb)\n{\n    // RGB [0..1] to Hue-Chroma-Value [0..1]\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 p = (rgb.g < rgb.b) ? vec4(rgb.bg, -1., 2. / 3.) : vec4(rgb.gb, 0., -1. / 3.);\n    vec4 q = (rgb.r < p.x) ? vec4(p.xyw, rgb.r) : vec4(rgb.r, p.yzx);\n    float c = q.x - min(q.w, q.y);\n    float h = abs((q.w - q.y) / (6. * c + EPSILON) + q.z);\n    return vec3(h, c, q.x);\n}\n\nvec3 HSVtoRGB(in vec3 hsv)\n{\n    // Hue-Saturation-Value [0..1] to RGB [0..1]\n    vec3 rgb = HUEtoRGB(hsv.x);\n    return ((rgb - 1.) * hsv.y + 1.) * hsv.z;\n}\n\nvec3 HSLtoRGB(in vec3 hsl)\n{\n    // Hue-Saturation-Lightness [0..1] to RGB [0..1]\n    vec3 rgb = HUEtoRGB(hsl.x);\n    float c = (1. - abs(2. * hsl.z - 1.)) * hsl.y;\n    return (rgb - 0.5) * c + hsl.z;\n}\n\nvec3 RGBtoHSV(in vec3 rgb)\n{\n    // RGB [0..1] to Hue-Saturation-Value [0..1]\n    vec3 hcv = RGBtoHCV(rgb);\n    float s = hcv.y / (hcv.z + EPSILON);\n    return vec3(hcv.x, s, hcv.z);\n}\n\nvec3 RGBtoHSL(in vec3 rgb)\n{\n    // RGB [0..1] to Hue-Saturation-Lightness [0..1]\n    vec3 hcv = RGBtoHCV(rgb);\n    float z = hcv.z - hcv.y * 0.5;\n    float s = hcv.y / (1. - abs(z * 2. - 1.) + EPSILON);\n    return vec3(hcv.x, s, z);\n}\n\nfloat random (vec3 st) {\n    return fract(sin(dot(st.xyz,\n                         vec3(12.9898,78.233, 103.2332)))*\n        43758.5453123);\n}\n\nfloat lerp(float a, float b, float t)\n{\n    return a * t + b * (1.0 - t);\n}\n\nvec3 lerp(vec3 a, vec3 b, float t)\n{\n    return a * t + b * (1.0 - t);\n}\n\nvoid mainForHSV( out vec4 fragColor, in vec2 uv )\n{\n    uv.x /= lerp(1.0, uv.y, sin(iTime / 2.0) / 2.0 + 0.5);\n    \n    if (uv.x > 1.0)\n    {\n        fragColor = vec4(0.0, 0.0, 0.0 ,1.0);\n        return;\n    }\n\n    float res = 128.0;\n\n    vec3 col = floor(res * HSVtoRGB(vec3(0.0, uv.xy))) / res;\n    vec3 rcol = vec3(random(col.xyz), random(col.yzx), random(col.zxy));\n    \n    vec3 outcol = lerp(col, rcol, sin(iTime * 1.0) / 2.0 + 0.5);\n\n    fragColor = vec4(outcol ,1.0);\n}\n\nvoid mainForHSL( out vec4 fragColor, in vec2 uv )\n{   \n    float maxChroma = 1.0 - abs(uv.y - 0.5) * 2.0;\n    maxChroma *= sqrt(3.0) / 2.0;\n    uv.x /= lerp(1.0, maxChroma, sin(iTime / 2.0) / 2.0 + 0.5);\n    \n    if (uv.x > 1.0)\n    {\n        fragColor = vec4(0.0, 0.0, 0.0 ,1.0);\n        return;\n    }\n\n    float res = 128.0;\n\n    vec3 col = floor(res * HSLtoRGB(vec3(0.0, uv.xy))) / res;\n    vec3 rcol = vec3(random(col.xyz), random(col.yzx), random(col.zxy));\n    \n    vec3 outcol = lerp(col, rcol, sin(iTime * 1.0) / 2.0 + 0.5);\n\n    fragColor = vec4(outcol ,1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    if (uv.x < 0.5)\n    {\n        mainForHSL(fragColor, vec2(uv.x * 2.0, uv.y));\n    }\n    else\n    {\n        mainForHSV(fragColor, vec2((uv.x - 0.5) * 2.0, uv.y));\n    }\n}","name":"Image","description":"","type":"image"}]}