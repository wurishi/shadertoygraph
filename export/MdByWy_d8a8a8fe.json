{"ver":"0.1","info":{"id":"MdByWy","date":"1493570972","viewed":199,"name":"Cube : Blending","username":"JCDjcd","description":"Compute translucidity by blending the nearest 10 points of ray-tracing.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["cube","blending"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//--------------------------------------------------------------------------\nfloat intersect(in vec3 A,in vec3 B,in vec3 C,in vec3 P,in vec3 n)\n{\n    vec3 u = B-A;\n    vec3 v = C-A;\n    vec3 w = -n;\n    vec3 s = P-A;\n    float det \t= u.x*v.y*w.z\n        \t\t+ v.x*w.y*u.z\n        \t\t+ w.x*u.y*v.z\n              \t- w.x*v.y*u.z\n        \t\t- v.x*u.y*w.z\n        \t\t- u.x*w.y*v.z;\n    if(abs(det) < 1e-6)\n        return -1000.0;\n    float cm_ux = v.y*w.z-v.z*w.y;\n    float cm_vx = u.z*w.y-u.y*w.z;\n    float cm_wx = u.y*v.z-u.z*v.y;\n    float cm_uy = v.z*w.x-v.x*w.z;\n    float cm_vy = u.x*w.z-u.z*w.x;\n    float cm_wy = u.z*v.x-u.x*v.z;\n    float cm_uz = v.x*w.y-v.y*w.x;\n    float cm_vz = u.y*w.x-u.x*w.y;\n    float cm_wz = u.x*v.y-u.y*v.x;\n    \n    float p = (cm_ux*s.x+cm_uy*s.y+cm_uz*s.z)/det;\n    float q = (cm_vx*s.x+cm_vy*s.y+cm_vz*s.z)/det;\n    float t = (cm_wx*s.x+cm_wy*s.y+cm_wz*s.z)/det;\n\n    if(p >= 0.0 && p <= 1.0 && q >= 0.0 && q <= 1.0)\n    {\n    \treturn t;\n    }\n    else\n    {\n        return -1000.0;\n    }\n} // intersect()\n\n//--------------------------------------------------------------------------\nvec3 Rz(in vec3 u,float alpha)\n{\n    float c = cos(alpha);\n    float s = sin(alpha);\n    float x = c*u.x-s*u.y;\n    float y = s*u.x+c*u.y;\n    float z = u.z;\n    return vec3(x,y,z);\n} // Rz()\n\n//--------------------------------------------------------------------------\nvec3 Ry(in vec3 u,float alpha)\n{\n    float c = cos(alpha);\n    float s = sin(alpha);\n    float z = s*u.z+c*u.x;\n    float x = c*u.z-s*u.x;\n    float y = u.y;\n    return vec3(x,y,z);\n} // Ry()\n\n//--------------------------------------------------------------------------\nstruct CubeSide\n{\n    vec3 A;\n    vec3 B;\n    vec3 C;\n    vec4 color;\n}; // struct CubeSide\n\n//--------------------------------------------------------------------------\nstruct Transformation\n{\n    float scale;\n    float theta;\n    float phi;\n    vec3  translation;\n}; // struct Transformation\n    \n//--------------------------------------------------------------------------\nvec4 compute(in vec3 P, in vec3 n)\n{        \n    // Definition of the cube :\n    CubeSide sides[6];\n    \n\t// top and bottom sides\n    sides[0].A \t\t= vec3(-1.0,-1.0,-1.0);\n    sides[0].B \t\t= vec3( 1.0,-1.0,-1.0);\n    sides[0].C \t\t= vec3(-1.0, 1.0,-1.0);\n    sides[0].color \t= vec4( 0.0, 0.0, 1.0 ,1.0); \t// blue\n    sides[1].A \t\t= vec3(-1.0,-1.0, 1.0);\n    sides[1].B \t\t= vec3( 1.0,-1.0, 1.0);\n    sides[1].C \t\t= vec3(-1.0, 1.0, 1.0);\n    sides[1].color \t= vec4( 1.0, 1.0, 0.0, 1.0); \t// yellow\n\t// front and rear sides\n    sides[2].A \t\t= vec3(-1.0,-1.0,-1.0);\n    sides[2].B \t\t= vec3(-1.0, 1.0,-1.0);\n    sides[2].C \t\t= vec3(-1.0,-1.0, 1.0);\n    sides[2].color \t= vec4( 1.0, 0.0, 0.0, 1.0); \t// red\n    sides[3].A \t\t= vec3( 1.0,-1.0,-1.0);\n    sides[3].B \t\t= vec3( 1.0, 1.0,-1.0);\n    sides[3].C \t\t= vec3( 1.0,-1.0, 1.0);\n    sides[3].color \t= vec4( 0.0, 1.0, 1.0, 1.0); \t// cyan\n\t// left and right sides\n    sides[4].A \t\t= vec3(-1.0,-1.0,-1.0);\n    sides[4].B \t\t= vec3( 1.0,-1.0,-1.0);\n    sides[4].C \t\t= vec3(-1.0,-1.0, 1.0);\n    sides[4].color \t= vec4( 0.0, 1.0, 0.0, 1.0); \t// green\n    sides[5].A \t\t= vec3(-1.0, 1.0,-1.0);\n    sides[5].B \t\t= vec3( 1.0, 1.0,-1.0);\n    sides[5].C \t\t= vec3(-1.0, 1.0, 1.0);\n    sides[5].color \t= vec4( 1.0, 0.0, 1.0, 1.0); \t// magenta\n\n    // Transformation for the three cubes\n    Transformation transformations[3];\n    \n    transformations[0].scale \t\t= 1.0;\n    transformations[0].theta \t\t= 0.0;\n    transformations[0].phi \t\t\t= 0.0;\n    transformations[0].translation \t= vec3(0.0,0.0,0.0);\n    \n    transformations[1].scale \t\t= 0.50;\n    transformations[1].theta \t\t= 3.1415926535*0.25;\n    transformations[1].phi \t\t\t= 3.1415926535*1.25;\n    transformations[1].translation \t= vec3(0.0,0.0,0.0);\n    \n    transformations[2].scale \t\t= 0.25;\n    transformations[2].theta \t\t= 0.0;\n    transformations[2].phi \t\t\t= 0.0;\n    transformations[2].translation \t= vec3(0.0,0.0,0.0);\n    \n\t// In order to perform the blending, we sort the nearest 10 intersections\n    float \tt_min[10];\n    vec4  \tcolor[10];\n    vec3    point[10];\n    int \tk;\n    for(k=0;k<10;k++)\n    {\n\t    t_min[k] = +1000.0;\n        color[k] = vec4(0.0,0.0,0.0,1.0);\n        point[k] = vec3(0.0,0.0,0.0);\n    } // for()\n    \n    int   i,j;\n    for(i=0;i<6;i++) // loop on each cube sides\n    {\n        for(j=0;j<3;j++) // loop on each cube\n        {\n            vec3 A = transformations[j].translation + transformations[j].scale*Ry(Rz(sides[i].A,transformations[j].theta),transformations[j].phi);\n            vec3 B = transformations[j].translation + transformations[j].scale*Ry(Rz(sides[i].B,transformations[j].theta),transformations[j].phi);\n            vec3 C = transformations[j].translation + transformations[j].scale*Ry(Rz(sides[i].C,transformations[j].theta),transformations[j].phi);\n            // Compute the intersection with that side.\n            // If behing the observer direction, don't take it into account.\n            float t = intersect(A,B,C,P,n);\n            if(t > 0.0 && t < t_min[9])\n            {\n                // put that value at the end of the sorted array\n                t_min[9] = t;\n                color[9] = sides[i].color;\n                // then re-sort the array\n                point[9] = P+t*n;\n                for(k=8;k>=0;k--)\n                {\n                    if(t_min[k+1] < t_min[k])\n                    {\n                        // swap k and k+1\n                        float tmp_t_min = t_min[k];\n                        vec4  tmp_color = color[k];\n                        vec3  tmp_point = point[k];\n                        \n                        t_min[k] \t\t= t_min[k+1];\n                        color[k] \t\t= color[k+1];\n                        point[k] \t\t= point[k+1];\n                        \n                        t_min[k+1] \t\t= tmp_t_min;\n                        color[k+1] \t\t= tmp_color;\n                        point[k+1] \t\t= tmp_point;\n                 \t}\n             \t} // for()\n            }\n        } // for()\n    } // for()\n\n    // now compute the render color base on the sorted intersections\n    vec4  c \t\t\t= vec4(0.0,0.0,0.0,1.0);\n    float decay_factor \t= 0.7;\n    float decay \t\t= 1.0;\n    float dr \t\t\t= 0.5;\n    float dt \t\t\t= 3.0;\n    for(k=0;k<10;k++)\n    {\n        decay \t\t\t   *= decay_factor;\n        float r = sqrt(point[k].x*point[k].x+point[k].y*point[k].y+point[k].z*point[k].z);\n        float attenuation \t= 0.5+0.5*cos(2.0*3.1415926535*((r/dr)-(iTime/dt)));\n        attenuation \t\t= pow(attenuation,10.0);\n        attenuation \t\t= 0.2+0.8*attenuation;\n        c \t\t\t\t   += decay*attenuation*color[k];\n    } // for()\n    \n    return vec4(c.xyz,1.0);\n} // compute()\n\n//--------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor,vec2 fragCoord)\n{\n    float m \t\t= min(iResolution.x,iResolution.y);\n\tvec2 uv \t\t= (fragCoord.xy / m - vec2(0.5,0.5))*4.5;\n    vec3 P \t\t\t= vec3(uv.x,uv.y,-5.0);\n    vec3 n      \t= vec3(0.0,0.0,1.0);\n    float alpha1\t= iTime*3.1415926535*2.0/17.0;\n    float alpha2\t= iTime*3.1415926535*2.0/5.0;\n    P \t\t\t\t= Ry(P,alpha1);\n    P \t\t\t\t= Rz(P,alpha2);\n    n\t \t\t\t= Ry(n,alpha1);\n    n \t\t\t\t= Rz(n,alpha2);\n\tfragColor \t\t= compute(P,n);\n} // mainImage()\n\n","name":"Image","description":"","type":"image"}]}