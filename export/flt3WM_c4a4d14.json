{"ver":"0.1","info":{"id":"flt3WM","date":"1636200306","viewed":132,"name":"try DFT","username":"yunhai","description":"line1-value noise\nline2-DFT combines with IDFT\nline3-more and more accurate DFT for a cycle","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["math","dft"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//---------------------Lines-------------------\nfloat line(vec2 uv,vec2 ori,vec2 dir)\n{\n    return SL(length(uv-(dot(uv-ori,dir)*dir+ori)));\n}\nvec3 cartesian(vec2 uv)\n{\n    vec3 col=vec3(0.);\n    float msp=MSI;\n    float lhlw=HLW/2.;//local HLW\n    vec3 mesh=vec3(SS(lhlw+2.*PIXW,lhlw-PIXW,abs(uv.x-round(uv.x/msp)*msp)));\n    mesh+=vec3(SS(lhlw+2.*PIXW,lhlw-PIXW,abs(uv.y-round(uv.y/msp)*msp)));\n    col+=mesh*.5;\n    col=mix(col,vec3(0.,1.,0.),line(uv,vec2(0.,-16.),vec2(1.,0.)));\n    col=mix(col,vec3(0.,1.,0.),line(uv,vec2(0.,-10.),vec2(1.,0.)));\n    col=mix(col,vec3(0.,1.,0.),line(uv,vec2(0.,0.),vec2(1.,0.)));\n    col=mix(col,vec3(0.,1.,0.),line(uv,vec2(0.),vec2(0.,1.)));\n    return col;\n}\n//----------------------------------------------\n\n//-------------------experiment-----------------\n//sample length\n#define L 10.\n//sample num\n#define S 50.\nfloat svalueNoise(float t)\n{\n    float a=floor(t),b=a+1.;t-=a;\n    t=t*t*(3.-2.*t);\n    return mix(hash(a),hash(b),t);\n}\n//here to change function\nfloat map(float x)\n{\n    return svalueNoise(x-iT)*3.;\n}\nvec2 dots(float l,float s,float k)\n{\n    float dl=l/s,re=0.,im=0.;\n    for(float i=0.;i<s;i++)\n    {\n        float x=i*dl;\n        re+=map(x)*cos(2.*PI*x/l*k);\n        im+=map(x)*sin(2.*PI*x/l*k);\n    }\n    return vec2(re,-im);\n}\n//two channels is just for drawing\nvec2 dft(float x)\n{\n    float l=L,s=S,dx=l/s,r1=0.,r2=0.;\n    \n    for(float i=1.;i<s*.5;i++)//.5s is because of Nyquist\n    {\n        vec2 v=dots(l,s,i);\n        float phi=atan(v.y,v.x),ten=length(v);\n        float part=ten*cos(2.*PI*x*i/L+phi);\n        r1+=part;\n        r2+=part*step(i,mod(iT*2.,s*.5));\n    }\n    return (vec2(r1,r2)+length(dots(l,s,0.))*.5)/(s*.5);\n}\nvoid setO(inout vec2 uv,inout float x,inout float y)\n{\n    x=uv.x;y=uv.y;\n}\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    vec2 uv=(C-vec2(iR.x*.1,iR.y*.5))*PIXW;uv.y-=5.;\n    float x,y,t=iTime*.5;\n    O.rgb=cartesian(uv);\n    \n    setO(uv,x,y);\n    float f=map(x);\n    O.rgb=mix(O.rgb,vec3(.4,.7,1.),\n          SL(abs(f-y)*LWF(f)));\n         \n    uv.y+=10.;   \n    setO(uv,x,y);\n    vec2 res=dft(x);\n    f=res.x;\n    float seg=min(1.,2.*abs(x-clamp(x,0.,L)));seg*=seg;\n    O.rgb=mix(O.rgb,mix(vec3(1.,.7,.3),vec3(.4,.7,1.),seg),\n         SL(abs(f-y)*LWF(f)));\n         \n    uv.y+=6.;\n    setO(uv,x,y);\n    f=res.y;\n    O.rgb=mix(O.rgb,mix(vec3(1.,.7,.3),vec3(.4,.7,1.),seg),\n         SL(abs(f-y)*LWF(f)));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define iR iResolution.xy\n#define iM iMouse\n#define iT iTime\n#define PIXW (CANVAS_WIDTH/iR.x)\n#define SS(a,b,t) smoothstep(a,b,t)\n#define SL(d) smoothstep(HLW+PIXW,HLW-PIXW,d)\n#define HLW (LW*.5)\nconst float PI=3.14159265;\n/*-----------DrawingSettings-----------*/\nconst float CANVAS_WIDTH=40.;\nconst float LW=.13;//line width\nconst float MSI=2.;//mesh space interval\n/*-----------utilities-----------*/\n//Line Width Fixer\n#define LWF(y) (normalize(vec2(PIXW,dFdx(y))).x)\n\nfloat hash(float t){return fract(sin(t*123.)*8731.);}\nfloat valueNoise(float t)\n{\n    float a=floor(t),b=a+1.;\n    return mix(hash(a),hash(b),t-a);\n}\n","name":"Common","description":"","type":"common"}]}