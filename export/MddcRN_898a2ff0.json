{"ver":"0.1","info":{"id":"MddcRN","date":"1518113520","viewed":205,"name":"Julia folder","username":"Fra32","description":"\"Folds\" a julia fractal from a circle. Automatically timelapses after a while. Timelapse and operation speed can be adjusted, the seed is specified using the mouse. The overlay maps all solid julia fractals at the current iteration(Overlay offset to fit).","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Change these as you desire\nfloat shiftTime = 1.;\nfloat rootTime = 1.;\nfloat timeLapseStart = 10.;\nfloat timeLapseDur = 10.;\nfloat timeLapseIter = 200.;\nfloat sloMoSpeed = .5;\nfloat mandelbrotOverlayOpacity = .75;\n\n\n\n\nvec2 c = vec2(cos(0.2)*.25-1.,sin(0.2)*.25);\nfloat tau = radians(360.);\n\nfloat arg(vec2 p){\n return acos(dot(normalize(p),vec2(1,0)));\n}\n\nvec3 grid(vec2 p, vec3 c){\n    float len = length(p);\n    float arg = arg(p);\n    if(mod(arg*16.+0.125/len,tau)<0.25/len||\n       mod(len+0.0125,.25)<0.025)\n    \treturn c;   \n    \n    return vec3(1.);\n    \n    \n    \n}\nvec2  offset = vec2(1,0);\nvec3 julia(vec2 p){\n    float t = iTime+(timeLapseIter-iTime*(1.-sloMoSpeed))*smoothstep(0.,1.,smoothstep(0.,1.,clamp(iTime-timeLapseStart,0.,timeLapseDur)/timeLapseDur));\n    int fullIter = int(t/(shiftTime+rootTime));\n    float partIter = mod(t,shiftTime+rootTime);\n    \n    vec2 p2 = vec2(p);\n    vec2 p3 = vec2(0.);\n    vec2 c2 = .5*vec2(p)-offset;\n    vec3 gridCol1 = vec3(1);\n    vec3 gridCol2 = vec3(1);\n    float ang2 = 0.;\n    if(partIter >= shiftTime){\n        float prog = smoothstep(0.,1.,(partIter-shiftTime)/rootTime);\n        float len = length(p);\n        float ang = arg(p);\n        if(p.y<0.)\n            ang = tau-ang;\n        float a = pow(2.,prog);\n        ang *= a;\n        ang2 = ang+tau*a;\n        len = pow(len,prog+1.);\n        p = len*vec2(cos(ang),sin(ang));\n        p2 = len*vec2(cos(ang2),sin(ang2));\n    }\n    \n    gridCol1 = grid(p,vec3(0,.6,.9));\n    gridCol2 = grid(p2,vec3(0,.6,.9));\n    \n    if(partIter < shiftTime){\n        p += c*smoothstep(0.,1.,partIter/shiftTime);\n        p2 += c*smoothstep(0.,1.,partIter/shiftTime);\n    }else{\n        p += c;\n        p2 += c;\n    }\n    \n    \n    for(int i = 0;i<fullIter;i++){\n        if(length(p)<4.)\n        p = vec2(pow(p.x,2.)-pow(p.y,2.),2.*p.x*p.y)+c;\n        if(length(p2)<4.)\n        p2 = vec2(pow(p2.x,2.)-pow(p2.y,2.),2.*p2.x*p2.y)+c;\n        if(length(p3)<4.)\n        p3 = vec2(pow(p3.x,2.)-pow(p3.y,2.),2.*p3.x*p3.y)+c2;\n    }\n    \n    vec3 col1 = vec3(0.);\n    vec3 col2 = vec3(0.);\n    vec3 col3 = vec3(.75,.5,.5);\n    \n    if(length(p)>2.)\n        col1 = vec3(1.);\n    if(length(p2)>2.)\n        col2 = vec3(1.);\n    if(length(p3)>2.||distance(4.*(iMouse.zw-iResolution.xy/2.)/iResolution.x,vec2(0,0))>3.||iMouse.x==0.&&iMouse.y==0.)\n        col3 = vec3(1.);\n    if(ang2>2.*tau){\n    \tcol2 = gridCol2 = vec3(1);\n    }\n    if(col3 == vec3(1.))\n    \treturn (col1*gridCol1+col2*gridCol2)/2.;\n    else\n    \treturn mix((col1*gridCol1+col2*gridCol2)/2.,col3,mandelbrotOverlayOpacity);\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\tif(iMouse.x==0. && iMouse.y==0.)\n    c = vec2(-1,0.24);\n    else\n    c = 4.*(iMouse.xy-iResolution.xy/2.)/iResolution.x-offset;\n    vec2 uv = 8.*(fragCoord-iResolution.xy/2.)/iResolution.x;\n\n    vec3 col = julia(uv);\n \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}