{"ver":"0.1","info":{"id":"DssGR2","date":"1666459773","viewed":135,"name":"Square, Rectangle SDF L1,L2,Linf","username":"Envy24","description":"You can apply rotation for L1 and Linf cases (similarly to L2 case), but you don't get correct sdf.\nHere you can see how L1 and Linf metrics behave with oriented primitives:\nhttps://www.shadertoy.com/view/fdKyD3\nhttps://www.shadertoy.com/view/NdVcW3","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf","square","rectangle","l1","l2","linf"],"hasliked":0,"parentid":"ddfGz2","parentname":"Distance field coloring"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define AR                        ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define NZMX                      ( (iMouse.x+iMouse.x-R.x) / R.x )  // in range [-1.0; 1.0]\n#define NZMY                      ( (iMouse.y+iMouse.y-R.y) / R.y )  // in range [-1.0; 1.0]\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define FIELD_SCALE                 2.0\n#define PI                          3.1415926535897932\n\n/* L2 square with rotation. *\n#define METRIC(B, E) ( L2(B, E) )\n#define SQUARE(NDC, C, size) ( squareSDF_L2(NDC, C, size) )\n\nfloat squareSDF_L2(\n    in vec2 NDC,\n    in vec2 C,\n    in float size)\n{\n    float angle = sinOSC(0.0, 1., iTime*0.5) * PI;  \n    float c = cos(-angle), s = sin(-angle);\n          NDC = mat2(c, s, -s, c) * NDC;\n         \n    vec2 P = abs(NDC-C), B = vec2(size*0.5);\n    \n    float R = sinOSC(0.0, 1.5, iTime*0.5);   \n    return \n        (P.x > B.x && P.y > B.y ?\n            length(P-B) :\n            max(P.x-B.x, P.y-B.y)) - R;\n        \n}\n/* L2 rectangle with rotation. */\n#define METRIC(B, E) ( L2(B, E) )\n#define RECTANGLE(NDC, C, R, rad) ( rectangleSDF_L2(NDC, C, R, rad) )\n#define W (2.)\n#define H (0.1)\n#define RAD ( sinOSC(0., 1., iTime*0.5)*PI )\nfloat rectangleSDF_L2(\n    in vec2 NDC,\n    in vec2 C,\n    in vec2 R,\n    in float radians)\n{\n    float c = cos(-radians), s = sin(-radians);\n         NDC = mat2(c, s, -s, c) * NDC;\n         \n    vec2 P = abs(NDC-C), B = C+R*0.5;\n\n    float r = sinOSC(0.0, 1.2, iTime*0.5);\n    //return length(max(P-B, vec2(0))) + min(max(P.x-B.x, P.y-B.y), 0.) - r;\n    return \n        (P.x > B.x && P.y > B.y ?\n            length(P-B) :\n            max(P.x-B.x, P.y-B.y)) - r;\n}\n/* Linf square without rotation *\n#define METRIC(B, E) ( Linf(B, E) )\n#define SQUARE(NDC, C, size) ( squareSDF_Linf(NDC, C, size) )\nfloat squareSDF_Linf(\n    in vec2 NDC,\n    in vec2 C,\n    in float size)\n{\n    vec2 P = abs(NDC-C), B = vec2(size*0.5);\n    \n    float R = sinOSC(0.0, 1.5, iTime*0.5);\n    return max(P.x-B.x, P.y-B.y) - R;       \n}\n/* Linf rectangle without rotation *\n#define METRIC(B, E) ( Linf(B, E) )\n#define RECTANGLE(NDC, C, R, rad) ( rectangleSDF_Linf(NDC, C, R, rad) )\n#define W (2.)\n#define H (0.1)\n#define RAD ( 0. )\nfloat rectangleSDF_Linf(\n    in vec2 NDC,\n    in vec2 C,\n    in vec2 R,\n    in float radians)\n{\n    vec2 P = abs(NDC-C), B = C+R*0.5;\n    \n    float r = sinOSC(0.0, 1.2, iTime*0.5);   \n    return max(P.x-B.x, P.y-B.y) - r;\n}\n/* L1 square without rotation *\n#define METRIC(B, E) ( L1(B, E) )\n#define SQUARE(NDC, C, size) ( squareSDF_L1(NDC, C, size) )\nfloat squareSDF_L1(\n    in vec2 NDC,\n    in vec2 C,\n    in float size)\n{\n    vec2 P = abs(NDC-C), B = vec2(size*0.5);\n           \n    float d0 = segmentSDF_L1(P, vec2(0, B.y), B, 0.),\n          d1 = segmentSDF_L1(P, vec2(B.x, 0), B, 0.),\n          sign = P.x < B.x && P.y < B.y ? -1. : 1.;\n\n    float R = sinOSC(0.0, 1.5, iTime*0.5);\n    return sign*min(d0, d1) - R;       \n}\n/* L1 rectangle without rotation *\n#define METRIC(B, E) ( L1(B, E) )\n#define RECTANGLE(NDC, C, R, rad) ( rectangleSDF_L1(NDC, C, R, rad) )\n#define W (2.)\n#define H (0.1)\n#define RAD ( sinOSC(0., 2.*PI, iTime*0.5) )\nfloat rectangleSDF_L1(\n    in vec2 NDC,\n    in vec2 C,\n    in vec2 R,\n    in float radians)\n{\n    vec2 P = abs(NDC-C), B = C+R*0.5;\n    \n    float d0 = segmentSDF_L1(P, vec2(0, B.y), B, 0.),\n          d1 = segmentSDF_L1(P, vec2(B.x, 0), B, 0.),  \n          sign = P.x < B.x && P.y < B.y ? -1. : 1.;\n    \n    float r = sinOSC(0.0, 1.2, iTime*0.5);   \n    return sign*min(d0, d1) - r;\n}\n/**/\n\nvec3 colorize_field(float dist, vec3 color)\n{    \n    float F = 30., freq = F*dist, aa = 1./F, C = 0.7, amp = 0.2, width = 0.3,\n          curves_sdf = C + amp*smoothstep(4./R.y, 0., (width+cos(freq)) * aa),\n          exp_raise = 1. - exp(-4.*abs(dist));\n        \n    color = 1.0 - sign(dist) * color; // Change color if dist is negative. \n    color *= exp_raise;               // Attenuate color around edges.     \n    color *= curves_sdf;              // Add interleaved curves.\n    \n    return mix(color, vec3(1), smoothstep(6./R.y, 0., abs(dist)) );\n}\n\nvec3 add_metric_function(\n    vec2 NDC,\n    vec3 color)\n{\n    float unit = 7.0 / R.y;\n\n    vec2 M = \n        LMB_IS_HOLD ?\n            TO_CENTERED_NDC(iMouse.xy) * FIELD_SCALE :\n            rotateAroundZ(vec2(1, 0), iTime * 0.5) * 1.5;\n            //vec2(0);\n    \n    //M=vec2(0.0, 0.0);\n    \n    // Add point\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(NDC - M) - 0.008));\n\n#ifdef SQUARE\n    float dist_form_point_to_box_edge = METRIC(NDC, M) - abs(SQUARE(M, vec2(0), 1.));\n#endif\n#ifdef RECTANGLE\n    float dist_form_point_to_box_edge = METRIC(NDC, M) - abs(RECTANGLE(M, vec2(0), vec2(W, H), RAD));\n#endif\n    float outline = abs(dist_form_point_to_box_edge);\n    \n    // Add metric function\n    return mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, outline));\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = TO_CENTERED_NDC(SC) * FIELD_SCALE;\n#ifdef SQUARE\n    float minDist = SQUARE(NDC, vec2(0), 1.);\n#endif\n#ifdef RECTANGLE\n    float minDist = RECTANGLE(NDC, vec2(0), vec2(W, H), RAD);\n#endif\n    \n    vec3 color = vec3(0.15, 0.33, 0.95);\n    \n    color = colorize_field(minDist, color); \n    color = add_metric_function(NDC, color);\n\n    O = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nvec2 rotateAroundZ(vec2 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    return vec2(\n        p.x * c - p.y * s,\n        p.y * c + p.x * s);\n}\n\nfloat L1(vec2 B, vec2 E)\n{\n    vec2 D = E - B;\n    return abs(D.x) + abs(D.y);\n}\n\nfloat L2(vec2 B, vec2 E)\n{\n    vec2 D = E - B;\n    return sqrt(D.x*D.x + D.y*D.y);\n}\n\nfloat Linf(vec2 B, vec2 E)\n{\n    vec2 D = E - B;\n    return max(abs(D.x), abs(D.y));\n}\n\n#define P(t) (S + (E - S)*t)\nfloat segmentSDF_L1(\n    vec2 NDC,\n    vec2 S,\n    vec2 E,\n    float R)\n{\n    float invD0 = 1.0 / (S.y-E.y);\n    return min(L1(P(clamp((NDC.x-S.x) / (E.x-S.x), 0.0, 1.0)), NDC), \n               min(L1(P(clamp((NDC.y+S.y) * invD0, 0.0, 1.0)), NDC),\n                   L1(P(clamp((S.y-NDC.y) * invD0, 0.0, 1.0)), NDC))) - R;\n}\n\nfloat segmentSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E,\n    float R)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - R;\n}\n\nfloat segmentSDF_Linf(\n    vec2 NDC,\n    vec2 S,\n    vec2 E,\n    float R)\n{\n    return min(Linf(P(clamp((S.y-S.x+NDC.x-NDC.y)/(E.x-S.x+S.y-E.y), 0.0, 1.0)), NDC), \n               Linf(P(clamp((S.y-NDC.y+S.x-NDC.x)/(S.x-E.x+S.y-E.y), 0.0, 1.0)), NDC)) - R;\n}","name":"Common","description":"","type":"common"}]}