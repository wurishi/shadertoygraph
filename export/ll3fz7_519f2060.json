{"ver":"0.1","info":{"id":"ll3fz7","date":"1539030190","viewed":152,"name":"sphere tracing 2","username":"stuxxnet42","description":"sphere tracing 2","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["simplespheretracingexample"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//threshold for hit testing\nconst float epsilon = 1.;\n\n// Distance field of a sphere at c with radius r, sampled at p.\nfloat sphere(vec3 c, float r, vec3 p) {\n\treturn length(p - c) - r;\n}\n// The Scene\nfloat distanceField(vec3 pos) {\n\tfloat s1 = sphere(vec3(1.0,1.0,0.0), 100., pos);\n\treturn s1;\n}\n\n// Approximates the normal vector at pos.\nvec3 distanceFieldNormal(vec3 pos) {\n\t// Method of central differences.\n\tconst float s = 1. / 2.;\n\t\n\tvec3 n = vec3(distanceField(pos + vec3(s, 0, 0)) - distanceField(pos - vec3(s, 0, 0)),\n\t\t\t\t  distanceField(pos + vec3(0, s, 0)) - distanceField(pos - vec3(0, s, 0)),\n\t\t\t\t  distanceField(pos + vec3(0, 0, s)) - distanceField(pos - vec3(0, 0, s)));\n\treturn normalize(n);\n}\n\n\n// Light source intensity\nconst float i_a = 0.3;\nconst float i_d = 0.6;\nconst float i_s = 0.4;\n\n// Material reflectiveness and color\nconst float k_a = 0.6;\nconst float k_d = 0.7;\nconst float k_s = 0.8;\nconst float alpha = 8.;\nconst vec3 matColor = vec3(1, 0.8, 0.3);\n\nconst vec3 lightpos = vec3(0.3, 1.0, 0.0);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat near = -iResolution.x * 1.2 / 2.;\n\tfloat far  =  iResolution.x * 1.2 / 2.;\n\t\n\tvec3 cameraPosition = vec3(0, 0, -1);\n\t\n\tvec3 pos = vec3(fragCoord.xy - iResolution.xy / 2., near);\n\t\n\tvec3 npos = pos / iResolution.x;\n\t\n\tvec3 dir = normalize(npos - cameraPosition);\n\tvec3 toEye = -dir;\n\tfragColor = vec4(0.0, 0.0, 0.0, 1);\n    int stepsTaken = 0;\n    for (int steps = 0; steps < 50; ++steps) {\n\t\tstepsTaken = steps;\n\t\tfloat d = distanceField(pos);\n\n\t\tif (d < epsilon) {\n            vec3 normal = distanceFieldNormal(pos);\n\t\t\tvec3 nl_m = normalize(lightpos);\n\t\t\tvec3 r_m = -reflect(nl_m, normal);\n            \n            float ambient = i_a * k_a;\n\t\t\tfloat diffuse = i_d * k_d * max(dot(nl_m, normal), 0.);\n\t\t\tfloat spec    = i_s * k_s * pow(max(dot(r_m, toEye), 0.), alpha);\n            \n            vec3 light = matColor * (ambient + diffuse) + spec;\n            \n\t\t\tfragColor = vec4(light, 1);\n\t\t\treturn;\n\t\t} else {\n\t\t\tpos += d * dir;\n\t\t}\n\t}\n}","name":"Image","description":"","type":"image"}]}