{"ver":"0.1","info":{"id":"ctSyRt","date":"1692810416","viewed":94,"name":"OKLCH Color Picker","username":"rcmz","description":"A perceptual color picker\nhttps://bottosson.github.io/posts/colorpicker/","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["colorpicker","oklab","oklch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float PI = 3.14159265358979323846;\n\nfloat transfer(float v) {\n    return v <= 0.0031308 ? 12.92 * v : 1.055 *pow(v, 0.4166666666666667) - 0.055;\n}\n\nvec3 transfer(vec3 v) {\n    return vec3(transfer(v.x), transfer(v.y), transfer(v.z));\n}\n\nvec3 hcl2rgb(vec3 hcl) {\n    hcl.y *= 0.33;\n    \n    vec3 lab = vec3(\n        hcl.z,\n        hcl.y * cos(hcl.x * PI*2.0),\n        hcl.y * sin(hcl.x * PI*2.0)\n    );\n    \n    vec3 lms = vec3(\n        lab.x + 0.3963377774f * lab.y + 0.2158037573f * lab.z,\n        lab.x - 0.1055613458f * lab.y - 0.0638541728f * lab.z,\n        lab.x - 0.0894841775f * lab.y - 1.2914855480f * lab.z\n    );\n    \n    lms = pow(max(lms, vec3(0.0)), vec3(3.0));\n    \n    vec3 rgb = vec3(\n        +4.0767416621f * lms.x - 3.3077115913f * lms.y + 0.2309699292f * lms.z,\n        -1.2684380046f * lms.x + 2.6097574011f * lms.y - 0.3413193965f * lms.z,\n        -0.0041960863f * lms.x - 0.7034186147f * lms.y + 1.7076147010f * lms.z\n    );\n     \n    rgb = transfer(rgb);\n    \n    if (any(lessThan(rgb, vec3(0.0))) || any(greaterThan(rgb, vec3(1.0)))) {\n        rgb = vec3(0.5);\n    }\n\n    return rgb;\n}\n\nvec2 uv2xy(vec2 uv) {\n    return ((uv * vec2(iResolution.x / iResolution.y, 1.0)) * 2.0 - 1.0);\n}\n\nbool ring(vec2 xy, out float t) {\n    t = atan(xy.y, xy.x) / (PI * 2.0) - 0.25;\n    float r = length(xy);\n    return r > 0.8 && r < 0.9;\n}\n\nbool square(vec2 xy, out vec2 ab) {\n    ab = xy;\n    ab = ab / (0.7 / sqrt(2.0));\n    ab = (ab + 1.0) / 2.0;\n    bool isIn = all(greaterThan(ab, vec2(0.0))) && all(lessThan(ab, vec2(1.0)));\n    ab = clamp(ab, vec2(0.0), vec2(1.0));\n    return isIn;\n}\n\nvec4 changeState(vec4 state) {\n    bool grabbedRing = state.w == 1.0;\n    bool grabbedSquare = state.w == 2.0;\n    \n    vec2 mouseXY = uv2xy((iMouse.xy + vec2(0.5)) / iResolution.xy);\n    bool clicked = iMouse.w > 0.0;\n\n    float mouseT;\n    bool mouseInRing = ring(mouseXY, mouseT);\n    \n    vec2 mouseAB;\n    bool mouseInSquare = square(mouseXY, mouseAB);\n    \n    if (clicked) {\n        grabbedRing = mouseInRing;\n        grabbedSquare = mouseInSquare;\n    }\n    \n    if (grabbedRing) {\n        state.x = mouseT;\n    }\n\n    if (grabbedSquare) {\n        state.zy = mouseAB;\n    }\n    \n    state.w = 0.0;\n    if (grabbedRing) state.w = 1.0;\n    if (grabbedSquare) state.w = 2.0;\n    \n    return state;\n}\n\nvec3 getHCL(vec4 state, vec2 fragCoord) {\n    vec2 fragXY = uv2xy(fragCoord / iResolution.xy);\n \n    vec3 hcl = state.xyz;\n    \n    float fragT;\n    if (ring(fragXY, fragT)) {\n        if (abs(fragT - hcl.x) < 0.002) {\n            return vec3(0.0, 0.0, 1.0);\n        }\n        return vec3(fragT, 0.38, 0.75);\n        //bool isReachable = hcl2rgb(vec3(fragT, state.yz)) != vec3(0.5);\n        //return vec3(fragT, 0.33, isReachable ? 0.78 : 0.65);\n    }\n\n    vec2 fragAB;\n    if (square(fragXY, fragAB)) {\n        if (distance(fragAB, hcl.zy) < 0.02){\n            return vec3(0.0, 0.0, 1.0);\n        }\n        return vec3(hcl.x, fragAB.yx);\n    }\n\n    if (fragXY.x > 1.0) {\n        return hcl;\n    }\n\n    return vec3(0.0, 0.0, 0.5);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec4 state = texture(iChannel0, vec2(0.5) / iResolution.xy);\n    \n    if (ivec2(fragCoord) == ivec2(0)) {\n        fragColor = changeState(state);\n    } else {\n        fragColor.rgb = hcl2rgb(getHCL(state, fragCoord));\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}