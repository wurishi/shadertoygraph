{"ver":"0.1","info":{"id":"3sKfWy","date":"1676299731","viewed":111,"name":"Gyroid Render","username":"Yoghurtghost","description":"A render of a small piece of Gyroid structure, as approximated by the function f(x,y,z) = sin(x)cos(y) + sin(y)cos(z) + sin(z)cos(x) < thickness.\n\nDrag your mouse over the screen to change the viewing direction.\n\n\n","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["gyroid","dynamicligting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI\t\t\t 3.14159265358\n#define farclip\t\t50.\n#define swirl\t\t 0.0\n#define Scale \t\t 3.14159265358/1.0\n#define thickness\t 0.02\n#define orbit\t\t 1.0\n#define iterations\t 100\n#define cube         2.0\n#define sun          0.1\n\n\n//Define transformation matrices for rotations around x, y and z axis.\nmat3 ROTX(float a){\n\tmat3 rot = mat3(1., 0., 0., 0., cos(a), -sin(a), 0., sin(a), cos(a));\n    return rot;\n}\n\nmat3 ROTY(float a){\n\tmat3 rot = mat3(cos(a), 0., sin(a), 0., 1., 0., -sin(a), 0., cos(a));\n    return rot;\n}\n\nmat3 ROTZ(float a){\n\tmat3 rot = mat3(cos(a), -sin(a), 0., sin(a), cos(a), 0., 0., 0., 1.);\n    return rot;\n}\n\n//GYROID Distance estimator\nfloat Gyroid(vec3 pos){\n    float scale = 1.0;\n    float strength = PI/5.;\n    pos=pos*Scale;\n    float DE = (cos(pos.x)*sin(pos.y)+cos(pos.y)*sin(pos.z)+cos(pos.z)*sin(pos.x));\n    return strength/Scale*DE;\n}\n\n//Cube Distance estimator\nfloat Cube(vec3 pos){\n    float DE = max(abs(pos.x),abs(pos.y));\n    DE = max(DE,abs(pos.z-cube))-cube;\n    return DE;\n}\n\n//Normal vector of de DE function\nvec3 GetNormal(vec3 pos){\n    float flip = -sign(Gyroid(pos));\n    float sigma = 0.001;\n    //pos=pos*Scale;\n    vec3 Normal = vec3((Gyroid(pos+vec3(sigma,0.0,0.0))-Gyroid(pos))/sigma,\n                       (Gyroid(pos+vec3(0.0,sigma,0.0))-Gyroid(pos))/sigma,\n                       (Gyroid(pos+vec3(0.0,0.0,sigma))-Gyroid(pos))/sigma);\n    return -normalize(Normal)*flip;                      \n}\n\n// Raycast all geometry\nmat3 MAP(vec3 campos, vec3 raydir, int N){\t\t\t\t\t\n\tfloat D = 0.0;\n    float Delta = 0.0;\n    vec3 Current = vec3(0.0);\n    vec3 color = vec3(1.0,0.0,0.0);\n    \n    \n    for(int i = 0; i < N; i++) {\n        Current = campos+D*raydir;\n        Delta = max(abs(Gyroid(Current))-thickness,Cube(Current));\n        Delta = min(Delta,Current.z);\n        D=D+Delta;\n    }\n    \n    //Determine hit coordinates\n    vec3 hit = Current;\t   \t\t\t\t\t            \n    vec3 normal = vec3(0.0);\n    \n    if(hit.z<0.01){                                    //if you hit the floor\n        color = vec3(0.9);\n        normal = vec3(0.0,0.0,1.0);\n    }else if (abs(Gyroid(hit))<(thickness*0.9)){       // if you hit the edges\n        color = vec3(0.5);\n        if((abs(hit.x)>abs(hit.y))&&(abs(hit.x)>abs(hit.z-cube))){\n            normal = vec3(1.0,0.0,0.0)*sign(hit.x);\n        }else if(abs(hit.y)>abs(hit.z-cube)){\n            normal = vec3(0.0,1.0,0.0)*sign(hit.y);\n        }else{\n            normal = vec3(0.0,0.0,1.0)*sign(hit.z);\n        }\n    } else {                                            // if you hit the Gyroid surface\n        normal = GetNormal(hit);\t\t\t\t\t    //Determine normal vector\n        if(sign(Gyroid(hit))<0.0){\t\t\t\t\t    //If you are at the other side, color is blue\n            color = vec3(0.0,0.0,1.0);\n        }\n    }\n    \n    mat3 data = mat3(hit,normal,color);\n    return data;\n}\n\n//Dynamic lighting\nfloat DL(vec3 hit, vec3 light){\n    mat3 Data = MAP(hit+light*1.9*thickness, light, 100);\n    \n    float dist = length(vec3(Data[0][0],Data[0][1],Data[0][2])-hit);\n    float DL = dist; \n    DL=smoothstep(14.0,15.0,DL);\n    return DL;\n}\n\n//Distort the colors\nvec3 saturate(vec3 RGB){\n    float fac = 1.9;\n    mat3 transform = mat3(1.0 , fac , 0.0 ,\n                          fac , 1.0 , fac , \n                          0.0 , fac , 1.0);\n    RGB.y = RGB.y+0.3*pow(max(RGB.x,RGB.z),3.0);\n    return (RGB);\n}\n\n//Create image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    \n    // Define camera position and direction.\n    float camEL = (PI*(1.0-orbit*iMouse.y/iResolution.y))*0.6+1.7;\n    float camAZ = (-2.0*PI*orbit*iMouse.x/iResolution.x+swirl*iTime/3.);\n    if(iMouse.xy==vec2(0.0,0.0)){\n        camEL = PI/180.*115.;\n        camAZ = PI/180.*225.;\n    }\n    \n    vec3 campos = vec3(0.0,0.0,-8.);\n    campos *= ROTY(-camEL);\n    campos *= ROTZ(PI+camAZ);\n    campos = campos + vec3(0.0,0.0,2.0);\n    \n    // Determine ray direction\n    vec3 raydir= normalize(vec3(uv.y-0.5,uv.x-0.5*iResolution.x/iResolution.y,1.0));\n    raydir *= ROTY(-camEL);\n    raydir *= ROTZ(PI+camAZ);\n    \n    //Determine lightsource direction\n    vec3 light = vec3(1.0,2.0,0.5);\n    light = vec3(cos(sun*iTime),sin(sun*iTime),0.5);\n    light = normalize(light);\n    \n    \n    vec3 background = vec3(exp(-5.*(1.0-dot(light,raydir))));\n    vec3 RGB = vec3(1.0,0.0,0.0);\n    \n    //Determine cut out block (hit position vec3)\n    mat3 Data = MAP(campos,raydir,120);\t\t\t\t\n    vec3 hit    = vec3(Data[0][0],Data[0][1],Data[0][2]);\n    vec3 normal = vec3(Data[1][0],Data[1][1],Data[1][2]);\n    vec3 color  = vec3(Data[2][0],Data[2][1],Data[2][2]);\n    \n    float lighting = dot(normal,normalize(light));\n    RGB = lighting*color;\n    vec3 bounce = normalize(campos-hit)+normalize(light);\n    bounce = normalize(bounce);\n    float reflection = abs(clamp(dot(normal,bounce),0.0,1.0));\n    \n       \n    RGB.x = RGB.x+exp(-50.*(1.0-reflection*reflection));\n    RGB.y = RGB.y+exp(-70.*(1.0-reflection*reflection));\n    RGB.z = RGB.z+exp(-100.*(1.0-reflection*reflection));\n    \n    vec3 Dark = color*dot(raydir,-normal);\n    RGB = clamp(RGB,0.0,1.0)+Dark*0.2;\n    \n    float dl = DL(hit,light);\n    RGB = RGB*(dl);\n    \n\tif(length(hit-campos)>farclip){RGB = background;}\n    \n\tRGB = saturate(RGB);\n    \n    // Output to screen\n    fragColor = vec4(RGB,0.0);\n}\n\n","name":"Image","description":"","type":"image"}]}