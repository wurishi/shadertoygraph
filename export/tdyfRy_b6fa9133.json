{"ver":"0.1","info":{"id":"tdyfRy","date":"1607559376","viewed":409,"name":"GPU Bossa (sound)","username":"athibaul","description":"Playing a bossa groove using frequency modulation.","likes":27,"published":1,"flags":8,"usePreview":0,"tags":["sound","gpumusic","bossanova","clave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Song: \"Favela\" by Antonio Carlos Jobim\n// Arranged to Shadertoy by Alexis THIBAULT\n\n\n// Sound design inspired by music programming language SuperCollider\n// https://supercollider.github.io/\n\n\n#define rgb(r,g,b) pow(vec3(r,g,b)/255., vec3(2.2))\n\n// Palette\nconst vec3 RED = rgb(166,13,54),\n\tCYAN = rgb(30,183,217),\n    TEAL = rgb(28,166,152),\n    YELLOW = rgb(242,185,80),\n    ORANGE = rgb(242,154,46);\n\n\n// Raymarching code adapted from my shader \"Misty Jungle\"\n// https://www.shadertoy.com/view/wdcBDH\n#define T(p) (textureLod(iChannel0,p,0.).r-0.5)\n\nconst float SEA_LEVEL = -0.5;\n\nfloat smin(float a, float b)\n{\n\treturn (a+b - sqrt((a-b)*(a-b)+0.01))/2.;\n}\n\nfloat map(vec3 p)\n{\n    // Warp coordinates\n    p.x += T(p.xy*0.005)*5.;\n    p.y += T(p.xy*0.007+0.5)*5.;\n    // Add relief\n    float d = p.z - 0.1*p.x - T(p.xy*0.1*mat2(.6,.8,-.8,.6))- T(p.xy*0.02)*2.;\n    return smin(d, p.z-SEA_LEVEL);\n}\n\nfloat bmap(vec3 p)\n{\n    return map(p) - T(p.xy*4.*mat2(.6,.8,-.8,.6))*0.01*smoothstep(SEA_LEVEL,SEA_LEVEL+0.1,p.z);\n}\n\nvec3 normal( vec3 p, float eps)\n{\n    vec2 e = eps * vec2(1, -1);\n    return normalize(\n          e.xxx * bmap(p+e.xxx)\n        + e.xyy * bmap(p+e.xyy)\n        + e.yxy * bmap(p+e.yxy)\n        + e.yyx * bmap(p+e.yyx)\n    );\n}\n\nfloat raymarch(vec3 ro, vec3 rd)\n{\n    float d, t=0.;\n    float prev_d, prev_step;\n    for(int i=0; i<256;i++)\n    {\n        d=map(ro+t*rd)*0.5;\n        if(t>100.) break;\n        if(d<0.001) \n        {\n        \tt -= d*prev_d/(d-prev_d); \n        \tbreak;\n        }\n        prev_d = d;\n        t += d;\n    }\n    return t;\n}\n\nvec3 render(vec3 ro, vec3 rd, float time)\n{\n    float t = raymarch(ro, rd);\n\tvec3 col = vec3(0.0);\n    \n    \n    vec3 skyCol = CYAN + (0.5*rd.y*rd.y);\n    vec3 sunCol = vec3(1.0,0.7,0.4);\n    // Render surface\n    if(t < 100.)\n    {\n        vec3 p = ro+t*rd;\n        float eps = 0.001 + 0.001*t;\n        vec3 n = normal(p, eps);\n        vec3 sunDir=normalize(vec3(-1,1,2));\n        \n        // Pick a surface color\n        vec3 color = TEAL*0.2; //mix(TEAL, RED, smoothstep(-2.,2.,sin(p.x)+cos(0.6*p.y)));\n        \n        vec3 green = pow(color, vec3(1.+T(p.xy*0.07))); // Many shades of green\n        vec3 surfCol1 = pow(color, vec3(0.4)), // Rocks\n            surfCol2 = green;\n        // Alternate patches of grass and rocks, with more rocks on slopes\n        float grassy = smoothstep(0.2,-0.2,T(p.xy)+1.-n.z*1.2);\n        vec3 surfCol = mix(surfCol1, surfCol2, grassy);\n        \n        // Change surface color if on the beach\n        surfCol = mix(surfCol, YELLOW*2.+0.2, smoothstep(0.1, 0.0, p.z-SEA_LEVEL));\n        \n        vec3 seaCol = TEAL + 0.2*T(p.xy*0.1-cos(time-p.x)*vec2(0.0,0.02)) + 0.2*T(p.yx*0.1-time*vec2(0.05,0));\n        seaCol = clamp(seaCol, 0., 1.);\n        seaCol = mix(pow(seaCol, vec3(0.4)), seaCol, smoothstep(0.2,-0.2,T(p.xy-0.05*cos(vec2(2,3)*time+p.xy+vec2(1.5,0)))-0.2));\n        surfCol = mix(surfCol, seaCol, smoothstep(0.02, 0.01, p.z-SEA_LEVEL));\n        //surfCol = seaCol;\n        \n\n        // Shade surface\n        col += surfCol * 0.4 * (0.5+0.5*n.z) * skyCol;\n        col += surfCol * clamp(dot(n, sunDir),0.,1.) * sunCol;\n    }\n    else\n    {\n        col = skyCol;\n    }\n    \n    float fog = 1.-exp(-0.01*t);\n    col = mix(col, skyCol, fog);\n    \n    col = max(col, 0.);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime*0.5;\n    vec2 uv = (2.*fragCoord.xy - iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(-3.0-2.*cos(0.2*time),time,0.1-0.3*sin(0.16*time));\n    ro.z = max(ro.z, 0.1-map(ro));\n    vec3 camFwd = normalize(vec3(sin(0.27*time)*0.3,1,-0.1+0.1*cos(0.4*time)));\n    vec3 camRight = normalize(cross(camFwd, vec3(0,0,1)));\n    vec3 camUp = cross(camRight, camFwd);\n    vec3 rd = normalize(camFwd + 0.5*(uv.x*camRight+uv.y*camUp));\n    \n    \n    vec3 col = render(ro, rd, time);\n    \n    // Saturate colors\n    col *= pow(col/(col.r+col.g+col.b), vec3(dot(uv,uv)*0.3));\n    #if 0\n    // Basic tone mapping\n    col = 1.-exp(-col);\n    #else\n    // ACES tone mapping\n    // https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n    // Used in https://www.shadertoy.com/view/ts3Bz7\n    col *= 0.9;\n    col = (col*(2.51*col+0.03))/(col*(2.43*col+0.59)+0.14);\n    #endif\n    \n    \n    col = pow(col, vec3(1./2.2)); // gamma\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define TAU (2.*3.1415926535)\n\n\n// ************** SOUND UTILS *************\n\n// Phase Modulation\n#define SinOsc(f, p) cos(mod(TAU*(f)*t + (p), TAU))\n\n// Duration of a two-bar loop\n//const float barD = 16./3.; // 90 bpm\nconst float barD = 4.0; // 120 bpm\n//const float barD = 3.0; // 180 bpm\n\n// Duration of notes\nconst float WHOLE_D = barD*1./2.,\n    HALF_D = barD*1./4.,\n    QUARTER_D = barD*1./8.,\n    DOT_QUARTER_D = barD*3./16.,\n    EIGHT_D = barD*1./16.;\n\nfloat fmNoise(float t)\n{\n    // White noise generated from frequency modulation\n    float sprate = 44100.;\n    return SinOsc(10000., SinOsc(sprate/sqrt(8.), 0.)*10000.);\n}\n\nfloat cps(float notenumber)\n{\n    // Convert MIDI note number to cycles per second\n    return 440.*exp2((notenumber-69.)/12.);\n}\n\nfloat linexp(float t, float t1, float t2, float v1, float v2)\n{\n    // Map a linear range to an exponential range\n    // Zero outside the range\n    return v1 * pow(v2/v1, clamp((t-t1)/(t2-t1),0.,1.)) * step(t1, t) * step(t, t2);\n}\n\n\n\n// *********** INSTRUMENT SOUNDS **********\n\nfloat hihat(float t)\n{\n    float env = linexp(t, 0.0, 0.01, 0.1, 1.0) + linexp(t, 0.01, 0.08, 1.0, 0.05);\n    return env * fmNoise(t);\n}\n\nfloat clave(float t)\n{\n    float env = linexp(t, 0.0, 0.2, 1.0, 0.0003);\n    // Main resonant frequencies\n    float v = SinOsc(2100.,0.) + SinOsc(2211.,0.)*env;\n    // Center \"body\"\n    v += SinOsc(2153., SinOsc(168., SinOsc(199.,0.)*5.)) * linexp(t, 0.0, 0.12, 0.3, 0.0003);\n    // Middle click\n    v += SinOsc(3503., SinOsc(146.,0.)*16.) * linexp(t, 0.0, 0.1, 0.3, 0.0001);\n    // Upper click\n    v += SinOsc(10000., SinOsc(130.,0.)*10.) * linexp(t, 0.0, 0.09, 0.15, 0.0003);\n    return v*env;\n}\n\nfloat bassDrum(float t)\n{\n    // Fundamental frequency\n    float env =  linexp(t, 0.0, 0.25, 1.0, 0.001);\n    float v = SinOsc(65., SinOsc(5.,0.)*5.*env) * env;\n    // Beater \"click\"\n    v += SinOsc(3000., SinOsc(141., SinOsc(1200., 0.)*0.1)*10.) * linexp(t, 0.0, 0.03, 0.3, 0.0001);\n    return v * smoothstep(0.0, 0.001, t);\n}\n\nfloat guitar(float freq, float t)\n{\n    float env = linexp(t, 0.0, 15.0, 1.0, 0.001);\n    float sig = SinOsc(freq+1., SinOsc(freq,0.)*env);\n    sig += SinOsc(5.*freq, SinOsc(freq,0.)*5.*env) * 0.1*env;\n    return sig * env;\n}\n\nfloat bass(float freq, float t)\n{\n    // Simple electric bass sound\n    float env = linexp(t, 0.0, 15.0, 1.0, 0.001);\n    float modStrength = (100./freq);\n    float sig = SinOsc(2.*freq,\n                       SinOsc(freq,\n                              SinOsc(freq, 0.)\n                             )\n                       *env*modStrength\n                      );\n    sig += SinOsc(freq*25., SinOsc(freq,0.)*10.*modStrength) * linexp(t, 0.0, 0.08, 0.1, 0.001);\n    return sig;\n}\n\nfloat flute(float freq, float t)\n{\n    float vib = SinOsc(5.,0.)*smoothstep(0.0, 0.8, t);\n    float env = smoothstep(0.0, 0.1, t) * (1. + 0.1*vib);\n    float sig = SinOsc(freq, SinOsc(freq+3., 0.)*0.8*env);\n    // Some more high frequencies for a more natural sound\n    sig += SinOsc(freq*round(5000./freq), SinOsc(freq,0.)*50.) * (0.01+0.005*vib);\n    // Blowing noise at the beginning of the note\n    sig += smoothstep(0.2,0.0,t)*SinOsc(freq, SinOsc(freq, SinOsc(freq*0.3,0.)*5.)*3.)*0.05;\n    return sig * env;\n}\n\n\n// *********** MUSICAL LOOPS *************\n\n// Chord types:\nconst int MINOR7 = 0,\n    MAJOR = 1,\n    DOMINANT7 = 2,\n    MAJOR7 = 3,\n    MINOR7b5 = 4,\n    MINOR6 = 5;\n\nstruct Chord{\n    int type;\n    float root; \n};\n\nvec2 clavePlayRythm(float t, int type)\n{\n\tif(type == 0)\n    {\n    \t// Bossa nova clave\n        float claveTime = t < barD*0.5 ? t : t + barD/8.;\n        claveTime = mod(claveTime, 3./16.*barD);\n        return clave(claveTime) * vec2(0.4,0.7);\n    }\n    else if(type == 1)\n    {\n    \t// Lots of downbeats\n        float claveTime = t - step(6.*EIGHT_D,t)*step(t,12.*EIGHT_D)*EIGHT_D;\n        claveTime = mod(claveTime, QUARTER_D);\n        return clave(claveTime) * vec2(0.4, 0.7);\n    }\n    else if(type == 2)\n    {\n    \t// Lots of upbeats\n        float claveTime = t - step(4.*EIGHT_D,t)*step(t,12.*EIGHT_D)*EIGHT_D;\n        claveTime = mod(claveTime, QUARTER_D);\n        return clave(claveTime) * vec2(0.4, 0.7);\n    }\n}\n\nvec2 hihatPlayEights(float t)\n{\n    // Accented half notes on the hi-hat\n    // TODO Accent beat 3\n    float hihatTime = mod(t,EIGHT_D);\n    return hihat(hihatTime) * (0.3 - 0.15*fract(t/(barD/8.)) + 0.05*sin(t)) * vec2(0.5,0.3);\n}\n\nfloat bassDrumPlayRythm(float t)\n{\n    // Dotted rythm on bass drum\n    float bdTime = mod(t, barD/4.);\n    bdTime = mod(bdTime, barD*3./16.);\n    return bassDrum(bdTime) * 2.;\n}\n\nfloat guitarChord(float t, Chord c)\n{\n    float sig = 0.;\n    float root = c.root;\n    // Center the chord around middle C, where the guitar is\n    // neither too muddy nor too bright\n    #define R(n) (mod((n)-7., 12.)+55.)\n    sig += guitar(cps(R(root)), t);\n    sig += guitar(cps(R(root + ((c.type==MINOR7b5) ? 6. : 7.))), t);\n    sig += guitar(cps(R(root + (c.type==MAJOR7 ? 11. : (c.type==MAJOR ? 12. : (c.type==MINOR6 ? 9. : 10.))))), t);\n    sig += guitar(cps(R(root + (c.type==MINOR7 || c.type==MINOR7b5 || c.type==MINOR6 ? 15. : 16.))), t);\n    //sig += guitar(cps(root + ((c.type==MINOR7b5) ? 18. : 19.)), t);\n    return sig;\n}\n\nfloat window(float t, float dur)\n{\n    float attack = 0.01;\n    float release = 0.1;\n    return smoothstep(0.0, attack, t) * smoothstep(dur, dur-release, t);\n}\n\nfloat guitarPlayRythm(float t, int rythmType, Chord c)\n{\n    // Play two bars of bossa rythm on given chord\n    // Rythms taken from \"Le Livre du Piano Jazz\"\n    // Mark Levine, pp. 208-209\n    float sig = 0.;\n    if(rythmType == 0)\n    {\n        // fig. 21-8\n        sig += guitarChord(t,c) * window(t, QUARTER_D);\n        t -= DOT_QUARTER_D;\n        sig += guitarChord(t, c) * window(t, DOT_QUARTER_D);\n        t -= DOT_QUARTER_D;\n        sig += guitarChord(t, c) * window(t, QUARTER_D*1.1);\n        t -= HALF_D;\n        sig += guitarChord(t, c) * window(t, DOT_QUARTER_D);\n        t -= DOT_QUARTER_D;\n        sig += guitarChord(t, c) * window(t, EIGHT_D*0.9);\n    }\n    if(rythmType == 1)\n    {\n        // fig. 21-9\n        t -= DOT_QUARTER_D;\n        sig += guitarChord(t,c) * window(t,QUARTER_D*0.9);\n        t -= QUARTER_D;\n        sig += guitarChord(t,c) * window(t,QUARTER_D*1.1);\n        t -= QUARTER_D;\n        sig += guitarChord(t,c) * window(t,EIGHT_D*0.7);\n        t -= QUARTER_D;\n        sig += guitarChord(t,c) * window(t,DOT_QUARTER_D*0.95);\n        t -= DOT_QUARTER_D;\n        sig += guitarChord(t,c) * window(t,QUARTER_D*0.9);\n        t -= QUARTER_D;\n        sig += guitarChord(t,c) * window(t,QUARTER_D*0.8);\n        t -= QUARTER_D;\n    }\n    if(rythmType == 2)\n    {\n        // fig. 21-10\n        t -= QUARTER_D;\n        sig += guitarChord(t,c) * window(t,QUARTER_D);\n        t -= DOT_QUARTER_D;\n        sig += guitarChord(t,c) * window(t,QUARTER_D);\n        t -= DOT_QUARTER_D;\n        sig += guitarChord(t,c) * window(t,DOT_QUARTER_D*1.1);\n        t -= DOT_QUARTER_D;\n        sig += guitarChord(t,c) * window(t,EIGHT_D*0.7);\n    }\n    if(rythmType == 3)\n    {\n        // fig. 21-11\n        sig += guitarChord(t,c) * window(t,QUARTER_D);\n        t -= DOT_QUARTER_D;\n        sig += guitarChord(t,c) * window(t,EIGHT_D*0.7);\n        t -= EIGHT_D;\n        sig += guitarChord(t,c) * window(t,EIGHT_D*1.1);\n        t -= EIGHT_D;\n        sig += guitarChord(t,c) * window(t,QUARTER_D*1.1);\n        t -= QUARTER_D;\n        sig += guitarChord(t,c) * window(t,EIGHT_D*0.7);\n        t -= HALF_D;\n        sig += guitarChord(t, c) * window(t,DOT_QUARTER_D*1.1);\n        t -= DOT_QUARTER_D;\n        sig += guitarChord(t, c) * window(t,QUARTER_D*0.8);\n    }\n    \n    // Light distortion\n    sig = sig / (5.0 + 0.3*abs(sig));\n    return sig;\n}\n\nfloat bassLine(float t, Chord c)\n{\n    // For a start, let's simply play 3-3-2\n    t = mod(t, WHOLE_D);\n    \n    float root = c.root - 24.;\n    float interval = (c.type == MINOR7b5) ? 6. : 7.;\n    \n    float sig = 0.;\n    sig += bass(cps(root),t) * window(t,DOT_QUARTER_D);\n    t -= DOT_QUARTER_D;\n    sig += bass(cps(root+interval),t) * window(t,DOT_QUARTER_D);\n    t -= DOT_QUARTER_D;\n    sig += bass(cps(root),t) * window(t,QUARTER_D);\n    \n    sig = sig/(1. + 0.1*abs(sig));\n    return sig;\n}\n\nfloat fluteTheme(float time)\n{\n    // Time : since beginning of anacrouse, one dotted quarter note before bar 0.\n    time = mod(time / WHOLE_D, 16.)*WHOLE_D;\n    \n    float sig = 0.;\n    \n    #define B(n,d) sig += flute(cps(n), t) * window(t, d); t -= d;\n    \n    if(time < (6.25)*WHOLE_D){\n    \tfloat t = mod(time, 2.*WHOLE_D);\n        B(74.,QUARTER_D)\n        B(79., QUARTER_D*3.)\n        B(74., QUARTER_D)\n        B(77., QUARTER_D*3.)\n        /*\n        sig += flute(cps(74.), t) * window(t, QUARTER_D);\n        t -= QUARTER_D;\n        sig += flute(cps(79.), t) * window(t, QUARTER_D*3.);\n        t -= QUARTER_D*3.;\n        sig += flute(cps(74.), t) * window(t, QUARTER_D);\n        t -= QUARTER_D;\n        sig += flute(cps(77.), t) * window(t, QUARTER_D*3.);\n        t -= QUARTER_D*3.;\n        */\n    } else {\n    \tfloat t = time - (6.25)*WHOLE_D;\n        B(70., EIGHT_D+WHOLE_D)\n        t -= HALF_D + EIGHT_D;\n        B(67., QUARTER_D)\n        B(72., 3.*QUARTER_D)\n        B(70., QUARTER_D)\n        B(74., 3.*QUARTER_D)\n        B(72., QUARTER_D)\n        B(74., 3.*QUARTER_D)\n        B(77., QUARTER_D)\n        B(79., EIGHT_D)\n        B(82., QUARTER_D)\n        B(79., EIGHT_D)\n        B(77., QUARTER_D)\n        B(74., QUARTER_D)\n        B(72., QUARTER_D)\n        B(70., QUARTER_D)\n        B(74., QUARTER_D)\n        B(72., QUARTER_D)\n        B(70., EIGHT_D)\n        B(67., QUARTER_D)\n        B(65., EIGHT_D)\n        B(62., QUARTER_D)\n        B(65., QUARTER_D)\n        B(67., EIGHT_D+WHOLE_D)\n    }\n    return sig;\n}\n\n\n// *************** PIECE STRUCTURE ***********\n\n\nvec2 testInstruments(float time)\n{\n    float ti = floor(time/barD)*barD;\n    float t = time - ti;\n    \n    vec2 v = vec2(0.);\n    \n    int claveType = 0;\n    v += clavePlayRythm(t, claveType);\n    v += hihatPlayEights(t);\n    v += bassDrumPlayRythm(t);\n    \n    // Guitar chord\n    Chord chord = Chord(MINOR7, 55.);\n    v += guitarPlayRythm(t, 2, chord);\n    \n    // Bass line\n    v += bassLine(t, chord) * 0.5;\n    return v;\n}\n\nvec2 sectionA(float time)\n{\n    float barNum = mod(time / WHOLE_D, 16.);\n    \n    Chord guitarChord;\n    Chord bassChord;\n    if(barNum < 6.)\n    {\n        bassChord = Chord(MINOR7, 55.);\n        if(mod(barNum, 2.) < 1.)\n            guitarChord = Chord(MINOR7, 55.);\n        else\n            guitarChord = Chord(MAJOR, 53.);\n    }\n    else if(barNum < 8.)\n        guitarChord = bassChord = Chord(MINOR7, 55.);\n    else if(barNum < 9.)\n        guitarChord = bassChord = Chord(MINOR7, 60.);\n    else if(barNum < 10.)\n        guitarChord = bassChord = Chord(DOMINANT7, 53.);\n\telse if(barNum < 11.)\n        guitarChord = bassChord = Chord(MAJOR7, 58.);\n    else if(barNum < 12.)\n        guitarChord = bassChord = Chord(DOMINANT7, 58.);\n    else if(barNum < 12.5)\n        guitarChord = bassChord = Chord(MINOR7b5, 52.);\n    else if(barNum < 13.)\n        guitarChord = bassChord = Chord(MINOR6, 51.);\n    else if(barNum < 13.5)\n        guitarChord = bassChord = Chord(MINOR7, 55.);\n    else if(barNum < 14.)\n        guitarChord = bassChord = Chord(MINOR7, 62.);\n    else if(barNum < 16.)\n        guitarChord = bassChord = Chord(MINOR7, 55.);\n    \n    float beginningOfTwoBars = floor(time / (2.*WHOLE_D)) * (2.*WHOLE_D);\n    float t = time - beginningOfTwoBars;\n    \n    vec2 sig = vec2(0);\n    \n    float barHash = fract(fmNoise(floor(time / (WHOLE_D*2.))*0.01)*100.);\n    int claveType = 2-int(barHash*3.);\n    int guitarPattern = int(barHash*4.);\n    \n    sig += clavePlayRythm(t, claveType);\n    sig += hihatPlayEights(t);\n    sig += bassDrumPlayRythm(t);\n        \n    sig += guitarPlayRythm(t, guitarPattern, guitarChord) * vec2(0.9,1.1);\n    sig += bassLine(t, bassChord) * 0.5;\n        \n    return sig;\n}\n\nvec2 sectionB(float time)\n{\n    // TODO\n    vec2 sig = vec2(0);\n    \n    float beginningOfTwoBars = floor(time / (2.*WHOLE_D)) * (2.*WHOLE_D);\n    float t = time - beginningOfTwoBars;\n    \n    int claveType = 0;\n    sig += clavePlayRythm(t, claveType);\n    sig += hihatPlayEights(t);\n    \n    return sig;\n}\n\nvec2 mainSound( in int samp, float time )\n{\n    //vec2 v = testInstruments(time);\n    time -= DOT_QUARTER_D;\n    vec2 v;\n    if(time < 0.)\n    \tv = vec2(0.);\n    else\n    \tv = sectionA(time);\n        \n    v += fluteTheme(time+DOT_QUARTER_D) * vec2(0.6,0.5);\n        \n    return v * vec2(0.1);\n}","name":"Sound","description":"","type":"sound"}]}