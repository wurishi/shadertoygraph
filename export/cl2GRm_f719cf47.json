{"ver":"0.1","info":{"id":"cl2GRm","date":"1673042237","viewed":279,"name":"Dithering Comparison","username":"fardaniqbal","description":"Top to bottom:\n* White noise\n* Sinless (https://www.shadertoy.com/view/4djSRW)\n* pack_morton2x16 to R1 (https://www.shadertoy.com/view/3tB3z3)\n* Inverse Hilbert to R1 (from same)\n* Interleaved Gradient noise\n* R2 noise\n* Blue noise\n* No dither","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["noise","banding","blue","dithering","quasirandom"],"hasliked":0,"parentid":"3tB3z3","parentname":"Hilbert R1 Blue Noise"},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Experiment to compare dithering techniques.  The rendered image compares\n   different noise patterns from top to bottom.  Left column shows the raw\n   noise.  Right column shows a gradient dithered with that noise before\n   quantizing to show how the noise performs.\n\n   #define DITHER_TPDF: dithering removes quantization banding but we still\n   get bands of flat areas where quantized signal is close to the original\n   signal.  [wronski] and [gjoel-inside] show how remapping the noise to\n   triangular pdf eliminates these flat bands.  Change DITHER_TPDF below to\n   compare uniform vs triangular pdf.\n\n   #define DITHER_SAT_ZERO/ONE: [dither-sat] shows how dithering signals\n   near 0 and 1 with TPDF creates dither noise in areas we expect to be a\n   flat 0 or 1.  The proposed solution is to fall back to uniform PDF near\n   those values.  Change these #defines to compare the difference.\n\n   #define HILBERT_LEVEL: speed/quality tradeoff for Hilbert-based noise.\n   Speed-wise: time increases linearly with this.  Quality-wise: increasing\n   this by 1 doubles the tiling period.\n\n   References:\n   [roberts]: http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n   [wronski]: https://bartwronski.com/2016/10/30/dithering-part-three-real-world-2d-quantization-dithering/\n   [shaderbook]: https://thebookofshaders.com/10/\n   [gjoel-inside]: https://loopit.dk/rendering_inside.pdf\n   [dither-sat]: https://computergraphics.stackexchange.com/questions/5904/whats-a-proper-way-to-clamp-dither-noise\n\n   I'm sure I missed a couple.  Let me know if you spot any. */\n/* --------------------------------------------------------------------- */\n#define DITHER_ANIMATED true    // change dither mask every frame?\n#define DITHER_RGB      false   // use unique masks per color channel?\n#define DITHER_TPDF     true    // dither with uniform or triangular pdf?\n#define DITHER_SAT_ZERO true    // assume signal clamps at 0?\n#define DITHER_SAT_ONE  true    // assume signal clamps at 1?\n#define QUANTIZE_STEPS  8,16,8  // rgb; try 32,64,32 for 16-bit (565) color\n\n#define HILBERT_LEVEL 7U        // bigger = slower but less tiling\n#define HILBERT_WIDTH (1U << HILBERT_LEVEL)\n\n// based on [roberts]\nfloat quasirand_r1(uint n) {\n    const float INV_PHI = 0.61803398874989484820;\n    return fract(0.5 + INV_PHI*float(n));\n}\nvec3 quasirand_r3(uint n) {\n    const vec3 FACTORS = vec3(0.81917251339616443969,\n                              0.67104360670378920841,\n                              0.54970047790197026694);\n    return fract(0.5 + FACTORS*vec3(n));\n}\n\nuint part1by1(uint x) {\n    x = (x & 0x0000ffffu);\n    x = ((x ^ (x << 8u)) & 0x00ff00ffu);\n    x = ((x ^ (x << 4u)) & 0x0f0f0f0fu);\n    x = ((x ^ (x << 2u)) & 0x33333333u);\n    x = ((x ^ (x << 1u)) & 0x55555555u);\n    return x;\n}\n\nuint pack_morton2x16(uvec2 v) {\n\treturn part1by1(v.x) | (part1by1(v.y) << 1);\n}\n\nuint inverse_gray32(uint n) {\n    n = n ^ (n >> 1);\n    n = n ^ (n >> 2);\n    n = n ^ (n >> 4);\n    n = n ^ (n >> 8);\n    n = n ^ (n >> 16);\n    return n;\n}\n\n// original from https://www.shadertoy.com/view/3tB3z3\nfloat PackMorton2x16R1Noise(vec2 p) {\n    uint x = pack_morton2x16(uvec2(p)) % (1u << 17u);    \n    //x = x ^ (x >> 1);\n    x = inverse_gray32(x);\n    return quasirand_r1(x);\n}\nvec3 PackMorton2x16R1Noise_rgb(vec2 p) {\n    float h1 = PackMorton2x16R1Noise(p);\n    float h2 = PackMorton2x16R1Noise(p + vec2(1234., 0.));\n    float h3 = PackMorton2x16R1Noise(p + vec2(0., 1234.));\n    return vec3(h1,h2,h3);\n}\nvec3 PackMorton2x16R3Noise(vec2 p) {\n    uint x = pack_morton2x16(uvec2(p)) % (1u << 17u);    \n    //x = x ^ (x >> 1);\n    x = inverse_gray32(x);\n    return quasirand_r3(x);\n}\n\n// original from https://www.shadertoy.com/view/XtGBDW\nuint HilbertIndex(uvec2 Position) {\n    uint Index = 0U;\n    for( uint CurLevel = HILBERT_WIDTH/2U; CurLevel > 0U; CurLevel /= 2U ) {\n        uvec2 Region = uvec2(greaterThan((Position & uvec2(CurLevel)), uvec2(0U)));\n        Index += CurLevel * CurLevel * ( (3U * Region.x) ^ Region.y);\n        if( Region.y == 0U ) {\n            if( Region.x == 1U )\n                Position = uvec2(HILBERT_WIDTH - 1U) - Position;\n            Position.xy = Position.yx;\n        }\n    }\n    return Index;\n}\n\n// original from https://www.shadertoy.com/view/3tB3z3\nfloat HilbertR1Noise(vec2 p) {\n    return quasirand_r1(HilbertIndex(uvec2(p)) % (1u << 17u));\n}\nvec3 HilbertR1Noise_rgb(vec2 p) {\n    float h1 = HilbertR1Noise(p);\n    float h2 = HilbertR1Noise(p + vec2(1234., 0.));\n    float h3 = HilbertR1Noise(p + vec2(0., 1234.));\n    return vec3(h1,h2,h3);\n}\n\n// idea from https://www.shadertoy.com/view/3tB3z3, but with r3 from [roberts]\nvec3 HilbertR3Noise(vec2 p) {\n    return quasirand_r3(HilbertIndex(uvec2(p)) % (1u << 17u));\n}\n\n// Dave Hoskins' hash (https://www.shadertoy.com/view/4djSRW.)  Allegedly\n// more portable than [shaderbook]'s hash because it avoids trig calls.\n// Less obvious patterning than [shaderbook]'s hash on a 2019 MacBook Pro.\nfloat SinlessWhiteNoise(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 SinlessWhiteNoise_rgb(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\n// from [shaderbook]\nfloat WhiteNoise(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\nvec3 WhiteNoise_rgb(vec2 p) {\n    float h1 = WhiteNoise(p);\n    float h2 = WhiteNoise(vec2(h1, p.x));\n    float h3 = WhiteNoise(vec2(h2, p.y));\n    return vec3(h1,h2,h3);\n}\n\n// based on [roberts]\nfloat R2Noise(vec2 p) {\n    return fract(dot(p, vec2(0.754877669, 0.569840296)));\n}\nvec3 R2Noise_rgb(vec2 p) {\n    float h1 = R2Noise(p);\n    float h2 = R2Noise(p + 53.); // offsets chosen empirically\n    float h3 = R2Noise(p + 49.); // to minimize hue shift\n    return vec3(h1,h2,h3);\n}\n\n// from [wronski]\nfloat InterleavedGradientNoise(vec2 p) {\n    return fract(52.9829189 * fract(0.06711056*p.x + 0.00583715*p.y));\n}\nvec3 InterleavedGradientNoise_rgb(vec2 p) {\n    float h1 = InterleavedGradientNoise(p);\n    float h2 = InterleavedGradientNoise(p + 9.);  // offsets chosen to\n    float h3 = InterleavedGradientNoise(p + 10.); // minimize hue shift\n    return vec3(h1,h2,h3);\n}\n\n// [roberts] recommends remapping their proposed R2Noise dither mask\n// through this formula to eliminate the discontinuities from fract().\n// Looks like it improves dithering for other noises too.\nvec3 triwave(vec3 z) { // z in [0..1]\n    return mix(2.0*z, 2.0 - 2.0*z, step(0.5, z));\n}\n\n// dither c with noise [-1..1] and quantize to given steps\nvec3 quantize(vec3 c, vec3 noise, uvec3 steps) {\n    vec3 vsteps = vec3(steps-1u);\n    vec3 scaled = c * vsteps;\n\n    // noise = triangle pdf if .5 <= scaled < vsteps-.5, else uniform pdf\n    vec3 mask0 = DITHER_SAT_ZERO ? step(vec3(.5), scaled)       : vec3(1);\n    vec3 mask1 = DITHER_SAT_ONE  ? 1. - step(vsteps-.5, scaled) : vec3(1);\n#if 1\n    // Triangle pdf derived from https://www.shadertoy.com/view/MtscD2\n    vec3 tpdf = sign(noise) * (1.0 - sqrt(1.0 - abs(noise)));\n#else\n    // Alternate tpdf from https://www.shadertoy.com/view/4t2SDh.  If used\n    // raw, it gives a stronger dither pattern than the other tpdf.\n    // However, remapping the base noise (off = fract(...) below) before\n    // applying this tpdf makes it identical to the other tpdf mapping (see\n    // graphs of both: https://www.desmos.com/calculator/3582poxjbq).\n    vec3 off = fract((noise*0.5) + 1.) * 2. - 1.;\n    vec3 tpdf = max(vec3(-1), off*inversesqrt(abs(off))) - sign(off);\n#endif\n    noise = mix(noise*0.5, tpdf, mask0*mask1*vec3(DITHER_TPDF));\n    return floor(scaled+noise+0.5) / vsteps;\n}\nvec3 lin2gamma(vec3 c) {return pow(c, vec3(1./2.2));} // srgb approx\nvec3 gamma2lin(vec3 c) {return pow(c, vec3(2.2));}\n\n/* - van damme --------------------------------------------------------- */\n\nvec3 van_damme(vec3 bgColor, vec2 uv) {\n    vec2 SZ = vec2(.5, .5);// * iResolution.yx/iResolution.xy;\n    vec2 muv = iMouse.xy / iResolution.xy;\n    if (all(lessThanEqual(iMouse.xy, vec2(0))))\n        return bgColor;\n    if (!(muv.x - SZ.x*.5 < uv.x && uv.x < muv.x + SZ.x*.5))\n        return bgColor;\n    if (!(muv.y - SZ.x*.5 < uv.y && uv.y < muv.y + SZ.x*.5))\n        return bgColor;\n    vec3 c = gamma2lin(texture(iChannel1, ((uv-(muv-SZ*.5))/SZ).xy).rgb);\n    return c;\n}\n\n/* --------------------------------------------------------------------- */\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    const float NOISE_SCALE = 1.;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 noiseOff = vec2((DITHER_ANIMATED ? 12345. : 0.) * fract(iTime));\n    vec2 noiseCoord = floor(fragCoord.xy/NOISE_SCALE + noiseOff);\n    vec3 noise;\n\n    if (uv.y > 7./8.) {\n        noise = WhiteNoise_rgb(noiseCoord/iResolution.xy);\n    } else if (uv.y > 6./8.) {\n        noise = DITHER_RGB ? SinlessWhiteNoise_rgb(noiseCoord)\n                           : vec3(SinlessWhiteNoise(noiseCoord));\n    } else if (uv.y > 5./8.) {\n        noise = PackMorton2x16R1Noise_rgb(noiseCoord);\n        noise = triwave(noise);\n    } else if (uv.y > 4./8.) {\n        noise = HilbertR1Noise_rgb(noiseCoord);\n        noise = triwave(noise);\n    } else if (uv.y > 3./8.) {\n        noise = InterleavedGradientNoise_rgb(noiseCoord);\n        noise = triwave(noise);\n    } else if (uv.y > 2./8.) {\n        noise = R2Noise_rgb(noiseCoord);\n        noise = triwave(noise);\n    } else if (uv.y > 1./8.) {\n        noise = texelFetch(iChannel0, ivec2(noiseCoord.xy)%textureSize(iChannel0,0), 0).rgb;\n    } else {\n        noise = vec3(0.5);\n    }\n    if (!DITHER_RGB)\n        noise = noise.rrr;\n\n    if (fract(uv.y * 8.0) < .02) {\n        fragColor = vec4(vec3(.2), 1.0); // border line\n    } else if (uv.x < 0.5) {\n        fragColor = vec4(noise, 1.0);\n    } else {\n        vec3 gradient = vec3((uv.x - 0.5) * 2.0);\n        vec3 c = clamp(gradient * 1.2 - .1, 0., 1.); // flat areas at the ends\n        //c = van_damme(c, uv); // TODO: test dither quality on image/video\n        c = lin2gamma(c);\n        if (fract(uv.y * 8.0) > 0.25)\n            fragColor = vec4(quantize(c, noise*2.-1., uvec3(QUANTIZE_STEPS)), 1.0);\n        else\n            fragColor = vec4(c, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}