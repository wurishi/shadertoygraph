{"ver":"0.1","info":{"id":"ftdfD2","date":"1663669144","viewed":93,"name":"Cube rotation + polygone","username":"Hatokuro","description":"suite du shader Cube rotation: https://www.shadertoy.com/view/sttfWH\navec l'ajout de polygone sur chacune des face du cube,\nattention aucun Z buffer pour l'instant","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["cuberotationpolygone"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define ANTIALIASING\n\n#define DISTCAMERA 10.\n#define SIZE 1.\n//======================== POLYGONE ========================\nbool sameside(vec2 uv, vec3 A, vec3 B, vec3 C) //permet d'indiquer de quel coté d'une ligne on se trouve (0 ou 1)\n{\n    vec3 u = vec3(uv.x,uv.y,0.0);\n    vec3 valuexy = cross(B-A,C-A);\n    vec3 valuexz = cross(B-A,u-A);\n    \n    if(dot(valuexy,valuexz)>=0.){return true;}\n    else{return false;}   \n}\n\nbool inTriangle(vec2 uv,vec3 v[3]) // permet d'indiquer si on se trouve bien a l'intérieur d'un triangle (3 ligne)\n{\n    if(sameside(uv,v[0],v[1],v[2]) && sameside(uv,v[1],v[2],v[0]) && sameside(uv,v[2],v[0],v[1])){return true;}\n    else{return false;}\n   \n}\n//======================== LINE ========================\nfloat segment(vec2 u, vec2 a, vec2 b)  {         \n    b -= a, u -= a;\n    return length( u - b * clamp(dot(b, u) / dot(b, b), 0., 1.));\n}\n\nfloat line(vec2 uv, vec2 A,vec2 B, float width)\n{\n    float mysegment = segment(uv,A,B);\n    return mysegment = smoothstep(width,0.,mysegment);\n}\n\n//======================== MATRIX ========================\nmat3 rotateX(float angle){\n    float cosPhi = cos(angle);\n    float sinPhi = sin(angle);\n    return mat3(1.,0.,0.,\n    0.,cosPhi,-sinPhi,\n    0.,sinPhi,cosPhi);\n}\n\nmat3 rotateY(float angle){\n    float cosPhi = cos(angle);\n    float sinPhi = sin(angle);\n    return mat3(cosPhi,0.,sinPhi,\n    0.,1.,0.,\n    -sinPhi,0.,cosPhi);\n}\n\nmat3 rotateZ(float angle){\n    float cosPhi = cos(angle);\n    float sinPhi = sin(angle);\n    return mat3(cosPhi,-sinPhi,0.,\n    sinPhi,cosPhi,0.,\n    0.,0.,1.);\n}\n\nmat3 scaleXYZ(vec3 scale){\n    return mat3(scale.x,0.,0.,\n    0.,scale.y,0.,\n    0.,0.,scale.z);\n}\n//======================== COORD CUBE ========================\nconst vec3 vertices[8] = vec3[](\n    vec3(-1.,-1.,1.),\n    vec3(1.,-1.,1.),\n    vec3(-1.,1.,1.),\n    vec3(1.,1.,1.),\n    vec3(-1.,-1.,-1.),\n    vec3(1.,-1.,-1.),\n    vec3(-1.,1.,-1.),\n    vec3(1.,1.,-1.)\n);\n\nconst int orderA[12] = int[](0,2,0,3,4,6,4,7,0,1,2,3);\nconst int orderB[12] = int[](1,3,2,1,5,7,6,5,4,5,6,7);\n\nconst int triOrderA[12] = int[](0,1,4,5,0,1,2,3,0,2,1,3);\nconst int triOrderB[12] = int[](1,2,5,6,1,4,3,6,2,4,3,5);\nconst int triOrderC[12] = int[](2,3,6,7,4,5,6,7,4,6,5,7);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalisation des pixel (from 0 to 1)\n    vec2 uv = (2.* fragCoord - iResolution.xy)/iResolution.y;\n    float px_size = 2. / iResolution.y;\n    vec3 col = vec3(0.);\n    \n    vec3 verticesCube[8];\n    for(int i=0;i<8;i++)\n    {\n\n        verticesCube[i] =  vertices[i] * rotateX(iTime) * rotateY(iTime) *rotateZ(iTime);\n        verticesCube[i] = verticesCube[i] *  scaleXYZ(vec3(SIZE,SIZE,SIZE)); \n        verticesCube[i].z += DISTCAMERA;\n        \n        //perspective pour la profondeur\n        float ooz = 1. / verticesCube[i].z;\n\n        verticesCube[i].x = ooz* verticesCube[i].x*2.;\n        verticesCube[i].y =  ooz * verticesCube[i].y*2.;\n        \n    }\n    \n    \n    for(int i=0;i<12;i++)\n    {\n        vec3 coordTri[3];\n        coordTri[0]= vec3(verticesCube[triOrderA[i]].xy,0.);\n        coordTri[1]= vec3(verticesCube[triOrderB[i]].xy,0.);\n        coordTri[2]= vec3(verticesCube[triOrderC[i]].xy,0.);\n        col += inTriangle(uv,coordTri) ? vec3(0.,0.,1.) : col;\n    }\n    for(int i=0;i<12;i++)\n    {\n        col += line(uv,verticesCube[orderA[i]].xy,verticesCube[orderB[i]].xy,px_size);//trassage de lignes\n    }\n\n    // Output to screen\n    #ifdef ANTIALIASING\n        fragColor = vec4(pow(col, vec3(1.0/2.2)), 1.0);\n    #else\n        fragColor = vec4(col,1.0);\n    #endif\n    \n }","name":"Image","description":"","type":"image"}]}