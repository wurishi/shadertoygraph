{"ver":"0.1","info":{"id":"WtKXWD","date":"1582740536","viewed":165,"name":"Sunshine","username":"yasuo","description":"https://en.wikipedia.org/wiki/List_of_Kinnikuman_characters#Sunshine","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["sunshine"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// All the distance functions from:https://iquilezles.org/articles/distfunctions\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 15.\n#define SURF_DIST .003\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) 1.0-smoothstep(b,antialiasing(1.0),d)\n#define BASE_COLOR vec3(0.8,0.75,0.0)*1.5\n#define EDGE_WIDTH 0.015\n\nfloat hash21(vec2 x) { \n    x = fract(x*vec2(123.34, 345.45));\n    x += dot(x,x+34.345);\n    return fract(x.x*x.y); \n}\n\nstruct Ray {\n    vec3 mat;\n    float d;\n    float edge;\n};\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    return (val1.w < val2.w)?val1:val2;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat dBox2d(vec2 p, vec2 b) {\n    return max(abs(p.x) - b.x, abs(p.y) - b.y);\n}\n\nfloat sdStar(in vec2 p, in float r, in int n, in float m)\n{\n    // next 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;  // m is between 2 and n\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) for regular polygon,\n\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\nvec3 sunshineLogo(vec2 uv, vec3 bg){\n    vec3 col = bg;\n    float r = 0.2;\n    float star = sdStar(uv,r*3.0,4,3.2);\n    col = mix(col, vec3(0.9,0.9,0.0)*0.3,S(star,0.0)); \n    \n    uv*=Rot(radians(45.0));\n    star = sdStar(uv,r*2.5,4,3.2);\n    col = mix(col, vec3(0.9,0.9,0.0)*0.3,S(star,0.0)); \n    float d = length(uv)-r;\n    col = mix(col, vec3(0.6,0.2,0.6)*0.8,S(d,0.0));\n    \n    return col;\n}\n\nvec3 bodyPaint(vec2 uv) {\n    uv*=5.0;\n    vec3 bcol = vec3(0.8,0.75,0.0);\n    vec3 col = bcol*0.5;\n    uv.x = mod(uv.x,1.0)-0.5;\n    uv.y = mod(uv.y,1.0)-0.5;\n    float d = dBox2d(uv,vec2(0.45));\n    col = mix(col, bcol*1.2,S(d,0.0));\n    return col;\n}\n\nvec3 emitColor(vec3 p, vec3 emitPos, vec3 emitColor, float radius, float softness, float brightness) {\n    float c = smoothstep(-softness,softness,-(length(p-emitPos)-radius));\n    emitColor = (emitColor*c)*brightness;\n    return emitColor;\n}\n\nfloat linear(float t) {\n  return t;\n}\n\n// A smart way to control the animation. function is from \"http://qiita.com/gaziya5/items/29a51b066cb7d24983d6\"\nfloat animscene(in float t, float w, float s) {\n    return clamp(t - w, 0.0, s) / s;  \n}\n\nvec4 ring(vec3 p) {\n    vec3 prevP = p;\n    float y = -1.0;\n    \n    // ring floor\n    float ringfloor = sdBox(p-vec3(0.0,y,0.0),vec3(4.0,0.2,4.0));\n        \n    float dshadow = length(p.xz)-2.0;\n    vec3 rcol = mix(vec3(0.3,0.7,1.0),vec3(0.3,0.7,1.0)*0.5,S(dshadow,-1.5));\n    vec4 resRingfloor = vec4(rcol,ringfloor);\n    \n    // corner post\n    p.xz = abs(p.xz);\n    p.xz -= 3.5;\n    float post = sdVerticalCapsule(p-vec3(0.0,y+0.25,0.0),1.5,0.1);\n    vec4 resPost = vec4(vec3(0.0,0.0,0.8),post);\n    float rope1 = sdTorus(p-vec3(0.0,y+0.5,0.0),vec2(0.12,0.02));\n    float rope2 = sdTorus(p-vec3(0.0,y+1.0,0.0),vec2(0.12,0.02));\n    float rope3 = sdTorus(p-vec3(0.0,y+1.5,0.0),vec2(0.12,0.02));\n    p = prevP;\n    \n    p.x = abs(p.x);\n    float ropeLine0 = sdCapsule(p-vec3(0.0,y+0.5,0.0), vec3(3.5,0.0,3.5),vec3(3.5,0.0,-3.5),0.02);\n    float ropeLine1 = sdCapsule(p-vec3(0.0,y+1.0,0.0), vec3(3.5,0.0,3.5),vec3(3.5,0.0,-3.5),0.02);\n    float ropeLine2 = sdCapsule(p-vec3(0.0,y+1.5,0.0), vec3(3.5,0.0,3.5),vec3(3.5,0.0,-3.5),0.02);\n    \n    p = prevP;\n    p.z = abs(p.z);\n    float ropeLine3 = sdCapsule(p-vec3(0.0,y+0.5,0.0), vec3(-3.5,0.0,3.5),vec3(3.5,0.0,3.5),0.02);\n    float ropeLine4 = sdCapsule(p-vec3(0.0,y+1.0,0.0), vec3(-3.5,0.0,3.5),vec3(3.5,0.0,3.5),0.02);\n    float ropeLine5 = sdCapsule(p-vec3(0.0,y+1.5,0.0), vec3(-3.5,0.0,3.5),vec3(3.5,0.0,3.5),0.02);\n    \n    float ropeLineD = min(ropeLine0,min(ropeLine1,min(ropeLine2,min(ropeLine3,min(ropeLine4,ropeLine5)))));\n    float ropeD = min(rope1,min(rope2,min(rope3,ropeLineD)));\n    \n    p = prevP;\n    \n    float speed = 1.5;\n    float animTime = mod(iTime,speed*4.0);\n    float ez = 0.0;\n    ez += linear(animscene(animTime, 0.0, speed))*-7.0;\n    ez += linear(animscene(animTime, speed*2.0, speed))*7.0;\n    \n    float ex = 0.0;\n    ex += linear(animscene(animTime, speed, speed))*-7.0;\n    ex += linear(animscene(animTime, speed*3.0, speed))*7.0;\n    \n    vec3 emitPos = vec3(3.5+ex,y+1.5,3.5+ez);\n    vec3 ecol = emitColor(p,emitPos, vec3(0.9),0.01,0.9,5.0);\n    \n    vec4 resRope1 = vec4(vec3(0.8,0.0,0.0)+ecol,ropeD);\n    \n    return combine(resRingfloor,combine(resPost,resRope1));\n}\n\nvec4 sunshineHead(vec3 p,vec3 bcol) {\n    vec3 prevP = p;\n    float y = 2.0;\n    float b = sdBox(p-vec3(0.0,y+1.25,0.15),vec3(0.17,0.25,0.2));\n    p.x = abs(p.x);\n    float b2 = sdBox(p-vec3(0.13,y+1.15,0.47),vec3(0.09,0.15,0.2));\n    p = prevP;\n    float b3 = sdBox(p-vec3(0.0,y+1.09,0.47),vec3(0.1,0.09,0.2));\n    float bd = max(-b3,max(-b2,b));\n    \n    float dmouth = sdBox(p-vec3(0.0,y+1.1,0.25),vec3(0.1,0.01,0.05));\n    p.x = abs(p.x);\n    float dmouth2 = sdBox(p-vec3(0.09,y+1.1,0.25),vec3(0.01,0.03,0.05));\n    p = prevP;\n    \n    vec4 resB = vec4(bcol,bd*0.6);\n    vec4 resMouth = vec4(vec3(0.5,0.0,0.0),min(dmouth,dmouth2));\n    \n    p.yz*=Rot(radians(90.0));\n    p.y += 2.35;\n    p.z -= 3.4;\n    vec2 uv = p.xz;\n    uv*=6.0;\n    float logo = sdBox(p-vec3(0.0,y,0.0),vec3(0.07,0.002,0.07));\n    vec3 lcol = sunshineLogo(uv,bcol);\n    vec4 resLogo = vec4(lcol,logo);\n    \n    return combine(resB,combine(resMouth,resLogo));\n}\n\nvec4 sunshineBody(vec3 p,vec3 bcol) {\n    vec3 prevP = p;\n    float y = 2.0;\n    \n    float b = sdBox(p-vec3(0.0,y,0.03),vec3(0.7,0.9,0.23));\n    float b2 = sdBox(p-vec3(0.0,y+0.2,0.03),vec3(0.9,0.8,0.23));\n    \n    p.x = abs(p.x);\n    float b3plane = dot(p-vec3(0.3,y,0),vec3(-0.7,1.5,-1.0));\n    float b3 = sdBox(p-vec3(0.0,y+0.6,0.2),vec3(0.9,0.4,0.2));\n    p = prevP;\n    \n    p.x *=0.2;\n    float b3tri = sdTriPrism(p-vec3(0.0,y+0.2,0.2),vec2(0.2,0.3));\n    b3 = max(-b3tri,max(-b3plane,b3));\n    p = prevP;\n    \n    p.x = abs(p.x);\n    float sholder = sdBox(p-vec3(0.7,y+1.25,0.1),vec3(0.2,0.25,0.3));\n    float splane0 = dot(p-vec3(0.85,y+1.5,0),vec3(-1.7,1.2,0.0));\n    float splane1 = dot(p-vec3(0.6,y+1.5,0),vec3(0.8,1.0,0.0));\n    sholder = max(splane1,max(splane0,sholder));\n    \n    p = prevP;\n    p.x = abs(p.x);\n    p.y += y;\n    p.x+=0.01;\n    \n    float plane0 = dot(p-vec3(-0.6,0.0,0),vec3(0.4,-0.10,0.0));\n    b = max(plane0,b);\n    float bd = min(min(b,min(b2,b3)),sholder);\n    p = prevP;\n    \n    p.yz*=Rot(radians(90.0));\n    p.y += 2.4;\n    p.z -= 2.7;\n    vec2 uv = p.xz;\n    uv*=2.5;\n    float logo = sdBox(p-vec3(0.0,y,0.0),vec3(0.25,0.002,0.25));\n    vec3 lcol = sunshineLogo(uv,bcol);\n    vec4 resLogo = vec4(lcol,logo);\n    vec4 resB = vec4(bcol,bd*0.6);\n    return combine(resB,resLogo);\n}\n\nfloat hands(vec3 p) {\n    vec3 prevP = p;\n    p.x*=0.8;\n    float sc = mix(0.01,3.5,smoothstep(-1.0,1.0,p.y));\n    p.z *= sc;\n    float e = sdEllipsoid(p,vec3(0.1,0.28,0.35));\n    p = prevP;\n    p.x*=0.8;\n    float thumb = sdCapsule(p, vec3(0.0,0.0,0.15),vec3(0.0,-0.2,0.25),0.05);\n    \n    float dh = min(e,thumb);\n    return dh;\n}\n\nvec4 sunshineArm(vec3 p,vec3 bcol) {\n    vec3 prevP = p;\n    float y = 2.5;\n    \n    p.x = abs(p.x);\n    p.yx *= Rot(radians(30.0)); \n    p.xy += vec2(-1.1,1.0);\n    \n\tbcol = bodyPaint(p.yx);\n    bcol += bodyPaint(p.yz);    \n    \n    float b = sdBox(p-vec3(1.2,y,0.03),vec3(0.2,0.45,0.2));\n    float b2 = sdBox(p-vec3(1.2,y-0.93,0.03),vec3(0.2,0.45,0.2));\n    float bd = min(b,b2);\n    vec4 resB = vec4(bcol,bd);\n    float dHands = hands(p-vec3(1.2,y-1.5,0.03));\n    vec4 resHands = vec4(BASE_COLOR,dHands);\n    \n    return combine(resB,resHands);\n}\n\nvec4 sunshineLegs(vec3 p,vec3 bcol) {\n    vec3 prevP = p;\n    float y = 0.9;\n    \n    p.x = abs(p.x);\n    float b = sdBox(p-vec3(0.58,y,0.03),vec3(0.25,0.45,0.25));\n    float b2 = sdBox(p-vec3(0.58,y-0.95,0.03),vec3(0.25,0.45,0.25));\n    float bd = min(b,b2);\n    vec4 resB = vec4(bcol,bd);\n    \n    float plane = dot(p-vec3(0.0,y,-1.1),vec3(0.0,1.0,1.0));\n    float foot = sdBox(p-vec3(0.58,y-1.6,0.1),vec3(0.25,0.15,0.4));\n    foot = max(plane,foot);\n    vec4 resFoot = vec4(BASE_COLOR,foot*0.6);\n    return combine(resB,resFoot);\n}\n\nvec4 sunshine(vec3 p) {\n    vec3 prevP = p;\n    float y = 0.2;\n    \n    vec3 bcol = bodyPaint(p.yx);\n    bcol += bodyPaint(p.yz);\n    \n    vec4 resHead = sunshineHead(p,bcol);\n    vec4 resBody = sunshineBody(p,bcol);\n    vec4 resArms = sunshineArm(p,bcol);\n    vec4 resLegs = sunshineLegs(p,bcol);\n    \n    return combine(resHead,combine(combine(resBody,resArms),resLegs));\n}\n\nvec4 GetDist(vec3 p) {\n    \n    vec3 prevP = p;\n    float _floor = p.y+1.0;\n    \n    // ring\n    vec4 resRing = ring(p);\n    \n    // sunshine\n    vec4 resSunshine = sunshine(p);\n    \n    // ground\n    vec4 f = vec4(vec3(0.3,0.8,0.3),_floor*0.6);\n    \n    vec4 model = combine(combine(resRing,resSunshine),f);\n    return model;\n}\n\nRay RayMarch(vec3 ro, vec3 rd) {\n    Ray r;\n    r.d = 1.0;\n    \n    float lastDistEval = 1e10; \n    float dist;\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*r.d;\n        vec4 dS = GetDist(p);\n        dist =  dS.w;\n        r.d += dS.w;\n        r.mat = dS.xyz;\n        \n\t\tif (lastDistEval < EDGE_WIDTH && dist > lastDistEval + 0.001) {\n\t\t\tr.edge = 1.0;\n\t\t}\n        if (dist < lastDistEval) lastDistEval = dist;\n        \n        if(r.d>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return r;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nvec2 GetLight(vec3 p) {\n    vec3 lightPos = vec3(2,8,3);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).d;\n    \n    float lambert = max(.0, dot( n, l))*0.1;\n\n    return vec2((lambert+dif),0.9) ;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://github.com/dmnsgn/glsl-tone-map/blob/master/aces.glsl\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nvec3 animationBg(vec2 uv, vec3 col, float t) {\n \t\tvec2 uvRef = uv;\n\t\tuv*=1.5;\n        uv*=vec2(15.0,1.5);\n        uv.y-=t*2.0;\n        \n        vec2 uv2 = fract(uv)-0.5;\n        vec2 id = floor(uv);\n        float h = hash21(id);\n        t+= h;\n        \n        float x = 0.0;\n        float y = sin(t*5.0)*.3;\n        vec2 lpos = (uv2-vec2(x,y))/vec2(2.0,1.0);\n        float l = dBox2d(lpos,vec2(0.02,0.3));\n        \n        col = mix(BASE_COLOR*1.1,BASE_COLOR*0.001,smoothstep(0.0,1.0,uvRef.y));\n        col = mix(col,vec3(h),S(l,0.0));\n        return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    float t = mod(iTime,8000.0);\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 4, -5);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-20.0));\n    ro.xz *= Rot(t*.3+1.0);\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,1,0), 1.);\n\n    Ray r = RayMarch(ro, rd);\n    \n    if(r.d<MAX_DIST) {\n        vec3 p = ro + rd * r.d;\n    \n        vec2 dif = GetLight(p);\n        col = vec3(dif.x)*r.mat;\n        col *= dif.y;\n        \n    } else {\n        // background\n        col = animationBg(uv,col,t)*0.7;\n    }\n    \n    col = mix(col,vec3(0.1,0.1,0.1),r.edge);\n    \n    // post-process\n    col = aces(col);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}