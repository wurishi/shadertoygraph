{"ver":"0.1","info":{"id":"llffzM","date":"1522229728","viewed":1284,"name":"Still non-accurate atmosphere ","username":"Ultraviolet","description":"Remake of [url=https://www.shadertoy.com/view/Ml2cWG]\nNon-accurate atmosphere[/url] by robobo1221 in the spherical domain.\nClick  to set sun position.\nUse space to change mapping.\nTODO: changing sun color temperature based on angle.","likes":15,"published":1,"flags":16,"usePreview":0,"tags":["sun","sky","atmosphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n\tfork of \"Non physical based atmospheric scattering\" by robobo1221\n\n*/\n\nconst float pi = 3.14159265359;\n\nconst float zenithOffset = 0.0;\nconst float multiScatterPhase = 0.1;\nconst float density = 0.7;\n\nconst vec3 skyColor = vec3(0.39, 0.57, 1.0); //Make sure one of the conponents is never 0.0\n\n\nfloat greatCircleDist(vec2 p, vec2 lp)\n{\n    float phi_1 = p.y;\n    float phi_2 = lp.y;\n    float delta_lambda = p.x-lp.x;\n    return acos(sin(phi_1)*sin(phi_2) + cos(phi_1)*cos(phi_2)*cos(delta_lambda));\n}\n\nfloat  zenithDensity(float x)\n{\n    \n    return density / pow(max(x - zenithOffset, 0.35e-2), 0.75);\n}\n\nvec3 getSkyAbsorption(vec3 x, float y){\n\t\n\tvec3 absorption = x * -y;\n\t     absorption = exp2(absorption) * 2.0;\n\t\n\treturn absorption;\n}\n\nfloat getSunPoint(vec2 p, vec2 lp){\n    float dist = greatCircleDist(p, lp)/pi*2.;\n\treturn smoothstep(0.03, 0.026, dist) * 50.0;\n}\n\n\nfloat getRayleigMultiplier(vec2 p, vec2 lp)\n{\n    float dist = greatCircleDist(p, lp)/pi*5.;\n\treturn 1.0 + pow(1.0 - clamp(dist, 0.0, 1.0), 2.0) * pi * 0.5;\n}\n\nfloat getMie(vec2 p, vec2 lp){\n    float dist = greatCircleDist(p, lp)/pi*2.;\n\tfloat disk = clamp(1.0 - pow(dist, 0.1), 0.0, 1.0);\n\t\n\treturn disk*disk*(3.0 - 2.0 * disk) * 2.0 * pi;\n}\n\nvec3 getAtmosphericScattering(vec2 p, vec2 lp)\n{\n    \n\tfloat zenith = zenithDensity(p.y);\n\tfloat sunPointDistMult =  clamp(length(max(lp.y + multiScatterPhase - zenithOffset, 0.0)), 0.0, 1.0);\n\t\n\tfloat rayleighMult = getRayleigMultiplier(p, lp);\n\t\n\tvec3 absorption = getSkyAbsorption(skyColor, zenith);\n    vec3 sunAbsorption = getSkyAbsorption(skyColor, zenithDensity(lp.y + multiScatterPhase));\n\tvec3 sky = skyColor * zenith * rayleighMult;\n\tvec3 sun = getSunPoint(p, lp) * absorption;\n\tvec3 mie = getMie(p, lp) * sunAbsorption;\n\t\n\tvec3 totalSky = mix(sky * absorption, sky / (sky + 0.5), sunPointDistMult);\n         totalSky += sun + mie;\n\t     totalSky *= sunAbsorption * 0.5 + 0.5 * length(sunAbsorption);\n\t\n\treturn totalSky;\n}\n\nvec3 jodieReinhardTonemap(vec3 c)\n{\n    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));\n    vec3 tc = c / (c + 1.0);\n\n    return mix(c / (l + 1.0), tc, tc);\n}\n\nvec2 screen2world(vec2 pos)\n{\n    if(texelFetch(iChannel0, ivec2(32,2),0).x < .5)\n    {\n        pos = (pos.xy / iResolution.xy - .5)*vec2(iResolution.x/iResolution.y, 1.);\n        return vec2(atan(pos.y, pos.x), (.5-length(pos))*pi);\n    }\n    \n    return (pos / iResolution.xy - .5) * vec2(2., 1.) * pi;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 position      = screen2world(fragCoord);\n\tvec2 lightPosition = screen2world(iMouse.xy);\n    \n    if(length(iMouse.xy)<10.)\n        //lightPosition = fract(-iTime*.1+0.2)<.5?vec2(0., (.5-fract(-iTime*.2+0.4))*pi) : vec2(pi, -(.5-fract(-iTime*.2+0.4))*pi);\n        lightPosition = vec2(1.0);\n\t\n\tvec3 color = getAtmosphericScattering(position, lightPosition) * pi;\n\tcolor = jodieReinhardTonemap(color);\n    color = pow(color, vec3(2.2)); //Back to linear\n    \n\t\n\tfragColor = vec4(color, 1.0 );\n\n}","name":"Image","description":"","type":"image"}]}