{"ver":"0.1","info":{"id":"MlcGzS","date":"1469870275","viewed":140,"name":"Transforming Box","username":"sea","description":"Transfiorming Box","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["transform","matrices"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415192\n\nconst float fov = 90.0;\n\nvec3 spherePosition = vec3(0.0, 0.0, 3.0);\nvec3 lightPosition = vec3(-3.0, 3.0, 1.0);\n\nfloat sphereRadius = 1.0;\nmat4 boxMat;\n\n// Thanks iq\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n// Each column in a matrix represents a vector facing a particular direction, the \n// first column is forward, the second column is up and the third column is right.\n\n// For each direction in a matrix, each row represents the x, y, z values.\n\n// To rotate around the y-axis, both the forward and right direction need to\n// rotate around their y-axis. Which means we need to set x and z values.\nmat4 yaw (float rotation)\n{\n    return mat4(\n        cos(rotation),\t0.0,\t-sin(rotation),\t0.0,\n        0.0,\t\t\t1.0,\t0.0,\t\t\t0.0,\n        sin(rotation),\t0.0,\tcos(rotation),\t0.0,\n        0.0,\t\t\t0.0,\t0.0,\t\t\t1.0\n    );\n}\n\n// To rotate around the z-axis, both the up and forward direction need to rotate\n// around their z-axis. Which means we need to set the x and z values.\nmat4 roll (float rotation)\n{\n    return mat4(\n        cos(rotation),\tsin(rotation),\t0.0,\t\t\t0.0,\n        -sin(rotation),\tcos(rotation),\t0.0,\t\t\t0.0,\n        0.0,\t\t\t0.0,\t\t\t1.0,\t\t\t0.0,\n        0.0,\t\t\t0.0,\t\t\t0.0,\t\t\t1.0\n    );\n}\n\n\n// To rotate around the x-axis, both the up and right direction need to rotate\n// around their x-axis. Which means we need to set the x and z values.\nmat4 pitch (float rotation)\n{\n    return mat4(\n       \t1.0,\t\t\t0.0,\t\t\t0.0,\t\t\t0.0,\n        0.0,\t\t\tcos(rotation),\tsin(rotation),\t0.0,\n        0.0,\t\t\t-sin(rotation),\tcos(rotation),\t0.0,\n        0.0,\t\t\t0.0,\t\t\t0.0,\t\t\t1.0\n    );\n}\n\nvec3 intesectBox (vec3 rayOrigin, vec3 rayDirection)\n{\n    float distance = 0.0;\n    \n    // Walk forward starting from the ray origin in the ray direction.\n    for (float i = 0.0; i < 8.0; i += 0.01)\n    {\n        // Calculate ray position.\n        vec3 point = rayOrigin + rayDirection * i;\n        point = (roll(iTime) * pitch(iTime) * vec4(point, 1.0)).xyz;\n        \n        if (sdBox(point, vec3(0.5)) <= 0.0)\n            return vec3(1.0);\n    }\n    \n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 viewSpace = uv * 2.0 - 1.0;\n    \n    float aspect = iResolution.x / iResolution.y;\n    \n    viewSpace.y /= aspect;\n    \n    vec3 rayOrigin = vec3(0.0, 0.0, -3.0);\n    \n    // Calculate ray direciton.\n    vec3 rayDirection = normalize(vec3(viewSpace, 1.0));\n    vec3 color = intesectBox(rayOrigin, rayDirection);\n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}