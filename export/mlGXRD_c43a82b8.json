{"ver":"0.1","info":{"id":"mlGXRD","date":"1685968935","viewed":73,"name":"Glow Sphere","username":"stefanasandei","description":"A ray marched sphere with a glowy effect. ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_STEPS = 256;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nfloat sphereSDF(vec3 p, float s)\n{\n  return length(p)-s;\n}\n\nfloat roundBoxSDF( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sceneSDF(vec3 point)\n{\n    return sphereSDF(point, 0.8);\n}\n\nfloat shootRay(vec3 rayOrigin, vec3 rayDir)\n{\n    float depth = MIN_DIST;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float dist = sceneSDF(rayOrigin + depth * rayDir);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= MAX_DIST) {\n            return MAX_DIST;\n        }\n    }\n    return MAX_DIST;\n}\n\nvec3 computeNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 palette(float t) \n{\n    vec3 a = vec3(0.608, 0.558, 0.668);\n    vec3 b = vec3(0.968, 0.028, 0.588);\n    vec3 c = vec3(0.338, 1.000, 1.000);\n    vec3 d = vec3(-1.252, -0.142, 0.198);\n\n    return a + b*cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord - iResolution.xy / 2.0;\n    float fov = 45.0;\n    float z = iResolution.y / tan(radians(fov) / 2.0);\n    \n    vec3 rayOrigin = vec3(0.0, 0.0, 5.0);\n    vec3 rayDir = normalize(vec3(uv, -z));\n   \n    float dist = shootRay(rayOrigin, rayDir);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n        \n    vec3 p = rayOrigin + dist * rayDir;\n    vec3 norm = computeNormal(p);\n    \n    float speed = 0.2;\n    float t = sin(iTime * speed / 3.0) + iTime / 100.0;\n    \n    vec3 lightDir = normalize(vec3(-1.0+cos(iTime), sin(iTime), -1.0));\n    float lightIntensity = max(dot(norm, -lightDir), 0.0);\n    \n    //vec3 albedo = vec3(0.3, 0.5, 1.0);\n    vec3 albedo = palette(t);\n    albedo *= lightIntensity;\n    \n    albedo = 1.0 - 0.02 / albedo;\n    \n    fragColor = vec4(albedo, 1.0);\n    \n    float gamma = 0.5;\n    fragColor.rgb = 1.0-pow(fragColor.rgb, vec3(1.0/gamma));\n}","name":"Image","description":"","type":"image"}]}