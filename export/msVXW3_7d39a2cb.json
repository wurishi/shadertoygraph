{"ver":"0.1","info":{"id":"msVXW3","date":"1681838915","viewed":40,"name":"Goku vs Vegeta","username":"LambsBread","description":"Shadertoy Assignment","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["raycast","camera","postprocess","buffer","lesson"],"hasliked":0,"parentid":"msdXDn","parentname":"CG2023 04"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int spheresNo = 27;\nSphere spheres[spheresNo];\n\nconst int planeNo = 1;\nPlane planes[planeNo];\n\nconst int triangleNo = 33;\nTriangle triangles[triangleNo];\n\nMaterial materials[12];\n\n// ---- CAMERA and EVENTs ----\n// Common key codes (WASD instead of arrows)\n\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nconst vec3 EyeStartPosition = vec3(0,10,40.5);\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2)\n{\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    \n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw+EyeStartPosition;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 0.2;\n    if (isKeyHeld(KeyLeft )) eye -= u*speed;\n    if (isKeyHeld(KeyRight)) eye += u*speed;\n    if (isKeyHeld(KeyUp   )) eye += w*speed;\n    if (isKeyHeld(KeyDown )) eye -= w*speed;\n    \n    if(iMouse.z>=0.)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//P\n               0.5,\t\t\t\t\t\t\t//minT\n               normalize(w+px.x*u+px.y*v),\t//V\n               500.);\t\t\t\t\t\t//maxT\n}\n\n// ---- MAIN ----\n\nconst float maxT = 1000.0;\n\nTraceResult intersectSphere(Ray ray, Sphere s)\n{\n    vec3 p0c = ray.p0 - s.c;\n    float a = dot(ray.v, ray.v);\n    float b = 2.0 * dot(p0c, ray.v);\n    float c = dot(p0c,p0c) - s.r*s.r;\n    float discriminant = b*b - 4.0*a*c;\n    if(discriminant < 0.0)\n        return TraceResult(vec3(0),ray.tmax, -1); // no intersection\n    float sqd = sqrt(discriminant);\n    float numerator = -b - sqd;\n    if(numerator < 0.0)\n        numerator = -b + sqd;\n    float t = 0.5 * numerator / a;\n    vec3 p = ray.p0 + t * ray.v;\n    vec3 normal = normalize(p - s.c);\n    return TraceResult(normal, t, s.matID);\n}\n\nTraceResult intersectPlane(Ray ray, Plane plane)\n{\n    float t = dot(plane.q0-ray.p0,plane.n)/dot(ray.v,plane.n);\n    return TraceResult(plane.n,t, plane.matID);\n}\n\nTraceResult intersectTriangle(Ray ray, Triangle tr) {\n    vec3 ab = tr.b - tr.a;\n    vec3 ac = tr.c - tr.a;\n    vec3 pvec = cross(ray.v, ac);\n    float det = dot(ab, pvec);\n    if (abs(det) < 0.000001) {\n        return TraceResult(vec3(0), ray.tmax, tr.matID);\n    }\n    float invDet = 1.0 / det;\n    vec3 tvec = ray.p0 - tr.a;\n    float u = dot(tvec, pvec) * invDet;\n    if (u < 0.0 || u > 1.0) {\n        return TraceResult(vec3(0), ray.tmax, tr.matID);\n    }\n    vec3 qvec = cross(tvec, ab);\n    float v = dot(ray.v, qvec) * invDet;\n    if (v < 0.0 || u + v > 1.0) {\n        return TraceResult(vec3(0), ray.tmax, tr.matID);\n    }\n    float t = dot(ac, qvec) * invDet;\n    vec3 normal = normalize(cross(ab, ac));\n    return TraceResult(normal, t, tr.matID);\n}\n\nTraceResult raycast(Ray ray)\n{\n    TraceResult res = TraceResult(vec3(0), ray.tmax, -1);\n    for(int i = 0; i < spheresNo; ++i)\n    {\n        TraceResult res2 = intersectSphere(ray, spheres[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    for(int i = 0; i < planeNo; ++i)\n    {\n        TraceResult res2 = intersectPlane(ray, planes[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    for(int i = 0; i < triangleNo; ++i)\n    {\n        TraceResult res2 = intersectTriangle(ray, triangles[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    return res;\n}\n\nvec4 missColor(Ray ray)\n{\n    return vec4(texture(iChannel2, ray.v).xyz,1.);\n}\n\nvec4 hitColor(Ray ray, TraceResult tr, vec3 lightPos) {\n    Material mat = materials[tr.matID]; // Get the material information from the material ID in the TraceResult\n    \n    vec3 p = ray.p0 + ray.v * tr.t; // Calculate the hit point in world coordinates using ray's origin, direction, and t value from TraceResult\n    vec3 n = tr.n; // Get the surface normal from TraceResult\n    vec3 v = -ray.v; // Calculate the view direction as the negation of the ray's direction\n    vec3 l = normalize(lightPos - p); // Calculate the light direction as the normalized vector from hit point to light source\n    \n    // Emission\n    vec3 emission = mat.emission * dot(n,v); // Calculate the emission contribution by multiplying the material's emission color with the dot product of surface normal and view direction\n    \n    // Add texture\n    if (mat.texID == 1) {\n        vec3 texColor = texture(iChannel3, tr.n.xy).rgb; // Use hit point's UV coordinates to sample a texture and get the RGB color\n        mat.color *= texColor; // Multiply the material's base color with the texture color\n    }\n    \n    // Shadow\n    Ray shadowray = Ray(p,0.001,l,length(lightPos-p)); // Create a shadow ray from hit point towards the light source with a small offset to avoid self-shadowing\n    TraceResult shadowRes = raycast(shadowray); // Cast the shadow ray to check for occlusion\n    \n    if (shadowRes.t < shadowray.tmax) {     // If there is an intersection along the shadow ray, return only the emission color (i.e., fully shadowed)\n         return vec4(emission,1.);\n    }\n    \n    // Diffuse\n    float costheta = max(dot(n,l),0.);      // Calculate the cosine of angle between surface normal and light direction, clamped to [0,1]\n    vec3 k_d = mat.color * mat.roughness;   // Calculate the diffuse reflection coefficient by multiplying the material's base color with roughness\n    \n    // Specular\n    vec3 toLight = normalize(lightPos - p); // Calculate the normalized vector from hit point to light source\n    vec3 toEye = -ray.v;                    // Calculate the normalized view direction as the negation of the ray's direction\n    vec3 k_s = vec3(mat.metalness);         // Convert the material's metalness to a vec3 for specular reflection coefficient\n    vec3 h = normalize(toLight+toEye);      // Calculate the half vector as the normalized sum of light direction and view direction\n    \n    // Shininess\n    float si = pow(clamp(dot(h,n),0.,1.),0.); // Calculate the specular reflection exponent using the dot product of half vector and surface normal\n    \n    // Final color\n    vec3 color = emission+(k_d+si*k_s)*costheta; // Calculate the final color by summing the emission, diffuse, and specular contributions\n    \n    return vec4(color, 1.); // Return the final color as a vec4 with alpha set to 1.0\n}\n\n\nvoid initScene() {\n    materials[0] = Material(vec3(6., 1.5, 0.3), 0.1, vec3(0), 0.03, 0.,0.,0); //Orange\n    materials[1] = Material(vec3(0.3, 1, 5.5), 1., vec3(0.3, 1, 5.5), 0.7, 0.,0.,0); // Genki Dama\n    materials[2] = Material(vec3(4., 4., 4.), 0.15, vec3(0.1), 0.01, 0.,0.,0); // Gray\n    materials[3] = Material(vec3(1.3, 0.8, 0.6), 0.3, vec3(0.1), 0.03, 0.,0.,0); // Skin\n    materials[4] = Material(vec3(0.3, 1, 4.1), 0.1, vec3(0), 0.04, 0.,0.,0); // Blue\n    materials[5] = Material(vec3(0., 0., 0.), 0.1, vec3(0.05), 0.15, 0.,0.,0); // Boots\n    materials[6] = Material(vec3(0., 0., 0.), 0.1, vec3(0), 0.00, 0.,0.,0); // Hair\n    materials[7] = Material(vec3(10., 10, 10), 0.1, vec3(0), 0.03, 0.,0.,0); // white eyes\n    materials[8] = Material(vec3(5., 5, 5), 0.1, vec3(0), 0.03, 0.,0.,0); // white clothes\n    materials[9] = Material(vec3(1.3, 0.9, 0.02), 0.5, vec3(0.1), 0.03, 0.,0.,0); // yellow\n    materials[10] = Material(vec3(22.*abs(sin(iTime*2.)) + 0.3, 0.5*abs(sin(iTime*2.)) + 1., 1.2*abs(sin(iTime)) +6.1), 0.01, vec3(abs(sin(iTime*2.)), 0.2*abs(sin(iTime*2.)) + 0.1, abs(sin(iTime)) +6.1), 0.6, 0.,0.,0); // Galick gun\n    materials[11] = Material(vec3(6., 6., 6.), 0.1, vec3(0), 0.1, 0.,0.,1); //Orange\n    \n    planes[0] = Plane(vec3(0, -5, 0), normalize(vec3(0, 1, 0)), 2); // ground (plane)\n\n    // Goku\n    spheres[0] = Sphere(vec3(0, -2.2, 0), 0.4f, 3);     // head\n    spheres[1] = Sphere(vec3(-0.6, -2.8, 0), 0.3f, 4);  // left arm\n    spheres[2] = Sphere(vec3(0.6, -2.8, 0), 0.3f, 4);   // right arm\n    spheres[3] = Sphere(vec3(-1., -2, 0), 0.25f, 3);  // left hand\n    spheres[4] = Sphere(vec3(1., -2, 0), 0.25f, 3);   // right hand\n    spheres[5] = Sphere(vec3(0, -3.3, 0), 0.62f, 0);     // torso\n    spheres[6] = Sphere(vec3(-0.6, -4.2, 0), 0.35f, 0);    // left leg (top right)\n    spheres[7] = Sphere(vec3(0.6, -4.2, 0), 0.35f, 0);     // right leg (top left)\n    spheres[8] = Sphere(vec3(-0.85, -4.8, 0), 0.3f, 5);   // left leg (bottom)\n    spheres[9] = Sphere(vec3(0.85, -4.8, 0), 0.3f, 5);   // right leg (bottom)\n    spheres[10] = Sphere(vec3(0, 4.2 + abs(10.*sin(iTime*0.12)), 0), 4.5f + abs(10.*sin(iTime*0.12)), 1);     // genki dama\n    spheres[11] = Sphere(vec3(-0.11, -2.15, 0.39), 0.018f, 4);  // right eye\n    spheres[12] = Sphere(vec3(0.11, -2.15, 0.39), 0.018f, 4);  // right eye\n\n    triangles[0] = Triangle(vec3(0, -2.9, 0.5), vec3(0.2, -2.65, 0.2),vec3(-0.2, -2.65, 0.2), 4); // shirt                        \n    triangles[1] = Triangle(vec3(0.75, -2.35, 0.3), vec3(0.25, -1.85, 0.3),vec3(-0.1, -2.25, 0.3), 6); // hair\n    triangles[2] = Triangle(vec3(0.35, -2.1, 0.3), vec3(0.9, -1.7, 0.3),vec3(-0.25, -1.9, 0.3), 6); // hair\n    triangles[3] = Triangle(vec3(0.3, -1.95, 0.35), vec3(0.65, -1.15, 0.35),vec3(-0.2, -1.95, 0.35), 6); // hair\n    triangles[4] = Triangle(vec3(0.3, -1.8, 0.3), vec3(-0.75, -1.85, 0.3),vec3(-0.3, -2.15, 0.3), 6); // hair\n    triangles[5] = Triangle(vec3(0.3, -1.8, 0.3), vec3(-0.65, -2.1, 0.3),vec3(-0.3, -2.3, 0.3), 6); // hair\n    triangles[6] = Triangle(vec3(0.35, -1.8, 0.3), vec3(-0.1, -1.7, 0.),vec3(-0.46, -1.9, 0.4), 6); // hair top view                        \n    triangles[7] = Triangle(vec3(0.2, -2.15, 0.37), vec3(0.2, -2.07, 0.35),vec3(0.05, -2.17, 0.42), 7); // eye 1                    \n    triangles[8] = Triangle(triangles[7].a * vec3(-1, 1, 1), triangles[7].c * vec3(-1, 1, 1), triangles[7].b * vec3(-1, 1, 1), triangles[7].matID); //eye2\n    triangles[9] = Triangle(vec3(0.08, -2.45, 0.33), vec3(0.15, -2.37, 0.4),vec3(-0.13, -2.37, 0.35), 7); // mouth\n    \n    // Vegeta\n    spheres[13] = Sphere(vec3(0, -2.2, 80), 0.4f, 3);     // head\n    spheres[14] = Sphere(vec3(0.6, -2.8, 80), 0.3f, 4);  // left arm\n    spheres[15] = Sphere(vec3(-0.6, -2.8, 80), 0.3f, 4);   // right arm\n    spheres[16] = Sphere(vec3(0.3, -2.95, 79), 0.22f, 8);  // left hand\n    spheres[17] = Sphere(vec3(-0.3, -2.95, 79), 0.22f, 8);   // right hand\n    spheres[18] = Sphere(vec3(0, -3.3, 80), 0.6f, 8);     // torso\n    spheres[19] = Sphere(vec3(0.6, -4.2, 80), 0.3f, 4);    // left leg (top right)\n    spheres[20] = Sphere(vec3(-0.6, -4.2, 80), 0.3f, 4);     // right leg (top left)\n    spheres[21] = Sphere(vec3(0.85, -4.8, 80), 0.3f, 8);   // left leg (bottom)\n    spheres[22] = Sphere(vec3(-0.85, -4.8, 80), 0.3f, 8);   // right leg (bottom)\n    spheres[23] = Sphere(vec3(-0.11, -2.15, 79.6), 0.018f, 4);  // right eye\n    spheres[24] = Sphere(vec3(0.11, -2.15, 79.6), 0.018f, 4);  // eye\n    spheres[25] = Sphere(vec3(0, -3., 77.5f - 78. *abs(sin(iTime*0.1))),1.3*abs(sin(iTime*0.1)) + 0.68f, 10);     // galick gun\n    \n    triangles[10] = Triangle(vec3(0, -4.3, 79.5), vec3(-0.3, -3.5, 79.4), vec3(0.3, -3.5, 79.4), 9); // mid protector\n    triangles[11] = Triangle(vec3(0.75, -2.35, 80.3), vec3(0.25, -1.85, 80.3), vec3(-0.1, -2.25, 80.3), 6); // hair\n    triangles[12] = Triangle(vec3(0.35, -2.1, 80.3), vec3(0.9, -1.7, 80.3), vec3(-0.25, -1.9, 80.3), 6); // hair\n    triangles[13] = Triangle(vec3(0.3, -1.95, 80.35), vec3(0.65, -1.15, 80.35), vec3(-0.2, -1.95, 80.35), 6); // hair\n    triangles[14] = Triangle(vec3(0.3, -1.8, 80.3), vec3(-0.75, -1.85, 80.3), vec3(-0.3, -2.15, 80.3), 6); // hair\n    triangles[15] = Triangle(vec3(0.3, -1.8, 80.3), vec3(-0.65, -2.1, 80.3), vec3(-0.3, -2.3, 80.3), 6); // hair\n    triangles[16] = Triangle(vec3(0.35, -1.8, 80.3), vec3(-0.1, -1.7, 80.3), vec3(-0.46, -1.9, 80.4), 6); // hair top view\n    triangles[17] = Triangle(vec3(-0.2, -2.15, 79.6), vec3(-0.2, -2.07, 79.65), vec3(-0.05, -2.17, 79.6), 7); // eye 1\n    triangles[18] = Triangle(triangles[17].a * vec3(-1, 1, 1), triangles[17].c * vec3(-1, 1, 1), triangles[17].b * vec3(-1, 1, 1), triangles[7].matID); // eye 2\n    triangles[19] = Triangle(vec3(-0.08, -2.45, 79.65), vec3(-0.15, -2.37, 79.64), vec3(0.13, -2.37, 79.65), 7); // mouth\n    triangles[20] = Triangle(vec3(-0.86, -4.3, 79.7), vec3(-0.6, -3.5, 80.), vec3(-0.29, -3.5, 79.4), 9); // left protector\n    triangles[21] = Triangle(vec3(0.86, -4.3, 79.7), vec3(0.27, -3.5, 79.35), vec3(0.66, -3.5, 80.), 9); // right protector\n    triangles[22] = Triangle(vec3(-1.75, -2.4, 79.5), vec3(-0.33, -2.5, 79.9), vec3(-0.42, -2.9, 79.55), 9); // left shoulder protector\n    triangles[23] = Triangle(triangles[22].a * vec3(-1, 1, 1), triangles[22].c * vec3(-1, 1, 1), triangles[22].b * vec3(-1, 1, 1), triangles[22].matID); // right sh prot\n    triangles[24] = Triangle(vec3(0.3, -1.95, 80.35), vec3(0.05, -0.65, 80.35), vec3(-0.2, -1.95, 80.35), 6); // hair\n    triangles[25] = Triangle(vec3(-0.3, -1.95, 80.35), vec3(-0.65, -1.15, 80.35), vec3(0.2, -1.95, 80.35), 6); // hair \n    triangles[26] = Triangle(vec3(0.3, -1.6, 80.25), vec3(0., -1.97, 79.55), vec3(-0.2, -1.6, 80.25), 6); // hair\n   \n    // Vertices of the tetrahedron\n    vec3 vertex1 = vec3(-1.75, -2.4, 79.5);\n    vec3 vertex2 = vec3(-0.33, -2.5, 79.9);\n    vec3 vertex3 = vec3(-0.42, -2.9, 79.55);\n\n    // Centroid of the original triangle\n    vec3 centr = (vertex1 + vertex2 + vertex3) / 3.0;\n    vec3 vertex4 = centr + vec3(0, 0, 1);\n\n    // Create the tetrahedron\n    triangles[27] = Triangle(vertex2,vertex1 , vertex4,  9); // bottom\n    triangles[28] = Triangle(vertex3, vertex2,vertex4 , 9); // neck\n    triangles[29] = Triangle(vertex3, vertex4,vertex1 , 9); // top behind\n    \n    // Mirror the tetrahedron to the left side\n    vec3 mirrorVertex1 = vec3(-vertex1.x, vertex1.y, vertex1.z);\n    vec3 mirrorVertex2 = vec3(-vertex2.x, vertex2.y, vertex2.z);\n    vec3 mirrorVertex3 = vec3(-vertex3.x, vertex3.y, vertex3.z);\n    vec3 mirrorVertex4 = vec3(-vertex4.x, vertex4.y, vertex4.z);\n\n    // Create the mirrored tetrahedron\n    triangles[30] = Triangle(mirrorVertex1, mirrorVertex2, mirrorVertex4, 9); // mirrored bottom\n    triangles[31] = Triangle(mirrorVertex2, mirrorVertex3, mirrorVertex4, 9); // mirrored neck\n    triangles[32] = Triangle(mirrorVertex3, mirrorVertex4, mirrorVertex1, 9); // mirrored top\n    \n    spheres[26] = Sphere(vec3(56, 70, 60), 10., 11);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    initScene();\n    \n    vec3 eye;\n    vec2 data;\n    Ray ray = Camera(fragCoord, eye, data);\n    \n    TraceResult result = raycast(ray);\n    \n    if (ray.tmax <= result.t) // If the ray doesn't hit anything in the scene\n        fragColor = missColor(ray); // Set the fragment color to the miss color\n    else // If the ray hits an object\n        fragColor = hitColor(ray, result, vec3(0,10,40));        // Set the fragment color\n        vec4 fragColor2 = hitColor(ray, result, vec3(-40,0,40)); // Calculate the fragment color with a different light position\n        fragColor += fragColor2; \n        \n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0); // Fetch the previous frame's color from a texture\n    fragColor = 0.2 * prev + 0.8 * fragColor;               // Blend the previous frame's color with the current fragment color using a blend factor\n    fragColor.w = result.t; \n    \n    if (fragCoord.x == 0.5 && fragCoord.y == 0.5)\n        fragColor.yzw = eye - EyeStartPosition;\n    if (fragCoord.x == 1.5 && fragCoord.y == 0.5)\n        fragColor.zw = data;\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float pi = 3.1415926535897932384626433832795;\n\nstruct Material {\n    vec3 color; // [0,1/pi]\n    float roughness; // [0,~7]\n    vec3 emission; // [0, inf]\n    float metalness; // 0.02-0.05 for non-metals, 0.6-0.9 for metals\n    float reflection;\n    float refraction;\n    int texID;\n};\n\nstruct Sphere {\n    vec3 c;    // center\n    float r;   // radius\n    int matID;\n};\n\nstruct Plane {\n    vec3 q0;    // any point on the plane\n    vec3 n;     // normal\n    int matID;\n};\n\nstruct Triangle\n{\nvec3 a,b,c;\nint matID;\n};\n\nstruct Ray\n{\n\tvec3 p0;    // ray origin if tmin=0\n\tfloat tmin; // omit solutions t<tmin\n\tvec3 v;     // direction\n\tfloat tmax; // omit solutions t>tmax\n};\n\nstruct TraceResult\n{\n    vec3 n;  // Normal vector on surface\n    float t; // Distance taken on ray\n    int matID;\n};\n","name":"Common","description":"","type":"common"}]}