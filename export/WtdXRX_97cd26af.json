{"ver":"0.1","info":{"id":"WtdXRX","date":"1581446363","viewed":682,"name":"discrete cosine transform fluid","username":"public_int_i","description":"fluid simulation using discrete cosine transform, based on rory618's fft fluid shader https://www.shadertoy.com/view/wdBGWG\nim fairly certain the mass conservation doesnt work properly without complex numbers but made this for the sake of experimenting","likes":14,"published":3,"flags":32,"usePreview":0,"tags":["simulation","fluid","physics","cosine","discrete","transform","dct"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 o, in vec2 u)\n{\n    o = vec4(length(texelFetch(iChannel0,ivec2(u),0))*.3);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Buffer A - X axis forward(type 2) cosine transform + stochastic advection\n\n#define R4P 1.1673039782614187\nvec4 r4(float n) {\n    return fract(.5+vec4(1./R4P,1./R4P/R4P,1./R4P/R4P/R4P,1./R4P/R4P/R4P/R4P)*n);\n}\nvec4 hash4(vec4 a) {\n    a = mod(abs(a),8273.97234);\n    #define R4S(sw) floor(fract(.352347+dot(a,vec4(.001,.1,10.,100.).sw*2.23454))*20000.)\n    return r4(R4S(xyzw)+R4S(yzwx)+R4S(wxyz)+R4S(zwxy));\n}\n\nfloat pmod(float v, float m) {\n \tif (v < 0.) return m-mod(-v,m)-1.;\n    return mod(v,m);\n}\n\nvec2 advec(float x, float y) {\n    vec2 v = -texelFetch(iChannel0,ivec2(x,y),0).xy;\n    v += (hash4(vec4(x,y,v.x+float(iFrame)/1000.,v.y)*11.1627863).xy-.5)*TURBULENCE;\n    return texelFetch(iChannel0, ivec2(pmod(v.x+x,iResolution.x),pmod(v.y+y,iResolution.y)),0).xy;\n}\n\nvoid mainImage(out vec4 o, in vec2 u)\n{\n    vec2 s = vec2(0);\n    for (float i = .5; i < iResolution.x; i++) s += advec(i,u.y)*cos(i*PI*floor(u.x)/iResolution.x);\n\to = vec4(s,0,0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Buffer B - Y axis forward(type 2) cosine transform + frequency space fluid processing\n\nvoid mainImage(out vec4 o, in vec2 u)\n{\n    vec2 s = vec2(0);\n    for (float i = .5; i < iResolution.y; i++) s += texelFetch(iChannel0,ivec2(u.x,i),0).xy*cos(i*PI*floor(u.y)/iResolution.y);\n\t\n    //frequency space processing\n    \n    //rescaling\n    s /= iResolution.x*iResolution.y*.25;\n    \n    //mass conservation, this is the core of the fluid sim\n    float len = length(s);\n    vec2 nu = normalize(floor(u));\n    s -= nu*dot(nu,s);\n    s *= len/(DIFFUSION+length(s));\n    \n    //prevent drifting\n    if (dot(u,u) < 1.) s = vec2(0);\n    \n    o = vec4(s,0,0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//Buffer C - Y axis inverse(type 3) cosine transform\n\nvoid mainImage(out vec4 o, in vec2 u)\n{\n    vec2 s = texelFetch(iChannel0,ivec2(u.x,0),0).xy*-.5;\n    for (float i = 0.; i < iResolution.y; i++) s += texelFetch(iChannel0,ivec2(u.x,i),0).xy*cos(i*PI*u.y/iResolution.y);\n    o = vec4(s,0,0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//Buffer D - X axis inverse(type 3) cosine transform\n\nvoid mainImage(out vec4 o, in vec2 u)\n{\n    vec2 s = texelFetch(iChannel0,ivec2(0,u.y),0).xy*-.5;\n    for (float i = 0.; i < iResolution.x; i++) s += texelFetch(iChannel0,ivec2(i,u.y),0).xy*cos(i*PI*u.x/iResolution.x);\n     \n    //add velocity forces\n    s += (pow(texture(iChannel1,u/iResolution.xy).xy,vec2(2.2))*2.-1.)*.05;\n    if (iMouse.w > 0.) {\n       \tvec2 d = u-iMouse.xy;\n     \ts += normalize(d)*max(0.,1.-length(d)/40.);\n    }\n    \n    o = vec4(s,0,0);\n}\n","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.141592653589793\n\n#define TURBULENCE 1.5\n#define DIFFUSION 1e-8","name":"Common","description":"","type":"common"}]}