{"ver":"0.1","info":{"id":"wsG3DR","date":"1569986167","viewed":181,"name":"Reflection & Displacement  Rain","username":"LucasWilson","description":"Desperately needs to be optimised :(","likes":2,"published":1,"flags":96,"usePreview":0,"tags":["reflection","rain","raystep"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"llXGDj","filepath":"https://soundcloud.com/rob-beckwith/soft-rain-loop","previewfilepath":"https://soundcloud.com/rob-beckwith/soft-rain-loop","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 const_SunVector= normalize(vec3(1.,.5, 0.2));\nvec3 CamPos = vec3(-.5, 0., 4.);\n\nvec2 map(in vec3 pos) {\n    float d = length(pos-vec3(0.,.28,0.))-.25;\n    //sphere collision\n                \n    float rippleOffset = texture(iChannel1, mod(pos.xz, vec2(1.))).z*10.;\n    if (length(pos-CamPos) > 3.) {\n        rippleOffset = 0.;\n    }\n    float d2 = pos.y-(-.25 + rippleOffset);\n    //ground plane collision\n                \n    return (d2 < d) ? vec2(d2,1.) : vec2(d,2.);\n}\n\nvec3 calcNormal(in vec3 pos){\n\tvec2 e = vec2(.001,0.);\n    \n    return normalize(vec3(\n        \tmap(pos + e.xyy).x-map(pos-e.xyy).x,\n            map(pos + e.yxy).x-map(pos-e.yxy).x,\n            map(pos + e.yyx).x-map(pos-e.yyx).x  ));\n}\n\nvec2 calcRay(in vec3 RayPos, in vec3 RayDirection) {\n    float t = 0.0;\n    float material;\n    \n    for (int i=0; i<100; i++) {\n        vec3 p = RayPos + RayDirection*t;\n        \n        vec2 mapping = map(p);\n        \n        float h = mapping.x;\n        material = mapping.y;\n        if (h<.001) {\n            break;\n        }\n        \n        t += h;\n        \n        if (t > 20.) {\n            break;\n        }\n    }\n    if (t>20.) {\n        t = -1.;\n    }\n    \n    return vec2(t,material);\n}\n\nvec3 CalcGroundShading(in vec3 pos, in vec3 normal) {\n    float sun_shadow = step(calcRay(pos + normal*.1, const_SunVector).x, 0.);\n\tvec2 pixelPos = mod(pos.xz, vec2(1.));\n\tvec3 pixelOffs = texture(iChannel1, pixelPos).xyz;\n    return clamp(sun_shadow, .5, 1.) * texture(iChannel0, pixelPos+pixelOffs.xy*pixelOffs.z).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy - .5) / vec2(1.,iResolution.x/iResolution.y);\n\n    // pixel color rgb\n    vec3 col;\n    \n    vec3 CamLookAt = normalize(vec3(0,0.,-1.));\n    \n    float c = cos(iTime*.3);\n    float s = sin(iTime*.3);\n    mat3 CamRot = mat3(c, 0., s,\n                       0., 1., 0.,\n                       -s, 0., c);\n    mat3 CamTilt = mat3(1., 0., 0.,\n                        0., cos(-.15), -sin(-.15),\n                        0., sin(-.15), cos(-.15));\n    //CamLookAt = CamRot * CamLookAt ;\n    CamPos = CamRot * vec3(0., 0., 2.);\n    \n    \n    vec3 rayDirection = CamRot * CamTilt * normalize( vec3(uv,0.) + CamLookAt);\n    col = texture(iChannel2, rayDirection*vec3(1.,1.5,1.)).xyz;\n    \n    vec2 RayData = calcRay(CamPos, rayDirection);\n    float t = RayData.x;\n    float material = RayData.y;\n    \n    if (t>0. && t<5.) {\n        vec3 pos = CamPos + t*rayDirection;\n        vec3 normal = calcNormal(pos);\n        \n        \n        col = vec3(.18);\n        \n        \n        if (material == 2.) {\n            //col *= 100.;\n            //sphere shading\n            float sun_shadow = step(calcRay(pos + normal*.001, const_SunVector).x, 0.);\n            col += vec3(.8) * sun_shadow * smoothstep(0., 1.5, dot(normal,const_SunVector));//sun diffuse\n        \tcol += vec3(.2, .05, 0.) * .2 * clamp(dot(normal, vec3(0.,-1.,0.)), 0.1, 1.);//ground reflect diffuse\n            \n            vec3 reflectionCol;\n            \n            //calc reflections\n            vec2 reflectionRay = calcRay(pos + normal*.1, normal);\n            float reflectionDepth = reflectionRay.x;\n            vec3 reflectionPos = pos + reflectionDepth*1.*normal;\n            vec3 reflectionNormal = calcNormal(reflectionPos);\n            \n            if (reflectionRay.y == 1. && reflectionRay.x > 0.) {\n                //reflected material is the ground\n                float normalDotFactor = clamp(dot(normal, vec3(0.,-1.,0.)),0.,1.);\n                \n                reflectionCol = normalDotFactor * CalcGroundShading(reflectionPos, normal);\n                //reflectionCol += (1.-normalDotFactor) * vec3(.5,.5,1.) * .2;\n            }\n            else if (reflectionRay.y < 1. || reflectionRay.x < 0.) {\n                //reflected onto nothing (show skybox)\n                float normalDotFactor = clamp(dot(normal, vec3(0.,1.,0.1)), .2,1.);\n                \n                reflectionCol += normalDotFactor * texture(iChannel2, normal).xyz;\n            }\n            \n            col += .5 * reflectionCol;\n        }\n        \n        if (material == 1.) {\n            //ground shading\n            col += CalcGroundShading(pos, normal);\n        }\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define pi 3.1415926535\n#define e 2.718281828\n\nfloat r21(vec2 p) {\n\treturn fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 4558.5453);\n}\n\nvec2 r22(vec2 p) {\n    float f = r21(p);\n    return (fract(vec2( f, floor(f)+fract(fract(f)*100.) ))-.5);\n}\n\nfloat powx = (e / (.1 * sqrt(2.*pi)));\n\n\nfloat NormalCurve(float Mean, float Dist) {\n    float sigmoid = .1;\n    float z = (3.3-Mean) * .005 * pow(powx, -1.*( pow(Dist-Mean,2.) / (2. * sigmoid * sigmoid)  ) );\n    \n    return z;\n}\n\nvec3 Ripple(float Mean, float Dist, vec2 vec) {\n    return vec3(normalize(vec), NormalCurve(Mean*3., Dist) - NormalCurve(Mean*3.1, Dist+.1) + NormalCurve(Mean*3.,Dist+.5)*.25 - NormalCurve(Mean*3., Dist+.7)*.25);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float resFactor  = iResolution.y/iResolution.x;\n    float dropCount = 90.;\n    vec2 uv = fragCoord/iResolution.xy-.5;\n    vec3 col;\n    \n    for (float i=1.; i<=dropCount; i+=1.) {\n        float t = (iTime + i/dropCount)*2.;\n        vec2 p = r22(vec2(i, floor(t)));\n        //col += smoothstep(.01,.005,distance(uv,p));\n        \n        col += Ripple(fract(t), length( (uv-p)*vec2(1./resFactor,1.))*30., uv-p);\n    }\n    \n    //col  += FuckMyShitUp(fract(iTime/10.), distance(uv,vec2(0.))*5., (uv-vec2(0.)));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}