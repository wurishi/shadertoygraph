{"ver":"0.1","info":{"id":"mdjXRy","date":"1670495688","viewed":149,"name":"Manipulate Puppets","username":"Chango","description":"Manipulate puppets","likes":6,"published":1,"flags":0,"usePreview":1,"tags":["manipulatepuppetsraymarchshadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Work Here!\n#define OBJNUM 12\n\n#define MaxTraceDis 10.\n#define MaxTraceTime 320.\n#define TraceThre 0.001f\n#define NormalEpsilon 0.01f\n\n//Custom\nTraceInfo tt;\nfloat glowAcc;\nvec3 eyePos;\n\nfloat hash_f2(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(37., 39.))) * 43758.54);\n}\n\n//Work Here!\nfloat GetObjSDF(int inx, vec3 p, in TraceInfo traceInfo)\n{\n    const float walkLen = 1.0;\n    const float r_string=0.002;\n    vec3 center = GetGridCenter_DownMode(p,vec3(3,50,3),vec3(0,0,0));\n    vec3 q = p-center;\n    float phase = hash_f2(center.xz);\n    float cx = walkLen*sin(0.2*iTime+phase);\n    vec3 c = vec3(cx,0.9,0.);\n    const float r_head = 0.1;\n    const vec3 bound_body = vec3(0.08,0.2,0.2);\n    const vec3 bound_arm = vec3(0.04,0.15,0.04);\n    \n            vec3 arm1_start = c+vec3(0,-r_head-bound_body.y+0.17,bound_body.z+0.01);\n             vec3 arm1_end = arm1_start+vec3(0.,-2.*bound_arm.y,2.*bound_arm.z);\n             vec3 q_arm1 = arm1_end - arm1_start;\n             q_arm1 = RotByEuler(q_arm1, vec3(0.,0.,30.*sin(3.*iTime+phase+center.z*0.1)));\n             arm1_end = arm1_start + q_arm1;\n             \n             vec3 arm2_start = c+vec3(0,-r_head-bound_body.y+0.17,-bound_body.z-0.01);\n             vec3 arm2_end = arm2_start+vec3(0.,-2.*bound_arm.y,-2.*bound_arm.z);\n             vec3 q_arm2 = arm2_end - arm2_start;\n             q_arm2 = RotByEuler(q_arm2, vec3(0.,0.,30.*sin(3.*iTime+phase+center.z*0.1+3.3)));\n             arm2_end = arm2_start + q_arm2;\n             \n     const vec3 bound_leg = vec3(0.05,0.18,0.03);\n             \n             vec3 leg1_start = c+vec3(0,-r_head-2.0*bound_body.y,bound_leg.z);\n             vec3 leg1_end = leg1_start+vec3(0.,-2.*bound_leg.y,0.);\n             vec3 q_leg1 = leg1_end - leg1_start;\n             q_leg1 = RotByEuler(q_leg1, vec3(0.,0.,10.*sin(6.3*iTime+phase+center.z*0.1+2.0)));\n             leg1_end = leg1_start + q_leg1;\n             \n             vec3 leg2_start = c+vec3(0,-r_head-2.0*bound_body.y,-bound_leg.z);\n             vec3 leg2_end = leg2_start+vec3(0.,-2.*bound_leg.y,0.);\n             vec3 q_leg2 = leg2_end - leg2_start;\n             q_leg2 = RotByEuler(q_leg2, vec3(0.,0.,10.*sin(6.3*iTime+phase+center.z*0.1+6.0)));\n             leg2_end = leg2_start + q_leg2;\n             \n             \n\tswitch(inx)\n    {\n        case 0: return SDFBox(p,vec3(eyePos.x,-0.48,eyePos.z),vec3(3000.,0.5,3000.));break;\n        case 1: \n            if(p.y>-5.&&p.y<5.)\n            {\n             return SDFSphere(q,c,r_head);\n             }break;\n        case 2:\n            if(p.y>-5.&&p.y<5.)\n            {\n            return SDFCapsule(q,vec3(0.,4.,0.),c+vec3(0.,r_head,0.),0.01);\n            }break;\n        case 3:\n            if(p.y>-5.&&p.y<5.)\n            {\n             return SDFBox(q,c+vec3(0,-r_head-bound_body.y,0),bound_body);\n            }break;\n        case 4:\n            if(p.y>-5.&&p.y<5.)\n            {          \n             return SDFCapsule(q,arm1_start,arm1_end,bound_arm.x);\n            }break;\n        case 5:\n            if(p.y>-5.&&p.y<5.)\n            {\n            return SDFCapsule(q,vec3(0.,4.,0.),arm1_end,r_string);\n            }break;\n        case 6:\n            if(p.y>-5.&&p.y<5.)\n            {          \n             return SDFCapsule(q,arm2_start,arm2_end,bound_arm.x);\n            }break;\n        case 7:\n            if(p.y>-5.&&p.y<5.)\n            {\n            return SDFCapsule(q,vec3(0.,4.,0.),arm2_end,r_string);\n            }break;\n        case 8:\n            if(p.y>-5.&&p.y<5.)\n            {          \n             return SDFCapsule(q,leg1_start,leg1_end,bound_leg.x);\n            }break;\n        case 9:\n            if(p.y>-5.&&p.y<5.)\n            {\n            return SDFCapsule(q,vec3(0.,4.,0.),leg1_end,r_string);\n            }\n        case 10:\n            if(p.y>-5.&&p.y<5.)\n            {          \n             return SDFCapsule(q,leg2_start,leg2_end,bound_leg.x);\n            }break;\n        case 11:\n            if(p.y>-5.&&p.y<5.)\n            {\n            return SDFCapsule(q,vec3(0.,4.,0.),leg2_end,r_string);\n            }break;\n        \n    }\n    return MAXFLOAT;\n}\n\nvec3 GetObjSDFNormal(int inx, vec3 p, in TraceInfo traceInfo);\n//Can optimize Here!\nvec3 GetObjNormal(int inx, vec3 p, in TraceInfo traceInfo)\n{\n\treturn GetObjSDFNormal(inx, p, traceInfo);\n}\n\n//Work Here!\nMaterial_PBR GetObjMaterial_PBR(int obj)\n{\n\tMaterial_PBR re;\n\tInit(re);\n\n\t//Work Here!\n    if(obj == 2 || obj==5 ||obj == 7||obj==9 || obj==11)\n    {\n        re.metallic = 0.8;\n        re.roughness = 0.2;\n    }\n\treturn re;\n}\n\n//Work Here!\nint GetObjRenderMode(int obj)\n{\n\t//if(obj == 0)\n    {\n        return 0;\n    }\n}\n\n//Can Work Here!\nvoid ObjPreRender(inout int mode, inout Material_PBR mat, inout Ray ray, inout HitInfo minHit)\n{\n    int inx = minHit.obj;\n    \n    if(inx == 0)\n    {\n        vec2 pos = minHit.P.xz;\n        ivec2 grid = ivec2(floor(pos));\n        if(abs(grid.x%2) == abs(grid.y%2))\n        {\n            mat.albedo *= 0.5;\n        }\n    }\n    \n}\n\n\n//Can Work Here!\nvoid ObjPostRender(inout vec3 result, inout int mode, inout Material_PBR mat, inout Ray ray, inout HitInfo minHit)\n{\n    float k = length(minHit.P - vec3(0,1,0));\n    k/=90.;\n    k = 1.-k;\n    result *=vec3(k);\n    if(minHit.obj==1)\n    {\n    k = abs(minHit.P.y-1.);\n    k/=3.;\n    k = 1.-k;\n    result *=vec3(k);\n    }\n    result = 1.0 - exp(-result);\n    result = pow(result,vec3(0.4545));\n}\n//------------------------------------------------\n\nvec3 GetObjSDFNormal(int inx, vec3 p, in TraceInfo traceInfo)\n{\n //float eplisonScale = 1.;\n\t//float normalEpsilon = NormalEpsilon;\n    //return normalize(vec3(1.));\n    /*\n\treturn normalize(vec3(\n\t\tGetObjSDF(inx, vec3(p.x + NormalEpsilon*eplisonScale, p.y, p.z), traceInfo) - GetObjSDF(inx, vec3(p.x - NormalEpsilon*eplisonScale, p.y, p.z), traceInfo),\n\t\tGetObjSDF(inx, vec3(p.x, p.y + NormalEpsilon*eplisonScale, p.z), traceInfo) - GetObjSDF(inx, vec3(p.x, p.y - NormalEpsilon*eplisonScale, p.z), traceInfo),\n\t\tGetObjSDF(inx, vec3(p.x, p.y, p.z + NormalEpsilon*eplisonScale), traceInfo) - GetObjSDF(inx, vec3(p.x, p.y, p.z - NormalEpsilon*eplisonScale), traceInfo)\n\t\t));*/\n\n    float h = NormalEpsilon; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*GetObjSDF(inx, p + k.xyy*h, traceInfo) + \n                      k.yyx*GetObjSDF(inx, p + k.yyx*h , traceInfo) + \n                      k.yxy*GetObjSDF( inx,p + k.yxy*h , traceInfo) + \n                      k.xxx*GetObjSDF(inx, p + k.xxx*h, traceInfo ) );\n}\n\n//Can Change Here\nvoid TraceScene(Ray ray, out HitInfo info)\n{\n\tfloat traceThre = TraceThre;\n    float minSDF = MAXFLOAT;\n\tInit(info);\n\n\tTraceInfo traceInfo;\n\tInit(traceInfo);\n\tvec3 oriPos = ray.pos;\n\n\tfloat objSDF[OBJNUM];\n\tint objInx = -1;\n\tfloat sdf = MAXFLOAT;\n\n\twhile (float(traceInfo.traceCount) <= MaxTraceTime)\n\t{\n\t\tobjInx = -1;\n\t\tsdf = MAXFLOAT;\n\n\t\tfor (int inx = 0; inx < OBJNUM; inx++)\n\t\t{\n\t\t\tobjSDF[inx] = GetObjSDF(inx, ray.pos, traceInfo);\n\t\t\tif (objSDF[inx] < sdf)\n\t\t\t{\n\t\t\t\tsdf = objSDF[inx];\n\t\t\t\tobjInx = inx;\n\t\t\t}\n\t\t}\n\n\n\t\tif(objInx == -1)\n\t\t{\n\t\t\tbreak;\n\t\t}\n        \n        if(sdf<minSDF)\n        {\n            minSDF = sdf;\n        }\n\n\t\tif (sdf > MaxTraceDis)\n\t\t{\n            glowAcc = minSDF;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sdf <= traceThre)\n\t\t{\n\t\t\tinfo.bHit = 1;\n\t\t\tinfo.obj = objInx;\n\t\t\tinfo.N = GetObjNormal(objInx, ray.pos, traceInfo);\n\t\t\tinfo.P = ray.pos;\n\t\t\tbreak;\n\t\t}\n\t\tray.pos += sdf * ray.dir;\n\t\tUpdate(traceInfo,sdf);\n\t\ttraceInfo.traceSum = length(ray.pos - oriPos);\n\t}\n}\n\nfloat GetPntlightAttenuation(vec3 pos, vec3 lightPos)\n{\n\tfloat d = length(pos - lightPos);\n\treturn saturate(1. / (d*d));\n\t//return 1 / (1 + 0.01*d + 0.005*d*d);\n}\n\nvec3 RenderSceneObj(Ray ray, inout HitInfo minHit, inout Material_PBR mat)\n{\n\tint mode = GetObjRenderMode(minHit.obj);\n\tObjPreRender(mode, mat, ray, minHit);\n\tvec3 result = vec3(0.);\n\t//###BLOCK ObjRender\n\t//Can Work Here!\n\tif(mode==0)\n\t{\n\t\tvec3 lightDirs[2];\n\t\tvec3 lightColors[2];\n        vec3 lightPos[2];\n        lightPos[0] = vec3(0.,1.,1.);\n        \n\t\tlightDirs[0] = normalize(minHit.P - lightPos[0]);\n\t\tlightColors[0] = 0.*vec3(0., 0., 1.) * GetPntlightAttenuation(minHit.P, lightPos[0]);\n\t\tlightDirs[1] = vec3(0.4255954, -0.7770073, -0.4638191);\n\t\tlightColors[1] = 1.*vec3(1, 1, 1);\n\t\tresult.rgb = 0.0 * mat.albedo * mat.ao;\n\t\tfor(int i=0;i<2;i++)\n\t\t{\n\t\t\tresult.rgb += PBR_GGX(mat, minHit.N, -ray.dir, -lightDirs[i], lightColors[i]);\n\t\t}\n\t}\n\t//###BLOCK\n\tObjPostRender(result, mode, mat, ray, minHit);\n\treturn result;\n}\n\nvec3 GetSDFGameColor(in Ray ray, out HitInfo minHit, out Material_PBR mat)\n{\n\tInit(mat);\n\tvec3 re = vec3(0.);\n\t//---Trace\n\tInit(minHit);\n\tTraceScene(ray, minHit);\n\t//___Trace\n\nif (minHit.bHit == 1)\n{ \n\tmat = GetObjMaterial_PBR(minHit.obj);\n\t//if(mat.reflective<0.001)\n\t//{\n\tre = RenderSceneObj(ray, minHit, mat);\n\t//}\n\t//else if (mat.reflective<0.999)\n\t//{\n\t//\tre = lerp(RenderSceneObj(ray, minHit, mat),SceneRenderReflect(ray, minHit,mat),mat.reflective);\n\t//}\n\t//else\n\t//{\n\t//re = SceneRenderReflect(ray, minHit,mat);\n\t//}\n\t//re *= RenderSceneSDFShadow(minHit);\n}\nelse\n{\n\t//re = (@BackGroundColor);\n\t//re = GetEnvIrradiance_equirectangular(envBgTex, ray.dir, true);\n\t//re = stars(ray.pos, ray.dir);\n\tre = vec3(0.);\n}\n\n\treturn re;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n//Custom\nfloat HardShadow_TraceScene(Ray ray, out HitInfo info, float maxLength, bool expensive)\n{\n\tInit(info);\n\n\tTraceInfo traceInfo;\n\tInit(traceInfo);\n\tvec3 oriPos = ray.pos;\n\n\tfloat objSDF[OBJNUM];\n\tint objInx = -1;\n\tfloat sdf = MAXFLOAT;\n\n\twhile (float(traceInfo.traceCount) <= MaxTraceTime*(expensive?1.:0.15))\n\t{\n\t\tobjInx = -1;\n\t\tsdf = MAXFLOAT;\n\t\t{\n\t\t\tfor (int inx = 0; inx < OBJNUM; inx++)\n\t\t\t{\n\t\t\t\tobjSDF[inx] = GetObjSDF(inx, ray.pos, traceInfo);\n\t\t\t\tif (objSDF[inx] < sdf)\n\t\t\t\t{\n\t\t\t\t\tsdf = objSDF[inx];\n\t\t\t\t\tobjInx = inx;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(objInx == -1)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sdf > MaxTraceDis*(expensive?1.:0.1))\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sdf <= TraceThre)\n\t\t{\n\t\t\tinfo.bHit = 1;\n\t\t\tinfo.obj = objInx;\n\t\t\tinfo.P = ray.pos;\n\t\t\tbreak;\n\t\t}\n\t\tray.pos += sdf * ray.dir;\n\t\tUpdate(traceInfo,sdf);\n\t\ttraceInfo.traceSum = length(ray.pos - oriPos);\n\n\t\tif(traceInfo.traceSum>maxLength)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (info.bHit == 1)\n\t{\n\t\treturn 0.;\n\t}\n\telse\n\t{\n\t\treturn 1.;\n\t}\n}\n\nfloat GetDirHardShadow(vec3 lightDir, in HitInfo minHit, float maxLength, out HitInfo shadowHit)\n{\n\tRay ray;\n\tray.pos = minHit.P;\n\tray.dir = -lightDir;\n\tray.pos += ray.dir*vec3(TraceThre*2.) + minHit.N*vec3(TraceThre*2.);\n\treturn HardShadow_TraceScene(ray, shadowHit, maxLength, false);\n}\n\nfloat DoShadow(in HitInfo minHit)\n{\n    int inx = minHit.obj;\n    vec3 lightDir = normalize(vec3(0.4255954, -0.7770073, -0.4638191));\n    //sha\n\tfloat maxShadowTraceLength = MAXFLOAT;\n\tfloat sha = 1.;\n\t\tHitInfo shadowHit;\n\t\t{\n\t\t sha = GetDirHardShadow(lightDir, minHit, maxShadowTraceLength, shadowHit);\n\t\t}\n    sha = max(sha,0.0);\n\treturn sha;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Custom\n    glowAcc = -1.;\n    \n    HitInfo minHit;\n    Material_PBR mat;\n    \n    Ray ray;\n    vec2 rotCenter = vec2(0.);\n    eyePos = vec3(0.0, 1.+abs(2.0*sin(0.05*iTime)), 5.);\n    ray.pos = eyePos;\n    ray.dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 re = GetSDFGameColor(ray,minHit,mat);\n    re *= vec3(DoShadow(minHit));\n    \n    if(glowAcc>0.)\n    {\n        //https://www.shadertoy.com/view/msfXW2\n        //float fakeGlow = saturate(1. - glowAcc);\n        //fakeGlow = pow(fakeGlow,1.);\n        //re += 0.1*pow(0.21/glowAcc,1.)*vec3(1.0,1.,0.4);\n    }\n\n    //dither to smooth: https://www.shadertoy.com/view/NldfRl\n    re += texelFetch(iChannel0, ivec2(fragCoord) & 1023, 0).rgb * vec3(1.0 / 256.0);\n    // Output to screen\n    fragColor = vec4(re,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAXFLOAT 3.402823e38f\n#define PI 3.1415926\n\nvec2 rotate(vec2 p, float a)\n{\n\tfloat c = cos(a), s = sin(a);\n\tmat2 m = mat2(c,-s,s,c);\n\treturn m*p;\n}\n\nfloat saturate(float x)\n{\n    return clamp(x,0.,1.);\n}\n    \nstruct Ray\n{\n\tvec3 pos;\n\tvec3 dir;\n};\n\nstruct HitInfo\n{\n\tint bHit;\n\tint obj;\n\tvec3 N;\n\tvec3 P;\n};\n\nstruct TraceInfo\n{\n\tint traceCount;\n\tfloat traceSum;\n\tfloat lastTrace;\n};\n\nvoid Init(out HitInfo re)\n{\n\tre.bHit = 0;\n\tre.obj = -1;\n\tre.N = vec3(0.);\n\tre.P = vec3(0.);\n}\n\nvoid Init(out TraceInfo re)\n{\n\tre.traceCount = 0;\n\tre.traceSum = 0.;\n\tre.lastTrace = MAXFLOAT;\n}\n\nvoid Update(inout TraceInfo traceInfo, float sdf)\n{\n\ttraceInfo.traceCount += 1;\n\ttraceInfo.lastTrace = sdf;\n}\n\nfloat SDFSphere(vec3 p, vec3 center, float radius)\n{\n\treturn length(p - center) - radius;\n}\n\nfloat SDFBox(vec2 p, vec2 center, vec2 bound)\n{\n\tvec2 q = abs(p - center) - bound;\n\treturn length(max(q, 0.0)) + min(max(q.x, q.y), 0.0);\n}\n\nfloat SDFBox(vec3 p, vec3 center, vec3 bound)\n{\n\tvec3 q = abs(p - center) - bound;\n\treturn length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat SDFCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nvec3 InvRotByEuler(vec3 p, vec3 eulerAngle)\n{\n\tfloat a = eulerAngle.x / 180.0f * PI;\n\tfloat b = eulerAngle.y / 180.0f * PI;\n\tfloat c = eulerAngle.z / 180.0f * PI;\n\tmat3 rotx = mat3(\n\t\t1,0,0,\n\t\t0,cos(a),sin(a),\n\t\t0,-sin(a),cos(a)\n    );\n\n\tmat3 roty = mat3(\n\t\tcos(b),0,-sin(b),\n\t\t0,1,0,\n\t\tsin(b),0,cos(b)\n    );\n\n\tmat3 rotz =mat3(\n\t\tcos(c),sin(c),0,\n\t\t-sin(c),cos(c),0,\n\t\t0,0,1\n    );\n\n\tp = roty*p;\n\tp = rotx*p;\n\tp = rotz*p;\n\treturn p;\n}\n\nvec3 RotByEuler(vec3 p, vec3 eulerAngle)\n{\n\tfloat a = eulerAngle.x / 180.0f * PI;\n\tfloat b = eulerAngle.y / 180.0f * PI;\n\tfloat c = eulerAngle.z / 180.0f * PI;\n\tmat3 rotx = mat3(\n\t\t1,0,0,\n\t\t0,cos(a),sin(a),\n\t\t0,-sin(a),cos(a)\n    );\n\n\tmat3 roty = mat3(\n\t\tcos(b),0,-sin(b),\n\t\t0,1,0,\n\t\tsin(b),0,cos(b)\n    );\n\n\tmat3 rotz = mat3(\n\t\tcos(c),sin(c),0,\n\t\t-sin(c),cos(c),0,\n\t\t0,0,1\n    );\n\n\tp = rotz*p;\n\tp = rotx*p;\n\tp = roty*p;\n\treturn p;\n}\n\nfloat SDFBox(vec3 p, vec3 center, vec3 bound, vec3 rotEuler)\n{\n\tp = p - center;\n\tp = InvRotByEuler(p, rotEuler);\n\tvec3 q = abs(p) - bound;\n\treturn length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nstruct Material_PBR\n{\n\tvec3 albedo;\n\tfloat metallic;\n\tfloat roughness;\n\tfloat ao;\n\tfloat reflective;\n\tvec2 reflect_ST;\n\tfloat alpha;\n};\n\nvoid Init(out Material_PBR mat)\n{\n\tmat.albedo = vec3(1.);\n\tmat.metallic = 0.;\n\tmat.roughness = 1.;\n\tmat.ao = 1.;\n\tmat.reflective = 0.;\n\tmat.reflect_ST = vec2(1.,0.);\n\tmat.alpha = 1.;\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n\treturn F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n\tfloat r = (roughness + 1.0);\n\tfloat k = (r*r) / 8.0;\n\n\tfloat nom = NdotV;\n\tfloat denom = NdotV * (1.0 - k) + k;\n\n\treturn nom / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n\tfloat NdotV = max(dot(N, V), 0.0);\n\tfloat NdotL = max(dot(N, L), 0.0);\n\tfloat ggx2 = GeometrySchlickGGX(NdotV, roughness);\n\tfloat ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n\treturn ggx1 * ggx2;\n}\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n\tfloat a = roughness * roughness;\n\tfloat a2 = a * a;\n\tfloat NdotH = max(dot(N, H), 0.0);\n\tfloat NdotH2 = NdotH * NdotH;\n\n\tfloat nom = a2;\n\tfloat denom = (NdotH2 * (a2 - 1.0) + 1.0);\n\tdenom = PI * denom * denom;\n\n\treturn nom / denom;\n}\n\nvec3 PBR_GGX(Material_PBR param, vec3 n, vec3 v, vec3 l, vec3 Li)\n{\n\tvec3 h = normalize(l + v);\n\n\t//Calculate F\n\tvec3 F0 = vec3(0.04);\n\tF0 = mix(F0, param.albedo, param.metallic);\n\tvec3 F = fresnelSchlick(max(dot(h, v), 0.0), F0);\n\n\t//Calculate diffuse\n\tvec3 kD = 1.0 - F;\n\tvec3 diffuse = (1.0 - param.metallic) * kD * param.albedo / PI;\n\n\t//Calculate specular\n\tfloat G = GeometrySmith(n, v, l, param.roughness);\n\tvec3 nominator;\n\tfloat NDF = DistributionGGX(n, h, param.roughness);\n\tnominator = NDF * G * F;\n\tfloat denominator = 4.0 * max(dot(n, v), 0.0) * max(dot(n, l), 0.0) + 0.001;\n\tvec3 specular = nominator / denominator;\n\n    float diffuseRate = 1.0f;\n    float specularRate = 1.0f;\n\tvec3 Lo = diffuse * diffuseRate + specular * specularRate;\n\tLo *= Li * max(dot(n, l), 0.);\n\n\treturn Lo;\n}\n\nfloat iqhash(float n)\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat noise_computational(in vec3 x)\n{\n\t// The noise function returns a value in the range -1.0f -> 1.0f\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\n\tf = f * f*(3.0 - 2.0*f);\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\treturn mix(mix(mix(iqhash(n + 0.0), iqhash(n + 1.0), f.x),\n\t\tmix(iqhash(n + 57.0), iqhash(n + 58.0), f.x), f.y),\n\t\tmix(mix(iqhash(n + 113.0), iqhash(n + 114.0), f.x),\n\t\t\tmix(iqhash(n + 170.0), iqhash(n + 171.0), f.x), f.y), f.z);\n}\n\n\nfloat noise(in vec3 x)\n{\n\t//return noise_texBase(x);\n\treturn noise_computational(x);\n}\n\nfloat fbm4(in vec3 p)\n{\n\tfloat n = 0.0;\n\tn += 1.000*noise(p*1.0);\n\tn += 0.500*noise(p*2.0); \n\tn += 0.250*noise(p*4.0);\n\tn += 0.125*noise(p*8.0);\n\treturn n;\n}\n\nvec3 GetGridCenter_DownMode(vec3 p, vec3 grid, vec3 offset)\n{\n\tp -= offset;\n\tfloat dis = grid.y;\n\tfloat m = round(p.y / dis);\n\tfloat centerY = m * dis;\n\n\tvec2 grid2 = grid.xz;\n\tvec2 m1 = floor(p.xz / grid2);\n\tvec2 c = grid2 * (m1 + 0.5);\n\treturn vec3(c.x, centerY, c.y) + offset;\n}","name":"Common","description":"","type":"common"}]}