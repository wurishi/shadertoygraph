{"ver":"0.1","info":{"id":"MccfRH","date":"1732691606","viewed":17,"name":"Organic evolutive colored basics","username":"Psydala","description":"Hello, i'm Jean. newbie and I try to create something for begin ^^.\nI love the colors function from Inigo Quilez !!\nadapation of the original algo from tutorial from Kishimisu  https://www.youtube.com/watch?v=f4s1h2YETNY\nfeedbacks&tips welcomes tks","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","pattern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Jean vouillamoz 2024 - Psydala \n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265358979323846\n\n// Author of 3 nexts functions @patriciogv ( patriciogonzalezvivo.com ) - 2015  theBookOfShader\nvec2 rotate2D(vec2 _st,float _angle){\n    _st-=.5;\n    _st=mat2(cos(_angle),-sin(_angle),\n    sin(_angle),cos(_angle))*_st;\n    _st+=.5;\n    return _st;\n}\n\nvec2 tile(vec2 _st,float _zoom){\n    _st*=_zoom;\n    return fract(_st);\n}\n\nvec2 rotateTilePattern(vec2 _st){    \n    //  Scale the coordinate system by 2x2\n    _st*=2.;    \n    //  Give each cell an index number\n    //  according to its position\n    float index=0.;\n    index+=step(1.,mod(_st.x,2.));\n    index+=step(1.,mod(_st.y,2.))*2.;\n    \n    //      |\n    //  2   |   3\n    //      |\n    //--------------\n    //      |\n    //  0   |   1\n    //      |\n    \n    // Make each cell between 0.0 - 1.0\n    _st=fract(_st);\n    \n    // Rotate each cell according to the index\n    if(index==1.){\n        //  Rotate cell 1 by 90 degrees\n        _st=rotate2D(_st,PI*.5);\n    }else if(index==2.){\n        //  Rotate cell 2 by -90 degrees\n        _st=rotate2D(_st,PI*-.5);\n    }else if(index==3.){\n        //  Rotate cell 3 by 180 degrees\n        _st=rotate2D(_st,PI);\n    }\n    \n    return _st;\n}\n// Author of palette function Inigo Quilez\nvec3 palette(in float t,in vec3 a,in vec3 b,in vec3 c,in vec3 d)\n{\n    return a+b*cos(6.283185*(c*t+d));\n}\n// personal adaptation algo from tutorial Kishimisu online in youtube. https://www.youtube.com/watch?v=f4s1h2YETNY \nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 st=fragCoord/iResolution.xy;\n   // vec2 mouse=iMouse/iResolution;\n    st.x*=iResolution.x/iResolution.y;      \n    vec2 st2=st;\n    vec3 final=vec3(0.);\n    for(float i=0.;i<5.;i++){\n        st=fract(st*2.)-.5;\n        st*=1.5;       \n        float d=length(min(abs(st)-.3,0.))+abs(-length(min(st,2.))-1.5)*2.*.8*exp(-length(st));\n        vec3 col=palette(d,vec3(.5,.5,.5),vec3(.5,.5,.5),vec3(2.,1.,0.),vec3(.5,.20,.25)+i*2.-iTime*.04);\n        d*=sin(d*4.+iTime*.2)/4.;\n        d=abs(d);   \n        st2*=1.5;\n        st*=.4;\n        st=rotateTilePattern(st);\n        st2*=tile(st,iTime*.04);\n        float r=.4;\n        d*=smoothstep(r,r-.3,d);\n        final+=col*d;        \n    }    \n    fragColor=vec4(final,1.);\n}","name":"Image","description":"","type":"image"}]}