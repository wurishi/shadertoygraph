{"ver":"0.1","info":{"id":"dsXXD4","date":"1668884164","viewed":301,"name":"Dark Plasma Star","username":"ChunderFPV","description":"Mouse X: change value\nMouse Y: change exponent","likes":20,"published":1,"flags":32,"usePreview":0,"tags":["spiral","buffer","fraction","exponent"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// --- counter code from https://www.shadertoy.com/view/7tV3zK\nvec4 char(vec2 p, int c) {\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                        dFdx, dFdy );\n}\nvec4 pInt(vec2 p, float n, float d) { // --- display int4\n    vec4 v = vec4(0);\n    if (n < 0.) \n        v += char(p - vec2(-.5,0), 45 ),\n        n = -n;\n    for (float i = d; i>0.; i--) \n        n /=  9.999999, // 10., // for windows :-(\n        v += char(p - .5*vec2(i-1.0,0), 48+ int(fract(n)*10.) );\n    return v;\n}// ---\n\n// screen coords, value, size, num left digits, num right digits\nvec3 counter(vec2 sc, float v, float s, float l, float r)\n{\n    float numleft = min(log2(abs(v))/log2(10.0), l-1.0);\n    l = max(floor(numleft), 0.0)+1.0;\n    sc /= s; // size\n    sc += vec2((l+1.0)/2.0, 0.28); // center on decimal\n    vec3 d = vec3(0);\n    d += pInt(sc, v, l).x; // left of decimal\n    sc.x -= l/2.0;\n    d += char(sc, 46).x; // decimal point\n    sc.x -= 0.5;\n    d += pInt(sc, floor(abs(v)*pow(10.0, r)), r).x; // right of decimal\n    return d;\n}\n\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    vec3 c = texture(iChannel0, XY/R, max(1.0, length(SC*2.0))).rgb;\n    c *= c*3.5; // contrast\n    \n    if (M.z > 0.0)\n    {\n        vec2 m = (M.xy/R*4.0)-2.0;\n        vec3 n = counter((XY-vec2(0.1, 0.11)*R)/R.y, R2N(m.x), 0.1, 4.0, 4.0); // number\n        vec3 e = counter((XY-vec2(0.1, 0.01)*R)/R.y, R2N(-m.y), 0.1, 4.0, 4.0); // exponent\n        c += n*vec3(1,1,0)+e*vec3(0,1,0);\n    }\n    \n    RGBA = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define SCALE 2.5\n#define R iResolution.xy\n#define M iMouse\n#define T iTime\n#define SC ((XY-0.5*R)/R.y)\n#define CS(a) vec2(cos(a), cos(a-TAU/4.0))\n#define TAU 6.2831853071795865\n#define DS(n,a,pr) max(0.0, 1.0-length(sc-CS(a-n*TAU*rr)*l)/(pr))\n#define FS(n,a,pr) max(0.0, 1.0-length(sc-CS(a-(TAU*sqrt(abs(n))*sign(n))*sqrt(rr*2.0))*l)/(pr))\n#define R2N(m) (abs(m) > 1.0) ? 1.0/(2.0*sign(m)-m): m\n#define CL(x,a,b) smoothstep(0.0,1.0,(2.0/3.0)*(x-a)/(b-a)+(1.0/6.0))*(b-a)+a // https://www.shadertoy.com/view/Ws3Xzr\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 RGBA, in vec2 XY )\n{\n    float t = T/600.0; // time between ints\n    t += 0.19; // starting value\n    float e = 0.25;  // exponent\n    vec2 m = (M.xy/R*4.0)-2.0; // mouse\n    if (M.z > 0.0) t = R2N(m.x); // value from mouse x\n    if (M.z > 0.0) e = R2N(-m.y); // exponent from mouse y\n    float z = (e < 0.0) ? pow(100.0, e): pow(500.0, e); // zoom based on exponent\n    z *= SCALE;\n    z = clamp(z, CL(z, 1e-16, 1e-15), CL(z, 1e+18, 1e+19)); // clamp at precision lost\n    vec2 sc = SC*z;\n    \n    vec2 tc = SC*SCALE; // texture coords\n    float tl = length(tc); // non-zoomed screen radius\n    float ring = pow(min(tl, 1.0/tl), 2.0);\n    \n    float tr = sqrt(dot(tc, tc)); // transform\n    vec3 tex = texture(iChannel1, tc/tr+t, 0.5).rgb*tr;\n    \n    float bs = -0.005*sign(t); // radial blur strength\n    float maa = (e < 0.0) ? pow(z/tl/SCALE, 0.25): 0.5; // mipmap aa\n    vec3 c = texture(iChannel0, mix(XY/R, vec2(0.5), bs), 0.5).rgb*0.96; // blend with previous frames\n    c += vec3(0.1, 0.4, 0.7)*tex*0.012; // background color\n    if (e < 0.0) c += pow(z/tl*min(0.5, abs(e)*25.0), 1.25)*vec3(0.1, 0.2, 0.3)*0.005; // blue dot\n    c += vec3(0.1, 0.2, 0.3)*ring*0.03; // blue ring\n    \n    vec3 dc = vec3(0.8, 0.4, 1.0)*ring*0.5; // denominator color\n    vec3 nc = vec3(0.8, 0.1, 0.2)*ring*0.5; // numerator color\n    vec3 fc = vec3(1.0, 0.6, 0.3*tl)*pow(tl, clamp(-1.0/e, 0.0, 0.25))*0.4;  // fraction color\n    \n    float r = length(sc); // screen radius\n    float sr = (TAU/4.0); // starting rotation\n    float px = length(fwidth(sc))/1.414; // pixel radius\n    float pr = max(px*3.0, 0.005*z); // point radius\n    float cr = pow(z/SCALE, 1.0/e)*TAU; // counter rotation\n    float fscr = sqrt(abs(t)*cr*2.0*TAU)*sign(t); // counter rotation\n    float rb = sin(T*TAU/10.0)*0.1; // rotation bounce\n    \n    float lim = 4.0; // loop limit\n    for (float i=0.0; i<lim; i++) // overlap cells for spirals\n    {\n        float rr = round((exp(log(r)/e)-i)/lim)*lim+i; // rounded radius\n        float l = pow(rr, e); // radius\n        c += DS(1.0/t, (1.0/t)*cr+sr+rb*0.25, pr*0.5)*nc; // numerator spiral\n        c += DS(t, t*cr-sr+rb*0.5, pr*0.5)*dc; // denominator spiral\n        c += FS(t, fscr+rb*0.75, pr)*fc; // fraction spiral\n    }\n    vec2 b = abs(fract(XY/R+0.5)-0.5)/fwidth(XY/R)/5.0; // black border\n    c = min(c, min(b.x, b.y)*0.75); // blend with border\n    \n    RGBA = vec4(c, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}