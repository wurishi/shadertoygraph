{"ver":"0.1","info":{"id":"MlKfzw","date":"1542139044","viewed":399,"name":"Sphere-Capped Cone Intersection","username":"fizzer","description":"Here's my attempt at a sphere-capped cone intersection. It is derived from IQ's flat-capped cone intersection: https://www.shadertoy.com/view/llcfRf","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","sphere","cone"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Assumes rd has unit length\nfloat intersectSphere(vec3 ro, vec3 rd, vec3 org, float rad)\n{\n    float b = 2. * dot(rd, ro - org);\n    float c = dot(ro - org, ro - org) - rad * rad;\n    float desc = b * b - 4. * c;\n    if (desc < 0.)\n        -1.0;\n    return (-b - sqrt(desc))/2.;\n}\n\n// This function is derived from IQ's capped cone intersection: https://www.shadertoy.com/view/llcfRf\nvec4 iRoundCappedCone( in vec3  ro, in vec3  rd, \n                      in vec3  pa, in vec3  pb, \n                      in float ra, in float rb )\n{\n    // Distance between the two endcap spheres along the cone's axis\n    float ab = distance(pa, pb);\n\n    // Distance of the apex of the cone along the cone's axis, from sphere A\n    float o = ra * ab / (rb - ra);\n\n    // The direction of the cone\n    vec3 dir = (pb - pa) / ab;\n\n    // Cone's apex point\n    vec3 apex = pa - dir * o;\n\n\tfloat oab = o + ab;\n\n    float cosConeAngle = sqrt(o * o - ra * ra) / o;\n    float sinConeAngle = sqrt(1.0 - cosConeAngle * cosConeAngle);\n    \n    // Compute new points for the endcap spheres, using Pythagoras and the law of similar triangles\n    vec3 pa2 = apex + dir * (oab - rb * rb / oab);\n    vec3 pb2 = apex + dir * (o - ra * ra / o);\n\n    // Compute new radii for the endcap spheres, again using Pythagoras\n    float ra2 = rb * cosConeAngle;\n    float rb2 = ra * cosConeAngle;\n\n    // Proceed as before to intersect the cone's middle section\n    vec3  ba = pb2 - pa2;\n    vec3  oa = ro - pa2;\n    vec3  ob = ro - pb2;\n\n    float baba = dot(ba,ba);\n    float rdba = dot(rd,ba);\n    float oaba = dot(oa,ba);\n\n    // body\n    float rbra = rb2 - ra2;\n    float hyhy = baba + rbra*rbra;\n    vec3  oc = oa*rb2 - ob*ra2; // also oc = oa*rbra + ba*ra2;\n\n    float ocba = dot(oc,ba);\n    float ocrd = dot(oc,rd);\n    float ococ = dot(oc,oc);\n\n    float k2 = baba*baba      - hyhy*rdba*rdba; // the gap is rdrd which is 1.0\n    float k1 = baba*baba*ocrd - hyhy*rdba*ocba;\n    float k0 = baba*baba*ococ - hyhy*ocba*ocba;\n\n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return vec4(-1.0);\n\n    float t = (-k1-sign(rbra)*sqrt(h))/(k2*rbra);\n\n    float y = oaba + t*rdba;\n    if( y>0.0 && y<baba ) \n    {\n        return vec4(t, normalize(baba*(baba*(oa+t*rd)-rbra*ba*ra2)-ba*hyhy*y));\n    }\n\n    // Order the spheres along ray direction to simplify the intersection logic\n    if(dot(rd, ba) > 0.)\n    {\n        vec3 tmp = pa;\n        pa = pb;\n        pb = tmp;\n        float tmp2 = ra;\n        ra = rb;\n        rb = tmp2;\n    }\n\n    // Unfortunately, unlike the flat-capped cone or the round-capped cylinder,\n    // There are cases where both endcaps must be tested against the ray.\n    \n    // Test against sphere A\n    float sia = intersectSphere(ro, rd, pa, ra);\n\n    if(sia > 0.0)\n        return vec4(sia, normalize(ro + rd * sia - pa));\n\n    // Test against sphere B\n    float sib = intersectSphere(ro, rd, pb, rb);\n\n    if(sib > 0.0)\n        return vec4(sib, normalize(ro + rd * sib - pb));\n\n    return vec4(-1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.rgb = vec3(0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Set up primary ray\n    vec3 ro = vec3(0.5, 5.2, 17.);\n    vec3 rd = normalize(vec3(uv.xy, -2.));\n\n    float time = iTime;\n    \n    // Rounded cone endpoints\n    vec3 pa = vec3(cos(time) * 4., 6. + cos(time / 2.), sin(time) * 4.);\n    vec3 pb = vec3(-cos(time) * 4., 6. + cos(time / 2. + 2.), -sin(time) * 4.);\n\n    // Rounded cone endcap radii\n    float r = 1.2 + cos(time / 4.) * .9;\n    float q = 0.5 + cos(time / 4.) * .3;\n\n    float mint = 1e4;\n\n    vec3 surfnorm = vec3(0);\n\n    // Raytrace the floor\n    if(rd.y<0.)\n    {\n        mint = -ro.y / rd.y;\n        surfnorm = vec3(0, 1, 0);\n    }\n\n    // Raytraced the rounded cone\n    vec4 tnor = iRoundCappedCone( ro, rd, pa, pb, r, q );\n\n    float t = tnor.x;\n\n    if(t > 0.)\n    {\n        mint = t;\n        surfnorm = tnor.yzw;\n    }\n\n    // Shading\n    vec3 ld = normalize(vec3(1, 1, 1));\n    float fr = pow(max(0., 1. - dot(-rd, surfnorm)), 2.);\n    fragColor.rgb = vec3(max(0., dot(surfnorm, ld)));\n    fragColor.rgb += texture(iChannel0, reflect(rd, surfnorm)).rgb * fr;\n\tfragColor.rgb = mix(vec3(.2), fragColor.rgb, exp(-mint /100.));\n    \n    // Shadow\n    if (ro.y + rd.y * mint < 1e-3 && iRoundCappedCone( ro + rd * mint + surfnorm * 1e-4, ld, pa, pb, r, q ).x > 0.)\n    \tfragColor.rgb *= .2;\n    \n    // Gamma etc.\n    fragColor.rgb = pow(clamp(fragColor.rgb, 0., 1.), vec3(1. / 2.2));\n}\n","name":"Image","description":"","type":"image"}]}