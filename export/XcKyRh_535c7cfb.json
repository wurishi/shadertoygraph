{"ver":"0.1","info":{"id":"XcKyRh","date":"1731473222","viewed":66,"name":"Chiropractor Tunnel","username":"akr51","description":"let me know if you know a way to improve the reflections","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\nLearning: \nThe Art of Code on YouTube\nNuSan FX on YouTube\nevvvvil_ on Twitch\nflopine on Twitch\n\n*/\n\n#define NSO 5\n#define ITR 120\n#define DST 90.0\n#define SRF 0.0001\n#define PI acos(-1.0)\n#define EPS vec2(0.0035, -0.0035)\n#define RT(X) mat2(cos(X), -sin(X), sin(X), cos(X))\n\n\nfloat j = 0.0;\nfloat t = 0.0;\nfloat g = 0.0;\nfloat g1 = 0.0;\n\nfloat box(vec3 sp, vec3 d)\n{\n    \n    sp = abs(sp) - d;\n    return max(max(sp.y, sp.x), sp.z);\n\n}\n\n\nvec2 map(vec3 sp)\n{\n    float dst[NSO];\n    float id = 0.0;\n    \n    sp.z = mod(sp.z + t * 10.0, 40.0) - 20.0;\n    sp.xy *= RT(sp.z * 0.1 + t);\n    for (int i = 0; i < 2; i++)\n    {\n    \n        sp = abs(sp) - vec3(10, 5, 2);\n        sp.zy *= RT(8.64);\n        sp.zx *= RT(PI * 0.125);\n        \n    \n    }\n    \n    vec3 spc = sp;\n    vec3 spw = sp;\n    vec3 spk = sp;\n    spc.zy *= RT(sp.x * 0.25);\n    dst[0] = box(abs(sp) - vec3(0.0, 2, 0), vec3(5.0, 0.25, 0.5));\n    dst[1] = box(spc, vec3(7.0, 0.25, 0.25));\n   \n    spw.x = spw.x - 1.0 * clamp(round(spw.x / 1.0), -7.0, 7.0);\n    \n    spw.zy *= RT(sp.x * 0.25);\n    spw.zy *= RT(t);\n    float sc = clamp(abs(spw.y),0.25, 8.0);\n    spw *= sc;\n    \n    dst[2] = box(spw, vec3(0.1, 1.0, 0.1)) / sc;\n    \n    spk.x += sin(sp.x * 11.0 + t) * 0.1;\n    \n    for (int i = 0; i < 2; i++)\n    {\n\n        spk = abs(spk) - vec3(0, 2.0 + sin(t) * 2.0 + 2.0, 0);\n        spk.zy *= RT(t);\n    \n    }\n    \n    dst[3] = length(abs(spk) - vec3(10, 0, 0)) - 0.25;\n    g += pow(0.1 / max(dst[3], 0.001), 3.0);\n    \n    dst[4] = box(sp, vec3(0.25, 1.25, 7.0));\n    g1 += pow(0.1 / max(dst[4], 0.001), 4.0 - clamp(sin(j + t), 0.0, 1.0) * 2.5);\n   \n    for (int i = 1; i < NSO; i++)\n    {\n    \n        if (dst[i] < dst[0])\n        {\n            \n            dst[0] = dst[i];\n            id = float(i);\n        \n        }\n    \n    }\n    \n    return vec2(dst[0] * 0.6, id);\n\n}\n\n\nvec2 mrch(vec3 ro, vec3 rd)\n{\n\n\n    float d0 = 0.0;\n    float id = 0.0;\n    for (int i = 0; i < ITR; i++)\n    {\n\n        vec3 sp = ro + rd * d0;\n        vec2 ds = map(sp);\n        j = float(i) / float(ITR);\n        if (d0 > DST || abs(ds.x) < SRF) break;\n        d0 += ds.x;\n        id = ds.y;\n    }\n    \n    // careful with shadow\n    if (d0 > DST) d0 = 0.0;\n    return vec2(d0, id);\n\n}\n\n\nvec3 nml(vec3 sp)\n{\n\n    return normalize(EPS.xyy * map(sp + EPS.xyy).x +\n                     EPS.yyx * map(sp + EPS.yyx).x +\n                     EPS.yxy * map(sp + EPS.yxy).x +\n                     EPS.xxx * map(sp + EPS.xxx).x);\n                     \n\n}\n\n\nvoid mainImage(out vec4 c_out, in vec2 uu)\n{\n   \n   vec2 rr = iResolution.xy;\n   vec2 uv = (uu + uu - rr) / rr.y;\n   \n   t = mod(iTime, 20.6);\n   \n   vec3 ro = vec3(cos(t) * (clamp(t - 11.0, 0.0, 1.0) * 23.0), sin(t) * (clamp(t - 11.0, 0.0, 1.0) * 23.0), -11);\n   vec3 fx = vec3(0.0);\n   vec3 w = normalize(fx - ro); \n   vec3 u = normalize(cross(w, vec3(0, 1, 0)));\n   vec3 v = normalize(cross(u, w));\n   vec3 rd = normalize(mat3(u, v, w) * vec3(uv, 0.5 + sin(t) * 0.5 + 0.5) * 2.0);\n   vec3 lp = vec3(0.0, 0.5, -3.0);\n   vec3 bgc = vec3(1.0 - (length(uv * 0.5) - 1.0)) * 0.1 * vec3(0.01, 0.0, 0.0);\n   vec3 clr = vec3(0.0);\n   vec3 arc = vec3(1.0);\n   vec3 clrs[NSO] = vec3[NSO](\n       vec3(1.0),\n       vec3(4.25, 0.5, 0.25),\n       vec3(1.0),\n       vec3(1.0),\n       vec3(1.0, 1.0, 0.25)\n   );\n\n   vec2 sc = mrch(ro, rd);\n   float d = sc.x;\n   int id = int(sc.y);\n   clr = bgc;\n   int rid = 0;\n   // reflections\n   for (int i = 0; i < 2; i++)\n   {\n   \n       if (d > 0.0)\n       {\n           rid = id;\n           vec3 ambc = clrs[id];\n           vec3 sp = ro + rd * d;\n           vec3 n = nml(sp);\n           vec3 ld = normalize(lp - sp);\n           float ar = d / DST;\n           float ao = exp(-2.0 * pow(max(0.0, 1.0 - map(sp + n * ar).x / ar), 2.0));\n           float df = max(0.0, dot(n, ld));\n           float fr = pow(1.0 + dot(n, rd), 4.0);\n           float spc = pow(max(dot(reflect(-ld, n), -rd), 0.0), 10.0);\n           clr = mix(ambc * (0.8 + ao + 0.2) * df + spc, bgc, min(fr, 0.5));\n           clr = (mix(clr, bgc, 1.0 - exp(-0.0003 * pow(d, 3.0)))) * arc;\n           \n           if (rid == 0)\n           {\n               vec3 rr = reflect(rd, n);\n               ro = sp + 0.01 * rr;\n               rd = rr;\n               arc *= 0.0025;\n\n           } else {\n               clr += g * vec3(clrs[2]);\n               clr += g1 * mix(vec3(0.0, 0, 0), vec3(1.0, 0.0, 0.0), sin(j + t) * 0.5);\n               break;\n           \n           }\n           \n           \n           \n       }\n       \n   \n   }\n   \n   clr += g * vec3(clrs[2]);\n   clr += g1 * mix(vec3(0.0, 0, 0), vec3(1.0, 0.0, 0.0), sin(j + t) * 0.5);\n   c_out = vec4(pow(clr, vec3(0.45)), 1.0);\n   \n}","name":"Image","description":"","type":"image"}]}