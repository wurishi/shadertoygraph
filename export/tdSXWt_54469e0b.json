{"ver":"0.1","info":{"id":"tdSXWt","date":"1555276563","viewed":573,"name":"Space Polyp","username":"OliverSchaff","description":"My first try on wavy motion. Use mouse to rotate.","likes":36,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","transparency","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Renderingcode from a shader by Shane\n// https://www.shadertoy.com/view/ll2SRy\n\n#define PI 3.14159265359\n#define grad_step 0.01\n#define time 2.0*iTime\n\n\n// Spectrum colour palette\n// IQ https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.0,0.5,0.5),vec3(.0,1.0,.0),vec3(0.62,0.33,0.37) );\n}\n\n// iq's distance functions\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\nfloat sdUnion_s( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 carToPol(vec3 p) {\n    float r = length(p);\n    float the = acos(p.z/r);\n    float phi = atan(p.y,p.x);\n    return vec3(r,the,phi);\n}\n\n// 2D rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nfloat pModPolar(inout vec2 p, float repetitions) { \n\tfloat angle = 2.*PI/repetitions; \n\tfloat a = atan(p.y, p.x) + angle/2.; \n\tfloat r = length(p); \n\tfloat c = floor(a/angle); \n\ta = mod(a,angle) - angle/2.; \n\tp = vec2(cos(a), sin(a))*r; \n    // For an odd number of repetitions, fix cell index of the cell in -x direction // (cell index would be e.g. -5 and 5 in the two halves of the cell): \n\tif (abs(c) >= (repetitions/2.)) c = abs(c); \n    return c;\n}\n\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.z -= clamp( p.z, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat distortedCapsule(vec3 p){\n    float dtime = 1.8*p.z-time-1.; // mix time with space to create wave\n    float dt = sin((dtime)-0.8*sin(dtime)); // distorted time, asymmetric sine wave\n    p.x += 0.2*(p.z)*dt;\n   \tfloat d = sdVerticalCapsule(p-vec3(0.9,0,0.), 2.0,0.05*(4.0-1.5*p.z));\n    float d2 = sdSphere(p-vec3(0.9,0,2.0),0.2);\n    d = sdUnion_s(d,d2,0.1);\n\treturn d;\n}\n\n\n\nfloat map( vec3 p ){\n    float dt = sin((time+2.5)-0.8*sin(time+2.5)); // distorted time, asymmetric sine wave\n    p.z += -0.2*dt;\n    float d0 = sdSphere(p-vec3(0,0,-0.7),0.5);\n    \n    float tentacleIndex = pModPolar(p.xy, 9.0);\n    p = rotationXY(vec2(0.0,-0.8))*p;\n    float d2 = distortedCapsule(p);\n    d0 = sdUnion_s(d0,d2,0.4);\n    return d0;\n}\n\n// get gradient in the world\nvec3 gradient( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tmap( pos + dx ) - map( pos - dx ),\n\t\t\tmap( pos + dy ) - map( pos - dy ),\n\t\t\tmap( pos + dz ) - map( pos - dz )\t\t\t\n\t\t)\n\t);\n}\n\n\nvec3 fresnel( vec3 F0, vec3 h, vec3 l ) {\n\treturn F0 + ( 1.0 - F0 ) * pow( clamp( 1.0 - dot( h, l ), 0.0, 1.0 ), 5.0 );\n}\n\n\n\nvec3 selfColor(vec3 pos) {\n    vec3 pol = carToPol(pos-vec3(0,0,-0.8));\n    return spectrum(0.45*pol.x);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvec3 reflectedColor(in vec3 p, in vec3 rd){\n    \n    vec3 Ks = vec3(0.7); // specular reflected intensity\n    float shininess = 40.0;\n    \n   \tvec3 n = gradient( p );\n    vec3 ref = reflect( rd, n );\n    vec3 rc = vec3(0);\n    \n    vec3 light_pos   = vec3( 15.0, 20.0, 5.0 );\n\tvec3 light_color = vec3( 1.0, 1.0, 1.0 );\n\tvec3 vl = normalize( light_pos - p );\n\tvec3 specular = vec3( max( 0.0, dot( vl, ref ) ) );\n    vec3 F = fresnel( Ks, normalize( vl - rd ), vl );\n\tspecular = pow( specular, vec3( shininess ) );\n\trc += light_color * specular; \n    return rc;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ) {\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec3 ro = vec3( 5.0*cos(0.2*iTime-10.0), 1.0, 5.0*sin(0.2*iTime-10.0));\n    vec3 ta = vec3( 0. , 0. , 0. );\n    \n    float aa = 1.0/min(iResolution.y,iResolution.x);\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0);  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy, 1.9+0.8*sin(0.15*iTime+12.0)) ); // 3.0 is the lens length\n    \n    // rotate camera with mouse\n\tmat3 rot = rotationXY(iMouse.xy * vec2( 0.01, -0.01 ) );\n\trd = rot * rd;\n\tro = rot * ro;\n    vec3 col = vec3(0), sp;\n    \n\t// Ray distance, bail out layer number, surface distance and normalized accumulated distance.\n\tfloat t=0., layers=0., d, aD;\n    \n    // Surface distance threshold. Smaller numbers give a sharper object. Antialiased with aa\n    float thD = 0.5*sqrt(aa); \n    \n    // Only a few iterations seemed to be enough. Obviously, more looks better, but is slower.\n\tfor(int i=0; i<50; i++)\t{\n        \n        // Break conditions. Anything that can help you bail early usually increases frame rate.\n        if(layers>12. || col.g>1.0 || t>8.) break;\n        \n        // Current ray postion\n        sp = ro + rd*t;\n\t\t\n        d = map(sp); // Distance to nearest point in the cube field.\n        \n        // If we get within a certain distance of the surface, accumulate some surface values.\n        // Values further away have less influence on the total.\n        //\n        // aD - Accumulated distance. I interpolated aD on a whim (see below), because it seemed \n        // to look nicer.\n        //\n        // 1/.(1. + t*t*.85) - Basic distance attenuation. Feel free to substitute your own.\n        \n         // Normalized distance from the surface threshold value to our current isosurface value.\n        aD = (thD-abs(d))/thD;\n        \n        // If we're within the surface threshold, accumulate some color.\n        // Two \"if\" statements in a shader loop makes me nervous. I don't suspect there'll be any\n        // problems, but if there are, let us know.\n        if(aD>0.) { \n            // Smoothly interpolate the accumulated surface distance value, then apply some\n            // basic falloff (fog, if you prefer) using the camera to surface distance, \"t.\"\n            // selfColor is the color of the object at the point sp\n            vec3 sc = selfColor(sp);\n            col += 8.*sc*(aD*aD*(3. - 2.*aD)/(1. + t*t*0.85));\n            col += 1.0*reflectedColor(sp, rd);\n            layers++;\n        }\n\n\t\t\n        // Kind of weird the way this works. I think not allowing the ray to hone in properly is\n        // the very thing that gives an even spread of values. The figures are based on a bit of \n        // knowledge versus trial and error. If you have a faster computer, feel free to tweak\n        // them a bit.\n        //t += abs(d)*0.5;\n        t += max(abs(d)*0.8, thD*1.1); \n\t}\n    \n    // I'm virtually positive \"col\" doesn't drop below zero, but just to be safe...\n    col = max(col, 0.);\n    \n\tfragColor = vec4(clamp(col, 0., 1.), 1);\n }\n","name":"Image","description":"","type":"image"}]}