{"ver":"0.1","info":{"id":"Mdjfzd","date":"1501818714","viewed":764,"name":"Lava Planet Deconstructed","username":"morgan3d","description":"Exploration of P_Malin's Shadertoy '17 contest winning code from https://www.shadertoy.com/view/ldBfDR","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["planet","comment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Deconstructed [SH17A] Lava Planet\n// originally by @P_Malin for the \"two tweet\" challenge.\n// https://www.shadertoy.com/view/ldBfDR\n//\n// I simplified some parts for clarity as well.\n// This shader renders the planet by slices. It is very\n// similar to parallax texture mapping, but it accumulates\n// the volumetric glow while searching for the planet surface.\n// The sky is exactly the same as the ground, but since you're\n// looking up, it acts flat because the height threshold is never\n// hit.\n\n// The red channel defines the height, but all channels\n// are used for color.\n#define elevationMap iChannel0\n#define colorMap iChannel1\n\nvoid mainImage( out vec4 outColor, vec2 fragCoord ) {\n    outColor = vec4(0);\n\n    // 'view' direction. This is the ray projected (effectively)\n    // into texture space, with the y-axis keeping track of \n    vec3 dir = vec3(fragCoord / iResolution.x, 1) - 0.5;\n    dir /= -abs(dir.y);\n    \n    // xz is the texture space offset. y is the distance from\n    // the max height down to the surface.\n    vec3 offset = vec3(0);\n    vec3 glow;\n    vec3 material;\n    vec3 landscape; \n    vec2 scrollDirection = vec2(0.707, 0.707);\n\t    \n    \n    vec2 coord = fragCoord;\n    // Stack many thin slices. The 0.6 height is critical to\n    // the character. The step size affects performance and quality,\n    // but also brightness because there is no normalizing factor\n    // on \"glow\". This loop is just for the volumetrics and finding the\n    // surface. The surface color and shading is outside of the loop.\n    //\n    // Work from the top down (the surface is pushed in by parallax mapping\n    // instead of popped up)\n    float clearance = 1.0;\n    for (float h = 0.0; h < 0.6 && clearance > 0.0; h += 0.001) {\n\n        // Use the x channel of texture 0 as a threshold for elevation.\n        // Once this falls to zero or below the rest of the loop\n        // does nothing.\n        clearance = max(0.0, texture(elevationMap, coord * 0.1).r - offset.y);\n        if (clearance > 0.0) {\n\t        // Volumetric lighting\n            \n\t\t \t// Calculate offset of slice intersection\n            // at this elevation.\n            offset = dir * h;\n            \n            // Add time sliding to move the camera\n            coord = offset.xz - iTime * 0.2 * scrollDirection;\n            \n            landscape = texture(elevationMap, coord * 0.1).rgb;\n            material = texture(colorMap, coord).rgb;\n            \n            // Don't glow too much near the top of mountains \n            // or we'll see banding in the lighting.\n            glow = pow(landscape * material, material + 7.0 + 0.1) * offset.y;\n            outColor.rgb += glow;\n        }\n    }\n    \n    \n    // Term for over-lighting the surface to hide\n    // banding artifacts. Increase contrast close to\n    // the surface (to make lava glow), decrease higher\n    // up (to hide banding).\n    float contrast = offset.y;\n    \n    // Use \"landscape\" at this point as fake light + shadow\n    // on the surface\n    landscape -= texture(elevationMap, coord * 0.1 -  0.01).rgb - 0.4; \n    // Color the surface\n    outColor.rgb += material * landscape + glow * 6e2 * contrast;\n    \n\t// Darken in the distance\n    outColor.rgb -= -offset.z * 0.03;\n    \n}","name":"Image","description":"","type":"image"}]}