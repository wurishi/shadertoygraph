{"ver":"0.1","info":{"id":"Ns3SD2","date":"1633942170","viewed":96,"name":"Basic Render Pipeline 2021-22","username":"meteotrix","description":"basic render pipeline. clipping is borked.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["lesson"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define _PI 3.1415926\n\nstruct Vertex\n{\n    vec3 pos;\n    vec3 color;\n};\n\nstruct Triangle\n{\n    Vertex v0;\n    Vertex v1;\n    Vertex v2;\n};\n\n//max tris per mesh\n#define max_tris 10 \n\nstruct Mesh\n{\n    int nb_tris;\n    Triangle tris[max_tris];\n    mat4x4 transfo;\n};\n\nfloat tri_area(vec3 v0, vec3 v1, vec3 v2)\n{\n    vec3 a = v1 - v0;\n    vec3 b = v2 - v0;\n    return length(cross(a,b)) * 0.5;\n}\n\nbool cross_up(vec3 v0, vec3 v1, vec3 v2)\n{\n    vec3 a = v1 - v0;\n    vec3 b = v2 - v0;\n    return cross(a,b).z >= 0.0;\n}\n\nbool pixel_in_tri(vec3 p, vec3 v0, vec3 v1, vec3 v2)\n{\n    //return cross_up(v1,v2,p) && cross_up(p,v2,v0) && cross_up(v0,v1,p) ;\n    \n     return \n          acos(dot(normalize(v0-p),normalize(v1-p)))\n        + acos(dot(normalize(v1-p),normalize(v2-p)))\n        + acos(dot(normalize(v2-p),normalize(v0-p)))\n        >= 1.999*_PI;\n}\n\nvec3 baryC_coords(vec3 p, vec3 v0, vec3 v1, vec3 v2)\n{\n    float tri_total_area = tri_area(v0,v1,v2);\n    float tri_subarea_v0 = tri_area(v1,v2,p);\n    float tri_subarea_v1 = tri_area(p,v2,v0);\n    float tri_subarea_v2 = tri_area(v0,v1,p);\n    return vec3( tri_subarea_v0 / tri_total_area,\n                 tri_subarea_v1 / tri_total_area,\n                 tri_subarea_v2 / tri_total_area);\n}\n\nvec3 color_for_pixel(vec3 baryC, vec3 c0, vec3 c1, vec3 c2)\n{\n    return c0 * baryC.x + c1 * baryC.y + c2 * baryC.z;\n}\n\nvec3 perspective_proj(vec3 p_VS, float near)\n{\n    float ratio = near / p_VS.z;\n    p_VS.x /= iResolution.x/iResolution.y;\n    return vec3(p_VS.xyz * ratio) - vec3(0,0,near);\n}\n\nvec3 perspective_proj_fov_bad(vec3 p_VS, float near, float fov)\n{\n    vec4 p = vec4(p_VS, 1);\n    float r = iResolution.x/iResolution.y; //aspect ratio\n    float s = near/p.z; //scale\n    mat4x4 proj = mat4x4(   s/r,0,0,0,\n                            0,  s,0,0,\n                            0,  0,s,0,\n                            0,  0,0,1);\n    return (p * proj).xyz - vec3(0,0,near);\n}\n\nvec4 perspective_proj_fov(vec3 p_VS, float near, float fov_y)\n{\n    vec4 p = vec4(p_VS, 0);\n    p.z = max(near,p.z); //tweak here: clamp z to near, not to 0\n    float f = tan(fov_y*0.5); //fov factor\n    float r = iResolution.x/iResolution.y; //aspect ratio\n    mat4x4 proj = mat4x4(   1.0/(f*r),0,    0,       0,\n                            0,        1.0/f,0,       0,\n                            0,        0,    1.0,     0,   //leave z for now\n                            0,        0,    1.0/near,0);  //put z/near in w for the perspective divide\n    vec4 p_proj = p * proj;\n    return vec4((p_proj/p_proj.w).xyz - vec3(0,0,near),p_proj.w); //code outside shouldn't assume we're on z==0\n    //return vec4((p_proj/p_proj.w).xyz, p_proj.w);\n}\n\n//obj: transfo de l'objet\n//rotation: rotation voulue\n//offset: offset du pivot\nvec3 rotate(vec4 v_WS, mat4x4 obj, mat4x4 rotation, vec3 offset)\n{\n    vec4 p = v_WS * inverse(obj); //passer de WS à OS\n    \n    //offset translation\n    mat4x4 t = mat4x4( 1,0,0,offset.x,\n                       0,1,0,offset.y,\n                       0,0,1,offset.z,\n                       0,0,0,1);\n                       \n    //test: confirmed, rotation transpose inverts it\n    if(false)\n    {\n        mat3x3 rota = mat3x3( rotation[0][0],rotation[0][1],rotation[0][2],\n                              rotation[1][0],rotation[1][1],rotation[1][2],\n                              rotation[2][0],rotation[2][1],rotation[2][2]);\n        rota = transpose(rota);\n        rotation[0][0] = rota[0][0];\n        rotation[0][1] = rota[0][1];\n        rotation[0][2] = rota[0][2];\n        rotation[1][0] = rota[1][0];\n        rotation[1][1] = rota[1][1];\n        rotation[1][2] = rota[1][2];\n        rotation[2][0] = rota[2][0];\n        rotation[2][1] = rota[2][1];\n        rotation[2][2] = rota[2][2];\n        p *= t * rotation * inverse(t);\n    }\n    else p *= t * rotation * inverse(t);\n    \n    return (p * obj).xyz; //repasser en WS\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0.0,0.0,mix(0.0,1.0,uv.y));   \n    \n    {Vertex v0 = Vertex(vec3(0.0,0.0,0.0), vec3(1.0,0.0,0.0));\n    Vertex v1 = Vertex(vec3(1.0,0.0,0.0), vec3(0.0,1.0,0.0));\n    Vertex v2 = Vertex(vec3(1.0,1.0,0.0), vec3(0.0,0.0,1.0));\n    Vertex v3 = Vertex(vec3(0.0,1.0,0.0), vec3(1.0,0.0,1.0));\n    \n    Vertex v4 = Vertex(vec3(0.0,0.0,0.0), vec3(1.0,0.0,0.0));\n    Vertex v5 = Vertex(vec3(1.0,0.0,0.0), vec3(0.0,1.0,0.0));\n    Vertex v6 = Vertex(vec3(1.0,0.0,1.0), vec3(0.0,0.0,1.0));\n    Vertex v7 = Vertex(vec3(0.0,0.0,1.0), vec3(1.0,0.0,1.0));   \n        \n    const int nb_meshs = 2;\n    Mesh meshs[nb_meshs];\n    meshs[0].nb_tris = 2;\n    meshs[1].nb_tris = 2;\n    \n    meshs[0].tris[0] = Triangle(v0, v1, v2);\n    meshs[0].tris[1] = Triangle(v0, v2, v3);\n    \n    meshs[1].tris[0] = Triangle(v4, v5, v6);\n    meshs[1].tris[1] = Triangle(v4, v6, v7);\n    \n    float move_cycle = sin(iTime)*3.5;\n    mat4x4 spin_cycle = mat4x4( cos(-iTime), -sin(-iTime),0,0,\n                                sin(-iTime), cos(-iTime), 0,0,\n                                0,          0,            1,0,\n                                0,          0,            0,1);\n        \n    meshs[0].transfo = mat4x4(  1,0,0,0,\n                                0,1,0,0,\n                                0,0,1,5,\n                                0,0,0,1);                                                                \n    meshs[1].transfo = mat4x4(  8,0,0,-4, \n                                0,8,0,-2, \n                                0,0,8, 4, \n                                0,0,0, 1);\n    \n    float z_min = 9999.0; //z \"buffer\"\n    vec3 closest_color = vec3(0,0,0);\n    \n    float t_ = 0.4; //toggle\n    mat4x4 view_matrix = mat4x4(cos(iTime*t_),0,sin(iTime*t_),0, \n                                0,1,0,0, \n                                -sin(iTime*t_),0,cos(iTime*t_),0, \n                                0,0,0,1);\n    float near = 1.00;\n    //float far = 50.00;\n\n    for(int j=0;j<nb_meshs;++j)\n    {\n        for(int i=0;i<meshs[j].nb_tris;++i)\n        {   \n            vec4 v0_OS = vec4(meshs[j].tris[i].v0.pos,1);\n            vec4 v1_OS = vec4(meshs[j].tris[i].v1.pos,1);\n            vec4 v2_OS = vec4(meshs[j].tris[i].v2.pos,1);\n        \n            vec4 v0_WS = v0_OS * meshs[j].transfo;\n            vec4 v1_WS = v1_OS * meshs[j].transfo;\n            vec4 v2_WS = v2_OS * meshs[j].transfo;\n            \n            if(j==0)\n            {\n                v0_WS.xyz = rotate(v0_WS, meshs[0].transfo, spin_cycle, vec3(-0.5,-0.5,0.0));\n                v1_WS.xyz = rotate(v1_WS, meshs[0].transfo, spin_cycle, vec3(-0.5,-0.5,0.0));\n                v2_WS.xyz = rotate(v2_WS, meshs[0].transfo, spin_cycle, vec3(-0.5,-0.5,0.0));\n            }\n            \n            //à display pour debug/check later\n            vec3 v0_VS = (v0_WS * inverse(view_matrix)).xyz;\n            vec3 v1_VS = (v1_WS * inverse(view_matrix)).xyz;\n            vec3 v2_VS = (v2_WS * inverse(view_matrix)).xyz;\n            \n            //actually, question: how large is near plane?\n            float fov_y = (120.0 / 180.0) * _PI;\n            vec4 v0_p = perspective_proj_fov(v0_VS,near, fov_y)+vec4(0.5,0.5,/*-near*/0,0);\n            vec4 v1_p = perspective_proj_fov(v1_VS,near, fov_y)+vec4(0.5,0.5,/*-near*/0,0);\n            vec4 v2_p = perspective_proj_fov(v2_VS,near, fov_y)+vec4(0.5,0.5,/*-near*/0,0);\n            \n            if(pixel_in_tri(vec3(uv.xy,0),v0_p.xyz, v1_p.xyz, v2_p.xyz))\n            {\n                vec3 baryC = baryC_coords(vec3(uv.xy,0), v0_p.xyz, v1_p.xyz, v2_p.xyz);                \n                \n                float frag_depth = v0_VS.z * baryC.x + v1_VS.z * baryC.y + v2_VS.z * baryC.z;\n                \n                if(frag_depth >= near*0.999)\n                {\n                    float w0 = v0_p.w;\n                    float w1 = v1_p.w;\n                    float w2 = v2_p.w;                \n                    vec3 baryC_p = vec3(baryC.x/w0, baryC.y/w1, baryC.z/w2 ) / ((baryC.x/w0)+(baryC.y/w1)+(baryC.z/w2)); //perspective-corrected\n\n                    //vec3 fragpos_OS = (v0_OS.xyz) * baryC_p.x + (v1_OS.xyz) * baryC_p.y + (v2_OS.xyz) * baryC_p.z;\n\n                    if(frag_depth < z_min)\n                    {\n                        z_min = frag_depth;\n\n                        col = color_for_pixel(baryC_p, meshs[j].tris[i].v0.pos, \n                                                       meshs[j].tris[i].v1.pos, \n                                                       meshs[j].tris[i].v2.pos);\n                        //col = vec3(mod(fragpos_OS.x, 0.2));\n                        //col = baryC_p;\n                        closest_color = col;\n                    }\n                }                \n            }\n        }\n    }}\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}