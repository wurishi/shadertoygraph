{"ver":"0.1","info":{"id":"WtV3Rw","date":"1578542234","viewed":187,"name":"Julia Quaternion Cross Section","username":"onlinerocker","description":"https://www.cs.cmu.edu/~kmcrane/Projects/QuaternionJulia/paper.pdf","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","fractal","mandelbrot","4d","quaternion","julla"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define ITERATIONS 2.0\n#define AA_SCALE 2.0\n\n//SETTINGS:\n#define VIEW_DIST 25.0\n#define C vec4(0.2,0.5,0.3,0.3)\n//#define C vec4(0.8,0.-0.1,0.9,0.9)\n\n//RESOURCES:\n//https://www.cs.cmu.edu/~kmcrane/Projects/QuaternionJulia/paper.pdf\n\nstruct Object\n{\n \tfloat dist;\n    float difVal;\n    float specVal;\n    float specKs;\n    float id;\n    \n    vec3 color;\n    vec3 normal;\n};\n\nstruct MarchRes\n{\n \tfloat totalDist;\n    float minDist;\n\n    vec3 curRay;\n    Object obj;\n};\n    \n//http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\nvec4 multQuat(vec4 q1, vec4 q2)\n{\n    vec4 r;\n    r.x   = q1.x*q2.x - dot( q1.yzw, q2.yzw );\n    r.yzw = q1.x*q2.yzw + q2.x*q1.yzw + cross( q1.yzw, q2.yzw );\n    return r;\n}\n\n//http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\nvec4 squareQuat(vec4 q)\n{\n \tvec4 r;\n    r.x   = q.x*q.x - dot( q.yzw, q.yzw );\n    r.yzw = 2.0*q.x*q.yzw;\n    return r;  \n}\n    \n//http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\nObject map(vec3 pos)\n{\n    Object o;\n    o.difVal = 1.0;\n    o.specVal = 50.0;\n    o.specKs = 0.01;    \n    o.dist = 1000.0;\n    \n    float ang = iTime/8.0;\n    float r;\n    \n    pos.xz *= mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n    \n    vec4 z = vec4(pos, 0.1);\n    vec4 dz = vec4(1, 0, 0, 0);\n\n    float it;\n    float minDist = 1000.0;\n    float mdX, mdY, mdZ;\n    mdX = minDist; mdY = minDist; mdZ = minDist;\n    \n    vec4 c = C;\n    c.w += 0.5*sin(iTime*2.0);\n        \n    \n    for(float x=0.0; x < 20.0; x++)\n    {\n        dz = 2.0*multQuat(z,dz);\n    \tz = squareQuat(z) + c;\n        \n        minDist = min(minDist, length(z - c)); //store minimum distance from starting point\n        mdX = min(mdX, abs(z.x));\n\t\tmdY = min(mdY, abs(z.y));\n\t\tmdZ = min(mdZ, abs(z.z));\n        \n        if(length(z) > 2.0)\n        {\n            it = x;\n            break;\n        }\n    }\n\n    //Coloring based off orbits: https://iquilezles.org/articles/ftrapsgeometric\n    o.color = vec3(0) + vec3(1.0, 0.3, 0.55)*sqrt(minDist);\n    o.color += vec3(0.0,0.3,0.3)*sqrt(mdX);\n    o.color += vec3(0.0,0.4,0)*sqrt(mdY);\n    o.color += vec3(0.0,0.1,0.5)*sqrt(mdZ);\n    \n    //o.color = vec3(1)-vec3(it/20.0);\n    o.dist = 0.5*length(z)*log(length(z)) / length(dz);\n    \n    return o;\n}\n  \nMarchRes marchRay(vec3 pos, vec3 dir, float speed)\n{\n \tMarchRes res;\n    Object o;\n    \n    res.totalDist = 0.001;\n    res.minDist = 1000.0;\n\n    for(int x=0; x<250; x++)\n    {\n \t\tres.curRay = pos + (dir*res.totalDist);\n        \n        o = map(res.curRay);\n        \n        if(abs(o.dist) < 0.001)\n        {\n            res.obj = o;\n            break;\n        }\n        else if(res.totalDist >= VIEW_DIST) break;\n           \n        \n        if(o.dist < res.minDist) res.minDist = o.dist;\n        res.totalDist += o.dist*speed; \n    }\n    \n    if(res.totalDist < VIEW_DIST)\n    {   \n        res.obj = o;\n    }\n    \t\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float done;\n    vec3 col;\n    \n    //AA based off IQ's implementation in many different shaders\n    for(float x=0.0; x<AA_SCALE; x++){\n        for(float y=0.0; y<AA_SCALE; y++){\n\n            vec2 aaOffset = vec2(x,y);\n            vec2 uv = (2.0*(fragCoord+aaOffset/AA_SCALE) - iResolution.xy)/iResolution.y;\n            vec3 camEye = vec3(0,0.0,2.2);\n            vec3 dir = normalize(vec3(uv, -1));\n\n\n            float rate = 8.0;\n            float camAng = PI/3.5;\n            float camAngPos = camAng;\n\n            mat2 rotCam = mat2( vec2(cos(camAng), -sin(camAng)), vec2(sin(camAng), cos(camAng)) );\n            mat2 rotCamPos = mat2( vec2(cos(camAngPos), -sin(camAngPos)), vec2(sin(camAngPos), cos(camAngPos)) );\n\n            camEye.xz = rotCamPos * camEye.xz;\n            dir.xz = rotCam * dir.xz;\n\n            MarchRes res = marchRay(camEye, dir, 1.0);\n            vec3 pos = res.curRay;  \n\n            vec3 tempCol = vec3(0.25);\n            if(res.totalDist < VIEW_DIST)\n            {\n                tempCol = res.obj.color;\n            }\n\n            col += tempCol;\n\n        }\n    }\n    \n    fragColor = vec4(col/((AA_SCALE*AA_SCALE)),1.0);\n}","name":"Image","description":"","type":"image"}]}