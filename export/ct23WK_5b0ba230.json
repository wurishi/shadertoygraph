{"ver":"0.1","info":{"id":"ct23WK","date":"1683162910","viewed":36,"name":"Sport Mesh","username":"Dirk","description":"Like a sport shoe micro texture.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["fractal","texture","mesh","fabric","sport","microtexture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nF map( v3 p ){\n\n    F d = 0.0;\n    \n    p.z += iTime*.2;\n    \n    vec3 pr = p*10.0;\n    pr.xz = fract( pr.xz )-0.5;\n    F s = pr.x>-pr.y ? 1. : -1.;\n    pr.xz -= abs( v2(0.5,0.5)*s ) -.5;\n    \n    d = torus(pr,v2(0.5,0.25))/10.0;\n    \n    d = min( p.y + 0.1, d );\n    \n\n    R d;\n\n}\n\nv3 calcNormal(v3 p) {\n\n    v2 e = v2(.001, 0);\n    v3 n = map(p) - v3( map(p-e.xyy), map(p-e.yxy), map(p-e.yyx) );\n    \n    R N(n);\n    \n}\n\nF  castRay(v3 ro, v3 rd) {\n\n    F t=0.;\n    \n    for( I i=0; i<100; i++) {\n    \n        F d = map(ro + rd*t);\n        t += d;\n        if(t>5.0 || A(d)<0.0001) B;\n        \n    }\n    \n    if(t>5.0) t=-1.;\n    \n    R t;\n    \n}\n\nv3 rayDir(v2 uv, v3 p, v3 l, F z) {\n\n    v3 f = N(l-p),\n    r = N(X(v3(0,1,0), f)),\n    u = X(f,r),\n    c = f*z,\n    i = c + uv.x*r + uv.y*u;\n    \n    R N(i);\n    \n}\n\nF s( v3 ro, v3 rd ){\n\n    F l = 1.0;\n    F t = 0.0;\n\n    for(I i=0;i<100;i++){\n    \n        F h = map(ro+rd*t);\n        l = min(l,32.0*abs(h)/t);\n        t+=h;\n    }\n\n    R l;\n}\n\nvoid mainImage( out v4 pixar, in v2 pixel ){\n\n    v2 uv = (2.0*pixel-iR.xy)/iR.y;\n    v2 uv2 = pixel/iR.xy;\n    \n    v2 m = ( iM.xy / iR.xy );\n    \n    v3 ro = v3(0.0,0.25,1.0);\n    ro.yz *= spin(-m.y*.1);\n    ro.xz *= spin(-m.x*.05);\n    v3 rd = rayDir( uv, ro, v3(0,0.,0), 1. );\n    F t = castRay( ro, rd );\n    \n    v3 col = v3(0.0);\n\n    if( t > 0.0 ){\n        if( t > 20.0 ){\n        \n            col = v3(0.0);\n            \n        }else{\n        \n            v3  pos = ro+rd*t;\n            v3  nor = calcNormal(pos);\n            v3  sun = v3(3.0,1.0,1.0);\n            F   dif = D(nor,sun) * 0.1 + 0.5;\n            F   sha = s(sun,nor);\n            \n            col = mix(v3(1.9,0.5,0.1),v3(dif),0.5)*sha;\n            \n        }\n    }\n\n    col *= P(col, v3(0.4545));\n    \n    pixar = v4(col,1.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n\n    //////////////////////////////\n    //                          //\n    //  DIRK'S DENSOR NOTATION  //\n    //                          //\n    //////////////////////////////\n\n\n#define  v2 vec2\n#define  v3 vec3\n#define  v4 vec4\n\n#define  iv2 ivec2\n#define  iv3 ivec3\n#define  iv4 ivec4\n\n#define  M2 mat2\n#define  M3 mat3\n#define  M4 mat4\n\n#define  iR iResolution\n#define  iM iMouse\n#define  iT iTime\n\n#define  PI 3.14159265359\n\n#define  A  abs\n#define  B  break\n#define  C  cos\n#define  D  dot\n#define  E  clamp\n#define  F  float\n#define  G  mix\n#define  H  hash\n#define  I  int\n#define  J  step\n#define  K  fract\n#define  L  length\n#define  M  min\n#define  N  normalize\n#define  O  mod\n#define  P  pow\n#define  Q  lerp\n#define  R  return\n#define  S  sin\n#define  T  texture\n#define  U  floor\n#define  V  mirror\n#define  W  min\n#define  X  cross\n#define  Y  mirror\n#define  Z  reflect\n\n#define  SS smoothstep\n\n\n\n    ////////////////////////\n    //                    //\n    //  ENGINE FUNCTIONS  //\n    //                    //\n    ////////////////////////\n    \n    \n//// UTILS ////\n\nF ndot(v2 a, v2 b ){\n    R a.x*b.x - a.y*b.y; \n}\nF dot2( v3 v ) {\n    R D(v,v);\n}\nv3 closestPointOnCylinder( v3 p, v2 dim ) {\n    return vec3(normalize(p.xy)*dim.x, clamp(p.z, -dim.y/2.0, dim.y/2.0));\n}\nlowp v3 permute( lowp  v3 x ){\n    R mod( x*x*34.+x, 289.); \n}\n\n\n//// PROFILES ////\n\nF profileSphere(  v2 p, F r){\n    return length(p) - r;\n}\nF profileLine(    v2 p, v2 dim){\n    return distance(p, vec2(clamp(p.x, -dim.x/2.0, dim.x/2.0), 0.0))-dim.y;\n}\nF profileSquare(  v2 p, v2 dim){\n    vec2 d = abs(p)-dim;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\nF profileRhombus( v2 p, v2 dim){\n    vec2 q = abs(p);\n    float h = clamp((-2.0*ndot(q,dim)+ndot(dim,dim))/dot(dim,dim),-1.0,1.0);\n    float d = length( q - 0.5*dim*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*dim.y + q.y*dim.x - dim.x*dim.y );\n}\nF profileCross(   v2 p, v2 b, F r ){\n\n    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n    vec2  q = p - b;\n    float k = max(q.y,q.x);\n    vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n    return sign(k)*length(max(w,0.0)) + r;\n}\nF profileHexagon( v2 p, F r ){\n\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nF getProfile( v2 p, I profile) {\n    float dist;\n    if (profile == 0) {\n        dist = profileSphere(p, 0.12);\n    } else if (profile == 1) {\n        dist = profileLine(p, vec2(0.4, 0.04));\n    } else if (profile == 2) {\n        dist = profileSquare(p, vec2(0.05,0.1))-0.02;\n    } else if (profile == 3) {\n        dist = profileRhombus(p, vec2(0.1,0.07))-0.03;\n    } else if (profile == 4) {\n        dist = profileCross(p, vec2(0.15,0.05), 0.0)-0.03;\n    } else if (profile == 5) {\n        dist = profileHexagon(p, 0.1)-0.03;\n    }\n    return dist;\n}\n\n\n\n    //////////////////////\n    //                  //\n    //  USER FUNCTIONS  //\n    //                  //\n    //////////////////////\n    \n\n// NOISE //\n\nF  hash11( F  p  ){\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nF  hash12( v2 p  ){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nF  hash13( v3 p3 ){\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nF  hash14( v4 p4 ){\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.x + p4.y) * (p4.z + p4.w));\n}\nv2 hash21( F  p  ){\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nv2 hash22( v2 p  ){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nv2 hash23( v3 p3 ){\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nv3 hash31( F  p  ){\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\nv3 hash32( v2 p  ){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nv3 hash33( v3 p3 ){\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\nv4 hash41( F  p  ){\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\nv4 hash42( v2 p  ){\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\nv4 hash43( v3 p  ){\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\nv4 hash44( v4 p4 ){\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n      F noise(   v2 p       ){\n\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash12( i + vec2(0.0,0.0) ), \n                     hash12( i + vec2(1.0,0.0) ), u.x),\n                mix( hash12( i + vec2(0.0,1.0) ), \n                     hash12( i + vec2(1.0,1.0) ), u.x), u.y);\n                     \n}\nfloat hash(float h) {\n\treturn fract(sin(h) * 43758.5453123);\n}\n\nfloat noise(vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tfloat n = p.x + p.y * 157.0 + 113.0 * p.z;\n\treturn mix(\n\t\t\tmix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n\t\t\t\t\tmix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n\t\t\tmix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\t\t\t\tmix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n      F noise3D( v3 x       ){\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tfloat n = p.x + p.y * 157.0 + 113.0 * p.z;\n\treturn mix(\n\t\t\tmix(mix(hash11(n + 0.0), hash11(n + 1.0), f.x),\n\t\t\t\t\tmix(hash11(n + 157.0), hash11(n + 158.0), f.x), f.y),\n\t\t\tmix(mix(hash11(n + 113.0), hash11(n + 114.0), f.x),\n\t\t\t\t\tmix(hash11(n + 270.0), hash11(n + 271.0), f.x), f.y), f.z);\n}\nlowp  F sNoise(  lowp  v2 v ){\n\n  lowp vec2 i = floor((v.x+v.y)*.36602540378443 + v),\n      x0 = (i.x+i.y)*.211324865405187 + v - i;\n  lowp float s = step(x0.x,x0.y);\n  lowp vec2 j = vec2(1.0-s,s),\n      x1 = x0 - j + .211324865405187, \n      x3 = x0 - .577350269189626; \n  i = mod(i,289.);\n  lowp vec3 p = permute( permute( i.y + vec3(0, j.y, 1 ))+ i.x + vec3(0, j.x, 1 )   ),\n       m = max( .5 - vec3(dot(x0,x0), dot(x1,x1), dot(x3,x3)), 0.),\n       x = fract(p * .024390243902439) * 2. - 1.,\n       h = abs(x) - .5,\n      a0 = x - floor(x + .5);\n      \n  return .5 + 65. * dot( pow(m,vec3(4.))*(- 0.85373472095314*( a0*a0 + h*h )+1.79284291400159 ), a0 * vec3(x0.x,x1.x,x3.x) + h * vec3(x0.y,x1.y,x3.y));\n  \n}\n      F fbm0(    v2 uv      ){\n\n    uv *= .75;\n    float value = 0.;\n    float amplitude = .75,n2=0.;\n    vec2 n1 = vec2(0.);\n    \n    for (int i = 0; i < 8; i++)\n    {\n        n2 = sin(uv.x+sin(uv.y*.43)/.37)+cos(uv.y+sin(uv.x*.37)/.43)+n2;\n        value -= abs(n2-value/2.0) * amplitude;\n        value = sqrt(value*value+.001/2.0);\n        \n        amplitude *= .37;\n\n        uv *= 2.05;\n        uv = vec2(uv.y,uv.x+n2);\n    }\n    \n    return value;\n    \n}\n      F fbm1(    v2 uv      ){\n\n    uv *= .8;\n    return fbm0(uv*2.)/2.+fbm0(uv);\n    \n}\n      F fbm2(    v2 x       ){\n\n    float f = 0.0;\n    float s = 0.5;\n    int   p = 8;\n    for( int i=0; i<9; i++ )\n    {\n        f += s*noise( x );\n        s *= 0.5;\n        x *= 2.0;\n        p *= 2;\n    }\n    \n    return f;\n}\n      F fbm3(    v2 uv      ){\n\n    uv*=4.0;\n    return mix(fbm2(uv+(0.5*noise(uv)-0.5)),fbm0(uv),0.5);\n\n}\n      F fbm4(    v3 p       ){\n\n\tfloat f = 0.0;\n\tf = 0.5000 * noise3D(p);\n\tp *= 2.01;\n\tf += 0.2500 * noise3D(p);\n\tp *= 2.02;\n\tf += 0.1250 * noise3D(p);\n\n\treturn f;\n}\n\n\n// SDF PRIMITIVES //\n\n// PRIMARY //\n\nF plane(     v3 p, v3 dir                   ){ \n    R D( p, N( dir ) );\n}\nF ball(      v3 p,  F s                     ){\n\n  return length(p)-s;\n\n}\nF box(      v3 p, v3 b                      ){\n\n  vec3 q = abs(p) - b;\n  \n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n  \n}\nF poll(      v3 p, v3 c                     ){\n\n  return length(p.xz-c.xy)-c.z;\n  \n}\nF egg(       v3 p, v3 r                     ){\n\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  \n  return k0*(k0-1.0)/k1;\n  \n}\nF pill(      v3 p,  F h,  F r               ){\n\n  p.y -= clamp( p.y, 0.0, h );\n  \n  return length( p ) - r;\n  \n}\n\n\n// AUXILIARY //\n\nF rBox(       v3 p, v3 b,  F r              ){\n\n  vec3 q = abs(p) - b;\n  \n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n  \n}\nF boxFrame(  v3 p, v3 b,  F e               ){\n\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  \n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n      \n} // Round Scaling Issue\nF torus(     v3 p, v2 t                     ){\n\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  \n  return length(q)-t.y;\n  \n}\nF link(      v3 p,  F le, F r1,  F r2       ){\n\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  \n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n  \n}\nF pillar(  v3 p,  F w,  F h,   F r          ){\n\n  vec2 d = vec2( length(p.xz)-2.0*w+r, abs(p.y) - h );\n  \n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - r;\n  \n}\nF rPillar(   v3 p, v3 a, v3 b,   F r        ){\n\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  \n  return sign(d)*sqrt(abs(d))/baba;\n  \n}\nF cone(      v3 p, v2 c,  F h               ){\n\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  \n  return sqrt(d)*sign(s);\n\n}\nF plane(     v3 p, v3 n,  F h               ){\n\n  return dot(p,n) + h;\n  \n}\nF hexPrism(  v3 p, v2 h                     ){\n\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n       \n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n  \n}\nF triPrism(  v3 p, v2 h                     ){\n  \n  vec3 q = abs(p);\n  \n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n\n}\nF rPill(     v3 p, v3 a, v3 b,   F r        ){\n\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  \n  return length( pa - ba*h ) - r;\n  \n}\nF kite(      v3 p,  F la, F lb,  F h, F ra  ){\n\n  p = abs(p);\n  vec2 b = vec2(la,lb);\n  float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n  vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n  \n  return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n  \n}\nF dimond(    v3 p,  F s                     ){\n  \n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n\n}\n\n\n// TOOLS //\n\nF  share( F d, F d2 ){ R max( d, d2 ); }\nF  carve( F d, F d2 ){ R min( -d, d2 ); }\nv3 fold(  v3 p, v3 dir ){ \n    \n        v3 n = N( dir );\n        p -= 2.*n*W( 0., D( p, n ) );\n        \n        R p;\n}\nF  join(  F d, F d2 ){ R min( d, d2 ); }\nF  slice( F d, v3 p, v3 dir ){\n\n       F pla = plane( p, dir );\n       \n       R max( pla, d );\n       \n   }\nF  shell( F d, F t ){ R max( d, d-t ); }\nv3 move( v3 p, v3 d2 ){ R p + d2; }\nM2 spin( F a                           ){ \n\n    F s=S(a*PI*2.0), c=C(a*PI*2.0); \n    \n    R M2(c,-s,s,c);\n    \n}\nF  twist( F d, F d2 ){ R min( d, d2 ); }\n\n\n// Elements //\n\nF spring(vec3 p, F r, F h, F c, I profile) {\n\n    float radius = r;\n    float height = h;\n    float coils = c/(height/3.141);\n\n    vec3 pc = closestPointOnCylinder(p, vec2(radius, height));\n\n    float distToCyl = distance(p, pc);\n\tfloat distToCoil = asin(sin(p.z*coils + 0.5*atan(p.x,p.y)))/coils;\n    \n    vec2 springCoords = vec2(distToCyl, distToCoil);\n    \n    //the multiplication factor is here to reduce the chance of the ray jumping through the back spring\n    return getProfile(springCoords, profile) * ( max(radius/2.0-abs(length(p.xy)-radius), 0.0)*0.3 + 0.7);\n}\nF grub( v3 p, F t ){\n\n    p.y += noise3D(p+3456.42);\n    R spring(p,noise3D(p)*0.05+(0.2-abs(p.z)*0.2),0.85+noise3D(p/2.0+t)*1.0,6.0,5);\n\n}\nF house( v3 p ){\n\n    return 1.0;\n    \n}\nF ladder( v3 p, I style ){\n\n    \n        F d = 0.0;\n        //F t = iTime;\n        F st = 0.0;\n        \n        p.x = min(A(p.x),4.0);\n        p.x = fract(p.x) -0.5;\n        \n        \n            v3 gp = p;\n        \n            gp.xy = abs(gp.xy);\n            gp = move(gp, v3(0.,-1.0,0.) );\n            \n            //st = sin(iTime);\n            \n            \n                p = fold( gp, v3(-1.0,-1.0,-0.0) );\n\n            if( style == 1 ){\n            \n                gp = move(gp, v3(0.1,-0.1,0.) );\n                p = fold( gp, v3(0.1,0.00,0.0) );\n                \n            }\n            \n        d = pillar(  p,  0.1,  4.0,   0.2          );\n        \n        R d;\n\n} //Rotate to Y Axis\n\nF convayor( v3 p, F t ){\n\n    F d = 0.0;\n\n    v3 bp = p; \n    bp.x += t;\n    bp.x = fract( bp.x )-0.5;\n    \n\n    v3 cp = p; \n    cp.y += 0.28; \n    cp.x += t;\n    cp.x = fract( cp.x )-0.5;\n\n    d = box( bp, v3( 0.25 ) );\n    \n    F d2 = box( cp, v3( 1.0,0.01,0.75 ) );\n    \n    cp.x = fract(cp.x*8.0)-0.5;\n    \n    \n    \n    F d3 = box( cp, v3( 0.48,-0.05,0.5 ) );\n    \n    d3 -= 0.1;\n    \n    d2 = min(d2,d3);\n    \n    d = min(d,d3);\n\n    R d;\n\n}\n\nF goblin( v3 p, I style ){\n    \n        //F t = iTime;\n        F st = 0.0;\n        \n     v3 gp = p;\n        \n        gp = abs( gp );\n        gp = move( gp, v3( 0.0, -3.0, 0.0 ) );\n        \n        if( p.y < 0.0 ){\n        \n            \n        \n            gp = fold( gp,  v3( -0.5, -0.5, 0.0 ) ); \n\n            gp = move( gp, v3( 0.0, 3.5, 0.0 ) ); \n            gp = fold( gp,  v3( 100.0 , 100.0, 2.0 ) );          \n            gp.yz *= spin(10.4);\n            \n            /*\n            if( gp.x <= 0.0 ){\n                gp = fold( gp,  v3( -0.5, -0.5, 0.0 ) );\n            }\n            if( gp.x > 0.0 ){\n                gp = fold( gp,  v3( -0.5, -0.5, 0.0 ) );\n            }\n            */\n            \n        }  \n        \n        if( p.y > 0.0 ){\n        \n            gp = fold( gp,  v3( -0.5, -0.5, 0.0 ) );\n            \n        } \n            \n        float d = pillar(  gp,  0.1,  4.0,   0.2          );\n        \n        return d;\n}\n\n\n\n\n\n\n","name":"Common","description":"","type":"common"}]}