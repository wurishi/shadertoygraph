{"ver":"0.1","info":{"id":"Ms3Xz4","date":"1457923791","viewed":325,"name":"Speed o' Light RayMarcher","username":"zephmann","description":"raymarchin'","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// returns distance from a point to surface of sphere\nfloat sphIntersect(vec3 p, vec3 c, float r, float d)\n{\n    vec3 tc = c;\n    \n    // uncomment for regular version\n    //d = 0.0;\n    \n    tc.x += cos( iTime * 2.3 - d );\n    tc.y += cos( iTime * 1.7 - d );\n\treturn (distance(p, tc) - r);\n}\n\n// march along ray until distance is within an epsilon or max steps is exceeded\nvec3 march(vec3 ro, vec3 rd)\n{\n    // col value to be returned\n\tvec3 col = vec3(0.);\n\t\n\tfloat t = 1.;        // current distance along ray\n\tfloat prevt = 0.;    // distance along ray at previous step\n\tfloat d = 10000000.; // distance to surface\n\tvec3 p;              // coordinates of current point on ray\n    float stepSize = 0.001;\n\t\n    int j;\n\tconst int maxSteps = 256;\n\t\n    // directional light\n\tvec3 light = (vec3(-1., -2., 1.5));\n\t\n    // sphere attributes\n\tfloat radius = 1.5;\n\tvec3 center = vec3(0.0, 0.0, 0.0);\n\t\n    // loop until steps exceeds max limit\n    // or break if our point is within epsilon distance\n\tfor(int i=0; i < maxSteps; i++)\n\t{\n\t\tprevt = t;\n\t\tp = ro + rd * t;\n\t\t\n\t\td = sphIntersect(p, center, radius, t);\n\t\t\n\t\tj = i+1;\n\t\tt += d;\n        //t += stepSize;\n\t\t\n        // check if distance is within epsilon\n\t\tif(abs(d) < 0.001)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n    // if j is less than maxSteps then we broke out early\n\tif(j < maxSteps)\n\t{\n        // used for calculating the surface normal\n    \tvec2 delta = vec2(0.001, 0.0);\n        \n        // calc surface normal\n\t\tvec3 norm = vec3(sphIntersect(p + delta.xyy, center, radius, t) - sphIntersect(p - delta.xyy, center, radius, t),\n\t\t\t\t\t\t sphIntersect(p + delta.yxy, center, radius, t) - sphIntersect(p - delta.yxy, center, radius, t),\n\t\t\t\t\t\t sphIntersect(p + delta.yyx, center, radius, t) - sphIntersect(p - delta.yyx, center, radius, t));\n\t\t\n        // calc lambert shading\n\t\tfloat lambert = max( dot(normalize(light), normalize(norm)), 0.0 );\n\t\t\n        // multiply surface color by lambert, add ambient color\n        vec3 surfColor = vec3(0.3, 0.8, 0.9);\n\t\tcol = surfColor * lambert + vec3(0.075);\n\t\t\n        // fake ambient occulusion\n\t\tcol *= vec3(float(maxSteps-j) / float(maxSteps));\n\t}\n\t\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv - 0.5;\n\tuv.y *= iResolution.y / iResolution.x;\n\t\n\tvec3 cam = vec3(0.0, 0.0, 8.0);\n\tvec3 dir = normalize(-cam);\n\t\n\tvec3 v1 = cross(dir, vec3(0,1,0));\n\tvec3 v2 = cross(dir, v1);\n\t\n\tdir += v1 * uv.x;\n\tdir += v2 * uv.y;\n\t\n\tvec3 col = march(cam, dir);\n\t\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}