{"ver":"0.1","info":{"id":"3ltGDH","date":"1576833680","viewed":209,"name":"Training 07 (Copo)","username":"coposuke","description":"training. I regret that no mirror reflection light...","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["training"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct geometry\n{\n    int type;\n    float dist;\n    vec3 position;\n    vec3 normal;\n};\n\nstruct info\n{\n    int type;\n    float dist;\n};\n    \nstruct lightinfo\n{\n    vec3 shade;\n    vec3 speculer;\n};\n    \nmat2 rotate(float angle)\n{\n    float s = sin(angle), c = cos(angle);\n    return mat2(c, s, -s, c);\n}\n\nvec2 pmod(vec2 rayPos, float split)\n{\n    float angle = atan(rayPos.x, rayPos.y) + PI / split;\n\tfloat num = PI_2 / split;\n    float id = (floor(angle / num));\n    angle = (id) * num;\n    return rayPos * rotate(-angle);\n}\n\nvec2 opMin(vec2 a, vec2 b)\n{\n    return (a.x < b.x) ? a : b;\n}\n\nfloat sdBox(vec3 pos, vec3 size)\n{\n    vec3 q = abs(pos) - size;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\ninfo map(vec3 rayPos)\n{\n    vec2 result = vec2(1e+5, 0);\n    \n    // plane\n    result = opMin(result, vec2(dot(rayPos + 40.0, vec3(0,0,1)), 1.0));\n    result = opMin(result, vec2(dot(rayPos - 40.0, vec3(0,0,-1)), 1.0));\n    result = opMin(result, vec2(dot(rayPos - 40.0, vec3(-1,0,0)), 1.0));\n    result = opMin(result, vec2(dot(rayPos + 40.0, vec3(1,0,0)), 1.0));\n    result = opMin(result, vec2(dot(rayPos - 20.0, vec3(0,-1,0)), 1.0));\n    result = opMin(result, vec2(dot(rayPos + 20.0, vec3(0,1,0)), 1.0));\n    \n    // mirror ball\n    vec3 ballRayPos = rayPos;\n    ballRayPos.y -= sin(iTime) * 5.0;\n    ballRayPos.xz = rotate(iTime * 0.3) * ballRayPos.xz;\n    ballRayPos.xz = pmod(ballRayPos.xz, 40.0);\n    ballRayPos.yz = pmod(ballRayPos.yz, 40.0);\n    ballRayPos.xy = rotate(iTime * 2.0) * ballRayPos.xy;\n    vec3 boxPos = ballRayPos - vec3(0, 0, 8.0 + smoothstep(0.5, 0.65, abs(sin(iTime * 0.5))) * 8.0);\n    vec3 boxSize= vec3(0.7 + smoothstep(0.5, 0.65, abs(sin((iTime - 2.5) * 0.5)) * 1.0) - smoothstep(0.5, 0.65, abs(sin(iTime * 0.5))) * 0.3);\n    result = opMin(result, vec2(sdBox(boxPos, boxSize), 2.0));\n\n    // mirror ring\n    vec3 ringRayPos = rayPos;\n    ringRayPos.y -= sin(iTime) * 5.0;\n    ringRayPos.xz = rotate(iTime * 2.0) * ringRayPos.xz;\n    ringRayPos.yz = pmod(ringRayPos.yz, 1000.0);\n    ringRayPos.xz = pmod(ringRayPos.xz, 10.0);\n    boxPos = ringRayPos - vec3(0, 0, 7.0);\n    boxSize= vec3(0.4 - smoothstep(0.5, 0.6, sin(iTime * 0.5)) * 0.2);\n    result = opMin(result, vec2(sdBox(boxPos, boxSize), 2.0));\n    \n    ringRayPos = rayPos;\n    ringRayPos.y -= sin(iTime) * 5.0;\n    ringRayPos.zy = rotate(iTime * 2.0) * ringRayPos.zy;\n    ringRayPos.xz = pmod(ringRayPos.xz, 1000.0);\n    ringRayPos.yz = pmod(ringRayPos.yz, 10.0);\n    boxPos = ringRayPos - vec3(0, 0, 5.0);\n    boxSize= vec3(0.3 - smoothstep(0.5, 0.6, sin(iTime * 0.5)) * 0.15);\n    result = opMin(result, vec2(sdBox(boxPos, boxSize), 2.0));\n    \n    ringRayPos = rayPos;\n    ringRayPos.y -= sin(iTime) * 5.0;\n    ringRayPos.xy = rotate(iTime * 2.0) * ringRayPos.xy;\n    ringRayPos.xz = pmod(ringRayPos.xz, 1000.0);\n    ringRayPos.yz = pmod(ringRayPos.yz, 10.0);\n    boxPos = ringRayPos - vec3(0, 0, 3.0);\n    boxSize= vec3(0.2 - smoothstep(0.5, 0.6, sin(iTime * 0.5)) * 0.1);\n    result = opMin(result, vec2(sdBox(boxPos, boxSize), 2.0));\n    \n    info ret;\n    ret.type = int(result.y);\n    ret.dist = result.x;\n    return ret;\n}\n\nvec3 computeNormal(vec3 rayPos)\n{\n    const float EPSILON = 1e-2;\n    return normalize(vec3(\n        map(rayPos + vec3(EPSILON,0,0)).dist - map(rayPos - vec3(EPSILON,0,0)).dist,\n        map(rayPos + vec3(0,EPSILON,0)).dist - map(rayPos - vec3(0,EPSILON,0)).dist,\n        map(rayPos + vec3(0,0,EPSILON)).dist - map(rayPos - vec3(0,0,EPSILON)).dist\n    ));\n}\n\ngeometry raymarch(vec3 camPos, vec3 camRay)\n{\n    geometry result;\n    vec3 rayPos = camPos;\n    float dist = 0.0;\n    \n    for(int i=0 ; i<200 ; ++i)\n    {\n        rayPos = camPos + camRay * dist;\n        \n        info inf = map(rayPos);\n        dist += inf.dist;\n        \n        if(inf.dist < 1e-4)\n        {\n            result.type = inf.type;\n            result.position = camPos + camRay * dist;\n            result.normal = computeNormal(result.position);\n            result.dist = dist;\n            return result;\n        }\n    }\n    \n    return result;\n}\n\nlightinfo lighting(geometry result, geometry reflection, vec3 camRay)\n{\n    vec3 lightPoints[] = vec3[](\n        vec3(-40,-20, 40),\n        vec3(-40, 20, 40),\n        vec3( 40,-20, 40),\n        vec3( 40, 20, 40),\n        vec3(-40,-20,-40),\n        vec3(-40, 20,-40),\n        vec3( 40,-20,-40),\n        vec3( 40, 20,-40)\n    );\n    \n    for(int i=0 ; i<8 ; ++i)\n    {\n        lightPoints[i].xz = rotate(iTime * 0.2) * lightPoints[i].xz;\n    }\n    \n    vec3 resultPosition = (result.type == 2) ? reflection.position : result.position;\n    vec3 resultNormal   = (result.type == 2) ? reflection.normal   : result.normal;\n    \n    lightinfo light;\n    for(int i=0 ; i<8 ; ++i)\n    {\n        vec3 lightPoint = lightPoints[i];\n        vec3 lightPointDir = lightPoint - resultPosition;\n        float lightPointDist = length(lightPointDir);\n        lightPointDir = normalize(lightPointDir);\n        \n        light.shade += float(result.type == 1) * vec3(clamp((40.0 - lightPointDist) * 0.03, 0.0, 1.0));\n        light.shade += float(result.type == 2) * vec3(clamp((40.0 - lightPointDist) * 0.03, 0.0, 1.0));\n\n        \n        lightPointDir = normalize(lightPoint - result.position);\n        vec3 reflectDir = normalize(reflection.position - result.position);\n        float RdotL = dot(reflectDir, lightPointDir);\n        float phong = pow(max(RdotL, 0.0), 50.0);\n        light.speculer += float(result.type == 2) * phong;\n    }\n    \n    light.shade = clamp(light.shade, 0.2, 1.0);\n    light.speculer = clamp(light.speculer, 0.0, 1.0);\n    \n    return light;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    mat3 camMat = rotate(iTime * 0.2, vec3(0,1,0));\n    vec3 camPos = camMat * vec3(0,0,-30);\n    vec3 camRay = normalize(camMat * vec3(uv, 2.0));\n    \n    geometry result = raymarch(camPos, camRay);\n    geometry reflection = raymarch(result.position + result.normal * 1e-3, reflect(camRay, result.normal));\n    \n    vec3 resultPosition = (result.type == 2) ? reflection.position : result.position;\n    vec3 resultNormal   = (result.type == 2) ? reflection.normal   : result.normal;\n    \n    vec2 textureUV = vec2(0);\n    textureUV += float(0.0 < abs(resultNormal.x)) * resultPosition.zy;\n    textureUV += float(0.0 < abs(resultNormal.y)) * resultPosition.xz;\n    textureUV += float(0.0 < abs(resultNormal.z)) * resultPosition.yx;\n    \n    vec4 diffuse = vec4(0);\n    diffuse += float(result.type == 1) * texture(iChannel0, textureUV * 0.0125);\n    diffuse += float(result.type == 2) * texture(iChannel0, textureUV * 0.0125);\n    \n    lightinfo light = lighting(result, reflection, camRay);\n    \n    fragColor.rgb = diffuse.rgb * light.shade + light.speculer;\n\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI      3.14159265357989\n#define PI_2    6.28318530715978\n\nmat3 rotate(float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m;\n}","name":"Common","description":"","type":"common"}]}