{"ver":"0.1","info":{"id":"WtdfDM","date":"1613175212","viewed":100,"name":"raymarchin","username":"mtybadger","description":"using a simple raymarcher to render the mandelbulb fractal \n\nmade by spruce :)","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal"],"hasliked":0,"parentid":"WldBzn","parentname":"raymarching a mandelbulb fractal"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Let's declare our Ray objects with an origin and a direction.\nstruct Ray { \n\tvec3 origin;\n\tvec3 dir;\n};\n    \n//boilerplate function for rotating points - I wrote one myself but it was much less impressive and concise than this so I replaced it.\n//still don't really get matrices but this takes a point and axes and does some magic. will come back later to figure this whole\n//matrix multiplication thing out.\nvec3 rotate( vec3 pos, float x, float y, float z )\n{\n\tmat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0, cos( x ), -sin( x ), 0.0, sin( x ), cos( x ) );\n\tmat3 rotY = mat3( cos( y ), 0.0, sin( y ), 0.0, 1.0, 0.0, -sin(y), 0.0, cos(y) );\n\tmat3 rotZ = mat3( cos( z ), -sin( z ), 0.0, sin( z ), cos( z ), 0.0, 0.0, 0.0, 1.0 );\n\n\treturn rotX * rotY * rotZ * pos;\n}\n\n//THIS is the actual mandelbulb formula - again still some reading to do but the point of this function, like any SDF, is to take\n//in a test point and figure out the distance to the fractal edge itself, positive or negative. \nfloat hit( vec3 r )\n{\n\tr = rotate( r, sin(iTime / 4.0), cos(iTime / 4.0), 0.0 );\n\tvec3 zn = vec3( r.xyz );\n\tfloat rad = 0.0;\n\tfloat hit = 0.0;\n\tfloat p = 8.0;\n\tfloat d = 1.0;\n\tfor( int i = 0; i < 10; i++ )\n\t{\n\t\t\n\t\t\trad = length( zn );\n\n\t\t\tif( rad > 2.0 )\n\t\t\t{\t\n\t\t\t\thit = 0.5 * log(rad) * rad / d;\n\t\t\t}else{\n\n\t\t\tfloat th = atan( length( zn.xy ), zn.z );\n\t\t\tfloat phi = atan( zn.y, zn.x );\t\t\n\t\t\tfloat rado = pow(rad,8.0);\n\t\t\td = pow(rad, 7.0) * 7.0 * d + 1.0;\n\t\t\t\n\n\n\t\t\tfloat sint = sin( th * p );\n\t\t\tzn.x = rado * sint * cos( phi * p );\n\t\t\tzn.y = rado * sint * sin( phi * p );\n\t\t\tzn.z = rado * cos( th * p ) ;\n\t\t\tzn += r;\n\t\t\t}\n\t\t\t\n\t}\n\t\n\treturn hit;\n}\n\n//Bridge between the fragment shader and the mandelbulb formula above: converts Rays to 3d vector points to test with. \nfloat distToScene(in Ray r) {\n    return hit(r.origin);\n}\n\nvec3 lerp(vec3 colorone, vec3 colortwo, float value)\n{\n\treturn (colorone + value*(colortwo-colorone));\n}\n\n//The actual fragment shader: this runs once for every pixel in the image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //Normalize the pixel coords coming in and account for aspect ratio etc etc. \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.y *= iResolution.y / iResolution.x;\n    //The important part: Make a ray at 0,0 and slightly in front of the origin, and with a direction based on the pixel it's coming from\n\tRay ray = Ray(vec3(0.0, 0.0, -2.0 + (sin(iTime) * 0.5)), normalize(vec3(uv, 1.)));\n\tvec3 col = vec3(0.);\n    //now march it!\n    for (int i=0; i<100; i++) {\n        //run this part 100 times: calculate the distance between the current ray position and the fractal\n        float dist = distToScene(ray); \n    \tif (dist < 0.001) {\n            //if we're less than 0.001 away from it then assume we've hit it, and set the color accordingly\n            col = vec3(1.0 / (float(i)/8.0));\n            break;\n        }\n        //otherwise march forward the maximum amount and try again. if you never hit the fractal, the color will remain black.\n        ray.origin += ray.dir * dist;\n    }\n    //output the colour we got multiplied by a tint: in this case red with a smidge of green and blue. Try messing with the vec3 arguments below to produce other colours.\n\t//fragColor.rgb = col * vec3(0.6, 0.15, 0.05);\n    vec3 black = vec3(0.0, 0.0, 0.0);\n    vec3 red = vec3(0.6, 0.15, 0.05);\n\tvec3 orange = vec3(1.0, 0.62, 0.13) * 0.15;\n    vec3 main = lerp(black, red, col.r);\n\tvec3 edge = lerp(black, orange, pow(col.r, 3.5));\n    vec3 lerpcolor = main + edge;\n    \n    fragColor.rgb = lerpcolor;\n}","name":"Image","description":"","type":"image"}]}