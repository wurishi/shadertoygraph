{"ver":"0.1","info":{"id":"7sXGzs","date":"1617301415","viewed":106,"name":"Endzsinke","username":"lantgabor","description":"Rotate the camera with the mouse click. \n\nUses Phong-Blinn + Raytracing+ reflections + CSG tree + Raymarching/Spheretracing + gamma correction.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["reflection","shadow","camera","csg","postprocess","spheretracing","gamma","phongblinn"],"hasliked":0,"parentid":"tsXXzr","parentname":"Sphere tracing example"},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = 1.*texelFetch(iChannel0,ivec2(fragCoord),0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This file contains the \n// ---- SPHERE TRACING ----\n\n\nstruct Ray\n{\n\tvec3 P;\n\tfloat Tmin;\n\tvec3 V;\n\tfloat Tmax;\n};\n\nstruct TraceResult\n{\n    float T;\t\t// Distance taken on ray\n    int matid;\n    int flags;\t\t// bit 0:   distance condition:     true if travelled to far t > t_max\n                    // bit 1:   surface condition:      true if distance to surface is small < error threshold\n};                  // bit 2:   iteration condition:    true if took too many iterations\n\nstruct SphereTraceDesc\n{\n    float epsilon;  //Stopping distance to surface\n    int maxiters;   //Maximum iteration count\n};\n\nvec3 Fresnel(vec3 F0, float cosTheta) { \n\t\treturn F0 + (vec3(1, 1, 1) - F0) * pow(cosTheta, 5.);\n}\n\n// SDF\n\nValue sdf(in vec3 p)\n{\n    p+=vec3(0,0,0); // base\n    \n    //vec3 r1 = rotateZ (vec3(0., 0.8, 0.)-vec3(-1.0, 1, -2.0), iTime*0.5);\n    //vec3 r2 = rotateX (vec3(0., 0.8, 0.)-vec3(-1.0, 1, -2.0), iTime*0.5);\n    \n    Value result = Value(sdPlane( p-vec3(0., 0.1, 0.),vec3(0., 1., 0.), 1.0), 0);\n    /* ------ */\n    \n    Value cone = Value(sdCone( p-vec3(0.,1.73,0.), vec2(0.5,0.5), .64 ), 1); \n    Value botC = Value(sdCappedCylinder( p-vec3(0.,1.3,0.), vec3(0.,0.6 , 0.),  vec3(0), 0.2), 1);\n    Value C = Value(sdBox( p-vec3(0., 1.05, 0.),vec3(0.65,0.2,0.65)), 5);\n\n    Value bottom = opSmoothUnion(C, opSmoothUnion(botC, cone, .2), .1);\n    \n    Value A = Value(sdOctahedron( p-vec3(0., 2.35, 0.),  0.4), 2);\n    result = Unite(result, A);\n    \n    \n    Value topC = Value(sdCappedCylinder( p-vec3(0.,2.9,0.), vec3(0.,0.3 , 0.),  vec3(0), 0.2), 1);\n    Value S1 = Value(sdSphere( p-vec3(0,3.7,0), .7), 1);\n    Value B = Value(sdBox( p-vec3(0, 4.3, 0),vec3(.8)), 1);\n    Value S2 = Value(sdSphere( p-vec3(0,3.8,0), .7), 1);\n\n    result = Unite(result, opSmoothUnion(topC, Subtract(S2,Subtract(B,S1)), .2));\n\n    Value table = Value(sdBox( p-vec3(0., 1., 0.),vec3(2,.05,2)), 6);\n    Value leg1 = Value(sdCappedCylinder( p-vec3(1.9,-1.7,1.9), vec3(0.,0.3 , 0.),  vec3(0,2.74,0), 0.1), 3);\n    Value leg2 = Value(sdCappedCylinder( p-vec3(-1.9,-1.7,1.9), vec3(0.,0.3 , 0.),  vec3(0,2.74,0), 0.1), 3);\n    Value leg3 = Value(sdCappedCylinder( p-vec3(-1.9,-1.7,-1.9), vec3(0.,0.3 , 0.),  vec3(0,2.74,0), 0.1), 3);\n    Value leg4 = Value(sdCappedCylinder( p-vec3(1.9,-1.7,-1.9), vec3(0.,0.3 , 0.),  vec3(0,2.74,0), 0.1), 3);\n    \n    result = Unite(result, Unite(table, Unite(leg1,Unite(leg2,Unite(leg3,leg4)))));\n\n    result = Unite(result, bottom);\n    \n    /*\n    Value T = Value(sdTorus( p-vec3(2. + sin(iTime)*.5, cos(iTime)*.7, 0.),vec2(0.6,0.15) ), 1);\n    result = Unite(result, T);\n    \n    Value A = Value(sdTwistedTorus( p-vec3(-2., 0.1, 0.), -cos(iTime)* 2.), 2);\n    result = Unite(result, A);\n    \n    Value O = Value(sdOctahedron( p-vec3(4.,0, 0.),0.8 ), 3);\n    result = Unite(result, O);\n    \n    Value C = Value(sdBox( p-vec3(0., 0., 0.),vec3(.4)), 7);\n    result = Unite(result, C);\n    \n    Value TopC = Value(sdCappedCylinder( p-vec3(2., -0.5, 2.), vec3(1.,1. , 0.),  vec3(0, 0, .2), 0.3), 5);\n    result = Unite(result, TopC);\n    \n    Value S = Value(sdSphere( p-vec3(4., -0.7 * cos(iTime+pi/2.), 2.), .3), 1);\n    Value S4 = Value(sdSphere( p-vec3(4., -0.7 * sin(iTime), 2.), .3), 1);\n    result = Unite(result,  opSmoothUnion(S,S4, .2));\n        \n    Value A2 = Value(sdSolidAngle(p-vec3(-2., -0.5, 2), vec2(0.1,0), 0.8), 4);\n    result = Unite(result,  A2);\n    \n    Value C2 = Value(sdBallyBall( p-vec3(0., 0, 2), iTime),8);\n    result = Unite(result,  C2);\n    \n    Value S2 = Value(sdSphere( p-vec3(0,0,-2), 1.), 9);\n    Value B = Value(sdBox( p-vec3(0, 0, -2),vec3(.8)), 3);\n    Value S3 = Value(sdSphere( p-vec3(0,0,-2), .5), 2);\n    Value B2 = Value(sdBox( p-vec3(0, sin(iTime)*.6, -1),vec3(.8)), 3);\n    result = Unite(result,Intersect(Unite(S3, Subtract(  S2, B)), B2) );\n    */\n    return result;\n    \n}\n\nTraceResult sphere_trace(in Ray ray, in SphereTraceDesc params)\n{\n    TraceResult ret = TraceResult(ray.Tmin, 0,0);\n    float d;\n    \n    int i = 0; do\n    {\n                Value sd = sdf(ray.P+ret.T*ray.V);\n\n        d = sd.x;\n        ret.T+=d;\n        ret.matid = int(sd.y);\n\n        ++i;\n    } while (\n\t\tret.T < ray.Tmax &&       \t\t\t// Stay within bound box\n\t\td\t  > params.epsilon * ret.T &&\t// Stop if cone is close to surface\n\t\ti     < params.maxiters\t        \t// Stop if too many iterations\n\t);\n    \n    ret.flags =  int(ret.T >= ray.Tmax)\n              | (int(d <= params.epsilon* ret.T)  << 1)\n              | (int(i >= params.maxiters) << 2);\n    return ret;\n}\n\n// ---- SHADING ---- (todo!)\n\nvec3 normal(const in vec3 p)\n{\n    const float eps=0.001;\n    vec3 plus = vec3(sdf(p+vec3(eps,0,0)).x,sdf(p+vec3(0,eps,0)).x,sdf(p+vec3(0,0,eps)).x);\n    vec3 minu = vec3(sdf(p-vec3(eps,0,0)).x,sdf(p-vec3(0,eps,0)).x,sdf(p-vec3(0,0,eps)).x);\n    return normalize(plus-minu);\n}\n\nvec3 missColor(Ray ray)\n{\n    return vec3(texture(iChannel2, ray.V).xyz);\n}\nvec3 errorColor(Ray ray)\n{\n    return vec3(1.,0.1,0.1);\n}\nvec3 hitColor(Ray ray)\n{\n    vec3 col = vec3(0.); // radiance\n    vec3 weight = vec3(1.); // for reflection\n    \n    for(int d = 0; d < 5; d++) { // RAY BOUNCE\n        for(int l = 0; l < 3; l++) { // FOR EACH LIGHT\n            SphereTraceDesc params = SphereTraceDesc(0.001, 128);\n            TraceResult t = sphere_trace(ray, params);\n            \n            if(bool(t.flags & 1)) return weight * missColor(ray);    \n            else if(bool(t.flags & 0)) return weight * errorColor(ray);\n\n            vec3 p = ray.P + ray.V*t.T; // hit \n            vec3 n = normal(p); // normal\n            vec3 lightDir = light[l].lightPos - p;\n\n            float distance = length(lightDir); // distance to light\n            distance = distance * distance;\n\n            lightDir = normalize(lightDir); // normalize\n\n            float costheta = max(dot(n,lightDir),0.);\n            float si = 0.0;\n            col += weight * mats[t.matid].ka * light[l].lightColour; // ambient\n\n            if (mats[t.matid].type == 0) { // rough\n\n                col += weight * mats[t.matid].kd * costheta * light[l].lightColour * light[l].glossiness / distance; // ambient + diff\n\n                Ray nRay = Ray(p + n * 0.001, 0.5, lightDir, 250.);\n\n                SphereTraceDesc params = SphereTraceDesc(0.001, 128);\n                TraceResult result = sphere_trace(nRay, params);\n\n                if (costheta > 0. && bool(result.flags & 1)) { // shadow\n\n                    //specular\n\n                    vec3 toLight = normalize(light[l].lightPos - p);\n                    vec3 h = normalize(-ray.V + toLight);\n\n                    si = pow(clamp(dot(h,n),0.,1.),mats[t.matid].shininess);\n\n                    col += weight * si * mats[t.matid].ks * light[l].lightColour * light[l].specularCoefficient / distance; // specular\n\n                }\n            }\n            if ( mats[t.matid].type == 1 ) { // reflective\n                   weight *= Fresnel(mats[t.matid].F0, dot(-ray.V, n));\n                   ray.P = p + n * 0.001;\n                   ray.V = reflect(ray.V, n); \n            } \n        \n       } return col;\n   }\n}\n\n// ---- CAMERA and EVENTs ----\n// Common key codes (WASD instead of arrows)\n\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nconst vec3 EyeStartPosition = vec3(-4.5,0.1,1.5);\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2)\n{\n    float time = iTime*0.2;\n    float dist = 8.0;\n    float height = 0.8;\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    \n    // Ray generation\n    \n    \n\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw+EyeStartPosition;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= vec2(-pi/2.,pi/8.);\n    \n   \tif(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    \n    \n    \n    float camAngleX = time;\n    float camAngleY = 0.;\n\n    eye.x = -sin(camAngleX) * cos((camAngleY));\n    eye.y = -sin((camAngleY)) + height;\n    eye.z = cos((camAngleX)) * cos((camAngleY));\n    eye *= dist;\n    \n    uv += vec2(time,0.);\n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 0.1;\n    if (isKeyHeld(KeyLeft )) eye -= u*speed;\n    if (isKeyHeld(KeyRight)) eye += u*speed;\n    if (isKeyHeld(KeyUp   )) eye += w*speed;\n    if (isKeyHeld(KeyDown )) eye -= w*speed;\n    \n   \n    \n    \n    if(iMouse.z>=0.)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//V\n               0.5,\t\t\t\t\t\t\t//minT\n               normalize(w+px.x*u+px.y*v),\t//P\n               250.);\t\t\t\t\t\t//maxT\n}\n\n// ---- MAIN ----\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Generate ray from pixel\n    vec3 eye; vec2 data; // this will be saved into first two pixels\n    Ray ray = Camera(fragCoord, eye, data);\n    \n    // Set epsilon and maximum iteration\n          \n    vec3 radiance = hitColor(ray);\n    \n    float screenGamma = 1.3; // gamma\n    vec3 colorGammaCorrected = pow(radiance, vec3(1.0 / screenGamma));\n    fragColor = vec4(colorGammaCorrected, 1.0);\n\n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = 0.3*prev + 0.7*fragColor;\n\n    // First two pixels are reserved\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixel (0,0)\n        fragColor.yzw = eye-EyeStartPosition;\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor.zw = data;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float pi = 3.1415926535897932384626433832795;\n\nstruct Value {\n    float x;\n    int y;\n};\n\n\nstruct Material {\n    vec3 ka, kd, ks;\n    float shininess;\n    int type; // 0 == rough, 1 == reflective, 2 == refractive (todo)\n    vec3 F0; // Fresnel\n};\n\nstruct Light\n{\n    vec3 lightPos;\n    vec3 lightColour;\n    float glossiness;\n    float specularCoefficient;\n};\n\nconst Light[] light = Light[] (\n    Light(vec3(11.,11,3.) /*lightPos*/,\n    vec3(.2, .2, .7) /*lightColour*/,\n    122. /*glossiness*/,\n    250. /*specularCoefficient*/\n    ),\n    Light(vec3(-11., 7. , 3.) /*lightPos*/,\n    vec3(.7, .1, .3) /*lightColour*/,\n    45. /*glossiness*/,\n    122. /*specularCoefficient*/\n    ),\n    Light(vec3(0., 7. , -6.) /*lightPos*/,\n    vec3(.8, .8, .4) /*lightColour*/,\n    77. /*glossiness*/,\n    88. /*specularCoefficient*/\n    )\n);\n\n\nconst Material[] mats = Material[] (\n                              Material(\n                                  vec3(.01) /*ka*/, vec3(0.2) /*kd*/, vec3(0.2) /*ks*/,\n                                  1., 0, vec3(0.03) \n                              ),//0\n                              Material(\n                                  vec3(.01) /*ka*/, vec3(0.) /*kd*/, vec3(0.) /*ks*/,\n                                  1., 1, vec3(1.5, 1.3, 0.9) \n                              ),//1\n                              Material(\n                                  vec3(.01) /*ka*/, vec3(0.1,0.46,0.8) /*kd*/, vec3(1.3) /*ks*/,\n                                  16., 0, vec3(1) \n                              ),//2\n                              Material(\n                                  vec3(.01) /*ka*/, vec3(0.11,0.9,0.2) /*kd*/, vec3(1.8) /*ks*/,\n                                  122., 0, vec3(0.13f, 0.35f, 0.05f) \n                              ),//3\n                              Material(\n                                  vec3(.01) /*ka*/, vec3(0.) /*kd*/, vec3(0.) /*ks*/,\n                                  1., 1, vec3(1.1) \n                              ),//4\n                              Material(\n                                  vec3(.01) /*ka*/, vec3(0.3,0.2,0.1) /*kd*/, vec3(10.) /*ks*/,\n                                  50., 0, vec3(0.) \n                              ),//5\n                              Material(\n                                  vec3(.01) /*ka*/, vec3(0.4,0.11,0.4) /*kd*/, vec3(.5) /*ks*/,\n                                  4., 0, vec3(0.4,0.11,0.4) \n                              ),//6\n                              Material(\n                                  vec3(.01) /*ka*/, vec3(0.) /*kd*/, vec3(0.) /*ks*/,\n                                  .1, 1, vec3(0.7,.55,.5) \n                              ),//7\n                              Material(\n                                  vec3(.01) /*ka*/, vec3(0.4,0.26,0.8) /*kd*/, vec3(1.4,1.46,1.3) /*ks*/,\n                                  98., 0, vec3(0.93f, 0.15f, 0.17f) \n                              ),//8\n                              Material(\n                                  vec3(.01) /*ka*/, vec3(0.2,0.16,0.1) /*kd*/, vec3(4) /*ks*/,\n                                  66., 0, vec3(.1,.4,.3) \n                              )//9\n                              );\n                              \nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec3 opTwist (vec3 p, float angle)\n{\n  float c = cos(10.0*p.y + angle);\n  float s = sin(10.0*p.y + angle);\n  mat2  m = mat2(c, -s, s, c);\n  return vec3(m*p.xz, p.y);\n}\n\nfloat sdTwistedTorus( in vec3 pos, float angle)\n{\n  return 0.5*sdTorus( opTwist(pos,angle), vec2(0.3, 0.15));\n}\n\nfloat sdDodecahedron(vec3 p, float radius)\n{\n  const float phi = 1.61803398875;  // Golden Ratio = (sqrt(5)+1)/2;\n  const vec3 n = normalize(vec3(phi,1,0));\n\n  p = abs(p / radius);\n  float a = dot(p, n.xyz);\n  float b = dot(p, n.zxy);\n  float c = dot(p, n.yzx);\n  return (max(max(a,b),c)-n.x) * radius;\n}\n\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\nfloat sdBallyBall( in vec3 pos, in float time)\n{\n  return sdSphere(pos, 0.4 )\n    + 0.03*sin(50.0*pos.x)*sin(50.0*pos.y + 8.0*time)*sin(50.0*pos.z);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 d = abs(p) - b;\n\treturn length(max(d,0.0))+min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\n\n// VALUE FN\n\nfloat Unite(float f1,float f2) {\n    return min(f1,f2);\n}\n\nValue Unite(Value a, Value b) {\n    if (a.x <= b.x) {\n        return a;\n    }\n    else return b;\n}\n\nValue Unite(Value a, float f, int m) {\n    if (a.x <= f) {\n        return a;\n    }\n    else return Value(f, m);\n    \n}\n\nValue Unite(float f, Value a, int m) {\n    return Unite(Value(f, m), a);\n}\n\n\nfloat Subtract(float f1, float f2) {\n    return max(-f1,f2);\n}\n\nValue Subtract(Value a, Value b) {\n    if (-a.x > b.x) {\n        return Value(-a.x, a.y);\n    }\n    else return b;\n}\n\nValue Subtract(Value a, float f, int m) {\n   if (-a.x > f) {\n        return Value(-a.x, a.y);\n    }\n    else return Value(f, m);\n    \n}\n\nValue Subtract(float f, Value a, int m) {\n    return Subtract(Value(f, m), a);\n}\n\n\nfloat Intersect(float f1, float f2) { \n    return max(f1,f2);\n}\n\nValue Intersect(Value a, Value b) {\n    if (a.x > b.x) {\n        return Value(a.x, a.y);\n    }\n    else return b;\n}\n\nValue Intersect(Value a, float f, int m) {\n   if (a.x > f) {\n        return Value(a.x, a.y);\n    }\n    else return Value(f, m);\n    \n}\n\nValue Intersect(float f, Value a, int m) {\n    return Intersect(Value(f, m), a);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nValue opSmoothUnion( Value d1, Value d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return Value(mix( d2.x, d1.x, h ) - k*h*(1.0-h), d1.y);\n}\n\nValue opSmoothUnion( Value d1, float d2, float k, int m ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1.x)/k, 0.0, 1.0 );\n    return Value(mix( d2, d1.x, h ) - k*h*(1.0-h), m);\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nValue opSmoothIntersection( Value d1, Value d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return Value(mix( d2.x, d1.x, h ) + k*h*(1.0-h), d1.y); \n}\n\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a), ca = cos(a);\n  return vec3(p.x, ca * p.y - sa * p.z, sa * p.y + ca * p.z);\n}\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a),   ca = cos(a);\n  return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a),   ca = cos(a);\n  return vec3(ca * p.x - sa * p.y, sa * p.x + ca * p.y, p.z);\n}\n","name":"Common","description":"","type":"common"}]}