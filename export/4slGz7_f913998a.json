{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define EPS vec2(1e-3, 0.0)\n#define ON vec2(1.0, 0.0)\n\nvec2 t;\nfloat time;\n\nvec3 rotateX(float a, vec3 v)\n{\n\treturn vec3(v.x, cos(a) * v.y + sin(a) * v.z,\n\t\t\t\tcos(a) * v.z - sin(a) * v.y);\n}\n\n\nvec3 rotateY(float a, vec3 v)\n{\n\treturn vec3(cos(a) * v.x + sin(a) * v.z, v.y,\n\t\t\t\tcos(a) * v.z - sin(a) * v.x);\n}\n\nvec2 cubeInterval(vec3 ro, vec3 rd)\n{\n\tvec3 slabs0 = (vec3(+1.0) - ro) / rd;\n\tvec3 slabs1 = (vec3(-1.0) - ro) / rd;\n\t\n\tvec3 mins = min(slabs0, slabs1);\n\tvec3 maxs = max(slabs0, slabs1);\n\t\n\t\n\treturn vec2(max(max(mins.x, mins.y), mins.z),\n\t\t\t\tmin(min(maxs.x, maxs.y), maxs.z));\n}\n\nfloat N(vec2 p)\n{\n\tp = mod(p, vec2(101.0));\n\treturn fract(sin(p.x * 41784.0) + sin(p.y * 32424.0));\n}\n\nfloat smN2(vec2 p)\n{\n\tvec2 fp = floor(p);\n\tvec2 pf = smoothstep(0.0, 1.0, fract(p));\n\t\n\treturn mix( mix(N(fp), N(fp + ON), pf.x), \n\t\t\t   mix(N(fp + ON.yx), N(fp + ON.xx), pf.x), pf.y);\n}\n\nfloat smN3(vec3 p)\n{\n\tvec2 o = vec2(111.0);\n\treturn mix(smN2(p.xy + floor(p.z) * o),\n\t\t\t   smN2(p.xy + (floor(p.z) + 1.0) * o), smoothstep(0.0, 1.0, fract(p.z)));\n}\n\nfloat fbm3(vec3 p)\n{\n\tfloat f = 0.0, x;\n\tfor(int i = 1; i <= 7; ++i)\n\t{\n\t\tx = exp2(float(i));\n\t\tf += (smN3(p * x) - 0.5) / x;\n\t}\n\treturn f;\n}\n\n#define fbm2(g) fbm3(vec3(g, 0.0))\n\nfloat pulse(float e0, float e1, float x)\n{\n\treturn step(e0, x) - step(e1, x);\n}\n\nfloat beam(float x)\n{\n\tx = clamp(x, 0.0, 1.0);\n\treturn smoothstep(0.7, 1.0, pow(1.0 - 2.0 * abs(x - 0.5), 0.02));\n}\n\nfloat beamShadow(float x)\n{\n\tx = clamp(x + 0.1, 0.0, 0.5);\n\treturn smoothstep(0.7, 1.0, pow(1.0 - 2.0 * abs(x - 0.5), 0.1));\n}\n\nvec3 wood(vec2 p)\n{\n\tp += vec2(200.0);\n\tp.x *= 1.2;\n\tp.y *= 0.6;\n\treturn vec3(0.4, 0.25, 0.1) * (1.0 + fbm2(p));\n}\n\nvec3 crate(vec3 o, vec2 p)\n{\n\tfloat shadow = mix(0.5, 1.0, smoothstep(0.0, 0.2, o.y + 1.0));\n\t\n\tfloat innercoord = fract(p.x * 3.0);\n\tvec2  outercoord = abs(p) * 3.0 - vec2(2.0);\n\tfloat acrosscoord = min(0.3, abs(dot(p, vec2(1.0)))) * 8.0 - 2.0;\n\t\n\tfloat inner = beam(innercoord);\n\t\n\tfloat outers0 = beamShadow(outercoord.y);\n\tfloat outers1 = beamShadow(outercoord.x);\n\t\n\tfloat outerm0 = beam(outercoord.y);\n\tfloat outerm1 = beam(outercoord.x);\n\t\n\tfloat acrosss0 = 1.0 - beamShadow(acrosscoord);\n\tfloat acrossm0 = 1.0 - beam(acrosscoord);\n\t\n\to += vec3(1e-2);\n\t\n\tfloat stain = (smoothstep(0.95, 1.0, fbm3(mod(o, vec3(5.01)) * 0.5) + 0.8 + fbm3(mod(o, vec3(5.01)) * 4.0) * 0.4));\n\t\n\tfloat v = inner * (1.0 - acrosss0) + acrossm0;\n\t\n\tv = v * (1.0 - outers1) + outerm1;\n\t\n\tvec3 innercol = wood(vec2(p.x * 3.0, p.y)) * 0.76;\n\tvec3 acrosscol = wood(vec2(dot(p, vec2(1.0)) * 3.0, p.x * 2.0));\n\tvec3 outer0col = wood(p.yx * vec2(4.0, 1.4)) * vec3(1.0, 1.0, 0.9);\n\tvec3 outer1col = wood(p.xy * vec2(4.0, 1.4));\n\t\n\tvec3 col = mix(innercol, acrosscol, acrossm0);\n\t\n\tcol = mix(col, outer1col, outerm1);\n\tcol = mix(col, outer0col, outerm0);\n\t\n\tfloat f = mix(0.5, 1.0,\n\t\t\t\t  (1.0 - pow(abs(p.x), 30.0)) * (1.0 - pow(abs(p.y), 30.0)));\n\t\n\treturn shadow * (v * (1.0 - outers0) + outerm0) * col * f * mix(vec3(1.0), vec3(0.8, 0.7, 0.5), stain);\n}\n\nbool gridSolidity1(vec3 rp)\n{\n\trp = floor(rp);\n\treturn rp.y < (N(rp.xz * 2.0) * 10.0 - 20.0 / (1.0 + abs(rp.x)));\n}\n\n\nfloat groundSolidity(vec2 p)\n{\n\treturn gridSolidity1(vec3(p.x, -2.0, p.y)) ? 1.0 : 0.0;\n}\n\nfloat groundShadow(vec2 p)\n{\n\tvec2 fp = floor(p);\n\tvec2 pf = smoothstep(0.0, 1.0, fract(p));\n\t\n\treturn mix( mix(groundSolidity(fp), groundSolidity(fp + ON), pf.x), \n\t\t\t   mix(groundSolidity(fp + ON.yx), groundSolidity(fp + ON.xx), pf.x), pf.y);\n}\n\nvec3 stone(vec2 p)\n{\n\tp += vec2(200.0);\n\tp.x *= 1.2;\n\tp.y *= 0.6;\n\treturn vec3(0.5, 0.5, 0.51) * smoothstep(0.0, 0.9, 1.0 + fbm2(p));\n}\n\nvec3 stoneFloor(vec3 o, vec2 p)\n{\n\tfloat shadow = 1.0 - groundShadow(o.xz * 2.0 - vec2(0.5));\n\treturn fbm2(p * 4.0) * 0.1 + shadow * mix(0.6, 0.65, smoothstep(0.0, 0.1, fbm2(o.xz * 2.0))) * vec3(0.7, 0.7, 0.8);\n}\n\nvec3 wall(vec3 o, vec2 p)\n{\n\tfloat f = mix(0.5, 1.0,\n\t\t\t\t  (1.0 - pow(abs(p.x), 30.0)) * (1.0 - pow(abs(p.y), 30.0)));\n\t\n\tif(o.y < -0.99)\n\t\treturn stoneFloor(o, p) * f * 0.7;\n\t\n\tfloat innercoord = fract(p.x * 7.0);\n\tvec2  outercoord = abs(p) * 3.0 - vec2(2.0);\n\tfloat acrosscoord = min(0.3, abs(dot(p, vec2(1.0)))) * 8.0 - 2.0;\n\t\n\tfloat inner = beam(innercoord);\n\t\n\tfloat outers0 = beamShadow(outercoord.y);\n\t\n\tfloat outerm0 = beam(outercoord.y);\n\t\n\tfloat g = pow(clamp((-o.y - 0.5) * 2.0, 0.0, 1.0), 2.0);\n\t\n\tfloat stain = (smoothstep(0.95, 1.0, fbm3(mod(o, vec3(5.0)) * 4.0) + 0.8 + g + fbm3(mod(o, vec3(5.0)) * 16.0) * 0.6));\n\t\n\tvec3 innercol = stone(vec2(p.x, p.y) * 2.0) * 0.76;\n\tvec3 outer0col = stone(p.yx * vec2(4.0, 1.4)) * vec3(1.0, 1.0, 0.9);\n\t\n\tvec3 col = mix(innercol, outer0col, outerm0);\n\t\n\tfloat fray = smoothstep(0.0, 0.5, stain) - smoothstep(0.5, 1.0, stain);\n\t\n\treturn vec3(fray) * 0.2 * (1.0 - outerm0) + (inner * (1.0 - outers0) + outerm0) * col * f *\n\t\tmix(vec3(1.0), vec3(0.5, 0.4, 0.3), 0.5 * stain * (1.0 - outerm0));\n}\n\n\n\nvec2 cubeProject(vec3 v)\n{\n\tvec3 av = abs(v);\n\t\n\tif(av.x > av.y && av.x > av.z)\n\t\treturn v.yz / av.x;\n\telse if(av.y > av.x && av.y > av.z)\n\t\treturn v.xz / av.y;\n\t\telse\n\t\t\treturn v.xy / av.z;   \n\t\t}\n\nbool gridSolidity0(vec3 rp)\n{\n\tif(rp.x < 1.0 && rp.y < -2.0)\n\t\treturn true;\n\t\t\n\tvec2 wc = fract(rp.xy * 0.4);\n\t\n\tfloat wires = pulse(-0.17, -0.1, 3.6 - sin(wc.x * 3.14159 * 2.0 + rp.z * 123.0) - wc.y * 4.0);\n\t\n\twires += pulse(-0.3, -0.1, 11.4 - sin(wc.x * 3.14159 * 2.0 + rp.z * 23.0) - wc.y * 16.0);\n\t\n\treturn (length(floor(rp.xy)) > 3.0) ||\n\t\t((wires * step(fract(rp.z), 1e-3) * step(1.0, rp.y)) > 0.0);\n}\n\nbool traverseUniformGridStep(vec3 ro, vec3 rd, vec3 increment, inout vec3 intersection, out float t)\n{\n\tt = min(intersection.x, min(intersection.y, intersection.z));\n\tvec3 rp = ro + rd * t;\n\t\n\tintersection += increment * step(intersection.xyz, intersection.yxy) *\n\t\tstep(intersection.xyz, intersection.zzx);\n\t\n\treturn gridSolidity1(rp) || gridSolidity0(rp);\n}\n\nfloat traverseUniformGrid(vec3 ro, vec3 rd)\n{\n\tro *= 2.0;\n\trd *= 2.0;\n\t\n\tvec3 increment = vec3(1.0) / rd;\n\tvec3 intersection = ((floor(ro) + round(rd * 0.5 + vec3(0.5))) - ro) * increment;\n\tfloat t;\n\t\n\tincrement = abs(increment);\n\tro += rd * 1e-3;\n\t\n\tif(traverseUniformGridStep(ro, rd, increment, intersection, t))\n\t\treturn t;\n\t\n\tif(traverseUniformGridStep(ro, rd, increment, intersection, t))\n\t\treturn t;\n\t\n\tif(traverseUniformGridStep(ro, rd, increment, intersection, t))\n\t\treturn t;\n\t\n\tif(traverseUniformGridStep(ro, rd, increment, intersection, t))\n\t\treturn t;\n\t\n\tif(traverseUniformGridStep(ro, rd, increment, intersection, t))\n\t\treturn t;\n\t\n\tif(traverseUniformGridStep(ro, rd, increment, intersection, t))\n\t\treturn t;\n\t\n\tif(traverseUniformGridStep(ro, rd, increment, intersection, t))\n\t\treturn t;\n\t\n\tif(traverseUniformGridStep(ro, rd, increment, intersection, t))\n\t\treturn t;\n\t\n\tif(traverseUniformGridStep(ro, rd, increment, intersection, t))\n\t\treturn t;\n\t\n\tif(traverseUniformGridStep(ro, rd, increment, intersection, t))\n\t\treturn t;\n\t\n\tif(traverseUniformGridStep(ro, rd, increment, intersection, t))\n\t\treturn t;\n\t\n\t\n\treturn 1e4;\n}\n\n\nfloat torchFlicker()\n{\n\treturn 1.0 - 0.3 * pulse(0.0, 0.4, fract(time * 0.2)) * pulse(0.4, 0.5, fract(time * 6.0)) +\n\t\tpulse(0.1, 0.12, fract(time * 0.12));\n}\n\nfloat torchOn()\n{\n\treturn smoothstep(0.0, 0.2, time - 4.0);\n}\n\nfloat torch(vec3 cp, vec3 cv, vec3 cw, vec3 rp, float nearest, out vec3 torch_o, out vec3 torch_d)\n{\n\ttorch_o = cp + cv;\n\ttorch_d = cw;\n\t\n\tfloat d = dot(normalize(rp - torch_o), -torch_d);\n\t\n\tfloat sparkles = 1.2 + 0.7 * smoothstep(0.95, 1.0, smN2(t.xy * 50.0 + vec2(time * 10.0 + cos(t.y * 10.0 + time * 0.3) * 2.0, sin(t.x * 10.0 + time * 0.3) * 2.0)));\n\tsparkles += 0.2 * smoothstep(0.95, 1.0, smN2(t.xy * 20.0 + vec2(time * 10.0 + cos(t.y * 10.0 + time * 0.3), sin(t.x * 10.0 + time * 0.3))));\n\t\n\treturn torchOn() * sparkles * torchFlicker() * 0.5 * (smoothstep(0.9, 1.0, d) * 2.0 + smoothstep(0.7, 1.0, d) * 0.3 + smoothstep(0.88, 0.88 + nearest * 0.02, d)) / distance(rp, cp);\n}\n\nfloat look(float x)\n{\n\tfloat c = floor(x);\n\treturn smoothstep(0.5, 1.0, 1.0 - abs(fract(x) - 0.5) * 2.0) * step(0.2, cos(mod(c, 20.0) * 3.0));\n}\n\n\nvec2 torchInterval(vec3 ro, vec3 rd, vec3 torch_o, vec3 torch_d)\n{\n\tvec3 w = normalize(torch_d);\n\tvec3 u = normalize(cross(w, vec3(0.0, 1.0, 0.0)));\n\tvec3 v = normalize(cross(w, u));\n\t\n\tvec3 scale = vec3(0.03, 0.03, 0.2);\n\t\n\trd = (transpose(mat3(u, v, w)) * rd) / scale;\n\tro = (transpose(mat3(u, v, w)) * (ro - torch_o)) / scale;\n\t\n\treturn cubeInterval(ro, rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tt = uv * 2.0 - vec2(1.0);\n\tt.x *= iResolution.x / iResolution.y;\n\ttime = iTime;\n\t\n\tvec3 cp = vec3(0.3, -0.7 + pow(0.5 + 0.5 * cos(time * 10.0), 0.7) * 0.01, time * 0.2);\n\t\n\tvec3 cl;\n\t\n\tcl = vec3(cp.x - 3.0, cp.y + 2.5, floor(cp.z / 4.0) * 4.0 + 2.0) - cp;\n\t\n\tcl = mix(vec3(0.0, 0.0, 1.0), cl, look(cp.z / 4.0));\n\t\n\tvec3 ct = cp + rotateY(cos(time * 0.2) * 0.3 + sin(time * 3.0) * 0.02,\n\t\t\t\t\t\t   rotateX((0.5 + 0.5 * sin(time * 0.3)) * 0.2, -cl));\n\tvec3 cw = normalize(ct - cp);\n\tvec3 cu = normalize(cross(cw, vec3(0.0, 1.0, 0.0)));\n\tvec3 cv = normalize(cross(cu, cw));\n\t\n\tmat3 rm = mat3(cu, cv, cw);\n\t\n\tvec3 ro = cp, rd = rm * vec3(t.xy * 0.3, -0.25);\n\t\n\tfloat t = traverseUniformGrid(ro, rd);\n\t\n\tvec3 rp = ro + rd * t;\n\tvec2 cc = cubeProject(rp * 2.0 - (floor(rp * 2.0) + vec3(0.5))); \n\t\n\tvec3 col0 = wall(rp, cc);\n\tvec3 col1 = crate(rp, cc);\n\t\n\tfloat order = gridSolidity0(rp * 2.0 + rd * 1e-3) ? 0.0 : 1.0;\n\t\n\tfloat nearest = t;\n\t\n\tvec3 l = vec3(0.01) + vec3(pow(1.0 - smoothstep(0.04, (2.0 - rp.y) * 0.15, distance(fract(rp.xz  * 0.6 + vec2(0.0)), vec2(0.5))), 2.0) *\n\t\t\t\t\t\t\t   1.0 * clamp(1.0-rp.y, 0.0, 1.0));\n\t\n\tvec3 torch_o, torch_d;\n\t\n\tvec3 ttilt = rm * vec3(-(iMouse.x - iResolution.x / 2.0) / iResolution.x,\n\t\t\t\t\t  -(iMouse.y - iResolution.y / 2.0) / iResolution.y * 0.5, 0.0);\n\t\n\n\tl += 0.8 * vec3(1.1, 1.1, 0.8) *\n\t\ttorch(cp, cv * -0.2 + cu * 0.1, rotateY(cos(time * 2.0) * 0.03, normalize(cw + cu * -0.2 + ttilt)), rp, nearest, torch_o, torch_d);\n\t\n\tvec2 ti = torchInterval(ro, rd, torch_o, torch_d);\n\tfloat thit = step(ti.x, ti.y) * step(0.0, ti.x);\n\t\n\tfloat tdd = distance(torch_o, ro + rd * ti.x) + 0.5;\n\t\n\tvec3 col = mix(col0, col1, order) * mix(vec3(0.02, 0.03, 0.1) * (3.0 - rp.y) * 0.2, vec3(1.2, 1.2, 1.0), l);\n\tvec3 fog = vec3(0.2, 0.25, 0.2) * 0.8;\n\t\n\tfloat v = 1.0 - pow(distance(uv, vec2(0.5)), 2.0) * 0.5;\n\t\n\tfragColor.rgb = 1.5 * mix(fog, col, exp(-nearest * nearest * 0.1)) * v;\n\t\n\tfragColor.rgb = mix(fragColor.rgb, vec3(1.0, 1.0, 0.9) * (clamp(tdd * 0.3, 0.0, 1.0) +\n\t\t\t\t\ttorchFlicker() * torchOn() * pow(clamp(tdd - 0.2, 0.0, 1.0) * 2.0, 30.0)), thit);\n\t\n\tfragColor.rgb *= 1.2;\n\t\n\tfragColor.rgb += vec3(N(fragCoord.xy) * 0.005);\n\tfragColor.a = 1.0;\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4slGz7","date":"1366228910","viewed":3758,"name":"Old Warehouse","username":"fizzer","description":"I tried to create the feeling of walking through an old warehouse full of crates. Unfortunately I ran up against what I think is an instruction-count limit. I'm sharing anyway this because I think the procedural crate texture turned out okay. Use mouse!","likes":73,"published":1,"flags":0,"usePreview":0,"tags":["procedural","foggy","uniformgrid","flashlight"],"hasliked":0,"parentid":"","parentname":""}}