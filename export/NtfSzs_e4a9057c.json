{"ver":"0.1","info":{"id":"NtfSzs","date":"1628958110","viewed":86,"name":"Distance-aided Raymarching","username":"lerping","description":"Morphing volumetric shapes, with ambient occlusion, using \"distance-aided\" raymarchig.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int steps = 55;\n\nfloat magnitude(vec3 a)\n{\n    return sqrt(a.x*a.x + a.y*a.y + a.z*a.z);\n}\n\nvec3 normalized(vec3 a)\n{\n    return a/length(a);\n}\n\nfloat sdfUnion(float sdf1, float sdf2)\n{\n    return min(sdf1, sdf2);\n}\n\n// Polynomial smooth min - https://iquilezles.org/articles/smin && Media Molecule\nfloat sdfSmoothUnion(float sdf1, float sdf2, float k)\n{\n    float h = max( k-abs(sdf1-sdf2), 0.0 )/k;\n    return min( sdf1, sdf2 ) - h*h*k*(1.0/4.0);\n}\n\nfloat sdfSphere(vec3 origin, vec3 center, float radius)\n{\n    // if distance from origin to center, is bigger than radius, return positive value\n    // if distance from origin to center, is smaller/equal to radius, return negative value  \n    return (magnitude(center-origin) - radius);\n}\n\n\nfloat rayMarch(vec3 origin, vec3[2] center, float radius, vec3 viewDir, vec3 lightPos, float specExpo, inout float diff, inout float spec, inout float ao)\n{   \n    float sdf;\n\n    for(int i=0; i<steps; i++)\n    {\n        float sdf1 = sdfSphere(origin, center[0], radius);\n        float sdf2 = sdfSphere(origin, center[1], radius);        \n        float sdf = sdfSmoothUnion(sdf1, sdf2, 0.75);\n        \n        origin += sdf * viewDir;        \n        \n        if ( sdf < 0.001 ) \n        {\n        // return 0 if center0 is closer than center1\n        // return 1 if center0 is distant than center1\n        float a =  min(1.0, floor(magnitude(center[0]-origin) / magnitude(center[1]-origin)) );\n        vec3 nearestCenter = a * center[1] + (1.0-a) * center[0];\n\n        vec3 normal = normalized(origin - nearestCenter);\n        vec3 lightDir = normalized(lightPos - origin);\n        // dot product will return negative value is vectors pointing in opposite directions.\n        // make sure result >= 0\n        diff = max(0.0, dot(normal, lightDir));\n\n        vec3 reflectDir = reflect(-lightDir, normal);\n        spec = pow(max(0.0, dot(-viewDir, reflectDir)), specExpo);\n\n        ao =  (float(i) / float(steps));\n        return 1.0;\n        }\n    }   \n    return 0.0;\n}\n\nvec3[] _center = vec3[]\n( \n    vec3(-1.1, 0.0, 5.0), \n    vec3( 1.1, 0.0, 5.0)\n);\n    \nfloat _radius = 1.0;\n\nvec3 _matAmbient = vec3(1.0, 1.0, 1.0);\nvec3 _matDiffuse = vec3(0.5, 0.5, 0.5);\nvec3 _matSpecular = vec3(1.0, 1.0, 1.0);\n\nvec3 _lightPos = vec3(0.0, 10.0, 0.0);\n\nvec3 _lightColor = vec3(1.0, 1.0, 1.0);\nfloat _lightAmbient = 0.2;\nfloat _lightDiffuse = 0.75;\nfloat _lightSpecular = 1.0;\nfloat _lightSpecularExpo = 32.0;\n\nmat4 rotZ(float angle)\n{\n    mat4 rotMatrix = mat4(\n        vec4( cos(angle), sin(angle), 0.0, 0.0),\n        vec4(-sin(angle), cos(angle), 0.0, 0.0),\n        vec4(        0.0,        0.0, 1.0, 0.0),\n        vec4(        0.0,        0.0, 0.0, 1.0)\n    );\n    \n    return rotMatrix; \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //_radius = mix(0.5, 2.0, abs(sin(iTime)));\n    _lightPos.z = mix(0.0, 10.0, sin(iTime*.5));\n    \n    _center[0].x -=  .2 * sin(iTime*.25);\n    _center[1].x +=  .2 * sin(iTime*.25);   \n           \n       \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 nfc = 2.0 * uv - 1.0;\n   \n    // fragment and camera world-space position\n    vec3 fragPos = vec3(nfc.x, nfc.y, 0.0) * vec3((iResolution.x/iResolution.y),1.0,1.0);\n    vec3 camPos = vec3(0.0, 0.0, -5.0);\n    \n    vec3 viewDir = normalized(fragPos - camPos);\n    \n    float diff;\n    float spec;\n    float ao;\n    float test = rayMarch(camPos, _center, _radius, viewDir, _lightPos, _lightSpecularExpo, diff, spec, ao);\n                                \n    vec3 ambient = (_lightAmbient * _lightColor) * _matAmbient;\n    vec3 diffuse = (_lightDiffuse * _lightColor) * (_matDiffuse * diff);\n    vec3 specular = (_lightSpecular * _lightColor) * (_matSpecular * spec);\n\n    //float edge = (ao*ao)*(3.0-2.0*ao);\n    \n    vec3 bg = vec3(0.3,0.3,0.3);\n     \n    vec3 col = ambient + diffuse + specular;\n    col = mix(bg, col*(1.0-ao), test);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}