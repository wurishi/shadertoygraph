{"ver":"0.1","info":{"id":"fsjfRV","date":"1677440196","viewed":41,"name":"Exercise 2.9 - Shadow","username":"marcpages2020","description":"shadow","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["shadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Sphere\n{\n vec3 position;\n float radius;\n};\n\nstruct Hit\n{\n  vec3 point;\n  vec3 normal;\n  int objectId;\n};\n\n//Global Variables ===================================================\nvec3 cameraPosition = vec3(0.0f, 0.0f, 5.0f);\nfloat planeYPosition = -0.5f;\nSphere spheres[3];\nvec3 lightPosition = vec3(0.5f, 1.0f, 0.5f);\nvec3 lightDirection = vec3(1.0); \n//=====================================================================\n\nvec3 rayDirection (in vec2 fragCoord, in vec3 origin)\n{\n  vec3 nearCoord = vec3(2.0 * fragCoord / iResolution.xy - 1.0, 0.0);\n  nearCoord.x *= iResolution.x / iResolution.y;\n  vec3 d = normalize(nearCoord - origin);\n  return d;\n}\n\nbool CastRay(vec3 origin, vec3 direction, inout Hit hit, int ignoreObjectId)\n{ \n  float pt = (planeYPosition - origin.y) / direction.y;\n  vec3 planeIntersectionPoint = origin + direction * pt;  \n  float closestDistance = 1000000000000.0f;\n  hit.objectId = -1;\n  \n  bool hitSomething = false;\n  if(pt > 0.0f)\n  {\n    hitSomething = true;\n    hit.point = planeIntersectionPoint;\n  }\n  \n  for(int i = 0; i < 3; ++i)\n  {\n    if(i == ignoreObjectId)\n    {\n       continue;\n    }\n    \n    float proj = dot(spheres[i].position - origin, direction);\n    vec3 k = origin + direction * proj; \n\n    float l1 = length(spheres[i].position - k);\n    float l2 = sqrt(spheres[i].radius * spheres[i].radius - l1 * l1);\n    \n    float t = proj - l2;\n    \n    vec3 P = origin + direction * t;\n    \n    float sphereIntersection = step(l1, spheres[i].radius);\n    vec3 normals = normalize(P - spheres[i].position);\n    \n    float distance = length(spheres[i].position + normals - cameraPosition);\n    if(l1 < spheres[i].radius && distance < closestDistance && t > 0.0f)\n    { \n      closestDistance = distance;\n      hit.objectId = i;\n      hit.point = P;\n      hit.normal = normals;\n      hitSomething = true;\n    }   \n  }\n  \n  return hitSomething;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    uv.x -= 0.5;\n    \n    //Sphere setting\n    float sphereRadius = 0.5f;\n    spheres[0] = Sphere(vec3(-0.8f, 0.0f, 0.2f), sphereRadius);\n    spheres[1] = Sphere(vec3(0.0f, 0.0f, -0.5f), sphereRadius);\n    spheres[2] = Sphere(vec3(0.8f, 0.0f, 0.0f), sphereRadius);\n    \n    //Camera setting\n    vec2 col = uv * 2.0f - 1.0f;\n    vec3 direction = normalize(rayDirection(fragCoord, cameraPosition));\n    \n    //Sky setting\n    vec3 skyColor = vec3(0.65, 0.7, 0.8);\n    skyColor = mix(skyColor, vec3(1.0f), -direction.y);      \n    \n    vec3 color = skyColor;\n    \n    vec3 floorColor = vec3(0.65f);\n    \n    Hit hit;\n    if(CastRay(cameraPosition, direction, hit, -2))\n    {\n      if(hit.objectId == -1)\n      {\n       color = floorColor;\n      }\n      else\n      {\n        color = vec3(dot(hit.normal, lightDirection));\n      }\n    }\n    \n    if(CastRay(hit.point, normalize(lightDirection), hit, hit.objectId))\n    {\n      color = vec3(0.0f);\n    }\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}