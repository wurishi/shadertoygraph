{"ver":"0.1","info":{"id":"Mdscz4","date":"1487318096","viewed":231,"name":"Douglas Wheeler Blue Neon","username":"SalikSyed","description":"a shader in the light style of douglas wheeler","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["light"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PADDING_X (0.1 * iResolution.x)\n#define PADDING_Y PADDING_X\n\n#define PADDING_X (0.1 * iResolution.x)\n#define PADDING_Y PADDING_X\n\nfloat compute_projected_point_alpha(vec2 start, vec2 end, vec2 pt) {\n    bool isValid = false;\n\n    vec2 r = vec2(0.0, 0.0);\n    if (start.x == end.x && start.y == end.y) start.x -= 0.00001;\n\n    float U = ((pt.x - start.x) * (end.x - start.x)) + ((pt.y - start.y) * (end.y - start.y));\n\n    float Udenom = pow(end.x - start.x, 2.0) + pow(end.y - start.y, 2.0);\n\n    U /= Udenom;\n\n    r.x = start.x + (U * (end.x - start.x));\n    r.y = start.y + (U * (end.y - start.y));\n\n    float minx, maxx, miny, maxy;\n\n    minx = min(start.x, end.x);\n    maxx = max(start.x, end.x);\n\n    miny = min(start.y, end.y);\n    maxy = max(start.y, end.y);\n\n    isValid = (r.x >= minx && r.x <= maxx) && (r.y >= miny && r.y <= maxy);\n\n    if (isValid) {\n    \treturn length(start-r) / length (start - end);\n    } else {\n    \treturn -1.0;\n    }\n}\n\n\n    float compute_light_from_segment_appx(vec2 start, vec2 end, vec2 pt) {\n    float t = compute_projected_point_alpha(start, end, pt);\n    if (t < 0.0) {\n     \treturn 0.0;\n    } else if (t >=1.0) {\n        return 0.0;\n    } else {\n\n        vec2 pt_on_line = t * start + (1.0 - t) * end;\n        float alpha = length(start - pt_on_line) / length(start-end);\n        float d1 =  100.0 / pow(length(start - pt), 1.2);\n        float d2 = 100.0 / pow(length(end - pt), 1.2);\n        return alpha * d1 + (1.0 - alpha) * d2;\n    }\n}  \n\n\nfloat compute_light_from_segment(vec2 start, vec2 end, vec2 pt) {\n    float sum = 0.0;\n    for(int i  = 0; i <= 100; i++) {\n     \tfloat alpha = float(i) / 100.0;\n        float d = length((alpha * start + (1.0 - alpha) * end) - pt);\n        sum += 2.0 / (pow(d, 1.44));\n    }\n    return sum;\n}    \n\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    \n    vec2 outerMin = vec2(PADDING_X, PADDING_Y);\n    vec2 outerMax = vec2(250, 250);\n\n   \tfloat d = 0.0;\n    float sz = 1.3;\n    for(int i = 0; i < 5; i++) {\n        \t// compute the light contribution from each fluorescent segment\n            d += compute_light_from_segment(outerMin - vec2(sz, 0.0), vec2(outerMin.x, outerMax.y)  - vec2(sz, 0.0), pos);\n            d += compute_light_from_segment(vec2(outerMax.x, outerMin.y) + vec2(0.0, -sz), outerMin + vec2(0.0, -sz), pos);\n  \t\t\td += compute_light_from_segment(vec2(outerMin.x, outerMax.y) + vec2(0.0, sz), outerMax+ vec2(0.0, sz), pos);\n            d += compute_light_from_segment(vec2(outerMax.x, outerMin.y)+ vec2(sz, 0.0), outerMax+ vec2(sz, 0.0), pos);\n            \n    }\n    \n    vec4 mixColor =  vec4(19.0/255.0, 98.0/255.0, 128.0/255.0, 1.0);\n    if (pos.x > outerMin.x && pos.x < outerMax.x && pos.y > outerMin.y && pos.y < outerMax.y) {\n        mixColor = vec4(14.0/255.0, 116.0/255.0, 132.0/255.0, 1.0);\n    }\n    \n    fragColor = mix(max(0.04, 0.1*sin(iTime*0.2))* d * mixColor, mixColor, 0.4);\n}","name":"Image","description":"","type":"image"}]}