{"ver":"0.1","info":{"id":"4dcGRN","date":"1682328526","viewed":83,"name":"Cubex","username":"Trakatranks","description":"¯\\_(ツ)_/¯","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define t iTime\n#define PI 3.1415\n\nfloat hash(float s){\n    return fract(sin(s)*42.53 + cos(s*131.01) * 4546.1);\n}\n\nfloat noise(float s, float f)\n{\n    return mix(hash(s), hash(s + 1.0), smoothstep(0.,1.,f));\n}\n\nmat2 Rotate(float a)\n{\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nfloat diffuse(vec3 normal, vec3 lightDir){\n  /*\n  return max(dot(normal, normalize(lightDir)), 0.0); //Classic calculation\n  /*/\n  return dot(normal, normalize(lightDir)) *.5 + .5; //Adjusted calculation wrapping around objects (simulates backlight)\n  //*/\n}\n\nfloat maxcomp(vec3 v)\n{\n    return max(v.x,max(v.y,v.z));\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat sdf_box(vec3 p, vec3 s, float r){\n    vec3 q = abs(p) - s;\n    return length(max(q, 0.0)) - min(maxcomp(q), 0.0) - r;\n}\n\nfloat sdf_plane(vec3 p, float h)\n{\n    return p.y - h;\n}\n\nfloat sdf_sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat map(vec3 pos)\n{\n    vec3 id = floor(pos);\n    vec3 uv = fract(pos);\n    \n    vec3 cp = pos;\n    cp = abs(cp);   \n    cp -= 0.5 + sin(t) * 4.;\n    cp.xy *= Rotate(t*.6);\n    cp.xz *= Rotate(t*.8);\n    \n    float box = sdf_box(cp, vec3(sin(t)+1.), 0.1);\n    float sphere = sdf_sphere(pos, 3.5);\n    \n    float res = smin(box, sphere, 1.0);\n    return res;\n}\n\nvec3 computeNormals(vec3 pos){\n    vec2 e = vec2(.001,.0);\n    vec3 normal = normalize(vec3(\n        map(pos + e.xyy) - map(pos - e.xyy),\n        map(pos + e.yxy) - map(pos - e.yxy),\n        map(pos + e.yyx) - map(pos - e.yyx)\n    ));\n    return normal;\n}\n\nvec3 march(vec3 pos, vec3 dir)\n{\n    vec3 lightpos = vec3(1.0,15.0,2.0);\n    vec3 color = vec3(0.0);\n    vec3 n = vec3(0.0);\n    float d = 0.0;\n    for(int i=0; i<150; i++)\n    {\n        float d = map(pos);\n        if(d < .01)\n        {\n            n = computeNormals(pos);\n            d = diffuse(n, vec3(15.,102.,12.));\n            color = vec3(d) * 1.-smoothstep(0.3,0.7,sin((pos.x * 10.)+sin(t*1.0)*20.));\n            break;\n        }\n        else{\n            color = mix(vec3(0.3,.0,.9),vec3(0.,.57,.89),dir.x);\n        }\n        pos += d * dir;\n    }\n    \n    return color;\n}\n\n#define campos    vec3(sin(t*.3) * 10.,10.,15.)\n#define camlookat vec3(0.0,0.0,0.0)\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 up = vec3(0.0,-1.0,.0);\n    \n    vec3 ray = normalize(camlookat - campos);\n\tvec3 cX  = normalize(cross(up,ray));\n\tvec3 cY  = normalize(cross(cX,ray));\n    vec3 rd  = normalize(vec3(ray+cX*uv.x+cY*uv.y));\n    \n    vec3 color = march(campos, rd);\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}