{"ver":"0.1","info":{"id":"7dlXzM","date":"1618900330","viewed":87,"name":"Game of Life Sandbox","username":"interstice","description":"Fork of clepirelli's GOL implementation, with wrapping, many-pixel blocks, discrete time-steps, and allowing editing while paused without movement. Click to add or remove sites. Block size and time-step size can be edited in 'Common'.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["test","private"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = pixelSize*floor(fragCoord/pixelSize) + 0.5;\n    fragColor = vec4(texture(iChannel0, uv / iResolution.xy).rgb, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 timeVec = texture(iChannel0, fragCoord);\n    \n    float prevTime = timeVec.x;\n    float timeDelta = iTime - prevTime;\n    float measuredTime = timeVec.z + timeDelta;\n    float measureCounter;\n    if (measuredTime > timeStep){\n        measuredTime = measuredTime - timeStep;\n        measureCounter = 1.0;\n    }\n    else{\n        \n        measureCounter = 0.0;\n    }\n    fragColor = vec4(iTime, timeDelta, measuredTime, measureCounter);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float pixelSize = 15.00;\nconst float timeStep = 0.0;","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    ivec2 grid_int = ivec2(floor(fragCoord/pixelSize));\n    ivec2 max_grid = ivec2(floor(iResolution.xy/pixelSize));\n    \n    //Start with single glider\n    if (iFrame == 0){\n        int center_x = max_grid.x/2;\n        int center_y = max_grid.y/2;\n        if ((grid_int.x == center_x && grid_int.y == center_y) ||\n            (grid_int.x == center_x && grid_int.y == center_y+1) ||\n            (grid_int.x == center_x && grid_int.y == center_y+2) ||\n            (grid_int.x == center_x-1 && grid_int.y == center_y) ||\n            (grid_int.x == center_x-2 && grid_int.y == center_y+1)){\n            fragColor = vec4(1.0,1.0,1.0,0.0);\n            return;\n        }\n        \n        else{\n            fragColor = vec4(0.0,0.0,0.0,0.0);\n            return;\n        }\n        \n    }\n    \n    vec2 uv = (vec2(grid_int) *pixelSize + 0.5)/iResolution.xy;\n    \n    vec2 pixel = vec2(1.0)/iResolution.xy;\n    pixel *= pixelSize;\n    \n    vec2 mouseUV = pixelSize*floor(iMouse.xy/pixelSize) + 0.5;\n    mouseUV /= iResolution.xy;\n    \n    bool written = (iMouse.z > 0.0) && (abs(uv.x - mouseUV.x) < pixel.x/2.0) && (abs(uv.y - mouseUV.y) < pixel.y/2.0);\n    \n    if(written)\n    {\n    \tfragColor = 1.0 - texture(iChannel0, uv);\n        return;\n    }\n    \n    float timeDiff = texture(iChannel1, uv).y;\n    float measureCounter = texture(iChannel1, uv).w;\n    \n    if(!(measureCounter > 0.0 && timeDiff > 0.0)){\n        fragColor = texture(iChannel0, uv);\n        return;\n    }\n    \n    bool alive = texture(iChannel0, uv).r >= 1.0;\n    int neighbors = 0;\n    \n    for(int i = -1; i <= 1; i++)\n    {\n        for(int j = -1; j<=1; j++)\n        {\n            bool thisPixel = (i== 0 && j == 0);\n            ivec2 neighbour_grid = (grid_int + ivec2(i, j) + max_grid)%max_grid; //% is not modulus\n            vec2 neighbour_uv = (vec2(neighbour_grid) * pixelSize + 0.5)/iResolution.xy;\n            neighbors += int(!thisPixel && \n               texture(iChannel0, neighbour_uv).r > .2);\n        }\n    }\n\n    alive = alive && !(neighbors <= 1 || neighbors > 3) || !alive &&  (neighbors == 3);\n\n                \n    fragColor = vec4(vec3(alive), 1.0f);\n}\n\n","name":"Buffer B","description":"","type":"buffer"}]}