{"ver":"0.1","info":{"id":"X3VGDh","date":"1718642335","viewed":93,"name":"Path tracing with reprojection","username":"gavrix32","description":"Path tracing","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["pathtracing","reprojection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 col = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    fragColor = vec4(post_process(col), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159\n#define MAX_DISTANCE 1e10\n#define BOUNCES 3\n#define SAMPLES 4\n#define FOV 90.0\n\nuint seed;\n\nstruct Ray {\n    vec3 ro, rd;\n};\n\nstruct Material {\n    vec3 color;\n    float emission, roughness;\n};\n\nstruct HitInfo {\n    Material material;\n    vec3 normal;\n    float min_dist;\n};\n\nfloat intersect_sphere(Ray ray, in vec3 pos, float radius) {\n    vec3 oc = ray.ro - pos;\n    float b = dot(oc, ray.rd);\n    float c = dot(oc, oc) - radius * radius;\n    float h = b * b - c;\n    if(h < 0.0) return -1.0;\n    return -b - sqrt(h);\n}\n\nfloat intersect_box(Ray ray, vec3 size, out vec3 normal) {\n    vec3 m = 1.0 / ray.rd;\n    vec3 n = m * ray.ro;\n    vec3 k = abs(m) * size;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if(tN > tF || tF < 0.0) return -1.0; // no intersection\n    normal = tN > 0.0 ? step(vec3(tN), t1) : step(t2, vec3(tF));\n    normal *= -sign(ray.rd);\n    return tN;\n}\n\nfloat intersect_plane(Ray ray, vec4 p) {\n    return -(dot(ray.ro, p.xyz) + p.w) / dot(ray.rd, p.xyz);\n}\n\n\nfloat checkerboard(vec2 p) {\n    return mod(floor(p.x) + floor(p.y), 2.0);\n}\n\nuint pcg_hash(uint seed) {\n    uint state = seed * 747796405u + 2891336453u;\n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    return (word >> 22u) ^ word;\n}\n\nfloat random() {\n    seed = pcg_hash(seed);\n    return float(seed) * (1. / 4294967296.0);\n}\n\nvec3 random_cosine_weighted_hemisphere(vec3 normal) {\n    float a = random() * 2. * PI;\n    float z = random() * 2. - 1.;\n    float r = sqrt(1. - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return normalize(normal + vec3(x, y, z));\n}\n\nvoid update_seed(float time, vec2 fragCoord) {\n    seed = pcg_hash(uint(fragCoord.x));\n    seed = pcg_hash(seed + uint(fragCoord.y));\n    seed = pcg_hash(seed + uint(time * 1000.));\n}\n\nbool raycast(vec2 uv, in Ray ray, out HitInfo hitInfo) {\n    float dist;\n    bool hit = false;\n    HitInfo info;\n    info.min_dist = MAX_DISTANCE;\n    dist = intersect_plane(ray, vec4(0.0, 1.0, 0.0, 1.0));\n    if (dist > 0.0 && dist < info.min_dist) {\n        info.min_dist = dist;\n        float cb = checkerboard(vec3(ray.ro + ray.rd * dist).xz);\n        info.normal = vec3(0.0, 1.0, 0.0);\n        info.material.color = cb != 0.0 ? vec3(1.0) : vec3(0.0);\n        info.material.emission = 0.0;\n        info.material.roughness = 1.0;       \n        hit = true;\n    }\n    vec3 sph_pos = vec3(0.0, 0.5, 7.0);\n    dist = intersect_sphere(ray, sph_pos, 1.5);\n    if (dist > 0.0 && dist < info.min_dist) {\n        info.min_dist = dist;\n        info.normal = ray.ro + ray.rd * dist - sph_pos;\n        info.material.color = vec3(1.0, 1.0, 1.0);\n        info.material.emission = 0.0;\n        info.material.roughness = 0.0;\n        hit = true;\n    }\n    vec3 normal;\n    dist = intersect_box(Ray(ray.ro - vec3(-5.0, 4.0, 5.0), ray.rd), vec3(0.0, 5.0, 5.0), normal);\n    if (dist > 0.0 && dist < info.min_dist) {\n        info.min_dist = dist;\n        info.normal = normal;\n        info.material.color = vec3(1.0, 0.0, 0.0);\n        info.material.emission = 0.0;\n        info.material.roughness = 1.0;\n        hit = true;\n    }\n    dist = intersect_box(Ray(ray.ro - vec3(5.0, 4.0, 5.0), ray.rd), vec3(0.0, 5.0, 5.0), normal);\n    if (dist > 0.0 && dist < info.min_dist) {\n        info.min_dist = dist;\n        info.normal = normal;\n        info.material.color = vec3(0.0, 1.0, 0.0);\n        info.material.emission = 0.0;\n        info.material.roughness = 1.0;\n        hit = true;\n    }\n    dist = intersect_box(Ray(ray.ro - vec3(0.0, 9.0, 5.0), ray.rd), vec3(5.0, 0.0, 5.0), normal);\n    if (dist > 0.0 && dist < info.min_dist) {\n        info.min_dist = dist;\n        info.normal = normal;\n        info.material.color = vec3(1.0, 1.0, 1.0);\n        info.material.emission = 0.0;\n        info.material.roughness = 1.0;\n        hit = true;\n    }\n    dist = intersect_box(Ray(ray.ro - vec3(0.0, 8.99, 5.0), ray.rd), vec3(2.0, 0.0, 2.0), normal);\n    if (dist > 0.0 && dist < info.min_dist) {\n        info.min_dist = dist;\n        info.normal = normal;\n        info.material.color = vec3(1.0, 1.0, 1.0);\n        info.material.emission = 10.0;\n        info.material.roughness = 1.0;\n        hit = true;\n    }\n    dist = intersect_box(Ray(ray.ro - vec3(0.0, 4.0, 10.0), ray.rd), vec3(5.0, 5.0, 0.0), normal);\n    if (dist > 0.0 && dist < info.min_dist) {\n        info.min_dist = dist;\n        info.normal = normal;\n        info.material.color = vec3(1.0, 1.0, 1.0);\n        info.material.emission = 0.0;\n        info.material.roughness = 1.0;\n        \n        hit = true;\n    }\n    dist = intersect_box(Ray(ray.ro - vec3(0.0, 4.0, 0.0), ray.rd), vec3(5.0, 5.0, 0.0), normal);\n    if (dist > 0.0 && dist < info.min_dist) {\n        info.min_dist = dist;\n        info.normal = normal;\n        info.material.color = vec3(1.0, 1.0, 1.0);\n        info.material.emission = 0.0;\n        info.material.roughness = 1.0;\n        \n        hit = true;\n    }\n    if (!hit) {\n        info.material.color = vec3(1.0);\n        info.material.emission = 0.0;\n        info.material.roughness = 1.0;\n        info.min_dist = MAX_DISTANCE;\n        hit = true;\n    }\n    hitInfo = info;\n    return hit;\n}\n\nvec2 uv2fragcoord(vec2 uv, vec2 resolution) {\n    return vec2((uv * resolution.y + resolution) / 2.);\n}\n\nvec2 reproject(vec3 prev_cam_pos, vec3 hitpos, vec2 resolution, float fov) {\n    float dist = distance(prev_cam_pos, hitpos);\n    vec3 dir = (hitpos - prev_cam_pos) / dist;\n    dir.xy /= fov;\n    dir.xy /= dir.z;\n    return uv2fragcoord(dir.xy, resolution);\n}\n\nvec3 post_process(vec3 col) {\n    col = vec3(1.0) - exp(-col);\n    col = pow(col, vec3(1.0 / 2.2));\n    return col;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"bool isKeyPressed(int key) {\n    return texelFetch(iChannel0, ivec2(key, 0), 0).x == 1.0;\n}\n\nfloat isTexel(vec2 coord, vec2 pos) {\n    vec2 d = abs(coord - pos - 0.5);\n    return 0.5 - max(d.x,d.y);\n}\n\nvec4 get(in vec2 position) {\n    vec2 uv = (position + 0.5) / iChannelResolution[0].xy;\n    return texture( iChannel1, uv, -256.0 );\n}\n\nvoid write(in vec4 value, in vec2 position, inout vec4 fragColor, in vec2 fragCoord) {\n    fragColor = ( isTexel(fragCoord,position ) > 0.0 ) ? value : fragColor;\n}\n\nconst int KEY_W = 87;\nconst int KEY_A = 65;\nconst int KEY_S = 83;\nconst int KEY_D = 68;\nconst int KEY_SPACE = 32;\nconst int KEY_SHIFT = 16;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 pos = get(vec2(0.0,0.0)).xyz;\n    if (iFrame == 0) pos = vec3(0.0, 4.0, 0.0);\n    vec3 prev_pos = pos;\n    if (isKeyPressed(KEY_W)) pos.z += 0.1;\n    if (isKeyPressed(KEY_A)) pos.x -= 0.1;\n    if (isKeyPressed(KEY_S)) pos.z -= 0.1;\n    if (isKeyPressed(KEY_D)) pos.x += 0.1;\n    if (isKeyPressed(KEY_SPACE)) pos.y += 0.1;\n    if (isKeyPressed(KEY_SHIFT)) pos.y -= 0.1;\n    //if (ivec2(fragCoord.xy) == ivec2(1, 0)) fragColor = vec4(pos, 1.0f);\n    //if (ivec2(fragCoord.xy) == ivec2(2, 0)) fragColor = vec4(prev_pos, 1.0f);\n    write(vec4(pos, 0.0), vec2(0.0, 0.0), fragColor, fragCoord);\n    write(vec4(prev_pos, 0.0), vec2(0.0, 1.0), fragColor, fragCoord);\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec3 trace(vec2 uv, in Ray ray) {\n    vec3 energy = vec3(1);\n    for (int i = 0; i <= BOUNCES; i++) {\n        HitInfo hitInfo;\n        if (raycast(uv, ray, hitInfo)) {\n            ray.ro += ray.rd * (hitInfo.min_dist - 0.001);\n            ray.rd = mix(reflect(ray.rd, hitInfo.normal), random_cosine_weighted_hemisphere(hitInfo.normal), hitInfo.material.roughness);\n            energy *= hitInfo.material.color;\n            if (hitInfo.material.emission > 0.0)\n                return energy * hitInfo.material.emission;\n        }\n    }\n    return vec3(0);\n}\n\nfloat isTexel(vec2 coord, vec2 pos) {\n    vec2 d = abs(coord - pos - 0.5);\n    return 0.5 - max(d.x,d.y);\n}\n\nvec4 get(in vec2 position) {\n    vec2 uv = (position + 0.5) / iChannelResolution[0].xy;\n    return texture( iChannel1, uv, -256.0 );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    update_seed(iTime, fragCoord);\n    vec3 out_color;\n    float fov_converted = tan(radians(FOV / 2.0));\n    Ray ray = Ray(get(vec2(0.0, 0.0)).xyz, normalize(vec3(uv * fov_converted, 1.0)));\n    HitInfo hitInfo;\n    for (int i = 0; i < SAMPLES; i++)\n        out_color += trace(uv, ray);\n    out_color /= float(SAMPLES);\n    \n    // reprojection\n    vec3 camera_position = get(vec2(0.0,0.0)).xyz;\n    vec3 old_camera_position = get(vec2(0.0,1.0)).xyz;\n    raycast(uv, Ray(camera_position, normalize(vec3(uv * fov_converted, 1.0))), hitInfo);\n    vec3 hitpos = camera_position+normalize(vec3(uv * fov_converted, 1.0))*hitInfo.min_dist;\n    vec2 rep = reproject(old_camera_position, hitpos, iResolution.xy, fov_converted);\n    vec3 prev_col = texture(iChannel0, rep / iResolution.xy).rgb;\n    out_color = mix(out_color, prev_col, 0.9);\n    fragColor = vec4(out_color, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}