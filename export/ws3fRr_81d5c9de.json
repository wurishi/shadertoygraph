{"ver":"0.1","info":{"id":"ws3fRr","date":"1604201348","viewed":50,"name":"Raymarch + phong illumination","username":"TheVanManCan","description":"Simplest example of raymarching, the plane on the y axis appears curved only because raymarching has a distance limit. Currently all ambiant and diffuse lights are based off of the same red coloring (including the lights) which needs to be updated","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_RAY_STEPS 200\n#define MAX_DISTANCE 200.0\n#define RAY_HIT_DISTANCE 0.005\n\nstruct sphere{\n    vec3 position;\n    vec3 color;\n    float radius;\n};\n\nstruct light{\n    vec3 intensity;\n    sphere s;\n};\n\nsphere centerObject = sphere(vec3(0,2,6), vec3(0.7, 0.3, 0.3), 1.0);\n\n\n#define NUM_LIGHT_SOURCE 2\nlight[2] GetLights(){\n    \n    sphere light1Sphere = sphere(vec3(6.5 * sin(iTime),\n                                      2.0, \n                                      6.5 * cos(iTime)),\n                                 vec3(0.3,0.3,.8),\n                                 0.5);\n    \n    light light1 = light(vec3(0.5), light1Sphere);\n    \n\n    sphere light2Sphere = sphere(vec3(3.0, 2.0, 3.0),\n                                 vec3(0.6, 0.6, 0.6),\n                                 0.3);\n    \n    light light2 = light(vec3(0.5), light2Sphere);\n\n    return light[2](light1, light2);\n}\n\nfloat SceneSDF(vec3 location) {\n    \n    //same as in main scene\n    light[2] lights = GetLights();\n    \n    float lightDist = min(length(location-lights[0].s.position) - lights[0].s.radius, length(location - lights[1].s.position) - lights[1].s.radius);\n    float sphereDist =  length(location-centerObject.position) - centerObject.radius;\n    float planeDist = location.y; //Asume ground is on y axis;\n    \n    float distance = min(sphereDist, planeDist);\n    distance = min(distance, lightDist);\n    return distance;\n}\n\nfloat RayMarch(vec3 rayOrigin, vec3 rayDirection){\n \tfloat originDistance = 0.0;\n    for(int i = 0; i < MAX_RAY_STEPS; i++){\n        vec3 currentLocation = rayOrigin + rayDirection*originDistance;\n        float sceneDistance = SceneSDF(currentLocation);\n        originDistance += sceneDistance;\n        if(sceneDistance < RAY_HIT_DISTANCE || originDistance > MAX_DISTANCE) break;\n    }\n    return originDistance;\n    \n}\n\n//estimate the normal by finding slope by sampling nearby points\nconst float EPSILON = 0.0001;\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        SceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - SceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        SceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - SceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        SceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - SceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    if (dotLN <= 0.0) {\n        //not visible\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    float dotRV = dot(R, V);\n    if (dotRV <= 0.0) {\n        // reflection opposite of the viewwer, only use diffuse\n        return lightIntensity * (k_d * dotLN);\n    }\n    \n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 phongIllumination(vec3 ambiantColor, vec3 diffuseColor, vec3 specularColor, float alpha, vec3 p, vec3 eye, vec3 lightPosition, vec3 lightIntensity) {\n    \n\tlight[2] lights = GetLights();\n    \n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * ambiantColor;\n \n    //objects\n    color += phongContribForLight(diffuseColor, specularColor, alpha, p, eye,\n                                  lightPosition,\n                                  lightIntensity);\n    \n    \n    //additional coloring to light sources\n    for(int i = 0; i < 2; i++){\n        if(length(p - lights[i].s.position) <= lights[i].s.radius+0.005){\n         \tcolor+= lights[i].s.color * lights[i].intensity;  \n        }\n    }\n     \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1) with screen dimensions taken into consideration\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 cameraOrigin = vec3(0, 5, -5);\n    vec3 cameraDirection = normalize(vec3(uv.x, uv.y-0.3, 1.0));\n\n\n    float distance = RayMarch(cameraOrigin, cameraDirection);\n   \n    vec3 position = cameraOrigin + cameraDirection*distance;\n    \n    vec3 ambiantColor = vec3(0.7, 0.3, 0.3);\n    vec3 diffuseColor = vec3(0.7, 0.3, 0.3);\n    float shininess = 5.0;\n    \n    light[2] lights = GetLights();\n    \n    vec3 col = vec3(0);\n    for(int i = 0; i < 2; i++){\n        col += phongIllumination(ambiantColor * lights[i].s.color, \n                                 diffuseColor * lights[i].s.color, \n                                 lights[i].s.color, \n                                 shininess, \n                                 position, \n                                 cameraOrigin, \n                                 lights[i].s.position, \n                                 lights[i].intensity);\n    }\n    \n    if(MAX_DISTANCE - distance < 0.1){\n     \tcol = vec3(0.0);   \n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n}","name":"Image","description":"","type":"image"}]}