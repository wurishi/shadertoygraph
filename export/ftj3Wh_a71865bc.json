{"ver":"0.1","info":{"id":"ftj3Wh","date":"1623945124","viewed":95,"name":"Raytracing: Class 6","username":"spr","description":"Our 9 spheres are _inside_ a large reflective sphere.\nClick and drag horizontally/vertically to move the outer large sphere in the x/z-direction.\n(The middle of the screen  (red sphere) is the neutral position; start from there!)","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"NtSGWR","parentname":"Class 6 BRDF II"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXX 10000000.0\n\nfloat seed = 0.0;\n\nstruct Material {\nvec3 baseColor;      \nfloat metallic;      \nfloat subsurface;    \nfloat specular;      \nfloat roughness;     \nfloat specularTint;  \nfloat anisotropic;   \nfloat sheen;         \nfloat sheenTint;     \nfloat clearcoat;     \nfloat clearcoatGloss;\n};\n// all the brdf code is from \n// https://github.com/wdas/brdf/blob/main/src/brdfs/disney.brdf\n// Thanks to Brent Burley and disneyanimation.com\nconst float PI = 3.14159265358979323846;\n\nfloat sqr(float x) { return x*x; }\n\nfloat SchlickFresnel(float u)\n{\n    float m = clamp(1.0-u, 0.0, 1.0);\n    float m2 = m*m;\n    return m2*m2*m; // pow(m,5)\n}\n\nfloat GTR1(float NdotH, float a)\n{\n    if (a >= 1.0) return 1.0/PI;\n    float a2 = a*a;\n    float t = 1.0 + (a2-1.0)*NdotH*NdotH;\n    return (a2-1.0) / (PI*log(a2)*t);\n}\n\nfloat GTR2(float NdotH, float a)\n{\n    float a2 = a*a;\n    float t = 1.0 + (a2-1.0)*NdotH*NdotH;\n    return a2 / (PI * t*t);\n}\n\nfloat GTR2_aniso(float NdotH, float HdotX, float HdotY, float ax, float ay)\n{\n    return 1.0 / (PI * ax*ay * sqr( sqr(HdotX/ax) + sqr(HdotY/ay) + NdotH*NdotH ));\n}\n\nfloat smithG_GGX(float NdotV, float alphaG)\n{\n    float a = alphaG*alphaG;\n    float b = NdotV*NdotV;\n    return 1.0 / (NdotV + sqrt(a + b - a*b));\n}\n\nfloat smithG_GGX_aniso(float NdotV, float VdotX, float VdotY, float ax, float ay)\n{\n    return 1.0 / (NdotV + sqrt( sqr(VdotX*ax) + sqr(VdotY*ay) + sqr(NdotV) ));\n}\n\nvec3 mon2lin(vec3 x)\n{\n    return vec3(pow(x[0], 2.2), pow(x[1], 2.2), pow(x[2], 2.2));\n}\n\n\nvec3 BRDF( vec3 L, vec3 V, vec3 N, vec3 X, vec3 Y, Material m)\n{\n    //float dot_nl \t= clamp(toLightTS.z, 0.0, 1.0);\n    //float dot_nv \t= clamp(toViewTS.z, 0.0, 1.0);\n    //float dot_nh\t= clamp(h_ts.z, 0.0, 1.0);\n    //float dot_lh \t= clamp(dot(toLightTS, h_ts), 0.0, 1.0); // same as dot(v_ts, h_ts)\n    ///float dot_ht\t= h_ts.x;\n    ///float dot_hb\t= h_ts.y;\n    \n    float NdotL = clamp(L.z, 0.0, 1.0); // dot(N,L);\n    float NdotV = clamp(V.z, 0.0, 1.0); // dot(N,V);\n    if (NdotL < 0.0 || NdotV < 0.0) return vec3(0.0, 0.0, 0.0);\n\n    vec3 H = normalize(L+V);\n    float NdotH = clamp(H.z, 0.0, 1.0); // dot(N,H);\n    float LdotH = clamp(dot(L, H), 0.0, 1.0); // dot(L,H);\n    \n    float HdotX = H.x;\n    float HdotY = H.y; \n    \n\n    vec3 Cdlin = mon2lin(m.baseColor);\n    Cdlin = m.baseColor;\n    float Cdlum = .3*Cdlin[0] + .6*Cdlin[1]  + .1*Cdlin[2]; // luminance approx.\n    vec3 Ctint = Cdlum > 0.0 ? Cdlin/Cdlum : vec3(1); // normalize lum. to isolate hue+sat\n    vec3 Cspec0 = mix(m.specular*.08*mix(vec3(1), Ctint, m.specularTint), Cdlin, m.metallic);\n    vec3 Csheen = mix(vec3(1), Ctint, m.sheenTint);\n\n    // Diffuse fresnel - go from 1 at normal incidence to .5 at grazing\n    // and mix in diffuse retro-reflection based on roughness\n    float FL = SchlickFresnel(NdotL), FV = SchlickFresnel(NdotV);\n    float Fd90 = 0.5 + 2.0 * LdotH*LdotH * m.roughness;\n    float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);\n    \n    float fd_90_minus_1 = 2.0 * LdotH * LdotH * m.roughness - 0.5;\n    \n    Fd  = (1.0 + fd_90_minus_1 * pow(1.0 - NdotL, 5.0))\n        * (1.0 + fd_90_minus_1 * pow(1.0 - NdotV, 5.0));\n\n\n    // Based on Hanrahan-Krueger brdf approximation of isotropic bssrdf\n    // 1.25 scale is used to (roughly) preserve albedo\n    // Fss90 used to \"flatten\" retroreflection based on roughness\n    float Fss90 = LdotH*LdotH*m.roughness;\n    float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);\n    float ss = 1.25 * (Fss * (1.0 / (NdotL + NdotV) - .5) + .5);\n\n    // specular\n    float aspect = sqrt(1.0-m.anisotropic*.9);\n    float ax = max(.001, sqr(m.roughness)/aspect);\n    float ay = max(.001, sqr(m.roughness)*aspect);\n    float Ds = GTR2_aniso(NdotH, HdotX, HdotY, ax, ay);\n    float FH = SchlickFresnel(LdotH);\n    vec3 Fs = mix(Cspec0, vec3(1), FH);\n    float Gs;\n    Gs  = smithG_GGX_aniso(NdotL, dot(L, X), dot(L, Y), ax, ay);\n    Gs *= smithG_GGX_aniso(NdotV, dot(V, X), dot(V, Y), ax, ay);\n    Gs = 1.0; \n    // sheen\n    vec3 Fsheen = FH * m.sheen * Csheen;\n\n    // clearcoat (ior = 1.5 -> F0 = 0.04)\n    float Dr = GTR1(NdotH, mix(.1,.001,m.clearcoatGloss));\n    float Fr = mix(.04, 1.0, FH);\n    float Gr = smithG_GGX(NdotL, .25) * smithG_GGX(NdotV, .25);\n    //return 1.0/PI * Fd*Cdlin * (1.0-m.metallic);\n    \n    return ((1.0/PI) * mix(Fd, ss, m.subsurface)*Cdlin + Fsheen)\n        * (1.0-m.metallic)\n        + Gs*Fs*Ds + .25*m.clearcoat*Gr*Fr*Dr;\n}\n\n\nvec3 bgColor(vec3 rayDir) {\n    float u =  0.5*(1.0 + rayDir[1]);\n    //return vec3(0.05, 0.05, 0.2);\n    return u*vec3(0.7, 0.8, 0.9) + (1.0-u)*vec3(0.05, 0.05, 0.2);\n}\n    \n// random number between 0 and 1\nfloat random() {\n    return fract(sin(seed++)*43758.5453123);\n}\n\n\n\n\n\n\n\nvec3 Rotate(in vec3 axis, in float angle, in vec3 v) \n{\n    return v*cos(angle) + cross(axis, v)* sin(angle) + axis*dot(axis, v)*(1.0-cos(angle));;\n}\n\n\n\n// a Light is defined by a location and a color\nstruct Light {\n    vec3 location;\n    vec3 color;\n    float radius;\n};\n\n// Sphere is defined by a center and radius and material: color\nstruct Sphere {\n\tfloat radius;\n\tvec3 center;\n    vec3 color;\n};\n\n// Ray is define by an origin point and a direction vector\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n \nstruct Intersection {\n    int obj;\n    float t;\n};\n\n\nconst int NUM_LIGHTS = 1;\nconst int NUM_SPHERE = 10;\nSphere spheres[NUM_SPHERE+NUM_LIGHTS];\nMaterial materials[NUM_SPHERE+NUM_LIGHTS];\nLight  lights[1];\n\nconst int special_sphere = NUM_SPHERE - 1;\nconst int light_sphere = NUM_SPHERE;\n\n// Intersection code for Ray-Sphere    \nfloat raySphereIntersect(in Ray ray, in Sphere sphere) {\n    \n    vec3 rayToSphere = ray.origin - sphere.center;\n    float b = dot(rayToSphere, ray.direction);\n    float c = dot(rayToSphere, rayToSphere) - (sphere.radius * sphere.radius);\n\tfloat disc = b*b - c;\n    float t;\n    if (disc > 0.0) {\n        t = -b - sqrt(disc);\n        if (t > 0.00001) {\n            return t;\n        }\n        t = -b + sqrt(disc);\n        if (t > 0.00001) {\n            return t;\n        }  \n    }\n    return MAXX;\n}\n\n\n// Checks if the Ray origin is inside the sphere, and returns time when it intersects boundary.\nfloat raySpecialSphereIntersect(in Ray ray, in Sphere sphere) {\n    vec3 rayToSphere = ray.origin - sphere.center;\n        \n    float dist_from_center = dot(rayToSphere, rayToSphere);\n    float radius_squared = sphere.radius * sphere.radius;\n    \n    if(dist_from_center <= radius_squared)\n        return sqrt( dist_from_center + radius_squared);\n    else\n        return MAXX;\n}\n\n// Traverses the entire scene and \n// returns the objectID and the intersection point\nIntersection intersectAllObjects(Ray ray, bool shadow) {\n    float minT = MAXX;\n    int iSphere = -1;\n    \n    for (int i=0; i < NUM_SPHERE+NUM_LIGHTS; i++) {\n       Sphere sphere = spheres[i];\n       \n       \n       float t=MAXX;\n       if(i==special_sphere)\n           {\n            if(!shadow)\n               t = raySpecialSphereIntersect(ray, sphere);\n           }\n       else {\n           if(!shadow || (i != light_sphere) )\n               t = raySphereIntersect(ray, sphere);\n       }\n       if (t < minT && t >= 0.001) {\n           // keep track of the closest sphere and intersection\n           iSphere = i;\n           minT = t;\n       }\n   }\n   \n   return Intersection(iSphere, minT);\n}\n \n// create 4 spheres at different locations in different colors\nvoid makeScene(int f, vec3 mouse_input) {\n    int count = 0;\n    float radius = 0.2;\n    float x = -0.5;\n    float y = -.5; \n    float z = -4.0;\n    // place 9 spheres in a grid with some separation\n    for (int i=0; i<3; i++) {\n        for (int j=0; j<3; j++) {\n            spheres[count] = Sphere(radius,vec3(x, y, z), vec3(0.0));\n            materials[count].baseColor = vec3(random(), random(), random());\n            x = x + (radius+0.3);\n            count++;\n        }\n        x = -0.5;  // reset x for the next row\n        z = z - (radius+0.5);\n        y = y + 0.3;\n    }\n    spheres[4].radius *= 1.5;\n    \n    // Sphere[NUM_SPHERE-1] is special. We are inside it.\n    \n    spheres[special_sphere] = Sphere(70.0, vec3(0, 0, -8.8)+mouse_input, vec3(1.0, 0.3, 0.3));\n   \n   \n    vec3 rotated_pos = Rotate(vec3(0,1,0), float(f)/80.-0.3, vec3(1.,0.,0.));    \n    vec3 light_pos = rotated_pos+vec3(0.0,.3,-3.6);\n    //vec3(x+.8-mod(float(f)/200.,2.), y-.5, z+5.- 2.*mod(float(f)/200.,2.5) );\n    vec3 light_col = vec3(1.);\n    float light_rad = 0.2;\n    lights[0] = Light(light_pos, light_col, light_rad);\n    spheres[light_sphere] = Sphere(light_rad*0.5,light_pos, light_col);\n\n\n\n    int l = 0;\n\n    materials[l].baseColor = vec3(0,1,0);\n    materials[l].metallic = 0.2; // .0; \n    materials[l].subsurface = 1.;\n    materials[l].specular = 0.2;\n    materials[l].roughness = 0.2;\n    materials[l].specularTint = 0.4;\n    materials[l].anisotropic = 0.3;\n    materials[l].sheen = 0.0;\n    materials[l].sheenTint = 0.3;\n    materials[l].clearcoat = 0.4;\n    materials[l].clearcoatGloss = 0.5;\n    \n    \n    l = 1;\n    \n    materials[l].baseColor = vec3(1.,.1,0.2);\n    materials[l].metallic = 0.0; // .0; \n    materials[l].subsurface = 0.0;\n    materials[l].specular = 0.4;\n    materials[l].roughness = 0.2;\n    materials[l].specularTint = 1.0;\n    materials[l].anisotropic = 0.7;\n    materials[l].sheen = 0.3;\n    materials[l].sheenTint = 0.0;\n    materials[l].clearcoat = 0.0;\n    materials[l].clearcoatGloss = 1.0;\n    \n    l = 2;\n    \n    materials[l].baseColor = vec3(0., 0.0, 1.0);\n    materials[l].metallic = .0; // .0; \n    materials[l].subsurface = 0.0;\n    materials[l].specular = 0.;\n    materials[l].roughness = 0.5;\n    materials[l].specularTint = 0.0;\n    materials[l].anisotropic = 0.4;\n    materials[l].sheen = 0.3;\n    materials[l].sheenTint = 0.0;\n    materials[l].clearcoat = 0.0;\n    materials[l].clearcoatGloss = 1.;\n    \n    l = 4;\n    \n    materials[l].baseColor = vec3(1., 0.0, 0.0);\n    materials[l].metallic = 0.0; // .0; \n    materials[l].subsurface = 0.5;\n    materials[l].specular = 0.0;\n    materials[l].roughness = 0.5;\n    materials[l].specularTint = 0.0;\n    materials[l].anisotropic = 0.0;\n    materials[l].sheen = 0.0;\n    materials[l].sheenTint = 0.0;\n    materials[l].clearcoat = 0.0;\n    materials[l].clearcoatGloss = 1.0;\n    \n    \n    l = 5;\n    \n    materials[l].baseColor = vec3(1., 1.0, 1.0);\n    materials[l].metallic = 0.0; // .0; \n    materials[l].subsurface = 0.0;\n    materials[l].specular = 0.0;\n    materials[l].roughness = 1.0;\n    materials[l].specularTint = 0.0;\n    materials[l].anisotropic = 0.0;\n    materials[l].sheen = 0.0;\n    materials[l].sheenTint = 0.0;\n    materials[l].clearcoat = 0.0;\n    materials[l].clearcoatGloss = 0.0;\n    \n    \n    l = 6;\n    \n    materials[l].baseColor = vec3(0.,1.,1);\n    materials[l].metallic = 0.8; // .0; \n    materials[l].subsurface = 0.0;\n    materials[l].specular = 1.;\n    materials[l].roughness = 0.2;\n    materials[l].specularTint = 1.0;\n    materials[l].anisotropic = 1.;\n    materials[l].sheen = 0.0;\n    materials[l].sheenTint = 0.0;\n    materials[l].clearcoat = 0.0;\n    materials[l].clearcoatGloss = 1.0;\n    \n    l = 8;\n    \n    materials[l].baseColor = vec3(0.,1.,0);\n    materials[l].metallic = 0.8; // .0; \n    materials[l].subsurface = 0.0;\n    materials[l].specular = 1.;\n    materials[l].roughness = 0.2;\n    materials[l].specularTint = 0.0;\n    materials[l].anisotropic = 0.0;\n    materials[l].sheen = 0.0;\n    materials[l].sheenTint = 0.0;\n    materials[l].clearcoat = 0.0;\n    materials[l].clearcoatGloss = 0.0;\n    \n    \n    \n    \n    //Outer sphere\n    l = 9;\n    \n    materials[l].baseColor = vec3(0., 0.0, 0.0);\n    materials[l].metallic = 1.; // .0; \n  \n}\n\n// samples per pixel\nconst int numSamples=10;\n\n// convert directionToLight and directionToView to tangent space\n//\nvoid convertToTangentSpace(vec3 toLight, vec3 toView, vec3 hitPoint, out vec3 toLightTS, out vec3 toViewTS, out vec3 nTS)\n{\n    // use a matrix to convert\n    vec3 t = normalize(dFdx(hitPoint));\n    vec3 b = normalize(dFdy(hitPoint));\n    vec3 n = normalize(cross(t, b));\n    mat3 xformMatrix = transpose(mat3(t, b, n));\n    \n    toLightTS = xformMatrix * toLight;\n    toViewTS = xformMatrix * toView;\n    nTS = n;\n}\n\nfloat checkLightVisibility(in Light light, vec3 hitPoint, vec3 hitNormal) {\n    float visible = 0.;\n    vec3 lightDir = normalize(light.location - hitPoint);\n    Ray ray;\n    ray.origin = hitPoint+lightDir*0.01;\n    ray.direction = lightDir;\n    Intersection intersection = intersectAllObjects(ray, true);\n    int iSphere = intersection.obj;\n    if (iSphere == -1 || iSphere == light_sphere) { \n        // no object was hit, light is visible\n        visible = 1.0;\n    } \n    return visible;\n}\n\n/* The main entry point:\n   * This is called for every pixel on the screen \n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   \n   float screenDepth = -2.0;\n   \n   float width = iResolution.x;\n   float height = iResolution.y; \n  \n   vec3 mouse_input = vec3( iMouse.z > 0. ? 4.*(iMouse.x/width - 0.5) : 0.,\n                            0.,\n                            iMouse.z > 0. ? 3.*(iMouse.y/height - 0.5) : 0.);\n   makeScene(iFrame, mouse_input);\n   \n   \n   \n\n   \n   vec3 samp = vec3(0, 0, 0);\n   seed = 0.0;\n   for (int i=0; i<numSamples; i++) {\n       float x = fragCoord.x + random() - 0.5;\n       float y = fragCoord.y + random() - 0.5;\n       \n   \n       // map (0.5, w-0.5) to (-1, 1)\n       // and (0.5, h-0.5) to (-1, 1)\n       x = (x/width)*2.0 - 1.0;\n       y = (y/height)*2.0 - 1.0;\n       \n       // account for the non-square window\n       float aspectRatio = width/height;\n       y = y/aspectRatio;\n              \n       \n       vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n       // normalized ray direction\n       vec3 rayDirection = normalize(vec3(x, y, screenDepth));\n       \n       Ray ray = Ray(rayOrigin, rayDirection);\n              \n       // traverse the scene (all spheres) and find the \n       // closest intersected object and intersection point\n       bool check_for_shadows = false;\n       Intersection intersection = intersectAllObjects(ray, check_for_shadows);\n       \n       int iSphere = intersection.obj;\n       float minT = intersection.t;\n       \n       if(iSphere == -1){\n           samp += bgColor(ray.direction);\n           continue;\n       }\n       \n       Sphere sphere = spheres[iSphere];\n       \n       \n       vec3 hit = ray.origin + minT*ray.direction;\n       vec3 hitPointNormal = normalize(hit-sphere.center);\n       if(iSphere == special_sphere) hitPointNormal *= -1.;\n\n        \n       //If we hit the special sphere, we keep bouncing;\n       int NUM_BOUNCES = 100;\n       //To have correct \"shadows\" in the outer sphere, we have to remember the first ray hit\n       bool first_hit_special_sphere = iSphere == special_sphere;\n       vec3 first_hit = hit;\n       vec3 first_normal = hitPointNormal;\n       \n       if(iSphere == special_sphere){\n           for(int k=0; k<NUM_BOUNCES; ++k){\n               vec3 reflDir = ray.direction - 2.0*hitPointNormal*dot(ray.direction, hitPointNormal);\n\n               ray.origin = hit;\n               ray.direction = reflDir;\n\n               intersection = intersectAllObjects(ray, false);\n               iSphere = intersection.obj;\n               if(iSphere == -1) break;\n               \n               minT = intersection.t;\n               sphere = spheres[iSphere];\n\n               hit = ray.origin + minT*ray.direction;\n               hitPointNormal = normalize(hit-sphere.center);\n\n               if(iSphere != special_sphere) break;\n               else hitPointNormal *= -1.;\n       }}\n       \n       if (iSphere > -1 && iSphere < NUM_SPHERE) { // if there is an intersection\n       \n           // to get around iSphere not being constant\n           /* for (int i=0; i<NUM_SPHERE+NUM_LIGHTS; i++) {\n               if (i==iSphere) {\n                   sphere = spheres[i];\n                   break;\n               }\n           }\n           */\n           \n\n           // vector from intersection to light\n           vec3 hitPointToLight = normalize(lights[0].location-hit);\n           vec3 hitPointToView = ray.origin-hit;\n           \n           vec3 toViewTS;\n           vec3 toLightTS;\n           vec3 nTS;\n           convertToTangentSpace(hitPointToLight, hitPointToView, hit, toLightTS, toViewTS, nTS); \n           vec3 h_ts \t\t= normalize(toLightTS + toViewTS);\n           float dot_nl \t= clamp(toLightTS.z, 0.0, 1.0);\n           float dot_nv \t= clamp(toViewTS.z, 0.0, 1.0);\n           float dot_nh\t= clamp(h_ts.z, 0.0, 1.0);\n           float dot_lh \t= clamp(dot(toLightTS, h_ts), 0.0, 1.0); // same as dot(v_ts, h_ts)\n           float dot_ht\t= h_ts.x;\n           float dot_hb\t= h_ts.y;\n           Material m = materials[iSphere];\n           vec3 wi;\n           float lightPdf;\n      \n           float lightVisible;\n           if(!first_hit_special_sphere)\n               lightVisible = checkLightVisibility(lights[0], hit, hitPointNormal);\n           else\n               lightVisible = checkLightVisibility(lights[0], first_hit, first_normal);\n\n           vec3 brdf = BRDF(toLightTS, toViewTS, nTS, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), m);\n          \n           vec3 col = brdf*dot_nl*lightVisible;\n           vec3 toneMappedColor = col * (1.0 / (col + 1.0));\n           float gamma = 1.0/2.2;\n           vec3 finalColor = vec3(pow(toneMappedColor.x, gamma), \n                                  pow(toneMappedColor.y, gamma), \n                                  pow(toneMappedColor.z, gamma));\n\n           samp += finalColor; \n       } \n       else if(iSphere == light_sphere) {\n           samp += lights[0].color;\n       }\n       else{\n           samp += bgColor(ray.direction);\n       }\n\n   }\n   // average all the samples per pixel\n   fragColor = vec4(samp/float(numSamples), 1.0);\n\n}","name":"Image","description":"","type":"image"}]}