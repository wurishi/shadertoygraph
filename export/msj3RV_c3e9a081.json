{"ver":"0.1","info":{"id":"msj3RV","date":"1668422420","viewed":27,"name":"SHADOW round","username":"Kattttt","description":"round round round","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["shadowcircle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592653589793\n\nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;   // hauteur du canevas\n    float W;   // largeur du canevas\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n   Camera C;\n   \n   vec3 view = normalize(LookAt - Obs);\n   vec3 horizon = normalize(cross(vec3(0,0,1), view));\n   vec3 up = normalize(cross(view, horizon));\n   \n   float ouverture = aperture*PI/180.0;\n   float z = iResolution.y/2.0 / tan(ouverture/2.0);\n   \n   C.Obs = Obs;\n   C.View = view;\n   C.Up = up;\n   C.Horiz = horizon;\n   C.H = iResolution.y;\n   C.W = iResolution.x;\n   C.z = z;\n   \n   return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   Ray r;\n   r.Origin = C.Obs;\n   r.Dir = C.z*C.View + (XY.x - C.W/2.0)*C.Horiz + (XY.y - C.H/2.0)*C.Up;\n   return r;\n}\n\nstruct Sphere {\n   vec3 Center;\n   float R;\n   vec3 col;\n};\n\n\nbool intersect_sphere(in Ray R, in Sphere S, out float t) {\n   float b = 2.0 * dot(R.Dir ,(R.Origin - S.Center));\n   float a = dot(R.Dir,R.Dir);\n   float c = dot(R.Origin - S.Center, R.Origin - S.Center) - S.R*S.R;\n   float delta =b*b - 4.0 *a*c;\n   if (delta > 0.0) {\n        t = (-b - sqrt(delta)) / (2.0*a);\n    }\n    return delta > 0.0;\n}\n\nstruct Lumiere {\n    vec3 Center;\n    vec3 col;\n    float I;\n};\n\nRay rayon_ombre(in vec3 coord,in Lumiere l) {\n    Ray r;\n    r.Dir =-normalize(coord - l.Center);\n    r.Origin = coord;\n    return r;\n}\n\n\nbool hasOmbreSphere(Ray r,Sphere s){\n     float t_ombre;\n     intersect_sphere(r, s, t_ombre);\n     if (t_ombre < 1.0 && t_ombre > 0.0){\n           return true;\n       }else{\n           return false;\n     }\n}\n\nvec3 getLumiereSphere(in vec3 coord, in Lumiere l, Sphere s) {\n    vec3 normale = normalize(coord- s.Center);\n    \n    vec3 incidence =  normalize(l.Center-coord);\n    float cTheta = dot(normale, incidence);\n    float intensite_resultante = l.I ;//* cTheta;\n    \n\n    return intensite_resultante * l.col * s.col * cTheta;\n\n}\n\n\nvec3 getLumiereTexture(in vec3 coord, in Lumiere l,Sphere s){\n\n    vec3 normale = normalize(coord- s.Center);\n    vec2 uv=vec2(normale.x,normale.y);\n    \n    vec3 incidence =  normalize(l.Center-coord);\n    float cTheta = dot(normale, incidence);\n    float intensite_resultante = l.I ;//* cTheta;\n    \n\n    return intensite_resultante * l.col * texture(iChannel0,uv).xyz * cTheta;\n}\n\n\n\nstruct Cylindre{\n    vec3 Center;\n    float h;\n    vec3 Dir;\n    float R;\n    vec3 col;\n    \n};\n\nbool intersect_cylindre(in Ray R, in Cylindre C, out float t, out float t2) {\n   vec3 x=R.Dir-dot(R.Dir,C.Dir)*C.Dir;\n   vec3 y=R.Origin - C.Center-dot(C.Dir,(R.Origin-C.Center))*C.Dir;\n   \n   float a = dot(x,x);\n   float b = 2.0 * dot(x,y);  \n   float c = dot(y,y) - C.R*C.R;\n   \n   float delta = b*b - 4.0 *a*c;\n   if (delta > 0.0) {\n        t = (-b - sqrt(delta)) / (2.0*a);\n        t2 = (-b + sqrt(delta)) / (2.0*a);\n    }\n    return delta > 0.0;\n}\n\nvec3 getLumiereCylindre(in vec3 coord, in Lumiere l, Cylindre c) {\n    vec3 Mprg=c.Center + dot(c.Dir,coord-c.Center)*c.Dir;\n    vec3 normale = normalize(coord - Mprg);\n    \n    vec3 incidence = normalize(l.Center-coord);\n    \n    float cTheta = dot(normale, incidence);\n    float intensite_resultante = l.I ;//* cTheta;\n    \n\n    return intensite_resultante * l.col * c.col * cTheta;\n\n}\n\n\nbool hasOmbreCylindre(Ray r,Cylindre c,vec3 Mprg){\n     float t_ombre;\n     float tround;\n     intersect_cylindre(r, c, t_ombre,tround);\n     if(length(Mprg-c.Center) <= c.h){\n         if (t_ombre < 1.0 && t_ombre > 0.0){\n               return true;\n           }else{\n               return false;\n         }\n     }\n}\n\n\nstruct Plan {\n    vec3 Op;\n    vec3 D1;\n    vec3 D2;\n    vec3 col;\n};\n\nbool intersect_plan(in Ray R, in Plan P, out float t, out float u, out float v) {   \n   vec3 dirN=normalize(cross(P.D1,P.D2));   \n   if(dot(R.Dir,dirN)!=0.0){\n       mat3 m = mat3(R.Dir, -P.D1, -P.D2);\n       vec3 o = (P.Op - R.Origin);\n       vec3 res=inverse(m)*o;\n       t=res[0];\n       u=res[1];\n       v=res[2];\n       return true;\n   }\n   return false;\n}\n\n\nvec3 getLumierePlan(in vec3 coord, in Lumiere l, Plan p) {\n    vec3 normale=normalize(cross(p.D1,p.D2)); \n    \n    \n    vec3 incidence =  normalize(l.Center-coord);\n    \n    if(dot(incidence,normale)< 0.0){\n        normale=-normale;\n    }//on inverse la normale si la normale est inversé par rapport a la caméra\n    \n    float cTheta = dot(normale, incidence);\n    float intensite_resultante = l.I ;//* cTheta;\n    \n    return intensite_resultante * l.col * p.col * cTheta;\n\n} \n\n\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \n   Camera C = camera(\n       vec3(2.0, 2.0, 1.0),\n       vec3(0.5, 0.5, 0.5),\n       50.0       \n   );\n   \n   vec2 uv= fragCoord.xy/iResolution.xy;\n   vec3 col = texture(iChannel1,uv).xyz;\n   Ray r = launch(C, fragCoord);\n   \n   vec3 centre = vec3(0, 0, 0);\n   vec3 centre2 = vec3(cos(iTime),sin(iTime), 0);\n   \n   \n   \n   Sphere s = Sphere(centre, 0.6, vec3(1,1,1));\n   Sphere s2 =  Sphere(vec3(cos(iTime*1.1),sin(iTime*1.1), 0.8), 0.2, vec3(1,0,1));\n   Sphere s3 = Sphere(vec3(sin(iTime), sin(iTime), 0), 0.3,vec3(0.5,0.8,0.5));\n   Sphere s4 = Sphere(vec3(sin(iTime), cos(iTime), 0), 0.4,vec3(0.9,0.8,0.5));\n   \n   Cylindre c= Cylindre(centre2, 0.4, vec3(0,1,0), 0.4, vec3(0.3,0.4,0.5));\n   Cylindre c2= Cylindre(vec3(0,0,0.7), 0.4, vec3(0,0,1), 0.4, vec3(1,1,1));\n   Cylindre c3= Cylindre(centre, 0.4, vec3(0,0,1), 0.4, vec3(0.3,0.4,0.5));\n   \n   float t = 1000.0;\n   float t1;\n   float t2;\n   float t3;\n   float t4;\n   float t5;\n   float t6;\n   float t7;\n   \n   Lumiere l = Lumiere(\n       vec3(5, 0, 3),\n       vec3(1,1,1),\n       1.0\n   );\n   \n   Plan p=Plan(vec3(-1,-1,-0.5),vec3(0,1,0),vec3(1,0,0),vec3(0.5,0.5,0.5));\n   float tp;\n   float up;\n   float vp;\n   \n   if (intersect_plan(r, p, tp,up,vp) && tp>0.0) {\n       t = tp;\n       vec3 coord = p.Op + up * p.D1 + vp * p.D2;    //ou r.Origin + tp * r.Dir;\n       vec3 Mprg=c.Center + dot(c.Dir,coord-c.Center)*c.Dir;\n       \n       Ray r_ombre = rayon_ombre(coord, l);\n       \n       if (hasOmbreSphere(r_ombre, s2)||hasOmbreSphere(r_ombre, s)||hasOmbreSphere(r_ombre, s3)||hasOmbreSphere(r_ombre, s4)||hasOmbreCylindre(r_ombre,c,Mprg)){\n           col = vec3(0,0,0);\n       }else{\n           col = getLumierePlan(coord, l, p);\n       }\n            \n   }\n   \n   \n   if (intersect_sphere(r, s, t1) && t1 < t) {\n       t = t1;\n       vec3 coord = r.Origin + t1 * r.Dir;\n       Ray r_ombre = rayon_ombre(coord, l);\n       \n       if (hasOmbreSphere(r_ombre, s2)||hasOmbreSphere(r_ombre, s3)||hasOmbreSphere(r_ombre, s4)){\n           col = vec3(0,0,0);\n       }else{\n           col = getLumiereTexture(coord, l, s);\n       }\n   }\n       \n   if (intersect_sphere(r, s2, t2) && t2 < t) {\n       t = t2;\n       vec3 coord = r.Origin + t2 * r.Dir;\n       Ray r_ombre = rayon_ombre(coord, l);\n     \n       if (hasOmbreSphere(r_ombre, s)||hasOmbreSphere(r_ombre, s3)||hasOmbreSphere(r_ombre, s4)){\n           col = vec3(0,0,0);\n       }else{\n           col = getLumiereSphere(coord, l, s2);\n       }\n   }\n       \n    if (intersect_sphere(r, s3, t3) && t3<t) {\n        t = t3;\n       vec3 coord = r.Origin + t3 * r.Dir;\n       Ray r_ombre = rayon_ombre(coord, l);\n     \n       if (hasOmbreSphere(r_ombre, s2)||hasOmbreSphere(r_ombre, s)||hasOmbreSphere(r_ombre, s4)){\n           col = vec3(0,0,0);\n       }else{\n           col = getLumiereSphere(coord, l, s3);\n       }\n   }\n   if (intersect_sphere(r, s4, t4)&&t4<t) {\n       t = t4;\n       vec3 coord = r.Origin + t4 * r.Dir;\n       Ray r_ombre = rayon_ombre(coord, l);\n     \n       if (hasOmbreSphere(r_ombre, s2)||hasOmbreSphere(r_ombre, s3)||hasOmbreSphere(r_ombre, s)){\n           col = vec3(0,0,0);\n       }else{\n           col = getLumiereSphere(coord, l, s4);\n       }\n       \n   }\n   \n   float tround;\n   if (intersect_cylindre(r, c, t5,tround)&&t5<t) {\n       t = t5;   \n       vec3 coord = r.Origin + t5 * r.Dir;\n       \n       vec3 coordRound=r.Origin + tround * r.Dir;\n       \n       Ray r_ombre = rayon_ombre(coord, l);\n       \n       vec3 Mprg=c.Center + dot(c.Dir,coord-c.Center)*c.Dir;\n       vec3 Mprg2=c.Center + dot(c.Dir,coordRound-c.Center)*c.Dir;\n       \n       if(length(Mprg-c.Center) <= c.h ){\n           if (hasOmbreSphere(r_ombre, s2)||hasOmbreSphere(r_ombre, s3)||hasOmbreSphere(r_ombre, s)){\n               col = vec3(0,0,0);\n           }else{\n               col = getLumiereCylindre(coord, l, c);\n           }\n           \n           \n       } else if(length(Mprg2-c.Center) <= c.h ){\n                   col = getLumiereCylindre(coordRound, l, c);\n           }\n       \n   }\n   \n   if (intersect_cylindre(r, c2, t6,tround)&&t6<t) {\n       t = t6;   \n       vec3 coord = r.Origin + t6 * r.Dir;\n       \n       vec3 coordRound=r.Origin + tround * r.Dir;\n       \n       Ray r_ombre = rayon_ombre(coord, l);\n       \n       vec3 Mprg=c2.Center + dot(c2.Dir,coord-c2.Center)*c2.Dir;\n       vec3 Mprg2=c2.Center + dot(c2.Dir,coordRound-c2.Center)*c2.Dir;\n       \n       if(length(Mprg-c2.Center) <= c2.h ){\n           if (hasOmbreSphere(r_ombre, s2)||hasOmbreSphere(r_ombre, s3)||hasOmbreSphere(r_ombre, s)){\n               col = vec3(0,0,0);\n           }else{\n               col = getLumiereCylindre(coord, l, c2);\n           }\n           \n           \n       } else if(length(Mprg2-c2.Center) <= c2.h ){\n                   col = getLumiereCylindre(coordRound, l, c2);\n           }\n       \n   }\n    \n    fragColor = vec4(col, 1.0);\n   \n}\n\n// scalaire : dot(v,w)\n// vectoriel : cross(v,w)\n// normalizer : normalize(v)\n// norme : length(v)\n// cos(a), sin(a), tan(a) en radian","name":"Image","description":"","type":"image"}]}