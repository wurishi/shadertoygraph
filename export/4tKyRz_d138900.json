{"ver":"0.1","info":{"id":"4tKyRz","date":"1544158878","viewed":721,"name":"A Tornado In A Box","username":"lgabriel13","description":"One of my first raymarching experiments.\nI know that it has a couple of problems and I hope I will be able to fix them at some point but for the moment that's what I have. Waiting for your help & feedback.","likes":35,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","raymarching","glass","box","tornado"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //maybe apply some post processing?\n\tvec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n        \n    \n\tfragColor = texture (iChannel0, fragCoord/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define EPSILON 0.0001\n\nstruct Ray\n{\n \tvec3 origin;\n    vec3 dir;\n};    \n\nfloat smin( float a, float b, float k, float matA, float matB, out float mat)\n{\n     mat = a < b ? matA : matB;\n    float h = max( k-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*0.25/k;\n}\n\nfloat Union (float a, float b, float matA, float matB, out float mat)\n{\n    mat = a < b ? matA : matB;\n    return min (a,b);\n}\n\n\nfloat TerrainSDF (vec3 p)\n{   \n    //I will need a box with offseted y\n   \tvec3 terrainP = abs(p + vec3 (0.0, 4., 0.0)) - vec3 (4., 0.1 + FBM (p.xz * 2.) * .2, 4.);\n  \tfloat terrainBox = min(max(terrainP.x,max(terrainP.y,terrainP.z)),0.0) + length(max(terrainP,0.0));\n    \n    return terrainBox;\n}\n\n\nfloat TornadoShape (vec3 q, float tornadoNoise, float heightOffset, float currentRadius, float baseRadius)\n{        \n    float height = 6.0;                    \n    \n    vec2 c = abs (vec2 (length (q.xz) - currentRadius, q.y)) - vec2 (baseRadius, height - heightOffset);// - FBM (spin_Point.xz * - 0.25));           \n    float tornadoShape =  vec2 (min (max (c.x, c.y), 0.0) + length (max (c, 0.0)), 0.0).x;\n    \n    return tornadoShape;\n}\n\nfloat CloudsShape (vec3 p, float xMovement, float zMovement)\n{          \n \tvec3 d = abs(p - vec3 (0.0, 3.0, 0.0)) - vec3 (4.,1., 4.);    \n  \tfloat shape = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n    \n    p.y /= pow (abs (length (p.xz)), .2) * 0.5;\n    float ellipse = length ((p-vec3 (0., 4., 0.))/vec3 (3.0, 2.0, 3.0)) - 1.0;\n    \n    float s;    \n    \n    return shape;\n}\n\nvec3 GetTerrainNormal(vec3 p )\n{\n   return normalize (vec3 (\n   \t\tTerrainSDF (vec3 (p + vec3 (EPSILON, 0.0, 0.0))) - TerrainSDF (vec3 (p - vec3 (EPSILON, 0.0, 0.0))),\n       \t2.0 * EPSILON,\n       \tTerrainSDF (vec3 (p + vec3 (0.0, 0.0, EPSILON))) - TerrainSDF (vec3 (p - vec3 (0.0, 0.0, EPSILON)))\n   ));\n}\n\nfloat MapSDF_Simple (vec3 p)\n{       \n    //Move q, and save the movement    \n    p.y+=3.9;\n    float zMovement = sin(iTime * .3) * 2.25;\n\tp.z += zMovement;\n    float xMovement = cos (iTime * .3) * .5 + sqrt ((abs (1.5 * p.y) * (cos (iTime) * .5 + 1.0)) + .5) * sin (iTime);    \n   \tp.x += xMovement;\n    \n   \n    \n    //--------- Tornado ---------//    \n    //Set the radius\n    float radiusCurveExponent = 1.25;\n    float maxRadius = 5.0;   \n    float baseRadius = .15;    \n    \n    float currentRadius = (pow (p.y, radiusCurveExponent * .26) + 0.2) * .2;    \n    \n            \n    //add the tornado shape to the noise\n    float height = 6.0;                    \n    \n    vec2 c = abs (vec2 (length (p.xz) - currentRadius, p.y)) - vec2 (baseRadius, height);\n    float tornadoShape =  vec2 (min (max (c.x, c.y), 0.0) + length (max (c, 0.0)), 0.0).x;\n    \n        \n    return tornadoShape;\n}\n\nvec2 MapSDF (vec3 p)\n{              \n    float result;\n    float mat;\n    vec3 q = p;               \n    \n    //Move q, and save the movement\n    float rotationSpeed = 4.0;    \n    q.y+=3.9;\n    float zMovement = sin(iTime * .3) * 2.25;\n\tq.z += zMovement;\n    float xMovement = cos (iTime * .3) * .5 + sqrt ((abs (1.5 * q.y) * (cos (iTime) * .5 + 1.0)) + .5) * sin (iTime);    \n   \tq.x += xMovement;\n    \n    if(q.y < 0.0)        \n      return vec2 (length (q), 0.0);  \n    \n    //--------- Tornado ---------//\n    //Spin\n    float t = iTime * rotationSpeed;\n    vec3 spin_Point = vec3 (Spin (t - q.y/1.5, q.xz), q.y);\n      \n    //Tornado noise\n    float noiseStrength = .18;    \n\tfloat tornadoNoise = CloudNoise (1.9, spin_Point, spin_Point * .5 + vec3 (0.0, 0.5, 0.25)) * noiseStrength;    \n    float debrisNoise = tornadoNoise; //make a copy of this noise because we will use it\n    \n    //Set the height of the tornado.\n    float heightOffset = tornadoNoise * 2.0 - 1.0;    \n    heightOffset += .3;\n    \n    //Set the radius\n    float radiusCurveExponent = 1.25;\n    float maxRadius = 5.0;   \n    float baseRadius = .25;    \n    \n    float currentRadius = (pow (q.y, radiusCurveExponent * .26) + 0.2) * .2;    \n    float radiusNoise = tornadoNoise * tornadoNoise;\n    currentRadius += radiusNoise;   \n    currentRadius = clamp (currentRadius, 0.0, maxRadius);          \n    \n    //add the tornado shape to the noise\n    float tornadoShape = TornadoShape (q, tornadoNoise, heightOffset, currentRadius, baseRadius);\n    tornadoNoise += tornadoShape * .55;\n    \n    result = tornadoNoise;\n    //--------- Tornado end ---------//\n    \n    \n    //--------- Clouds ---------//\n    vec3 point = p;\n    \n    //Clouds noise\n    point = RotateY (iTime * .2, point);    \n    float cloudNoise = CloudNoise (1.25, point * 0.5, point * 0.5) * .7;                           \n    \n    //Clouds shape\n    float cloudsShape = CloudsShape (p, xMovement, zMovement);\n              \n    \n    //Substract a sphere with radius of the current tornado radius\n    float tornadoRadiusSphere = length (p + vec3 (xMovement, -2.5, zMovement)) - currentRadius * 1.4;\n    cloudsShape = max (cloudsShape, -tornadoRadiusSphere);        \n   \tcloudNoise += cloudsShape * 0.6;        \n    //--------- Clouds end ---------//    \n    //Union between clouds and tornado using a smooth min function\n    result = smin (cloudNoise, tornadoNoise, 1.23, 1.0, 0.0, mat);              \n    \n    //--------- \"DEBRIS\" ---------//        \n    vec3 point_Debris = p;       \n    \n    point_Debris += vec3 (xMovement, 0.0, zMovement);\n    point_Debris = RotateY ((t* .25 - point_Debris.y/1.5), point_Debris);//vec3 (Spin (t - point_Me.y/1.5, point_Me.xz), point_Me.y);\n    point_Debris.y -= pow (length (point_Debris.xz), 1.12);    \n    point_Debris.y += 4.;\n    \n    vec3 d = abs(point_Debris) - vec3 (1.1,.55, 1.25);    \n  \tfloat shape = min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n   \tshape = shape * 0.15 + debrisNoise;\n    \n    //result = Union (result, shape, mat, 4.0, mat);       \n    //--------- End of \"DEBRIS\" ---------//        \n        \n    //Union tornado, clouds and debris                          \n   // result = Union (result, debrisNoise, mat, 4.0, mat);       \n    \n    \n    //--------- Terrain ---------//          \n    float terrain = TerrainSDF (p);\n   \tresult = Union (result, terrain, mat, 3.0, mat);\n    //--------- Terrain end ---------//                    \t\n    \n    return vec2 (result, mat);   \n}\n\nmat3 GetCameraMatrix (vec3 origin, vec3 lookAt)\n{\n    vec3 f = normalize (lookAt - origin);\n    vec3 up = vec3 (0.0, 1.0, 0.0);\n    vec3 l = normalize (cross (f, up));\n    vec3 u = normalize (cross (l, f));\n    \n    return mat3\n    (\n        l,\n        u,\n        -f\n    );\n}\n\nbool BoxIntersection (Ray ray, out vec2 tNtF, vec3 boxSize, out vec3 normal, out int faceNo)\n{\n    vec3 m = 1.0/ray.dir;\n    vec3 n = m * ray.origin;\n    \n    vec3 k = abs (m) * boxSize;\n    \n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max (max (t1.x, t1.y), t1.z);\n    float tF = min (min (t2.x, t2.y), t2.z);\n    \n    //no intersection\n    if (tN > tF || tF < 0.0) \n        return false;\n    \n    \n    normal = -sign (ray.dir) * step (t1.yzx, t1.xyz) * step (t1.zxy, t1.xyz);\n    \n    if (abs (normal).x > 0.) \n    {\n        faceNo = 2;\n    }\n    else \n    {\n    \tif (abs (normal).z > 0.)\n        {\n        \tfaceNo = 1;\n        }\n        else \n        {\n         \tfaceNo = 3;   \n        }\n    }\n    \n    tNtF = vec2 (tN, tF);\n    \n    return true;\n}\n\nvec2 MapBox (Ray ray, float tMin, int faceNo, float boxSize)\n{    \n    if (faceNo == 1)\n    {\n\t\tvec2 xy = (ray.origin + tMin * ray.dir).xy/boxSize;    \n        return xy;\n    } \n    \n    if (faceNo == 2) \n    {\n     \tvec2 zy = (ray.origin + tMin * ray.dir).zy/boxSize;\n        return zy;\n    }\n    \n    if (faceNo == 3) \n    {\n     \tvec2 xz = (ray.origin + tMin * ray.dir).xz/boxSize;\n        return xz;\n    }\n    \n}\n\nvec2 GetNoiseDrops(vec2 uv, float speedMultiplier, float seed, float sizeMultiplier) \n{        \n    vec2 a = vec2 (7.0, 3.);        \n    float off = texture (iChannel0, uv*0.1).x;\n    float speed = ((Hash01 (floor (uv * a).x + seed) + 1.0) * 0.5)  * .2;          \n    uv.y += speed * speedMultiplier * 1.3 * (iTime + 234.5);\n    \n    vec2 st = fract (uv * a + vec2 (off * 0.4, off * 0.05));\n   \tst -= 0.5;        //-0.5-> 0.5\n   \tst *= 2.0;        //-1.0-> 1.0    \n    \n    float randomXPosition = fract (sin (floor (uv).x * 682.2 + floor (uv).y *21.2) * 421.21);\n    randomXPosition = (randomXPosition) * 2.0 - 1.0;\n    randomXPosition *= 0.5;\n   \n    vec2 p = (st-vec2 (randomXPosition, 0.0))/a;\n      \n    float mainDropDist = smoothstep (0.05 * sizeMultiplier, 0.04 * sizeMultiplier, length (p));             \n    \n    return vec2 ((p * mainDropDist * 5.0));\n}\n\nfloat GetShadow (vec3 ro, vec3 rd, float minD, float maxD)\n{\n\tfloat res = 1.0;\n    float t = minD;\n    \n    float ph = 1e10;\n    for (int i=0; i<10; i++)\n    {        \n\t\tvec3 currentPoint = ro + rd * t;\n        \n        float d = MapSDF_Simple (currentPoint);          \n        \n        float y = d * d/(2.0 * ph);\n        float h = sqrt (d*d - y*y);\n        res = min (res, 10.0 * h/max(0.0, t-y));\n        ph = d;\n        \n        t += d;\n        \n        if (t<EPSILON || t>maxD)\n            break;\n    }\n    \n    return clamp (res, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    vec2 notModifiedUvs = fragCoord/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x = uv.x * iResolution.x/iResolution.y;\n    \n    //Camera\n    float zoom = 5.0;    \n    vec3 cameraOrigin = vec3 (0.0, ((sin (iTime*.25) +1. * .5)) * 7.5, -30.0);             \n    cameraOrigin = RotateY (iTime * 15. * 0.02, cameraOrigin);\n    vec3 lookAt = vec3 (0.0, 0.0, 0.0);                \n    \n    mat3 camMatrix = GetCameraMatrix (cameraOrigin, lookAt);\n    \n    //Create ray\n    Ray ray;\n    ray.origin = cameraOrigin;    \n    vec3 dir = camMatrix * (normalize (vec3 (uv.x, uv.y, -zoom)));             \n    ray.dir = dir;                \n  \n    //Raymarch with a softness\n    vec3 pos = ray.origin;\n    float softness = .1;\n    float visibility = 1.;\n    float density = 1.5/softness;    \n    float light = 0.;\n    \n    float mat = 0.0;\n    vec4 bgCol = vec4 (0.0);\n    \n    \n    // box\n    vec3 boxNormal;\n    vec2 boxIntersection;\n    int faceNo = 0;\n    float boxSize = 4.0;\n    bool hasIntersectedBox = BoxIntersection (ray, boxIntersection, vec3 (boxSize, boxSize, boxSize), boxNormal, faceNo); \n    float t = 0.0;\n    vec2 uvFace = vec2 (0.0);  \n    \n    vec2 rayOffset = vec2 (0.0);    \n    \n    //If we have a intersection with the box\n    //Get the uvs and apply offset to the raydir based on the generated noises.\n    if (hasIntersectedBox)\n    {        \n        pos = ray.origin + ray.dir * (boxIntersection.x - 0.3);                \n            \n        fragColor = vec4 (1.0, 0.0, 0.0, 0.0);    \n            \n        uvFace = MapBox (ray, boxIntersection.x, faceNo, boxSize);         \n     \n        if (pos.y <boxSize - 1. && pos.y > -boxSize + 0.5)\n        {\n            rayOffset = GetNoiseDrops (uvFace * 2.0 , 1.0, 12.312, .8);\n            rayOffset += GetNoiseDrops (uvFace * 2.8, 1.0, 555.2, 0.6);\n            rayOffset += GetNoiseDrops (uvFace * 3.2, 3.0, 5., 0.3) * 0.5;                                        \n        }\n\n        if (faceNo == 1)\n            ray.dir.xy += rayOffset;    \n        if (faceNo == 2)\n            ray.dir.xz += rayOffset;  \n        \n        \n        //because i don't have an actual light ray that hits the glass cube, i will only bend our view dir, to fake like there was a media change\n        //will use the index of the refraction for glass 1.52\n        //Normally i should use the box normal of the point that is leaving the cube            \n        vec3 refractedRay = refract (ray.dir, boxNormal, 1./1.2);          \n        float c = acos (dot (-ray.dir, boxNormal));\n        c = 0.04 + (1.-0.04) * pow ((1.0 - cos (c)), 5.0);\n            \n        bgCol = texture (iChannel2, refractedRay) * (1.-c) + texture (iChannel2, reflect (ray.dir, boxNormal)) * (c);                   \n        t = pow ((boxIntersection.y - boxIntersection.x) * 1./boxSize, .2);  \n        bgCol += vec4 (0.3, 0.3, 0.3, 0.3) * (1.-t);\n        \n    } else \n    {\n        //If we don't intersect the cube then just return the value from the cubemap\n        bgCol = texture (iChannel2, ray.dir);\n        fragColor = bgCol;\n     \treturn;   \n    }   \n    \n    \n    vec3 sunPos = vec3 (-10.0, 10.0, 20.0);\n    vec3 sunDir = normalize(sunPos);\n    \n    float dist = 0.0;\n    \n    //Raymarch\n    for ( int i=0; i < 128; i++)\n    {\n        vec2 map = MapSDF (pos);\n        float h = map.x;\n        mat = map.y;\n      \tdist += h;\n        if (dist>boxIntersection.y - EPSILON)\n        {\n         \t//Marched out of the box   \n            fragColor = bgCol;\n            return;\n        }\n        \n        float vis = smoothstep(EPSILON,softness,h);             \n        \n        //Thanks to TekF for this\n        h = max(h,EPSILON); // ensure we always march forward        \n        if ( vis < 1. )\n        {\n            float newvis = visibility * pow(vis,h*density);             \n\t    \tlight += (visibility - newvis)*smoothstep( -.5, 1., (MapSDF(pos+sunDir*softness).x - h)/softness );\n            visibility = 0.2 *  exp(.1 * h*density);\n        }\n        \n       \n        if ( vis <= 0. ) \n            break;\n        \n        pos += h*ray.dir;\n    }\n    \n    \n    //Apply colors\n   \tvec4 finalCol = vec4 (0.0);    \n    vec3 uvXYZ = (pos.xyz/boxSize + 1.0) * 0.5;    \n    vec4 tintColor = vec4 (0.0);   \n    \n\tif (mat == 0.0)                    \n    {\n        tintColor =  mix (vec4 (-0.1), vec4 (0.0, 0.0, 0.6, 0.0), pow (uvXYZ.y, 3.0));\n   \t\tfinalCol = light * vec4(.5,.55,.63,0)+vec4(.2,.2,.2,1.) + 0.2 * tintColor;\n    }\n    \n    if (mat == 1.0)        \n    {\n        float p = FBM (uvXYZ.xz + iTime * 0.1);\n        tintColor =   mix (vec4 (.1, 0.2, 0.4,0.0), vec4 (0.0, .1, 0.6, 0.0),p);\n        finalCol = light * vec4(.6,.6,.6,0)+vec4(.2,.2,.23,1.) + tintColor * 0.2;\n        \n    }  \n        \n    if (mat == 3.0)\n    {\n        //Get terrain color\n        //Simple diffuse illumination\n        vec3 N = GetTerrainNormal(pos);\n      \n        vec3 ref = normalize (reflect( ray.dir, N ));\n        \n        vec2 uvPos = (vec2 (pos.xz/4.0) + 1.0 ) *.5;        \n        float resY = texture (iChannel1, uvPos).x;\n     \n        \n        vec3 lightDir = normalize (sunPos - pos);\n    \tfloat NDotL = clamp (dot (N,lightDir), 0.0, 1.0);\n        \n        vec3 diffuse = mix (vec3 (0.2, 0.55, 0.11), vec3 (0.2, 0.35, 0.11) * .6, pow (resY, 2.));     \t                \n    \n    \tvec3 H = normalize (reflect (-lightDir, N));\n    \tvec3 Vdir = normalize (ray.dir-pos);\n    \tfloat spec = .1;\n    \tfloat dotRV = dot (H, Vdir);\n    \n    \tfloat shadow = GetShadow (pos, sunDir, 0.0, 50.0);\n     \n        vec3 lightColor = vec3 (0.2, 0.35, 0.2);\n            \n    \tvec4 c = vec4 (diffuse, 0.0) * NDotL * vec4 (lightColor, 1.0)  * shadow + max(0.0, pow (spec * dotRV, 5.));     \n\t\tfinalCol = c;      \n    }\n    \n    //Debris taken away by tornado\n    if (mat == 4.0)\n    {\n        finalCol = light * vec4(.13,.12,.1,0) +vec4(.05,.05,.05,1.);\n    }                 \n\n    \n    //Gamma correction\n    fragColor= bgCol * .2 + pow (finalCol, vec4 (1./2.2));        \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec3 RotateY (float angle, vec3 point)\n{\n\tfloat c = cos (angle);\n    float s = sin (angle);\n    \n    mat3 yRotMat = mat3 \n    (\n        c, 0.0, s,\n        0.0, 1.0, 0.0,\n        -s, 0.0, c\n    );\n    \n    return yRotMat * point;\n}\n\nvec3 RotateX (float angle, vec3 point)\n{\n\tfloat c = cos (angle);\n    float s = sin (angle);\n    \n    mat3 xRotMat = mat3 \n    (\n        1.0, 0.0, 0.0,\n        0.0, c, s,\n        0.0, -s, c\n    );\n    \n    return xRotMat * point;\n}\n\nvec3 RotateZ (float angle, vec3 point)\n{\n    float c = cos (angle);\n    float s = sin (angle);\n    \n    mat3 zRotMat = mat3 \n    (\n    \tc, s, 0,\n        -s, c, 0,\n        0, 0, 1\n    );\n    \n    return zRotMat * point;\n}\n\nvec2 Spin (float angle, vec2 point)\n{\n    float c = cos (angle);\n    float s = sin (angle);\n    \n \tmat2 rotMat = mat2 (c, -s, s, c);\n    \n    return rotMat * point;\n}\n\n//Random function\nfloat Hash (vec2 p)\n{\n\treturn fract (sin (dot (p, vec2 (12.56, 167.89))) * 6750.21);\n}\n\n//Simple noise\nfloat Noise (vec2 p)\n{\n   \tvec2 lv = fract (p);\n    vec2 index = floor (p);\n    \n    vec2 sm = 6.0 * lv * lv * lv * lv * lv -\n       \t 15.0 * lv * lv * lv * lv + \n         10.0 * lv * lv * lv; //smooth function\n    \n    float bl = Hash (index);\n    float br = Hash (index + vec2 (1.0, 0.0));\n    float b = mix (bl, br, sm.x);\n    float tl = Hash (index + vec2 (0.0, 1.0));\n    float tr = Hash (index + vec2 (1.0, 1.0));\n    float t = mix (tl, tr, sm.x);\n    \n    return mix (b, t, sm.y);   \n}\n\n//Fractal Brownian Motion\nfloat FBM (vec2 p)\n{\n    const int OCTAVES = 6;\n    \n    float result = 0.0;\n    float m = 0.0;\n    \n    float amplitude = 1.0;\n    float freq = 1.0;\n    \n    for (int i=0; i<6; i++)\n    {\n        result += Noise (p * freq) * amplitude;\n        m += amplitude;\n        amplitude *= 0.5; //lacunarity\n        freq *= 2.0; //gain\n    }\n    \n    return result/m;\n}\n\nfloat Hash( float n ) \n{ \n    return fract(sin(n)*753.5453123); \n}\n\nfloat Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( Hash(n+  0.0), Hash(n+  1.0),f.x),\n                   mix( Hash(n+157.0), Hash(n+158.0),f.x),f.y),\n               mix(mix( Hash(n+113.0), Hash(n+114.0),f.x),\n                   mix( Hash(n+270.0), Hash(n+271.0),f.x),f.y),f.z);\n}\n\n// Cloud noise by iq: https://www.shadertoy.com/view/XslGRr\n// takes a input position + and offset vector and returns a density amount\n// derived by summing multiple layers of noise at varying strengths and scales\nfloat CloudNoise(float scale,in vec3 p, in vec3 dir)\n{\n\tvec3 q = p + dir; \n    float f;\n\tf  = 0.50000*Noise( q ); q = q*scale*2.02 + dir;\n    f += 0.25000*Noise( q ); q = q*2.03 + dir;\n    f += 0.12500*Noise( q ); q = q*2.01 + dir;\n    f += 0.06250*Noise( q ); q = q*2.02 + dir;\n    f += 0.03125*Noise( q );\n    return f;\n}\n\nfloat Hash01 (float x)\n{\n\treturn fract (sin (x * 21.34) * 456.78);    \n}","name":"Common","description":"","type":"common"}]}