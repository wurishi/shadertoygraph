{"ver":"0.1","info":{"id":"dscXzM","date":"1679543609","viewed":109,"name":"Simple Particles in a piston","username":"gorplex","description":"Particles in a piston\n\nmouse pushes objects","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["test","wave","particles","demo","physics","buffer","pressure"],"hasliked":0,"parentid":"ds3XzM","parentname":"Simple particles breathing"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float circle(vec2 p, float r, vec2 uv) {\n    return smoothstep(1.5/iResolution.y, 0., length(uv-p)-r);\n}\n\nvec3 objColor(int objIndex) {\n    return hsv2rgb_smooth(vec3(float(objIndex)/float(NUM_OBJECTS), 0.7, 1.));\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.y;\n    vec3 col = vec3(0.);\n    \n    for(int i=0; i<NUM_OBJECTS;i++) {\n        col += objColor(i)*circle(GET_OBJECT_DATA(i).xy, CIRCLE_SIZE, uv);\n        \n    }\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//const\n#define ASPECT_RATIO iResolution.x/iResolution.y\n#define PI 3.1415926538\n\n//Scene options\n#define NUM_OBJECTS 1000\n#define CIRCLE_SIZE 0.01\n\n//physics values\n#define DELTA_T 0.01\n#define OBJECT_MASS 2.\n#define MAX_VEL 0.6\n#define MAX_ACC 1.0\n\n//Scene  force values\n#define BOUNDRY_WIDTH 0.02\n#define BOUNDRY_FORCE 1000.0\n#define MOUSE_FORCE 0.5\n#define FRICTION_FORCE 5.\n\n//Wall Values\n#define WALL_FREQ 0.4\n#define WALL_AMP 0.3\n\n//Boid values\n#define SEPERATION_FORCE 0.01\n#define COHESION_FORCE 0.\n\n\n//texelFetch is not defined in Common\n#define GET_OBJECT_DATA(index) texelFetch(iChannel0, ivec2(index, 0), 0)\n\n//'random' vals for init\n#define HASH(i) fract(sin(i*1234.567)*12345.567)\n\n// Smooth HSV to RGB conversion \n// Source https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Buffer A runs physics calculations and stores velocity and position vetors\n\nvec2 randomPos(float seed) {\n    return vec2(ASPECT_RATIO*HASH(seed), HASH(HASH(seed)));\n}\n\nfloat smoothStepWindowBoundries(float x,  float minBoundry, float maxBoundry) {\n    return 1.-smoothstep(minBoundry, minBoundry+BOUNDRY_WIDTH, x) -smoothstep(maxBoundry-BOUNDRY_WIDTH, maxBoundry, x);\n}\n\nvec2 calcInverseSquareForce(vec2 dist) {\n    return normalize(dist)/dot(dist, dist);\n}\n\nvec2 calcForces(vec2 pos, vec2 vel, int objectIndex) {       \n    vec2 force = vec2(0.);\n\n    //Boundry force\n    float boundryLocation = WALL_AMP*ASPECT_RATIO*(0.5*sin(iTime*WALL_FREQ*2.*PI)+0.5);\n    force += BOUNDRY_FORCE*vec2(smoothStepWindowBoundries(pos.x, boundryLocation, ASPECT_RATIO), \n        smoothStepWindowBoundries(pos.y, 0., 1.));\n\n    //Mouse force\n    vec4 m = iMouse / iResolution.y;\n    //if button is down\n    if(m.z>0.0) {\n        force += MOUSE_FORCE*calcInverseSquareForce(pos-m.xy);\n    }\n    \n    //Friction\n    force += FRICTION_FORCE*-1.*vel;\n    \n    //Other object forces\n    vec2 avgPos = vec2(0.);\n    vec2 avgVel = vec2(0.);\n    for(int i = 0;i <NUM_OBJECTS; i++) {\n        vec4 otherData = GET_OBJECT_DATA(i);\n        vec2 otherPos = otherData.xy;\n        vec2 otherVel = otherData.zw;\n        \n        //Calc avg pos\n        avgPos += otherPos/float(NUM_OBJECTS);\n        avgVel += otherVel/float(NUM_OBJECTS);\n        if(i != objectIndex) {\n            //Separation force, small random force if in same location\n            if( length(pos - otherPos) > 0.) {\n                force += SEPERATION_FORCE*calcInverseSquareForce(pos - otherPos);\n            } else {\n                force += 10.*randomPos(float(i));\n            }\n        }\n    }\n    \n    //Cohesion force\n    force += COHESION_FORCE*normalize(avgPos-pos);\n    \n    \n    return force;\n}\n\n\nvec4 physUpdate(int objectIndex) {\n    vec4 objectData = GET_OBJECT_DATA(objectIndex);\n    vec2 pos = objectData.xy;\n    vec2 vel = objectData.zw;\n\n    //Calc deltaV = Acc*deltaT = F/M*deltaT and Clamp to max acc\n    vel += clamp(calcForces(pos, vel, objectIndex)/OBJECT_MASS*DELTA_T, -MAX_ACC, MAX_ACC);\n    vel = clamp(vel, -MAX_VEL, MAX_VEL);\n    pos +=vel*DELTA_T;\n    \n    return vec4(pos, vel);\n}\n\nvoid mainImage( out vec4 posVelData, vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.y;\n    \n    //each pixel along x will physics update an object\n    int objectIndex = int(floor(fragCoord.x));\n    if(fragCoord.y > 0.5 || objectIndex > NUM_OBJECTS) discard;\n\n    if (iFrame < 5) {\n        //init pos and vel\n        posVelData = vec4(randomPos(float(objectIndex)), .5, .5);\n    } else {\n        posVelData = physUpdate(objectIndex);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}