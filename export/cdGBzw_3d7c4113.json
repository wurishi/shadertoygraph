{"ver":"0.1","info":{"id":"cdGBzw","date":"1698020315","viewed":164,"name":"TDF Screensaver","username":"FoRenard","description":"uwu\nFull screen recommended","likes":13,"published":1,"flags":0,"usePreview":1,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define resolution iResolution\n#define time iTime\n#define outColor fragColor\n\n// \n// ..%%%%...%%.......%%%%...%%%%%....%%%%...%%.....\n// .%%......%%......%%..%%..%%..%%..%%..%%..%%.....\n// .%%.%%%..%%......%%..%%..%%%%%...%%%%%%..%%.....\n// .%%..%%..%%......%%..%%..%%..%%..%%..%%..%%.....\n// ..%%%%...%%%%%%...%%%%...%%%%%...%%..%%..%%%%%%.\n// ................................................\n// \n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define remap(x,a,b,c,d) ((((x)-(a))/((b)-(a)))*((d)-(c))+(c))\n#define remapc(x,a,b,c,d) clamp((((x)-(a))/((b)-(a)))*((d)-(c))+(c),min(c,d),max(c,d))\n#define rep(i,n) for(int i=0;i<n;i++)\n\nconst float PI = acos(-1.0);\nconst float TAU = 2.0 * PI;\n\nfloat RENARD_EPS = 1e-4;\n#define Width0  (RENARD_EPS)\n#define Width1  (RENARD_EPS)\nconst int FACE_DEFAULT = 0;\nconst int FACE_SLEEP = 1;\nint FACE_TYPE = 0;\n\n// \n// .%%..%%...%%%%...%%%%%%...%%%%...%%%%%%.\n// .%%%.%%..%%..%%....%%....%%......%%.....\n// .%%.%%%..%%..%%....%%.....%%%%...%%%%...\n// .%%..%%..%%..%%....%%........%%..%%.....\n// .%%..%%...%%%%...%%%%%%...%%%%...%%%%%%.\n// ........................................\n// \n\nvec3 pcg33(vec3 v)\n{\n    uvec3 x = floatBitsToUint(v);\n    const uint k = 1103515245u;\n    x = ((x >> 8U) ^ x.yzx) * k;\n    x = ((x >> 8U) ^ x.yzx) * k;\n    x = ((x >> 8U) ^ x.yzx) * k;\n    return vec3(x) / float(-1u);\n}\n\n// \n// ..%%%%...%%%%%%..%%..%%..%%%%%%..%%%%%....%%%%...%%.....\n// .%%......%%......%%%.%%..%%......%%..%%..%%..%%..%%.....\n// .%%.%%%..%%%%....%%.%%%..%%%%....%%%%%...%%%%%%..%%.....\n// .%%..%%..%%......%%..%%..%%......%%..%%..%%..%%..%%.....\n// ..%%%%...%%%%%%..%%..%%..%%%%%%..%%..%%..%%..%%..%%%%%%.\n// ........................................................\n// \n\nvec2 orbit(float a)\n{\n    return vec2(cos(a), sin(a));\n}\nmat2 rot(float a)\n{\n    vec2 p = orbit(a);\n    return mat2(p.x, p.y, -p.y, p.x);\n}\n\nfloat dot2(vec2 v)\n{\n    return dot(v, v);\n}\nfloat cross2(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\nvec3 hex2rgb(int hex)\n{\n    return vec3((hex >> 16) & 0xff, (hex >> 8) & 0xff, hex & 0xff) / 255.0;\n}\n\nfloat getEPS(vec2 uv)\n{\n    vec2 px = abs(dFdx(uv) + dFdy(uv));\n    return max(px.x, px.y);\n}\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\nfloat sdEquilateralTriangle(vec2 p, float r)\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r / k;\n    if(p.x + k * p.y > 0.0)\n        p = vec2(p.x - k * p.y, -k * p.x - p.y) / 2.0;\n    p.x -= clamp(p.x, -2.0 * r, 0.0);\n    return -length(p) * sign(p.y);\n}\nfloat sdBox(vec2 p, vec2 b)\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\nfloat sdTunnel(vec2 p, vec2 wh)\n{\n    p.x = abs(p.x);\n    p.y = -p.y;\n    vec2 q = p - wh;\n\n    float d1 = dot2(vec2(max(q.x, 0.0), q.y));\n    q.x = (p.y > 0.0) ? q.x : length(p) - wh.x;\n    float d2 = dot2(vec2(q.x, max(q.y, 0.0)));\n    float d = sqrt(min(d1, d2));\n\n    // return (max(q.x, q.y) < 0.0) ? -d : d;\n    return sign(max(q.x, q.y)) * d;\n}\n\n// \n// .%%%%%...%%%%%%..%%%%%%..%%%%%%..%%%%%%..%%%%%..\n// .%%..%%..%%.........%%.....%%....%%......%%..%%.\n// .%%%%%...%%%%......%%......%%....%%%%....%%%%%..\n// .%%..%%..%%.......%%.......%%....%%......%%..%%.\n// .%%%%%...%%%%%%..%%%%%%..%%%%%%..%%%%%%..%%..%%.\n// ................................................\n// \n\n// https://www.shadertoy.com/view/MlKcDD\n// 0: exact, using a cubic colver\n// 1: approximated\n#define METHOD 0\n\n#if METHOD==0\n// signed distance to a quadratic bezier\nfloat sdBezier(in vec2 pos, in vec2 A, in vec2 B, in vec2 C)\n{\n    vec2 a = B - A;\n    vec2 b = A - 2.0 * B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b, b);\n    float kx = kk * dot(a, b);\n    float ky = kk * (2.0 * dot(a, a) + dot(d, b)) / 3.0;\n    float kz = kk * dot(d, a);\n\n    float res = 0.0;\n    float sgn = 0.0;\n\n    float p = ky - kx * kx;\n    float q = kx * (2.0 * kx * kx - 3.0 * ky) + kz;\n    float p3 = p * p * p;\n    float q2 = q * q;\n    float h = q2 + 4.0 * p3;\n\n    if(h >= 0.0)\n    {   // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n\n        #if 0\n        // When p≈0 and p<0, h-q has catastrophic cancelation. So, we do\n        // h=√(q²+4p³)=q·√(1+4p³/q²)=q·√(1+w) instead. Now we approximate\n        // √ by a linear Taylor expansion into h≈q(1+½w) so that the q's\n        // cancel each other in h-q. Expanding and simplifying further we\n        // get x=vec2(p³/q,-p³/q-q). And using a second degree Taylor\n        // expansion instead: x=vec2(k,-k-q) with k=(1-p³/q²)·p³/q\n        if(abs(p) < 0.001)\n        {\n            float k = p3 / q;              // linear approx\n          //float k = (1.0-p3/q2)*p3/q;  // quadratic approx \n            x = vec2(k, -k - q);\n        }\n        #endif\n\n        vec2 uv = sign(x) * pow(abs(x), vec2(1.0 / 3.0));\n        float t = clamp(uv.x + uv.y - kx, 0.0, 1.0);\n        vec2 q = d + (c + b * t) * t;\n        res = dot2(q);\n        sgn = cross2(c + 2.0 * b * t, q);\n    }\n    else\n    {   // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q / (p * z * 2.0)) / 3.0;\n        float m = cos(v);\n        float n = sin(v) * 1.732050808;\n        vec3 t = clamp(vec3(m + m, -n - m, n - m) * z - kx, 0.0, 1.0);\n        vec2 qx = d + (c + b * t.x) * t.x;\n        float dx = dot2(qx), sx = cross2(c + 2.0 * b * t.x, qx);\n        vec2 qy = d + (c + b * t.y) * t.y;\n        float dy = dot2(qy), sy = cross2(c + 2.0 * b * t.y, qy);\n        if(dx < dy)\n        {\n            res = dx;\n            sgn = sx;\n        }\n        else\n        {\n            res = dy;\n            sgn = sy;\n        }\n    }\n\n    return sqrt(res) * sign(sgn);\n}\n#else\n\n// This method provides just an approximation, and is only usable in\n// the very close neighborhood of the curve. Taken and adapted from\n// http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\nfloat sdBezier(vec2 p, vec2 v0, vec2 v1, vec2 v2)\n{\n    vec2 i = v0 - v2;\n    vec2 j = v2 - v1;\n    vec2 k = v1 - v0;\n    vec2 w = j - k;\n\n    v0 -= p;\n    v1 -= p;\n    v2 -= p;\n\n    float x = cross2(v0, v2);\n    float y = cross2(v1, v0);\n    float z = cross2(v2, v1);\n\n    vec2 s = 2.0 * (y * j + z * k) - x * i;\n\n    float r = (y * z - x * x * 0.25) / dot2(s);\n    float t = clamp((0.5 * x + y + r * dot(s, w)) / (x + y + z), 0.0, 1.0);\n\n    return length(v0 + t * (k + k + t * w));\n}\n#endif\n\nconst int mimi0Count = 3;\nconst vec2 mimi0DPoints[mimi0Count] = vec2[mimi0Count](vec2(0.3337333, 0.5017499), vec2(0.3165894, 0.5574675), vec2(0.3016016, 0.5728836));\nconst vec2 mimi0CPoints[mimi0Count + 1] = vec2[mimi0Count + 1](vec2(0.3664181, 0.4767151), vec2(0.3161717, 0.5588251), vec2(0.305142, 0.569242), vec2(0.3143334, 0.5784334));\n\nfloat mimi0(vec2 uv)\n{\n    uv -= vec2(0, 0.25);\n    float c = 0.0;\n    rep(i, mimi0Count)\n    {\n        vec2 p0 = mimi0CPoints[i];\n        vec2 p1 = mimi0DPoints[i];\n        vec2 p2 = mimi0CPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        c += smoothstep(Width0, Width0 - RENARD_EPS, abs(d));\n    }\n    return c;\n}\n\nconst int mimi1Count = 4;\nconst vec2 mimi1DPoints[mimi1Count] = vec2[mimi1Count](vec2(0.314979, 0.5729164), vec2(0.3063789, 0.5909783), vec2(0.3122102, 0.5986192), vec2(0.3924156, 0.6095699));\nconst vec2 mimi1CPoints[mimi1Count + 1] = vec2[mimi1Count + 1](vec2(0.3400694, 0.5612761), vec2(0.3143334, 0.5796589), vec2(0.3094313, 0.594978), vec2(0.3222993, 0.5962035), vec2(0.4466898, 0.5814972));\nfloat mimi1(vec2 uv)\n{\n    uv -= vec2(0, 0.25);\n    float c = 0.0;\n    rep(i, mimi1Count)\n    {\n        vec2 p0 = mimi1CPoints[i];\n        vec2 p1 = mimi1DPoints[i];\n        vec2 p2 = mimi1CPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        c += smoothstep(Width0, Width0 - RENARD_EPS, abs(d));\n    }\n    return c;\n}\n\nconst int mimi2Count = 3;\nconst vec2 mimi2DPoints[mimi2Count] = vec2[mimi2Count](vec2(0.3297472, 0.5560984), vec2(0.3467522, 0.537255), vec2(0.3335863, 0.5345061));\nconst vec2 mimi2CPoints[mimi2Count + 1] = vec2[mimi2Count + 1](vec2(0.3400694, 0.5612761), vec2(0.3382916, 0.5466302), vec2(0.3404306, 0.5359352), vec2(0.3498422, 0.5141174));\nfloat mimi2(vec2 uv)\n{\n    uv -= vec2(0, 0.25);\n    float c = 0.0;\n    rep(i, mimi2Count)\n    {\n        vec2 p0 = mimi2CPoints[i];\n        vec2 p1 = mimi2DPoints[i];\n        vec2 p2 = mimi2CPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        c += smoothstep(Width0, Width0 - RENARD_EPS, abs(d));\n    }\n    return c;\n}\n\nconst int mimi3Count = 3;\nconst vec2 mimi3DPoints[mimi3Count] = vec2[mimi3Count](vec2(0.3542524, 0.5421035), vec2(0.3654502, 0.5273353), vec2(0.3517519, 0.5250721));\nconst vec2 mimi3CPoints[mimi3Count + 1] = vec2[mimi3Count + 1](vec2(0.3626762, 0.5496248), vec2(0.3592538, 0.5355074), vec2(0.3605372, 0.5265236), vec2(0.3605372, 0.5102672));\nfloat mimi3(vec2 uv)\n{\n    uv -= vec2(0, 0.25);\n    float c = 0.0;\n    rep(i, mimi3Count)\n    {\n        vec2 p0 = mimi3CPoints[i];\n        vec2 p1 = mimi3DPoints[i];\n        vec2 p2 = mimi3CPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        c += smoothstep(Width0, Width0 - RENARD_EPS, abs(d));\n    }\n    return c;\n}\n\nconst int mimi4Count = 1;\nconst vec2 mimi4DPoints[mimi4Count] = vec2[mimi4Count](vec2(0.3344154, 0.5099288));\nconst vec2 mimi4CPoints[mimi4Count + 1] = vec2[mimi4Count + 1](vec2(0.3562592, 0.5183954), vec2(0.3720878, 0.4858826));\nfloat mimi4(vec2 uv)\n{\n    uv -= vec2(0, 0.25);\n    float c = 0.0;\n    rep(i, mimi4Count)\n    {\n        vec2 p0 = mimi4CPoints[i];\n        vec2 p1 = mimi4DPoints[i];\n        vec2 p2 = mimi4CPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        c += smoothstep(Width0, Width0 - RENARD_EPS, abs(d));\n    }\n    return c;\n}\n\nfloat mimi(vec2 uv)\n{\n    bool migi = uv.x > 0.5;\n    uv.x = 0.5 - abs(uv.x - 0.5);\n    const vec2 p0 = vec2(0.3664181, 0.4767151 + 0.25), q0 = vec2(0.4466898, 0.5814972 + 0.25);\n    const float r = 0.1;\n    vec2 cen = (p0 + q0) * 0.5;\n    vec2 dir = normalize(q0 - p0);\n    dir *= rot(PI * 0.5);\n    cen += dir * r;\n    // const vec2 cen = vec2(0.5, 0.5207813);\n    uv -= cen;\n    float l = length(uv);\n    float fq = pow(remapc(l, length(cen - p0), 0.4, 0.0, 1.0), 0.8) * 0.2;\n    float lt = time * 0.1;\n    float ltf = fract(lt), lti = floor(lt);\n    lt = (lti + pow(smoothstep(0.0, 1.0, ltf), 160.0)) * 2.5 * TAU;\n\n    float rt = time * 2.0 - fq * 5.0 * PI + (migi ? lt : 0.0);\n    uv *= rot(sin(rt) * fq);\n    uv += cen;\n\n    vec2 auv = uv;\n    float c = 0.0;\n    c += mimi0(auv);\n    c += mimi1(auv);\n    c += mimi2(auv);\n    c += mimi3(auv);\n    c += mimi4(auv);\n    return c;\n}\n\nconst int hair0Count = 1;\nconst vec2 hair0DPoints[hair0Count] = vec2[hair0Count](vec2(0.3123834, 0.2714705));\nconst vec2 hair0CPoints[hair0Count + 1] = vec2[hair0Count + 1](vec2(0.366295, 0.5272), vec2(0.3752087, 0.2601414));\nfloat hair0(vec2 uv)\n{\n    uv -= vec2(0, 0.2);\n    float c = 0.0;\n    rep(i, hair0Count)\n    {\n        vec2 p0 = hair0CPoints[i];\n        vec2 p1 = hair0DPoints[i];\n        vec2 p2 = hair0CPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        c += smoothstep(Width0, Width0 - RENARD_EPS, abs(d));\n    }\n    return c;\n}\n\nconst int hair1Count = 1;\nconst vec2 hair1DPoints[hair1Count] = vec2[hair1Count](vec2(0.4685905, 0.6364962));\nconst vec2 hair1CPoints[hair1Count + 1] = vec2[hair1Count + 1](vec2(0.4487305, 0.6303712), vec2(0.4789313, 0.6369464));\nfloat hair1(vec2 uv)\n{\n    uv -= vec2(0, 0.2);\n    float c = 0.0;\n    rep(i, hair1Count)\n    {\n        vec2 p0 = hair1CPoints[i];\n        vec2 p1 = hair1DPoints[i];\n        vec2 p2 = hair1CPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        c += smoothstep(Width0, Width0 - RENARD_EPS, abs(d));\n    }\n    return c;\n}\n\nconst int hair2Count = 1;\nconst vec2 hair2DPoints[hair2Count] = vec2[hair2Count](vec2(0.5258037, 0.6381837));\nconst vec2 hair2CPoints[hair2Count + 1] = vec2[hair2Count + 1](vec2(0.5068359, 0.6381837), vec2(0.5507813, 0.6313477));\nfloat hair2(vec2 uv)\n{\n    uv -= vec2(0, 0.2);\n    float c = 0.0;\n    rep(i, hair2Count)\n    {\n        vec2 p0 = hair2CPoints[i];\n        vec2 p1 = hair2DPoints[i];\n        vec2 p2 = hair2CPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        c += smoothstep(Width0, Width0 - RENARD_EPS, abs(d));\n    }\n    return c;\n}\n\nconst int hair3Count = 4;\nconst vec2 hair3DPoints[hair3Count] = vec2[hair3Count](vec2(0.4781175, 0.6467599), vec2(0.4929611, 0.6681346), vec2(0.524968, 0.6688459), vec2(0.5233529, 0.6500028));\nconst vec2 hair3CPoints[hair3Count + 1] = vec2[hair3Count + 1](vec2(0.4805382, 0.6289349), vec2(0.4860118, 0.6581277), vec2(0.5079064, 0.6684667), vec2(0.5231109, 0.6471803), vec2(0.5121636, 0.6544785));\nfloat hair3(vec2 uv)\n{\n    uv -= vec2(0, 0.2);\n    float c = 0.0;\n    rep(i, hair3Count)\n    {\n        vec2 p0 = hair3CPoints[i];\n        vec2 p1 = hair3DPoints[i];\n        vec2 p2 = hair3CPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        c += smoothstep(Width0, Width0 - RENARD_EPS, abs(d));\n    }\n    return c;\n}\n\nconst int hair4Count = 1;\nconst vec2 hair4DPoints[hair4Count] = vec2[hair4Count](vec2(0.5027429, 0.6376072));\nconst vec2 hair4CPoints[hair4Count + 1] = vec2[hair4Count + 1](vec2(0.5152045, 0.6599522), vec2(0.5072982, 0.6192039));\nfloat hair4(vec2 uv)\n{\n    uv -= vec2(0, 0.2);\n    float c = 0.0;\n    rep(i, hair4Count)\n    {\n        vec2 p0 = hair4CPoints[i];\n        vec2 p1 = hair4DPoints[i];\n        vec2 p2 = hair4CPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        c += smoothstep(Width0, Width0 - RENARD_EPS, abs(d));\n    }\n    return c;\n}\n\nconst int hair5Count = 5;\nconst vec2 hair5DPoints[hair5Count] = vec2[hair5Count](vec2(0.4060487, 0.2825897), vec2(0.3744714, 0.2825897), vec2(0.3642769, 0.5272579), vec2(0.4228127, 0.6118096), vec2(0.4779559, 0.6264679));\nconst vec2 hair5CPoints[hair5Count + 1] = vec2[hair5Count + 1](vec2(0.3984913, 0.415), vec2(0.4227322, 0.2825897), vec2(0.3719779, 0.3424344), vec2(0.3947037, 0.5712076), vec2(0.4553059, 0.620447), vec2(0.4893946, 0.6196894));\nfloat hair5(vec2 uv)\n{\n    uv -= vec2(0, 0.2);\n    float c = 0.0;\n    rep(i, hair5Count)\n    {\n        vec2 p0 = hair5CPoints[i];\n        vec2 p1 = hair5DPoints[i];\n        vec2 p2 = hair5CPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        c += smoothstep(Width0, Width0 - RENARD_EPS, abs(d));\n    }\n    return c;\n}\n\nconst int hair6Count = 2;\nconst vec2 hair6DPoints[hair6Count] = vec2[hair6Count](vec2(0.3954884, 0.401431), vec2(0.4106577, 0.4060477));\nconst vec2 hair6CPoints[hair6Count + 1] = vec2[hair6Count + 1](vec2(0.3840983, 0.4560635), vec2(0.4181871, 0.4083393), vec2(0.4053091, 0.4787893));\nfloat hair6(vec2 uv)\n{\n    uv -= vec2(0, 0.2);\n    float c = 0.0;\n    rep(i, hair6Count)\n    {\n        vec2 p0 = hair6CPoints[i];\n        vec2 p1 = hair6DPoints[i];\n        vec2 p2 = hair6CPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        c += smoothstep(Width0, Width0 - RENARD_EPS, abs(d));\n    }\n    return c;\n}\n\nconst int hair7Count = 1;\nconst vec2 hair7DPoints[hair7Count] = vec2[hair7Count](vec2(0.4347027, 0.4898417));\nconst vec2 hair7CPoints[hair7Count + 1] = vec2[hair7Count + 1](vec2(0.4062079, 0.4713728), vec2(0.4634625, 0.5516046));\nfloat hair7(vec2 uv)\n{\n    uv -= vec2(0, 0.2);\n    float c = 0.0;\n    rep(i, hair7Count)\n    {\n        vec2 p0 = hair7CPoints[i];\n        vec2 p1 = hair7DPoints[i];\n        vec2 p2 = hair7CPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        c += smoothstep(Width0, Width0 - RENARD_EPS, abs(d));\n    }\n    return c;\n}\n\nconst int hair8Count = 7;\nconst vec2 hair8DPoints[hair8Count] = vec2[hair8Count](vec2(0.4502097, 0.478475), vec2(0.4977004, 0.4598745), vec2(0.4936969, 0.4640964), vec2(0.5041099, 0.462031), vec2(0.5064528, 0.4567828), vec2(0.5397303, 0.4583783), vec2(0.5237788, 0.5193359));\nconst vec2 hair8CPoints[hair8Count + 1] = vec2[hair8Count + 1](vec2(0.4691126, 0.5715683), vec2(0.4962333, 0.4604492), vec2(0.4864397, 0.4717494), vec2(0.5082868, 0.4612025), vec2(0.4947265, 0.4830497), vec2(0.5357841, 0.4581891), vec2(0.5346541, 0.4777762), vec2(0.5256139, 0.5670483));\nfloat hair8(vec2 uv)\n{\n    uv -= vec2(0, 0.2);\n    float c = 0.0;\n    rep(i, hair8Count)\n    {\n        vec2 p0 = hair8CPoints[i];\n        vec2 p1 = hair8DPoints[i];\n        vec2 p2 = hair8CPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        c += smoothstep(Width0, Width0 - RENARD_EPS, abs(d));\n    }\n    return c;\n}\n\nconst int hair9Count = 1;\nconst vec2 hair9DPoints[hair9Count] = vec2[hair9Count](vec2(0.550795, 0.5026342));\nconst vec2 hair9CPoints[hair9Count + 1] = vec2[hair9Count + 1](vec2(0.5252373, 0.5576314), vec2(0.5956755, 0.4807896));\nfloat hair9(vec2 uv)\n{\n    uv -= vec2(0, 0.2);\n    float c = 0.0;\n    rep(i, hair9Count)\n    {\n        vec2 p0 = hair9CPoints[i];\n        vec2 p1 = hair9DPoints[i];\n        vec2 p2 = hair9CPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        c += smoothstep(Width0, Width0 - RENARD_EPS, abs(d));\n    }\n    return c;\n}\n\nfloat hair(vec2 uv)\n{\n    vec2 auv = uv;\n    auv.x = 0.5 - abs(uv.x - 0.5);\n    float c = 0.0;\n    c += hair0(auv);\n    c += hair1(uv);\n    c += hair2(uv);\n    c += hair3(uv);\n    c += hair4(uv);\n    c += hair5(auv);\n    c += hair6(auv);\n    c += hair7(uv);\n    c += hair8(uv);\n    c += hair9(uv);\n    return c;\n}\n\nconst int jawCount = 1;\nconst vec2 jawDPoints[jawCount] = vec2[jawCount](vec2(0.4313611, 0.3690723));\nconst vec2 jawCPoints[jawCount + 1] = vec2[jawCount + 1](vec2(0.4105328, 0.4079142), vec2(0.5, 0.3690723));\nfloat jaw(vec2 uv)\n{\n    uv -= vec2(0, 0.2);\n    float c = 0.0;\n    rep(i, jawCount)\n    {\n        vec2 p0 = jawCPoints[i];\n        vec2 p1 = jawDPoints[i];\n        vec2 p2 = jawCPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        c += smoothstep(Width0, Width0 - RENARD_EPS, abs(d));\n    }\n    return c;\n}\n\nconst int mouthCount = 3;\nconst vec2 mouthDPoints[mouthCount] = vec2[mouthCount](vec2(0.4885096, 0.3946072), vec2(0.4899845, 0.3984413), vec2(0.490913, 0.3984413));\nconst vec2 mouthCPoints[mouthCount + 1] = vec2[mouthCount + 1](vec2(0.4832596, 0.3980693), vec2(0.4888397, 0.3954652), vec2(0.4914438, 0.3984413), vec2(0.500744, 0.4021614));\nfloat mouth(vec2 uv)\n{\n    uv -= vec2(0, 0.2);\n    float c = 0.0;\n    rep(i, mouthCount)\n    {\n        vec2 p0 = mouthCPoints[i];\n        vec2 p1 = mouthDPoints[i];\n        vec2 p2 = mouthCPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        c += smoothstep(Width1, Width1 - RENARD_EPS, abs(d));\n    }\n    return c;\n}\n\nconst int eye0Count = 6;\nconst vec2 eye0DPoints[eye0Count] = vec2[eye0Count](vec2(0.4720628, 0.4217044), vec2(0.4626648, 0.4774323), vec2(0.433164, 0.4852708), vec2(0.4131272, 0.45221), vec2(0.4134572, 0.4165726), vec2(0.4424489, 0.4070025));\nconst vec2 eye0CPoints[eye0Count + 1] = vec2[eye0Count + 1](vec2(0.4540792, 0.4127126), vec2(0.4666031, 0.4540792), vec2(0.4488244, 0.4811097), vec2(0.420666, 0.4646491), vec2(0.413267, 0.4371083), vec2(0.4309425, 0.4108007), vec2(0.4540792, 0.4127126));\nvec2 eye_std0(vec2 uv)\n{\n    uv -= vec2(0, 0.2);\n    float c = 0.0;\n    float s = 1.0;\n    rep(i, eye0Count)\n    {\n        vec2 p0 = eye0CPoints[i];\n        vec2 p1 = eye0DPoints[i];\n        vec2 p2 = eye0CPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        s *= float(d < 0.0);\n        c += smoothstep(Width1, Width1 - RENARD_EPS, abs(d));\n    }\n    return vec2(c, s);\n}\n\nconst int eye1Count = 4;\nconst vec2 eye1DPoints[eye1Count] = vec2[eye1Count](vec2(0.4370469, 0.4608925), vec2(0.4451273, 0.4633779), vec2(0.4415632, 0.4737157), vec2(0.4332314, 0.4716665));\nconst vec2 eye1CPoints[eye1Count + 1] = vec2[eye1Count + 1](vec2(0.4350586, 0.4650879), vec2(0.4411621, 0.4621582), vec2(0.4433594, 0.4685059), vec2(0.4372559, 0.4726563), vec2(0.4350127, 0.4656067));\nvec2 eye_std1(vec2 uv)\n{\n    uv -= vec2(0, 0.2);\n    float c = 0.0;\n    float s = 1.0;\n    rep(i, eye1Count)\n    {\n        vec2 p0 = eye1CPoints[i];\n        vec2 p1 = eye1DPoints[i];\n        vec2 p2 = eye1CPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        s *= float(d < 0.0);\n        c += smoothstep(Width1, Width1 - RENARD_EPS, abs(d));\n    }\n    return vec2(c, s);\n}\n\nconst int eye2Count = 6;\nconst vec2 eye2DPoints[eye2Count] = vec2[eye2Count](vec2(0.455011, 0.4747225), vec2(0.468009, 0.446457), vec2(0.4596506, 0.4146294), vec2(0.437374, 0.4115263), vec2(0.4260025, 0.4353544), vec2(0.4298123, 0.4627348));\nconst vec2 eye2CPoints[eye2Count + 1] = vec2[eye2Count + 1](vec2(0.4420311, 0.4720037), vec2(0.4608051, 0.4621226), vec2(0.4627813, 0.4265508), vec2(0.4482891, 0.4130467), vec2(0.4308326, 0.4252334), vec2(0.4288564, 0.4558646), vec2(0.4341263, 0.4664044));\nvec2 eye_std2(vec2 uv)\n{\n    uv -= vec2(0, 0.2);\n    float c = 0.0;\n    float s = 1.0;\n    rep(i, eye2Count)\n    {\n        vec2 p0 = eye2CPoints[i];\n        vec2 p1 = eye2DPoints[i];\n        vec2 p2 = eye2CPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        s *= float(d > 0.0);\n        c += smoothstep(Width1, Width1 - RENARD_EPS, abs(d));\n    }\n    return vec2(c, s);\n}\n\nconst int eyebrow0Count = 2;\nconst vec2 eyebrow0DPoints[eyebrow0Count] = vec2[eyebrow0Count](vec2(0.4010779, 0.4603835), vec2(0.432934, 0.49391));\nconst vec2 eyebrow0CPoints[eyebrow0Count + 1] = vec2[eyebrow0Count + 1](vec2(0.4125977, 0.4370118), vec2(0.4164513, 0.476563), vec2(0.4487607, 0.4813171));\nfloat eyebrow0(vec2 uv)\n{\n    uv -= vec2(0, 0.2);\n    float c = 0.0;\n    rep(i, eyebrow0Count)\n    {\n        vec2 p0 = eyebrow0CPoints[i];\n        vec2 p1 = eyebrow0DPoints[i];\n        vec2 p2 = eyebrow0CPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        c += smoothstep(Width1, Width1 - RENARD_EPS, abs(d));\n    }\n    return c;\n}\n\nconst int eyebrow2Count = 2;\nconst vec2 eyebrow2DPoints[eyebrow2Count] = vec2[eyebrow2Count](vec2(0.4079011, 0.4699939), vec2(0.4275994, 0.4885447));\nconst vec2 eyebrow2CPoints[eyebrow2Count + 1] = vec2[eyebrow2Count + 1](vec2(0.4047227, 0.4463349), vec2(0.4184052, 0.4798861), vec2(0.4388733, 0.4908168));\nfloat eyebrow2(vec2 uv)\n{\n    uv -= vec2(0, 0.2);\n    float c = 0.0;\n    rep(i, eyebrow2Count)\n    {\n        vec2 p0 = eyebrow2CPoints[i];\n        vec2 p1 = eyebrow2DPoints[i];\n        vec2 p2 = eyebrow2CPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        c += smoothstep(Width1, Width1 - RENARD_EPS, abs(d));\n    }\n    return c;\n}\n\nconst int eyebrow3Count = 1;\nconst vec2 eyebrow3DPoints[eyebrow3Count] = vec2[eyebrow3Count](vec2(0.4389693, 0.5187222));\nconst vec2 eyebrow3CPoints[eyebrow3Count + 1] = vec2[eyebrow3Count + 1](vec2(0.4139235, 0.5023056), vec2(0.4550404, 0.5130652));\nfloat eyebrow3(vec2 uv)\n{\n    uv -= vec2(0, 0.2);\n    float c = 0.0;\n    rep(i, eyebrow3Count)\n    {\n        vec2 p0 = eyebrow3CPoints[i];\n        vec2 p1 = eyebrow3DPoints[i];\n        vec2 p2 = eyebrow3CPoints[i + 1];\n        float l0 = length(p0 - uv), l1 = length(p2 - uv);\n        float t = saturate(l0 / (l0 + l1));\n        t = 1.0 - abs(t - 0.5) * 2.0;\n        t = pow(t, 0.5) * 1.5;\n        float d = sdBezier(uv, p0, p1, p2);\n        float w = Width0 * t;\n        c += smoothstep(w, w - RENARD_EPS, abs(d));\n    }\n    return c;\n}\n\nfloat nose(vec2 uv)\n{\n    float r = 0.0035;\n    float y = remapc(uv.y - 0.62, -r, r, 0.0, 1.0);\n    uv -= vec2(0.5, 0.62);\n    uv.x *= mix(1.0, 0.5, y);\n    float d = length(uv);\n    float c = smoothstep(r, r - RENARD_EPS, d);\n    return c;\n}\n\nfloat iris(vec2 uv)\n{\n    float r = 0.013;\n    float y = remapc(uv.y - 0.63, 0.0, r * 1.1, 0.0, 1.0);\n    uv -= vec2(0.447, 0.63);\n    uv.y /= 1.1;\n    float d = length(uv);\n    float c = smoothstep(r, r - 0.003, d);\n    return c * mix(1.0, 0.0, y);\n}\n\nfloat cheek(vec2 uv)\n{\n    float c = 0.0;\n    float d = sdSegment(uv, vec2(0.425, 0.603), vec2(0.425, 0.608));\n    c += smoothstep(Width0, Width0 - RENARD_EPS, d);\n    d = sdSegment(uv, vec2(0.43, 0.603), vec2(0.43, 0.608));\n    c += smoothstep(Width0, Width0 - RENARD_EPS, d);\n    return c;\n}\n\nfloat eye_std(vec2 uv, vec2 auv)\n{\n    float c = 0.0;\n    float m0 = 1.0, m1 = 1.0, m2 = 1.0;\n    vec2 cs = vec2(0);\n    cs = eye_std0(auv);\n    c += cs.x;\n    m0 *= cs.y;\n\n    cs = eye_std1(uv);\n    c += cs.x;\n    m1 *= cs.y;\n    cs = eye_std2(uv);\n    c += cs.x;\n    m0 *= 1.0 - cs.y;\n\n    cs = eye_std1(uv - vec2(0.11, 0));\n    c += cs.x;\n    m2 *= cs.y;\n    cs = eye_std2(uv - vec2(0.11, 0));\n    c += cs.x;\n    m0 *= 1.0 - cs.y;\n\n    // 白目\n    float r = 0.05;\n    float y = remapc(uv.y - 0.64, 0.0, r, 0.0, 1.0);\n    m0 *= 0.2;\n    m0 = mix(m0, m0 * 0.1, y);\n\n    c += eyebrow0(auv);\n    c += eyebrow2(auv);\n\n    c += iris(auv);\n    return c + m0 + m1 + m2;\n}\n\nfloat eye_sleep(vec2 uv)\n{\n    uv -= vec2(0, .15);\n    float c = 0.0;\n    const vec2 p0 = vec2(0.4161512, 0.4794657), q0 = vec2(0.4704818, 0.4811769);\n    float d = sdSegment(uv, p0, q0);\n    float l0 = length(p0 - uv), l1 = length(q0 - uv);\n    float t = pow(abs(saturate(l0 / (l0 + l1)) * 2.0 - 1.0), 3.0);\n    float w = mix(Width0 * 2.0, Width0, t);\n    c += smoothstep(w, w - RENARD_EPS, d);\n    return c;\n}\n\nfloat face(vec2 uv)\n{\n    vec2 auv = uv;\n    auv.x = 0.5 - abs(uv.x - 0.5);\n    float c = 0.0;\n    c += jaw(auv);\n    c += mouth(auv);\n    bool blink = pcg33(vec3(floor(time * 7.0))).x < 0.04;\n    c += (blink || FACE_TYPE == FACE_SLEEP) ? eye_sleep(auv) : eye_std(uv, auv);\n    c += eyebrow3(auv);\n    c += nose(uv);\n    c += cheek(auv);\n    return c;\n}\n\nconst int neckCount = 1;\nconst vec2 neckDPoints[neckCount] = vec2[neckCount](vec2(0.4819892, 0.5645803));\nconst vec2 neckCPoints[neckCount + 1] = vec2[neckCount + 1](vec2(0.4835215, 0.568), vec2(0.4586934, 0.5610994));\nfloat neck(vec2 uv)\n{\n    float c = 0.0;\n    rep(i, neckCount)\n    {\n        vec2 p0 = neckCPoints[i];\n        vec2 p1 = neckDPoints[i];\n        vec2 p2 = neckCPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        c += smoothstep(Width0, Width0 - RENARD_EPS, abs(d));\n    }\n    return c;\n}\n\nconst int cloth0Count = 3;\nconst vec2 cloth0DPoints[cloth0Count] = vec2[cloth0Count](vec2(0.4272272, 0.5572448), vec2(0.448801, 0.5718976), vec2(0.4723846, 0.5656338));\nconst vec2 cloth0CPoints[cloth0Count + 1] = vec2[cloth0Count + 1](vec2(0.4073051, 0.528985), vec2(0.4294026, 0.5579699), vec2(0.4560917, 0.5705971), vec2(0.4744584, 0.5662923));\nfloat cloth0(vec2 uv)\n{\n    float c = 0.0;\n    rep(i, cloth0Count)\n    {\n        vec2 p0 = cloth0CPoints[i];\n        vec2 p1 = cloth0DPoints[i];\n        vec2 p2 = cloth0CPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        c += smoothstep(Width0, Width0 - RENARD_EPS, abs(d));\n    }\n    return c;\n}\n\nconst int cloth1Count = 3;\nconst vec2 cloth1DPoints[cloth1Count] = vec2[cloth1Count](vec2(0.4603218, 0.5674), vec2(0.4564562, 0.5601355), vec2(0.4778564, 0.5301752));\nconst vec2 cloth1CPoints[cloth1Count + 1] = vec2[cloth1Count + 1](vec2(0.4715424, 0.5653092), vec2(0.4584521, 0.5638863), vec2(0.4712578, 0.5394132), vec2(0.5, 0.5206314));\nfloat cloth1(vec2 uv)\n{\n    float c = 0.0;\n    rep(i, cloth1Count)\n    {\n        vec2 p0 = cloth1CPoints[i];\n        vec2 p1 = cloth1DPoints[i];\n        vec2 p2 = cloth1CPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        c += smoothstep(Width1, Width1 - RENARD_EPS, abs(d));\n    }\n    return c;\n}\n\nfloat sakotsu(vec2 uv)\n{\n    float d = sdSegment(uv, vec2(0.4736328, 0.5458984), vec2(0.4934082, 0.5412598));\n    return smoothstep(Width1, Width1 - RENARD_EPS, d);\n}\n\nfloat ribbon0(vec2 uv)\n{\n    vec2 auv = uv;\n    auv.x -= 0.5;\n    const float b0 = 0.5197617, a0 = -18.0;\n    float y = a0 * auv.x * auv.x + b0;\n    float d = auv.y - y;\n    float c0 = smoothstep(0., -RENARD_EPS, d);\n    const float b1 = 0.5102468, a1 = -32.0;\n    y = a1 * auv.x * auv.x + b1;\n    d = auv.y - y;\n    c0 *= smoothstep(0., RENARD_EPS, d);\n    const vec2 p0 = vec2(0.4570313, 0.4853516), q0 = vec2(0.4677734, 0.4777832);\n    const float m0 = (q0.y - p0.y) / (q0.x - p0.x), n0 = p0.y - m0 * p0.x;\n    y = m0 * uv.x + n0;\n    d = uv.y - y;\n    c0 *= smoothstep(0., RENARD_EPS, d);\n\n    float c1 = 0.0;\n    const float b2 = 0.5197617, a2 = -165.0;\n    y = a2 * auv.x * auv.x + b2;\n    d = auv.y - y;\n    c1 += smoothstep(0., -RENARD_EPS * 10.0, d);\n    const float b3 = 0.5102468, a3 = -600.0;\n    y = a3 * auv.x * auv.x + b3;\n    d = auv.y - y;\n    c1 *= smoothstep(0., RENARD_EPS * 10.0, d);\n    const vec2 p1 = vec2(0.4816895, 0.4458008 + 0.007), q1 = vec2(0.4921875, 0.4431152 + 0.007);\n    const float m1 = (q1.y - p1.y) / (q1.x - p1.x), n1 = p1.y - m1 * p1.x;\n    y = m1 * uv.x + n1;\n    d = uv.y - y;\n    c1 *= smoothstep(0., RENARD_EPS, d);\n\n    return saturate(c0 + c1);\n}\n\nconst int himo0Count = 1;\nconst vec2 himo0DPoints[himo0Count] = vec2[himo0Count](vec2(0.4536494, 0.4436567));\nconst vec2 himo0CPoints[himo0Count + 1] = vec2[himo0Count + 1](vec2(0.4414063, 0.4543457), vec2(0.4870605, 0.4414063));\nfloat himo0(vec2 uv)\n{\n    float c = 0.0;\n    rep(i, himo0Count)\n    {\n        vec2 p0 = himo0CPoints[i];\n        vec2 p1 = himo0DPoints[i];\n        vec2 p2 = himo0CPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        c += smoothstep(0.004, 0.004 - RENARD_EPS, abs(d));\n    }\n    return c;\n}\n\nfloat ribbon1(vec2 uv)\n{\n    vec2 uv0 = uv - vec2(0.493, 0.4401855);\n    float d = sdEquilateralTriangle(uv0.yx, 0.005) - 0.003;\n    float c = smoothstep(Width1, Width1 - RENARD_EPS, d);\n    float c0 = himo0(uv);\n    c0 *= smoothstep(Width1, Width1 - RENARD_EPS, 0.4414063 - uv.x);\n    c0 *= smoothstep(0.01, -0.01, uv.x - 0.4870605);\n    return c + c0;\n}\n\nconst int cloth2Count = 5;\nconst vec2 cloth2DPoints[cloth2Count] = vec2[cloth2Count](vec2(0.3459159, 0.4136349), vec2(0.3630695, 0.333584), vec2(0.4465556, 0.3243077), vec2(0.4851234, 0.4004285), vec2(0.4134342, 0.4617111));\nconst vec2 cloth2CPoints[cloth2Count + 1] = vec2[cloth2Count + 1](vec2(0.3941045, 0.4899559), vec2(0.3477937, 0.4048715), vec2(0.4124837, 0.3280935), vec2(0.4687441, 0.3681009), vec2(0.4381135, 0.4406144), vec2(0.3837284, 0.4424897));\nfloat cloth2(vec2 uv)\n{\n    float c = 0.0;\n    rep(i, cloth2Count)\n    {\n        vec2 p0 = cloth2CPoints[i];\n        vec2 p1 = cloth2DPoints[i];\n        vec2 p2 = cloth2CPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        c += smoothstep(Width0, Width0 - RENARD_EPS, abs(d));\n    }\n    return c;\n}\n\nconst int yubi0Count = 3;\nconst vec2 yubi0DPoints[yubi0Count] = vec2[yubi0Count](vec2(0.4154299, 0.469287), vec2(0.4213602, 0.4676646), vec2(0.4269133, 0.4734645));\nconst vec2 yubi0CPoints[yubi0Count + 1] = vec2[yubi0Count + 1](vec2(0.4085882, 0.4879582), vec2(0.4165252, 0.4698948), vec2(0.4263779, 0.4729054), vec2(0.4241884, 0.4819371));\nfloat yubi0(vec2 uv)\n{\n    float c = 0.0;\n    rep(i, yubi0Count)\n    {\n        vec2 p0 = yubi0CPoints[i];\n        vec2 p1 = yubi0DPoints[i];\n        vec2 p2 = yubi0CPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        c += smoothstep(Width1, Width1 - RENARD_EPS, abs(d));\n    }\n    return c;\n}\nconst int yubi1Count = 3;\nconst vec2 yubi1DPoints[yubi1Count] = vec2[yubi1Count](vec2(0.4290129, 0.467969), vec2(0.43514, 0.4685704), vec2(0.4400764, 0.4723018));\nconst vec2 yubi1CPoints[yubi1Count + 1] = vec2[yubi1Count + 1](vec2(0.4263779, 0.4729054), vec2(0.4291148, 0.467979), vec2(0.4397886, 0.4720843), vec2(0.4370517, 0.4844002));\nfloat yubi1(vec2 uv)\n{\n    float c = 0.0;\n    rep(i, yubi1Count)\n    {\n        vec2 p0 = yubi1CPoints[i];\n        vec2 p1 = yubi1DPoints[i];\n        vec2 p2 = yubi1CPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        c += smoothstep(Width1, Width1 - RENARD_EPS, abs(d));\n    }\n    return c;\n}\nconst int yubi2Count = 2;\nconst vec2 yubi2DPoints[yubi2Count] = vec2[yubi2Count](vec2(0.4490034, 0.4700516), vec2(0.4519218, 0.4751893));\nconst vec2 yubi2CPoints[yubi2Count + 1] = vec2[yubi2Count + 1](vec2(0.4397886, 0.4720843), vec2(0.4515572, 0.4745475), vec2(0.4504625, 0.489053));\nfloat yubi2(vec2 uv)\n{\n    float c = 0.0;\n    rep(i, yubi2Count)\n    {\n        vec2 p0 = yubi2CPoints[i];\n        vec2 p1 = yubi2DPoints[i];\n        vec2 p2 = yubi2CPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        c += smoothstep(Width1, Width1 - RENARD_EPS, abs(d));\n    }\n    return c;\n}\nconst int yubi3Count = 2;\nconst vec2 yubi3DPoints[yubi3Count] = vec2[yubi3Count](vec2(0.4584278, 0.4750955), vec2(0.4629927, 0.4813362));\nconst vec2 yubi3CPoints[yubi3Count + 1] = vec2[yubi3Count + 1](vec2(0.4512835, 0.4789265), vec2(0.462231, 0.4802949), vec2(0.4627784, 0.4964425));\nfloat yubi3(vec2 uv)\n{\n    float c = 0.0;\n    rep(i, yubi3Count)\n    {\n        vec2 p0 = yubi3CPoints[i];\n        vec2 p1 = yubi3DPoints[i];\n        vec2 p2 = yubi3CPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        c += smoothstep(Width1, Width1 - RENARD_EPS, abs(d));\n    }\n    return c;\n}\nconst int yubi4Count = 2;\nconst vec2 yubi4DPoints[yubi4Count] = vec2[yubi4Count](vec2(0.4450425, 0.5247965), vec2(0.4733011, 0.4967696));\nconst vec2 yubi4CPoints[yubi4Count + 1] = vec2[yubi4Count + 1](vec2(0.4187147, 0.524085), vec2(0.4518309, 0.5180638), vec2(0.4627784, 0.4835792));\nfloat yubi4(vec2 uv)\n{\n    float c = 0.0;\n    rep(i, yubi4Count)\n    {\n        vec2 p0 = yubi4CPoints[i];\n        vec2 p1 = yubi4DPoints[i];\n        vec2 p2 = yubi4CPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        c += smoothstep(Width1, Width1 - RENARD_EPS, abs(d));\n    }\n    return c;\n}\n\nfloat hand(vec2 uv)\n{\n    float c = 0.0;\n    uv -= vec2(0, -0.1);\n    c += yubi0(uv);\n    c += yubi1(uv);\n    c += yubi2(uv);\n    c += yubi3(uv);\n    c += yubi4(uv);\n    c = saturate(c);\n    return c;\n}\n\nconst int cloth3Count = 1;\nconst vec2 cloth3DPoints[cloth3Count] = vec2[cloth3Count](vec2(0.4380694, 0.5438331));\nconst vec2 cloth3CPoints[cloth3Count + 1] = vec2[cloth3Count + 1](vec2(0.443274, 0.5748128), vec2(0.4371082, 0.5415173));\nfloat cloth3(vec2 uv)\n{\n    uv -= vec2(0, -0.1);\n    float c = 0.0;\n    rep(i, cloth3Count)\n    {\n        vec2 p0 = cloth3CPoints[i];\n        vec2 p1 = cloth3DPoints[i];\n        vec2 p2 = cloth3CPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        c += smoothstep(Width1, Width1 - RENARD_EPS, abs(d));\n    }\n    return c;\n}\n\nconst int cloth4Count = 3;\nconst vec2 cloth4DPoints[cloth4Count] = vec2[cloth4Count](vec2(0.3217941, 0.4189177), vec2(0.3414212, 0.3636141), vec2(0.4198256, 0.3085935));\nconst vec2 cloth4CPoints[cloth4Count + 1] = vec2[cloth4Count + 1](vec2(0.3717685, 0.5494775), vec2(0.3258187, 0.4075773), vec2(0.3665287, 0.3459947), vec2(0.5, 0.3085935));\nfloat cloth4(vec2 uv)\n{\n    uv -= vec2(0, -0.2);\n    float c = 0.0;\n    rep(i, cloth4Count)\n    {\n        vec2 p0 = cloth4CPoints[i];\n        vec2 p1 = cloth4DPoints[i];\n        vec2 p2 = cloth4CPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        c += smoothstep(Width0, Width0 - RENARD_EPS, abs(d));\n    }\n    return c;\n}\nconst int cloth5Count = 8;\nconst vec2 cloth5DPoints[cloth5Count] = vec2[cloth5Count](vec2(0.3464637, 0.5292405), vec2(0.3330419, 0.4968905), vec2(0.3488403, 0.4881146), vec2(0.3534004, 0.4913778), vec2(0.3685941, 0.4689087), vec2(0.3817447, 0.4701243), vec2(0.3817447, 0.5053068), vec2(0.360871, 0.5049469));\nconst vec2 cloth5CPoints[cloth5Count + 1] = vec2[cloth5Count + 1](vec2(0.3574228, 0.5104836), vec2(0.3444231, 0.524322), vec2(0.3364555, 0.4962259), vec2(0.3519713, 0.4903551), vec2(0.3591001, 0.486581), vec2(0.3737772, 0.4693878), vec2(0.3817447, 0.5), vec2(0.3658096, 0.5050321), vec2(0.3574228, 0.5109029));\nfloat cloth5(vec2 uv)\n{\n    float c = 0.0;\n    rep(i, cloth5Count)\n    {\n        vec2 p0 = cloth5CPoints[i];\n        vec2 p1 = cloth5DPoints[i];\n        vec2 p2 = cloth5CPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        c += smoothstep(Width1, Width1 - RENARD_EPS, abs(d));\n    }\n    return c;\n}\nconst int cloth6Count = 1;\nconst vec2 cloth6DPoints[cloth6Count] = vec2[cloth6Count](vec2(0.3497758, 0.5010887));\nconst vec2 cloth6CPoints[cloth6Count + 1] = vec2[cloth6Count + 1](vec2(0.3574228, 0.5104836), vec2(0.3519713, 0.4903551));\nfloat cloth6(vec2 uv)\n{\n    float c = 0.0;\n    rep(i, cloth6Count)\n    {\n        vec2 p0 = cloth6CPoints[i];\n        vec2 p1 = cloth6DPoints[i];\n        vec2 p2 = cloth6CPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        c += smoothstep(Width1, Width1 - RENARD_EPS, abs(d));\n    }\n    return c;\n}\nconst int cloth7Count = 1;\nconst vec2 cloth7DPoints[cloth7Count] = vec2[cloth7Count](vec2(0.3610872, 0.5016757));\nconst vec2 cloth7CPoints[cloth7Count + 1] = vec2[cloth7Count + 1](vec2(0.3653903, 0.5050321), vec2(0.3599388, 0.4857423));\nfloat cloth7(vec2 uv)\n{\n    float c = 0.0;\n    rep(i, cloth7Count)\n    {\n        vec2 p0 = cloth7CPoints[i];\n        vec2 p1 = cloth7DPoints[i];\n        vec2 p2 = cloth7CPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        c += smoothstep(Width1, Width1 - RENARD_EPS, abs(d));\n    }\n    return c;\n}\nconst int cloth8Count = 14;\nconst vec2 cloth8DPoints[cloth8Count] = vec2[cloth8Count](vec2(0.3161924, 0.5010245), vec2(0.3196588, 0.4995523), vec2(0.3105778, 0.4853926), vec2(0.3202754, 0.4797249), vec2(0.3130877, 0.4634204), vec2(0.328211, 0.456277), vec2(0.3229529, 0.4423806), vec2(0.3446856, 0.4311638), vec2(0.3452047, 0.4206082), vec2(0.3752044, 0.4128887), vec2(0.3743577, 0.4028694), vec2(0.4035521, 0.3927736), vec2(0.4306011, 0.3767013), vec2(0.4900789, 0.3740177));\nconst vec2 cloth8CPoints[cloth8Count + 1] = vec2[cloth8Count + 1](vec2(0.3269451, 0.5184976), vec2(0.3166687, 0.5008222), vec2(0.3195461, 0.499178), vec2(0.3125581, 0.4839689), vec2(0.320324, 0.4790379), vec2(0.3174908, 0.4601276), vec2(0.3275966, 0.4546533), vec2(0.333158, 0.4371135), vec2(0.3447086, 0.4306965), vec2(0.3601094, 0.4152957), vec2(0.3750824, 0.4114455), vec2(0.4013464, 0.3935364), vec2(0.420255, 0.3828489), vec2(0.4593054, 0.3799715), vec2(0.5, 0.3799715));\nfloat cloth8(vec2 uv)\n{\n    float c = 0.0;\n    rep(i, cloth8Count)\n    {\n        vec2 p0 = cloth8CPoints[i];\n        vec2 p1 = cloth8DPoints[i];\n        vec2 p2 = cloth8CPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        c += smoothstep(Width0, Width0 - RENARD_EPS, abs(d));\n    }\n    return c;\n}\n\nfloat ribbon2(vec2 uv)\n{\n    uv -= vec2(0, -0.3);\n    float c = 0.0;\n    c += cloth5(uv);\n    c += cloth6(uv);\n    c += cloth7(uv);\n    c += cloth8(uv);\n    return c;\n}\n\nconst int cloth9Count = 5;\nconst vec2 cloth9DPoints[cloth9Count] = vec2[cloth9Count](vec2(0.4296511, 0.4941425), vec2(0.4255559, 0.4918793), vec2(0.4341358, 0.4791419), vec2(0.4463012, 0.4745635), vec2(0.4588898, 0.4593591));\nconst vec2 cloth9CPoints[cloth9Count + 1] = vec2[cloth9Count + 1](vec2(0.4114454, 0.5000001), vec2(0.429413, 0.4940109), vec2(0.4255628, 0.4918719), vec2(0.4366856, 0.4781823), vec2(0.4525142, 0.4670595), vec2(0.4816046, 0.4593591));\nfloat cloth9(vec2 uv)\n{\n    float c = 0.0;\n    rep(i, cloth9Count)\n    {\n        vec2 p0 = cloth9CPoints[i];\n        vec2 p1 = cloth9DPoints[i];\n        vec2 p2 = cloth9CPoints[i + 1];\n        float d = sdBezier(uv, p0, p1, p2);\n        c += smoothstep(Width0, Width0 - RENARD_EPS, abs(d));\n    }\n    return c;\n}\n\nfloat body(vec2 uv)\n{\n    vec2 auv = uv;\n    auv.x = 0.5 - abs(uv.x - 0.5);\n    float c = 0.0;\n    c += neck(auv);\n    c += cloth0(auv);\n    c += cloth1(auv);\n    c += sakotsu(auv);\n    c += ribbon0(auv);\n    c += ribbon1(auv);\n    c += cloth2(auv);\n    vec2 huv = auv + vec2(0, 0.0015 * sin(time * 2.0));\n    c += hand(huv);\n    // いらんかも\n    c += cloth3(auv);\n    c += cloth4(auv);\n    c += ribbon2(auv);\n    c += cloth9(auv);\n    c = saturate(c);\n    return c;\n}\n\nfloat renard(vec2 uv, int faceType)\n{\n    FACE_TYPE = faceType;\n    RENARD_EPS = getEPS(uv) * 2.0;\n    float c = 0.0;\n    uv += vec2(0.5, 0.5693037);\n    vec2 fuv = uv;\n    fuv -= vec2(0.5, 0.5693037);\n    fuv *= rot(sin(time * .8 + 42.42) * 0.08);\n    fuv += vec2(0.5, 0.5693037);\n\n    c += mimi(fuv);\n    c += hair(fuv);\n    c += face(fuv);\n    c += body(uv);\n    c = saturate(c);\n    return c;\n}\n\nfloat sdNikuq(vec2 uv)\n{\n    uv.x = abs(uv.x);\n    float d = length(uv - vec2(0, -0.1)) - 0.25;\n    d = min(d, length(uv - vec2(0.35, 0.1)) - 0.1);\n    d = min(d, length(uv - vec2(0.15, 0.3)) - 0.1);\n    return d;\n}\n\n// \n// .%%...%%...%%%%...%%%%%%..%%..%%.\n// .%%%.%%%..%%..%%....%%....%%%.%%.\n// .%%.%.%%..%%%%%%....%%....%%.%%%.\n// .%%...%%..%%..%%....%%....%%..%%.\n// .%%...%%..%%..%%..%%%%%%..%%..%%.\n// .................................\n// \n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 fc = gl_FragCoord.xy.xy, res = resolution.xy, asp = resolution.xy / min(resolution.x, resolution.y);\n    vec2 uv = fc / res, suv = (uv * 2.0 - 1.0) * asp;\n    vec3 col = vec3(0);\n\n    // nikuq\n    suv.x += time * 0.25;\n    vec2 uvq = suv * 4.0, uvf = fract(uvq), uvi = floor(uvq);\n    vec3 ers = pcg33(vec3(uvi, 2));\n    uvf -= vec2(0.5);\n    uvf /= ers.x * 0.8 + 0.1;\n    uvf *= rot(ers.y * TAU);\n    float dq = ers.z < 0.6 ? sdNikuq(uvf) : 0.0;\n    float cq = smoothstep(0.0, 0.0 - RENARD_EPS, dq);\n    vec3 bg0 = hex2rgb(0xD8F0EC), bg1 = hex2rgb(0xE9B384);\n    col += mix(bg0, bg1, cq);\n\n    // TDF\n    const float w = 0.1;\n    const float r = 0.1;\n    vec2 tuv = suv * 1.2;\n    float l = getEPS(tuv) * 2.0;\n    float c = 0.0, d;\n\n    // tuv.x += time * 0.25;\n    float id = floor(tuv.x / (1.0 + 2.0 * r));\n    float lt = time * 0.25 + id * 0.25;\n    lt = floor(lt) + pow(fract(lt), 0.3);\n    tuv.x = mod(tuv.x, 3.0 + 6.0 * r) - r;\n    tuv.y = mod(tuv.y + 2.4 + lt * 3.0, 3.0) - 2.3;\n\n    vec2 uv0 = tuv, uv1 = tuv - vec2(1.0 + 2.0 * r, 0), uv2 = tuv - vec2(2.0 + 4.0 * r, 0);\n\n    // T\n    d = sdBox(uv0 - vec2(0.5, 0.5), vec2(0.4, 0));\n    d = min(d, sdBox(uv0 - vec2(0.5, 0), vec2(0, 0.5)));\n    // D\n    uv1 = (uv1 - vec2(0.4, 0)) * rot(-0.5 * PI);\n    d = min(d, sdTunnel(uv1, vec2(0.5, 0.3)));\n    // F\n    d = min(d, sdBox(uv2 - vec2(0.1, 0), vec2(0, 0.5)));\n    d = min(d, sdBox(uv2 - vec2(0.5, 0.5), vec2(0.4, 0)));\n    d = min(d, sdBox(uv2 - vec2(0.5, 0), vec2(0.4, 0)));\n\n    d -= r;\n    d = abs(d + w) - w;\n    c += smoothstep(l, 0.0, d);\n\n    // renard\n    tuv.x = mod(tuv.x + r, 1.0 + 2.0 * r) - r;\n    vec2 ruv0 = tuv - vec2(0.5, -1.3);\n    float re = renard(ruv0 * 0.5, 1);\n\n    // waku\n    c += step(0.58, abs(tuv.x - 0.5));\n    c += step(0.66, tuv.y);\n\n    c += re;\n\n    col = mix(col, hex2rgb(0xF0D8D8) * 0.5, saturate(c));\n\n    outColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}