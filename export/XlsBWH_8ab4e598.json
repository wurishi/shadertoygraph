{"ver":"0.1","info":{"id":"XlsBWH","date":"1511789242","viewed":218,"name":"Fjords","username":"Draedrus","description":"fjords inspired shader, tried to do a post processing water and cheap clouds","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["reflection","clouds","water","ssr","fjords"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy);\n    float epsX = 0.8/iResolution.x;\n    float epsY = 0.8/iResolution.y;\n    \n    fragColor = vec4(0.0);\n    fragColor += vec4(texture(iChannel0, uv+vec2(-epsX, 0.0)).rgb, 1.0);\n    fragColor += vec4(texture(iChannel0, uv+vec2(0.0, -epsY)).rgb, 1.0);\n    fragColor += vec4(texture(iChannel0, uv+vec2(+epsX, 0.0)).rgb, 1.0);\n    fragColor += vec4(texture(iChannel0, uv+vec2(0.0, +epsY)).rgb, 1.0);\n    fragColor /= 4.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define CAMPOS vec3(0.0, 1.0, 20.0)\n#define CAMLOOKAT vec3(0.0, 1.0, 0.0)\n\n#define TERRAIN_HEIGHT -4.5\n#define MOUNTAIN_AMP 12.0\n\n#define CAMERA_FAR 200.0\n#define CAMERA_NEAR 0.1\n\n#define WATER_BASE_LEVEL -1.8\n\n/** TOOLS **/\n\nvec2 rot(vec2 X, float a)\n{\n \tfloat s = sin(a); float c = cos(a);\n    return mat2(c, -s, s, c)*X;\n}\n\n/** HASH **/\n\nfloat hash(vec2 uv)\n{\n \tvec2 suv = sin(uv);\n    suv = rot(suv, uv.x);\n    return fract(mix(suv.x*13.13032942, suv.y*12.01293203924, dot(uv, suv)));\n}\n\nfloat custom_perlin_hash(vec2 uv)\n{\n \tvec2 lower\t= floor(uv);\n    vec2 frac \t= fract(uv);\n    vec2 f = frac*frac*(3.0-2.0*frac);\n    \n    return mix(\n        \tmix(hash(lower+vec2(0.0, 0.0)), hash(lower+vec2(1.0, 0.0)), f.x),\n        \tmix(hash(lower+vec2(0.0, 1.0)), hash(lower+vec2(1.0, 1.0)), f.x),\n        \tf.y);\n}\n\nfloat fbm_hash(vec2 uv)\n{\n    float total = 0.0;\n    total += 0.5000*custom_perlin_hash(uv); uv*=2.001;\n    total += 0.2500*custom_perlin_hash(uv); uv*=2.003;\n    total += 0.1250*custom_perlin_hash(uv); uv*=2.002;\n    total += 0.0625*custom_perlin_hash(uv); uv*=2.001;\n    return clamp(total, 0.0, 1.0);\n}\n\nfloat hash3D(vec3 uv)\n{\n \tvec3 suv = fract(sin(uv));\n    mat3 rdz = mat3(0.324354, 0.303147, 0.21024,\n                    0.405434, 0.723953, 0.69343,\n                    0.904379, 0.594319, 0.10439);\n    suv = rdz*suv;\n    return fract(dot(suv, uv)*1204.9324234934);\n}\n\nfloat custom_perlin_hash3D(vec3 uv)\n{\n \tvec3 lower\t= floor(uv);\n    vec3 frac \t= fract(uv);\n    vec3 f = frac*frac*(3.0-2.0*frac);\n    \n    return mix( // Z\n        \tmix( // Y\n                mix( // X\n                    hash3D(lower+vec3(0.0, 0.0, 0.0)), hash3D(lower+vec3(1.0, 0.0, 0.0)), f.x),\n                mix( // X\n                    hash3D(lower+vec3(0.0, 1.0, 0.0)), hash3D(lower+vec3(1.0, 1.0, 0.0)), f.x),\n                f.y),\n        \tmix( // Y\n                mix( // X\n                    hash3D(lower+vec3(0.0, 0.0, 1.0)), hash3D(lower+vec3(1.0, 0.0, 1.0)), f.x),\n                mix( // X\n                    hash3D(lower+vec3(0.0, 1.0, 1.0)), hash3D(lower+vec3(1.0, 1.0, 1.0)), f.x),\n                f.y),\n        \tf.z);\n}\n\nfloat fbm_hash3D(vec3 uv)\n{\n    float total = 0.0;\n    total += 0.5000*custom_perlin_hash3D(uv); uv*=2.001;\n    total += 0.2500*custom_perlin_hash3D(uv); uv*=2.003;\n    total += 0.1250*custom_perlin_hash3D(uv); uv*=2.002;\n    total += 0.0625*custom_perlin_hash3D(uv); uv*=2.001;\n    return clamp(total, 0.0, 1.0);\n}\n\nfloat voronoi(vec2 uv) {\n    vec2 fl = floor(uv);\n    vec2 fr = fract(uv);\n    float res = 1.0;\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec2 p = vec2(i, j);\n            float h = hash(fl+p);\n            //h += 0.5-0.5*sin(iTime*0.8+h);\n            vec2 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            //res = min(res, d);\n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    //return sqrt(res);\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nfloat voronoi3D(vec3 p) {\n    vec3 fl = floor(p);\n    vec3 fr = fract(p);\n    float res = 1.0;\n    for(int k=-1;k<=1;k++) {\n        for( int j=-1; j<=1; j++ ) {\n            for( int i=-1; i<=1; i++ ) {\n                vec3 fp = vec3(i, j, k);\n                float h = hash3D(fl+fp);\n                //h += 0.5-0.5*sin(iTime*0.8+h);\n                vec3 vp = fp-fr+h;\n                float d = dot(vp, vp);\n\n                //res = min(res, d);\n                res +=1.0/pow(d, 8.0);\n            }\n        }\n    }\n    //return sqrt(res);\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nvec3 voronoi3DP(vec3 p) {\n    vec3 fl = floor(p);\n    vec3 fr = fract(p);\n    vec2 pxz = vec2(0.0);\n    float res = 1.0;\n    for(int k=-1;k<=1;k++) {\n        for( int j=-1; j<=1; j++ ) {\n            for( int i=-1; i<=1; i++ ) {\n                vec3 fp = vec3(i, j, k);\n                float h = hash3D(fl+fp);\n                //h += 0.5-0.5*sin(iTime*0.8+h);\n                vec3 vp = fp-fr+h;\n                float d = dot(vp, vp);\n\n                //res = min(res, d);\n                res +=1.0/pow(d, 8.0);\n                if(d<res) {\n                    pxz = vp.xz;\n                }\n            }\n        }\n    }\n    //return sqrt(res);\n    res = pow( 1.0/res, 1.0/16.0 );\n    return vec3(res, pxz);\n}\n\n/**\nRAYMARCHING PLANE NOISE\n**/\n\nfloat sdEllipsoidY( in vec3 p, in vec2 r )\n{\n    return (length( p/r.xyx ) - 1.0) * r.x;\n}\n\nfloat map_trees(vec3 p)\n{\n\tfloat d = 100.0;\n\tvec2 n = floor( p.xz );\n    vec2 f = fract( p.xz );\n    for( int j=-1; j<=1; j++ )\n\tfor( int i=-1; i<=1; i++ )\n\t{\n\t\tvec2  g = vec2( float(i), float(j) );\n\t\tvec2  o = vec2(hash( n + g ), hash(n+g));\n        vec2  v = vec2(hash( n + g + vec2(0.5,0.5) ), hash( n + g + vec2(0.5,0.5) ));\n\t\tvec2  r = g - f + o;\n\n        // tree max height\n        float height = 0.1 * (0.4+0.3*v.x);\n        float width = 0.2*(0.01 + 0.2*v.x + 0.1*v.y);\n        vec3  q = vec3(r.x,p.y-height*0.9,r.y);\n        float k = sdEllipsoidY( q, vec2(width*0.8,height*0.6) );\n\n        d = min(d, k);\n\t}\n\treturn d;\n}\nvec2 mapTerrain(vec3 p)\n{\n\tvec2 rm = vec2(\n        p.y + TERRAIN_HEIGHT\n        +MOUNTAIN_AMP*fbm_hash(p.xz*0.1)\n        + 0.3*fbm_hash(p.xz*2.0)\n        //+MOUNTAIN_HEIGHT*fbm_hash(p.xz*0.05)\n        , 0.0);\n    \n    float heigh = clamp((p.y-(-1.4))*1.0, -2.0, 1.5);\n    \n    float forest = (rm.x + max(0.0, heigh*(fbm_hash3D(p*0.1)-0.3)*2.5)\n        *0.9*min(0.7, voronoi(p.xz*5.0)));\n    \n    rm.x = max(rm.x, forest);//mix(rm.x, forest, max(0.0, p.y-(-1.4))*1.0);\n    rm.y = clamp(max(0.0, (forest-rm.y)*5.0), 0.0, 1.0);\n    return rm;\n}\n\nvec2 raymarching(vec3 ro, vec3 rd, float tmin, float tmax)\n{\n    vec2 res = vec2(0.0, -1.0);\n    for(int i=0;i<80;i++)\n    {\n        vec2 di = mapTerrain(ro+rd*res.x);\n        if(di.x<tmin || res.x>tmax)\n            break;\n        res.x += di.x*0.5*log(1.0f+float(i));\n        res.y = di.y;\n    }\n    res.x = clamp(res.x, tmin, tmax);\n    return res;\n}\n\nvec3 mapNormal(vec3 pt, float e) {\n    vec3 normal;\n    normal.y = mapTerrain(pt).x;\n    normal.x = mapTerrain(vec3(pt.x+e,pt.y,pt.z)).x - normal.y;\n    normal.z = mapTerrain(vec3(pt.x,pt.y,pt.z+e)).x - normal.y;\n    normal.y = e;\n    return normalize(normal);\n}\n\n/** END RAYMARCHING **/\n\n// the camera construction method is inspired by the one from IQ\nmat3 setCamera( in vec3 origin, in vec3 target, vec3 viewUp )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cu = normalize( cross(cw,viewUp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n// https://www.shadertoy.com/view/lstSRS\nvec3 tonemapping(vec3 color)\n{\n    //Tonemapping and color grading\n    color = pow(color, vec3(1.5));\n    color = color / (1.0 + color);\n    color = pow(color, vec3(1.0 / 1.5));\n\n    \n    color = mix(color, color * color * (3.0 - 2.0 * color), vec3(1.0));\n    color = pow(color, vec3(1.3, 1.20, 1.0));    \n\n\tcolor = clamp(color * 1.01, 0.0, 1.0);\n    \n    color = pow(color, vec3(0.7 / 2.2));\n    return color;\n}\n\nvec2 normal_pack(vec3 n)\n{\n    return n.xy*0.5+0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy);\n    vec2 pixel = -1.0 + 2.0*uv;// vec2(iResolution.x*0.6, iResolution.y);\n\tpixel.x *= iResolution.x/iResolution.y;\n    vec2 uvo = uv*5.0;\n    vec2 uvr = rot(uvo-(floor(uvo*1.0)), iTime);\n\n    // camera\n    vec3 ro = CAMPOS;\n    vec3 rd = normalize(vec3(-1.0-uv*2.0, 1.0));\n    mat3 ca = setCamera(ro, CAMLOOKAT, vec3(0.0, 1.0, 0.0));\n    rd = ca*normalize(vec3(pixel.xy, 2.0));\n    // end camera\n\n    // raymarch\n    vec2 rm = raymarching(\n        ro,\n        rd,\n        CAMERA_NEAR, CAMERA_FAR);\n    // end raymarch\n    if(rm.x>CAMERA_FAR*0.7)\n    {\n        rm.x = mix(rm.x, CAMERA_FAR, rm.x/(CAMERA_FAR*0.7));\n    }\n    \n    vec2 n = normal_pack(normalize(mapNormal(ro+rd*rm.x, 0.0001)));\n    \n    fragColor = vec4(rm.x, rm.y, n.x, n.y);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// camera\n#define CAMPOS vec3(0.0, 1.0, 20.0)\n#define CAMLOOKAT vec3(0.0, 1.0, 0.0)\n\n// HDR sky parameters\n#define SCALE_HEIGHT\t\t 8000.0\n#define SUNDIST \t149597870700.0\n#define EARTHRADIUS\t\t\t 6360e3\n#define ATMOSPHERERADIUS \t6420e3\n#define SUNINTENSITY\t\t 20.0\n#define SUNRADIUS \t  695700000.0\n#define MOONRADIUS \t\t1737400.0\n#define EARTHPOS vec3(0.0, 0.0, 0.0)\n\n// light\n#define SUNPOS vec3(-SUNDIST*0.3, SUNDIST*0.00, -SUNDIST)\n\n// environment\n#define WATER_FREQ 0.6\n#define WATER_AMP 0.1000\n#define WATER_SPEED 0.50\n#define WATER_BASE_LEVEL -1.8\n\n#define COLOR_SAND vec3(0.4, 0.3, 0.2)\n\n#define TERRAIN_HEIGHT -4.0\n#define MOUNTAIN_AMP 12.0\n\n#define CAMERA_FAR 200.0\n#define CAMERA_NEAR 0.1\n\n#define TIME mix(0.0, 20.0*3.1418, fract(0.01*(iTime+18.19)))\n\nvec3 SUN_POS = SUNPOS;\n\n#define SUN_DIR normalize(CAMLOOKAT-SUN_POS)\n\n/** TOOLS **/\n\nfloat IntersectSphere(vec3 ro, vec3 rd, vec3 sc, float sr, out float tmin, out float tmax) {\n    vec3 Z = ro-sc;\n    float B = 2.0 * dot(rd, Z);\n    float C = Z.x*Z.x+Z.y*Z.y+Z.z*Z.z-sr*sr;\n    float D = B*B - 4.0*C;\n    float d = -1.0;\n    if(D>=0.0) {\n        if(C==0.0) {\n            tmax = -B/2.0;\n            d = 0.0;\n        }else{\n            tmin = (-B-sqrt(D))/2.0;\n            tmax = (-B+sqrt(D))/2.0;\n            d = 1.0;\n        }\n    }\n    return d;\n}\n\nfloat IntersectPlane(vec3 ro, vec3 rd, vec3 po, vec3 pn) {\n    float Vd = dot(rd, pn);\n    float t = -1.0;\n    float d = -1.0;\n    if(Vd<0.0) {\n        float V0 = -(dot(pn, ro)+length(po-ro));\n        float t = V0/Vd;\n        if(t>=0.0) {\n            d = t;\n        }\n    }\n    return d;\n}\n\nvec2 rot(vec2 X, float a)\n{\n \tfloat s = sin(a); float c = cos(a);\n    return mat2(c, -s, s, c)*X;\n}\n\nvec3 rot3D(vec3 X, float a)\n{\n \tfloat s = sin(a); float c = cos(a);\n    mat3 rotX = mat3(1.0, 0.0, 0.0,\n                     0.0, c, -s,\n                     0.0, s, c);\n    mat3 rotY = mat3(c, 0.0, -s,\n                     0.0, 1.0, 0.0,\n                     s, 0.0, c);\n    mat3 rotZ = mat3(c, -s, 0.0,\n                     s, c, 0.0,\n                     0.0, 0.0, 1.0);\n                     \n    return rotX*rotY*rotZ*X;\n}\n\n/** HASH **/\n\nfloat hash(vec2 uv)\n{\n \tvec2 suv = sin(uv);\n    suv = rot(suv, uv.x);\n    return fract(mix(suv.x*13.13032942, suv.y*12.01293203924, dot(uv, suv)));\n}\n\nfloat custom_perlin_hash(vec2 uv)\n{\n \tvec2 lower\t= floor(uv);\n    vec2 frac \t= fract(uv);\n    vec2 f = frac*frac*(3.0-2.0*frac);\n    \n    return mix(\n        \tmix(hash(lower+vec2(0.0, 0.0)), hash(lower+vec2(1.0, 0.0)), f.x),\n        \tmix(hash(lower+vec2(0.0, 1.0)), hash(lower+vec2(1.0, 1.0)), f.x),\n        \tf.y);\n}\n\nfloat fbm_hash(vec2 uv)\n{\n    float total = 0.0;\n    total += 0.5000*custom_perlin_hash(uv); uv*=2.001;\n    total += 0.2500*custom_perlin_hash(uv); uv*=2.003;\n    total += 0.1250*custom_perlin_hash(uv); uv*=2.002;\n    total += 0.0625*custom_perlin_hash(uv); uv*=2.001;\n    return clamp(total, 0.0, 1.0);\n}\n\n// 3D hash\n\n\nfloat hash3D(vec3 uv)\n{\n \tvec3 suv = fract(sin(uv));\n    mat3 rdz = mat3(0.324354, 0.303147, 0.21024,\n                    0.805434, 0.403953, 0.89343,\n                    0.504379, 0.594319, 0.10439);\n    suv = rdz*suv;\n    return fract(dot(suv, uv)*1204.9324234934);\n}\n\nfloat custom_perlin_hash3D(vec3 uv)\n{\n \tvec3 lower\t= floor(uv);\n    vec3 frac \t= fract(uv);\n    vec3 f = frac*frac*(3.0-2.0*frac);\n    \n    return mix( // Z\n        \tmix( // Y\n                mix( // X\n                    hash3D(lower+vec3(0.0, 0.0, 0.0)), hash3D(lower+vec3(1.0, 0.0, 0.0)), f.x),\n                mix( // X\n                    hash3D(lower+vec3(0.0, 1.0, 0.0)), hash3D(lower+vec3(1.0, 1.0, 0.0)), f.x),\n                f.y),\n        \tmix( // Y\n                mix( // X\n                    hash3D(lower+vec3(0.0, 0.0, 1.0)), hash3D(lower+vec3(1.0, 0.0, 1.0)), f.x),\n                mix( // X\n                    hash3D(lower+vec3(0.0, 1.0, 1.0)), hash3D(lower+vec3(1.0, 1.0, 1.0)), f.x),\n                f.y),\n        \tf.z);\n}\n\nfloat fbm_hash3D(vec3 uv)\n{\n    float total = 0.0;\n    total += 0.5000*custom_perlin_hash3D(uv); uv*=2.001;\n    total += 0.2500*custom_perlin_hash3D(uv); uv*=2.003;\n    total += 0.1250*custom_perlin_hash3D(uv); uv*=2.002;\n    total += 0.0625*custom_perlin_hash3D(uv); uv*=2.001;\n    return clamp(total, 0.0, 1.0);\n}\n\n/** WATER LEVEL **/\n\n\nfloat getWaterLevel(vec3 p)\n{\n\treturn WATER_BASE_LEVEL +\n        WATER_AMP*(\n        \t(fbm_hash(p.xz*WATER_FREQ+TIME*WATER_SPEED)\n       \t\t + fbm_hash(p.xz*WATER_FREQ-TIME*WATER_SPEED)\n            )\n            );\n}\n\n/*float getWaterDetailsLevel(vec3 p)\n{\n    return WATER_AMP*fbm_hash(p.xz*WATER_FREQ+TIME*WATER_SPEED*0.05);\n\treturn p.y+WATER_BASE_LEVEL +\n        WATER_AMP*(\n        \t(fbm_hash(p.xz*WATER_FREQ+TIME*WATER_SPEED*1.000)\n       \t\t + fbm_hash(p.xz*WATER_FREQ-TIME*WATER_SPEED*1.000)\n            )\n            );\n}*/\nfloat getWaterDetailsLevel(vec3 p)\n{\n    float h = 0.0;\n    vec3 op = p;\n    #ifdef FLOOD\n    float w = (-p.z+sin(TIME*WAVES_SPEED))*FLOOD_AMP;\n    #endif\n    float a = WATER_AMP;\n    float f = WATER_FREQ;\n    float T = TIME*WATER_SPEED;\n    //h = 0.2*(-1.0+fbm_hash(p.xz+TIME)+fbm_hash(p.xz-TIME)); \n    h = a*(-1.0+fbm_hash3D(p*f+T)+fbm_hash3D(p*f-T)); \n    //for(int i=0;i<5;++i) {\n    //}\n    /*#ifdef WAVES\n    h+= wave(op,\n             mix(0.05, 0.9, min(1.0, max(0.0,p.z)/3.2)),\n             T*5.0)\n        *gaussianNoise(op.xz*0.1+T);\n    #endif*/\n    #ifdef FLOOD\n    return h+w;\n    #else\n    return h;\n    #endif   \n}\n/** END WATER LEVEL **/\n\n/**\nRAYMARCHING PLANE NOISE\n**/\n\nvec2 mapTerrain(vec3 p)\n{\n    vec2 rm = vec2(\n        p.y + TERRAIN_HEIGHT\n        +MOUNTAIN_AMP*fbm_hash(p.xz*0.1)\n        //+MOUNTAIN_HEIGHT*fbm_hash(p.xz*0.05)\n        , 0.0);\n    \n    \n    return rm;\n}\n\nvec2 raymarching(vec3 ro, vec3 rd, float tmin, float tmax)\n{\n    vec2 res = vec2(0.0, -1.0);\n    for(int i=0;i<80;i++)\n    {\n        vec2 di = mapTerrain(ro+rd*res.x);\n        if(di.x<tmin || res.x>tmax)\n            break;\n        res.x += di.x*0.5*log(1.0f+float(i));\n        res.y = di.y;\n    }\n    res.x = clamp(res.x, tmin, tmax);\n    return res;\n}\n\nvec3 mapNormal(vec3 pt, float e) {\n    vec3 normal;\n    normal.y = mapTerrain(pt).x;\n    normal.x = mapTerrain(vec3(pt.x+e,pt.y,pt.z)).x - normal.y;\n    normal.z = mapTerrain(vec3(pt.x,pt.y,pt.z+e)).x - normal.y;\n    normal.y = e;\n    return normalize(normal);\n}\n\nvec3 mapNormalWater(vec3 pt, float e) {\n    vec3 normal;\n    normal.y = pt.y+getWaterDetailsLevel(pt);\n    normal.x = pt.y+getWaterDetailsLevel(vec3(pt.x+e,pt.y,pt.z)) - normal.y;\n    normal.z = pt.y+getWaterDetailsLevel(vec3(pt.x,pt.y,pt.z+e)) - normal.y;\n    normal.y = e;\n    return normalize(normal);\n}\n\n/** END RAYMARCHING **/\n\n/** RENDERING **/\n\n\n// From http://www.scratchapixel.com/old/lessons/3d-advanced-lessons/simulating-the-colors-of-the-sky/atmospheric-scattering/\nvec3 atmosphereScattering(vec3 ro, vec3 rd, vec3 L)\n{\n    vec3 light = vec3(0.0);\n    float tmin = 0.0;\n    float tmax = 0.0;\n    float d = IntersectSphere(ro, rd, EARTHPOS, ATMOSPHERERADIUS, tmin, tmax);\n    vec3 Pa = ro+rd*tmax;\n    /*if(d>0.0)\n        Pa = ro+rd*(tmax-tmin);*/\n    float RdotL = dot(rd, L);\n    float tCurrent = 0.0;\n    float segL = tmax/16.0;\n    /*if(d>0.0)\n        segL = (tmax-tmin)/16.0;*/\n    float g = 0.76; // 0.76\n    float hr = 7994.0; // 7994\n    float hm = 1200.0; // 1200\n    // Rayleigh\n    vec3 sumR = vec3(0.0);\n    float phaseR = 3.0/(16.0*3.14)*(1.0+RdotL*RdotL);\n    vec3 betaR = vec3(5.5e-6, 13.0e-6, 22.4e-6);\n    float opticalDepthR = 0.0;\n    // Mie\n    vec3 sumM = vec3(0.0);\n    float phaseM = 3.0/(8.0*3.14)*((1.0-g*g)+(1.0+RdotL*RdotL))/((2.0+g*g)+pow(1.0+g*g-2.0*g*RdotL, 1.5));\n    vec3 betaM = vec3(21e-6);\n    float opticalDepthM = 0.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        vec3 X = ro+rd*(tCurrent+0.5*segL);\n        float h = length(X) - EARTHRADIUS;\n        float _hr = exp(-h/hr)*segL;\n        float _hm = exp(-h/hm)*segL;\n        opticalDepthR += _hr;\n        opticalDepthM += _hm;\n        vec3 lRay = L;//normalize((SUNDIST*L)-X);\n        float tlmin = 0.0;\n        float tlmax = 0.0;\n        float dl = IntersectSphere(X, L, EARTHPOS, ATMOSPHERERADIUS, tlmin, tlmax);\n        float segLLight = tlmax/8.0;\n        float tCurrentLight = 0.0;\n        float opticalDepthLightR = 0.0;\n        float opticalDepthLightM = 0.0;\n        bool ended = true;\n        for (int j = 0; j < 8; ++j)\n        {\n            vec3 samplePositionLight = X+L*(tCurrentLight + 0.5 * segLLight);\n            float hLight = length(samplePositionLight) - EARTHRADIUS;\n            if (hLight < 0.0)\n            {\n                ended = false;\n                break;\n            }\n            opticalDepthLightR += exp(-hLight / hr) * segLLight;\n            opticalDepthLightM += exp(-hLight / hm) * segLLight;\n            tCurrentLight += segLLight;\n        }\n        if (ended)\n        {\n            vec3 tau = betaR * (opticalDepthR + opticalDepthLightR) + betaM * 1.1 * (opticalDepthM + opticalDepthLightM);\n            vec3 attenuation = vec3(exp(-tau.x), exp(-tau.y), exp(-tau.z));\n            sumR += _hr * attenuation;\n            sumM += _hm * attenuation;\n        }\n        tCurrent += segL;\n    }\n    return SUNINTENSITY * (sumR * phaseR * betaR + sumM * phaseM * betaM);\n}\n\n// bezier bisibility\n//A*(1-T)^3+3*B*(1-T)^2*T+3*C*(1-T)*T^2+D*T^3 with A = 0, B = 0.2 & C = 1.0 & D = 1.0\n//#define VISIBILITY(T) 0.0*(1.0-T)*(1.0-T)*(1.0-T)+3.0*0.0*(1-T)*(1-T)*T+3.0*1.0*(1.0-T)*T*T+1.0*T*T*T\n\nfloat VISIBILITY(float T)\n{\n    return 0.0*(1.0-T)*(1.0-T)*(1.0-T)+3.0*0.0*(1.0-T)*(1.0-T)*T+3.0*1.0*(1.0-T)*T*T+1.0*T*T*T;\n}\n\nvec3 getSkyLight(vec3 ro, vec3 rd, vec3 L, out vec3 mieColor)\n{\n    float g = 0.76; // 0.76\n    float g2 = g*g;\n    float RdotL = max(0.0, dot(rd, normalize(SUN_POS-CAMPOS)));\n    vec3 betaR = vec3(22.5e-6, 13.0e-6, 6.4e-6);\n    vec3 betaM = vec3(21e-6);\n    float phaseR = 3.0/(16.0*3.14)*(1.0+RdotL*RdotL);\n    float phaseM = (\n        (3.0*(1.0-g2))/\n        (2.0*(2.0+g2))\n    )*\n        (\n            (1.0+RdotL*RdotL)/\n            pow(1.0+g2-2.0*g*RdotL, 1.5)\n        );\n    vec3 as = atmosphereScattering(ro+vec3(0.0, EARTHRADIUS+20.0, 0.0), rd, -L);\n    float disc = max(0.0, RdotL)*90.0/180.0;\n    as += pow(disc, 20.0)*phaseM*2e9*betaR;\n    \n    float tmin, tmax;\n    float d = IntersectSphere(ro\n                                  , rd\n                                  , vec3(0.0, ro.y-2000.0, 0.0)\n                                  , 2000.0-ro.y\n                                  , tmin, tmax);\n    float c = 0.0;\n    float r = 0.0;\n    float near = 0.0;\n    float far = 10.0;\n    vec3 roc = ro+rd*tmin;\n    vec3 rdc = rd;//-normalize(SUNPOS-roc);\n    \n    float e = 1.0;\n    \n    float sumR = 0.0;\n    float sumM = 0.0;\n    for(int i = 0; i <10; i++)\n    {\n        vec3 P = (roc+rdc*r);\n        float noise = fbm_hash3D(\n            (P*0.002+vec3(0.0, 0.0, 0.0)).xyz\n            +vec3(0.0, 0.0, 1.1*TIME)) ;\n        float t = max(0.0, noise);\n        if(t<0.01 || r>far*noise)\n            break;\n        r += t;\n        float RdotLC = max(0.0, dot(rdc, -normalize(P-SUN_POS)));\n        //sumR += t/far*RdotLC;\n        //sumM += t/far*4.0*noise;\n        sumR += t/far*4.0*noise;\n    }\n    float den = r/20.0;//(far-r)/(far-near);\n    c = clamp((r-near)/(far-near), 0.0, 1.0);\n    //c = (far-r)/(far-near);\n    float minc = 0.2;\n    //c = mix(0.0, 1.0, clamp((c-minc)/(1.0-minc), 0.0, 1.0));\n    float zone = max(0.0, fbm_hash3D((roc+rdc*r)*0.001+vec3(0.0, 0.05*TIME, 0.0))-0.5);\n    \n    //zone = 10.0*pow((2.0*(zone-0.5)), 4.0);\n\n    //c *= zone;\n    \n    //return vec3(VISIBILITY(rdc.y));\n    float dayFactor = max(0.0, dot(vec3(0.0, 1.0, 0.0), -L));\n \tmieColor = 2e5*betaR*phaseR*sumR*dayFactor;\n    vec3 skyscat = as + mieColor;//2e2*(betaM*phaseM*sumM+betaR*phaseR*sumR);\n    //return vec3(zone);\n    return mix(\n        skyscat,\n        skyscat+dayFactor*2e1*max(0.0, dot(rd, -L))*den*zone,\n        max(0.0, VISIBILITY(rdc.y))\n    );//+clamp(exp(3.5*(e-0.5)), 0.0, 1.0)*c;\n    /*return mix(as,\n               2e4*(betaM*phaseM*sumM+betaR*phaseR*sumR)* // cloud \"color\"\n        clamp(exp(3.5*(e-0.5)\n                 ), 0.0, 1.0)\n    , c);*/\n}\n\nfloat Fresnel_Schlick(float n1, float n2, float NdotV)\n{\n    float R0 = (n1-n2)/(n1+n2);\n    R0 *= R0;\n    return R0+(1.0-R0)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV);\n}\n\nvec3 RenderTerrain(vec3 ro, vec3 rd, vec3 P, vec3 N, float D, vec3 L, vec2 rm)\n{\n    vec3 color = vec3(0.0);\n \n    float heightnoise = fbm_hash3D(P*5.0)-0.8;\n    \n    color = mix(vec3(0.7, 0.9, 0.6), vec3(0.05, 0.01, 0.07), fbm_hash3D(2.0*P));\n    // forest\n    color = mix(color,\n                vec3(0.1, 0.3, 0.2)*(fbm_hash3D(P*20.0)),\n                clamp(heightnoise+rm.y, 0.0, 1.0)\n               \t);\n    // snow\n    color = mix(\n        \t\tcolor,\n                vec3(1.0),\n                clamp(\n        heightnoise+P.y/(TERRAIN_HEIGHT+MOUNTAIN_AMP)*4.0,\n        0.0, 1.0)\n               );\n    color = color*max(0.0, dot(-L, N));\n    \n    return color;\n}\n\nvec3 Render(vec3 ro, vec3 rd, vec2 rm, vec3 L, float ssaod)\n{\n    vec3 P = ro+rd*rm.x;\n    vec3 Pt = P;\n    float WH = getWaterLevel(P);\n    vec3 N = mapNormal(P, 0.0001);\n    \n    vec3 mieColor;\n    vec3 skyColor = getSkyLight(ro, rd, L, mieColor);\n    vec3 color = skyColor;\n\n    float depth = (CAMERA_FAR-rm.x)/(CAMERA_FAR-CAMERA_NEAR);\n    vec3 color_sand = COLOR_SAND;\n    if(rm.x>=CAMERA_FAR)\n    {\n        \n    }else if(WH<P.y) // land\n    {\n        color = RenderTerrain(ro, rd, P, N, depth, L, rm);\n    \t//color = mix(skyColor, color, min(1.0, depth+0.6));\n        color_sand *= max(0.0, dot(-L, N));\n    }\n    else // water\n    {\n        float tmin, tmax;\n        tmin = IntersectPlane(ro, rd, vec3(0.0, WATER_BASE_LEVEL, 0.0), vec3(0.0, 1.0, 0.0));\n    \t/*float d = IntersectSphere(ro+vec3(0.0, EARTHRADIUS+20.0, 0.0)\n                                  , rd\n                                  , EARTHPOS\n                                  , EARTHRADIUS\n                                  , tmin, tmax);*/\n        P = ro+rd*tmin;\n        P.y = WH;\n        vec3 Nw = mapNormalWater(P, 0.00001);\n        Nw.z = -Nw.z;\n        float NdotV = max(0.0, dot(Nw, -rd));\n        float F = Fresnel_Schlick(1.0, 1.331, NdotV);\n        float E = 0.08;\n        //F /= E;\n        F = clamp(F, 0.1, 80.0);\n        \n        vec3 water_color = vec3(0.05, 0.1, 0.12);\n        \n\n        vec3 ror = vec3(Pt.x, WH, Pt.z);\n        vec3 rdr = reflect(rd, Nw);//vec3(rd.x, -rd.y, rd.z);//\n        float reflnear = 0.01;\n        float reflfar = 90.0;\n    // raymarch\n    \tvec2 rmm = raymarching(\n        \tror,\n        \trdr,\n        \treflnear, reflfar);\n    // end raymarch\n        #define DEPTH(x, n, f) (f-x)/(f-n)\n    \tfloat depthm = DEPTH(rmm.x, reflnear, reflfar);\n        \n        vec3 Pr = ror+rdr*rmm.x;\n        float depthr = DEPTH(rmm.x, reflnear, reflfar);\n        \n        vec3 mieColor;\n        vec3 rskycolor = getSkyLight(ror, rdr, L, mieColor);\n        \n        vec3 colorRefl = rskycolor;\n        if(rmm.x<reflfar)\n        {\n        \n            vec3 Nr = mapNormal(Pr, 0.0001);\n        \tcolorRefl = RenderTerrain(ror, rdr, Pr, Nr, depthr, L, rmm);\n            colorRefl= mix(rskycolor, colorRefl, min(1.0, depthr+0.8));\n            colorRefl = colorRefl*colorRefl;\n            //color = mix(vec3(0.4, 0.3, 0.2), color, min(1.0, abs(Pr.y-WH)*4.0));\n        }\n        //color = mix(water_color, color, (1.0-depthr)*0.3);\n        \n        float extinction = 1.0/(max(1.0, (WH-Pt.y)*50.0));\n        \n        float fbm = fbm_hash(P.xz);\n        vec3 colorDepth = vec3(depth*max(0.0, dot(N, -L))*extinction);\n        vec3 colorSurface = mix(\n            water_color*clamp(fbm, 0.8, 1.0),\n            colorRefl, 1.0-F)*0.5;\n        \n        {\n            color = mix(colorDepth, colorSurface, clamp(abs(WH-Pt.y)/0.5, 0.0, 1.0));\n            // specular\n            color += mieColor*pow(max(0.0, dot(reflect(rd, Nw), -L)), 32.0);\n\n            //color = colorDepth;\n            color_sand *= max(0.0, dot(-L, N))*extinction;\n            //color_sand = vec3(max(0.0, dot(-L, N))/(max(1.0, (WH-Pt.y)*50.0)));\n\n            // foam\n            color = mix(color, vec3(1.0), hash(P.xz)*max(0.0, 1.0-abs(Pt.y-WH)*15.0));\n\n            ssaod /= abs(Pt.y-WH)*15.0;\n        }\n    }\n    color = mix(color_sand, color, min(1.0, abs(Pt.y-WH)*8.0));\n    ssaod *= depth;\n    //color = color_sand;\n    return color*max(0.2, 1.0-ssaod);\n}\n\n/** END RENDERING **/\n\n// the camera construction method is inspired by the one from IQ\nmat3 setCamera( in vec3 origin, in vec3 target, vec3 viewUp )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cu = normalize( cross(cw,viewUp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 normal_decode(vec2 enc)\n{\n    vec3 n;\n    n.xy = enc*2.0-1.0;\n    n.z = sqrt(1.0-dot(n.xy, n.xy));\n    return n;\n}\n\n// https://www.shadertoy.com/view/lstSRS\nvec3 tonemapping(vec3 color)\n{\n    //Tonemapping and color grading\n    color = pow(color, vec3(1.5));\n    color = color / (1.0 + color);\n    color = pow(color, vec3(1.0 / 1.5));\n\n    \n    color = mix(color, color * color * (3.0 - 2.0 * color), vec3(1.0));\n    color = pow(color, vec3(1.3, 1.20, 1.0));    \n\n\tcolor = clamp(color * 1.01, 0.0, 1.0);\n    \n    color = pow(color, vec3(0.7 / 2.2));\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy);\n    vec2 pixel = -1.0 + 2.0*uv;// vec2(iResolution.x*0.6, iResolution.y);\n\tpixel.x *= iResolution.x/iResolution.y;\n    vec2 uvo = uv*5.0;\n    vec2 uvr = rot(uvo-(floor(uvo*1.0)), TIME);\n    \n    // camera\n    SUN_POS = vec3(-SUNDIST*0.3, sin(0.2*TIME)*SUNDIST, cos(0.2*TIME)*SUNDIST);\n    vec3 ro = CAMPOS;\n    vec3 rd = normalize(vec3(-1.0-uv*2.0, 1.0));\n    mat3 ca = setCamera(ro, CAMLOOKAT, vec3(0.0, 1.0, 0.0));\n    rd = ca*normalize(vec3(pixel.xy, 2.0));\n    // end camera\n\n    \n   \tvec4 gbuf = texture(iChannel0, uv);\n    vec2 rm = gbuf.xy;\n    float ssaod = 0.0f;\n    \n    ssaod += texture(iChannel0, uv+vec2(-0.001, -0.001)).r;\n    ssaod += texture(iChannel0, uv+vec2(0.001, -0.001)).r;\n    ssaod += texture(iChannel0, uv+vec2(-0.001, 0.001)).r;\n    ssaod += texture(iChannel0, uv+vec2(0.001, 0.001)).r;\n    ssaod *= 0.25;\n    ssaod = clamp(abs(gbuf.x-ssaod), 0.0, 1.0);\n    \n    vec3 color = Render(ro, rd, rm, normalize(SUN_DIR), ssaod);\n    vec3 colorBeforeTM = texture(iChannel1, uv).rgb;\n\n    fragColor = vec4(0.5*(tonemapping(color)+colorBeforeTM), 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}