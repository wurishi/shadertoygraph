{"ver":"0.1","info":{"id":"4tKfWW","date":"1546313835","viewed":156,"name":"Reconstructed Vase","username":"WB","description":"Raymarched vase fragments made from some constructive solid geometry and 3d gradient noise.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","distancefields"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 256\n#define MIN_DIST 0.03\n#define _FoV 50.0\n#define _Epsilon 0.05\n\nconst vec3 _Center = vec3(0.0);\nconst float _Radius = 1.0;\nconst float _TextureScale = 0.5;\nconst float _SpecularExp = 50.0;\n\nfloat sdSphere(vec3 pos, vec3 center, float radius)\n{\n    return length(center - pos) - radius;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//Boolean operations for distance fields\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat opShell(float d, float thickness)\n{\n    return abs(d) - thickness;\n}\n\n//Ray-sphere intersection\nbool raycastSphere(vec3 ro, vec3 rd, out vec3 p0, out vec3 p1, vec3 center, float r)\n{\n    float A = 1.0; //dot(rd, rd);\n    float B = 2.0 * (rd.x * (ro.x - center.x) + rd.y * (ro.y - center.y) + rd.z * (ro.z - center.z));\n    float C = dot(ro - center, ro - center) - (r * r);\n\n    float D = B * B - 4.0 * A * C;\n    if (D < 0.0)\n    {\n        return false;\n    }\n    else\n    {\n        float t0 = (-B - D)/(2.0 * A);\n        float t1 = (-B + D)/(2.0 * A);\n        p0 = ro + rd * t0;\n        p1 = ro + rd * t1;\n        return true;\n    }\n}\n\n//X-axis rotation matrix\nvec3 rotateX(vec3 p, float t)\n{\n    float cosTheta = cos(t);\n    float sinTheta = sin(t);\n    mat3 rot = mat3(1.0, 0.0, 0.0,\n        \t\t\t0.0, cosTheta, -sinTheta,\n    \t\t\t    0.0, sinTheta, cosTheta);\n    \n    return rot * p;\n}\n\n//Y-axis rotation matrix\nvec3 rotateY(vec3 p, float t)\n{\n    float cosTheta = cos(t);\n    float sinTheta = sin(t);\n    mat3 rot = mat3(cosTheta, 0.0, sinTheta,\n        \t\t\t0.0, 1.0, 0.0,\n    \t\t\t    -sinTheta, 0.0, cosTheta);\n    \n    return rot * p;\n}\n\n//iq's gradient noise\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nfloat map(vec3 pos)\n{   \n    float freq = 6.0;\n    \n    float d1 = sdCappedCylinder(pos, vec2(0.2,0.75));\n    \n    float d2 = sdSphere(pos, vec3(0.0,-0.25,0.0), 0.45);\n    \n    float d3 = sdSphere(pos, vec3(0.0,1.0,0.0), 0.4);\n    \n    float d4 = sdCappedCylinder(pos + vec3(0.0,-1.75,0.0), vec2(1.0,1.0));\n        \n    float df = opSmoothUnion(d1, d2, 0.2);\n    df = opSmoothUnion(df, d3, 0.2);\n    df = opShell(df, 0.005);\n    df = opSubtraction(d4, df);\n    df = max(df, 0.045-abs(noise(pos * freq)));\n    df += cos(pos.y*64.0)/128.0;\n    //df += cos(pos.x*16.0)/48.0;\n    //df += cos(pos.z*16.0)/48.0;\n    \n    return df;\n}\n\nvec3 raymarch(vec3 pos, vec3 dir)\n{\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        float dist = map(pos);\n        \n        if (dist <= MIN_DIST)\n        {\n            return pos;\n        }\n        \n        pos += dir * dist * _Epsilon;\n    }\n    \n    return vec3(0.0);\n}\n    \n//Approximate surface normal using central difference\nvec3 calculateNormal(vec3 p)\n{\n    const float eps = 0.01;\n\n    return normalize(vec3(map(p + vec3(eps, 0, 0)) - map(p - vec3(eps, 0, 0)),\n                          map(p + vec3(0, eps, 0)) - map(p - vec3(0, eps, 0)),\n                          map(p + vec3(0, 0, eps)) - map(p - vec3(0, 0, eps))));\n}\n\n//Tri-planar texture mapping\nvec3 triPlanar(vec3 p, vec3 n, float k)\n{\n    vec2 xUV = p.zy/_TextureScale;\n    vec2 yUV = p.xz/_TextureScale;\n    vec2 zUV = p.xy/_TextureScale;\n    \n    vec3 colX = texture(iChannel0, xUV).rgb;\n    vec3 colY = texture(iChannel0, yUV).rgb;\n    vec3 colZ = texture(iChannel0, zUV).rgb;\n    \n    vec3 blend = pow(abs(n),vec3(k));\n    blend = blend/(blend.x + blend.y + blend.z);\n    \n    return colX * blend.x + colY * blend.y + colZ * blend.z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 rayOrigin = vec3(0.0, 1.5, -4.0);\n        \n    //Compute eye vector from field of view\n    vec2 uv = fragCoord/iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n    float d = ar/tan(radians(_FoV/2.0));    \n    vec3 rayDir = normalize(vec3((-1.0 + 2.0 * uv) * vec2(ar, 1.0), d));\n    \n    rayDir = rotateX(rayDir, -0.35);\n    rayDir = rotateY(rayDir, iTime * 0.2);\n    rayOrigin = rotateY(rayOrigin, iTime * 0.2);\n    \n    vec3 col = texture(iChannel1, rayDir).rgb;\n    \n    vec3 start, end;\n    \n    if(raycastSphere(rayOrigin, rayDir, start, end, _Center, _Radius))\n    {\n        vec3 sp = raymarch(start, rayDir);\n        \n        if(sp != vec3(0.0))\n        {\n            vec3 n = calculateNormal(sp);\n\n            vec3 r = rayOrigin - sp;\n            float atten = 1.0/dot(r,r);\n\n            float nl = dot(n, -rayDir);\n\n            vec3 h = (n-rayDir)/length(n-rayDir);     \n            float spec = pow(max(dot(n, h), 0.0), _SpecularExp) * max(0.0, nl);\n\n            col = triPlanar(sp, n, 2.0);\n            \n            vec3 amb = vec3(0.1, 0.1,0.1) * texture(iChannel1, n).rgb;\n\n            //Lighting\n            //float flicker = ((1.0 + sin(iTime*2.0)/2.0) + (1.0 + sin(iTime*10.0)/4.0) + (1.0+sin(iTime*25.0)/8.0))*0.5;\n            col = amb + col * (nl + spec) * atten * 15.0;\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}