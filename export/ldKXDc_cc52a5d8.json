{"ver":"0.1","info":{"id":"ldKXDc","date":"1467228860","viewed":178,"name":"Mandelbrot Math","username":"akohdr","description":"Clean matrix implementation of Mandelbrot math.  \nNo zooms, or colour scheme distractions just the math.\n","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Mandelbrot explaination @ https://en.wikipedia.org/wiki/Mandelbrot_set\n// Follow on from https://www.shadertoy.com/view/4sVXW3\nvoid mainImage(out vec4 k,vec2 p) \n{\n\tp += p; p /= iResolution.y;\t// aspect adjusted scaling to 0 <= y <= 2\n    \t\t\t\t\t\t\t// multiply and add reusing single reg.    \n//\tp *= 2./iResolution.y;\t\t// equivalent (two multiplies and extra hidden reg.)\n    \n    vec2 z = vec2(0),\t\t\t// initialize complex loop variable z\n        \n         c = p - vec2(2.5,1);\t// complex value c at position p on complex plane\n    \t\t\t\t\t\t\t// origin is offset to fit display (-1 <= y <= 1)\n    \n    for (float i=0.; i <24.; i++) {\n        \n\t\t// vec2/mat2 implementation of Mandelbrot complex quadratic map\n\t\t//\n        //\t\t\t\t\t 2\n        //\t\tf (z)\t=\tz\t+\tc\n        //\t\t c\n        \n\t\t//\t\t\t\t\t\t\t\t\t 2\n        // Algebraic approach: expansion of z  =  (a + bi)(a + bi)\n        //\t= aa + abi + abi - bb \n        \n\t\t//\tz = vec2(z.x*z.x - z.y*z.y,\n\t\t//\t\t\t 2.*z.x*z.y\t\t\t) + c;\t\t\t\t\t\t\t\t\t\t// (1)\n        \n\t\t//  = ( a  bi)(a )\n        //    ( bi a )(bi)\n        \n\t\t//\tz = mat2( z.x, z.y,\n\t\t//\t\t\t -z.y, z.x)\t*\tz + c;\t\t\t\t\t\t\t\t\t\t\t// (2)\n        \n        // rearrange note transpose due to non-commutative nature of matrices\n\t\t//\tz = z * mat2( z.x,-z.y,\n\t\t//\t\t\t      z.y, z.x) + c;\t\t\t\t\t\t\t\t\t\t\t// (3)\n        \n        // define a custom operator based on single transform\n\t\t\t#define SQi(z) (mat2(z,-z.y,z.x)*z)\n        \tz = SQi(z) + c;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// (4)\n        \n        \n        // Geometric Approach: complex product as scale and rotation\n        \tfloat a = -atan(z.y,z.x),\n                  m = length(z);\n            vec2 sc = sin(vec2(a,a + 3.14159/2.));\t\t// sin and cos of a\n\t\t//\tz =  mat2( sc.y,-sc.x,\n\t\t//\t\t\t   sc.x, sc.y) * mat2( m, 0,\n\t\t//\t\t\t\t\t\t\t\t   0, m) * z + c;\t\t\t\t\t\t\t// (5)\n\n        // rearrange note transpose due to non-commutative nature of matrices\n        //\tz =  z * mat2( m, 0,\n\t\t//\t\t\t\t   0, m ) * mat2( sc.y, sc.x,\n\t\t//\t\t\t\t\t\t\t\t -sc.x, sc.y) + c;\t\t\t\t\t\t\t// (6)\n        \n        //\tz =  z * m * mat2( sc.y, sc.x,\n\t\t//\t\t\t\t\t  -sc.x, sc.y) + c;\t\t\t\t\t\t\t\t\t\t// (7)\n\n        // pipeline the operations reusing z\n\t\t//\tz *= m;\t\t\t\t\t\t\t\t// scale\n        //\tz *= mat2(sc.yx,-sc.x,sc.y);\t\t// rotate (transpose of regular mat2 rot)\n        //\tz += c;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// (8)\n\t}    \n    \n \t\t// tag func to determine if c lies in/outside Mandelbrot set\n     \t//\n     \t//\t\tc in M <=> |z| <= 2\n\n#define inSet(z)  length(z) <= 2.\n    \n    k = vec4(inSet(z));\t\t\t// white on black\n\tk = 1.-k;\t\t\t\t\t// black on white    \n}\n\n\n\n\n\n\n\n\n\n\n\n// animate shape based on iteration limit by adding following line to end of loop\n//\t\tif (i>iTime) break;\n\n// highlight attractors using time as inSet test limit\n//#define inSet(z)  length(z) < iTime/5.\n\n\n/* Golf version\n\nvoid mainImage( out vec4 O, vec2 c ) {\n//\tO-=O; \n    while(O.w++<21.) O.xy = c/2e2-1.-mat2(O.xy,-O.y,O.x)*O.xy;    \n} // 90 (without init of O)\n*/\n","name":"Image","description":"","type":"image"}]}