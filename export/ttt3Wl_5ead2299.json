{"ver":"0.1","info":{"id":"ttt3Wl","date":"1578000656","viewed":72,"name":"tunelv4","username":"jorge2017a1","description":"tunelv4","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["tunelv4"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nfloat Sphere(vec3 p, vec3 o, float r){\n        return length(p-o)-r;  \n}\n \nfloat Plane(vec3 p){\n\treturn p.y;\t\n}\n\nvec3 DR(vec3 p,vec3 q){\n\treturn mod(p,q)-q/2.;\n}\n\n\n///----------------------------\n\n\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n//Sphere function\nfloat sdSpherev2( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n\n///por Iq\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n///---------------------------------------------\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n// Create infinite copies of an object -  https://iquilezles.org/articles/distfunctions\nvec2 opRep( in vec2 p, in float s )\n{\n    return mod(p+s*0.5,s)-s*0.5;\n}\n\n\n\n///-------------------------------\n\nfloat h(vec3 p) {\n    \n\n    \n    vec2 res;\n    float dif1, dif2;\n \n    \n    res= vec2(999.9);\n    \n     p.xz=opRep( p.xz, 15. );\n   // p.z=mod( mod(p.z, 7.0),2.0)-0.5;\n   \n    \n    \n    float sdb1=sdBox(p-vec3(0.0,5.5,0.), vec3(8.5,5.8,8.0) );\n    float sdb2=sdBox(p-vec3(0.0,6.0,0.), vec3(7,5.2,9.0) );\n    \n    float sdb3d=sdBox(p-vec3(0.0,6.0,0.), vec3(1,1.0,1.0) );\n    \n    \n    \n    float sdb3pisoi=sdBox(p-vec3(-5.0,3.0,0.0), vec3(3,1.1,2.) );\n    float sdb4pisod=sdBox(p-vec3(5.0,3.0,0.0), vec3(3,1.1,2.) );\n    \n    float sdb5pisoi=sdBox(p-vec3(-5.0,6.0,0.0), vec3(3,1.1,4.0) );\n    float sdb6pisod=sdBox(p-vec3(5.0,6.0,0.0), vec3(3,1.1,4.0) );\n    \n    \n   \n    dif2=differenceSDF(sdb1,sdb3pisoi);\n    dif2=differenceSDF(dif2,sdb4pisod);\n    dif2=differenceSDF(dif2,sdb5pisoi);\n    dif2=differenceSDF(dif2,sdb6pisod);\n    \n    //dif1=differenceSDF(sdb1, sdb2);\n    dif1=differenceSDF(dif2,sdb2);\n    \n    \n    res=opU(res, vec2(dif1,8));\n    \n    return res.x;\n}\n\nvec3 GetNormal(vec3 p) {\n\tvec2 e=vec2(.001,0);\n\treturn normalize(vec3(\n\t\th(p+e.xyy)-h(p-e.xyy),\n\t\th(p+e.yxy)-h(p-e.yxy),\n\t\th(p+e.yyx)-h(p-e.yyx)\n\t));\n}\n\nfloat AO(vec3 p,vec3 q){\t\t\t// AO at point p with normal q\n\tfloat o=0.,s=1.,r,d;\n    \tfor(float i=0.;i<5.;i++){\n\t\tr=.01+.12*i/4.;\n\t\tvec3 a=q*r+p;\n\t\td=h(a);\n\t\to+=-(d-r)*s;\n\t\ts*=.95;\n    \t}\n    \treturn clamp(1.-3.*o,0.,1.);   \n}\n\nfloat SH(vec3 p, vec3 q){\t\t\t// Calculate shadow amount: p=intersection point; q=light direction\n\tvec3 r = p + q*.01;\n\tfloat d;\n\tfor(int i=0; i<16; i++) {\n\t\td = h(r);\n\t\tif (d < .001)\n\t\t\tbreak;\n\t\tr += q * d;\t\t\t\t// March along!\n\t}\n\tif (d < 0.001)\n\t\treturn 0.1;\n\telse\n\t\treturn 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy * 2. - iResolution.xy) / iResolution.y;\n\t\n\t//vec3 ro = vec3(1.4, 1.6, -4+iTime);\t\t\t// Cam pos (ray origin)\n    vec3 ro = vec3(1.4, 4.6, -24.0+iTime);\t\t\t// Cam pos (ray origin)\n    \n    \n\tvec3 up = vec3(0, 1, 0);\t\t\t// Cam orientation vecs\n\tvec3 fd = vec3(0, 0, 1);\n\tvec3 right = -cross(fd,up);\n\t\n\tfloat fov=1.8;\n\tvec3 rd = normalize(right*uv.x + up*uv.y + fd*fov);\t// Ray dir \n\t\n\tvec3 p = ro;\t\t\t\t\t// Current test position\n\tfloat d;\t\t\t\t\t// Distance of p from surface\n\tfor(int i=0; i<128; i++) {\n\t\td = h(p);\n\t\tif (d < .001)\n\t\t\tbreak;\n\t\tp += rd * d;\t\t\t\t// March along!\n\t}\n\t\n    \n    \n    \n    \n\tif (d < .001) {\t\t\t\t\t// We hit something!\n\t\t//vec3 lp = vec3(10,10,-10);\t\t// Light position\n        //vec3 lp = vec3(0.5,5.,-10);\t\t// Light position\n        vec3 lp = vec3(0.0,5.,iTime);\t\t// Light position\n        \n\t\tvec3 ld = normalize(lp-p);\t\t// Light direction\n\t\tvec3 n = GetNormal(p); \t\t\t// Normal\n\t\tfloat diffuse = dot(n,ld);\t\t// Diffuse amount\n\t\tvec3 c = vec3(.8,.9,1) * diffuse * AO(p,n) * SH(p,ld);\n\t\t\n\t\n        \n        vec3 lp1 = vec3(10.0,1.,iTime-5.0);\t\t// Light position\n        \n\t\tvec3 ld1 = normalize(lp1-p);\t\t// Light direction\n\t\tvec3 n1 = GetNormal(p); \t\t\t// Normal\n\t\tfloat diffuse1 = dot(n1,ld1);\t\t// Diffuse amount\n\t\tvec3 c1 = vec3(.3,.5,.8) * diffuse1 * AO(p,n1) * SH(p,ld1);\n\t\t\n\t\tfragColor =( vec4(c, 1)+vec4(c1, 1))/1.5;\n        \n        \n        \n\t} else\t\t\t\t\t\t// We fucking hit NOTHING\n\t\tfragColor = vec4(uv.x / 2., uv.y * 1.4, 1, 1);\n}\n","name":"Image","description":"","type":"image"}]}