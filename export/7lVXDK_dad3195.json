{"ver":"0.1","info":{"id":"7lVXDK","date":"1641394061","viewed":85,"name":"Implicit curves rasterization","username":"Envy24","description":"Solution for problem in this shader: https://www.shadertoy.com/view/slVXWV\n\nOther solutions:\nhttps://www.shadertoy.com/view/slVSWV\nhttps://www.shadertoy.com/view/stKXWc","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["curves","function","plot","implicit","rasterization"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                       iResolution\n#define TEX0(x)               ( texture(iChannel0, (x)) )\n#define TEX_COORDS(SC)        ( (SC) / (R.xy) )                       // in range x=[0.0; 1.0], y=[0.0; 1.0]\n#define TAU                     6.2831853071795862\n\nfloat gaussian(const float x, const float y, const float sigma)\n{\n    float n = 1.0 / (TAU * sigma * sigma);\n    float exponent = -0.5 * ((x * x + y * y) / (sigma * sigma));\n\n    return n * exp(exponent);\n}\n\nfloat gaussianFilter(vec2 SC, float halfRange, float sigma)\n{\n    float sum = 0.0;\n    \n    for (float y = -halfRange; y <= halfRange; y += 1.0)\n    {\n        for (float x = -halfRange; x <= halfRange; x += 1.0)\n        {\n            sum += TEX0(TEX_COORDS(SC + vec2(x, y))).r * gaussian(x, y, sigma);\n        }\n    }\n    \n    return sum;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    // No AA.\n    //O = vec4(1.0) - TEX0(TEX_COORDS(SC));\n    \n    // With AA.\n    O = vec4(1.0 - gaussianFilter(SC, 3.0, 0.8));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define R                       iResolution\n#define AR                    ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define NZMY                  ( (iMouse.y+iMouse.y-R.y) / R.y )  // in range [-1.0; 1.0]\n#define LMB_IS_HOLD           ( iMouse.z > 0.0 )\n\n#define XMIN     -2.0\n#define XMAX     2.0\n#define YMIN     -2.0\n#define YMAX     2.0\n\n//#define FUNCTION unit_circle          \n#define FUNCTION heart_curve\n//#define FUNCTION heart_curve2\n//#define FUNCTION devil_curve\n//#define FUNCTION electric_motor_curve\n\n//#define FUNCTION random_curve_0003\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    float xStep = (XMAX - XMIN) / (R.x - 1.0);\n    float yStep = (YMAX - YMIN) / (R.y - 1.0);\n\n    float modulation = \n        LMB_IS_HOLD == true ?\n            NZMY :\n            0.0;\n    \n    float dist = \n        modulation + FUNCTION(\n            (XMIN + floor(SC.x) * xStep) * AR,\n            YMIN + floor(SC.y) * yStep);\n\n    O = vec4(dist);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/* xRange=[-1.0; 1.0] yRange=[-1.0; 1.0] */\nfloat unit_circle( float x, float y )\n{\n    return x*x + y*y - 1.0;\n}\n\n/* source: https://www.desmos.com/calculator/pi5ofejgt0?lang=ru\n   xRange=[-2.0; 2.0] yRange=[-2.0; 2.0]    */\nfloat heart_curve(float x, float y)\n{\n    float term = x*x + y*y - 1.0;\n    return term * term * term - x*x * y*y*y;\n}\n\n/* xRange=[-1.5; 1.5] yRange=[-1.5; 2.0] */\nfloat heart_curve2(float x, float y)\n{\n    float term = y - pow(x * x, 1.0 / 3.0);\n    return x * x + term * term - 1.0;\n}\n\n/* source: https://mathworld.wolfram.com/DevilsCurve.html\n   xRange=[-2.0; 2.0] yRange=[-2.0; 2.0]     */\nfloat devil_curve(float x, float y)\n{\n    return y * y * (y * y - 1.0) - x * x * (x * x - 2.0);\n}\n\n/* source: https://mathworld.wolfram.com/DevilsCurve.html \n   xRange=[-12.5; 12.5] yRange=[-12.5; 12.5]     */\nfloat electric_motor_curve(float x, float y)\n{\n    return y * y * (y * y - 100.0) - x * x * (x * x - 96.0);\n}\n\n/* xRange=[-2.0; 2.0] yRange=[-2.0; 2.0] */\nfloat random_curve_0001(float x, float y)\n{\n    return sin(x*x + y*y)-y*y;\n}\n\n/* xRange=[-4.0; 4.0] yRange=[-4.0; 4.0] */\nfloat random_curve_0002(float x, float y)\n{\n    float xx = x * x;\n\n    return xx * sin(xx + xx) - y*y;\n}\n\n/* xRange=[-2.0; 2.0] yRange=[-2.0; 2.0] */\nfloat random_curve_0003(float x, float y)\n{\n    return x * x * sin(32.0 * (x - y)) * tan(x + y) - y * y * y;\n}\n\n/* source: https://www.desmos.com/calculator/pi5ofejgt0?lang=ru\n   xRange=[-40.0; 40.0] yRange=[-40.0; 40.0]    */\nfloat random_curve_0004(float x, float y)\n{\n    return x * x * x + y * y - 6.0 * x * y;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define R                       iResolution\n#define TEX0(x)               ( texture(iChannel0, x) )\n#define TEX_COORDS(SC)        ( (SC) / (R.xy) )                       // in range x=[0.0; 1.0], y=[0.0; 1.0]\n\nbool compare(float l, float r)\n{\n    l = l >= 0.0 ? 1.0 : -1.0;\n    r = r >= 0.0 ? 1.0 : -1.0;\n    \n    return l != r;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    float CENTER = TEX0(TEX_COORDS(SC)).r;\n    float RIGHT  = TEX0(TEX_COORDS(SC + vec2(1.0, 0.0))).r;\n    float LEFT   = TEX0(TEX_COORDS(SC - vec2(1.0, 0.0))).r;\n    float TOP    = TEX0(TEX_COORDS(SC + vec2(0.0, 1.0))).r;\n    float BOTTOM = TEX0(TEX_COORDS(SC - vec2(0.0, 1.0))).r;\n\n    bool isVisible = \n        compare(CENTER, RIGHT) ||\n        compare(CENTER, LEFT) ||\n        compare(CENTER, TOP) ||\n        compare(CENTER, BOTTOM);\n\n    O = vec4(isVisible);\n}","name":"Buffer B","description":"","type":"buffer"}]}