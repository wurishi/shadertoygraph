{"ver":"0.1","info":{"id":"3sdfDX","date":"1606147132","viewed":61,"name":"TP_MMV_BRALET_DURET_Shader2","username":"antoine_bralet","description":"Second shader permettant de générer un paysage à partir d'une heigth map à partir de somme de bruits. Nous. avons ajouté des primitives volumiques à savoir des sphères fusionnées entre elles et avec le sol ainsi qu'un trou creusé par une sphère.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["tp1","mmv"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Texturing\n// Eric Galin\n\nconst float view = 5000.0;  // View distance\nconst float Epsilon = 0.05; // Marching epsilon\n\n// Iterations\nconst int Steps = 256;      // Maximum number of steps when sphere-tracing\nconst float K = 7.0;\t    // Lipschitz constant\n\n// Rendering\nconst float fog = 5000.0;   // Fog attenuation distance\n\n\nfloat addition(float h1, float alpha1, float h2, float alpha2){\n\treturn (h1*alpha1 + h2*alpha2)/(alpha1+alpha2);\n}\n\n\n//Get the SDF of a sphere depending\n// p : position in the world\n// radius : radius of the sphere to consider\n// center : position of the center of the sphere\nfloat getSphere(in vec3 p, in float radius, in vec3 center){\n    float h;\n    //Direction from p to the center of the sphere\n    vec3 dir = p-center;\n    //Get the norm\n    float n = sqrt((p.x-center.x)*(p.x-center.x) + (p.y-center.y)*(p.y-center.y) + (p.z-center.z)*(p.z-center.z));\n    \n    //Get q located at the intersection betwen the sphere and dir\n    vec3 q = center + radius * dir/n;\n    //Get the turbulences\n    float turb = fBmSphere(q, radius);\n    //Move the radisu according to the turbulence\n    float dispRad = radius + turb;\n    \n    //Get the SDF depending on the displaced radius\n    h = n - dispRad; \n    \n    return h;\n    \n}\n\n// Terrain heightfield\n// x : Position in the plane\nfloat Terrain(in vec2 x)\n{\n\t// Rotation matrix\n\tconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\n    const float l0=1350.0;  // Initial wavelength\n    const float a0=455.0;   // Initial amplitude\n    \n    float a = -200.0;       // Initial height\n    float b = a0;           \n\tvec2  p = x/l0;\n    for( int i=0; i<3; i++ )\n    {\n        float n = Noise(p);\n        a += b*n;\n\t\tb *= 0.55;\n        p = m2*p*2.;\n    }\n\treturn a;\n}\n\n//Function that join two spheres together\n//p : position in the world\nfloat getMultipleSpheres(vec3 p){\n    vec3 c1, c2;\n    float rad1, rad2;\n    //Caracteristics of the two spheres\n    rad1 = 100.0;\n    rad2 = 100.0;\n    c1 = vec3(-1000.0, -300.0, Terrain(vec2(-1000.0, -300.0))+rad1);\n    c2 = vec3(-1000.0, -200.0, Terrain(vec2(-1000.0, -300.0))+rad1+rad2+50.0);\n    //Get the SDF depending on p\n   \tfloat hs1 = getSphere(p,rad1, c1);\n    float hs2 = getSphere(p,rad2, c2);\n    \n    // Distance between the centers\n    float nc2c1 = sqrt((c2.x-c1.x)*(c2.x-c1.x) + (c2.y-c1.y)*(c2.y-c1.y) + (c2.z-c1.z)*(c2.z-c1.z));\n    //direction from the first to the second\n    vec3 dir = (c2-c1)/nc2c1;\n    //distance from p to c1\n    vec3 pvec = (p-c1);\n    //Projection of pvec on the dir unit vector\n    float proj = dot(pvec, dir);\n    \n    //Get the coefficients of the interpolation between the two spheres\n    float alpha1, alpha2;\n    float turbMax = 25.0;\n    //If the point is dependent of Sphere 1, then attribute 1.0\n    if(proj < nc2c1 - rad2 - turbMax){\n        alpha1 = 1.0;\n        alpha2 = 0.0;\n    }else if(proj > rad1 + turbMax){\t//if dependent of Spehere 2\n        alpha1 = 0.;\n        alpha2 = 1.0;\n    }else{\t//if dependent of both : interpolation\n        //Distance where the interpolation has to be calculated\n        float val = rad1 + turbMax - nc2c1 + rad2 + turbMax;\n        //Calculation of the coefficients\n        alpha1 = 1.0-(proj-nc2c1+rad2+turbMax)/val;\n        alpha2 = (proj-nc2c1+rad2+turbMax)/val;\n    }\n\n    //Calculation of h depending on the coefficient of interpolation\n    float h = addition(hs1, alpha1 , hs2, alpha2);\n    return h;\n}\n\n//Get SDF by interpolating spheres and terrain\nfloat interpTerrainSphere(in vec3 p, in float hTer, in float hSph, in vec3 center){\n    float h = p.z-hTer;\n    \n    //Get the norm between p and the center of the sphere\n    float n = sqrt((p.x-center.x)*(p.x-center.x) + (p.y-center.y)*(p.y-center.y) + (p.z-center.z)*(p.z-center.z));\n    //Caculate the point located on the sphere\n    vec3 pSphere = p + hSph * (center - p)/n;\n    \n    //Calculate the norm between p and the surface of the sphere\n    float nbis = sqrt((p.x-pSphere.x)*(p.x-pSphere.x) + (p.y-pSphere.y)*(p.y-pSphere.y));\n    \n    //interpolation in a given range of distance\n    float dist = 100.0;\n    if (nbis < dist){        \n    \th = min(h,p.z-addition(pSphere.z, 1.0-nbis/dist, hTer, nbis/dist));\n    }\n    \n    return h;\n\t\n}\n\nfloat digTerrainSphere(in vec3 p, in float hTer, in float hSph, in vec3 center){\n    //Initialize the return as the ground\n    float h = p.z-hTer;\n    \n    //Get the norm between p and the center of the sphere\n    float n = sqrt((p.x-center.x)*(p.x-center.x) + (p.y-center.y)*(p.y-center.y) + (p.z-center.z)*(p.z-center.z));\n    //Caculate the point located on the sphere\n    vec3 pSphere = p + hSph * (center - p)/n;\n    \n    //Memory of the height to check if p is inside the sphere or not\n    float memz = pSphere.z;\n    \n    //Check if the height of the sphere is above the ground\n    if(pSphere.z > hTer){\n        \n    \tpSphere.z -= 2.0*(pSphere.z - hTer);\n    }\n    \n    //Calculate the norm between the point and the surface of the sphere\n    float newN = sqrt((p.x-pSphere.x)*(p.x-pSphere.x) + (p.y-pSphere.y)*(p.y-pSphere.y) + (p.z-pSphere.z)*(p.z-pSphere.z));\n    \n    //Calculate the norm between center and the surface of the sphere\n    float nbis = sqrt((pSphere.x-center.x)*(pSphere.x-center.x) + (pSphere.y-center.y)*(pSphere.y-center.y) + (memz-center.z)*(memz-center.z));\n\n\t//Check if the point is inside the sphere to update the sdf\n    if ((n < nbis)&&(pSphere.z < hTer)){ \n        h = newN;\n    }\n    \n    return h;\n}\n\n// Implicit surface defining the terrain\n// p : Point\nfloat Implicit(in vec3 p) \n{\n    float realH = Terrain(p.xy);\n\tfloat h = p.z - realH;\n    float rad = 100.0;\n    vec3 centerInterp = vec3(-1000.0, -300.0, Terrain(vec2(-1000.0, -300.0))+rad);\n    vec3 centerDig = vec3(0.0, 0.0, Terrain(vec2(0.0, 0.0))-50.0);\n    vec3 centerEat = vec3(-1000.0, -100.0, Terrain(vec2(-1000.0, -300.0))+250.0+50.0);\n    float hS = getMultipleSpheres(p);\n\tfloat hD = getSphere(p, rad, centerDig);\n\tfloat hE = getSphere(p, rad, centerEat);\n    \n    h = interpTerrainSphere(p, p.z-h, hS, centerInterp);\n\t\n    h = digTerrainSphere(p, p.z-h, hD, centerDig);\n    \n   \th = digTerrainSphere(p, p.z-h, hE, centerEat);\n    \n    return h;\n}\n\n// Sphere tracing\n// ro, rd : Ray origin and direction\n// t : Intersection depth\n// i : Iteration count\nbool Intersect(in vec3 ro, in vec3 rd, out float t,out int i)\n{\n    t = 0.0;\n\tfor( i=0; i<Steps; i++ )\n\t{\n        vec3 p = ro + t*rd;\n\t\tfloat h = Implicit(p);\n        \n        // 1 cm precision at 1 meter range, reduce precision as we get farther from eye\n        if( abs(h)< Epsilon*sqrt(1.0+t) ) \n        { \n            return true;\n        }\n        if( t>view ) { return false; }\n\t\t// Empirical Lipschitz constant with level of detail (the further, the larger steps)\n        t += max(Epsilon,h*sqrt(1.0+8.0*t/view)/K);\n\t}\n\n    \n\treturn false;\n}\n\n// Analysis of the scalar field --------------------------------------------------------------------------\n\n//Get the slope of the terrain\n//p : point where to get the slope\nfloat Slope(in vec3 p)\n{\n    float slope = 0.0f;\n    float eps = 0.01;\n    //Get the height on x and y to get the gradient\n    float zp = Terrain(p.xy);\n    float zepsx = Terrain(vec2(p.x + eps, p.y));\n    float zepsy = Terrain(vec2(p.x, p.y + eps));\n    //Calculate the slope\n    slope = sqrt(((zepsx - zp)/eps)*((zepsx - zp)/eps) + ((zepsy - zp)/eps)*((zepsy - zp)/eps)); \n    \n\treturn slope;\n}\n\n//Function used to determine de color of the current texture\nvec3 SnowTex(in vec3 p)\n{\t//bruitage de la texture par somme de bruits\n    float noiseAlpha = fBm(p);\n    //Rock color\n    vec3 col = vec3(0.0);\n    \n    if ((p.z > 400.0) && (Slope(p) < 2.0)){\n    \tcol = mix(vec3(0.55), vec3(0.75), noiseAlpha);\n    } else if ((p.z > 350.0) && (Slope(p) < 2.0)){\n        vec3 csnow = mix(vec3(0.55), vec3(0.75), noiseAlpha);\n        col = mix(col, csnow, (p.z - 350.0)/50.0 );\n    } else if (p.z < 50.0) {\n        col = mix(0.5*vec3(0.471,0.361,0.110), 0.5*vec3(0.5,0.4,0.2), noiseAlpha);\n    }\n\n    return col ;\n}\n\n// Calculate object normal\n// p : point\nvec3 Normal(in vec3 p )\n{\n  float eps = 0.01;\n  vec3 n;\n  float v = Implicit(p);\n  n.x = Implicit( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = Implicit( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = Implicit( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return 0.5+mix(vec3(0.05,0.05,0.5),vec3(0.65,0.39,0.65),t);\n}\n\n// Rendering \n// ro, rd : Ray origin and direction\n// pip : Picture in picture boolean\nvec4 Render( in vec3 ro, in vec3 rd, bool pip )\n{\n    // Light direction\n    const vec3 light1 = normalize( vec3(-0.8,-0.3,0.4) );\n   \n\tvec3 col;\n    float t;\n    int it;\n    bool b=Intersect( ro, rd, t , it);\n    if( b==false)\n    {\n        // sky\t\t\n        col = vec3(0.35,0.65,0.95) - rd.z*rd.z*2.5;\n    }\n\telse\n\t{\n        // mountains\t\t\n\t\tvec3 p = ro + t*rd;\n        vec3 n = Normal( p );\n        \n        vec3 ref = reflect( rd, n );\n        float fre = clamp( 1.0+dot(rd,n), 0.0, 1.0 );\n        vec3 hal = normalize(light1-rd);\n        \n        col = SnowTex(p);\n        \n        \n         // Pseudo diffuse lighting\n\t\tfloat dif = 0.5*(1.0+dot( light1, n ));\n        dif*=dif;\n        \n        col += dif*vec3(0.5);\n\n\t\t// Fog\n        float fo = 1.0-exp(-pow(t/fog,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        col = mix( col, 0.5*col+0.51*vec3(0.35,0.65,0.95), fo );\n\n\t}\n    \n    // Shading for iterations\n    if (pip==true)\n    {\n    \treturn vec4(ShadeSteps(it),1.0);\n    }\n    else\n    {\n    // Gamma with square root\n       return vec4( sqrt(col), t );\n    }\n\n}\n\nmat3 moveCamera(float time, out vec3 ro)\n{\n\t// Origin\n    ro =  vec3(2000.0*cos(iMouse.x*0.01),2000.0*sin(iMouse.x*0.01),1000.0) ;\n\t\n    // Target\n    vec3 ta = vec3(0.0,0.0,500.0);\n    \n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, 0.0,1.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec2 RayDirection(in vec2 pixel, out bool pip)\n{\n    // Pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;\n   if (pip==true)\n   {    \n    const float fraction=1.0/4.0;\n    // Picture in picture\n    if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))\n    {\n        p=(-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);\n        pip=true;\n    }\n       else\n       {\n           pip=false;\n       }\n   }\n   return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   // Time as function of the position of the mouse\n    float time = iTime*0.25 + 4.0*iMouse.x/iResolution.x;\n\n    // Camera transform\n    vec3 ro; \n    mat3 cam = moveCamera( time, ro);   \n\n    // Picture in picture\n    bool pip=true;\n    \n    // Pixel coordinates\n    vec2 p = RayDirection(fragCoord, pip);\n   \n    // Camera ray    \n    vec3 rd = cam * normalize(vec3(p,3.0));\n    \n    // Render\n    vec4 res = Render( ro, rd, pip );\n     \n    fragColor = vec4( res.xyz, 0.0 );\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Texturing\n// Eric Galin\n\n// Texturing and noise ---------------------------------------------------------\n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in space\nfloat Hash(in vec3 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// Procedural value noise with cubic interpolation\n// x : Point \nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix(mix( Hash(i+vec3(0,0,0)), \n                        Hash(i+vec3(1,0,0)),f.x),\n                   mix( Hash(i+vec3(0,1,0)), \n                        Hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( Hash(i+vec3(0,0,1)), \n                        Hash(i+vec3(1,0,1)),f.x),\n                   mix( Hash(i+vec3(0,1,1)), \n                        Hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in the plane\nfloat Hash(in vec2 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\n\n// Procedural value noise with cubic interpolation\n// x : Point \nfloat Noise(in vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix( Hash(i+vec2(0,0)), \n                        Hash(i+vec2(1,0)),f.x),\n                   mix( Hash(i+vec2(0,1)), \n                        Hash(i+vec2(1,1)),f.x),f.y);\n}\n\n//Fractal Brownian Noise for snow texture\nfloat fBm( vec3 p )\n{\n    float f = 0.0;\n    f += 0.5000*Noise(p); p = p*2.02;\n    f += 0.2500*Noise(p); p = p*2.03;\n    f += 0.1250*Noise(p); p = p*2.01;\n    f += 0.0625*Noise(p);\n    return f/0.9375;\n}\n\n//Fractal Brownian Noise for sphere ependant on the radius\nfloat fBmSphere( vec3 p, float radius )\n{\n    float f = 0.0;\n    float r = radius/2.0;\n    p /= radius;\n    f += r*Noise(p); p = p*2.;r /= 2.;\n    f += r*Noise(p); p = p*2.;r /= 2.;\n    f += r*Noise(p); p = p*2.;r /= 2.;\n    return f;\n}\n\n","name":"Common","description":"","type":"common"}]}