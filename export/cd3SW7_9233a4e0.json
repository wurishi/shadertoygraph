{"ver":"0.1","info":{"id":"cd3SW7","date":"1710589201","viewed":24,"name":"lhe-march2","username":"lhe","description":"second raymarching test","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON (1.0e-3)\n#define THRESHOLD (1.0e-1)\n#define MAX_CYCLES 180\n\nfloat sdIntersect(in float a, in float b) {\n    return max(a, b);\n}\n\nfloat sdSphere(in vec3 coord, in vec3 center, float radius) {\n    return length(coord - center) - radius;\n}\n\nvec3 snSphere(in vec3 coord, in vec3 center, float radius) {\n    return normalize(coord - center);\n}\n\nfloat sdHalfSpace(in vec3 coord, in vec3 point, in vec3 normal) {\n    return dot(normal, coord - point);\n}\n\nvec3 snHalfSpace(in vec3 coord, in vec3 point, in vec3 normal) {\n    return normal;\n}\n\nfloat sdPiped(in vec3 coord, in vec3 point, in vec3 a, in vec3 b, in vec3 c) {\n    return sdIntersect(\n        sdIntersect(\n            sdHalfSpace(coord, point, -normalize(cross(a, b))),\n            sdHalfSpace(coord, point, -normalize(cross(c, a)))\n        ),\n        sdIntersect(\n            sdIntersect(\n                sdHalfSpace(coord, point, -normalize(cross(b, c))),\n                sdHalfSpace(coord, point + c, normalize(cross(a, b)))\n            ),\n            sdIntersect(\n                sdHalfSpace(coord, point + b, normalize(cross(c, a))),\n                sdHalfSpace(coord, point + a, normalize(cross(b, c)))\n            )\n        )\n    );\n}\n\nfloat sdComplex(in vec3 coord) {\n    vec3 center = vec3(iMouse.xy, -100.0);\n    float radius = 50.0;\n    return max(\n        -sdSphere(coord, center, radius - 2.0),\n        sdPiped(coord, center - vec3(0.0, radius, radius), vec3(2.0 * radius, 0.0, 0.0), vec3(0.0, 2.0 * radius, 0.0), vec3(0.0, 0.0, 2.0 * radius))\n    );\n    //return sdSphere(coord, center, radius);\n}\n\nvec3 snComplex(in vec3 coord) {\n    float sd = sdComplex(coord);\n    return normalize(vec3(\n        sdComplex(coord + vec3(EPSILON, 0.0, 0.0)) - sd,\n        sdComplex(coord + vec3(0.0, EPSILON, 0.0)) - sd,\n        sdComplex(coord + vec3(0.0, 0.0, EPSILON)) - sd\n    ));\n}\n\nvec3 orthoRay(in vec2 screen, float s) {\n    return vec3(screen, -s);\n}\n\nvec3 perspRay(in vec2 screen, float s) {\n    float focal = 500.0;\n    vec3 ray = vec3(screen - iResolution.xy * 0.5, -focal);\n    return vec3(iResolution.xy * 0.5, focal) + s * normalize(ray);\n}\n\nstruct hit {\n    bool visible;\n    vec3 point;\n    vec3 normal;\n};\n\nhit march(in vec2 screen) {\n    vec3 center = vec3(iMouse.xy, -100.0);\n    float radius = 50.0;\n    float s = 0.0;\n    for (int i = 0; i < MAX_CYCLES; i++) {\n        vec3 coord = perspRay(screen, s);\n        //float dist = sdPiped(coord, center -radius, vec3(radius, 0.0, 0.0), vec3(0.0, radius, 0.0), vec3(0.0, 0.0, radius));\n        //float dist = sdHalfSpace(coord, center, vec3(1.0, 0.0, 0.0));\n        //float dist = sdSphere(coord, center, radius);\n        float dist = sdComplex(coord);\n        \n        if (dist < THRESHOLD) {\n            // vec3 norm = snSphere(coord, center, radius);\n            vec3 norm = snComplex(coord);\n            return hit(true, coord, norm);\n        }\n        s += dist;\n    }\n    return hit(false, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0));\n}\n\nstruct light {\n    vec3 source;\n    vec3 intensity;\n};\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    light[] lights = light[](\n        light(vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 1.0)),\n        light(vec3(iResolution.xy/2.0, -200.0), vec3(1.0, 1.0, 1.0))\n    );\n    vec3 camera = vec3(iResolution.xy/2.0, 0.0);\n    float kA = 1.0, kD = 0.3, kS = 0.3;\n    hit h = march(fragCoord);\n    if (h.visible) {\n        vec3 lum = kA * vec3(0.1, 0.0, 0.0);\n        for (int i = 0; i < 2; i++) {\n            light l = lights[i];\n            vec3 L = normalize(l.source - h.point);\n            float d = dot(h.normal, L);\n            if (d < 0.0) continue;\n            vec3 diffuse = d * l.intensity;\n            \n            vec3 reflection = 2.0 * d * h.normal - L;\n            vec3 view = normalize(camera - h.point);\n            vec3 specular = max(0.0, dot(reflection, view)) * l.intensity;\n            \n            lum += kD * diffuse + kS * specular;\n        }\n        \n        //float lum = -dot(h.normal, normalize(h.point - vec3(iResolution.xy/2.0, 0.0)));\n        //fragColor = lum * vec4(0.8, 0.7, 0.8, 0.0) + vec4(0.0, 0.0, 0.0, 1.0);\n        //fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n        fragColor = vec4(lum, 1.0);\n    } else {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }   \n}\n\n","name":"Image","description":"","type":"image"}]}