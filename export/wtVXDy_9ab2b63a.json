{"ver":"0.1","info":{"id":"wtVXDy","date":"1584119759","viewed":60,"name":"RT memories","username":"btwist","description":"Basic ray-tracing with simple diffuse shading model.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float MAX_FLOAT = 1.175494351e+38;\nfloat PI = 3.14159265359;\nfloat EPS = 1e-6;\n\n\n// Global scene\nScene scene;\n\n\n/*    Scene building    *\n * -------------------- */\n\n/*\n * Adds an object to the scene\n */\nvoid addObject(in int type, in int index, in vec3 color)\n{\n    scene.objects[scene.objectCount].type = type;\n    scene.objects[scene.objectCount].typeIndex = index;\n    scene.objects[scene.objectCount].color = color;\n    scene.objectCount += 1;\n}\n\n/*\n * Adds a parametric plane to the scene\n */\nvoid addPlane(in vec3 p0, in vec3 normal, in vec3 color)\n{\n\tPlane p = Plane(p0, normal);\n    \n    scene.planes[scene.planeCount] = p;\n    addObject(PLANE, scene.planeCount, color);\n    scene.planeCount += 1;\n}\n\n/*\n * Adds a parametric sphere to the scene\n */\nvoid addSphere(in vec3 center, in float radius, in vec3 color)\n{\n    Sphere s = Sphere(center, radius);\n    \n    scene.spheres[scene.sphereCount] = s;\n    addObject(SPHERE, scene.sphereCount, color);\n    scene.sphereCount += 1;\n}\n\n/*\n * Adds a parametric light to the scene\n */\nvoid addLight(in vec3 pos, in vec3 color, in float constant, in float linear, in float quadratic)\n{\n    Light l = Light(pos, color, constant, linear, quadratic);\n    \n    scene.lights[scene.lightCount] = l;\n    scene.lightCount += 1;\n}\n\nvoid buildScene()\n{\n    scene.planeCount = 0;\n\tscene.sphereCount = 0;\n\tscene.lightCount = 0;\n    \n    // Planes\n    addPlane(vec3(-3.0, 0.0, 0.0), normalize(vec3(1.0, 0.0, 0.0)), vec3(1.0, 0.4, 0.4));\n    addPlane(vec3(3.0, 0.0, 0.0), normalize(vec3(-1.0, 0.0, 0.0)), vec3(0.4, 1.0, 0.4));\n    addPlane(vec3(0.0, -3.0, 0.0), normalize(vec3(0.0, 1.0, 0.0)), vec3(0.4, 0.4, 1.0));\n    \n    // Spheres\n    for (int i = 0; i < SPHERES_MAX_NUM; ++i) {\n        float acceleration = 0.1 * float(SPHERES_MAX_NUM - i);\n    \taddSphere(\n            vec3(2.0 * cos(acceleration * iTime), 2.0 * sin(acceleration * iTime), -3.0 * float(i)),\n            1.0,\n            hsv2rgb(vec3(360.0 * float(i) / float(SPHERES_MAX_NUM), 1.0, 1.0))\n        );\n    }\n    \n    // Lights\n    addLight(vec3(0.0, 0.0, 6.0 - 30.0 * (1.0 - sin(iTime))), vec3(1.0), 1.0, 0.09, 0.032);\n}\n\n\n/*   Intersection routines   *\n * ------------------------- */\n\n/*\n * Determines if a given ray intersects a parametric plane\n */\nbool intersectPlane(in vec3 rayOrig, in vec3 rayDir,\n                    in vec3 planeP0, in vec3 planeNormal,\n                    in float near, in float far,\n                    out float dist)\n{ \n    float den = -dot(planeNormal, rayDir);\n    \n    if (den > EPS) {\n        dist = dot(rayOrig - planeP0, planeNormal) / den;\n        \n        return dist >= near && dist <= far; \n    } \n \n    return false; \n}\n\n/*\n * Determines if a given ray intersects a parametric sphere\n */\nbool intersectSphere(in vec3 rayOrig, in vec3 rayDir,\n                     in vec3 sphereCenter, in float sphereRadius,\n                     in float near, in float far,\n                     out float dist)\n{\n\t// Compute ray-sphere intersection\n    float delta = dot(rayDir, rayOrig - sphereCenter);\n    delta *= delta;\n    delta -= dot(rayOrig - sphereCenter, rayOrig - sphereCenter) - sphereRadius * sphereRadius;\n    \n    if (delta < 0.0) // No intersection\n        return false;\n    \n    // If delta is zero, intersection point is unique\n    dist = -dot(rayDir, rayOrig - sphereCenter);\n    \n    // Otherwise there are two : take the point whose distance to the camera is the smallest\n    if (delta >= EPS)\n        dist = dist - sqrt(delta);\n    \n    // Check finally if the hit point lies between the near and far planes\n    if (dist < near || dist > far)\n        return false;\n    \n    return true;\n}\n\n/*\n * Determines if a given ray intersects any object of the scene\n */\nbool intersectScene(in vec3 rayOrig, in vec3 rayDir,\n                    in float near, in float far,\n                    out Intersection inter)\n{\n    bool hit = false;\n    float dist = MAX_FLOAT, currentDist = MAX_FLOAT;\n    int hitObjectIndex = -1;\n    \n    // Check if the ray intersects one of the scene's objects\n    for (int i = 0; i < scene.objectCount; ++i)\n    {\n        Object obj = scene.objects[i];\n        \n        if (obj.type == PLANE) {\n            Plane plane = scene.planes[obj.typeIndex];\n            intersectPlane(rayOrig, rayDir, plane.p0, plane.normal, near, far, currentDist);\n        } else { // SPHERE\n            Sphere sphere = scene.spheres[obj.typeIndex];\n            intersectSphere(rayOrig, rayDir, sphere.center, sphere.radius, near, far, currentDist);\n        }\n        \n        if (currentDist < dist) {\n            dist = currentDist;\n            hitObjectIndex = i;\n        }\n    }\n    \n    if (hitObjectIndex == -1)\n        return false;\n    \n    Object hitObject = scene.objects[hitObjectIndex];\n    \n    // Update intersection\n    inter.dist = dist;\n    inter.point = rayOrig + dist * rayDir;\n    inter.color = hitObject.color;\n    \n    if (hitObject.type == PLANE)\n        inter.normal = scene.planes[hitObject.typeIndex].normal;\n    else // SPHERE\n        inter.normal = normalize(inter.point - scene.spheres[hitObject.typeIndex].center);\n    \n    return true;\n}\n\n\n/*     Lighting routine     *\n * ------------------------ */\n\n/*\n * Compute to the scene's light contributions for a given intersection point\n */\nvec4 forwardShading(Intersection inter)\n{\n    vec4 color = vec4(vec3(0.0), 1.0);\n    \n    // Loop over the lights and sum the contributions\n    for (int i = 0; i < scene.lightCount; ++i)\n    {\n        Light light = scene.lights[i];\n        \n        // Compute the fragment color based on a simple diffuse shading model\n        vec3 lightDir = normalize(light.position - inter.point);\n        float diffuse = max(dot(inter.normal, lightDir), 0.0);\n        vec3 diffuseColor = light.color * diffuse * inter.color;\n        \n        // Make the light intensity inversely proportional to the square of the distance to the light\n        float dist = length(light.position - inter.point);\n        float attenuation = 1.0 / (light.constant + light.linear * dist + light.quadratic * (dist * dist));\n        diffuseColor *= attenuation;\n        \n        color.xyz += diffuseColor;\n    }\n    \n    return color;\n}\n\n\n/*         Main         *\n * -------------------- */\n    \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    // Normalized device coordinates (from 0 to 1)\n    vec2 pixelCoord = fragCoord / iResolution.xy;\n    // Screen space coordinates (from -1 to 1)\n    pixelCoord = pixelCoord * 2.0 - vec2(1.0);\n    // Scale pixel with respect to image aspect ratio\n    float aspectRatio = iResolution.x / iResolution.y;\n    pixelCoord.x *= aspectRatio;\n    // Scale pixel with respect to camera field of view\n    float fov = PI * 0.25;\n    pixelCoord *= tan(fov * 0.5);\n    \n    vec3 camPos = vec3(0.0, 0.0, 8.0);\n    vec3 pixelPos = vec3(pixelCoord, camPos.z - 1.0); // Screen 1 unit away from camera origin\n    vec3 rayDir = normalize(pixelPos - camPos);\n    \n    // Create the scene\n\tbuildScene();\n    \n    // Ray-tracing time\n    Intersection inter;\n    \n    if (!intersectScene(camPos, rayDir, 1e-4, 1e4, inter)) {\n        // If there is no intersection with any object in the scene, return background color\n        float grad = smoothstep(-1.0, 0.5, pixelCoord.y);\n        fragColor = grad * vec4(0.0, 0.302, 0.365, 1.0) + (1.0 - grad) * vec4(vec3(0.0), 1.0);\n        fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n        return;\n    }\n    \n    // Shading (forward rendering)\n    fragColor = forwardShading(inter);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const int PLANE  = 0;\nconst int SPHERE = 1;\n\nconst int PLANES_MAX_NUM  = 10;\nconst int SPHERES_MAX_NUM = 20;\nconst int LIGHTS_MAX_NUM  = 10;\nconst int OBJECTS_MAX_NUM = PLANES_MAX_NUM + SPHERES_MAX_NUM;\n\n\n/*   Scene & objects definitions  *\n * ----------------------------- */\n\nstruct Object {\n    int          type;\n    int     typeIndex;\n    vec3        color;\n};\n\nstruct Plane {\n    vec3           p0;\n    vec3       normal;\n};\n\nstruct Sphere {\n    vec3       center;\n    float      radius;\n};\n\nstruct Light {\n    vec3     position;\n    vec3        color;\n    float    constant;\n    float      linear;\n    float   quadratic;\n};\n\nstruct Scene {\n\tObject  objects[OBJECTS_MAX_NUM];\n    Plane     planes[PLANES_MAX_NUM];\n    Sphere  spheres[SPHERES_MAX_NUM];\n    \n    Light     lights[LIGHTS_MAX_NUM];\n    \n    int                  objectCount;\n    int                   planeCount;\n    int                  sphereCount;\n    \n    int                   lightCount;\n};\n\n\n/*  Ray-geometry intersection  *\n * --------------------------- */\n\n\nstruct Intersection {\n    float      dist;\n    vec3      point;\n    vec3     normal;\n    vec3      color;\n};\n\n\n/*     Color utils     *\n * ------------------  */\n\n\nvec3[6] hsv2rgbCvtTable(in float value, in float f, in float l, in float m, in float n)\n{\n    vec3 cvtTable[6] = vec3[](\n        vec3(value, n, l),\n        vec3(m, value, l),\n        vec3(l, value, n),\n        vec3(l, m, value),\n        vec3(n, l, value),\n        vec3(value, l, m)\n\t);\n    \n    return cvtTable;\n}\n\n/*\n * https://fr.wikipedia.org/wiki/Teinte_Saturation_Valeur\n */\nvec3 hsv2rgb(in vec3 hsv)\n{\n    float hi = mod(floor(hsv.x * 0.01666666666), 6.0);\n    float f = hsv.x * 0.01666666666 - hi;\n    float l = hsv.z * (1.0 - hsv.y);\n    float m = hsv.z * (1.0 - f * hsv.y);\n    float n = hsv.z * (1.0 - (1.0 - f) * hsv.y);\n    \n    return hsv2rgbCvtTable(hsv.z, f, l, m, n)[int(hi)];\n}","name":"Common","description":"","type":"common"}]}