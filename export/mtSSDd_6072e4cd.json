{"ver":"0.1","info":{"id":"mtSSDd","date":"1676786826","viewed":493,"name":"Happy Moomin (v2)","username":"ytt","description":"A more accurate Moomin model","likes":37,"published":1,"flags":48,"usePreview":1,"tags":["grass","quaternion","outline","anime","moomin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//  _   _            ____   ____ __     __            ____    ____                _  _   _\n// | | | |    /\\    |  _ \\ |  _ \\\\ \\   / /  /\\ /\\    / __ \\  / __ \\    /\\ /\\    | || \\ | |\n// | |_| |   /  \\   | | | || | | |\\ \\ / /  /  V  \\  | |  | || |  | |  /  V  \\   | ||  \\| |\n// |  _  |  / /\\ \\  | |_| || |_| | \\ V /  / /\\ /\\ \\ | |  | || |  | | / /\\ /\\ \\  | || \\ \\ |\n// | | | | / ____ \\ |  __/ |  __/   | |  / /  V  \\ \\| |__| || |__| |/ /  V  \\ \\ | || |\\  |\n// |_| |_|/_/    \\_\\|_|    |_|      |_| /_/       \\_\\\\____/  \\____//_/       \\_\\|_||_| \\_|\n//\n\n//\n// Quickstart:\n//\n// - Toggle theme with F2\n// - Toggle navigation mode with N\n// - Move with W,A,S,D\n//\n\n//\n// Inputs:\n//\n// - Mouse drag - Swivel\n// - Ctrl + Mouse drag - Zoom\n// - Shift + Mouse drag - Pan\n// - Mouse click - Set pivot\n// - Mouse double click - Set pivot and center view (Inspect) / Teleport (Walk)\n//\n// - F1 - Toggle render mode (Compose, Steps, Normal, Depth, Shadow, Outline, Edge, UV)\n// - F2 - Toggle theme (Day, Night, Plain)\n// - N - Toggle navigation mode (Inspect, Walk)\n// - W,A,S,D - Move horizontally\n// - E,C - Move vertically\n// - +,- - Change render resolution\n// - R - Reset view\n//\n\n// MIT License\n// - Empty scene template:\n//   https://www.shadertoy.com/view/mlsSRN\n\n// Image - Scale and text\n// Inputs: Buffer C, Font\n\n// Notes:\n// - Keyframe (pose) definition is at Buffer A\n// - Keyframes can be mixed to create animation (see setPose usage at Buffer A's mainImage function)\n// - Reference image:\n//   https://i.pinimg.com/originals/b0/17/5a/b0175ab6fe33c7a24b75a657a26da6b5.png\n\n#define fontTexture(coord) texture(iChannel1, (coord) / vec2(1024.0))\n\nconst int[] text = int[](\n    87, 97, 108, 107, -1, // 0 - Walk\n    73, 110, 115, 112, 101, 99, 116, -1, // 1 - Inspect\n    80, 108, 97, 105, 110, -1, // 2 - Plain\n    68, 97, 121, -1, // 3 - Day\n    78, 105, 103, 104, 116, -1, // 4 - Night\n    67, 111, 109, 112, 111, 115, 101, -1, // 5 - Compose\n    83, 116, 101, 112, 115, -1, // 6 - Steps\n    78, 111, 114, 109, 97, 108, -1, // 7 - Normal\n    68, 101, 112, 116, 104, -1, // 8 - Depth\n    83, 104, 97, 100, 111, 119, -1, // 9 - Shadow\n    79, 117, 116, 108, 105, 110, 101, -1, // 10 - Outline\n    69, 100, 103, 101, -1, // 11 - Edge\n    85, 86, -1); // 12 - UV\n\nfloat characterTexture(vec2 pos, int index)\n{\n    vec2 index2 = vec2(float(index % 16), float(15 - index / 16));\n    return pos.x < 0.0 || pos.x > 64.0 || pos.y < 0.0 || pos.y > 64.0  ? 0.0 :\n        fontTexture(pos + 64.0 * index2).r;\n}\n\nvec2 numberTexture(vec2 pos, float value, int digits) // (mask, width)\n{\n    vec2 pos1 = pos;\n    float result = 0.0;\n\n    if (value < 0.0)\n    {\n        result += characterTexture(pos1, 45);\n        pos1.x -= 32.0;\n        value = abs(value);\n    }\n\n    int magnitude = int(max(floor(log(value) / 2.302585), 0.0)) + 1;\n\n    value /= pow(10.0, float(magnitude - 1));\n\n    while (magnitude > -digits)\n    {\n        int digit = int(floor(value));\n        result += characterTexture(pos1, digit + 48);\n        value = fract(value) * 10.0;\n\n        pos1.x -= 32.0;\n        magnitude--;\n\n        if (magnitude == 0 && digits > 0)\n        {\n            result += characterTexture(pos1, 46);\n            pos1.x -= 32.0;\n        }\n    }\n\n    return vec2(pos.x - pos1.x, min(result, 1.0));\n}\n\nfloat stringTexture(vec2 pos, int index)\n{\n    float result = 0.0;\n\n    int i = 0;\n    while (i < text.length() && index > 0)\n    {\n        if (text[i] == -1)\n        {\n            index--;\n        }\n\n        i++;\n    }\n\n    while (i < text.length() && text[i] != -1)\n    {\n        result += characterTexture(pos, text[i]);\n        pos.x -= 32.0;\n        i++;\n    }\n\n    return result;\n}\n\nfloat getTargetMask(vec2 pos)\n{\n    const float thickness = 2.0;\n    const float opening = 5.0;\n    const float size = 15.0;\n\n    pos.xy = abs(pos.xy);\n    pos = vec2(max(pos.x, pos.y), min(pos.x, pos.y));\n\n    return ((pos.x > opening && pos.x < size && pos.x > thickness && pos.y < thickness)) ? 1.0 : 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    deserializeState(iChannel0, iResolution.xy);\n\n    vec2 skipState = fragCoord.x < STATE_SIZE + 2.0 && fragCoord.y < 3.0 ? vec2y(3.0) : vec2(0.0);\n    vec2 uv = (fragCoord.xy + skipState) / iResolution.xy;\n\n    float renderScale = state.renderScale;\n\n    #ifndef SMOOTH_SCALE\n        uv = round(uv * renderScale * iResolution.xy) / (renderScale * iResolution.xy);\n    #endif\n\n    uv *= renderScale;\n    uv += (1.0 - renderScale) / 2.0;\n\n    vec3 color = texture(iChannel0, uv).rgb;\n\n    float annotation = 0.0;\n\n    vec2 p = fragCoord.xy;\n\n    vec2 p2 = p;\n    if (iTime < state.targetAnnotation.z + 0.05 && state.targetAnnotation.w > 0.0)\n    {\n        annotation += getTargetMask(p2 - state.targetAnnotation.xy);\n    }\n\n    #ifdef DISPLAY_DEBUG_VALUE\n        p2 = p;\n        p2 /= TEXT_SCALE;\n        vec4 displayValue = state.debug;\n        p2.y -= 3.0 * 60.0; // 3 lines up\n        annotation += numberTexture(p2, displayValue.x, 2).y; p2.y += 60.0;\n        annotation += numberTexture(p2, displayValue.y, 2).y; p2.y += 60.0;\n        annotation += numberTexture(p2, displayValue.z, 2).y; p2.y += 60.0;\n        annotation += numberTexture(p2, displayValue.w, 2).y; p2.y += 60.0;\n    #endif\n\n    if (state.modeAnnotation.x > 0.0 && iTime < state.modeAnnotation.y + 1.0)\n    {\n        p2 = p;\n        p2.y -= iResolution.y;\n        p2 /= TEXT_SCALE;\n        p2.y += 75.0;\n\n        if (state.modeAnnotation.x > 3.0)\n        {\n            vec2 p3 = p2;\n            vec2 t2 = numberTexture(p3, state.nextRenderScale * 100.0, 0);\n            annotation += t2.y;\n            p3.x -= t2.x;\n            annotation += characterTexture(p3, 37); // \"%\"\n\n            p3 = p2;\n            p3.y += 60.0;\n            t2 = numberTexture(p3, state.nextRenderScale * iResolution.x, 0);\n            annotation += t2.y;\n            p3.x -= t2.x;\n            annotation += characterTexture(p3, 120); // \"x\"\n            p3.x -= 32.0;\n            t2 = numberTexture(p3, state.nextRenderScale * iResolution.y, 0);\n            annotation += t2.y;\n        }\n        else if (state.modeAnnotation.x > 2.0)\n        {\n            annotation += stringTexture(p2, int(state.navigationMode));\n        }\n        else if (state.modeAnnotation.x > 1.0)\n        {\n            annotation += stringTexture(p2, 2 + int(state.nextTheme));\n        }\n        else\n        {\n            annotation += stringTexture(p2, 5 + int(state.nextRenderMode));\n        }\n    }\n\n    vec3 annotationColor = vec3(min(step(color.r, 0.2) + step(color.g, 0.2) + step(color.b, 0.2), 1.0));\n    color = mix(color, annotationColor, min(annotation, 1.0));\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// MIT License\n\n// Common\n\n// --- Scene parameters ---\n\nconst vec3 INITIAL_TARGET = vec3(0.0, 1.2, 0.0);\nconst vec3 INITIAL_ORIGIN = vec3(0.0, 2.1, 2.3);\nconst vec3 SUN_DIRECTION = normalize(vec3(1.0));\n\n//#define SMOOTH_SCALE\n//#define DISPLAY_DEBUG_VALUE\n#define TEXT_SCALE 0.6\n\n#define MAX_STEPS 100\n#define MAX_REFLECTION_STEPS 30\n#define MAX_DIST 600.0\n#define MAX_DIST_LOG 6.4\n#define FIELD_OF_VIEW 1.8\n#define SURF_DIST 0.0001\n#define BOUNDS_MARGIN 0.2\n#define BOUNDS_MARGIN_LARGE 0.4\n\n// --- Materials ---\n#define MATERIAL_EMPTY 0.0\n#define MATERIAL_SKY 1.0\n#define MATERIAL_GRASS 2.0\n#define MATERIAL_FLOWER1 3.0\n#define MATERIAL_FLOWER2 4.0\n#define MATERIAL_MOUNTAIN 5.0\n#define MATERIAL_ROCK 6.0\n#define MATERIAL_SKIN 7.0\n#define MATERIAL_EYE 8.0\n#define MATERIAL_PUPIL 9.0\n#define MATERIAL_MOUTH 10.0\n\n// Materials properties\n#define materialHasOutline(m) ((m) >= MATERIAL_ROCK || (m) >= MATERIAL_FLOWER1 && (m) <= MATERIAL_FLOWER2)\n#define materialHasInnerLines(m) ((m) >= MATERIAL_MOUNTAIN)\n#define materialFadeOutlines(m) ((m) >= MATERIAL_GRASS && maxIndex1 <= MATERIAL_FLOWER2)\n#define materialFadeInnerLines(m) ((m) != MATERIAL_MOUNTAIN)\n#define materialCastsShadow(m) ((m) >= MATERIAL_ROCK)\n#define materialReceivesShadow(m) ((m) > MATERIAL_SKY && (m) < MATERIAL_MOUNTAIN || (m) > MATERIAL_CLOUD)\n#define materialHasGroundBounceLight(m) ((m) > MATERIAL_GRASS && (m) < MATERIAL_SKIN)\n\n// --- Interaction ---\n#define ZOOM_DRAG_SPEED 4.0\n#define ZOOM_SCROLL_SPEED 0.3\n#define MOVE_CAMERA_HEIGHT 1.0\n#define MOVE_SPEED1 4.0\n#define MOVE_SPEED2 8.0\n#define MOVE_GRAVITY 4.0\n#define MOVE_COLLISION 6.0\n#define SWIVEL_SPEED 5.0\n#define CLICK_TIME 0.4\n#define MIN_CAMERA_HEIGHT 0.2\n\n// --- Constants ---\n#define PI025 0.78539816339\n#define PI05 1.57079632679\n#define PI075 2.35619449019\n#define PI 3.14159265359\n#define PI2 6.28318530718\n\n#define map11_01(x) (((x) + 1.0) * 0.5)\n#define map01_11(x) ((x) * 2.0 - 1.0)\n\n#define vec2x(x) vec2(x, 0.0)\n#define vec2y(y) vec2(0.0, y)\n#define vec3x(x) vec3(x, 0.0, 0.0)\n#define vec3y(y) vec3(0.0, y, 0.0)\n#define vec3z(z) vec3(0.0, 0.0, z)\n\n#define vec2x1 vec2(1.0, 0.0)\n#define vec2y1 vec2(0.0, 1.0)\n#define vec3x1 vec3(1.0, 0.0, 0.0)\n#define vec3y1 vec3(0.0, 1.0, 0.0)\n#define vec3z1 vec3(0.0, 0.0, 1.0)\n\n\n#define KEY_SHIFT 16\n#define KEY_CONTROL 17\n#define KEY_A 65\n#define KEY_C 67\n#define KEY_D 68\n#define KEY_E 69\n#define KEY_N 78\n#define KEY_R 82\n#define KEY_S 83\n#define KEY_W 87\n#define KEY_KP_PLUS 107\n#define KEY_KP_MINUS 109\n#define KEY_F1 112\n#define KEY_F2 113\n#define KEY_EQUALS 61\n#define KEY_MINUS 173\n#define BUTTON_LEFT 245\n#define BUTTON_MIDDLE 246\n#define BUTTON_RIGHT 247\n#define MOUSE_SCROLL_UP 250\n#define MOUSE_SCROLL_DOWN 251\n\n#define inputTexture(coord) texture(iChannel0, (coord) / iResolution.xy)\n#define inputTextureState(i) texture(iChannel0, vec2(float(i) + 0.5, 0.5) / iResolution.xy)\n\n// --- Serialization ---\n\n// Buffer definition (broken into [whole].[fraction] parts):\n//     x: outline.depth\n//     y: material.uv_x\n//     z: edge.uv_y\n//     w: tint.shadow\n\n#define getOutlineComponent(t) floor(t.x)\n#define getDepthComponent(t) fract(t.x)\n#define getMaterialIndexComponent(t) floor(t.y)\n#define getEdgeGroupComponent(t) floor(t.z)\n#define getMaterialUvComponent(t) fract(t.yz)\n#define getTintIndexComponent(t) floor(t.w)\n#define getShadowComponent(t) fract(t.w)\n\n#define setOutlineComponent(t, g) vec4(fract(t.x) + g, t.yzw)\n#define serializeDepth(d) clamp(log((d) + 1.0) / MAX_DIST_LOG, 0.0, 0.9999)\n#define deserializeDepth(d) (exp((d) * MAX_DIST_LOG) - 1.0)\n\nstruct State\n{\n    bool initialized; // 0 - state initialized\n    vec3 origin; // 1 - camera origin\n    vec3 target; // 2 - camera target\n    vec3 targetOffset; // 3 - camera target offset (when target is set but not centered)\n    vec4 targetAnnotation; // 4 - camera target offset (when target is set but not centered)\n    vec3 nextOrigin; // 5 - next frame navigated origin\n    vec3 nextTarget; // 6 - next frame navigated target\n    vec3 nextTargetOffset; // 7\n    vec3 viewX; // 8 - camera x axis (cached)\n    vec3 viewY; // 9 - camera y axis (cached)\n    vec3 viewZ; // 10 - camera z axis (cached)\n    vec3 viewOrigin; // 11 - clipped camera origin (above ground)\n    float dragStartTime; // 12\n    vec2 dragStartPosition; // 13\n    vec2 dragLastPosition; // 14 - non applied drag delta start\n    float renderMode; // 15\n    float renderScale; // 16\n    float nextRenderMode; // 17\n    float nextRenderScale; // 18\n    float navigationMode; // 19\n    bool focused; // 20 - viewport was clicked\n    float clickTime; // 21\n    float clickCount; // 22\n    vec2 modeAnnotation; // 23\n    float theme; // 24\n    float nextTheme; // 25\n    vec4 debug; // 26\n} state;\n\n#define STATE_SIZE 27.0\n\nvoid deserializeState(sampler2D iChannel0, vec2 iResolution)\n{\n    state.initialized = inputTextureState(0).x > 0.0;\n    state.origin = inputTextureState(1).xyz;\n    state.target = inputTextureState(2).xyz;\n    state.targetOffset = inputTextureState(3).xyz;\n    state.targetAnnotation = inputTextureState(4);\n    state.nextOrigin = inputTextureState(5).xyz;\n    state.nextTarget = inputTextureState(6).xyz;\n    state.nextTargetOffset = inputTextureState(7).xyz;\n    state.viewX = inputTextureState(8).xyz;\n    state.viewY = inputTextureState(9).xyz;\n    state.viewZ = inputTextureState(10).xyz;\n    state.viewOrigin = inputTextureState(11).xyz;\n    state.dragStartTime = inputTextureState(12).x;\n    state.dragStartPosition = inputTextureState(13).xy;\n    state.dragLastPosition = inputTextureState(14).xy;\n    state.renderMode = inputTextureState(15).x;\n    state.renderScale = inputTextureState(16).x;\n    state.nextRenderMode = inputTextureState(17).x;\n    state.nextRenderScale = inputTextureState(18).x;\n    state.navigationMode = inputTextureState(19).x;\n    state.focused = inputTextureState(20).x > 0.0;\n    state.clickTime = inputTextureState(21).x;\n    state.clickCount = inputTextureState(22).x;\n    state.modeAnnotation = inputTextureState(23).xy;\n    state.theme = inputTextureState(24).x;\n    state.nextTheme = inputTextureState(25).x;\n    state.debug = inputTextureState(26);\n}\n\nvec4 serializeState(int index)\n{\n    if (index == 0) return vec4(state.initialized ? 1.0 : 0.0, 0.0, 0.0, 0.0);\n    if (index == 1) return vec4(state.origin, 0.0);\n    if (index == 2) return vec4(state.target, 0.0);\n    if (index == 3) return vec4(state.targetOffset, 0.0);\n    if (index == 4) return vec4(state.targetAnnotation);\n    if (index == 5) return vec4(state.nextOrigin, 0.0);\n    if (index == 6) return vec4(state.nextTarget, 0.0);\n    if (index == 7) return vec4(state.nextTargetOffset, 0.0);\n    if (index == 8) return vec4(state.viewX, 0.0);\n    if (index == 9) return vec4(state.viewY, 0.0);\n    if (index == 10) return vec4(state.viewZ, 0.0);\n    if (index == 11) return vec4(state.viewOrigin, 0.0);\n    if (index == 12) return vec4(state.dragStartTime, 0.0, 0.0, 0.0);\n    if (index == 13) return vec4(state.dragStartPosition, 0.0, 0.0);\n    if (index == 14) return vec4(state.dragLastPosition, 0.0, 0.0);\n    if (index == 15) return vec4(state.renderMode, 0.0, 0.0, 0.0);\n    if (index == 16) return vec4(state.renderScale, 0.0, 0.0, 0.0);\n    if (index == 17) return vec4(state.nextRenderMode, 0.0, 0.0, 0.0);\n    if (index == 18) return vec4(state.nextRenderScale, 0.0, 0.0, 0.0);\n    if (index == 19) return vec4(state.navigationMode, 0.0, 0.0, 0.0);\n    if (index == 20) return vec4(state.focused ? 1.0 : 0.0, 0.0, 0.0, 0.0);\n    if (index == 21) return vec4(state.clickTime, 0.0, 0.0, 0.0);\n    if (index == 22) return vec4(state.clickCount, 0.0, 0.0, 0.0);\n    if (index == 23) return vec4(state.modeAnnotation, 0.0, 0.0);\n    if (index == 24) return vec4(state.theme, 0.0, 0.0, 0.0);\n    if (index == 25) return vec4(state.nextTheme, 0.0, 0.0, 0.0);\n    if (index == 26) return vec4(state.debug);\n\n    return vec4(0.0);\n}\n\nvoid resetState()\n{\n    state.initialized = false;\n    state.origin = vec3(0.0);\n    state.target = vec3(0.0);\n    state.targetOffset = vec3(0.0);\n    state.nextOrigin = vec3(0.0);\n    state.nextTarget = vec3(0.0);\n    state.nextTargetOffset = vec3(0.0);\n    state.viewX = vec3(0.0);\n    state.viewY = vec3(0.0);\n    state.viewZ = vec3(0.0);\n    state.viewOrigin = vec3(0.0);\n    state.dragStartTime = 0.0;\n    state.dragStartPosition = vec2(0.0);\n    state.dragLastPosition = vec2(0.0);\n    state.renderMode = 0.0;\n    state.renderScale = 0.0;\n    state.nextRenderMode = 0.0;\n    state.nextRenderScale = 0.0;\n    state.navigationMode = 0.0;\n    state.focused = false;\n    state.clickTime = 0.0;\n    state.clickCount = 0.0;\n    state.modeAnnotation = vec2(0.0);\n    state.theme = 0.0;\n    state.nextTheme = 0.0;\n    state.debug = vec4(0.0);\n}\n\n// --- Common functions ---\n\nfloat smin(float a, float b, float k) // smooth min\n{\n    k = max(k, 0.001);\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * h * k / 6.0;\n}\n\nvec3 smin(vec3 a, vec3 b, float k) // x component smooth min\n{\n    float x = smin(a.x, b.x, k);\n    return vec3(x, a.x <= b.x ? a.yz : b.yz);\n}\n\nfloat smax(float a, float b, float k) // smooth max\n{\n    k = max(k, 0.001);\n    float h = max(k - abs(a - b), 0.0) / k;\n    return max(a, b) + h * h * h * k / 6.0;\n}\n\nvec3 smax(vec3 a, vec3 b, float k) // x component smooth max\n{\n    float x = smax(a.x, b.x, k);\n    return vec3(x, a.x <= b.x ? b.yz : a.yz);\n}\n\nvec2 minx(vec2 a, vec2 b) // x component min\n{\n    return a.x <= b.x ? a : b;\n}\n\nvec3 minx(vec3 a, vec3 b) // x component min\n{\n    return a.x <= b.x ? a : b;\n}\n\nvec4 minx(vec4 a, vec4 b) // x component min\n{\n    return a.x <= b.x ? a : b;\n}\n\nvec2 maxx(vec2 a, vec2 b) // x component max\n{\n    return a.x >= b.x ? a : b;\n}\n\nvec3 maxx(vec3 a, vec3 b) // x component max\n{\n    return a.x >= b.x ? a : b;\n}\n\nvec4 maxx(vec4 a, vec4 b) // x component max\n{\n    return a.x >= b.x ? a : b;\n}\n\n// smooth merge based on k, and interpolating a.w, and b.w\nvec4 smin(vec4 a, vec4 b, float k)\n{\n    float x = smin(a.x, b.x, k);\n\n    float d = abs(x - a.x) - abs(x - b.x);\n    d = clamp(d * 6.0, -1.0, 1.0);\n\n    float w = a.w * max(0.0, -d) + b.w * max(0.0, d);\n\n    return vec4(x, a.x <= b.x ? a.yz : b.yz, w);\n}\n\n// smooth merge based on b.w\nvec3 smin(vec3 a, vec4 b)\n{\n    return smin(a, b.xyz, b.w);\n}\n\n// smooth merge based on b.w, while keeping a.w unchanged\nvec4 smin(vec4 a, vec4 b)\n{\n    return vec4(smin(a.xyz, b.xyz, b.w), a.w);\n}\n\nmat2 rotation(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, s, -s, c);\n}\n\nfloat pow2(float value)\n{\n    return value * value;\n}\n\nfloat stretchAxis(float p, float w)\n{\n    p += w * 0.5;\n    return p - clamp(p, 0.0, w);\n}\n\nfloat stretchAxis(float p, float a, float b)\n{\n    return p - clamp(p, a, b) + a;\n}\n\nvec2 bendSpace(vec2 pos, vec2 origin, float stretch, float squash, float angle)\n{\n    angle *= 0.5;\n    pos += origin;\n    float a = atan(pos.y, pos.x);\n    a += angle; // rotate\n    a = mod(a + PI, PI2) - PI; // map back to -PI..PI\n\n    float side = step(0.0, angle) * PI; // stretch side 0 or PI\n\n    float f = 1.0 - exp(-abs((side - abs(a)) / stretch)); // exponential ease-in from 0 to stretch\n    f -= exp(-abs(PI - side - abs(a)) / squash); // exponential ease-out from PI-squash to PI\n\n    a = sign(a) * clamp(abs(a) + f * angle, 0.0, PI);\n\n    pos = length(pos) * vec2(cos(a), sin(a));\n    pos -= origin;\n\n    return pos;\n}\n\nvec2 radialMod(vec2 p, float count, out float index)\n{\n    float angle = atan(p.y, p.x);\n    float size = PI2 / count;\n\n    index = angle / size + 0.5;\n    angle = (fract(index) - 0.5) * size;\n\n    index = floor(index);\n    return vec2(cos(angle), sin(angle)) * length(p.xy);\n}\n\n\n// --- Quaternions ---\n\nconst vec4 quaternion0 = vec4(0.0, 0.0, 0.0, 1.0);\n\n#define quaternion(axis, a) vec4(sin(a / 2.0) * axis.xyz, cos(a / 2.0))\n#define quaternionx(a) vec4(sin(a / 2.0), 0.0, 0.0, cos(a / 2.0))\n#define quaterniony(a) vec4(0.0, sin(a / 2.0), 0.0, cos(a / 2.0))\n#define quaternionz(a) vec4(0.0, 0.0, sin(a / 2.0), cos(a / 2.0))\n\nvec4 quaternionInverse(vec4 q)\n{\n    return vec4(-q.xyz, q.w);\n}\n\nvec4 quaternionScale(vec4 q, float scale)\n{\n    float angle = acos(q.w) * 2.0;\n    vec3 axis = q.xyz / sin(angle / 2.0);\n\n    return quaternion(axis, angle * scale);\n}\n\nvec4 multiply(vec4 q1, vec4 q2)\n{\n    return vec4(q1.w * q2.xyz + q2.w * q1.xyz + cross(q1.xyz, q2.xyz), q1.w * q2.w - dot(q1.xyz, q2.xyz));\n}\n\nvec4 multiply(vec4 q1, vec4 q2, vec4 q3)\n{\n    vec4 q12 = vec4(q1.w * q2.xyz + q2.w * q1.xyz + cross(q1.xyz, q2.xyz), q1.w * q2.w - dot(q1.xyz, q2.xyz));\n    return vec4(q12.w * q3.xyz + q3.w * q12.xyz + cross(q12.xyz, q3.xyz), q12.w * q3.w - dot(q12.xyz, q3.xyz));\n}\n\nvec3 rotate(vec3 pos, vec4 q)\n{\n    vec3 t = q.w * pos + cross(q.xyz, pos);\n    return dot(q.xyz, pos) * q.xyz + q.w * t - cross(t, q.xyz);\n}\n\n// --- Noise ---\n\nfloat hash(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(vec2 pos)\n{\n    vec2 p = floor(pos);\n    vec2 f = fract(pos);\n\n    f = f * f * (3.0 - 2.0 * f);\n\n    float n = p.x + 7.0 * p.y;\n\n    return mix(mix(hash(n), hash(n + 1.0), f.x),\n               mix(hash(n + 7.0), hash(n + 8.0), f.x), f.y);\n}\n\nfloat noise(vec3 pos)\n{\n    vec3 p = floor(pos);\n    vec3 f = fract(pos);\n\n    f = f * f * (3.0 - 2.0 * f);\n\n    float a = 37.0;\n    float b = 19.0;\n\n    float n = p.x + a * p.y + b * p.z;\n\n    float res = mix(mix(mix(hash(n), hash(n + 1.0), f.x),\n                        mix(hash(n + a), hash(n + a + 1.0), f.x), f.y),\n                    mix(mix(hash(n + b), hash(n + b + 1.0), f.x),\n                        mix(hash(n + a + b), hash(n + a + b + 1.0), f.x), f.y), f.z);\n    return res;\n}\n\nfloat fbm(vec2 p)\n{\n    float f = 0.5 * noise(p);\n    p *= 2.1; f += 0.25 * noise(p);\n    p *= 2.1; f += 0.25 * noise(p);\n    return f;\n}\n\nfloat fbm(vec3 p)\n{\n    float f = 0.5 * noise(p);\n    p *= 2.1; f += 0.25 * noise(p);\n    return f;\n}\n\n// --- SDF ---\n\nfloat sdCircle(vec2 pos, float size)\n{\n    return length(pos) - size;\n}\n\nfloat sdRectangle(vec2 pos, vec2 size)\n{\n    vec2 d = abs(pos) - size;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat sdSphere(vec3 pos, float size)\n{\n    return length(pos) - size;\n}\n\nfloat sdEllipsoid(vec3 pos, vec3 rad)\n{\n    float k0 = length(pos / rad);\n    float k1 = length(pos / rad / rad);\n    return k0 * (k0 - 1.0) / k1;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp( dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\n  return length(pa - ba * h) - r;\n}\n\nfloat sdArc(vec3 pos, float len, float angle, float width, float taper)\n{\n    angle = map01_11(step(0.0, angle)) * max(abs(angle), 0.01);\n\n    // parameters\n    vec2 sc = vec2(sin(angle), cos(angle));\n    float ra = 0.5 * len / angle;\n\n    // recenter\n    pos.x -= ra;\n\n    // reflect\n    vec2 q = pos.xy - 2.0 * sc * max(0.0, dot(sc, pos.xy));\n\n    float u = abs(ra) - length(q);\n    float d2 = (q.y < 0.0) ? dot(q + vec2(ra, 0.0), q + vec2(ra, 0.0)) : u * u;\n    float s = sign(angle);\n\n    float t = (pos.y > 0.0) ? atan(s * pos.y, -s * pos.x) * ra : (s * pos.x < 0.0) ? pos.y : len - pos.y;\n    width = max(0.001, width - t * taper);\n\n    return sqrt(d2 + pos.z * pos.z) - width;\n}\n\nfloat sdBox(vec3 pos, vec3 size)\n{\n    vec3 d = abs(pos) - size;\n    return length(max(d, 0.0)) + min(max(max(d.x, d.y), d.z), 0.0);\n}\n\nfloat sdBoxApprox(vec3 pos, vec3 size)\n{\n    vec3 d = abs(pos) - size;\n    return max(max(d.x, d.y), d.z);\n}\n\nfloat sdBoxApprox(vec3 pos, vec3 size, vec3 origin)\n{\n    return sdBoxApprox(pos - origin * size, size);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// MIT License\n\n// Buffer A - Model and navigation\n// Inputs: Buffer A, Keyboard\n\n#define keyboardTexture(coord) texture(iChannel1, (coord) / vec2(256.0, 3.0))\n\n// steps view values\nint marchSteps = 0;\nint marchTransparentSteps = 0;\nint marchReflectionSteps = 0;\nint marchShadowSteps = 0;\n\n// Consts\nconst mat2 rotation_0 = mat2(1.0, 0.0, 0.0, 1.0);\nconst mat2 rotation_1 = mat2(0.9998476, 0.0174524, -0.0174524, 0.9998476);\nconst mat2 rotation_7_5 = mat2(0.9914448, 0.1305261, -0.1305261, 0.9914448);\nconst mat2 rotation_10 = mat2(0.9848077, 0.1736481, -0.1736481, 0.9848077);\nconst mat2 rotation_15 = mat2(0.9659258, 0.258819, -0.258819, 0.9659258);\nconst mat2 rotation_20 = mat2(0.9396926, 0.342020, -0.342020, 0.9396926);\nconst mat2 rotation_25 = mat2(0.9063077, 0.422618, -0.422618, 0.9063077);\nconst mat2 rotation_30 = mat2(0.8660254, 0.5, -0.5, 0.8660254);\nconst mat2 rotation_45 = mat2(0.7071067, 0.7071067, -0.7071067, 0.7071067);\nconst mat2 rotation_60 = mat2(0.5, 0.8660254, -0.8660254, 0.5);\nconst mat2 rotation_90 = mat2(0.0, 1.0, -1.0, 0.0);\nconst mat2 rotation_120 = mat2(-0.5, 0.8660254, -0.8660254, -0.5);\nconst mat2 rotation_145 = mat2(-0.8191520, 0.5735764, -0.5735764, -0.8191520);\nconst mat2 rotation_180 = mat2(-1.0, 0.0, 0.0, -1.0);\n\nconst mat2 rotation_n1 = mat2(0.9998476, -0.0174524, 0.0174524, 0.9998476);\nconst mat2 rotation_n7_5 = mat2(0.9914448, -0.1305261, 0.1305261, 0.9914448);\nconst mat2 rotation_n10 = mat2(0.9848077, -0.1736481, 0.1736481, 0.9848077);\nconst mat2 rotation_n15 = mat2(0.9659258, -0.258819, 0.258819, 0.9659258);\nconst mat2 rotation_n20 = mat2(0.9396926, -0.342020, 0.342020, 0.9396926);\nconst mat2 rotation_n25 = mat2(0.9063077, -0.422618, 0.422618, 0.9063077);\nconst mat2 rotation_n30 = mat2(0.8660254, -0.5, 0.5, 0.8660254);\nconst mat2 rotation_n36 = mat2(0.8090169, -0.5877852, 0.5877852, 0.8090169);\nconst mat2 rotation_n45 = mat2(0.7071067, -0.7071067, 0.7071067, 0.7071067);\nconst mat2 rotation_n60 = mat2(0.5, -0.8660254, 0.8660254, 0.5);\nconst mat2 rotation_n90 = mat2(0.0, -1.0, 1.0, 0.0);\nconst mat2 rotation_n120 = mat2(-0.5, -0.8660254, 0.8660254, -0.5);\nconst mat2 rotation_n145 = mat2(-0.8191520, -0.5735764, 0.5735764, -0.8191520);\nconst mat2 rotation_n180 = mat2(-1.0, -0.0, 0.0, -1.0);\n\n\n// -- Moomin --\n\n// - Keyframe contains animatable rotation angles (vec3), that could be mixed with\n// other keyframes values\n// - Pose contains quaternion rotation values (vec4) that are calculated based on\n// the applied keyframe (using setPose)\n\nstruct HeadPose\n{\n    vec4 rotation;\n    vec2 eyesDirection;\n    vec4 earsRotation;\n    float eyesOpen;\n    float eyelidsOffset;\n    float eyebrowsHeight;\n    float cheeksHeight;\n    float cheeksBlush;\n    float mouthHeight;\n    float mouthOpen;\n};\n\nstruct ArmPose\n{\n    vec4 shoulderRotation;\n    vec4 armRotation;\n    vec4 elbowRotation;\n    vec4 wristRotation;\n    float fingersSpread;\n    float fingersFold;\n};\n\nstruct LegPose\n{\n    vec4 baseRotation;\n    vec4 rotation;\n    vec4 kneeRotation;\n    vec4 footRotation;\n    float toesAngle;\n};\n\nstruct TailPose\n{\n    vec4 baseRotation;\n    vec4 rotation;\n    float curve;\n};\n\nstruct Pose\n{\n    vec3 offset;\n    vec4 rotation;\n    vec4 bodyCurve;\n    HeadPose head;\n    ArmPose rightArm;\n    ArmPose leftArm;\n    LegPose rightLeg;\n    LegPose leftLeg;\n    TailPose tail;\n} pose;\n\n// Keyframe\n\nstruct HeadKeyframe\n{\n    vec3 rotation;\n    vec2 eyesDirection;\n    vec3 earsRotation;\n    float eyesOpen;\n    float eyelidsOffset;\n    float eyebrowsHeight;\n    float cheeksHeight;\n    float cheeksBlush;\n    float mouthHeight;\n    float mouthOpen;\n};\n\nstruct ArmKeyframe\n{\n    vec3 shoulderRotation;\n    vec3 armRotation;\n    vec3 elbowRotation;\n    vec3 wristRotation;\n    float fingersSpread;\n    float fingersFold;\n};\n\nstruct LegKeyframe\n{\n    vec3 baseRotation;\n    vec3 rotation;\n    vec3 kneeRotation;\n    vec3 footRotation;\n    float toesAngle;\n};\n\nstruct TailKeyframe\n{\n    vec3 baseRotation;\n    vec3 rotation;\n    float curve;\n};\n\nstruct Keyframe\n{\n    vec3 offset;\n    vec3 rotation;\n    vec3 bodyCurve;\n    HeadKeyframe head;\n    ArmKeyframe rightArm;\n    ArmKeyframe leftArm;\n    LegKeyframe rightLeg;\n    LegKeyframe leftLeg;\n    TailKeyframe tail;\n};\n\nKeyframe emptyKeyframe = Keyframe(\n    vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), // body\n    HeadKeyframe(vec3(0.0, 0.0, 0.0), vec2(0.0, 0.0), vec3(0.0), 0.8, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0), // head\n    ArmKeyframe(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 0.0, 0.0), // right arm\n    ArmKeyframe(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 0.0, 0.0), // left arm\n    LegKeyframe(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 0.0), // right leg\n    LegKeyframe(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 0.0), // left leg\n    TailKeyframe(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 0.5)); // tail\n\nKeyframe happyKeyframe = Keyframe(\n    vec3(0.0, 0.7, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.225, -0.3, 0.0), // body\n    HeadKeyframe(vec3(-0.125, 0.325, -0.075), vec2(0.0, 0.0), vec3(0.0), 0.0, -0.8, 0.1, 1.0, 0.0, 0.0, 0.0), // head\n    ArmKeyframe(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.1, 0.4), vec3(0.0, 0.1, 0.0), vec3(0.0, 0.1, -0.3), 0.0, -0.1), // right arm\n    ArmKeyframe(vec3(0.0, 0.0, -0.2), vec3(0.0, -0.4, 0.3), vec3(0.0, 0.1, 0.0), vec3(0.0, 0.1, -0.15), 0.0, -0.1), // left arm\n    LegKeyframe(vec3(1.25, 0.3, -0.3), vec3(0.0, 0.0, 0.0), vec3(-0.8, 0.0, 0.0), vec3(0.3, 0.0, 0.0), 0.0), // right leg\n    LegKeyframe(vec3(0.1, 0.3, 0.1), vec3(-0.1, 0.2, -0.1), vec3(-0.2, 0.0, 0.0), vec3(-0.2, 0.0, 0.0), 0.0), // left leg\n    TailKeyframe(vec3(0.2, -0.3, 0.0), vec3(-0.1, 0.0, -0.6), 1.0)); // tail\n\nvoid setPose(Keyframe keyframe)\n{\n    #define set_vars(angle) s = sin(angle); c = cos(angle)\n    #define set_qx(target, angle)   set_vars(angle); target = vec4(s.x, 0.0, 0.0, c.x)\n    #define set_qy(target, angle)   set_vars(angle); target = vec4(0.0, s.y, 0.0, c.y)\n    #define set_qz(target, angle)   set_vars(angle); target = vec4(0.0, 0.0, s.z, c.z)\n    #define set_qxy(target, angle)  set_vars(angle); target = vec4(s.x * c.y, c.x * s.y, s.x * s.y, c.x * c.y)\n    #define set_qxz(target, angle)  set_vars(angle); target = vec4(s.x * c.z,  - s.x * s.z, c.x * s.z, c.x * c.z)\n    #define set_qyx(target, angle)  set_vars(angle); target = vec4(s.x * c.y, c.x * s.y,  - s.x * s.y, c.x * c.y)\n    #define set_qyz(target, angle)  set_vars(angle); target = vec4(s.y * s.z, s.y * c.z, c.y * s.z, c.y * c.z)\n    #define set_qzx(target, angle)  set_vars(angle); target = vec4(s.x * c.z, s.x * s.z, c.x * s.z, c.x * c.z)\n    #define set_qzy(target, angle)  set_vars(angle); target = vec4(-s.y * s.z, s.y * c.z, c.y * s.z, c.y * c.z)\n    #define set_qxyz(target, angle) set_vars(angle); target = vec4((s.x * c.y * c.z + c.x * s.y * s.z), (c.x * s.y * c.z - s.x * c.y * s.z), (c.x * c.y * s.z + s.x * s.y * c.z), (c.x * c.y * c.z - s.x * s.y * s.z))\n    #define set_qxzy(target, angle) set_vars(angle); target = vec4((s.x * c.y * c.z - c.x * s.y * s.z), (c.x * s.y * c.z - s.x * c.y * s.z), (c.x * c.y * s.z + s.x * s.y * c.z), (c.x * c.y * c.z + s.x * s.y * s.z))\n    #define set_qyxz(target, angle) set_vars(angle); target = vec4((s.x * c.y * c.z + c.x * s.y * s.z), (c.x * s.y * c.z - s.x * c.y * s.z), (c.x * c.y * s.z - s.x * s.y * c.z), (c.x * c.y * c.z + s.x * s.y * s.z))\n    #define set_qyzx(target, angle) set_vars(angle); target = vec4((s.x * c.y * c.z + c.x * s.y * s.z), (c.x * s.y * c.z + s.x * c.y * s.z), (c.x * c.y * s.z - s.x * s.y * c.z), (c.x * c.y * c.z - s.x * s.y * s.z))\n    #define set_qzxy(target, angle) set_vars(angle); target = vec4((s.x * c.y * c.z - c.x * s.y * s.z), (c.x * s.y * c.z + s.x * c.y * s.z), (c.x * c.y * s.z + s.x * s.y * c.z), (c.x * c.y * c.z - s.x * s.y * s.z))\n    #define set_qzyx(target, angle) set_vars(angle); target = vec4((s.x * c.y * c.z - c.x * s.y * s.z), (c.x * s.y * c.z + s.x * c.y * s.z), (c.x * c.y * s.z - s.x * s.y * c.z), (c.x * c.y * c.z + s.x * s.y * s.z))\n\n    vec3 s, c;\n\n    pose.offset = keyframe.offset;\n    set_qxyz(pose.rotation, keyframe.rotation);\n    set_qxyz(pose.bodyCurve, keyframe.bodyCurve);\n\n    set_qzxy(pose.head.rotation, keyframe.head.rotation);\n    pose.head.eyesDirection = keyframe.head.eyesDirection;\n    set_qzxy(pose.head.earsRotation, keyframe.head.earsRotation);\n    pose.head.eyesOpen = keyframe.head.eyesOpen;\n    pose.head.eyelidsOffset = keyframe.head.eyelidsOffset;\n    pose.head.eyebrowsHeight = keyframe.head.eyebrowsHeight;\n    pose.head.cheeksHeight = keyframe.head.cheeksHeight;\n    pose.head.cheeksBlush = keyframe.head.cheeksBlush;\n    pose.head.mouthHeight = keyframe.head.mouthHeight;\n    pose.head.mouthOpen = keyframe.head.mouthOpen;\n\n    set_qxyz(pose.rightArm.shoulderRotation, keyframe.rightArm.shoulderRotation);\n    set_qxyz(pose.rightArm.armRotation, keyframe.rightArm.armRotation);\n    set_qy(pose.rightArm.elbowRotation, keyframe.rightArm.elbowRotation);\n    set_qxyz(pose.rightArm.wristRotation, keyframe.rightArm.wristRotation);\n    pose.rightArm.fingersSpread = keyframe.rightArm.fingersSpread;\n    pose.rightArm.fingersFold = keyframe.rightArm.fingersFold;\n\n    set_qxyz(pose.leftArm.shoulderRotation, keyframe.leftArm.shoulderRotation);\n    set_qxyz(pose.leftArm.armRotation, keyframe.leftArm.armRotation);\n    set_qy(pose.leftArm.elbowRotation, keyframe.leftArm.elbowRotation);\n    set_qxyz(pose.leftArm.wristRotation, keyframe.leftArm.wristRotation);\n    pose.leftArm.fingersSpread = keyframe.leftArm.fingersSpread;\n    pose.leftArm.fingersFold = keyframe.leftArm.fingersFold;\n\n    set_qxyz(pose.rightLeg.baseRotation, keyframe.rightLeg.baseRotation);\n    set_qxyz(pose.rightLeg.rotation, keyframe.rightLeg.rotation);\n    set_qx(pose.rightLeg.kneeRotation, keyframe.rightLeg.kneeRotation);\n    set_qxyz(pose.rightLeg.footRotation, keyframe.rightLeg.footRotation);\n    pose.rightLeg.toesAngle = keyframe.rightLeg.toesAngle;\n\n    set_qxyz(pose.leftLeg.baseRotation, keyframe.leftLeg.baseRotation);\n    set_qxyz(pose.leftLeg.rotation, keyframe.leftLeg.rotation);\n    set_qx(pose.leftLeg.kneeRotation, keyframe.leftLeg.kneeRotation);\n    set_qxyz(pose.leftLeg.footRotation, keyframe.leftLeg.footRotation);\n    pose.leftLeg.toesAngle = keyframe.leftLeg.toesAngle;\n\n    set_qxyz(pose.tail.baseRotation, vec3(clamp(keyframe.tail.baseRotation.x, -0.5, 0.2), keyframe.tail.baseRotation.yz));\n    set_qxyz(pose.tail.rotation, vec3(clamp(keyframe.tail.rotation.x, -0.5, 0.2), keyframe.tail.rotation.yz));\n    pose.tail.curve = clamp(keyframe.tail.curve, -1.5, 1.5);\n}\n\nKeyframe mixKeyframe(Keyframe keyframe1, Keyframe keyframe2, float f)\n{\n    #define mixProperty(property) mix(keyframe1.property, keyframe2.property, f)\n\n    Keyframe keyframe;\n\n    keyframe.offset = mixProperty(offset);\n    keyframe.rotation = mixProperty(rotation);\n    keyframe.bodyCurve = mixProperty(bodyCurve);\n\n    keyframe.head.rotation = mixProperty(head.rotation);\n    keyframe.head.eyesDirection = mixProperty(head.eyesDirection);\n    keyframe.head.eyesOpen = mixProperty(head.eyesOpen);\n    keyframe.head.earsRotation = mixProperty(head.earsRotation);\n    keyframe.head.eyelidsOffset = mixProperty(head.eyelidsOffset);\n    keyframe.head.cheeksHeight = mixProperty(head.cheeksHeight);\n    keyframe.head.cheeksBlush = mixProperty(head.cheeksBlush);\n    keyframe.head.mouthHeight = mixProperty(head.mouthHeight);\n    keyframe.head.mouthOpen = mixProperty(head.mouthOpen);\n\n    keyframe.rightArm.shoulderRotation = mixProperty(rightArm.shoulderRotation);\n    keyframe.rightArm.armRotation = mixProperty(rightArm.armRotation);\n    keyframe.rightArm.elbowRotation = mixProperty(rightArm.elbowRotation);\n    keyframe.rightArm.wristRotation = mixProperty(rightArm.wristRotation);\n    keyframe.rightArm.fingersSpread = mixProperty(rightArm.fingersSpread);\n    keyframe.rightArm.fingersFold = mixProperty(rightArm.fingersFold);\n\n    keyframe.leftArm.shoulderRotation = mixProperty(leftArm.shoulderRotation);\n    keyframe.leftArm.armRotation = mixProperty(leftArm.armRotation);\n    keyframe.leftArm.elbowRotation = mixProperty(leftArm.elbowRotation);\n    keyframe.leftArm.wristRotation = mixProperty(leftArm.wristRotation);\n    keyframe.leftArm.fingersSpread = mixProperty(leftArm.fingersSpread);\n    keyframe.leftArm.fingersFold = mixProperty(leftArm.fingersFold);\n\n    keyframe.rightLeg.baseRotation = mixProperty(rightLeg.baseRotation);\n    keyframe.rightLeg.rotation = mixProperty(rightLeg.rotation);\n    keyframe.rightLeg.kneeRotation = mixProperty(rightLeg.kneeRotation);\n    keyframe.rightLeg.footRotation = mixProperty(rightLeg.footRotation);\n    keyframe.rightLeg.toesAngle = mixProperty(rightLeg.toesAngle);\n\n    keyframe.leftLeg.baseRotation = mixProperty(leftLeg.baseRotation);\n    keyframe.leftLeg.rotation = mixProperty(leftLeg.rotation);\n    keyframe.leftLeg.kneeRotation = mixProperty(leftLeg.kneeRotation);\n    keyframe.leftLeg.footRotation = mixProperty(leftLeg.footRotation);\n    keyframe.leftLeg.toesAngle = mixProperty(leftLeg.toesAngle);\n\n    keyframe.tail.baseRotation = mixProperty(tail.baseRotation);\n    keyframe.tail.rotation = mixProperty(tail.rotation);\n    keyframe.tail.curve = mixProperty(tail.curve);\n\n    return keyframe;\n}\n\nKeyframe mirrorKeyframe(Keyframe keyframe)\n{\n    #define mirror_vec3(a) a = vec3(a.x, -a.yz)\n    #define switch_vec3(a, b) c = a; a = b; b = c\n    #define switch_float(a, b) d = a; a = b; b = d\n    vec3 c;\n    float d;\n\n    mirror_vec3(keyframe.rotation);\n    mirror_vec3(keyframe.bodyCurve);\n    mirror_vec3(keyframe.head.rotation);\n    mirror_vec3(keyframe.tail.baseRotation);\n    mirror_vec3(keyframe.tail.rotation);\n    switch_vec3(keyframe.rightArm.shoulderRotation, keyframe.leftArm.shoulderRotation);\n    switch_vec3(keyframe.rightArm.armRotation, keyframe.leftArm.armRotation);\n    switch_vec3(keyframe.rightArm.elbowRotation, keyframe.leftArm.elbowRotation);\n    switch_vec3(keyframe.rightArm.wristRotation, keyframe.leftArm.wristRotation);\n    switch_float(keyframe.rightArm.fingersSpread, keyframe.leftArm.fingersSpread);\n    switch_float(keyframe.rightArm.fingersFold, keyframe.leftArm.fingersFold);\n    switch_vec3(keyframe.rightLeg.baseRotation, keyframe.leftLeg.baseRotation);\n    switch_vec3(keyframe.rightLeg.rotation, keyframe.leftLeg.rotation);\n    switch_vec3(keyframe.rightLeg.kneeRotation, keyframe.leftLeg.kneeRotation);\n    switch_vec3(keyframe.rightLeg.footRotation, keyframe.leftLeg.footRotation);\n    switch_float(keyframe.rightLeg.toesAngle, keyframe.leftLeg.toesAngle);\n\n    return keyframe;\n}\n\nvec4 sdEye(vec3 pos, float side)\n{\n    float bounds = sdBoxApprox(pos, vec3(0.05));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec4(bounds, 0.0, 0.0, 0.0);\n    }\n\n    const float s1 = 0.038; // eyeball size\n    const float s2 = s1 * 0.45; // pupil size\n    const float s3 = s1 + 0.002; // eye lids size\n    const float y1 = 0.6 * s3; // eye lids opening\n\n    vec3 pos1 = pos;\n\n    float d1 = sdSphere(pos1, s3); // eyelids\n\n    vec3 pos2 = pos1;\n    pos2.y -= y1; // opening start\n    pos2.yz *= rotation(pose.head.eyelidsOffset);\n\n    vec3 pos3 = pos2;\n    pos3.yz *= rotation(PI05 - pose.head.eyesOpen * (PI05 + pose.head.eyelidsOffset));\n    float d2 = smax(d1, pos3.y, pose.head.eyesOpen * 0.02); // upper eyelid\n\n    pos3 = pos2;\n    pos3.yz *= rotation(-PI05 + pose.head.eyesOpen * (PI05 - pose.head.eyelidsOffset));\n    float d3 = smax(d1, pos3.y, pose.head.eyesOpen * 0.02); // lower eyelid\n\n    d1 = min(d2, d3);\n\n    float edge = 0.5 * (sign(pos2.z) + 3.0);\n    vec4 dm1 = vec4(d1, MATERIAL_SKIN, edge, 0.03);\n\n    pos2 = pos1;\n    d1 = sdSphere(pos2, s1); // eyeball\n\n    pos2.xy *= rotation(0.1 - side * pose.head.eyesDirection.x);\n    pos2.yz *= rotation(pose.head.eyesDirection.y);\n\n    pos2.y -= s1;\n    d2 = sdSphere(pos2, s2); // pupil\n\n    vec4 dm2 = vec4(d1, d2 > 0.0 ? MATERIAL_EYE : MATERIAL_PUPIL, 0.0, 0.0);\n    dm1 = smin(dm1, dm2);\n\n    return dm1;\n}\n\nvec4 sdEar(vec3 pos)\n{\n    float bounds = sdBoxApprox(pos, vec3(0.055), vec3(0.0, 1.0, -0.5));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec4(bounds, 0.0, 0.0, 0.0);\n    }\n\n    float d1, d2;\n\n    vec3 pos1 = pos;\n    pos1.y += 0.1;\n    d1 = sdEllipsoid(pos1, vec3(0.05, 0.2, 0.06));\n\n    pos1.y -= 0.11;\n    pos1.z += 0.18;\n    d2 = sdSphere(pos1, 0.2);\n    d1 = smax(d1, d2, 0.02);\n\n    pos1 = pos;\n    pos1.z -= 0.02;\n    pos1.y -= 0.04;\n    d2 = sdEllipsoid(pos1, vec3(0.02, 0.06, 0.02));\n    d1 = smax(d1, -d2, 0.02);\n\n    d1 = smax(d1, -pos.y - 0.05, 0.1);\n\n    float hue = d2 < 0.001 ? 1.0 : 0.0;\n    float edge = d2 < 0.001 ? 2.0 : 1.0;\n    float merge = 0.005 + 0.01 * smoothstep(-0.03, 0.03, d2);\n\n    return vec4(d1, MATERIAL_SKIN, edge + 0.99 * hue, merge);\n}\n\nvec4 sdHead(vec3 pos)\n{\n    const vec4 eyesRotation = vec4(0.128, 0.093, 0.145, 0.977);\n    const float blushSize = 0.02;\n    const float blushMargin = 0.03;\n\n    float bounds = sdBoxApprox(pos, vec3(0.8, 0.25, 0.3), vec3(0.0, -0.2, 0.5));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec4(bounds, 0.0, 0.0, 0.0);\n    }\n\n    vec3 pos1, pos2;\n    float d1, d2, d3;\n\n    pos.z -= 0.05;\n    pos.yz *= rotation_60;\n\n    pos1 = pos;\n    pos1.xz *= rotation_90;\n    pos1.xy *= rotation_n90;\n    d1 = sdArc(pos1, 0.18, -0.4, 0.14, -0.11); // head arc\n    pos1.y -= 0.02;\n    d2 = sdSphere(pos1, 0.144);\n    d1 = smin(d1, d2, 0.01); // smooth arc\n\n    pos1 = pos;\n    float rcurve = 0.3;\n    pos1 -= vec3(0.0, 0.22 - rcurve, 0.07);\n    d2 = sdCircle(pos1.xy, rcurve); // flatten head arc top\n    d2 = length(vec2(d2, pos1.z)) - 0.055;\n\n    d1 = smax(d1, -d2, 0.22);\n    //d1 = min(d1, d2);\n    float merge = smoothstep(0.15, -0.05, pos1.z) * 0.15 + 0.0005;\n\n    // eyes\n    vec3 eyesPos = pos;\n    float eyeSide = sign(eyesPos.x);\n    eyesPos.x = abs(eyesPos.x);\n    eyesPos -= vec3(0.053, 0.085, 0.081);\n    eyesPos = rotate(eyesPos, eyesRotation);\n\n    pos1 = eyesPos;\n    pos1 -= vec3(0.0, 0.02, -0.005);\n    d2 = sdSphere(pos1, 0.035); // eyes socket\n    d1 = smax(d1, -d2, 0.04);\n\n    // eyes top outline group\n    pos1 = eyesPos;\n    pos1 -= vec3(0.004, 0.03, -0.015);\n    d2 = sdSphere(pos1, 0.025);\n\n    float edge = d2 < 0.0 ? 3.0 : 0.0; // eyes top outline\n\n    // eyebrows\n    pos1 = pos;\n    pos1.x = abs(pos1.x);\n    pos1.yz *= rotation(0.15 - pose.head.eyebrowsHeight * 0.35);\n    pos1.xy *= rotation_n30;\n\n    pos2 = pos1;\n    pos2.z += 0.025;\n    d2 = sdCircle(pos2.xz, 0.025); // eyebrow size\n    d2 = max(d2, -pos2.y);\n\n    pos2 = pos1;\n    pos2.z -= 0.05;\n    pos2.x += 0.03; // eyebrow angle\n    d3 = sdCircle(pos2.xz, 0.08); // eyebrow curve\n    d3 = max(d3, -pos2.y);\n\n    edge = d2 > 0.0 ? edge :\n           d3 > 0.0 ? 1.0 : 3.0;\n\n    vec4 dm1 = vec4(d1, MATERIAL_SKIN, edge, merge);\n\n    pos1 = eyesPos;\n    vec4 dm2 = sdEye(pos1, eyeSide);\n    dm1 = smin(dm1, dm2);\n\n    pos1 = pos;\n    pos1.yz *= rotation_n45;\n    pos1.x = abs(pos1.x);\n    pos1.xy *= rotation_n15;\n    pos1 -= vec3(0.04, 0.09, -0.01);\n    pos1.xz *= rotation_n15;\n    pos1 = rotate(pos1, pose.head.earsRotation);\n    pos1.y -= 0.02;\n    dm2 = sdEar(pos1);\n    dm1 = smin(dm1, dm2);\n\n    // mouth\n    pos1 = pos;\n    pos1 += vec3(0.0, 0.06 + pose.head.mouthHeight, -0.25 + pose.head.mouthHeight);\n    d1 = sdEllipsoid(pos1, vec3(0.03, 0.02, 0.015) * clamp(pose.head.mouthOpen, 0.001, 4.0));\n    dm1.xyz = maxx(dm1.xyz, vec3(-d1, MATERIAL_MOUTH, 0.0));\n\n    // cheeks\n    float f = clamp(pose.head.cheeksHeight, 0.0, 1.0);\n    pos1 = pos;\n    pos1.x = abs(pos1.x);\n    pos1 -= vec3(0.055, 0.06, 0.15);\n    d1 = sdSphere(pos1, 0.07 + 0.015 * clamp(f, 0.0, 1.0));\n    dm2 = vec4(d1, MATERIAL_SKIN, 0.0, 0.01);\n    dm1 = smin(dm1, dm2);\n\n    // cheeks blush\n    pos1 = pos;\n    pos1.x = abs(pos1.x);\n    pos1 -= vec3(0.1, 0.12, 0.12);\n    d1 = sdSphere(pos1, blushSize);\n\n    float hue = clamp(pose.head.cheeksBlush * (blushMargin - d1) / blushMargin, 0.0, 1.0);\n    hue = abs(dm1.y - MATERIAL_SKIN) < 0.001 ? hue : 0.0;\n    dm1.z += 0.99 * hue;\n\n    return dm1;\n}\n\n\nvec4 sdLeg(vec3 pos, vec4 legRotation, vec4 kneeRotation, vec4 footRotation, float toesAngle)\n{\n    const float l1 = 0.1; // thigh length\n    const float l2 = 0.07; // shin length\n    const float l3 = 0.075; // foot length\n\n    const float t1 = 0.085; // thigh thickness\n    const float t2 = 0.065; // shin thickness\n    const float h3 = 0.04; // foot height\n    const float w3 = 0.065; // foot width\n\n    vec3 pos1 = pos;\n    pos1.y += l1 + 0.04;\n    pos1 = rotate(pos1, legRotation);\n\n    float bounds = sdBoxApprox(pos1, vec3(0.1, 0.2, 0.1), vec3(0.0, -0.6, -0.2));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec4(bounds, 0.0, 0.0, 0.0);\n    }\n\n    float d1 = sdEllipsoid(pos1, vec3(t1, l1, t1)); // thigh\n    float merge = smoothstep(-0.6, 0.1, pos1.y / l1);\n\n    vec4 dm1 = vec4(d1, MATERIAL_SKIN, 0.0, 0.2 * merge);\n    pos1.y += l1 - t2 * 0.8;\n    pos1 = rotate(pos1, kneeRotation);\n    pos1.y += l2 - t2 * 0.5;\n\n    d1 = sdEllipsoid(pos1, vec3(t2, l2, t2)); // shin\n    merge = smoothstep(-0.8, 0.0, pos1.y / l2);\n    vec4 dm2 = vec4(d1, MATERIAL_SKIN, 0.0, 0.1 * merge);\n\n    pos1.y += l2 - t2 * 0.8;\n    pos1 = rotate(pos1, footRotation);\n    pos1.y += t2 * 0.8;\n    pos1.z -= l3 * 0.4;\n\n    pos1.yz = bendSpace(pos1.yz, vec2(-0.4 * h3, -0.2 * l3), 1.0, 0.5, toesAngle);\n\n    merge = smoothstep(0.5, -0.1, pos1.z / l3);\n    float d2 = sdEllipsoid(pos1, vec3(w3, h3, l3)); // foot\n\n    pos1.y += 0.4;\n    float d3 = sdSphere(pos1, 0.385); // flatten foot curve\n    d2 = smax(d2, -d3, 0.01);\n\n    vec4 dm3 = vec4(d2, MATERIAL_SKIN, 0.0, 0.04 * merge);\n    dm2 = smin(dm2, dm3, dm3.w);\n\n    dm1 = smin(dm1, dm2, dm2.w);\n    return dm1;\n}\n\nvec4 sdFinger(vec3 pos, mat2 rotation)\n{\n    float bounds = sdBoxApprox(pos, vec3(0.02, 0.01, 0.01), vec3x(-0.1));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec4(bounds, 0.0, 0.0, 0.0);\n    }\n\n    vec3 pos1 = pos;\n\n    float d = sdEllipsoid(pos1, vec3(0.015, 0.009, 0.009)); // finger\n    float merge = smoothstep(-0.015, 0.0, pos1.x);\n    vec4 dm1 = vec4(d, MATERIAL_SKIN, 0.0, 0.005 * merge);\n\n    pos1.x += 0.011;\n    pos1.xz *= rotation;\n    pos1.x += 0.001;\n    d = sdEllipsoid(pos1, vec3(0.01, 0.007, 0.007)); // finger tip\n    merge = smoothstep(-0.01, 0.0, pos1.x);\n\n    vec4 dm2 = vec4(d, MATERIAL_SKIN, 0.0, 0.005 * merge);\n\n    dm1 = smin(dm1, dm2);\n\n    return dm1;\n}\n\nvec4 sdFingers(vec3 pos, float spread, float fold)\n{\n    const float x = 0.006;\n    const float r1 = 0.035 - x;\n    const float r2 = 0.005 + x;\n\n    float bounds = sdBoxApprox(pos, vec3(0.05), vec3x(-0.5));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec4(bounds, 0.0, 0.0, 0.0);\n    }\n\n    float spreadAngle = 0.2 * clamp(spread, -1.0, 1.0);\n    float foldAngle = -PI05 * clamp(fold, -1.0, 1.0);\n\n    vec3 pos1, pos2;\n    vec4 dm1, dm2;\n\n    mat2 m1 = rotation(-0.4 - spreadAngle);\n    mat2 m2 = rotation(spreadAngle * 0.5);\n    mat2 m3 = rotation(foldAngle);\n    mat2 m4 = rotation(foldAngle * 0.5);\n\n    pos1 = pos;\n    pos1 += vec3(0.005, -0.006, 0.005);\n\n    float side = sign(pos1.y);\n    pos1.y = abs(pos1.y);\n\n    // middle\n    pos2 = pos1;\n    pos2.x += r1;\n    pos2.xz *= m3;\n    pos2.x += r2;\n    dm1 = sdFinger(pos2, m4);\n\n    // index and ring\n    pos1.xy *= m1;\n    pos2 = pos1;\n    pos2.x += r1;\n    pos2.xy *= rotation_7_5;\n    pos2.xz *= m3;\n    pos2.x += r2;\n    pos2.xy *= m2;\n    dm2 = sdFinger(pos2, m4);\n    dm1 = minx(dm1, dm2);\n\n    // thumb and pinky\n    pos1.xy *= m1;\n    pos1.xy = side > 0.0 ? pos1.xy * m1 : pos1.xy; // thumb gap\n    pos1.x -= 0.004 * side; // thumb length\n    pos2 = pos1;\n    pos2.x += r1;\n    pos2.xy *= rotation_15;\n    pos2.xz *= m3;\n    pos2.x += r2;\n    pos2.xy *= m2;\n    dm2 = sdFinger(pos2, m4);\n    dm1 = minx(dm1, dm2);\n\n    return dm1;\n\n}\n\nvec4 sdArm(vec3 pos, vec4 armRotation, vec4 elbowRotation, vec4 wristRotation, float fingersSpread, float fingersFold)\n{\n    const float l1 = 0.11; // upper arm length\n    const float l2 = 0.07; // forearm length\n\n    const float t1 = 0.07; // upper arm thickness\n    const float t2 = 0.05; // forearm thickness\n\n    const vec3 s3 = vec3(0.035, 0.04, 0.025);\n\n    vec3 pos1 = pos;\n    pos1 = rotate(pos1, armRotation);\n\n    float bounds = sdBoxApprox(pos, vec3(0.2), vec3x(-0.5));\n    if (bounds > BOUNDS_MARGIN)\n    {\n       return vec4(bounds, 0.0, 0.0, 0.0);\n    }\n\n    pos1.x += l1 - t1;\n    float d1 = sdEllipsoid(pos1, vec3(l1, t1, t1)); // upper arm\n    float merge = smoothstep(-0.3 * l1, 0.5 * l1, pos1.x);\n    vec4 dm1 = vec4(d1, MATERIAL_SKIN, 0.0, 0.05 * merge);\n\n    pos1.x += l1 - t2;\n    pos1 = rotate(pos1, elbowRotation);\n    pos1.x += l2 - 0.5 * t2;\n\n    d1 = sdEllipsoid(pos1, vec3(l2, t2, t2)); // forearm\n    merge = smoothstep(-0.5 * l2, 0.5 * l2, pos1.x);\n    vec4 dm2 = vec4(d1, MATERIAL_SKIN, 0.0, 0.05 * merge);\n    dm1 = smin(dm1, dm2);\n\n    pos1.x += l2 - 0.5 * t2;\n    pos1 = rotate(pos1, wristRotation);\n    pos1.x += t2 - 0.8 * s3.z;\n    pos1.z += 0.5 * s3.z;\n\n    d1 = sdEllipsoid(pos1, s3); // palm\n    merge = smoothstep(-s3.x, 0.5 * s3.x, pos1.x);\n    dm2 = vec4(d1, MATERIAL_SKIN, 0.0, 0.05 * merge);\n    dm1 = smin(dm1, dm2);\n\n    pos1.x -= 0.01;\n    dm2 = sdFingers(pos1, fingersSpread, fingersFold);\n    dm1 = smin(dm1, dm2);\n\n    return dm1;\n}\n\nvec4 sdTail(vec3 pos, float curve)\n{\n    // length\n    const float l1 = 0.4;\n    const float l2 = 0.1;\n\n    // thickness\n    const float t1 = 0.02;\n    const float t2 = 0.04;\n\n    float bounds = sdBoxApprox(pos, vec3(0.1, 0.4, 0.3), vec3z(-1.0));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec4(bounds, 0.0, 0.0, 0.0);\n    }\n\n    vec3 pos1 = pos;\n\n    pos1 = vec3(pos1.y, -pos1.z, pos1.x);\n    float d1 = sdArc(pos1, l1, curve, t1, 0.03);\n\n    float merge = 0.05 * smoothstep(l1 * 0.5, 0.0, length(pos));\n    vec4 dm1 = vec4(d1, MATERIAL_SKIN, 0.0, merge);\n\n    pos1.xy *= rotation(-curve);\n    pos1.y -= 1.0 * l1 * cos(curve * 0.5);\n    pos1.xy *= rotation(-curve);\n    d1 = sdArc(pos1, l2, 0.4 * curve, t2, 0.4);\n\n    vec4 dm2 = vec4(d1, MATERIAL_SKIN, 0.0, merge);\n    dm1 = smin(dm1, dm2, 0.02);\n\n    return dm1;\n}\n\nvec3 sdMoomin(vec3 pos)\n{\n    float d1, d2, d3;\n    vec4 d4, d5;\n    vec3 pos1, pos2;\n    vec3 d = vec3(MAX_DIST, 0.0, 0.0);\n\n    pos -= pose.offset;\n    pos = rotate(pos, pose.rotation);\n\n    float bounds = sdBoxApprox(pos, vec3(0.5, 0.6, 0.5), vec3(0.0, 0.9, -0.3));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    d = vec3(MAX_DIST, 0.0, 0.0);\n\n    // body\n    pos1 = pos;\n    pos1 = rotate(pos1, quaternionInverse(pose.bodyCurve));\n    pos1.y -= 0.05;\n    pos1 = rotate(pos1, pose.bodyCurve);\n    pos1.y -= 0.32;\n    d1 = sdSphere(pos1, 0.22); // belly\n\n    vec3 tailPos = pos1;\n    vec3 legsPos = pos1;\n    legsPos.y += 0.01;\n    legsPos.z += 0.03;\n\n    pos1.y -= 0.18;\n    pos1 = rotate(pos1, pose.bodyCurve);\n    pos1.y -= 0.1;\n\n    vec3 armsPos = pos1;\n    armsPos.y += 0.08;\n\n    d2 = sdEllipsoid(pos1, vec3(0.12, 0.25, 0.12)); // ribcage\n    d1 = smin(d1, d2, 0.3);\n\n    d = minx(d, vec3(d1, MATERIAL_SKIN, 0.0));\n\n    // head\n    pos1.y -= 0.11;\n    pos1 = rotate(pos1, pose.bodyCurve);\n    pos1 = rotate(pos1, pose.head.rotation);\n    pos1.y -= 0.1;\n    d = smin(d, sdHead(pos1));\n\n    // arms\n    pos1 = armsPos;\n    pos1 = rotate(pos1, pose.rightArm.shoulderRotation);\n    pos1.x += 0.15;\n    d4 = sdArm(pos1, pose.rightArm.armRotation, pose.rightArm.elbowRotation, pose.rightArm.wristRotation, pose.rightArm.fingersSpread, pose.rightArm.fingersFold);\n\n    pos1 = armsPos;\n    pos1.x = -pos1.x;\n    pos1 = rotate(pos1, pose.leftArm.shoulderRotation);\n    pos1.x += 0.15;\n    d5 = sdArm(pos1, pose.leftArm.armRotation, pose.leftArm.elbowRotation, pose.leftArm.wristRotation, pose.leftArm.fingersSpread, pose.leftArm.fingersFold);\n\n    d = smin(d, minx(d4, d5));\n\n    // legs\n    pos1 = legsPos;\n    pos1.x += 0.08;\n    pos1.z -= 0.06;\n    pos1 = rotate(pos1, pose.rightLeg.baseRotation);\n    pos1.z += 0.06;\n    d4 = sdLeg(pos1, pose.rightLeg.rotation, pose.rightLeg.kneeRotation, pose.rightLeg.footRotation, pose.rightLeg.toesAngle);\n\n    pos1 = legsPos;\n    pos1.x = -pos1.x;\n    pos1.x += 0.08;\n    pos1.z -= 0.06;\n    pos1 = rotate(pos1, pose.leftLeg.baseRotation);\n    pos1.z += 0.06;\n    d5 = sdLeg(pos1, pose.leftLeg.rotation, pose.leftLeg.kneeRotation, pose.leftLeg.footRotation, pose.leftLeg.toesAngle);\n\n    d = smin(d, minx(d4, d5));\n\n    pos1 = tailPos;\n    pos1 = rotate(pos1, pose.tail.baseRotation);\n    pos1.y += 0.08;\n    pos1.z += 0.1;\n    pos1.yz *= rotation_n60;\n    pos1 = rotate(pos1, pose.tail.rotation);\n    pos1.z += 0.05;\n    d4 = sdTail(pos1, pose.tail.curve);\n    d = smin(d, d4);\n\n    return d;\n}\n\n// --- ------ ---\n\nfloat getGroundHeight(vec3 pos)\n{\n    return 0.5 * (sin(0.15 * pos.x) + sin(0.25 * pos.z));\n}\n\nvec3 getWindForce(vec3 pos, float time)\n{\n    float phase = pos.x + pos.z; // phase direction\n    float an = 4.0; // force direction\n\n    phase += 0.2 * (sin(2.0 * pos.x + time) + sin(3.0 * pos.z + time)); // noise\n\n    phase = sin(1.5 * time + phase);\n    an += phase; // change direction\n\n    float stength = 0.1 + 2.0 * map11_01(phase);\n    stength *= 0.6 + 0.4 * sin(0.2 * pos.z + 0.5 * time); // pulse\n\n    return stength * vec3(cos(an), 0.0, sin(an));\n}\n\nvec3 sdRock(vec3 pos, float size, float h1, float h2)\n{\n    size *= 1.0 - 0.5 * h2;\n\n    float bounds = sdBoxApprox(pos, vec3(1.5 * size));\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    float phase = PI * h2;\n\n    vec3 pos1 = pos;\n    pos1.x += 0.02 * (sin(15.0 * pos.x + phase) + sin(10.0 * pos.z + phase));\n    pos1.y += 0.01 * (sin(13.0 * pos.x + phase) + sin(18.0 * pos.z + phase));\n    pos1.z += 0.02 * (sin(10.0 * pos.x + phase) + sin(15.0 * pos.z + phase));\n    pos1.y += 0.4 * size;\n\n    pos1 /= size;\n    float d = sdSphere(pos1, 1.0);\n    d *= size;\n\n    return vec3(d, MATERIAL_ROCK, 0.0);\n}\n\nvec3 sdRocks(vec3 pos)\n{\n    const vec2 gridSize = vec2(15.0);\n    const float size1 = 0.5;\n    const float size2 = 0.7;\n\n    vec3 pos1 = pos;\n    vec2 index = floor(pos1.xz / gridSize + 0.5);\n    pos1.xz -= index * gridSize;\n\n    float h1 = hash(index);\n    float h2 = hash(index + 1000.0);\n    float size = mix(size1, size2, fract(100.0 * (h1 + h2)));\n\n    pos1.xz -= (0.5 * gridSize - size) * vec2(map01_11(h1), map01_11(h2));\n\n    return sdRock(pos1, size, h1, h2);\n}\n\nvec3 sdFlower(vec3 pos, float hue, float scale, vec3 dir)\n{\n    const float size1 = 0.02; // petals\n    const float thickness1 = 0.002;\n    const float size2 = 0.03; // base\n    const float size3 = 0.02; // disk\n    const float size4 = 0.2; // stem\n    const float thickness4 = 0.004;\n\n    pos /= scale;\n\n    float bounds = sdBoxApprox(pos, vec3(0.07, 0.1, 0.07), vec3y1) * scale;\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    pos.zy *= rotation(atan(-dir.z, dir.y));\n    pos.xy *= rotation(atan(-dir.x, dir.y));\n\n    pos.y -= 0.8 * size4;\n\n    // petals\n    vec3 pos1 = pos;\n    pos1.xy *= rotation_n30;\n\n    float index = 0.0;\n    vec3 pos2 = pos1;\n    pos2.xz = radialMod(pos2.xz, 5.0, index);\n    pos2.x -= 1.5 * size1;\n    pos2.xy *= rotation_30;\n    float d = sdCircle(pos2.xz, size1);\n    d = max(0.0, d);\n    d = length(vec2(d, pos2.y));\n    d -= thickness1;\n    vec3 d1 = vec3(d, MATERIAL_FLOWER1, hue);\n\n    // base\n    pos2 = pos1;\n    pos2.y -= 0.4 * size2;\n    d = sdSphere(pos2, size2);\n    d = max(d, pos2.y + 0.68 * size2);\n    vec3 d2 = vec3(d, MATERIAL_GRASS, 0.8);\n    d1 = smin(d1, d2, 0.01);\n\n    // stem\n    pos2 = pos;\n    pos2.x -= 0.73 * size4;\n    pos2.y += 0.7 * size4;\n    d = sdCircle(pos2.xy, size4);\n    d = length(vec2(d, pos2.z));\n    d = max(d, pos2.x);\n    d = max(d, pos1.y + 0.1 * size4);\n    d = max(d, -pos2.y);\n    d -= thickness4;\n    d2 = vec3(d, MATERIAL_GRASS, 0.5);\n    d1 = smin(d1, d2, 0.01);\n\n    // disk\n    pos2 = pos1;\n    pos2.y += size3;\n    d = sdSphere(pos2, size3);\n    d = max(d, -pos2.y + 0.5 * size3);\n    d2 = vec3(d, MATERIAL_FLOWER2, 0.0);\n    d1 = minx(d1, d2);\n\n    d1.x *= scale;\n    return d1;\n}\n\nvec3 sdFlowers(vec3 pos, float time)\n{\n    const vec2 gridSize = vec2(1.5);\n\n    float bounds = pos.y - 0.4;\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    float viewDist = length(state.origin - pos);\n    if (viewDist > 30.0)\n    {\n        return vec3(MAX_DIST, 0.0, 0.0);\n    }\n\n    vec3 pos1 = pos;\n\n    float h = 0.35 + 0.05 * (sin(pos.x) + sin(pos.z)); // height\n\n    vec3 dir = vec3y1;\n    dir += 0.3 * getWindForce(pos, time + 0.2);\n    dir.y = max(0.0, dir.y);\n    dir = normalize(dir);\n    dir *= h / dir.y;\n\n    float y = clamp(pos1.y / dir.y, 0.0, 1.0);\n\n    vec2 index = floor((pos1.xz - y * dir.xz) / gridSize + 0.5);\n\n    float rocksDist = sdRocks(vec3(index * gridSize, 0.0).xzy).x;\n    if (rocksDist < 0.2)\n    {\n        return vec3(MAX_DIST, 0.0, 0.0);\n    }\n\n    vec3 pos2 = pos1;\n    pos2.xz -= index * gridSize;\n    pos2.xz -= 0.1 * y * dir.xz; // skew\n\n    float h1 = hash(index);\n    float h2 = hash(index + 1000.0);\n    float h3 = fract(h1 + h2);\n\n    pos2.xz -= (0.4 * gridSize - 0.1) * map01_11(vec2(h1, h2)); // jitter\n\n    return sdFlower(pos2, h1, h / 0.25, dir);\n}\n\nfloat getGrassShade(vec2 pos)\n{\n    pos.x += 4.0 * fbm(pos);\n    float x = 0.99 * fbm(pos * vec2(1.0, 0.8) * 0.3);\n    x = x * x;\n    x = x * (2.0 - x);\n    return x;\n}\n\nvec3 sdGrass(vec3 pos, float time)\n{\n    const vec2 gridSize1 = vec2(0.05);\n    const vec2 gridSize2 = vec2(0.15);\n    const float h1 = 0.08;\n    const float h2 = 0.15;\n    const float h3 = 0.03;\n    const float r1 = 0.005;\n    const float r2 = 0.015;\n    const float rocksMargin = 0.0;\n    const vec2[] offsets = vec2[](vec2(0.0), vec2(0.2, 0.8), vec2(0.7, 0.3));\n\n    float bounds = pos.y - h1 - 2.0 * h3;\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    float viewDist = length(state.origin - pos);\n\n    float d1 = pos.y;\n    vec2 rootPos = pos.xz;\n\n    if (viewDist > 20.0)\n    {\n        d1 = pos.y - 0.5 * (h1 + h2);\n    }\n    else\n    {\n        float rocksDist = sdRocks(vec3(pos.xz, 0.0).xzy).x - rocksMargin;\n        float rocksMask1 = smoothstep(0.0, 0.3, rocksDist); // skew\n        float rocksMask2 = smoothstep(-0.1, 0.2, rocksDist); // height\n\n        for (int i = 0; i < 3; i++)\n        {\n            float j = float(i);\n\n            vec3 pos1 = pos;\n            vec2 gridSize = mix(gridSize1, gridSize2, j / 2.0);\n            pos1.xz += offsets[i] * gridSize;\n\n            float h = mix(h1, h2, map11_01(0.5 * (sin(7.1 * pos1.x + 1.8 * j) + sin(9.3 * pos1.z + 1.5 * j))));\n            h += j * h3;\n            h *= rocksMask2;\n\n            vec3 dir = vec3y1;\n            dir += getWindForce(vec3(pos.xz + offsets[i] * 0.3, pos.y).xzy, time) * rocksMask1;\n            dir.y = max(0.0, dir.y);\n            dir = normalize(dir);\n            dir *= h;\n\n            float y = clamp(pos1.y / dir.y, 0.0, 1.0);\n\n            pos1.xz -= 0.2 * dir.xz * pow(y, 2.0); // curve\n\n            vec2 gridOffset = y * dir.xz; // offset grid index based on the direction relative to the queried position height\n            vec2 index = floor((pos1.xz - gridOffset) / gridSize + 0.5);\n            vec3 pos2 = pos1;\n\n            float h1 = hash(index);\n            float h2 = hash(index + 1000.0);\n\n            pos2.xz -= index * gridSize;\n            pos2.xz += 0.3 * gridSize * map01_11(vec2(h1, h2)); // jitter\n\n            float r = mix(r2, r1, y);\n            float d2 = sdCapsule(pos2, vec3(0.0), dir, r);\n\n            rootPos = d2 < d1 ? index * gridSize : rootPos;\n            d1 = min(d1, d2);\n        }\n    }\n\n    vec3 d = vec3(d1, MATERIAL_GRASS, 0.0);\n    d.yz += fract(rootPos / 1000.0 + 0.5); // serialize root position\n    return d;\n}\n\nvec3 sdGround(vec3 pos)\n{\n    vec3 d = vec3(pos.y, MATERIAL_GRASS, 0.0);\n    d.yz += fract(pos.xz / 1000.0 + 0.5);\n    return d;\n}\n\nvec3 sdMountains(vec3 pos)\n{\n    const float scale = 200.0;\n\n    const float f = 2.0;\n    const float r1 = 2.0;\n    const float h1 = 1.6;\n    const float thickness1 = 0.8;\n    const float count1  = 4.0;\n    const float offset1 = -1.4;\n\n    const float r2 = 3.0;\n    const float h2 = 2.0;\n    const float thickness2 = 1.0;\n    const float variation2 = 0.3;\n    const float count2  = 3.0;\n    const float offset2 = 3.6;\n\n    const float bumps = 0.2;\n    const float details = 2.5;\n    const float seed = 0.0;\n\n    pos /= scale;\n\n    vec3 pos1 = pos;\n\n    float r = length(pos1.xz);\n\n    float bounds = (abs(r - 3.0) - 2.0) * scale;\n    if (bounds > BOUNDS_MARGIN)\n    {\n        return vec3(bounds, 0.0, 0.0);\n    }\n\n    pos1.y -= bumps * fbm(pos1 * details + seed) - 0.1;\n    pos1.y += thickness1;\n\n    float an = atan(pos1.z, pos1.x);\n\n    float d1 = sdCircle(pos1.xz, r1);\n    float h = pow(map11_01(sin(count1 * an + offset1)), 0.8) * h1;\n    d1 = length(vec2(d1, stretchAxis(pos1.y, h)));\n    d1 -= thickness1;\n\n    float mask = smoothstep(0.0, 1.0, abs(an + PI05)); // front valley mask\n\n    float d2 = sdCircle(pos1.xz, r2);\n    h = pow(map11_01(sin(count2 * an + PI + offset2)) + 0.05, 0.3) * h2;\n    h *= 1.0 + variation2 * sin((count2 - 1.0) * an); // variation\n    h *= mask;\n    d2 = length(vec2(d2, stretchAxis(pos1.y, h)));\n    d2 -= thickness2 * mask;\n\n    d1 = min(d1, d2);\n\n    d1 = smin(d1, pos.y + 0.1, 0.8);\n    d1 = max(d1, -pos.y);\n    d1 = max(d1, r - r2 - 2.0 * thickness2);\n\n    return vec3(d1 * scale, MATERIAL_MOUNTAIN, 0.0);\n}\n\nvec3 sdBackground(vec3 pos)\n{\n    vec3 d1 = vec3(MAX_DIST, MATERIAL_SKY, 0.0);\n    vec3 d2, pos1;\n\n    pos1 = pos;\n    pos1.xz -= state.origin.xz;\n    d2 = sdMountains(pos1);\n    d1 = minx(d1, d2);\n\n    pos1 = pos;\n    pos1.y -= getGroundHeight(pos1);\n\n    d2 = sdGround(pos1);\n    d1 = minx(d1, d2);\n\n    return d1;\n}\n\nfloat mapCollision(vec3 pos, float time)\n{\n    return MAX_DIST;\n}\n\nvec3 map(vec3 pos, float time)\n{\n    vec3 pos1 = pos;\n    pos1.y -= getGroundHeight(vec3(pose.offset.xz, 0.0).xzy);\n    vec3 d1 = sdMoomin(pos1);\n\n    pos1 = pos;\n    pos1.y -= getGroundHeight(pos1);\n\n    if (state.theme < 1.0)\n    {\n        return d1;\n    }\n\n    vec3 d2;\n\n    d2 = sdGround(pos1);\n    d1 = minx(d1, d2);\n\n    d2 = sdRocks(pos1);\n    d1 = minx(d1, d2);\n\n    d2 = sdGrass(pos1, time);\n    d1 = minx(d1, d2);\n\n    d2 = sdFlowers(pos1, time);\n    d1 = minx(d1, d2);\n\n    return d1;\n}\n\nvec3 mapReflection(vec3 pos, float time)\n{\n    return vec3(MAX_DIST, 0.0, 0.0);\n}\n\nvec2 mapTransparent(vec3 pos, float time)\n{\n    return vec2(MAX_DIST, 0.0);\n}\n\nvec3 getNormalTransparent(vec3 pos, float time)\n{\n    vec3 n = vec3(0.0);\n\n    for (int i = 0; i < 4; i++)\n    {\n        vec3 d = 2.0 * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.0;\n        vec2 dm = mapTransparent(pos + 0.05 * d, time);\n\n        n += dm.y > 0.0 ? d * dm.x : vec3(0.0);\n    }\n\n    return normalize(n);\n}\n\nvec3 castRay(vec3 ro, vec3 rd, float time, int maxSteps) // ray origin, ray direction\n{\n    float d = 0.0; // distance from ray origin\n    vec2 m = vec2(0.0); // material\n\n    for (int i = 0; i < maxSteps; i++)\n    {\n        vec3 pos = ro + rd * d; // current position\n\n        vec3 d1 = map(pos, time); // distance from current position to the scene\n        d += d1.x;\n        m = d1.yz;\n\n        marchSteps++;\n\n        if (d > MAX_DIST || abs(d1.x / (d + 1.0)) < SURF_DIST)\n        {\n            break;\n        }\n    }\n\n    if (d > MAX_DIST || m.x < MATERIAL_EMPTY + 1.0)\n    {\n        m = vec2(MATERIAL_SKY, 0.0);\n        d = MAX_DIST;\n    }\n\n    return vec3(d, m);\n}\n\nvec3 castRayBackground(vec3 ro, vec3 rd, float time, int maxSteps, float maxDistance) // ray origin, ray direction\n{\n    float d = 0.0; // distance from ray origin\n    vec2 m = vec2(0.0); // material\n\n    int i;\n    for (i = 0; i < maxSteps; i++)\n    {\n        vec3 pos = ro + rd * d; // current position\n\n        vec3 dm = sdBackground(pos); // distance from current position to the scene\n        d += dm.x;\n        m = dm.yz;\n        marchSteps++;\n\n        if (d > maxDistance || abs(dm.x / (d + 1.0)) < SURF_DIST)\n        {\n            break;\n        }\n    }\n\n    if (d > maxDistance || m.x < 1.0)\n    {\n        m = vec2(MATERIAL_SKY, 0.0);\n        d = MAX_DIST;\n    }\n\n    return vec3(d, m);\n}\n\n\nvec3 castRayReflection(vec3 ro, vec3 rd, float time, int maxSteps) // ray origin, ray direction\n{\n    float d = 0.0; // distance from ray origin\n    vec2 m = vec2(0.0); // material\n\n    for (int i = 0; i < maxSteps; i++)\n    {\n        vec3 pos = ro + rd * d; // current position\n\n        vec3 d1 = mapReflection(pos, time); // distance from current position to the scene\n        d += d1.x;\n        m = d1.yz;\n\n        marchReflectionSteps++;\n\n        if (d > MAX_DIST || abs(d1.x / (d + 1.0)) < SURF_DIST)\n        {\n            break;\n        }\n    }\n\n    if (d > MAX_DIST || m.x < MATERIAL_EMPTY + 1.0)\n    {\n        m = vec2(MATERIAL_SKY, 0.0);\n        d = MAX_DIST;\n    }\n\n    return vec3(d, m);\n}\n\nvec2 castRayTransparent(vec3 ro, vec3 rd, float time, int maxSteps, float maxDistance)\n{\n    float d = 0.0;\n    float m = 0.0;\n\n    for (int i = 0; i < maxSteps; i++)\n    {\n        vec3 pos = ro + rd * d;\n\n        vec2 d1 = mapTransparent(pos, time);\n        d += d1.x;\n        m = d1.y;\n\n        marchTransparentSteps++;\n\n        if (d > maxDistance)\n        {\n            return vec2(MAX_DIST, 0.0);\n        }\n\n        if (abs(d1.x / (d + 1.0)) < SURF_DIST)\n        {\n            break;\n        }\n    }\n\n    return vec2(d, m);\n}\n\nfloat castRayCollision(vec3 ro, vec3 rd, float time, int maxSteps) // ray origin, ray direction\n{\n    float d = 0.0; // distance from ray origin\n\n    for (int i = 0; i < maxSteps; i++)\n    {\n        vec3 pos = ro + rd * d; // current position\n\n        float d1 = mapCollision(pos, time); // distance from current position to the scene\n        d += d1;\n\n        if (d > MAX_DIST || abs(d1 / (d + 1.0)) < SURF_DIST)\n        {\n            break;\n        }\n    }\n\n    return min(d, MAX_DIST);\n}\n\nfloat castShadow(vec3 ro, vec3 rd, float time)\n{\n    float result = 1.0;\n    float d = 0.01; // position\n\n    for (int i = 0; i < 50; i++)\n    {\n        vec3 pos = ro + d * rd;\n        vec3 d1 = map(pos, time);\n\n        marchShadowSteps++;\n\n        if (!materialCastsShadow(floor(d1.y)))\n        {\n            d1.x += 0.01; // skip object\n        }\n        else\n        {\n            result = min(result, max(0.0, 40.0 * d1.x / d)); // soft shadow\n        }\n\n        d += max(d1.x, 0.01);\n\n        if (abs(d1.x) < (d * 0.001) || d > MAX_DIST)\n        {\n            break;\n        }\n    }\n\n    return clamp(1.0 - result, 0.0, 1.0);\n}\n\nfloat castShadowTransparent(vec3 ro, vec3 rd, float time)\n{\n    float result = 1.0;\n    float d = 0.01; // position\n\n    for (int i = 0; i < 50; i++)\n    {\n        vec3 pos = ro + d * rd;\n        vec2 d1 = mapTransparent(pos, time);\n\n        marchShadowSteps++;\n\n        if (!materialCastsShadow(floor(d1.y)))\n        {\n            d1.x += 0.01; // skip object\n        }\n        else\n        {\n            result = min(result, max(0.0, 40.0 * d1.x / d)); // soft shadow\n        }\n\n        d += max(d1.x, 0.01);\n\n        if (abs(d1.x) < (d * 0.001) || d > MAX_DIST)\n        {\n            break;\n        }\n    }\n\n    return clamp(1.0 - result, 0.0, 1.0);\n}\n\nvoid getViewAxis(in vec3 origin, in vec3 target, out vec3 viewOrigin, out vec3 viewX, out vec3 viewY, out vec3 viewZ)\n{\n    origin.y = max(origin.y, getGroundHeight(origin) + MIN_CAMERA_HEIGHT);\n\n    viewOrigin = origin;\n    viewZ = normalize(target - origin);\n    viewX = normalize(cross(viewZ, vec3(0.0, 1.0, 0.0)));\n    viewY = cross(viewX, viewZ);\n}\n\nbool isKeyDown(int key)\n{\n    return keyboardTexture((vec2(0.5) + vec2(float(key), 0.0))).x > 0.5;\n}\n\nbool isKeyPressed(int key)\n{\n    return keyboardTexture((vec2(0.5) + vec2(float(key), 1.0))).x > 0.5;\n}\n\nvec2 scaleMouseCoordinate(vec2 coord)\n{\n    vec2 uv = map01_11(coord / iResolution.xy);\n    uv *= state.renderScale;\n    return map11_01(uv) * iResolution.xy;\n}\n\nvec3 getPosition(vec2 fragCoord)\n{\n    vec4 t = inputTexture(fragCoord);\n\n    vec2 uv = map01_11(fragCoord / iResolution.xy);\n    uv.x *= iResolution.x / iResolution.y;\n\n    float depth = deserializeDepth(getDepthComponent(t));\n    vec3 rd = normalize(uv.x * state.viewX + uv.y * state.viewY + FIELD_OF_VIEW * state.viewZ * state.renderScale);\n\n    vec3 pos = state.viewOrigin + depth * rd; // point in scene\n\n    return pos;\n}\n\nvoid updateState(vec2 fragCoord, float delta, float time)\n{\n    bool toggleRenderModeAction = isKeyPressed(KEY_F1);\n    bool toggleThemeAction = isKeyPressed(KEY_F2);\n    bool toggleNavigationModeAction = isKeyPressed(KEY_N);\n    bool resetViewAction = isKeyPressed(BUTTON_RIGHT) || isKeyPressed(KEY_R);\n    bool scaleUpRenderAction = isKeyPressed(KEY_KP_PLUS) || isKeyPressed(KEY_EQUALS);\n    bool scaleDownRenderAction = isKeyPressed(KEY_KP_MINUS) || isKeyPressed(KEY_MINUS);\n    bool zoomInAction = isKeyPressed(MOUSE_SCROLL_UP);\n    bool zoomOutAction = isKeyPressed(MOUSE_SCROLL_DOWN);\n    bool moveLeftAction = isKeyDown(KEY_A);\n    bool moveRightAction = isKeyDown(KEY_D);\n    bool moveForwardAction = isKeyDown(KEY_W);\n    bool moveBackwardAction = isKeyDown(KEY_S);\n    bool moveUpAction = isKeyDown(KEY_E);\n    bool moveDownAction = isKeyDown(KEY_C);\n    bool startDragAction = isKeyPressed(BUTTON_LEFT) || isKeyPressed(BUTTON_MIDDLE) || iMouse.w > 0.0;\n    bool dragAction = isKeyDown(BUTTON_LEFT) || isKeyDown(BUTTON_MIDDLE) || iMouse.z > 0.0;\n    bool dragZoomModifier = isKeyDown(KEY_CONTROL);\n    bool dragPanModifier = isKeyDown(KEY_SHIFT);\n    bool moveModifier = isKeyDown(KEY_SHIFT);\n\n    bool isMouseOverViewport = iMouse.x > 0.0 && iMouse.y > 0.0 && iMouse.x < iResolution.x && iMouse.y < iResolution.y;\n    bool moveAction = moveLeftAction || moveRightAction || moveForwardAction || moveBackwardAction;\n\n    if (iMouse.z > 0.0 || isKeyPressed(BUTTON_LEFT) || isKeyPressed(BUTTON_MIDDLE) || isKeyPressed(BUTTON_RIGHT))\n    {\n        state.focused = isMouseOverViewport;\n    }\n\n    state.focused = true; // override\n\n    float zoomOffset = 0.0;\n    vec3 panOffset = vec3(0.0);\n    vec2 swivelOffset = vec2(0.0);\n\n    bool isDragging = length(state.dragStartPosition) > 0.0;\n    bool isClicked = isDragging && !dragAction && state.navigationMode < 2.0 && (time - state.dragStartTime < CLICK_TIME && length(iMouse.xy - state.dragStartPosition) < 20.0);\n\n    if (isClicked)\n    {\n        state.clickCount = time - state.clickTime > 0.0 && time - state.clickTime < CLICK_TIME ? state.clickCount + 1.0 : 0.0;\n        state.clickTime = time;\n    }\n\n    if (state.focused)\n    {\n        if (toggleRenderModeAction)\n        {\n            state.nextRenderMode = mod(state.renderMode + 1.0, 8.0);\n            state.modeAnnotation = vec2(1.0, time);\n        }\n\n        if (toggleThemeAction)\n        {\n            state.nextTheme = mod(state.nextTheme + 1.0, 3.0);\n            state.modeAnnotation = vec2(2.0, time);\n        }\n\n        if (toggleNavigationModeAction)\n        {\n            state.navigationMode = mod(min(state.navigationMode, 1.0) + 1.0, 2.0);\n            state.modeAnnotation = vec2(3.0, time);\n        }\n\n        if (scaleUpRenderAction)\n        {\n            state.nextRenderScale = clamp(state.renderScale * 1.1, 0.01, 1.0);\n            state.modeAnnotation = vec2(4.0, time);\n        }\n\n        if (scaleDownRenderAction)\n        {\n            state.nextRenderScale = clamp(state.renderScale / 1.1, 0.01, 1.0);\n            state.modeAnnotation = vec2(4.0, time);\n        }\n\n        if (resetViewAction)\n        {\n            resetState();\n            state.focused = true;\n        }\n\n        float moveSpeed = moveModifier ? MOVE_SPEED2 : MOVE_SPEED1;\n\n        if (moveLeftAction)\n        {\n            panOffset.x = delta * moveSpeed;\n        }\n\n        if (moveRightAction)\n        {\n            panOffset.x = -delta * moveSpeed;\n        }\n\n        if (moveForwardAction)\n        {\n            panOffset.z = -delta * moveSpeed;\n        }\n\n        if (moveBackwardAction)\n        {\n            panOffset.z = delta * moveSpeed;\n        }\n\n        if (moveUpAction)\n        {\n            panOffset.y = -delta * moveSpeed * 0.5;\n        }\n\n        if (moveDownAction)\n        {\n            panOffset.y = delta * moveSpeed * 0.5;\n        }\n    }\n\n    if (isMouseOverViewport)\n    {\n        if (zoomInAction)\n        {\n            zoomOffset = -ZOOM_SCROLL_SPEED;\n        }\n\n        if (zoomOutAction)\n        {\n            zoomOffset = ZOOM_SCROLL_SPEED;\n        }\n\n        if (startDragAction)\n        {\n            state.dragStartTime = time;\n            state.dragStartPosition = iMouse.xy;\n            state.dragLastPosition = iMouse.xy;\n            isDragging = true;\n        }\n    }\n\n    if (dragAction || moveAction)\n    {\n        state.targetAnnotation = vec4(0.0);\n        state.modeAnnotation = vec2(0.0);\n    }\n\n    if (!dragAction)\n    {\n        state.dragStartPosition = vec2(0.0);\n        state.dragLastPosition = vec2(0.0);\n        isDragging = false;\n    }\n\n    if (isDragging && dragAction)\n    {\n        vec2 dragOffset = (iMouse.xy - state.dragLastPosition) / iResolution.y;\n        state.dragLastPosition = iMouse.xy;\n\n        if (dragZoomModifier && !moveAction)\n        {\n            zoomOffset = -ZOOM_DRAG_SPEED * sign(dragOffset.y) * 2.0 * length(dragOffset);\n        }\n        else if (dragPanModifier && !moveAction)\n        {\n            panOffset = vec3(dragOffset.xy, 0.0);\n        }\n        else // swivel\n        {\n            swivelOffset = SWIVEL_SPEED * dragOffset.xy;\n        }\n    }\n\n    vec3 viewDirection = state.target - state.origin;\n    float viewDistance = length(viewDirection);\n\n    vec2 viewRotation = vec2(atan(viewDirection.z, viewDirection.x), atan(viewDirection.y, length(viewDirection.xz)));\n\n    if (state.navigationMode > 1.0)\n    {\n        panOffset = vec3(0.0);\n    }\n\n    if (state.navigationMode < 1.0) // walk mode (0)\n    {\n        vec3 origin = state.origin;\n\n        vec3 d1 = vec3(castRayCollision(origin, vec3y(-1.0), time, MAX_STEPS), 100.0, 0.0);\n\n        float targetHeight = MOVE_CAMERA_HEIGHT + max(getGroundHeight(state.origin), origin.y - d1.x);\n\n        vec3 moveZ = normalize(vec3(state.viewZ.xz, 0.0).xzy);\n        vec3 moveY = vec3y(1.0);\n        vec3 moveX = cross(moveZ, moveY);\n        vec3 targetOffset = panOffset.x * moveX + panOffset.z * moveZ;\n\n        viewRotation += swivelOffset.xy * 0.5;\n        viewRotation.y = clamp(viewRotation.y, -PI05 + 0.001, PI05 - 0.001);\n\n        vec3 target = origin + viewDistance * vec3(cos(viewRotation.x) * cos(viewRotation.y), sin(viewRotation.y), sin(viewRotation.x) * cos(viewRotation.y));\n\n        origin -= targetOffset;\n        target -= targetOffset;\n\n        targetHeight = clamp(targetHeight, origin.y - MOVE_GRAVITY * delta, origin.y + MOVE_COLLISION * delta);\n        target.y += targetHeight - origin.y;\n        origin.y = targetHeight;\n\n        // teleport\n        if (isClicked && state.clickCount > 0.0) // double click\n        {\n            vec3 clickPosition = getPosition(scaleMouseCoordinate(iMouse.xy));\n            float d1 = length(clickPosition - state.origin);\n\n            if (d1 < 300.0) // exclude mountains and sky\n            {\n                vec3 pos = clickPosition; // point in scene\n                pos.y += MOVE_CAMERA_HEIGHT;\n                target += pos - origin;\n                origin = pos;\n            }\n        }\n\n        state.nextOrigin = origin;\n        state.nextTarget = target;\n    }\n    else // inspection mode (1)\n    {\n        // zoom\n        viewDistance *= pow(2.0, zoomOffset);\n\n        // swivel\n        viewRotation.xy += swivelOffset;\n        viewRotation.y = clamp(viewRotation.y, -PI05 + 0.001, PI05 - 0.001);\n\n        // pan\n        vec3 panX = state.viewX;\n        vec3 panZ = normalize(vec3(state.viewZ.xz, 0.0).xzy);\n        vec3 panY = cross(panX, panZ);\n        vec3 targetOffset = viewDistance * (panOffset.x * panX + panOffset.y * panY + panOffset.z * panZ);\n\n        state.nextOrigin = state.target - targetOffset - viewDistance * vec3(cos(viewRotation.x) * cos(viewRotation.y), sin(viewRotation.y), sin(viewRotation.x) * cos(viewRotation.y));\n        state.nextTarget = state.target - targetOffset;\n\n        // re-center target\n        state.nextTargetOffset *= max(0.0, 1.0 - 0.5 * length(swivelOffset) - length(panOffset) - abs(zoomOffset) - length(panOffset));\n\n        if (isClicked)\n        {\n            vec3 clickPosition = getPosition(scaleMouseCoordinate(iMouse.xy));\n            float d1 = length(clickPosition - state.origin);\n\n            #ifdef RENDER_TRANSPARENCY\n                float d2 = castRayTransparent(state.origin, state.viewZ, time, MAX_STEPS, MAX_DIST).x;\n                d1 = min(d1, d2);\n            #endif\n\n            if (d1 < 100.0) // limit distance\n            {\n                vec3 target = clickPosition; // point in scene\n\n                state.nextTargetOffset += state.target - target;\n                state.nextTarget = target;\n                state.targetAnnotation = vec4(iMouse.xy, time, 1.0);\n\n                if (state.clickCount > 0.0) // double click\n                {\n                    state.nextTargetOffset = vec3(0.0);\n                    state.nextOrigin = target - 2.0 * normalize(viewDirection);\n                }\n            }\n        }\n    }\n\n    if (length(state.nextOrigin - state.origin) < 0.0001)\n    {\n        state.nextOrigin = state.origin;\n    }\n\n    if (length(state.nextTarget - state.target) < 0.0001)\n    {\n        state.nextTarget = state.target;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    deserializeState(iChannel0, iResolution.xy);\n\n    if (!state.initialized)\n    {\n        resetState();\n        state.initialized = true;\n        state.nextRenderMode = 0.0;\n        state.nextRenderScale = 1.0;\n        state.nextOrigin = INITIAL_ORIGIN;\n        state.nextTarget = INITIAL_TARGET;\n        state.nextTargetOffset = vec3(0.0);\n        state.nextTheme = 1.0;\n        state.navigationMode = 2.0;\n    }\n\n    state.origin = state.nextOrigin;\n    state.target = state.nextTarget;\n    state.targetOffset = state.nextTargetOffset;\n    state.renderMode = state.nextRenderMode;\n    state.renderScale = state.nextRenderScale;\n    state.theme = state.nextTheme;\n\n    vec3 origin = state.origin;\n    vec3 target = state.target + state.targetOffset;\n\n    float time = iTime;\n\n    setPose(happyKeyframe);\n\n    // Empty pose:\n    //setPose(emptyKeyframe);\n\n    // Simple animation:\n    //Keyframe targetKeyframe = happyKeyframe;\n    //if (fract(time / 2.0) < 0.5)\n    //{\n    //    targetKeyframe = mirrorKeyframe(targetKeyframe);\n    //}\n    //setPose(mixKeyframe(emptyKeyframe, targetKeyframe, pow(abs(sin(time * PI)), 0.8)));\n\n    vec2 uv = map01_11(fragCoord / iResolution.xy);\n\n    if (fragCoord.x < STATE_SIZE && fragCoord.y < 1.0) // state\n    {\n        float delta = iTimeDelta;\n\n        vec3 origin, rdx, rdy, rdz;\n        getViewAxis(state.origin, state.target + state.targetOffset, origin, rdx, rdy, rdz);\n\n        state.viewX = rdx;\n        state.viewY = rdy;\n        state.viewZ = rdz;\n        state.viewOrigin = origin;\n\n        updateState(fragCoord, delta, time);\n\n        fragColor = serializeState(int(floor(fragCoord.x)));\n    }\n    else if (abs(uv.x) < state.renderScale && abs(uv.y) < state.renderScale)\n    {\n        // ray direction\n        vec3 origin, rdx, rdy, rdz;\n        getViewAxis(state.origin, state.target + state.targetOffset, origin, rdx, rdy, rdz);\n\n        uv.x *= iResolution.x / iResolution.y;\n        int steps = 0;\n        vec3 rd = normalize(uv.x * rdx + uv.y * rdy + FIELD_OF_VIEW * rdz * state.renderScale);\n        vec3 d1 = castRay(origin, rd, time, MAX_STEPS);\n\n        if (state.theme < 1.0)\n        {\n            fragColor = vec4(serializeDepth(d1.x), d1.y, d1.z, 0.0);\n            return;\n        }\n\n        vec3 d2 = castRayBackground(origin, rd, time, MAX_STEPS, d1.x);\n        d1 = minx(d1, d2);\n\n        vec3 pos = origin + d1.x * rd; // point in scene\n\n        float tint = 0.0;\n\n        #ifdef RENDER_TRANSPARENCY\n            vec2 d2 = castRayTransparent(origin, rd, time, MAX_STEPS, d1.x);\n            vec3 pos2 = origin + d2.x * rd; // transparent point in scene\n            vec3 n2 = getNormalTransparent(pos2, time); // transparent normal\n\n            // transparent tint\n            tint = d2.y;\n            // reflection\n            if (tint >= MATERIAL_REFLECTION_START)\n            {\n                vec3 r = reflect(rd, n2);\n                vec3 d3 = castRayReflection(pos2, r, time, MAX_STEPS);\n\n                // reflection tint\n                tint += d3.x > 10.0 ? 0.0 : 1.0;\n\n                // reflection outline group\n                d1.z += d3.x < 10.0 ? (2.0 + floor(d3.y) + floor(d3.z)) : 1.0;\n            }\n            else if (tint >= MATERIAL_TRANSPARENT_START)\n            {\n                vec3 r = reflect(rd, n2);\n                tint += dot(r, SUN_DIRECTION) > 0.8 ? 1.0 : 0.0;\n            }\n\n            d1.x = min(d1.x, d2.x);\n        #endif\n\n        float shadow = castShadow(pos, SUN_DIRECTION, time);\n\n        #ifdef RENDER_TRANSPARENCY_SHADOW\n            shadow += castRayTransparent(pos, SUN_DIRECTION, time, MAX_STEPS, MAX_DIST).y > 0.0 ? 0.5 : 0.0;\n        #endif\n\n        shadow = d1.y > MATERIAL_SKY ? shadow : 0.0;\n        shadow = clamp(shadow, 0.0, 0.99);\n\n        if (state.renderMode == 1.0) // override uv with ray march steps count\n        {\n            int steps = marchSteps;\n            steps += marchTransparentSteps;\n            steps += marchReflectionSteps;\n            steps += marchShadowSteps;\n\n            d1.z = floor(d1.z) + min(0.99, 0.5 * (float(steps) / float(MAX_STEPS)));\n        }\n        else if (d1.y >= MATERIAL_GRASS && d1.y < MATERIAL_GRASS + 1.0)\n        {\n            vec2 rootPos = fract(d1.yz) * 1000.0; // deserialize root position\n            float h = (pos.y - getGroundHeight(pos)) / 0.2;\n            d1.y = MATERIAL_GRASS + 0.99 * getGrassShade(rootPos);\n            d1.z = 0.9 * clamp(h, 0.0, 1.0);\n        }\n\n        fragColor = vec4(serializeDepth(d1.x), d1.y, d1.z, tint + shadow);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// MIT License\n\n// Buffer B - Outline\n// Inputs: Buffer A\n\nvec3 getPosition(vec2 coord, vec4 t)\n{\n    vec2 uv = map01_11(coord / iResolution.xy);\n    uv.x *= iResolution.x / iResolution.y;\n\n    float depth = deserializeDepth(getDepthComponent(t));\n    vec3 rd = normalize(uv.x * state.viewX + uv.y * state.viewY + FIELD_OF_VIEW * state.viewZ * state.renderScale);\n\n    vec3 pos = state.viewOrigin + depth * rd; // point in scene\n\n    return pos;\n}\n\nvec3 getPosition(vec2 coord)\n{\n    return getPosition(coord, inputTexture(coord));\n}\n\nvec3 getNormal(vec2 fragCoord)\n{\n    vec3 pos = getPosition(fragCoord);\n    vec3 nx0 = pos - getPosition(fragCoord - vec2(1.0, 0.0));\n    vec3 ny0 = pos - getPosition(fragCoord - vec2(0.0, 1.0));\n    vec3 nx1 = pos - getPosition(fragCoord + vec2(1.0, 0.0));\n    vec3 ny1 = pos - getPosition(fragCoord + vec2(0.0, 1.0));\n    vec3 nx = length(nx0) < length(nx1) ? -nx0 : nx1;\n    vec3 ny = length(ny0) < length(ny1) ? -ny0 : ny1;\n    return normalize(cross(nx, ny));\n}\n\nvec2 getDepthGradient(vec2 coord)\n{\n    vec2 g = vec2(0.0);\n\n    for (int i = 0; i < 9; i++)\n    {\n        vec2 offset = vec2(float(i % 3), float(i / 3)) + vec2(-1.0);\n        float d = deserializeDepth(getDepthComponent(inputTexture(coord + offset))) / MAX_DIST;\n        g.x += d * offset.x * (2.0 - abs(offset.y));\n        g.y += d * offset.y * (2.0 - abs(offset.x));\n    }\n\n    return g;\n}\n\nfloat getOutline(vec2 coord)\n{\n    const int innerEdgeCount = 4;\n\n    float f, fx1, fx2, fy1, fy2;\n\n    float material = getMaterialIndexComponent(inputTexture(coord));\n\n    // depth gradient\n    f =   length(getDepthGradient(coord));\n    fx1 = length(getDepthGradient(coord - vec2x1));\n    fx2 = length(getDepthGradient(coord + vec2x1));\n    fy1 = length(getDepthGradient(coord - vec2y1));\n    fy2 = length(getDepthGradient(coord + vec2y1));\n\n    // perimeter outline based on depth\n    float result = f >= 0.1 ? 1.0 : 0.0;\n\n    // inner outline based on depth\n    result += 4.0 * f >= 1.05 * (fx1 + fx2 + fy1 + fy2 + 0.000005) ? 1.0 : 0.0;\n\n    // remove outline for the same material\n    result = materialHasInnerLines(material) ? result : 0.0;\n\n    vec4 t = inputTexture(coord);\n    vec4 tx1 = inputTexture(coord - vec2x1);\n    vec4 tx2 = inputTexture(coord + vec2x1);\n    vec4 ty1 = inputTexture(coord - vec2y1);\n    vec4 ty2 = inputTexture(coord + vec2y1);\n\n    // material difference\n    f = material;\n    fx1 = getMaterialIndexComponent(tx1);\n    fx2 = getMaterialIndexComponent(tx2);\n    fy1 = getMaterialIndexComponent(ty1);\n    fy2 = getMaterialIndexComponent(ty2);\n\n    // perimeter outline based on material difference\n    result += abs(f - fx1) + abs(f - fx2) + abs(f - fy1) + abs(f - fy2) > 0.0 ? 1.0 : 0.0;\n\n    // edge group\n    float edge = getEdgeGroupComponent(t);\n    f = edge;\n    fx1 = getEdgeGroupComponent(tx1);\n    fx2 = getEdgeGroupComponent(tx2);\n    fy1 = getEdgeGroupComponent(ty1);\n    fy2 = getEdgeGroupComponent(ty2);\n    result += f > 0.0 && ( // exclude edge group 0\n        fx1 > 0.0 && abs(f - fx1) > 0.0 || fx2 > 0.0 && abs(f - fx2) > 0.0 ||\n        fy1 > 0.0 && abs(f - fy1) > 0.0 || fy2 > 0.0 && abs(f - fy2) > 0.0) ? 1.0 : 0.0;\n\n    // tint difference\n    float tint = getTintIndexComponent(t);\n    f = tint;\n    fx1 = getTintIndexComponent(tx1);\n    fx2 = getTintIndexComponent(tx2);\n    fy1 = getTintIndexComponent(ty1);\n    fy2 = getTintIndexComponent(ty2);\n\n    // perimeter outline based on tint difference (excluding reflection on next slot)\n    result += abs(f - fx1) > 1.0 || abs(f - fx2) > 1.0 || abs(f - fy1) > 1.0 || abs(f - fy2) > 1.0 ? 1.0 : 0.0;\n\n    result = min(result, 1.0);\n\n    return result;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 t = inputTexture(fragCoord);\n\n    if (fragCoord.x < STATE_SIZE && fragCoord.y < 1.0)\n    {\n        fragColor = t;\n        return;\n    }\n\n    deserializeState(iChannel0, iResolution.xy);\n\n    fragColor = setOutlineComponent(t, getOutline(fragCoord));\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// MIT License\n\n// Buffer C - Compose materials and outline\n// Inputs: Buffer B\n\nconst vec3[] skyColor = vec3[](vec3(0.52, 0.78, 0.82), vec3(0.64, 0.9, 1.0), vec3(0.3, 0.6, 1.0));\nconst vec3[] fogColor = vec3[](vec3(1.0), vec3(0.9, 0.95, 1.0), vec3(1.0, 0.8, 1.0));\nconst vec3[] grassColor1 = vec3[](vec3(1.0), vec3(0.84, 1.0, 0.52), vec3(1.0, 0.8, 1.5));\nconst vec3[] grassColor2 = vec3[](vec3(1.0), vec3(0.11, 0.72, 0.49), vec3(0.3, 0.6, 1.5));\nconst vec3[] rockColor1 = vec3[](vec3(1.0), vec3(0.95), vec3(0.95));\nconst vec3[] rockColor2 = vec3[](vec3(1.0), vec3(0.85), vec3(0.85, 0.85, 1.0));\nconst vec3[] mountainColor1 = vec3[](vec3(1.0), vec3(0.21, 0.76, 0.72), vec3(1.0, 0.8, 1.0));\nconst vec3[] mountainColor2 = vec3[](vec3(1.0), vec3(0.81, 1.0, 0.61), vec3(0.3, 0.6, 1.0));\nconst vec3[] skinColor1 = vec3[](vec3(0.76, 0.92, 0.98), vec3(0.85, 0.98, 0.99), vec3(0.85, 0.98, 0.99));\nconst vec3[] skinColor2 = vec3[](vec3(1.0, 0.78, 0.72), vec3(0.94, 0.92, 0.92), vec3(0.94, 0.92, 0.92));\nconst vec3 groundColor = vec3(0.68, 0.34, 0.02);\n\nfloat getMaterialTextureMask(vec3 pos)\n{\n    pos.x += 10.0 * fbm(pos);\n    float x = 1.5 * fbm(pos * vec3(1.0, 0.8, 1.2) * 0.4);\n    x = x * x;\n    x = x * (3.0 - x);\n    return x;\n}\n\nfloat getStarsMask(vec2 pos)\n{\n    const float size1 = 0.03;\n    const float size2 = 0.05;\n    const float gridSize = 0.04;\n    vec2 index = floor(pos / gridSize + 0.5);\n    vec2 pos1 = pos;\n    pos1 -= index * gridSize;\n    float h1 = hash(index);\n    float h2 = hash(index + 1000.0);\n    float h3 = hash(index + 2000.0);\n    pos1 -= 0.4 * gridSize * vec2(map01_11(h1), map01_11(h2));\n    float d = smoothstep((h1 + 1.0) * size2, (h1 + 1.0) * size1, length(pos1) / gridSize);\n    d = h3 < 0.3 ? d : 0.0;\n    return d * h2;\n}\n\nvec3 getMaterialColor(float index, vec2 uv, vec3 pos, vec3 n)\n{\n    if (index < 1.0)\n    {\n        return vec3(1.0, 1.0, 0.0); // missing\n    }\n\n    int theme = int(state.theme);\n\n    if (index < MATERIAL_SKY + 1.0)\n    {\n        pos -= state.origin;\n\n        if (state.theme > 1.0)\n        {\n            vec3 n = normalize(pos);\n            float an = atan(n.y, length(n.xz));\n            float stretch = 3.0 - an / PI05;\n            vec2 p = stretch * pos.xz * 0.001;\n\n            float t = getMaterialTextureMask(0.1 * pos + 2.0);\n            float moon =\n                (0.6 + 3.0 * t) * smoothstep(1.01, 1.0, 12.0 * length(n - SUN_DIRECTION)) +\n                0.3 * smoothstep(0.4, 0.0, length(n - SUN_DIRECTION));\n            return mix(skyColor[theme] * pow(max(1.0 - n.y, 0.0), 0.8), vec3(1.0, 1.0, 0.7), getStarsMask(p) * max(0.0, n.y - 0.2) * 2.0 + moon);\n        }\n\n        if (state.theme > 0.0)\n        {\n            float sunMask = dot(normalize(SUN_DIRECTION), normalize(pos));\n            const float f1 = 0.00012;\n            const float f2 = 0.1;\n            sunMask = max(0.0, (sunMask - 1.0 + f1) / f1) + // sun\n                0.1 * pow(max(0.0, (sunMask - 1.0 + f2) / f2), 4.0); // halo\n            //sunMask *= exp(sunMask);\n            return mix(skyColor[theme], vec3(2.0), sunMask);\n        }\n\n        return skyColor[theme];\n    }\n\n    if (index < MATERIAL_GRASS + 1.0)\n    {\n        vec3 grassColor = mix(grassColor1[theme], grassColor2[theme], uv.x).rgb;\n        return mix(groundColor, grassColor, 0.8 + 0.2 * uv.y);\n    }\n\n    if (index < MATERIAL_FLOWER1 + 1.0)\n    {\n        return uv.y > 0.5 ? vec3(1.0) :\n            min(vec3(1.0), vec3(0.95 + 0.1 * sin((uv.y * 2.0 + vec3(0.0, 0.2, 0.5)) * PI2)));\n        //return mix(vec3(1.0), vec3(1.0, 0.99, 0.1), uv.y);\n    }\n\n    if (index < MATERIAL_FLOWER2 + 1.0)\n    {\n        return vec3(1.0, 1.0, 0.1);\n    }\n\n    if (index < MATERIAL_MOUNTAIN + 1.0)\n    {\n        vec3 pos1 = pos;\n        pos1.xz -= state.origin.xz;\n        float t = getMaterialTextureMask(0.1 * pos1);\n\n        vec3 viewZ = normalize(state.origin - pos);\n        vec3 viewX = normalize(cross(viewZ, vec3(pos1.x, 0.0, pos1.z)));\n\n        float fresnel = dot(n, viewZ);\n        fresnel = pow(clamp(fresnel * 1.2, 0.0, 1.0), 4.0);\n\n        float sky = dot(n, cross(viewZ, viewX));\n        sky = pow(clamp(sky * 1.1, 0.0, 1.0), 8.0);\n\n        //vec3 color = mix(var7.rgb, var8.rgb, 0.7 * fresnel + 0.3 * t);\n        //vec3 color = mix(vec3(0.19, 0.73, 0.6), vec3(0.89, 1.0, 0.81), 0.7 * fresnel + 0.3 * t);\n        //vec3 color = mix(fogColor, skyColor, 0.7 * fresnel + 0.3 * t);\n        vec3 color = mix(mountainColor1[theme], mountainColor2[theme], 0.7 * fresnel + 0.3 * t);\n        color = mix(color, skyColor[theme], 0.8 * sky + 0.2 * t);\n\n        return color;\n    }\n\n    if (index < MATERIAL_ROCK + 1.0)\n    {\n        return mix(rockColor1[theme], rockColor2[theme], getMaterialTextureMask(pos * 7.0));\n    }\n\n    if (index < MATERIAL_SKIN + 1.0)\n    {\n        return mix(skinColor1[theme], skinColor2[theme], uv.y);\n    }\n\n    if (index < MATERIAL_EYE + 1.0)\n    {\n        return vec3(1.0);\n    }\n\n    if (index < MATERIAL_PUPIL + 1.0)\n    {\n        return vec3(0.16, 0.85, 1.0);\n    }\n\n    if (index < MATERIAL_MOUTH + 1.0)\n    {\n        return vec3(1.0, 0.8, 0.75);\n    }\n\n    return vec3(1.0, 1.0, 0.0); // missing\n}\n\nvec4 getMaterialTintColor(float index)\n{\n    return vec4(0.0); // missing\n}\n\nvec2 getOutline(vec2 fragCoord)\n{\n    float f = 0.0;\n    float minDepth = 1.0;\n    float maxDepth = 0.0;\n    float minIndex1 = 100.0;\n    float maxIndex1 = 0.0;\n    float minIndex2 = 100.0;\n    float maxIndex2 = 0.0;\n\n    float outlineIndex1 = 0.0; // selected outline material index\n    float outlineIndex2 = 0.0; // selected outline tint index\n    float outlineDepth = MAX_DIST; // selected outline material distance\n\n    for (int i = 0; i < 9; i++)\n    {\n        vec2 offset = vec2(float(i % 3), float(i / 3)) + vec2(-1.0);\n        vec4 t = inputTexture(fragCoord + offset);\n\n        float depth = min(deserializeDepth(getDepthComponent(t)) / 200.0, 1.0); // MAX_DIST\n        minDepth = min(minDepth, depth);\n        maxDepth = max(maxDepth, depth);\n\n        float index1 = getMaterialIndexComponent(t);\n        minIndex1 = min(minIndex1, index1);\n        maxIndex1 = max(maxIndex1, index1);\n\n        float index2 = getTintIndexComponent(t);\n        minIndex2 = min(minIndex2, index2);\n        maxIndex2 = max(maxIndex2, index2);\n\n        outlineIndex1 = outlineDepth < depth ? outlineIndex1 : index1;\n        outlineIndex2 = outlineDepth < depth ? outlineIndex2 : index2;\n        outlineDepth = min(outlineDepth, depth);\n\n        bool isOutline = getOutlineComponent(t) > 0.0;\n        f += isOutline ? (3.0 - abs(offset.x) - abs(offset.y)) / 3.0 : 0.0;\n    }\n\n    float isEdge = (abs(maxDepth - minDepth) + abs(maxIndex1 - minIndex1) + abs(maxIndex2 - minIndex2)) * 150.0; // keep edge outlines\n\n    float depth1 = pow(1.0 - minDepth, 5.0); // fade inner outlines\n    depth1 = materialFadeInnerLines(maxIndex1) ? depth1 : 1.0;; // keep mountains inner lines\n    minDepth = materialFadeOutlines(minIndex1) && materialFadeOutlines(maxIndex1) ? 40.0 * minDepth : minDepth; // fade grass flowers outlines\n    float opacity = clamp(1.0 - minDepth * 0.5, 0.0, 1.0); // fade far outlines\n    return vec2(opacity * clamp(f / 3.0, 0.0, 1.0) * clamp(isEdge + depth1, 0.0, 1.0), outlineIndex1);\n}\n\nvec3 getPosition(vec2 coord, vec4 t)\n{\n    vec2 uv = map01_11(coord / iResolution.xy);\n    uv.x *= iResolution.x / iResolution.y;\n\n    float depth = deserializeDepth(getDepthComponent(t));\n    vec3 rd = normalize(uv.x * state.viewX + uv.y * state.viewY + FIELD_OF_VIEW * state.viewZ * state.renderScale);\n\n    vec3 pos = state.viewOrigin + depth * rd; // point in scene\n\n    return pos;\n}\n\nvec3 getPosition(vec2 coord)\n{\n    return getPosition(coord, inputTexture(coord));\n}\n\nvec3 getNormal(vec2 coord, vec4 t)\n{\n    vec3 pos = getPosition(coord, t);\n    vec3 nx0 = pos - getPosition(coord - vec2(1.0, 0.0));\n    vec3 ny0 = pos - getPosition(coord - vec2(0.0, 1.0));\n    vec3 nx1 = pos - getPosition(coord + vec2(1.0, 0.0));\n    vec3 ny1 = pos - getPosition(coord + vec2(0.0, 1.0));\n    vec3 nx = length(nx0) < length(nx1) ? -nx0 : nx1;\n    vec3 ny = length(ny0) < length(ny1) ? -ny0 : ny1;\n    return normalize(cross(nx, ny));\n}\n\nvec3 getDepthColor(float depth)\n{\n    const float depth1 = 0.5;\n    const float depth2 = 4.0;\n    depth = deserializeDepth(depth);\n    depth = log(depth + depth1) / log(depth1 + depth2);\n    return vec3(1.0 - depth);\n}\n\n// iq - shadertoy/ll2GD3\nvec3 getGroupColor(float group)\n{\n    return group > 0.0 ? vec3(0.7 + 0.3 * sin((group * 0.27 + vec3(0.66, 0.0, 0.33)) * PI2)) : vec3(0.9);\n}\n\nfloat getTargetMask(vec2 pos)\n{\n    const float thickness = 2.0;\n    const float opening = 5.0;\n    const float size = 15.0;\n\n    pos.xy = abs(pos.xy);\n    pos = vec2(max(pos.x, pos.y), min(pos.x, pos.y));\n\n    return ((pos.x > opening && pos.x < size && pos.x > thickness && pos.y < thickness)) ? 1.0 : 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 t = inputTexture(fragCoord);\n\n    if (fragCoord.x < STATE_SIZE && fragCoord.y < 1.0)\n    {\n        fragColor = t;\n        return;\n    }\n\n    deserializeState(iChannel0, iResolution.xy);\n\n    int theme = int(state.theme);\n\n    vec3 color;\n\n    if (state.renderMode > 6.0)\n    {\n        // uv\n        color = vec3(getMaterialUvComponent(t), 0.0);\n    }\n    else if (state.renderMode > 5.0)\n    {\n        // outline + edge group\n        color = getGroupColor(getEdgeGroupComponent(t)) * (1.0 - getOutlineComponent(t));\n    }\n    else if (state.renderMode > 4.0)\n    {\n        // outline\n        color = vec3(1.0 - getOutlineComponent(t));\n    }\n    else if (state.renderMode > 3.0)\n    {\n        // shadow\n        color = vec3(1.0 - getShadowComponent(t));\n    }\n    else if (state.renderMode > 2.0)\n    {\n        // depth\n        color = getDepthColor(getDepthComponent(t));\n    }\n    else if (state.renderMode > 1.0)\n    {\n        // normal\n        color = getNormal(fragCoord, t);\n    }\n    else if (state.renderMode > 0.0)\n    {\n        // steps\n        color = mix(vec3(getMaterialUvComponent(t).y), vec3(0.6, 0.9, 1.0), getOutlineComponent(t));\n    }\n    else\n    {\n        float materialIndex = getMaterialIndexComponent(t);\n        float tintIndex = getTintIndexComponent(t);\n        float depth = deserializeDepth(getDepthComponent(t));\n        vec2 uv = getMaterialUvComponent(t);\n        vec3 pos = getPosition(fragCoord, t);\n        vec3 n = getNormal(fragCoord, t);\n\n        color = getMaterialColor(materialIndex, uv, pos, n);\n\n        // mix with grass color on down facing surfaces\n        color = mix(color, color + grassColor1[theme] - vec3(1.0), materialIndex > MATERIAL_GRASS ? 0.3 * smoothstep(-0.2, -0.6, dot(n, vec3(0.0, 1.0, 0.0))) : 0.0);\n\n        // outline\n        vec2 outline = getOutline(fragCoord);\n        vec3 outlineColor = getMaterialColor(outline.y, uv, pos, n);\n        outlineColor = vec3(pow(outlineColor.r, 4.0), pow(outlineColor.g, 4.0), pow(outlineColor.b, 4.0));\n        outlineColor = mix(outlineColor, vec3(0.28, 0.15, 0.04), 0.5);\n\n        color = mix(color, outlineColor, outline.x);\n        if (state.theme > 0.0)\n        {\n            // shadow\n            bool isGrass = abs(materialIndex - MATERIAL_GRASS) < 0.1;\n            float shadow = getShadowComponent(t);\n            shadow = isGrass ? shadow : (1.0 - (1.0 - shadow) * smoothstep(0.1, 0.2, dot(SUN_DIRECTION, n)));\n\n            shadow = abs(materialIndex - MATERIAL_SKY) > 0.0 && abs(materialIndex - MATERIAL_MOUNTAIN) > 0.0 ? shadow : 0.0;\n            shadow *= 0.3;\n            color = mix(color, color + vec3(0.3, 0.0, 0.8) - vec3(1.0), shadow);\n\n            // tint\n            vec4 tintColor = getMaterialTintColor(tintIndex);\n            color = mix(color, tintColor.rgb, tintColor.a);\n\n            // fog\n            float fog1 = 50.0 + 2.0 * max(pos.y, 0.0); // start\n            float fog2 = 200.0 + 10.0 * max(pos.y, 0.0); // end\n            float fog = min(pow(max(depth - fog1, 0.0) / (fog2 - fog1), 0.8), 1.0);\n            color = mix(color, fogColor[theme], fog);\n        }\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Buffer C","description":"","type":"buffer"}]}