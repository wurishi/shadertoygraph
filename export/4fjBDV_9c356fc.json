{"ver":"0.1","info":{"id":"4fjBDV","date":"1725531268","viewed":69,"name":"test union ball shader","username":"www998www","description":"union ball shader copy","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["ball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 16x acceleration of https://www.shadertoy.com/view/4tSyzy\n// by applying gaussian at intermediate MIPmap level.\n\nconst int samples = 35,\n          LOD = 2,         // gaussian done on MIPmap at scale LOD\n          sLOD = 1 << LOD; // tile size = 2^LOD\nconst float sigma = float(samples) * .25;\n\nfloat gaussian(vec2 i) {\n    return exp( -.5* dot(i/=sigma,i) ) / ( 6.28 * sigma*sigma );\n}\n\nvec4 blur(sampler2D sp, vec2 U, vec2 scale) {\n    vec4 O = vec4(0);  \n    int s = samples/sLOD;\n    \n    for ( int i = 0; i < s*s; i++ ) {\n        vec2 d = vec2(i%s, i/s)*float(sLOD) - float(samples)/2.;\n        O += gaussian(d) * textureLod( sp, U + scale * d , float(LOD) );\n    }\n    \n    return O / O.a;\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    vec4 col = vec4((texture(iChannel0, U/iResolution.xy).x + texture(iChannel0, U/iResolution.xy).y) / 0.7, 0, 0, 1);\n    vec4 bl =  blur( iChannel0, U/iResolution.xy, 1./iChannelResolution[0].xy );\n    O = col*0.5*bl*0.5 + texture(iChannel0, U/iResolution.xy)*0.6;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// https://www.shadertoy.com/view/3sySRK\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  vec2 mo = iMouse.xy/iResolution.xy;\n  return length(p)-s - (sin(iTime) * 0.2 * 3.0) * floor(sin(iTime)*0.25)*0.3;\n} \n\n\nfloat map(vec3 p)\n{\n    float d = 2.0;\n    for (int i = 0; i < 32; i++) {\n        float fi = float(i);\n        float time = iTime * (fract(fi * 412.531 + 0.513) - 0.5) * 2.0 * 0.1;\n        d = opSmoothUnion(\n            sdSphere(p + sin(time + fi * vec3(52.5126, 64.62744, 632.25) * 3.0) * vec3(iResolution.x/iResolution.y*2.5, 2.5, 1.5), mix(0.5, sin(iTime) * 0.25 + 0.75, fract(fi * 412.531 + 0.5124))),\n            d,\n            0.6\n        );\n    }\n    return d;\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 1e-5; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) + \n                      k.yyx*map( p + k.yyx*h ) + \n                      k.yxy*map( p + k.yxy*h ) + \n                      k.xxx*map( p + k.xxx*h ) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = (0.3 + 0.2*cos(iTime /2.0 +uv.xyx+vec3(0,2,4)));\n    vec3 rayOri = vec3((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0) * 6.0, 3.0);\n    vec3 rayDir = vec3((mo.x - 0.5)*0.5, (mo.y - 0.5)*0.5, -1.0);\n    \n    float depth = 0.0;\n    vec3 p;\n\n    for(int i = 0; i <128; i++) {\n        p = rayOri + rayDir * depth;\n        float dist = map(p);\n        depth += dist;\n        if (dist < 1e-6) {\n            break;\n        }\n    }\n    depth = min(6.0, depth);\n    // Output to screen\n    vec4 color = vec4(depth/2.0*(sin(mo.x) + 1.0)*col.x, depth/2.0*(sin(mo.y) + 1.0)*col.y, depth/2.0*mo.x*col.z, 1.0);\n    fragColor = color * vec4(1.0, 1.0, 1.0, 0.7);\n}","name":"Buffer A","description":"","type":"buffer"}]}