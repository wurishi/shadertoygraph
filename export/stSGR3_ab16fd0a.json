{"ver":"0.1","info":{"id":"stSGR3","date":"1624354547","viewed":88,"name":"Lorenz attractor Weirdness","username":"Bupeldox","description":"Uses a lorenz attractor, a chaotic equation, to do weird stuff.\nThis compares start point of the strange attractor (screen xy + z kinda time), to the output (as the rotation from 0,1).","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["math","trippy","lorenz"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat speed = 1.;\nfloat scale = 4000.0;\nvec2 offset = vec2(0.0,0.0);\nfloat yitterations = 10.;\n\nfloat infinity = 1.0/0.0;\n\nfloat zinp = 0.0;\n\n\n\nfloat tSin(float inp){\nreturn (sin(inp)+1.)/2.;\n}\n\nvec3 LorenzDifferential(vec3 tinput,float delta){\n    float sigma = 20.0;\n    float beta= pow(tSin(speed*iTime/1.242)*10.0,2.);\n    float ohmega= pow(tSin(speed*iTime/4.35)*10.0,2.);\n\n    float x = tinput.x;\n    float y = tinput.y;\n    float z = tinput.z;\n    \n    vec3 newPoint = vec3(\n        (sigma*(y-(x))),\n        (x*(ohmega-abs(z)))-y,\n        ((x*y)-(beta*z))\n    );\n    newPoint = newPoint * delta;\n    return newPoint;\n}\n\n\nvec3 lorenzAttractor(vec3 start,float delta,float itterations){\n\t\n\t\n    \n\tvec3 currentPoint = start;\n    \n\t\n\tfor(float i = 0.;i<itterations;i+=1.0){\n\t\tvec3 tdelta = LorenzDifferential(currentPoint,delta);\n        vec3 newPoint = currentPoint + tdelta;\n        \n        if(abs(newPoint.x)==infinity||abs(newPoint.y)==infinity||abs(newPoint.z)==infinity){\n            //return vec3(max(-i,newPoint.x),max(-i,newPoint.y),max(-i,newPoint.z));\n            return vec3(-i);\n        }\n        \n\t\tcurrentPoint = newPoint;\n\t}\n    \n    vec3 finalTDelta = LorenzDifferential(currentPoint,delta*mod(itterations,1.));\n    \n\treturn currentPoint+finalTDelta;\n}\n\n\nvec3 canvasPToCoord(vec2 inp){\n\n\n    inp = inp - (iResolution.xy*0.5);\n    inp = inp/iResolution.xx;\n    inp.x *= 0.2;\n    inp = inp * scale;\n    inp = inp + offset;\n\treturn vec3(inp,zinp);\n}\n\nfloat transformFunc (float x){\n    //The largest sig fig.\n    float a = floor(log(x))/log(10.)-1.0;\n    float b = x/pow(10.,a);\n    float c = (b-10.)/90.;\n    return min(max(c,0.),1.);\n}\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n \nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvec3 colourTransform(vec3 col){\n        ///*\n        //Winding\n\n        float angle = acos(dot(normalize(col.xy), vec2(0.,1.)));\n          float dist = length(col);\n        vec3 hsv = vec3(angle/(3.1415*2.),0.5,min(max(sqrt(dist)/20.,0.),1.));\n        col = hsv2rgb(hsv);\n        return col;\n        /**/\n        \n        /*\n        //Exponent\n        /**/\n        \n        /*\n        //Exponential Grid\n        col.x =transformFunc(col.x);\n        col.y =transformFunc(col.y);\n        col.z =transformFunc(col.z);\n        col = col*9.;\n        return col;\n        /**/\n\n}\n\n\n\nvec3 colorTransform2(vec3 col){\n   \n    vec3 hsl = rgb2hsv(col);\n\n    hsl.x = hsl.x/2.;\n    hsl.x+=mod(speed*iTime/12.3,1.0);\n    hsl.z = pow(hsl.z,0.2);\n    hsl.x += 0.5;\n\n    return hsv2rgb(hsl);\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float tTime = speed*iTime/2.0;\n   \n    \n    float szoom = (sin(tTime/2.)+1.0);\n    \n    yitterations = 5. + ((sin(tTime)+1.0)*80.0);\n     \n     \n     \n     \n    scale = ((szoom+3.0)-pow((sin(tTime))+1.,1.1)) *3000.0;\n    zinp = cos(tTime/3.14)*1000.0;\n     \n    vec3 col = vec3(0);\n    \n    vec3 p = canvasPToCoord(fragCoord);\n    \n    \n    vec3 endPoint = lorenzAttractor(p,0.001,yitterations);\n    endPoint = abs(endPoint);\n    col = colourTransform(endPoint); \n    \n    \n    col=colorTransform2(col);\n    \n    \n    /*\n    if(col.x<=0. && col.y<=0. && col.z<=0.&&false){\n       //20 15000\n       //90 2500\n        scale = 2000. + ((sin(tTime)+1.0)*((15000.-2500.)/2.));\n        yitterations = 20. + ((sin(tTime+(3.14))+1.0)*45.0);\n        zinp = 1000.;\n        p = canvasPToCoord(fragCoord);\n        zinp = cos(tTime/-3.14)*1000.0;\n        endPoint = lorenzAttractor(p,-0.001,yitterations); //Reverse the differetial\n\n        endPoint = colourTransform(endPoint); \n\n        col=colorTransform2(endPoint);\n        //col=vec3(1.0,1.0,1.0);\n    }*/\n    \n    \n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}