{"ver":"0.1","info":{"id":"4dsfzM","date":"1495481141","viewed":250,"name":"rotating menger sponge","username":"urbans","description":"menger","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["menger"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nfloat map_box(vec3 pos){\n \n    vec3 d = abs(pos) - 1.0;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n    \n}\n\n\nfloat map_test1(vec3 p){\n    //vec3 d = abs(p) - 0.5;\n    \n    vec3 c = vec3(5.0, 5.0, 5.0);\n    vec3 q = mod(p,c) - 0.5*c;\n\n    return length(max(abs(q)-1.0,0.0));\n\n}\n\n\nfloat map_menger1(vec3 p){\n    //vec3 d = abs(p) - 0.5;\n    \n    //vec3 c = vec3(5.0, 5.0, 5.0);\n    //vec3 q = mod(p,c) - 0.5*c;\n\n    vec3 mvx = vec3(1.0, 0.0, 0.0);\n    vec3 mvy = vec3(0.0, 1.0, 0.0);\n    vec3 mvz = vec3(0.0, 0.0, 1.0);\n    \n    float cube1 = length(max(abs(p + mvx)-0.5,0.0));\n    float cube2 = length(max(abs(p)-0.5,0.0));\n    float cube3 = length(max(abs(p - mvx)-0.5,0.0));\n\n    float cube4 = length(max(abs(p + mvx + mvy)-0.5,0.0));\n    float cube5 = length(max(abs(p - mvx + mvy)-0.5,0.0));\n\n    float cube6 = length(max(abs(p + mvx + 2.0 * mvy)-0.5,0.0));\n    float cube7 = length(max(abs(p - mvx + 2.0 * mvy)-0.5,0.0));\n    float cube8 = length(max(abs(p + 2.0 * mvy)-0.5,0.0));\n\n    \n    //return cube1;\n    return min(min(min(min(min(min(min(cube1, cube2), cube3), cube4), cube5), cube6), cube7), cube8);\n\n}\n\n\nfloat menger_atom(vec3 pos, float half_size){ \n    vec3 d = abs(pos) - half_size;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat menger_iter1(vec3 p, float outer_half_size){\n\n\tfloat cube0= menger_atom(p, outer_half_size);\n\n    float inner_half_size = outer_half_size / 3.0;\n    \n    vec3 mvx = vec3(inner_half_size * 2.0, 0.0, 0.0);\n    vec3 mvy = vec3(0.0, inner_half_size * 2.0, 0.0);\n    vec3 mvz = vec3(0.0, 0.0, inner_half_size * 2.0);\n    \n\tfloat inflate = 1.5;\n    float cube11 = menger_atom(p+mvz, inner_half_size * inflate);\n    float cube12 = menger_atom(p,     inner_half_size * inflate);\n\tfloat cube13 = menger_atom(p-mvz, inner_half_size * inflate);\n    \n    float cube14 = menger_atom(p-mvx, inner_half_size * inflate);\t\n    float cube15 = menger_atom(p+mvx, inner_half_size * inflate);\n\n    float cube16 = menger_atom(p-mvy, inner_half_size * inflate);\n    float cube17 = menger_atom(p+mvy, inner_half_size * inflate);\n    \n    //return cube1;\n    float cross_3d = min(min(min(min(min(min(cube11, cube12),cube13),cube14),cube15),cube16),cube17);\n\n    //return cross_3d;\n    return max(-cross_3d, cube0);\n    \n}\n\nfloat menger_iter2(vec3 p, float outer_half_size){\n\n   \tfloat cube0=menger_atom(p, outer_half_size);\n\n    float inner_half_size = outer_half_size / 3.0;\n    \n    vec3 mvx = vec3(inner_half_size * 2.0, 0.0, 0.0);\n    vec3 mvy = vec3(0.0, inner_half_size * 2.0, 0.0);\n    vec3 mvz = vec3(0.0, 0.0, inner_half_size * 2.0);\n    \n\n    float inflate = 1.0;\n    float cube11 = menger_iter1(p+mvz+mvy, inner_half_size * inflate);\n    float cube12 = menger_iter1(p+mvz+mvy+mvx,     inner_half_size * inflate);\n\tfloat cube13 = menger_iter1(p+mvz+mvx, inner_half_size * inflate);\n    float cube14 = menger_iter1(p+mvz+mvy, inner_half_size * inflate);\t\n    float cube15 = menger_iter1(p+mvz-mvy, inner_half_size * inflate);\n    float cube16 = menger_iter1(p+mvz-mvx, inner_half_size * inflate);\n    float cube17 = menger_iter1(p+mvz-mvx-mvy, inner_half_size * inflate);\n    float cube18 = menger_iter1(p+mvz-mvx+mvy, inner_half_size * inflate);\n    float cube19 = menger_iter1(p+mvz+mvx-mvy, inner_half_size * inflate);\n\n    float cube21 = menger_iter1(p+mvx+mvy, inner_half_size * inflate);\n    float cube22 = menger_iter1(p+mvx-mvy,     inner_half_size * inflate);\n\tfloat cube23 = menger_iter1(p-mvx+mvy, inner_half_size * inflate);\n    float cube24 = menger_iter1(p-mvx-mvy, inner_half_size * inflate);\t\n    \n    float cube31 = menger_iter1(p-mvz+mvy, inner_half_size * inflate);\n    float cube32 = menger_iter1(p-mvz+mvy+mvx,     inner_half_size * inflate);\n\tfloat cube33 = menger_iter1(p-mvz+mvx, inner_half_size * inflate);\n    float cube34 = menger_iter1(p-mvz+mvy, inner_half_size * inflate);\t\n    float cube35 = menger_iter1(p-mvz-mvy, inner_half_size * inflate);\n    float cube36 = menger_iter1(p-mvz-mvx, inner_half_size * inflate);\n    float cube37 = menger_iter1(p-mvz-mvx-mvy, inner_half_size * inflate);\n    float cube38 = menger_iter1(p-mvz-mvx+mvy, inner_half_size * inflate);\n    float cube39 = menger_iter1(p-mvz+mvx-mvy, inner_half_size * inflate);\n    \n    \n    //return cube1;\n    float layer1 = min(min(min(min(min(min(min(min(cube11, cube12),cube13),cube14),cube15),cube16),cube17),cube18),cube19);\n    float layer2 = min(min(min(cube21, cube22),cube23),cube24);\n    float layer3 = min(min(min(min(min(min(min(min(cube31, cube32),cube33),cube34),cube35),cube36),cube37),cube38),cube39);\n\n    return min(min(layer1, layer2), layer3);\n    \n}\n\n\nfloat map_menger2(vec3 p){\n\n\treturn menger_iter2(p, 2.0);\n\n}\n\n\n\nfloat map_menger3(vec3 p){\n\n    float box = basic_box(p, vec3(1.0));\n\tfloat hole_x1 = basic_box(p, vec3(100.0, 1.0/3.0, 1.0/3.0));\n\tfloat hole_y1 = basic_box(p, vec3(1.0/3.0, 100.0, 1.0/3.0));\n\tfloat hole_z1 = basic_box(p, vec3(1.0/3.0, 1.0/3.0, 100.0));\n    \n\treturn max(max(max(box,-hole_x1), -hole_y1), -hole_z1);\n\n}\n\n\n\nfloat map_menger4(vec3 p){\n\n\tfloat main_width = 2.0;\n\tfloat hole_x, hole_y, hole_z;\n\tfloat inf = 100.0;\n    float iter_width = main_width;\n\tfloat offset_x, offset_y, offset_z;\n    \n    vec3 startx = vec3(-main_width, 0.0, 0.0);\n    vec3 starty = vec3(0.0, -main_width, 0.0);\n    vec3 startz = vec3(0.0, 0.0, -main_width);\n    \n    float menger = basic_box(p, vec3(main_width));\n\n\n    for (float iter=0.0; iter<3.0; iter++){\n\n        iter_width = iter_width/ 3.0;\n        \n        float step_size = iter_width * 2.0;\n        \n\n        float max_steps = pow(3.0,iter);\n        \n        offset_x = -main_width + iter_width * 3.0;\n\n        for (float j=0.0; j<max_steps; j++){\n\n            \n            offset_y = -main_width + iter_width * 3.0;\n            for (float k=0.0; k<max_steps; k++){\n                \n                \n                offset_z = -main_width + iter_width * 3.0;\n                for (float l=0.0; l<max_steps; l++){\n        \t    \n            \t\thole_x = basic_box(p + vec3(0.0, offset_y, offset_z), vec3(inf, iter_width, iter_width));\n\t\t            hole_y = basic_box(p + vec3(offset_x, 0.0, offset_z), vec3(iter_width, inf, iter_width));\n\t\t\t\t\thole_z = basic_box(p + vec3(offset_x, offset_y, 0.0), vec3(iter_width, iter_width, inf));    \n\n\t\t            menger = max(max(max(menger,-hole_x), -hole_y), -hole_z);\n\t\t\t\t\t//menger = max(-hole_x, menger);\n                    \n\t\t            offset_z += step_size*3.0;\n                }\n                \n                \n                offset_y += step_size * 3.0;\n            }\n   \n            offset_x += step_size * 3.0;\n        }\n        \n    }\n    \n\treturn menger;\n\n}\n*/\n\nfloat basic_box(vec3 pos, vec3 b){\n    vec3 d = abs(pos) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat map_menger5(vec3 p){\n\n\tfloat main_width_b = 3.0;\t// ok\n\tfloat inf = 50.0;\t\t\t// ok\n\n    float hole_x, hole_y, hole_z; \t\t\t // ok\n\tfloat offset_x, offset_y, offset_z;\t\t // ok\n\n    float hole_width_b = main_width_b / 3.0; // correct\n    \n    float menger = basic_box(p, vec3(main_width_b)); // ok\n    \n    for (int iter=0; iter<4; iter++){ \t\t \t\t // ok\n\n\t\tfloat hole_dist = hole_width_b * 2.0 * 3.0;  // correct\n \n        vec3 c = vec3(hole_dist);\n        vec3 q = mod(p + vec3(hole_width_b), c) - vec3(hole_width_b);\n\n        hole_x = basic_box(q, vec3(inf, hole_width_b, hole_width_b));\n        hole_y = basic_box(q, vec3(hole_width_b, inf, hole_width_b));\n        hole_z = basic_box(q, vec3(hole_width_b, hole_width_b, inf));\n\n        hole_width_b = hole_width_b / 3.0;        // reduce hole size for next iter\n        menger = max(max(max(menger, -hole_x), -hole_y), -hole_z); // subtract\n\n    }\n\n\treturn menger;\n\n}\n\n\nfloat trace(vec3 origin, vec3 ray){\n    \n    float t = 0.0;\n    for (int i=0; i<32; ++i){\n        vec3 p = origin + ray * t;\n        float d = map_menger5(p);\n        t += d;\n    }\n\treturn t;\n}\n\nmat2 rotate(float theta){\n    return mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // normalize coords\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    // convert coords from 0,1 to -1,1\n    uv = uv * 2.0 - 1.0;\n    \n    // fix aspect\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ray = normalize(vec3(uv.x, uv.y, 1.0));\n    vec3 origin = vec3(0.0,0.0,-1.0);\n\n    float theta;\n    theta = iTime / 5.0;\n    theta -= 5.0 * iMouse.x/iResolution.x;\n    ray.yz *= rotate(theta);\n    ray.xy *= rotate(theta);\n    origin.yz *= rotate(theta);\n    origin.xy *= rotate(theta);\n    \n    float t = trace(origin, ray);\n    \n    float fog = 1.0 / (1.0 + t * t * 0.1);\n    float intensity = 1.0/(t*t);\n    vec3 fc = vec3(fog);\n    \n\tfragColor = vec4(fc,1.0);\n}","name":"Image","description":"","type":"image"}]}