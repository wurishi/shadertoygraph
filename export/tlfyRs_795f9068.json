{"ver":"0.1","info":{"id":"tlfyRs","date":"1592776931","viewed":125,"name":"RayTracedSingularityAccurate","username":"oseday","description":"black hole","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["ray","blackhole","march"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ambient 1.0\n#define EPSILON 0.01\n#define EventHorizon\n//#define ExpandingGravity\n\nconst float Gravity = 0.1; \n\nstruct rayresult{\n    vec3 o; //origin\n    vec3 v; //direction\n    float dist; //distance\n};\n\nmat4 cam = mat4(\n    1,0,0,0,\n    0,1,0,0,\n    0,0,1,0,\n    0,0,0,1\n);\n\nmat4 addmv(mat4 mat, vec3 v){\n    mat4 n = mat;\n    n[3]=n[3]+vec4(v,0);\n    return n;\n}\n\nmat4 mat4v(vec3 v){\n    return mat4(\n        1,0,0,v.x,\n        0,1,0,v.y,\n        0,0,1,v.z,\n        0,0,0,1\n    );\n}\n\nvec3 matpos(mat4 mat){\n    return mat[3].xyz;\n}\n\nconst float planedist = 1.;\n\nfloat kFarClip = 400.;\nconst int kRaymarchIterations = 800;\nfloat tick;\n\nvec4 calcRayAccel(vec4 pos, vec4 vel, float g) {\t\n\t//calculate schwarzschild geodesic acceleration\n\tfloat r = length(pos.xyz);\n\tfloat oneMinus2MOverR = 1. - 2.*g/r;\t\t\t\n\tfloat posDotVel = dot(pos.xyz, vel.xyz);\n\tfloat velDotVel = dot(vel.xyz, vel.xyz);\n\tfloat r2 = r * r;\n\tfloat invR2M = 1. / (r * oneMinus2MOverR);\n\tfloat rMinus2MOverR2 = oneMinus2MOverR / r;\n\tfloat MOverR2 = g / r2;\n\tvec4 accel = vec4(0.);\n\taccel.xyz = -MOverR2 * (rMinus2MOverR2 * pos.xyz * vel.w * vel.w + invR2M * (pos.xyz * velDotVel - 2. * vel.xyz * posDotVel));\n\taccel.w = 2. * MOverR2 * invR2M * posDotVel * vel.w;\n\treturn accel;\n}\n\nvec3 manager(rayresult io){\n    vec3 col = vec3(0,0,0);\n    \n    \n    \n    float fClosest = kFarClip;\n\tfloat d = 0.0;\n\tfloat dl = kFarClip/float(kRaymarchIterations);\n    float g = dl*Gravity;\n    //bool doo;\n\tfor(int i=0; i<kRaymarchIterations; i++)\n\t{\n        //io.o = io.o + io.v * dl;\n        \n\t\td = length(io.o)/1.;\n        \n        #ifdef EventHorizon\n        //if (d < 1.){\n            //return vec3(0,0,0);\n        //}\n        #endif\n        \n        float gt = g;\n        #ifdef ExpandingGravity\n        gt *= (sin(tick)+1.)\n        #endif\n        \n        \n        //float d2 = d*d;\n        //io.v = normalize(io.v - gt*normalize(io.o)/d2);\n        \n        vec4 pos = vec4(io.o,0.);\n        vec4 vel = vec4(io.v,0.);\n\t\tvel.w = 1. / (1. - 2. * gt / length(io.o));\n        \n\t\t/* Runge-Kutta 4 integration */\n\t\tvec4 accel1 = calcRayAccel(pos, vel, gt);\n\t\tvec4 vel2 = vel + .5 * dl * accel1;\n\t\tvec4 accel2 = calcRayAccel(pos + .5 * dl * vel, vel2, gt);\n\t\tvec4 vel3 = vel + .5 * dl * accel2;\n\t\tvec4 accel3 = calcRayAccel(pos + .5 * dl * vel2, vel3, gt);\n\t\tvec4 vel4 = vel + dl * accel3;\n\t\tvec4 accel4 = calcRayAccel(pos + dl * vel3, vel4, gt);\n\t\tvec4 newpos = pos + (vel + 2. * vel2 + 2. * vel3 + vel4) * dl / 6.;\n\t\tvec4 newvel = vel + (accel1 + 2. * accel2 + 2. * accel3 + accel4) * dl / 6.;\n\t\t/**/\n            \n        io.o = newpos.xyz;\n        io.v = newvel.xyz;\n        \n        //col = col / (1. + 1./d2);\n\t}\n    \n    col += texture(iChannel0,io.v).xyz;\n    \n    \n    return col;\n}\n\nvoid updatescene(float tick){\n    \n}\n\nconst int MSAA = 1;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    tick = iTime/5.;\n    \n    \n    updatescene(tick);\n    \n    vec2 mouseuv = vec2(0,0);//(iMouse.xy-iResolution.xy/2.0)/iResolution.xx*2.;\n    \n    \n    mat4 ncam = cam\n        *build_transform(vec3(0,0,0),vec3(0,-mouseuv.x*3.1415928,0))\n        *build_transform(vec3(0,0,0),vec3(-mouseuv.y*3.1415928+sin(tick*2.*0.)/3.,0,0))\n        ;\n    \n    //kFarClip = 3. - sin(tick)*1.+1.;\n    \n    ncam = ncam\n        //*build_transform(vec3(0,0,-500. + sin(tick*5.)*498.9),vec3(0,0.3,0))\n        *build_transform(vec3(0,0,-1),vec3(0,0,0))\n        ;\n    //ncam[3].xyz = ncam[3].xyz + vec3(0,0,80);\n    \n    \n    vec3 campos = matpos(ncam);\n    vec3 totcol = vec3(0,0,0);\n        \n    float distMSAA = float(MSAA+1);\n    \n    for (int xs=1;xs<=MSAA;xs++){\n        for (int ys=1;ys<=MSAA;ys++){\n            \n            vec2 uv = (fragCoord+vec2(xs,ys)/distMSAA-iResolution.xy/2.0)/iResolution.xx*2.;\n\n            vec3 v = normalize(uv.x*ncam[0].xyz+uv.y*ncam[1].xyz+ncam[2].xyz*planedist);\n\n            vec3 col = vec3(0,0,0);\n\n            rayresult ray;\n            \n            ray.o=campos;\n            ray.v=v;\n            ray.dist=2.10;\n\n            col += manager(ray);\n\n            col = clamp(col,vec3(0,0,0),vec3(1,1,1));\n            totcol += col;\n        }\n    }\n    \n    totcol /= float(MSAA*MSAA);\n\n    fragColor = vec4(totcol,1.);//vec4(totcol,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"mat4 build_transform(vec3 pos, vec3 ang) \n{\n  float cosX = cos(ang.x);\n  float sinX = sin(ang.x);\n  float cosY = cos(ang.y);\n  float sinY = sin(ang.y);\n  float cosZ = cos(ang.z);\n  float sinZ = sin(ang.z);\n\n  mat4 m;\n\n  float m00 = cosY * cosZ + sinX * sinY * sinZ; \n  float m01 = cosY * sinZ - sinX * sinY * cosZ; \n  float m02 = cosX * sinY;\n  float m03 = 0.0;\n  \n  float m04 = -cosX * sinZ; \n  float m05 = cosX * cosZ; \n  float m06 = sinX;\n  float m07 = 0.0;\n  \n  float m08 = sinX * cosY * sinZ - sinY * cosZ;\n  float m09 = -sinY * sinZ - sinX * cosY * cosZ;\n  float m10 = cosX * cosY;\n  float m11 = 0.0;\n  \n  float m12 = pos.x;\n  float m13 = pos.y;\n  float m14 = pos.z;\n  float m15 = 1.0;\n\n  /*\n  //------ Orientation ---------------------------------\n  m[0] = vec4(m00, m01, m02, m03); // first column.\n  m[1] = vec4(m04, m05, m06, m07); // second column.\n  m[2] = vec4(m08, m09, m10, m11); // third column.\n\n  //------ Position ------------------------------------\n  m[3] = vec4(m12, m13, m14, m15); // fourth column.\n  */\n\n  //------ Orientation ---------------------------------\n  m[0][0] = m00; // first entry of the first column.\n  m[0][1] = m01; // second entry of the first column.\n  m[0][2] = m02;\n  m[0][3] = m03;\n  \n  m[1][0] = m04; // first entry of the second column.\n  m[1][1] = m05; // second entry of the second column.\n  m[1][2] = m06;\n  m[1][3] = m07;\n\n  m[2][0] = m08; // first entry of the third column.\n  m[2][1] = m09; // second entry of the third column.\n  m[2][2] = m10;\n  m[2][3] = m11;\n  \n  //------ Position ------------------------------------\n  m[3][0] = m12; // first entry of the fourth column.\n  m[3][1] = m13; // second entry of the fourth column.\n  m[3][2] = m14;\n  m[3][3] = m15;\n\n  return m;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    fragColor = texture(iChannel0,1.7*vec2(atan(rayDir.x/rayDir.z) , (rayDir.y)));\n    fragColor *= fragColor*1.7;\n}","name":"Cube A","description":"","type":"cubemap"}]}