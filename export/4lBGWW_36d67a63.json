{"ver":"0.1","info":{"id":"4lBGWW","date":"1430683364","viewed":704,"name":"Arabesque #1","username":"mplanck","description":"Inspired by Tedx summit video: [url]https://www.youtube.com/watch?v=u0-zCwSfkOo[/url] .  Probably going to keep playing with this idea in a few more sketches.","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["kaleidoscope","raytest"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define REALLY_SMALL_NUMBER 0.0001\n#define BIG_NUMBER 1000000.\n#define PI 3.14159\n#define TWO_PI 6.28318\n\nfloat g_time = 0.;\n    \n// Reference: http://geomalgorithms.com/a05-_intersect-1.html. Does an\n// intersection test against a plane that is assumed to be double sided and\n// passes through the plane_origin and has the specified normal.\n\n// Returns a vec2 where:\n//   result.x = 1. or 0. if there is a hit\n//   result.y = t such that ray_origin + t*ray_direction = intersection point\nvec2 intersect_plane(vec3 ray_origin,\n                     vec3 ray_direction,\n                     vec3 plane_origin,                     \n                     vec3 plane_normal)\n{\n    float ray_direction_dot_normal = dot(ray_direction, plane_normal);\n\n    float denominator = ray_direction_dot_normal;\n    \n    float intersected = 0.;\n    float t = BIG_NUMBER;\n    if (abs(denominator) > REALLY_SMALL_NUMBER) {\n        t = -dot(plane_normal, (ray_origin - plane_origin)) / denominator;    \n        if (t > REALLY_SMALL_NUMBER) {\n            intersected = 1.;\n        }\n    }\n    return vec2(intersected, t);\n\n}\n\n// intersection for a sphere with a ray. If the ray origin is inside the\n// sphere - no intersection takes place.  So there is gauranteed to be a tmin\n// and tmax return value.\n// Returns a vec3 where:\n//  result.x = 1. or 0. to indicate if a hit took place\n//  result.y = tmin\n//  result.z = tmax\n\nvec3 intersect_sphere(vec3 ro,                 \n                     vec3 rd, \n                     float r,\n                     vec3 sphc)\n{\n\n    // Calculate the ray origin in object space of the sphere\n    vec3 oro = ro - sphc;\n\n    // We don't consider an intersection if the ray is inside the sphere\n\n    // DEBRANCH\n    // Equivalent to:\n    // if (dot(oro, oro) < r*r) {\n    //     return vec3(0.);\n    // }\n    float isInsideSphere = step(dot(oro, oro), r*r);\n    \n    float a = dot(rd, rd);\n    float b = dot(oro, rd);\n    float c = dot(oro, oro) - r*r;\n    float discr = b*b - a*c; // discriminant\n\n    float tmin = 0.0;\n    float tmax = 0.0;\n\n    // DEBRANCH\n    // Equivalent to:\n    // if (discr > 0.) {\n    //     ...\n    // }\n\n    float isdiscrgtZero = step(0., discr);\n\n    // Real root of disc, so intersection\n    float sdisc = sqrt(discr);\n    tmin = (-b - sdisc)/a;\n    tmax = (-b + sdisc)/a; \n\n    float hit = step(0., tmin);\n\n    return step(0., (1. - isInsideSphere) * isdiscrgtZero) * vec3(hit, tmin, tmax);\n}\n\nfloat grayscale(vec3 c)\n{\n    return dot(c, vec3(.21, .72, .07));\n}\n\nvoid mirror_test(vec3 o, vec3 r, vec3 po, vec3 pn,\n                 inout vec3 rn,\n                 inout float t)\n{\n    \n    vec2 hr = intersect_plane(o, r, po, pn);\n    if (hr.x > .5 && t > hr.y)\n    {\n        rn = pn;\n        t = hr.y;\n    }\n}\n\nvec3 shade_plane(vec3 hp, \n                 float reflect_depth)\n{\n\n    vec3 c = vec3(0.);\n    float a = 0.;\n\n    // retrace a sphere at the end of the arabesque to\n    // add coollapsing iris effect\n    vec3 iz = vec3(0., -1., 0.);\n    vec3 ix = vec3(1., 0., 0.);\n    vec3 iy = normalize(cross(ix, iz));\n    \n    vec2 uv = .2 * hp.xz;\n    vec3 o = vec3(0.);\n    vec3 r = normalize(ix * uv.x + iy * uv.y + iz);\n    \n    vec3 sphc = vec3(.2 * sin(20. * g_time + reflect_depth), \n                     -5. * sin(12. * g_time + .5 * reflect_depth) - 6., \n                     .2 * cos(20. * g_time + reflect_depth));\n    vec3 spht = intersect_sphere(o, r, .6, sphc);\n    \n    if (spht.x > .5)\n    {\n        float t = spht.y;\n        vec3 hp = o + r * t;\n        vec3 hn = normalize(hp - sphc);\n        float l = max(0., dot(hn, vec3(0., 1., 0.)));\n        a = l * .4 * smoothstep(10., 4., t);\n    }\n\t\n    vec2 tex_lookup = .08 * (hp.xz + g_time * vec2(10., 2.));\n    float tex = grayscale(texture(iChannel0, tex_lookup).rgb);\n    vec3 bg = 1./(reflect_depth*.1+1.) * 1.5 * mix(vec3(1., .4, 0.),\n                                                  vec3(.2, .0, 1.),\n                                                  tex);\n    c = (1. + a) * bg;\n    return c;\n}\n\nvec3 trace_arabesque(vec3 rd, \n                     vec3 ro)\n{\n \n    vec3 r = rd;\n    vec3 o = ro;  \n    vec3 c = vec3(0.);\n    for (float i = 0.; i < 22.; i += 1.)\n    {\n        float t = BIG_NUMBER;\n        vec3 hn = vec3(0.);\n\n        // Test intersection with the mirrors of the arabesque\n\n        mirror_test(o, r, vec3(.5, 0., .866),  vec3(.866, 0., .5),  hn, t);\n        mirror_test(o, r, vec3(0., 0., -1.),   vec3(0., 0., 1.),    hn, t);\n        mirror_test(o, r, vec3(-.5, 0., .866), vec3(-.866, 0., .5), hn, t);        \n\n        // Now test the shaded plane at the bottom of the arabesque\n        vec2 pt = intersect_plane(o, r, vec3(0., -10., 0.), vec3(0., 1., 0.));\n        if (pt.x > .5 && t > pt.y)\n        {\n\n            t = pt.y;\n            vec3 hp = o + r * t;\n            float s = .8 + .2 * smoothstep(0., 2., t);\n            c += s * shade_plane(hp, i);\n            break;\n        }\n\n        // If loop isn't broken, reflect the mirrors of the arabesque \n        // and repeat\n        o = o + r * t;\n        r = reflect(r, hn);\n\n    }\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    g_time = .1 * iTime;\n    \n    // aspect ratio\n    float invar = iResolution.y / iResolution.x;\n    vec2 uv = fragCoord / iResolution.xy - .5;\n    uv.y *= invar;\n    \n    vec3 iz = vec3(0., -1., 0.);\n    vec3 ix = vec3(cos(g_time), 0., sin(g_time));\n    vec3 iy = normalize(cross(ix, iz));\n    \n    vec3 o = vec3(0., 4. * sin(g_time + PI * iMouse.x/iResolution.x), 0.);\n    vec3 r = normalize(ix * uv.x + iy * uv.y + .3 * iz);\n        \n    vec3 c = trace_arabesque(r, o);\n    \n    // gamma correct\n    c = pow(c, vec3(.45));\n    \n    fragColor = vec4(c, 1.);\n}","name":"","description":"","type":"image"}]}