{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"//------------------------------------------------------\n// RGB triangle with linear light intensity correction\n//\n// Click it to compare result with no correction\n//\n// You can adjust correction methods with macro (0-3):\n//------------------------------------------------------\n#define CORRECTION_METHOD     1\n#define CORRECTION_METHOD_ALT 0\n\n//-----------------------\n// 0. Pass, no correction\n//-----------------------\n\nfloat toLinearPass(float c) {\n    return c;\n}\n\nvec3 toLinearPass(vec3 c) {\n    return c;\n}\n\nfloat toSrgbPass(float c) {\n    return c;\n}\n\nvec3 toSrgbPass(vec3 c) {\n    return c;\n}\n\n//-----------------------\n// 1. Standard sRGB\n//-----------------------\n\nfloat toLinearStandard(float c) {\n    return c <= 0.04045\n        ? c / 12.92\n        : pow((c + 0.055) / (1.055), 2.4)\n    ;\n}\n\nvec3 toLinearStandard(vec3 c) {\n    return vec3(toLinearStandard(c.x), toLinearStandard(c.y), toLinearStandard(c.z));\n}\n\nfloat toSrgbStandard(float c) {\n    return c <= 0.0031308\n        ? 12.92 * c\n        : 1.055 * pow(c, 1.0/2.4) - 0.055\n    ;\n}\n\nvec3 toSrgbStandard(vec3 c) {\n    return vec3(toSrgbStandard(c.x), toSrgbStandard(c.y), toSrgbStandard(c.z));\n}\n\n//-----------------------\n// 2. Fast, gamma = 2.2\n// ----------------------\nconst float gamma = 2.2;\n\nfloat toLinearFast(float c) {\n    return pow(c, gamma);\n}\n\nvec3 toLinearFast(vec3 c) {\n    return vec3(toLinearFast(c.x), toLinearFast(c.y), toLinearFast(c.z));\n}\n\nfloat toSrgbFast(float c) {\n    return pow(c, 1.0 / gamma);\n}\n\nvec3 toSrgbFast(vec3 c) {\n    return vec3(toSrgbFast(c.x), toSrgbFast(c.y), toSrgbFast(c.z));\n}\n\n//--------------------------\n// 3. Superfast, gamma = 2.0\n//--------------------------\n\nfloat toLinearSuperFast(float c) {\n    return c * c;\n}\n\nvec3 toLinearSuperFast(vec3 c) {\n    return c * c;\n}\n\nfloat toSrgbSuperFast(float c) {\n    return sqrt(c);\n}\n\nvec3 toSrgbSuperFast(vec3 c) {\n    return sqrt(c);\n}\n\n\n//--------------------------------------------------\n// 4. Advanced\n// Standard with discontinuity elimination\n// Any difference can only be detected with more bpp\n//--------------------------------------------------\n\nfloat toLinearAdvanced(float c) {\n    return c <= 0.0404482362771082\n        ? c / 12.92\n        : pow((c + 0.055) / (1.055), 2.4)\n    ;\n}\n\nvec3 toLinearAdvanced(vec3 c) {\n    return vec3(toLinearAdvanced(c.x), toLinearAdvanced(c.y), toLinearAdvanced(c.z));\n}\n\nfloat toSrgbAdvanced(float c) {\n    return c <= 0.00313066844250063\n        ? 12.92 * c\n        : 1.055 * pow(c, 1.0/2.4) - 0.055\n    ;\n}\n\nvec3 toSrgbAdvanced(vec3 c) {\n    return vec3(toSrgbAdvanced(c.x), toSrgbAdvanced(c.y), toSrgbAdvanced(c.z));\n}\n\n//---\n\n#if CORRECTION_METHOD == 1\n    #define toSrgb   toSrgbStandard\n    #define toLinear toLinearStandard\n#elif CORRECTION_METHOD == 2\n    #define toSrgb   toSrgbFast\n    #define toLinear toLinearFast\n#elif CORRECTION_METHOD == 3\n    #define toSrgb   toSrgbSuperFast\n    #define toLinear toLinearSuperFast\n#elif CORRECTION_METHOD == 4\n    #define toSrgb   toSrgbAdvanced\n    #define toLinear toLinearAdvanced\n#else\n    #define toSrgb   toSrgbPass\n    #define toLinear toLinearPass\n#endif\n\n#if CORRECTION_METHOD_ALT == 1\n    #define toSrgbAlt   toSrgbStandard\n    #define toLinearAlt toLinearStandard\n#elif CORRECTION_METHOD_ALT == 2\n    #define toSrgbAlt   toSrgbFast\n    #define toLinearAlt toLinearFast\n#elif CORRECTION_METHOD_ALT == 3\n    #define toSrgbAlt   toSrgbSuperFast\n    #define toLinearAlt toLinearSuperFast\n#elif CORRECTION_METHOD_ALT == 4\n    #define toSrgbAlt   toSrgbAdvanced\n    #define toLinearAlt toLinearAdvanced\n#else\n    #define toSrgbAlt   toSrgbPass\n    #define toLinearAlt toLinearPass\n#endif\n\n//-----------------------\n// main\n//-----------------------\n\nvoid mainImage(\n    out vec4 fragColor,\n    in vec2 fragCoord)\n{\n    // Triangle vertices\n    vec2 center = iResolution.xy * 0.5 - vec2(0, iResolution.y)*0.15;\n    float radius = iResolution.y * 0.6;\n\n    vec2 p1 = vec2(center.x - radius*sqrt(3.0)*0.5, center.y - radius*0.5);\n    vec2 p2 = vec2(center.x + radius*sqrt(3.0)*0.5, center.y - radius*0.5);\n    vec2 p3 = vec2(center.x, center.y + radius);\n\n    const vec3 c1 = vec3(1.0, 0.0, 0.0);\n    const vec3 c2 = vec3(0.0, 1.0, 0.0);\n    const vec3 c3 = vec3(0.0, 0.0, 1.0);\n        \n    // Rasterization\n    vec2 v12 = p2 - p1;\n    vec2 v13 = p3 - p1;\n    \n    float S = v12.x * v13.y - v13.x * v12.y;\n    \n    vec2 v = fragCoord;    \n    \n    vec2 v1 = p1 - v;\n    vec2 v2 = p2 - v;\n    vec2 v3 = p3 - v;\n    \n    float S12 = v1.x * v2.y - v2.x * v1.y;\n    float S23 = v2.x * v3.y - v3.x * v2.y;\n    float S31 = v3.x * v1.y - v1.x * v3.y;\n  \n    bool outOfBounds = S12 < 0.0 || S23 < 0.0 || S31 < 0.0;\n    if (outOfBounds)\n        return;\n\n    float vc1 = S23 / S;\n    float vc2 = S31 / S;\n    float vc3 = S12 / S;\n\n    bool isClicked = (iMouse.z > 0.0);\n        \n    vec3 c = isClicked\n        ? vc1 * toLinearAlt(c1) + vc2 * toLinearAlt(c2) + vc3 * toLinearAlt(c3)\n        : vc1 * toLinear(c1) + vc2 * toLinear(c2) + vc3 * toLinear(c3)\n    ;\n\n    fragColor.xyz = isClicked\n        ? toSrgbAlt(c)\n        : toSrgb(c)\n    ;\n    fragColor.w = 1.0;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4cKfWG","date":"1734424440","viewed":66,"name":"SRGB correct triangle","username":"oleghab","description":"RGB triangle with color correction\nClick it to compare result\nPick a methods with a macro and recompile\n\n0. Pass, no correction\n1. Standard sRGB\n2. Fast correction aka gamma = 2.2\n3. Superfast correction aka gamma = 2.0\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["srgb"],"hasliked":0,"parentid":"","parentname":""}}