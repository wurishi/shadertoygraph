{"ver":"0.1","info":{"id":"wlfcR2","date":"1684328793","viewed":231,"name":"Voice Assistant","username":"MartinRGB","description":"particles,radial blur glow & sdf ","likes":2,"published":1,"flags":32,"usePreview":1,"tags":["glowkawaseblurradialsdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash1_2(in vec2 x)\n{\n \treturn fract(sin(dot(x, vec2(52.127, 61.2871))) * 521.582);   \n}\n\nvec2 hash2_2(in vec2 x)\n{\n    return fract(sin(x * mat2(20.52, 24.1994, 70.291, 80.171)) * 492.194);\n}\n\n//Simple interpolated noise\nvec2 noise2_2(vec2 uv)\n{\n    //vec2 f = fract(uv);\n    vec2 f = smoothstep(0.0, 1.0, fract(uv));\n    \n \tvec2 uv00 = floor(uv);\n    vec2 uv01 = uv00 + vec2(0,1);\n    vec2 uv10 = uv00 + vec2(1,0);\n    vec2 uv11 = uv00 + 1.0;\n    vec2 v00 = hash2_2(uv00);\n    vec2 v01 = hash2_2(uv01);\n    vec2 v10 = hash2_2(uv10);\n    vec2 v11 = hash2_2(uv11);\n    \n    vec2 v0 = mix(v00, v01, f.y);\n    vec2 v1 = mix(v10, v11, f.y);\n    vec2 v = mix(v0, v1, f.x);\n    \n    return v;\n}\n\n//Simple interpolated noise\nfloat noise1_2(in vec2 uv)\n{\n    vec2 f = fract(uv);\n    //vec2 f = smoothstep(0.0, 1.0, fract(uv));\n    \n \tvec2 uv00 = floor(uv);\n    vec2 uv01 = uv00 + vec2(0,1);\n    vec2 uv10 = uv00 + vec2(1,0);\n    vec2 uv11 = uv00 + 1.0;\n    \n    float v00 = hash1_2(uv00);\n    float v01 = hash1_2(uv01);\n    float v10 = hash1_2(uv10);\n    float v11 = hash1_2(uv11);\n    \n    float v0 = mix(v00, v01, f.y);\n    float v1 = mix(v10, v11, f.y);\n    float v = mix(v0, v1, f.x);\n    \n    return v;\n}\n\n#define PI 3.1415927\n#define TWO_PI 6.283185\n\n#define ANIMATION_SPEED 1.5\n#define MOVEMENT_SPEED 1.0\n#define MOVEMENT_DIRECTION vec2(0.0, -1.0)\n\n#define PARTICLE_SIZE 0.003\n\n#define PARTICLE_SCALE (vec2(1.5, 1.6))\n#define PARTICLE_SCALE_VAR (vec2(0.25, 0.2))\n\n#define PARTICLE_BLOOM_SCALE (vec2(0.5, 0.8))\n#define PARTICLE_BLOOM_SCALE_VAR (vec2(0.3, 0.1))\n\n#define SPARK_COLOR vec3(0.0, 0.0, 1.05) * 1.5\n#define BLOOM_COLOR vec3(0.8, 1., 0.95) * 0.8\n#define SMOKE_COLOR vec3(0.0, 0.43, 1.81) * 0.8\n\n#define SIZE_MOD 1.05\n#define ALPHA_MOD 0.9\n#define LAYERS_COUNT 15\n\n\nfloat layeredNoise1_2(in vec2 uv, in float sizeMod, in float alphaMod, in int layers, in float animation)\n{\n \tfloat noise = 0.0;\n    float alpha = 1.0;\n    float size = 1.0;\n    vec2 offset;\n    for (int i = 0; i < layers; i++)\n    {\n        offset += hash2_2(vec2(alpha, size)) * 10.0;\n        \n        //Adding noise with movement\n     \tnoise += noise1_2(uv * size + iTime * animation * 8.0 * MOVEMENT_DIRECTION * MOVEMENT_SPEED + offset) * alpha;\n        alpha *= alphaMod;\n        size *= sizeMod;\n    }\n    \n    noise *= (1.0 - alphaMod)/(1.0 - pow(alphaMod, float(layers)));\n    return noise;\n}\n\n//Rotates point around 0,0\nvec2 rotate(in vec2 point, in float deg)\n{\n \tfloat s = sin(deg);\n    float c = cos(deg);\n    return mat2(s, c, -c, s) * point;\n}\n\n//Cell center from point on the grid\nvec2 voronoiPointFromRoot(in vec2 root, in float deg)\n{\n  \tvec2 point = hash2_2(root) - 0.5;\n    float s = sin(deg);\n    float c = cos(deg);\n    point = mat2(s, c, -c, s) * point * 0.66;\n    point += root + 0.5;\n    return point;\n}\n\n//Voronoi cell point rotation degrees\nfloat degFromRootUV(in vec2 uv)\n{\n \treturn iTime * ANIMATION_SPEED * (hash1_2(uv) - 0.5) * 2.0;   \n}\n\nvec2 randomAround2_2(in vec2 point, in vec2 range, in vec2 uv)\n{\n \treturn point + (hash2_2(uv) - 0.5) * range;\n}\n\n\nvec3 fireParticles(in vec2 uv, in vec2 originalUV)\n{\n    vec3 particles = vec3(0.0);\n    vec2 rootUV = floor(uv);\n    float deg = degFromRootUV(rootUV);\n    vec2 pointUV = voronoiPointFromRoot(rootUV, deg);\n    float dist = 2.0;\n    float distBloom = 0.0;\n   \n   \t//UV manipulation for the faster particle movement\n    vec2 tempUV = uv + (noise2_2(uv * 2.0) - 0.5) * 0.1;\n    tempUV += -(noise2_2(uv * 3.0 + iTime) - 0.5) * 0.07;\n\n    //Sparks sdf\n    dist = length(rotate(tempUV - pointUV, 0.7) * randomAround2_2(PARTICLE_SCALE, PARTICLE_SCALE_VAR, rootUV));\n    \n    //Bloom sdf\n    distBloom = length(rotate(tempUV - pointUV, 0.7) * randomAround2_2(PARTICLE_BLOOM_SCALE, PARTICLE_BLOOM_SCALE_VAR, rootUV));\n\n    //Add sparks\n    particles += (1.0 - smoothstep(PARTICLE_SIZE * 0.6, PARTICLE_SIZE * 3.0, dist)) * SPARK_COLOR;\n    \n    //Add bloom\n    particles += pow((1.0 - smoothstep(0.0, PARTICLE_SIZE * 6.0, distBloom)) * 1.0, 3.0) * BLOOM_COLOR;\n\n    //Upper disappear curve randomization\n    float border = (hash1_2(rootUV) - 0.5) * 2.0;\n \tfloat disappear = 1.0 - smoothstep(border, border + 0.5, originalUV.y);\n\t\n    //Lower appear curve randomization\n    border = (hash1_2(rootUV + 0.214) - 1.8) * 0.7;\n    float appear = smoothstep(border, border + 0.4, originalUV.y);\n    \n    return particles * disappear * appear;\n}\n\n\n//Layering particles to imitate 3D view\nvec3 layeredParticles(in vec2 uv, in float sizeMod, in float alphaMod, in int layers, in float smoke) \n{ \n    vec3 particles = vec3(0);\n    float size = 1.0;\n    float alpha = 1.0;\n    vec2 offset = vec2(0.0);\n    vec2 noiseOffset;\n    vec2 bokehUV;\n    \n    for (int i = 0; i < layers; i++)\n    {\n        //Particle noise movement\n        noiseOffset = (noise2_2(uv * size * 2.0 + 0.5) - 0.5) * 0.15;\n        \n        //UV with applied movement\n        bokehUV = (uv * size + iTime * MOVEMENT_DIRECTION * MOVEMENT_SPEED) + offset + noiseOffset; \n        \n        //Adding particles\t\t\t\t\t\t\t\tif there is more smoke, remove smaller particles\n\t\tparticles += fireParticles(bokehUV, uv) * alpha * (1.0 - smoothstep(0.0, 1.0, smoke) * (float(i) / float(layers)));\n        \n        //Moving uv origin to avoid generating the same particles\n        offset += hash2_2(vec2(alpha, alpha)) * 10.0;\n        \n        alpha *= alphaMod;\n        size *= sizeMod;\n    }\n    \n    return particles;\n}\n\nvec4 particleImage(in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.x;\n    \n    float vignette = 1.0 - smoothstep(0.4, 1.4, length(uv + vec2(0.0, 0.3)));\n    \n    uv *= 1.8;\n    \n    float smokeIntensity = layeredNoise1_2(uv * 10.0 + iTime * 4.0 * MOVEMENT_DIRECTION * MOVEMENT_SPEED, 1.7, 0.7, 6, 0.2);\n    smokeIntensity *= pow(1.0 - smoothstep(-1.0, 1.6, uv.y), 2.0); \n    vec3 smoke = smokeIntensity * SMOKE_COLOR * 0.8 * vignette;\n    \n    //Cutting holes in smoke\n    smoke *= pow(layeredNoise1_2(uv * 4.0 + iTime * 0.5 * MOVEMENT_DIRECTION * MOVEMENT_SPEED, 1.8, 0.5, 3, 0.2), 2.0) * 1.5;\n    \n    vec3 particles = layeredParticles(uv, SIZE_MOD, ALPHA_MOD, LAYERS_COUNT, smokeIntensity);\n    \n    vec3 col = particles  + SMOKE_COLOR * 0.02;//smoke\n\tcol *= vignette;\n    \n    float lightStrength = 0.2;\n    \n    col = smoothstep(-0.08 - lightStrength, 1.0, col);\n\n    return vec4(col, 1.0);\n}\n\n\n#define STEPS 100.\n\n#define ENABLE_RADIAL_BLUR true\n\nvec4 blurEffect( sampler2D sourceImage, vec2 inUV, vec2 innerPoint ){\n    \n    vec2 targetVector = innerPoint - inUV;\n    float shineFactor = 1. - length(targetVector) / sqrt(2.);\n    \n    //shineFactor*= (sin(iTime) +1.)/2.;\n    \n    vec4 result = texture(sourceImage, inUV);\n    \n    // Turn on to overlay blur over texture\n    bool textureOverlay = true;\n    \n    \n    vec4 particleCol = particleImage(inUV*iResolution.xy);\n    \n    if(!textureOverlay)\n    \tresult = vec4(0.0);\n    \n    if(ENABLE_RADIAL_BLUR)\n        for(float dist = 0.0; dist < 1.0; dist += 1. / STEPS){\n            vec4 radialBlurTex = texture(sourceImage, inUV + targetVector * dist*1.) * shineFactor / STEPS;\n            result += radialBlurTex + radialBlurTex*particleCol*10.;\n\n        }\n    else\n        result = texture(sourceImage,inUV);\n    \tshineFactor = 0.;\n    \n    result.w = 1.;\n    return result;\n    \n}\n\n// Move mouse around to set inner point of radial blur!\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Normalized inner point of radial blur\n    vec2 innerPoint = iMouse.xy / iResolution.xy; //vec2((sin(iTime)+1.)/2.,0.5);\n\n    vec4 blurCol = blurEffect(iChannel0, uv, innerPoint);\n    //innerPoint = vec2(0.5 + 0.25*sin(iTime),0.5);\n    //vec4 particleCol = particleImage(fragCoord);\n    fragColor = blurCol;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// The MIT License\n// Copyright © 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Analytic intersection of a torus (degree 4 equation). Motivated by Antonalog's \n// shader (https://www.shadertoy.com/view/XdSGWy), and simplified the geometrically \n// impossible cases, and optimized coefficients. One can probably do better than \n// this though...\n\n\n// Other intersectors: https://iquilezles.org/articles/intersectors\n//\n// Box:             https://www.shadertoy.com/view/ld23DV\n// Triangle:        https://www.shadertoy.com/view/MlGcDz\n// Capsule:         https://www.shadertoy.com/view/Xt3SzX\n// Ellipsoid:       https://www.shadertoy.com/view/MlsSzn\n// Sphere:          https://www.shadertoy.com/view/4d2XWV\n// Capped Cylinder: https://www.shadertoy.com/view/4lcSRn\n// Disk:            https://www.shadertoy.com/view/lsfGDB\n// Capped Cone:     https://www.shadertoy.com/view/llcfRf\n// Rounded Box:     https://www.shadertoy.com/view/WlSXRW\n// Rounded Cone:    https://www.shadertoy.com/view/MlKfzm\n// Torus:           https://www.shadertoy.com/view/4sBGDy\n// Sphere4:         https://www.shadertoy.com/view/3tj3DW\n// Goursat:         https://www.shadertoy.com/view/3lj3DW\n\n\n\n\nfloat rand(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898,12.1414))) * 83758.5453);\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n);\n    vec2 f = mix(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nvec3 ramp(float t) {\n\treturn t <= .5 ? vec3( 1. - t * 1.4, .5*(sin(iTime)+1.)/2., 1.05*(cos(iTime*2.)+1.)/2. ) / t : vec3( .3 * (1. - t) * 2., .2, 1.05 ) / t;\n}\n\nfloat fire(vec2 n) {\n    return noise(n) + noise(n * 2.1) * .6 + noise(n * 5.4) * .42;\n}\n\n// f(x) = (|x|² + R² - r²)² - 4·R²·|xy|² = 0\nfloat iTorus( in vec3 ro, in vec3 rd, in vec2 tor )\n{\n    float po = 1.0;\n\n    \n    float Ra2 = tor.x*tor.x;\n    float ra2 = tor.y*tor.y;\n\t\n    float m = dot(ro,ro);\n    float n = dot(ro,rd);\n\t\n    float k = (m - ra2 - Ra2)/2.0;\n    float k3 = n;\n    float k2 = n*n + Ra2*rd.z*rd.z + k;\n    float k1 = k*n + Ra2*ro.z*rd.z;\n    float k0 = k*k + Ra2*ro.z*ro.z - Ra2*ra2;\n\t\n    #if 1\n    // prevent |c1| from being too close to zero\n    if( abs(k3*(k3*k3 - k2) + k1) < 0.01 )\n    {\n        po = -1.0;\n        float tmp=k1; k1=k3; k3=tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n\n    }\n\t#endif\n\n    float c2 = 2.0*k2 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3 - k2) + k1;\n    float c0 = k3*(k3*(-3.0*k3*k3 + 4.0*k2) - 8.0*k1) + 4.0*k0;\n\n    \n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    \n    float Q = c2*c2 + c0;\n    float R = 3.0*c0*c2 - c2*c2*c2 - c1*c1;\n    \n\t\n    float h = R*R - Q*Q*Q;\n    float z = 0.0;\n    if( h < 0.0 )\n    {\n    \t// 4 intersections\n        float sQ = sqrt(Q);\n        z = 2.0*sQ*cos( acos(R/(sQ*Q)) / 3.0 );\n    }\n    else\n    {\n        // 2 intersections\n        float sQ = pow( sqrt(h) + abs(R), 1.0/3.0 );\n        z = sign(R)*abs( sQ + Q/sQ );\n    }\t\t\n    z = c2 - z;\n\t\n    float d1 = z   - 3.0*c2;\n    float d2 = z*z - 3.0*c0;\n    if( abs(d1) < 1.0e-4 )\n    {\n        if( d2 < 0.0 ) return -1.0;\n        d2 = sqrt(d2);\n    }\n    else\n    {\n        if( d1 < 0.0 ) return -1.0;\n        d1 = sqrt( d1/2.0 );\n        d2 = c1/d1;\n    }\n\n    //----------------------------------\n\t\n    float result = 1e20;\n\n    h = d1*d1 - z + d2;\n    if( h > 0.0 )\n    {\n        h = sqrt(h);\n        float t1 = -d1 - h - k3; t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = -d1 + h - k3; t2 = (po<0.0)?2.0/t2:t2;\n        if( t1 > 0.0 ) result=t1; \n        if( t2 > 0.0 ) result=min(result,t2);\n    }\n\n    h = d1*d1 - z - d2;\n    if( h > 0.0 )\n    {\n        h = sqrt(h);\n        float t1 = d1 - h - k3;  t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = d1 + h - k3;  t2 = (po<0.0)?2.0/t2:t2;\n        if( t1 > 0.0 ) result=min(result,t1);\n        if( t2 > 0.0 ) result=min(result,t2);\n    }\n\n    return result;\n}\n\n// df(x)/dx\nvec3 nTorus( in vec3 pos, vec2 tor )\n{\n\treturn normalize( pos*(dot(pos,pos)- tor.y*tor.y - tor.x*tor.x*vec3(1.0,1.0,-1.0)));\n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec3 sphPos,in float radius )\n{\n\tvec3 oc = ro - sphPos.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - radius*radius;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\n\n// intersect capsule : https://iquilezles.org/articles/intersectors\nfloat iCap( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n\n        float y = baoa + t*bard;\n        \n        // body\n        if( y>0.0 && y<baba ) return t;\n\n        // caps\n        vec3 oc = (y<=0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - r*r;\n        h = b*b - c;\n        if( h>0.0 )\n        {\n            return -b - sqrt(h);\n        }\n    }\n    return -1.0;\n}\n\n\n#define AA 3\nvec4 torusObject(float radius,float thickness,in vec2 offset)\n{\n    // camera movement\t\n\tfloat an = 3.14/2.; //iTime/2.\n\tvec3 ro = vec3( 2.5*cos(an), 0.0, 2.5*sin(an) ) ;\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n\n   // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    // background\n    vec4 tot = vec4(0.);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(gl_FragCoord.xy+o))/iResolution.y - offset;\n\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*gl_FragCoord.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n\t    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raytrace\n\t\n\t    // raytrace-plane\n        vec2 torus = vec2(radius,thickness);\n        vec2 glowTorus = vec2(radius,thickness+0.03);\n        \n        vec3 sphOPos = vec3( 0.0,0.0,0.0);\n        float sphRadius = radius;\n        float glowSphRadius = radius+0.01;\n        \n        vec3 capA = vec3(0.0,radius/-2.,0.0);\n        vec3 capB = vec3(0.0,radius/2.,0.0);\n        float capR = 0.05;\n        float glowCapR = capR + 0.01;\n        \n        \n        \n        //float t = iTorus( ro, rd, torus );\n        //float glowT = iTorus( ro, rd, glowTorus );\n        \n        //float t = iSphere( ro, rd, sphOPos,sphRadius );\n        //float glowT = iSphere( ro, rd, sphOPos,glowSphRadius );\n        \n        float t = iCap( ro, rd, capA, capB, capR );\n        float glowT = iCap( ro, rd, capA, capB, glowCapR);\n        \n        vec2 uv = gl_FragCoord.xy / iResolution.y;\n    \n        //uv.x += uv.y < .5 ? 23.0 + t * .35 : -11.0 + t * .3;    \n        uv.y = abs(uv.y - .5);\n        uv.x = abs(uv.x - .5);\n        uv *= 5.0;\n    \n        float q = fire(uv - iTime * .013) / 2.0;\n        vec2 r = vec2(fire(uv + q / 2.0 + t - uv.x - uv.y), fire(uv + q - t));\n        vec3 color = vec3(1.0 / (pow(vec3(0.5, 0.0, .1) + 1.61, vec3(4.0))));\n            \n        float grad = pow((r.y + r.y) * max(.0,t/3.) + .1, 4.0); //max(0.,uv.y);\n        color = ramp(grad);\n        color /= (1.50 + max(vec3(0), color));\n        // shading/lighting\t\n\t    //vec4 col = vec4(0.08)*(1.0-0.3*length(p)) + 0.02*rd.y;\n        //### background color\n        \n\t    vec4 col = vec4(0.,0.,0.,1.) ;\n        vec4 glowCol = vec4(0.,0.,0.,1.);\n        \n        \n        if(t>0. )\n\t    {\n            // r\n            //vec3 pos = ro + t*rd;\n\t\t    //vec3 nor = nTorus( pos, torus );\n            //vec3 lig = normalize(vec3(0.7,0.6,0.3));\n            //vec3 hal = normalize(-rd+lig);\n\t\t    //float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n\t\t    //float amb = clamp( 0.5 + 0.5*nor.y, 1.0, 1.0 );\n            \n            \n            //### ring color\n            float dist = 1./t;\n            \n\n            //**********        Radius       **********\n\n            // Dampen the glow to control the radius\n            dist *= 0.1;\n\n            //**********       Intensity     **********\n\n            // Raising the result to a power allows us to change the glow fade behaviour\n            // See https://www.desmos.com/calculator/eecd6kmwy9 for an illustration\n            // (Move the slider of m to see different fade rates)\n            dist = pow(dist, 0.01);\n\n            \n            \n\n            //Knowing the distance from a fragment to the source of the glow, the above can be written compactly as: \n            //\tfloat getGlow(float dist, float radius, float intensity){\n            //\t\treturn pow(radius/dist, intensity);\n            //\t}\n            //The returned value can then be multiplied with a colour to get the final result\n\n            // Get colour\n            col.rgb = dist * vec3(1., 1., 1.0); //+distance(p-offset/2.,p+offset/2.)\n\n            // Glow Fire Effect\n            float t = iTime;\n    \t\tvec2 uv = gl_FragCoord.xy / iResolution.y;\n    \n    \t\t//uv.x += uv.y < .5 ? 23.0 + t * .35 : -11.0 + t * .3;    \n    \t\tuv.y = abs(uv.y - .5);\n    \t\tuv.x = abs(uv.x - .5);\n    \t\tuv *= 5.0;\n    \n    \t\tfloat q = fire(uv - t * .013) / 2.0;\n    \t\tvec2 r = vec2(fire(uv + q / 2.0 + t - uv.x - uv.y), fire(uv + q - t));\n    \t\tvec3 color = vec3(1.0 / (pow(vec3(0.5, 0.0, .1) + 1.61, vec3(4.0))));\n            \n            float grad = pow((r.y + r.y) * max(.0,dist/3.) + .1, 4.0); //max(0.,uv.y);\n    \t\tcolor = ramp(grad);\n    \t\tcolor /= (1.50 + max(vec3(0), color));\n            \n            // See comment by P_Malin\n            col.rgb = 1.0 - exp( -col.rgb );\n            \n            col.a = 1.;\n            \n            \n            // add fire Effect\n            //col.rgb = color;\n            \n            //col = vec4(1.);\n            \n            //const float fr = 3.14159*8.0;\n            //vec2 uv = vec2(0.8*atan(pos.x,pos.y),atan(pos.z,length(pos.xy)-torus.y));\n            //float wi = smoothstep(-1.0,-0.98,cos(uv.x*fr))*smoothstep(-1.0,-0.98,cos(uv.y*fr));\n\t\t    //col.rgb *= vec3(0.15,0.25,0.35)*amb + 1.05*vec3(1.0,0.9,0.7)*dif;\n            //col.rgb += wi*0.3*pow(clamp(dot(hal,nor),0.0,1.0),32.0)*dif;\n\t    }\n        \n        \n        if((glowT) > 0.)\n        {\n            //**********         Glow        **********\n    \n            // Equation 1/x gives a hyperbola which is a nice shape to use for drawing glow as \n            // it is intense near 0 followed by a rapid fall off and an eventual slow fade\n            float dist = 1./glowT;\n            \n\n            //**********        Radius       **********\n\n            // Dampen the glow to control the radius\n            dist *= 0.1;\n\n            //**********       Intensity     **********\n\n            // Raising the result to a power allows us to change the glow fade behaviour\n            // See https://www.desmos.com/calculator/eecd6kmwy9 for an illustration\n            // (Move the slider of m to see different fade rates)\n            dist = pow(dist, 0.01);\n\n            \n            \n\n            //Knowing the distance from a fragment to the source of the glow, the above can be written compactly as: \n            //\tfloat getGlow(float dist, float radius, float intensity){\n            //\t\treturn pow(radius/dist, intensity);\n            //\t}\n            //The returned value can then be multiplied with a colour to get the final result\n\n\n            //Length = 1.0-smoothstep(Length,0.0,0.4) / 0.2;\n           \n            // Get colour\n            glowCol.rgb = dist * vec3(1.0, 1.0, 1.0); //+distance(p-offset/2.,p+offset/2.)\n\n            // Glow Fire Effect\n            float t = iTime;\n    \t\tvec2 uv = gl_FragCoord.xy / iResolution.y;\n    \n    \t\t//uv.x += uv.y < .5 ? 23.0 + t * .35 : -11.0 + t * .3;    \n    \t\tuv.y = abs(uv.y - .5);\n    \t\tuv.x = abs(uv.x - .5);\n    \t\tuv *= 5.0;\n    \n    \t\tfloat q = fire(uv - t * .013) / 2.0;\n    \t\tvec2 r = vec2(fire(uv + q / 2.0 + t - uv.x - uv.y), fire(uv + q - t));\n    \t\tvec3 color = vec3(1.0 / (pow(vec3(0.5, 0.0, .1) + 1.61, vec3(4.0))));\n            \n            float grad = pow((r.y + r.y) * max(.0,dist/3.) + .1, 4.0); //max(0.,uv.y);\n    \t\tcolor = ramp(grad);\n    \t\tcolor /= (1.50 + max(vec3(0), color));\n            \n            //glowCol.rgb = color;\n            \n            // See comment by P_Malin\n            glowCol.rgb = 1.0 - exp( -glowCol.rgb );\n            glowCol.rgb = mix(glowCol.rgb,color,0.4);\n           \t//glowCol *= Length;\n        }\n        \n        \n        tot += glowCol;\n\t\n\t    //tot += col;\n        \n\n    #if AA>1\n    }\n    \n    // ## AA Effect\n    \n    tot /= float(AA*AA);\n    #endif\n\n\t// dither to remove banding in the background\n    //tot.rgb += fract(sin(gl_FragCoord.x*vec3(13,1,11)+gl_FragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n    \n    return tot*1.;\n}\n\nvec4 mixCol(in vec4 orig,in vec4 mixed){\n\treturn mix(orig,mixed,orig.a);\n}\n\nfloat freqs[4];\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    freqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x*2.;\n\tfreqs[1] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x*2.;\n\tfreqs[2] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x*2.;\n\tfreqs[3] = texture( iChannel0, vec2( 0.30, 0.25 ) ).x*2.;\n        \n    float motionFactor = (sin(iTime*6.)+1.)/2.;\n    //motionFactor = 1.;\n    motionFactor *= 2.5;\n  \tvec4 color = torusObject(0.02 + 0.23*motionFactor,0.05,vec2(0.,0.));\n    \n    color += torusObject(0.02 + 0.13*motionFactor,0.05,vec2(0.2,0.));\n    color += torusObject(0.02 + 0.08*motionFactor,0.05,vec2(0.4,0.));\n    color += torusObject(0.02 + 0.03*motionFactor,0.05,vec2(0.6,0.));\n    color += torusObject(0.02,0.05,vec2(0.8,0.));\n    \n    color += torusObject(0.02 + 0.13*motionFactor,0.05,vec2(-0.2,0.));\n    color += torusObject(0.02 + 0.08*motionFactor,0.05,vec2(-0.4,0.));\n    color += torusObject(0.02 + 0.03*motionFactor,0.05,vec2(-0.6,0.));\n    color += torusObject(0.02,0.05,vec2(-0.8,0.));\n    \n    \n    //vec4 color = torusObject(0.02 + 0.23*freqs[0],0.05*freqs[0],vec2(0.,0.));\n    //color += torusObject(0.02 + 0.13*freqs[0],0.05*freqs[0],vec2(0.2,0.));\n    //color += torusObject(0.02 + 0.08*freqs[0],0.05*freqs[0],vec2(0.4,0.));\n    //color += torusObject(0.02 + 0.03*freqs[0],0.05*freqs[0],vec2(0.6,0.));\n    //color += torusObject(0.02,0.05*freqs[0],vec2(0.8,0.));\n    \n    //color += torusObject(0.02 + 0.13*freqs[0],0.05*freqs[0],vec2(-0.2,0.));\n    //color += torusObject(0.02 + 0.08*freqs[0],0.05*freqs[0],vec2(-0.4,0.));\n    //color += torusObject(0.02 + 0.03*freqs[0],0.05*freqs[0],vec2(-0.6,0.));\n    //color += torusObject(0.02,0.05*freqs[0],vec2(-0.8,0.));\n    \n    \n    fragColor = color;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// downsample pass 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.xy / (iResolution.xy / 2.0));\n    vec2 halfpixel = 0.5 / (iResolution.xy / 2.0);\n    float offset = 5.0;\n\n    vec4 sum = texture(iChannel0, uv) * 4.0;\n    sum += texture(iChannel0, uv - halfpixel.xy * offset);\n    sum += texture(iChannel0, uv + halfpixel.xy * offset);\n    sum += texture(iChannel0, uv + vec2(halfpixel.x, -halfpixel.y) * offset);\n    sum += texture(iChannel0, uv - vec2(halfpixel.x, -halfpixel.y) * offset);\n\n    fragColor = sum / 8.0;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// upsample pass 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.xy / (iResolution.xy * 2.0));\n    vec2 halfpixel = 0.5 / (iResolution.xy * 2.0);\n    float offset = 5.0;\n\n    vec4 sum = texture(iChannel0, uv +vec2(-halfpixel.x * 2.0, 0.0) * offset);\n    \n    sum += texture(iChannel0, uv + vec2(-halfpixel.x, halfpixel.y) * offset) * 2.0;\n    sum += texture(iChannel0, uv + vec2(0.0, halfpixel.y * 2.0) * offset);\n    sum += texture(iChannel0, uv + vec2(halfpixel.x, halfpixel.y) * offset) * 2.0;\n    sum += texture(iChannel0, uv + vec2(halfpixel.x * 2.0, 0.0) * offset);\n    sum += texture(iChannel0, uv + vec2(halfpixel.x, -halfpixel.y) * offset) * 2.0;\n    sum += texture(iChannel0, uv + vec2(0.0, -halfpixel.y * 2.0) * offset);\n    sum += texture(iChannel0, uv + vec2(-halfpixel.x, -halfpixel.y) * offset) * 2.0;\n\n    fragColor = sum / 12.0;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"XsXGzn","filepath":"/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3","previewfilepath":"/media/ap/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3","type":"music","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// The MIT License\n// Copyright © 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Analytic intersection of a torus (degree 4 equation). Motivated by Antonalog's \n// shader (https://www.shadertoy.com/view/XdSGWy), and simplified the geometrically \n// impossible cases, and optimized coefficients. One can probably do better than \n// this though...\n\n\n// Other intersectors: https://iquilezles.org/articles/intersectors\n//\n// Box:             https://www.shadertoy.com/view/ld23DV\n// Triangle:        https://www.shadertoy.com/view/MlGcDz\n// Capsule:         https://www.shadertoy.com/view/Xt3SzX\n// Ellipsoid:       https://www.shadertoy.com/view/MlsSzn\n// Sphere:          https://www.shadertoy.com/view/4d2XWV\n// Capped Cylinder: https://www.shadertoy.com/view/4lcSRn\n// Disk:            https://www.shadertoy.com/view/lsfGDB\n// Capped Cone:     https://www.shadertoy.com/view/llcfRf\n// Rounded Box:     https://www.shadertoy.com/view/WlSXRW\n// Rounded Cone:    https://www.shadertoy.com/view/MlKfzm\n// Torus:           https://www.shadertoy.com/view/4sBGDy\n// Sphere4:         https://www.shadertoy.com/view/3tj3DW\n// Goursat:         https://www.shadertoy.com/view/3lj3DW\n\n\n\n// f(x) = (|x|² + R² - r²)² - 4·R²·|xy|² = 0\nfloat iTorus( in vec3 ro, in vec3 rd, in vec2 tor )\n{\n    float po = 1.0;\n\n    \n    float Ra2 = tor.x*tor.x;\n    float ra2 = tor.y*tor.y;\n\t\n    float m = dot(ro,ro);\n    float n = dot(ro,rd);\n\t\n    float k = (m - ra2 - Ra2)/2.0;\n    float k3 = n;\n    float k2 = n*n + Ra2*rd.z*rd.z + k;\n    float k1 = k*n + Ra2*ro.z*rd.z;\n    float k0 = k*k + Ra2*ro.z*ro.z - Ra2*ra2;\n\t\n    #if 1\n    // prevent |c1| from being too close to zero\n    if( abs(k3*(k3*k3 - k2) + k1) < 0.01 )\n    {\n        po = -1.0;\n        float tmp=k1; k1=k3; k3=tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n\n    }\n\t#endif\n\n    float c2 = 2.0*k2 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3 - k2) + k1;\n    float c0 = k3*(k3*(-3.0*k3*k3 + 4.0*k2) - 8.0*k1) + 4.0*k0;\n\n    \n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    \n    float Q = c2*c2 + c0;\n    float R = 3.0*c0*c2 - c2*c2*c2 - c1*c1;\n    \n\t\n    float h = R*R - Q*Q*Q;\n    float z = 0.0;\n    if( h < 0.0 )\n    {\n    \t// 4 intersections\n        float sQ = sqrt(Q);\n        z = 2.0*sQ*cos( acos(R/(sQ*Q)) / 3.0 );\n    }\n    else\n    {\n        // 2 intersections\n        float sQ = pow( sqrt(h) + abs(R), 1.0/3.0 );\n        z = sign(R)*abs( sQ + Q/sQ );\n    }\t\t\n    z = c2 - z;\n\t\n    float d1 = z   - 3.0*c2;\n    float d2 = z*z - 3.0*c0;\n    if( abs(d1) < 1.0e-4 )\n    {\n        if( d2 < 0.0 ) return -1.0;\n        d2 = sqrt(d2);\n    }\n    else\n    {\n        if( d1 < 0.0 ) return -1.0;\n        d1 = sqrt( d1/2.0 );\n        d2 = c1/d1;\n    }\n\n    //----------------------------------\n\t\n    float result = 1e20;\n\n    h = d1*d1 - z + d2;\n    if( h > 0.0 )\n    {\n        h = sqrt(h);\n        float t1 = -d1 - h - k3; t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = -d1 + h - k3; t2 = (po<0.0)?2.0/t2:t2;\n        if( t1 > 0.0 ) result=t1; \n        if( t2 > 0.0 ) result=min(result,t2);\n    }\n\n    h = d1*d1 - z - d2;\n    if( h > 0.0 )\n    {\n        h = sqrt(h);\n        float t1 = d1 - h - k3;  t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = d1 + h - k3;  t2 = (po<0.0)?2.0/t2:t2;\n        if( t1 > 0.0 ) result=min(result,t1);\n        if( t2 > 0.0 ) result=min(result,t2);\n    }\n\n    return result;\n}\n\n// df(x)/dx\nvec3 nTorus( in vec3 pos, vec2 tor )\n{\n\treturn normalize( pos*(dot(pos,pos)- tor.y*tor.y - tor.x*tor.x*vec3(1.0,1.0,-1.0)));\n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec3 sphPos,in float radius )\n{\n\tvec3 oc = ro - sphPos.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - radius*radius;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\n\n// intersect capsule : https://iquilezles.org/articles/intersectors\nfloat iCap( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n\n        float y = baoa + t*bard;\n        \n        // body\n        if( y>0.0 && y<baba ) return t;\n\n        // caps\n        vec3 oc = (y<=0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - r*r;\n        h = b*b - c;\n        if( h>0.0 )\n        {\n            return -b - sqrt(h);\n        }\n    }\n    return -1.0;\n}\n\n\n#define AA 1\nvec4 torusObject(float radius,float thickness,in vec2 offset)\n{\n    // camera movement\t\n\tfloat an = iTime/4.; //0.5*iTime*2.\n\tvec3 ro = vec3( 2.5*cos(an), 0.0, 2.5*sin(an) ) ;\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n\n   // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    // background\n    vec4 tot = vec4(0.);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(gl_FragCoord.xy+o))/iResolution.y - offset;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*gl_FragCoord.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n\t    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raytrace\n\t\n\t    // raytrace-plane\n        vec2 torus = vec2(radius,thickness);\n        vec2 glowTorus = vec2(radius,thickness+0.02);\n        \n        vec3 sphOPos = vec3( 0.0,0.0,0.0);\n        float sphRadius = radius;\n        float glowSphRadius = radius+0.02;\n        \n        vec3  capA = vec3(0.0,-radius/2.,0.0);\n        vec3  capB = vec3(0.0,radius/2.,0.0);\n        float capR = 0.05;\n        float glowCapR = capR + 0.02;\n        \n        \n        \n        //float t = iTorus( ro, rd, torus );\n        //float glowT = iTorus( ro, rd, glowTorus );\n        \n        //float t = iSphere( ro, rd, sphOPos,sphRadius );\n        //float glowT = iSphere( ro, rd, sphOPos,glowSphRadius );\n        \n        float t = iCap( ro, rd, capA, capB, capR );\n        float glowT = iCap( ro, rd, capA, capB, glowCapR);\n        \n        // shading/lighting\t\n\t    //vec4 col = vec4(0.08)*(1.0-0.3*length(p)) + 0.02*rd.y;\n        //### background color\n        \n\t    vec4 col = vec4(0.,0.,0.,1.) ;\n        vec4 glowCol = vec4(0.,0.,0.,1.);\n        \n        \n        if(t>0. )\n\t    {\n            // r\n            //vec3 pos = ro + t*rd;\n\t\t    //vec3 nor = nTorus( pos, torus );\n            //vec3 lig = normalize(vec3(0.7,0.6,0.3));\n            //vec3 hal = normalize(-rd+lig);\n\t\t    //float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n\t\t    //float amb = clamp( 0.5 + 0.5*nor.y, 1.0, 1.0 );\n            \n            \n            //### ring color\n            float dist = 1./t;\n            \n\n            //**********        Radius       **********\n\n            // Dampen the glow to control the radius\n            dist *= 0.1;\n\n            //**********       Intensity     **********\n\n            // Raising the result to a power allows us to change the glow fade behaviour\n            // See https://www.desmos.com/calculator/eecd6kmwy9 for an illustration\n            // (Move the slider of m to see different fade rates)\n            dist = pow(dist, 0.01);\n\n            \n            \n\n            //Knowing the distance from a fragment to the source of the glow, the above can be written compactly as: \n            //\tfloat getGlow(float dist, float radius, float intensity){\n            //\t\treturn pow(radius/dist, intensity);\n            //\t}\n            //The returned value can then be multiplied with a colour to get the final result\n\n            // Get colour\n            col.rgb = dist * vec3(1., 1., 1.0); //+distance(p-offset/2.,p+offset/2.)\n\n            // See comment by P_Malin\n            col.rgb = 1.0 - exp( -col.rgb );\n            \n            col.a = 1.;\n            \n            //col = vec4(1.);\n            \n            //const float fr = 3.14159*8.0;\n            //vec2 uv = vec2(0.8*atan(pos.x,pos.y),atan(pos.z,length(pos.xy)-torus.y));\n            //float wi = smoothstep(-1.0,-0.98,cos(uv.x*fr))*smoothstep(-1.0,-0.98,cos(uv.y*fr));\n\t\t    //col.rgb *= vec3(0.15,0.25,0.35)*amb + 1.05*vec3(1.0,0.9,0.7)*dif;\n            //col.rgb += wi*0.3*pow(clamp(dot(hal,nor),0.0,1.0),32.0)*dif;\n\t    }\n        \n        \n        if((glowT) > 0.)\n        {\n            //**********         Glow        **********\n    \n            // Equation 1/x gives a hyperbola which is a nice shape to use for drawing glow as \n            // it is intense near 0 followed by a rapid fall off and an eventual slow fade\n            float dist = 1./glowT;\n            \n\n            //**********        Radius       **********\n\n            // Dampen the glow to control the radius\n            dist *= 0.1;\n\n            //**********       Intensity     **********\n\n            // Raising the result to a power allows us to change the glow fade behaviour\n            // See https://www.desmos.com/calculator/eecd6kmwy9 for an illustration\n            // (Move the slider of m to see different fade rates)\n            dist = pow(dist, 0.01);\n\n            \n            \n\n            //Knowing the distance from a fragment to the source of the glow, the above can be written compactly as: \n            //\tfloat getGlow(float dist, float radius, float intensity){\n            //\t\treturn pow(radius/dist, intensity);\n            //\t}\n            //The returned value can then be multiplied with a colour to get the final result\n\n\n            //Length = 1.0-smoothstep(Length,0.0,0.4) / 0.2;\n           \n            // Get colour\n            glowCol.rgb = dist * vec3(0.0, 0.5, 1.0); //+distance(p-offset/2.,p+offset/2.)\n\n            \n            // See comment by P_Malin\n            glowCol.rgb = 1.0 - exp( -glowCol.rgb );\n           // glowCol *= Length;\n        }\n        \n        \n        //tot += glowCol;\n\t\n\t    tot += col;\n        \n\n    #if AA>1\n    }\n    \n    // ## AA Effect\n    \n    tot /= float(AA*AA);\n    #endif\n\n\t// dither to remove banding in the background\n    //tot.rgb += fract(sin(gl_FragCoord.x*vec3(13,1,11)+gl_FragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n    \n    return tot*1.;\n}\n\nvec4 renderObject(){\n    \n    float motionFactor = (sin(iTime*6.)+1.)/2.;\n    //motionFactor = 1.;\n    motionFactor *= 2.5;\n    \n  \tvec4 color = torusObject(0.02 + 0.23*motionFactor,0.05,vec2(0.,0.));\n    color += torusObject(0.02 + 0.13*motionFactor,0.05,vec2(0.2,0.));\n    color += torusObject(0.02 + 0.08*motionFactor,0.05,vec2(0.4,0.));\n    color += torusObject(0.02 + 0.03*motionFactor,0.05,vec2(0.6,0.));\n    color += torusObject(0.02,0.05,vec2(0.8,0.));\n    \n    color += torusObject(0.02 + 0.13*motionFactor,0.05,vec2(-0.2,0.));\n    color += torusObject(0.02 + 0.08*motionFactor,0.05,vec2(-0.4,0.));\n    color += torusObject(0.02 + 0.03*motionFactor,0.05,vec2(-0.6,0.));\n    color += torusObject(0.02,0.05,vec2(-0.8,0.));\n    \n    return color;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    \n    vec4 colorTex = texture(iChannel1,uv);\n    \n    \n    \n    mat3 trans = mat3(\n        1.0-0.05, 0.0, -1.,\n        0.0, 1.0-0.05, -1.,\n\t\t0.0, 0.0, 1.0\n\t);\n    \n    \n    float fi = 3.14;\n    \n    mat2 rot = mat2(\n        cos(fi), -sin(fi),\n        sin(fi), cos(fi)\n\t);\n    \n    uv = (vec3(uv,1) * trans).xy;\n    uv = uv * rot;\n    uv = (vec3(uv,1) * -trans).xy;\n    \n    \n    vec4 blurTex = texture(iChannel0,uv);\n  \n    blurTex.rgb *= vec3(0.,0.5,1.);\n    uv = fragCoord.xy/iResolution.xy;\n    //colorTex = renderObject();\n    \n    colorTex = texture(iChannel1,vec2(uv.x/1.11,uv.y/1.1) + vec2(0.05));\n    \n    fragColor =  blurTex + colorTex*1.05 ;\n}","name":"Buffer D","description":"","type":"buffer"}]}