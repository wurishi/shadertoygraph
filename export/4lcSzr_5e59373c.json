{"ver":"0.1","info":{"id":"4lcSzr","date":"1477614420","viewed":244,"name":"Easy Rotation","username":"panda1234lee","description":"Easy Rotation","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["rotate","rotation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 参考自 https://www.shadertoy.com/view/XlsGWf#\n\n/*void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 offset = vec2(.5, .5);\n    \n    uv-=offset;\n    \n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n\n    float rot = radians(iTime * 45.0);\n    \n    mat2 m = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n   \tuv  = m * uv;\n    \n    uv+=offset;\n    \n    fragColor = texture(iChannel0, uv);\n    \n    if(uv.x >= 0. \n       && uv.y >= 0. \n       && uv.x <= 1.\n       && uv.y <= 1. )\n       fragColor = texture(iChannel0, uv);\n    else\n       fragColor = vec4(0.);\n}*/\n\n\n// 谢谢 834144373 大神的指导！\nvoid mainImage( out vec4 c,vec2 u)\n{\t\n   \tu = mat2(cos(.785*iDate.w-vec4(0,-1.6,1.6,0))) * (u+u-(c.xy=iResolution.xy))/c.x + .5;\n    c = all(lessThan(abs(u-.5),u-u+.5)) ? texture(iChannel0,u, -10.) : -c;\n}\n\n// Thanks ollj !\n// return 2d rotation matrix of rotation by [a] in radians; \n// (以a为弧度，返回一个2D旋转矩阵)\n//#define r2(a)   mat2(-cos(a),sin(a),sin(a),cos(a))\n// return 2d mirror matrix equal to single rotation by [a] in radians; 1.585 is not perfect for r=pi/4, but close enough.\n// (返回一个2D镜像矩阵，等价于以a为弧度的单次旋转。虽然1.585对于 r=pi/4 的情况不是很理想， 但已经足够近似了)\n//#define r2m(a) mat2(sin(a + vec4(1, 0, 0, -1) * 1.585025))\n\n// https://www.shadertoy.com/view/llV3zK\n// return [p].xyz, reflected at plane with [planeNormal] and [offset] from vec3(0)\n/*float pReflect(inout vec3 p, vec3 planeNormal, float offset)\n{\n    float t=dot(p, planeNormal)+offset;\n    if (t<0.)\n        p=p-(2.*t)*planeNormal;\n    \n    return sign(t);\n}*/","name":"Image","description":"","type":"image"}]}