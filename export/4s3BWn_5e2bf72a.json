{"ver":"0.1","info":{"id":"4s3BWn","date":"1524591459","viewed":160,"name":"Tentacle Tunnel v2","username":"ChloeSnyder","description":"CIS 566 final project v2","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["566"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define deg2rad PI / 180.0\n\n// RAY MARCHING CODE SOURCE JAMIE WONG\nconst int MAX_MARCHING_STEPS = 400;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 250.0;\nconst float EPSILON = 0.001;\nconst float EPSILON_NORM = .001;\n\nconst vec3 A = vec3(-3.142, -3.142, .618);\nconst vec3 B = vec3(-3.142, -3.142,-.362);\nconst vec3 C = vec3(-3.142, -3.142, 2.0);\nconst vec3 D = vec3(-3.142, -3.142, -3.142);\n\nconst vec3 A2 = vec3(0.070, 0.095, 0.157);\nconst vec3 B2 = vec3(0.636, 0.633, 0.069);\nconst vec3 C2 = vec3(1.508, 0.758, 0.951);\nconst vec3 D2 = vec3(4.307, 5.442, 2.733);\n\n// stripes are too thin\nconst vec3 A3 = vec3(.421, .116, .699);\nconst vec3 B3 = vec3(.001, .238, .050);\nconst vec3 C3 = vec3(.119, .888, 1.262);\nconst vec3 D3 = vec3(4.926, .433, 4.186);\n\n//thicker stripes\nconst vec3 A4 = vec3(-0.412, -0.202, -0.412);\nconst vec3 B4 = vec3(1.458, 1.122, 3.295);\nconst vec3 C4 = vec3(1.820, 1.820, 1.820);\nconst vec3 D4 = vec3(4.625, 2.557, 2.557);\n\nconst vec3 PINK = 1.2 * vec3(203.0/255.0, 49.0/255.0, 122.0/255.0);\nconst vec3 DARK_PURPLE = 1.2 * vec3(115.0/255.0, 49.0/255.0, 111.0/255.0);\nconst vec3 NAVY = vec3(13.0/255.0, 26.0/255.0, 60.0/255.0);\nconst vec3 BLACK = vec3(0.0);\nconst vec3 WHITE = vec3(1.0);\nconst vec3 TEAL = 1.2 * vec3(107.0/255.0, 192.0/255.0, 185.0/255.0);\nconst vec3 DARK_TEAL = 1.2 * vec3(54.0/256.0, 83.0/256.0, 78.0/256.0);\nconst vec3 ORANGE = 1.2 * vec3(233.0/255.0, 89.0/255.0, 55.0/255.0);\nconst vec3 DARK_ORANGE = .82 * vec3(184.0/255.0, 75.0/255.0, 44.0/255.0);\nconst vec3 RED = 1.2 * vec3(200.0/255.0, 28.0/255.0, 35.0/255.0);\nconst vec3 DARK_RED = 1.2 * vec3(54.0/255.0, 6.0/255.0, 4.0/255.0);\nconst vec3 GREEN = 1.2 * vec3(45.0/255.0, 121.0/255.0, 91.0/255.0);\nbool colorSet = false;\n\nvec3 K_d = vec3(-1, -1, -1); // diffuse color\nfloat shininess;\n\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat noise( in vec2 x )\n{\n\treturn sin(1.5*x.x)*sin(1.5*x.y);\n}\n\n\nfloat noise2(vec3 x)\n{\n        return fract(sin(dot(x.xy,\n                         vec2(12.9898,78.233)))\n                * 43758.5453123);\n}\n\nvec2 rot(vec2 r, float a) {\n\treturn vec2(\n\t\tcos(a) * r.x - sin(a) * r.y,\n\t\tsin(a) * r.x + cos(a) * r.y);\n}\n\n\n\n\n//https://github.com/BrianSharpe/GPU-Noise-Lib/blob/master/gpu_noise_lib.glsl\nvec4 FAST32_hash_3D_Cell( vec3 gridcell )\t//\tgenerates 4 different random numbers for the single given cell point\n{\n    //    gridcell is assumed to be an integer coordinate\n\n    //\tTODO: \tthese constants need tweaked to find the best possible noise.\n    //\t\t\tprobably requires some kind of brute force computational searching or something....\n    const vec2 OFFSET = vec2( 50.0, 161.0 );\n    const float DOMAIN = 69.0;\n    const vec4 SOMELARGEFLOATS = vec4( 635.298681, 682.357502, 668.926525, 588.255119 );\n    const vec4 ZINC = vec4( 48.500388, 65.294118, 63.934599, 63.279683 );\n\n    //\ttruncate the domain\n    gridcell.xyz = gridcell - floor(gridcell * ( 1.0 / DOMAIN )) * DOMAIN;\n    gridcell.xy += OFFSET.xy;\n    gridcell.xy *= gridcell.xy;\n    return fract( ( gridcell.x * gridcell.y ) * ( 1.0 / ( SOMELARGEFLOATS + gridcell.zzzz * ZINC ) ) );\n}\n\n//https://github.com/BrianSharpe/GPU-Noise-Lib/blob/master/gpu_noise_lib.glsl\nfloat Falloff_Xsq_C2( float xsq ) { xsq = 1.0 - xsq; return xsq*xsq*xsq; }\n\n//https://github.com/BrianSharpe/GPU-Noise-Lib/blob/master/gpu_noise_lib.glsl\nfloat PolkaDot3D( \tvec3 P,\n                    float radius_low,\t\t\n                    float radius_high\t)\n{\n    //\testablish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n\n    //\tcalculate the hash.\n    vec4 hash = FAST32_hash_3D_Cell( Pi );\n\n    //\tuser variables\n    float RADIUS = max( 0.0, radius_low + hash.w * ( radius_high - radius_low ) );\n    float VALUE = RADIUS / max( radius_high, radius_low );\t//\tnew keep value in proportion to radius.  Behaves better when used for bumpmapping, distortion and displacement\n\n    //\tcalc the noise and return\n    RADIUS = 2.0/RADIUS;\n    Pf *= RADIUS;\n    Pf -= ( RADIUS - 1.0 );\n    Pf += hash.xyz * ( RADIUS - 2.0 );\n    //Pf *= Pf;\t\t//\tthis gives us a cool box looking effect\n    return Falloff_Xsq_C2( min( dot( Pf, Pf ), 1.0 ) ) * VALUE;\n}\n\n\n/**\n * Rotation matrix around the X axis. https://www.shadertoy.com/view/4tcGDr\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n/**\n * Rotation matrix around the Y axis. https://www.shadertoy.com/view/4tcGDr\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Rotation matrix around the Z axis. https://www.shadertoy.com/view/4tcGDr\n */\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// modified from jamie wong\nvec3 scaleOp(vec3 samplePoint, vec3 scale)\n{\n\treturn (samplePoint / scale) * min(scale.x, min(scale.y, scale.z));\n}\n\n//JW\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n//JW\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n//JW\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n// iq\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//iq\nfloat smin2( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n\n// iq\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n//iq\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n// iq\nfloat cylinderSDF( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//http://glslsandbox.com/e#40928.0\nfloat saturate( float x )\n{\n    return clamp( x, 0.0, 1.0 );\n}\n\n\n// Based off: //http://glslsandbox.com/e#40928.0\n// Creates the main body of tentacle\nfloat noodle (vec3 p)\n{\n   \n    float scale = 1.0 - 2.5 * saturate( abs( p.y ) * 0.01 );  \n    \n    // sdCapsule, second argument defines lower end point, third is upper end point\n    // p is the point being evaluated, last argument is thickness\n    float cap = sdCapsule(p, vec3( 0.0, -6.0, 0.0 ), vec3( 0.0, 4.0, 0.0 ), 0.3 * scale );\n\t\n    // want more tapering at the end\n    float cone = sdCone(rotateX(-PI/2.0) * p + vec3(0.0, 0.0, -1.0), normalize(vec2(1.5, .30)));\n    //return cone;\n    return smin(cone, cap, -.5);\n}\n\nfloat suctionCup(vec3 p, float scale, int i, int tentacleID)\n{\n    \n    vec3 cp = rotateX(-PI/2.0) * p;\n    float outer = cylinderSDF(cp, vec2(1.0, .30) / scale);\n    float inner = cylinderSDF(cp, vec2(.25, .5) / ((.4) * scale));\n    \n    float mid = differenceSDF(outer, inner);\n    \n    if(mid < EPSILON) {\n        float currTent = mod(float(tentacleID), 4.0);\n        float currSC = mod(float(i), 2.0);\n       \n        if(currTent == 0.0)\n        {\n   \t\t\tif(currSC == 0.0 && !colorSet)\n    \t\t{ \n        \t\tK_d = PINK;\n        \t\tcolorSet = true;\n    \t\t} else if(currSC != 0.0 && !colorSet)\n    \t\t{\n        \t\tK_d = DARK_PURPLE;\n            \tcolorSet = true;\n    \t\t}\n        } else if (currTent == 1.0) {\n            if(currSC == 0.0 && !colorSet)\n    \t\t{ \n        \t\tK_d = TEAL;\n        \t\tcolorSet = true;\n    \t\t} else if(currSC != 0.0 && !colorSet)\n    \t\t{\n        \t\tK_d = DARK_TEAL;\n            \tcolorSet = true;\n    \t\t}\n        } else if (currTent == 2.0) {\n            if(currSC == 0.0 && !colorSet)\n    \t\t{ \n        \t\tK_d = RED;\n        \t\tcolorSet = true;\n    \t\t} else if(currSC != 0.0 && !colorSet)\n    \t\t{\n        \t\tK_d = DARK_RED;\n            \tcolorSet = true;\n    \t\t}\n        } else {\n            if(currSC == 0.0 && !colorSet)\n    \t\t{ \n        \t\tK_d = ORANGE;\n        \t\tcolorSet = true;\n    \t\t} else if(currSC != 0.0 && !colorSet)\n    \t\t{\n        \t\tK_d = DARK_ORANGE;\n            \tcolorSet = true;\n    \t\t}\n        }\n    }\n    \n    return mid;\n}\n\n\n\n\n//http://glslsandbox.com/e#40928.0\n// Creates the tentacle by calling noodle and placing suction cups along body of tentacle\nfloat Tentacle( vec3 p , int tentacleID)\n{\n    p.x -= sin( p.y * 2.0 + iTime * 7.0 ) * 0.21;\n    \n    float noodle = noodle(p); // The \"main body\" of the tentacle\n    if(noodle < EPSILON)\n    {\n        \n        float pt = PolkaDot3D(p, .0, .5);\n        if(pt < EPSILON)\n        {\n            K_d = BLACK;//vec3(pt, pt, pt);\n            colorSet = true;\n        } else {\n       \t\tK_d = NAVY;// vec3(0.0, 0.0, 0.0);// palette(sin(iTime), A, B, C, D);\n            colorSet = true;\n        }\n    } \n    \n    float scale = 150.0;\n    p += vec3(0.0, -.70, 0.0);\n    vec3 sc_p1 = p - vec3(0.01, 0.0, 0.03);\n    vec3 sc_p2 = p - vec3(-0.01, 0.0, 0.03);\n    \n    \n    sc_p1 = rotateY(PI/4.0) * sc_p1;\n    sc_p2 = rotateY(-PI/4.0) * sc_p2;\n    \n    vec3 init_sc_p1 = sc_p1;\n    vec3 init_sc_p2 = sc_p2;\n    float init_scale = scale;\n    \n    float sc1 = suctionCup(sc_p1, scale, 0, tentacleID);\n    float sc2 = suctionCup(sc_p2, scale, 0, tentacleID);\n    float sc = unionSDF(sc1, sc2);\n    \n    // first six suction cups: start small and scale bigger\n    // as they are placed from the tip towards the base\n    // also, rotate so that they lie \"on\" the surface of the tentacle\n    // alternate colors\n    for(int i = 0; i < 6; i++)\n    {\n        scale /= 1.45;\n        sc_p1 += vec3(-0.00005, .05 * float(i),float(i) * -0.0085);\n        sc_p2 += vec3(0.00005, .05 * float(i),float(i) * -0.0085);\n        sc1 = suctionCup(sc_p1, scale, i, tentacleID);\n        sc2 = suctionCup(sc_p2, scale, i, tentacleID);    \n        sc = unionSDF(sc, sc1);\n        sc = unionSDF(sc, sc2);\n     }\n  \n    \n    sc_p1 = rotateY(-PI/8.0) * sc_p1;\n    sc_p2 = rotateY(PI/8.0) * sc_p2;\n    \n    // Once close enough to the base, can be the same size and rotation\n    for(int j = 6; j < 15; j++)\n    {\n    \n        sc_p1 += vec3(0, .25 , -0.0179);\n        sc_p2 += vec3(0, .25 , -0.0179);\n        sc1 = suctionCup(sc_p1, scale, j, tentacleID);\n        sc2 = suctionCup(sc_p2, scale, j, tentacleID);\n        sc = unionSDF(sc, sc1);\n        sc = unionSDF(sc, sc2);\n    }\n    \n   \n    return smin(noodle, sc, .01);\n  \n}\n\n// modified from iq\nfloat opRep(vec3 p, int i)\n{\n    vec3 q = vec3(p.x + cos(iTime), p.y + sin(iTime), mod(p.z,9.0));\n\n    float scale = 1.0 - 2.5 * saturate( abs( q.y ) * 0.01 );  \n   \tfloat boundingCapsule = sdCapsule(q, vec3( 0.0, -6.0, 0.0 ), vec3( 0.0, 4.0, 0.0 ),  .50 * scale );\n    float tentacle; \n\n    if(boundingCapsule < .001)\n   \t{\n    \ttentacle = Tentacle(q, i);\n        \n    } else {\n        tentacle = boundingCapsule;\n   \t}\n\n    return tentacle;\n}\n\n\n// Creates the tunnel and maps the tentacles onto it\nfloat map( vec3 p){\n   \n    float tentacleRing = -1.0;\n    float amplitude = 1.9;\n    int numTentacles = 12;\n    float offSet = (noise(.75 * PI * p.xy)/2.0 * sin(3.0 * iTime));\n    float m = cos(p.x) + cos(p.y) + sin(p.z) + offSet;\n\n    if(m < EPSILON)\n    {\n\t        \n        vec3 colorPoint = vec3(cos(p.x) + offSet + p.x + sin(iTime), cos(p.y) + offSet + p.y + iTime, sin(p.z) + offSet + p.z + iTime);\n        float whitept = PolkaDot3D(mod(p, 3.0), .0, .50);\n        float blackInside = PolkaDot3D(mod(p, 3.0), .0, .4);\n        \n        \n        float greenpt = PolkaDot3D(p, .30, .35);\n        float blackInside2 = PolkaDot3D(p, .30, .15);\n\t\t\n        float ptOffY = PolkaDot3D(colorPoint + p, .0, .2);\n        float ptOffR = PolkaDot3D(mod(colorPoint, 25.0), .0, .2);\n       \n        vec3 redDotsOff = vec3(ptOffR, 0.0, 0.0);\n        vec3 yellowDotsOff = vec3(ptOffY, ptOffY, 0.0);\n        \n        \n       if(whitept > 0.0)\n        {\n            if(blackInside > 0.0)\n            {\n                K_d = BLACK;//vec3(-1.0);\n            } else {\n                K_d = WHITE;\n            }\n        }\n        else if(redDotsOff.x > 0.0)\n        {\n            K_d = RED;\n        }\n         else if(greenpt > 0.0)\n        {\n            if(blackInside2 > 0.0)\n            {\n                K_d = BLACK;//vec3(-1.0);\n            } else {\n                K_d =  ORANGE;\n            }\n        }\n        else if(yellowDotsOff.x > 0.0)\n        {\n            K_d = ORANGE;\n        } else {\n            vec3 c1 = .52 * palette( p.z, A4, B4, C4, D4);\n            vec3 c2 = .52 * palette( p.z , A3, B3, C3, D3);\n\n            K_d = mix(c1, c2, cos(iTime * 2.));\n            \n        }\n       \n    }\n    float gap = 360.0 / float(numTentacles) * deg2rad;\n    \n    for(int i = 0; i < numTentacles; i++)\n    {\n\n       \tfloat angle = float(i) * gap;     \n             \n        float offsetX = (amplitude) * sin(angle);\n    \tfloat offsetY = (amplitude) * cos(angle);\n        \n        vec3 localP = p;\n        localP += vec3(offsetX, offsetY, 0.0);\n        localP = rotateZ(-angle) * localP;\n        \n        \n        float tentacle = opRep(localP, i);\n        \n        if(tentacleRing == -1.0)\n        {\n            tentacleRing = tentacle;\n        }\n      \n        tentacle = unionSDF(tentacle, m); \n        tentacleRing = unionSDF(tentacle, tentacleRing);\n\n    }\n    \n    \n             \n    return tentacleRing;\n    \n}\n\n  \nfloat sceneSDF(vec3 samplePoint) {\n    \n    float sdf = map(samplePoint);\n     return sdf;\n\n  \n}\n\n\n/** JW\n * \n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/** JW\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/** JW\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON_NORM, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON_NORM, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON_NORM, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON_NORM, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON_NORM)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON_NORM))\n    ));\n}\n\n\nfloat lambert(vec3 N, vec3 L)\n{\n  vec3 nrmN = normalize(N);\n  vec3 nrmL = normalize(L);\n  float result = dot(nrmN, nrmL);\n  return max(result, 0.0);\n}\n\n\n/** JW\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n//iq\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayOri,   // camera position\n               in vec3  rayDir )  // camera to point vector\n{\n    float b = .1;\n    float c = .1;\n    float fogAmount = c * exp(-rayOri.y*b) * (1.0-exp( -distance*rayDir.y*b ))/rayDir.y;\n    vec3  fogColor  = mix(vec3(01.5,0.6,1.7), TEAL, sin(iTime));// mix(TEAL, vec3(01.5,0.6,1.7), sin(iTime));\n    return mix( rgb, fogColor, fogAmount );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 2.5 * iTime);\n      \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    \n    worldDir.xy = rot(worldDir.xy, (iTime));\n\n   \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(WHITE,1.0);//vec4(mix(vec3(01.5,0.6,1.7), TEAL, sin(iTime)),1.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n\n    \n    vec3 color = K_d * lambert(estimateNormal(p), eye);\n\n    vec3 color_fog = applyFog(color, dist, eye, worldDir);\n    \n    fragColor = vec4(color_fog, 1.0);\n\n    \n}","name":"Image","description":"","type":"image"}]}