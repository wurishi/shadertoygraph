{"ver":"0.1","info":{"id":"4lSBRG","date":"1516147422","viewed":2023,"name":"Ray-Marching in Voxel-Grid","username":"jt","description":"Experimenting with a combination of voxels and ray-marching to render a grid of different shapes specified by 3d-texture, e.g. in a computer-game.\nSee also [url=https://www.shadertoy.com/view/7lGfRD]primitives in voxels, refleced[/url].","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","raymarching","grid","voxel","hybrid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ray-Marching in Voxel-Grid, written 17.1.2018 by Jakob Thomsen.\n// (https://www.shadertoy.com/view/4lSBRG)\n// Experimenting with a combination of voxels and ray-marching\n// to render a grid of different shapes from a 3d-texture,\n// e.g. for visualization of computer-game levels.\n\n#define GRIDEPS 0.0001\n#define GRIDMAX 50\n\n#define MARCHEPS 0.001\n#define MARCHMAX 100\n#define MARCHDIST 1000.0\n\nfloat sphereSDF(vec3 p)\n{\n    return length(p) - 0.25;\n}\n\nvec3 sphereNRM(vec3 p)\n{\n    return normalize(p);\n}\n\nfloat cubeSDF(vec3 p)\n{\n    vec3 d = abs(p) - 0.25;\n    return min(max(d.x,max(d.y,d.z)), 0.0) + length(max(d, 0.0));\n}\n\nvec3 cubeNRM(vec3 p)\n{\n    vec3 q = abs(p);\n    // XXX HACK: normals flipped for better visibility XXX\n    return -((q.x > q.y && q.x > q.z) ? vec3(sign(p.x), 0.0, 0.0) : (q.y > q.z) ? vec3(0.0, sign(p.y), 0.0) : vec3(0.0, 0.0, sign(p.z)));\n}\n\nfloat scene(vec3 p)\n{\n    //return length(p) - 5.0; // sphere\n    vec2 q = vec2(length(p.xy) - 5.0, p.z); return length(q) - 4.0; // torus\n}\n\nvec4 raymarch(float end, vec3 pos, vec3 dir, float h)\n{\n    float total = 0.0;\n    for (int i = 0; i < MARCHMAX; i++)\n    {\n        vec3 current = pos + total * dir;\n        // NOTE: form must fit inside in 0..1 grid-cell!\n        current -= 0.5; // center in 0..1 cube\n        float dist = mix(sphereSDF(current), cubeSDF(current), h);\n        if (dist < MARCHEPS) // We're inside the scene surface!\n        {\n            vec3 n = mix(sphereNRM(current), cubeNRM(current), h);\n\n            return vec4(n * 0.5 + 0.5, 1.0);\n        }\n\n        // Move along the view ray\n        //total += dist; // XXX artifacts on cube-edges when using full step-size (possibly due to GRIDEPS?) XXX\n        total += 0.5 * dist; // XXX half step-size hides (or solves?) this XXX\n\n        if (total >= end) // Gone too far; give up\n        {\n            return vec4(0.0);\n        }\n    }\n\n    return vec4(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 ndc = 2.0 * uv - 1.0;\n    ndc.x *= float(iResolution.x) / float(iResolution.y);\n    float mx = 6.28 * float(iMouse.x) / float(iResolution.x);\n    float my = 2.0 * (1.0 - float(iMouse.y) / float(iResolution.y));\n    mx = (iMouse.x != 0.0) ? mx : 6.28 * fract(iTime * 0.1); // default-movement\n    my = (iMouse.y != 0.0) ? my : 2.0 * (0.5 + 0.5 * cos(iTime * 0.5)); // default-movement\n\n    mat2 R = mat2(vec2(cos(mx), sin(mx)), vec2(-sin(mx), cos(mx)));\n    vec3 start = vec3(0.0, 0.0, -10.0 * my);\n    start.xz = R * start.xz;\n    vec3 dir = vec3(0.5 * ndc.xy, 1.0);\n    dir.xz = R * dir.xz;\n\n    vec4 color = vec4(0.0);\n\n    float total = 0.0;\n    for (int i = 0; i < GRIDMAX; i++)\n    {\n        vec3 pos = start + dir * total;\n\n        // Snap ray to grid depending on ray-direction\n        vec3 D1 = (mix(floor(pos), ceil(pos), step(0.0, dir)) - pos) / dir; // forward\n        // Distance to nearest wall (forward)\n        float d1 = min(D1.x, min(D1.y, D1.z));\n\n        vec3 cell = floor(pos);\n        if(scene(cell) < 0.0)\n        {\n            float shape = step(0.5, texture(iChannel0, cell * 0.1)).r;\n            vec4 c = raymarch(d1, fract(pos), dir, shape);\n            color = mix(c, color, color.a);\n        }\n\n        // NOTE: if line-artifacts appear, try tweaking GRIDEPS:\n        //       axis-aligned lines through whole screen: GRIDEPS too big\n        //       lines on cube-faces in distance: GRIDEPS too small\n        // TODO: more robust solution which avoids epsilon.\n        total += d1 + GRIDEPS;\n    }\n\n    fragColor = color;\n}\n","name":"Image","description":"","type":"image"}]}