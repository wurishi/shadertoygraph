{"ver":"0.1","info":{"id":"DlyfzV","date":"1708800512","viewed":64,"name":"Fork OKLCH Sphere","username":"mehow_one","description":"OKLCH : https://bottosson.github.io/posts/colorpicker/","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","noise","swirl","curl","domainwarping"],"hasliked":0,"parentid":"DsKyRh","parentname":"3D Curly Noise"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define iterations 12\n#define flowintensity 0.5\n#define numOctaves 1\n#define flowoffset 7.0\n\n// PREVIEW SCENE FROM : https://www.shadertoy.com/view/XsXfRH - Inigo Quilez\n\nfloat hash(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return (fract((p3.x + p3.y) * p3.z));\n}\n\n\nvec4 noised( in vec3 x )\n{\n    vec3 i = vec3(floor(x));\n    vec3 w = fract(x);\n    \n    // cubic interpolation\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w); \n    \n    float a = hash(i+vec3(0,0,0));\n    float b = hash(i+vec3(1,0,0));\n    float c = hash(i+vec3(0,1,0));\n    float d = hash(i+vec3(1,1,0));\n    float e = hash(i+vec3(0,0,1));\n\tfloat f = hash(i+vec3(1,0,1));\n    float g = hash(i+vec3(0,1,1));\n    float h = hash(i+vec3(1,1,1));\n    \n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\nvec4 fbm( vec3 x )\n{    \n    float G = exp2(-1.);\n    float f = 1.0;\n    float a = 1.0;\n    vec4 t;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        t += a*noised(x * f);\n        f *= 2.07;\n        a *= G;\n    }\n    return t;\n}\n\n\n//@CollinInMySternum function to make swirly noise using fbm\nfloat curl(vec3 p, vec3 n)\n{\n    for(int i=0; i<iterations; i++)\n    {\n        vec3 x = p + flowoffset;\n        vec3 g = cross(fbm(x).yzw, n);\n        p -= (flowintensity / float(iterations)) * g;\n    }\n    \n    return (fbm(p).x + 1.0) / 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 2.5*cos(an), 1.0, 2.0*sin(an) );\n    vec3 ta = vec3( 0.0, 1.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.25*ww );\n    \n    // sphere center\t\n\tvec3 sc = vec3(0.0,1.0,0.0);\n\n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tfloat occ = 1.0;\n\tvec3  pos = vec3(0.0);\n\tvec3 ld = rd + vec3(0.,-.5,0.);\n\t// raytrace-plane for occlusion\n\tfloat h = (0.0-ro.y)/rd.y;\n\tif( h>0.0 ) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.0,1.0,0.0); \n\t\tpos = ro + h*rd;\n\t\tvec3 di = sc - pos;\n\t\tfloat l = length(di) * 1.0;\n\t\tocc = 1.0 - dot(nor,di/l)*1.0*1.0/(l*l); \n\t}\n\n\t// raytrace-sphere\n\tvec3  ce = ro - sc;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - 1.0;\n\th = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\th = -b - sqrt(h);\n\t\tif( h<tmin ) \n\t\t{ \n\t\t\ttmin=h; \n\t\t\tnor = normalize(ro+h*rd-sc); \n\t\t\t//occ = 0.5 + 0.5 * nor.y;\n\t\t}\n\t}\n\n    // shading/lighting\t\n    vec3 bn = normalize(nor);\n    float diffuse = max(dot(bn, -ld), 0.0);\n\tvec3 col = lch2rgb(vec3(0.8, rd.y,curl(rd,ro)));\n    \n    \n    \n    \n    if( tmin<80.0 )\n    {\n    pos = ro + tmin*rd;\n    \n    if (h == tmin) {\n        float f = curl(pos * 2.0 + iTime * 0.1, normalize(nor)); \n        float diffuse = max(dot(bn, -ld), 0.0);\n        f *= occ;\n        //col = vec3(f * 2.) * diffuse;\n        col = lch2rgb(vec3(diffuse,0.5,f));\n        } else {\n        col = vec3(col * occ);\n        }\n \n    }\n    \n    col = sqrt(col);\n\n\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265358979323846;\n\n//see link in description for the source of those transfer function\nfloat transfer(float v) {\n    return v <= 0.0031308 ?12.92 * v : 1.055 *pow(v, 0.4166666666666667) - 0.055;\n}\n\nvec3 transfer(vec3 v) {\n    return vec3(transfer(v.x), transfer(v.y), transfer(v.z));\n}\n\n// slightly rearranged vector components so it matches with LCH\nvec3 lch2rgb(vec3 lch) {\n    lch.y *= 0.33;\n    \n    vec3 lab = vec3(\n        lch.x,\n        lch.y * cos(lch.z * PI*2.0),\n        lch.y * sin(lch.z * PI*2.0)\n    );\n    \n    vec3 lms = vec3(\n        lab.x + 0.3963377774f * lab.y + 0.2158037573f * lab.z,\n        lab.x - 0.1055613458f * lab.y - 0.0638541728f * lab.z,\n        lab.x - 0.0894841775f * lab.y - 1.2914855480f * lab.z\n    );\n    \n    lms = pow(max(lms, vec3(0.0)), vec3(3.0));\n    \n    vec3 rgb = vec3(\n        +4.0767416621f * lms.x - 3.3077115913f * lms.y + 0.2309699292f * lms.z,\n        -1.2684380046f * lms.x + 2.6097574011f * lms.y - 0.3413193965f * lms.z,\n        -0.0041960863f * lms.x - 0.7034186147f * lms.y + 1.7076147010f * lms.z\n    );\n     \n    rgb = transfer(rgb);\n    return rgb;\n}","name":"Common","description":"","type":"common"}]}