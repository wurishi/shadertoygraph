{"ver":"0.1","info":{"id":"tlcXz8","date":"1580365786","viewed":178,"name":"Animated blob","username":"16807","description":"An animated blob composed of spherical harmonics. It undulates rhythmically. \nI took my earlier demo from [here](https://www.shadertoy.com/view/tlcSzr) and animated it. ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","animated","sphericalharmonics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define IN(T) in T\n#define INOUT(T) inout T\n#define OUT(T) out T\n#define CONST(T) const T\n#define VAR(T) T\n#define FUNC(T) T\n\n#define BIG 1e10\n#define PI 3.1415926\n\n\n\n/*\n\"get_distance_from_point_to_spherical_harmonics_blob\"\nreturns the signed distance of a point to the surface of \na blob formed from spherical harmonics. \n\nA0 point position\nB0 blob origin\nr  blob reference radius\n  the radius of a sphere where f00==1 and f1n1..f22 == 0\nf00..f22 blob expansion coefficients\n  the expansion coefficients to the spherical harmonics series\n  that describe the radius of a blob at a given set of lat long coordinates\n*/\nfloat get_distance_of_3d_point_to_spherical_harmonics_blob(\n    in vec3 A0,\n    in vec3 B0,\n    in float r0,\n\n    in float f00,\n\n    in float f1n1,\n    in float f10,\n    in float f11,\n\n    in float f2n2,\n    in float f2n1,\n    in float f20,\n    in float f21,\n    in float f22,\n\n    in float f3n3,\n    in float f3n2,\n    in float f3n1,\n    in float f30,\n    in float f31,\n    in float f32,\n    in float f33\n){\n    vec3 D = A0-B0; // offset\n    vec3 Dhat = normalize(D);\n\n    float x = Dhat.x;\n    float y = Dhat.y;\n    float z = Dhat.z;\n\n    float x2 = x*x;\n    float y2 = y*y;\n    float z2 = z*z;\n\n    float xy = x*y;\n    float yz = y*z;\n    float zx = z*x;\n\n    float xyz = x*y*z;\n\n    float r = 1.f;//length(D);\n    float r2 = r*r;\n    float r3 = r*r*r;\n\n    float fijYij = \n          f00  * 0.5f*sqrt(1.f/PI)  \n\n        + f1n1 * sqrt(0.75f/PI) * y/r  \n        + f10  * sqrt(0.75f/PI) * z/r  \n        + f11  * sqrt(0.75f/PI) * x/r \n\n        + f2n2 * 0.50f*sqrt(15.f/PI) *  xy/r2 \n        + f2n1 * 0.50f*sqrt(15.f/PI) *  yz/r2 \n        + f20  * 0.25f*sqrt(5.0f/PI) * (-x2-y2+2.f*z2)/r2 \n        + f21  * 0.50f*sqrt(15.f/PI) *  zx/r2 \n        + f22  * 0.25f*sqrt(15.f/PI) * (x2-y2)/r2  \n\n        + f3n3 * 0.25f*sqrt(35.0f/(2.f*PI)) * (3.f*x2-y2)*y/r3\n        + f3n2 * 0.50f*sqrt(105.f/     PI)  * (xyz)/r3\n        + f3n1 * 0.25f*sqrt(21.0f/(2.f*PI)) * (y*(4.f*z2-x2-y2))/r3\n        + f30  * 0.25f*sqrt(7.00f/     PI)  * (z*(2.f*z2-3.f*x2-3.f*y2))/r3\n        + f31  * 0.25f*sqrt(21.0f/(2.f*PI)) * (x*(4.f*z2-x2-y2))/r3\n        + f32  * 0.25f*sqrt(105.f/     PI)  * (z*(x2-y2))/r3\n        + f33  * 0.25f*sqrt(35.0f/(2.f*PI)) * (x*(x2-3.f*y2))/r3\n      ;\n\n    return length(D) - (r0*fijYij); \n}\n\n\n\n\nmat4 get_rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat4  projection_matrix_inverse = (mat4(0.5,0,0,0,0,0.3,0,0,0,0,0,-50,0,0,-1,50));\n    mat4  view_matrix_inverse = (get_rotation_matrix(vec3(0,1,0), 0.3+ iMouse.x * -0.01 + 0.3*iTime) * mat4(0.707, 0, 0.707, 0, 0.235, 0.942, -0.235, 0, -0.666, 0.333, 0.666, 0, -4, 2, 4, 1));\n    float reference_distance = 0.5f;//6.367e6;\n    \n    vec2  screenspace    = fragCoord/iResolution.xy;\n    vec2  clipspace      = 2.0 * screenspace - 1.0;\n    vec3  view_direction = normalize(view_matrix_inverse * projection_matrix_inverse * vec4(clipspace, 1, 1)).xyz;\n    vec3  view_origin    = view_matrix_inverse[3].xyz * reference_distance;\n    \n    float r = 0.5f*sqrt(1.f/PI);\n    \n    vec3 A0 = view_origin;\n    vec3 A = view_direction;\n    vec3 At = A0;\n    \n    float t = 0.f;\n    float sdf = 0.f;\n    const int MAX_STEP_COUNT = 10;\n    const float MIN_SDF = 0.01;\n    const float MAX_T = 10.f;\n    \n    int i;\n    for ( i = 0; i< MAX_STEP_COUNT; i++)\n    {\n        sdf = get_distance_of_3d_point_to_spherical_harmonics_blob(\n            \tAt, vec3(0,0,0), 1.0f,\n            \n                                 1.0f,\n                           0.0f, 0.3f*cos(1.2*iTime), 0.0f,\n                      0.0f, 0.0f, 0.0f, 0.0f, 0.0f,\n                0.0f, 0.2f*cos(0.5*iTime), 0.0f, 0.1f*cos(0.4*iTime), 0.0f, 0.0f, 0.1f\n        \t);\n        if ( sdf < MIN_SDF || t > MAX_T) break;\n        t += sdf;\n        At += A*sdf;\n    }\n    \n    vec3  color = sdf < MIN_SDF && t < MAX_T? \n        vec3(r-length(At), length(At)-r, r-length(At)+0.1) * 30.f + vec3(0.01) : \n        vec3(0);\n    \n    fragColor = vec4(color/4.f, 1.0);\n}","name":"Image","description":"","type":"image"}]}