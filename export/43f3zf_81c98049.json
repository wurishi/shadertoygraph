{"ver":"0.1","info":{"id":"43f3zf","date":"1707762930","viewed":106,"name":"Lissajous Curves - Distance","username":"nr4","description":"Distance to the specific Lissajous curves with frequency ratio 1:2, 1:3 and 2:3\nThis uses iq's distance visualization code.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","approximation","distance","quartic","lissajous","quintic","signed"],"hasliked":0,"parentid":"mttyzB","parentname":"Archimedean Spiral - Distance"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Distance to the specific Lissajous curves with frequency ratio 1:2, 1:3 and 2:3\n * Copyright (C) 2024 Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nconst vec3 c = vec3(1,0,-1);\nconst float pi = 3.14159;\n\n// Determine zeros of k.x*x^2+k.y*x+k.z\nvec2 quadratic_zeros(vec3 k)\n{\n    if(k.x == 0.) return -k.z/k.y*c.xx;\n    float d = k.y*k.y-4.*k.x*k.z;\n    if(d<0.) return vec2(1.e4);\n    return (c.xz*sqrt(d)-k.y)/(2.*k.x);\n}\n\n// Determine zeros of k.x*x^3+k.y*x^2+k.z*x+k.w\nvec3 cubic_zeros(vec4 k)\n{\n    if(k.x == 0.) return quadratic_zeros(k.yzw).xyy;\n    \n    // Depress\n    vec3 ai = k.yzw/k.x;\n    \n    //discriminant and helpers\n    float tau = ai.x/3., \n        p = ai.y-tau*ai.x, \n        q = -tau*(tau*tau+p)+ai.z, \n        dis = q*q/4.+p*p*p/27.;\n        \n    //triple real root\n    if(dis > 0.) {\n        vec2 ki = -.5*q*c.xx+sqrt(dis)*c.xz, \n            ui = sign(ki)*pow(abs(ki), c.xx/3.);\n        return vec3(ui.x+ui.y-tau);\n    }\n    \n    //three distinct real roots\n    float fac = sqrt(-4./3.*p), \n        arg = acos(-.5*q*sqrt(-27./p/p/p))/3.;\n    return c.zxz*fac*cos(arg*c.xxx+c*pi/3.)-tau;\n}\n\n// Determine zeros of a*x^4+b*x^3+c*x^2+d*x+e\nvec4 quartic_zeros(float a, float b, float cc, float d, float e) {\n    if(a == 0.) return cubic_zeros(vec4(b, cc, d, e)).xyzz;\n    \n    if(b == 0. && d == 0.) {\n        vec2 ta = quadratic_zeros(vec3(a, cc, e));\n        return vec4(sqrt(ta), -sqrt(ta));\n    }\n    \n    // Depress\n    float _b = b/a,\n        _c = cc/a,\n        _d = d/a,\n        _e = e/a;\n        \n    // Helpers\n    float p = (8.*_c-3.*_b*_b)/8.,\n        q = (_b*_b*_b-4.*_b*_c+8.*_d)/8.,\n        r = (-3.*_b*_b*_b*_b+256.*_e-64.*_b*_d+16.*_b*_b*_c)/256.;\n        \n    // Determine available resolvent zeros\n    vec3 res = cubic_zeros(vec4(8.,8.*p,2.*p*p-8.*r,-q*q));\n    \n    // Find nonzero resolvent zero\n    float m = res.x;\n    if(m == 0.) m = res.y;\n    if(m == 0.) m = res.z;\n    \n    // Apply newton iteration to fix numerical artifacts;\n    // Credit goes to NinjaKoala / epoqe :)\n    for(int i=0; i < 2; i++) {\n        float a_2 = p + m;\n        float a_1 = p*p/4.-r + m * a_2;\n        float b_2 = a_2 + m;\n\n        float f = -q*q/8. + m * a_1;\n        float f1 = a_1 + m * b_2;\n\n        m -= f / f1; // Newton iteration step\n    }\n    \n    // Apply Ferrari method\n    return vec4(\n        quadratic_zeros(vec3(1.,sqrt(2.*m),p/2.+m-q/(2.*sqrt(2.*m)))),\n        quadratic_zeros(vec3(1.,-sqrt(2.*m),p/2.+m+q/(2.*sqrt(2.*m))))\n    )-_b/4.;\n}\n\nvec2 xlissajous1_2(float t) {\n    return vec2(cos(t), cos(2. * t));\n}\n\nfloat dlissajous1_2(vec2 x) {\n    // f1:f2: 1:2\n    vec3 t = acos(clamp(cubic_zeros(vec4(\n        8.,\n        0.,\n        -4. * x.y - 3.,\n        -x.x\n    )), -1., 1.));\n        \n    return min(\n        min(\n            length(x - xlissajous1_2(t.x)),\n            length(x - xlissajous1_2(t.y))\n        ),\n        length(x - xlissajous1_2(t.z))\n    );\n}\n\nvec2 xlissajous2_3(float t) {\n    return vec2(cos(2. * t), cos(3. * t));\n}\n\nvec2 nlissajous2_3(float t) {\n    return -vec2(2. * sin(2. * t), 3. * sin(3. * t));\n}\n\nfloat dlissajous2_3prime(vec2 x, float t) {\n    return dot(x - xlissajous2_3(t), nlissajous2_3(t));\n}\n\nfloat dlissajous2_3(vec2 x) {\n    x.y = abs(x.y);\n\n    // Use interval approximation to determine a numerical solution for the quintic.\n    // TODO: find something better, I really would like an analytical approach\n        float sa = 2.*pi/3.;\n    float e = step(-.5, x.x) + step(.5, x.x);\n    float tmin = sa * e,\n        tmax = sa * (2. + e),\n        //tmin = 0.,\n        //tmax = .5 * pi + .5 * pi * step(x.x, .5),\n        tnew, \n        dmin = dlissajous2_3prime(x,tmin),\n        dmax = dlissajous2_3prime(x,tmax),\n        dnew;\n    \n    for(int i=0; i<20; ++i)\n    {\n        tnew = mix(tmin, tmax, .5);\n        dnew = dlissajous2_3prime(x,tnew);\n        \n        if(dnew>0.)\n        {\n            tmin = tnew;\n            dmin = dnew;\n        }\n        else \n        {\n            tmax = tnew;\n            dmax = dnew;\n        }\n    }\n    \n    float a5 = 48.;\n    float a4 = 0.;\n    float a3 = -40.;\n    float a2 = -12. * x.y;\n    float a1 = 5. - 4. * x.x;\n    float a0 = 3. * x.y;\n    \n    // Polynomial division of numerical solution.\n    float _a = a5,\n        _b = a4+_a*tmin,\n        _c = a3+_b*tmin,\n        _d = a2+_c*tmin,\n        _e = a1+_d*tmin;\n        \n    vec4 t = clamp(quartic_zeros(_a,_b,_c,_d,_e), 0., 2. * pi);\n    tmin = clamp(tmin, 0., 2. * pi);\n    \n    return min(\n        length(x-xlissajous2_3(tmin)),\n        min(\n            min(\n                length(x-xlissajous2_3(t.x)),\n                length(x-xlissajous2_3(t.y))\n            ),\n            min(\n                length(x-xlissajous2_3(t.z)),\n                length(x-xlissajous2_3(t.w))\n            )\n        )\n    );\n}\n\nvec2 xlissajous1_3(float t) {\n    return vec2(cos(1. * t), cos(3. * t));\n}\n\nvec2 nlissajous1_3(float t) {\n    return -vec2(1. * sin(1. * t), 3. * sin(3. * t));\n}\n\nfloat dlissajous1_3prime(vec2 x, float t) {\n    return dot(x - xlissajous1_3(t), nlissajous1_3(t));\n}\n\nfloat dlissajous1_3(vec2 x) {\n\n    // Use interval approximation to determine a numerical solution for the quintic.\n    // TODO: find something better, I really would like an analytical approach\n    float sa = 2.*pi/3.;\n    float e = step(-.5, x.x) + step(.5, x.x);\n    float tmin = sa * e,\n        tmax = sa * (2. + e),\n        //tmin = (.5 - .5*step(x.x,-.5))*step(x.x,.5),\n        //tmax = .5 * pi + .5 * pi * step(x.x, .5) +.5 * pi * step(x.x, -.5),\n        tnew, \n        dmin = dlissajous1_3prime(x,tmin),\n        dmax = dlissajous1_3prime(x,tmax),\n        dnew;\n    \n    for(int i=0; i<20; ++i)\n    {\n        tnew = mix(tmin, tmax, .5);\n        dnew = dlissajous1_3prime(x,tnew);\n        \n        if(dnew>0.)\n        {\n            tmin = tnew;\n            dmin = dnew;\n        }\n        else \n        {\n            tmax = tnew;\n            dmax = dnew;\n        }\n    }\n    \n    float a5 = -48.;\n    float a4 = 0.;\n    float a3 = -48.;\n    float a2 = -12. * x.y;\n    float a1 = 10.;\n    float a0 = 3. * x.y - x.x;\n    \n    // Polynomial division of numerical solution.\n    float _a = a5,\n        _b = a4+_a*tmin,\n        _c = a3+_b*tmin,\n        _d = a2+_c*tmin,\n        _e = a1+_d*tmin;\n        \n    vec4 t = clamp(quartic_zeros(_a,_b,_c,_d,_e), 0., 2. * pi);\n    tmin = clamp(tmin, 0., 2. * pi);\n    \n    return min(\n        length(x-xlissajous1_3(tmin)),\n        min(\n            min(\n                length(x-xlissajous1_3(t.x)),\n                length(x-xlissajous1_3(t.y))\n            ),\n            min(\n                length(x-xlissajous1_3(t.z)),\n                length(x-xlissajous1_3(t.w))\n            )\n        )\n    );\n}\n\nfloat scene(vec2 uv) {\n    int index = int(floor(iTime)) % 3;\n    if(index == 0)\n        return dlissajous2_3(uv);\n    else if(index == 1)\n        return dlissajous1_3(uv);\n    else if(index == 2)\n        return dlissajous1_2(uv);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float scale = 3.;\n    vec2 uv = scale * (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec2 mouse = scale * (iMouse.xy - .5 * iResolution.xy) / iResolution.y;\n    float px = 1.0 / iResolution.y;\n    float d = scene(uv)/scale;\n    vec3 col = (d > 0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65, 0.85, 1.0);\n\tcol *= 1.0 - exp2(-12.0 * abs(d));\n\tcol *= 0.7 + 0.2 * cos(150.0 * d);\n\tcol = mix( col, vec3(1.0), 1.0 - smoothstep(0.0, 3.0 * px, abs(d)));\n    d = scene(mouse);\n    float l = length(uv - mouse);\n    col = mix(col, vec3(1.0, 1.0, 1.0), 1.0 - smoothstep(0.0, 2.0 * px, abs(l - abs(d))-.001 * scale));\n    col = mix(col, vec3(1.0, 1.0, 1.0), 1.0 - smoothstep(0.0, 2.0 * px, l - px*3.0));\n\tfragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}