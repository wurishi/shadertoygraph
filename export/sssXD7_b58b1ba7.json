{"ver":"0.1","info":{"id":"sssXD7","date":"1618843751","viewed":206,"name":"Magic cube with fireball","username":"Naduha","description":"Работа выполнена Малышевой Надеждой \n320 группа ","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["cube","glass","fireball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv) / float(iFrame + 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const vec3 CAMERA_POS = vec3(2.5, 2.0, -9);\nconst float INF = 1e10;\nconst int COUNT_LIGHT = 4;\nconst float TRANSP   = 0.6; \n\nvec3 randDir;\n\n//Camera\n    \nstruct Camera\n{\n    vec3 front;\n    vec3 up;\n    vec3 right;\n    //vec3 viewVec;\n};\n\nCamera get_Camera (vec3 camera_pos)\n{\n    vec3 front = normalize(-camera_pos); // normalize( (0, 0, 0) - camera_pos )\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    //up = normalize(cross(right, front));\n    return Camera(front, up, right);\n}\n\nvec3 get_ViewVec(Camera c, vec2 uv)\n{\n    return normalize(c.front + c.up * uv.y + c.right * uv.x);\n}\n\n//Material \n\nconst int EMISSION = 0;\nconst int DIFFUSE = 1;\nconst int REFLECTION = 2;\nconst int REFRACTION = 3;\n\n\n\n//Object\n\nstruct Plane\n{\n    int coord;\n    float r;\n    vec3 center;\n    //int material;\n    //vec4 Texture; \n};\n\n// (CAMERA_POS + t * viewVec).y == -y\n// t = (-y - CAMERA_POS.y) / viewVec.y;\nfloat tracePlane(vec3 pos, vec3 dir, out vec3 normal, Plane p) \n{\n     \n    float t = (p.center[p.coord] - pos[p.coord]) / dir[p.coord];\n    if (t <= 0.0) {\n        return INF;\n    }\n    \n    int x = (p.coord != 0) ? 0 : 1;\n    int z = (p.coord != 2) ? 2 : 1;\n     \n    vec3 worldPos = t * dir + pos;\n    if ((abs(worldPos[x]) > p.r) || (abs(worldPos[z]) > p.r) )\n    {\n        return INF;\n    }\n    normal = vec3(0.0);\n    normal[p.coord] = 1.0 * float((p.center[p.coord] > 0.0) ? -1 : 1);\n    //float((p.y < 0.0) ? -1 : 1);\n    return t;\n}\n\n\nstruct Cube\n{\n    vec3 center;\n    float size;\n    Plane side[6];\n};\n\n\nCube InitCube(vec3 center, float size)\n{\n    Plane side[6];\n    for (int i = 0; i < 6; i++)\n    {\n        int signx = ( i % 2 == 0 ) ? 1 : -1;\n        vec3 offset = vec3(0);\n        offset[i/2] = size * float(signx);\n        side[i] = Plane(i/2, size, center + offset);\n    }\n    return Cube(center, size, side);\n}\n\nfloat traceCube(vec3 pos, vec3 dir, out vec3 normal, Cube cube)\n{\n    \n    float t = INF;\n    for (int i = 0; i < 6; i++)\n    {\n        vec3 planeNorm;\n        float planeT = tracePlane(pos, dir, planeNorm, cube.side[i]);  //floor\n        if (planeT < t) \n        {\n            t = planeT;\n            normal = planeNorm;\n        }\n    }\n    \n    vec3 a = cube.center - pos;\n    if ((abs(a.x) < cube.size)&&(abs(a.y) < cube.size)&&(abs(a.z) < cube.size))\n    {\n        normal = normal * (-1.0);\n    }\n    return t;\n}\n\n\n\nfloat hash(float n) {\n    float x = sin(n)*43758.5453f;\n    return x-floor(x);\n}\n\nfloat noise(vec3 x) \n{\n    vec3 p = vec3(floor(x.x), floor(x.y), floor(x.z));\n    vec3 f = vec3(x.x-p.x, x.y-p.y, x.z-p.z);\n    f = f*(f*(vec3(3., 3.f, 3.)-f*2.));\n    float n = dot(p, vec3(1., 57., 113.));\n    return mix(mix(\n                     mix(hash(n +  0.), hash(n +  1.), f.x),\n                     mix(hash(n + 57.), hash(n + 58.), f.x), f.y),\n                mix(\n                    mix(hash(n + 113.), hash(n + 114.), f.x),\n                    mix(hash(n + 170.), hash(n + 171.), f.x), f.y), f.z);\n}\n\nvec3 rotate(vec3 v) \n{\n    return vec3(dot(vec3(0.00,  0.80,  0.60), v), dot(vec3(-0.80,  0.36, -0.48), v), dot(vec3(-0.60, -0.48,  0.64), v));\n}\n\nfloat fractal_brownian_motion(const vec3 x) {\n    vec3 p = rotate(x);\n    float f = 0.;\n    f += 0.5000*noise(p); p = p*(2.32);\n    f += 0.2500*noise(p); p = p*(3.03+1.);\n    f += 0.1550*noise(p); p = p*(2.61+1.);\n    f += 0.0725*noise(p);\n    return f/0.9375;\n}\n\n\nvec3 palette_fire(float d) \n{\n    const vec3   yellow = vec3(1.7, 1.3, 1.0); \n    const vec3   orange = vec3(1.0, 0.6, 0.0);\n    const vec3      red = vec3(1.0, 0.0, 0.0);\n    const vec3 darkgray = vec3(0.1, 0.1, 0.1);\n    const vec3     gray = vec3(0.4, 0.4, 0.4);\n\n    float x = max(0.f, d);\n    if (x<.8f)\n        return mix(gray, darkgray, x*4.f -0.5);\n    else if (x<1.f)\n        return mix(darkgray, red, x*4.f-3.f);\n    else if (x<2.f)\n        return mix(red,  mix(darkgray, orange, x*4.f-3.f), x*4.f-4.f);\n    return mix(orange, yellow, x*4.f-5.f);\n    /*float x = max(0.f, min(1.f, d));\n    if (x<.5f)\n        return red;\n    else if (x<.7f)\n        return gray;\n    else if (x<0.9f)\n        return yellow;\n    return orange;*/\n}\n\n\nfloat traceSphere(vec3 pos, vec3 dir, float r, out vec3 normal, float flag) {\n    // dot(pos + t * dir, pos + t * dir) == r * r;\n    // dot(pos, pos) + 2 * t * dot(pos, dir) + t * t * dot(dir, dir) == r * r\n    // t * t + 2.0 * t * dot(pos, dir) + dot(pos, pos) - r * r == 0\n    float dis = flag * 1.2 * (fractal_brownian_motion(pos) );/* + 0.001   *(sin(16. * pos.x) \n                                                                   * sin(16. * pos.y)\n                                                                   * sin(16. * pos.z)));*/\n    float a = dot(dir, dir);\n    float b = dot(pos, dir);\n    float c = dot(pos, pos) - (r + dis) * (r + dis);\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    float t = -b - sqrt(D);\n    if (t > 0.0) {\n        normal = normalize(pos + t * dir);\n        return t;\n    }\n    t = -b + sqrt(D);\n    if (t < 0.0) {\n        return INF;\n    }\n    normal = normalize(pos + t * dir);\n    return t;\n}\n\n\nfloat traceCylinder(vec3 pos, vec3 dir, out vec3 normal) {\n    float t = (-1.0  - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) < 0.5) {\n        normal = vec3(0, 1, 0);\n        return t;\n    }\n    \n    // dot(pos + t * dir, pos + t * dir) == r * r;\n    // dot(pos, pos) + 2 * t * dot(pos, dir) + t * t * dot(dir, dir) == r * r\n    // t * t + 2.0 * t * dot(pos, dir) + dot(pos, pos) - r * r == 0\n    float a = dot(dir.xz, dir.xz);\n    float b = dot(pos.xz, dir.xz);\n    float c = dot(pos.xz, pos.xz) - 0.5;\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    t = (-b - sqrt(D)) / a;\n    if (t > 0.0) {\n        worldPos = t * dir + pos;\n        if (worldPos.y <= -1.0) {\n            normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n            return t;\n        }\n    }\n    t = (-b + sqrt(D)) / a;\n    if (t < 0.0) {\n        return INF;\n    }\n    worldPos = t * dir + pos;\n    if (worldPos.y <= -1.0) {\n        normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n        return t;\n    }\n    return INF;\n}\n\nbool in_cube(vec3 pos)\n{\n    if ((abs(pos.x) < 1.0) && (abs(pos.y) < 1.0) && (abs(pos.z) < 1.0))\n        return true;\n    return false;\n}\n\nbool isOccluded(vec3 pos, vec3 target, Cube cube) {\n    vec3 dir = target - pos;\n    float dist = length(dir);\n    dir /= dist;\n    \n    vec3 cubeNorm;\n    float cubeT = traceCube(pos, dir, cubeNorm, cube);\n    if ((cubeT < dist) && (!in_cube(pos+target)))//dot(dir, cubeNorm) < 0.0))\n        return true;\n    vec3 cylNorm;\n    float cylT = traceCylinder(pos, dir, cylNorm);\n    return (cylT < dist);\n}\n\n//Light \nstruct Light\n{\n    vec3 pos;\n    float radius;\n    vec3 color;\n    float brightness;\n};\n\nvec3 computeLight(vec3 pos, vec3 color, vec3 normal, Light light[COUNT_LIGHT], Cube cube) \n{\n    \n    vec3 summ = vec3(0, 0, 0);\n    \n    for (int i = 0; i < COUNT_LIGHT; i++)\n    {\n        vec3 toLight = light[i].pos - pos;\n        float distSq = dot(toLight, toLight);\n        float att =  isOccluded(pos, light[i].pos + randDir * light[i].radius, cube) ? 0.0 : light[i].brightness / distSq; //isOccluded(pos, light[i].pos + randDir * light[i].radius, cube) ? 0.0 :\n        summ = summ + max(0.0, dot(normal, normalize(toLight))) * att * light[i].color;\n    }\n    \n    return color * (summ  + texture(iChannel1, normal).rgb * 0.3);\n    \n}\n\nvec3 refraction(vec3 v, vec3 normal, float n1, float n2) {\n    if (dot(v, normal) < 0.0) {\n        normal = -normal;\n    }\n    float cosA = dot(v, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 tang = normalize(v - cosA * normal);\n    float sinB = sinA / n2 * n1;\n    if (sinB >= 1.0)\n    {\n        return vec3(1000.0);\n    }\n    float cosB = sqrt(1.0 - sinB * sinB);\n    return sinB * tang + cosB * normal;\n}\n\n\nfloat pow2(float x) {\n    return x * x;\n}\n\n\nfloat rand(float frame)\n{\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\n\nvec3 radiance (vec2 p) \n{\n\tfloat color1 = 4.0 - (2.0 * length(2.5 * p));\n\tvec3 coord = vec3(atan(p.x, p.y) / 6.2832 + 0.5, length(p) * 0.4, 0.5);\n\tfor(int i = 1; i <= 3; i++)\n\t{\n\t\tfloat power = pow(2.0, float(i));\n\t\tcolor1 += 0.5*(1.5 / power) * 0.1;\n\t}\n\tcolor1 *= 0.5;\n\treturn vec3( color1, pow(max(color1, 0.0), 2.0)*0.4, pow(max(color1, 0.0), 3.0) * 0.15);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 randVec = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    randDir = normalize(randVec - 0.5);\n    Camera camera = get_Camera(CAMERA_POS); \n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (randVec.xy - 0.5) * 2.0) / iResolution.x;\n    vec3 viewVec = get_ViewVec(camera, uv);\n    \n    Light light[COUNT_LIGHT];\n    light[0] = Light(vec3(-3, 2, 1)+ randVec * 0.1, 0.25, vec3(0.0, 1.0, 1.0), 20.0f);\n    light[1] = Light(vec3(3, 0, 2) + randVec * 0.4, 0.75, vec3(1.0, 0.0, 1.0), 5.0f);\n    light[2] = Light(vec3(0, 0, 5) + randVec * 0.2, 0.5, vec3(1.0, 1.0, 1.0), 5.0f);\n    light[3] = Light(vec3(-0.5, -0.5, -0.5) + randVec * 1.1, 0.45, vec3(1.0, 0.7, 0.5), 100.0f);\n        \n    \n    Plane plane = Plane(1, 10.0, vec3(0, -1.5, 0));//, DIFFUSE);\n    Cube cube = InitCube(vec3(0, 0, 0), 1.0);\n    \n    vec3 curPos = vec3(CAMERA_POS);\n    vec3 curDir = viewVec;\n    vec3 colorMult = vec3(1, 1, 1);\n    \n    const float GLASS_N = 1.5;\n    const float AIR_N = 1.0;\n    float n1 = AIR_N;\n    float GLASS_R = pow2(AIR_N - GLASS_N) / pow2(AIR_N + GLASS_N);\n    float alfa = 1.0;\n\n    vec4 col_buf = vec4(0.0);\n\n    float n2 = GLASS_N;\n    float mult = 1.0;\n\n    for(int i; i < 10; i++)\n    {\n        float t = INF;\n        int materialType;\n        vec3 color;\n        vec3 normal;\n        \n        vec3 planeNorm;\n        float planeT = tracePlane(curPos, curDir, planeNorm, plane);  //floor\n        alfa = 1.0;\n        if ((planeT < t) && (randVec.y < alfa)) \n        {\n            t = planeT;\n            if (randVec.y < 0.8)\n            {\n                materialType = DIFFUSE;\n            }\n            else \n            {\n                materialType = REFLECTION;\n            }\n            vec3 worldPos = t * curDir + curPos;\n            color = texture(iChannel0, worldPos.xz * 0.1).rgb;\n            normal = planeNorm;\n        }\n        \n        for (int i = 0; i < COUNT_LIGHT-1; i++)\n        {\n            vec3 l1Norm;\n            float light1T = traceSphere(curPos - light[i].pos, curDir, light[i].radius, l1Norm, 0.0);\n            alfa = 1.0;\n            if ((light1T < t) && (randVec.y < alfa)) \n            {\n                t = light1T;\n                if (i == 3)\n                {\n                    materialType = EMISSION;\n                }\n                else\n                {\n                    materialType = EMISSION;\n                }\n                color = light[i].color;\n                normal = l1Norm;\n            }\n        }\n               \n        \n        vec3 cubeNorm;\n        alfa = 1.0;\n        float cubeT = traceCube(curPos, curDir, cubeNorm, cube);\n        if ((cubeT < t) && (randVec.y < alfa))\n        {\n            t = cubeT;\n            normal = cubeNorm;\n            if (randVec.x >= GLASS_R)\n            {\n                //colorMult = vec3(1, 0.8, 0.5);\n                materialType = REFRACTION;\n                \n            }\n            else\n            {\n                materialType = REFLECTION;\n            }\n            mult = 0.5;\n        }\n        \n        vec3 cylNorm;\n        alfa = 1.0;\n        float cylT = traceCylinder(curPos, curDir, cylNorm);\n        if ((cylT < t) && (randVec.y < alfa))\n        {\n            t = cylT;\n            materialType = DIFFUSE;\n            vec3 worldPos = t * curDir + curPos;\n            color = texture(iChannel0, worldPos.xz * worldPos.y).rgb;\n            normal = cylNorm;\n            if (randVec.y < 0.8)\n            {\n                materialType = DIFFUSE;\n            }\n            else \n            {\n                materialType = REFLECTION;\n            }\n            \n        }\n        \n        if (randVec.x < TRANSP)\n        {\n            vec3 sphNorm;\n            alfa = 1.0; \n            float sph2T = traceSphere(curPos, curDir, 0.2, sphNorm, 1.0);  //в нуле \n            vec3 worldPos = sph2T * curDir + curPos;\n            alfa = (1.0 - length(worldPos.xy))*2.; \n            if ((sph2T < t) && (randVec.y < alfa))\n            {\n                t = sph2T;\n                normal = sphNorm;\n                            \n                \n                vec2 p = (fragCoord.xy / iResolution.xy) - 0.5;\n                p.x *= iResolution.x / iResolution.y;\n                vec3 fo = radiance(p);\n                col_buf += vec4(mix(vec3(0.02, 0.01, 0.01), fo * vec3(0.7, 0.5, 0.5), 0.7), 0.8) * 0.57;//vec3(fo * vec3(0.7, 0.5, 0.5));\n                \n                float noise_amplitude = 1.0;\n                float noise_level = (0.5/dot(worldPos,worldPos))/noise_amplitude;\n                color = (palette_fire(noise_level)) + vec3(0.6, 0.1, 0.1);//texture(iChannel3, worldPos).rgb + vec3(0, 0.3, 0.3);\n                \n\n                if (randVec.x < 0.3)\n                {\n                    materialType = EMISSION;\n                } \n                else \n                {\n                    materialType = REFRACTION;\n                    colorMult *= color * 0.5;\n                }\n            }\n            /*sphNorm;\n            sph2T = traceSphere(curPos, curDir, 1.0, sphNorm, 0.0);\n            vec3 worldPos = sph2T * curDir + curPos;\n            alfa = (1.5 - length(worldPos)) * ();\n            if ((sph2T < t) && (randVec.y < alfa))\n            {\n                t = sph2T;\n                normal = sphNorm;\n                materialType = EMISSION;\n                color = vec3(1.0, 0.6, 0.0);\n            }*/\n        }\n\n        \n            if (t != INF)                                                \n            {\n                vec3 worldPos = t * curDir + curPos;\n                col_buf += vec4(vec3(texture(iChannel0, worldPos.xz).rgb * 0.1) * colorMult * mult, 0.0);\n                if (materialType == EMISSION) \n                {\n                    col_buf += vec4(color * colorMult * mult,  0.0);\n                    break;\n                    \n                }\n                if (materialType == DIFFUSE) \n                {\n                    col_buf += vec4(computeLight(worldPos, color, normal, light, cube) * colorMult, 1.0);\n                    break;\n                   \n                }\n                if (materialType == REFLECTION)\n                {\n                    curDir = reflect(curDir, normal);\n                    curPos = worldPos + curDir * 1e-4;\n                }\n                if (materialType == REFRACTION)\n                {\n                    vec3 Dir = refraction(curDir, normal, n1, n2);\n                    if (Dir.x == 1000.0)\n                    {\n                        curDir = reflect(curDir, normal);\n                        curPos = worldPos + curDir * 1e-4;\n                    }\n                    else \n                    {\n                        //colorMult *= vec3(1, 0.7, 0.4);\n                        curDir = Dir;\n                        curPos = worldPos+ curDir * 1e-4;\n                        float tmp = n1;\n                        n1 = n2;\n                        n2 = tmp;\n                    }\n                }\n            }\n            else\n            {\n                col_buf += vec4(texture(iChannel1, curDir).rgb * colorMult * mult, 1.0); //background\n                break;\n            }\n            \n        \n    }\n    fragColor = col_buf;\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}","name":"Buffer B","description":"","type":"buffer"}]}