{"ver":"0.1","info":{"id":"NdyBzR","date":"1657526553","viewed":58,"name":"Path-Traced SDFs (outdated)","username":"nethe550","description":"SDF rendering using path-tracing.\n\nAn outdated project, see https://www.shadertoy.com/view/7t3cD7.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf","pathtracing","tracing","path"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Misc. Settings\nint MAX_MARCH_ITERATIONS = 100;\nfloat COLLISION_EPSILON = 0.001;\n\n// Camera Settings\nfloat SELF_INTERSECTION_BIAS = 0.001;\nfloat FAR_PLANE = 20.0;\nvec3 CAMERA_POSITION = vec3(0.0, 1.0, 2.5);\nvec3 CAMERA_TARGET = vec3(0.0, 0.0, 0.0);\n\n// Shading Settings\nfloat NORMAL_EPSILON = 0.0001;\nvec3 SUN_DIRECTION = vec3(0.8, 0.4, 0.2);\nvec3 SKY_DIRECTION = vec3(0.0, 1.0, 0.0);\nfloat SKY_LIGHT_BIAS = 0.5;\nvec3 BOUNCE_DIRECTION = vec3(0.0, -1.0, 0.0);\nfloat BOUNCE_LIGHT_BIAS = 0.5;\nfloat HORIZON_BIAS = 2.25;\nfloat GLOSSINESS = 50.0;\n\n// Color Settings\nvec3 BASE_COLOR = vec3(0.18);\nvec3 SUN_COLOR = vec3(7.0, 4.5, 3.0);\nvec3 SKY_COLOR = vec3(0.55, 0.85, 1.0);\nvec3 SKY_LIGHT_COLOR = vec3(0.5, 0.8, 0.9);\nvec3 BOUNCE_LIGHT_COLOR = vec3(0.7, 0.3, 0.2);\nvec3 HORIZON_FOG_COLOR = vec3(0.7, 0.75, 0.8);\n\n// Scene Settings\nfloat GROUND_HEIGHT = -0.25;\n\n\n// a generic sphere sdf\nfloat sdfSphere( in vec3 pixel, vec3 pos, float radius) {\n    \n    return length(pixel + pos) - radius;\n    \n}\n\n// a generic box sdf\nfloat sdfBox( in vec3 pixel, vec3 pos, vec3 size, float radius ) {\n\n    vec3 s = size * 0.5;\n    \n    vec3 q = abs( pixel + pos ) - s;\n\n    vec3 dm = max( q, vec3(0.0) );\n    \n    float d = length(dm) + min( max( max( q.x, q.y ), q.z ), 0.0 );\n\n    return d - radius;\n\n}\n\n// a generic line segment sdf\nfloat sdfLineSegment( in vec3 pixel, vec3 a, vec3 b, float thickness ) {\n\n    vec3 pMinusA = pixel - a;\n    vec3 bMinusA = b - a;\n\n    float h = min( 1.0, max( 0.0, dot(pMinusA, bMinusA) / dot(bMinusA, bMinusA) ) );\n\n    return length( pMinusA - bMinusA * h ) - thickness * 0.5;\n\n}\n\n// the minimum distance to all sdfs in the scene\nfloat distanceToScene( in vec3 pixel ) {\n        \n    // sphere sdf\n    float sphere = sdfSphere( pixel, vec3(0.0), 0.25 );\n    \n    // ground plane sdf\n    float ground = pixel.y - GROUND_HEIGHT;\n    \n    // box sdf\n    float box = sdfBox( pixel, vec3(1.5, -0.01, 0.0), vec3(0.5), 0.01 );\n    \n    // line sdf\n    float line = sdfLineSegment( pixel, vec3(1.0, 0.25, -1.0), vec3(1.0, 0.25, 1.0), 0.125 );\n    \n    return min( line, min( box, min( sphere, ground ) ) );\n\n}\n\nfloat castRay ( in vec3 ro, vec3 rd ) {\n\n    // march along ray\n    float t = 0.0;\n    for ( int i = 0; i < MAX_MARCH_ITERATIONS; i++ ) {\n        \n        // the current position along the ray\n        vec3 pos = ro + t * rd;\n        \n        float h = distanceToScene( pos );\n            \n        // inside of sdf\n        if (h < COLLISION_EPSILON) break;\n        \n        // march forward by the closest safe distance\n        t += h;\n        \n        // ray reached camera far clip plane\n        if (t > FAR_PLANE) break;\n        \n    }\n    if (t > FAR_PLANE) t = -1.0; \n    return t;\n\n\n}\n\n// approximates the normal direction from a given position in the scene\nvec3 calculateNormal( in vec3 pos ) {\n\n        // The delta between sample positions\n        vec2 e = vec2(NORMAL_EPSILON, 0.0);\n        \n        // samples points in the scene very close to each other to calculate the surface normal direction\n        return normalize( vec3(distanceToScene(pos + e.xyy) - distanceToScene(pos - e.xyy),\n                               distanceToScene(pos + e.yxy) - distanceToScene(pos - e.yxy),\n                               distanceToScene(pos + e.yyx) - distanceToScene(pos - e.yyx) ) );\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    CAMERA_POSITION.x = CAMERA_POSITION.x * cos(iTime) - CAMERA_POSITION.z * sin(iTime);\n    CAMERA_POSITION.z = CAMERA_POSITION.z * cos(iTime) + CAMERA_POSITION.x * sin(iTime);\n \n    // map 0 1 to -1 1\n    vec2 uv = ( 2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    // the transformation matrix to make the camera point at the target position\n    vec3 ww = normalize( CAMERA_TARGET - CAMERA_POSITION );\n    vec3 uu = normalize( cross( ww, vec3(0, 1, 0) ) );\n    vec3 vv = normalize( cross( uu, ww ) );\n    \n    // ray-marching direction\n    vec3 rd = vec3( normalize( uv.x * uu + uv.y * vv + 1.5 * ww) );\n    \n    // March a ray\n    float t = castRay( CAMERA_POSITION, rd );\n    \n    // clip plane color\n    vec3 col = SKY_COLOR - HORIZON_BIAS * (0.5 * rd.y);\n    col = mix( col, HORIZON_FOG_COLOR, exp( -10.0 * rd.y ) );\n    \n    // path hit sdf, render\n    if (t > 0.0) {\n        \n        // point on sdf surface\n        vec3 hitPoint = CAMERA_POSITION + t * rd;\n        \n        // normal direction to sdf surface\n        vec3 normal = calculateNormal( hitPoint );\n    \n        // diffuse lighting coefficient from sun\n        float sunDiffuse = clamp( dot( normal, SUN_DIRECTION ), 0.0, 1.0 );\n        \n        // diffuse lighting coefficient from reflected sky light\n        float skyDiffuse = clamp( SKY_LIGHT_BIAS + SKY_LIGHT_BIAS * dot( normal, SKY_DIRECTION ), 0.0, 1.0 );\n        \n        // shadows from sun\n        float sunShadow = step( castRay( hitPoint + normal * SELF_INTERSECTION_BIAS, SUN_DIRECTION ), 0.0 );\n           \n        // diffuse bounce-lighting to illuminate darker areas\n        float bounceDiffuse = clamp( BOUNCE_LIGHT_BIAS + BOUNCE_LIGHT_BIAS * dot( normal, BOUNCE_DIRECTION ), 0.0, 1.0 );\n        \n        // blinn-phong specular lighting\n        vec3 halfVector = normalize( SUN_DIRECTION + CAMERA_POSITION );\n        float specular = pow( clamp( dot( normal, halfVector ), 0.0, 1.0 ), GLOSSINESS );\n    \n        col = BASE_COLOR * SUN_COLOR * sunDiffuse * sunShadow;\n        col += BASE_COLOR * SKY_LIGHT_COLOR * skyDiffuse;\n        col += BASE_COLOR * BOUNCE_LIGHT_COLOR * bounceDiffuse;\n        col += sunDiffuse * specular;\n        \n    }\n    \n    // gamma correction\n    col = pow( col, vec3(0.4545) );\n    \n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}