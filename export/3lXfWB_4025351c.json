{"ver":"0.1","info":{"id":"3lXfWB","date":"1597563616","viewed":193,"name":"Hexagonal","username":"shirokko","description":"animated loading icon","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["hexagon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define ramp\n#define freeze_stationary_points\n// NOT WORKING\n//#define take_shortest_direction \n#define annulus1\n#define annulus2\n\n#define pi 3.14159265\n#define aspectratio iResolution.y/iResolution.x\n#define nloops 10\n#define T1 1.0\n#define T2 1.0\n#define T3 0.5\n#define T4 0.3\n\nfloat normDist(vec2 a, vec2 b)\n{\n    vec2 c = a-b;\n    return sqrt(c.x*c.x + c.y*c.y*aspectratio*aspectratio);\n}\n\nvec3 drawLine (vec2 p1, vec2 p2, vec2 uv, float a, vec3 c)\n{\n    float r = 0.;\n    float one_px = 1. / iResolution.x; //not really one px\n    \n    // get dist between points\n    float d = normDist(p1, p2);\n    \n    // get dist between current pixel and p1\n    float duv = normDist(p1, uv);\n\n    // if point is on line, according to dist, it should match current uv \n    r = 1.-floor(1.-(a*one_px)+normDist(mix(p1, p2, clamp(duv/d, 0., 1.)),  uv));\n        \n    return r*c;\n}\n\nvec3 drawGradientLine (vec2 p1, vec2 p2, vec2 uv, float a, vec3 c1, vec3 c2)\n{\n    float r = 0.;\n    float one_px = 1. / iResolution.x; //not really one px\n    \n    // get dist between points\n    float d = normDist(p1, p2);\n    \n    // get dist between current pixel and p1\n    float duv = normDist(p1, uv);\n\n    // if point is on line, according to dist, it should match current uv \n    r = 1.-floor(1.-(a*one_px)+normDist(mix(p1, p2, clamp(duv/d, 0., 1.)),  uv));\n    \n    // get fraction of length along the line\n    float wc = duv/d;\n        \n    return r*((1.-wc)*c1 + wc*c2);\n}\n\nvec3 drawCircle(vec2 p, float d, vec2 uv)\n{\n    return ((normDist(p, uv) <= d) ? 1. : 0.) * vec3(1.0);\n}\n\nfloat gauss(float x)\n{\n    return exp(-10000.*x*x);\n}\n\nvec3 drawGradientCircle(vec2 p, float d, vec2 uv, vec3 c1, vec3 c2)\n{\n    float r = normDist(p, uv);\n    float nr = gauss(r);\n    return ((r <= d) ? 1. : 0.) * (nr*c1 + (1.-nr)*c2);\n}\n\nvec3 drawAnnulus(vec2 p, float d1, float d2, vec2 uv, vec3 c)\n{\n    return (normDist(p, uv)>d1 && normDist(p,uv)<d2) ? c : vec3(0.);\n}\n\nint imod(int n, int m) {\n    return n >= m ? n-m*int(floor(float(n/m))) : n;\n}\n\nfloat fmod(float n, float m) {\n    return n >= m ? n - m*floor(n/m) : n;\n}\n\nfloat rand(vec2 co)\n{ // pseudorandom real [0, 1]\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nint intRand(vec2 co, int m)\n{ // pseudorandom integer [0, m)\n    return imod(int(rand(co)*100.), m);\n}\n\nbool isNeighbour(int a, int b)\n{\n    return abs(a-b)==1 || abs(a-b) == 5 ? true : false;\n}\n\nbool isComplement(int a, int b)\n{\n    return abs(a-b)==3 ? true : false;\n}\n\nint smd(int a, int b, int m)\n{ // signed modulo distance\n    return b-a > m/2 ? a-b+m : b-a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 lc = vec3(129., 216., 208.);\n    vec3 hc = vec3(255.);\n    hc /= vec3(255.);\n    lc /= vec3(255.);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float t = iTime;\n    \n    // setup a normalized time in [0.,1.]\n    float nt = fmod(t, 1.);\n    // optional: smooth start and end\n#ifdef ramp\n    nt = (cos(nt*pi)+1.)/2.;\n#endif\n    \n    //define unit hexagon\n    vec2 hex[6];\n    for (int i=0; i<6; i++) {\n        float n = float(i)*2.;\n        hex[i] = vec2(sin(n*pi/6.), cos(n*pi/6.));\n    }\n    \n    // scale unit hexagon to center of screen\n    vec2 points[6];\n    for (int i=0; i<6; i++) {\n        points[i] = hex[i];\n        points[i] *= vec2(aspectratio, 1.);\n        points[i] *= vec2(0.5, 0.5);\n        points[i] += vec2(1.0, 1.0);\n        points[i] /= vec2(2.0, 2.0);\n    }\n    \n    // animate points\n    vec2 p[6];\n    int q[] = int[6](0, 1, 2, 3, 4, 5);\n    \n    // randomize a destination point\n    for (int i=0; i<6; i++) {\n        // setup a consistent seed for each \"loop\"\n        float ft = floor(t);\n        // number of unique \"loops\" until it does a global loop\n        ft = fmod(ft, float(nloops));\n        // choose a number to swap with\n        int a = intRand(vec2(ft, i), 6);\n        // swap those two entries\n        int t=q[a];\n        q[a] = q[i];\n        q[i] = t;\n    }\n    \n    for (int i=0; i<6; i++) {\n        // choose the endpoints\n        int j = 1;\n        int a = i;\n        int b = q[a];\n        \n#ifdef freeze_stationary_points\n        if (a != b) {\n#endif\n            // weights for a and b\n            float wa = 1.-nt;\n            float wb = nt;\n\n            // setup velocities to be the tangent\n            vec2 va = vec2(-hex[a].y, hex[a].x);\n            vec2 vb = vec2(-hex[b].y, hex[b].x);\n            // check to see if we're rotating the right way\n#ifdef take_shortest_direction\n            if (smd(a,b,6) > 0) {\n                va *= -1.; vb *= -1.;\n            }\n#endif\n            \n            float s = 0.5;\n            va *= vec2(s);\n            vb *= vec2(s);\n            //va = vec2(0.,0.);\n            //vb = vec2(0.,0.);\n            // setup 4-point stencil\n            vec2 pi0 = points[a];\n            vec2 pi1 = points[a]+va/3.;\n            vec2 pi2 = points[b]-vb/3.;\n            vec2 pi3 = points[b];\n            // define bezier curve\n            p[i] = wa*wa*wa*pi0 + 3.*wa*wa*wb*pi1 + 3.*wa*wb*wb*pi2 + wb*wb*wb*pi3;\n#ifdef freeze_stationary_points\n        } else {\n            p[i] = points[a];\n        }\n#endif\n    }\n    \n    vec3 lines;\n    for (int i=0; i<6; i++) {\n        // connect all other points\n        for (int j=0; j<6; j++) {\n            if (i==j) continue;\n        \t//int a = i; int b = imod(i+1, 6);\n            int a=i; int b=j;\n            \n            float aa = isNeighbour(a,b) ? 0.8 : 0.0; // start neighbours\n            float ba = isNeighbour(a,b) ? 0.0 : 0.2; // start interior\n            float ab = isNeighbour(q[a], q[b]) ? 0.8 : 0.0; // end neighbours\n            float bb = isNeighbour(q[a], q[b]) ? 0.0 : 0.2; // end interior\n            \n            float ta = isComplement(a,b) ? T2 : T3;\n            float tb = isComplement(q[a], q[b]) ? T2 : T3;\n            ta += isNeighbour(a,b) ? T1 : 0.0;\n            tb += isNeighbour(q[a], q[b]) ? T1 : 0.0;\n            \n        \tlines += drawLine(p[a], p[b], uv, (1.-nt)*ta + nt*tb, (1.-nt)*aa*hc+(1.-nt)*ba*lc + nt*ab*hc+nt*bb*lc);\n        }\n        \n        // connect to complement midpoints (loop start)\n        for (int j=0; j<6; j++) {\n            int a=i; int b=j;\n            if (!isComplement(a, b)) continue;\n            \n            // look for neighbours of j\n            for (int k=0; k<6; k++) {\n                int c=k;\n                if (!isNeighbour(b, c)) continue;\n                vec2 midpoint = (p[b]+p[c])/2.;\n                lines += drawGradientLine(p[a], midpoint, uv, T4, (1.-nt)*vec3(0.3), vec3(0.));\n            }\n        }\n        // connect to complement midpoints (loop end)\n        for (int j=0; j<6; j++) {\n            int a=i; int b=j;\n            if (!isComplement(q[a], q[b])) continue;\n            \n            // look for neighbours of j\n            for (int k=0; k<6; k++) {\n                int c=k;\n                if (!isNeighbour(q[b], q[c])) continue;\n                vec2 midpoint = (p[b]+p[c])/2.;\n                lines += drawGradientLine(p[a], midpoint, uv, T4, nt*vec3(0.3), vec3(0.));\n            }\n        }\n    }\n        \n    vec3 annulus;\n    for (int i=0; i<6; i++) {\n#ifdef annulus1\n        {\n            int a = i;\n            int b = q[a];\n\n            float alpha = 0.;\n            if (a == b) alpha = 1. + min(min(3.*nt, 3.-3.*nt), 1.);\n            else alpha = max(1.0+(nt-1.)*3.,0.) + max(1.0+(-nt)*3.,0.);\n\n          \tannulus += drawGradientCircle(p[i], 0.05, uv, alpha*vec3(0.5), vec3(0.));\n        }\n#endif\n#ifdef annulus2\n        {\n            // find closest point\n            float closestDist = 10000.;\n            float alpha = 0.;\n            if (i == q[i]) alpha = 2.;\n            else {\n                for (int j=0; j<6; j++)\n                    closestDist = min(normDist(points[i], p[j]), closestDist);\n                //alpha = max(1./(100.*closestDist+1.),0.);\n                alpha = exp(-30.*closestDist);\n            }\n\n            annulus += drawAnnulus(points[i], 0.025, 0.027, uv, alpha*vec3(0.4));\n        }\n#endif\n    }\n    \n\tfragColor = vec4(lines + annulus, 1.);\n}","name":"Image","description":"","type":"image"}]}