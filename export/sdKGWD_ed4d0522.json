{"ver":"0.1","info":{"id":"sdKGWD","date":"1633021656","viewed":162,"name":"Path tracing 1","username":"Shcherbakov","description":"Base sample for stream.\nThere are implementations for implicit and explicit sampling and multiple importance sampling.\nStream: https://youtu.be/MKai0qIbDgQ\nStream 2: https://youtu.be/ekVBOqryI60","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel2, fragCoord / iResolution.xy) / float((iFrame + 1));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float INF = 1e10;\n\nfloat lengthSq(vec3 v) {\n    return dot(v, v);\n}\n\nfloat pow2(float x) { return x * x; }\n\nstruct OpaqueSphere {\n    vec3 pos;\n    float radius;\n    vec3 color;\n    float specP;\n    float specFactor;\n    float transP;\n};\n\nstruct EmissiveSphere {\n    vec3 pos;\n    float radius;\n    vec3 color;\n};\n\n\nconst int CIRCLE_COUNT = 10;\nconst int SPHERES_COUNT = 4 + CIRCLE_COUNT;\nOpaqueSphere spheres[SPHERES_COUNT] = OpaqueSphere[SPHERES_COUNT](\n    // Circle\n    OpaqueSphere(vec3(0, -1000, 0), 999.0, vec3(0.7), 0.0, 0.0, 0.0),\n    OpaqueSphere(vec3(0, -1000, 0), 999.0, vec3(0.7), 0.0, 0.0, 0.0),\n    OpaqueSphere(vec3(0, -1000, 0), 999.0, vec3(0.7), 0.0, 0.0, 0.0),\n    OpaqueSphere(vec3(0, -1000, 0), 999.0, vec3(0.7), 0.0, 0.0, 0.0),\n    OpaqueSphere(vec3(0, -1000, 0), 999.0, vec3(0.7), 0.0, 0.0, 0.0),\n    OpaqueSphere(vec3(0, -1000, 0), 999.0, vec3(0.7), 0.0, 0.0, 0.0),\n    OpaqueSphere(vec3(0, -1000, 0), 999.0, vec3(0.7), 0.0, 0.0, 0.0),\n    OpaqueSphere(vec3(0, -1000, 0), 999.0, vec3(0.7), 0.0, 0.0, 0.0),\n    OpaqueSphere(vec3(0, -1000, 0), 999.0, vec3(0.7), 0.0, 0.0, 0.0),\n    OpaqueSphere(vec3(0, -1000, 0), 999.0, vec3(0.7), 0.0, 0.0, 0.0),\n    // Walls\n    OpaqueSphere(vec3(0, -1000, 0), 999.0, vec3(0.7), 0.0, 0.0, 0.0),\n    OpaqueSphere(vec3(-1000, 0, -1), 995.0, vec3(0.9, 0.9, 0.2), 0.0, 0.0, 0.0),\n    OpaqueSphere(vec3(0, 0, -1000), 990.0, vec3(0.9), 0.0, 0.0, 0.0),\n    OpaqueSphere(vec3(1000, 0, -1), 995.0, vec3(0.9), 0.0, 0.0, 0.0)//,\n    // Other scenes\n    /*OpaqueSphere(vec3(-2, 0, -7), 0.5, vec3(0.6, 0.1, 0.1)),\n    OpaqueSphere(vec3(4, 1, 0), 1.0, vec3(0.8, 0.7, 0.3)),\n    OpaqueSphere(vec3(0.6, 0, -1), 0.3, vec3(0.99)),\n    OpaqueSphere(vec3(-3.0, 0, 0), 0.3, vec3(0.99)),\n    OpaqueSphere(vec3(1, 0.5, -3), 0.5, vec3(0.1, 0.8, 0.99))*/\n);\n\nconst int LIGHTS_COUNT = 2;\nEmissiveSphere lights[LIGHTS_COUNT] = EmissiveSphere[LIGHTS_COUNT](\n    EmissiveSphere(vec3(1.5, 0, 3), 0.15, vec3(15.0)),\n    EmissiveSphere(vec3(0, 2, -1), 0.5, vec3(40.0))\n);\n\nfloat intersectSphere(vec3 pos, vec3 dir, vec3 sphere_pos, float radius) {\n    // length(pos + t * dir - sphere.xyz) = sphere.w\n    float c = lengthSq(pos - sphere_pos) - pow2(radius);\n    float b = 2.0 * dot(pos - sphere_pos, dir);\n    float a = lengthSq(dir);\n    float D = pow2(b) - 4.0 * a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    float Dsqrt = sqrt(D);\n    float t = (-b - Dsqrt) / a * 0.5;\n    if (t > 0.0) {\n        return t;\n    }\n    t = (-b + Dsqrt) / a * 0.5;\n    if (t > 0.0) {\n        return t;\n    }\n    return INF;\n}\n\n\nvec3 genRay(uint hash, vec3 normal) {\n    vec3 tang = abs(normal.x) > 0.99 ? vec3(0, 1, 0) : vec3(1, 0, 0);\n    vec3 bitang = normalize(cross(normal, tang));\n    tang = cross(bitang, normal);\n    vec2 randValues = texelFetch(iChannel1, ivec2(hash / 1024u, hash) % 1024, 0).xy;\n    float phi = 2.0 * PI * randValues.x;\n    float sinTheta = sqrt(randValues.y);\n    float cosTheta = sqrt(1.0 - randValues.y);\n    vec3 res = vec3(\n        sinTheta * cos(phi),\n        sinTheta * sin(phi),\n        cosTheta\n    );\n    return normal * res.z + tang * res.x + bitang * res.y;\n}\n\nvec3 genSpecularRay(uint hash, vec3 normal, float specFactor) {\n    vec3 tang = abs(normal.x) > 0.99 ? vec3(0, 1, 0) : vec3(1, 0, 0);\n    vec3 bitang = normalize(cross(normal, tang));\n    tang = cross(bitang, normal);\n    vec2 randValues = texelFetch(iChannel1, ivec2(hash / 1024u, hash) % 1024, 0).xy;\n    float spec = pow(randValues.x, 1.0 / (specFactor + 1.0));\n    float h = sqrt(1.0 - pow2(spec));\n    vec3 res = vec3(\n        h * cos(2.0 * PI * randValues.y),\n        h * sin(2.0 * PI * randValues.y),\n        spec\n    );\n    return normal * res.z + tang * res.x + bitang * res.y;\n}\n\nbool is_light_visible(vec3 pos, vec3 dir, float t, int light_id) {\n    for (int sphere_id = 0; sphere_id < SPHERES_COUNT; ++sphere_id) {\n        float sphT = intersectSphere(pos, dir, spheres[sphere_id].pos, spheres[sphere_id].radius);\n        if (sphT < t) {\n            return false;\n        }\n    }\n    for (int sphere_id = 0; sphere_id < LIGHTS_COUNT; ++sphere_id) {\n        float sphT = intersectSphere(pos, dir, lights[sphere_id].pos, lights[sphere_id].radius);\n        if (sphT < t && sphere_id != light_id) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfloat get_light_area(int idx) {\n    return 4.0 * PI * pow2(lights[idx].radius);\n}\n\nvec3 trace(vec3 pos, vec3 dir, uint hash) {\n    const int TRACE_DEPTH = 3;\n    vec3 colorMult = vec3(1);\n    vec3 color = vec3(0);\n    vec3 prevNormal = dir;\n    #if SHADOW_RAYS\n    bool allowImplicit = true;\n    #else\n    bool allowImplicit = false;\n    #endif\n    for (int iter = 0; iter < TRACE_DEPTH; ++iter) {\n        hash++;\n        float t = INF;\n        int idx = -1;\n        bool emissive = false;\n        for (int sphere_id = 0; sphere_id < SPHERES_COUNT; ++sphere_id) {\n            float sphT = intersectSphere(pos, dir, spheres[sphere_id].pos, spheres[sphere_id].radius);\n            if (sphT < t) {\n                t = sphT;\n                idx = sphere_id;\n            }\n        }\n        for (int sphere_id = 0; sphere_id < LIGHTS_COUNT; ++sphere_id) {\n            float sphT = intersectSphere(pos, dir, lights[sphere_id].pos, lights[sphere_id].radius);\n            if (sphT < t) {\n                t = sphT;\n                idx = sphere_id;\n                emissive = true;\n            }\n        }\n        if (idx == -1) {\n            return color;\n        }\n        if (emissive) {\n            #if SHADOW_RAYS\n            if (!allowImplicit) {\n                return lights[idx].color * colorMult + color;\n            }\n            #endif\n            #if MIS\n            float cosThetaExpl = max(-dot(dir, normalize(pos + t * dir - lights[idx].pos)), 0.0);\n            float cosThetaImpl = max(dot(dir, prevNormal), 0.0);\n            if (cosThetaExpl > 0.0 && cosThetaImpl >= 0.0) {\n            float pe = pow2(t) / get_light_area(idx) / cosThetaExpl;\n                float pi = cosThetaImpl / PI;\n                float wi = pow2(pi) / (pow2(pe) + pow2(pi));\n                return iter == 0 ? lights[idx].color : lights[idx].color * colorMult * wi + color;\n            }\n            #elif SHADOW_RAYS\n            return iter == 0 ? lights[idx].color : color;\n            #endif\n            return lights[idx].color * colorMult;\n        }\n        pos = pos + t * dir;\n        vec3 normal = normalize(pos - spheres[idx].pos);\n        pos += 1e-3 * normal;\n        \n        float matRandVal = texelFetch(iChannel1, ivec2(hash / 1024u, hash) % 1024, 0).w;\n        int matId = matRandVal < spheres[idx].transP ? TRANS_MAT :\n            matRandVal < spheres[idx].specP ? SPEC_MAT : DIFF_MAT;\n        \n        float cosTheta;\n        float PDF;\n        vec3 BRDF;\n        switch (matId) {\n            case DIFF_MAT:\n                dir = genRay(hash, normal);\n                cosTheta = max(dot(normal, dir), 0.0);\n                PDF = cosTheta / PI;\n                BRDF = spheres[idx].color / PI;\n                break;\n            case SPEC_MAT:\n                float specFactor = spheres[idx].specFactor;\n                dir = genSpecularRay(hash, normal, specFactor);\n                cosTheta = max(dot(normal, dir), 0.0);\n                float specMult = pow(cosTheta, specFactor) / PI * 0.5;\n                PDF = (specFactor + 1.0) * specMult;\n                BRDF = spheres[idx].color * (specFactor + 2.0) * specMult;\n                allowImplicit = false;\n                break;\n            case TRANS_MAT:\n                pos -= 2e-3 * normal;\n                vec3 innerDir = refract(dir, normal, 1.0 / 1.5);\n                float dist = intersectSphere(pos, innerDir, spheres[idx].pos, spheres[idx].radius);\n                pos += innerDir * dist;\n                normal = normalize(pos - spheres[idx].pos);\n                pos += 1e-3 * normal;\n                dir = refract(innerDir, -normal, 1.5 / 1.0);\n                cosTheta = 1.0;\n                PDF = 1.0;\n                BRDF = spheres[idx].color;\n                allowImplicit = false;\n                break;\n        }\n        if (allowImplicit) {\n            for (int light_idx = 0; light_idx < LIGHTS_COUNT; ++light_idx) {\n                vec4 randomVal = texelFetch(iChannel1, ivec2(hash / 1024u, hash) % 1024, 0);\n                vec3 randDir = normalize(randomVal.xyz - 0.5);\n                vec3 lightPos = lights[light_idx].pos + randDir * lights[light_idx].radius * randomVal.w;\n                vec3 shadowDir = lightPos - pos;\n                float shadowDist = length(lightPos - pos);\n                shadowDir /= shadowDist;\n                if (is_light_visible(pos, shadowDir, shadowDist, light_idx)) {\n                    float cosTheta1 = max(dot(randDir, -shadowDir), 0.0);\n                    float cosTheta2 = max(dot(normal, shadowDir), 0.0);\n                    if (cosTheta1 > 0.0 && cosTheta2 > 0.0) {\n                        float lightPDF = 1.0 / get_light_area(light_idx) * pow2(shadowDist) / cosTheta1;\n                        vec3 lightIntens = lights[light_idx].color * spheres[idx].color * cosTheta2 / PI;\n                        #if MIS\n                        float pe = lightPDF;\n                        float pi = PDF;\n                        if (pe > 0.0 && pi > 0.0) {\n                            float we = pow2(pe) / (pow2(pe) + pow2(pi));\n                            color += lightIntens / lightPDF * colorMult * we;\n                        }\n                        #else\n                        color += lightIntens / lightPDF * colorMult;\n                        #endif\n                    }\n                }\n            }\n        }\n        if (PDF > 0.0) {\n            colorMult *= BRDF / PDF * cosTheta;\n            prevNormal = normal;\n        } else {\n            return color;\n        }\n    }\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 CAMERA_POS = vec3(0, 1, 10);\n    vec3 target = vec3(0, 0, 0);\n    uint hash = ((uint(fragCoord.x) << 12) | uint(fragCoord.y)) ^ floatBitsToUint(iTime);\n    vec3 forward = normalize(target - CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(forward, up));\n    up = cross(right, forward);\n    for (int i = 0; i < CIRCLE_COUNT; ++i) {\n        float angle = float(i) / float(CIRCLE_COUNT) * 2.0 * PI;\n        spheres[i].pos = vec3(sin(angle) * 2.0, -0.2 + sin(float(i) * 20.0) * 0.5, cos(angle) * 2.0);\n        spheres[i].radius = 0.4;\n        spheres[i].color = texelFetch(iChannel1, ivec2(i, 0), 0).rgb;\n        vec3 randVals = texelFetch(iChannel1, ivec2(i, 1), 0).rgb;\n        if (i % 2 == 0) {\n            spheres[i].color *= 2.0;\n            spheres[i].transP = randVals.x * 0.5 + 0.49;\n        } else {\n            spheres[i].specP = randVals.x * 0.5 + 0.49;\n            spheres[i].specFactor = randVals.y * 128.0;\n        }\n    }\n    for (int i = 0; i < SAMPLES_COUNT; ++i) {\n        hash += uint(i);\n        vec2 rand = texelFetch(iChannel1, ivec2(hash / 1024u, hash) % 1024, 0).rg;\n        vec2 uv = (fragCoord - iResolution.xy * 0.5 + (rand - 0.5)) / iResolution.x;\n        vec3 viewVec = normalize(forward + right * uv.x + up * uv.y);\n        fragColor.rgb += trace(CAMERA_POS, viewVec, hash);\n    }\n    fragColor.rgb /= float(SAMPLES_COUNT);\n    fragColor.rgb += texture(iChannel2, fragCoord / iResolution.xy).rgb;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const int SAMPLES_COUNT = 1;\nconst float PI = 3.14159265359;\nconst int DIFF_MAT = 0;\nconst int SPEC_MAT = 1;\nconst int TRANS_MAT = 2;\n#define SHADOW_RAYS 1\n#define MIS 1","name":"Common","description":"","type":"common"}]}