{"ver":"0.1","info":{"id":"3lc3D4","date":"1576268325","viewed":76,"name":"Polyp 3","username":"indigofracture","description":"noise","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["jellyfish"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.14159265\n\n#define LIMBS 8\n#define JOINTS 32\n#define LIMB_LENGTH 0.025*0.25\n#define FATNESS 0.7\n\n// Reverse colors and thickness for cool effect.\n//#define REVERSED\n\n//#define DANCE\n\n\n// Optimized Simplex noise functions from Makio64: https://www.shadertoy.com/view/4sdGD8\n\n/*lowp vec3 permute(in lowp vec3 x) { return mod( x*x*34.+x, 289.); }\nlowp float snoise(in lowp vec2 v) {\n  lowp vec2 i = floor((v.x+v.y)*.36602540378443 + v),\n      x0 = (i.x+i.y)*.211324865405187 + v - i;\n  lowp float s = step(x0.x,x0.y);\n  lowp vec2 j = vec2(1.0-s,s),\n      x1 = x0 - j + .211324865405187, \n      x3 = x0 - .577350269189626; \n  i = mod(i,289.);\n  lowp vec3 p = permute( permute( i.y + vec3(0, j.y, 1 ))+ i.x + vec3(0, j.x, 1 )   ),\n       m = max( .5 - vec3(dot(x0,x0), dot(x1,x1), dot(x3,x3)), 0.),\n       x = fract(p * .024390243902439) * 2. - 1.,\n       h = abs(x) - .5,\n      a0 = x - floor(x + .5);\n  return .5 + 65. * dot( pow(m,vec3(4.))*(- 0.85373472095314*( a0*a0 + h*h )+1.79284291400159 ), a0 * vec3(x0.x,x1.x,x3.x) + h * vec3(x0.y,x1.y,x3.y));\n}*/\n\n//#define HIGH_QUALITY_NOISE\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n#ifndef HIGH_QUALITY_NOISE\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0. ).yx;\n#else\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\n\tvec2 rg1 = textureLod( iChannel0, (uv+ vec2(0.5,0.5))/256.0, 0. ).yx;\n\tvec2 rg2 = textureLod( iChannel0, (uv+ vec2(1.5,0.5))/256.0, 0. ).yx;\n\tvec2 rg3 = textureLod( iChannel0, (uv+ vec2(0.5,1.5))/256.0, 0. ).yx;\n\tvec2 rg4 = textureLod( iChannel0, (uv+ vec2(1.5,1.5))/256.0, 0. ).yx;\n\tvec2 rg = mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\n#endif\t\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn textureLod( iChannel0, (uv+118.4)/256.0, 0. ).x;\n}\n\n/*float hash(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}*/\n\n\n// Draw line and circle functions from Loeizd: https://www.shadertoy.com/view/4ljfRD\n\nfloat drawLine (vec2 p1, vec2 p2, vec2 uv, float a)\n{\n    float r = 0.;\n    float one_px = 1. / iResolution.x; //not really one px\n    \n    // get dist between points\n    float d = distance(p1, p2);\n    \n    // get dist between current pixel and p1\n    float duv = distance(p1, uv);\n\n    //if point is on line, according to dist, it should match current uv \n    r = 1.-floor(1.-(a*one_px)+distance (mix(p1, p2, clamp(duv/d, 0., 1.)),  uv));\n        \n    return r;\n}\n\nfloat drawCircle(vec2 p, float d, vec2 uv)\n{\n    return (distance(p, uv) <= d) ? 1. : 0.;\n}\n\n// Basic map function from: https://stackoverflow.com/questions/17134839/how-does-the-map-function-in-processing-work\n\nfloat map(float value, \n                              float istart, \n                              float istop, \n                              float ostart, \n                              float ostop) {\n    return ostart + (ostop - ostart) * ((value - istart) / (istop - istart));\n}\n\n\nvec3 bodycolor1 = vec3(1.0,0.8,0.8);\nvec3 bodycolor2 = vec3(0.2,0.0,0.3);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float t = iTime*45.; //Pro Tipâ„¢: multipluy time to go faster!\n\n    vec2 noise_vec = vec2(-t * 0.05, t * 0.05);\n    \n    float lines = 0.;\n    \n    vec2 init = vec2(0.5+sin(t*0.01) * 0.3, 0.5+cos(t*0.01) * 0.3);\n    #ifdef DANCE\n    init += noise(noise_vec)*0.15;\n    #endif\n    //vec2 noisebump = vec2(sin(noise(noise_vec)), cos(noise(noise_vec))) * 0.4;\n    //init += noisebump;\n    \n    #ifndef REVERSED\n    // Main fadeoff mapping\n    float fadeoff = map(distance(init,uv),0.,LIMB_LENGTH*float(JOINTS),FATNESS,0.0);//((LIMB_LENGTH*float(JOINTS))-distance(init, uv));\n\t#else\n    // Reversed fadeoff mapping (gives a cool widening effect)\n    float fadeoff = map(distance(init,uv),0.,LIMB_LENGTH*float(JOINTS),0.0,FATNESS);\n    #endif\n    \n    for(int i = 0; i < LIMBS; ++i) {\n            vec2 prevpos = init;\n        for(int j = 0; j < JOINTS; ++j) {\n            float theta = map(noise(noise_vec), -1., 1., pi, -pi) + (t*0.01);\n            //float theta = map(noise(noise_vec), -1., 1., pi/3.-(pi/4.), -pi/3.-(pi/4.)) + (t*0.01);\n            noise_vec += float(j);\n            vec2 nextpos = prevpos + (vec2(sin(theta), cos(theta)) * LIMB_LENGTH);\n            if(lines == 0.)\n            \tlines += drawLine(prevpos, nextpos, uv, fadeoff*16.) * fadeoff;//* map(float(j), 0., float(JOINTS), 1.0, 0.0);\n            prevpos = nextpos;\n        }\n    }\n    \n    if(lines == 0.)\n        lines += drawCircle(init, .02+(sin(t*0.1) + 1.)*0.02 * noise(noise_vec), uv) * fadeoff;\n    \n    vec3 col = vec3(0.,0.,0.);\n    col.r = map(lines, 1.0, 0.0, bodycolor1.r, bodycolor2.r);\n    col.g = map(lines, 1.0, 0.0, bodycolor1.g, bodycolor2.g);\n    col.b = map(lines, 1.0, 0.0, bodycolor1.b, bodycolor2.b);\n    \n\tfragColor = vec4(col.r, col.g, col.b, 1.);\n}","name":"Image","description":"","type":"image"}]}