{"ver":"0.1","info":{"id":"wtsXRB","date":"1563449705","viewed":667,"name":"Golden Fractal Wheel","username":"jmb","description":"From the 64kb demo \"Inner System Lab\" https://www.youtube.com/watch?v=w71XrzzdfWw","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["fractal","reflection","wheel","gold"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float EPS = 2e-2;\nconst int MAX_STEPS = 100;\n\nconst float T_INF = -1.0;\nconst float T_SPHERE = 0.0;\nconst float T_WALL = 1.0;\nconst float T_BOX = 2.0;\nconst float T_ARROW = 3.0;\n    \nfloat psin(float v) \n{\n    return (1.0 + sin(v)) * 0.5;\n}\n\nfloat reflectiveIndex(float type) \n{\n    if (type == T_WALL)\n        return 0.4;\n\tif (type == T_SPHERE)\n        return 0.2;\n\tif (type == T_BOX)\n        return 0.5;\n\treturn 0.0;\n}\n\nfloat specularFactor(float type) \n{\n    if (type == T_WALL)\n        return 0.0;\n\treturn 1.0;\n}\n\n\nvec3 color(float type, vec3 p) \n{\n    if (type == T_WALL)\n       return 0.1*palette(fract(-p.x*p.y*0.015), vec3(0.5), vec3(0.5), vec3(1.0, 1.0, 1.0), vec3(0.00, 0.10, 0.20\t) );\n    else if (type == T_SPHERE)\n        return vec3(0.2, 0.1, 0.6);\n    else if (type == T_BOX) {\n        \n        vec3 white = vec3(0., 1.0, 0.);\n        vec3 red = vec3(1.0, 0, 0);\n\t\tfloat m = mod(floor((iTime+1.9) * 1. / 2.), 2.);\n        red = mix(white, red, 1.);\n        \n        vec3 yellow = vec3(1.0, 1.0, 0.0);\n\t\treturn mix(red, yellow, 0.3*noise_3(2.0*sin((iTime+0.5)*0.5)*p + iTime*0.5));\n     }\n    else if (type == T_ARROW)\n        return vec3(0.1, 0.1, 0.8);\n    return vec3(0.0);\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\n\nfloat smink( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 sun(vec2 a, vec2 b)\n{\n\t\n    float sm = smink(a.x,b.x, 0.1);\n\tfloat m = min(a.x, b.x);\n\tfloat ca = abs(sm -a.x);\n\tfloat cb = abs(sm -b.x);\n\t\n\treturn ca < cb ? vec2(sm, a.y) : vec2(m, b.y);\n}\n\nvec2 un(vec2 a, vec2 b) { return a.x < b.x ? a : b; }\n\nfloat rv(float low, float high, float p)\n{\n    return low + (high - low) * hash11(p);\n}\n\n\n// From iq.\nvec2 fractalBox(in vec3 p)\n{\n   p.xz *= rot(-2. + 2.3*psin((iTime - 17.)*0.06));\n\n   moda(p.xy, 15.);\n   pMod1(p.x, 1.);\n\n   float d = sdBox(p,vec3(1.0)) - 0.0;\n   vec2 res = vec2( d, T_BOX);\n\n   float bpm = 133.;\n   float beat = mod(iTime, 60.f / bpm * 4.f);\n   float f = 1.*smoothspike(0.0, 0.45, beat);\n\n   float tim = mod(iTime + 1.7 - 2.0, 4.0);\n   float s = 0.7 + 0.3*smoothstep(1.7, 2.0, tim) - 0.3*smoothstep(3.7, 4.0, tim);\n\n   for( int m=0; m<3; m++ )\n   {\n      vec3 newp = p;\n      vec3 a = mod( newp * s, 2.0 ) - 1.0;\n      s *= 3.0;\n      vec3 r = abs(1.0 - 3.0*abs(a));\n      float da = max(r.x,r.y);\n      float db = max(r.y,r.z);\n      float dc = max(r.z,r.x);\n      float c = (min(da,min(db,dc))-1.0)/s;\n\n      if( c>d )\n      {\n          d = c;\n          res = vec2( d, T_BOX);\n       }\n   }\n    \n\n   return res;\n}\n\nvec2 walls(vec3 p) {\n    \n \tfloat d = -sdBox( p - vec3(0.0, 10.0, 0.0), vec3(60.0));\n    return vec2(d, T_WALL);\n}\n\nvec3 wheelPos() {\n \treturn vec3(0., 0., 1.5);    \n}\n\nvec2 flooring(vec3 p) {\n  return vec2(p.y +1.7 + 0.02*noise_2(2.*p.xz + 0.5*iTime), T_WALL);\n}\n\nvec2 map( in vec3 p )\n{\n    vec2 s = vec2(sdSphere(p - wheelPos(), 1.0), T_BOX);\n    vec2 w = flooring(p);\n    \n    float sc = 2.0;\n    float tf = 0.5;\n    vec3 direction = normalize(vec3(sin(iTime*tf), cos(iTime*tf), psin(iTime*tf)));\n    vec2 fs = fractalBox(   1./sc*(p - wheelPos()));\n    fs.x *= sc;\n    return sun(w, fs);\n}\n\nvec3 normal(vec3 p) \n{\n    float eps = EPS;\n    vec3 n = vec3(map(vec3(p.x + eps, p.y, p.z)).x, map(vec3(p.x, p.y + eps, p.z)).x, map(vec3(p.x, p.y, p.z + eps)).x);\n    return normalize(n - map(p).x);\n}\n\nvec2 march(vec3 ro, vec3 rd, out vec3 p, out int steps)\n{\n    float t = 0.0;\n   \tvec2 res = vec2(0.0, -1.0);\n    for(steps = 0; steps < MAX_STEPS; ++steps) {\n    \tp = ro + t * rd;   \n        vec2 tres = map(p);\n        t += tres.x;\n        if (tres.x < EPS) {\n\t\t\tres = tres;\n            break;\n        }\n        if (t > 400.0) {\n            break;\n        }\n    }\n    return res;\n}\n\nfloat shadow(vec3 ro, vec3 dir) \n{\n    float t = 0.01;\n \tfloat sf = 1.0;\n    for(int i = 0; i < MAX_STEPS; ++i) {\n\t\tvec3 p = ro + t * dir;    \t\n        vec2 res = map(p);\n        t += clamp(res.x, 0.02, 0.1);\n        if (res.x < 0.001)\n            return 0.5;\n       sf = min(sf, 8.0 * abs(res.x) / t);\n    }\n \treturn min(1.0, 0.5 + 0.5*sf);\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n) \n{\n\tfloat as = 0.0;\n    float sl = 60.0 * 1e-3;\n    int ns = 6;\n    for(int i = 0; i < ns; i++) {\n    \tvec3 ap = p + float(i) * sl * n;    \n    \tas += map(ap).x;\n    }\n    return mix(1.0, smoothstep(0.0, float(ns *(ns - 1) / 2) * sl, as), 0.6);\n}\n                          \nvec3 colorize(vec2 res, vec3 p, vec3 dir, int steps) \n{\n    vec3 light = normalize(vec3(1.0, -1,  -1.));\n    vec3 lightPos = wheelPos();\n    \n    vec3 n = normal(p);\n    float lf = min(2.5, 3.0 / (0.02 + 0.1*pow(length(p - lightPos), 3.)));\n    \n    // Material properties\n    float diffuse1 = 0.0*max(0.,dot(-light, n));\n    float diffuse2 = max(0.,dot(-normalize(p - lightPos), n));\n    float diffuse = max(diffuse1, 2.*diffuse2);\n    float k = max(0.0, dot(dir, reflect(-normalize(p - lightPos), n)));\n    float spec = specularFactor(res.y) * pow(k, 100.0);\n    \n    vec3 col = color(res.y, p);\n\tfloat ao = ambientOcclusion(p, n);\n\n    if (res.x < EPS)\n        col =  (lf) * (ao * col *(0.02+diffuse) + spec);\n    \n    float ns = float(steps) / 100.;\n    return pow(col * ns * 20., vec3(0.4545));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n\tuv.y *= iResolution.y / iResolution.x;\n    \n\tvec3 ro = vec3(12.0, 11., 12.0);\n    vec3 tar = vec3(0.0, 1.0, 0.0);\n    ro = mix(tar, ro, 1.0);\n    vec3 dir = normalize(tar - ro);\n\tvec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), dir));\n\tvec3 up = cross(dir, right);\n\tvec3 rd = normalize(dir + right * uv.x + up * uv.y);\n    \n    vec3 p;\n    int steps;\n    vec2 res = march(ro, rd, p, steps);\n    vec3 col = colorize(res, p, rd, steps);\n\n    float ri = reflectiveIndex(res.y);\n    if (ri > 0.0) { \n        vec3 p2;\n   \t\trd = reflect(rd, normal(p));\n    \tres = march(p + 0.1 * rd, rd, p2, steps);\n    \tvec3 newCol = colorize(res, p2, rd, steps);\n    \tcol = mix(col, newCol, ri);\n    }\n\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nmat2 rot(float a)\n{\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nvoid moda (inout vec2 p, float rep)\n{\n    float per = 2.*PI/rep;\n    float a = atan(p.y, p.x);\n    float l = length(p);\n    a = mod(a-per*0.5,per)-per*0.5;\n    p = vec2(cos(a),sin(a))*l;  \n}\n\n\nvoid mo (inout vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if(p.y >p.x) p = p.yx;\n}\n\nfloat stmin (float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b), 0.5*(u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\n\nfloat smoothspike(float left, float right, float value) \n{\n\tfloat mid = (left + right) / 2.;\n    return value < mid ? smoothstep(left, mid, value) : 1. - smoothstep(mid, right, value);\n}\n\n\nfloat hash11(float p) {\n    return fract(sin(p * 727.1)*435.545);\n}\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*437.545);\n}\nvec3 hash31(float p) {\n\tvec3 h = vec3(127.231,491.7,718.423) * p;\t\n    return fract(sin(h)*435.543);\n}\n\nfloat noise_2( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( hash12( i + vec2(0.0,0.0) ), \n                     hash12( i + vec2(1.0,0.0) ), u.x),\n                mix( hash12( i + vec2(0.0,1.0) ), \n                     hash12( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n// 3d noise\nfloat noise_3(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = f*f*(3.0-2.0*f);\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash12( ii + vec2(0.0,0.0) );\n\tfloat b = hash12( ii + vec2(1.0,0.0) );    \n    float c = hash12( ii + vec2(0.0,1.0) );\n\tfloat d = hash12( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash12( ii + vec2(0.0,0.0) );\n\tb = hash12( ii + vec2(1.0,0.0) );    \n    c = hash12( ii + vec2(0.0,1.0) );\n\td = hash12( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),0.0);\n}\n\n// fBm\nfloat fbm3(vec3 p, float a, float f) {\n    return noise_3(p);\n}\n\nfloat fbm3_high(vec3 p, float a, float f) {\n    float ret = 0.0;    \n    float amp = 1.0;\n    float frq = 1.0;\n    for(int i = 0; i < 4; i++) {\n        float n = pow(noise_3(p * frq),2.0);\n        ret += n * amp;\n        frq *= f;\n        amp *= a * (pow(n,0.2));\n    }\n    return ret;\n}\n\n\nmat3 rotateAngle(vec3 v, float a )\n{\n    float si = sin( a );\n    float co = cos( a );\n    float ic = 1.0f - co;\n\n    return mat3( v.x*v.x*ic + co,       v.y*v.x*ic - si*v.z,    v.z*v.x*ic + si*v.y,\n                   v.x*v.y*ic + si*v.z,   v.y*v.y*ic + co,        v.z*v.y*ic - si*v.x,\n                   v.x*v.z*ic - si*v.y,   v.y*v.z*ic + si*v.x,    v.z*v.z*ic + co );\n}\n\n","name":"Common","description":"","type":"common"}]}