{"ver":"0.1","info":{"id":"DlSyzd","date":"1692289422","viewed":61,"name":"Blood Sky - PBR","username":"amankhan","description":"A truncated version of volumetric rendering for clouds.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["volume","cloud","sky","rendering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_RSTEPS 50.\n#define MAX_VSTEPS 10.\n#define STEP_RSIZE 0.2\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n#define S smoothstep\n#define T iTime*0.2\n#define ARG T * 2. * PI * 0.25\n#define MODT smoothstep(0., 0.5, sin(ARG + 0.5))\n#define MODT2 smoothstep(0.48,0.5,sin(ARG + 0.5)) -  smoothstep(0.5,0.52,sin(ARG + 0.5))\n#define MODT3 smoothstep(0.48,0.5,sin(ARG + 0.45)) -  smoothstep(0.5,0.52,sin(ARG + 0.45))\n\n/* ********* UTILS ************** \n*********************************/\n\n// 2D Rotation\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// Background\nvec3 Bg(vec3 rd) {    \n    float L = rd.y * 0.5 + 0.5;\n    vec3 lBlue = vec3(0.29, 0.3, 0.3);\n    vec3 dBlue = vec3(0.07, 0.10, 0.2);\n    vec3 lRed = vec3(0.94, 0.94, 0.94);\n    vec3 dRed = vec3(0.83, 0.83, 0.83);\n    return mix(mix(dRed, dBlue, MODT), mix(lRed, lBlue, MODT), L) + (MODT2 + MODT3) * vec3(1);\n}\n\n// 3D Grid\nvec3 sdGrid(vec3 p, float thickness, vec2 size, vec3 choice) {\n    // (A)\n    // We are going to swizzle the xyz around based on the grid plane we want to generate.\n    // Choices are:\n    // x == 1. => xy DEFAULT\n    // y == 1. => yz\n    // z == 1. => zx\n    if(choice.y == 1.)\n        p.xyz = p.yzx;\n    else if(choice.z == 1.)\n        p.xyz = p.zxy;\n    \n    // (B) \n    // Calculate the centre of the individual cells. For example if we want it to be 2 units wide\n    // on each side, the midpoints are 1, 1\n    vec2 mid = size * 0.5; \n    \n    // (C)\n    // Shift the existing coordinate by the midpoint.\n    p.xy += mid; \n    \n    // (D)\n    // Modulo breaks the grid system into repeated multiples of our unit.\n    // For example a 2 x 2 unit grid would result in our p coordinates to be \n    // repeated in the 0,2 range.\n    p.xy = mod(p.xy, size); \n    \n    // (E)\n    // We now have a local grid system. We place the thin cylinder in the centre.\n    // We do this as leaving the cylinder in the origin leads to artifacts. And this \n    // is why we pre-shifted everything in (C). \n    p.xy -= mid;\n    \n    // Place the thin cylinders in the middle.\n    float Grid1 = length(p.xz) - thickness;\n    float Grid2 = length(p.yz) - thickness;\n    \n    // Boolean union\n    float d = min(Grid1, Grid2);\n    \n    return vec3(Grid1, Grid2, d);\n}\n\n// XY Plane Shortcut\nvec3 sdGridXY(vec3 p, float thickness, vec2 size) {\n    return sdGrid(p, thickness, size, vec3(1., 0., 0.));\n}\n\n// YZ Plane Shortcut\nvec3 sdGridYZ(vec3 p, float thickness, vec2 size) {\n    return sdGrid(p, thickness, size, vec3(0., 1., 0.));\n}\n\n// ZX Plane Shortcut\nvec3 sdGridZX(vec3 p, float thickness, vec2 size) {\n    return sdGrid(p, thickness, size, vec3(0., 0., 1.));\n}\n\n/* ******* NOISE FUNCS ***********\n*********************************/\n\n// Takes a 3D point and returns a float 0 - 1\nfloat Hash31(vec3 p) {\n    return fract(sin(dot(p, vec3(12.9898,78.233, 124.419))) * 43758.5453123);\n}\n\n// Value Noise: \nfloat VNoise(vec3 x ) {\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n\n    float a = Hash31( p+vec3(0,0,0) );\n    float b = Hash31( p+vec3(1,0,0) );\n    float c = Hash31( p+vec3(0,1,0) );\n    float d = Hash31( p+vec3(1,1,0) );\n    float e = Hash31( p+vec3(0,0,1) );\n    float f = Hash31( p+vec3(1,0,1) );\n    float g = Hash31( p+vec3(0,1,1) );\n    float h = Hash31( p+vec3(1,1,1) );\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);\n}\n\nfloat fbm(vec3 p, float iter) {\n    float amp = 1.;\n    float freq = 1.;\n    float scale = 0.;\n    float result = 0.;\n    \n    for(float i=0.; i<iter; i++) {\n        result += amp * VNoise(p * freq);\n        scale += amp;\n        amp *= 0.5;\n        freq *= (2. + i*0.1);\n    }\n    \n    scale *= 0.8;\n    return result / scale ;\n}\n\n/* ***** VOLUME RENDERING FUNCS ***********\n*******************************************/\n\n// Henyey-Greenstein Phase function\nfloat phase(float g, float cosTheta) {\n    float denom = 1. + g*g - 2.*g*cosTheta;\n    \n    return (1. / (4. * PI)) * (1. - g * g) / (denom * sqrt(denom));\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd) {\n    const float YPLANE = 15.; // Define max cloud height.\n    vec3 CLOUDCOL = mix(vec3(0.19, 0.37, 0.96), vec3(0.79, 0.11, 0.10), MODT);\n    const float SIGMA_A = 1.4; // Absorption\n    const float SIGMA_S = 0.9; // Scattering\n    const float SIGMA_E = SIGMA_A + SIGMA_S; // Extinction\n    float transparency = 1.;\n    \n    for(float i=0.; i<MAX_RSTEPS; i++) {\n        float d = i * STEP_RSIZE;\n    \tvec3 p = ro + rd * d;\n        p.xz *= Rot(T*0.3);\n        p.z += T;\n        \n        // Check if we are below or above the cloud plane\n        if(p.y < YPLANE && transparency > 0.01) {            \n            float density = clamp((fbm(p, 4.) - 0.3)*5., 0., 1.);            \n            float lambda = density * SIGMA_E;\n            float sampleAttn = exp(-STEP_RSIZE * lambda);\n\n            transparency *= sampleAttn;            \n        } else break;       \n    }\n    \n    return Bg(rd) * (1. - transparency) + CLOUDCOL * (transparency); // Inverted\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0, 0, -3);\n    //ro.yz *= Rot(-m.y*PI+1.);\n    ro.xz *= Rot(-m.x*TAU);\n    \n    vec3 lookat = vec3(0,0.,0);\n    vec3 rd = GetRayDir(uv, ro, lookat, 1.);\n   \n    vec3 col = RayMarch(ro, rd);\n         \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}