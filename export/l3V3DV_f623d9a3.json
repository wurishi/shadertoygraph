{"ver":"0.1","info":{"id":"l3V3DV","date":"1718285043","viewed":21,"name":"Recursin","username":"FeedbackLoop","description":"trying and trying","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["simple","recurrenceplot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize coordinates to range [-1, 1]\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    \n    // Time variable to animate the sine wave\n    float time = iTime;\n    uv *= mat2(.707, -.707, .707, .707);\n    float scaling = 50.0 + 2.0 * sin(time);\n\n    // Generate values for t1 and t2 based on the sine wave\n    float t1 = (uv.x * uv.y) * scaling;  // Adjust scaling factor as needed\n    float t2 = uv.y * scaling;  // Adjust scaling factor as needed\n\n    // Animate the sine wave over time\n    float value1 = sin(t1+time) + sin(time);\n    float value2 = cos(t2+time) + cos(time);\n\n    // Calculate the distance between the states\n    float distance = abs(value1 - value2);\n\n    // Apply a threshold to determine recurrence\n    float threshold = 0.7;  // Adjust threshold as needed\n    // Recurrence plot (binary value)\n    float recurrence = step(distance, threshold);\n\n    // Set the fragment color based on the recurrence value\n    if (recurrence < threshold) {\n        fragColor = vec4(0.0, 1.0, 0.0, 0.0); // Green for recurrent points\n    } else {\n        fragColor = vec4(1.0*sin(time), 0.0, 1.0*cos(time), 1.0); // Red for non-recurrent points\n    }\n}\n","name":"Image","description":"","type":"image"}]}