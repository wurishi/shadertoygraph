{"ver":"0.1","info":{"id":"3ldSW7","date":"1581095080","viewed":112,"name":"SH Naive solver","username":"rubbish","description":"Simple visualization of SH based on previous works, extended max band to 128 by refactoring naive implementation","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["solver","spherical","harmonics","sh","factorials"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Original source:  https://www.shadertoy.com/view/lsfXWH\n// \t--Created by inigo quilez - iq/2013\n//  --License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Based on Spherical harmonics solver by TimoKinnunen\n//  --https://www.shadertoy.com/view/3dKGWG\n// \n// Changes: \n//  - Turned back to the simplest naive equation, but surprisingly effective \n//  - Used approximated factorial to evaluate ALP\n//  - Support at most band 64 for full band visualisation (l=64, m=[-64, 64])\n//\t          at most band 128, order 0 for highest record.\n//    Seems factorial died after around 128!, probably caused by invalid exp()\n\nprecision highp float;\n\n// band\n#define L 32\n\n// order\n#define M 32\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // antialias level (try 1, 2, 3, ...)\n#endif\n\n#define AUTOMATIC\n//#define SHOW_SPHERES\n\n//---------------------------------------------------------------------------------\n\n// control step length of marching\n#define MARCH_STEP\t\t\t\t0.05\n// control maximum marching depth\n#define MARCH_MAX_ITERATION     600\n\n// upper & lower bounds used by factorial approximation\n#define a0 0.833333333333333333   //            1 / 12\n#define a1 0.033333333333333333   //            1 / 30\n#define a2 0.252380952380952381   //           53 / 210\n#define a3 0.525606469002695418   //          195 / 371\n#define a4 1.011523068126841712   //        22999 / 22737\n#define a5 1.517473649153287398   //     29944523 / 19733142\n#define a6 2.269488974204959961   // 109535241009 / 48264275462\n#define SQRT2 1.4142135623 \t\t  // sqrt(2)\n#define INV_4PI 0.0795774715 \t  // 1 / (4 * pi)\n#define LOG_2PI 1.8378770664      // log(2 * pi)\n\n// look up table for first few factorials due to \n// limited precision of approximated factorial when input x is small\nconst float factorialLUT[11] = float[11](\n\t1.0,\n    1.0,\n    2.0,\n    6.0,\n    24.0,\n    120.0,\n    720.0,\n    5040.0,\n    40320.0,\n    362880.0,\n    3628800.0\n);\n\n// Stieltjes's continued fraction approximation based on: \n// \t\thttp://www.luschny.de/math/factorial/approx/SimpleCases.html\nfloat FactorialStieltjesNoExp(in int x)\n{\n\tif(x < 11) { return log(factorialLUT[x]); }\n\tfloat  Z = float(x) + 1.0;\n\treturn 0.5 * LOG_2PI + (Z - 0.5) * log(Z) - Z + \n\t\ta0/(Z + a1/(Z + a2/(Z + a3/(Z + a4/(Z + a5/(Z + a6/Z))))));\n}\n\n// K(l, m) * P(l, m)\n// Based on Spherical Harmonic Lighting: The Gritty Details by Robin Green, 2003\n//    http://silviojemma.com/public/papers/lighting/spherical-harmonic-lighting.pdf\nfloat KP(in int l, in int m, in float x)\n{\n\tfloat f = 0.0;\n\tif(m > 0)\n\t{\n        float t1 = FactorialStieltjesNoExp(l - m);\n        float t2 = FactorialStieltjesNoExp(2 * m - 1);\n        float t3 = FactorialStieltjesNoExp(l + m);\n        float t4 = FactorialStieltjesNoExp(m - 1);\n        \n        f = pow(2.0, float(2 - 2 * m)) * exp(t1 + 2.0 * t2 - t3 - 2.0 * t4);\n\t}\n\telse\n\t{\n\t\tf = 1.0;\n\t}\n\t\n\t// kp <=> K(l, m) * (2m - 1)!!\n\tfloat kp = sqrt((2.0 * float(l) + 1.0) * INV_4PI * f); \n\t// (-1)^(m)\n\tfloat fact = 1.0 - 2.0 * mod(float(m), 2.0);\n\tfloat Pmm = fact * kp * pow(1.0 - x * x, float(m) / 2.0);\n    \n\tif(l == m){ return Pmm; }\n\n\tfloat Pmmp1 = x * (2.0 * float(m) + 1.0) * Pmm;\n\tif(l == m+1) { return float(Pmmp1); }\n\n\tfloat Pml = 0.0;\n\tfor (int ll = m+2; ll <= l; ++ll)\n\t{ \n\t\tPml = ( (2.0 * float(ll) - 1.0) * x * Pmmp1 - (float(ll) + float(m) - 1.0) * Pmm ) / float(ll - m);\n\t\tPmm = Pmmp1;\n\t\tPmmp1 = Pml;\n\t}\n\treturn Pml;\n}\n\n// Y_l_m(s), where l is the band and m the range in [-l..l] \nfloat SHNaive(in int l, in int m, in vec3 s)\n{\n\tfloat phi = atan(s.z, s.x);\n\n\tif(m == 0)\n\t{\n\t\treturn KP(l, 0, s.y);\n\t}\n\telse if(m > 0)\n\t{\n        //s.y <=> cos(theta)\n\t\treturn SQRT2 * cos(float(m) * phi)  * KP(l, m, s.y);\n\t}\n\telse\n\t{\n\t\treturn SQRT2 * sin(-float(m) * phi) * KP(l, -m, s.y);\n\t}\n}\n\nvec3 map( in vec3 p )\n{\n    vec3 p00 = p;\n\t\n\tfloat r, d; vec3 n, s, res;\n\t\n    #ifdef SHOW_SPHERES\n\t#define SHAPE (vec3(d-0.35, -1.0+2.0*clamp(0.5 + 16.0*r,0.0,1.0),d))\n\t#else\n\t#define SHAPE (vec3(d-abs(r), sign(r),d))\n\t#endif\n\n    int l = L;\n    int m = M;\n    #ifdef AUTOMATIC\n    int x = ((iFrame>>1)&0x7FF)/15;\n    int Y = int(floor(sqrt(0.25+float(2*x))-0.5));\n    int X = int(floor(float(x)-0.5*float(Y+Y*Y)));\n    l = Y+1;\n    m = X+1;\n    #endif\n\td=length(p00); n=p00/d; r = SHNaive(l, m, n ); s = SHAPE; res = s;\n\t\n\treturn vec3( res.x, 0.5+0.5*res.y, res.z );\n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n\tvec3 res = vec3(1e10,-1.0, 1.0);\n\n\tfloat maxd = 10.0;\n    float h = 1.0;\n    float t = 1.0;\n    vec2  m = vec2(-1.0);\n    for( int i=0; i<MARCH_MAX_ITERATION; i++ )\n    {\n        if( h<0.001||t>maxd ) break;\n        vec3 p = ro+rd*t ;\n\t    vec3 res = map(p);\n        h = res.x;\n\t\tm = res.yz;\n        t += h*MARCH_STEP;\n    }\n\tif( t<maxd && t<res.x ) res=vec3(t,m);\n\t\n\n\treturn res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.001,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\n    float an = 10.0*iMouse.x/iResolution.x;\n    float am = 2.*iMouse.y/iResolution.y - 1.;\n    float turn = radians(360./256.)*float(iFrame&0xFF);\n    vec3  ro = vec3(2.0*sin(an+turn),2.0*sin(am),2.0*cos(an+turn)) * 1.0;\n    vec3  ta = vec3(0.0,0.0,0.0);\n\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    vec3 tot = vec3(0.0);\n\n    #define ZERO min(iFrame,0)\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {        \n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+vec2(float(m),float(n))/float(AA))) / iResolution.y;\n\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n        // background \n        vec3 col = vec3(0.3) * clamp(1.0-length(p)*0.5,0.0,1.0);\n\n        // raymarch\n        vec3 tmat = intersect(ro,rd);\n        if( tmat.y>-0.5 )\n        {\n            // geometry\n            vec3 pos = ro + tmat.x*rd;\n            vec3 nor = calcNormal(pos);\n            vec3 ref = reflect( rd, nor );\n\n            // material\t\t\n            vec3 mate = 0.5*mix( vec3(1.0,0.6,0.15), vec3(0.2,0.4,0.5), tmat.y );\n\n            float occ = clamp( 2.0*tmat.z, 0.0, 1.0 );\n            float sss = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 1.0 );\n\n            // lights\n            vec3 lin  = 2.5*occ*vec3(1.0,1.00,1.00)*(0.6+0.4*nor.y);\n                 lin += 1.0*sss*vec3(1.0,0.95,0.70)*occ;\t\t\n\n            // surface-light interacion\n            col = mate.xyz * lin;\n        }\n\n        // gamma\n        col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n        tot += col;\n    }\n    tot /= float(AA*AA);\n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}