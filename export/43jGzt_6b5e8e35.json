{"ver":"0.1","info":{"id":"43jGzt","date":"1708728753","viewed":76,"name":"Magic Eye Smash Effect","username":"zalo","description":"An animated Magic Eye attempting to simplify and make sense of PMalin's Original Magic Eye Shader.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["autostereogram","magiceye"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Simplified Autostereogram Shader, based on Stereogram - @P_Malin\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/ldf3Dr\n\n// and SmashEffect by dila\n// https://www.shadertoy.com/view/XlBXRK\n\n// Use Parallel Viewing instead of Cross Eyed Viewing\n#define INVERT_DEPTH\n\n// Enable Wiggle Stereo to see the 3D Image without screwing up eyes\n//#define WIGGLESTEREO\n\n// Creates a Stair-Stepping Effect; May Improve Stereo Convergence on Low Res Displays\n//#define INTEGER_OFFSET \n\n// Show the underlying Depth Map\n//#define SHOW_DEPTH_IMAGE\n\nfloat fPixelRepeat = 96.0 * 2.0;\nfloat fDepthScale = 16.0;\nfloat gUVScale = 1.0;\n\nvec4 GetStereogramDepth(vec2 vPixel)\n{\n\t// Adjust pixel co-ordinates to be in centre of strip\n    return texture(iChannel0, ((vPixel - vec2(fPixelRepeat * 0.5, 0.0)) / iResolution.xy));\n}\n\nvec3 Stereogram(vec2 vPixel)\n{\n\tvec2 vInitialPixel = vPixel;\n\t#ifdef INTEGER_OFFSET\n\tvInitialPixel = floor(vInitialPixel + 0.5);\n\t#endif\n\tvec2 vIntPixel = vInitialPixel;\n\t\n    // Accumulate Disparity Shifts sideways across the display to avoid compensatory negative disparity shifts.\n    // See the compensation described here:\n    // https://blog.demofox.org/2023/10/22/how-to-make-your-own-spooky-magic-eye-pictures-autostereograms/#:~:text=Doing%20that%2C%20we%20aren%E2%80%99t%20quite%20there.%20Some%203D%20effects%20are%20starting%20to%20pop%20out%2C%20but%20it%20doesn%E2%80%99t%20look%20quite%20right.\n\t\n    // 64 is an arbitrary number, enough to make sure we will reach the edge of the screen\n\tfor(int i=0; i<64; i++) {\n\t\t// Step left fPixelRepeat minus depth...\n\t\tvec4 vDepth = GetStereogramDepth(vIntPixel);\n\t\tfloat fOffset = -fPixelRepeat;\n\n\t\t#ifndef INVERT_DEPTH\n\t\tfOffset -= vDepth.w * fDepthScale;\n\t\t#else\n\t\tfOffset += vDepth.w * fDepthScale;\n\t\t#endif\t\t\n\t\t\n\t\tvIntPixel.x = vIntPixel.x + fOffset;\t\t\n\t\t#ifdef INTEGER_OFFSET\n\t\tvIntPixel.x = floor(vIntPixel.x + 0.5);\n\t\t#endif\n\t\t\n\t\t// ...until we fall of the screen\n\t\tif(vIntPixel.x < 0.0) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tvIntPixel.x = mod(vIntPixel.x, fPixelRepeat);\n\t\n\tvec2 vUV = (vIntPixel + 0.5) / fPixelRepeat;\n\t\n\tconst float fMipLod = -32.0;\n\n    if ( gUVScale != 1.0 ) {\n        vUV = fract(vUV) * gUVScale;\n    }\n\n\treturn texture(iChannel1, fract(vec2(vUV)), fMipLod).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t#ifdef SHOW_DEPTH_IMAGE\n    fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy);\n\t#else\n    vec2 pixCoord = fragCoord.xy;\n    \n    #ifdef WIGGLESTEREO\n    float mult = mod(floor(iTime * 10.0), 2.0);\n    pixCoord.x -= (-0.5 + mult) * fPixelRepeat;\n    #endif\n    \n    fragColor = vec4(Stereogram(pixCoord), 1.0);\n\t#endif\t\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Borrowed from https://www.shadertoy.com/view/XlBXRK\n\nmat2 rot(float t)\n{\n \treturn mat2(cos(t), sin(t), -sin(t), cos(t));   \n}\n\n/* thanks to iq */\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nvec3 times()\n{\n    float gt = fract(iTime * 0.5) * 3.0;\n    float a  = clamp(gt - 0.0, 0.0, 1.0);\n    float b  = clamp(gt - 1.0, 0.0, 1.0);\n    float c  = clamp(gt - 2.0, 0.0, 1.0);\n    return vec3(a, b, c);\n}\n\nfloat map(vec3 p)\n{\n    float height = 1.0;\n    float ground = p.y + height;\n    \n    vec3 pt = times();\n    float pound = 0.82 - pow(1.0-pt.y, 2.0) - pow(pt.z, 32.0);\n    pound *= 2.0;\n    \n\tfloat srot = smoothstep(0.0, 1.0, (pt.y+pt.z)*0.5);\n    mat2 mrot = rot(-0.3 + srot * 3.14);\n    \n    vec3 boxoff = vec3(0.0, pound, 0.0);\n    p.xz *= mrot;\n    float box = udRoundBox(p - boxoff, vec3(height)*0.5, height*0.25);\n \treturn min(ground, box);\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n \tfloat t = 0.0;\n    for (int i = 0; i < 128; ++i) {\n        vec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n        if (t < 0.001) {\n            break;\n        }\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uv.y += 0.75;\n    \n    vec3 r = normalize(vec3(uv, 1.0));\n    vec3 o = vec3(0.0, -0.75, -2.0);\n    \n    float t = trace(o, r);\n    \n    vec3 pos = o + r * t;\n    float td = dot(vec3(0.0, 0.0, 1.0), pos-o);\n    \n    t = min(1.0/td, 1.0);\n    \n    fragColor = vec4(t);\n}","name":"Buffer A","description":"","type":"buffer"}]}