{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"//https://www.youtube.com/@cool3dcode\n// Thanks Evvvvil for the twitch streams. I coded along with all of them until my back started hurting.\n// number of scene primitives\n#define NSO 1 \n// Epsilon for normals\n#define EPS vec2(0.00001, -0.00001)\n// surface hit distance\n#define SRF 0.0001\n// maximum ray march distance\n#define DST 90.0\n// number of iterations.\n#define ITR 128\n// rotate about an axis. .xy is z axis rotation for example. notice that z is not in .xy\n// whichever axis is missing is the one you're rotating over\n#define RT(X) mat2(cos(X), -sin(X), sin(X), cos(X))\n\n// time\nfloat t = 0.0;\n// glow\nfloat g1 = 0.0;\n\nfloat box(vec3 sp, vec3 dm)\n{\n\tsp = abs(sp) - dm;\n\treturn max(max(sp.y, sp.x), sp.z);\n\t\n\t\n}\n\n// scene\nvec2 map(vec3 sp)\n{\n\tfloat dst[NSO];\n\tfloat id = 0.0;\n\tvec3 spw = sp;\n\t\n\tspw.z = mod(spw.z + t, 2.0);\n\tspw.xy *= RT(sp.z * 0.1);\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\t\n\t\tspw = abs(spw) - vec3(1, 2, 2);\n\t\tspw.xy *= RT(1.2);\n\t\t\n\t\t\n\t}\n\t\n\tspw.zy *= RT(sp.x * 0.1);\n\tdst[0] = box(spw, vec3(5, 0.14, 1));\n\tfloat gfx = length(spw + vec3(sin(t) * 2.5, 1, 0)) - 0.01;\n\t\n    // usually this would be += but I prefer it like this for this scene\n    g1 = pow(0.1 / max(gfx, 0.001), 3.0);\n\t\n\tfor (int i = 1; i < NSO; i++)\n\t{\n\t\tif (dst[i] < dst[0]) {\n\t\t\tdst[0] = dst[i];\n\t\t\tid = float(i);\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t}\n\treturn vec2(dst[0] * 0.8, id);\n\t\n\t\n}\n\nvec3 nml(vec3 sp)\n{\n\t\n\treturn normalize(EPS.xyy * map(sp + EPS.xyy).x + \n\t\t\t         EPS.yyx * map(sp + EPS.yyx).x + \n\t\t             EPS.yxy * map(sp + EPS.yxy).x + \n\t\t\t         EPS.xxx * map(sp + EPS.xxx).x); \n\t\n}\n\nvec2 mrch(vec3 ro, vec3 rd)\n{\n\tfloat d0 = 0.0;\n\tfloat id = 0.0;\n\tfor (int i = 0; i < ITR; i++) \n\t{\t\n\t\tvec3 sp = ro + rd * d0;\n\t\tvec2 ds = map(sp);\n\t\tif (d0 > DST || abs(ds.x) < SRF) break;\n\t\td0 += ds.x;\n\t\tid = ds.y;\n\t\t\n\t\t\n\t}\n\t\n\tif (d0 > DST) d0 = 0.0;\n\treturn vec2(d0, id);\n\t\n}\n\nvoid mainImage(out vec4 c_out, in vec2 uu)\n{\n\tvec2 rr = iResolution.xy;\n    vec2 uv = (uu + uu - rr) / rr.y;\n\tuv *= 0.5;\n\tt = mod(iTime, acos(-1.0) * 6.0);\n\t// ray origin\n    vec3 ro = vec3(5 , 0.5, -7);\n\t// camera\n    vec3 w = normalize(vec3(0) - ro);\n\tvec3 u = normalize(cross(w, vec3(0, 1, 0)));\n\tvec3 v = normalize(cross(u, w));\n\t// ray direction\n    vec3 rd = normalize(mat3(u, v, w) * vec3(uv, 1.5));\n\t// light position\n    vec3 lp = vec3(0, 2, -2);\n\t// scene\n    vec2 sc = mrch(ro, rd);\n\tfloat d = sc.x;\n\tint id = int(sc.y);\n\t\n\t// background color\n\tvec3 amb = vec3(0.1, 0.1, 0.09) * 0.6;\n\tvec3 clr = amb;\n\t\n\tif (d > 0.0)\n\t{\n\t\tvec3 sp = ro + rd * d;\n\t\tvec3 n  = nml(sp);\n\t\tvec3 ld = normalize(lp - sp);\n\t\t\n        // diffuse\n        float df = max(0.0, dot(n, ld));\n\t\t// specular highlight\n\t\tfloat spc = pow(max(dot(reflect(-ld, n), -rd), 0.0), 40.0);\n\t\t// sub surface scattering\n        float ss = smoothstep(0.0, 1.0, map(sp + vec3(sin(t) * 2.5, 1, 0)).x / 2.5);\n\t\t\n\t\tclr = amb * df + ss * vec3(0, 0.1, 0.1) + spc;\n        // distance fog\n\t\tclr = mix(clr, amb, 1.0 -exp(-0.00005 * pow(d, 3.0)));\n\t\t\n\t}\n\t\n\tclr += g1 * vec3(1, 0.1, 0.1);\n\t\n\tc_out = vec4(clr, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4cGfWR","date":"1733905113","viewed":48,"name":"Ominous Monolithic Megastructure","username":"akr51","description":"An ominous artificial megastructure that looks like it could power a civilization. ","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""}}