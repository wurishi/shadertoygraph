{"ver":"0.1","info":{"id":"DdBGR1","date":"1667184406","viewed":195,"name":"3D_raymarching_scene_girl","username":"zhxmdefj","description":"test","likes":3,"published":1,"flags":0,"usePreview":1,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TIME 60.0\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin(float a, float b, float k)\n{\n\tfloat h = max(k - abs(a - b), 0.0);\n\treturn min(a, b) - h * h * 0.25 / k;\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax(float a, float b, float k)\n{\n\tk *= 1.4;\n\tfloat h = max(k - abs(a - b), 0.0);\n\treturn max(a, b) + h * h * h / (6.0 * k * k);\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin3(float a, float b, float k)\n{\n\tk *= 1.4;\n\tfloat h = max(k - abs(a - b), 0.0);\n\treturn min(a, b) - h * h * h / (6.0 * k * k);\n}\n\nfloat sclamp(in float x, in float a, in float b)\n{\n\tfloat k = 0.1;\n\treturn smax(smin(x, b, k), a, k);\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat opOnion(in float sdf, in float thickness)\n{\n\treturn abs(sdf) - thickness;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat opRepLim(in float p, in float s, in float lima, in float limb)\n{\n\treturn p - s * clamp(round(p / s), lima, limb);\n}\n\n\nfloat det(vec2 a, vec2 b) { return a.x * b.y - b.x * a.y; }\nfloat ndot(vec2 a, vec2 b) { return a.x * b.x - a.y * b.y; }\nfloat dot2(in vec2 v) { return dot(v, v); }\nfloat dot2(in vec3 v) { return dot(v, v); }\n\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdTorus(in vec3 p, in float ra, in float rb)\n{\n\treturn length(vec2(length(p.xz) - ra, p.y)) - rb;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n\tp.x = abs(p.x);\n\tfloat k = (sc.y * p.x > sc.x * p.z) ? dot(p.xz, sc) : length(p.xz);\n\treturn sqrt(dot(p, p) + ra * ra - 2.0 * ra * k) - rb;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere(in vec3 p, in float r)\n{\n\treturn length(p) - r;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdEllipsoid(in vec3 p, in vec3 r)\n{\n\tfloat k0 = length(p / r);\n\tfloat k1 = length(p / (r * r));\n\treturn k0 * (k0 - 1.0) / k1;\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox(in vec3 p, in vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(max(d.x, d.y), d.z), 0.0) + length(max(d, 0.0));\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdArc(in vec2 p, in vec2 scb, in float ra)\n{\n\tp.x = abs(p.x);\n\tfloat k = (scb.y * p.x > scb.x * p.y) ? dot(p.xy, scb) : length(p.xy);\n\treturn sqrt(dot(p, p) + ra * ra - 2.0 * ra * k);\n}\n\n#if 1\n// http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\n// { dist, t, y (above the plane of the curve, x (away from curve in the plane of the curve))\nvec4 sdBezier(vec3 p, vec3 va, vec3 vb, vec3 vc)\n{\n\tvec3 w = normalize(cross(vc - vb, va - vb));\n\tvec3 u = normalize(vc - vb);\n\tvec3 v = (cross(w, u));\n\t//----\n\tvec2 m = vec2(dot(va - vb, u), dot(va - vb, v));\n\tvec2 n = vec2(dot(vc - vb, u), dot(vc - vb, v));\n\tvec3 q = vec3(dot(p - vb, u), dot(p - vb, v), dot(p - vb, w));\n\t//----\n\tfloat mn = det(m, n);\n\tfloat mq = det(m, q.xy);\n\tfloat nq = det(n, q.xy);\n\t//----\n\tvec2  g = (nq + mq + mn) * n + (nq + mq - mn) * m;\n\tfloat f = (nq - mq + mn) * (nq - mq + mn) + 4.0 * mq * nq;\n\tvec2  z = 0.5 * f * vec2(-g.y, g.x) / dot(g, g);\n\t//float t = clamp(0.5+0.5*(det(z,m+n)+mq+nq)/mn, 0.0 ,1.0 );\n\tfloat t = clamp(0.5 + 0.5 * (det(z - q.xy, m + n)) / mn, 0.0, 1.0);\n\tvec2 cp = m * (1.0 - t) * (1.0 - t) + n * t * t - q.xy;\n\t//----\n\tfloat d2 = dot(cp, cp);\n\treturn vec4(sqrt(d2 + q.z * q.z), t, q.z, -sign(f) * sqrt(d2));\n}\n#else\nfloat det(vec3 a, vec3 b, in vec3 v) { return dot(v, cross(a, b)); }\n\n// my adaptation to 3d of http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\n// { dist, t, y (above the plane of the curve, x (away from curve in the plane of the curve))\nvec4 sdBezier(vec3 p, vec3 b0, vec3 b1, vec3 b2)\n{\n\tb0 -= p;\n\tb1 -= p;\n\tb2 -= p;\n\n\tvec3  d21 = b2 - b1;\n\tvec3  d10 = b1 - b0;\n\tvec3  d20 = (b2 - b0) * 0.5;\n\n\tvec3  n = normalize(cross(d10, d21));\n\n\tfloat a = det(b0, b2, n);\n\tfloat b = det(b1, b0, n);\n\tfloat d = det(b2, b1, n);\n\tvec3  g = b * d21 + d * d10 + a * d20;\n\tfloat f = a * a * 0.25 - b * d;\n\n\tvec3  z = cross(b0, n) + f * g / dot(g, g);\n\tfloat t = clamp(dot(z, d10 - d20) / (a + b + d), 0.0, 1.0);\n\tvec3 q = mix(mix(b0, b1, t), mix(b1, b2, t), t);\n\n\tfloat k = dot(q, n);\n\treturn vec4(length(q), t, -k, -sign(f) * length(q - n * k));\n}\n#endif\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 sdSegment(vec3 p, vec3 a, vec3 b)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn vec2(length(pa - ba * h), h);\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 sdSegmentOri(vec2 p, vec2 b)\n{\n\tfloat h = clamp(dot(p, b) / dot(b, b), 0.0, 1.0);\n\treturn vec2(length(p - b * h), h);\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdFakeRoundCone(vec3 p, float b, float r1, float r2)\n{\n\tfloat h = clamp(p.y / b, 0.0, 1.0);\n\tp.y -= b * h;\n\treturn length(p) - mix(r1, r2, h);\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdCone(in vec3 p, in vec2 c)\n{\n\tvec2 q = vec2(length(p.xz), p.y);\n\n\tvec2 a = q - c * clamp((q.x * c.x + q.y * c.y) / dot(c, c), 0.0, 1.0);\n\tvec2 b = q - c * vec2(clamp(q.x / c.x, 0.0, 1.0), 1.0);\n\n\tfloat s = -sign(c.y);\n\tvec2 d = min(vec2(dot(a, a), s * (q.x * c.y - q.y * c.x)),\n\t\tvec2(dot(b, b), s * (q.y - c.y)));\n\treturn -sqrt(d.x) * sign(d.y);\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n\tp = abs(p);\n\tvec2 b = vec2(la, lb);\n\tfloat f = clamp((ndot(b, b - 2.0 * p.xz)) / dot(b, b), -1.0, 1.0);\n\tvec2 q = vec2(length(p.xz - 0.5 * b * vec2(1.0 - f, 1.0 + f)) * sign(p.x * b.y + p.z * b.x - b.x * b.y) - ra, p.y - h);\n\treturn min(max(q.x, q.y), 0.0) + length(max(q, 0.0));\n}\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec4 opElongate(in vec3 p, in vec3 h)\n{\n\tvec3 q = abs(p) - h;\n\treturn vec4(max(q, 0.0), min(max(q.x, max(q.y, q.z)), 0.0));\n}\n//-----------------------------------------------\n\n// ray-infinite-cylinder intersection\nvec2 iCylinderY(in vec3 ro, in vec3 rd, in float rad)\n{\n\tvec3 oc = ro;\n\tfloat a = dot(rd.xz, rd.xz);\n\tfloat b = dot(oc.xz, rd.xz);\n\tfloat c = dot(oc.xz, oc.xz) - rad * rad;\n\tfloat h = b * b - a * c;\n\tif (h < 0.0) return vec2(-1.0);\n\th = sqrt(h);\n\treturn vec2(-b - h, -b + h) / a;\n}\n\n// ray-infinite-cone intersection\nvec2 iConeY(in vec3 ro, in vec3 rd, in float k)\n{\n\tfloat a = dot(rd.xz, rd.xz) - k * rd.y * rd.y;\n\tfloat b = dot(ro.xz, rd.xz) - k * ro.y * rd.y;\n\tfloat c = dot(ro.xz, ro.xz) - k * ro.y * ro.y;\n\n\tfloat h = b * b - a * c;\n\tif (h < 0.0) return vec2(-1.0);\n\th = sqrt(h);\n\treturn vec2(-b - h, -b + h) / a;\n}\n\n//-----------------------------------------------\n\nfloat linearstep(float a, float b, in float x)\n{\n\treturn clamp((x - a) / (b - a), 0.0, 1.0);\n}\n\nvec2 rot(in vec2 p, in float an)\n{\n\tfloat cc = cos(an);\n\tfloat ss = sin(an);\n\treturn mat2(cc, -ss, ss, cc) * p;\n}\n\nfloat expSustainedImpulse(float t, float f, float k)\n{\n\treturn smoothstep(0.0, f, t) * 1.1 - 0.1 * exp2(-k * max(t - f, 0.0));\n}\n\n//-----------------------------------------------\n\nvec3 hash3(uint n)\n{\n\t// integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n\tn = n * (n * n * 15731U + 789221U) + 1376312589U;\n\tuvec3 k = n * uvec3(n, n * 16807U, n * 48271U);\n\treturn vec3(k & uvec3(0x7fffffffU)) / float(0x7fffffff);\n}\n\n//---------------------------------------\n\nfloat noise1(sampler2D tex, in vec2 x)\n{\n\treturn textureLod(tex, (x + 0.5) / 64.0, 0.0).x;\n}\nfloat noise1f(sampler2D tex, in vec2 x)\n{\n\treturn texture(tex, (x + 0.5) / 64.0).x;\n}\n\nfloat fbm1(sampler2D tex, in vec2 x)\n{\n\tfloat f = 0.0;\n\tf += 0.5000 * noise1(tex, x); x *= 2.01;\n\tf += 0.2500 * noise1(tex, x); x *= 2.01;\n\tf += 0.1250 * noise1(tex, x); x *= 2.01;\n\tf += 0.0625 * noise1(tex, x);\n\tf = 2.0 * f - 0.9375;\n\treturn f;\n}\nfloat fbm1f(sampler2D tex, in vec2 x)\n{\n\tfloat f = 0.0;\n\tf += 0.5000 * noise1f(tex, x); x *= 2.01;\n\tf += 0.2500 * noise1f(tex, x); x *= 2.01;\n\tf += 0.1250 * noise1f(tex, x); x *= 2.01;\n\tf += 0.0625 * noise1f(tex, x);\n\tf = 2.0 * f - 0.9375;\n\treturn f;\n}\nfloat bnoise(in float x)\n{\n\tfloat i = floor(x);\n\tfloat f = fract(x);\n\tfloat s = sign(fract(x / 2.0) - 0.5);\n\tfloat k = 0.5 + 0.5 * sin(i);\n\treturn s * f * (f - 1.0) * ((16.0 * k - 4.0) * f * (f - 1.0) - 1.0);\n}\n\nvec3 fbm13(in float x, in float g)\n{\n\tvec3 n = vec3(0.0);\n\tfloat s = 1.0;\n\tfor (int i = 0; i < 6; i++)\n\t{\n\t\tn += s * vec3(bnoise(x), bnoise(x + 13.314), bnoise(x + 31.7211));\n\t\ts *= g;\n\t\tx *= 2.01;\n\t\tx += 0.131;\n\t}\n\treturn n;\n}\n\n// this SDF is really 6 braids at once (through domain repetition)\n// with three strands each (brute forced)\nvec4 sdHair(vec3 p, vec3 pa, vec3 pb, vec3 pc, float an, out vec2 occ_id)\n{\n\tvec4 b = sdBezier(p, pa, pb, pc);\n\tvec2 q = rot(b.zw, an);\n\n\tvec2 id2 = round(q / 0.1);\n\tid2 = clamp(id2, vec2(0), vec2(2, 1));\n\tq -= 0.1 * id2;\n\n\tfloat id = 11.0 * id2.x + id2.y * 13.0;\n\n\tq += smoothstep(0.5, 0.8, b.y) * 0.02 * vec2(0.4, 1.5) * cos(23.0 * b.y + id * vec2(13, 17));\n\n\tocc_id.x = clamp(length(q) * 8.0 - 0.2, 0.0, 1.0);\n\tvec4 res = vec4(99, q, b.y);\n\tfor (int i = 0; i < 3; i++)\n\t{\n\t\tvec2 tmp = q + 0.01 * cos(id + 180.0 * b.y + vec2(2 * i, 6 - 2 * i));\n\t\tfloat lt = length(tmp) - 0.02;\n\t\tif (lt < res.x)\n\t\t{\n\t\t\tocc_id.y = id + float(i);\n\t\t\tres.x = lt;\n\t\t\tres.yz = tmp;\n\t\t}\n\t}\n\treturn res;\n}\n\n// the SDF for the hoodie and jacket. It's a very distorted\n// ellipsoid, torus section, a segment and a sphere.\nvec4 sdHoodie(in vec3 pos)\n{\n\tvec3 opos = pos;\n\n\tpos.x += 0.09 * sin(3.5 * pos.y - 0.5) * sin(pos.z) + 0.015;\n\tpos.xyz += 0.03 * sin(2.0 * pos.y) * sin(7.0 * pos.zyx);\n\n\t// hoodie\n\tvec3 hos = pos - vec3(0.0, -0.33, 0.15);\n\thos.x -= 0.031 * smoothstep(0.0, 1.0, opos.y + 0.33);\n\thos.yz = rot(hos.yz, 0.9);\n\tfloat d1 = sdEllipsoid(hos, vec3(0.96 - pos.y * 0.1, 1.23, 1.5));\n\tfloat d2 = 0.95 * pos.z - 0.312 * pos.y - 0.9;\n\tfloat d = max(opOnion(d1, 0.01), d2);\n\n\t// shoulders\n\tvec3 sos = vec3(abs(pos.x), pos.yz);\n\tvec2 se = sdSegment(sos, vec3(0.18, -1.6, -0.3), vec3(1.1, -1.9, 0.0));\n\td = smin(d, se.x - mix(0.25, 0.43, se.y), 0.4);\n\td = smin(d, sdSphere(sos - vec3(0.3, -2.2, 0.4), 0.5), 0.2);\n\n\t// neck\n\topos.x -= 0.02 * sin(9.0 * opos.y);\n\tvec4 w = opElongate(opos - vec3(0.0, -1.2, 0.3), vec3(0.0, 0.3, 0.0));\n\td = smin(d,\n\t\tw.w + sdCappedTorus(vec3(w.xy, -w.z), vec2(0.6, -0.8), 0.6, 0.02),\n\t\t0.1);\n\n\t// bumps\n\td += 0.004 * sin(pos.x * 90.0) * sin(pos.y * 90.0) * sin(pos.z * 90.0);\n\td -= 0.002 * sin(pos.x * 300.0);\n\td -= 0.02 * (1.0 - smoothstep(0.0, 0.04, abs(opOnion(pos.x, 1.1))));\n\n\t// border\n\td = min(d, length(vec2(d1, d2)) - 0.015);\n\n\treturn vec4(d, pos);\n}\n\n// moves the head (and hair and hoodie). This could be done more\n// efficiently (with a single matrix or quaternion), but this code\n// was optimized for editing, not for runtime :(\nvec3 moveHead(in vec3 pos, in vec3 an, in float amount)\n{\n\tpos.y -= -1.0;\n\tpos.xz = rot(pos.xz, amount * an.x);\n\tpos.xy = rot(pos.xy, amount * an.y);\n\tpos.yz = rot(pos.yz, amount * an.z);\n\tpos.y += -1.0;\n\treturn pos;\n}\n\n// the animation state\nvec3 animData; // { blink, nose follow up, mouth } \nvec3 animHead; // { head rotation angles }\n\n// SDF of the girl. It is not as efficient as it should, both in terms\n// of performance and euclideanness of the returned distance. Among\n// other things I tweaked the overal shape of the head though scaling\n// right in the middle of the design process (see 1.02 and 1.04 numbers\n// below). I should have backpropagated those adjustements to the \n// primitives themselves, but I didn't and now it's too late. So,\n// I am paying some cost there.\n//\n// Generally, she is modeled to camera (her face's shape looks bad from\n// other perspectives. She's made of five ellipsoids blended together for\n// the face, a cone and three spheres for the nose, a torus for the teeh\n// and two quadratic curves for the lips. The neck is a cylinder, the\n// hair is made of three quadratic that are repeated multiple times\n// through domain repetition and each of them contains three more curves\n// in order to make the braids. The hoodie is an ellipsoid deformed with\n// two sine waves and cut in half, the neck is an elongated torus section\n// and the shoulders are capsules.\n//\nvec4 map(in vec3 pos, in float time, out float outMat, out vec3 uvw)\n{\n\toutMat = 1.0;\n\n\tvec3 oriPos = pos;\n\n\t// head deformation and transformation\n\tpos.y /= 1.04;\n\tvec3 opos;\n\topos = moveHead(pos, animHead, smoothstep(-1.2, 0.2, pos.y));\n\tpos = moveHead(pos, animHead, smoothstep(-1.4, -1.0, pos.y));\n\tpos.x *= 1.04;\n\tpos.y /= 1.02;\n\tuvw = pos;\n\n\t// symmetric coord systems (sharp, and smooth)\n\tvec3 qos = vec3(abs(pos.x), pos.yz);\n\tvec3 sos = vec3(sqrt(qos.x * qos.x + 0.0005), pos.yz);\n\n\n\n\t// head\n\tfloat d = sdEllipsoid(pos - vec3(0.0, 0.05, 0.07), vec3(0.8, 0.75, 0.85));\n\n\t// jaw\n\tvec3 mos = pos - vec3(0.0, -0.38, 0.35); mos.yz = rot(mos.yz, 0.4);\n\tmos.yz = rot(mos.yz, 0.1 * animData.z);\n\tfloat d2 = sdEllipsoid(mos - vec3(0, -0.17, 0.16),\n\t\tvec3(0.66 + sclamp(mos.y * 0.9 - 0.1 * mos.z, -0.3, 0.4),\n\t\t\t0.43 + sclamp(mos.y * 0.5, -0.5, 0.2),\n\t\t\t0.50 + sclamp(mos.y * 0.3, -0.45, 0.5)));\n\n\t// mouth hole\n\td2 = smax(d2, -sdEllipsoid(mos - vec3(0, 0.06, 0.6 + 0.05 * animData.z), vec3(0.16, 0.035 + 0.05 * animData.z, 0.1)), 0.01);\n\n\t// lower lip    \n\tvec4 b = sdBezier(vec3(abs(mos.x), mos.yz),\n\t\tvec3(0, 0.01, 0.61),\n\t\tvec3(0.094 + 0.01 * animData.z, 0.015, 0.61),\n\t\tvec3(0.18 - 0.02 * animData.z, 0.06 + animData.z * 0.05, 0.57 - 0.006 * animData.z));\n\tfloat isLip = smoothstep(0.045, 0.04, b.x + b.y * 0.03);\n\td2 = smin(d2, b.x - 0.027 * (1.0 - b.y * b.y) * smoothstep(1.0, 0.4, b.y), 0.02);\n\td = smin(d, d2, 0.19);\n\n\t// chicks\n\td = smin(d, sdSphere(qos - vec3(0.2, -0.33, 0.62), 0.28), 0.04);\n\n\t// who needs ears\n\n\n\t// eye sockets\n\tvec3 eos = sos - vec3(0.3, -0.04, 0.7);\n\teos.xz = rot(eos.xz, -0.2);\n\teos.xy = rot(eos.xy, 0.3);\n\teos.yz = rot(eos.yz, -0.2);\n\td2 = sdEllipsoid(eos - vec3(-0.05, -0.05, 0.2), vec3(0.20, 0.14 - 0.06 * animData.x, 0.1));\n\td = smax(d, -d2, 0.15);\n\n\teos = sos - vec3(0.32, -0.08, 0.8);\n\teos.xz = rot(eos.xz, -0.4);\n\td2 = sdEllipsoid(eos, vec3(0.154, 0.11, 0.1));\n\td = smax(d, -d2, 0.05);\n\n\tvec3 oos = qos - vec3(0.25, -0.06, 0.42);\n\n\t// eyelid\n\td2 = sdSphere(oos, 0.4);\n\toos.xz = rot(oos.xz, -0.2);\n\toos.xy = rot(oos.xy, 0.2);\n\tvec3 tos = oos;\n\toos.yz = rot(oos.yz, -0.6 + 0.58 * animData.x);\n\n\t//eyebags\n\ttos = tos - vec3(-0.02, 0.06, 0.2 + 0.02 * animData.x);\n\ttos.yz = rot(tos.yz, 0.8);\n\ttos.xy = rot(tos.xy, -0.2);\n\td = smin(d, sdTorus(tos, 0.29, 0.01), 0.03);\n\n\t// eyelids\n\teos = qos - vec3(0.33, -0.07, 0.53);\n\teos.xy = rot(eos.xy, 0.2);\n\teos.yz = rot(eos.yz, 0.35 - 0.25 * animData.x);\n\td2 = smax(d2 - 0.005, -max(oos.y + 0.098, -eos.y - 0.025), 0.02);\n\td = smin(d, d2, 0.012);\n\n\t// eyelashes\n\toos.x -= 0.01;\n\tfloat xx = clamp(oos.x + 0.17, 0.0, 1.0);\n\tfloat ra = 0.35 + 0.1 * sqrt(xx / 0.2) * (1.0 - smoothstep(0.3, 0.4, xx)) * (0.6 + 0.4 * sin(xx * 256.0));\n\tfloat rc = 0.18 / (1.0 - 0.7 * smoothstep(0.15, 0.5, animData.x));\n\toos.y -= -0.18 - (rc - 0.18) / 1.8;\n\td2 = (1.0 / 1.8) * sdArc(oos.xy * vec2(1.0, 1.8), vec2(0.9, sqrt(1.0 - 0.9 * 0.9)), rc) - 0.001;\n\tfloat deyelashes = max(d2, length(oos.xz) - ra) - 0.003;\n\n\t// nose\n\teos = pos - vec3(0.0, -0.079 + animData.y * 0.005, 0.86);\n\teos.yz = rot(eos.yz, -0.23);\n\tfloat h = smoothstep(0.0, 0.26, -eos.y);\n\td2 = sdCone(eos - vec3(0.0, -0.02, 0.0), vec2(0.03, -0.25)) - 0.04 * h - 0.01;\n\teos.x = sqrt(eos.x * eos.x + 0.001);\n\td2 = smin(d2, sdSphere(eos - vec3(0.0, -0.25, 0.037), 0.06), 0.07);\n\td2 = smin(d2, sdSphere(eos - vec3(0.1, -0.27, 0.03), 0.04), 0.07);\n\td2 = smin(d2, sdSphere(eos - vec3(0.0, -0.32, 0.05), 0.025), 0.04);\n\td2 = smax(d2, -sdSphere(eos - vec3(0.07, -0.31, 0.038), 0.02), 0.035);\n\td = smin(d, d2, 0.05 - 0.03 * h);\n\n\t// mouth\n\teos = pos - vec3(0.0, -0.38 + animData.y * 0.003 + 0.01 * animData.z, 0.71);\n\ttos = eos - vec3(0.0, -0.13, 0.06);\n\ttos.yz = rot(tos.yz, 0.2);\n\tfloat dTeeth = sdTorus(tos, 0.15, 0.015);\n\teos.yz = rot(eos.yz, -0.5);\n\teos.x /= 1.04;\n\n\t// nose-to-upperlip connection\n\td2 = sdCone(eos - vec3(0, 0, 0.03), vec2(0.14, -0.2)) - 0.03;\n\td2 = max(d2, -(eos.z - 0.03));\n\td = smin(d, d2, 0.05);\n\n\t// upper lip\n\teos.x = abs(eos.x);\n\tb = sdBezier(eos, vec3(0.00, -0.22, 0.17),\n\t\tvec3(0.08, -0.22, 0.17),\n\t\tvec3(0.17 - 0.02 * animData.z, -0.24 - 0.01 * animData.z, 0.08));\n\td2 = length(b.zw / vec2(0.5, 1.0)) - 0.03 * clamp(1.0 - b.y * b.y, 0.0, 1.0);\n\td = smin(d, d2, 0.02);\n\tisLip = max(isLip, (smoothstep(0.03, 0.005, abs(b.z + 0.015 + abs(eos.x) * 0.04))\n\t\t- smoothstep(0.45, 0.47, eos.x - eos.y * 1.15)));\n\n\t// valley under nose\n\tvec2 se = sdSegment(pos, vec3(0.0, -0.45, 1.01), vec3(0.0, -0.47, 1.09));\n\td2 = se.x - 0.03 - 0.06 * se.y;\n\td = smax(d, -d2, 0.04);\n\tisLip *= smoothstep(0.01, 0.03, d2);\n\n\t// neck\n\tse = sdSegment(pos, vec3(0.0, -0.65, 0.0), vec3(0.0, -1.7, -0.1));\n\td2 = se.x - 0.38;\n\n\t// shoulders\n\tse = sdSegment(sos, vec3(0.0, -1.55, 0.0), vec3(0.6, -1.65, 0.0));\n\td2 = smin(d2, se.x - 0.21, 0.1);\n\td = smin(d, d2, 0.4);\n\n\t// register eyelases now\n\tvec4 res = vec4(d, isLip, 0, 0);\n\tif (deyelashes < res.x)\n\t{\n\t\tres.x = deyelashes * 0.8;\n\t\tres.yzw = vec3(0.0, 1.0, 0.0);\n\t}\n\t// register teeth now\n\tif (dTeeth < res.x)\n\t{\n\t\tres.x = dTeeth;\n\t\toutMat = 5.0;\n\t}\n\n\t// eyes\n\tpos.x /= 1.05;\n\teos = qos - vec3(0.25, -0.06, 0.42);\n\td2 = sdSphere(eos, 0.4);\n\tif (d2 < res.x)\n\t{\n\t\tres.x = d2;\n\t\toutMat = 2.0;\n\t\tuvw = pos;\n\t}\n\n\t// hair\n\t{\n\t\tvec2 occ_id, tmp;\n\t\tqos = pos; qos.x = abs(pos.x);\n\n\t\tvec4 pres = sdHair(pos, vec3(-0.3, 0.55, 0.8),\n\t\t\tvec3(0.95, 0.7, 0.85),\n\t\t\tvec3(0.4, -1.45, 0.95),\n\t\t\t-0.9, occ_id);\n\n\t\tvec4 pres2 = sdHair(pos, vec3(-0.4, 0.6, 0.55),\n\t\t\tvec3(-1.0, 0.4, 0.2),\n\t\t\tvec3(-0.6, -1.4, 0.7),\n\t\t\t0.6, tmp);\n\t\tif (pres2.x < pres.x) { pres = pres2; occ_id = tmp;  occ_id.y += 40.0; }\n\n\t\tpres2 = sdHair(qos, vec3(0.4, 0.7, 0.4),\n\t\t\tvec3(1.0, 0.5, 0.45),\n\t\t\tvec3(0.4, -1.45, 0.55),\n\t\t\t-0.2, tmp);\n\t\tif (pres2.x < pres.x) { pres = pres2; occ_id = tmp;  occ_id.y += 80.0; }\n\n\n\t\tpres.x *= 0.8;\n\t\tif (pres.x < res.x)\n\t\t{\n\t\t\tres = vec4(pres.x, occ_id.y, 0.0, occ_id.x);\n\t\t\tuvw = pres.yzw;\n\t\t\toutMat = 4.0;\n\t\t}\n\t}\n\n\t// hoodie\n\tvec4 tmp = sdHoodie(opos);\n\tif (tmp.x < res.x)\n\t{\n\t\tres.x = tmp.x;\n\t\toutMat = 3.0;\n\t\tuvw = tmp.yzw;\n\t}\n\n\treturn res;\n}\n\nfloat sdf( vec3 p ) {\n    float boxD = sdBox(p, vec3(1.,1.,1.));\n    p += vec3(0.0,-0.2,0.0);\n    //p *= RotMat(vec3(0.,1.,0.), -pi/2.);\n    const float scale = 0.6;\n    p *= (1.0 / scale);\n    //return map(p).d * scale;\n    float matID;\n    vec3 uvw;\n    vec4 tmp = map(p, TIME, matID, uvw);\n    return max(boxD, tmp.x) * 0.5;\n}\n\n//Created by Kelvin_Z\n//2022.10.27\n\nconst float pi = 3.1415;\nint tracingFlag = 2; // 0:    normal_sphere_trace\n                     // 1:    relaxed_sphere_trace\n                     // else: enhance_sphere_trace\n\n//定义射线\nstruct Ray\n{\n\tvec3 p;         //起点\n\tvec3 v;         //方向\n\tfloat Tmin;\n\tfloat Tmax;\n};\n//定义求交结果\nstruct TraceResult\n{\n    float T;\t\t// Distance taken on ray\n    int flags;\t\t// 0:   travelled to far t > t_max\n                    // 1:   distance to surface is small < error threshold\n                    // 2:   took too many iterations\n    int steps;\n};\n//Trace参数\nstruct SphereTraceDesc\n{\n    float epsilon;  // Stopping distance to surface\n    int maxSetps;   // Maximum iteration count\n};\n\nTraceResult normal_sphere_trace(in Ray ray, in SphereTraceDesc params)\n{\n    TraceResult ret = TraceResult(ray.Tmin, 0, 0);\n    float d;\n    \n    int i = 0; \n    do\n    {\n        d = sdf(ray.p+ret.T*ray.v);\n        ret.T+=d;\n        ++i;\n    } while (\n\t\tret.T < ray.Tmax &&       \t\t\t// Stay within bound box\n\t\td\t  > params.epsilon * ret.T &&\t// Stop if cone is close to surface\n\t\ti     < params.maxSetps\t        \t// Stop if too many iterations\n\t);\n    \n    ret.steps = i;\n    ret.flags =  int(ret.T >= ray.Tmax)\n              | (int(d <= params.epsilon* ret.T)  << 1)\n              | (int(i >= params.maxSetps) << 2);\n    return ret;\n}\n\nTraceResult relaxed_sphere_trace(in Ray ray, in SphereTraceDesc params)\n{\n    TraceResult ret = TraceResult(ray.Tmin, 0, 0);\n    float d = 0.0;\n    float prev_t = ray.Tmin;\n    float prev_d = 0.;\n    const float omega = 1.6;\n    \n    int i = 0; do\n    {\n        prev_d = d;\n        \n        d = sdf(ray.p+ret.T*ray.v);\n        \n        // If the bigger step was a mistake\n        if (prev_d + d < omega * prev_d)\n        {\n            // Step back and take a normal step\n            ret.T = prev_t + prev_d;\n            d = sdf(ray.p+ret.T*ray.v);\n            ++i;\n        }\n        \n        prev_t = ret.T;\n        ret.T += d * omega;\n        \n        ++i;\n    } while (\n\t\tprev_t < ray.Tmax &&       \t\t\t// Stay within bound box\n\t\td\t  > params.epsilon * prev_t &&\t// Stop if cone is close to surface\n\t\ti     < params.maxSetps\t        \t// Stop if too many iterations\n\t);\n    \n    ret.T = prev_t;\n    ret.steps = i;\n    ret.flags =  int(ret.T >= ray.Tmax)\n              | (int(d <= params.epsilon* ret.T)  << 1)\n              | (int(i >= params.maxSetps) << 2);\n    return ret;\n}\n\nTraceResult enhanced_sphere_trace(in Ray ray, in SphereTraceDesc params)\n{\n    TraceResult ret = TraceResult(ray.Tmin, 0, 0);\n    float d = 0.0;\n    float prev_t = ray.Tmin;\n    float prev_d = 0.;\n    const float omega = 0.9;\n    float next_d = 0.;\n    \n    int i = 0; do\n    {\n        prev_d = d;\n        \n        d = sdf(ray.p+ret.T*ray.v);\n        \n        // If the bigger step was a mistake\n        if (d < omega * next_d || d < 0.)\n        {\n            // Step back and take a normal step\n            ret.T = prev_t + prev_d;\n            d = sdf(ray.p+ret.T*ray.v);\n        }\n        \n        float diff_d = d - prev_d;\n        float diff_t = ret.T - prev_t;\n        next_d = diff_t - diff_d > 0. ? d * (diff_t + diff_d) / (diff_t - diff_d) : 0.;\n        next_d = max(0., next_d);\n        \n        prev_t = ret.T;\n        ret.T += d + next_d * omega;\n        \n        ++i;\n    } while (\n\t\tprev_t < ray.Tmax &&       \t\t\t// Stay within bound box\n\t\td\t  > params.epsilon * prev_t &&\t// Stop if cone is close to surface\n\t\ti     < params.maxSetps\t        \t// Stop if too many iterations\n\t);\n    \n    ret.T = prev_t;\n    ret.steps = i;\n    ret.flags =  int(ret.T >= ray.Tmax)\n              | (int(d <= params.epsilon* ret.T)  << 1)\n              | (int(i >= params.maxSetps) << 2);\n    return ret;\n}\n\n//选择trace方式\nTraceResult raymarching(in Ray ray, in SphereTraceDesc params)\n{\n    if (tracingFlag == 0)\n        return normal_sphere_trace(ray, params);\n    \n    if (tracingFlag == 1)\n    \treturn relaxed_sphere_trace(ray, params);\n    \n    return enhanced_sphere_trace(ray, params);\n}\n\n// ---- 着色 ----\n\n// 法线计算\nvec3 normal(const in vec3 p)\n{\n\t// Center sample\n\tfloat c = sdf(p);\n\t// Use offset samples to compute gradient / normal\n\tvec2 eps_zero = vec2(0.001, 0.0);\n\treturn normalize(vec3(\n\t\tsdf(p + eps_zero.xyy),\n\t\tsdf(p + eps_zero.yxy),\n\t\tsdf(p + eps_zero.yyx)) - c);\n}\n\nvec4 skyColor(Ray ray)\n{\n    // 天空盒\n    vec3 fogColor = vec3(0.30, 0.36, 0.60);\n    vec3 col = fogColor - ray.v * 0.4;\n    return vec4(col, 1.0);\n}\n\nvec4 errorColor(Ray ray, float t)\n{\n    return vec4(1.,0.,0.,1.);\n}\n\nvec3 lightPos = vec3(10.,10.,10.);\n\nvec4 hitColor(Ray ray,float t)\n{\n    vec3 p = ray.p + ray.v*t;\n    vec3 n = normal(p);\n    \n    vec3 lightPos=vec3(10.,10.,10.);\n    \n    vec3 v = -ray.v;\n    vec3 l = normalize(lightPos-p);\n    \n    //diffuse\n    float costheta = max(dot(n,l),0.);\n    vec3 k_d = vec3(1./pi, 2./pi, 3./pi);\n    \n    //specular\n    vec3 toLight = normalize(lightPos - p);\n    vec3 toEye = -ray.v;\n    vec3 k_s = vec3(0.4);\n    \n    Ray shadow_ray = Ray(p, l, 0.05, distance(p,lightPos));\n    \n    SphereTraceDesc params = SphereTraceDesc(0.0006, 64);\n    TraceResult result = raymarching(shadow_ray, params);\n\n    vec3 h = normalize(toLight+toEye);\n    float si = pow(clamp(dot(h,n),0.,1.),160.);\n    \n    //sum\n    vec3 col = (k_d + si*k_s)*costheta;\n    \n    // if(bool(result.flags)) \n    // {\n    //     col = vec3(0);\n    // }\n    \n    return vec4(col,1.);\n}\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n\tvec3 camForward = normalize(camTarget - camPos);\n\tvec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camForward));\n\tvec3 camUp = normalize(cross(camForward, camRight));\n\n    // fPersp controls the camera's field of view. Try changing it!\n    float fPersp = 1.5;\n\tvec3 vDir = normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);\n\n\treturn vDir;\n}\n\nRay Camera(vec2 fragCoord, out vec3 camPos, out vec2 data2)\n{\n    // Ray generation\n    vec3 camTarget = vec3(0, 0, 0);\n    vec2 uv2 = 2.0 * (fragCoord/iResolution.xy - 0.5);\n    uv2.x *= iResolution.x/iResolution.y; // Correct for aspect ratio\n\n    vec3 vDir = getCameraRayDir(uv2, camPos, camTarget);\n    \n    // Ray generation\n    return Ray(camPos,\n               vDir,\n               0.05,\t\t\t\t\t\t//minT\n               500.);\t\t\t\t\t\t//maxT\n}\n\n// ---- MAIN ----\nvoid renderScene(in Ray ray, out vec4 fragColor)\n{\n    // Set epsilon and maximum iteration\n    SphereTraceDesc params = SphereTraceDesc(0.0006, 64);\n    \n    // Raytrace\n    TraceResult result = raymarching(ray, params);\n    \n    if(bool(result.flags == 1))    \n        fragColor = skyColor(ray);    \n    else if(bool(result.flags == 2)) \n        fragColor = hitColor(ray, result.T);\n    else \t        \t\t\t  \n        fragColor = errorColor(ray, result.T);\n        \n    fragColor.w = float(result.steps);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Generate ray from pixel\n    vec3 camPos = vec3(0, 0, 2); //camrea pos\n    vec2 data;\n\n    Ray ray = Camera(fragCoord, camPos, data);\n    \n\trenderScene(ray, fragColor);\n}","name":"Image","description":"","type":"image"}]}