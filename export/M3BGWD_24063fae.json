{"ver":"0.1","info":{"id":"M3BGWD","date":"1708454886","viewed":43,"name":"Raymarching lighting base","username":"therepo90","description":"base, its generally a copy but simplified version of iq tutorial(code from yt video).","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float map(vec3 p) {\n \n    float sp1 = sdBox(p-vec3(1.5,0.,0.),vec3(1.));\n     float ground = p.y+1.; \n    float objs[OBJ_CNT];\n    objs[0]=sp1; \n     objs[1]=ground; \n    //float result = sminArr(objs, 0.5);\n    //return result;\n    return min(sp1,ground);\n}\n\n\n\nfloat rayMarch(vec3 ro,vec3 rd) { // get distance to closest object\n    float t = 0.;  \n    float tmax = 40.0;\n    for (int i = 0; i < 80; i++) {\n        vec3 p = ro + rd * t;      \n\n        float d = map(p);          \n\n        t += d;                    \n\n        if (d < .01) break; //@TODO for some reason .00001 gives artifacts.      \n        if (t > tmax) break;       \n    }\n    if(t > tmax) {\n        t=-1.; // object hit -> t>0, obj not hit - t<0\n    }\n    return t;\n}\n\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(0.0005,0.0);\n    return normalize( vec3( \n        map( pos + e.xyy ) - map( pos - e.xyy ),\n\t\tmap( pos + e.yxy ) - map( pos - e.yxy ),\n\t\tmap( pos + e.yyx ) - map( pos - e.yyx ) ) );\n}\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n \n   \n    float fov = 1.;\n    vec3 ro = vec3(0, 0, 4.5); // ro is placed before the screen, -z is towards the screen          \n    vec3 rd = normalize(vec3(uv*fov, -1.5)); // dir is pointed towards the screen  \n    vec3 col = vec3(0.6,.7,.8) - 0.5*rd.y;\n    float t = rayMarch(ro,rd);\n    if(t>0.){\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n        //col=vec3(t)*.1;\n        //col=nor;\n        vec3 mate = vec3(.18);\n        vec3  sun_dir = normalize( vec3(0.8, 0.4, 0.2) );\n        float sun_dif = clamp(dot( nor, sun_dir ), 0.0, 1.0 );\n        float bou_dif= clamp(0.5+0.5*dot(nor,vec3(0.,-1.,0.)),0.,1.);\n        float sky_dif= clamp(0.5+0.5*dot(nor,vec3(0.,1.,0.)),0.,1.);\n        //shadows, step to invert. Hit, >0 means make result 0, Not hit, <0, make it 1.\n        // if hit we want to show 0 value which is shadow.\n        float sun_sha = step(rayMarch(pos+nor*0.01,sun_dir), 0.); \n        col=mate*vec3(7.,5.,3.)*sun_dif*sun_sha;\n        //col+=mate*vec3(.7,.3,.2)*bou_dif;\n        col+=mate*vec3(0.5,0.8,.9)*sky_dif;\n        //col=nor.zzz;\n    }\n    \n     col = pow( col, vec3(0.4545) ); // gamma correction\n     \n    fragColor = vec4(col, 1.); \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define OBJ_CNT 2\n\nfloat smoothstep3(float edge0, float edge1, float edge2, float x) {\n    return clamp((smoothstep(edge0, edge1, x) - smoothstep(edge1, edge2, x)), 0.0, 1.0);\n}\nfloat sdSphere( vec3 p, float s ) // s -radius\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n \n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat sminArr(float values[OBJ_CNT], float k) {\n    float result = values[0];\n\n    for (int i = 1; i < OBJ_CNT; i++) {\n        result = smin(result, values[i], k);\n    }\n\n    return result;\n}\n\n\nmat2 rot2D(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n","name":"Common","description":"","type":"common"}]}