{"ver":"0.1","info":{"id":"XcXcRS","date":"1721222302","viewed":80,"name":"sws3005-2024Summer-G9","username":"Steven_Qsi","description":"a brief 3D model about some primitives. It won't appears normally until 19/7/2024.   —— 17/7/2024\nNow it's published. Although it's rough and has some bug, it's my group's first trying. We will continue on it. —— 19/7/2024","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//============================================================================\n// PROJECT ID: Task2_By_Group9\n//\n// GROUP NUMBER: 09\n//\n// STUDENT NAME: He Qijun\n// NUS User ID.: t0933264\n//\n// STUDENT NAME: Wang Zhuo\n// NUS User ID.: t0933474\n//\n// STUDENT NAME: Chen Yiran\n// NUS User ID.: t0933842\n//\n// COMMENTS TO GRADER: This is a scene describing a creeper chasing a villager in an island on a sea of floating lava\n//                     where the lands will be distorted by each step the villager take.\n//\n//============================================================================\n\n//============================================================================\n// Constants.\n//============================================================================\nconst float PI = 3.141592653589793;\n\nconst vec3 BACKGROUND_COLOR = vec3(0.1, 0.2, 0.6);\n\n// Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * PI / 180.0;\n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Use this for the camera rotation velocity.\nconst float CAM_V = 0.5;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\n// Constants for the scene objects.\nconst int NUM_LIGHTS = 2;\nconst int NUM_MATERIALS = 20;\nconst int NUM_PLANES = 3;\nconst int NUM_SPHERES = 5;\nconst int NUM_CUBES = 23;\nconst int NUM_CYLINDERS = 1;\n\n// status bonus\nint status = 2;\nint lava = 2;\nfloat speed1 = 1.5;\nfloat speed2 = 1.5;\nvec3 cc1 = vec3(7.5, 4.2, 0.0);\nvec3 cc2 = vec3(-7.5, 4.2, 0.0);\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Cube_t {\n    vec3 rad; // the length width height\n    vec3 center; // the center 's position\n    int materialID;\n    mat4 M; //determine the rotation\n};\nstruct Cylinder_t {\n    vec3 center;\n    float radius, height;\n    int materialID;\n};\n\nstruct MC_human {\n    vec3 center;\n    float d;\n    Cube_t head;\n    Cube_t body;\n    Cube_t eyebrown;\n    Cube_t leye;\n    Cube_t reye;\n    Cube_t rpupil;\n    Cube_t lpupil;\n    Cube_t nose;\n    Cube_t left_arm;\n    Cube_t right_arm;\n    Cube_t left_leg;\n    Cube_t right_leg;\n};\n\nstruct Creeper {\n    vec3 center;\n    float d;\n    Cube_t head;\n    Cube_t body;\n    Cube_t foot1; // left front\n    Cube_t foot2; // right front\n    Cube_t foot3; // left back\n    Cube_t foot4; // right back\n    Cube_t leye;\n    Cube_t reye;\n    Cube_t mouth1;\n    Cube_t mouth2;\n    Cube_t mouth3;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0.\n};\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nCube_t Cube[NUM_CUBES];\nCylinder_t Cylinder[NUM_CYLINDERS];\n\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\nMC_human Human;\nCreeper creeper;\n\n//============================================================================\n// Create Functions.\n//============================================================================\nPlane_t CreatePlane(float A, float B, float C, float D, int materialID) {\n    Plane_t pln;\n    pln.A = A;\n    pln.B = B;\n    pln.C = C;\n    pln.D = D;\n    pln.materialID = materialID;\n    return pln;\n}\n\nSphere_t CreateSphere(vec3 center, float radius, int materialID) {\n    Sphere_t sph;\n    sph.center = center;\n    sph.radius = radius;\n    sph.materialID = materialID;\n    return sph;\n}\n\nCube_t CreateCube(vec3 rad, vec3 center, mat4 M, int materialID) {\n    Cube_t cube;\n    cube.rad = rad;\n    cube.center = center;\n    cube.M = M;\n    cube.materialID = materialID;\n    return cube;\n}\n\n// Create a material.\nMaterial_t CreateMaterial(vec3 k_a, vec3 k_d, vec3 k_r, float n) {\n    Material_t mat;\n    mat.k_d = k_d;\n    mat.k_a = k_a;\n    mat.k_r = k_r;\n    mat.k_rg = 0.5 * k_r;\n    mat.n = n;\n    return mat;\n}\n\n// Create a light.\nLight_t CreateLight(vec3 position, vec3 I_a, vec3 I_source) {\n    Light_t light;\n    light.position = position;\n    light.I_a = I_a;\n    light.I_source = I_source;\n    return light;\n}\n\nmat4 rotationMatrix(vec3 u, float theta) {\n    float cosT = cos(theta);\n    float sinT = sin(theta);\n    float oneMinusCosT = 1.0 - cosT;\n    vec3 u2 = u * u;\n\n    return mat4(vec4(cosT + u2.x * oneMinusCosT, u.x * u.y * oneMinusCosT - u.z * sinT, u.x * u.z * oneMinusCosT + u.y * sinT, 0), \n                vec4(u.y * u.x * oneMinusCosT + u.z * sinT, cosT + u2.y * oneMinusCosT, u.y * u.z * oneMinusCosT - u.x * sinT, 0), \n                vec4(u.z * u.x * oneMinusCosT - u.y * sinT, u.z * u.y * oneMinusCosT + u.x * sinT, cosT + u2.z * oneMinusCosT, 0), \n                vec4(0, 0, 0, 1));\n}\n\nmat4 translationMatrix(vec3 t) {\n    return mat4(vec4(1, 0, 0, 0), vec4(0, 1, 0, 0), vec4(0, 0, 1, 0), vec4(-t, 1));\n}\n\nMC_human CreateHuman(vec3 center, float d, float size) {\n    MC_human human;\n    center *= size;\n    human.center = center;\n    human.d = d;\n    // the whole human should rotate around the center Hard_R\n    mat4 Hard_R = rotationMatrix(vec3(0.0, 1.0, 0.0), d);\n    mat4 Hard_T = translationMatrix(center);\n\n    // body mat\n    mat4 R = Hard_R;\n    mat4 T = Hard_T;\n    mat4 M = R * T;\n    human.body = CreateCube(vec3(1.0, 2.0, 0.75) * size, center, M, 9);\n    Cube[0] = human.body;\n\n    // head mat\n    vec3 axis = normalize(vec3(0.0, 1.0, 0.0));\n    float angle = 0.0;\n    vec3 head_c = size * vec3(0.0, 2.77, 0.0);\n    R = rotationMatrix(axis, angle);\n    T = translationMatrix(head_c);\n    M = R * T * Hard_R * Hard_T;\n    human.head = CreateCube(vec3(1.0, 1.2, 1.0) * size, head_c, M, 7);\n    Cube[1] = human.head;\n\n    // eyebrow\n    vec3 eb_c = size * vec3(0.0, 2.77, 1.0);\n    T = translationMatrix(eb_c);\n    M = R * T * Hard_R * Hard_T;\n    human.eyebrown = CreateCube(vec3(0.8, 0.1, 0.03) * size, eb_c, M, 8);\n    Cube[2] = human.eyebrown;\n\n    // right eye\n    vec3 re_c = size * vec3(0.67, 2.57, 1.0);\n    T = translationMatrix(re_c);\n    M = R * T * Hard_R * Hard_T;\n    human.reye = CreateCube(vec3(0.13, 0.15, 0.03) * size, re_c, M, 9);\n    Cube[3] = human.reye;\n\n    // left eye\n    vec3 le_c = size * vec3(-0.67, 2.57, 1.0);\n    T = translationMatrix(le_c);\n    M = R * T * Hard_R * Hard_T;\n    human.leye = CreateCube(vec3(0.13, 0.15, 0.03) * size, le_c, M, 9);\n    Cube[4] = human.leye;\n\n    // right pupil\n    vec3 rp_c = size * vec3(0.41, 2.57, 1.0);\n    T = translationMatrix(rp_c);\n    M = R * T * Hard_R * Hard_T;\n    human.rpupil = CreateCube(vec3(0.13, 0.15, 0.03) * size, rp_c, M, 10);\n    Cube[5] = human.rpupil;\n\n    // left pupil\n    vec3 lp_c = size * vec3(-0.41, 2.57, 1.0);\n    T = translationMatrix(lp_c);\n    M = R * T * Hard_R * Hard_T;\n    human.lpupil = CreateCube(vec3(0.13, 0.15, 0.03) * size, lp_c, M, 10);\n    Cube[6] = human.lpupil;\n\n    // nose\n    vec3 nose_c = size * vec3(0.0, 2.07, 1.2);\n    T = translationMatrix(nose_c);\n    M = R * T * Hard_R * Hard_T;\n    human.nose = CreateCube(vec3(0.28, 0.45, 0.2) * size, nose_c, M, 7);\n    Cube[7] = human.nose;\n\n    // left arm mat\n    axis = normalize(vec3(1.0, 0.0, 0.0));\n    angle = sin(6.0 * iTime) / 360.0 * PI * 90.0;\n    vec3 left_arm_c = size * vec3(1.255, 1.9 - 1.5 * abs(cos(angle)), -1.5 * sin(angle));\n    R = rotationMatrix(axis, angle);\n    T = translationMatrix(left_arm_c);\n    M = R * T * Hard_R * Hard_T;\n    human.left_arm = CreateCube(vec3(0.5, 1.5, 0.5) * size, left_arm_c, M, 7);\n    Cube[8] = human.left_arm;\n\n    // right arm mat\n    axis = normalize(vec3(1.0, 0.0, 0.0));\n    angle = sin(6.0 * iTime + PI) / 360.0 * PI * 90.0;\n    vec3 right_arm_c = size * vec3(-1.255, 1.9 - 1.5 * abs(cos(angle)), -1.5 * sin(angle));\n    R = rotationMatrix(axis, angle);\n    T = translationMatrix(right_arm_c);\n    M = R * T * Hard_R * Hard_T;\n    human.right_arm = CreateCube(vec3(0.5, 1.5, 0.5) * size, right_arm_c, M, 7);\n    Cube[9] = human.right_arm;\n\n    // left leg mat\n    angle = sin(6.0 * iTime + PI) / 360.0 * PI * 90.0;\n    vec3 left_leg_c = size * vec3(0.5, -2.0 - 1.5 * abs(cos(angle)), -1.5 * sin(angle));\n    R = rotationMatrix(axis, angle);\n    T = translationMatrix(left_leg_c);\n    M = R * T * Hard_R * Hard_T;\n    human.left_leg = CreateCube(vec3(0.425, 1.5, 0.65) * size, left_leg_c, M, 7);\n    Cube[10] = human.left_leg;\n\n    // right leg mat\n    angle = sin(6.0 * iTime) / 360.0 * PI * 90.0;\n    vec3 right_leg_c = size * vec3(-0.5, -2.0 - 1.5 * abs(cos(angle)), -1.5 * sin(angle));\n    R = rotationMatrix(axis, angle);\n    T = translationMatrix(right_leg_c);\n    M = R * T * Hard_R * Hard_T;\n    human.right_leg = CreateCube(vec3(0.425, 1.5, 0.65) * size, right_leg_c, M, 7);\n    Cube[11] = human.right_leg;\n\n    return human;\n}\n\nCreeper CreateCreeper(vec3 center, float d, float size) {\n    Creeper creeper;\n    center *= size;\n    creeper.center = center;\n    creeper.d = d;\n\n    int mat_1, mat_2;\n    if(status == 2) {\n        mat_1 = 2;\n        mat_2 = 3;\n    } else {\n        mat_1 = 9;\n        mat_2 = 9;\n    }\n\n    // the whole creeper should rotate around the center Hard_R\n    mat4 Hard_R = rotationMatrix(vec3(0.0, 1.0, 0.0), d);\n    mat4 Hard_T = translationMatrix(center);\n\n    // body mat(all y minus 4.0)\n    mat4 R = Hard_R;\n    mat4 T = Hard_T;\n    mat4 M = R * T;\n    creeper.body = CreateCube(vec3(1.0, 2.0, 1.0) * size, center, M, mat_1);\n    Cube[12] = creeper.body;\n\n    // head mat\n    vec3 axis = normalize(vec3(0.0, 1.0, 0.0));\n    float angle = 0.0;\n    vec3 head_c = size * vec3(0.0, 3.0, 0.0);\n    R = rotationMatrix(axis, angle);\n    T = translationMatrix(head_c);\n    M = R * T * Hard_R * Hard_T;\n    creeper.head = CreateCube(vec3(1.2, 1.2, 1.2) * size, head_c, M, mat_1);\n    Cube[13] = creeper.head;\n\n    // left front foot mat\n    axis = normalize(vec3(1.0, 0.0, 0.0));\n    angle = sin(6.0 * iTime) / 360.0 * PI * 90.0;\n    vec3 lf_c = size * vec3(0.5, -2.0 - 1.0 * abs(cos(angle)), 1.0 - sin(angle));\n    R = rotationMatrix(axis, angle);\n    T = translationMatrix(lf_c);\n    M = R * T * Hard_R * Hard_T;\n    creeper.foot1 = CreateCube(vec3(0.5, 1.0, 0.5) * size, lf_c, M, mat_1);\n    Cube[14] = creeper.foot1;\n\n    // right front foot mat\n    axis = normalize(vec3(1.0, 0.0, 0.0));\n    angle = sin(6.0 * iTime + PI) / 360.0 * PI * 90.0;\n    vec3 rf_c = size * vec3(-0.5, -2.0 - 1.0 * abs(cos(angle)), 1.0 - sin(angle));\n    R = rotationMatrix(axis, angle);\n    T = translationMatrix(rf_c);\n    M = R * T * Hard_R * Hard_T;\n    creeper.foot2 = CreateCube(vec3(0.5, 1.0, 0.5) * size, rf_c, M, mat_1);\n    Cube[15] = creeper.foot2;\n\n    // left back foot mat\n    angle = sin(6.0 * iTime + PI) / 360.0 * PI * 90.0;\n    vec3 lb_c = size * vec3(0.5, -2.0 - 1.0 * abs(cos(angle)), -1.0 - sin(angle));\n    R = rotationMatrix(axis, angle);\n    T = translationMatrix(lb_c);\n    M = R * T * Hard_R * Hard_T;\n    creeper.foot3 = CreateCube(vec3(0.5, 1.0, 0.5) * size, lb_c, M, mat_1);\n    Cube[16] = creeper.foot3;\n\n    // right back foot mat\n    angle = sin(6.0 * iTime) / 360.0 * PI * 90.0;\n    vec3 rb_c = size * vec3(-0.5, -2.0 - 1.0 * abs(cos(angle)), -1.0 - sin(angle));\n    R = rotationMatrix(axis, angle);\n    T = translationMatrix(rb_c);\n    M = R * T * Hard_R * Hard_T;\n    creeper.foot4 = CreateCube(vec3(0.5, 1.0, 0.5) * size, rb_c, M, mat_1);\n    Cube[17] = creeper.foot4;\n\n    // left eye mat\n    axis = normalize(vec3(0.0, 1.0, 0.0));\n    angle = 0.0;\n    vec3 le_c = size * vec3(0.5, 3.5, 1.23);\n    R = rotationMatrix(axis, angle);\n    T = translationMatrix(le_c);\n    M = R * T * Hard_R * Hard_T;\n    creeper.leye = CreateCube(vec3(0.3, 0.3, 0.1) * size, le_c, M, mat_2);\n    Cube[18] = creeper.leye;\n\n    // right eye mat\n    vec3 re_c = size * vec3(-0.5, 3.5, 1.23);\n    T = translationMatrix(re_c);\n    M = R * T * Hard_R * Hard_T;\n    creeper.reye = CreateCube(vec3(0.3, 0.3, 0.1) * size, re_c, M, mat_2);\n    Cube[19] = creeper.reye;\n\n    // mouth1 mat\n    vec3 mouth1_c = size * vec3(0.5, 2.4, 1.23);\n    T = translationMatrix(mouth1_c);\n    M = R * T * Hard_R * Hard_T;\n    creeper.mouth1 = CreateCube(vec3(0.2, 0.4, 0.1) * size, mouth1_c, M, mat_2);\n    Cube[20] = creeper.mouth1;\n\n    // mouth2 mat\n    vec3 mouth2_c = size * vec3(-0.5, 2.4, 1.23);\n    T = translationMatrix(mouth2_c);\n    M = R * T * Hard_R * Hard_T;\n    creeper.mouth2 = CreateCube(vec3(0.2, 0.4, 0.1) * size, mouth2_c, M, mat_2);\n    Cube[21] = creeper.mouth2;\n\n    // mouth3 mat\n    vec3 mouth3_c = size * vec3(0.0, 2.7, 1.23);\n    T = translationMatrix(mouth3_c);\n    M = R * T * Hard_R * Hard_T;\n    creeper.mouth3 = CreateCube(vec3(0.3, 0.5, 0.1) * size, mouth3_c, M, mat_2);\n    Cube[22] = creeper.mouth3;\n\n    return creeper;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene() {\n    // Horizontal plane.\n    Plane[0] = CreatePlane(0.0, 1.0, 0.0, 0.0, 3);\n\n    Plane[1] = CreatePlane(1.0, 0.0, 0.0, 30.0, 0);\n    Plane[2] = CreatePlane(0.0, 0.0, 1.0, 30.0, 0);\n\n    Cylinder[0].radius = 0.7;\n    Cylinder[0].center = vec3(0, 2.0, 0);\n    Cylinder[0].height = 100.0;\n    Cylinder[0].materialID = 9;\n\n    const float HUMAN_RAD = 15.0;\n    const float MOVE_RADIUS = 8.0;\n    cc1 = vec3(HUMAN_RAD * cos(speed1 * iTime), 4.2 + 3.5 * abs(sin(4.0 * iTime)), HUMAN_RAD * sin(speed1 * iTime));\n    cc2 = vec3(MOVE_RADIUS * cos(speed2 * iTime + PI), 4.2, MOVE_RADIUS * sin(speed2 * iTime + PI));\n\n    if(mod(iTime, 2.5) <= 0.5) {\n        if(status == 1)\n            status = 2;\n        else\n            status = 1;\n    }\n\n    float d = -speed1 * iTime;\n    Human = CreateHuman(cc1, d, 0.4);\n\n    d = -speed2 * iTime + PI;\n    creeper = CreateCreeper(cc2, d, 0.4);\n\n    // sphere.\n    vec3 center = cc2 * 0.4 + vec3(0.2 * MOVE_RADIUS * cos(-1.2*speed2 * iTime), sin(speed2 * iTime), 0.2 * MOVE_RADIUS * sin(-1.2*speed2 * iTime));\n    float radius = 0.32;\n    int mat_sph = 1;\n    if(mod(iTime, 2.5) <= 0.5) {\n        mat_sph = 2;\n    } else if (mod(iTime, 2.5) <= 1.0) {\n        mat_sph = 3;\n    } else if (mod(iTime, 2.5) <= 1.5) {\n        mat_sph = 4;\n    } else if (mod(iTime, 2.5) <= 2.0) {\n        mat_sph = 5; \n    } else {\n        mat_sph = 1;\n    }\n    Sphere[0] = CreateSphere(center, radius, mat_sph);\n\n    // Circling sphere.\n    if(mod(iTime, 2.5) <= 0.5) {\n        mat_sph = 6;\n    } else if (mod(iTime, 2.5) <= 1.0) {\n        mat_sph = 7;\n    } else if (mod(iTime, 2.5) <= 1.5) {\n        mat_sph = 8;\n    } else if (mod(iTime, 2.5) <= 2.0) {\n        mat_sph = 9; \n    } else {\n        mat_sph = 6;\n    }\n    center = cc2 * 0.4 + vec3(0.2 * MOVE_RADIUS * cos(-1.2*speed2 * iTime + PI), sin(speed2 * iTime + PI), 0.2 * MOVE_RADIUS * sin(-1.2*speed2 * iTime + PI));\n    radius = 0.32;\n    Sphere[1] = CreateSphere(center, radius, mat_sph);\n\n    // Silver\n    Material[0] = CreateMaterial(vec3(0.1, 0.1, 0.1), vec3(0.5, 0.5, 0.5), vec3(1.0, 1.0, 1.0), 64.0);\n    \n    // Gold\n    Material[1] = CreateMaterial(vec3(0.24725, 0.1995, 0.0745), vec3(0.75, 0.6065, 0.2265), vec3(0.628, 0.5558, 0.366), 51.2);\n\n    // Copper(changed)\n    Material[4] = CreateMaterial(vec3(0.0, 0.27, 0.0), vec3(0.0, 0.56, 0.0), vec3(0.2568, 0.1376, 0.086), 12.8);\n\n    // Black material\n    Material[3].k_d = vec3(0.0, 0.0, 0.0);\n    Material[3].k_a = 0.2 * Material[3].k_d;\n    Material[3].k_r = vec3(0.3, 0.3, 0.3);\n    Material[3].k_rg = vec3(0.0, 0.0, 0.0);\n    Material[3].n = 38.4;\n\n    // Green Plastic\n    // Updated Green plastic material.\n    Material[2].k_d = vec3(0.0, 0.8, 0.0);   // Strong diffuse reflection, typical for plastic.\n    Material[2].k_a = 0.2 * Material[2].k_d; // Low ambient light reflection.\n    Material[2].k_r = vec3(1.0, 1.0, 1.0);   // Less intense specular reflection than white.\n    Material[2].k_rg = 0.5 * Material[2].k_r;  // No global reflection to avoid any transparency effect.\n    Material[2].n = 128.0;                   // High specular exponent for a shiny plastic look.\n\n    // green floor\n    vec3 k_d = vec3(1.0, 0.829, 0.829);\n    Material[5] = CreateMaterial(0.5 * k_d, k_d, 2.0 * k_d, 11.264);\n\n    // brown floor\n    k_d = vec3(0.5, 0.35, 0.05);\n    Material[6] = CreateMaterial(0.5 * k_d, k_d, 2.0 * k_d, 76.8);\n\n    // skin\n    Material[7] = CreateMaterial(vec3(0.435, 0.225, 0.170), vec3(0.8, 0.606, 0.606), vec3(0.0, 0.0, 0.0), 6.0);\n    Material[7].k_rg = vec3(0., 0., 0.);\n\n    // brown eyebrown\n    k_d = vec3(0.418, 0.285, 0.0195);\n    Material[8] = CreateMaterial(0.5 * k_d, k_d, vec3(0.1), 76.8);\n\n    // white eye\n    Material[9] = CreateMaterial(vec3(0.5, 0.5, 0.5), vec3(1.0, 1.0, 1.0), vec3(0.774597, 0.774597, 0.774597), 76.8);\n    Material[9].k_rg = vec3(0.0);\n\n    // dark green pupil\n    Material[10] = CreateMaterial(vec3(0.0, 0.15, 0.0), vec3(0.0, 0.3, 0.0), vec3(0.0, 0.0, 0.0), 76.8);\n\n   // Orange-yellow material\n    Material[11].k_d = vec3(1.0, 0.65, 0.0);  // Strong diffuse reflection, typical for orange-yellow.\n    Material[11].k_a = 0.2 * Material[11].k_d; // Low ambient light reflection.\n    Material[11].k_r = vec3(1.0, 0.8, 0.3);  // Specular reflection less intense than white.\n    Material[11].k_rg = vec3(0.0); // No global reflection to avoid any transparency effect.\n    Material[11].n = 1.0;                   // Specular exponent.\n\n    // Vivid red material\n    Material[12].k_d = vec3(1.0, 0.1, 0.1);   // Strong diffuse reflection, vivid red.\n    Material[12].k_a = 0.2 * Material[12].k_d; // Low ambient light reflection.\n    Material[12].k_r = vec3(1.0, 0.5, 0.5);   // Specular reflection less intense than white.\n    Material[12].k_rg = vec3(0.0); // No global reflection to avoid any transparency effect.\n    Material[12].n = 128.0;                   // Specular exponent.\n             // Specular exponent.\n\n    // Light 0.\n    vec3 position = vec3(16.0, 4.0, 16.0);\n    vec3 I_a = vec3(0.1, 0.1, 0.1);\n    vec3 I_source = vec3(1.0, 1.0, 1.0);\n    Light[0] = CreateLight(position, I_a, I_source);\n\n    // Light 1.\n    position = vec3(-30.0, 9.0, -30.0);\n    I_a = vec3(0.1, 0.1, 0.1);\n    I_source = vec3(1.0, 1.0, 1.0);\n    Light[1] = CreateLight(position, I_a, I_source);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection\n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane(\n    in Plane_t pln,\n    in Ray_t ray,\n    in float tmin,\n    in float tmax,\n    out float t,\n    out vec3 hitPos,\n    out vec3 hitNormal\n) {\n    vec3 N = vec3(pln.A, pln.B, pln.C);\n    float NRd = dot(N, ray.d);\n    float NRo = dot(N, ray.o);\n    float t0 = (-pln.D - NRo) / NRd;\n    if(t0 < tmin || t0 > tmax)\n        return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize(N);\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane(in Plane_t pln, in Ray_t ray, in float tmin, in float tmax) {\n    vec3 N = vec3(pln.A, pln.B, pln.C);\n    float NRd = dot(N, ray.d);\n    float NRo = dot(N, ray.o);\n    float t0 = (-pln.D - NRo) / NRd;\n    if(t0 < tmin || t0 > tmax)\n        return false;\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere(\n    in Sphere_t sph,\n    in Ray_t ray,\n    in float tmin,\n    in float tmax,\n    out float t,\n    out vec3 hitPos,\n    out vec3 hitNormal\n) {\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    float Rd = dot(ray.d, ray.o - sph.center);\n    float Ro = dot(ray.o - sph.center, ray.o - sph.center);\n\n    float a = dot(ray.d, ray.d);\n    float b = 2.0 * Rd;\n    float c = Ro - sph.radius * sph.radius;\n    float discriminant = b * b - 4.0 * a * c;\n\n    // b^2 - 4ac < 0, no soution for t(no intersection).\n    if(discriminant < 0.0)\n        return false;\n\n    // check if there is solution or choose the smaller t.\n    if(b < 0.0)\n        t = (-b - sqrt(discriminant)) / (2.0 * a);\n    else\n        t = (-b + sqrt(discriminant)) / (2.0 * a);\n\n    if(t < tmin || t > tmax)\n        return false;\n\n    hitPos = ray.o + t * ray.d;\n    hitNormal = normalize(hitPos - sph.center);\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere(in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax) {\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    float Rd = dot(ray.d, ray.o - sph.center);\n    float Ro = dot(ray.o - sph.center, ray.o - sph.center);\n\n    float a = dot(ray.d, ray.d);\n    float b = 2.0 * Rd;\n    float c = Ro - sph.radius * sph.radius;\n    float discriminant = b * b - 4.0 * a * c;\n\n    // b^2 - 4ac < 0, no soution for t(no intersection).\n    if(discriminant < 0.0)\n        return false;\n\n    float t;\n\n    if(b < 0.0)\n        t = (-b - sqrt(discriminant)) / (2.0 * a);\n    else\n        t = (-b + sqrt(discriminant)) / (2.0 * a);\n\n    if(t < tmin || t > tmax)\n        return false;\n    return true;\n}\nfloat shpIntersect(in Ray_t ray, in Sphere_t sph) {\n    vec3 po = ray.o - sph.center;\n\n    float b = dot(ray.d, po);\n    float c = dot(po, po) - sph.radius * sph.radius;\n    float h = b * b - c;\n\n    h = b + sqrt(h);//#\n\n    return -h / 2.0;//#\n}\n\nbool IntersectCube(in Cube_t cube, in Ray_t ray, in float tmin, in float tmax, out float t, out vec3 hitPos, out vec3 hitNormal) {\n    vec3 sco = (cube.M * vec4(ray.o, 1.0)).xyz;\n    vec3 scd = normalize((transpose(inverse(cube.M)) * vec4(ray.d, 1.0)).xyz);\n    vec3 m = 1.0 / scd;\n    vec3 n = m * sco;\n    vec3 k = abs(m) * cube.rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max(max(t1.y, t1.z), t1.x);\n    float tF = min(min(t2.y, t2.z), t2.x);\n\n    if(tN > tF || tF < 0.0)\n        return false;\n    if(tN < tmin || tN > tmax)\n        return false;\n    t = tN;\n    hitPos = (inverse(cube.M) * vec4((sco + t * scd), 1.0)).xyz;\n    hitNormal = (transpose(inverse(cube.M)) * vec4((-sign(ray.d) * step(t1.zxy, t1.xyz) * step(t1.yzx, t1.xyz)), 1.0)).xyz;\n    return true;\n}\n\nbool IntersectCube(in Cube_t cube, in Ray_t ray, in float tmin, in float tmax) {\n    vec3 sco = (cube.M * vec4(ray.o, 1.0)).xyz;\n    vec3 scd = normalize((transpose(inverse(cube.M)) * vec4(ray.d, 1.0)).xyz);\n    vec3 m = 1.0 / scd;\n    vec3 n = m * sco;\n    vec3 k = abs(m) * cube.rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max(max(t1.y, t1.z), t1.x);\n    float tF = min(min(t2.y, t2.z), t2.x);\n\n    if(tN > tF || tF < 0.0)\n        return false;\n    if(tN < tmin || tN > tmax)\n        return false;\n    return true;\n}\n\n///////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectCylinder(\n    in Cylinder_t cld,\n    in Ray_t ray,\n    in float tmin,\n    in float tmax,\n    out float t,\n    out vec3 hitPos,\n    out vec3 hitNormal\n) {\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    Plane_t top, but;\n    top.A = 0.0, top.B = -1.0, top.C = 0.0, top.D = cld.center.y + cld.height, top.materialID = cld.materialID;\n    but.A = 0.0, but.B = -1.0, but.C = 0.0, but.D = cld.center.y + cld.height, but.materialID = but.materialID;\n\n    float temp_t;\n    vec3 temp_hitpos, temp_hitNormal;\n    if(IntersectPlane(top, ray, tmin, tmax, temp_t, temp_hitpos, temp_hitNormal) || IntersectPlane(but, ray, tmin, tmax, temp_t, temp_hitpos, temp_hitNormal)) {\n        vec3 d = temp_hitpos - cld.center;\n        if(d.x * d.x + d.z * d.z < cld.radius * cld.radius) {\n            t = temp_t;\n            hitPos = temp_hitpos;\n            hitNormal = temp_hitNormal;\n            return true;\n        }\n    }\n\n    vec3 oc = ray.o - cld.center;\n    float a = ray.d.x * ray.d.x + ray.d.z * ray.d.z;\n    float b = 2.0 * (ray.d.x * oc.x + ray.d.z * oc.z);\n    float c = oc.x * oc.x + oc.z * oc.z - cld.radius * cld.radius;\n    float d = b * b - 4.0 * a * c;\n    if(d < 0.0)\n        return false;\n\n    d = sqrt(d);\n    float t1 = (-b - d) / 2.0 / a;\n    float t2 = (-b + d) / 2.0 / a;\n    t = t1 < t2 ? t1 : t2;\n\n    if(t < tmin || t > tmax)\n        return false;\n    vec3 hitTemp = ray.o + t * ray.d;\n    if(hitTemp.y > cld.center.y + cld.height)\n        return false;\n\n    hitPos = hitTemp;\n    hitNormal = normalize(vec3(hitPos.x - cld.center.x, 0.0, hitPos.z - cld.center.z));\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectCylinder(in Cylinder_t cld, in Ray_t ray, in float tmin, in float tmax) {\n    Plane_t top, but;\n    top.A = 0.0, top.B = -1.0, top.C = 0.0, top.D = cld.center.y + cld.height, top.materialID = cld.materialID;\n    but.A = 0.0, but.B = -1.0, but.C = 0.0, but.D = cld.center.y - cld.height, but.materialID = but.materialID;\n\n    float temp_t;\n    vec3 temp_hitpos, temp_hitNormal;\n    if(IntersectPlane(top, ray, tmin, tmax, temp_t, temp_hitpos, temp_hitNormal) || IntersectPlane(but, ray, tmin, tmax, temp_t, temp_hitpos, temp_hitNormal)) {\n        vec3 d = temp_hitpos - cld.center;\n        if(d.x * d.x + d.z * d.z < cld.radius * cld.radius)\n            return true;\n    }\n    vec3 oc = ray.o - cld.center;\n\n    float a = ray.d.x * ray.d.x + ray.d.z * ray.d.z;\n    float b = 2.0 * (ray.d.x * oc.x + ray.d.z * oc.z);\n    float c = oc.x * oc.x + oc.z * oc.z - cld.radius * cld.radius;\n\n    float d = b * b - 4.0 * a * c;\n\n    if(d < 0.0)\n        return false;\n\n    d = sqrt(d);\n    float t1 = (-b - d) / 2.0 / a;\n    float t2 = (-b + d) / 2.0 / a;\n\n    float t;\n    t = t1 < t2 ? t1 : t2;\n\n    if(t < tmin || t > tmax)\n        return false;\n\n    vec3 hitPos = ray.o + t * ray.d;\n    if(hitPos.y > cld.center.y + cld.height)\n        return false;\n\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting(\n    in vec3 L,\n    in vec3 N,\n    in vec3 V,\n    in bool inShadow,\n    in Material_t mat,\n    in Light_t light\n) {\n    if(inShadow) {\n        return light.I_a * mat.k_a;\n    } else {\n        vec3 R = reflect(-L, N);\n        float N_dot_L = max(0.0, dot(N, L));\n        float R_dot_V = max(0.0, dot(R, V));\n        float R_dot_V_pow_n = (R_dot_V == 0.0) ? 0.0 : pow(R_dot_V, mat.n);\n\n        return light.I_a * mat.k_a +\n            light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\nfloat hash(float n) {\n    return fract(sin(n) * 43758.5453123);\n}\n// Generate a random number based on input coordinates\nfloat random(vec2 st) {\n    return hash(dot(st.xy, vec2(12.9898, 78.233)));\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay(\n    in Ray_t ray,\n    out bool hasHit,\n    out vec3 hitPos,\n    out vec3 hitNormal,\n    out vec3 k_rg\n) {\n    // Find whether and where the ray hits some object.\n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    // check sphere\n    Sphere_t temp_sphere;\n    bool isSphere = false;\n    for(int i = 0; i < NUM_SPHERES; i++) {\n        temp_hasHit = IntersectSphere(Sphere[i], ray, DEFAULT_TMIN, nearest_t, temp_t, temp_hitPos, temp_hitNormal);\n        if(temp_hasHit && temp_t < nearest_t) {\n            isSphere = true;\n            temp_sphere = Sphere[i];\n\n            hasHitSomething = true;\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = Sphere[i].materialID;\n        }\n    }\n\n    // check cube \n    Cube_t temp_cube;\n    bool isCube = false;\n    for(int i = 0; i < NUM_CUBES; i++) {\n        temp_hasHit = IntersectCube(Cube[i], ray, DEFAULT_TMIN, nearest_t, temp_t, temp_hitPos, temp_hitNormal);\n\n        if(temp_hasHit && temp_t < nearest_t) {\n            isCube = true;\n            temp_cube = Cube[i];\n\n            hasHitSomething = true;\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = Cube[i].materialID;\n        }\n    }\n\n    // check sphere\n    Plane_t temp_plane;\n    for(int i = 0; i < NUM_PLANES; i++) {\n        temp_hasHit = IntersectPlane(Plane[i], ray, DEFAULT_TMIN, nearest_t, temp_t, temp_hitPos, temp_hitNormal);\n\n        if(temp_hasHit && temp_t < nearest_t) {\n            temp_plane = Plane[i];\n            hasHitSomething = true;\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = Plane[i].materialID;\n            if(i == 0) {\n                float len = 7.0;\n                if(nearest_hitPos.x < len && nearest_hitPos.x > -len && nearest_hitPos.z < len && nearest_hitPos.z > -len) {\n                    float divisor = 3.5;\n                    float tempX = mod(nearest_hitPos.x + 0.5, divisor) - 1.0;\n                    float tempZ = mod(nearest_hitPos.z + 0.5, divisor) - 1.0;\n                    if(tempX * tempZ < 0.0)\n                        nearest_hitMatID = Plane[i].materialID;\n                    else\n                        nearest_hitMatID = 5;\n                }\n                   // outside the bounding box\n                    // magma: half are red and half are yellow\n                else {\n                    float divisor = 3.0;\n                    float tempX = mod(nearest_hitPos.x + 0.5, divisor) - 1.0;\n                    float tempZ = mod(nearest_hitPos.z + 0.5, divisor) - 1.0;\n\n                    int material_1 = 11;int material_2 = 12;\n\n\n                    if(mod(iTime, 2.5) <= 0.5) {\n                        if(lava == 1)\n                            lava = 2;\n                        else\n                            lava = 1;\n                    }\n\n                    if(lava == 2) {\n                        lava = 1;\n                        material_1 = 11; material_2=12;\n                    } else if(lava == 1) {\n                        lava = 2;\n                         material_1 = 12; material_2=11;\n\n                    }\n\n                    if(tempX * tempZ < 0.0)\n                        nearest_hitMatID = material_1;\n                    else\n                        nearest_hitMatID = material_2;\n\n\n                //    // Using the sum of coordinates to alternate colors\n                //     int sumCoords = int(floor(nearest_hitPos.x) + floor(nearest_hitPos.z));\n                //     float keys = random(nearest_hitPos.xz);\n                //     int key = int(floor(keys * 3.0));\n\n                //     if(sumCoords % 3 == key % 3) {\n                //         nearest_hitMatID = 12; // red\n                //     } else if(sumCoords % 3 == (key + 1 )%3) {\n                //         nearest_hitMatID = 11; // yellow\n                //     } else {\n                //         nearest_hitMatID = 1; // green\n                //     }\n                }\n\n            }\n        }\n    }\n\n    //check cylinder\n    for(int i = 0; i < NUM_CYLINDERS; i++) {\n        temp_hasHit = IntersectCylinder(Cylinder[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n        if(temp_hasHit && temp_t < nearest_t) {\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = Cylinder[i].materialID;\n            hasHitSomething = true;\n        }\n    }\n\n    // One of the output results.\n    hasHit = hasHitSomething;\n    if(!hasHitSomething) {\n        vec3 skyBox = texture(iChannel0, ray.d).rgb;\n        //vec3 skyBox = BACKGROUND_COLOR;\n        return skyBox;\n    }\n    vec3 I_local = vec3(0.0);  // Result color will be accumulated here.\n\n    // check shadow\n    // Ray_t shadowRay;\n    Ray_t shadowRay;\n    for(int i = 0; i < NUM_LIGHTS; i++) {\n        shadowRay.o = nearest_hitPos;\n        shadowRay.d = normalize(Light[i].position - nearest_hitPos);\n\n        float d = distance(nearest_hitPos, Light[i].position);\n        bool inShadow = false;\n        if(!inShadow) {\n            for(int j = 0; j < NUM_SPHERES; j++) {\n                inShadow = IntersectSphere(Sphere[j], shadowRay, DEFAULT_TMIN, d);\n                if(inShadow)\n                    break;\n            }\n        }\n        if(!inShadow) {\n            for(int j = 0; j < NUM_CUBES; j++) {\n                inShadow = IntersectCube(Cube[j], shadowRay, DEFAULT_TMIN, d);\n                if(inShadow)\n                    break;\n            }\n        }\n        if(!inShadow) {\n            for(int j = 0; j < NUM_CYLINDERS; j++) {\n                inShadow = IntersectCylinder(Cylinder[j], shadowRay, DEFAULT_TMIN, d);\n                if(inShadow) {\n                    break;\n                }\n            }\n        }\n\n        I_local += PhongLighting(shadowRay.d, nearest_hitNormal, -ray.d, inShadow, Material[nearest_hitMatID], Light[i]);\n    }\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n\n    return I_local;\n}\n\n//--------------------------------------------------------------------\n\n//wrap the plane once\nfloat map(in vec3 pos) {\n    float d1 = length(pos.xz - Human.center.xz);\n    // float d2 = length(pos.xz - creeper.center.xz );\n\n    float fact1 = 1.0;\n    // float fact2 = 10.0;\n\n    // float d = -log(exp(-d1 * fact1) + exp(-d2 * fact2));\n    float d = d1;\n\n    float h = 1.0 - 2.0 / (1.0 + 0.3 * d * d);\n\n    return pos.y - h;\n}\n\nfloat rayMarch(in Ray_t ray, float tmax) {\n    float t = 0.0;\n\n    // bounding plane\n    float h = (5.0 - ray.o.y) / ray.d.y;\n    if(h > 0.0)\n        t = h;\n\n    // raymarch iteration    \n    for(int i = 0; i < 10; i++) {\n        vec3 pos = ray.o + t * ray.d;\n        float h = map(pos);\n        Plane[0].D = h;\n        if(h < 0.001 || t > tmax)\n            break;\n        t += h;\n    }\n    return t;\n}\n\nvec3 render(in Ray_t ray) {\n    vec3 col = vec3(0.0);\n\n    // raytrace stuff    \n    float t1 = shpIntersect(ray, Sphere[0]);//#\n    float t2 = shpIntersect(ray, Sphere[1]);//#\n\n    float t = min(t1, t2);//#\n\n    Sphere_t sph = Sphere[0];//#\n    if(t == t2)\n        sph = Sphere[1];//#\n\n    // raymarch stuff    \n    float tmax = DEFAULT_TMAX;\n    if(t > 0.0)\n        tmax = t;\n    t = rayMarch(ray, tmax);\n\n    col *= smoothstep(0.0, 6.0, iTime);\n\n    return col;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n    // Position the camera.\n    vec3 cam_up_vec = vec3(0.0, 1.0, 0.0);\n    \n    vec3 cam_pos;\n    // Way 1\n    //if(mod(iTime, 5.0) < 1.5) cam_pos = vec3(0., 8., -10. - 4.0*mod(iTime, 5.0));\n    //else if (mod(iTime, 5.0) < 2.5) cam_pos = vec3(9., 6.+3.*mod(iTime, 5.0) , 9.);\n    //else if (mod(iTime, 5.0) < 4.0) cam_pos = vec3(-20.0*cos(0.2 *iTime), 12., 20.0*sin(0.2*iTime));\n    //else cam_pos = vec3(-12., 8. -0.5*mod(iTime, 5.0), 0.);\n    \n    // Way 2\n    cam_pos = vec3(12.0 * cos(CAM_V * iTime + 7.0 * mo.x), \n                        4.0 * sin(CAM_V * iTime) + 8.0, \n                        12.0 * sin(CAM_V * iTime + 7.0 * mo.x));\n    \n    vec3 cam_lookat = vec3(0.0, 0.0, 0.0);\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize(cam_pos - cam_lookat);\n    vec3 cam_x_axis = normalize(cross(cam_up_vec, cam_z_axis));\n    vec3 cam_y_axis = normalize(cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize(pixel_pos.x * cam_x_axis + pixel_pos.y * cam_y_axis + pixel_pos_z * cam_z_axis);\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3(0.0);\n    vec3 compounded_k_rg = vec3(1.0);\n    Ray_t nextRay = pRay;\n\n    I_result -= 5.0 * render(pRay);\n\n    for(int level = 0; level <= NUM_ITERATIONS; level++) {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay(nextRay, hasHit, hitPos, hitNormal, k_rg);\n\n        I_result += compounded_k_rg * I_local;\n\n        if(!hasHit)\n            break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t(hitPos, normalize(reflect(nextRay.d, hitNormal)));\n    }\n    fragColor = vec4(I_result, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}