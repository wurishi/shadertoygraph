{"ver":"0.1","info":{"id":"4cKczw","date":"1731732865","viewed":55,"name":"Endless Glider","username":"TheSwaGiraffe","description":"storing data:\nhttps://www.shadertoy.com/view/tdGBDG\n\nraymarching:\nhttps://www.youtube.com/watch?v=khblXafu7iA&t=122s\n\nrendering text:\nhttps://www.shadertoy.com/view/dsGXDt\n\nthis would be impossible for me to do without those resources tysm to those people","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","game","sim","glide"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Example of using buffers to carry states between frames.\n// Important note: colors are not clamped so you have a pretty broad range to store data in.\n\n// Common - code available to all tabs (it is quite literally inserted into each)\n// Buffer A - code for variable management\n// Image - main shader that outputs to the display\n\n/*\n    this is a great video on raymarching go check it out\n    https://www.youtube.com/watch?v=khblXafu7iA&t=122s\n*/\n\nmakeStr1f(speed)  _S _p _e _e _d __ _dec(i, 3) __ _m _DIV _s                             _end\nmakeStr1f(angle)  _A _n _g _l _e __ _dec(i, 3)                                           _end\nmakeStr3f(Pos)  _P _o _s __ _LPR _dec(x, 0) _COM __ _dec(y, 0) _COM __ _dec(z, 0) _RPR   _end\nmakeStr1f(score)  _S _c _o _r _e __ _dec(i, 0)                                              _end\nconst float e = 2.7182818284590452353602874713527;\nconst float pi = 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066;\nfloat hash(vec3 p)\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn sin(length(fract(sin(p)*43758.5453123)));\n}\nvec3 pickColor(float d1, float d2, vec3 c1, vec3 c2, float gradient)\n{\n    return mix(c1, c2, clamp((d1 - d2)/gradient, 0., 1.));\n}\nfloat degtorad = 0.01745329251;\nvec3 rgb(int r, int g, int b)\n{\n    return vec3(r,g,b)/255.;\n}\nvec4 rgba(int r, int g, int b, float a)\n{\n    return vec4(r, g, b, a * 255.)/255.;\n}\nmat2 rot2D(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c,s,-s,c);\n}\n\nvec3 shade(vec3 normal, vec3 lightDir, vec3 surfCol, vec3 ambient)\n{\n    float diffuse = max(0., dot(normal, -lightDir));\n    return surfCol * (clamp(vec3(diffuse) + ambient, 0., 1.));\n}\nfloat focalLength = 1.;\nfloat smin(float a, float b, float k)\n{\n    float h = max(k-abs(a-b), 0.)/k;\n    return min(a, b) - h*h*h*k*(1./6.);\n}\n\nfloat smax( float a, float b, float k ) {\n    float h = max( k-abs(a-b), 0.0 )/k;\n\treturn max( a, b ) + h*h*k*(1./4.);\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\nfloat Sphere(vec3 p){\n    vec3 q = p;\n    vec3 motion = vec3(0,sin(-iTime) * 1.25,0);\n    motion.xy *= rot2D(hash(ceil((p + spacing/2.) / spacing) * spacing) * pi);\n    motion.yz *= rot2D(hash(ceil((p + spacing/2.) / spacing) * spacing + 70.) * pi);\n    motion.xz *= rot2D(hash(ceil((p + spacing/2.) / spacing) * spacing - 90.) * pi + iTime);\n    q += motion;\n\n    q = mod(q - spacing/2., spacing) - spacing/2.;\n    return length(q) -.5;\n}\nfloat Box(vec3 p){\n    vec3 q = mod(p - spacing/2., spacing) - spacing/2.;\n    q.xy *= rot2D(hash(ceil((p + spacing/2.) / spacing) * spacing) * pi);\n    q.yz *= rot2D(hash(ceil((p + spacing/2.) / spacing) * spacing + 70.) * pi);\n    q.xz *= rot2D(hash(ceil((p + spacing/2.) / spacing) * spacing - 90.) * pi + iTime);\n\n    return smax(sdBox(q, vec3(.75)), -(length(q) - .75), .5);\n}\nfloat sceneSDF(vec3 p)\n{\n    float sphere = Sphere(p);\n    float box = Box(p);\n    return smin(box, sphere, .5);\n}\nvec3 getnorm(vec3 p)\n{\n    vec3 q = ceil(p*75.)/75.;\n    vec2 eps = vec2(0.001,0.);\n    vec3 norm = normalize(sceneSDF(p)-vec3(sceneSDF(p-eps.xyy),sceneSDF(p-eps.yxy),sceneSDF(p-eps.yyx)));\n    return norm;\n}\nfloat march(vec3 ro, vec3 rd)\n{\n    vec3 p = ro + rd;\n    return sceneSDF(p);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 textuv = fragCoord / iResolution.y * 20. + vec2(0, -19);\n    vec4 pos = fetchData(iChannel0, POS_ADDR).xyzw;\n    focalLength = tan((35. - abs(pos.w * pos.w))/(180.0/pi));\n    if(focalLength < .01)\n    {\n        focalLength = 0.01;\n    }\n    vec3 rot = fetchData(iChannel1, ROT_ADDR).xyz;\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy)/ iResolution.y;\n    vec3 rd = normalize(vec3(uv, focalLength));\n    float text = 1. - Pos(textuv, pos.x * 7., pos.y * 7., pos.z * 7.);\n    textuv.y ++;\n    text -= speed(textuv, pos.w * 7.);\n    textuv.y ++;\n    vec3 dir = vec3(0, 0, 1);\n    dir.xy *= rot2D(rot.z);\n    dir.yz *= rot2D(rot.x);\n    dir.xz *= rot2D(rot.y);\n    text -= angle(textuv, acos(dot(dir, vec3(0, 1, 0))) / degtorad);\n    textuv.y ++;\n    text -= score(textuv, fetchData(iChannel3, SCO_ADDR).r);\n    rd.xy *= rot2D(rot.z);\n    rd.yz *= rot2D(rot.x);\n    rd.xz *= rot2D(rot.y);\n    float totalDist = 0.;\n    vec3 ro = pos.xyz;\n    //march\n    for(int i = 0; i < 100; i++){\n        float dist = march(ro, rd * totalDist);\n        totalDist += dist;\n        if(totalDist > 100. || dist < .01){break;}\n    }\n    //skybox\n        if(totalDist > 100.){\n        vec3 light = rgb(255, 225, 255); \n        vec3 dark = rgb(25, 25, 25);\n        fragColor = vec4(mix(dark, light, normalize(rd).y/2. + .5), 1.);\n        fragColor.rgb *= text;\n        return;\n    }\n    \n    vec3 p = ro + rd * totalDist;\n    vec3 col = vec3(pow(totalDist, .25) -1.5)/1.5;\n    vec3 lightDir = vec3(1,-1, 1);\n    vec3 sCol = pickColor(Box(p), Sphere(p), rgb(226, 171, 219), rgb(171, 215, 226), 1.5);\n    col = (shade(getnorm(p), lightDir, sCol, vec3(.25)));\n    col *= text;\n    // Output to screen\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//position\n\nmat2 rot2D(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c,s,-s,c);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 rot = fetchData(iChannel1, ROT_ADDR).xyz;\n    storeData(fragCoord, POS_ADDR);\n    fragColor = vec4(0., 1.5, -4.5, 0); // Initial value\n\n    if (iFrame > 0) { // After initialization\n        storeData(fragCoord, POS_ADDR);\n        fragColor = fetchData(iChannel0, POS_ADDR); // Load value from previous frame\n        float speed = fetchData(iChannel2, VEL_ADDR).x;\n        vec3 dir = vec3(0, 0, 1);\n        dir.xy *= rot2D(rot.z);\n        dir.yz *= rot2D(rot.x);\n        dir.xz *= rot2D(rot.y);\n        if(abs(speed) > 5.){\n            speed -= pow(speed, 2.) * .005 * speed / abs(speed);\n        }\n        fragColor.xyz += speed * dir;\n        fragColor.a = speed; //store speed in alpha channel\n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// data storing\n\n// Addresses:\n// These should be ivec2s containing the pixel coordinates of where certain data\n// should go. The coordinates are not normalize but can range from (0, 0) to\n// (iResolution.x, iResolution.y).\nconst ivec2 ROT_ADDR = ivec2(0, 0);\n\nconst ivec2 POS_ADDR = ivec2(0, 1);\n\nconst ivec2 VEL_ADDR = ivec2(1, 0);\n\nconst ivec2 SCO_ADDR = ivec2(1, 1);\n// Unfortunately, the only way to define functions that sample iChannels in Common\n// is with #define :(\n\n// buf - iChannel to read from\n// addr - the data address in the form of an ivec2 (vector containing two integers)\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n\n// buf_pos - fragment position (fragCoord)\n// addr - the data address in the form of an ivec2\n// storeData() just evaluates if the data address matches the fragment position\n// in which case the data should be stored in fragColor.\n#define storeData(buf_pos, addr) ivec2(buf_pos) == addr\n#define spacing 15.\n\n// text rendering\n\n/*   ### How to use this shader ? ###\n   \n   = Setup =\n   0. Copy the content of the Common Tab inside your shader\n   1. Make sure the FONT_TEXTURE #define is set to the iChannel \n      containing the alphabet texture\n   \n   = Declare String =\n   2. Use makeStr to declare a new string (needs to be done outside any function)\n   3. Write your text using _ before each char, and __ for spaces\n   4. Finish your string with the _end keyword\n   \n       makeStr(printAnother) _A _n _o _t _h _e _r __ _E _x _a _m _p _l _e    _end\n   \n   = Print String =\n   5. Call the new function by passing it your uvs. It returns a grayscale value.\n   \n       finalCol += printAnother(uv);\n   \n   Note that by default a character has a height of 1 (which is full height if \n   the coordinates are normalized). You are responsible for scaling/offsetting \n   the uvs to control the text placement before calling the function.\n \n \n   ### Characters available ###\n   \n   uppercase: _A _B _C ...\n   lowercase: _a _b _c ...\n   digits   : _0 _1 _2 ...\n   special  : _EXC _QUOT ... (see Common)\n   \n   \n   ### Javascript string generator helper ###\n   \n   To make things even easier, I've made a tiny javascript helper function that you\n   can use to convert strings to the right _F _o _r _m _a _t !\n   (I've written it in the comments of this shader)\n   \n   \n   ### Special functions ###\n   \n   _dig(i)       : write a specific digit [i ranges between 0-9]\n   _dec(i, prec) : write a floating point number [prec: number of decimals to print]\n   _ch(i)        : Write an uppercase character [i ranges between 0-25]\n   \n   To use these special functions, you need to pass additional parameters into makeStr:\n   \n   \"makeStr1i\" allows you to pass 1 int parameter named \"i\" :\n   \n   makeStr1i(test) _dig(i) _end\n   test(uv, 5);\n   \n   \"makeStr1f\" allows you to pass 1 float parameter named \"i\":\n   \n   makeStr1f(test) _dec(i, 3) _end\n   test(uv, 5.);\n   \n   You can also create your own makeStr with any parameter type! (see below)\n   \n   \n   ### Help me optimize it! ###\n   \n   The _dec() function is only for debug purposes, I've never used it in a published shader.\n   It's *very* intensive and can have rounding issues (ie 21.999 when the float is 22.), \n   however it's done with a pretty naive approach so if you can come up with a better one\n   I'd be glad! The function is defined at the very end of this tab.\n*/\n\n/// SETTINGS ///\n\n// Set to the iChannel containing the alphabet texture\n#define FONT_TEXTURE iChannel2\n\n// Horizontal character spacing (default: 0.5)\n#define CHAR_SPACING 0.44\n\n\n/// STRING CREATION ///\n\n// Create a basic string\n#define makeStr(func_name) float func_name(vec2 u) { _print \n\n// Create a string with an int parameter\n#define makeStr1i(func_name) float func_name(vec2 u, int i) { _print\n\n// Create a string with a float parameter\n#define makeStr1f(func_name) float func_name(vec2 u, float i) { _print\n\n// Create a string with two floats parameter\n#define makeStr2f(func_name) float func_name(vec2 u, float i, float j) { _print\n\n\n// Create a vec3\n#define makeStr3f(func_name) float func_name(vec2 u, float x, float y, float z) { _print\n\n// ... Or create your own strings with any parameters\n#define makeStrXX(func_name) float func_name(vec2 u, ...) { _print\n\n// Terminate a string\n#define _end    ); return d; }\n\n\n/// SPECIAL FUNCTIONS ///\n\n// Dynamic uppercase character\n// i: [0-25]\n#define _ch(i)  _ 65+int(i)\n\n// Dynamic digit\n// i: [0-9]\n#define _dig(i) _ 48+int(i)\n\n// Floating point debug\n// x:   value to print\n// dec: number of decimal places to print\n#define _dec(x, dec) ); d += _decimal(FONT_TEXTURE, u, x, dec); (0\n\n\n/// SPECIAL CHARACTERS ///\n\n// Space\n#define __    ); u.x -= CHAR_SPACING; (0\n\n#define _EXC  _ 33 // \" ! \"\n#define _DBQ  _ 34 // \" \" \"\n#define _NUM  _ 35 // \" # \"\n#define _DOL  _ 36 // \" $ \"\n#define _PER  _ 37 // \" % \"\n#define _AMP  _ 38 // \" & \"\n#define _QUOT _ 39 // \" ' \"\n#define _LPR  _ 40 // \" ( \"\n#define _RPR  _ 41 // \" ) \"\n#define _MUL  _ 42 // \" * \"\n#define _ADD  _ 43 // \" + \"\n#define _COM  _ 44 // \" , \"\n#define _SUB  _ 45 // \" - \"\n#define _DOT  _ 46 // \" . \"\n#define _DIV  _ 47 // \" / \"\n#define _COL  _ 58 // \" : \"\n#define _SEM  _ 59 // \" ; \"\n#define _LES  _ 60 // \" < \"\n#define _EQU  _ 61 // \" = \"\n#define _GRE  _ 62 // \" > \"\n#define _QUE  _ 63 // \" ? \"\n#define _AT   _ 64 // \" @ \"\n#define _LBR  _ 91 // \" [ \"\n#define _ANTI _ 92 // \" \\ \"\n#define _RBR  _ 93 // \" ] \"\n#define _UND  _ 95 // \" _ \"\n\n\n/// CHARACTER DEFINITIONS ///\n\n// Uppercase letters (65-90)\n#define _A _ 65\n#define _B _ 66\n#define _C _ 67\n#define _D _ 68\n#define _E _ 69\n#define _F _ 70\n#define _G _ 71\n#define _H _ 72\n#define _I _ 73\n#define _J _ 74\n#define _K _ 75\n#define _L _ 76\n#define _M _ 77\n#define _N _ 78\n#define _O _ 79\n#define _P _ 80\n#define _Q _ 81\n#define _R _ 82\n#define _S _ 83\n#define _T _ 84\n#define _U _ 85\n#define _V _ 86\n#define _W _ 87\n#define _X _ 88\n#define _Y _ 89\n#define _Z _ 90\n\n// Lowercase letters (97-122)\n#define _a _ 97\n#define _b _ 98\n#define _c _ 99\n#define _d _ 100\n#define _e _ 101\n#define _f _ 102\n#define _g _ 103\n#define _h _ 104\n#define _i _ 105\n#define _j _ 106\n#define _k _ 107\n#define _l _ 108\n#define _m _ 109\n#define _n _ 110\n#define _o _ 111\n#define _p _ 112\n#define _q _ 113\n#define _r _ 114\n#define _s _ 115\n#define _t _ 116\n#define _u _ 117\n#define _v _ 118\n#define _w _ 119\n#define _x _ 120\n#define _y _ 121\n#define _z _ 122\n\n// Digits (48-57)\n#define _0 _ 48\n#define _1 _ 49\n#define _2 _ 50\n#define _3 _ 51\n#define _4 _ 52\n#define _5 _ 53\n#define _6 _ 54\n#define _7 _ 55\n#define _8 _ 56\n#define _9 _ 57\n\n\n/// Internal functions ///\n\n// Start\n#define _print  float d = 0.; (u.x += CHAR_SPACING\n\n// Update\n#define _       ); u.x -= CHAR_SPACING; d += _char(FONT_TEXTURE, u,\n\n// Print character\nfloat _char(sampler2D s, vec2 u, int id) {\n    vec2 p = vec2(id%16, 15. - floor(float(id)/16.));\n         p = (u + p) / 16.;\n         u = step(abs(u-.5), vec2(.5));\n    return texture(s, p).r * u.x * u.y;\n}\n\n// Floating point debug\nfloat _decimal(sampler2D FONT_TEXTURE, inout vec2 u, float n, int decimals) {\n    float d = 0., N = 1.; // d is the final color, N the number of digits before the decimal\n\n    if (n < 0.) {  // If the number is negative\n        n *= -1.;  // Make it positive\n        (0 _SUB ); // Print a minus sign\n    }\n    \n    // Calculate the number of digits before the decimal point\n    for (float x = n; x >= 10.; x /= 10.) N++;\n\n    // Print the digits before the decimal point\n    for (float i = 0.; i < N; i++) {        \n        float magnitude = pow(10., N-i-1.);\n        float leftDigit = floor(n / magnitude);\n        n -= leftDigit * magnitude;\n        \n        (0 _dig(leftDigit) );\n    }\n    if(decimals > 0){\n    (0 _DOT ); // Print a dot\n    }\n    // Print the digits after the decimal point\n    for (int i = 0; i < decimals; i++) {\n        float firstDecimal = floor((n - floor(n)) * 10.);\n        n *= 10.;\n        \n        (0 _dig(firstDecimal) );\n    }\n    \n    return d;\n}\n\nfloat _num(sampler2D FONT_TEXTURE, inout vec2 u, float n) {\n    float d = 0., N = 1.; // d is the final color, N the number of digits before the decimal\n\n    if (n < 0.) {  // If the number is negative\n        n *= -1.;  // Make it positive\n        (0 _SUB ); // Print a minus sign\n    }\n    \n    // Calculate the number of digits before the decimal point\n    for (float x = n; x >= 10.; x /= 10.) N++;\n\n    // Print the digits before the decimal point\n    for (float i = 0.; i < N; i++) {        \n        float magnitude = pow(10., N-i-1.);\n        float leftDigit = floor(n / magnitude);\n        n -= leftDigit * magnitude;\n        \n        (0 _dig(leftDigit) );\n    }\n    \n    return d;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//rotation\n\nmat2 rot2D(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c,s,-s,c);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(-.3, 0, 0, 0); // Initial value\n    storeData(fragCoord, ROT_ADDR);\n\n    if (iFrame > 0) { // After initialization\n        storeData(fragCoord, ROT_ADDR);\n        fragColor = fetchData(iChannel0, ROT_ADDR); // Load value from previous frame\n        vec3 forwards = vec3(0,0,1);\n        vec3 mouse = normalize(vec3(vec2((iMouse.x + .5) - iResolution.x/2., (iMouse.y + .5) - iResolution.y/2.)/iResolution.yx, 1.));\n\n        float y = 1.;\n        if(mouse.y < 0.){y = -1.;}\n        float x = 1.;\n        if(mouse.x < 0.){x = -1.;}\n        vec3 rot = vec3(0);\n        rot.x = y * acos(dot(normalize(vec3(mouse.yz, 0)), normalize(vec3(forwards.yz, 0))));\n        rot.y = x * acos(dot(normalize(vec3(mouse.xz, 0)), normalize(vec3(forwards.xz, 0))));\n        //rot *= iTimeDelta;\n        if(iMouse.z >= 0.){\n            fragColor.xyz = fragColor.xyz + rot * iTimeDelta * 4.;\n        }\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//velocity\nmat2 rot2D(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c,s,-s,c);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 rot = fetchData(iChannel1, ROT_ADDR).xyz;\n    storeData(fragCoord, POS_ADDR);\n    fragColor = vec4(0); // Initial value\n\n    if (iFrame > 0) { // After initialization\n        storeData(fragCoord, VEL_ADDR);\n        fragColor = fetchData(iChannel0, VEL_ADDR); // Load value from previous frame\n        vec3 dir = vec3(0, 0, 1);\n        dir.xy *= rot2D(rot.z);\n        dir.yz *= rot2D(rot.x);\n        dir.xz *= rot2D(rot.y);\n        float acceleration = dot(vec3(0, -1, 0), dir);\n        fragColor.x += acceleration * iTimeDelta/10.;\n    }\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"const float pi = 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066;\nfloat hash(vec3 p)\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn sin(length(fract(sin(p)*43758.5453123)));\n}\nmat2 rot2D(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c,s,-s,c);\n}\nfloat smin(float a, float b, float k)\n{\n    float h = max(k-abs(a-b), 0.)/k;\n    return min(a, b) - h*h*h*k*(1./6.);\n}\n\nfloat smax( float a, float b, float k ) {\n    float h = max( k-abs(a-b), 0.0 )/k;\n\treturn max( a, b ) + h*h*k*(1./4.);\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\nfloat Sphere(vec3 p){\n    vec3 q = p;\n    vec3 motion = vec3(0,sin(-iTime) * 1.25,0);\n    motion.xy *= rot2D(hash(ceil((p + spacing/2.) / spacing) * spacing) * pi);\n    motion.yz *= rot2D(hash(ceil((p + spacing/2.) / spacing) * spacing + 70.) * pi);\n    motion.xz *= rot2D(hash(ceil((p + spacing/2.) / spacing) * spacing - 90.) * pi + iTime);\n    q += motion;\n\n    q = mod(q - spacing/2., spacing) - spacing/2.;\n    return length(q) -.5;\n}\nfloat Box(vec3 p){\n    vec3 q = mod(p - spacing/2., spacing) - spacing/2.;\n    q.xy *= rot2D(hash(ceil((p + spacing/2.) / spacing) * spacing) * pi);\n    q.yz *= rot2D(hash(ceil((p + spacing/2.) / spacing) * spacing + 70.) * pi);\n    q.xz *= rot2D(hash(ceil((p + spacing/2.) / spacing) * spacing - 90.) * pi + iTime);\n\n    return smax(sdBox(q, vec3(.75)), -(length(q) - .75), .5);\n}\nfloat ScoringSphere(vec3 p)\n{\n    vec3 q = mod(p - spacing/2., spacing) - spacing/2.;\n    return (length(q) - .75);\n}\nfloat sceneSDF(vec3 p)\n{\n    float sphere = Sphere(p);\n    float box = Box(p);\n    return smin(box, sphere, .5);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0, 0, 0, 0); // Initial value\n    storeData(fragCoord, SCO_ADDR);\n\n    if (iFrame > 0) { // After initialization\n        storeData(fragCoord, SCO_ADDR);\n        fragColor = fetchData(iChannel0, SCO_ADDR); // Load value from previous frame\n        if(sceneSDF(fetchData(iChannel1, POS_ADDR).xyz) <= 0.){fragColor.x = 0.;}\n        if(ScoringSphere(fetchData(iChannel1, POS_ADDR).xyz) <= 0. && fragColor.y == 0.){fragColor.x ++; fragColor.y = 1.;}\n        if(ScoringSphere(fetchData(iChannel1, POS_ADDR).xyz) > 0.){fragColor.y = 0.;}\n    }\n}","name":"Buffer D","description":"","type":"buffer"}]}