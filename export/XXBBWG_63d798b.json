{"ver":"0.1","info":{"id":"XXBBWG","date":"1730620246","viewed":539,"name":"MOTOR :: motormath.xyz","username":"ENDESGA","description":"STRUCTURE::MOTOR from [url=https://motormath.xyz]motormath.xyz[/url]\n\nTransforms the cube by the motor via the mouse, and observes it.","likes":5,"published":3,"flags":0,"usePreview":0,"tags":["motor","3dmath","dualquaternion","motormath"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M iMouse.xy\n#define R iResolution.xy\n#define W R.x\n#define H R.y\n\n//\n\nvec2 UV;\nfloat AA;\nvec4 C = vec4(0.);\nfloat D = 0.;\nfloat draw_width;\n\n//\n\n#define hangle float\n#define vector vec3\n/*\nstruct vector\n{\n\tfloat x;\n\tfloat y;\n\tfloat z;\n};\n*/\n\n//\n\nstruct rotor\n{\n\tvector v;\n\thangle h;\n};\n\nrotor new_rotor( in vector norm_v, in hangle h )\n{\n\treturn rotor(\n\t\tnorm_v * sin( h ),\n\t\tcos( h )\n\t);\n}\n\nrotor invert_rotor( in rotor r )\n{\n    return rotor(\n        -r.v,\n        r.h\n    );\n}\n\n\nrotor rotor_mul_float( in rotor r, in float f )\n{\n    return rotor(r.v * f, r.h * f);\n}\n\n#define rotor_halve( R ) rotor_mul_float( R, .5 )\n\nrotor rotor_mul( in rotor a, in rotor b )\n{\n\tfloat i = ( a.v.z + a.v.x ) * ( b.v.x + b.v.y );\n\tfloat j = ( a.h + a.v.y ) * ( b.h - b.v.z );\n\tfloat k = ( a.h - a.v.y ) * ( b.h + b.v.z );\n\tfloat l = i + j + k;\n\tfloat m = .5 * ( ( a.v.z - a.v.x ) * ( b.v.x - b.v.y ) + l );\n\treturn rotor(\n\t\tvector(\n\t\t\t( a.h + a.v.x ) * ( b.h + b.v.x ) + m - l,\n\t\t\t( a.h - a.v.x ) * ( b.v.y + b.v.z ) + m - k,\n\t\t\t( a.v.y + a.v.z ) * ( b.h - b.v.x ) + m - j\n\t\t),\n\t\t( a.v.z - a.v.y ) * ( b.v.y - b.v.z ) + m - i\n\t);\n}\n\nrotor rotor_add( in rotor a, in rotor b )\n{\n    return rotor(\n        a.v + b.v,\n        a.h + b.h\n    );\n}\n\nrotor rotor_sub( in rotor a, in rotor b )\n{\n    return rotor(\n        a.v - b.v,\n        a.h - b.h\n    );\n}\n\nrotor yaw_pitch_roll( in hangle yaw, in hangle pitch, in hangle roll )\n{\n\tfloat sy = sin( yaw );\n\tfloat cy = cos( yaw );\n\tfloat sp = sin( pitch );\n\tfloat cp = cos( pitch );\n\tfloat sr = sin( roll );\n\tfloat cr = cos( roll ); \n\treturn rotor(\n\t\tvec3(\n\t\t\tsr * cp * cy - cr * sp * sy,\n\t\t\tcr * sp * cy + sr * cp * sy,\n\t\t\tcr * cp * sy - sr * sp * cy\n\t\t),\n\t\tcr * cp * cy + sr * sp * sy\n\t);\n}\n\nrotor look_rotor( in vector from_v, in vector to_v, in hangle roll )\n{\n    vector dir = normalize( to_v - from_v );\n    return yaw_pitch_roll(\n        atan( dir.y, dir.x ) * .5,\n        asin( -dir.z ) * .5,\n        roll\n    );\n}\n\nvector vector_rotate( in vector v, in rotor r )\n{\n    float a = r.v.y * v.z - r.v.z * v.y;\n    float b = r.v.z * v.x - r.v.x * v.z;\n    float c = r.v.x * v.y - r.v.y * v.x;\n    return vector(\n        v.x + 2. * ( r.h * a + r.v.y * c - r.v.z * b ),\n        v.y + 2. * ( r.h * b + r.v.z * a - r.v.x * c ),\n        v.z + 2. * ( r.h * c + r.v.x * b - r.v.y * a )\n    );\n}\n\nfloat rotor_magnitude( in rotor a, in rotor b )\n{\n    return dot( a.v, b.v ) + ( a.h * b.h );\n}\n\nrotor rotor_normalize( in rotor r )\n{\n    float mag = rotor_magnitude( r, r );\n    if( mag < 1e-7 ) // almost zero\n    {\n        return rotor( vector(0.), 1. );\n    }\n    float inv_mag = 1. / sqrt( mag );\n    return rotor( r.v * inv_mag, r.h * inv_mag );\n}\n\nrotor rotor_mix( in rotor a, in rotor b, in float t )\n{\n    float mag = rotor_magnitude( a, b );\n    if( mag < 0. )\n    {\n\t    b.v = -b.v;\n\t    b.h = -b.h;\n    }\n    return rotor_normalize(\n        rotor(\n            mix( a.v, b.v, t ),\n            mix( a.h, b.h, t )\n        )\n    );\n}\n\n//\n\nstruct motor\n{\n    rotor r;\n    rotor t;\n};\n\nmotor new_motor( in rotor r, in vector pos )\n{\n    return motor(\n        r,\n        rotor_halve(\n            rotor_mul(\n                rotor(\n                    vector( pos.x, pos.y, pos.z ),\n                    0.\n                ),\n                r\n            )\n        )\n    );\n}\n\nmotor invert_motor( in motor m )\n{\n    return motor(\n        invert_rotor( m.r ),\n        invert_rotor( m.t )\n    );\n}\n\nmotor motor_mul( in motor a, in motor b )\n{\n    return motor(\n        rotor_mul( a.r, b.r ),\n        rotor_add(\n            rotor_mul( a.r, b.t ),\n            rotor_mul( a.t, b.r )\n        )\n    );\n}\n\nvector vector_transform( in vector v, in motor m )\n{\n    return motor_mul(\n        motor_mul(\n            m,\n            motor(\n                rotor( vector( 0. ), 1. ),\n                rotor( v, 0. )\n            )\n        ),\n        motor(\n            rotor( -m.r.v, m.r.h ),\n            rotor( m.t.v, -m.t.h )\n        )\n    ).t.v;\n}\n\nmotor motor_mix( in motor a, in motor b, in float t )\n{\n    float mag = a.r.h * b.r.h + dot(a.r.v, b.r.v);\n    if(mag < 0.0) b = motor(rotor(-b.r.v,-b.r.h),rotor(-b.t.v,-b.t.h));\n\n    motor m =  motor(\n        rotor(mix(a.r.v, b.r.v, t), mix(a.r.h, b.r.h, t)),\n        rotor(mix(a.t.v, b.t.v, t), mix(a.t.h, b.t.h, t))\n    );\n    \n    float q = m.r.h * m.r.h + dot(m.r.v, m.r.v);\n    float norm_dual = (m.r.h * m.t.h + dot(m.r.v, m.t.v)) / q;\n    float scale_squared = 1./(q * q);\n    \n    return motor(\n        rotor_mul_float(rotor_mul_float(m.r, q), scale_squared),\n        rotor_mul_float(rotor_sub(rotor_mul_float(m.t, q), rotor_mul_float(m.r, norm_dual)), scale_squared)\n    );\n}\n\n//\n\nstruct projection\n{\n    float view_scale;\n    float spherical;\n    float sphere_scale;\n};\n\nprojection new_projection( in float fov_degrees, in float spherical, in float sphere_scale )\n{\n    return projection(\n        1. / tan(fov_degrees * .5),\n        spherical,\n        sphere_scale\n    );\n}\n\nvector world_to_view( in vector v )\n{\n    return vector( -v.y, -v.z, v.x );\n}\n\nvector view_to_world(in vector v)\n{\n    /**/\n    v.y = -v.y;\n    /**/\n\treturn vector( v.z, -v.x, -v.y );\n}\n\nvector vector_project( in vector world_v, in projection p )\n{\n    vector pos = world_to_view( world_v );\n    /**/\n    pos.y = -pos.y;\n    /**/\n    float z = ( ( 1. - p.spherical ) * pos.z ) +\n        ( p.spherical * ( length( vector( pos.xy, pos.z * p.sphere_scale ) ) / p.sphere_scale ) );\n    \n    return vector(\n        pos.x / z * p.view_scale,\n        pos.y / z * p.view_scale,\n        1. / z\n    );\n}\n\n//\n\n#define observer motor\n\nobserver new_observer( in vector from_v, in vector to_v, in hangle roll )\n{\n    return invert_motor( new_motor( look_rotor( from_v, to_v, roll ), from_v ) );\n}\n\nvector vector_observe( in vector world_v, in observer o, in projection p )\n{\n    return vector_project(\n        vector_transform( world_v, o ),\n        p\n    );\n}\n\n//\n\nvoid draw_line( in vector a, in vector b, vec4 c, float w) {\n    float d = mix(a.z, b.z, clamp(dot(UV - a.xy, b.xy - a.xy) / dot(b.xy - a.xy, b.xy - a.xy), 0., 1.));\n    if (max(0.,d) < D) return;\n\n    vec2 v = b.xy - a.xy;\n    vec2 p = UV - a.xy;\n    float t = smoothstep(AA, -AA, length(p - clamp(dot(p, v) / dot(v, v), 0., 1.) * v) - w);\n\n    D = mix(D, d, t);\n    C = mix(C, c, t);\n}\n\nvoid draw_cube( in motor m, in float scale, in observer o, in projection p, in vec4 c )\n{\n    float s = scale * .5;\n    \n    vector origin = vector_observe( vector_transform( vector( 0. ), m ), o, p );\n    vector forward = vector_observe( vector_transform( vector( .5, 0., 0. ), m ), o, p );\n    \n    vector flu = vector_observe( vector_transform( vector( s, s, s ), m ), o, p );\n    vector blu = vector_observe( vector_transform( vector( -s, s, s ), m ), o, p );\n    vector bru = vector_observe( vector_transform( vector( -s, -s, s ), m ), o, p );\n    vector fru = vector_observe( vector_transform( vector( s, -s, s ), m ), o, p );\n    \n    vector fld = vector_observe( vector_transform( vector( s, s, -s ), m ), o, p );\n    vector bld = vector_observe( vector_transform( vector( -s, s, -s ), m ), o, p );\n    vector brd = vector_observe( vector_transform( vector( -s, -s, -s ), m ), o, p );\n    vector frd = vector_observe( vector_transform( vector( s, -s, -s ), m ), o, p );\n\n    draw_line( flu, blu, c, draw_width * 2. );\n    draw_line( blu, bru, c, draw_width * 2. );\n    draw_line( bru, fru, c, draw_width * 2. );\n    draw_line( fru, flu, c, draw_width * 2. );\n    \n    draw_line( flu, fld, c, draw_width * 2. );\n    draw_line( blu, bld, c, draw_width * 2. );\n    draw_line( bru, brd, c, draw_width * 2. );\n    draw_line( fru, frd, c, draw_width * 2. );\n    \n    draw_line( fld, bld, c, draw_width * 2. );\n    draw_line( bld, brd, c, draw_width * 2. );\n    draw_line( brd, frd, c, draw_width * 2. );\n    draw_line( frd, fld, c, draw_width * 2. );\n    \n    draw_line( origin, forward, vec4( 1., 1., 0., 1. ), draw_width * 2. );\n}\n\n//\n\nvector origin = vector( 0, 0, 0 );\nvector eye_pos = vector( -1, -1, 1 );\nvector look_pos = vector( 0, 0, 0 );\nobserver eye;\n\nprojection retina;\n\nvoid mainImage( out vec4 O, in vec2 P )\n{\n\tUV = ( 2. * P - R ) / H;\n\tAA = ( .5 * ( dFdx( UV.x ) + dFdy( UV.y ) ) );\n    draw_width = 1. / ( R.y * .5 );\n    \n    eye = new_observer( eye_pos, origin, 0. );\n    \n    retina = new_projection( 90., .5, 2. );\n    \n    //\n    \n    draw_line(\n        vector_observe( origin, eye, retina ),\n        vector_observe( vector( 1, 0, 0 ), eye, retina ),\n        vec4( 1, 0, 0, 1 ),\n        draw_width * 2.\n    );\n    \n    draw_line(\n        vector_observe( origin, eye, retina ),\n        vector_observe( vector( 0, 1, 0 ), eye, retina ),\n        vec4( 0, 1, 0, 1 ),\n        draw_width * 2.\n    );\n    \n    draw_line(\n        vector_observe( origin, eye, retina ),\n        vector_observe( vector( 0, 0, 1 ), eye, retina ),\n        vec4( 0, 0, 1, 1 ),\n        draw_width * 2.\n    );\n    \n    //\n    float mx = ((M.x/W)*2.-1.);\n    float my = ((M.y/H)*2.-1.);\n    motor cube_motor = new_motor(\n        yaw_pitch_roll( mx + my, mx, my ),\n        vector( mx+.5, my+.5, 0. )\n    );\n    draw_cube( cube_motor, 1.5, eye, retina, vec4( 1 ) );\n    \n    //\n    \n    O = C;\n}","name":"Image","description":"","type":"image"}]}