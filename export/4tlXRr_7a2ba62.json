{"ver":"0.1","info":{"id":"4tlXRr","date":"1434499573","viewed":361,"name":"Metaballs Cell Shading","username":"morukutsu","description":"Experimenting with metaballs. WIP.\ntodo: \n- add more effects (if i have ideas!)\n- optimize","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["metaballs2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"float EDGE_SIZE    = 0.03;\nfloat MERGE_THRESH = 0.25;\nvec4  EDGE_COLOR   = vec4(0.7, 0.9, 1.0, 1.0);\nvec4  BALL_COLOR   = vec4(0.1, 0.3, 1.0, 1.0);\nvec4  BG_COLOR     = vec4(0.1, 0.0, 0.2, 1.0);\n\nvec2 fragPos(vec2 fragCoord)\n{\n    vec2 scale = vec2(1.0 / iResolution.x, \n                      1.0 / iResolution.x);\n    vec2 uv = fragCoord;\n    uv *= scale;\n    \n    uv.y += ((iResolution.x - iResolution.y) / 2.0) / iResolution.x;\n    return uv;\n}\n\nvec4 circle(vec2 fragCoord, vec2 center, float radius)\n{\n    vec2 uv = fragPos(fragCoord);\n    vec2 v = uv - center;\n    vec4 color = vec4(0, 0, 0, 1.0);\n    \n    float l = length(v);\n    if (l < radius)\n    {\n        float i = 1.0 - (l / radius);\n        i = pow(i, 2.0); // <- most of the effect relies of this being non linear\n        color = vec4(1.0, 1.0, 1.0, 1.0) * i;\n    }\n    return color;\n}\n\nvec4 normal_circle(vec2 fragCoord, vec2 center, float radius)\n{\n    vec2 uv = fragPos(fragCoord);\n    vec2 v = uv - center;\n    vec4 normal = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    float l = length(v);\n    if (l < radius)\n    {\n        float i = 1.0 - (l / radius);\n        i = pow(i, 3.0);\n        vec4 color = vec4(1.0, 1.0, 1.0, 1.0) * i;\n        v = v * 15.0;\n        normal = vec4(v.x * i, v.y * i, i * 0.7, 0.0);\n    }\n    return normal;\n}\n\nfloat cellShading(float i)\n{\n\tif (i < 0.1)\n        return 0.0;\n    else if (i < 0.4)\n        return 0.4;\n    else\n        return 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float disp = sin(iTime  * 0.5) * 0.20;\n    float size = sin(iTime) * 0.05;\n    vec4 c = vec4(0.0, 0.0, 0.0, 0.0);\n    vec4 normal = vec4(0.0, 0.0, 0.0, 0.0);\n    float s = 1.0;\n    \n    for (int i = 0; i < 2; i++)\n    { \n        float radius = 0.2 + size * s;\n        vec2 pos = vec2(0.5 + disp * s, 0.5);\n        pos.y += sin(iTime) * 0.10;\n        \n        c += circle(fragCoord, pos, radius);\n        normal += normal_circle(fragCoord, pos, radius);\n        s = -s;\n    }\n    \n    // mouse controlled ball\n    c += circle(fragCoord, fragPos(iMouse.xy), 0.2);\n    normal += normal_circle(fragCoord, fragPos(iMouse.xy), 0.2);\n    \n    // light\n    float lPosX = sin(iTime * 2.0);\n    float lPosY = -sin(iTime * 2.0);\n    vec4 L = vec4(0.7 + lPosX, 0.7 + lPosY, 1.0, 0.0);\n\tvec4 diffuse = vec4(1.0, 1.0, 1.0, 1.0);\n    \n    // merge\n    if (c.r > MERGE_THRESH)\n    {\n        vec4 height = c;\n        // edge\n        if (c.r > MERGE_THRESH && c.r < MERGE_THRESH + EDGE_SIZE)\n        {\n            // smooth edge\n            //float smooth = 1.0 - (c.r - MERGE_THRESH) / EDGE_SIZE;\n            c = EDGE_COLOR/* * (1.0 - smooth) + BALL_COLOR * smooth*/;\n        }\n        else\n        {\n            c += BALL_COLOR;\n        \n            // lighting\n            float NdotL = dot(normal, L);\n            NdotL = cellShading(NdotL);\n            vec4 lightColor = diffuse * NdotL + vec4(0.4, 0.4, 0.4, 1.0);\n            lightColor = clamp(lightColor, vec4(0.0, 0.0, 0.0, 0.0), vec4(1.0, 1.0, 1.0, 1.0));\n        \tc = c * lightColor;\n        }   \n    }\n    else\n    \tc = BG_COLOR;\n    \n    //--------------------------------------\n    // vignetting by iq\n    //--------------------------------------\n    vec2 q = fragPos(fragCoord);\n    c *= 0.25 + 0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n    fragColor = c;\n}","name":"","description":"","type":"image"}]}