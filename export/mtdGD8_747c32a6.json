{"ver":"0.1","info":{"id":"mtdGD8","date":"1682396833","viewed":63,"name":"Field of Stars","username":"shastro","description":"First time trying ray marching and sdfs","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sdf","domainrepitition"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int num_iter = 255;\nconst float min_camera_dist = 0.0;\nconst float max_camera_dist = 1000.0;\nconst float epsilon = 0.01;\n\nfloat sphereSDF(vec3 ro, float radius) {\n    return length(ro) - radius;\n}\n\n// Polynomial smooth min (for copying and pasting into your shaders)\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat sceneSDF(vec3 ro) {\n    float dist = max_camera_dist;\n    float k = 0.3*(0.5 + 0.5*sin(iTime/3.0))+0.4;\n    \n    float mod_size = 8.0;\n    float mod_off = 4.0;\n    vec3 mod_ro = mod(ro,mod_size) - vec3(mod_off, mod_off, mod_off);\n    \n    dist = smin(sphereSDF(mod_ro, 0.2), dist, k);\n    float r = 0.1*(0.5+0.5*sin(iTime*3.)) + 0.5;\n    int N = 5;\n    for (int i = 0; i < N; i++) {\n        float theta = float(i)*(2.*3.14)/float(N);\n        dist = smin(sphereSDF(mod_ro+vec3(r*cos(iTime+theta),r*sin(iTime+theta),0.0), r/10.),dist, k);\n    }\n    \n    return dist;\n}\n\nfloat diff(vec3 po, vec3 dir, float dx) {\n    float fpdx = sceneSDF(po + (dx/2.)*dir);\n    float fmdx = sceneSDF(po - (dx/2.)*dir);\n    float df = fpdx - fmdx;\n    return df;\n}\n\nvec3 grad(vec3 po, float dd) {\n    vec3 x = vec3(1.0,0.0,0.0);\n    vec3 y = vec3(0.0,1.0,0.0);\n    vec3 z = vec3(0.0,0.0,1.0);\n    \n    float dfx = diff(po, x, dd);\n    float dfy = diff(po, y, dd);\n    float dfz = diff(po, z, dd);\n    \n    return normalize(vec3(dfx, dfy,dfz));\n    \n}\n\nstruct RayResult {\n    vec3 diffuse_color;\n    float dist;\n    float min_dist;\n};\n\nRayResult marchRay(vec3 ro, vec3 rd) {\n    float depth = min_camera_dist;\n    RayResult outray;\n    outray.dist = max_camera_dist;\n    \n \n    float min_dist = max_camera_dist;\n    for (int i=0;i<num_iter;i++){\n        float dist = sceneSDF(ro + depth * rd);\n        if (dist < epsilon) {\n          outray.dist = depth;\n          break;\n        }\n        depth += dist;\n        if (depth >= max_camera_dist) {\n            outray.dist = max_camera_dist;\n            depth = max_camera_dist;\n            break;\n        }\n        \n        min_dist = min(min_dist, dist);\n    }\n    vec3 diffuse_color = vec3(1.0, 1.0,0.85);\n    vec3 normal = grad(ro + depth*rd, 0.001);\n    vec3 light_color = vec3(1.0,0.9,0.7);\n    //vec3 light_dir = normalize(vec3(3.+cos(iTime),3.*sin(iTime),3.*cos(iTime)+3.));\n    vec3 light_dir = normalize(vec3(2,1,4));\n    outray.diffuse_color = light_color*dot(light_dir,normal);\n    //outray.diffuse_color = diffuse_color;\n    outray.min_dist = min_dist;\n    return outray;\n}\n\nvec3 initRay(float fov, vec2 size, vec2 fragCoord) {\n    // Move to the center of the screen;\n    vec2 xy = fragCoord - size / 2.0;\n    // \n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 dir = initRay(70.0, iResolution.xy, fragCoord);\n    vec3 camera_o = vec3(iTime,iTime,-3.*iTime+5.);\n    vec3 col = vec3(0.0,0.0,0.0);\n    \n    RayResult res = marchRay(camera_o, dir);\n    \n    if (res.dist < max_camera_dist) {\n        col = res.diffuse_color;\n        \n    } else {\n        //col += vec3(1.0,1.0,0.4)*(1.-pow((res.min_dist),0.1));\n    }\n    // Time varying pixel color\n    float f = clamp(40./res.dist, 0.0, 1.0);\n    col = vec3(0.0,0.25,0.4)*(1.-f) + col*f;\n    //col = clamp(col + vec3(1.0,1.0,0.4)*(1.-pow((res.min_dist),0.5)), 0.0,1.0);\n    \n    // Output to screen\n    \n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}