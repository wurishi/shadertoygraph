{"ver":"0.1","info":{"id":"WtVyRd","date":"1611592577","viewed":211,"name":"Procedural Stones Ground","username":"marcelfernandez13","description":"This shader shows a procedural wet look stones ground.The ground geometry and ao was based on BigWIngs shader:\nhttps://www.shadertoy.com/view/XlcSzM\n\nYou can play with the mouse \"dragging\" to move the light. ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["procedural","raymarching","noise","ground","pbr","wet","stone"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This shader shows a wet look stones ground.\n// The ground geometry and ao was taken from a BigWIngs shader:\n// https://www.shadertoy.com/view/XlcSzM\n//\n// You can play with the mouse to move the light. In Constants section\n// you will find \"vec4 stones\" to control the shape of the stones.\n\n#define MAX_STEPS 100\n#define MAX_DISTANCE 100.0\n#define SURFACE_DIST 0.01\n\n#define PI 3.141592653589793238\n#define GAMMA 2.2\n#define saturate(val) clamp(val, 0.0, 1.0) \n\n// Structs\n\nstruct Material {\n    vec3  albedo;\n    vec3  normal;\n    float NdotL;\n    float NdotH;\n    float NdotV;\n    float HdotL;\n    float metalness;\n    float roughness;\n};\n\n\n// Constants\n\nvec4 stones = vec4(.2, .3, .5, 2.);\nfloat lightIntensity = 3.;\nfloat lightOffset = 7.;\n\n// Global\n\nvec3 lightPos = vec3(0, 2, 7);\n\n// Aux Functions\n\nfloat N2(vec2 p) {\n\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 N21(float p) {\n\tvec2 p2 = fract(vec2(p) * vec2(443.897, 441.423));\n\tp2 += dot(p2, p2.yx + 19.19);\n    return fract((p2.xx+p2.yx)*p2.yy);\n\n}\n\nfloat N2(float x, float y) { return N2(vec2(x, y)); }\n\nvec3 N31(float p) {\t\n   vec3 p3 = fract(vec3(p) * vec3(443.897, 441.423, 437.195));\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nfloat Noise(vec2 uv) {\n    vec2 id = floor(uv);\n    vec2 m = fract(uv);\n    m = 3.* m * m - 2.* m * m * m;\n    \n    float top = mix(N2(id.x, id.y), N2(id.x+1., id.y), m.x);\n    float bot = mix(N2(id.x, id.y+1.), N2(id.x+1., id.y+1.), m.x);\n    \n    return mix(top, bot, m.y);\n}\n\nfloat noiseTex(vec2 uv, float seed, float octaves) {\n    float v = 0.;\n    uv += N21(seed);\n    \n    for (float i = 1.; i <= 11.; i++) {\n    \tv += Noise(uv) / i;\n        uv *= 2.;\n        \n        if (i > octaves) break;\n    }\n    \n    return v * .5;\n}\n\n// Gamma Correction\n\nvec3 gammaToLinear(vec3 col) {\n    return pow(col, vec3(GAMMA));\n}\n\nvec3 linearToGamma(vec3 col) {\n    return pow(col, vec3(1.0 / GAMMA));\n}\n\n// PBR\n\nfloat SchlickFresnel(float dotProduct) {\n    return pow(clamp(1.0 - dotProduct, 0.0, 1.0), 5.0);\n}\n\nfloat Geometry(float NdotV, float alphaG) {\n    float a = alphaG * alphaG;\n    float b = NdotV * NdotV;\n    return 1.0 / (NdotV + sqrt(a + b - a * b));\n}\n\nfloat TrowbridgeReitzNDF(float NdotH, float roughness) {\n    if (roughness >= 1.0)\n        return 1.0 / PI;\n    \n    float roughnessSqr = roughness * roughness;\n    \n    float d = (NdotH * roughnessSqr - NdotH) * NdotH + 1.0;\n    return roughnessSqr / (PI * d * d);\n}\n\n// -------\n\nvec2 GetStoneTiles(vec3 p) {\n    return vec2(p.x + sin(p.z * stones.x), p.z + sin(p.x * stones.y) * stones.z) * stones.w;\n}\n\nfloat getDistance(vec3 p) {\n    float d = p.y;\n    vec2 tiles = GetStoneTiles(p);;\n    vec2 id = floor(tiles);\n    float bump = N2(id.x, id.y);\n\n    vec2 tUv = tiles * PI;\n    float tileMask = abs(sin(tUv.x)*sin(tUv.y));\n    tileMask = 1.0 - pow(1.0 - tileMask, 8.0);\n    d -= tileMask * .09 * bump;\n \n    vec3 n = N31(id.x + id.y * 165.32);\t\n    float detail = sin(n.x * p.x * 15.0) * sin(n.y * p.z * 15.0) * 0.05;\n    detail += sin(n.z * p.x * p.z * 5.0) * 0.005;\n    d += detail;\t\t\t\t\t\n   \n    return d;\n}\n\nfloat GroundAO(vec3 normal, vec3 pos, float dist) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++) {\n    \n        float hr = 0.01 + dist * float(i) / 5.0;\n        vec3 aopos =  normal * hr + pos;\n        float dd = getDistance(aopos);\n        occ += -(dd - hr)*sca;\n        sca *= 0.35;\n    }\n    \n    return saturate(1.0 - 3.0 * occ);    \n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    // Distance to the object\n    float dO = 0.0; \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + (dO * rd);\n        float dS = getDistance(p);\n        dO += dS;\n        if (dS <= SURFACE_DIST || dS > MAX_DISTANCE) break;\n    }\n\n    return dO;\n}\n\nvec3 getNormal(vec3 p) {\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n\tvec3 nor = vec3(\n\t    getDistance(p+eps.xyy) - getDistance(p-eps.xyy),\n\t    getDistance(p+eps.yxy) - getDistance(p-eps.yxy),\n\t    getDistance(p+eps.yyx) - getDistance(p-eps.yyx));\n\treturn normalize(nor);\n}  \n\nvec3 diffuseTerm(Material mat, float lightIntensity) {\n    return (mat.albedo / PI * (1.0 - mat.metalness)) * mat.NdotL * lightIntensity;\n}\n\nvec3 specularTerm(Material mat) {\n    vec3 irradiatedColor = vec3(.3);\n    float specularRoughness = mat.roughness * (1.0 - mat.metalness) + mat.metalness;\n    float D = TrowbridgeReitzNDF(mat.NdotH, specularRoughness);\n    \n    float Cspec0 = 0.02;\n    vec3 F = vec3(mix(Cspec0, 1.0, SchlickFresnel(mat.HdotL)));\n    float alphaG = pow(specularRoughness * 0.5 + 0.5, 2.0);\n    float G = Geometry(mat.NdotL, alphaG) * Geometry(mat.NdotV, alphaG);\n    \n    return (D * G * F * irradiatedColor) * (1.0 + mat.metalness * mat.albedo) +\n                                           irradiatedColor * mat.metalness * mat.albedo;\n}\n\nvec3 renderGround(vec3 p, vec3 v) {\n    vec3 col = vec3(0);\n    Material mat;\n    \n    vec2 uv = p.xz * 5.;\n    mat.albedo = gammaToLinear(vec3(0.5));\n    vec2 noise = vec2(noiseTex(uv, 0., 5.), noiseTex(uv, 12., 5.));\n\n    vec3 l = normalize(lightPos - p);\n    vec3 n = getNormal(p);\n    n.xz += (noise - 0.5) * 2.0;\n    \n    n = normalize(n);\n    \n    mat.normal = n;\n    \n    vec3 h = normalize(v + l);\n    \n    vec2 id = floor(GetStoneTiles(p));\n    mat.albedo *= 1.0 + (N2(id) - 0.5) * 0.3;\t\t\n    \n    float ao = GroundAO(n, p, 1.0);\n    \n    mat.metalness = 1.0 - noise.y;\n    mat.roughness = noise.y;\n    mat.NdotL = dot(n, l);\n    mat.NdotH = dot(h, n);\n    mat.NdotV = dot(n, v);\n    mat.HdotL = dot(h, l);\n    \n    \n    vec3 diff = diffuseTerm(mat, lightIntensity);\n    vec3 specular = saturate(specularTerm(mat));\n    \n    // return specular;\n    return (diff + specular) * ao * dot(vec3(0, 1, 0), l);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Set 0 of uv in the midle of the screen\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    if (iMouse.z > 0.0) {\n        vec2 mouseOffset = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n        lightPos.xz += mouseOffset * lightOffset;\n    } else {\n        lightPos.xz += vec2(sin(iTime), cos(iTime)) * 3.0;\n    }\n\n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0, 4, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y - .5, 1.0));\n    \n    if (rd.y <= .0) {\n        float dist = rayMarch(ro, rd);\n\n        vec3 p = ro + (rd * dist);\n\n        col = renderGround(p, rd);\n    }\n    \n    col = linearToGamma(col);\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}