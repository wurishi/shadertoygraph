{"ver":"0.1","info":{"id":"DlfyDn","date":"1690651124","viewed":87,"name":"2001 A Space Odyssey","username":"imadr","description":"Work in progress, needs a better bloom","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["sun","space","planet","moon","2001"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define bloom_threshold 0.4\n\nconst float coeffs[17] = float[17](\n    0.054357471287453586, 0.05597299121643706, 0.05741187187895187, 0.058658212993637625, 0.059698023499076366, 0.06051948890171193, 0.06111320317982378, 0.06147235962854794, 0.06159275482871962, 0.06147235962854794, 0.06111320317982378, 0.06051948890171193, 0.059698023499076366, 0.058658212993637625, 0.05741187187895187, 0.05597299121643706, 0.054357471287453586\n);\n\nvec3 filmicToneMapping(vec3 color)\n{\n\tcolor = max(vec3(0.), color - vec3(0.004));\n\tcolor = (color * (6.2 * color + .5)) / (color * (6.2 * color + 1.7) + 0.06);\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 texel_size = 1.0 / iResolution.xy;\n    const int M = 8;\n    const int N = 2 * M + 1;\n    vec3 blur = vec3(0.0);\n    for(int i = 0; i < N; ++i){\n\t\tfor (int j = 0; j < N; ++j)\n\t\t{\n            vec2 coord = uv + texel_size * vec2(float(i - M), float(j - M));\n            vec3 col = texture(iChannel0, coord).rgb;\n            float l = col.r * 0.3 + col.g * 0.59 + col.b * 0.11;\n            l = l > bloom_threshold ? l : 0.;\n            if(l < 0.8) continue;\n\t\t\tblur += coeffs[i] * coeffs[j] * vec3(0.906, 0.302, 0)*4.;\n\t\t}\n\t}\n\n    vec3 col = texture(iChannel0, uv).rgb;\n    float noise = (hash12(uv*iTime/100.)+4.)/5.;\n    \n    col = filmicToneMapping(col);\n\n    col += blur;\n    col *= noise;\n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define SUN   1.0\n#define EARTH 2.0\n#define MOON  3.0\n#define PI    3.14159265359\n\n\nvec2 plane(vec3 point, float height, float col){\n    return vec2(point.y-height, col);\n}\n\nvec2 sphere(vec3 point, float radius, float col){\n    return vec2(length(point)-radius, col);\n}\n\nvec2 vec_min(vec2 a, vec2 b){\n    return a.x > b.x ? b : a;\n}\n\nvec2 scene(vec3 point){\n    vec2 moon = sphere(point-vec3(0, -1, 1), 1., MOON);\n    vec2 earth = sphere(point-vec3(0, -0.25, 3.5), 1., EARTH);\n    vec2 sun = sphere(point-vec3(0, 3.4, 14.5), 0.65, SUN);\n    return vec_min(moon, vec_min(sun, earth));\n}\n\nvec2 march(vec3 ray_origin, vec3 ray_direction){\n    vec3 current_point = ray_origin;\n    float dist_total = 0.;\n    float col;\n    for(int i = 0; i < 3000; i++){\n        current_point = ray_origin+ray_direction*dist_total;    \n        vec2 s = scene(current_point);\n        col = s.y;\n        float dist = s.x;\n        dist_total += dist;\n        if(dist < 0.00001){\n            break;\n        }\n        if(dist_total > 1000.){\n            col = 0.;\n            break;\n        }\n    }\n    return vec2(dist_total, col);\n}\n\nvec3 normal(vec3 point){\n    if(point.z > 1000.) return vec3(0.);\n    float dist = scene(point).x;\n    float delta = 0.00001;\n    vec2 dir = vec2(delta, 0.);\n    float dx = scene(point+dir.xyy).x-dist;\n    float dy = scene(point+dir.yxy).x-dist;\n    float dz = scene(point+dir.yyx).x-dist;\n    return normalize(vec3(dx, dy, dz));\n}\n\nfloat lighting(vec3 point, vec3 normal, vec3 light_pos){\n    vec3 direction_to_light = normalize(light_pos);\n    if(march(point+normal*0.001, direction_to_light).x < length(light_pos-point)){\n        return 0.;\n    }\n    return max(0., dot(normal, direction_to_light));\n}\n\n// from https://www.shadertoy.com/view/4t3yzj\nfloat craters(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    float va = 0.;\n    float wt = 0.;\n    for (int i = -2; i <= 2; i++) for (int j = -2; j <= 2; j++) for (int k = -2; k <= 2; k++) {\n        vec3 g = vec3(i,j,k);\n        vec3 o = 0.8 * hash33(p + g);\n        float d = distance(f - g, o);\n        float w = exp(-4. * d);\n        va += w * sin(2.*PI * sqrt(d));\n        wt += w;\n\t}\n    return abs(va / wt);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = gl_FragCoord.xy / iResolution.xy - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float cx = 0.;\n    float sx = 0.;\n    float cy = 0.;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    if( iMouse.z > 0. ) {\n        cx = cos( 10. * mouse.x );\n        sx = sin( 10. * mouse.x );\n        cy = cos( 3.2 * mouse.y );\n    }\n\n    float y_pos = -0.3+0.5*(0.5+0.3)*(1.0+cos(iTime/10.+PI));\n    vec3 camera_pos = vec3(0, y_pos, 0);\n    vec3 camera_target = vec3(0, y_pos, 1);\n    \n    mat3 matrix = lookat_matrix(camera_pos, camera_target, 0.0);\n    vec3 view = matrix * normalize(vec3(uv, 1.0));\n    \n    vec2 march_out = march(camera_pos, view);\n    float depth = march_out.x;\n    vec3 col = vec3(0);\n    \n    if(march_out.y < 0.9){\n        float stars_size = 200.;\n        float stars_number = 0.18;\n        float stars_attenuation = 80.0;\n        float stars = pow(fbm(stars_size * view) + stars_number, stars_attenuation);\n        fragColor = vec4(vec3(stars), 1.0);\n        return;\n    }\n\n    vec3 point = camera_pos+view*depth;\n    vec3 norm = normal(point);\n    vec3 light_position = vec3(0., 0.5, 0.5);\n    float directional_light = lighting(point, norm, light_position);\n    \n    vec3 light = vec3(0);;\n    if(march_out.y == EARTH){\n        vec3 ambient_light = vec3(1.)/1000.;\n        light += ambient_light + directional_light;\n        col = pow(mix(\n            vec3(0.80, 0.94, 0.5),\n            vec3(0., 0.72, 0.96), fbm(10. * point)), vec3(2.0));\n        col += pow(vec3(fbm(8. * point))+0.3, vec3(9.0));\n    }\n    else if(march_out.y == MOON){\n        for(float i = 0.; i < 5.; i++){\n            float c = craters(0.9 * pow(2.7, i) * point);\n            float noise = 0.4 * exp(-3. * c) * fbm(10. * point);\n            float w = clamp(3. * pow(0.6, i), 0.2, 0.8) - noise*8.;\n            col += w * c;\n        }\n        light = pow(vec3(0.07, 0.085, 0.1)*4., vec3(4.1));\n    }\n    \n    col *= light;\n    \n    if(march_out.y == SUN){\n        col = vec3(1, 1, 1);\n    }\n\n    fragColor = vec4(col, 1.); \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float hash(float n){\n    return fract(sin(n)*123.456789);\n}\n\nfloat hash12(vec2 p){\n    vec3 p3  = fract(vec3(p.xyx) * 443.8975);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3){\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nfloat noise(vec3 p){\n    vec3 fl = floor( p );\n    vec3 fr = fract( p );\n    fr = fr * fr * ( 3.0 - 2.0 * fr );\n\n    float n = fl.x + fl.y * 157.0 + 113.0 * fl.z;\n    return mix( mix( mix( hash( n +   0.0), hash( n +   1.0 ), fr.x ),\n                     mix( hash( n + 157.0), hash( n + 158.0 ), fr.x ), fr.y ),\n                mix( mix( hash( n + 113.0), hash( n + 114.0 ), fr.x ),\n                     mix( hash( n + 270.0), hash( n + 271.0 ), fr.x ), fr.y ), fr.z );\n}\n\nfloat fbm(vec3 p){\n    float f;\n    f  = 0.5000 * noise(p); p *= 2.1;\n    f += 0.2500 * noise(p); p *= 2.2;\n    f += 0.1250 * noise(p); p *= 2.3;\n    f += 0.0625 * noise(p);\n    return f;\n}\n\nmat3 lookat_matrix(vec3 origin, vec3 target, float roll) {\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 ww = normalize(target - origin);\n    vec3 uu = normalize(cross(ww, rr));\n    vec3 vv = normalize(cross(uu, ww));\n    return mat3(uu, vv, ww);\n}","name":"Common","description":"","type":"common"}]}