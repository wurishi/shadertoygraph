{"ver":"0.1","info":{"id":"4stXzj","date":"1460895973","viewed":200,"name":"dark ominous clouds","username":"public_int_i","description":"dark evil looking clouds, the other day i tried to make a real-time cloud renderer and it actually turned out decent.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["clouds","dark","ominous"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Ethan Alexander Shulman 2016\n//This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n\n\n#define pi 3.14\n#define lightDirection normalize(vec3(1.,1.,1.))\n#define ambientColor skyColor*.2+vec4(.2)\n#define diffuseColor vec4(.8)\n#define skyColor vec4(.55,.65,.94,1.)\n#define sunColor vec4(1.,.84,.94,1.)*1.35\n#define cloudRoughness .3\n\n\n//2d point rotation\nvec2 rot(in vec2 p, in float a) {\n    return p*mat2(sin(a),cos(a),-cos(a),sin(a));\n}\n//3d point rotation on xy then xz axes\nvec3 rot(in vec3 ip, in vec2 a) {\n    vec3 p = ip;\n    p.yz = rot(p.yz,a.y);\n    p.xz = rot(p.xz,a.x);\n    return p;\n}\n\n//random float 0-1 from seed a\nfloat hash(float a) {\n    return fract(fract(a*24384.2973)*512.34593+a*128.739623);\n}\n//random float 0-1 from seed p\nfloat hash3(in vec3 p) {\n    return fract(fract(p.x)*128.234+fract(p.y)*124.234+fract(fract(p.z)*128.234)+\n                 fract(p.x*128.234)*18.234+fract(p.y*128.234)*18.234+fract(fract(p.z*128.234)*18.234));\n}\n\n//cloud distance function, rough and not an accurate distance\nfloat df(vec3 ip, float i) {\n    \n    float fp = (floor(abs(ip.x)/200.)+floor(abs(ip.z)/200.)*1024.)*2.4321239;\n    vec3 p = vec3(mod(abs(ip.xz),200.)-100., ip.y+hash(fp*.3954+fp*3.49634)*100.-50.).xzy;    \n                \n    float ldst = abs(ip.y)-(6.+cos(cos(ip.x/24.234)+ip.z/131.5435+\n                                   cos(ip.y/33.3958)+ip.x/191.9257+\n                                   cos(ip.z/36.3834)+ip.y/135.3245)*6.);\n    ldst += (cos((ip.x/i)/i+cos(cos((ip.x+ldst*4.)/i)*cloudRoughness+(ip.y*.39)/i)*4.0192854)*\n             cos((ip.y/i)/i+cos(cos(.8+(ip.y+ldst*4.)/i)*cloudRoughness+(ip.z*.37)/i)*4.0817395)*\n             cos((ip.z/i)/i+cos(cos(1.6+(ip.z+ldst*4.)/i)*cloudRoughness+(ip.x*.41)/i)*4.0243927))*i+min(3.,length(p.xz)*.05);\n    \n    return max(.2, ldst);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //setup ray from pixel coordinate, camera rotation and camera origin\n\tvec3 rd = normalize(vec3( (fragCoord*2.-iResolution.xy)/iResolution.x, 1. )),\n \t\t rp = vec3(0.,cos(iTime*.12945)*100.-80.,iTime*20.);\n\n\tvec2 cameraRotation = vec2(pi/2.+cos(iTime*.0963)*2., pi/3.+cos(iTime*.12945)*.23);\n\trd = rot(rd,cameraRotation);\n\n    //rough transparent object ray marching with 4 lod's for lighting\n\t//only 1 lod is rendered each step and lod's are switched each step for speed\n    vec2 c = vec2(0.);\n    float s = 0., im = 2.;\n    for (int i = 0; i < 64; i++) {\n        vec3 pd = rp+rd*s;\n        float ie = pow(im = mod(im,4.)+1., 2.),\n              od = df(pd, ie);\n        c += vec2( (df(pd+lightDirection*(ie*2.), ie)-od)/(ie*2.),\n                    .02)*pow(max(0.,(ie*.4-od))/(ie*.4),4.);\n        if (c.y >= 1.) break;\n        \n        s += od*(.5+hash3(pd)*.4);\n    }\n    c.x *= .07;\n    \n    fragColor = c.xyyy;\n}","name":"Image","description":"","type":"image"}]}