{"ver":"0.1","info":{"id":"mlXfW4","date":"1697128389","viewed":18,"name":"mouse_mdm_cleanup","username":"mariano_dm","description":"a mouse head for computer graphics course","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","interview"],"hasliked":0,"parentid":"clXfW8","parentname":"mouse_mdm 880"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Things to have a student do:\n// * MAKE IT PRETTY! I'm color blind, so you're going to have to fix the colors yourself!!!\n// * Explain why the ground plane has blinking band in the distance. Why does it bend\n//   near the object? How might it be reduced? How might it be elimininated (almost)\n//   entirely with minimal computational cost?\n// * Write a function that can be used to recenter any object to <0.5, 0.5, 0.5>\n//   * Use this function to get rid of the hard-coded offset in map_ground_plane\n//   * Instance the recentered object. (In-person only.)\n// * Make the object reflective. GLSL has a reflect() function.\n// * How would you support lots of unrelated objects, each with their own shading \n//   functions? What are the advantages/drawbacks of doing a trace of the whole world\n//   in one loop, versus having one loop for each compound object?\n// * Multiple light sources? If you put several light sources close enough together,\n//   it can look like you have \"soft\" shadows.\n\nconst float PI = 3.141592657;\n\nfloat map_composite_object( in vec3 p) {\n    float dist = smooth_union(\n    //Head\n    sdf_sphere(p, 1.5),\n    //Nose\n    sdf_sphere(p - vec3(1.7,0.0,0.0),0.4), 0.3);\n    //Ears\n    dist = hard_union(dist, \n        hard_subtraction(sdf_sphere( p-vec3(0.4,1.7,-0.7),0.6), \n        sdf_sphere( p-vec3(0.5,1.7,-0.7),0.6) ));\n    dist = hard_union(dist,\n        hard_subtraction(sdf_sphere( p-vec3(0.4,1.7,0.7),0.6),\n        sdf_sphere( p-vec3(0.5,1.7,0.7),0.6) ));\n    \n    //Eyes\n    dist = hard_union(dist,\n        hard_subtraction(sdf_sphere( p-vec3(0.9,0.8,-0.5),0.4), \n        sdf_sphere( p-vec3(1.2,1.1,-0.6),0.1) ));\n    \n    dist = hard_union(dist,\n        hard_subtraction(sdf_sphere( p-vec3(0.9,0.8,0.5),0.4), \n        sdf_sphere( p-vec3(1.2,1.1,0.6),0.1) ));\n    \n    //whiskers\n    dist = hard_union(dist,sdCapsule( p-vec3(0.7,0.1,0.5),vec3(0.8,0.1,0.5), vec3(0.8,0.0,0.0), 0.05 ));\n    dist = hard_union(dist,sdCapsule( p-vec3(0.7,0.2,0.5),vec3(0.8,0.2,0.5), vec3(0.8,0.0,0.0), 0.05 )); \n    dist = hard_union(dist,sdCapsule( p-vec3(0.7,0.2,0.4),vec3(0.8,0.3,0.4), vec3(0.8,0.0,0.0), 0.05 ));\n\n    dist = hard_union(dist,sdCapsule( p-vec3(0.7,0.1,-0.5),vec3(0.8,0.1,-0.5), vec3(0.8,0.0,0.0), 0.05 ));\n    dist = hard_union(dist,sdCapsule( p-vec3(0.7,0.2,-0.5),vec3(0.8,0.2,-0.5), vec3(0.8,0.0,0.0), 0.05 )); \n    dist = hard_union(dist,sdCapsule( p-vec3(0.7,0.2,-0.4),vec3(0.8,0.3,-0.4), vec3(0.8,0.0,0.0), 0.05 ));\n    return dist;  \n}\n\nfloat map_ground_plane( in vec3 p) {\n    return p.y + 2.0;\n}\n\n\nvec3 calc_normal( in vec3 p ) // for function f(p)\n{\n    const float eps = 0.0001; // or some other value\n    const vec2 h = vec2(eps,0);\n    vec3 normal = normalize( \n        vec3(map_composite_object(p+h.xyy) - map_composite_object(p-h.xyy),\n             map_composite_object(p+h.yxy) - map_composite_object(p-h.yxy),\n             map_composite_object(p+h.yyx) - map_composite_object(p-h.yyx) ) );\n    return normal;\n}\n\nbool is_shadowed(in vec3 p, in vec3 normal, in vec3 light_pos) {\n    float distance_travelled = 0.0;\n    \n    // p is already very close to a surface. If we just check to see how far from\n    // that surface we are and assume we've hit it when d<0.001, we'll always think\n    // we've hit it in the first iteration. What happens if this value is too small?\n    p += normal * 0.002;\n    vec3 light_dir = light_pos - p;\n    float dist_to_light = length(light_dir);\n    //normalize light_dir:\n    light_dir /= dist_to_light;\n    \n    for(int iterations = 0; iterations < 150; iterations++) {\n        float d = map_composite_object(p);\n        distance_travelled += d;\n        if(distance_travelled > dist_to_light) {\n            return false;\n        }\n        if(d < 0.001) {\n            return true;\n        }\n        p += d * light_dir;\n    }\n    \n    // you could make an argument to go either way... true is probably better.\n    return true;\n}\n    \n// MAKE VERY SURE THAT normal IS NORMALIZED (length == 1.0)\nvec3 lighting(in vec3 p, in vec3 normal, in vec3 light_col, in vec3 light_pos, in vec3 surface_col) {\n    if(is_shadowed(p, normal, light_pos)) {\n        return vec3(0.0);\n    }\n    vec3 light_dir = normalize(light_pos - p);\n    float diffuse_brightness = dot(normal, light_dir);\n    return diffuse_brightness * light_col * surface_col;\n}\n\n// Nothing says the light_col is limited to values <= 1.0!!!\nvec3 light_col = vec3(0.8, 1.0, 0.3);\nvec3 light_pos = vec3(2.0, 6.0, 3.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // We want 0,0 to be the center of the screen, so rescale and recenter:\n    uv *= 2.0;\n    uv -= 1.0;\n    \n    // The pixels in the image now go from <-1.0, -1.0> at the bottom left to\n    // <1.0, 1.0> at the top right. This means our pixels are squashed. Rescale\n    // in the y direction to compensate:\n    uv.y /= (iResolution.x/iResolution.y);\n    \n    // Set up the camera:\n    float camera_distance_from_origin = 8.0;\n    vec3 camera_position = vec3(\n        sin(iTime/2.0) * camera_distance_from_origin,\n        2.5,\n        cos(iTime/2.0) * camera_distance_from_origin);\n    vec3 camera_lookat_point = vec3(0.0, 0.0, 0.0);\n    \n    // Setting up the camera takes a bit of magic. The cross product of two vectors gives\n    // you a third vector at right angles to both of the input vectors. Our camera is at \n    // some arbitrary point in space, pointing at some other arbitrary point in space. To\n    // figure out which way is up and which way is right, we have to do some assuming. We\n    // want the camera to be level, so the right vector must be perpendicular to <0, 1, 0>\n    // AND the look direction, so let's start with that:\n    // !!!!NOTE!!!!\n    // This all goes to hell if your camera is directly above or below the lookat point,\n    // because the cross product of the look vector and <0, 1, 0> is undefined. Don't.\n    vec3 look_direction = normalize(camera_lookat_point - camera_position);\n    vec3 right = normalize(cross(look_direction, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, look_direction));\n    \n    // To get the direction a \"reverse photon\" travels from the eyepoint, we put the uv \n    // \"screen\" in front of the eyepoint and find the vector from the eyepoint through\n    // the pixel we're currently processing:\n    float eyepoint_to_screen_distance = 2.0;\n    vec3 pixel_location = camera_position + eyepoint_to_screen_distance * look_direction +\n        right * uv.x + up * uv.y;\n    vec3 ray_direction = normalize(pixel_location - camera_position);\n    \n    // 1) Start at the camera position.\n    // 2) Check to see how far current_position is from object(s).\n    // 3) Move along the camera->pixel direction by that distance.\n    // 4) goto 2, until you've either gone too far from objects to expect to ever hit them,\n    //    or, you're so close to one that we'll assume you've hit the object.\n    // 5) If you hit the compound object, find its normal and just use that as its color,\n    //    otherwise, you hit the ground plane and choose a color that paints the grid.\n    // 6) If you've iterated too many times, give up and return blinking green to draw\n    //    attention to the issue.\n    vec3 current_position = camera_position;\n\n    for(int iterations=0; iterations<150; iterations++) {\n        float comp_dist = map_composite_object(current_position);\n        float plane_dist = map_ground_plane(current_position);\n        float dist = min(comp_dist, plane_dist);\n        current_position += dist * ray_direction;\n        if(dist < 0.001) {\n            vec3 diffuse_col;\n            if(comp_dist < plane_dist) {\n                vec3 normal = calc_normal(current_position);\n                diffuse_col = lighting(current_position, normal, light_col, light_pos, vec3(1.0));\n            } else {\n                // Compute the ground plane color intensity:\n                vec3 c = vec3(0.9 + 0.05*cos(current_position.x) + 0.05*cos(current_position.z));\n                diffuse_col = lighting(current_position, vec3(0.0, 1.0, 0.0), light_col, light_pos, c);\n\n            }\n            fragColor.rgb = diffuse_col;\n            return;\n        } else if (dist > 10.0) {\n            fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n            return;\n        }\n    }\n    \n    // This is our error case. We didn't hit anything, but we iterated so long that we\n    // had to give up. \n    fragColor.g = 0.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float hard_union( float d0, float d1 ) {\n    return(min(d0, d1));\n}\n\nfloat hard_subtraction( float d0, float d1 ) {\n    return(max(d0, -d1));\n}\n\nfloat hard_intersection( float d0, float d1 ) {\n    return(max(d0, d1));\n}\n\nfloat smooth_union( float d0, float d1, float k ) {\n    float h = clamp( 0.5 + 0.5*(d0-d1)/k, 0.0, 1.0 );\n    return mix( d0, d1, h ) - k*h*(1.0-h); }\n\nfloat smooth_subtraction( float d0, float d1, float k ) {\n    float h = clamp( 0.5 - 0.5*(d0+d1)/k, 0.0, 1.0 );\n    return mix( d0, -d1, h ) + k*h*(1.0-h); }\n\nfloat smooth_intersection( float d0, float d1, float k ) {\n    float h = clamp( 0.5 - 0.5*(d0-d1)/k, 0.0, 1.0 );\n    return mix( d0, d1, h ) + k*h*(1.0-h); }\n\n\n// LOOK AT https://iquilezles.org/articles/distfunctions/ for the best SDF reference\n// anywhere.\n\n// The \"signed distance function\" for a box with rounded corners. \nfloat sdf_rounded_box( in vec3 p, in vec3 r, in float radius) {\n    return length(max(abs(p) - r, 0.0)) - radius;\n}\n\nfloat sdf_sphere( in vec3 p, in float radius) {\n    return length(p) - radius;\n}\n\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n  // sampling independent computations (only depend on shape)\n  float w = sqrt(r*r-h*h);\n  \n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : \n                          abs(length(q)-r) ) - t;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n","name":"Common","description":"","type":"common"}]}