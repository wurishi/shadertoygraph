{"ver":"0.1","info":{"id":"NsfXW8","date":"1618517622","viewed":110,"name":"Hallway | skylerr","username":"isqaa","description":"Based on Superliminal","likes":2,"published":1,"flags":32,"usePreview":1,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int kernelSize = 11;\nfloat sigma = 20.0f;\nconst int filterSize = 5;\n\nfloat gaussian(float x, float sigma) {\n    return 0.39894 * exp(-0.5f * x * x / (sigma * sigma)) / sigma;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 uv = texture(iChannel0, fragCoord / iResolution.xy);\n    vec3 color = uv.rgb;\n    float blurInterpolation = uv.a;\n    \n    float kernel[kernelSize];\n    for (int i = 0; i <= filterSize; i++) {\n        kernel[filterSize + i] = gaussian(float(i), sigma);\n        kernel[filterSize - i] = gaussian(float(i), sigma);\n    }\n    \n    float normalization = 0.0f;\n    for (int i = 0; i < kernelSize; i++) {\n        normalization += kernel[i];\n    }\n    \n    vec3 blurredColor = vec3(0);\n    for (int x = -filterSize; x <= filterSize; x++) {\n        for (int y = -filterSize; y <= filterSize; y++) {\n            vec3 textureColor = texture(iChannel0, (fragCoord.xy + vec2(x, y)) / iResolution.xy).rgb;\n            blurredColor += kernel[filterSize + x] * kernel[filterSize + y] * textureColor;\n        }\n    }\n    blurredColor /= float(normalization) * float(normalization);\n    \n    fragColor = vec4(mix(color, blurredColor, blurInterpolation), 1.0f);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Colors\nvec3 cyan = vec3(0, 1, 1);\nvec3 red = vec3(1, 0, 0);\nvec3 green = vec3(0, 1, 0);\nvec3 white = vec3(1);\nvec3 black = vec3(0);\nvec3 pink = vec3(233,185,171);\nvec3 mediumPink = vec3(222, 159, 151);\nvec3 darkPink = vec3(199,132,123);\nvec3 brown = vec3(120,47,22);\nvec3 darkRed = vec3(143,1,7);\nvec3 lightRed = vec3(202,28,37);\nvec3 yellow = vec3(246,217,183);\nvec3 veryDarkPink = vec3(179, 100, 91);\nvec3 gray = vec3(222);\n\n// Ray marching\nfloat epsilon = 0.0001f;\nfloat maxRayTravel = 800.0f;\n\n// Camera\nvec3 cameraPosition = vec3(0, -1.0f, -50.0f);\nvec3 cameraRef = vec3(0, 0, 0);\nvec3 worldUp = vec3(0, 1, 0);\nfloat fov = radians(19.5f);\nfloat focalLength = 15.0f;\nfloat focalRange = 30.0f;\n\n// Ambient Occlusion\nconst float aoDistance = 0.2f;\nconst float fiveTapK = 0.8f;\n\n// Shadows\nfloat minT = 0.1f;\nfloat maxT = 2.0f;\nfloat k = 2.5f;\n\n// Smooth blending\nfloat blendK = 40.0f;\n\nstruct Intersection {\n    vec3 color;\n    float t;\n    float d;\n    vec3 point;\n    vec3 normal;\n    float ao;\n    float lit;\n};\n\nvec3 lightPosition = vec3(1.0f, 0, 0);\nvec3 lightColor = vec3(1.0f);\nfloat ambientLight = 0.5f;\n\nIntersection defaultIntersection = Intersection(vec3(0.780f, 0.517f, 0.482f), 0.0f, 1e10, vec3(0.0f), vec3(0.0f), 0.0f, 0.0f);\n\nmat4 rotate(vec3 axis, float angle) {\n    float c = 1.0f - cos(angle);\n    return mat4(\n        vec4(\n            cos(angle) + pow(axis.x, 2.0f) * c,\n            axis.z * sin(angle) + axis.x * axis.y * c,\n            -1.0f * axis.y * sin(angle) + axis.x * axis.z * c,\n            0),\n        vec4(\n            -1.0f * axis.z * sin(angle) + axis.x * axis.y * c,\n            cos(angle) + pow(axis.y, 2.0f) * c,\n            axis.x * sin(angle) + axis.y * axis.z * c,\n            0),\n        vec4(\n            axis.y * sin(angle) + axis.x * axis.z * c,\n            -1.0f * axis.x * sin(angle) + axis.y * axis.z * c,\n            cos(angle) + pow(axis.z, 2.0f) * c,\n            0\n        ),\n        vec4(0, 0, 0, 1.0f)\n    );\n}\n\nmat4 transformMatrix(vec3 t, vec3 r, vec3 s) {\n    mat4 translate = mat4(vec4(1.0f, 0, 0, 0), vec4(0, 1.0f, 0, 0), vec4(0, 0, 1.0f,  0), vec4(t, 1.0f));\n    mat4 rotateX = rotate(vec3(1.0f, 0, 0), radians(r.x));\n    mat4 rotateY = rotate(vec3(0, 1.0f, 0), radians(r.y));\n    mat4 rotateZ = rotate(vec3(0, 0, 1.0f), radians(r.z));\n    mat4 scale = mat4(vec4(s.x, 0, 0, 0), vec4(0, s.y, 0, 0), vec4(0, 0, s.z, 0), vec4(0, 0, 0, 1.0f));\n    return translate * rotateX * rotateY * rotateZ * scale;\n}\n\nmat4 transforms[18];\nmat4 invTransforms[18];\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nvec2 random2(vec2 p) {\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\nvec2 pow2(vec2 p, float x) { return vec2(pow(p.x, x), pow(p.y, x)); }\n\nfloat surflet(vec2 p, vec2 gridPoint) {\n    vec2 t2 = abs(p - gridPoint);\n    vec2 t = vec2(1.0f) - 6.0f * pow2(t2, 5.0f) + 15.0f * pow2(t2, 4.0f) - 10.0f * pow2(t2, 3.0f);\n    vec2 gradient = random2(gridPoint) * 2.0f- vec2(1.0f);\n    vec2 diff = p - gridPoint;\n    float height = dot(diff, gradient);\n    return height * t.x * t.y;\n}\n\nfloat perlin2D(vec2 p) {\n    float sum = 0.0f;\n    sum += surflet(p, floor(p) + vec2(0.0f));\n    sum += surflet(p, floor(p) + vec2(0.0f, 1.0f));\n    sum += surflet(p, floor(p) + vec2(1.0f, 0.0f));\n    sum += surflet(p, floor(p) + vec2(1.0f));\n    return sum;\n}\n\nfloat boxSDF(vec3 p, int i) {\n    float sideLength = 1.0f;\n    p = vec3(invTransforms[i] * vec4(p, 1));\n    vec3 q = abs(p) - vec3(sideLength / 2.0f);\n    return length(max(q, 0.0f)) + min(max(q.x, max(q.y, q.z)), 0.0f);\n}\n\nfloat planeSDF(vec3 p, int i) {\n    float sideLength = 1.0f;\n    p = vec3(invTransforms[i] * vec4(p, 1));\n    vec3 normal = vec3(0.0f, 0.0f, 1.0f);\n    float scale = 1.0f;\n    float h = sideLength / 2.0f;\n    float distanceFromPlane = abs(dot(p, normal));\n\n    if (p.x >= -h && p.x <= h && p.y >= -h && p.y <= h) {\n        return distanceFromPlane / scale;\n    } else {\n        vec2 p2D = vec2(abs(p.x), abs(p.y));\n        float distanceFromEdge = length(max(p2D - vec2(h, h), 0.0f));\n        return sqrt((distanceFromPlane * distanceFromPlane) + (distanceFromEdge * distanceFromEdge)) / scale;\n    }\n}\n\nfloat cylinderSDF(vec3 p, int i) {\n    float r = 0.1f;\n    float h = 0.1f;\n    p = vec3(invTransforms[i] * vec4(p, 1));\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(h, r);\n    return min(max(d.x, d.y), 0.0f) + length(max(d, 0.0f));\n}\n\nfloat roundCylinderSDF(vec3 p, int i, float ra, float rb, float h) {\n    p = vec3(invTransforms[i] * vec4(p, 1));\n    vec2 d = vec2(length(p.xz) - 2.0f * ra + rb, abs(p.y) - h);\n    return min(max(d.x, d.y), 0.0f) + length(max(d, 0.0f)) - rb;\n}\n\nfloat coneSDF(vec3 p, int i, float h, float r1, float r2) {\n  p = vec3(invTransforms[i] * vec4(p, 1));\n  vec2 q = vec2(length(p.xz), p.y);\n  vec2 k1 = vec2(r2, h);\n  vec2 k2 = vec2(r2 - r1, 2.0f * h);\n  vec2 ca = vec2(q.x - min(q.x, (q.y < 0.0f) ? r1 : r2), abs(q.y) - h);\n  vec2 cb = q - k1 + k2 * clamp(dot(k1 - q, k2) / dot2(k2), 0.0f, 1.0f);\n  float s = (cb.x < 0.0f && ca.y < 0.0f) ? -1.0f : 1.0f;\n  return s * sqrt(min(dot2(ca), dot2(cb)));\n}\n\nfloat sphereSDF(vec3 p, int i) {\n    p = vec3(invTransforms[i] * vec4(p, 1));\n    return length(p) - 0.4f;\n}\n\nfloat smoothBlendSDF(float a, float b) {\n    // float h = clamp(0.5f + 0.5f * (b - a) / blendK, 0.0f, 1.0f);\n    // return mix(b, a, h) - k * h * (1.0f - h);\n    //a = pow( a, k ); b = pow( b, blendK );\n    //return pow( (a*b)/(a+b), 1.0f/blendK );\n    \n    float res = exp2( -blendK*a ) + exp2( -blendK*b );\n    return -log2( res )/blendK;\n}\n\nfloat pawnSDF(vec3 p) {\n    float sphereD = sphereSDF(p, 12);\n    float coneD = coneSDF(p, 13, 0.5f, 0.4f, 0.2f);\n    float cylinderD = roundCylinderSDF(p, 14, 0.35f, 0.35f, 0.05f);\n    return smoothBlendSDF(smoothBlendSDF(sphereD, coneD), cylinderD);\n}\n\nfloat doorSDF(vec3 p) {\n    float frame = boxSDF(p, 15);\n    float cutout = boxSDF(p, 16);\n    return max(-frame, cutout);\n}\n\nvec3 repeatSDFInput(vec3 p, vec3 center) {\n    return mod(p + 0.5f * center, center) - 0.5f * center;\n}\n\nvec3 boxNormal(vec3 p, int i) {\n    float dx = boxSDF(vec3(p.x + epsilon, p.y, p.z), i) - boxSDF(vec3(p.x - epsilon, p.y, p.z), i);\n    float dy = boxSDF(vec3(p.x, p.y + epsilon, p.z), i) - boxSDF(vec3(p.x, p.y - epsilon, p.z), i);\n    float dz = boxSDF(vec3(p.x, p.y, p.z + epsilon), i) - boxSDF(vec3(p.x, p.y, p.z - epsilon), i);\n    return normalize(vec3(dx, dy, dz));\n}\n\nvec3 planeNormal(vec3 p, int i) {\n    vec3 normal = vec3(0, 0.0f, 1.0f);\n    return normalize((transforms[i] * vec4(normal, 0)).xyz);\n}\n\nvec3 coneNormal(vec3 p, int i, float h, float r1, float r2) {\n    float dx = coneSDF(vec3(p.x + epsilon, p.y, p.z), i, h, r1, r2) - coneSDF(vec3(p.x - epsilon, p.y, p.z), i, h, r1, r2);\n    float dy = coneSDF(vec3(p.x, p.y + epsilon, p.z), i, h, r1, r2) - coneSDF(vec3(p.x, p.y - epsilon, p.z), i, h, r1, r2);\n    float dz = coneSDF(vec3(p.x, p.y, p.z + epsilon), i, h, r1, r2) - coneSDF(vec3(p.x, p.y, p.z - epsilon), i, h, r1, r2);\n    return normalize(vec3(dx, dy, dz));\n}\n\nvec3 pawnNormal(vec3 p) {\n    float dx = pawnSDF(vec3(p.x + epsilon, p.y, p.z)) - pawnSDF(vec3(p.x - epsilon, p.y, p.z));\n    float dy = pawnSDF(vec3(p.x, p.y + epsilon, p.z)) - pawnSDF(vec3(p.x, p.y - epsilon, p.z));\n    float dz = pawnSDF(vec3(p.x, p.y, p.z + epsilon)) - pawnSDF(vec3(p.x, p.y, p.z - epsilon));\n    return normalize(vec3(dx, dy, dz));\n}\n\nvec3 doorNormal(vec3 p) {\n    float dx = doorSDF(vec3(p.x + epsilon, p.y, p.z)) - doorSDF(vec3(p.x - epsilon, p.y, p.z));\n    float dy = doorSDF(vec3(p.x, p.y + epsilon, p.z)) - doorSDF(vec3(p.x, p.y - epsilon, p.z));\n    float dz = doorSDF(vec3(p.x, p.y, p.z + epsilon)) - doorSDF(vec3(p.x, p.y, p.z - epsilon));\n    return normalize(vec3(dx, dy, dz));\n}\n\nIntersection getSceneIntersection(vec3 origin, vec3 direction, float t, bool shadowCheck) {\n    vec3 p = origin + t * direction;\n    vec3 q = repeatSDFInput(p, vec3(0.0f, 0.0f, 10.0f));\n    vec3 q_30 = repeatSDFInput(p, vec3(0.0f, 0.0f, 30.0f));\n    vec3 q_40 = repeatSDFInput(p, vec3(0.0f, 0.0f, 40.0f));\n    vec3 q_50 = repeatSDFInput(p, vec3(0.0f, 0.0f, 50.0f));\n    vec3 q_60 = repeatSDFInput(p, vec3(0.0f, 0.0f, 60.0f));\n    vec3 q_180 = repeatSDFInput(p, vec3(0.0f, 0.0f, 180.0f));\n    float minDistance = maxRayTravel;\n    float newDistance;\n    Intersection i = defaultIntersection;\n    \n    // Right Wall, 1\n    newDistance = planeSDF(q, 0);\n    if (newDistance < minDistance) {\n        minDistance = newDistance;\n        i.color = (p.y < -2.0f ? darkPink : pink) / 255.0f;\n        i.color *= p.y > 5.0f ? (5.8f - p.y) : 1.0f;\n        \n        if (p.y < -2.4f && p.y > -4.6f && mod(p.z, 10.0f) < 8.0f) {\n            i.color = mediumPink / 255.0f;\n        }\n        if (minDistance < epsilon) {\n            i.normal = planeNormal(q, 0);\n        }\n    }\n    \n    // Left Wall, 2\n    newDistance = planeSDF(q, 1);\n    if (newDistance < minDistance) {\n        minDistance = newDistance;\n        i.color = (p.y < -2.0f ? darkPink : pink) / 255.0f;\n        i.color *= p.y > 5.0f ? (5.8f - p.y) : 1.0f;\n        if (p.y < -2.4f && p.y > -4.6f && mod(p.z, 10.0f) < 8.0f) {\n            i.color = mediumPink / 255.0f;\n        }\n        if (minDistance < epsilon) {\n            i.normal = planeNormal(q, 1);\n        }\n    }\n    \n    // Ceiling, 3\n    newDistance = planeSDF(q, 2);\n    if (newDistance < minDistance) {\n        minDistance = newDistance;\n        i.color = pink / 255.0f;\n        if (minDistance < epsilon) {\n            i.normal = planeNormal(q, 2);\n        }\n    }\n    \n    // Floor, 4\n    newDistance = planeSDF(q, 3);\n    if (newDistance < minDistance) {\n        minDistance = newDistance;\n        float brightness = 5.0f;\n        float r = clamp(perlin2D(p.xz / 1.5f) / brightness + (1.0f - (1.0f / brightness)), 0.0f, 1.0f);\n        i.color = ((abs(p.x) < 3.0f) ? lightRed * r : (abs(p.x) < 3.5f) ? darkRed * r : brown) / 255.0f;\n        if (minDistance < epsilon) {\n            i.normal = planeNormal(q, 3);\n        }\n    }\n    \n    // Left wall extrusion\n    newDistance = boxSDF(q_30, 4);\n    if (newDistance < minDistance) {\n        minDistance = newDistance;\n        i.color = (p.y < -2.0f ? darkPink : pink) / 255.0f;\n        if (minDistance < epsilon) {\n            i.normal = boxNormal(q_30, 4);\n        }\n    }\n    \n    // Second Cube, 6\n    newDistance = boxSDF(q_30, 5);\n    if (newDistance < minDistance) {\n        minDistance = newDistance;\n        i.color = (p.y < -2.0f ? darkPink : pink) / 255.0f;\n        if (minDistance < epsilon) {\n            i.normal = boxNormal(q_30, 5);\n        }\n    }\n    \n    // Puck light outer, 6\n    newDistance = cylinderSDF(q_30, 6);\n    if (newDistance < minDistance) {\n        minDistance = newDistance;\n        i.color = black / 255.0f;\n        if (minDistance < epsilon) {\n            i.normal = boxNormal(q_30, 6);\n        }\n    }\n    \n    // Puck light, 7\n    newDistance = cylinderSDF(q_30, 7);\n    if (newDistance < minDistance) {\n        minDistance = newDistance;\n        i.color = white;\n        if (minDistance < epsilon) {\n            i.normal = boxNormal(q_30, 7);\n        }\n    }\n    \n    // cone, 8\n    if (!shadowCheck) {\n        newDistance = coneSDF(q_60, 8, 0.25f, 0.35f, 0.2f);\n        if (newDistance < minDistance) {\n            minDistance = newDistance;\n            i.color = yellow / 255.0f;\n            i.ao = 1.0f;\n            if (minDistance < epsilon) {\n                i.lit = 1.0f;\n                i.normal = coneNormal(q_60, 8, 0.25f, 0.35f, 0.2f);\n            }\n        }\n    }\n    \n    \n    // vents, 9\n    newDistance = boxSDF(q_60, 9);\n    if (newDistance < minDistance) {\n        minDistance = newDistance;\n        i.color = white;\n        i.color = mix(vec3(0.8f), vec3(0.6f), mod(floor(p.y * 30.0f), 2.0f));\n        if (minDistance < epsilon) {\n            i.normal = boxNormal(q_60, 9);\n        }\n    }\n    \n    // lamp pole\n    if (!shadowCheck) {\n    newDistance = boxSDF(q_60, 10);\n    if (newDistance < minDistance) {\n        minDistance = newDistance;\n        i.color = brown / 255.0f;\n        if (minDistance < epsilon) {\n            i.normal = boxNormal(q_60, 10);\n            i.lit = 1.0f;\n        }\n    }\n    }\n    \n    // lamp pole\n    if (!shadowCheck) {\n    newDistance = boxSDF(q_60, 11);\n    if (newDistance < minDistance) {\n       minDistance = newDistance;\n       i.color = brown / 255.0f;\n       if (minDistance < epsilon) {\n           i.normal = boxNormal(q_60, 11);\n           i.lit = 1.0f;\n       }\n    }\n    }\n    \n    // pawn\n    newDistance = pawnSDF(q_180);\n    if (newDistance < minDistance) {\n       minDistance = newDistance;\n       i.color = white;\n       if (minDistance < epsilon) {\n           i.normal = pawnNormal(q_180);\n       }\n    }\n    \n    // door, 15-16\n    if (!shadowCheck) {\n    newDistance = doorSDF(q_60);\n    if (newDistance < minDistance) {\n       minDistance = newDistance;\n       i.color = gray / 255.0f;\n       if (minDistance < epsilon) {\n           i.normal = doorNormal(q_60);\n       }\n    }\n    }\n    \n    // fire alarm\n    newDistance = boxSDF(q_60, 17);\n    if (newDistance < minDistance) {\n       minDistance = newDistance;\n       i.color = vec3(1, 0, 0);\n       if (minDistance < epsilon) {\n           i.normal = boxNormal(q_60, 17);\n       }\n    }\n\n    i.point = p;\n    i.d = minDistance;\n    \n    return i;\n}\n\nIntersection getSceneIntersection(vec3 origin, vec3 direction, float t) {\n    return getSceneIntersection(origin, direction, t, false);\n}\n\nfloat computeAO(vec3 origin, vec3 normal) {\n    float sum = 0.0f;\n    for (int i = 0; i < 5; i++) {\n        vec3 p = origin + normal * float(i) * aoDistance;\n        Intersection intersection = getSceneIntersection(origin, normal, float(i) * aoDistance);\n        sum += (1.0f / pow(2.0f, float(i))) * (float(i) * aoDistance - intersection.d);\n        \n    }\n    return 1.0f - (fiveTapK * sum);\n}\n\nIntersection rayMarch(vec3 origin, vec3 direction) {\n    float t = 0.0f;\n    while (t < maxRayTravel) {\n        Intersection i = getSceneIntersection(origin, direction, t);\n        t += i.d;\n        if (i.d < epsilon) {\n            i.t = t;\n            return i;\n        }\n    }\n    Intersection i = defaultIntersection;\n    i.t = maxRayTravel;\n    return i;\n}\n\nfloat softShadow(vec3 dir, vec3 origin) {\n    float res = 1.0f;\n    for (float t = minT; t < maxT;) {\n        float m = getSceneIntersection(origin, dir, t, true).d;\n        if (m < 0.0001f) return 0.0f;\n        res = min(res, k * m / t);\n        t += m;\n    }\n    return res;\n}\n\nvec3 getRayDirection(vec2 position) {\n    vec3 forward = normalize(cameraPosition - cameraRef);\n    vec3 right = normalize(cross(worldUp, forward));\n    vec3 up = normalize(cross(right, forward));\n    \n    float a = fov / 2.0f;\n    float len = length(cameraRef - cameraPosition);\n    \n    vec3 v = up * len * tan(a);\n    vec3 h = right * len * (iResolution.x / iResolution.y) * tan(a);\n    vec3 p = cameraRef + (position.x * h) + (position.y * v);\n    return normalize(p - cameraPosition);\n}\n\nvec2 toNDC(vec2 p) {\n    return vec2(\n        (p.x / (iResolution.x / 2.0f)) - 1.0f,\n        ((iResolution.y - p.y) / (iResolution.y / 2.0f)) - 1.0f);\n}\n\nvoid setShapeTransforms(float z) {\n    transforms = mat4[](\n        transformMatrix(vec3(5, 0, 0), vec3(0, -90.0f, 0), vec3(10.0f, 14.0f, 1.0f)), // Right wall\n        transformMatrix(vec3(-5, 0, 0), vec3(0, 90.0f, 0), vec3(10.0f, 14.0f, 1.0f)), // Left wall\n        transformMatrix(vec3(0, 5, 0), vec3(90.0f, 0, 0), vec3(9.0f, 10.0f, 1.0f)), // Ceiling\n        transformMatrix(vec3(0, -5, 0), vec3(-90.0f, 0, 0), vec3(10.0f, 10.0f, 1.0f)), // Floor\n        transformMatrix(vec3(4.5, 0, 0), vec3(0, 0, 0), vec3(1, 10, 3)), // Left wall extrusion\n        transformMatrix(vec3(-4.5, 0, 0), vec3(0, 0, 0), vec3(1, 10, 3)), // Right wall extrusion\n        transformMatrix(vec3(0, 4.9, 0), vec3(0, 0, 0), vec3(3.0f, 1.0f, 3.0f)), // black light\n        transformMatrix(vec3(0, 4.8, 0), vec3(0, 0, 0), vec3(2.0f, 1.0f, 2.0f)), // white light\n        transformMatrix(vec3(3.1f, 0, 0), vec3(0, 0, 0), vec3(2.0f, 2.0f, 2.0f)), // cone\n        transformMatrix(vec3(-5.4f, 2.0f, -10), vec3(0, 0, 0), vec3(1.0f, 1.0f, 2.0f)), // vents\n        transformMatrix(vec3(3.5f, -1.0f, 0), vec3(0, 0, 0), vec3(1.0f, 0.2f, 1.0f)), // lamp pole\n        transformMatrix(vec3(3.1f, -0.5f, 0), vec3(0, 0, 0), vec3(0.2f, 1.0f, 1.0f)), // lamp pole\n        transformMatrix(vec3(0.0f, -2.9f, 10.0f), vec3(0, 0, 0), vec3(1.0f)), // pawn sphere\n        transformMatrix(vec3(0.0f, -3.7f, 10.0f), vec3(0, 0, 0), vec3(1.0f, 1.0f, 1.0f)), // pawn cone\n        transformMatrix(vec3(0.0f, -4.6f, 10.0f), vec3(0, 0, 0), vec3(1.0f, 1.0f, 1.0f)), // pawn cylinder\n        transformMatrix(vec3(-4.4f, -2.3f, -15.0f), vec3(0, 0, 0), vec3(1.0f, 5.5f, 4.0f)), // door frame\n        transformMatrix(vec3(-5.3f, -2.3f, -15.0f), vec3(0, 0, 0), vec3(1.0f, 6.0f, 5.0f)), // door cutout\n        transformMatrix(vec3(5.3f, 4.0f, 15.0f), vec3(0, 0, 0), vec3(1.0f, 0.5f, 1.0f)) // Fire alarm\n    );\n    for (int i = 0; i < transforms.length(); i++) {\n        invTransforms[i] = inverse(transforms[i]);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 rayDirection = getRayDirection(toNDC(fragCoord));\n    cameraPosition.z += 10.0f * iTime;\n    float z = lightPosition.z + 10.0f * iTime;\n    lightPosition.z = z - mod(z, 60.0f);\n    setShapeTransforms(z);\n    \n    Intersection intersection = rayMarch(cameraPosition, rayDirection);\n    \n    lightPosition.z = intersection.point.z - mod(intersection.point.z - 30.0f, 60.0f) + 30.0f;\n    \n    vec3 lightVector = normalize(lightPosition - intersection.point);\n    float irradiance = min(clamp(dot(intersection.normal, lightVector), 0.0f, 1.0f) + ambientLight, 1.0f);\n    float ao = max(intersection.ao, computeAO(intersection.point, intersection.normal));\n    vec3 color = ao * max(mix(intersection.color, veryDarkPink / 255.0f, 1.0f - irradiance), intersection.lit * intersection.color);\n    float fog = clamp((intersection.t - 200.0f) / 200.0f, 0.0f, 1.0f);\n    float shadow = max(intersection.lit, clamp(softShadow(lightVector, intersection.point), 0.5f, 1.0f));\n    color = mix(shadow * color, darkPink / 255.0f, fog);\n    \n    float blur = min(1.0f, abs((intersection.t * 0.4f - focalLength) / focalRange));\n    blur = pow(blur, 2.0f);\n    \n    fragColor = vec4(vec3(min(color, 1.0f)), blur);\n    \n    if (intersection.t >= maxRayTravel - 10.0f) {\n        fragColor = vec4(intersection.color, 1.0f);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}