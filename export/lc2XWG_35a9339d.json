{"ver":"0.1","info":{"id":"lc2XWG","date":"1707139714","viewed":102,"name":"VertigoGlass","username":"xtr1984","description":"some vertigo tunnel\nsee also https://www.youtube.com/watch?v=xmu22Ih8aGE   tried to reproduce, well sometime)","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","cooktorrance"],"hasliked":0,"parentid":"XsXXDB","parentname":"Cook-Torrance"},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// based on https://www.shadertoy.com/view/XsXXDB\n////////////////////////////////////////\n// Classic raytracing\n// Cook-Torrance shading \n//\n\nstruct Material {\n\tvec3  color;\t\t// diffuse color\n\tbool reflection;\t// has reflection \n\tbool refraction;\t// has refraction\n\tfloat n;\t\t\t// refraction index\n\tfloat roughness;\t// Cook-Torrance roughness\n\tfloat fresnel;\t\t// Cook-Torrance fresnel reflectance\n\tfloat density;\t\t// Cook-Torrance color density i.e. fraction of diffuse reflection\n};\n\nstruct Light {\n\tvec3 pos;\n\tvec3 color;\n};\n\n//////////////////////////////////////\n/// Ray-Primitive intersections\n/// fast version test the existence of \n/// an intersection\n\nstruct Inter {\n\tvec3 p;\t\t//pos\n\tvec3 n; \t//normal\n\tvec3 vd;\t// viewdir\n\tfloat d;\t//distance\n\tbool inside; // inside object\n\tMaterial mat; // object material\n};\n\nvoid intSphere(vec3 ro, vec3 rd, vec3 p, float r, Material mat, inout Inter i)\n{\n\tfloat dist = -1.;\n\tvec3 v = ro-p;\n\tfloat b = dot(v,rd);\n\tfloat c = dot(v,v) - r*r;\n\tfloat d = b*b-c;\n\tif (d>0.)\n\t{\n\t\tfloat t1 = (-b-sqrt(d));\n\t\tfloat t2 = (-b+sqrt(d));\n\t\tif (t2>0.)\n\t\t{\n\t\t\tdist = t1>0.?t1:t2;\n\t\t\tif ((dist<i.d)||(i.d<0.))\n\t\t\t{\n\t\t\t\ti.p = ro+dist*rd;\n\t\t\t\ti.n = normalize(i.p-p);\n\t\t\t\ti.d = dist;\n\t\t\t\ti.vd = -rd;\n\t\t\t\ti.inside = t1<0.;\n\t\t\t\tif (i.inside)\n\t\t\t\t\ti.n *= -1.; //invert the normal when hitting inside during refraction\n\t\t\t\ti.mat = mat;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\n//////////////////////////////////////\n/// Shading functions\n\n\n/// References:\n/// http://content.gpwiki.org/index.php/D3DBook:%28Lighting%29_Cook-Torrance\n/// http://ruh.li/GraphicsCookTorrance.html\nvec3 shadeCookTorrance( Inter i, Light lig )\n{\n\tfloat roughness = i.mat.roughness;\n\tfloat F0 = i.mat.fresnel;\n\tfloat K = i.mat.density;\n\t//\n\tvec3 ld = normalize(lig.pos-i.p);\n\tvec3 h = normalize(i.vd+ld);\n\tfloat NdotL = clamp( dot( i.n, ld ),0.,1. );\n\tfloat NdotH = clamp( dot( i.n, h ),0.,1. );\n\tfloat NdotV = clamp( dot( i.n, i.vd ),0.,1. );\n\tfloat VdotH = clamp( dot( h, i.vd ),0.,1. );\n\tfloat rsq = roughness * roughness;\n\t\n\t// Geometric Attenuation\n\tfloat NH2   = 2. * NdotH / VdotH;\n\tfloat geo_b = (NH2 * NdotV );\n\tfloat geo_c = (NH2 * NdotL );\n\tfloat geo   = min( 1., min( geo_b, geo_c ) );\n\t\n\t// Roughness\n\t// Beckmann distribution function\n\tfloat r1 = 1. / ( 4. * rsq * pow(NdotH, 4.));\n\tfloat r2 = (NdotH * NdotH - 1.) / (rsq * NdotH * NdotH);\n\tfloat rough = r1 * exp(r2);\n\t\n\t// Fresnel\t\t\t\n\tfloat fres = pow( 1.0 - VdotH, 5. );\n\tfres *= ( 1.0 - F0 );\n\tfres += F0;\n\t\n\tvec3 spec = (NdotV * NdotL==0.) ? vec3(0.) : vec3 ( fres * geo * rough ) / ( NdotV * NdotL );\n\tvec3 res = NdotL * ( (1.-K)*spec + K*i.mat.color ) * lig.color;// * exp(-0.001*length(lig.pos-i.p));\n\treturn res;\n}\n\n////////////////////////////////////\n// Raytracing\n\n\n\nvec3 raytraceRay( vec3 ro, vec3 rd, inout Inter i)\n{\n\tMaterial mat;\n    vec3 hit,p;\n    float R = 15.0+12.0*sin(iTime/10.0);\n    \n    float d = sqrt(R*R/(1.0-rd.z*rd.z));\n    \n    if(d < 1500.0)\n\t{\n        hit  = d * rd + ro;\n        float f;\n        hit.z =   round(hit.z/15.)*15.0;\n        float f2 = 0.0;\n        if (mod (hit.z,2.0)==0.) f2 = iTime/3.0;\n        mat2 rot = mat2(cos(f2),sin(f2), -sin(f2),cos(f2));\n        vec3 rd2 = rd;\n        rd2.xy = rot*rd.xy;\n        if (rd2.x>0.)\n            f = atan(rd2.y/ rd2.x);\n        else {\n            f = atan(rd2.y/ rd2.x)+3.14;\n        }\n        float fd = 6.28/30.0;\n        f = round(f/fd)*fd;\n        hit.xy = R * vec2(cos(f),sin(f));\n        \n        mat.color = vec3(sin(iTime/30.),sin(iTime/20.),sin(iTime/10.));\n        mat.reflection = true;\n        mat.refraction = true;\n        mat.n = 1.33;\n        mat.fresnel = 0.8;\n        mat.roughness = .1;\n        mat.density = 0.5;\n        intSphere( ro, rd2, hit, 2.0, mat, i);\n\t\t\n\t}\n\n   \n    \n\t//\n\tmat.color = vec3(1.0,1.0,1.0);\n\tmat.reflection = true;\n\tmat.refraction = true;\n\tmat.n = 1.33;\n\tmat.fresnel = 0.8;\n\tmat.roughness = .1;\n\tmat.density = 0.5;\n\tp = vec3(0.,4.0,0.);\n\tintSphere( ro, rd, p, 1.5, mat, i);\n    i.n = -cross(i.n, texture(iChannel1,i.n.xy*0.1).xyz);\n\t//\n\tvec3 col = vec3(0.1,0.1,0.1);\n\tif (i.d>0.)\n\t{\n\t\t// ambiant\n\t\tfloat ambiant = 0.1;\n\t\tcol = ambiant*i.mat.color;\n\t\t\n\t\tif (!i.inside)\n\t\t{\n\t\t\t// lighting\n\t\t\tLight lig;\n\t\t\tlig.color = vec3(1.,1.,1.);\n\t\t\tlig.pos = vec3(0., 20., 0.);\n\t\t\t//if (hidden(i,lig.pos)<0.)\n\t\t\tcol += 0.5*shadeCookTorrance(i, lig);\n\t\t\tlig.pos = vec3(-4., 20., -4.);\n\t\t\t//if (hidden(i,lig.pos)<0.)\n\t\t\tcol += 0.5*shadeCookTorrance(i, lig);\n\t\t}\n\t}\n    else {\n        col = texture(iChannel0, rd).xyz*1.5;\n    }\n\treturn clamp(col,0.,1.);\n}\n\nvec3 raytrace( vec3 ro, vec3 rd)\n{\n\tInter i;\n\ti.p = vec3(0.,0.,0.);\n\ti.n = vec3(0.,0.,0.);\n\ti.d = -1.;\n\ti.vd = vec3(0.,0.,0.);\n\ti.inside = false;\n\t//\n\tvec3 accum = vec3(0.);\n\tvec3 col = vec3(0.);\n\tfloat refl = 1.;\n\tfloat refr = 1.;\n\tcol = raytraceRay(ro, rd, i);\n\taccum += col; // * exp(-0.0005*i.d*i.d);\n\tif (i.mat.reflection)\n\t{\n\t\tInter li = i;\n\t\tvec3 lro = ro;\n\t\tvec3 lrd = rd;\n\t\tlro = li.p;\n\t\tlrd = reflect(-li.vd,li.n);\n\t\tlro += 0.001*lrd;\n\t\tfor (int k=1; k<4; ++k)\n\t\t{\n\t\t\tli.d = -1.;\n\t\t\trefl *= 1.-i.mat.density;\n\t\t\t//\n\t\t\tcol = raytraceRay(lro, lrd, li);\n\t\t\t//\n\t\t\taccum += col * refl; // * exp(-0.005*i.d*i.d);\n\t\t\tif ((li.d<.0)||(!li.mat.reflection)) break;\n\t\t\tlro = li.p;\n\t\t\tlrd = reflect(-li.vd,li.n);\n\t\t\tlro += 0.0001*lrd;\n\t\t}\n\t}\n\tif (i.mat.refraction)\n\t{\n\t\tInter li = i;\n\t\tvec3 lro = ro;\n\t\tvec3 lrd = rd;\n\t\tfloat n = 1./li.mat.n;\n\t\tfloat cosI = -dot(li.n,li.vd);\n\t\tfloat cost2 = 1.-n*n*(1.-cosI*cosI);\n\t\tif (cost2>0.)\n\t\t{\n\t\t\tlro = li.p;\n\t\t\tlrd = normalize(-li.vd*n+li.n*(n*cosI - sqrt(cost2)));\n\t\t\tlro += 0.0001*lrd;\n\t\t\tfor (int k=1; k<4; ++k)\n\t\t\t{\n\t\t\t\tli.d = -1.;\n\t\t\t\trefr *= 1.-li.mat.density;\n\t\t\t\t//\n\t\t\t\tcol = raytraceRay(lro, lrd, li);\n\t\t\t\t//\n\t\t\t\taccum += col * refr; //* exp(-0.005*i.d*i.d);\n\t\t\t\tif ((li.d<.0)||(!li.mat.refraction)) break;\n\t\t\t\tif (li.inside)\n\t\t\t\t\tn = li.mat.n;\n\t\t\t\telse\n\t\t\t\t\tn = 1./li.mat.n;\n\t\t\t\tcosI = -dot(li.n,li.vd);\n\t\t\t\tcost2 = 1.-n*n*(1.-cosI*cosI);\n\t\t\t\tif (cost2<=0.) break;\n\t\t\t\tlro = li.p;\n\t\t\t\tlrd = normalize(-li.vd*n+li.n*(n*cosI - sqrt(cost2)));\n\t\t\t\tlro += 0.0001*lrd;\n\t\t\t}\n\t\t}\n\t}\n\treturn clamp(accum,0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\t\t \n\tfloat Time = 0.45*(15.0 + iTime);\n    \n\tvec3 ro = vec3( 0.0, 0.0,  iTime*10.0);\n    vec3 ta = vec3( 0.0, 0, 10000.0 );\n\n    // camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( cos(iTime/10.), sin(iTime/10.) , 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n    vec3 col = raytrace( ro, rd );\n\t\n\tfragColor=vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}