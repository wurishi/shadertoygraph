{"ver":"0.1","info":{"id":"DltfzB","date":"1701366051","viewed":42,"name":"lense in cosmos","username":"nayk","description":"stars, cosmos, lense","likes":0,"published":1,"flags":1,"usePreview":0,"tags":["stars","cosmos","lense"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000\n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\nfloat cheap_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n//get coords and direction\nvec3 dir=rd;\nvec3 from=ro;\n\n//volumetric rendering\nfloat s=0.1,fade=1.;\nvec3 v=vec3(0.);\nfor (int r=0; r<volsteps; r++) {\nvec3 p=from+s*dir*.5;\np = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\nfloat pa,a=pa=0.;\nfor (int i=0; i<iterations; i++) {\np=abs(p)/dot(p,p)-formuparam;\n            p.xy*=mat2(cos(iTime*0.01),sin(iTime*0.01),-sin(iTime*0.01),cos(iTime*0.01));// the magic formula\na+=abs(length(p)-pa); // absolute sum of average change\npa=length(p);\n}\n\na*=a*a; // add contrast\nif (r>6) fade*=1.2; // dark matter, don't render near\n//v+=vec3(dm,dm*.5,0.);\nv+=fade;\nv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\nfade*=distfading; // distance fading\ns+=stepsize;\n}\nv=mix(vec3(length(v)),v,saturation); //color adjust\nfragColor = vec4(v*.02,1.);\n}\nvoid lense(in vec2 lensPosition, in float rad, in vec2 fragCoord, inout vec2 distortion)\n{\n    vec2 totalCenterDir = lensPosition - fragCoord;\n    vec2 lensCenterDirection = normalize(totalCenterDir);\n    float dist = distance(lensPosition, fragCoord);\n   \n    float radius = iResolution.x / 5.0;\n   \n    float power = (max(radius - dist, 0.0)) / radius;\n   \n    if(power > 0.0)\n    {\n        float depth = 0.95 - power;\n        power = pow(depth, 2.0) * 0.80;\n       \n        distortion += lensCenterDirection * power;\n    }\n}\n/* original https://www.shadertoy.com/view/lsyXDK https://www.shadertoy.com/view/lslyRn https://www.shadertoy.com/view/DlycWR*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//get coords and direction\nvec2 uv=fragCoord.xy/iResolution.xy-.5;\n    vec2 uv2=fragCoord.xy/iResolution.xy-.5;\n    //get coords and direction\nvec2 uv3=fragCoord.xy/iResolution.xy-.5;\nuv.y*=iResolution.y/iResolution.x;\nuv2.y*=iResolution.y/iResolution.x;\nvec3 dir=vec3(uv*zoom,1.);\nfloat time=iTime*speed+.25;\n vec2 distorted = vec2(0.0);\n     // anim between 0.9 - 1.1\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;\n   \n     vec3 c23 = cheap_star(uv,anim) * vec3(0.55,0.5,0.55)*0.3;\n     uv.x-=cos(iTime)*0.35;\n      uv.y-=sin(iTime)*0.35;\n        \n        \n        uv2.x-=sin(iTime)*0.35;\n      uv2.y-=cos(iTime)*0.3;\n    lense(\n        vec2(cos(iTime) / 2.0 + 0.5, sin(iTime) / 2.0 + 0.5) * iResolution.xy,\n        iResolution.x,\n        fragCoord,\n        distorted);\n   \n   \n    lense(\n        vec2(sin(iTime) / 2.0 + 0.5, cos(iTime) / 2.0 + 0.5) * iResolution.xy,\n        iResolution.x / 5.0,\n        fragCoord,\n        distorted);\n\nvec3 from=vec3(1.,.5,0.5);\n   \nfrom+=vec3(time*2.,time,-2.);\n\n\n   \n     \n\nfrom.xy*=distorted;\nmainVR(fragColor, fragCoord, from, dir);\n    fragColor*= vec4(cheap_star(uv,anim) * vec3(0.55,0.5,0.55)*0.3, 1.0);\n     fragColor*= vec4(cheap_star(uv2,anim) * vec3(0.55,0.5,0.55)*0.3, 1.0);\n        fragColor*= vec4(cheap_star(uv3,anim) * vec3(0.55,0.5,0.55)*0.3, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}