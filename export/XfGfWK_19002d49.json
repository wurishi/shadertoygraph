{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// Quick way to toggle blur using the preprocessor. Just set to 0 to disable or anything else to enable.\n#define BLURRED 1\n// Define how large the kernel is. This serves as a base for other implementations.\n// Don't set this to 0! Odd values work best.\n#define KERNEL_WIDTH 11\n\nvec4 processKernel(vec2 uv, float[KERNEL_WIDTH * KERNEL_WIDTH] kernel)\n{\n    // Calculate step size to sample adjacent pixels\n    float step = 1.0;\n    float stepX = step / iResolution.x;\n    float stepY = step / iResolution.y;\n    \n    // Initialize result color for current pixel\n    vec4 result = vec4(0);\n    \n    // Accumulate the final pixel color sample by sample\n    for(int y = 0; y < KERNEL_WIDTH; y++)\n    {\n        for(int x = 0; x < KERNEL_WIDTH; x++)\n        {\n            // Calculate sample offset for both X and Y coordinates.\n            vec2 sampleOffset = vec2(0);\n            sampleOffset.x = stepX * (-floor(float(KERNEL_WIDTH / 2)) + float(x));\n            sampleOffset.y = stepY * (floor(float(KERNEL_WIDTH / 2)) - float(y));\n            vec4 currentSample = texture(iChannel0, uv + sampleOffset);\n            \n            // Traverse the kernel from bottom right to top left, flipping it.\n            // Flipping the kernel is part of the convolution operation.\n            int kernelIndex = (KERNEL_WIDTH * KERNEL_WIDTH - 1) - (KERNEL_WIDTH * y + x);\n            result += kernel[kernelIndex] * currentSample;\n        }\n    }\n    \n    return result;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Initialize a simple kernel for a uniform blur\n    float[KERNEL_WIDTH * KERNEL_WIDTH] kernel;\n    for(int i = 0; i < KERNEL_WIDTH * KERNEL_WIDTH; i++)\n    {\n        kernel[i] = 1.0 / float(KERNEL_WIDTH * KERNEL_WIDTH);\n    }\n\n    // Output the desired result to screen\n    #if BLURRED != 0\n    fragColor = processKernel(uv, kernel);\n    #else\n    fragColor = texture(iChannel0, uv);\n    #endif\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XfGfWK","date":"1734914251","viewed":51,"name":"Learning: Simple Box Blur","username":"TheCreator","description":"A simple box blur effect to teach myself about convolution and in preparation for implementing a Gaussian blur!","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d","blur","learning","box"],"hasliked":0,"parentid":"","parentname":""}}