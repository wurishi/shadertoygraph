{"ver":"0.1","info":{"id":"ltScz3","date":"1509924012","viewed":724,"name":"Cell diffusion simulation","username":"dust","description":"A bit of DLA, a bit of cellular automata. R to swap between 3D and 2D views, drag the circle around in 2D view to modify cell activations. Arrows to rotate the sphere, Q/E to zoom.","likes":8,"published":1,"flags":48,"usePreview":0,"tags":["procedural","3d","raymarching","fractal","ca","dla","cellularautomata","diffuselimitedaggregation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define EPS 0.0001\n#define ATMOS_DENSITY 7.5\n#define SPHERE_RADIUS 1.0\n\n// Choose a projection (0 for stereographic, 1 for orthographic)\n// Stereographic projection produces detailed pixel data near the north \n// pole but degenerates into mud in the southern hemisphere; hemispheric \n// planar projection preserves area without most artifacts, but produces \n// less interesting imagery in the northern hemisphere, hides information\n// outside the projective radii (0.25 for each hemisphere; hemispheres are\n// projected either side of the central y-axis), and becomes very muddy\n// near the +z/-z border\n#define PROJ_TYPE 0\n\n// Orthographic map degenerates near the meridian (since single (x,y) coords\n// correspond to larger areas on the sphere); use these to obscure that by \n// hiding cells at the edges of each hemisphere\n#define CLEAN_ORTHO\n#define CLEAN_ORTHO_THRESH 0.95\n#define CLEAN_ORTHO_GRAD 10.0\n\nvec4 Map(vec3 coord)\n{\n    // Lock sphere to the origin\n    // Also displace surface for active cells\n    float dist = length(coord) - SPHERE_RADIUS;\n    \n    // Define color variable\n    vec3 rgb = vec3(0.0, 0.0, 0.0);\n    \n    // Consider per-ray cylinder extension at random angles; should\n    // produce pretty noise-driven latticework\n    \n    // Project sphere surface onto the plane\n    float A = 4.0 * 3.14159 * (SPHERE_RADIUS * SPHERE_RADIUS);\n    #if PROJ_TYPE == 0\n    // Uses a modified stereographic projection: \n    // https://wikipedia.org/Stereographic_projection\n    vec2 uv = vec2(coord.x / (SPHERE_RADIUS - coord.y), // Change axes here for cool image effects\n                   coord.z / (SPHERE_RADIUS - coord.y)) / A;    \n    \n    // Align projection to the center of buffer-A\n    uv += vec2(0.5, 0.5);\n    \n    #else\n    // Uses orthographic projection through (x, y)\n    // Simple translation is used to map the close hemisphere (-z)\n    // onto a second circle adjacent to the circle mapped for the\n    // far hemisphere (+z)\n    vec2 uv = vec2((coord.x / SPHERE_RADIUS) / 4.0, \n                   (coord.y / SPHERE_RADIUS) / 4.0);\n    if (coord.z < 0.0)\n    {\n     \tuv.x += 0.5;   \n    }\n    \n    // Align projection to the left half of buffer-A\n    uv += vec2(0.25, 0.5);\n\n    #endif\n        \n    // Cache cell status for the given texture coordinates\n    rgb = textureLod(iChannel0, uv, 0.0).xyz;\n    \n    #if PROJ_TYPE == 1\n    #ifdef CLEAN_ORTHO\n    float circDist = length(vec2(coord.x / SPHERE_RADIUS, \n                    \t\t\t coord.y / SPHERE_RADIUS));\n    float thresh = CLEAN_ORTHO_THRESH;\n    vec3 baseRGB = rgb;\n    rgb *= mix(rgb, rgb * 0.0, (circDist - thresh) / (1.0 - thresh)) / CLEAN_ORTHO_GRAD;\n    rgb = min(rgb, baseRGB);\n    #endif\n    #endif\n    \n    // Return a scaled distance + a color\n    return vec4(dist, rgb);\n}\n\nvec3 RayDir(float fovRads, vec2 viewSizes, vec2 pixID)\n{\n    vec2 xy = pixID - (viewSizes / 2.0);\n    float z = viewSizes.y / tan(fovRads / 2.0);\n    return normalize(vec3(xy, z));\n}\n\n// Computes the inverse of a given quaternion\nvec4 QtnInverse(vec4 qtn)\n{\n    return vec4(qtn.xyz * -1.0, qtn.w);\n}\n\n// Compute the product of two quaternions\nvec4 QtnProduct(vec4 qtnA, vec4 qtnB)\n{\n    vec3 vecA = qtnA.w * qtnB.xyz;\n    vec3 vecB = qtnB.w * qtnA.xyz;\n    vec3 orthoVec = cross(qtnA.xyz, qtnB.xyz);\n\n    return vec4(vecA + vecB + orthoVec,\n                 (qtnA.w * qtnB.w) - dot(qtnA.xyz, qtnB.xyz));\n}\n\n// Perform rotation by applying the given quaternion to\n// the given vector\nvec3 QtnRotate(vec3 vec, vec4 qtn)\n{\n    vec4 qv = QtnProduct(qtn, vec4(vec, 0.0));\n    return QtnProduct(qv, QtnInverse(qtn)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float currRayDist = 0.0;\n\tvec3 rayDir = RayDir(3.14 / 2.0, iResolution.xy, fragCoord);\n    vec3 rayRGB = vec3(0.0, 0.0, 0.0);\n    vec4 inputs = texture(iChannel1, fragCoord / iResolution.xy);\n    float xSpin = inputs.x;\n    float ySpin = inputs.y;\n    vec3 unitX = vec3(1, 0, 0);\n    vec3 unitY = vec3(0, 1, 0);\n    if (inputs.z < 1.0)\n    {\n        // Ray-march a spherical surface projection of the generated cells\n        // (3D view)\n    \twhile (currRayDist < 10.0)\n    \t{\n        \t// Define eye position + ray vector\n        \tvec3 eyePos = vec3(0.0, 0.0, -3.0);\n    \t\tvec3 rayVec = eyePos + (rayDir * currRayDist) + \n            \t\t  \t  (vec3(0, 0, 1.0) * inputs.w);\n                       \n        \trayVec = QtnRotate(rayVec, vec4(unitX * sin(inputs.x), cos(inputs.x)));\n        \trayVec = QtnRotate(rayVec, vec4(unitY * sin(inputs.y), cos(inputs.y)));\n                           \n        \t// Accumulate atmospheric color\n        \trayRGB += vec3(0.001125, 0.00125, 0.0015) * ATMOS_DENSITY;\n        \n        \t// March against distance field\n        \tvec4 field = Map(rayVec);\n        \tif (field.x < EPS)\n        \t{   \n    \t\t\trayRGB += field.yzw / sqrt(currRayDist + EPS);\n            \tfragColor = vec4(rayRGB, 1.0);\n            \treturn;\n       \t\t}\n        \n        \tcurrRayDist += abs(field.x);\n   \t\t}\n        \n        // Draw the accumulated color to the screen\n        fragColor = vec4(rayRGB, 1.0);\n    }\n    \n    else\n    {\n        // Draw the generated cells directly onto the plane (2D view)\n        fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// Simulation controls\n\n#define CLEAR_RADIUS 40.0 // Set to [0.0] to hide the eraser\n#define HIDE_BRUSH_IN_3D\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // Evaluate whether the current pixel is stuck to any other pixels\n    // i.e whether any neighbours of the current pixel are nonzero\n    vec2 uv = fragCoord / iResolution.xy;    \n\tfloat stepX = 1.0 / iChannelResolution[0].x;\n\tfloat stepY = 1.0 / iChannelResolution[0].y;\n    vec2 leftVec = uv - vec2(stepX, 0.0);\n    vec2 rightVec = uv + vec2(stepX, 0.0);\n    vec2 upVec = uv - vec2(0.0, stepY);\n    vec2 downVec = uv + vec2(0.0, stepY);\n    bool stuck = texture(iChannel0, leftVec).x > 0.0 ||\n            \t texture(iChannel0, rightVec).x > 0.0 ||\n            \t texture(iChannel0, upVec).x > 0.0 ||\n            \t texture(iChannel0, downVec).x > 0.0;\n    \n    // Evaluate whether the current pixel is in the centre of the display\n    bool centrePx = uv.x < (0.5 + stepX) && uv.x > (0.5 - stepX) &&\n        \t\t\tuv.y < (0.5 + stepY) && uv.y > (0.5 - stepY);\n    \n    // Analytical diffusion variance is hard, so lets source ours from audio\n    // instead :)\n    int sonoNdx = int(uv.x * 512.0); // Sound textures are 512 pixels wide\n    float wav = texelFetch(iChannel2, ivec2(sonoNdx, 1), 0).x;\n\n    // Source noise from a kernel applied over the noise texture rather\n    // than a single-pixel local sample\n    // Mix in audio samples for greater variance\n    vec2 uvN = fragCoord / iChannelResolution[1].xy;\n    float stepXN = 1.0 / iChannelResolution[0].x;\n    float stepYN = 1.0 / iChannelResolution[0].y;\n    vec2 leftVecN = uvN - vec2(stepXN, 0.0);\n    vec2 rightVecN = uvN + vec2(stepXN, 0.0);\n    vec2 upVecN = uvN - vec2(0.0, stepYN);\n    vec2 downVecN = uvN + vec2(0.0, stepYN);\n    float nearPotency = (texture(iChannel1, leftVecN).x + wav) *\n            \t \t    (texture(iChannel1, rightVecN).x / wav) +\n            \t \t    (pow(texture(iChannel1, upVecN).x, wav)) /\n            \t \t    (texture(iChannel1, downVecN).x - wav);\n        \n    // Attract cell activation against the output of a magic diffusion function\n    // Maybe this is some sort of PDE, idk; it's just a random\n    // combination I thought up that works nicely for this context :)\n    if ((texture(iChannel1, uvN).x > sin(log(pow(iTime, wav)) * log(nearPotency))) &&\n        (centrePx || stuck))\n    {\n    \tfragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    }\n    \t\n    else\n    {\n    \tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    \n    // Cells are de-activated within the given radius of the mouse position\n    // Set CLEAR_RADIUS to [0] to prevent de-activation\n    vec4 inputs = texture(iChannel3, uv);\n    #ifdef HIDE_BRUSH_IN_3D\n    if (inputs.z > 0.0)\n    {\n    #endif\n    \tfloat relLength = length(fragCoord.xy - iMouse.xy);\n    \tif (relLength < CLEAR_RADIUS)\n    \t{\n    \t\tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \t}\n    #ifdef HIDE_BRUSH_IN_3D\n    }\n    #endif\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n// Keyboard input\n\n// WASD macros\n#define UP_KEY float(0x26)\n#define LEFT_KEY float(0x25)\n#define RIGHT_KEY float(0x27)\n#define DOWN_KEY float(0x28)\n\n// R, Q, E macros\n#define R_KEY float(0x52)\n#define Q_KEY float(0x51)\n#define E_KEY float(0x45)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Initialise input values\n    float xSpin = 0.0;\n    float ySpin = 0.0;\n    float view = 0.0;\n    float zoom = 0.0;\n    if (iFrame > 0)\n    {\n\t\t// Update spin about x\n        xSpin = texture(iChannel1, fragCoord / iResolution.xy).x;\n    \txSpin += (texture(iChannel0, vec2((UP_KEY + 0.5) / 256.0, 0.25)).x * iTimeDelta);        \n        xSpin -= (texture(iChannel0, vec2((DOWN_KEY + 0.5) / 256.0, 0.25)).x * iTimeDelta);\n        \n        // Update spin about y\n    \tySpin = texture(iChannel1, fragCoord / iResolution.xy).y;\n        ySpin += texture(iChannel0, vec2((LEFT_KEY + 0.5) / 256.0, 0.25)).x * iTimeDelta;\n        ySpin -= texture(iChannel0, vec2((RIGHT_KEY + 0.5) / 256.0, 0.25)).x * iTimeDelta;        \n        \n        // Update view selection\n        // Views are toggled, not persisted\n        view = texture(iChannel0, vec2((R_KEY + 0.5) / 256.0, 0.75)).x;\n        \n        // Update zoom selection\n        zoom = texture(iChannel1, fragCoord / iResolution.xy).w;\n        zoom += texture(iChannel0, vec2((Q_KEY + 0.5) / 256.0, 0.25)).x * iTimeDelta;\n        zoom -= texture(iChannel0, vec2((E_KEY + 0.5) / 256.0, 0.25)).x * iTimeDelta;\n    }\n    \n    fragColor = vec4(xSpin, ySpin, \n                     view, zoom);\n}","name":"Buffer B","description":"","type":"buffer"}]}