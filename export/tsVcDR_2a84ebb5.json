{"ver":"0.1","info":{"id":"tsVcDR","date":"1602624396","viewed":52,"name":"GenerOETive","username":"Kaeylos","description":"#3 Vasarely\nmade during the Ink-MAC-tober 2020\na generative representation of \"OET - OET.\" 1955 by Victor Vasarely","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["vasarely","imac"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// inspired by : https://www.shadertoy.com/view/4dfSDj\n// source: https://www.shadertoy.com/view/ttc3zr\nuint murmurHash11(uint src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\nfloat hash11(float src) { return uintBitsToFloat(murmurHash11(floatBitsToUint(src)) & 0x007fffffu | 0x3f800000u) - 1.0; }\n\nuint murmurHash12(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\nfloat hash12(vec2 src) { return uintBitsToFloat(murmurHash12(floatBitsToUint(src)) & 0x007fffffu | 0x3f800000u) - 1.0; }\n\nuvec2 murmurHash21(uint src) {\n    const uint M = 0x5bd1e995u;\n    uvec2 h = uvec2(1190494759u, 2147483647u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\nvec2 hash21(float src) { return uintBitsToFloat(murmurHash21(floatBitsToUint(src)) & 0x007fffffu | 0x3f800000u) - 1.0; }\n\n#define rot2(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat band (vec2 id, float threshold) {\n    return step(hash12(id), threshold);\n}\n\nfloat randomLines(vec2 uv, float seed) {\n\t// dilated uv on y axis\n    vec2 duv = uv;\n    duv.x *= 0.8*(1.+.5*(1.+mod(iTime/20., 0.3)*cos(iTime/10.*seed)));\n    duv.y *= 0.02*(1.+mod(floor(iTime*0.1), seed+.1)/(seed+.1)); \n    return max(band(floor(duv*100.), .25), band(floor((duv +0.01*mod(iTime/10., seed+.1)/(seed+.1)*cos(iTime/2.) )*80.), .25));\n}\n\nfloat rottingSquareMask(vec2 uv, float seed, float radius) {\n// rotating squares\n    float a = clamp(cos((iTime/1.) * (.5 + 0.1*hash11(seed))), -.1, .1) / .1 + clamp(cos(seed + (iTime/2.) * .6), -.15, .15) / .12;\n    vec2 center = vec2(cos(seed + mod(iTime/12., hash11(seed))/0.5), sin(mod(iTime/10., hash11(seed))/hash11(seed))) /2.0;\n    vec2 suv = uv * rot2(a) + center;\n    return step(abs(suv.x) + abs(suv.y), radius);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy)  / iResolution.y;\n    vec2 Ouv = uv; // keep original UV\n    // adding noise to uv to generate motion\n    float uvNoise = 0.05*((1.+cos(iTime))/20. + mod(iTime/10., 0.2)*cos(1.*iTime)*0.4);\n    uv += uvNoise;\n    \n    float color = 1.; // color in b&w \n    \n    // basic bg lines\n    color *= randomLines(uv, 1.);\n    \n    // horizontal band\n    float hm = step(0.3, abs(uv.y));\n    color = mix(color, randomLines(uv, 2.), hm);\n    \n    //  cubes \n    for(float i; i < 8.; ++i) {\n    \tfloat cubemask = rottingSquareMask(uv, i*10., 0.45 + 0.3*hash11(i*10.0));\n    \t//color *= cubemask;\n    \tcolor = mix(color, randomLines(uv, i), cubemask);\n    }\n\t\t\n\t// horizontal band\n\thm = step(0.3, abs(uv.y + mod(iTime/10., 0.2)*cos(1.*iTime)*0.5));\n    color = mix(color, randomLines(uv, 5.), hm);\n        \n    // periodic inversion\n    color = mix(color, (1.-color), step(.08, iTime / 60.) * round(cos(iTime) *.5+.5));\n    \n    // white border\n    vec2 w = step(abs(Ouv), vec2(.42));\n    float borderMask = w.x*w.y;\n    color = mix(1., color, borderMask);\n    \n    // square mask\n    vec2 s = step(abs(Ouv), vec2(.45));\n    float squareMask = s.x*s.y;\n    \n    vec3 yColor = vec3(1., 1., 0.95); // yellowish background color\n    vec3 finalColor = mix(vec3(.92), yColor * color, squareMask);\n    \n\t\n    fragColor = vec4(finalColor, 1);\n}","name":"Image","description":"","type":"image"}]}