{"ver":"0.1","info":{"id":"MtKSRt","date":"1485476668","viewed":192,"name":"Reveal","username":"joshbrandl","description":"A blurred image gets either sharpened or edge detected in a circle around the mouse!  Circle size is parametric as well is type of kernel being applied to the circle.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["blur","edgedetection","sharpen","reveal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//Sharpen or edge detection?\nbool sharpenSwitch = true; //false for edge detection\n\n//Circle\nfloat circRad = 0.1;//Change this to change size of circle\nvec2 circPos = vec2(0.9,0.5);//Default pos\n\n//Layers\nvec4 Layer1;\nvec4 Layer2;\n\n// Originally by Nikos Papadopoulos, 4rknova / 2015\n// Heavily modified by Dr. Sajid Farooq, 2016\n//The blur matrix. Since there are 9 pixels, each weight is 1/9 = 0.111 \n// to ensure that each pixel is averaged properly\nmat3 blur = mat3(\n 0.111, 0.111, 0.111, // first column (not row!)\n 0.111, 0.111, 0.111, // second column\n 0.111, 0.111, 0.111 // third column\n);\n\nmat3 sharpen = mat3(\n 0., -1, 0.0, // first column (not row!)\n -1, 5, -1, // second column\n 0., -1, 0.0 // third column\n);\n\nmat3 edgeDetection = mat3(\n -1, -1, -1, // first column (not row!)\n -1, 8, -1, // second column\n -1, -1, -1 // third column\n);\n\nvec3 sample(const int x, const int y, in vec2 fragCoord)\n{\n vec2 uv = fragCoord.xy / iResolution.xy * iChannelResolution[0].xy;\n uv = (uv + vec2(x, y)) / iChannelResolution[0].xy ;\n return texture(iChannel0, uv).xyz;\n}\nvec3 filter(in vec2 fragCoord, mat3 kernel)\n{\n vec3 sum = sample(-1, -1, fragCoord) * kernel[0][0]\n + sample(-1, 0, fragCoord) * kernel[0][1]\n + sample(-1, 1, fragCoord) * kernel[0][2]\n + sample( 0, -1, fragCoord) * kernel[1][0]\n + sample( 0, 0, fragCoord) * kernel[1][1]\n + sample( 0, 1, fragCoord) * kernel[1][2]\n + sample( 1, -1, fragCoord) * kernel[2][0]\n + sample( 1, 0, fragCoord) * kernel[2][1]\n + sample( 1, 1, fragCoord) * kernel[2][2];\n \n return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n \tvec2 uv = fragCoord.xy / iResolution.xy;\n \tvec4 ogColor = texture(iChannel0, uv);\n    vec4 manColor = texture(iChannel3, uv);\n\tmanColor = vec4(manColor.r, manColor.b, 0, manColor.a);\n \tvec2 fc = fragCoord.xy;\n \t\n \t//vec3 cf = filter(fc, blur);\n \tvec3 sharp = filter(fc, sharpen);\n \tvec3 blur = filter(fc, blur);\n    vec3 edge = filter(fc, edgeDetection);\n    \n    //Are we sharpening or edge detecting?\n    if(sharpenSwitch)\n    {\n\t\tLayer1 = vec4(sharp, 1.0);\n    }\n    else\n    {\n\t\tLayer1 = vec4(edge, 1.0);\n    }\n    \n    //Layer 2 is always going to be blurred\n    Layer2 = vec4(blur,1.0);\n    \n    //Circle logic + resolution scale correction\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    uv.x *= (iResolution.x / iResolution.y);\n    mouse.x *= (iResolution.x / iResolution.y);\n    \n    if(length(uv - mouse) <= circRad)\n    {\n\t\tLayer2.a = 0.0;\n    }\n    \n    //Layer Blending\n    vec4 Composite = mix(Layer1, Layer2, Layer2.a);\n    \n    //Final\n \tfragColor = Composite;\n}","name":"Image","description":"","type":"image"}]}