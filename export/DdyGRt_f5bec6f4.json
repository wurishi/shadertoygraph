{"ver":"0.1","info":{"id":"DdyGRt","date":"1678936291","viewed":342,"name":"Cry me a river","username":"ianertson","description":"Use the mouse to look around :)\nYou can also press the \"v\" key on your keyboard to toggle WASD camera. (You may need to press it multiple times).\nWhen activated, use WASD to move, shift to fly down and space to fly up.","likes":11,"published":1,"flags":48,"usePreview":1,"tags":["3d","raymarching","raymarch","sdf","refraction","water","materials","textures","river"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 boxBlur(vec2 uv, in float f) {\n  vec3 col = vec3(0.0);\n  const int filterSize = 8;\n  const int halfFilterSize = filterSize / 2;\n\n  const int start = -halfFilterSize;\n  const int end = -halfFilterSize + filterSize;\n\n  float shadow = 0.0;\n  vec2 texelSize = clamp(1.0+f, 1.0, 2.5) / vec2(textureSize(iChannel0, 0).xy);\n  int count = 0;\n  for(int x = start; x < end; ++x)\n  {\n      for(int y = start; y <= end; ++y)\n      {\n         vec3 next = texture(iChannel0, uv + (vec2(x, y) * texelSize)).rgb;\n         col += next;\n         count += 1;\n      }\n  }\n\n  col /= float(count);\n  return col;\n}\n\nvec3 shade(in vec2 uv) {\n    vec4 rgba = texture(iChannel0, uv).rgba;\n    vec3 col = rgba.rgb;\n    float depth = rgba.a;\n    \n    vec3 blurred = boxBlur(uv, depth*2.);\n    \n    return mix(col, blurred, depth);\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = fc/R.xy;\n    \n    col = shade(uv);\n    \n    O = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R (iResolution.xy)\n#define T (iTime)\n#define M_PI (3.14159265359)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n#define SAMPLE(var, id_) if (id_ != skip && var < dist) { id = id_; dist = var; }\n\n#define AMBIENT 0.05\n\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\nmat2 rot(in float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\nstruct Material { float rough; float spec; float metallic; float lum; float z;};\n#define NEW_MATERIAL Material(1.0, 1.0, 0.0, 0.0, 0.0)\n\nMaterial materialMix(in Material a, in Material b, in float f) {\n    Material next = NEW_MATERIAL;\n    next.rough = mix(a.rough, b.rough, f);\n    next.spec = mix(a.spec, b.spec, f);\n    next.metallic = mix(a.metallic, b.metallic, f);\n    next.lum = mix(a.lum, b.lum, f);\n    next.z = mix(a.z, b.z, f);\n    return next;\n}\n\nstruct Data {\n    vec3 p;\n    vec3 n;\n    float d;\n    int id;\n    int skip;\n    bool skipWater;\n    float far;\n    int steps;\n    Material m;\n};\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), FAR, 0, 0, true, FAR, STEPS, NEW_MATERIAL)\n\nstruct Light { vec3 p; vec3 d; vec3 c; float s; int type; };\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\n\nvec3 getLightDir(in Light light, in vec3 p) {\n    return light.type == LIGHT_AMBIENT ? normalize(light.p) :\n           light.type == LIGHT_POINT ? normalize(light.p - p) :\n           normalize(light.d);\n}\n\nvec3 getLightAtt(in Light light, in vec3 p, in vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = max(AMBIENT, dot(n, L));\n    switch (light.type) {\n        case LIGHT_AMBIENT: return light.c * light.s * NdotL; break;\n        case LIGHT_POINT: return light.c * NdotL * (pow(light.s, 2.0) /\n            max(0.0001, pow(distance(light.p, p), 2.0))); break;\n        case LIGHT_DIR: return light.c * light.s * NdotL * smoothstep(0.8, 1.0, dot(\n            normalize(light.p - p),\n            L\n        )); break;\n    }\n    return vec3(0.0);\n}\n\nvec2 boxUv(in vec3 p, in vec3 n) {\n    return mix(mix(p.xy, p.zy, round(adot(n, vec3(1, 0, 0)))), p.xz, round(adot(n, vec3(0, 1, 0))));\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n    return smin(a, b, -k);\n}\n\nvec3 smin(vec3 a, vec3 b, float k) {\n    vec3 h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nvec3 smax(vec3 a, vec3 b, float k) {\n    return smin(a, b, -k);\n}\n\nfloat sabs(in float v, in float k) {\n    return smax(-v, v, k);\n}\n\nvec3 mix4(vec3 c1, vec3 c2, vec3 c3, vec3 c4, vec3 m) {\n    return mix(mix(mix(c1, c2, m.x), c3, m.y), c4, m.z);\n}\n\nvec3 aces(vec3 x) {\n    return x*(2.51*x + .03) / (x*(2.43*x + .59) + .14);\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) *\n                  pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\n\nfloat sfract(in float x) {\n    return min(fract(x)/(1.0-fwidth(x)), fract(-(x))/fwidth(x));\n}\n\n\n// smooth mod\nfloat smod(in float x, in float n) {\n     float k = mod(x, n);\n     float ks = min(fract(x/n)/(1.-(0.5)), fract(-x/n)/(0.5)) * n;     \n     return mix(k, ks, smoothstep(0.0, 1.0, pow(k/n, 2.)));\n}\n\nvec3 makeNormal(in vec3 wn, in float z, in float mx, in float s) {\n    if (abs(z) <= 0.000000001) return wn;\n    vec2 dx = vec2(dFdx(z), 0.0);\n    vec2 dy = vec2(0.0, dFdy(z));\n    float bumpScale = s;\n    vec3 cp = cross(vec3(dx, bumpScale), vec3(dy, bumpScale));\n    if (length(cp) <= 0.0001) return wn;\n    cp = normalize(cp);   \n    return normalize(mix(wn, normalize(wn+cp), mx));\n}\n\nuint hash21u(in vec2 ip, in float seed) {\n    uvec2 p = uvec2(floatBitsToUint(ip.x), floatBitsToUint(ip.y));\n    uint s = floatBitsToUint(seed);\n    s ^= ~s >> 3U;\n    p ^= (p << 17U);\n    s ^= (~p.x);\n    s ^= (~p.y);\n    p ^= (p >> 11U);\n    p ^= (p << 5U);\n    p ^= (s << 3U);\n    return ((p.x + p.y) ^ (p.x * s + p.y))*293U;\n}\n\nfloat hash21(in vec2 ip, in float seed) { return float(hash21u(ip, seed)) / float(0xFFFFFFFFU); }\n\nvec3 hash23(in vec2 ip, in float seed) {\n    uint n = hash21u(ip, seed);\n    n ^= (n >> 13U);\n    return vec3(float((n >> 16U) & 0xFFU), float((n >> 8U) & 0xFFU), float(n & 0xFFU)) / float(0xFFU);\n}\n\nfloat voronoi(in vec2 p, in float seed){\n    vec2 Pi = floor(p);\n    vec2 Pf = fract(p);\n\n    float dmin = 1e20;\n    vec2 res = vec2(0.0);\n    \n    for(int j=-1; j<=1; j++){\n        for(int i=-1; i<=1; i++){\n            vec2 lattice = vec2(float(i),float(j));\n            vec2 offset = vec2(hash21(Pi+lattice, 0.9231234), hash21(Pi+lattice, 78.38381));\n            vec2 diff = lattice + offset - Pf;\n            \n            float dist = dot(diff,diff);\n            \n            if(dist<dmin){\n                dmin = dist;\n                res = lattice + offset;\n            }\n        }\n    }\n    \n    return clamp(sqrt(dmin), 0.0, 1.0);\n}\n\nfloat voronoiID(in vec2 p, in float seed, out vec2 id){\n    vec2 Pi = floor(p);\n    vec2 Pf = fract(p);\n    \n    float dmin = 1e20;\n    vec2 res = vec2(0.0);\n    float r = 1.0;\n    \n    for(int j=-1; j<=1; j++){\n        for(int i=-1; i<=1; i++){\n            vec2 lattice = vec2(float(i),float(j));\n            vec2 offset = vec2(hash21(Pi+lattice, 0.9231234), hash21(Pi+lattice, 78.38381));\n            vec2 diff = lattice + offset - Pf;\n            \n            float dist = dot(diff,diff);\n            r = min(r, dist/0.56);\n            if(r<dmin){\n                id = offset;\n                dmin = r;\n                res = lattice + offset;\n            }\n        }\n    }\n\n    return clamp(sqrt(dmin), 0.0, 1.0);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// taken from https://www.shadertoy.com/view/ldGGzV\n\n#define MOVE_SPEED 10.\n#define PI 3.14159\n\nconst float KEY_W = 87.5 / 256.0;\nconst float KEY_A = 65.5 / 256.0;\nconst float KEY_S = 83.5 / 256.0;\nconst float KEY_D = 68.5 / 256.0;\nconst float KEY_SHIFT = 16.0;\nconst float KEY_SPACE = 32.0;\nconst float KEY_V = 86.0;\n\n\nbool isEnabled() {\n    return texelFetch(iChannel1, ivec2(2, 0), 0).x > 0.001;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos = texture(iChannel1, vec2(0.)).xyz;\n    if(iFrame <= 1) pos = vec3(0.,1.5,0.);\n    \n    switch (int(fragCoord.x)) {\n        case 0: {\n            if (isEnabled()) {\n                float mx = iMouse.xy == vec2(0.) ? 0. : ((iMouse.x / iResolution.x) * 2. - 1.) * 360.;\n                float speed = MOVE_SPEED * iTimeDelta;\n\n                float forwardBackward =\n                texture(iChannel0, vec2(KEY_W, 0.)).r -\n                texture(iChannel0, vec2(KEY_S, 0.)).r;\n\n                float leftRight =\n                texture(iChannel0, vec2(KEY_A, 0.)).r -\n                texture(iChannel0, vec2(KEY_D, 0.)).r;\n\n                float s = sin(radians(mx));\n                float c = cos(radians(mx));\n\n                pos.x += speed * (forwardBackward * s - leftRight * c);\n                pos.z += speed * (forwardBackward * c + leftRight * s);\n            }\n        }; break;\n        case 1: {\n            if (isEnabled()) {\n                pos = texelFetch(iChannel1, ivec2(1, 0), 0).xyz;\n                float space = texelFetch(iChannel0, ivec2(KEY_SPACE, 0), 0).r;\n                float shift = texelFetch(iChannel0, ivec2(KEY_SHIFT, 0), 0).r;\n\n                pos.y += space * 0.2;\n                pos.y -= shift * 0.2;\n            }\n        }; break;\n        \n        case 2: {\n            pos = texelFetch(iChannel1, ivec2(2, 0), 0).xyz;\n            float v = texelFetch(iChannel0, ivec2(KEY_V, 0), 0).r;\n            \n            float timeDiff = iTime - pos.y;\n            \n             if (timeDiff > 0.07) {\n                bool prev = pos.x > 0.0001;\n                bool toggle = v > 0.0001;\n\n                bool next = prev;\n\n\n                if (toggle) {\n                    next = !prev;\n                }\n                pos.y = iTime;\n                pos.x = next ? 1.0 : 0.0;\n            }\n        \n        }; break;\n    }\n    \n    \n    fragColor = vec4(pos, 0.);\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define DEBUG_WATER 0\n\n#define NEAR 0.003\n#define FAR 86.0\n#define STEPS 80\n#define SHADOW_STEPS 33\n\n#define ID_NONE 0\n#define ID_GROUND 1\n#define ID_WATER 2\n#define ID_ROCK 3\n\n#define NOISE(p, seed, lod) (textureLod(iChannel3, (p + (seed*1.9287827185))/256.0, lod).rgb)\n\nvec3 snoise(in vec2 p, in float seed, in float lod) {\n    p += 0.99288124;\n    vec2 id = floor(p);\n    vec2 lv = fract(p); lv = lv*lv*(3.0-2.0*lv);\n    return mix(\n        mix(NOISE(id, seed, lod), NOISE(id + vec2(1, 0), seed, lod), lv.x),\n        mix(NOISE(id + vec2(0, 1), seed, lod), NOISE(id + vec2(1, 1), seed, lod), lv.x),\n        lv.y\n    );\n}\n\nvec3 snoise(in vec2 p, in float seed, in float lod, in float freq, const in int octaves) {\n    p += 0.99288124;\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    for (int i = ZERO; i < octaves; i++) {\n        n += amp * snoise(p*freq, seed, lod); div += amp; amp /= 2.0; lod /= 2.0; freq *= 2.0;\n    }\n    return n / div;\n}\n\nvec3 snoiseWarp(in vec2 p, in float seed, in float lod, in float freq, const in int octaves, in float warp) {\n    p += 0.99288124;\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    for (int i = ZERO; i < octaves; i++) {\n        n += amp * snoise(p*freq, seed, lod); div += amp; amp /= 2.0; lod /= 2.0; freq *= 2.0;\n        p += (n.xy*n.z)*warp;\n    }\n    return n / div;\n}\n\nfloat sineNoise(in vec2 p, in float seed, in float freq, const in int octaves) {\n    float n = 0.0;\n    float div = 0.0;\n    float amp = 1.0;\n    \n    float x = 0.0;\n    float y = 0.0;\n    \n    for (int i = ZERO; i < octaves; i++) {\n        x += amp * exp(cos((p.x + sin(x*freq-p.y) + sin(seed * freq))*freq)-1.0);\n        y += amp * exp(sin((p.y + cos(y*freq-p.x) + cos(seed * freq))*freq)-1.0);\n        p.xy *= rot((x-y) + (seed*freq));\n        div += amp; amp /= 2.0; freq *= 2.0;\n        \n    }\n    \n    return clamp(((x + y) / 2.0) / div, 0.0, 1.0);\n}\n\nfloat heightNoise(in vec2 p, in float seed, in float freq, const in int octaves) {\n    float n = 0.0;\n    float div = 0.0;\n    float amp = 1.0;\n    \n    float x = 0.0;\n    float y = 0.0;\n    \n    for (int i = ZERO; i < octaves; i++) {\n        x += amp * exp(cos((p.x + sin(x*freq-p.y) + sin(seed * freq))*freq)-1.0);\n        y += amp * exp(sin((p.y + cos(y*freq-p.x) + cos(seed * freq))*freq)-1.0);\n        div += amp; amp /= 2.0; freq *= 2.0;\n        \n    }\n    \n    return clamp(((x + y) / 2.0) / div, 0.0, 1.0);\n}\n\nfloat mut(in float v, in float seed) {\n    float v1 = exp(cos(v-seed)-1.);\n    float v2 = exp(sin(v+seed)-1.);\n    float v3 = exp(cos(sin(v1-seed) + cos(v2+seed))-1.);\n    float v4 = exp(sin(v3)-1.);\n    float v5 = exp(sin(cos(v3-seed) + sin(v4+seed))-1.);\n    float v6 = exp(cos(sin(v1-v5) + (v2-v4))-1.);\n    return v1 * v2 * v3 + v4 * v5 + v6;\n}\n\nfloat freqNoise(in vec2 p, in float seed, in float freq, const in int octaves) {\n    vec2 n = vec2(0.0);\n    float div = 0.0;\n    float amp = 1.0;\n    \n    for (int i = 0; i < octaves; i++) {\n        n += amp*vec2(mut(p.x*freq, seed), mut(p.y*freq, seed));\n        p += amp*n*freq*0.2;\n        p *= rot(freq*n.x*n.y*amp*(float(i+1) / float(octaves)));\n        div += amp; amp /= 2.0; freq *= 2.0;\n    }\n    \n    return ((n.x + n.y)*0.5) / div;\n}\n\nfloat getRiverArea(in vec3 p) {\n    return 1.0-smoothstep(1., 10., abs(p.x)-5.);\n}\n\nfloat groundSDF(in vec3 p) {\n    if (p.y >= 16.0) return p.y;\n    float riverArea = getRiverArea(p);\n    \n    float h = heightNoise(p.xz, 4.492123, 0.09, 4);\n    h *= (1.0-riverArea);\n    h -= riverArea*0.5;\n    \n    if (riverArea > 0.00002) {\n        vec3 nn = snoise(p.xz, 0.3928715, 0.1, 0.4, 6);\n        h += ((pow(nn.x, 2.)*0.5)*riverArea*riverArea)*0.33;\n    }\n    \n    return (p.y - (h*9.)) / (1.6);\n}\n\nfloat waterSDF(in vec3 p) {\n    if (p.y > 4.) return p.y;\n    float riverArea = getRiverArea(p);\n    if (riverArea <= 0.0002) return FAR;\n    \n    float d = p.y;\n    float h = 0.0;\n    \n\n    float time = T*0.9;\n\n    float seed = 0.62134;\n    vec2 shift = vec2(cos(time + seed), sin(time + seed))*0.5;\n\n    vec3 n1 = snoiseWarp(p.xz+(shift*0.2), 0.00823812 + seed, 1.0, 0.5, 6, 1.5);\n    shift += n1.yz*2.0-1.0;\n    vec3 n2 = snoiseWarp(p.zx-(shift*0.1), 2.39289156 + seed, 1.0, 0.3, 6, 1.5);\n    shift = vec2(sin(time + 3.92981 + n1.x + n2.x), cos(time + 7.78844 + n1.y + n2.y));\n    \n    vec3 n3 = snoiseWarp(p.xz+(shift), 10.2948839 + seed, 0.5, 1.0, 6, 1.5);\n    \n    shift = vec2(cos(time - n3.z), sin(time - n3.y));\n    vec3 n4 = snoise(p.zx-shift, 16.992388215 + seed, 0.2, 0.1, 3);\n    \n\n    h += n1.x;\n    h += n2.x;\n    h *= (0.5+(n1.y*0.5));\n    h -= n2.y*0.5;\n    h += (n3.x*0.5)-n3.y;\n    h *= (0.2+(n4.x*0.5));\n    h += n4.z;\n    h -= n1.z;\n    h *= (0.5+(n3.z*0.5));\n    \n    d -= h;\n    return max(d,-riverArea);\n}\n\nfloat rockSDF(in vec3 p, in float r, in float seed) {\n    float nxz1 = heightNoise(p.xz, 0.02389125 + seed,  0.5, 4);\n    float nyz1 = heightNoise(p.yz, 2.20989381 + seed,  0.5, 4);\n    float nxy1 = heightNoise(p.xy, 7.39988832 + seed,  0.9, 4);\n    float w = heightNoise(vec2(nxz1, nyz1)+nxy1, 16.9398838 + seed,  1., 4);\n    float rr = fract(seed*10.2381825123);\n    \n    \n    p.y *= (1.0+w);\n    \n    r += nxz1*nyz1*2.;\n    \n    r = mix(r, r*0.2, nxy1);\n    r = mix(r, r*r*0.6, rr);\n  \n    p.y -= r*2.;\n    float d = length(p) - max(0.002, r);\n    return d/1.5;\n}\n\nfloat sdf(inout Data data, in vec3 p) {\n    int skip = data.skip;\n    int id = ID_NONE;\n    float dist = FAR;\n    \n  //  p.z = smod(p.z, ceil(FAR*2.));\n   // p.z = smod(p.z, FAR*2., 0.8);\n    #if DEBUG_WATER\n    float water = waterSDF(p);\n    SAMPLE(water, ID_WATER);\n    #else\n    \n    if (!data.skipWater) {\n        \n        float water = waterSDF(p);\n        data.id = ID_WATER;\n        return water;\n    }\n    #endif\n    \n    float ground = groundSDF(p);\n    SAMPLE(ground, ID_GROUND);\n    \n    \n    float riverArea = getRiverArea(p);\n    \n    if (riverArea > 0.0002 && abs(p.x) < 8. && p.y < -2.) {\n        vec2 rockId = floor((p.xz/4.0)-2.);\n\n        p.z = mod(p.z, 4.0)-2.;\n        p.x = mod(p.x, 4.0)-2.;\n\n        float seed = hash21(rockId*10.902831, 4.92921832);\n\n        if (floor(seed*10.) > 5.0) {\n            vec3 offset = hash23(rockId*20.98388, 77.9038991);\n\n\n            p.xz += vec2(cos(offset.x*TAU), sin(offset.y*TAU))*0.9;\n\n            float rock = rockSDF(p - vec3(0, -(riverArea*0.5)*9., 0), 0.3, seed);\n            SAMPLE(rock, ID_ROCK);\n        }\n\n    }\n    \n    data.id = id;\n    return dist;\n}\n\nbool march(inout Data data, in vec3 ro, in vec3 rd) {\n    float d = 0.0;\n    int steps = data.steps;\n    bool isWater = data.skipWater == false;\n    for (int i = ZERO; i < steps; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        d += next;\n        \n        if ((isWater ? next : abs(next)) <= (NEAR * (1.0 + (d*2.)))) break;\n        if (abs(d) >= data.far) return false;\n    }\n    \n    vec3 p = ro+rd*d;\n    vec2 e = vec2(\n        (data.id == ID_WATER) ? 0.4 : (data.id == ID_GROUND) ? 0.1 : 0.001\n    , 0.0);\n    vec3 n = normalize(sdf(data, p) - vec3(\n        sdf(data, p - e.xyy),\n        sdf(data, p - e.yxy),\n        sdf(data, p - e.yyx)\n    ));\n    \n    data.d = d;\n    data.p = p;\n    data.n = n;\n    \n    return true;\n}\n\nfloat getShadow(in vec3 ro, in vec3 rd, in vec3 n, in float near, in float far, in int skip) {\n    float NdotL = cdot(n, rd);\n    if (NdotL <= 0.00002) return 1.0;\n    Data data = NEW_DATA;\n    data.skip = skip;\n\n    \n    float d = 0.0;\n    float r = 1.0;\n    for (int i = ZERO; i < SHADOW_STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        r = min(r, next/0.44);\n        d += next*0.13;\n        \n        if (abs(next) <= (NEAR * (1.0 + d))) break;\n        if (abs(d) >= FAR) break;\n    }\n    \n    return clamp(r + 0.8*(d / (1.0 + d)), AMBIENT, 1.0);\n}\n\n//#define DEBUG_TEXTURE rockTexture\n\nvec3 rockTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 c1 = rgb(109, 109, 107);\n    vec3 c2 = rgb(177, 144, 118);\n    vec3 c3 = rgb(110, 109, 113);\n    vec3 c4 = rgb(107, 100, 90);\n    \n    vec3 hf1 = snoise(uv, 0.3828185, 0.3, 64.0, 6);\n    vec3 hf2 = snoise(uv, 4.4968877, 0.2, 100.0, 6);\n    vec3 hf3 = snoise(uv, 7.7983955, 0.1, 120.0, 6);\n    vec3 lf1 = snoise(uv, 3.5553379, 0.1, 6.0, 6);\n    float w =  voronoi(uv*6., 0.2398125);\n    \n    float grain1 = smoothstep(0.5, 0.9, hf3.x);\n    float grain2 = smoothstep(0.5, 0.9, hf3.y);\n    float grain3 = smoothstep(0.5, 0.9, hf3.z);\n    \n    vec3 col1 = mix4(c1, c2, c3, c4, hf1);\n    col += col1;\n    \n    float cracks = max(0.0, 1.0-smoothstep(0.01, 0.05, abs(lf1.x*2.0-1.0)));\n    cracks = clamp(pow(((cracks*hf1.y*lf1.z)*2.)*(1.0-(grain1+grain2+grain3)), 2.), 0.0, 1.0);\n    col = mix(col, col+col, cracks);\n    \n    float bumps = max(0.0, 1.0-w);\n    float bumpEdges = clamp(smoothstep(0.2, 1.3, 1.0-bumps)*hf2.x*2.*hf1.y*2., 0.0, 1.0);\n    col = mix(col, col*col, bumpEdges);\n    \n    float bumpTops = smoothstep(0.01, 1.5, max(0.0, bumps-bumpEdges));\n    bumpTops = pow(bumpTops*1.1, 7.)*smoothstep(0.4, 0.7, lf1.x)*max(0.0, 1.0-cracks);\n    col += bumpTops;\n    \n    col = mix(col, col*col, clamp((grain1+grain2+grain3)*lf1.z, 0.0, 1.0));\n    \n    m.spec = clamp(cracks + bumpTops, 0.0, 1.0);\n    \n    m.z = clamp(1.0-(cracks+bumpEdges), 0.0, 1.0);\n    \n    return col;\n}\n\nvec3 pebblePat(in vec2 uv, in float seed, inout float w) {\n    vec3 c1 = rgb(206, 206, 204);\n    vec3 c2 = rgb(143, 122, 100);\n    vec3 c3 = rgb(53, 68, 67);\n    vec3 c4 = rgb(95, 90, 83);\n    vec3 c5 = rgb(219, 204, 178);\n    vec3 c6 = rgb(161, 157, 144);\n    \n    vec3 mf1 = snoise(uv, 0.0289381 + seed, 0.05, 16.0, 6);\n    \n    vec2 vid = vec2(0.0);\n    w = voronoiID(uv*10., 3.281235 + seed, vid);\n    \n    vec3 vidr = hash23(vid, 4.49282871 + seed);\n    \n    vec3 col1 = mix4(c1, c2, c3, c4, vidr);\n    vec3 col2 = mix4(c3, c4, c5, c6, vidr);\n    \n    vec3 col = mix(col1, col2, 0.3*smoothstep(0.5, 0.6, mf1.x));\n    col = col * smoothstep(0.2, 1.0, max(0.0, (1.0-w)));\n    \n    return col;\n}\nvec3 pebbleTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    float w1 = 0.0;\n    float w2 = 0.0;\n    \n    vec3 mf1 = snoise(uv, 2.29382814, 0.05, 16.0, 6);\n    float sn = sineNoise(uv + mf1.xz, 5.39381, 3.0, 6);\n    \n    vec3 col1 = pebblePat(uv, 0.023125, w1);\n    vec3 col2 = pebblePat(uv*4.0, 444.4234, w2);\n    float iw1 = max(0.0, 1.0-w1);\n    float iw2 = max(0.0, 1.0-w2);\n    col = mix(col1, col2, max(0.0, iw2-iw1));\n    col = mix(col, mix(col1, col2, smoothstep(0.3, 0.7, mf1.x)), 0.5);\n    \n    col = mix(col, vec3(sn), clamp(1.0 - smax(iw1, iw2, 0.6), 0.0, 1.0));\n    \n    m.spec = clamp(smax(pow(iw1, 2.0), pow(iw2, 2.0), 0.3), 0.0, 1.0);\n    \n    m.z = (iw1+iw2)/2.;\n    \n    return col;\n}\n\nvec3 grassTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    float w = voronoi(uv*10., 0.3921255);\n    float iw = max(0.0, 1.0-w);\n    vec3 hf1 = snoise(uv, 0.882792154, 0.4, 120.0, 6);\n    vec3 hf2 = snoise(uv, 5.59382819, 0.4, 99.0, 6);\n    vec3 lf1 = snoise(uv, 7.77499345, 0.2, 4.0, 6);\n    vec3 lf2 = snoise(uv, 0.00333222, 0.2, 2.0, 6);\n    vec3 lf3 = snoiseWarp(uv, 5.555993, 0.5, 0.5, 6, 0.5);\n    vec3 grain = abs(normalize(reflect(cross(hf1*2.0-1.0, hf2*2.0-1.0), lf1)));\n    vec3 g1 = rgb(63, 92, 11);\n    vec3 g2 = rgb(97, 110, 32);\n    vec3 g3 = rgb(143, 146, 72);\n    vec3 g4 = rgb(60, 73, 41);\n    \n    vec3 grassCol = mix4(g1, g2, g3, g4, hf1);\n    \n    col += grassCol;\n    \n    vec3 d1 = rgb(68, 63, 45);\n    vec3 d2 = rgb(185, 164, 131);\n    vec3 d3 = rgb(131, 128, 108);\n    vec3 d4 = rgb(97, 79, 64);\n    \n    vec3 dirtCol = mix4(d1, d2, d3*iw, d4, hf2);\n    \n    float dirtReg = smoothstep(0.3, 0.7, lf1.x) * smoothstep(0.22, 0.7, lf2.x);\n    float grainReg = smoothstep(0.44, 0.7, lf2.z);\n    \n    col = mix(col, dirtCol, dirtReg);\n    \n    float crust = grainReg*grain.x;\n    \n    float wet = smoothstep(0.5, 0.7, lf3.x);\n    \n    col = mix(col, (col*col)+(d4*d4), wet);\n    \n    m.z = clamp((1.0 - (dirtReg*dirtReg))+(luma(col)*0.01), 0.0, 1.0);\n    m.spec = clamp(pow(dirtReg*hf1.z, 2.), 0.0, 1.0);\n    \n    col = mix(col, col*col, clamp(0.5+((crust * 0.5) + (lf1.y*0.5*lf1.y)), 0.0, 1.0));\n    return col;\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = p.xz;\n    vec3 col = vec3(0.0);\n    \n    Material grassMaterial = NEW_MATERIAL;\n    vec3 grassCol = grassTexture(uv, p, grassMaterial);\n    \n    float riverArea = getRiverArea(p);\n    riverArea = pow(riverArea, 6.0);\n\n    if (riverArea > 0.0001) {\n        Material pebbleMaterial = NEW_MATERIAL;\n        vec3 pebbleCol = pebbleTexture(uv*0.2, p, pebbleMaterial);\n        col = mix(grassCol, pebbleCol, riverArea);\n        data.m = materialMix(grassMaterial, pebbleMaterial, riverArea);\n        data.n = makeNormal(data.n, data.m.z, 0.2, 0.3);\n    } else {\n        col = grassCol;\n        data.m = grassMaterial;\n        data.n = makeNormal(data.n, data.m.z, 0.3, 0.1);\n    }\n    \n     \n    return col;\n}\n\nvec3 getAlbedoWater(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, n);\n    vec3 col = rgb(34, 57, 75);\n    \n    data.m.rough = 0.0002;\n    data.m.metallic = 0.0001;\n    return col;\n}\n\nvec3 getAlbedoRock(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, n);\n    vec3 col = rockTexture(uv, p, data.m);\n    data.n = makeNormal(data.n, data.m.z, 0.3, 0.1);\n\n    return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_GROUND: return getAlbedoGround(data); break;\n        case ID_WATER: return getAlbedoWater(data); break;\n        case ID_ROCK: return getAlbedoRock(data); break;\n    }\n    \n    return vec3(1.);\n}\n\nvec3 getSky(in vec3 rd) {\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    vec3 col = pow(vec3(0.29, 0.61, 0.9), vec3(1.0 + dotup));\n    return col;\n}\n\nvec3 forEachLight(in Data data, in Light light, in vec3 ro, in vec3 rd, in vec3 diffuse) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec3 L = getLightDir(light, p);\n    vec3 ref = reflect(L, n);\n    float VdotR = cdot(rd, ref);\n    float spec = data.m.spec * pow(VdotR, 64.0);\n    vec3 att = getLightAtt(light, p, n);\n    float shadow = getShadow(p + (n*NEAR*2.), L, n, data.d, light.type == LIGHT_AMBIENT ? \n        FAR : distance(light.p, p), data.id);\n        \n    return (diffuse + spec) * att * shadow;\n}\n\n\nvec3 lightEffect(in Data data, in Light light, in vec3 ro, in vec3 rd) {\n    vec3 L = getLightDir(light, ro);\n    float VdotL = cdot(rd, L);\n    \n    return light.c * light.s * pow(VdotL, 16.0)*0.5;\n}\n\nbool iplane(vec3 N, vec3 P, vec3 O, vec3 D, out float t, out vec3 point, inout float dx, inout float dy) {\n    float denom = dot(N, D);\n    if (abs(denom) < 0.0001) return false;\n    t = dot(N, (P - O)) / denom;\n    if (t < 0.0) return false;\n    point = O + t * D;\n    vec3 v = point - P;\n    vec3 uAxis = normalize(cross(N, vec3(0, 1, 0)));\n    vec3 vAxis = normalize(cross(N, vec3(0, 0, 1)));\n    dx = dot(v, uAxis);\n    dy = dot(v, vAxis);\n\n    if (abs(dx) > 1. || abs(dy) > 16.) return false;\n    \n    point = point - P;\n    return true;\n}\n\nvec3 waterEffect(in vec3 primCol, in Data data, in Light light, in vec3 ro, in vec3 rd, inout float depth) {\n    float amp = smoothstep(0.0, 1.0, max(0.0, -ro.y+0.5));\n    if (amp <= 0.000001) return primCol;\n    \n    float dotup = cdot(rd, vec3(0, 1, 0));\n    \n    amp *= max(0.0, 1.0 - smoothstep(0.0, 0.5, dotup));\n    \n    vec3 col = vec3(0.29, 0.59, 0.9)*primCol;\n    vec3 nn = textureLod(iChannel2, (rd + vec3(cos(T*0.2), sin(T*0.2), sin((T*0.2)+2.209291)))*0.5, 0.0).xyz;\n    float planeDist = FAR;\n    vec3 planePoint = vec3(0.0);\n    float dx = 0.0;\n    float dy = 0.0;\n    iplane(vec3(0, -1, 0), vec3(0, 0.5, 0), ro, rd, planeDist, planePoint, dx, dy);\n    planeDist = max(0.0, planeDist);\n    dx = max(0.0, abs(dx));\n    dy = max(0.0, abs(dy));\n    \n    col += smoothstep(0.2, 1.0, depth)*col*smoothstep(0.0, 1.0, smax(smax(dx/FAR, dy/FAR, 0.5), planeDist/FAR, 0.5)) * vec3(0.29, 0.59, 0.9);\n    \n    depth += adot(rd, normalize(nn*2.0-1.0));\n    \n    return mix(primCol, col, amp);\n}\n\nvec3 render(inout Data data, in vec3 ro, in vec3 rd, inout float depth) {\n    #if DEBUG_WATER\n    data.skipWater = false;\n    #endif\n    vec3 col = vec3(0.0);\n    float dotup = cdot(rd, vec3(0,1,0));\n    Light light = Light(vec3(1, 2, 3), vec3(0.0), vec3(0.97, 0.89, 0.79), 2.0, LIGHT_AMBIENT);\n    \n    bool hit = false;\n    vec3 oro = ro;\n    vec3 ord = rd;\n    \n    if (march(data, ro, rd)) {\n        hit = true;\n        vec3 albedo = getAlbedo(data);\n        vec3 diffuse = albedo / M_PI;\n        col += forEachLight(data, light, ro, rd, diffuse);\n    } else {\n        col += getSky(rd);\n    }\n    \n    col += lightEffect(data, light, ro, rd);\n    \n    #if DEBUG_WATER <= 0\n    bool hitWater = false;\n    float riverArea = getRiverArea(hit ? data.p : (ro+rd*(FAR/2.)));\n    Data water = NEW_DATA;\n    Data primWater = water;\n    if (hit && riverArea > 0.0002) {\n        water.skipWater = false;\n        water.far = data.d+6.;\n        water.steps = 33;\n        primWater = water;\n        vec3 mixf = vec3(1.0);\n        vec3 waterDiffuse = vec3(0.0); \n        bool isRefract = false;\n        bool isReflect = false;\n\n        for (int j = ZERO; j < 3; j++) {\n            if (march(water, ro, rd) && (water.d < data.d || j > 0)) {\n                hitWater = true;\n                vec3 albedo = getAlbedo(water);\n                vec3 diffuse = albedo / M_PI;\n                \n                if (j <= 0) {\n                    col /= 2.;\n                    primWater = water;\n                    waterDiffuse = diffuse;\n                }\n                \n                vec3 nextCol = vec3(0.0);\n                nextCol += forEachLight(water, light, ro, rd, diffuse);\n                \n                if (isRefract) {\n                    float depthDiff = abs(data.d - primWater.d) / FAR;\n                    col /= (1.0 + (depthDiff*64.));\n                    col = nextCol/2.;\n                    col *= max(0.0, 1.0 - depthDiff);\n                } else {\n                    col += nextCol * mixf;\n                }\n                \n                \n                isReflect = false;\n                isRefract = false;\n                \n                switch (j) {\n                    // refract\n                    case 0: {\n                        ro = (primWater.p + (primWater.n*NEAR*2.));\n                        rd = refract(ord, primWater.n, 1.0/1.33);\n                        mixf = vec3(1.0);\n                        isRefract = true;\n                        water.skipWater = true;\n                        water.steps = 33;\n                        water.far = data.d+6.;\n                    }; break;\n                    \n                    \n                    // reflect\n                    case 1: {\n                        float rough = primWater.m.rough;\n                        float metallic = primWater.m.metallic;\n                       \n                        ro = (primWater.p + (primWater.n*NEAR*2.));\n                        rd = reflect(ord, primWater.n);\n                        \n                        float NdotV = dot(primWater.n, rd);\n                        vec3 f0 = mix(vec3(0.04), waterDiffuse, metallic);\n                        vec3 F = fresnelSchlickRoughness(NdotV, f0, rough*rough);\n                        mixf = F;\n                        isReflect = true;\n                        waterDiffuse = diffuse;\n                        water.skipWater = true;\n                        water.steps = STEPS/2;\n                        water.far = FAR;\n                    }; break;\n                    \n                    default: {\n                        break;\n                    }; break;\n                }\n            } else {\n                if (j <= 0 && !(isRefract || isReflect)) {\n                    break;\n                }\n                \n                if (isReflect) {\n                    col += getSky(rd) * mixf;\n                    col += lightEffect(water, light, ro, rd) * mixf*0.5;\n                } \n            }\n        }\n\n    }\n\n    #endif\n    \n    depth = min(data.d, max(water.d, primWater.d)) / FAR;\n    \n    col += smoothstep(0.02, 1.0, depth) * light.c * max(0.0, 1.0 - smoothstep(-0.1, 0.25, dotup));\n    \n    col = waterEffect(col, data, light, oro, ord, depth);\n    depth = clamp(depth, 0.0, 1.0);\n    return col;\n}\n\nvoid getRay(in vec2 uv, in vec4 m, inout vec3 ro, inout vec3 rd) {\n    ro = vec3(0, 0, -5.0);\n    rd = normalize(vec3(uv.xy, 1.0));\n    \n    \n    vec3 toggleWalk = texelFetch(iChannel0, ivec2(2, 0), 0).xyz;\n   \n    if (toggleWalk.x > 0.001) {\n        vec3 walk = texelFetch(iChannel0, ivec2(0, 0), 0).xyz;\n        vec3 fly = texelFetch(iChannel0, ivec2(1, 0), 0).xyz;\n        ro += walk;\n        ro.y += fly.y;\n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n        return;\n    }\n    \n    if (m.z > 0.001 && length(m.xy) > 0.001 && iFrame > 1 && iTime > 0.0001) {\n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n    } else {\n        rd.yz *= rot(radians(mix(0.0, -20.0, 0.5+(0.5*sin(T)))));\n        rd.xz *= rot(radians(mix(-10., 10.0,0.5+(cos(T)*0.5))));\n    }\n    \n    float moveTime = T*0.5;\n\n    ro.z += moveTime*10.;\n    \n    float y = 3.;\n    float time = T*0.5;\n    \n    y += (sin(time)*4.)+1.1;\n    \n    ro.x += cos(time)*3.;\n    \n    ro.y += y;\n    ro.y = max(y, ro.y);\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y, iMouse.zw);\n    \n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    getRay(uv, m, ro, rd);\n    Data data = NEW_DATA;\n    float depth = 1.0;\n    \n    #ifdef DEBUG_TEXTURE\n    Material ma = NEW_MATERIAL;\n    col += DEBUG_TEXTURE(fc.xy/R.xy, ro+rd, ma);\n    #else\n    col += render(data, ro, rd, depth);\n    col += (col*col*luma(col));\n    col = aces(col);\n    col = pow(col, vec3(1.0 / 2.2));\n    #endif\n    \n    O = vec4(col, depth);\n}","name":"Buffer A","description":"","type":"buffer"}]}