{"ver":"0.1","info":{"id":"4clyDj","date":"1721619959","viewed":39,"name":"MiPhone_","username":"Huihui_","description":"Fork from: https://www.shadertoy.com/view/lclcW8\n3D, raymarching\n\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst int MAX_SHADOW_STEPS = 15;\nconst float PRECISION = 1e-4;\nconst float MAX_DIST = 100.0;\nconst float PI = 3.1416;\n\n\nstruct Material {\n  vec3 ambientColor; // k_a * i_a\n  vec3 diffuseColor; // k_d * i_d\n  vec3 specularColor; // k_s * i_s\n  float alpha; // shininess\n};\n\nstruct Surface {\n  int id; // id of object\n  float sd; // signed distance\n  Material mat;\n};\n\n\nMaterial checkerboard(vec3 p) {\n  //vec3 aCol = vec3( 0.3 + grad_noise(p.xy, 1.) );\n  \n  vec3 aCol = 0.5 + 0.5 * vec3(-1. + mod(floor(p.x) + floor(p.z), 2.0));\n  vec3 dCol = vec3(0.3);\n  vec3 sCol = vec3(0);\n  float a = 1.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial phoneScreen() {\n  vec3 aCol = 0.4 * vec3(0., 0., 0.);\n  vec3 dCol = 0.5 * vec3(.1, 0.1, 0.1);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 128.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\n\nMaterial selfieCamera() {\n  vec3 aCol = 0.4 * vec3(0.1, 0.1, 0.1);\n  vec3 dCol = 0.5 * vec3(.2, 0.2, 0.2);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 128.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial smallSelfieCamera() {\n  vec3 aCol = 0.4 * vec3(0.1, 0.1, 0.1);\n  vec3 dCol = 0.5 * vec3(.3, 0.3, 0.3);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 128.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\n\nMaterial phoneBody() {\n  vec3 aCol = 0.4 * vec3(0.529, 0.831, 0.857 );\n  vec3 dCol = 0.5 * vec3(0.529,  0.931, 0.957 );\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 64.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial circle() {\n  vec3 aCol = 0.4 * vec3(0., 0., 0.);\n  vec3 dCol = 0.8 * vec3(.8, 0.8, 0.8);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 64.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial backCamera() {\n  vec3 aCol = 0.4 * vec3(0.1,.1,.1  );\n  vec3 dCol = 0.5 * vec3(0.1,.1,.1 );\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 64.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial smallbackCamera() {\n  vec3 aCol = 0.4 * vec3(0.15,.15,.15  );\n  vec3 dCol = 0.5 * vec3(0.15,.15,.15 );\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 64.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\n\nMaterial flash() {\n  vec3 aCol = 0.4 * vec3(0.9,.9,.9  );\n  vec3 dCol = 0.5 * vec3(0.9,.9,.9 );\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 64.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial backDecor() {\n  vec3 aCol = 0.4 * vec3(0.329, 0.831, 0.757 );\n  vec3 dCol = 0.5 * vec3(0.429,  0.931, 0.857 );\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 64.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial button() {\n  vec3 aCol = 0.4 * vec3( 0.75,0.75,0.75);\n  vec3 dCol = 0.5 * vec3( 0.73,0.75,0.77);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 64.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial socket() {\n  vec3 aCol = 0.4 * vec3( 0.,0.,0.);\n  vec3 dCol = 0.5 * vec3( 0.,0.,0.);\n  vec3 sCol = 0.6 * vec3(0, 0, 0);\n  float a = 64.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\n\n\n\nSurface opUnion(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2;\n  return obj1;\n}\n\nSurface opSmoothUnion(Surface obj1, Surface obj2, float k) {\n  float h = clamp( 0.5 + 0.5*(obj2.sd - obj1.sd)/k, 0.0, 1.0 );\n  return Surface(100-obj1.id,mix( obj2.sd, obj1.sd, h ) - k*h*(1.0-h),obj1.mat);\n}\n\n\nSurface scene(vec3 p) {  \n    //p.y += 0.;\n    \n  Surface co = Surface(0, p.y + 1., checkerboard(p));\n  \n    p.xy *= rotate2d(iTime);\n    p.yz *= rotate2d(iTime);\n  \n    //p.x = mod(p.x,2.);\n    // phone body, elongated cylinder\n    {\n    vec3 q = p - vec3(.0,0.0,0.0);\n    vec4 w = opElongate( q, vec3(0.45,0.,0.2) );\n    co = opUnion( co, Surface(1, w.w+sdCappedCylinder( w.xyz, vec2(0.04,0.035) ), phoneBody() ) );\n    }\n    \n    // phone screen\n    {\n    vec3 q = p - vec3(.0,0.0001,0.0);\n    vec4 w = opElongate( q, vec3(0.445,0.,0.195) );\n    co = opUnion( co, Surface(2, w.w+sdCappedCylinder( w.xyz, vec2(0.04,0.035) ), phoneScreen() ) );\n    }\n\n    // selfie camera\n    {\n    vec3 q = p - vec3(.45,0.0002,0.0);\n    vec4 w = opElongate( q, vec3(0.0,0.,0.05) );\n    co = opUnion( co, Surface(3, w.w+sdCappedCylinder( w.xyz, vec2(0.02,0.035) ), selfieCamera()) );\n    }\n\n    // selfie camera left    cylinder\n    {\n    vec3 q = p - vec3(.45,0.0003,0.05);\n    co = opUnion( co, Surface(4,sdCappedCylinder( q, vec2(0.017,0.035) ), smallSelfieCamera() ));\n    }\n    \n    // selfie camera right   cylinder\n    {\n    vec3 q = p - vec3(.45,0.0003,-0.05);\n    co = opUnion( co, Surface(4,sdCappedCylinder( q, vec2(0.017,0.035) ), smallSelfieCamera() ));\n    }\n    \n    // cycle torus\n    {\n    vec3 q = p - vec3(-.39,0.0003,.0);\n    co = opUnion( co, Surface(5,sdTorus( q, vec2(0.035,0.035)) , circle() ) );\n    }\n\n    // back camera\n    {\n    vec3 q = p - vec3(.32,-0.038,0.07);\n    vec4 w = opElongate( q, vec3(0.0,0.,0.0) );\n    co = opSmoothUnion( co, Surface(6, w.w+sdCappedCylinder( w.xyz, vec2(0.135,0.015) ),  backCamera() ),0.04 );\n    }\n    \n    // back camera bottom\n    {\n    vec3 q = p - vec3(.32,-0.0412,0.07);\n    vec4 w = opElongate( q, vec3(0.0,0.,0.0) );\n    co = opUnion( co, Surface(6, w.w+sdCappedCylinder( w.xyz, vec2(0.135,0.015) ),  backCamera() ) );\n    }\n\n    // back camera 1\n    {\n    vec3 q = p - vec3(.38,-0.0415,0.11);\n    vec4 w = opElongate( q, vec3(0.0,0.,0.0) );\n    co = opUnion( co, Surface(7, w.w+sdCappedCylinder( w.xyz, vec2(0.035,0.015) ), smallbackCamera() ));\n    }\n    \n    \n    // back camera 2\n    {\n    vec3 q = p - vec3(.28,-0.0415,0.11);\n    vec4 w = opElongate( q, vec3(0.0,0.,0.0) );\n    co = opUnion( co, Surface(8, w.w+sdCappedCylinder( w.xyz, vec2(0.035,0.015) ), smallbackCamera() ));\n    }\n    \n    \n    // back flash\n    {\n    vec3 q = p - vec3(.38,-0.0415,0.01);\n    vec4 w = opElongate( q, vec3(0.0,0.,0.0) );\n    co = opUnion( co, Surface(9, w.w+sdCappedCylinder( w.xyz, vec2(0.035,0.015) ),  flash() ));\n    }\n    \n    \n    // back camera 3\n    {\n    vec3 q = p - vec3(.28,-0.0415,0.01);\n    vec4 w = opElongate( q, vec3(0.0,0.,0.0) );\n    co = opUnion( co, Surface(10, w.w+sdCappedCylinder( w.xyz, vec2(0.035,0.015) ), smallbackCamera() ));\n    }  \n    \n    // back decoration\n    {\n    vec3 q = p - vec3(.0,-0.021,-0.07);\n    vec4 w = opElongate( q, vec3(0.45,0.,0.13) );\n    co = opUnion( co, Surface(11, w.w+sdCappedCylinder( w.xyz, vec2(0.03,0.015) ), backDecor() ) );\n    }\n    \n    \n    // side button up\n    {\n    vec3 q = p - vec3(.25,0.0002,0.231);\n    q.yz = q.zy;\n    vec4 w = opElongate( q, vec3(0.08,.0,0.) );\n    co = opUnion( co, Surface(12, w.w+sdCappedCylinder( w.xyz, vec2(0.013,0.015) ), button() ) );\n    }\n    \n    // side button down\n    {\n    vec3 q = p - vec3(.05,0.0002,0.231);\n    q.yz = q.zy;\n    vec4 w = opElongate( q, vec3(0.04,.0,0.) );\n    co = opUnion( co, Surface(12, w.w+sdCappedCylinder( w.xyz, vec2(0.013,0.015) ), button() ) );\n    }\n    \n    // charge\n    {\n    vec3 q = p - vec3(-.476 ,0.0,0.);\n    q.yx = q.xy;\n    vec4 w = opElongate( q, vec3(0.0,.0,0.028) );\n    co = opUnion( co, Surface(13, w.w+sdCappedCylinder( w.xyz, vec2(0.013,0.015) ), socket() ) );\n    }\n    \n    // audio left\n    {\n    vec3 q = p - vec3(-.476 ,0.0,-0.08);\n    q.yx = q.xy;\n    vec4 w = opElongate( q, vec3(0.0,.0,0.006) );\n    co = opUnion( co, Surface(13, w.w+sdCappedCylinder( w.xyz, vec2(0.01,0.015) ), socket() ) );\n    }\n\n    // audio right 1\n    {\n    vec3 q = p - vec3(-.476 ,0.0,0.1);\n    q.yx = q.xy;\n    vec4 w = opElongate( q, vec3(0.0,.0,0.0) );\n    co = opUnion( co, Surface(13, w.w+sdCappedCylinder( w.xyz, vec2(0.01,0.015) ), socket() ) );\n    }\n  \n    // audio right 2\n    {\n    vec3 q = p - vec3(-.476 ,0.0,0.13);\n    q.yx = q.xy;\n    vec4 w = opElongate( q, vec3(0.0,.0,0.0) );\n    co = opUnion( co, Surface(13, w.w+sdCappedCylinder( w.xyz, vec2(0.01,0.015) ),socket() ) );\n    }\n    \n    // audio right 3\n    {\n    vec3 q = p - vec3(-.476 ,0.0,0.16);\n    q.yx = q.xy;\n    vec4 w = opElongate( q, vec3(0.0,.0,0.0) );\n    co = opUnion( co, Surface(13, w.w+sdCappedCylinder( w.xyz, vec2(0.01,0.015) ),socket()) );\n    }\n    \n    // audio right 4\n    {\n    vec3 q = p - vec3(-.476 ,0.0,0.19);\n    q.yx = q.xy;\n    vec4 w = opElongate( q, vec3(0.0,.0,0.0) );\n    co = opUnion( co, Surface(13, w.w+sdCappedCylinder( w.xyz, vec2(0.01,0.015) ), socket() ) );\n    }\n  \n  \n  \n  \n  {}\n  \n  {}\n  \n  {}\n\n  return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n  float depth = 0.0;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = scene(p);\n    depth += abs(co.sd);\n    if (abs(co.sd) < PRECISION || depth > MAX_DIST) break;\n  }\n\n  co.sd = depth;\n\n  return co;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n      e.xyy * scene(p + e.xyy).sd +\n      e.yyx * scene(p + e.yyx).sd +\n      e.yxy * scene(p + e.yxy).sd +\n      e.xxx * scene(p + e.xxx).sd);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n    vec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n    vec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n    vec3 cu = normalize(cross(cd, cr)); // camera up\n\n    return mat3(-cr, cu, -cd);\n}\n\nvec3 phong(vec3 lightDir, float lightIntensity, vec3 normal, vec3 rd, Surface co) {\n  // background\n  vec3 bgColor = vec3(0.835, 1.0, 1.0);\n  //bgColor = vec3(0.5);\n  if (co.sd > MAX_DIST) return bgColor;\n  \n  // ambient\n  vec3 ambient = co.mat.ambientColor;\n\n  // diffuse\n  float dotLN = clamp(dot(-lightDir, normal), 0., 1.);\n  vec3 diffuse = co.mat.diffuseColor * dotLN;\n\n  // specular\n  float dotRV = clamp(dot(reflect(lightDir, normal), -rd), 0., 1.);\n  vec3 specular = co.mat.specularColor * pow(dotRV, co.mat.alpha);\n\n  vec3 col = lightIntensity * (ambient + diffuse + specular);\n  \n  // fog\n  col = mix(col, bgColor, 1.0 - exp(-0.0002 * co.sd * co.sd * co.sd));\n  return col;\n\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float tmax) {\n  float res = 1.0;\n  float t = mint;\n\n  for(int i = 0; i < MAX_SHADOW_STEPS; i++) {\n    float h = scene(ro + rd * t).sd;\n      res = min(res, 8.0*h/t);\n      t += clamp(h, 0.02, 0.10);\n      if(h < 0.001 || t > tmax) break;\n  }\n\n  return clamp( res, 0.0, 1.0 ); // soft shadow\n  //return step(tmax - 0., t); //hard shadow\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y ;\n  vec2 mouse = iMouse.xy / iResolution.xy;\n  \n  vec3 col = vec3(0);\n  \n  vec3 lp = vec3(0); // lookat point (aka camera target)\n  vec3 ro = vec3(cos(2.*PI*mouse.x), 1.*sin(2.*PI*mouse.y) , sin(2.*PI*mouse.x));\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  Surface co = rayMarch(ro, rd); // closest object\n  \n  vec3 p = ro + rd * co.sd; // point on surface found by ray marching\n  vec3 normal = calcNormal(p); // surface normal\n\n  // light\n  vec3 lightPosition = 4. * vec3(cos(iTime), 1., sin(iTime));\n  vec3 lightDirection = normalize(p - lightPosition);\n  float lightIntensity = 0.9;\n      \n  // phone light model\n  col = phong(lightDirection, lightIntensity, normal, rd, co); \n      \n//*  // soft shaddow from iq\n  if (/*co.id == 1 && */ co.sd < 0.2 * MAX_DIST) {\n    float softShadow = clamp(softShadow(p, -lightDirection, 100.*PRECISION, length(p-lightPosition)), 0.2, 1.0);\n    col *= softShadow;\n  }\n//*/\n\n//*  // reflection;\n  if ((co.id == 11 || co.id == 2) && scene(p).sd < 10. * PRECISION) {\n    vec3 reflRD = reflect(rd, normal);\n    vec3 reflRO = p + 1.1 * PRECISION * normal; // move origin a little bit away\n    // reflRO = p + 1.5 * PRECISION * reflRD; // not working\n    Surface reflCO = rayMarch(reflRO, reflRD);\n    vec3 reflP = reflRO + reflRD * reflCO.sd;\n    vec3 reflNormal = calcNormal(reflP);\n    reflCO.sd += co.sd;\n    vec3 reflCol = phong(lightDirection, lightIntensity, reflNormal, reflRD, reflCO);\n    col = mix(col, reflCol, 0.2);\n  }\n//*/\n\n/*  // refraction\n  if (co.id == 3 && scene(p).sd < 10. * PRECISION) {\n    const float ETA = 1.69; // glass 1.69, water 1.33ï¼Œ1.0 air\n    vec3 refrRD1 = refract(rd, normal, 1./ETA);\n    vec3 refrRO1 = p - 2.1 * PRECISION * normal; // move origin into the sphere\n    //refrRO1 = p + 5. * PRECISION * refrRD1; // not working\n    Surface refrCO1 = rayMarch(refrRO1, refrRD1);\n    vec3 refrP1 = refrRO1 + refrRD1 * refrCO1.sd;\n    vec3 refrN1 = calcNormal(refrP1);\n    \n    vec3 refrRD2 = refract(refrRD1, -refrN1, ETA);\n    vec3 refrRO2 = refrP1 + 2.1 * PRECISION * refrN1; // move origin outside the sphere\n    //refrRO2 = refrP1 + 5. * PRECISION * refrRD2; // not working\n    Surface refrCO2 = rayMarch(refrRO2, refrRD2);\n    vec3 refrP2 = refrRO2 + refrRD2 * refrCO2.sd;\n    vec3 refrN2 = calcNormal(refrP2);\n    refrCO2.sd += refrCO1.sd + co.sd;\n    vec3 refrCol = phong(lightDirection, lightIntensity, refrN2, refrRD2, refrCO2);\n    col = mix(col, refrCol, 0.2);\n  }\n*/\n  col = pow(col, vec3(1.0/2.2)); // Gamma correction\n  fragColor = vec4(col, 1.0); // Output to screen\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//-------------------------------------------------\n\nvec4 opElongate( in vec3 p, in vec3 h )\n{\n    //return vec4( p-clamp(p,-h,h), 0.0 ); // faster, but produces zero in the interior elongated box\n    \n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\n//-------------------------------------------------\n\nfloat sdSphere(vec3 p, float r )\n{\n  return length(p) - r;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n//---------------------------------\n\nfloat map(in vec3 pos)\n{\n    float d = 1e10;\n    \n\n    // ellipsoide\n    {\n    vec3 q = pos - vec3(-3.0,0.0,-1.0);\n    d = min( d, sdEllipsoid( q.yzx, vec3(0.4,0.2,0.1) ) );\n    }\n    \n    // elongated ellipsoide\n    {\n    vec3 q = pos - vec3(-3.0,0.0,1.0);\n    vec4 w = opElongate( q, vec3(0.2,0.0,0.3) );\n    d = min( d, w.w+sdEllipsoid( w.yzx, vec3(0.4,0.2,0.1) ) );\n    }\n\n    // cylinder *****\n    {\n    vec3 q = pos - vec3(-1.0,0.0,-1.0);\n    d = min( d, sdCappedCylinder( q, vec2(0.4,0.1) ) );\n    }\n    \n    // elongated cylinder\n    {\n    vec3 q = pos - vec3(-1.0,0.0,1.0);\n    vec4 w = opElongate( q, vec3(0.2,0.0,0.3) );\n    d = min( d, w.w+sdCappedCylinder( w.xyz, vec2(0.4,0.1) ) );\n    }\n\n    // torus\n    {\n    vec3 q = pos - vec3(1.0,0.0,-1.0);\n    d = min( d, sdTorus( q, vec2(0.4,0.05) ) );\n    }\n    \n    // elongated torus\n    {\n    vec3 q = pos - vec3(1.0,0.0,1.0);\n    vec4 w = opElongate( q, vec3(0.2,0.0,0.3) );\n    d = min( d, w.w+sdTorus( w.xyz, vec2(0.4,0.05) ) );\n    }\n\n    // torus\n    {\n    vec3 q = pos - vec3(3.0,0.0,-1.0);\n    d = min( d, sdTorus( q.xzy, vec2(0.4,0.05) ) );\n    }\n    \n    // elongated torus\n    {\n    vec3 q = pos - vec3(3.0,0.0,1.0);\n    vec4 w = opElongate( q, vec3(0.2,0.0,0.3) );\n    d = min( d, w.w+sdTorus( w.xzy, vec2(0.4,0.05) ) );\n    }\n\n    return d;\n}\n\n\n\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat opUnion(float d1, float d2) {\n  return min(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1, d2);\n}\n\nfloat opSmoothIntersection(float d1, float d2, float k) {\n  float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSubtraction(float d1, float d2) {\n  return max(-d1, d2);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n  return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSubtraction2(float d1, float d2) {\n  return max(d1, -d2);\n}\n\nfloat opSmoothSubtraction2(float d1, float d2, float k) {\n  float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n  return mix( d1, -d2, h ) + k*h*(1.0-h);\n}\n/*\nfloat opSymX(vec3 p, float r, vec3 o)\n{\n  p.x = abs(p.x);\n  return sdSphere(p, r, o);\n}\n\nfloat opSymXZ(vec3 p, float r, vec3 o)\n{\n  p.xz = abs(p.xz);\n  return sdSphere(p, r, o);\n}\n\nfloat opRep(vec3 p, float r, vec3 o, vec3 c)\n{\n  vec3 q = mod(p+0.5*c,c)-0.5*c;\n  return sdSphere(q, r, o);\n}\n\nfloat opRepLim(vec3 p, float r, vec3 o, float c, vec3 l)\n{\n  vec3 q = p-c*clamp(round(p/c),-l,l);\n  return sdSphere(q, r, o);\n}\n\n*/\n\n\n\n\nvec2 grad( ivec2 z )  // replace this anything that returns a random vector\n{\n    // 2D to 1D  (feel free to replace by some other)\n    int n = z.x+z.y*11111;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n#if 0\n\n    // simple random vectors\n    return vec2(cos(float(n)),sin(float(n)));\n    \n#else\n\n    // Perlin style vectors\n    n &= 7;\n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n                              gr;\n#endif                              \n}\n\nfloat noise( in vec2 p )\n{\n    ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f); // feel free to replace by a quintic smoothstep instead\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n\nfloat grad_noise(vec2 uv, float scale) {\n    float f = 0.0;\n       \n    uv *= scale;\n        mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\t\tf  = 0.5000*noise( uv ); uv = m*uv;\n\t\tf += 0.2500*noise( uv ); uv = m*uv;\n\t\tf += 0.1250*noise( uv ); uv = m*uv;\n\t\tf += 0.0625*noise( uv ); uv = m*uv;\n\t\n\tf = 0.5 + 0.5*f;\n    \n    return f;\n}\n\n\n","name":"Common","description":"","type":"common"}]}