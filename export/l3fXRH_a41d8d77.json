{"ver":"0.1","info":{"id":"l3fXRH","date":"1709135426","viewed":43,"name":"Wireframe Pseudo Cube Fixture","username":"PG_TG","description":"Description","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["tag"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*-------------------------------\n  WIREFRAME PSEUDO CUBE FIXTURE\n-------------------------------*/\n\n#define PI 3.1415926535897932384626433832795\n\n// CIRCLE FUNCTION\nvec4 circle(vec2 uv, vec2 pos, float rad, vec3 col, bool edg, float smt) {\n    float value = distance(pos, uv);\n\n    if (edg) // Smooth edges mode\n        value = smoothstep(value, value + smt, rad);\n    else     // Hard edges mode\n        value = step(value, rad);\n    \n    return vec4(col, value);\n}\n\n// LINE FUNCTION\nvec4 line(vec2 uv, vec2 A, vec2 B, vec3 col, float thic, float blur) {\n    \n    vec2 g = B - A;\n    vec2 h = uv - A;\n    float d;\n    \n    d = length(h - g * clamp(dot(g, h) / dot(g, g), 0.0, 1.0));\n    if(blur != 0.)\n        if((blur * thic) >= thic)\n            d = smoothstep(blur * thic, thic, d);\n        else\n            d = smoothstep(thic, blur * thic * length(0.05), d);\n    else\n        d = step(thic, d);\n    \n    return vec4(col, d);\n}\n\n// CUBE FUNCTION\nvec4 cube(vec2 uv, vec2 pos, float rot, float width, float height, float tilt, float thic, vec3 col) {\n    vec4 background, foreground;\n    background = vec4(0.);\n    \n    for (int i = 0; i <= 3; i++) {\n        float j = float(i);\n        \n        foreground = line(\n            uv, \n            vec2(\n                pos.x + sin(rot + PI/2. * j) * width * 1.5,\n                pos.y + height - cos(rot + PI/2. * j) * tilt/45. * 100.\n            ), \n            vec2(\n                pos.x + sin(rot + PI/2. * j) * width * 1.5,\n                pos.y - height - cos(rot + PI/2. * j) * tilt/45. * 100.\n            ), \n            col,\n            thic/10.,\n            1.01\n        );\n        background = mix(background, foreground, foreground.a);\n        foreground = line(\n            uv, \n            vec2(\n                pos.x + sin(rot + PI/2. * j) * width * 1.5,\n                pos.y + height - cos(rot + PI/2. * j) * tilt/45. * 100.\n            ), \n            vec2(\n                pos.x + sin(rot + PI/2. * (j + 1.)) * width * 1.5,\n                pos.y + height - cos(rot + PI/2. * (j + 1.)) * tilt/45. * 100.\n            ), \n            col,\n            thic/10.,\n            1.01\n        );\n        background = mix(background, foreground, foreground.a);\n        foreground = line(\n            uv, \n            vec2(\n                pos.x + sin(rot + PI/2. * j) * width * 1.5,\n                pos.y - height - cos(rot + PI/2. * j) * tilt/45. * 100.\n            ), \n            vec2(\n                pos.x + sin(rot + PI/2. * (j + 1.)) * width * 1.5,\n                pos.y - height - cos(rot + PI/2. * (j + 1.)) * tilt/45. * 100.\n            ), \n            col,\n            thic/10.,\n            1.01\n        );\n        background = mix(background, foreground, foreground.a);\n    }\n    return background;\n}\n\n// ROTATION FUNCTION\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle), -sin(_angle),\n                sin(_angle), cos(_angle));\n}\n\n// SCALE FUNCTION\nmat2 scale(vec2 _scale) {\n    return mat2(_scale.x, 0.0, 0.0, _scale.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Aspect Ratio Fix\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // UV Scaling\n    uv = scale(vec2(sin(iTime/4.) + 3.0)) * uv;\n    uv *= rotate2d(sin(iTime * PI/4.)/5.);\n    \n    // Background Setup\n    vec4 background = vec4(0.);\n    vec4 foreground = circle(\n        uv,\n        vec2(0.),\n        8.,\n        vec3(1.),\n        true,\n        12.\n    );\n    background = mix(background, foreground, foreground.a);\n    \n    // Draw Cubes\n    background = mix(background, foreground, foreground.a);\n    foreground = cube(\n        uv,\n        vec2(0.),\n        iTime * 2.,\n        0.5,\n        0.5,\n        0.05,\n        0.15 / fract(iTime/8.),\n        vec3(0.)\n    );\n    background = mix(background, foreground, foreground.a);\n    foreground = cube(\n        uv,\n        vec2(0.),\n        iTime * 1.5,\n        1.0,\n        1.0,\n        0.1,\n        0.15 / fract((iTime + 1.)/8.),\n        vec3(0.)\n    );\n    background = mix(background, foreground, foreground.a);\n    foreground = cube(\n        uv,\n        vec2(0.),\n        iTime,\n        1.5,\n        1.5,\n        0.15,\n        0.15 / fract((iTime + 2.)/8.),\n        vec3(0.)\n    );\n    background = mix(background, foreground, foreground.a);\n    foreground = cube(\n        uv,\n        vec2(0.),\n        iTime * 0.5,\n        2.0,\n        2.0,\n        0.2,\n        0.15 / fract((iTime + 3.)/8.),\n        vec3(0.)\n    );\n    background = mix(background, foreground, foreground.a);\n    foreground = cube(\n        uv,\n        vec2(0.),\n        iTime * 0.25,\n        2.5,\n        2.5,\n        0.25,\n        0.15 / fract((iTime + 4.)/8.),\n        vec3(0.)\n    );\n    background = mix(background, foreground, foreground.a);\n\n    // Output To screen\n    fragColor = mix(background, foreground, foreground.a);\n}","name":"Image","description":"","type":"image"}]}