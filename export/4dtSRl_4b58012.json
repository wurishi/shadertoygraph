{"ver":"0.1","info":{"id":"4dtSRl","date":"1463657765","viewed":842,"name":"Oblivion Bubbleship HUD","username":"calx","description":"I went about recreating Joseph Chan's Bubbleship hud from Oblivion using distance transforms. The code's a total mess but the actual excersize in drawing with shaders was really interesting. http://www.josephychan.com/Oblivion","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["distancefield","ui","hud"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define QUARTER_PI 0.78539816339\n#define HALF_PI 1.57079632679\n#define TWO_PI 6.28318530718\n\nconst vec4 \tBLUE\t\t\t= vec4(0.306, 0.502, 0.537, 1.000);\nconst vec4 \tRED\t\t\t\t= vec4(0.941, 0.306, 0.208, 1.000);\nconst vec4 \tGREY_BLUE\t\t= vec4(0.494, 0.620, 0.663, 1.000);\nconst vec4 \tYELLOW\t\t\t= vec4(0.969, 1.000, 0.804, 1.000);\nconst vec4 \tGREEN\t\t\t= vec4(0.804, 1.000, 0.965, 1.000);\nconst vec4 \tGREY\t\t\t= vec4(0.449, 0.481, 0.489, 1.000);\nconst vec4 \tD_GREY\t\t\t= vec4(0.050, 0.050, 0.050, 1.000);\nconst vec4 \tM_GREY\t\t\t= vec4(0.200, 0.200, 0.200, 1.000);\nconst vec4 \tWHITE \t\t\t= vec4(1.000, 1.000, 1.000, 1.000);\nconst vec4 \tT_WHITE \t\t= vec4(1.000, 1.000, 1.000, 0.500);\nconst vec4 \tBLACK\t\t\t= vec4(0.000, 0.000, 0.000, 0.000);\nconst vec2 \tORIGIN \t\t\t= vec2(0.0);\nconst float LINE_WEIGHT \t= 0.0035;\nconst float METER_WEIGHT \t= 0.0100;\n\t  float SMOOTH\t\t\t= 0.0;\n\t  float R_SMOOTH\t\t= 0.2000;\n\nfloat map(float value, float istart, float istop, float ostart, float ostop) \n{\n    return ostart + (ostop - ostart) * ((value - istart) / (istop - istart));\n}\n\n\nfloat n_angleBetween(vec2 v1, vec2 v2)\n{\n    float angle = atan(v1.y-v2.y, v1.x-v2.x);\n    return ((angle < 0.0) ? (angle += TWO_PI) : angle) / TWO_PI;\n}\n\nvec2 rotate(vec2 v, float rotation)\n{\n\treturn vec2(cos(rotation)*v.x + sin(rotation)*v.y, -sin(rotation)*v.x + cos(rotation)*v.y);\n}\n\nfloat radialLine(vec2 r, float radius, float cutoff, float weight, bool flip)\n{\n    vec2  uv = rotate(r, -cutoff/2.0);\n    if(flip) uv = vec2(0.0)-uv;\n\tfloat d = distance(uv, ORIGIN);\n    float ir = \tradius;\n\tfloat or = \tir + weight;\n    float theta = n_angleBetween(uv, ORIGIN);\n    float s = theta * 180.0;\n    float line =  step(theta, cutoff/TWO_PI);\n\tfloat ring =  smoothstep(or+SMOOTH, or-SMOOTH, d) * (1.0 - smoothstep(ir+SMOOTH, ir-SMOOTH, d));\n    \n\treturn ring * line;;\n}\n\nfloat radialMeter(vec2 r, float radius, float cutoff, bool flip)\n{\n    vec2  uv = rotate(r, -cutoff/2.0);\n    if(flip) uv = vec2(0.0)-uv;\n\tfloat d = distance(uv, ORIGIN);\n    float ir = \tradius;  \n\tfloat or = \tir + METER_WEIGHT;   \n    float theta = n_angleBetween(uv, ORIGIN);\n    float s = theta * 200.0;\n    float grads = fract(s);    \n\tfloat steps = (1.0-smoothstep((0.4-R_SMOOTH), (0.41+R_SMOOTH), grads)) * smoothstep((0.2-R_SMOOTH),(0.21+R_SMOOTH), grads) ;\n    float line =  step(theta, cutoff/TWO_PI);\n\tfloat ring =  smoothstep(or+SMOOTH, or-SMOOTH, d) * (1.0 - smoothstep(ir+SMOOTH, ir-SMOOTH, d));\n\n    steps *= ring * line;\n        \n\treturn steps;\n}\n\nfloat dottedSect(vec2 r, float radius, float cutoff, float dotSize, bool flip, float num)\n{ \n    float a = num;\n    vec2  uv = rotate(r, -cutoff/2.0);\n    if(flip) uv = vec2(0.0)-uv;\n    float theta =  round(n_angleBetween(uv, vec2(0.0)) * (TWO_PI * a)) / a;\n    float x = radius * cos(theta);\n    float y = radius * sin(theta);\n    vec2  v = vec2(x, y);   \n \tfloat d = distance(uv, v);\n    float e = smoothstep(d-SMOOTH, d+SMOOTH, dotSize);\n    float line =  step(theta, cutoff);\n\n    return e*line;\n}\n\nfloat returnBracket(vec2 r, float radius, float cutoff, float weight, float vCut, bool flip)\n{\n    vec2 uv =  rotate(r, -cutoff/2.0);\n    if(flip) uv = vec2(0.0)-uv;\n\tfloat d = distance(uv, ORIGIN);\n    float ir = \tradius;\n\tfloat or = \tir + weight;\n    float theta = n_angleBetween(uv, ORIGIN);\n    float line =   step(theta, cutoff/TWO_PI);\n    float halfs =  (cutoff/TWO_PI) / 2.0;\n    float sec = step(halfs-(vCut/TWO_PI), theta) * (1.0-step(halfs+((vCut/TWO_PI)), theta));\n\tfloat ring = smoothstep(or+SMOOTH, or-SMOOTH, d) * (1.0 - smoothstep(ir+SMOOTH, ir-SMOOTH, d));\n  \n\treturn ring * (line - sec);\t\n}\n\nfloat solBracket(vec2 r, float radius, float weight, float cutoff, float cut, float retrn)\n{\n    vec2 uv =  r;\n\tfloat d = distance(uv, ORIGIN);\n    float ir = \tradius;\n\tfloat or = \tir + weight;\n  \tfloat ring =  smoothstep(ir-SMOOTH, ir+SMOOTH, d) * (1.0 - smoothstep(or-SMOOTH, or+SMOOTH, d));\n    float circ = step(radius+weight, d);\n\tfloat block = \tsmoothstep(uv.y-SMOOTH, uv.y+SMOOTH, cutoff) * (1.0 - smoothstep(uv.y-SMOOTH, uv.y+SMOOTH, -cutoff));\n    float topLine = smoothstep(uv.y-SMOOTH, uv.y+SMOOTH,  cutoff-weight);\n    float botLine = smoothstep(uv.y-SMOOTH, uv.y+SMOOTH, -(cutoff-(weight)));\n    \n\tfloat xblock = step(-retrn, uv.x) * (1.0-step(retrn, uv.x));\n    float yblock = step(-cut, uv.y) * (1.0-step(cut, uv.y));\n    \n    ring *= block;\n    topLine *= (1.0 - botLine);\n    block *= (1.0 - topLine);\n    ring += block;\n    ring *= 1.0-circ;\n    float blocks = (xblock+yblock);\n    \n\treturn ring * (1.0-(blocks));\t\n}\n\nfloat single(vec2 r, float radius, float weight)\n{\n    vec2  uv = r;\n\tfloat d = distance(uv, ORIGIN);\n    float ir = \tradius;\n\tfloat or = \tir + weight;\n\tfloat ring =  smoothstep(or+SMOOTH, or-SMOOTH, d) * (1.0 - smoothstep(ir+SMOOTH, ir-SMOOTH, d));\n    \n\treturn ring;\n}\n\nfloat splitLine(vec2 r, float w, float yOffset, float split, float weight) \n{\n    vec2 uv = r + vec2(0.0, yOffset);\n    float f = step(uv.x, w) * (1.0-step(w, -uv.x));\n    float l = step(uv.y, (weight/2.0)) * (1.0 - step(uv.y, -(weight/2.0)));\n    float g = step(uv.x, split) * (1.0-step(split, -uv.x));\n    \n    return f * l * (1.0-g);\n}\n\nfloat meter(vec2 r, float w, float yOffset, float inc, float weight, float num) \n{\n    vec2 uv = r - vec2(0.0, yOffset);\n    float f = step(uv.x, w) * (1.0-step(w, -uv.x));\n    float l = step(uv.y, (weight/2.0)) * (1.0 - step(uv.y, -(weight/2.0)));\n    float incr = fract(uv.x*num);\n    float gnn = (1.0-smoothstep((0.4-SMOOTH), (0.41+SMOOTH), incr)) * smoothstep((0.2-SMOOTH),(0.21+SMOOTH), incr);\n    f *= (gnn * l);   \n    \n    return f ;\n}\n\nfloat grid(vec2 r, float num, float weight)\n{\n    vec2 uv = r * num;\n    float gridx = smoothstep(weight - SMOOTH, weight + SMOOTH, fract(uv.x));\n    float gridy = smoothstep(weight - SMOOTH, weight + SMOOTH, fract(uv.y));\n    \n    return (1.0 - (gridx * gridy));\n}\n\nfloat dots(vec2 r, float num, float pointSize)\n{\n    vec2 uv = r * num;\n    vec2  v = vec2(round(uv.x),round(uv.y));   \n \tfloat d = distance(uv, v);\n    return smoothstep(d-SMOOTH, d+SMOOTH, pointSize);   \n}\n\nfloat bg(vec2 r, float w, float h)\n{\n    float f = 1.0 - step(w, distance(r, ORIGIN));\n    \n    float g = step(-h, r.y) * (1.0-step(h, r.y));\n    \n    f *= g;\n    \n\treturn 1.0-f;\n}\n\nfloat hash(float x)\n{\n    return fract(sin(x) * 43758.5453) * 2.0 - 1.0;\n}\n\nvec2 hashPosition(float x)\n{\n    return vec2(hash(x) * 64.0, hash(x * 1.1) * 64.0);\n}\n\nfloat sineOut(float t) \n{\n  return sin(t * HALF_PI);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    SMOOTH \t\t= map(iResolution.x, 800.0, 2560.0, 0.0025, 0.0010);\n\tvec2 uv =  2.0 * vec2(fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float rotation = - PI / 4.0;\n    rotation = 0.0;\n    uv = vec2(cos(rotation)*uv.x + sin(rotation)*uv.y, -sin(rotation)*uv.x + cos(rotation)*uv.y);\n    \n    vec2 q = fragCoord.xy / iResolution.xy;\n\t\n\tconst float sequenceDuration = 1.25;\n\tfloat currentSequence = floor(iTime / sequenceDuration);\n\tfloat currentSequenceTime = mod(iTime, sequenceDuration);\n\tvec2  startingPosition = hashPosition(currentSequence) * 0.005;\n\tvec2  goalPosition = hashPosition(currentSequence + 1.0) * 0.005;\n\tvec2  currentPosition;\n\tconst float speed = 0.5;\n\tfloat potentialDistance = speed * currentSequenceTime;\n\tfloat goalDistance = length(goalPosition - startingPosition);\n    \n\tif (potentialDistance < goalDistance) {\n\t\tcurrentPosition = mix(startingPosition, goalPosition, sineOut(potentialDistance / goalDistance));\n\t} else {\n\t\tcurrentPosition = goalPosition;\n\t}\n\t\n    vec2 targetPosition = uv-currentPosition;\n    \n    vec4 tex = texture(iChannel0, q) * 0.1; \n    \n    vec4 final  = mix(tex, \tBLACK, \tbg(uv, 1.4805, 0.500) * 0.50);      \n    \t final *= mix(tex, \tBLACK, \tbg(uv, 1.2805, 0.702) * 0.25); \n    \n    final = mix(final, \tWHITE\t, dots(uv, 20.0, 0.04) * 0.25);    \n    final = mix(final, \tWHITE\t, grid (uv, 10.0, 0.03) * 0.10);   \n    final = mix(final,  RED     , radialLine (targetPosition, 0.1092, QUARTER_PI, LINE_WEIGHT, false));    \n    final = mix(final,  RED     , radialLine (targetPosition, 0.1092, QUARTER_PI, LINE_WEIGHT, true)); \n    final = mix(final,  WHITE   , radialLine (targetPosition, 0.2777, QUARTER_PI, LINE_WEIGHT, false));    \n    final = mix(final,  WHITE   , radialLine (targetPosition, 0.2777, QUARTER_PI, LINE_WEIGHT, true));\n    final = mix(final,  BLUE    , splitLine  (targetPosition, 0.3000, 0.3300, 0.0160, 0.005));\n    final = mix(final,  WHITE   , splitLine  (targetPosition, 0.6231, 0.0000, 0.5324, LINE_WEIGHT));\n    final = mix(final,  RED     , dottedSect (targetPosition, 0.3490, HALF_PI  +(QUARTER_PI/4.0), 0.004, false, 12.40)); \n    final = mix(final,  RED     , dottedSect (targetPosition, 0.3490, HALF_PI  +(QUARTER_PI/4.0), 0.004, true, 12.40));  \n    final = mix(final,  GREY    , solBracket (targetPosition, 0.3490, LINE_WEIGHT, 0.3, 0.265, 0.000));\n   \tfinal = mix(final,  WHITE   , solBracket (targetPosition, 0.3777, LINE_WEIGHT, 0.05, 0.018, 0.3675));\n    final = mix(final,  WHITE   , radialMeter(targetPosition, 0.4138, QUARTER_PI, false));   \n    final = mix(final,  WHITE   , radialMeter(targetPosition, 0.4138, QUARTER_PI, true)); \n    final = mix(final,  GREY    , single     (targetPosition, 0.4527, LINE_WEIGHT));\n   \tfinal = mix(final, \tGREY_BLUE, splitLine  (targetPosition, 0.6231, 0.0, 0.5324, LINE_WEIGHT));    \n    final = mix(final, \tBLUE\t, solBracket (targetPosition, 0.5750, LINE_WEIGHT, 1.0, 0.2314, 0.0000));\n \tfinal = mix(final, \tWHITE\t, solBracket (uv, 1.4805, LINE_WEIGHT, 0.7000, 0.0592, 1.2900));\n    final = mix(final, \tBLUE\t, solBracket (uv, 1.3021, LINE_WEIGHT, 0.6685, 0.1592, 0.0000));\n    final = mix(final, \tGREY\t, solBracket (uv, 1.3021, LINE_WEIGHT, 0.7000, 0.6950, 0.0000));\n    final = mix(final, \tBLUE\t, solBracket (uv, 1.2574, LINE_WEIGHT, 0.5174, 0.0000, 0.8551));\n    final = mix(final, \tBLUE\t, solBracket (uv, 1.2574, LINE_WEIGHT, 0.5374, 0.5300, 0.8551));\n    final = mix(final, \tBLUE\t, solBracket (uv, 1.2574, LINE_WEIGHT, 0.6390, 0.6300, 0.8551));\n    final = mix(final, \tWHITE\t, dottedSect (uv, 1.2800, 0.8324, 0.003, false, 112.40));\n    final = mix(final, \tWHITE\t, dottedSect (uv, 1.2800, 0.8324, 0.003, true, 112.40));\n    final = mix(final, \tGREY\t, meter\t\t (uv, 0.8500, 0.6390, 0.9324, 0.010, 50.0));\n    \n\n    fragColor = final;\n} ","name":"Image","description":"","type":"image"}]}