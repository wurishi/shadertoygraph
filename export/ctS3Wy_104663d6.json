{"ver":"0.1","info":{"id":"ctS3Wy","date":"1673814302","viewed":85,"name":"Minecraft grassblock test","username":"ianertson","description":"Just a Minecraft block test","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","rays","minecraft","block","grassblock"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float noise(vec2 uv) { return texture(iChannel0, uv).r; }\n\nvec3 grass(vec2 uv) {\n    uv /= 2.6;\n    vec3 color = vec3(0.28, 0.55, 0.09);\n    vec3 noise = vec3(noise(uv*2.0));\n    return color * (0.5 + noise);\n}\n\nvec3 dirt(vec2 uv) {\n    uv /= 2.6;\n    vec3 color = vec3(0.333, 0.247, 0.137);\n    vec3 noise = vec3(noise(uv*2.0));\n    return color * (0.5 + noise);\n}\n\nvec3 shade(vec2 uv, vec3 normal) {\n    vec3 g = grass(uv);\n    if (dot(normal, vec3(0.0, 1.0, 0.0)) > 0.5) return g;\n    float n = noise(uv*0.5);\n    float s = smoothstep(0.0, 1.0, max(0.0, pow(0.9-(uv.y*2.0-(n*0.8)), 2.0)));\n    return mix(g, dirt(uv), s);\n}\n\nvec3 getBackground(vec3 origin, vec3 dir) { return texture(iChannel1, camera(origin, dir) * vec3(0.0, 0.0, -1.0)).rgb;}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    \n    Ray ray = getPrimaryRay(\n        (vec3(cos(iTime))*0.5)+vec3(0.0, 0.0, -4.0),           // origin\n        fc,                                                    // fragCoord\n        iResolution.xy,                                        // resolution\n        (vec3(sin(iTime+3.0))*0.1) + vec3(0.0, 0.0, -1.0),     // look\n        60.0,                                                  // fov\n        0.1,                                                   // near\n        400.0                                                  // far\n    );\n    \n    vec3 lightPos = vec3(0.3, 4.0, -0.5);\n    vec3 lightColor = vec3(0.8, 0.5, 0.5);\n    float lightStrength = 16.0;\n    float depth = ray.far;\n    bool hit = false;\n\n    if (rayAABBIntersection(\n        ray,\n        makeBox(\n            vec3(-0.5, -0.5, -1.5),                       // position\n            vec3(1.0, 1.0, 1.0),                          // size\n            vec4(-0.001, 1.0, 0.0, iTime)                    // rotation\n        )\n    )) {\n        hit = false;\n        vec3 albedo = shade(ray.result.uv, ray.result.normal);\n        vec3 L = normalize(ray.result.point - lightPos);\n        \n        float NdotL = dot(ray.result.normal, L);\n        float dist = abs(distance(ray.result.point, lightPos));\n        float att = 0.001+max(0.1, (pow(lightStrength, 2.0) / max(0.0001, pow(dist, 2.0))) * NdotL);\n        col = (albedo / M_PI) * lightColor * att;\n        depth = ray.result.dist;\n    }\n    \n    depth /= ray.far;\n    vec3 bg = getBackground(ray.origin, ray.dir);\n    float mag = length(col)+float(hit);\n    float imag = max(0.0, 1.0 - (mag*ray.far));\n    col = mix(col, bg, smoothstep(0.0, 1.0, imag));\n    col += depth*0.01;\n    col += (col*luma(col))*1.45;\n    col = mix(reinhard2(col), aces(col), 0.59);\n\n    fragColor = vec4(pow(col, vec3(1.0 / 1.9)),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float M_PI = 3.14159265359;\n\nstruct Box {\n  vec3 pos;\n  vec3 size;\n  vec4 rotation;\n};\n\nvec3 getBoxCenter(in Box box) {\n  vec3 boxMin = box.pos;\n  vec3 boxMax = boxMin+box.size;\n  vec3 center = (boxMin+boxMax)*0.5;\n  center -= box.pos;\n  center *= -1.0;\n  return center;\n}\n\nBox makeBox(vec3 pos, vec3 size, vec4 rotation) { return Box(pos, size, rotation); }\n\nvec2 rot2D(vec2 p, float angle) {\n  angle = radians(angle);\n  float s = sin(angle);\n  float c = cos(angle);\n  return p * mat2(c, s, -s, c);\n}\n\nmat4 rotationX(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat4(vec4(1, 0, 0, 0), vec4(0, c, -s, 0), vec4(0, s, c, 0),\n              vec4(0, 0, 0, 1));\n}\n\nmat4 rotationY(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat4(vec4(c, 0, s, 0), vec4(0, 1, 0, 0), vec4(-s, 0, c, 0),\n              vec4(0, 0, 0, 1));\n}\n\nmat4 rotationZ(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat4(vec4(c, -s, 0, 0), vec4(s, c, 0, 0), vec4(0, 0, 1, 0),\n              vec4(0, 0, 0, 1));\n}\n\nvec3 rotate3D(vec3 vertex, vec3 center, vec3 axis, float angle, bool inv, out mat4 matrix) {\n  matrix = (rotationX(angle * axis.x) * rotationY(angle * axis.y) * rotationZ(angle * axis.z));\n  matrix = inv ? inverse(matrix) : matrix;\n  return (matrix * vec4(vertex - center, 1.0)).xyz + center;\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = lookAtPoint;\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nmat4 proj(float fovy, float aspect, float nearZ, float farZ) {\n\n  mat4 dest = mat4(0.0);\n  float f = 1.0f / tan(fovy * 0.5f);\n  float fn = 1.0f / (nearZ - farZ);\n\n  dest[0][0] = f / aspect;\n  dest[1][1] = f;\n  dest[2][2] = -farZ * fn;\n  dest[2][3] = 1.0f;\n  dest[3][2] = nearZ * farZ * fn;\n  return dest;\n}\n\nmat4 look(vec3 eye, vec3 center, vec3 up) {\n  mat4 dest = mat4(0.0);\n  vec3 f = vec3(0.0);\n  vec3 u = vec3(0.0);\n  vec3 s = vec3(0.0);\n\n  f = normalize(center - eye);\n\n  s = cross(up, f);\n  u = cross(f, s);\n\n  dest[0][0] = s[0];\n  dest[0][1] = u[0];\n  dest[0][2] = f[0];\n  dest[1][0] = s[1];\n  dest[1][1] = u[1];\n  dest[1][2] = f[1];\n  dest[2][0] = s[2];\n  dest[2][1] = u[2];\n  dest[2][2] = f[2];\n  dest[3][0] = -dot(s, eye);\n  dest[3][1] = -dot(u, eye);\n  dest[3][2] = -dot(f, eye);\n  dest[0][3] = dest[1][3] = dest[2][3] = 0.0f;\n  dest[3][3] = 1.0f;\n\n  return dest;\n}\n\nstruct RayResult {\n  vec3 normal;\n  vec3 point;\n  vec2 uv;\n  float dist;\n  vec3 color;\n  float id;\n  int iid;\n};\n\nstruct Ray {\n  vec3 origin;\n  vec3 dir;\n  float near;\n  float far;\n  int skip_id;\n  bool is_any;\n  RayResult result;\n};\n\nRay getPrimaryRay(vec3 origin, vec2 coord, vec2 res, vec3 lookDir, float fov,\n                  float near, float far) {\n  Ray ray;\n  ray.near = near;\n  ray.far = far;\n  ray.skip_id = -1;\n  ray.origin = origin;\n  ray.dir = normalize((inverse(proj(radians(fov), res.x / res.y, near, far) *\n                               look(lookDir, vec3(0.0), vec3(0, 1, 0))) *\n                       vec4(vec2(((coord.x - res.x / 2.0)) / res.x,\n                                 ((coord.y - res.y / 2.0)) / res.y) /\n                                0.5,\n                            1.0, 1.0))\n                          .xyz);\n  return ray;\n}\n\nvec3 cubenormal(vec3 v) {\n  vec3 s = sign(v);\n  vec3 a = abs(v);\n  return mix(mix(vec3(0.0, 0.0, s.z), vec3(s.x, 0.0, 0.0), step(a.z, a.x)),\n             mix(vec3(0.0, s.y, 0.0), vec3(s.x, 0.0, 0.0), step(a.y, a.x)),\n             step(a.z, a.y));\n}\n\nbool rayAABBIntersection(inout Ray ray, in Box box) {\n  box.rotation.xyz = normalize(box.rotation.xyz);\n  vec3 boundsMin = min(box.pos, box.pos+box.size);\n  vec3 boundsMax = max(box.pos, box.pos+box.size);\n  vec3 rayDir = ray.dir;\n  vec3 rayOrigin = ray.origin;\n  \n  vec3 center = getBoxCenter(box);\n  mat4 matrix = mat4(1.);\n  \n  vec3 pos = box.pos;\n\n  pos = rotate3D(box.pos, center, box.rotation.xyz, box.rotation.w, false, matrix);\n  boundsMin = pos;\n  boundsMax = boundsMin+box.size;\n  rayDir = (matrix * vec4(ray.dir, 0.0)).xyz;\n  rayOrigin = (matrix * vec4(ray.origin, 1.0)).xyz;\n  center = (boundsMin + boundsMax) / 2.0;\n  \n  \n  vec3 tMin = (boundsMin - rayOrigin) / rayDir;\n  vec3 tMax = (boundsMax - rayOrigin) / rayDir;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  float tClosest = tFar;\n  \n  \n  box.rotation = normalize(box.rotation);\n  \n\n  if ((tNear < tFar && tNear > ray.near)) {\n    tClosest = tNear;\n    ray.result.point = rayOrigin + rayDir * tNear;\n    ray.result.dist = abs(distance(rayOrigin, ray.result.point));\n    vec3 halfextent = boundsMax - center;\n    vec3 relpos = ray.result.point - center;\n    vec2 bounds = boundsMax.xy - boundsMin.xy;\n    vec3 uv3 = relpos.xyz / (boundsMax - boundsMin);\n    ray.result.normal = normalize(cubenormal(relpos / (halfextent)));\n\n    vec3 n = ray.result.normal;\n\n    if (n.y > 0. || n.y < 0.) {\n      ray.result.uv = vec2(uv3.x, uv3.z-1.0);\n    } else if (n.x < 0. || n.x > 0.) {\n      ray.result.uv = vec2(uv3.z, uv3.y);\n    } else {\n      ray.result.uv = vec2(uv3.x, uv3.y);\n    }\n    \n    ray.result.point = rotate3D(\n        ray.result.point, vec3(0.0), box.rotation.xyz, box.rotation.w, true, matrix);\n        \n    ray.result.normal = rotate3D(\n        ray.result.normal, vec3(0.0), box.rotation.xyz, box.rotation.w, true, matrix);\n        \n    ray.result.normal = normalize(ray.result.normal);\n    ray.result.normal.y *= -1.0;\n      \n  }\n  \n  \n\n  return tClosest != tFar;\n}\n\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\nvec3 reinhard2(vec3 x) {\n  const float L_white = 4.0;\n  return (x * (1.0 + x / (L_white * L_white))) / (1.0 + x);\n}\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}","name":"Common","description":"","type":"common"}]}