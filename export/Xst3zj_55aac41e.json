{"ver":"0.1","info":{"id":"Xst3zj","date":"1450933958","viewed":416,"name":"Fast SSAA + Outlining test","username":"pyrite","description":"Thanks iq for the SSAA code from your spherical harmonics demo.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["ssaa"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Austin Kootz - pyrite/2015\n// SSAA implentation created by iq/2013. (Many thanks!)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// Four spheres colored by surface location. For\n// reference and fun.\n\n\n\n// antialias level (try 1, 2, 3, ...)\n#define AA 2\n\n\nfloat sphere(in vec3 ro, in vec3 sp, in float sr){\n    return length(ro-sp)-sr;\n}\n\nfloat elipse(in vec3 ro, in vec3 e1, in vec3 e2, in float er){\n    return (length(ro-e1)+length(ro-e2))/2.0 - (er+1.0)*length(e1-e2)/2.0;\n}\n\nfloat map(in vec3 ro){\n    \n    return min(sphere(ro, vec3(0.0,0.0,0.0),1.0+0.5*sin(3.0*iTime)),\n               min(sphere(ro,vec3(-2,0.0,0.0),1.0), \n                   min(sphere(ro,vec3(0.0,-2,0.0),1.0),\n                       sphere(ro,vec3(0.0,0.0,-2),1.0)\n                      )\n                  )\n              );\n}\n\nvec3 scene(in vec3 ro,in vec3 rd){\n    vec3 col = vec3(0);\t\t// initialize color return value\n    float rv = map(ro);\t\t//ray value\n    float rm = rv; \t\t\t//tracker for minimum ray value\n    float ow = 0.1; \t\t//outline width\n    for (int s =0; s<100; s++){\n       \trm = min(rv,rm);\n       \tro += rd*rv*0.9;\n        rv = max(map(ro),0.009);\n        if (rv<0.01){\n            float edge = map(ro);\n            //color based on suface location\n            col = vec3(ro.x,ro.y,ro.z)*0.25;\n            break;\n        }\n        //check if a ray has passed through an outline region\n        if (rv>rm && rm<ow){\n            break;\n        }\n    }\n    if (rm < ow && rm<rv){\n    col += 0.0;\n    } else {\n        col += 0.9;\n    }\n\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    // camera\n    float an = 0.5*iTime - 5.0*iMouse.x/iResolution.x;\n    vec3  ro = vec3(6.0*sin(3.0*an),6.0*cos(an),6.0*cos(an));\n    vec3  ta = vec3(0.0,0.0,0.0);\n\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {   \n        //create p for ray based on AA settings\n        vec3 p = vec3((-iResolution.xy + 2.0*(fragCoord.xy-0.5+(vec2(float(m),float(n))+0.5)/float(AA))) / iResolution.y,2.0);\n    \t\n        \n        //create view ray from vector p\n        vec3 rd = normalize( p.x*uu + p.y*vv + p.z*ww );\n        \n        //render scene\n        vec3 col = scene(ro,rd);\n        \n        //vignette\n        col -= 0.2*length(p.xy);\n        \n        tot += col;\n    }\n    tot /= float(AA*AA);\n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}