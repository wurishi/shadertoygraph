{"ver":"0.1","info":{"id":"fl3GW7","date":"1636182778","viewed":395,"name":"Dynamic system plotter","username":"Envy24","description":"new version:                            https://www.shadertoy.com/view/ddB3R1\nexplanation:                             https://www.youtube.com/watch?v=fDSIRXmnVvk&t=39s\nstandalone version (sfml, c++): https://github.com/HackerPoet/Chaos-Equations","likes":28,"published":1,"flags":32,"usePreview":0,"tags":["chaos","dynamic","plotter","system","attractors"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// New version: https://www.shadertoy.com/view/ddB3R1\n#define R iResolution\n\n#define BLACK  vec4(0.0)\n#define WHITE  vec4(1.0)\n#define COLOR1 vec4(0.07, 0.91, 0.95, 1.0)\n#define COLOR2 vec4(0.9,  0.5,  0.2,  1.0)\n#define COLOR3 vec4(0.8,  0.5,  0.1,  1.0)\n\nvoid mainImage( out vec4 O, in vec2 P ) \n{ \n    /* Colored *\n    vec4 fragment_color = COLOR1 - texture(iChannel0, P/iResolution.xy);\n    vec4 background_color = BLACK;   \n    //O = fragment_color;\n    O = fragment_color.w < 0.0 ? background_color : fragment_color;  \n    /* Colored */\n    \n    /* Grayscaled */\n    O = texture(iChannel0, P/R.xy);\n    /* Grayscaled */\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"struct sceneParameters\n{\n    /* Scene. */\n    float scale;\n    bool use_intensity;         /* If true, then samples look smaller, but plot looks more detailed. */\n    \n    /* Trail */\n    float color_recover_amount; /* Lower amount - darker plot */\n    float fade_out;             /* Lower value - longer fade_out. */\n    \n    /* Plot. */\n    vec2 offset;\n    float minT;                 /* Minimum range constraint. */\n    float maxT;                 /* Maximum range constraint. */\n    float speed;                /* Oscillation speed */\n    \n    /* Samples. */\n    float radius;\n    float smoothness;\n    int count;\n    \n    /* Parameters for x equation.\n    \n       Simple brief:\n        If xx0 =  1.0 then term xx in equasion is positive;\n        If xx0 =  0.0 then term xx in equasion is off;\n        If xx0 = -1.0 then term xx in equasion is negative.\n        \n       Parameters can be any real numbers and you can expand equations\n       for more terms xxx, xxxx, etc...\n    */\n    float xx0;\n    float xy0;\n    float yy0;\n    float yt0;\n    float tt0;\n    float tx0;\n    float x0;\n    float y0;\n    float t0;\n    \n    /* Parameters for y equation. */\n    float xx1;\n    float xy1;\n    float yy1;\n    float yt1;\n    float tt1;\n    float tx1;\n    float x1;\n    float y1;\n    float t1;\n};\n\nvoid initForSystem0(inout sceneParameters desc, in bool use_intensity)\n{\n    desc.scale = 1.0;                 desc.use_intensity = use_intensity;\n    desc.color_recover_amount = 0.01; desc.fade_out = 2.2;\n    //desc.offset = vec2(0.6, -0.48);    desc.minT = 0.36;     desc.maxT = 0.472;       desc.speed = 0.7;\n    desc.offset = vec2(0.6, -0.48);   desc.minT = 0.46;     desc.maxT = 0.472;        desc.speed = 0.07;   \n    desc.count = 2000;                desc.radius = 0.0035; desc.smoothness = 0.011; \n      \n    // Equation: newX = x*x + y*t - t*x - x\n    desc.xx0 = 1.0; desc.xy0 = 0.0; desc.yy0 = 0.0; \n    desc.yt0 = 1.0; desc.tt0 = 0.0; desc.tx0 = -1.0; \n    desc.x0 = -1.0; desc.y0 = 0.0;  desc.t0 = 0.0;\n    \n    // Equation: newY = -x*y - y*y - y*t - t*t - t*x - y\n    desc.xx1 = 0.0;  desc.xy1 = -1.0; desc.yy1 = -1.0;  \n    desc.yt1 = -1.0; desc.tt1 = -1.0; desc.tx1 = -1.0;   \n    desc.x1 = 0.0;   desc.y1 = -1.0;  desc.t1 = 0.0;   \n}\n\nvoid initForSystem1(inout sceneParameters desc, in bool use_intensity)\n{\n    desc.scale = 0.8;                 desc.use_intensity = use_intensity;\n    desc.color_recover_amount = 0.04; desc.fade_out = 0.8;    \n    desc.offset = vec2(0.0, -0.1);    desc.minT = -0.137;   desc.maxT = -0.05;       desc.speed = 0.2;    \n    desc.count = 1000;                desc.radius = 0.0095; desc.smoothness = 0.02; \n    \n    // Equation: newX = -x*x + x*y + y*y - y*t - t*t + t*x - x - y - t\n    desc.xx0 = -1.0; desc.xy0 = 1.0;  desc.yy0 = 1.0;\n    desc.yt0 = -1.0; desc.tt0 = -1.0; desc.tx0 = 1.0;   \n    desc.x0 = -1.0;  desc.y0 = -1.0;  desc.t0 = -1.0;    \n    \n    // Equation: newY = -x*x - x*y + y*y + y*t + t*t - t*x + t\n    desc.xx1 = -1.0; desc.xy1 = -1.0; desc.yy1 = 1.0;  \n    desc.yt1 = 1.0;  desc.tt1 = 1.0;  desc.tx1 = -1.0; \n    desc.x1 = 0.0;   desc.y1 = 0.0;   desc.t1 = 1.0;  \n}\n\nvoid initForSystem2(inout sceneParameters desc, in bool use_intensity)\n{\n    desc.scale = 1.4;                 desc.use_intensity = use_intensity;\n    desc.color_recover_amount = 0.05; desc.fade_out = 0.8;    \n    desc.offset = vec2(-0.20, 0.55);  desc.minT = -0.529;   desc.maxT = -0.49;       desc.speed = 0.187;    \n    desc.count = 1500;                desc.radius = 0.0095; desc.smoothness = 0.015; \n    \n    // Equation: newX = -x*x - y*y - t*t + t*x + y - t\n    desc.xx0 = -1.0; desc.xy0 = 0.0;  desc.yy0 = -1.0;\n    desc.yt0 = 0.0;  desc.tt0 = -1.0; desc.tx0 = 1.0;   \n    desc.x0 = 0.0;   desc.y0 = 1.0;   desc.t0 = -1.0;    \n    \n    // Equation: newY = x*x - x*y - y*t - t*t\n    desc.xx1 = 1.0; desc.xy1 = -1.0;  desc.yy1 = 0.0;  \n    desc.yt1 = -1.0; desc.tt1 = -1.0; desc.tx1 = 0.0; \n    desc.x1 = 0.0; desc.y1 = 0.0;     desc.t1 = 0.0;\n}\n\nvoid initForSystem3(inout sceneParameters desc, in bool use_intensity)\n{\n    desc.scale = 0.9;                 desc.use_intensity = use_intensity;\n    desc.color_recover_amount = 0.09; desc.fade_out = 0.4;    \n    desc.offset = vec2(0.6, 0.16);    desc.minT = 0.330;    desc.maxT = 0.380;       desc.speed = 0.487;    \n    desc.count = 1500;                desc.radius = 0.0055; desc.smoothness = 0.009; \n    \n    // Equation: newX = -x*x + t*t + t*x + x - y + t\n    desc.xx0 = -1.0; desc.xy0 = 0.0; desc.yy0 = 0.0;\n    desc.yt0 = 0.0;  desc.tt0 = 1.0; desc.tx0 = 1.0;   \n    desc.x0 = 1.0;   desc.y0 = -1.0; desc.t0 = 1.0;    \n    \n    // Equation: newY = -y*y - y*t + t*x + x - y\n    desc.xx1 = 0.0;  desc.xy1 = 0.0; desc.yy1 = -1.0;  \n    desc.yt1 = -1.0; desc.tt1 = 0.0; desc.tx1 = 1.0; \n    desc.x1 = 1.0;   desc.y1 = -1.0; desc.t1 = 0.0;\n}\n\nvoid initForSystem4(inout sceneParameters desc, in bool use_intensity)\n{\n    desc.scale = 0.9;                 desc.use_intensity = use_intensity;\n    desc.color_recover_amount = 0.08; desc.fade_out = 0.45;    \n    desc.offset = vec2(0.2, 0.26);    desc.minT = -0.410;    desc.maxT = -0.2851;       desc.speed = 0.287;    \n    desc.count = 1500;                desc.radius = 0.0035; desc.smoothness = 0.009; \n    \n    // Equation: newX = -y*t - t*x + y\n    desc.xx0 = 0.0;  desc.xy0 = 0.0; desc.yy0 = 0.0;\n    desc.yt0 = -1.0; desc.tt0 = 0.0; desc.tx0 = -1.0;   \n    desc.x0 = 0.0;   desc.y0 = 1.0;  desc.t0 = 0.0;    \n    \n    // Equation: newY = x*x - t*x - x + t\n    desc.xx1 = 1.0; desc.xy1 = 0.0; desc.yy1 = 0.0;  \n    desc.yt1 = 0.0; desc.tt1 = 0.0; desc.tx1 = -1.0; \n    desc.x1 = -1.0; desc.y1 = 0.0;  desc.t1 = 1.0;\n}\n\nvoid initForSystem5(inout sceneParameters desc, in bool use_intensity)\n{\n    desc.scale = 1.1;                 desc.use_intensity = use_intensity;\n    desc.color_recover_amount = 0.02; desc.fade_out = 0.35;    \n    desc.offset = vec2(-0.1, 0.05);   desc.minT = -0.200;    desc.maxT = 0.025;       desc.speed = 0.05;    \n    desc.count = 1500;                desc.radius = 0.0035; desc.smoothness = 0.01; \n    \n    // Equation: newX = -x*x + x*y - y*y + y*t - t*x - x + y + t\n    desc.xx0 = -1.0;  desc.xy0 = 1.0; desc.yy0 = -1.0;\n    desc.yt0 = 1.0;   desc.tt0 = 0.0; desc.tx0 = -1.0;   \n    desc.x0 = -1.0;   desc.y0 = 1.0;  desc.t0 = 1.0;    \n    \n    // Equation: newY = -x*x + t*t - t*x - x - y\n    desc.xx1 = -1.0; desc.xy1 = 0.0; desc.yy1 = 0.0;  \n    desc.yt1 = 0.0;  desc.tt1 = 1.0; desc.tx1 = -1.0; \n    desc.x1 = -1.0;  desc.y1 = -1.0; desc.t1 = 0.0;\n}\n\n/* Returns sine modulated value in range [min, max]. */\nfloat oscillateInRange(float min, float max, float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nfloat circleSDF(vec2 S, vec2 C,float r, float smoothness)\n{\n    // Sample coordinates relative to circle center.\n    float _x = S.x - C.x; float _y = S.y - C.y;\n    \n    // Signed distance.\n    float sd = sqrt(_x * _x + _y *_y) - r;\n     \n    // Smoothstep interpolation.\n    return smoothstep(-smoothness, smoothness, sd);\n    //return smoothstep(-smoothness, smoothness, sd * sd); // outline\n}\n\n/* Signed distance of squared distances. \n   Should work faster without calculation square root. */\nfloat circleSDFSQ(vec2 S, vec2 C,float r, float smoothness)\n{\n    // Sample coordinates relative to circle center.\n    float _x = S.x - C.x; float _y = S.y - C.y;\n    \n    // Signed distance of squares.\n    float sds = _x * _x + _y *_y - r * r;\n    \n    float ss = smoothness * smoothness;\n    \n    // Smoothstep interpolation.\n    return smoothstep(-ss, ss, sds);\n    //return smoothstep(-ss, ss, sds * sds); // outline\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define R iResolution\n#define center(P) ( (P+P-R.xy)/R.y )\n#define MX (iMouse.x / iResolution.x)\n#define MY (iMouse.y / iResolution.y)\n#define LMB_IS_HOLD (iMouse.z > 0.0)\n\nfloat scene(\n    in vec2 P,\n    float T,\n    sceneParameters desc)\n{\n    // Translate and scale center for better view.\n    P += desc.offset;\n\n    float t = LMB_IS_HOLD == false ? \n        T :                       // Fixed initialization.\n        (MX * 6.0 - 3.0) * 0.5;   // Interactive initialization.\n    \n    /* Initialize first sample coordinates and \n       minimal distance from test fragment to samples. */\n    float x = T, y = T;\n    float minDistance = 9.;\n\n    // Iteratively evaluate dynamic system.\n    for (int idx = 0; idx < desc.count; ++idx)\n    {\n        float xx = x*x, xy = x*y, yy = y*y;\n        float yt = y*t, tt = t*t, tx = t*x;\n        \n        // Save new coordinates for next iteration.\n        float x_ = \n            desc.xx0 * xx + desc.xy0 * xy + desc.yy0 * yy + \n            desc.yt0 * yt + desc.tt0 * tt + desc.tx0 * tx +\n            desc.x0 * x   + desc.y0 * y   + desc.t0 * t;\n    \n        y = \n            desc.xx1 * xx + desc.xy1 * xy + desc.yy1 * yy + \n            desc.yt1 * yt + desc.tt1 * tt + desc.tx1 * tx +\n            desc.x1 * x   + desc.y1  * y  + desc.t1 * t;\n            \n        x = x_;\n            \n        // Find closest sample.  \n        minDistance = min(circleSDFSQ(P, vec2(x, y), desc.radius, desc.smoothness), minDistance);       \n        //minDistance = min(circleSDF(P, vec2(x, y), desc.radius, desc.smoothness), minDistance); \n    }    \n\n    return minDistance;\n}\n\nvoid mainImage( out vec4 O, in vec2 P )\n{\n    sceneParameters desc;\n    \n    /* Examples. */\n    initForSystem0(desc, true);\n    //initForSystem1(desc, false);\n    //initForSystem2(desc, false);\n    //initForSystem3(desc, false);\n    //initForSystem4(desc, false);\n    //initForSystem5(desc, false);\n\n    vec2 uv = center(P) * desc.scale;\n   \n    // Recover color.\n    float recover_amount = desc.color_recover_amount * desc.fade_out;\n    vec4 color = texture(iChannel0, P/R.xy) + vec4(recover_amount);\n \n    // Pick intensity.\n    float intensity = desc.use_intensity == true ? color.x : 1.0;\n\n    if (LMB_IS_HOLD == false) \n    { \n        /* Static scene. */\n        color *= // Attenuate color.\n            scene(\n                uv,\n                oscillateInRange(\n                    desc.minT,\n                    desc.maxT,\n                    iTime * desc.speed * intensity), \n                desc); \n    }\n    else \n    { \n        /* Interactive scene for exploring. */\n        color *= \n            scene(\n                uv, \n                oscillateInRange(\n                    0.0, \n                    0.1, \n                    iTime * 10.1 * MY * intensity),\n                desc); \n    }\n    \n    O = color;\n}","name":"Buffer A","description":"","type":"buffer"}]}