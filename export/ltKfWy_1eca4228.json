{"ver":"0.1","info":{"id":"ltKfWy","date":"1610360773","viewed":93,"name":"Mandlebrot-TG","username":"tobySixx","description":"-","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int MAX_STEPS = 100;\nstruct Light\n{\n    vec3 pos;\n    float intensity;\n};\n\nLight light = Light(vec3(-3, 5, -2), 1.25);\nLight light2 = Light(vec3(0, 5, 0), 0.2);\n\nfloat sphere(vec3 p)\n{\n\treturn length(p) - 1.0;\n}\n\nfloat mandelbrot(vec3 p, out float dr)\n{\n    // f(n) = z2 + c\n    vec2 res = p.xy;\n    \n    float n = 0.0;\n    while(n < 100.0)\n    {\n        // x2 + -y + 2xyi +  \n        float real = res.x;\n        float im = res.y;\n        res.x = real * real - im * im;\n        res.y = 2.0 * real * im;\n        \n        res += p.xy;\n        \n        if(length(res) > 2.0)\n        {\n        \tbreak;\n        }\n        n++;\n    }\n    dr = length(res);\n    return n;\n}\n\n/*\nfloat distanceFunction(vec3 p)\n{\n    float dr;\n    float r = mandelbrot(p, dr);\n    return 0.5 * log(r) * r / dr; \n}\n*/\n\nfloat distanceFunction(vec3 pos) {\n    \n    int Iterations = 100;\n    float Bailout = 2.0;\n    float Power = 8.0;\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < Iterations ; i++) \n    {\n\t\tr = length(z);\n\t\tif (r>Bailout) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\nfloat phong(vec3 normal)\n{\n    float ambient = 0.2;\n    vec3 lightDirection = normalize(-light.pos);\n    float diffuse;\n    float nDotl = dot(normal, lightDirection);\n    if (nDotl > 0.0)\n    {\n        diffuse = 0.2 * nDotl * light.intensity;\n    }\n\n    lightDirection = normalize(-light2.pos);\n    nDotl = dot(normal, lightDirection);\n    if(nDotl > 0.0)\n    {\n        diffuse += 0.2 * nDotl * light2.intensity;\n    }\n     \n    return diffuse;\n}\n\nfloat shadow(vec3 ro, vec3 rd, float mint, float maxt, float k)\n{\n    float res = 1.0;\n    for(float t=mint; t < maxt;)\n    {\n\t\tfloat h = distanceFunction(ro + rd * t);\n        if(h<0.001)\n        {\n            return 0.0;\n        }\n        res = min(res, k*h/t);\n        t += h;\n    }\n    return res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n   \tfloat mouse = iMouse.x / iResolution.x;\n\t\n    float zoom = 1.5;\n    vec3 cameraPosition = vec3(sin(mouse)*zoom, 0.0, cos(mouse)*zoom);\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n    vec3 cameraDirection = normalize(cameraTarget - cameraPosition);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 cameraRight = normalize(cross(up, cameraPosition));\n    vec3 cameraUp = cross(cameraDirection, cameraRight);\n\n    vec3 col = vec3(0.16, 0.20, 0.28);\n    \n    vec3 normal = vec3(0.0);\n    \n    vec3 rayPosition = cameraPosition;\n    vec3 rayDirection = normalize(cameraRight * uv.x + cameraUp * uv.y + cameraDirection);\n    \n    float rayDistance = 0.001;\n    for(int i=0; i<MAX_STEPS; i++)\n    {\n\t\tif (rayDistance < 0.001)\n        {\n            normal = normalize(vec3(distanceFunction(rayPosition+vec3(0.001, 0.0, 0.0)) - distanceFunction(rayPosition-vec3(0.001, 0.0, 0.0)), \n                                    distanceFunction(rayPosition+vec3(0.0, 0.001, 0.0)) - distanceFunction(rayPosition-vec3(0.0, 0.001, 0.0)),\n                                    distanceFunction(rayPosition+vec3(0.0, 0.0, 0.001)) - distanceFunction(rayPosition-vec3(0.0, 0.0, 0.001))));\n            \n            // Material\n            vec3 mat = vec3(0.2);\n\n            // Lighting \n            float sha = shadow(rayPosition, normalize(rayPosition - light.pos), 0.001, 20.0, 2.0);\n            float sun = clamp( dot(normal, normalize(-light.pos)), 0.0, 1.0);\n            float sky = clamp(0.5 + 0.5 * normal.y, 0.0, 1.0);\n            float ind = clamp(dot(normal, normalize(-light.pos*vec3(-1.0, 0.0, -1.0))), 0.0, 1.0);\n\n            float occ = 1.0;\n\n            // Compute lighting \n            vec3 lin = sun * vec3(1.64, 1.27, 0.99) * pow(vec3(sha), vec3(1.0, 1.2, 1.5));\n            lin += sky * vec3(0.16, 0.20, 0.28) * occ; \n            lin += ind * vec3(0.4, 0.28, 0.20) * occ;\n\n            // Multiply lighting and materials \n            col = mat * lin;\n\n            // apply fog\n            // col = \n            \n            break;\n        }\n        rayDistance = distanceFunction(rayPosition);\n        rayPosition += rayDistance * rayDirection;\n    }\n\n    // gamma correct\n    col = pow(col, vec3(1.0/2.2));\n    \n\t\n    fragColor = vec4(col, 1.0);    \n}","name":"Image","description":"","type":"image"}]}