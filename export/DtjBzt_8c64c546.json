{"ver":"0.1","info":{"id":"DtjBzt","date":"1694384676","viewed":213,"name":"Unified DFT water","username":"Famousghost","description":"Unified DFT water\n\nPoor performance, becasue I used simple IDFT instead of IFFT\n\nCommon section ->  you can change unified water params\n\nBufferD -> you can change foam params\n\nImage -> you can change water color params and camera movement\n\n\n","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["waterraymarchingdftspectrum"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 120\n#define START_VALUE 0.0\n#define MIN_DIST 0.005\n#define MAX_DIST 2000.0\n#define ROUGHNESS 0.85\n#define SSCATTERING 0.05\n\n\n#define PITCH 12.0\n#define YAW -90.0\n\n\n//ENABLE and disable features\n#define CHOPPINESS_ACTIVE 1\n#define FOAMS 1\n#define CAMERA_ROTATION 0\n\n\nfloat sdWater( vec3 p, vec3 n, float dist)\n{\n    vec2 res = vec2(WATER_RESOLUTION_SIZE, WATER_RESOLUTION_SIZE);\n    \n    vec3 displacement = texture(iChannel0, p.xz / res).rgb;\n    #if CHOPPINESS_ACTIVE == 1\n    displacement = texture(iChannel0, (p.xz - displacement.yz) / res).rgb;\n    #endif\n    p.y += displacement.x;\n    float val = dot(p, n) - dist;\n    return val;\n}\n\nfloat sdScene(vec3 p)\n{\n    return sdWater(p, vec3(0.0f, 1.0f, 0.0f), 0.0f);\n}\n\nfloat rayMarching(vec3 ro, vec3 rd)\n{\n    float depth = 0.0f;\n    for(int i = 0; i < MAX_STEPS; ++i)\n    {\n        vec3 p = ro + rd * depth;\n        float d = sdScene(p);\n        depth += d;\n        if(d <= MIN_DIST || d >= MAX_DIST)\n            break;\n    }\n    return depth;\n}\n\nvec3 calcNormal(in vec3 p)\n{\n    float e = 0.5f;\n    return normalize(\n                    vec3(\n                        sdScene(vec3(p.x + e, p.y, p.z)) - sdScene(vec3(p.x - e, p.y, p.z)),\n                        sdScene(vec3(p.x, p.y + e, p.z)) - sdScene(vec3(p.x, p.y - e, p.z)),\n                        sdScene(vec3(p.x, p.y, p.z + e)) - sdScene(vec3(p.x, p.y, p.z - e))\n                    ));\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float near, in float far, in float k, in int accurate )\n{\n    float res = 1.0;\n    float ph = 1e10;\n    float t = near;\n    for( int i=0; i< accurate; i++ )\n    {\n        float h = sdScene(ro + rd*t);\n\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, 10.0*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n        if(t <= near || t >= far)\n            break;\n    }\n    return res;\n}\n\n\nfloat diff(vec3 p, vec3 lightDir, vec3 normal)\n{\n    float diff = max(dot(lightDir, normal), 0.0f);\n    float depth = softshadow(p + normal * MIN_DIST, lightDir, MIN_DIST, MAX_DIST, 8.0f, 64);\n    diff *= depth;\n\n    return clamp(diff, 0.0f, 1.0f);\n}\n\nfloat halfSpec(vec3 lightDir, vec3 rd, vec3 normal, float power)\n{\n    vec3 H = normalize(lightDir + rd);\n    return pow(clamp(dot(normal, H), 0.0f, 1.0f), power);\n}\n\nfloat normalization(float a, float b, float value)\n{\n    return (value - a) / (b - a);\n}\n\nfloat remap(float a0, float b0, float a1, float b1, float value)\n{\n    float t = normalization(a0, b0, value);\n    return mix(a1, b1, t);\n}\n\n#define K2 0.1\n#define K3 0.5\n\nvec3 scatter(vec3 p, vec3 lightDir, vec3 rayDir, vec3 normal, vec3 sunColor, vec3 skyColor)\n{\n   vec2 res = vec2(WATER_RESOLUTION_SIZE, WATER_RESOLUTION_SIZE);\n    \n    vec3 displacement = texture(iChannel0, p.xz / res).rgb;\n    #if CHOPPINESS_ACTIVE == 1\n    displacement = texture(iChannel0, (p.xz - displacement.yz) / res).rgb;\n    #endif\n    \n    vec3 x0 = SSCATTERING * max(0.0f, displacement.y) * skyColor * pow(dot(lightDir, rayDir), 4.0f) * (0.5f - 0.5f * pow(dot(lightDir, normal), 3.0f));\n    vec3 x1 = K2 * pow(dot(-rayDir, normal), 2.0f) * skyColor;\n    vec3 x2 = K3 * dot(lightDir, normal) * skyColor * sunColor;\n    float depth = softshadow(p + normal * MIN_DIST, lightDir, MIN_DIST, MAX_DIST, 8.0f, 64);\n    x2 *= depth;\n    return x0 + x1 + x2;\n}\n\nvec4 waterScene(vec3 ro, vec3 rd)\n{\n    vec3 col = vec3(0.0f);\n    float d = rayMarching(ro, rd);\n    \n    float pitch = radians(PITCH);\n    float yaw = radians(YAW);\n    \n    vec3 lightDir = normalize(vec3(cos(pitch) * cos(yaw), sin(pitch), cos(pitch) * sin(yaw)));\n    float sun = clamp((1.0f - smoothstep(radians(0.5f), radians(5.0f), acos(dot(lightDir, rd)))) * 1.1f, 0.0f, 1.0f);\n\n    vec3 skyColor = vec3(0.52734375f, 0.8046875f, 0.91796875f);\n\n    float offset = 1000.0f;\n    \n    float clouds = pow(clamp((fbm(rd * 2.0f + vec3(0.0f, 0.0f, iTime + offset) * 0.01f, 2.0f) + \n                              fbm(rd * 4.0f + vec3(0.0f, 0.0f, iTime + offset) * 0.05f, 4.0f) +\n                              fbm(rd * 8.0f + vec3(0.0f, 0.0f, iTime + offset) * 0.1f, 8.0f) +\n                              fbm(rd * 12.0f + vec3(0.0f, 0.0f, iTime + offset) * 0.2f, 16.0f)) * 0.35f *\n                              2.0f - 1.0f, 0.0f, 1.0f), 1.0f) * smoothstep(0.0f, 0.1f, dot(rd, vec3(0.0f, 1.0f, 0.0f)));\n    vec3 sunColor = vec3(0.984375f, 0.89453125f, 0.65375f);\n    vec4 result = vec4(sunColor * sun + skyColor * (1.0f - sun), 1.0f);\n    result.xyz = mix(result.xyz, vec3(1.0f), clouds);\n    vec3 reflectedSkyColor = result.xyz;\n    if(d <= MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n\n        vec3 normal = calcNormal(p);\n        \n        normal += (1.0f - ROUGHNESS) * clamp(texture(iChannel1, p.xz/iChannelResolution[0].xy).rrr, vec3(-0.5f), vec3(0.5f));\n        normal = normalize(normal);\n        \n        float diffuse = diff(p, lightDir, normal.xyz);\n        \n        float specular = halfSpec(-rd, lightDir, normal.xyz, 64.0f); //Blin-phong HalfNormalSpecular\n        \n        float fresnel = clamp(pow(1.0f - dot(-rd, normal), 5.0f), 0.0f, 1.0f);\n        \n        vec3 waterColor = vec3(0.13671875f, 0.53515625f, 0.8515625f);\n        \n        vec3 diffColor = scatter(p, lightDir, rd, normal, sunColor, skyColor);\n        vec3 specularColor = vec3(specular);\n        \n        vec3 H = normalize(normal - lightDir.xyz);\n        vec2 res = vec2(WATER_RESOLUTION_SIZE, WATER_RESOLUTION_SIZE);\n        #if FOAMS == 1\n    \n        vec3 displacement = texture(iChannel0, p.xz / res).rgb;\n        #if CHOPPINESS_ACTIVE == 1\n        displacement = texture(iChannel0, (p.xz - displacement.yz) / res).rgb;\n        #endif\n        #if CHOPPINESS_ACTIVE == 1\n        float jacobian = clamp((1.0f - texture(iChannel0, (p.xz - displacement.yz) / res).a + CUTOFF_FOAMS), 0.0f, 1.0f);\n        #else\n        float jacobian = clamp(texture(iChannel0, p.xz / res).a + CUTOFF_FOAMS, 0.0f, 1.0f);\n        #endif\n        col = mix(clamp((diffColor + specularColor + reflectedSkyColor * fresnel), 0.0f, 1.0f), result.xyz, fresnel);\n        result.xyz = col;\n        result.xyz = mix(result.xyz, vec3(1.0f), (1.0f - jacobian) * FOAM_BRIGHTNESS_SCALE);\n        #else\n        col = mix(clamp((diffColor + specularColor + reflectedSkyColor * fresnel) * vec3(1.0f), 0.0f, 1.0f), result.xyz, fresnel);\n        result.xyz = col;\n        #endif \n        result.xyz = mix(skyColor, result.xyz, exp(-d * 0.003f));\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5f * iResolution.xy) / iResolution.y;\n    \n    #if CAMERA_ROTATION == 1\n    float pi = atan(1.0f) * 4.0f;\n    float xAngle = iMouse.y / iResolution.y;\n    float yAngle = iMouse.x / iResolution.x;\n    \n\n    float x = cos(yAngle * 2.0f * PI)* cos(xAngle * 2.0f * PI);\n    float y = sin(xAngle * 2.0f * PI);\n    float z = sin(yAngle * 2.0f * PI) * cos(xAngle * 2.0f * PI);\n    \n    vec3 dir = vec3(x, y, z);\n    #endif\n\n    vec3 ro = vec3(0.0f, 35.0f, 0.0f);\n    vec3 rd = normalize(vec3(uv, -1.0f));\n    \n    #if CAMERA_ROTATION == 1\n    \n    rd = lookAt(ro, vec3(0.0f, 1.0f, 0.0f), ro + dir) * rd;\n    \n    #endif\n    vec4 col = waterScene(ro, rd);\n    \n    \n    fragColor = col;\n    //fragColor = vec4(texture(iChannel0, fragCoord/iResolution.xy).rgb, 1.0f); //Check Displacement texture\n    //fragColor = vec4(1.0f - texture(iChannel0, fragCoord/iResolution.xy).aaaa); //Foam jacobian Texture\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//--------------------------AUTHOR-------------------------//\n//-----------------------Famousghost-----------------------//\n\n\n//---------------------RESOURCES---------------------//\n\n// https://www.cg.tuwien.ac.at/research/publications/2018/GAMPER-2018-OSG/GAMPER-2018-OSG-thesis.pdf //\n// https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.1011.6218&rep=rep1&type=pdf //\n// https://github.com/gasgiant/FFT-Ocean //\n// https://tore.tuhh.de/bitstream/11420/1439/1/GPGPU_FFT_Ocean_Simulation.pdf //\n\n//---------------------RESOURCES---------------------//\n\n//---------------------Wave Main Properties---------------------//\n\n#define WIND_SPEED 7.0\n#define FETCH 1000000.0\n#define WIND_DIRECTION_ANGLE -45.0\n#define WATER_RESOLUTION_SIZE 900.0\n#define WAVE_SPEED  0.25\n#define CHOPPINESS 1.2\n#define FOAM_STRENGTH 1.0\n#define FOAM_BRIGHTNESS_SCALE 2.0\n\n//If foams are too high you can change this param to higher in order to attenuate foams\n#define CUTOFF_FOAMS 0.8\n\n//---------------------Wave Main Properties---------------------//\n\n//---------------------Common Values UNIFIED---------------------//\n\n#define PI 3.14159265359\n#define Gravity 9.81f\n#define WAVE_LENGTH 170.0\n#define C_M 0.23\n\n//---------------------Common Values UNIFIED---------------------//\n\n//--------------------- Common Functions ---------------------//\n\nmat3 lookAt(vec3 pos, vec3 up, vec3 forward)\n{\n    vec3 direction = normalize(forward - pos);\n\n    vec3 right = normalize(cross(up, direction));\n    vec3 newUp = normalize(cross(direction, right));\n\n    \n    return mat3(right, \n                newUp,\n                direction);\n}\n\n\nfloat sqr(float x)\n{\n    return x * x;\n}\n\n\nfloat sqr4(float x)\n{\n    return sqr(x) * sqr(x);\n}\n\nvec2 compMul(vec2 number, vec2 number2)\n{\n    return vec2(number.x * number2.x - number.y * number2.y, number.x * number2.y + number.y * number2.x);\n}\n\nfloat permuteFactor(const vec2 id)\n{\n    return (1.0f - 2.0f * (mod(id.x + id.y, 2.0f)));\n}\n\n//--------------------- Common Functions ---------------------//\n\n//---------------------Gaussian Distribution random---------------------//\n\nfloat random(vec3 uv)\n{\n    return fract(sin(dot(uv, vec3(19.1432f, 57.34254f, 33.3434f))) * 435563.6342f);\n}\n\nvec2 gaussianNoise(vec2 uv, float val)\n{\n    float u1 = random(vec3(uv, val));\n    float u2 = random(vec3(uv, val + 1.0f));\n    float l = sqrt(-2.0f * log(u1));\n    return vec2(clamp(l * cos(2.0f * PI * u2), 0.0f, 1.0f), clamp(l * sin(2.0f * PI * u2), 0.0f, 1.0f));\n}\n\n//---------------------Gaussian Distribution random---------------------//\n\nfloat DirectionalSpreadFunctionUnified(float w, float theta, float theta_p, float u_star, float c, float c_p)\n{\n    float a_m = 0.13f * u_star / C_M;\n    const float a_0 = log(2.0f) / 4.0f;\n    const float a_p = 4.0f;\n    float deltaFromK = tanh(a_0 + a_p * pow(c / c_p, 2.5f) + a_m * pow(C_M / c, 2.5f));\n    return 1.0f + deltaFromK * cos(2.0f * (theta - theta_p));\n}\n\n//UnifiedSpectrum(k, kLength, waveParam.windSpeed, omega_c, k_p, L_pm, w, u_star, c, c_p, k_m) \nfloat UnifiedSpectrum(vec2 k, float kAngle, float directionAngle, float kLength, float windSpeed, \n                      float omega_c, float k_p, float L_pm, float w, \n                      float u_star, float c, float c_p, float k_m, vec2 n)\n{\n    float gamma = 1.7f + 6.0f * log(omega_c);\n    if(omega_c < 1.0f)\n    {\n        gamma = 1.7f;\n    }\n    \n    float sigma = 0.08f * (1.0f + 4.0f / (omega_c * omega_c * omega_c));\n    float gammaFunction = exp(-sqr(sqrt(kLength / k_p) - 1.0f) / (2.0f * sqr(sigma)));\n    float j_p = pow(gamma, gammaFunction);\n    \n    //Low frequency regime\n    \n    float alpha_p = 0.006f * sqrt(omega_c);\n    float F_p = L_pm * j_p * exp(-omega_c / sqrt(10.0f) * (sqrt(kLength / k_p) - 1.0f));\n    float B_l = 0.5f * alpha_p * c_p / c * F_p;\n    \n    //high frequency regime\n    \n    float alpha_m = 0.01f * (u_star < C_M ? 1.0f + log(u_star / C_M) : 1.0f + 3.0f * log(u_star / C_M));\n    float F_m = L_pm * j_p * exp(-0.25f * sqr(kLength / k_m - 1.0f));\n    float B_h = 0.5f * alpha_m * C_M / c * F_m;\n    \n    float ang = kAngle - directionAngle;\n\n    vec2 kDir = vec2(cos(ang), sin(ang));\n\n    if(kDir.x > 0.0f)\n        return 0.0f;\n\n    return (B_l + B_h) / (2.0f * PI * kLength * kLength * kLength * kLength);\n}\n\n//---------------------Unified Spectrum---------------------//\n\n\n//--------------------- Perlin Noise ---------------------//\n\nfloat random(in vec3 uv, in float freq)\n{\n    return fract(sin(dot(uv * freq, vec3(13.5345f, 33.534534f, 43.5343f))) * 45462.545f);\n}\n\nvec3 frac(vec3 uv)\n{\n    return uv - floor(uv);\n}\n\nfloat ssmooth(float x)\n{\n    return x * x * (3.0f - 2.0f * x);\n}\n\nvec3 moduloUv(in vec3 uv, in float freq)\n{\n    return vec3(mod(uv.x, freq), mod(uv.y, freq), mod(uv.z, freq));\n}\n\nfloat simpleNoise(in vec3 uv, in float freq)\n{\n    vec3 iuv = floor(uv);\n    vec3 fuv = frac(uv); //uv - floor(uv)\n    \n    float x =  random(moduloUv(iuv + vec3(0.0f, 0.0f, 0.0f), freq), freq);\n    float x1 = random(moduloUv(iuv + vec3(1.0f, 0.0f, 0.0f), freq), freq);\n    \n    float y =  random(moduloUv(iuv + vec3(0.0f, 1.0f, 0.0f), freq), freq);\n    float y1 = random(moduloUv(iuv + vec3(1.0f, 1.0f, 0.0f), freq), freq);\n    \n    float x2 =  random(moduloUv(iuv + vec3(0.0f, 0.0f, 1.0f), freq), freq);\n    float x3 = random(moduloUv(iuv + vec3(1.0f, 0.0f, 1.0f), freq), freq);\n    \n    float y2 =  random(moduloUv(iuv + vec3(0.0f, 1.0f, 1.0f), freq), freq);\n    float y3 = random(moduloUv(iuv + vec3(1.0f, 1.0f, 1.0f), freq), freq);\n    \n    \n    \n    float a = mix(x, x1, ssmooth(fuv.x));\n    \n    float b = mix(y, y1, ssmooth(fuv.x));\n    \n    float c = mix(x2, x3, ssmooth(fuv.x));\n    \n    float d = mix(y2, y3, ssmooth(fuv.x));\n    \n    float ab = mix(a, b, ssmooth(fuv.y));\n    \n    float cd = mix(c, d, ssmooth(fuv.y));\n\n    \n    return mix(ab, cd, ssmooth(fuv.z));\n}\n\nfloat fbm(in vec3 uv, in float freq)\n{\n    float sum = 0.00;\n    float amp = 0.5;\n    \n    for( int i = 0; i < 6; ++i )\n    {\n        sum += simpleNoise( uv, freq ) * amp;\n        uv += uv * 2.0f;\n        amp *= 0.5f;\n    }\n    \n    return sum;\n}\n\n//--------------------- Perlin Noise ---------------------//\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct WaterParameters\n{\n    float windSpeed;\n    float fetch;\n    float directionAngle;\n};\n\nfloat calcOmegaUnified(float k, float k_m, float g)\n{\n    return sqrt(Gravity * k * (1.0f + sqr(k / k_m)));\n}\n\nvec3 h0kCalculationsUNIFIED(vec2 n, vec2 k, WaterParameters waveParam, float kLength, vec2 deltaK)\n{\n    vec2 noise = gaussianNoise(n, 0.0f);\n    float k_m = 120.0f;\n    float w = calcOmegaUnified(kLength, k_m, Gravity);\n    float X = Gravity * waveParam.fetch / sqr(waveParam.windSpeed);\n    float X0 = 2.2e+4f;\n    \n    float omega_c =  0.84f * pow(tanh(pow(X / X0, 0.4f)), -0.75f);\n    float k_p = Gravity * sqr(omega_c / waveParam.windSpeed);\n    \n    float L_pm = exp(-1.25f * sqr(k_p / kLength));\n    float c = w / kLength;\n    float c_p = calcOmegaUnified(k_p, k_m, Gravity) / k_p;\n    \n    float z0 = 3.7e-5f * sqr(waveParam.windSpeed) / Gravity * pow((waveParam.windSpeed / c_p), 0.9f);\n    float u_star = 0.41f * waveParam.windSpeed / log(10.0f / z0);\n    \n    float f = 1.0f / sqrt(2.0f);\n\n    float waveAngle = atan(k.y, k.x);\n    \n    float spectrum = UnifiedSpectrum(k, waveAngle, waveParam.directionAngle, kLength, waveParam.windSpeed, omega_c, k_p, L_pm, w, u_star, c, c_p, k_m, n) \n                     * DirectionalSpreadFunctionUnified(w, waveAngle, waveParam.directionAngle, u_star, c, c_p);\n             \n    vec2 h0k = f * noise * sqrt(spectrum);\n    \n    return vec3(h0k, w);\n}\n\nWaterParameters createUNIFIEDParams()\n{\n    WaterParameters waveParam;\n    \n    waveParam.windSpeed = WIND_SPEED;\n    waveParam.fetch = FETCH;\n    waveParam.directionAngle = radians(WIND_DIRECTION_ANGLE);\n   \n    return waveParam;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //------- UNIFIED SPECTRUM  -------//\n    \n    vec2 n = (fragCoord - 0.5f * iResolution.xy);\n    vec2 deltaK = vec2(2.0f * PI / WAVE_LENGTH);\n    vec2 k = n * deltaK;\n    float kLength = length(k);\n    float w = sqrt(kLength * Gravity);\n    WaterParameters waveParam;\n\n    waveParam = createUNIFIEDParams();\n    vec3 h0k = h0kCalculationsUNIFIED(n, k, waveParam, kLength, deltaK);\n    vec3 h0minusk = h0kCalculationsUNIFIED(n, -k, waveParam, kLength, deltaK);\n    \n    //------- UNIFIED SPECTRUM  -------//\n    \n    //------- Time dependent spectrum  -------//\n    \n    float cosinus = cos(w * 2.0f * PI * (iTime * WAVE_SPEED + 1000.0f));\n    float sinsus = sin(w * 2.0f * PI * (iTime * WAVE_SPEED + 1000.0f));\n    \n    vec2 eiw = vec2(cosinus, sinsus);\n    \n    \n    vec2 hkt = compMul(h0k.xy, eiw) + compMul(vec2(h0minusk.x, h0minusk.y), vec2(eiw.x, -eiw.y));\n    \n    vec2 ihkt = vec2(-hkt.y, hkt.x);\n    vec2 waveMovementX = ihkt * k.x * (1.0f / kLength);\n    vec2 waveMovementZ = ihkt * k.y * (1.0f / kLength);\n    \n    //------- Time dependent spectrum  -------//\n\n    fragColor = vec4(hkt.xy, waveMovementX.x - waveMovementZ.y, waveMovementX.y + waveMovementZ.x);\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Horizontal DFT of the input.\n\n//https://www.shadertoy.com/view/MscGWS//\n\nfloat tau = 2.0f * PI;\n\nvec2 polar(float m, float a)\n{\n\treturn m*vec2(cos(a), sin(a));   \n}\n\nvec2 cmul(vec2 a,vec2 b)\n{\n\treturn vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord;\n    \n    float w = uv.x - iResolution.x*0.5f;\n    \n    vec2 xw = vec2(0.0f);\n    vec2 xw_2 = vec2(0.0f);\n    \n    for(float n = 0.0;n <iChannelResolution[0].x; ++n )\n    {\n        float a = -(tau * w * n) / iChannelResolution[0].x;\n        \n        vec2 xn = textureLod(iChannel0, vec2(n, uv.y) / iChannelResolution[0].xy, 0.0).xy;\n        vec2 xn_2 = textureLod(iChannel0, vec2(n, uv.y) / iChannelResolution[0].xy, 0.0).zw;\n        \n        xw += cmul(xn, polar(1.0f, a));\n        xw_2 += cmul(xn_2, polar(1.0f, a));\n    }\n    \n    fragColor = vec4(xw, xw_2);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//Vertical DFT of horizontal DFT (final 2D dft).\n\n//https://www.shadertoy.com/view/MscGWS//\n\nfloat tau = 2.0f*PI;\n\nvec2 polar(float m, float a)\n{\n\treturn m*vec2(cos(a), sin(a));   \n}\n\nvec2 cmul(vec2 a,vec2 b)\n{\n\treturn vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = fragCoord;\n    \n    float w = uv.y - iResolution.y*0.5f;\n    \n    vec2 xw = vec2(0.0f);\n    vec2 xw_2 = vec2(0.0f);\n    \n    for(float n = 0.0;n < iChannelResolution[0].y;n++)\n    {\n        float a = -(tau * w * n) / iChannelResolution[0].y;\n        \n        vec2 xn = textureLod(iChannel0, vec2(uv.x, n) / iChannelResolution[0].xy, 0.0).xy;\n        vec2 xn_2 = textureLod(iChannel0, vec2(uv.x, n) / iChannelResolution[0].xy, 0.0).zw;\n        \n        xw += cmul(xn, polar(1.0, a));\n        xw_2 += cmul(xn_2, polar(1.0f, a));\n    }\n    \n    fragColor = vec4(xw,xw_2);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"#define SIMPLE_JACOBIAN 0\n#define ATTENUATION_PARAM 0.98\n\nfloat jacobian(vec2 fragCoord)\n{\n    vec2 left = texture(iChannel0, (fragCoord - vec2(1.0f, 0.0f)) / iChannelResolution[0].xy).yz * permuteFactor(fragCoord- vec2(1.0f, 0.0f));\n    vec2 right = texture(iChannel0, (fragCoord + vec2(1.0f, 0.0f)) / iChannelResolution[0].xy).yz * permuteFactor(fragCoord+ vec2(1.0f, 0.0f));\n    \n    vec2 top = texture(iChannel0, (fragCoord + vec2(0.0f, 1.0f)) / iChannelResolution[0].xy).yz * permuteFactor(fragCoord + vec2(0.0f, 1.0f));\n    vec2 bottom = texture(iChannel0, (fragCoord - vec2(0.0f, 1.0f)) / iChannelResolution[0].xy).yz * permuteFactor(fragCoord - vec2(0.0f, 1.0f));\n    \n    float jxx = 1.0f + FOAM_STRENGTH * (right.x - left.x) * 0.5f;\n    float jyy = 1.0f + FOAM_STRENGTH * (top.y - bottom.y) * 0.5f;\n    float jxy = 1.0f + FOAM_STRENGTH * (right.y - left.y) * 0.5f;\n    \n    return jxx*jyy - jxy*jxy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 uv = fragCoord / iChannelResolution[0].xy;\n\n    vec4 displacement = texture(iChannel0, uv) * permuteFactor(fragCoord);\n    \n    #if SIMPLE_JACOBIAN == 1\n    fragColor = vec4(displacement.x, CHOPPINESS * displacement.z, CHOPPINESS * displacement.w, jacobian(fragCoord));\n    #else\n    float jac = texture(iChannel1, uv).a;\n    float currentJac = jacobian(fragCoord);\n    jac += iTimeDelta * step(1.0f - currentJac, 0.0f);\n    jac *= ATTENUATION_PARAM;\n    \n    fragColor = vec4(displacement.x, CHOPPINESS * displacement.z, CHOPPINESS * displacement.w, max(jac, currentJac));\n    #endif\n\n}","name":"Buffer D","description":"","type":"buffer"}]}