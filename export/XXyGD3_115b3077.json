{"ver":"0.1","info":{"id":"XXyGD3","date":"1718639711","viewed":41,"name":"pxfl brick","username":"olano","description":"GLSL version of brick from my 1998 PhD dissertation\n\nOriginally written the pfman shading language for PixelFlow (the first graphics hardware with a real-time high-level shading language)","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["brick","historic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// ****************************************************\n//\n// More complex and realistic looking brick shader.\n//\n// ****************************************************\n\n///////\n// original had C++ program with tcl/tk GUI to control all of these parameters\n\n// control for basic brick\nconst float brick_width = 0.125;\nconst float brick_height = 0.05;\nconst float mortar_width = 0.01;\nconst float mortar_height = 0.01;\nconst vec3 brick_color = vec3(0.8, 0.1, 0.1);\nconst vec3 mortar_color = vec3(0.5);\n\n// add symmetric high frequency noise\nconst float brick_hfnoise_mix = 0.25;\nconst float brick_hfnoise_freq = 200.0;\nconst float mortar_hfnoise_mix = 0.25;\nconst float mortar_hfnoise_freq = 200.0;\n\n// add low frequency to bricks\nconst float brick_lfnoise_scale = 0.5;\nconst vec2 brick_lfnoise_freq = vec2(4,1);\n\n// add inward bump to mortar\nconst float mortar_bump_scale = 1.0;\n\n// color individual bricks differently\nconst float brick_color_scale = 0.5;\n\n////////\n// direct translation of brick generation\n// note that some of the weird smoothstep code using duv as the blend factor\n//   is to fade out the noise when too high frequency\n// lighting is a simplified diffuse just to make the mortar bumps visible\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 texcoord = fragCoord/iResolution.y;\n    \n    // figure out which row of bricks\n    uint row = uint(texcoord.y / brick_height);\n    \n    // offset even rows by half a row\n    // this could potentially cause the texcoord to become larger than 1\n    float u_texcoord = texcoord.x;\n    if (row % 2u < 1u)\n        u_texcoord += brick_width * 0.5;\n\n    // now safe to find column of bricks as well\n    uint col = uint(u_texcoord / brick_width);\n    \n    // compute \"brick coordinates\"\n    vec2 st = vec2(\n        mod(u_texcoord, brick_width),\n        mod(texcoord.y, brick_height)\n    );\n    \n    // perturbation vector to put each brick in its own place in\n    // noise space.\n    vec2 brick_shift = vec2(hash(uvec3(row,col,0)).xy & 0xffffu);\n    \n    // surface color will be either brick or mortar\n    vec3 mortar = mortar_color;\n    vec3 brick = brick_color;\n    \n    // distance in texture space between adjacent pixels for\n    // antialiasing\n    float duv = length(fwidth(texcoord));\n    \n    // add in high frequency noise to mortar\n    if (mortar_hfnoise_mix > 0.0) {\n        mortar += mortar_hfnoise_mix\n            * (1.-smoothstep(1./mortar_hfnoise_freq,\n                             2./mortar_hfnoise_freq, \n                             duv))\n            * snoise(vec2(mortar_hfnoise_freq*texcoord));\n    }\n    \n    // do individual brick color variations\n    if (brick_color_scale > 0.0) {\n        brick *= 1.0 - brick_color_scale\n            * float(hash(uvec3(row,col,0)).x & 0xffffu) / float(0xffff)\n            * (1.-smoothstep(brick_width/2., 2.*brick_width, duv))\n            * (1.-smoothstep(brick_height/2., 2.*brick_height, duv));\n    }\n    \n    // add in high frequency noise to the brick\n    if (brick_hfnoise_mix > 0.0) {\n        brick += brick_hfnoise_mix\n            * (1.-smoothstep(1./brick_hfnoise_freq, 2./brick_hfnoise_freq, duv))\n            * snoise(brick_hfnoise_freq * st + brick_shift);\n    }\n    \n    // add low frequency noise\n    if (brick_lfnoise_scale > 0.0) {\n        vec2 lf_texcoord = brick_lfnoise_freq * st + brick_shift;\n        brick *= 1. + brick_lfnoise_scale\n            * (1.-smoothstep(1./brick_lfnoise_freq.x,\n                             2./brick_lfnoise_freq.x, duv))\n            * (1.-smoothstep(1./brick_lfnoise_freq.y,\n                             2./brick_lfnoise_freq.y, duv))\n            * snoise(lf_texcoord);\n    }\n    \n    // choose mortar or brick colors based on position in\n    // brick coordinates\n    float colormix =\n        (smoothstep(mortar_width/2. - duv, mortar_width/2., st.x)\n         - smoothstep(brick_width - mortar_width/2.,\n                     brick_width - mortar_width/2. + duv, st.x))\n        * (smoothstep(mortar_height/2. - duv,mortar_height/2., st.y)\n           - smoothstep(brick_height - mortar_height/2.,\n                        brick_height - mortar_height/2. + duv, st.y));\n\n    vec3 surface_color = mix(mortar, brick, colormix);\n\n    //////////////////////////////\n    // bump edges of mortar\n    vec2 ndisp;\n    \n    // create blend variables -- 0-1 from center of mortar to brick\n    float left_blend = st.x / (mortar_width/2.);\n    float right_blend = (brick_width - st.x) / (mortar_width/2.);\n    float bottom_blend = st.y / (mortar_height/2.);\n    float top_blend = (brick_height - st.y) / (mortar_height/2.);\n    \n    // add displacements for each edge\n    float blend = left_blend;\n    if (blend > bottom_blend || blend > top_blend || blend >= 1.)\n        blend = 0.;\n    ndisp.x = mix(0., -mortar_bump_scale, blend);\n    \n    blend = right_blend;\n    if (blend > bottom_blend || blend > top_blend || blend >= 1.)\n        blend = 0.;\n    ndisp.x += mix(0., mortar_bump_scale, blend);\n    \n    blend = bottom_blend;\n    if (blend > left_blend || blend > right_blend || blend > 1.)\n        blend = 0.;\n    ndisp.y = mix(0., -mortar_bump_scale, blend);\n    \n    blend = top_blend;\n    if (blend > left_blend || blend > right_blend || blend > 1.)\n        blend = 0.;\n    ndisp.y += mix(0., mortar_bump_scale, blend);\n    \n    // fade bump away to antialias\n    ndisp.x *= (1.-smoothstep(mortar_width/2., 2.*mortar_width, duv));\n    ndisp.y *= (1.-smoothstep(mortar_height/2., 2.*mortar_width, duv));\n    \n    // bump normal direction\n    vec3 material_normal = normalize(vec3(ndisp,1));\n    \n    // accumulate diffuse colors for each light\n    vec3 L = normalize(vec3(1,1,1));\n    float diffuse = clamp(dot(L,material_normal),0.,1.);\n    \n    // Output to screen\n    fragColor = vec4(surface_color * diffuse,1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// 3D integer to 3D integer random hash\nuvec3 hash(uvec3 v) {\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n    v ^= v >> 16u;\n    v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n    return v;\n}\n\n// hash from 2D grid cell to [-1,1]^2 \nvec2 rand(vec2 p) {\n    uvec3 v = hash(uvec3(ivec3(p,0)));\n\n    return vec2(v.xy & 0xffffu) / float(0xffff) * 2. - 1.;\n}\n\n// signed Perlin noise in [-1,1]\nfloat snoise(vec2 p) {\n    vec2 pi = floor(p);\t\t\t\t\t\t// integer part\n    vec2 pf = fract(p);\t\t\t\t\t\t// fractional part\n    vec2 ps = (3.0 - 2.0 * pf) * pf * pf;\t// smooth blend factor\n    \n    float n00 = dot(rand(pi + vec2(0,0)), pf - vec2(0,0));\n    float n01 = dot(rand(pi + vec2(0,1)), pf - vec2(0,1));\n    float n10 = dot(rand(pi + vec2(1,0)), pf - vec2(1,0));\n    float n11 = dot(rand(pi + vec2(1,1)), pf - vec2(1,1));\n    \n    float n0 = mix(n00, n10, ps.x);\n    float n1 = mix(n01, n11, ps.x);\n        \n    return mix(n0, n1, ps.y);\n}\n","name":"Common","description":"","type":"common"}]}