{"ver":"0.1","info":{"id":"XssBRB","date":"1496964160","viewed":423,"name":"Tetrahedral Dithering","username":"theGiallo","description":"Following this https://www.shadertoy.com/view/4sffWM . Takes a color, finds a tetrahedron of palette colors containing that color and uses the barycentric coordinates to select the palette entry, using a mask/random value.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["palette","dithering","bluenoise","bayer","goldennoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":3,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MOVE_PIC 0\n\n// With 0 it's temporal dithering. ¡¡ Photosensitive epilepsy WARNING !!\n#define FIXED_PATTERN 1\n\n// Pattern relative to canvas or texture represented\n#define PATTERN_RELATIVE_TO_PIC 0\n\n#define PALETTE_COUNT 8\n// try 8,14,15,27\n\n// These numbers are empirical.\n//   Y   / X     \n// 1009  / 19 23 [39] 43 53\n// [65537] / (49 no f.y *=...) 59 (45) 43 24 [25] 27 30\n#define GOLDEN_X 25\n#define GOLDEN_Y 65537\n\n#define SHOW_THE_MASK 0\n\n/*\n\n Improving on the concept of https://www.shadertoy.com/view/4dsfDN , that uses linear interpolation in 1D,\n this shader uses a tetrahedron of palette colors containing the high definition color and its barycentric\n coordinates to choose from the 4 palette colors using a random value. The random value can be seen as a mask.\n \n Enabling the temporal dithering makes the mask to randomly shift every frame, exploiting image permanence on the retina.\n\n The search for the tetrahedron is brute force because it's thinked for a generic palette. Also I use a palette and\n I don't work by channels, like [3] because of that. Exploiting the knowledge of a\n grid-palette computations could be improved and this could be applied on a bigger palette, like a 24bit palette ;)\n\n From left to right:\n       truth  |  golden noise    | texture (linear I think) noise | pseudo blue noise    | Bayer mask\n                             [1]                                                     [2]\n\n [1] https://en.wikipedia.org/wiki/Low-discrepancy_sequence#Additive_recurrence\n [2] https://www.shadertoy.com/view/4sGSDd\n [3] https://www.shadertoy.com/view/XdsfW7\n*/\n\n\nvec3 palette[PALETTE_COUNT];\n\nfloat sqlength( vec3 v )\n{\n    return dot(v,v);\n}\nfloat mod1( float x )\n{\n    return x - floor(x);\n}\n\n// source: https://www.shadertoy.com/view/4sGSDd\nfloat mask(vec2 p) // see https://www.shadertoy.com/view/ldyXDd\n{\n#define T(l) textureLod(iChannel2,U/256.,l)\n#define DMUL  8.12235325   \n#define SIZE  5.5\n    vec2 U = floor(p/SIZE)*SIZE;\n    p += ( T(0.).xy - .5 ) *DMUL;\n    return fract( p.x*1.705 + p.y*.5375 ); \n}\n\n#if 0\nvec2\nrotate( vec2 v, float a )\n{\n\tfloat s = sin( a );\n\tfloat c = cos (a );\n\tmat2 m = mat2( c, -s, s, c );\n\treturn m * v;\n}\n\nfloat\nmask4( vec2 f )\n{\n    #define V0 0.0/7.0\n    #define V1 1.0/7.0\n    #define V2 2.0/7.0\n    #define V3 3.0/7.0\n    #define V4 4.0/7.0\n    #define V5 5.0/7.0\n    #define V6 6.0/7.0\n    #define V7 7.0/7.0\n    float m[8*8];\n    m[0*8+0] = V0; m[0*8+1] = V2; m[0*8+2] = V4; m[0*8+3] = V6; m[0*8+4] = V0; m[0*8+5] = V2; m[0*8+6] = V4; m[0*8+7] = V6;\n    m[1*8+0] = V3; m[1*8+1] = V5; m[1*8+2] = V7; m[1*8+3] = V1; m[1*8+4] = V3; m[1*8+5] = V5; m[1*8+6] = V7; m[1*8+7] = V1;\n    m[2*8+0] = V4; m[2*8+1] = V6; m[2*8+2] = V0; m[2*8+3] = V2; m[2*8+4] = V4; m[2*8+5] = V6; m[2*8+6] = V0; m[2*8+7] = V2;\n    m[3*8+0] = V7; m[3*8+1] = V1; m[3*8+2] = V3; m[3*8+3] = V5; m[3*8+4] = V7; m[3*8+5] = V1; m[3*8+6] = V3; m[3*8+7] = V5;\n    m[4*8+0] = V0; m[4*8+1] = V2; m[4*8+2] = V4; m[4*8+3] = V6; m[4*8+4] = V0; m[4*8+5] = V2; m[4*8+6] = V4; m[4*8+7] = V6;\n    m[5*8+0] = V3; m[5*8+1] = V5; m[5*8+2] = V7; m[5*8+3] = V1; m[5*8+4] = V3; m[5*8+5] = V5; m[5*8+6] = V7; m[5*8+7] = V1;\n    m[6*8+0] = V4; m[6*8+1] = V6; m[6*8+2] = V0; m[6*8+3] = V2; m[6*8+4] = V4; m[6*8+5] = V6; m[6*8+6] = V0; m[6*8+7] = V2;\n    m[7*8+0] = V7; m[7*8+1] = V1; m[7*8+2] = V3; m[7*8+3] = V5; m[7*8+4] = V7; m[7*8+5] = V1; m[7*8+6] = V3; m[7*8+7] = V5;\n   \n    int x = ( 8 + int(f.x) % 8 ) % 8;\n    int y = ( 8 + int(f.y) % 8 ) % 8;\n    return m[x*8+y];\n}\n\n#define max4(a,b,c,d) max(max(max(a,b),c),d)\n#define min4(a,b,c,d) min(min(min(a,b),c),d)\n#endif\n\nfloat\ngolden_noise( vec2 f )\n{\n    #define a 0.618034\n    #define l GOLDEN_X\n\n    f.y *= texture(iChannel1,f).r * float(GOLDEN_X);\n    int ll = l * l;\n    float ret = a;\n    int c = ( ll + ( int(f.x) + int(f.y) * GOLDEN_Y ) % ll ) % ll ;\n    for ( int i = 0; i != ll; ++i )\n    {\n        ret = mod1( ret + a );\n        if ( c == i )\n        {\n            break;\n        }\n    }\n    #undef a\n    #undef l\n    \n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #if PALETTE_COUNT > 0\n    palette[0] = vec3(0.0,0.0,0.0);\n    #endif\n    #if PALETTE_COUNT > 1\n    palette[1] = vec3(1.0,1.0,1.0);\n    #endif\n    #if PALETTE_COUNT > 2\n    palette[2] = vec3(1.0,0.0,0.0);\n    #endif\n    #if PALETTE_COUNT > 3\n    palette[3] = vec3(0.0,1.0,0.0);\n    #endif\n    #if PALETTE_COUNT > 4\n    palette[4] = vec3(0.0,0.0,1.0);\n    #endif\n    #if PALETTE_COUNT > 5\n    palette[5] = vec3(0.0,1.0,1.0);\n    #endif\n    #if PALETTE_COUNT > 6\n    palette[6] = vec3(1.0,0.0,1.0);\n    #endif\n    #if PALETTE_COUNT > 7\n    palette[7] = vec3(1.0,1.0,0.0);\n    #endif\n    #if PALETTE_COUNT > 8\n    palette[8] = vec3(0.5,0.0,0.0);\n    #endif\n    #if PALETTE_COUNT > 9\n    palette[9] = vec3(0.0,0.5,0.0);\n    #endif\n    #if PALETTE_COUNT > 10\n    palette[10] = vec3(0.0,0.0,0.5);\n    #endif\n    #if PALETTE_COUNT > 11\n    palette[11] = vec3(0.0,0.5,0.5);\n    #endif\n    #if PALETTE_COUNT > 12\n    palette[12] = vec3(0.5,0.0,0.5);\n    #endif\n    #if PALETTE_COUNT > 13\n    palette[13] = vec3(0.5,0.5,0.0);\n    #endif\n    #if PALETTE_COUNT > 14\n    palette[14] = vec3(0.5,0.5,0.5);\n    #endif\n    #if PALETTE_COUNT > 15\n    palette[15] = vec3(0.5,1.0,0.0);\n    #endif\n    #if PALETTE_COUNT > 16\n    palette[16] = vec3(0.5,1.0,0.5);\n    #endif\n    #if PALETTE_COUNT > 17\n    palette[17] = vec3(0.5,1.0,1.0);\n    #endif\n    #if PALETTE_COUNT > 18\n    palette[18] = vec3(0.0,0.5,1.0);\n    #endif\n    #if PALETTE_COUNT > 19\n    palette[19] = vec3(0.0,1.0,0.5);\n    #endif\n    #if PALETTE_COUNT > 20\n    palette[20] = vec3(0.5,0.0,1.0);\n    #endif\n    #if PALETTE_COUNT > 21\n    palette[21] = vec3(1.0,0.5,0.0);\n    #endif\n    #if PALETTE_COUNT > 22\n    palette[22] = vec3(0.5,0.5,1.0);\n    #endif\n    #if PALETTE_COUNT > 23\n    palette[23] = vec3(1.0,0.5,1.0);\n    #endif\n    #if PALETTE_COUNT > 24\n    palette[24] = vec3(1.0,0.5,0.5);\n    #endif\n    #if PALETTE_COUNT > 25\n    palette[25] = vec3(1.0,1.0,0.5);\n    #endif\n    #if PALETTE_COUNT > 26\n    palette[26] = vec3(1.0,0.0,0.5);\n    #endif\n\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float d = floor( uv.x * 5.0 ) * 0.2;\n    vec2 tex_uv = fragCoord.xy / iResolution.xy;\n    #if MOVE_PIC\n    tex_uv.x -= d - 0.4 + 0.4 * sin( iTime * 3.14159 * 0.1 );\n    #else\n    tex_uv.x -= d - 0.1 - 0.435;\n    #endif\n    vec3 hc = texture(iChannel0, tex_uv).rgb;\n    \n    fragColor.rgb = hc = clamp(hc,vec3(0.0),vec3(1.0));\n    \n    \n    if ( uv.x > 0.2 )\n    {\n        int id0 = -1;\n        int id1 = -1;\n        int id2 = -1;\n        int id3 = -1;\n        float p0 = -10.0,\n              p1 = -10.0,\n              p2 = -10.0,\n              p3 = -10.0;\n        float rank = -1.0;\n        for ( int i = 0; i != palette.length(); ++i )\n        {\n            for ( int j = i+1; j != palette.length(); ++j )\n            {\n                for ( int k = j+1; k != palette.length(); ++k )\n                {\n                    for ( int l = k+1; l != palette.length(); ++l )\n                    {\n                        mat4 D0 = mat4(vec4(palette[i],1.0),\n                                       vec4(palette[j],1.0),\n                                       vec4(palette[k],1.0),\n                                       vec4(palette[l],1.0));\n                        mat4 D1 = mat4(vec4(hc,1.0),\n                                       vec4(palette[j],1.0),\n                                       vec4(palette[k],1.0),\n                                       vec4(palette[l],1.0));\n                        mat4 D2 = mat4(vec4(palette[i],1.0),\n                                       vec4(hc,1.0),\n                                       vec4(palette[k],1.0),\n                                       vec4(palette[l],1.0));\n                        mat4 D3 = mat4(vec4(palette[i],1.0),\n                                       vec4(palette[j],1.0),\n                                       vec4(hc,1.0),\n                                       vec4(palette[l],1.0));\n                        mat4 D4 = mat4(vec4(palette[i],1.0),\n                                       vec4(palette[j],1.0),\n                                       vec4(palette[k],1.0),\n                                       vec4(hc,1.0));\n                        float d0 = determinant(D0);\n                        float d1 = determinant(D1);\n                        float d2 = determinant(D2);\n                        float d3 = determinant(D3);\n                        float d4 = determinant(D4);\n                        \n                        float _rank = 0.0;\n                        #if 1\n                        #define DZ_V 10.\n                        #define DNZ_V 0.\n                        #else\n                        #define DZ_V 0.\n                        #define DNZ_V 10.\n                        #endif\n                        #define RANGE_COMP 0\n                        #if RANGE_COMP\n                        _rank += abs( d1 ) <= 0.001 ? DZ_V : DNZ_V;\n                        _rank += abs( d2 ) <= 0.001 ? DZ_V : DNZ_V;\n                        _rank += abs( d3 ) <= 0.001 ? DZ_V : DNZ_V;\n                        _rank += abs( d4 ) <= 0.001 ? DZ_V : DNZ_V;\n                        if ( abs( d0 ) <= 0.0000001 || _rank <= rank )\n                        {\n                            continue;\n                        }\n                        if ( ( sign(d0) == sign(d1) || abs( d1 ) <= 0.1 ) &&\n                             ( sign(d0) == sign(d2) || abs( d2 ) <= 0.1 ) &&\n                             ( sign(d0) == sign(d3) || abs( d3 ) <= 0.1 ) &&\n                             ( sign(d0) == sign(d4) || abs( d4 ) <= 0.1 )\n                            //&& abs( d0 - ( d1 + d2 + d3 + d4 ) ) < 0.000001\n                           )\n                        #else\n                        _rank += d1 == 0.0 ? DZ_V : DNZ_V;\n                        _rank += d2 == 0.0 ? DZ_V : DNZ_V;\n                        _rank += d3 == 0.0 ? DZ_V : DNZ_V;\n                        _rank += d4 == 0.0 ? DZ_V : DNZ_V;\n                        \n                        if ( abs( d0 ) <= 0.0000001 || _rank <= rank )\n                        {\n                            continue;\n                        }\n                        if ( ( sign(d0) == sign(d1) || d1 == 0.0 ) &&\n                             ( sign(d0) == sign(d2) || d2 == 0.0 ) &&\n                             ( sign(d0) == sign(d3) || d3 == 0.0 ) &&\n                             ( sign(d0) == sign(d4) || d4 == 0.0 )\n                            //&& abs( d0 - ( d1 + d2 + d3 + d4 ) ) < 0.000001\n                           )\n                        #endif\n                        {\n                            id0 = i;\n                            id1 = j;\n                            id2 = k;\n                            id3 = l;\n                            p0 = d1/d0;\n                            p1 = d2/d0;\n                            p2 = d3/d0;\n                            p3 = d4/d0;\n                            rank = _rank;\n                        }\n                    }\n                }\n            }\n        }\n\n        p0 = abs( p0 );\n        p1 = abs( p1 );\n        p2 = abs( p2 );\n        p3 = abs( p3 );\n        p1 += p0;\n        p2 += p1;\n        p3 += p2;\n        p0 /= p3;\n        p1 /= p3;\n        p2 /= p3;\n        p3 /= p3;\n        vec3 COLOR_0 = vec3(0.0);\n        vec3 COLOR_1 = vec3(0.0);\n        vec3 COLOR_2 = vec3(0.0);\n        vec3 COLOR_3 = vec3(0.0);\n        #if 1\n        for ( int i = 0; i != palette.length(); ++i )\n        {\n            COLOR_0 = i == id0 ? palette[i] : COLOR_0;\n            COLOR_1 = i == id1 ? palette[i] : COLOR_1;\n            COLOR_2 = i == id2 ? palette[i] : COLOR_2;\n            COLOR_3 = i == id3 ? palette[i] : COLOR_3;\n        }\n        #else\n        COLOR_0 = palette[id0];\n        COLOR_1 = palette[id1];\n        COLOR_2 = palette[id2];\n        COLOR_3 = palette[id3];\n        #endif\n    \n        \n        #if PATTERN_RELATIVE_TO_PIC\n         #define MASK_COORD ( iResolution.xy * tex_uv )\n        #else\n         #define MASK_COORD fragCoord\n        #endif\n        \n        #if FIXED_PATTERN\n         #define PER_FRAME(a) a\n         #define PER_FRAME_MASK\n         #define PER_FRAME4\n         #define PER_FRAME_GOLD\n        #else\n         #define PER_FRAME(uv) ( (uv) + texture(iChannel2, vec2(mod1(t/iChannelResolution[2].x), mod1(mod(t,iChannelResolution[2].x) ) ) ).xy )\n         //( rotate( uv - vec2(0.5), iTime * 6.2831 ) + vec2(0.5) )\n         #define PER_FRAME_MASK(uv) PER_FRAME(uv)\n         #define PER_FRAME4 +iTime*120.0\n         #define PER_FRAME_GOLD + round( (  ( texture(iChannel2, vec2(mod1(t/iChannelResolution[2].x), mod1(mod(t,iChannelResolution[2].x) ) ) ).xy * 2.0 - 1.0 ) * 64.0 ) )\n        #endif\n               \n        float t = iTime;\n        vec2 guv = ( MASK_COORD PER_FRAME_GOLD );\n        vec2 ruv = PER_FRAME( MASK_COORD / iChannelResolution[1].xy );\n        vec2 ruvb = PER_FRAME( MASK_COORD / iChannelResolution[3].xy );\n        float m =\n           uv.x < 0.4 ? golden_noise( guv):\n         ( uv.x < 0.6 ? texture(iChannel1, ruv ).r :\n         ( uv.x < 0.8 ? mask( PER_FRAME( MASK_COORD ) ) :\n           texture(iChannel3, ruvb ).r\n            ) );\n\n        vec3 DEFAULT = vec3(0.0,1.0,1.0);\n        DEFAULT = COLOR_3;\n\t\tfragColor.rgb = m <= p0 ? COLOR_0 :\n        ( m <= p1 ? COLOR_1 :\n         ( m <= p2 ? COLOR_2 :\n          ( m <= p3 ? COLOR_3 : DEFAULT ) ) );\n        \n\t\t#if SHOW_THE_MASK            \n\t\tfragColor.rgb = vec3(m);\n        #endif\n    }\n}\n","name":"Image","description":"","type":"image"}]}