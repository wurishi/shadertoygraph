{"ver":"0.1","info":{"id":"7ttSD4","date":"1639942790","viewed":360,"name":"Tamby's Christmas Balls","username":"TambakoJaguar","description":"For this year, I've made a Christmas Shader! ;)\nI hope you like it! I know it's not that optimized, maybe you could help me to do it?\nUse the mouse to look around.","likes":18,"published":1,"flags":16,"usePreview":0,"tags":["3d","cute","mouse","christmas","colorful","sky","balls","animated","reflections","cables","hanging","prettc"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\"Tamby's Christmas Balls\" by Emmanuel Keller aka Tambako - December 2021\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n\nTodo:\n* Add random color variation\n* More patterns\n* Improve crown geometry\n* Improve thread geometry\n- (Snow flakes?)\n- Optimize render speed and compile speed\n*/\n\n// Switches, you can play with them!\n#define specular\n#define reflections\n#define double_balls\n#define complex_crown\n#define complex_thread\n//#define captmode\n\n#define pi 3.14159265359\n\n#ifdef captmode\nconst float KEY_1\t\t= 97.5/256.0;\nconst float KEY_2\t\t= 98.5/256.0;\nconst float KEY_3\t\t= 99.5/256.0;\nconst float KEY_4\t\t= 100.5/256.0;\nconst float KEY_5\t\t= 101.5/256.0;\nconst float KEY_6\t\t= 102.5/256.0;\nconst float KEY_7\t\t= 103.5/256.0;\nconst float KEY_8\t\t= 104.5/256.0;\nconst float KEY_9\t\t= 105.5/256.0;\n#endif\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\n//#define antialias\nconst float aawidth = 0.8;\nconst int aasamples = 4;\n\n// Ambient light\nconst vec3 ambientColor = vec3(1.);\nconst float ambientint = 0.35;\n\n// Specular options\nconst float specint = 0.31;\nconst float specshin = 80.;\n\n// Shadow options\nconst float shi = 0.5;\n\n// Tracing options\nconst float normdelta = 0.0005;\nconst float maxdist = 400.;\n\n// Color options\nconst float gamma = 1.5;\nconst float brightness = 1.2;\nconst vec3 crown_color = vec3(0.8);\nconst vec3 thread_color = vec3(0.3);\n\nconst float color_variation = 0.33;\n\n// Geometry options\nconst float ball_diameter = 2.;\nconst float crown_diameter = 0.3;\nconst float crown_height = 0.25;\nconst float thread_diameter = 0.05;\n\nconst float size_variation = 0.5;\nconst float height_variation = 22.;\nconst float pos_variation = 0.25;\n\nconst float repeat_step = 7.;\n\nconst float twist1 = 2.8;\nconst float stripefreq1 = 6.4;\n\nconst float twist2 = 2.;\nconst float stripefreq2 = 4.6;\n\nconst float twist3 = 1.1;\nconst float stripefreq3 = 12.;\n\n// Campera options\nvec3 campos;\nvec3 camtarget;\nvec3 camdir = vec3(0., 0., 0.);\nfloat fov = 2.2;\n\nconst float fogdens = 0.0115;\n\nstruct DirLamp\n{\n  vec3 direction;\n  vec3 color;\n  float intensity;\n};\n\nstruct RenderData\n{\n  \tvec3 col;\n  \tvec3 pos;\n  \tvec3 norm;\n  \tint objnr;\n    float dist;\n};\n   \n// Every object of the scene has its ID\n#define SKY_OBJ       0\n#define BALL_OBJ_1    1\n#define CROWN_OBJ_1   2\n#define THREAD_OBJ_1  3\n#define BALL_OBJ_2    4\n#define CROWN_OBJ_2   5\n#define THREAD_OBJ_2  6\n    \nDirLamp lamps[3];\nvec3 colors[6];\n\nint aai;\nint aaj;\n\nfloat curtime;\n\n#ifdef captmode\nint num_key;\nint isKeyPressed(float key)\n{\n\treturn texture(iChannel0, vec2(key, 0.25) ).x > .0?1:0;\n}\n#endif\n\nvoid init()\n{    \n    lamps[0] = DirLamp(vec3(-2.5, 1., -4.), vec3(1., .92, .45), 0.7);\n    lamps[1] = DirLamp(vec3(2., 3., -4.), vec3(0.4, 0.6, 1.), 1.2);\n    lamps[2] = DirLamp(vec3(2., -1., 4.), vec3(1., 1., 1.), 1.22);\n   \n    colors[0] = vec3(1., 0.4, 0.3);\n    colors[1] = vec3(1., 0.8, 0.3);\n    colors[2] = vec3(1., 0.8, 0.3);\n    colors[3] = vec3(0.85, 0.85, 0.85);\n    colors[4] = vec3(0.3, 0.35, 1.0);\n    colors[5] = vec3(0.1, 0.85, 0.15);\n    \n    #ifdef captmode\n    num_key = isKeyPressed(KEY_1) + 2*isKeyPressed(KEY_2) + 3*isKeyPressed(KEY_3);\n    num_key+= 4*isKeyPressed(KEY_4) + 5*isKeyPressed(KEY_5) + 6*isKeyPressed(KEY_6);\n    num_key+= 7*isKeyPressed(KEY_7) + 8*isKeyPressed(KEY_8) + 9*isKeyPressed(KEY_9);\n    \n    curtime = 14.; \n    #else\n    curtime = -5.5*(iTime + 0.028*iTime*iTime);\n    #endif    \n}\n\n// Union operation from iq\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n// 1D hash function\nfloat hash(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 333.33;\n    p *= p + p;\n    return fract(p);\n}\n\n// From https://www.shadertoy.com/view/4sfGzS\nfloat noise(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix(hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix(hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix(hash(n+113.0), hash(n+114.0),f.x),\n                   mix(hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat getBallSize(vec3 pos)\n{\n    pos.xz+= vec2(repeat_step*0.5, repeat_step*0.5);\n    vec2 bp = floor(pos.xz/repeat_step);\n    \n    return size_variation*hash(bp.x*545.741 + bp.y*843.275) - size_variation*0.5 + 1.;\n}\n\nvec3 getBallPos(vec3 pos)\n{\n    pos.xz+= vec2(repeat_step*0.5, repeat_step*0.5);\n    vec2 bp = floor(pos.xz/repeat_step);\n    \n    float bpx = repeat_step*(2.*pos_variation*hash(bp.x*811.659 + bp.y*436.152) - pos_variation);\n    float bpy = 2.*height_variation*hash(bp.x*344.175 + bp.y*258.149) - height_variation;\n    float bpz = repeat_step*(2.*pos_variation*hash(bp.x*248.632 + bp.y*574.694) - pos_variation);\n    \n    return vec3(bpx, bpy, bpz);\n}\n\nfloat map_ball(vec3 pos, float size)\n{\n   return min(length(pos) - ball_diameter*size*0.5, ball_diameter);\n   //return length(pos) - ball_diameter*size*0.5;\n}\n\nfloat map_crown(vec3 pos, float size)\n{\n   #ifdef complex_crown\n   float a = atan(pos.x, pos.z); // + twist*pos.y;\n   float s = sin(9.*a);   \n\n   float crown = length(pos.xz) - crown_diameter*0.5 + 0.12*(pos.y - ball_diameter*size*0.5 - 0.2) + 0.008*s - 0.04*smoothstep(ball_diameter*size*0.5 + 0.12, ball_diameter*size*0.5, pos.y);\n   crown = max(crown, pos.y - ball_diameter*size*0.5 - crown_height);\n   crown = max(crown, -pos.y + ball_diameter*size*0.5 - 0.02*s*smoothstep(crown_diameter*0.25, crown_diameter*0.5, length(pos.xz)));\n   #else\n   float crown = length(pos.xz) - crown_diameter*0.5;\n   crown = max(crown, pos.y - ball_diameter*size*0.3 - crown_height);\n   crown = max(crown, -pos.y);   \n   #endif\n   \n   return min(crown, ball_diameter);\n   //return crown;\n}\n\nfloat map_thread(vec3 pos)\n{\n   #ifdef complex_thread\n   float a = atan(pos.x, pos.z) + 15.*pos.y;\n   float s = abs(sin(3.*a));\n   \n   float thread = length(pos.xz) - thread_diameter*(0.5 + 0.08*s);\n   thread = max(thread, -pos.y);   \n   #else\n   float thread = length(pos.xz) - thread_diameter*0.5;\n   thread = max(thread, -pos.y);   \n   #endif\n   \n   return min(thread, ball_diameter);\n   //return thread;\n}\n\nvec2 map(vec3 pos)\n{\n    vec3 pos1 = pos;\n    vec3 pos2 = pos;\n\n    float size1 = getBallSize(pos);\n    vec3 ballpos1 = getBallPos(pos);\n    \n    pos1-= ballpos1;\n\n    pos1.xz+= vec2(repeat_step*0.5, repeat_step*0.5);\n    pos1.xz = mod(pos1.xz, repeat_step);\n    pos1.xz-= vec2(repeat_step*0.5, repeat_step*0.5);\n\n    float ball1 = map_ball(pos1, size1);\n    vec2 res = vec2(ball1, BALL_OBJ_1);\n    \n    float crown1 = map_crown(pos1, size1);\n    res = opU(res, vec2(crown1, CROWN_OBJ_1));\n    \n    float thread1 = map_thread(pos1);\n    res = opU(res, vec2(thread1, THREAD_OBJ_1));\n    \n    #ifdef double_balls\n    \n    float size2 = getBallSize(pos + vec3(50.5*repeat_step, 0., 50.5*repeat_step));\n    vec3 ballpos2 = getBallPos(pos + vec3(80.5*repeat_step, 0., 80.5*repeat_step));\n    \n    pos2-= ballpos2;\n\n    pos2.xz = mod(pos2.xz, repeat_step);\n    pos2.xz-= vec2(repeat_step*0.5, repeat_step*0.5);\n\n    float ball2 = map_ball(pos2, size2);\n    res = opU(res, vec2(ball2, BALL_OBJ_2));\n    \n    float crown2 = map_crown(pos2, size2);\n    res = opU(res, vec2(crown2, CROWN_OBJ_2));\n    \n    float thread2 = map_thread(pos2);\n    res = opU(res, vec2(thread2, THREAD_OBJ_2));    \n    \n    #endif\n\n    return res;\n}\n\n// Main tracing function\nvec2 trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = 0.008;\n    float objnr = 0.;\n    vec3 pos;\n    float dist;\n    \n  \tfor (int i = 0; i < 105; ++i)\n    {\n    \tpos = ray*t + cam;\n        vec2 res = map(pos);\n        dist = res.x;\n        if (dist>maxdist || abs(dist)<0.0005)\n            break;\n        t+= dist;\n        objnr = abs(res.y);\n  \t}\n  \treturn vec2(t, objnr);\n}\n\nfloat getBallNormal(vec3 pos, int objnr)\n{\n    if (objnr==BALL_OBJ_2)\n        pos.xz+= vec2(repeat_step*45., repeat_step*35.);\n    else if (objnr==BALL_OBJ_1)\n        pos.xz+= vec2(repeat_step*0.5, repeat_step*0.5);\n    else return 0.;\n    \n    vec2 bp = floor(pos.xz/repeat_step);\n    int type = int(7.*hash(bp.x*951.147 + bp.y*154.698));\n    \n    if (type==3)\n        return smoothstep(0.0, 0.9, noise(vec3(pos.x*2. + pos.y*2., pos.y*10. - pos.x*10., pos.z*2.)));\n    else\n        return 0.;\n}\n\nvec3 getNormal(vec3 pos, float e, int objnr)\n{  \n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e2 = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e2*(map(pos + e*e2).x + 0.02*getBallNormal(pos + e*e2, objnr));\n    }\n    return normalize(n);\n}\n\n// Gets the color of the sky\nvec3 getSkyColor(vec3 ray)\n{ \n    return 1.1*mix(vec3(clamp(0.1 + ray.y*0.6, 0., 0.7), clamp(0.2 - ray.y*0.6, 0., 0.4) + 0.23*(smoothstep(0., 0.4, ray.y) - smoothstep(0.4, 0.9, ray.y)), clamp(0.3 - ray.y*1.2, 0., 0.6)), vec3(0.9), 0.35);\n}\n\nvec3 getColorVariation(vec2 bp, float f)\n{\n    float rv = color_variation*(hash(bp.x*f*475.268 + bp.y*f*864.125) - 0.5);\n    float gv = color_variation*(hash(bp.x*f*632.175 + bp.y*f*124.759) - 0.5);\n    float bv = color_variation*(hash(bp.x*f*584.957 + bp.y*f*378.155) - 0.5);\n    return vec3(rv, gv, bv);\n    return vec3(0.);\n}\n\nfloat getTwist(vec3 pos, float freq, float twist, float center, bool second)\n{\n    vec3 posc = pos;\n    if (second)\n       posc-= getBallPos(posc + vec3(80.5*repeat_step, 0., 80.5*repeat_step));\n    else\n       posc-= getBallPos(posc);\n    if (!second)\n        posc.xz+= vec2(repeat_step*0.5, repeat_step*0.5);\n    posc.xz = mod(posc.xz, repeat_step);\n    posc.xz-= vec2(repeat_step*0.5, repeat_step*0.5);\n    \n    float a = atan(posc.x, posc.z) + twist*posc.y;\n    float s = sin(freq*a);\n    return smoothstep(center - 0.02, center + 0.02, s);\n}\n\nfloat star(vec3 pos, float r1, float sf, float nb, bool second)\n{\n    float bs = 0.001;\n    float bw = 0.006;\n    \n    vec3 posc = pos;\n    if (second)\n       posc-= getBallPos(posc + vec3(80.5*repeat_step, 0., 80.5*repeat_step));\n    else\n       posc-= getBallPos(posc);\n    if (!second)\n        posc.xz+= vec2(repeat_step*0.5, repeat_step*0.5);\n    posc.xz = mod(posc.xz, repeat_step);\n    posc.xz-= vec2(repeat_step*0.5, repeat_step*0.5);\n    float a;\n    vec2 uv;\n    if (second)\n    {\n       a = (mod(atan(posc.x, posc.z), pi/4.) - pi/8.)/1.8;\n       uv = vec2(a, 0.6*posc.y);\n    }\n    else\n    {\n       a = (mod(atan(posc.x, posc.z)*2.5 - (abs(posc.y)<0.6 && abs(posc.y)>0.2?pi/8.:0.), pi/4.) - pi/8.)/1.8;\n       posc.y = mod(clamp(posc.y + 0.2, -0.45, 0.75), 0.4) - 0.15;\n       uv = vec2(a, 1.2*posc.y);\n    }\n\n    float alpha1 = mod(atan(uv.x, uv.y), 2.*pi/nb);\n    float alpha2 = mod(2.*pi/nb-atan(uv.x, uv.y), 2.*pi/nb);\n    float alpha = alpha1<pi/nb?alpha2:alpha1;\n    float f = sf*length(uv)*cos(alpha)/cos(pi/nb) - length(uv)*(sf-1.);\n    float v = smoothstep(r1 - bs, r1 + bs, f);\n    return v;\n}\n\nvec3 getBallColor(vec3 pos, bool second)\n{\n    vec3 pos2 = pos;\n    if (second)\n        pos2.xz+= vec2(repeat_step*45., repeat_step*35.);\n    else\n        pos2.xz+= vec2(repeat_step*0.5, repeat_step*0.5);\n    vec2 bp = floor(pos2.xz/repeat_step);\n    \n    int type = int(7.*hash(bp.x*951.147 + bp.y*154.698));\n    \n    int coln1 = int(6.*hash(bp.x*842.345 + bp.y*763.236));\n    int coln2 = int(6.*hash(bp.x*162.569 + bp.y*417.693));\n    if (coln1==coln2)\n        coln2 = int(6.*hash(bp.x*647.158 + bp.y*125.658));\n    vec3 colvar1 = getColorVariation(bp, 3.3);\n    vec3 colvar2 = getColorVariation(bp, 5.5);\n\n    if (type==0) // Solid color\n        return colors[coln1] + colvar1;\n    if (type==1) // Twist right\n        return mix(colors[coln1] + colvar1, colors[coln2] + colvar2, getTwist(pos, stripefreq1, twist1, 0., second));    \n    if (type==2) // Twist left\n        return mix(colors[coln1] + colvar1, colors[coln2] + colvar2, getTwist(pos, stripefreq2, -twist2, 0., second));    \n    if (type==3) // Bumpy\n        return mix(colors[coln1] + colvar1, colors[coln2] + colvar2, smoothstep(0.0, 0.9, noise(vec3(pos.x*2. + pos.y*2., pos.y*10. - pos.x*10., pos.z*2.))));        \n    if (type==4) // Double twist (checker)\n        return mix(colors[coln1] + colvar1, colors[coln2] + colvar2, max(getTwist(pos, stripefreq3, twist3, 0.8, second), getTwist(pos, stripefreq3, -twist3, 0.8, second)));    \n    if (type==5) // Circles\n    {\n        float sc = length(mod(pos, 0.3) - vec3(0.15)) - 0.1;\n        return mix(colors[coln1] + colvar1, colors[coln2] + colvar2, smoothstep(-0.01, 0.01, sc));\n    }\n    if (type==6) // Stars\n    {\n        float star1 = star(pos, second?0.1:0.08, second?1.7:1., second?7.:5., second);\n        return mix(colors[coln1] + colvar1, colors[coln2] + colvar2, star1);\n    }\n}\n\n// Combines the colors\nvec3 getColor(vec3 pos, int objnr, vec3 ray)\n{ \n   if (objnr==BALL_OBJ_1)\n      return getBallColor(pos, false);\n   if (objnr==CROWN_OBJ_1)\n      return crown_color;\n   if (objnr==THREAD_OBJ_1)\n      return thread_color;\n   if (objnr==BALL_OBJ_2)\n      return getBallColor(pos, true);\n   if (objnr==CROWN_OBJ_2)\n      return crown_color;\n   if (objnr==THREAD_OBJ_2)\n      return thread_color;         \n   else\n      return getSkyColor(ray);\n}\n\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat fresnel(vec3 ray, vec3 norm, float n2)\n{\n   float n1 = 1.; // air\n   float angle = acos(-dot(ray, norm));\n   float r0 = dot((n1-n2)/(n1+n2), (n1-n2)/(n1+n2));\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\n   return clamp(r, 0., 0.8);\n}\n\n// Shading of the objects pro lamp\nvec3 lampShading(DirLamp lamp, vec3 norm, vec3 pos, vec3 ocol, int objnr)\n{\n\tvec3 pl = normalize(lamp.direction);\n      \n    // Diffuse shading\n    vec3 col = ocol*lamp.color*lamp.intensity*clamp(dot(norm, pl), 0., 1.);\n    \n    // Specular shading\n    #ifdef specular\n    if (dot(norm, lamp.direction) > 0.0)\n        col+= lamp.color*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    return col;\n}\n\n// Shading of the objects over all lamps\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, int objnr)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<3; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol, objnr);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\n// Sets the position of the camera with the mouse and calculates its direction\nconst float axm = 2.*pi;\nconst float aym = 0.8;\nvoid setCamera()\n{\n   vec2 iMouse2;\n\n   #ifdef captmode\n   iMouse2 = vec2(0.5, 0.43);\n   #else\n   if (iMouse.x==0. && iMouse.y==0.)\n      iMouse2 = vec2(0.5, 0.4);\n   else\n      iMouse2 = iMouse.xy/iResolution.xy;\n   #endif      \n   \n   campos = vec3(0.4, 3., curtime);\n   camdir = vec3(3.6*iMouse2.x - 1.75, -3.5*iMouse2.y + 1.5, -1.); \n}\n\n// Tracing and rendering a ray\nRenderData trace0(vec3 tpos, vec3 ray, float maxdist)\n{\n    vec2 tr = trace(tpos, ray, maxdist);\n    float tx = tr.x;\n    int objnr = int(tr.y);\n    vec3 col;\n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    \n    if (tx<maxdist*0.5)\n    {\n        norm = getNormal(pos, normdelta, objnr);\n        col = getColor(pos, objnr, ray);\n      \n        // Shading\n        col = col*ambientColor*ambientint + lampsShading(norm, pos, col, objnr);\n    }\n    else\n    {\n        objnr = SKY_OBJ;\n        col = getSkyColor(ray);\n    }\n    return RenderData(col, pos, norm, objnr, tx);\n}\n\n// Main render function with reflections and refractions\nvec4 render(vec2 fragCoord)\n{   \n  \tvec2 uv = fragCoord.xy / iResolution.xy; \n  \tuv = uv*2.0 - 1.0;\n  \tuv.x*= iResolution.x / iResolution.y;\n    float fov2 = fov;\n    \n    #ifdef captmode\n    if (num_key>0)\n    {\n        fov2*= 3.;\n        uv.x+= 2.*(iResolution.x / iResolution.y)*(mod(float(num_key - 1), 3.) - 1.);\n        uv.y+= 2.*(float((num_key - 1)/3) - 1.);\n    }\n    #endif    \n\n  \tvec3 ray = GetCameraRayDir(uv, camdir, fov2);\n  \tRenderData traceinf = trace0(campos, ray, maxdist);\n  \tvec3 col = traceinf.col;\n    \n    #ifdef reflections\n    float rf;\n    if (traceinf.objnr!=SKY_OBJ && traceinf.objnr!=THREAD_OBJ_1 && traceinf.objnr!=THREAD_OBJ_2)\n    {\n       rf = 0.8 + 0.2*fresnel(ray, traceinf.norm, 3.2);\n       vec3 refray = reflect(ray, traceinf.norm);\n        \n       RenderData traceinfr = trace0(traceinf.pos, refray, maxdist*0.5);\n       float distr = traceinfr.dist;     \n       float fogdr = clamp(exp(-pow(fogdens*distr*3., 2.)), 0., 1.);\n       \n       vec3 refray2 = reflect(refray, traceinfr.norm);\n       vec3 refcol2 = mix(traceinfr.col*getSkyColor(refray2), traceinfr.col, 0.2);\n       vec3 colr = mix(getSkyColor(refray), refcol2, fogdr);            \n        \n       col = mix(1.3*col, mix(traceinf.col, vec3(1.), 0.3)*colr, rf);      \n    }\n    #endif\n    \n    float dist = traceinf.dist;     \n    float fogd = clamp(exp(-pow(fogdens*dist, 2.)), 0., 1.);\n    col = mix(getSkyColor(ray), col, fogd);    \n    \n  \treturn vec4(brightness*pow(col, vec3(gamma)), 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    init();\n    setCamera();\n    \n    // Antialiasing\n    #ifdef antialias\n    vec4 vs = vec4(0.);\n    for (aaj=0;aaj<aasamples ;aaj++)\n    {\n       float oy = float(aaj)*aawidth/max(float(aasamples-1), 1.);\n       for (aai=0;aai<aasamples ;aai++)\n       {\n          float ox = float(aai)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    fragColor = vs/vec4(aasamples*aasamples);\n    #else\n    fragColor = vec4(render(fragCoord));\n    #endif\n}","name":"Image","description":"","type":"image"}]}