{"ver":"0.1","info":{"id":"ctfBDj","date":"1693428455","viewed":38,"name":"Sketch #10: Warped Lines","username":"MOONtyzoo","description":"Inspired by code from https://thebookofshaders.com/11/\n\nI'm surprised that rotating space by the noise value gives you a continuous output. This is black magic.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sketch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358\n\nfloat smoothmix(float a, float b, float x)\n{\n    return (1.0-smoothstep(0.0, 1.0, x))*a + smoothstep(0.0, 1.0, x)*b;\n}\n\nmat2 rotate2D(float angle)\n{\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));\n}\n\nfloat lines(in vec2 uv, in float size, in float density)\n{\n    uv = fract(uv*density);\n    return smoothstep(0.0, size*0.05, abs(uv.x-0.5));\n}\n\nfloat random(float x)\n{\n    return fract(439029.0*sin(x));\n}\n\nfloat random(vec2 uv)\n{\n    return fract(439029.0*sin(dot(uv, vec2(85.3876, 9.38532))));\n}\n\nvec2 randomGradientVec(vec2 uv)\n{\n    float angle = 2.0*PI*random(uv);\n    return vec2(cos(angle), sin(angle));\n}\n\nfloat noise(in vec2 uv, in float sampleNum)\n{\n    /*\n        Creates gradients at sample points\n        \n        Quadrants 1, 2, 3, 4 correspond to letters d, c, a, b\n    */\n    vec2 uv_i = floor(uv*sampleNum);\n    vec2 uv_f = fract(uv*sampleNum);\n    float time_i = floor(iTime);\n    float time_f = fract(iTime);\n    \n    vec2 gradA = randomGradientVec(uv_i);\n    vec2 gradB = randomGradientVec(uv_i + vec2(1.0, 0.0));\n    vec2 gradC = randomGradientVec(uv_i + vec2(0.0, 1.0));\n    vec2 gradD = randomGradientVec(uv_i + vec2(1.0, 1.0));\n    \n    /*\n        Dot product and interpolation to get noise value at each pixel\n    */\n    float valA = dot(uv_f, gradA);\n    float valB = dot(uv_f - vec2(1.0, 0.0), gradB);\n    float valC = dot(uv_f - vec2(0.0, 1.0), gradC);\n    float valD = dot(uv_f - vec2(1.0, 1.0), gradD);\n    float valAB = smoothmix(valA, valB, uv_f.x);\n    float valBC = smoothmix(valC, valD, uv_f.x);\n    float val = 0.8*smoothmix(valAB, valBC, uv_f.y) + 0.5;\n    \n    return val;\n}\n\n//  Function from IÃ±igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n\n// ------------------------------------------------------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    /*\n        Control variables\n    */\n    float noiseScale = 3.0;\n    \n    /*\n        Warp space then draw lines\n    */\n    float originalNoise = noise(uv, noiseScale);\n    uv = rotate2D((0.5*sin(iTime)+0.5)*noise(uv, noiseScale))*uv;\n    float lines = lines(uv + 0.1*iTime, 8.0, 20.0);\n    \n    /*\n        Coloring\n        \n        The white and red values correspond to noise values (0 to 1 respectively) that are warping the space\n        My guess is that the white values have no rotation while the red values are rotated most\n    */\n    vec3 HSV = vec3(0.0, 0.0, 0.0);\n    HSV[0] = 0.0;\n    HSV[1] = 0.4*originalNoise;\n    HSV[2] = lines;\n    vec3 color = hsv2rgb(HSV);\n    \n    fragColor = vec4(vec3(color), 1.0);\n}","name":"Image","description":"","type":"image"}]}