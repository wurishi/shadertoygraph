{"ver":"0.1","info":{"id":"dlc3DX","date":"1683220678","viewed":91,"name":"physical 2 digital #WCCChallenge","username":"epibyte","description":"Neon Love for the WCCChallenge","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["neon","wccchallenge"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Physical to digital #WCChallenge contribution\n//\n// Dear fellow creative coding community\n// im in love with neon bar installations and renderings not only since Zach.\n// Still having my issues with shaders, but slowly progressing.\n// Its a major speed enhanement in relation to p5js and processing.\n// The color of the neon bars will change via noise()\n//\n// Change line 166 for noise field neon bar distribution + rotation.\n//\n// Another example with animated \"<3\" integrated in p5js: \n// https://editor.p5js.org/boettcher.f/full/nISSJX0-i\n\n#define PI 3.14159265\n\n/**\n * NeonBar\n */\n\nstruct NeonBar{\n  vec2 pos;  // position\n  float len; // length\n  float ang; // angle\n  float dag; // delta angle\n  float cag; // curr angle\n  vec3 clr;  // color rgb\n  float its; // intensity\n};\n\nNeonBar createBar(vec2 pos, float len, float angle, float deltaAngle, vec3 color, float intense) {\n    NeonBar bar;\n    bar.pos = pos;\n    bar.len = len;\n    bar.ang = angle;\n    bar.dag = deltaAngle;\n    bar.cag = angle;\n    bar.clr = color;\n    bar.its = intense;\n    return bar;\n}\n\nvoid barSetAngle( inout NeonBar bar, in float time) {\n    bar.cag = bar.ang + bar.dag * time;\n}\n\n/**\n * Rand & Noise\n */\n\nfloat random ( in vec2 st ) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))*43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d // https://www.shadertoy.com/view/4dS3Wd\nfloat noise ( in vec2 st ) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n// dist from rotating spot point center, radius, angle\nfloat distCircRad( in vec2 uv, in vec2 c, in float r, in float a) {\n   vec2 p = c + vec2(cos(a), sin(a)) * r;\n   return length(uv - p);\n}\n\n// dist from segment point a, point b\nfloat distSegment( in vec2 p, in vec2 a, in vec2 b ) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return max(0., length( pa - ba*h ));\n}\n\n// clr for NeonBar\nvec3 clrNeonBar( in vec2 p, in NeonBar bar ) {\n    // float angle = bar.ang + bar.dag * time;\n    vec2 w = vec2(cos(bar.cag),sin(bar.cag)) * bar.len * 0.5;\n    vec2  a = bar.pos + w;\n    vec2  b = bar.pos - w;\n    float d = distSegment(p, a, b);\n    float br =  bar.its / d;\n    br = min(1.86, br); // reduce overglue\n    // br = smoothstep(.001, 0.91, br);\n    return vec3(br) * bar.clr; \n}\n\n// TODO: intersections, in progress\n\nbool intersectsA(vec2 ro, vec2 rd, NeonBar bar) {\n    // abcd ray1, pqrs ray2\n    float det, gamma, lambda;\n    float a = ro.x;\n    float b = ro.y;\n    float c = a + rd.x;\n    float d = b + rd.y;\n    \n    vec2 w0 = vec2(cos(bar.ang),sin(bar.ang)) * bar.len * 0.5;\n    vec2 p1 = bar.pos + w0;\n    vec2 p2 = bar.pos - w0;\n    float p = p1.x;\n    float q = p1.y;\n    float r = p2.x;\n    float s = p2.y;\n    \n    \n    det = (c - a) * (s - q) - (r - p) * (d - b);\n    if (abs(det) < .0001) {\n      return false; // negative = no intersection\n    } else {\n      lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;\n      gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;\n      // print(lambda, gamma);\n      // print(lambda*(c-a)+a, lambda*(d-b)+b)\n      return 0. < lambda && lambda < 1. && 0. < gamma && gamma < 1.;\n    }\n}\n\n// bool intersects(vec2 p, vec2 q, vec2 r, vec2 s) {\nbool intersects(vec2 uv, NeonBar bar, NeonBar other) {\n    vec2 w = vec2(cos(bar.cag),sin(bar.cag)) * bar.len * 0.5;\n    vec2 p1 = bar.pos + w;\n    vec2 p2 = bar.pos - w;\n    \n    return intersectsA(uv, p1 - uv, other) || intersectsA(uv, p2 - uv, other);\n}\n\nvec3 getColor(vec2 pos, float iTime) {\n    float n = noise(pos);\n    return n < sin(iTime) * .5 ? vec3(.8, .2, .7) : n < sin(iTime) ? vec3(.2, .7, .8)  : vec3(0.9);\n}\n\n/**\n * Main fragment\n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - 0.5; // 0 center\n    uv.x *= iResolution.x / iResolution.y; // aspect ratio\n\n\n    // angle\n    float angle = iTime * 2.;\n\n    // define bars\n    NeonBar bars[50];\n    const int barsNum = 36; // bars.length(); not working\n    // NeonBar createBar(vec2 pos, float len, float angle, float deltaAngle, vec3 color, float intense)\n    int barIndex = 0;\n    if (true) {\n        vec2 pos;\n        vec3 col;\n        // N\n        pos = vec2(-.5, .25);\n        col = getColor(pos, iTime);\n        bars[barIndex++] = createBar(pos, 0.45, PI/2., .0, col, 0.005);\n        pos = vec2(-.3875, .25);\n        col = getColor(pos, iTime);\n        bars[barIndex++] = createBar(pos, 0.45, -PI/2.7 + iTime - sin(iTime*2.)/2., .0, col, 0.005);\n        pos = vec2(-.275, .25);\n        col = getColor(pos, iTime);\n        bars[barIndex++] = createBar(pos, 0.45, PI/2., .0, col, 0.005);\n        // E\n        pos = vec2(-.125, .375);\n        col = getColor(pos, iTime);\n        bars[barIndex++] = createBar(pos, 0.25, PI/4., .0, col, 0.005);\n        pos = vec2(-.125, .125);\n        col = getColor(pos, iTime);\n        bars[barIndex++] = createBar(pos, 0.25, -PI/4., .0, col, 0.005);\n        pos = vec2(-.125, .25);\n        col = getColor(pos, iTime);\n        bars[barIndex++] = createBar(pos, 0.15, .0, .0, col, 0.005);\n        // O\n        pos = vec2(.0625, .375);\n        col = getColor(pos, iTime);\n        bars[barIndex++] = createBar(pos, 0.2, PI/3., .0, col, 0.005);\n        pos = vec2(.0625, .125);\n        col = getColor(pos, iTime);\n        bars[barIndex++] = createBar(pos, 0.2, -PI/3., .0, col, 0.005);\n        pos = vec2(.1875, .375);\n        col = getColor(pos, iTime);\n        bars[barIndex++] = createBar(pos, 0.2, -PI/3., .0, col, 0.005);\n        pos = vec2(.1875, .125);\n        col = getColor(pos, iTime);\n        bars[barIndex++] = createBar(pos, 0.2, PI/3., .0, col, 0.005);\n        // N\n        pos = vec2(.275, .25);\n        col = getColor(pos, iTime);\n        bars[barIndex++] = createBar(pos, 0.45, PI/2., .0, col, 0.005);\n        pos = vec2(.3875, .25);\n        col = getColor(pos, iTime);\n        bars[barIndex++] = createBar(pos, 0.45, -PI/2.8, .0, col, 0.005);\n        pos = vec2(.5, .25);\n        col = getColor(pos, iTime);\n        bars[barIndex++] = createBar(pos, 0.45, PI/2., .0, col, 0.005);\n\n        // L\n        pos = vec2(-.5, -.25);\n        col = getColor(pos, iTime);\n        bars[barIndex++] = createBar(pos, 0.45, PI/2., .0, col, 0.005);\n        pos = vec2(-.375, -.475);\n        col = getColor(pos, iTime);\n        bars[barIndex++] = createBar(pos, 0.2, 0., .0, col, 0.005);\n        // O\n        pos = vec2(-.0625, -.375);\n        col = getColor(pos, iTime);\n        bars[barIndex++] = createBar(pos, 0.2, PI/3., .0, col, 0.005);\n        pos = vec2(-.0625, -.125);\n        col = getColor(pos, iTime);\n        bars[barIndex++] = createBar(pos, 0.2, -PI/3., .0, col, 0.005);\n        pos = vec2(-.1875, -.375);\n        col = getColor(pos, iTime);\n        bars[barIndex++] = createBar(pos, 0.2, -PI/3., .0, col, 0.005);\n        pos = vec2(-.1875, -.125);\n        col = getColor(pos, iTime);\n        bars[barIndex++] = createBar(pos, 0.2, PI/3., .0, col, 0.005);\n        // V\n        pos = vec2(.075, -.25);\n        col = getColor(pos, iTime);\n        bars[barIndex++] = createBar(pos, 0.45, -PI/2.3, .0, col, 0.005);\n        pos = vec2(.18, -.25);\n        col = getColor(pos, iTime);\n        bars[barIndex++] = createBar(pos, 0.45, PI/2.3, .0, col, 0.005);\n        // E\n        pos = vec2(.375, -.125);\n        col = getColor(pos, iTime);\n        bars[barIndex++] = createBar(pos, 0.25, PI/4., .0, col, 0.005);\n        pos = vec2(.375, -.375);\n        col = getColor(pos, iTime);\n        bars[barIndex++] = createBar(pos, 0.25, -PI/4., .0, col, 0.005);\n        pos = vec2(.375, -.25);\n        col = getColor(pos, iTime);\n        bars[barIndex++] = createBar(pos, 0.15, .0, .0, col, 0.005);\n    } else {\n        for (float y = -.5; y <= .51; y += .2) {\n            for (float x = -.5; x <= .51; x += .2) {\n                if (barIndex < barsNum) {\n                    vec2 pos = vec2(x + 0.05, y - 0.1);\n                    float n = noise(pos);\n                    vec3 col = n < sin(iTime) * .5 ? vec3(.8, .2, .7) : n < sin(iTime) ? vec3(.2, .7, .8)  : vec3(0.9);\n                    float da = floor((n * 10.) * 10.) < 5. ? -.1 : .1;\n                    bars[barIndex++] = createBar(pos, 0.1, PI/2., da, col, 0.005);\n                }\n            }\n        }\n    }\n\n\n    // background color\n    vec3 col = vec3(.0, .0, 0.1);\n    \n    float dd = distance(uv, vec2(0.));\n    // col += vec3(.01 / dd);\n\n\n// --> Segments <---------------------------------------------------------\n\n    for (int i = 0; i < barsNum; i++) {\n        barSetAngle(bars[i], iTime * 4.);\n        bool visible = true;\n        /*\n        for (int j = 0; j < barsNum; j++) {\n            float d;\n            if (i != j) {\n                visible = visible && !intersects(uv, bars[i], bars[j]);\n            }\n        }\n        */\n        visible = true; // ToDO fix intersects \n        if (visible) col += clrNeonBar(uv, bars[i]); // sin(angle)\n        if (!visible) col += .25 * clrNeonBar(uv, bars[i]); // sin(angle)\n    }\n\n// --> random & noise <---------------------------------------------------\n    // col += 0.25 * random(uv) + .25;\n    // col *= max(.25, min( .75, noise(1.1*uv+iTime)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}