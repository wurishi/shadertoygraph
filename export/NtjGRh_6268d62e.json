{"ver":"0.1","info":{"id":"NtjGRh","date":"1623344399","viewed":74,"name":"Genuine fbm 2D","username":"GenuineIntelligence","description":"a genuine implementation for fractional brownian motion ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fbm","brownian","genuine"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Copyright © 2021 by Arthur Cavalier, Théo Jonchier, Thibault Tricard\nThis work is free. You can redistribute it and/or modify it under the\nterms of the Do What The Fuck You Want To Public License, Version 2,\nas published by Sam Hocevar. See the COPYING file or http://www.wtfpl.net/ \nfor more details.*/\n\n/** INPUT PARAMETERS */\n#define nb_octaves 6\n#define scale 0.1\n\n/** @brief Generates a random number */\nfloat random_2_1(vec2 x)\n{\n    return fract( sin( dot(x ,vec2(24.12357, 36.789) ) ) * 12345.123);\n}\n\n/** @brief value noise */\nfloat valueNoise(vec2 pos)\n{\n    vec2 fr= fract(pos);\n    vec2 fl= floor(pos);\n    vec2 AA= fl ;\n    vec2 AB= fl + vec2(1,0);\n    vec2 BA= fl + vec2(0,1);\n    vec2 BB= fl + vec2(1,1);\n    \n    // we sample random number on a regular grid\n    //\n    //  AA-----------AB\n    //   |           |\n    //   |           |\n    //   |    pos    |\n    //   |           |\n    //   |           |\n    //  BA-----------BB\n    \n    float rAA = random_2_1(AA);\n    float rAB = random_2_1(AB);\n    float rBA = random_2_1(BA);\n    float rBB = random_2_1(BB);\n    \n    // bilinear interpolation of the value\n    float nAA_AB = mix(rAA , rAB, fr.x);\n    float nBA_BB = mix(rBA , rBB, fr.x);\n    return mix(nAA_AB , nBA_BB, fr.y);\n}\n\n/** @brief fractional brownian motion */\nfloat fbm(vec2 uv)\n{ \n    float noise = 0.0;\n    float weights = 0.0;\n    \n    // sum of the value octaves\n    for(int i = 0; i< nb_octaves; i++) {\n        //octave frequency\n        float freq = 0.0625 *  pow(2.0,float(i+1));\n        // octave weight\n        float weight = 1.0/float(i+1);\n        // sum of the octave times the weight\n        noise += valueNoise(uv* freq)*weight;\n        // sum of the weight\n        weights += weight;\n    }\n    \n    // return the sum of octaves divided by the sum of the weight\n    return noise /weights ;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // we sample the fractional brownian motion at a point\n    // we shift it from the origin to avoid artefacts\n    float value = fbm(fragCoord * scale   + vec2(512));\n    fragColor = vec4(value);\n}","name":"Image","description":"","type":"image"}]}