{"ver":"0.1","info":{"id":"lfVGD3","date":"1713373851","viewed":58,"name":"Nick & Regan's really cool shade","username":"reganly1809","description":"For Pookie, from Pookies\n\neyes hurt","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["homework"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float EPSILON = 0.0001;\nconst float NEAR = 0.001;\nconst float FAR = 80.0;\n/*\nArches : wave transform (i know its not rotat, translation or scale but it should count bc its cool\nSpheres : translation through loops\nOctahedron : spins, and has this noise thing going on\nA FOOT BALL: uhhh scales, rotates\nLast object: scale and rotates\n\n\nI meannnn it doesn't get better than this \n\n*/\n//noise\nfloat noise(vec3 p) {\n\n    float frequency1 = 16.5;\n    float frequency2 = 16.5;\n    float amplitude1 = 0.5;\n    float amplitude2 = 0.25;\n\n    //first layer of noise\n    float n1 = sin(dot(p, vec3(frequency1)) + iTime * 5.0) * amplitude1;\n\n    //second layer\n    float n2 = cos(dot(p, vec3(frequency2)) + iTime * 5.0) * amplitude2;\n\n    //Combine\n    float totalNoise = n1 + n2;\n\n    \n    return totalNoise * 0.5 + 0.5;\n}\n//rotate\n// this rotation function is from a shader by gaz\n//https://www.shadertoy.com/view/wdcczs\nvoid rot3(inout vec3 p,vec3 a,float t){\n\ta=normalize(a);\n\tvec3 q=cross(a,p),u=cross(q,a);\n\tp=u*cos(t)+q*sin(t)+a*dot(p,a);   \n}\n//SHAPES\nfloat sdSphere(vec3 p, float r)\n{\n  return length(p) - r;\n}\nfloat sdOctahedron(vec3 p, float s) {\n//rotate\nrot3(p,vec3(0,1,0),iTime);\n    //appply thu noise\n    float noiseFactor = 0.1;\n    vec3 noisePosition = p + noise(p) * noiseFactor;\n\n    \n    noisePosition = abs(noisePosition);\n    float m = noisePosition.x + noisePosition.y + noisePosition.z - s;\n    vec3 q;\n\n    if( 3.0 * noisePosition.x < m ) q = noisePosition.xyz;\n    else if( 3.0 * noisePosition.y < m ) q = noisePosition.yzx;\n    else if( 3.0 * noisePosition.z < m ) q = noisePosition.zxy;\n    else return m * 0.57735027;\n\n    float k = clamp(0.5 * (q.z - q.y + s), 0.0, s);\n    return length(vec3(q.x, q.y - s + k, q.z - k));\n}\n\nfloat sdCappedTorus( vec3 p, vec2 sc, float ra, float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\nfloat sdVesicaSegment( in vec3 p, in vec3 a, in vec3 b, in float w )\n{\n    rot3(p,vec3(3,1,0),iTime*10.0);\n    vec3  c = (a+b)*0.5;\n    float l = length(b-a);\n    vec3  v = (b-a)/l;\n    float y = dot(p-c,v);\n    vec2  q = vec2(length(p-c-y*v),abs(y));\n    \n    float r = 0.5*l;\n    float d = 0.5*(r*r-w*w)/w;\n    vec3  h = (r*q.x<d*(q.y-r)) ? vec3(0.0,r,0.0) : vec3(-d,0.0,d+w);\n \n    return length(q-h.xy) - h.z;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n \n rot3(p,vec3(2,1,3),iTime*3.0);\n  float n = noise(p);\n  \n  vec3 scaledB = b * (0.05 * n);\n  //original box distance calculation\n  vec3 q = abs(p) - scaledB;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) + sin(iTime + 1.5);\n}\n\nfloat waves(vec2 uv)\n{\n// learning to do the waves from that 4 hour video  by freya holmer\n\n    float waves = cos(uv.x * 1.0 * 6.28318530718 * 2.0) * 0.1;\n    float t = cos((uv.y + waves + (iTime) * 0.1) * 3.0 * 6.28318530718 * 2.0) * 1.8 + 0.9;\n    return t;  \n}\n\nfloat torus(float add, vec3 p)\n{\n    vec3 tPos = p + vec3(1.2,0.6,1.0); // torus position\n    vec2 sc = vec2(0.5, 0.0); // makes shape a hald circle\n    float torus =  sdCappedTorus(tPos+ add, sc, 0.8, 0.1 );\n    torus *= clamp(torus + waves(p.xy), 0.1, 1.8);\n    return torus;\n}\nfloat torusflip(float add, vec3 p)\n{\n    vec3 tPos = p + vec3(-1.8-add,0.6,1.0); // torus position\n    vec2 sc = vec2(0.5, 0.0); // makes shape a hald circle\n    float torus =  sdCappedTorus(tPos + add, sc, 0.8, 0.1 );\n    torus *= clamp(torus + waves(p.xy), 0.1, 1.8);\n    return torus;\n}\n\nfloat combinedTorus(vec3 p)\n{\n    return min(min(min(torus(0.0, p), torus(0.3, p)), torus(0.6, p)), min(min(torusflip(0.0, p), torusflip(0.3, p)), torusflip(0.6, p)));\n}\nfloat combinedCircles(vec3 p)\n{\n    vec3 spherePosition1 = vec3(1.8, sin(iTime)+-0.2, sin(iTime*1.0-0.2)- 1.0);\n    float sphere1 = sdSphere(p - spherePosition1, 0.2);  \n    \n    vec3 spherePosition2 = vec3(-1.55, sin(iTime)+-0.4, sin(iTime*1.0-0.2)- 1.0);\n    float sphere2 =sdSphere(p - spherePosition2, 0.2);  \n    \n    return min(sphere1, sphere2);\n}\n\nfloat map(vec3 p)\n{\n   \n    float ground = p.y + 0.95;\n    \n    vec3 humunculousPos = vec3(3.2,-1.2,-1.0);\n    float humunculousScale = 3.0 * (0.9 + 0.9);\n    float humunculous = sdBox(p + humunculousPos, vec3(humunculousScale));\n\n    float coolshape = sdOctahedron( p + vec3(-1.0, 0.9,-3.0), 3.0);\n    \n    vec3 footballTransform = vec3(sin(iTime*1.3)*6.0,cos(iTime*1.3)*1.5,1.0);\n    \n    vec3 a = vec3(-0.7,-0.4, 0.0);\n    vec3 b = vec3( 0.8, 0.3, 0.0);\n    float l = length(b-a);    \n    float w = sqrt(0.2/l);    \n    float football = sdVesicaSegment(p+footballTransform, a, b, w*0.85 ) - w*0.15;\n    \n\n    // torusssss\n    float torusarray = combinedTorus(p);\n    return min(ground, min(torusarray, min(coolshape,min(humunculous, min(football,combinedCircles(p)))))); \n   \n    \n    //coolshape *= clamp(coolshape + waves(p.xy/0.6), 0.5, 1.3);\n    //sphere *=  clamp(sphere + waves(p.xy), 0.2, 1.0);\n    // return min(coolshape, min(ground,sphere));\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n        map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n        map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\n//LIGHTS\nvec3 DirectionalLight(vec3 position, vec3 normal, vec3 cameraPosition,\n    vec3 lightPosition, vec3 lightColor,\n    float ambientIntensity, float diffuseIntensity, float specularPower)\n    {\n    vec3 N = normal;\n    vec3 L = normalize(position + lightPosition);\n    vec3 V =  normalize(position + cameraPosition);\n    vec3 R = reflect( -L, N);\n    \n    float dotNL = max(dot(N,L), 0.0);\n    float dotVR = max( dot(V,R), 0.0);   \n    \n    vec3 C = vec3(0.0,0.0,0.0);\n    C += lightColor * ambientIntensity;\n    C += lightColor * diffuseIntensity * dotNL;\n    C += lightColor * pow(dotVR, specularPower) ;\n\n    return C; \n    }\n\nvec3 SpotLighting(vec3 position, vec3 normal, vec3 cameraPosition,\n    vec3 lightPosition, vec3 lightColor,\n     float diffuseIntensity, float specularPower, vec3 spotLightDir, float coneAngle) \n{\n    vec3 N = normal;\n    vec3 L = normalize(position + lightPosition);\n    vec3 V =  normalize(position + cameraPosition);\n    vec3 R = reflect( -L, N);  \n    \n    // 2. Calculate lighting vector similarities\n    float dotNL = max(dot(N,L), 0.0);\n    float dotVR = max( dot(V,R), 0.0);\n    \n    float spotCosine = cos(coneAngle * 0.5);\n    float spotDirection = dot(normalize(-spotLightDir), normalize(position - lightPosition));\n    \n    float spotIntensity = step(spotCosine, spotDirection);\n   \n    // 3. Apply ambient, diffuse, and specular contributions\n    // let C = base color (black)\n    vec3 C = vec3(0.0,0.0,0.0);\n    C += lightColor * diffuseIntensity * dotNL * spotIntensity;\n    C += lightColor * pow(dotVR, specularPower) * spotIntensity;\n\n    \n    return C;\n}\n\nvec3 PointLight(vec3 position, vec3 normal, vec3 cameraPosition,\n    vec3 lightPosition, vec3 lightColor, float diffuseIntensity, float specularPower,float pointLightIntensity, float attStrength)\n    {\n        \n    vec3 N = normal;\n    vec3 L = normalize(lightPosition - position);\n    vec3 V =  normalize(cameraPosition - position);\n    vec3 R = reflect( -L, N);\n    vec3 halfWay = normalize(V + L);\n    \n    \n    // 2. Calculate lighting vector similarities\n    float dotNL = max(dot(N,L), 0.0);\n    float dotVR = max( dot(V,R), 0.0);\n    float dotNH = max(dot(halfWay, N), 0.0);\n    \n    float distance = length(lightPosition - position);\n    float attenuation = attStrength / (distance * distance); \n       \n        vec3 C = vec3(0.0,0.0,0.0);\n    C += lightColor * dotNL;\n    C += lightColor * pow(dotNH, specularPower) ;\n    C *= diffuseIntensity * attenuation;\n    C *= pointLightIntensity;\n    return C;\n    }\n\nvec3 CalculateLighting(vec3 position, vec3 normal, vec3 cameraPosition)\n{\n    vec3 lightColorGrey = vec3(0.8,0.8,1.5);\n    vec3 lightColorYellow = vec3(1.0,0.9,0.6);\n    vec3 lightColorGreen = vec3(0,1.0,0.4);\n    vec3 lightColorBlue = vec3(0.2,0.2,1.0);\n    vec3 lightColorSkyBlue = vec3(0.4, 0.8039, 1.0);\n    vec3 lightColorOrange = vec3(1.7, 0.7, 0.0);\n    vec3 lightColorRed = vec3(2.0, 0.2, 0.2);\n   \n    vec3 lightPosition1 = vec3(7.0, 8.0, -2.0); // blue global light\n    vec3 lightPosition2 = vec3(-7.0, 8.0, 2.0); // orange global light\n    \n    vec3 lightPosition3 = vec3( cos(iTime*10.0) *1.0,4.0,  5.0); // spotlight 1\n    \n    vec3 lightPosition4 = vec3(2.5,0.0,-1.0);\n    vec3 lightPosition5 = vec3(-2.1,0.0,-1.0);\n     \n    float pointLightIntensity = 2.5;\n    \n    vec3 spotlightDir = vec3(cos(iTime * 2.0) * 1.2, 1.6, sin(iTime *2.0) * 1.2); \n    //vec3 directionallightDir = normalize(vec3(2.0, 1.0, -2.0));     \n    float coneSize = 0.6;\n    float ambient = 0.15;\n    float diffuse = 0.35;\n    float specular = 5.0;\n    vec3 TotalLighting = vec3(0.0);\n    \n    \n    TotalLighting += DirectionalLight(position, normal, cameraPosition, lightPosition1, lightColorSkyBlue,ambient-0.6,diffuse+0.5, specular-3.0);\n    TotalLighting += DirectionalLight(position, normal, cameraPosition, lightPosition2, lightColorOrange,ambient-0.51,diffuse+0.5, specular-4.0);\n    \n    \n    TotalLighting += SpotLighting(position, normal, cameraPosition, lightPosition3,lightColorYellow,  diffuse*8.0, specular-2.0, spotlightDir, coneSize);\n    \n    TotalLighting += PointLight(position, normal, cameraPosition, lightPosition4, lightColorBlue, diffuse, specular,pointLightIntensity, 2.0);\n    TotalLighting += PointLight(position, normal, cameraPosition, lightPosition5, lightColorRed, diffuse, specular,pointLightIntensity,2.0);\n    return TotalLighting;\n}\n//Post Processing filter\n//oh yah, we did the bonus B^)\nvec3 applyGamma(vec3 color, float gamma) {\n    return pow(color, vec3(1.0 / gamma));\n}\n\nvec3 applyContrast(vec3 color, float contrastFactor) {\n    return (color - 0.5) * contrastFactor + 0.5;\n}\n\nvec3 adjustSaturation(vec3 color, float saturationFactor) {\n    float grey = dot(color, vec3(0.9, 0.39, 0.7)); // luma calc\n    return mix(vec3(grey), color, saturationFactor);\n}\n\n//OUTPUT\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    // Ray origin\n    vec3 ro = vec3(0.0, 0.0, -3.0);\n    // FoV of 90 degrees\n    float fov = tan(45.0 * 3.14 / 180.0); \n    // Ray direction\n    vec3 rd = normalize(vec3(uv * fov, 1.0));    \n    // Distance along ray\n    float t = 0.0;   \n    for (int i = 0; i < 80; i++)\n    {\n        // Scene position\n        vec3 p = ro + rd * t;\n                // Determine maxmimum safe stepping distance\n        float d = map(p);\n                // Step along ray by distance d\n        t += d;\n                // Intersection if distance is very close to surface (SDF --> -1)\n        if (d < NEAR) break;\n                // No intersection if distance along ray exceeds view distance\n        if (t > FAR) break;\n    }\n    \n    vec3 p = ro + rd * t;\n    vec3 n = estimateNormal(p);\n\n    vec3 lighting = CalculateLighting(p, n, ro);\n    vec3 background = vec3(0.0,0.,0.);\n    background *= waves(uv.xy);\n    \n    \n    bool hit = t < FAR - EPSILON;\n    vec3 color = hit ? lighting : vec3(0.9,0.3,0.0)* waves(-uv.xy) *uv.y;\n    color = applyGamma(color, 0.8); //gamma\n    color = applyContrast(color, 1.1); //contrast boost\n    color = adjustSaturation(color, 1.05); //saturation\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}