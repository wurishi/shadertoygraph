{"ver":"0.1","info":{"id":"DtBGzW","date":"1672903729","viewed":81,"name":"Wave Equation PDE 6.0","username":"kowalski_analytics","description":"Time evolution of an initial state of a wave equation confined to a square, e.g. a finite square metal plate hit with a four-headed hammer. Red values are positive, blue are negative, display rotates between the FDM (RK4) method and the Spectral method.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["wave","spectral","pde","rk4"],"hasliked":0,"parentid":"mlj3R1","parentname":"Wave Equation PDE 5.0"},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"# define PI5 15.708\n\n/// wave eq: d^2 y / dt^2 = c^2 L\n/// => discrete version: dy' = c^2 L dt, dy = y' dt\n\n\n/// --- OVERALL PROGRAM STRUCTURE: ---\n/// Common: defines macros used throughout the program, specifically the simulation paramters\n/// and the Main computation loop (with provision for additional instructions). Main loop computes\n/// k1, k2, k3, and k4 in the RK4 method via buffers A, B, C, and D, which are evaluated sequentially.\n/// Each buffer has access to its prior state, as well as the current states of those before it, \n/// and prior states of those after it.\n\n/// Buffers are compute shaders running on the GPU, as such they are massively parallelized.\n/// Each entry in a buffer is assigned a separate thread, the above access rules are necessary to\n/// prevent access conflicts. Because of this, we can accomplish up to 360 iterations per second,\n/// the maxiumum alloted in this software, for around a quarter million pixels if not zoomed in.\n/// Far, far more power is achievable, but is not necessary.\n\n/// because D is the last buffer, the additional instructions (instr) are used to complete the RK4 calculation,\n/// and D is used to store the actual value of amplitude and amplitude rate, NOT k4, like the other buffers store.\n/// k4 is calculated by the initial part of the Main() loop, before (instr) uses it to compute the new state of the system.\n\n/// TO THIS END: Y() gives the current state of the system, K() gives the deviation provided by the previous step\n/// of the RK4 calculation. iChannels are configured for each buffer in accordance with this convention.\n/// D must also include iChannels for A and B, which provide it with k1 and k2.\n\n/// IMAGE then displays part of this result, with the other half of the square occupied by the \n/// spectral solution. The boundary conditions have been chosen to make the 2d Fourier Transform\n/// separable in X and Y, thus making the computation of spectral solution trivial (FT of a square wave is known).\n\n\n/// This represents a Finite Difference Method for the 2d wave equation, with an isolated time derivative\n/// and an easily computed Laplacian (the other side of the wave equation) via convolution of a simple discrete filter\n/// with the relevant buffers representing the sub-iterated states. \n\n/// This is then readily compared to the \"exact\" spectral solution as described above.\n\n\nvoid mainImage( out vec4 r, in vec2 u )\n{\n    float t = 0.;\n    if (iFrame > 500) t = float(iFrame - 500) * 0.00106;\n\n    vec2 uv = u / iResolution.y - 0.5;\n    r = vec4(0.);\n    \n    // display half the resonance cavity as brute-force numerical and half as spectral soln. \n    // (rotating comparison for visual effect)\n    if (uv.x * cos(t) + uv.y * sin(t) < 0.) {\n        r = texelFetch(iChannel0,ivec2(u),0).xxxx;\n    }\n    else if (uv.x < 0.5) {\n        uv += 0.5;\n        t *= dt * sqrt(c2) * 10.;\n    \n        float X_wave = 0.;\n        float Y_wave = 0.;\n        for (float n = 1.; n < 80.; n += 2.0) {\n            X_wave += (sin(n * 3.1415 * uv.x) * cos(n * 3.1415 * t)\n                    -  sin(n * PI5 * uv.x) * cos(n * PI5 * t)) / n; \n            Y_wave += (sin(n * 3.1415 * uv.y) * cos(n * 3.1415 * t)\n                    -  sin(n * PI5 * uv.y) * cos(n * PI5 * t)) / n;\n        }\n        r = vec4(0.40528 * X_wave * Y_wave);\n    }\n    \n    r = vec4(r.x, 0., -r.x, 0.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define Y(i) texelFetch(iChannel0,ivec2(i+u),0)\n#define K(i) texelFetch(iChannel1,ivec2(i+u),0)\n\n// USE THESE PARAMETERS TO MODIFY THE SIMULATION:\n\n#define c2 2.0\n#define dt 0.01\n\n\n/// --- MAIN LOOP: ---\n\n/// A.x is A (amplitude) at position u, A.y is time derivative of amplitude\n    \n/// --- NOT CURRENTLY IN USE: ---\n/// Discrete Laplacian operator as convex sum of 5-point stencil and cross laplacian\n/// with gamma parameter = 1/3, optimal for rotational symmetry (Wikipedia)\n\n/// --- CURRENTLY IN USE: ---\n/// Basic non-rotationally optimal 5x5 Laplacian convolution filter, necessary for reflections\n/// at left and bottom bounds to work properly (likely a buffer interpolation error in 3x3 filters)\n\n#define Main(instr) void mainImage( out vec4 r, in vec2 u )             \\\n{                                                                       \\\n    r = A();                                                            \\\n                                                                        \\\n    float laplace = -25. * r.x;                                         \\\n    for(vec2 i = vec2(-3); ++i.x < 3.;) for(i.y = -3.; ++i.y < 3.;) {   \\\n        laplace += A(i).x;                                              \\\n    }                                                                   \\\n                                                                        \\\n    r.x = r.y;                                                          \\\n    r.y = c2 * laplace;                                                 \\\n                                                                        \\\n    instr                                                               \\\n}                                                                       \\\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define A(i) Y(i)\n\nMain()","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define A(i) (Y(i) + K(i) * dt * 0.5)\n\nMain()","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define A(i) (Y(i) + K(i) * dt * 0.5)\n\nMain()","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"#define A(i) (Y(i) + K(i) * dt)\n#define f(chn) texelFetch(chn,ivec2(u),0)\n\nMain(    \n    /// --- ADDITIONAL INSTRUCTIONS NECESSARY TO TIME EVOLVE: --- \n    // r is currently k4, but final result must be the new state\n\n    // y(t+dt) = y(t) + dt*(k1 + 2k2 + 2k3 + k4)/6 \n    r = Y() + (f(iChannel3) + 2.*(f(iChannel2) + f(iChannel1)) + r) * dt/6.;\n    \n\n    // initial conditions\n    if (iFrame < 500) {\n        vec2 uv = u / iResolution.yy;\n        r.xy = vec2(0.);\n        uv = abs(abs(uv - 0.5) - 0.2);\n        if (uv.x < 0.1 && uv.y < 0.1) r.x = 1.0;\n    }\n    if (u.x/iResolution.y > 1.) r.x = 0.;\n)","name":"Buffer D","description":"","type":"buffer"}]}