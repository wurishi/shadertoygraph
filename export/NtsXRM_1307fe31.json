{"ver":"0.1","info":{"id":"NtsXRM","date":"1626256303","viewed":245,"name":"Apple Logo SDF Draft","username":"chenglou","description":"Apple logo uses cubic bezier. This closely approximates it with only circles + smoothing. Maybe it's better to just use the cubic beziers?\n\nSee comment for details. Click to reveal the composing circles. Cleaned up: https://www.shadertoy.com/view/ftXSzX","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["raytracing","sdf","logo","apple"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThe circles of the logo are manually approximated in a Figma file:\nhttps://www.figma.com/file/ywGtT2aMhG04cuvz2MKF0d/Apple-soft-3D-Community?node-id=0%3A1\nThen converted from Figma's coordinate system, where:\n- y increases downward\n- sizes aren't normalized to 0 - 1\n- origin of the circles are on the upper left\n- circles are specified using width instead of radius\n\nSee convertCoords below\n*/\n\nfloat sdCircle( vec2 p, float r ) { return length(p) - r; }\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat opExtrussion( in vec3 p, in float sdf, in float h ) {\n    vec2 w = vec2( sdf, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat ratio = 3./3.;\nfloat width = 419.;\nfloat height = 497.;\n\nfloat convertCoords(vec2 coord, vec3 xyr) {\n    float r = xyr.z / 2.;\n    vec2 absolute = vec2(xyr.x - width / 2., height / 2. - xyr.y) + vec2(r, -r);\n    return sdCircle(coord - absolute * ratio / height * 2., r * ratio / height * 2.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\n    float leaf1 = convertCoords(coord, vec3(95, -102, 221));\n    float leaf2 = convertCoords(coord, vec3(211, -1, 227));\n\n    float shoulderLeft = convertCoords(coord, vec3(12, 118, 229));\n    float shoulderRight = convertCoords(coord, vec3(186, 117, 244));\n\n    float bodyLeft = convertCoords(coord, vec3(-71, 44, 500));\n    float bodyCenter = convertCoords(coord, vec3(-17, 140, 460));\n    float bodyRight = convertCoords(coord, vec3(1, -39, 599));\n    float bodyShoulderLeft = convertCoords(coord, vec3(0, 99, 330));\n\n    float bite = convertCoords(coord, vec3(350, 152, 220));\n    float bottom = convertCoords(coord, vec3(96, 477, 246));\n\n    float delimiterLeft = convertCoords(coord, vec3(-32, 161, 165));\n    \n\n    float leaf = opIntersection(leaf1, leaf2);\n    float tinyPieceLeft = opIntersection(delimiterLeft, bodyShoulderLeft) + 0.994 * ratio / height; // random constant\n    float lowerPart = opIntersection(bodyLeft, opIntersection(bodyCenter, bodyRight));\n    \n    float body;\n    body = opUnion(shoulderLeft, shoulderRight);\n    body = opSmoothUnion(body, lowerPart, 60. * ratio / height); // random constant\n    body = opUnion(body, tinyPieceLeft);\n    body = opUnion(body, leaf);\n    body = opSubtraction(bite, body);\n    body = opSmoothSubtraction(bottom, body, 94. * ratio / height); // random constant\n    \n    \n    vec3 color = vec3(1.0) - sign(body) * vec3(0.1,0.4,0.7);\n    color *= 1.0 - exp(-3.0 * abs(body));\n    color *= 0.8 + 0.2 * cos(150.0 * body);\n    color = mix(color, vec3(1.0), 1.0 - smoothstep(0.0,0.01, abs(body)));\n\n    float line = 0.002;\n    if (iMouse.z > 0.001 &&\n        (abs(leaf1) < line\n        || abs(leaf2) < line\n        || abs(bite) < line\n        || abs(shoulderLeft) < line\n        || abs(shoulderRight) < line\n        || abs(bottom) < line\n        || abs(bodyRight) < line\n        || abs(bodyLeft) < line\n        || abs(bodyShoulderLeft) < line\n        || abs(bodyCenter) < line\n        || abs(delimiterLeft) < line)\n    ) {\n        color = vec3(1, 1, 0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}