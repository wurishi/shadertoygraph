{"ver":"0.1","info":{"id":"mdBfDV","date":"1690148293","viewed":123,"name":"Look through windows","username":"pacman000","description":"Sunlight grows the grass.","likes":0,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","noise","sdf","fbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Constants\nconst float DMAX = 600.0;\nconst float PI = 3.14159265358979;\nconst float DMIN = 0.6;\nconst float EPS = 0.06;\nconst float STEP_SIZE = 0.4;\nconst int MAX_STEPS = 384; // for ray marching\nconst int MAX_SHADOW_STEPS = 256; // for ray marching\nconst int NUM_MATERIALS = 20;\nconst int NUM_LIGHTS = 4;\nconst int MAX_DEPTH = 3;\nconst int NUM_RECORDS = 2 * 2 * 2 * 2 - 1; // 2 ^ (MAX_DEPTH + 1) - 1\nconst int NUM_CTRL_POINTS = 3;\nconst float GROUND_SCALE = 10.0;\n\n// Options\nbool AA = false;\nbool AO = false; // to do?\nbool REFRACTION = true;\nbool REFLECTION = true;\n// Helpers\n// Random generator\n// Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\n\nfloat random(in vec2 _st)\n{\n    return fract(sin(dot(_st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nint randInt(int a, int b, in vec2 _st) // a <= x < b\n{\n    int x = int(floor(random(_st) * float(b - a) + float(a)));\n    return x;\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n           (c - a) * u.y * (1.0 - u.x) +\n           (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 8\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = 3.0;\n    float frequency = 3.0;\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= frequency;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.75;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\n// rotation\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n// atan2\nfloat atan2(in float y, in float x)\n{\n    bool s = (abs(x) > abs(y));\n    return mix(PI/2.0 - atan(x,y), atan(y,x), s);\n}\n\nfloat MaxV(in vec3 v)\n{\n    return max(v.x, max(v.y, v.z));\n}\n\n// 3-point Piecewise Bezier curve\nstruct Bezier\n{\n    vec3 P0;\n    vec3 P1;\n    vec3 P2;\n};\n\nvec3 bezier(Bezier curve, float t)\n{\n    float a = 1.0 - t;\n    float b = t;\n    return a * a * curve.P0 + 2.0 * a * b * curve.P1 + b * b * curve.P2;\n}\n\nvec3 bezierTangent(Bezier curve, float t)\n{\n    return normalize(2.0 * (1.0 - t) * (curve.P1 - curve.P0) + 2.0 * t * (curve.P2 - curve.P1));\n}\n\n// Ray\nstruct Ray\n{\n    vec3 o;\n    vec3 d;\n};\n\n// Material\nstruct Material\n{\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float smoothness;\n    vec3 rg; // reflection coeffcient\n    vec3 tg; // transmission coeffcient\n    float eta; // refraction index\n    float random_color;\n    float random_displace;\n    vec3 emit;\n\n} materials[NUM_MATERIALS];\nconst int MAT_BRASS = 0;\nconst int MAT_BRONZE = 1;\nconst int MAT_SILVER = 2;\nconst int MAT_RED = 3;\nconst int MAT_GREEN = 4;\nconst int MAT_BLUE = 5;\nconst int MAT_GLASS = 6;\nconst int MAT_MIRROR = 7;\nconst int MAT_GREY = 8;\nconst int MAT_RUBBER = 9;\nconst int MAT_ROCKET = 10;\nconst int MAT_GROUND = 11;\nconst int MAT_GRASS = 12;\nconst int MAT_LOGO_RED = 13;\nconst int MAT_LOGO_GREEN = 14;\nconst int MAT_LOGO_BLUE = 15;\nconst int MAT_LOGO_YELLOW = 16;\nconst int MAT_SUN = 17;\n\n// For recursive ray marching\n// A FIFO queue which simulates the ray tree\nstruct HitRecord\n{\n    Ray ray;\n    vec3 g; // a series of rg and tg multiplied\n    int depth;\n} hitRecords[NUM_RECORDS];\n\n// Geometry\n// Sphere\nstruct Sphere\n{\n    vec3 c;\n    float radius;\n    int matID;\n};\n\nfloat sdSphere(vec3 p, Sphere sph)\n{\n    vec3 r = p - sph.c;\n    return length(r) - sph.radius;\n}\n\nstruct Plane\n{\n    // n must be normalized\n    vec3 n;\n    float h;\n    int matID;\n};\n\nfloat sdPlane(vec3 p, Plane plane)\n{\n    return dot(p, plane.n) + plane.h;\n}\n\nstruct Torus\n{\n    vec2 t;\n    int matID;\n};\n\nfloat sdTorus(vec3 p, Torus tor)\n{\n  vec2 q = vec2(length(p.xz) - tor.t.x, p.y);\n  return length(q) - tor.t.y;\n}\n\nstruct Box // axis-aligned\n{\n    vec3 c; // center\n    vec3 b; // half size in three directions\n    int matID;\n};\n\nfloat sdBox(vec3 p, Box b)\n{\n    vec3 q = abs(p - b.c) - b.b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nstruct Cylinder\n{\n    vec3 a;\n    vec3 b;\n    float r;\n    int matID;\n};\n\nfloat sdCylinder(vec3 p, Cylinder cyl)\n{\n    vec3  ba = cyl.b - cyl.a;\n    vec3  pa = p - cyl.a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    float x = length(pa*baba-ba*paba) - cyl.r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nstruct Cone\n{\n    float r;\n    float h;\n    int matID;\n};\n\nfloat sdCone(vec3 p, Cone c)\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = vec2(c.r, -c.h);\n    \n  vec2 w = vec2(length(p.xz), p.y);\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n// Light\nstruct Light\n{\n    vec3 p;\n    vec3 I_ambient;\n    vec3 I_diffuse;\n    vec3 I_specular;\n} lights[NUM_LIGHTS];\n\n// Construct the scene\nSphere sph1;\nSphere sph2;\nSphere sph3;\nSphere sph4;\nSphere sun;\nTorus torus;\nPlane ground;\nbool intersect_ground;\nBox cbox1;\nBox cbox2;\nBox cbox3;\nBox cbox4;\nBox cbox5;\nBox cbox6;\nBox box1;\nBox box2;\nBox box3;\nBox logo1;\nBox logo2;\nBox logo3;\nBox logo4;\nBox logo5;\nBox logo6;\nBox logo7;\nBox logo8;\nBox logo9;\nBox logo10;\nBox logo11;\nBox logo12;\nCylinder cyl1;\n// End\n\n// Set the camera\n// Camera frames is left handed\nfloat FOV = 45.0; // Vertical field of view\nfloat aspect;\nvec3 camera_pos;\nvec3 camera_up = normalize(vec3(0.0, 1.0, 0.0));\nvec3 camera_lookat;\nvec3 camera_z;\nvec3 camera_x;\nvec3 camera_y;\n\n// Record the material at the hit point\nMaterial hitMat;\n\nvoid mixMaterial(Material material1, Material material2, out Material matOut, float p)\n{\n    matOut.ambient = mix(material1.ambient, material2.ambient, p);\n    matOut.diffuse = mix(material1.diffuse, material2.diffuse, p);\n    matOut.specular = mix(material1.specular, material2.specular, p);\n    matOut.smoothness = mix(material1.smoothness, material2.smoothness, p);\n    matOut.rg = mix(material1.rg, material2.rg, p);\n    matOut.tg = mix(material1.tg, material2.tg, p);\n    matOut.eta = mix(material1.eta, material2.eta, p);\n    matOut.random_color = mix(material1.random_color, material2.random_color, p);\n    matOut.random_displace = mix(material1.random_displace, material2.random_displace, p);\n    matOut.emit = mix(material1.emit, material2.emit, p);\n}\n\n// Signed distance function operations\nfloat opUnion(float d1, float d2, Material material1, Material material2, out Material matOut)\n{\n    if (d1 <= d2)\n    {\n        matOut = material1;\n        return d1;\n    }\n    else\n    {\n        matOut = material2;\n        return d2;\n    }\n}\n// d1 - d2\nfloat opSubtraction(float d1, float d2, Material material1, Material material2, out Material matOut)\n{\n    if (-d2 >= d1)\n    {\n        matOut = material2;\n        return -d2;\n    }\n    else\n    {\n        matOut = material1;\n        return d1;\n    }\n}\n\nfloat opIntersection(float d1, float d2, Material material1, Material material2, out Material matOut)\n{\n    if (d1 >= d2)\n    {\n        matOut = material1;\n        return d1;\n    }\n    else\n    {\n        matOut = material2;\n        return d2;\n    }\n}\n\n\nfloat opSmoothUnion(float d1, float d2, float k, Material material1, Material material2, out Material matOut)\n{\n    float h = clamp(0.5 + 0.5 * (d1 - d2) / k, 0.0, 1.0);\n    mixMaterial(material1, material2, matOut, h);\n    return mix(d1, d2, h) - k * h * (1.0 - h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k, Material material1, Material material2, out Material matOut)\n{\n    float h = clamp(0.5 - 0.5 * (d1 + d2) / k, 0.0, 1.0);\n    mixMaterial(material1, material2, matOut, h);\n    return mix(d1, -d2, h) + k * h * (1.0 - h);\n}\n\nfloat opSmoothIntersection(float d1, float d2, float k, Material material1, Material material2, out Material matOut)\n{\n    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    mixMaterial(material2, material1, matOut, h);\n    return mix(d2, d1, h) + k * h * (1.0 - h);\n}\n\n// Deformations and distortions\nfloat opRep(in vec3 p, Box box, in vec3 c) // Infinite repetition\n{\n    vec3 q = mod(p + 0.5 * c, c) - 0.5 * c;\n    return sdBox(q, box);\n}\nfloat opRepLim(in vec3 p, in Box box, in float c, in vec3 l)\n{\n    vec3 q = p - c * clamp(round(p / c), -l, l);\n    return sdBox(q, box);\n}\n\nfloat opRepLim(in vec3 p, in Torus t, in float c, in vec3 l)\n{\n    vec3 q = p - c * clamp(round(p / c), -l, l);\n    return sdTorus(q, t);\n}\n\nfloat opDisplace(in vec3 p, in Sphere sph, float freq)\n{\n    float d1 = sdSphere(p, sph);\n    float d2 = sin(freq * p.x) * sin(freq * p.y) * sin(freq * p.z);\n    return d1 + d2;\n}\n\nfloat opDisplace(in vec3 p, in Plane plane, float freq)\n{\n    float d1 = sdPlane(p, plane);\n    float d2 = sin(freq * p.x) * sin(freq * p.y) * sin(freq * p.z);\n    return d1 + d2;\n}\n\nfloat opDisplace(in vec3 p, in Box box, float freq)\n{\n    float d1 = sdBox(p, box);\n    float d2 = sin(freq * p.x) * sin(freq * p.y) * sin(freq * p.z);\n    return d1 + d2;\n}\n\nfloat opRandomDisplace(in vec3 p, in Sphere sph)\n{\n    p = p - sph.c;\n    float radius_factor = 10.0;\n    float height = 20.0;\n    p += height * (2.0 * fbm(p / (radius_factor * sph.radius)) - 1.0) * normalize(p);\n    float d = sdSphere(p + sph.c, sph);\n    return d;\n}\n\nfloat opRandomDisplace(in vec3 p, in Box box, in vec3 n)\n{\n    vec3 o = box.c;\n    vec3 t;\n    vec3 b;\n    // note that box is axis-aligned\n    if (abs(dot(n, vec3(0.0, 1.0, 0.0))) >= 1.0 - EPS)\n    {\n        t = vec3(1.0, 0.0, 0.0);\n        b = cross(t, n);\n    }\n    else\n    {\n        t = vec3(0.0, 1.0, 0.0);\n        b = cross(t, n);\n    }\n    float sparsity = 2000.0;\n    float height = 20.0;\n    p -= height * (fbm(vec2(dot(p - o, t) / sparsity, dot(p - o, b) / sparsity)) - 1.0) * n;\n    float d = sdBox(p, box);\n    return d;\n}\n\nfloat opRandomDisplace(in vec3 p, in Plane plane)\n{\n    vec3 o = plane.n * (-plane.h);\n    vec3 t;\n    vec3 b;\n    // note that plane is axis-aligned\n    if (abs(dot(plane.n, vec3(0.0, 1.0, 0.0))) >= 1.0 - EPS)\n    {\n        t = vec3(1.0, 0.0, 0.0);\n        b = cross(t, plane.n);\n    }\n    else\n    {\n        t = vec3(0.0, 1.0, 0.0);\n        b = cross(t, plane.n);\n    }\n    float factor = 0.0;\n    float freq = 0.0024;\n    float amp = 1.0;\n    vec2 uv = vec2(dot(p - o, t), dot(p - o, b));\n    mat2 rotate = rot(PI / 5.0);\n    for (int i = 0; i < OCTAVES; i++)\n    {\n        factor += texture(iChannel0, uv * freq).r * amp;\n        amp *= 0.4;\n        freq *= 2.0;\n        uv = rotate * uv;\n    }\n    factor = pow(factor, 2.0);\n    p -= factor * plane.n;\n    float d = sdPlane(p, plane);\n    return d;\n}\n\n\nfloat opTwist(in vec3 p, in Box box, float k)\n{\n    p = p - box.c;\n    float c = cos(k * p.y);\n    float s = sin(k * p.y);\n    mat2 m = mat2(c, -s, s, c);\n    vec3 q = vec3(m * p.xz, p.y);\n    return sdBox(q + box.c, box);\n}\n\nvec4 texturePlane(in vec3 p, in Plane plane)\n{\n    vec3 o = plane.n * (-plane.h);\n    vec3 t;\n    vec3 b;\n    // note that plane is axis-aligned\n    if (abs(dot(plane.n, vec3(0.0, 1.0, 0.0))) >= 1.0 - EPS)\n    {\n        t = vec3(1.0, 0.0, 0.0);\n        b = cross(t, plane.n);\n    }\n    else\n    {\n        t = vec3(0.0, 1.0, 0.0);\n        b = cross(t, plane.n);\n    }\n    float sparsity = 400.0;\n    return texture(iChannel1, vec2(dot(p - o, t) / sparsity, dot(p - o, b) / sparsity));\n}\n\n// Construct the aeroplane\n// Construct the rocket\nfloat rocket_scale = 1.0;\nvec3 rocket_position;\nfloat pitch;\nfloat yaw;\nCylinder r_body;\nSphere r_cap1;\nCone r_cap2;\nfloat sdRocket(vec3 p, out Material matOut)\n{\n\tfloat result = DMAX;\n    matOut = materials[0];\n    p -= rocket_position;\n    p.yz *= rot(pitch);\n    p.xz *= rot(-yaw);\n\tp /= rocket_scale;\n\n    r_body = Cylinder(vec3(0.0, 0.0, -1.0), vec3(0.0, 0.0, 1.0), 0.3, MAT_ROCKET);\n    result = opUnion(result, sdCylinder(p, r_body), matOut, materials[r_body.matID], matOut);\n\n    r_cap1 = Sphere(vec3(0.0, 0.0, 1.0), 0.3, MAT_ROCKET);\n    result = opUnion(result, sdSphere(p, r_cap1), matOut, materials[r_cap1.matID], matOut);\n\n    r_cap2 = Cone(0.25, 0.5, MAT_SILVER);\n    vec3 pp = p;\n    pp -= vec3(0.0, 0.0, 1.8);\n    pp.yz *= rot(radians(90.0));\n    result = opSmoothUnion(result, sdCone(pp, r_cap2), 0.3, matOut, materials[r_cap2.matID], matOut);\n    return result;\n}\n\nstruct Paperplane\n{\n    vec3 r;\n    int matID;\n};\n\nfloat sdPaperplane(vec3 r)\n{\n\tfloat paperplane;\t\n    r -= rocket_position;\n    r.yz *= rot(pitch);\n    r.xz *= rot(-yaw);\n\tr /= rocket_scale;\n    r.x=-abs(r.x);\n    float lwing=udTriangle(r,vec3(0.0,0.5,0.8),vec3(-0.05,0.5,0.0),vec3(-0.25,0.5,0.0))-0.005;\n    float lbase=udTriangle(r,vec3(0.0,0.51,0.8),vec3(-0.05,0.5,0.0),vec3(0.0,0.35,0.0))-0.002;\n    paperplane=min(lbase,lwing);\n    return paperplane;\n}\n\nPaperplane paperplane;\n\nvec3 box_normal(vec3 p, Box box)\n{\n    vec3 det = vec3(EPS, 0.0, 0.0);\n    return normalize(vec3(sdBox(p + det.xyz, box) - sdBox(p - det.xyz, box),\n                          sdBox(p + det.zxy, box) - sdBox(p - det.zxy, box),\n                          sdBox(p + det.yzx, box) - sdBox(p - det.yzx, box)));\n}\n\nvec3 ground_normal(vec3 p)\n{\n    vec3 det = vec3(4.0 * EPS, 0.0, 0.0);\n    return normalize(vec3(opRandomDisplace((p + det.xyz) / GROUND_SCALE, ground) * GROUND_SCALE - opRandomDisplace((p - det.xyz) / GROUND_SCALE, ground) * GROUND_SCALE,\n                          opRandomDisplace((p + det.zxy) / GROUND_SCALE, ground) * GROUND_SCALE - opRandomDisplace((p - det.zxy) / GROUND_SCALE, ground) * GROUND_SCALE,\n                          opRandomDisplace((p + det.yzx) / GROUND_SCALE, ground) * GROUND_SCALE - opRandomDisplace((p - det.yzx) / GROUND_SCALE, ground) * GROUND_SCALE));\n}\n\n// Calculate sdf of the whole scene\nfloat sdf(vec3 p)\n{\n    float d = DMAX;\n    mat2 rotateMat3 = rot(iTime / 8.0);\n    // Traverse all the objects\n    Material mat = materials[0];\n    d = opUnion(d, opRandomDisplace(p / GROUND_SCALE, ground) * GROUND_SCALE, mat, materials[ground.matID], mat);\n    if (abs(d) <= DMIN) // grass\n    {\n        intersect_ground = true;\n        if (abs(d) <= DMIN)\n        {\n            float tm = mod(iTime / 8.0, 2.0 * PI);\n            mixMaterial(mat, materials[MAT_GRASS], mat, smoothstep(0.6, 0.9, ground_normal(p).y) * abs(sin(tm)));\n        }\n    }\n    d = opUnion(d, sdSphere(p, sun), mat, materials[sun.matID], mat);\n    // d = opSmoothUnion(d, opDisplace(p, plane1, 0.0), 0.7, mat, materials[plane1.matID], mat);\n    // d = opSmoothUnion(d, opDisplace(p, plane2, 0.0), 0.7, mat, materials[plane2.matID], mat);\n    // d = opSmoothUnion(d, sdPlane(p, plane3), 0.7, mat, materials[plane3.matID], mat);\n    // d = opSmoothUnion(d, opDisplace(p, plane5, 0.0), 0.7, mat, materials[plane5.matID], mat);\n    // d = opSmoothUnion(d, opDisplace(p, plane6, 0.0), 0.7, mat, materials[plane6.matID], mat);\n    // d = opUnion(d, opRandomDisplace(p, box1, box_normal(p, box1)), mat, materials[box1.matID], mat);\n    // d = opUnion(d, sdBox(p, cbox1), mat, materials[cbox1.matID], mat);\n    // d = opSmoothUnion(d, sdBox(p, cbox2), 0.6, mat, materials[cbox2.matID], mat);\n    // d = opSmoothUnion(d, sdBox(p, cbox3), 0.6, mat, materials[cbox3.matID], mat);\n    // d = opSmoothUnion(d, sdBox(p, cbox4), 0.6, mat, materials[cbox4.matID], mat);\n    // d = opSmoothUnion(d, sdBox(p, cbox5), 0.6, mat, materials[cbox5.matID], mat);\n    // d = opSubtraction(d, sdBox(p, cbox6), mat, materials[cbox6.matID], mat);\n    // d = opUnion(d, opRepLim(p - vec3(15.0, 0.0, -20.0), box2, 6.0, vec3(0.0, 2.0, 2.0)), mat, materials[box2.matID], mat);\n    // vec3 pp = p - vec3(-9.0, 5.0, -45.0);\n    // pp.xz = rotateMat3 * pp.xz;\n    // d = opUnion(d, opTwist(pp, box3, 0.1), mat, materials[box3.matID], mat);\n    // d = opUnion(d, opDisplace(p, sph4, 0.7), mat, materials[sph4.matID], mat);\n\n    \n    mat2 rotateLogo = rot(-PI / 4.0);\n    // logo\n    d = opUnion(d, sdBox(p - vec3(0.0, 4.0 + 20.0, 10.0), logo1), mat, materials[logo1.matID], mat);\n    d = opUnion(d, sdBox(p - vec3(-8.0, 4.0 + 20.0, 10.0), logo2), mat, materials[logo2.matID], mat);\n    d = opUnion(d, sdBox(p - vec3(0.0, -4.0 + 20.0, 10.0), logo3), mat, materials[logo3.matID], mat);\n    d = opUnion(d, sdBox(p - vec3(-8.0, -4.0 + 20.0, 10.0), logo4), mat, materials[logo4.matID], mat);\n    float tm = mod(iTime / 10.0, 2.0 * PI);\n    float ctm = cos(tm), stm = sin(tm);\n    mat2 glassRotate = rot(-PI / 2.0 - tm);\n    vec3 p5 = p, p6 = p, p7 = p, p8 = p;\n    vec3 trans = camera_lookat + 0.55 * (camera_pos - camera_lookat);\n    p5 -= trans;\n    p5.xz = glassRotate * (p5.xz);\n    d = opUnion(d, sdBox(p5 - vec3(2.0, 2.0, 0.0), logo5), mat, materials[logo5.matID], mat);\n    p6 -= trans;\n    p6.xz = glassRotate * (p6.xz);\n    d = opUnion(d, sdBox(p6 - vec3(-2.0, 2.0, 0.0), logo6), mat, materials[logo6.matID], mat);\n    p7 -= trans;\n    p7.xz = glassRotate * (p7.xz);\n    d = opUnion(d, sdBox(p7 - vec3(2.0, -2.0, 0.0), logo7), mat, materials[logo7.matID], mat);\n    p8 -= trans;\n    p8.xz = glassRotate * (p8.xz);\n    d = opUnion(d, sdBox(p8 - vec3(-2.0, -2.0, 0.0), logo8), mat, materials[logo8.matID], mat);\n    vec3 p9 = p, p10 = p, p11 = p, p12 = p;\n    p9 -= vec3(1.0, 25.0, -25.0);\n    p9.xy = rotateLogo * p9.xy;\n    d = opUnion(d, sdBox(p9, logo1), mat, materials[logo1.matID], mat);\n    p10 -= vec3(-5.0, 25.0, -25.0);\n    p10.xy = rotateLogo * p10.xy;\n    d = opSmoothUnion(d, sdBox(p10, logo2), 0.7, mat, materials[logo2.matID], mat);\n    p11 -= vec3(1.0, 21.0, -25.0);\n    p11.xy = rotateLogo * p11.xy;\n    d = opSmoothUnion(d, sdBox(p11, logo3), 0.7, mat, materials[logo3.matID], mat);\n    p12 -= vec3(-5.0, 21.0, -25.0);\n    p12.xy = rotateLogo * p12.xy;\n    d = opSmoothUnion(d, sdBox(p12, logo4), 0.7, mat, materials[logo4.matID], mat);\n    // d = opUnion(d, sdPaperplane(p), mat, materials[paperplane.matID], mat);\n    // Material matRocket;\n    // float d_rocket = sdRocket(p, matRocket);\n    // d = opUnion(d, d_rocket, mat, matRocket, mat);\n    // d = opUnion(d, opTwist(p, sph1, 6.2), mat, materials[sph1.matID], mat);\n    // End traversing\n    hitMat = mat;\n    return d;\n}\n// derive normal vector for a point\nvec3 sdf_normal(vec3 p)\n{\n    vec3 det = vec3(EPS, 0.0, 0.0);\n    return normalize(vec3(sdf(p + det.xyz) - sdf(p - det.xyz),\n                          sdf(p + det.zxy) - sdf(p - det.zxy),\n                          sdf(p + det.yzx) - sdf(p - det.yzx)));\n}\n\n// Initializers\nvoid initScene()\n{\n    sph4 = Sphere(vec3(-7.0, -13.0, -30.0), 5.0, MAT_GLASS);\n    float tm = mod(iTime / 8.0, 2.0 * PI);\n    sun = Sphere(vec3(500.0 * cos(tm), 500.0 * abs(sin(tm)), -320.0), 8.0, MAT_SUN);\n    paperplane = Paperplane(vec3(0.0, 0.0, 0.0), MAT_SILVER);\n    ground = Plane(vec3(0.0, 1.0, 0.0), 0.0, MAT_GROUND);\n    cbox1 = Box(vec3(20.0, 0.0, -20.0), vec3(0.5, 20.0, 20.0), MAT_RED);\n    cbox2 = Box(vec3(-20.0, 0.0, -20.0), vec3(0.5, 20.0, 20.0), MAT_GREEN);\n    cbox3 = Box(vec3(0.0, 20.0, -20.0), vec3(20.0, 0.5, 20.0), MAT_GREY);\n    cbox4 = Box(vec3(0.0, 0.0, 0.0), vec3(20.0, 20.0, 0.5), MAT_GREY);\n    cbox5 = Box(vec3(0.0, -20.0, -20.0), vec3(20.0, 0.5, 20.0), MAT_GREY);\n    cbox6 = Box(vec3(0.0, 0.0, 0.0), vec3(7.0, 7.0, 0.6), MAT_GREY);\n    box2 = Box(vec3(0.0, 0.0, 0.0), vec3(2.5), MAT_GLASS);\n    box3 = Box(vec3(0.0, 0.0, 0.0), vec3(5.0, 9.0, 5.0), MAT_GLASS);\n    logo1 = Box(vec3(0.0, 0.0, 0.0), vec3(3.0, 3.0, 2.0), MAT_LOGO_RED);\n    logo2 = Box(vec3(0.0, 0.0, 0.0), vec3(3.0, 3.0, 2.0), MAT_LOGO_GREEN);\n    logo3 = Box(vec3(0.0, 0.0, 0.0), vec3(3.0, 3.0, 2.0), MAT_LOGO_BLUE);\n    logo4 = Box(vec3(0.0, 0.0, 0.0), vec3(3.0, 3.0, 2.0), MAT_LOGO_YELLOW);\n    logo5 = Box(vec3(0.0, 0.0, 0.0), vec3(1.5, 1.5, 3.0), MAT_GLASS);\n    logo6 = Box(vec3(0.0, 0.0, 0.0), vec3(1.5, 1.5, 3.0), MAT_GLASS);\n    logo7 = Box(vec3(0.0, 0.0, 0.0), vec3(1.5, 1.5, 3.0), MAT_GLASS);\n    logo8 = Box(vec3(0.0, 0.0, 0.0), vec3(1.5, 1.5, 3.0), MAT_GLASS);\n}\n\nvoid initMaterials()\n{\n    // BRASS\n    materials[MAT_BRASS].ambient = vec3(0.329412, 0.223529, 0.027451);\n    materials[MAT_BRASS].diffuse = vec3(0.780392, 0.568627, 0.113725);\n    materials[MAT_BRASS].specular = vec3(0.992157, 0.941176, 0.807843);\n    materials[MAT_BRASS].smoothness = 27.8974;\n    materials[MAT_BRASS].rg = vec3(0.6);\n    materials[MAT_BRASS].tg = vec3(0.0);\n\n    // SILVER\n    materials[MAT_SILVER].ambient = vec3(0.19225, 0.19225, 0.19225);\n    materials[MAT_SILVER].diffuse = vec3(0.50754, 0.50754, 0.50754);\n    materials[MAT_SILVER].specular = vec3(0.50827, 0.50827, 0.50827);\n    materials[MAT_SILVER].smoothness = 51.2;\n    materials[MAT_SILVER].rg = vec3(0.88);\n    materials[MAT_SILVER].tg = vec3(0.0);\n\n    // GLASS\n    materials[MAT_GLASS].ambient = vec3(0.0);\n    materials[MAT_GLASS].diffuse = vec3(0.0);\n    materials[MAT_GLASS].specular = vec3(1.0);\n    materials[MAT_GLASS].smoothness = 150.0;\n    materials[MAT_GLASS].rg = vec3(0.2);\n    materials[MAT_GLASS].tg = vec3(0.6);\n    materials[MAT_GLASS].eta = 1.5;\n\n\n    // MIRROR\n    materials[MAT_MIRROR].ambient = vec3(0.1);\n    materials[MAT_MIRROR].diffuse = vec3(0.0);\n    materials[MAT_MIRROR].specular = vec3(0.0);\n    materials[MAT_MIRROR].smoothness = 100.0;\n    materials[MAT_MIRROR].rg = vec3(0.3);\n    materials[MAT_MIRROR].tg = vec3(0.0);\n    materials[MAT_MIRROR].eta = 0.0;\n\n    // GREY\n    materials[MAT_GREY].ambient = vec3(0.1);\n    materials[MAT_GREY].diffuse = vec3(1.0);\n    materials[MAT_GREY].specular = vec3(0.0);\n    materials[MAT_GREY].smoothness = 100.0;\n    materials[MAT_GREY].random_displace = 0.2;\n\n    // RED\n    materials[MAT_RED].ambient = vec3(0.1);\n    materials[MAT_RED].diffuse = vec3(1.0, 0.0, 0.0);\n    materials[MAT_RED].specular = vec3(0.0);\n    materials[MAT_RED].smoothness = 100.0;\n\n    // GREEN\n    materials[MAT_GREEN].diffuse = vec3(0.1);\n    materials[MAT_GREEN].diffuse = vec3(0.0, 1.0, 0.0);\n    materials[MAT_GREEN].specular = vec3(0.0);\n    materials[MAT_GREEN].smoothness = 100.0;\n\n    // BLUE\n    materials[MAT_BLUE].ambient = vec3(0.1);\n    materials[MAT_BLUE].diffuse = vec3(0.0, 0.0, 1.0);\n    materials[MAT_BLUE].specular = vec3(0.0);\n    materials[MAT_BLUE].smoothness = 100.0;\n\n    // RUBBER\n    materials[MAT_RUBBER].ambient = vec3(0.02);\n    materials[MAT_RUBBER].diffuse = vec3(0.01);\n    materials[MAT_RUBBER].specular = vec3(0.4);\n    materials[MAT_RUBBER].smoothness = 10.0;\n\n    // ROCKET\n    materials[MAT_ROCKET].ambient = vec3(0.19225, 0.19225, 0.19225);\n    materials[MAT_ROCKET].diffuse = vec3(0.50754, 0.50754, 0.50754);\n    materials[MAT_ROCKET].specular = vec3(0.50827, 0.50827, 0.50827);\n    materials[MAT_ROCKET].smoothness = 51.2;\n    materials[MAT_ROCKET].rg = vec3(0.88);\n    materials[MAT_ROCKET].tg = vec3(0.0);\n\n    // GROUND\n    materials[MAT_GROUND].ambient = vec3(0.72, 0.51, 0.42) * 0.2;\n    materials[MAT_GROUND].diffuse = vec3(0.72, 0.51, 0.42);\n    materials[MAT_GROUND].specular = vec3(0.0);\n\n    // GRASS\n    materials[MAT_GRASS].ambient = vec3(0.55, 0.55, 0.027) * 0.2;\n    materials[MAT_GRASS].diffuse = vec3(0.55, 0.55, 0.027) * 0.7;\n    materials[MAT_GRASS].specular = vec3(0.55, 0.55, 0.027) * 0.1;\n    materials[MAT_GRASS].smoothness = 1.0;\n\n    ;\n    // LOGO_RED\n    materials[MAT_LOGO_RED].ambient = vec3(0.792, 0.153, 0.02) * 0.2;\n    materials[MAT_LOGO_RED].diffuse = vec3(0.792, 0.153, 0.02);\n    materials[MAT_LOGO_RED].specular = vec3(0.792, 0.153, 0.02);\n    materials[MAT_LOGO_RED].smoothness = 30.0;\n\n    // LOGO_GREEN\n    materials[MAT_LOGO_GREEN].diffuse = vec3(0.498, 0.694, 0.11) * 0.2;\n    materials[MAT_LOGO_GREEN].diffuse = vec3(0.498, 0.694, 0.11);\n    materials[MAT_LOGO_GREEN].specular = vec3(0.498, 0.694, 0.11);\n    materials[MAT_LOGO_GREEN].smoothness = 30.0;\n\n    // LOGO_BLUE\n    materials[MAT_LOGO_BLUE].ambient = vec3(0.173, 0.373, 0.62) * 0.2;\n    materials[MAT_LOGO_BLUE].diffuse = vec3(0.173, 0.373, 0.62);\n    materials[MAT_LOGO_BLUE].specular = vec3(0.173, 0.373, 0.62);\n    materials[MAT_LOGO_BLUE].smoothness = 30.0;\n\n    // LOGO_YELLOW\n    materials[MAT_LOGO_YELLOW].ambient = vec3(0.984, 0.78, 0.082) * 0.2;\n    materials[MAT_LOGO_YELLOW].diffuse = vec3(0.984, 0.78, 0.082);\n    materials[MAT_LOGO_YELLOW].specular = vec3(0.984, 0.78, 0.082);\n    materials[MAT_LOGO_YELLOW].smoothness = 30.0;\n\n\n    // SUN\n    materials[MAT_SUN].ambient = vec3(0.0);\n    materials[MAT_SUN].diffuse = vec3(0.0);\n    materials[MAT_SUN].specular = vec3(0.0);\n    materials[MAT_SUN].emit = vec3(1.0, 0.843, 0.0) * 1.1;\n}\n\nvoid initLights()\n{\n    // LIGHT0\n    lights[0].p = vec3(-20.0, 10.0, 40.0);\n    lights[0].I_ambient = vec3(0.2);\n    lights[0].I_diffuse = vec3(1.0);\n    lights[0].I_specular = vec3(1.0);\n\n    // LIGHT1\n    lights[1].p = vec3(20.0, 10.0, 40.0);\n    lights[1].I_ambient = vec3(0.2);\n    lights[1].I_diffuse = vec3(1.0);\n    lights[1].I_specular = vec3(1.0);\n\n    // LIGHT2\n    lights[2].p = vec3(0.0, 100.0, 0.0);\n    lights[2].I_ambient = vec3(0.2);\n    lights[2].I_diffuse = vec3(0.8);\n    lights[2].I_specular = vec3(0.8);\n\n    // LIGHT SUN\n    float tm = mod(iTime / 12.0, 2.0 * PI);\n    lights[3].p = vec3(500.0 * cos(tm), 500.0 * abs(sin(tm)), -300.0);\n    lights[3].I_ambient = vec3(0.2);\n    lights[3].I_diffuse = vec3(1.0);\n    lights[3].I_specular = vec3(1.0);\n}\n// End\n\n// Updates\nconst int NUM_SEGS = 7;\nBezier trails[NUM_SEGS] = Bezier[NUM_SEGS] (\n    Bezier(vec3(0.0, 10.0, -120.0),\n           vec3(0.0, 10.0, -100.0),\n           vec3(0.0, 10.0, -80.0)\n    ),\n    Bezier(vec3(0.0, 10.0, -80.0),\n           vec3(0.0, 3.0, -20.0),\n           vec3(0.0, 0.0, 20.0)\n    ),\n    Bezier(vec3(0.0, 0.0, 20.0),\n           vec3(30.0, 5.0, 30.0),\n           vec3(10.0, 0.0, 40.0)\n    ),\n    Bezier(vec3(-10.0, 0.0, 40.0),\n           vec3(-30.0, -5.0, 30.0),\n           vec3(0.0, 0.0, 20.0)\n    ),\n    Bezier(vec3(0.0, 0.0, 20.0),\n           vec3(0.0, 4.0, 30.0),\n           vec3(0.0, 0.0, 35.0)\n    ),\n    Bezier(vec3(0.0, 0.0, 35.0),\n           vec3(0.0, 5.0, 45.0),\n           vec3(0.0, 3.0, 60.0)\n    ),\n    Bezier(vec3(0.0, 5.0, 60.0),\n           vec3(0.0, -10.0, 75.0),\n           vec3(0.0, -20.0, 90.0)\n    )\n);\n\nvoid updateView() // update camera and aeroplane\n{\n    float tm = iTime / 8.0;\n    int idx = int(mod(tm, float(NUM_SEGS)));\n    vec3 p = bezier(trails[idx], fract(tm));\n    vec3 t = bezierTangent(trails[idx], fract(tm));\n    if (fract(tm) >= 0.6)\n    {\n        float k = smoothstep(0.6, 1.0, fract(tm));\n        int nxt = (idx + 1) % NUM_SEGS;\n        p = mix(p, bezier(trails[nxt], 0.0), k);\n        t = normalize(mix(t, bezierTangent(trails[nxt], 0.0), k));\n    }\n    rocket_position = p;\n    if (abs(t.z) >= EPS)\n        pitch = atan(-t.y / t.z);\n    else\n        pitch = 0.0;\n    yaw = atan(t.x, t.z);\n\n    bool fixed_pos = true;\n    if (fixed_pos)\n    {\n        float tm = mod(iTime / 10.0, 2.0 * PI);\n        camera_pos = vec3(30.0 * cos(tm), 25.0, 40.0 * sin(tm));\n        camera_lookat = vec3(0.0, 20.0, 0.0);\n        camera_z = normalize(camera_pos - camera_lookat);\n        camera_x = cross(camera_up, camera_z);\n        camera_y = cross(camera_z, camera_x);\n    }\n    else\n    {\n        camera_pos = p - 2.5 * t + (1.0 + 2.0 * max(0.0, t.y)) * camera_up;\n        camera_lookat = p;\n        camera_z = normalize(camera_pos - camera_lookat);\n        camera_x = cross(camera_up, camera_z);\n        camera_y = cross(camera_z, camera_x);\n    }\n}\n// End\n\n// derive corresponding ray direction for this fragment\nvec3 rayDirection(vec2 fragCoord)\n{\n    vec2 sXY = fragCoord - iResolution.xy / 2.0;\n    float z = -iResolution.y / 2.0 / tan(FOV / 2.0);\n    vec3 unit = normalize(vec3(sXY, z));\n    return normalize(unit.x * camera_x + \n                     unit.y * camera_y + \n                     unit.z * camera_z);\n}\n\n\nvec3 bgColor(Ray ray)\n{\n    // float cloud = smoothstep(0.0, 2.0, fbm((ray.d.xyz + vec3(iTime / 20.0, 0.0, 0.0)) * 10.0));\n    float cloud;\n    float theta = atan(ray.d.y, length(ray.d.xz));\n    if (theta >= radians(2.0))\n        cloud = smoothstep(0.6, 0.90, texture(iChannel1, (ray.d.xz * (200.0 / ray.d.y) * 0.00005 + vec2(iTime / 150.0, 0.0))).r);\n    else\n        cloud = 0.05;\n    float tm = mod(iTime / 8.0, 2.0 * PI);\n    vec3 sky = mix(mix(vec3(.72, .85, 1.3), vec3(0.937, 0.545, 0.353),\n                   smoothstep(0.6, 0.05, abs(sin(tm)))), vec3(.72, .85, 1.3),\n                   smoothstep(0.0, 0.4, ray.d.y)) - 0.5 * ray.d.y;\n    return sky * (1.0 - cloud) + vec3(1.3) * cloud;\n\n}\n\n// Soft shadow from iq\nfloat softShadow(vec3 p0, Light light, float w)\n{\n    float res = 1.0;\n    float t = 2.0 * DMIN;\n    vec3 rd = light.p - p0;\n    float tmax = length(rd);\n    rd /= tmax;\n    \n    for (int i = 0; i < MAX_SHADOW_STEPS && t < tmax; i++)\n    {\n        vec3 p = p0 + rd * t;\n        Material mat = hitMat;\n        float h = sdf(p);\n        hitMat = mat;\n        res = min(res, h / (w * t));\n        t += clamp(h, EPS, 0.05);\n        if (res < -1.0 || t > tmax)\n            break;\n    }\n    res = max(res, -1.0);\n    return 0.25 * (1.0 + res) * (1.0 + res) * (2.0 - res);\n    return res;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting(in vec3 p, in vec3 N, in vec3 V, in Light light)\n{\n    if (MaxV(hitMat.emit) > EPS)\n        return hitMat.emit;\n    float noShadow = softShadow(p, light, 0.5);\n\n    Material mat = hitMat;\n    vec3 L = normalize(light.p - p);\n    vec3 R = reflect(-L, N);\n    float N_dot_L = max(0.0, dot(N, L));\n    float R_dot_V = max(0.0, dot(R, V));\n    float R_dot_V_pow_n = (R_dot_V == 0.0)? 0.0 : pow(R_dot_V, mat.smoothness);\n    vec3 ambient = mat.ambient;\n    vec3 diffuse = mat.diffuse;\n    vec3 specular = mat.specular;\n\n    return light.I_ambient * ambient + noShadow * \n           (light.I_diffuse * diffuse * N_dot_L + \n           light.I_specular * specular * R_dot_V_pow_n);\n}\n\n// Cast a imaginary view ray\n// and use ray marching to intersect the scene\n// return the calculated color\nvec3 castRay(Ray ray0)\n{\n    vec3 color = vec3(0.0);\n    int top = 0;\n    int end = 1;\n    hitRecords[top] = HitRecord(ray0, vec3(0.6), 0);\n    while (top < end)\n    {\n        Ray ray = hitRecords[top].ray;\n        if (MaxV(hitRecords[top].g) < EPS)\n        {\n            top++;\n            continue;\n        }\n        float total_distance = 2.0 * EPS;\n        bool hit = false;\n        vec3 p;\n        float d;\n        float sign_d = sign(sdf(ray.o));\n        for (int i = 0; i < MAX_STEPS; i++)\n        {\n            p = ray.o + total_distance * ray.d;\n            intersect_ground = false;\n            d = sdf(p);\n            if (intersect_ground || abs(d) < EPS) // intersection\n            {\n                hit = true;\n                break;\n            }\n            total_distance += STEP_SIZE * abs(d);\n            sign_d = sign(d);\n            if (total_distance > DMAX)\n                break;\n        }\n        if (!hit)\n            color += hitRecords[top].g * bgColor(ray);\n        else\n        {\n            vec3 normalP = sdf_normal(p) * sign(d); // note that normal(p) always points outwards\n            for (int l = 0; l < NUM_LIGHTS; l++)\n                color += hitRecords[top].g * PhongLighting(p, normalP / sign(d), -ray.d, lights[l]); // restore normalP to distinguish front and back\n            if (REFLECTION && MaxV(hitMat.rg) >= EPS && hitRecords[top].depth < MAX_DEPTH)\n                hitRecords[end++] = HitRecord(Ray(p + 2.0 * EPS * normalP, reflect(ray.d, normalP)), hitRecords[top].g * hitMat.rg, hitRecords[top].depth + 1);\n            if (REFRACTION && MaxV(hitMat.tg) >= EPS && hitRecords[top].depth < MAX_DEPTH)\n            {\n                vec3 d_refraction = refract(ray.d, normalP, sign_d > 0.0 ? 1.0 / hitMat.eta : hitMat.eta);\n                hitRecords[end++] = HitRecord(Ray(p - 3.0 * EPS * normalP, d_refraction), \n                                                hitRecords[top].g * hitMat.tg, hitRecords[top].depth + 1);\n            }\n        }\n        top++;\n    }\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initScene();\n    initMaterials();\n    initLights();\n    updateView();\n    vec3 color = vec3(0.0);\n    if (AA) {\n        for (float i = -0.25; i <= 0.25 + EPS; i += 0.5)\n            for (float j = -0.25; j <= 0.25 + EPS; j += 0.5)\n            {\n                Ray ray = Ray(camera_pos, rayDirection(fragCoord + vec2(i, j)));\n                color += castRay(ray);            \n            }\n            color /= 4.0;\n    }\n    else\n    {\n        Ray ray = Ray(camera_pos, rayDirection(fragCoord));\n        color = castRay(ray);\n    }\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}