{"ver":"0.1","info":{"id":"7dyfDw","date":"1658290272","viewed":218,"name":"Dark Side of the Moon","username":"fiiisssh","description":"?","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["rainbow","pinkfloyd"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 rot(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return mat2(c, -s, s, c);\n}\n\nfloat s3_2 = sqrt(3.0)/2.0;\n\n// given a 2d coordinate system, fills it\n// with the pink floyd rainbow\nvec3 rainbow(vec2 uv) {\n    vec3 colors[6];\n    colors[0] = vec3(1.0, 0.0, 0.0);\n    colors[1] = vec3(1.0, 0.4, 0.0);\n    colors[2] = vec3(1.0, 1.0, 0.0);\n    colors[3] = vec3(0.4, 1.0, 0.0);\n    colors[4] = vec3(0.0, 0.5, 1.0);\n    colors[5] = vec3(0.5, 0.0, 0.8);\n    \n    vec3 col = vec3(0.0);\n    \n    // iterates over the colors and downwards\n    for (int i = 0; i < 6; i += 1) {\n        // y_variance is used to animate the color's y position\n        float y_variance = sin(uv.x - iTime * 2.0 * fract(float(i) * 12.34) + 2.0) / 16.0 * uv.x;\n        float y = 0.5 - float(i) * (1.0 / 6.0) + y_variance;\n        col += smoothstep(4.8 / 6.1, 1.0, 1.0 - abs(uv.y - y)) * colors[i];\n    }\n    \n    return col;\n}\n\n// produces a smooth horizontal line in the coordinate space\nfloat line(vec2 uv, float width) {\n    return smoothstep(1.0 - width, 1.0, 1.0 - abs(uv.y));\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdEquilateralTriangle(in vec2 p) {\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sd_triangle_fill(in vec2 p) {\n    float d = sdEquilateralTriangle(p);\n    return smoothstep(0.08, 0.0, d);\n}\n\nfloat sd_triangle_lines(in vec2 p, in float width) {\n    float d = sdEquilateralTriangle(p);\n    return 1.0 - smoothstep(0.0, width, abs(d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 0.0 is the center\n    vec2 uv = (fragCoord - iResolution.xy / 2.0)/iResolution.y;\n\n    vec3 col = vec3(0.0);\n    \n    vec2 rainbow_uv = uv * rot(radians(10.0 * sqrt(uv.x) + sin(iTime / 2.0)));\n    rainbow_uv.y *= 17.5 - sqrt(1.0 + uv.x * 220.0);\n    rainbow_uv.y -= 1.0 - sqrt(uv.x);\n    col += smoothstep(0., 0.8, rainbow(rainbow_uv) * step(1.0 - 1.0, rainbow_uv.x));\n\n    vec2 line_uv = uv * rot(radians(-10.0));\n    line_uv.y -= 0.055 + (sin(line_uv.x + iTime / 2.0) * 0.05) * (abs(line_uv.x) - 0.1);\n    col += smoothstep(0.8, 1.0, line(line_uv, 0.025) * step(0.0, -line_uv.x));\n    \n    // cover the line & rainbow within the triangle\n    vec2 triangle_uv = uv * 3.0 + vec2(0.0, 0.25);\n    col *= 1.0 - sd_triangle_fill(triangle_uv);\n    \n    // main triangle lines\n    vec3 lines = sd_triangle_lines(triangle_uv, 0.075 + cos(iTime) * 0.02)\n                  * vec3(0.7, 0.9, 1.0);\n    col += smoothstep(0.0, 0.9, lines);\n    \n    // thinner triangle lines to make the outer edge sharper\n    col += sd_triangle_lines(triangle_uv * 0.95, 0.02);\n    \n    // triangle connector to the white line\n    vec2 spread_uv = (uv * 9.0 + vec2(0.5, -0.4)) * rot(radians(-100.0 + sin(iTime / 2.0)));\n    spread_uv.x *= 2.25;\n    float spread = sd_triangle_fill(spread_uv) * smoothstep(0.1, -0.2, uv.x);\n    col += smoothstep(0.1, 1.0, spread);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}