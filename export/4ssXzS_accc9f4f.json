{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Created by vincent francois - cyanux/2014\n// Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License (CC BY-NC-ND 3.0)\n//\n// vfrancois.pro@hotmail.fr\n//\n// Distances + Phong Shading + Reflection (no iteration)\n\n// Some modifications : normal computation and reflect method from\n// https://www.shadertoy.com/view/4dj3zV\n\n// Boolean operator from iq website (tks)\n// https://iquilezles.org/articles/distfunctions\n\n// Tks to Lebesgue, Bourbaki group, and many others! (see Lp space)\n\n// Tks to tekf (math), iq (distance, raymarching), rez (the scene is dead, amazing simplicity), \n// dubmood  (best tracks 4 ever) and many others !\n\n// Varying this value!\n#define D 5.0 // distance from object\n\n// Choose your object :)\n\n//#define OBJECT sdBoundedPlane(p, vec2(1.0, 0.5))\n//#define OBJECT sdBox(p, vec3(1.5))\n//#define OBJECT sdFastOctahedron(p, vec3(0.5))\n#define OBJECT sdHexagon(p, 0.5)\n//#define OBJECT sdInfiniteSquarePrism(p, vec2(0.5, 0.7))\n//#define OBJECT sdInfiniteHexagonalPrism(p, vec2(0.5, 0.5))\n//#define OBJECT sdInfiniteRhombusPrism(p, vec3(0.5))\n//#define OBJECT sdRhombicuboctahedron(p, vec3(0.7))\n//#define OBJECT sdRhombus(p, 0.5)\n//#define OBJECT sdSquarePyramid(p, 1.0)\n//#define OBJECT sdTriangle(p, vec3(1.0))\n//#define OBJECT sdTruncatedCuboctahedron(p, vec3(0.7))\n//#define OBJECT sdTruncatedOctahedron(p, vec3(1.0))\n\n\n//#define OBJECT sdSphere(p, 1.5)\n\n// Following is a dirty code\n\n#define T iTime\n\nvec2 iMouseXY;\n//vec2 iMouseXY = vec2(0.0);\n\nfloat COS;\nfloat SIN;\n\nvec3 rX(vec3 v, float t) {\n\tfloat COS = cos(t);\n\tfloat SIN = sin(t);\n\treturn vec3(v.x,SIN*v.z+COS*v.y,COS*v.z-SIN*v.y);\n}\nvec3 rY(const vec3 v, const float t) {\n\tfloat COS = cos(t);\n\tfloat SIN = sin(t);\n\treturn vec3(COS*v.x-SIN*v.z, v.y, SIN*v.x+COS*v.z);\n}\n\nfloat sdBox(vec3 p, vec3 r) {\n\treturn\n\t\tmax(abs(p.x) - r.x, 0.0) +\n\t\tmax(abs(p.y) - r.y, 0.0) + \n\t\tmax(abs(p.z) - r.z, 0.0);\n}\nfloat sdBoundedPlane(vec3 p, vec2 r)\n{\n\treturn\n\t\tmax(\n\t\t\tabs(p.x) - r.x + abs(p.z) - r.y,\n\t\t\tabs(p.y - r.y));\n}\nfloat sdFastOctahedron(vec3 p, vec3 r) {\n\treturn abs(p.x) - r.x + abs(p.y) - r.y + abs(p.z) - r.z;\n}\nfloat sdHexagon(vec3 p, float r) {\n\treturn\n\t\tmax(\n\t\t\tmax(abs(p.x) - r , 0.0) - r +\tmax(abs(p.y) -r , 0.0) - r,\n\t\t\tabs(p.z - r));\n}\nfloat sdInfiniteSquarePrism(vec3 p, vec2 r) {\n\treturn\n\t\tmax(\n\t\t\tmax(abs(p.x) - r.x, 0.0) + max(abs(p.y) - r.y, 0.0),\n\t\t\tabs(p.y) - r.y);\n}\nfloat sdInfiniteHexagonalPrism(vec3 p, vec2 r) {\n\treturn\n\t\tmax(abs(p.x) - r.x, 0.0) - 0.5 * r.x +\n\t\tmax(abs(p.y) - r.y, 0.0) - 0.5 * r.y;\n}\nfloat sdInfiniteRhombusPrism(vec3 p, vec3 r) {\n\treturn\n\t\tmin(\n\t\t\tmax(abs(p.x) - r.x, 0.0) +\n\t\t\tmax(abs(p.y) - r.y, 0.0) +\n\t\t\tmax(abs(p.z) - r.z, 0.0),\n\t\t\tabs(p.x) - r.x + abs(p.y) - r.y);\n}\nfloat sdRhombicuboctahedron(vec3 p, vec3 r) {\n\treturn\n\t\tmax(abs(p.x) - r.x, 0.0) - 0.5 * r.x +\n\t\tmax(abs(p.y) - r.y, 0.0) - 0.5 * r.y +\n\t\tmax(abs(p.z) - r.z, 0.0) - 0.5 * r.z;\n}\nfloat sdRhombus(vec3 p, float r) {\n\treturn\n\t\tmax(\n\t\t\tabs(p.x) - r + abs(p.y) - r + abs(p.z) - r,\n\t\t\tabs(p.x - r));\n}\nfloat sdSquarePyramid(vec3 p, float r) {\n\treturn \n\t\tmax(\n\t\t\tabs(p.x) - r + abs(p.y) - r + abs(p.z) - r,\n\t\t\tmax(r - p.y, 0.0) - 0.5);\n}\nfloat sdTriangle(vec3 p, vec3 r) {\n\treturn \n\t\tmax(\n\t\t\tmax(\n\t\t\t\tabs(p.x) - r.x + abs(p.y) - r.y + abs(p.z) - r.z,\n\t\t\t\tmax(r.y - p.y - 0.5, 0.0)),\n\t\t\tabs(p.x - r.x));\n\t\t\t\n}\nfloat sdTruncatedCuboctahedron(vec3 p, vec3 r) {\n\treturn\n\t\tmax(\n\t\t\tabs(p.x) - r.x + abs(p.y) - r.y + abs(p.z) - r.z - (abs(r.x)+abs(r.y)+abs(r.z)) * 0.33,\n\t\t\tmax(abs(p.x) - r.x, 0.0) - 0.5 * r.x + max(abs(p.y) - r.y, 0.0) - 0.5 * r.y + max(abs(p.z) - r.z, 0.0) - 0.5 * r.z\n\t\t);\t\t\t\n}\nfloat sdTruncatedOctahedron(vec3 p, vec3 r) {\n\treturn\n\t\tmax(\n\t\tabs(p.x) - r.x +\n\t\tabs(p.y) - r.y + \n\t\tabs(p.z) - r.z,\n\t\t\tmax(abs(p.x) - r.x, 0.0) - 0.5 * r.x + max(abs(p.y) - r.y,0.0) - 0.5 * r.y + max(abs(p.z) - r.z,0.0));\n\t\t\t\n\t\t\n}\nfloat sdSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nbool is_dCM = false;\n\nfloat scene(vec3 p) {\n\tfloat dCM = -sdSphere(p, 16.0);\n\t\n\tp = rY(p, iTime);\n\t\n\tfloat dO = OBJECT;\n\t\t\n\tif(dCM < dO) is_dCM = true;\n\t\t\t\t\t \n\treturn min(dO, dCM);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    iMouseXY = 8.0 * (iMouse.xy / iResolution.xy - 0.5);\n    COS = cos(T);\n    SIN = sin(T);\n\n\tfragColor = vec4(1.0);\n\t\n\tvec2 ar = vec2(iResolution.x/iResolution.y, 1.0);\n\tvec2 uv = ar * (fragCoord.xy / iResolution.xy - 0.5);\n\t\n\tvec3 ro = -rY(rX(vec3(0.0, 0.0, D) , iMouseXY.y), iMouseXY.x);\n\tvec3 co = ro;\n\tvec3 rd = normalize(rY(rX(vec3(uv, 1.0), iMouseXY.y), iMouseXY.x));\n\t\n\tvec3 gradient;\n\tfloat d;\n\t\n\tfor(float n = 0.0; n < 128.0; n++) {\n\t\td = scene(ro);\n\t\tif(d < 0.01) {\n\t\t\tgradient.x = scene(ro + vec3(0.00001, 0.0,   0.000));\n\t\t\tgradient.y = scene(ro + vec3(0.0,   0.00001, 0.000));\n\t\t\tgradient.z = scene(ro + vec3(0.0,   0.0,   0.00001));\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t\tro += rd * d * 0.5;\n\t}\n\t\n\t\n\tif(is_dCM == true)\n\t{\n\t\tfragColor = texture(iChannel0, ro);\n\t\treturn;\n\t}\n\t\n\t// Light position\n\tvec3 Lp = rY(vec3(0.0, 0.0, 10.0), T * 4.0);\n\t// The direction vector from the point on the surface toward each light source\n\tvec3 L = normalize(Lp - ro);\n\t// The normal at this point on the surface\n\t// !!! Valid normal !!!\n\tvec3 n = normalize(gradient - d);\n\t// The direction that a perfectly ray of light would take from this point on the\n\t// surface\n\tvec3 r = 2.0 * dot(L, n) * n - L;\n\t// The direction pointing towards the viewer (such as virtual camera)\n\tvec3 e = r;\n\t// The direction of reflection\n\t//vec3 f = 2.0 * dot(normalize(rd), n) * n + normalize(rd);\n\t// correct reflection vector (from https://www.shadertoy.com/view/4dj3zV)\n\tvec3 f = reflect(normalize(rd), n);\n\t// Ambient, Diffuse and Specular components\n\tvec3 Ca = mix(vec3(0.25),texture(iChannel0, f).xyz, 0.9);\n\tvec3 Cd = mix(vec3(0.4), texture(iChannel0, f).xyz, 0.5);\n\tvec3 Cs = mix(vec3(0.4), texture(iChannel0, f).xyz, 0.3);\n\t// Shininess\n\tfloat P  = 0.3;\n\t// Ambient factor\n\tfloat Ka = 0.9;\n\t// Diffuse factor\n\tfloat Kd = 0.1;\t\n\t// Specular factor\n\tfloat Ks = 0.001;\t\n\t// Diffuse (Lambertian) Component\n\tvec3 Ld = Kd * Cd * max(0.0, dot(n, L));\t\n\t// Ambient Component\n\tvec3 La = Ka * Ca;\t\n\t// Specular (Phong) Component\n\tvec3 Ls = Ks * Cs * pow(max(0.0, dot(e, r)), P);\t\n\t// Total radiance\n\tvec3 Ip = (La + Ld + Ls) / length(Lp) * length(Lp);\t\n\n\tfragColor.xyz = Ip;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4ssXzS","date":"1403352802","viewed":242,"name":"SomethingMetallic6","username":"cyanux","description":"Valid Truncated Cuboctahedron & gradient values modified (thickness simulation) [Special thanks to TekF for normal and gradient (much better than me in 3d, for sure)]","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","distance"],"hasliked":0,"parentid":"","parentname":""}}