{"ver":"0.1","info":{"id":"4cjGDR","date":"1704124294","viewed":38,"name":"Sand With Inertia","username":"maze_maze","description":"Sand with inertia","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["simulation","particles","physics","particle","sand"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// We also can add subpixel movement in future for more realistic movement of particles\nvoid mainImage(out vec4 color, vec2 frag) {\n    color.rgb = vec3(texelFetch(iChannel0, ivec2(frag), 0).z);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 tile(int xo, int yo) {\n    ivec2 p = pos + ivec2(xo, yo);\n    if (p != clamp(p, ivec2(0), iRes - 1))\n        return vec4(0, 0, 1, 0);\n    else\n        return texelFetch(iChannel0, p, 0);\n}\nbool random(int xo, int yo) {\n    ivec2 p = pos + ivec2(xo, -yo);\n    return (p.x * 5 ^ p.y * 7 ^ iFrame * 11) % 3 != 0;\n}\nvoid mainImage(out vec4 color, vec2 frag) {\n    initStuff;\n    vec4 current = tile(0, 0);\n    switch (int(current.z)) {\n    case 2:\n        current.y -= 0.1;\n        if (random(1, 0) && int(tile(1, -1).z) == 0 && int(tile(1, 0).z) == 0 && int(tile(0, -1).z) != 0)\n            current.x += 0.5;\n        if (random(-1, 0) && int(tile(-1, -1).z) == 0 && int(tile(-1, 0).z) == 0 && int(tile(0, -1).z) != 0)\n            current.x -= 0.5;\n        break;\n    }\n    if (iMouse.z > 0. && distance(frag, iMouse.xy) < 4.)\n        current = vec4(0, 0, 2, 0);\n    color = vec4(clamp(current.xy, -16., 16.), current.z, 0);\n    if (iFrame == 0) {\n        if (length(vec2(pos - iRes / 2)) < 32.) {\n            color = vec4(0, 0, 2, 0);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Y movement\nvec4 getTile() {\n    if (pos != clamp(pos, ivec2(0), iRes - 1))\n        return vec4(0, 0, 1, 0);\n    else\n        return vec4(texelFetch(iChannel0, pos, 0));\n}\nvoid mainImage(out vec4 color, vec2 frag) {\n    initStuff;\n    ivec2 start = pos;\n    vec4 current_tile = getTile();\n    int dir = (iFrame & 1) * -2 + 1;\n    pos.y += dir;\n    bool on_edge = int(getTile().z) != 0;\n    pos = start;\n    if (int(current_tile.z) == 0) {\n        for (int i; i < 16; i++) {\n            pos.y -= dir;\n            vec4 tile = getTile();\n            if (int(tile.z) != 0) {\n                if (dir == sign(int(tile.y))) {\n                    int offset = abs(int(tile.y));\n                    if (i == offset)\n                        current_tile = tile;\n                    else if (on_edge && i < offset) {\n                        tile.x *= 0.9;\n                        current_tile = tile;\n                    }\n                }\n                break;\n            }\n        }\n    } else if (dir == sign(int(current_tile.y))) {\n        int end = abs(int(current_tile.y));\n        current_tile.x *= 0.95;\n        current_tile.y = 0.0;\n        for (int i; i < end; i++) {\n            pos.y += dir;\n            vec4 tile = getTile();\n            if (int(tile.z) != 0) {\n                break;\n            }\n            current_tile = vec4(0);\n        }\n    }\n    color = vec4(current_tile);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"ivec2 iRes;\nivec2 pos;\n#define initStuff iRes = ivec2(iResolution.xy); pos = ivec2(frag);","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// X movement\nvec4 getTile() {\n    if (pos != clamp(pos, ivec2(0), iRes - 1))\n        return vec4(0, 0, 1, 0);\n    else\n        return vec4(texelFetch(iChannel0, pos, 0));\n}\nvoid mainImage(out vec4 color, vec2 frag) {\n    initStuff;\n    ivec2 start = pos;\n    vec4 current_tile = getTile();\n    int dir = (iFrame & 1) * -2 + 1;\n    pos.x += dir;\n    bool on_edge = int(getTile().z) != 0;\n    pos = start;\n    if (int(current_tile.z) == 0) {\n        for (int i; i < 16; i++) {\n            pos.x -= dir;\n            vec4 tile = getTile();\n            if (int(tile.z) != 0) {\n                if (dir == sign(int(tile.x))) {\n                    int offset = abs(int(tile.x));\n                    if (i == offset)\n                        current_tile = tile;\n                    else if (on_edge && i < offset) {\n                        tile.y *= 0.9;\n                        current_tile = tile;\n                    }\n                }\n                break;\n            }\n        }\n    } else if (dir == sign(int(current_tile.x))) {\n        int end = abs(int(current_tile.x));\n        current_tile.y *= 0.95;\n        current_tile.x = 0.0;\n        for (int i; i < end; i++) {\n            pos.x += dir;\n            vec4 tile = getTile();\n            if (int(tile.z) != 0) {\n                tile.y *= 0.5;\n                break;\n            }\n            current_tile = vec4(0);\n        }\n    }\n    color = vec4(current_tile);\n}","name":"Buffer C","description":"","type":"buffer"}]}