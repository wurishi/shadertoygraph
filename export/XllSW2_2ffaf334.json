{"ver":"0.1","info":{"id":"XllSW2","date":"1439816852","viewed":387,"name":"m.c. escher: sphere surface","username":"tly","description":"recreation of m.c. eschers \"sphere surface with fishes\" :)","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","noise","lines","sphere","escher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\nconst float PI = 3.14156;\n\nstruct Ray{\n\tvec3 p,v;\n};\n\t\nstruct Sphere{\n\tvec3 o;\n\tfloat r;\n};\n\t\nstruct Hit{\n\tbool hit;\n\tvec3 p;\n};\n\t\nHit hit(Ray ray,Sphere sphere){\n\tvec3 o = sphere.o - ray.p;\n\tfloat p = - 2.0 * dot(ray.v,o)  / dot(ray.v,ray.v);\n\tfloat q = (dot(o,o) - sphere.r * sphere.r) / dot(ray.v,ray.v);\n\tfloat temp = p*p*0.25 - q;\n\treturn Hit(\n\t\ttemp >= 0.0, temp >= 0.0 ? ray.p + ray.v * (-p*0.5 - sqrt(temp)) : vec3(0)\n\t);\n}\n\nvec3 rotateY(in vec3 v, in float a) {\n\treturn vec3(cos(a)*v.x + sin(a)*v.z, v.y,-sin(a)*v.x + cos(a)*v.z);\n}\n\nvec3 rotateX(in vec3 v, in float a) {\n\treturn vec3(v.x,cos(a)*v.y + sin(a)*v.z,-sin(a)*v.y + cos(a)*v.z);\n}\n\nfloat hash2 (vec2 p) {\n\treturn fract(sin(p.x*15.0 + p.y*35.7)*49379.37);\t\n}\n\nfloat noise2(vec2 p){\n\tvec2 iP = floor(p);\n\tvec2 fP = fract(p);\n\t\n\treturn mix(\n\t\tmix(hash2(iP + vec2(0,0)),hash2(iP + vec2(0,1)),fP.y),\n\t\tmix(hash2(iP + vec2(1,0)),hash2(iP + vec2(1,1)),fP.y),\n\t\tfP.x\n\t);\n\treturn 0.0;\n}\n\nfloat stretch(float x, float oldMin,float oldMax,float newMin,float newMax){\n\treturn (x-oldMin)/(oldMax-oldMin) * (newMax - newMin) + newMin;\n}\n\nfloat pattern(vec2 uv){\n\tuv.y = 1.12 * abs(2.0 * uv.y - 1.0) - 0.06;\n\t\n\tfloat h = uv.x < 0.1 ? stretch(-uv.x,-0.1,0.0,0.2,1.0):\n\t\t  uv.x < 0.3 ? stretch(uv.x,0.1,0.2,0.2,0.35):\n\t\t  uv.x < 0.5 ? stretch(-uv.x,-0.5,-0.3,0.0,0.5) :\n\t\t  uv.x < 0.65 ? stretch(uv.x,0.5,0.65,0.0,0.8) :\n\t\t  uv.x < 0.85 ? stretch(-uv.x,-0.85,-0.65,0.5,0.8) : \n\t\t\tstretch(uv.x,0.85,1.0,0.5,1.0);\n\t\n\tfloat eye1 = step(abs(distance(vec2(2.0,0.4),vec2(3.0 * uv.x, uv.y)) - 0.15),0.03);\n\tfloat eye2 = step(0.03,abs(distance(vec2(0.4,0.6),vec2(3.0 * uv.x, uv.y)) - 0.15));\n\treturn (step(h,uv.y) + step(uv.y,0.0) + eye1) * step(uv.y,1.0) * eye2;\n}\n\nvec3 map(vec2 p){\n\tfloat t = smoothstep(0.05,0.09,min(fract(p.x*60.0),fract(p.y*60.0)));\n\t \n\tfloat u = -log(1.0 - 2.0 * abs(p.y - 0.5)) + sign(p.y - 0.5) * p.x;\n\tu -= step(0.0,p.y-0.5) * 2.0 * u;\n\tu *= 2.0;\n\t\n\tfloat v = +log(1.0 - 2.0 * abs(p.y - 0.5)) + sign(p.y - 0.5) * 6.0 *  p.x;\n\tv -= step(0.0,p.y-0.5) * 2.0 * v;\n\t\n\treturn mix(\n\t\tvec3(0.3),\n\t\tmix(vec3(0.42),1.15 * vec3(0.7,0.7,0.6),pattern(fract(vec2(-v,u)))),\n\t\tt\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = ( fragCoord.xy / iResolution.xy ) - 0.5;\n\tuv.x *= iResolution.x/iResolution.y;\n\t\n\tRay ray = Ray(vec3(0,0,0),normalize(vec3(uv.x,uv.y,1)));\n\tSphere sphere = Sphere(vec3(0.2,0,5.4),2.0);\n\t\n\tHit h = hit(ray,sphere);\n\t\n\tvec3 n = normalize(h.p - sphere.o);\n\tfloat light = dot(n,vec3(0,0,-1));\n\t\n\tn = rotateY(n,-0.3);\n\tn = rotateX(n,-0.9);\n\tn = rotateY(n,-0.1 * iTime);\n\n\tfloat angleX = (atan(n.z,n.x) + PI)/(2.0 * PI);\n\tfloat angleY = acos(n.y)/PI;\n\t\n\tfragColor.w = 1.0;\n\tfragColor.xyz = mix(\n\t\tvec3(0.7,0.7,0.6) * (distance(uv,vec2(0.2,-0.3)) + 0.1),\n\t\tlight * map(vec2(angleX,angleY)),\n\t\tfloat(h.hit)\n\t) + 0.15 * (noise2(gl_FragCoord.xy/1.5)-0.5);\n}","name":"","description":"","type":"image"}]}