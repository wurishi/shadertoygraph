{"ver":"0.1","info":{"id":"tds3Wn","date":"1616450786","viewed":328,"name":"Postcard Raytracer Port","username":"Bio_Cyan","description":"A GLSL port of Andrew Kensler's postcard raytracer.","likes":5,"published":3,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 coord;\nfloat randState;\nvec2 rand() {\n    randState++;\n    return hash23(vec3(coord, randState));\n}\n\nfloat box_dist(vec3 point, vec3 mins, vec3 maxs)\n{\n    mins = point - mins;\n    maxs = maxs - point;\n    return -min(min(min(mins.x, maxs.x), min(mins.y, maxs.y)), min(mins.z, maxs.z));\n}\n\nfloat signed_dist(in vec3 point, out int type)\n{\n    float dist = 1e9;\n    vec2 flattened = point.xy;\n    vec4 line[] = vec4[](\n        vec4(-26, 0, -26, 16),\n        vec4(-26, 8, -22, 8),\n        vec4(-26, 16, -22, 16),\n        vec4(-13, 0, -13, 16),\n        vec4(-15, 0, -11, 0),\n        vec4(-15, 16, -11, 16),\n        vec4(-7, 0, 2, 16),\n        vec4(-7, 16, 2, 0),\n        vec4(3, 0, 10, 16),\n        vec4(10, 16, 14, 0),\n        vec4(8, 8, 12, 8),\n        vec4(18, 0, 18, 16),\n        vec4(18, 8, 22, 8),\n        vec4(18, 16, 22, 16),\n        vec4(20, 8, 26, 0)\n    );\n    for (int i = 0; i < 15; i++) {\n        vec2 base = line[i].xy*0.5;\n        vec2 edge = line[i].zw*0.5 - base;\n        float t = dot(flattened - base, edge)/dot(edge, edge);\n        t = min(max(0.0, t), 1.0);\n        vec2 offset = flattened - (base + edge*t);\n        dist = min(dist, dot(offset, offset));\n    }\n    dist = sqrt(dist);\n    vec2 a[] = vec2[](\n        vec2(-11, 6),\n        vec2(11, 6)\n    );\n    for (int i = 0; i < 2; i++) {\n        vec2 o = flattened - a[i];\n        float newdist;\n        if (o.x > 0.0) {\n            newdist = abs(sqrt(dot(o, o)) - 2.0);\n        } else {\n            o.y += o.y > 0.0 ? -2.0 : 2.0;\n            newdist = sqrt(dot(o, o));\n        }\n        dist = min(dist, newdist);\n    }\n    dist = pow(pow(dist, 8.0) + pow(abs(point.z), 8.0), 0.125) - 0.5;\n    type = 1;\n    float wall_dist = min(\n        -min(\n            box_dist(point, vec3(-30.0, -0.5, -30.0), vec3(30.0, 18.0, 30.0)),\n            box_dist(point, vec3(-25.0, 17.0, -25.0), vec3(25.0, 20.0, 25.0))\n        ),\n        box_dist(vec3(mod(abs(point.x), 8.0), point.yz), vec3(1.5, 18.5, -25.0), vec3(6.5, 20.0, 25.0))\n    );\n    if (wall_dist < dist) {\n        dist = wall_dist;\n        type = 2;\n    }\n    float source_dist = 19.9 - point.y;\n    if (source_dist < dist) {\n        dist = source_dist;\n        type = 3;\n    }\n    return dist;\n}\n\nint march_ray(in vec3 origin, in vec3 direction, out vec3 hit, out vec3 normal)\n{\n    int type;\n    int steps = 0;\n    float dist;\n    for (float t = 0.0; t < 100.0; t += dist) {\n        hit = origin + direction*t;\n        dist = signed_dist(hit, type);\n        if (dist < 0.01 || ++steps > 99) {\n            normal = normalize(vec3(\n                signed_dist(hit + vec3(0.01, 0.0, 0.0), steps) - dist,\n               \tsigned_dist(hit + vec3(0.0, 0.01, 0.0), steps) - dist,\n                signed_dist(hit + vec3(0.0, 0.0, 0.01), steps) - dist\n            ));\n            return type;\n        }\n    }\n    return 0;\n}\n\nvec3 trace_ray(vec3 origin, vec3 direction)\n{\n    vec3 hit;\n    vec3 normal;\n    vec3 reflected = vec3(0.0);\n    vec3 t = vec3(1.0);\n    vec3 light = normalize(vec3(0.6, 0.6, 1.0));\n    for (int bounce = 0; bounce < 3; bounce++) {\n        int type = march_ray(origin, direction, hit, normal);\n        if (type == 0) {\n            break;\n        }\n        if (type == 1) {\n            direction = direction - 2.0*normal*dot(normal, direction);\n            origin = hit + direction*0.1;\n            t *= 0.2;\n        }\n        if (type == 2) {\n            float irradiance = dot(normal, light);\n            vec2 rand = rand();\n            float yaw = 6.283185*rand.x;\n            float cosine2 = rand.y;\n            float sine = sqrt(1.0 - cosine2);\n            float g = normal.z < 0.0 ? -1.0 : 1.0;\n            float u = -1.0/(g + normal.z);\n            float v = normal.x*normal.y*u;\n            direction = -vec3(v, g + normal.y*normal.y*u, -normal.y)*cos(yaw)*sine\n                + vec3(1.0 + g*normal.x*normal.x*u, g*v, -g*normal.x)*sin(yaw)*sine\n                + normal*sqrt(cosine2);\n            origin = hit + direction*0.1;\n            t *= 0.2;\n            if (irradiance > 0.0 && march_ray(hit + normal*0.1, light, hit, normal) == 3) {\n                reflected += t*vec3(500.0, 400.0, 100.0)*irradiance;\n            }\n        }\n        if (type == 3) {\n            reflected += t*vec3(50.0, 80.0, 100.0);\n            break;\n        }\n    }\n    \n    return reflected;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    coord = fragCoord;\n    \n    float width = iResolution.x;\n    float height = iResolution.y;\n    vec3 eye = vec3(-22.0, 5.0, 25.0);\n    vec3 gaze = normalize(vec3(-3.0, 4.0, 0.0) - eye);\n    vec3 left = normalize(vec3(gaze.z, 0.0, -gaze.x))/width;\n    vec3 up = cross(gaze, left);\n    vec3 color = vec3(0.0);\n    float x = width - fragCoord.x;\n    float y = fragCoord.y;\n    int samples = 16;\n    for (int i = 0; i < samples; i++) {\n        vec2 offset = rand();\n        color += trace_ray(eye, normalize(gaze + left*(x - width/2.0 + offset.x) + up*(y - height/2.0 + offset.y)));\n    }\n   \tcolor = color/float(samples) + vec3(14.0/241.0);\n    color /= color + vec3(1.0);\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}