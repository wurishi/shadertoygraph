{"ver":"0.1","info":{"id":"Ntj3WV","date":"1624748358","viewed":187,"name":"Jamming cubes (shader jam port)","username":"rimina","description":"My shader from the livecode demozoo org launch shader jam. It's adapted a bit for shadertoy so it's not exactly the same code. Check out https://livecode.demozoo.org/","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["livecoding"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright Â© 2021-2022 rimina.\n// All rights to the likeness of the visuals reserved.\n\n// Any individual parts of the code that produces the visuals is\n// available in the public domain or licensed under the MIT license,\n// whichever suits you best under your local legislation.\n\n// This is to say: you can NOT use the code as a whole or the visual\n// output it produces for any purposes without an explicit permission,\n// nor can you remix or adapt the work itself without a permission.*\n// You absolutely CANNOT mint any NFTs based on the Work or part of it.\n// You CAN however use any individual algorithms or parts of the Code\n// for any purpose, commercial or otherwise, without attribution.\n\n// *(In practice, for most reasonable requests, I will gladly grant\n//   any wishes to remix or adapt this work :)).\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n    \n    vec3 col = texture(iChannel0, uv).rgb;\n\n    vec4 pcol = vec4(0.0);\n    vec2 puv = vec2(1.0/iResolution.x, 1.0/iResolution.y);\n    vec4 kertoimet = vec4(0.1531, 0.12245, 0.0918, 0.051);\n    pcol = texture(iChannel0, uv) * 0.1633;\n    pcol += texture(iChannel0, uv) * 0.1633;\n    for(int i = 0; i < 4; ++i){\n        pcol += texture(iChannel0, vec2(uv.x - (float(i)+1.0) * puv.y, uv.y - (float(i)+1.0) * puv.x)) * kertoimet[i] +\n        texture(iChannel0, vec2(uv.x - (float(i)+1.0) * puv.y, uv.y - (float(i)+1.0) * puv.x)) * kertoimet[i] +\n        texture(iChannel0, vec2(uv.x + (float(i)+1.0) * puv.y, uv.y + (float(i)+1.0) * puv.x)) * kertoimet[i] +\n        texture(iChannel0, vec2(uv.x + (float(i)+1.0) * puv.y, uv.y + (float(i)+1.0) * puv.x)) * kertoimet[i];\n    }\n    col += pcol.rgb;\n    col *= 0.8;\n    \n    col = mix(col, texture(iChannel0, uv).rgb, 0.6);\n    \n    col = smoothstep(-0.2, 1.2, col);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float E = 0.001;\nconst float FAR = 100.0;\nconst int STEPS = 100;\n\nconst vec3 FOG_COLOR = vec3(0.02, 0.08, 0.085);\nconst vec3 LIGHT_COLOR = vec3(0.9, 0.6, 0.3);\n\nvec3 glow = vec3(0.0);\n\nbool flip = false;\n\nfloat ID = 0.0;\n\nfloat sphere(vec3 p, float r){\n  return length(p)-r;\n}\n\nfloat box(vec3 p, vec3 b){\n  vec3 d = abs(p)-b;\n  return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\n//FROM MERCURY SDF LIBRARY\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\nvoid rotate(inout vec2 p, float a){\n  p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// 3D noise function (IQ)\nfloat noise(vec3 p){\n  vec3 ip = floor(p);\n  p -= ip;\n  vec3 s = vec3(7.0,157.0,113.0);\n  vec4 h = vec4(0.0, s.yz, s.y+s.z)+dot(ip, s);\n  p = p*p*(3.0-2.0*p);\n  h = mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n  h.xy = mix(h.xz, h.yw, p.y);\n  return mix(h.x, h.y, p.z);\n}\n\nfloat scene(vec3 p){\n  float safe = sphere(p, 1.0);\n  \n  vec3 pp = p; \n  for(int i = 0; i < 8; ++i){\n    pp = abs(pp) - vec3(0.4, 0.1, 0.5);\n    \n    rotate(pp.xy, /*fft*10.0*/iTime);\n    rotate(pp.xz, iTime*0.5);\n    rotate(pp.yz, /*fft*10.0+*/iTime*0.1);\n  }\n  \n  pp -= noise(p-iTime*2.0)*0.9;\n  float a = box(pp, vec3(0.5));\n  //a = max(a, -safe);\n  \n  pp = p;\n  pp -= noise(p+iTime*2.5)*0.4;\n  \n  float offset = 12.0;\n  \n  ID = floor((pp.z + offset*0.5) / offset);\n  pp.z = mod(pp.z + offset*0.5, offset)-offset*0.5;\n  \n  rotate(pp.yz, radians(90.0));\n  float tunnel = -fCylinder(pp, 12.0, 12.0);\n  rotate(pp.yz, -radians(90.0));\n  \n  glow += vec3(0.2, 0.5, 0.5) * 0.01 / (abs(a) + 0.01);\n  \n  if(tunnel < a){\n    flip = true;\n  }\n  else{\n    flip = false;\n  }\n  \n  return min(a, tunnel);\n}\n\nfloat march(vec3 ro, vec3 rd){\n  float t = E;\n  vec3 p = ro;\n  for(int i = 0; i < STEPS; ++i){\n    float d = scene(p);\n    t += d;\n    p = ro + rd*t;\n    \n    if(d < E || t > FAR){\n      break;\n    }\n  }\n  \n  return t;\n}\n\nvec3 normals(vec3 p){\n  vec3 e = vec3(E, 0.0, 0.0);\n  return normalize(vec3(\n    scene(p+e.xyy) - scene(p-e.xyy),\n    scene(p+e.yxy) - scene(p-e.yxy),\n    scene(p+e.yyx) - scene(p-e.yyx)\n  ));\n}\n\nvec3 shade(vec3 rd, vec3 p, vec3 n, vec3 ld){\n  if(flip){\n    n = -n;\n    ld = -ld;\n  }\n  float l = max(dot(n, ld), 0.0);\n  float a = max(dot(reflect(ld, n), rd), 0.0);\n  float s = pow(a, 10.0);\n  \n  vec3 lc = vec3(0.2, 0.9, 1.0);\n  vec3 sc= vec3(0.5, 0.9, 1.0);\n  \n  if(mod(ID, 2.0) == 0.0){\n    lc = lc.brg;\n    sc = sc.brg;\n  }\n  \n  return l * lc * 0.5 + s * sc * 0.8;\n}\n\n//https://iquilezles.org/articles/fog\nvec3 fog(vec3 col, vec3 p, vec3 ro, vec3 rd, vec3 ld){\n  float dist = length(p-ro);\n\tfloat sunAmount = max( dot(rd, -ld), 0.0 );\n\tfloat fogAmount = 1.0 - exp( -dist*0.06);\n\tvec3  fogColor = mix(FOG_COLOR, LIGHT_COLOR, pow(sunAmount, 10.0));\n  return mix(col, fogColor, fogAmount);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n\tvec2 uvv = uv - 0.5;\n\tuvv /= vec2(iResolution.y / iResolution.x, 1);\n    \n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 rt = vec3(0.0, 0.0, -1.0);\n    \n    vec3 z = normalize(rt-ro);\n    vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n    vec3 y = normalize(cross(x, z));\n\n    vec3 rd = normalize(mat3(x,y,z) * vec3(uvv, radians(40.0)));\n    vec3 col = vec3(0.0);\n\n    float t = march(ro, rd);\n    vec3 p = ro + rd*t;\n    vec3 n = normals(p);\n    vec3 ld = -z;\n    if(t < FAR){\n        col = shade(rd, p, n, ld);\n    }\n\n    col += glow * 0.1;\n    col = fog(col, p, ro, rd, ld);\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}