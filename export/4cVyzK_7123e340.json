{"ver":"0.1","info":{"id":"4cVyzK","date":"1732100162","viewed":25,"name":"RollBall","username":"MartinBeans","description":"First Shader","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["camroll"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Cam {\n    vec3 pos;\n    vec3 dir;//相机位置，相机朝向\n    vec3 rightWard;//相机朝向不足以完全约束相机，还希望可以旋转相机，因此还要限定右手方向\n    vec3 upWard;\n}cam;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n\n    \n    //定义模型\n    vec4 sphere = vec4(0., 0., 2., 1.);//xyz坐标，半径r\n    //vec3 sphereCenter = sphere.xyz;\n    \n       \n   //定义相机\n   //cam.pos=vec3(0,0,-0.5);\n   \n   cam.pos=sphere.xyz + vec3(sin(iTime), 0., cos(iTime)*5.);\n   cam.dir=normalize(sphere.xyz-cam.pos);//求球心到相机的向量\n   cam.rightWard=-cross(cam.dir, vec3(0,1,0));//通过叉乘“绝对朝上”向量来找右手边\n   cam.upWard=cross(cam.rightWard, cam.dir);\n   \n    vec3 ray=normalize(uv.x*cam.rightWard+uv.y*cam.upWard+1.*cam.dir);\n    vec3 sphereCenter = cam.pos-sphere.xyz;\n    \n     //求交点\n    float a=dot(ray, ray),\n          b=2.*dot(sphereCenter, ray),\n          c=dot(sphereCenter, sphereCenter) - sphere.w*sphere.w,\n          delta=b*b-4.*a*c,\n          k;\n\n   \n          \n   fragColor = vec4(0);\n   \n   if(delta<0.) \n   {\n       fragColor=texture(iChannel0,-ray);\n       return;\n   }\n   \n   k=(-b - sqrt(delta))/(2.*a);\n   vec3 p = k*ray;\n   \n   \n   //求法线向量，并归一化\n   vec3 normal = (p-sphere.xyz)/sphere.w;\n   \n   //定义一个光源\n   vec3 dirLight = normalize(vec3(-1.,-1.,.2));\n//进行光照漫反射处理\n   vec3 diffuse = vec3(1.0, 1.0, 1.0) * pow(max(0., (dot(normal, -dirLight)+10.)/11.),12.);\n   vec3 ambient = vec3(.8, .7, .7)*.12;//环境光\n   \n   fragColor.xyz = min(diffuse+ambient, 1.);\n    \n}","name":"Image","description":"","type":"image"}]}