{"ver":"0.1","info":{"id":"XdByzm","date":"1491333896","viewed":728,"name":"Sine to Gerstner Wave","username":"TinyTexel","description":"coarse/decent, approximative mapping from sine/cosine to trochoidal/gerstner wave \nred and green are the ground truth curves (normalized and unnormalized, respectively)\nthe white ones are the approximations\n(https://en.wikipedia.org/wiki/Trochoidal_wave)","likes":15,"published":1,"flags":8,"usePreview":0,"tags":["wave","sine","cosine","gerstner","trochoidal","cycloid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\ncoarse, approximative mapping from sine to trochoidal/gerstner wave \nred and green are the ground truth curves (normalized and unnormalized, respectively)\nthe white ones are the approximations\n\nhttps://en.wikipedia.org/wiki/Trochoidal_wave\nhttps://en.wikipedia.org/wiki/Trochoid\nhttps://en.wikipedia.org/wiki/Cycloid\nhttp://mathworld.wolfram.com/CurtateCycloid.html\n*/\n\n#define USE_DECENT_APPROX\n\n#define Time iTime\n\n/*\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define frac fract\n/**/\n\n#define rsqrt inversesqrt\n#define clamp(x) clamp(x, 0.0, 1.0)\n\nconst float Pi = 3.14159265359;\n\nfloat InvLerp(float a, float b, float r) { return (a - r) / (a - b); }\n\nfloat Pow4(float x)\n{\n    float x2 = x*x;\n    \n    return x2*x2;\n}\n\nfloat Root4(float x)\n{\n    return rsqrt(rsqrt(x));\n}\n\nfloat Pow4Pow2Lerp(float x, float l)\n{\n    float x2 = x * x;\n    \n    return (l + (1.0 - l) * x2) * x2;\n}\n\nfloat InvPow4Pow2Lerp(float x, float l)\n{\n    return sqrt(0.5 * (l - sqrt(l*l + (4.0 - 4.0 * l) * x))/(l - 1.0));\n}\n\n\n#ifdef USE_DECENT_APPROX\n    float SinToGWave00(float x, float l)\n    {\n        return 1.0 - InvPow4Pow2Lerp(1.0 - x, l);\n    }\n\n    float SinToGWave0(float x, float s)\n    {\n        float l = mix(0.001, 0.08, s);\n\n        float ss = 1.0 - Pow4Pow2Lerp(1.0 - s, l);\n\n        return SinToGWave00(x * ss, l);\n    }\n#else\n    float SinToGWave00(float x)\n    {\n        return 1.0 - Root4(1.0 - x);\n    }\n\n    float SinToGWave0(float x, float s)\n    {\n        float ss = 1.0 - Pow4(1.0 - s);\n\n        return SinToGWave00(x * ss);\n    }\n#endif\n\n\nfloat SinToGWave0N(float x, float s)\n{\n    return SinToGWave0(x, s) / s;\n}\n\nfloat SinToGWave(float x, float s)\n{\n    return SinToGWave0(x * 0.5 + 0.5, s) * 2.0 - s;\n}\n\nfloat SinToGWaveN(float x, float s)\n{\n    return SinToGWave0(x * 0.5 + 0.5, s) / s * 2.0 - 1.0;\n}\n\n// inverse ground truth curve (can not be analytically inverted)\nfloat InvGW(float y, float s)\n{\n    return acos(y/s) - sqrt(s*s - y*y);\n}\n\nfloat InvGW0(float y, float s)\n{\n    return InvGW((y * 2.0 - 1.0) * s, s) / Pi;\n}\n    \n\nfloat Plot(float f, float y)\n{\n    float v = f - y;\n    v /= length(vec2(dFdx(v), dFdy(v)));\n    v = clamp(1.0 - abs(v));\n    \n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 uv )\n{\n    vec2 tex = uv / iResolution.xy;\n    vec2 tex2 = tex * vec2(iResolution.x / iResolution.y, 1.0);\n    \n    float x = tex2.x;\n    float xx1 = abs(mod(x - 1.0, 2.0) - 1.0);\n    float xx2 = abs(mod(x + 1.5, 2.0) - 1.0);\n    float y = tex2.y;\n    \n    vec3 col = vec3(0.0);\n    float cos0 = cos((x - 1.5) * Pi);\n    float cos1 = cos0/Pi*2.0 * 0.5 + 0.5;\n    col = mix(col, vec3(0.05), Plot(0.5, y));\n    col = mix(col, vec3(0.2), Plot(cos1, y));\n    \n    float s = 1.0;// amplitude scale of the curve; dictates the shape (s=1: cycloid | s=0: sine)\n    s = mix(0.05, 0.98, sin(Time) * 0.5 + 0.5);\n\n    float sp = 0.5 - 0.5 * s/Pi*2.0;// used for plotting the ground truth version\n\n    // normalized to range [0..1]\n    col = mix(col, vec3(1.0, 0.0, 0.0), Plot(InvGW0(y, s), xx1));// correct\n    col = mix(col, vec3(1.0), Plot(SinToGWave0N(cos((x - 0.0) * Pi) * 0.5 + 0.5, s), y));// approx\n    \n    // unnormalized\n    col = mix(col, vec3(0.0, 1.0, 0.0), Plot(InvGW0(InvLerp(sp, 1.0 - sp, y), s), xx2));// correct\n    col = mix(col, vec3(1.0), Plot(SinToGWave(cos0, s)/Pi*2.0 * 0.5 + 0.5, y));// approx\n   \n    \n    //col = vec3(v);\n\t//fragColor = vec4(tex2, 0.0,1.0);\n    fragColor = vec4(pow(clamp(col), vec3(1.0/2.2)), 0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"XsfGRr","channel":0}],"code":"#define rsqrt inversesqrt\n#define clamp(x) clamp(x, 0.0, 1.0)\n\nconst float Pi = 3.14159265359;\n\nfloat Pow4(float x)\n{\n    float x2 = x*x;\n    \n    return x2*x2;\n}\n\nfloat Root4(float x)\n{\n    return rsqrt(rsqrt(x));\n}\n\nfloat SinToGWave00(float x)\n{\n    return 1.0 - Root4(1.0 - x);\n}\n\nfloat SinToGWave0(float x, float s)\n{\n    float ss = 1.0 - Pow4(1.0 - s);\n    \n    return SinToGWave00(x * ss);\n}\n\nfloat SinToGWave0N(float x, float s)\n{\n    return SinToGWave0(x, s) / s;\n}\n\nvec2 mainSound( in int samp, float time )\n{\n    float s = 0.9;\n    s = mix(0.9, 0.1, sin(time - Pi) * 0.5 + 0.5);\n    \n    return vec2(0.0);\n    return 0.5 * vec2( SinToGWave0N(sin(Pi*2.0 * 220.0 * mod(time, 2.0)) * 0.5 + 0.5, s) * 2.0 - 1.0);\n}","name":"Sound","description":"","type":"sound"}]}