{"ver":"0.1","info":{"id":"msd3zX","date":"1677641889","viewed":99,"name":"PBR experiments","username":"ianertson","description":"Just playing around with PBR","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 getColor(vec2 uv) { return texture(iChannel0, uv).rgb; }\n\n\nvec3 blurx(vec2 uv) {\n  vec3 col = vec3(0.0);\n  const int filterSize = 8;\n  const int halfFilterSize = filterSize / 2;\n\n  const int start = -halfFilterSize;\n  const int end = -halfFilterSize + filterSize;\n\n  float shadow = 0.0;\n  vec2 texelSize = 1.0 / vec2(textureSize(iChannel0, 0).xy);\n  int count = 0;\n  for(int x = start; x < end; ++x)\n  {\n      for(int y = start; y <= end; ++y)\n      {\n         vec3 next = texture(iChannel0, uv + (vec2(x, y) * texelSize)).rgb;\n         col += next;\n         count += 1;\n      }\n  }\n\n  col /= float(count);\n  return col;\n}\n\n\nfloat estimateNoise(vec3 col, vec2 uv) {\n    vec2 e = vec2(1.0) / R.xy;\n    vec3 a = vec3(\n        luma(getColor(uv + vec2(e.x, 0))),\n        luma(getColor(uv + vec2(0, e.y))),\n        luma(getColor(uv + vec2(e.x, e.y)))\n    );\n    \n    float l = luma(col);\n    float n1 = abs(l - ((a.x+a.y+a.z)/3.));\n    float n2 = abs(a.x - a.y);\n    float n3 = abs(a.x - a.z);\n    float n4 = abs(a.y - a.z);\n    float n5 = fwidth(l);\n    \n    float n = (n1+n2+n3+n4+n5)/5.0;\n    return clamp(n*M_PI, 0.0, 1.0);\n}\n\nvec3 shade(vec2 uv) {\n    vec3 col = getColor(uv);\n    float depth = texture(iChannel0, uv).a;\n    float noiseEst = estimateNoise(col, uv);\n    \n    vec3 smo = blurx(uv);\n    col = mix(col, smo, clamp(smoothstep(0.05, 1.0, depth)*2., 0.0, 1.));\n    col = mix(col, smo, noiseEst*noiseEst);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = fc/R.xy;\n    \n    col = shade(uv);\n    \n    O = vec4(clamp(col, 0.0, 1.0), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R (iResolution.xy)\n#define T (iTime+8.97)\n#define M_PI (3.14159265359)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n#define notzero(V) (abs(V) <= 0.000001 ? 0.01 : V)\n#define SAMPLE(var, OB, id_) if (id_ != skip && var < dist) { id = id_; dist = var; o = OB; }\n#define TEXTURE_SIGNATURE in vec2 uv, in vec3 p, inout Material m\n#define AMBIENT 0.03\n\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\nmat2 rot(float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\nstruct Object {\n    vec3 p;\n};\n\n#define NEW_OBJECT Object(vec3(0.0))\n\nstruct Material {\n    float rough;\n    float spec;\n    float metallic;\n};\n\n#define NEW_MATERIAL Material(1.0, 1.0, 0.0)\n\nstruct Data {\n    vec3 p;\n    vec3 n;\n    vec2 uv;\n    float d;\n    int id;\n    int skip;\n    Material m;\n    Object o;\n};\n\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), vec2(0.0), FAR, 0, 0, NEW_MATERIAL, NEW_OBJECT)\n\nstruct Light {\n    vec3 p;\n    vec3 d;\n    vec3 c;\n    float s;\n    int type;\n};\n\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\n\nvec3 getLightDir(in Light light, in vec3 p) {\n    switch (light.type) {\n        case LIGHT_AMBIENT: return normalize(light.p); break;\n        case LIGHT_POINT: return normalize(light.p - p); break;\n        case LIGHT_DIR: return normalize(light.d); break;\n    }\n    return vec3(0.0);\n}\n\nvec3 getLightAtt(in Light light, in vec3 p, in vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = max(AMBIENT, dot(n, L));\n    \n    switch (light.type) {\n        case LIGHT_AMBIENT: { return light.c * light.s * NdotL; }; break;\n        case LIGHT_POINT: { return light.c * (pow(light.s, 2.0) / max(0.0001, distance(\n            light.p, p))); }; break;\n        case LIGHT_DIR: { return light.c * light.s * smoothstep(0.8, 1.0, dot(\n            normalize(light.p - p),\n            L\n        )); }; break;\n    }\n    \n    return vec3(AMBIENT);\n}\n\nvec2 boxUv(in vec3 p, in vec3 n) {\n    vec2 uv = vec2(0.0);\n    uv = mix(uv, p.xy, round(adot(n, vec3(0, 0, 1))));\n    uv = mix(uv, p.xz, round(adot(n, vec3(0, 1, 0))));\n    uv = mix(uv, p.zy, round(adot(n, vec3(1, 0, 0))));\n    return uv;\n}\n\nvec3 fixNormal(vec3 wn, vec3 n, float th, float mixf) {\n    vec3 t = cross(wn, vec3(0, 1, 0));\n    vec3 b = vec3(0.0);\n    if (abs(length(t)) == 0.0) t = cross(wn, vec3(0, 0, 1));\n    t = normalize(t);\n    b = normalize(cross(wn, t));\n    mat3 tbn = mat3(t, b, -wn);\n    n = normalize((tbn)*n);\n    return normalize(mix(wn, n, mixf*max(th, dot(wn, n))));\n}\n\nvec3 EnvBRDFApprox(vec3 specularColor, float roughness, float ndotv) {\n  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * ndotv)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  return specularColor * AB.x + AB.y;\n}\n\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) *\n                  pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = M_PI * denom * denom;\n\n    return nom / notzero(max( denom, 0.000001 ));\n}\n\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nfloat GeometrySchlickGGX(float NdotV, float k)\n{\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / notzero(denom);\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float k)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx1 = GeometrySchlickGGX(NdotV, k);\n    float ggx2 = GeometrySchlickGGX(NdotL, k);\n\n    return ggx1 * ggx2;\n}\n\nfloat microfacetDistribution(float roughness, float NdotH)\n{\n    float roughnessSq = roughness * roughness;\n    float f = (NdotH * roughnessSq - NdotH) * NdotH + 1.0;\n    return roughnessSq / notzero((M_PI * f * f) + 0.00001);\n}\n\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nvec3 unreal(vec3 x) {\n  return x / (x + 0.155) * 1.019;\n}\n\nvec3 uchimura(vec3 x, float P, float a, float m, float l, float c, float b) {\n  float l0 = ((P - m) * l) / a;\n  float L0 = m - m / a;\n  float L1 = m + (1.0 - m) / a;\n  float S0 = m + l0;\n  float S1 = m + a * l0;\n  float C2 = (a * P) / (P - S1);\n  float CP = -C2 / P;\n\n  vec3 w0 = vec3(1.0 - smoothstep(0.0, m, x));\n  vec3 w2 = vec3(step(m + l0, x));\n  vec3 w1 = vec3(1.0 - w0 - w2);\n\n  vec3 TT = vec3(m * pow(x / m, vec3(c)) + b);\n  vec3 S = vec3(P - (P - S1) * exp(CP * (x - S0)));\n  vec3 L = vec3(m + a * (x - m));\n\n  return TT * w0 + L * w1 + S * w2;\n}\n\nvec3 uchimura(vec3 x) {\n  const float P = 1.0;  // max display brightness\n  const float a = 1.0;  // contrast\n  const float m = 0.22; // linear section start\n  const float l = 0.4;  // linear section length\n  const float c = 1.33; // black\n  const float b = 0.0;  // pedestal\n\n  return uchimura(x, P, a, m, l, c, b);\n}\n\nvec3 look(vec2 uv, vec3 point, vec3 ro) {\n    vec3 camForward = normalize(point - ro);\n    vec3 camRight = -normalize(cross(camForward, vec3(0, 1, 0)));\n    vec3 camUp = -normalize(cross(camRight, camForward));\n    vec3 screenCenter = ro + camForward * 1.;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// taken from https://www.shadertoy.com/view/ldGGzV\n\n#define MOVE_SPEED 10.\n#define PI 3.14159\n\nconst float KEY_W = 87.5 / 256.0;\nconst float KEY_A = 65.5 / 256.0;\nconst float KEY_S = 83.5 / 256.0;\nconst float KEY_D = 68.5 / 256.0;\nconst float KEY_SHIFT = 16.0;\nconst float KEY_SPACE = 32.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos = texture(iChannel1, vec2(0.)).xyz;\n    if(iFrame == 0) pos = vec3(0.,0.,0.);\n    \n    switch (int(fragCoord.x)) {\n        case 0: {\n            float mx = iMouse.xy == vec2(0.) ? 0. : ((iMouse.x / iResolution.x) * 2. - 1.) * 360.;\n            float speed = MOVE_SPEED * iTimeDelta;\n\n            speed *= 1.; //+ 2. * texture(iChannel0,vec2(KEY_SHIFT,0.)).r;\n\n            speed *= 3.0;\n\n            float forwardBackward =\n            texture(iChannel0, vec2(KEY_W, 0.)).r -\n            texture(iChannel0, vec2(KEY_S, 0.)).r;\n\n            float leftRight =\n            texture(iChannel0, vec2(KEY_A, 0.)).r -\n            texture(iChannel0, vec2(KEY_D, 0.)).r;\n\n            float s = sin(radians(mx));\n            float c = cos(radians(mx));\n\n            pos.x += speed * (forwardBackward * s - leftRight * c);\n            pos.z += speed * (forwardBackward * c + leftRight * s);\n        \n        }; break;\n        case 1: {\n            pos = texelFetch(iChannel1, ivec2(1, 0), 0).xyz;\n            float space = texelFetch(iChannel0, ivec2(KEY_SPACE, 0), 0).r;\n            float shift = texelFetch(iChannel0, ivec2(KEY_SHIFT, 0), 0).r;\n            \n            pos.y += space * 0.2;\n            pos.y -= shift * 0.2;\n           \n        \n        }; break;\n    }\n    \n    \n    fragColor = vec4(pos, 0.);\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define NEAR 0.003\n#define FAR 200.0\n#define STEPS 96\n\n#define ID_NONE 0\n#define ID_GROUND 1\n#define ID_BOX 2\n#define ID_CYL 3\n#define ID_TORUS 4\n\n#define WALK 0\n\nvec3 noise(in vec2 p, in float seed) {\n    return textureLod(iChannel3, (p + (seed*1.0023981828))/256.0, 0.0).xyz;\n}\n\nvec3 snoise(in vec2 p, in float seed) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p);\n    lv = lv*lv*(3.0-2.0*lv);\n    \n    return mix(\n        mix(noise(id, seed), noise(id+vec2(1, 0), seed), lv.x),\n        mix(noise(id+vec2(0, 1), seed), noise(id+vec2(1, 1), seed), lv.x),\n        lv.y\n    );\n}\n\nvec3 noise(in vec2 p, in float seed, in float freq) {\n    p += 2.2;\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    #define ADV n += amp*noise(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    ADV;ADV;ADV;ADV;\n    #undef ADV\n    return n/div;\n}\n\nvec3 snoise(in vec2 p, in float seed, in float freq) {\n    p += 2.2;\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    #define ADV n += amp*snoise(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    ADV;ADV;ADV;ADV;\n    #undef ADV\n    return n/div;\n}\n\nvec3 noise6(in vec2 p, in float seed, in float freq) {\n    p += 2.2;\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    #define ADV n += amp*noise(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    ADV;ADV;ADV;ADV;ADV;ADV;\n    #undef ADV\n    return n/div;\n}\n\nvec3 snoise6(in vec2 p, in float seed, in float freq) {\n    p += 2.2;\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    #define ADV n += amp*snoise(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    ADV;ADV;ADV;ADV;ADV;ADV;\n    #undef ADV\n    return n/div;\n}\n\nfloat boxSDF(in vec3 p, in vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat cylSDF(in vec3 p, in vec3 dir, in float l, in float r) {\n    dir = normalize(dir);\n    vec3 a = vec3(0.0);\n    vec3 b = dir*l;\n    vec3 p2 = p * dot(normalize(p), dir) / l;\n    vec3 pa = p -a;\n    vec3 ba = b -a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    float j = length(pa - ba * h) - r;\n    return max(j, length(p2)-(h+(r/(6.28*l))));\n}\n\n\nfloat torusSDF(in vec3 p, in float r1, float r2) {\n    p = p.yzx;\n    float ll = length(p.yz)-r1;\n    return length(vec2(ll,p.x))-r2;\n}\n\nfloat groundSDF(in vec3 p) {\n    if (p.y > 90.) return p.y;\n    float h = 0.0;\n    \n    float area = smoothstep(8.0, 32.0, distance(p.xz, vec2(0.0)));\n    \n    vec3 lf = snoise6(p.xz, 1.03928915, 0.02);\n    \n    \n    \n    h += smoothstep(5., 32.0, pow(lf.x, 3.0)*32.)*64.;\n    h -= smoothstep(8.5, 16.0, lf.y*16.)*32.;\n    \n    h += (pow(lf.z, 2.)*2.0-1.0)*16.;\n    \n    h *= area;\n\n    return (p.y - h)/2.2;\n}\n\nfloat getDist(inout Data data, in vec3 p) {\n    float dist = FAR;\n    int id = ID_NONE;\n    int skip = data.skip;\n    Object o = NEW_OBJECT;\n    \n    float ground = groundSDF(p);\n    SAMPLE(ground, o, ID_GROUND);\n    \n    Object oBox = Object(vec3(0, 0.9 + ((0.5+(0.5*cos(T)))*3.3), sin(T)));\n    float box = boxSDF(p - oBox.p, vec3(0.5)) - 0.1;\n    \n    \n    SAMPLE(box, oBox, ID_BOX);\n    \n    Object oThing = Object(vec3(cos(T), 0.4+(0.5+(0.5*sin(T)))*3.3, 2));\n    float thing = cylSDF(p - oThing.p, vec3(0, 1., 0), 2., 0.2);\n    SAMPLE(thing, oThing, ID_CYL);\n    \n    Object oTorus = Object(vec3(-3., 0.2+(0.5+(0.5*sin(T+2.22382814)))*3.3, 3.));\n    float torus = torusSDF(p - oTorus.p, 0.6, 0.2);\n    SAMPLE(torus, oTorus, ID_TORUS);\n    \n    data.id = id;\n    data.o = o;\n    \n    return dist;\n}\n\n\nbool march(inout Data data, in vec3 ro, in vec3 rd) {\n    float dist = 0.0;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p);\n        dist += next;\n        if (abs(next) <= (NEAR * (1.0 + (abs(dist))))) break;\n        if (abs(dist) >= FAR) return false;\n    }\n    \n    vec3 p = ro+rd*dist;\n    vec2 e = vec2(NEAR*2., 0.0);\n    vec3 n = normalize(getDist(data, p) - vec3(\n        getDist(data, p - e.xyy),\n        getDist(data, p - e.yxy),\n        getDist(data, p - e.yyx)\n    ));\n    vec2 uv = boxUv(p - data.o.p, n);\n    \n    data.p = p;\n    data.n = n;\n    data.uv = uv;\n    data.d = dist;\n    \n    return true;\n}\n\nfloat getShadow(in int skip, in vec3 ro, in vec3 rd, in float near, in float far) {\n    float dist = 0.0;\n    Data data = NEW_DATA;\n    data.skip = skip;\n    far = min(far, FAR);\n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p);\n        dist += next;\n        if (abs(next) <= (NEAR * (1.0+abs(dist)))) break;\n        if (abs(dist) >= FAR) return 1.0;\n    }\n    \n\n    dist = abs(dist);\n    return clamp((dist)/(1.0+dist), AMBIENT, 0.88);\n}\n\n//#define DEBUG_TEXTURE metalTexture\n\nvec3 metalTexture(TEXTURE_SIGNATURE) {\n    vec3 col = vec3(0.0);\n    vec3 hf = noise6(uv, 3.99288235, 64.0);\n    vec3 hf2 = noise6(uv * hf.yz, 2.22237215, 16.0);\n    vec3 lf = snoise6(uv/2., 1.33332815, 10.0);\n    \n    float cracks = abs(lf.x-lf.z);\n    cracks = max(0.0, 1.0-smoothstep(0.02, 0.07, cracks));\n    cracks = cracks*hf.y*hf2.z;\n    \n    vec3 c1 = rgb(131, 133, 135);\n    vec3 c2 = rgb(193, 191, 190);\n    vec3 c3 = rgb(148, 140, 136);\n    vec3 c4 = rgb(177, 184, 192);\n    \n    vec3 met = mix(mix(mix(c1, c2, hf.x), c3, hf.y), c4, hf.z);\n    met = (met*0.5)+(0.5*mix(mix(mix(met, c1, hf2.x), c2, hf2.y), c3, hf2.z));\n    \n    col += met;\n    col = mix(col, col*col, cracks);\n    \n    m.spec = clamp(luma(col) - cracks, 0.2, 1.0);\n    m.rough = clamp(cracks*cracks, 0.1, 1.0);\n    m.metallic = luma(col);\n    \n    return col;\n}\n\nvec3 grassTexture(TEXTURE_SIGNATURE) {\n    vec3 col = vec3(0.0);\n//    uv *= 4.;\n    vec3 hf = noise6(uv, 0.9382815, 100.0);\n    vec3 hf2 = noise6(uv + (hf.xy*0.1), 2.3982333, 64.0);\n    vec3 lf = snoise(uv, 1.9763628858, 1.2);\n    vec3 area = snoise6(uv + hf2.yz, 1.11183829, 1.);\n    vec3 area2 = snoise6(uv, 3.33392815, 2.0);\n    vec3 grainv = noise6(uv+(area.xy/2.), 1.88273777, 64.0);\n    vec3 grainv2 = \n        clamp(abs(normalize(refract(cross(reflect(grainv, area), hf2), hf, dot(grainv, hf)*1.47))), 0.0, 1.0);\n    float grain1 = clamp(pow(grainv.x, 6.0)*2., 0.0, 1.0);\n    float grain2 = clamp(pow(grainv2.z, 6.0)*2.0, 0.0, 1.0);\n    \n\n    float cracks = (1.0-smoothstep(0.01, 0.05, abs(area2.x-lf.x)));\n    \n    \n    float mudArea = pow(area.x, 2.);\n    mudArea = (1.0-smoothstep(0.02, 0.23, mudArea));\n    \n    float rockArea = pow(area2.y, 2.0);\n    rockArea = (1.0-smoothstep(0.02, 0.23, rockArea));\n    rockArea *= max(0.0, 1.0 - mudArea*2.);\n    float inv = clamp(1.0-smoothstep(0.02, 0.6, lf.z), 0.0, 1.0);\n    rockArea *= clamp(inv*8., 0.0, 1.0);\n    \n    rockArea += smoothstep(1., 16.0, max(0.0, p.y))*max(area2.z, 0.1);\n    rockArea = clamp(rockArea, 0.0, 1.0);\n  //  mudArea += float(p.y > 2.0 && p.y < 5.0);\n   \n   float sm = 1.1;\n   mudArea += smoothstep(-sm, 5.0+sm, max(0.0, p.y)) * \n              smoothstep(-sm, 5.0+sm, max(0.0, (-p.y)+5.0));//*smoothstep(-sm, 4.0+sm, max(0.0, (-p.y)+5.));//max(0.0, 1.0-(rockArea*9.)) * (smoothstep(0., 2., max(0.0, p.y-(1.0-sm))) * smoothstep(0.0-sm, 5., max(0.0, (-p.y)+(5.0+sm))));\n   //mudArea += smoothstep(1., 16.0, max(0.0, p.y-6.))*(1.0-smoothstep(1., 16.0, max(0.0, p.y+6.)));\n    mudArea = clamp(mudArea, 0.0, 1.0);\n    float between = max(0.0, 1.0-smoothstep(0.02, 0.5, abs(1.0-(rockArea+mudArea)*5.)));\n  \n    \n    vec3 g1 = rgb(56, 77, 31);\n    vec3 g2 = rgb(93, 111, 73);\n    vec3 g3 = rgb(101, 130, 56);\n    vec3 g4 = rgb(66, 70, 46);\n    \n    vec3 m1 = rgb(107, 85, 65);\n    vec3 m2 = rgb(66, 50, 39);\n    vec3 m3 = rgb(99, 85, 69);\n    vec3 m4 = rgb(123, 110, 105);\n    \n    vec3 r1 = rgb(175, 168, 159);\n    vec3 r2 = rgb(196, 178, 151);\n    vec3 r3 = rgb(106, 102, 96);\n    vec3 r4 = rgb(152, 149, 150);\n    \n    vec3 grassCol = mix(mix(mix(g1, g2, hf.x), g3, hf.y), g4, hf.z);\n    vec3 mudCol = mix(mix(mix(m1, m2, hf2.x), m3, hf2.y), m4, hf2.z);\n    vec3 rockCol = mix(mix(mix(r1, r2, (grainv2.x+area.x)/2.), r3, (grainv2.y+area.y)/2.), r4, \n        (grainv2.z+area.z)/2.);\n    rockCol = mix(rockCol, rockCol*rockCol, grainv.z);\n    \n    col += grassCol;\n    col = mix(col, mudCol, clamp(mudArea*3., 0.0, 1.0));\n    col = mix(col, col*col, grain1);\n    col = mix(col, col*col, clamp(grain2*mudArea*10., 0.0, 1.0));\n    col = mix(col, rockCol, rockArea);\n    \n    col += clamp(pow(rockArea, 20.0), 0.0, 1.0)*r2;\n    col = mix(col, m1*r1, between*cracks);\n    col = mix(col, col*col, cracks*area.y*area2.z*lf.y*lf.z);\n    col = mix(col, col*col, lf.z);\n    col = mix(col, col*col, 0.6*clamp(lf.x*(lf.y*cracks)*0.5+(between*0.5), 0.0, 1.0));\n    m.spec = clamp((mudArea+rockArea)/2., 0.0, 1.0);\n    \n\n    m.rough = 1.0;//clamp(1.0 - (mudArea*mudArea), 0.2, 1.0);\n    return col;\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    vec2 uv = data.uv;//data.p.xz;//data.uv;\n    vec3 p = data.p;\n    vec3 col = grassTexture(uv, p, data.m);\n    \n    /*\n    float e = -0.02;\n    vec3 bump = fixNormal(data.n, normalize(luma(col) - vec3(\n        luma(grassTexture(uv + vec2(e, 0), p, data.m)),\n        luma(grassTexture(uv + vec2(0, e), p, data.m)),\n        clamp(1.0-((data.d/FAR)*0.5), 0.1, 0.5)\n    )), 0.2, clamp(1.0-((data.d/FAR)*6.), 0.0, 1.0));\n    data.n = bump;*/\n    return col;\n}\n\nvec3 getAlbedoCyl(inout Data data) {\n    vec2 uv = data.uv;\n    vec3 p = data.p;\n    vec3 col = metalTexture(uv, p, data.m);\n    return col;\n}\nvec3 getAlbedoBox(inout Data data) {\n    vec2 uv = data.uv;\n    vec3 p = data.p;\n    vec3 col = metalTexture(uv, p, data.m);\n    return col;\n}\n\n\nvec3 getAlbedoTorus(inout Data data) {\n    vec2 uv = data.uv;\n    vec3 p = data.p;\n    vec3 col = snoise6(uv, 2.2093815, 4.0);\n    data.m.rough = clamp(noise6(uv*2., 9.3288215, 32.0).r*2., 0.0, 1.0);\n    return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_GROUND: return getAlbedoGround(data); break;\n        case ID_CYL: return getAlbedoCyl(data); break;\n        case ID_BOX: return getAlbedoBox(data); break;\n        case ID_TORUS: return getAlbedoTorus(data); break;\n    }\n    \n    return vec3(0.77);\n}\n\nvec3 getSky(in Data data, in Light light, in vec3 ro, in vec3 rd) {\n    vec2 uv = rd.xz/rd.y;\n    vec3 col = vec3(0.0);\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    \n    vec3 blue = vec3(0.29, 0.61, 0.9);\n    \n    col = pow(blue, vec3(1.0 + (dotup*2.)));\n    \n    return col;\n    \n}\n\nvec3 forEachLight(inout Data data, in Light light, in vec3 ro, in vec3 rd, in vec3 albedo) {\n    vec3 diffuse = albedo / M_PI;\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec3 L = getLightDir(light, p);\n    vec3 ref = reflect(L, n);\n    float VdotR = cdot(rd, ref);\n    float spec = data.m.spec * pow(VdotR, 32.0);\n    vec3 att = getLightAtt(light, p, n);\n    float shadow = getShadow(data.id == ID_GROUND ? 2031 : data.id, p+(n*NEAR*2.), L, data.d, light.type == LIGHT_AMBIENT ? FAR : \n        distance(light.p, p));\n        \n    vec3 H = normalize(L + rd);\n    float metallic = data.m.metallic;\n    float rough = data.m.rough;\n    float NdotL = max(dot(n, L), 0.0);\n    float NdotH = clamp(dot(n, H), 0.000001, 1.0);\n    float HdotV = clamp(dot(H, rd),0.000001, 1.0);\n    vec3 f0 = mix(vec3(0.04), diffuse, metallic);\n    float NdotV = dot(n, rd);\n    vec3 fresnel = fresnelSchlick(HdotV, f0);\n    float D = microfacetDistribution(rough, NdotH);\n    float S = DistributionGGX(n, H, rough);\n    float G = GeometrySmith(n, rd, L, rough);\n    float Fsd = (4.0 * NdotV * NdotL);\n    vec3 specularity = (fresnel * S * G) / notzero(Fsd);\n    \n    vec3 kd = vec3(1.0) - specularity;\n    kd *= 1.0 - metallic;\n        \n    return (kd * diffuse + (specularity + spec)) * att * shadow;\n}\n\n#define NUM_LIGHTS 1\n\nvec3 render(inout Data data, in vec3 ro, in vec3 rd, inout float depth) {\n    vec3 col = vec3(0.0);\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    \n    Light lights[NUM_LIGHTS];\n    lights[0] = Light(vec3(1, 2, -3), vec3(0.0), vec3(0.97, 0.78, 0.69), 2.0, LIGHT_AMBIENT);\n    \n    vec3 mixf = vec3(1.0);\n    vec3 ord = rd;\n    vec3 oro = ro;\n    float dist = FAR;\n    for (int j = ZERO; j < 2; j++) {\n        if (march(data, ro, rd)) {\n            if (j <= 0) { dist = abs(data.d); }\n            \n            vec3 n = data.n;\n            vec3 albedo = getAlbedo(data);\n            \n            \n            for (int i = ZERO; i < NUM_LIGHTS; i++) {\n                Light light = lights[i];\n\n                col += forEachLight(data, light, ro, rd, albedo) * mixf;\n                \n            }\n\n            \n           if (data.m.rough > 0.999 || abs(data.d) > (FAR/2.)) break;\n            \n            float rough = data.m.rough;\n\n            float NdotV = dot(n, -rd);\n            rd = reflect(rd, n);\n            ro = data.p+(data.n*NEAR*2.);\n            float metallic = data.m.metallic;\n            vec3 diffuse = albedo / M_PI;\n            \n            vec3 f0 = mix(vec3(0.04), diffuse, metallic);\n            vec3 F = fresnelSchlickRoughness(NdotV, f0, rough*rough);\n\n            \n            mixf *= F * max(0.0, 1.0-((rough*rough)*0.8));\n\n        } else {\n            col += getSky(data, lights[0], ro, rd) * mixf;\n            break;\n        }\n    }\n    \n    depth = dist / FAR;\n    \n    col += smoothstep(0.1, 1.0, depth) * max(0.0, 1.0 - smoothstep(0.0, 0.4, dotup));\n    \n    return col;\n}\n\nvoid getRay(in vec2 uv, in vec4 m, inout vec3 ro, inout vec3 rd) {\n    ro = vec3(0, 1, -9.0);\n    rd = normalize(vec3(uv.xy, 1.0));\n    \n    #if WALK\n    vec3 walk = texelFetch(iChannel0, ivec2(0, 0), 0).xyz;\n    vec3 fly = texelFetch(iChannel0, ivec2(1, 0), 0).xyz;\n    \n    ro += walk;\n    ro.y += fly.y;\n    \n    rd.yz *= rot(m.y*TAU);\n    rd.xz *= rot(m.x*TAU);\n    #else\n    \n    if (m.z > 0.001) {\n        ro.yz *= rot(m.y*TAU);\n        ro.xz *= rot(m.x*TAU);\n        \n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n    } else {\n        ro.y += 1.;\n        float time = T*0.2;\n\n        ro.xz *= rot(time);\n        rd.xz *= rot(time);\n    }\n    #endif\n    \n    ro.y = max(1.0, ro.y);\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec4 m = iMouse;\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    m.xy = (m.xy-0.5*R.xy)/R.y;\n    \n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    getRay(uv, m, ro, rd);\n    Data data = NEW_DATA;\n    float depth = 1.0;\n    \n    #ifdef DEBUG_TEXTURE\n    Material ma = NEW_MATERIAL;\n    col += DEBUG_TEXTURE(fc.xy/R.xy, ro+rd, ma);\n    #else\n    col += render(data, ro, rd, depth);\n    \n    col += (col*col*luma(col));\n    \n\n    col = unreal(col);\n   // col = pow(col, vec3(1.0 / 2.2));\n    #endif\n    \n    O = vec4(clamp(col, 0.0, 1.0), depth);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}