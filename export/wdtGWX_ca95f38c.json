{"ver":"0.1","info":{"id":"wdtGWX","date":"1569425240","viewed":141,"name":"2D Cogs","username":"zodiax","description":"2D cogs animated","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["cogs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define iterX 10\n#define iterY 6\n\nmat2 rotate2d(float _angle){//https://thebookofshaders.com/08/\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat rectangle(vec2 uv, vec2 center, vec2 size){\nreturn step(abs(uv.x-center.x), size.x/2.)*step(abs(uv.y-center.y), size.y/2.);\n}\n\nfloat elipse(vec2 uv, vec2 center, vec2 size){\nreturn step(distance(uv/size,center), 0.2);\n}\n\nfloat cog(vec2 uv, float cogRadius, int cogSize, float rotSpeed, float scale,float dill)\n{\n    float cog;\n    uv /= scale;\n    uv *= rotate2d((dill+sin(iTime/4.)*4.)*rotSpeed); // rotation of the cog\n    for(int i = 0; i<cogSize; i++)//setting the ends of the cog - number and size\n    {\n       float toDeg = 3.14159/180.0;\n       cog += clamp(rectangle(uv*rotate2d((360.)/float(cogSize)*float(i+1)*toDeg),vec2(0.,0.2), vec2(.06, 0.055)),0.,1.);\n    };\n    cog += elipse(uv,vec2(0.),vec2(cogRadius*3.))-rectangle(uv,vec2(0.),vec2(cogRadius*0.35));\n    return cog;\n}\n\nfloat generateCogsX(vec2 uv, float iniDir, float tOffset)\n{\n    float cogSet;\n    float dir = iniDir;\n    float dill = 0.0+tOffset;\n    float cogOffset = 0.0825;\n\n    uv.x -= cogOffset*(float(iterX)-1.)/2.;\n    for(int i = 0; i<iterX; i++)//setting the ends of the cog - number and size\n    {\n       uv.x += cogOffset*min(float(i),1.); //offset the cog\n       dir *= -1.; //change the direction of rotation\n       dill += 180.*(-1.);// offset the roation to match the next cog\n       cogSet += cog(uv,0.3,10,dir,0.2,dill);\n    };\n\treturn cogSet;\n}\n\nfloat cogsXY(vec2 uv)\n{\n    float dir = -1.;\n    float cogs;\n    float cogOffset = 0.0825;\n    float tOffset = 0.;\n    uv.y -= cogOffset*(float(iterY)-1.)/2.;\n    for(int i = 0; i<iterY; i++)//setting the ends of the cog - number and size\n    {\n        tOffset += 180.;\n        dir *= -1.;\n        uv.y += cogOffset*min(float(i),1.); //offset the cog\n\t\tcogs += generateCogsX(uv, dir, tOffset);\n    };\n\treturn cogs;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-iResolution.xy/2.0)/iResolution.x;\n\n    vec3 col = vec3(0.2,0.4,0.0)*min(cogsXY(uv),1.0);\n    col += (1.-min(cogsXY(uv),1.0)) * vec3(1.,.8,.0);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}