{"ver":"0.1","info":{"id":"XsSBWc","date":"1527270422","viewed":191,"name":"Volume scatter","username":"asiJa","description":"atempto do do realistic volumetric scattering","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","volumetric","scattering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 lightDir = normalize( vec3( 1.0,0.5,0.0 ) );\n\nfloat Func( in vec3 p ){\n    \n    /*\n    vec3  cosp = cos(pos*vec3(4.0,6.0,3.0));\n\tvec3  sinp = sin(pos*vec3(4.0,6.0,3.0));\n    float   r2 = dot(pos,pos);\n    */\n    \n\t/*\n    float nxy = cosp.x-sinp.y;\n    float nyz = cosp.y+sinp.z;\n    float nzx = cosp.z+sinp.x;\n    return ( 1.0/((nxy*nxy+nyz*nyz)*16.0+1.0) - 1.0/((nyz*nyz+nzx*nzx)*16.0+1.0) )*clamp(1.0-r2*0.25, 0.0, 1.0 );\n\t*/\n    \n    /*\n    float n1 = (sinp.y - sinp.x)*(sinp.y - sinp.z);\n    return clamp(1.0-r2*0.25, 0.0, 1.0 )*(\n           1.0/((n1*n1 + sinp.x*sinp.x)*64.0+1.0)\n         - 1.0/((n1*n1 + sinp.z*sinp.z)*64.0+1.0)\n           );\n    */\n    \n    \n    //float fang = p.x*p.y*p.z;\n    //float fang = p.x*p.y;\n    float fang = p.x*p.x-p.y*p.y;\n    //float fang = 2.*p.z*p.z  - p.x*p.x - p.y*p.y;\n    //float fang = p.x*p.y + p.x*p.z + p.y*p.z;\n    \n    //float fang = (2.*p.x*p.x - p.y*p.y - p.z*p.z)*(2.*p.y*p.y - p.x*p.x - p.z*p.z);\n    //float fang = p.x*p.x + p.y*p.y;\n    //float fang = (2*p.x*p.y - p.x*p.z - p.y*p.z);\n    //float fang = (2*p.x*p.y - p.x*p.z - p.y*p.z);\n    \n    float r = length(p)*1.2;\n    //return pos.x*pos.y*pos.z *   /(r*r*r);\n    return  fang * 100.*exp(-5.0*r);\n        \n        \n        \n\t//return sinp.x*sinp.y*sinp.z*clamp(1.0-r2*0.25, 0.0,1.0);\n    //return clamp(1.0-r2*0.25, 0.0, 1.0 );\n}\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph ){\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0,-1.0);\n    float  sh =  sqrt( h );\n\treturn vec2( -b-sh, -b+sh);\n}\n\nvec2 rot(in vec2 v,in vec2 u){ return vec2(v.x*u.x-v.y*u.y,v.x*u.y+v.y*u.x); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2  p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n\tvec3 ro = vec3(0.0, 0.0, 4.0 );\n\tvec3 rd = normalize( vec3(p,-2.0) );\n    \n    vec2 camX = vec2( cos(iMouse.x*0.1), sin(iMouse.x*0.1) );\n    ro.xz = rot(ro.xz,camX);\n    rd.xz = rot(rd.xz,camX);\n    \n    vec4 sph = vec4( vec3(0.0,0.0,0.0), 2.0 );\n    \n    vec2 tt = sphIntersect( ro, rd, sph );\n    \n    //vec3 mclr = vec3( 0.2,0.5,0.5 );\n    \n    \n    vec4 clrsum = vec4(0.0);\n    float t = tt.x;\n    float it = 0.0;\n    if( tt.x>0.0 ){\n        for(int i=0; i<64; i++){\n            vec3 pos = ro + t*rd;\n        \tfloat f = Func( pos )*5.0;\n            //vec3 mclr = clamp( vec3( f*8.0,0.5,-f*8.0 ), 0.0,1.0 );\n            //float dens = abs(f)*5.0;\n            \n            vec3 mclr = (f>0.0)?vec3(0.0,0.5,1.0):vec3(1.0,0.5,0.0);\n            \n            float dens = f*f;\n           \n            // --- linar aditive walk\n            //clrsum += vec4( 1.0,1.0,1.0,1.0 ) * dens * (1.0/64.0); t += 0.05;\n            \n            /*\n\t\t\t// --- uniform walk occluding\n            float dt    = 0.05; \n            float da    = dens*dt*2.0;\n            float wa    = 1.0-clrsum.a; wa=clamp(wa,0.0,1.0); \n            clrsum += vec4( mclr,2.0 ) * da * wa;\n            t += dt;\n\t\t\t*/\n\t\t\t\n\t\t\t// --- nonuniform walk occluding\n            float dt    = 0.05/(dens*8.0 + 1.0 );\n            //float dt    = 0.05/(sqrt(dens)*4.0 + 1.0 ); \n            float da    = dens*dt*4.0;\n            float wa    = 1.0-clrsum.a; wa=clamp(wa,0.0,1.0); \n            clrsum += vec4( mclr,3.0 ) * da * wa;\n            t += dt;\n            \n            \n            it+= (1.0/64.0);\n            if( (t>tt.y) ) break;\n        }\n    }\n    \n    //clrsum.rgb*=clrsum.rgb; clrsum.rgb *=4.0;\n    \n    clrsum.rgb *=2.0;\n    //clrsum.rgb += (1.0-clrsum.a)*vec3(0.0,0.0,0.0); \n    clrsum.rgb += (1.0-clrsum.a)*vec3(1.0,1.0,1.0); \n    clrsum.a=1.0;\n    \n    //clrsum.g = (t-tt.x)*0.25;\n    //clrsum.rgb = vec3( (t-tt.x)*0.25 );\n    //clrsum.rgb = vec3( it*it*it );\n    \n    fragColor = clrsum;\n    \n}","name":"Image","description":"","type":"image"}]}