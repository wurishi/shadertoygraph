{"ver":"0.1","info":{"id":"ml2fzz","date":"1693753358","viewed":137,"name":"golden hall","username":"pb","description":"try full screen, use mouse to look around","likes":18,"published":1,"flags":32,"usePreview":0,"tags":["raymarch","glow","reflections","mandelbox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//philip,bertani@gmail.com\n//Buffer A is where it is at\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    //distance the ray travelled was saved in alpha channel\n    float maxDist = texture(iChannel0,uv).a;\n    \n    vec2 texel = 1./iResolution.xy;\n    vec4 total_color;\n    for (int i=0;i<5;i++){\n        float fi = float(i)-2.;\n        for (int j=0;j<5;j++){ \n            float fj = float(j)-2.;\n            vec4 color = texture(iChannel0, \n                uv + vec2( texel.x*fi,texel.y*fj )  );\n            total_color += color * gk1s[i*5 + j];\n        }\n    }\n    fragColor = total_color;\n    \n    //fwidth is really good at detecting sharp edges, so subtract them off\n    //since they are causing flickering, subtract off more as we get further\n    //away since the effect is worse with distance\n    \n    fragColor -= fwidth(fragColor) * exp(maxDist*maxDist/100.);\n \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float[] params = float[] ( \n0.,\n6.,\n-0.27,\n0.5,\n-0.5,\n-.9,\n-0.,\n.0,\n0.,\n0.,\n0.,\n0.,\n-.05,\n1.,\n0.,\n0.1,\n2.,\n0.,\n-1.,\n-0.,\n-2.,\n1.,\n0.,\n.5,\n.5,\n0.0,\n-4.,\n0.5,\n0.3,\n0.1,\n0.,\n0.2,\n0.\n);\n\n\n//gaussian_kernel_one_stdev\nfloat[] gk1s = float[] (\n        0.003765,0.015019,0.023792,0.015019,0.003765,\n        0.015019,0.059912,0.094907,0.059912,0.015019,\n        0.023792,0.094907,0.150342,0.094907,0.023792,\n        0.015019,0.059912,0.094907,0.059912,0.015019,\n        0.003765,0.015019,0.023792,0.015019,0.003765 );\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define extraReflection 1.  //set this to zero if your FPS is crashing - sorry\n\nfloat num_iter, objid, inf=1e6, too_small=1e-6, \n    distToFloor, glow=0., maxDist=30., mmaxDist=30., tileColor=0.;\nvec3 ifs_color, ro;\n\nfloat de(vec3 p) {\n    vec4 q = vec4(p, 3.);\n    float nn=2.;\n    q.xz = mod(q.xz + nn, 2.*nn) - nn;\n    vec2 qq = floor(q.xz);\n    q.xyz -= 1.;\n\n    float i=0.;\n    for(; i < params[1]; i++) {\n        q.xyz = abs(q.xyz + (1.+params[32])*1.0) - (1.+params[32])*1.0*(1.+q.xyz/50.*(1.+params[19]));\n        q /= clamp(dot(q.xyz, q.xyz), 0.4+params[2], 1.0+params[3]);\n        q *= (1.+params[4]);\n        //q += params[30]*q.y;\n    }\n    \n    \n    float d2 = length( max( abs(q.xyz) - vec3(1.2+params[5],1.2+params[6], 1.2+params[18]), 0.0) )/q.w;\n    float d1 = p.y + 1. + .005*length(qq);  //tiles \n   \n    objid = 0.0;\n    if ( d1 < d2 ) objid = 1.; \n    \n    tileColor = d2;\n    distToFloor = d1;\n    \n    return max( min(d1 , d2) , -(length(p-ro)-params[7]) );\n}\n\nfloat march(vec3 ro, vec3 rd, float mx) {\n    float t = 0.0;\n  \n    float eps = 1e-5, distfac=30.;\n    float hitThreshold = eps;\n    for(int i = 0; i < 200; i++) {\n        float d = de(ro + rd*t);\n        if (d < hitThreshold || t >= mx) break;\n        t += d;\n        hitThreshold = eps*(1.+t*t*distfac);\n        glow += .15*exp(-max(6.-d,0.)/10.);\n    }\n    return t;\n}\n\nvec3 phong(\n  in vec3 pt,\n  in vec3 prp,\n  in vec3 normal,\n  in vec3 light,\n  in vec3 color,\n  in float spec,\n  in vec3 ambLight)\n{\n   vec3  lightv= (light-pt);\n   float lightDist =  length(lightv);\n   float diffuse=dot(normal,lightv);\n   vec3  refl=-reflect(lightv,normal);\n   vec3  viewv=normalize(prp-pt);\n   float specular=pow(max(dot(refl,viewv),0.0),spec+params[20]);\n   \n   return  4.*exp(-lightDist*lightDist/10.)*( (max(diffuse,0.))*(color) + .2*specular*vec3(.9,.8,.6));  \n}\n\nvec3 normal(vec3 p, float dist) {\n    vec2 h = vec2(0.0001 + params[25] + dist/2000., 0.0);\n    vec3 n = vec3(\n        de(p + h.xyy) - de(p - h.xyy),\n        de(p + h.yxy) - de(p - h.yxy),\n        de(p + h.yyx) - de(p - h.yyx));\n    return normalize(n);\n}\n\n\nvec3 render(vec3 ro, vec3 rd) {\n\n \n    vec3 col = vec3(0.);\n    vec3 light_dir =  ro ; light_dir.z += mmaxDist - mod(iTime*8., mmaxDist*2.);\n    vec3 color     = vec3( params[27], params[28], params[29]);\n    float specular_power = 2.;\n    vec3 ambient_light = vec3(.1);\n    vec3 floor_color = vec3(0.3,0.2,.1);\n    float t = march(ro, rd, mmaxDist);\n    \n    glow *= exp(-t*t*1e-2);\n    maxDist = t;\n    \n    if(t < mmaxDist) {\n        vec3 pos = ro + rd*t;\n        vec3 nor = normal(pos, t);   \n        vec3 cf = phong( pos, ro, nor, light_dir, color, specular_power, ambient_light);       \n        col = cf;\n        \n        col += 1.4*objid*(floor_color + 15.*(tileColor*tileColor)*vec3(.5,.5,.2));\n        \n        if (params[21] > 0. ) {  //first reflection\n            vec3 pos2 = ro + rd*.999*t; \n            vec3 ref = reflect(rd, nor);\n            float tt =  march( pos2, ref, mmaxDist);\n            glow *= exp(-tt*tt*3e-2);\n            glow *= exp(-distToFloor/10.);\n\n            if ( tt < mmaxDist) {\n                vec3 ppos = pos2 + ref*tt;\n                vec3 nnor = normal(ppos, tt);\n                vec3 rref = reflect(ref, nnor);\n                \n                vec3 cf2 = phong( ppos, ro, nnor, light_dir, color, specular_power, ambient_light); \n                col += params[23] * cf2;                    \n                \n\n              if ( (params[21] + extraReflection) > 1.) {  //second reflection\n                vec3 pos3 = pos2  + ref*.999*tt;\n                float ttt = march( pos3, rref, mmaxDist);\n                glow *= exp(-ttt*ttt*1e-4);\n                \n                if (ttt < mmaxDist ) {\n                   vec3 pppos = pos3 + rref * ttt;\n                   vec3 nnnor = normal(pppos, ttt);\n \n                   vec3 cf3 = phong( pppos, ro, nnnor, light_dir, color, specular_power, ambient_light);\n                   col += params[24] * cf3;\n                   \n                }\n              }\n            }\n        }\n        \n        col = clamp(col, 1e-6,inf);\n        col *= col;\n    }\n    return col + 6e-6*pow(glow,5.)*vec3(.5,.3,.07) ;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p  = (2.*fragCoord.xy-iResolution.xy)/iResolution.y*1.5;\n    \n    ro = vec3(0.,1.,iTime/5.);\n    vec3 rd = normalize( vec3(p,2.) );\n    \n    //float s2 = 1./sqrt(2.);\n    //rd.xz *= mat2(s2,-s2,s2,s2);\n    \n    \n    if (iMouse.w != 0.) {\n        vec2 an = 5.*(iMouse.xy/iResolution.xy-.5);\n        vec2 cc=cos(an), ss=sin(an);\n        rd.xz *= mat2(cc.x,-ss.x,ss.x,cc.x);\n        rd.yz *= mat2(cc.y,-ss.y,ss.y,cc.y);\n    }\n    else {\n        float an = .7854 + iTime/10., cc=cos(an), ss=sin(an);\n        rd.xz *= mat2(cc,-ss,ss,cc);\n    }\n    \n    vec3 col = render(ro, rd);\n    col = 1. - exp(-.3 * (1.+params[16]) * col);\n    \n    fragColor = vec4( col, maxDist);\n    \n}\n","name":"Buffer A","description":"","type":"buffer"}]}