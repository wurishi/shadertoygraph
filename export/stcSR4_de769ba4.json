{"ver":"0.1","info":{"id":"stcSR4","date":"1638817369","viewed":220,"name":"Vorocrash (pt.2)","username":"kastorp","description":"part 2: more blocks with voronoi particle tracking \n\n","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["voronoi","polygon","clipping"],"hasliked":0,"parentid":"NttSR8","parentname":"Vorocrash (pt.1)"},"renderpass":[{"inputs":[{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":3,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Vorocrash (part 2) by Kastor\n//Based on Oneshade polygon clipping algorithm: https://www.shadertoy.com/view/sdXGz7 \n//------------------------------------------------------------------------------\n//   part 1: getting voronoi polygons (https://www.shadertoy.com/view/NttSR8)\n//   part 2: more blocks with voronoi particle tracking \n//   part 3: collision detection with polgon intersection (TODO)\n//------------------------------------------------------------------------------\nGETTERS\nvoid mainImage(out vec4 O, in vec2 fragCoord) {\n  \n    \n    vec2 uv =  fragCoord / iResolution.xy*size ;\n    float unit = .05;\n    O= vec4(.2,.2,.2,-1);\n     \n    //O=mix(O,vec4(.3,.3,.3,-1),smoothstep(unit,0.,min(fract(uv.x),fract(uv.y)))); \n    ivec4 nb = getCClosest( uv); \n    for(int i=0;i<4;i++){ \n        int x = nb[i];\n        vec3[MP] poly ;   //xy=coords, z=polygon id\n        vec4 pData= texelFetch(iChannel0,ivec2(x,0),0); // x=size, yz=center, w=rotation\n        for(int i=0;i<int(pData.x);i++) poly[i]=texelFetch(iChannel0,ivec2(x,i+1),0).xyz;\n    \n\n        // Draw poly \n        float d= sdPolygon(uv-pData.yz,poly,int(pData.x));\n        vec2 ruv= uv-pData.yz + getCenter(int(pData.w));\n        \n        if(pData.x>0. && float(x)>O.w ) O=mix(O,mix(vec4(.3,.4,.5,-1), vec4(texture(iChannel3,ruv*.02,0.).rgb,float(x)),smoothstep(unit, 0.0,d+.04)),smoothstep(unit, 0.0,d));\n        \n        \n        O=mix(O,vec4(.8,.6,.8,float(x)),smoothstep(unit,0.,-.05+length(uv-pData.yz)));             \n    }\n    \n   \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n//#define REDUCE 1e-8//remove redundant vertexes\n#define POLDIR 1 //1=counterclockwise, 0= clockwise\nfloat cross2d(vec3 a, vec3 b) {return cross(vec3(a.xy,0.),vec3(b.xy,0.)).z;  }\nfloat dot2d(vec2 a){return dot(a,a);}\nfloat dot2d(vec3 a){return dot(a.xy,a.xy);}\n\n\n//Oneshade polygon clipping algorithm https://www.shadertoy.com/view/sdXGz7\nint clipPoly(vec3 clipA , vec3 clipB,in vec3[MP] poly, int num, inout vec3[MP] clipped)\n{\n    vec2 clipTan = clipB.xy - clipA.xy;          // Clip tangent\n    vec2 clipPerp = vec2(-clipTan.y, clipTan.x); // Clip normal\n\n    int nClip = 0;                   // Number of vertices in the clipped polygon\n\n    for (int v=1; v < num + 1; v++) {\n        vec2 e1 = poly[v - 1].xy - clipA.xy, e2 = poly[v % num].xy - clipA.xy;\n        float dot1 = dot(e1, clipPerp), dot2 = dot(e2, clipPerp);\n        if (dot1 >= 0.0) {\n            clipped[nClip] =  poly[v - 1];\n            nClip++;\n        }\n\n        if ((dot1 >= 0.0) != (dot2 >= 0.0)) {\n            // Relative to clipping line\n            vec2 rel1 = vec2(dot(e1, clipTan), dot1);\n            vec2 rel2 = vec2(dot(e2, clipTan), dot2);\n\n            // Solve for zero and transform back to world space\n            float zero = rel1.x - rel1.y / (rel2.y - rel1.y) * (rel2.x - rel1.x);\n            float det = clipTan.x * clipPerp.y - clipTan.y * clipPerp.x;\n            vec2 clipPos = vec2(clipPerp.y, -clipPerp.x) * zero / det + clipA.xy;\n            \n            // Add to clipped vertices\n            clipped[nClip] = vec3(clipPos,\n                dot2d(clipPos-clipA.xy)<.0001?clipA.z:\n                dot2d(clipPos-clipB.xy)<.0001?clipB.z:0.\n                );\n            nClip++;\n        }\n    }\n    return nClip;\n\n}\n\nint intersectPoly(in vec3[MP] poly, int nPoly,in vec3[MP] clipping, int nClipping,  inout vec3[MP] clipped)\n{\n    int nClip = nPoly;   \n    for(int i=0;i< nClipping;i++)\n    nClip =clipPoly(  clipping[(i+1-POLDIR)%nClipping],  clipping[(i+POLDIR)%nClipping],  clipped,  nClip ,  clipped);    \n    return nClip;\n}\n\n\nvoid mainImage(out vec4 O, in vec2 U) {\n\n ivec2 ui=ivec2(U);\n if(ui.x>=NP || ui.y>MP) discard;\n \n\n    vec3[MP] poly ;   //original polygon\n    int sPoly=4; \n    poly[0]=vec3(9,-5,2);\n    poly[1]=vec3(-9,-5,2);\n    poly[2]=vec3(-9,5,2);\n    poly[3]=vec3(9,5,2);\n\n\n    vec2 c= getCenter(ui.x);\n    \n    for(int x =-1;x<2;x++)for(int y =-1;y<2;y++){\n        vec2 c2= getCenter(ui.x +x+y*17);\n        vec2 a = (c+c2)*.5 - (c2-c).yx*vec2(-.1,.1);\n        vec2 b = (c+c2)*.5 + (c2-c).yx*vec2(-.1,.1);\n        if((x!=0 || y!=0 )&& abs(c2.x)<8.5 && abs(c2.y)<4.5) sPoly=clipPoly(  vec3(a,0),  vec3(b,0),  poly,  sPoly ,  poly);\n    }\n    if(sPoly>0){\n        vec2 b=c;\n        \n        //crack:\n        float r= 0.,d=1.; // no rotation or scaling\n        vec2 ct= b+size*.5;\n        ct.y+=sign(b.y)*(1.-cos(iTime))*.3 *(1.-exp(-abs(b.y))); //horizontal crack\n        ct.x+=sign(b.x)*(1.-cos(iTime))*.3 *(1.-exp(-abs(b.x))) ; //vertical crack\n\n\n        if(ui.y==0)  O=vec4(sPoly,ct,ui.x);\n        else {\n           vec2 v = poly[ui.y-1].xy;      \n           v= (v-b)*d *mat2(cos(r),sin(r),-sin(r),cos(r));\n           O=vec4(v,poly[ui.y-1].z,0);\n        }\n    }else O=vec4(0);\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define MP 12 //maximum polygon size (adjust as needed)\n#define NP 153\n#define LOD 8\n#define R iResolution\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ZERO  min(iFrame,0)\n#define size vec2(18.,18.*R.y/R.x)\n#define NGH NP\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n// Drawing utilities\nvoid drawPoint(inout vec3 pixel, in float unit, in vec2 p, in vec2 pos, in float sz, in vec3 color) {\n    pixel = mix(pixel, color, smoothstep(unit, 0.0, length(p - pos) - sz));\n}\n\nvoid drawLine(inout vec3 pixel, in float unit, in vec2 p, in vec2 a, in vec2 b, in float thickness, in bool inf, in vec3 color) {\n    vec2 pa = p - a, ba = b - a;\n    float proj = dot(pa, ba) / dot(ba, ba);\n    if (!inf) proj = clamp(proj, 0.0, 1.0);\n    float d = length(pa - ba * proj) - thickness;\n    pixel = mix(pixel, color, smoothstep(unit, 0.0, d));\n}\n\n// Modified version of font loader from https://www.shadertoy.com/view/ltcXzs\nvoid drawChar(sampler2D  ch, inout vec3 color, in vec3 charColor, in vec2 p, in vec2 pos, in vec2 sz, in int char) {\n    p = (p - pos) / sz + 0.5;\n    if (all(lessThan(abs(p - 0.5), vec2(0.5)))) {\n        float val = textureGrad(ch, p / 16.0 + fract(vec2(char, 15 - char / 16) / 16.0), dFdx(p / 16.0), dFdy(p / 16.0)).r;\n        color = mix(color, charColor, val);\n    }\n}\nvoid drawChars(sampler2D  ch, inout vec3 color, in vec3 charColor, in vec2 p, in vec2 pos, in vec2 sz, int nChars, int[8] chars) {   \n    for(int i=0;i<nChars;i++) drawChar( ch,color,charColor,  p, pos+vec2(i,0)*sz*.5, sz, chars[i]);\n}\n\n\n//Iq SDF\nfloat sdPolygon( in vec2 p, in vec3[MP] v ,int num)\n{\n    \n    float d = dot(p-v[0].xy,p-v[0].xy);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        vec2 e = v[j].xy - v[i].xy;\n        vec2 w =    p - v[i].xy;\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        bvec3 cond = bvec3( p.y>=v[i].y,  p.y <v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }  \n    return s*sqrt(d);\n}\n\n//-------------------------\n\n\n\nivec2 i2xy(int id) {return ivec2(id, 0);}\nint xy2i(ivec2 p){ return p.x ;}\n\n#define GETTERS \\\nivec4 getBNeighbor(int id){ return floatBitsToInt(texel(iChannel1, i2xy(id)));} \\\nvec4 getAParticle(int id){ vec4 p= texel(iChannel0, i2xy(id)); return vec4(p.yz,p.xw); } \\\nivec4 getCClosest(vec2 p){ return floatBitsToInt(texel(iChannel2, p *vec2(LOD)));} \n//ivec2 p2c(vec2 p){ return ivec2(p);} \\\n//vec2 c2p(ivec2 c){ return vec2(c);} \\\n\nvec2 getCenter(int x){\n    float hd=.7;\n    vec2 c0= vec2(-8+(x%17),-4 + (x/17));\n    vec2 c= c0+ (hash22(c0)-.5)*hd;\n    return c;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//particle neighbors \n\nGETTERS\n\n//sorting closest 4 particles\nivec4 u; //ids\nvec4 d; //distances\nvec2 pos; //this particle position\nint tid;\n\n//insertion sort\nvoid sort(int utemp)\n{\n    if(utemp == tid || utemp < 0) return;\n       \n   \tvec4 part = getAParticle(utemp);\n    vec2 dx = part.xy - pos;\n    float dtemp = length(dx);\n    //sorting\n    if(dx.x > abs(dx.y)){ if(d.x > dtemp) {d.x = dtemp;u.x = utemp; }}\n    else if(dx.x < -abs(dx.y)) { if(d.y > dtemp) {d.y = dtemp;u.y = utemp;}}\n    else if(dx.y > abs(dx.x)){ if(d.z > dtemp) {d.z = dtemp;u.z = utemp;} }\n    else if(d.w > dtemp) {d.w = dtemp;u.w = utemp;}\n}\n\nvoid sortneighbor(int id)\n{\n    ivec4 nb = getBNeighbor(id);\n    for(int j = 0; j < 4; j++) sort(nb[j]);\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{  \n    \n    ivec2 p = ivec2(fragCoord);\n    if(p.x > NP || p.y>1) discard;\n    \n    int id = xy2i(p);     \n    u = ivec4(-1); d = vec4(1e10);    \n    tid = id;\n    pos = getAParticle(id).xy;\n    \n    //sortneighbor(id); \n     \n    for(int i = 0; i < NGH; i++)\n    {\n        int id=(iFrame*NGH+i) % NP;\n        vec4 pp= getAParticle(id);\n        sort(id); \n    }\n    /*\n    ivec4 nc = getCClosest(ivec2(pos)); for(int i = ZERO; i < 4; i++)sort(nc[i]); \n    \n    ivec4 nb = getBNeighbor(id);\n    for(int i = 0; i < 4; i++)\n    {\n        //sort 4x4  particles \n        sortneighbor(nb[i]); \n        ivec4 nbb = getBNeighbor(nb[i]);\n        for(int j = 0; j < 4; j++) sortneighbor(nbb[j]); \n    }\n    */\n    if( any(lessThan(u, ivec4(-1))) || any(greaterThan(u, ivec4(NP))))u = ivec4(0);\n    \n    U = intBitsToFloat(u);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//4th order voronoi particle tracking for each screen position (from Michael0884)\n\nGETTERS\n\nvec2 cross_distribution(int i) { return vec2((1<<(i/4)) * ivec2( ((i&2)/2)^1, (i&2)/2 ) * ( 2*(i%2) - 1 ));}\n\nivec4 u; //ids\nvec4 d; //distances\nvec2 pos; //pixel position\n\nfloat particleDistance(int id, vec2 p){ return distance(getAParticle(id).xy, p);}\n\n//insertion sort\nvoid sort(int utemp)\n{\n    if(utemp <0) return; \n   \tfloat dtemp = particleDistance(utemp, pos);\n    //sorting\n    if(d.x > dtemp) { d = vec4(dtemp, d.xyz);u = ivec4(utemp, u.xyz); }\n    else if(d.y > dtemp && dtemp > d.x) { d.yzw = vec3(dtemp, d.yz); u.yzw = ivec3(utemp, u.yz);}\n    else if(d.z > dtemp && dtemp > d.y){d.zw = vec2(dtemp, d.z); u.zw = ivec2(utemp, u.z);}\n    else if(d.w > dtemp && dtemp > d.z){d.w = dtemp;u.w = utemp;}\n}\n\nvoid sortpos(vec2 p)\n{\n    ivec4 nb = getCClosest(p);\n    for(int j = ZERO; j < 4; j++) sort(nb[j]);\n}\n\nvoid sortPart(int id)\n{\n    ivec4 nb = getBNeighbor(id);\n    for(int j = ZERO; j < 4; j++)sort(nb[j]);\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{\n    pos = fragCoord /vec2(LOD);   \n    if (any(greaterThan(pos,ceil(size) ))) { discard;} //skip pixels out of screen   \n    vec2 p = vec2(pos);     \n    u = ivec4(-1); d = vec4(1e10); \n    \n    sortpos(p); \n    \n    for(int i = ZERO; i < 20; i++)\n    {\n        vec2 p2 =p+cross_distribution(i);        \n        sortpos(p2); \n    }\n    \n    for(int i = ZERO; i<4; i++)\n    {\n        if(u[i]<0) continue;\n        sortPart(u[i]);       \n    }\n    \n    U = intBitsToFloat(u);\n}\n","name":"Buffer C","description":"","type":"buffer"}]}