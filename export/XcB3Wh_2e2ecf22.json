{"ver":"0.1","info":{"id":"XcB3Wh","date":"1704128301","viewed":68,"name":"Intro to Raymarching blubbers122","username":"blubbers122","description":"adapted from vid: \nraymarching from kishimisu tutorial https://www.youtube.com/watch?v=khblXafu7iA&list=WL&index=2","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y,q.z)),0.0);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a-b), 0.0)/k;\n    return min(a,b) - h*h*h*k*(1.0/6.0);\n}\n\nvec3 rot3D(vec3 p, vec3 axis, float angle) {\n    return mix(dot(axis, p) * axis, p, cos(angle)) + cross(axis, p) * sin(angle);\n}\n\nmat2 rot2D(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nvec3 palette( float t ) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263,0.416,0.557);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n// distance to the scene\nfloat map(vec3 p) {\n   \n    \n    \n    vec3 q = p;\n    \n    q.y -= iTime * .1;\n    q = fract(p) - .5;\n    \n    float a = 0.;\n    \n    \n    vec3 sphereOrbit = vec3(.2, 0., 0.);\n    sphereOrbit.xy *= rot2D(iTime * 10.);\n\n    vec3 spherePos = vec3(sin(iTime) *.2,0,0);\n    float sphere = sdSphere(q - sphereOrbit, .05 + cos(iTime * 8.) * .05);\n    \n    q.xy *= rot2D(iTime);\n    \n    \n    \n    // scaled box\n    float middleSphere = sdSphere(q, .05 + sin(iTime * 3.) * .05); \n    \n    float ground = p.y + .75;\n    \n    return smin(ground, smin(sphere, middleSphere, .1), .1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 m = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y * 4.;\n    \n    // ray origin\n    vec3 ro = vec3(0,0,-3);\n    // ray direction\n    vec3 rd = normalize(vec3(uv.x, -1,uv.y));\n    vec3 col = vec3(0);\n    \n    // total distance travelled\n    float t = 0.0;\n   \n    //Vertical camera rotation\n    ro.yz *= rot2D(-m.y);\n    rd.yz *= rot2D(-m.y);\n    // don't let camera go under floor\n    //ro.y = max(ro.y, -0.5);\n    //rd.y = max(rd.y, -0.5);\n   \n    //Horizontal camera rotation\n    ro.xz *= rot2D(-m.x);\n    rd.xz *= rot2D(-m.x);\n    \n    ro.x += iTime;\n    ro.y += iTime + abs(tan(iTime/4.)) * 2.;\n  \n    float lastD;\n    float iterationPercent = 0.;\n    //Start Raymarching\n    for (int i = 0; i < 80; i++){\n        // position along the ray\n        vec3 p = ro + rd * t;\n\n        float d = map(p);\n\n        t += d;\n        iterationPercent = float(i) / 80.;\n        \n        // stop early if close enough\n        // stop early if too far\n        if (d < .001 || t > 40.) {\n            lastD = d;\n            break;\n        }\n    }\n    \n    // Coloring\n    col = palette(.1 + sin(iTime) * (t * .08) + sin(iTime) * iterationPercent * .1);\n    \n    // Output to screen\n    fragColor = vec4(col,1);\n}","name":"Image","description":"","type":"image"}]}