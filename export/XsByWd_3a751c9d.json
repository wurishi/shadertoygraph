{"ver":"0.1","info":{"id":"XsByWd","date":"1494281575","viewed":581,"name":"Bubble Ring","username":"leon","description":"Learning about modeling shapes","likes":39,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// training for modeling shapes\n// using koltes code as base https://www.shadertoy.com/view/XdByD3\n// using iq articles\n// using mercury library\n\n#define PI 3.14159\n#define TAU PI*2.\n#define t iTime\n\nmat2 rz2 (float a) { float c=cos(a), s=sin(a); return mat2(c,s,-s,c); }\nfloat sphere (vec3 p, float r) { return length(p)-r; }\nfloat iso (vec3 p, float r) { return dot(p, normalize(sign(p)))-r; }\nfloat cyl (vec2 p, float r) { return length(p)-r; }\nfloat cube (vec3 p, vec3 r) { return length(max(abs(p)-r,0.)); }\nvec2 modA (vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an*.5;\n    a = mod(a, an)-an*.5;\n    return vec2(cos(a),sin(a))*length(p);\n}\nfloat smin (float a, float b, float r)\n{\n    float h = clamp(.5+.5*(b-a)/r,0.,1.);\n    return mix(b, a, h) - r*h*(1.-h);\n}\n\nfloat map (vec3 p)\n{\n    \n    p.xz *= rz2(.5);\n    p.xy *= rz2(t*.5);\n    p.yz *= rz2(t*.3);\n    \n    float cyl2wave = .1+.7*(sin(p.z+t*2.)*.5+.5);\n    float cylfade = 1.-smoothstep(.0,6.,abs(p.z));\n    float cyl2r = 0.02*cyl2wave*cylfade;\n    float cylT = 2.;\n    float cylC = 8.;\n    vec2 cyl2p = modA(p.xy*rz2(p.z*cylT), cylC)-vec2(cyl2wave, 0)*cylfade;\n    float cyl2 = cyl(cyl2p, cyl2r);\n    cyl2p = modA(p.xy*rz2(-p.z*cylT), cylC)-vec2(cyl2wave, 0)*cylfade;\n    cyl2 = smin(cyl2, cyl(cyl2p, cyl2r),.1);\n    cyl2p = modA(p.xy*rz2(-p.z*cylT), cylC*.5)-vec2(cyl2wave, 0)*cylfade;\n    cyl2 = smin(cyl2, iso(vec3(cyl2p,mod(p.z*2.,1.)-.5), .2*cyl2wave),.1);\n    \n    vec3 cubP = p;\n    float cubC = 0.5;\n    cubP.z -= t*2.;\n    float cubI = floor(cubP.z / cubC);\n    cubP.z = mod(cubP.z, cubC)-cubC*.5;\n    cubP.xy *= rz2(t*2.+cubI*4.);\n    cubP.yz *= rz2(t*3.+cubI*8.);\n    cyl2 = min(cyl2, cube(cubP,vec3(.35*cyl2wave*cylfade)));\n    \n    float a = atan(p.y,p.x);\n    float l = length(p.xy)-2.;\n    p.xy = vec2(l,a);\n    \n    //p.z += a;\n    \n    float wave = (sin(p.y+t)*.5+.5);\n    \n    float sphR = wave*0.5;\n    float sphC = 1.;\n    float sph1 = sphere(vec3(p.x,mod(3.*(p.y/TAU+t),sphC)-sphC*.5,p.z), sphR);\n    \n    float iso1 = iso(p, 0.2);\n    \n    p.xz *= rz2(p.y*3.*wave);\n    p.xz = modA(p.xz, 3.);\n    p.x -= wave*(.85-.5*(.5+.5*sin(6.*(p.y+t))));\n    float cyl1 = cyl(p.xz, 0.02);\n    float sph2 = sphere(vec3(p.x,mod(p.y*2.,1.)-.5,p.z), .2*wave);\n    \n\treturn min(cyl2, smin(sph1, smin(cyl1,sph2,.1), .1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(uv,-4), rp = vec3(uv,1), mp = ro;\n    int i = 0;\n    const int count = 50;\n    for(;i<count;++i) {\n\t\tfloat md = map(mp);\n        if (md < 0.001) {\n            break;\n        }\n        mp += rp*md*.5;\n    }\n    float r = float(i)/float(count);\n    fragColor = vec4(1);\n    fragColor *= 1.-smoothstep(.0,5.,length(mp));\n    fragColor *= 1.-smoothstep(5.,10.,length(mp-ro));\n    fragColor *= 1.-r;\n}","name":"Image","description":"","type":"image"}]}