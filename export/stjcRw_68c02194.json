{"ver":"0.1","info":{"id":"stjcRw","date":"1649397548","viewed":71,"name":"Ray Marching V2 - JLE","username":"jleeelle","description":"Many spheres, many colors. That's a nice upgrade.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n\n#define NUM_SPHERES 3\n\n// 04/08/2022, Joshua Elledge\n\n// This shader inplements the Ray Marching (Sphere Tracing) algorithm to render\n// several objects in real time, and implements a very basic material system to\n// allow for multiple different colors of objects.\n\n// At a later date I intend to implement more 3D primitives such as cubes,\n// capsules, touses (tori?), etc. as well as a more robust material system\n// to allow for reflections and more.\n\nstruct Sphere {\n  vec3 pos;\n  float r;\n  vec3 col;\n};\nstruct Distolor {\n    float dist;\n    vec3 col;\n};\nstruct Camera {\n    vec3 pos;\n    vec3 dir;\n};\nstruct Light {\n    vec3 pos;\n    vec3 col;\n};\nstruct Scene {\n    Camera cam;\n    Light light;\n    Sphere[NUM_SPHERES] spheres;\n};\n\n// Estimates the distance from some point p to the surface\n// of some sphere sph\nfloat sphereDistance(Sphere sph, vec3 p) {\n    return length(p - sph.pos) - sph.r;\n}\n\n// Returns the distance to and material of the closest\n// object to point p\nDistolor GetDist(Scene scene, vec3 p) {\n\n    Distolor d;\n    \n    d.dist = p.y;\n    d.col = vec3(1);\n    \n    for(int i = 0; i < NUM_SPHERES; i++) {\n        float sDist = sphereDistance(scene.spheres[i], p);\n        if(sDist < d.dist) {\n            d.dist = sDist;\n            d.col = scene.spheres[i].col;\n        }\n    }\n    return d;\n}\n\n// For several points p along a ray cast from the camera,\n// estimate the smallest distance to any object. When that distance\n// is less than some threshhold SURF_DIST, return the distance and material\n// of the \"hit\" object.\nDistolor RayMarch(Scene scene) {\n    Distolor d;\n    d.dist = 0.0;\n    d.col = vec3(1);\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = scene.cam.pos + scene.cam.dir * d.dist;\n        Distolor closest = GetDist(scene, p);\n        d.dist += closest.dist;\n        if(d.dist > MAX_DIST) break;\n        if(closest.dist < SURF_DIST) {\n            d.col = closest.col;\n            break;\n        }\n    }\n    return d;\n}\n\nvec3 GetNormal (Scene scene, vec3 p) {\n    float d = GetDist(scene, p).dist;\n    vec2 e = vec2(.01, 0);\n    vec3 n = d - vec3(\n        GetDist(scene, p - e.xyy).dist,\n        GetDist(scene, p - e.yxy).dist,\n        GetDist(scene, p - e.yyx).dist\n    );\n    return normalize(n);\n}\n\n// Shade the objects by casting a ray back toward the light source.\n// If an object is hit instead, the object is in shadow.\nvec3 GetLight(Scene scene, Distolor d) {\n\n    vec3 p = scene.cam.pos + scene.cam.dir * d.dist;\n\n    vec3 light_v = normalize(scene.light.pos - p);\n    vec3 normal = GetNormal(scene, p);\n    \n    // Darken the color based on the angle between the\n    // light vector and the surface normal\n    float diffuse = clamp(dot(normal, light_v), 0.0, 1.0);\n    \n    scene.cam.pos = p + normal * SURF_DIST * 2.0;\n    scene.cam.dir = light_v;\n    \n    Distolor d2 = RayMarch(scene);\n    \n    if (d2.dist < length(scene.light.pos - p)) {\n        diffuse *= .3;\n    }\n    \n    return d.col * diffuse;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Center (from -.5 to .5)\n    uv -= .5;\n    // Adjust for aspect ratio\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n    // Initialize scene -------------------------------------------------------\n    Camera cam;\n    cam.pos = vec3(0, 1, 0);\n    cam.dir = normalize(vec3(uv.x, uv.y, 1));\n    \n    // Camera motion\n    //cam.pos.x += sin(iTime) * 3.0;\n    //cam.dir.x -= sin(iTime) * .3;\n    \n    Light light;\n    light.pos = vec3(0, 4, 6);\n    light.col = vec3(1);\n    \n    // Light motion\n    light.pos.xz += vec2(sin(iTime), cos(iTime)) * 3.0;\n    \n    Sphere s1;\n    s1.pos = vec3(2, .5, 6);\n    s1.r = .5;\n    s1.col = vec3(1, 0, 0);\n    \n    Sphere s2;\n    s2.pos = vec3(-2, .75, 6);\n    s2.r = .75;\n    s2.col = vec3(0, 0, 1);\n    \n    Sphere s3; \n    s3.pos = vec3(0, 1, 8);\n    s3.r = 1.0;\n    s3.col = vec3(0, 1, 0);\n    \n    Sphere spheres[NUM_SPHERES];\n    spheres[0] = s1;\n    spheres[1] = s2;\n    spheres[2] = s3;\n    \n    Scene mainScene;\n    mainScene.cam = cam;\n    mainScene.light = light;\n    mainScene.spheres = spheres;\n    // ------------------------------------------------------------------------\n\n    Distolor d = RayMarch(mainScene);\n\n    vec3 col = GetLight(mainScene, d);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}