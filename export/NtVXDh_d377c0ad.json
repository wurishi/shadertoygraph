{"ver":"0.1","info":{"id":"NtVXDh","date":"1640611042","viewed":755,"name":"Lonely sphere","username":"bitless","description":"A lonely sphere running over a field of voxels","likes":50,"published":1,"flags":0,"usePreview":0,"tags":["2d","distortion","sphere","voxel","isometric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: bitless\n// Title: A lonely sphere running over a field of voxels\n\n// Thanks to Patricio Gonzalez Vivo & Jen Lowe for \"The Book of Shaders\"\n// and Fabrice Neyret (FabriceNeyret2) for https://shadertoyunofficial.wordpress.com/\n// and Inigo Quilez (iq) for  https://iquilezles.org/www/index.htm\n// and whole Shadertoy community for inspiration.\n\n// Special thanks to Shane for the \"Isometric Height Map\"\n// https://www.shadertoy.com/view/flcSzX. \n// I got some ideas there to improve my code.\n\n#define h21(p) ( fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453) ) //hash21\n#define rot(a)   mat2(cos(a + vec4(0,11,33,0)))                             //rotate 2d\n#define p(t, a, b, c, d) ( a + b*cos( 6.28318*(c*t+d) ) )                   //iq's palette\n\n\nfloat noise( in vec2 f ) //gradient noise\n{\n    vec2 i = floor( f );\n    f -= i;\n    \n    vec2 u = f*f*(3.-2.*f);\n\n    return mix( mix( h21( i + vec2(0,0) ), \n                     h21( i + vec2(1,0) ), u.x),\n                mix( h21( i + vec2(0,1) ), \n                     h21( i + vec2(1,1) ), u.x), u.y);\n}\n\nvec3 hexToSqr (vec2 st) //hexagonal cell coords to square face coords \n{ \n    vec3 r;\n    if (st.y > 0.-abs(st.x)*.57777)\n        if (st.x > 0.) \n            r = vec3((vec2(st.x,(st.y+st.x/1.73)*.86)*2.),3); //right face\n        else\n            r = vec3(-(vec2(st.x,-(st.y-st.x/1.73)*.86)*2.),2); //left face\n    else \n        r = vec3 (-(vec2(st.x+st.y*1.73,-st.x+st.y*1.73)),1); //top face\n    return r;\n}\n\nvec2 toSqr  (vec2 lc)\n {\n    return vec2((lc.x+lc.y)*.5,(lc.x-lc.y)*0.28902);\n }\n \nfloat T; //global timer\nfloat sm; //smoothness factor\nvec2 sp; //sphere position on isometric plane\n \nvoid voxel (vec2 uv, vec2 id, vec2 lc, vec2 sh, inout vec4 C)\n{\n\n    vec2 ic = vec2((uv.x+uv.y*1.73),(uv.x-uv.y*1.73)); //isometic coordinates\n\n    uv += sh*vec2(-1,.28902) ;\n    vec2 ii = floor(vec2((uv.x+uv.y*1.73),(uv.x-uv.y*1.73))); //isometric grid cell's id\n    float th = mix (                                                                                     //sphere track depth\n                        mix(1.,noise (ii*.5)*.3,smoothstep (4.,1.,abs(ii.x+15.-noise(vec2(ii.y*.1,0.))*15.))) //sphere track\n                        ,smoothstep(2.,4.,length(ii+sp-vec2(-.5,T+.5)))                                     //spot under sphere\n                        ,smoothstep (2., -1., ii.y-T)) \n    \n         , s =  pow(noise(vec2(h21(ii)*ii+iTime*.5)),8.)*.75 //small picks of altitude \n         , hg = (pow(noise(ii*.2*rot(1.) - iTime*.02),4.)-.5)*2.     //large noise\n                 + s;\n\n    hg = (hg+1.)*th - 1.;   //voxel altitude\n    float sz = 1.1 + s*1.5*th; //voxel size variation\n    \n    vec3 vx = hexToSqr(lc-vec2(sh.x,(sh.y-(hg*2.-1.)/sz)*0.28902));  //voxel sides coords and side id\n    \n    vx.xy *= sz;\n    \n    vec4 V = vec4(p(ii.y*.05+hg*.3*th,vec3(.9),vec3(.7),vec3(.26),vec3(.0,.1,.2)),1.); //voxel color\n    \n    float f = mix(.3, (.9 - vx.z*.15),smoothstep (.45+sm,.45-sm, max(abs(vx.x-.5),abs(vx.y-.5)))); //sides of voxel \n    f = mix (f, 1.-length(vx.xy-vec2(.6)*1.2), smoothstep (.4+sm,.4-sm,length(vx.xy-.5))); //circles on sides\n    f = mix (f, .4, smoothstep (.04+sm,-sm,abs(length(vx.xy-.5)-.4))); //circles edge\n    f -= f*smoothstep(5.,3.,length(ic+sp-vec2(-.5,T+.5)))*.5; //shadow under sphere\n    f += (hg+1.)*.07; //highlighting high-altitude voxels    \n//    f = smoothstep (-0.5,1.6,f); //gamma correcton\n    C = mix (C, V*f , smoothstep(1.+sm,1.-sm,max(vx.x,vx.y))); //mix colors with voxel mask \n}\n \nvoid Draw (vec2 uv, inout vec4 C)\n{\n    sp = vec2((1.-noise(vec2(T*.1,0.)))*15.,0.); //sphere position on isometric plane\n    vec2    st = vec2((uv.x+uv.y*1.73),(uv.x-uv.y*1.73)) //isometic coordinates\n         ,  sc = toSqr(st+sp)-uv+vec2(.0,2.+noise(vec2(iTime*5.,0.))*.2) //sphere center\n         ,  vc = uv; //coordinates for voxels \n\n    if (length(vc+sc) < 3.) //change coords for distortion effect on sphere\n    {\n        vc += sc;\n        vc += vc*(pow(length(vc*.35),4.)) - sc; \n        sm = sm + .07;  //add small blur \n    }\n    vc += toSqr(vec2(0.,T));\n\n    vec2 id = floor(vec2((vc.x+vc.y*1.73),(vc.x-vc.y*1.73))); //cell id\n    float n = mod(id.x+id.y+1.,2.);  //even and odd cells\n\n    st = vec2((1.-n)*.5-vc.x,vc.y*1.73-n*.5); \n    id = floor(st)*vec2(1.,2.) + vec2(n*.5,n); //corrected cell id\n    vec2 lc = fract(st) - vec2(.5);  //local cell corrdinates\n    lc.y *= .57804;\n\n    vec2[7] sh = vec2[7] (vec2(0,-2),vec2(.5,-1),vec2(-.5,-1),vec2(0,0),vec2(.5,1),vec2(-.5,1),vec2(0,2)); //coordinate offsets for voxel neighbors \n    \n    for (int i = 0 ; i<7 ; i++) voxel (vc, id, lc, sh[i], C); //draw voxel and his neighbors\n    \n    uv+= sc;\n\n    if (length(uv) < 3.) //add some colors for sphere\n    {\n        C = mix (C, \n            vec4(0,.05,.15,1),  \n            noise(vec2(-uv.x,(uv.y+uv.x/1.73)*.86)*1.5*rot(-T*.15))*.4); //color spots on sphere);\n        C += smoothstep(3.,-10., uv.y)*length(uv)*.1; //small light gradient on top of sphere \n    }\n    \n    C = mix (C, vec4(0),smoothstep (.02+sm,.02-sm,abs(length(uv)-3.))*.25); //small outline of sphere\n}\n\nvoid mainImage( out vec4 C, in vec2 g)\n{\n    vec2 rz = iResolution.xy\n        ,uv = (g+g-rz)/-rz.y;\n    uv += -.5;\n    uv *= 1.+sin(iTime*.3)*.25; //camera scale\n    sm = 3./iResolution.y;\n    \n    T = -iTime*4.-((sin(iTime*.5)+1.)*5.); //local timer with speed variation\n\n    C = vec4(0);\n\n    Draw (uv*5., C);\n\n    uv*=5.;\n    C=pow(C,vec4(1./1.4));\n}","name":"Image","description":"","type":"image"}]}