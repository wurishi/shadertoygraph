{"ver":"0.1","info":{"id":"stGBDG","date":"1665145506","viewed":124,"name":"Credit card","username":"ilyabelow","description":"Sber credit card with PBR","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf","pbr","creditcard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n\n\nTHIS USES CUSTOM TEXTURES!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n\n\nHow to load custom textures:\n\nOpen the javascript console of your browser:\n               Mac           Not Mac\nChrome:  cmd + opt + J    ctrl + shift J\nFirefox: cmd + opt + K    ctrl + shift K\n\n\nCopy and paste (Firefox will ask for comformation):\n\ngShaderToy.SetTexture(0, {mSrc:'https://i.ibb.co/q0JKytW/albedo.png', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\ngShaderToy.SetTexture(1, {mSrc:'https://i.ibb.co/NY1JZjV/rough.png', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\ngShaderToy.SetTexture(2, {mSrc:'https://i.ibb.co/5rKHWVj/normal.png', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\ngShaderToy.SetTexture(3, {mSrc:'https://i.ibb.co/RD0Gkfn/metal.png', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n\n\n\n\nWithout textures the shader has no point\n\nUse mouse to turn the card around\n\n\n\n\n\n*/\n\n\n#define PI 3.141592\n#define MAX_STEPS 200\n#define MAX_DIST 500.\n#define EPS 0.02\n#define PI 3.141592\n\n// === ROTATION\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\n// === SDF COMPOSITION\n\nfloat hard_intersect(float a, float b) {\n    return max(a, b);\n}\n\nfloat hard_union(float a, float b) {\n    return min(a, b);\n}\n\nfloat hard_subtract(float a, float b) {\n    return max(a, -b);\n}\n\nfloat smooth_union(float k, float d1, float d2) {\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n\n    return mix(d2, d1, h) - k*h*(1.0-h); \n}\n\nfloat smooth_subtract(float k, float d1, float d2) {\n    float h = clamp(0.5 - 0.5*(d2+d1)/k, 0.0, 1.0);\n\n    return mix(d2, -d1, h) + k*h*(1.0-h); \n}\n\nfloat smooth_intersect(float k, float d1, float d2) {\n    float h = clamp(0.5 - 0.5*(d2-d1)/k, 0.0, 1.0);\n\n    return mix(d2, d1, h) + k*h*(1.0-h); \n}\n\n// == SDFs\n\nfloat sphere_sdf(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\n\nfloat plane_sdf(vec3 p, vec3 n, float d) {\n    return dot(p, n)-d;\n}\n\n\n// SDF ITSELF\n\nfloat sdf(vec3 p, mat3 m) {\n    return hard_union(plane_sdf(p, vec3(0,1,0), -6.),\n    smooth_intersect(.1,plane_sdf(p*m, vec3(0,-1,0), 2.),\n    smooth_intersect(.1,plane_sdf(p*m, vec3(0,1,0), 2.),\n    smooth_intersect(.1,plane_sdf(p*m, vec3(-1,0,0), 3.),\n    smooth_intersect(.1,plane_sdf(p*m, vec3(1,0,0), 3.),\n    smooth_intersect(.1, plane_sdf(p*m, vec3(0,0,-1), 0.05),\n    plane_sdf(p*m, vec3(0,0,1), 0.05)))))));\n}\n\n\n\n// RAY TRACING\n\nvec3 trace(vec3 from, vec3 dir, mat3 m, out bool hit) {\n    vec3 p = from;\n    hit = false;\n    float total_dist = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float t = sdf(p, m);\n        if (t <= EPS) {\n            hit = true;\n            break;\n        }\n        p += t * dir;\n        total_dist += t;\n        if (total_dist > MAX_DIST) {\n            break;\n        }\n    }\n    return p;\n}\n\n\nvec3 norm (vec3 p, mat3 m)\n{\n    float d = EPS;\n    float dx1 = sdf(p + vec3(d, 0, 0), m);\n    float dx2 = sdf(p - vec3(d, 0, 0), m);\n    float dy1 = sdf(p + vec3(0, d, 0), m);\n    float dy2 = sdf(p - vec3(0, d, 0), m);\n    float dz1 = sdf(p + vec3(0, 0, d), m);\n    float dz2 = sdf(p - vec3(0, 0, d), m);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\n// LIGHTING\n\nfloat D_GGX(float noh, float roughness)\n{\n    float a2 = roughness*roughness;\n    float brace = (noh*noh*(a2 - 1.0) + 1.0);\n\t\n    return a2 /(PI* brace*brace);\n}\n\nfloat G_SchlickGGX(float nov, float roughness)\n{\n    float k = (roughness + 1.0)*(roughness + 1.0) / 8.0;\n\n    return nov / (nov*(1. - k) + k);\n}\n\nvec3 F_Schlick(float noh, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(clamp(1.0 - noh, 0.0, 1.0), 5.0);\n}\n\n\nfloat shadow(vec3 p, vec3 n, mat3 m, vec3 light) {\n    float hardness = 20.;\n    float min_dist = MAX_DIST;\n    float prev_t = 0.;\n    float dist_left = length(light - p);\n    vec3 dir = (light - p) / dist_left;\n    p += n*0.1;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float t = sdf(p, m);\n        if (t < prev_t && t < min_dist) {\n            min_dist = t;\n        }\n        prev_t = t;\n\n        if (abs(t) < 0.01) {\n            p += 0.11 * dir;\n        } else {\n            p += abs(t) * dir;\n        }\n        dist_left -= t;\n        if (dist_left <= 0.) {\n            break;\n        }\n    }\n    return 1./(1.+exp(-min_dist*hardness));\n}\n\nvec4 sky( in vec2 fragCoord) {\n    float h = fragCoord.y / iResolution.y;\n\n    return (vec4(180,218,231,1)*(1. - h) + vec4(1,114,184,1)*h)/255.;\n}\n\n// RENDERING\n\nvec3 direction(in vec2 fragCoord) {\n    float scale = 3.;\n    vec2 uv = scale*(fragCoord-.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n    return normalize(vec3(uv, 1));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 mouse = iMouse.xy / iResolution.xy -vec2(0.5, 0.5);\n    mat3 m = rotateX(6.28*mouse.y/2.-.5) * rotateY(-6.28*mouse.x/2.);\n    \n    // Scene setup\n    vec3 eye = vec3(0,2,-4);\n    vec3 dir = rotateX(-.5) * direction(fragCoord);\n    // Lights\n    int lights_count = 2;\n    vec3 lights[] = vec3[]( vec3(1,1.5,-1)*5., vec3(-1,.5,-1)*10. );\n    float lightInts[] = float[](3.5, 1.5);  \n    vec3 lightColors[] = vec3[](vec3(1), vec3(0,0,1));  \n\n    // Raycast\n    bool hit = false;\n    vec3 p = trace(eye, dir, m, hit);\n    if (!hit) {\n        fragColor = sky(fragCoord);\n        return;\n    }\n    // Normal\n    vec3 n = norm(p, m);\n\n        \n    // Load textures\n    float metallic=0.;\n    float roughness=1.;\n    float ambient=.1;\n    vec3 albedo;\n    \n    if (p.y < -5.0) { //floot\n        albedo = vec3(1);\n    } else if (dot(p, m*vec3(0,0,-1)) < 0.04) { //back of the card\n        albedo = vec3(0,0,0);\n    }\n    else { //the card\n        // Texture coordinates\n        vec3 card_normal = m*vec3(0,0,-1);\n        vec3 p_projected = p - card_normal*dot(p, card_normal);\n        vec3 coords = inverse(m)*p_projected;\n        coords.x = coords.x/6.-.5;\n        coords.y = coords.y/4.-.5;\n        // Textures\n        ambient = texture(iChannel1, coords.xy).x;\n        roughness = texture(iChannel1, coords.xy).x;\n        albedo = texture(iChannel0, coords.xy).xyz;\n        metallic = texture(iChannel3, coords.xy).x;\n\n        // tbn basis\n        vec3 n_tex = texture(iChannel2, coords.xy).xyz * 2. -1.;\n        vec3 t = m*vec3(1,0,0);\n        vec3 b = m*vec3(0,1,0);\n        n = n_tex.x*t+n_tex.y*b+n_tex.z*n;\n    }\n\n    vec3 resultColor = vec3(0,0,0);\n    for (int i = 0; i < lights_count; i++) {\n        // Vectors\n        vec3 l = normalize(lights[i] - p);\n        vec3 v = normalize(eye - p);\n        vec3 h = normalize(l + v);\n        // Scalar products\n        float noh = max(dot(n, h), 0.);\n        float nov = max(dot(n, v), 0.);\n        float nol = max(dot(n, l), 0.);\n\n        // Colors for specular and difusion components\n        vec3 F0 = mix(vec3(0.04), albedo, metallic);\n        vec3 F = F_Schlick(noh, F0);\n        vec3 specular = F * D_GGX(noh, roughness)*G_SchlickGGX(nov, roughness) / (4.*nov*nol+EPS);\n\n        vec3 diffuse = (vec3(1) - F)*(1. - metallic) * albedo / PI;\n\n        // Calculating incoming radience\n        float shadow = shadow(p, n, m, lights[i]);\n        vec3 radience = lightColors[i]*lightInts[i]*shadow*nol;\n\n        // Calculating outcoming radience\n        resultColor += (diffuse + specular)*radience;\n    }\n    // Ambien light\n    resultColor += albedo*ambient;\n\n    // Result\n    fragColor = vec4(resultColor, 1);\n}","name":"Image","description":"","type":"image"}]}