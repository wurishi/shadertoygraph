{"ver":"0.1","info":{"id":"cdKyW1","date":"1696056157","viewed":74,"name":"Texture mapped raymarching","username":"gimulnautti","description":"Add spherical and toroidal texture mapping to https://www.shadertoy.com/embed/wsSGDG","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","texture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 polarCoordinates(in vec3 p, in vec3 up, in vec3 right, in vec3 fwd)\n{\n    vec3 rfPlane = vec3(p.x, 0.0, p.z);\n    vec3 n = normalize(rfPlane);\n \n    float dotnright = dot(n, right);\n    float dotnfwd = dot(n, fwd);\n    \n    float angle = acos(dotnright);\n    if (dotnfwd < 0.0) angle = 6.28 - angle;\n    return vec2(angle / 6.28, p.y + 0.5);\n}\n\nfloat sdTorus(in vec3 p, in vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdInvTorus(in vec3 p, in vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return -(length(q) - t.y);\n}\n\nvec2 sdTorusMapped(in vec3 p, in vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n\n    vec3 right = vec3(1.0, 0.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 fwd = vec3(0.0, 0.0, 1.0);\n    \n    return vec2(polarCoordinates(p, up, right, fwd).x, polarCoordinates(vec3(q.x, 0.0, q.y), up, right, fwd).x);\n}\n\nfloat sdSphere(in vec3 p, in float s)\n{\n    return length(p) - s;\n}\n\nvec2 sdSphereMapped(in vec3 p, in float s)\n{\n    return polarCoordinates(p, vec3(0.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0));\n}\n\nvec3 repeat(in vec3 pos, in vec3 s)\n{\n    return pos - s*round(pos / s);\n}\n\nfloat map(in vec3 pos )\n{\n    //vec3 s = vec3(1.5, 1.3, 1.3);\n    vec3 s = vec3(6.0,5.0,6.0);\n    return sdInvTorus(repeat(pos, s), vec2(2.5, 2.1));\n    return sdInvTorus(pos, vec2(2.5, 2.0));\n    return sdTorus(repeat(pos, s), vec2(0.4, 0.21));\n    return sdSphere(repeat(pos, s), 0.5);\n}\n\nvec2 texMap(in vec3 pos)\n{\n    //vec3 s = vec3(1.5, 1.3, 1.3);   \n    vec3 s = vec3(6.0,5.0,6.0);\n    return sdTorusMapped(repeat(pos, s), vec2(2.5, 2.1));\n    return sdTorusMapped(pos, vec2(2.5, 2.0));\n    return sdTorusMapped(repeat(pos, s), vec2(0.4, 0.21));\n    return sdSphereMapped(repeat(pos, s), 0.5);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.15*(iTime-10.0);\n\tvec3 ro = vec3( 2.5*cos(an), 0.4, 4.0*sin(an) );\n    vec3 ta = vec3( 0.0, -0.0, 0.0 );\n    \n    //ro = vec3(-1.0,0.0,-1.9);\n    \n    // camera matrix\n    vec3 up = vec3(0.0,0.6,0.5);\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww, up) );\n    vec3 vv = normalize( cross(uu, ww) );\n    \n    // fragment position  \n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n\t// create view ray\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // uv coordinates\n    vec2 uv = vec2(0.0, 0.0);\n\n    // raymarch\n    const float tmax = 50.0;\n    float t = 0.0;\n    for( int i=0; i<256; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float h = map(pos);\n        if( h<0.0001) {\n            // calculate texture lookup on hit\n            uv = texMap(pos);\n            break;\n        }\n        else if ( t > tmax)\n        {\n            break;\n        }\n        t += h;\n    }     \n    \n    // shading\n    vec3 col = vec3(0.0);\n    if( t<tmax )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n        float dif = clamp( dot(nor,vec3(0.7,1.6,0.4)), 0.0, 1.0 );\n        float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n                       \n        col = ( vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif );  \n        col *= texture(iChannel0, uv).rgb;\n    }\n\n    // gamma        \n    col = sqrt( col );\n\n\n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}