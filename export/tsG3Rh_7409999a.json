{"ver":"0.1","info":{"id":"tsG3Rh","date":"1569684447","viewed":134,"name":"torus knot intersection gif","username":"arifr123","description":"the intersection of a rotating plane and a torus knot.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["torusknot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433832795\n\nfloat fOverDerF(float t, vec3 p)\n{\n    \n\tfloat sint = sin(t);\n    float cost = cos(t);\n    \n    float sin2t = 2.0*sint*cost;//sin(2.0*t);\n    float cos2t = cost*cost - sint*sint;//cos(2.0*t);\n    \n    float sin4t = 2.0*sin2t*cos2t;//sin(4.0*t);\n    \n    float sin3t = sin(3.0*t);\n    float cos2tSq = cos2t*cos2t;\n    float cos3t = cos(3.0*t);\n    \n    return (2.0*p.x*sint + p.x*sin2t + 2.0*p.x*sin4t - 3.0*p.y*cos3t - 2.0*p.z*cost - 4.0*p.z*cos2tSq + p.z*cos2t + 2.0*p.z - 6.0*sin3t)/(2.0*p.x*cost + 16.0*p.x*cos2tSq + 2.0*p.x*cos2t - 8.0*p.x + 9.0*p.y*sin3t + 2.0*p.z*sint - 2.0*p.z*sin2t + 8.0*p.z*sin4t - 16.0*cos2tSq*cos2t + 12.0*cos2t - 18.0*cos3t + 4.0*cos(6.0*t));\n\t\n    \n    //return (2.0*p.x*sin(t) + p.x*sin(2.0*t) + 2.0*p.x*sin(4.0*t) - 3.0*p.y*cos(3.0*t) - 2.0*p.z*cos(t) - 4.0*p.z*pow(cos(2.0*t), 2.0) + p.z*cos(2.0*t) + 2.0*p.z - 6.0*sin(3.0*t))/(2.0*p.x*cos(t) + 16.0*p.x*pow(cos(2.0*t), 2.0) + 2.0*p.x*cos(2.0*t) - 8.0*p.x + 9.0*p.y*sin(3.0*t) + 2.0*p.z*sin(t) - 2.0*p.z*sin(2.0*t) + 8.0*p.z*sin(4.0*t) - 16.0*pow(cos(2.0*t), 3.0) + 12.0*cos(2.0*t) - 18.0*cos(3.0*t) + 4.0*cos(6.0*t));\n}\n\nvec3 torusKnot(float t)\n{\n    return vec3((cos(3.0*t) + 2.0)*cos(t), sin(3.0*t), (cos(3.0*t) + 2.0)*sin(t));\n}\n\nfloat torusKnotDist(vec3 p)\n{\n    int samplePointsNum = 12;\n    \n    float jump = 2.0 * PI / float(samplePointsNum);\n    \n    float minDist = -1.0;\n    float minT;\n    \n    for(int i = 0; i < samplePointsNum; i++)\n    {\n        float cT = jump * float(i);\n        \n        cT -= fOverDerF(cT, p);\n        \n        float cDist = distance(torusKnot(cT), p);\n        \n        if(minDist == -1.0 || cDist < minDist)\n        {\n            minDist = cDist;\n            minT = cT;\n        }\n    }\n\n    minT -= fOverDerF(minT, p);\n    \n    return distance(torusKnot(minT), p);\n}\n\n\nmat4 rotationMatX( in float angle ) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nmat4 rotationMatY( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n\t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\n}\n\nmat4 rotationMatZ( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n\t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t0,\t1);\n}\n\nmat4 rotationMat(vec3 rotation){\n    return rotationMatX(rotation.x) * rotationMatY(rotation.y) * rotationMatZ(rotation.z);\n}\n\nvec3 rotate(vec3 v, mat4 rotationMat){\n    return vec3(vec4(v, 1.0) * rotationMat);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 i = vec3(1, 0, 0);\n    vec3 j = vec3(0, 1, 0);\n    vec3 k = vec3(0, 0, 1);\n    \n    \n    \n    mat4 rm = rotationMat(vec3(3.0*iTime, 7.0*iTime,  5.0*iTime)/4.0);\n        \n    i = rotate(i, rm);\n    j = rotate(j, rm);\n    k = rotate(k, rm);\n    \n    \n    vec2 uv = fragCoord - iResolution.xy/2.0;\n    uv /= iResolution.yy;\n    uv *= 8.0;\n    \n    \n    vec3 p = uv.x * i + uv.y * k;\n    \n    \n    vec3 col = vec3(0);\n    \n    //if(torusKnotDist(p) <= 0.5) col = (normalize(p+3.));\n    col = smoothstep(0., -12./iResolution.y, torusKnotDist(p) - .5 ) * normalize(p+3.);\n    \n    \n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}