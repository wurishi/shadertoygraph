{"ver":"0.1","info":{"id":"DtX3zf","date":"1673772367","viewed":118,"name":"PavilionInLake","username":"bryan05","description":"chinese pavilion,  phong illumination, shadow, lake environment","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"ctfGzf","parentname":"EnvironmentTemplate"},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst vec3 sunLig = normalize(vec3(0.1,0.4,0.7));\n\nvec2 pavilion(vec3 p, in sampler2D iChannel1)\n{    \n\n    vec2 res ;\n\n\n\n    p.y-=8.;\n\n\n    //ceiling\n    vec3 q = p;\n\n    q.y = p.z;\n    q.z = p.y;\n\n    float r = max(-q.z, 0.);\n    r = 0.15* pow(r, 2.);\n    vec2 rCeiling; \n    rCeiling.x = sdHexPrism( q,vec2( r, 7. ) );\n    rCeiling.x *= 0.4;\n    rCeiling.y = 4.1;\n\n    //sphere\n    q = p;\n    q.y +=0.6;\n    vec2 rSphere;\n    rSphere.x = length(q) -0.3;\n    rSphere.y = 4.1;    \n    res = combine(rCeiling, rSphere);\n    \n    \n    //floor    \n    q = p;\n    q.y = p.z;\n    q.z = p.y;\n    q.z +=15.;\n    vec2 rFloor;\n    rFloor.x = sdHexPrism(q, vec2(6., 0.3));\n    rFloor.y = 4.1;\n    res = combine(res, rFloor);\n\n\n\n    //columns\n    q = p;\n    float angle = PI2/6.0;\n    float tan = atan(p.z, p.x);\n\tfloat sector =  round( tan/ angle) ; \n    {\n        float an = sector * angle;\n        q.xz = mat2(cos(an), -sin(an), sin(an),cos(an)) * q.xz;\n\n    }\n      \n    q.x -= 5.;  \n    q.y += 11.;\n    vec2 rColumns;\n    rColumns.x = sdCylinder( q, vec3(0., -4., 0.), vec3(0., 5., 0.), 0.5);\n    rColumns.y = 4.2;\n    \n    res = combine(res, rColumns); \n    \n    \n    \n\n    return res;\n}\n\n\nvec3 doBumpMapGrass( in vec2 pos, in vec3 nor, out float hei )\n{\n    const float e = 0.002;\n    const float b = 0.03;\n    \n\tfloat ref = fbm6( 4.0*pos, iChannel0 );\n    hei = ref;\n    \n    vec3 gra = -b*vec3( fbm6(4.0*vec2(pos.x+e, pos.y), iChannel0)-ref,\n                        e,\n                        fbm6(4.0*vec2(pos.x, pos.y+e), iChannel0)-ref )/e;\n\t\n\tvec3 tgrad = gra - nor*dot( nor, gra );\n    return normalize( nor - tgrad );\n}\n\nvec3 skyColor( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.3,0.4,0.5)*0.3 - 0.3 * rd.y;\n\n    rd.y+= 0.025;\n    float t = (1000.0-ro.y)/rd.y;\n    if( t>0. )\n    {\n        vec2 uv = (ro+t*rd).xz;\n        float cl = texture( iChannel0, 0.00003*uv.yx ).x;\n        cl = smoothstep(0.3,0.7,cl);\n        col = mix( col, vec3(0.3,0.2,0.1), 0.1*cl );\n    }\n    \n    col = mix( col, vec3(0.2,0.25,0.30)*0.5, exp(-30.0*rd.y) ) ;\n    \n    float sd = pow( clamp( 0.35 + 0.65*dot(sunLig,-(rd)), 0.0, 1.0 ), 21.0 );\n    col = mix( col, vec3(1.2,0.30,0.05)/1.2, sd*exp(-abs((60.0-50.0*sd)*rd.y)) ) ;\n   // return vec3(abs(sd));\n    return col * 5.;\n}\n\n\n\nfloat terrain( in vec2 p )\n{\n   \n    float h = 90.0 * textureGood( iChannel2, p.yx*0.0001 + 0.35 + vec2(0.02,0.05) ).x - 70.0 + 5.0;\n    \n    h *= sin(length(p)/40.);\n    h = mix( h, -7.2, 1.0-smoothstep(16.0,60.0,length(p)));\n    h -= 7.0 * textureGood( iChannel2, p*0.002 ).x;\n    float d = textureLod( iChannel0, p*0.01, 0.0 ).x;\n    h -= 1.0*d*d*d;\n    return h;\n}\n\n\nvec2 sceneSDF(vec3 p, vec3 direction) {    \n\n    vec2 res ;\n    vec3 tempp = p;\n    tempp *= 1.6;\n    tempp.y += 1.; \n   res = pavilion(tempp,iChannel1);\n\n   float dPlane = p.y +9.;\n   dPlane += sin(p.x * 0.1 + iTime * 1.5) * 0.05;\n   vec2 planeRes;   \n   planeRes.x = dPlane;\n    \n   planeRes.y = 2.0;\n    \n   res = combine(res, planeRes);\n    \n   float h = terrain( p.xz );\n   float m = p.y - h;\n   m *= 0.35;\n   if( m<res.x ) \n   res = vec2( m, 3.0);\n   \n    return res;\n}\n\n\nvec2 calculateDistance(vec3 eye, vec3 marchingDirection, float start, float end) {\n    vec2 res;\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec2 dist = sceneSDF(eye + depth * marchingDirection, marchingDirection);\n        res.y = dist.y;\n        if (dist.x < EPSILON) {\n            res.x = depth;\n\t\t\treturn res;\n        }\n        depth += dist.x;\n        if (depth >= end) {\n            res.x = end;\n            return res;\n        }\n    }\n    res.x = end;\n    return res;\n}\n            \n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvec3 calculateNormal(vec3 p, vec3 direction) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z), direction).x - sceneSDF(vec3(p.x - EPSILON, p.y, p.z), direction).x,\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z), direction).x - sceneSDF(vec3(p.x, p.y - EPSILON, p.z), direction).x,\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON), direction).x - sceneSDF(vec3(p.x, p.y, p.z - EPSILON), direction).x\n    ));\n}\n\n\n/**\n * Phong illumination.\n * \n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity, vec3 direction, vec3 N) {\n   \n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n\n\n\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n\n\n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN) ;\n    }\n    \n\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n\n\n\nvec3 lightsAccumulation(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye, vec3 N) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    vec3 direction = p - eye;\n \n    \n    vec3 light1Pos = vec3(20.0 ,\n                          8.0,\n                          -20.0 );\n    vec3 light1Intensity = vec3(0.3, 0.4, 0.5);\n    \n    vec3 lightDirection = light1Pos - p;\n    float distanceToLight = length(lightDirection); \n    \n    vec3 diffuseDir = normalize(light1Pos);\n\n    vec2 dist = calculateDistance(p+N*0.001, diffuseDir, MIN_DIST, 5.*MAX_DIST);\n    float sha = 1.0f;\n    \n    if(dist.x < distanceToLight) sha = 0.0; \n    \n    \n    vec3 color1 = phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity, direction, N) *sha;\n\n    \n    color += color1;\n  \n    vec3 light2Pos = vec3(-light1Pos.x ,\n                          .0,\n                          -light1Pos.z );\n    vec3 light2Intensity = vec3(0.05, 0.05, 0.05);\n  \n    \n    vec3 color2 = phongContribForLight(k_d, vec3(0.5, 0.5, 0.5), 1., p, eye,\n                                  light2Pos,\n                                  light2Intensity, direction, N);\n\n    \n   color += color2;\n  \n    return color;\n}\n\nvec3 lighting(float ma, vec3 p, vec3 eye, vec3 direction )\n{\n    vec3 N = calculateNormal(p, direction);    \n   vec3 K_s = vec3(1., 1.0, 1.0);\n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = (getColor( vec3(240.,156., 90.))) ;\n    if(ma == 2.0 ) \n    {\n            K_a = vec3(0.1,0.27,0.18)*0.45;\n            K_a += 2.0*vec3(0.01,0.03,0.03)*(1.0-smoothstep(0.0,10.0,p.y-terrain(p.xz)));\n            K_a *= 0.4;            \n            float foam = (1.0-smoothstep(0.0,1.0,p.y-terrain(p.xz)));\n            foam *= smoothstep( 0.35,0.5,texture(iChannel0,p.xz*0.07).x );\n            K_a += vec3(0.08)*foam;\n\n\n            vec2 e = vec2(0.01,0.0);\n            float ho = fbm4( (p.xz     )*vec2(2.0,0.5), iChannel0 );\n            float hx = fbm4( (p.xz+e.xy)*vec2(2.0,0.5) , iChannel0);\n            float hy = fbm4( (p.xz+e.yx)*vec2(2.0,0.5) , iChannel0);\n            float sm = (1.0-smoothstep(0.0,4.0,p.y-terrain(p.xz)));\n            sm *= 0.02 + 0.03*foam;\n            ho *= sm;\n            hx *= sm;\n            hy *= sm;\n                \n            N = normalize( vec3(ho-hx,e.x,ho-hy) );\n    \n    \n        K_a *= 5.; \n        K_s = vec3(0.0, 0.0, 0.0);;\n    }\n    else \n    if(ma == 3.0 ) \n    {\n    \n\n\n        \n            K_a = vec3(0.95,0.9,0.85) * 0.4*texture( iChannel0, p.xz*0.015 ).xyz;\n            K_a *= 0.25 + 0.75*smoothstep( -25.0, -24.0, p.y );\n            K_a *= 0.32;            \n\t\t\tfloat h;\n            vec3 mor = doBumpMapGrass( p.xz, N, h );\n\n            float is_grass = smoothstep( 0.9,0.95,mor.y);\n            \n            K_a = mix( K_a, vec3(0.15,0.1,0.0)*0.8*0.7 + h*h*h*vec3(0.12,0.1,0.05)*0.15, is_grass );\n\n            N = mor;\n        \n        K_a *=5.;\n        \n        K_s = vec3(0.0, 0.0, 0.0);;\n    \n    \n    }\n     else \n    if(ma == 1.0 ) \n    {\n        K_a = vec3(0.95,0.9,0.55); \n        K_s = vec3(1., 1.0, 1.0);\n    }\n    else if (ma == 4.1)\n    {\n        K_a = vec3(153./255.,214./255.,138./255.) *0.7; \n        K_s = vec3(1., 1.0, 1.0);\n    }\n    else if (ma == 4.2)\n    {\n        K_a = vec3(214./255.,64./255.,64./255.) *0.7; \n        K_s = vec3(1., 1.0, 1.0);\n    }\n    vec3 K_d = K_a;\n    \n    float shininess = 10.;\n    \n    vec3 color = lightsAccumulation(K_a, K_d, K_s, shininess, p, eye, N);\n \n    return color;\n\n\n}\n\n\nmat3 buildViewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(120.0* sin (0.4 ), 30.0 , 120.0* cos(0.4 ));\n   // eye = vec3(30.0, 10.0 , 30.0);\n    mat3 viewToWorld = buildViewMatrix(eye, vec3(-18.0, 10.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    vec2 dist = calculateDistance(eye, worldDir, MIN_DIST, MAX_DIST);\n  \n    if (dist.x > MAX_DIST - EPSILON) \n    {\n      \n        fragColor =vec4( skyColor( eye, worldDir ), 1.0);\n\t\treturn;\n    }\n    \n    vec3 p = eye + dist.x * worldDir;\n    \n\n    \n    vec3 color = lighting(dist.y, p, eye, worldDir);\n    \n    vec3 fogcol = vec3(0.1,0.125,0.15);\n    float sd = pow( clamp( 0.25 + 0.75*dot(sunLig,abs(worldDir)), 0.0, 1.0 ), 4.0 );\n\tfogcol = mix( fogcol, vec3(1.0,0.25,0.042), sd*exp(-abs((60.0-50.0*sd)*abs(worldDir.y))) ) ;\n\n    float fog = 1.0 - exp(-0.0013*dist.x);\n    color *= 1.0-0.5*fog;\n    color = mix( color, fogcol *4., fog );\n    \n    fragColor = vec4( color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//functions from iq\n\n#define PI2 6.283185\nconst int MAX_MARCHING_STEPS = 2000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 500.0;\nconst float EPSILON = 0.0001;\n\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n\n\n\n\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    else p.y = p.y + sin(p.x)* .3;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x ;\n    float d2 = abs(p.z)-h.y ;\n  //  d2 -= step(p.z, 0.) * sin(p.y) *0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n\n\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\n// https://iquilezles.org/articles/smin\nvec3 smax( vec3 a, vec3 b, float k )\n{\n\tvec3 h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\nvec3 getColor(vec3 color)\n{\n    return vec3(color.x/255., color.y/255., color.z/255. );\n}\n\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n/////////////// iq's distance funs\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - (b-r);\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\n\n\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\n\nfloat noise( in vec3 x , in sampler2D iChannel1 )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel1, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat noise( in vec2 x , in sampler2D iChannel1)\n{\n    vec2 p = vec2(floor(x));\n    vec2 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = p.xy;\n\tfloat rgA = textureLod( iChannel1, (uv+vec2(0,0))/256.0, 0. ).x;\n    float rgB = textureLod( iChannel1, (uv+vec2(1,0))/256.0, 0. ).x;\n    float rgC = textureLod( iChannel1, (uv+vec2(0,1))/256.0, 0. ).x;\n    float rgD = textureLod( iChannel1, (uv+vec2(1,1))/256.0, 0. ).x;\n    return mix( mix( rgA, rgB, f.x ),\n                mix( rgC, rgD, f.x ), f.y );\n}\n\nfloat fbm4( in vec3 p , in sampler2D iChannel1)\n{\n    float n = 0.0;\n    n += 1.000*noise( p*1.0 , iChannel1);\n    n += 0.500*noise( p*2.0 , iChannel1);\n    n += 0.250*noise( p*4.0 , iChannel1);\n    n += 0.125*noise( p*8.0 , iChannel1);\n    return n;\n}\n\nfloat fbm4( in vec2 p , in sampler2D iChannel1)\n{\n    float n = 0.0;\n    n += 1.00000*noise( p*1.0 , iChannel1);\n    n += 0.50000*noise( p*2.0 , iChannel1);\n    n += 0.25000*noise( p*4.0 , iChannel1);\n    n += 0.12500*noise( p*8.0 , iChannel1);\n    return n;\n}\n\nfloat fbm6( in vec3 p , in sampler2D iChannel1)\n{\n    float n = 0.0;\n    n += 1.00000*noise( p*1.0 , iChannel1);\n    n += 0.50000*noise( p*2.0 , iChannel1);\n    n += 0.25000*noise( p*4.0 , iChannel1);\n    n += 0.12500*noise( p*8.0 , iChannel1);\n    n += 0.06250*noise( p*16.0 , iChannel1);\n    n += 0.03125*noise( p*32.0 , iChannel1);\n    return n;\n}\n\n\nfloat fbm6( in vec2 p , in sampler2D iChannel1 )\n{\n    float n = 0.0;\n    n += 1.00000*noise( p*1.0 , iChannel1);\n    n += 0.50000*noise( p*2.0 , iChannel1);\n    n += 0.25000*noise( p*4.0 , iChannel1);\n    n += 0.12500*noise( p*8.0 , iChannel1);\n    n += 0.06250*noise( p*16.0 , iChannel1);\n    n += 0.03125*noise( p*32.0 , iChannel1);\n    return n;\n}\n\nfloat fbm( in vec3 p , in sampler2D iChannel1)\n{\n    return fbm4(p, iChannel1);\n}\n\nvec2 combine(vec2 res1, vec2 res2)\n{\n    if( res1.x < res2.x ) return res1;\n    else return res2;\n\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n\n\n\n\nvec4 textureGood( sampler2D sam, in vec2 uv )\n{\n    uv = uv*1024.0 - 0.5;\n    vec2 iuv = floor(uv);\n    vec2 f = fract(uv);\n    f = f*f*(3.0-2.0*f);\n\tvec4 rg1 = textureLod( sam, (iuv+ vec2(0.5,0.5))/1024.0, 0.0 );\n\tvec4 rg2 = textureLod( sam, (iuv+ vec2(1.5,0.5))/1024.0, 0.0 );\n\tvec4 rg3 = textureLod( sam, (iuv+ vec2(0.5,1.5))/1024.0, 0.0 );\n\tvec4 rg4 = textureLod( sam, (iuv+ vec2(1.5,1.5))/1024.0, 0.0 );\n\treturn mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\n}\n\n\n","name":"Common","description":"","type":"common"}]}