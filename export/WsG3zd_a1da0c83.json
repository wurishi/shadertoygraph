{"ver":"0.1","info":{"id":"WsG3zd","date":"1570797293","viewed":228,"name":"Flight through a nebula v2","username":"Delvar","description":"Simple fly though of a 3d simplex via ray marching.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["noise","raymarch","cloud","simplex","nebula"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// also see \n// voronoi  version, https://www.shadertoy.com/view/tdyGzK\n// simplex version, https://www.shadertoy.com/view/WsG3zd\n// box version, https://www.shadertoy.com/view/tsK3Rd\n// simplex function taken from https://www.shadertoy.com/view/XsX3zB\n\n\n#define RAY_MAX_STEPS 100\n#define RAY_MAX_DISTANCE 10.0\n#define RAY_CAMERA_FADE_START_DISTANCE 0.5\n#define RAY_CAMERA_FADE_END_DISTANCE 2.0\n#define RAY_MAX_STEPS_SHADOW 15\n\n#define K\t0.1428571428571429\t// 1/7\n#define Ko\t0.3571428571428571\t// 1/2-(K/2)\n#define K2\t0.0204081632653061\t// 1/(7*7)\n#define Kz\t0.1666666666666667\t// 1/6\n#define Kzo\t0.4166666666666667\t// 1/2-(1/(6*2))\n#define Km\t0.0034602076124567\t// 1/289\n#define PI\t3.1415926535897932384626433832795\n    \nstruct camera {\n   vec3 origin, forward, right, up;\n   float zoom; // Distance from screen\n};\n\nstruct ray {\n   vec3 origin, direction;\n};\n       \ncamera getCameraDirection(vec3 origin, vec3 direction, float zoom) {\n   camera camera;\n   camera.origin = origin;\n   camera.forward = normalize(direction);\n   camera.right = cross(vec3(0.0,1.0,0.0), camera.forward);\n   camera.up = cross(camera.forward, camera.right);\n   camera.zoom = zoom;\n   return camera;\n}\n\nray getRay(vec2 uv, camera camera) {\n\tray ray;\n    ray.origin = camera.origin;\n    vec3 center = ray.origin + camera.forward * camera.zoom;\n    vec3 intersection = center + (uv.x * camera.right) + ( uv.y * camera.up );\n    ray.direction = normalize(intersection - ray.origin);\n\treturn ray;   \n}\n\nfloat mod289(float x) {\n\treturn x - floor(x * Km) * 289.0;\n}\n\nfloat mod7(float x) {\n\t//return x;\n\treturn x - floor(x * (1.0 / 7.0)) * 7.0;\n}\n\n//Wrap around for id generation\nfloat wrap(float x) {\n\t//return mod((34.0 * x + 1.0) * x, 289.0);\n    return mod289((34.0 * x + 1.0) * x);\n}\n\n// --------------------------------------------------\n//from https://www.shadertoy.com/view/XsX3zB\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\n#define F3 0.333333\n#define G3 0.1666667\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n// --------------------------------------------------\n\nvec3 RayMarch(ray ray, float maxDistance, int maxSteps)\n{\n    float maxStepsf = float(maxSteps);\n    float stepSize = maxDistance/maxStepsf;\n    vec3 total = vec3(0.0);\n    \n    // Stop the shimmering??\n    //float currentDistance = stepSize-(ray.origin.z-(floor(ray.origin.z/stepSize)*stepSize));\n    float currentDistance = 1.0;\n    \n    float strike = 1.0+smoothstep(0.5,1.0,sin(ray.direction.z+iTime*20.0)*sin(ray.direction.x +iTime*30.0)*cos(ray.direction.y +iTime*40.0)*(wrap(iTime)/289.0));\n    \n    for(float i=0.0; i<maxStepsf; i++) {\n\t\tvec3 currentPoint = ray.origin + ray.direction * currentDistance;\n        \n        float s = (1.0-abs(simplex3d(currentPoint)));\n        s=s*s*s;\n        s=smoothstep(0.1,2.0, s);\n        \n        float stepf = ((maxStepsf - i)/maxStepsf);\n        s *= stepf;\n        vec3 light = sin((currentPoint+vec3(iTime/10.0,iTime/13.0,iTime/15.0))/4.0)*0.5+1.0; //Yes we blow out the colour a little.\n        total += light*s;\n        currentDistance += stepSize;\n    }\n    return (total*(3.0/maxStepsf))*strike;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized Pixel coordinates (from -0.5 to +0.5, center at 0,0)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    // Normalized Mouse coordinates (from -0.5 to +0.5, center at 0,0)\n    vec2 mouse = ((iMouse.xy-0.5*iResolution.xy)/iResolution.y);// - vec2(0.5,0.5)*(iMouse.w*0.1);\n    //Snap to center on startup.\n    if(iMouse.x <= 1.0 && iMouse.y <= 1.0) {\n        mouse = vec2(0.0,0.0);\n    }\n\n    // -- 1st person cammera\n    vec3 forward = vec3(\n        sin(mouse.x*PI),\n    \tsin(mouse.y*PI),\n    \tcos(mouse.x*PI)\n    );\n    camera camera = getCameraDirection(vec3(0.0,0.0,iTime), forward, 0.5);\n    \n    ray ray = getRay(uv, camera);\n\tvec3 colour = RayMarch(ray, RAY_MAX_DISTANCE, RAY_MAX_STEPS);\n    float gamma = 0.8;\n    colour = pow(colour, vec3(1.0/gamma));\n    \n    fragColor = vec4(colour,1.0);\n\n}\n","name":"Image","description":"","type":"image"}]}