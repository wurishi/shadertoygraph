{"ver":"0.1","info":{"id":"4ffyD2","date":"1721906818","viewed":190,"name":"Pathtraced Materials Fork","username":"spalmer","description":"pathtraced BSDFs based on Poisson's toy\nnot [i]quite[/i] PBR","likes":11,"published":1,"flags":32,"usePreview":1,"tags":["reflection","gi","dof","csg","wood","ellipsoid","brdf","diffuse","material","ibl","pbr","bsdf","raytrac","pathtrac"],"hasliked":0,"parentid":"dsdSW4","parentname":"materials :)"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// spalmer fork of Poisson's most excellent http://shadertoy.com/view/dsdSW4\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    fragColor.rgb = pow(fragColor.rgb, vec3(.45)); // approx. gamma correction OETF\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":3,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// fork from http://shadertoy.com/view/dsdSW4\n// original shader by http://shadertoy.com/user/Poisson\n// default CCA-BY-NC-SA 3.0 license\n// Features: IBL, PBR, diffuse, roughness, glossy, metal,\n// global illumination, glass refraction and caustics, \n// textures, bump mapping, emission, lights, absorption,\n// depth of field (DoF), anisotropy (kinda)\n\n// spalmer refactored the BSDF and materials\n// improved camera motion handling, add egg CSG,\n// animated light colors, redid tonemap and skybox\n// did quite a lot of cleanup actually\n\n// samples per pixel per frame (16 got me a performance warning!)\nconst int SPP = 4;\n\nconst float tau = radians(360.);\n\nfloat sqr(float x) { return x * x; }\n\nconst vec3 lumcoeff = vec3(.299, .587, .114); // which rec?\n\nfloat luma(vec3 c)\n{\n    return dot(c, lumcoeff);\n}\n\nfloat rseed; // random seed\n\nfloat rand()\n{\n    return fract(sin(rseed += .1) * 4568.7564);\n}\n\n// normalized on sphere surface\nvec3 distribSphere() \n{\n    float a = rand() * tau,\n        x = rand() * 2. - 1.;\n\treturn vec3(sqrt(1. - x * x) * vec2(sin(a),cos(a)), x);\n}\n\n// 3d vector uniformly distributed within unit ball, I think\nvec3 uniformVector() \n{\n\treturn pow(rand(), 1./3.) * distribSphere();\n}\n\n// random 3d vector, gaussian distributed?\nvec3 randomVector()\n{\n    return sqrt(rand()) * uniformVector();\n}\n\n// http://shadertoy.com/view/7tGBDw\n// supposed to return the *local* H vector !!\n/*vec3 sample_ggx_importance(vec3 n, vec3 v, float a2) // sample isotropic H\n{\n    vec2 uv = vec2(rand(), rand());\n    float cos_th = sqrt(max((1. - uv.x) / (uv.x * (a2 - 1.) + 1.), .0001));\n    float sin_th = sqrt(max(1. - cos_th * cos_th, 0.0001));\n    float phi = tau * uv.y;\n    // this still needs transformed somehow though... in tangent space I suppose.\n    vec3 srv = vec3(sine_th * cos(phi), sin_th * sin(phi), cos_th);\n    //return srv;\n    // I'd rather have one that works in world space, avoiding transforms.\n    // let's just return a spherically uniform vector proportion, caller can add it to the other vector and normalize..\n    // requires args n and v so we can construct the proper vector orientated properly\n    vec3 r = reflect(n, -v);\n    vec3 v_new = normalize(mix(r, n, a2));\n    return normalize(v_new + srv);\n}*/\n\n// TODO Trowbridge-Reitz\n/*float D_tr(float nh, float a) \n{\n    float aa = a * a,  t = 1. + (aa - 1.) * nh * nh;\n    return aa / (.5 * tau * t * t);\n}*/\n\n// Fresnel approx\nfloat schlick(float c) // assumes c is 0..1 - since c is v dot h, and h is halfway to l, vh can not be below 0.\n{\n    float m = 1. - c, mm = m * m;\n    return mm * mm * m;\n}\n\n// ray ellipsoid intersection function\n// thanks to iq: http://iquilezles.org/articles/intersectors/\n// egg[0] is the center of the ellipsoid and egg[1] is the size\nvec2 intersectEllipse(vec3 ro, vec3 rd, mat2x3 egg)\n{\n    vec3 oc = ro - egg[0],\n        r2 = 1. / (egg[1] * egg[1]);\n    float a = dot(rd, rd * r2),\n        b = dot(oc, rd * r2),\n        c = dot(oc, oc * r2),\n        h = b * b - a * (c - 1.); // discriminant\n    if (h < 0.)\n        return vec2(-1);\n    return (vec2(-1, 1) * sqrt(h) - b) / a;\n}\n\n// gets animated by mainImage\nvec3 eggCut0 = vec3(.3,-.4,.5), //vec3(0,.7,0), //\n    eggCut1 = vec3(.42);\n\nvec3 eggNormal(vec3 p, mat2x3 e)\n{\n    p -= e[0];\n    vec3 r2 = 1. / (e[1] * e[1]);\n    vec3 n = normalize(p * r2);\n    p -= eggCut0;\n    if (length(p / eggCut1) < 1.)\n        n = normalize(p / (eggCut1 * eggCut1));\n    return n;\n}\n\n// ellipsoids\n//const\nmat2x3 eggs[] = mat2x3[] (\n    mat2x3(-1.5,1.5,  .5, .2,.2,.2),\n    mat2x3( 1.5,1.5,- .5, .2,.2,.2),\n    mat2x3(-1.5,0  , 0  , .4,.5,.4),\n    mat2x3( 0  ,0  , 0  , .4,.5,.4),\n    mat2x3( 1.5,0  , 0  , .4,.5,.4),\n    mat2x3( 1.5,0  , 1.5, .4,.5,.4),\n    mat2x3(-1.5,0  , 1.5, .4,.5,.4),\n    mat2x3( 0  ,0  , 1.5, .4,.5,.4),\n    mat2x3( 0  ,0  ,-1.5, .4,.5,.4),\n    mat2x3( 1.5,0  ,-1.5, .4,.5,.4),\n    mat2x3(-1.5,0  ,-1.5, .4,.5,.4)\n);\n#define EGGCOUNT eggs.length()\n\n// ray-scene intersection\nfloat intersect(vec3 ro, vec3 rd, float tmax, out vec3 on, out float oid)\n{\n    float t = tmax; // final distance    \n    for (int i = 0; i < EGGCOUNT; ++i) {\n        mat2x3 eg = eggs[i]; // current ellipsoid\n        vec2 tn = intersectEllipse(ro, rd, eg); // 2 hit times or -1\n        if (tn.x < 0. && tn.y > 0.) tn.x = 0.; // start inside\n        if (dot(eggCut1, eggCut1) > 0.) {\n            // some CSG for more interesting shape than simple ovoid (eggs are cooler than spheres though)\n            vec2 tm = intersectEllipse(ro, rd, mat2x3(eg[0] + eggCut0, eggCut1));\n            if (tn.x > 0. && tm.y > 0.) { // && tm.x > tn.x && tm.y > tn.x\n                if (tn.x > tm.x && tn.y < tm.y)\n                    tn = vec2(-1.);\n                if (tm.x < tn.x && tn.x < tm.y) //tm.x < tn.x) // && tn.y < tm.x) //\n                    tn.x = tm.y; // CSG\n            }\n        }\n        if (tn.x > 0. && tn.x < t) {\n            on = eggNormal(tn.x * rd + ro, eg); //tn.xyz;\n            oid = float(i); // ellipsoid id\n            t = tn.x; //tn.w;\n        }\n    }    \n    // plane\n    float h = (-.5-ro.y) / rd.y;\n    if (rd.y < -.05 && h < t) { //h > 0. && h < t) { // fake tabletop\n        on = vec3(0,1,0);\n        oid = float(EGGCOUNT);\n        t = h;\n    }\n    return min(t, tmax);\n}\n\n\n// http://youtube.com/watch?v=VaYyPTw0V84\nvec3 texTriplanar(sampler2D tex, vec3 p, vec3 n) \n{\n    vec3 xy = texture(tex, p.xy).rgb;\n    vec3 xz = texture(tex, p.xz).rgb;\n    vec3 yz = texture(tex, p.yz).rgb;\n    n = normalize(n);\n    vec3 m = abs(n); //n * n; //\n    return yz*m.x + xz*m.y + xy*m.z;\n}\n\n// texture bump mapping, thanks Shane\n// bf = bump factor\nvec3 texBump(sampler2D tex, vec3 p, vec3 n, float bf)\n{\n    const vec2 e = vec2(.0002, 0); // epsilon\n    mat3 m = mat3(texTriplanar(tex, p - e.xyy, n),\n                  texTriplanar(tex, p - e.yxy, n),\n                  texTriplanar(tex, p - e.yyx, n));\n    // normal of texture\n    vec3 g = lumcoeff * m; // luma coeffs\n    g = (g - luma(texTriplanar(tex,  p , n))) / e.x; \n    g -= n * dot(n, g);                      \n    return g * bf;\n}\n\n\n// return true to continue tracing, false to terminate with col\nbool surface(vec3 p, vec3 n, float id, inout float t, inout vec3 ro, inout vec3 rd, inout vec3 col)\n{\n    int i = int(round(id));\n    float blink0 = (1. - abs(sin(1.5 * iTime))); //1.; // for animation\n    float blink1 = 1. - blink0; //1.; //\n    //float blink2 = (1. - abs(sin(6. * iTime))); // for debugging\n    // multi-material split\n    switch (i) {\n        case 6:\n        case 10:\n            float h = texTriplanar(iChannel2, p*2., n).r;\n            if (h > .7)\n                id = float(i = 5); // gold\n            break;\n    }\n    \n    // shading model\n    const int KLITE = 0, KOPAQ = 1, KTRANS = 2, KMETAL = 3;\n    // TODO should unify KOPAQ and KTRANS to KDIELECTRIC\n    int kind = KOPAQ;\n    vec3 tint = vec3(1);\n    float\n        f0 = .05,\n        ior = 1.5; // TODO f0 more fundamental?\n    vec3 bmp = vec3(0);\n    vec3 arou = vec3(0); // \"anisotropic\" roughness\n    // obtain material parameters\n    switch (i)\n    {\n        case 0:\n            kind = KLITE;\n            tint = vec3(5) * blink1;\n            break;\n        case 1:\n            kind = KLITE;\n            tint = vec3(7,7,0) * blink0;\n            break;\n        case 2:\n            kind = KOPAQ;\n            //arou = vec3(0.);\n            tint = vec3(.9,.3,.1); // smooth orange plastic\n            break;\n        case 3:\n            kind = KOPAQ;\n            tint = vec3(.2,.6,.1); // rough green plastic\n            arou = vec3(.6) * sqrt(1./3.);\n            bmp = texBump(iChannel2, p*2., n, .04);\n            break;\n        case 4:\n            kind = KMETAL; // crumpled aluminum\n            tint = vec3(.9);\n            arou = vec3(.4) * sqrt(1./3.);\n            bmp = texBump(iChannel3, p*.5, n, .003);\n            break;\n        case 5:\n            kind = KMETAL;\n            bmp = texBump(iChannel2, p*2., n, -.04);\n            tint = vec3(.9,.7,.3); // golden\n            break;\n        case 6:\n            kind = KOPAQ;\n            bmp = texBump(iChannel2, p*2., n, .1);\n            tint = vec3(.3,.1,.9); // violet\n            break;\n        case 7:\n            kind = KMETAL; // blue \"brushed\"\n            arou = vec3(.4, 1,.4); // anisotropic\n            tint = vec3(.1,.3,.9);\n            break;\n        case 8:\n            kind = KTRANS;\n            tint *= exp(-2. * t * (1. - vec3(.9,.8,.7))); //tint *= exp(-.2 * t * vec3(1,2,3)); // smoky absorption of mostly b\n            break;\n        case 9:\n            kind = KTRANS;  // plain glass\n            break;\n        case 10:\n            kind = KTRANS;\n            bmp = texBump(iChannel2, p*2., n, .07);\n            ior = 2.4; // emerald\n            tint *= exp(-1.5 * t * (1. - vec3(0,.93,.16))); //tint *= exp(-.5 * t * vec3(3,.2,2.5)); // absorb r+b\n            break;\n        case 11:\n            kind = KOPAQ; // wood floor\n            bmp = texBump(iChannel3, p*.5, n, .0025);\n            tint = pow(texture(iChannel3, p.xz*.5).rgb, vec3(2.));\n            arou = vec3(.01,.01,.4); //vec3(.1) * sqrt(1./3.); //\n            f0 = .1; // shinier clearcoat\n            break;\n    }\n    //if (i == 4) tint = blink2 * 12. * vec3(1,0,1); // debug glow on a particular obj\n    float rou = length(arou);\n    if (kind == KLITE) {\n        col *= tint;\n        return false; // self-illuminated - terminate\n    }\n    if (kind == KTRANS) {\n        f0 = (1. - ior) / (1. + ior); // recompute f0 from ior\n        f0 = f0 * f0;\n    }\n    \n    n = normalize(n + bmp); // apply bumpmap\n    float fre = 1. + dot(rd, n); // fresnel - before or after bumpmap?  FIXME should use vh\n    vec3 l = reflect(rd, n); // Phong\n    //l = sample_ggx_importance(n, v, rou * rou); // TODO use better distribution\n    \n    float ks = f0 + (1.-f0) * pow(fre, 5.) * (1. - rou);\n    float s = -sign(fre - 1.); // inside or outside\n    if (s > 0.) ior = 1. / ior;\n    \n    // BSDF set up for reflection by default\n    if (kind == KMETAL) {\n        col *= tint;\n    } else if (ks < rand()) { \n        if (kind == KOPAQ) { // opaque material : diffuse\n            col *= tint;\n            l = n; arou = vec3(sqrt(1./3.));\n        } else if (kind == KTRANS) { // transmission\n            if (s > 0.) col *= tint; // absorption\n            l = refract(rd, n, ior);\n            n = -n;\n        }\n    } \n    vec3 srv = uniformVector(); //randomVector(); //\n    rd = normalize(normalize(l) + arou * srv);\n    ro = .0005 * n + p;\n    return true;\n}\n\n   #if 0\n    // TODO figure out the ndf (pdf?) correction factor,\n    // add importance sampling biasing for the two lights and for the upper (sky) hemisphere\n    // something like:\n    vec3 is_bias = normalize(vec3(0,1,0) + normalize(vec3(p - spheres[0][0])) + normalize(vec3(p - spheres[1][0])));\n    vec3 l2 = normalize(l + is_bias);\n    col /= dot(is_bias, l2); // *=\n    l = l2; // importance sample?\n   #endif\n\n// tonemapper\n\n \n// un-tonemap operator, first decide which tonemap to use\nfloat untonemap(float x)\n{\n    x = sqrt(max(x, 1e-3));\n    return x / (6. - 6. * x);\n}\n    //return sinh(x); // inverse of asinh\n    // I have inverse ACES somewhere, can't bother finding rn\n//vec3 ACES(vec3 x) { float a = 2.51, b = .03, c = 2.43, d = .59, e = .14; return (x*(a*x+b)) / (x*(c*x+d)+e); }\nfloat tonemap(float x)\n{\n    return sqr(x / (x + 1. / 6.)); // my approx to Hable uncharted 2 tonemap\n}\n    //return ACES(vec3(x)).r;\n    //return asinh(x);\n    //return x / (x + .6);\n\n// can tune relative to the point lightsources which are around 6 luminance\nconst float cubemapBrightness = 6.;\n// sets white point\nconst float exposure = 1.;\n\nvec3 untonemap(vec3 c)\n{\n    return vec3(untonemap(c.r), untonemap(c.g), untonemap(c.b));\n}\n\nvec3 tonemap(vec3 c)\n{\n    return vec3(tonemap(c.r), tonemap(c.g), tonemap(c.b));\n}\n\nvec3 skybox(vec3 rd)\n{\n    vec3 c = texture(iChannel1, rd).rgb;\n    c = pow(c, vec3(2.2)); // EOTF approx from sRGB\n    //c = clamp(c, 1e-7, .995); // inverting 1. gives infinity, we don't want that\n    c = untonemap(c); // only reason I'm using my un-tonemap is so that it will match original once it gets tonemapped again; sometimes you may not care if it matches exactly\n    c = clamp(c, 0., cubemapBrightness); // let's clamp afterward instead\n    return c;\n}\n    //c *= cubemapBrightness; // not exposure, since we didn't produce the image\n\n// multibounce pathtracing rendering\nvec3 PathTrace(vec3 ro, vec3 rd)\n{\n    int izero = min(0, iFrame);\n    vec3 col = vec3(1); // final color\n    float tmax = 8e4;\n    for (int i = izero + 4; i-- > 0; ) { // 4 bounces of GI seems plenty\n        vec3 n; float id; // normal and id\n        float t = intersect(ro, rd, tmax, n, id); // distance\n        if (!(t < tmax)) //t < 0.) \n            return col * skybox(rd); // background\n        vec3 p = ro + rd*t;\n        // moved material eval \n        bool go = surface(p, n, id, t, ro, rd, col);\n        if (!go) break;\n    }\n    return col;\n}\n\nmat3 setCamera(vec3 ro, vec3 ta)\n{\n    vec3 w = normalize(ta - ro), // forward\n        u = normalize(cross(w, vec3(0,1,0))), // right\n        v = cross(u, w); // up\n    return mat3(u, v, w);\n}\n\n// vec2 to float for dithering rand seed\nfloat hash(vec2 x)\n{\n\tfloat n = dot(x,vec2(127.1, 311.7));\n\treturn fract(sin(n) * 4568.7564);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 R = iResolution.xy;\n    if (length(fragCoord - .5) < .5) { // FIXME sqrt\n        fragColor = vec4(R, iMouse.xy);\n        return;\n    }\n    int izero = min(0, iFrame);\n    \n    eggCut0 = .6 * sin(floor(iDate.w / 10.) * 789. * vec3(4,5,6));\n    \n    // normalized mouse coordinates\n    vec2 mo = (iMouse.xy - .5 * R) / R.y;\n\n    float an = -mo.x * tau - 1.5; // camera xz rotation\n    vec3 ro = 4.5*vec3(sin(an), .3+.7*mo.y, cos(an)), // ray origin\n        ta = vec3(0); // target\n    mat3 ca = setCamera(ro, ta); // camera matrix\n    vec2 p0 = (fragCoord - .5 * R) / R.y; // pixel coordinates centered\n    vec3 rd = ca * normalize(vec3(p0, 1.5)); // ray direction\n\n    // depth of field\n    vec3 tn; float tid;\n    float fd = intersect(ro, ca[2], 12., tn, tid); // auto set focus distance by tracing ray forward - outside SPP loop!\n    vec3 fp = fd * rd + ro; // focal point\n\n    vec3 c = vec3(0); // accumulated color\n    for (int i = SPP + izero; i-- > 0; ) {\n        // init random seed\n        rseed = float(i) + iTime + hash(p0);\n        // FIXME does many rand(), some could be re-used.\n        vec2 off = vec2(rand(), rand()) - .5; // AA subpixel offset\n        \n        vec2 p = p0 + off / R.y;\n        \n        // disk distribution\n        float w = sqrt(rand()); // vector length\n        float a = tau * rand(); // angle\n        \n        ro += .03 * w * vec3(sin(a), cos(a), 0.) * ca;  // blur\n        rd = normalize(fp - ro);\n                \n        c += PathTrace(ro, rd);\n    }\n    c /= float(SPP);    \n    \n    c = tonemap(c) / tonemap(exposure);\n    vec4 dat0 = texelFetch(iChannel0, ivec2(0), 0),\n        prior = texelFetch(iChannel0, ivec2(fragCoord), 0); // prior frames\n    float dt = 1. / 60., //iTimeDelta, //\n        blend = exp2(-2. * dt) * step(.01, iTime); // don't blend on frame 0\n    // if not moving mouse, allow to accumulate.\n    if (length(vec4(R, iMouse.xy) - dat0) > 2.) blend = 0.; // FIXME sqrt\n    blend *= max(0., 1. - .3 * length(iMouse.xy - dat0.zw)); // depends on how much mouse moved, so small motions keep more data, but blends faster than usual if any mouse motion\n    c = mix(c, prior.rgb, blend);\n    c = clamp(c, 0., 1.);\n    fragColor = vec4(c, 1);\n}\n\n    // color grading\n    //c = c*c*(3.-2.*c); // contrast\n    //c = 1.85*c/(1.+c); // highlights rolloff\n\n    // vignette\n    //c *= .5+.5*pow(16. * p.x*p.y*(1.-p.x)*(1.-p.y), .1);\n   \n","name":"Buffer A","description":"","type":"buffer"}]}