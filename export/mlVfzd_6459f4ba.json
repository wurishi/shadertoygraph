{"ver":"0.1","info":{"id":"mlVfzd","date":"1702408925","viewed":79,"name":"cosmos egg","username":"nayk","description":"cosmos,sky,egg,raymarch,stars,colorful,glow","likes":4,"published":1,"flags":1,"usePreview":0,"tags":["raymarch","colorful","sky","glow","stars","cosmos","egg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*originals https://www.shadertoy.com/view/4tyfWy  https://www.shadertoy.com/view/lslyRn https://www.shadertoy.com/view/DtGfzV and other https://www.shadertoy.com/view/mtSSDt*/\n\n\n\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000\n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\n\n\n\n//parameter in the geodesic flow\nfloat xi=1.;\nfloat fov=120.;\n\n\n//flow by nil geodesics towards the xy plane.\nvec3 flow(vec3 eye, vec3 dir,float t){\n   \n    //get a and c and alpha:\n    float c=dir.z;\n    float a=length(dir.xy);\n    float alpha=atan(dir.y,dir.x);\n   \n    //give geodesic\n    float x=(a*sin(c*t*xi+alpha)-a*sin(alpha))/(c*xi);\n       \n    float y=(a*cos(c*t*xi+alpha)-a*cos(alpha))/(c*xi);\n    float z=((a*a*c+2.*c*c*c)*t*xi-a*a*sin(c*xi*t))/(2.*c*c*xi);\n   \n    return eye+vec3(x,y,z);\n}\n\n\nvec3 flow2(vec3 eye, vec3 dir,float t){\n   \n    //get a and c and alpha:\n    float c=dir.z;\n    float a=length(dir.xy);\n    float alpha=atan(dir.y,dir.x);\n   \n    //give geodesic\n    float x=2.*a/c*sin(c*t/2.)*cos(c*t/2.+alpha);\n    float y=2.*a/c*sin(c*t/2.)*sin(c*t/2.+alpha);\n    float z=c*t+0.5*a*a*(c*t-sin(c*t))/(c*c);\n   \n    return eye+vec3(x,y,z);\n}\n\n\n\n//are you above the plane?\nbool abovePlane(vec3 pos){\n    if(pos.z>0.){return true;}\n    else{return false;}\n}\n\n//given the initial conditions AND a distance just before\n//impacting the plane, do a binary search to find the plane:\nvec3 findPlane(vec3 eye, vec3 dir, inout float dist,float stp){\n\n    //flowing dist doesnt hit the plane, dist+step does:\n    float testDist=stp;\n   \n    for(int i=0;i<8;i++){\n       \n        //divide the step size in half\n         testDist=testDist/2.;\n\n        //if you are still above the plane, add to distance.\n        if(abovePlane(flow(eye,dir,dist+testDist))){\n            dist+=testDist;\n        }\n        //if not, then don't add: divide in half and try again\n   \n    }\n   \n    return flow(eye,dir,dist);\n   \n   \n}\n   \nvec3 trace(vec3 eye, vec3 dir,inout float totalDist){\n \n    float stp=1.;\n    float dist=0.;\n   \n    vec3 endPt=eye;\n   \n//keep flowing along at fixed step size till you hit the plane.\n    for(int count=0;count<50;count++){\n     \n        dist+=stp;\n        endPt=flow(eye,dir,dist);\n        //check if you hit the plane\n        if(!abovePlane(endPt)){\n            break;}\n    }\n   \n   \n    //if you return here, that means dist is set to be right after you step past the plane:\n    dist=dist-stp;//right before you hit the plane.\n   \n    //now do binary search to find the plane.\n    endPt=findPlane(eye,dir,dist,stp);\n   \n\n    //return the point which actually lies on the plane.\n    totalDist=dist;\n    return endPt;\n}\n\n\n\n\n//======== COLORING THE PLANE ================\n//==================================================\n\n\nvec3 checkerboard(vec3 p,vec2 offset,float size){\n    float x=mod(size*p.x+offset.x,2.);\n    float y=mod(size*p.y+offset.y,2.);\n   \n    vec3 color=vec3(0.);\n   \n    //what to do if we hit the plane in the at z=0\n    if(abs(p.z)<0.5){\n    if(y<1.&&x<1.||y>1.&&x>1.)\n    {color=vec3(1.);}\n    }\n\n    return color;\n}\n\n\n\n\n//adjust the color computed at p by a fog:\nvec3 fog(vec3 p,vec3 color){\n    float r=length(p.xy);\n   \nfloat s=1./50.;\n    float fogginess=exp(-r*r*s);\n    return fogginess*color;\n}\n\n\n\n//======== SETTING UP THE VIEW ETC ================\n//==================================================\n\n\n\n//viewDir is based around looking down the z-axis: this rotates coordinates\n//so the screen center is instead facing forwardVec\nvec3 rotateView(vec2 sphCoords,vec3 dir){\n\n    float theta=sphCoords.x;\n    float phi=sphCoords.y;\n\n \n    vec3 tempDir;\n    //first, rotate up in the phi direction, fixing the x axis:\n    tempDir.x=dir.x;\n   \n    tempDir.z= cos(phi)*dir.z-sin(phi)*dir.y;\n    tempDir.y= sin(phi)*dir.z+cos(phi)*dir.y;\n   \n   \n    vec3 newDir;\n    //now rotate about the z-axis\n    newDir.z=tempDir.z;\n    newDir.x=cos(theta)*tempDir.x-sin(theta)*tempDir.y;\n    newDir.y=sin(theta)*tempDir.x+cos(theta)*tempDir.y;\n   \n    return newDir;\n}\n\n\n//mostly linear but zero deriv at beginning and end\n\nfloat smoothTransition(float x){\n    if(x<0.){return 0.;}\n    else if(x>1.){return 1.;}\n    else{\n        return 3.*x*x-2.*x*x*x;\n    }\n}\n\n\n\n\n//======== TIMING FOR THE ANIMATION ================\n//==================================================\n\n//setting time intervals:\nfloat totalTime=5.;\nfloat time1;\nfloat time2;\nfloat time3;\nfloat time4;\n\nvoid setTimes(){\n    time1=0.25*totalTime;\n    time2=0.5*totalTime;\n    time3=0.75*totalTime;\n    time4=totalTime;\n}\n\n\n\n//intial starting location of your eye (should be along z axis).\nvec3 eyePosition(float time){\n   \n    //can only move your eye up and down on the z-axis so that\n    //everything is Euc translations and the geodesics are right.\n\n    float h,x;\n   \n    float eucHeight=3.;\n    float deltaHeight=8.;\n\n   \n    time=mod(time,totalTime);\n   \n    //start at a constant height while you turn your head up\n    if(time<time1){\n        h=eucHeight;\n    }\n   \n    //then move upwards as you distort the metric, and turn your head back down\n    else if(time<time3){\n        x=(time-time1)/(time3-time1);\n        h=eucHeight+deltaHeight*pow(smoothTransition(x),4.);\n   \n    }\n\n    //then move back downwards to the origin height.\n    else{\n        x=(time-time3)/(time4-time3);\n       h=eucHeight+deltaHeight-deltaHeight*smoothTransition(x);\n    }\n   \n   \n    return vec3(0.,0.,h);\n   \n}\n\n\n\n//initial starting direction in spherical coordinates in your tangent space:\nvec2 eyeDirection(float time){\n   \n    //no rotation in the xy plane: the twisting geodesics does enough of that!\n    float theta=0.;\n    //just raise our head up and down.\n    float phi;\n   \n    time=mod(time,totalTime);\n   \n    //turn your head up\n    if(time<time1){\n        phi=-smoothTransition(time/time1)*3.14/3.;\n    }\n   \n    //lower your head as you change the metric\n    else if(time<time3){\n        float x=(time3-time)/(time3-time1);\n        phi=-3.14/3.*smoothTransition(x);\n    }\n   \n    //be looking straight down for the descent\n    else{\n    phi=0.;\n    }\n   \n \n    return vec2(theta,phi);\n}\n\n\nfloat nilify(float time){\n    //change the metric parameter between 0 and 1\n    float xi;\n\n   \n    time=mod(time,totalTime);\n   \n    if(time<time1){\n        //euclidean space (don't divide by zero!)\n        xi=0.0001;\n    }\n   \n    else if(time>time1 &&time<time2){\n        //smoothly interpolate until nil\n        xi=smoothTransition((time-time1)/(time2-time1));\n    }\n   \n    else if(time>time2&&time<time3){\n        //stay nil\n        xi=1.;\n    }\n   \n    else{\n        //smoothly interpolate back to euclidean\n        xi=smoothTransition(((time4-time)/(time4-time3)));\n    }\n   \n   \n    return xi;\n}\n\n\n\n//adjust the color computed at p by a fog:\nvec3 animateFog(vec3 p,vec3 color,float time){\n    float r=length(p.xy);\n   \n    time=mod(time,totalTime);\n    float s=(time/totalTime)*(1.-time/totalTime);\n    s=s/30.;\n   \n    float fogginess=exp(-r*r*s);\n    return fogginess*color;\n}\n\n\n\n\n//======== ANTI-ALIASING ================\n//==================================================\n\n\n//given eye position, direction and distance, get checker color\nvec3 getChecker(vec3 eye, vec3 dir, float dist){\n    float size=2.;\n    vec2 offset=vec2(0.1,0.2);\n    vec3 p=flow(eye, dir, dist);\n    return checkerboard(p,offset,size);\n}\n\n\n//set the initial direction from fragCoord\nvec3 tVector(vec2 fragCoord,float time){\n   \nvec3 dir = rayDirection(fov, iResolution.xy, fragCoord);\n    //give the initial direciton you look in as a funciton of theta/phi\n    //in the spherical coords on your tangent space.\n    vec2 eyeDir=eyeDirection(time);\n    dir=rotateView(eyeDir,dir);\n\n    return dir;\n}\n\n\n\nvec3 getColor(vec2 fragCoord,float time){\n   \n    float dist;\n   \n    //set the geometry\n    xi=nilify(time);\n   \n    //do the original tracing to get the distance:\n    vec3 eye=eyePosition(time);\n    vec3 dir=tVector(fragCoord,time);\n\n    //find the point on the plane you reach after raytracing\n    vec3 endPt=trace(eye,dir,dist);\n   \n    //offset to the checkerboard pattern to adjust\n    vec3 color=getChecker(eye,dir,dist);\n   \n    //fog is off at beginning and end, on in middle\n    color=animateFog(endPt,color,time);\n   \n  return color;\n}\n\n\n\n\n\nvec3 timeAA(vec2 fragCoord,float time,int T){\n       \n   \n    float t=float(T);//T=length of time to sample over\n    //size of a timestep (should be related to frames...)\n    //make the step size increase over the time interval = more blur at the end\n    float stp=0.000+0.002*mod(time,totalTime)/totalTime;\n\n   \n    float newTime;\n    vec3 color=vec3(0.);\n    vec3 newDir;\n    float dist;\n   \n    //set the geometry\n    xi=nilify(time);\n   \n    //do the original tracing to get the distance:\n    vec3 eye=eyePosition(time);\n    vec3 dir=tVector(fragCoord,time);\n    vec3 endPt=trace(eye,dir,dist);\n    //now distance is saved:\n\n    //now iterate over a time interval, and take the average color\n    for(int k=-T;k<T+1;k++){\n        newTime=time+stp*float(k);\n          xi=nilify(newTime);\n        eye=eyePosition(newTime);\n            newDir=tVector(fragCoord,newTime);\n            color+=getChecker(eye,newDir,dist);\n    }\n   \n    color=color/(2.*t+1.);\n   \n    color=animateFog(endPt,color,time);\n   \n  return color;\n   \n}\n\n\n\n\n//======== MAKING THE IMAGE ================\n//==================================================\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\nvec3 dir=rd;\nvec3 from=ro;\n\nfloat s=0.1,fade=1.;\nvec3 v=vec3(0.);\nfor (int r=0; r<volsteps; r++) {\nvec3 p=from+s*dir*.5;\np = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\nfloat pa,a=pa=0.;\nfor (int i=0; i<iterations; i++) {\np=abs(p)/dot(p,p)-formuparam; // the magic formula\na+=abs(length(p)-pa);\n            p.xy*=mat2(cos(iTime*0.01),sin(iTime*0.01),-sin(iTime*0.01),cos(iTime*0.01));// absolute sum of average change\npa=length(p);\n}\nfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\na*=a*a; // add contrast\nif (r>6) fade*=1.2-dm; // dark matter, don't render near\n//v+=vec3(dm,dm*.5,0.);\nv+=fade;\nv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\nfade*=distfading; // distance fading\ns+=stepsize;\n}\nv=mix(vec3(length(v)),v,saturation); //color adjust\nfragColor = vec4(v*.01,1.);\n}\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * (1.0 - h);\n}\n\nfloat GetDist(vec3 p) {\nvec4 s1 = vec4(0, 2, 6, 1);\n    vec4 s2 = vec4(0, 3, 6, 0.5);\n   \n    float sphereDist1 = length(p - s1.xyz) - s1.w;\n    float sphereDist2 = length(p - s2.xyz) - s2.w;\n    float planeDist = p.y;\n   \n    float d = smin(sphereDist1, sphereDist2, 1.2);\n    d = min(d, planeDist);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\nfloat dO = 0.0;\n   \n    for(int i = 0; i < MAX_STEPS; i++) {\n    vec3 p = ro + rd * dO;\n    \n        float dS = GetDist(p);\n        dO += dS;\n        if(dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n   \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\nfloat d = GetDist(p);\n    vec2 e = vec2(0.01, 0);\n   \n    vec3 n = d - vec3(\n        GetDist(p - e.xyy),\n        GetDist(p - e.yxy),\n        GetDist(p - e.yyx));\n \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 2);\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n   \n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    float d = RayMarch(p + n * SURF_DIST * 2.0, l);\n    if(d < length(lightPos - p)) dif *= 0.1;\n   \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//get coords and direction\nvec2 uv=fragCoord.xy/iResolution.xy-.5;\nuv.y*=iResolution.y/iResolution.x;\nvec3 dir=vec3(uv*zoom,tan(iTime*0.0001));\nfloat time=iTime*speed+.25;\n\n     setTimes();\n    fov=120.;\n      vec3 col = vec3(0);\n   \n    vec3 ro = vec3(0, 2, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n    float d2 = RayMarch(ro, rd);\n   \n    vec3 p2 = ro + rd * d2;\n   \n    float dif = GetLight(p2);\n    col = vec3(dif);\n   \n    col = pow(col, vec3(0.4545)); // gamma correction\n    vec3 color;\n\nvec4 O =fragColor;\n    vec2 C =fragCoord;\n    O=vec4(0);\n    vec3 p,q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<110.;\n        O.xyz+=mix(vec3(3),H(g*2.1),sin(2.8))*1./e/8e3\n    )\n    {\n        p=g*d;\n        p.z+=-iTime*1.5;\n       \n\n        a=50.;\n        p=mod(p-a,a*2.)-a;\n        s=4.;\n         p.xz*=mat2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime));\n            p.yx*=mat2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime));  \n        for(int i=0;i++<8;){\n            p=.23-abs(p);\n           \n            p.x<p.z?p=p.zyx:p;\n            p.z<p.y?p=p.xzy:p;\n                 p.y<p.x?p=p.xyz:p;\n            s*=e=1.4+sin(-iTime*.234)*.1;\n            p=abs(p)*e-\n                vec3(\n                    10.+cos(iTime*.3+.05*sin(iTime*.3))*0.2,\n                   100,\n                    10.+cos(iTime*.5)*5.\n                 )*col;\n               \n         }\n         g+=e=length(p.yz)/s;\n           \n    }\n\n  \ncolor=timeAA(fragCoord,iTime,5);\nvec3 from=vec3(1.,.5,0.5)*col;\nfrom+=vec3(time*2.,time,-2.);\n\n\nmainVR(fragColor, fragCoord, from, dir);\nfragColor+=O;\n   \n}\n","name":"Image","description":"","type":"image"}]}