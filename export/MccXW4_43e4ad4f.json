{"ver":"0.1","info":{"id":"MccXW4","date":"1713909535","viewed":55,"name":"Pre- vs Post- Sqrt Color Average","username":"FatalSleep","description":"Example of pre- vs post- sqrt color averaging via blurring.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["blur","color","averaging"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Example of pre- vs post- sqrt color averaging via blurring.\n    Cameras store colors as sqrt() of the actual radiance to save on memory space by reducing color precision--taking advantage of the logarithmic\n    nature of eyesight detecting changes with higher accuracy with darker color tones, but not with brighter color tones. Averaging squared radiance\n    then square-rooting back will average colors with their actual stored brightness without lost brightness precision.\n    \n    NOTE: This may be useful for any blending, blurring or averaging processes (e.g. blurs, lighting, bloom, etc.).\n*/\n\nvec3 encodeSRGB(vec3 linearRGB)\n{\n    vec3 a = 12.92 * linearRGB;\n    vec3 b = 1.055 * pow(linearRGB, vec3(1.0 / 2.4)) - 0.055;\n    vec3 c = step(vec3(0.0031308), linearRGB);\n    return mix(a, b, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float Pi = 6.28318530718; // Pi*2\n    \n    // GAUSSIAN BLUR SETTINGS {{{\n    float Directions = 32.0; // BLUR DIRECTIONS (Default 16.0 - More is better but slower)\n    float Quality = 12.0; // BLUR QUALITY (Default 4.0 - More is better but slower)\n    float Size = 128.0; // BLUR SIZE (Radius)\n    // GAUSSIAN BLUR SETTINGS }}}\n   \n    vec2 Radius = (Size/iResolution.xy);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Pixel colour\n    vec4 Color = texture(iChannel0, uv);\n    \n    // Blur calculations\n    for( float d=0.0; d<Pi; d+=Pi/Directions)\n    {\n\t\tfor(float i=1.0/Quality; i<=1.0; i+=1.0/Quality)\n        {\n\t\t\tColor += texture( iChannel0, uv+vec2(cos(d),sin(d))*Radius*i);\t\t\n        }\n    }\n    \n    //////////////////////////////////////////////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////////////////////////////////////////////\n        if (fragCoord.x < iResolution.x * 0.5) {\n            // Blur Post-SQRT\n            Color /= Quality * Directions - 31.0;\n            fragColor = vec4(encodeSRGB(Color.rgb), 1.0);\n        } else {\n            // Blur Pre-SQRT (multiply by 255.0 to maintain byte precision).\n            Color = (Color * Color) * 255.0;\n            float quality = Quality * Directions - 31.0;\n            Color /= quality;\n            Color = sqrt(Color) / 255.0;\n            fragColor = vec4(encodeSRGB(Color.rgb), 1.0);\n        }\n    //////////////////////////////////////////////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////////////////////////////////////////////\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 decodeSRGB(vec3 screenRGB)\n{\n    vec3 a = screenRGB / 12.92;\n    vec3 b = pow((screenRGB + 0.055) / 1.055, vec3(2.4));\n    vec3 c = step(vec3(0.04045), screenRGB);\n    return mix(a, b, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 red = vec4(decodeSRGB(vec3(1.0, 0.0, 0.0)), 1.0);\n    vec4 green = vec4(decodeSRGB(vec3(0.0, 1.0, 0.0)), 1.0);\n    \n    if (fragCoord.x < iResolution.x * 0.25) {\n        fragColor = red;\n    }\n    if (fragCoord.x >= iResolution.x * 0.25 && fragCoord.x < iResolution.x * 0.5) {\n        fragColor = green;\n    }\n    if (fragCoord.x >= iResolution.x * 0.5 && fragCoord.x < iResolution.x * 0.75) {\n        fragColor = green;\n    }\n    if (fragCoord.x >= iResolution.x * 0.75) {\n        fragColor = red;\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}