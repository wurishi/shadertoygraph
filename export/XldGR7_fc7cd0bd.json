{"ver":"0.1","info":{"id":"XldGR7","date":"1468585914","viewed":18581,"name":"[SH16B] valley flight","username":"Bananaft","description":"Here is my raymarching debut. Developed on GTX 960. Thanks for watching!\n\nMain inspiration (and optional soundtrack): https://www.youtube.com/watch?v=zLohrSf69ao\n\nShould look like this: https://twitter.com/Bananaft/status/754706898092425220","likes":135,"published":1,"flags":32,"usePreview":1,"tags":["terrain","clouds","motionblur","sky","canyon","sh16b","valley"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Here is my raymarching debut. Developed on GTX 960. Thanks for watching!\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    vec2 uv2 = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    float asp = iResolution.x / iResolution.y;\n    uv2.x *= asp;\n    \n    float dist = pow(max(1. - texture(iChannel0,uv).a * 0.04,0.),3.5);\n    \n    vec3 origin = vec3(0.0, 2.2 + 2. * sin(iTime), -1000.0 + iTime * 15.);\n    \n   vec3 direction;// = vec3(0.0, 0, 1.0);\n\tvec2 ml;\n    if (iMouse.x>10.)\n    {\n     \tml.x = 2.5 - iMouse.x/iResolution.x * 5.;\n        ml.y = -2.5 + iMouse.y/iResolution.y * 5.;\n    }\n   \t// camera\t\n\tvec3 ro = origin;\n\tvec3 ta = origin + vec3( sin(iTime * 0.2)+ml.x,ml.y , 2. );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tdirection = ca * normalize( vec3(uv2.xy,2.0) );\n    \n    //inverse(ca);\n    vec3 dir = direction;\n    vec2 bdir = vec2(-dir.x,dir.y);//vec2(0.75-uv.x + dir.x,uv.y*asp + dir.y);//-vec2(0.5)+uv;\n    bdir += vec2(-direction.x, direction.y);\n    bdir.x /= asp;\n    float dither = texture(iChannel1,fragCoord/4.).r;\n    \n    //bdir.y *= 1./asp;\n    vec3 color=vec3(0.);\n    const int BLUR_STEPS = 8;\n    float bs = float(BLUR_STEPS);\n    for ( int i=0; i<BLUR_STEPS; i++ )\n    {\n     \tcolor += texture(iChannel0,uv - bdir * (float(i)+2.*dither) / bs * 0.16 * dist).xyz/bs;\n    }\n    \n   // color = vec3(dist);// direction;// vec3(bdir,0.);\n    \n    \n   \n    //const int RAY_STEPS = 128;\n    //const float NEAR_CLIP = .5;\n    //const float FAR_CLIP = 100.0;\n    \n   // vec3 normal;\n   // vec3 intersection; \n    \n    \n    // Reinhard tonemapping\n    float white = 8.;\n    float L = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.g;\n    float nL = (1.0 + L / white) / (1.0 + L);;\n    //float scale = nL / L;\n    color *= nL;\n    color = pow(color,vec3( 1./2.2 ));\n    \n    fragColor = vec4(color,0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void pR(inout vec2 p,float a)\n{\n    p=cos(a)*p+sin(a)*vec2(p.y,-p.x);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n\n// 3D voronoi https://www.shadertoy.com/view/ldl3Dl\n//vec3 hash( vec3 x )\n//{\n//\treturn textureLod( iChannel0, (x.xy+vec2(3.0,1.0)*x.z+0.5)/64.0, 0. ).xyz;\n//}\n\nvec3 hash( vec3 x )\n{\n\tx = vec3( dot(x,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(x,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(x,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(x)*43758.5453123);\n}\n\nvec2 hash2d( vec2 x )\n{\n\treturn textureLod( iChannel0, (x.xy)/64.0, 0. ).xy;\n}\n\nvec3 voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\t//float id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + hash( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\t//id = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3(  res , 0.0 );//abs(id)\n}\n// Gradient noise https://www.shadertoy.com/view/XdXGW8\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash2d( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash2d( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash2d( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash2d( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nfloat heightmap(vec2 p)\n{\n \tfloat o = textureLod(iChannel1,(p)*0.0036,0.0).x;\n    return 1.-o;\n}\n\nfloat bump(vec2 p)\n{\n \tmat2 mat = mat2(vec2(-0.95765948032,-0.28790331666), vec2(0.28790331666,-0.95765948032));\n    float o = textureLod(iChannel1,(p * mat)*0.17,0.0).x;\n    return o;\n}\n\nvec4 scene(vec3 point)\n{\n \tfloat v = 1. - textureLod(iChannel1, point.xz * 0.02, 0.0).r;// voronoi(point * 0.2).x;\n    float h1 = bump(point.xz);\n    float h2 = heightmap(point.xz);\n    float valley = pow((min(abs(sin(point.z* 0.03)*0.38 + point.x * 0.08) *0.6,1.)),1.0 + v * 3.2);\n    float d = 1. + point.y + (mix(h1 * 0.3, (1.-h1) * 0.9 ,clamp(-0.3+v,0.0,1.0))) - (-3.+h2 * 8.) * valley;\n    d = min(d-v*3.2 * valley,d) ;\n   \n    \n    //d = min(d, sdSphere(p2 - vec3(10.),10.0));\n    \n    return vec4(d,v,h1,h2);\n}\n\nfloat sky(vec3 point)\n{\n    //vec3 p2;\n    //const float cldspacing = 80.;\n    //vec2 clsftuv = vec2(ceil(point.x/cldspacing)/64.,ceil(point.y/cldspacing)/64.);\n    //vec2 clsft = vec2(texture(iChannel0,clsftuv).r,texture(iChannel0,clsftuv.yx).r);\n    //p2.xz = mod(point.xz, cldspacing);\n    //p2.y = point.y - 20.;\n \t//float d = sdSphere(p2 - vec3(cldspacing/2.,0.,cldspacing/2.),15.0);   \n    \n    \n    //vec3 vrn = voronoi(point * 0.25);\n    vec3 vrn2 = voronoi(point * 0.02 + vec3(iTime * 0.05,iTime * 0.1,0.));\n    //float v3 =  voronoi(point * 0.6).x;\n    float v2 = 0.6 - vrn2.x * (1.5 - vrn2.y );\n    float v =  voronoi(point * 0.25).x;// vrn.x;// * (1.4 - vrn.y);\n    //v2 = texture(iChannel0, point.xz * 0.001 + vec2(iTime * 0.001)).r;\n    float cld = max(8. - v2 * 9.8,0.);\n    float d = sdSphere(vec3(cld,point.y - 26., cld),6.0);      \n\tv = -0.3 + v* 2.1 ;\n    d += v;// + v3 * 1.4;\n    \n    return d;\n}\n\n\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    scene(pos+eps.xyy).x - scene(pos-eps.xyy).x,\n\t    scene(pos+eps.yxy).x - scene(pos-eps.yxy).x,\n\t    scene(pos+eps.yyx).x - scene(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = scene( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    const vec3 SKY_COL = vec3(0.6,0.89,0.98);\n    const vec3 SUN_COL = vec3(1.0,0.98,0.87);\n    vec3 suncol = vec3(0.7031,0.4687,0.1055);\n    \n  \n    const int RAY_STEPS = 256;\n    const float NEAR_CLIP = .5;\n    const float FAR_CLIP = 800.0;\n    \n    const int SKY_STEPS = 96;\n    const float SKY_NEAR_CLIP = 20.;\n    \n    vec3 normal;\n    vec3 intersection; \n    vec3 origin = vec3(0.0, -0.2 + 0.3 * sin(iTime * 2.), -1000.0 + iTime * 15.);\n    vec3 direction;// = vec3(0.0, 0, 1.0);\n\tvec2 ml = vec2(0.);\n    if (iMouse.x>10.)\n    {\n     \tml.x = 2.5 - iMouse.x/iResolution.x * 5.;\n        ml.y = -2.5 + iMouse.y/iResolution.y * 5.;\n    }\n   \t// camera\t\n\tvec3 ro = origin;\n\tvec3 ta = origin + vec3( sin(iTime * 0.2)+ml.x,ml.y , 2. );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tdirection = ca * normalize( vec3(uv.xy,2.0) );\n   \n    float distance = 0.;\n    float totalDistance = NEAR_CLIP;\n    float skyDistance = SKY_NEAR_CLIP;\n    \n    float spec =0.;\n    float shadow =0.;\n    float diff = 1.;\n    float fog = 0.;\n    float amb=0.;\n    \n    vec3 lig  = normalize(vec3(-0.3,0.3,0.6));//iMouse.x/iResolution.x,iMouse.y/iResolution.y\n    vec3 texs;\n    \n\tvec3 Col = vec3(4.0);\n    for(int i =0 ;  i < RAY_STEPS; ++i) ////// Rendering main scene\n    {\n        intersection = origin + direction * totalDistance;\n        vec4 s = scene(intersection);\n        distance = s.r;\n        texs = s.gba;\n        totalDistance += distance;\n                     \n        if(distance <= 0.002 || totalDistance >= FAR_CLIP)\n        {\n            //Col = vec3(0.,1.,0.);\n            break;\n        }\n    }\n    if (totalDistance >= FAR_CLIP)\n    {\t\n     \n        //float myst = 0.0;\n        for(int i =0 ;  i < SKY_STEPS; ++i)    ////////////// Rendering clouds\n        {\n            intersection = origin + direction * skyDistance;\n            distance = sky(intersection);\n            skyDistance += distance;\n           \n\t\t\t//myst += max(1.2-distance,0.);\n            if(distance <= 0.02 || skyDistance >= FAR_CLIP)\n            {\n                //Col = vec3(0.,1.,0.);\n               break;\n            }\n        }\n        float occl = 0.0;\n        for(int i =0 ;  i < 4; ++i)\n        {\n         \tfloat d = sky(intersection + vec3(0.,-2. + 4.7 * float(i),0.));\n            occl += d * 0.067;\n        }\n        occl = clamp(occl,0.1,2.0);\n        float sunlight = 0.0;\n        \n        for(int i =0 ;  i < 4; ++i)\n        {\n         \tfloat d = sky(intersection +(1.3 * lig + lig) * 3.2 * float(i));\n            sunlight += d * 0.037;\n        }\n        sunlight = max(sunlight,0.);\n        //myst = clamp(1.0 - myst,0.,1.);\n    \tCol = vec3(0.6,0.89,0.98) * occl + SUN_COL * sunlight * 4.;// +vec3(myst);\n        fog = max((1.-(skyDistance / FAR_CLIP)), 0.);\n        //Col = vec3(myst);\n        //fog = 1.0;\n       \n    } else {\n     \t\n        float rock = clamp( texs.b * 2. - texs.g * 1. * (3.-intersection.y) * (0.3+texs.r) ,0. ,1.);\n        float nstx = texture(iChannel0, intersection.xz).r;\n        Col = mix(vec3(0.27,0.35,0.15) * (0.2 + pow(texs.g + texs.g * (-0.3 + nstx),2.2)), vec3(0.86,0.48,0.32) * (0.2 + pow(texs.g,0.6)), rock); //clamp(intersection.y,0.,1.)\n        normal = calcNormal(intersection);\n\n        diff = clamp(dot(normal , lig),0.,1.);\n        shadow = softshadow( intersection, lig, 0.02, 2.5 ) * max(2. -texture(iChannel0, intersection.xz * 0.001+vec2(iTime * 0.001)).r * 3.1,0.);\n        diff *= shadow;\n        amb = 0.24 * normal.y;\n        float dotrflct = dot(reflect( direction, normal ), lig );\n        spec = shadow * (rock + ((1.-rock) * pow(nstx,4.0) * 2.) ) * pow(clamp(dotrflct, 0.0, 1.0 ),26.0);\n        \n        float depth = ((totalDistance / FAR_CLIP));\n        fog = clamp(exp((intersection.y*0.3 - 1.3)*depth+0.24) * (1.-exp(depth*1.9-1.9)) ,0.,1.);//\n        //fog = 1.0;\n    }\n    \n   float horizon = abs(direction.y);\n   float sun = max(1.0 - (1.0 + 10.0 * lig.y + horizon) * length(direction - lig),0.0)\n        + 0.3 * pow(1.0-horizon,18.0) * (1.3-lig.y);\n    \n   vec3 chroma = vec3(mix(SKY_COL, suncol,clamp(sun,0.,1. ) * 0.85)) + vec3(0.06,0.06,0.06); \n    \n   float luma = ((0.5 + 1.0 * pow(lig.y,0.4)) * (1.5-horizon) + pow(sun, 2.2) * lig.y * (5.0 + 15.0 * lig.y));\n   \n   float exposure = 2.3;\n    \n   vec3 fogCol =  chroma * luma * exposure;\n    \n    vec3 Final = mix(fogCol,Col * diff *SUN_COL*2.0 + spec* SUN_COL * 1.6 + Col * amb * SKY_COL, fog);\n\tfragColor = vec4(Final ,totalDistance);\n    //fragColor = vec4(direction,0.);\n    //fragColor = vec4();\n}","name":"Buffer A","description":"","type":"buffer"}]}