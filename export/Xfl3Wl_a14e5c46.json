{"ver":"0.1","info":{"id":"Xfl3Wl","date":"1703681986","viewed":34,"name":"VIBaJ's Ray Marching","username":"VIBaJ","description":"Ray marching with soft shadows and diffuse lighting.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sphereSDF(float r, vec3 p) {\n    return length(p) - r;\n}\n\nfloat boxSDF(vec3 dimensions, vec3 p) {\n    vec3 v = abs(p) - dimensions / 2.0;\n    return length(max(v, 0.0)) + min(max(v.x, max(v.y, v.z)), 0.0);\n}\n\nfloat torusSDF(vec2 t, vec3 p) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat smoothmax(float a, float b, float k) {\n    return log(exp(k * a) + exp(k * b)) / k;\n}\n\nfloat smoothmin(float a, float b, float k) {\n    return -smoothmax(-a, -b, k);\n}\n\nmat2 rot2D(float angle) {\n    float sinAngle = sin(angle);\n    float cosAngle = cos(angle);\n    return mat2(cosAngle, -sinAngle, sinAngle, cosAngle);\n}\n\nvec3 rot(vec3 p, vec3 r) {\n    p.yz *= rot2D(r.x);\n    p.xz *= rot2D(r.y);\n    p.xy *= rot2D(r.z);\n    return p;\n}\n\nfloat getDist(vec3 p) {\n    vec3 a = rot(p - vec3(0.0, 0.0, 2.0), vec3(0.0, p.y * 10.0 + mod(iTime, radians(360.0)), 0.0));\n    float box = boxSDF(vec3(2.0, 2.0, 2.0), a / vec3(0.3, 2.5, 0.3)) * 0.1;\n    return box;\n}\n\nconst vec3 camPosition = vec3(0.0, 0.0, -1.0);\n\nvec3 ambientLight = vec3(0.1, 0.1, 0.1);\nvec3 light = camPosition + vec3(0.0, 1.0, 0.0);\nfloat shadowSharpness = 200.0;\n\nint steps = 200;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // normalized pixel coords from -1 to 1\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    // ray march\n    vec3 color = vec3(0.0);\n    vec3 o = camPosition;\n    vec3 p = o;\n    vec3 direction = normalize(vec3(uv, 1.0));\n    float t = 0.0;\n    int i;\n    for(i = 0; i < steps; i++) {\n        float dist = getDist(p);\n        t += dist;\n        p = o + t * direction;\n        if(dist < 0.00001) {\n            float kd = 1.0;\n            p -= 0.0001 * direction;\n            o = p;\n            vec3 lightVec = light - o;\n            float lightDist = length(lightVec);\n            direction = normalize(lightVec);\n            t = 0.0;\n            for(int j = 0; j < steps; j++) {\n                dist = getDist(p);\n                t += dist;\n                p = o + t * direction;\n                if(t > lightDist) {\n                    break;\n                } else if(dist < 0.00001) {\n                    kd = 0.0;\n                    break;\n                } else {\n                    kd = min(kd, shadowSharpness * dist / t);\n                }\n            }\n            if(kd > 0.0) {\n                vec3 vx = vec3(0.00001, 0.0, 0.0);\n                vec3 vy = vec3(0.0, 0.00001, 0.0);\n                vec3 vz = vec3(0.0, 0.0, 0.00001);\n                vec3 normal = normalize(vec3(getDist(o + vx) - getDist(o - vx),\n                                             getDist(o + vy) - getDist(o - vy),\n                                             getDist(o + vz) - getDist(o - vz)));\n                color = vec3(max(kd * dot(normal, direction), 0.0));\n            }\n            color += ambientLight;\n            break;\n        } else if(dist > 100.0) {\n            break;\n        }\n    }\n    //color = vec3(float(i) / float(steps));\n\n    // output color\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}