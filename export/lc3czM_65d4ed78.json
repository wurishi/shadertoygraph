{"ver":"0.1","info":{"id":"lc3czM","date":"1731577988","viewed":62,"name":"Bricks done right","username":"stegu","description":"The \"bricks\" pattern is an iconic example dating back to the early days of Renderman SL, but it's usually done wrong, with mapping coordinates that are discontinuous at the brick boundaries. That causes terrible aliasing on minification. This does not.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["antialiasing","bricks"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// An anti-aliased step function in the style of RSL and OSL\nfloat aastep(float threshold, float value) {\n  float afwidth = fwidth(value);  // fwidth(v) is |dFdx(v)| + |dFdy(v)|\n  return smoothstep(threshold-afwidth, threshold+afwidth, value);\n}\n\n// One of Dave Hoskins' \"sin-less\" fract hashes,\n// taken from https://www.shadertoy.com/view/4djSRW\n// \"Bad\" in a statistical sense, but adequate for this.\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (-0.5 to 0.5 for longest axis)\n    vec2 p = (fragCoord-0.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n\n    // Animated transformations to show off the anti-aliasing\n    float scale = 20.0*(2.2 + 2.0*sin(iTime*0.5));\n    float rotation = sin(iTime*0.2);\n    float co = cos(rotation);\n    float si = sin(rotation);\n    mat2 T = scale * mat2(co, -si, si, co);\n    p = T * p;\n\n    // The main pattern generation - everything else is fluff\n    float x = p.x;\n    float y = p.y;\n    float s = 2.0*abs(fract(0.5*(x+0.5*floor(2.0*y-0.5)))-0.5);\n    float t = 2.0*abs(fract(y)-0.5);\n    float bricksx = aastep(0.475, s) - aastep(0.525, s); // s is stretched\n    float bricksy = aastep(0.45, t) - aastep(0.55, t);   // 2x relative to t\n    float bricks = max(bricksx, bricksy);\n\n    // A unique pseudo-random ID for each brick\n    float xi = floor(x + floor(2.0*y+0.5)*0.5);\n    float yi = floor(2.0*y+0.5);\n    float id = hash12(vec2(xi, yi)); // Hash of the closest centerpoint of a brick\n    \n    // Use the pattern to mix a final pixel color\n    vec3 bg = (0.7 + id*0.3) * vec3(0.7,0.2,0.0); // Brick red with variation\n    vec3 fg = vec3(0.7,0.7,0.7); // Light gray\n    vec3 col = mix(bg, fg, bricks);\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}