{"ver":"0.1","info":{"id":"WtdBRj","date":"1613070047","viewed":1012,"name":"Fireworks - AT (sound)","username":"athibaul","description":"A simple, colorful fireworks shader, with sound. Make sure to reset time so that sound and image are synched.","likes":28,"published":1,"flags":8,"usePreview":0,"tags":["2d","explosion","fireworks"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 glow(vec2 p, vec2 lpos)\n{\n    vec2 q = p - lpos;\n    float atten = 1./dot(q,q);\n    //atten *= (1. + atten*1e-4); // Make the inside slightly sharper\n    return vec3(1.0) * atten;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 lastExpl = lastExplosion(iTime);\n    float t = lastExpl.x, explNum = lastExpl.y, tFadeout = lastExpl.z;\n    \n    // Fireworks base color\n    vec3 baseCol = vec3(0.5,0.5,0.5) + 0.4*sin(vec3(1.)*explNum+vec3(0.,2.1,-2.1));\n    \n    // Number of particles\n    float N_LIGHTS = 100.;\n    for(float i=0.; i<N_LIGHTS; i++)\n    {\n        \n        // Generate points uniformly on hemisphere\n        // (see Total Compendium eq. (34))\n        float f = i/N_LIGHTS;\n        float r = sqrt(1. - f*f);\n        float th = 2.*0.618033*3.14159*i; // Use Golden Ratio for a quasirandom sequence\n        float hash = sin(explNum+i*85412.243);\n        float weight = (1.-0.2*hash);\n        th += hash *3.* 6.28/N_LIGHTS;\n        // Only take x and y coordinates\n        vec2 lpos = vec2(cos(th), sin(th)) * r;\n        // Add some physics\n        lpos.xy *= (1.-exp(-3.*t/weight)) * weight; // explosion, easing out\n        lpos.y += t*0.3*weight - t*(1.-exp(-t*weight)) * 0.6 * weight; // vertical free-fall motion\n        float intensity = 2e-4;\n        intensity *= exp(-2.*t); // Fade out with time\n        intensity *= (1.-0.5*hash); // Randomize per particle\n        intensity *= (1.+10.*exp(-20.*t)); // Intensity burst at explosion\n        intensity *= clamp(3.*tFadeout, 0., 1.); // Fade out before next explosion\n        col += glow(p, lpos) * intensity * baseCol;\n    }\n    \n    \n    col = max(col, 0.);\n    //col = 1.-exp(-col); // Tone mapping\n    col = (col*(2.51*col+0.03))/(col*(2.43*col+0.59)+0.14); // Tone mapping\n    //col = col/(1.+col);\n    col = sqrt(col); // gamma correction\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define TAU (2.*3.1415926)\n#define SinOsc(f,p) sin(TAU*(f)*t+(p))\n\nfloat whistle(float time)\n{\n    vec3 lastExpl = lastExplosion(time);\n    float t = lastExpl.x, explNum = lastExpl.y, tFadeout=lastExpl.z;\n    float fmax = 3200. + rand(explNum)*200.;\n    float fmin = 3000.;\n    float whist = sin(TAU*(t*fmax - t*t/2.*(fmax-fmin)));\n    float env = smoothstep(0.,0.5,t) * smoothstep(0.,0.1,tFadeout);\n    float inten = (0.5+0.49*sin(2.62*time)) * (0.5-0.49*cos(time+explNum)) * (0.5+0.3*sin(13.*time));\n    return whist*env * inten;\n}\n\n\nfloat noise(float s){\n    // Noise is sampled at every integer s\n    // If s = t*f, the resulting signal is close to a white noise\n    // with a sharp cutoff at frequency f.\n    int si = int(floor(s));\n    float sf = fract(s);\n    sf = sf*sf*(3.-2.*sf); // smoothstep(0,1,sf)\n    return mix(rand(float(si)), rand(float(si+1)), sf)*2.-1.;\n}\n\nfloat coloredNoise(float t, float fc, float df)\n{\n    // Noise peak centered around frequency fc\n    // containing frequencies between fc-df and fc+df.\n    // Modulate df-wide noise by an fc-frequency sinusoid\n    return sin(TAU*fc*mod(t,1.))*noise(t*df);\n}\n\n\nvec2 explosion(float time)\n{\n    //float t = fract(time);\n    vec3 lastExpl = lastExplosion(time);\n    float t = lastExpl.x;\n    #if 0\n    // Use Phase Modulation synthesis to generate the waveforms\n    float v = SinOsc(0.,2.*SinOsc(1174.,2.5*SinOsc(726.,8.*SinOsc(31.2,2.41*SinOsc(37.,0.)*SinOsc(23.1,0.)))));\n    float v2 = SinOsc(0.,2.*SinOsc(972.,2.5*SinOsc(634.,8.*SinOsc(36.2,2.41*SinOsc(29.,0.)))));\n    #else\n    // Use colored noise\n    float v = coloredNoise(t,500.,800.) + 0.1*noise(8000.*t) + 0.05*noise(15000.*t);\n    float v2 = coloredNoise(t+1.,500.,800.) + 0.1*noise(8000.*(t+1.)) + 0.05*noise(15000.*(t+1.));\n    #endif\n    float env = 2.*exp(-t*20.)+0.5*exp(-t*10.) + 0.03; // Explosion envelope\n    for(float i=0.; i<3.; i++)\n    {\n        float t0 = rand(i+163.*lastExpl.y);\n        float dt = t-t0;\n        env += 0.2*exp(-10.*dt) * step(0.,dt); // Add small sub-explosions\n    }\n    vec2 res = vec2(v,v2) * env;\n    res /= 1.+abs(res.x)+abs(res.y); // Distort at high amplitudes\n    return res;\n}\n\n\nvec2 mainSound( int samp, float time )\n{\n    vec2 v = vec2(0.);\n    float th = 0.3*cos(3.*time);\n    v += 0.05*whistle(time) * vec2(1.-th, 1.+th);\n    v += 0.3*explosion(time);\n    return vec2(v);\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"\nfloat rand(vec2 co){\n    // https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n/*\nfloat rand(float v){\n    return fract(sin(12.9898*v)*43758.5453);\n}\n*/\n\nfloat rand(float p)\n{\n    // Hash function by Dave Hoskins\n    // https://www.shadertoy.com/view/4djSRW\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n\nvec3 lastExplosion(float time)\n{\n    // vec3(time since last explosion,\n    //      index of last explosion,\n    //      time until next explosion)\n    float t = mod(time, 10.);\n    float interval = floor(time/10.);\n    float t0max = 0., imax=-1.;\n    float t0next = 10.;\n    for(float i=0.; i<10.; i++)\n    {\n        float t0 = rand(vec2(interval, i)) * 10.;\n        if(t > t0 && t0 > t0max)\n        {\n            t0max = t0;\n            imax = i;\n        }\n        if(t < t0 && t0 < t0next)\n        {\n            t0next = t0;\n        }\n    }\n    return vec3(t-t0max, 10.*interval+imax, t0next-t);\n}","name":"Common","description":"","type":"common"}]}