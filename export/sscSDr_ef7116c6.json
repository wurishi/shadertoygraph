{"ver":"0.1","info":{"id":"sscSDr","date":"1632936296","viewed":160,"name":"Mcleod f(3,6), generalized","username":"DrHow","description":"2D packing generalizing f(3,6) from John Mcleod's thesis, where a Coxeter diagram is given.\nIt is too symmetric hence boring, so I modified the angles to break the vertical reflection symmetry.\nBut then, it might not be arithmetic any more.","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["2d","circlepacking"],"hasliked":0,"parentid":"7scXWn","parentname":"McLeod f(3,14)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Disclaimer:\nI know nothing about lighting and coloring (I'm colorblind).\nI copied the visual effect from Zhao Liang (twitter @neozhaoliang).\nAnd I count on the community to make these things nicer.\n*/\n\n//*****************************************************************************\n\nfloat map(vec2 p, inout int index) {\n    vec2 mouse = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    float k = 1.0;\n    if (iMouse.z > 0.0) {\n        p -= mouse;\n        k = dot(p,p);\n        p /= k;\n        p += mouse;\n    }\n    const float strong_factor = 4.;\n    return DE(p, index) * strong_factor;\n}\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 post_process(vec3 col, vec2 uv) {\n  col = pow(clamp(col, 0., 1.), vec3(1.0/2.2)); \n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *= 0.5 + 0.5*pow(19.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.7);\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    init();\n\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 p = 2. * uv - 1.;\n    p.x *= iResolution.x / iResolution.y;\n    p *= ZOOM;\n    float aa  = 2.0 / iResolution.y;\n    \n    int index, cid;\n    \n    float d = map(p, index);\n    cid = index;\n    \n    \n    float b = -0.4;\n    float t = 10.0;\n    const float lh = 2.;\n    const vec3 lp = vec3(2.5, 2.5, lh);\n    \n    vec3 ro = vec3(0, 0, t);\n    vec3 pp = vec3(p, 0);\n    \n    vec3 rd = normalize(pp - ro);\n\n    vec3 ld = normalize(lp - pp);\n    \n    float bt = -(t-b)/rd.z;\n  \n    vec3  bp   = ro + bt*rd;\n    vec3  srd = normalize(lp - bp);\n    float bl = L2(lp - bp);\n\n    float st = (0.0-b)/srd.z;\n    vec3  sp = bp + srd*st;\n\n    float bd = map(bp.xy, index);\n    float sd = map(sp.xy, index);\n\n    vec3 col = vec3(0);\n    const float ss = 15.0;\n    col       += vec3(1.)  * (1.0 - exp(-ss*(max(sd, 0.0)))) / bl;\n    float l   = length(p);\n    float hue = fract(0.25*l) + .45;\n    float sat = .9*tanh(4.*l);\n    vec3 hsv  = vec3(hue, sat, 1.0);\n    vec3 bcol = hsv2rgb(hsv);\n    \n    col       *= (1.0-clamp(tanh(0.75*l), 0., .1)) * 1.3;\n\n    col       = mix(col, vec3(1), smoothstep(-aa, aa, -d));\n    col       += 0.5*sqrt(bcol.zxy)*(exp(-(10.0+100.0*tanh(l))*max(d, 0.0)));\n    col = post_process(col, uv);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define inf              -1.\n#define MAX_ITER         50\n#define PI               3.141592653\n#define L2(x)            dot(x, x)\n#define L2XY(x, y)       dot(x - y, x - y)\n#define ZOOM             2.\n\nbvec2 displayRealBalls = bvec2(1, 1);\n\n// a1 = 3, a2 = 4, a3 = 2, a4 = 2 gives Mcleos f(3,6).\n// Vertical mirror if a3 = a4\nconst float a1 = 3.;\nconst float a2 = 4.;\nconst float a3 = 2.;\nconst float a4 = 4.;\n\n// For spheres n is the center, r is the radius\n// For planes n is the normal vector, r is the distance between the plane and the origin\n// if invert is true then the inside/outside of the sphere is interchanged (not used in this program)\n// if hasRealBall is true then this virtual ball has a real ball correspondes to it\nstruct Ball {\n    bool isplane;\n    vec2 n;\n    float r;\n    bool invert;\n    bool isRealBall;\n};\n\n// coclusters are mirror balls, they corresponde to root vectors (space-like)\nBall[3] coclusters;\n// clusters are real balls, they corresponde to space-like weight vectors\nBall[1] clusters;\n\nvec2 T;\n\nBall defaultBall() {\n    return Ball(false, vec2(0, 0), 1., false, false);\n}\n\n// Distance from a point to a ball\nfloat sdistanceToBall(vec2 p, Ball B) {\n    if (B.isplane) {\n        float k = dot(vec3(p, 1), vec3(B.n, B.r));\n        return k;\n    }\n    else {\n        float k = length(p - B.n) - B.r;\n        return k;\n    }\n}\n\nBall from_plane(vec2 n, float d) {\n    return Ball(true, n, d, false, false);\n}\n\nBall from_sphere(vec2 cen, float r) {\n    return Ball(false, cen, r, false, false);\n}\n\nvoid invertBall(inout Ball B) {\n    B.invert = !B.invert;\n}\n\nfloat dihedral(float x) {\n    return x == inf ? 1. : cos(PI / x);\n}\n\n\nvoid translate(inout vec2 p, vec2 t) {\n    p.x = mod(p.x, t.x);\n}\n\n// try to reflect a point p to the positive half space bounded by a ball\n// if we are already in the positive half space, do nothing and return true,\n// else reflect about the ball and return false\n// if B is a sphere we try to reflect p into the interior of B\nbool try_reflect(inout vec2 p, Ball B, inout float scale) {\n    if (B.isplane) {\n        float k = dot(vec3(p, 1), vec3(B.n, B.r));\n        if (k >= 0.)\n            return true;\n        p -= 2. * k  * B.n;\n        return false;\n    }\n    else {\n        vec2 cen = B.n;\n        float r = B.r;\n        vec2 q = p - cen;\n        float d2 = dot(q, q);\n        float k = (r * r) / d2;\n        if ( (k < 1. && B.invert) || (k > 1. && !B.invert) )\n            return true;\n        p = k * q + cen;\n        scale *= k;\n        return false;\n    }\n}\n\n \n// return distance to the scene, and get the index of the real ball hitted\nfloat DE(vec2 p, inout int index) {\n    Ball Bxy;\n\n    float scale = 3.;\n    for (int i = 0; i < MAX_ITER; i++) {\n        bool cond = true;\n\n        Bxy = coclusters[0];\n        cond = cond && try_reflect(p, Bxy, scale);\n        \n        translate(p, T);\n        Bxy = coclusters[1];\n        cond = cond && try_reflect(p, Bxy, scale);\n        \n        translate(p, T);        \n        Bxy.n = coclusters[1].n + T;\n        cond = cond && try_reflect(p, Bxy, scale);\n        \n        translate(p, T);\n        Bxy = coclusters[2];\n        cond = cond && try_reflect(p, Bxy, scale);\n\n        if (cond)\n            break;\n    }\n    \n    index = 0;\n\n    //float d1 = sdistanceToBall(p, clusters[0]);\n    //float d2 = sdistanceToBall(p, clusters[1]);\n    //d1 = abs(d1); d2 = abs(d2);\n    translate(p, T);\n    Bxy = clusters[0];\n    float d = sdistanceToBall(p, Bxy);\n    d=abs(d);\n    return d / scale;\n}\n\n\n\nvoid init() {   \n    Ball B0 = from_plane(vec2(0, -1.), 0.);\n    \n    Ball B1 = from_sphere(vec2(0., -1.), 1./cos(PI/a1));\n    float c2=sqrt(1./cos(PI/a1)/cos(PI/a1) + 1./cos(PI/a2)/cos(PI/a2) + 2.*cos(PI/a3)/cos(PI/a1)/cos(PI/a2));\n    Ball B2 = from_sphere(vec2(c2, -1.), 1./cos(PI/a2));\n    float c3=sqrt(1./cos(PI/a1)/cos(PI/a1) + 1./cos(PI/a2)/cos(PI/a2) + 2.*cos(PI/a4)/cos(PI/a1)/cos(PI/a2));\n    T = vec2(c2+c3,0);\n    \n    invertBall(B1);\n    invertBall(B2);\n    coclusters = Ball[3] (B0,B1,B2);\n    \n    clusters[0] = from_plane(vec2(0., -1.), -1.);\n}\n","name":"Common","description":"","type":"common"}]}