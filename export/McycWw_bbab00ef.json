{"ver":"0.1","info":{"id":"McycWw","date":"1733162201","viewed":67,"name":"2 задание Кузнецов Алексей ","username":"bloomet","description":"wefwef","likes":2,"published":3,"flags":48,"usePreview":0,"tags":["wefwef"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 rotate2d(float theta) {\n  float s = -sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float PI = 3.14159265359;\n\nstruct Surface {\n    float sd; // signed distance value\n    vec3 col; // color\n    int id; // identifier for each surface/object\n};\nSurface sdTank( vec3 p, vec3 b, vec3 offset, vec3 col)\n{\n  p = (p - offset);\n  vec3 q = abs(p) - b;\n  float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n  return Surface(d, col, 2);\n}\nSurface sdTank2( vec3 p, vec3 b, vec3 offset, vec3 tank_move, vec3 col)\n{\n  p = (p - offset - tank_move);\n  vec3 q = abs(p) - b;\n  float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n  return Surface(d, col, 2);\n}\n\nSurface sdSphere(vec3 p, vec3 a, float r, vec3 offset, vec3 tank_move, vec3 col){\n    float d = length(p - offset - a - tank_move) - r;\n    return Surface(d, col, 4);\n}\nSurface sdCapsule( vec3 p, vec3 a, float r, vec3 offset, vec3 tank_move, vec3 col)\n{\n  vec3 pa = p - offset - a - tank_move;\n  float h = clamp( dot(pa,-a)/dot(-a,-a), 0.0, 1.0 );\n  float d = length( pa - -a*h ) - r;\n  return Surface (d, col, 3);\n}\nSurface sdFloor(vec3 p, vec3 col) {\n  float d = p.y + 1.;\n  return Surface(d, col, 1);\n}\n\nSurface minWithColor(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2;\n  return obj1;\n}\nSurface maxWithColor(Surface obj1, Surface obj2){\n  if (-obj2.sd > obj1.sd) \n      {\n      Surface obj = obj2;\n      obj.sd = -obj.sd;\n      return obj;\n      }\n  return obj1; \n}\n\nSurface Tank(vec3 p, vec3 tank_move, vec3 color1, vec3 color2) { //функция танка\n  Surface tank2 = sdTank2(p, vec3(3, 0.6, 1.25), vec3(-5, 0.1, -4), tank_move, color1);\n  tank2 = minWithColor(tank2, sdTank2(p, vec3(2.3, 0.4, 1.1), vec3(-5, 0.6, -4), tank_move, color1)); \n  tank2 = minWithColor(tank2, sdTank2(p, vec3(0.8, 0.7, 1.), vec3(-5, 1.2, -4), tank_move, color1)); \n  tank2 = minWithColor(tank2, sdCapsule(p, vec3(3.2, 0., 0.), 0.2, vec3(-5, 1.5, -4), tank_move, color2)); \n  int flag2 = 0;\n  for (float j = -2.7; j >= -6.7; j--){\n      float x2 = j * 1.1; float z2; \n      if (flag2 == 0) z2 = -3.1;\n      else z2 = -5.;\n      if (j == -6.7 && flag2 == 0) {\n          flag2 = 1;\n          j = -1.7;\n      }\n      tank2 = minWithColor(tank2, sdSphere(p, vec3(0), 0.5, vec3(x2, -0.5, z2), tank_move, color2)); //vec3(1, 1, 0.5)));\n  }\n  return tank2;\n}\n\nSurface sdScene(vec3 p, vec2 offset, vec3 cannonball_offset, vec3 tank_move, float velocity, float radius) {\n  \n  Surface tank = sdTank(p, vec3(3, 0.6, 1.25), vec3(5, -0.1, -4), vec3(0.5, 0.5, 0.9));\n  tank = minWithColor(tank, sdTank(p, vec3(2.3, 0.4, 1.1), vec3(5, 0.6, -4), vec3(0.5, 0.5, 0.9)));\n  tank = minWithColor(tank, sdTank(p, vec3(0.8, 0.7, 1.), vec3(5, 1.2, -4), vec3(0.5, 0.5, 0.9)));\n  tank = minWithColor(tank, sdCapsule(p, vec3(-3.2, offset), 0.2, vec3(5, 1.5, -4), vec3(0), vec3(1, 0.5, 0.3)));\n  int flag = 0;\n  for (float i = 2.7; i<= 6.7; i++){\n      float x = i * 1.1; float z;\n      if (flag == 0) z = -3.1;\n      else z = -5.;\n      if (i == 6.7 && flag == 0) {\n          flag = 1;\n          i = 1.7;\n      }\n      tank = minWithColor(tank, sdSphere(p, vec3(0), 0.5, vec3(x, -0.5, z), vec3(0), vec3(1, 0.5, 0.3)));\n  }\n  \n  vec3 soilColor = vec3(1., 0.44, 0.);\n  vec3 grassColor = vec3(1., 1., 1.);\n  float n = texture(iChannel1, p.xz * 0.35).r;\n  vec3 floorColor = mix(soilColor, grassColor, smoothstep(0.2, 0.8, n));\n  //vec3 floorColor = vec3(.5 + 0.3*mod(floor(p.x) + floor(p.z), 2.0));\n  Surface co = sdFloor(p, floorColor);\n  Surface tank2 = Tank(p, tank_move, vec3(0.8, 0.2, 1), vec3(1, 1, 0.5)); //в tank2 лежат полностью объединенные фигуры\n  co = minWithColor (co, tank2);\n  co = minWithColor (co, tank);\n  if (velocity < 0.4) { //значит нажат пробел (ядро летит)\n      Surface cannonball = sdSphere(p, vec3(cannonball_offset), radius, vec3(1.8, 1.5, -4), vec3(0), vec3(1, 1, 0.5));\n      co = minWithColor(co, cannonball);\n      //co = maxWithColor(co, cannonball);\n  }\n  return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end, vec2 offset, vec3 cannonball_offset, vec3 tank_move, float velocity, float radius) {\n  float depth = start;\n  Surface co; // closest object\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = sdScene(p, offset, cannonball_offset, tank_move, velocity, radius);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > end) break;\n  }\n\n  co.sd = depth;\n\n  return co;\n}\n\nvec3 calcNormal(in vec3 p, vec2 offset, vec3 cannonball_offset, vec3 tank_move, float velocity, float radius) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    return normalize(\n      e.xyy * sdScene(p + e.xyy, offset, cannonball_offset, tank_move, velocity, radius).sd +\n      e.yyx * sdScene(p + e.yyx, offset, cannonball_offset, tank_move, velocity, radius).sd +\n      e.yxy * sdScene(p + e.yxy, offset, cannonball_offset, tank_move, velocity, radius).sd +\n      e.xxx * sdScene(p + e.xxx, offset, cannonball_offset, tank_move, velocity, radius).sd);\n}\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n    vec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n    vec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n    vec3 cu = normalize(cross(cd, cr)); // camera up\n\n    return mat3(-cr, cu, -cd);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.835, 1, 1);\n  \n  vec2 gun_offset = vec2(texelFetch( iChannel0, ivec2(0,0), 0 ).y, texelFetch( iChannel0, ivec2(0,0), 0 ).z);\n  vec3 cannonball_offset = vec3(texelFetch( iChannel2, ivec2(0,0), 0 ).xyz);\n  vec3 tank_move = vec3(texelFetch( iChannel3, ivec2(0,0), 0 ).x, 0., texelFetch( iChannel3, ivec2(0,0), 0 ).z);\n  float velocity = texelFetch( iChannel2, ivec2(0,0), 0 ).w;\n  float radius = texelFetch( iChannel0, ivec2(0,0), 0 ).w;\n  \n  vec3 col = vec3(0);\n  vec2 mouseUV = iMouse.xy/iResolution.xy; // Range: <0, 1>\n  vec3 lp = vec3(texelFetch( iChannel3, ivec2(0,0), 0 ).x, 0., texelFetch( iChannel3, ivec2(0,0), 0 ).z) - vec3(3.2, 0, 2.2); // lookat point (aka camera target)\n  vec3 ro = vec3(0., 4.5, 0.);\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(PI/2., 0., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  Surface co = rayMarch(ro, rd, MIN_DIST, MAX_DIST, gun_offset, cannonball_offset, tank_move, velocity, radius); // closest object\n\n  if (co.sd > MAX_DIST) {\n    col = backgroundColor; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * co.sd; // point on cube or floor we discovered from ray marching\n    vec3 normal = calcNormal(p, gun_offset, cannonball_offset, tank_move, velocity, radius);\n\n    // check material ID\n    if( co.id == 1 ) // floor\n    {\n        col = co.col;\n    } else {\n      // lighting\n      vec3 lightPosition = vec3(6, 9, 3);\n      vec3 lightDirection = normalize(lightPosition - p);\n\n      // color\n      float dif = clamp(dot(normal, lightDirection), 0.3, 1.); // diffuse reflection\n      col = dif * co.col + backgroundColor * .2; // Add a bit of background color to the diffuse color\n    }\n  }\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//вращение пушки\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst float gun_speed = 0.7;\nfloat handleKeyboardz(float offsetz) { \n\n    float left = texelFetch(iChannel0, ivec2(KEY_LEFT, 0), 0).x * 0.1;\n    float right = texelFetch(iChannel0, ivec2(KEY_RIGHT, 0), 0).x * -0.1;\n    \n    if ((offsetz + gun_speed * (left + right)) >= 1.5 || (offsetz + gun_speed * (left + right)) <= -1.5)\n        return offsetz;\n    else {\n        offsetz += gun_speed * (left + right);\n        return offsetz;\n    }\n}\nfloat handleKeyboardy(float offsety) { \n\n    float up = texelFetch(iChannel0, ivec2(KEY_UP, 0), 0).x * 0.1;\n    float down = texelFetch(iChannel0, ivec2(KEY_DOWN, 0), 0).x * -0.1;\n   \n    if ((offsety + gun_speed * (up + down)) >= 0.6 || (offsety + gun_speed * (up + down)) <= -0.4)\n        return offsety;\n    else {\n        offsety += gun_speed * (up + down);\n        return offsety;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float offsetz = texelFetch( iChannel1, ivec2(0, 0), 0).z; //лево право\n    float offsety = texelFetch( iChannel1, ivec2(0, 0), 0).y; //верх низ\n    float velocity = texelFetch( iChannel2, ivec2(0, 0), 0).w; //берем скорость ядра\n    float cannonball_radius = texelFetch( iChannel1, ivec2(0, 0), 0).w; //используем для изменения размера ядра\n    \n    if (iFrame != 0) {\n        offsetz = handleKeyboardz(offsetz);\n        offsety = handleKeyboardy(offsety);\n    }\n    else {\n        offsetz = 0.;\n        offsety = 0.;\n        cannonball_radius = 0.2;\n    }\n    \n    \n    \n    fragColor = vec4(0, offsety, offsetz, cannonball_radius);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//выстрел ядра\nconst int KEY_SPACE = 32;\nvec3 shot(vec3 offset, vec3 gun_offset, float velocity) {\n    offset.x -= 0.4;\n    if (gun_offset.y < 0.)\n        offset.y += (gun_offset.y * 0.4)/2.;\n    else if (gun_offset.y == 0.)\n        offset.y -= 0.04;\n    else\n        offset.y += (gun_offset.y * velocity);\n    offset.z += (gun_offset.z * 0.4)/ 3.;\n    if (offset.x < -20. || offset.z > 5. || offset.z < -5. || offset.y < -1. || offset. y > 5. || offset.x > 10.) \n        return gun_offset;\n    return offset;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 offset = texelFetch( iChannel1, ivec2(0, 0), 0).xyz; // смещение ядра\n    float velocity = texelFetch( iChannel1, ivec2(0, 0), 0).w;\n    vec3 gun_offset = vec3(0., texelFetch( iChannel2, ivec2(0,0), 0 ).y, texelFetch( iChannel2, ivec2(0,0), 0 ).z);\n    if (texelFetch(iChannel0, ivec2(KEY_SPACE, 0), 0).x == 1.0 || (velocity < 0.4)) {\n        velocity += -9.8 * iTimeDelta * 0.5;\n        offset = shot(offset, gun_offset, velocity);\n        if (offset == gun_offset) velocity = 0.4;\n    }\n    else {\n        offset = gun_offset;\n    }\n    if (iFrame == 0){\n        velocity = 0.4;\n        offset = gun_offset;\n    }\n    fragColor = vec4(offset, velocity);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//Перемещение танка 2 (фиолетовый)\nconst int KEY_LEFT  = 65;\nconst int KEY_UP = 87;\nconst int KEY_DOWN = 83;\nconst int KEY_RIGHT = 68;\nconst float tank_speed = 1.;\nfloat handleKeyboardz(float offsetz) { \n\n    float left = texelFetch(iChannel0, ivec2(KEY_LEFT, 0), 0).x * -0.1;\n    float right = texelFetch(iChannel0, ivec2(KEY_RIGHT, 0), 0).x * 0.1;\n\n    offsetz += tank_speed * (left + right);\n    return offsetz;\n}\nfloat handleKeyboardx(float offsetx) {\n\n    float up = texelFetch(iChannel0, ivec2(KEY_UP, 0), 0).x * 0.1;\n    float down = texelFetch(iChannel0, ivec2(KEY_DOWN, 0), 0).x * -0.1;\n    \n    offsetx += tank_speed * (up + down);\n    return offsetx;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float offsetx = texelFetch( iChannel1, ivec2(0, 0), 0).x; //лево право\n    float offsetz = texelFetch( iChannel1, ivec2(0, 0), 0).z; //верх низ\n    \n    if (iFrame != 0) {\n        offsetz = handleKeyboardz(offsetz);\n        offsetx = handleKeyboardx(offsetx);\n    }\n    else {\n        offsetz = 0.;\n        offsetx = 0.;\n    }\n    fragColor = vec4(offsetx, 0, offsetz, 0);\n}","name":"Buffer C","description":"","type":"buffer"}]}