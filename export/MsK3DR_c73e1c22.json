{"ver":"0.1","info":{"id":"MsK3DR","date":"1454081145","viewed":460,"name":"Fractal city_242","username":"rebb","description":"Based on fragmentarium port of http://www.creativeapplications.net/javascript-2/the-imaginary-kingdom-of-aurullia/","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["fractal","city","fragmentarium"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"const float PI=3.14159265358979323846;\nvec3 fo =vec3 (0.0961,1.28528,0.74286);\nvec3 gh = vec3 (0.4273,0.62314,0.5638);\nvec3 gw = vec3 (0.0,0.0,0.0);\nvec4 X = vec4( 0.5,0.6,0.6,-0.22968);\nvec3 BaseColor = vec3(.623529,0.623529,0.623529);\nvec4 Y = vec4(1,0.6,0,0.44876);\nvec4 Z = vec4(0.8,0.78,1,0.15902);\nvec4 R = vec4(0.4,0.7,1,0.08464);\nvec3 orbitColor;\n\nint Iterations=12;\nfloat Scale = 3.22996;\nfloat MinRad2 = 0.112585;\nvec4 orbitTrap = vec4(40000.0);\nfloat r = .1;\nfloat sr = 30.0;\nmat3 rot;\nfloat Power =6.0;\nvec2 moro = vec2 (1.31,1.6);\nfloat marched = 0.0;\n\nfloat min_distance = 1.0;\nfloat max_distance = 63.2;\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nvec2 rotate(vec2 k,float t)\n\t{\n\treturn vec2(cos(t)*k.x-sin(t)*k.y,sin(t)*k.x+cos(t)*k.y);\n\t}\n\n//DarkBeam's \"fold\"... reinterpreted... it's more than a fold, much more! Just awesome!\nfloat DBFold(vec3 p, float fo, float g, float w){\n\tif(p.z>p.y) p.yz=p.zy;\n\tfloat vx=p.x-2.*fo;\n\tfloat vy=p.y-4.*fo;\n \tfloat v=max(abs(vx+fo)-fo,vy);\n\tfloat v1=max(vx-g,p.y-w);\n\tv=min(v,v1);\n\tv1=max(v1,-abs(p.x));\n\treturn min(v,p.x);\n}\n//the coordinates are pushed/pulled in parallel\nvec3 DBFoldParallel(vec3 p, vec3 fo, vec3 g, vec3 w){\n\tvec3 p1=p;\n\tp.x=DBFold(p1,fo.x,g.x,w.x);\n\tp.y=DBFold(p1.yzx,fo.y,g.y,w.y);\n\tp.z=DBFold(p1.zxy,fo.z,g.z,w.z);\n\treturn p;\n}\n//serial version\nvec3 DBFoldSerial(vec3 p, vec3 fo, vec3 g,vec3 w){\n\tp.x=DBFold(p,fo.x,g.x,w.x);\n\tp.y=DBFold(p.yzx,fo.y,g.y,w.y);\n\tp.z=DBFold(p.zxy,fo.z,g.z,w.z);\n\treturn p;\n}\nfloat DE(vec3 p)\n{\n\tvec4 JC=vec4(p,1.);\n\tfloat r2=dot(p,p);\n\tfloat dd = 1.;\n\tfor(int i = 0; i<12 ; i++){\n\t\t\n\t\tp = p - clamp(p.xyz, -1.0, 1.0) * 2.0;  // mandelbox's box fold\n\n\t\t//Apply pull transformation\n\t\tvec3 signs=sign(p);//Save \tthe original signs\n\t\tp=abs(p);\n\t\tp=DBFoldParallel(p,fo,gh,gw);\n\t\t\n\t\tp*=signs;//resore signs: this way the mandelbrot set won't extend in negative directions\n\t\t\n\t\t//Sphere fold\n\t\tr2=dot(p,p);\n\t\tfloat  t = clamp(1./r2, 1., 1./MinRad2);\n\t\tp*=t; dd*=t;\n\t\t\n\t\t//Scale and shift\n\t\tp=p*Scale+JC.xyz; dd=dd*Scale+JC.w;\n\t\tp=vec3(1.0,1.0,.92)*p;\n\t\n\t\t//For coloring and bailout\n\t\tr2=dot(p,p);\n\t\torbitTrap = min(orbitTrap, abs(vec4(p.x,p.y,p.z,r2)));\t\n\t}\n\tdd=abs(dd);\n#if 1\n\treturn (sqrt(r2)-sr)/dd;//bounding volume is a sphere\n#else\n\tp=abs(p); return (max(p.x,max(p.y,p.z))-sr)/dd;//bounding volume is a cube\n#endif\n}\n\nfloat opRep( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return DE( q );\n}\nvec3 cpath( float t )\n{\n\tvec3 pos = vec3( 0.0, 0.0, 95.0 + t );\n\t\n\tfloat a = smoothstep(5.0,20.0,t);\n\tpos.xz += a*150.0 * cos( vec2(1.0,6.0) + 1.0*0.01*t );\n\tpos.xz -= a*150.0 * cos( vec2(5.0,6.0) );\n\tpos.xz += a* 50.0 * cos( vec2(0.0,3.5) + 6.0*0.01*t );\n\tpos.xz -= a* 50.0 * cos( vec2(0.0,3.5) );\n\n\treturn pos;\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nfloat rm(vec3 origin, vec3 ray) {\n   \n\tfloat distance_marched = min_distance;\n\n\tfor (int i=0; i<250; i++) {\n\t\t\n\t\tfloat step_distance = DE(origin + ray*distance_marched);\n\t\tif (abs(step_distance) < 0.001 ) {\n\t\t\treturn distance_marched/(max_distance-min_distance);\n\t\t}\n\t\tdistance_marched += step_distance;\n\t\tmarched = distance_marched;\n\t\tif (distance_marched > max_distance) {\n\t\t\treturn -1.0;\n\t\t}\n\t}\n\treturn -1.0;\n}\n\nvec3 render(vec2 q) {\n    orbitTrap.w = sqrt(orbitTrap.w);\n\t\n    \n    vec2 mouse = (iMouse.xy / iResolution.xy) * 8.0 ;\n\tvec3 eye = vec3(vec2(-5.0,5.5),-8.0);\n\tvec3 screen = vec3(q,6.222+sin(iTime)*.8);\n\t\n\tvec3 ray = normalize (screen-eye);\n    mat3 rot = rotationXY(moro);\n\tfloat s = rm(rot*eye,rot*ray);\n    \n\torbitColor = X.xyz*X.w*orbitTrap.x +\n\t\tY.xyz*Y.w*orbitTrap.y +\n\t\tZ.xyz*Z.w*orbitTrap.z +\n\t\tR.xyz*R.w*orbitTrap.w;\n\t\n\tvec3 color = mix(BaseColor,.79*orbitColor, 0.3743);\n\t//color += vec3(s-.43*.8+0.4*q.y *sin(q.x))*marched/5.26;\n    return color;\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = (6.0*fragCoord.xy-iResolution.xy)/iResolution.x;\n\t\n\tvec3 col = render(q);\n\t\t\n  //vec3 col2 = texture( iChannel0,q ).xyz;\n  fragColor = vec4(col,1.0); \t\n\t//fragColor = vec4(col.xyz+col2, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}