{"ver":"0.1","info":{"id":"dl3yWl","date":"1699804918","viewed":50,"name":"colorful rains of cubes","username":"nayk","description":" tiling, tesselation, alternating, domino","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["colorful","cubes","shader","tiling","tesselation","alternating","domino"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* original https://www.shadertoy.com/view/DlcyWs*/\nvec2 rotate(vec2 v, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec2(v.x * c - v.y * s, v.x * s + v.y * c);\n}\n\nvec3 hash32(vec2 p) // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 alternating_domino_tiling(int n, vec2 p) // https://www.shadertoy.com/view/DlcyWs alternating domino tiling by jt\n{\n    ivec2 q = ivec2(floor(p*float(n))); // quantisize to squares \n    bool flip = (q.x&1)!=(q.y&1); // alternate in checkerboard pattern\n    q = ivec2(floor(p*float(n)*cos(iTime*1.)*(flip ? vec2(1, 2) : vec2(2, 1)))); // (re-)quantisize to dominos\n    return hash32(vec2(q)/*+floor(iTime)*/); // apply random color\n    //return vec3(q&ivec2(1),!flip); // non-random colors\n}\n\nvoid mainImage(out vec4 o, in vec2 I)\n{\n    vec2 R = iResolution.xy;\n    vec2 I2 = I;\n    I = (2. * I - R) / R.y;\n    \n    \n    vec4 O = o;\n    \n   \n     O *= 0.;\n    vec2 r = iResolution.xy;\n    for(float i,t=iTime;\n        i<t/.1;\n        O+=(cos(i+vec4(6,1,2,3))+1.)*r.y/2e2/pow(t,.6)/\n        length(I2+.4*r*abs(mod((t/.1-i++)/vec2(9.03,7),4.)-2.)-r*.9));\n    O*=O;\n     I.xy=rotate(I,iTime/1.-length(I)*(iTime*0.01));\n    vec3 color =\n        all(lessThan(abs(I), vec2(2.1))) ?\n        alternating_domino_tiling(15, I.xy) :\n        vec3(0);\n\n    o = vec4(color*O.xyz, 1);\n \n}\n","name":"Image","description":"","type":"image"}]}