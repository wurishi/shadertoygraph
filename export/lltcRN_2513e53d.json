{"ver":"0.1","info":{"id":"lltcRN","date":"1531917530","viewed":3023,"name":"2d gi","username":"toocanzs","description":"A 2D GI shader I had unlisted for a while. Now it's public\n\nRead my first comment for a description of each of the buffers, since for some reason I can't type a long enough message in the description here.","likes":21,"published":1,"flags":32,"usePreview":0,"tags":["2d","global","illumination"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 Linear2sRGB(vec3 color){\n    vec3 x = color * 12.92;\n    vec3 y = 1.055 * pow(clamp(color,0.,1.),vec3(0.4166667)) - 0.055;\n    vec3 clr = color;\n    clr.r = (color.r < 0.0031308) ? x.r : y.r;\n    clr.g = (color.g < 0.0031308) ? x.g : y.g;\n    clr.b = (color.b < 0.0031308) ? x.b : y.b;\n    return clr;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(Linear2sRGB(texture(iChannel0, uv).rgb),1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define USE_HASH 0\n#define EPSILON 0.5/iResolution.x\n#define PI 3.141596\n\nfloat tau = 6.283185307179586;\nfloat hash(float p) { return fract(sin(p) * 43758.5453123);}\n\n//#define WEIGHTED 1\n\nfloat sdSphere( vec2 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec2 p, vec2 b )\n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nstruct Material{\n\tfloat emission;\n    vec3 color;\n};\nMaterial surfaces[10];\n\nvoid setupSurfaces()\n{\n    surfaces[0] = Material(0., vec3(1.,1.,0));\n    surfaces[1] = Material(0., vec3(1.,0.,0.));\n    surfaces[2] = Material(0., vec3(1.,0.,0.));\n    surfaces[3] = Material(0., vec3(1.,0.,1.));\n    surfaces[4] = Material(4., vec3(1.,1.,1.));\n    surfaces[5] = Material(0., vec3(1.,0.,0.));\n    surfaces[6] = Material(0., vec3(0.,0.,1.));\n    surfaces[7] = Material(0., vec3(0.,1.,0.));\n    surfaces[8] = Material(0., vec3(0.,1.,0.));\n    surfaces[9] = Material(4., vec3(1.,1.,1.));\n}\n\n#define lightTime iTime * 0.6\n#define LIGHT_DIST sdSphere(uv - vec2(sin(lightTime),cos(lightTime)*(sin(lightTime*1.2123341) + 1.)*0.5), 0.1)\n#define LIGHT_DIST2 sdSphere(uv - vec2(sin(lightTime*1.9774531434 + 12.5662),cos(lightTime*.99632)*(sin(lightTime*1.91258823341) + 1.)*0.5), 0.1)\n//#define LIGHT_DIST sdSphere(uv, 0.1)\n#define BOX1 sdBox(uv - vec2(1.2,0), vec2(0.05,0.4))\n#define BOX2 sdBox(uv - vec2(0.,0.4), vec2(0.9,0.05))\n#define BOX3 sdBox(uv - vec2(0.,-0.5), vec2(1.2,0.03))\n#define BOX4 sdSphere(uv - vec2(-0.9,-0.1), 0.1)\n#define BOX5 sdBox(uv - vec2(1.75,-0.3), vec2(0.05,1.3))\n#define BOX6 sdBox(uv - vec2(0,1), vec2(1.7,0.05))\n#define BOX7 sdBox(uv - vec2(0,-1), vec2(1.7,0.05))\n#define BOX8 sdBox(uv - vec2(-1.75,-0.3), vec2(0.05,1.3))\n\nMaterial getMaterial(vec2 uv)\n{\n    float test = EPSILON;\n    vec2 st = uv;\n    st.x *= iResolution.y / iResolution.x;\n    if(BOX1 < test)\n    {\n        return surfaces[0];\n    }\n    else if(BOX2 < test)\n    {\n        return surfaces[1];\n    }\n    else if(BOX3 < test)\n    {\n        return surfaces[2];\n    }\n    else if(BOX4 < test)\n    {\n        return surfaces[3];\n    }\n    else if(LIGHT_DIST < test)\n    {\n        return surfaces[4];\n    }\n    else if(BOX5 < test)\n    {\n        return surfaces[5];\n    }\n    else if(BOX6 < test)\n    {\n        return surfaces[6];\n    }\n    else if(BOX7 < test)\n    {\n        return surfaces[7];\n    }\n    else if(BOX8 < test)\n    {\n        return surfaces[8];\n    }\n    else if(LIGHT_DIST2 < test)\n    {\n        return surfaces[9];\n    }\n    else\n    {\n    \treturn Material(0., vec3(1.));\n    }\n}\nfloat map(vec2 uv)\n{\n    float d = BOX1;\n    d = min(d,BOX2);\n    d = min(d,BOX3);\n    d = min(d,BOX4);\n    d = min(d,BOX5);\n    d = min(d,BOX6);\n    d = min(d,BOX7);\n    d = min(d,BOX8);\n    d = min(d,LIGHT_DIST);\n    d = min(d,LIGHT_DIST2);\n    return d;\n}\n\nfloat getEmissionFromBuffer(vec2 st)\n{\n    vec2 pix = 1./iResolution.xy;\n    st = (st * iResolution.xy + 0.5)/iResolution.xy;\n    float e = max(texture(iChannel0, (st) + pix * vec2(-1,1)).a,0.);\n    e = max(max(texture(iChannel0, (st) + pix * vec2(0,1)).a,0.),e);\n    e = max(max(texture(iChannel0, (st) + pix * vec2(1,1)).a,0.),e);\n    e = max(max(texture(iChannel0, (st) + pix * vec2(-1,0)).a,0.),e);\n    e = max(max(texture(iChannel0, (st) + pix * vec2(0,0)).a,0.),e);\n    e = max(max(texture(iChannel0, (st) + pix * vec2(1,0)).a,0.),e);\n    e = max(max(texture(iChannel0, (st) + pix * vec2(-1,-1)).a,0.),e);\n    e = max(max(texture(iChannel0, (st) + pix * vec2(0,-1)).a,0.),e);\n    e = max(max(texture(iChannel0, (st) + pix * vec2(1,-1)).a,0.),e);\n    return e;\n}\n\n\n\nbool trace(vec2 origin, vec2 ray, out vec2 hitPos, out float d)\n{\n    float t = 0.;\n    float dist;\n    vec2 samplePoint;\n    for(int i = 0; i < 32; i++)\n    {\n        samplePoint = origin + ray * t;\n        dist = map(samplePoint);\n        t += dist;\n        d = t;\n        if(dist < EPSILON)\n        {\n            \n            hitPos = samplePoint;\n            return true;\n        }\n    }\n    return false;\n}\n\nvec2 estimateNormal(vec2 p) \n{\n    return normalize(vec2(\n        map(vec2(p.x + EPSILON, p.y)) - map(vec2(p.x - EPSILON, p.y)),\n        map(vec2(p.x, p.y + EPSILON)) - map(vec2(p.x, p.y - EPSILON))\n    ));\n}\n\nfloat rand(vec2 p)\n{\n    return fract(sin(dot(p.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    setupSurfaces();\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 originalUv = uv;\n    uv = uv * 2.0 - 1.0;\n    float aspect = iResolution.x / iResolution.y;\n    float invAspect = iResolution.y / iResolution.x;\n    uv.x *= aspect;\n    \n    vec3 col = vec3(0.);\n    float emis = 0.;\n    \n    for(float i = 0.; i < RAYS_PER_PIXEL; i++)\n    {\n        vec2 hitPos;\n        float dist;\n        float curAngle = fract(texture(iChannel2, originalUv).r + i * phi) * tau;\n        vec2 randDirection = vec2(cos(curAngle),sin(curAngle));\n        bool hit = trace(uv, randDirection, hitPos, dist);\n        if(hit)\n        {\n            Material mat = getMaterial(hitPos);\n            float d = max(dist,0.);\n            vec2 st = hitPos;\n            st.x *=  invAspect;\n            st = (st + 1.0)*0.5;\n            \n            float lastEmission = 0.;\n            if(mat.emission <= EPSILON)\n            {\n                \n            \tlastEmission = getEmissionFromBuffer(st);\n                #ifdef WEIGHTED\n                vec2 normal = estimateNormal(hitPos);\n            \tfloat c = clamp(dot(-randDirection,normal),0.,1.);\n                lastEmission *= c;\n                #endif\n            }\n            if( iFrame==0 || d < EPSILON) lastEmission = 0.0;\n            \n            float emission = mat.emission + lastEmission;\n            emis += emission*0.6;\n            col += (mat.emission + lastEmission)*mat.color;\n        }\n    }\n    col /= RAYS_PER_PIXEL;\n    emis /= RAYS_PER_PIXEL;\n    \n    vec2 st = fragCoord/iResolution.xy;\n    vec3 oldCol  = texture(iChannel0, st).rgb;\n    vec3 newCol = col;\n    \n    if(iFrame==0) oldCol = vec3(0.0);\n\n    float hysterisis = 0.9;\n    fragColor = vec4(mix(newCol, oldCol, hysterisis), emis );\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// A buffer containing multiples of the golden ratio used for random directions per pixel\n// Note that we could just do fract(N * phi) where N is based on the frame number, but once N gets large we hit \n// https://blog.demofox.org/2017/10/31/animating-noise-for-integration-over-time/\n\n//hash from https://www.shadertoy.com/view/4ssXzX\nfloat pi = 3.14159265359;\nfloat bbsm = 1739.;\nvec2 bbsopt(in vec2 a){\n\treturn fract(a*a*(1./bbsm))*bbsm;\n}\nvec2 mod1024(in vec2 a){\n\treturn fract(a*(1./1024.))*1024.;\t\n}\nvec4 hash(in vec2 pos){\n\tvec2 a0 = mod1024(pos*pi);\n\tvec2 a1 = bbsopt(a0);\n\tvec2 a2 = a1.yx + bbsopt(a1);\n\tvec2 a3 = a2.yx + bbsopt(a2);\n\treturn fract((a2.xyxy + a3.xxyy + a1.xyyx)*(1./bbsm));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 init = hash(fragCoord);\n    fragColor = fract(texture(iChannel0,uv) + RAYS_PER_PIXEL/phi);\n    \n    //Check if resolution changed and reinit if it did\n    vec2 oldRes = texture(iChannel1, vec2(0)).xy;\n    if(oldRes != iResolution.xy)\n        fragColor = init;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//Keep track of old resolution to detect fullscreening\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(iResolution.xy,1.0,1.0);\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float RAYS_PER_PIXEL = 16.;\nconst float phi = 1.6180339887498948482045868343656381177203091798058;","name":"Common","description":"","type":"common"}]}