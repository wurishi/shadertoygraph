{"ver":"0.1","info":{"id":"l3tGWX","date":"1717161994","viewed":121,"name":"Raytracing 3 DJ","username":"DjBlueBear","description":"A Simple ray-tracing engine using ray-marching to find the intersection of rays and objects\n change the movement variable off to get a better quality image","likes":3,"published":3,"flags":32,"usePreview":0,"tags":["raytracing","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float frames = float(iFrame);\n\n    vec3 buffer = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n    \n    vec3 col = buffer;\n\n    if(!movement)\n        col /= frames;\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float pi = 3.14159265;\n\nconst float Deg2Rad = pi / 180.0;\n\n//Random Functions vvvvvv\n\nuint hash(inout uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\nfloat rand(inout uint seed)\n{\n    return fract(float(hash(seed))/ 4294967296.0);//4294967296 2 ^ 32 / 32 bit unsigned integer limit\n}\n\nfloat randNorm(inout uint seed)\n{   \n    float theta = 2.0 * pi * rand(seed);\n    float rho = sqrt( -2.0 * log(rand(seed)));\n    return rho * cos(theta);\n}\n\nvec3 randVec3(inout uint seed)\n{\n    float rand0 = rand(seed);\n    float rand1 = rand(seed);\n    float rand2 = rand(seed);\n\n    return vec3(rand0, rand1, rand2);\n}\n\nvec3 randVec3Norm(inout uint seed)\n{\n    float rand0 = randNorm(seed);\n    float rand1 = randNorm(seed);\n    float rand2 = randNorm(seed);\n\n    return normalize(vec3(rand0, rand1, rand2));\n}\n\nvec3 randAlongAxis(in vec3 axis, inout uint seed)\n{\n    vec3 value = randVec3Norm(seed);\n\n    value *= sign(dot(axis, value));\n\n    return value;\n}\n\n//Random Functions^^^^^^\n\n//SDFs vvvvvv all SDFs (Signed Distance Functions) come from Inigo Quilez at iquilezles.org\n\nfloat sdSphere(in vec3 p, in vec3 c, in float r)\n{\n    vec3 q = p - c;\n    return length(q) - r;\n}\n\nfloat sdBox(in vec3 p, in vec3 c,in vec3 b )\n{\n  vec3 q = abs(p - c) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus(in vec3 p, in vec3 c, in vec2 t )\n{\n  p -= c;\n\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n\n  return length(q)-t.y;\n}\n\n//SDFs ^^^^^^ all SDFs (Signed Distance Functions) come from Inigo Quilez at iquilezles.org\n\nfloat sdObject(in vec3 p, in object obj)\n{\n    if(obj.shape == 0)\n    {\n        return sdSphere(p, obj.position, obj.scale.x);\n    }\n    else if(obj.shape == 1)\n    {\n        return sdBox(p, obj.position, obj.scale);\n    }\n    else if(obj.shape == 2)\n    {\n        return sdTorus(p, obj.position, obj.scale.xy);\n    }\n    return 100000.0;\n}\n\nvec3 mapSky(in vec3 d)\n{\n    return texture(iChannel1, d).xyz * sky_intensity;\n}\n\nbool inBoundingBox(in vec3 p, in object obj)\n{\n    vec3 boxP = vec3(0.0);\n    vec3 boxM = vec3(0.0);\n    \n    if(obj.shape == 0)//sphere\n    {\n        vec3 offset = vec3(obj.scale.x + 0.1);\n        boxP = obj.position + offset;\n        boxM = obj.position - offset;\n    }\n    else if(obj.shape == 1)//box\n    {\n        vec3 offset = obj.scale + 0.1;\n        boxP = obj.position + offset;\n        boxM = obj.position - offset;\n    }\n    else if(obj.shape == 2)//tourus\n    {\n        float foo = obj.scale.x + obj.scale.y;\n        vec3 offset = vec3(foo, obj.scale.y, foo) + vec3(0.1);\n        boxP = obj.position + offset;\n        boxM = obj.position - offset;\n    }\n    \n    bool x = p.x < boxP.x && p.x > boxM.x;\n    bool y = p.y < boxP.y && p.y > boxM.y;\n    bool z = p.z < boxP.z && p.z > boxM.z;\n    \n    return x && y && z;\n}\n\nobject mapObject( in vec3 p)\n{\n    object obj;\n    float dist = 100000.0;\n    for(int i = 0; i < objectList.length(); i++)\n    {\n        object current = objectList[i];\n        \n        if(!inBoundingBox(p, current))\n        {\n            continue;\n        }\n        \n        float obj_dist = sdObject(p, current);\n\n        if(obj_dist < dist)\n        {\n            dist = obj_dist;\n            obj = current;\n        }\n    }\n    return obj;\n}\n\nfloat mapWorld(in vec3 p)\n{\n    float dist = 100000.0;\n    for(int i = 0; i < objectList.length(); i++)\n    {\n        float obj_dist = sdObject(p, objectList[i]);\n\n        if(obj_dist < dist)\n        {\n            dist = obj_dist;\n        }\n    }\n    return dist;\n}\n\nvec3 calcNormal(in vec3 p)\n{\n  const vec3 small_step = vec3(0.00001, 0.0, 0.0);\n  \n  float grad_x = mapWorld(p + small_step.xyy) - mapWorld(p - small_step.xyy);\n  float grad_y = mapWorld(p + small_step.yxy) - mapWorld(p - small_step.yxy);\n  float grad_z = mapWorld(p + small_step.yyx) - mapWorld(p - small_step.yyx);\n\n  vec3 normal = vec3(grad_x, grad_y, grad_z);\n\n  return normalize(normal);\n}\n\nvec3 raymarch( in vec3 ray_origin, in vec3 ray_dir, inout bool hit)\n{\n    const int steps = 256;\n    const float min_dist = 0.001;\n    const float max_dist = 1000.0;\n    float dist_traveled = 0.1;\n    vec3 position;\n\n    for(int i = 0; i < steps; i++)\n    {\n        vec3 position = ray_origin + normalize(ray_dir) * dist_traveled;\n\n        float dist = mapWorld(position);\n\n        if(dist < min_dist)\n        {\n            hit = true;\n\n            return position;\n        }\n        else if(dist > max_dist)\n        {\n                break;\n        }\n        dist_traveled += dist;\n    }\n    hit = false;\n\n    return position;\n}\n\nvec3 raytrace( in vec3 ray_origin, in vec3 ray_dir, inout uint seed)\n{\n    vec3 color = vec3(1.0);\n    vec3 light = vec3(0.0);\n\n    vec3 position = ray_origin;\n    vec3 direction = normalize(ray_dir);\n\n    for(int i = 0; i < reflections; i++)\n    {\n        bool hit = false;\n\n        vec3 hit_pos = raymarch(position, direction, hit);\n        \n        if(hit)\n        {\n            object obj = mapObject(hit_pos);\n\n            light += obj.emission * color;\n\n            vec3 normal = calcNormal(hit_pos);\n\n            vec3 specular = reflect(direction, normal);\n\n            vec3 diffuse = normalize(normal + randAlongAxis(normal, seed));\n            \n            if(rand(seed) > obj.glossy)\n            {\n                direction = mix(diffuse, specular, obj.smoothness);\n\n                color *= obj.color;\n            }\n            else\n            {\n                direction = specular;\n                    \n                color *= obj.coat_color;\n            }\n            position = hit_pos;\n        }\n        else\n        {\n                light += mapSky(direction + randVec3(seed) * background_blur) * color;\n                break;\n        }\n    }\n    return light;\n}\n\nvec3 eulerToForward(in vec3 euler)//X yaw / Y Pitch / Z Roll (discarded)\n{\n    float x = sin(euler.x);\n    float y = -(sin(euler.y) * cos(euler.x));\n    float z = -(cos(euler.y) * cos(euler.x));\n\n    return normalize(vec3(x,y,z));\n}\nvec3 camera( in vec2 uv, in vec2 mouse)\n{\n    float aspect = iResolution.x / iResolution.y;\n    vec3 forward = eulerToForward(vec3(mouse.x * -2.0 * pi, mouse.y, 0.0));//change later to work properly for camerea movement\n    vec3 up = vec3(0.0,1.0,0.0);\n    vec3 right = cross(up, forward);\n\n    vec3 dir = right * uv.x + up * uv.y + forward * (180.0 / FOV - 1.0);\n\n    return normalize(dir);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame < 1)\n    {\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n        return;\n    }\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec2 mouseUV = vec2(0.5);\n    \n    if(movement)\n        mouseUV = iMouse.xy / iResolution.xy - vec2(0.0,0.5);\n    \n    float modFrame = 2.0 + mod(float(iFrame), 500.0);//if the seed goes over 4294967296 (32 bit unsigned integer limit)\n    //all calls of the rand function will return undefined because the seed will overflow\n    //after about 200 frames this adds enough to the seed to cause it to overflow so i set it back to zero after around 170 * 60 frames\n\n    uint seed = uint((fragCoord.y * iResolution.x + fragCoord.x) * modFrame);\n\n    vec3 camera_ray_dir = camera(uv, mouseUV * vec2(1.0 ,0.0));\n\n    vec3 col = vec3(0.0);\n    \n    for(int i = 0; i < ray_num; i++)\n    {\n        vec3 ray_origin = camera_position + randVec3Norm(seed) * dof_strength;\n        vec3 ray_dir = camera_ray_dir + randVec3Norm(seed) * blur_strength;\n        col +=  raytrace(ray_origin, ray_dir, seed);\n    } \n\n    col /= float(ray_num);\n    col *= exposure;\n\n    vec3 buffer = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n    \n    if(!movement)\n        col += buffer;//i bet after like 10000 seconds the colors start to get weird and innacurate because\n        //the numbers get so big you run into floating point imprecision\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//Change skybox settings in Cube A\n\nconst bool movement = false;//if true the user can move the camrea but it only displays the most recent frame\n//if false camera cannot move and the display is the average of all frames over time\n\nconst float exposure = 1.0;//each pixel's color gets multiplied by this number\n\nconst float sky_intensity = 1.0;//how bright the skybox is\n\nconst int ray_num = 1;//number of rays per pixel\n\nconst int reflections = 8;//number of reflections per ray\n\nconst float dof_strength = 0.000;//depth of field strength (I haven't added this yet)\n\nconst float blur_strength = 0.0001;//global blur applied to every pixel / ray; i recomend 0.0001\n\nconst float background_blur = 0.1;//blur applied to the direction used to get the color from the background cubemap\n\nconst vec3 camera_position = vec3(0.0,0.0,-12.0);\n\nconst  float FOV = 90.0;\n\nstruct object{\n    int shape;// 0 Sphere / 1 Cube / 2 Tourus\n    vec3 position;\n    vec3 scale;//Sphere uses only X / Cube uses all X, Y, and Z / Tourus uses only X and Y\n    vec3 color;\n    vec3 coat_color;\n    vec3 emission;\n    float smoothness;//how diffuse / specular the reflections are : lerp(diffuse, specular, smoothness)\n    float glossy;//what percent of reflections bounce off the coat / are specular and use coat color\n};\n\nconst object objectList[10] = object[](\n//object(int shape, vec3 position vec3 scale, vec3 color, vec3 coat color, vec3 emission, float smooth, float gossy);\nobject(0, vec3(0.0,0.0,-24.0),  vec3(4.0,4.0,0.1),   vec3(1.0,1.0,1.0), vec3(1.0,1.0,1.0), vec3(1.0,1.0,1.0), 0.1, 0.1),//back wall\nobject(1, vec3(0.0,0.0,4.0),  vec3(4.0,4.0,0.1),   vec3(1.0,1.0,1.0), vec3(1.0,1.0,1.0), vec3(0.0,0.0,0.0), 0.1, 0.1),//back wall\nobject(1, vec3(4.0,0.0,0.0),  vec3(0.1, 4.0, 4.0), vec3(0.3,0.3,1.0), vec3(1.0,1.0,1.0), vec3(0.0,0.0,0.0), 0.1, 0.1),//right wall\nobject(1, vec3(-4.0,0.0,0.0), vec3(0.1, 4.0, 4.0),vec3(1.0,0.3,0.3), vec3(1.0,1.0,1.0), vec3(0.0,0.0,0.0), 0.1, 0.1),//left wall\nobject(1, vec3(0.0,-4.0,0.0), vec3(4.0, 0.1, 4.0),vec3(1.0,1.0,1.0), vec3(1.0,1.0,1.0), vec3(0.0,0.0,0.0), 0.1, 0.2),//floor\nobject(1, vec3(0.0,4.0,0.0),  vec3(4.0, 0.1, 4.0), vec3(0.3,1.0,0.3), vec3(1.0,1.0,1.0), vec3(0.0,0.0,0.0), 0.1, 0.1),//ceiling\nobject(2, vec3(0.0,-3.0,0.0), vec3(2.5, 0.7, 1.0), vec3(1.0,1.0,1.0), vec3(1.0,1.0,1.0), vec3(0.0,0.0,0.0), 0.1, 0.2),//subject\nobject(0, vec3(-1.5,-1.0,0.0), vec3(0.75, 1.0, .0), vec3(1.0,1.0,1.0), vec3(1.0,1.0,1.0), vec3(3.0,0.1,0.1), 0.0, 0.0),//subject\nobject(0, vec3(0.0,1.0,0.0), vec3(0.75, 1.0, 1.0), vec3(1.0,1.0,1.0), vec3(1.0,1.0,1.0), vec3(0.1,3.0,0.1), 0.0, 0.0),//subject\nobject(0, vec3(1.5,-1.0,0.0), vec3(0.75, 1.0, 1.0), vec3(1.0,1.0,1.0), vec3(1.0,1.0,1.0), vec3(0.1,0.1,3.0), 0.0, 0.0)//subject\n);","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"const vec3 groundCol = vec3(0.2,0.2,0.3);\n\nconst vec3 skyCol = vec3(0.5,0.8,0.9);\n\nconst vec3 sunCol = vec3(1.0,0.9,0.8) * 2.0;\n\nconst vec3 sunDir = vec3(0.6,0.4,1.0);\n\nconst float sunRad = 1.1;\n\nconst vec3 flareCol = sunCol * 0.25;\n\nconst float flareRad = 1.0;\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    const vec3 up = vec3(0.0,1.0,0.0);\n   \n    float angle = dot(rayDir, up);\n   \n    float diff = mix(angle - 2.0, 0.5, angle + 1.0);\n   \n    vec3 col = mix(groundCol, skyCol, clamp(angle + diff, 0.0, 1.0));\n    \n    float sun = dot(normalize(sunDir), normalize(rayDir));\n\n    const float flare = 1.0 / (flareRad + sunRad);\n    \n    col += max(max(sun, 0.0) - flare, 0.0) * flareCol;\n\n    if(sun > 1.0 / (sunRad / 256.0 + 1.0))\n    {\n        col += sunCol;\n    }\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}","name":"Cube A","description":"","type":"cubemap"}]}