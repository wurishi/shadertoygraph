{"ver":"0.1","info":{"id":"DdGSD1","date":"1680996236","viewed":803,"name":"[4k] Random Generation","username":"Kali","description":"4kb intro presented at Revision 2023 by LIA. The party version introduces variations every time is run. \nIn this version you can click the mouse at different points along the x axis to see these variations.\nCode by me and music by Uctumi as usual.","likes":53,"published":1,"flags":96,"usePreview":1,"tags":["intro","4k","demoscene"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"ldt3Rn","filepath":"https://soundcloud.com/pablo-andrioli/random-generated-3e?si=f98962a4f27541eca27bc858c41b8848&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","previewfilepath":"https://soundcloud.com/pablo-andrioli/random-generated-3e?si=f98962a4f27541eca27bc858c41b8848&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// **********************************************************\n// RANDOM GENERATION by Latitude Independent Association\n// **********************************************************\n// The 4k executable introduce variations each time is run\n// Here you can click the mouse at different points along\n// the X axis to see these variations\n// **********************************************************\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0,uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define iD iMouse.x\n#define rot(a) mat2(cos(a+vec4(0,11,33,0)))   \n\nfloat curhash, nexthash, h1, h2, tt = 0., id, it, cab = 100., sph = 100., pis, time;\nvec3 pos, pobj;\n\nfloat hash(float p) {\n    p = p * 1230.123 + iD;\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    return fract(2. * p * p);\n}\n\nvec2 rand2(vec2 co) {\n    return\n        vec2(fract(sin(dot(co.xy, vec2(12.98, 78.23))) * 43758.54),\n            fract(cos(dot(co.xy, vec2(4.89, 7.23))) * 23421.63));\n}\n\nfloat rnd()\n{\n    h1++;\n    h2++;\n    return mix(hash(h1), hash(h2), fract(tt));\n}\n\nfloat cables(vec3 p) {\n    it = 0.;\n    p.xz *= rot(iTime);\n    float area = length(p), sc = 1., m = 1000.;\n    p *= .15;\n    for (float i = 0.; i < 8.; i++) {\n        p.xy = sin(p.xy);\n        p.xy *= rot(1.);\n        p.xz *= rot(1.5);\n        p = p * 2.;\n        float l2 = length(p) * .5 - .2;\n        float l = length(p.xy);\n        l = mix(l, l2, smoothstep(113., 120., iTime));\n        m = min(m, l);\n        if (m == l) it = i;\n\n    }\n    float d = m;\n    area += it * 2.;\n    d = max(d, area - smoothstep(100., 110., iTime) * 20.);\n    d = min(d, m + smoothstep(1., 20., area) * 2. + smoothstep(6.5, 5., iTime) * 30.);\n    return d;\n}\n\n\n\nfloat obj(vec3 p)\n{\n    float bo=length(p) - 15.;\n    if (bo > 0.) return bo + 1.;\n    vec3 p2 = p;\n    float s = sin(time * 3.);\n    p.xy *= rot((rnd() - .5) * 1.);\n    p.xz *= rot(time - p.y * (.12 + rnd() * .5));\n    p.xy *= rot(time - p.z * (.12 + rnd() * .6));\n    sph = length(p) - 2.3 - length(sin(p * 7.)) * .5 - rnd();\n    sph = min(sph, length(p.xy + 5.) + .1 + smoothstep(53., 51., iTime));\n    sph = min(sph, abs(p.x + 10.) + .1 + smoothstep(69., 67., iTime));\n    sph = max(sph, length(p) - 13.);\n    pos = p;\n    float d;\n    d = length(p) - 1. - rnd() * 2.;\n    d = max(d, -length(p.xy) + 2.5 + rnd());\n    d = max(d, -length(p.xz) + 2.5 + rnd());\n    d = max(d, -length(p.yz) + 2.5 + rnd());\n    float desp = (rnd() - .5) * 10.;\n    float rem = length(p.yz + vec2(desp, 0.)) * (.5 + rnd() * .5) + rnd() * .9;\n    rem = length(p.xz + vec2(desp, 0.)) * (.5 + rnd() * .5) + rnd() * .9;\n    d = min(d, rem);\n    d -= length(sin(p * (rnd() * 2. + 2.))) * (.8 + rnd() * .5);\n    d = max(d, length(p2) - 15.);\n    d = min(d + 2. * (smoothstep(15., 12., iTime) + smoothstep(93., 105., iTime)), sph);\n    pobj = p;\n    return d * .2;\n}\n\nfloat de(vec3 p) {\n    p.yz*=rot(smoothstep(80.,100.,iTime)*6.3);\n    vec3 p2 = p;\n    p2.y += 10. - smoothstep(0., 2., time) * 10.;\n    if (length(p) < 30.) cab = cables(p2);\n    p.xz *= rot(rnd() * 3.);\n    id = 0.;\n    h1 = curhash;\n    h2 = nexthash;\n    float d1 = obj(p2);\n    float d1b = length(p2) - 2.7;\n    float l = smoothstep(min(30., time * 10.), 0., length(p.xz));\n    float d2 = p.y + 4.5 + sin(length(p) * 5. - time * 20.) * .02 * l + smoothstep(50., 55., iTime) * 20.;\n    float d3 = max(abs(p.y + 2.), abs(length(p.xz) - 8.));\n    pis = d2;\n    d2 = min(d1b, d2);\n    return min(sph,min(cab, min(d1, d2)));\n}\n\n// normal hack to reduce webgl compilation time, not in the original version\nvec3 normal(vec3 pos) {\n    vec2 e=vec2(0.,.01);\n    vec3[4] ev = vec3[4](e.yxx, e.xyx, e.xxy, e.xxx-.000001);\n    vec3 nn = vec3(0);\n    for(int i = 0; i<4; i++){\n        nn += sign(ev[i])*de(pos + ev[i]);\n        if(nn.x<-1e8) break; // Fake break.\n    } \n    return normalize(nn);\n}\n\nvec3 march(vec3 from, vec3 dir)\n{\n    vec3 gcol = normalize(.3 + vec3(rnd(), rnd() * .5, rnd()));\n    gcol.rb *= rot(dir.y * 1.5);\n    gcol = abs(gcol);\n    float td = 0., d, maxdist = 70., g = 0., ref = 0.;\n    vec3 p = from + dir, col = vec3(.0);\n    float h = rand2(dir.xy + mod(time, 10.)).x - .5;\n    float savepis = 0.;\n    float glow = smoothstep(13., 14., iTime) - smoothstep(94., 96., iTime) + smoothstep(103., 103.5, iTime);\n    for (int i = 0; i < 200; i++)\n    {\n        p += dir * d * (1. - h * .2);\n        d = de(p);\n        if (td > maxdist) break;\n        if (d < .01 && ref < 1.)\n        {\n            savepis = pis;\n            ref++;\n            vec3 n = normal(p);\n            dir = reflect(dir, n);\n            p += .01 * dir;\n            continue;\n        }\n        if (d < .01) break;\n        td += d;\n        g = max(g, (.3 + glow * .35) / (.1 + sph * 3.)) * step(fract(iTime * 2.5), .4 + step(iTime, 40.) + step(66., iTime) + length(p) * .1);\n        float fl = .1 / (.1 + pis * .5) * .015;\n        fl *= 1. + step(fract(iTime * 2.5), .4) * step(40., iTime);\n        g += fl;\n        g += .1 / (.1 + cab * 2.) * step(.7, fract(length(p) * .2 - iTime * 1.25 + it * .2));\n    }\n    if (d < .01)\n    {\n        vec3 n = normal(p);\n        vec3 refr = reflect(dir, n);\n        col = normalize((fract(.5 * pobj * rnd()))) * 5. * pow(max(0., dot(normalize(-p), n)), 3.) * 1.\n            + pow(max(0., dot(normalize(-p), refr)), 5.) * 1.5 * gcol\n            + smoothstep(.5, 0., abs(length(pobj.xy) - 7.)) * 5.;\n        col *= gcol;;\n        if (savepis < 0.1) col *= .5;\n    } else {\n        col = gcol * gl_FragCoord.x/iResolution.x * (.5+step(.5,fract(iTime*2.5))*.5) * step(40.,iTime) * step(iTime,123.5);\n    }\n    col = clamp(col, vec3(0.), vec3(1.));\n    col += g * gcol * (.7 + step(.5, savepis) * .3);\n    return col;\n}\n\nvec2 uniformDisc(vec2 co) {\n    vec2 r = rand2(co);\n    return sqrt(r.y) * vec2(cos(r.x * 6.28), sin(r.x * 6.28));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    time = (iTime * (.25 + step(26.5, iTime) * .2 + step(40., iTime) * .2 + step(66.5, iTime) * .1) + 0.);\n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n    tt = smoothstep(0., 1., fract(iTime * .15625));\n    float n = floor(iTime * .15625) + step(26.5, iTime) + step(40., iTime) + step(80., iTime),\n        split = sign(uv.x + smoothstep(67.5, 66.5, iTime) * .5 * -sign(uv.x) - .15 * smoothstep(66.5, 80., iTime));\n    if (iTime > 66.5 && iTime < 80.) {\n        uv.x -= split * .25 + smoothstep(66.5, 80., iTime) * .07;\n        uv *= 1.4 * -split - (iTime - 66.5) * .06;\n        n += split * 10.;\n        split = 10.;\n    }\n    curhash = n;\n    nexthash = n + 1.;\n    h1 = curhash;\n    h2 = nexthash;\n    uv.x += (rnd() - .5) * .4 * smoothstep(115., 110., iTime) * step(split, 9.);\n    uv.x *= iResolution.x / iResolution.y;\n    uv += uniformDisc(uv + iTime) * .05\n        * (smoothstep(2., 0., min(abs(iTime - 39.5), abs(iTime - 66.))) + 2. * smoothstep(122.5, 130., iTime));\n    vec3 dir = normalize(vec3(uv, .6 + rnd()*.9)),\n        from = vec3(0., -4. + 15. * rnd(), -20);\n    from.y -= step(40., iTime) * 5.;\n    from.y += step(66.5, iTime) * 15.;\n    from.y = max(-4., from.y);\n    from.y -= step(53.3, iTime) * 15.;\n    if (iTime < 26.5) from.y *= .5;\n    from.xz *= rot(-time + smoothstep(120.5, 124., iTime) * 5.);\n    if (iTime > 53.3 && iTime < 66.5) dir = normalize(vec3(uv, 1.7));\n    dir.xy *= 1. + smoothstep(118., 120., iTime) * .6;\n    vec3 fr = normalize(-from);\n    vec3 rt = normalize(cross(fr, vec3(0., 1., 0.)));\n    dir = mat3(rt, cross(rt, fr), fr) * dir;\n    vec3 col = march(from, dir);\n    vec3 fb = texture(iChannel0, vec2(fragCoord.xy / iResolution.xy)).rgb;\n    if (time > .01) {\n        col = mix(col, fb, .93);\n    }\n    col += step(abs(iTime - 26.5), .02) * .3;\n    col += step(abs(iTime - 53.3), .02) * .3;\n    col += step(abs(iTime - 80.), .02) * .3;\n    col.rgb = mix(length(col.rgb) * vec3(.5, .4, .3), col.rgb, .8);\n    col *= smoothstep(130., 127., iTime) * smoothstep(0., .5, iTime);\n    if (split > 9.) col *= exp(-.2 * abs(uv.x));\n    fragColor = vec4(col, 1.);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}