{"ver":"0.1","info":{"id":"3lsBD8","date":"1596597807","viewed":277,"name":"crater noise","username":"okelly4408","description":"crater noise","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["noise","sphere","craters"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 20.\n#define MIN_DIST .001\n#define MAX_ITER 100\n\nconst vec3 BOX = vec3(0.5);\nconst float eps = 0.0001;\nfloat hash(\n\tin float n\n){\n\treturn fract(sin(n)*753.5453123);\n}\n\nvec3 getColor(vec3 pos, vec3 normal){\n\tfloat slope = abs(normal.y);\n\tvec3 mainColor = vec3( 0.75 *vec3(0.9647, 0.3843, 0.23549));\n\tvec3 orangeRust = vec3(195.0, 88.0, 23.0)/255.0;\n\tvec3 mid  = vec3(0.75686276,0.6039216,0.41960785) * 0.8;\n\tvec3 col = mix(mid * 0.75, orangeRust * 0.65, slope * .75 );\n\treturn col * 0.5;\n}\n\nfloat noise(in vec3 x){\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f*f*(3.0 - 2.0*f);\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\nfloat fbm (in vec3 p, in int octaves)\n{\n    float f = 0.0;\n    float freq = 1.0;\n    for (int i = 0; i < octaves; i++)\n    {\n        float n = noise((p * m) * freq) / freq;\n        f += n;\n        freq *= 2.0;\n    }\n    return f;\n}\n\n\n\nvec4 gpuGetCell3D(const in int x, const in int y, const in int z)\n{\n\tfloat u = float(x + y * 31) / 256.0;\n\tfloat v = float(z - x * 3) / 256.0;\n\treturn(texture(iChannel1, vec2(u, v)));\n}\n\nvec2 gpuCellNoise3D(const in vec3 xyz)\n{\n\tint xi = int(floor(xyz.x));\n\tint yi = int(floor(xyz.y));\n\tint zi = int(floor(xyz.z));\n\n\tfloat xf = xyz.x - float(xi);\n\tfloat yf = xyz.y - float(yi);\n\tfloat zf = xyz.z - float(zi);\n\n\tfloat dist1 = 9999999.0;\n\tfloat dist2 = 9999999.0;\n\tvec3 cell;\n\n\tfor (int z = -1; z <= 1; z++)\n\t{\n\t\tfor (int y = -1; y <= 1; y++)\n\t\t{\n\t\t\tfor (int x = -1; x <= 1; x++)\n\t\t\t{\n\t\t\t\tcell = gpuGetCell3D(xi + x, yi + y, zi + z).xyz;\n\t\t\t\tcell.x += (float(x) - xf);\n\t\t\t\tcell.y += (float(y) - yf);\n\t\t\t\tcell.z += (float(z) - zf);\n\t\t\t\tfloat dist = dot(cell, cell);\n\t\t\t\tif (dist < dist1)\n\t\t\t\t{\n\t\t\t\t\tdist2 = dist1;\n\t\t\t\t\tdist1 = dist;\n\t\t\t\t}\n\t\t\t\telse if (dist < dist2)\n\t\t\t\t{\n\t\t\t\t\tdist2 = dist;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn vec2(sqrt(dist1), sqrt(dist2));\n}\n\nfloat f2mf1(vec3 p)\n{\n\tvec2 c = gpuCellNoise3D(p);\n\n\treturn c.y - c.x;\n}\n\n\nfloat craterNoise3D(in vec3 p){\n\t\n    \n    const float radius = 0.25;\n    const float slope = .095;\n    const float frequency = 2.35;\n    const float depth = -0.982;\n    const float rimWidth = 0.125;\n    \n\tfloat fractal = fbm(p * frequency * 2.0, 4) * 0.07;\n\tfloat cell = gpuCellNoise3D((p * frequency) + fractal ).x;\n\tfloat r = radius + fractal;\n\tfloat crater = smoothstep(slope, r, cell);\n\t  \t  crater = mix(depth, crater, crater);\n\tfloat rim = 1.0 - smoothstep(r, r + rimWidth, cell);\n\t      crater = rim - (1.0 - crater);\n\treturn crater * 0.08;\n}\n\n  \nfloat sdSphere(vec3 p, vec3 c, float r) {\n    \n    return length(p - c) - (r + (fbm(p * 2.15, 6) * 0.25) + (craterNoise3D(p / 2.0)));\n}\n\nfloat map(in vec3 p){\n    return sdSphere(p, vec3(0.0), 4.0);\n}\nvec3 sNormal(in vec3 p){\n    float e = 0.001;\n    float d = map(p);\n    float xd = map(p+vec3(e,0,0));\n    float yd = map(p+vec3(0,e,0));\n    float zd = map(p+vec3(0,0,e));\n    vec3 n = (vec3(xd,yd,zd)-d)/e;\n    return n;\n}\nfloat castRay(vec3 ro, vec3 rd){\n    float t = 0.0; \n    for(int i=0; i<MAX_ITER; i++){\n        vec3 p = ro + t*rd;\n        float h = map(p);\n        if(abs(h)<MIN_DIST) break;\n        t+=h*0.75;\n        if(t>MAX_DIST) break;\n    }\n    if(t>MAX_DIST) t = -1.0;\n    return t;\n}\nvec3 camera(in vec2 uv, in vec3 ro, vec3 ta, float fd){\n    vec3 up = vec3(0,1,0); // global up vector\n    vec3 ww = normalize(ta-ro); // direction to the target\n    vec3 uu = normalize(cross(ww, up)); // camera right direction\n    vec3 vv = normalize(cross(uu, ww)); // camera up direction\n    \n    vec3 rd = normalize(uv.x*uu + uv.y*vv + fd*ww); // camera direction to uv\n    return rd;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5);\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 li = normalize(vec3(0.5, .8, 3.0));\n    float a = 10.0 * iMouse.x/iResolution.x;\n    float taDist = 2.0;\n    vec3 ro = vec3( 8.0 * sin(a + float(iTime * 0.25)), 7.0, 8.0* cos(a + float(iTime * 0.25)));\n    vec3 ta = vec3(0,0,0);\n    \n    vec3 rd = camera(uv, ro, ta, 1.0);\n    float t = castRay(ro, rd);\n    vec3 col = vec3(0.0);\n    if (t > 0.0) {\n        vec3 pos = ro + t*rd;\n        vec3 normal = sNormal(pos);\n        //col =mix(vec3(0.6, 0.4, 0.3), vec3(0.2), smoothstep(4.5, 5.5, length(pos))) + 0.25*pow(max(dot(li, normal)*1.2, 0.05), .75);\n        col = (dot(li, normal) + 1.15) * getColor(pos, normal);\n    }\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}