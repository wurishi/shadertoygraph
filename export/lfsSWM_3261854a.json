{"ver":"0.1","info":{"id":"lfsSWM","date":"1705391013","viewed":132,"name":"RGB game of life","username":"retronyme","description":"Game of life using the sorbel edge detection\nThere is a different sim running on each color canal\n\nSobel edge adapted from https://www.shadertoy.com/view/wl2cW3","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["sim"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\tvec2 uv = (fragCoord.xy / iResolution.xy);\n    \n    vec4 cell = texture(iChannel0, uv);\n    \n    fragColor = cell;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define brushSize 20.0\n\n#define SRC_CHAN iChannel0\n#define NOISE_CHAN iChannel1\n#define NOISE_TRESH 0.3\n\n#define LONELY 1.0\n#define OVERCROWDED 4.0\n#define BIRTH 3.0\n\n/* From https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\nAny live cell with fewer than two live neighbors dies, as if by underpopulation.\nAny live cell with two or three live neighbors lives on to the next generation.\nAny live cell with more than three live neighbors dies, as if by overpopulation.\nAny dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n*/\n\nfloat get_neighbor(in vec2 fragCoord, in vec2 offset, int channel) {\n    vec2 invres = vec2(1.0/iResolution.x,1.0/iResolution.y);\n    vec4 cell_color = texture(SRC_CHAN,(fragCoord + offset)*invres);\n    return cell_color[channel] > 0.0 ? 1.0 : 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    vec3 next_state;\n\n    for(int i = 0; i < 3; i++) {\n        float cell = get_neighbor(fragCoord, vec2(0,0), i);\n\n        fragColor = vec4(cell);\n        \n        // count neighbors \n        float  neighbors = get_neighbor(fragCoord, vec2(0,-1), i) +\n        get_neighbor(fragCoord, vec2(0, 1), i) +\n        get_neighbor(fragCoord, vec2(1,-1), i) +\n        get_neighbor(fragCoord, vec2(1, 0), i) +\n        get_neighbor(fragCoord, vec2(1, 1), i) +\n        get_neighbor(fragCoord, vec2(-1,-1), i) +\n        get_neighbor(fragCoord, vec2(-1, 0), i) +\n        get_neighbor(fragCoord, vec2(-1, 1), i);\n\n        // apply rule\n        if (cell > 0.1) {\n            // alive\n            if (neighbors > LONELY && neighbors < OVERCROWDED) {\n               cell = 1.0;\n            } else {\n               cell = 0.0;\n            }\n          } else {\n            // dead\n            if (neighbors == BIRTH) {\n                cell =  1.0;\n            } else {\n                cell = 0.0;\n            }\n          }\n\n        next_state[i] = cell;\n    }\n\n\n    // draw with mouse \n    float distance = length(fragCoord.xy - iMouse.xy);\n    if (distance < brushSize && iMouse.z > 0.01) {\n        next_state = vec3(1.0);\n    }   \n\n    // mix with input channel\n    vec2 invres = vec2(1.0/iResolution.x,1.0/iResolution.y);\n    vec4 cam_rgba;\n    cam_rgba.r = texture(NOISE_CHAN, (fragCoord)*invres).r;\n    cam_rgba.g = texture(NOISE_CHAN, (vec2(10.*cos(2.*iTime), 0.0) +fragCoord)*invres).g;\n    cam_rgba.b = texture(NOISE_CHAN, (vec2(0.0, 20.*cos(2.*iTime)) +fragCoord)*invres).b;\n\n    \n    vec3 video;\n    video.r = cam_rgba.r > NOISE_TRESH ? 1.0 : 0.0;\n    video.g = cam_rgba.g > NOISE_TRESH ? 1.0 : 0.0;\n    video.b = cam_rgba.b > NOISE_TRESH ? 1.0 : 0.0;\n\n    vec3 color = next_state*0.5 * (1.0 - video) + video;\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define channel iChannel0\n#define MERGE 0\n// sets RGB based on edge angle\n#define COLOR_ANGLE 1\n#define OUTLINE_COL 0.0f,0.5f,1.0f\n// enable / disable canny, uses only sorbel edge\n#define CANNY 0\n// STEP effects thickness\n#define STEP 1.0f\n// MIN outline brightness mask\n#define MIN 0.1f\n// MAX NOT USED\n#define MAX 0.5f \n#define INTENSITY 2.0f\n\n// GREENSCREEN requires MERGE\n#define GREENSCREEN 0\n#define GREENSCREEN_CHANNEL iChannel2\n#define threshold 0.55\n#define padding 0.01\n// CONSTANTS\nconst float M_PI = 3.1415;\nfloat GetBrightness(vec2 uv)\n{\n    vec4 color = texture(channel,uv);\n\treturn sqrt((color.x * color.x) + (color.y*color.y) + (color.z * color.z));   \n}\nvec2 Sorbel(vec2 uv)\n{\n    float stepx = STEP/iResolution[0];\n    float stepy = STEP/iResolution[1];\n\n\tvec2 uvTL = vec2(uv.x-stepx, uv.y+stepy);\n    vec2 uvML = vec2(uv.x-stepx, uv.y);\n    vec2 uvBL = vec2(uv.x-stepx, uv.y-stepy);\n    \n    vec2 uvTR = vec2(uv.x+stepx, uv.y+stepy);\n    vec2 uvMR = vec2(uv.x+stepx, uv.y);\n    vec2 uvBR = vec2(uv.x+stepx, uv.y-stepy);\n    \n    vec2 uvTM = vec2(uv.x, uv.y+stepy);\n    vec2 uvBM = vec2(uv.x, uv.y-stepy);\n    // Time varying pixel color\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float tl = GetBrightness(uvTL);\n    float ml = GetBrightness(uvML);\n    float bl = GetBrightness(uvBL);\n    \n    float tr = GetBrightness(uvTR);\n    float mr = GetBrightness(uvMR);\n    float br = GetBrightness(uvBR);\n    \n    float tm = GetBrightness(uvTM);\n    float bm = GetBrightness(uvBM);\n    \n    float gx = 0.0f;\n    gx += tl * -1.f;\n    gx += ml * -2.f;     \n    gx += bl * -1.f;\n    \n    gx += tr * 1.f;\n    gx += mr * 2.f;     \n    gx += br * 1.f;\n  \tfloat gy = 0.0f;\n    gy += tl * -1.f;\n    gy += tm * -2.f;     \n    gy += tr * -1.f;\n    \n    gy += bl * 1.f;\n    gy += bm * 2.f;     \n    gy += br * 1.f;\n    \n    return vec2(gx,gy);\n}\nfloat GetStrength(vec2 vg)\n{\n   \n    float gx = vg.x;\n    float gy = vg.y;\n    \n    float g = (gx*gx+gy*gy);\n    return g;\n}\nfloat GetAngle(vec2 vg)\n{\n    float angle = atan(vg.y,vg.x);\n\treturn angle;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float stepx = STEP/iResolution[0];\n    float stepy = STEP/iResolution[1];  \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 sorbeA = Sorbel(uv);\n   \tfloat sorbelA_Strength = GetStrength(sorbeA);\n    float angle = GetAngle(sorbeA);\n    #if CANNY\n    vec2 dir;\n  \tdir.x = cos(angle)*stepx;\n\tdir.y = sin(angle)*stepy;\n    vec2 sorbelB = Sorbel(uv + dir);\n    vec2 sorbelC = Sorbel(uv - dir);\n    \n    float sorbelB_Strength = GetStrength(sorbelB);    \n    float sorbelC_Strength = GetStrength(sorbelC);\n\n    if(sorbelA_Strength < sorbelB_Strength || sorbelA_Strength < sorbelC_Strength )\n    \tsorbelA_Strength = 0.0f;\n    #endif\n    // Treshold\n    if(sorbelA_Strength < MIN)\n        sorbelA_Strength = 0.0f;\n    \n    vec4 col = vec4(0,0,0,0);\n    #if MERGE\n    #if GREENSCREEN\n    vec4 greenScreen = vec4(0.,1.,0.,1.);\n    vec4 sourceColor = texture(channel, uv);\n    \n    vec3 diff = sourceColor.xyz - greenScreen.xyz;\n    float fac = smoothstep(threshold-padding,threshold+padding, dot(diff,diff));\n    \n    col += mix(sourceColor, texture(GREENSCREEN_CHANNEL, uv), 1.-fac);\n\t #else\n    col += texture(channel, uv);\n       #endif\n    #endif\n    \n\t#if COLOR_ANGLE\n     vec3 outlineCol = vec3(sin(angle), sin(angle + 2.0f*M_PI/3.0f),sin(angle + 2.f*M_PI/3.0f * 2.0f));\n\t#else\n       vec3 outlineCol = vec3(OUTLINE_COL);\n#endif\n    col += vec4(outlineCol*sorbelA_Strength * INTENSITY, 1.0);\n    // Output to screen\n    // col = vec4(angle,angle,angle,1.0f);\n    fragColor = col;\n}","name":"Buffer B","description":"","type":"buffer"}]}