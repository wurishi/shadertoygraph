{"ver":"0.1","info":{"id":"7dl3Rj","date":"1639366698","viewed":77,"name":"009_Oscillation_3","username":"francislarge","description":"P","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["playground"],"hasliked":0,"parentid":"NdfGzj","parentname":"009_Oscillation_2"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct FWave\n{\n    float AngleRange; \n    float Amplitude;  \n    float YOffset;\n    vec4 Color;\n};\n\nstruct FLight\n{\n    float Intensity;\n    vec4  Color;\n    vec2 Position;\n};\n\n\nfloat GetY(FWave Wave, float CurrentAngle_X);\nvec2 CalculateSlope(vec2 Point1, vec2 Point2);\nvec2 CalculateNormal(vec2 Slope);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    FWave Wave;\n    Wave.AngleRange = acos(-1.0) / 2.0 ;\n    Wave.Amplitude  = 0.5;\n    Wave.YOffset    = 0.0;\n    Wave.Color      = vec4(0.2, 0.9, 0.6, 1.0);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    float AspectRatio = iResolution.x/iResolution.y;\n    \n    uv.x  = uv.x * 2.0 - 1.0;\n    uv.x *= AspectRatio;\n    \n    float XShift = iTime;\n    float CurrentAngle = (uv.x + XShift) * Wave.AngleRange;\n    float CurrentY  = GetY(Wave, CurrentAngle);\n    \n    vec2 CurrentPoint = vec2(uv.x, CurrentY); \n    \n    CurrentY = (CurrentY + 1.0) / 2.0; \n        \n    float Output_Based_On_Current_Y =  uv.y / CurrentY;\n    \n    Output_Based_On_Current_Y = min(Output_Based_On_Current_Y, 1.0);\n    \n    float PushToEdge  = 15.0;\n\n    Output_Based_On_Current_Y = pow(Output_Based_On_Current_Y, PushToEdge);\n    \n    //Invert and get a line output instead\n    Output_Based_On_Current_Y = (1.0 - Output_Based_On_Current_Y) * Output_Based_On_Current_Y;\n    \n    Output_Based_On_Current_Y = clamp(Output_Based_On_Current_Y * 5.0, 0.0, 1.0);\n    \n    //Calculate surface normal\n    uv.x  = (fragCoord.x - 0.1) / iResolution.x; \n    uv.x  = uv.x * 2.0 - 1.0; \n    uv.x *= AspectRatio;\n    \n    float PreviousAngle = (uv.x + XShift) * Wave.AngleRange;\n    float PreviousY = GetY(Wave, PreviousAngle);\n    vec2  PreviousPoint = vec2(uv.x, PreviousY);\n    \n    vec2 Normal = CalculateNormal( CalculateSlope(  CurrentPoint, PreviousPoint ) );\n    \n    //Calculate light\n    FLight Light;\n    Light.Intensity = 1.0;\n    Light.Position  = vec2(0.0, .80);\n    \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)); \n    Light.Color  = vec4(0.4, 0.7, .9, 1);\n    \n    float CircleRadius = 0.15;\n    uv = fragCoord/iResolution.xy; uv = uv * 2.0 - 1.0; uv.x *= AspectRatio;\n    float Circle = max( CircleRadius - distance(uv, Light.Position), 0.0) / CircleRadius;\n    Circle = Circle / 0.4;\n    Circle = clamp(Circle, 0.0, 1.0);\n        \n    float I = dot( Light.Position - CurrentPoint, Normal) * Light.Intensity;\n    I = max(I, 0.0);\n    \n    //Final output\n    vec4 FinalOutput = Output_Based_On_Current_Y * I * Light.Color;\n    vec4 LightShape = Circle * Light.Color * Light.Intensity ;\n     \n    FinalOutput = mix(FinalOutput, LightShape, 0.6);\n    \n    fragColor = ( FinalOutput );\n   \n}\n\nfloat GetY(FWave Wave, float CurrentAngle_X)\n{\n    return Wave.Amplitude * cos(CurrentAngle_X) + Wave.YOffset;\n}\n\nvec2 CalculateSlope(vec2 Point1, vec2 Point2)\n{\n    return Point1 - Point2;\n}\n\nvec2 CalculateNormal(vec2 Slope)\n{\n    Slope = normalize(Slope);\n    \n    return vec2( -Slope.y, Slope.x);\n}\n\n","name":"Image","description":"","type":"image"}]}