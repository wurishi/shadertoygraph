{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Fragment coords relative to the center of viewport, in a 1 by 1 coords sytem.\n\tvec2 uv = -1.0 + 2.0* fragCoord.xy / iResolution.xy;\n\n\t// But I want circles, not ovales, so I adjust y with x resolution.\n\tvec2 homoCoords = vec2( uv.x, 2.0* fragCoord.y/iResolution.x );\n\n\t// Sin of distance from a moving origin to current fragment will give us..... \n\tvec2 movingOrigin1 = vec2(sin(iTime*.7),+sin(iTime*1.7));\n\t\n\t// ...numerous... \n\tfloat frequencyBoost = 50.0; \n\t\n\t// ... awesome concentric circles.\n\tfloat wavePoint1 = sin(distance(movingOrigin1, homoCoords)*frequencyBoost);\n\t\n\t// I want sharp circles, not blurry ones.\n\tfloat blackOrWhite1 = sign(wavePoint1);\n\t\n\t// That was cool ! Let's do it again ! (No, I dont want to write a function today, I'm tired).\n\tvec2 movingOrigin2 = vec2(-cos(iTime*2.0),-sin(iTime*3.0));\n\tfloat wavePoint2 = sin(distance(movingOrigin2, homoCoords)*frequencyBoost);\n\tfloat blackOrWhite2 = sign(wavePoint2);\n\t\n\t// I love pink.\n\tvec3 pink = vec3(1.0, .5, .9 );\n\tvec3 darkPink = vec3(0.5, 0.1, 0.3);\n\t\n\t// XOR virtual machine.\n\tfloat composite = blackOrWhite1 * blackOrWhite2;\n\t\n\t// Pinkization\n\tfragColor = vec4(max( pink * composite, darkPink), 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldX3DN","date":"1370380546","viewed":4306,"name":"Simple Eye Blower","username":"Lanza","description":"Classic oldschool effect, pink flavour. \nRemembering Amiga bitplanes...\nNo ray-thinger, nor 3D, just plain plane 2D effect.","likes":25,"published":1,"flags":0,"usePreview":0,"tags":["oldschool","circle","moire","pink","bitplane"],"hasliked":0,"parentid":"","parentname":""}}