{"ver":"0.1","info":{"id":"dsGXz1","date":"1682193791","viewed":99,"name":"basicpathtracetest","username":"quadrortx8000","description":"asd","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["asd"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 SampleBilaterialFilter(sampler2D tex, vec2 texelSize, vec2 uv, float sigmaS, float sigmaR, float kernelSize)\n{\n    vec4 color = texture(tex, uv);\n    vec4 sum = vec4(0.0);\n    float weightSum = 0.0;\n\n    for(float x = -kernelSize; x <= kernelSize; x++) \n    {\n        for(float y = -kernelSize; y <= kernelSize; y++) \n        {\n            vec2 offset = vec2(x, y) * texelSize;\n            vec4 neighborColor = texture(tex, uv + offset);\n            float spatialWeight = exp(-(x * x + y * y) / (2.0 * sigmaS * sigmaR));\n            float rangeWeight = exp(-(length(neighborColor.rgb - color.rgb) / (sqrt(2.0) * sigmaR)));\n            float weight = spatialWeight * rangeWeight;\n            sum += neighborColor * weight;\n            weightSum += weight;\n        }\n    }\n    \n    return sum / weightSum;\n}\n\nvec3 aces(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.4));\t\n}\n\nvec3 uchimura(vec3 x, float P, float a, float m, float l, float c, float b) {\n  float l0 = ((P - m) * l) / a;\n  float L0 = m - m / a;\n  float L1 = m + (1.0 - m) / a;\n  float S0 = m + l0;\n  float S1 = m + a * l0;\n  float C2 = (a * P) / (P - S1);\n  float CP = -C2 / P;\n\n  vec3 w0 = vec3(1.0 - smoothstep(0.0, m, x));\n  vec3 w2 = vec3(step(m + l0, x));\n  vec3 w1 = vec3(1.0 - w0 - w2);\n\n  vec3 T = vec3(m * pow(x / m, vec3(c)) + b);\n  vec3 S = vec3(P - (P - S1) * exp(CP * (x - S0)));\n  vec3 L = vec3(m + a * (x - m));\n\n  return T * w0 + L * w1 + S * w2;\n}\n\nvec3 uchimura(vec3 x) {\n  const float P = 1.0;  // max display brightness\n  const float a = 1.0;  // contrast\n  const float m = 0.22; // linear section start\n  const float l = 0.4;  // linear section length\n  const float c = 1.33; // black\n  const float b = 0.0;  // pedestal\n\n  return uchimura(x, P, a, m, l, c, b);\n}\n\nvec3 filmic(vec3 x) {\n  vec3 X = max(vec3(0.0), x - 0.004);\n  vec3 result = (X * (6.2 * X + 0.5)) / (X * (6.2 * X + 1.7) + 0.06);\n  return result;\n}\n\nvec3 lottes(vec3 x) {\n  const vec3 a = vec3(1.6);\n  const vec3 d = vec3(0.977);\n  const vec3 hdrMax = vec3(8.0);\n  const vec3 midIn = vec3(0.18);\n  const vec3 midOut = vec3(0.267);\n\n  const vec3 b =\n      (-pow(midIn, a) + pow(hdrMax, a) * midOut) /\n      ((pow(hdrMax, a * d) - pow(midIn, a * d)) * midOut);\n  const vec3 c =\n      (pow(hdrMax, a * d) * pow(midIn, a) - pow(hdrMax, a) * pow(midIn, a * d) * midOut) /\n      ((pow(hdrMax, a * d) - pow(midIn, a * d)) * midOut);\n\n  return pow(x, a) / (pow(x, a * d) * b + c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //vec3 col = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    vec3 col = SampleBilaterialFilter(iChannel0, vec2(1.0) / iResolution.xy, fragCoord / iResolution.xy, 10.0, 0.2, 1.0).rgb;\n    col /= texture(iChannel0, fragCoord / iResolution.xy).w;\n    vec3 col2;\n    col2 = log(pow(col, vec3(1.0 / 1.4)) * 2.0 + 1.0);\n    //col2 = pow(col, vec3(1.0 / 2.4)) * 1.1 - 0.1; //8\n    //col2 = aces(col); //6\n    //col2 = pow(uchimura(col), vec3(1.0 / 2.4)); //9\n    //col2 = linear(col); //7.5\n    //col2 = filmic(col); //6\n    //col2 = pow(lottes(col * 0.8), vec3(1.0 / 2.4)); //9\n    fragColor = vec4(col2, 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"int renders = 1;\n\nint bounces = 3;\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n \nvec3 randVec(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * 3.14159265358979323 * 2.0;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\nfloat fresnel(float n1, float n2, vec3 normal, vec3 incident, float f0, float f90)\n{\n        // Schlick aproximation\n        float r0 = (n1-n2) / (n1+n2);\n        r0 *= r0;\n        float cosX = -dot(normal, incident);\n        if (n1 > n2)\n        {\n            float n = n1/n2;\n            float sinT2 = n*n*(1.0-cosX*cosX);\n            // Total internal reflection\n            if (sinT2 > 1.0)\n                return f90;\n            cosX = sqrt(1.0-sinT2);\n        }\n        float x = 1.0-cosX;\n        float ret = r0+(1.0-r0)*x*x*x*x*x;\n \n        // adjust reflect multiplier for object reflectivity\n        return mix(f0, f90, ret);\n}\n\nvoid scene(in vec3 ro, in vec3 rd, inout hitinfo hit) {  \n    vec3 a = vec3(-4.1, -4.1, -8.1);\n    vec3 a1 = vec3(-4.1, -4.1, 0.0);\n    vec3 b = vec3(-4.1, 4.1, -8.1);\n    vec3 b1 = vec3(-4.1, 4.1, 0.0);\n    vec3 c = vec3(4.1, 4.1, -8.1);\n    vec3 c1 = vec3(4.1, 4.1, 0.0);\n    vec3 d = vec3(4.1, -4.1, -8.1);\n    vec3 d1 = vec3(4.1, -4.1, 0.0);\n    \n    vec3 l1 = vec3(-1.0, 3.999, -3.0);\n    vec3 l2 = vec3(-1.0, 3.999, -5.0);\n    vec3 l3 = vec3(1.0, 3.999, -5.0);\n    vec3 l4 = vec3(1.0, 3.999, -3.0);\n    \n    if (iQuad(ro, rd, hit, a, b, c, d)) { //back\n        hit.albedo = vec3(1.0, 1.0, 1.0);\n        hit.emissive = vec3(0.0, 0.0, 0.0);\n        hit.roughness = 1.0;\n        hit.specular = 0.0;\n        hit.speccol = vec3(1.0);\n        hit.IOR = 1.0;\n    }\n    if (iQuad(ro, rd, hit, a, a1, b1, b)) { //left\n        hit.albedo = vec3(1.0, 0.0, 0.0);\n        hit.emissive = vec3(0.0, 0.0, 0.0);\n        hit.roughness = 1.0;\n        hit.specular = 0.0;\n        hit.speccol = vec3(1.0);\n        hit.IOR = 1.0;\n    }\n    if (iQuad(ro, rd, hit, c, c1, d1, d)) { //right\n        hit.albedo = vec3(0.0, 1.0, 0.0);\n        hit.emissive = vec3(0.0, 0.0, 0.0);\n        hit.roughness = 1.0;\n        hit.specular = 0.0;\n        hit.speccol = vec3(1.0);\n        hit.IOR = 1.0;\n    }\n    if (iQuad(ro, rd, hit, b, b1, c1, c)) { //top\n        hit.albedo = vec3(1.0, 1.0, 1.0);\n        hit.emissive = vec3(0.0, 0.0, 0.0);\n        hit.roughness = 1.0;\n        hit.specular = 0.0;\n        hit.speccol = vec3(1.0);\n        hit.IOR = 1.0;\n    }\n    if (iQuad(ro, rd, hit, d, d1, a1, a)) { //bottom\n        hit.albedo = vec3(1.0, 1.0, 1.0);\n        hit.emissive = vec3(0.0, 0.0, 0.0);\n        hit.roughness = 1.0;\n        hit.specular = 0.0;\n        hit.speccol = vec3(1.0);\n        hit.IOR = 1.0;\n    }\n    /*if (iQuad(ro, rd, hit, l1, l2, l3, l4)) { //light\n        hit.albedo = vec3(1.0, 1.0, 1.0);\n        hit.emissive = vec3(0.0, 1.0, 0.0);\n        hit.roughness = 1.0;\n        hit.specular = 0.0;\n        hit.speccol = vec3(1.0);\n        hit.IOR = 1.0;\n    }\n    if (iQuad(ro, rd, hit, l1 + vec3(3.0, 0.0, 0.0), l2 + vec3(3.0, 0.0, 0.0), l3 + vec3(3.0, 0.0, 0.0), l4 + vec3(3.0, 0.0, 0.0))) { //light\n        hit.albedo = vec3(1.0, 1.0, 1.0);\n        hit.emissive = vec3(0.0, 0.0, 1.0);\n        hit.roughness = 1.0;\n        hit.specular = 0.0;\n        hit.speccol = vec3(1.0);\n        hit.IOR = 1.0;\n    }\n    if (iQuad(ro, rd, hit, l1 - vec3(3.0, 0.0, 0.0), l2 - vec3(3.0, 0.0, 0.0), l3 - vec3(3.0, 0.0, 0.0), l4 - vec3(3.0, 0.0, 0.0))) { //light\n        hit.albedo = vec3(1.0, 1.0, 1.0);\n        hit.emissive = vec3(1.0, 0.0, 0.0);\n        hit.roughness = 1.0;\n        hit.specular = 0.0;\n        hit.speccol = vec3(1.0);\n        hit.IOR = 1.0;\n    }*/\n    if (iBox(ro, rd, boxparams(vec3(0.0, 1.0, 0.0), -30.0, vec3(-1.0, -2.0, -6.0)), vec3(1.0, 2.0, 1.0), hit)) { //big box\n        hit.albedo = vec3(1.0, 1.0, 1.0);\n        hit.emissive = vec3(0.0, 0.0, 0.0);\n        hit.roughness = 0.0;\n        hit.specular = 0.0;\n        hit.speccol = vec3(1.0);\n        hit.IOR = 1.0;\n    }\n    if (iSphere(ro, rd, vec4(2.0, -3.0, -6.0, 1.0), hit)) {\n        hit.albedo = vec3(1.0, 1.0, 1.0);\n        hit.emissive = vec3(0.0, 0.0, 0.0);\n        hit.roughness = 0.0;\n        hit.specular = 1.0;\n        hit.speccol = vec3(1.0);\n        hit.IOR = 1.0;\n    }\n}\n\nvec3 shade(in vec3 ro, in vec3 rd, inout uint rngState) {\n    vec3 col = vec3(0.0);\n    vec3 through = vec3(1.0);\n    vec3 sunrd = normalize(vec3(0.25, 1.0, 0.5));\n    \n    for (int i = 0; i <= bounces; i++) {\n        hitinfo hit;\n        hitinfo sunhit;\n        hit.distance = far;\n        sunhit.distance = far;\n        scene(ro, rd, hit);\n        \n        if (hit.distance == far) {col += tonemap(texture(iChannel1, rd).rgb) * through * 0.5; break;}\n        \n        ro = (ro + rd * hit.distance) + hit.normal * 0.001;\n        \n        scene(ro, normalize(sunrd + randVec(rngState) * 0.025), sunhit);\n        \n        float specularChance = hit.specular;\n        if (specularChance > 0.0f) {\n            specularChance = fresnel(1.0, hit.IOR, rd, hit.normal, hit.specular, 1.0);\n        }\n        \n        float doSpecular = (RandomFloat01(rngState) < specularChance) ? 1.0f : 0.0f;\n        \n        vec3 diffuseRayDir = normalize(hit.normal + randVec(rngState));\n        vec3 specularRayDir = reflect(rd, hit.normal);\n        specularRayDir = normalize(mix(specularRayDir, diffuseRayDir, hit.roughness * hit.roughness));\n        rd = mix(diffuseRayDir, specularRayDir, doSpecular);\n        \n        col += hit.emissive * through;\n        \n        through *= mix(hit.albedo, hit.speccol, doSpecular);\n        \n        if (sunhit.distance == far) col += vec3(1.0, 0.8, 0.4) * 1.0 * through;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 m = iMouse;\n    m.x = m.x/iResolution.x;\n    m.y = m.y*2.0/iResolution.y;\n    m = m * 2.0 - 1.0;\n    m.x *= iResolution.x/iResolution.y;\n    \n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float distance = 1.0 / tan(90.0 * 0.5 * PI / 180.0);\n    \n    vec3 ro = vec3(0.0, 0.0, 4.0);\n    vec3 rd = normalize(vec3(uv, -distance));\n    \n    //ro = vec3(uv.x, uv.y + 1.0, 3.0);\n    //rd = vec3(0.0, 0.0, -1.0);\n    \n    \n    vec3 col = texture( iChannel0, fragCoord/iResolution.xy ).xyz;\n    float temp = texture( iChannel0, fragCoord/iResolution.xy ).w;\n    \n    if (iFrame == 0 || m.z > 0.0 || any(isnan(col))) {\n        col = vec3(0.0);\n        temp = 0.0;\n    }\n    \n    if (iMouse.x > 0.0) {\n        ro *= rotateX(m.y-1.5);\n        ro *= rotateY(m.x);\n        rd *= rotateX(m.y-1.5);\n        rd *= rotateY(m.x);\n    }\n\n    for (int i = 0; i < renders; i++) col += shade(ro, rd, rngState) / float(renders);\n    temp += 1.0;\n\n    fragColor = vec4(col,temp);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265358979323\n\nfloat far = 1000000.0;\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n \nvec3 linear(vec3 rgb) {\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n \nvec3 tonemap(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),\n        rgb / 12.92f,\n        LessThan(rgb, 0.04045f)\n    );\n}\n\nstruct hitinfo {\n    float distance;\n    vec3 normal;\n    vec3 emissive;\n    vec3 albedo;\n    float specular;\n    float roughness;\n    vec3 speccol;\n    float IOR;\n};\n\nmat4 rotate4( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\nfloat ScalarTriple(vec3 u, vec3 v, vec3 w) {\n    return dot(cross(u, v), w);\n}\n\nstruct box {\n    mat4 rot;\n\tmat4 tra;\n\tmat4 txi; \n\tmat4 txx;\n};\n\nbox boxparams(vec3 rotdir, float deg, vec3 loc) {\n    mat4 rot = rotate4(normalize(rotdir), radians(deg));\n\tmat4 tra = translate(loc.x, loc.y, loc.z);\n\tmat4 txi = tra * rot; \n\tmat4 txx = inverse( txi );\n    return box(rot, tra, txi, txx);\n}\n\nbool iSphere(in vec3 ro, in vec3 rd, in vec4 sph, inout hitinfo hit) {\n\tvec3 a = ro - sph.xyz;\n\tfloat b = dot(a, rd);\n\tfloat c = dot(a, a) - sph.w * sph.w;\n    \n    if (b > 0.0 && c > 0.0) return false;\n    \n\tfloat discr = b * b - c;\n    \n    if (discr < 0.0) return false;\n    \n    bool inside = false;\n    float dist = -b - sqrt(discr);\n    \n    if (dist < 0.0) {\n        inside = true;\n        dist = -b + sqrt(discr);\n    }\n    \n    if (dist > 0.001 && dist < hit.distance) {\n        hit.distance = dist;\n        hit.normal = normalize((ro + rd * dist) - sph.xyz) * (inside ? -1.0 : 1.0);\n        return true;\n    }\n    \n    return false;\n}\n\nbool iQuad(in vec3 rayPos, in vec3 rayDir, inout hitinfo info, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    // calculate normal and flip vertices order if needed\n    vec3 normal = normalize(cross(c-a, c-b));\n    if (dot(normal, rayDir) > 0.0f)\n    {\n        normal *= -1.0f;\n        \n\t\tvec3 temp = d;\n        d = a;\n        a = temp;\n        \n        temp = b;\n        b = c;\n        c = temp;\n    }\n    \n    vec3 p = rayPos;\n    vec3 q = rayPos + rayDir;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n    \n    // determine which triangle to test against by testing against diagonal first\n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;\n    if (v >= 0.0f)\n    {\n        // test against triangle a,b,c\n        float u = -dot(pb, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pb, pa);\n        if (w < 0.0f) return false;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*b+w*c;\n    }\n    else\n    {\n        vec3 pd = d - p;\n        float u = dot(pd, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pa, pd);\n        if (w < 0.0f) return false;\n        v = -v;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*d+w*c;\n    }\n    \n    float dist;\n    if (abs(rayDir.x) > 0.1f)\n    {\n        dist = (intersectPos.x - rayPos.x) / rayDir.x;\n    }\n    else if (abs(rayDir.y) > 0.1f)\n    {\n        dist = (intersectPos.y - rayPos.y) / rayDir.y;\n    }\n    else\n    {\n        dist = (intersectPos.z - rayPos.z) / rayDir.z;\n    }\n    \n\tif (dist > 0.001 && dist < info.distance)\n    {\n        info.distance = dist;        \n        info.normal = normal;        \n        return true;\n    }    \n    \n    return false;\n}\n\nbool iBox(in vec3 ro, in vec3 rd, in box box, in vec3 rad, inout hitinfo hit) {\n    mat4 txx = box.txx;\n    mat4 txi = box.txi;\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n    vec3 m = 1.0/rdd;\n    \n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max(max(t1.x,t1.y),t1.z);\n    float tF = min(min(t2.x,t2.y),t2.z);\n    \n\tif( tN>tF || tF<0.0 ) {tN = far; return false;}\n\n    vec4 res = vec4(tN, step(tN,t1));\n\n    if (tN > 0.001 && tN < hit.distance) {\n    hit.distance = tN;\n    hit.normal = (txi * vec4(-sign(rdd)*res.yzw,0.0)).xyz;\n\n\treturn true; }\n}","name":"Common","description":"","type":"common"}]}