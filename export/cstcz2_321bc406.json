{"ver":"0.1","info":{"id":"cstcz2","date":"1695251371","viewed":102,"name":"2.5d shading test","username":"stb","description":"A sanity check\n\nAs it turns out, it's best to evaluate stuff in a 3d way... even for 2.5 things.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["2d","refraction","shading","specular","25d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n   \n*/\n\n#define res iResolution.xy\n\nfloat s, c;\n#define rotate(p, a) mat2(c=cos(a), s=-sin(a), -s, c) * p\n\n// checker pattern\nfloat checker(in vec2 p) {\n    return float( mod(floor(p.x*4.), 2.)<1. ^^ mod(floor(p.y*4.), 2.)<1. );\n}\n\n// the shape (value=height)\nfloat map(vec2 p) {\n    \n    // rotation, translation\n    p = rotate(p, .03*iTime);\n    p -= .1 * iTime;\n    \n    // repetition\n    p = fract(p)-.5;\n    p *= 2.;\n    \n    // a 2d spherical shape\n    return .25 * sqrt(max(0., 1.-(p.x*p.x+p.y*p.y)));\n}\n\n// distance estimate (a camera-facing height map)\nfloat de(vec3 p) {\n    return p.z - map(p.xy);\n}\n\n// surface normal\nvec3 getNorm(vec3 p) {\n    vec3 o = 1. * vec3(-1., 0., 1.) / res.y;\n    return\n        normalize(\n            vec3(\n                de(p-o.xyy) - de(p-o.zyy),\n                de(p-o.yxy) - de(p-o.yzy),\n                //de(p-o.yyz) - de(p-o.yyx)\n                2.*o.x\n            )\n        );\n}\n\n\nvoid mainImage(out vec4 fo, in vec2 fc) {\n    vec2 uv = fc.xy / res;\n    vec2 p = (fc.xy-res/2.) / res.y;\n    \n    // zoom amount\n    float zoom = .37;\n    \n    p /= zoom;\n    \n    vec3 rpos = vec3(p, -10.);\n    vec3 rdir = vec3(0., 0., 1.);\n    vec3 rhit = vec3(rpos.xy, -map(rpos.xy));\n    \n    // mouse position\n    vec2 m = (iMouse.xy-res/2.) / res.y / zoom;\n    \n    // output rgb value\n    vec3 rgb;\n    \n    // light position\n    vec3 lpos = vec3(m, -1.) - rhit;\n    if(iMouse.w>=0.)\n        lpos = 1.7 * vec3(sin(.7*iTime), cos(.7*iTime), -1.) - rhit;\n    \n    // light color\n    vec3 lcol = 1. * vec3(3., 2.7, 2.3);\n    \n    // light distance\n    float ldist = pow(length(lpos), 2.);\n    \n    // normal\n    vec3 norm = getNorm(rhit);\n    \n    // diffuse\n    float brilliance = 2.;\n    vec3 diff = .0533 * vec3(.9, .8, .7) * pow(max(0., 1.-dot(-lpos, norm)), brilliance) / ldist;\n    \n    // reflection vector\n    vec3 refl = normalize(reflect(-lpos, norm));\n    \n    // specular hightlight\n    float spec = 1.5 * pow(clamp(.525*(1.-.93*dot(refl, rdir)), 0., 1.), 256.);\n    \n    // refraction vector\n    vec2 refr = (p + .1*iTime + 4.*normalize(refract(vec3(0,0,1), norm, 1./1.5)).xy) ;\n    \n    // refracted background\n    rgb = vec3(.5, .9, 1.) * mix(.5, checker(refr.xy+.0002*iTime), .35);\n    \n    // multiply rgb with map (fake density)\n    rgb *= 1. - 3.*map(rhit.xy);\n    \n    // apply diffuse\n    rgb += lcol * diff;\n    \n    // apply specular\n    float aoi = 1.05 - dot(vec3(0,0,-1), norm);\n    rgb += lcol * spec * aoi;\n    \n    //rgb = vec3(aoi);\n    \n    // output\n    fo = vec4(rgb, 1.);\n}","name":"Image","description":"","type":"image"}]}