{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"const float PI = 3.141592653589793;\nconst float TAU = 2.0 * PI;\nconst float TAU_INVERSE = 1.0 / TAU;\n\nvec2 uv2xy(vec2 uv) {\n    float aspect = iResolution.y / iResolution.x;\n    return 2.0 * (uv - vec2(0.5)) * vec2(1.0, aspect);\n}\n\nvec2 xy2polar(vec2 xy) {\n    return vec2(\n        length(xy),\n        atan(xy.y, xy.x)\n    );\n}\n\nvec2 polar2xy(vec2 polar) {\n    float r = polar.x;\n    float a = polar.y;\n    return vec2(\n        r * cos(a),\n        r * sin(a)\n    );\n}\n\nconst vec3 COLOR1 = vec3(1.0, 0.666, 0.0);\nconst vec3 COLOR2 = vec3(0, 0.333, 1.0);\n\nfloat between(float a, float b, float t1, float t2) {\n  float v = 0.5 + 0.25 * (sin(t1) + cos(t2));\n  return a + (b - a) * v;\n}\n\nvec2 findDisk(vec2 polar, float time, float i, float minSectors, float sectorsScale) {\n    float threshold = between(0.2, 0.4, time * 0.001074, time * 0.001247);\n    float len = polar.x;\n    float ang = polar.y;    \n    if (len < threshold) {\n        float spiral = between(-10.0, 10.0, time * 0.001078, time * 0.001777);\n        float ellipse = 0.8 - sin(ang * 4.0) * 0.2;\n        return vec2(ellipse * len / threshold, ang + time * 0.001 + spiral * len);\n    }\n    \n    float sectors = floor(i * 1.0 + minSectors);\n    float len2 = threshold + 0.5 * (1.0 - threshold);    \n    float ang2 = TAU * (0.5 + floor(ang * TAU_INVERSE * sectors)) / sectors;\n    vec2 center = polar2xy(vec2(len2, ang2));\n    vec2 xy = polar2xy(polar) - center;\n    vec2 polar2 = xy2polar(xy);\n    float effect = between(0.0, 4.0, i * time * 0.001574, -time * 0.000754);\n    polar2.x *= effect / (1.0 - threshold);\n    polar2.y += i * between(-2.0, 2.0, time * 0.000451, time * 0.0004995);\n    return polar2;\n}\n\nvec3 computeColor(float time, vec2 polar, vec3 colSub, vec3 colAdd, float minSectors, float sectorsScale) {\n    vec3 col = colSub;\n    for (float i=0.0; i<8.0; i++) {\n        float a = smoothstep(0.49, 0.51, polar.x);\n        col += (mix(colSub, colAdd, a) - mix(colAdd, colSub, a)) * 0.1;\n        float light = 1.0 - smoothstep(0.75, 1.0, polar.x);\n        col *= 0.7 + (light * .3);\n        vec3 tmp = colAdd;\n        colAdd = colSub;\n        colSub = tmp;\n        polar = findDisk(polar, time, i, minSectors, sectorsScale);\n    }\n    return col;\n}\n\nfloat getSectorsMin(float stageI) {\n  return floor(between(2.0, 23.0, stageI, stageI * stageI));\n}\n\nfloat getSectorsScale(float stageI) {\n  return floor(between(0.0, 4.0, 74.458 * stageI, stageI * 7.14545));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 1000.0;    \n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 xy = uv2xy(uv);\n    vec2 polar = xy2polar(xy);\n    float stage = time * 0.0001;\n    float stageI = floor(stage);\n    float stageF = fract(stage);\n    \n    time *= .25;\n    vec3 colSub = COLOR1;\n    vec3 colAdd = COLOR2;\n    vec3 col1 = computeColor(time, polar, colSub, colAdd, getSectorsMin(stageI), getSectorsScale(stageI));\n    vec3 col2 = computeColor(time, polar, colSub, colAdd, getSectorsMin(stageI + 1.0), getSectorsMin(stageI + 1.0));\n    \n    vec3 col = mix(col1, col2, smoothstep(0.9, 1.0, stageF));\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lcyBDR","date":"1733946280","viewed":63,"name":"Fast Pseudo-Fractal 1","username":"tolokoban","description":"A fast pseudo-fractal","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""}}