{"ver":"0.1","info":{"id":"MdtGWS","date":"1452033339","viewed":668,"name":"Test: quick DOF","username":"TambakoJaguar","description":"I try to test/develop a technique using buffers to quickly achieve a (imprecise) depth of field effect.\nWhat is dumb is that the raymarching code is kinda duplicated, and it has problems and glitches, but maybe this could be used in the future...","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarching","blur","depthoffield","gaussian","buffer","multipass","mataballs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int blur_size = 30;\nconst float blur_width = 1.;\n\nfloat gauss(float x, float e)\n{\n    return exp(-pow(x, 2.)/e); \n}\n\n// Vertical blurring\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 pos = fragCoord.xy / iResolution.xy;\n   vec4 pixval = vec4(0.);\n   float tot = 0.;\n    \n   const int nb = 2*blur_size+1;\n   \n   for (int x=0; x<nb; x++)\n   { \n       float x2 = blur_width*float(x-blur_size);\n       vec2 ipos = pos + vec2(0., x2/iResolution.x);\n       float g = gauss(x2, float(20*blur_size)*min(texture(iChannel0, pos).r, texture(iChannel0, ipos).r));\n       pixval+= g*texture(iChannel1, ipos);\n       tot+= g;\n   }\n   fragColor = pixval/tot;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define pi 3.141593\n\nstruct RenderData\n{\n  vec3 col;\n  vec3 pos;\n  vec3 norm;\n  int objnr;\n};\n\nvec3 campos = vec3(0., 3., 12.);\nvec3 camtarget = vec3(0., 0., 0.);\nvec3 camdir = vec3(0., -0.3, -1.);\nconst float focusdist = 12.5;\nconst float dof = 1.3;\nconst float focwidth = 3.5;\nfloat fov = 2.5;\n\nconst vec3 ambientColor = vec3(0.1, 0.4, 0.9);\nconst float ambientint = 0.2;\n\nvec3 colors[3];\n\nconst float maxdist = 70.;\n\nconst float flpos = 3.3;\n\nvec4 hex;\nconst float hexts = 1.9;\nconst float hexth = 0.1;\nconst float hexbw = 0.15;\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) + vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) - vect.y*cos(angle);\n    return rv;\n}\n\nfloat obj(vec3 pos)\n{\n    return length(pos);\n}\n\nfloat floorm(vec3 pos)\n{\n    return pos.y + flpos;\n}\n\nfloat map(vec3 pos)\n{\n    vec2 d = vec2(2. + 0.55*sin(iTime*1.2), 0.); \n    float s1 = 1./pow(obj(pos + vec3(rotateVec(d, 0.), 0.)), 2.);\n    float s2 = 1./pow(obj(pos + vec3(rotateVec(d, 2./3.*pi), 0.)), 2.);\n    float s3 = 1./pow(obj(pos + vec3(rotateVec(d, 4./3.*pi), 0.)), 2.);\n    return min(1. - (s1 + s2 + s3)*2., floorm(pos));\n}\n\nvec2 trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = 3.0;\n    vec3 pos;\n  \tfor (int i = 0; i < 128; ++i)\n    {\n    \tpos = ray*t + cam;\n    \tfloat dist = map(pos);\n        if (dist>maxdist || abs(dist)<0.01)\n            break;\n        t+= dist;\n  \t}\n  \treturn vec2(t, pos);\n}\n\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\n// Sets the position of the camera with the mouse and calculates its direction\nvoid setCamera()\n{\n   vec2 iMouse2;\n   if (iMouse.x==0. && iMouse.y==0.)\n      iMouse2 = iResolution.xy*vec2(0.5, 0.5);\n   else\n      iMouse2 = iMouse.xy;\n   \n   campos = vec3(-20.*cos(0.4 + 2.8*iMouse2.x/iResolution.x),\n                 20.*cos(2.*iMouse2.y/iResolution.y),\n                 20.*sin(0.4 + 2.8*iMouse2.x/iResolution.x)*sin(2.*iMouse2.y/iResolution.y));\n   camdir = camtarget - campos;   \n}\n\nvec2 render(vec2 fragCoord)\n{  \n  vec2 uv = fragCoord.xy / iResolution.xy; \n  uv = uv*2.0 - 1.0;\n  uv.x*= iResolution.x / iResolution.y;\n\n  vec3 ray = GetCameraRayDir(uv, camdir, fov);\n    \n  return trace(campos, ray, maxdist);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    setCamera();\n    vec2 renderDat = render(fragCoord);\n    fragColor = vec4(focwidth*pow(length(renderDat.y - camtarget)/maxdist, dof));       \n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n\"Sine metaballs\" by Emmanuel Keller aka Tambako - December 2015\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.141593\n\nstruct Lamp\n{\n  vec3 position;\n  vec3 color;\n  float intensity;\n  float attenuation;\n};\n\nstruct RenderData\n{\n  vec3 col;\n  vec3 pos;\n  vec3 norm;\n  int objnr;\n};\n    \n    \nLamp lamps[3];\n\nvec3 campos = vec3(0., 3., 12.);\nvec3 camtarget = vec3(0.);\nvec3 camdir = vec3(0., -0.3, -1.);\nfloat fov = 2.5;\n\nconst vec3 ambientColor = vec3(0.1, 0.4, 0.9);\nconst float ambientint = 0.2;\n\nvec3 colors[3];\n\n#define specular\nconst float specint = 0.28;\nconst float specshin = 30.;\nconst float aoint = 0.0;\nconst float shi = 0.8;\nconst float shf = 0.5;\n\nconst float normdelta = 0.002;\nconst float maxdist = 70.;\n\nconst float flpos = 3.3;\n\nvec4 hex;\nconst float hexts = 1.9;\nconst float hexth = 0.1;\nconst float hexbw = 0.15;\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.8;\nconst int aasamples = 2;\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) + vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) - vect.y*cos(angle);\n    return rv;\n}\n\n// From https://www.shadertoy.com/view/Xd2GR3\nvec4 hexagon(vec2 p) \n{\n\tvec2 q = vec2( p.x*2.0*0.5773503, p.y + p.x*0.5773503 );\n\t\n\tvec2 ppi = floor(q);\n\tvec2 pf = fract(q);\n\n\tfloat v = mod(ppi.x + ppi.y, 3.0);\n\n\tfloat ca = step(1.0,v);\n\tfloat cb = step(2.0,v);\n\tvec2  ma = step(pf.xy,pf.yx);\n\t\n    // distance to borders\n\tfloat e = dot( ma, 1.0-pf.yx + ca*(pf.x+pf.y-1.0) + cb*(pf.yx-2.0*pf.xy) );\n\n\t// distance to center\t\n\tp = vec2( q.x + floor(0.5+p.y/1.5), 4.0*p.y/3.0 )*0.5 + 0.5;\n\tfloat f = length( (fract(p) - 0.5)*vec2(1.0,0.85) );\t\t\n\t\n\treturn vec4( ppi + ca - cb*ma, e, f );\n}\n\nvec3 getHexagonColor(vec4 hex, float nbcols)\n{\n    colors[0] = vec3(.95, .88, .75);\n    colors[1] = vec3(.45, .65, .9);\n    colors[2] = vec3(.6, .9, .3);\n    \n    int colnr = int(mod(hex.x, nbcols));\n    /*vec3 color = vec3(mod(colnr, 3.)==0., mod(colnr, 3.)==1., mod(colnr, 3.)==2.);\n    if (colnr>2.)\n        color = vec3(1.) - color;\n    \n    vec3 color2 = vec3(0.5*color.r + 0.3*color.g + 0.7*color.b,\n                       0.3*color.r + 0.7*color.g + 0.4*color.b,\n                       0.8*color.r + 0.5*color.g + 0.3*color.b);*/\n    \n    vec3 color2 = colnr==0?colors[0]:(colnr==1?colors[1]:colors[2]);\n    \n    return color2;\n}\n\nfloat obj(vec3 pos)\n{\n    return length(pos);\n}\n\nfloat floorm(vec3 pos)\n{\n    hex = hexagon(pos.xz/hexts);\n    return pos.y + flpos;\n}\n\nfloat map(vec3 pos, bool nofloor)\n{\n    vec2 d = vec2(2. + 0.55*sin(iTime*1.2), 0.); \n    float s1 = 1./pow(obj(pos + vec3(rotateVec(d, 0.), 0.)), 2.);\n    float s2 = 1./pow(obj(pos + vec3(rotateVec(d, 2./3.*pi), 0.)), 2.);\n    float s3 = 1./pow(obj(pos + vec3(rotateVec(d, 4./3.*pi), 0.)), 2.);\n    if (nofloor)\n        return 1. - (s1 + s2 + s3)*2.;\n    else   \n        return min(1. - (s1 + s2 + s3)*2., floorm(pos));\n}\n\nfloat trace(vec3 cam, vec3 ray, float maxdist, bool nofloor) \n{\n    float t = 3.0;\n  \tfor (int i = 0; i < 128; ++i)\n    {\n    \tvec3 pos = ray*t + cam;\n    \tfloat dist = map(pos, nofloor);\n        if (dist>maxdist || abs(dist)<0.01)\n            break;\n        t+= dist;\n  \t}\n  \treturn t;\n}\n\n// From https://www.shadertoy.com/view/MstGDM\nvec3 getNormal(vec3 pos, float e)\n{\n    vec2 q = vec2(0, e);\n    return normalize(vec3(map(pos + q.yxx, false) - map(pos - q.yxx, false),\n                          map(pos + q.xyx, false) - map(pos - q.xyx, false),\n                          map(pos + q.xxy, false) - map(pos - q.xxy, false)));\n}\n\nvec3 floor_color()\n{\n    return getHexagonColor(hex, 3.);\n}\n\nvec3 obj_color(vec3 norm, vec3 pos)\n{\n    vec2 d = vec2(2. + 0.8*sin(iTime*1.2), 0.); \n    float s1 = 1./pow(length(pos + vec3(rotateVec(d, 0.), 0.)), 2.);\n    float s2 = -1./pow(length(pos + vec3(rotateVec(d, 2./3.*pi), 0.)), 2.);\n    float s =  s1 + s2;\n    vec3 col1 = mix(vec3(1., 0.1, 0.1), vec3(0.1, 1., 0.1), clamp(s*6. + 0.6, 0.1, 0.9));\n     \n    s = 1./pow(length(pos + vec3(rotateVec(d, 4./3.*pi), 0.)), 2.);\n    return mix(col1, vec3(0.1, 0.1, 1.0), clamp(s*6. - 0.6, 0.1, 0.9));\n}\n\nvec3 sky_color(vec3 ray)\n{\n    return ambientColor + vec3(0.4, 0.3, 0.05)*2.8*(0.6-atan(ray.y)); \n}\n\n// From https://www.shadertoy.com/view/Xds3zN;\nfloat softshadow(vec3 ro, vec3 rd, float mint, float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n    \tfloat h = map(ro + rd*t, false);\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.0001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol)\n{\n\tvec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n      \n    // Diffuse shading\n    vec3 col = ocol*normalize(lamp.color)*lamp.intensity*clamp(dot(norm, pli), 0., 1.);\n    \n    // Specular shading\n    #ifdef specular\n    if (dot(norm, lamp.position - pos) > 0.0)\n        col+= vec3(1., 0.7, 0.3)*normalize(lamp.color)*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    // Softshadow\n    col*= shi*softshadow(pos, normalize(lamp.position-pos), shf, 50.) + 1. - shi;\n    \n    return col;\n}\n\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<3; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\n// Sets the position of the camera with the mouse and calculates its direction\nvoid setCamera()\n{\n   vec2 iMouse2;\n   if (iMouse.x==0. && iMouse.y==0.)\n      iMouse2 = iResolution.xy*vec2(0.5, 0.5);\n   else\n      iMouse2 = iMouse.xy;\n   \n   campos = vec3(-20.*cos(0.4 + 2.8*iMouse2.x/iResolution.x),\n                 20.*cos(2.*iMouse2.y/iResolution.y),\n                 20.*sin(0.4 + 2.8*iMouse2.x/iResolution.x)*sin(2.*iMouse2.y/iResolution.y));\n   camdir = camtarget-campos;   \n}\n\nRenderData trace0(vec3 tpos, vec3 ray, bool nofloor)\n{\n    float tx = trace(tpos, ray, maxdist, nofloor);\n    vec3 col;\n    int objnr;\n    \n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    if (tx<maxdist*0.97)\n    {\n        norm = getNormal(pos, normdelta);\n\n        // Coloring\n        if (pos.y<=-flpos+0.01)\n        {\n           col = floor_color();\n           objnr = 1;\n        }\n        else\n        {\n           col = obj_color(norm, pos);\n           objnr = 2;\n        }\n      \n        // Shading\n        col = ambientColor*ambientint + lampsShading(norm, pos, col);\n  }\n  else\n  {\n      // Sky\n      col = sky_color(ray);\n      objnr = 3;\n  }\n  return RenderData(col, pos, norm, objnr);\n}\n\nvec4 render(vec2 fragCoord)\n{\n  lamps[0] = Lamp(vec3(-5., 3.5, 10.), vec3(1., 1., 1.), 3.2, .05);\n  lamps[1] = Lamp(vec3(8., 0.3, 5.), vec3(1.0, 0.75, 0.75), 2.0, 0.01);\n  lamps[2] = Lamp(vec3(-9., -0.5, -6.), vec3(0.7, 0.8, 1.0), 5.0, 0.15);\n    \n  vec2 uv = fragCoord.xy / iResolution.xy; \n  uv = uv*2.0 - 1.0;\n  uv.x*= iResolution.x / iResolution.y;\n\n  vec3 ray = GetCameraRayDir(uv, camdir, fov);\n    \n  RenderData traceinf = trace0(campos, ray, false);\n  vec3 col = traceinf.col;\n  /*if (traceinf.objnr==1)\n  {\n     RenderData traceinf_floor = trace0(traceinf.pos, reflect(ray,traceinf.norm), true);\n     col = 0.3*traceinf_floor.col + 0.7*col;\n     //col = traceinf_floor.col;\n  }*/\n\n  return vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    setCamera();\n    \n    // Antialiasing\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vs/vec4(aasamples*aasamples);       \n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"const int blur_size = 30;\nconst float blur_width = 1.;\n\nfloat gauss(float x, float e)\n{\n    return exp(-pow(x, 2.)/e); \n}\n\n// Horizontal blurring\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 pos = fragCoord.xy / iResolution.xy;\n   vec4 pixval = vec4(0.);\n   float tot = 0.;\n    \n   const int nb = 2*blur_size+1;\n   \n   for (int x=0; x<nb; x++)\n   { \n       float x2 = blur_width*float(x-blur_size);\n       vec2 ipos = pos + vec2(x2/iResolution.x, 0.);\n       float g = gauss(x2, float(20*blur_size)*min(texture(iChannel0, pos).r, texture(iChannel0, ipos).r));\n       pixval+= g*texture(iChannel1, ipos);\n       tot+= g;\n   }\n   fragColor = pixval/tot;\n}","name":"Buf C","description":"","type":"buffer"}]}