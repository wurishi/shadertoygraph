{"ver":"0.1","info":{"id":"MtGSzW","date":"1483191363","viewed":216,"name":"Mandelbrot Minimap","username":"ptrgags","description":"Mandelbrot set with a minimap to select points of interest.\nControls: Click and hold over a point in the minimap. Drag the mouse around to zoom.\n\nNot the best UI, but I don't feel like setting up a buffer just to cache the last mouse click.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","mandelbrot","minimap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_ITERATIONS 1000.0\n#define MIN_ZOOM 25.0\n#define MAX_ZOOM 50000.0\n#define CENTER (iResolution.xy / 2.0)\n#define MINIMAP_ZOOM 75.0\n#define MINIMAP_CENTER (0.75 * iResolution.xy)\n#define MINIMAP_CENTER_COMPLEX vec2(-0.55, 0.0)\n\nfloat mandelbrot(vec2 c) {\n    //z = 0 + 0i\n    float a = 0.0;\n    float b = 0.0;\n    \n    for (float i = 0.0; i < NUM_ITERATIONS; i++) {\n        //Calculate z^2\n        float re = a * a - b * b + c.x;\n        float im = 2.0 * a * b + c.y;\n\n        //If we escaped the circle, return the number\n        //of completed iterations\n        if ((re * re + im * im) > 4.0)\n            return i + 1.0;\n\n        //Update for the next iteration\n        a = re;\n        b = im;\n    }\n\n    //If we reached here, return 0 to indicate no divergence\n    return 0.0;\n}\n\n\n//Calculate colors\n//based on the normalized number of iters\nvec4 mandelbrot_gradient(float val) {\n    //Colors to use\n    vec4 black = vec4(0.0);\n    vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 blue2 = vec4(0.0, 0.5, 1.0, 1.0);\n    vec4 cyan = vec4(0.0, 1.0, 1.0, 1.0);\n    vec4 white = vec4(1.0);\n    \n    //stops\n    float stop1 = 0.1;\n    float stop2 = 0.2;\n    float stop3 = 0.4;\n    \n    //multi-stop graident technique from Stack Overflow:\n    //http://stackoverflow.com/questions/15935117/how-to-create-multiple-stop-gradient-fragment-shader\n    vec4 color;\n    color = mix(black, blue, smoothstep(0.0, stop1, val));\n    color = mix(color, blue2, smoothstep(stop1, stop2, val));\n    color = mix(color, cyan, smoothstep(stop2, stop3, val));\n    color = mix(color, white, smoothstep(stop3, 1.0, val));\n    return color;\n}\n\n//Convert mouse screen coodrinates (clamped to minimap)\n//to a point in the complex plane\nvec2 minimap_to_complex(vec2 mouse_mini) {\n    //Move to center of minimap\n    vec2 centered = mouse_mini - MINIMAP_CENTER;\n    vec2 complex = centered / MINIMAP_ZOOM + MINIMAP_CENTER_COMPLEX;\n    return complex;\n}\n\n//Get the screen coord in the minimap that \n//coresponds to the complex number specified\nvec2 complex_to_minimap(vec2 complex) {\n\tvec2 centered = (complex - MINIMAP_CENTER_COMPLEX) * MINIMAP_ZOOM;\n   \tvec2 mouse_mini = centered + MINIMAP_CENTER;\n   \treturn mouse_mini;\n}\n\n//Draw a minimap in the top-right corner of the screen\nvec4 mandelbrot_minimap(vec2 screen_coord) {\n    //center the coordinates in the box\n    vec2 point = screen_coord - iResolution.xy * 0.75;\n    \n    //shift/scale the minimap a little\n    vec2 minimap_centered = point / 75.0 + vec2(-0.55, 0);\n    \n    float iters = mandelbrot(minimap_centered);\n    float val = iters / NUM_ITERATIONS;\n    return mandelbrot_gradient(val);\n}\n\n//Use mouse click position or default to a point\n//in the seahorse valley\nvec2 minimap_mouse() {\n    //Default point in Seahorse Valley\n    if (any(lessThan(iMouse.zw, CENTER)))\n        return complex_to_minimap(vec2(-0.745, 0.1));\n   \telse\n        return iMouse.zw;\n}\n\n//Use the minimap \nvec2 point_of_interest() {\n    //vec2 mouse = clamp(iMouse.zw, CENTER, iResolution.xy);\n    vec2 mouse = minimap_mouse();\n    return minimap_to_complex(mouse);\n}\n\nvec4 mandelbrot_zoom(vec2 screen_coord) {\n   \tvec2 mouse_uv = iMouse.xy / iResolution.xy;\n    \n    //Fix the preview\n    if (mouse_uv == vec2(0.0))\n        mouse_uv = vec2(0.5);\n    \n    //Calculate the zoom amount\n    float zoom = mix(MIN_ZOOM, MAX_ZOOM, mouse_uv.x);\n    \n    //Seahorse Valley\n    //vec2 point_of_interest = vec2(-0.745, 0.1);\n    vec2 poi = point_of_interest();\n    \n    //Centered screen coordinatees\n\tvec2 centered = screen_coord - CENTER;\n    \n    //Pan and zoom\n    vec2 point = centered / zoom + poi;\n    \n    //Do Mandelbrot set calculations\n    float iters = mandelbrot(point);\n    float val = iters / NUM_ITERATIONS;\n    \n    return mandelbrot_gradient(val);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    //Draw the minimap\n    if (all(greaterThan(fragCoord, CENTER)))\n        fragColor = mandelbrot_minimap(fragCoord);\n    //Draw a border around the minimap\n    else if (all(greaterThan(fragCoord, CENTER - vec2(3.0))))\n        fragColor = vec4(1.0, 0.5, 0.0, 1.0);\n    //Use the rest of the screen to draw the zoomed-in fractal\n    else\n        fragColor = mandelbrot_zoom(fragCoord);\n    \n    vec2 poi = minimap_mouse();\n    float dist = distance(fragCoord, poi);\n    if (10.0 < dist && dist < 12.0)\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}","name":"Image","description":"","type":"image"}]}