{"ver":"0.1","info":{"id":"3tyXWd","date":"1586100932","viewed":134,"name":"electric cubemap rain","username":"Carandiru","description":"// original shader borrowed from Fabrice Neyret @ https://www.shadertoy.com/view/wtGXzc (thank u)\n// as the template and base of this shader\n\nlooking inside of the cube map, with what would be faces of a view into the \"rain\" in that particular direction. ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["rain","cubenap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// original shader borrowed from Fabrice Neyret @ https://www.shadertoy.com/view/wtGXzc (thank u)\n// as the template and base of this shader\n\n// looking inside of the cube map, with what would be faces of a view \n// into the \"rain\" in that particular direction. \n\n// carandiru\n// http://bit.ly/supersinfulsilicon\n\n\n\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 uv = u.xy / R.xy * 2.0 - 1.0;\n\tuv.y *= iResolution.y / iResolution.x;\n    \n    vec3 rayDir = normalize(vec3(uv, 1.0));\n\trayDir.xz *= rot(PI*.5);   \n    \n    vec2 rotv = vec2(0);\n    if (iMouse.z > 0.0) {\n        rotv = vec2((iMouse.xy - iResolution.xy*0.5)*0.01);\n    } else {\n        rotv = vec2(iTime*0.1, sin(iTime*0.3)*0.3);\n    }\n    \n    mat2 rot1 = rot(rotv.x);\n    mat2 rot2 = rot(-rotv.y);\n    rayDir.xy *= rot2;\n    rayDir.xz *= rot1;\n    \n \t//O.rgb = mix(royal_purple, royal_blue, .5-.5*rayDir.y);\n\n   // O.b = .7 * ( .5+.5*rayDir.y );       // background env\n    //O.r = .3 * ( .5-.5*rayDir.y );\n\n    vec4 T = texture(iChannel0, rayDir); // dynamic env\n    O = T + abs(mix(O, T, T.a));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define PI (3.14159265358979323846)\n#define GOLDEN_RATIO (1.61803398874989484820)\n\n    \n#define R         iResolution.xy\n\n//#define rot(a)    mat2 ( cos(a+vec4(0,11,33,0)) )\n#define hash12(p) fract(sin((p)*vec2(127.1,311.7)) *43758.5453123)\n#define viewAngle texelFetch(iChannel1, ivec2(0), 0)\n#define viewDir   ray(vec2(0))\n#define drop(i)   texelFetch(iChannel1, ivec2(i,0), 0)\n#define zoom      texelFetch(iChannel1, ivec2(2), 0).x\n\n#define sq(x) (x*x)\n\n// rgb(0.222f,0.222f,1.0f) (far depth color) - royal blue (cooler)\nconst vec3 royal_blue = vec3(0.222f,0.222f,1.0f); // components are maximized\n// rgb(0.80f,0.65f,1.0f) (near depth color) - royal purle (warmer) \nconst vec3 royal_purple = (mix(royal_blue, vec3(0.80f,0.65f,1.0f), 0.5f)); // components are maximized\n\n/*\nvec3 dir;\n\n#define ray(U) (                     \\\n    dir = normalize(vec3(U,zoom)),   \\\n    dir.xz *= rot(viewAngle.x),      \\\n    dir.yz *= rot(viewAngle.y),      \\\n    dir )\n*/\n\n// 2D Weyl hash 32-bit XOR  - https://www.shadertoy.com/view/4dlcR4\n\n#define _W0 0x3504f335u   \n#define _W1 0x8fc1ecd5u  \n#define _W2 0xbb67ae85u\n#define _W3 0xf1bbcdcbu\n\n// 741103597u, 1597334677u, 204209821u, 851723965u  // MLCG constants\n#define _M0 741103597u    \n#define _M1 1597334677u\n#define _M2 204209821u\n#define _M3 851723965u\n\n#define _FSCALE 256.0f\n#define _FNORM (1.0f/16777216.0f/_FSCALE)\n\nuvec2 base_hash_2D(in uvec2 n)\n{\n  n.x *= _W0;   // x' = Fx(x)\n  n.y *= _W1;   // y' = Fy(y)\n  n.x ^= n.y;    // combine\n\n  return( (n.x * uvec2(_M0, _M1)) ^ (n.x >> 16) ); // MLCG constant\n}\n\nvec2 hash22(in vec2 xy)\n{\n\treturn vec2(base_hash_2D(uvec2(_FSCALE * xy))) * _FNORM;\n}\n\nvec2 V;\n#define rot(a) mat2( V= sin(vec2(1.57, 0) + a), -V.y, V.x)\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"// original shader borrowed from Fabrice Neyret @ https://www.shadertoy.com/view/wtGXzc (thank u)\n// as the template and base of this shader\n\n// looking inside of the cube map, with what would be faces of a view \n// into the \"rain\" in that particular direction. \n\n// carandiru\n// http://bit.ly/supersinfulsilicon\n\n\nvec3 cartToSphere(vec3 cart) {\n    \n    float r = dot(cart,cart);\n    vec3 n = cart / (r);\n    return vec3(atan(n.x, n.z), asin(n.y), 1.0/(1.0+r*r));\n}\n\nvoid mainCubemap( out vec4 O, vec2 U, vec3 rayOri, vec3 rayDir )\n{\n    O = texture(iChannel0, rayDir) * .995; // faded past\n    \n    //vec2 face_uv = fract(U/R.y*vec2(1, -1));//U.xy/R;\n    vec2 face_uv = U/R * 2.0f - 1.0f;\n\n    vec2 blue_noise = textureLod(iChannel2, (face_uv), 0.0f).rg;\n   // vec2 radial;\n    //radial = ((R.y*(blue_noise-0.5))/R.x);   // this ends up -1.0f...1.0f range\n\t\n    //float L = length(rayDir);\n    \n    vec3 color = vec3(0);\n     \n    vec3 ruv = cartToSphere(rayDir) * 0.5f + 0.5f;\n    \n    #define layers ((18.0f))\n    for ( float layer = layers; layer >= 0.0f ; --layer )\n    {\n        vec3 st = vec3((ruv.x - 0.5), (ruv.y * 0.02), (ruv.z - 0.5));\n        \n        // bluenoise here helps with aliasing\n        st += vec3(iTime*.015+(ruv.z*0.5f)+blue_noise.x*.0009, \n                   iTime*.012, \n                   iTime*.015+(ruv.x*0.5f)+blue_noise.y*.0009) * abs((layer));\n\n        vec3 samp = texture(iChannel3, st).rgb;\n        float f = mix(samp.r, mix(samp.g, samp.b, 0.5f), 0.5f);\n        f = pow(f, 23.0) * 13.0;\n\n        color += f * royal_purple * (1.0f - color);\n    }\n    \n    //float checker = step(0.5f, texture( iChannel1, (ruv) ).r);\n    //color += checker * 0.95;\n    //color += mix(color * sqrt(royal_blue), color, color * length(uv));\n    \n    //#define gradient (ruv)\n    //color *= vec3(gradient.x, 0.0f, gradient.y);\n    \n    O = vec4(mix(O.rgb, color, 0.5f),1);\n    \n}","name":"Cube A","description":"","type":"cubemap"}]}