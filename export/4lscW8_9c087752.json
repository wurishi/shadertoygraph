{"ver":"0.1","info":{"id":"4lscW8","date":"1504680267","viewed":296,"name":"Reflections practice","username":"balintfodor","description":"Playing with reflections. Improvements and suggestions are welcome.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","reflections","smin","multiplerays","cameralookat"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPS 0.001\n#define CAM_NEAR 0.1\n#define CAM_FAR 20.\n#define MAX_ITER 128\n#define MAX_RAYS 8\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat dSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat dPlane(vec3 p, vec3 n)\n{\n    return dot(p, n);\n}\n\nvec3 elevate(float freq, float phase, float amp)\n{\n    return vec3(0., sin(iTime*freq + phase)*amp, 0.);\n}\n\nfloat dScene(vec3 p)\n{\n    // TODO: find a cheaper way to get the sdf and do the motion\n    float k = 0.3;\n    float d = dPlane(p + vec3(0., 0.0, 0.), vec3(0., 1., 0.));\n   \td = smin(d, dSphere(p + elevate(1., 0., 1.), 1.), k);\n    for (int i = 0; i < 3; ++i) {\n        float t = radians(float(i) / 3. * 360.);\n        vec3 offset = 1.*vec3(cos(t+iTime), 0., sin(t+iTime));\n        d = smin(d, dSphere(p + elevate(1.839, t*5., 1.) + offset, 0.5), k);\n    }\n    \n    return d;\n}\n\nvec3 estimateNormal(vec3 p)\n{\n    vec3 e = vec3(EPS, 0., 0.);\n    return normalize(vec3(\n        dScene(p + e.xyy) - dScene(p - e.xyy),\n        dScene(p + e.yxy) - dScene(p - e.yxy),\n        dScene(p + e.yyx) - dScene(p - e.yyx)));\n}\n\nvec4 closestObstacle(vec3 ro, vec3 rd, float tStart)\n{\n    float t = tStart;\n    for (int i = 0; i < MAX_ITER; ++i) {\n        vec3 p = ro + rd * t;\n        float d = dScene(p);\n        if (d < EPS || d > CAM_FAR) {\n\t\t\treturn vec4(ro + rd * t, t);\n        }\n        t += d;\n    }\n    return vec4(ro + rd * t, t);\n}\n\nvec4 render(vec3 ro_, vec3 rd_)\n{   \n    vec3 ro = ro_;\n    vec3 rd = rd_;\n    float factor = 1.;    \n    for (int i = 0; i < MAX_RAYS; ++i) {\n        vec4 q = closestObstacle(ro, rd, 2.*EPS);\n        if (q.w >= CAM_FAR) {\n            break;\n        }\n        vec3 n = estimateNormal(q.xyz);\n        vec3 refl = reflect(rd, n);\n        ro = q.xyz;\n        rd = refl;\n        factor *= 0.8;\n    }\n    vec4 bg = texture(iChannel0, rd);\n    vec4 bg_ = texture(iChannel0, rd_);\n    return mix(factor * bg, bg_, smoothstep(float(CAM_FAR)-5., float(CAM_FAR), distance(ro, ro_)));\n}\n\nvec3 cameraLookAt(vec3 target, vec3 camPos, vec3 up, vec2 uv, float camNear)\n{\n    vec3 axisZ = normalize(target - camPos);\n    vec3 axisX = cross(axisZ, up);\n    vec3 axisY = cross(axisX, axisZ);\n    return normalize(axisX * uv.x + axisY * uv.y + camNear * axisZ); \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - .5* iResolution.xy) / iResolution.x;\n    vec3 ro = vec3(2. * cos(0.3*iTime), sin(0.3*iTime) + 1.5, 2. * sin(0.3*iTime));\n    vec3 rd = cameraLookAt(vec3(0., 0.5, 0.), ro, vec3(0., 1., 0.), uv, 0.23);\n    fragColor = render(ro, rd);\n}\n","name":"Image","description":"","type":"image"}]}