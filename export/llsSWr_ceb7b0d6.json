{"ver":"0.1","info":{"id":"llsSWr","date":"1436042470","viewed":749,"name":"Basic 3D Scene","username":"jcant0n","description":"Basic Scene, diffuse phong","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","lighting","raymach"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#ifdef GL_ES\n    precision highp float;\n#endif\n\nvec3 cameraPosition = vec3(0, 3, -10.0);\nvec3 spherePosition = vec3(-1.5, 0.8, 1.5);\nfloat sphereRadius = 1.0;\n\nvec3 cubePosition = vec3(1.5, 0.9, 1.5);\nvec3 cubeSize = vec3(1);\n\nvec3 torusPosition = vec3(0, 0.5, -1.5);\nvec2 torusSize = vec2(1.0, 0.5);\n\nvec3 light0 = vec3(2, 2, 4);\nvec3 light0_color = vec3(1);//vec3(0.1, 0.7, 0.1);\n\nvec2 rotate( vec2 vector, float angle )\n{\n\tvec2 sincos = vec2( sin(angle), cos(angle) );\n\treturn vec2( vector.x * sincos.y - vector.y * sincos.x, \n\t\t\t\tvector.x * sincos.x + vector.y * sincos.y );\n}\n\nfloat planeDistance(vec3 rayPosition) {\n    return rayPosition.y;\n}\n\nfloat cubeDistance(vec3 rayPosition, vec3 cubePosition, vec3 cubeSize) {\n    vec3 d = abs(rayPosition - cubePosition) - cubeSize;\n    return min(max(d.x, max(d.y,d.z)), 0.0) + length(max(d,0.0));\n}\n\nfloat sphereDistance(vec3 rayPosition, vec3 spherePosition, float sphereRadius)\n{\n    float d = length(rayPosition - spherePosition) - sphereRadius;\n    return d;\n}\n\nfloat torusDistance(vec3 rayPosition, vec3 torusPosition, vec2 torusSize) {\n    vec2 d = vec2( length(rayPosition.xz - torusPosition.xz) - torusSize.x, rayPosition.y - torusPosition.y);\n    return length(d) - torusSize.y;\n}\n\nfloat scene(vec3 rayPosition)\n{\n\tfloat entity = planeDistance(rayPosition);\n    entity = min(entity, cubeDistance(rayPosition, cubePosition, cubeSize));\n    entity = min(entity, sphereDistance(rayPosition, spherePosition, sphereRadius));\n    entity = min(entity, torusDistance(rayPosition, torusPosition, torusSize));\n    \n    ///float entity = cubeDistance(rayPosition, cubePosition, cubeSize);\n\n    return entity;\n}\n\n// Uses map function (smallest distance to scene) for\n// approximating normal at pos\nvec3 getNormal(vec3 pos)\n{\n    float epsilon = 0.001;\n    \n\tvec2 t = vec2(0.0, epsilon);\n    vec3 n = vec3(scene(pos + t.yxx) - scene(pos - t.yxx),\n           \t      scene(pos + t.xyx) - scene(pos - t.xyx),\n                  scene(pos + t.xxy) - scene(pos - t.xxy));\n    \n    return normalize(n);\n}\n\nvec3 getDiffuse(vec3 rayPosition)\n{\n    vec3 normal = getNormal(rayPosition);\n    vec3 dir = normalize(light0 - rayPosition);\n    float diffuse = max( dot(dir, normal), 0.0);\n    return light0_color * diffuse;\n}\nvec3 getColor(vec3 rayPosition, vec3 rayDirection)\n{\n    vec3 backgroundColor = vec3(0);\n    \n    vec3 color = backgroundColor;\n    \n    for(int i = 0; i < 128; ++i)\n    {\n        float d = scene(rayPosition);\n        rayPosition += d * rayDirection;\n        \n        if(d < 0.001)\n        {\n            color = getDiffuse(rayPosition);\n            break;\n        }\n    }\n    \n    return getNormal(rayPosition);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    uv -= .5;\n    uv.x = aspect * uv.x;\n    \n    light0.xz = rotate(light0.xz, iTime);\n    float mouseX = iMouse.x * .008;\n    \n    cameraPosition.xz = rotate(cameraPosition.xz, mouseX);\n    \n    vec3 cameraTarget = vec3(0);\n    vec3 cameraForward = normalize(cameraTarget - cameraPosition);\n    vec3 cameraUp = vec3(0,1,0);\n    vec3 cameraRight = normalize( cross(cameraForward, cameraUp));\n    \n    vec3 rayPosition = cameraPosition;\n    vec3 rayDirection = normalize(cameraForward + uv.x * cameraRight + uv.y * cameraUp);\n                                \n    vec3 color = getColor(rayPosition, rayDirection);\n    \n\tfragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}