{"ver":"0.1","info":{"id":"dsVXDD","date":"1681150206","viewed":120,"name":"Increasing Median of Medians","username":"lilinitsy","description":"There's a bug that offsets the image some amount of pixels left and down causing image mismatching. Click to view original image.","likes":0,"published":1,"flags":0,"usePreview":1,"tags":["filter","post","effect","postprocess","median"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_WINDOWSIZE 21\n#define values(i, j) texture(iChannel0, uv + ((vec2(i, j) - vec2(filter_extent)) * pixel_size)).rgb\n#define NUM_BINS ((MAX_WINDOWSIZE / BIN_SIZE) * (MAX_WINDOWSIZE / BIN_SIZE))\n#define BIN_SIZE 3\n\nvoid mainImage(out vec4 fragcolour, in vec2 fragcoord)\n{\n    vec3 luminance_vals = vec3(0.2126, 0.7152, 0.0722);\n    vec2 pixel_size = 1.0 / iResolution.xy;\n    vec2 uv = fragcoord / iResolution.xy;\n\n\n    // Determine windowsize based on distance from center\n    float dist_from_center = length(uv - vec2(0.5, 0.5));\n    int WINDOWSIZE =  2 * int(float(MAX_WINDOWSIZE) * dist_from_center) + 1;  \n    int filter_extent = WINDOWSIZE / 2;\n    int bincount = WINDOWSIZE == MAX_WINDOWSIZE ? NUM_BINS : ((WINDOWSIZE / BIN_SIZE + 1) * (WINDOWSIZE / BIN_SIZE + 1));\n    vec3 medians[NUM_BINS];\n\n    for(int i = 0; i < bincount; i++)\n    {\n        vec3 intermediary_values[BIN_SIZE * BIN_SIZE];\n        int bin_row = i / (WINDOWSIZE / BIN_SIZE);\n        int bin_col = i % (WINDOWSIZE / BIN_SIZE);\n        \n        for(int r = 0; r < BIN_SIZE; r++)\n        {\n            for(int c = 0; c < BIN_SIZE; c++)\n            {\n                intermediary_values[r * BIN_SIZE + c] = values(bin_col * BIN_SIZE + c, bin_row * BIN_SIZE + r);\n            }\n        }\n\n        // Sort intermediary_values using an insertion sort to find the median.\n        for(int j = 1; j < BIN_SIZE * BIN_SIZE; j++)\n        {\n            vec3 key = intermediary_values[j];\n            int k = j - 1;\n            while (k >= 0 && dot(intermediary_values[k], luminance_vals) > dot(key, luminance_vals))\n            {\n                intermediary_values[k + 1] = intermediary_values[k];\n                k = k - 1;\n            }\n            intermediary_values[k + 1] = key;\n        }\n        medians[i] = intermediary_values[BIN_SIZE * BIN_SIZE / 2];\n    }\n\n    // Sort the medians array to find the overall median.\n    for (int i = 1; i < bincount; i++)\n    {\n        vec3 key = medians[i];\n        int j = i - 1;\n        while (j >= 0 && dot(medians[j], luminance_vals) > dot(key, luminance_vals))\n        {\n            medians[j + 1] = medians[j];\n            j = j - 1;\n        }\n        medians[j + 1] = key;\n    }\n\n    // Output the median color.\n    if(iMouse.w > 0.0)\n    {\n        fragcolour = texture(iChannel0, uv);\n    }\n    \n    else\n    {\n        if(bincount == 0)\n        {\n            fragcolour = texture(iChannel0, uv);\n        }\n        \n        else\n        {\n            fragcolour = vec4(medians[bincount / 2], 1.0);\n        }\n    }\n}","name":"Image","description":"","type":"image"}]}