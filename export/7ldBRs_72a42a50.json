{"ver":"0.1","info":{"id":"7ldBRs","date":"1663598666","viewed":44,"name":"Voxel raymarching testaroo-two","username":"PrenexNormalForm","description":"second voxel raymarching test, this time more readable\n\nthe fps seems about the same to me, they probably compile to similar machine code anyway\nhmm actually this seems slower than my first one","likes":0,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","voxels"],"hasliked":0,"parentid":"slcfzf","parentname":"Voxel raymarching testaroo"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n    Returns the distance to the environment at the given position.\n    pos: the position\n*/\nfloat signedDistance(vec3 pos);\n\n/**\n    Defines the voxel grid.\n*/\nbool isVoxel(vec3 pos);\n\n//stub\nvec3 voxelColor(vec3 pos);\n\n/**\n    Converts the fragment coordinate to a normalized ray\n    in camera's local space (camera facing -z).\n    fov: the field of view in degrees\n    fragCoord: the fragCoord\n    returns a normalized ray\n*/\nvec3 fragCoordToRay(float fov, vec2 fragCoord);\n\n/**\n    Marches the ray from the start position until it intersects\n    the environment.\n    startPos: the position to start marching from\n    ray: the direction to march, normalized\n    returns vec3(the position of intersection, minimum distance to env)\n*/\nvec4 rayMarch(vec3 startPos, vec3 ray);\n\n/**\n    Determines the color the current fragment should be based on\n    the camera position and the result of this fragment's\n    raymarch.\n    marchPos.xyz: the position at raymarch completion\n    marchPos.w: the minimum distance to the scene during the raymarch\n    cameraPos: the camera position\n    returns fragment color (linear)\n*/\nvec3 shadeScene(vec4 marchPos, vec3 cameraPos);\nfloat distSq(vec3 a, vec3 b);\nfloat distSq(vec2 a, vec2 b);\nfloat distSq(float a, float b);\nvec3 encodeSRGB(vec3 linearRGB);\n\n\nconst float MAX_DISTANCE = 100.0;\nconst int MAX_RAY_MARCHES = 1000;\nconst float NEARLY_ZERO = 0.001;\nconst vec3 SUN_RAY = normalize(vec3(0.5, 1.0, 0.65));\n\n//helpers for signedDistance\nvec3 left(vec3 pos) {return pos + vec3(-1,0,0);}\nvec3 right(vec3 pos) {return pos + vec3(1,0,0);}\nvec3 down(vec3 pos) {return pos + vec3(0,-1,0);}\nvec3 up(vec3 pos) {return pos + vec3(0,1,0);}\nvec3 backward(vec3 pos) {return pos + vec3(0,0,-1);}\nvec3 forward(vec3 pos) {return pos + vec3(0,0,1);}\n\nfloat signedDistance(vec3 pos)\n{\n    float dSq = 1.0; //distance squared\n    bool isVox = isVoxel(pos);\n    \n    //faces\n    bool leftFace = isVox ^^ isVoxel(left(pos));\n    bool rightFace = isVox ^^ isVoxel(right(pos));\n    bool downFace = isVox ^^ isVoxel(down(pos));\n    bool upFace = isVox ^^ isVoxel(up(pos));\n    bool bwdFace = isVox ^^ isVoxel(backward(pos));\n    bool fwdFace = isVox ^^ isVoxel(forward(pos));\n    \n    if (leftFace) dSq = min(dSq, distSq(0., fract(pos.x)));\n    if (rightFace) dSq = min(dSq, distSq(1., fract(pos.x)));\n    if (downFace) dSq = min(dSq, distSq(0., fract(pos.y)));\n    if (upFace) dSq = min(dSq, distSq(1., fract(pos.y)));\n    if (bwdFace) dSq = min(dSq, distSq(0., fract(pos.z)));\n    if (fwdFace) dSq = min(dSq, distSq(1., fract(pos.z)));\n    \n    //edges\n    bool leftDownEdge = !leftFace && !downFace && (isVox ^^ isVoxel(left(down(pos))));\n    bool leftUpEdge = !leftFace && !upFace && (isVox ^^ isVoxel(left(up(pos))));\n    bool leftBwdEdge = !leftFace && !bwdFace && (isVox ^^ isVoxel(left(backward(pos))));\n    bool leftFwdEdge = !leftFace && !fwdFace && (isVox ^^ isVoxel(left(forward(pos))));\n    \n    bool bwdDownEdge = !bwdFace && !downFace && (isVox ^^ isVoxel(backward(down(pos))));\n    bool bwdUpEdge = !bwdFace && !upFace && (isVox ^^ isVoxel(backward(up(pos))));\n    bool fwdDownEdge = !fwdFace && !downFace && (isVox ^^ isVoxel(forward(down(pos))));\n    bool fwdUpEdge = !fwdFace && !upFace && (isVox ^^ isVoxel(forward(up(pos))));\n    \n    bool rightDownEdge = !rightFace && !downFace && (isVox ^^ isVoxel(right(down(pos))));\n    bool rightUpEdge = !rightFace && !upFace && (isVox ^^ isVoxel(right(up(pos))));\n    bool rightBwdEdge = !rightFace && !bwdFace && (isVox ^^ isVoxel(right(backward(pos))));\n    bool rightFwdEdge = !rightFace && !fwdFace && (isVox ^^ isVoxel(right(forward(pos))));\n    \n    if (leftDownEdge) dSq = min(dSq, distSq(vec2(0), fract(pos.xy)));\n    if (leftUpEdge) dSq = min(dSq, distSq(vec2(0,1), fract(pos.xy)));\n    if (leftBwdEdge) dSq = min(dSq, distSq(vec2(0), fract(pos.xz)));\n    if (leftFwdEdge) dSq = min(dSq, distSq(vec2(0,1), fract(pos.xz)));\n    \n    if (bwdDownEdge) dSq = min(dSq, distSq(vec2(0), fract(pos.yz)));\n    if (bwdUpEdge) dSq = min(dSq, distSq(vec2(1,0), fract(pos.yz)));\n    if (fwdDownEdge) dSq = min(dSq, distSq(vec2(0,1), fract(pos.yz)));\n    if (fwdUpEdge) dSq = min(dSq, distSq(vec2(1), fract(pos.yz)));\n    \n    if (rightDownEdge) dSq = min(dSq, distSq(vec2(1,0), fract(pos.xy)));\n    if (rightUpEdge) dSq = min(dSq, distSq(vec2(1), fract(pos.xy)));\n    if (rightBwdEdge) dSq = min(dSq, distSq(vec2(1,0), fract(pos.xz)));\n    if (rightFwdEdge) dSq = min(dSq, distSq(vec2(1), fract(pos.xz)));\n    \n    //vertices\n    bool leftDownBwdVert = !(leftFace || downFace || bwdFace || bwdDownEdge || leftBwdEdge || leftDownEdge);\n    leftDownBwdVert = leftDownBwdVert && (isVox ^^ isVoxel(left(down(backward(pos)))));\n    bool leftDownFwdVert = !(leftFace || downFace || fwdFace || fwdDownEdge || leftFwdEdge || leftDownEdge);\n    leftDownFwdVert = leftDownFwdVert && (isVox ^^ isVoxel(left(down(forward(pos)))));\n    bool leftUpBwdVert = !(leftFace || upFace || bwdFace || bwdUpEdge || leftBwdEdge || leftUpEdge);\n    leftUpBwdVert = leftUpBwdVert && (isVox ^^ isVoxel(left(up(backward(pos)))));\n    bool leftUpFwdVert = !(leftFace || upFace || fwdFace || fwdUpEdge || leftFwdEdge || leftUpEdge);\n    leftUpFwdVert = leftUpFwdVert && (isVox ^^ isVoxel(left(up(forward(pos)))));\n    \n    bool rightDownBwdVert = !(rightFace || downFace || bwdFace || bwdDownEdge || rightBwdEdge || rightDownEdge);\n    rightDownBwdVert = rightDownBwdVert && (isVox ^^ isVoxel(right(down(backward(pos)))));\n    bool rightDownFwdVert = !(rightFace || downFace || fwdFace || fwdDownEdge || rightFwdEdge || rightDownEdge);\n    rightDownFwdVert = rightDownFwdVert && (isVox ^^ isVoxel(right(down(forward(pos)))));\n    bool rightUpBwdVert = !(rightFace || upFace || bwdFace || bwdUpEdge || rightBwdEdge || rightUpEdge);\n    rightUpBwdVert = rightUpBwdVert && (isVox ^^ isVoxel(right(up(backward(pos)))));\n    bool rightUpFwdVert = !(rightFace || upFace || fwdFace || fwdUpEdge || rightFwdEdge || rightUpEdge);\n    rightUpFwdVert = rightUpFwdVert && (isVox ^^ isVoxel(right(up(forward(pos)))));\n    \n    if (leftDownBwdVert) dSq = min(dSq, distSq(vec3(0), fract(pos)));\n    if (leftDownFwdVert) dSq = min(dSq, distSq(vec3(0,0,1), fract(pos)));\n    if (leftUpBwdVert) dSq = min(dSq, distSq(vec3(0,1,0), fract(pos)));\n    if (leftUpFwdVert) dSq = min(dSq, distSq(vec3(0,1,1), fract(pos)));\n    \n    if (rightDownBwdVert) dSq = min(dSq, distSq(vec3(1,0,0), fract(pos)));\n    if (rightDownFwdVert) dSq = min(dSq, distSq(vec3(1,0,1), fract(pos)));\n    if (rightUpBwdVert) dSq = min(dSq, distSq(vec3(1,1,0), fract(pos)));\n    if (rightUpFwdVert) dSq = min(dSq, distSq(vec3(1), fract(pos)));\n    \n    //finally, the square root\n    float dist = sqrt(dSq);\n    //negative if within voxel\n    dist *= 1.0 - 2.0 * float(isVox);\n    //sphere as control\n    dist = min(dist, length(vec3(sin(iTime),0,-5) - pos) - 0.5);\n    return dist;\n}\n\n\n// rand function https://www.shadertoy.com/view/Xt23Ry\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }\n\n\nbool isVoxel(vec3 pos)\n{\n    bool voxel = false;\n    //every other voxel in xy=0,0 is filled\n    voxel = voxel || floor(pos.xy) == vec2(0.) && mod(floor(pos.z), 2.) == 0.;\n    //every other voxel in xy=1,1 is filled\n    voxel = voxel || floor(pos.xy) == vec2(1.) && mod(floor(pos.z), 2.) == 1.;\n    //grid of every 5 spaces\n    voxel = voxel || floor(pos.z) == -7. && mod(floor(pos.x),5.) == 3. && mod(floor(pos.y),5.) == 4.;\n    //column of random voxels\n    voxel = voxel || pos.x < -2. && pos.x >= -7. && pos.z < -9. && pos.z >= -14. && rand(floor(pos) + vec3(floor(iTime))) < 0.2; \n    return voxel;\n}\n\nvec3 fragCoordToRay(float fov, vec2 fragCoord)\n{\n    float halfFOV = radians(fov) / 2.0;\n    float viewPlaneScale = tan(halfFOV);\n    vec2 centeredFragCoord = fragCoord - iResolution.xy * 0.5;\n    vec2 viewPlaneCoord = centeredFragCoord / iResolution.xx * 2.0;\n    vec3 ray = vec3(viewPlaneCoord * viewPlaneScale, -1.0);\n    return normalize(ray);\n}\n\nvec4 rayMarch(vec3 startPos, vec3 ray)\n{\n    vec3 pos = startPos;\n    float minDist = MAX_DISTANCE;\n    for (int i = 0; i < MAX_RAY_MARCHES; i++)\n    {\n        float dist = signedDistance(pos);\n        minDist = min(minDist, dist);\n        if (dist < NEARLY_ZERO || distSq(pos, startPos) > MAX_DISTANCE*MAX_DISTANCE)\n        {break;}\n        pos += ray * dist;\n    }\n    return vec4(pos, minDist);\n}\n\nvec3 shadeScene(vec4 march, vec3 cameraPos)\n{\n    vec3 color = vec3(0.8, 0.8, 0.05);\n    if (march.w < NEARLY_ZERO)\n    {\n        vec3 normal = normalize(vec3(\n            signedDistance(march.xyz + vec3(0.001,0,0)) - signedDistance(march.xyz + vec3(-0.001,0,0)),\n            signedDistance(march.xyz + vec3(0,0.001,0)) - signedDistance(march.xyz + vec3(0,-0.001,0)),\n            signedDistance(march.xyz + vec3(0,0,0.001)) - signedDistance(march.xyz + vec3(0,0,-0.001))\n        ));\n        float light = max(0., dot(normal, SUN_RAY)) * 1. + 0.4;\n        color = light * color;\n    }\n    else\n    {\n        //sky color\n        color = vec3(0.2, 0.5, 0.8);\n        color = vec3(color.xy + 0.2*vec2(pow(exp(-march.w*march.w),2.0)), color.z);\n    }\n    return color;\n}\n\nfloat distSq(vec3 a, vec3 b)\n{\n    vec3 diff = a - b;\n    return dot(diff, diff);\n}\n\nfloat distSq(vec2 a, vec2 b)\n{\n    vec2 diff = a - b;\n    return dot(diff, diff);\n}\n\nfloat distSq(float a, float b)\n{\n    float diff = a - b;\n    return diff * diff;\n}\n\n//from https://www.shadertoy.com/view/lscSzl\nvec3 encodeSRGB(vec3 linearRGB)\n{\n    vec3 a = 12.92 * linearRGB;\n    vec3 b = 1.055 * pow(linearRGB, vec3(1.0 / 2.4)) - 0.055;\n    vec3 c = step(vec3(0.0031308), linearRGB);\n    return mix(a, b, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPos = vec3(0.5) + 3.*vec3(cos(0.2 * iTime), sin(0.2 * iTime), 0);\n    vec3 ray = fragCoordToRay(80.0, fragCoord);\n    vec4 march = rayMarch(cameraPos, ray);\n    vec3 col = shadeScene(march, cameraPos);\n\n    // Output to screen\n    fragColor = vec4(encodeSRGB(col),1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}