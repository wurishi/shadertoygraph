{"ver":"0.1","info":{"id":"7s3GR2","date":"1630205135","viewed":63,"name":"Noisy Patterns on Polar Shape","username":"gunthern","description":"Noisy patterns on polar shape","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise","polar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float random (in vec2 _uv) {\n    return fract(sin(dot(_uv.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nmat2 rotate2d (float _angle){\n\treturn mat2 (cos(_angle),sin(_angle),-sin(_angle),cos(_angle));   \n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _uv) {\n    vec2 i = floor(_uv);\n    vec2 f = fract(_uv);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*2.*(3.0-2.0*f);\n    u = smoothstep(0.,2.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat box(vec2 _uv, vec2 _size, float _smoothEdges){\n    _size = vec2(0.5)-_size*0.5;\n    vec2 aa = vec2(_smoothEdges*0.5);\n    vec2 uv = smoothstep(_size,_size+aa,_uv);\n    uv *= smoothstep(_size,_size+aa,vec2(1.0)-_uv);\n    return uv.y*uv.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.0);\n    \n    \n    vec2 uvax = uv * rotate2d((iTime-cos(1./sin(iTime*.3))));\n    vec2 uvay = uv * rotate2d((iTime-sin(1./cos(iTime*.5))));\n    float a = atan(uvax.x,uvay.y);\n    float f = cos(a*3.*sin(iTime*.1));\n    float r = length(uv*4.);\n    col += (1.0 - vec3(smoothstep(f,f+0.02,r)));\n    \n    col += vec3(.0, -.3, .3) *\n           box(\n               (uv * rotate2d(cos(iTime*.2)*100.*noise(uv*(cos(iTime*.3)+.4)*10.))) + vec2(sin(iTime*.66)*.1, cos(iTime)),\n               vec2(0.3),\n               0.01\n           );\n           \n    col += vec3(.2, -.7, -.3) *\n    box(\n       (uv * rotate2d(tan(iTime*.5)*90.*noise(uv*(sin(iTime*.3)+.5)*13.))) + vec2(sin(iTime*.4)*.3, tan(iTime*.62)),\n       vec2(0.8),\n       0.01\n    );\n    \n     col /= vec3(.6, -.1, -.3) *\n    box(\n       (uv * rotate2d(tan(iTime*.2)*30.*noise(uv*(cos(iTime*.7)+.5)*23.))) + vec2(tan(iTime*.9)*.4, cos(iTime)),\n       vec2(0.8),\n       0.9\n    );\n    \n     col += vec3(sin(iTime*-.8), sin(iTime*-.4), sin(iTime*.3)) *\n    box(\n       (uv * rotate2d(sin(iTime*.3)*30.*noise(uv*(tan(iTime*-.7)+.2)*3.))) + vec2(sin(iTime*.2)*.4, sin(iTime*.3)),\n       vec2(0.8),\n       0.9\n    );\n    \n    col += vec3(.8, .3, -.9) *\n    box(\n       (uv * rotate2d(tan(iTime*.2)*40.*noise(uv*(sin(iTime*.73)+.9)*3.))) + vec2(sin(iTime*.9)+.4, cos(iTime*.92)),\n       vec2(0.8),\n       0.01\n    );\n    \n    col /= vec3(\n        dot(vec2(iTime*.05),vec2(cos(iTime),tan(iTime))),\n        dot(vec2(iTime*.2),vec2(sin(iTime),cos(iTime))),\n        dot(vec2(iTime*.1),vec2(tan(iTime),sin(iTime)))\n    ) *\n    box(\n       (uv * rotate2d(cos(iTime*.5)+9.*noise(uv*(sin(iTime*.3)+.5)*13.))) + vec2(sin(iTime*.4)*.3, tan(iTime*.62)),\n       vec2(0.8),\n       0.01\n    );\n    \n    col = clamp(col, 0.0, 1.0);\n   \n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}