{"ver":"0.1","info":{"id":"slGfRm","date":"1664234411","viewed":344,"name":"Dream Pool #1","username":"murf","description":"Dream Pool #1 (Conquer)\n\nMy take on Jared Pike's Dream Pools (go have a look).\n\nWorking on making it prettier and faster, open to suggestions!\n\nThanks to:\nwtXXWS for the sexy tiles\nMlXGWf for the water\n\nUPDATE#1: Added camera movement and panning.\n","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["tunnel","mouse","water","tile","dream","pools","back","rooms","dreampool","backrooms"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//==========================================================================//\n// Dream Pool #1                                                            //\n//==========================================================================//\n\n// Boost this if you've got the pc for it\n#define AA 1\n\n#define MAX_STEPS 100\n#define MAX_DIST  200.\n#define SURF_DIST .01\n#define ID_WATER  0.\n#define ID_FLOOR  1.\n#define ID_WALL   2.\n//#define FULLBRIGHT\n//#define NO_WATER\n\nconst float waterLevel = 2.5;\nconst float wallDistance = 18.1;\nconst float camDistance = 1.9;\nconst float tunnelHeight = 5.9;\nconst float tunnelsSpacing = 30.;\nconst float pillarsSpacing = 15.;\nconst float pillarsDistance = 20.;\nconst vec3 lightAmbient = vec3(244., 233., 155.)/255.*.3;//vec3(.29,.25,.2)*1.;\n//const vec3 light0 = vec3(-6., 15., -10.)*10.;\nconst vec3 sunDir = vec3(-4., 15., -10.);\nconst vec3 waterColor = vec3(0.,.6,.6);\nconst vec3 tileColor = vec3(0.84, 0.88, 0.89);\nconst vec3 cementColor = vec3(0.24, 0.28, 0.19);\nconst vec2 camMinMaxHeight = vec2(4.3+0.8*2.7,2.7);\nconst vec3 camPos = vec3(0.,camMinMaxHeight.x,-camDistance);\nconst float waterIntensity = .3;\n\nfloat time = 0.; \n\n//==========================================================================//\n// Auxilary functions                                                       //\n//==========================================================================//\n\nfloat sfract(float n)\n{ return smoothstep(0.0,1.0,fract(n)); }\n\nfloat rand(vec2 n)\n{ return fract(abs(sin(dot(n,vec2(5.3357,-5.8464))))*256.75+0.325); }\n\nfloat noise(vec2 n)\n{\n    n *= waterIntensity;//smoothstep(waterIntensity, 0.4, abs(n.x)/50.);\n    float h1 = mix(rand(vec2(floor(n.x),floor(n.y))),\n                   rand(vec2(ceil(n.x),floor(n.y))),\n                   sfract(n.x));\n    float h2 = mix(rand(vec2(floor(n.x),ceil(n.y))),\n                   rand(vec2(ceil(n.x),ceil(n.y))),\n                   sfract(n.x));\n    return mix(h1,h2,sfract(n.y));\n}\n\nmat2 rot(float a) \n{ float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\n\n//==========================================================================//\n// Signed distance functions                                                //\n//==========================================================================//\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdLink(vec3 p, float le, float r1, float r2)\n{\n    vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n    return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdLip(vec3 p)\n{\n    const float le = 6., r1 = 4., r2 = .75;\n    const float off = tunnelsSpacing;\n    p.x = mod(p.x+off,2.*off)-off;\n    p.y = max(p.y, -0.25);\n    p.z += le;\n    p.y += r2;    \n    p = p.xzy;\n    return sdLink(p,le,r1,r2);\n}\n\nfloat sdSteps(vec3 p)\n{\n    const float off = tunnelsSpacing;\n    p.x = mod(p.x+off,2.*off)-off;\n    p.z -= wallDistance;\n    p.z = min(p.z, 1.);\n    return min(min(\n        sdCappedCylinder(p, 5., 1.5),\n        sdCappedCylinder(p, 6., 1.)),\n        sdCappedCylinder(p, 7., .5));\n}\n\nfloat sdPillars(vec3 p)\n{\n    const float off = pillarsSpacing;\n    p.z += pillarsDistance;\n    p.x = mod(p.x+off,2.*off)-off;\n    return min(\n        sdCappedCylinder(p,5.,200.),\n        sdBox(p, vec3(off, 3., 7.)));\n}\n\nfloat sdWater(vec3 p)\n{\n    //Distort coordinates\n    p += vec3(iTime*.2,0.0,0.0)+vec3(noise(p.xz),0.0,noise(p.xz+8.0))*.2;\n    float height = 0.01*pow(noise(p.xz+vec2(iTime*0.7,iTime*0.6))*0.5\n                           +noise(p.xz*8.0+vec2(iTime))*0.35\n                           +noise(p.xz*16.0+vec2(0.0,iTime*0.5))*0.1\n                           +noise(p.xz*24.0)*0.05,0.25);\n    float model = p.y-height*20.;\n    return .8*model;\n}\n\nfloat sdTiles(vec3 p)\n{\n    float planeDist = p.y;\n    float panel = 0.;\n    float fade = 2.-min(length(p),8.)/16.;\n    if(fade>0.)\n    {\t\n        panel = max(0.9,max(abs(-1.+2.*mod(p.x,.5)),\n                            abs(-1.+2.*mod(p.z,.5))))-.9;\n    \tpanel = panel*panel;\n        //panel += .25*noise(p.xz);\n     \tplaneDist = mix(p.y,p.y+.95,panel*fade);\n    }\n    return planeDist;\n}\n\nfloat sdFloor(vec3 p)\n{\n    return sdTiles(p);\n    //return max(-sdHoles(p), sdTiles(p));\n}\n\nfloat sdTunnel(vec3 p, vec3 bP, float off)\n{\n    const float offX = tunnelsSpacing;\n    vec3 ogP = p;\n    p.x = mod(p.x+offX,2.*offX)-offX;\n    bP.x = mod(p.x+offX,2.*offX)-offX;\n    \n    return max(-min(\n        sdBox(bP, vec3(4., off, 12.5)),\n        sdCappedCylinder(p, 4., 12.5)),\n        sdTiles(ogP));\n}\n\nfloat sdWall(vec3 p)\n{\n    const float off = tunnelHeight;\n    const float off2 = tunnelsSpacing;\n    \n    p.z -= wallDistance; //push entire wall back  \n    \n    vec3 bP = p;\n    \n    p.z *= -1.;     //flip towards camera\n    p.y -= 2.*off;  //shift upwards\n    p = p.xzy;      //rotate\n    \n    vec3 lP = p;\n    lP.x = mod(p.x+off2,2.*off2)-off2;\n    \n    bP.y -= off;    //shift upwards\n    \n    return min(sdTunnel(p, bP, off), sdLip(lP));\n}\n\nvec2 sdWorldNoWater(vec3 p)\n{\n    float id = ID_FLOOR;\n    float d = min(min(min(\n        sdWall(p),\n        sdFloor(p)),\n        sdSteps(p)),\n        sdPillars(p));\n    return vec2(d, id);\n}\n\nvec2 sdWorld(vec3 p)\n{   \n    vec2 di = sdWorldNoWater(p);\n    float d = di.x;\n    float id = di.y;\n    \n    #ifndef NO_WATER\n    float worldDist = d;\n    \n    p.y -= waterLevel;\n    d = min(d,sdWater(p));\n    \n    if(d < worldDist)\n        id = ID_WATER;\n    #endif\n        \n    return vec2(d, id);\n}\n\n//==========================================================================//\n// Marching functions                                                       //\n//==========================================================================//\n\nvec2 rayMarch(vec3 ro, vec3 rd)\n{\n    float dO =0.;\n    vec2 obj = vec2(-1.);\n    \n    for(int i=0; i<MAX_STEPS; i++)\n    {\n\t\tvec3 p = ro + rd*dO;\n        obj = sdWorld(p);\n        float dS = obj.x;\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) \n            break;        \n    }\n    \n    return vec2(dO, obj.y);\n}\n\nvec2 refractMarch(vec3 ro, vec3 rd)\n{\n    float dO =0.;\n    vec2 obj = vec2(-1.);\n    \n    for(int i=0; i<MAX_STEPS; i++)\n    {\n\t\tvec3 p = ro + rd*dO;\n        obj = sdWorldNoWater(p);\n        float dS = obj.x;\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) \n            break;        \n    }\n    \n    return vec2(dO, obj.y);\n}\n\nfloat shadowMarch(vec3 ro, vec3 rd)\n{\n    float dO =0.;\n    float res = 1.;\n    float dS =0.;\n    for(int i=0; i<MAX_STEPS; i++)\n    {\n        /*if(dO>MAX_DIST)\n            break;*/\n\t\tvec3 p = ro + rd*dO;\n        vec2 obj = sdWorldNoWater(p);\n        dS = obj.x;\n        dO += dS;\n        if(dS<SURF_DIST) \n            return 0.;\n        res = min(res, 8.*dS/dO);\n    }\n         \n    return res;\n}\n\n//==========================================================================//\n// Computes normal at given point, with and without water.                  //\n//==========================================================================//\n\nvec4 getNormal(vec3 p)\n{\n    vec2 item = sdWorld(p);\n    float d = item.x;\n    \n    vec2 e = vec2(.01, 0.);\n    vec3 n = d - vec3(\tsdWorld(p-e.xyy).x,\n                 \t\tsdWorld(p-e.yxy).x,\n                 \t\tsdWorld(p-e.yyx).x);\n    return vec4(normalize(n), item.y);\n}\n\nvec4 getNormalNoWater(vec3 p)\n{\n    vec2 item = sdWorldNoWater(p);\n    float d = item.x;\n    \n    vec2 e = vec2(.01, 0.);\n    vec3 n = d - vec3(\tsdWorldNoWater(p-e.xyy).x,\n                 \t\tsdWorldNoWater(p-e.yxy).x,\n                 \t\tsdWorldNoWater(p-e.yyx).x);\n    return vec4(normalize(n), item.y);\n}\n\nvec3 getLight(vec3 p, vec3 rd)\n{\n    vec3 col = vec3(1.);\n    #ifdef NO_WATER\n    vec4 item = getNormalNoWater(p);\n    #else\n    vec4 item = getNormal(p);\n    #endif\n    vec3 n = item.xyz;\n    vec3 light = sunDir;\n    //light.x += cos(time*.01);\n    vec3 l = normalize(light); \n    //l = normalize(lightPos-p);\n    float dif = dot(n,l);\n    float sub = max(0.,.5+.5*dif);\n    dif = max(0.,dif);\n    \n    #ifndef NO_WATER\n    if(item.w == ID_WATER)\n    {        \n        col = waterColor;\n        col += pow(sub,2.)*vec3(0.95,0.61,0.38);\n        \n        //XZ\n        /*float corr = 4.5;\n        vec3 v1 = normalize(vec3(sunDir.x,0.,sunDir.z));\n        vec3 p1 = vec3((pillarsSpacing)*4.-corr,0.,pillarsDistance);\n        vec3 p2 = vec3(-(pillarsSpacing)*2.+corr,0.,pillarsDistance);\n        vec3 l2 = cross(vec3(0.,1.,0.),v1);\n        vec3 l1 = cross(v1,vec3(0.,1.,0.));\n        \n        float fade = length(p-camPos);\n        float d1 = dot(p1,l1);\n        float d2 = dot(p2,l2);\n        \n        if(dot(vec4(l1,d1), vec4(p,1.)) > 0. && \n           dot(vec4(l2,d2), vec4(p,1.)) > 0.)*/\n        {\n            float fade = .92;\n            vec3 nrd = refract(rd, n, fade);\n            vec2 dr = refractMarch(p, nrd);\n            p = p + nrd*dr.x;\n            rd = nrd;   \n        }\n    }    \n        \n    item = getNormalNoWater(p);\n    n = item.xyz;\n    #endif\n\n    dif = dot(n,l);\n    dif = max(0.,dif);\n\n    float d = shadowMarch(p+n*SURF_DIST*2., l);\n    d = sqrt(d);\n    dif *=d;\n    #ifndef FULLBRIGHT\n    col *= vec3(dif)+(vec3(.6,.1,.0)-vec3(dif))*(d*.1);\n    #endif\n    vec2 ll = mod(p.xz,.5);\n    col *= mix(tileColor,cementColor,ll.x>.46 || ll.y>.46?1.0:0.);\n\n    if(dif>0.)\n    {\n        float spec = pow( max(0.,dot(l, reflect(rd, n))), 100.);\n        col +=vec3(.45*spec);\n    }\n    \n    return col;\n}\n\n//==========================================================================//\n// Main ray marching function. Computes color of current pixel              //\n//==========================================================================//\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec2 d = rayMarch(ro, rd);\n    vec3 p = ro + rd*d.x;\n    vec3 dif = getLight(p, rd);\n    \n    return mix(dif,lightAmbient,pow(min(1.,d.x*.005),.5));\n}\n\n//==========================================================================//\n// Main                                                                     //\n//==========================================================================//\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float mTime = iTime;\n    \n    vec3 tot = vec3(0.0);\n    \n    //anti aliasing\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ ) {        \n    vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n    vec2 uv = 0.5*(-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n\n    uv *=1.+.2*pow(dot(uv,uv),2.);      \n    float ad = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n    time = mTime - 0.5*(1.0/30.0)*(float(m*AA+n)+ad)/float(AA*AA-1);\n    #else    \n    vec2 uv = 0.5*(-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    uv *=1.+.2*pow(dot(uv,uv),2.);\n    time = mTime;\n    #endif  \n        \n    vec2 mouse = iMouse.xy;\n    \n    if (iMouse.z < 1.0)\n    {\n        mouse.x = iResolution.x * (sin(time*.1)*.5+.5);\n        mouse.y = iResolution.y * (0.7 + .2*(sin(time*.3)*.5+.5));\n    }\n    \n    //camera\n    vec2 delta = (mouse.xy-iResolution.xy/2.)/iResolution.x;\n    delta.x *= 2.;\n    if(delta.y > 0.) delta.y *= 2.;\n    delta.y *= -1.;\n    vec2 camrot = delta.yx;\n    \n    vec4 pitch = vec4(cos(camrot.x),sin(camrot.x)*vec2(1,-1),0);\n    vec4 yaw = vec4(cos(camrot.y),sin(camrot.y)*vec2(1,-1),1);\n    vec3 i = vec3(yaw.x,0,yaw.z);\n    vec3 j = pitch.yxy*yaw.ywx;\n    vec3 k = pitch.xzx*yaw.ywx;\n    \n    vec2 mm = camMinMaxHeight;\n    vec3 ro = camPos;\n    vec3 rd = normalize(vec3(uv.x, uv.y-.2,1.));\n    \n    rd = rd.x*i + rd.y*j + rd.z*k;\n    //ro = ro.x*cam.i + ro.y*cam.j + ro;\n    ro += vec3(-time,0.,0.);\n        \n    //renders\n\ttot += render(ro, rd);        \n        \n    #if AA>1\n    } tot /= float(AA*AA);    \n    #endif\n    \n    // tone mapping\t\t\t\n    tot = tot*1.2/(1.0+tot);\n\n\t// gamma\t\n\ttot = pow( clamp(tot,0.0,1.0), vec3(0.45) );\n\n    tot = tot*tot*(3.0-2.0*tot);\n    \n\t// vignetting\t\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\ttot *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n    \n    fragColor = vec4(tot, 1.);\n}","name":"Image","description":"","type":"image"}]}