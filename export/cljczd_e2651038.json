{"ver":"0.1","info":{"id":"cljczd","date":"1692189706","viewed":54,"name":"Mod of 01000001's FXAA Shader","username":"beans_please","description":"Original shader: https://www.shadertoy.com/view/mljyzc","likes":1,"published":3,"flags":32,"usePreview":0,"tags":["fxaa"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float get_luminance(vec3 col)\n{\n    return dot(col, vec3(.3, .58, .12));\n}\n\nvoid mainImage(out vec4 O, in vec2 U)\n{\n    vec2 r = iResolution.xy;\n    \n    // Find the normal\n    vec2 normal = vec2(0);\n    {\n        float next_lum = get_luminance(texelFetch(iChannel0, ivec2(U) + ivec2(1, 0), 0).xyz);\n        float prev_lum = get_luminance(texelFetch(iChannel0, ivec2(U) + ivec2(-1, 0), 0).xyz);\n        normal.x = (prev_lum - next_lum) / 2.;\n    }\n    {\n        float next_lum = get_luminance(texelFetch(iChannel0, ivec2(U) + ivec2(0, 1), 0).xyz);\n        float prev_lum = get_luminance(texelFetch(iChannel0, ivec2(U) + ivec2(0, -1), 0).xyz);\n        normal.y = (prev_lum - next_lum) / 2.;\n    }\n    \n    // Tangent\n    vec2 tangent = normal * mat2(0, 1, -1, 0);\n    \n    // Directional blur along the tangent\n    const int num_samples = 20;\n    const float len = 10.;\n    vec3 col = vec3(0);\n    float sum_weights = 0.;\n    for (int i = 0; i < num_samples; i++)\n    {\n        // 0 to 1\n        float t = float(i) / float(num_samples - 1);\n        \n        // -len/2 to len/2\n        float offs_along_tanget = len * (t - .5);\n        \n        // Target pixel's coordinates\n        vec2 target_coord = U + tangent * offs_along_tanget;\n        \n        // Weight of this sample\n        //float weight = 1. - abs(2. * t - 1.); // Tent\n        float weight = cos(3.14159265359 * (t - .5)); // Cosine\n        //float weight = 1.;\n        \n        // Update the sum of all weights\n        sum_weights += weight;\n        \n        col += weight * texture(iChannel0, target_coord / r).xyz;\n    }\n    col /= sum_weights;\n    \n    // Output\n    col = pow(col, vec3(1. / 2.2));\n    O = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 O, in vec2 U)\n{\n    vec2 uv = U / iResolution.y * (sin(iTime*.1) * .5 + .6);\n    \n    vec3 col = vec3(0.15, 1., 0.05);\n    \n    float a = length(mod(uv*10., vec2(2))-1.)>.8?0.:1.;\n    col *= a;\n    \n    O = vec4(col, 1.);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}