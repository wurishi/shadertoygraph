{"ver":"0.1","info":{"id":"tl2yD3","date":"1595617879","viewed":87,"name":"v3-2DCloudSea","username":"jorge2017a1","description":"v3-2DCloudSea","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["v32dcloudsea"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Create  by JiepengTan@gmail.com\n\nfloat Remap(float oa,float ob,float na,float nb,float val){\n\treturn (val-oa)/(ob-oa) * (nb-na) + na;\n}\n\n\nfloat Wave(float layer,vec2 uv,float val)\n{\n\tfloat amplitude =  layer*layer*0.00004;\n\tfloat frequency = val*200.0*uv.x/layer;\n\tfloat phase = 9.*layer+ iTime/val;\n\t\n    return amplitude*sin(frequency+phase); \n}\n\t\n\nfloat Circle(vec2 uv,vec2 center,float size,float blur){\n\tuv = uv - center;\n\tuv /= size;\n\tfloat len = length(uv);\n\treturn smoothstep(1.,1.-blur,len);\n}\n\nfloat AngleCircle(vec2 uv,vec2 center,float size,float blur)\n{\n\tuv = uv - center;\n\tuv /= size;\n\tfloat deg = atan(uv.y,uv.x) + iTime * -0.1;\n\tfloat len = length(uv);\n\tfloat offs =( sin(deg*9.0)*3.+sin(deg*11.0+sin(iTime*6.0)*0.5))*0.05;\n\treturn smoothstep(1.+offs,1.-blur+offs,len);\n}\n\n\n\nfloat DrawCloud(vec2 uv,vec2 center,float size)\n{\n\tuv = uv - center;\n\tuv /= size;\n\tfloat col = Circle(uv,vec2(0.,0.),0.2,0.05);\n\tcol =col *  smoothstep(-0.1,-0.1+0.01,uv.y);\n\tcol += Circle(uv,vec2(0.15,-0.05),0.1,0.05);\n\tcol += Circle(uv,vec2(0.,-0.1),0.11,0.05);\n\tcol += Circle(uv,vec2(-0.15,-0.1),0.1,0.05);\n\tcol += Circle(uv,vec2(-0.3,-0.08),0.1,0.05);\n\tcol += Circle(uv,vec2(-0.2,0.),0.15,0.05);\n\treturn col;\n}\n\n\nfloat DrawClouds(vec2 uv)\n{\n\tuv.x += 0.03*iTime;\n\tuv.x = fract(uv.x+0.5) - 0.5;\n\tfloat col = DrawCloud( uv,vec2(-0.4,0.3),0.2);\n\tcol += DrawCloud( uv,vec2(-0.2,0.42),0.2);\n\tcol += DrawCloud( uv,vec2(0.0,0.4),0.2);\n\tcol += DrawCloud( uv,vec2(0.15,0.3),0.2);\n\tcol += DrawCloud( uv,vec2(0.45,0.45),0.2);\n\treturn col;\n}\n\nvec3 ProcessFrag(vec2 uv)  \n{\n\tvec3 col = vec3(0.0,0.0,0.0);\n\tfloat num = 0.;\n    const float LAYER =3.0;\n\t\n    for (float i=1.; i < LAYER; i++) \n    {\n\t\tfloat wave = 2.*Wave(i,uv,1.)+Wave(i,uv,1.8)+.5*Wave(i,uv,3.);\n\t\tfloat layerVal = 0.7-0.03*i + wave;\n\t\t\n        if(uv.y >layerVal)\n        {\n\t\t\tbreak;\n\t\t}\n        \n\t\tnum = i;//计算所在层的ID\n\t}\n\t\n    col = num*vec3(0.0,.03,1.0);//计算每一层的基本颜色\n\tcol += (LAYER - num) * vec3(.04,.04,.04);//颜色叠亮\n\t\n    if(num ==0.0)\n    {\n\t\t\t\t\t//添加海平面泛光\n\t\tfloat ry = Remap(0.7,1.0,1.0,0.0,uv.y);\n\t\t//col = lerp(vec3(0.1,0.6,0.9),vec3(0.1,0.7,0.9),ry);\n        col = mix(vec3(0.1,0.6,0.9),vec3(0.1,0.7,0.9),ry);\n        \n\t\tcol += pow(ry,10.)*vec3(0.9,0.2,0.1)*0.2;\n\t}\n\t\n    //调整UV为(-0.5,-0.5,0.5,0.5)方便绘图\n\tuv = uv - vec2(0.5,0.5);\n\t//添加太阳\n\t\tvec2 sunPos = vec2(0.3,0.35);\n\t\tfloat sun = Circle(uv,sunPos,0.06,0.05);\n\t\tfloat sunCircle = AngleCircle(uv,sunPos,0.08,0.05);\n\t\t//col = lerp( col ,vec3(0.9,0.6,0.15),sunCircle);\n    \tcol = mix( col ,vec3(0.9,0.6,0.15),sunCircle);\n\t\t//col = lerp( col ,fixed3(0.98,0.9,0.1),sun);\n    col = mix( col ,vec3(0.98,0.9,0.1),sun);\n\t\t//云\n\t\tcol += DrawClouds(uv);\n\t\treturn col;\n\t\t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col =ProcessFrag(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}