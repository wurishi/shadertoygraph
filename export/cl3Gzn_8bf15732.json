{"ver":"0.1","info":{"id":"cl3Gzn","date":"1682274621","viewed":66,"name":"Acre study raymarching2023/04/24","username":"Acre","description":"https://iquilezles.org/articles/distfunctions/\nI have referred to this article but do not fully understand it.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ITERATION_NUM 99\nconst float MAT_A=1.0;\nconst float CHECK=999.0;\nconst float pi = acos(-1.0);\n\nvec2 map(vec3 p) \n{\n    vec2 d;\n    float pxz=0.8;\n    d=vec2(sphere(p+vec3(0.0,-0.4,0.0), 0.4),MAT_A);\n    d=opUnion(d,vec2(sdPlane(p,vec3(0, 1, 0),0.), CHECK));\n\treturn d;\n}\nvec3 getnormal(vec3 p)\n{\n    vec2 d =vec2(0.0001,0.0);\n    return normalize(vec3(map(p +d.xyy).x -map(p -d.xyy).x,map(p +d.yxy).x -map(p -d.yxy).x,map(p +d.yyx).x -map(p -d.yyx).x));\n}\nvec3 materialize(vec3 p, float depth,vec2 mat)\n{\n    vec3 col=vec3(1.0);\n    if (depth > 10.0)\n    {\n    }\n    else\n    {\n         float l=Lambert(vec3(cos(iTime),0.0,sin(iTime)), getnormal(p));\n         vec3 lc=vec3(1.0,0.0,0.0);\n         if(mat.y== MAT_A)\n         {   \n             col=vec3(l);\n             col*= lc;\n         }\n \n         else if(mat.y==CHECK)\n         {\n            col =checkerboard(p.x, p.z);\n         }\n     }\n     return col;\n}\nvec3 raymarch(vec3 ro, vec3 rd) \n{\n\tvec3 p;\n    vec2 d;\n\tfloat depth;\n\tfor(int i=0; i<ITERATION_NUM; i++) \n\t{\n        p=ro+rd*depth;\n\t\td = map(p);\n\t\tif(d.x<0.00001)\n\t\t{\n\t\t    break;\n\t\t}\n\t\tdepth += d.x;\n\t}\n\treturn  materialize(p,depth,d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 origin = vec3(0.0, 3.0, -5.0);\n    vec3 target = vec3(0.0);\n    mat3 camera = SetCamera(origin, target, 0.0);\n    vec3 rd = camera * normalize(vec3(p,3.5));\n\tvec3 col=raymarch(origin , rd);    \n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec2 opUnion(vec2 d1,vec2 d2 ) { return (d1.x<d2.x) ? d1 : d2; }\nfloat sphere(vec3 rayPos, float r) \n{\n    float d=length(rayPos)-r;\n\treturn d;\n}\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  return dot(p,n) + h;\n}\nvec3 checkerboard(float u, float v)\n{\n    return vec3(0.1 + 0.9* mod(floor(u*2.0) +  floor(v*2.0), 2.0));\n}\n//Lighting\nfloat Lambert(vec3 l,vec3 n)\n{\n    return clamp(dot(n,l),0.0,1.0);\n}\n\nmat3 SetCamera(in vec3 origin, in vec3 target, float rotation)\n{\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n\nvec3 lighting(vec3 lp,vec3 n)\n{\n     return vec3(Lambert(lp,n));\n}\n","name":"Common","description":"","type":"common"}]}