{"ver":"0.1","info":{"id":"cdSXDW","date":"1670279487","viewed":193,"name":"Teddy Bear","username":"Sizertz","description":"Hi! This is my first shader here.\nI'm teaching myself GLSL, raymarching and SDFs.\nClick to move camera (stays centered on Teddy). Press play to let it rotate.","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","bear"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float lerp(in float a, in float b, in float t) {\n    return a * (1.0 -t) + b * t;\n}\n\nvec3 lerp(in vec3 a, in vec3 b, in float t) {\n    return a * (1.0 -t) + b * t;\n}\n\n// polynomial smooth min\nfloat smoothmin(in  float a, in float b, in float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat smoothmax(in  float a,in  float b,in  float k )\n{\n    return -smoothmin(-a,-b,k);\n}\n\nfloat smoothmin2(in  float a, in  float b, in  float r) {\n    return - log(exp(-r*a) + exp(-r*b)) / r;\n}\n\n\nfloat smoothmax2(in  float a, in  float b, in  float r) {\n    return log(exp(r*a) + exp(r*b)) / r;\n}\n\nfloat sdfSphere(in  vec3 pos,  in float radius) {\n    return length(pos) - radius;\n}\n\n\nfloat sdfPrimXLine(in vec3 pos) {\n    if(pos.x > 1.)\n        return length(pos - vec3(0.,0.,1.));\n    if(pos.x < 0.)\n        return length(pos);\n    return length(pos.yz); \n}\n\nfloat length2(vec3 v) {\n    return v.x*v.x + v.y*v.y + v.z*v.z;\n}\n\nfloat sdfPrimLine(in vec3 pos, in vec3 a, in vec3 b) {\n    vec3 u = b-a;\n    vec3 x = pos-a;\n    if(dot(x, u) < 0.)\n        return length(x);\n    x = pos-b;\n    if(dot(x, u) > 0.)\n        return length(x);\n    vec3 proj = cross(u, cross(u, x));\n    return abs(dot(x,normalize(proj))); \n}\n\nfloat sdfPrimCircle(in vec3 pos, in vec3 o, in float r, in vec3 n) {\n    pos -= o;\n    vec3 u = -cross(n, cross(n,pos));\n    u = normalize(u);\n    return length(pos-r*u);\n}\n\nfloat sdfPrimCone(in vec3 pos, in float slope, in vec3 axis, in vec3 origin) {\n    pos -= origin;\n    axis = normalize(axis);\n    if(dot(axis,pos) < 0.) axis = -axis;\n    // normal to the plane that contains the axis and pos\n    vec3 n = cross(pos,axis);\n    n = normalize(n);\n    \n    vec3 u = cross(axis, n);\n    if(dot(pos,u) < 0.) u = -u;\n    // tangent to the cone in that plane\n    vec3 t = axis + slope * u;\n    // normal to the cone in that plane\n    vec3 proj = cross(t, n);\n    return dot(pos, normalize(proj));\n}\n\nfloat sdfPrimPlane(in vec3 pos, in vec3 n) {\n    return dot(pos, normalize(n));\n}\n\nvec3 bendCoords(in vec3 pos, in vec3 origin, in vec3 t, in vec3 n, in float amount) {\n    vec3 p = pos-origin;\n    n = normalize(n);\n    t = normalize(t);\n    mat3 mat = mat3(t,n,cross(t,n));\n    mat3 inv = inverse(mat);\n    p = inv * p;\n    float c = cos(amount*p.x);\n    float s = sin(amount*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return  mat * vec3(m*p.xy,p.z) + origin;\n}\n\nfloat sdfEar(in vec3 pos, in float radius) {\n    float s1 = sdfSphere(pos, radius);\n    float s2 = sdfSphere(pos + vec3(0.,0.02,1.*radius), radius*0.5);\n    \n    return  smoothmax(s1, -s2, .1);\n}\n\nfloat sdfHead(in vec3 pos) {\n    // sphere\n    vec3 headPos = vec3(0.0,1.02,0.0);\n    vec3 conePos = vec3(0.,1.5,0);\n    float cone = sdfPrimCone(pos, .4, headPos-conePos, conePos);\n    pos -= headPos;\n    float isoSmooth= .4;\n    float size = .2;\n    float scale = 1. + isoSmooth/size;\n    pos *= vec3(scale);\n\n    float sd = sdfSphere(pos , size);\n    \n    \n    // cutoff front and back\n    sd = smoothmax(sd, pos.z - size * .5, size * 2.5);\n    sd = smoothmax(sd, -pos.z - size * .5, size * 2.5);\n    sd = smoothmax(sd, -pos.y + size * .1, size * 5.5);\n    \n    sd = (sd - isoSmooth) / scale;\n    \n    sd = smoothmax(sd, cone, .1);\n    \n    return sd;\n}\n\n\nvec4 sceneSDF(in vec3 pos) {\n\n    vec3 mirrorXPos = vec3(abs(pos.x),pos.yz);\n    \n    // head\n    float sd = sdfHead(pos);\n    \n    // ears\n    float ears = sdfEar(vec3(abs(pos.x), pos.yz)-vec3(0.12,1.14,-0), 0.07);\n    sd = smoothmin(sd, ears, 0.02);\n    \n    \n    //snout\n    vec3 snoutCenter = vec3(0.0,1.05,-0.08);\n    float snoutSize = .1;\n    float snout = sdfSphere(pos-snoutCenter, snoutSize);\n    snout = smoothmax(snout, pos.y-(snoutCenter.y+snoutSize * .1), snoutSize);\n    \n    float fulcrum = sdfPrimCircle(pos, snoutCenter + vec3(.0,.00,+.11), snoutSize + .1, vec3(1.,0.,0.) - 0.001);\n    fulcrum = sdfPrimLine(pos,vec3(0.,.99,-.16),vec3(0.,1.1,-.22)) -0.001;\n    fulcrum = smoothmin(fulcrum, sdfPrimLine(pos,vec3(0.,.99,-.165),vec3(0.2,.88,-.02)) -0.001, 0.01);\n    fulcrum = smoothmin(fulcrum, sdfPrimLine(pos,vec3(0.,.99,-.165),vec3(-0.2,.88,-.02)) -0.001, 0.01);\n   \n    snout = smoothmax(snout, -fulcrum, 0.03);\n    //snout = min(snout, sdfPrimLine(mirrorXPos,vec3(0.,.99,-.16),vec3(0.2,.8,-.02))- .001);\n\n    sd = smoothmin(sd, snout, 0.008);\n    \n    \n    //nose\n    float nose = sdfSphere(pos-vec3(0.0,1.04,-0.16), .02);\n    nose = smoothmax(nose, pos.y-1.055, 0.01);\n    \n    float nostril = sdfSphere(mirrorXPos-vec3(0.015,1.03,-0.168), .01);\n    nose = smoothmax(nose, -nostril, 0.01);\n    \n    sd = smoothmin(sd, nose, 0.005);\n    \n    \n    // eyes\n    float eyes = sdfSphere(mirrorXPos-vec3(0.06,1.07,-0.115), .015);\n    sd = smoothmax(sd, -eyes - .0145, .05);\n    sd = smoothmin(sd, eyes, .004);\n    \n    \n    // body\n    float body= sdfSphere(pos-vec3(0.,0.7,0.02), .22);\n    body = smoothmin(body, sdfSphere(pos-vec3(0.,0.85,0.03), .12), 0.2);\n    sd = smoothmin(sd, body, 0.02);\n    \n    // arm\n    float arm = sdfPrimCircle(mirrorXPos, vec3(0.1,0.8,-0.05), .14, vec3(0.,1.,-.7)) - .065;\n    arm = smoothmax(arm, -sdfPrimPlane(mirrorXPos, vec3(1.5,1.2,.1)) + .62, .12);\n    sd = min(sd, arm);\n    \n    // leg\n    vec3 footPos = vec3(0.2,0.6,-0.28);\n    vec3 legOri = vec3(0.1,0.6,0.);\n    float leg=sdfPrimLine(mirrorXPos, legOri, footPos) - .08;\n    float foot = sdfSphere(mirrorXPos-(footPos+vec3(0.,0.02,0.)), 0.11);\n    foot = smoothmax(foot,sdfPrimPlane(mirrorXPos, footPos-legOri) - 0.37, 0.06);\n    \n    //foot = smoothmax(foot,-sdfPrimCircle(mirrorXPos,footPos+vec3(.01,.025,-.018),0.1,footPos-legOri) + 0.002, 0.01);\n    \n    foot= smoothmax(foot, sdfPrimPlane(mirrorXPos, vec3(1.1,0.,0.2)) - .27, 0.12);\n    foot= smoothmax(foot, sdfPrimPlane(mirrorXPos, -vec3(1.1,0.,0.2)) + .03, 0.12);\n    \n    leg = smoothmax(leg,sdfPrimPlane(mirrorXPos, footPos-legOri) - 0.32, 0.035);\n    leg = smoothmin(leg,foot,.01);\n    \n    \n    sd = smoothmin(sd, leg, 0.01);\n    sd = smoothmax(sd, -pos.y + .5, 0.2);\n    \n    // ground\n    sd = min(sd,pos.y);\n    return vec4(sd, pos);\n}\n\nvec4 rayMarch(in vec3 rayOrigin, in vec3 rayDir) {\n    vec4 res = vec4(-1.0);\n    \n    float t = 0.001;\n    float tmax = 100000.0;\n    \n    for(int i=0; i<1024 && t<tmax; i++) {\n        vec4 h = sceneSDF(rayOrigin + t*rayDir);\n        if( h.x < 0.001 ) { res = vec4(t, h.yzw); break; }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nvec3 camToScene(in vec3 dir, in vec3 camDir, in vec3 camUp) {\n    vec3 cZ = normalize(camDir);\n    vec3 cX = normalize(cross(camUp, cZ));\n    vec3 cY = cross(cZ,cX);\n    mat3 camToSceneMat = mat3(cX,cY,cZ);\n    return camToSceneMat * dir;\n}\n\nvec4 rayMarch(in vec2 pixel, in vec3 camPos, in vec3 camDir, in vec3 camUp, in float fov) {\n    // vec3 dir = vec3( tan(fov) / iResolution.x * pixel, 1.0); // pixel direction in camera space \n    vec3 dir = vec3( tan(fov * 3.14159 / 180.0) * (pixel - vec2(iResolution.xy / 2.0)), iResolution.x); // pixel direction in camera space \n    dir = camToScene(dir, camDir, camUp);\n    return rayMarch(camPos, normalize(dir));\n}\n\nvec3 camPos(in float time) {\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    float angle = time * 0.5 + mouse.x * 10.;\n    float radius = 3.0;\n    float height = 1.3 + (.5-mouse.y)*2.;\n    return vec3(radius*cos(angle), height, -radius*sin(angle));\n}\n\nvec3 calcNormal(in vec3 pos) {\n    vec3 n = vec3(0.0);\n    for (int i = 0; i<4; i++) {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e* sceneSDF(pos+0.0005*e).x;\n    }\n    return normalize(n);    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.03 * float(i);\n        float d = sceneSDF( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 1.*occ, 0.0, 1.0 );\n}\n\nfloat calcSoftShadow( in vec3 origin, in vec3 dir, in float tmin, in float tmax )\n{\n    float res = 1.0;\n    float t = tmin;\n    for( int i=0; i<96; i++ )\n    {\n\t\tfloat h = sceneSDF( origin + dir*t ).x;\n        float s = clamp(32.0*h/t,0.0,1.0);\n        res = min( res, s );\n        t += clamp( h, 0.01, 100.9 );\n        if( res<0.001 || t>tmax ) break;\n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 camPos = camPos(iTime);\n    vec3 camDir = vec3(0,.85,0) - camPos;\n    vec3 camUp = vec3(0,1,0);\n    float fov = 30.0;\n\n\n    // background\n    vec3 bg = vec3(0.6,.7,.9);\n    vec3 col = bg;\n    \n    // ray march scene\n    vec4 rayMarch = rayMarch(fragCoord, camPos, camDir, camUp, fov);    \n    if(rayMarch.x > 0.0) {\n        float zDepth = rayMarch.x;\n        float depthMask = pow(max(0.0, zDepth-2.0)*0.01,.5);\n        depthMask = clamp(0.,1.,1.0-depthMask);\n        vec3 normal = calcNormal(rayMarch.yzw);\n        float ao = calcAO(rayMarch.yzw, normal);\n        \n        vec3 mat = rayMarch.z > .01 ? vec3(.7,.5,.3) : vec3(0.5+0.01*float((int(floor(rayMarch.y) + floor(rayMarch.w)) % 2) == 0));\n\n        \n        // ambiant with BG color\n        col = bg*.5*mat;\n        \n        //  directional light\n        vec3 directionalLight = normalize(vec3(1.,-2.,2.));\n        float directionalDiffuse = clamp(dot(-directionalLight,normal), 0., 1.);\n        float directionalShadow = calcSoftShadow(rayMarch.yzw, -1.*directionalLight, 0.0001, 3.5);\n        col += mat * 1.0 * directionalDiffuse * directionalShadow; \n        \n        // add Fresnel sheen to Teddy\n        if(rayMarch.z > .01) {\n            col += 0.2 - .2 * clamp(dot(normal, normalize(camPos-rayMarch.yzw)), 0., 1.);\n            col = clamp(col, 0., 1.);\n        }        \n        \n        // AO\n        col = lerp(col*col*col, col, pow(ao, .2));\n        \n        // atmospheric fog\n        col = lerp(bg, col, depthMask);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}