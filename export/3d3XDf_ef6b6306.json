{"ver":"0.1","info":{"id":"3d3XDf","date":"1572975030","viewed":125,"name":"Goutte 5","username":"denosya","description":"Training purpose","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["gouttedeau"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BACKZ 5.0\n#define BACKSCALE 5.0\n\n#define ANIM_DURATION 5.0\n#define ANIM_LOOP_DURATION 20.0\n\n#define SHADOW_SMOOTHNESS 0.66\n#define SHADOW_INTENSITY 0.25\n\n#define HILIGHT 0.9\n#define SHININESS 40.0\n#define AMBIANT 0.85\n\n#define MATERIAL 1.33\n\n\nstruct Drop {\n    vec3 center;\n    vec3 radius;\n};\n    \nstruct Sphere {\n    vec3 center;\n    float radius;\n};\n\nvec3 light() {\n\treturn vec3(2.0 * cos(iTime*0.),0.0,1.5);\n}\n    \n    \nbool intersectSphere(in vec3 origin, in vec3 ray, in Sphere sphere, out vec3 col1, out vec3 col2, out vec3 normal) {\n    \n    vec3 oc = sphere.center - origin;\n    vec3 P  = origin + ray * dot(oc, ray);\n    \n    float centerP = length(P-sphere.center);    \n    \n    if(centerP>sphere.radius) {\n        return false;\n    }\n\n    float l = sqrt(sphere.radius*sphere.radius - centerP*centerP);\n    \n    col1 = P - ray * l;\n    col2 = P + ray * l;    \n    \n    normal = normalize(col1 - sphere.center);\n    \n    return true;\n}\n\n\nbool intersectDrop(in vec3 origin, in vec3 ray, Drop drop, out vec3 col1, out vec3 col2, out vec3 normal) {\n    \n    vec3 newOrigin = drop.center + (origin-drop.center) / drop.radius;\n    \n    ray = normalize(ray / drop.radius);\n\n    if(intersectSphere(newOrigin, ray, Sphere(drop.center, drop.radius.x), col1, col2, normal)) {\n    \n        col1 = drop.center + (col1 - drop.center) / drop.radius;\n        normal = normalize(col1 - drop.center);\n        return true;\n    }\n    \n    return false;\n}\n\nfloat getBackgroundLighting(vec3 m, Drop drop) {\n    \n    vec3 light = light();\n    float shadow = 0.0;\n\n    vec3 lightingNormal = vec3(0,0,-1); \n    \n    // Caustiques\n    vec3 v0 = -normalize(m - light);\n    vec3 col1, col2, normal;\n    \n    if(intersectDrop(m, v0, drop, col1, col2, normal)) {\n        vec3 v1 = refract(v0, normal, MATERIAL);\n\n        vec3 outsidepoint = col1 + v1 * 100.0;\n        vec3 col3, col4;\n        \n        intersectDrop(outsidepoint, -v1, drop, col3, col4, lightingNormal);\n    }\n    \n    float lighting = max(dot(v0, lightingNormal), 0.0);\n    \n\n    return 0.75 + pow(lighting, 6.0);\n}\n    \n    \nvec4 background(in vec3 origin, in vec3 ray, in Drop drop) {\n\n    float dz = BACKZ - origin.z;\n    vec3 coll = origin + ray * (dz/ray.z);\n    \n    //float lighting = 1.0 - getShadow(coll, drop)*SHADOW_INTENSITY;\n    vec4 color = texture(iChannel1, coll.xy/BACKSCALE);\n    \n    /*\n    if(floor(mod(coll.x,0.25)*8.0) == floor(mod(coll.y,0.25)*8.0))\n        color = vec4(1);\n    else\n        color = vec4(0);\n    \n   // color = vec4(coll.x*0.5+0.5, coll.y*0.5+0.5, coll.x*coll.y*0.25+0.5, 1.0);\n    */\n    \n    \n    return color * getBackgroundLighting(coll, drop);\n}\n    \nvec4 computeColor(vec3 eye, vec3 ray, in vec3 m, in vec3 normal, in Drop drop) {\n    \n    // Lighting \n    vec3 light = light();\n    float hilight = pow(max(dot(reflect(normalize(m-light), normal), -ray), 0.0), SHININESS);\n    float diffuse = clamp(dot(normalize(light-m), normal), 0.0, 1.0); \n    float ambiant = AMBIANT;\n    \n\t// Reflection\n    vec4 reflexion = texture(iChannel0, reflect(ray, normal));    \n    \n    // Refraction \n    vec3 mo = drop.center - m;\n    vec3 i2 = refract(ray, normal, 1.0/MATERIAL);\n    \n    vec3 outsidePoint = m + i2 * 100.0;\n    vec3 m2, col2, n2;\n    intersectDrop(outsidePoint, -i2, drop, m2, col2, n2);\n    \n    vec4 refraction;\n    \n    if(m2.z < BACKZ) {\n    \trefraction = background(m, i2, drop);\n    }\n    else {\n\n        vec3 mm2 = normalize(m2 - m);\n        vec3 i3 = refract(mm2, -n2, MATERIAL);  \n\n        refraction = background(m2, i3, drop);\n    }\n    \n    float lighting = clamp(ambiant + diffuse, 0.0, 1.0);\n\n    return mix(refraction, reflexion, .15)*lighting + hilight * HILIGHT;     \n}\n\nfloat anim(float amplitude, float amorti, float shift) {\n\n    float sequenceTime = mod(iTime*4.0 + shift, ANIM_LOOP_DURATION) / ANIM_LOOP_DURATION;\n    \n    float a = 3.1415 *(amorti*sequenceTime-1.0);\n    return (1.0 ) + sin(a)/a * amplitude;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n\n    Drop drop = Drop(vec3(0.,0.,4.5), vec3(1.15, 0.99, 0.53));\n    \n    drop.radius.x *= anim(0.017, 15.0, 0.0);\n    drop.radius.y *= anim(-0.025, 11.0, 0.35);\n\n    vec3 p = vec3(uv.x, uv.y, .0);\n\n    vec3 eye = vec3(0,0,-1.5);\n    vec3 ray = normalize(p-eye);\n\n    vec3 coll1, coll2, normal;\n    \n     if(intersectDrop(eye, ray, drop, coll1, coll2, normal)) {\n    \tfragColor = computeColor(eye, ray, coll1, normal, drop);\n        //fragColor = vec4(vec3(normal.xy, -normal.z),0);\n    }\n    else {    \n        fragColor = background(eye, ray, drop);\n        //fragColor = vec4(0);\n    }\n}\n\n","name":"Image","description":"","type":"image"}]}