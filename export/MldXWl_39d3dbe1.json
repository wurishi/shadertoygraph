{"ver":"0.1","info":{"id":"MldXWl","date":"1482255233","viewed":128,"name":"#Devember 2016 - day 19","username":"theGiallo","description":"I've added repeated lights with shadows","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["firstperson","devember"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SQRT2 1.4142135623730950488016887242096980785696\n#define PI    3.1415926535897932384626433832795\n#define HPI   1.57079632679489661923132169\n#define QPI   0.785398163397448309615660845819875721\n#define TAU   6.283185307179586476925286766559\n\n#define RENDER_REFLECTIONS 1\n#define DRAW_ITERATIONS_GRADIENT 0\n#define RAYM_MAX_ITERS 500\n#define SHADOW_MAX_ITERS 16\n\n#define CAMERA_LINEAR 0\n#define INVERTED_Y_AXIS 0\n\n#define MPt vec2\n#define distance x\n\n\nconst vec3 point_light_pos = vec3(12.0,0.0,3.8);\nconst float point_light_int = 1.0;\nconst float point_light_radius = 6.0;\nconst vec3 rep = vec3(0.0,3.0,0.0);\nconst int nl = int( ceil( 2.0 * point_light_radius / rep.y ) );\n\nstruct\nMaterial\n{\n    vec3 color;\n    float diffuse_reflection;\n    float specular_reflection;\n    float ambient_reflection;\n    float shininess;\n};\nstruct\nMaterial_Point\n{\n    float distance;\n    Material material;\n};\n    \n#define MAT_PLASTIC  0.0\n#define MAT_ORANGE   1.0\n#define MAT_RED      2.0\n#define MAT_GREEN    3.0\n#define MAT_BLUE     4.0\n#define MAT_FLOOR_W  5.0\n#define MAT_FLOOR_B  6.0\n#define MAT_METAL_GRID 7.0\n#define MAT_TUNNEL_WALL_W 8.0\n#define MAT_COUNT    9\n\n////////////////////////////////////////////////////////////////////////////////\n\nfloat\nmanhattan( vec2 p )\n{\n    p = abs ( p );\n    float ret = p.x + p.y;\n    return ret;\n}\nfloat\nmanhattan( vec2 p0, vec2 p1 )\n{\n    float ret;\n    \n    vec2 d = abs ( p1 - p0 );\n    ret = d.x + d.y;\n    \n    return ret;\n}\nfloat\nmanhattan( in vec3 p )\n{\n    p = abs ( p );\n    float ret = p.x + p.y + p.z;\n    return ret;\n}\nfloat\nsum( in vec2 p )\n{\n    float ret = p.x + p.y;\n    return ret;\n}\nfloat\nsum( in vec3 p )\n{\n    float ret = p.x + p.y + p.z;\n    return ret;\n}\n\n#define pow2(v) (v*v)\n#define pow3(v) (v*v*v)\n\nfloat\npow4( in float v )\n{\n    v = v*v;\n    v = v*v;\n    return v;\n}\nvec2\npow4( in vec2 v )\n{\n    v = v*v;\n    v = v*v;\n    return v;\n}\nvec3\npow4( in vec3 v )\n{\n    v = v*v;\n    v = v*v;\n    return v;\n}\nfloat\npow6( in float v )\n{\n    float ret = v*v;\n    ret = ret*ret;\n    ret = ret * v;\n    return ret;\n}\nvec2\npow6( in vec2 v )\n{\n    vec2 ret = v*v;\n    ret = ret*ret;\n    ret = ret * v;\n    return ret;\n}\nvec3\npow6( in vec3 v )\n{\n    vec3 ret = v*v;\n    ret = ret*ret;\n    ret = ret * v;\n    return ret;\n}\nvec2\npow8( in vec2 v )\n{\n    v = v*v;\n    v = v*v;\n    v = v*v;\n    return v;\n}\nvec3\npow8( in vec3 v )\n{\n    v = v*v;\n    v = v*v;\n    v = v*v;\n    return v;\n}\nvec2\npowv2( in vec2 v, in float exp )\n{\n    return pow( v, vec2(exp,exp) );\n}\nvec3\npowv3( in vec3 v, in float exp )\n{\n    return pow( v, vec3(exp,exp,exp) );\n}\n\nvec4\ncircle( vec4 color, vec2 pos, float radius, float border_width, vec2 point )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float dist = length( point - pos );\n    ret = color * (1.0 - smoothstep( radius, radius + border_width, dist ) );\n    \n    return ret;\n}\nvec4\nsquare( vec4 color, vec2 pos, float side, float border_width, float rot_rad, vec2 point )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float max_d = SQRT2 * side;\n    vec2 rd = point - pos;\n    float tot_rad = QPI + rot_rad;\n    vec2 rd_rot;\n    rd_rot.x = rd.x * cos( tot_rad ) + rd.y * sin( tot_rad );\n    rd_rot.y = rd.x * sin( tot_rad ) - rd.y * cos( tot_rad );\n    float dist = manhattan( rd_rot );\n    ret = color * (1.0 - smoothstep( max_d, max_d + border_width, dist ) );\n    \n    return ret;\n}\nvec4\nsquare_tex( vec4 color, vec2 pos, float side, float border_width, float rot_rad, vec2 point, sampler2D tex )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float max_d = SQRT2 * side;\n    vec2 rd = point - pos;\n    float tot_rad = QPI + rot_rad;\n    vec2 rd_rot;\n    rd_rot.x = rd.x * cos( tot_rad ) + rd.y * sin( tot_rad );\n    rd_rot.y = rd.x * sin( tot_rad ) - rd.y * cos( tot_rad );\n    float dist = manhattan( rd_rot );\n    ret = color * (1.0 - smoothstep( max_d, max_d + border_width, dist ) );\n    ret *= texture( tex, rd_rot * (0.5 / side ) + 0.5 );\n    \n    return ret;\n}\n\n// NOTE(theGiallo): pre-multiplied alpha\nvoid\nblend_pma( inout vec4 dst, in vec4 src )\n{\n    dst.rgb = src.rgb + dst.rgb * ( 1.0 - src.a );\n    dst.a = min( 1.0, dst.a + src.a );\n}\n\nfloat\nmirror( float x )\n{\n    x *= 0.5;\n    return 1.0 - abs( 2.0 * ( x - floor(x) ) - 1.0 );\n}\n\nfloat\ndecimal( float x )\n{\n    return x - floor(x);\n}\n\n// NOTE(theGiallo): h in [0,1)\nvec3\nrgb_from_hsv( vec3 hsv )\n{\n\tvec3 ret;\n\tfloat c = hsv.g * hsv.b;\n\tfloat hh = hsv.r * 6.0;\n\n\tfloat x = c * ( 1.0 - abs( hh - 2.0 * floor( hh / 2.0 ) - 1.0 ) );\n\n\tif ( hh < 1.0 || hh >= 6.0 )\n\t{\n\t\tret.r = c;\n\t\tret.g = x;\n\t\tret.b = 0.0;\n\t} else\n\tif ( hh < 2.0 )\n\t{\n\t\tret.r = x;\n\t\tret.g = c;\n\t\tret.b = 0.0;\n\t} else\n\tif ( hh < 3.0 )\n\t{\n\t\tret.r = 0.0;\n\t\tret.g = c;\n\t\tret.b = x;\n\t} else\n\tif ( hh < 4.0 )\n\t{\n\t\tret.r = 0.0;\n\t\tret.g = x;\n\t\tret.b = c;\n\t} else\n\tif ( hh < 5.0 )\n\t{\n\t\tret.r = x;\n\t\tret.g = 0.0;\n\t\tret.b = c;\n\t} else\n\tif ( hh < 6.0 )\n\t{\n\t\tret.r = c;\n\t\tret.g = 0.0;\n\t\tret.b = x;\n\t}\n\n\tfloat m = hsv.b - c;\n\tret.r += m;\n\tret.g += m;\n\tret.b += m;\n\n\treturn ret;\n}\n\n#define ORANGE_RGB vec3(1.0,0.4,0.0)\n#define T_EPS 0.001\n\nfloat\nminv3( in vec3 v )\n{\n    return min( v.x, min( v.y, v.z ) );\n}\n\nfloat\nmaxv3( in vec3 v )\n{\n    return max( v.x, max( v.y, v.z ) );\n}\n\nfloat\nminv2( in vec2 v )\n{\n    return min( v.x, v.y );\n}\n\nfloat\nmaxv2( in vec2 v )\n{\n    return max( v.x, v.y );\n}\n\n\n#define length3( v ) ( pow(sum(pow3(v)),1.0/3.0) )\n#define length4( v ) ( pow(sum(pow3(v)),1.0/4.0) )\n#define length6( v ) ( pow(sum(pow3(v)),1.0/6.0) )\n#define length8( v ) ( pow(sum(pow3(v)),1.0/8.0) )\n\n\nvec3\nat_pos( in vec3 pos, in vec3 p )\n{\n    return p-pos;\n}\n\nmat4\ntr( mat4 m )\n{\n    return mat4(\n       vec4(m[0][0],m[1][0],m[2][0],m[3][0]),\n       vec4(m[0][1],m[1][1],m[2][1],m[3][1]),\n       vec4(m[0][2],m[1][2],m[2][2],m[3][2]),\n       vec4(m[0][3],m[1][3],m[2][3],m[3][3])\n    );\n}\n\nvec3\nrotate( in vec3 r, in vec3 p )\n{\n\tmat4 Rx = mat4(\n\t   vec4( 1.0, 0.0,      0.0,       0.0 ),\n\t   vec4( 0.0, cos(r.x), -sin(r.x), 0.0 ),\n\t   vec4( 0.0, sin(r.x),  cos(r.x), 0.0 ),\n\t   vec4( 0.0, 0.0,      0.0,       0.0 ) );\n\tmat4 Ry = mat4(\n\t   vec4(  cos(r.y), 0.0, sin(r.y), 0.0 ),\n\t   vec4(  0.0,      1.0, 0.0,      0.0 ),\n\t   vec4( -sin(r.y), 0.0, cos(r.y), 0.0 ),\n\t   vec4(  0.0,      0.0, 0.0,      1.0 ) );\n\tmat4 Rz = mat4(\n\t   vec4( cos(r.z), -sin(r.z), 0.0, 0.0 ),\n\t   vec4( sin(r.z),  cos(r.z), 0.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       1.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       0.0, 1.0 ) );\n\tmat4 m = Rx * Ry * Rz;\n\treturn (vec4(p,1.0)*m).xyz;\n}\nvec3\nrotate_inv( in vec3 r, in vec3 p )\n{\n    r = -r;\n\tmat4 Rx = mat4(\n\t   vec4( 1.0, 0.0,      0.0,       0.0 ),\n\t   vec4( 0.0, cos(r.x), -sin(r.x), 0.0 ),\n\t   vec4( 0.0, sin(r.x),  cos(r.x), 0.0 ),\n\t   vec4( 0.0, 0.0,      0.0,       0.0 ) );\n\tmat4 Ry = mat4(\n\t   vec4(  cos(r.y), 0.0, sin(r.y), 0.0 ),\n\t   vec4(  0.0,      1.0, 0.0,      0.0 ),\n\t   vec4( -sin(r.y), 0.0, cos(r.y), 0.0 ),\n\t   vec4(  0.0,      0.0, 0.0,      1.0 ) );\n\tmat4 Rz = mat4(\n\t   vec4( cos(r.z), -sin(r.z), 0.0, 0.0 ),\n\t   vec4( sin(r.z),  cos(r.z), 0.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       1.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       0.0, 1.0 ) );\n\tmat4 m = Rz * Ry * Rx;\n\treturn (vec4(p,1.0)*m).xyz;\n}\n// NOTE(theGiallo): s.x radius, s.y Y axis rotation, s.z Z axis rotation\nvec3\ncartesian_from_spherical( in vec3 s )\n{\n\tmat4 Ry = mat4(\n\t   vec4(  cos(s.y), 0.0, sin(s.y), 0.0 ),\n\t   vec4(  0.0,      1.0, 0.0,      0.0 ),\n\t   vec4( -sin(s.y), 0.0, cos(s.y), 0.0 ),\n\t   vec4(  0.0,      0.0, 0.0,      1.0 ) );\n\tmat4 Rz = mat4(\n\t   vec4( cos(s.z), -sin(s.z), 0.0, 0.0 ),\n\t   vec4( sin(s.z),  cos(s.z), 0.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       1.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       0.0, 1.0 ) );\n\tmat4 m = Ry * Rz;\n\treturn (vec4(0.0,0.0,s.x,1.0)*m).xyz;\n}\n\nvec3\nat_angle( in vec3 a, in vec3 p )\n{\n    return rotate_inv( a, p );\n}\n\n#if 0\nvec3\nrepeat( in vec3 rep, in vec3 p )\n{\n    return mod(p,rep) + 0.5*rep;\n}\n#endif\n\nvec3\nrepeated( in vec3 rep, in vec3 p )\n{\n    return mod( p, rep ) - 0.5 * rep;\n}\n\nvec2\nunion_op( in vec2 p0, in vec2 p1 )\n{\n    if ( p0.x < p1.x )\n    {\n        return p0;\n    }\n    return p1;\n}\n\nvec2\nintersect_op( in vec2 p0, in vec2 p1 )\n{\n    if ( p0.x > p1.x )\n    {\n        return p0;\n    }\n    return p1;\n}\n\nvec2\nsubtract_op( in vec2 p0, in vec2 p1 )\n{\n    p0.x = -p0.x;\n    if ( p0.x > p1.x )\n    {\n        return p0;\n    }\n    return p1;\n}\n\nvec2\nmix_op_( in vec2 p0, in vec2 p1, float max_dist )\n{\n    bool do_mix = p0.x > 0.0 && p0.x < max_dist &&\n                  p1.x > 0.0 && p1.x < max_dist;\n    if ( !do_mix && p0.x < p1.x )\n    {\n        return p0;\n    }\n    if ( !do_mix && p1.x < p0.x )\n    {\n        return p1;\n    }\n    float h_max_dist = max_dist * 0.5;\n    p0.x = (p0.x-h_max_dist)/h_max_dist;\n    p1.x = (p1.x-h_max_dist)/h_max_dist;\n    float p02 = p0.x*p0.x;\n    float p12 = p1.x*p1.x;\n    float v = ( p0.x + p1.x )*0.5;\n    vec2 ret = vec2(max_dist * v, p0.y );\n\n    return ret;\n}\nvec2\nmix_op_( in vec2 p0, in vec2 p1, float max_dist, float m0 )\n{\n    bool do_mix = p0.x > 0.0 && p0.x < max_dist &&\n                  p1.x > 0.0 && p1.x < max_dist;\n    if ( !do_mix && p0.x < p1.x )\n    {\n        return p0;\n    }\n    if ( !do_mix && p1.x < p0.x )\n    {\n        return p1;\n    }\n    float h_max_dist = max_dist * 0.5;\n    p0.x = (p0.x-h_max_dist)/h_max_dist;\n    p1.x = (p1.x-h_max_dist)/h_max_dist;\n    float v = mix( p0.x, p1.x, m0 );\n    vec2 ret = vec2(max_dist * v, p0.y );\n\n    return ret;\n}\nvec2\nmix_op_( in vec2 p0, in vec2 p1, vec2 max_dist )\n{\n    bool do_mix = p0.x > 0.0 && p0.x < max_dist.x &&\n                  p1.x > 0.0 && p1.x < max_dist.y;\n    if ( !do_mix && p0.x < p1.x )\n    {\n        return p0;\n    }\n    if ( !do_mix && p1.x < p0.x )\n    {\n        return p1;\n    }\n    vec2 h_max_dist = max_dist * 0.5;\n    p0.x = (p0.x-h_max_dist.x)/h_max_dist.x;\n    p1.x = (p1.x-h_max_dist.y)/h_max_dist.y;\n    float v = mix( p0.x, p1.x, 0.5 );\n    vec2 ret = vec2(minv2(max_dist) * v, p0.y );\n\n    return ret;\n}\n\nvec2\nmix_op_9avg( in vec2 p0, in vec2 p1, float max_dist )\n{\n    bool do_mix = p0.x > 0.0 && p0.x < max_dist &&\n                  p1.x > 0.0 && p1.x < max_dist;\n    if ( !do_mix && p0.x < p1.x )\n    {\n        return p0;\n    }\n    if ( !do_mix && p1.x < p0.x )\n    {\n        return p1;\n    }\n    vec2 m1 = mix_op_(p0,p1,vec2(max_dist*0.9, max_dist*0.1));\n    vec2 m2 = mix_op_(p0,p1,vec2(max_dist*0.8, max_dist*0.2));\n    vec2 m3 = mix_op_(p0,p1,vec2(max_dist*0.7, max_dist*0.3));\n    vec2 m4 = mix_op_(p0,p1,vec2(max_dist*0.6, max_dist*0.4));\n    vec2 m5 = mix_op_(p0,p1,vec2(max_dist*0.5, max_dist*0.5));\n    vec2 m6 = mix_op_(p0,p1,vec2(max_dist*0.4, max_dist*0.6));\n    vec2 m7 = mix_op_(p0,p1,vec2(max_dist*0.3, max_dist*0.7));\n    vec2 m8 = mix_op_(p0,p1,vec2(max_dist*0.2, max_dist*0.8));\n    vec2 m9 = mix_op_(p0,p1,vec2(max_dist*0.1, max_dist*0.9));\n    #if 0\n    return vec2((m1.x+m2.x+m3.x+m4.x+m5.x+m6.x+m7.x+m8.x+m9.x)/9.0,m9.y);\n    #else\n    return\n    vec2( minv3(\n       vec3( minv3(vec3(m1.x,m2.x,m3.x)),\n             minv3(vec3(m4.x,m5.x,m6.x)),\n             minv3(vec3(m7.x,m8.x,m9.x)) ) ), m9.y );\n    #endif\n}\n\nvec2\nmix_op_p2( in vec2 p0, in vec2 p1, float max_dist )\n{\n    bool do_mix = p0.x > 0.0 && p0.x < max_dist &&\n                  p1.x > 0.0 && p1.x < max_dist;\n    if ( !do_mix && p0.x < p1.x )\n    {\n        return p0;\n    }\n    if ( !do_mix && p1.x < p0.x )\n    {\n        return p1;\n    }\n    vec2 d;\n    d.x = p1.x - pow2( ( max_dist - p0.x ) / max_dist ) * max_dist;\n    d.y = p0.x - pow2( ( max_dist - p1.x ) / max_dist ) * max_dist;\n    return vec2((d.x+d.y)*0.5,p0.y);\n    //return vec2(min(d.x,d.y),p0.y);\n}\n\n// IQ's polynomial smooth min (k = 0.1);\nfloat\nsmin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2\nsmin_op( in vec2 p0, in vec2 p1, float max_dist )\n{\n    float m = smin(p0.x,p1.x,max_dist);\n    return vec2(m,m-p0.x>=m-p1.x?p0.y:p1.y);\n}\n\nvec2\nmix_op( in vec2 p0, in vec2 p1, float max_dist )\n{\n    if ( mod( iTime, 2.0 ) < 1.0 )\n    {\n        return smin_op(p0,p1,max_dist);\n    } else\n    {\n    \treturn mix_op_9avg(p0,p1,max_dist);\n    }\n#if 0\n\treturn mix_op_p2(p0,p1,max_dist);\n#endif\n}\n\nMaterial\nchange_color( Material m, vec3 color )\n{\n    Material ret = m;\n    ret.color = color;\n    return ret;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nfloat\nsphere_sd( in float sph_r, in vec3 p )\n{\n    return length( p ) - sph_r;\n}\n\nfloat\naab_sd( in vec3 sides, in vec3 p )\n{\n    sides *= 0.5;\n    p = abs( p );\n    vec3 d = p - sides;\n    return min( maxv3( d ), 0.0 ) + length( max(d,0.0) );\n}\n\nfloat\nplane_sd( in vec3 p )\n{\n    return abs( p.z );\n}\n\n\nfloat\nhalf_space_sd( in vec3 p )\n{\n    return p.z;\n}\n\nfloat\nround_aab_ud( in vec3 sides, in float r, in vec3 p )\n{\n    sides *= 0.5;\n    p = abs( p );\n    vec3 d = p - sides;\n    return length( max(d, 0.0) ) - r;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length(p.xy)-torus.x,p.z);\n    return length(q)-torus.y;\n}\n\nfloat\ncylinder_sd( in float r, in vec3 p )\n{\n    return length( p.xy ) - r;\n}\n\nfloat\ncapped_cylinder_sd( in vec2 rh, in vec3 p )\n{\n    vec2 d = abs( vec2( length( p.xy ), p.z ) ) - rh;\n    return min( maxv2(d), 0.0 ) + length( max(d, 0.0) );\n}\n\nfloat\nhalf_cone_pos_sd( in vec2 c, in vec3 p )\n{\n    vec2 c1 = vec2(c.y,-c.x);\n    return dot( c1, vec2(length(p.xy), p.z) );\n}\n\nfloat\ncone_sd( in vec2 c, in vec3 p )\n{\n    p = abs(p);\n    vec2 c1 = vec2(c.y,-c.x);\n    return dot( c1, vec2(length(p.xy), p.z) );\n}\n\nfloat\ncapped_cone_as_intersections_sd( in float h, in float r1, in float r2, in vec3 p )\n{\n    float R1z = (r1*h)/(r2-r1);\n    float R2z = R1z + h;\n    p = at_pos(vec3(0.0,0.0,-R1z),p);\n\tvec2 c = vec2(r2/R2z,1.0);\n\treturn\n\tmax( max( -half_space_sd( at_pos(vec3(0.0,0.0,R1z), p) ), half_space_sd( at_pos( vec3(0.0,0.0,R2z), p ) ) ),\n         half_cone_pos_sd( c, p )\n       );\n}\n\n// NOTE(theGiallo): d.x is the depth of the prism(or height), d.y the radius\n// NOTE(theGiallo): depth on x axis, diameter on y axis\nfloat\nhex_prism_sd( in vec2 dr, in vec3 p )\n{\n    p = abs(p);\n    return max(p.x-dr.x*0.5,max(p.y*0.866025+p.z*0.5,p.z)-0.866025*dr.y);\n}\n\nfloat\ntri_prism_sd( in vec2 ds, in vec3 p )\n{\n  \tp.xy = abs(p.xy);\n    \n    return max( p.x - ds.x*0.5, max( p.y * 0.866025 + 0.5 * p.z - ds.y * 0.433012702, -p.z ) );\n}\n\nfloat\ntri_prism_bary_sd( in vec2 ds, in vec3 p )\n{\n    p.z += ds.y * 0.288675135;\n    \n    return tri_prism_sd( ds, p );\n}\n\nfloat\ntri_prism_bary_r_sd( in vec2 dr, in vec3 p )\n{\n    dr.y = dr.y * 1.732050808;\n    \n    return tri_prism_bary_sd( dr, p );\n}\n\nfloat\ncline_sd( in vec3 a, in vec3 b, in float r, in vec3 p )\n{\n    vec3 ap = p - a, ab = b - a;\n    float t = clamp( dot(ap,ab)/dot(ab,ab), 0.0, 1.0 );\n    return length( ap - ab * t ) - r;\n}\n\nfloat\nellipsoid_sd( in vec3 r3, in vec3 p )\n{\n    return ( length( p/r3 ) - 1.0 ) * minv3(r3);\n}\n\nfloat\nsphere8_sd( in float sph_r, in vec3 p )\n{\n    return length8( p ) - sph_r;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus82_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length(p.xy)-torus.x,p.z);\n    return length8(q)-torus.y;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus88_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length8(p.xy)-torus.x,p.z);\n    return length8(q)-torus.y;\n}\n\n\nfloat\nsphere4_sd( in float sph_r, in vec3 p )\n{\n    return length4( p ) - sph_r;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus42_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length(p.xy)-torus.x,p.z);\n    return length4(q)-torus.y;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus44_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length4(p.xy)-torus.x,p.z);\n    return length4(q)-torus.y;\n}\n\nfloat\nsphere3_sd( in float sph_r, in vec3 p )\n{\n    return length3(abs(p)) - sph_r;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus32_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length(p.xy)-torus.x,p.z);\n    return length3(abs(q))-torus.y;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus33_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length3(abs(p.xy))-torus.x,p.z);\n    return length3(abs(q))-torus.y;\n}\n\nfloat\nspheremh_sd( in float sph_r, in vec3 p )\n{\n    return manhattan(p) - sph_r;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus2mh_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(manhattan(p.xy)-torus.x,p.z);\n    return length(q)-torus.y;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorusmh2_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length(p.xy)-torus.x,p.z);\n    return manhattan(q)-torus.y;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorusmhmh_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(manhattan(p.xy)-torus.x,p.z);\n        return manhattan(q)-torus.y;\n}\n\n\nfloat\ncapped_cylinder8_sd( in vec2 rh, in vec3 p )\n{\n    vec2 d = abs( vec2( length8( p.xy ), p.z ) ) - rh;\n    return min( maxv2(d), 0.0 ) + length8( max(d, 0.0) );\n}\n\nfloat\ncapped_cylindermh_sd( in vec2 rh, in vec3 p )\n{\n    vec2 d = abs( vec2( manhattan( p.xy ), p.z ) ) - rh;\n    return min( maxv2(d), 0.0 ) + manhattan( max(d, 0.0) );\n}\n    \n//////////\n\nvec2\nmap( in vec3 pos )\n{    \n    float angle4 = iTime*TAU*0.25;\n    \n    MPt res;\n    res.distance = 1e38;\n\n    float m = mod( floor(pos.x * 2.0) + floor(pos.y * 2.0), 2.0 );\n    res = union_op( MPt( plane_sd( pos ),\n                         MAT_FLOOR_B * (1.0 - m) + MAT_FLOOR_W * m ),\n                    res );\n    \n    const float axis_r = 0.05;\n    res = union_op( MPt( sphere_sd( axis_r*2.0, at_pos( vec3(0.0), pos ) ),\n                         MAT_PLASTIC ), res );\n    res = union_op( MPt( cline_sd( vec3(0.0), vec3(1.0,0.0,0.0), axis_r, pos ),\n                         MAT_RED ),res );\n    res = union_op( MPt( cline_sd( vec3(0.0), vec3(0.0,1.0,0.0), axis_r, pos ),\n                         MAT_GREEN ),res );\n    res = union_op( MPt( cline_sd( vec3(0.0), vec3(0.0,0.0,1.0), axis_r, pos ),\n                         MAT_BLUE ),res );\n    \n    \n    \n    \n    // NOTE(theGiallo): light\n    vec3 lp = repeated( rep,at_pos( point_light_pos + vec3(0.0,0.0,0.15), pos ));\n    res =\n       union_op(\n           MPt( capped_cylinder_sd( vec2(0.02,0.4) , at_pos( vec3(0.0,0.0,0.5),lp ) ), MAT_PLASTIC ),\n           res\n       );\n    res =\n       union_op(\n           intersect_op(\n              subtract_op(\n                 MPt( sphere_sd(\n                         0.09, lp\n                      ), MAT_ORANGE\n                    ),\n                 MPt( sphere_sd(\n                         0.1, lp\n                      ), MAT_PLASTIC\n                    )\n               ),\n               MPt( aab_sd( vec3(0.2,0.2,0.2), at_pos( vec3(0.0,0.0,0.1),lp) ), MAT_PLASTIC )\n            ), res );\n    \n    vec3 op = pos;\n    pos = repeated( vec3(0.0,4.0,0.0), pos );\n    \n    // NOTE(theGiallo): tunnel section\n    float X = 12.0;\n    vec3 P = at_pos(vec3(X,0.0,2.5), pos );\n    res =\n       union_op(\n          subtract_op(\n             union_op(\n                MPt( capped_cylinder_sd (vec2(2.0,5.0),\n                                         at_angle( vec3(HPI,0.0,0.0),\n                                                   P ) ), MAT_TUNNEL_WALL_W ),\n                intersect_op(\n                   MPt( capped_cylinder_sd (vec2(2.05,0.25),\n                                            at_angle( vec3(HPI,0.0,0.0),\n                                                      repeated( vec3(0.0,1.0,0.0),\n                                                                P ) ) ), MAT_ORANGE ),\n                   MPt( aab_sd(vec3(5.0,4.0,3.0),at_pos(vec3(0.0,0.0,1.0),P) ), MAT_TUNNEL_WALL_W ) )\n                ),\n             MPt( aab_sd(vec3(5.0,4.05,5.0),P ), MAT_TUNNEL_WALL_W )\n          ),\n          res );\n\n    // NOTE(theGiallo): grid\n    res =\n       union_op(\n          subtract_op(\n             MPt( aab_sd( vec3(0.02,0.02,0.1),\n                          repeated( vec3(0.02,0.02,0.0), at_angle( vec3(0.0,0.0,QPI),\n                                    at_pos( vec3(X,0.0,1.0),\n                                            pos) ) ) ), MAT_METAL_GRID ),\n             MPt( aab_sd(vec3(2.5,4.0,0.02),at_pos(vec3(X,0.0,1.0),pos) ), MAT_METAL_GRID )\n          ),\n          res );\n\n    \n    pos = op;\n    \n    \n\n\treturn res;\n}\n\nvec3\ncalc_normal( in vec3 pos, in float t )\n{\n    vec3 eps = vec3( max(0.02,T_EPS*t),0.0,0.0);\n\treturn normalize( vec3(\n           map( pos + eps.xyy ).distance - map( pos - eps.xyy ).distance,\n           map( pos + eps.yxy ).distance - map( pos - eps.yxy ).distance,\n           map( pos + eps.yyx ).distance - map( pos - eps.yyx ).distance ) );\n}\n\nvec2\nraymarch( in vec3 start, in vec3 dir, inout float t, in float t_max )\n{\n    MPt mp;\n    for ( int it=0; it!=RAYM_MAX_ITERS; ++it )\n    {\n        vec3 here = start + dir * t;\n        mp = map( here );\n        #if DRAW_ITERATIONS_GRADIENT\n        mp.y = mp.y * 10000.0 + float(it);\n        #endif\n        if ( mp.distance < ( T_EPS * t ) || t > t_max )\n        {\n        \tbreak;\n        }\n        #if 1\n        // NOTE(theGiallo): this is to sample nicely the twisted things\n        t += mp.distance * 0.4;\n        #else\n        t += mp.distance;\n        #endif\n    }\n    if ( t > t_max )\n    {\n        t = -1.0;\n    }\n    return mp;\n}\n\nfloat\nshadow( in vec3 start, in vec3 dir )\n{\n    float ret = 1.0;\n    float c = step( mod( iTime, 4.0 ), 2.0 );\n    float t = 0.02, t_max = 16.0;\n    MPt mp;\n    \n    #if DRAW_ITERATIONS_GRADIENT\n    int it_;\n    #endif\n    for ( int it=0; it!=SHADOW_MAX_ITERS; ++it )\n    {\n\t    #if DRAW_ITERATIONS_GRADIENT\n\t    it_ = it;\n    \t#endif\n        vec3 here = start + dir * t;\n        mp = map( here );\n        ret = min( ret, 8.0*mp.distance/t);\n        if ( mp.distance < ( T_EPS * t ) || t > t_max )\n        {\n        \tbreak;\n        }\n        \n        float inc;\n        // NOTE(theGiallo): this is to sample nicely the twisted things\n        inc = c * mp.distance * 0.4;\n\t\tinc += ( 1.0 - c ) * clamp( mp.distance, 0.02, 0.1 );\n        t += inc;\n    }\n    #if DRAW_ITERATIONS_GRADIENT\n    return float(it_);\n    #endif\n    if ( t > t_max )\n    {\n        t = -1.0;\n    }\n    if ( c == 0.0 ) return 1.0 - clamp( ret, 0.0, 1.0 );\n\n    if ( t < 0.0 )\n    {\n        return 0.0;\n    }\n    //return 1.0;\n    ret = 1.0 / pow(1.0 - 1e-30 + max( mp.distance, 1e-30 ), 5.0 );\n    float th = 0.1;\n    return smoothstep( 0.0, 1.0, ( ret*1.1 - th ) / (1.0-th) );\n}\n\n\nfloat\nimg_scale_given_h_fov( float near, float fov )\n{\n    float hw = iResolution.x / min( iResolution.y, iResolution.x );\n    return tan( fov * 0.5 ) * near / hw;\n}\n\nvec3\nrender_no_reflections( in Material materials_table[MAT_COUNT],\n                       in vec3 start, in vec3 dir, in float max_dist,\n                       inout float t, out vec3 normal, out int material_index )\n{\n    vec3 ret = rgb_from_hsv(vec3(0.57,0.5,0.7));\n    vec3 sun_specular_color = vec3(0.8,1.0,1.0);\n    vec3 sun_light_dir = normalize( rotate( vec3(0.0,0.0,0.0*iTime*TAU/16.0), vec3( -0.0, 1.0, -1.0 ) ) );\n\n    MPt mp = raymarch( start, dir, t, 1e2 );\n    material_index = int(mp.y);\n    Material mat;\n    for ( int i = 0; i != MAT_COUNT; ++i )\n    {\n        if ( i == material_index )\n        {\n            mat = materials_table[i];\n        }\n\t}\n\n    if ( t > 0.0 )\n    {\n        vec3 point = start + dir * t;\n        normal = calc_normal( point, t );\n        // ret = 0.5 + normal * 0.5;return ret;\n        \n\n        #if DRAW_ITERATIONS_GRADIENT\n        mp.y += shadow( point, -sun_light_dir );\n        #else\n        float sh = 1.0 - shadow( point, -sun_light_dir );\n        float diffuse = sh * max( 0.0, dot( normal, -sun_light_dir ) );\n        float spec = sh * pow( max( 0.0, dot( reflect( dir, normal ) , -sun_light_dir ) ), mat.shininess  );\n        #endif\n\n        float diffuse_pl = 0.0, spec_pl = 0.0;\n\n        for ( int i=0; i!=nl; ++i )\n        {\n        \tvec3 pld = -at_pos( point_light_pos + float(i)*rep, repeated( rep, point ) );\n        \tfloat ld = length( pld );\n        \tpld /= ld;\n        \tfloat ld2 = ld*ld;\n            float sh_pl = 0.0;\n\n        \t#if DRAW_ITERATIONS_GRADIENT\n        \tmp.y += shadow( point, pld );\n        \t#else\n        \tif ( ld <= point_light_radius )\n        \t{\n\t            sh_pl      = 1.0 - shadow( point, pld );\n\t        \tfloat diffuse_pl_ = sh_pl * max( 0.0, dot( normal, pld ) );\n\t        \tfloat spec_pl_    = sh_pl * pow( max( 0.0, dot( reflect( dir, normal ) , pld ) ), mat.shininess  );\n                diffuse_pl += diffuse_pl_ * point_light_int / ld2;\n                spec_pl    += spec_pl * point_light_int / ld2;\n\t    \t}\n            #endif\n        }\n        \n        #if !DRAW_ITERATIONS_GRADIENT\n        float ambient = 0.3;\n        ret = ( ( diffuse + diffuse_pl ) * mat.diffuse_reflection +\n                  ambient   * mat.ambient_reflection ) * mat.color +\n                ( spec + spec_pl  ) * mat.specular_reflection * sun_specular_color;\n        #endif\n    } else\n    if ( t == 0.0 )\n    {\n        ret = mat.color / ( 1.0 - 20.0 * mp.distance );\n    }\n    #if DRAW_ITERATIONS_GRADIENT\n    material_index = int(mp.y);\n    #endif\n    return ret;\n}\n\nvoid\ncamera_linear_gallery( in vec3 start, in vec3 obj_dist, in float sec_per_obj,\n                       out vec3 camera_pos )\n{\n    const int obj_count = 3;\n\n    float u = mirror( iTime / ( float(obj_count) * sec_per_obj ) );\n\n    //u = 1.0;\n\n    float pu = 1.0 / float(obj_count-1);\n    float pt = 0.0;\n    vec3 p = vec3(0.0);\n    for ( int i = 0; i!=obj_count; ++i )\n    {\n        float s = pu * ( -0.5 + float(i) );\n        p +=\n           ( start + obj_dist * float(i) ) *\n           ( smoothstep( s - 0.1 * pu, s + 0.1 * pu, u ) - smoothstep( s + pu * 0.9, s + pu * 1.1, u ) );\n    }\n    camera_pos.xyz = p;\n}\n\nvoid\ncamera_radial_gallery_mirror( in vec3 center, in vec2 radial_start, in vec2 obj_radial_dist, in float radius, in float sec_per_obj,\n                       out vec3 camera_pos )\n{\n    const int obj_count = 6;\n\n    float u = mirror( iTime / ( float(obj_count) * sec_per_obj ) );\n\n    //u = 1.0;\n\n    float pu = 1.0 / float(obj_count-1);\n    float pt = 0.0;\n    vec2 a = vec2(0.0);\n    for ( int i = 0; i!=obj_count; ++i )\n    {\n        float s = pu * ( -0.5 + float(i) );\n        a +=\n           ( obj_radial_dist * float(i) ) *\n           ( smoothstep( s - 0.1 * pu, s + 0.1 * pu, u ) - smoothstep( s + pu * 0.9, s + pu * 1.1, u ) );\n        \n    }\n    camera_pos.xyz = center + cartesian_from_spherical( vec3(radius,radial_start+a) );\n}\nvoid\ncamera_radial_gallery_loop( in vec3 center, in vec2 radial_start, in vec2 obj_radial_dist, in float radius, in float sec_per_obj,\n                       out vec3 camera_pos, out vec3 look )\n{\n    // NOT)theGiallo): set 1+ if you want a complete circle\n    const int obj_count = 9;\n\n    float u = decimal( iTime / ( float(obj_count) * sec_per_obj ) );\n    \n    \n    if ( iMouse.z > 0.0 )\n    {\n    \tvec2 mouse_u = iMouse.xy / iResolution.xy;\n        u = mouse_u.x;\n    }\n\n    //u = 1.0;\n\n    float pu = 1.0 / float(obj_count-1);\n    float pt = 0.0;\n    vec2 a = vec2(0.0);\n    for ( int i = 0; i!=obj_count; ++i )\n    {\n        float s = pu * ( -0.5 + float(i) );\n        a +=\n           ( obj_radial_dist * float(i) ) *\n           ( smoothstep( s - 0.1 * pu, s + 0.1 * pu, u ) - smoothstep( s + pu * 0.9, s + pu * 1.1, u ) );\n        \n    }\n    camera_pos.xyz = cartesian_from_spherical( vec3(radius,radial_start+a) );\n    look = normalize(-camera_pos);\n    camera_pos.xyz += center;\n}\n\nvoid\nfirst_person_camera( in vec3 pos, in vec2 angles0, in vec2 angles, out vec3 camera_pos, out vec3 look )\n{\n    vec2 a = angles*( iMouse.yx/iResolution.yx * 2.0 - 1.0 );\n\t//a = vec2(0.0);\n    a.y = -a.y;\n    #if INVERTED_Y_AXIS\n    a.x = -a.x;\n    #endif\n    a += angles0;\n    \n    camera_pos.xyz = cartesian_from_spherical( vec3(0.075,a) );\n    look = normalize(-camera_pos);\n    camera_pos.xyz = pos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 qc = 2.0 * q - 1.0;\n\tvec2 p = ( 2.0 * fragCoord.xy - iResolution.xy ) / min( iResolution.y, iResolution.x );\n    vec4 col;\n    \n    float img_plane_dist = 0.05;\n    float img_scale = img_scale_given_h_fov( img_plane_dist, TAU / 3.0 );\n\n    float time = iTime * PI * 0.06125;\n\n    vec3 d = vec3(6.0,0.0,0.0);\n    vec3 base = vec3(0.0,4.0,1.3);\n    \n    vec3 camera_pos;\n    vec3 look;\n    #if CAMERA_LINEAR\n    camera_linear_gallery( base, d, 4.0, camera_pos );\n    look = normalize( vec3(0.0,-0.5,-0.1) );\n    #else\n    //camera_radial_gallery_loop( vec3(12.0,0.0,2.0), vec2(HPI*0.8,-QPI), vec2(0.0,TAU/8.0), 4.0, 4.0, camera_pos, look );\n    \n    vec3 cp = vec3(12.0,0.0,2.8);\n    vec2 angles = vec2(PI*0.4,TAU*1.5);\n    vec2 angles0 = vec2(HPI,HPI);\n    first_person_camera( cp, angles0, angles, camera_pos, look );\n    #endif\n\n    vec3 up = vec3(0.0,0.0,1.0);\n    vec3 right = normalize(cross( look, up ));\n    vec3 img_up = cross( right, look );\n\n    vec3 dir = look * img_plane_dist + right * p.x * img_scale + img_up * p.y * img_scale;\n    vec3 start = camera_pos + dir;\n    dir = normalize( dir );\n\n    float max_dist = 1e2;\n    float max_dist_reflection = 1e1;\n    float t = 0.0, t1 = 0.0;\n    vec3 normal, normal1;\n    vec3 pos, pos1, dir1;\n\n    Material materials_table[MAT_COUNT];\n\n    materials_table[int(MAT_PLASTIC)].color = rgb_from_hsv( vec3(0.083,0.1,1.0) );\n    materials_table[int(MAT_PLASTIC)].diffuse_reflection  = 1.0;\n    materials_table[int(MAT_PLASTIC)].specular_reflection = 1.0;\n    materials_table[int(MAT_PLASTIC)].ambient_reflection  = 1.0;\n    materials_table[int(MAT_PLASTIC)].shininess           = 15.0;\n\n    materials_table[int(MAT_FLOOR_B)].color = vec3(0.7);\n    materials_table[int(MAT_FLOOR_B)].diffuse_reflection  = 1.0;\n    materials_table[int(MAT_FLOOR_B)].specular_reflection = 0.2;\n    materials_table[int(MAT_FLOOR_B)].ambient_reflection  = 0.5;\n    materials_table[int(MAT_FLOOR_B)].shininess           = 1.0;\n\n    materials_table[int(MAT_FLOOR_W)].color = vec3(1.0);\n    materials_table[int(MAT_FLOOR_W)].diffuse_reflection  = 1.0;\n    materials_table[int(MAT_FLOOR_W)].specular_reflection = 0.2;\n    materials_table[int(MAT_FLOOR_W)].ambient_reflection  = 0.5;\n    materials_table[int(MAT_FLOOR_W)].shininess           = 1.0;\n\n    materials_table[int(MAT_ORANGE)] = change_color(materials_table[int(MAT_PLASTIC)], ORANGE_RGB );\n    materials_table[int(MAT_RED   )] = change_color(materials_table[int(MAT_PLASTIC)], vec3(1.0,0.0,0.0) );\n    materials_table[int(MAT_GREEN )] = change_color(materials_table[int(MAT_PLASTIC)], vec3(0.0,1.0,0.0) );\n    materials_table[int(MAT_BLUE  )] = change_color(materials_table[int(MAT_PLASTIC)], vec3(0.0,0.0,1.0) );\n\n    materials_table[int(MAT_METAL_GRID)].color = rgb_from_hsv( vec3(225.0/360.0,0.06,0.65) );\n    materials_table[int(MAT_METAL_GRID)].diffuse_reflection  = 0.8;\n    materials_table[int(MAT_METAL_GRID)].specular_reflection = 1.1;\n    materials_table[int(MAT_METAL_GRID)].ambient_reflection  = 0.9;\n    materials_table[int(MAT_METAL_GRID)].shininess           = 16.0;\n\n    materials_table[int(MAT_TUNNEL_WALL_W)].color = rgb_from_hsv( vec3(0.083,0.1,1.0) );\n    materials_table[int(MAT_TUNNEL_WALL_W)].diffuse_reflection  = 1.0;\n    materials_table[int(MAT_TUNNEL_WALL_W)].specular_reflection = 1.0;\n    materials_table[int(MAT_TUNNEL_WALL_W)].ambient_reflection  = 1.0;\n    materials_table[int(MAT_TUNNEL_WALL_W)].shininess           = 15.0;\n    \n    int material_index;\n    col.rgb = render_no_reflections( materials_table, start, dir, max_dist, t, normal, material_index );\n    #if DRAW_ITERATIONS_GRADIENT\n    float it = mod( float(material_index), 10000.0 ),\n          it1 = 0.0;\n    material_index /= 10000;\n    #endif\n    \n    float max_iters = float(RAYM_MAX_ITERS) + 2.0 * float((1+nl)*SHADOW_MAX_ITERS) + 1.0;\n#if RENDER_REFLECTIONS\n    max_iters += float(RAYM_MAX_ITERS) + 32.0;\n    pos = start + dir * t;\n    float fe = 0.01;\n    float cn = dot(normal,-dir);\n    float sn = 1.0 - cn*cn;\n    if ( t > 0.0 &&\n         ( material_index == int(MAT_FLOOR_W) ||\n           material_index == int(MAT_FLOOR_B) ||\n           material_index == int(MAT_TUNNEL_WALL_W )\n         )\n       )\n    {\n        int material_index1;\n        dir1 = reflect(dir,normal);\n        t1 = 0.01;\n        vec3 reflection;\n    \treflection = render_no_reflections( materials_table, pos, dir1, max_dist_reflection, t1, normal1, material_index1 );\n        \n\t    #if DRAW_ITERATIONS_GRADIENT\n    \tit1 = mod( float(material_index1), 10000.0 );\n    \t#else\n        if ( t1 > 0.0 )\n        {\n            t1 += 1.0;\n        \tfloat a = ( sn*sn * 0.9 / t1 );\n        \tcol.rgb = col.rgb * ( 1.0 - a ) + a * reflection;\n        }\n        #endif\n    }\n#endif\n    #if DRAW_ITERATIONS_GRADIENT\n\t   col.rgb = rgb_from_hsv(vec3(float(it+it1)/(1.0*max_iters),1.0,1.0));\n    #endif\n    \n    // NOTE(theGiallo): gamma correction\n\t// col.rgb = pow( col.rgb, vec3(0.4545) );\n\n    fragColor = vec4(col.rgb,1);\n}","name":"Image","description":"","type":"image"}]}