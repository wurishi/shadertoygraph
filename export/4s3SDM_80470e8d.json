{"ver":"0.1","info":{"id":"4s3SDM","date":"1459533516","viewed":418,"name":"IC-fabrication","username":"javalang","description":"very experimental, just learning distance functions...\ncomment MOVEMENT  for static picture","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by johann langhofer - lavalang/04-2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Bit Paced Sprites from https://www.shadertoy.com/view/XtsGRl\n// dist fuctions from https://iquilezles.org/articles/distfunctions\n#define MOVEMENT\nconst float grad_step = 0.1;\nvec2 print_pos = vec2(2,8);\n\n#define CHAR_SIZE vec2(3, 7)\n#define CHAR_SPACING vec2(4, 8)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\nfloat sdPlane(vec3 p, vec4 n) {\n\treturn dot(p, n.xyz) + n.w;\n}\nfloat sdPlane(vec3 p) {\n\treturn p.y;\n}\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\nfloat fBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\nfloat fBoxCheap(vec3 p, vec3 b) { //cheap box\n\treturn vmax(abs(p) - b);\n}\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nfloat ICbody(vec3 pos) {\n\tpMod2(pos.xz, vec2(5, 8)); //domain: multiple objekts in xz-direction with distance: 8-units\n\tfloat mark = fCylinder(pos + vec3(.99, -0.38, 2.5), .18, .11); //pin 1 marker\n\tpos.x = abs(pos.x) - .5; //domain: x-Axis mirror\n\t//half IC-body (half x-dimension)\n\treturn max(-mark, fBoxCheap(pos, vec3(1, .35, 3)));\n}\n\nfloat ICpins(vec3 pos) {\n\tpMod2(pos.xz, vec2(5, 8)); //domain: multiple objekts in xz-direction with distance: 8-units\n\tpos.x = abs(pos.x) - .55; //domain: x-Axis mirror\n\tfloat boxBig = fBoxCheap(pos, vec3(5, 1.5, 3)); //shape, will be used later\n\tfloat c = pMod1(pos.z, .84); //domain: multiple objekts in y-axis with distance: .84-units\n\tfloat box2 = fBoxCheap(pos + vec3(-1, .35, 0), vec3(.05, .25, .125)); //one IC-pin largepart\n\tfloat box3 = fBoxCheap(pos + vec3(-1, .8, 0), vec3(.05, .6, .05)); //one IC-pin smallpart\n\tfloat box23 =fOpUnionRound(box3, box2,.15); //merge pins\n\tfloat boxes = max(boxBig, box23); //mask with shape\n\treturn boxes;\n}\n\nfloat ICground(vec3 pos) {\n\treturn sdPlane(pos+1.2);\n}\n\n// phong shading\nvec3 shading(vec3 v, vec3 n, vec3 eye) {\n// ...add lights here...\n\n\tfloat shininess = 16.0 * .3;\n\tvec3 final = vec3(0.0);\n\tvec3 ev = normalize(v - eye);\n\tvec3 ref_ev = reflect(ev, n);\n\n// light 0\n\t{\n\t\tvec3 light_pos = vec3(20.0, 20.0, 20.0);\n\t\tvec3 light_color = vec3(.7, .7, .7);\n\n\t\tvec3 vl = normalize(light_pos - v);\n\n\t\tfloat diffuse = max(0.0, dot(vl, n));\n\t\tfloat specular = max(0.0, dot(vl, ref_ev));\n\t\tspecular = pow(specular, shininess);\n\n\t\tfinal += light_color * (diffuse + specular);\n\t}\n\n// light 1\n\t{\n\t\tvec3 light_pos = vec3(-20.0, -20.0, -20.0);\n\t\tvec3 light_color = vec3(.7, .7, .7);\n\n\t\tvec3 vl = normalize(light_pos - v);\n\n\t\tfloat diffuse = max(0.0, dot(vl, n));\n\t\tfloat specular = max(0.0, dot(vl, ref_ev));\n\t\tspecular = pow(specular, shininess);\n\n\t\tfinal += light_color * (diffuse + specular);\n\t}\n\n\treturn final;\n}\n\nvec3 bg(vec3 dir, bool colored) {\n\tvec3 cube = texture(iChannel0, dir).xyz;\n\tif (colored)\n\t\treturn cube;\n\tfloat avg = (cube.x + cube.y + cube.z) * 0.333;\n\treturn vec3(avg);\n}\n\n// ========================================\nvec3 getBackground(vec3 rd) {\n\treturn texture(iChannel0, rd).xyz;\n}\n\nvec2 opU(vec2 d1, vec2 d2) {\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\n\nvec2 map( in vec3 pos )\n{\n#ifdef MOVEMENT\n\tpos.z += iTime*5.;//+abs(sin(iTime * 2.5));\n#endif\n\tvec2 res = opU(vec2(ICbody(pos),10),vec2(ICpins(pos),20));\n\tres = opU(res,vec2(ICground(pos), 1 ));\n\treturn res;\n}\nvec3 gradient(vec3 pos) {\n\tconst vec3 dx = vec3(grad_step, 0.0, 0.0);\n\tconst vec3 dy = vec3(0.0, grad_step, 0.0);\n\tconst vec3 dz = vec3(0.0, 0.0, grad_step);\n\treturn normalize(\n\t\t\tvec3(map(pos + dx).x - map(pos - dx).x,\n\t\t\t\t\tmap(pos + dy).x - map(pos - dy).x,\n\t\t\t\t\tmap(pos + dz).x - map(pos - dz).x));\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t\t\tmap(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t\t\tmap(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t\t\tmap(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor( int i=0; i<16; i++ )\n\t{\n\t\tfloat h = map( ro + rd*t ).x;\n\t\tres = min( res, 8.0*h/t );\n\t\tt += clamp( h, 0.02, 0.10 );\n\t\tif( h<0.001 || t>tmax ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n\tfloat sca = 1.0;\n\tfor( int i=0; i<5; i++ )\n\t{\n\t\tfloat hr = 0.01 + 0.12*float(i)/4.0;\n\t\tvec3 aopos = nor * hr + pos;\n\t\tfloat dd = map( aopos ).x;\n\t\tocc += -(dd-hr)*sca;\n\t\tsca *= 0.95;\n\t}\n\treturn clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\nvec2 castRay( in vec3 ro, in vec3 rd ) {\n\n\tfloat tmin = 0.0;\n\tfloat tmax = 50.0;\n\n\tfloat precis = 0.002;\n\tfloat t = tmin;\n\tfloat m = -1.0;\n\tfor( int i=0; i<150; i++ )\n\t{\n\t\tvec2 res = map( ro+rd*t );\n\t\tif( res.x<precis || t>tmax ) break;\n\t\tt += res.x;\n\t\tm = res.y;\n\t}\n\n\tif( t>tmax ) m=-1.0;\n\treturn vec2( t, m );\n}\n//Automatically generated from a sprite sheet.\nfloat ch_sp = 0.0;\nfloat ch_a = 712557.0;\nfloat ch_e = 2018607.0;\nfloat ch_j = 1872746.0;\nfloat ch_l = 1198375.0;\nfloat ch_p = 711972.0;\nfloat ch_s = 2018927.0;\nfloat ch_1 = 730263.0;\nfloat ch_3 = 693354.0;\nfloat ch_0 = 711530.0;\n\n//Extracts bit b from the given number.\nfloat extract_bit(float n, float b)\n{\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));\n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(float spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n\n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0)));\n    bounds = bounds && all(lessThan(uv,size));\n\n    return bounds ? extract_bit(spr, bit) : 0.0;\n\n}\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat char(float ch, vec2 uv)\n{\n    float px = sprite(ch, CHAR_SIZE, (uv - print_pos));\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\n//Returns the digit sprite for the given number.\nfloat get_digit(float d)\n{\n    d = floor(d);\n\n    if(d == 0.0) return ch_0;\n    if(d == 1.0) return ch_1;\n    if(d == 3.0) return ch_3;\n    return 0.0;\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n\tvec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n\tvec2 res = castRay(ro,rd);\n\tfloat t = res.x;\n\tfloat m = res.y;\n\tif( m>-0.5 )\n\t{\n\t\tvec3 pos = ro + t*rd;\n\t\tvec3 nor = calcNormal( pos );\n\t\tvec3 shaded=shading( pos, nor, ro );\n\t\tvec3 ref = reflect( rd, nor );\n\t\tif( m<1.5 )\n\t\t{\n#ifdef MOVEMENT\n\t\t\tfloat fz= iTime*5.;//+abs(sin(iTime * 2.5));\n#else\n\t\t\tfloat fz=0.;\n#endif\n\t\t\tfloat rep=2.0;\n\t\t\tfloat f = mod( floor(rep*(pos.z+fz)) + floor(rep*pos.x), 2.0);\n\t\t\tcol = 0.2 + 0.3*f*vec3(.5,1.2,0.4);\n\t\t}\n\n\t\tif(m>1.5) {\n\t\t\tfloat fz= iTime;\n\t\t\tvec3 n = gradient( pos );\n\t\t\tcol=shading( pos, n, rd );\n\t\t\tvec2 tpos=0.55+0.4*(pos).zx; \n#ifdef MOVEMENT\n\t\t\ttpos.x+=0.8+fz*2.;\n#else\n            tpos.x+=0.8;\n#endif\n\t\t\tvec2 uv=36.*vec2(tpos.xy);\n\t\t\tuv.y=mod(uv.y,36.);\n\t\t\tuv.x=mod(uv.x,115.25/2.);\n\t\t\tuv.y-=16.;\n\t\t\tfloat cl=0.0;\n\t\t    cl += char(ch_j,uv);\n\t\t    cl += char(ch_l,uv);\n\t\t    cl += char(ch_a,uv);\n            cl += char(ch_0,uv);\n            cl += char(ch_0,uv);\n            cl += char(ch_1,uv);\n            print_pos = vec2(2,-2);\n\t\t    cl += char(ch_e,uv);\n\t\t    cl += char(ch_s,uv);\n\t\t    cl += char(ch_p,uv);\n\t\t    cl += char(ch_3,uv);\n\t\t    cl += char(ch_3,uv);\n\t\t    cl += char(ch_1,uv);\n\t\t    cl += char(ch_0,uv);\n\t\t    col=mix(col,vec3(cl),0.32500);//FloatSlider);\n\t\t}\n\n#define LIGHTNING\n#ifdef LIGHTNING\n\t\t// lightning\n\t\tfloat occ = calcAO( pos, nor );\n\t\tvec3 lig = normalize( vec3(0.3*sin(iTime*5.), 0.7,0.0*cos(iTime*5.)) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n\t\tfloat dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n\t\tfloat bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\t\tfloat dom = smoothstep( -0.1, 0.1, ref.y );\n\t\tfloat fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n\t\tdif *= softshadow( pos, lig, 0.02, 2.5 );\n\t\tdom *= softshadow( pos, ref, 0.02, 2.5 );\n\t\tvec3 lin = vec3(0.0);\n\t\tlin += 1.20*dif*vec3(1.00,0.85,0.55);\n\t\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n\t\tlin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n\t\tlin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n\t\tlin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n\t\tlin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n#endif\n\t\tif(m>15.) {\n\t\t\tcol=pow( abs(clamp(getBackground(rd)*1.,0.5,1.0)), vec3(0.5945) );\n\t\t}\n\t}\n\treturn vec3( clamp(col,0.0,1.0) );\n}\nvoid myCamera(out vec3 ro, out vec3 rd) {\n\tvec2 q = gl_FragCoord.xy / iResolution.xy;\n\tvec2 coord = 2.0 * q - 1.0;\n\tcoord.x *= iResolution.x / iResolution.y;\n\tfloat myFOV =0.38000;\n\tcoord *= myFOV;\n\tvec3 myDirection=vec3(0.46801,-0.66000,-0.56098);\n\tvec3 dir = normalize(myDirection);\n\tvec3 myUp=vec3(0.31800,1.,-0.46915);\n\tvec3 upOrtho = normalize(myUp - dot(dir, myUp) * dir);\n\tvec3 right = normalize(cross(dir, upOrtho));\n\tvec3 myEye=vec3(-9.52621,10.73630+sin(iTime/3.)*2.9,9.72645);\n\tro = myEye;\n\trd = normalize(dir + coord.x * right + coord.y * upOrtho);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 eye, dir;\n\tmyCamera(eye, dir);\n\tvec3 col = render( eye, dir );\n\tcol = pow( abs(clamp(col,0.0,1.0)), vec3(0.945) );\n\tfragColor=vec4( col, 1.0 );\n\n}\n\n","name":"Image","description":"","type":"image"}]}