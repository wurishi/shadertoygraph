{"ver":"0.1","info":{"id":"WdSSWD","date":"1553722455","viewed":547,"name":"Pixel planet","username":"vegardno","description":"Inspired by https://managore.itch.io/planetarium","likes":25,"published":1,"flags":32,"usePreview":0,"tags":["pixelart"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// inspired by/based on:\n//\n//   https://managore.itch.io/planetarium\n//\n// also see:\n//\n//   http://viclw17.github.io/2018/06/12/GLSL-Practice-With-Shadertoy/\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if 0\n    // Nearest neighbour filtering\n    vec2 uv = (screen_height / iResolution.y) * fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n#else\n\n    // Using my own filtering technique to avoid uneven pixel sizes\n    // when upscaling:\n   \t//\n    //   https://vegard.wiki/w/Pixel_art_upscaling\n    //\n    vec2 uv = screen_height * fragCoord / iResolution.y;\n\n    // Calculate the size of (half) a pixel\n#if 0\n    vec2 border = .5 * fwidth(uv);\n#else\n    vec2 border = .5 * screen_height / iResolution.xy;\n#endif\n\n    vec2 uvf = fract(uv);\n\n    // the main color of the texel, assuming we're not at a border\n    vec4 col = texelFetch(iChannel0, ivec2(uv), 0);\n\n    vec4 xcol = col;\n    if (uvf.x < border.x)\n        xcol = mix(texelFetchOffset(iChannel0, ivec2(uv), 0, ivec2(-1, 0)), col, uvf.x / border.x);\n    else if (1. - uvf.x < border.x)\n        xcol = mix(texelFetchOffset(iChannel0, ivec2(uv), 0, ivec2(1, 0)), col, (1. - uvf.x) / border.x);\n\n        vec4 ycol = col;\n    if (uvf.y < border.y)\n        ycol = mix(texelFetchOffset(iChannel0, ivec2(uv), 0, ivec2(0, -1)), col, uvf.y / border.y);\n    else if (1. - uvf.y < border.y)\n        ycol = mix(texelFetchOffset(iChannel0, ivec2(uv), 0, ivec2(0, 1)), col, (1. - uvf.y) / border.y);\n\n    fragColor = mix(xcol, ycol, .5);\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// TODO:\n//  - clumpy cloud distribution\n//  - precompute dust properties\n//  - landmasses...\n\nvec3 dark_grey = vec3(53., 43., 49.) / 255.;\nvec3 dark_blue = vec3(75., 109., 133.) / 255.;\nvec3 dark_red = vec3(170., 90., 103.) / 255.;\nvec3 purple = vec3(157., 91., 136.) / 255.;\nvec3 white = vec3(245., 245., 212.) / 255.;\nvec3 green = vec3(150., 207., 133.) / 255.;\nvec3 light_green = vec3(223., 223., 170.) / 255.;\nvec3 light_blue = vec3(191., 231., 231.) / 255.;\nvec3 blue = vec3(152., 186., 210.) / 255.;\nvec3 grey = vec3(53., 53., 53.) / 255.;\nvec3 dark_yellow = vec3(166., 166., 144.) / 255.;\n\n// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nvec3 camera(float fov, vec2 size, vec2 uv)\n{\n    vec2 xy = uv;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n// intersect ray with sphere to find\n//  - the distance to the sphere\n//  - and the point of intersection on the sphere\n// http://viclw17.github.io/2018/07/16/raytracing-ray-sphere-intersection/\nfloat intersect_ray_sphere(vec3 origin, vec3 direction, vec3 center, float radius)\n{\n    vec3 oc = origin - center;\n    float a = dot(direction, direction);\n    float b = 2. * dot(oc, direction);\n    float c = dot(oc, oc) - radius * radius;\n    float disc = b * b - 4. * a * c;\n    if (disc < 0.) {\n        // no intersection?\n        return -1.;\n    } else {\n        return (-b - sqrt(disc)) / (2. * a);\n    }\n}\n\n// https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRotate.xml\nmat4 rotate(float a, vec3 v)\n{\n    float c = cos(a);\n    vec3 ci = (1. - c) * v;\n    vec3 s = sin(a) * v;\n\n    return mat4(\n        ci.x * v.x + c, ci.x * v.y + s.z, ci.x * v.z - s.y, 0,\n        ci.y * v.x - s.z, ci.y * v.y + c, ci.y * v.z + s.x, 0,\n        ci.z * v.x + s.y, ci.z * v.y - s.x, ci.z * v.z + c, 0,\n        0, 0, 0, 1\n\t);\n}\n\n// https://stackoverflow.com/questions/12964279/whats-the-origin-of-this-glsl-rand-one-liner\nfloat rand(vec2 co)\n{\n\treturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand2(vec2 co)\n{\n    // distribute values from -1 to 1, extremes are rarer\n    return 8. * pow(rand(co) - .5, 3.);\n}\n\n/* https://en.wikipedia.org/wiki/Ordered_dithering */\nconst float bayer_matrix[64] = float[64](\n     -0.500000,  0.250000, -0.312500,  0.437500, -0.453125,  0.296875, -0.265625,  0.484375,\n      0.000000, -0.250000,  0.187500, -0.062500,  0.046875, -0.203125,  0.234375, -0.015625,\n     -0.375000,  0.375000, -0.437500,  0.312500, -0.328125,  0.421875, -0.390625,  0.359375,\n      0.125000, -0.125000,  0.062500, -0.187500,  0.171875, -0.078125,  0.109375, -0.140625,\n     -0.468750,  0.281250, -0.281250,  0.468750, -0.484375,  0.265625, -0.296875,  0.453125,\n      0.031250, -0.218750,  0.218750, -0.031250,  0.015625, -0.234375,  0.203125, -0.046875,\n     -0.343750,  0.406250, -0.406250,  0.343750, -0.359375,  0.390625, -0.421875,  0.328125,\n      0.156250, -0.093750,  0.093750, -0.156250,  0.140625, -0.109375,  0.078125, -0.171875\n);\n\nfloat dither(vec2 uv, float levels, float sharpness, float intensity)\n{\n    int x = int(floor(uv.x)) & 7;\n    int y = int(floor(uv.y)) & 7;\n    float threshold = bayer_matrix[8 * y + x];\n#if 0 // full dither\n    return round(levels * intensity + threshold) / levels;\n#else // respect sharpness\n    float major = floor(levels * intensity);\n    float minor = float(fract(levels * intensity) > .5 + sharpness * threshold);\n    return (major + minor) / levels;\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord - vec2(.5 * screen_height * iResolution.x / iResolution.y, .5 * screen_height);\n    if (uv.x > .5 * screen_height * iResolution.x / iResolution.y || uv.y > .5 * screen_height)\n        discard;\n\n    vec3 pos = vec3(0., 0., 12.);\n    vec3 dir = camera(90., vec2(screen_height), uv);\n    vec3 col = dark_grey;\n\tfloat z = 1000.;\n\n    const float planet_size = 3.;\n    vec3 planet_position = vec3(0);\n\n    // starry background\n    {\n    \tfloat star = rand(uv);\n    \tif (star <= .001)\n\t        col = dark_blue;\n\t    else if (star <= .002)\n\t        col = purple;\n\t    else if (star <= .003)\n\t        col = white;\n\t}\n    \n#if 1\n\t// sun\n    mat4 sun_matrix = rotate(radians(-35.) * iTime, normalize(vec3(0., 1., 0.)));\n    float sun_orbit = 900.;\n    float sun_size = 30.;\n    vec3 sun_position = (sun_matrix * vec4(-sun_orbit, 0, 0, 1)).xyz;\n    {\n    \tfloat t = intersect_ray_sphere(pos, dir, sun_position, sun_size);\n        if (t >= 0. && t < z) {\n            col = vec3(1, 1, 1);\n            z = t;\n        }\n    }\n\n\tvec3 L_sun = normalize(sun_position - planet_position);\n\n#else\n   \tvec3 L_sun = normalize(vec3(-1, 1, 2));\n#endif\n        \n    // moon\n    float moon_size = 1.;\n    mat4 moon_matrix = rotate(radians(30.), normalize(vec3(1., 0., 1.)));\n    float moon_radius = 7.;\n    float moon_frequency = 2.;\n    vec3 moon_position = planet_position\n        + moon_radius * (moon_matrix * vec4(cos(moon_frequency * iTime), 0, sin(moon_frequency * iTime), 1.)).xyz;\n    {\n    \tfloat t = intersect_ray_sphere(pos, dir, moon_position, moon_size);\n        if (t >= 0. && t < z) {\n\t\t\tvec3 p = pos+dir*t;\n            vec3 light_dir = normalize(p - sun_position);\n            float t_planet = intersect_ray_sphere(sun_position,\n\t\t\t\tlight_dir,\n\t\t\t\tplanet_position,\n\t\t\t\tplanet_size);\n\n\t\t\tif (t_planet >= 0. && length(sun_position - planet_position) < length(sun_position - p))\n                col = grey;\n            else {\n            \tvec3 N = normalize(p-moon_position);\n\t\t\t\t// XXX: fake rotation, should follow the moon I guess\n            \tfloat tex = 2. * texture(iChannel0,\n                                     .1 * N.xy + vec2(.1 * iTime, 0)).r;\n                float dot_sun = .5 + dot(N, L_sun);\n\t\t\t\tfloat intensity = round(2. * max(0., tex * dot_sun)) / 2.;\n                \n            \tfloat shadow_int = dither(uv, 2., .8, dot_sun);\n            \tif (shadow_int < .5) {\n\t                col = mix(dark_yellow, white, shadow_int);\n\t            } else {\n            \t\tcol = white * (.7 + .2 * intensity);\n                }\n            }\n            z = t;\n        }\n    }\n    \n    // planet\n    {\n        float t = intersect_ray_sphere(pos, dir, planet_position, planet_size);\n        if (t >= 0. && t < z) {\n\t\t\tvec3 p = pos+dir*t;\n            vec3 N = normalize(p-planet_position);\n            // XXX: fake rotation, should follow the moon I guess\n            float tex = 2. * texture(iChannel0,\n                                     .1 * N.xy + vec2(.1 * iTime, 0)).r;\n            float dot_sun = .5 + dot(N, L_sun);\n#if 0 // dither?\n            float intensity = dither(uv, 3., .7, clamp(tex * dot_sun, 0., 1.));\n#else\n\t\t\tfloat intensity = floor(2. * max(0., tex * dot_sun)) / 2.;\n#endif\n\n            float shadow_int = dither(uv, 2., .8, dot_sun);\n            if (shadow_int < .5) {\n                col = mix(dark_blue, blue, shadow_int);\n            } else {\n                // is distance from sun to planet smaller than\n                // from from the camera to the dust?\n                vec3 light_dir = normalize(p - sun_position);\n                float t_moon = intersect_ray_sphere(sun_position,\n\t\t\t\t\tlight_dir,\n\t\t\t\t\tmoon_position,\n\t\t\t\t\tmoon_size);\n\n\t\t\t\tif (t_moon >= 0. && length(sun_position - moon_position) < length(sun_position - planet_position))\n                    col = dark_blue;\n\t\t\t\telse\n            \t\tcol = mix(dark_blue, blue, intensity);\n            }\n            z = t;\n        }\n    }\n    \n    // dust\n    const int nr_dust = 120;\n    mat4 dust_matrix = rotate(radians(30.), normalize(vec3(1., 0., 1.)));\n    for (int i = 0; i < nr_dust; ++i) {\n    \tfloat dust_radius = 4.\n            + 2. * rand2(vec2(121., float(i)))\n\t\t\t+ 1. * rand(vec2(129., float(i)));\n    \tfloat dust_frequency = 4. - .5 * dust_radius;\n    \tfloat dust_phase = 2. * 3.1415 * rand(vec2(13. + float(i)));\n        float dust_y = .05 * rand2(vec2(137., float(i)));\n        float dust_size = .09 * (1. + rand2(vec2(93., float(i))));\n    \tvec3 dust_position = planet_position\n\t        + dust_radius * (dust_matrix * vec4(cos(dust_frequency * iTime + dust_phase), dust_y, sin(dust_frequency * iTime + dust_phase), 1.)).xyz;\n\t    {\n\t    \tfloat t = intersect_ray_sphere(pos, dir, dust_position, dust_size);\n\t        if (t >= 0. && t < z) {\n\t\t\t\t// is distance from sun to planet smaller than\n                // from from the camera to the dust?\n                vec3 light_dir = normalize(dust_position - sun_position);\n                float t_planet = intersect_ray_sphere(sun_position,\n\t\t\t\t\tlight_dir,\n\t\t\t\t\tplanet_position,\n\t\t\t\t\tplanet_size);\n\t\t\t\tvec3 p = sun_position+light_dir*t_planet;\n\n\t\t\t\tif (t_planet >= 0. && length(sun_position - planet_position) < length(sun_position - dust_position))\n                    col = grey;\n                else\n\t\t            col = mix(purple, blue, round(rand(vec2(22., float(i)))));\n\t            z = t;\n\t        }\n\t    }\n    }\n\n#if 0\n    // clouds\n    const int nr_clouds = 120;\n    mat4 clouds_matrix = rotate(radians(-30. * iTime), normalize(vec3(-1., 1., 1.)));\n    for (int i = 0; i < nr_clouds; ++i) {\n    \tfloat cloud_radius = planet_size + .1 * rand2(vec2(121., float(i)));\n    \tfloat cloud_frequency = 2.;\n        vec3 cloud_pos = normalize(vec3(\n            rand(vec2(10., float(i))),\n            rand(vec2(63., float(i))),\n            rand(vec2(137., float(i)))\n        ) - vec3(.5, .5, .5));\n        float cloud_size = .13 * (1. + rand2(vec2(93., float(i))));\n    \tvec3 cloud_position = planet_position\n\t        + cloud_radius * (clouds_matrix * vec4(cloud_pos, 1.)).xyz;\n\t    {\n\t    \tfloat t = intersect_ray_sphere(pos, dir, cloud_position, cloud_size);\n\t        if (t >= 0. && t < z) {\n                vec3 p = pos+dir*t;\n            \tvec3 N = normalize(p-planet_position);\n\t\t\t\tfloat intensity = round(3. * max(0., 2. * dot(N, L_sun))) / 3.;\n\n            \tcol = mix(dark_blue, white, intensity);\n\t            z = t;\n\t        }\n\t    }\n    }\n#endif\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// shadertoy output seems to be 288 tall, so dividing by 96\n// or 144  gives us a nice ratio of 1:3 or 1:2 screen:virtual\n// pixel sizes, respectively.\nconst float screen_height = 96.;","name":"Common","description":"","type":"common"}]}