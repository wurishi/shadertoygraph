{"ver":"0.1","info":{"id":"ltc3Rj","date":"1470238243","viewed":334,"name":"sphere coordinates","username":"nzNico","description":"Is there a better way to generate a uv map for a sphere ?","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymrchingspherecoordinates"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 scene( in vec3 pos )//reception d'une sphere\n{\n    vec3 dim = vec3(1, 1, 1);\n    \n    pos += vec3(0, 0., 0);\n    \n    float resSphere = sdSphere(pos, 1.3);\n    \n   \n    vec2 res = vec2(resSphere, 2.);\n    \n    \n    return res;\n}\n\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n                    scene(pos+eps.xyy).x - scene(pos-eps.xyy).x,\n                    scene(pos+eps.yxy).x - scene(pos-eps.yxy).x,\n                    scene(pos+eps.yyx).x - scene(pos-eps.yyx).x );\n    return normalize(nor);\n}\n\nvec2 getUV(vec3 pos)\n{\n    vec3 nor = calcNormal(pos);\n    float lon = atan(nor.x,nor.z)/3.14;\n    float lat = acos(nor.y)/3.14;\n    vec2 r = vec2(lat, lon);\n    \n    return r;\n}\n\nvec2 rayMarching(in vec3 camPos, in vec3 rayDirection)\n{\n    float dMin = 1.;\n    float dMax = 50.;\n    float precis = 0.002;\n    float traveledDistance = dMin;\n    float color = -1.;\n    \n    for( int i = 0 ; i < 50 ; i++ )\n    {\n        vec2 res = scene( camPos + (rayDirection * traveledDistance) );\n        \n        if( res.x<precis || traveledDistance>dMax )\n        {\n            break;\n        }\n        \n        traveledDistance += res.x;\n        color = res.y;\n    }\n    \n    if( traveledDistance > dMax )\n    {\n        color = -1.0;\n    }\n    return vec2( traveledDistance, color );\n}\n\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta-ro);//z (dir)\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);//haut\n    vec3 cu = normalize( cross(cw,cp) );//x (droite/gauche)\n    vec3 cv = normalize( cross(cu,cw) );//y (haut normalisÃ©)\n    return mat3( cu, cv, cw );\n}\n\n\nfloat makeCheker(vec2 p)\n{\n    vec2 checker = p*10.;\n    vec2 cells = floor(checker);\n    float chekerColor = 0.;\n    if(mod(cells.x+cells.y, 2.)== 0.)\n    {\n        chekerColor = 1.;\n    }\n    else\n    {\n     \tchekerColor = 0.;   \n    }\n    return chekerColor;\n}\n\nvec2 seeCoords(vec2 p)\n{\n    return p.xy;\n}\n\n\nvec2 arrangeCoords(vec2 p)\n{\n    vec2 q = p.xy/iResolution.xy;\n    vec2 r = -1.0+2.0*q;\n\tr.x *= iResolution.x/iResolution.y;\n    return r;\n}\n//->START\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = arrangeCoords(fragCoord);\n     \n    \n    \n    \n    vec3 lookAt = vec3(-0, -0, 0);\n    vec3 camPos = vec3(5. * sin(iTime*0.3), 3. , -4. * cos(iTime*0.3));\n    \n    mat3 camera = setCamera(camPos, lookAt, 0.);\n    vec3 rayDirection = camera * normalize( vec3(p.xy,2.0) );\n    vec2 rayResult = rayMarching(camPos, rayDirection);\n        \n    \n    float rayDistance = rayResult.x;\n    float rayColor = rayResult.y;\n    vec3 hitPos = camPos + rayDirection*rayDistance;\n    vec2 chekerUv;\n    \n    vec3 color;\n    \n    vec3 sphereColor = vec3(0, 0, 0);\n    \n\n    \n    if(rayColor > 1.)\n    {\n        color = vec3(1. , 0.4 ,0.1 );\n     \n        if(rayDistance>1.)\n        {\n        \tchekerUv = getUV(hitPos);\n            sphereColor = vec3(makeCheker(chekerUv));\n            //sphereColor = vec3(seeCoords(chekerUv), 0.);\n        }\n        \n    }\n    else\n    {\n        color = vec3(0., 0., 0.);\n    }\n    \n   \n    vec3 pos = camPos + rayDistance * rayDirection;\n    vec3 nor = calcNormal( pos );\n    \n\n\t\n    fragColor = vec4(sphereColor, 1);\n}","name":"Image","description":"","type":"image"}]}