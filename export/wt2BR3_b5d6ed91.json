{"ver":"0.1","info":{"id":"wt2BR3","date":"1599520180","viewed":123,"name":"Pucca","username":"iuryBorgesRodrigues","description":"demo desenho pucca","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","pucca"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define AA 2\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(vec2(c, -s),vec2( s, c));\n}\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( in vec2 p, in float r ) \n{\n    return length(p)-r;\n}\nfloat rounding( in float d, in float h )\n{\n    return d - h;\n}\nfloat sdVesica(vec2 p, float r, float d)\n{\n    p = abs(p);\n\n    float b = sqrt(r*r-d*d);  // can delay this sqrt by rewriting the comparison\n    return ((p.y-b)*d > p.x*b) ? length(p-vec2(0.0,b))*sign(d)\n                               : length(p-vec2(-d,0.0))-r;\n}\n\n\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    \n    \n    \n    \n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba);\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb )\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat dot2(in vec2 v ) { return dot(v,v); }\n\n// trapezoid / capped cone, specialized for Y alignment\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n\n\tp.x = abs(p.x);\n    vec2 ca = vec2(max(0.0,p.x-((p.y<0.0)?r1:r2)), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    \n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n\tvec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(p.x*q.y-p.y*q.x),k*(p.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\n\nvec3 scene(vec2 p){\n    vec3 col=vec3(1.0,0.5,0.1);\n    \n    \n  \n   float cabelo[2];\n    \n   float detalheCabelo[6];\n    \n   float olhos[2]; \n   \n   float cabeca;\n   float rosto;\n    \n   float boca;\n    \n   float body[3];\n   \n   float sombracelha[2];\n    \n   float bochecha[2];\n   \n   float braco[6];\n    \n   float mao[2];\n    \n   float perna[2];\n    \n   //olhos\n   vec2 v1 = cos(vec2(0.0,2.00)  );\n   vec2 v2 = cos(vec2(0.0,1.50));\n   float th = 0.1*(0.5+0.5*sin(4.0));\n    \n   //fim olhos\n    \n   //sombracelhas\n    \n   float ta = 3.14*(0.5+0.5*cos(-0.7*0.52+2.0));\n   float tb = 3.14*(0.5+0.5*cos(0.5*0.31+2.0));\n   float rb = 0.15*(0.5+0.5*cos(3.0*0.41+3.0));\n    \n    //fim sombracelas\n    \n    \n   //body\n    \n    \n    float ra = 0.3+0.15*sin(1.2*1.3+0.0);\n    float rb2 = 0.35+0.15*sin(1.6*1.4+1.1);\n    vec2  pa = vec2(-0.6,0.0)+0.4*sin(1.2*1.1+vec2(0.0,2.0));\n    vec2  pb = vec2(-0.6,0.0)+0.4*sin(1.2*1.2+vec2(1.0,2.5));\n    vec2  pc = vec2(0.8,0.0);\n    \n    \n    \n   //fim body\n    \n   \n    \n   p/=vec2(0.5,0.5);\n   p.y+=-0.5;\n   \n   cabeca=sdEllipse((p*Rot(1.55)),vec2(0.5,0.7));\n   rosto=sdEllipse((((p*Rot(1.55)))/vec2(0.9))+vec2(-0.05,0.0),vec2(0.5,0.7));\n    \n   cabelo[0]=sdCircle(p+vec2(0.7,-0.2),0.2);\n   cabelo[1]=sdCircle(p+vec2(-0.7,-0.2),0.2);\n   \n   vec2 p1=p;\n   p1*=Rot(3.0);\n   p1+=vec2(-0.3,0.4);\n    \n    \n   vec2 p2=p;\n   p2*=Rot(5.0);\n   p2+=vec2(-0.0,0.8);\n    \n   detalheCabelo[0]=sdCircle(((p1/vec2(0.5))*Rot(2.23))+vec2(0.7,-0.2),0.2);\n   detalheCabelo[1]=sdCircle(((p1/vec2(0.5))*Rot(2.23))+vec2(0.7,-0.12),0.2);\n    \n   detalheCabelo[3]=sdCircle(((p2/vec2(0.5))*Rot(2.23))+vec2(0.7,-0.2),0.2);\n   detalheCabelo[4]=sdCircle(((p2/vec2(0.5))*Rot(2.23))+vec2(0.7,-0.12),0.2);\n    \n   detalheCabelo[2]=max(detalheCabelo[0],-detalheCabelo[1]);\n   detalheCabelo[5]=max(detalheCabelo[3],-detalheCabelo[4]);\n   \n   mao[0]=sdCircle(p+vec2(0.59,1.0),0.1);\n   mao[1]=sdCircle(p+vec2(-0.59,1.0),0.1);\n   \n   perna[0]=sdEllipse((p+vec2(0.2,1.1)),vec2(0.15,0.4));\n   perna[1]=sdEllipse((p+vec2(-0.2,1.1)),vec2(0.15,0.4));\n \n   olhos[0]= udSegment( (p*Rot(1.8)/vec2(1.0,0.5))+vec2(0.8,0.7), v1, v2 ) - th;\n   olhos[1]= udSegment( (p*Rot(-1.8)/vec2(01.0,0.5))+vec2(1.16,0.7), v1, v2 ) - th;\n  \n   \n   sombracelha[0]=sdArc((p/vec2(0.3))+vec2(1.6,-0.2),vec2(sin(ta),cos(ta)),vec2(sin(tb),cos(tb)), 0.5, rb);\n   sombracelha[1]=sdArc((p/vec2(0.3))+vec2(-1.7,-0.2),vec2(sin(ta),cos(ta)),vec2(sin(tb),cos(tb)), 0.5, rb);\n\n   boca=sdArc(((p/vec2(0.15,0.2))*Rot(3.2))+vec2(0.0,-1.5),vec2(sin(ta),cos(ta)),vec2(sin( 3.14*(0.5+0.5*cos(-0.2*0.31+2.0))),cos( 3.14*(0.5+0.5*cos(-0.2*0.31+2.0)))), 0.5, rb);\n\n   bochecha[0]=sdCircle(p+vec2(0.35,0.3),0.05);\n   bochecha[1]=sdCircle(p+vec2(-0.35,0.3),0.05);\n    \n   body[0]=sdTrapezoid(((p/vec2(1.0,0.5))+vec2(0.8,1.5))-pc, ra, rb2, 0.5+0.2*sin(1.3) );\n       \n   body[1]=sdTrapezoid(((p/vec2(0.9,0.48))+vec2(0.8,1.5))-pc, ra, rb2, 0.5+0.2*sin(1.3) );\n   \n   body[2]=max(body[0],-body[1]);\n    \n    \n   braco[0]=sdTriangleIsosceles( ((p/vec2(0.5,0.6))+vec2(0.65,0.7))*Rot(0.48),vec2(0.3,-1.1));\n   braco[1]=sdTriangleIsosceles( ((p/vec2(0.5,0.6))+vec2(-0.65,0.7))*Rot(-0.48),vec2(0.3,-1.1));\n   \n   braco[2]=sdTriangleIsosceles( ((p/vec2(0.48,0.59))+vec2(-0.65,0.7))*Rot(-0.48),vec2(0.3,-1.1));\n   braco[3]=max(braco[1],-braco[2]);\n   \n   braco[4]=sdTriangleIsosceles( ((p/vec2(0.48,0.59))+vec2(0.65,0.7))*Rot(0.48),vec2(0.3,-1.1));\n   braco[5]=max(braco[0],-braco[4]);\n    \n    \n   \n   if(perna[0] < 0.0) col=vec3(0.0);\n   if(perna[1] < 0.0) col=vec3(0.0);\n    \n   \n   if(mao[0] < 0.0) col=vec3(1.0);\n   if(mao[1] < 0.0) col=vec3(1.0);\n   if(body[0] < 0.0) col=vec3(0.9,0.0,0.0);\n   if(body[2] < 0.0) col=vec3(0.0);    \n   if(cabelo[0] < 0.0) col=vec3(0.0);\n   if(cabelo[1] < 0.0) col=vec3(0.0);\n   if(cabeca < 0.0) col=vec3(0.0);\n   if(rosto < 0.0) col=vec3(0.85,0.7,0.5);\n   if(olhos[0] < 0.0) col=vec3(0.0);\n   if(olhos[1] < 0.0) col=vec3(0.0);\n   if(sombracelha[0] < 0.0) col=vec3(0.0);\n   if(sombracelha[1] < 0.0) col=vec3(0.0);\n   if(boca < 0.0) col=vec3(0.0);\n   if(bochecha[0] < 0.0) col=vec3(0.9,0.5,0.5);\n   if(bochecha[1] < 0.0) col=vec3(0.9,0.5,0.5);\n   if(braco[0] < 0.0) col=vec3(0.9,0.0,0.0);\n   if(braco[1] < 0.0) col=vec3(0.9,0.0,0.0);\n   if(braco[3] < 0.0) col=vec3(0.0,0.0,0.0);\n   if(braco[5] < 0.0) col=vec3(0.0,0.0,0.0);\n   if(detalheCabelo[2] < 0.0) col=vec3(1.0,0.0,0.0);\n    if(detalheCabelo[5] < 0.0) col=vec3(1.0,0.0,0.0);\n    \n    \n    return col;\n}\n\n#define ZERO (min(iFrame,0))\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n  \n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n     // pixel coordinates\n      vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n     vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;   \n \t vec3 col=vec3(0.0);\n  \n  \t  col *= 1.5 - 0.2*length(p);\n      col = col*vec3(1.11,0.89,0.79);\n    \n      col=scene(p);\n        \n         tot += col;\n    }\n    \n    tot /= float(AA*AA);\n  fragColor = vec4(tot,1.0);\n}","name":"Image","description":"","type":"image"}]}