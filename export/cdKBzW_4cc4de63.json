{"ver":"0.1","info":{"id":"cdKBzW","date":"1697986439","viewed":111,"name":"Debug Black Things","username":"3t13nn3","description":"I don't know why there is black artifacts","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["bug"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 0\n#define NUM_OCTAVE 8\n\nstruct Object\n{\n    float depth;\n    vec3 color;\n};\n\nfloat sdSphere( in vec3 p, in float s ){\n    return length(p)-s;\n}\n\n\nObject sMin(Object a, Object b, float k) {\n    float h = clamp(0.5 + 0.5 * (b.depth - a.depth) / k, 0.0, 1.0);\n    Object result;\n    result.depth = mix(b.depth, a.depth, h) - k * h * (1.0 - h);\n    result.color = mix(b.color, a.color, h);\n    return result;\n}\n\n\nObject opUnion( Object d1, Object d2 )\n{\n\tif (d2.depth < d1.depth) {\n        return d2;\n    } else {\n        return d1;\n    }\n}\n\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    #if 1\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    #else\n    vec2 u = w*w*(3.0-2.0*w);\n    #endif\n\n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n    \n    return -1.0+2.0*(a + (b-a)*u.x + (c-a)*u.y + (a - b - c + d)*u.x*u.y);\n}\n\nconst mat2 m2 = mat2(  0.80,  0.60,\n                      -0.60,  0.80 );\n\nfloat fbm( in vec2 x)\n{\n    float f = 1.0;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<NUM_OCTAVE; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m2*x;\n    }\n    \n\treturn a;\n}\n\nObject map( in vec3 pos ) {\n    vec3 floorColor = vec3(0.063,0.055,0.027);\n\n    float fbmm = fbm(pos.xz);\n    fbmm = pos.y - fbmm;\n    \n    return Object(fbmm, floorColor);\n    /*\n    vec3 curp = pos;\n    //vec3 floorColor = vec3(0.05,0.09,0.02) + smoothstep(-0.001, 0.001, sin(20.0 * curp.x) + sin(20.0 * curp.z)) * 0.1;\n    vec3 floorColor = vec3(0.05,0.09,0.02);\n    Object d2 = Object((curp.y - (-1.5)) * fbm(pos, 1.), floorColor);\n    */\n    \n    /*\n    vec3 tmp = vec3(pos.x, pos.y - cos(iTime) / 2.0, pos.z);\n    Object d1 = Object(sdSphere(tmp, 0.25), vec3(0.3, 0.1, 0.05));\n    \n    tmp = vec3(pos.x - cos(iTime / 3.1415), pos.y, pos.z);\n    Object d3 = Object(sdSphere(tmp, 0.1), vec3(0.05, 0.05, 0.125));\n    \n    Object r = sMin(d1, d2, 0.15);\n    r = sMin(r, d3, 0.15);\n\n    return r;\n    */\n}\n\nvec3 calcNormal( in vec3 pos ) {\n    vec2 e = vec2(0.0001, 0.0);\n    return normalize(vec3(map(pos+e.xyy).depth - map(pos-e.xyy).depth,\n                          map(pos+e.yxy).depth - map(pos-e.yxy).depth,\n                          map(pos+e.yyx).depth - map(pos-e.yyx).depth));\n}\n\nfloat castShadow( in vec3 ro, in vec3 rd) {\n    float res = 1.0;\n    float t = 1.0;\n    for(int i = 0; i < 100; ++i) {\n        vec3 pos = ro + t * rd;\n        float h = max(0.0, map(pos).depth);\n        res = min(res, 16.0 * h / t);\n        if( h < 0.0001) break;\n        t += h;\n        if(t >20.0 ) break;\n    }\n    \n    return res;\n}\n\nObject castRay( in vec3 ro, in vec3 rd ) {\n    Object m; // material\n    float t = 0.0;\n    for( int i = 0; i < 100; ++i) {\n        vec3 pos = ro + t * rd;\n        \n        Object h = map(pos);\n        m = h;\n        if(h.depth < 0.001)\n            break;\n        //t += h.depth;\n        t += h.depth * 0.3;\n        if(t > 30.0) break;\n    }\n    \n    if(t > 30.0) m = Object(t, vec3(-1000.0));\n    \n    return Object(t, m.color);\n}\n\n// TODO - FIX LIGHT FOLLOWING CAMERA\nvec3 render( in vec3 ro, in vec3 rd) {\n    vec3 col = vec3(0.4, 0.75, 1.0) - 0.7 * rd.y;\n    col = mix(col, vec3(0.7, 0.75, 0.8), exp(-10.0*rd.y));\n    \n    Object tm = castRay(ro, rd);\n    \n    if(tm.color.x > -1000.0) {\n        float t = tm.depth;\n    \n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n        \n        //vec3 mate = vec3(0.18);\n        col = tm.color;\n        \n        /*\n        vec3 sun_dir = normalize(vec3(0.8, 0.4, 0.2));\n        float sun_dif = clamp(dot(nor, sun_dir), 0.0, 1.0);\n        float sun_sha = castShadow(pos + nor*0.001, sun_dir);    \n        float sky_dif = clamp(0.5 + 0.5*dot(nor, vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n        float bou_dif = clamp(0.5 + 0.5*dot(nor, vec3(0.0, -1.0, 0.0)), 0.0, 1.0);\n        \n        \n        col = mate * vec3(7.0, 4.5, 3.0) * sun_dif * sun_sha;\n        col += mate * vec3(0.5, 0.8, 0.9) * sky_dif;\n        col += mate * vec3(0.7, 0.3, 0.2) * bou_dif;\n        */\n        vec3  sun_lig = normalize( vec3(0.6, 0.35, 0.5) );\n        float sun_dif = clamp(dot( nor, sun_lig ), 0.0, 1.0 );\n        vec3  sun_hal = normalize( sun_lig-rd );\n        float sun_sha = castShadow(pos + nor*0.001, sun_lig);  \n\t\tfloat sun_spe = pow(clamp(dot(nor,sun_hal),0.0,1.0),8.0)*sun_dif*(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));\n\t\tfloat sky_dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n        float bou_dif = sqrt(clamp( 0.1-0.9*nor.y, 0.0, 1.0 ))*clamp(1.0-0.1*pos.y,0.0,1.0);\n\n        vec3 lin = vec3(0.0);\n        lin += sun_dif*vec3(8.10,6.00,4.20)*sun_sha;\n        lin += sky_dif*vec3(0.50,0.70,1.00);\n        lin += bou_dif*vec3(0.40,1.00,0.40);\n\t\tcol = col*lin;\n\t\tcol += sun_spe*vec3(8.10,6.00,4.20)*sun_sha;\n        \n        col = mix( col, vec3(0.5,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    float an = 0.01 * iTime;\n    \n    vec3 col = vec3(0.0);\n    \n    if (AA < 1) {\n        vec3 ro = vec3(1.0 * sin(an), 1.5 + sin(an * 100.) * 0.5, 1.0);\n        vec3 ta = vec3(1.0 * cos(an), 1.5 + sin(an * 100.) * 0.5, 0.0);\n\n        vec3 ww = normalize(ta-ro);\n        vec3 uu = normalize(cross(ww, vec3(0, 1, 0)));\n        vec3 vv = normalize(cross(uu, ww));\n\n        vec3 movement = ww * iTime * iTime / 10. * 2.;\n\n        ro = ro + movement;\n\n        vec3 rd = normalize(p.x * uu + p.y * vv + 1.5 * ww);\n\n        col += render(ro, rd);\n    } else {\n        for (int i = -AA; i <= AA; i++) {\n            for (int j = -AA; j <= AA; j++) {\n                vec2 offset = vec2(float(i), float(j)) / (float(AA) * iResolution.y);\n                vec3 ro = vec3(1.0 * sin(an), 0.25 + sin(an * 100.) * 0.5, 1.0);\n                vec3 ta = vec3(1.0 * cos(an), 0.25 + sin(an * 100.) * 0.5, 0.0);\n                vec3 ww = normalize(ta - ro);\n                vec3 uu = normalize(cross(ww, vec3(0, 1, 0)));\n                vec3 vv = normalize(cross(uu, ww));\n                \n                vec3 movement = ww * iTime * iTime / 10. * 2.;\n                \n                ro = ro + movement;\n        \n                vec3 rd = normalize((p.x + offset.x) * uu + (p.y + offset.y) * vv + 1.5 * ww);\n\n                col += render(ro, rd);\n            }\n        }\n        col /= float((2 * AA + 1) * (2 * AA + 1));\n    }\n\n    \n    \n    // gamma correction (same as sqrt()) \n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}