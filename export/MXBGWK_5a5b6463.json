{"ver":"0.1","info":{"id":"MXBGWK","date":"1709740041","viewed":133,"name":"travel in fractal","username":"totan","description":"This is a sample posted on this site.\nhttps://qiita.com/Totan16/items/7165ace3d2a5e1ba6a7d\n\n","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define Res iResolution\n#define iMAX 100.0\n#define REACH 0.0001\n#define repeat(p,r) (mod(p,r)-r/2.)\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define Mod(p,a) mod(p-a/2.,a)-a/2.\n\n\n\n\nstruct RAY{\n    vec3 p;\n    vec3 dir;\n    vec3 Ndir;\n    vec2 tex;\n    float obj;\n    float total_d;\n    vec3 tCol;\n};RAY ray;\n\nfloat hash(float n){return fract(sin(n)*432.123);}\nfloat sdBox( vec3 p, vec3 b ){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdPillar(vec3 p, vec2 b){\n    vec2 q = abs(p.xz) - b;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\n\n\nfloat MAP(in vec3 p0){\n    \n    vec3 p=p0;\n    //p.xz=Mod(p.xz,68.);\n    p.xz=Mod(p.xz,17.);\n    //p.z=Mod(p.z,17.);\n    vec2 mas = vec2(p0.xz-p.xz)+0.1;\n    mas=floor(mas);\n    for(float i=0.,h=(hash(mas.x+3.*mas.y))*2.0+4.; i++<h;){p.xz=p.zx;}\n    \n    vec3 q=p;\n    q.z+=16.+(hash(mas.x+mas.y))*5.;\n    \n    float d=100.,d2;\n    float c=min(floor(iTime/3.), mod(iTime/3.,1.)+iTime/3.-1.);\n    float b=c*0.13+(hash(mas.x+mas.y+0.1))*5.+6.;\n    float a=1.;\n    for(float i=0.0;i++<7.;){\n        q.xz*=rot(b/a);\n        q = abs(q) - 9.*a;\n        d2= max(q.x,max(q.y,q.z));\n        d=min(d,d2);\n        a/=1.75;\n    }\n    float F=max(-d,p.y-10.);\n    \n    float T=sdBox(p-vec3(0.,0.,0.),vec3(5.,1.+(hash(mas.x+mas.y+0.1))*10.+5.,5.));\n    \n    float cuttingGrid = sdPillar(p,vec2(9));\n    //return cuttingGrid;\n    return min(min(max(F,T),p0.y+9.), -cuttingGrid);\n    \n}\nvec3 getNormal(float d){\n    //vec3 p=ray.p;\n    const vec2 e = vec2(0.001,0.0);\n    #if 0\n    return normalize(\n        vec3(MAP(ray.p + e.xyy) - MAP(ray.p - e.xyy),\n             MAP(ray.p + e.yxy) - MAP(ray.p - e.yxy),\n             MAP(ray.p + e.yyx) - MAP(ray.p - e.yyx)));\n    #else   \n    return normalize(\n        vec3(MAP(ray.p + e.xyy),\n             MAP(ray.p + e.yxy),\n             MAP(ray.p + e.yyx) )-MAP(ray.p));\n    #endif\n            \n}\nvec3 getReflect(vec3 dir,vec3 n){\n    //vec3 n = getNormal(d);\n    return reflect(dir,n);\n}\nbool RM(){\n    vec3 dir = ray.dir;\n    for(float t_d=0.0,d,i=0.0;i++<iMAX;){\n        t_d += d = MAP(ray.p);\n        ray.p+=dir*d;\n        if(d<REACH){\n            ray.Ndir=getNormal(d);\n            if(ray.obj<5.0){\n                ray.total_d=t_d;\n                return true;\n            }\n            dir = getReflect(dir,ray.Ndir);\n        }\n    }\n    return false;\n}\n\nvoid MOVE(inout vec3 pos,inout vec3 dir){\n    float speed = iTime*0.5;\n    pos.x+=9.;\n    pos.z += iTime*6.;\n    pos.y += cos(speed)*18.-18.;\n    dir.zy*=rot(cos(speed)*0.5+.07);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-Res.xy*0.5)/Res.y;\n    vec3 dir = vec3(uv.x,uv.y,(1.0-dot(uv, uv))*0.3 + 1.),\n         pos=vec3(0.0,30.,-30.);\n    MOVE(pos,dir);\n    //\n    \n    ray.dir=dir;\n    ray.p=pos;\n    ray.obj=1.0;\n    ray.tCol=vec3(0.0);\n    ray.total_d=0.0;\n    vec3 col=vec3(1.0);\n    if( RM() ){\n        float amb = 0.2*ray.Ndir.x+.4*ray.Ndir.y+.4;\n        col=0.0067 * vec3(1, 1, 1) * ray.total_d*amb;\n        //if(ray.obj==2.0){col=texture(iChannel0,ray.tex/32.).xyz;}\n    }\n    else{\n        col=vec3(1.0);\n    }\n    col=pow(col, vec3(.4545));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}