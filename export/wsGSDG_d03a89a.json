{"ver":"0.1","info":{"id":"wsGSDG","date":"1575118178","viewed":159,"name":"Simple 3D_sphere","username":"lypion","description":"Ray tracing, Sphere intersection, Blinn-Phong Lighting Model","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n---Main Content---\n\tThis is a basic ray tracing little program, inluding \n\t1. Basic transform matrix (scale, rotate, translate)\n\t2. Basic transform matrix between world space and view space\n\t3. ray-sphere intersecion,\n\t4. ray-plane intersection,\n\t5. Blinn-Phong lighting model \n\t6. Shadow calculation\n\n---Note---\n\t1.mat is column-based\n\t2.all related calculation is in view space\n\t3.the right sign ^ means the left param is a vector\n*/\n\n#define LIGHT_AMBIENT vec3(0.5)\n//All the objects is defined in its self space\nSphere sphere = Sphere(vec3(0.0, 0.0, 0.0), Material(vec3(0.2), vec3(1.0, 1.0, 0.0), vec3(1.0, 1.0, 0.0), 256.0), 4.0);  \nPlane plane = Plane(vec3(0.0), normalize(vec3(0.0, 1.0, 0.0)), Material(vec3(0.2), vec3(0.9), vec3(0.2), 4.0));\n\n\n//The ray equation: p^ = origin^ + direction^ * t\n//The sphere equation: dot(p^ - position^, p^ - position^) - radius * radius = 0\n//Solve the up two equations, we get a quadratic equation about t:\n//dot(direction^, direction^) * t * t + 2 * dot(direction^, origin^ - position^) * t + dot(origin^ - position^, origin^ - position^) - radius * radius = 0\n//The left thing is to solve this quatratic equation\nIntersection IntersectWithSphereFirst(Intersection intersection, Sphere sphere)\n{\n\tvec3 temp = intersection.ray.origin - sphere.position;\n    float a = dot(intersection.ray.direction, intersection.ray.direction);\n    float b = dot(intersection.ray.direction, temp);\n    float c = dot(temp, temp) - sphere.radius * sphere.radius;\n    float delta = b * b - a * c;\n    \n    if(delta > 0.00001)\n    {\n    \tfloat sqrtDelta = sqrt(delta);\n    \tfloat t1 = (-b + sqrtDelta) / a;\n        float t2 = (-b - sqrtDelta) / a;\n        \n        if(t2 > intersection.ray.tMIN && t2 < intersection.t)\n        {\n            vec3 point = intersection.ray.origin + intersection.ray.direction * t2;\n            vec3 normal = CalSphereNormal(sphere, point);\n        \tintersection.t = t2;\n            intersection.color = sphere.material;\n            intersection.normal = normal;\n            intersection.hasIntersect = true;\n        }        \t\n        else if(t1 > intersection.ray.tMIN && t1 < intersection.t)\n        {\n            vec3 point = intersection.ray.origin + intersection.ray.direction * t1;\n            vec3 normal = CalSphereNormal(sphere, point);\n        \tintersection.t = t1;\n            intersection.color = sphere.material;\n            intersection.normal = normal;\n            intersection.hasIntersect = true;\n        }        \t\n    }\n    return intersection;\n}\n\n//The ray equation: p^ = origin^ + direction^ * t\n//The plane equation: dot(p^ - point, normal) = 0\n//Solve the up two equations, we get a result:\n//if the ray direction is paralle to the plane, which means dot(direction, normal) = 0, the ray has no intersection with the plane\n//otherwise, t = dot(point^ - origin^, normal) / dot(direction, normal)\nIntersection IntersectWithPlaneFirst(Intersection intersection, Plane plane)\n{\n\tfloat denominator = dot(intersection.ray.direction, plane.normal);\n\tif(abs(denominator) < 0.00001)\n        return intersection; \n    \n    float t = dot((plane.point - intersection.ray.origin), plane.normal) / denominator;\n    if(t > intersection.ray.tMIN && t < intersection.ray.tMAX && t < intersection.t)\n    {\n    \tintersection.t = t;\n        intersection.color = plane.material;\n        intersection.normal = plane.normal;\n        intersection.hasIntersect = true;\n    } \n    return intersection;\n}\n\n//Generate the ray from the camera\n//return-return the ray in view space\nRay GenerateRay(Camera camera, vec2 uv)\n{\n    //map the center of the screen as the origin point\n\tuv -= vec2(0.5);\n    float halfHeight = tan(camera.fov / 2.0) * camera.frustum.nearestPlane;\n    vec3 pixelInViewSpace = vec3(0.0, 0.0, -camera.frustum.nearestPlane) + \n                 \t\t\tvec3(2.0 * uv.x * halfHeight * camera.aspectRatio, 0.0, 0.0) + \n                 \t\t\tvec3(0.0, 2.0 * uv.y * halfHeight, 0.0);\n    return Ray(vec3(0.0), normalize(pixelInViewSpace), RAY_MIN, RAY_MAX);\n}\n\n\n\nvec3 ShadowTest(Intersection intersection, vec3 lightDirect, Camera camera)\n{\n    vec3 point = intersection.ray.origin + intersection.ray.direction * intersection.t;\n\tvec3 newPoint = point - 0.01 * lightDirect;\n    Ray shadowRay = Ray(newPoint, -lightDirect, RAY_MIN, RAY_MAX); \n   \t\n    bool interWithLSphere = IsIntersectWithSphere(shadowRay, sphere, camera, true);    \n \tbool interWithPlane = IsIntersectWithPlane(shadowRay, plane, camera, true); \n    if(interWithLSphere || interWithPlane) \n    \treturn vec3(0.0);\n    else\n        return vec3(1.0);\n}\n\nvec3 RayTracing(Ray ray, DirectLight directLight, Camera camera)\n{\n    Material defultMat = Material(vec3(1.0), vec3(1.0), vec3(1.0), 0.0);\n    \n\tIntersection intersection = Intersection(ray, defultMat, vec3(1.0, 0.0, 0.0), RAY_MAX, false);\n    intersection = IntersectWithSphereFirst(intersection, sphere);    \n    intersection = IntersectWithPlaneFirst(intersection, plane);\n    //The ambient color is added whether or not the ray hits something\n    vec3 color = LIGHT_AMBIENT * intersection.color.ambient;\n    if(intersection.hasIntersect == true)\n    {\n    \tcolor = CalDirectLight(directLight, intersection, vec3(0.0));\n        color = color * ShadowTest(intersection, directLight.direction, camera);\n        return color;\n    }\n    return vec3(1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    Frustum frustum = Frustum(2.0, 100.0);\n\tvec3 cameraPos = vec3(0.0, 4.0, 0.0);\n\tvec3 cameraTar = vec3(0.0, 4.0, -1.);\n\tCamera camera = Camera(cameraPos, cameraTar, vec3(0.0, 1.0, 0.0), frustum, \n                           80.0 / 180.0 * PI, iResolution.x / iResolution.y);\n    \n    vec3 spherePos = vec3(0.0, 4.1, -12.0);\n    \n    //translate the sphere from self space to world space\n    mat4 sphereTransform = CalWorld2ViewMatrix(camera) * Translate(spherePos); \n    sphere.position = vec3(sphereTransform * vec4(sphere.position, 1.0));  \n    //translate the plane from self space to world space\n    mat4 planeTransform = CalWorld2ViewMatrix(camera); \n    plane.point = (planeTransform * vec4(plane.point, 1.0)).xyz;\n    //---NOTICE---: \n    //Not all the times normal matrix is equal to the transform matrix, To be exact, \n    //the normal matrix = transpose(inverse(transformMatrix))\n    //when we only do the equal ratio scale, rotation, translate, \n    //the inversed 3x3 transformMatrix is equal to the transposed 3x3 transformMatrix\n    //The normal is a vertor, so we need to eliminate the translation transform, \n    //so just set the w-component of the vec4 to be 0\n    mat4 normalMat = planeTransform;\n    plane.normal = normalize((normalMat * vec4(plane.normal, 0.0)).xyz);\n    \n    vec3 direction = normalize(vec3(cos(iTime * 0.1) * 10.0, -abs(sin(iTime * 0.1)) * 10.0, cos(iTime * 0.1) * 10.0 - 12.));\n    //vec3 direction = vec3(0.0 ,0.0, -1.0);\n    DirectLight directLight = DirectLight(direction, vec3(0.8));      \n    directLight.direction = vec3(CalWorld2ViewMatrix(camera) * vec4(directLight.direction, 0.0)).xyz;\n    \n    Ray ray = GenerateRay(camera, uv);   \n    vec3 color = RayTracing(ray, directLight, camera);\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//The nearest intersect distance\n#define RAY_MIN 0.0001f\n//The farest intersect distance\n#define RAY_MAX 1.0e20f\n\n#define PI 3.1415\n\n//only see the outside\n#define OUTSIDE_ONLY\n\nstruct Ray\n{\n\tvec3 origin;\n    vec3 direction;\n    float tMIN;\n    float tMAX;       \n};\n    \nstruct DirectLight\n{\n\tvec3 direction;\n\tvec3 color;\n};\n    \nstruct Material\n{\n    vec3 ambient;\n\tvec3 diffuse;\n    vec3 specular;\n    float shininess;\n};\n    \nstruct Intersection\n{\n    Ray ray;\n    Material color;\n    vec3 normal;\n\tfloat t;\n    bool hasIntersect;\n};\n    \nstruct Plane\n{\n\tvec3 point;\n    vec3 normal;\n    Material material;\n};\n    \nstruct Sphere\n{\n\tvec3 position;\n    Material material;\n    float radius;\n};\n    \nstruct Frustum\n{\n    //the distance between near plane and camera\n    float nearestPlane;\n    //the distance between far plane and camera\n    float farestPlane;\n};\n    \nstruct Camera\n{\n\tvec3 position;\n    vec3 target;\n    vec3 upGuide;   //the vector used to calculate the coordinate of camera, not the real up vector of camera\n    Frustum frustum;\n    float fov;\n    float aspectRatio;\n};\n\nmat4 Scale(vec3 param)\n{\n\treturn mat4(vec4(param.x, 0.0, 0.0, 0.0),\n                vec4(0.0, param.y, 0.0, 0.0),\n                vec4(0.0, 0.0, param.z, 0.0),\n                vec4(0.0, 0.0, 0.0, 1.0));\n}\n\nmat4 Translate(vec3 param)\n{\n\treturn mat4(vec4(1.0, 0.0, 0.0, 0.0),\n                vec4(0.0, 1.0, 0.0, 0.0),\n                vec4(0.0, 0.0, 1.0, 0.0),\n                vec4(param, 1.0));\n}\n\nmat4 Rotate(vec3 param)\n{\n\tmat4 xMat = mat4(vec4(1.0, 0.0, 0.0, 0.0),\n                     vec4(0.0, cos(param.x), sin(param.x), 0.0),\n                     vec4(0.0, -sin(param.x), cos(param.x), 0.0),\n                     vec4(0.0, 0.0, 0.0, 1.0));\n    mat4 yMat = mat4(vec4(cos(param.y), 0.0, -sin(param.y), 0.0),\n                     vec4(0.0, 1.0, 0.0, 0.0),\n                     vec4(sin(param.y), 0.0, cos(param.y), 0.0),\n                     vec4(0.0, 0.0, 0.0, 1.0));\n    mat4 zMat = mat4(vec4(cos(param.z), sin(param.z), 0.0, 0.0),\n                     vec4(-sin(param.z), cos(param.z), 0.0, 0.0),\n                    vec4(0.0, 0.0, 1.0, 0.0),\n                    vec4(0.0, 0.0, 0.0, 1.0));\n    return zMat * yMat * xMat;\n}\n\nmat4 CalWorld2ViewMatrix(Camera camera)\n{\n\tvec3 zDirec = normalize(camera.position - camera.target);\n    vec3 xDirec = normalize(cross(camera.upGuide, zDirec));\n    vec3 yDirec = cross(zDirec, xDirec);\n    mat4 view2World = mat4(vec4(xDirec, 0.0), \n                           vec4(yDirec, 0.0), \n                           vec4(zDirec, 0.0), \n                           vec4(0.0, 0.0, 0.0, 1.0));\n\t\n    mat4 translateMat = mat4(vec4(1.0, 0.0, 0.0, 0.0), \n                             vec4(0.0, 1.0, 0.0, 0.0), \n                             vec4(0.0, 0.0, 1.0, 0.0), \n                             vec4(-camera.position, 1.0));\n    return transpose(view2World) * translateMat;\n}\n\nmat4 CalView2WorldMatrix(Camera camera)\n{\n\tvec3 zDirec = normalize(camera.position - camera.target);\n    vec3 xDirec = normalize(cross(camera.upGuide, zDirec));\n    vec3 yDirec = cross(zDirec, xDirec);\n    mat4 view2World = mat4(vec4(xDirec, 0.0), \n                           vec4(yDirec, 0.0), \n                           vec4(zDirec, 0.0), \n                           vec4(0.0, 0.0, 0.0, 1.0)); \n    mat4 translateMat = mat4(vec4(1.0, 0.0, 0.0, 0.0), \n                             vec4(0.0, 1.0, 0.0, 0.0), \n                             vec4(0.0, 0.0, 1.0, 0.0), \n                             vec4(camera.position, 1.0));\n    return view2World * translateMat;\n}\n\nvec3 CalSphereNormal(Sphere sphere, vec3 point)\n{\n\treturn normalize(point - sphere.position);\n}\n\n//param-outsideOnly: the viewer can see the inside of the object or not\nbool IsIntersectWithSphere(Ray ray, Sphere sphere, Camera camera, bool outsideOnly)\n{\n\tvec3 temp = ray.origin - sphere.position;\n    float a = dot(ray.direction, ray.direction);\n    float b = dot(ray.direction, temp);\n    float c = dot(temp, temp) - sphere.radius * sphere.radius;\n    float delta = b * b - a * c;\n    \n    if(delta > 0.0)\n    {\n        float sqrtDelta = sqrt(delta);\n    \tfloat t1 = (-b + sqrtDelta) / a;\n        float t2 = (-b - sqrtDelta) / a;\n            \n        if(t2 > ray.tMIN && t2 < ray.tMAX)\n       \t{\n            return true;\n        }\n        else if(t1 > ray.tMIN && t1 < ray.tMAX)\n        {\n        \treturn true;       \n        }\n    }        \n    return false;\n}\n\nbool IsIntersectWithPlane(Ray ray, Plane plane, Camera camera, bool outsideOnly)\n{\n    float denominator = dot(ray.direction, plane.normal);\n\tif(abs(denominator) < 0.00001)\n        return false;\n    \n    float t = dot((plane.point - ray.origin), plane.normal) / denominator;\n\n\tif(t > ray.tMIN && t < ray.tMAX)\n    {\n    \treturn true;\n    }\n    return false;\n}\n\n\n\nvec3 CalDirectLight(DirectLight light, Intersection intersection, vec3 viewPos)\n{   \n    //diffuse\n    float diff = max(0.0, dot(-light.direction, intersection.normal));\n    vec3 diffuse = diff * light.color * intersection.color.diffuse;\n    \n    //specular\n    vec3 viewDirect = normalize(viewPos - (intersection.ray.origin + intersection.t * intersection.ray.direction));\n    vec3 h = normalize(-light.direction + viewDirect);\n    vec3 specular = light.color * intersection.color.specular * pow(max(0.0, dot(intersection.normal, h)), intersection.color.shininess);\n\t\n    return diffuse + specular;\n}\n","name":"Common","description":"","type":"common"}]}