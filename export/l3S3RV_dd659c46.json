{"ver":"0.1","info":{"id":"l3S3RV","date":"1708624477","viewed":65,"name":"volume ray casting primitive","username":"delajor","description":"I'm sure there are 1000 setups like this, but this is just a really quick primitive to do volume ray casting... ","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","cube"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RotateX(v,a) v.yz *= mat2(cos(a),sin(a),-sin(a),cos(a))\n#define RotateY(v,a) v.xz *= mat2(cos(a),sin(a),-sin(a),cos(a))\n#define RotateZ(v,a) v.xy *= mat2(cos(a),sin(a),-sin(a),cos(a))\n\n\nvec2 intersect_box(vec3 orig, vec3 dir) {\n  const vec3 box_min = vec3(-1);\n  const vec3 box_max = vec3(1);\n  vec3 inv_dir = 1.0 / dir;\n  vec3 tmin_tmp = (box_min - orig) * inv_dir;\n  vec3 tmax_tmp = (box_max - orig) * inv_dir;\n  vec3 tmin = min(tmin_tmp, tmax_tmp);\n  vec3 tmax = max(tmin_tmp, tmax_tmp);\n  float t0 = max(tmin.x, max(tmin.y, tmin.z));\n  float t1 = min(tmax.x, min(tmax.y, tmax.z));\n  return vec2(t0, t1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    vec3 dir = normalize(vec3(uv-res/2.0,1.0));\n    vec3 orig = vec3(0,0,-3.5);\n\n        \n    RotateX(dir,radians(iMouse.y));\n    RotateX(orig,radians(iMouse.y));\n    RotateY(dir,radians(-iMouse.x));\n    RotateY(orig,radians(-iMouse.x));\n\n    vec2 t_hit = intersect_box(orig, dir);\n    \n    if (t_hit.x > t_hit.y){\n        fragColor = vec4(0.0);\n        return;\n    }\n\n\n      // We don't want to sample voxels behind the eye if it's\n      // inside the volume, so keep the starting point at or in front\n      // of the eye\n      t_hit.x = max(t_hit.x, 0.0);\n\n      ivec3 volume_dims = ivec3(100);\n\n      // Step 3: Compute the step size to march through the volume grid\n      vec3 dt_vec = 1.0 / (vec3(volume_dims) * abs(dir));\n      float dt = min(dt_vec.x, min(dt_vec.y, dt_vec.z));\n\n      // Step 4: Starting from the entry point, march the ray through the volume\n      // and sample it\n      vec3 p = orig + t_hit.x * dir;\n      //gl_FragColor= vec4(p, 1.00);\n      //return;\n      vec4 color = vec4(0.0);\n\n      for (float t = t_hit.x; t < t_hit.y; t += dt) {\n\n        //vec4 val_color = transfer_fcn(p);\n        vec4 val_color = vec4(p, 0.01);\n        \n\n        // Step 4.2: Accumulate the color and opacity using the front-to-back\n        // compositing equation\n        color.rgb += (1.0 - color.a) * val_color.a * val_color.rgb;\n        color.a += (1.0 - color.a) * val_color.a;\n\n        // Optimization: break out of the loop when the color is near opaque\n        if (color.a >= 0.95) {\n          break;\n        }\n        p += dir * dt;\n        }\n    fragColor = color;\n    \n}","name":"Image","description":"","type":"image"}]}