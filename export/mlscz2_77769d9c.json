{"ver":"0.1","info":{"id":"mlscz2","date":"1692209797","viewed":56,"name":"Clock Shader Test","username":"gsm041039","description":"Clock Shader Test","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI 3.141592654\n#define TAU 6.283185308\n\nfloat Hash21(vec2 p) {\n    return fract(sin(dot(p, vec2(5124.3352, 7547.23))) * 3431.41);\n}\n\nmat2 Rotate(float r) {\n    float s = sin((r));\n    float c = cos((r));\n\n    return mat2(c, -s, s, c);\n\n}\n\nfloat Hand(vec2 p, vec2 l, float t, float s) {\n    vec2 pd = vec2(0.5, clamp(p.y, l.x, l.y));\n\n    return smoothstep(t, t - s, distance(p, pd));\n\n}\n\nfloat Box(vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat ClockMark(vec2 p, float n, float r, vec2 d) {\n    float m;\n    for(float i = 0.; i < n; i++) {\n        float t = i / n;\n        vec2 offset = vec2(cos(((TAU) * t)), sin(((TAU) * t))) * r;\n        vec2 uvn = (p + offset) * Rotate(-(TAU) * t + PI / 2.);\n        m += step(Box(uvn, vec2(d.x, d.y)), 0.001);\n    }\n\n    return m;\n\n}\n\nvec4 Clock(vec2 p, vec3 c) {\n    vec3 col;\n    float a;\n\n    float cb = smoothstep(0.03, 0.015, abs(length(p - 0.5) - 0.5));\n    float cf = step(length(p - 0.5), 0.5);\n    float cfs = 1. - smoothstep(0.42, 0.5, length(p - 0.5));\n    float cc = smoothstep(0.03, 0.015, length(p - 0.5));\n    float ccs = smoothstep(0.04, 0.015, length(p - 0.5));\n\n\n    float cbs = 1. - smoothstep(0.3, 1.2, length(p  - vec2(0.0, 0.8)));\n    cbs = pow(cbs, 5.)* cb * 0.7;\n\n    \n\n    float cs = 1. - smoothstep(0.1, 0.5, length(p  - vec2(0.7, 0.4)));\n    cs = clamp(cs - cb - cf, 0.0, 1.0);\n\n    float rt = iTime / (TAU);\n    vec2 uvsh = (p - 0.5) * Rotate(floor(rt * 60. / TAU) / 60. * TAU) + 0.5;\n    float sh = Hand(uvsh, vec2(0.5, 0.9), 0.003, 0.002);\n\n    vec2 uvshs = (p - 0.5) * Rotate(floor(rt * 60. / TAU) / 60. * TAU + 0.03) + 0.5;\n    float shs = Hand(uvshs, vec2(0.5, 0.89), 0.02, 0.08);\n\n    vec2 uvmh = (p - 0.5) * Rotate(floor(rt * 60. / TAU) / 60. * TAU / 60.) + 0.5;\n    float mh = Hand(uvmh, vec2(0.5, 0.8), 0.008, 0.002);\n\n    vec2 uvmhs = (p - 0.5) * Rotate(floor(rt * 60. / TAU) / 60. * TAU / 60. + 0.05) + 0.5;\n    float mhs = Hand(uvmhs, vec2(0.5, 0.8), 0.01, 0.05);\n\n    vec2 uvhh = (p - 0.5) * Rotate(rt / 60. / 60.) + 0.5;\n    float hh = Hand(uvhh, vec2(0.5, 0.7), 0.012, 0.002);\n\n    vec2 uvhhs = (p - 0.5) * Rotate(rt / 60. / 60. + 0.07) + 0.5;\n    float hhs = Hand(uvhhs, vec2(0.5, 0.7), 0.02, 0.05);\n\n    vec2 uvmr = p - 0.5;\n    float hm = ClockMark(uvmr, 12., .45, vec2(0.002, 0.03));\n\n    float mm = ClockMark(uvmr, 60., .46, vec2(0.002, 0.01));\n\n    vec2 uvs = p * 5. + iMouse.x / iResolution.x;\n    float s = (step(0.5, sin(((uvs - 0.5) * Rotate(PI * .25) + 0.5).y * PI) * 0.5 + 0.5) * 0.7 + 0.1) * 0.7;\n    s *= (1.0 - step(0.01, cb)) * cf;\n\n    float g = cf * (1.0 - cb) * 0.3;\n    vec3 cfc = vec3(cf * cfs) * vec3(1.0, 1.0, 1.0);\n    vec3 gc = vec3(0.6, 0.7, 0.8);\n    vec3 sc = vec3(1.0, 1.0, 1.0);\n\n    vec3 cbc = mix(c * 0.7, c, cb);\n    cb = smoothstep(0.0, 0.2, cb);\n\n    float m = (hm + mm) * (1.0 - cb);\n\n    float h = max(max(max(sh,mh),hh), shs + mhs + hhs);\n    vec3 ccc = mix(vec3(0.7, 0.5, 0.2), vec3(1.0, 0.96, 0.87), cc);\n    cc = smoothstep(0.0, 0.2, cc);\n\n    col = mix(cfc, cbc, cb);\n    col = mix(col , vec3(0.0), m);\n    col = mix(col, vec3(0.2), h);\n    col = mix(col, vec3(0.2), ccs);\n    col = mix(col, ccc, cc);\n    col = mix(col, gc, g);\n    col = mix(col, sc, s);\n    col = mix(col, vec3(1), cbs);\n    col = mix(col, vec3(0), cs);\n\n    a = clamp(cb + cf + cs, 0.0, 1.0);\n\n    return vec4(col, a);\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 col = vec3(1);\n\n    vec2 uv = ((fragCoord - 0.5 * iResolution.xy) / iResolution.y) + 0.5;\n\n    vec2 m = (iMouse.xy / iResolution.xy - 0.5) * 0.25;\n\n    \n    float d = clamp(0.0, 1.0, dot(m,  uv - 0.5));\n    float a = mix(1.0, 10.0,d);\n\n\n    float scale = mix(1.0, 2., 1. / a);\n    vec2 uv2 = ((uv * scale + (scale - 1.) * -0.5) + m);\n    vec4 clock = Clock(uv2, vec3(1.0, 0.1, 0.2));\n    col = mix(col, clock.xyz, clock.a);\n\n    fragColor = vec4(vec3(col), 1.0);\n\n}\n","name":"Image","description":"","type":"image"}]}