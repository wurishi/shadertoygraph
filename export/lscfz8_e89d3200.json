{"ver":"0.1","info":{"id":"lscfz8","date":"1524012053","viewed":75,"name":"DomainDistortion2","username":"ChloeSnyder","description":"566","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["566"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define deg2rad PI / 180.0\n\n// RAY MARCHING CODE SOURCE JAMIE WONG\nconst int MAX_MARCHING_STEPS = 100;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 500.0;\nconst float EPSILON = 0.0001;\nconst float EPSILON_NORM = .001;\n\nvec3 K_d = vec3(-1.0, -1.0, -1.0); // diffuse color\nfloat shininess;\n\nfloat noise( in vec2 x )\n{\n\treturn sin(1.5*x.x)*sin(1.5*x.y);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n//sdSphere(p - vec3(0.0, -2.0, 0.0), .40)\nfloat opTwist( vec3 p )\n{\n    float c = cos(20.0*p.y) + noise(p.xy);\n    float s = sin(20.0*p.y) + noise(p.xy);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return sdSphere(q/2.0, .40);\n}\n\n\n\n/**\n * Rotation matrix around the X axis. https://www.shadertoy.com/view/4tcGDr\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n/**\n * Rotation matrix around the Y axis. https://www.shadertoy.com/view/4tcGDr\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Rotation matrix around the Z axis. https://www.shadertoy.com/view/4tcGDr\n */\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// modified from jamie wong\nvec3 scaleOp(vec3 samplePoint, vec3 scale)\n{\n\treturn (samplePoint / scale) * min(scale.x, min(scale.y, scale.z));\n}\n\n//JW\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n//JW\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n//JW\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n// iq\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n// iq\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n//iq\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n// iq\nfloat cylinderSDF( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//http://glslsandbox.com/e#40928.0\nvoid Rotate( inout vec2 p, float a ) \n{\n    p = cos( a ) * p + sin( a ) * vec2( p.y, -p.x );\n}\n\n\n//http://glslsandbox.com/e#40928.0\nfloat saturate( float x )\n{\n    return clamp( x, 0.0, 1.0 );\n}\n\n//http://glslsandbox.com/e#40928.0\nfloat Smooth( float x )\n{\n\treturn smoothstep( 0.0, 1.0, saturate( x ) );   \n}\n\n\n\n// Based off: //http://glslsandbox.com/e#40928.0\nfloat noodle (vec3 p)\n{\n   \n    float scale = 1.0 - 2.5 * saturate( abs( p.y ) * 0.01 );  \n    //p.x -= sin( p.y * 2.0 + iTime * 10.0 ) * 0.1; //controls animation of tentacle\n   \n    \n    // For ret: sdCapsule, second argument defines lower end point, third is upper end point\n    // p is the point being evaluated, last argument is thickness\n    float cap = sdCapsule(p, vec3( 0.0, -2.0, 0.0 ), vec3( 0.0, 4.0, 0.0 ), 0.3 * scale );\n\t\n    // want more tapering at the end\n    float cone = sdCone(rotateX(-PI/2.0) * p + vec3(0.0, 0.0, -1.0), normalize(vec2(1.5, .30)));//sdCappedCone(p , vec3(1.0, 1.0, 1.0));\n    //return cone;\n    float f = smin(cone, cap, -.5);\n    \n    return smin(f, opTwist(p - vec3(0.0, -2.0, 0.0)), .1);//sdSphere(p - vec3(0.0, -2.0, 0.0), .40));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat suctionCup(vec3 p, float scale)\n{\n    \n    vec3 cp = rotateX(-PI/2.0) * p;\n    float outer = cylinderSDF(cp, vec2(1.0, .30) / scale);\n    float inner = cylinderSDF(cp, vec2(.25, .5) / scale);\n    \n    float mid = differenceSDF(outer, inner);\n\n   \n    if(mid <= 0.0 + EPSILON)\n    {\n        K_d = vec3(1.0, 0.0, 1.0);\n    } \n\n    return mid;\n}\n\n\n//http://glslsandbox.com/e#40928.0\nfloat Tentacle( vec3 p )\n{\n    p.x -= sin( p.y * 2.0 + iTime * 10.0 ) * 0.1;\n    \n    float noodle = noodle(p); // The \"main body\" of the tentacle\n    if(noodle < 0.0 + EPSILON)\n    {\n        K_d = vec3(1.0, 0.0, 0.0);\n    } \n    \n    float scale = 150.0;\n    p += vec3(0.0, -.70, 0.0);\n    vec3 sc_p1 = p - vec3(0.01, 0.0, 0.02);\n    vec3 sc_p2 = p - vec3(-0.01, 0.0, 0.02);\n    \n    \n    sc_p1 = rotateY(PI/4.0) * sc_p1;\n    sc_p2 = rotateY(-PI/4.0) * sc_p2;\n    float sc1 = suctionCup(sc_p1, scale);\n    float sc2 = suctionCup(sc_p2, scale);\n    float sc = unionSDF(sc1, sc2);\n    \n    \n    // first six suction cups: start small and scale bigger\n    // as they are placed from the tip towards the base\n    // also, rotate so that they lie \"on\" the surface of the tentacle\n    for(int i = 0; i < 6; i++)\n    {\n        scale /= 1.45;\n        sc_p1 += vec3(-0.00005, .05 * float(i),float(i) * -0.0085);\n        sc_p2 += vec3(0.00005, .05 * float(i),float(i) * -0.0085);\n        sc1 = suctionCup(sc_p1, scale);\n        sc2 = suctionCup(sc_p2, scale);\n        sc = unionSDF(sc, sc1);\n        sc = unionSDF(sc, sc2);\n    }\n    \n    sc_p1 = rotateY(-PI/8.0) * sc_p1;\n    sc_p2 = rotateY(PI/8.0) * sc_p2;\n    \n    // Once close enough to the base, can be the same size and rotation\n    for(int j = 6; j < 14; j++)\n    {\n        if(j > 12)\n        {\n            sc_p1 = rotateY(PI/16.0) * sc_p1;\n    \t\tsc_p2 = rotateY(-PI/16.0) * sc_p2;\n        }\n        sc_p1 += vec3(0, .25 , -0.0176);\n        sc_p2 += vec3(0, .25 , -0.0176);\n        sc1 = suctionCup(sc_p1, scale);\n        sc2 = suctionCup(sc_p2, scale);\n        sc = unionSDF(sc, sc1);\n        sc = unionSDF(sc, sc2);\n    }\n    \n   \n    float f = smin(noodle, sc, .01);\n    return f;//unionSDF(f, sdSphere(p - vec3(0.0, .50, 0.0), .40));\n  \n}\n\n// iq\n\n\nfloat opCheapBend( vec3 p )\n{\n    float c = cos(p.y) + noise(p.xy);\n    float s = sin(p.y) ;//+ noise(p.xy);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    \n    // TODO: the bounding capsule has to go here.\n    float scale = 1.0 - 2.5 * saturate( abs( p.y ) * 0.01 );  \n    float boundingCapsule = sdCapsule(p, vec3( 0.0, -30.0, 0.0 ), vec3( 0.0, 4.0, 0.0 ),  scale );\n    if(boundingCapsule < .015)\n    {\n        return Tentacle(p);\n        \n    } else {\n       // K_d = vec3(noise(p.xy), noise(p.xz), noise(p.yz));\n        return boundingCapsule;\n    }\n}\n\n\nfloat opRep( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return opCheapBend( q );\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n    \n    vec3 p = samplePoint;\n    \n  // return opRep(p, vec3(4.0, 0.0, 5.0));\n   \n    \n    /*if(boundingCapsule < .015)\n    {\n        //return Tentacle(p);\n        return opRep(p, vec3(0.0, 0.0, PI));\n    } else {\n        return boundingCapsule;\n    }*/\n    \n    \n     float tentacleRing = opRep(samplePoint, vec3(2.0, 0.0, 10));//-1.0;//-1.0;\n    float amplitude = 1.0;\n    int numTentacles = 3;\n   \n    float gap = 360.0 / float(numTentacles) * deg2rad;\n    \n    for (int i = 0; i < numTentacles; i++)\n    {\n        float angle = float(i) * gap;     \n             \n        float offsetX = (amplitude) * sin(angle);\n    \tfloat offsetY = (amplitude) * cos(angle);\n        \n        vec3 localP = p;\n        localP += vec3(offsetX, offsetY, 0.0);\n        localP = rotateZ(-angle) * localP;\n        float tentacle = opRep(localP, vec3(float(i) * PI, 0.0, float(i) * PI));\n        \n        \n        tentacleRing = unionSDF(tentacle, tentacleRing);\n       // tentacleRing = unionSDF(tentacleRing, sdSphere(localP, 1.0));\n    }\n    \n    \n   /* for(int i = 0; i < numTentacles; i++)\n    {\n\n       \tfloat angle = float(i) * gap;     \n             \n        float offsetX = (amplitude) * sin(angle);\n    \tfloat offsetY = (amplitude) * cos(angle);\n        \n        vec3 localP = p;\n        localP += vec3(offsetX, offsetY, 0.0);\n        localP = rotateZ(-angle) * localP;\n        \n        float scale = 1.0 - 2.5 * saturate( abs( localP.y ) * 0.01 );  \n    \tfloat boundingCapsule = sdCapsule(localP, vec3( 0.0, -2.0, 0.0 ), vec3( 0.0, 4.0, 0.0 ), 0.5 * scale );\n\t\tif(boundingCapsule < .015)\n        {\n            float tentacle = opRep(localP, vec3(2.0, 0.0, 10));\n        \tif(tentacleRing == -1.0)\n        \t{\n            \ttentacleRing = tentacle;\n        \t}\n      \n        \ttentacleRing = unionSDF(tentacle, tentacleRing);\n        }   else {\n            tentacleRing = unionSDF(boundingCapsule, tentacleRing);\n        }\n    }\n    */\n        \n    return tentacleRing;\n    \n    \n  //  return opRep(samplePoint, vec3(0.0, 0.0, PI));\n    //return opCheapBend(samplePoint);\n   // return opTwist(samplePoint);\n   //return(Tentacle(samplePoint));\n\n}\n\n\n/** JW\n * \n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/** JW\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/** JW\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON_NORM, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON_NORM, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON_NORM, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON_NORM, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON_NORM)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON_NORM))\n    ));\n}\n\n\nfloat lambert(vec3 N, vec3 L)\n{\n  vec3 nrmN = normalize(N);\n  vec3 nrmL = normalize(L);\n  float result = dot(nrmN, nrmL);\n  return max(result, 0.0);\n}\n\n\n/** JW\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nmat2 rot(float a) \n{\n    vec2 s = sin(vec2(a, a + PI/2.0));\n    return mat2(s.y,s.x,-s.x,s.y);\n}\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nfloat fbm6( vec2 p )\n{\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.015625*(0.5+0.5*noise( p ));\n    return f/0.96875;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 10.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    \n    /*  vec3 rayDir = cam* normalize( vec3(screenPos.xy,2.0) );\n    rayDir.xy *= rot(iTime*0.1);\n    float dist = rayMarch(rayDir, cameraOrigin);*/\n    // https://www.shadertoy.com/view/4slyRs\n   // worldDir.xy *= rot(iTime*.2);\n    \n    \n //   worldDir.x += fbm6(worldDir.xy);\n //   worldDir.xy *= rot(iTime * fbm6(worldDir.xy));\n    worldDir.xz *= rot(cos(iTime) * fbm6(worldDir.xy));\n    worldDir.xy *= rot(sin(iTime));\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        //fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n       // fragColor = vec4(fbm4(iTime * fragCoord), iTime * fbm6(fragCoord), iTime * noise(iTime * fragCoord), 1.0);\n\t\tfragColor = vec4(fbm4(iTime * fragCoord), 0.0, 0.0, 1.0);\n\n        return;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    \n    vec3 color = K_d * lambert(estimateNormal(p), eye);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}