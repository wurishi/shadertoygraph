{"ver":"0.1","info":{"id":"7sKfDh","date":"1658340939","viewed":155,"name":"Raymarching using D3D matrices","username":"EisernSchild","description":"Here i use D3D style (inverse) matrices in the Microsoft provided transform_ray() method to generate the ray.\n\nThis is useful if you want to add volume ray techniques within your D3D/Hlsl projects.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","math"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Raymarching using D3D matrices\n// Copyright (c) 2022 by Denis Reischl\n//\n// SPDX-License-Identifier: MIT\n\n// uses code with following rights :\n// Copyright (c) Microsoft\n// Copyright (c) 2013 Inigo Quilez\n// \n// SPDX-License-Identifier: MIT\n\n/*\n    Here i use D3D style (inverse) matrices in the Microsoft \n    provided transform_ray() method to generate the ray.\n    \n    This is useful if you want to add volume ray techniques\n    within your D3D/Hlsl projects.\n*/\n\n// scene primitives\n#define SPHERE uint(0)\n#define FLOOR uint(1)\nvec3 vSpherePos = vec3(0., 1., 0.);\n\n// ray hit attribute\nstruct PosNorm\n{\n\tvec3 vPosition;\n\tvec3 vNormal;\n    uint uPrimI;\n};\n\n// max ray steps\nconst uint uMaxSteps = uint(255);\n// ray min/max distance\nconst float fTMin = 0.f, fTMax = 100.f;\n// adjust raysteps to avoid flaws\nconst float fStepAdjust = 1.f;\n// treshold = min factor to provide hit\nconst float fThreshold = 0.0001;\n\n// signed distance functions - by Inigo Quilez\nfloat sdSphere(vec3 vPos) { return length(vPos - vSpherePos) - 1.0; }\nfloat sdPlane(vec3 vPos) { return vPos.y; }\n\n// scene (all primitives distance)\nfloat sdScene(vec3 vPos, out uint uIx) \n{\n    float fD = sdSphere(vPos);\n    uIx = SPHERE;\n    float fDn = sdPlane(vPos);\n    if (fDn < fD)\n    {\n        uIx = FLOOR;\n        fD = fDn;\n    }\n    return fD;\n}\n\n// get normal for hit\nvec3 sdCalculateNormal(in vec3 vPos, in uint uIx)\n{\n    switch (uIx)\n    {\n    case SPHERE:\n        return normalize(vPos - vSpherePos);\n    case FLOOR:\n        return vec3(0., 1., 0.);\n    default:break;\n    }\n\n    vec2 vE = vec2(1.0, -1.0) * 0.5773 * 0.0001;\n    return normalize(\n        vE.xyy * sdScene(vPos + vE.xyy, uIx) +\n        vE.yyx * sdScene(vPos + vE.yyx, uIx) +\n        vE.yxy * sdScene(vPos + vE.yxy, uIx) +\n        vE.xxx * sdScene(vPos + vE.xxx, uIx));\n}\n\n// Volume Ray Casting (Ray Marching) - Microsoft method\nbool vrc(in vec3 vOri, in vec3 vDir, out float fThit, out PosNorm sAttr)\n{\n\tfloat fT = fTMin;\n\tfloat fStep = sdScene(vOri, sAttr.uPrimI);\n\tvec3 vPos = vOri;\n\n\t// march through the space\n\tuint uI = uint(0);\n\twhile (uI++ < uMaxSteps && fT <= fTMax)\n\t{\n        // perform step\n\t\tvPos += fStep * vDir;\n\t\tfloat fDist = sdScene(vPos, sAttr.uPrimI);\n\n\t\t// intersection ?\n\t\tif (fDist <= fThreshold * fT)\n\t\t{\n            // is valid ?\n\t\t\tif (fT < fTMax)\n\t\t\t{\n                vec3 vNormal = sdCalculateNormal(vPos, sAttr.uPrimI);\n\t\t\t\tfThit = fT;\n\t\t\t\tsAttr.vPosition = vPos;\n\t\t\t\tsAttr.vNormal = vNormal;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// raymarch step\n\t\tfStep = fStepAdjust * fDist;\n\t\tfT += fStep;\n\t}\n\treturn false;\n}\n\n// transform a ray based on screen position, camera position and inverse wvp matrix - Microsoft method\nvoid transform_ray(in uvec2 sIndex, in vec2 sScreenSz, in vec4 vCamPos, in mat4x4 sWVPrInv,\n\tout vec3 vOrigin, out vec3 vDirection)\n{\n\t// center in the middle of the pixel, get screen position\n\tvec2 vXy = vec2(sIndex.xy) + 0.5f;\n\tvec2 vUv = vXy / sScreenSz.xy * 2.0 - 1.0;\n\t\n\t// unproject by inverse wvp\n\tvec4 vWorld = vec4(vUv, 0, 1) * sWVPrInv;\n\n\tvWorld.xyz /= vWorld.w;\n\tvOrigin = vCamPos.xyz;\n\tvDirection = normalize(vWorld.xyz - vOrigin);\n}\n\n// lighting \nvec3 SceneLighting(\n    in vec3 vPos, \n    in vec3 vRayDir, \n    in vec3 vLitPos,\n\tin vec3 vNorm,\n\tin vec3 cMaterial,\n\tin vec3 vLight,\n\tin vec3 cLight)\n{\n\t// get distance, reflection\n\tfloat fDist = length(vLitPos - vPos);\n\tvec3 vRef = reflect(vRayDir, vNorm);\n\n\t// calculate fresnel, specular factors\n\tfloat fFresnel = max(dot(vNorm, -vRayDir), 0.0);\n\tfFresnel = pow(fFresnel, .3) * 1.1;\n\tfloat fSpecular = max(dot(vRef, vLight), 0.0);\n\n\t// do lighting\n\tvec3 cLit = cMaterial * .8f;\n\tcLit = mix(cLit, cMaterial * max(dot(vNorm, vLight), 0.0), min(fFresnel, 1.0));\n\tcLit += cLight * pow(fSpecular, 220.0);\n\n\treturn cLit;\n}\n\n// get UV position of ground plane\nvec2 GroundLitPos(in vec3 vPos, in vec3 vRayDir)\n{\n\t// get lit position\n\tfloat fD = -vPos.y / vRayDir.y;\n\treturn vec2(vPos.x + vRayDir.x * fD, vPos.z + vRayDir.z * fD);\n}\n\n// checkers, hexagonal\nfloat checkers_hex(in vec2 vPt, in vec2 vDpdx, in vec2 vDpdy )\n{\n    // filter kernel\n    vec2 vW = abs(vDpdx) + abs(vDpdy) + 0.001;\n    // integral\n    float fIn = (HexGrid(vPt + .5 * vW) + HexGrid(vPt - .5 * vW)) * .5f;\n    \n    return mix(smoothstep(.6, .65, fIn), fIn, length(vW));\n}\n\nvoid mainImage( out vec4 cOut, in vec2 vXY )\n{\n    const float fCamDist = 17.f;    \n    const float fCamHeight = 7.f;\n    const vec3 cSphere = vec3(1.0, 0.3, 0.3);\n    vec3 vRef;\n    \n    // move primitives\n    vSpherePos.xy = vec2(cos(iTime * .8) * .4, sin(iTime) * .3 + 1.3);\n    \n    // get current camera position and lookat matrix\n    vec4 vCamPos = vec4(sin(iTime) * fCamDist, fCamHeight, cos(iTime) *  fCamDist, 0.0);\n    mat4x4 avLookAt = LookAtLH(vCamPos.xyz, vec3(0., .1, 0.), vec3(0., 1., 0.));\n      \n    // get projection matrix\n    mat4x4 avProj = PerspectiveLH(vec2(radians(90.), radians(60.)), vec2(1., 1000.));\n    \n    // get ray\n    vec3 vOri, vDir;\n    transform_ray(uvec2(vXY), iResolution.xy, \n        vCamPos, inverse(avLookAt * avProj), vOri, vDir);\n    \n    // perform volume ray cast (raymarching)\n    float fThit = 0.f;\n    PosNorm sAttr;\n    if (!vrc(vOri, vDir, fThit, sAttr))\n    {\n        // Didn't hit anything.. draw horizon\n        if (vDir.y > 0.0)\n            cOut = mix(vec4(.0, .0, 1., 1.), vec4(.5, .6, .8, 1.), 1. - vDir.y);\n        else\n            cOut = mix(vec4(.0, .0, 1., 1.), vec4(.5, .6, .8, 1.), 1. + vDir.y);\n\t\treturn;\n    }\n    else\n    {\n        // which primitive was hit by ray ?\n        switch (sAttr.uPrimI) \n        {\n        \n        case SPHERE:        \n            // apply lighting\n            vec3 cCol = SceneLighting(\n                vCamPos.xyz, \n                vDir, \n                sAttr.vPosition,\n                sAttr.vNormal,\n                cSphere,\n                normalize(vec3(-.4f, .2f, -.3f)),\n                vec3(.9f, .8f, .7f));\n            vRef = reflect(vDir, sAttr.vNormal);\n            \n            // adjust to avoid reflection flaws by horizon\n            if (vRef.y > -0.1)\n            {\n                cCol = mix(cCol, mix(vec3(.0, .0, 1.), vec3(.5, .6, .8), 1. - vRef.y), .2);\n            }\n            else\n            {\n                // get checkers\n                vec2 vUV = GroundLitPos(sAttr.vPosition, vRef);\n                float fCh = checkers_hex(vUV, dFdx(vUV), dFdy(vUV));\n                cCol = mix(cCol, mix(vec3(.7, .8, .6) * .1, vec3(.9, .8, .7), fCh) * .2, .2);\n            }\n            \n            cOut = vec4(cCol, 1.);\n            break;\n\n        case FLOOR:        \n            // get ground uv, render checkers\n            vec2 vUV = GroundLitPos(vOri, vDir);\n            cOut = mix(vec4(.7, .8, .6, 1.), vec4(.9, .8, .7, 1.), checkers_hex(vUV, dFdx(vUV), dFdy(vUV)));\n            \n            // get shadow\n            float fThisSh = 0.f;\n            PosNorm sAttrSh;\n            if (vrc(sAttr.vPosition + vec3(0., 0.1, 0.), normalize(vec3(-.4f, .2f, -.3f)), fThisSh, sAttrSh))\n            {\n                cOut *= .8f + clamp(fThisSh * .02, .0, .15);\n            }\n            \n            // get reflection\n            vRef = reflect(vDir, normalize(vec3(0., 1., 0.)));\n            float fThisRf = 0.f;\n            sAttrSh.vPosition = vec3(0.);\n            sAttrSh.vNormal = vec3(0.);\n            sAttrSh.uPrimI = uint(0);\n            if (vrc(sAttr.vPosition + vec3(0., 0.1, 0.), vRef, fThisRf, sAttrSh))\n            {\n                fThisRf += fThisSh * 1.4f;\n                cOut = mix(cOut, vec4(cSphere * .3, 1.), fThisRf * 0.02);\n            }\n            \n            // apply lighting\n            cOut.xyz = SceneLighting(\n                vCamPos.xyz, \n                vDir, \n                sAttr.vPosition,\n                sAttr.vNormal,\n                cOut.xyz,\n                normalize(vec3(-.4f, .2f, -.3f)),\n                vec3(.9f, .8f, .7f));\n            \n            // blend with horizon to avoid flaws   \n            cOut = mix(cOut, vec4(.5, .6, .8, 1.), clamp(fThit * .017, 0., 1.));\n            break;\n            \n        }\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// EisernSchild 3D library\n// Copyright (c) 2022 by Denis Reischl\n//\n// SPDX-License-Identifier: MIT\n\n// Math Library #####################################################\n\n// Orthographic projection : ba = (b.an)an\nvec2 ortho_proj(vec2 vA, vec2 vB)\n{\n    vec2 vAn = normalize(vA);\n    return dot(vB, vAn) * vAn;\n}\n\n// rotate 2D\nvec2 rotate(vec2 vV, float fA) \n{\n\tfloat fS = sin(fA);\n\tfloat fC = cos(fA);\n\tmat2 mR = mat2(fC, -fS, fS, fC);\n\treturn mR * vV;\n}\n\n// Hex Grid Library #####################################################\n\nconst vec2 vNext = vec2( 1.5f / sqrt(3.f), 1.5f );\nconst float fTD = length(vNext);\n\n/// Cartesian to hex coordinates\nvec2 HexUV(vec2 vXy)\n{\n\t// hex coords       (u, v) = (          .5 * x + .5 * y,        y ) \n\t// hex coord scaled (u, v) = ((sqrt(3.f) * x + y) / 3.f, y / 1.5f )\n\treturn vec2( (sqrt(3.f) * vXy.x + vXy.y) / 3.f, vXy.y / 1.5f );\n}\n\n/// Hex to cartesian coordinates\nvec2 HexXY(vec2 vUv)\n{\n\t// get cartesian coords\n\treturn vec2( (vUv.x * 3.f - vUv.y * 1.5f) / sqrt(3.f), vUv.y * 1.5f );\n}\n\n// provide hex grid\nfloat HexGrid(vec2 vPt)\n{\n    // get approx. hexagonal center coords\n    vec2 vUvC = round(HexUV(vPt));\n        \n    // get approx. cartesian hex center\n    vec2 vPtC = HexXY(vUvC);\n    \n    // get local coords absolut, adjust x\n    vec2 vPtLc = abs(vPt - vPtC);\n    if (vPtLc.x > (fTD * .5)) vPtLc.x = fTD - vPtLc.x;\n    \n    // project point on constant tile vector\n    vec2 vPtN = ortho_proj(vNext, vPtLc);\n    \n    // get distance, adjust again\n    float fD = max(vPtLc.x, length(vPtN));\n    if (fD > (fTD * .5)) fD = fTD - fD;\n    \n    return fD;\n}\n\n// Transform Library #####################################################\n\n// provide a lookat matrix\nmat4x4 LookAtLH(vec3 vCam, vec3 vTar, vec3 vUp)\n{\n    mat4x4 avLookAt;\n    vec3 vZ = normalize(vTar - vCam);\n    vec3 vX = normalize(cross(vUp, vZ));\n    vec3 vY = cross(vZ, vX);\n       \n    avLookAt = \n    mat4x4(\n        vec4(1., 0., 0., -vCam.x),\n        vec4(0., 1., 0., -vCam.y),\n        vec4(0., 0., 1., -vCam.z),\n        vec4(0., 0., 0., 1.)\n    ) *\n    mat4x4(\n        vec4(vX.x, vX.y, vX.z, 0.),\n        vec4(vY.x, vY.y, vY.z, 0.),\n        vec4(vZ.x, vZ.y, vZ.z, 0.),\n        vec4(0., 0., 0., 1.)\n    );\n    \n    return avLookAt;\n}\n\n// provide a perspective projection matrix\nmat4x4 PerspectiveLH(vec2 vFov, vec2 vZnf)\n{\n    float fW = tan(vFov.x*0.5),\n          fH = tan(vFov.y*0.5);\n    \n    mat4x4 avProj = mat4x4( 0.0 );\n    avProj[0][0] = 2. * vZnf.x / fW;\n    avProj[1][1] = 2. * vZnf.x / fH;\n    avProj[2][2] = vZnf.y / (vZnf.y - vZnf.x);\n    avProj[3][2] = 1.;\n    avProj[2][3] = vZnf.x*vZnf.y/(vZnf.x - vZnf.y);\n    \n    return avProj;\n    \n}","name":"Common","description":"","type":"common"}]}