{"ver":"0.1","info":{"id":"lfsXWB","date":"1705683830","viewed":158,"name":"snow hill godrays pushed paint.","username":"chenxianming","description":"snow hill godrays pushed paint.\n\nmade this paint lastyear.","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["fog","godrays","hill"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// https://www.shadertoy.com/view/ls3GWS\n// FXAA code from: http://www.geeks3d.com/20110405/fxaa-fast-approximate-anti-aliasing-demo-glsl-opengl-test-radeon-geforce/3/\n// https://developer.download.nvidia.com/assets/gamedev/files/sdk/11/FXAA_WhitePaper.pdf\n\n#define FXAA_SPAN_MAX 16.0\n#define FXAA_REDUCE_MUL   (1.0/FXAA_SPAN_MAX)\n#define FXAA_REDUCE_MIN   (1.0/128.0)\n#define FXAA_SUBPIX_SHIFT (1.0/4.0)\n\nvec3 FxaaPixelShader( vec4 uv, sampler2D tex, vec2 rcpFrame) {\n    \n    vec3 rgbNW = texture(tex, uv.zw).xyz;\n    vec3 rgbNE = texture(tex, uv.zw + vec2(1,0)*rcpFrame.xy).xyz;\n    vec3 rgbSW = texture(tex, uv.zw + vec2(0,1)*rcpFrame.xy).xyz;\n    vec3 rgbSE = texture(tex, uv.zw + vec2(1,1)*rcpFrame.xy).xyz;\n    vec3 rgbM  = texture(tex, uv.xy).xyz;\n\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max(\n        (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),\n        FXAA_REDUCE_MIN);\n    float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n    \n    dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\n          max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n          dir * rcpDirMin)) * rcpFrame.xy;\n\n    vec3 rgbA = (1.0/2.0) * (\n        texture(tex, uv.xy + dir * (1.0/3.0 - 0.5)).xyz +\n        texture(tex, uv.xy + dir * (2.0/3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (\n        texture(tex, uv.xy + dir * (0.0/3.0 - 0.5)).xyz +\n        texture(tex, uv.xy + dir * (3.0/3.0 - 0.5)).xyz);\n    \n    float lumaB = dot(rgbB, luma);\n\n    if((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;\n    \n    return rgbB; \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 rcpFrame = 1./iResolution.xy;\n  \tvec2 uv2 = fragCoord.xy / iResolution.xy;\n        \n    vec3 col;\n    \n    vec4 uv = vec4( uv2, uv2 - (rcpFrame * (0.5 + FXAA_SUBPIX_SHIFT)));\n    col = FxaaPixelShader( uv, iChannel0, 1./iResolution.xy );\n    \n    fragColor = vec4( col, 1. );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define T( s ) fract( iTime * s ) * PI * 4.\n\n\nfloat mountain( vec3 p ){\n    float py = p.y;\n\n    p.x -= .05;\n    \n    py = abs( py - .3 );\n    \n    p += texture( iChannel0, ( p.xz ) * .31 ).rgb * .1;\n    \n    return v(\n        max(\n            max(\n                abs( p.x ),\n                abs( p.z )\n            ) - 1. * py,\n            abs( p.y ) - .3\n        )\n    );\n}\n\n\nfloat df( vec3 p ){\n    return mountain( p );\n}\n\nfloat b( vec3 p ){\n    \n    float py = p.z / 2. + .5;\n    \n    p.x += cos( T( .025 ) ) * ( I.x > I.y ? 8. : 6. );\n    p.z += sin( T( .025 ) ) * 3.;\n    p.y += cos( T( .125 ) ) * .1;\n    p.y += py * .5;\n    \n    p.xz *= rot( atan( sin( T( .025 ) ) * ( I.x > I.y ? .8 : .6 ), cos( T( .025 ) ) * .3 ) );\n    p.yz *= rot( PI * -.45 );\n    \n    p.y -= 1.5;\n\n    \n    return body( p );\n}\n\nvec3 renderEgle( vec3 r ){\n    vec3 c, p, o = vec3( 0., 0., -70. );\n    r.xy *= .1;\n    float t, d, i;\n    for( ; i < 20.; i++ )\n        p = o + r * t,\n        d = b( p ),\n        t += d * .7777778;\n    \n    if( d < 1e-3 )\n        c = vec3( 1. );\n        \n    return c;\n}\n\n// egleEND\n\nvoid mainImage( out vec4 U, in vec2 V )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 u = ( V * 2. - I.xy ) / A;\n    if( I.x <= I.y )\n        u = ( V * 3. - I.xy * 1.5 ) / A,\n        u.y -= .3;\n    \n    \n    vec3 c, p, o = vec3( 0., 0., -1. ), r = vec3( u * .6, 1. );\n    float t, ta, d, da, dp, i;\n    \n    c -= renderEgle( r );\n    \n    for( ; i < 64.; i++ )\n        p = o + r * t,\n        d = df( p ),\n        t += d * .4445,\n        d *= ( smoothstep( 0.0, .5, abs( u.y + .1 ) - .01 ) );\n    \n    c += ( 1. - smoothstep( 0.1, .8, length( u - vec2( .0, .0 ) ) - .01 ) ) * 2.;\n    \n    c *= v( mountain( p ) );\n    \n    c = v( c );\n    \n    // Output to screen\n    U = vec4(c,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n#define T( s ) fract( iTime * s ) * PI * 4.\n\n\nbool sw( float t, float a ){\n    return mod( round( t + 5. ), 14. ) == a;\n}\n\nfloat ww( float t ){\n    \n    float r = T( .25 );\n    \n    if( \n        sw( t, 0. ) ||\n        sw( t, 1. ) ||\n        sw( t, 2. )\n    ){\n        r = fract( ( 1.5 + cos( iTime * 5. ) * .03 ) * .25 ) * PI * 4.;\n    }\n\n    return cos( r );\n}\n\n\nfloat rep(inout vec2 p, float rep) \n{\n\n    float an = TAU/rep;\n    \n    float fa = (atan(p.y,p.x)+an*0.5)/an;\n    float ia = floor( fa );\n    \n    float sym = an*ia;\n    \n    p *= rot(sym);\n\n    return ia;\n}\n\n\nfloat mountain( vec3 p ){\n    float py = p.y;\n\n    p.x -= .05;\n    \n    py = abs( py - .3 );\n    \n    p += texture( iChannel0, ( p.xz ) * .31 ).rgb * .1;\n    \n    return v(\n        max(\n            max(\n                abs( p.x ),\n                abs( p.z )\n            ) - 1. * py,\n            abs( p.y ) - .3\n        )\n    );\n}\n\nfloat mountains( vec3 p ){\n\n    p.y += .7;\n    \n    p += texture( iChannel0, ( p.xz ) * .32 ).rgb * .1;\n    \n    float d = length( p * vec3( .1, 1., .1 ) ) - .6;\n\n    return v(d);\n}\n\nfloat cloud( vec3 p, float i ){\n    \n    p.x += cos( iTime / i ) * .05;\n    p.y += cos( iTime / i ) * .05;\n    \n    \n    p += texture( iChannel0, p.yz + abs(i) * .1 ).r * .1;\n    p += texture( iChannel0, p.xz + abs(i) * .1 ).r * .1;\n\n    return length( p * vec3( .6, 1., .6 ) ) - .1;\n}\n\nfloat clouds( vec3 p ){\n    \n    p.y -= .3;\n    \n    p.y = abs( p.y ) - .3;\n    float i = rep( p.xz, 25. );\n    p.x -= .7;\n\n    \n    return cloud( p, i );\n}\n\n// egle\n\nfloat wings( vec3 p ){\n    \n    p.x -= .1;\n    p.y -= .1;\n    \n    p.z -= pow( p.x, 3. ) * ww(iTime) / 1.4;\n    \n    float d = .5;\n    \n    float g = smax(\n        abs( p.x ) - .35,\n        abs( p.y ) - .15,\n        .05\n    );\n    \n    vec2 p2 = p.xy;\n    \n    p2.y += abs( cos( p2.x ) * .4 );\n    p2.x = abs( p2.x ) - .3;\n    p2.y -= .4;\n    p2.x = abs( p2.x ) - .1;\n    \n    g = smin(\n        g,\n        length( p2 ) - .1,\n        .1\n    );\n    \n    return max(\n        g,\n        abs( p.z ) - .01\n    );\n}\n\n\nfloat tail( vec3 p ){\n    \n    p.y += .2;\n    \n    p.yz *= rot( PI * -.025 + cos( T( .25 ) ) * .05 );\n    p.y -= .2;\n    \n    return max(\n        max(\n            abs( p.x ) - .3 * abs( p.y - .5 ),\n            abs( p.y ) - .15\n        ),\n        abs( p.z ) - .01\n    );\n}\n\n\nfloat beak( vec3 p ){\n\n    float py = 1. - ( p.y / 2. + .5 );\n    \n    py -= .5;\n    py *= 2.;\n    py = clamp( py, 0., 1. );\n    \n    return max(\n        length( p.xz ) - .3 * py,\n        abs( p.y ) - .1\n    );\n}\n\nfloat paw( vec3 p ){\n    \n    p.x = abs( p.x ) - .1;\n    \n    p.xz *= rot( PI * .25 );\n    p.yz *= rot( PI * .5 );\n    \n    \n    for( float i = 0.; i < 2.; i++ ){\n        p.xz = abs( p.xz );\n        p.xz *= rot( i / 3. * PI );\n    }\n    \n\n    float a = max(\n        length( p.xy ) - .09,\n        -( length( p.xy + vec2( .0, .02 ) ) - .09 )\n    );\n    \n    return max(\n        a,\n        abs( p.z ) - .01\n    );\n}\n\nfloat head( vec3 p ){\n    return length( p ) - .08;\n}\n\n\nfloat b( vec3 p ){\n    \n    float py = p.z / 2. + .5;\n    \n    p.x += cos( T( .025 ) ) * ( I.x > I.y ? 8. : 6. );\n    p.z += sin( T( .025 ) ) * 3.;\n    p.y += cos( T( .125 ) ) * .1;\n    p.y += py * .5;\n    \n    p.xz *= rot( atan( sin( T( .025 ) ) * ( I.x > I.y ? .8 : .6 ), cos( T( .025 ) ) * .3 ) );\n    p.yz *= rot( PI * -.45 );\n    \n    p.y -= 1.5;\n\n    float d = .1;\n    \n    vec3 pwing = p;\n    \n    pwing.xz *= rot( ww(iTime) * .3 );\n    \n    if( pwing.x < 0. ){\n        pwing.x *= -1.;\n        pwing.xz *= rot( ww(iTime) * .3 );\n        pwing.xz *= rot( ww(iTime) * .3 );\n    }\n\n    d = smin( \n        wings( pwing + vec3( -.05, .1, 0. ) ),\n        body( p ),\n        .05\n    );\n    \n    d = smin( d, tail( p + vec3( 0., .2, 0. ) ), .02 );\n    \n    d = smin( d, head( p - vec3( 0.0, 0.25, .05 ) ), .02 );\n    \n    d = min( d, beak( p - vec3( .0, .4, .06 ) ) );\n    \n    d = min( d, paw( p - vec3( 0., .0, -.15 ) ) );\n    \n    return d;\n}\n\nvec3 renderEgle( vec3 r ){\n    vec3 c, p, o = vec3( 0., 0., -70. );\n    r.xy *= .1;\n    float t, d, i;\n    for( ; i < 64.; i++ )\n        p = o + r * t,\n        d = b( p ),\n        t += d * .7777778;\n    \n    if( d < 1e-3 )\n        c = vec3( 1. );\n        \n    return c;\n}\n\n// egleEND\n\nfloat df( vec3 p ){\n    \n    return smin( \n        mountain( p ),\n        mountains( p ),\n        .08\n    );\n}\n\nvec3 l(in vec3 b) {\n  vec2 a = vec2(1, -1) * .5773;\n  return normalize(a.xyy * df(b + a.xyy * 5e-4) + a.yyx * df(b + a.yyx * 5e-4) +\n                   a.yxy * df(b + a.yxy * 5e-4) + a.xxx * df(b + a.xxx * 5e-4));\n}\n\nfloat g( vec3 a, vec3 p ){\n    return v( dot( a, l(p) ) );\n}\n\nfloat S( vec3 p, vec3 ca, vec3 r, float q ){\n    return v( pow( dot( l( p ), normalize( normalize( ca ) - r ) ), q ) );\n}\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = df( ro + rd*t );\n\n        // traditional technique\n        res = min( res, 10.0*h/t );\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\nvec3 gr( vec2 V, vec2 cen, float n ){\n    vec3 c;\n    \n    vec2 u = V / I.xy;\n    \n    for( float i = 0.; i < 500.; i++ ){\n        if( i > n ){\n            break ;\n        }\n        c += texture( iChannel1, u + ( i / n * .8 ) * ( cen - u ) ).rgb * (1.- i / n ) * .2;\n    }\n    \n    return c;\n}\n\nfloat gr2( vec2 u ){\n    u.y -= .3;\n    u.x += .1;\n    \n    u = normalize( u );\n    u = mod( u, .3 ) - .2 + cos( u.x ) * .1 + cos( iTime ) * .05;\n    \n    return ( 1. - smoothstep( 0., .1, length( u ) - .01 ) ) * .5;\n}\n\nvoid mainImage( out vec4 U, in vec2 V )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 u = ( V * 2. - I.xy ) / A;\n    if( I.x <= I.y )\n        u = ( V * 3. - I.xy * 1.5 ) / A,\n        u.y -= .3;\n    \n    vec3 c, skyCol = vec3( 0.51, 0.83, 0.97 ), p, pa, o = vec3( 0., 0., -1. ), r = vec3( u * .6, 1. );\n    float t, ta, d, da, dp, e = sqrt( 1e-3 ), i;\n    float fog;\n    \n    vec3 eg = renderEgle( r );\n    eg = sqrt( eg );\n    \n    for( ; i < 64.; i++ )\n        p = o + r * t,\n        pa = o + r * ta,\n        d = df( p ),\n        da = clouds( pa ),\n        dp = ( 1. - abs( da ) / e ),\n        c += ( dp > 0. ) ? .01 * (1. - dp) / ta : 0.,\n        t += d * .4445,\n        d *= ( smoothstep( 0.0, .5, abs( u.y + .1 ) - .01 ) ),\n        ta = mix(\n            ta,\n            .8,\n            max( abs( da ) * .22223, e * .1 )\n        ),\n        fog += d * ( 1. - (p.z / 2. + .5) );\n\n    \n    c = v( c );\n    c -= v( gr2( u ) ) * 2.;\n    c *= .1;\n    c += .3;\n    \n    if( sin( T( .025 ) ) * 3. > 0. )\n        c = mix(\n            c,\n            vec3(-.1),\n            eg\n        );\n        \n    \n    vec3 gg;\n    \n    c += smoothstep( .2, 1., u.y / 2. + .5 ) * skyCol * .65;\n    c *= ( smoothstep( 0.0, .2, abs( u.y + .3 ) - .01 ) );\n\n    vec3 n = l( p );\n    float dif = g( vec3( 0., 1.3, -.2 ), p );\n    \n    if( d < 1e-3 && df( p ) != clouds( p ) ){\n        \n        float density = .4;\n        float fogFactor = exp( -density * density * fog * fog );\n        \n        if( df( p ) == mountains( p ) ){\n            \n            gg = vec3( dif );\n\n            gg -= texture( iChannel0, p.xz * 3. ).r * .5;\n\n            gg -= calcSoftshadow( o, l( p ), .1, 3. ) * .1;\n\n            if( df( p ) == mountains( p ) )\n                gg *= fogFactor;\n\n            gg += dif * .1;\n            gg += texture( iChannel0, p.xz * 5. ).r * .1;\n            \n            gg = v( gg );\n            \n        }\n\n    }\n    \n    gg += .05;\n    gg = clamp( gg, .5, 1. );\n    gg -= v( vec3( mountain( p ) ) + vec3( mountains( p ) ) ) * .9;\n    gg = v( gg );\n    gg += skyCol * .05;\n    c += gg;\n    \n    \n    if( d < 1e-3 && df( p ) != clouds( p ) && df( p ) != mountains( p ) ){\n\n        float density = .8;\n        float fogFactor = exp( -density * density * fog * fog );\n        \n        c = vec3( dif ) ;\n\n        c -= texture( iChannel0, p.xz * 3. ).r * .5;\n\n        c -= calcSoftshadow( o, l( p ), .1, 3. ) * .1;\n\n        c += dif * .1;\n        \n        c += texture( iChannel0, p.xz * 5. ).r * .1;\n        \n        c = clamp( c, .4, 1. );\n        c += skyCol * .1;\n        c = v( c );\n    }\n\n    \n    if( sin( T( .025 ) ) * 3. < 0. )\n        c = mix(\n            c,\n            vec3(.25 * skyCol),\n            eg\n        );\n    \n    vec2 cen = vec2( .5, .66 );\n    vec3 ga = gr( V, cen, 40. );\n    c += ga * vec3( 0.97, 0.75, 0.16 ) * .3;\n\n    cen = vec2( .5, .8 );\n\n    ga = gr( V, cen, 15. );\n    c += ga * vec3( .7 ) * .1;\n    \n    cen = vec2( .51, .8 );\n    ga = gr( V, cen, 15. );\n    c += ga * vec3( 0.97, 0.75, 0.16 ) * .4;\n\n\n    ta = 0.,\n    i = 0.,\n    da = 0.,\n    dp = 0.;\n    \n    for( ; i < 40.; i++ )\n        pa = o + r * ta,\n        pa.y *= -1.,\n        pa += abs( fract( 21443.456 * p.z ) ) * .02,\n        da = clouds( pa - vec3( 0., .2, 0. ) ),\n        dp = ( 1. - abs( da ) / e ),\n        c -= ( dp > 0. ) ? .01 * dp / ta  : 0.,\n        ta += max( abs( da ) * .2223, e * .4 );\n\n    ta = 0.,\n    i = 0.,\n    da = 0.,\n    dp = 0.;\n    \n    float smk = 0.;\n    \n    for( ; i < 40.; i++ )\n        pa = o + r * ta,\n        pa -= abs( fract( 21443.456 * p.z ) ) * .015,\n        pa.xz *= rot( T( .0025 ) ),\n        p.y += cos( T( .0125 ) ) * .1,\n        da = clouds( pa - vec3( 0., -.5, 0. ) ),\n        dp = ( 1. - abs( da ) / e ),\n        smk += ( dp > 0. ) ? .002 * dp / ta  : 0.,\n        ta += max( ( da ) * .33334, e * .1 );\n    \n    smk = v( smk );\n    smk = sqrt( smk );\n    c = mix(\n        c,\n        vec3( 1. ),\n        smk\n    );\n    \n    c += fract( 123.456 * p.z ) * .03;\n    \n    // Output to screen\n    U = vec4(c,1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926\n#define TAU PI * 2.\n#define I iResolution\n#define A min( I.x, I.y )\n#define v( a ) clamp( a, 0., 1. )\n#define rot( a ) mat2( cos( a ), sin( a ), -sin( a ), cos( a ) )\n\nfloat smin (float a, float b, float r)\n{\n    float h = clamp(.5+.5*(b-a)/r,0.,1.);\n    return mix(b, a, h) - r*h*(1.-h);\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat body( vec3 p ){\n    \n    float py = p.y;\n    \n    py *= p.y > 0. ? 2. : 4.;\n    \n    py = clamp( py, -1., 1. );\n    py = pow( py, 2. );\n    \n    py = abs( py );\n    py = abs( py - 1. );\n    \n    py = abs( py ) - .1;\n    \n    return smax(\n        smax( \n            abs( p.x ) - .1 * py,\n            abs( p.y ) - .3 * py,\n            .05\n        ),\n        abs( p.z ) - .1,\n        .1\n    );\n    \n}\n","name":"Common","description":"","type":"common"}]}