{"ver":"0.1","info":{"id":"dtycWc","date":"1700729432","viewed":25,"name":"extremly trippy sierpinski attem","username":"OogaAndBooga","description":"a better shader","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractal","sierpinski"],"hasliked":0,"parentid":"Dsjyzw","parentname":"sierpinsi with dot product"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433832795\n\nfloat ws( float e[4], int len) {\n    float d = 0.;\n    for(int i = 0; i < len; i += 2) {\n        if(i / 2 % 2 == 1)\n            d += sin(e[i]) * e[i + 1];\n        else\n            d += sin(e[i]) * e[i + 1];\n    }\n    return d;\n}\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec2 squarescale(vec2 a){\n    vec2 i = iResolution.xy;\n    return vec2((a.x - .5) * i.y / i.x + .5, a.y); \n}\n\n//cosine\nfloat cosine(vec2 a, vec2 b) {\n    float c = dot(a, b) / length(a) / length(b); // cosine\n    return c;\n}\n\n//project a on b\nvec2 proj(vec2 a, vec2 b) {\n    float c = cosine(a, b);\n    return normalize(b) * length(a) * c;\n}\n\n// perpendicular distance\nfloat pdist(vec2 p, vec2 a, vec2 b) {\n    vec2 amog = proj(p - a, b - a); //project\n    return distance(p - a, amog);\n}\n\nvec2 trdsierpinski(vec2 p, vec2 a, vec2 b, vec2 c) {\n    float dp = pdist(a, b, p); // dist p to ab\n    float dc = pdist(a, b, c); // dist c to ab\n    float pcos = cosine(p - a, b - a); // p cosine\n    float ccos = cosine(c - a, b - a); // c cosine\n    \n    return vec2(dp / dc, bool(ccos < pcos));\n}\n\nvec2 sierpinski(vec2 a, vec2 b, vec2 c, vec2 p, float iter) {\n    \n    // start new part\n//    float d1 = pdist(p, a, b);\n//    float d2 = pdist(p, b, c);\n//    float d3 = pdist(p, c, a);\n    \n//    d1 /= pdist(c, a, b);\n//    d2 /= pdist(a, b, c);\n//    d3 /= pdist(b, c, a);\n    // end new part\n    \n    vec2 i1 = trdsierpinski(p, a, b, c);\n    vec2 i2 = trdsierpinski(p, b, c, a);\n    vec2 i3 = trdsierpinski(p, c, a, b);\n    \n    float d1 = i1[0];\n    float d2 = i2[0];\n    float d3 = i3[0];\n    \n    bool c1 = bool(i1[1]);\n    bool c2 = bool(i2[1]);\n    bool c3 = bool(i3[1]);\n    \n    float rez = pow(2.0, iter); //exponent determines resolutution\n    int rd1 = int(d1 * rez);\n    int rd2 = int(d2 * rez);\n    int rd3 = int(d3 * rez);\n    \n    // angle cosine for A, B and C\n    //float ca = cosine(c - a, b - a);\n   // float cb = cosine(a - b, c - b);\n  //  float cc = cosine(b - c, a - c);\n    \n //   float cpa = cosine(p - a, b - a);\n //   float cpb = cosine(p - b, c - b);\n //   float cpc = cosine(p - c, a - c);\n    \n    return vec2(\n        float(bool(rd1 & rd2 & rd3)), \n        float(c1 && c2 && c3)\n        //1.0\n        //float(ca <= cpa && cb <= cpb && cc <= cpc)\n        //1.0\n        //float(0.0 <= kab && kab < 1.0 && 0.0 <= kbc && kbc <= 1.0 && 0.0 <= kca && kca < 1.0)\n    );\n}\n\nfloat iter = 4.5; // resolution, if integer sierpinskini emerges\n\nint MODE = 3;\nbool TRIPPY = true;\nbool TBACKGROUND = false;\nbool MAKESQUARE = false;\nbool PINK = false;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 a = vec2(0.05, 0.10001);\n    vec2 b = vec2(0.5, 0.94);\n    vec2 c = vec2(0.95, 0.1);\n    \n     if(MODE == 1) {\n        a += vec2(0., ws(float[](iTime, 0.1, -iTime *4., 0.05), 4));\n        b += vec2(0.2*(smoothstep(-0.7,0.7,sin(iTime * 3.)) - 0.7),0);\n        c += vec2(0.,0.);\n    }\n    else if(MODE == 2){\n        a += vec2(0.1 * random(vec2(0., float(int(iTime) % 3))), 0.2*random(vec2(0., float(int(iTime) % 4))));\n        b += vec2(0.1 * random(vec2(0., float(int(iTime + 1.) % 3))), 0.1*random(vec2(0., float(int(iTime) % 10))));\n        c += vec2(0.15 * random(vec2(0., float(int(iTime) % 4))), 0.19*random(vec2(0., float(int(iTime * .5) % 10))));\n    }\n    else if(MODE == 3) {\n        float t = iTime * .5, r = 0.2, s = 0.3;\n        vec2 ro = vec2(r * cos(t), r * sin(t)) + vec2(.5);\n        float tr = iTime * -0.5;\n        a = ro + s * vec2(cos(0.+tr), sin(0.+tr));\n        b = ro + s * vec2(cos(PI*2./3.+tr), sin(PI*2./3.+tr));\n        c = ro + s * vec2(cos(PI*4./3.+tr), sin(PI*4./3.+tr));\n    }\n    else if(MODE == 4) {\n        a = vec2(.5);\n        float t = iTime;\n        b = a + vec2(cos(t-PI/.3),sin(t-PI/.3)) * ((t / 2. / PI) - floor(t / 2. / PI) + 1.);\n        c = a + vec2(cos(t-PI*2./.3),sin(t-PI*2./.3)) * ((t / 2. / PI) - floor(t / 2. / PI) + 1.);\n    }\n    \n    if(MAKESQUARE) {\n        a = squarescale(a);\n        b = squarescale(b);\n        c = squarescale(c);\n    }\n    \n    if(TRIPPY) {\n        iter += .5 + .5*sin(iTime * .4);\n    }\n    \n    vec3 e = vec3(0.);\n    vec3 f = vec3(1.);\n    vec3 bkg = vec3(0.133,0.867,0.302);\n    \n    if(PINK) {\n         e = vec3(0.976,0.302,0.843);\n         f = vec3(0.820,0.259,0.867);\n         bkg = vec3(0.729,0.043,0.957);\n    }\n    \n    vec2 i = sierpinski(a, b, c, uv, iter);\n    if(i.y == 1. || TBACKGROUND)\n        fragColor = vec4(i.x*f + float(!bool(i.x))*e, 1.);\n    else\n        fragColor = vec4(bkg, 1.0);\n}","name":"Image","description":"","type":"image"}]}