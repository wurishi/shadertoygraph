{"ver":"0.1","info":{"id":"wdBfzh","date":"1589549838","viewed":190,"name":"Path Tracing Spheres","username":"boris159","description":"Basic implementation of path tracing algorithm.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["3d","raytracing","pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 tex = texture(iChannel0, fragCoord / iResolution.xy);\n    vec3 col = tex.xyz / tex.a;\n    col = pow(col, vec3(1.0 / 2.2));\n    \n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"struct Material\n{\n    vec3 emitt;\n    vec3 ref;\n    float spec;\n    float diff;\n};\n\nstruct Sphere\n{\n    vec3 pos;\n    float r;\n    Material mat;\n};\n\n#define EPSILON 0.001\n#define PI 3.141592\n#define MAX_DIST 1000.0\n#define bounces 5\n#define spNum 7\n\nSphere spheres[spNum];\nfloat seed;\n\nfloat rand()\n{\n    seed += 0.15342;\n    return fract(sin(seed) * 35423.7652344);\n}\n\nfloat randUnit(float a, float b)\n{\n\treturn a + (b - a) * rand();\n}\n\nvec3 randDir(vec3 dir, float spread)\n{\n    vec3 b3 = normalize(dir);\n    vec3 different = (abs(b3.x) < 0.5) ? vec3(1, 0, 0) : vec3(0, 1, 0);\n    vec3 b1 = normalize(cross(b3, different));\n    vec3 b2 = cross(b1, b3);\n\n    float z = randUnit(cos(spread * PI), 1.0);\n    float r = sqrt(1.0 - z * z);\n    float theta = randUnit(-PI, PI);\n    float x = r * cos(theta);\n    float y = r * sin(theta);\n\n    return b1 * x + b2 * y + b3 * z;\n}\n\nvec3 bounce(Material mat, vec3 dir, vec3 n)\n{\n    if (rand() < mat.spec)\n    \tdir = randDir(reflect(dir, n), mat.diff / 2.0);\n    else\n        dir = randDir(n, 0.5);\n    \n    return dir;\n}\n\nvec3 makeRay(vec2 coord)\n{\n    vec2 res;\n    res.x = coord.x - iResolution.x * 0.5;\n    res.y = coord.y - iResolution.y * 0.5;\n    \n    return normalize(vec3(res / iResolution.yy, 1));\n}\n\nfloat intersect(vec3 origin, vec3 dir, Sphere sp)\n{\n    vec3 oc = origin - sp.pos;\n    float b = dot(oc, dir);\n    float c = dot(oc, oc) - sp.r * sp.r;\n    float h = b * b - c;\n    \n    if(h < 0.0)\n        return -1.0;\n        \n    h = sqrt(h);\n    return min(-b - h, -b + h);\n}\n\nfloat closestSphere(vec3 origin, vec3 dir, out Sphere sp)\n{\n    float res = MAX_DIST;\n    \n    for (int i = 0; i < spNum; i++)\n    {\n        float d = intersect(origin, dir, spheres[i]);\n        \n        if (d < res && d > EPSILON)\n        {\n            res = d;\n            sp = spheres[i];\n        }\n    }\n    \n    return res;\n}\n\nvec3 trace(vec3 origin, vec3 dir)\n{\n\tvec3 globalCol = vec3(0);\n    Sphere spheres[bounces];\n    \n    for (int b = 0; b < bounces; b++)\n    {\n        Sphere tmp = Sphere(vec3(0), 0.0, Material(vec3(0), vec3(0), 0.0, 1.0));\n        float d = closestSphere(origin, dir, tmp);\n       \tspheres[b] = tmp;\n        \n        origin += dir * d;\n        vec3 n = normalize(origin - tmp.pos);\n        dir = bounce(tmp.mat, dir, n);\n    }\n    \n    for (int i = bounces - 1; i >= 0; i--)\n    \tglobalCol = spheres[i].mat.emitt + globalCol * spheres[i].mat.ref;\n\n    return globalCol;\n}\n\nvec2 dirByAng(float deg)\n{\n    float rad = deg * PI / 180.0;\n    return vec2(sin(rad), cos(rad));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Material wallMat = Material(vec3(0), vec3(1), 0.75, 0.25);\n    \n    spheres[0] = Sphere(vec3(dirByAng(0.0) * 5001.0, 0), 5000.0, wallMat);\n    spheres[1] = Sphere(vec3(dirByAng(120.0) * 5001.0, 0), 5000.0, wallMat);\n    spheres[2] = Sphere(vec3(dirByAng(240.0) * 5001.0, 0), 5000.0, wallMat);\n    spheres[3] = Sphere(vec3(0, 0, 5003), 5000.0, Material(vec3(0), vec3(1), 0.0, 1.0));\n    \n    spheres[4] = Sphere(vec3(dirByAng(0.0) * 0.45, 3), 0.4, Material(vec3(0, 1, 0), vec3(1), 0.0, 1.0));\n    spheres[5] = Sphere(vec3(dirByAng(120.0) * 0.45, 3), 0.4, Material(vec3(0, 0, 1), vec3(1), 0.0, 1.0));\n    spheres[6] = Sphere(vec3(dirByAng(240.0) * 0.45, 3), 0.4, Material(vec3(1, 0, 0), vec3(1), 0.0, 1.0));\n    \n    seed = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    vec3 traced = trace(vec3(0, 0, 0), makeRay(fragCoord));\n    vec4 col = texture(iChannel0, fragCoord / iResolution.xy);\n    col += vec4(traced, 1);\n    \n    if (iMouse.z > 0.0)\n        col = vec4(0);\n    \n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"}]}