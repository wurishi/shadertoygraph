{"ver":"0.1","info":{"id":"MfXGDj","date":"1703527050","viewed":39,"name":"planet and star","username":"nayk","description":"planet,star,galaxy, universe","likes":1,"published":1,"flags":1,"usePreview":0,"tags":["star","planet","galaxy","universe"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* originals https://www.shadertoy.com/view/4sVfWR https://www.shadertoy.com/view/lslyRn https://www.shadertoy.com/view/4tyfWy*/\n\n#define iterations 12\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n#define pi 3.14159265359\n//this noise stuff is from iq thanks\nfloat hash (vec2 v) {\n    v = floor(v);\n    return fract(67.3249*sin(17.1234*length(v-vec2(34.14,123.))));\n}\nfloat noise (vec2 v) {\n    vec4 n = vec4(floor(v),ceil(v));\n    vec4 h = vec4(hash(n.xy),hash(n.zy),hash(n.xw),hash(n.zw));\n    return mix(mix(h.x,h.y,v.x-n.x),mix(h.z,h.w,v.x-n.x),v.y-n.y);\n}\nmat2 r (float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(s,-c,c,s);\n}\nfloat no (vec2 v) {\n    float c = 0.;\n    for (int i = 1; i < 10; i++) {\n        v = 1.*r(0.1944*pi)*v;\n        c += 0.2*noise(v)/(1.+length(sin(0.5*v)));\n    }\n    return c;\n}\n// flow stuff is from trirop https://www.shadertoy.com/view/MsScWD very cool\nvec2 ff (vec2 v) {\n    \tfloat n = 1.+0.5*noise(v);\n\t\treturn \n\t        sign(v.y-0.5)*50.*vec2(n*sin(1.4*v.y),0.)/(v.y+3.5)+\n\t        .1*vec2(sin(-12.*v.y*n),cos(13.*v.x))+\n\t        1.8*vec2(cos(-6.*v.y),sin(4.*v.x))+\n\t        1.2*vec2(sin(-1.4*v.y),cos(1.5*v.x))+\n\t        2.0*vec2(sin(-.5*v.y),cos(.6*v.x))+\n\t        0.8*vec2(sin(-.2*v.y),cos(.2*v.x*n))\n\t     ;}\nbool star = false;\nvec2 mouse;\nvoid sphere (inout vec3 p, inout vec3 d) {\n\tfloat r = .12, dp = dot(d,p), pp = dot(p,p), det = dp*dp+r*r-pp;\n    if (det < 0.) star = true;\n    float x = -dp+sqrt(det);\n    p = (p+d*x);\n    d = reflect(normalize(p),d);\n}\n\nvec3 surface (vec2 uv) {\n\tvec3 col = 00.1*vec3(7.-abs(uv.y))*no (uv);\n    for (int i = 0; i < 10; i++) {\n\t\tuv += 0.001*(2.+0.5*sin(.1*iTime))*ff(uv);\n    }\n    float j = no(0.2*uv*pi);\n    vec3 c = sin(j*vec3(1,2,3));\n    col += abs(mix(c*c*c,vec3(j),abs(1.-uv.y/7.5)));\n    return col;\n}\nvec3 stars (vec2 v) {\n\treturn vec3(pow(1.35*no(0.1*iTime+5.*mouse+3.*v/dot(v,v)),7.));\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam;\n            p.xy*=mat2(cos(iTime*0.05),sin(iTime*0.05),-sin(iTime*0.05),cos(iTime*0.05));// the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.2-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.02,1.);\t\n}\nfloat heal_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n   vec2 uv2 = fragCoord.xy/iResolution.xy-.5;;\n\tvec3 dir=vec3(uv2*zoom,1.);\n\tfloat time=iTime*speed+.25;\n   \n \n        uv2.x+=0.2*cos(iTime);\n        uv2.y+=0.2*sin(iTime);\n          \n    // anim between 0.9 - 1.1\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;    \n\n\t\tfloat q = 2.2+0.1*min(17.,iTime);\n    vec3 p = vec3(0,0,-q);\n    vec3 d = normalize(vec3(uv,4.));\n    mouse = iMouse.xy/iResolution.xy;\n    p.yz = r(-mouse.y+0.7*pi)*p.yz;\n    d.yz = r(-mouse.y+0.7*pi)*d.yz;\n    p.zx = r(mouse.x+0.25*pi)*p.zx;\n    d.zx = r(mouse.x+0.25*pi)*d.zx;\n    vec3 col;\n    sphere(p,d);\n    if (star) {\n       \n    } else {\n    \tcol = 1.2*surface(8.*vec2(atan(d.z,d.x)+0.01*iTime*min(iTime,17.),acos(d.y)));\n        float sh = dot(d,normalize(vec3(1,0,-1)));\n        col *= sh+0.4;\n    }\n    float l = length(uv-vec2(0.2,0))*q;\n    col = col+.19*vec3(0.5,0.7,1.)*(uv.x+0.5)*exp(-0.01*l*l*l*l)*q;\n\n\tvec3 from=vec3(1.,.5,0.5);\n\tfrom+=vec3(time*2.,time,-2.);\n\tdir+=col;\n\t\n\tmainVR(fragColor, fragCoord, from, dir);\t\n  fragColor+=vec4(col,0);\n     fragColor+= vec4( heal_star(uv2,anim) * vec3(0.35,0.2,0.15)*0.05, 1.0);\n     \n}\n","name":"Image","description":"","type":"image"}]}