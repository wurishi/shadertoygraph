{"ver":"0.1","info":{"id":"MttGWX","date":"1472503857","viewed":188,"name":"Rejmarschning","username":"DanielPettersso","description":"Playing with ray marching signed distance fields. Stealing a lot of stuff from iq..","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float RAY_PRECISION = 0.002;\nconst float MAX_RAY_LENGTH = 10.;\nconst int MAX_MARCHING_STEPS = 50;\nconst float AMBIENCE = 0.01;\n\nfloat sdPlane(vec3 p) {\n\treturn p.y+texture(iChannel0, p.xz*.5).x*-.04;\n}\n\nfloat sdSphere(in vec3 pos, in float radius) {\n    return length(pos) - radius;\n}\n\nfloat sdRoundBox( vec3 pos, vec3 size, float rounding) {\n    vec2 tp = vec2(pos.x+pos.z,pos.y+pos.z);\n    pos += texture(iChannel1, tp*.3).xyz*.02;\n\treturn length(max(abs(pos) - size, 0.0)) - rounding;\n}\n\nfloat opSub(float d1, float d2) {\n    return max(-d2, d1);\n}\n\nvec2 opU(vec2 d1, vec2 d2) {\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opBlend(vec2 a, vec2 b) {\n    float k = 0.3;\n    float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n    float xx = mix( b.x, a.x, h ) - k*h*(1.0-h);\n    float yy = (a.x<b.x) ? a.y : b.y;\n    return vec2(xx, yy);\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec2 queryDistanceFields(in vec3 pos) {\n    \n    vec3 repPos = opRep(pos, vec3(4., 0., 4.));\n    \n    vec2 thingy = vec2(\n        opSub(\n            sdRoundBox(repPos, vec3(1.), .1), \n            sdSphere(repPos, 1.4)\n        ), \n        1.\n    );\n    vec2 plane = vec2(sdPlane(pos+vec3(0., .4, 0.)), 2.);    \n    vec2 pillars = opBlend(thingy, plane);\n    \n    vec3 ballPos = vec3(cos(iTime*2.)*2.1, 0., sin(iTime*2.)*2.1);\n    vec3 ballRepPos = opRep(pos+vec3(4.,0.,0.), vec3(8., 0., 8.));\n    vec2 ball = vec2(sdSphere(ballRepPos - ballPos, .5), 3.);\n    \n    return opU(ball, pillars);\n    \n    \n}\n\nvec2 rayMarch(in vec3 rayOrigin, in vec3 rayDirection) {\n    \n    float rayLength = 0.;\n    float material = -1.;\n    \n    for (int i=0; i<MAX_MARCHING_STEPS; i++) {\n        \n        vec2 res = queryDistanceFields(rayOrigin+rayDirection*rayLength);\n        rayLength += res.x;\n\t    material = res.y;\n        \n        if (res.x < RAY_PRECISION || rayLength > MAX_RAY_LENGTH) break; \n       \n    }\n\n    if (rayLength > MAX_RAY_LENGTH) material=-1.0;\n    return vec2( rayLength, material );\n}\n\nvec3 calcNormal(in vec3 pos) {\n\tvec3 eps = vec3(0.001, 0.0, 0.0);\n\tvec3 nor = vec3(\n\t    queryDistanceFields(pos+eps.xyy).x - queryDistanceFields(pos-eps.xyy).x,\n\t    queryDistanceFields(pos+eps.yxy).x - queryDistanceFields(pos-eps.yxy).x,\n\t    queryDistanceFields(pos+eps.yyx).x - queryDistanceFields(pos-eps.yyx).x);\n\treturn normalize(nor);\n}\n\nfloat softshadow(in vec3 shadowPoint, in vec3 directionToLight, in float mint, in float tmax) {\n\tfloat res = 1.0;\n    float t = mint;\n    for(int i=0; i<64; i++) {\n\t\tfloat h = queryDistanceFields(shadowPoint + directionToLight * t).x;\n        res = min( res, 3.0*h/t );\n        t += clamp( h, 0.01, 0.05);\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 getBaseColor(in float material, in vec3 hitPosition, in vec3 reflectDirection) {\n    if (material == 1.) {\n        vec2 tp = vec2(hitPosition.x+hitPosition.z,hitPosition.y+hitPosition.z);\n    \treturn texture(iChannel1, tp*.3).xyz;\n    } else if (material == 2.) {\n        return texture(iChannel0, hitPosition.xz*.5).xyz;\n    } else if (material == 3.) {\n        return reflectDirection; \n    }\n    return vec3(1.);\n}\n\nvec3 getColor(in vec2 marchResult, in vec3 rayOrigin, in vec3 rayDirection) { \n    \n    float material = marchResult.y;\n    float rayLength = marchResult.x;\n    \n    if (material < 0.) {\n    \treturn vec3(0.);    \n    } else { \n        \n        vec3 lightDirection = normalize( vec3(cos(iTime*.3), 2., sin(iTime*.3)+3.) );\n        vec3 hitPosition = rayOrigin + rayLength * rayDirection;\n        vec3 normal = calcNormal(hitPosition);\n        vec3 ref = reflect(rayDirection, normal);\n        \n        vec3 baseColor = getBaseColor(material, hitPosition, ref);\n        float ambience = AMBIENCE + AMBIENCE * normal.y;\n        float diffuse = clamp(dot(normal, lightDirection), 0.0, 1.0);\n        \n        float shadowAmount = softshadow(hitPosition, lightDirection, 0.01, 5.);  \n        \n        diffuse *= shadowAmount;\n        diffuse += ambience;\n        diffuse *= pow((MAX_RAY_LENGTH-rayLength)/MAX_RAY_LENGTH,2.);\n        \n        return baseColor * diffuse + vec3(1.) * pow(diffuse, 10.);    \n    }\n}\n\nvec3 render(in vec3 rayOrigin, in vec3 rayDirection) { \n    vec2 res = rayMarch(rayOrigin, rayDirection);\n    return getColor(res, rayOrigin, rayDirection);\n}\n\nmat3 cameraMatrix(in vec3 ro, in vec3 ta, float cr) {\n    \n    // this math is beyond me =(\n    \n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // pixel coordinates ranging from -1 to 1\n    \n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    \n    // mouse input\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n    float spinAngle = iTime * .06 + 6.0 * mo.x;\n    \n    // camera\t\n    \n\tvec3 rayOrigin = vec3(\n        -0.5 + 3.5 * cos(spinAngle), \n        2.5 + 2.0 * mo.y, \n        0.5 + 3.5 * sin(spinAngle)\n    );\n    \n\tvec3 target = vec3(0.);    \n    float fieldOfView = 2.; // lower value = more fow\n    \n    mat3 cm = cameraMatrix(rayOrigin, target, 0.);\n    vec3 rayDirection = cm * normalize(vec3(p.xy,fieldOfView));\n    \n    // render\t\n    \n    vec3 col = render(rayOrigin, rayDirection);\n    \n    // gamma correction\n    \n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n    \n}","name":"Image","description":"","type":"image"}]}