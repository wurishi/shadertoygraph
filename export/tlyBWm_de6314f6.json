{"ver":"0.1","info":{"id":"tlyBWm","date":"1614820974","viewed":261,"name":"Cone Traced Depth of Field","username":"BondoGames","description":"Drag the mouse around to change focal distance and aperture. Cone tracer with the radius changing as the distance from the camera increases to simulate depth of field. Blatant knock off of this shader: https://www.shadertoy.com/view/4scBW8\n","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","dof","depthoffield","conetracing","conetracing","onepass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":" //cone tracing explained here: https://www.scratchapixel.com/lessons/advanced-rendering/rendering-distance-fields/basic-sphere-tracer\n \n \n //comment this out to stop rendering the point light (it's quite expensive)\n#define renderPointLight \n //uncomment this to tonemap (reduces washed out highlights but also darkens the image)\n//#define toneMap\n //camera position and camera target\nvec3 cp=vec3(0.,4.,0);vec3 ct=vec3(2.,3.5,1);\n //max march iterations, max distance (basically far clipping plane),\n //step multiplier dampens raymarch step size to improve blur\nfloat maxI=200.,maxd=50.,stepMultiplier=.5;\n //sample offset for calculating normals\nvec2 e=vec2(0.0035,0);\n //light position\nvec3 lp,ld=normalize(vec3(-1,-1,-1));\n //colour of spheres and background (darker sphere colours help to hide artifacts),light colour\n //(dont set any of the light colour components to 0, it will look stupid),vignette colour\nvec3 sphCol=vec3(0.0,0.7,1),bg=vec3(.9),lc=vec3(1.),vc=vec3(0.,0.2,.3);\n //light brightness\nfloat plb=.7,dlb=1.;\nfloat focalDist=3.,aperture=.02;\n //sphere grid scale\nfloat grid=2.;\n //ambient light level, specular coefficient (shininess)\nfloat amb=.1,specCoeff=400.;\n //camera movement vector\nvec3 vel=vec3(1.,0.,1.);\n //speed and mag of sphere wave, speed and radius of of light rotation\nfloat waveSpeed=1.2,waveMag=.4,lightSpeed=1.,lightRad=12.,\n //height of light, magnitude and sped of light's height oscilation\nlightHeight=2.,lightOscilationMag=1.,lightOscilationSpeed=.5;\nfloat vignetteStrength=.7,fogStrength=1.;\n //trade off between noise and banding with extreme blur. Must be between 0 and 1.\nfloat sampleOffset=.2; \n\n //pseudo random number from float (between 0 and 1)\nfloat hash11(float x){\n    return fract(sin(x*835.24+132.124)*123.1433);\n}\n //pseudo random number from vec2 (between 0 and 1)\nfloat hash21(vec2 x){\n    return fract(sin(x.x*845.24+x.y*554.5243+122.124)*123.143);\n}\n\n //return the co-ordinates of the nearest sphere within the grid\n //used to animate and colour them discretely\nvec2 getID(vec3 p){\n    return vec2(floor((p.x+grid/2.)/grid),floor((p.z+grid/2.)/grid));\n}\n\n //add a random offset to a given point, with a max distance r from the original point.\n //this is used to add noise to the blur, reducing banding\nvec3 rndPt(vec3 c,float r){\n    return c+normalize(vec3(hash11(c.z)-.5,hash11(c.x)-.5,hash11(c.y)-.5))*hash11(r+iTime)*r;\n}\n\n //get distance to world\nfloat map(vec3 p){\n    float planeDist=p.y+1.;//distance to ground plane\n    p+=vel*iTime;//apply camera movement\n    vec2 id=getID(p);//get discrete co-ordinates of current sphere within grid\n    p.y+=sin(id.x+id.y+iTime*waveSpeed)*waveMag;//animate sphere heights with wave\n    p.xz=mod(p.xz+grid/2.,grid)-grid/2.;//mod function creates the infinite grid\n    return min(length(p)-1.,planeDist);//return distance to nearest sphere\n}\n\n //calculate normal vector at given point\nvec3 norm(vec3 p){\n    return normalize(vec3(map(p+e.xyy),map(p+e.yxy),map(p+e.yyx))-map(p));\n}\n\n //calculate the colour at a given point\nvec3 shade(vec3 p,vec3 rd){\n     //vector from light to point\n    vec3 lightVec=p-lp;\n     //again, find discrete co-ordinates of nearest sphere\n    vec2 id = getID(p+vel*iTime);\n     //direction to light source\n    vec3 pld=normalize(lightVec);\n     //calculate normal vector at point\n    vec3 no = norm(p);\n     //multiply light based on squared distance from light source\n    float lMult=10./dot(lightVec,lightVec);\n     //standard diffuse lighting formula\n    float dif=lMult*plb*(exp(max(0.,dot(no,-pld)))-1.);//point light\n    dif+=dlb*(exp(max(0.,dot(no,-ld)))-1.);//directional light\n     //standard specular lighting formula. \n     //hash21(..)... randomizes the specular exponent (shininess) of each sphere\n    float spec=lMult*plb*pow(max(0.,dot(-pld,reflect(rd,no))),hash21(id)*specCoeff+2.);//point light//\n    spec+=dlb*pow(max(0.,dot(-ld,reflect(rd,no))),hash21(id)*specCoeff+2.);//directional light//\n     //albedo (base colour) of closest sphere\n    vec3 al=vec3(smoothstep(.3,.7,hash21(id)))*sphCol;\n     //amount of fog based on distance from camera\n    float fog=clamp(fogStrength*smoothstep(0.,maxd,length(p-cp)),0.,1.);\n     //use all the stuff above to calculate colour\n    return mix((dif*lc+amb)*al+vec3(spec),bg,fog);\n}\n\n//responsible for rendering the visible point light.\nvec3 glow(vec3 f, vec3 rd){\n    float glow;\n    if (dot(f, lp-cp)>0.){//only needed if light is in front of camera\n        vec3 lrd = normalize(lp - cp);//ray direction to point light\n        float mind = 0.04;//this doesnt need to be accurate so we can reduce accuracy for performance\n        maxd = length(cp - lp);//distance doesnt need to go beyond distance to light\n        vec3 p=cp;float td,d=100000.;\n        for(int _=0;_<100&&d>mind&&td<maxd;_++){\n            d=map(p);td+=d;p+=lrd*d;\n        }\n        if (td>maxd){//if nothing was hit between camera and light, light is visible\n            glow = .06 / length(cross(rd, lp - cp));\n        }\n    } else{//light is behind camera, just apply glow based on distance\n        glow = .06 / length(lp - cp);\n    }\n    return glow*lc;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n     //set aperture and focal distance based on mouse position\n    aperture = .1 * iMouse.x/iResolution.x;\n\tfocalDist = maxd * iMouse.y/iResolution.y;\n    lp=vec3(sin(iTime*lightSpeed)*lightRad,lightHeight+sin(iTime*lightOscilationSpeed)*lightOscilationMag,cos(iTime*lightSpeed)*lightRad);//aniamte point light\n     //pixel co-ordinates, mapped to range between -.5 and .5, then scaled by the aspect ratio in the x-axis.\n    vec2 uv = fragCoord/iResolution.xy-.5;uv.x*=iResolution.x/iResolution.y;\n     //this section calculates the ray direction of the pixel.\n    vec3 f=normalize(ct-cp);vec3 r=normalize(cross(vec3(0,1,0),f));vec3 u=normalize(cross(f,r));\n    vec3 si=cp+f+uv.x*r+uv.y*u;vec3 rd=normalize(si-cp);\n     //vertical field of view in radians, used to calculate cone radius later\n    float vfov=atan(.5);\n     //randomized\n    float startDist=hash21(uv+iTime)*map(cp);\n     //variables required for the raymarch\n     //i=total raymarch steps,d=current distance,td=total distance\n    float i,d,td=startDist;\n     //p=current point (starts at camera position) with a random offset to reduce colour banding\n    vec3 p=cp+startDist*rd;\n     //accumulated colour over all samples, alpha channel used to store amount of cone that has not yet hit the scene\n    //vec4 acc=vec4(bg,1.);\n    //acc.rgb=vec3(0.);\n    vec4 acc=vec4(0,0,0,1);\n     //radius of the cone based on width of pixel in world space\n    float rad=(2.0*tan(vfov/2.0)) /(iResolution.y);\n     //very small minimum radius to reduce aliasing at focal point\n    float minRad=4./iResolution.x;\n    for (;i<maxI;i++){ //main raymarching loop.\n        d=map(p);\n         //current radius of cone. this function makes it shrink until focal point, then grow again.\n         //max(minRad*td,...) expression prevents perfect focus to prevent aliasing.\n        float cRad=max(minRad*td,rad*td+aperture*abs(td-focalDist));\n         //add to total distance, move point\n         //step multiplier used to dampen step size, more expensive but more accurate blur.\n        td+=d*stepMultiplier;p+=rd*d*stepMultiplier;\n         //if geometry is within cone.\n        if(d<cRad){\n             //naive method of estimating the strength of the current sample .\n            float alpha = smoothstep(cRad, -cRad, d);\n             //get colour at the current position.\n             //This position is offset randomly to trade banding with noise.\n            vec3 sampleCol=shade(rndPt(p,d*sampleOffset),rd);\n             //add the sample to the cumulative colour\n             //acc.rgb=mix(acc.rgb,sampleCol,acc.a*alpha);\n            acc.rgb+=acc.a*alpha*sampleCol;\n             //reduce the remaining alpha, as some of the cone has hit the scene.\n            acc.a*=1.-alpha;\n             //if enough of the cone has hit the scene, break out of the loop.\n            if (acc.a<.001){break;}\n        }\n         //if distance is greater than the threshold distance, break out of the loop early\n        if(td>maxd){break;}//acc.a=1.;\n    }\n     //if alpha is greater than 0, the sample colour is mixed with the initial black. We therefore need \n     //to saturate the colour to remove artifacts caused by this.\n    acc.rgb*=1./max(.001,(1.-acc.a));\n     //blend between object colour and background based on alpha.\n    vec3 col=mix(acc.rgb,bg,acc.a);\n    \n    #ifdef renderPointLight\n        col += glow(f,rd);\n    #endif\n    #ifdef toneMap\n        col=1.-exp(-col);\n    #endif\n     //apply vignette. hash21(...) adds imperceptible to reduce banding.\n    col=mix(col,vc,length(uv)*vignetteStrength+hash21(uv+iTime)*.01);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}