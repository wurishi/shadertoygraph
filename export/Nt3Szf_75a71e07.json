{"ver":"0.1","info":{"id":"Nt3Szf","date":"1639476095","viewed":183,"name":"Alvy Inspired (micro)feedback3","username":"akohdr","description":"Was thinking about how to extend my own Feedback3 based on Moore neighborhood to more than 4 axis and stumbled on Victor's shader realized it's harmonic series.   \nProbably didn't hurt I had just watched CMU fireside with Dr Alvy Ray Smith.","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["fluid","feedback","harmonic"],"hasliked":0,"parentid":"XsSfWR","parentname":"[SH17A] microfeedback 3"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Andrew Wild - akohdr/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n/* Alvy Ray Smith fireside from CMU\n\n   https://www.youtube.com/watch?v=OPXkRzY26eg\n\n   - Central Dogma of computer graphics @25:22\n     \"A 3D Euclidean geometry model contains virtual camera that projects model \n      into 2D in Renaissance perspective\" \n\n   take away from video why constrain art to dogma of \n     euclidean space and newtonian physics??\n\n   this shader extends from https://www.shadertoy.com/view/XsSfWR\n   after realizing it uses harmonic series in feedback\n   \n*/\n\n//#define TRANSITION 20.  // secs between transitions\n#define TRANSITION 1200.  // frames between transitions\n\nvoid mainImage(out vec4 c, vec2 u)\n{\n//    float t = iTime; \n    float t = float(iFrame); \n    \n    // lookup from dynamic feedback loop generated in Buffer A\n    c = texelFetch(iChannel0, ivec2(u),0);\n\n    // apply cloud like colour EQ on downbeat\n    if(mod(t,2.*TRANSITION)<TRANSITION) {\n        float w = dot(c.rgb,c.b*vec3(.001,.001,.3));\n        c = vec4(max(vec3(.1,0,.8), .25+abs(sin(w+vec3(0,0,c.b)))), 1);\n    }\n    \n    // fade through black between transitions\n    c *= abs(sin(3.141/TRANSITION*t));\n    \n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by Andrew Wild - akohdr/2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// apply 2d rotation a to vector u\n#define rot(u,a) (mat2(cos(a), sin(a), -sin(a), cos(a)) * (u))\n\n// a little faster extending u\n//#define rot(u,a) (mat2(cos(a), sin(a), -sin(a), cos(a)) * (3.*u))\n\n// or more twister on smaller u\n//#define rot(u,a) (mat2(cos(3.*a), sin(3.*a), -sin(3.*a), cos(3.*a)) * (.1*u))\n\n// or don't rotate\n//#define rot(u,a) (u)\n\n// this texure lookup will include linear filter from iChannel0 settings\n#define T(x) texture(iChannel0, fract((x)/iResolution.xy))\n\n// compute a weighted parameterized harmonic feedback component\nvec4 harmonic(vec2 p, vec4 c, float t, float harmonic, float weight)\n{\n   return weight * (\n             c.gbar/4.                                 // swizzle fields\n             - .3*c                                    // weighted feedback\n             +\n//           (mod(iTime, 8.)<1. ?                      // extra shake on downbeat\n//                 T(p - c.wz*harmonic + .1*c.wy*rot(t/c.wz, t)) :\n                 T(p - c.wz*harmonic + .1*t/c.wz)\n//             )\n          );\n}\n\nvoid mainImage(out vec4 c, vec2 p)\n{   \n    float t = 1.+float(iFrame);    // ensure non-zero timebase\n    \n    if (t<1200.) c = p.xyyx/t;     // initial condition, this is the numeric ignition\n    \n    t = sin(t);                    // keeps things constrained, maintains nice 60fps\n//    t = sin(t)/t;                // sin(t)/t is actually the sinc() function\n    \n    \n//    for(float h=.6; h<4e2; h+=h)  // doubling h is essentially harmonic series\n    // h = (0.6, 1.2, 2.4, 4.8, 9.6, 19.2, 38.4, 76.8, 153.6, 307.2);\n    \n    // unwind the loop and tweak some of the harmonics\n    // there's whole world of synthesis knowledge to exploit here\n    \n    // feedback creates recursive fourier series of\n    // intermodulation products of all harmonic components\n    \n    c += harmonic(p, c, t,    .6, 1.);\n    c += harmonic(p, c, t,   1.2, 1.);\n    c += harmonic(p, c, t,   2.4, 1.);\n    c += harmonic(p, c, t,   4.8, 1.);\n    c += harmonic(p, c, t,   9.6, 1.);\n    c += harmonic(p, c, t,  19.2, 1.);\n    c += harmonic(p, c, t,  38.4, 1.);\n    c += harmonic(p, c, t,  76.8, 1.);\n    c += harmonic(p, c, t, 153.6, 1.);\n    c += harmonic(p, c, t, 307.2, 1.);\n    \n//    if(t>200.) c *= .53141;\n//    c = fract(c)*7.;\n    \n//\tc = mix(T(p+c.xy), cos(c)+sin(T(p-1.)), .03);\n\n//\tc = mix(T(p+rot(c.xy,dot(c.zw*p,c.xy/p))),      // lookup along radial axis\n\tc = mix(T(p+rot(c.xy,dot(c.zw/p,c.xy/p))),      // introduces movement bias\n            cos(c)                                  // original microfeedback 3\n            +sin(T(p-c.zw))                         // lookup another diagonal component\n            ,.03);\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}