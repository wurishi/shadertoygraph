{"ver":"0.1","info":{"id":"WsfSDl","date":"1552547964","viewed":101,"name":"Repitation Torus ","username":"kiyamada96","description":"Raymaching test","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymaching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define OCTAVES 5\n#define CS(a) vec2(cos(a),sin(a))\n\nconst float sphereSize=1.;\nconst vec3 lightDir=vec3(-0.577,0.577,0.577);\n\nconst float PI=3.14;\nconst float angle=90.0;\nconst float fov=angle*0.5*PI/180.0;\n\nvec3 trans(vec3 p)\n{\n\treturn mod(p,4.0)-2.0;\n}\n\nfloat smooth_min(float d1,float d2,float k)\n{\n\tfloat h=exp(-k*d1)+exp(-k*d2);\n    return -log(h)/k;\n}\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nfloat dist_sphere(vec3 p)\n{\n\treturn length(p)-1.0;\n}\n\nfloat dist_cube(vec3 p)\n{\n\n\treturn length(max(abs(p)-vec3(2.5,0.1,0.5),0.0))-0.1;\n}\n\nfloat dist_tolus(vec3 p,vec2 r)\n{   \n    vec2 d= vec2(length(p.xy) - r.x, p.z);\n    return length(d) - r.y;\n}\n\nfloat dist_func_floor(vec3 p)\n{\n\treturn dot(p,vec3(0.0,1.0,0.0))+1.0;\n}\n\nfloat dist_cylinder(vec3 p,vec2 r)\n{\n\tvec2 d=abs(vec2(length(p.xy),p.z))-r;\n    return min(max(d.x,d.y),0.0)+length(max(d,0.0))-0.1;\n\n}\nfloat dist_func(vec3 p)\n{\n    float rot = 60.0*3.14 / 180.0;\n\trot *= iTime;\n\tvec3 q = rotate(p,rot,vec3(1,1,1));\n    \n    q.x*=sin(iTime*0.5);\n    vec3 e=trans(q);\n   \n    float d2=dist_cube(e);\n    float d1=dist_tolus(e,vec2(1.5,0.25));\n    float d3=dist_cylinder(e,vec2(0.75,0.25));\n    \n    return smooth_min(smooth_min(d1,d2,16.0),d3,16.0) ;\n}\n\nvec3 getNormal(vec3 p)\n{\n\tfloat d=0.01;\n\treturn normalize(vec3(\n        dist_func(p+vec3(d,0.0,0.0))-dist_func(p+vec3(-d,0.0,0.0)),\n        dist_func(p+vec3(0.0,d,0.0))-dist_func(p+vec3(0.0,-d,0.0)),\n        dist_func(p+vec3(0.0,0.0,d))-dist_func(p+vec3(0,0.0,-d))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p=(fragCoord.xy*2.0-iResolution.xy)/min(iResolution.x,iResolution.y);\n    \n    vec3 cPos=vec3(0.0,0.0,5.0);\n    vec3 cDir=vec3(0.,0.,-1);\n    vec3 cUp=vec3(0.,1.0,0.);\n    vec3 cSide=cross(cDir,cUp);\n    float targetDepth=1.0;\n    \n  \tvec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n    \n    float dist=0.0;\n    float rlen=0.0;\n   \tvec3 rPos=cPos;\n    \n    for(int i=0;i<128;i++)\n    {\n    \tdist=dist_func(rPos);\n        rlen+=dist;\n        rPos=cPos+ray*rlen;\n    }\n   \t\n    vec3 color;\n    if(abs(dist)<0.001)\n    {\n   \t\tvec3 nor=getNormal(rPos);\n        float diff=clamp(dot(lightDir,nor),0.1,1.0);\n        color=vec3(1.0,1.0,1.0)*nor;\n    }\n    else\n    {\n    \tcolor=vec3(0.0);\n    }\n    fragColor=vec4(color,1.0);\n    \n}","name":"Image","description":"","type":"image"}]}