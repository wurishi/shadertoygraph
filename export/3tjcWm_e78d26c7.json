{"ver":"0.1","info":{"id":"3tjcWm","date":"1594578965","viewed":178,"name":"Ray Tracer Lesson 5 - Refraction","username":"omegasbk","description":"Shader made for lesson two of Darko's Gamedev Cookbook series on youtube.\nChannel: https://www.youtube.com/channel/UCEB2BQkJs_9tH6DE0dM5kqA","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","raymarching","refraction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Darko (omegasbk) \n//\n// Darko's Gamedev Cookbok Youtube serial\n// https://www.youtube.com/channel/UCEB2BQkJs_9tH6DE0dM5kqA\n//\n// Lesson 5 - Refraction\n\nstruct Camera \n{\n    vec3 position;\n    vec3 direction;\n    float canvasPosition; \n} camera;\n\nstruct Light\n{\n\tvec3 direction;    \n} light;\n\nstruct Material \n{\n    float diffuse;\n    float specular;\n    float shininess;\n    float ambience;\n} material;\n\nstruct Sphere\n{\n    vec3 color;\n    vec3 position;\n    float radius;     \n    Material material;\n} sphere;\n\nvoid setupScene()\n{\n    camera.position = vec3(0., 0., 3.5);\n    camera.direction = vec3(0., 0., -1.);\n    camera.canvasPosition = 2.7;\n    \n    light.direction = normalize(vec3(0., -1., -0.78));\n    \n    material.ambience = 0.2;\n    material.diffuse = 0.7;\n    material.specular = 1.0;\n    material.shininess = 10.0;    \n            \n    sphere.position = vec3(0., 0., 0.);\n    sphere.radius = 0.7;\n    sphere.color = vec3(0.9, 0.2, 0.3);\n    sphere.material = material;\n}\n\nbool solveQuadratic(float a, float b, float c, out float t0, out float t1)\n{\n    float disc = b * b - 4. * a * c;\n    \n    if (disc < 0.)\n    {\n        return false;\n    } \n    \n    if (disc == 0.)\n    {\n        t0 = t1 = -b / (2. * a);\n        return true;\n    }\n    \n    t0 = (-b + sqrt(disc)) / (2. * a);\n    t1 = (-b - sqrt(disc)) / (2. * a);\n    return true;    \n}\n\nbool intersect(vec3 origin, vec3 direction, out vec3 surfaceNormal, out vec3 Phit)\n{\n    vec3 L = origin - sphere.position;\n    \n    float a = dot(direction, direction);\n    float b = 2. * dot(direction, L);\n    float c = dot(L, L) - pow(sphere.radius, 2.);\n    \n    float t0;\n    float t1;\n    \n    if (solveQuadratic(a, b, c, t0, t1))\n    {\n        float t = t0;\n        if (t1 < t0)\n        {\n            t = t1;\n        }\n        \n        Phit = origin + t * direction;\n        surfaceNormal = normalize(Phit - sphere.position);\n        \n        return true;\n    }  \n     \n    return false;\n}\n\n\nint mode = 3;\n\nvec3 getPhongColor(vec3 direction, vec3 lightDirection, vec3 surfaceNormal, vec3 objectColor)\n{\n\tfloat coeff = -dot(light.direction, surfaceNormal);                          \n    \n    vec3 ambient = sphere.material.ambience * objectColor;\n    vec3 diffuse = sphere.material.diffuse * max(coeff, 0.) * objectColor;\n        \n    float shininess = pow(max(-dot(direction, reflect(light.direction, surfaceNormal)), 0.), sphere.material.shininess);\n    vec3 specular = sphere.material.specular * shininess * objectColor;\n        \n    return ambient + diffuse + specular;\n}\n\nvec3 getReflectedColor(vec3 direction, vec3 surfaceNormal)\n{\n    vec3 reflectedRay = reflect(direction, surfaceNormal);\n    vec3 reflectedColor = texture(iChannel0, reflectedRay).rgb;\n    return mix(sphere.color, reflectedColor, sphere.material.specular);\n}\n\nvec3 getRefractedRay(vec3 N, vec3 I)\n{\n   float eta1 = 1.;\n    float eta2 = 1.9;\n    float eta = eta1 / eta2;\n    \n    float c1 = dot(N, I);\n    if (c1 < 0.)\n    {\n        c1 = -c1;\n    }\n    else\n    {\n        N = -N;\n        eta = 1. / eta;\n    }    \n    \n   \tfloat theta = acos(c1);\n    \n    float k = 1. - eta * eta * sin(theta) * sin(theta);\n    if (k < 0.) \n        return vec3(0.);\n    \n    float c2 = sqrt(k);\n    \n    vec3 T = eta * I + N * (eta * c1 - c2);\n    return T;    \n   \n}\n\nvec3 rayTrace(vec3 direction)\n{\n    vec3 surfaceNormal;\n    vec3 Phit;\n    \n    if (intersect(camera.position, direction, surfaceNormal, Phit))\n    {        \n        switch(mode)\n        {\n            case 0: // Phong\n            {\n\t\t\t\treturn getPhongColor(direction, light.direction, surfaceNormal, sphere.color);\n            }\n            case 1: // Reflections \n            {                          \n               \treturn getReflectedColor(direction, surfaceNormal);\n            }\n            case 2: // Reflections + Phong\n            {\n                vec3 reflectedColor = getReflectedColor(direction, surfaceNormal);                \n                return getPhongColor(direction, light.direction, surfaceNormal, reflectedColor);\n            }\n            case 3: // Refraction\n            {\n                vec3 refractedRay = getRefractedRay(surfaceNormal, direction);\n                \n                if (intersect(Phit, normalize(refractedRay), surfaceNormal, Phit))\n                {\n                    refractedRay = getRefractedRay(surfaceNormal, normalize(refractedRay)); \n                }                \n                \n                return texture(iChannel0, normalize(refractedRay)).rgb;\n            }\n        }     \n    }\n    \n    return texture(iChannel0, direction).rgb;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{        \n        setupScene();\n    \n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= (iResolution.x / iResolution.y); \n        \n    camera.position.x = cos(iTime) * 4.;\n    camera.position.z = sin(iTime) * 4.;\n    \n    // Camera movement\n    float rotation = iTime;\n    camera.position = vec3(cos(rotation), 0., sin(rotation)) * camera.canvasPosition;\n    camera.direction = normalize(vec3(0.) - camera.position);\n    vec3 right = normalize(cross(camera.direction, vec3(0., 1., 0.)));\n    vec3 up = cross(right, camera.direction);\n   \tvec3 dir =  normalize(uv.x * right + uv.y * up + camera.direction);\n     \n    vec3 col = rayTrace(dir);\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}