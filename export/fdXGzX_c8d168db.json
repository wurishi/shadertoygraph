{"ver":"0.1","info":{"id":"fdXGzX","date":"1616358849","viewed":169,"name":"Phase Storm","username":"cwalther","description":"Aligning local plane waves to a direction field by random propagation.\n\nPlay with the parameters in the Buffer A code!","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["a"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Check the Buffer A shader for the interesting stuff.\n// This is just a conversion from the complex numbers in the red-green plane\n// of Buffer A to a somewhat prettier color map.\n\nconst float r22 = 0.5*sqrt(2.0);\n\n#if 1\nconst mat3 colorTransform = mat3(\n//out: r, g, b\n    1.0, 0.5, 0.0, //in: re\n    0.0, 0.5, 1.0, //in: im\n    0.0, 0.0, 0.0  //in: 1\n)*mat3( // 2. scale and translate origin to midpoint\n    0.5, 0.0, 0.0,\n    0.0, 0.5, 0.0,\n    0.5, 0.5, 1.0\n)*mat3( // 1. rotate 45 degrees so 1 -> white, -1 -> black, i -> blue, -i -> orange\n    r22, r22, 0.0,\n    -r22, r22, 0.0,\n    0.0, 0.0, 1.0\n);\n#else\nconst mat3 colorTransform = mat3(\n//out: r, g, b\n    1.0, 0.0, 0.0, //in: re\n    0.0, 1.0, 0.0, //in: im\n    0.0, 0.0, 0.0  //in: 1\n);\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ri = texture(iChannel0, fragCoord.xy/iResolution.xy).rg;\n    fragColor = vec4(colorTransform*vec3(ri, 1.0), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*  (c) Copyright 2021 by Christian Walther.\n\n    This work is licensed under a Creative Commons\n    Attribution-ShareAlike 4.0 International (CC BY-SA 4.0) License\n    (http://creativecommons.org/licenses/by-sa/4.0/).\n*/\n\n/*\nThe algorithm locally tries to make plane waves of a constant wavelength,\naligned in direction to an externally imposed non-plane vector field. The phase\nat each pixel is determined by extending the local plane wave from random\nneighbor pixels. There is no global solution, resulting in lots of\ndiscontinuities between domains of competing local solutions. Nevertheless,\npatterns eventually emerge, sometimes resembling the guiding vector field,\nsometimes not.\n*/\n\n\n//// Parameters to play with:\n\n// Wave number = 2pi / wavelength in pixels.\nconst float wavenum = 6.283/100.0;\n\n// The noise needs to move, otherwise the system quickly falls into a steady state.\n// This is its overall speed in pixels per second. Interesting values are around\n// 1.0 - 30.0, larger values make macroscopic evolution very slow.\nconst float windspeed = 3.0;\n\n// To reduce periodic artifacts, four differently scaled copies of the noise\n// texture are used, two for the x and two for the y displacement, moving in\n// different directions. These are the directions and fine speed adjustments.\nconst vec2 winddirx1 = vec2(-0.2, 0.90);\nconst vec2 winddirx2 = vec2(0.1, -0.95);\nconst vec2 winddiry1 = vec2(1.00, 0.4);\nconst vec2 winddiry2 = vec2(-1.05, -0.1);\n\n// Initialization: Radius in pixels of the circle of which the inside will be\n// initialized to 1 (white), the outside to empty (gray). Make it small to grow\n// from a small seed, or larger than the screen to have all pixels compete at\n// once.\nconst float seedradius = 2.0;\n\n// The field of wave vectors the local plane waves try to align to, in this case\n// tangential around a point in the left third of the image, corresponding to\n// radial wavefronts, and with a constant magnitude given above.\nvec2 wavevectorfield(vec2 fragCoord) {\n    const mat2 rot90 = mat2(0.0, 1.0, -1.0, 0.0);\n    return wavenum*normalize(rot90*(fragCoord - vec2(0.333, 0.5)*iResolution.xy));\n}\n\n\n//// Implementatin from here on:\n\n// some complex math\nvec2 expi(float p) {\n    return vec2(cos(p), sin(p));\n}\nvec2 cmult(vec2 a, vec2 b) {\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // random displacement to source point\n    vec2 d = vec2(\n        1.4*(\n            texture(iChannel1, (fragCoord.xy - windspeed*winddirx1*iTime)/256.0).x - 0.5\n            + texture(iChannel1, (fragCoord.xy - windspeed*winddirx2*iTime)/256.0/1.4).x - 0.5\n        ),\n        1.4*(\n            texture(iChannel1, (fragCoord.xy - windspeed*winddiry1*iTime)/256.0/1.2).x - 0.5\n            + texture(iChannel1, (fragCoord.xy - windspeed*winddiry2*iTime)/256.0/1.6).x - 0.5\n        )\n    );\n    // look up phase at source point\n    vec2 srcP = texture(iChannel0, (fragCoord.xy + d)/iResolution.xy).rg;\n    // is there anything there?\n    if (dot(srcP, srcP) > 0.1*0.1) {\n        // evaluate wave vector\n        vec2 k = wavevectorfield(fragCoord);\n        // new phase = old phase propagated along wave\n        vec2 newP = normalize(cmult(srcP, expi(dot(k, d))));\n        // output\n        fragColor = vec4(newP, 0.0, 1.0);\n    }\n    else {\n        // nothing there - was there anything here before?\n        vec2 oldP = texture(iChannel0, fragCoord.xy/iResolution.xy).rg;\n        if (oldP != vec2(0.0, 0.0)) {\n            // yep - preserve it\n            fragColor = vec4(oldP, 0.0, 1.0);\n        }\n        else {\n            // nope - initialize to phase 0 outside or phase 1 inside circle\n            fragColor = vec4(1.0 - step(seedradius, length(fragCoord - 0.5*iResolution.xy)), 0.0, 0.0, 1.0);\n        }\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}