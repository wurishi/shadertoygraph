{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"/*\nby Uğur Güney. March 8, 2014. \n\nHi! I started learning GLSL a month ago. The speedup gained by using\nGPU to draw real-time graphics amazed me. If you want to learn\nhow to write shaders, this tutorial written by a beginner can be\na starting place for you.\n\nPlease fix my coding errors and grammar errors. :-)\n*/\n\n// choose the tutorial by changing the number and compiling the shader again\n#define TUTORIAL 0\n\n/* TUTORIAL LIST\n 1 VOID. BLANK SCREEN.\n 2 SOLID COLOR\n 3 GLSL VECTORS\n 4 RGB COLOR MODEL AND COMPONENTS OF VECTORS\n 5 THE COORDINATE SYSTEM\n 6 RESOLUTION, THE FRAME SIZE\n 7 COORDINATE TRANSFORMATION\n 8 HORIZONTAL AND VERTICAL LINES\n 9 VISUALISING THE COORDINATE SYSTEM\n10 MOVING THE COORDINATE CENTER TO THE CENTER OF THE FRAME\n11 MAKING THE ASPECT RATIO OF THE COORDINATE SYSTEM 1.0\n12 DISK\n13 FUNCTIONS\n14 BUILT-IN FUNCTIONS: STEP\n15 BUILT-IN FUNCTIONS: CLAMP\n16 BUILT-IN FUNCTIONS: SMOOTHSTEP\n17 BUILT-IN FUNCTIONS: MIX\n18 ANTI-ALIASING WITH SMOOTHSTEP\n19 FUNCTION PLOTTING\n20 COLOR ADDITION AND SUBSTRACTION\n21 COORDINATE TRANSFORMATIONS: ROTATION\n22 COORDINATE TRANSFORMATIONS: SCALING\n23 SUCCESSIVE COORDINATE TRANSFORMATIONS\n24 TIME, MOTION AND ANIMATION\n25 PLASMA EFFECT\n26 TEXTURES\n27 MOUSE INPUT\n28 RANDOMNESS\n*/\n\n#define PI 3.14159265359\n#define TWOPI 6.28318530718\n\n#if TUTORIAL == 1\n// VOID. BLANK SCREEN.\n//\n// \"main\" function is called several times per second to produce\n// the shader effect.\n// The system aims to produces a speed of 60 frames per second (FPS).\n// But if the GLSL script is computationally hard, then the frame\n// rate drops. (You can read the frame rate at the info bar below\n// the screen.\n//\n// Because we are not doing anything in the function\n// this shader will produce a black screen.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n}\n\n#elif TUTORIAL == 2\n// SOLID COLOR\n//\n// \"fragColor\" is the output variable of the shader.\n// Its value determines the image on the screen.\n// This shaders sets its value to be the yellow color.\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(1.0, 1.0, 0.0 ,1.0);\n}\n\n\n#elif TUTORIAL == 3\n// GLSL VECTORS\n//\n// fragColor\" should be assigned a vec4 object, which is made \n// of four numbers between 0 and 1.\n// First three numbers determines the color, and fourth number\n// determines the opacity.\n// (For now changing the transparancy value will have no effect)\n// A \"vec4\" data object can be constructed by giving 4 \"float\" arguments,\n// or one \"vec3\" and one \"float\" argument.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Here we are seperating the color and transparency parts\n\t// of the vec4 that represents the pixels.\n\tvec3 color = vec3(0.0, 1.0, 1.0);\n\tfloat alpha = 1.0;\n\t\n\tvec4 pixel = vec4(color, alpha);\n\tfragColor = pixel;\n}\n\n#elif TUTORIAL == 4\n// RGB COLOR MODEL AND COMPONENTS OF VECTORS\n//\n// After initialized, the components of vectors can be reached using\n// the dot \".\" notation.\n//\n// RGB: http://en.wikipedia.org/wiki/RGB_color_model\n// A color is represented by three numbers (here in the range [0.0, 1.0])\n// The model assumes the addition of pure red, green and blue lights\n// of given intensities.\n//\n// If you lack design skills like me, and having hard time\n// in choosing nice looking, coherent set of colors \n// you can use one of these websites to choose color palettes, where\n// you can browse different sets of colors \n// https://kuler.adobe.com/create/color-wheel/\n// http://www.colourlovers.com/palettes\n// http://www.colourlovers.com/colors\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// play with these numbers:\n\tfloat redAmount = 0.6; // amount of redness\n\tfloat greenAmount = 0.2; // amount of greenness\n\tfloat blueAmount = 0.9; // amount of blueness\n\t\n\tvec3 color = vec3(0.0); \n\t// Here we only input a single argument. It is a third way of\n\t// contructing vectors.\n\t// \"vec3(x)\" is equivalent to vec3(x, x, x);\n\t// This vector is initialized as\n\t// color.x = 0.0, color.y = 0.0; color.z = 0.0;\n\tcolor.x = redAmount;\n\tcolor.y = greenAmount;\n\tcolor.z = blueAmount;\n\t\n\tfloat alpha = 1.0;\n\tvec4 pixel = vec4(color, alpha);\t\n\tfragColor = pixel;\n}\n\n\n#elif TUTORIAL == 5\n// THE COORDINATE SYSTEM\n//\n// \"fragCoord\", \"fragment coordinate\" is an input variable.\n//\n// It tells us at which pixel we are on the screen. The coordinate center\n// is the left bottom corner, and coordinate values increases towards\n// right and upwards.\n//\n// The main function is run for each and every pixel on the screen. At\n// each call the \"gl_FracCoord\" has the coordinates of the corresponding\n// pixel.\n//\n// GPUs have many cores, so, the function calls for different pixels\n// can be calculated in parallel at the same time.\n// This allows higher speeds than the calculation of pixel colors one\n// by one in series on the CPU. But, it puts an important constraint too:\n// The value of a pixel cannot depend on the value of another pixel. (the\n// calculations are done in parallel and it is impossible to know which\n// one will finish before the other one)\n// The outcome of a pixel can only depend on the pixel coordinate (and\n// some other input variables.)\n// This is the most important difference of shader programming. We'll\n// come to this point again and again\n//\n// Let's draw something that is not a solid color.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// choose two colors\n\tvec3 color1 = vec3(0.886, 0.576, 0.898);\n\tvec3 color2 = vec3(0.537, 0.741, 0.408);\n\tvec3 pixel;\n\t\n\t// if the x coordinate is greater than 100 then plot color1\n\t// else plot color2\n\tfloat widthOfStrip = 100.0;\n\tif( fragCoord.x > widthOfStrip ) {\n\t\tpixel = color2;\n\t} else {\n\t\tpixel = color1;\n\t}\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 6\n// RESOLUTION, THE FRAME SIZE\n//\n// If you resize your browser, or go to fullscreen mode and come back\n// you'll see that the ratio of the width of the first color to the\n// second color changes with screen size.\n// It is because we set the width of the strip in absolute number of\n// pixels, rather than as a proportion of the screen width and height.\n//\n// Say we want to paint the left and right halves with different colors.\n// Without knowing the number of pixels horizontally, we cannot prepare\n// a shader that works on all frame sizes.\n// \n// How can we learn the screen size (the width and height) in terms of \n// the number of pixel. It is given us in the variable \"iResolution\".\n// \"iResolution.x\" is the width of the frame, and\n// \"iResolution.y\" is the height of the frame\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 color1 = vec3(0.741, 0.635, 0.471);\n\tvec3 color2 = vec3(0.192, 0.329, 0.439);\n\tvec3 pixel;\n\t\n\t// sugar syntax for \"if\" conditional. It says\n\t// \"if the x coordinate of a pixel is greater than the half of\n\t// the width of the screen, then use color1, otherwise use\n\t// color2.\"\n\tpixel = ( fragCoord.x > iResolution.x / 2.0 ) ? color1 : color2;\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 7\n// COORDINATE TRANSFORMATION\n// \n// Instead of working on screen coordinates, using our own coordinate\n// system is more convenient most of the time.\n//\n// Here we will make and use a new coordinate system \"r\", instead of\n// the absolute screen coordinates \"fragCoord\". In \"r\"\n// the x and y coordinates will go from 0 to 1. For x, 0 is the left\n// side and 1 is the right side. For y, 0 is the bottom side, and 1 is\n// the upper side.\n//\n// Using \"r\" let's divide the screen into 3 parts.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = vec2(fragCoord.x / iResolution.x,\n\t\t\t\t  fragCoord.y / iResolution.y);\n\t// r is a vec2. Its first component is pixel x-coordinate divided by\n\t// the frame width. And second component is the pixel y-coordinate\n\t// divided by the frame height.\n\t//\n\t// For example, on my laptop, the full screen frame size is\n\t// 1440 x 900. Therefore iResolution is (1440.0, 900.0).\n\t// The main function should be run 1440*900=1296000 times to\n\t// generate a frame.\n\t// fragCoord.x will have values between 0 and 1439, and\n\t// fragCoord.y will have values between 0 and 899, whereas\n\t// r.x and r.y will have values between [0,1].\n\t\n\tvec3 color1 = vec3(0.841, 0.582, 0.594);\n\tvec3 color2 = vec3(0.884, 0.850, 0.648);\n\tvec3 color3 = vec3(0.348, 0.555, 0.641);\n\tvec3 pixel;\n\t\n\t// sugar syntax for \"if\" conditional. It says\n\t// \"if the x coordinate of a pixel is greater than the half of\n\t// the width of the screen, then use color1, otherwise use\n\t// color2.\"\n\tif( r.x < 1.0/3.0) {\n\t\tpixel = color1;\n\t} else if( r.x < 2.0/3.0 ) {\n\t\tpixel = color2;\n\t} else {\n\t\tpixel = color3;\n\t}\n\t\t\t\n\t// pixel = ( r.x < 1.0/3.0 ) ? color1 : (r.x<2.0/3.0) ? color2: color3;\n\t// same code, single line.\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 8\n// HORIZONTAL AND VERTICAL LINES\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = vec2( fragCoord.xy / iResolution.xy );\n\t// shorter version of the same coordinate transformation.\n\t// For example \"aVector.xy\" is a new vec2 made of the first two \n\t// components of \"aVector\".\n\t// And, when division operator is applied between vectors,\n\t// each component of the first vector is divided by the corresponding\n\t// component of the second vector.\n\t// So, first line of this tutorial is the same as the first line\n\t// of the previous tutorial.\n\t\n\tvec3 backgroundColor = vec3(1.0);\n\tvec3 color1 = vec3(0.216, 0.471, 0.698);\n\tvec3 color2 = vec3(1.00, 0.329, 0.298);\n\tvec3 color3 = vec3(0.867, 0.910, 0.247);\n\n\t// start by setting the background color. If pixel's value\n\t// is not overwritten later, this color will be displayed.\n\tvec3 pixel = backgroundColor;\n\t\n\t// if the current pixel's x coordinate is between these values,\n\t// then put color 1.\n\t// The difference between 0.55 and 0.54 determines\n\t// the with of the line.\n\tfloat leftCoord = 0.54;\n\tfloat rightCoord = 0.55;\n\tif( r.x < rightCoord && r.x > leftCoord ) pixel = color1;\n\t\n\t// a different way of expressing a vertical line\n    // in terms of its x-coordinate and its thickness:\n\tfloat lineCoordinate = 0.4;\n\tfloat lineThickness = 0.003;\n\tif(abs(r.x - lineCoordinate) < lineThickness) pixel = color2;\n\t\n\t// a horizontal line\n\tif(abs(r.y - 0.6)<0.01) pixel = color3;\n\t\n\t// see how the third line goes over the first two lines.\n\t// because it is the last one that sets the value of the \"pixel\".\n\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 9\n// VISUALISING THE COORDINATE SYSTEM\n//\n// Let's use a for loop and horizontal and vertical lines to draw\n// a grid of the coordinate center\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = vec2( fragCoord.xy / iResolution.xy );\n\t\n\tvec3 backgroundColor = vec3(1.0);\n\tvec3 axesColor = vec3(0.0, 0.0, 1.0);\n\tvec3 gridColor = vec3(0.5);\n\n\t// start by setting the background color. If pixel's value\n\t// is not overwritten later, this color will be displayed.\n\tvec3 pixel = backgroundColor;\n\t\n\t// Draw the grid lines\n\t// we used \"const\" because loop variables can only be manipulated\n\t// by constant expressions.\n\tconst float tickWidth = 0.1;\n\tfor(float i=0.0; i<1.0; i+=tickWidth) {\n\t\t// \"i\" is the line coordinate.\n\t\tif(abs(r.x - i)<0.002) pixel = gridColor;\n\t\tif(abs(r.y - i)<0.002) pixel = gridColor;\n\t}\n\t// Draw the axes\n\tif( abs(r.x)<0.005 ) pixel = axesColor;\n\tif( abs(r.y)<0.006 ) pixel = axesColor;\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 10\n// MOVING THE COORDINATE CENTER TO THE CENTER OF THE FRAME\n//\n// Instead of mapping [0, iResolution.x]x[0, iResolution.y] region to\n// [0,1]x[0,1], lets map it to [-1,1]x[-1,1]. This way the coordinate\n// (0,0) will not be at the lower left corner of the screen, but in the\n// middle of the screen.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = vec2( fragCoord.xy - 0.5*iResolution.xy );\n\t// [0, iResolution.x] -> [-0.5*iResolution.x, 0.5*iResolution.x]\n\t// [0, iResolution.y] -> [-0.5*iResolution.y, 0.5*iResolution.y]\n\tr = 2.0 * r.xy / iResolution.xy;\n\t// [-0.5*iResolution.x, 0.5*iResolution.x] -> [-1.0, 1.0]\n\t\n\tvec3 backgroundColor = vec3(1.0);\n\tvec3 axesColor = vec3(0.0, 0.0, 1.0);\n\tvec3 gridColor = vec3(0.5);\n\n\t// start by setting the background color. If pixel's value\n\t// is not overwritten later, this color will be displayed.\n\tvec3 pixel = backgroundColor;\n\t\n\t// Draw the grid lines\n\t// This time instead of going over a loop for every pixel\n    // we'll use mod operation to achieve the same result\n    // with a single calculation (thanks to mikatalk)\n\tconst float tickWidth = 0.1;\n\tif( mod(r.x, tickWidth) < 0.008 ) pixel = gridColor;\n    if( mod(r.y, tickWidth) < 0.008 ) pixel = gridColor;\n    // Draw the axes\n\tif( abs(r.x)<0.006 ) pixel = axesColor;\n\tif( abs(r.y)<0.007 ) pixel = axesColor;\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n#elif TUTORIAL == 11\n// MAKING THE ASPECT RATIO OF THE COORDINATE SYSTEM 1.0\n//\n// As we have seen from the previous examples, we do get rectangles\n// instead of squares when we plot the coordinate systems.\n// It is because, we assigned same numerical interval, [0,1] to different\n// physical distances. Actually the width of the frame is bigger \n// than of its height.\n// So, to keep the aspect ratio, we should not map the actual distances\n// [0, iResolution.x] and [0, iResolution.y] to the same interval.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = vec2( fragCoord.xy - 0.5*iResolution.xy );\n\tr = 2.0 * r.xy / iResolution.y;\n\t// instead of dividing r.x to iResolution.x and r.y to iResolution.y\n\t// divide both of them to iResolution.y.\n\t// This way r.y will be in [-1.0, 1.0]\n\t// and r.x will depend on the frame size. I guess the non-full screen\n\t// mode rx will be in [-1.78, 1.78], and in full screen mode\n\t// for my laptop, it will be in [-1.6, 1.6] (1440./900.=1.6)\n\t\n\tvec3 backgroundColor = vec3(1.0);\n\tvec3 axesColor = vec3(0.0, 0.0, 1.0);\n\tvec3 gridColor = vec3(0.5);\n\n\tvec3 pixel = backgroundColor;\n\t\n\t// Draw grid lines\n\tconst float tickWidth = 0.1;\n\tfor(float i=-2.0; i<2.0; i+=tickWidth) {\n\t\t// \"i\" is the line coordinate.\n\t\tif(abs(r.x - i)<0.004) pixel = gridColor;\n\t\tif(abs(r.y - i)<0.004) pixel = gridColor;\n\t}\n\t// Draw the axes\n\tif( abs(r.x)<0.006 ) pixel = axesColor;\n\tif( abs(r.y)<0.007 ) pixel = axesColor;\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n#elif TUTORIAL == 12\n// DISK\n//\n// Let's draw disks\n//\n// So, in GLSL we don't give a command of \"draw this disk here with that\n// color\". Instead we use an indirect command such as \"if the pixel \n// coordinate is inside this disk, put that color for the pixel\"\n// The indirect commands are a bit counter intuitive until you\n// get used to that way of thinking.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\t\n\tvec3 bgCol = vec3(0.3);\n\tvec3 colBlue = vec3(0.216, 0.471, 0.698);\n\tvec3 colRed = vec3(1.00, 0.329, 0.298);\n\tvec3 colYellow = vec3(0.867, 0.910, 0.247);\n\n\tvec3 pixel = bgCol;\n\t\n\t// To draw a shape we should know the analytic geometrical\n\t// expression of that shape.\n\t// A circle is the set of points that has the same distance from\n\t// it its center. The distance is called radius.\n\t// The distance from the coordinate center is sqrt(x*x + y*y)\n\t// Fix the distance as the radius will give the formula for\n\t// a circle at the coordinate center\n\t// sqrt(x*x + y*y) = radius\n\t// The points inside the circle, the disk, is given as\n\t// sqrt(x*x + y*y) < radius\n\t// Squaring both sides will give\n\t// x*x + y*y < radius*radius\n\tfloat radius = 0.8;\n\tif( r.x*r.x + r.y*r.y < radius*radius ) {\n\t\tpixel = colBlue;\n\t}\n\t\n\t// There is a shorthand expression for sqrt(v.x*v.x + v.y*v.y)\n\t// of a given vector \"v\", which is \"length(v)\"\n\tif( length(r) < 0.3) {\n\t\tpixel = colYellow;\n\t}\n\t\n\t// draw a disk of which center is not at (0,0).\n\t// Say the center is at c: (c.x, c.y). \n\t// The distance of any point r: (r.x, r.y) to c is \n\t// sqrt((r.x-c.x)^2+(r.y-c.y)^2)\n\t// define a distance vector d: (r.x - c.x, r.y - c.y)\n\t// in GLSL d can be calculated \"d = r - c\".\n\t// Just as in division, substraction of two vectors is done\n\t// component by component.\n\t// Then, length(d) means sqrt(d.x^2+d.y^2)\n\t// which is the distance formula we are looking for.\n\tvec2 center = vec2(0.9, -0.4);\n\tvec2 d = r - center;\n\tif( length(d) < 0.6) {\n\t\tpixel = colRed;\n\t}\n\t// This shifting of the center of the shape works for any\n\t// kind of shape. If you have a formula in terms of r\n\t// f(r) = 0, then f(r-c)=0 expresses the same geometric shape\n\t// but its coordinate is shifted by c.\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n// Note how the latest disk is shown and previous ones are left\n// behind it. It is because the last if condition changes the pixel\n// value at the end.\n// If the coordinates of pixel fits multiple if conditions, the last\n// manipulation will remain and fragColor is set to that one.\n\n\n#elif TUTORIAL == 13\n// FUNCTIONS\n//\n// Functions are great for code reuse. Let's put the code for disks\n// into a function and use the function for drawing.\n// There are so many different ways of writing a function to draw a shape.\n//\n// Here we have a void function that does not return anything. Instead,\n// \"pixel\" is taken as an \"inout\" expression. \"inout\" is a unique\n// keyword of GLSL.\n// By default all arguments are \"in\" arguments. Which\n// means, the value of the variable is given to the function scope\n// from the scope the function is called. \n// An \"out\" variable gives the value of the variable from the function\n// to the scope in which the function is called.\n// An \"inout\" argument does both. First the value of the variable is\n// sent to the function as its argument. Then, that variable is\n// processed inside the function. When the function ends, the value\n// of the variable is updated where the function is called.\n//\n// Here, the \"pixel\" variable that is initialized with the background\n// color in the \"main\" function. Then, \"pixel\" is given to the \"disk\"\n// function. When the if condition is satisfied the value of the \"pixel\"\n// is changed with the \"color\" argument. If it is not satified, the\n// \"pixel\" is left untouched and keeps it previous value (which was the\n// \"bgColor\".\nvoid disk(vec2 r, vec2 center, float radius, vec3 color, inout vec3 pixel) {\n\tif( length(r-center) < radius) {\n\t\tpixel = color;\n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\t\n\tvec3 bgCol = vec3(0.3);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\n\tvec3 pixel = bgCol;\n\t\n\tdisk(r, vec2(0.1, 0.3), 0.5, col3, pixel);\n\tdisk(r, vec2(-0.8, -0.6), 1.5, col1, pixel);\n\tdisk(r, vec2(0.8, 0.0), .15, col2, pixel);\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n// As you see, the borders of the disks have \"jagged\" curves, where\n// individual pixels can be seen. This is called \"aliasing\". It occurs\n// because pixels have finite size and we want to draw a continuous\n// shape on a discontinuous grid.\n// There is a method to reduce the aliasing. It is done by mixing the\n// inside color and outside colors at the border. To achieve this\n// we have to learn some built-in functions.\n\n// And, again, note the order of disk function calls and how they are\n// drawn on top of each other. Each disk function manipulates\n// the pixel variable. If a pixel is manipulated by multiple disk\n// functions, the value of the last one is sent to fragColor.\n\n// In this case, the previous values are completely overwritten.\n// The final value only depends to the last function that manipulated\n// the pixel. There are no mixtures between layers.\n\n\n#elif TUTORIAL == 14\n// BUILT-IN FUNCTIONS: STEP\n//\n// \"step\" function is the Heaviside step function :-)\n// http://en.wikipedia.org/wiki/Heaviside_step_function\n// \n// f(x0, x) = {1 x>x0, \n//            {0 x<x0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\n\t\n\tvec3 bgCol = vec3(0.0); // black\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\n\tvec3 pixel = bgCol;\n\t\n\tfloat edge, variable, ret;\n\t\n\t// divide the screen into five parts horizontally\n\t// for different examples\n\tif(r.x < -0.6*xMax) { // Part I\n\t\tvariable = r.y;\n\t\tedge = 0.2;\n\t\tif( variable > edge ) { // if the \"variable\" is greater than \"edge\"\n\t\t\tret = 1.0;          // return 1.0\n\t\t} else {                // if the \"variable\" is less than \"edge\"\n\t\t\tret = 0.0;          // return 0.0\n\t\t}\n\t} \n\telse if(r.x < -0.2*xMax) { // Part II\n\t\tvariable = r.y;\n\t\tedge = -0.2;\n\t\tret = step(edge, variable); // step function is equivalent to the\n\t\t                            // if block of the Part I\n\t} \n\telse if(r.x < 0.2*xMax) { // Part III\n\t\t// \"step\" returns either 0.0 or 1.0.\n\t\t// \"1.0 - step\" will inverse the output\n\t\tret = 1.0 - step(0.5, r.y); // Mirror the step function around edge\n\t} \n\telse if(r.x < 0.6*xMax) { // Part IV\n\t\t// if y-coordinate is smaller than -0.4 ret is 0.3\n\t\t// if y-coordinate is greater than -0.4 ret is 0.3+0.5=0.8\n\t\tret = 0.3 + 0.5*step(-0.4, r.y);\n\t}\n\telse { // Part V\n\t\t// Combine two step functions to create a gap\n\t\tret = step(-0.3, r.y) * (1.0 - step(0.2, r.y));\n\t\t// \"1.0 - ret\" will create a gap\n\t}\n\t\n\tpixel = vec3(ret); // make a color out of return value.\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 15\n// BUILT-IN FUNCTIONS: CLAMP\n//\n// \"clamp\" function saturates the input below and above the thresholds\n// f(x, min, max) = { max x>max\n//                  { x   max>x>min\n//                  { min min>x\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\t// use [0,1] coordinate system for this example\n\t\n\tvec3 bgCol = vec3(0.0); // black\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\n\tvec3 pixel = bgCol;\n\t\n\tfloat edge, variable, ret;\n\t\n\t// divide the screen into four parts horizontally for different\n\t// examples\n\tif(p.x < 0.25) { // Part I\n\t\tret = p.y; // the brightness value is assigned the y coordinate\n\t\t           // it'll create a gradient\n\t} \n\telse if(p.x < 0.5) { // Part II\n\t\tfloat minVal = 0.3; // implementation of clamp\n\t\tfloat maxVal = 0.6;\n\t\tfloat variable = p.y;\n\t\tif( variable<minVal ) {\n\t\t\tret = minVal;\n\t\t}\n\t\tif( variable>minVal && variable<maxVal ) {\n\t\t\tret = variable;\n\t\t}\n\t\tif( variable>maxVal ) {\n\t\t\tret = maxVal;\n\t\t}\n\t} \n\telse if(p.x < 0.75) { // Part III\n\t\tfloat minVal = 0.6;\n\t\tfloat maxVal = 0.8;\n\t\tfloat variable = p.y;\n\t\tret = clamp(variable, minVal, maxVal);\n\t} \n\telse  { // Part IV\n\t\tfloat y = cos(5.*TWOPI*p.y); // oscillate between +1 and -1\n\t\t                             // 5 times, vertically\n\t\ty = (y+1.0)*0.5; // map [-1,1] to [0,1]\n\t\tret = clamp(y, 0.2, 0.8);\n\t}\n\t\n\tpixel = vec3(ret); // make a color out of return value.\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 16\n// BUILT-IN FUNCTIONS: SMOOTHSTEP\n//\n// \"smoothstep\" function is like step function but instead of a\n// sudden jump from 0 to 1 at the edge, it makes a smooth transition\n// in a given interval\n// http://en.wikipedia.org/wiki/Smoothstep\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\t// use [0,1] coordinate system for this example\n\t\n\tvec3 bgCol = vec3(0.0); // black\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // red\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // yellow\n\n\tvec3 pixel = bgCol;\n\t\n\tfloat edge, variable, ret;\n\t\n\t// divide the screen into four parts horizontally for different\n\t// examples\n\tif(p.x < 1./5.) { // Part I\n\t\tfloat edge = 0.5;\n\t\tret = step(edge, p.y); // simple step function\n\t} \n\telse if(p.x < 2./5.) { // Part II\n\t\t// linearstep (not a builtin function)\n\t\tfloat edge0 = 0.45;\n\t\tfloat edge1 = 0.55;\n\t\tfloat t = (p.y - edge0)/(edge1 - edge0);\n\t\t// when p.y == edge0 => t = 0.0\n\t\t// when p.y == edge1 => t = 1.0\n\t\t// RHS is a linear function of y\n\t\t// so, between edge0 and edge1, t has a linear transition\n\t\t// between 0.0 and 1.0\n\t\tfloat t1 = clamp(t, 0.0, 1.0);\n\t\t// t will have negative values when t<edge0 and\n\t\t// t will have greater than 1.0 values when t>edge1\n\t\t// but we want it be constraint between 0.0 and 1.0\n\t\t// so, clamp it!\t\t\n\t\tret = t1;\n\t} \n\telse if(p.x < 3./5.) { // Part III\n\t\t// implementation of smoothstep\n\t\tfloat edge0 = 0.45;\n\t\tfloat edge1 = 0.55;\n\t\tfloat t = clamp((p.y - edge0)/(edge1 - edge0), 0.0, 1.0);\n\t\tfloat t1 = 3.0*t*t - 2.0*t*t*t;\n\t\t// previous interpolation was linear. Visually it does not\n\t\t// give an appealing, smooth transition.\n\t\t// To achieve smoothness, implement a cubic Hermite polynomial\n\t\t// 3*t^2 - 2*t^3\n\t\tret = t1;\n\t}\n\telse if(p.x < 4./5.) { // Part IV\n\t\tret = smoothstep(0.45, 0.55, p.y);\n\t}\n\telse if(p.x < 5./5.) { // Part V\n\t\t// smootherstep, a suggestion by Ken Perlin\n\t\tfloat edge0 = 0.45;\n\t\tfloat edge1 = 0.55;\n\t\tfloat t = clamp((p.y - edge0)/(edge1 - edge0), 0.0, 1.0);\t\t\n\t\t// 6*t^5 - 15*t^4 + 10*t^3\n\t\tfloat t1 = t*t*t*(t*(t*6. - 15.) + 10.);\n\t\tret = t1;\n\t\t// faster transition and still smoother\n\t\t// but computationally more involved.\n\t}\t\n\t\t\n\tpixel = vec3(ret); // make a color out of return value.\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 17\n// BUILT-IN FUNCTIONS: MIX\n//\n// A shader can be created by first constructing individual parts\n// and composing them together.\n// There are different ways of how to combine different parts.\n// In the previous disk example, different disks were drawn on top\n// of each other. There was no mixture of layers. When disks\n// overlap, only the last one is visible.\n//\n// Let's learn mixing different data types (in this case vec3's\n// representing colors\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\t\n\tvec3 bgCol = vec3(0.3);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // red\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // yellow \n\t\n\tvec3 ret;\n\t\n\t// divide the screen into four parts horizontally for different\n\t// examples\n\tif(p.x < 1./5.) { // Part I\n\t\t// implementation of mix\n\t\tfloat x0 = 0.2; // first item to be mixed\n\t\tfloat x1 = 0.7;  // second item to be mixed\n\t\tfloat m = 0.1; // amount of mix (between 0.0 and 1.0)\n\t\t// play with this number\n\t\t// m = 0.0 means the output is fully x0\n\t\t// m = 1.0 means the output is fully x1\n\t\t// 0.0 < m < 1.0 is a linear mixture of x0 and x1\n\t\tfloat val = x0*(1.0-m) + x1*m;\n\t\tret = vec3(val);\n\t} \n\telse if(p.x < 2./5.) { // Part II\n\t\t// try all possible mix values \n\t\tfloat x0 = 0.2;\n\t\tfloat x1 = 0.7;\n\t\tfloat m = p.y; \n\t\tfloat val = x0*(1.0-m) + x1*m;\n\t\tret = vec3(val);\t\t\n\t} \n\telse if(p.x < 3./5.) { // Part III\n\t\t// use the mix function\n\t\tfloat x0 = 0.2;\n\t\tfloat x1 = 0.7;\n\t\tfloat m = p.y; \n\t\tfloat val = mix(x0, x1, m);\n\t\tret = vec3(val);\t\t\n\t}\n\telse if(p.x < 4./5.) { // Part IV\n\t\t// mix colors instead of numbers\n\t\tfloat m = p.y;\n\t\tret = mix(col1, col2, m);\n\t}\n\telse if(p.x < 5./5.) { // Part V\n\t\t// combine smoothstep and mix for color transition\n\t\tfloat m = smoothstep(0.5, 0.6, p.y);\n\t\tret = mix(col1, col2, m);\n\t}\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 18\n// ANTI-ALIASING WITH SMOOTHSTEP\n//\nfloat linearstep(float edge0, float edge1, float x) {\n\tfloat t = (x - edge0)/(edge1 - edge0);\n\treturn clamp(t, 0.0, 1.0);\n}\nfloat smootherstep(float edge0, float edge1, float x) {\n\tfloat t = (x - edge0)/(edge1 - edge0);\n\tfloat t1 = t*t*t*(t*(t*6. - 15.) + 10.);\n\treturn clamp(t1, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\n\t\n\tvec3 bgCol = vec3(0.3);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\n\tvec3 pixel = bgCol;\n\tfloat m;\n\t\n\tfloat radius = 0.4; // increase this to see the effect better\n\tif( r.x < -0.5*xMax ) { // Part I\n\t\t// no interpolation, yes aliasing\n\t\tm = step( radius, length(r - vec2(-0.5*xMax-0.4,0.0)) );\n\t\t// if the distance from the center is smaller than radius,\n\t\t// then mix value is 0.0\n\t\t// otherwise the mix value is 1.0\n\t\tpixel = mix(col1, bgCol, m);\n\t}\n\telse if( r.x < -0.0*xMax ) { // Part II\n\t\t// linearstep (first order, linear interpolation)\n\t\tm = linearstep( radius-0.005, radius+0.005, length(r - vec2(-0.0*xMax-0.4,0.0)) );\n\t\t// mix value is linearly interpolated when the distance to the center\n\t\t// is 0.005 smaller and greater than the radius.\n\t\tpixel = mix(col1, bgCol, m);\n\t}\t\n\telse if( r.x < 0.5*xMax ) { // Part III\n\t\t// smoothstep (cubical interpolation)\n\t\tm = smoothstep( radius-0.005, radius+0.005, length(r - vec2(0.5*xMax-0.4,0.0)) );\n\t\tpixel = mix(col1, bgCol, m);\n\t}\n\telse if( r.x < 1.0*xMax ) { // Part IV\n\t\t// smootherstep (sixth order interpolation)\n\t\tm = smootherstep( radius-0.005, radius+0.005, length(r - vec2(1.0*xMax-0.4,0.0)) );\n\t\tpixel = mix(col1, bgCol, m);\n\t}\n\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 19\n// FUNCTION PLOTTING\n//\n// It is always useful to see the plots of functions on cartesian\n// coordinate system, to understand what they are doing precisely\n//\n// Let's plot some 1D functions!\n// \n// If y value is a function f of x value, the expression of their\n// relation is: y = f(x)\n// in other words, the plot of a function is all points\n// that satisfy the expression: y-f(x)=0\n// this set has 0 thickness, and can't be seen.\n// Instead use the set of (x,y) that satisfy: -d < y-f(x) < d\n// in other words abs(y-f(x)) < d\n// where d is the thickness. (the thickness in in y direction)\n// Because of the properties of absolute function, the condition\n// abs(y-f(x)) < d is equivalent to the condition:\n// abs(f(x) - y) < d\n// We'll use this last one for function plotting. (in the previous one\n// we have to negate the function that we want to plot)\nfloat linearstep(float edge0, float edge1, float x) {\n\tfloat t = (x - edge0)/(edge1 - edge0);\n\treturn clamp(t, 0.0, 1.0);\n}\nfloat smootherstep(float edge0, float edge1, float x) {\n\tfloat t = (x - edge0)/(edge1 - edge0);\n\tfloat t1 = t*t*t*(t*(t*6. - 15.) + 10.);\n\treturn clamp(t1, 0.0, 1.0);\n}\n\nvoid plot(vec2 r, float y, float lineThickness, vec3 color, inout vec3 pixel) {\n\tif( abs(y - r.y) < lineThickness ) pixel = color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = 2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\t\n\tvec3 bgCol = vec3(1.0);\n\tvec3 axesCol = vec3(0.0, 0.0, 1.0);\n\tvec3 gridCol = vec3(0.5);\n\tvec3 col1 = vec3(0.841, 0.582, 0.594);\n\tvec3 col2 = vec3(0.884, 0.850, 0.648);\n\tvec3 col3 = vec3(0.348, 0.555, 0.641);\t\n\n\tvec3 pixel = bgCol;\n\t\n\t// Draw grid lines\n\tconst float tickWidth = 0.1;\n\tfor(float i=-2.0; i<2.0; i+=tickWidth) {\n\t\t// \"i\" is the line coordinate.\n\t\tif(abs(r.x - i)<0.004) pixel = gridCol;\n\t\tif(abs(r.y - i)<0.004) pixel = gridCol;\n\t}\n\t// Draw the axes\n\tif( abs(r.x)<0.006 ) pixel = axesCol;\n\tif( abs(r.y)<0.007 ) pixel = axesCol;\n\t\n\t// Draw functions\n\tfloat x = r.x;\n\tfloat y = r.y;\n\t// pink functions\n\t// y = 2*x + 5\n\tif( abs(2.*x + .5 - y) < 0.02 ) pixel = col1;\n\t// y = x^2 - .2\n\tif( abs(r.x*r.x-0.2 - y) < 0.01 ) pixel = col1;\n\t// y = sin(PI x)\n\tif( abs(sin(PI*r.x) - y) < 0.02 ) pixel = col1;\n\t\n\t// blue functions, the step function variations\n\t// (functions are scaled and translated vertically)\n\tif( abs(0.25*step(0.0, x)+0.6 - y) < 0.01 ) pixel = col3;\n\tif( abs(0.25*linearstep(-0.5, 0.5, x)+0.1 - y) < 0.01 ) pixel = col3;\n\tif( abs(0.25*smoothstep(-0.5, 0.5, x)-0.4 - y) < 0.01 ) pixel = col3;\n\tif( abs(0.25*smootherstep(-0.5, 0.5, x)-0.9 - y) < 0.01 ) pixel = col3;\n\t\n\t// yellow functions\n\t// have a function that plots functions :-)\n\tplot(r, 0.5*clamp(sin(TWOPI*x), 0.0, 1.0)-0.7, 0.015, col2, pixel);\n\t// bell curve around -0.5\n\tplot(r, 0.6*exp(-10.0*(x+0.8)*(x+0.8)) - 0.1, 0.015, col2, pixel);\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n// in the future we can use this framework to see the plot of functions\n// and design and find functions for our liking\n// Actually using Mathematica, Matlab, matplotlib etc. to plot functions\n// is much more practical. But they need a translation of functions \n// from GLSL to their language. Here we can plot the native implementations\n// of GLSL functions.\n\n\n#elif TUTORIAL == 20\n// COLOR ADDITION AND SUBSTRACTION\n//\n// How to draw a shape on top of another, and how will the layers\n// below, affect the higher layers?\n//\n// In the previous shape drawing functions, we set the pixel\n// value from the function. This time the shape function will\n// just return a float value between 0.0 and 1.0 to indice the\n// shape area. Later that value can be multiplied with some color\n// and used in determining the final pixel color.\n\n// A function that returns the 1.0 inside the disk area\n// returns 0.0 outside the disk area\n// and has a smooth transition at the radius\nfloat disk(vec2 r, vec2 center, float radius) {\n\tfloat distanceFromCenter = length(r-center);\n\tfloat outsideOfDisk = smoothstep( radius-0.005, radius+0.005, distanceFromCenter);\n\tfloat insideOfDisk = 1.0 - outsideOfDisk;\n\treturn insideOfDisk;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\tvec3 black = vec3(0.0);\n\tvec3 white = vec3(1.0);\n\tvec3 gray = vec3(0.3);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // red\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // yellow\n\t\n\tvec3 ret;\n\tfloat d;\n\t\n\tif(p.x < 1./3.) { // Part I\n\t\t// opaque layers on top of each other\n\t\tret = gray;\n\t\t// assign a gray value to the pixel first\n\t\td = disk(r, vec2(-1.1,0.3), 0.4);\n\t\tret = mix(ret, col1, d); // mix the previous color value with\n\t\t                         // the new color value according to\n\t\t                         // the shape area function.\n\t\t                         // at this line, previous color is gray.\n\t\td = disk(r, vec2(-1.3,0.0), 0.4);\n\t\tret = mix(ret, col2, d);\n\t\td = disk(r, vec2(-1.05,-0.3), 0.4); \n\t\tret = mix(ret, col3, d); // here, previous color can be gray,\n\t\t                         // blue or pink.\n\t} \n\telse if(p.x < 2./3.) { // Part II\n\t\t// Color addition\n\t\t// This is how lights of different colors add up\n\t\t// http://en.wikipedia.org/wiki/Additive_color\n\t\tret = black; // start with black pixels\n\t\tret += disk(r, vec2(0.1,0.3), 0.4)*col1; // add the new color\n\t\t                                         // to the previous color\n\t\tret += disk(r, vec2(-.1,0.0), 0.4)*col2;\n\t\tret += disk(r, vec2(.15,-0.3), 0.4)*col3;\n\t\t// when all components of \"ret\" becomes equal or higher than 1.0\n\t\t// it becomes white.\n\t} \n\telse if(p.x < 3./3.) { // Part III\n\t\t// Color substraction\n\t\t// This is how dye of different colors add up\n\t\t// http://en.wikipedia.org/wiki/Subtractive_color\n\t\tret = white; // start with white\n\t\tret -= disk(r, vec2(1.1,0.3), 0.4)*col1;\n\t\tret -= disk(r, vec2(1.05,0.0), 0.4)* col2;\n\t\tret -= disk(r, vec2(1.35,-0.25), 0.4)* col3;\t\t\t\n\t\t// when all components of \"ret\" becomes equals or smaller than 0.0\n\t\t// it becomes black.\n\t}\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n\n#elif TUTORIAL == 21\n// COORDINATE TRANSFORMATIONS: ROTATION\n//\n// Up to now, we translated to coordinate center to draw geometric\n// shapes at different parts of the screen.\n// Lets learn how to rotate the shapes.\n\n// a function that draws an (anti-aliased) grid of coordinate system\nfloat coordinateGrid(vec2 r) {\n\tvec3 axesCol = vec3(0.0, 0.0, 1.0);\n\tvec3 gridCol = vec3(0.5);\n\tfloat ret = 0.0;\n\t\n\t// Draw grid lines\n\tconst float tickWidth = 0.1;\n\tfor(float i=-2.0; i<2.0; i+=tickWidth) {\n\t\t// \"i\" is the line coordinate.\n\t\tret += 1.-smoothstep(0.0, 0.008, abs(r.x-i));\n\t\tret += 1.-smoothstep(0.0, 0.008, abs(r.y-i));\n\t}\n\t// Draw the axes\n\tret += 1.-smoothstep(0.001, 0.015, abs(r.x));\n\tret += 1.-smoothstep(0.001, 0.015, abs(r.y));\n\treturn ret;\n}\n// returns 1.0 if inside circle\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 1.0 - smoothstep( radius-0.005, radius+0.005, length(r-center));\n}\n// returns 1.0 if inside the rectangle\nfloat rectangle(vec2 r, vec2 topLeft, vec2 bottomRight) {\n\tfloat ret;\n\tfloat d = 0.005;\n\tret = smoothstep(topLeft.x-d, topLeft.x+d, r.x);\n\tret *= smoothstep(topLeft.y-d, topLeft.y+d, r.y);\n\tret *= 1.0 - smoothstep(bottomRight.y-d, bottomRight.y+d, r.y);\n\tret *= 1.0 - smoothstep(bottomRight.x-d, bottomRight.x+d, r.x);\n\treturn ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\tvec3 bgCol = vec3(1.0);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\t\n\tvec3 ret;\n\t\n\tvec2 q;\n\tfloat angle;\n\tangle = 0.2*PI; // angle in radians (PI is 180 degrees)\n\t// q is the rotated coordinate system\n\tq.x =   cos(angle)*r.x + sin(angle)*r.y;\n\tq.y = - sin(angle)*r.x + cos(angle)*r.y;\n\t\n\tret = bgCol;\n\t// draw the old and new coordinate systems\n\tret = mix(ret, col1, coordinateGrid(r)*0.4 );\n\tret = mix(ret, col2, coordinateGrid(q) );\n\t\n\t// draw shapes in old coordinate system, r, and new coordinate system, q\n\tret = mix(ret, col1, disk(r, vec2(1.0, 0.0), 0.2));\n\tret = mix(ret, col2, disk(q, vec2(1.0, 0.0), 0.2));\n\tret = mix(ret, col1, rectangle(r, vec2(-0.8, 0.2), vec2(-0.5, 0.4)) );\t\n\tret = mix(ret, col2, rectangle(q, vec2(-0.8, 0.2), vec2(-0.5, 0.4)) );\t\n\t// as you see both circle are drawn at the same coordinate, (1,0),\n\t// in their respective coordinate systems. But they appear\n\t// on different locations of the screen\n\t\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n#elif TUTORIAL == 22\n// COORDINATE TRANSFORMATIONS: SCALING\n//\n// Scaling the coordinate system.\n\n// a function that draws an (anti-aliased) grid of coordinate system\nfloat coordinateGrid(vec2 r) {\n\tvec3 axesCol = vec3(0.0, 0.0, 1.0);\n\tvec3 gridCol = vec3(0.5);\n\tfloat ret = 0.0;\n\t\n\t// Draw grid lines\n\tconst float tickWidth = 0.1;\n\tfor(float i=-2.0; i<2.0; i+=tickWidth) {\n\t\t// \"i\" is the line coordinate.\n\t\tret += 1.-smoothstep(0.0, 0.008, abs(r.x-i));\n\t\tret += 1.-smoothstep(0.0, 0.008, abs(r.y-i));\n\t}\n\t// Draw the axes\n\tret += 1.-smoothstep(0.001, 0.015, abs(r.x));\n\tret += 1.-smoothstep(0.001, 0.015, abs(r.y));\n\treturn ret;\n}\n// returns 1.0 if inside circle\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 1.0 - smoothstep( radius-0.005, radius+0.005, length(r-center));\n}\n// returns 1.0 if inside the rectangle\nfloat rectangle(vec2 r, vec2 topLeft, vec2 bottomRight) {\n\tfloat ret;\n\tfloat d = 0.005;\n\tret = smoothstep(topLeft.x-d, topLeft.x+d, r.x);\n\tret *= smoothstep(topLeft.y-d, topLeft.y+d, r.y);\n\tret *= 1.0 - smoothstep(bottomRight.y-d, bottomRight.y+d, r.y);\n\tret *= 1.0 - smoothstep(bottomRight.x-d, bottomRight.x+d, r.x);\n\treturn ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\tvec3 bgCol = vec3(1.0);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\t\t\n\tvec3 ret = bgCol;\n\t\n\t// original\n\tret = mix(ret, col1, coordinateGrid(r)/2.0);\n\t// scaled\n    float scaleFactor = 3.3; // zoom in this much\n\tvec2 q = r / scaleFactor;\n\tret = mix(ret, col2, coordinateGrid(q)/2.0);\n\n\tret = mix(ret, col2, disk(q, vec2(0.0, 0.0), 0.1));\t\n\tret = mix(ret, col1, disk(r, vec2(0.0, 0.0), 0.1));\n\t\n\tret = mix(ret, col1, rectangle(r, vec2(-0.5, 0.0), vec2(-0.2, 0.2)) );\n\tret = mix(ret, col2, rectangle(q, vec2(-0.5, 0.0), vec2(-0.2, 0.2)) );\n\t\n\t// note how the rectangle that are not centered at the coordinate origin\n\t// changed its location after scaling, but the disks at the center\n\t// remained where they are.\n\t// This is because scaling is done by multiplying all pixel\n\t// coordinates with a constant.\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n\n#elif TUTORIAL == 23\n// SUCCESSIVE COORDINATE TRANSFORMATIONS\n//\n// Drawing a shape on the desired location, with desired size, and\n// desired orientation needs mastery of succesive application of\n// transformations.\n//\n// In general, transformations do not commute. Which means that\n// if you change their order, you get different results.\n//\n// Let's try application of transformations in different orders.\n\nfloat coordinateGrid(vec2 r) {\n\tvec3 axesCol = vec3(0.0, 0.0, 1.0);\n\tvec3 gridCol = vec3(0.5);\n\tfloat ret = 0.0;\n\t\n\t// Draw grid lines\n\tconst float tickWidth = 0.1;\n\tfor(float i=-2.0; i<2.0; i+=tickWidth) {\n\t\t// \"i\" is the line coordinate.\n\t\tret += 1.-smoothstep(0.0, 0.008, abs(r.x-i));\n\t\tret += 1.-smoothstep(0.0, 0.008, abs(r.y-i));\n\t}\n\t// Draw the axes\n\tret += 1.-smoothstep(0.001, 0.015, abs(r.x));\n\tret += 1.-smoothstep(0.001, 0.015, abs(r.y));\n\treturn ret;\n}\n// returns 1.0 if inside circle\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 1.0 - smoothstep( radius-0.005, radius+0.005, length(r-center));\n}\n// returns 1.0 if inside the disk\nfloat rectangle(vec2 r, vec2 topLeft, vec2 bottomRight) {\n\tfloat ret;\n\tfloat d = 0.005;\n\tret = smoothstep(topLeft.x-d, topLeft.x+d, r.x);\n\tret *= smoothstep(topLeft.y-d, topLeft.y+d, r.y);\n\tret *= 1.0 - smoothstep(bottomRight.y-d, bottomRight.y+d, r.y);\n\tret *= 1.0 - smoothstep(bottomRight.x-d, bottomRight.x+d, r.x);\n\treturn ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\tvec3 bgCol = vec3(1.0);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\t\t\n\tvec3 ret = bgCol;\n\n\tfloat angle = 0.6;\n\tmat2 rotationMatrix = mat2(cos(angle), -sin(angle),\n                               sin(angle),  cos(angle));\t\n\n\tif(p.x < 1./2.) { // Part I\n\t\t// put the origin at the center of Part I\n\t\tr = r - vec2(-xMax/2.0, 0.0); \n\n\t\tvec2 rotated = rotationMatrix*r;\n\t\tvec2 rotatedTranslated = rotated - vec2(0.4, 0.5);\n\t\tret = mix(ret, col1, coordinateGrid(r)*0.3);\n\t\tret = mix(ret, col2, coordinateGrid(rotated)*0.3);\n\t\tret = mix(ret, col3, coordinateGrid(rotatedTranslated)*0.3);\n\n\t\tret = mix(ret, col1, rectangle(r, vec2(-.1, -.2), vec2(0.1, 0.2)) );\n\t\tret = mix(ret, col2, rectangle(rotated, vec2(-.1, -.2), vec2(0.1, 0.2)) );\n\t\tret = mix(ret, col3, rectangle(rotatedTranslated, vec2(-.1, -.2), vec2(0.1, 0.2)) );\n\t} \n\telse if(p.x < 2./2.) { // Part II\n\t\tr = r - vec2(xMax*0.5, 0.0); \n\n\t\tvec2 translated = r - vec2(0.4, 0.5);\n\t\tvec2 translatedRotated = rotationMatrix*translated;\n\t\t\n\t\tret = mix(ret, col1, coordinateGrid(r)*0.3);\n\t\tret = mix(ret, col2, coordinateGrid(translated)*0.3);\n\t\tret = mix(ret, col3, coordinateGrid(translatedRotated)*0.3);\n\n\t\tret = mix(ret, col1, rectangle(r, vec2(-.1, -.2), vec2(0.1, 0.2)) );\n\t\tret = mix(ret, col2, rectangle(translated, vec2(-.1, -.2), vec2(0.1, 0.2)) );\n\t\tret = mix(ret, col3, rectangle(translatedRotated, vec2(-.1, -.2), vec2(0.1, 0.2)) );\t\t\n\t} \t\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n\n#elif TUTORIAL == 24\n// TIME, MOTION AND ANIMATION\n//\n// One of the inputs that a shader gets can be the time.\n// In ShaderToy, \"iTime\" variable holds the value of the\n// time in seconds since the shader is started.\n//\n// Let's change some variables in time!\n\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 1.0 - smoothstep( radius-0.005, radius+0.005, length(r-center));\n}\n\nfloat rect(vec2 r, vec2 bottomLeft, vec2 topRight) {\n\tfloat ret;\n\tfloat d = 0.005;\n\tret = smoothstep(bottomLeft.x-d, bottomLeft.x+d, r.x);\n\tret *= smoothstep(bottomLeft.y-d, bottomLeft.y+d, r.y);\n\tret *= 1.0 - smoothstep(topRight.y-d, topRight.y+d, r.y);\n\tret *= 1.0 - smoothstep(topRight.x-d, topRight.x+d, r.x);\n\treturn ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\t\n\tvec3 ret;\n\t\t\n\tif(p.x < 1./5.) { // Part I\n\t\tvec2 q = r + vec2(xMax*4./5.,0.);\n\t\tret = vec3(0.2);\n\t\t// y coordinate depends on time\n\t\tfloat y = iTime;\n\t\t// mod constraints y to be between 0.0 and 2.0,\n\t\t// and y jumps from 2.0 to 0.0\n\t\t// substracting -1.0 makes why jump from 1.0 to -1.0\n\t\ty = mod(y, 2.0) - 1.0;\n\t\tret = mix(ret, col1, disk(q, vec2(0.0, y), 0.1) );\n\t} \n\telse if(p.x < 2./5.) { // Part II\n\t\tvec2 q = r + vec2(xMax*2./5.,0.);\n\t\tret = vec3(0.3);\n\t\t// oscillation\n\t\tfloat amplitude = 0.8;\n\t\t// y coordinate oscillates with a period of 0.5 seconds\n\t\tfloat y = 0.8*sin(0.5*iTime*TWOPI);\n\t\t// radius oscillates too\n\t\tfloat radius = 0.15 + 0.05*sin(iTime*8.0);\n\t\tret = mix(ret, col1, disk(q, vec2(0.0, y), radius) );\t\t\n\t} \n\telse if(p.x < 3./5.) { // Part III\n\t\tvec2 q = r + vec2(xMax*0./5.,0.);\n\t\tret = vec3(0.4);\n\t\t// booth coordinates oscillates\n\t\tfloat x = 0.2*cos(iTime*5.0);\n\t\t// but they have a phase difference of PI/2\n\t\tfloat y = 0.3*cos(iTime*5.0 + PI/2.0);\n\t\tfloat radius = 0.2 + 0.1*sin(iTime*2.0);\n\t\t// make the color mixture time dependent\n\t\tvec3 color = mix(col1, col2, sin(iTime)*0.5+0.5);\n\t\tret = mix(ret, color, rect(q, vec2(x-0.1, y-0.1), vec2(x+0.1, y+0.1)) );\t\t\n\t\t// try different phases, different amplitudes and different frequencies\n\t\t// for x and y coordinates\n\t}\n\telse if(p.x < 4./5.) { // Part IV\n\t\tvec2 q = r + vec2(-xMax*2./5.,0.);\n\t\tret = vec3(0.3);\n\t\tfor(float i=-1.0; i<1.0; i+= 0.2) {\n\t\t\tfloat x = 0.2*cos(iTime*5.0 + i*PI);\n\t\t\t// y coordinate is the loop value\n\t\t\tfloat y = i;\n\t\t\tvec2 s = q - vec2(x, y);\n\t\t\t// each box has a different phase\n\t\t\tfloat angle = iTime*3. + i;\n\t\t\tmat2 rot = mat2(cos(angle), -sin(angle), sin(angle),  cos(angle));\n\t\t\ts = rot*s;\n\t\t\tret = mix(ret, col1, rect(s, vec2(-0.06, -0.06), vec2(0.06, 0.06)) );\t\t\t\n\t\t}\n\t}\n\telse if(p.x < 5./5.) { // Part V\n\t\tvec2 q = r + vec2(-xMax*4./5., 0.);\n\t\tret = vec3(0.2);\n\t\t// let stop and move again periodically\n\t\tfloat speed = 2.0;\n\t\tfloat t = iTime*speed;\n\t\tfloat stopEveryAngle = PI/2.0;\n\t\tfloat stopRatio = 0.5;\n\t\tfloat t1 = (floor(t) + smoothstep(0.0, 1.0-stopRatio, fract(t)) )*stopEveryAngle;\n\t\t\n\t\tfloat x = -0.2*cos(t1);\n\t\tfloat y = 0.3*sin(t1);\n\t\tfloat dx = 0.1 + 0.03*sin(t*10.0);\n\t\tfloat dy = 0.1 + 0.03*sin(t*10.0+PI);\n\t\tret = mix(ret, col1, rect(q, vec2(x-dx, y-dy), vec2(x+dx, y+dy)) );\t\t\n\t}\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n#elif TUTORIAL == 25\n// PLASMA EFFECT\n//\n// We said that the a pixel's color only depends on its coordinates\n// and other inputs (such as time)\n// \n// There is an effect called Plasma, which is based on a mixture of\n// complex function in the form of f(x,y).\n//\n// Let's write a plasma!\n//\n// http://en.wikipedia.org/wiki/Plasma_effect\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat t = iTime;\n    r = r * 8.0;\n\t\n    float v1 = sin(r.x +t);\n    float v2 = sin(r.y +t);\n    float v3 = sin(r.x+r.y +t);\n    float v4 = sin(length(r) +1.7*t);\n\tfloat v = v1+v2+v3+v4;\n\t\n\tvec3 ret;\n\t\n\tif(p.x < 1./10.) { // Part I\n\t\t// vertical waves\n\t\tret = vec3(v1);\n\t} \n\telse if(p.x < 2./10.) { // Part II\n\t\t// horizontal waves\n\t\tret = vec3(v2);\n\t} \n\telse if(p.x < 3./10.) { // Part III\n\t\t// diagonal waves\n\t\tret = vec3(v3);\n\t}\n\telse if(p.x < 4./10.) { // Part IV\n\t\t// circular waves\n\t\tret = vec3(v4);\n\t}\n\telse if(p.x < 5./10.) { // Part V\n\t\t// the sum of all waves\n\t\tret = vec3(v);\n\t}\t\n\telse if(p.x < 6./10.) { // Part VI\n\t\t// Add periodicity to the gradients\n\t\tret = vec3(sin(2.*v));\n\t}\n\telse if(p.x < 10./10.) { // Part VII\n\t\t// mix colors\n\t\tv *= 1.0;\n\t\tret = vec3(sin(v), sin(v+0.5*PI), sin(v+1.0*PI));\n\t}\t\n\t\n\tret = 0.5 + 0.5*ret;\n\t\n    vec3 pixel = ret;\n    fragColor = vec4(pixel, 1.);\n}\n\n\n\n#elif TUTORIAL == 26\n// TEXTURES\n//\n// ShaderToy can use upto four textures. \n\nfloat rect(vec2 r, vec2 bottomLeft, vec2 topRight) {\n\tfloat ret;\n\tfloat d = 0.005;\n\tret = smoothstep(bottomLeft.x-d, bottomLeft.x+d, r.x);\n\tret *= smoothstep(bottomLeft.y-d, bottomLeft.y+d, r.y);\n\tret *= 1.0 - smoothstep(topRight.y-d, topRight.y+d, r.y);\n\tret *= 1.0 - smoothstep(topRight.x-d, topRight.x+d, r.x);\n\treturn ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\tvec3 bgCol = vec3(0.3);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\t\n\tvec3 ret;\n\t\n\tif(p.x < 1./3.) { // Part I\n\t\tret = texture(iChannel1, p).xyz;\n\t} \n\telse if(p.x < 2./3.) { // Part II\n\t\tret = texture(iChannel1, 4.*p+vec2(0.,iTime)).xyz;\n\t} \n\telse if(p.x < 3./3.) { // Part III\n\t\tr = r - vec2(xMax*2./3., 0.);\n\t\tfloat angle = iTime;\n\t\tmat2 rotMat = mat2(cos(angle), -sin(angle),\n        \t               sin(angle),  cos(angle));\n\t\tvec2 q = rotMat*r;\n\t\tvec3 texA = texture(iChannel1, q).xyz;\n\t\tvec3 texB = texture(iChannel2, q).xyz;\n\t\t\n\t\tangle = -iTime;\n\t\trotMat = mat2(cos(angle), -sin(angle),\n        \t               sin(angle),  cos(angle));\n\t\tq = rotMat*r;\t\t\n\t\tret = mix(texA, texB, rect(q, vec2(-0.3, -0.3), vec2(.3, .3)) );\n\t\t\n\t}\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n\n#elif TUTORIAL == 27\n// MOUSE INPUT\n//\n// ShaderToy gives the mouse cursor coordinates and button clicks\n// as an input via the iMouse vec4.\n//\n// Let's write a shader with basic Mouse functionality.\n// When clicked on the frame, the little disk will follow the\n// cursor. The x coordinate of the cursor changes the background color.\n// And if the cursor is inside the bigger disk, it'll color will change.\n\n\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 1.0 - smoothstep( radius-0.5, radius+0.5, length(r-center));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\n\t\n\t// background color depends on the x coordinate of the cursor\n\tvec3 bgCol = vec3(iMouse.x / iResolution.x);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\t\n\tvec3 ret = bgCol;\n\t\n\tvec2 center;\n\t// draw the big yellow disk\n\tcenter = vec2(100., iResolution.y/2.);\n\tfloat radius = 60.;\n\t// if the cursor coordinates is inside the disk\n\tif( length(iMouse.xy-center)>radius ) {\n\t\t// use color3\n\t\tret = mix(ret, col3, disk(fragCoord.xy, center, radius));\n\t}\n\telse {\n\t\t// else use color2\n\t\tret = mix(ret, col2, disk(fragCoord.xy, center, radius));\n\t}\t\n\t\n\t// draw the small blue disk at the cursor\n\tcenter = iMouse.xy;\n\tret = mix(ret, col1, disk(fragCoord.xy, center, 20.));\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n\n\n#elif TUTORIAL == 28\n// RANDOMNESS\n//\n// I don't know why, but GLSL does not have random number generators.\n// This does not pose a problem if you are writing your code in\n// a programming language that has random functions. That way\n// you can generate the random values using the language and send\n// those values to the shader via uniforms.\n//\n// But if you are using a system that only allows you to write\n// the shader code, such as ShaderToy, then you need to write your own\n// pseuo-random generators.\n//\n// Here is a pattern that I saw again and again in many different\n// shaders at ShaderToy.\n// Let's draw N different disks at random locations using this pattern.\n\nfloat hash(float seed)\n{\n\t// Return a \"random\" number based on the \"seed\"\n    return fract(sin(seed) * 43758.5453);\n}\n\nvec2 hashPosition(float x)\n{\n\t// Return a \"random\" position based on the \"seed\"\n\treturn vec2(hash(x), hash(x * 1.1));\n}\n\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 1.0 - smoothstep( radius-0.005, radius+0.005, length(r-center));\n}\n\nfloat coordinateGrid(vec2 r) {\n\tvec3 axesCol = vec3(0.0, 0.0, 1.0);\n\tvec3 gridCol = vec3(0.5);\n\tfloat ret = 0.0;\n\t\n\t// Draw grid lines\n\tconst float tickWidth = 0.1;\n\tfor(float i=-2.0; i<2.0; i+=tickWidth) {\n\t\t// \"i\" is the line coordinate.\n\t\tret += 1.-smoothstep(0.0, 0.005, abs(r.x-i));\n\t\tret += 1.-smoothstep(0.0, 0.01, abs(r.y-i));\n\t}\n\t// Draw the axes\n\tret += 1.-smoothstep(0.001, 0.005, abs(r.x));\n\tret += 1.-smoothstep(0.001, 0.005, abs(r.y));\n\treturn ret;\n}\n\nfloat plot(vec2 r, float y, float thickness) {\n\treturn ( abs(y - r.y) < thickness ) ? 1.0 : 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\tvec3 bgCol = vec3(0.3);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\t\n\tvec3 ret = bgCol;\n\t\n\tvec3 white = vec3(1.);\n\tvec3 gray = vec3(.3);\n\tif(r.y > 0.7) {\n\t\t\n\t\t// translated and rotated coordinate system\n\t\tvec2 q = (r-vec2(0.,0.9))*vec2(1.,20.);\n\t\tret = mix(white, gray, coordinateGrid(q));\n\t\t\n\t\t// just the regular sin function\n\t\tfloat y = sin(5.*q.x) * 2.0 - 1.0;\n\t\t\n\t\tret = mix(ret, col1, plot(q, y, 0.1));\n\t}\n\telse if(r.y > 0.4) {\n\t\tvec2 q = (r-vec2(0.,0.6))*vec2(1.,20.);\n\t\tret = mix(white, col1, coordinateGrid(q));\n\t\t\n\t\t// take the decimal part of the sin function\n\t\tfloat y = fract(sin(5.*q.x)) * 2.0 - 1.0;\n\t\t\n\t\tret = mix(ret, col2, plot(q, y, 0.1));\n\t}\t\n\telse if(r.y > 0.1) {\n\t\tvec3 white = vec3(1.);\n\t\tvec2 q = (r-vec2(0.,0.25))*vec2(1.,20.);\n\t\tret = mix(white, gray, coordinateGrid(q));\n\t\t\n\t\t// scale up the outcome of the sine function\n\t\t// increase the scale and see the transition from\n\t\t// periodic pattern to chaotic pattern\n\t\tfloat scale = 10.0;\n\t\tfloat y = fract(sin(5.*q.x) * scale) * 2.0 - 1.0;\n\t\t\n\t\tret = mix(ret, col1, plot(q, y, 0.2));\n\t}\t\n\telse if(r.y > -0.2) {\n\t\tvec3 white = vec3(1.);\n\t\tvec2 q = (r-vec2(0., -0.0))*vec2(1.,10.);\n\t\tret = mix(white, col1, coordinateGrid(q));\n\t\t\n\t\tfloat seed = q.x;\n\t\t// Scale up with a big real number\n\t\tfloat y = fract(sin(seed) * 43758.5453) * 2.0 - 1.0;\n\t\t// this can be used as a pseudo-random value\n\t\t// These type of function, functions in which two inputs\n\t\t// that are close to each other (such as close q.x positions)\n\t\t// return highly different output values, are called \"hash\"\n\t\t// function.\n\t\t\n\t\tret = mix(ret, col2, plot(q, y, 0.1));\n\t}\n\telse {\n\t\tvec2 q = (r-vec2(0., -0.6));\n\t\t\n\t\t// use the loop index as the seed\n\t\t// and vary different quantities of disks, such as\n\t\t// location and radius\n\t\tfor(float i=0.0; i<6.0; i++) {\n\t\t\t// change the seed and get different distributions\n\t\t\tfloat seed = i + 0.0; \n\t\t\tvec2 pos = (vec2(hash(seed), hash(seed + 0.5))-0.5)*3.;;\n\t\t\tfloat radius = hash(seed + 3.5);\n\t\t\tpos *= vec2(1.0,0.3);\n\t\t\tret = mix(ret, col1, disk(q, pos, 0.2*radius));\n\t\t}\t\t\n\t}\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n\n\n\n\n/* End of tutorials */\n\n#elif TUTORIAL == 0\n// WELCOME SCREEN\nfloat square(vec2 r, vec2 bottomLeft, float side) {\n\tvec2 p = r - bottomLeft;\n\treturn ( p.x > 0.0 && p.x < side && p.y>0.0 && p.y < side ) ? 1.0 : 0.0;\n}\n\nfloat character(vec2 r, vec2 bottomLeft, float charCode, float squareSide) {\n\tvec2 p = r - bottomLeft;\n\tfloat ret = 0.0;\n\tfloat num, quotient, remainder, divider;\n\tfloat x, y;\t\n\tnum = charCode;\n\tfor(int i=0; i<20; i++) {\n\t\tfloat boxNo = float(19-i);\n\t\tdivider = pow(2., boxNo);\n\t\tquotient = floor(num / divider);\n\t\tremainder = num - quotient*divider;\n\t\tnum = remainder;\n\t\t\n\t\ty = floor(boxNo/4.0); \n\t\tx = boxNo - y*4.0;\n\t\tif(quotient == 1.) {\n\t\t\tret += square( p, squareSide*vec2(x, y), squareSide );\n\t\t}\n\t}\n\treturn ret;\n}\n\nmat2 rot(float th) { return mat2(cos(th), -sin(th), sin(th), cos(th)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat G = 990623.; // compressed characters :-)\n\tfloat L = 69919.;\n\tfloat S = 991119.;\n\t\n\tfloat t = iTime;\n\n\tvec2 r = (fragCoord.xy - 0.5*iResolution.xy) / iResolution.y;\n\t//vec2 rL = rot(t)*r+0.0001*t;\n\t//vec2 rL = r+vec2(cos(t*0.02),sin(t*0.02))*t*0.05;\n\tfloat c = 0.05;//+0.03*sin(2.5*t);\n\tvec2 pL = (mod(r+vec2(cos(0.3*t),sin(0.3*t)), 2.0*c)-c)/c;\n\tfloat circ = 1.0-smoothstep(0.75, 0.8, length(pL));\n\tvec2 rG = rot(2.*3.1415*smoothstep(0.,1.,mod(1.5*t,4.0)))*r;\n\tvec2 rStripes = rot(0.2)*r;\n\t\t\t\t\n\tfloat xMax = 0.5*iResolution.x/iResolution.y;\n\tfloat letterWidth = 2.0*xMax*0.9/4.0;\n\tfloat side = letterWidth/4.;\n\tfloat space = 2.0*xMax*0.1/5.0;\n\t\n\tr += 0.001; // to get rid off the y=0 horizontal blue line.\n\tfloat maskGS = character(r, vec2(-xMax+space, -2.5*side)+vec2(letterWidth+space, 0.0)*0.0, G, side);\n\tfloat maskG = character(rG, vec2(-xMax+space, -2.5*side)+vec2(letterWidth+space, 0.0)*0.0, G, side);\n\tfloat maskL1 = character(r, vec2(-xMax+space, -2.5*side)+vec2(letterWidth+space, 0.0)*1.0, L, side);\n\tfloat maskSS = character(r, vec2(-xMax+space, -2.5*side)+vec2(letterWidth+space, 0.0)*2.0, S, side);\n\tfloat maskS = character(r, vec2(-xMax+space, -2.5*side)+vec2(letterWidth+space, 0.0)*2.0 + vec2(0.01*sin(2.1*t),0.012*cos(t)), S, side);\n\tfloat maskL2 = character(r, vec2(-xMax+space, -2.5*side)+vec2(letterWidth+space, 0.0)*3.0, L, side);\n\tfloat maskStripes = step(0.25, mod(rStripes.x - 0.5*t, 0.5));\n\t\n\tfloat i255 = 0.00392156862;\n\tvec3 blue = vec3(43., 172., 181.)*i255;\n\tvec3 pink = vec3(232., 77., 91.)*i255;\n\tvec3 dark = vec3(59., 59., 59.)*i255;\n\tvec3 light = vec3(245., 236., 217.)*i255;\n\tvec3 green = vec3(180., 204., 18.)*i255;\n\n\tvec3 pixel = blue;\n\tpixel = mix(pixel, light, maskGS);\n\tpixel = mix(pixel, light, maskSS);\n\tpixel -= 0.1*maskStripes;\t\n\tpixel = mix(pixel, green, maskG);\n\tpixel = mix(pixel, pink, maskL1*circ);\n\tpixel = mix(pixel, green, maskS);\n\tpixel = mix(pixel, pink, maskL2*(1.-circ));\n\t\n\tfloat dirt = pow(texture(iChannel0, 4.0*r).x, 4.0);\n\tpixel -= (0.2*dirt - 0.1)*(maskG+maskS); // dirt\n\tpixel -= smoothstep(0.45, 2.5, length(r));\n\tfragColor = vec4(pixel, 1.0);\n}\n#endif","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Md23DV","date":"1394312329","viewed":60477,"name":"GLSL 2D Tutorials","username":"vug","description":"28 tutorials on writing pixel shaders at Shadertoy. Written by a beginner for beginners.  ^_^","likes":656,"published":1,"flags":0,"usePreview":0,"tags":["tutorial"],"hasliked":0,"parentid":"","parentname":""}}