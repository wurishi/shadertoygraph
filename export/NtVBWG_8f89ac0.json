{"ver":"0.1","info":{"id":"NtVBWG","date":"1665175206","viewed":110,"name":"Sin approximations collection","username":"Envy24","description":"blue- approximation, red - sin(x), teal (light blue) - error.\npurple - trajectory via sine approximation,\nblack - trajectory via native sine implementation.\nHold LMP to see very thin curves.\nChebychev approximation: https://www.shadertoy.com/view/ddj3Wh","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sin","approximation","taylor"],"hasliked":0,"parentid":"stVcDz","parentname":"Minimal Plotter"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCENE_SCALE               ( 2. )\n#define SM                        ( iMouse.z > 0. ? 2.7 : 4. )\n#define UNIT                      ( (SM*SCENE_SCALE) / iResolution.y  )\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n#define PI                          3.1415926535897932\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nfloat draw_explicit_func(vec2 NDC, float fx, float dfdx)\n{\n    float signed_dist = NDC.y - fx;\n    return SMAA(abs(signed_dist) / sqrt(1.0 + dfdx * dfdx));\n}\n\n/* Usefull shader to check accuracy more precisely: https://www.shadertoy.com/view/Dd23Dh */\n\n/* Chebyshev approximation: https://www.shadertoy.com/view/ddj3Wh */\n\n/* Source: \"Math Toolkit For Real-Time Development\", Jack W. Crenshaw */\nfloat error_mult = 1e5;\nvec2 sincos(float x)\n{\n    const float sin_30 =      0.5;\n    const float cos_30 =      0.8660254037844386;\n    const float pi_over_six = 0.5235987755982988; // pi / 6\n    const float inv =         1.9098593171027440; // 1 / pi_over_six\n    const float tau =         6.2831853071795862; // 2 * pi\n    const float inv_tau =     0.1591549430918953; // 1 / tau\n    \n    // On/Off accuracy improvment.\n    x = fract(x*inv_tau)*tau;\n\n    int n = int(x * inv + 0.5); \n    x -= float(n) * pi_over_six;   \n    \n    n = n < 0 ? (n + 12) % 12 : n % 12;\n    \n    float z = x*x, s = 0., c = 0.,\n          s1 = ((z/20.0-1.0)*z/6.0+1.0)*x,\n          c1 = ((z/30.0+1.0)*z/12.0-1.0)*z/2.0+1.0;        \n    \n    switch(n)\n    {\n    case 0:  s =  s1;                        c =  c1;                        break;\n    case 1:  s =  cos_30 * s1 + sin_30 * c1; c = -sin_30 * s1 + cos_30 * c1; break;\n    case 2:  s =  sin_30 * s1 + cos_30 * c1; c = -cos_30 * s1 + sin_30 * c1; break;\n    case 3:  s =  c1;                        c = -s1;                        break;\n    case 4:  s = -sin_30 * s1 + cos_30 * c1; c = -cos_30 * s1 - sin_30 * c1; break;\n    case 5:  s = -cos_30 * s1 + sin_30 * c1; c = -sin_30 * s1 - cos_30 * c1; break;\n    case 6:  s = -s1;                        c = -c1;                        break;\n    case 7:  s = -cos_30 * s1 - sin_30 * c1; c =  sin_30 * s1 - cos_30 * c1; break;\n    case 8:  s = -sin_30 * s1 - cos_30 * c1; c =  cos_30 * s1 - sin_30 * c1; break;\n    case 9:  s = -c1;                        c =  s1;                        break;\n    case 10: s =  sin_30 * s1 - cos_30 * c1; c =  cos_30 * s1 + sin_30 * c1; break;\n    case 11: s =  cos_30 * s1 - sin_30 * c1; c =  sin_30 * s1 + cos_30 * c1; break;\n    }\n    \n    return vec2(s, c);\n}\nfloat sine(float x) { return sincos(x).x; }\n/* Optimized Taylor approximation. *\nfloat error_mult = 1e5;\nfloat sine(float x)\n{        \n    const float tau =     6.2831853071795862;\n    const float inv_tau = 0.1591549430918953;\n    \n    float X = fract(x*inv_tau);\n       \n    switch (int(X * 4.))\n    {                                              // Quadrants:\n    case 0: X = X                    * tau; break; // first\n    case 1: X = (.25 - (X - .25))    * tau; break; // second\n    case 2: X = (-(X - .5))          * tau; break; // third\n    case 3: X = (-(.25 - (X - .75))) * tau; break; // fourth\n    }\n\n    float xx = X*X;\n    const float a0 =  1.,\n                a1 = -0.166666665811,\n                a2 =  0.008333320401,\n                a3 = -0.000198407018014,\n                a4 =  0.0000027522394147,\n                a5 = -0.00000002384080041;\n\n    return (((((a5 * xx + a4) * xx + a3) * xx + a2) * xx + a1) * xx + a0) * X;\n}\n/* Taylor approximation *\nfloat error_mult = 2e5;\nfloat sine(float radians)\n{    \n    const float TAU = 6.2831853071795862;\n    \n    // Wrap up argument\n    radians = \n        radians >= 0. ?\n            mod(radians, TAU) :\n            mod(radians, -TAU);\n\n    // Minimize error for values >= PI.\n    radians = \n        radians >= PI ?\n            radians - TAU :\n            radians;           \n    // Minimize error for values <= -PI.\n    radians = \n        radians <= -PI ?\n            radians + TAU :\n            radians;\n\n    float xx = radians * radians,\n          power = xx * radians,\n          factorial = 1., m = 2.;\n\n    for (float idx = 0.; idx < 9.; idx += 1.)\n    {\n        factorial *= -m * (m+1.); m += 2.; \n        radians += power / factorial; power *= xx;       \n    }\n\n    return radians;\n}\n/* Source: https://www.shadertoy.com/view/7d23D1 *\nfloat error_mult = 1e2;\nfloat sine(float x)\n{\n  const float PI_ = 3.1415926535898;\n  const float PI_2 = 1.5707963267949; // PI/2\n  const float INVPI = 0.31830988618379; // 1/PI\n  const float K1 = 3.4336293856408; // 16 - 4*PI\n  const float K2 = -6.8672587712817; // 8*PI - 32\n  const float K3 = 0.29203673205103; // 16 - 5*PI\n  // The following costs 9 MULs, 3 ADDs, 3 SUBs and 2 FLOORs (optimizations are welcome)\n  float line = INVPI*x;\n  float stair = floor(line);\n  float saw = line - stair;\n  float wave = saw*(saw*(saw*(saw*K1 + K2) + K3) + PI_);\n  float square = 1.0-2.0*(stair - 2.0*floor(0.5*line));\n  return square*wave;\n}\n/* Source: https://www.shadertoy.com/view/4sGyRD *\nfloat error_mult = 1e1;\nfloat sine(float x)\n{\n    const float pi  =  3.1415926535897932384626433832795;\n    const float pi2 =  6.283185307179586476925286766559;\n    const float b   =  1.2732395447351626861510701069801;\t//  4 / pi\n    const float c   = -0.4052847345693510857755178528389;\t// -4 / pi^2\n\tx = mod(x, pi2) - pi;\n    float s = b * x + c * x * abs(x); // mul mul mad, abs is free\nreturn -s;\n}\n/* Source: https://www.shadertoy.com/view/DtX3Rf *\nfloat error_mult = 1e1;\nfloat sine(float v) {\n    v /= 3.1415926538; // optional - period of 2pi\n    v = 2.0 * fract(v / 2.0);\n    return v <= 1.0 ? -4.0 * v * (v - 1.0) : 4.0 * (v - 1.0) * (v - 2.0);\n}\n/* Source: https://www.shadertoy.com/view/DtX3Rf (spalmer improvment) *\nfloat error_mult = 1e2;\nfloat sine(float v) {\n    v /= 3.1415926538; // optional - period of 2pi\n    v = 2.0 * fract(v / 2.0);\n    v = v <= 1.0 ? -4.0 * v * (v - 1.0) : 4.0 * (v - 1.0) * (v - 2.0);\n    v *= .775 + .225 * abs(v);\n    return v;\n}\n/* Source: @spalmer comment *\nfloat error_mult = 1e2;\nfloat sinus(float x) \n{\n    x *= 0.1591549430918953; // 1./(2.*PI)\n\tx -= floor(x); // frac range reduction\n\tx = 4.*x - 2.;\n\tx *= abs(x) - 2.;\n\treturn x;\n}\nfloat sine(float x)\n{\n\tx = sinus(x);\n\tx *= .775 + .225 * abs(x);\n\treturn x;\n}\n/* Source: https://www.youtube.com/watch?v=kkMt4lrJzs8 *\nfloat error_mult = 1e2;\nfloat sine(float x) \n{\n\treturn (16.*x*(PI - x)) / (5.*PI*PI-4.*x*(PI-x));\n}\n/* Source: https://www.youtube.com/watch?v=kkMt4lrJzs8 *\nfloat error_mult = 1e2;\nfloat sinus(float x)\n{\n    float x2 = x * x;\n    float x3 = x2 * x;\n    float x5 = x3 * x2;\n    \n    return x - x3 / 6. + x5 / 120.;\n}\nfloat sine(float x) \n{\n    x = mod(x, 2.*PI);\n\tfloat k = floor(x * 2. / PI);\n    float y = x - k * PI * 0.5;\n    int quadrant = int(k) % 4;\n    \n    switch(quadrant)\n    {\n    case 0: return sinus(y);\n    case 1: return sinus(PI * 0.5 - y);\n    case 2: return -sinus(y);\n    case 3: break;\n    }\n    return -sinus(PI * 0.5 - y);\n}\n/**\nfloat error_mult = 1e1;\nfloat sine(float x)\n{\n    const float invTAU = 0.1591549430918953;  // 1/(2*PI)\n          x = x * invTAU;                     // scale T so that seq 0, 1, 2,... maps to 0, TAU, 2.*TAU, ...\n          x = fract(x);                       // wrap T in range [0; TAU];\n    float y = x;                              // y range is [0; 1]\n          y = 4.* y - 2.0;                    // max from [0; 1] to [-2; 2]\n          y = y > 0. ?                        // make approximate sine shape\n              (y-1.)*(y-1.)-1.  :             // second half of phase\n              1.-((y+1.)*(y+1.));             // first half of phase\n    return y;            \n}\n/**\nfloat error_mult = 1e1;\nfloat sine(float x)\n{\n    float e = 1.733;\n    const float invTAU = 0.1591549430918953;  // 1/(2*PI)\n          x = x * invTAU;                     // scale T so that seq 0, 1, 2,... maps to 0, TAU, 2.*TAU, ...\n          x = fract(x);                       // wrap T in range [0; TAU];\n    float y = x;                              // y range is [0; 1]\n          y = 4.* y - 2.0;                    // max from [0; 1] to [-2; 2]\n          y = y > 0. ?                        // make approximate sine shape\n              pow(abs(y-1.), e)-1.  :         // second half of phase\n              1.-pow(abs(y+1.), e);           // first half of phase\n    return y;            \n}\n/* https://www.shadertoy.com/view/ctjyzG *\nfloat error_mult = 2e1;\nfloat sine(float x)\n{\n    float a = abs(mod(x/PI-.5,2.)-1.);\n    return a*a*(3.-2.*a)*2.-1.;\n}\n/* https://www.shadertoy.com/view/4sd3zM *\nfloat error_mult = 1e2;\nfloat sine(float x)\n{  \n    x /= 2.*PI;\n    // approximation of sine avoiding cumbersome pi-constant\n    //return sign(.5-fract(x))*(1.-pow(abs(2. * fract(x*2.) - 1.), 1.75)); // original\n    return sign(.5-fract(x))*(1.-pow(abs(2. * fract(x*2.) - 1.), 1.74395));   \n}\n/* https://www.shadertoy.com/view/4sd3zM (by coyote) *\nfloat error_mult = 1e3;\nfloat sine(float x)\n{\n    // Bhaskara I as sine\n    float a = mod(x, PI), b;\n    //original formula\n    //y2 = sign(mod(U.x,2.*PI) - PI) * 16.*a*(a-PI) / (5.*PI*PI + 4.*a*(a-PI));\n    a *= a - PI;\n    a = 3.999 * a;\n    b = mod(x,2.*PI) < PI ? -a-a : a+a;\n    return (b+b) / (5.*PI*PI + a);\n}\n/* https://www.shadertoy.com/view/dt2cRV (by ENDESGA) *\nfloat error_mult = 1e2;\nfloat sine(float x)\n{\n    const float pi = 3.1415926535897932;\n    const float tau = 6.2831853071795862;\n    const float tausqr = tau * tau;\n    const float pi_d2 = pi * .5;\n    \n    float px = mod(x + pi, tau);\n    x = (px < 0.) ? (pi - (px + tau)) : (pi - px);\n    if (px >= pi) {\n        x += pi_d2;\n        return -(4. - (5. * tausqr) / (tausqr + (4. * x * x)));\n    } else {\n        x -= pi_d2;\n        return -((5. * tausqr) / (tausqr + (4. * x * x)) - 4.);\n    }\n}\n/**\nfloat error_mult = 1e3;\nfloat sine(float radians)\n{    \n    const float TAU = 6.2831853071795862;\n    \n    // Wrap up argument\n    radians = \n        radians >= 0. ?\n            mod(radians, TAU) :\n            mod(radians, -TAU);\n\n    // Minimize error for values >= PI.\n    radians = \n        radians >= PI ?\n            radians - TAU :\n            radians;           \n    // Minimize error for values <= -PI.\n    radians = \n        radians <= -PI ?\n            radians + TAU :\n            radians;\n\n    const float pi_sqr = 9.8696044010893586;\n    \n    float y = 1., xx = radians*radians;\n    for (float k = 1.; k < 256.; k += 1.)\n    {\n        y *= 1. - xx / (k*k*pi_sqr);\n    }\n    \n    return radians*y;\n}\n/**/\n\nfloat error(float x)\n{\n    return sin(x) - sine(x);\n}\n\nfloat cosine(float radians)\n{\n    const float TAU = 6.2831853071795862;\n    return sine(radians + TAU*0.25);\n}\n\nfloat tangens(float radians)   { return sine(radians) / cosine(radians); }\nfloat cotangens(float radians) { return cosine(radians) / sine(radians); }\nfloat secant(float radians)    { return 1./cosine(radians); }\nfloat cosecant(float radians)  { return 1./sine(radians); }\n\n#define T ( triangleOSC(0.1, 16., iTime * .5) )\nint func_idx = 0;\nfloat explicit(float x) \n{ \n    if (func_idx == 0)\n        return sin(T*x);\n    if (func_idx == 1)\n        return sine(T*x);\n    else\n        return error_mult*error(T*x);\n}\nfloat explicitSDF(\n    in vec2 NDC,\n    in float pixel_size,\n    in float thickness)\n{\n    float quality = 4.,  \n          order = thickness + quality,\n          minimal_distance = 9e5;\n          \n    vec2 B = \n        vec2(NDC.x-order*pixel_size,\n             explicit(NDC.x-order*pixel_size));\n      \n    for (float i = -order + 1.; i <= order; i += 1.)\n    {\n        vec2 E = vec2(B.x + pixel_size, explicit(B.x + pixel_size));\n        minimal_distance = \n            min(minimal_distance, segmentSDF(NDC, B, E, 0.));\n        B = E;\n    }\n    \n    return minimal_distance - pixel_size * thickness;\n}\n\nvec3 scene( in vec2 NDC )\n{\n    float ps = 4./iResolution.y,\n          thin = iMouse.z > 0. ? 0.008 : 0.004;\n\n    vec3 color = vec3(1);\n         color = mix( color, vec3(0.8), SMAA(cellsSDF(NDC)+thin) );\n         color = mix( color, vec3(0), SMAA(x_axisSDF(NDC)+thin) );\n         color = mix( color, vec3(0), SMAA(y_axisSDF(NDC)+thin) ); \n         \n         /* Approximation */\n         func_idx = 1;\n         color = mix(color, vec3(1,0,0), SMAA(explicitSDF(NDC, ps, ps)+thin));\n         /* sin(x) */\n         func_idx = 0;\n         color = mix(color, vec3(0,0,1), SMAA(explicitSDF(NDC, ps, ps)+thin));\n         /* Error */\n         func_idx = 2;\n         color = mix(color, vec3(0,.5,.5), SMAA(explicitSDF(NDC, ps, ps)+thin));\n\n         /* Stability check. */\n         color = mix( color, vec3(1,0,1), SMAA(diskSDF(NDC, 1.4*vec2(tangens(sine(iTime)), 1.4*cosine(iTime)), 3.*UNIT)) );\n         color -= SMAA(diskSDF(NDC, 1.4*vec2(tan(sin(iTime)), 1.4*cos(iTime)), UNIT)); \n  \n    return color;\n}\n\nvec3 mag_scene(vec2 NDC, vec2 pos, float mag, inout vec3 color)\n{\n    float r = 1., s = 0.1;\n    \n    //color = mix(color, scene((NDC-pos)/mag + pos), SMAA(diskSDF(NDC, pos, r))); // L2-disk\n    color = mix(color, scene((NDC-pos)/mag + pos), SMAA(squareSDF(NDC, pos, r) - s)); // L2-square\n    //color = mix(color, scene((NDC-pos)/mag + pos), SMAA(rhombusSDF(NDC, pos, r))); // L1-disk, rhombus\n    // Try another shapes.\n    \n    return color;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0), false),\n         MP = map_to_centered_ndc(iMouse.xy, SCENE_SCALE, vec2(0), false);\n    \n    vec3 color = vec3(1);\n         color = scene(NDC);\n         \n    if (iMouse.z > 0.)\n        color = mag_scene(NDC, MP, 10., color);\n\n    O = vec4(color, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\nfloat triangleOSC(float min, float max, float T)\n{\n    const float invTAU = 0.1591549430918953; // 1/(2*PI)\n          T *= invTAU;          // scale T so that seq 0, 1, 2,... maps to 0, TAU, 2.*TAU, ...\n          T = fract(T);         // wrap T in range [0; TAU];\n    float y = T;                // y range is [0; 1]\n          y = 2.* y - 1.0;      // max from [0; 1] to [-1; 1]\n          y = y > 0.0 ? -y : y; // invert second half of period, new range [-1; 0]\n          y += 1.;              // shift from [-1; 0] to [0; 1]\n    return min + y*(max - min); // map y from [0, 1] to [min; max]\n}\n\nfloat rhombusSDF(in vec2 NDC, in vec2 C, in float r) \n{ \n    vec2 P = abs(C - NDC);\n    return P.x + P.y - r; \n}\nfloat diskSDF(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\nfloat squareSDF(in vec2 NDC, in vec2 C, in float r) \n{ \n    NDC -= C;\n    NDC = abs(NDC) - vec2(r); \n    return length(max(NDC,vec2(0.))) + min(max(NDC.x, NDC.y),0.0);\n}\nfloat segmentSDF(in vec2 NDC, in vec2 B, in vec2 E, in float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}\nfloat y_axisSDF(vec2 NDC) { return abs(NDC.x); }\nfloat x_axisSDF(vec2 NDC) { return abs(NDC.y); }\nfloat vertical_lineSDF(vec2 NDC, float x0) { return abs(NDC.x-x0); }\nfloat horizontal_lineSDF(vec2 NDC, float y0) { return abs(NDC.y-y0); }\nfloat cellsSDF(vec2 NDC)\n{\n    //NDC *= 2.; // Finer cells\n    NDC = fract(NDC);\n    NDC = fract(min(NDC, 1. - NDC));\n    return\n        min(vertical_lineSDF(NDC, 0.), horizontal_lineSDF(NDC, 0.));\n}","name":"Common","description":"","type":"common"}]}