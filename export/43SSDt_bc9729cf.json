{"ver":"0.1","info":{"id":"43SSDt","date":"1711192566","viewed":81,"name":"Eye of Julia","username":"Shiyumemeguri","description":"A very stunning julia effect was produced by inverting the Mandelbrot set and using fixed C","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","mouse","mandelbrot","orbit","trap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Modify by Shiyumemeguri \n// Base Anthony Hall https://www.shadertoy.com/view/ssfyR4\n\n\n// Lower these to speed up\nconst int SS = 2;\nconst float maxIters = 600.0;\n\n// The amount of time spent on each shape variation\nconst float shapeDuration = 8.0;\n\nconst vec2 center = vec2(0.0, 0.0);\n\n\nconst float pi  = radians(180.0);\nconst float twoPi = radians(360.0);\n\n// Globals set in mainImage\nfloat leafOrbitOffset; \nfloat orbitTrapInfluence;\nfloat colorOffset;\n\nconst int numAnimations = 5;\n// Other interesting parameters\nconst vec3 cAndScales[numAnimations] = vec3[](\n    vec3(0.3, 0.0, 2.0), // eyes\n    vec3(-1.43641, 0.0, 120.0), // circle2\n    vec3(-1.81, 0.0, 200.0), // circle\n    vec3(-1.822752, 0.0, 600.0), // broken eyes\n    vec3(-1.8605, 0.0, 80.0) // eyes2\n);\nvec2 c2 = vec2(0.3, 0.0); // eyes\nfloat scale = 2.0;\n\nvec2 complexMultiply(vec2 c1, vec2 c2) {\n    return vec2(\n    \tc1.x*c2.x - c1.y*c2.y,\n    \tc1.x*c2.y + c1.y*c2.x);\n}\n\n// \"Triangular\" distance from origin\nfloat triangleOrbit(vec2 point)\n{\n    point.y = abs(point.y);\n    return max(-point.x, dot(point, vec2(0.5, 0.5 * sqrt(3.0))));\n}\n\n// \"Leafular\" (??) distance from orgin for positive offset values only - still produces\n// interesting results with negative offset values\n// Increasing offset makes it less circular and more leaf-like\nfloat leafOrbit(vec2 point)\n{\n    point.y = abs(point.y);\n    point.y += leafOrbitOffset;\n    float leafDist = length(point) - leafOrbitOffset;\n    return leafDist;\n}\n\n// Oscillating \"glowing\" color band\nvec3 colorBand(float t, vec3 exponents)\n{\n    float phase = t * twoPi;\n    return pow(vec3(0.5 - 0.5 * cos(phase)), exponents);\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 mandelbrot(vec2 C)\n{\n\tfloat denom = C.x*C.x + C.y*C.y;\n\tC /= denom;\n    vec2 z = C;\n    //C = (iMouse.xy == vec2(0)) ? vec2(0.5*cos(iTime) - 0.25, 0.5*sin(iTime) + 0.25) : 2. * iMouse.xy / iResolution.xy - 1.;\n        \n    float zz = 0.0f;   \n    \n    float outerDist = 1e5; // Orbit trap outside the set\n    float innerDist = 1e5; // Orbit trap inside the set\n    float iters;\n    \n    // The magnitude at which we consider a point divergent. Higher values are better\n    // for the smooth iteration count method (so Z^2 becomes much more significant than C)\n    // at the cost of a few more iterations.\n    const float bound = 32.0;\n    \n    // This offset corrects the optimized version of the smooth iteration formula\n    // so it is equivalent to the non-optimized version\n    const float smoothOffset = -log2(log2(bound)) - 1.0;\n    \n    for (iters = 1.0; iters < maxIters; iters ++)\n    {\n        z = complexMultiply(z, z) + c2;\n        zz = dot(z, z);\n        if (zz > bound * bound)\n            break;\n        \n        // This is a really weird function but it produces a good result\n        outerDist = min(outerDist, \n            log( 0.4 * abs( log( abs( log( leafOrbit(5.0 * z) ) ) ) ) + 0.04) );\n        innerDist = min(innerDist, triangleOrbit(z));\n    }\n    if (iters == maxIters) // In set\n    {  \n        //float t = log(innerDist + 0.00002) - 0.12 * iTime + 0.6; // old\n        float t = 300.0 * innerDist - 0.075 * iTime + 0.45;\n        return colorBand(t, vec3(6.0, 20.0, 1.5));\n    }\n    else // Not in set\n    {\n        // See Inigo Quilez's article on smooth iteration count\n        // https://iquilezles.org/articles/msetsmooth\n        // Orbit distance gets added slightly to the smooth iteration count\n        float smoothIters = iters - (log2(log2(zz)) + smoothOffset);\n        float t = -0.25 * orbitTrapInfluence * outerDist\n            + 0.9 * log2(smoothIters) + 0.5 * (1.0 - orbitTrapInfluence) + colorOffset;\n\n        vec3 color = vec3(10.0, 2.5, 0.75);\n        vec3 hsv = rgb2hsv(color);\n        hsv.x = sin(iTime * 0.3);\n\n        vec3 rgb = hsv2rgb(hsv);\n        return colorBand(t, color);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Oscillate between different orbit trap shapes based on time/mouse\n    const float[3] offsets = float[3](-2.1, 1.6, -1.0);\n    float shape;\n    if (iMouse.z > 0.0)\n    {\n        shape = 3.0 * iMouse.x / iResolution.x;\n        colorOffset = iMouse.y / iResolution.y - 0.5;\n    }\n    else\n    {\n        shape = mod(iTime / shapeDuration + 0.2, 3.0);\n        colorOffset = 0.0;\n    }   \n    leafOrbitOffset = offsets[int(shape)] + 0.4 * fract(shape);\n    orbitTrapInfluence = smoothstep(0.0, 0.2, 0.5 - abs(fract(shape) - 0.5));     \n\n    // animation\n    int index = int(mod(floor(iTime / 5.0), float(numAnimations)));\n    //vec3 cAndScale = cAndScales[index];\n    vec3 cAndScale = cAndScales[0];\n    c2 = cAndScale.xy;\n    scale = cAndScale.z;\n\n    vec3 color = vec3(0.0);\n    for (int y = 0; y < SS; y++)\n    {\n        for (int x = 0; x < SS; x++)\n        {\n            const float increment = 1.0 / float(SS);\n            const float offset = 0.5 * increment - 0.5;\n            vec2 newFragCoord = fragCoord + offset + increment * vec2(x, y);\n            vec2 uv = (2.0 * newFragCoord - iResolution.xy) / iResolution.y;\n            uv *= scale;\n            vec2 C = center + uv;\n            color += mandelbrot(C);\n        }\n    }\n    color /= float(SS * SS);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}