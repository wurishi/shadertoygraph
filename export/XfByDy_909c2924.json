{"ver":"0.1","info":{"id":"XfByDy","date":"1722888619","viewed":28,"name":"Smooth curve","username":"Yeeun","description":"Smooth curve with Monte Carlo Sampling","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["curve"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_SAMPLES 500\n#define GLITCH_FREQUENCY 0.1\n#define GLITCH_AMPLITUDE 0.2\n#define ANIMATION_SPEED 1.0\n#define WAVE_AMPLITUDE 0.3\n#define BRIGHTNESS 2.0  // Increase brightness factor\n\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nvec2 glitch(vec2 p, float time) {\n    float noise = random(p + time);\n    if (noise < GLITCH_FREQUENCY) {\n        float glitchAmount = (noise / GLITCH_FREQUENCY) * GLITCH_AMPLITUDE;\n        p.x += sin(time * 50.0 + p.y * 10.0) * glitchAmount;\n        p.y += cos(time * 60.0 + p.x * 12.0) * glitchAmount;\n    }\n    return p;\n}\n\nvec2 cubicBezier(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t) {\n    float t2 = t * t;\n    float t3 = t2 * t;\n    float mt = 1.0 - t;\n    float mt2 = mt * mt;\n    float mt3 = mt2 * mt;\n    return p0 * mt3 + p1 * 3.0 * mt2 * t + p2 * 3.0 * mt * t2 + p3 * t3;\n}\n\nfloat distToLine(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Normalize UV coordinates to range [-1, 1]\n    uv = uv * 2.0 - 1.0;\n    \n    // Assigned start and end points\n    vec2 p0 = vec2(-0.8, 0.0);  // Start point\n    vec2 p3 = vec2(0.8, 0.0);   // End point\n    \n    // Animate middle control points\n    float time = iTime * ANIMATION_SPEED;\n    vec2 p1 = vec2(-0.4, sin(time) * WAVE_AMPLITUDE);\n    vec2 p2 = vec2(0.4, sin(time + 3.14159) * WAVE_AMPLITUDE);\n    \n    float lineThickness = 0.003;\n    float smoothing = 0.001;\n    \n    vec3 colorSum = vec3(0.0);\n    \n    // Monte Carlo sampling loop\n    for (int i = 0; i < NUM_SAMPLES; i++)\n    {\n        float t = float(i) / float(NUM_SAMPLES);\n        \n        // Glitched curve points with random offsets\n        vec2 glitched_p0 = glitch(p0 + random(uv + iTime) * 0.01, iTime);\n        vec2 glitched_p1 = glitch(p1 + random(uv + iTime) * 0.01, iTime);\n        vec2 glitched_p2 = glitch(p2 + random(uv + iTime) * 0.01, iTime);\n        vec2 glitched_p3 = glitch(p3 + random(uv + iTime) * 0.01, iTime);\n        \n        vec2 glitchedCurvePoint = cubicBezier(glitched_p0, glitched_p1, glitched_p2, glitched_p3, t);\n        \n        // Calculate the distance from the pixel to the glitched curve\n        float distToGlitched = distToLine(uv, p0, glitchedCurvePoint);\n        \n        colorSum += smoothstep(lineThickness + smoothing, lineThickness - smoothing, distToGlitched) * vec3(1.0 - float(i) / float(NUM_SAMPLES));\n    }\n    \n    vec3 finalColor = colorSum / float(NUM_SAMPLES);\n    \n    finalColor *= BRIGHTNESS;\n    \n    fragColor = vec4(finalColor, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}