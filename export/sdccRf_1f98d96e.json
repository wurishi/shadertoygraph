{"ver":"0.1","info":{"id":"sdccRf","date":"1655054872","viewed":369,"name":"Tribute to Light Away Game","username":"Sir_Dudard","description":"Light Away is my very first game. It was my key to the industry, so a few years after publishing it I decided to prepare a shader version of the core gameplay mechanic. Light Away was published as a hyper-casual arcade game for mobile platforms. \n","likes":16,"published":1,"flags":96,"usePreview":0,"tags":["game","collision","sdf","field","of","view"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MtBSzw","filepath":"https://soundcloud.com/user-814644988/gurdonark-homework?si=38d81598df4744e6a32749f1b38db372&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","previewfilepath":"https://soundcloud.com/user-814644988/gurdonark-homework?si=38d81598df4744e6a32749f1b38db372&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Created by Sir Dudard\n//---------------------\n//PC PLATFORM AND MOUSE RECOMENDED TO PLAY\n//---------------------\n//SDFs: https://www.shadertoy.com/playlist/MXdSRf\n//PointTriangleTest:https://www.shadertoy.com/view/4tXXzn\n//FontIntegration:https://www.shadertoy.com/view/WdBXWd\n//GAMEPLAY:\n//Press LMB to move wall and hide from the light!\n\n#define phoneMaskColor vec4(0.15686, 0.15686, 0.15686, 1.)\n\n#define transitionDuration 1.\n\n#define levelTransitionDuration 0.25\n\nvec4 DeadAnimation(in vec2 uv, in float t)\n{\n    float ct = clamp(t,0.,splashTransitionDuration);\n    float size = mix(0.,2., pow(ct, 0.5));\n    float r = S(size + 0.005, size - 0.005, length(uv)) ;\n    return vec4(r);\n}\n\nvec4 PlayerColor(vec2 uv, vec4 lightColor)\n{\n    vec2 parallelogram1Offset = vec2(0.045,-0.048);\n    vec2 parallelogram2Offset = vec2(-0.025,-0.0);\n\n    vec2 smallTriangleOffset = vec2(-0.008,-0.008);\n\n    float mainTriangle = sign(EquilateralTriangleSDF(uv-playerPos, 0.045));\n    float smallTriangle = sign(EquilateralTriangleSDF(uv-playerPos - smallTriangleOffset, 0.018));\n    \n    float parallelogram1 = sign(ParallelogramSDF(uv-playerPos-parallelogram1Offset , 0.004, 0.08, -0.05));\n    float parallelogram2 = sign(ParallelogramSDF(uv-playerPos-parallelogram2Offset , 0.007, 0.08, 0.05));\n    float combinedParall = (1.-(parallelogram1 + parallelogram2));\n    \n    float line = combinedParall + parallelogram1;\n    \n    float combined = (1.-mainTriangle)*((smallTriangle*parallelogram1) + line);\n        \n    vec4 color = mix(white, vec4(0.95,0.,0.,0.2), sign(lightColor));\n    \n    return vec4(clamp01(combined));\n}\n\nvec4 BackgroundColor(vec2 uv, float st)\n{\n    uv.y = (uv.y + 1.0 )/2.;\n    \n    float currentTimeFrameIndex = floor(st);\n    float nextTimeFrameIndex = currentTimeFrameIndex + 1.;\n    \n    float currentRandom = Rand(currentTimeFrameIndex);\n    float nextRandom = Rand(nextTimeFrameIndex);\n\n    int currentBackgroundIndex = int(floor(currentRandom * float(levelBackgroundsCount))); \n    int nextBackgroundIndex = int(floor(nextRandom * float(levelBackgroundsCount))); \n\n    float transitionStartRatio = 1.- transitionDuration/levelDuration; \n    float colorMask = smoothstep(transitionStartRatio,1.0, fract(st));\n\n    vec3 currentBottomColor = backgroundBottomColors[currentBackgroundIndex];\n    vec3 nextBottomColor = backgroundBottomColors[nextBackgroundIndex];\n    vec3 bottomColor = mix(currentBottomColor,nextBottomColor,colorMask);\n    \n    vec3 currentTopColor = backgroundTopColors[currentBackgroundIndex];\n    vec3 nextTopColor = backgroundTopColors[nextBackgroundIndex];\n    vec3 topColor = mix(currentTopColor,nextTopColor,colorMask);\n\n    vec3 color = mix(bottomColor,topColor, uv.y);\n\n    return vec4(color, 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    AppState s;\n    loadState( iChannel1, s );\n\n    vec2 samplerUV = fragCoord.xy / iResolution.xy;\n    vec2 uv = (2.0* fragCoord- iResolution.xy)/iResolution.y;\n    \n    float t = iTime;\n        \n    if((s.stateID == GS_SPLASH || \n       s.stateID == GS_DEAD))\n    {\n        t = s.timeFailed;\n    }\n\n    //Calculate objects\n    vec4 background = BackgroundColor(uv,  (t - s.timeStarted) / levelDuration);\n    vec4 particles = texture(iChannel2, samplerUV);\n    vec4 lightsWall = texture(iChannel3, samplerUV);\n    vec4 player = PlayerColor(uv,lightsWall);\n        \n    //Render\n    vec4 gameColor = Blend(particles,background);\n    gameColor = Blend(lightsWall, gameColor);\n    gameColor = Blend(player, gameColor); \n    \n    if(s.stateID == GS_DEAD)\n    {\n        gameColor = Blend(DeadAnimation(uv - playerPos, iTime - s.timeFailed), gameColor);\n    }\n    \n    fragColor = mix(phoneMaskColor,gameColor, step(abs(uv.x * 1.6), 1.0));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"bool PointInTriangle(vec2 A, vec2 B, vec2 C, vec2 P)\n{\n    float s1 = C.y - A.y;\n    float s2 = C.x - A.x;\n    float s3 = B.y - A.y;\n    float s4 = P.y - A.y;\n\n    float w1 = (A.x * s1 + s4 * s2 - P.x * s1) / (s3 * s2 - (B.x-A.x) * s1);\n    float w2 = (s4 - w1 * s3) / s1;\n    return w1 >= 0. && w2 >= 0. && (w1 + w2) <= 1.;\n}\n\nfloat DeathCondition(in float st, in float t, in Wall wall, in vec2 playerPos)\n{\n    float s = 1./lightsCount;\n\n    for(float i = 0.; i<1.; i+=s)\n    {\n        float bt = fract(t * lampSpeed + i);\n        float yOffset = mix(-0.2,0.2,Rand(i));\n        float x = RandSide(i) * horizontalMax;\n        float y = yOffset + 2. - bt *8.;\n        \n        if(y < GetStartGameLightsOffset(st,t,st + levelEnterDuration))\n        {\n            continue;\n        }\n        \n        Lamp l;\n        l.pos = vec2(x, y);\n        l.la = playerPos;\n        l.a = mix(minAngle,maxAngle,Rand(i));\n        l.r = mix(minRadius,maxRadius,Rand(i));\n\n        if(length(l.pos-playerPos) < l.r)\n        {\n            vec2 AonRadius;\n            vec2 BonRadius;\n    \n            GetCollisionMaskPoints(wall, l, AonRadius, BonRadius, 30.);\n            \n            float distToWallA = length(l.pos-wall.posA);\n            float distToWallB = length(l.pos-wall.posB);\n            \n            vec2 upPlayer = playerPos + vec2(0.,0.03);\n            if(!PointInTriangle(wall.posA,wall.posB,AonRadius,upPlayer) &&\n               !PointInTriangle(wall.posB,AonRadius,BonRadius,upPlayer))\n               {\n                   return 1.;\n               }\n               \n            vec2 leftPlayer = playerPos + vec2(-.02,-0.015);\n            if(!PointInTriangle(wall.posA,wall.posB,AonRadius,leftPlayer) &&\n               !PointInTriangle(wall.posB,AonRadius,BonRadius,leftPlayer))\n               {\n                   return 1.;\n               }\n               \n            vec2 rightPlayer = playerPos + vec2(0.02,-0.015);\n            if(!PointInTriangle(wall.posA,wall.posB,AonRadius,upPlayer) &&\n               !PointInTriangle(wall.posB,AonRadius,BonRadius,upPlayer))\n               {\n                   return 1.;\n               }\n        }\n    }\n    \n    return 0.;\n}\n\nvoid UpdateGame(inout AppState s, in float t, in vec2 m)\n{\n    if (s.stateID == GS_SPLASH) // splash\n    {        \n        bool canStartGame = length(s.iMousePos - m) > C_MOUSE_EPSILON;\n\n        if (canStartGame)\n        {\n            SetStateGame(s, iTime);\n        }             \n    }\n    else if (s.stateID == GS_GAME) // game\n    {\n       vec2 mScreenSpace = (2.*m-iResolution.xy)/iResolution.y;\n       if(DeathCondition(s.timeStarted, t, GetWall(mScreenSpace, playerPos), playerPos) > 0.5)\n       {\n           SetStateDeath(s, t, m);\n       }\n    }\n    else if (s.stateID == GS_DEAD) // death animation\n    {\n        if (t > s.timeFailed + splashTransitionDuration) \n        {            \n            SetStateSplash(s,m);\n        }\n    }\n     \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    if ( fragCoord.x >= 8. || fragCoord.y >= 8. ) \n    {        \n        discard;    \n    }\n    \n    AppState s;\n    loadState( iChannel0, s );\n        \n    float t = iTime;\n    vec2 m = iMouse.xy;\n    \n    if (iFrame <= 0)\n    {\n \t\tSetStateSplash(s,m);\n\t} \n    else\n    {\n        UpdateGame(s,t,m);\n    }\n        \n  \n    fragColor = saveState( s, fragCoord, iFrame, iTime );\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define clamp01(x) clamp(x,0.,1.)\n#define S(a,b,t) smoothstep(a,b,t)\n\n#define white vec4(1.)\n#define darkColor vec3(0.23)\n\n#define playerDeadZoneRadius 0.1\n#define levelDuration 10.\n#define splashTransitionDuration 2.\n#define levelEnterDuration 25.\n\n#define lampSpeed 0.05\n\n#define lightsCount 5.;\n\n#define minRadius 0.7\n#define maxRadius 1.2\n\n#define minAngle 10.\n#define maxAngle 40.\n\n#define wallWidth 0.008\n#define wallPlacementRadius 0.6\n#define wallLength 0.3\n\nconst float degToRad = 0.01745;\nconst int levelBackgroundsCount = 4;\n\nconst float horizontalMax = 0.63;\n\nvec3[levelBackgroundsCount] backgroundBottomColors = vec3[](\nvec3(0.08627451, 0.1333333, 0.1647059),\nvec3(0.2313726, 0.5294118, 0.6),\nvec3(0.09411765, 0.1568628, 0.282353),\nvec3(0., 0.4235294, 0.6901961)\n);\n\nvec3[levelBackgroundsCount] backgroundTopColors = vec3[](\nvec3(0.227451, 0.454902, 0.5019608),\nvec3(0.3921569, 0.1686275, 0.4509804),\nvec3(0.8980392, 0.1686275, 0.3647059),\nvec3(0., 0.7058824, 0.8588235)\n);\n\nvec2 playerPos = vec2 (0.,-0.65);\n\nmat2 rotMat(float a)\n{\n\tfloat c = cos(a), s = sin(a);\n    return mat2(c, s,-s, c);\n}\n\nfloat angleOfVec(in vec2 v)\n{\n    return atan(v.x,v.y);\n}\n\nfloat Rand(float i)\n{\n    return fract(sin(i * 23325.) * 35543.);\n}\n\nfloat RandSide(float i)\n{\n    return sign(Rand(i*2323.)*2.-1.);\n}\n\nfloat Random21(vec2 p)\n{\n    p = fract(p*vec2(242.46,234.960));\n    p += dot(p,p + 23.64);\n    return fract(p.x*p.y);\n}\n\nvec2 Random22(vec2 p)\n{\n    float n = Random21(p);\n    return vec2(n, Random21(p + n));\n}\n\nfloat PieSDF(in vec2 p, in vec2 c, in float r )\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,r) );\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat LineSDF( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba);\n}\n\nfloat EquilateralTriangleSDF(in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat ParallelogramSDF( in vec2 p, float wi, float he, float sk )\n{\n    vec2  e  = vec2(sk,he);\n    float e2 = sk*sk + he*he;\n\n    p = (p.y<0.0)?-p:p;\n    vec2  w = p - e; w.x -= clamp(w.x,-wi,wi);\n    vec2  d = vec2(dot(w,w), -w.y);\n    float s = p.x*e.y - p.y*e.x;\n    p = (s<0.0)?-p:p;\n    vec2  v = p - vec2(wi,0); v -= e*clamp(dot(v,e)/e2,-1.0,1.0);\n    d = min( d, vec2(dot(v,v), wi*he-abs(s)));\n    return sqrt(d.x)*sign(-d.y);\n}\n\nfloat TriangleSDF( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nvec4 Blend(vec4 src, vec4 dst)\n{\n    return vec4(src.xyz * 1. + dst.xyz * (1. - src.w),1.);\n}\n\n//COLLISION\n\nstruct Lamp\n{\n    vec2 pos;\n    vec2 la;\n    float r;\n    float a;\n};\n\nstruct Wall\n{\n    vec2 posA;\n    vec2 posB;\n};\n\nvec2 GetMaxLeft(in Lamp l)\n{\n    vec2 lookAtDir = l.la - l.pos;  \n    mat2 rotation = rotMat(angleOfVec(lookAtDir) - (l.a) * degToRad);\n    return vec2(0.,1.) * rotation;\n}\n\nvec2 GetMaxRight(in Lamp l)\n{\n    vec2 lookAtDir = l.la - l.pos;  \n    mat2 rotation = rotMat(angleOfVec(lookAtDir) + (l.a) * degToRad);\n    return vec2(0.,1.) * rotation;\n}\n\nvoid GetCollisionMaskPoints(Wall wall, Lamp l, out vec2 maxA, out vec2 maxB, in float mult)\n{\n    vec2 wallMiddle = (wall.posA - wall.posB) / 2. + wall.posB;\n    vec2 lightToWall = wall.posA - l.pos;\n    vec2 lookAtDir = l.la - l.pos; \n   \n    vec2 lampToA = wall.posA - l.pos;\n    vec2 lampMaxLeft = GetMaxLeft(l);\n    \n    if(angleOfVec(lampMaxLeft) > angleOfVec(lampToA))\n    {\n        lampToA = lampMaxLeft;\n    }\n    \n    maxA = l.pos + normalize(lampToA) * l.r * mult;\n       \n    vec2 lampToB = wall.posB - l.pos;\n    vec2 lampMaxRight = GetMaxRight(l); \n    \n    if(angleOfVec(lampMaxRight) < angleOfVec(lampToB))\n    {\n        lampToB = lampMaxRight;\n    }\n    \n    maxB = l.pos + normalize(lampToB) * l.r * mult;\n}\n\nWall GetWall(in vec2 m, in vec2 playerPos){\n    vec2 playerToMouse = m-playerPos;\n    vec2 playerToMouseNorm = normalize(playerToMouse);\n    \n    float playerToMouseLength = max(min(length(playerToMouse), wallPlacementRadius),playerDeadZoneRadius);\n\n    vec2 lineMiddle = playerPos + playerToMouseNorm * playerToMouseLength;\n    \n    float halfWallLength = wallLength*0.5;\n    \n    vec2 middleToA = vec2(playerToMouse.y,-playerToMouse.x);\n    vec2 A = lineMiddle + normalize(middleToA) * halfWallLength;\n    \n    vec2 middleToB = vec2(-playerToMouse.y,playerToMouse.x);\n    vec2 B = lineMiddle + normalize(middleToB) * halfWallLength;\n    \n    Wall wall;\n    wall.posA = A;\n    wall.posB = B;\n    \n    return wall;\n}\n\n\n//STATE\n\nconst float C_MOUSE_EPSILON = 10.;\n\n// Game State\nconst float GS_SPLASH = 0.0;\nconst float GS_GAME = 1.0;\nconst float GS_DEAD = 2.0;\n\nstruct AppState\n{\n\tfloat stateID;\n    float timeStarted;  \n    float timeFailed;\n\n    vec2 iMousePos;\n\n    float score;\n    float highscore;\n};\n\nvec4 loadValue( sampler2D tex, int x, int y )\n{\n    return texelFetch( tex, ivec2( x, y ), 0 );\n}\n\nvoid loadState( sampler2D tex, out AppState s )\n{\n    vec4 data;\n\n\tdata = loadValue( tex, 0, 0 );\n    s.stateID = data.x;\n    s.timeStarted = data.y;\n    s.timeFailed = data.z;\n    \n    data = loadValue( tex, 1, 0 );\n    s.iMousePos.x = data.x;\n    s.iMousePos.y = data.y;\n    \n    data = loadValue( tex, 2, 0 );\n    s.score = data.x;\n    s.highscore = data.y;\n}\n\nvoid storeValue( vec2 re, vec4 va, inout vec4 fragColor, vec2 fragCoord )\n{\n    fragCoord = floor( fragCoord );\n    fragColor = ( fragCoord.x == re.x && fragCoord.y == re.y ) ? va : fragColor;\n}\n\nvec4 saveState( in AppState s, in vec2 fragCoord, int iFrame, float iTime )\n{   \n    vec4 ret = vec4(0.);\n\tstoreValue(vec2(0,0), vec4(s.stateID,s.timeStarted,s.timeFailed,0.), ret, fragCoord);  \n    storeValue(vec2(1,0), vec4(s.iMousePos.x,s.iMousePos.y, 0., 0.), ret, fragCoord);    \n\tstoreValue(vec2(2,0), vec4(s.score,s.highscore, 0., 0.), ret, fragCoord);    \n\n\treturn ret;\n}\n\nfloat GetStartGameLightsOffset(in float st, in float t, in float mt){\n    return mix(2., -8., clamp01((t - st) / (mt - st)));\n}\n\nvoid SetStateSplash(inout AppState s, in vec2 m)\n{    \n    s.stateID = GS_SPLASH;\n    s.timeStarted = 0.;\n    s.timeFailed = 0.;\n    \n    s.iMousePos = m;\n    \n    s.score = 0.;\n    s.highscore = 0.; \n}\n\nvoid SetStateGame(inout AppState s, in float t)\n{    \n    s.stateID = GS_GAME;\n    s.timeStarted = t;\n    \n    s.score = 0.;\n    s.highscore = 0.; \n}\n\nvoid SetStateDeath(inout AppState s, in float t, in vec2 m)\n{    \n    s.stateID = GS_DEAD;\n    s.timeFailed = t;\n    \n    s.iMousePos = m;\n    \n    s.score = 0.;\n    s.highscore = 0.; \n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define S(a,b,t) smoothstep(a,b,t)\n\nfloat Line(vec2 p, vec2 a, vec2 b)\n{\n    float d = LineSDF(p,a,b);\n    float m = S(.03,.01,d);\n    m *= S(0.9,0.4,length(a-b));\n    return m;\n}\n\nvec2 GetPosition(vec2 id, vec2 offset){\n    vec2 seed = id + offset;\n    vec2 n = Random22(seed) * (iTime*0.5 + 10.);\n   return offset + sin(n) * .4;\n}\n\nfloat DrawField(vec2 uv, float scale)\n{\n    uv *= scale;\n    vec2 gv = fract(uv)- .5;\n    vec2 id = floor(uv);\n    \n    float m = 0.;\n    \n    vec2 p[9];\n    int i = 0;\n    for(float y = -1.; y <= 1.; y++)\n    {\n        for(float x = -1.; x <= 1.; x++)\n        {\n            p[i] = GetPosition(id, vec2(x,y));\n            i++;\n        }\n    }\n    \n    \n    for(int i=0; i<9; i++)\n    {\n        m += Line(gv,p[4],p[i]);\n       \n    }\n    \n     m += Line(gv,p[1],p[3]);     \n     m += Line(gv,p[1],p[5]);     \n     m += Line(gv,p[5],p[7]);\n     m += Line(gv,p[7],p[3]);\n     \n     return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    vec2 uv = (2. * fragCoord - iResolution.xy)/iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution.xy - 0.5;\n    \n    vec2 fieldUV = uv + vec2(t* 0.01,t* 0.01);\n    float field = DrawField(fieldUV,10.);\n    float fieldMask = clamp(S(3.5,0.,length(uv *vec2(1.,2.) + vec2(0.0,-0.5))),0.,1.);\n    field *= fieldMask;\n\n    fragColor = vec4(0.6588, 0.9137, 1.,1.0) * field * 0.3;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n//Lights and wall\n\n#define bulbRadius 0.96\n\nfloat CollisionMask(in vec2 uv, in Wall wall, in Lamp l)\n{\n    float distToWallA = length(l.pos-wall.posA);\n    float distToWallB = length(l.pos-wall.posB);\n\n    vec2 AonRadius;\n    vec2 BonRadius;\n    \n    GetCollisionMaskPoints(wall, l, AonRadius, BonRadius, 1.2);\n\n    if(distToWallA <= l.r && distToWallB <= l.r)\n    {\n        return sign(TriangleSDF(uv,wall.posA,wall.posB,AonRadius))\n             + sign (TriangleSDF(uv,wall.posB,AonRadius,BonRadius));\n    }\n    \n    if(distToWallA <= l.r)\n    {\n        return sign(TriangleSDF(uv,wall.posA,wall.posB,AonRadius));\n    }\n    else if (distToWallB <= l.r)\n    {\n       return sign(TriangleSDF(uv,wall.posB,wall.posA,BonRadius));\n    }       \n    \n    return 1.;\n}\n\nfloat WallMask(in vec2 uv, in vec2 m, out Wall wall)\n{\n    wall = GetWall(m, playerPos);\n    return 1.-sign(LineSDF(uv, wall.posA, wall.posB) - wallWidth);\n}\n\nvec4 WallColor(in vec2 uv, in vec2 m, out Wall wall)\n{\n    return vec4(WallMask(uv,m, wall));\n}\n\nfloat LampMask(in vec2 uv, Lamp l)\n{\n    float lampAngleRad = l.a * degToRad;\n    \n    vec2 lookAtDir = l.la - l.pos; \n        \n    mat2 rotation = rotMat(angleOfVec(lookAtDir) + 0.025);\n    \n    vec2 muv = rotation*(uv-l.pos);\n    \n    return PieSDF(muv, vec2(sin(lampAngleRad),cos(lampAngleRad)), l.r);\n}\n\nfloat LampsMask(in vec2 uv, in float st, in float t, in Wall wall)\n{\n    float mask = 0.;\n    \n    float s = 1./lightsCount;\n\n    for(float i = 0.; i<1.; i+=s)\n    {\n        float bt = fract(t * lampSpeed + i);\n        \n        float yOffset = mix(-0.2,0.2,Rand(i));\n        \n        float x = RandSide(i) * horizontalMax;\n        float y = yOffset + 2. - bt * 8.;\n        \n        if(y < GetStartGameLightsOffset(st,t,st + levelEnterDuration))\n        {\n            continue;\n        }\n        \n        Lamp l;\n        l.pos = vec2(x, y);\n        l.la = playerPos;\n        l.a = mix(minAngle,maxAngle,Rand(i));\n        l.r = mix(minRadius,maxRadius,Rand(i));\n        \n        float lampLight = (1. - length((uv-l.pos)/l.r));\n        \n        float lampMask = clamp01(1.-sign(LampMask(uv,l)));\n       \n        float collisionMask = CollisionMask(uv, wall, l);\n      \n        lampMask *= clamp01(collisionMask);                    \n\n        float lampBulb = S(bulbRadius,bulbRadius + 0.01 ,(1. - length((uv-l.pos))));\n               \n        mask += clamp01(lampBulb + lampLight * lampMask);\n    }\n    \n    return mask;\n}\n\nvec4 LampsColor(in vec2 uv,in float st, in float t, in Wall wall)\n{\n    return vec4(LampsMask(uv, st, t, wall));\n}\n\nvec4 UIColor(in vec2 uv, float st)\n{\n    float ft = fract(st);\n\n    float progress = 1.-sign(LineSDF(uv, vec2(-0.45,0.85), vec2(-0.45 + ft * 0.9,0.85)) - 0.01);    \n    vec4 progressColor = vec4(progress);\n    \n    return clamp01(progressColor);\n}\n\nvec4 UIBackgroundColor(in vec2 uv)\n{\n    float progresBg = 1.-sign(LineSDF(uv, vec2(-0.45,0.85), vec2(0.45,0.85)) - 0.006);\n    vec4 progressBgColor = vec4(darkColor,0.2)* progresBg;\n    \n    return clamp01(progressBgColor);\n}\n\n//FONTS\n\n#define AA_QUALITY 3\n\n// allow a little bleed between pixels - this looks more photographic, but blurrier\n#define AA_ROUND true\n#define AA_ROUND_RADIUS 1.1071\n\n\n// Font Definitions\nstruct Typeface\n{\n    vec2 scale;\n    vec2 padding;\n    vec2 bias;\n    float biasAngle;\n    float threshold;\n};\n\nconst Typeface Deco = Typeface( vec2(0.5,.5), vec2(0.), vec2(-.0,.0), 0., -0.03 );\n\nfloat RenderFont_NoAA\n    (\n        vec2 uv,\n        Typeface font,\n        uint text[8]\n    )\n{\n    // each char is in a 64x64 space, trim off the white boundary\n    vec2 charBottomLeft = vec2(18,3) - font.padding/2.;\n    vec2 charDims = vec2(28,52) + font.padding;\n\n    uv = uv/font.scale; //+vec2(iTime*200.,0);\n    \n    if ( uv.y < .0 || uv.y >= charDims.y ) return 1.;\n    \n    uint index = uint(uv.x/charDims.x);\n    ivec2 res = ivec2(iResolution.xy);\n    uint index4 = index/4u;\n\n    if ( index4 >= uint(text.length()) ) return 1.;\n    \n    uint char = ( text[index4] >> (8u*(index&3u)) )&0xffu;\n    \n    char = char^0xf0u; // flip the y coord\n    \n    uv.x = fract(uv.x/charDims.x)*charDims.x;\n    uv += vec2(ivec2(char&0xfu,char>>4u)) * iChannelResolution[0].xy/16.;\n    uv += charBottomLeft;\n                            \n    vec4 v = texture( iChannel0, uv/iChannelResolution[0].xy ) -.5;\n                            \n    vec2 bias = 2.*v.yz;\n    bias = bias*cos(font.biasAngle) + bias.yx*sin(font.biasAngle)*vec2(1,-1);\n    bias = pow(abs(bias),vec2(3));\n    \n    vec2 duvdx = dFdx(uv);\n    vec2 duvdy = dFdy(uv);\n    \n    return S( font.threshold-0.01 * duvdx.y,font.threshold +0.01* duvdy.y, v.w + dot( font.bias, bias ) );\n}\n\n// RenderFont\n//\n// Output:\n//\t\tA linear brightness value where 0 = text, 1 = background.\n//\t\tI recommend applying a gamma curve before displaying.\n//\n// uv\n//\t\tRelative to the bottom left of the line of text, most fonts are about 40 units tall\n//\n// font\n//\t\tOne of the Typefaces defined earlier\n//\n// text\n//\t\tA line of text, encoded using my tool here: https://tekf.github.io/Misc-Tools/StringToHex.html\n//\t\tEach byte is 4-bit u, 4-bit v coord of a character in the font texture.\n//\nfloat RenderFont\n    (\n        vec2 uv,\n        Typeface font,\n\t\tuint text[8]\n    )\n{\n    const int numSamples = 1<<(AA_QUALITY);\n    \n    float sum = 0.;\n    vec2 duvdx = dFdx(uv);\n    vec2 duvdy = dFdy(uv);\n\n    // anti-alias the font\n    // this would be more efficient run per-character inside the font render function\n    // (the SDFs on some of the fonts are good enough that I could probably just soften the step function)\n    for ( int i=0; i < numSamples; i++ )\n    {\n        // ideal 2D quasirandom sequence from http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n        uvec2 quasi2 = uvec2(0xC13FA9A9u,0x91E10DA5u);\n        uint seed = uint(i);\n        //seed += uint(iFrame*numSamples); // randomize per frame - causes shimmering\n        //seed += uint(fragCoord.x)*quasi2.x+uint(fragCoord.y)*quasi2.y; // randomize per pixel - this looks bad at low sample counts (and at high counts it's less important)\n        vec2 jitter = vec2( quasi2 * seed ) / exp2(32.);\n\n        if ( AA_ROUND )\n        {\n            // circle of confusion slightly bigger than a pixel - should look more photographic\n            jitter.x *= 6.283185;\n            jitter = AA_ROUND_RADIUS*(1.-jitter.y*jitter.y)*vec2(cos(jitter.x),sin(jitter.x));\n        }\n        else\n        {\n            jitter -= .5;\n        }\n        \n        sum += RenderFont_NoAA( uv + jitter.x*duvdx + jitter.y*duvdy, font, text );\n    }\n   \n    return sum/float(numSamples);\n}\n\nvec4 DisplaySplash(in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord*360./iResolution.y;\n    // Text encoded using my tool here: https://tekf.github.io/Misc-Tools/StringToHex.html\n\tfloat f = RenderFont( uv-vec2(257,230), Deco, uint[]( 0x4847494cU, 0x41574154U, 0x59U, 0x20U, 0x20U, 0x20U, 0x20U, 0x20U ) );\n    \n    uv = (2.0* fragCoord- iResolution.xy)/iResolution.y;\n    float mask = 1.-sign(ParallelogramSDF(uv - vec2(0,0.22), 0.35, 0.2, 0.));\n\n    vec4 color = vec4((1.-pow( f, 1./2.2)) * mask);\n\n    float glow = 1.-pow(S(-0.6,0.8,length((uv- vec2(0,0.35)) * vec2(0.8,3.))),0.35);\n\n    color += + vec4(vec3(glow), 0.);\n\n    //Tap to start\n    uv = fragCoord*360./iResolution.y;\n\tf = RenderFont( (uv-vec2(292,120)) * vec2(3.,3.), Deco, uint[]( 0x20706154U, 0x73206f74U, 0x74726174U, 0x20U, 0x20U, 0x20U, 0x20U, 0x20U ) );\n    \n    uv = (2.0* fragCoord- iResolution.xy)/iResolution.y;\n    mask = 1.-sign(ParallelogramSDF(uv - vec2(0,-0.15), 0.155, 0.2, 0.));\n\n    color += vec4((1.-pow( f, 1./2.2)) * mask);\n\n    // Output to screen\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    AppState s;\n    loadState( iChannel1, s );\n        \n    if (s.stateID == GS_SPLASH) // splash\n    { \n        fragColor = DisplaySplash(fragCoord.xy);\n        return;\n    }\n    \n    float t = iTime;\n    \n    float startTime = s.timeStarted;\n    \n    vec2 uv = (2.0* fragCoord- iResolution.xy)/iResolution.y;\n    vec2 m = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    if(s.stateID == GS_DEAD)\n    {\n        t = s.timeFailed;\n        m = (2.*s.iMousePos-iResolution.xy)/iResolution.y;\n    }\n\n    Wall wall;\n\n    vec4 wallSDF = WallColor(uv,m,wall);\n    vec4 lights = LampsColor(uv,startTime, t , wall);\n    \n    float uit = (t - s.timeStarted) / levelDuration;\n\n    vec4 ui = UIColor(uv,uit);\n    vec4 uiBackground = UIBackgroundColor(uv);\n        \n    fragColor = clamp01(wallSDF + lights + ui + uiBackground);   \n}","name":"Buffer C","description":"","type":"buffer"}]}