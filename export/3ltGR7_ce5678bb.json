{"ver":"0.1","info":{"id":"3ltGR7","date":"1575928735","viewed":147,"name":"Flollow The Light","username":"julianlumia","description":"made after playing around with this shader: https://www.shadertoy.com/view/wslSz7","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["light"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec3 v)\n{ \n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy;\n    vec3 x3 = x0 - D.yyy;\n    i = mod289(i); \n    vec4 p = permute( permute( permute( \n                i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n            + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n            + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n    float n_ = 0.142857142857; \n    vec3  ns = n_ * D.wyz - D.xzx;\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z); \n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );  \n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0,0,0,0));\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n    vec4 norm = (vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n         norm = 1.79284291400159 - 0.85373472095314 * norm;\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float mask = clamp(length(vec2(.5,.5) - uv * 2. + .5) * (2. + .5 * sin(iTime * 2.)), 0.,1.);\n    uv += snoise(uv.xyx * 10. + vec3(0,-iTime * .3,0)) * .007 * (1. - mask);\n    vec2 dir = (uv - vec2(.5,.5));\n    vec4 color = vec4(0.0,0.0,0.0,0.0);\n    vec4 og = texture(iChannel0, uv);\n    float str = .1;\n    float steps = 64.;\n    for (float i = 0.; i < 64.; i++)\n    {  \n        float j = float(i) / steps;\n        color += texture(iChannel0, uv + j * dir * str);\n    }    \n    color /= steps;\n    color = mix(color, og, mask);\n    \n    fragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define saturate(x) clamp(x, 0., 1.)\n#define iGlobalTime iTime\n\nvec3 OpRepeatXZ(in vec3 p, in vec2 factor)\n{\n\tvec2 tmp = mod(p.xz, factor) - 0.5*factor;\n\treturn vec3(tmp.x, p.y, tmp.y);\n}\n\nvec3 OpRepeatZ(in vec3 p, float f)\n{\n    float t = mod(p.z, f) - .5 * f;\n    return vec3(p.x, p.y, t);\n}\n\nvec3 OpRepeat( in vec3 p, in vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return ( q );\n}\n\n\nfloat OpSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n\nvec3 RotateX(vec3 pos, float angle) \n{\n\treturn vec3(\n        pos.x,\n        pos.y * cos(angle) - pos.z * sin(angle),\n        pos.y * sin(angle) + pos.z * cos(angle)\n    );\n}\n\nvec3 GlobalOffset(vec3 p) \n{\n    vec3 pp = p;\n    pp.y += sin(p.z * 1.5 + iTime * 5.) * .3;\n    \n\n    return pp;\n}\n\nfloat PrimCylinder( vec3 p, vec3 c )\n{\n    return length(p.xz-c.xy)-c.z;\n}\n\nfloat getDist(vec3 p)\n{\n    vec3 p2 = p;\n    float r = 3.14159*sin(p.z*.01+(sin((iTime*0.5)*0.5+0.5)*0.001))+cos(iTime*0.1);\n    mat2 R = mat2(cos(r), sin(r), -sin(r), cos(r));\n    p.xy *= R;     \n    p = GlobalOffset(p);\n    float nr = 600.;\n    vec2 repeat = vec2((cos(p.z*0.0001+nr)*.5+.5)*10., (sin(p.z*0.01+iTime)*.5+1.)*10.);\n    float dist = 100.;\n    float count =sin(iTime*0.1)*0.5+0.5*3.;\n   // float count = .35;\n    for(float i = 0.; i < 4.; i++) \n    {\n        float j = float(i);\n        float ratio = j / float(count);\n        vec3 pos = RotateX(p.zxy + vec3(sin(iTime)*0.5+.5,sin(iTime)*0.5+.5,sin(iTime)*0.5+0.5), (j / float(count)) * 3.14);\n        float size = .1 + .5 * (sin(iTime) * .5 + .5);\n        dist = OpSmoothUnion(dist, PrimCylinder(OpRepeatXZ(pos, repeat), vec3(.0, 0, size)), 1.);\n    }\n \n    return dist;\n}\n\nfloat Fog(vec3 p, float dist)\n{\n    return ((dist / min(dist, length(p))) - 1.);\n}\n\nvec4 Raymarch(vec3 ro, vec3 rd, out float emission) \n{\n\tfloat dO=0.;\n    vec3 color = vec3(0.);\n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*dO;\n        float dS = getDist(p);\n        dO += dS;   \n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n        color = vec3(sin((iTime*0.5)*0.5+0.5),cos(iTime)*0.5+0.5,sin(iTime)*0.5+0.5); // ground\n    }\n    return vec4(dO, color);\n}\n\nvec3 Normal(vec3 p) \n{\n\tfloat d = getDist(p);\n    vec2 e = vec2(.001, 0); \n    vec3 n = d - vec3(\n        getDist(p-e.xyy),\n        getDist(p-e.yxy),\n        getDist(p-e.yyx)\n    );\n    return normalize(n);\n}\n\nvec4 Light(vec3 p, vec3 rd) \n{\n    vec3 lightPos = vec3(0, 0, 15. + iTime);\n    vec3 l = normalize(lightPos-(p));\n    vec3 n = Normal(p);\n    float dif = saturate(dot(n, l));\n    float fog = Fog(lightPos-(p), 50.) * .2;\n    dif *= fog;\n    vec3 color = vec3(1) * dif;\n    vec3 v = -rd;\n\tvec3 r = normalize(2. * dif * n - l); \n\tfloat spec = pow(saturate(dot(r, v)), 10.0) * dif;\n          spec *= 1.2;\n          spec = pow(spec, 5.) * 5.;\n    return vec4(color, spec);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0, 0, iTime);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 0.5));\n   \trd.x += sin(iTime) * .025;\n    vec3 col = vec3(0);\n    float emission = 0.;\n    vec4 rm = Raymarch(ro, rd, emission);\n    float dist = rm.x;\n    vec3 color = rm.zzw;\n    vec3 p = ro + rd * dist;\n    vec4 lighting = Light(p, rd);\n    vec3 lightingColor = lighting.rgb;\n    float lightingSpec = lighting.a;\n    col = lightingColor * color;\n    col += lightingSpec * vec3(1.,.7,.2);\n    col *= (1. - dot(Normal(p), vec3(0,1,0))) + .2;\n    col += .13;\n    col.b += .02; \n    float pulse = (10. * (sin(iTime * 2.) * 3. + .5));\n    col += saturate((p.z - iTime - 15.) * .01) * vec3(1,.05,0) * 2.;\n    col += saturate((p.z - iTime - 40. + pulse) * .01) * vec3(1,1,.3) * 1.;\n    col += saturate((p.z - iTime - 100. + pulse) * .01) * vec3(1,1,1) * 1.;  \n    fragColor = vec4(col, 1.);\n}","name":"Buffer A","description":"","type":"buffer"}]}