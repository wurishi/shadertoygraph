{"ver":"0.1","info":{"id":"3lXfzH","date":"1595945949","viewed":402,"name":"Tileable Curl distortion","username":"ming","description":"Simple distortion effect with tileable curl noise","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["distortion","curl","tileable"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/MdSBzm\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspect = vec2(1.0, (iResolution.y / iResolution.x));\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel distortion\n    vec3 off = curlNoise(vec3(uv + vec2(iTime * 0.25, 0.0), 0.0));\n    off *= 0.05;\n    \n    // Masking\n    float dist = length((uv.xy - vec2(0.5, 0.5)) * aspect);\n    off.xy *= vec2(1.0) - smoothstep(0.2, 0.25, dist);\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv + off.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//----------------------------------------------------------------------------------------\nvec3 HashALU(in vec3 p, in float numCells)\n{\n\t// This is tiling part, adjusts with the scale\n\tp = mod(p, numCells);\n\t\n    p = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + fract(sin(p)*43758.5453123) * 2.0;\n}\n\n#define Hash HashALU\n\n//----------------------------------------------------------------------------------------\nfloat TileableNoise(in vec3 p, in float numCells )\n{\n\tvec3 f, i;\n\t\n\tp *= numCells;\n\n\t\n\tf = fract(p);\t\t// Separate integer from fractional\n    i = floor(p);\n\t\n    vec3 u = f*f*(3.0-2.0*f); // Cosine interpolation approximation\n\n    return mix( mix( mix( dot( Hash( i + vec3(0.0,0.0,0.0), numCells ), f - vec3(0.0,0.0,0.0) ), \n                          dot( Hash( i + vec3(1.0,0.0,0.0), numCells ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( Hash( i + vec3(0.0,1.0,0.0), numCells ), f - vec3(0.0,1.0,0.0) ), \n                          dot( Hash( i + vec3(1.0,1.0,0.0), numCells ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( Hash( i + vec3(0.0,0.0,1.0), numCells ), f - vec3(0.0,0.0,1.0) ), \n                          dot( Hash( i + vec3(1.0,0.0,1.0), numCells ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( Hash( i + vec3(0.0,1.0,1.0), numCells ), f - vec3(0.0,1.0,1.0) ), \n                          dot( Hash( i + vec3(1.0,1.0,1.0), numCells ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nfloat TileableNoiseFBM(in vec3 p, float numCells, int octaves)\n{\n\tfloat f = 0.0;\n    \n\t// Change starting scale to any integer value...\n    p = mod(p, vec3(numCells));\n\tfloat amp = 0.5;\n    float sum = 0.0;\n\t\n\tfor (int i = 0; i < octaves; i++)\n\t{\n\t\tf += TileableNoise(p, numCells) * amp;\n        sum += amp;\n\t\tamp *= 0.5;\n\n\t\t// numCells must be multiplied by an integer value...\n\t\tnumCells *= 2.0;\n\t}\n\n\treturn f / sum;\n}\n\nvec3 snoiseVec3( vec3 x )\n{\n  float numCells = 6.0;\n  int octaves = 3;\n   \n  float s  = TileableNoiseFBM(vec3( x ), numCells, octaves);\n  float s1 = TileableNoiseFBM(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ), numCells, octaves);\n  float s2 = TileableNoiseFBM(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ), numCells, octaves);\n  vec3 c = vec3( s , s1 , s2 );\n  return c;\n\n}\n\nvec3 curlNoise(vec3 p)\n{\n  const float e = .1;\n  vec3 dx = vec3( e   , 0.0 , 0.0 );\n  vec3 dy = vec3( 0.0 , e   , 0.0 );\n  vec3 dz = vec3( 0.0 , 0.0 , e   );\n\n  vec3 p_x0 = snoiseVec3( p - dx );\n  vec3 p_x1 = snoiseVec3( p + dx );\n  vec3 p_y0 = snoiseVec3( p - dy );\n  vec3 p_y1 = snoiseVec3( p + dy );\n  vec3 p_z0 = snoiseVec3( p - dz );\n  vec3 p_z1 = snoiseVec3( p + dz );\n\n  float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\n  float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\n  float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\n\n  const float divisor = 1.0 / ( 2.0 * e );\n  return normalize( vec3( x , y , z ) * divisor );\n}\n","name":"Common","description":"","type":"common"}]}