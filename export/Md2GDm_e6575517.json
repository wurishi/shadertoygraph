{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"float ease(float p) { return 3.0*p*p-2.0*p*p*p; }\n\nfloat sphere(vec3 p, float r) { return length(p)-r; }\n\nfloat round_box (vec3 p, vec3 b, float r) { return length(max(abs(p)-b, 0.0))-r; }\n\nfloat map(vec3 p, bool norm)\n{\n    vec3 c = vec3(2.0, 2.0, 25.0);\n    vec3 q = mod(p,c) - 0.5*c;\n\t\n    float bb = round_box(p-vec3(-1.0, 1.0, 12.5), vec3(7.0, 7.0, 1.0), 0.0); //bounding box\n    float cub = round_box(q, vec3(0.7, 0.7, 0.7), 0.2); //cubes array\n    if (!norm) cub = max(cub, bb);\n\telse cub = min(cub, p.y + 6.0);\n\n    float f = max(p.y + 6.0, sphere(p-vec3(0.0, 0.0, 12.5), 50.0)); //floor\n    float d = min(cub,f);\n\t\n\treturn d;\n}\n\nfloat intersect(vec3 ro, vec3 rd )\n{\n    float t = 0.0;\n\tfloat eps = 0.002;\n\tfloat h = 1.0;\n    float res = -1.0;\n\tfloat d = 1.0;\n\tfor(int i=0; i<100; i++){\n\t\tif( h < eps) {\n\t\t\tres = t;\n\t\t\tcontinue;\n\t\t}\n\t\th = map(ro + rd*t, false);\n\t\tt += h*d;\n\t\td *= 1.01;\n    }\n    return res;\n}\n\nvec3 calcNormal(vec3 pos){\n    vec3  eps = vec3(.05,0.0,0.0);\n    vec3 nor;\n    nor.x = map(pos+eps.xyy,true) - map(pos-eps.xyy,true);\n    nor.y = map(pos+eps.yxy,true) - map(pos-eps.yxy,true);\n    nor.z = map(pos+eps.yyx,true) - map(pos-eps.yyx,true);\n    return normalize(nor);\n}\n\nvec3 skyCol(vec3 rd, vec3 sunpos, float t){\n    float dt = clamp(t,0.0,1.3);\n    float nt = clamp(t-1.1,0.2,1.2);\n\n    vec3 col = vec3(0.6, 0.7, 0.9);\n    float sun = max(pow(clamp(dot(rd,sunpos),0.0,1.0),16.0),0.0);\n\n    col += vec3(0.6,0.6,0.4)*sun;\n    vec3 daycol = vec3(0.5,0.5,0.5)*pow(0.7-clamp(rd.y,0.0,1.0),3.0);\n    vec3 setcol = vec3(0.7,0.0,-0.6)*(pow(0.7-clamp(rd.y,0.0,1.0),3.0)+0.3*rd.z);\n    col += mix(daycol,setcol,dt*dt*dt);\n    col = mix(col,vec3(0.0,0.0,0.1),ease(nt-0.2));\n        \n        return col;\n}\n\nvec3 lamb(vec3 norm, vec3 light){\n    float dif1 = max(0.4 + 0.6*dot(norm,light),0.0);\n    vec3 col  = vec3(0.2,0.2,0.2);\n    col += 2.0*dif1*vec3(1.0,0.97,0.85);\n    col += 1.0*(0.5+0.5*norm.y)*vec3(0.1,0.15,0.2);\n    return col;\n}\n\nvec3 matCol (float x, float y) {\n\tif (y <= -5.95) return vec3(0.3);\n\tif (mod(max(abs(ceil(0.5*x)), abs(floor(0.5*y))), 2.0) >= 1.0) return vec3(0.1);\n\telse return vec3(0.9);\n}\n\t\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n    float t = 2.2*cos(0.1*iTime);//0.1*(25.0-iTime);\n\n    // light\n    vec3 light = normalize(vec3(0.0,1.0-t,1.0+t/2.2));\n    vec3 lightcol = skyCol(normalize(vec3(0.0,1.0,1.0)),light,t);\n\n    // camera\n    vec3 ro = vec3(16.0*cos(0.5*iTime),2.0*sin(0.3*iTime),16.0*sin(0.5*iTime)+13.5);\n    vec3 ww = normalize(vec3(1.0,1.0,12.5) - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    vec3 col = vec3(0.0);\n    float tmat = intersect(ro,rd);\n    if( tmat>0.0 )\n    {\n        vec3 pos = ro + tmat*rd;\n        vec3 nor = calcNormal(pos);\n        vec3 rr = reflect(rd,nor);\n\n        float rmat = intersect(pos+0.1*rr,rr);\n\n        if (rmat>0.0) {\n            vec3 rpos = pos + rmat*rr;\n            vec3 rnor = calcNormal(rpos);\n            vec3 rr2 = reflect(rr,rnor);\n\n            float rmat2 = intersect(rpos+0.1*rr2,rr2);\n         \n            if (rmat2>0.0) {\n                vec3 rpos2 = rpos + rmat2*rr2;\n                vec3 rnor2 = calcNormal(rpos2);\n                col = lamb(rnor2, light);\n                col *= matCol(rpos2.x, rpos2.y);\n                col *= vec3(0.2,0.2,0.3);\n            } else {\n                col = skyCol(rr2,light,t);\n            }\n            col *= matCol(rpos.x, rpos.y);\n        } else {\n            col = skyCol(rr,light,t);\n        }\n        col *= matCol(pos.x, pos.y);\n        if (pos.y <= -5.99) col = mix(col,matCol(pos.x, pos.y),0.6);\n\n        col *= lightcol;\n    } else {\n        col = skyCol(rd,light,t);\n    }\n        fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Md2GDm","date":"1389735519","viewed":400,"name":"Sunrise Cubes","username":"robalan","description":"My first foray into raymarching: cubes with a sunrise/sunset in the background.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""}}