{"ver":"0.1","info":{"id":"lt3yz8","date":"1531480135","viewed":421,"name":"Blnk","username":"Bitmesh","description":"music visualiser.\n\nthe code is not very efficient, as it calculates the distance to every light at every pixel. \nmy goal was to recreate a visualiser I made in Unity before.","likes":7,"published":1,"flags":4,"usePreview":0,"tags":["music","visualiser"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGRr","filepath":"/presets/mic.png","previewfilepath":"/presets/mic.png","type":"mic","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define LIGHT_COUNT 128.\n#define ASPECT_RATIO 1.77777777778\n#define INTENSITY 1.2\n#define RANGE 128.\n\n//#define REFLECTION\n\nfloat renderGlow(float radius, float intensity, vec2 position, vec2 uv)\n{\n    float distance = clamp(length(position - uv), 0., 1.);\n    return pow(1. - distance, 1. / radius) * intensity;\n}\n\nfloat renderGradient(float y, float sharpness)\n{\n    return pow(y, sharpness);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;    \n    vec2 Nuv = fragCoord / iResolution.xy;    \n\tuv = uv*2.-1.;\n    uv.x *= ASPECT_RATIO;\n    \n\tvec4 lightColor = vec4(1, 0.85, 0.07, 1);\n    float final = 0.0;\n    for (float i = 0.; i < LIGHT_COUNT; i++)\n    {\n        float ran = texture(iChannel1, vec2(i * 25.3123, 0)).r * RANGE;\n        float sound = pow(texelFetch(iChannel0, ivec2(ran ,0), 0 ).x * INTENSITY, 4.5);\n\t\t\n        sound = max(0.01, sound);\n        \n        float x = (i / LIGHT_COUNT * ASPECT_RATIO * 2.) - ASPECT_RATIO;\n        float y = 0.8 - sound*sound*.025;\n        float z = mod(i, 5.) + 1.;\n\t\t\n        final += renderGlow(.1/ z, sound, vec2(x,y) / z, uv) / z;\n        #ifdef REFLECTION\n            if (Nuv.y < 0.4)\n                final += 0.0001 + renderGlow(.1/ z, sound, vec2(x, .3-y) / z, vec2(uv.x, uv.y *.3)) / z  *.07;\n        #endif\n    }\n       \n    fragColor = ((0.5*((final)+(final*final)) * lightColor));\n}","name":"Image","description":"","type":"image"}]}