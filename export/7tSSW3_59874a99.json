{"ver":"0.1","info":{"id":"7tSSW3","date":"1628751412","viewed":112,"name":"Environment Mapping","username":"Yon","description":"Environment mapping.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["math","cubemap","mapping","environment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592\n#define TWO_PI 6.28318530717958\n\nfloat pow2(float x){\n    return x*x;\n}\n\n//------------------------------------------------------------------------------\n// Mapping\n//------------------------------------------------------------------------------\n\nvec2 LatMapping(in vec3 r){\n        vec2 uv = vec2(atan(r.z,r.x)/(2.*PI) + 0.5,asin(r.y) / PI + 0.5);\n        return uv;\n}\n\nvec2 SphMapping(in vec3 r){\n        float m = 2.*sqrt(r.x*r.x+r.y*r.y+(r.z+1.)*(r.z+1.));\n        vec2 uv = vec2(r.x/(m) + .5, r.y/(m)+.5);\n        return uv;\n}\n\nvec2 OctMapping(in vec3 r){\n    // Project the sphere onto the octahedron, and then onto the xy plane\n    vec2 p = r.xy * (1.0 / (abs(r.x) + abs(r.y) + abs(r.z)));\n    // Reflect the folds of the lower hemisphere over the diagonals\n    // Some version of the \"sign\" takes into account whether there are zeros or not\n    vec2 uv = (r.z <= 0.0) ? ((1.0 - abs(p.yx)) * sign(p)) : p;\n\n    return uv*0.5+0.5;\n}\n\nvec3 PanoProjection(in vec2 uv){\n        return vec3(cos(uv.x*TWO_PI),-cos(uv.y*PI),sin(uv.x*TWO_PI));\n}\n\n\nvec2 PanoMapping(in vec3 r){\n        return vec2((atan(r.z, r.x) / TWO_PI) + 0.5, acos(-r.y) / PI);\n}\n\n\nvec3 OctProjection(vec2 uv) {\n    uv = uv*2.-1.;\n    vec3 v = vec3(uv.xy, 1.0 - abs(uv.x) - abs(uv.y));\n    if (v.z < 0.) v.xy = (1.0 - abs(v.yx)) * sign(v.xy);\n    return normalize(v);\n}\n\nvec3 LatProjection(vec2 uv){\n    uv *= vec2(2.*PI,PI);\n    vec3 r;\n    r.y = -cos(uv.y);\n    r.z = cos(uv.x)*sin(uv.y);\n    r.x = sin(uv.x)*sin(uv.y);\n    return r;\n}\n\n\nvec3 SphProjection(in vec2 uv){\n    vec3 r;\n    float k = sqrt(-pow2(2.*uv.x-1.) - pow2(2.*uv.y-1.) +1.);\n    r.x = 2.*k*(2.*uv.x-1.);\n    r.y = 2.*k*(2.*uv.y-1.);\n    r.z = 2.*k*k -1.;\n    return r;\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // // Render scene\n    float distance;\n    vec3 color;\n    vec3 r;\n    vec2 uv;\n    uv = fragCoord.xy / iResolution.xy;\n    if(uv.y<0.5){\n        uv.y*=2.;\n        r = LatProjection(uv);\n        color =texture(iChannel0, r).rgb;\n    }\n    uv = fragCoord.xy / iResolution.xy;\n    if(uv.x<0.5 && uv.y>=0.5){\n        uv *=2.;\n        r = SphProjection(fract(uv));\n        color =texture(iChannel0, r).rgb;\n    }\n    uv = fragCoord.xy / iResolution.xy;\n    if(uv.x>=0.5 && uv.y>=0.5){\n        uv*=2.;\n        r = OctProjection(fract(uv));\n        color =texture(iChannel0, r).rgb;\n    }\n\n\n    fragColor = vec4(pow(color,vec3(1./2.2)), 1.0);\n}","name":"Image","description":"","type":"image"}]}