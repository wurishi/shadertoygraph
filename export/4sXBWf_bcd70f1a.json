{"ver":"0.1","info":{"id":"4sXBWf","date":"1498422510","viewed":133,"name":"Tyre Rasterizer","username":"zproxy","description":"https://www.shadertoy.com/view/MsjSzz\ncannot move camera inside object tho","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["rasterizer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define LINEAR_ROTATION\n\n#define WEIGHT (3.0 / iResolution.x)\nconst vec3 RED = vec3(1.0,0.0,0.0);\nconst vec3 GREEN = vec3(0.0,1.0,0.0);\nconst vec3 BLUE = vec3(0.0,0.8,1.0);\nconst vec3 WHITE = vec3(1.0,1.0,0.97);\nconst vec3 YELLOW = vec3(1.0,1.0,0.0);\n\n// rasterize functions\nfloat line(vec2 p, vec2 p0, vec2 p1, float w) {\n    vec2 d = p1 - p0;\n    float t = clamp(dot(d,p-p0) / dot(d,d), 0.0,1.0);\n    vec2 proj = p0 + d * t;\n    float dist = length(p - proj);\n    dist = 1.0/dist*WEIGHT*w;\n    return min(dist*dist,1.0);\n}\nfloat circle(vec2 p, vec2 c, float r, float w) {\n    float dist = abs(length(p - c)) + r;\n    dist = 1.0/dist*WEIGHT*w;\n    return min(dist*dist,1.0);\n}\n\n// matrices\nmat4 getRotMatrix(vec3 a) {\n    vec3 s = sin(a);\n    vec3 c = cos(a);    \n    mat4 ret;\n    ret[0] = vec4(c.y*c.z,c.y*s.z,-s.y,0.0);\n    ret[1] = vec4(s.x*s.y*c.z-c.x*s.z,s.x*s.y*s.z+c.x*c.z,s.x*c.y,0.0);\n    ret[2] = vec4(c.x*s.y*c.z+s.x*s.z, c.x*s.y*s.z-s.x*c.z,   c.x*c.y,0.0);    \n    ret[3] = vec4(0.0,0.0,0.0,1.0);\n    return ret;\n}\nmat4 getPosMatrix(vec3 p) {   \n    mat4 ret;\n    ret[0] = vec4(1.0,0.0,0.0,p.x);\n    ret[1] = vec4(0.0,1.0,0.0,p.y);\n    ret[2] = vec4(0.0,0.0,1.0,p.z);   \n    ret[3] = vec4(0.0,0.0,0.0,1.0);\n    return ret;\n}\n\n// utils\nvec3 mix3(vec3 a, vec3 b, vec3 c, float t) {\n    if(t>0.5) return mix(b,c,t*2.0-1.0);\n    else return mix(a,b,t*2.0);\n}\nvec3 fragment(vec3 p) {\n    float t = sin(p.x*0.8+iTime*0.5)*0.5+0.5;\n    float fog = min(pow(p.z,2.0)*400.0,1.0);\n //   return mix3(RED,GREEN,BLUE,t) * fog;\n    \n    // return white. always\n    return vec3(1.) * fog;\n}    \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    //uv = uv * (1.0 + pow(length(uv)*0.4,0.5)) * 0.6;\n    \n    float line_width = 1.9;\n    float time = iTime * 0.1;\n    vec3 c = vec3(mix(vec3(0.19,0.13,0.1),vec3(1.0), 0.5*pow(length(uv)*0.5,2.0)));\n    \n    \n    // if we go too close it will break\n    mat4 cam = getPosMatrix(vec3(0.0,0.0,8.0));\n    \n\n    //mat4 rot = getRotMatrix(vec3(0.,0.,3.14 +time));\n\n    \n    \n    mat4 rot = getRotMatrix(vec3(\n        \n        // xlat animation\n        -3.14 +iTime  *0.1,0.,\n                                 \n                                 // moonrise to moonset\n                                 -iTime));\n\n    \n     \n    vec3 instances[1];\n    instances[0] = vec3( 0.0, 0.0,0.0);\n   \n    \n    {\n        \n        // input assembly\n        // vec3 vert[8];\n        \n        #define zcount 3\n        //#define zpoints 4\n        \n        // 23fps\n//        #define zpoints 8 \n\n        #define zpoints 36 \n\n        #define radius 5.\n        \n        // https://www.opengl.org/discussion_boards/showthread.php/170193-Constant-vec3-array-no-go\n        // const vec3 MyArray[4]=vec3[4](\n        \n        // 360 Gx2 from 1999 vb6 hehe\n        vec3[zpoints * zcount] vert;\n        \n        // -1 0 +1\n        for(int i = 0; i < zcount; i++) \n        {\n            float z = float(i) - 1.;\n        \n            // can we get 4 corners from a circle?\n            \n             for(int zpoint = 0; zpoint < zpoints ; zpoint++) \n             {\n                 vert[(i * zpoints)+zpoint] = vec3(\n                     radius*cos(float(zpoint)*2.*3.14/float(zpoints)),\n                     radius*sin(float(zpoint)*2.*3.14/float(zpoints)),\n                     z);\n             }\n          // vert[(i * zpoints)+0] = vec3(-1.0,-1.0,z);\n          // vert[(i * zpoints)+1] = vec3(-1.0, 1.0,z);    \n          // vert[(i * zpoints)+2] = vec3( 1.0, 1.0,z);    \n          // vert[(i * zpoints)+3] = vec3( 1.0,-1.0,z);\n        }\n        \n        \n \n\n\n        \n        // vertex processing        \n        mat4 pos = getPosMatrix(instances[0] );\n        mat4 mat = pos * rot * cam;\n\n        for(int i = 0; i < zpoints * zcount; i++) {\n\t\t\t\n            // rescale?\n            //vert[i] *= 4.;\n            \n            // transform\n            vert[i] = (vec4(vert[i],1.0) * mat).xyz;\n\n            // perspective\n            vert[i].z = 1.0 / vert[i].z;\n            \n            // what does this do? isometric without.\n            vert[i].xy *= vert[i].z;\n            \n            \n        }    \n\n        // primitive assembly and rasterize\n        vec3 i;\n        \n     \n        \n        \n     // which scanline?\n       int zindex0 = (int(iFrame) / 30) % 3;\n                         \n        //\n        \n        //         for(int zindex = 0; zindex <  zcount; zindex++) \n\n        {\n            int zindex = 0;\n           \n            for(int zpoint = 0; zpoint < zpoints ; zpoint++) \n            {\n                // https://www.shadertoy.com/view/MsjSzz\n\n                // verticals\n                // https://www.shadertoy.com/view/XdfBWf\n\n\n\n                //zpoint = 0;\n            i += vec3(0.0,0,1.0) * line(uv,vert[(zindex * zpoints)+zpoint].xy,vert[(zindex * zpoints)+(zpoint+1)%zpoints].xy,line_width * 0.5);\n            //i += line(uv,vert[(zindex * zpoints)+1].xy,vert[(zindex * zpoints)+2].xy,line_width);\n            //i += line(uv,vert[(zindex * zpoints)+2].xy,vert[(zindex * zpoints)+3].xy,line_width);\n            //i += line(uv,vert[(zindex * zpoints)+3].xy,vert[(zindex * zpoints)+0].xy,line_width);\n\n            }\n        }\n    \n           {\n            int zindex = 1;\n           \n            for(int zpoint = 0; zpoint < zpoints ; zpoint++) \n            {\n                // https://www.shadertoy.com/view/MsjSzz\n\n                // verticals\n                // https://www.shadertoy.com/view/XdfBWf\n\n\n\n                //zpoint = 0;\n            i += vec3(1.0,1.0,0) * line(uv,vert[(zindex * zpoints)+zpoint].xy,vert[(zindex * zpoints)+(zpoint+1)%zpoints].xy,line_width * 0.5);\n            //i += line(uv,vert[(zindex * zpoints)+1].xy,vert[(zindex * zpoints)+2].xy,line_width);\n            //i += line(uv,vert[(zindex * zpoints)+2].xy,vert[(zindex * zpoints)+3].xy,line_width);\n            //i += line(uv,vert[(zindex * zpoints)+3].xy,vert[(zindex * zpoints)+0].xy,line_width);\n\n            }\n        }\n        \n           {\n            int zindex = 2;\n           \n            for(int zpoint = 0; zpoint < zpoints ; zpoint++) \n            {\n                // https://www.shadertoy.com/view/MsjSzz\n\n                // verticals\n                // https://www.shadertoy.com/view/XdfBWf\n\n\n\n                //zpoint = 0;\n            i += vec3(1.0,0,0) * line(uv,vert[(zindex * zpoints)+zpoint].xy,vert[(zindex * zpoints)+(zpoint+1)%zpoints].xy,line_width * 0.5);\n            //i += line(uv,vert[(zindex * zpoints)+1].xy,vert[(zindex * zpoints)+2].xy,line_width);\n            //i += line(uv,vert[(zindex * zpoints)+2].xy,vert[(zindex * zpoints)+3].xy,line_width);\n            //i += line(uv,vert[(zindex * zpoints)+3].xy,vert[(zindex * zpoints)+0].xy,line_width);\n\n            }\n        }\n        \n        \n        \n        //int vindex = (int(iFrame) / 2) % (zpoints);\n        \n        // animate the whole thing instead?\n        int vindex = 0;\n\n        i += line(uv,vert[vindex].xy,vert[vindex + 2 * zpoints].xy,line_width *2.);\n        \n        //i += line(uv,vert[1].xy,vert[5].xy,line_width);\n        //i += line(uv,vert[2].xy,vert[6].xy,line_width);\n        //i += line(uv,vert[3].xy,vert[7].xy,line_width);\n    \n        \n        c += fragment(vert[0]) * min(i,1.0);\n    }\n     \n    \n    // fragment\n\tfragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}]}