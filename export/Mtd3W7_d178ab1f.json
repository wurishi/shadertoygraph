{"ver":"0.1","info":{"id":"Mtd3W7","date":"1469728716","viewed":1889,"name":"Overcast Skies 2D v2","username":"CaliCoastReplay","description":"Betterized version of :  https://www.shadertoy.com/view/MttGW7  \n\n(I'd just have saved it there, but I'm losing the fight with Shadertoy's save functionality.)","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["fractal","noise","clouds","fbm","perlin","sky","brownian","motion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nfloat rand(vec2 n) {\n    float value = fract(sin(cos(dot(n, vec2(12.9898,8.1414)))) * 42758.5453);\n    return sqrt(value)/1.25;\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat fbm(vec2 n) {\n    float total = 0.0, amplitude = 1.0;\n    for (int i = 0; i <4; i++) {\n        total += noise(n) * amplitude;\n        n += n*2.1;\n        amplitude *= 0.377 + sin(iTime)/500.0;\n    }\n    return total;\n}\n\nfloat fbm_readded(vec2 uv)\n{\n    float i = fbm(uv);\n    uv.x = uv.x * 1.5;    \n    uv.y += 0.5f;\n    float i2 = fbm(uv);\n    uv.y = uv.y * 2.0;\n    uv.x -= 0.3f;\n    float i3 = fbm(uv);\n    uv.x = uv.x * 2.0;\n    uv.y += 0.7f;\n    float i4 = fbm(uv);\n    uv.y = uv.y * 1.5;\n    uv.x += .4f;\n    float i5 = fbm(uv);\n    return (i + i2 + i3 - i4 + i5)/3.0;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 1.5;\n    //uv.x -= iTime/8.0 + 1.8;\n    uv.y -= iTime/12.4 + .89;\n    uv.x -= iTime/9.0 + 1.9;\n    //uv.y -= iTime/9.4 + 0.9817;\n    vec2 uv2 = uv;\n    uv2.x +=  (iTime+10.0)/15.0;\n    uv2.y +=  (iTime-8.0)/12.0;\n    vec2 uv3 = uv2;\n    uv3.x += (iTime-7.0)/102.0;\n    uv3.y += (iTime+9.0)/96.0;\n    float main_cloudiness = fbm_readded(uv);\n    float intensity = max(main_cloudiness, \n                          1.3*fbm_readded(uv2))+ .9*main_cloudiness * fbm(uv2) * fbm(uv3);\n    intensity *= .64;\n    intensity += cos(sin(iTime/10.0))/7.0 - .3;\n    if (intensity < 0.5)\n        intensity *= intensity;\n    \n    vec3 color = vec3(1.0, 1.0, 1.0);\n    color *= intensity; \n    vec3 hsv = rgb2hsv(color);\n    hsv.z *= hsv.z ;\n    float overflow = 0.0;\n    if (hsv.z > 1.0)\n    {\n        overflow = hsv.z - 1.0;\n        hsv.y -= 0.01;\n    }\n    else if (hsv.z > 0.6)\n    {\n        hsv.y -= 0.05;\n        hsv.z -= 0.096;\n        hsv.z *= .93;\n        hsv.z *= sqrt(hsv.z)* 1.29;        \n    }\n    else\n    {\n        hsv.z -= 0.1;\n        hsv.z *= .9;\n     \n    }\n    hsv.z -= 0.02;\n    hsv.y -= 0.02;\n    color = hsv2rgb(hsv);  \n    color.b = 1.0;\n    color = color * sqrt(color);\n    color.r -= 2.0*overflow; \n    color.g -= 2.0*overflow;\n\tfragColor = vec4(color,1.0);\n    fragColor *= fragColor;\n}","name":"Image","description":"","type":"image"}]}