{"ver":"0.1","info":{"id":"DtcyDs","date":"1699802528","viewed":41,"name":"Distorted double twisted torus","username":"Spartansky","description":"Simple Raymarching where we twist a double torus and smooth shade with a sphere. Then some displacement for fun.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .0001\n\nmat2 Rot2d(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s,\n                s,  c);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere(vec3 p, float r){\n    return length(p) - r;\n}\n\nfloat sdTorus(vec3 p, vec2 t){\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n\n    float a = atan(p.x, p.z);\n\n    q *= Rot2d(-45.);\n    q *= Rot2d(a*sin(iTime/5.)*4.5);\n    q.y = abs(q.y)-.3;\n\n    return length(q)-t.y;\n}\n\nfloat GetDist(vec3 p){\n    vec3 tP = p;\n    vec3 sP = p;\n\n    float torusDist = sdTorus(tP, vec2(1.5,.25));\n    float sphereDist = sdSphere(sP, 1.);\n\n    float displacement = sin(cos(iTime+2.)*p.x)*sin(cos(iTime)*p.y)*sin(cos(iTime+3.)*p.z);\n\n    torusDist += displacement;\n    sphereDist += displacement*2.;\n\n    return opSmoothUnion(torusDist, sphereDist, .25);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float d0 = 0.;\n\n    for(int i=0; i < MAX_STEPS; i++){\n        vec3 p = ro + rd*d0;\n        float dS = GetDist(p);\n        d0 += dS;\n        if(d0 > MAX_DIST || dS < SURF_DIST) break;\n    }\n\n    return d0;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p) - \n        vec3(GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(\n            cross(\n                vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvec3 Bg(vec3 rd){\n    float k = rd.y*.5+.5;\n\n    vec3 col = mix(vec3(0.7373, 0.1686, 0.1686), vec3(0.0, 0.149, 1.0), k);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord.xy*2. - iResolution.xy)\n    /iResolution.y;\n\n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0, 2, 4);\n    vec3 rd = GetRayDir(vec2(uv.x, uv.y), vec3(ro.x, ro.y, ro.z), vec3(0,0,0), 1.25);\n   \n    col += Bg(rd);\n\n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = mix(Bg(r), vec3(dif), .5);\n        col *= vec3(0.2, 0.8078, 0.902)*1.5;\n        }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}