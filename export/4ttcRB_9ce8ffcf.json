{"ver":"0.1","info":{"id":"4ttcRB","date":"1533042973","viewed":174,"name":"IQzVcWc3e9MlVy063QMY","username":"liurui39660","description":"Too noisy, too many spheres, too shiny its color.\nJust a sample to perform pressure tests.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["none"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\nconst float PI = atan(1., 1.)*4.;\n\nconst vec3 BACKGROUND_COLOR = vec3(0.1, 0.2, 0.6);\nconst float FOVY = 50.0 * PI / 180.0;\nconst float DEFAULT_TMIN = 10.0e-4;\nconst float DEFAULT_TMAX = 10.0e6;\nconst int NUM_ITERATIONS = 2;\n\nstruct Ray_t {\n\tvec3 o;  // Ray Origin.\n\tvec3 d;  // Ray Direction. A unit vector.\n};\nstruct Plane_t {\n\t// The plane equation is Ax + By + Cz + D = 0.\n\tfloat A, B, C, D;\n\tint materialID;\n};\nstruct Sphere_t {\n\tvec3 center;\n\tfloat radius;\n\tint materialID;\n};\nstruct Light_t {\n\tvec3 position;  // Point light 3D position.\n\tvec3 I_a;       // For Ambient.\n\tvec3 I_source;  // For Diffuse and Specular.\n};\nstruct Material_t {\n\tvec3 k_a;   // Ambient coefficient.\n\tvec3 k_d;   // Diffuse coefficient.\n\tvec3 k_r;   // Reflected specular coefficient.\n\tvec3 k_rg;  // Global reflection coefficient.\n\tfloat n;    // The specular reflection exponent. Ranges from 0.0 to 128.0. \n};\n\n#define HitType_t int\n#define NOTHING 0\n#define PLANE 1\n#define SPHERE 2\n\nconst int NUM_PER_DIR = 7;\n\nconst int NUM_SPHERES = NUM_PER_DIR * NUM_PER_DIR;\nconst float RADIUS = 1.0 / 4.0;\nSphere_t Sphere[NUM_SPHERES];\nint index(int x, int y) {\n\treturn x * NUM_PER_DIR + y;\n}\nvoid InitSphere() {\n\tfor (int i = 0; i < NUM_PER_DIR; i++) {\n\t\tfor (int j = 0; j < NUM_PER_DIR; j++) {\n\t\t\tSphere[index(i, j)].radius = RADIUS;\n\t\t\tSphere[index(i, j)].center = vec3(i - (NUM_PER_DIR - 1) / 2, sin(0.5*iTime + float(i + j)) + 3.0 + RADIUS, j - (NUM_PER_DIR - 1) / 2);\n\t\t\tSphere[index(i, j)].materialID = index(i, j);\n\t\t}\n\t}\n\tSphere[index((NUM_PER_DIR - 1) / 2, (NUM_PER_DIR - 1) / 2)].center = vec3(0, 1e20, 0);\n}\n\nconst int NUM_PLANES = 5;\nPlane_t Plane[NUM_PLANES];\nvoid InitPlane() {\n\tPlane[0].A = 0.0;\n\tPlane[0].B = 1.0;\n\tPlane[0].C = 0.0;\n\tPlane[0].D = 0.0;\n\tPlane[0].materialID = -1;\n\n\tPlane[1].A = 0.0;\n\tPlane[1].B = 0.0;\n\tPlane[1].C = 1.0;\n\tPlane[1].D = 5.0;\n\tPlane[1].materialID = -1;\n\n\tPlane[2].A = 1.0;\n\tPlane[2].B = 0.0;\n\tPlane[2].C = 0.0;\n\tPlane[2].D = 5.0;\n\tPlane[2].materialID = -1;\n\n\tPlane[3].A = 0.0;\n\tPlane[3].B = 0.0;\n\tPlane[3].C = -1.0;\n\tPlane[3].D = 5.0;\n\tPlane[3].materialID = -1;\n\n\tPlane[4].A = -1.0;\n\tPlane[4].B = 0.0;\n\tPlane[4].C = 0.0;\n\tPlane[4].D = 5.0;\n\tPlane[4].materialID = -1;\n}\n\nconst int NUM_LIGHTS = 2;\nLight_t Light[NUM_LIGHTS];\nvoid InitLight() {\n\t// Light 0.\n\tLight[0].position = vec3(0, 0.5*sin(0.25*iTime) + 3.0 + RADIUS, 0);\n\tLight[0].I_a = vec3(0.1, 0.1, 0.1);\n\tLight[0].I_source = vec3(1.0, 1.0, 1.0);\n}\n\nconst int NUM_MATERIALS = NUM_PER_DIR * NUM_PER_DIR;\nMaterial_t Material[NUM_MATERIALS];\nvoid InitMaterial() {\n\tfor (int i = 0; i < NUM_PER_DIR; i++) {\n\t\tfor (int j = 0; j < NUM_PER_DIR; j++) {\n\t\t\tMaterial[index(i, j)].k_d = vec3(\n\t\t\t\t0.4*sin(0.25*iTime + float(i + j)*PI / float(2 * NUM_PER_DIR)) + 0.6,\n\t\t\t\t0.4*sin(0.5*iTime + float(i + j)*PI / float(2 * NUM_PER_DIR)) + 0.6,\n\t\t\t\t0.4*sin(0.375*iTime + float(i + j)*PI / float(2 * NUM_PER_DIR)) + 0.6);\n\t\t\tMaterial[index(i, j)].k_a = 0.2*Material[0].k_d;\n\t\t\tMaterial[index(i, j)].k_r = 2.0 * Material[0].k_d;\n\t\t\tMaterial[index(i, j)].k_rg = 0.5 * Material[0].k_r;\n\t\t\tMaterial[index(i, j)].n = 64.0;\n\t\t}\n\t}\n}\n\nvoid InitScene() {\n\tInitSphere();\n\tInitPlane();\n\tInitLight();\n\tInitMaterial();\n}\nbool IntersectPlane(in Plane_t pln, in Ray_t ray, in float tmin, in float tmax, out float t, out vec3 hitPos, out vec3 hitNormal, out HitType_t hitType) {\n\tvec3 N = vec3(pln.A, pln.B, pln.C);\n\tfloat NRd = dot(N, ray.d);\n\tfloat NRo = dot(N, ray.o);\n\tfloat t0 = (-pln.D - NRo) / NRd;\n\tif (t0 < tmin || t0 > tmax) return false;\n\n\tt = t0;\n\thitPos = ray.o + t0 * ray.d;\n\thitNormal = normalize(N);\n\thitType = PLANE;\n\treturn true;\n}\nbool IntersectPlane(in Plane_t pln, in Ray_t ray, in float tmin, in float tmax) {\n\tfloat _;\n\tvec3 _1;\n\tHitType_t _2;\n\treturn IntersectPlane(pln, ray, tmin, tmax, _, _1, _1, _2);\n}\nbool IntersectSphere(in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax, out float t, out vec3 hitPos, out vec3 hitNormal, out HitType_t hitType) {\n\tray.o -= sph.center;\n\tfloat a = dot(ray.d, ray.d);\n\tfloat b = 2.0 * dot(ray.d, ray.o);\n\tfloat c = dot(ray.o, ray.o) - sph.radius*sph.radius;\n\tfloat d = b * b - 4.0 * a*c;\n\tif (d > 0.0) {\n\t\tfloat solutionA = (-b + sqrt(d)) / (2.0 * a);\n\t\tfloat solutionB = (-b - sqrt(d)) / (2.0 * a);\n\t\tif (solutionB > 0.0)\n\t\t\tt = solutionB;\n\t\telse if (solutionA > 0.0)\n\t\t\tt = solutionA;\n\t\telse\n\t\t\treturn false;\n\t}\n\telse if (d == 0.0)\n\t\tt = -b / (2.0*a);\n\telse\n\t\treturn false;\n\thitPos = ray.o + t * ray.d + sph.center;\n\thitNormal = normalize(hitPos - sph.center);\n\thitType = SPHERE;\n\treturn tmin < t&&t < tmax;\n}\nbool IntersectSphere(in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax) {\n\tfloat _;\n\tvec3 _1;\n\tHitType_t _2;\n\treturn IntersectSphere(sph, ray, tmin, tmax, _, _1, _1, _2);\n}\nvec3 PhongLighting(in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n\tin Material_t mat, in Light_t light) {\n\tif (inShadow) {\n\t\treturn light.I_a * mat.k_a;\n\t}\n\telse {\n\t\tvec3 R = reflect(-L, N);\n\t\tfloat N_dot_L = max(0.0, dot(N, L));\n\t\tfloat R_dot_V = max(0.0, dot(R, V));\n\t\tfloat R_dot_V_pow_n = (R_dot_V == 0.0) ? 0.0 : pow(R_dot_V, mat.n);\n\t\treturn light.I_a * mat.k_a + light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n\t}\n}\nMaterial_t TextureColor(HitType_t hitType, int hitIndex, vec3 hitPos) {\n\tswitch (hitType) {\n\tcase SPHERE:\n\t\treturn Material[0];\n\tcase PLANE:\n\t\tif (hitIndex == 0) {\n\t\t\tvec3 color = texture(iChannel0, hitPos.xz / 10.).xyz;\n\t\t\treturn Material_t(0.0*color, 1.0*color, 1.0*color, 0.0*color, 64.0);\n\t\t}\n\t\telse if (hitIndex == 1 || hitIndex == 3) {\n\t\t\tvec3 color = texture(iChannel0, hitPos.xy / 10.).xyz;\n\t\t\treturn Material_t(0.0*color, 1.0*color, 1.0*color, 0.0*color, 64.0);\n\t\t}\n\t\telse if (hitIndex == 2 || hitIndex == 4) {\n\t\t\tvec3 color = texture(iChannel0, hitPos.zy / 10.).xyz;\n\t\t\treturn Material_t(0.0*color, 1.0*color, 1.0*color, 0.0*color, 64.0);\n\t\t}\n\t}\n}\nvec3 CastRay(in Ray_t ray,\n\tout bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg) {\n\tbool hasHitSomething = false;\n\tfloat nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n\tvec3 nearest_hitPos;              // 3D position of the nearest hit point.\n\tvec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n\tint nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\tHitType_t nearest_hitType = NOTHING;\n\tint nearest_hitIndex;\n\tfloat temp_t;\n\tvec3 temp_hitPos;\n\tvec3 temp_hitNormal;\n\tbool temp_hasHit;\n\tHitType_t temp_hitType;\n\tMaterial_t mat;\n\tfor (int i = 0; i < NUM_PLANES; i++) {\n\t\ttemp_hasHit = IntersectPlane(Plane[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal, temp_hitType);\n\t\tif (temp_hasHit&&temp_t < nearest_t) {\n\t\t\thasHitSomething = true;\n\t\t\tnearest_t = temp_t;\n\t\t\tnearest_hitPos = temp_hitPos;\n\t\t\tnearest_hitNormal = temp_hitNormal;\n\t\t\tnearest_hitMatID = Plane[i].materialID;\n\t\t\tnearest_hitType = temp_hitType;\n\t\t\tnearest_hitIndex = i;\n\t\t}\n\t}\n\tfor (int i = 0; i < NUM_SPHERES; i++) {\n\t\ttemp_hasHit = IntersectSphere(Sphere[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal, temp_hitType);\n\t\tif (temp_hasHit&&temp_t < nearest_t) {\n\t\t\thasHitSomething = true;\n\t\t\tnearest_t = temp_t;\n\t\t\tnearest_hitPos = temp_hitPos;\n\t\t\tnearest_hitNormal = temp_hitNormal;\n\t\t\tnearest_hitMatID = Sphere[i].materialID;\n\t\t\tnearest_hitType = temp_hitType;\n\t\t\tnearest_hitIndex = i;\n\t\t}\n\t}\n\thasHit = hasHitSomething;\n\tif (!hasHitSomething) return BACKGROUND_COLOR;\n\tvec3 I_local = vec3(0.0);\n\tbool inShadow[NUM_LIGHTS];\n\tRay_t rayHitPosToLight[NUM_LIGHTS];\n\tfor (int i = 0; i < NUM_LIGHTS; i++) {\n\t\tinShadow[i] = false;\n\t\trayHitPosToLight[i] = Ray_t(nearest_hitPos, normalize(Light[i].position - nearest_hitPos));\n\t\tfor (int j = 0; j < NUM_PLANES; j++)\n\t\t\tif (IntersectPlane(Plane[j], rayHitPosToLight[i], DEFAULT_TMIN, length(Light[i].position - nearest_hitPos)))\n\t\t\t\tinShadow[i] = true;\n\t\tfor (int j = 0; j < NUM_SPHERES; j++)\n\t\t\tif (IntersectSphere(Sphere[j], rayHitPosToLight[i], DEFAULT_TMIN, length(Light[i].position - nearest_hitPos)))\n\t\t\t\tinShadow[i] = true;\n\t}\n\tfor (int i = 0; i < NUM_LIGHTS; i++) {\n\t\tif (nearest_hitMatID >= 0)\n\t\t\tmat = Material[nearest_hitMatID];\n\t\telse\n\t\t\tmat = TextureColor(nearest_hitType, nearest_hitIndex, nearest_hitPos);\n\t\tI_local += PhongLighting(rayHitPosToLight[i].d, nearest_hitNormal, normalize(-ray.d), inShadow[i], mat, Light[i]);\n\t}\n\thitPos = nearest_hitPos;\n\thitNormal = nearest_hitNormal;\n\tk_rg = Material[nearest_hitMatID].k_rg;\n\treturn I_local;\n}\nRay_t Camera(vec3 position, vec3 lookAt, vec3 upVector) {\n\tvec3 positionPixel = vec3((2.0 * gl_FragCoord.xy - iResolution.xy) / iResolution.y, -1.0 / tan(FOVY / 2.0));\n\tvec3 z = normalize(position - lookAt);\n\tvec3 x = normalize(cross(upVector, z));\n\tvec3 y = normalize(cross(z, x));\n\treturn Ray_t(position, normalize(positionPixel.x*x + positionPixel.y*y + positionPixel.z*z));\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tInitScene();\n\tRay_t nextRay = Camera(vec3(5.0*sin(0.2*iTime), 5.0, 5.0*cos(0.2*iTime)), vec3(-5.0*sin(0.2*iTime), 0.0, -5.0*cos(0.2*iTime)), vec3(0., 1., 0.));\n\tfragColor = vec4(0, 0, 0, 1);\n\tvec3 compounded_k_rg = vec3(1.0);\n\tfor (int level = 0; level <= NUM_ITERATIONS; level++) {\n\t\tbool hasHit;\n\t\tvec3 hitPos, hitNormal, k_rg;\n\t\tvec3 I_local = CastRay(nextRay, hasHit, hitPos, hitNormal, k_rg);\n\t\tfragColor.xyz += compounded_k_rg * I_local;\n\t\tif (!hasHit)\n\t\t\tbreak;\n\t\tcompounded_k_rg *= k_rg;\n\t\tnextRay = Ray_t(hitPos, normalize(reflect(nextRay.d, hitNormal)));\n\t}\n}\n","name":"Image","description":"","type":"image"}]}