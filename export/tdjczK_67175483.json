{"ver":"0.1","info":{"id":"tdjczK","date":"1587360779","viewed":471,"name":"Flying over the night city","username":"ilyaev","description":"Flying over the night city. Looks better fullscreen. Use mouse to control camera rotation. Move mouse to center to switch back to demo mode (Thanks to Fabrice for suggestion)","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["mouse","grid","night","city","generated","fly"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CAMERA_RANGE 8.\n#define CAMERA_TIME_SCALE .1\n#define SHOW_CARS true\n#define COLOR_WINDOW vec3(1., .9, .45)\n#define COLOR_WINDOW_TINT vec3(0.9, .3, .1)\n#define COLOR_BUILDING_BASE vec3(0.3,.5, .1)\n#define COLOR_ROAD_DELIMETER vec3(0.87, .72, .14)\n#define COLOR_ROAD vec3(0.1)\n#define COLOR_ROAD_SIDEWALK vec3(.7)\n#define COLOR_CAR_ROOF vec3(.3)\n#define MAX_STEPS 256\n#define MIN_DISTANCE 0.0001\n#define MAX_DISTANCE 10.\n#define defaultBaseSize .3\n#define defaultBaseSpacing 2.5\n#define bounds vec3(7.0, 7.0, 0.)\n#define BLD_RECT 1.\n#define BLD_HEX 2.\n#define BLD_TUBE 4.\n#define OBJ_FLOOR 3.\n#define OBJ_CAMERA 5.\n#define OBJ_DOME 6.\n#define OBJ_CAR 7.\n#define BULDING_BASE_SIZE .4\n#define PI 3.14\n\nvec2 mouse;\n\nfloat CELL_SIZE = (defaultBaseSize + defaultBaseSpacing/2.);\nfloat HALF_CELL_SIZE;\n\nstruct Camera {\n    float z;\n    float x;\n    float y;\n    float verticalAngle;\n    float horizontalAngle;\n    float rotation;\n};\n\nCamera camera;\n\nbool isScripted = true;\n\n// #iUniform float my_scalar = 1.0 in { 0.0, 5.0 } // This will expose a slider to edit the value\n\n\n\nstruct DistBuilding {\n    float d;\n    vec3 size;\n    float height;\n    vec3 q1;\n    float objId;\n};\n\nstruct DistResult {\n    float d;\n    vec3 id;\n    vec3 q1;\n    vec3 p;\n    float h;\n    float obj;\n    DistBuilding building;\n    DistBuilding cars;\n};\n\nstruct TraceResult {\n    vec3 id;\n    float dt;\n    float ds;\n    float h;\n    vec3 p;\n    vec3 q1;\n    DistResult dist;\n    float obj;\n};\n\n\n\n\nfloat hexDist(vec2 uv) {\n    uv = abs(uv);\n    return max(uv.x, dot(uv, normalize(vec2(1., 1.73))));\n}\n\n\nmat2 rot2d(float a) {\n    float ca = cos(a);\n    float sa = sin(a);\n    return mat2(vec2(sa, ca), vec2(-ca, sa));\n}\n\nfloat n21(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat smoothNoise(vec2 uv) {\n    vec2 lv = smoothstep(0., 1., fract(uv));\n    vec2 id = floor(uv);\n\n    float bl = n21(id);\n    float br = n21(id + vec2(1.,0.));\n    float b = mix(bl, br, lv.x);\n\n    float tl = n21(id + vec2(0.,1.));\n    float tr = n21(id + vec2(1.,1.));\n    float t = mix(tl, tr, lv.x);\n\n    float n = mix(b, t, lv.y);\n    return n;\n}\n\nfloat noise(vec2 uv, int level) {\n    float n = 0.;\n    float d = 1.;\n    if (level > 0) {\n\t    n += smoothNoise(uv * 4.);\n    }\n    if (level > 1) {\n\t    n += smoothNoise(uv * 8.) * .5;\n        d += .5;\n    }\n    if (level > 2) {\n    \tn += smoothNoise(uv * 16.) * .25;\n        d += .25;\n    }\n    if (level > 3) {\n\t    n += smoothNoise(uv * 32.) * .125;\n        d += .125;\n    }\n    if (level > 4) {\n\t    n += smoothNoise(uv * 64.) * .025;\n        d += .0625;\n    }\n    return n / d;\n}\n\nvec3 getColorById(vec3 id) {\n    float n = max(.2, n21(vec2(id.x, id.y)));\n    vec3 rcol = vec3(n, fract(n*567.433), fract(n*1689.33));\n    return rcol;\n}\n\nvec3 withMouse(vec3 p) {\n        vec2 mouse = iMouse.xy/iResolution.xy;\n        float a = max(mouse.y, .505) * 3.14 * 2.;\n        p.yz *= rot2d(a);\n        float aa = mouse.x * 3.14 * 2.;\n        p.xy *= rot2d(aa);\n        return p;\n}\n\nvec3 setSceneAngle(vec3 p) {\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    p.yz *= rot2d(PI);\n    p.xy *= rot2d(camera.horizontalAngle);\n    p.x += HALF_CELL_SIZE;\n    p.y += HALF_CELL_SIZE;\n    // p.xy -= .77;\n    p += vec3(camera.x, camera.y, camera.z);\n    return p;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nDistBuilding distBuilding(vec3 q1, vec3 id) {\n    DistBuilding res;\n    float n = n21(id.xy);\n    float n1 = fract(n*4553.33);\n    float n2 = fract(n*145.33);\n\n    float obj = BLD_RECT;\n\n    if (n1 > .7) {\n        obj = BLD_HEX;\n    } else if (n2 > .8) {\n        obj = BLD_TUBE;\n    }\n\n    float baseSize = defaultBaseSize;\n\n    float h = baseSize;\n\n    if (obj == BLD_TUBE && n1 < .2 ) {\n        n = (sin(q1.x + (n1*50.)) * .5 + .5);\n    }\n\n    float ah = n * .5;\n\n    h += ah;\n    q1.z -= ah;\n    q1.z -= defaultBaseSize;\n\n    float d;\n\n\n\n    vec3 size = vec3(baseSize, baseSize, h);\n\n    if (obj == BLD_HEX) {\n        d = sdHexPrism(q1, vec2(size.x, size.z));\n    } else if (obj == BLD_TUBE) {\n        float tmp = q1.z;\n        q1.z = q1.y;\n        q1.y = tmp;\n        d = sdCappedCylinder(q1, baseSize, size.z);\n    } else {\n        if (n1 > .3) {\n            size.x *= .5;\n            size.y *= 1.5;\n        } else if (n2 > .5) {\n            size.y *= .5;\n            size.x *= 1.5;\n        }\n\n        if (n < .6) {\n            vec3 q2,nsize, nsize3, q3, d3;\n            if (n2 < .2 && size.x == size.y) {\n                d = sdBox(q1, size);\n                q2 = vec3(q1.x, q1.y, q1.z - size.z);\n                nsize = vec3(size.xy/1.5, size.z*2.);\n                q3 = vec3(q1.x, q1.y, q1.z - size.z - size.z / 1.8);\n                nsize3 = vec3(size.xy/(1.5*1.5), size.z*2. + size.z / 1.8);\n            } else {\n                q1 += vec3(0.1, -0.08, 0.);\n                d = sdBox(q1, size);\n                float extraH = size.z + size.z * n1;\n                q2 = vec3(q1.x - .18, q1.y + .18, q1.z - extraH);\n                nsize = vec3(size.xy, size.z + extraH);\n                if (n1 > .4) {\n                    nsize.xy = nsize.yx;\n                }\n            }\n\n            float d2 = sdBox(q2, nsize);\n            if (d2 < d) {\n                q1 = q2;\n                size = nsize;\n                d = d2;\n            }\n\n            if (nsize3.x != 0.) {\n                float d3 = sdBox(q3, nsize3);\n                if (d3 < d) {\n                    q1 = q3;\n                    size = nsize3;\n                    d = d3;\n                }\n            }\n\n        } else {\n            d = sdBox(q1, size);\n        }\n    }\n\n    res.d = d;\n    res.q1 = q1;\n    res.size = size;\n    res.objId = obj;\n    res.height = size.z;\n\n    return res;\n}\n\nDistBuilding distCars(vec3 po) {\n    DistBuilding res;\n\n\n    float carSize = .02;\n\n    po -= vec3(vec2(HALF_CELL_SIZE), carSize / 2.);\n\n    vec3 baseSpacing = vec3(CELL_SIZE);\n    vec3 rc1 = vec3(baseSpacing);\n    vec3 direction = vec3(-1, 0., 0.);\n\n    float t = iTime * 2.;\n\n    vec3 p = po;\n\n    p.x -= t;\n\n    vec3 id = round(p/rc1);\n    if (mod(id.y, 2.) == 0.) {\n        p = po;\n        p.x += t;\n        id = round(p/rc1);\n        direction.x = 1.;\n    }\n    float n = n21(id.xy);\n\n    vec3 q1 = p - rc1*vec3(id.xy, 0.);\n\n    q1.x -= (sin(iTime*7. * n)*.5 + .5)*HALF_CELL_SIZE;\n    q1.y -= (n - .5)/6.;\n\n    float d = sdBox(q1, vec3(carSize*2., carSize, carSize));\n\n    p = po;\n\n    p.y -= t;\n    vec3 direction2 = vec3(0., -1., 0.);\n\n    id = round(p/rc1);\n    if (mod(id.x , 2.) == 0.) {\n        p = po;\n        p.y += t;\n        id = round(p/rc1);\n        direction2.y = 1.;\n    }\n    n = n21(id.xy);\n\n    q1 = p - rc1*vec3(id.xy, 0.);\n\n    q1.y -= (sin(iTime*5. * n)*.5 + .5)*HALF_CELL_SIZE; //(n - .5)/CELL_SIZE;\n    q1.x -= (n - .5)/6.;\n\n    float d1 = sdBox(q1, vec3(carSize, carSize * 2., carSize));\n\n    res.d = min(d, d1);\n    res.q1 = d1 > d ? direction : direction2;\n    return res;\n}\n\n\nDistResult getDist(vec3 p) {\n    vec3 baseSpacing = vec3(defaultBaseSize + defaultBaseSpacing/2.);\n\n    vec3 l = bounds;\n    vec3 rc1 = vec3(baseSpacing);\n\n    vec3 id = round(p/rc1);\n\n    vec3 q1 = p - rc1 * clamp(id, -l, l);\n\n    DistBuilding building = distBuilding(q1, id);\n\n    float d = building.d;\n    float obj = building.objId;\n    q1 = building.q1;\n\n    // d = 1000000.;\n    float floord = p.z;\n\n    if (floord < d) {\n        obj = OBJ_FLOOR;\n    }\n\n    d = min(d, floord);\n\n    float skyD = -(length(p) - 30.);\n\n    if (skyD < d) {\n        obj = OBJ_DOME;\n        d = skyD;\n    }\n    DistBuilding cars;\n    if (SHOW_CARS) {\n        cars = distCars(p);\n        if (cars.d < d) {\n            d = cars.d;\n            obj = OBJ_CAR;\n        }\n    }\n\n    // if (!isScripted) {\n    //     vec3 cameraQ = vec3(-p.x + HALF_CELL_SIZE, -p.y + HALF_CELL_SIZE, p.z-.3) + vec3(camera.x, camera.y, camera.z);\n    //     cameraQ.xy *= rot2d(-camera.horizontalAngle);\n    //     float cd = sdBox(cameraQ, vec3(.1, .2, .1));\n    //     if (cd < d) {\n    //         p = cameraQ;\n    //         obj = OBJ_CAMERA;\n    //     }\n\n    //     d = min(d, cd);\n    // }\n\n\n    DistResult r;\n    r.d = d;\n    r.id = id;\n    r.q1 = q1;\n    r.building = building;\n    r.cars = cars;\n    r.p = p;\n    r.obj = obj;\n    return r;\n}\n\nTraceResult trace(vec3 ro, vec3 rd) {\n    float ds,dt;\n    float n;\n    vec3 id, shift;\n    vec3 p;\n    vec3 q1;\n\n    DistResult dist;\n\n\n    for(int i = 0 ; i < MAX_STEPS ; i++) {\n        p = ro + rd * ds;\n\n        if (isScripted) {\n            p = setSceneAngle(p);\n        } else {\n            p = withMouse(p);\n        }\n\n        dist = getDist(p);\n\n        dt = dist.d;\n        id = dist.id;\n        q1 = dist.q1;\n\n        ds += dt * .4;\n\n        if (abs(dt) < MIN_DISTANCE || dt > MAX_DISTANCE) {\n            break;\n        }\n    }\n\n    TraceResult res;\n\n    res.id = id;\n    res.dt = dt;\n    res.ds = ds;\n    res.p = p;\n    res.q1 = q1;\n    res.obj = dist.obj;\n    res.dist = dist;\n\n    return res;\n}\n\nvec3 getNormal(vec3 p, float d) {\n    vec2 e = vec2(0.00001, 0.);\n    vec3 n = d - vec3(\n        getDist(p - e.xyy).d,\n        getDist(p - e.yxy).d,\n        getDist(p - e.yyx).d\n    );\n    return normalize(n);\n}\n\n\nvec3 getCubeUV(vec3 p, vec3 normal, vec3 fsize) {\n    vec2 cuv = vec2(0.);\n    vec2 size = fsize.yz;\n    if (normal.z != 0.) {\n        // roof\n        cuv.xy = vec2(p.x, p.y);\n        size = fsize.xy;\n        // size.y = size.x;\n    }\n    if (normal.x != 0.) {\n        cuv.xy = vec2(p.y, p.z);\n        size = fsize.yz;\n    }\n    if (normal.y != 0.) {\n        cuv = vec2(p.x, p.z);\n        size = fsize.xz;\n    }\n\n    cuv /= size*2.;\n\n    cuv += vec2(.5, .5);\n\n    float r = size.x / size.y;\n\n    cuv -= vec2((r-1.)*.03, 0.);\n\n    cuv.x *= r;\n\n    return vec3(cuv, r);\n}\n\nvec2 getTubeUV(vec3 p, vec3 normal, vec2 size) {\n    float x = atan(p.x, p.z) / 6.28;\n    float y = p.y/size.y;\n\n    vec2 cuv = vec2(x, y);\n    if (normal.z != 0.) {\n        cuv = p.xz / size.x;\n    }\n    return cuv;\n}\n\nvec2 getHexUV(vec3 p, vec3 normal, vec2 size) {\n\n    float x = atan(p.x, p.y) / 6.28;\n    float y = p.z/size.y;\n\n    vec2 cuv = vec2(x, y);\n\n    if (normal.z != 0.) {\n        cuv = p.xy / size.x;\n    }\n\n    cuv += vec2(.5, .5);\n\n    return cuv;\n}\n\nvec4 allWindowsSkyscraperTexture(vec3 p, vec2 uv, vec3 normal, vec3 bid, float xr, float obj, float w, vec3 size) {\n    vec3 col = vec3(0.15);\n    vec2 wuv = uv;\n\n    float frameWidth = .03;\n\n    float frame;\n\n    float fogMultiplier = 0.;\n\n    if (obj == BLD_RECT) {\n        if (normal.z == 0.) {\n            frame = step(uv.x, frameWidth) +  step((1. - frameWidth) * xr, uv.x) + step((1. - frameWidth), uv.y);\n            frame += step(uv.y, frameWidth);\n        } else {\n            if (size.x > size.y) {\n                frame = step(uv.x, frameWidth - .15) +  step((.95 - frameWidth) * xr, uv.x) + step((1. - frameWidth), uv.y);\n            } else {\n                frame = step(uv.x, frameWidth) +  step((1. - frameWidth) * xr, uv.x) + step((1. - frameWidth), uv.y);\n            }\n            frame += step(uv.y, frameWidth);\n        }\n        uv *= 40. * w / xr;\n    } else if (obj == BLD_HEX) {\n        vec2 huv = uv;\n        if (normal.z == 0.) {\n            frame = step(fract(huv.x*6. + .53), .1);\n            frame += step(1.46, huv.y);\n        } else {\n            frame = step(1. - frameWidth * 2., hexDist((uv - .5)*rot2d(3.14)));\n        }\n        float scaleY = 20. * defaultBaseSize / xr;\n        uv *= vec2(scaleY*(6.*xr), scaleY);\n    } else if (obj == BLD_TUBE) {\n        vec2 huv = uv;\n        if (normal.z != 0.) {\n            float hl = length(huv);\n            frame = step(hl, 1.1) - step(hl, 1. - frameWidth * 2.);\n        } else {\n            frame = step(1. - frameWidth * 2., huv.y);\n        }\n        float scaleY = 20. * defaultBaseSize / xr;\n        uv *= vec2(scaleY*(6.*xr), scaleY);\n    }\n\n    col += frame;\n\n    if (normal.z == 0. && frame == 0.) {\n\n        float bn = fract(n21(bid.xy)*567.85);\n        float distToBuilding = distance(bid*CELL_SIZE, vec3(camera.x, camera.y, camera.z));\n\n        bool isLight = bn > .6 && distToBuilding > 6. ? true : false;\n        col = vec3(0.);\n        vec2 id = floor(uv);\n        uv = fract(uv);\n        float n = n21(id + bid.xy + 22.*floor(normal.xy));\n        float borders = (step(uv.x, .3) + step(uv.y, .3));\n        if (!isLight && n > .7 && abs(sin(bid.x + bid.y + fract(n*23422.)*110. + iTime/50.)) > fract(n*123.22)) {\n            col += COLOR_WINDOW * (1. - borders);\n            col += borders * COLOR_WINDOW_TINT;\n            fogMultiplier = .3;\n        } else {\n            if (borders != 0.) {\n                col = vec3(0.2);\n                if (isLight) {\n                    vec2 lights = vec2(sin(wuv.x + iTime + fract(bn * 3322.)*10.), sin(wuv.y + iTime + fract(bn * 3322.)*10.));\n                    if (bn > .85) {\n                        col.rb += lights;\n                    } else {\n                        col.rg += lights;\n                    }\n                }\n            }\n        }\n\n    }\n\n    return vec4(col, fogMultiplier);\n}\n\nvec3 domeTexture(vec3 p) {\n    vec3 q1 = p;\n    q1.yz *= rot2d(PI);\n    p = q1;\n    vec3 col = vec3(.01);\n    float x = acos(p.y/length(p));\n    float y = atan(p.z, p.x) / 6.28;\n    vec2 uv = vec2(x, y) + .5;\n\n    float rize = .1 + sin(iTime/6.)*.1;\n\n    vec2 muv = uv*vec2(1., 5.);\n    vec2 id = floor(muv);\n    muv = fract(muv) - .5;\n    muv += vec2(rize, 0.);\n\n    bool isMoon = false;\n\n    if (id.y == 2.) {\n        float muvl = length(muv);\n        float ml = muvl * 1.5;\n        vec3 mc = step(ml, .1) * vec3(noise(5. + muv*4. + iTime/50., 5));\n        if (ml > .1) {\n            mc += pow(.05 / muvl, 6.0);\n        }\n        if (ml < .15) {\n            isMoon = true;\n        }\n        col += mc * vec3(.9, .6, .1);\n    }\n\n    vec2 suv = uv * vec2(30., 150.);\n    vec2 sid = floor(suv);\n    suv = fract(suv) - .5;\n\n    float n = n21(sid);\n    if (n > .7 && !isMoon) {\n        col += step(length(suv + vec2(fract(n*3432.33) - .5, fract(n*78953.2) - .5)), .04*fract(n*123.123));\n    }\n\n    return col;\n}\n\nvec4 floorTexture(vec3 p, vec3 q1) {\n    vec3 col = vec3(0.);\n\n    float fogMultiplier = 0.;\n\n    vec2 uv = mod((p.xy - HALF_CELL_SIZE), CELL_SIZE) / CELL_SIZE - .5;\n    vec2 roadUV = mod((p.xy), CELL_SIZE) / CELL_SIZE;\n    vec2 blockID = floor(p.xy / CELL_SIZE);\n\n    if (abs(blockID.x) > bounds.x || abs(blockID.y) > bounds.y) {\n        return vec4(COLOR_BUILDING_BASE, fogMultiplier);\n    }\n\n    float roadX = step(BULDING_BASE_SIZE, roadUV.x) - step(1. - BULDING_BASE_SIZE, roadUV.x);\n    float roadY = step(BULDING_BASE_SIZE, roadUV.y) - step(1. - BULDING_BASE_SIZE, roadUV.y);\n\n    float road = max(roadX, roadY);\n\n\n    col += road * COLOR_ROAD;\n\n    // col.rg = roadUV;\n    // col.rg = uv;\n\n    vec2 baseUV = abs(uv);\n    col += step(max(baseUV.x, baseUV.y), BULDING_BASE_SIZE*.9) * COLOR_BUILDING_BASE;\n\n    uv = fract((uv + .26)*8.);\n\n    if (roadX == 0.) {\n        uv.x /= 4.;\n    }\n    if (roadY == 0.) {\n        uv.y /= 4.;\n    }\n\n    float delimeter = step(max(uv.x, uv.y), .1) * road;\n\n    fogMultiplier = delimeter * 1.5;\n\n    col += delimeter * COLOR_ROAD_DELIMETER;\n\n    if (col.x == 0.) {\n        col = COLOR_ROAD_SIDEWALK;\n    }\n\n    vec2 zebraUV = roadUV * 12.;\n    vec2 zebraID = floor(zebraUV);\n    zebraUV = fract(zebraUV);\n\n    float n = n21(blockID);\n\n    if (zebraID.x == 3. && road > 0. && n > .7) {\n        col += step(fract((zebraUV - .08)*vec2(1., 3.)).y + .1, .4);\n    }\n    if (zebraID.y == 3. && road > 0. && fract(n*123.33) > .7) {\n        col += step(fract((zebraUV - .08)*vec2(3., 1.)).x + .1, .4);\n    }\n\n    return vec4(col, fogMultiplier);\n}\n\nvec3 carTexture(TraceResult tr, vec3 normal) {\n    vec3 col = vec3(0.);\n    vec3 dir = tr.dist.cars.q1;\n\n    if (normal.y > 0. && dir.x == 0.) {\n        if (dir.y > 0.) {\n            col.r += 1.;\n        } else {\n            col.rgb += 1.;\n        }\n    } else\n    if (normal.y < 0. && dir.x == 0.) {\n        if (dir.y < 0.) {\n            col.r += 1.;\n        } else {\n            col.rgb += 1.;\n        }\n    } else\n\n    if (normal.x > 0. && dir.y == 0.) {\n        if (dir.x > 0.) {\n            col.r += 1.;\n        } else {\n            col.rgb += 1.;\n        }\n    } else\n    if (normal.x < 0. && dir.y == 0.) {\n        if (dir.x < 0.) {\n            col.r += 1.;\n        } else {\n            col.rgb += 1.;\n        }\n    } else {\n        col = COLOR_CAR_ROOF;\n    }\n\n    return col;\n}\n\nvec4 getBuildingTexture(TraceResult tr, vec3 normal) {\n    vec3 col = vec3(0.);\n\n    vec3 id = tr.id;\n    float objId = tr.obj;\n\n    vec3 p = tr.p;\n\n    float baseSize = normal.x == 0. ? tr.dist.building.size.x : tr.dist.building.size.y;\n\n    vec2 size = vec2(baseSize, tr.dist.building.height);\n\n    vec3 cubeUV = getCubeUV(tr.q1, normal, tr.dist.building.size);\n    vec2 uv = cubeUV.xy;\n\n    if (objId == BLD_HEX) {\n        uv = getHexUV(tr.q1, normal, size);\n    }\n    if (objId == BLD_TUBE) {\n        uv = getTubeUV(tr.q1, normal, size);\n    }\n\n    vec4 tc = allWindowsSkyscraperTexture(p, uv, normal, id, cubeUV.z, tr.obj, baseSize, tr.dist.building.size);\n\n    col += tc.rgb;\n\n    return vec4(col, tc.w);\n}\n\nvec2 getCameraIterationPosition(float iteration) {\n    if (iteration == 0.) {\n        return vec2(0.);\n    }\n    float n = n21(vec2(iteration));\n\n    float m = CAMERA_RANGE;\n    return round(vec2((n - .5) * m, (fract(n*113.43) - .5) * m));\n}\n\nvec3 cameraNextPosition() {\n    float t = iTime * CAMERA_TIME_SCALE;\n\n    vec2 center = vec2(.0);\n\n    float iterationDuration = 1.;\n\n    float iteration = floor(t / iterationDuration) + 1.;\n    float stepSize = 1.;\n\n    float cellStepSize = CELL_SIZE*stepSize;\n\n    vec2 prevPosition = getCameraIterationPosition(iteration - 1.)*cellStepSize;\n    vec2 nextPosition = getCameraIterationPosition(iteration)*cellStepSize;\n\n\n    float iterationTime = mod(t, iterationDuration) / iterationDuration;\n\n    float iterationSteps = 2.;\n    float stepDuration = iterationDuration / iterationSteps;\n    float iterationStep = floor(iterationTime / stepDuration) + 1.;\n\n    float iterationStepTime = mod(iterationTime, stepDuration) / stepDuration;\n\n    vec2 f = (nextPosition - prevPosition) * vec2(iterationStepTime);\n\n    if (iterationStep == 1.) {\n        f.y = 0.;\n    } else if (iterationStep == 2.) {\n        prevPosition.x = nextPosition.x;\n        f.x = 0.;\n    }\n\n\n    center = prevPosition + f;\n\n    return vec3(center, iteration*2. - iterationStep);\n}\n\nvoid scriptCamera() {\n    float t = iTime / 18.;\n\n    vec3 nextPosition = cameraNextPosition();\n\n    camera.x = nextPosition.x;\n    camera.y = nextPosition.y;\n\n    camera.z = .5 - cos(iTime/2.) * .5;\n\n    float verticalA = 1.0;\n    float horizA = 0.;\n    horizA = sin(t*8.);\n\n    verticalA = 1. - (sin(t*8.)*.02 + .01);\n\n    camera.rotation = sin(iTime) * PI/64.;\n\n    float n = n21(vec2(nextPosition.z + 13.));\n\n    float topDown = step(.2, n);\n\n    horizA  *= topDown;\n    verticalA *= topDown;\n    camera.z -= (topDown - 1.) * n/2.;\n\n    if (length(mouse.xy - .5) > .1) {\n        horizA = PI * mouse.x;\n        verticalA = PI/3. * mouse.y;\n    }\n\n    camera.horizontalAngle = horizA;\n    camera.verticalAngle = verticalA;\n}\n\nvoid setupCamera() {\n    camera.x = 0.;\n    camera.y = 0.;\n    camera.z = 0.;\n    camera.rotation = 0.;\n    scriptCamera();\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoords) {\n\n    HALF_CELL_SIZE = CELL_SIZE / 2.;\n\n    mouse = iMouse.xy/iResolution.xy;\n    if (mouse.x == 0. || mouse.y == 0.) {\n        mouse += .5;\n    }\n    isScripted = true; //!isKeyDown(Key_Shift);\n\n    setupCamera();\n\n    vec2 uv = ((fragCoords.xy / iResolution.xy) - .5) * vec2(iResolution.x / iResolution.y, 1.);\n\n    vec3 col = vec3(.0);\n\n    float a = 0.;\n\n    vec3 ro = vec3(0., 1. , 0.1);\n    vec3 lookat = vec3(0., 1.*camera.verticalAngle, 0.);\n\n    if (!isScripted) {\n        ro = vec3(0., 0. , -4.);\n        lookat = vec3(0., 0., 0.);\n    }\n\n    float zoom = .9;\n    vec3 up = vec3(0., 1., 0.);\n    up.xy *= rot2d(PI / 2. + camera.rotation);\n\n    vec3 f = normalize(lookat - ro);\n    vec3 r = normalize(cross(up, f));\n    vec3 u = cross(f, r);\n\n    vec3 c = ro + f * zoom;\n    vec3 I = c + uv.x * r + uv.y * u;\n\n    vec3 rd = normalize(I - ro);\n\n    TraceResult tr = trace(ro, rd);\n    float fogMultiplier = 0.;\n\n    if (tr.dt < MIN_DISTANCE) {\n        float objId = tr.obj;\n\n        vec3 normal;\n\n        if (objId == OBJ_FLOOR) {\n            vec4 fc = floorTexture(tr.p, tr.q1);\n            col += fc.rgb;\n            normal = vec3(0., -1., 0.);\n            fogMultiplier = fc.w;\n        } else if (objId == OBJ_CAMERA) {\n            col += mix(vec3(0., 0., 1.), vec3(1., 0., 0.), (.7 + tr.dist.p.y*10.));\n        } else if (objId == OBJ_DOME) {\n            col += domeTexture(tr.p);\n        } else if (objId == OBJ_CAR) {\n            normal = getNormal(tr.p, tr.dt);\n            col += carTexture(tr, normal);\n            fogMultiplier = 2.;\n        } else {\n            normal = getNormal(tr.p, tr.dt);\n            vec4 bt = getBuildingTexture(tr, normal);\n            col += bt.rgb;\n            fogMultiplier = bt.w;\n        }\n\n    }\n\n    float d = length(tr.p - vec3(camera.x, camera.y, camera.z))/(1. + camera.z/8.);\n    float fog = (2.2) - d/1.8;\n\n    fragColor = vec4(min(vec3(1.), col), 1.);\n    if (tr.obj != OBJ_DOME) {\n        if (fogMultiplier != 0.) {\n             fragColor *= fog > -fogMultiplier ?  (1. - (fog < 0. ? abs(fog)/fogMultiplier : 0.)) : fog;\n        } else {\n            fragColor *= fog;\n        }\n\n    }\n}","name":"Image","description":"","type":"image"}]}