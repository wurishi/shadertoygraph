{"ver":"0.1","info":{"id":"ttV3Rc","date":"1579539063","viewed":390,"name":"Floating diamond","username":"lnae","description":"Shiny things.","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["reflection","refraction","cubemap","bloom","dispersion","gem"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    //vertical blur pass\n    vec3 bloom = texture(iChannel1, uv).rgb;\n    float ratio = iResolution.x / iResolution.y;\n    float offset = 0.0015 * ratio;\n    float weight = 1.;\n    for(float i = 1.; i < 10.; i++){\n        bloom += texture(iChannel1, uv + vec2(0., i * offset)).rgb * weight;\n        bloom += texture(iChannel1, uv - vec2(0., i * offset)).rgb * weight;\n        weight = smoothstep(10., 0., i);\n    }\n    \n    col += 0.0015 * bloom;\n    col = 1. - exp(-col * 2.); //simple tone mapping\n    fragColor = vec4(pow(col, vec3(1. / 2.2)),1.0); //gamma corrected color\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"#define PI 3.14159\n\nfloat hash(vec2 p){\n\treturn fract(123456.789 * sin(dot(p, vec2(12.34, 56.78))));\n}\n\n\nmat2 rot(float a){\n\tfloat c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir ){\n    \n    //cache\n    if(iFrame > 1) discard;\n    \n    float angle = asin(rayDir.y) / (2. * PI);\n    vec3 col = vec3(0.12 * -angle, 0.12 * (angle + 0.05), 0.07) + 0.8 * smoothstep(0., 0.3, -angle + 0.015) * vec3(1., 0.3, 0.);\n    \n    //horizon\n    float angle2 = atan(rayDir.z, rayDir.x);\n    angle *= 10.;\n    col *= smoothstep(-0.06, -0.05, angle + 0.3);\n    \n    //stars\n    vec2 uv = (fragCoord / iResolution.xy) * 150.;\n    vec2 cell = floor(uv);\n    float th = 0.9;\n    uv = fract(uv) * 2. - 1.;\n    float val = hash(cell);\n    float strength = 0.5 * (max(th, val) - th) * 1. / (1. - th);\n    strength *= strength;\n    float star = smoothstep(strength, 0., length(uv) - strength);\n    star += 0.2 * smoothstep(5. * strength, 0., length(uv) - strength);\n    star *= star * hash(cell + 1000.);\n    col += star * 3. * max(0., angle + 0.3);\n    \n    //moon\n    vec3 dir = rayDir;\n    dir.zy = rot(-PI / 8.) * dir.zy;\n    dir.xy = rot(-PI / 6.) * dir.xy;\n    angle = asin(dir.y) / PI;\n    float moon = max(0., angle - 0.29);\n    col += smoothstep(0., 1., moon) * vec3(1., 1., 0.75);\n    col += 2. * smoothstep(0.175, 0.178, moon) * vec3(1., 1., 0.75);\n    \n    col = max(vec3(0.), col);\n    fragColor = vec4(col,1.0);\n}","name":"Cube A","description":"","type":"cubemap"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159\n#define CHEAP_DISPERSION\n\nconst float EPS = 0.00001;\nconst float EPSN = 0.001;\nconst int STEPS = 50;\n\nconst float IOR = 2.41;\nconst int NREF = 5;\nconst int REFSTEPS = 30;\n\nconst float DISPERSION = 0.01;\n\nmat2 rot(float a){\n\tfloat c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat scene(vec3 pos){\n    \n    pos.y += 0.075 * sin(iTime);\n    pos.yz = rot(1. + 0.5 * sin( 0.5 * iTime - 0.5 * PI)) * pos.yz;\n    pos.xz = rot(sin(0.5 * iTime) + 0.6 * iTime) * pos.xz;\n    \n    //repeat 3 times and mirror in each part \n    vec3 p = pos;\n    float t = 2. * PI / 3.;\n    float angle = floor((atan(p.z, p.x) + 0.5 * t) / t) * t;\n    p.xz = rot(angle) * p.xz;\n    p.z = abs(p.z);\n    \n    //I would usually do this, but here this method gives precision problems, very noticeable with the reflections\n    /*float angle = mod(atan(p.z, p.x) + 0.5 * t, t) - 0.5 * t;\n    angle = abs(angle);\n    float r = length(p.xz);\n    p.x = r * cos(angle);\n    p.z = r * sin(angle);*/\n    \n    // I used this faceting diagram for the trilliant cut : http://www.facetdiagrams.org/database/files/pc13067d.html\n    vec3 pGem = p;\n    pGem.xz = rot(0.6544) * pGem.xz;\n    float distGem = -(rot(0.8150) * (pGem.xy + vec2(0., 0.5))).y; //pavilion\n    distGem = max(distGem, pGem.x - 0.475); //girdle\n    distGem = max(distGem, (rot(-0.7155) * (pGem.xy + vec2(0., -0.43))).y ); //crown\n\n    pGem = p;\n    pGem.xz = rot(0.9162) * pGem.xz;\n    distGem = max(distGem, -(rot(0.8552) * (pGem.xy + vec2(0., 0.5))).y ); //pavilion\n    distGem = max(distGem, pGem.x - 0.4385); //girdle\n    distGem = max(distGem, (rot(-0.7155) * (pGem.xy + vec2(0., -0.398))).y ); //crown\n\n    pGem = p;\n    pGem.xz = rot(PI / 4.) * pGem.xz;\n    distGem = max(distGem, -(rot(0.8203) * (pGem.xy + vec2(0., 0.4895))).y ); //pavilion\n    distGem = max(distGem, (rot(-0.5969) * (pGem.xy + vec2(0., -0.33))).y ); //crown\n\t\n    pGem = p;\n    pGem.xz = rot(PI / 6.) * pGem.xz;\n    distGem = max(distGem, (rot(-0.3351) * (pGem.xy + vec2(0., -0.2445))).y ); //crown\n    \n    pGem = p;\n    pGem.xz = rot(PI / 3.) * pGem.xz;\n    distGem = max(distGem, (rot(-0.3351) * (pGem.xy + vec2(0., -0.228))).y ); //crown\n    \n    distGem = max(distGem, pGem.y - 0.1445); //table\n    \n\treturn distGem;\n}\n\n\nvec3 normal(vec3 pos){\n\tvec2 eps = vec2(EPSN, 0.);\n    return normalize(vec3(scene(pos + eps.xyy) - scene(pos - eps.xyy), \n                          scene(pos + eps.yxy) - scene(pos - eps.yxy), \n                          scene(pos + eps.yyx) - scene(pos - eps.yyx)));\n}\n\n\nfloat fresnel(vec3 ray, vec3 refr, vec3 n, float ior1, float ior2){\n\tfloat f0 = (ior1 - ior2) / (ior1 + ior2);\n    f0 *= f0;\n    float cosAngle = dot(n, -ray);\n    //Schlick's approximation doesn't work directly when the first index of refraction is bigger\n    if(ior1 > ior2){\n    \tcosAngle = dot(-n, refr);\n    }\n    float t = 1. - cosAngle;\n    t = t * t * t * t * t; //better than pow(t,5) ?\n    return f0 + (1. - f0) * t;\n}\n\n\nvec3 render(vec2 uv){\n\tvec3 color = vec3(0.);    \n    \n    //camera\n    vec3 eye = vec3(0., 0., 1.75);\n    vec2 mouse = iMouse.xy / iResolution.xy - 0.5;\n    \n    vec3 up = vec3(0., 1., 0.);\n    float rotY = 0.;\n    float rotX = 0.15;\n    if(iMouse.z > 0.){\n    \trotY = mouse.x * PI;\n    \trotX = mouse.y * PI;\n    }\n    \n    eye.yz = rot(rotX) * eye.yz;\n    up.yz = rot(rotX) * up.yz;\n    eye.xz = rot(rotY) * eye.xz;\n    up.xz = rot(rotY) * up.xz;\n    \n    vec3 target = vec3(0.);\n    float fovY = 0.25 * PI;\n    float zoom = 0.5 / tan(0.5 * fovY);\n    \n    vec3 dir = normalize(eye - target);\n    vec3 right = normalize(cross(up, dir));\n    \n    //ray march\n    vec3 ray = normalize(-dir * zoom + uv.x * right + uv.y * up);\n    vec3 pos = eye;\n    float dist;\n    float t = 0.;\n    bool hit = false;\n    \n    for(int s = 0; s < STEPS; s++){\n        dist = scene(pos);\n        if(dist < EPS){\n            hit = true;\n        \tbreak;\n        }\n        if(t > 10.){\n        \tbreak;\n        }\n    \tpos += ray * dist;\n        t += dist;\n    }\n    \n    if(hit){\n        vec3 n = normal(pos);\n        vec3 reflected = reflect(ray, n);\n        vec3 refracted = refract(ray, n, 1. / IOR);\n        float fre = fresnel(ray, refracted, n, 1., IOR);        \n        color = texture(iChannel0, reflected).xyz * fre;\n        \n        float factor = 1. - fre;\n        ray = refracted;\n        for(int r = 0; r < NREF; r++){\n            pos += 10. * EPS * ray;\n            for(int s = 0; s < REFSTEPS; s++){\n                pos += ray * -scene(pos);\n            }\n            vec3 n2 = -normal(pos);\n            refracted = refract(ray, n2, IOR);\n            fre = fresnel(ray, refracted, n2, IOR, 1.);\n            \n            #ifdef CHEAP_DISPERSION\n            //only when the ray leaves the stone, gives a nice effect without marching 3 times \n            vec3 refractedR = refract(ray, n2, IOR - DISPERSION);\n            vec3 refractedG = refract(ray, n2, IOR);\n            vec3 refractedB = refract(ray, n2, IOR + DISPERSION);\n            color.r += texture(iChannel0, refractedR).r * factor * (1. - fre);\n            color.g += texture(iChannel0, refractedG).g * factor * (1. - fre);\n            color.b += texture(iChannel0, refractedB).b * factor * (1. - fre);\n            #else\n            color += texture(iChannel0, refracted).rgb * factor * (1. - fre);\n            #endif\n            \n            ray = reflect(ray, n2);\n            factor = factor * fre;\n        }\n        color += texture(iChannel0, ray).xyz * factor;\n    }else{\n    \tcolor = texture(iChannel0, ray).xyz;\n    }\n\treturn color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col = render(uv);\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    //bloom, horizontal blur pass\n    float th = 0.1;\n    vec3 col = max(vec3(0.), texture(iChannel0, uv).rgb - th);\n    float offset = 0.0015;\n    float weight = 1.;\n    for(float i = 1.; i < 10.; i++){\n        col += max(vec3(0.), texture(iChannel0, uv + vec2(i * offset, 0.)).rgb - th) * weight;\n        col += max(vec3(0.), texture(iChannel0, uv - vec2(i * offset, 0.)).rgb - th) * weight;\n        weight = smoothstep(10., 0., i);\n    } \n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}