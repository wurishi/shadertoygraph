{"ver":"0.1","info":{"id":"Dd3SDS","date":"1680299235","viewed":182,"name":"This is truly cursed","username":"ianertson","description":"Use the mouse to look around :)\nHe is missing legs and feet, but I actually coded those as well, decided to throw them out in an attempt to reduce compile time.","likes":12,"published":1,"flags":48,"usePreview":1,"tags":["3d","raytracing","raymarching","raymarch","sdf","weird","creepy","human","cursed"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ID_GROUND 1\n#define ID_FACE 2\n#define ID_FACE_EYE 3\n#define ID_FACE_HAND 4\n#define ID_ROOM 5\n\nfloat groundSDF(in vec3 p) {\n    return p.y;\n}\n\nfloat fingerSDF(in vec3 p, in vec3 dir, in float len, in float r) {\n    r *= 0.9;\n    float lenA = len*0.44;\n    float lenB = len-lenA;\n    float d = lineSDF(p, vec3(0.0), dir*lenA, r);\n    float d2 = lineSDF(p - (dir*lenA), vec3(0.0), dir*lenB, r*0.8);\n    return min(d, d2);\n}\n\nfloat handSDF(in vec3 p) {\n    vec3 dir = vec3(0, 0, 1);\n    float r = 0.15;\n    float len = 0.05;\n    \n \n    float palm = cylSDF((p * vec3(1.0/1.2, 1, 1)) - vec3(0, -r*1.5, 0), -dir*len*0.5, dir*len*0.5, r*0.8);\n    float dist = palm;\n    \n    float fingerLenScale = 1.1;\n    float fingers = FAR;\n    \n    float thumbLen = r*0.7;\n    float thumbR = 0.036;\n    fingers = min(fingers, fingerSDF(p - vec3(thumbLen*0.02, -r*0.62, 0), normalize(vec3(1., 0.5, 0)), thumbLen, thumbR));\n    \n    p.y += 0.04;\n    float indexLen = r*1.2*fingerLenScale;\n    float indexR = 0.029;\n    fingers = min(fingers, fingerSDF(p - vec3(r*0.5, -r*0.6, 0), vec3(1., 0, 0), indexLen, indexR));\n    \n    float middleLen = (indexLen+0.046)*fingerLenScale;\n    float middleR = 0.029;\n    fingers = min(fingers, fingerSDF(p - vec3(r*0.5, -((r*0.6)+(indexR*2.)), 0), vec3(1., 0, 0), middleLen, middleR));\n    \n    \n    float ringLen = (indexLen+0.02)*fingerLenScale;\n    float ringR = 0.029;\n    fingers = min(fingers, fingerSDF(p - vec3(r*0.5, -((r*0.6)+2.0*(indexR+middleR)), 0), vec3(1., 0, 0), ringLen, ringR));\n    \n    float pinkLen = (indexLen-0.01)*fingerLenScale;\n    float pinkR = 0.028;\n    fingers = min(fingers, fingerSDF(p - vec3(r*0.5, -((r*0.6)+2.0*(indexR+middleR+ringR)), 0), vec3(1., 0, 0), pinkLen, pinkR));\n    \n    dist = smin(dist, fingers, 0.03);\n    return dist;\n}\nfloat atan2(in float y, in float x)\n{\n    return x == 0.0 ? sign(y)*M_PI/2. : atan(y, x);\n}\n\nfloat faceSDF(\n    in vec3 p,\n    inout int id,\n    inout Object o,\n    in int skip,   \n    inout float upperLip,\n    inout float head,\n    inout float eye,\n    inout float hand,\n    inout float lleg\n) {\n    float dist = FAR;\n    id = ID_FACE;\n    vec3 op = p;\n    p.x = sabs(p.x, 0.02);\n    \n    float r = 0.45;\n    float rr = r;\n    head = FAR;\n\n    float ssig = smoothSign(op.x, 0.04);\n    float mouthClosed = 0.5+sin(T+cos(((T+sin((T+92.5281)*3.))-2.393982)*2.))*0.5;\n    float browLift = 0.5+cos(((T-2.*ssig)-8.2881243)+sin(((T+2.*ssig)+2.393982)*2.))*0.5;\n\n    p.z -= 0.09*srange(p.y, r/2., r*2., 0.4);\n    r /= (1.0 + smoothstep(0.0, 1.2, r-p.y));\n    r += 0.29*srange(p.y, -r, -0.31, 0.2)*srange(abs(p.x), r*2., -0.9, 1.)*smoothstep(0.0, r*2., -p.z);\n\n    vec3 headScale = vec3(1.0);\n    \n    headScale.y *= (1.0 + 0.5*(smoothstep(0.0, 0.6, p.z+(r/2.))*smoothstep(0.4, 0.8, p.y)));\n\n    head = distance(p*headScale, vec3(p.x/-16., p.y/8., (0.25*sin(p.z*p.y*0.8)*max(0.0, p.z+0.5)))) - r;\n    float oHead = head;\n    float box = boxSDF(p - vec3(0, 0., 0), vec3(r))-(0.04);\n    head = mix(head, box, \n        0.83*(srange(abs(p.x), 0.0, 0.02, 0.21) *\n        srange(p.y, -0.2, r/3., 0.2) * \n        srange(p.z, -1., 0., 0.25))) + 0.5*smoothstep(0.1, 2.0, abs(p.z));\n\n    head = mix(head, oHead, smoothstep(0.1, 0.29, p.y+(r/3.))*(0.8*smoothstep(0.0001, r, p.z+(r*1.3))*srange(length(p), r*0.2, r+r*1.5, 0.5)));\n    head += smoothstep(0.0, 0.7, p.z-r/3.)*smoothstep(0.01, 0.8, p.y);\n    p = op;\n    p.x = sabs(p.x, 0.02);\n    \n    vec3 noseDir = normalize(vec3(0, -1, -0.6));\n    float noseLen = r*0.25;\n    float noseR = r*0.05;\n    \n    float nose = lineSDF(p - vec3(0, noseLen/1.2, (-r)+noseR*2.5), vec3(0, 0, 0), noseDir*noseLen, noseR);\n    nose -= sclamp(-p.z+(r*2.), 0.0, 1.0, 0.5)*srange(p.z, -0.2, 0., 0.2)*smoothstep(0.0, 1.0, dot(p-vec3(0, noseLen/1.2, (-r)+noseR*2.5), noseDir));\n    \n    float browLen = r/2.;\n    float browR = r*0.05;\n    vec3 browDir = vec3(1, 0, 0);\n    browDir = mix(browDir, browDir + vec3(0, 0, 0.9), smoothstep(0.0, browLen*2., sabs(p.x, 0.2)));\n    browDir = mix(browDir, browDir + vec3(0, 0.5, 0.), 1.0-smoothstep(0.0, 0.3, abs(p.x)/(1.0+abs(p.x))));\n    \n    browDir = normalize(browDir);\n    float brow = lineSDF(vec3(sabs(p.x, 0.04), p.y - mix(0.0, mix(-0.02, 0.02, 0.5+cos(T)*0.5), browLift), p.z) - vec3(noseR+0.02, noseLen+browR*2., (-r)+noseR*3.), vec3(0, 0, 0), browDir*browLen, browR);\n    \n    nose = smin(nose, brow, 0.07);\n    head = smin(head, nose, 0.09);\n    \n    r = rr;\n    \n    float mouthR = r*0.11;\n    vec3 mouthPos = vec3(0, -mouthR+-noseLen+-0.01, (-r*0.289));\n    float mouth = distance(p - mouthPos, vec3(p.x/1.7, 0., p.z/2.)) - mouthR;\n    mouth /= 1.2;\n    head = smax(head, -mouth, 0.03)/(1.0+clamp(mouth, 0.0, 0.4));\n    \n    \n    float lipR = mouthR*2.;\n    vec3 lipPos = (mouthPos + vec3(0, (mouthR-lipR*0.11), -lipR*1.07));\n    lipPos.y = abs(lipPos.y)+0.04;\n    float lipPY = abs(p.y+lipPos.y)-lipR*0.25;\n    upperLip = torusSDF(vec3(p.x, lipPY, p.z) - vec3(lipPos.x, mix(0.0, -0.01, mouthClosed), lipPos.z), lipR, 0.01);\n    head = smin(head, upperLip, 0.02 + (0.05*srange(p.y, lipPos.y-0.22, -0.09, 0.03+mix(0.0, 0.04, mouthClosed))));\n    \n    float eyeHoleR = r*0.15;\n    float eyeX = (r*0.5)-(eyeHoleR*1.5);\n    vec3 eyePos = vec3(eyeX, eyeHoleR*0.61, -r*0.56);\n    float eyeHole = sphereSDF((mirrorX(p) - eyePos)*vec3(1.0/1.5, 1.0, 1.0), eyeHoleR);\n    eyeHole += 0.02*srange(abs(p.x)-eyeX, 0.09, 0.8, 0.06)*srange(p.y, -0.3, 0.0, 0.06);\n    eyeHole += 0.04*srange(abs(p.x), 0.0, 0.011, 0.06)*srange(p.y, 0.0, 0.07, 0.06);\n    head = smax(head, -eyeHole, 0.06);\n    \n    float eyeR = eyeHoleR*0.6;\n    vec3 finalEyePos = (eyePos + vec3(eyeR*0.11, eyeR*0.2, eyeR*0.26));\n    float g = (((T-sin(T+5.553242))*2.)+cos(((T+54.209291)*1.5)-4.29912));\n    \n    float eyeRotY = sin(g-sign(op.x))*0.99;\n    float eyeSig = sign(eyeRotY);\n    eyeRotY = abs(eyeRotY);\n    eyeRotY = pow(eyeRotY, 3.)*eyeSig*2.*-sign(op.x);\n    eyeRotY = mix(0.0, eyeRotY, 0.5+sin((T*0.21)-1.11111)*0.5);\n    Object oEye = Object(o.p+pointRotInv(finalEyePos, o.q\n    *sign(op.x)), o.q+vec3(cos((T+sin((T-4.9292)*0.5))*2.5)*0.25*-sign(op.x), eyeRotY, 0));\n    eye = sphereSDF(pointRot(mirrorX(p) - finalEyePos, oEye.q), eyeR);\n    \n    float lidR = eyeHoleR*0.9;\n    float lidLen = eyeR*2.5;\n    vec3 lidDir = vec3(0, 1, 0);\n    float eyeLid = cylSDF(vec3(abs(p.x), p.y, p.z) - (eyePos + (lidDir*lidLen*0.45)), vec3(0, 0, 0), lidDir*lidLen, lidR);\n    head = smin(head, eyeLid, 0.042);\n    \n    float bagR = eyeR*1.5;\n    float eyeBag = torusSDF(mirrorX(p) - vec3(eyePos.x, 0.0, eyePos.z+(bagR*0.33)), bagR, 0.015);\n    head = smin(head, eyeBag, 0.042 + (0.062*srange(-p.y+0.003+mix(0.0, 0.04*ssig, 0.33*max(0.0, 1.0-browLift))+mix(0.0, 0.02, 0.25*max(0.0, 1.0-mouthClosed)), 0.0, 0.14, 0.026)));\n    \n    vec3 earDir = vec3(0.8, 0, -0.5);\n    earDir = normalize(earDir);\n    vec3 earRot = vec3(0, sin(p.z*6.), sin(-p.y*2.));\n    \n    float earLen = 0.02;\n    float earR = r*0.2;\n    vec3 earPos = (vec3(r*0.77, earR*0.9, 0));\n    vec3 earP = mirrorX(p) - earPos;\n    \n    float ear = cylSDF(pointRotMx(earP, earRot, 0.5), vec3(0, 0, 0), earDir*earLen, earR);\n    vec3 pp = p + ear;\n    float earHole = distance(pointRotMx(mirrorX(p) - (earPos-0.02*earDir), earRot, 0.5), vec3(0., (-p.y*0.4*sin((p.z)*6.))+((-p.y/2.)*(-p.z+0.1)*2.), 0.)) - earR*0.77;\n    earHole -= srange((-p.z)+0.08, 0.0, 0.01, 0.09)*0.05*smoothstep(0.0, 0.2, dot(mirrorX(p) - (earPos-0.02*earDir), normalize(vec3(-0.2, -0.5, -0.3))));\n    earHole = max(earHole, 0.025*-dot(earP, normalize(vec3(-1, 0.5, 0.2))));\n    ear = smax(ear, -earHole, 0.02);\n    \n    float earFreq = clamp(1.0/max(0.035, distance(vec3(abs(p.x)+0.25*-sin(((p.y/2.)-p.z*2.)*abs(p.x)*2.), p.y, p.z-0.5*sin(p.y*p.x)), earPos)), 0.0, 96.0);\n    ear += (exp(sin(0.5*earFreq)-1.)*0.15*sclamp(abs(p.x)-earPos.x, 0.0, 0.5, 0.15))-0.003;\n    float earHole2 = distance(earP, vec3((-earR*0.33)-(earP.x/2.), -earR*0.45, -earR*0.32))-(earR*0.48);\n    ear = smax(ear, -earHole2, 0.026);\n    head = mix(head, smax(head, -earHole2, 0.06), 0.25);\n    head = smin(head, ear, 0.044);\n    \n    dist = min(dist, head);\n    \n    float neckLen = r*0.65;\n    float neckR = r*0.41;\n    float neck = cylSDF(p - vec3(0, -(neckLen+(r/2.)), 0), vec3(0, 0, 0), vec3(0, neckLen, 0), neckR);\n    \n    \n    \n    float shoulderLen = r*2.2;\n    vec3 shoulderDir = vec3(1, 0, 0);\n    float shoulderR = r*0.45;\n    float shoulder = lineSDF(p -  vec3(0, (-((neckLen*1.5)+shoulderR)), 0), -shoulderDir*shoulderLen*0.5, shoulderDir*shoulderLen*0.5, shoulderR);\n    \n    shoulder -= 0.4*slt(p.x, 0.35, 0.15)*srange(p.y, -0.6, -0.3, 0.5)*smoothstep(0.0, 1.0, dot(p-vec3(0, (-((neckLen*1.2)+shoulderR)), -shoulderR*0.9), normalize(vec3(0.5, 0.5, 0.))));\n    \n    neck = smin(neck, shoulder, 0.1);\n    dist = smin(dist, neck, 0.03);\n    \n    float steptoR = r*0.05;\n    vec3 steptoDir = vec3(1, 1.7, 0);\n    float steptoLen = neckLen;\n    float steptoBend = smoothstep(0.0, 0.45, p.y-(-((neckLen*1.2)+shoulderR)));\n    steptoDir.z += steptoBend*2.;\n    steptoLen += 0.07*steptoBend;\n    steptoR += 0.015*srange((p.y)-((-((neckLen*1.2)+shoulderR))), 0.09, 0.2, 0.06);//smoothstep(0.0, 0.4, abs(p.y-(-((neckLen*1.2)+shoulderR)))+(neckLen/2.));\n    steptoDir = normalize(steptoDir);\n    \n    \n    float stepto = lineSDF(vec3(abs(p.x)-0.02, p.y, p.z) - vec3(0, (-((neckLen*1.2)+shoulderR)), -shoulderR*0.9), vec3(0, 0, 0), steptoDir*steptoLen, steptoR);\n    dist = smin(dist, stepto, 0.04+(0.1*steptoBend));\n    \n    float armLenScale = 0.8;\n    \n    float uarmLen = shoulderLen*0.8*armLenScale;\n    float uarmR = shoulderR*0.8;\n    \n    float uarmY = ((-((neckLen*1.2)+shoulderR)))-(uarmR*0.45);\n    vec3 uarmDir = vec3(1., mix(0.0, -1., 0.5+sin((T+sign(op.x)*cos((T*2.)+18.292831))+2.*sign(op.x))*0.5), 0.);\n    uarmDir = normalize(uarmDir);\n    vec3 uarmPos = vec3((shoulderLen*0.5)+(uarmR*0.25), uarmY, 0);\n    float uarm = lineSDF(p - uarmPos, vec3(0, 0, 0), uarmDir*uarmLen, uarmR);\n    dist = smin(dist, uarm, 0.1);\n    \n    float larmLen = uarmLen*1.02;\n    float larmR = uarmR*0.7;\n    \n    float larmY = ((-((neckLen*1.2)+shoulderR)))-(larmR*0.45);\n    vec3 larmDir = uarmDir;\n   // larmDir = normalize(larmDir);\n    float larm = lineSDF(p - ((uarmPos + uarmDir*uarmLen)), vec3(0, 0, 0), larmDir*larmLen, larmR);\n    dist = smin(dist, larm, 0.05);\n    vec3 handRot = vec3(0, 0, atan2(larmDir.y, larmDir.x));\n    vec3 handP = p;\n    \n    vec3 handOff1 = (vec3(1, 0, 0)*1.5*(larmLen+uarmLen));\n    vec3 handOff2 = vec3(0.06, -((neckLen*0.5)+larmR*2.), 0);\n    vec3 handPos = vec3(0.0);\n    handPos += pointRot(handOff1, -handRot);\n    handPos += pointRot(handOff2, handRot);\n\n    Object oHand = Object(o.p + pointRotInv(handPos, o.q), o.q + handRot);\n    hand = handSDF(pointRot(handP - handPos, handRot));\n    hand /= 1.3;\n    //dist = smin(dist, hand, 0.07);\n    \n    float torsoLen = r*1.2;\n    float torsoR = r;\n    vec3 torsoDir = vec3(0, 1, 0);\n    vec3 torsoPos = vec3(0, (-(r+torsoLen+shoulderR)), 0);\n    float torso = lineSDF(p - torsoPos, -torsoDir*torsoLen*0.5, torsoDir*torsoLen*0.5, torsoR);\n    \n    torso += smoothstep(0.0, 0.6, dot(p-(torsoPos-vec3(0, -0.3, 0)), vec3(0, -1., 0)))*smoothstep(0.0, 1.5, length((p-torsoPos).xz));\n    torso += 0.25*smoothstep(0.0, 1.0, abs(p.z))*smoothstep(0.0, 0.4, p.y+1.5);\n    \n    p = op;\n    p.x = sabs(p.x, 0.06);\n    float chestLen = 0.15;\n    float chestR = 0.2;\n    float chest = cylSDF(p - (torsoPos + vec3(chestR*0.9, chestR*2.1, -chestLen*1.6)), vec3(0), vec3(0, 0, chestLen), chestR);\n    float chestSp = sphereSDF(p - (torsoPos + vec3(chestR*0.9, chestR*2.1, -chestLen*1.6)), chestR*0.89);\n    chest = mix(chest, chestSp, 0.7*(1.0-smoothstep(0.0, 0.3, p.y-(torsoPos.y+chestR*2.1))));\n    dist = smin(dist, chest, 0.15);\n    \n    dist = smin(dist, torso, 0.1);\n    \n \n    SAMPLE(eye, oEye, ID_FACE_EYE);\n\n    SAMPLE(hand, oHand, ID_FACE_HAND);\n    \n    dist = smin(dist, hand, 0.04);\n\n    return dist;\n}\n\nfloat faceSDF(\n    in vec3 p,\n    inout int id,\n    inout Object o,\n    in int skip\n){\n    float upperLip = 0.0;\n    float head = 0.0;\n    float eye = 0.0;\n    float hand = 0.0;\n    float lleg = 0.0;\n    return faceSDF(p, id, o, skip, upperLip, head, eye, hand, lleg);\n}\n\nfloat sdf(inout Data data, in vec3 p) {\n    int skip = data.skip;\n    int id = ID_NONE;\n    float dist = FAR;\n    Object o = NEW_OBJECT;\n    \n    float ground = groundSDF(p);\n    SAMPLE(ground, o, ID_GROUND);\n    \n    vec3 roomSize = vec3(8, 7, 8);\n    float room = boxSDF(p - vec3(0.0, roomSize.y, 0.0), roomSize);\n    float inside = boxSDF(p - vec3(0, 0, 0), roomSize*0.8);\n    room = max(room, -inside);\n    SAMPLE(room, o, ID_ROOM);\n\n    int faceId = 0;\n    vec3 faceRot = vec3(0, 0, 0);\n    faceRot.y = mix(0.0, sin(T), 0.25*sgt(p.y, 2.5, 0.29));\n    faceRot.y = mix(faceRot.y, sin(T-4.48931), 0.45*slt(p.y, 1.0, 0.29)*slt(abs(p.x), 0.5, 0.06));\n    faceRot.z = mix(0.0, cos(T), 0.25*sgt(p.y, 2.5, 0.29)*slt(abs(p.x), 0.6, 0.15));\n    Object oFace = Object(vec3(0, 2.9, 0), faceRot);\n    float face = faceSDF(pointRot(p - oFace.p, oFace.q), faceId, oFace, skip);\n    SAMPLE(face, oFace, faceId);\n    \n    data.id = id;\n    data.o = o;\n    return dist;\n}\n\nfloat checkerTexture(in vec2 uv, in float s) {\n    vec2 d = max(abs(dFdx(uv)), abs(dFdy(uv))) + s;\n    vec2 t1 = vec2(1.-2.0*abs(fract((uv.x+.5*d.x)*0.5)-0.5), 1.-2.0*abs(fract((uv.y+.5*d.y)*.5)-0.5));\n    vec2 t2 = vec2(1.-2.0*abs(fract((uv.x-.5*d.x)*0.5)-0.5), 1.-2.0*abs(fract((uv.y-.5*d.y)*.5)-0.5));\n    return 0.5 - 0.5*((t1.x-t2.x)/d.x)*(t1.y-t2.y)/d.y;\n}\n\n//#define DEBUG_TEXTURE eyeTexture\n//#define DEBUG_CENTER_UV 1\nvec3 eyeTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(1.0);\n    \n    float scale = 1.0;\n    #ifdef DEBUG_TEXTURE\n    scale *= 0.1;\n    #endif\n    uv *= scale;\n    \n    vec3 c1 = rgb(83, 91, 88);\n    vec3 c2 = rgb(185, 181, 167);\n    vec3 c3 = rgb(23, 48, 62);\n    vec3 c4 = rgb(98, 116, 126);\n    \n    \n    vec3 v1 = rgb(197, 74, 80);\n    vec3 v2 = rgb(190, 126, 113);\n    vec3 v3 = rgb(119, 52, 53);\n    vec3 v4 = rgb(93, 28, 31);\n    \n    \n    vec3 hf1 = snoise(uv, 0.0023123, 0.0, 48.0/0.1, 6);\n    vec3 hf2 = snoise(uv, 5.5938115, 0.0, 32.0/0.1, 6);\n    vec3 lf1 = snoise(uv, 2.3333333, 0.0, 8.0/0.1, 6);\n    vec3 warp = snoiseWarp(uv, 9.9928315, 0.0, 16.0/scale, 2, 0.02);\n    \n    float veins = 1.0-smoothstep(0.02, 0.09, abs(warp.x*2.0-1.0));\n    \n    veins *= smoothstep(0.4, 0.7, lf1.y)*smoothstep(0.2, 0.8, lf1.z);\n    \n    vec3 veinCol1 = mix4(v1, v2, v3, v4, hf2);\n    vec3 veinCol2 = mix4(v4, v3, v2, v1, smoothstep(0.4, 0.7, hf2));\n    vec3 veinCol = mix(veinCol1, veinCol2, smoothstep(0.4, 0.7, lf1.x));\n    vec3 irisCol1 = mix4(c1, c2, c3, c4, smoothstep(0.4, 0.7, hf1));\n    vec3 irisCol2 = mix4(c4, c3, c2, c1, hf1);\n    vec3 irisCol = mix(irisCol1, irisCol2, smoothstep(0.4, 0.7, hf1.x));\n    \n    \n    float ra = 0.023;\n    float fe = ra*0.2;\n    float iris = 1.0-smoothstep(ra-fe, ra+fe, length(uv));\n    float pupil = 1.0-smoothstep((ra-fe)*0.46, (ra+fe)*0.46, length(uv));\n    \n    veins *= max(0.0, 1.0-(iris+pupil));\n    \n    \n    col = mix(col, irisCol, iris);\n    col = mix(col, vec3(0.0), pupil); \n    col = mix(col, veinCol, veins);\n    col = mix(col, vec3(0.0), 0.89*smoothstep(0.03, 0.15, length(uv)));\n    \n    m.metallic = mix(0.0, 0.5, iris);\n    //col.rg = uv.rg;\n    return col;\n}\n\nvec3 skinTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 c1 = rgb(186, 115, 85);\n    vec3 c2 = rgb(211, 162, 132);\n    vec3 c3 = rgb(175, 112, 58);\n    vec3 c4 = rgb(220, 164, 136);\n    \n    float pat = voronoi2D(uv*16., 3.39291);\n    \n    vec3 hf1 = snoise(uv, 0.092931, 0.02, 32.0, 6);\n    vec3 lf1 = snoise(uv, 4.494929, 0.03, 8.0, 6);\n    vec3 lf2 = snoise(uv, 9.982835, 0.04, 5.0, 6);\n    \n    pat *= smoothstep(0.4, 0.7, clamp(lf2.x+(lf1.z*0.15), 0.0, 1.0));\n    pat *= 0.4;\n    \n    vec3 patCol1 = mix4(c1, c2, c3, c4, smoothstep(0.4, 0.7, lf2));\n    vec3 patCol2 = mix4(c4, c3, c2, c1, smoothstep(0.4, 0.7, hf1));\n    vec3 patCol = mix(patCol1*c2, patCol2*patCol1, smoothstep(0.4, 0.7, lf1.z));\n    \n    vec3 skin1 = mix4(c1, c2, c3, c4, hf1);\n    vec3 skin2 = mix4(c4, c3, c2, c1, hf1);\n    vec3 skinCol = mix(skin1, skin2, lf1.x);\n    col += skinCol;\n\n\n    \n    \n    col = mix(col, patCol, pat);\n    m.z = 0.5-pat;\n    m.spec = clamp(pat*3.5, 0.4, 0.7);\n    m.rough = clamp(((pat*2.)+(lf1.x*0.6)), 0.38, 1.0);\n    \n    return col;\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, n);\n    uv -= 1.;\n    vec3 col = vec3(0.0)+checkerTexture(uv*0.5, 0.02);\n    data.m.rough = 0.5;\n    data.m.metallic = 0.55;\n    return col;\n}\n\n//#define DEBUG_TEXTURE lipTexture\nvec3 lipTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    vec3 c1 = rgb(221, 162, 164);\n    vec3 c2 = rgb(186, 82, 88);\n    vec3 c3 = rgb(152, 74, 70);\n    vec3 c4 = rgb(201, 127, 136);\n    \n    vec3 hf1 = snoise(uv, 0.092931, 1., 32.0, 6);\n    vec3 lf1 = snoise(uv, 4.494929, 0.03, 8.0, 6);\n    vec3 lf2 = snoise(uv, 9.982835, 0.04, 5.0, 6);\n    \n    float pat = voronoi2D((uv*16.)+lf2.xy*8., 3.39291);\n    pat = smoothstep(1.0, 0.0, pat);\n    \n    vec3 col1 = mix4(c1, c2, c3, c4, hf1);\n    vec3 col2 = mix4(c4, c3, c2, c1, hf1);\n    col = mix(col1, col2, smoothstep(0.4, 0.7, lf2.x));\n    \n    col = mix(col, col*col, clamp(pat, 0.5, 1.0));\n    \n    m.z = 0.5-pat;\n    \n    return col;\n}\n\nvec3 getAlbedoFace(inout Data data) {\n    vec3 p = pointRot(data.p - data.o.p, data.o.q);\n    vec3 n = pointRot(data.n, data.o.q);\n    vec2 uv = boxUv(p, n);\n    vec3 col = vec3(1.0);\n    \n    Object o = data.o;\n    int oId = 0;\n    float lip = 0.0;\n    float head = 0.0;\n    float eye = 0.0;\n    float hand = 0.0;\n    float lleg = 0.0;\n    float face = faceSDF(\n        p,\n        oId,\n        o,\n        -1,   \n        lip,\n        head,\n        eye,\n        hand,\n        lleg\n    );\n    \n    Material skinMaterial = NEW_MATERIAL;\n    Material lipMaterial = NEW_MATERIAL;\n    float lipArea = smoothstep(0.025, 0.0, lip);\n    float lipArea2 = smoothstep(0.09, 0.025, lip);\n    float skinArea = max(\n        smoothstep(0.03, 0.0, head),\n        max(\n        smoothstep(0.015, 0.0, hand),\n        smoothstep(0.015, 0.0, lleg)\n        )\n    )*(1.0-(lipArea*0.35));\n    col = mix(col, skinTexture(uv*9., p, skinMaterial), skinArea);\n    col = mix(col, lipTexture(uv*16., p, lipMaterial), lipArea);\n    \n    data.m = materialMix(data.m, skinMaterial, skinArea);\n    data.m = materialMix(data.m, lipMaterial, lipArea);\n    data.n = makeNormal(data.n, data.m.z, 0.11, 0.09);\n    \n    //col = mix(col, vec3(1, 0, 0), smoothstep(0.03, 0.0, lip));\n    \n    //data.n = makeNormal(data.n, data.m.z, 0.16, 0.009);\n    return col;\n}\n\n\nvec3 getAlbedoFaceEye(inout Data data) {\n    vec3 p = pointRot(mirrorX(data.p) - data.o.p, data.o.q*sign(data.p.x));\n    vec3 n = data.n;\n    vec2 uv = p.xy;//boxUv(p, n);\n    uv.y -= 0.006;\n    vec3 col = eyeTexture(uv, p, data.m);\n    data.m.lum = 1.;\n    data.m.rough = 0.1;\n    data.m.metallic = max(data.m.metallic, 0.15);\n    return col;\n}\n\nvec3 getAlbedoFaceHand(inout Data data) {\n    vec3 p = mirrorX(data.p) - data.o.p;\n    vec3 n = pointRot(data.n, data.o.q);\n    vec2 uv = boxUv(p, n);\n    vec3 col = skinTexture(uv*9., p, data.m);\n    return col;\n}\n\n//#define DEBUG_TEXTURE concreteTexture\n\nvec3 concreteTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 c1 = vec3(0.424, 0.427, 0.447);\n    vec3 c2 = vec3(0.302, 0.294, 0.290);\n    vec3 c3 = vec3(0.835, 0.835, 0.835);\n    vec3 c4 = vec3(0.455, 0.424, 0.341);\n    \n    float w = wnoise(uv*4.);\n    //w = smoothstep(0.5, 0.8, w);\n    vec2 ww = vec2(cos(w*3.14), sin(w*3.14));\n    \n    vec3 lf1 = snoise(uv, 7.777948833, 0.0, 6.0, 6);\n    vec3 lf2 = snoise(uv, 16.69383838, 0.3, 16.0, 4);\n    float cracks = 1.0-smoothstep(0.0, 0.09, abs(lf2.x*2.0-1.0));\n    cracks *= smoothstep(0.4, 0.7, lf2.y);\n    cracks *= smoothstep(0.2, 0.6, lf1.x);\n    \n    uv += 0.05*ww*smoothstep(0.4, 0.7, lf1.y);\n    \n    \n    vec3 hf1 = snoise(uv, 0.032982191, 0.0, 96.0, 6);\n    vec3 hf2 = snoise(uv, 3.339299822, 0.0, 64.0, 6);\n    \n    \n    vec3 bg1 = mix4(c1, c2, c3, c4, hf1);\n    vec3 bg2 = mix4(c4, c3, c2, c1, smoothstep(0.4, 0.7, hf2));\n    vec3 bg = mix(bg1, bg2, smoothstep(0.4, 0.7, lf1.x));\n    col += bg;\n    \n    col = mix(col, clamp((col*col)+c3, 0.0, 1.0), w*w*w*0.25);\n    col = mix(col, c2, 0.8*smoothstep(0.1, 0.6, lf1.z)*clamp(length(ww-lf1.xy), 0.0, 1.0));\n    col = mix(col, clamp(col*c4+c1, 0.0, 1.0), cracks);\n    \n    m.z = max(0.0, 0.2-cracks);\n    m.spec = w*w;\n//    m.rough = clamp(max(0.0, 1.0-w)+cracks, 0.81, 1.0);\n    \n    return col;\n}\n\nvec3 getAlbedoRoom(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, n);\n    vec3 col = concreteTexture(uv, p, data.m);\n    data.n = makeNormal(data.n, data.m.z, 0.5, 0.01);\n    return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_GROUND: return getAlbedoGround(data); break;\n        case ID_FACE: return getAlbedoFace(data); break;\n        case ID_FACE_EYE: return getAlbedoFaceEye(data); break;\n        case ID_FACE_HAND: return getAlbedoFaceHand(data); break;\n        case ID_ROOM: return getAlbedoRoom(data); break;\n    }\n    \n    return vec3(0.77);\n}\n\nvec3 getSky(in vec3 rd, in Light[NUM_LIGHTS] lights) {\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    vec3 col = pow(COLOR_SKY, vec3(1.0 + dotup));\n    return col;\n}\n\nvec3 render(inout Data data, in vec3 ro, in vec3 rd, inout float depth) {\n    vec3 col = vec3(0.0);\n    depth = 1.0;\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    \n    Light lights[NUM_LIGHTS];\n    lights[0] = Light(vec3(2.2, 2, -4.5), vec3(0.0), vec3(6.5, 2.9, 1.5), 2.5, LIGHT_POINT);\n    vec3 spotPos = vec3(-2.6, 6., -4.5);\n    vec3 spotDir = normalize(-spotPos);\n    lights[1] = Light(spotPos, -spotDir, vec3(5.5, 3.3, 2.2), 2.5, LIGHT_DIR);\n    \n    raycast(data, lights, col, ro, rd);\n    \n    depth = data.d / FAR;\n    \n    col = mix(col, vec3(0.0), 0.5*smoothstep(0.0, 0.11, depth));\n    \n    return col;\n}\n\nRay getRay(in vec2 uv, in vec4 m) {\n    vec3 ro = vec3(0, 0, -1.5);\n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n    \n    #if 0\n    vec3 toggleWalk = texelFetch(iChannel0, ivec2(2, 0), 0).xyz;\n    if (toggleWalk.x > 0.001) {\n        vec3 walk = texelFetch(iChannel0, ivec2(0, 0), 0).xyz;\n        vec3 fly = texelFetch(iChannel0, ivec2(1, 0), 0).xyz;\n        ro += walk;\n        ro.y += fly.y;\n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n        return Ray(ro, rd);\n    }\n    #endif\n    \n    if (m.z > 0.001 && length(m.xy) > 0.0001 && iFrame > 1 && iTime > 0.0001) {\n        ro.yz *= rot(m.y*TAU);\n        ro.xz *= rot(m.x*TAU);\n        \n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n    } else {\n        vec3 lookp = vec3(0, 0, 0);\n        ro = vec3(0, 0, -1.5);\n        float time = T;\n        float cycle = mod(time, 12.0+0.9);\n        float frame = 1.0;\n        \n        #define MOVE_TO(POINT, LOOK)\\\n            ro = mix(ro, POINT, smoothstep(frame - 0.9, frame + 0.9, cycle));\\\n            lookp = mix(lookp, LOOK, smoothstep(frame - 0.9, frame + 0.9, cycle));\\\n            frame += 1.0;\n            \n        MOVE_TO(vec3(0, 0, -1.5), vec3(0, 0, 0));\n        MOVE_TO(vec3(0, 0, -1.9), vec3(0, 0, 0));\n        MOVE_TO(vec3(0, 0, -2.0), vec3(0, 0, 0));\n        MOVE_TO(vec3(0.5, 0, -2.0), vec3(0, 0, 0));\n        MOVE_TO(vec3(1.0, 0, -2.0), vec3(0, 0, 0));\n        MOVE_TO(vec3(0.5, 0, -2.0), vec3(0, 0, 0));\n        MOVE_TO(vec3(0.0, 0, -2.0), vec3(0, 0, 0));\n        MOVE_TO(vec3(-0.5, 0, -2.0), vec3(0, 0, 0));\n        MOVE_TO(vec3(-1.0, 0, -2.0), vec3(0, 0, 0));\n        MOVE_TO(vec3(-0.5, 0, -2.0), vec3(0, 0, 0));\n        MOVE_TO(vec3(0.0, 0, -2.0), vec3(0, 0, 0));\n        \n        /////////////////////////////////////////////\n        MOVE_TO(vec3(0.0, 0, -1.5), vec3(0, 0, 0));\n        rd = look(uv, lookp, ro, 1.0);\n    }\n    \n    float y = 2.8;\n    ro.y += y;\n    ro.y = max(ro.y, y);\n    \n    return Ray(ro, rd);\n}\n\nvec4 blit(in vec2 fc) {\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y, iMouse.zw);\n    \n    Ray ray = getRay(uv, m);\n    vec3 ro = ray.ro;\n    vec3 rd = ray.rd;\n    Data data = NEW_DATA;\n    float depth = 1.0;\n    \n    #ifdef DEBUG_TEXTURE\n    #ifdef DEBUG_CENTER_UV\n    vec2 debugUv = (fc-0.5*R.xy)/R.y;\n    #else\n    vec2 debugUv = fc.xy/R.xy;\n    #endif\n    Material ma = NEW_MATERIAL;\n    col += DEBUG_TEXTURE(debugUv, ro+rd, ma);\n    #else\n    col += render(data, ro, rd, depth);\n    col = aces(col);\n    col = pow(col, vec3(1.0 / 2.2));\n    #endif\n    \n    return vec4(col, depth);\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    O = blit(fc);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R (iResolution.xy)\n#ifndef HW_PERFORMANCE\n#define iTime (0.0)\n#define iFrame (0)\nuniform sampler2D iChannel3;\n#define iResolution vec2(0.0)\n#define iMouse vec4(0.0)\n#endif\n#define T (iTime)\n#define M_PI (3.14159265359)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define NEG1 (min(-1, ZERO))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n\nstruct Light { vec3 p; vec3 d; vec3 c; float s; int type; };\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\n\n#define FORWARD_DECL\\\n    float sdf(inout Data data, in vec3 p) { return FAR; }\\\n    vec3 getAlbedo(inout Data data) { return vec3(0.0); }\\\n    vec3 getSky(in vec3 rd, in Light[NUM_LIGHTS] lights) { return vec3(0.0); }\n\n#define SAMPLE(var, OBJ, id_) if (id_ != skip && var < dist) { id = id_; dist = var; o = OBJ; }\n// Ray marcher constants\n\n#define NEAR 0.003\n#define FAR 50.0\n#define STEPS 60\n#define SHADOW_STEPS 33\n#define FAR_LOD 0.8\n#define NORMAL_RANGE 0.001\n#define AMBIENT 0.01\n#define NUM_LIGHTS 2\n#define ID_NONE -1\n\n// Colors\n\n#define COLOR_SKY vec3(0.29, 0.61, 0.9)\n#define COLOR_SUN vec3(0.97, 0.81, 0.79)\n\n// Render constants\n\n#define SPECULAR_AMPLITUDE 64.0\n#define SHADOW_NDOTL_EPSILON 0.000003\n\n// Default sun light\n\n#define LIGHT_SUN Light(vec3(1, 2, -3), vec3(0.0), COLOR_SUN, 2.0, LIGHT_AMBIENT)\n\nstruct Object {\n    vec3 p;\n    vec3 q;\n};\n\n#define NEW_OBJECT Object(vec3(0.0), vec3(0.0))\n\nstruct Material { float rough; float spec; float metallic; float lum; float z; float ior; };\n#define NEW_MATERIAL Material(1.0, 1.0, 0.0, 0.0, 0.0, 0.0)\n\nMaterial materialMix(in Material a, in Material b, float f) {\n    Material c = NEW_MATERIAL;\n    c.rough = mix(a.rough, b.rough, f);\n    c.spec = mix(a.spec, b.spec, f);\n    c.metallic = mix(a.metallic, b.metallic, f);\n    c.lum = mix(a.lum, b.lum, f);\n    c.z = mix(a.z, b.z, f);\n    c.ior = mix(a.ior, b.ior, f);\n    return c;\n}\n\nstruct Data {\n    vec3 q;\n    vec3 ro;\n    vec3 rd;\n    vec3 p;\n    vec3 n;\n    float d;\n    int skip;\n    int id;\n    float sig;\n    Material m;\n    Object o;\n};\n#define NEW_DATA Data(vec3(0.0), vec3(0.0),vec3(0.0), vec3(0.0), vec3(0.0), FAR, ID_NONE, ID_NONE, 1., NEW_MATERIAL, NEW_OBJECT)\n\n\nstruct Ray {\n    vec3 ro;\n    vec3 rd;\n};\n\n#ifndef HW_PERFORMANCE\nfloat sdf(inout Data data, in vec3 p) { return FAR; }\nvec3 getAlbedo(inout Data data) { return vec3(0.0); }\nvec3 getSky(in vec3 rd, in Light[NUM_LIGHTS] lights) { return vec3(0.0); }\n#else\nfloat sdf(inout Data data, in vec3 p);\nvec3 getAlbedo(inout Data data);\nvec3 getSky(in vec3 rd, in Light[NUM_LIGHTS] lights);\n#endif\n\n\n// Utilities\n\nvec3 mix4(vec3 c1, vec3 c2, vec3 c3, vec3 c4, vec3 m) {\n    return mix(mix(mix(c1, c2, m.x), c3, m.y), c4, m.z);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n    return smin(a, b, -k);\n}\n\nvec3 smin(vec3 a, vec3 b, float k) {\n    vec3 h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nvec3 smax(vec3 a, vec3 b, float k) {\n    return smin(a, b, -k);\n}\n\nfloat sabs(in float v, in float k) {\n    return smax(-v, v, k);\n}\n\nfloat sclamp(in float v, in float mi, in float ma, in float k) {\n    return smin(smax(v, mi, k), ma, k);\n}\n\nfloat sgt(in float a, in float b, in float s) {\n    float h = clamp(0.5 + 0.5 * (a - b) / s, 0.0, 1.0);\n    return mix(0.0, 1.0, h*h*(3.0-2.0*h));\n}\n\nfloat slt(in float a, in float b, in float s) {\n    float h = clamp(0.5 + 0.5 * (b - a) / s, 0.0, 1.0);\n    return mix(0.0, 1.0, h*h*(3.0-2.0*h));\n}\n\nfloat srange(in float v, in float mi, in float ma, in float s) {\n    return sgt(v, mi - s, s) * slt(v, ma + s, s);\n}\n\nfloat smoothSign(float x, float k) {\n    float s = smoothstep(-k, k, x);\n    return mix(s, sign(x), 0.5*clamp(max(0.0, 1.0-(abs(s)*2.5))*max(0.0, 1.0-k), 0.0, 1.0));\n}\n\nvec3 mirrorX(in vec3 p) {\n    return vec3(abs(p.x), p.y, p.z);\n}\n\nvec3 makeNormal(in vec3 wn, in float z, in float mx, in float s) {\n    if (abs(z) <= 0.0000001) return wn;\n    vec2 dx = vec2(dFdx(z), 0.0001);\n    vec2 dy = vec2(0.0001, dFdy(z));\n    float bumpScale = s;\n    vec3 cp = cross(vec3(dx, bumpScale), vec3(dy, bumpScale));\n    if (length(cp) <= 0.00002) return wn;\n    cp = normalize(cp);\n    mx *= max(0.0, 1.0 - max(0.0, dot(cp, -wn)));\n    vec3 next = normalize(mix(wn, normalize(wn+cp), mx));\n    if (length(next) <= 0.0001) return wn;\n    return next;\n}\n\nmat2 rot(in float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\nvec3 look(in vec2 uv, in vec3 point, in vec3 ro, in float zoom) {\n    vec3 camForward = normalize(point - ro);\n    vec3 camRight = -normalize(cross(camForward, vec3(0, 1, 0)));\n    vec3 camUp = -normalize(cross(camRight, camForward));\n    vec3 screenCenter = ro + camForward * zoom;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\n\nvec3 pointRot(in vec3 p, in vec3 r) {\n    p.yz *= rot(r.x);\n    p.xz *= rot(r.y);\n    p.xy *= rot(r.z);\n    return p;\n}\n\nvec3 pointRotInv(in vec3 p, in vec3 r) {\n    p.xy *= inverse(rot(r.z));\n    p.xz *= inverse(rot(r.y));\n    p.yz *= inverse(rot(r.x));\n    return p;\n}\n\nvec3 pointRotMx(in vec3 p, in vec3 r, in float s) {\n    vec3 p2 = p;\n    p2.yz *= rot(r.x);\n    p2.xz *= rot(r.y);\n    p2.xy *= rot(r.z);\n    return mix(p, p2, s);\n}\n\nvec2 boxUv(in vec3 p, in vec3 n) {\n    return mix(mix(p.xy, p.yz, round(adot(n, vec3(1, 0, 0)))), p.xz, round(adot(n, vec3(0, 1, 0))));\n}\n\n// Distance functions\n\nfloat sphereSDF(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat boxSDF(in vec3 p, in vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat lineSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    return length(pa - ba * (clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0))) - r;\n}\n\nfloat cylSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    vec3 c = a + t * ab;\n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n    return e + i;\n}\n\nfloat torusSDF(in vec3 p, in float r1, float r2) {\n    p = p.yzx;\n    float ll = length(p.yz)-r1;\n    return length(vec2(ll,p.x))-r2;\n}\n\n// Noise functions\n\nfloat hash21Fast(in vec2 p, in float seed) {\n    float ma = 64.092391;\n    float x = mod(p.x*4.0291, ma) / ma;\n    float y = mod(p.y*5.5920, ma) / ma;\n    vec2 p2 = mix(vec2(x,y), vec2(y, x), fract(seed*10.29891231))*2.0-1.0;\n    float r1 = mod(100.2891382*fract(seed+(dot(p, p2)*16.2099123)), ma)/ma;\n    float r2 = fract((p.x*3.392912+p.y)*distance(p2, p-seed));\n    return fract(dot(p, vec2(r1, r2)));\n}\n\nfloat voronoi2D(in vec2 p, in float seed){\n    vec2 Pi = floor(p);\n    vec2 Pf = fract(p);\n    \n    float dmin = 1e20;\n    vec2 res = vec2(0.0);\n    float r = 1.0;\n    \n    for(int j=NEG1; j<=1; j++){\n        for(int i=NEG1; i<=1; i++){\n            vec2 lattice = vec2(float(i),float(j));\n            vec2 offset = vec2(hash21Fast(Pi+lattice, seed+3.328123), hash21Fast(Pi+lattice, seed+5.58931));\n            vec2 diff = lattice + offset - Pf;\n            \n            float dist = dot(diff,diff);\n            r = min(r, dist/0.56);\n            if(r<dmin){\n                dmin = r;\n                res = lattice + offset;\n            }\n        }\n    }\n\n    return clamp(sqrt(dmin), 0.0, 1.0);\n}\n\nfloat wnoise(in vec2 uv) {\n    vec2 k = uv*2.0-1.0;\n    vec2 r = vec2(0.0);\n    float f = 1.;\n    const int iter = 4;\n    const float dim = 1.;\n    for (int i = ZERO; i < iter; i++) {\n        r += sin( k*f +(float(i)/float(iter))*2.5) / f;\n        k = k * mat2(8.0, 6.28, -8.0, 6.28)*.1 + r*.29;     \n        r += sin( k*f +(float(i)/float(iter))*2.5) / f;\n        k = k * mat2(8.0, 6.28, -8.0, 6.28)*.1 + r*.29;\n    };\n    float n = 1.0-dFdx(length(r)*dim);\n    return clamp(exp(n-1.5)*n, 0.0, 1.0);\n}\n\n#define NOISE(p, seed, lod) (textureLod(iChannel3, (p + (seed*1.9287827185))/256.0, lod).rgb)\n\nvec3 snoise(in vec2 p, in float seed, in float lod) {\n    p += 0.99288124;\n    vec2 id = floor(p);\n    vec2 lv = fract(p); lv = lv*lv*(3.0-2.0*lv);\n    return mix(\n        mix(NOISE(id, seed, lod), NOISE(id + vec2(1, 0), seed, lod), lv.x),\n        mix(NOISE(id + vec2(0, 1), seed, lod), NOISE(id + vec2(1, 1), seed, lod), lv.x),\n        lv.y\n    );\n}\n\nvec3 snoise(in vec2 p, in float seed, in float lod, in float freq, const in int octaves) {\n    p += 0.99288124;\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    for (int i = ZERO; i < octaves; i++) {\n        n += amp * snoise(p*freq, seed, lod); div += amp; amp /= 2.0; lod /= 2.0; freq *= 2.0;\n    }\n    return n / div;\n}\n\nvec3 snoiseWarp(in vec2 p, in float seed, in float lod, in float freq, const in int octaves, in float warp) {\n    p += 0.99288124;\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    for (int i = ZERO; i < octaves; i++) {\n        n += amp * snoise(p*freq, seed, lod); div += amp; amp /= 2.0; lod /= 2.0; freq *= 2.0;\n        p += (n.xy*n.z)*warp;\n    }\n    return n / div;\n}\n\n// Shading & Colors\n\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\n\nvec3 aces(vec3 x) {return x*(2.51*x + .03) / (x*(2.43*x + .59) + .14); }\n\nvec3 fresnelSchlickRoughness(float NdotV, vec3 F0, float rough) {\n  return F0 + (max(vec3(1.0 - rough), F0) - F0) * pow(max(1.0 - NdotV, 0.0), 5.0);\n}\n\nvec3 fresnelSchlick(vec3 F0, float cosTheta) {\n\treturn F0 + (vec3(1.0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nfloat ndfGGX(float cosLh, float roughness) {\n\tfloat alpha   = roughness * roughness;\n\tfloat alphaSq = alpha * alpha;\n\n\tfloat denom = (cosLh * cosLh) * (alphaSq - 1.0) + 1.0;\n\treturn alphaSq / (0.00038287129+(M_PI * denom * denom));\n}\n\nfloat gaSchlickG1(float cosTheta, float k) {\n\treturn cosTheta / (0.0003111772+(cosTheta * (1.0 - k) + k));\n}\n\nfloat gaSchlickGGX(float cosLi, float cosLo, float roughness) {\n\tfloat r = roughness + 1.0;\n\tfloat k = (r * r) / 8.0;\n\treturn gaSchlickG1(cosLi, k) * gaSchlickG1(cosLo, k);\n}\n\nvec3 EnvBRDFApprox(vec3 specularColor, float roughness, float ndotv) {\n    const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n    const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * ndotv)) * r.x + r.y;\n    vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n    return specularColor * AB.x + AB.y;\n}\n\n// Marching\n\nbool march(inout Data data, in vec3 ro, in vec3 rd) {\n    float d = 0.0;\n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        d += next;\n        if (abs(next) <= (NEAR * (1.0 + (d / FAR_LOD)))) break;\n        if (abs(d) >= FAR) return false;\n    }\n    \n    vec3 p = ro+rd*d;\n    //vec2 e = vec2(NORMAL_RANGE, 0.0);\n    /*vec3 n = normalize(sdf(data, p) - vec3(\n        sdf(data, p - e.xyy),\n        sdf(data, p - e.yxy),\n        sdf(data, p - e.yyx)\n    ));*/\n    \n    // thanks to iq: https://iquilezles.org/articles/normalsSDF/\n    const float h = NORMAL_RANGE;\n    vec3 n = vec3(0.0);\n    for(int i = ZERO; i < 4; i++) {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdf(data, p+e*h);\n    }\n    n = normalize(n);\n    \n    data.d = d;\n    data.p = p;\n    data.n = n;\n    \n    return true;\n}\n\n// Modified version of iq's https://www.shadertoy.com/view/lsKcDD\nfloat getShadow(in vec3 ro, in vec3 rd, in vec3 n, in float near, in float far, in int skip) {\n    float NdotL = dot(n, rd);\n    float nl = max(0.0, NdotL);\n    float res = 1.0;\n    float t = NEAR;\n    float ph = 1e10;\n    Data data = NEW_DATA;\n    data.skip = skip;\n    \n    float tneg = 0.0;\n    \n    for(int i = ZERO; i < SHADOW_STEPS; i++) {\n        vec3 p = ro + rd*t;\n        \n        p += n*nl*(1.0+0.1*(t / (1.0 + t)));\n        \n\t\tfloat h = sdf(data, p);\n        \n        float neg = max(0.0, -h);\n        tneg += neg;\n\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min(res, 16.0*d/max(0.0,t-y));\n        ph = h;\n        ph += nl;\n        \n        t += h;\n        \n        if( res < 0.0001 || t > far ) break;\n        \n    }\n    res = clamp(res, AMBIENT, 1.0);\n    return clamp(res*res*(3.0-2.0*res), AMBIENT, 1.);\n}\n\n// Lighting\n\nvec3 getLightDir(in Light light, in vec3 p) {\n    return light.type == LIGHT_AMBIENT ? normalize(light.p) :\n           light.type == LIGHT_POINT ? normalize(light.p - p) :\n           normalize(light.d);\n}\n\nvec3 getLightAtt(in Light light, in vec3 p, in vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = max(AMBIENT, dot(n, L));\n    \n    switch (light.type) {\n        case LIGHT_AMBIENT: return light.c * light.s * NdotL; break;\n        case LIGHT_POINT: return light.c * NdotL * (\n            pow(light.s, 2.0) / max(0.0001, pow(distance(light.p, p), 2.0))\n        ); break;\n        case LIGHT_DIR: return light.c * light.s * NdotL * smoothstep(0.8, 1.0, dot(\n            normalize(light.p - p),\n            L\n        )); break;\n    }\n    \n    return vec3(0.0);\n}\n\nvec3 forEachLight(in Light light, in Data data, in vec3 ro, in vec3 rd, in vec3 diffuse) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec3 L = getLightDir(light, p);\n    vec3 ref = reflect(L, n);\n    float VdotR = cdot(rd, ref);\n    float spec = data.m.spec * pow(VdotR, SPECULAR_AMPLITUDE);\n    vec3 att = getLightAtt(light, p, n);\n    float shadow = data.m.lum > 0.992 ? 1.0 : getShadow(p + (n*NEAR*2.0), L, n, data.d, light.type == LIGHT_AMBIENT ? FAR :\n        distance(light.p, p), data.id);\n        \n    float metallic = data.m.metallic;\n    float rough = data.m.rough;\n    float specF = data.m.spec;\n    \n    vec3 LH = normalize(L + -rd);\n    float cosLi = max(0.0001, dot(n, L));\n\tfloat cosLh = max(0.0001, dot(n, LH));\n    float cosLo = max(0.0001, dot(n, -rd));\n    vec3 F0 = mix(vec3(0.04), diffuse, metallic);\n    vec3 F  = fresnelSchlick(F0, max(0.0, dot(LH, -rd)));\n    float D = ndfGGX(cosLh, rough);\n    float G = gaSchlickGGX(cosLi, cosLo, rough);\n    vec3 kd = mix(vec3(1.0) - F, vec3(0.0), metallic);\n    vec3 diffuseBRDF = kd * diffuse;\n    vec3 specularBRDF = (F * D * G) / max(0.00003, 4.0 * cosLi * cosLo);\n    \n        \n    return (diffuseBRDF + specF*specularBRDF) * att * shadow; \n}\n\nbool rayGetColor(inout Data data, in Light lights[NUM_LIGHTS],\n    in bool with_sky, inout vec3 col, in vec3 ro, in vec3 rd, inout vec3 diffuse) {\n    if (!march(data, ro, rd)) {\n        if (with_sky) {\n            col += getSky(rd, lights);\n        }\n        return false;\n    }\n    vec3 albedo = getAlbedo(data);\n    diffuse = albedo / M_PI;\n    for (int i = ZERO; i < NUM_LIGHTS; i++) {\n        Light light = lights[i];\n        col += forEachLight(light, data, ro, rd, diffuse);\n    }\n    return true;\n}\n\nbool raycast(\n    inout Data data,\n    in Light lights[NUM_LIGHTS],\n    inout vec3 col,\n    in vec3 ro,\n    in vec3 rd\n ) {\n    \n    vec3 diffuse = vec3(0.0);\n    if (!rayGetColor(data, lights, true, col, ro, rd, diffuse)) return false;\n    float rough = data.m.rough;\n    float metallic = data.m.metallic;\n    vec3 n = data.n;\n    vec3 p = data.p;\n    \n    if (rough < 0.993) {\n        vec3 F0 = mix(vec3(0.04), diffuse, metallic);\n        float NdotV = max(0.0, dot(n, -rd));\n        vec3 F = fresnelSchlickRoughness(NdotV, F0, rough);\n        Data reflectData = NEW_DATA;\n        vec3 reflectRo = p + (n*NEAR*3.);\n        vec3 reflectDir = reflect(rd, n);\n        vec3 reflectDiffuse = vec3(0.0);\n        vec3 reflectColor = vec3(0.0);\n        vec3 env = EnvBRDFApprox(vec3(0.77), rough*rough, NdotV);\n        reflectData.skip = data.id;\n        \n        rayGetColor(reflectData, lights, true, reflectColor, reflectRo, reflectDir, reflectDiffuse);\n        \n        col += reflectColor * (F * env.x * env.y);\n    }\n    \n    return true;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"FORWARD_DECL\n#pragma optimize(off)\n#pragma optionNV(fastmath off)\n#pragma optionNV(fastprecision off)\n#pragma optionNV(unroll none)\n\n// taken from https://www.shadertoy.com/view/ldGGzV\n\n#define MOVE_SPEED 10.\n#define PI 3.14159\n\nconst float KEY_W = 87.5 / 256.0;\nconst float KEY_A = 65.5 / 256.0;\nconst float KEY_S = 83.5 / 256.0;\nconst float KEY_D = 68.5 / 256.0;\nconst float KEY_SHIFT = 16.0;\nconst float KEY_SPACE = 32.0;\nconst float KEY_V = 86.0;\n\n\nbool isEnabled() {\n    return texelFetch(iChannel1, ivec2(2, 0), 0).x > 0.001;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos = texture(iChannel1, vec2(0.)).xyz;\n    if(iFrame <= 1) pos = vec3(0., 2.0, 10.);\n    \n    switch (int(fragCoord.x)) {\n        case 0: {\n            if (isEnabled()) {\n                float mx = iMouse.xy == vec2(0.) ? 0. : ((iMouse.x / iResolution.x) * 2. - 1.) * 360.;\n                float speed = MOVE_SPEED * iTimeDelta;\n\n                float forwardBackward =\n                texture(iChannel0, vec2(KEY_W, 0.)).r -\n                texture(iChannel0, vec2(KEY_S, 0.)).r;\n\n                float leftRight =\n                texture(iChannel0, vec2(KEY_A, 0.)).r -\n                texture(iChannel0, vec2(KEY_D, 0.)).r;\n\n                float s = sin(radians(mx));\n                float c = cos(radians(mx));\n\n                pos.x += speed * (forwardBackward * s - leftRight * c);\n                pos.z += speed * (forwardBackward * c + leftRight * s);\n            }\n        }; break;\n        case 1: {\n            if (isEnabled()) {\n                pos = texelFetch(iChannel1, ivec2(1, 0), 0).xyz;\n                float space = texelFetch(iChannel0, ivec2(KEY_SPACE, 0), 0).r;\n                float shift = texelFetch(iChannel0, ivec2(KEY_SHIFT, 0), 0).r;\n\n                pos.y += space * 0.2;\n                pos.y -= shift * 0.2;\n            }\n        }; break;\n        \n        case 2: {\n            pos = texelFetch(iChannel1, ivec2(2, 0), 0).xyz;\n            float v = texelFetch(iChannel0, ivec2(KEY_V, 0), 0).r;\n            \n            float timeDiff = iTime - pos.y;\n            \n             if (timeDiff > 0.07) {\n                bool prev = pos.x > 0.0001;\n                bool toggle = v > 0.0001;\n\n                bool next = prev;\n\n\n                if (toggle) {\n                    next = !prev;\n                }\n                pos.y = iTime;\n                pos.x = next ? 1.0 : 0.0;\n            }\n        \n        }; break;\n    }\n    \n    \n    fragColor = vec4(pos, 0.);\n}","name":"Buffer D","description":"","type":"buffer"}]}