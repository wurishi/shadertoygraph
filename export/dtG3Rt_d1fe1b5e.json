{"ver":"0.1","info":{"id":"dtG3Rt","date":"1685402802","viewed":133,"name":"Hollow Sphere Theory ","username":"RedWool","description":"Shader for BC Calculus","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define cTime clamp(iTime * .15,0.,1.)\n#define tTime (3.*pow(cTime,2.) - 2.*pow(cTime,3.))\n\nstruct Material \n{\n    float dist;\n    vec3 color;\n    vec3 pos;\n    float r;\n};\n\nmat2 rot(float a)\n{\n    return mat2(cos(a), -sin(a),\n    sin(a),cos(a));\n}\n\nMaterial add (Material m, Material s)\n{\n    bool b = min(m.dist, s.dist) == s.dist;\n    return Material(\n    min(m.dist, s.dist),\n    b ? s.color : m.color,\n    b ? s.pos : m.pos,\n    b ? s.r : m.r);\n}\n\nMaterial sub (Material m, Material s)\n{\n    bool b = max(m.dist, -s.dist) == m.dist;\n    return Material(\n    max(-m.dist, s.dist),\n    b ? s.color : m.color,\n    b ? s.pos : m.pos,\n    b ? s.r : m.r);\n}\n\nfloat sdfSphere(vec3 o, vec3 c)\n{\n    return distance(o, c) - 1.47;\n}\n\nfloat sdfHollowSphere(vec3 o, vec3 c)\n{\n    return abs(distance(o, c) - 1.49)-.01;\n}\n\n\nfloat sdfBox(vec3 o, vec3 c)\n{\n    vec3 s = vec3(4.98);\n    vec3 p = clamp(o - c, -s, s);\n    return distance(o, c + p)-.01;\n}\n\nMaterial ring(vec3 o, vec3 c, float p, float l)\n{\n    Material s = Material(sdfHollowSphere(o, vec3(0)+c), vec3(.1,.1,.1),o ,.8);\n    Material b1 = Material(sdfBox(o, vec3(l+p+5.,0,0)+c), vec3(1,0,0),o ,1.);\n    Material b2 = Material(sdfBox(o, vec3(-l+p-5.,0,0)+c), vec3(1,0,0),o ,1.);\n    \n    return sub(b2,sub(b1,s));\n}\n\nfloat atan2(vec2 o)\n{\n    return atan(o.x / o.y);\n}\n\nMaterial map(vec3 o)\n{\n    float div = mix(35., 35., tTime), dif = mix(.5, 0., tTime), di = 1.5/div, c = -1.5 + di, p = c;\n    Material r = ring(o,vec3(p*dif,0,0),p,di);\n    for (float i = 1.; i < 29.; i++)\n    {\n        p = di*2.*i+c;\n        r = add(r, ring(o,vec3(p*dif,0,0),p,di));\n        // (i > 29.5? mix(0.,20.,tTime) : 0.)\n    }\n    \n    p = di*58.+c;\n        r = add(r, ring(o,vec3(p*dif+mix(1.5,0.,tTime),0,0),p,di));\n    \n    vec3 d = mix(vec3(8,0,0), vec3(0,0,0), tTime);\n    r = add(r, Material(sdfSphere(o,d)+.6, texture(iChannel1,vec2(atan2((o-d).xz),\n    atan2((o-d).yz)+.2)*-.333+.5).xyz,o,.1));\n    \n    //r = add(r, \n    \n    return r;\n} \n\nvec3 normal(vec3 o)\n{\n    vec2 d = vec2(.01, 0);\n    return normalize(vec3(\n    map(o + d.xyy).dist - map(o - d.xyy).dist,\n    map(o + d.yxy).dist - map(o - d.yxy).dist,\n    map(o + d.yyx).dist - map(o - d.yyx).dist));\n}\n\nvec3 rayMarch(vec3 o, vec3 d, out Material mat)\n{\n    float maxDist = 100.,\n    minDist = .001,\n    cd = 0.;\n    Material cm;\n    for (int i = 0; i < 150; i++)\n    {\n        vec3 co = o + d * cd;\n        cm = map(co);\n        \n        if(cm.dist < minDist)\n        {\n            mat = cm;\n            return mat.color*(dot(vec3(0,1,0),normal(co))*.3 +.7);\n        }\n        else if (cm.dist > maxDist)\n        {\n            break;\n        }\n        \n        cd += cm.dist;\n    }\n    \n    cm.r = -1.;\n    mat = cm;\n    return texture(iChannel0, d).xyz;\n}\n\nvec3 rayTrace(vec3 o, vec3 d)\n{\n    vec3 tot = vec3(0),\n    co = o, cd = d;\n    float l = .5, m = .9;\n    Material mat;\n    \n    tot = rayMarch(co, cd, mat);\n    if (mat.r > 0.)\n    {\n        for (int i = 0; i < 10; i++)\n        {\n            float pr = mat.r;\n            vec3 re = reflect(cd, normal(mat.pos));\n            cd = re;\n            co = mat.pos + re * 0.05;\n        \n            vec3 a = rayMarch(co, cd, mat);\n            if (mat.r < 0.)\n            {\n                tot += a * l * pr;\n                break;\n            }\n            tot += a * pr * l;\n        \n            l *= m;\n        }\n    }\n\n    return tot;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec2 inp = iMouse.xy/iResolution.y;\n    //vec3 co = vec3(0,0,-5);\n    vec3 cd = normalize(vec3(uv.x,uv.y,1));\n    \n    //float t = clamp(iTime*.5 ,0.,1.);\n    //t = 3.*pow(t,2.) - 2.*pow(t,3.);\n   \n    \n    vec3 \n    sPos = vec3(6,2,-6), \n    ePos = vec3(5,1,1),\n    cPos = mix(sPos, ePos, tTime);\n    \n    vec2\n    sRot = vec2(.3,.2),\n    eRot = vec2(1.8,.2),\n    cRot = mix(sRot, eRot, tTime);\n    \n    //cRot -= inp * 2.;\n    \n    cd.yz *= rot(cRot.y);\n    cd.xz *= rot(cRot.x);\n\n    //cPos.yz *= rot(cRot.y);\n    //cPos.xz *= rot(cRot.x);\n\n    // Time varying pixel color\n    vec3 col = rayTrace(cPos,cd);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}