{"ver":"0.1","info":{"id":"tslGDr","date":"1559835388","viewed":97,"name":"Ryan Raymarching","username":"rmccampbell7","description":"raymarching demo","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415927\n\n#define AA 2\n\n#define clamp01(x) clamp(x, 0., 1.)\n\nstruct DistMeta {\n    float dist;\n    int matId;\n};\n\nstruct Material {\n    vec3 diff_color;\n    vec3 spec_color;\n    float shininess;\n};\n\n\nfloat sdPlane(vec3 pos, vec3 norm, float d) {\n    return dot(pos, norm) - d;\n}\n\nfloat sdSphere(vec3 pos, float radius) {\n    return length(pos) - radius;\n}\n\nfloat sdBox(vec3 pos, vec3 bounds) {\n    return length(max(abs(pos) - bounds, 0.));\n}\n\n\nfloat opUnion(float a, float b) {\n    return min(a, b);\n}\n\nfloat opIntersect(float a, float b) {\n    return max(a, b);\n}\n\nfloat opSubtract(float a, float b) {\n    return max(a, -b);\n}\n\nDistMeta opUnion(DistMeta a, DistMeta b) {\n    if (a.dist < b.dist)\n        return a;\n    else\n        return b;\n}\n\n\nMaterial getMaterial(int matId) {\n    switch (matId) {\n    case 0:\n        return Material(vec3(.55), vec3(.8), 35.);\n    case 1:\n        return Material(vec3(1, 0, 0)*.9, vec3(.8), 20.);\n    case 2:\n        return Material(vec3(0, 1, 0)*.9, vec3(.8), 20.);\n    case 3:\n        return Material(vec3(0, 0, 1)*.9, vec3(.8), 20.);\n    case 4:\n        return Material(vec3(.4, 0, 1), vec3(.8), 15.);\n    default:\n        return Material(vec3(.25), vec3(0), 0.);\n    }\n}\n\n\nDistMeta map(vec3 pos) {\n    DistMeta res = DistMeta(sdPlane(pos, vec3(0,1,0), -6.), 0);\n    res = opUnion(res, DistMeta(sdSphere(pos - vec3(0,0,0), 5.), 1));\n    res = opUnion(res, DistMeta(sdSphere(pos - vec3(10,0,-2), 4.), 2));\n    res = opUnion(res, DistMeta(sdSphere(pos - vec3(-10,3,-2), 4.), 3));\n    res = opUnion(res, DistMeta(sdBox(pos - vec3(-8,-3,3), vec3(2)) - .4, 4));\n    return res;\n}\n\n\nDistMeta castRay(vec3 origin, vec3 dir) {\n    float minDist = 1.;\n    float maxDist = 100.;\n\n    float t = minDist;\n    int matId = -1;\n    for (int i=0; i<128; i++) {\n        float eps = 1e-4*t;\n        DistMeta res = map(origin + dir*t);\n        matId = res.matId;\n        if (res.dist < eps || t > maxDist) break;\n        t += res.dist;\n    }\n    if (t > maxDist)\n        matId = -1;\n    return DistMeta(t, matId);\n}\n\n\nvec3 calcNormal(vec3 pos) {\n    vec2 e = vec2(1.0, -1.0) * 1e-3;\n    return normalize(e.xyy * map(pos + e.xyy).dist +\n                     e.yxy * map(pos + e.yxy).dist +\n                     e.yyx * map(pos + e.yyx).dist +\n                     e.xxx * map(pos + e.xxx).dist);\n}\n\n\nvec3 shade(vec3 origin, vec3 dir, float dist, int matId) {\n    vec3 pos = origin + dist*dir;\n    vec3 normal = calcNormal(pos);\n    Material mat = getMaterial(matId);\n    float ambient = .12*(1.0 + .6*normal.y);\n    \n    vec3 light1 = normalize(vec3(1, 1, .75));\n    float diffuse = clamp01(dot(normal, light1));\n    float specular = pow(clamp01(dot(reflect(-light1, normal), -dir)), mat.shininess);\n\n    vec3 light2 = normalize(vec3(1, .5, -2));\n    diffuse += .8 * clamp01(dot(normal, light2));\n    specular += .8 * pow(clamp01(dot(reflect(-light2, normal), -dir)), mat.shininess);\n\n    float total = diffuse + ambient;\n    vec3 col = clamp01(total)*mat.diff_color;\n    col += clamp01(specular)*mat.spec_color;\n    return clamp01(col);\n}\n\n\nvec3 render(vec3 origin, vec3 dir) {\n    vec3 col = vec3(.5, .8, 1.)*(1.+1.5*dir.y);\n    DistMeta res = castRay(origin, dir);\n    if (res.matId >= 0) {\n        col = shade(origin, dir, res.dist, res.matId);\n    }\n    return col;\n}\n\n\nmat3 lookAt(vec3 cameraPos, vec3 center, vec3 up) {\n    vec3 forward = normalize(center - cameraPos);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    return mat3(right, up, forward);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy == vec2(0) ?\n        vec2(0) : (2.*iMouse.xy - iResolution.xy) / iResolution.xy;\n\n    float r = 30.;\n    float theta = 2.*PI*(iTime/10. + mouse.x*.5 + .25);\n    float phi = -mouse.y*PI/2.;\n    vec3 cameraPos = vec3(r*cos(theta)*cos(phi), r*sin(phi), r*sin(theta)*cos(phi));\n    vec3 center = vec3(0, 0, 0);\n    mat3 cameraRot = lookAt(cameraPos, center, vec3(0, 1, 0));\n\n    float fov = 45.0;\n    float screenDist = 1. / tan(fov/2.*PI/180.);\n\n    vec3 col = vec3(0);\n    for (int i=0; i<AA; i++) {\n        for (int j=0; j<AA; j++) {\n            vec2 pix = fragCoord + vec2(i, j)/float(AA);\n            vec2 uv = (2.*pix - iResolution.xy) / iResolution.y;\n            vec3 rayDir = cameraRot * normalize(vec3(uv, screenDist));\n            col += render(cameraPos, rayDir);\n        }\n    }\n    col /= float(AA*AA);\n\n    // gamma\n    col = pow(col, vec3(1./2.2));\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}