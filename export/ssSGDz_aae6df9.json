{"ver":"0.1","info":{"id":"ssSGDz","date":"1617232925","viewed":91,"name":"Box intersection with camrea","username":"Bushra","description":"Box intersection with camrea","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["boxintersectionwithcamrea"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// https://iquilezles.org/articles/boxfunctions\nvec4 iBox( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec4(-1.0);\n\n\tvec3 nor = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    // convert to ray space\n\t\n\tnor = (txi * vec4(nor,0.0)).xyz;\n\n\treturn vec4( tN, nor );\n}\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv -= 0.5;                            //set the origin middle of the screen\n    uv.x *= iResolution.x/iResolution.y;  //calculate aspect ratio\n    \n    //camera \n    vec3 ro = vec3(1.0, 1.50, -4.0);  //camera position or ray origin \n    \n    vec3 LookAt = vec3(0.5);          //Look at position\n    float zoom = 1.0;    \n    \n    //vec3 rd = vec3 rd(uv, ro, LookAt, zoom);  //calling ray direction function\n    vec3 forward = normalize(LookAt - ro);              //calculate forward, normalize return unit vector \n    vec3 right = cross (vec3(0.0, 1.0, 0.0), forward);  //y is (0.0, 1.0, 0.0,); right = y cross forward\n    vec3 up = cross (forward, right);\n    \n    vec3 c = ro + forward * zoom;          //center of the screen  \n    vec3 i = c + uv.x*right + uv.y*up;     //i is the insect point on the screen\n    \n    vec3 rd = i - ro;       //ray direction\n    \n    // rotate and translate box_proxy\t\n    float angle = 0.0;\n\tmat4 rot_proxy = rotationAxisAngle( normalize(vec3(0.0,1.0,0.0)), angle );\n\tmat4 tra_proxy = translate( 0.0, 0.0 , 0.0 );\n\tmat4 txi_proxy = tra_proxy * rot_proxy; \n\tmat4 txx_proxy = inverse( txi_proxy );\n    \n    // rotate and translate box_clip\t\n    //float angle = 0.5 * iTime;    \n    float trans = 0.5 * iTime; \n\tmat4 rot_clip = rotationAxisAngle( normalize(vec3(1.0,.0,0.0)), angle );\n\tmat4 tra_clip = translate( 0.0, 1.0 * sin(trans) , 0.0 );\n\tmat4 txi_clip = tra_clip * rot_clip; \n\tmat4 txx_clip = inverse( txi_clip );\n    \n    // raytrace\n\tfloat tmin = 10000.0;\n\n    // raytrace box\n    vec3 box_proxy = vec3(0.7,0.4,0.4) ;\n    vec3 box_clip = vec3(0.5,0.4,0.4) ;\n    \n    vec4 res_proxy = iBox( ro, rd, txx_proxy, txi_proxy, box_proxy);\n    vec4 res_clip = iBox( ro, rd, txx_clip, txi_clip, box_clip);    \n       \n    vec3 col;\n    //when clip and proxy intersect\n    if(res_proxy.x>0.0 && res_proxy.x< tmin && res_clip.x>0.0 && res_clip.x< tmin)\n    {   \n         col = vec3(1., 1., 0.); //clip and proxy\n    }\n    \n    \n     //uncomment from here to see proxy cube and clip cube both together\n     /*\n      //proxy color red\n    else if (res_proxy.x>0.0 && res_proxy.x< tmin)\n    {\n         col = vec3(1., 0., 0.); //proxy\n    }\n\n    //clip color green\n    else if (res_clip.x>0.0 && res_clip.x< tmin)\n    {\n        col = vec3(0., 1., 0.); //clip\n    }\n    */\n    \n    else{\n         col = vec3(0.0, 0.3, 0.3); //background color\n    } \n      \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}