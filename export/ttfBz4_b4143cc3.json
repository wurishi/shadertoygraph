{"ver":"0.1","info":{"id":"ttfBz4","date":"1605125260","viewed":488,"name":"Connecting to AFIG","username":"stack_overflow","description":"This shader was done for an AFIG (Association Française d’Informatique Graphique https://www.asso-afig.fr/site/) contest.\nThere is many bugs and the code is somewhat messy. Sorry, had to meet the deadline ;-)","likes":15,"published":1,"flags":40,"usePreview":1,"tags":["oldschool","afig"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n This shader is a sumbission to an AFIG (Association Francaise d'Informatique Graphique).\n shader contest. So, many part of the code is messy and done in a rush...\n\n Edit 1: Thanks to Dave_Hoskins for his improvement on the modem noise function for faking\n the Phase 3 transmission!\n*/\n\nvoid modemPerturbate(in float t0, in float totalLength, inout vec2 uv) \n{\n    float lengthStateCall, t0StateCall;\n    int call_modem_state = modemStateCall(t0, lengthStateCall, t0StateCall);\n\n    switch (call_modem_state){\n        case STATE_MODEM_CALL_WAIT0:\n        case STATE_MODEM_CALL_ACK_INIT:\n        break;\n        \n        case STATE_MODEM_CALL_CR_D:\n        case STATE_MODEM_CALL_ES_R:\n        case STATE_MODEM_CALL_CL:\n        case STATE_MODEM_CALL_ACK_MS:\n        uv.x += 0.1*noise(vec2(iTime, uv.y));    \n        if(uv.x > 1.) uv.x -= 1.;\n        break;\n        \n        case STATE_MODEM_CALL_CM:\n        uv.y = fract(10.*iTime + uv.y);\n        break;\n        \n        case STATE_MODEM_CALL_L1:\n        case STATE_MODEM_CALL_L2:\n        uv.x += .1*sin(100.*uv.y + 100.*iTime);    \n        if(uv.x > 1.) uv.x -= 1.;\n        break;\n    }\n    \n    float lengthStateRecv, t0StateRecv;\n    int recv_modem_state = modemStateRecv(t0, lengthStateRecv, t0StateRecv);\n    \n    switch (recv_modem_state){\n        case STATE_MODEM_RCV_CR_E:\n        case STATE_MODEM_RCV_MS:\n        // H deflection\n        uv.x += 0.1*noise(vec2(iTime, uv.y));    \n        if(uv.x > 1.) uv.x -= 1.;\n        break;\n        \n        case STATE_MODEM_RCV_ANSAM:\n        uv.y = mod(iTime * uv.y, 1.);\n        break;\n        \n        \n        case STATE_MODEM_RCV_JM:\n        uv.y += max(0.5 - 2. * iTime, 0.) * fract(1.3*iTime);\n        if(uv.y > 1.) uv.y -= 1.;\n        break;\n        \n        case STATE_MODEM_RCV_L1:\n        case STATE_MODEM_RCV_L2:\n        case STATE_MODEM_RCV_A0:\n        case STATE_MODEM_RCV_A1:\n        uv.y += .1*sin(100.*uv.x + 100.*iTime);    \n        if(uv.y > 1.) uv.y -= 1.;\n        break;\n        \n        \n        case STATE_MODEM_RCV_INFO0_A:\n        case STATE_MODEM_RCV_INFO1_A:\n        uv.y += 0.1*noise(vec2(iTime, uv.y));    \n        if(uv.y > 1.) uv.y -= 1.;\n        break;\n        \n\n        case STATE_MODEM_RCV_P3:\n        vec2 uv_noise = uv;\n        uv_noise.x += 0.5*noise(vec2(iTime, uv_noise.y));\n        uv_noise.y += 0.5*noise(vec2(2.*iTime, uv_noise.x));\n        uv = mix(uv_noise, uv, smoothstep(0., totalLength, t0));\n        break;\n    }\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Which state are we in?\n    float lengthState, t0;\n    int storyState = storyboardState(iTime, lengthState, t0);\n\n    float wave_value;\n    switch (storyState) {\n        case STATE_TONE:        \n        // Effect: Screen powering\n        uv = uv - vec2(0.5);\n        float v = exp(-2.0*iTime);\n        uv.y /= 1. - v;\n        uv = uv + vec2(0.5);\n\n        // Effect: V-sync\n        uv.y += max(0.5 - 0.5 * iTime, 0.) * fract(1.3*iTime);\n        if(uv.y > 1.) uv.y -= 1.;\n\n\n        fragColor = (1.+10.*v) *texture(iChannel0, uv);\n        return;\n\n\n        case STATE_DIALING:\n        case STATE_WAITING:\n        break;\n\n\n        case STATE_MODEM:\n        modemPerturbate(t0, lengthState, uv);\n        break;\n\n    }\n\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n Tweaking section\n ================\n\n Some global variables for configuring the shader\n*/\n\n// The phone number we compose with DTMF tones\nconst int number[] = int[](0, 8, 8, 7, 5, 3, 2, 5, 5, 1);\n\n// Raymarch params\nconst int N_STEPS = 500;\nconst float MAX_DIST = 200.;\nconst float MIN_DIST = 0.001;\n\n\n/*\n Storyboard\n ==========\n\n 1 - Init sequence\n -----------------\n\n - TONE: Just standard French dial tone\n - DIALING: DTMF dialing to a remote modem\n - WAITING: Nothing happen... waiting for the modem to answer\n\n During this sequence, we display a waveform of the emitted sounds.\n\n\n 2 - Modem dialog sequence\n -------------------------\n\n We display the AFIG logo in a retro fashion manner. We distord the\n logo in screen space depending on the current modem status.\n\n\n 3 - Connection established\n --------------------------\n\n Hurra! we have our connection to our remote super server. Some might\n say later on this is the latest cutting edge SGI station. But don't \n be tricked. This is only a shadetoy.\n\n For now on, we rotate on a very hacky way the logo because why not?\n\n\n 4 - 2D logo blending\n --------------------\n\n Mutate the logo to a \"textured\" logo with a checkerboard. Because,\n it used to be cool. Why they aren't that popular anymore?\n\n\n 5 - Bouncing ball\n -----------------\n\n We finally might have an Amiga? Tansition to a bouncing ball\n\n \n 6 - Raymarching\n ---------------\n\n This part is probably the most buggy... Was done on rush. Basically, \n one simple raymarching scene then, changing to a reflective logo with\n a sky model (Hosek and Wilkie).\n\n You're still reading? ;-)\n\n*/\n\nconst int  STATE_TONE                   = 0;\nconst int  STATE_DIALING                = 1;\nconst int  STATE_WAITING                = 2;\nconst int  STATE_MODEM                  = 3;\nconst int  STATE_CONNECTED              = 4;\nconst int  STATE_TRANSFORM_CHECKERBOARD = 5;\nconst int  STATE_TRANSITION_BALL        = 6;\nconst int  STATE_TRANSITION_BOUNCING    = 7;\nconst int  STATE_ZOOM_OUT_BOUNCING      = 8;\nconst int  STATE_BOUNCING               = 9;\nconst int  STATE_FADE_OUT_BOUNCING      = 10;\nconst int  STATE_TRANSITION_RAYMARCH    = 11;\nconst int  STATE_ZOOM_OUT_RAYMARCH      = 12;\nconst int  STATE_RAYMARCH_LAMBERT       = 13;\nconst int  STATE_RAYMARCH_LAMBERT_ROT   = 14;\nconst int  STATE_TRANSITION_HOSEK       = 15;\nconst int  STATE_RAYMARCH_HOSEK         = 16;\n\n\nconst float duration_state[] = float[]\n    (2.,  // STATE_TONE\t\t\t\t\t\t0\n     2.,  // STATE_DIALING\t\t\t\t\t1\n     1.,  // STATE_WAITING\t\t\t\t\t2\n     15., // STATE_MODEM\t\t\t\t\t3\n     5.,  // STATE_CONNECTED\t\t\t\t4\n     5.,  // STATE_TRANSFORM_CHECKERBOARD \t5\n     3.,  // STATE_TRANSITION_BALL\t\t\t6\n     2.,  // STATE_TRANSITION_BOUNCING\t\t7\n     3.,  // STATE_ZOOM_OUT_BOUNCING\t\t8\n     20., // STATE_BOUNCING\t\t\t\t\t9\n     2.,  // STATE_FADE_OUT_BOUNCING\t\t10\n     2.,  // STATE_TRANSITION_RAYMARCH      11\n     2.,  // STATE_ZOOM_OUT_RAYMARCH\t\t12\n     1.,  // STATE_RAYMARCH_LAMBERT\t\t\t13\n     3.,  // STATE_RAYMARCH_LAMBERT_ROT\t\t14\n     4.,  // STATE_TRANSITION_HOSEK\t\t\t15\n     1.   // STATE_RAYMARCH_HOSEK\t\t\t16\n    );\n\nint storyboardState(in float time, out float duration, out float t0) \n{\n\n    float prev_duration = 0.;\n\n    for (int i = 0; i <= STATE_RAYMARCH_HOSEK; i++) {\n        t0 = time - prev_duration;\n        duration  = duration_state[i];\n        prev_duration += duration;\n\n\n        if (time < prev_duration) {\n            return i;\n        }\n    }\n\n    //t0 = time - prev_duration;\n    return STATE_RAYMARCH_HOSEK;\n}\n\n\n/*\n Modem sequence\n ==============\n\n To ease keep track of the dialog between remote and local modemes, we\n have a similar function as the storyboard. This helps adding some cool\n effects on the displayed image.\n\n Note at the current state of the code, we do not use (while we should)\n this state in the sound shader. Would be much nicer... but no time for\n refactoring and doing everything right ;-)\n\n Timings are probably full of mistakes here and there.\n\n\n Standard sequence\n -----------------\n\n RECV                 T (ms)          CALL\n\n ┌───────────────────────────    0                                  ─┐\n │ INIT (400ms)                                                      │\n ├───────────────────────────   400   ────────────────────────────┐  │\n │ CR_e (100ms)                        ACK INIT (400 ms)          │  │\n └───────────────────────────   500                               │  │\n                .                                                 │  │\n                .               800   ────────────────────────────┤  │\n                .                      CR_d (100 ms)              │  │\n                .               900   ────────────────────────────┤  │\n                .                      ES_r (100 ms)              │  │\n                .               1000  ────────────────────────────┤  │\n                .                      CL (~586 ms)               │  │\n ┌────────────────────────────  1500    nbits(176)/bitrate(300bps)│  │ Phase 1\n │ MS (640 ms)                                                    │  │\n │  nbits(192)/bitrate)                                           │  │\n └────────────────────────────  2240  ────────────────────────────┤  │\n                .                      ACK MS [c1] (~190ms)       │  │\n                .                       nbits(56)/bitrate         │  │\n                .               2430  ────────────────────────────┘  │\n                .                                  .                 │\n ┌────────────────────────────  3430               .                 │\n │ ANSam (2 s)                                     .                 │\n └────────────────────────────  4430  ────────────────────────────┐  │\n                .                      CM ( 1800 ms: 6*90/300)    │  │\n ┌────────────────────────────  5430                              │  │\n │ JM(900ms:3*90/300)                                             │  │\n │                              6230  ────────────────────────────┤  │\n │                                      CJ () (I don't have data) │  └────────\n ├─────────┬──────────────────  6330  ────────────────────────────┤ ─┐\n │ Guard   │ INFO0_a (49bits)          INFO0_c (48bits)           │  │\n │         ├──────────────────  6412  ────────────────────────────┤  │\n │         │ A       (150 ms)          B                          │  │\n ├─────────┴──────────────────  6562  ────────────────────────────┘  │\n │ L1 (150 ms)                                     .                 │\n ├────────────────────────────  6712               .                 │\n │ L2 (550 ms)                                     .                 │\n ├─────────┬──────────────────  7262  ────────────────────────────┐  │ Phase 2\n │ Guard   │  A                        B                          │  │\n └─────────┴──────────────────  7362  ────────────────────────────┤  │\n                .                      L1 (150 ms)                │  │\n                .               7512  ────────────────────────────┤  │\n                .                      L2 (550 ms)                │  │\n ┌─────────┬──────────────────  8062  ────────────────────────────┤  │\n │ Guard   │  A                        INFO1_c                    │  │\n │         ├──────────────────  8144  ────────────────────────────┘  │\n │         │ INFO1_a                               .                 └────────\n ├─────────┴──────────────────  8226               .                ─┐\n │ S                                               .                 │\n ├────────────────────────────                     .                 │\n │ PP                                              .                 │\n ├────────────────────────────                     .                 │\n │ TRN                                             .                 │\n └────────────────────────────        ────────────────────────────┐  │ Phase 3\n                                       S                          │  │\n                                      ────────────────────────────┤  │\n                                       PP                         │  │\n                                      ────────────────────────────┤  │\n                                       TRN                        │  │\n                                      ────────────────────────────┘  └──────── \n\n See\n ---\n - https://www.itu.int/itu-t/recommendations/index.aspx?ser=V\n - https://oona.windytan.com/posters/dialup-final.png\n - http://what-when-how.com/voip/fax-and-modem-tones-basics-voip/\n*/\n\nconst int  STATE_MODEM_RCV_INIT       = 0;\nconst int  STATE_MODEM_RCV_CR_E       = 1;\nconst int  STATE_MODEM_RCV_WAIT0      = 2;\nconst int  STATE_MODEM_RCV_MS         = 3;\nconst int  STATE_MODEM_RCV_WAIT1      = 4;\nconst int  STATE_MODEM_RCV_ANSAM      = 5;\nconst int  STATE_MODEM_RCV_WAIT2      = 6;\nconst int  STATE_MODEM_RCV_JM         = 7;\nconst int  STATE_MODEM_RCV_INFO0_A    = 8;\nconst int  STATE_MODEM_RCV_A0         = 9;\nconst int  STATE_MODEM_RCV_L1         = 10;\nconst int  STATE_MODEM_RCV_L2         = 11;\nconst int  STATE_MODEM_RCV_A1         = 12;\nconst int  STATE_MODEM_RCV_INFO1_A    = 13;\nconst int  STATE_MODEM_RCV_WAIT3      = 14;\nconst int  STATE_MODEM_RCV_P3         = 15;\n\n\nint modemStateRecv(in float time, out float duration, out float t0) {\n    const float rcv_duration[] = float[]\n        (.4,    \t\t// INIT\t\t\t\t// 0\n         .1,    \t\t// RC_e\t\t\t\t// 1\n         1.,   \t\t\t// -- wait --\t\t// 2\n         192./300.,   \t// MS \t\t\t\t// 3\n         56.0/300.+1.,  // -- wait --\t\t// 4\n         2.,    \t\t// ANSam\t\t\t// 5\n         1.,    \t\t// -- wait --\t\t// 6\n         3.*90./300.,   // JM\t\t\t\t// 7\n         49./300.,  \t// INFO0_a + Guard\t// 8\n         .15,   \t\t// A + Guard\t\t// 9\n         .15,   \t\t// L1\t\t\t\t// 10\n         .55,   \t\t// L2\t\t\t\t// 11\n         .15,  \t\t\t// A + Guard\t\t// 12\n         49./300.//,  \t// INFO1_a + Guard\t// 13\n         //.7     \t\t// -- wait --\t\t// 14\n        );\n\n    float prev_duration = 0.;\n\n    for (int i = 0; i <= STATE_MODEM_RCV_INFO1_A; i++) {\n        duration = rcv_duration[i];\n        t0 = time - prev_duration;\n        prev_duration += duration;\n\n        if (time < prev_duration) {\n            return i;\n        }\n    }\n\n    t0 = time - prev_duration;\n    return STATE_MODEM_RCV_P3;\n}\n\n\nconst int  STATE_MODEM_CALL_WAIT0     = 0;\nconst int  STATE_MODEM_CALL_ACK_INIT  = 1;\nconst int  STATE_MODEM_CALL_CR_D      = 2;\nconst int  STATE_MODEM_CALL_ES_R      = 3;\nconst int  STATE_MODEM_CALL_CL        = 4;\nconst int  STATE_MODEM_CALL_ACK_MS    = 5;\nconst int  STATE_MODEM_CALL_WAIT1     = 6;\nconst int  STATE_MODEM_CALL_CM        = 7;\nconst int  STATE_MODEM_CALL_CJ        = 8;\nconst int  STATE_MODEM_CALL_INFO0_C   = 9;\nconst int  STATE_MODEM_CALL_B0        = 10;\nconst int  STATE_MODEM_CALL_WAIT2     = 11;\nconst int  STATE_MODEM_CALL_B1        = 12;\nconst int  STATE_MODEM_CALL_L1        = 13;\nconst int  STATE_MODEM_CALL_L2        = 14;\nconst int  STATE_MODEM_CALL_INFO1_C   = 15;\nconst int  STATE_MODEM_CALL_P3        = 16;\n\n\nint modemStateCall(in float time, out float duration, out float t0) {\n    const float call_duration[] = float[]\n        (.4,    \t\t// -- wait -- \t\t// 0\n         .4,    \t\t// ACK INIT\t\t\t// 1\n         .1,    \t\t// CR_d\t\t\t\t// 2\n         .1,    \t\t// ES_r\t\t\t\t// 3 \n         176./300., \t// CL\t\t\t\t// 4\n         56./300.,  \t// ACK MS\t\t\t// 5\n         2.,    \t\t// -- wait --\t\t// 6\n         6.*90./300.,\t// CM\t\t\t\t// 7\n         .1,    \t\t// CJ\t\t\t\t// 8\n         48./300.,   \t// INFO0_c\t\t\t// 9\n         .15,   \t\t// B\t\t\t\t// 10\n         .7,    \t\t// -- wait --\t\t// 11\n         .1,    \t\t// B\t\t\t\t// 12\n         .15,   \t\t// L1\t\t\t\t// 13\n         .55,   \t\t// L2\t\t\t\t// 14\n         .082   \t\t// INFO1_c\t\t\t// 15\n        );\n\n\n    float prev_duration = 0.;\n\n    for (int i = 0; i <= STATE_MODEM_CALL_INFO1_C; i++) {\n        duration = call_duration[i];\n        t0 = time - prev_duration;\n        prev_duration += duration;\n\n        if (time < prev_duration) {\n            return i;\n        }\n    }\n\n    t0 = time - prev_duration;\n    return STATE_MODEM_CALL_P3;\n}\n\n\n/*\n Sound utility functions\n =======================\n\n Both used in fragment and sound shaders for scope display.\n*/\n\nfloat wave(in float freq, in float t) {\n    return sin(6.2831*freq*t);\n}\n\n\nfloat wave_shift(in float freq, in float t, in float shift) {\n    return sin(6.2831*freq*t + shift);\n}\n\n\nfloat dtmf(in int i, in float time) {\n    int col = (i - 1) % 3;\n    int row = (i - 1) / 3;\n\n    const float c[3] = float[](1209., 1336., 1477.);\n    const float r[3] = float[](697., 770., 852.);\n\n    if (i == 0) {\n        return wave(c[1], time) + wave(941.0, time);\n    }\n\n    return wave(c[col], time) + wave(r[row], time);\n}\n\n\nfloat dial(in int number[10], float t0, float duration) {\n    float delta = duration / 10.;\n    float idx   = t0 / delta;\n\n    // duty cycle\n    if (fract(idx) < 0.7) {\n        return 0.2*dtmf(number[int(idx)], t0);\n    }\n\n    return 0.;   \n}\n\n\nfloat dial2(in int number[10], float x, float t0, float duration) {\n    float delta = duration / 10.;\n    float idx   = t0 / delta;\n\n    // duty cycle\n    if (fract(idx) < 0.7) {\n        return dtmf(number[int(idx)], x);\n    }\n\n    return 0.;   \n}\n\n\n/*\n 2D Geometry functions\n =====================\n*/\n\nvec2 sphereUV(vec3 sphere_normal)\n{\n    vec2 uv = vec2(0.5 + atan(sphere_normal.x, sphere_normal.z) / (2. * 3.14),\n                   0.5 - asin(sphere_normal.y) / 3.14);\n\n    return uv;\n}\n\n\n\nvec3 checkerboardTexture(in vec2 uv) \n{\n    float lines = 16.0;\n    float cols = 16.0;\n\n    uv = vec2(cols, lines) * uv;\n\n    vec3 col;\n    if (mod(uv.x + floor(mod(uv.y, 2.0)), 2.0) < 1.0) {\n        col = vec3(1.0, 0., 0.0);\n    } else {\n        col = vec3(1.0);\n    }\n    return col;\n}\n\n\nvec3 grid(in vec2 uv, \n          in float rows, in float cols, \n          in float weight_x, in float weight_y) \n{    \n    uv = vec2(cols, rows) * uv;\n\n    if (fract(mod(uv.x, (cols))) <= weight_x) { return vec3(0, 0, 1.); }\n    if (fract(mod(uv.y, (rows))) <= weight_y) { return vec3(0, 0, 1.); }\n    return vec3(0.8);\n}\n\n\n// https://www.shadertoy.com/view/4tlBDH\nfloat noise(vec2 p)\n{\n    return fract(dot(sin(p.x * 123.12)*142.,cos(p.y *34.95)*165.47));\n}\n\n\n\n// 2D circles are defined such as\n// c.xy = position in 2D space\n// c.z  = radius\n\nbool isOnCircle(in vec3 c, in vec2 uv, in float width) {\n    uv -= c.xy;    \n    return abs(length(uv) - c.z) < width;\n}\n\n\nbool isInCircle(in vec3 c, in vec2 uv) {\n    uv -= c.xy;    \n    return length(uv) < c.z;\n}\n\n\nvec3 getSphereNormal(in vec3 c, in vec2 uv) {\n    vec3 normal = vec3(uv - c.xy, 0.);\n    normal.z = sqrt(c.z*c.z - length(normal.xy)*length(normal.xy));\n    normal = normalize(normal);\n    return normal;\n}\n\n// 2D lines are defined such as\n// l.xy = position in 2D space\n// l.z  = angle in radians\n\nbool isOnLine(in vec3 l, in vec2 uv, in float width) {\n    float c = cos(l.z);\n    float s = sin(l.z);\n\n    uv += l.xy;\n\n    vec2 localLine = \n        vec2(\n            c * uv.x + s * uv.y,\n            -s * uv.x + c * uv.y);\n\n    float d = localLine.x - (l.x);\n\n    return abs(d) < width;\n}\n\n\nbool isOnWave(in float freq, in vec2 uv) {\n    float t = wave(freq, uv.x/500.);\n\n    //t = (t + 1.0) / 2.;\n\n    return (abs(t - uv.y) < 0.01);\n}\n\n\nbool isOnAfigLogo(in vec2 uv, in float aspect) \n{\n    // Tracing line width\n    const float d = .01;\n\n\n    uv = 2. * uv - vec2(1.);\n    uv.x *= aspect;\n\n    // Translate / scale\n    uv.y -= 0.2;\n    uv *= 1.2;\n\n    const vec3 c0 = vec3(0., 0., .8);   // Outer ring\n    const vec3 c1 = vec3(0., 0., .6);   // Inner ring\n\n    const float avg = .5;//(c0.z + c1.z) / 2.;\n\n    const vec3 c2_out = vec3(avg, -avg, 0.3);    // Larger bubble outside\n    const vec3 c2_in  = vec3(avg, -avg, c2_out.z - 3.*d);    // Larger bubble inside\n    const vec3 c2_in_in  = vec3(avg, -avg, c2_in.z - d);    // Larger bubble inside\n\n    const vec3 c3 = vec3(c2_in.xy * 1.9, 0.15); // Smaller bubble\n\n    // Diagonal lines\n    const vec3 l0 = vec3(0., 0., 3.14/4.);\n    const vec3 l1 = vec3(0., 0., -3.14/4.);\n\n    // This code can be much more optimized...\n\n     // Larger bubble\n\n    if (isOnCircle(c2_in, uv, d)) { return true; }\n\n    // Mask for larger bubble -> outline\n    if (isInCircle(c2_out, uv)) {\n        return false;   \n    }\n\n    // Smaller bubble\n\n    if (isOnCircle(c3, uv, d))    { return true; }\n\n    // Intersection Larger bubble & ring\n    if (   isInCircle(c0, uv) && !isInCircle(c1, uv)\n        && isOnCircle(c2_out, uv, d) ) {\n        return true;   \n    }\n\n    // Main logo\n\n    // Lines cut\n    const float cutWidth = .03;\n\n    if ( isOnLine(l0, uv, cutWidth) || isOnLine(l1, uv, cutWidth)) {\n        return false;\n    }\n\n    if (  isInCircle(c0, uv) && !isInCircle(c1, uv)\n        && (isOnLine(l0, uv, cutWidth + 2.*d) || isOnLine(l1, uv, cutWidth + 2.*d))) {\n        return true;\n    }\n\n    return isOnCircle(c0, uv, d) || isOnCircle(c1, uv, d);\n}\n\n\nbool isInAfigLogo(in vec2 uv, float aspect, out vec2 texCoords) \n{\n    // Tracing line width\n    const float d = .01;\n\n    texCoords = uv;\n    texCoords.x *= aspect;\n\n    uv = 2. * uv - vec2(1.);\n    uv.x *= aspect;\n\n    // Translate / scale\n    uv.y -= 0.2;\n    uv *= 1.2;\n\n    const vec3 c0 = vec3(0., 0., .8);   // Outer ring\n    const vec3 c1 = vec3(0., 0., .6);   // Inner ring\n\n    const float avg = .5;//(c0.z + c1.z) / 2.;\n\n    const vec3 c2_out = vec3(avg, -avg, 0.3);    // Larger bubble outside\n    const vec3 c2_in  = vec3(avg, -avg, c2_out.z - 3.*d);    // Larger bubble inside\n    const vec3 c3 = vec3(c2_in.xy * 1.9, 0.15); // Smaller bubble\n\n    // Diagonal lines\n    const vec3 l0 = vec3(0., 0., 3.14/4.);\n    const vec3 l1 = vec3(0., 0., -3.14/4.);\n\n    // This code can be much more optimized...\n\n    // Larger bubble\n\n    // Mask for larger bubble -> outline\n    if (isInCircle(c2_out, uv) && !isInCircle(c2_in, uv)) {\n        return false;   \n    }\n\n    if (isInCircle(c2_in, uv)) { \n        vec3 normal = getSphereNormal(c2_in, uv);\n        texCoords = sphereUV(normal);\n        return true;\n    }\n\n    // Smaller bubble\n    \n    if (isInCircle(c3, uv))    { \n        vec3 normal = getSphereNormal(c3, uv);\n        texCoords = sphereUV(normal);\n        return true; \n    }\n\n    // Intersection Larger bubble & ring\n    if (   isInCircle(c0, uv) && !isInCircle(c1, uv)\n        && isOnCircle(c2_out, uv, d) ) {\n        return true;   \n    }\n\n    // Main logo\n\n    // Lines cut\n    const float cutWidth = .03;\n\n    if ( isOnLine(l0, uv, cutWidth) || isOnLine(l1, uv, cutWidth)) {\n        return false;\n    }\n\n    if (isInCircle(c0, uv) && !isInCircle(c1, uv)) {\n        return true;\n    }\n\n    return false;\n}\n\n\n\n/*\n \n Raymarching\n ===========\n*/\n\nstruct ray_t {\n    vec3 origin;\n    vec3 direction;\n};\n\n\nray_t camera(in vec3 pos, in vec3 target, in float fov, in vec2 uv, in float aspect)\n{    \n    float theta = fov * 3.14/180.0;\n    float h_height = tan(theta/2.0);\n    float h_width =  h_height * aspect;\n    \n    vec3 w = normalize(pos - target);\n    vec3 u = normalize(cross(vec3(0., 1., 0.), w));\n    vec3 v = cross(w, u);\n    \n    vec3 ll = pos - h_width*u - h_height*v - w;\n    vec3 horizontal = 2.0 * h_width*u;\n    vec3 vertical = 2.0 * h_height*v;\n    \n    \n    return ray_t(\n        pos,\n        normalize(ll + uv.x*horizontal + uv.y*vertical - pos)\n        );\n        //normalize(vec3(uv.x, uv.y, 1.)));\n}\n\n\nfloat checkersTexture(in vec2 p)\n{\n    vec2 q = floor(p);\n    return mod( q.x+q.y, 2.0 );            // xor pattern\n}\n\n\n\n\n// The MIT License\n// Copyright © 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Similar to https://www.shadertoy.com/view/XlXBWs, but with a triangular filter kernel,\n// which produces less flickering animations that a box filter. Luckily, it's still easily\n// integrable analytically! Full description in this article:\n//\n// https://iquilezles.org/articles/checkerfiltering\n//\n// Inspired by http://http.developer.nvidia.com/GPUGems/gpugems_ch25.html and improved\n\n  \n// checker, 2D, box filter: https://www.shadertoy.com/view/XlcSz2\n// checker, 3D, box filter: https://www.shadertoy.com/view/XlXBWs\n// checker, 3D, tri filter: https://www.shadertoy.com/view/llffWs\n// grid,    2D, box filter: https://www.shadertoy.com/view/XtBfzz\n// xor,     2D, box filter: https://www.shadertoy.com/view/tdBXRW\n\n// --- analytically box-filtered checkerboard ---\n// https://www.shadertoy.com/view/XlcSz2\n\nvec3 checkersTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n    // filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;  \n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)/2.0)-0.5)-abs(fract((p+0.5*w)/2.0)-0.5))/w;\n    // xor pattern\n    float v = 0.5 - 0.5*i.x*i.y;\n    \n    return v * vec3(0.1) + vec3(0.8);\n}\n\n\n// https://iquilezles.org/articles/distfunctions\nfloat opSubtraction(float d1, float d2) { return max(-d1,d2); }\n\n\nfloat sdCylinder(vec3 p, float l, float L) \n{\n    return max(length(p.yx) - l, abs(p).z - L);\n}\n\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdSphere(vec3 p, float s)\n{\n    return length(p)-s;\n}\n\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n    float d = 0.6;\n\n    vec2 q = vec2(length(p.xy)-t.x, p.z);\n    float l1 = length(q)-t.y;\n    float l2 = sdSphere(p - vec3(.5, -.6, 0), 0.35);\n\n    return opSubtraction(l2, l1);\n}\n\n\nfloat sdGround(in vec3 pos) \n{\n    //if (abs(pos.y) < MIN_DIST) { return -1.; }\n    return abs(pos.y);\n}\n\n\nfloat sdScene(in vec3 pos, in mat3 rot_logo, out vec3 col) \n{\n    vec3 orig = pos;\n    pos -= vec3(0., 2., 0.);\n    pos *= rot_logo;\n\n    const float angle = 3.14/4.;\n    const float cAngle = cos(angle);\n    const float sAngle = sin(angle);\n\n    const mat3 m45d = mat3(\n        cAngle , sAngle, 0,\n        -sAngle, cAngle, 0,\n        0, 0, 1);\n\n    const mat3 m45b = mat3(\n        cAngle, -sAngle, 0,\n        sAngle, cAngle, 0,\n        0, 0, 1);\n\n    float objects[4] = float[](\n        opSubtraction(\n            min(\n                sdBox((pos - vec3(.0, 0.1, 0.6)) * m45d, vec3(1.2, 0.1, 1.5)),\n                sdBox((pos - vec3(.0, 0.1, 0.6)) * m45b, vec3(1.2, 0.1, 1.5))),\n            opSubtraction(\n                sdCylinder(pos - vec3(.5, -.5, 0), .35, .8), \n                opSubtraction(\n                    sdCylinder(pos - vec3(0., 0.1, 0), .6, .8), \n                    sdCylinder(pos - vec3(0., 0.1, 0), 1., .1)\n                )\n            )\n        ),\n        sdSphere(pos - vec3(.5, -.5, 0), 0.3),\n        sdSphere(pos - vec3(.5*1.9, -.5*1.9, 0), 0.15),\n        //sdSphere(orig - vec3(0., -1000., 0.), 1000.)\n        sdGround(orig - vec3(0, .0, 0.))\n    );\n\n    vec3 colors[4] = vec3[](vec3(1., 0., 0.), vec3(0., 1., 0.), vec3(0., 0., 1.), vec3(1., 1., 0.));\n\n    float d_min = MAX_DIST;//objects[0];\n    int idx_min = 0;\n\n    for (int i = 0; i < 4; i++) {\n        if (d_min > objects[i]) {\n            d_min = objects[i];\n            idx_min = i;\n        }\n    }\n\n    col = colors[idx_min];\n\n    switch (idx_min)\n    {\n        case 0:\n        if ((-pos.x + pos.y) < 0.) {\n            col = vec3(0., .5, 0.);\n        } else {\n            col = vec3(.5);\n        }\n        break;\n\n        case 1:\n        case 2:\n        col = vec3(0., 1., 0.);\n        break;\n\n        case 3:\n        vec2 uv = 1.*orig.xz;\n        \n\t\tvec2 ddx_uvw = dFdx(uv); \n        vec2 ddy_uvw = dFdy(uv); \n\n        //col = vec3(checkersTexture(uv));\n        col = checkersTextureGradBox(uv, ddx_uvw, ddy_uvw);\n        break;\n    }\n\n    return d_min;\n}\n\n/*\nvec3 getNormal(in vec3 p, in mat3 rot_logo) {\n    vec3 c;\n    vec2 e = vec2(.0001, 0.);\n\n    return normalize( \n        vec3(sdScene(p+e.xyy, rot_logo, c) - sdScene(p-e.xyy, rot_logo, c),\n             sdScene(p+e.yxy, rot_logo, c) - sdScene(p-e.yxy, rot_logo, c),\n             sdScene(p+e.yyx, rot_logo, c) - sdScene(p-e.yyx, rot_logo, c) ) );\n\n}\n*/\n\nvec3 getNormal( in vec3  p, in mat3 rot_logo ) // for function f(p)\n{\n    //if (p.y < MIN_DIST*2.) return vec3(0., 1., 0.);\n    vec3 c;\n\tconst float h = 0.01; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sdScene( p + k.xyy*h, rot_logo, c ) + \n                      k.yyx*sdScene( p + k.yyx*h, rot_logo, c ) + \n                      k.yxy*sdScene( p + k.yxy*h, rot_logo, c ) + \n                      k.xxx*sdScene( p + k.xxx*h, rot_logo, c ) );\n}\n\n\nfloat rayMarch(in ray_t ray, in mat3 rot_logo, out vec3 col) {  \n    float dist = 0.;\n    vec3 pos;\n\n    int i;\n    for (i = 0; i <= N_STEPS; i++) {\n        pos = ray.origin + dist * ray.direction;\n\n        dist += sdScene(pos, rot_logo, col);\n\n        if (dist < MIN_DIST)\n            return dist;\n\n        if (dist > MAX_DIST) {\n            return -1.f;\n        }\n    }\n\n    if (i == N_STEPS) return -1.f;\n\n    return dist;\n}\n\n/*\n Skydome\n =======\n\n This is highly untested code... have to be done on time.\n\n It is taking the implementation of the analytical skylight and\n solar radiance models presented in the SIGGRAPH 2012 paper\n\n\n \"An Analytic Model for Full Spectral Sky-Dome Radiance\"\n\n and the 2013 IEEE CG&A paper\n\n \"Adding a Solar Radiance Function to the Hosek Skylight Model\"\n\n both by \n\n Lukas Hosek and Alexander Wilkie\n Charles University in Prague, Czech Republic\n\n\n It is using the albedo 0 and turbidity 1 coefficients from the\n code provided by the authors.\n\n You can get the code (3-clause BSD license) from there:\n https://cgg.mff.cuni.cz/projects/SkylightModelling/\n*/\n\nvec3 hosek_rgb[] = vec3[](\n    vec3(-1.099459e+000, -1.140530e+000, -1.372629e+000),\n    vec3(-1.335146e-001, -1.982747e-001, -4.905585e-001),\n    vec3(-4.083223e+000, -7.512730e+000, -4.100789e+001),\n    vec3(5.919603e+000, 8.403899e+000, 4.122169e+001),\n    vec3(-1.104166e-001, -5.699038e-002, -7.389360e-003),\n    vec3(1.600158e+000, 9.015907e-001, 4.839359e-001),\n    vec3(-1.326538e-006, 3.392161e-002, 6.474757e-003),\n    vec3(4.917807e+000, 4.772522e+000, 3.471755e+000),\n    vec3(5.127716e-001, 5.111184e-001, 5.092936e-001),\n    vec3(-1.169858e+000, -1.165117e+000, -1.523025e+000),\n    vec3(-1.832793e-001, -1.852955e-001, -6.497084e-001),\n    vec3(9.694744e-001, 2.963684e+000, 6.249857e+000),\n    vec3(9.495762e-002, -2.262274e+000, -5.662543e+000),\n    vec3(-4.738918e-002, -1.571683e-001, -1.908402e-002),\n    vec3(2.194171e-001, 6.339974e-001, 5.512810e-001),\n    vec3(1.095749e-001, 4.977879e-002, -2.181049e-005),\n    vec3(3.603604e+000, 7.243307e+000, 2.507663e+000),\n    vec3(3.815119e-001, 4.220053e-001, 4.339598e-001),\n    vec3(-9.665225e-001, -1.169936e+000, -1.035567e+000),\n    vec3(-1.403888e-001, -3.357429e-001, -7.478740e-002),\n    vec3(5.194457e+000, 1.911291e+000, 9.221030e-001),\n    vec3(-1.107607e+000, -2.391074e-001, -2.140047e+000),\n    vec3(-8.135181e-001, -4.791643e-001, -2.374146e-002),\n    vec3(4.969661e+000, 1.446113e+000, 3.795517e-001),\n    vec3(-2.300508e-001, -9.178108e-002, -1.769134e-002),\n    vec3(-2.489350e+000, -4.700239e+000, 7.479831e+000),\n    vec3(1.279158e+000, 8.096219e-001, 7.729303e-001),\n    vec3(-1.292508e+000, -1.060246e+000, -1.271086e+000),\n    vec3(-1.299552e-001, -1.051633e-001, -5.588190e-001),\n    vec3(-2.071404e+000, 5.013829e-001, 6.908023e-001),\n    vec3(-4.752482e-002, 2.832309e+000, 2.096832e+000),\n    vec3(1.215598e+000, -3.707855e-001, -2.453967e-001),\n    vec3(-1.904179e+000, 1.523131e+000, 1.410648e+000),\n    vec3(3.027985e-001, 9.163749e-002, 4.475036e-002),\n    vec3(8.707768e+000, 5.604183e+000, -4.719115e+000),\n    vec3(6.332446e-002, 7.208566e-001, 5.741186e-001),\n    vec3(-9.264666e-001, -1.089753e+000, -9.712598e-001),\n    vec3(-1.696780e-001, -2.382167e-001, -7.033926e-002),\n    vec3(4.574070e+000, 2.360312e+000, 9.167274e-001),\n    vec3(-4.232936e-001, -5.902562e+000, -9.502097e-001),\n    vec3(-7.575833e+000, -8.799894e+000, 3.004684e-001),\n    vec3(5.079755e+000, 1.377692e+000, 4.547054e-001),\n    vec3(-2.576343e-001, -6.131633e-002, -5.929017e-002),\n    vec3(-4.506805e+000, -1.415472e+000, 5.266196e+000),\n    vec3(6.908129e-001, 6.124057e-001, 7.204135e-001),\n    vec3(-1.139072e+000, -1.075481e+000, -1.087457e+000),\n    vec3(-1.796056e-001, -1.242391e-001, -1.888896e-001),\n    vec3(1.923311e+000, 1.425781e+000, 8.156686e-001),\n    vec3(6.788529e+000, 8.810319e+000, 3.101712e-001),\n    vec3(-2.364389e+000, -2.922646e+000, -2.155419e+000),\n    vec3(-1.064041e+000, 1.486520e+000, 1.422205e+000),\n    vec3(1.717010e-001, 3.270580e-002, 9.692261e-002),\n    vec3(1.534681e+000, 3.889783e+000, 3.122404e+000),\n    vec3(5.015810e-001, 4.999482e-001, 4.999430e-001));\n\n\nvec3 hosek_rad[] = vec3[](\n    vec3(1.962684e+000, 1.590330e+000, 9.926518e-001),\n    vec3(1.159831e+000, 1.355401e+000, 1.999494e+000),\n    vec3(4.450588e+000, 1.151412e+000, -4.136109e+000),\n    vec3(5.079633e+000, 1.359116e+001, 1.856270e+001),\n    vec3(4.437388e+000, 5.857714e+000, 1.351028e+001),\n    vec3(4.324573e+000, 8.090833e+000, 1.390238e+001));\n\n\nvoid getCoefs(float solar_elevation, out vec3 config[9]) \n{\n    solar_elevation = pow(solar_elevation / (3.14 / 2.0), (1.0 / 3.0));\n\n    // albedo 0 & turbidity 1\n    for (int i = 0; i < 9; i++) {\n        config[i] = pow(1.0-solar_elevation, 5.0) * hosek_rgb[i]  + \n            5.0  * pow(1.0-solar_elevation, 4.0) * solar_elevation * hosek_rgb[i+9] +\n            10.0*pow(1.0-solar_elevation, 3.0)*pow(solar_elevation, 2.0) * hosek_rgb[i+18] +\n            10.0*pow(1.0-solar_elevation, 2.0)*pow(solar_elevation, 3.0) * hosek_rgb[i+27] +\n            5.0*(1.0-solar_elevation)*pow(solar_elevation, 4.0) * hosek_rgb[i+36] +\n            pow(solar_elevation, 5.0)  * hosek_rgb[i+45];\n\n    }\n\n}\n\n\nvec3 getRad(float solar_elevation) \n{\n    solar_elevation = pow(solar_elevation / (3.14 / 2.0), (1.0 / 3.0));\n\n    // albedo 0 & turbidity 1\n    return \n        pow(1.0-solar_elevation, 5.0) * hosek_rad[0] +\n        5.0*pow(1.0-solar_elevation, 4.0)*solar_elevation * hosek_rad[1] +\n        10.0*pow(1.0-solar_elevation, 3.0)*pow(solar_elevation, 2.0) * hosek_rad[2] +\n        10.0*pow(1.0-solar_elevation, 2.0)*pow(solar_elevation, 3.0) * hosek_rad[3] +\n        5.0*(1.0-solar_elevation)*pow(solar_elevation, 4.0) * hosek_rad[4] +\n        pow(solar_elevation, 5.0) * hosek_rad[5];\n}\n\n\nvec3 radiance_rgb(float solar_elevation, float theta, float gamma)\n{\n    vec3 config[9];\n    getCoefs(solar_elevation, config);\n\n    vec3 rad = getRad(solar_elevation);\n\n    vec3 expM;\n    expM.r = exp(config[4].r * gamma);\n    expM.g = exp(config[4].g * gamma);\n    expM.b = exp(config[4].b * gamma);\n\n    float rayM = cos(gamma)*cos(gamma);\n\n    vec3 mieM = vec3(0.);\n    mieM.r = (1.0 + rayM) / pow((1.0 + config[8].r*config[8].r - 2.0*config[8].r*cos(gamma)), 1.5);\n    mieM.g = (1.0 + rayM) / pow((1.0 + config[8].g*config[8].g - 2.0*config[8].g*cos(gamma)), 1.5);\n    mieM.b = (1.0 + rayM) / pow((1.0 + config[8].b*config[8].b - 2.0*config[8].b*cos(gamma)), 1.5);\n\n    float zenith = sqrt(cos(theta));\n\n    return rad * (1.0 + config[0] * exp(config[1] / (cos(theta) + 0.01))) *\n        (config[2] + config[3] * expM + config[5] * rayM + config[6] * mieM + config[7] * zenith);\n}\n\n\n\nvec3 skyColor(in vec3 dir, in vec3 sunPos)\n{\n    // below horizon\n    dir.y = max(dir.y, 0.);\n    \n\tdir = normalize(dir);\n    float gamma = acos(dot(dir, sunPos));\n    float theta = acos(dir.y);//0.*acos(dot(dir, vec3(0., 1., 0.)));\n    float elev = 3.14/2. - acos(sunPos.y);//0.*acos(dot(sunPos, vec3(0., 1., 0.)));\n    \n    \n    return radiance_rgb(elev, theta, gamma) / 10.;\n}\n\n\nvec3 material_lighting(inout ray_t ray, in mat3 rot_logo, in vec3 normal) \n{\n    vec3 lp = vec3(-3., 5., 3.);\n    vec3 l = normalize(lp - ray.origin);\n\n    vec3 c;\n    float dist_light = length(lp - ray.origin);\n    float dist_scene = rayMarch(ray_t(ray.origin + 1.5*MIN_DIST*normal, l), rot_logo, c);\n\n    if (dist_scene > 0. && dist_scene < dist_light) {\n        return vec3(0.);\n    }\n\n    return vec3(20.)/(dist_light*dist_light)* clamp(dot(normal, l), 0., 1.);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[],"code":"// Modem noise sound for Phase 3 was previously performed with \n// the noise function (in common). Was not that convincing.\n// This edit comes from Dave_Hoskins. Thanks ;-)\nfloat noiseModem(vec2 p)\n{\n    p = floor(p*2500.0)/2500.0;\n    return fract(dot(sin(p.x * 123.12)*142.,cos(p.y *34.95)*165.47));\n}\n\n// https://www.itu.int/itu-t/recommendations/index.aspx?ser=V\n// https://oona.windytan.com/posters/dialup-final.png\n// http://what-when-how.com/voip/fax-and-modem-tones-basics-voip/\n\nfloat initiating(in float t0) {\n    float receiver = 0.;\n    float caller = 0.;\n    \n    vec4 test = texture(iChannel0, vec2(0.));\n    \n    /***********/\n\t/* Phase 1 */\n    /***********/\n\n    // Initiating -> receiver: OK (400ms)\n    if (t0 < .4) {\n        receiver += wave(1375., t0) + wave(2002., t0);\n    }\n    \n    // ACK Init (400ms)\n    if (t0 > .4 && t0 < .8) {\n     \tcaller += wave(1529., t0) + wave(2225., t0);\n    }\n    \n    \n    // After init -> receiver: CR_e = Give me your capabilities (100ms)\n    if (t0 > .4 && t0 < .5) {\n        receiver += wave(400., t0);\n    }\n    \n    // My capilities are (100 ms each)\n    if (t0 > .8 && t0 < .9) {\n     \tfloat start_t0 = t0 - .8;\n        \n        // CR_d\n        if (start_t0 < .1) {\n         \tcaller += wave(1900., start_t0);\n        } \n        // ES_r\n        else if (start_t0 < .2) {\n            caller += wave(1650., start_t0);\n        }\n    }\n    \n\t// FSK config\n    float channel1 = 1080.; // PSK Caller avg frequency (Hz)\n    float channel2 = 1750.; // PSK Reciever avg frequency (Hz)\n    float dev      = 100.;  // PSK V.21 frequency deviation (+/-Hz)\n    int bitrate    = 300;   // PSK transmission speed (bps)\n        \n    // Caller ID FSK\n    int n_bits_c0 = 176;\n\tfloat start_c0 = 1.0;\n    float end_c0 = start_c0 + float(n_bits_c0) / float(bitrate);\n        \n    if (t0 >= start_c0 && t0 < end_c0) {\n        float start_t0 = t0 - start_c0;\n        \n        // To be transmitted\n        int data[176] = int[](\n            0,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,0,\n            0,1,0,0,1,0,0,0, 1,0,0,1,0,0,1,1, 0,0,0,0,0,0,0,1,\n            0,0,0,0,0,0,0,1, 0,0,0,0,0,0,0,1, 1,0,0,1,0,0,0,0,\n            1,0,1,0,1,1,0,1, 0,1,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,\n            0,0,1,0,1,0,0,1, 1,0,0,0,0,0,0,1, 1,1,0,0,0,0,0,1,\n            1,1,0,0,0,0,1,0, 1,1,1,0,0,0,1,0, 0,0,1,0,0,0,1,1,\n            1,1,1,0,0,1,0,0, 0,0,1,1,0,1,1,1, 0,1,1,1,1,1,1,0,\n            0,1,1,1,1,1,1,0\n        );\n        \n        int idx_bit = int(start_t0 * float(bitrate));\n        float idx_bit_2 = start_t0 * float(bitrate);\n        \n        /*\n        float b1 = data[int(floor(idx_bit_2))] == 0 ? -dev : dev;\n        float b2 = data[int(ceil(idx_bit_2))] == 0 ? -dev : dev;\n\n        caller += mix(\n            wave(channel1 + b1, t0),\n            wave(channel1 + b2, t0),\n            idx_bit_2);\n\t\t*/\n        \n        //*\n        if (idx_bit < n_bits_c0) {\n            if (data[idx_bit] == 0) {\n                caller += wave(channel1 - dev, t0); // F_a\n            } else {\n                caller += wave(channel1 + dev, t0); // F_z   \n            }\n        }\n\t\t//*/\n    }\n    \n    // Receiver, Let's use V.8\n    int n_bits_r0 = 192;\n    float start_r0 = end_c0;\n    float end_r0 = start_r0 + float(n_bits_r0) / float(bitrate);\n    \n    if (t0 >= start_r0 && t0 < end_r0) {\n        float start_t0 = t0 - start_r0;\n        \n        int data[192] = int[](\n            0,1,1,1,1,1,1,0, 0,0,1,1,1,1,1,1, 0,1,1,1,1,1,1,0,\n            0,1,1,1,1,1,1,0, 1,0,0,0,1,0,0,0, 1,0,0,0,0,0,0,1,\n            0,0,0,0,0,0,0,1, 0,0,0,0,0,0,0,1, 0,0,0,0,0,0,0,1,\n            1,0,0,0,0,0,0,1, 0,0,1,0,1,1,0,1, 0,1,0,0,0,0,0,0,\n            0,0,0,0,0,0,0,0, 0,0,1,0,1,0,0,1, 1,0,0,0,0,0,0,1,\n            1,1,0,0,0,0,0,1, 0,0,0,0,0,0,0,0, 1,1,1,0,0,0,0,0,\n            1,0,0,0,0,0,0,0, 0,1,1,1,1,1,1,0, 1,1,0,1,1,1,0,0,\n            0,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,0\n        );\n        \n        int idx_bit = int(start_t0 * float(bitrate));\n        \n        if (idx_bit < n_bits_r0) {\n            if (data[idx_bit] == 0) {\n                receiver += wave(channel2 - dev, t0); // F_a\n            } else {\n                receiver += wave(channel2 + dev, t0); // F_z   \n            }\n        }\n    }\n    \n    // ACK\n    int n_bits_c1 = 56;\n    float start_c1 = end_r0;\n    float end_c1 = start_c1 + float(n_bits_c1) / float(bitrate);\n    \n    if (t0 >= start_c1 && t0 < end_c1) {\n        float start_t0 = t0 - start_c1;\n               \n        // To be transmitted\n        int data[56] = int[](\n            0,1,1,1,1,1,1,0, 0,1,1,1,1,1,1,0,\n            0,0,1,0,1,0,0,0, 1,0,1,1,1,0,1,1,\n            0,1,1,0,0,1,0,1, 0,1,1,1,1,1,1,0,\n            0,1,1,1,1,1,1,0\n        );\n        \n        int idx_bit = int(start_t0 * float(bitrate));\n        \n        if (idx_bit < n_bits_c0) {\n            if (data[idx_bit] == 0) {\n                caller += wave(channel1 - dev, t0); // F_a\n            } else {\n                caller += wave(channel1 + dev, t0); // F_z   \n            }\n        }\n    }\n    \n    // ANSam\n    float start_ANSam = end_c1 + 1.;\n    float end_ANSam = start_ANSam + 2.;\n    \n    if (t0 > start_ANSam && t0 < end_ANSam) {\n        float ampl = mix(.8, 1., (wave(15., t0) + 1.) / 2.);\n     \treceiver += ampl * wave(2100., t0);   \n    }\n    \n    // CM Modulation mode available\n    int n_bits_c2 = 90 * 6;\n    float start_c2 = end_c1 + 2.;\n    float end_c2 = start_c2 + float(n_bits_c2) / float(bitrate);\n    \n    if (t0 >= start_c2 && t0 < end_c2) {\n        float start_t0 = t0 - start_c2;\n               \n        // To be transmitted\n        int data[90] = int[](\n            1,1,1,1,1,1,1,1,1,1, 0,0,0,0,0,0,0,1,1,1, 0,1,0,0,0,0,0,1,1,1,\n            0,1,0,1,0,1,0,1,0,1, 0,1,1,0,0,1,0,0,0,1, 0,0,0,1,0,1,0,0,1,1,\n            0,0,1,0,1,0,1,0,0,1, 0,1,0,1,1,0,0,0,0,1, 0,1,1,1,0,0,1,0,0,1\n        );\n        \n        int idx_bit = int(start_t0 * float(bitrate)) % 90;\n        \n        if (idx_bit < n_bits_c0) {\n            if (data[idx_bit] == 0) {\n                caller += wave(channel1 - dev, t0); // F_a\n            } else {\n                caller += wave(channel1 + dev, t0); // F_z   \n            }\n        }\n    }\n    // TODO: Missing CJ\n    \n    // JM\n    int n_bits_r1 = 90 * 3;\n    float start_r1 = end_ANSam;\n    float end_r1 = start_r1 + float(n_bits_r1) / float(bitrate);\n    \n    if (t0 >= start_c2 && t0 < end_c2) {\n        float start_t0 = t0 - start_c2;\n        \n        int data[90] = int[](\n            1,1,1,1,1,1,1,1,1,1, 0,0,0,0,0,0,1,1,1,1, 0,1,0,0,0,0,0,1,1,1,\n            0,1,0,1,0,0,1,1,0,1, 0,1,1,0,0,1,0,0,0,1, 0,0,0,0,0,1,0,0,1,1,\n            0,1,1,1,0,0,0,1,0,1, 0,1,0,1,1,0,0,0,0,1, 0,0,1,0,1,0,1,0,0,1\n        );\n        \n        int idx_bit = int(start_t0 * float(bitrate)) % 90;\n\n        if (idx_bit < n_bits_r0) {\n            if (data[idx_bit] == 0) {\n                receiver += wave(channel2 - dev, t0); // F_a\n            } else {\n                receiver += wave(channel2 + dev, t0); // F_z   \n            }\n        }\n    }\n    \n    /***********/\n    /* Phase 2 */\n    /***********/\n    \n    // DPSK V.34 config \n    float channelA   = 2400.; // DPSK Caller frequency (Hz)\n    float channelB   = 1200.; // DPSK Reciever frequency (Hz)\n    int dpsk_bitrate = 600;   // DPSK transmission speed (bps)\n    \n    // INFO_0\n    int n_bits_info_0a = 49;\n    int n_bits_info_0c = 48;\n    float start_info_0 = end_r1;\n    float end_info_0   = \n        start_info_0\n        + float(max(n_bits_info_0a, n_bits_info_0c)) / float(dpsk_bitrate) \n        + .150;\n\n    if (t0 > start_info_0 && t0 < end_info_0) {\n        float start_t0 = t0 - start_info_0;\n        int idx_bit = int(start_t0 * float(dpsk_bitrate));\n        \n        // INFO_0a\n        int data_a[49] = int[](\n            1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,\n            0,1,0,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,1,1,1,1\n        );\n        \n        if (idx_bit >= 49 || data_a[idx_bit] == 0) {\n\t\t\treceiver += wave(channelA, t0);\n        } else {\n\t\t\treceiver += wave_shift(channelA, t0, 3.14);\n        }\n        \n        // Guard\n        receiver += wave(channel2, t0);\n        \n        // INFO_0b\n        int data_c[48] = int[](\n        \t1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,\n        \t1,0,1,0,0,0,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,0,1,1\n   \t\t);\n        \n        if (idx_bit >= 48 || data_c[idx_bit] == 0) {\n\t\t\tcaller += wave(channelB, t0);\n        } else {\n\t\t\tcaller += wave_shift(channelB, t0, 3.14);\n        }\n    }\n    \n    // L1 & L2\n    float start_l1_0 = end_r1;\n    float end_l1_0 = start_l1_0 + .150;\n    \n    float start_l2_0 = end_l1_0;\n    float end_l2_0 = start_l2_0 + .550;\n    \n    float start_l1_1 = end_l2_0 + .100;\n    float end_l1_1 = start_l1_1 + .150;\n    \n    float start_l2_1 = end_l1_1;\n    float end_l2_1 = start_l2_1 + .550;\n    \n    if (t0 >= end_l2_0 && t0 <= start_l1_1) {\n        receiver += wave(channelA, t0);\n        receiver += wave(channel2, t0);\n        caller += wave(channelB, t0);\n    }\n    \n    if (t0 > start_l1_0 && t0 < end_l2_1) {\n        float L2 = \n            wave(150., t0) +\n            wave_shift(300., t0, 3.14) +\n            wave(450., t0) +\n            wave(600., t0) +\n            wave(750., t0) +\n            wave(1050., t0) +\n            wave(1350., t0) +\n            wave(1500., t0) +\n            wave_shift(1650., t0, 3.14) +\n            wave(1950., t0) +\n            wave(2100., t0) +\n            wave_shift(2250., t0, 3.14) +\n            wave(2550., t0) +\n            wave_shift(2700., t0, 3.14) +\n            wave(2850., t0) +\n            wave_shift(3000., t0, 3.14) +\n            wave_shift(3150., t0, 3.14) +\n            wave_shift(3300., t0, 3.14) +\n            wave_shift(3450., t0, 3.14) +\n            wave(3600., t0) +\n            wave(3750., t0);\n        \n        if (t0 < end_l1_0) {\n            receiver += L2;\n        } else if (t0 < end_l2_0) {\n            receiver += 0.5*L2;\n        } else if (t0 < end_l1_1) {\n            caller += L2;\n        } else if (t0 < end_l2_1) {\n            caller += 0.5*L2;\n        }\n    }\n   \n    // INFO_1\n    int n_bits_info_1a = 49;\n    int n_bits_info_1c = 48;\n    \n    float start_info_1c = end_l2_1;\n    float end_info_1c   = start_info_1c + float(n_bits_info_1c) / float(dpsk_bitrate);\n\t\n    float start_info_1a = end_info_1c;\n    float end_info_1a = start_info_1a + float(n_bits_info_1a) / float(dpsk_bitrate);\n    \n    if (t0 > start_info_1c && t0 < end_info_1c) {\n        float start_t0 = t0 - start_info_1c;\n        int idx_bit = int(start_t0 * float(dpsk_bitrate));\n        \n        // INFO_1c\n        int data[109] = int[](\n            0,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,\n            1,0,0,0,0,1,0,1,1,1,0,0,0,0,1,0,1,1,1,0,0,0,0,1,0,1,1,1,0,0,0,0,1,\n            0,0,0,0,1,0,1,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,1,0,\n            0,0,1,0,0,0,0,1,1,1\n        );\n        \n        if (idx_bit >= 109 || data[idx_bit] == 0) {\n\t\t\tcaller += wave(channelB, t0);\n        } else {\n\t\t\tcaller += wave_shift(channelB, t0, 3.14);\n        }\n        \n        // Guard\n        receiver += wave(channel2, t0);\n        \n        receiver += wave(channelA, t0);\n    }\n    \n    if (t0 > start_info_1a && t0 < end_info_1a) {\n        float start_t0 = t0 - start_info_1a;\n        int idx_bit = int(start_t0 * float(dpsk_bitrate));\n        \n        // INFO_1a\n    \tint data[70] = int[](\n        \t1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,0,0,0,\n        \t0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,1,1\n        );\n        \n        if (idx_bit >= 70 || data[idx_bit] == 0) {\n\t\t\treceiver += wave(channelA, t0);\n        } else {\n\t\t\treceiver += wave_shift(channelA, t0, 3.14);\n        }\n        \n        // Guard\n        receiver += wave(channel2, t0);\n    }\n    \n    /* Phase 3 */\n    \n    // We skip signal S for this primitive implementation\n    \n    // PP emitter\n    float pp_length = 1.;//50.*287./iSampleRate;\n    float start_pp_e = end_info_1a;\n    float end_pp_e = start_pp_e + pp_length;\n    \n    if (t0 > start_pp_e && t0 < end_pp_e) {\n        // Very fake...\n        for (int h = 0; h < 30; h++) {\n            float start_t0 = t0 - start_pp_e;\n            int idx = int(287. * start_t0 * float(h));// / pp_length);\n\n            int i = idx % 4; // 0,1,2,3\n            int k = idx / 4;\n\n            if (k%3 == 1) {\n                receiver += float(k*i+4)/300.;//(wave(float(k*i+4), t0) < 0.)? -1. : 1.;\n            } else {\n                receiver += float(k*i)/300.;//(wave(float(k*i), t0) < 0.)? -1. : 1.;\n            }\n        }\n    }\n    \n    // Fake TRN\n    float start_trn_e = end_pp_e;\n    float end_trn_e = start_trn_e + 2.5;\n    float br = 56000.;\n    \n    if (t0 > start_trn_e && t0 < end_trn_e) {       \n        receiver += wave(4200. * noiseModem(vec2(t0)), t0);\n    }\n    \n    \n    // PP caller\n    float start_pp_c = end_trn_e;\n    float end_pp_c = start_pp_c + pp_length;\n    \n    if (t0 > start_pp_c && t0 < end_pp_c) {\n          for (int h = 0; h < 30; h++) {\n            float start_t0 = t0 - start_pp_c;\n            int idx = int(287. * start_t0 * float(h));// / pp_length);\n\n            int i = idx % 4; // 0,1,2,3\n            int k = idx / 4;\n\n            if (k%3 == 1) {\n                caller += float(k*i+4)/300.;//(wave(float(k*i+4), t0) < 0.)? -1. : 1.;\n            } else {\n                caller += float(k*i)/300.;//(wave(float(k*i), t0) < 0.)? -1. : 1.;\n            }\n        }      \n        /*\n        float start_t0 = t0 - start_pp_c;\n        int idx = int(287. * start_t0 / pp_length);\n        \n        int i = idx % 4; // 0,1,2,3\n    \tint k = idx / 4;\n        \n        if (k%3 == 1) {\n            caller += wave(float(k*i+4)/6. * 300., t0);\n        } else {\n            caller += wave(float(k*i)/6. * 300., t0);\n        }\n*/\n    }\n    \n    \n    // Fake TRN\n    float start_trn_c = end_pp_c;\n    float end_trn_c = start_trn_c + 2.5;\n    \n    if (t0 > start_trn_c && t0 < end_trn_c) {       \n        caller += wave(4200. * noiseModem(vec2(t0)), t0);\n    }\n    \n    return .5*(receiver + caller);\n}\n\n\nfloat responding(float t0) {\n    if (t0 < .1) {\n        return wave(1529., t0) + wave(2225., t0);\n    }\n    \n    return 0.;\n}\n\n\nfloat segment2(float t0) {\n    if (t0 < .1) {\n     \treturn \n            wave(650., t0) + \n            wave(1150., t0) + \n            wave(400., t0) +\n            wave(1900., t0) +\n            wave(980., t0) +\n            wave(1650., t0);\n    }\n    \n    return 0.;\n}\n\n\nfloat ballBounces(in float time) {\n    float t0;\n    \n    if (time > 2.08 && time < 5.0) {\n     \tt0 = time - 2.08;  \n    } else if (time > 6.32 && time < 8.) {\n     \tt0 = time - 6.32;   \n    } else if (time > 10.59 && time < 14.) {\n     \tt0 = time - 10.59;   \n    } else if (time > 14.90 && time < 18.) {\n     \tt0 = time - 14.90;   \n    } else if (time > 19.40 && time < 23.) {\n     \tt0 = time - 19.40;   \n    } else if (time > 23.65 && time < 26.) {\n     \tt0 = time - 23.65;   \n    } \n    else {\n        return 0.;\n    }\n    \n    return ( sin(6.2831*(80.0)*t0)*exp(-1.5*t0) + \n                .2*sin(6.2831*(20.0)*t0)*exp(-1.*t0) + \n                .6*sin(6.2831*(40.0)*t0)*exp(-1.*t0) + \n                sin(6.2831*(120.0)*t0)*exp(-1.5*t0));   \n    \n}\n\n\nvec2 mainSound( in int samp, float time )\n{\n    float lengthState, t0;\n    int storyState = storyboardState(time, lengthState, t0);\n    \n    float retVal = 0.;\n    \n    switch (storyState) {\n        case STATE_TONE:\n        retVal = .5*wave(425.0, time);\n        break;\n        \n        case STATE_DIALING:\n\t\tretVal = .25*dial(number, t0, lengthState);\n        break;\n        \n        case STATE_WAITING:\n        retVal = 0.;\n        break;\n        \n        case STATE_MODEM:\n        retVal = 0.1*initiating(t0);\n        break;\n        \n        case STATE_BOUNCING:\n        retVal = ballBounces(t0);\n        break;\n        \n       \tdefault:\n        return vec2(0);\n    }\n    \n    return vec2(retVal);\n    \n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}","name":"Sound","description":"","type":"sound"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const vec3 green_phosphore = vec3(0., .66, 0.);\n\nbool downgrade(\n    in vec2 uv, \n    out vec2 downgradedUV) \n{\n    // Downgrade resolution\n    // CGA\n    vec2 cga = vec2(320, 200);\n    ivec2 raster = ivec2(uv * vec2(320, 200));\n\n\n    // Mimics Raster lines... Just a little exagerated\n    // for artistic purpose :-)\n    float t = fract(iTime);\n    int field = int(t * 30.);\n\n    if (raster.y % 2 == field % 2) {\n        return false;\n    }\n\n    downgradedUV = vec2(raster) / cga;\n    return true;\n}\n\n\nvec3 waveformScene(\n    in vec2 uv, \n    in float aspect, \n    int storyState, in float t0, in float lengthState) \n{\n    vec3 col = vec3(0.);\n\n    uv = 2.* uv - vec2(1.);\n    uv.x *= aspect;\n\n    if (!downgrade(uv, uv)) {\n        return col;\n    }\n\n    switch (storyState) {\n        case STATE_TONE:\n        case STATE_DIALING:\n        // Plot the waveform\n        float wave_value = (storyState == STATE_TONE)\n            ? wave(440.0, (uv.x + iTime)/ 500.0) \n            : .8*dial2(number, (uv.x + iTime)/500.0, t0, lengthState);\n\n        if (abs(.4*wave_value - uv.y) < 0.01) {\n            col = green_phosphore;   \n        } else {\n            col = vec3(0.);\n        }\n        break;\n\n        case STATE_WAITING:\n        if (uv.y == 0.) {\n            col = green_phosphore;\n        } else {\n            col = vec3(0.);\n        }\n        break;\n    }\n\n    return col;\n}\n\n\nvec3 connectingScene(\n    in vec2 uv, \n    in float aspect, \n    int storyState, in float t0, in float lengthState) \n{\n    uv = 2.* uv - vec2(1.);\n    uv.x *= aspect;\n\n    if (!downgrade(uv, uv)) {\n        return vec3(0.);\n    }\n\n    float lengthStateRecv, t0StateRecv;\n    int recv_modem_state = modemStateRecv(t0, lengthStateRecv, t0StateRecv);\n\n    switch (recv_modem_state) {\n        case STATE_MODEM_RCV_INIT:\n        case STATE_MODEM_RCV_CR_E:\n        if (uv.y == 0.) {\n            return green_phosphore;\n        } else {\n            return vec3(0.);\n        }\n    }\n    \n    float lengthStateCall, t0StateCall;\n    int call_modem_state = modemStateCall(t0, lengthStateCall, t0StateCall);\n\n    switch (call_modem_state) {\n        case STATE_MODEM_CALL_WAIT0:\n        if (uv.y == 0.) {\n            return green_phosphore;\n        } else {\n            return vec3(0.);\n        }\n    }\n\n    uv.x /= aspect;\n    uv = uv / 2. + vec2(0.5);\n\n    if (isOnAfigLogo(uv, aspect)) {\n        return green_phosphore;\n    }\n\n    return vec3(0.);\n}\n\n\nvec3 connectedScene(\n    in vec2 uv,\n    in float aspect, \n    int storyState, in float t0, in float lengthState)\n{\n    vec3 col = vec3(0.);\n    uv = 2.* uv - vec2(1.);\n    uv.x *= aspect;\n\n    if (!downgrade(uv, uv)) {\n        return vec3(0.);\n    }\n\n    // Rotation in hacky way :-p\n    float rotation = 2.*t0 / lengthState;//fract(iTime/3.);\n    rotation *= 2.*3.14;\n    uv.x /= cos(rotation);\n\n    uv.x /= aspect;\n    uv = uv / 2. + vec2(0.5);\n\n    if (isOnAfigLogo(uv, aspect)) {\n        col = green_phosphore;\n    }\n\n    return col;\n}\n\n\nvec3 transformCheckerboardScene(\n    in vec2 uv,\n    in float aspect, \n    int storyState, in float t0, in float lengthState)\n{\n    vec3 colRaster = vec3(0);\n    vec3 colTextured = vec3(0);\n\n    if (isOnAfigLogo(uv, iResolution.x / iResolution.y)) {\n        vec2 rasterUV = uv;\n\n        vec3 col = vec3(0.);\n        rasterUV = 2.* rasterUV - vec2(1.);\n        rasterUV.x *= aspect;\n\n        if (!downgrade(rasterUV, rasterUV)) {\n            colRaster = vec3(0.);\n        } else {\n            colRaster = green_phosphore;\n        }\n\n        rasterUV.x /= aspect;\n        rasterUV = rasterUV / 2. + vec2(0.5);\n\n    }\n\n    float t = t0 / lengthState;\n\n    vec2 texCoords;\n\n    if (isInAfigLogo(uv, aspect, texCoords)) {\n        colTextured = checkerboardTexture(texCoords);\n    }\n\n    return mix(colRaster, colTextured, t);\n}\n\n\nvec3 transitionBallScene(\n    in vec2 uv,\n    in float aspect, \n    int storyState, in float t0, in float lengthState)\n{\n    vec3 colTextured = vec3(0);\n    vec2 texCoords;\n\n    // target center\n    float t = smoothstep(0., lengthState, t0);\n\n    const float avg = .5;//(c0.z + c1.z) / 2.;\n\n    const vec3 c2_out = vec3(avg, -avg, 0.3);   // Larger bubble outside\n    const vec3 c2_in  = vec3(avg, -avg, 0);     // Larger bubble inside\n    const vec3 c3 = vec3(c2_in.xy * 1.9, 0.15); // Smaller bubble\n\n    vec2 uv_t = 2.*uv - vec2(1.);\n    uv_t.x *= aspect;\n    float theta = -3.14/6.;\n    uv_t *= mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n    uv_t *= 1.2 * c3.z;\n    uv_t = uv_t + c3.xy;// * c3.z;\n    uv_t /= 1.2;\n    uv_t.y += 0.2;\n    uv_t.x /= aspect;\n    uv_t = (uv_t + vec2(1.)) / 2.;\n\n    uv_t = mix(uv, uv_t, t);\n\n    if (isInAfigLogo(uv_t, aspect, texCoords)) {\n        colTextured = checkerboardTexture(texCoords);\n    }\n\n    return colTextured;\n}\n\n\nvec2 getR(vec2 uv, vec2 position) \n{\n    float aspect = iResolution.x / iResolution.y;\n\n    vec2 r = 2. * uv - vec2(1.);\n\n    r.x *= aspect;\n    r *= 3.;\n    r -= position;\n\n    return r;\n}\n\n\nvec3 sceneBall(vec2 uv, float aspect, vec3 resolution) {\n    vec3 col = vec3(0);\n    float back_floor = .1;\n    vec2 position = texelFetch(iChannel0, ivec2(0), 0).xy;\n\n    vec2 r = getR(uv, position);\n    float l_r = length(r);\n\n    // Draw the ball\n    if (l_r < 1.) {\n        float theta = -3.14/6.;\n        r *= mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n        vec3 sphere_normal = vec3(r, sqrt(1. - l_r*l_r));\n\n        vec2 sUV = sphereUV(sphere_normal);\n        sUV.x -= fract(.3*position.x);\n\n        col = checkerboardTexture(sUV);\n\n        // Shading\n        vec3 lPos = vec3(0., 0., 1.);\n        col *= dot(sphere_normal, lPos);\n    } \n    // Draw main background\n    else if (uv.y >= back_floor) {\n        float cols = 16.;\n        float rows = cols / aspect;\n        float weight_x = cols / resolution.x;\n        float weight_y = weight_x * rows / cols * aspect;\n        uv.y -= back_floor - weight_y;\n\n        col = grid(uv, rows, cols, weight_x, weight_y);\n\n        // Draw ball shadow       \n        vec2 r_shadow = r - vec2(.2);\n\n        if (length(r_shadow) < 1.1) {\n            col *= vec3(.8);\n        }\n    } \n    // Bottom part of the background\n    else {\n        // Fake perspective\n        uv.y = uv.y / back_floor;        \n        uv.x = 2.*uv.x - 1.;\n        uv.x /= mix(1., 1.2, 1.-uv.y);\n        uv.x = uv.x / 2. + 0.5;\n\n        float cols = 16.;\n        float rows = cols/3. / aspect;\n\n        float weight_x = cols / resolution.x;\n        float weight_y = weight_x * rows / cols * aspect / back_floor;\n\n        vec2 r_shadow = getR(uv, position) - vec2(.2);\n        uv.y = -uv.y;\n        col = grid(uv, rows, cols, weight_x, weight_y);\n\n        if (length(r_shadow) < 1.) {\n            col *= vec3(.8);\n        }\n    }\n\n    return col;\n}\n\n\nvec3 transitionBouncingScene(\n    in vec2 uv,\n    in float aspect,\n    int storyState, in float t0, in float lengthState)\n{\n    vec3 colTextured = vec3(0);\n    vec2 texCoords;\n\n    // target center\n    float t = smoothstep(0., lengthState, t0);\n\n    const float avg = .5;//(c0.z + c1.z) / 2.;\n\n    const vec3 c2_out = vec3(avg, -avg, 0.3);    // Larger bubble outside\n    const vec3 c2_in  = vec3(avg, -avg, 0);    // Larger bubble inside\n    vec3 c3 = vec3(c2_in.xy * 1.9, 0.15); // Smaller bubble\n\n    vec2 uv_t = 2.*uv - vec2(1.);\n    uv_t.x *= aspect;\n\n    float theta = -3.14/6.;\n    uv_t *= mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n\n    uv_t *= 1.2 * c3.z;\n    uv_t = uv_t + c3.xy;// * c3.z;\n    uv_t /= 1.2;\n    uv_t.y += 0.2;\n    uv_t.x /= aspect;\n    uv_t = (uv_t + vec2(1.)) / 2.;\n\n\n    if (isInAfigLogo(uv_t, aspect, texCoords)) {\n        colTextured = checkerboardTexture(texCoords);\n    }\n\n    vec2 uv_t2 = 2.*uv - vec2(1.);\n    uv_t2 /= 3./1.2;\n    uv_t2 = (uv_t2 + vec2(1.)) / 2.;\n\n\n    vec3 sceneBallCol = sceneBall(uv_t2, aspect, iResolution);\n\n    return mix(colTextured, sceneBallCol, t);\n}\n\n\nvec3 zoomOutBouncingScene(\n    in vec2 uv,\n    in float aspect,\n    int storyState, in float t0, in float lengthState)\n{\n    vec3 colTextured = vec3(0);\n    vec2 texCoords;\n\n    // target center\n    float t = smoothstep(0., lengthState, t0);\n\n    vec2 uv_t2 = 2.*uv - vec2(1.);\n    uv_t2 /= 3./1.2;\n    uv_t2 = (uv_t2 + vec2(1.)) / 2.;\n\n    return sceneBall(mix(uv_t2, uv, t), aspect, iResolution);\n}\n\n\nvec3 fadeOutBouncingScene(\n    in vec2 uv,\n    in float aspect,\n    int storyState, in float t0, in float lengthState)\n{\n    float t = smoothstep(0., lengthState, t0);\n        \n    vec3 col = vec3(0);\n\n    vec2 position = texelFetch(iChannel0, ivec2(0), 0).xy;\n    \n    // recenter the ball\n    // Now you see that I am struggling with my stupid code\n    vec2 offset = position / 3.;\n    offset.x /= aspect;\n    vec2 uv2 = (2.*uv - vec2(1.));\n    uv2 += offset;\n    uv2 = (uv2 + vec2(1.)) / 2.;\n    \n    uv = mix(uv, uv2, t);\n    vec2 r = getR(uv, position);\n    float l_r = length(r);\n    \n\t\n    // Draw the ball\n    if (l_r < 1.) {\n        //float l_r_prev = length(getR(uv_prev_scene, position));\n\n        float theta = -3.14/6.;\n        r *= mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n        vec3 sphere_normal = vec3(r, sqrt(1. - l_r*l_r));\n\n        vec2 sUV = sphereUV(sphere_normal);\n        sUV.x -= fract(.3*position.x);\n\n        col = checkerboardTexture(sUV);\n\n        // Shading\n        vec3 lPos = vec3(0., 0., 1.);\n        col *= dot(sphere_normal, lPos);\n    } \n    \n\n    return mix(sceneBall(uv, aspect, iResolution), col, t);\n}\n\n\n\nvec3 transitionRaymarch(\n    in vec2 uv,\n    in float aspect,\n    int storyState, in float t0, in float lengthState)\n{\n    vec3 colTextured = vec3(0);\n    vec2 texCoords;\n\n    // target ball\n    float t = smoothstep(0., lengthState, t0);\n    \n    vec3 colB = vec3(0);\n    float back_floor = .1;\n    \n    // recenter the ball\n    vec2 position = texelFetch(iChannel0, ivec2(0), 0).xy;\n    vec2 offset = position / 3.;\n    offset.x /= aspect;\n    vec2 uv_ball = (2.*uv - vec2(1.));\n    uv_ball += offset;\n    uv_ball = (uv_ball + vec2(1.)) / 2.;\n    \n    \n    vec2 r = getR(uv_ball, position);\n    float l_r = length(r);\n    \n    // Draw the ball\n    if (l_r < 1.) {\n\n        float theta = -3.14/6.;\n        r *= mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n        vec3 sphere_normal = vec3(r, sqrt(1. - l_r*l_r));\n\n        vec2 sUV = sphereUV(sphere_normal);\n        sUV.x -= fract(.3*position.x);\n\n        colB = checkerboardTexture(sUV);\n\n        // Shading\n        vec3 lPos = vec3(0., 0., 1.);\n        colB *= dot(sphere_normal, lPos);\n    }\n    \n    \n    mat3 rot_logo = \n        mat3(1., 0., 0.,\n             0., 1., 0.,\n             0., 0., 1.);\n\n    \n    vec2 cam_start = vec2(0.95, 1.05);\n    ray_t ray = camera(\n        vec3(cam_start, 0.8), \n        vec3(cam_start, -10.), \n        60., uv, aspect);\n    \n    vec3 colRM = vec3(0.);\n    float d = rayMarch(ray, rot_logo, colRM);\n    \n    if (d > 0.) {\n        ray.origin = ray.origin + d * ray.direction;\n        vec3 normal = getNormal(ray.origin, rot_logo);\n\n        vec3 contrib = material_lighting(ray, rot_logo, normal);\n        colRM = pow(colRM * contrib, vec3(1./2.2));\n    } else { \n        colRM = vec3(0.);\n    }\n     \n    return mix(colB, colRM, t);\n}\n\n\nvec3 zoomOutRaymarch(\n    in vec2 uv,\n    in float aspect,\n    int storyState, in float t0, in float lengthState)\n{\n    mat3 rot_logo = \n        mat3(1., 0., 0.,\n             0., 1., 0.,\n             0., 0., 1.);\n\n    float t = smoothstep(0., lengthState, t0);\n\n    \n    vec3 cam_pos_start = vec3(0.95, 1.05, .8);\n    vec3 cam_pos_end   = vec3(0., 1.5, 3.);\n\n    vec3 cam_target_start = vec3(0.95, 1.05, -10.);\n    vec3 cam_target_end   = vec3(0., 2.0, 0.);\n    \n    vec3 cam_pos_interpolate    = mix(cam_pos_start, cam_pos_end, t);\n    vec3 cam_target_interpolate = mix(cam_target_start, cam_target_end, t);\n    \n    ray_t ray = camera(\n        cam_pos_interpolate, \n        cam_target_interpolate, \n        60., uv, aspect);\n    \n    vec3 col;\n    float d = rayMarch(ray, rot_logo, col);\n    \n    if (d < 0.) return vec3(0.);\n    \n    ray.origin = ray.origin + d * ray.direction;\n    vec3 normal = getNormal(ray.origin, rot_logo);\n\n    vec3 contrib = material_lighting(ray, rot_logo, normal);\n\n    return pow(col * contrib, vec3(1./2.2));\n}\n\n\n\nvec3 raymarchLambert(\n    in vec2 uv,\n    in float aspect,\n    int storyState, in float t0, in float lengthState)\n{\n    mat3 rot_logo = \n        mat3(cos(t0) , 0., sin(t0),\n             0.      , 1., 0.,\n             -sin(t0), 0., cos(t0)\n            );\n\n    ray_t ray = camera(\n        vec3(0., 1.5, 3.), \n        vec3(0., 2.0, 0.), \n        60., uv, aspect);\n    \n    vec3 col;\n    float d = rayMarch(ray, rot_logo, col);\n    \n    if (d < 0.) return vec3(0.);\n    \n    ray.origin = ray.origin + d * ray.direction;\n    vec3 normal = getNormal(ray.origin, rot_logo);\n\n    vec3 contrib = material_lighting(ray, rot_logo, normal);\n\n    return pow(col * contrib, vec3(1./2.2));\n}\n\n\n\nvec3 raymarchHosek(\n    in vec2 uv,\n    in float aspect,\n    int storyState, \n    in float t0, in float t1,\n    in float lengthState)\n{\n    float lengthT = 10.;\n    float tt = fract(t1 / (2.*lengthT)) * lengthT;\n    float x1 = exp(- (tt - lengthT/2.)*(tt - lengthT/2.) / 12.);\n    \n    float lengthP = 2.;\n    float tp = fract(t1 / (2.*lengthP)) * lengthP;\n    float x2 = exp(- (tp - lengthP/2.)*(tp - lengthP/2.) / 12.);\n    \n    float sunTheta = clamp(x1 * 3.14/2., 0.001, 3.14/2. - 0.001); //(1. - iMouse.y / iResolution.y) * 3.14/2.; \n   \tfloat sunPhi   = clamp(fract(.5*t1 / lengthT) * 2.*3.14, 0.01, 2.*3.14); //3.14 + iMouse.x / iResolution.x * 2.*3.14;\n    \n\tvec3 sunPos = vec3(\n        sin(sunTheta) * cos(sunPhi), \n        cos(sunTheta), \n        sin(sunTheta) * sin(sunPhi));\n    \n    vec3 attenuation = vec3(1.);\n\n    mat3 rot_logo = \n        mat3(cos(t0) , 0., sin(t0),\n             0.      , 1., 0.,\n             -sin(t0), 0., cos(t0)\n            );\n    \n    ray_t ray = camera(\n        vec3(0., 1.5, 3.), \n        vec3(0., 2.0, 0.), \n        60., uv, aspect);\n    \n\tfloat d;\n\n    for (int i = 0; i < 3; i++) {\n        vec3 col;\n        d = rayMarch(ray, rot_logo, col);\n        \n        if (d < 0.) { break;  }\n        \n        // Hack to clean the mess at horizon\n        if (d >= MAX_DIST / 2. || ray.origin.y < 0.1) {\n            float t = smoothstep(MAX_DIST/2., MAX_DIST/1.5, d*d);\n            attenuation *=  mix(col, vec3(1.), t);\n            break;\n\t    }\n        \n        vec3 hitpoint = ray.origin + d * ray.direction;\n        vec3 normal = getNormal(hitpoint, rot_logo);\n\n        ray.direction = normalize(reflect(ray.direction, normal));\n        ray.origin = hitpoint + 2.*MIN_DIST * normal;\n        attenuation *= col;\n    }\n    \n\tvec3 sky_direction = skyColor(ray.direction, sunPos);\n    vec3 col = attenuation * skyColor(ray.direction, sunPos);\n    \n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Which state are we in?\n    float lengthState, t0;\n    int storyState = storyboardState(iTime, lengthState, t0);\n\n    // Screen coordinates 0 .. 1\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Aspect ratio\n    float aspect = iResolution.x/iResolution.y;\n\n    vec3 col = vec3(0.);\n\n    switch (storyState) {\n        case STATE_TONE:\n        case STATE_DIALING:\n        case STATE_WAITING:\n        col = waveformScene(uv, aspect, storyState, t0, lengthState);\n        break;\n\n        case STATE_MODEM:\n        col = connectingScene(uv, aspect, storyState, t0, lengthState);\n        break;\n\n        case STATE_CONNECTED:\n        col = connectedScene(uv, aspect, storyState, t0, lengthState);\n        break;\n\n        case STATE_TRANSFORM_CHECKERBOARD:\n        col = transformCheckerboardScene(uv, aspect, storyState, t0, lengthState);\n        break;\n\n        case STATE_TRANSITION_BALL:\n        col = transitionBallScene(uv, aspect, storyState, t0, lengthState);\n        break;\n\n        case STATE_TRANSITION_BOUNCING:\n        col = transitionBouncingScene(uv, aspect, storyState, t0, lengthState);\n        break;\n\n        case STATE_ZOOM_OUT_BOUNCING:\n        col = zoomOutBouncingScene(uv, aspect, storyState, t0, lengthState);\n        break;\n\n        case STATE_BOUNCING:\n        col = sceneBall(uv, aspect, iResolution);\n\t\tbreak;\n        \n        case STATE_FADE_OUT_BOUNCING:\n        col = fadeOutBouncingScene(uv, aspect, storyState, t0, lengthState);\n\t\tbreak;\n        \n        case STATE_TRANSITION_RAYMARCH:\n        col = transitionRaymarch(uv, aspect, storyState, t0, lengthState);\n\t\tbreak;\n        \n        case STATE_ZOOM_OUT_RAYMARCH:\n        col = zoomOutRaymarch(uv, aspect, storyState, t0, lengthState);\n\t\tbreak;\n        \n        case STATE_RAYMARCH_LAMBERT:\n        col = raymarchLambert(uv, aspect, storyState, 0., lengthState);\n        break;\n        \n        case STATE_RAYMARCH_LAMBERT_ROT:\n        col = raymarchLambert(uv, aspect, storyState, t0, lengthState);\n\t\tbreak;\n        \n        case STATE_TRANSITION_HOSEK:\n        float t1 = mix(duration_state[STATE_TRANSITION_HOSEK - 1] - t0, t0 - lengthState, smoothstep(0., lengthState, t0));\n        vec3 col1 = raymarchLambert(uv, aspect, storyState, t1, lengthState);\n        vec3 col2 = raymarchHosek(uv, aspect, storyState, t1, 0., lengthState);\n\t\tcol = mix(col1, col2, smoothstep(0., lengthState, t0));\n        break;\n        \n        default:\n        col = raymarchHosek(uv, aspect, storyState, t0, t0, lengthState);\n        break;\n    }\n\n    fragColor = vec4(col, 1.);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Keep track of time bewteen for animation\nvoid mainImage(out vec4 posVelocity, in vec2 fragCoord)\n{    \n    float lengthState, t0;\n    int storyState = storyboardState(iTime, lengthState, t0);\n\n    vec4 prevPos = texelFetch(iChannel0, ivec2(0), 0);\n    vec2 velocity = vec2(0);\n    vec2 position = vec2(0);\n    \n    if (storyState < STATE_BOUNCING) {\n        velocity = vec2(.6, 0.);\n    }\n    else if (storyState == STATE_BOUNCING) {\n        vec2 bboxX = vec2(-4., 4.);\n        vec2 bboxY = vec2(-1.8, 2.);\n\n        velocity = prevPos.zw + vec2(0., -0.8) * iTimeDelta;    \n        position = prevPos.xy + velocity * iTimeDelta;\n\n        if (position.x < bboxX.x || position.x > bboxX.y) {\n            velocity.x = -velocity.x;\n            position = prevPos.xy + velocity * iTimeDelta;\n        }\n\n        if (position.y < bboxY.x) {\n            velocity.y = -velocity.y;\n            position = prevPos.xy + velocity * iTimeDelta;\n        }   \n\n        velocity.y = clamp(velocity.y, -2., 2.);\n    } \n    else if (storyState <= STATE_ZOOM_OUT_RAYMARCH)  {\n        position = prevPos.xy;\n     \tvelocity = vec2(0);   \n    }\n    \n    \n    posVelocity = vec4(position, velocity);\n\n}\n","name":"Buffer B","description":"","type":"buffer"}]}