{"ver":"0.1","info":{"id":"3sKXRD","date":"1573539939","viewed":105,"name":"Procedual Noise Texture","username":"alenwesker","description":"Simple procedual cloud-alike noise texture","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI  3.14159265359\n#define TWO_PI (2.0*PI)\n#define HALF_PI (0.5*PI)\n#define float2 vec2\n#define float4 vec4\n#define fmod mod\n#define saturate(x) clamp(x, 0.0f, 1.0f)\n#define frac fract\n\n#define USE_FAST_SIN\n\n//#define SLIP_FUNCTION\n#ifdef SLIP_FUNCTION\nfloat hash1( vec2 p )\n{\n    //float q = ( dot(p,vec2(127.1,311.7)));\n    vec2 v = p * 10.0f;\n\treturn (sin(v.x) + sin(v.y)) * 0.25 + 0.25;\n}\n#else\n// Use fast sin to faster calculation\nfloat2 FMod2(float2 x, float2 y)//Review the above, we need to do it on our own\n{\n    return x - floor(x / y) * y;\n}\nfloat2 FastSinDouble(float2 input2) //Calculate sin/cos together to save instructions\n{\n    #ifdef USE_FAST_SIN\n    \n\tfloat2 zeroTo2PI = FMod2(float2(input2.x, input2.y), float2(TWO_PI, TWO_PI)); //move to range 0-2pi\n\n    //This calculation is achieved by Desmo; Only 3 instructions !!!\n    float4 core = float4(zeroTo2PI.xxyy) * (1.0f / HALF_PI)  + float4(-1.0f, -3.0f, -1.0f, -3.0f);\n    float4 result = saturate(-core * core + float4(1.0f, 1.0f, 1.0f, 1.0f));\n    return float2(result.xz - result.yw);\n    #else\n    return sin(input2);\n    #endif\n}\nfloat NoiseCloudAlike1( float2 p )\n{\n    //float q = ( dot(p,vec2(127.1,311.7)));\n    float2 v = p * 10.0f;\n    float2 sin2 = FastSinDouble(v); \n\treturn (sin2.x + sin2.y) * 0.25 + 0.25; //It means overlapping two waves\n}\nfloat NoiseCloudAlike(float2 uv)\n{   \n    float v = NoiseCloudAlike1(uv + 0.25) * NoiseCloudAlike1(uv) * 4.0;\n    return v;\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 uvMovement = uv;\n    \n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    #ifdef SLIP_FUNCTION\n    float v = hash1(uvMovement + 0.25) * hash1(uvMovement) * 4.0;\n    #else\n    float v = NoiseCloudAlike(uvMovement);\n    #endif\n    \n    vec3 col = vec3(v,v,v);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}