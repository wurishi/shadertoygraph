{"ver":"0.1","info":{"id":"WsKyzG","date":"1603131590","viewed":58,"name":"RIOW - 6.a - Normals","username":"TheMunro","description":"Raytracing","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord),0);\n    //fragColor = vec4(sqrt(data.rgb/data.w),1.0);\n    fragColor = vec4(data.rgb, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//constants\nvec3 zero = vec3(0., 0., 0.);\nvec3 one = vec3(1., 1., 1.);\n\n//data types\nstruct Ray\n{ \n    vec3 o; \n    vec3 d;\n};\n    \nstruct Sphere\n{ \n    vec3 c; \n    float r;\n};\n    \nSphere sphere = Sphere(vec3(0., 0., -1.), 0.5);\n\n//functions\nfloat hit_sphere(in Sphere s, in Ray r)\n{\n    //quadratic solution \n    vec3 oc = r.o - s.c;\n    float a = dot(r.d, r.d);\n    float b = 2. * dot(oc, r.d);\n\tfloat c = dot(oc, oc) - s.r * s.r;\n    \n\tfloat det = b*b - 4.*a*c;\n        \n    if(det < 0.)\n        return -1.;\n\n    return (-b - sqrt(det)) / (2. * a);\n}   \n    \nvec3 ray_color(in Ray r)\n{\n    float t = hit_sphere(sphere, r);\n    if(t > 0.) \n    {\n        vec3 p = r.d * t + r.o;\n        vec3 normal = normalize(p - sphere.c);\n        //return vec4(ray.dir, 1.0); \n      \n        return 0.5 * (normal + 1.); \n    }\n    \n    vec3 n = normalize(r.d);\n    t = 0.5 * (n.y + 1.);\n    return mix(one, vec3(0.5, 0.7, 1.), t);\n}\n\n//output\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) \n{    \n    vec2 seed = vec2(hrand(fragCoord) + iTime);\n    //remap height into [-1, 1]\n    vec2 uv = (2. * fragCoord.xy - iResolution.xy + hash_2d(seed))/iResolution.y;\n        \n    //position \n    Ray r = Ray(zero, vec3(uv, -1.));\n    \n    vec3 col = ray_color(r);\n    \n    //still need to accumulate per frame\n    fragColor = vec4(col, 1.);\n}","name":"Buffer @","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float nrand(in vec2 n)\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n\n// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\n\nuint base_hash(uvec2 p)\n{\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat hash_1d(vec2 x)\n{\n    uint n = base_hash(floatBitsToUint(x));\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nvec2 hash_2d(vec2 x)\n{\n    uint n = base_hash(floatBitsToUint(x));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2((rz.xy >> 1) & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash_3d(vec2 x)\n{\n    uint n = base_hash(floatBitsToUint(x));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3((rz >> 1) & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec4 hash_4d(vec2 x)\n{\n    uint n = base_hash(floatBitsToUint(x));\n    uvec4 rz = uvec4(n, n*16807U, n*48271U, n*69621U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec4((rz >> 1) & uvec4(0x7fffffffU))/float(0x7fffffff);\n}  \n\nfloat hrand(in vec2 coord) \n{\n    uint hashed_coord = base_hash(floatBitsToUint(coord));\n    return float(hashed_coord)/float(0xFFFFFFFFU);  \n}\n","name":"Common","description":"","type":"common"}]}