{"ver":"0.1","info":{"id":"4XlyzN","date":"1726006226","viewed":39,"name":"Moving Circle123","username":"alexkozh","description":"s","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["s"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.1415926535897932384626433832795\nvoid storeValue( in ivec2 re, in vec4 va, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    fragColor = (re.x==fragCoord.x && re.y==fragCoord.y ) ? va : fragColor;\n}\n\nfloat DrawSphere(in vec2 center, in vec2 coord, in float r)\n{\n    float val = length(center - coord);\n    \n    return 1.0f - smoothstep(-2.0f * r,  2.0f* r, val);\n}\n\nfloat GetUAngle(in vec2 center, in vec2 coord, in float r) //x\n{\n    float val = clamp((center.x - coord.x) * 2.0f, -1.0f, 1.0f);\n    \n    return val * M_PI / 2.0f;\n}\n\nfloat GetVAngle(in vec2 center, in vec2 coord, in float r) //y\n{\n    float val = clamp((coord.y - center.y) * 2.0f, -1.0f, 1.0f);\n    \n    return val * M_PI / 2.0f;\n}\n\n\nvec3 GetSphereNormal(in vec2 center, in vec2 coord, in float r)\n{\n    float angleU = GetUAngle(center, coord, r); //rotate by Z\n    float angleV = GetVAngle(center, coord, r); //rotate by Y\n    \n    mat3x3 rotByY = mat3(vec3(cos(angleV), 0.0f, -sin(angleV)), \n                         vec3(0.0f,        1.0f,  0.0f),\n                         vec3(sin(angleV), 0.0f,  cos(angleV))\n                        );\n    mat3x3 rotByZ = mat3(vec3( cos(angleU), sin(angleU), 0.0f), \n                         vec3(-sin(angleU), cos(angleU), 0.0f),\n                         vec3(0.0f,         0.0f,        1.0f)\n                        );\n                        \n    mat3x3 finalRot = rotByY * rotByZ;\n    \n    vec3 baseNormal = vec3(1, 0, 0);\n     \n    vec3 actualNormal = finalRot * baseNormal;\n    return actualNormal;\n}\n\nfloat GetIntansity(in vec3 normal, in vec3 lightDir, in vec3 lightPos, in vec3 objCenter, float r)\n{\n    vec3 pointPos = objCenter + normal * r;\n    \n    vec3 dir = pointPos - lightPos;\n    float factor = 1.0f / length(pointPos - lightPos);\n    \n    return clamp(dot(normal, dir), 0.0f, 1.0f) * factor + 0.1f;\n}\n\nfloat DrawBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //data\n    vec2 mousePos = (iMouse.xy * 2.0f - iResolution.xy) / iResolution.y;\n    vec3 lightPos = vec3(-0.5f, mousePos.x, mousePos.y);\n    vec3 lightDir = vec3(0, 1.0f, -1.0f);\n    \n    vec2 circleCenter = texelFetch(iChannel2, ivec2(0,0), 0).xy;\n    vec2 cubeCenter =   texelFetch(iChannel2, ivec2(3,0), 0).xy;\n    \n    vec2 boxSize = vec2(0.4f, 0.2f);\n    float circleR = 0.2f;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    ivec2 ifragCoord = ivec2(fragCoord);\n    vec2 uv = (2.0f * fragCoord - iResolution.xy)/iResolution.y;\n    \n    //////\n    \n    float kSphere = DrawSphere(circleCenter, uv, circleR);\n    float kLight  = DrawSphere(lightPos.yz, uv, 0.1f);\n    float kCube   = DrawBox(uv - cubeCenter, boxSize);\n    //colors\n    vec3 colCircle = texture(iChannel0, uv - circleCenter).rgb;\n    vec3 colCube = texture(iChannel3, uv - cubeCenter).rgb;\n    \n    \n    // Output to screen\n    if(kLight != 0.0f)\n    {\n        fragColor = vec4(1.0f);\n    }\n    else if(kCube <= 0.0f)\n    {\n        fragColor = vec4(colCube, 1.0f);\n    }\n    else if(kSphere != 0.0f)\n    {\n        float intensity = GetIntansity(GetSphereNormal(circleCenter, uv, circleR), lightDir, lightPos, vec3(0.0f, circleCenter.x, circleCenter.y), circleR);\n        fragColor = vec4(colCircle * intensity, 1.0f);\n    }\n    else\n    {\n        fragColor = vec4(0.5f, 0.0f, 0.5f, 1.0f);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define M_PI 3.1415926535897932384626433832795\n#define CircleC 12\nvec4 loadValue( in ivec2 re )\n{\n    return texelFetch( iChannel1, re, 0 );\n}\n\nvoid storeValue( in ivec2 re, in vec4 va, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    fragColor = (re.x==fragCoord.x && re.y==fragCoord.y ) ? va : fragColor;\n}\n\nvec2 MinMaxDotProductCircle(in vec2 circlePos, in float r, vec2 normal)\n{\n    float maxV = 0.0f;\n    float minV = 10000000.0f;\n    \n    for(int i = 0; i < CircleC; i++)\n    {\n        float angle = float(i) * 2.0f * M_PI / float(CircleC);\n        vec2 dir = vec2(cos(angle), sin(angle)) * r;\n        \n        vec2 vert = circlePos + dir;\n        float prod = dot(vert, normal);\n\n\t\tminV = min(minV, prod);\n\t\tmaxV = max(maxV, prod);\n    }\n\n    return vec2(minV, maxV);\n}\n\nvec2 MinMaxDotProductCube(in vec2 cubePos, in vec2 cubeSize, vec2 normal)\n{\n    float maxV = 0.0f;\n    float minV = 10000000.0f;\n    \n    for(int i = 0; i < 4; i++)\n    {\n        float angle = float(i) * 2.0f * M_PI / 4.0f;\n        vec2 dir = vec2(cos(angle) * cubeSize.x, sin(angle)* cubeSize.y);\n        \n        vec2 vert = cubePos + dir;\n        float prod = dot(vert, normal);\n\n\t\tminV = min(minV, prod);\n\t\tmaxV = max(maxV, prod);\n    }\n\n    return vec2(minV, maxV);\n}\nbool isCollide(in vec2 circlePos, in float r, in vec2 cubePos, in vec2 cubeSize)\n{\n    //circle check\n    for(int i = 0; i < CircleC; i++)\n    {\n        float angle1 = float(i) * 2.0f * M_PI / float(CircleC);\n        vec2 dir1 = vec2(cos(angle1), sin(angle1)) * r;\n        \n        float angle2 = float((i + 1) % 6) * 2.0f * M_PI / float(CircleC);\n        vec2 dir2 = vec2(cos(angle2), sin(angle2)) * r;\n        \n        vec2 v1 = circlePos + dir1;\n        vec2 v2 = circlePos + dir2;\n        \n        vec2 side = v2 - v1;\n        vec2 norm = vec2(-side.y, side.x);\n        \n        vec2 circleMinMax = MinMaxDotProductCircle(circlePos, r, norm);\n        vec2 cubeMinMax =   MinMaxDotProductCube(cubePos, cubeSize, norm);\n        \n        \n        if(circleMinMax.x >= cubeMinMax.y || cubeMinMax.x >= circleMinMax.y)\n        {\n            return false;\n        }\n    }\n    //cube check\n    for(int i = 0; i < 4; i++)\n    {\n        float angle1 = float(i) * 2.0f * M_PI / 4.0f;\n        vec2 dir1 = vec2(cos(angle1) * cubeSize.x, sin(angle1) * cubeSize.y);\n        \n        float angle2 = float((i + 1) % 4) * 2.0f * M_PI / 4.0f;\n        vec2 dir2 = vec2(cos(angle2) * cubeSize.x, sin(angle2) * cubeSize.y);\n        \n        vec2 v1 = cubePos + dir1;\n        vec2 v2 = cubePos + dir2;\n        \n        vec2 side = v2 - v1;\n        vec2 norm = vec2(-side.y, side.x);\n        \n        vec2 circleMinMax = MinMaxDotProductCircle(circlePos, r, norm);\n        vec2 cubeMinMax =   MinMaxDotProductCube(cubePos, cubeSize, norm);\n        \n        if(cubeMinMax.x >= circleMinMax.y || circleMinMax.x >= cubeMinMax.y)\n        {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        //data\n        float boarder = 1.5f;\n        float yPos = -0.4f;\n        \n        \n        \n        vec4 circleVelocity = vec4(0.05f, 0.0f, 0.0f, 0.0f);\n        \n        float maxCubeVel = 0.4f;\n        float startVel = 0.02f;\n        float stepVel = 0.002f;\n        vec4 cubeVelocity = texelFetch(iChannel1, ivec2(1,0), 0);\n        cubeVelocity.x = 0.0f;\n        cubeVelocity.z = 0.0f;\n        if(cubeVelocity.y < startVel)\n        {\n            cubeVelocity.y = startVel;\n        }\n        //vec2 uv = (2.0f * fragCoord - iResolution.xy)/iResolution.y;\n        vec2 uv = fragCoord / iResolution.xy;\n        ivec2 ifragCoord = ivec2(fragCoord);\n       \n\n        vec4 circlePos = texelFetch(iChannel1, ivec2(0,0), 0);\n        float circleR = 0.2f;\n        circlePos.y = yPos;\n        \n        vec4 cubePos   = texelFetch(iChannel1, ivec2(3,0), 0);\n        vec2 cubeSize  = vec2(0.4f, 0.2f);\n        \n        float Akeypressed = texelFetch(iChannel0, ivec2(65, 0), 0).x;\n        float Dkeypressed = texelFetch(iChannel0, ivec2(68, 0), 0).x;\n        \n        \n        //circle move//\n        if(Akeypressed != 0.0 && circlePos.x > -boarder)\n        {       \n           circlePos -= circleVelocity;\n        }\n        else if (circlePos.x <= -boarder)\n        {\n            circlePos = vec4(-boarder, yPos, 0.0f, 0.0f);\n        }\n        \n        if(Dkeypressed != 0.0 && circlePos.x < boarder)\n        {            \n            circlePos += circleVelocity;\n        }\n        else if(circlePos.x >= boarder)\n        {\n            circlePos = vec4(boarder, yPos, 0.0f, 0.0f);\n        }\n        /////////////\n        \n        //cube move//\n        \n        cubePos -= cubeVelocity;\n        if(cubePos.y <= -1.5f)\n        {\n             cubePos.y = 1.5f;\n             cubePos.x = circlePos.x;\n             if(cubeVelocity.y < maxCubeVel)\n             {\n                 cubeVelocity.y += stepVel;\n             }\n        }   \n        \n        \n        \n        //check collision\n        if(isCollide(circlePos.xy, circleR, cubePos.xy, cubeSize))\n        {\n            //storeValue(ivec2(5,0),vec4(1.0f, 0.0f, 0.0f, 1.0f), fragColor, ifragCoord);\n            circlePos = vec4(0.0f, yPos, 0.0f, 0.0f);\n            cubePos.y = 2.0f;\n            cubePos.x = circlePos.x;\n            cubeVelocity.y = startVel;\n        }\n\n        //save data\n        storeValue(ivec2(0,0), circlePos, fragColor, ifragCoord);\n        storeValue(ivec2(3,0), cubePos,   fragColor, ifragCoord);\n        storeValue(ivec2(1,0), cubeVelocity,   fragColor, ifragCoord);\n   \n}","name":"Buffer A","description":"","type":"buffer"}]}