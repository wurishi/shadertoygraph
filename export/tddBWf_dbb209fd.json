{"ver":"0.1","info":{"id":"tddBWf","date":"1606174631","viewed":83,"name":"Real-time ball 2","username":"lechuga2000","description":"Basic ray-tracing scheme for spherical","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sphere","ball","realtime"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Eye\nconst float eyeRadius = 5.0;\nconst float eyeSpeed = 0.3;\n\nvec3 eye;\n\n// Light\nvec3 lightPosition;\n\n// Ball\nconst vec3 ballCenter = vec3(0.0);\nconst float ballRadius = 1.5;\n\nconst vec3 ballMaterialDiffuse = vec3(1.0, 0.0, 0.0);\nvec3 ballMaterialAmbient = 0.2 * ballMaterialDiffuse;\nconst vec3 ballMaterialSpecular = vec3(0.7);\nfloat ballMaterialShininess = 100.0;\n\nconst float reflection = 0.2;\n\nvec3 color(in vec3 lightPosition, in vec3 normal, in vec3 materialAmbient, in vec3 materialDiffuse\n               , in vec3 materialSpecular, in float materialShininess, in vec3 rayIntersection)\n{\n  vec3 L = normalize(lightPosition - rayIntersection);\n  vec3 E = normalize(eye - rayIntersection);\n  vec3 R = normalize(-reflect(L, normal));\n\n  vec3 Idiffuse = clamp(materialDiffuse * max(dot(normal, L), 0.0), 0.0, 1.0);\n  vec3 Ispecular = clamp(materialSpecular * pow(max(dot(R, E), 0.0), 0.3 * materialShininess), 0.0, 1.0);\n\n  return clamp(materialAmbient + Idiffuse + Ispecular, 0.0, 1.0);\n}\n\nvec3 ballColor(in vec3 lightPosition, in vec3 rayIntersection)\n{\n  vec3 normal = normalize(rayIntersection - ballCenter);\n\n  vec3 textureEnv = texture(iChannel0, reflect(normalize(rayIntersection - eye), normal)).xyz;\n\n  float t;\n  \n  return mix(color(lightPosition, normal, ballMaterialAmbient, ballMaterialDiffuse, ballMaterialSpecular\n                     , ballMaterialShininess, rayIntersection)\n               , textureEnv\n               , reflection);\n}\n\nbool ballIntersection(in vec3 rayOrigin, in vec3 rayDirection, in vec3 center, in float radius, out float t)\n{\n  vec3 m = rayOrigin - center;\n\n  float a = dot(rayDirection, rayDirection);\n  float b = 2.0 * dot(rayDirection, m);\n  float c = dot(m, m) - pow(radius, 2.0);\n\n  float det = pow(b, 2.0) - 4.0 * a * c;\n  if (det < 0.0)\n  {\n    return false;\n  }\n  else\n  {\n    float aa = 0.5 / a;\n    float sqrtDet = sqrt(det);\n      \n    if ((t = aa * (-b - sqrtDet)) < 0.0)\n    {\n      t = aa * (-b + sqrtDet);\n    }\n    \n    return t > 0.0;\n  }\n}\n\nvec4 render(in vec2 texCoord)\n{\n  vec2 uv = texCoord;\n  uv.x *= iResolution.x / iResolution.y;\n\n  vec3 rayDirection1 = -normalize(eye);\n  vec3 rayDirection2 = cross(rayDirection1, vec3(0.0, -1.0, 0.0));\n  vec3 rayDirection3 = cross(rayDirection1, rayDirection2);\n\n  vec3 rayDirection = normalize(rayDirection1 + uv.x * rayDirection2 + uv.y * rayDirection3);\n\n  float t;\n  const float lightRadius = 5.0e-2;\n\n  if (ballIntersection(eye, rayDirection, ballCenter, ballRadius, t))\n  {\n    return vec4(ballColor(lightPosition, eye + t * rayDirection), 1.0);\n  }\n  else\n  {\n    return texture(iChannel0, rayDirection);\n  }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = fragCoord / iResolution.xy - 0.5;\n    \n  eye = vec3(eyeRadius * sin(eyeSpeed * iTime), 0.0, eyeRadius * cos(eyeSpeed * iTime));\n    \n  lightPosition = vec3(5.0, max(2.0, 10.0 - iTime), 5.0);\n    \n  // Output to screen\n  vec4 c = render(uv);\n  for (int j = -1; j < 2; ++j)\n  {\n    for (int i = 0; i < 2; ++i)\n    {\n        c += render(clamp(uv + vec2(float(i) / iResolution.x, float(j) / iResolution.y), -0.5, 0.5));\n    }\n  }\n\n  fragColor = 0.2 * c;\n}","name":"Image","description":"","type":"image"}]}