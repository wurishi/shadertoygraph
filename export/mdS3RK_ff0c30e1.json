{"ver":"0.1","info":{"id":"mdS3RK","date":"1667858117","viewed":259,"name":"Erode, Dilate and their mix","username":"Envy24","description":"Added masks based on norms, pixelation, and linear interpolation between erode and dilate.\n","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["filter","lp","norm","dilate","pixelization","erode","l1","l2","linf","motphologic"],"hasliked":0,"parentid":"NlyBDt","parentname":"Erode, Dilate and Blur, filter"},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define TO_TEX_COORDS(SC)         ( (SC) / (R.xy) )                  // in range x=[0.0; 1.0], y=[0.0; 1.0]\n#define TEX0(TC)                  ( texture(iChannel0, (TC)) )\n#define TEXF0(SC)                 ( texelFetch(iChannel0, ivec2(SC), 0) )  // (channel, integer coordinates, mipmap level)\n#define PIXELATE(SC, PS)          ( floor( (SC) / (PS) ) * (PS) )       // PS - pixel size\n//#define READ_PIXEL(SC)            ( TEX0(TO_TEX_COORDS(SC)) )\n#define READ_PIXEL(SC)            ( TEX0(TO_TEX_COORDS(PIXELATE(SC, 5.))) )\n\nfloat luminosity(vec4 color)\n{\n    //https://www.shadertoy.com/view/XdXSzX\n    //return (color.x + color.y + color.z) * 0.3333333;\n    /**/\n    vec4 sRGB = vec4(0.2126, .7152, 0.0722, 1.);\n    return dot(color, sRGB);\n    /**\n    vec4 SD_Tel = vec4(0.3, .59, 0.11, 1.);\n    return dot(color, SD_Tel);\n    /**/\n}\n\n// https://www.shadertoy.com/view/NtlBWr\n//#define MASK(c, r) ( 1. ) // bypass\n//#define MASK(c, r) ( length(vec2(c, r)) < O ? 1. : 0. ) // l2-norm\n#define MASK(c, r) ( abs(c) + abs(r) < O ? 1. : 0. ) // l1-norm\n//#define MASK(c, r) ( max(abs(c), abs(r)) < O ? 1. : 0. ) // linf-norm\n//#define EXP        ( 0.1 )\n//#define MASK(c, r) ( pow(pow(abs(c), EXP) + pow(abs(r), EXP), 1./(EXP)) < O ? 1. : 0. )\nvec4 erode(in vec2 SC, in float order)\n{\n    float O = order, min_ = 2., max_ = -1.;\n    vec4 min_c = vec4(0), max_c = vec4(0);\n\n    for (float r = -O; r <= O; r += 1.)\n    {\n        for (float c = -O; c <= O; c += 1.)\n        {\n            vec4 C = READ_PIXEL(SC + vec2(c, r)) * (2. - MASK(c, r));\n            float v = luminosity(C);\n            \n            min_ = min(min_, v); max_ = max(max_, v);\n            \n            min_c = min_ == v ? C : min_c;\n            max_c = max_ == v ? C : max_c;\n        }\n    }\n    \n    return min_c;\n}\nvec4 dilate(in vec2 SC, in float order)\n{\n    float O = order, min_ = 2., max_ = -1.;\n    vec4 min_c = vec4(0), max_c = vec4(0);\n\n    for (float r = -O; r <= O; r += 1.)\n    {\n        for (float c = -O; c <= O; c += 1.)\n        {\n            vec4 C = READ_PIXEL(SC + vec2(c, r)) * MASK(c, r);\n            float v = luminosity(C);\n            \n            min_ = min(min_, v); max_ = max(max_, v);\n            \n            min_c = min_ == v ? C : min_c;\n            max_c = max_ == v ? C : max_c;\n        }\n    }\n    \n    return max_c;                 // dilate\n}\nvec4 mixed(in vec2 SC, in float order)\n{\n    float O = order, min_ = 2., max_ = -1.;\n    vec4 min_c = vec4(0), max_c = vec4(0);\n\n    for (float r = -O; r <= O; r += 1.)\n    {\n        for (float c = -O; c <= O; c += 1.)\n        {\n            vec4 C = READ_PIXEL(SC + vec2(c, r));\n            float v = luminosity(C);\n            \n            min_ = min(min_, v); max_ = max(max_, v);\n            \n            min_c = min_ == v ? C : min_c;\n            max_c = max_ == v ? C : max_c;\n        }\n    }\n    \n    float t = sinOSC(-5., 5., iTime);\n    return mix(min_c, max_c, t);\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    float order = 2.;\n\n    //O = mixed(SC, order); return;\n    // Or with norm applied\n    O = mix(dilate(SC, order), erode(SC, order), sinOSC(-5., 5., iTime)); return;\n    /* Or separated with norm applied\n    O = \n        SC.x > R.x*0.5 ?\n            O = dilate(SC, order) :\n            O = erode(SC, order);\n    /**/\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}","name":"Common","description":"","type":"common"}]}