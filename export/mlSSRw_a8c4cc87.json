{"ver":"0.1","info":{"id":"mlSSRw","date":"1680021466","viewed":76,"name":"falling circles 1","username":"RandoMissilannya","description":"slow gravity-like  falling","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["falling","gravity","slow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Inspiration Lovely Stars\n//https://www.shadertoy.com/view/MlSSWV\n\n\n// normalized coords version:\n#define S(v,v0,r)  smoothstep( -1.5/R.y, 1.5/R.y, length(v-(v0)) - (r) )  \n// pixel coords version:\n#define S1(v,v0,r)  smoothstep( -1.5, 1.5, R.y* ( length(v-(v0)) - (r) )) \n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nstruct Surface {\n    float sd; // signed distance value\n    vec3 col; // color\n};\n\nSurface minSurface(Surface obj1, Surface obj2) {\n  // if inside both return left\n  if(obj2.sd<.001 && obj1.sd<.001) return obj1;\n  // return the one with the smallest distance\n  else if (obj2.sd < obj1.sd) return obj2; \n  \n  return obj1;\n}\n\nfloat sdCircle(vec2 uv, float r, vec2 offset) {\n    float d =length(vec2(uv.x - offset.x, uv.y - offset.y)) - r;\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Surface d_smallest =Surface(10.,vec3(0.0));\n\n    vec2 R = iResolution.xy;\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 p = (2.0*fragCoord-R)/R.y;\n    \n\n    int num_drops=192;  \n    float mod_value=float(num_drops)*.1 +.5;\n    \n    for(int i=0;i<num_drops;i++)\n    {\n        float ii = float(i);\n        float start_group= float(i) ;\n        float t = mod(iTime - start_group, mod_value) ;\n        \n        float rad_random=hash12(vec2(ii,ii));\n        float y_random  =rad_random;\n        float x_random=hash12(vec2(ii,ii*ii));\n        \n        //0.5 * 9.80665 * timeÂ² * damp   \n        float gravity1=  (0.5 * 9.80665 * t *t)*.16;\n        float radius=rad_random * .5;\n        float xoffset=x_random*4.-2.;\n\n        vec2 offset = vec2(xoffset,1.5+2.5*(y_random)-gravity1);\n\n        vec3 circColor=vec3(rad_random*.8,xoffset+y_random*.2,y_random*.6);\n        float d =sdCircle(p, radius, offset);\n        //Smoothstep seems slower here\n        //float d=S1(p,offset,radius);\n          \n        Surface d1 =Surface(d,circColor);\n        \n        //get the circle with smallest distance of all\n        d_smallest = minSurface(d_smallest, d1);\n        \n       }\n    //background\n    vec3 col = vec3(.4, 0.0256,.212);\n    col+= d_smallest.col * step(d_smallest.sd,.001);\n    //if(d_smallest.sd< .001 )\n    //    col = d_smallest.col;\n \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}