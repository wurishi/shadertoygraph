{"ver":"0.1","info":{"id":"tllfzN","date":"1596349013","viewed":84,"name":"FBM Tri","username":"yungdaveboi","description":"Based on https://iquilezles.org/articles/warp/warp.htm","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float powShape(float x) {\n    float x2 = abs(x);\n    x2 *= x2;\n    return 1. - x2;\n}\n\nmat4 rotationZ( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n\t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t0,\t1);\n}\n\nmat4 rotationX( in float angle ) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nmat4 rotationY( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n\t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\t\n}\n\nfloat sigmoid(float x) {\n    return tanh(x * 2.5);\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float a = textureLod(iChannel0,(p+vec2(0.5,0.5))/256.0,0.0).x;\n\tfloat b = textureLod(iChannel0,(p+vec2(1.5,0.5))/256.0,0.0).x;\n\tfloat c = textureLod(iChannel0,(p+vec2(0.5,1.5))/256.0,0.0).x;\n\tfloat d = textureLod(iChannel0,(p+vec2(1.5,1.5))/256.0,0.0).x;\n    return mix(mix( a, b,f.x), mix( c, d,f.x),f.y);\n}\n\nfloat fbm(vec2 x, float h, int iter) {\n    float g = exp2(-h);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for(int i = 0; i < iter; i++) {\n        t += a * (-1.0 + 2.0 * noise(x*f));\n        f *= 2.01;\n        a *= g;\n    }\n    \n    return t;\n}\n\nfloat sdEquilateralTriangle( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat fbmH(vec2 x) {\n \treturn fbm(x, 0.9, 5);   \n}\n\nfloat fbmH2(vec2 x) {\n \treturn fbm(x, 0.8, 4);   \n}\n\n// Harmonic Series Inspired Wave Synthesis\n// h_s := half-cycles per second (baseline)\n// gain_ratio := gain bias to tune distribution of normalized gain among frequencies\n// > Essentially, \"How much gain do I want to be allocated to base frequency?\"\n// > 0.5 is a solid default\n// > 0.6 gives g(f1) = 0.6, g(f2) = 0.20, g(f3) = 0.10, g(f4) = 0.05\n// > 0.4 gives g(f1) = 0.4, g(f2) = 0.30, g(f3) = 0.15, g(f4) = 0.08\n// > 0.1 gives g(f1) = 0.1, g(f2) = 0.45, g(f3) = 0.23, g(f5) = 0.12\n// > 0.9 gives g(f1) = 0.9, g(f2) = 0.05, g(f2) = 0.03, g(f1) = 0.01\n// > One can also use values x > 1, x < 0 though you're results might be wonky\n//\n// Total Gain(sum(x)) = 1.0,           for 0 <= gain_ratio <= 1.0\n// Gain g(1) = gain_ratio\n// Gain g(n) = 1.0 - gain_ratio^n      for n > 1\n// Base Freq = cycles_s * 2.0\n// Freq. of r(n) = base_freq * freq_ratio^n\n// sum(x) = E<n> [ g(n) * sin(x * r(n)) ]\nfloat h_synth(float x, float h_s, float freq_ratio, float gain_ratio) {\n    float PI = 3.1416;\n    float gain = gain_ratio;\n    float gain_numerator = abs(1.0 - gain_ratio);\n    float rem_gain = 1.0;\n    // 2 cancels out in 2.0*PI*x\n    // Since c_s is cycles per second\n    // (2 per period)\n    float w = 0.0;\n    float f = h_s;\n    float t = x * PI;\n    \n    for(int i = 1; i < 6; i++) {\n        float n = float(i);\n        w += gain * sin(t * f);\n        rem_gain -= gain;\n        gain = gain_numerator / 2.0;\n        gain_numerator /= 2.0;\n        f = f * freq_ratio;\n    }\n    w += rem_gain * sin(t * f);\n    return w;\n}\n\n/* Normal Distribution Inspired Wave Synthesis ( 100% Faked )\n * Z-score values picked pretty much at random in +0.4 intervals.\n *\n * base_f := Central frequency. In half-cycles per second (location parameter)\n * f_spread := Shape of distribution. 1.00 for default (scale parameter)\n * > Effectively controls the amount of gain at the mean (base frequency).\n * f_ratio := Ratio between base and high/low frequency e.g. ( base f. * 2.0 = high f. )\n */\nfloat norm_synth(float x, float base_f, float f_ratio, float f_spread) {\n    const int LOOP_MAX = 5;\n    float PI = 3.1416;\n    float w = 0.0;\n    float t = x * PI;;\n    float end = abs(base_f * f_ratio);\n    float ztable[6] = float[](\n        0.6554, 0.7881, 0.8849,\n        0.9452, 0.9772, 0.9918\n    );\n    float gdiff = 0.0;\n    for(int i = LOOP_MAX; i >= 0; i--) {\n        float fp = mix(base_f, end, float(i) / float(LOOP_MAX));\n        float fn = 2.0 * base_f - fp;\n        float gain = (1.0 - ztable[i] - gdiff) * f_spread;\n        gdiff += 2.0 * gain;\n        w += gain * sin(t * fp);\n        w += gain * sin(t * fn);\n    }\n    \n    w += (1.0 - gdiff) * sin(t * base_f);\n    return w;\n}\n\nvec2 fish(vec2 uv, float magic) {\n    float theta = atan(uv.y, uv.x);\n    float radius = length(uv);\n    radius = pow(radius, magic);\n    uv.x = radius * cos(theta);\n    uv.y = radius * sin(theta);\n    return 0.5 * (uv + 1.0);\n}\n\nfloat pattern(vec2 p, out vec2 q, out vec2 r) {\n    float s1 = h_synth(iTime + 3.145 * 6.0,  0.0410, 1.4,  0.35);\n    float s2 = h_synth(iTime + 3.145,  0.02295, 1.1,  0.50);\n    float s3 = h_synth(iTime + 3.145 / 8.0, 0.03175, 1.05, 0.50);\n    float s4 = h_synth(iTime + 3.145 / 4.0, 0.02265, 1.1,  0.50);\n    /*float s1 = norm_synth(iTime + 3.145 / 4.0 * 5.0,  0.00565, 150.0, 1.0);\n    float s2 = norm_synth(iTime + 3.145 / 8.0 * 10.0, 0.00595, 150.0, 1.0);\n    float s3 = norm_synth(iTime + 3.145 / 8.0 * 20.0, 0.00547, 150.0, 1.0);\n    float s4 = norm_synth(iTime + 3.145 / 4.0 * 30.0, 0.00596, 150.0, 1.0);*/\n \n    //p *= 0.97 + 0.03 * vec2(s1, -1.0 * s2);\n    //p += 0.03 * vec2(s1 * -1.0, s2);\n    \n    //p += vec2(0.29, 0.33);\n    //p = vec2(5.0 * h_synth(p.x, 0.1, 1.2, 0.4), 5.0 * h_synth(p.y, 0.1, 1.2, 0.4));\n    //p = vec2(cos(p.y * 2.0), cos(p.x * 2.0));\n    //p = fish(p, 1.5);\n  \t//p *= vec2(s2, s1);\n    q = 0.5 + 0.5 * vec2(\n        fbmH( p * 4.0 ), // + vec2(0.43, 0.37) * s4),\n        fbmH( p * 4.0 ) //+ vec2(0.35, 0.41) * s3)\n        );\n    \n    r = q * 0.85 + 0.15 * mix(s1, s2, cos(10.0*s3)); ;// + 0.025 * -1.0 * vec2(s3, s4);\n    r = 0.5 + 0.5 * vec2(\n        fbmH2(r * 6.2),// + s4 * vec2(0.29, 0.13)),\n        fbmH2(r * 6.2) // + s3 * vec2(0.14, 0.31))\n        );\n    \n    return fbmH(1.53 * r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // Pallette\n    /*\n    vec3 col1 = vec3(0.125, 0.251, 0.317);\n    vec3 col2 = vec3(0.231, 0.412, 0.471);\n    vec3 col3 = vec3(0.518, 0.662, 0.674);\n    vec3 col4 = vec3(0.894, 0.890, 0.890);\n    vec3 col5 = vec3(0.965, 0.859, 0.482);\n    */\n    vec3 col1 = vec3(0.952, 0.568, 0.537);\n    vec3 col2 = vec3(0.733, 0.501, 0.509);\n    vec3 col3 = vec3(0.431, 0.458, 0.509);\n    vec3 col4 = vec3(0.015, 0.396, 0.509);\n    vec3 col5 = vec3(0.965, 0.859, 0.482);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // FBM\n\tvec2 q, r;\n    float f = pattern(uv, q, r);\n    \n    // FBM Color Mixing\n    vec3 col = col1;\n    col = mix( col, col2, dot(q, q));\n    col = mix( col, col3, dot(r, q));\n    col = mix( col, col4, f);\n    //col = mix( col, col4, dot(r,r));\n    //col = mix( col, col5, f);\n    \n    \n    // Draw signed distance function (distance to edge)\n    vec2 uv_tri = uv * 4. - vec2(2.);\n    // Triangle Position\n    vec2 uv_t1 = vec2(uv_tri.x - 0.6, uv_tri.y - 0.6);\n    vec2 uv_t2 = vec2(uv_tri.x + 0.6, uv_t1.y + 0.6);\n    vec2 uv_t3 = vec2(uv_tri.x - 0.6, uv_t2.y + 0.6);\n    vec2 uv_t4 = vec2(uv_tri.x + 0.6, uv_t3.y + 0.6);\n    \n    vec4 uv_tir1 = 1.00 * vec4(uv_t1.x , uv_t1.y, 1.0, 1.0) * rotationZ(2.0*3.14/8.0 * iTime * -0.5);\n    vec4 uv_tir2 = 1.50 * vec4(uv_t2.x , uv_t2.y, 1.0, 1.0) * rotationZ(3.14 + 2.0*3.14/8.0 * iTime * 0.5);\n    vec4 uv_tir3 = 1.75 * vec4(uv_t3.x , uv_t3.y, 1.0, 1.0) * rotationZ(3.14 * 1.5 + 2.0*3.14/8.0 * iTime * -0.5);\n    vec4 uv_tir4 = 1.0 * vec4(uv_t4.x , uv_t4.y, 1.0, 1.0) * rotationZ(3.14 * 0.75 + 2.0*3.14/8.0 * iTime * -0.5);\n    uv_t1 = uv_tir1.xy;\n    uv_t2 = uv_tir2.xy;\n    uv_t3 = uv_tir3.xy;\n    uv_t4 = uv_tir4.xy;\n    \n    // SDF\n    float d1 = sdEquilateralTriangle(uv_t1);\n    float d2 = sdEquilateralTriangle(uv_t2);\n    float d3 = sdEquilateralTriangle(uv_t3);\n    float d4 = sdEquilateralTriangle(uv_t4);\n    // Quantize SDF output to [0, 1]\n    float s1 = ceil((1. - sign(d1)) / 2.);\n    float s2 = ceil((1. - sign(d2)) / 2.);\n    float s3 = ceil((1. - sign(d3)) / 2.);\n    float s4 = ceil((1. - sign(d4)) / 2.);\n    float tri_check = floor(s1 + s2 + s3 + s4);\n   \n    if(tri_check > 0.001) {\n        // Mix triangle colors\n        vec3 colsd = col;\n        colsd = mix(colsd, col1, s4);\n        colsd = mix(colsd, col2, s3);\n        colsd = mix(colsd, col5, s2);\n        colsd = mix(colsd, col3, s1);\n        colsd = mix(colsd, col5, pattern(uv * 0.1, r, q) * 0.5);\n        colsd = mix(colsd, col3, (1.0 - pattern(uv * 0.1, r, q)) * 0.1);\n        col = colsd;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}