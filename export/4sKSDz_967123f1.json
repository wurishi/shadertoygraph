{"ver":"0.1","info":{"id":"4sKSDz","date":"1463842477","viewed":342,"name":"Tame Impala","username":"ottopo","description":"Inspired by Tame Impala artwork\nOttavio Hartman - 2016","likes":4,"published":1,"flags":64,"usePreview":0,"tags":["tame","impala"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"lsfGWf","filepath":"https://soundcloud.com/racso2099/the-less-i-know-the-better-vinyl","previewfilepath":"https://soundcloud.com/racso2099/the-less-i-know-the-better-vinyl","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Ottavio Hartman - hartmano@sas.upenn.edu - https://github.com/omh1280\n\n#define PI 3.1415927\n#define NUM_STREAKS 12.\n#define STREAK_SIZE .15\n#define STREAK_WIDTH .3\n\n// HSV to RGB created by inigo quilez - iq/2014\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 _rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), _rgb, c.y);\n}\n\n// Cartesian and Polar conversions\nvec2 c2p(vec2 c) {\n    return vec2(length(c), atan(c.y, c.x));\n}\nvec2 p2c(vec2 p) {\n    return p.x*(vec2(cos(p.y), sin(p.y)));\n}\n\n// Rand and noise function. Credit to patriciogonzalezvivo\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\nfloat noise(float p){\n    float fl = floor(p);\n  \tfloat fc = fract(p);\n    return mix(rand(fl), rand(fl + 1.0), fc);\n}\n\n// Basic circle function\nfloat circle(vec2 uv, vec2 center, float radius) {\n    float delta = abs(noise(iTime))/30. + .01;\n    return smoothstep(radius + delta, radius - delta, length(uv - center));\n}\n\nfloat head(vec2 uv, vec2 center, float radius) {\n    vec2 uv2 = uv - center;\n    uv2.x /= .78;\n    \n    // Create cool \"expanding head\" technique\n    float sound = texture(iChannel0, vec2(abs(uv2.x*sin(uv2.y)), .25)).x;\n    uv2 *= 2.*noise(iTime*.5 + sound);\n    \n    // Create the head itself\n    vec2 rtheta = c2p(uv2);\n    float angle = rtheta.y;\n    float neck = 1.*pow(angle + .2, 2.) + .66;\n    float chin = .08*sin(7.*angle) + .92;\n    float face = .98 + sin((angle+.45)*7.)/22.;\n    \n    if ((angle < PI/10.) && (angle > -PI/4.)) {\n        uv2 /= neck;\n    } else if ((angle > PI/1.64) || (angle < -PI/1.03)) {\n\t\tuv2 /= face;\n    } else if (angle < -PI/2.) {\n        uv2 /= chin;\n    } else if ((angle < PI/1.64) && (angle > PI/10.)) {\n        // Cranium\n        uv2 /= .94;\n    }\n    \n    return circle(uv2 + center, center, radius);\n}\n\nfloat streak(vec2 uv, vec2 center, float radius) {\n    vec2 rtheta = c2p(uv);\n    vec2 center_p = c2p(center);\n    \n    // Make streaks skinny\n    rtheta.y -= (center_p.y - rtheta.y)/STREAK_WIDTH;\n    \n    // Waviness\n    rtheta.y += .1*noise(rtheta.x*60. + sin(rtheta.y));\n    \n    return circle(p2c(rtheta), center, radius);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.yy;\n    float maxX = iResolution.x/iResolution.y;\n\n    vec2 center = vec2(.5*maxX, .5);\n    vec2 rtheta = c2p(uv - center);\n    \n    // STREAKS\n    float radius = PI/(NUM_STREAKS*.5);\n    // Streaks' displacement away from head center\n    float disp = mod(.25*iTime, 1.);\n    // Repeat streaks in a circle\n    rtheta.y = mod(rtheta.y - .3*iTime, radius) - radius/2.;\n    vec2 uv2 = p2c(rtheta);\n    float i = streak(uv2, vec2(disp, 0.), STREAK_SIZE);\n    \n    // HEAD\n    float h = head(uv, center, .3);\n\n    // TRIPPY\n    vec3 pixel = vec3(0.08, 0.08, 0.15);\n    \n    // Streak colors (change as disp increases)\n    pixel = mix(pixel, hsv2rgb(vec3(disp, .73, 1.)), i*(length(uv2)));\n    \n    // Head color\n    vec3 pale = vec3(1.0, .88, .70);\n    pixel = mix(pixel, pale, h);\n    \n    // Trippy background\n\tfloat sound = texture(iChannel0, vec2(abs(uv2.x*sin(uv2.y)), .25)).x;\n\n    for (float i = 0.; i < 5.; i++) {\n    \tuv2 = p2c(c2p(uv2) + vec2(sin(.1*iTime), sin(.4*iTime*i)));\n    \tpixel += .1*(noise(iTime + noise(iTime*sin(uv2.x/uv2.y))*sin(uv2.x*10.)*rtheta.y)+ \n             noise(iTime*i + noise(iTime*sin(uv2.x+uv2.y))*sin(uv2.y*20.*i)*sound*i));\n    }\n    // More colors\n    pixel *= vec3(3.*noise(.1*iTime*(uv2.x * uv2.y)), 2.*noise(sound), sound);\n    \n    fragColor = vec4(pixel, 1.0);\n}","name":"Image","description":"","type":"image"}]}