{"ver":"0.1","info":{"id":"lsc3RM","date":"1448556987","viewed":376,"name":"Little Raytracer","username":"Draedrus","description":"A little show of some works I am doing as a hobby.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["noise","raytracer","smoke","cubemapping","environmentmapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"/**\n* author: Pierre-Marie Plans\n* mail: pierre.plans@gmail.com\n**/\n\n#define OCTAVES 4\n#define DIST_FOG 6.0\n#define FOG_SPEED_FACTOR 0.03\n#define MAX_T 99999.0\n//#define DO_ANTIALIASING\n\nstruct Sphere {\n    vec3 c;\n    float r;\n    vec4 color;\n};\n    struct Plane {\n        vec3 o;\n        vec3 n;\n        vec4 color;\n    };\n        struct Ray {\n            vec3 o;\n            vec3 d;\n        };\n            struct Light {\n                vec3 o;\n                vec3 d;\n                vec4 diffuseColor;\n                float shininess;\n                float specularPower;\n            };\n                struct Scene {\n                    Sphere sphs[4];\n                    Plane ps[4];\n                    int ns;\n                    int np;\n                };\n\nvec4 ambientColor = vec4(0.2, 0.2, 0.4, 1.0);\nScene scene;\n\nfloat rand(vec3 co){\n    return fract(sin(dot(co.xyz ,vec3(12.9898,78.233, 34.49584))) * 43758.5453);\n}\n/**\n * noise and smoothNoise function were inspired by common knowledge found in internet.\n **/\nfloat noise(float x) {\n    return fract(sin(x)*556858.4905705783);\n}\n\n/**\n * Inspired from a noisy function in \"Seascape\" by TDM\n **/\nfloat smoothNoise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 n = fract(x);\n    vec3 f = n*n*(3.0-2.0*n);\n    float winy = 157.0;\n    float winz = 113.0;\n    \n    float wx = p.x+winy*p.y+winz*p.z;\n    return mix(\n        \tmix(\n                mix(noise(wx+0.0)     ,      noise(wx+1.0), f.x),\n                mix(noise(wx+0.0+winy), noise(wx+1.0+winy), f.x),\n                f.y),\n        \tmix(\n                mix(noise(wx+0.0+winz)     ,      noise(wx+1.0+winz), f.x),\n                mix(noise(wx+0.0+winy+winz), noise(wx+1.0+winy+winz), f.x),\n                f.y)\n        , f.z);\n}\n\n/**\n * This one is inspired by IQ code from this website.\n **/\nfloat perlin(vec3 V) {\n    float total = 0.0;\n    for(int i=2;i<OCTAVES+2;i++) {\n        total += (1.0/float(i))*smoothNoise(V);\n        V*=2.0+(float(i)/100.0);\n    }\n    return total;\n}\n\nfloat _notreallyperpdot(vec3 a, vec3 b) {\n    return a.x*b.z-a.y*b.x-a.z*b.y;\n}\n\nfloat IntersectRay(Ray r1, Ray r2) {\n    vec3 a = r1.o+r1.d;\n    vec3 b = r2.o+r2.d;\n    vec3 c = a-b;\n    return _notreallyperpdot(c, a)/_notreallyperpdot(a, b);\n}\n\nfloat LineIntersectLine(vec3 a, vec3 b) {\n    vec3 c = a-b;\n    return _notreallyperpdot(c, a)/_notreallyperpdot(a, b);\n}\n\nfloat IntersectPlane(Ray r, Plane p) {\n    float Vd = dot(r.d, p.n);\n    float t = -1.0;\n    float d = -1.0;\n    if(Vd<0.0) {\n        float V0 = -(dot(p.n, r.o)+length(p.o-r.o));\n        float t = V0/Vd;\n        if(t>=0.0) {\n            d = t;\n        }\n    }\n    return d;\n}\n\nfloat IntersectSphere(Ray r, Sphere s) {\n    vec3 Z = r.o-s.c;\n    float A = 1.0;//r.d.x*r.d.x+r.d.y*r.d.y+r.d.z*r.d.z; // 1.0 if r.d normalized\n    float B = 2.0 * dot(r.d, Z);//(r.d.x * (r.o.x - s.c.x) + r.d.y * (r.o.y - s.c.y) + r.d.z * (r.o.z - s.c.z));\n    float C = Z.x*Z.x+Z.y*Z.y+Z.z*Z.z-s.r*s.r;//(r.o.x - s.c.x)*(r.o.x - s.c.x) + (r.o.y - s.c.y)*(r.o.y - s.c.y) + (r.o.z - s.c.z)*(r.o.z - s.c.z) - s.r*s.r;\n    float D = B*B - 4.0*C;\n    float t = -1.0;\n    float d = -1.0;\n    if(D>=0.0) {\n        /*t = (- B - sqrt(D)) / 2.0;\n        if(t>0.0) { // okay this is the closest one\n        }else{ // nope we recompute\n            t = (- B + sqrt(D)) / 2.0;\n        }\n        d = t;*/\n        // self-made optimisation only one sqrt in both cases\n        if(C>0.0) {\n            d = (-B-sqrt(D))/2.0;\n        }else{\n            d = (-B+sqrt(D))/2.0;\n        }\n    }\n    return d;\n}\n\n// adapted from https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model\nvec4 blinnPhong(vec4 bColor, Light l, vec3 normal, vec3 vV) {\n    vec3 N = normalize(normal);\n    float lambertTerm = max(dot(-l.d, N), 0.0);\n    float specular = 0.0;\n    float shininess = 16.0;\n    float screenGamma = 2.2;\n\n    if(lambertTerm>0.0) {\n        vec3 viewDir = normalize(vV);\n\n        vec3 halfDir = normalize(-l.d+vV);\n        float specAngle = max(dot(halfDir, N), 0.0);\n        specular = pow(specAngle, l.shininess);\n    }\n    vec4 colorLinear = ambientColor +\n        lambertTerm * bColor + // diffuse color\n        specular * vec4(1.0); // specular color\n    vec3 colorGammaCorrected = pow(colorLinear.xyz, vec3(1.0/screenGamma));\n    return vec4(colorGammaCorrected, 1.0);\n}\n\nvec2 raycast(Ray r) {\n    vec2 ret = vec2(MAX_T, -1.0);\n    float t = MAX_T;\n    t = IntersectPlane(r, scene.ps[0]);\n    if(t>0.0 && t<ret.x) {\n        ret.x = t;\n        ret.y = 0.0;\n    }\n    t = IntersectSphere(r, scene.sphs[0]);\n    if(t>0.0 && t<ret.x) {\n        ret.x = t;\n        ret.y = 1.0;\n    }\n    t = IntersectSphere(r, scene.sphs[1]);\n    if(t>0.0 && t<ret.x) {\n        ret.x = t;\n        ret.y = 2.0;\n    }\n    t = IntersectSphere(r, scene.sphs[2]);\n    if(t>0.0 && t<ret.x) {\n        ret.x = t;\n        ret.y = 3.0;\n    }\n    t = IntersectSphere(r, scene.sphs[3]);\n    if(t>0.0 && t<ret.x) {\n        ret.x = t;\n        ret.y = 4.0;\n    }\n    return ret;\n}\n\nvec4 foggy(vec4 c, vec3 p, float y) {\n    vec4 fogColor = vec4(0.4, 0.7, 0.4, 1.0);\n    p.z = p.z+cos(iTime*FOG_SPEED_FACTOR);\n    c = mix(c, vec4(perlin(p*6.0)*fogColor), y);\n    c = mix(c, vec4(perlin(p*2.0)*fogColor), y);\n    c = mix(c, vec4(perlin(p*4.0)*fogColor), y);\n    return clamp(c, 0.0, 1.0);\n}\n\nfloat scat(Ray r, vec3 lo) {\n    // scattering\n    vec3 pos = (r.o+r.d)*smoothNoise(vec3(iTime))*0.05;\n    vec3 step = r.d*7.0/50.0;\n    float illum = 0.0;\n    for(int i=0;i<50;i++) {\n        vec2 rrc = raycast(Ray(pos, normalize(lo-pos)));\n        if(rrc.x>0.0 && rrc.y<0.0) {\n            float t = rrc.x/MAX_T;\n            illum += 1.0/50.0;\n        }\n        pos+=step;\n    }\n    return illum;\n}\n\nvec4 pixColorNoReflexion(vec2 rcast, Ray r, Light l, vec3 viewV) {\n    vec4 pColor = texture(iChannel1, r.d*vec3(4.0, 4.0, 1.0));\n    if(rcast.x>0.0 && rcast.x<MAX_T && rcast.y>=0.0) {\n        vec3 normal = vec3(0.0);\n        vec3 pt = r.o+r.d*(rcast.x-0.01);\n        if(rcast.y==0.0) {\n            vec4 texColor = texture(iChannel0, pt.xz/5.0);\n            pColor = texColor;\n            if(rcast.x>DIST_FOG) {\n                float y = max(1.0+r.d.y*DIST_FOG, 0.0);\n                pColor = foggy(pColor, r.d, y);\n            }\n            // check if objects shadowing:\n            Ray rr = Ray(pt, vec3(0.0));\n            rr.d = normalize(l.o-rr.o);\n            //normal = scene.ps[0].n+texture(iChannel1, pt.xz/5.0).xyz;\n            vec2 rrc = raycast(rr);\n            if(rrc.x>0.0 && rrc.x<MAX_T && rrc.y>=0.0) {\n                pColor = mix(pColor, vec4(0.0), 0.5);\n            }\n        }else if(rcast.y>0.0) {\n            if(rcast.y==1.0) {\n                pColor = scene.sphs[0].color;\n                normal = pt - scene.sphs[0].c;\n            }else if(rcast.y==2.0) {\n                pColor = scene.sphs[1].color;\n                normal = pt - scene.sphs[1].c;\n            }else if(rcast.y==3.0) {\n                pColor = scene.sphs[2].color;\n                normal = pt - scene.sphs[2].c;\n            }else if(rcast.y==4.0) {\n                pColor = scene.sphs[3].color;\n                normal = pt - scene.sphs[3].c;\n            }\n            pColor = blinnPhong(pColor, l, normal, viewV);\n        }\n        if(rcast.x>DIST_FOG) {\n            float y = min(max(1.0+r.d.y*DIST_FOG, 0.0), 1.0);\n            pColor = foggy(pColor, r.d, y);\n        }\n    }else if(r.d.y<0.5){\n        float y = pow((0.5-r.d.y)*2.0, 8.0);\n    \ty = y +max(r.d.x*cos(iTime), 0.0)/16.0;\n        return foggy(pColor, r.d, y);\n    }\n    return pColor;\n}\n\nvec4 pixColor(vec2 rcast, Ray r, Light l, vec3 viewV) {\n    vec4 pColor = texture(iChannel1, r.d*vec3(4.0, 4.0, 1.0));\n    if(rcast.x>0.0 && rcast.x<99999.0 && rcast.y>=0.0) {\n        vec3 normal = vec3(0.0);\n        vec3 pt = r.o+r.d*(rcast.x-0.01);\n        if(rcast.y==0.0) {\n            vec4 texColor = texture(iChannel0, pt.xz/5.0);\n            pColor = texColor;\n            // check if objects shadowing:\n            Ray rr = Ray(pt, vec3(0.0));\n            rr.d = normalize(l.o-rr.o);\n            //normal = scene.ps[0].n+texture(iChannel1, pt.xz/5.0).xyz;\n            vec2 rrc = raycast(rr);\n            if(rrc.x>0.0 && rrc.x<99999.0 && rrc.y>=0.0) {\n                pColor = mix(pColor, vec4(0.0), 0.5);\n            }\n        }else if(rcast.y>0.0) {\n            if(rcast.y==1.0) {\n                pColor =  scene.sphs[0].color;\n                normal = pt - scene.sphs[0].c;\n            }else if(rcast.y==2.0) {\n                pColor =  scene.sphs[1].color;\n                normal = pt - scene.sphs[1].c;\n            }else if(rcast.y==3.0) {\n                pColor =  scene.sphs[2].color;\n                normal = pt - scene.sphs[2].c;\n            }else if(rcast.y==4.0) {\n                pColor =  scene.sphs[3].color;\n                normal = pt - scene.sphs[3].c;\n            }\n            pColor = blinnPhong(pColor, l, normal, viewV);\n            Ray rr = Ray(pt, vec3(1.0));\n            rr.d = normalize(reflect(normalize(r.d), normalize(normal)));\n            vec2 rrc = raycast(rr);\n            pColor = mix(pColor, pixColorNoReflexion(rrc, rr, l, viewV), 0.5);\n        }\n        //pColor*=scat(r, l.o);\n        if(rcast.x>DIST_FOG) {\n            float y = min(max(1.0+r.d.y*DIST_FOG, 0.0), 1.0);\n            pColor = foggy(pColor, r.d, y);\n        }\n    }else{\n        float y = pow((0.5-r.d.y)*2.0, 8.0);\n    \ty = y +max(r.d.x*cos(iTime), 0.0)/16.0;\n        return foggy(pColor, r.d, y);\n    }\n    return pColor;\n}\n\n// the camera construction method is inspired by the one from IQ\nmat3 setCamera( in vec3 origin, in vec3 target, vec3 viewUp )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cu = normalize( cross(cw,viewUp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 centerscreen = vec2(0.5, 0.5);\n    vec2 pixel = (-iResolution.xy + 2.0*fragCoord.xy)/ iResolution.y;\n    vec2 mv = (iMouse.xy/iResolution.xy)-centerscreen;\n    float Time = mod(iTime, 360.0);\n    Light l = Light(\n        vec3(0.0, 4.0, 0.0),\n        vec3(0.0, -4.0, 0.0),\n        vec4(1.0, 1.0, 1.0, 1.0),\n        16.0,\n        2.0);\n    l.d = normalize(vec3(0.0)-l.o);\n    Light l2 = Light(\n        vec3(2.0, 4.0, 0.0),\n        vec3(0.0, -4.0, 0.0),\n        vec4(1.0, 1.0, 1.0, 1.0),\n        16.0,\n        2.0);\n    l2.d = normalize(vec3(0.0)-l2.o);\n    scene.sphs[0] = Sphere(\n        vec3(0.0, 0.0, 5.0),\n        0.3,\n        vec4(0.0, 0.0, 1.0, 1.0));\n    scene.sphs[1] = Sphere(\n        vec3(-0.5, 0.0, 5.0),\n        0.15,\n        vec4(0.0, 1.0, 0.0, 1.0));\n    scene.sphs[2] = Sphere(\n        vec3(0.5, 0.0, 5.5),\n        0.2,\n        vec4(1.0, 1.0, 0.0, 1.0));\n    scene.sphs[3] = Sphere(\n        vec3(cos(Time), sin(Time*4.0+2.8)/4.0+0.2, sin(Time)+5.0),\n        0.15,\n        vec4(0.0, 1.0, 1.0, 1.0));\n    scene.ns = 4;\n    scene.ps[0] = Plane(\n        vec3(0.0, 0.0, 0.0),\n        normalize(vec3(0.0, 1.0, 0.0)),\n        vec4(0.4, 0.6, 0.5, 1.0));\n    scene.np = 1;\n    \n    Ray r = Ray(vec3(0.0, 0.0, -1.0), vec3(pixel, 2.0));\n    //mat3 ca = mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0));\n    mat3 ca = setCamera(r.o, vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 0.0));\n\n    #ifdef DO_ANTIALIASING\n        Ray r1 = Ray(r.o, ca*normalize(r.d-r.o+vec3(-1.0/iResolution.x, 0.0, 0.0)));\n        Ray r2 = Ray(r.o, ca*normalize(r.d-r.o+vec3(1.0/iResolution.x, 0.0, 0.0)));\n        Ray r3 = Ray(r.o, ca*normalize(r.d-r.o+vec3(0.0, -1.0/iResolution.y, 0.0)));\n        Ray r4 = Ray(r.o, ca*normalize(r.d-r.o+vec3(0.0, 1.0/iResolution.y, 0.0)));\n\n        vec3 vV = ca*normalize(r.d-r.o);\n\n        vec2 rc1 = raycast(r1);\n        vec2 rc2 = raycast(r2);\n        vec2 rc3 = raycast(r3);\n        vec2 rc4 = raycast(r4);\n\n        vec4 pColor1 = mix(pixColor(rc1, r1, l, vV), pixColor(rc1, r1, l2, vV), 0.5);\n        vec4 pColor2 = mix(pixColor(rc2, r2, l, vV), pixColor(rc2, r2, l2, vV), 0.5);\n        vec4 pColor3 = mix(pixColor(rc3, r3, l, vV), pixColor(rc3, r3, l2, vV), 0.5);\n        vec4 pColor4 = mix(pixColor(rc4, r4, l, vV), pixColor(rc4, r4, l2, vV), 0.5);\n\n        vec4 antialiasedColor = mix(pColor1, mix(pColor2, mix(pColor3, pColor4, 0.5), 0.5), 0.5);\n\n        fragColor = antialiasedColor;\n    #else\n    \tr.d = ca*normalize(r.d-r.o);\n        vec3 vV = r.d;\n        vec2 rc = raycast(r);\n        fragColor = mix(pixColor(rc, r, l, vV), pixColor(rc, r, l2, vV), 0.5);\n    #endif\n}","name":"","description":"","type":"image"}]}