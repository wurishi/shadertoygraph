{"ver":"0.1","info":{"id":"wsycRG","date":"1603119224","viewed":347,"name":"Spherical and Geodesic line","username":"lzjseed","description":"Try to drag the mouse on the surface and draw the geodesic line.\n","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarch","lighting","drawline","sphericalcoordinatesystem","surfaceuv"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define max_distance (100.0)\n#define sphere_info vec4(0.0,0.0,0.0,0.7)\n#define rot(d) rotY(d)*rotX(-0.46)*rotZ(-0.3)\n#define invRot(d) rotZ(0.3)*rotX(0.46)*rotY(-d)\n\n#if 1\n#define AA (1)\n#else\n#define AA (0)\n#endif\n\nmat3 rotZ(float d)\n{\n    float s = sin(d);\n    float c = cos(d);\n    \n    return mat3(c,-s,0,\n                s,c,0,\n                0,0,1);\n}\n\nmat3 rotY(float d)\n{\n    float s = sin(d);\n    float c = cos(d);\n    \n    return mat3(c,0,-s,\n                0,1,0,\n                s,0,c);\n}\n\nmat3 rotX(float d)\n{\n    float s = sin(d);\n    float c = cos(d);\n    \n    return mat3(1,0,0,\n                0,c,-s,\n                0,s,c);\n}\n\nmat3 cameraSetup(vec3 forward,vec3 up)\n{\n    vec3 right = normalize(cross(up,forward));\n    up = normalize(cross(forward,right));\n    \n    return mat3(right,up,forward);\n}\n\nfloat drawSphere(vec3 p,vec3 o,float r)\n{\n    return length(p-o) - r;\n}\n\nfloat drawCapsule(vec3 p,vec3 a,vec3 b,float r)\n{\n    vec3 ap = p - a;\n    vec3 ab = b - a;\n    \n    vec3 c = a + ab * clamp(dot(ap,ab) / dot(ab,ab),0.0,1.0);\n    return length(c - p) - r;\n}\n\nvec2 opU(vec2 a,vec2 b)\n{\n    return a.x < b.x ? a : b; \n}\n\nvec2 map(vec3 pos)\n{\n    vec4 sphere = sphere_info;\n    \n    pos = rot(iTime) * pos;\n    \n    vec2 d1 = vec2(drawSphere(pos,sphere.xyz,sphere.w),0.1);\n    \n    vec3 posA = vec3(0.0,0.9,0.0);\n    vec3 posB = vec3(0.0,-0.9,0.0);\n    \n    vec2 d2 = vec2(drawCapsule(pos,posA,posB,0.05),1.1);\n    \n    return opU(d1,d2);\n}\n\nfloat geodesic(vec3 p1,vec3 p2,vec3 wp)\n{\n    if(length(p1-p2) < 0.0001) return 0.0;\n    \n    //world to object\n    vec3 op1 = rot(iTime) * p1;\n    vec3 op2 = rot(iTime) * p2;\n    \n    vec3 op = vec3(0.0, (dot(op1,op1) - dot(op2,op2)) / (2.0 * (op1.y - op2.y)) ,0.0);\n    \n    vec3 p = invRot(iTime) * op;\n    \n    vec3 up = normalize(cross(p-p1,p-p2));\n    \n    up = length(up) < 0.5 ? invRot(iTime) * vec3(0.0,1.0,0.0) : up;\n    \n    vec3 wpd = normalize(wp - p);\n    \n    float x = abs(dot(up,wpd));\n    \n    vec3 forward = normalize((p1 + p2) * 0.5 - p);\n    \n    forward = length(forward) < 0.5 ? invRot(iTime) * vec3(0.0,0.0,-1.0) : forward;\n    \n    float y = dot(forward,wpd);\n    float y0 = dot(forward,normalize(p1 - p));\n    \n    if(x < 0.01 && y > y0) return 1.0;\n    \n    return 0.0;\n}\n\nfloat softShadow(vec3 pos,vec3 nor,vec3 dir)\n{\n    float minValue = 0.0001;\n    float maxValue = 10.0;\n    float t = 0.0;\n   \n    pos = pos + nor * 0.1;\n    \n    for(int i = 0; i < 10; ++ i)\n    {\n        vec2 hit = map(pos + dir * t);\n        if(hit.x < minValue) break;\n        \n        t += hit.x;\n        if(t > maxValue) break;\n    }\n    \n    return clamp(t / maxValue,0.0,1.0);\n}\n\nvec3 calNormal(vec3 p)\n{\n    float h = 0.000001;\n    vec2 k = vec2(1.0,-1.0);\n    \n    return normalize(k.xxx * map(p + k.xxx * h).x \n                   + k.xyy * map(p + k.xyy * h).x\n                   + k.yxy * map(p + k.yxy * h).x\n                   + k.yyx * map(p + k.yyx * h).x);\n}\n\nvec2 raymarching(vec3 pos,vec3 dir)\n{\n    float near = 0.001;\n    float minValue = 0.0001;\n    float maxValue = 100.0;\n    float t = near;\n    float material = -1.0;\n    \n    for(int i = 0; i < 100; ++ i)\n    {\n        vec2 hit = map(pos + dir * t);\n        material = hit.y;\n        if(hit.x < minValue) break;\n        \n        t += hit.x;\n        if(t > maxValue) break;\n    }\n    \n    if(t > maxValue) return vec2(-1.0,-1.0);\n    return vec2(t,material);\n}\n\nvec2 calSphereUV(vec3 pos)\n{\n    pos = rot(iTime) * pos;\n    \n    vec4 sph = sphere_info;\n    \n    vec3 dir = normalize(pos - sph.xyz);\n    vec2 dir2 = normalize(dir.xz); \n    \n    return acos(vec2(dir2.y,dir.y)) / 3.1415926;\n}\n\nfloat calCapsuleUV(vec3 pos)\n{\n    pos = rot(iTime) * pos;\n    \n    vec4 sph = sphere_info;\n    \n    vec3 dir = normalize(pos - sph.xyz);\n    vec2 dir2 = normalize(dir.xz); \n    \n    float d = acos(dir2.y) / 3.1415926;\n    \n    if(dir2.x < 0.0)\n    {\n        d = 2.0 - d;\n    }\n    \n    return d * 0.5;\n}\n\nfloat renderTouchPoint(bool isHit,vec2 hit2,vec3 hitPos,vec3 pos,vec3 dir,out vec3 touchPos)\n{\n    if(isHit)\n    {\n        float dist = hit2.x;\n        float materialId = hit2.y;\n        if(dist >= 0.0 && materialId < 1.0)\n        {\n            vec3 objPos = pos + dir * dist;\n            \n            float t = 1.0 - smoothstep(0.03,0.031,length(objPos - hitPos));\n            \n            float t2 = 1.0 - smoothstep(0.0,0.01,abs(length(objPos - hitPos) - 0.06));\n            \n            touchPos = objPos;\n            \n            return max(t,t2);\n        }\n    }\n    \n    touchPos = vec3(0.0,0.0,0.0);\n    return 0.0;\n}\n\nvec3 render(vec3 pos,vec3 dir, out vec2 hit)\n{\n    hit = raymarching(pos,dir);\n    \n    float dist = hit.x;\n    vec3 skyCol = vec3(0.1,0.5,1.8);\n    \n    if(dist < 0.0)\n    {\n        //not hit anything\n        \n        return skyCol;\n    }\n    \n    float materialId = hit.y;\n    vec3 objPos = pos + dir * dist;\n    \n    vec3 baseCol = vec3(1.0);\n    if(materialId < 1.0)\n    {\n        baseCol = vec3(1.0,1.0,1.0);\n        \n        vec2 uv = calSphereUV(objPos);\n        \n        float u = smoothstep(0.07,0.12,abs(fract(uv.x * 10.0) * 2.0 - 1.0));\n        float v = smoothstep(0.07,0.12,abs(fract(uv.y * 10.0) * 2.0 - 1.0));\n        \n        baseCol *= u;\n        baseCol *= v;\n    }\n    else if(materialId < 2.0)\n    {\n        float u = calCapsuleUV(objPos);\n        \n        if(u < 1.0 / 3.0)\n        {\n            baseCol = vec3(1.0,0.0,0.0);\n        }\n        else if(u < 2.0 / 3.0)\n        {\n            baseCol = vec3(0.0,1.0,0.0);\n        }\n        else\n        {\n            baseCol = vec3(0.0,0.0,1.0);\n        }\n    }\n    \n    \n    vec3 litCol = vec3(1.0,1.0,1.0);\n    vec3 lit = normalize(vec3(-0.5,1.0,-0.1));\n   \n    vec3 nor = calNormal(objPos);\n   \n    float shadow = softShadow(objPos,nor,lit);\n    \n    float ndl = max(0.0,dot(lit,nor));\n    \n    return baseCol * litCol * ndl * shadow + skyCol * baseCol * 0.3;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2  mouseCoord = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y;\n    vec2  mouseCoord2 = (vec2(iMouse.z,abs(iMouse.w)) * 2.0 - iResolution.xy) / iResolution.y;\n    \n    \n    float z = -10.0;\n    vec3  cameraPos = vec3(0.0,0.0,z);\n    vec3  mousePos = vec3(mouseCoord.xy,0.0);\n    vec3  mousePos2 = vec3(mouseCoord2.xy,0.0);\n    \n    vec3  finalColor = vec3(0.0);\n    float n = 0.0;\n        \n    vec3  cameraViewDir = vec3(0.0,0.0,1.0);\n    mat3  viewToWorld = cameraSetup(cameraViewDir,vec3(0.0,1.0,0.0));\n\t\n    vec3 mouseDir1 = viewToWorld * normalize(mousePos - cameraPos);\n    vec3 mouseDir2 = viewToWorld * normalize(mousePos2 - cameraPos);\n        \n        \n    vec2 mouseHit1 = raymarching(cameraPos,mouseDir1);\n    vec2 mouseHit2 = raymarching(cameraPos,mouseDir2);\n    \n    for(int y = -AA; y <= AA; ++ y)\n    {\n    \tfor(int x = -AA; x <= AA; ++ x)\n        {\n            vec2  screenCoord = ((fragCoord + vec2(x,y)*0.25) * 2.0 - iResolution.xy) / iResolution.y;\n            \n            vec3  screenPos = vec3(screenCoord.xy,0.0);\n    \n            vec3  cameraRay = normalize(screenPos - cameraPos);\n            \n            vec3  dir = viewToWorld * cameraRay;\n            \n            vec2  hit;\n            \n            vec3  sceneColor = render(cameraPos,dir,hit);\n            \n            bool  isHit = hit.x >= 0.0 ? true : false;\n            \n            vec3  tarPos = isHit ? cameraPos + dir * hit.x : vec3(0.0);\n            \n            vec3  touchPos1;\n            vec3  touchPos2;\n\n            float alpha = renderTouchPoint(isHit,mouseHit1,tarPos,cameraPos,mouseDir1,touchPos1);\n            float alpha2 = renderTouchPoint(isHit,mouseHit2,tarPos,cameraPos,mouseDir2,touchPos2);\n\n            sceneColor = mix(sceneColor,vec3(1.0,0.0,0.0),alpha);\n            sceneColor = mix(sceneColor,vec3(1.0,0.0,0.0),alpha2);\n\t\t\t\n            if(mouseHit1.x > 0.0 && mouseHit1.y < 1.0 && mouseHit2.x > 0.0 && mouseHit2.y < 1.0 && iMouse.z > 0.0)\n            {\n                float alpha3 = geodesic(touchPos1,touchPos2,tarPos);\n            \tsceneColor = mix(sceneColor,vec3(1.0,0.0,0.0),alpha3);\n            }\n            \n            //gamma correct\n            sceneColor = pow(sceneColor,vec3(0.4545));\n            \n            finalColor += sceneColor;\n            n += 1.0;\n        }\n    }\n    \n    finalColor = finalColor / n;\n    \n    // Output to screen\n    fragColor = vec4(finalColor,1.0);\n}","name":"Image","description":"","type":"image"}]}