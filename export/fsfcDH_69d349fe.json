{"ver":"0.1","info":{"id":"fsfcDH","date":"1642070869","viewed":117,"name":"Base Sphere Raytrace","username":"maurice","description":"Very base example on how to raytrace sphere.Based on extremely beautiful and simple shader and relative tutorial by kig. The purpose of this shader is not to be as small as possibile but to write clear code useful for understand the math behind-the-scene.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","sphere"],"hasliked":0,"parentid":"ldS3DW","parentname":"Ray tracing sphere example"},"renderpass":[{"inputs":[],"outputs":[],"code":"/*****\n *\n * Very base example on how to raytrace sphere.Based on extremely beautiful and simple \n * shader and relative tutorial by kig. The purpose of this shader is not to be \n * as small as possibile but to write clear code useful for understand the math behind-the-scene.\n *\n *****/\n\n// colors\nconst vec3 skyColor = vec3( 0.4, 0.2, 1.0 );\nconst vec3 sunColor = vec3(2.0, 2.0, 0.5); // vec3( 0.8, 0.8, 0.2 );\nconst vec3 evenSquareColor = vec3( 0.7, 0.5, 0.6 );\nconst vec3 oddSquareColor = vec3( 0.7, 0.7, 0.7);\nconst vec3 sphereColor = vec3( 0.0, 0.9, 0.1 );\n\n// normals\nconst vec3 upDirection = vec3( 0.0, 1.0, 0.0 );\nconst vec3 groundOrigin = vec3( 0.0 );  // plane origin\nconst vec3 groundNormal = upDirection;  // plane normal\n\n#define OBLIQUE_FLOOR\n\n/** Finds the distance of a specified plane for a given ray\n *  @returns D if exists a point P in plane where P = rayOrigin + rayDirection * D\n *  @returns -1.0 if given ray does not intersect plane\n */\nfloat planeCollision( vec3 ro, vec3 rd, vec3 po, vec3 pn )\n{\n    // a point lays in a plane when dot( planeOrigin - p, planeNormal ) is zero\n    // for which d the expression (dot( (ro + rd * d) - po, pn )) is zero ?\n    // solving by d...:            dot( ro, pn ) + dot( rd, pn ) * d - dot( po, pn ) = 0 \n    float dist = dot( po - ro, pn ) / dot( rd, pn );\n    \n    float st = step( 0.0, -dot( rd, pn ) ); // dot( rd, -pn ) );\n    \n    return mix( -1.0, dist, st );\n}\n\n/** Returns the ground color given a point on it.\n */\nvec3 ground( vec3 point )\n{\n    return mix( vec3( 0.0 ),\n        mix( evenSquareColor, oddSquareColor,\n#ifndef OBLIQUE_FLOOR\n            mod( floor( point.z + iTime ) + floor( point.x ), 2.0 )\n#else\n            smoothstep( -0.01, 0.01, sin( point.z * 2.5 + iTime * 3. ) - cos( point.x * 2.5 + 1.9 ) )\n#endif\n        ),\n        smoothstep( 16., 0., distance( point, groundOrigin ) )\n    );\n}\n\n/**Returns the color of the envirornment given a ray and time\n */\nvec3 background( vec3 ro, vec3 rd, float time )\n{    \n    vec3 light = normalize( vec3( sin(time), 0.6, cos(time) ));\n    vec3 sunDirection = light;\n    \n    // sky factor: dot product with ray direction and up vector\n    float sky = pow( max( 0.0, dot( upDirection, rd ) ), 1.0 );\n    // sun factor: dot product with ray direction and light direction\n    float sun = max( 0.0, dot( rd, sunDirection ) );\n    float sunHaze = 64.0; // max( 2.0, 0.0 + (cos(t) * 256.0 ) );\n    // ground color\n    float groundDistance = planeCollision( ro, rd, groundOrigin, groundNormal );\n    vec3 groundColor = ground( ro + rd * groundDistance );\n    \n    return pow( sky, 0.50 ) * skyColor\n        + ( pow( sun, sunHaze ) + 0.2 * pow( sun, 2.0 ) ) * sunColor\n        + step( 0.0, groundDistance ) * groundColor;\n}\n\n/**Detects if a given ray collide with a sphere\n * @returns D distance from ray origin and the hit point on the surface of the sphere\n * @returns -1 if ray does not intersect the sphere\n */\nfloat sphereCollision( vec3 ro, vec3 rd, vec3 center, float r )\n{\n    // based on kig code\n    vec3 rc = ro - center;\n    float c = dot( rc, rc ) - ( r * r );\n    float b = dot( rd, rc );\n    float d = b*b - c;\n    float t = -b - sqrt(abs(d));\n    float st = step( 0.0, min( t, d ));\n    \n    \n    return mix( -1.0, t, st );\n}\n\n/**Finds the sphere distance and normal of the point intersected by a given ray\n * @returns D distance from ray origin and the hit point on the surface of the sphere\n * @returns -1 if ray does not intersect the sphere\n */\nfloat sphere( vec3 ro, vec3 rd, float time, out vec3 sphereNormal )\n{\n    vec3 sphereCenter = vec3( 0.3, 0.9 + cos( time * 1.579 ) * 0.4, 0.0 );\n    const float sphereRadius = 1.0;\n    \n    float spheresDistance = sphereCollision( ro, rd, sphereCenter, sphereRadius ); // spheresDistance is -1 if no collision\n    sphereNormal = normalize( sphereCenter - (ro+rd * spheresDistance) );          // normalizing the center with the hit point\n    \n    return spheresDistance;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (-1.0 + 2.0*fragCoord.xy / iResolution.xy) * vec2(iResolution.x/iResolution.y, 1.0);\n    // ray origin\n    vec3 ro = vec3( 0.0, 1.0, -2.0 - 1.0 + ( iMouse.y / iResolution.y ) );\n    // ray direction with some movment determined by mouse\n    vec3 rd = normalize( vec3( uv + vec2( (iMouse.x / iResolution.y) -0.5, 0. ), 1.0 ) );\n    \n    // detects collision with sphere\n    vec3 sphereNormal;\n    float spheresDistance = sphere( ro, rd, iTime, sphereNormal );\n    // \n    vec3 bgColor = background( ro, rd, iTime );\n    \n    rd = reflect( rd, sphereNormal );\n    \n    vec3 sphereColor = background( ro, rd, iTime ) * sphereColor;\n    \n    vec3 outColor = mix( bgColor, sphereColor, step( 0.0, spheresDistance ) );\n    \n    fragColor = vec4(outColor,1.0);\n}","name":"Image","description":"","type":"image"}]}