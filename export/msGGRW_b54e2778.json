{"ver":"0.1","info":{"id":"msGGRW","date":"1678230162","viewed":1404,"name":"Between the billowing clouds","username":"jolle","description":"All the hard part was made by Poisson in the original Smoke Flythrough, I just modified the density function and camera etc","likes":91,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarching","noise","ray","volume","clouds","fbm","cloud","volumetric","raymarcher","scattering","smoke","scatter","volumetrics"],"hasliked":0,"parentid":"ms3GDs","parentname":"Smoke Flythrough"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord*RESOLUTION/(iResolution.xy*iResolution.xy));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// A simple cloud shader to test my volumetric renderer, the noise is very bad and cheap.\n//\n#define NUM_STEPS 256 // marching steps, higher -> better quality\n\n// aces tonemapping\nvec3 ACES(vec3 x) {\n    float a = 2.51;\n    float b =  .03;\n    float c = 2.43;\n    float d =  .59;\n    float e =  .14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n// generate a number between 0 and 1\nfloat hash(float n) {return fract(sin(n)*43758.5453123);}\n\n// 3d noise function\nfloat noise(vec3 x) {\n    vec3 p = floor(x+.5);\n    vec3 f = fract(x+.5);\n    f = f*f*(3.-2.*f);\n    x = p + f - .5;\n    return textureLod(iChannel0, x/iChannelResolution[0], 0.).r;\n}\n\n// volume density\nfloat map(vec3 p) {\n    float f = 0.;\n    \n    vec3 t = iTime * vec3(-.5, -.75*sign(p.x), .5);\n    p *= 3.;\n    f += .5*noise(p+t*.4);\n    f += .25*noise(2.*p+t*.2);\n    f += .0625*noise(8.*p+t*.1);\n    f += .03125*noise(16.*p+t*.05);\n    f += .015625*noise(32.*p+t*.025);\n    \n    f += cos(p.x * 2.25) * .3;\n    f -= .35;\n\n    return -256.*f;\n}\n\n// light intensity function\nfloat getLight(float h, float k, vec3 ce, vec3 p) {\n    vec3 lig = ce-p;\n    float llig = length(lig);\n    lig = normalize(lig);\n    float sha = clamp((h - map(p + lig*k))/128.,0.,1.);\n    float att = 1./(llig*llig);\n    return sha*att;\n}\n\n// volumetric rendering\nvec3 render(vec3 ro, vec3 rd) {                   \n    float tmax = 6.; // maximum distance\n    float s = tmax / float(NUM_STEPS); // step size\n    float t = 0.; // distance travelled\n    // dithering\n    t += s*hash(gl_FragCoord.x*8315.9213/iResolution.x+gl_FragCoord.y*2942.5192/iResolution.y);\n    vec4 sum = vec4(0,0,0,1); // final result\n    \n    for (int i=0; i<NUM_STEPS; i++) { // marching loop\n        vec3 p = ro + rd*t; // current point\n        float h = map(p); // density\n        \n        if (h>0.) { // inside the volume    \n            // lighting\n            float occ = exp(-h*.1); // occlusion\n            \n            float k = .08;\n            vec3 col = 3.*vec3(.3,.6,1)*getLight(h, k, ro+vec3(0.75,-1,1.5), p)*occ\n                     + 3.*vec3(1,.2,.1)*getLight(h, k, ro+vec3(-0.5,1.25,2.0), p)*occ;\n             \n            sum.rgb += h*s*sum.a*col; // add the color to the final result\n            sum.a *= exp(-h*s); // beer's law\n        }\n        \n        if (sum.a<.01) break; // optimization\n        t += s; // march\n    }\n                   \n    // output\n    return sum.rgb;\n}\n\n// camera function\nmat3 setCamera(vec3 ro, vec3 ta) {\n    vec3 w = normalize(ta - ro); // forward vector\n    vec3 u = normalize(cross(w, vec3(-1,0,0))); // side vector\n    vec3 v = cross(u, w); // cross vector\n    return mat3(u, v, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x > RESOLUTION.x || fragCoord.y > RESOLUTION.y)\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n\n    // pixel coordinates centered at the origin\n    vec2 p = (fragCoord - .5*RESOLUTION) / RESOLUTION.y;\n\n    vec3 ro = vec3(0,0,iTime * 0.4); // ray origin\n    vec3 ta = ro + vec3(0,0,1); // target\n    mat3 ca = setCamera(ro, ta); // camera matrix\n    vec3 rd = ca * normalize(vec3(p,1.5)); // ray direction\n    \n    vec3 col = render(ro, rd); // render\n    \n    col = ACES(col); // tonemapping\n    col = pow(col, vec3(.4545)); // gamma correction\n\n    // vignette\n    vec2 q = fragCoord/RESOLUTION;\n    col *= pow(16. * q.x*q.y*(1.-q.x)*(1.-q.y), .1);\n\n    // output\n    fragColor = vec4(col,1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define RESOLUTION min(vec2(1280, 720), iResolution.xy)\n","name":"Common","description":"","type":"common"}]}