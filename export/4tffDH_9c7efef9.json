{"ver":"0.1","info":{"id":"4tffDH","date":"1511709861","viewed":683,"name":"Doyle spirals","username":"knighty","description":"A port a [url=http://www.fractalforums.com/fragmentarium/doyle-spirals/]fragmentarium shader drawing Doyle spirals[/url]. The original draws it in 3D instead. Maybe next time :) .\nChange the parameters (P, Q) at the beginning of the script.","likes":32,"published":1,"flags":0,"usePreview":0,"tags":["spiral","doyle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Doyle Spirals. Port from fragmentarium shader done a long time ago.\n//Public domain\n\n//Links:\n//http://www.fractalforums.com/fragmentarium/doyle-spirals/\n//http://www.josleys.com/show_gallery.php?galid=265\n//http://www.josleys.com/article_show.php?id=3\n//http://klein.math.okstate.edu/IndrasPearls/cusp.pdf\n\n#define PI 3.14159\n\n//Constant parameters: feel free to change these.\n//These control the shape of the spiral\nconst int P = 18;\nconst int Q = 7;//should be at least 3\n\n//Want do do an inversion?\nconst bool DoInversion = true;//false;//\n//Inversion center\nconst vec2 InvCenter = vec2(.7,0.);\n//Inversion radius squared\nconst float InvRadius = 1.;\n\n//to change the radius of the discs\nfloat SRadScl = 1.;\n\n//Draw circles?\nconst bool DrawCircles = true;//false;//\nconst float DRadius=0.7, Width=1.4, Gamma=2.2;\nconst vec3 BackgroundColor = vec3(.8);\nconst vec3 CurveColor = vec3(0.);\n\n\n//Initializations\n//all the initialization calculations done here could (and should) be done in the host program.\n\n//Global variables\nmat2 Mat,iMat;\nvec4 rads, xps, yps;\n\n//given an etimated z find the solution to Doyle spiral equations using Newton-Raphson method\n//The unknowns are the similarities a = exp(z), b = exp(zt) and the radius r.\n//The equations are:\n//r = ( exp( 2 * z.x ) - 2 * exp( z.x ) * cos( z.y ) + 1 ) / ( exp( z.x ) + 1 )\n//r = ( exp( 2 * zt.x) - 2 * exp( zt.x) * cos( zt.y) + 1 ) / ( exp( zt.x) + 1 )\n//r = ( exp( 2 * z.x ) - 2 * exp( z.x ) * exp( zt.x) * cos( z.y - zt.y ) + exp( 2 * zt.x ) ) / ( exp( z.x ) + exp( zt.x ) )\n//z.x * p = zt.x * q\n//z.y * p + 2 * PI = zt.y * q\n//In fact the last equation should be:\n//   z.y * p + 2 * k * PI = zt.y * q\n//Where k is an integer. I haven't esplored other values of k than 1\n//For more information see the articles cited above.\n\nvec2 solve( vec2 z ) {\n\t//Newton-Raphson method\n\tfloat k = float( P ) / float( Q );\n\tfor ( int i=0; i<2; i++ ){//2 iterations are usually sufficient: the convergence is very fast. especially when P o=and/or Q are relatively big\n\t\tfloat lb = z.x * k, tb = z.y * k + 2. * PI / float( Q );\n\t\tfloat ra = exp( z.x ),rb = exp( lb );\n        float ca = cos( z.y ), cb = cos( tb ), cab = cos( z.y - tb );\n\t\t\n        //compute function values\n\t\tvec3 v = vec3( ( ra * ra - 2. * ra * ca + 1. ) / (( ra + 1. ) * ( ra + 1. )),\n\t\t\t\t\t   ( rb * rb - 2. * rb * cb + 1. ) / (( rb + 1. ) * ( rb + 1. )),\n\t\t\t\t\t   ( ra * ra - 2. * ra * rb * cab + rb * rb ) / (( ra + rb ) * ( ra + rb )));\n\t\tvec2 f = v.xy - v.yz;\n\t\t\n        //compute jacobian\n\t\tvec3 c = 2.* vec3( ra / (( ra + 1. ) * ( ra + 1. )),\n                           k * rb / (( rb + 1. ) * ( rb + 1. )),\n                           ( 1. - k ) * ra * rb / (( ra + rb ) * ( ra + rb )));\n\t\tvec3 v0 = c * vec3( ( 1. + ca ) * ( ra - 1. ) / ( ra + 1. ),\n                            ( 1. + cb ) * ( rb - 1. ) / ( rb + 1. ),\n                            ( 1. + cab) * ( ra - rb ) / ( ra + rb ));\n\t\tvec3 v1 = c * sin( vec3( z.y, tb, z.y - tb ));\n\t\tmat2 J  = mat2(0.);\n\t\tJ[0]    = v0.xy - v0.yz; J[1] = v1.xy - v1.yz;\n        \n\t\t//compute inverse of J\n#if 1\n\t\tfloat idet = 1. / ( J[0][0] * J[1][1] - J[0][1] * J[1][0] );\n\t\tmat2 iJ    = -J;\n\t\tiJ[0][0]   = J[1][1];\n\t\tiJ[1][1]   = J[0][0];\n        //next value\n\t\tz -= idet * ( iJ * f );\n#else\n        //of course\n        mat2 iJ = inverse(J);\n        //but slightly slower\n        //next value\n\t\tz -= iJ * f;\n#endif\n\t}\n\treturn z;\n}\n\nvoid init() {\n\t//Find estimate then use Newton Raphson method to refine the solution.\n\t//Notice that for big P and/or Q the packing will look just like hexagonal one\n\t//If we take the centers of all packed circles in log-polar plane we will get almost a triangular array\n\t//That's why I'm using log-polar plane\n\t//Notice also the link to Drost effect ;)\n\t//Someone already noticed that before: http://gimpchat.com/viewtopic.php?f=10&t=3941\n\t\n    //Estimate z\n    vec2  v  = vec2( -float( P ) + float( Q ) * 0.5 , float( Q ) * sqrt( 3. ) * 0.5 );\n\tfloat vd = 1. / length(v);\n\tfloat scl = 2. * PI * vd;\n\tvec2  z  = scl * vd * v.yx;\n\t\n    //Refine. \n    z=solve(z);\n\t\n    //Compute the parameters used for drawing the circle packing\n    float k = float( P ) / float( Q );\n\t\n    vec2  zt= vec2( z.x * k, z.y * k + 2. * PI / float( Q ));\n\tMat[0]  = z; Mat[1] = zt;\n\tiMat    = -Mat;\n\tiMat[0][0] = Mat[1][1]; iMat[1][1] = Mat[0][0];\n\tiMat *= 1. / ( Mat[0][0] * Mat[1][1] - Mat[0][1] * Mat[1][0] );\n\t\n    float ra = exp( z.x ), rb = exp( zt.x ), ca = cos( z.y );\n\tfloat rs = sqrt(( ra * ra - 2. * ra * ca + 1. ) / (( ra + 1. ) * ( ra + 1. )));//radius of the circle centered at (1,0)\n\trs *= SRadScl;//for some variations\n\trads = rs * vec4( 1., ra, rb, ra * rb );//radius for the 4 circles in the fundamental domain\n\txps = vec4( 1., ra * ca, rb * cos( zt.y ), ra * rb * cos( z.y + zt.y ));//Their x coordinates\n\typs = vec4( 0., ra * sin( z.y ), rb * sin( zt.y ), ra * rb * sin( z.y + zt.y ));//y\n}\n\n//End initializations\n\n\nvec4 CDoyle( vec2 z ){\n\tvec2 p = z;\n\t\n    //transform to the plane log-polar\n\tp = vec2( log( length( p ) ), atan( p.y, p.x ));\n\t\n    //transform into the \"oblique\" base (defined by z and zt in vinit() function above)\n\tvec2 pl = iMat * p;\n\t\n    //go to the losange defined by z and zt (as defined in vinit())\n\tvec2 ip = floor( pl );\n\tpl = pl - ip;\n\t\n    //back to log-polar plane\n\tpl = Mat * pl;\n\t\n    //scale and delta-angle\n\tfloat scl = exp( pl.x - p.x ), angle = pl.y - p.y;\n\t\n    //the original z is scaled and rotated using scl and angle\n\tz *= scl;\n\tfloat c = cos(angle),s = sin(angle);\n\tz.xy = z.xy * mat2(vec2( c, -s ), vec2( s, c ));//rotate z\n\t\n    //distances to the discs that are inside the fundamental domain\n\tvec4 vx = vec4( z.x ) - xps;\n\tvec4 vy = vec4( z.y ) - yps;\n\tvec4 dists = sqrt( vx * vx + vy * vy ) - rads;\n\t\n    //take the minimal distance\n\tfloat mindist = min( min( dists.x, dists.y ) , min( dists.z, dists.w ) );\n\t\t\n    //what is the nearest sphere\n\tbvec4 bvhit = equal( dists, vec4( mindist ) );\n\tint mindex  = int( dot( vec4( bvhit ), vec4( 0., 1., 2., 3. ) ) );\n    \n#if 0\n    const mat4 set = mat4(vec4(0.),vec4(1.,0.,1.,0.),vec4(0.,1.,1.,0.),vec4(1.,1.,2.,0.));\n\tvec3  minprop  = set[ mindex ].xyz;\n#else\n    vec3 minprop;\n    if( mindex == 0 )      minprop = vec3(0.);\n    else if( mindex == 1 ) minprop = vec3(1.,0.,1.);\n    else if( mindex == 2 ) minprop = vec3(0.,1.,1.);\n    else                   minprop = vec3(1.,1.,2.);\n#endif\n\t\n    vec3 bc = vec3( ip, ip.x + ip.y ) + minprop;\n\tbc = bc / vec3( P, Q, max( abs( float( P - Q ) ), 1.) );\n\tbc-= floor( bc );\n\t\n\treturn vec4( bc, mindist/scl );//For coloring\n}\n\nfloat coverageFunction(float t){\n\t//this function returns the area of the part of the unit disc that is at the rigth of the verical line x=t.\n\t//the exact coverage function is:\n\t//t=clamp(t,-1.,1.); return (acos(t)-t*sqrt(1.-t*t))/PI;\n\t//this is a good approximation\n\treturn 1. - smoothstep( -1., 1., t );\n\t//a better approximation:\n\t//t=clamp(t,-1.,1.); return (t*t*t*t-5.)*t*1./8.+0.5;//but there is no visual difference\n}\n\nfloat coverageLine(float d, float lineWidth, float pixsize){\n\td = d * 1. / pixsize;\n\tfloat v1 = ( d - 0.5 * lineWidth ) / DRadius;\n\tfloat v2 = ( d + 0.5 * lineWidth ) / DRadius;\n\treturn coverageFunction( v1 ) - coverageFunction( v2 );\n}\n\nfloat coverage(float d, float lineWidth, float pixsize){\n\td = d * 1. / pixsize;\n\tfloat v1 = ( d - 0.5 * lineWidth ) / DRadius;\n\treturn coverageFunction( v1 );\n}\n\nvec3 color(vec2 p) {\n    float pixsize = dFdx( p.x );\n    \n    vec4 col = vec4(0.);\n    \n    float ang = iTime * 0.5;\n    float c = cos( ang ), s = sin( ang );\n\tmat2 rot= mat2( vec2( c, -s ), vec2( s, c ) );\n    \n    if( DoInversion ) {\n\t\tp = p - InvCenter;\n\t\tfloat r2 = dot( p, p );\n        float r  = sqrt(r2);\n\t\tp = ( InvRadius / r2 ) * p + InvCenter;\n        col = CDoyle( rot * p );\n        col.w = r2 * col.w / (InvRadius + r * col.w);\n\t} else\n        col = CDoyle( rot * p );\n        \n    float v=coverage(col.w, Width, pixsize);\n    col.rgb = sin( 2. * PI * col.rgb + .0) * 0.5 + 0.5;\n    col.rgb = mix( pow(BackgroundColor, vec3(Gamma)), pow(col.rgb, vec3(Gamma)), v);\n    if(DrawCircles){\n    \tv=coverageLine(col.w, Width, pixsize);\n    \tcol.rgb = mix( col.rgb, pow(CurveColor, vec3(Gamma)),v);\n    }\n    return pow( col.rgb, vec3( 1. / Gamma ) ) ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst float scaleFactor = 1.4;\n\tvec2 uv = scaleFactor * ( fragCoord.xy - 0.5 * iResolution.xy ) / iResolution.y;\n    SRadScl = sin( iTime ) * 0.05 + 0.95;\n\tinit(); \n\tfragColor = vec4( color( uv ), 1.0 );\n}","name":"Image","description":"","type":"image"}]}