{"ver":"0.1","info":{"id":"cdfBD2","date":"1689172914","viewed":87,"name":"3D Arrow SDF","username":"aria","description":"Arrow SDF. The tip is a cone and the body is a line segment. \nJust define a start and an end vector.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["sdf","arrow","arrowsdf","raysdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\n\nmat4 rotationMatrix(vec3 axis, float angle) {\n\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, 0.0,\n                oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, 0.0,\n                oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c, 0.0,\n                0.0, 0.0, 0.0, 1.0);\n\n}\n\nvec3 rotate(vec3 v, vec3 axis, float angle) {\n\n    mat4 m = rotationMatrix(axis, angle);\n    return (m * vec4(v, 1.0)).xyz;\n\n}\n\nvec3 applyDirectionVector(vec3 vec, vec3 direction) {\n\n    float angle = atan(direction.y, direction.x);\n    mat4 rotXY = rotationMatrix(vec3(0.0, 0.0, -1.0), angle);\n    float angleZ = -asin(direction.z);\n    mat4 rotZ = rotationMatrix(vec3(0.0, -1.0, 0.0), angleZ);\n    mat4 rot = rotXY * rotZ;\n    vec4 v = vec4(vec, 1) * rot;\n\n    return v.xyz;\n\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat cone(vec3 position, float radius, float halfHeight) {\n\n    vec2 q = vec2(length(position.xz) - radius, position.y + halfHeight);\n    vec2 end = vec2(-radius, halfHeight * 2.0);\n    vec2 segment = q - end * clamp(dot(q, end) / dot(end, end), 0.0, 1.0);\n    float d = length(segment);\n    bool b = max(segment.x, segment.y) > 0.0;\n\n    return mix(-min(d, q.y), d, b);\n\n}\n\nfloat cylinder( vec3 p, float h, float r ) {\n\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n\n}\n\nfloat pyramid(vec3 position, float halfWidth, float halfDepth, float halfHeight) {\n\n    position.xz = abs(position.xz);\n    \n    // bottom\n    float s1 = abs(position.y) - halfHeight;\n    vec3 base = vec3(max(position.x - halfWidth, 0.0), abs(position.y + halfHeight), max(position.z - halfDepth, 0.0));\n    float d1 = dot(base, base);\n    \n    vec3 q = position - vec3(halfWidth, -halfHeight, halfDepth);\n    vec3 end = vec3(-halfWidth, 2.0 * halfHeight, -halfDepth);\n    vec3 segment = q - end * clamp(dot(q, end) / dot(end, end), 0.0, 1.0);\n    float d = dot(segment, segment);\n    \n    // side\n    vec3 normal1 = vec3(end.y, -end.x, 0.0);   \n    float s2 = dot(q.xy, normal1.xy);\n    bool b2 = dot(q.xy, -end.xy) < 0.0 && dot(q, cross(normal1, end)) < 0.0;\n    float d2 = mix(d, s2 * s2 / dot(normal1.xy, normal1.xy), float(b2));\n\n    // front/back\n    vec3 normal2 = vec3(0.0, -end.z, end.y);\n    float s3 = dot(q.yz, normal2.yz);\n    bool b3 = dot(q.yz, -end.yz) < 0.0 && dot(q, cross(normal2, -end)) < 0.0;\n    float d3 = mix(d, s3 * s3 / dot(normal2.yz, normal2.yz), float(b3));\n    \n    return sqrt(min(min(d1, d2), d3)) * sign(max(max(s1, s2), s3));\n\n}\n\n    float capsule( vec3 p, vec3 a, vec3 b, float r ) {\n\n      vec3 pa = p - a, ba = b - a;\n      float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n      return length(pa - ba * h) - r;\n\n    }\n\n\nfloat arrow(vec3 position, vec3 start, vec3 end) {\n\n    const float cornerRadius = 0.035;\n    \n    const float tipWidth = 0.22;\n    // const float tipDepth = 0.22; // for pyramid tip\n    const float tipHeight = 0.22;\n    const float lineThickness = 0.022;\n\n    vec3 arrow = end - start;\n    vec3 dir = normalize(arrow);\n    float len = length(arrow);\n    \n    float halfWidth = tipWidth / 2.0; \n    // float halfDepth = tipDepth / 2.0; // for pyramid tip\n    float halfHeight = tipHeight / 2.0;\n    \n    vec3 pos = position - start;\n\n    // * matching direction\n    pos = applyDirectionVector(pos, dir);\n\n    // * fix rotation\n    pos = rotate(pos, vec3(0, 0, 1), -PI / 2.0);\n    \n    // pyramid tip\n    // float tip = pyramid(pos - vec3(0, len - halfHeight, 0), halfWidth, halfDepth, halfHeight);\n    \n    // cone tip\n    float tip = cone(pos - vec3(0, len - halfHeight, 0), halfWidth, halfHeight);\n    \n    // float lineHeight = len - halfHeight;\n    // float line = cylinder(pos , lineHeight / 2.0, lineThickness);\n    float line = capsule(position + dir * halfHeight, start, end, lineThickness);\n    \n    return smin(line, tip, cornerRadius) - cornerRadius;\n    \n}\n\nfloat sdf(vec3 position) { \n    return arrow(position, vec3(1, 0, 0), vec3(-1, 0, 0));\n}\n\nvec3 normal(vec3 position) {\n    float epsilon = 0.001;\n    vec3 gradient = vec3(\n        sdf(position + vec3(epsilon, 0, 0)) - sdf(position + vec3(-epsilon, 0, 0)),\n        sdf(position + vec3(0, epsilon, 0)) - sdf(position + vec3(0, -epsilon, 0)),\n        sdf(position + vec3(0, 0, epsilon)) - sdf(position + vec3(0, 0, -epsilon))\n    );\n    return normalize(gradient);\n}\n\nmat3 lookAtMatrix(vec3 from, vec3 to) {\n    vec3 forward = normalize(to - from);\n    vec3 right = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, forward);\n    return mat3(right, up, forward);\n}\n\nfloat raycast(vec3 rayOrigin, vec3 rayDirection) {\n    int stepCount = 128;\n    float maximumDistance = 5.0;\n    float t = 0.0;\n    for (int i = 0; i < stepCount; i++) {\n        if (t > maximumDistance) {\n            break;\n        }\n        vec3 currentPosition = rayOrigin + rayDirection * t;\n        float d = sdf(currentPosition);\n        if (d < 0.0001) {\n            return t;\n        }\n        t += d;\n    }\n    return 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfloat angle = 0.5 * (iTime - 6.0);\n\t//vec3 rayOrigin = vec3(1.0 * cos(angle), sin(iTime / 3.0) - 0.2, 1.0 * sin(angle) - 3.0);\n    vec3 rayOrigin = vec3(0, 0, 1.8);\n    vec3 targetPosition = vec3(0.0);\n    mat3 cameraTransform = lookAtMatrix(rayOrigin, targetPosition);\n    vec3 result = vec3(0.0);\n    ivec2 sampleCount = ivec2(3.0, 3.0);\n    for (int y = 0; y < sampleCount.y; y++) {\n        for (int x = 0; x < sampleCount.x; x++) {\n            vec2 uv = fragCoord + (vec2(float(x), float(y)) / vec2(sampleCount) - 0.5);\n            uv = uv / iResolution.xy;\n            uv = (uv * 2.0) - 1.0;\n            uv.x *= iResolution.x / iResolution.y;\n            vec3 rayDirection = normalize(vec3(uv, 1.5));\n            rayDirection = cameraTransform * rayDirection;\n            float t = raycast(rayOrigin, rayDirection);\n            vec3 color = vec3(0.0);\n            if (t > 0.0) {\n                // same style that Inigo Quilez uses in his shaders\n                vec3 position = rayOrigin + rayDirection * t;\n                vec3 lightDirection = vec3(-0.57735);\n                vec3 n = normal(position);\n                float diffuseAngle = max(dot(n, lightDirection), 0.0);\n                // diffuse\n                color = vec3(0.8, 0.7, 0.5) * diffuseAngle;\n                // ambient\n                color += vec3(0.2, 0.3, 0.4) * ((n.y + 1.0) * 0.5);\n            }\n            // gamma        \n            color = sqrt(color);\n            result += color;\n        }\n    }\n    result /= float(sampleCount.x * sampleCount.y);\n\tfragColor = vec4(result, 1.0);\n}","name":"Image","description":"","type":"image"}]}