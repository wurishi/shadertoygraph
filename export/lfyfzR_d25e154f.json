{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"\n// My first complete scene using raymarching to learn and practice procedural rendering techniques.\n\n// The lighthouse is modeled with SDFs after Ar-Men, a notorious open-sea lighthouse in Brittany, France.\n// https://en.wikipedia.org/wiki/Ar_Men\n// https://www.detienne.net/phares/divers_phare_int_armen_gb.php\n\n// All textures are procedural. The letters painted on the lighthouse (and the title) are composed with 2D SDFs.\n// The lightbeam is achieved with volumetric rendering. The waves are an approximation of Gerstner waves: https://www.shadertoy.com/view/XftcDj.\n\n//# define AA\n\nbool SHOWTITLE = true;\n\nconst float MATERIAL_SKY = 0.0;\nconst float MATERIAL_SEA = 1.0;\n\nconst float MAX_DIST = 1000.0;\n\nconst vec3 lighthouseOrigin = vec3(-40.0, 16.0, 220.0);\nconst mat2 lighthouseRotation = mat2(0.637423, -0.770513, 0.770513, 0.637423);\nconst vec3 lighthouseLantern = lighthouseOrigin + vec3(0.0, 24.2, 0.0);\n\n\nvec3 keylight = normalize( vec3(-1.5, -1.0, -1.5) );\n\n\n\nfloat odd(float v) { return ceil(fract(v * 0.5)); }\nfloat dot2(vec2 v) { return v.x * v.x + v.y * v.y; }\n\n\n// https://iquilezles.org/articles/distfunctions/\nfloat smin( float a, float b, float k)\n{\n\n  float h = max(k - abs(a - b), 0.0) / k;\n  return min(a, b) - h * h * h * k * (1.0/6.0);\n\n}\n\n\nmat2 rotationTriple(float a, float b, float c)\n{\n    return mat2(a/c, b/c, -b/c, a/c);\n}\n\n\n// https://iquilezles.org/articles/distfunctions/\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n\n// https://iquilezles.org/articles/distfunctions/\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\n\n\n// PRIMITIVES\n// https://iquilezles.org/articles/distfunctions/\n\n\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\n\nfloat sdTunnel( in vec2 p, in vec2 wh )\n{\n    p.x = abs(p.x); p.y = -p.y;\n    vec2 q = p - wh;\n\n    float d1 = dot2(vec2(max(q.x,0.0),q.y));\n    q.x = (p.y>0.0) ? q.x : length(p)-wh.x;\n    float d2 = dot2(vec2(q.x,max(q.y,0.0)));\n    float d = sqrt( min(d1,d2) );\n    \n    return (max(q.x,q.y)<0.0) ? -d : d;\n}\n\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n\nfloat sdBox2D( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdCylinderInfinite( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n// UTILITY FUNCTIONS\n\n\nvec3 pickClosest( vec3 A, vec3 B )\n{\n\n    return (A.x < B.x) ? A : B;\n\n}\n\n\n\nvec3 pickFarthest( vec3 A, vec3 B )\n{\n\n    return (A.x > B.x) ? A : B;\n\n}\n\n\nfloat random(vec2 p) {\n\n  return fract(sin(dot(p, vec2(101.2, 973.0))) * 43758.5453123);\n\n}\n\n\nfloat staticNoise(vec2 p) {\n\n  return fract(sin(dot(p, vec2(101.2, 973.0))) * (43758.5453123 + iTime * 8.0));\n\n}\n\n\nfloat randomSeed(float i, float s) {\n\n    return fract(fract(sin(i)) * s);\n\n}\n\n\nvec2 random2D(vec2 i) {\n    \n    float d = dot(i, vec2(22.9876, 34.4388));\n\n    return vec2( randomSeed( d, 3141592.65359 ), randomSeed( d, 2951414.95356 ) ) * 2.0 - 1.0;\n\n}\n\n\nfloat gradNoise2D(vec2 p) {\n\n    vec2 f = fract(p);\n\n    vec2 fl = mod(floor(p), 20.0);\n    vec2 ce = mod(ceil(p), 20.0);\n\n    vec2 a = random2D(vec2(fl.x, fl.y));\n    vec2 b = random2D(vec2(ce.x, fl.y));\n    vec2 c = random2D(vec2(fl.x, ce.y));\n    vec2 d = random2D(vec2(ce.x, ce.y));\n\n    float da = dot(a, f - vec2(0.0, 0.0));\n    float db = dot(b, f - vec2(1.0, 0.0));\n    float dc = dot(c, f - vec2(0.0, 1.0));\n    float dd = dot(d, f - vec2(1.0, 1.0));\n    \n    return 0.5 + mix( mix(da, db, f.x), mix(dc, dd, f.x), f.y );\n\n}\n\n\nfloat FBM(vec2 p, int i, float d) {\n    \n    mat2 r = mat2(4.0/5.0, 3.0/5.0, -3.0/5.0, 4.0/5.0);\n    \n    float f = 2.0;\n    float w = 0.5;\n    \n    float n = gradNoise2D(p) * w;\n    \n    for (int j=0; j<i; j++) {\n    \n        p = p * r;\n        w = w * d;\n        \n        n += gradNoise2D(p * f) * w;\n    \n        f = f * 2.0;\n    \n    }\n    \n    return n;\n\n}\n\n\n\nfloat paintedLetters( vec2 p )\n{\n    \n    float vth = 0.15;\n    float hth = vth * 0.85;\n\n    // A\n    p = p + vec2(2.35, 0.0);\n    vec2 w = vec2(0.8, 1.0);\n    float d1 = sdOrientedBox( p - vec2(0.5 * w.x, 1.0), vec2(0.0, -0.47) * w, vec2(0.49, 0.48) * w, hth * 1.02 );\n    float d2 = sdOrientedBox( p - vec2(0.5 * w.x, 1.0), vec2(1.0, -0.47) * w, vec2(0.51, 0.48) * w, vth * 0.92 );\n    float h1 = sdOrientedBox( p - vec2(0.0, 0.35), vec2(0.65, 0.5) * w, vec2(1.35, 0.5) * w, hth * 0.85 );\n    float ap = sdOrientedBox( p - vec2(0.5 * w.x, 1.48), vec2(0.5, -hth * 0.2) * w, vec2(0.5, hth * 0.2) * w, hth );\n    float t1 = sdOrientedBox( p - vec2(0.0 * w.x, 0.53), vec2(0.5, -hth * 0.2) * w, vec2(0.5, hth * 0.175) * w, hth );\n    float t2 = sdOrientedBox( p - vec2(1.0 * w.x, 0.53), vec2(0.5, -hth * 0.2) * w, vec2(0.5, hth * 0.2) * w, hth );\n    \n    float A = min(min(ap, min(t1, t2)), min(h1, min(d1, d2)));\n\n    // R\n    p = p + vec2(-1.35, 0.0);\n    w = vec2(0.8, 1.0);\n    float v1 = sdOrientedBox( p - vec2(vth * 0.5, 0.5), vec2(0.0, 0.0) * w, vec2(0.0, 1.0) * w, vth );\n    float a1 = abs(sdTunnel( p.yx - vec2(1.196, 0.6 - vth), vec2(0.24, 0.35))) - hth * 0.5;\n    d1 = sdOrientedBox( p - vec2(0.397 + vth * 0.5, 0.955), vec2(0.0, 0.01) * w, vec2(0.45 - hth, -0.414) * w, hth * 1.07 );\n    t1 = sdOrientedBox( p - vec2(0.41 * w.x, 0.53), vec2(0.5, -hth * 0.2) * w, vec2(0.5, hth * 0.35) * w, hth * 0.95 );\n    float R = min(v1, min(a1, min(d1, t1)));\n    \n    // hyphen\n    p = p + vec2(-1.1, 0.0);\n    w = vec2(0.8, 1.0);\n    float hyphen = sdOrientedBox( p - vec2(0.0, 0.95), vec2(-0.4, 0.0) * w, vec2(0.4, 0.0) * w, hth * 0.95 );    \n\n    // M\n    p = p + vec2(-0.43, 0.0);\n    w = vec2(0.8, 1.0);\n    v1 = sdOrientedBox( p - vec2(vth * 0.5, 0.5), vec2(0.0, 0.0) * w, vec2(0.0, 1.0) * w, vth );\n    float v2 = sdOrientedBox( p - vec2(1.0 * w.x - vth * 0.5, 0.5), vec2(0.0, 0.0) * w, vec2(0.0, 1.0) * w, vth );\n    \n    d1 = sdOrientedBox( p - vec2(vth * 0.6, 1.461), vec2(0.01, 0.0) * w, vec2(0.5 - hth, -0.5) * w, hth * 0.98 );\n    d2 = sdOrientedBox( p - vec2(1.0 * w.x - vth * 0.6, 1.461), vec2(-0.5 + hth, -0.5) * w, vec2(-0.01, 0.0) * w, hth * 0.98 );\n    ap = sdOrientedBox( p - vec2(0.5 * w.x, 0.99), vec2(0.0, -hth * 0.5) * w, vec2(0.0, hth * 0.5) * w, hth );\n    float M = min(v1, min(v2, min(ap, min(d1, d2))));\n\n    // E\n    p = p + vec2(-0.97, 0.0);\n    w = vec2(0.65, 1.0);\n    float v = sdOrientedBox( p - vec2(vth * 0.5, 0.5), vec2(0.0, 0.0) * w, vec2(0.0, 1.0) * w, vth );\n    \n    h1 = sdOrientedBox( p - vec2(0.0, hth * 0.5), vec2(0.0, 0.5) * w, vec2(1.0, 0.5) * w, hth );\n    float h2 = sdOrientedBox( p - vec2(0.0, 0.5), vec2(0.0, 0.5) * w, vec2(0.8, 0.5) * w, hth );\n    float h3 = sdOrientedBox( p - vec2(0.0, 1.0 - hth * 0.5), vec2(0.0, 0.5) * w, vec2(1.0, 0.5) * w, hth );\n    float E = min(v, min(h1, min(h2, h3)));\n    \n    // N\n    p = p + vec2(-0.78, 0.0);\n    w = vec2(0.7, 1.0);\n    v1 = sdOrientedBox( p - vec2(vth * 0.5, 0.5), vec2(0.0, 0.0) * w, vec2(0.0, 1.0) * w, vth );\n    v2 = sdOrientedBox( p - vec2(1.0 * w.x - vth * 0.5, 0.5), vec2(0.0, 0.0) * w, vec2(0.0, 1.0) * w, vth );\n    d1 = sdOrientedBox( p - vec2(0.5 * w.x, 1.0), vec2(-0.5 + hth * 1.1, 0.5 - hth * 0.25) * w, vec2(0.5 - hth * 1.1, -0.5 + hth * 0.25) * w, hth * 1.05 );\n    \n    float N = min(v1, min(v2, d1));\n    \n    return min(A, min(R, min(hyphen, min(M, min(E, N)))));\n\n}\n\n\nconst mat2 mr0 = mat2(0.7071, 0.7071, -0.7071, 0.7071);\nconst mat2 mr1 = mat2(0, 1, -1, 0);\nconst mat2 mr2 = mat2(7.0/24.0, 24.0/25.0, -24.0/25.0, 7.0/25.0);\nconst mat2 mr3 = mat2(48.0/73.0, 55.0/73.0, -55.0/73.0, 48.0/73.0);\n\n\n\nvec3 getSkyColor( vec3 rd )\n{\n    return vec3(0.83, 0.84, 0.86) - rd.y * 0.55 + (rd.x + 0.1) * 0.3;\n}\n\n\n// MATERIAL FUNCTIONS\n\n\nfloat brickValueNoise2D(vec2 p, float width, float n) {\n\n    vec2 q = floor(p);\n    \n    float xo = odd(q.y);\n    q.x = floor(q.x / width - (xo * 0.5));\n\n    vec2 f = fract(q);\n\n    vec2 fl = floor(q);\n    vec2 ce = ceil(q);\n\n    float a = random(vec2(fl.x, fl.y));\n    float b = random(vec2(ce.x, fl.y));\n    float c = random(vec2(fl.x, ce.y));\n    float d = random(vec2(ce.x, ce.y));\n    \n    //float ns = FBM(p * 2.0, 4, 0.95);\n    \n    return (0.5 + mix( mix(a, b, f.x), mix(c, d, f.x), f.y ) * 0.5) * n;\n\n}\n\n\nfloat brickMortarLines(vec2 p, float width, float th, float n) \n{    \n    p += vec2(th * 0.5);\n    vec2 q = floor(p);\n    float xo = odd(q.y);    \n    q.x = floor((q.x / width - (xo * 0.5)));\n\n    p = p / vec2(width, 1.0) - vec2(xo * 0.5, 0.0);\n\n    float x = 1.0 - step(th/width, min(1.0, (abs(p.x - q.x))));\n    float y = 1.0 - step(th, min(1.0, (abs(p.y - q.y))));\n    \n    return max(x, y);\n\n}\n\n\nvec2 brickLuminance(float x, float y, float th, float n) {\n\n  \n  vec2 q = vec2( x, y );\n  q += n * 0.1;\n  \n  float w = 2.0;\n  float n0 = 0.25 + brickValueNoise2D(q, w, n) * 0.65;\n  float n1 = brickMortarLines(q, w, (0.5 + n) * th, n);\n  \n  return vec2(n0, n1);\n\n}\n\n\nvec2 brickPattern(vec3 p, vec3 ob)\n{\n    \n    float lanternOffset = step(2.0, ob.z);\n    float towerOffset   = step(3.0, ob.z);\n    \n    float isFoundation = 1.0 - lanternOffset;\n    float isBrick = step(1.0, ob.z) - step(5.0, ob.z);\n    float isLantern = lanternOffset - towerOffset;\n    \n    float sx = (1.0 - isLantern * 0.5 + isFoundation\n * 0.06);\n    float sy = 1.5 + 2.0 * towerOffset;\n    float dy = 0.72 - towerOffset * 0.85 - lanternOffset * 1.52;\n    \n    // wrapping bricks around circular base\n    float x = atan(p.z, p.x) * 8.9175 * sx;\n    float y = p.y * sy - dy;\n    \n    // correcting for rectangular dock sides\n    x = mix(x, p.x * 1.20 + 0.65, step(6.9,  p.x));\n    x = mix(x, p.z * 1.23 + 0.02, step(12.0, p.x));\n    \n    float n = FBM( vec2(x, y) * (4.0 + 12.0 * isLantern), 3, 0.95 );\n    \n    float a = 0.5 - towerOffset * 0.05 - lanternOffset * 0.25;\n    float b = 0.1 + step(2.0, ob.z) * .9;\n    \n    float mdepth = 1.0 - towerOffset * 0.5;\n    float bdepth = 1.0;\n    \n    return brickLuminance(x, y, 0.15 - isLantern * 0.05, n) * isBrick * vec2(bdepth, mdepth);\n}\n\n\n\n// LIGHTHOUSE SDF\n\nconst float MATERIAL_LIGHTHOUSE = 100.0;\n\nconst float MATERIAL_LIGHTHOUSE_METAL = 110.0;\nconst float MATERIAL_LIGHTHOUSE_CONCRETE = 115.0;\n\nconst float MATERIAL_LIGHTHOUSE_MASONRY = 120.0;\nconst float MATERIAL_LIGHTHOUSE_LANTERN_GLASS = 130.0;\n\nconst float MATERIAL_LIGHTHOUSE_WINDOW = 150.0;\nconst float MATERIAL_LIGHTHOUSE_WINDOW_PAINTED = 151.0;\nconst float MATERIAL_LIGHTHOUSE_WINDOW_CASEMENT = 155.0;\n\nconst float MATERIAL_LIGHTHOUSE_DOOR = 160.0;\n\n\nvec3 lighthousePosition( vec3 p )\n{\n    vec3 q0 = (p - lighthouseOrigin);\n    vec2 q = lighthouseRotation * q0.xz;\n    //vec2 q = q0.xz;\n    \n    return vec3(q.x, q0.y, q.y);\n}\n\n\nfloat sdGuardRailBar( vec3 p, float h, float id )\n{\n    float longbar = float(id == 12.0);\n    \n    h = mix(h, 1.8, longbar);\n    float th = mix(0.03, 0.035, longbar);\n\n    return sdVerticalCapsule(p, h, th);\n}\n\n\nfloat sdRailing( vec3 p, float r, float h, float an )\n{  \n    // circular railing, vertical-axis revolution of a circle\n    r = (an > 3.141592*12.0/30.0) ? 0.0 : r;\n\n    vec2 q = vec2(length(p.xz) - r, p.y - h);\n    return sdCircle(q, 0.035);  \n}\n\n\nfloat sdBalconyFrame( vec3 p, float r, float h, mat2 ro )\n{\n    \n    float hh = h * 0.5;\n    float vb1 = sdVerticalCapsule(p, h, 0.035);\n    \n    vec3 q = p;\n    q.xz = q.zx * ro;\n    float vb2 = sdVerticalCapsule(q + vec3(-1.24, 0.0, 0.0), h, 0.035);\n    float vb3 = sdVerticalCapsule(q + vec3(-1.24, 0.0, 1.24), h, 0.035);\n    \n    float hb11 = sdCapsule( q + vec3(0.0, -hh, 0.0), vec3(0.0, 0.0, 0.0), vec3(1.24, 0.0, 0.0), 0.035 );\n    float hb12 = sdCapsule( q + vec3(-1.24, -hh, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, -1.24), 0.035 );\n    \n    float hb21 = sdCapsule( q + vec3(0.0, -h, 0.0), vec3(0.0, 0.0, 0.0), vec3(1.24, 0.0, 0.0), 0.035 );\n    float hb22 = sdCapsule( q + vec3(-1.24, -h, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, -1.24), 0.035 );\n\n    float vb = min(vb1, min(vb2, vb3));\n    float hb = min(min(hb11, hb12), min(hb21, hb22));\n\n    return min( hb, vb ); \n\n}\n\n\nfloat sdGuardRails( vec3 p, float r)\n{\n     \n    // guardrail height\n    float h = 1.4;\n \n     // Circular guardrails\n    float rot = -90.0 * 6.283184/360.0;\n    vec2 rotv = vec2(cos(rot), sin(rot));\n    p.xz = p.xz * mat2(rotv.x, rotv.y, -rotv.y, rotv.x);\n \n    p.x = abs(p.x);\n    vec3 q = p;\n\n    float count = 30.0;\n    float sp = 3.141592 / count;\n    float an = atan(q.z/q.x);\n    \n    float id = round(an/sp);\n    id = clamp(id, -15.0, 10.0);\n\n    float a1 = sp * (id + 0.0);\n    float a2 = sp * (id + 1.0);\n\n    vec2 r1 = vec2(cos(a1), sin(a1));\n    vec2 r2 = vec2(cos(a2), sin(a2));\n\n    vec3 q1 = q;\n    vec3 q2 = q;\n\n    q1.xz = mat2(r1.x, -r1.y, r1.y, r1.x) * q1.xz;\n    q2.xz = mat2(r2.x, -r2.y, r2.y, r2.x) * q2.xz;\n    \n    vec3 radOffset = vec3(r, 0.0, 0.0);\n    \n    float bars = min( sdGuardRailBar(q1 - radOffset, h, id), sdGuardRailBar(q2 - radOffset, h, id + 1.0) );\n    float rail = sdRailing(q, r, h, an);\n    \n    // Balcony\n    float ab = sp * -12.0;\n    vec2 rb = vec2(cos(ab), sin(ab));\n    mat2 ro = mat2(rb.x, -rb.y, rb.y, rb.x);\n    \n    vec3 qb = q;\n    qb.xz = qb.xz * ro;\n    float balcony = sdBalconyFrame(qb - radOffset, r, h + 0.6, ro);\n    \n    return min( bars, min(rail, balcony) );\n}\n\n\nvec3 beamVector(float i)\n{\n    // Ar-men’s lantern flashes 3 times every 20 seconds\n    float a = (iTime + i) * 6.283184 / 40.0;\n    return vec3(cos(a), 0.0, sin(a));\n}\n\n\nfloat sdLighhouseBeam( vec3 p )\n{\n \n    p = p - lighthouseLantern;\n    \n    float toLantern = length(p);\n    float r = 0.8 + toLantern * 0.02;\n\n    vec3 beamA = beamVector(-0.15);\n    float d1 = sdCapsule( p, beamA * -3000.0, beamA * 3000.0, r );\n    \n    vec3 beamB = beamVector(0.0);\n    float d2 = sdCapsule( p, beamB * -3000.0, beamB * 3000.0, r );\n    \n    vec3 beamC = beamVector(0.15);\n    float d3 = sdCapsule( p, beamC * -3000.0, beamC * 3000.0, r );\n\n    return min(d1, min(d2, d3));\n\n}\n\n\nfloat sdLighthousePole( vec3 p )\n{\n\n    float a = sdCylinder(p - vec3(0, -0.35, 0), vec2(0.3 - p.y * 0.05, 0.15)) - 0.01;\n    float b = sdCylinder(p - vec3(0, 0.25, 0), vec2(0.15 - p.y * 0.02, 0.5)) - 0.05;\n    \n    return smin(a, b, 0.5);\n\n}\n\n\nfloat sdGuardRailSegments( vec3 p )\n{\n    \n    vec3 q = p;\n    q.x = abs(q.x);\n\n    float count = 30.0;\n    float sp = 6.283184/count;\n    float an = atan(q.z/q.x);\n\n    float rid = round(an/sp);\n    rid = clamp(rid, -5.0, 10.0);\n\n    float a1 = sp * (rid + 0.0);\n    float a2 = sp * (rid + 1.0);\n    float a3 = sp * (rid + 0.5);\n\n    vec2 r1 = vec2(cos(a1), sin(a1));\n    vec2 r2 = vec2(cos(a2), sin(a2));\n\n    vec3 q1 = q;\n    vec3 q2 = q;\n\n    q1.xz = mat2(r1.x, -r1.y, r1.y, r1.x) * q1.xz;\n    q2.xz = mat2(r2.x, -r2.y, r2.y, r2.x) * q2.xz;\n    \n    float r = 7.8;\n    q1 = q1 - vec3(r, 0.0, 0.0);\n    q2 = q2 - vec3(r, 0.0, 0.0);\n    \n    float verticals = min(sdVerticalCapsule(q1, 1.4, 0.04), sdVerticalCapsule(q2, 1.4, 0.04));\n    \n    float id1 = floor(p.y / 0.7);\n    id1 = clamp(id1, 1.0, 2.0);\n    p.y = p.y - 0.7 * id1 + 1.4;\n    \n    float rotA = 2.1;\n    p.xz = p.xz * mat2(cos(rotA), sin(rotA), -sin(rotA), cos(rotA));\n    an = atan(p.z, p.x);\n    r = (an > 3.141592*20.0/30.0) ? 0.0 : r;\n    \n    vec2 q3 = vec2(length(p.xz) - r, p.y - 1.45);\n    float horizontals = sdCircle(q3, 0.04);\n\n    return min(verticals, horizontals);\n\n}\n\n\nfloat sdLadderRungs( vec3 p )\n{\n     \n    //p.z += 0.5;\n    p.xz = vec2(p.z, p.x);\n    p.xy = vec2(p.y, p.x);\n \n    float s = 0.4;\n    float id = floor((p.x + (s * 0.5)) / s);\n    id = clamp(id, -7.0, 6.0);\n    p.x = p.x - s * id;\n    //p.xz = p.zx;\n    \n    return sdVerticalCapsule(p, 1.0, 0.04);\n\n}\n\n\nfloat sdLighthouseFoundation2D( vec2 p )\n{\n\n    p.xy = vec2(-p.y, -p.x) - 1.0;\n\n    float base = sdCircle(p, 8.0);\n    \n    // Dock\n    float dock = sdBox2D(p - vec2(0.0, -6.0), vec2(4.0, 6.0));\n    base = smin(dock, base, 1.0);\n    \n    return base;\n}\n\n\nfloat sdLighthouseFoundation( vec3 p, float height )\n{\n    float base = sdCylinder(p, vec2(8.0, height));\n    \n    // Dock\n    float dock = sdBox(p - vec3(0.0, 0.0, -6.0), vec3(4.0, height, 6.0));\n    base = min(dock, base);\n    \n    return base;\n}\n\nvec3 sdLighthouseBase( vec3 p )\n{\n\n    p.xz = vec2(-p.z, -p.x);\n    vec3 q = p - vec3(0.0, -14.5, 0.0);\n\n    // Circular base\n    float height = 7.6;\n    vec3 base = vec3(sdLighthouseFoundation(q, height), MATERIAL_LIGHTHOUSE_MASONRY, float(p.y < -6.9));\n    vec3 baseMetal = vec3(0.0, MATERIAL_LIGHTHOUSE_METAL, 0.0);\n    \n    // Dock poles\n    vec3 qp = q;\n    qp.x = qp.x - 0.4;\n    float idp = floor(qp.x / 2.0);\n    idp = clamp(idp, -2.0, 1.0);\n    qp.x = qp.x - (2.0 * idp);\n    base.x = min(base.x, sdLighthousePole(qp - vec3(1.0,  height + 0.5, -11.5)));\n    \n    vec3 qpr = q - vec3(-2.5, height + 1.1, -11.5);\n    qpr.xy = qpr.yx;\n    baseMetal.x = sdVerticalCapsule(qpr, 6.0, 0.04);\n        \n    vec3 ql = q - vec3(4.0, height * 0.5 + 4.0, -8.6);\n    \n    // Dock ladder\n    float ladderTrough = sdBox(ql, vec3(0.4, height, 0.55));\n    base.x = max(base.x, -ladderTrough);\n    \n    float rungs = sdLadderRungs(ql - vec3(-0.1, -height * 0.5, -0.5));\n    baseMetal.x = min(baseMetal.x, rungs);\n    \n    // Guardrails\n    float guardrails = sdGuardRailSegments(q - vec3(0.0, height, 0.0));\n    baseMetal.x = min(baseMetal.x, guardrails);\n    \n    base.x -= 0.05;\n    \n    return pickClosest(base, baseMetal);\n\n}\n\n\nvoid sdWindow( vec3 p, inout vec3 tower, float id, float taper )\n{\n    \n    p.z -= taper - 0.2;\n    \n    float r = 3.7;\n\n    vec3 origin = vec3(p.x, p.y, -p.z - r);\n    vec3 size = vec3(0.7, 1.0, 1.1);\n\n    // Stone frame\n    float windowFrame = max(sdBox(origin, size), sdCylinder(p, vec2(3.85, 20.2)));\n    \n    tower = pickClosest( vec3(windowFrame, MATERIAL_LIGHTHOUSE_WINDOW, id), tower );\n\n    size += vec3(-0.3, -0.3, 0.3);\n    float windowInset = sdBox(origin, size);\n    tower = pickFarthest( vec3(-windowInset, MATERIAL_LIGHTHOUSE_WINDOW, id), tower );\n    \n    p.z += taper - id * 0.13 - 0.2;\n    \n    float casementOffset = 0.15;\n    // Casement: vertical bars\n    float sv = 0.45;\n    vec3 qv = p - vec3(0.0, -0.72, casementOffset - r);\n    float idv = clamp(floor((qv.x + sv * 0.5)/sv), -1.0, 1.0);\n    qv.x = qv.x - sv * idv;\n    \n    float th = 0.03 + abs(idv) * 0.05;\n    float windowCasementVertical = sdVerticalCapsule(qv, 1.44, th);\n    tower = pickClosest( vec3(windowCasementVertical, MATERIAL_LIGHTHOUSE_WINDOW_CASEMENT, id), tower);\n    \n    // Casement: horizontal bars\n    float sh = 0.36;\n    vec3 qh = p - vec3(0.45, 0.0, casementOffset - r);\n    float idh = clamp(floor((qh.y + sh * 0.5)/sh), -2.0, 2.0);\n    qh.y = qh.y - sh * idh;\n    qh = vec3(qh.y, -qh.x, qh.z);\n    \n    th = 0.03 + smoothstep(1.1, 1.1, abs(idh)) * 0.05;\n    float windowCasementHorizontal = sdVerticalCapsule(qh, 0.9, th);\n    tower = pickClosest( vec3(windowCasementHorizontal, MATERIAL_LIGHTHOUSE_WINDOW_CASEMENT, id), tower);\n}\n\n\nvoid sdStairwellWindow( vec3 p, inout vec3 tower, float id, float taper )\n{\n    p.z -= taper - 0.2;\n    \n    float r = 3.7;\n\n    vec3 origin = vec3(p.x, p.y, -p.z - r);\n    vec3 size = vec3(0.45, 0.7, 0.7);\n\n    // Stone frame\n    float windowFrame = max(sdBox(origin, size), sdCylinder(p, vec2(3.85, 20.2)));\n    \n    tower = pickClosest( vec3(windowFrame, MATERIAL_LIGHTHOUSE_WINDOW, id), tower );\n    \n    size += vec3(-0.2, -0.2, 0.2);\n    float windowInset = sdBox(origin, size);\n    tower = pickFarthest( vec3(-windowInset, MATERIAL_LIGHTHOUSE_WINDOW, id), tower );\n    \n    float windowCasement = sdBox(origin + vec3(0.0, 0.0, 0.1), vec3(size.x, size.y, 0.1));\n    \n    float roundWindow1 = sdCylinderInfinite(vec3(origin.x, origin.z, origin.y), vec3(0.0,  0.19, 0.16));\n    float roundWindow2 = sdCylinderInfinite(vec3(origin.x, origin.z, origin.y), vec3(0.0, -0.19, 0.16));\n    \n    windowCasement = max(windowCasement, -roundWindow1);\n    windowCasement = max(windowCasement, -roundWindow2);\n    \n    tower = pickClosest( vec3(windowCasement, MATERIAL_LIGHTHOUSE_WINDOW_CASEMENT, id), tower);\n}\n\n\nvec3 sdLighthouseTower( vec3 p )\n{\n\n    float tower = sdCylinder(p, vec2(4.0, 20.2));\n    float towerTaper = p.y * 0.02 + exp((p.y + 30.0) * 0.06) * 0.025;\n    tower += towerTaper;\n    \n    vec3 Tower = vec3(tower, MATERIAL_LIGHTHOUSE_MASONRY, 3.0 + step(5.6, p.y) + step(19.2, p.y));\n        \n    // Windows\n    \n    float step = 3.7;\n    vec3 qw = p;\n    qw.y = qw.y - 2.25;\n    float idw = clamp(round(qw.y / step), -1.0, 4.0);\n    qw.y = qw.y - step * idw;\n    \n    sdWindow(qw, Tower, idw, towerTaper);\n    \n    float step2 = 3.7;\n    vec3 qsw = p;\n    qsw.xz = qsw.zx;\n    qsw.y = qsw.y - 3.7;\n    float idsw = clamp(round(qsw.y / step2), -2.0, 3.0);\n    qsw.y = qsw.y - step2 * idsw;\n    \n    sdStairwellWindow(qsw, Tower, idsw, towerTaper);\n    \n    float towerbase = sdCylinder(p - vec3(0, -6.8, 0), vec2(4.2, 0.25)) - 0.1;\n    Tower.x = smin(Tower.x, towerbase, 0.1);\n    \n    float taper = sdCylinder(p - vec3(0, 19.2, 0), vec2(3.3 + (p.y - 19.1) * 0.9, 0.3));\n    \n    Tower.x = min(Tower.x, taper);\n        \n    // Platform\n    \n    float platform = sdCylinder(p - vec3(0, 19.8, 0), vec2(3.8, 0.5)) - 0.05;\n    \n    vec3 pb = p;\n    pb.zx = pb.xz;\n    float balcony = sdBox(pb - vec3(0.0, 20.3, 2.4), vec3(1.2, 0.1, 2.5) ) - 0.1;\n    \n    Tower.x = min(Tower.x, min(platform, balcony));\n    \n    return Tower;\n\n}\n\n\nfloat sdWindArrow( vec3 q )\n{\n    \n    float arrow = sdVerticalCapsule(q.yzx - vec3(0.0, -0.7, 0.0), 1.4, 0.025);\n    vec3 qw = q - vec3(0.0, 0.0, -0.6);\n    arrow = min(arrow, sdBox(qw, vec3(0.025, 0.05 - clamp(qw.z, -.5, .5) * 0.25, 0.30))); // wing\n    vec3 qh = q - vec3(0.0, 0.0,  0.7);\n    arrow = min(arrow, sdBox(qh, vec3(0.025, 0.05 - clamp(qh.z, -.5, 0.5) * 0.5, 0.1))); // arrowhead\n    \n    return arrow;\n}\n\n\nfloat sdWindCock( vec3 q )\n{\n    float windcock = sdVerticalCapsule(q, 3.0, 0.025);\n    \n    // cardinal axes\n    q.y -= 1.2;\n    windcock = min(windcock, sdCapsule(q, vec3(-0.75, 0, 0), vec3(0.75, 0, 0), 0.025));\n    windcock = min(windcock, sdCapsule(q, vec3(0, 0, -0.75), vec3(0, 0, 0.75), 0.025));\n        \n    // wind arrows\n    q.y -= 0.8;\n    q.xz = q.xz * lighthouseRotation;\n    windcock = min(windcock, sdWindArrow(q));\n    q.xz = q.xz * -lighthouseRotation;\n    windcock = min(windcock, sdWindArrow(q.zyx));\n    \n    return windcock;\n}\n\n\nvec3 sdLanternRoof( vec3 q )\n{\n    \n    float lanternHalfDome = sdSphere(q, 1.85);\n    lanternHalfDome -= pow(abs(sin(5.0 * atan(q.z, q.x) + 1.570796)), 20.0) * 0.07;\n    lanternHalfDome = max(-sdBox(q - vec3(0.0, -1.2, 0.0), vec3(2.3, 1.5, 2.3)), lanternHalfDome);\n    \n    q.y -= 0.3;\n    float lanternRoofRimBase = sdCylinder(q, vec2(1.95, 0.05)) - 0.02; q.y += 0.05;\n    float lanternRoofRimEdge = sdCylinder(q, vec2(2.1, 0.01));\n    float lanternRoofRim = smin(lanternRoofRimBase, lanternRoofRimEdge, 0.3);\n    \n    q.y -= 1.8; float neckRing1 = sdSphere(q, 0.28);\n    //q.y -= 0.1; float neckRing2 = sdSphere(q, 0.3);\n    q.y -= 0.5; float lanternTop = sdSphere(q, 0.45);\n    lanternTop = min(lanternTop, min(neckRing1, 1e20));\n    \n    float windcock = sdWindCock(q);\n    \n    lanternTop = smin(lanternTop, windcock, 0.3);\n\n    return vec3(smin(smin(lanternHalfDome, lanternTop, 0.2), lanternRoofRim, 0.2), MATERIAL_LIGHTHOUSE_METAL, 0.0);\n}\n\n\nvec3 sdLanternCrane( vec3 p )\n{\n    vec3 q = p - vec3(-0.5, 0.8, -2.8);\n \n    float mast = sdCylinder(q - vec3(0.0, -0.15, 0.0), vec2(0.12, 2.2));\n    \n    float boom = sdVerticalCapsule(q.yzx - vec3(1.95, -2.0, 0.0), 1.8, 0.05);\n    \n    vec3 braceAxis = normalize(vec3(0.0, -0.35, 1.0));\n    float dbar = sdCapsule(q - vec3(0.0, 1.63, -1.1), braceAxis * -0.95, braceAxis * 0.95, 0.05);\n    boom = min(boom, dbar);\n    \n    float vbar1 = sdVerticalCapsule(q - vec3(0.0, 1.32, -0.2), 0.62, 0.05);\n    boom = min(boom, vbar1);\n    \n    float vbar2 = sdVerticalCapsule(q - vec3(0.0, 1.58, -0.85), 0.36, 0.05);\n    boom = min(boom, vbar2);\n    \n    return vec3(min(mast, boom), MATERIAL_LIGHTHOUSE_METAL, 0.0);\n}\n\n\nvec3 sdLanternWindowFrameSegment( vec3 q, float ido )\n{\n    \n    q.y -= 4.36;\n    vec3 rq = q;\n        \n    // rotational repetition\n    float an = atan(rq.z, rq.x);\n    float sp = 3.141592 / 5.0;\n    float id = floor(an / sp);\n    float qan0 = (id + ido) * sp;\n    float qan1 = ((id + ido) + 0.5) * sp;\n    float r = 1.9;\n    \n    rq = rq - vec3(cos(qan0) * r, 0.0, sin(qan0) * r);\n    rq.xz = rq.xz * mat2(cos(qan1), sin(qan1), -sin(qan1), cos(qan1));\n    \n    vec2 panesize = vec2(0.6, 0.5);\n    \n    // framing\n    float vertical = sdVerticalCapsule(rq - vec3(0.0, -panesize.y, 0.0), panesize.y * 2.0, 0.04 );\n    float horizontal1 = sdVerticalCapsule(rq.xzy - vec3(0.0, 0.0, -panesize.y), panesize.x * 2.0, 0.04 );\n    float horizontal2 = sdVerticalCapsule(rq.xzy - vec3(0.0, 0.0, panesize.y), panesize.x * 2.0, 0.04 );\n    \n    vec2 centerOffset = vec2(-0.0, -panesize.x);\n    rq = rq - vec3(0.0, -panesize.y, 0.0);\n    rq.xz = rq.xz + centerOffset.xy;\n    rq.z = abs(rq.z);\n    \n    float diagonal = sdCapsule(rq, vec3(0.0, 0.0, panesize.x-0.15), vec3(0.1, -2.1, 0.1), 0.04);\n    \n    return vec3(min(min(vertical, diagonal), min(horizontal1, horizontal2)), MATERIAL_LIGHTHOUSE_METAL, 0.0);\n\n}\n\n\nvec3 sdLanternWindowGlassSegment( vec3 q, float ido )\n{\n    \n    q.y -= 4.36;\n    vec3 rq = q;\n        \n    // rotational repetition\n    float an = atan(rq.z, rq.x);\n    float sp = 3.141592 / 5.0;\n    float id = floor(an / sp);\n    float qan0 = (id + ido) * sp;\n    float qan1 = ((id + ido) + 0.5) * sp;\n    float r = 1.85;\n    \n    rq = rq - vec3(cos(qan0) * r, 0.0, sin(qan0) * r);\n    rq.xz = rq.xz * mat2(cos(qan1), sin(qan1), -sin(qan1), cos(qan1));\n    \n    vec2 panesize = vec2(0.6, 0.5);\n    \n    // window panes\n    vec3 squarePane = vec3(sdBox(rq - vec3(0.0, 0.0, panesize.x), vec3(0.02, panesize.y, panesize.x)), MATERIAL_LIGHTHOUSE_LANTERN_GLASS, id + 1.0);\n    \n    float slope = rq.y * 0.155;\n    float triangularPane1 = sdBox(rq - vec3(-0.04 - q.y * 0.05, -2.0, panesize.x), vec3(0.02, 1.5, panesize.x - 0.1 + slope));\n    \n    vec3 rqt2 = q - vec3(cos(qan0) * r * 0.95, 0.0, sin(qan0) * r * 0.95);\n    rqt2.xz = rqt2.xz * mat2(cos(qan0), sin(qan0), -sin(qan0), cos(qan0));\n    rqt2.z += float(panesize);\n    float triangularPane2 = sdBox(rqt2 - vec3(0.05 + q.y * 0.01, -2.0, panesize.x), vec3(0.02, 1.5, panesize.x - 0.5 - slope));\n    \n    return pickClosest(squarePane, vec3(min(triangularPane1, triangularPane2), MATERIAL_LIGHTHOUSE_LANTERN_GLASS, id));\n\n}\n\n\nvec3 sdLantern( vec3 p )\n{\n    \n    vec3 q = p - vec3(0.0, 21.6, 0.0);\n    \n    vec3 lanternFoundation = vec3(sdCylinder(q, vec2(2.4, 1.5)), MATERIAL_LIGHTHOUSE_MASONRY, 2.0);\n    float lanternFoundationRim = sdCylinder(q - vec3(0, 1.45, 0), vec2(2.6, 0.15)) - 0.04;\n    lanternFoundation.x = min(lanternFoundation.x, lanternFoundationRim);\n    \n    vec3 lanternBase = vec3(sdCylinder(q - vec3(0, 1.7, 0), vec2(1.95, 0.15)) - 0.02, MATERIAL_LIGHTHOUSE_METAL, 0.0);\n    vec3 lantern0 = sdLanternWindowFrameSegment(q, 0.0);\n    vec3 lantern1 = sdLanternWindowFrameSegment(q, 1.0);\n    vec3 lantern = pickClosest(pickClosest(lantern0, lantern1), lanternBase);\n        \n    lantern = pickClosest(lantern, sdLanternCrane(q));\n        \n    q.y -= 4.7;\n    vec3 lanternRoof = sdLanternRoof(q);\n    \n    return pickClosest(pickClosest(lantern, lanternFoundation), lanternRoof);\n}\n\n\nvec3 sdLanternGlass( vec3 p )\n{\n    \n    vec3 q = lighthousePosition(p);\n    q = q - vec3(0.0, 21.6, 0.0);\n    \n    vec3 lantern0 = sdLanternWindowGlassSegment(q, 0.0);\n    vec3 lantern1 = sdLanternWindowGlassSegment(q, 1.0);\n    return pickClosest(lantern0, lantern1);\n}\n\n\n\nvec3 sdLighthouse( vec3 p )\n{\n\n    vec3 q = lighthousePosition(p);\n\n    // Foundation\n    vec3 lighthouse = sdLighthouseBase(q);\n    \n    // Tower\n    vec3 tower = sdLighthouseTower(q);\n    lighthouse = pickClosest(lighthouse, tower);\n    \n    // Protection wall\n    vec3 qw = q;\n    qw.xz = -q.zx;\n    vec3 wall = vec3(sdBox(qw - vec3(-3.4, 7.6 + 1.5 - 15.0, -5.0), vec3(0.35, 1.2, 6.0)), MATERIAL_LIGHTHOUSE_CONCRETE, 0.0);\n    lighthouse = pickClosest(lighthouse, wall);\n    \n    // Silos\n    vec3 qs = q - vec3(2.5, -3.9, 0.0);\n    vec3 h = vec3(2.0, 0.0, 0.0);\n    float silof = sdBox(qs - vec3(2.0, 0.0, 0.5), vec3(1.0, 4.0, 1.5));\n    qs.z += 1.0;\n    float silo1 = sdCylinder(qs - clamp(qs, -h, h), vec2(1.2, 4.0));\n    qs.z -= 3.0;\n    float silo2 = sdCylinder(qs - clamp(qs, -h, h), vec2(1.2, 4.0));\n    \n    silof = smin(silof, min(silo1, silo2), 0.1);\n    silof = max(silof, -sdBox(qs - vec3(2.0, -1.1, -1.5), vec3(1.5, 2.0, 0.55)));\n    \n    vec3 silo = vec3(silof - 0.05, MATERIAL_LIGHTHOUSE_CONCRETE, 0.0);\n    silo.x = min(silo.x, sdBox(qs + vec3(-0.8, 1.0, 1.5), vec3(1.0, 2.2, 1.0)));\n    \n    lighthouse = pickClosest(lighthouse, silo);\n    \n    // Door\n    vec3 door = vec3(sdBox(qs + vec3(-1.8, 1.4, 1.5), vec3(0.05, 1.6, 0.4)), MATERIAL_LIGHTHOUSE_DOOR, 0.0);\n    lighthouse = pickClosest(lighthouse, door);\n    \n    // Platform railings\n    float guardrails = sdGuardRails(q - vec3(0.0, 20.2, 0.0), 3.8);\n    lighthouse = pickClosest(lighthouse, vec3(guardrails, MATERIAL_LIGHTHOUSE_METAL, 0.0));\n        \n    // Lantern\n    \n    vec3 lantern = sdLantern(q);\n    \n    lighthouse = pickClosest(lighthouse, lantern);\n    \n    return lighthouse;\n\n}\n\n\nfloat getLighthouseBumpMap( vec3 p, vec3 ob )\n{\n\n   vec3 q = p - lighthouseOrigin;\n   q.xz = mat2(0.7071, -0.7071, 0.7071, 0.7071) * q.xz;\n   float an = atan(q.x, q.z);\n        \n   vec2 qa = vec2(cos(an), sin(an)) * p.y * 32.0 + p.y;\n   float n = FBM( qa, 3, 0.75 );\n   \n   float b = 0.0\n           + n * 0.02 * float(ob.y == MATERIAL_LIGHTHOUSE_WINDOW)\n           + n * 0.1  * float(ob.y == MATERIAL_LIGHTHOUSE_CONCRETE);\n   \n   if (ob.y == MATERIAL_LIGHTHOUSE_MASONRY) \n   {\n       vec2 brick = brickPattern(q, ob);\n       \n       float depth = 0.4 - step(3.0, ob.z) * 0.3 - step(4.0, ob.z) * 0.098;\n\n       b += (min(brick.x, brick.y) + brick.x * 0.25) * depth;\n\n    }\n    \n    return b;\n}\n\n\n\n\n\n// OCEAN SDF\n\n\nfloat sineSquaredPos(float v)\n{\n\n    return pow(abs(0.5 + v * 0.5), 2.0);\n\n}\n\n\nfloat sineSquared(float v)\n{\n\n    return -1.0 + sineSquaredPos(v) * 2.0;\n\n}\n\n\nfloat sineB(vec2 rp, float time) {\n  \n  float a = sin((rp.x * 0.117351 + rp.y * 0.917892) + time);\n  float b = sin((rp.x * -0.991752 + rp.y * 0.123639) + time);\n\n  return mix(a, b, 0.6667);\n\n}\n\n\nfloat sineA(vec2 q, float time) {\n  \n  float o = sin(q.y + time);\n  \n  float s = sin(q.x + time);\n  \n  s += sineSquared(sin(2.0 * q.x + 0.4971 + o)) * 0.5;\n  s += sineSquared(sin(4.0 * q.x + 1.1238 + o)) * 0.25;\n  s += sin(8.0 * q.x + 2.5781 + o) * 0.125;\n  //s += sin(16.0 * q.x + 4.6823 + o) * 0.0625;\n\n  return s;\n\n}\n\n\nfloat[9] getOceanTimes(float offset)\n{\n    float t0 = (iTime + offset) * 0.6;\n    float t1 = t0 * 0.5;\n    float t2 =  1.0 + -t0 * 0.25;\n    float times[9] = float[9](\n        t0,\n        t1,\n        -t0,\n        -t1,\n        t2,\n        t2 * 5.0,\n        t1 * 0.1,\n        t1 * 0.5,\n        t2 * 0.25\n      );\n    return times;\n}\n\n\nfloat wave(float x, float t)\n{\n    float p = x + t;\n    float gtx = cos(p);\n    float gty = sin(p);\n    \n    return sin(p - gtx) + gty;\n}\n\nfloat lighthouseSwell(vec3 rp, float t1, float t2, float swell, float waves)\n{\n  vec3 lq = lighthousePosition(rp);\n  float ld = clamp(sdLighthouseFoundation2D(lq.xz), 0.0, 100.0);\n  float d = 50.0 / (10.0 + ld);\n  \n  float h = 0.0;\n  \n  d *= (1.5 + (swell + waves) * 0.1);\n  float x = ld * 0.2;\n  \n  h += d * 0.25 * (0.5 + waves * 0.5) * (0.5 + swell * 0.5);\n\n  // radial wave pattern against the base of the lighthouse\n  float a = wave(x,        t1);\n  float b = wave(x * 4.0,  t1) * 0.1;\n  \n  h += a + b;\n  \n  // wave pattern at the circumference of the lighthouse\n  vec2 rq = rp.xz - lighthouseOrigin.xz;\n  float an = -atan(rq.y, rq.x);\n  \n  float a2 = wave(an,        t2);\n  float b2 = wave(an * 4.0,  t2) * 0.1;\n  float c2 = wave(an * 16.0, t2) * 0.04;\n  \n  h += a2 + b2 + c2;\n  \n  return h * 0.1 * d + exp(-pow(ld, 2.0)) * (ld + 1.0) * 0.25;\n    \n}\n\n\n\nfloat oceanSurface(vec3 rp, float[9] times) {\n    \n    //return 0.0;\n    \n    float  t0 = times[0];\n    float  t1 = times[1];\n    float _t0 = times[2];\n    float _t1 = times[3];\n    \n    float t2 = times[4];\n    float t3 = times[5];\n    \n    float cost = cos(t0);\n    float sint = sin(t0);\n        \n    float h = 1.0;\n    rp.x += cost * 0.5;\n    \n    float swell = wave((rp.x + rp.z * 0.5) * 0.025,  t1);\n    float waves = wave((rp.x + rp.z * 0.8) * 0.050,  t0);\n    \n    h += swell * 0.5;\n    h += waves * 1.5;\n\n    float windnoise = 0.0;\n\n    float wt1 = _t0;\n    vec2 wq1 = vec2(rp.x, rp.z * 1.2);\n    float x1 = (wq1.x + wq1.y) * 0.2;\n    float a1 = wave(x1 * 1.1,   wt1);\n    float b1 = wave(x1 * 3.9,   wt1) * 0.1;\n    \n    windnoise += (a1 + b1) * 0.15;\n    \n    float wt2 = _t1;\n    vec2 wq2 = vec2(rp.x, rp.z * 0.3 + cost);\n    float x2 = (wq2.x + wq2.y) * 0.2 - waves * 0.25;\n    float a2 = wave(x2 * 1.0,  wt2);\n    float b2 = wave(x2 * 4.0,  wt2) * 0.1;\n    \n    windnoise += (a2 + b2) * 0.25;\n    \n    h += windnoise * (1.0 + (swell + waves) * 0.1);\n    \n    h += lighthouseSwell(rp, t2 * 4.0, t3, swell, waves) * 0.8;\n    \n    return h;\n}\n\n\nvec3 sdOcean( vec3 p, float[9] times )\n{\n    return vec3(p.y - oceanSurface(p, times), MATERIAL_SEA, 0.0);\n}\n\n\nfloat getOceanBumpMap( vec3 rp, float[9] times )\n{\n  //return 0.0;\n  \n  vec3 lq = lighthousePosition(rp);\n  float sd = sdLighthouseFoundation2D(lq.xz);\n\n  float d = 50.0 / (10.0 + sd);\n  vec2 p0 = vec2(rp.z, rp.x * 1.2) * 0.4;\n  \n  // general noise\n  //  * -sin(sd * 0.001 + times[3] * 0.02)\n  float t = times[3];\n  \n  float gn0 = FBM(p0 + t * 1.5, 4, 0.55 );\n  float gn1 = FBM(p0 + t * sin(sd * 0.001 * d - t * 0.002) + gn0 * 4.0, 4, 0.5 );\n  \n  return gn0 * (0.5 + 0.5 * gn1) * d * 0.5;\n}\n\n\nvec3 oceanShading(vec3 ro, vec3 rd, vec3 rp, vec3 n, float t, float[9] times)\n{\n    //return vec3(0.18);\n    vec3 q = rp - lighthouseOrigin;\n    float sd = sdLighthouseFoundation2D(q.xz) + 10.0;\n    \n    // lighthouse wash\n        \n    float d = 50.0 / (10.0 + sd);\n    float r = sd + sin(iTime);\n    float an = atan(q.x, q.z) - iTime * 0.02;\n    float ns = FBM( vec2(cos(an) * r, sin(an) * r) * 0.1, 5, 0.9 );\n        \n    sd = sd * ns;\n    \n    // Initial color\n    float ht = 1.0 - exp(-rp.z * 0.01);\n    vec3 col = mix(vec3(0.16, 0.18, 0.19), vec3(0.14, 0.16, 0.17), ht);\n        \n    // general noise\n    vec2 p0 = vec2(rp.z, rp.x * 1.2) * 0.3;\n    //float gn = FBM(p0+ times[3] * exp(-sd * 0.001), 4, 0.5 );\n\n    float tg = times[3];\n    float gn0 = FBM(p0 + tg, 4, 0.5 );\n    float gn1 = FBM(p0 + tg * sin(sd * 0.001 * d - tg * 0.002) + gn0 * 2.0, 4, 0.5 );\n\n    float gn = gn0 * gn1;\n    \n    // turbulent water -- deeper water        \n    float d0 = smoothstep(30.0, 90.0 + (10.0 * sin(iTime * 0.4896)), sd);\n    col = mix(vec3(0.26, 0.3, 0.33) * (0.25 + (1.0 - d0) * 1.1 * (0.5 + 0.5 * gn)), col, pow(d0, 2.0));\n    \n    // turbulent water -- foamy water\n    float ns0 = FBM( vec2(rp.x + iTime * 1.4783, rp.z + iTime * 0.674) * 0.05, 4, 0.65 );\n    ns0 = pow(ns0, 2.0);\n    \n    float ns1 = FBM( vec2(rp.x, rp.z - iTime * 1.2233) * 0.1, 5, 0.75 );\n    ns1 = smoothstep(0.25 - sin(iTime * 0.9235) * 0.05, 1.0, ns1);\n    \n    float d1 = 1.0 - smoothstep(25.0, 30.0 + ns * 20.0, sd);\n    col = mix(col, vec3(0.58, 0.6, 0.62), pow(d1, 2.0) * ns1 * ns0 * (0.5 + 0.5 * gn));\n    \n    // Wave highlights\n    col *= (1.0 + smoothstep(0.2, 0.9, ns1) * smoothstep(-5.0, 15.0, rp.y - 2.0) * 0.2 * step(0.0, rp.y));\n    \n    // wave sub-surface\n    col = mix(col, vec3(0.15, 0.4, 0.5) * 0.5, d0 * max(0.0, dot(reflect(rd, n), n)));\n    \n    col *= (0.8 + 0.2 * ns * ns0);\n    \n    return col;\n}\n\n\n// RENDERING FUNCTIONS\n\n\nvec3 applyFog(vec3 rd, inout vec3 col, vec3 skyColor, float t)\n{\n    float ns = FBM( vec2(rd.x + iTime * 0.1, rd.y) * 0.5, 4, 0.65 );\n    \n    float fog = pow(smoothstep(200.0, 600.0, t), 0.5);\n        \n    vec3 fogColor = vec3(0.67, 0.68, 0.67) * skyColor + (0.35 * ns - 0.25);\n    fogColor = fogColor * exp(-vec3(1.0, 1.0, 0.95) * t * 0.00002);\n    \n    fogColor = smoothstep(-0.1, 1.15, fogColor);\n    \n    return mix(col, fogColor, fog);\n}\n\n\nvec3 scenePoint( vec3 p, float[9] times )\n{\n    vec3 d = vec3(MAX_DIST, MATERIAL_SKY, 0.0);\n    \n    vec3 ocean = sdOcean(p, times);\n    \n    // First checking if we're within a reasonable distance\n    // from the lighthouse before evaluate its SDF\n    vec3 lq = p - lighthouseOrigin;\n    if (dot(lq, lq) < 1225.0) d = pickClosest(d, sdLighthouse(p));\n    \n    d = pickClosest( ocean, d);\n\n    return d;\n}\n\n\n\n#define ZERO (min(iFrame,0))\n\n// https://iquilezles.org/articles/normalsSDF\n\nvec3 calcOceanNormal( in vec3 pos, float times[9] )\n{\n\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.05;\n    return normalize( e.xyy*sdOcean( pos + e.xyy, times ).x + \n                      e.yyx*sdOcean( pos + e.yyx, times ).x + \n                      e.yxy*sdOcean( pos + e.yxy, times ).x + \n                      e.xxx*sdOcean( pos + e.xxx, times ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        vec3 p = pos+0.05*e;\n        n += e * (sdOcean(p, times).x + getOceanBumpMap(p, times));\n        //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nvec3 calcLighthouseNormal( in vec3 pos, in float t, vec3 ob )\n{\n\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.05;\n    return normalize( e.xyy*sdLighthouse( pos + e.xyy ).x + \n                      e.yyx*sdLighthouse( pos + e.yyx ).x + \n                      e.yxy*sdLighthouse( pos + e.yxy ).x + \n                      e.xxx*sdLighthouse( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        vec3 p = pos+0.05 * e;\n        n += e * (sdLighthouse(p).x + getLighthouseBumpMap(p, ob));\n        //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    \n    return normalize(n);\n#endif    \n}\n\nvec3 calcLanternGlassNormal( in vec3 pos )\n{\n\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.05;\n    return normalize( e.xyy*sdLanternGlass( pos + e.xyy ).x + \n                      e.yyx*sdLanternGlass( pos + e.yyx ).x + \n                      e.yxy*sdLanternGlass( pos + e.yxy ).x + \n                      e.xxx*sdLanternGlass( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        vec3 p = pos+0.05 * e;\n        n += e * sdLanternGlass(p).x;\n        //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    \n    return normalize(n);\n#endif    \n}\n\n\nfloat softshadowOcean( in vec3 ro, in vec3 rd, float mint, float maxt, float w, float[9] times )\n{\n    float res = 2.0;\n    float ph = 1e20;\n    float t = mint;\n    \n    for( int i=0; i<64 && t<maxt; i++ )\n    {\n        float h = scenePoint(ro + rd*t, times).x;\n        \n        if( h<0.001 * t )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, d/(w*max(0.0,t-y)) );\n        ph = h;\n        t += h;\n    }\n    \n    return res;\n}\n\n\nfloat softshadowLighthouse( in vec3 ro, in vec3 rd, float mint, float maxt, float w )\n{\n    float res = 2.0;\n    float ph = 1e20;\n    float t = mint;\n    \n    for( int i=0; i<128 && t<maxt; i++ )\n    {\n        float h = sdLighthouse(ro + rd*t).x;\n        if( h<0.001 * t )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, d/(w*max(0.0,t-y)) );\n        ph = h;\n        t += h;\n    }\n    \n    return res;\n}\n\n\n// https://blog.devgenius.io/some-interesting-raymarching-concepts-8e38aa67e1ef\nfloat ao(vec3 ro, vec3 n, float k)\n{\n    float res = 0.0;\n    float f = 0.25;\n    \n    float times[9] = getOceanTimes(0.0);\n    \n    for(int i=1; i<6; i++)\n    {\n        vec3 rp = ro + f * float(i) * n;\n        //res+=(1.0 / pow(2.0, float(i))) * (f * float(i) - min(sdLighthouse(rp).x, rp.y)); \n        res+=(1.0 / pow(2.0, float(i))) * (f * float(i) - scenePoint(rp, times).x);    \n    }\n    return k*res;\n}\n\n\nfloat getLanternLighting(vec3 ro, vec3 rd, vec3 rp, vec3 n, vec3 ob)\n{\n\n    vec3 toLantern = rp - lighthouseLantern;\n    float toLanternDist = length(toLantern);\n    toLantern = normalize(toLantern);\n    \n    vec3 beam = beamVector(0.0);\n    float beamAlignment = 0.25 + abs(dot(toLantern, beam)) * 0.75;\n    float normalAlignment = max(0.0, dot(-toLantern, n));\n    \n    normalAlignment = mix(normalAlignment, 0.8 + normalAlignment * 0.2, float(ob.y == MATERIAL_LIGHTHOUSE_LANTERN_GLASS));\n    \n    return beamAlignment * normalAlignment;\n\n}\n\n\nconst vec3 keyLightColor = normalize(vec3(1.0, 0.8, 0.5));\nconst vec3 fillLightColor = normalize(vec3(0.8, 1.0, 1.2));\nconst vec3 ambtLightColor = normalize(vec3(0.92, 0.98, 1.1)) * 1.75;\nconst vec3 lntnLightColor = normalize(vec3(1.4, 1.2, 1.0));\n\n\nvec3 getOceanLighting(vec3 ro, vec3 rd, vec3 rp, vec3 n, float[9] times)\n{\n    vec3 fillight = normalize( vec3(-keylight.x, 0.0, keylight.z * 0.5) );\n\n    float amb = 0.5 + n.y * 0.5;\n\n    float key = max(0.0, dot( -keylight, n ));\n    float fil = max(0.0, dot( -fillight, n ));\n    \n    vec3 nro = rp + n * 0.01;\n    float shd = softshadowOcean(nro, -keylight, 0.0, MAX_DIST, 0.1, times);\n    \n    float ksp = key * pow(max(0.0, dot(-keylight, reflect(rd, n))), 3.0);\n    float kfrsnl = pow(max(0.0, dot(rd, -keylight)), 5.0);\n    \n    vec3 l = vec3(0.0); \n    l += key * 0.7 * shd * keyLightColor;\n    l += fil * 0.3 * fillLightColor;\n    l += ksp * kfrsnl * shd;\n    l += amb * ambtLightColor;\n\n    return l;\n}\n\n\n\nfloat getWindowIllumination(vec3 rp, vec3 n, vec3 ob)\n{\n\n    float idw = ob.z;\n    float ho = idw * 0.13;\n    \n    vec3 innerLightOffset = vec3(0.0, (idw) * 3.8 + 2.0, 0.5);\n    innerLightOffset.xz = innerLightOffset.xz * mat2(0.7071, -0.7071, 0.7071, 0.7071);\n    \n    vec3 q = rp - lighthouseOrigin - innerLightOffset;\n    \n    vec3 light = normalize(q);\n    float windowExposure = max(0.0, dot(n, -light));\n    \n    // Window illumination applies to two windows\n    float litWindows = (step(0.0, idw) - step(2.0, idw));\n    \n    return windowExposure * litWindows;\n}\n\n\nvec3 getLighthouseLighting(vec3 ro, vec3 rd, vec3 rp, vec3 n, vec3 ob)\n{\n\n    vec3 fillight = normalize( vec3(-keylight.x, keylight.y, keylight.z * 0.1) );\n\n    float amb = 0.8 + max(0.0, n.y) * 0.2;\n\n    float key = max(0.0, dot( -keylight, n ));\n    \n    float isWindow = float(ob.y == MATERIAL_LIGHTHOUSE_WINDOW || ob.y == MATERIAL_LIGHTHOUSE_WINDOW_CASEMENT);\n    \n    vec3 q = lighthousePosition(rp);\n    float fillExposure = max(0.0, dot( -fillight, normalize(q))) * (1.0 - isWindow);\n    float fil = max(0.0, dot( -fillight, n )) * fillExposure;\n    \n    vec3 nro = rp + n * 0.01;\n    float shd = softshadowLighthouse(nro, -keylight, 0.0, MAX_DIST, 0.1);\n        \n    float occ = -clamp(ao(rp, n, 1.5), 0.0, 1.0);\n    \n    float ltn = getLanternLighting(ro, rd, rp, n, ob);\n    ltn *= smoothstep(35.5, 38.0, rp.y);\n    \n    float wdw = getWindowIllumination(rp, n, ob) * isWindow;\n    \n    float isLanternGlass = float(ob.y == MATERIAL_LIGHTHOUSE_LANTERN_GLASS);\n    \n    amb *= 1.0 + 0.5 * isLanternGlass;\n    shd = mix(shd, 1.0, isLanternGlass);\n        \n    vec3 l = vec3(0.0); \n    l += key * 0.7 * shd * keyLightColor;\n    l += fil * 0.3 * fillLightColor;\n    l += amb * ambtLightColor * 0.8;\n    l += occ * 0.5;\n    l += ltn * 3.0 * lntnLightColor;\n    l += wdw * 16.0;\n    \n    return l;\n\n}\n\n\n\nfloat getBrickWetness( vec3 rp )\n{\n\n    float wy0 = oceanSurface(rp, getOceanTimes( 0.0));\n    float wy1 = oceanSurface(rp, getOceanTimes(-1.0));\n    float wy2 = oceanSurface(rp, getOceanTimes(-2.0));\n    float wy3 = oceanSurface(rp, getOceanTimes(-4.0));\n    \n    float d0 = 1.0 - smoothstep(0.0, 0.5, rp.y - wy0);\n    float d1 = 1.0 - smoothstep(0.0, 1.0, wy1 - rp.y);\n    float d2 = 1.0 - smoothstep(0.0, 2.0, wy2 - rp.y);\n    float d3 = 1.0 - smoothstep(0.0, 4.0, wy3 - rp.y);\n\n    return 1.0 - (d0 + d1 + d2 + d3) * 0.25;\n\n}\n\n\nvec3 lighthouseShading(vec3 col, vec3 ro, vec3 rd, vec3 rp, vec3 n, float t, vec3 ob)\n{\n    \n    float l = 0.5;\n    float detail = exp(-t * 0.005);\n\n    vec3 q = rp - lighthouseOrigin;\n    q.xz = mat2(0.7071, -0.7071, 0.7071, 0.7071) * q.xz;\n    \n    float r = length(q);\n    float an = atan(q.z, q.x);\n    vec2 qa = vec2( cos(an), sin(an) ) * (q.y + 25.0 + r * 10.0);\n\n    float n0 = FBM(qa * 0.05, 5, 0.8);\n\n    vec2 qa1 = qa * vec2(n0 * 0.3, n0 * 0.5);\n    float n1 = FBM(qa1 * 0.02, 6, 0.7);\n\n    vec2 qa2 = qa * vec2(n0, n1 * 20.0);\n    float n2 = FBM(qa2 * 8.0, 2, 0.3);\n                \n    float n11 = smoothstep(0.60, 1.0, n1);\n    float n12 = smoothstep(0.50, 1.0, n1);\n    float n13 = smoothstep(0.55, 1.0, n1);\n\n    float nbr = max(min(n0, 1.0 - n2 * 0.75), 1.0 - n11);\n    float nbg = max(min(n0, 1.0 - n2), 1.0 - n12);\n    float nbb = max(min(n0, 1.0 - n2 * 0.5), 1.0 - n13);\n    \n    vec3 nb = vec3(nbr, nbg, nbb) * (0.5 + 0.5 * n2);\n    \n    vec3 brickColor = vec3(0.31, 0.32, 0.3)\n        * (0.75 + 0.5 * (1.0 - nb))\n        * (0.6  + 1.0 *        n2)\n        * (0.9  + 0.1 *        vec3(n12, n13, n11))\n        ;\n\n    vec3 paintColor = vec3(0.6, 0.6, 0.62) * (1.1  - 0.2 * nb);\n\n    if (ob.y == MATERIAL_LIGHTHOUSE_METAL)\n    {\n        col = vec3(0.06, 0.08, 0.1)\n            * (0.5 + 2.0 * n13 * nb * n2)\n            + n2 * 0.2;\n    }\n    else if (ob.y == MATERIAL_LIGHTHOUSE_CONCRETE)\n    {\n        col = vec3(0.17, 0.2, 0.18) \n            * (0.75 + 0.5 * n1)\n            * (0.8  + 0.4 * nb)\n            + n1 * 0.1;\n        col *= (0.75 + nb.bgr * (1.0 - nb));\n    }\n    else if (ob.y == MATERIAL_LIGHTHOUSE_DOOR)\n    {\n        col = vec3(0.0, 0.2, 0.1) * n2;\n    }\n    else if (ob.y == MATERIAL_LIGHTHOUSE_MASONRY) \n    {\n\n        if (ob.z == 1.0) \n        {\n            // foundation - dark\n            \n            float wtn = getBrickWetness(rp);\n            wtn = smoothstep(0.1, 0.8, wtn) * (1.0 - smoothstep(7.0, 12.0, rp.y));\n                            \n            // Base color\n            vec2 brick = brickPattern(q, ob);\n            \n            float brick1 = 1.0 - step(0.6, brick.x);\n            float brick2 = step(0.5, brick.x) - step(0.8, brick.x);\n            float brick3 = step(0.8, brick.x);\n            \n            col = brickColor;\n            col = mix(col, brickColor * vec3(1.16, 1.08, 0.99),  brick1); \n            col = mix(col, brickColor * vec3(1.08, 1.05, 1.03),  brick2);\n            col = mix(col, brickColor * vec3(0.95, 0.85, 0.75),  brick3);\n            \n            col = mix(col, col * (0.5 + nb * 0.5), 1.0 - brick.x);\n            col = col * (1.0 - 0.75 * pow(brick.x, 2.0));\n            \n            // Water streaking\n            //float downstream = sin(rp.y * (1.1 + rd.y) + n0) * 0.2 + sin(rp.y * (4.0 - rd.y) + n1) * 0.1 + sin(rp.y * 24.0) * 0.05;\n            \n            //float anw = atan(q.z, q.x);\n            //vec2 qw = vec2(cos(anw), sin(anw));\n            //float nsw0 = FBM( qw * 30.0 + rp.y * 1.2 + iTime, 3, 0.8 );\n            //float nsw1 = FBM( qw * 15.0 + rp.y * 0.3 + iTime * 0.5 + nsw0 * 4.0, 3, 0.4 );\n            \n            float nsw0 = FBM( vec2(atan(q.z, q.x + n1) * 5.0 + n1 * 5.0, rp.y * 1.1 + n2 * 0.5 + iTime + n0), 3, 0.8 );\n            float nsw1 = FBM( vec2(atan(q.z + n1, q.x) * 30.0 + nsw0 * 1.0, rp.y * 0.1 + iTime * 0.5 - nsw0 * 5.0), 3, 0.4 );\n            nsw1 = smoothstep(0.3, 0.4, nsw1) * (0.9 + 0.1 * brick.y);\n            nsw0 *= nsw1;\n            \n            col = col * smoothstep(-4.0, 8.0 + n1 * 2.0, rp.y);\n            col *= (n0 * 0.5) + smoothstep(0.3, 0.7, brick.x) * n1 * 1.0;\n            \n            float streaks = smoothstep(0.8, 0.9, n1) * smoothstep(0.75, 0.85, n1);\n            vec3 rust = vec3(0.11 + n2 * 0.1, 0.1 + n0 * 0.1, 0.08 - n2 * 0.04) * nb.rgg;\n            col = mix(col, rust, streaks * 0.7) * (0.5 + nb.ggg * 0.75);\n            \n            col += brick.y * (0.35 + n13 * 0.25) * (1.0 - n11) * nb.rgb * 0.65;\n            \n            // water leakage\n            col = col - wtn * 0.25; // wet stone darkening\n            col = mix(col, vec3(0.33, 0.37, 0.375) * nsw1, smoothstep(0.0, 0.6, wtn) * wtn * nsw0); // water streaks\n        }\n        else if (ob.z == 3.0)\n        {\n            // tower - dark section\n            \n            vec2 brick = brickPattern(q, ob);\n            \n            float brick1 = 1.0 - step(0.6, brick.x);\n            float brick2 = step(0.5, brick.x) - step(0.8, brick.x);\n            float brick3 = step(0.8, brick.x);\n            \n            col = brickColor;\n            col = mix(col, brickColor * vec3(1.16, 1.08, 0.99),  brick1); \n            col = mix(col, brickColor * vec3(1.08, 1.05,  1.03),  brick2);\n            col = mix(col, brickColor * vec3(0.95, 0.85, 0.75),  brick3);\n            \n            col = mix(col, col * (0.5 + nb * 0.5), 1.0 - brick.x);\n            col = col * (1.0 - 0.75 * pow(brick.x, 2.0));\n            \n            float streaks = smoothstep(0.8, 0.9, n1) * smoothstep(0.75, 0.85, n1);\n            vec3 rust = vec3(0.11 + n2 * 0.1, 0.1 + n0 * 0.1, 0.08 - n2 * 0.04) * nb.rgg;\n            col = mix(col, rust, streaks * 0.6) * (0.75 + nb.ggg * 0.75);\n            col *= 0.1 + smoothstep(9.0, 18.0 + n2 * 0.5, rp.y + 2.0) * 0.75; // water darkening\n            \n            col += brick.y * n2 * (1.2 - n13) * (1.0 - nb.brg * 0.75);\n        \n        }\n        else if (ob.z == 4.0)\n        {\n            // tower - white section\n            \n            col = paintColor;\n            \n            vec2 brick = brickPattern(q, ob);\n            \n            col = col * (0.95 + brick.x * 0.05);\n            \n            vec3 fade = smoothstep(0.6, 1.0, n11) * nb.rbg * (0.5 + n2 * 0.5);\n            col = mix(col, brickColor * vec3(0.25, 0.45, 0.5), clamp(fade, 0.0, 1.0) * 0.5);\n            col = mix(col, paintColor, brick.y);\n            col *= (0.9 + 0.2 * nb);\n            \n            // stripes\n            float roughEdge = n2 * 0.02;\n            float stripe = min(\n                abs(rp.y - 24.65) - 0.14 - roughEdge, \n                abs(rp.y - 27.65) - 0.14 - roughEdge\n                );\n            \n            // letters\n            \n            vec2 lpos = vec2( atan(q.z/q.x) * 1.9 + 0.52, (rp.y - 23.95) / 2.2 );\n            float blackPaint = min(stripe, paintedLetters(lpos));\n            \n            col = col * (1.0 - (0.9 - n1 * n2 * 0.25) * step(0.0, -blackPaint));\n\n        }\n        else if (ob.z == 2.0)\n        {\n            // tower - lanter base\n            \n            vec2 brick = brickPattern(q, ob);\n            \n            float brick1 = 1.0 - step(0.6, brick.x);\n            float brick2 = step(0.5, brick.x) - step(0.8, brick.x);\n            float brick3 = step(0.8, brick.x);\n            \n            col = brickColor;\n            col = mix(col, brickColor * vec3(1.16, 1.08, 0.99),  brick1); \n            col = mix(col, brickColor * vec3(1.08, 1.05,  1.03),  brick2);\n            col = mix(col, brickColor * vec3(0.95, 0.85, 0.75),  brick3);\n            \n            col = mix(col, col * (0.5 + nb * 0.5), 1.0 - brick.x);\n            col = col * (1.0 - 0.75 * pow(brick.x, 2.0));\n            col += brick.y * n2 * nb;\n        \n        }\n        else if (ob.z == 5.0)\n        {\n            // Painted black\n            col = vec3(0.1, 0.1, 0.15) * (0.5 + 0.5 * n2) + (1.0 - nb) * 0.2;\n        }\n        else\n        {\n            col = brickColor * (0.75 + 0.25 * n12) - (1.0 - nb) * 0.25;\n        }\n\n    }\n    else if (ob.y == MATERIAL_LIGHTHOUSE_WINDOW_CASEMENT)\n    {\n        col = vec3(0.7, 0.7, 0.75);\n    }\n    else if (ob.y == MATERIAL_LIGHTHOUSE_WINDOW) \n    {\n        \n        float n01 = smoothstep(0.6, 0.7, n0);\n        float n11 = smoothstep(0.4, 0.7, n1);\n        \n        vec3 qw = q;\n        //float step = 3.8;\n        qw.y = qw.y - 2.2;\n        \n        float idw = ob.z;\n        float ho = idw * 0.13;\n        \n        // Window illumination, applies to two windows\n        float litWindows = (step(0.0, idw) - step(2.0, idw));\n        \n        vec3 paintedCol = paintColor;\n        vec3 fade = smoothstep(0.7, 1.0, n11) * nb.rbg * (0.8 + n2 * 0.2);\n        paintedCol = mix(paintedCol, paintedCol * vec3(0.75, 0.9, 1.0) * 2.0, clamp(fade, 0.0, 1.0) * 0.1);\n        \n        vec3 unpaintedCol = brickColor * (0.5 + 0.5 * nb) * (0.75 + 0.25 * n12);\n        unpaintedCol *= 0.25 + smoothstep(12.0, 15.0 + n01 * 0.5, rp.y) * 0.75; // water darkening\n        \n        float streaks = smoothstep(0.8, 0.9, n1) * smoothstep(0.75, 0.85, n1);\n        unpaintedCol = mix(unpaintedCol, vec3(0.11, 0.1, 0.08), streaks * 0.4) * (0.75 + nb.ggg * 0.75);\n        \n        vec3 windowCol = mix(\n            unpaintedCol,  // unpainted\n            paintedCol,    // painted\n            step(0.1, idw)\n            );\n        \n        vec3 unlitPane = getSkyColor(reflect(rd, n));\n        vec3 windowPaneCol = mix(\n            unlitPane,              // unlit\n            vec3(1.35, 1.125, 0.9), // lit\n            litWindows\n        );\n         \n        float paneBoundary = step(3.38, length(qw.xz) + ho);\n        \n        col = mix(windowPaneCol, windowCol, paneBoundary);       \n\n    }\n    \n    return col;\n}\n\n\n\nvec4 raymarchLighthouse( vec3 ro, vec3 rd, vec3 col )\n{\n    \n    float toLighthouse = length(lighthouseOrigin - ro);\n    \n    vec3 rp = ro + rd * toLighthouse;\n    vec3 d = sdLighthouse(rp);\n    \n    if (d.x > 10.0 - rd.y * 10.0) \n    { \n        return vec4(col, MAX_DIST); \n    }\n    \n    float t = toLighthouse - abs(d.x) - 15.0;\n\n   \n    for ( int i=0; i<150; i++)\n    {\n    \n        rp = ro + rd * t;\n        \n        d = sdLighthouse(rp);\n        \n        if (abs(d.x) < 0.0004) break;\n        \n        if (t > toLighthouse + 30.0)\n        {\n            t = MAX_DIST;\n            break;\n        }\n        \n        t = max(1.0, t) + d.x;\n    \n    }\n    \n    if (t < MAX_DIST)\n    {\n        vec3 n = calcLighthouseNormal(rp, t, d);\n        vec3 l = getLighthouseLighting(ro, rd, rp, n, d);\n        \n        vec3 mt = lighthouseShading(col.rgb, ro, rd, rp, n, t, d);\n        \n        col = mt * l;\n    }\n    \n    return vec4(col, t);\n}\n\n\nvec3 renderLanternGlass( vec3 ro, vec3 rd, vec3 col, inout float lt )\n{\n\n    float toLantern = length(lighthouseLantern - ro);\n    vec3 rp = ro + rd * toLantern;\n    \n    float tmax = toLantern * 1.5;\n    \n    vec3 d = sdLanternGlass(rp);\n        \n    if (d.x > 2.0) return col; \n\n    float t = toLantern - abs(d.x) - 2.0;\n        \n    int   ps = 0;    // pass throughs\n    float ft = 1e20; // first hit\n    float dt = 0.0;  // distance travelled through glass\n    float ior = 1.0/1.5;\n    float oir = 1.5;\n    vec3 n = vec3(0.0);\n    \n    bool enteredGlass = false;\n   \n    for ( int i=0; i<1000; i++)\n    {\n        rp = ro + rd * t;\n        \n        d = sdLanternGlass(rp);\n        \n        if (d.x <= 0.01) \n        {    \n            ft = min(t + d.x, ft);\n            \n            dt += 0.001 + step(41.5, rp.y) * 0.004;\n            d.x = 0.001;\n            \n            enteredGlass = true;\n        }\n        else if (d.x > 0.01 && enteredGlass == true)\n        {\n            ps += 1;\n            enteredGlass = false;\n        }\n        \n        \n        if (ps > 2 || (ps > 0 && lt < ft) || t > tmax) break;\n        \n        t = max(1.0, t) + d.x;\n    }\n      \n    if (ps > 0 && ft < lt)\n    {\n      vec3 gp = ro + rd * ft;\n      \n      // transparent color\n      rd = normalize(rp - ro);\n      vec3 absorb = exp(-dt * 10.0 * vec3(0.15, 0.16, 0.45));\n      float cloudiness = 1.0 - exp(-dt * 0.3);\n      vec3 opaqueColor = vec3(1.0 - cloudiness, (1.0 - cloudiness) * 0.75, (1.0 - cloudiness) * 0.5);\n      col = mix(col * absorb, opaqueColor, cloudiness);\n    \n      vec3 gob = vec3(0.0, MATERIAL_LIGHTHOUSE_LANTERN_GLASS, 0.0);\n      vec3 n = calcLanternGlassNormal(gp);\n      vec3 gl = getLighthouseLighting(ro, rd, gp, n, gob);\n      \n      col *= gl;\n      \n      // sky reflection\n      vec3 rrd = reflect(rd, n);\n      float fresnel = pow(max(0.0, dot(rd, rrd)), 5.0);\n      \n      col = mix(col, getSkyColor(rrd), fresnel);\n      \n    }\n    \n    return col;\n}\n\n\nvec4 raymarchOcean( vec3 ro, vec3 rd, float times[9] )\n{\n    vec3 rp = ro + rd * MAX_DIST;\n    \n    vec3 d = sdOcean(rp, times);\n    \n    if (d.x > 0.0) return vec4(0.0, MATERIAL_SKY, 0.0, MAX_DIST);\n    \n    float t = (ro.y - 8.0) / rd.y;\n   \n    for ( int i=0; i<150; i++)\n    {\n        \n        rp = ro + rd * t;\n        d = sdOcean(rp, times);\n        \n        t = max(1.0, t) + d.x;\n        \n        if (abs(d.x) < 0.001 * t) break;\n\n        if (t > MAX_DIST) break;\n        \n    }\n    \n    return vec4(d, t);\n}\n\n\nvec4 renderOcean( vec3 ro, vec3 rd, vec4 col )\n{\n    float times[9] = getOceanTimes(0.0);\n    \n    vec4 R = raymarchOcean(ro, rd, times);\n    \n    if (R.w < col.a)\n    {\n        vec3 rp = ro + rd * R.w;\n        vec3 n = calcOceanNormal(rp, times);\n        vec3 l = getOceanLighting(ro, rd, rp, n, times);\n        \n        vec3 mt = oceanShading(ro, rd, rp, n, R.w, times);\n        \n        col.rgb = mt * l;\n        col.a = R.w;\n        \n        // Reflections\n        vec3 rro = rp + n * 0.1;\n        vec3 rrd = reflect(rd, n);\n        vec4 rR = raymarchOcean(rro, rrd, times);\n        \n        vec3 rcol = getSkyColor(rrd);\n        \n        if (rR.w < MAX_DIST)\n        {\n            vec3 rrp = rro + rrd * rR.w;\n            vec3 rn = calcOceanNormal(rrp, times);\n            vec3 rl = getOceanLighting(rro, rrd, rrp, rn, times);\n\n            vec3 rmt = oceanShading(rro, rrd, rrp, rn, rR.w, times);\n\n            rcol = rmt * rl;\n        \n        }\n        \n        float radius = smoothstep(25.0, 50.0, length(rp.xz - lighthouseOrigin.xz));\n        float reflects = 0.25 * radius * (1.0 - smoothstep(150.0, 300.0, R.w));\n        float frsnl = pow(max(0.0, dot(rrd, rd)), 5.0);\n\n        col.rgb = mix(col.rgb, rcol, reflects * frsnl); \n     \n    }\n    \n    return col;\n}\n\n\nvec3 renderLightBeam(vec3 ro, vec3 rd, vec3 col, vec3 skycolor, inout float rt)\n{\n    vec3 q = beamVector(0.0);\n    float d = sdLighhouseBeam(ro);\n        \n    float or = dot(rd, q);\n    float dt = 0.5 + abs(or) * 1.0;\n    \n    float t = min(d, rt);\n    vec3 rp = ro + rd * t;\n    \n    float dist = 0.0;\n    \n    for (int i=0; i<200; i++) {\n        \n        d = sdLighhouseBeam(rp);\n        \n        vec2 q = rp.xz - lighthouseLantern.xz;\n        d = d / dot(q, q); // light falloff\n        \n        dist += max(0.0, -d / t);\n        t += max(dt, d);\n        \n        if (t >= rt) break;\n        \n        rp = ro + rd * t;\n    \n    }\n    \n    dist = 1000.0 * dist;\n    \n    col *= 3.0 - exp(-dist * vec3(1.0, 0.8, 0.5)) * 2.1;\n    \n    return col;\n}\n\n\nvoid setCamera(vec2 uv, inout vec3 ro, inout vec3 rd)\n{\n\n    float cameraHeight = 100.0; // 15.0\n    float cameraPitch = 0.2; // 0.2\n    float focalLength = 40.0;\n    \n    float h = -2.5; // -2\n    float v = -13.5; // 13\n    \n    ro = vec3(0.0, cameraHeight, -focalLength);\n    ro.xy += uv * 35.0;\n    \n    //ro.z = -4.0;\n    rd = normalize( vec3(h, v, focalLength));\n    \n    //ro.y += cameraHeight;\n\n}\n\n\nvec3 render( vec2 uv )\n{\n    // Camera\n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    \n    setCamera(uv, ro, rd);\n\n    // Ray marching and rendering the scene\n    vec3 skycolor = getSkyColor(rd);\n\n    vec4 L = raymarchLighthouse(ro, rd, skycolor);\n    vec4 O = renderOcean(ro, rd, L);\n    \n    vec3 col = O.rgb; // scene color\n    float t = O.a;    // ray depth\n    \n    col = applyFog(rd, col, skycolor, t);\n    \n    col = renderLightBeam(ro, rd, col, skycolor, t);\n    \n    col = renderLanternGlass(ro, rd, col, t);\n    \n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    fragCoord = fragCoord * 1.2;\n\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = ((2.0 * fragCoord) - iResolution.xy) / iResolution.y;\n    \n    # ifdef AA\n    vec2 dx = vec2(dFdx(uv.x) * 0.25, 0.0);\n    vec2 dy = vec2(0.0, dFdy(uv.y) * 0.25);\n    \n    vec3 col1 = render(uv + dx - dy);\n    vec3 col2 = render(uv - dx - dy);\n    vec3 col3 = render(uv + dx + dy);\n    vec3 col4 = render(uv - dx + dy);\n    \n    vec3 col = (col1 + col2 + col3 + col4) * 0.25;\n    \n    # else\n    vec3 col = render(uv);\n    \n    # endif\n        \n    // Desaturate & color correct\n    \n    float L = dot(col, vec3(0.299, 0.587, 0.114));\n    \n    //col /= L;\n    \n    float exposure = log2(L / 0.5);\n    exposure += 0.2;\n    \n    L = L * pow(2.0, exposure);\n        \n    col = mix(col, vec3(L), 0.35);\n    col = vec3(\n        pow(col.r, 0.82),\n        pow(col.g, 0.85),\n        pow(col.b, 0.85)\n        );\n    col = smoothstep(0.0, 0.8, col);\n    \n    // Lens falloff\n    col *= 1.0 - 0.02 * dot(uv, uv);\n    \n    // Grain\n    col *= 0.95 + staticNoise(uv) * 0.1;\n    \n    // Opening title\n    if (SHOWTITLE) {\n\n        if (paintedLetters(uv * vec2(1.4, 1.2) - vec2(-0.08, -0.75)) < 0.0)\n        {\n            col = mix(vec3(1.0), col, smoothstep(7.0, 7.5, iTime));   \n        }\n        \n        if (iTime > 7.5)\n        {\n            SHOWTITLE = false;\n        }\n    \n    }\n\n    // Output to screen\n    fragColor = vec4(col.rgb, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lfyfzR","date":"1733693262","viewed":165,"name":"Armen Lighthouse (Isometric)","username":"eliaszi","description":"Ar-Men — \"The Rock\" in the Breton language. \n\nThis is one of the most notorious open-sea lighthouses off the coast of Brittany, France.\n\nIsometric variant of https://www.shadertoy.com/view/M3lyRf.","likes":17,"published":1,"flags":0,"usePreview":1,"tags":["procedural","raymarching","sea","water","ocean","fog","isometric","storm","lighthouse"],"hasliked":0,"parentid":"","parentname":""}}