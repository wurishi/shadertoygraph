{"ver":"0.1","info":{"id":"tsV3DV","date":"1571026877","viewed":133,"name":"Raytracer (old)","username":"cmarangu","description":"idk what multipass is exactly but i think this is a multipass for me? anywast since glsl doesnt freaking support recursion so i may develop my first raytracer on another platform instead","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","reflections"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// /*\n// Old code for: \"Raytracer (WIP)\"\n// Created: 2019 10/14 (before then)\n// Tags: raytracing, reflections\n// Description: idk what multipass is exactly but i think this is a multipass for me?\n// anywast since glsl doesnt freaking support recursion so i may develop my first raytracer on\n// another platform instead\n\n// C010011012 (@cmarangu)'s 1st raytracer :D\n// Started 2019 9/26\n// Original attempt 2019 7/21\n// or was it 7/3\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Ray2 {\n    bool exists;\n    vec3 color;\n    Ray ray;\n};\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n};\n\nstruct Plane {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Material {\n\tfloat lighting;\n    float reflectionIndex;\n};\n\nconst Ray noRay = Ray(vec3(0), vec3(0));\nconst vec3 noColor = vec3(0);\n\nconst vec3 sun = vec3(0, 2, 0);\n\n// vec3 plan2(Ray ray, Plane plan\n\nRay2 inter_ray_plane(Ray ray, Plane plan) {\n    // https://www.scratchapixel.com/\n    float denom = dot(plan.direction, ray.direction);\n    if (denom > 1e-6) {\n        vec3 p010 = normalize(plan.origin-ray.origin);\n    \tfloat t = dot(p010, plan.direction)/denom;\n    \tvec3 p = ray.origin+ray.direction*t;\n        // if (t < 0.) {\n        \t// float a = mod(p.x, 1.);\n        \t// float b = mod(p.z, 1.);\n        \t// vec3 col = vec3(min(a, b), a, max(a, b));\n        \t// checkerboard texture knowledge from\n        \t// http://web.cse.ohio-state.edu/~shen.94/681/Site/Slides_files/texture.pdf\n        \tvec3 col = vec3(mod(\n                floor(p.x*2.)+\n                floor(p.z*2.),\n            2.));\n            return Ray2(\n                true,\n                col,\n                Ray(p, reflect(ray.direction, plan.direction))\n            );\n        // }\n\t}\n    return Ray2(false, noColor, noRay);\n}\n\nRay2 inter_ray_sph(Ray ray, Sphere sph) {\n    // Much help from TheArtOfCode\n    // https://www.youtube.com/watch?v=HFPlKQGChpE\n    // t is the closest point on the ray to the center\n    // of the sphere (unless im mistaken)\n    float t = dot(sph.center-ray.origin, ray.direction);\n    // no t is the coefficient of rd to get that point\n    // p is the point on the ray closest to the center\n    // of the sphere\n    vec3 p = ray.origin+ray.direction*t;\n    // pi_0 and pi_1 have nothing to do with any circle\n    // constant. they are the initial point of intersection\n    // and secondary point of intersection of the ray with\n    // the sphere respectively\n    float y = length(p-sph.center);\n    if (t > 0.) {\n        if (y < sph.radius) {\n            float x = sqrt(sph.radius*sph.radius-y*y);\n            vec3 pi_0 = ray.origin+ray.direction*(t-x);\n            vec3 pi_1 = ray.origin+ray.direction*(t+x);\n            Plane plan_r = Plane(pi_0, normalize(pi_0-sph.center) );\n            vec3 col = vec3(.2, 0., 0.);\n            // col = vec3(0., 1., 200./255.);\n            vec3 r = reflect(ray.direction, plan_r.direction);\n            float spec = abs(dot(r, r))/5.;\n            col = (col+vec3(spec))/2.;\n            return Ray2(\n                true,\n                col,\n                Ray(pi_0, reflect(ray.direction, plan_r.direction))\n            );\n    \t}\n    }\n    return Ray2(false, noColor, noRay);\n}\n\nint closer(Ray ray, Ray2 obj1, Ray2 obj2) {\n    if (obj1.exists) {\n        if (obj2.exists) {\n            if (length(obj2.ray.origin-ray.origin) < length(obj1.ray.origin-ray.origin)) {\n                return 2;\n            }\n            else {\n                return 1;\n            }\n        }\n        else {\n            return 1;\n        }\n    }\n    else if (obj2.exists) {\n        return 2;\n    }\n    else {\n        return 0;\n    }\n}\n\nvec3 CAST2(Ray ray) {\n    Sphere sph = Sphere(vec3(0., -.0, 2.+2.+2.*sin(iTime)), 1.);\n    Plane plan = Plane(vec3(0., 1., 0.), normalize(vec3(0., -1., 0.)) );\n    \n    Ray2 r2s = inter_ray_sph(ray, sph);\n    Ray2 r2p = inter_ray_plane(ray, plan);\n    \n    int r2_ = closer(ray, r2p, r2s);\n    \n    if (r2_ == 2) {\n        // return (r2s.color*3.+CAST2(r2s.ray)*2.)/5.;\n        return r2s.color;\n    }\n    else if (r2_ == 1) {\n        // return (r2p.color*3.+CAST2(r2p.ray)*2.)/5.;\n        return r2p.color;\n    }\n    else {\n    \treturn vec3(0., 0., 100./255.);\n    }\n    \n    \n}\n\nvec3 CAST(Ray ray) {\n    Sphere sph = Sphere(vec3(0., -.0, 2.+2.+2.*sin(iTime)), 1.);\n    Plane plan = Plane(vec3(0., 1., 0.), normalize(vec3(0., -1., 0.)) );\n    \n    Ray2 r2s = inter_ray_sph(ray, sph);\n    Ray2 r2p = inter_ray_plane(ray, plan);\n    \n    int r2_ = closer(ray, r2p, r2s);\n    \n    if (r2_ == 2) {\n        return (r2s.color*3.+CAST2(r2s.ray)*2.)/5.;\n        // return r2s.color;\n    }\n    else if (r2_ == 1) {\n        return (r2p.color*3.+CAST2(r2p.ray)*2.)/5.;\n        // return r2p.color;\n    }\n    else {\n    \treturn vec3(0., 0., 100./255.);\n    }\n    \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.x*2.*1.2;\n    vec3 dir = vec3(uv.x, uv.y, 1.);\n    float mag = sqrt(dir.x*dir.x+dir.z*dir.z);\n    float ang = atan(dir.z, dir.x)+(iMouse.x-iResolution.x/2.)/180.;\n    dir = vec3(cos(ang)*mag, dir.y, sin(ang)*mag);\n    Ray RAY = Ray(vec3(0., 0., 0.), normalize(dir));\n    \n    /// OH MI GOSH I CASTED A RAY I DID IT THE\n     // / /// WORLD OF 3D GRAPHICS IS MIIIINE!!!!!\n    // and then theres recursive ray casts :D\n    vec3 retina = CAST(RAY);\n\n    // Output to screen\n    fragColor = vec4(retina, 1.0);\n}\n/**/\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}