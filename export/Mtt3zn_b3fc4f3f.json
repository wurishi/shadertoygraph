{"ver":"0.1","info":{"id":"Mtt3zn","date":"1467767340","viewed":124,"name":"marbleplanet","username":"Zoz","description":"learning making textures","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["texture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    \n    vec3 b = vec3(0.);\n    float res = .001;\n    for (int i = 0; i < 10; i++) {\n        for(int j = 0; j < 10; j++) {\n         \tb  += texture(iChannel0, uv + vec2(-(2.5 * res) + float(i) * res,\n                                                 -(2.5 * res) + float(j) * res)).rgb;\n        }\n    }\n\tb /= 100.;                      \n\tfragColor.rgb = b;\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define pi 3.1415\n#define t iTime\n\nmat3 rotz(float t){\n     return mat3( cos(t),  -sin(t), 0,\n       \t          sin(t),   cos(t), 0,\n\t\t  \t\t  0,        0 ,     1);\n}\nmat3 roty(float t){\n    return  mat3( cos(t),  0,  sin(t),\n     \t    \t  0,       1,  0,\n           \t      -sin(t), 0,  cos(t)); \n\n}\n\nmat3 rotx(float t){\n     return mat3( 1, 0 ,      0,\n            \t  0, cos(t), -sin(t),\n\t   \t  \t      0, sin(t),  cos(t));\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat no( in vec2 p ) {\n    p += iTime * .05;\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( rand( i + vec2(0.0,0.0) ), \n                     rand( i + vec2(1.0,0.0) ), u.x),\n                mix( rand( i + vec2(0.0,1.0) ), \n                     rand( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat noise(in vec2 p) {\n \treturn (no(p) + no(p * 2.) + no(p * 4.) + no(p * 8.) + no(p * 16.)) / 5.;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  p *= rotx(iTime);\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat map(vec3 p) {\n    return length(p) - 1.;\n \treturn sdBox(p, vec3(.9, .9, .9));   \n}\n\nfloat render(vec3 o, vec3 r) {\n \tfloat k = 0.;\n    for (int i = 0; i < 500; i++) {\n     \tvec3 p = o + r * k;\n        float m = map(p);\n        k += m * .5;\n    }\n    return k;\n}\n\nvec3 nor(vec3 p, float prec)\n{\n    vec2 e = vec2(prec, 0.);\n    \n    vec3 n;\n    \n    n.x = map(p+e.xyy) - map(p-e.xyy); \n    n.y = map(p+e.yxy) - map(p-e.yxy); \n    n.z = map(p+e.yyx) - map(p-e.yyx);  \n    \n    return normalize(n); \n}\n\nvec3 applyFog(vec3 c, float dist) {\n \tfloat fogAmount = 1. - exp(-dist * .1);\n    vec3 fogColor = vec3(0.0);\n    return mix(c, fogColor, fogAmount);\n}\n\n\nvec3 shade(vec3 o, vec3 r, float k, vec3 color) {\n    vec3 lp = vec3(10., 5., -4.);\n    vec3 p = o + r * k;\n    vec3 n = nor(p, 0.01);\n    \n    float light = 0.0;\n    light += 1.2 * max(dot(n, normalize(lp)), 0.);\n    light += .8 * pow(max(dot(normalize(o - p), reflect(-normalize(lp), n)), 0.), 9.);\n        \n    \n    vec3 planet = color * light;\n    return applyFog(planet, k);\n}\n\n\n\nfloat F(vec2 p) {\n    float sum = 0.;\n    //p *= 6.;\n    for (int i = 0; i < 20; i++) {\n        float e = pow(2., float(i));\n        sum += no(p * vec2(e)) / e;\n    }\n    return sum;\n    \n}\n\nfloat fbm(vec2 v) {\n\tfloat sum = 0.;\n    for (int i = 0; i < 10; i++) {\n        float e = pow(2., float(i));\n        sum += no(v * vec2(e)) / e;\n    }\n    return sum;\n}\n\nfloat marble(vec2 v) {\n    float c = 0.;\n    for (int i = 0; i < 3; i++) {\n     \tc = fbm(v + c) + fbm(v)* 1.7;   \n    }\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 uvo = uv;\n    \n    mat3 rot = roty(iTime * .1);\n    vec3 o = vec3(0., 0., -1.5);\n    vec3 r = normalize(vec3(uv, 1.));\n    o *= rot;\n    r *= rot;\n    \n    float k = render(o , r);\n    \n    vec3 p = o + k * r;\n    float phi = acos(p.y);\n    float theta;\n    \n    if (abs(sin(phi)) < 2.) {\n     \ttheta = acos(p.x);   \n    } else {\n     \ttheta = acos(p.z / sin(phi));\n    }\n    \n    vec2 texCoord = vec2(phi, theta);\n    texCoord = vec2(phi, theta) * .8;\n    \n    uv.x += iTime / 30.;\n    uv.y -= iTime / 100.;\n    float c;\n    //c =  (1. + sin((texCoord.x * .5 + texCoord.y *.5 + F(texCoord + iTime / 100.) / 2.) * 40.) ) / 2.;\n    c = marble(texCoord);\n    //c = F(uv + iTime / 100.);\n    //vec3 color = vec3(sin(c + pi / 3.), sin(c + pi / 5.), sin(c + pi / .7));\n    vec3 color = vec3(sin(c), sin(c + pi/4.), sin(c + pi/2.));\n    \n   \tcolor = shade(o, r, k, color);\n    //color = mix(color, vec3(0., .3, .5), smoothstep(1.1, 1.2, length(uvo)));\n    //color = mix(color, vec3(0.), smoothstep(1.24, 1.3, length(uvo)));\n\n    //color += mix(vec3(.6, .6, .0), vec3(0), smoothstep(.001, .01, length(uvo + vec2(1., 0.))));\n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}