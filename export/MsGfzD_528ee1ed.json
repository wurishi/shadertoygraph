{"ver":"0.1","info":{"id":"MsGfzD","date":"1527776591","viewed":262,"name":"Kaleido blobs","username":"NuSan","description":"Raymarching test scene, trying to make organic parts, and making it hypnotic by mirroring uvs a bunch.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define KALEIDO 1\n#define MAXSTEPS 200\n\n#define v2Resolution iResolution\n#define out_color fragColor\n#define time iTime\n\n\nfloat sph(vec3 p, float r) {\n  return length(p)-r;\n}\n\nfloat cyl(vec3 p, vec2 s) {\n  return max(length(p.xz)-s.x,abs(p.y)-s.y);\n}\n\nvec3 rep(vec3 p, vec3 s) {\n  return (fract(p/s+0.5)-0.5)*s;\n}\n\nvec3 repid(vec3 p, vec3 s) {\n  return floor(p/s+0.5);\n}\n\nmat2 rot(float a) {\n  float co=cos(a);\n  float so=sin(a);\n  return mat2(co,so,-so,co);\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp(0.5+0.5*(a-b)/h,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\nfloat smax(float a, float b, float h) {\n  float k=clamp(0.5+0.5*(b-a)/h,0.0,1.0);\n  return mix(a,b,k)+k*(1.0-k)*h;\n}\n\nfloat map(vec3 p) {\n\n\n  vec3 m0 = p;\n  //m0.xy=abs(m0.xy);\n\n  float tt = time * 0.2;\n  float tt2 = time * 0.5;\n\n  vec3 r0 = m0;\n  r0.xz *= rot(tt);\n  r0.yz *= rot(tt*2.3975);\n  vec3 r1 = rep(r0, vec3(2.0));\n  vec3 def = repid(r0, vec3(2.0));\n  \n  float d = sph(r1, 0.1);\n\n  for(int i=0;i<7;++i) {\n    vec3 r2 = r1;\n    r2.xy *= rot(tt2*0.221 + float(i)*1.986 + dot(def,def));\n    r2.yz *= rot(tt2*1.674 + float(i)*5.34);\n    d=smin(d,cyl(r2+vec3(0.0), vec2(0.02,0.8)), 0.2);\n  }\n\n  for(int i=0;i<7;++i) {\n    vec3 r2 = r1;\n    r2.xy *= rot(tt2*0.8742 + float(i)*2.1243);\n    r2.yz *= rot(tt2*1.9865 + float(i)*6.974 + dot(def,def));\n    d=smax(d,-cyl(r2+vec3(0.0), vec2(0.02,0.8)),0.1);\n  }\n\n  float ex=smax(sph(r1,0.3),-sph(r1,1.1),0.2);\n\n  d=smin(d,ex,0.8);\n  d=smax(d, sph(r1,0.8),0.2);\n\n  return d;\n\n}\n\nvec3 norm(vec3 p) {\n\n  float base = map(p);\n  vec2 off = vec2(0.0,0.001);\n  return normalize(vec3(base-map(p+off.yxx),base-map(p+off.xyx),base-map(p+off.xxy)));\n\n}\n\nvec2 mirror(vec2 uv, float a) {\n  mat2 rr = rot(a);\n  vec2 m=uv*rr;\n  m.x=abs(m.x);\n  return m*rr;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(2.0*fragCoord.x / v2Resolution.x-1.0, 1.0-2.0*fragCoord.y / v2Resolution.y);\n  uv /= vec2(v2Resolution.y / v2Resolution.x, 1);\n\n  vec2 off = vec2(cos(time),sin(time)) * 0.3;\n  //uv=abs(uv)-abs(off);\n\n  float tt=time*0.5;\n#if KALEIDO\n  uv = mirror(uv, tt*0.1);\n  uv = mirror(uv, -tt*0.3 + 0.124);\n  uv = mirror(uv, tt*2.3);\n\n  uv -= abs(off);\n#endif\n\n  vec3 col = vec3(0.0);\n  \n  vec3 ro = vec3(0,0,-1);\n  vec3 rd = normalize(vec3(uv, 1.0));\n  \n  vec3 p = ro;\n\n  float e = 0.0;\n\n  for(int i=0;i<MAXSTEPS;++i) {\n\n    float d = map(p);\n    if(d<0.0001) {\n\n      break;\n    }\n    e += (1.0-clamp(length(p-ro)/10.0,0.0,1.0))*0.00001/(d);\n    p += d*rd;\n  }\n\n  vec3 n = norm(p);\n  float lum = clamp(dot(n,normalize(vec3(0.7))),0.0,1.0);\n\n  float depth = length(p-ro);\n\n  col = vec3(1.0/depth);\n  col *= lum;\n  col += 0.3*vec3(0.0,1.0,1.0)*max(0.0,n.y);\n  col += (pow(depth,0.3))*vec3(0.2,0.0,0.5)*0.2;\n\n  col += e * vec3(1.0,0.6,0.0);\n\n  out_color = vec4(col,0);\n\n  //out_color = vec4(fract(uv*5.0),0,0);\n}","name":"Image","description":"","type":"image"}]}