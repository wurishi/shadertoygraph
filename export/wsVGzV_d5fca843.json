{"ver":"0.1","info":{"id":"wsVGzV","date":"1570601111","viewed":305,"name":"Colormixing metaballs","username":"bitless","description":"Thanks to Patricio Gonzalez Vivo & Jen Lowe for \"The Book of Shaders\" and inspiration ","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["2d","voronoi","metaballs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: bitless\n// Title: Colormixing Metaballs\n// Thanks to Patricio Gonzalez Vivo & Jen Lowe for \"The Book of Shaders\" and inspiration \n\n// translate color from HSB space to RGB space\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat rand (vec2 st) {\n    float f = fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n    return max(f,0.2);\n}\n\nvec3 random_color (vec2 p){\n    return hsb2rgb(vec3(rand(p),0.6,1.0));\n // blood cells bellow\n // return hsb2rgb(vec3(0.02,clamp(rand(p),0.7,0.8),clamp(rand(p),0.4,1.0)));\n\n}\n\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 st = fragCoord.xy/iResolution.xy;\n    st -= 0.5;\n    if (iResolution.y > iResolution.x ) \n        st.y *= iResolution.y/iResolution.x;\n    else \n        st.x *= iResolution.x/iResolution.y;\n   \n    vec3 color = vec3(.0);\n\n    // Scale\n    float scale = sin(iTime*0.2)*2.0 + 5.0;\n   \tst *= scale;\n\n    //st += noise(st*.005*scale)*100.05/scale;\n    //st += random2(st)*0.02;\n\n\n    // Tile the space\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n    \n    vec3 c = vec3(0.0);\n    vec3 c1;\n\n    float m_dist = 10.;  // minimun distance\n    float meta_dist = 10.;  // minimun distance\n    vec2 cl_point;\n    vec2 cl_dist;\n\n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            // Neighbor place in the grid\n            vec2 neighbor = vec2(float(x),float(y));\n            \n            // Random position from current + neighbor place in the grid\n            vec2 point = random2(i_st + neighbor);\n\n\t\t\t// Animate the point\n            point = 0.5 + 0.5*sin(iTime + 6.2831*point);\n\n\t\t\t// Vector between the pixel and the point\n            vec2 diff = neighbor + point - f_st;\n\n            // Distance to the point\n            float dist = length(diff);\n            \n            if (m_dist>dist) {\n                cl_point = neighbor +i_st;\n                cl_dist = diff;\n            }\n            \n            // mix color with neighbors\n            c = mix (c,random_color(neighbor+i_st),1.0-smoothstep(.0,1.0,dist*0.90));\n\n            // Keep the closer distance\n            m_dist = min(m_dist, dist);\n            meta_dist = min(meta_dist, meta_dist*dist*1.0);\n            \n        }\n    }\n    \n\n    // Draw the min distance (distance field)\n\t// base color\n    color = mix(random_color(cl_point),c,1.0);\n    // inner borders of cells\n    color -= smoothstep(-0.1,1.0,m_dist)*0.24;\n    // borders of metaballs\n    color = (color)*abs(1.0-smoothstep(0.7,1.0,meta_dist*0.4)*0.3-smoothstep(0.95,1.0,meta_dist*0.4));\n\n    fragColor = vec4(color,1.);\n}","name":"Image","description":"","type":"image"}]}