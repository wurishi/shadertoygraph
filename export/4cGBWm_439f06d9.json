{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"//#version 330 core\n#define SHADERTOY\n\n#ifndef SHADERTOY\nout vec4 fragColor;\nin vec4 fragPosition; \n\nuniform vec3 finger_positions[5]; \nuniform float finger_openings[5]; \nuniform float finger_speeds[5];\nuniform float pt0_speed;\nuniform float time;\n\nvec2 iResolution = vec2(1280,800);\nfloat iTime;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord );\n\nvoid main() {\n    iTime = time;\n    vec2 fragCoord = (.5*fragPosition.xy+.5)*iResolution;\n    mainImage(fragColor, fragCoord);\n}\n\n#endif\n\n\n#define FAR 40.\n\nmat2 rot(float a) {\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nfloat smin(float a, float b, float k){\n    float h = clamp(.5+.5*(b-a)/k,0.,1.);\n    return mix(b,a,h)-k*h*(1.-h);\n}\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.)/k1;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r ) {\n  vec3 q = abs(p) - b + r;\n  return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.) - r;\n}\n\n\nfloat thumb(float d, vec3 p, float a, float k){\n    a*=.9;\n    p.yz*=rot(a);\n    \n    d=smin(d,length(p) -.4,.1);\n    d=min(d,sdCapsule(p,vec3(0),vec3(0,-k,0),.25));\n    \n    p.y += k;\n    p.yz*=rot(a);\n\n    d=min(d,length(p) -.37);\n    d=min(d, sdCapsule(p,vec3(0),vec3(0,-.8*k,0),.35));\n    return d;\n}\n\nfloat finger(float d, vec3 p, float a, float k){\n    a*=1.35;\n    p.yz*=rot(a);\n    \n    d=smin(d,length(p) -.4, .1);\n    d=min(d,sdCapsule(p,vec3(0),vec3(0,-k,0),.25));\n    \n    p.y += k;\n    p.yz*=rot(a);\n\n    d=min(d,length(p) -.35);\n    d=min(d, sdCapsule(p,vec3(0),vec3(0,-.9*k,0),.25));\n    p.y += .9*k;\n    p.yz*=rot(a);\n\n    d=min(d,length(p) -.35);\n    d=min(d, sdCapsule(p,vec3(0),vec3(0,-.8*k,0),.3));\n    return d;\n}\n\nfloat op0,op1,op2,op3,op4;\nfloat scissor = 0.;\n\nfloat hand(vec3 p0) {\n    float d = 999.;\n    \n    p0 = p0.yzx;\n    \n    p0.zx *= rot(3.14+.2*cos(iTime));\n    d = min(d, mix(sdEllipsoid(p0-vec3(1,1.3,.2), vec3(1.7,1.5,.7)),\n                    sdRoundBox(p0- vec3(1,1.3,.2), vec3(1.7,1.5,.7)-.25,.25), .3));\n    vec3 p1 = p0;\n    p1.yx*=rot(.3*scissor);\n    d = finger(d,p1, op0, .9);\n    \n    vec3 p2 = p0-vec3(.7,-.1,.15);\n    p2.yx*=rot(-.2*scissor);\n    d = finger(d,p2, op1, 1.1);\n    \n    d = finger(d,p0-vec3(1.4,-.1,.1), op2, 1.);\n    d = finger(d,p0-vec3(2.1,0,0), op3, .8);\n    \n    vec3 p = p0-vec3(-.7,2.,0);\n    p.xy *= rot(-.8);\n    p.zx *= rot(-1.1);\n    d = thumb(d,p, op4, 1.2);\n\n    return d;\n}\n\nfloat calcAO(vec3 pos, vec3 nor ) {\n    float ao = 0.;\n    for( int i=0; i<8; i++ ) {\n        float h = .02 + .5*float(i)/7.;\n        float d = hand(pos + h*nor);\n        ao += h-d;\n    }\n    return clamp( 1.5 - ao*.6, 0., 1. );\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(hand(p) - vec3(hand(k[0]),hand(k[1]),hand(k[2])));\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    float a = cos(.2*iTime);\n    \n#ifdef SHADERTOY\n    op0 = .45+.45*cos(3.*iTime);\n    op1 = .48+.5*cos(.3+3.*iTime);\n    op2 = .5+.5*cos(.2+3.*iTime);\n    op3 = .5+.5*cos(.1+3.*iTime);\n    op4 = .5+.4*cos(.1+3.*iTime);\n    scissor = .2*(.5+.5*cos(iTime));\n    vec3 ta = vec3(0,-1,0);\n    a += -1.5+3.14*iMouse.x/iResolution.x;\n#else\n\tfloat po = 1.5;\n    op0 = 1.5*pow(1.-finger_openings[1],po);\n    op1 = 1.5*pow(1.-finger_openings[2],po);\n    op2 = pow(1.-finger_openings[3],po);\n    op3 = pow(1.-finger_openings[4],po);\n    op4 = pow(1.-finger_openings[0],po);\n\top0 = clamp(op0,0.,1.);\n\top1 = clamp(op1,0.,1.);\n    scissor = smoothstep(.45,1.,op2-op0); \n\top4 = (op2+op3)*.5;\n    vec3 ta = vec3(0,3.*finger_positions[0].y-1.5,0);\n#endif\t\n\n    // Camera\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float dis = 30.;\n\n    vec3 ro = dis*vec3( cos(a),.7, sin(a) );\n    mat3 ca = setCamera( ro, ta, .1*cos(.3));\n    vec3 rd = ca * normalize( vec3(uv.xy,4.5) );\n\n    // RayMarching\n    float t = 10.;\n    for (int i = 0; i < 100; i++) {\n        float d = hand(ro+rd*t);\n        t += d;\n        if (t>FAR && d<1e-2) break;\n    }\n    \n    // Shading\n    vec3 p = ro+rd*t;\n    vec3 n = norm(p);\n    float ao = calcAO(p, n);\n    vec3 r = reflect(rd,n);\n    float ss = smoothstep(-.05,.05,hand(p+vec3(.05)/sqrt(3.)));\n    float tex = .5;\n    float diff = mix(length(sin(n*2.)*.5+.5)/sqrt(3.),ss,.7)+.1;\n    float spec = length(sin(r*4.)*.5+.5)/sqrt(3.);\n    float specpow = mix(3.,10.,tex);\n    float frens = 1.-pow(dot(rd,n),2.)*.98;\n\n    vec3 col = vec3(1.,.2,.4),\n         bg = .5*vec3(.2,.3,.3);\n\n    col = (ao*.8+.2)*col*diff + pow(spec,specpow)*frens;\n\n    float bgdot = length(sin(rd*3.5)*.4+.6)/sqrt(3.);\n    bg = bg * bgdot + pow(bgdot, 10.)*2.;\n \n    fragColor.xyz = t<FAR ? col : bg;\n    fragColor = sqrt(fragColor);\n    fragColor *= 1.- dot(uv,uv)*.6;\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4cGBWm","date":"1734078914","viewed":139,"name":"Simple Robot Hand","username":"iapafoto","description":"Simple hand design for automatic Shifumi (Stone Paper Scissors) using mediapipe\n\nhttps://github.com/iapafoto/shifumi\n","likes":30,"published":1,"flags":0,"usePreview":0,"tags":["hand","mediapipe"],"hasliked":0,"parentid":"","parentname":""}}