{"ver":"0.1","info":{"id":"MstGD8","date":"1450209076","viewed":197,"name":"Vector Field Thingy","username":"sixstring982","description":"Vector field","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["field","vector","euler","integrator"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define EPSILON 0.001\n#define MAX_RAY_DIST 50.0\n#define MAX_RAY_ITERS 100\n\n#define EULER_MAX_ITERS 50\n#define LAMBDA 0.006\n\n#define CAMERA_DIST 5.0\n#define MOUSE_SPEED 0.02\n#define AUTOSPIN_SPEED 0.2\n\n#define PI 3.1415926535\n#define PIOVERTWO 1.57079632679\n\nfloat smin(float a, float b) {\n    const float k = 0.9;\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat sphere(in vec3 ro, in float r) {\n    return length(ro) - r;\n}\n\nfloat box(in vec3 ro, in vec3 d) {\n    vec3 b = abs(ro) - d;\n    return min(max(b.x, max(b.y, b.z)), 0.0) +\n               length(max(b, 0.0));\n}\n\nfloat repSphere(in vec3 rep, in vec3 ro, in float r) {\n    vec3 q = mod(ro, rep) - 0.5 * rep;\n    return sphere(q, r);\n}\n\nvec3 f(in vec3 v) {\n    //v = mix(v, 1.2 * texture(iChannel1, v.xy).rgb, 0.5 + 0.5 * sin(iTime * 0.9));\n    v = v * 1.2;\n    return 3.0 * vec3(0.25 + 0.75 * sin(iTime + v.x), \n                      0.25 + 0.75 * cos(iTime + v.y),\n                      0.25 + 0.75 * sin(iTime + v.x * v.y));\n}\n\nvec3 eulerIntegrate(in vec3 ro) {\n    for (int i = 0; i < EULER_MAX_ITERS; i++) {\n        ro = ro + LAMBDA * f(ro);\n    }\n    \n    return ro;\n}\n\nfloat opU(in float a, in float b) {\n    return min(a, b);\n}\n\nfloat opS(in float a, in float b) {\n    return max(a, -b);\n}\n\nfloat opBlend(in float a, in float b) {\n    return smin(a, b);\n}\n\nfloat map(in vec3 ro) {\n    vec2 io = vec2(1.0, -1.0);\n    #if 1\n    vec3 ei = eulerIntegrate(ro);\n\t#else\n    vec3 ei = ro;\n    #endif\n    float d = 1e20;\n    //float d = box(ei, vec3(1.0));\n    d = opBlend(d, sphere(ei + vec3(sin(iTime * 0.2)), 1.01));\n    d = opBlend(d, sphere(ei + vec3(-sin(iTime)), 1.01));\n    d = opBlend(d, sphere(ei + vec3(sin(iTime * 0.5)) * io.xyy, 1.01));\n    d = opBlend(d, sphere(ei + vec3(-sin(iTime * 0.3)) * io.xyy, 1.01));\n    return d;\n}\n\nbool lightAt(in int idx, out vec3 lightPos) {\n    if (idx == 0) {\n        lightPos = vec3(5.0 * sin(iTime), 0.0, 5.0 * cos(iTime));\n        return true;\n    } else if (idx == 1) {\n        lightPos = vec3(3.0);\n        return true;\n    } else if (idx == 2) {\n        lightPos = vec3(-3.0);\n        return true;\n    } else if (idx == 3) {\n        lightPos = vec3(5.0 * sin(iTime + PI), \n                        0.0, \n                        5.0 * cos(iTime + PI));\n        return true;\n    } else {\n        return false;\n    }\n}\n\nvec3 normalAt(in vec3 ro) {\n    vec2 ev = vec2(EPSILON, 0.0);\n    return normalize(vec3(map(ro + ev.xyy) - map(ro - ev.xyy),\n                          map(ro + ev.yxy) - map(ro - ev.yxy),\n                          map(ro + ev.yyx) - map(ro - ev.yyx)));\n}\n\nvec3 lighting(in vec3 ro, in vec3 rd, in float td) {\n    const float shininess = 1e20;\n    float spec = 0.0;\n    float diff = 0.0;\n    vec3 N = normalAt(ro);\n    vec3 V = normalize(-rd);\n    vec3 L;\n    vec3 R;\n    vec3 e = normalize(eulerIntegrate(ro));\n    vec3 lightPos;\n    \n    for (int i = 0; i < 10; i++) {\n        if (!lightAt(i, lightPos)) {\n            break;\n        }\n        vec3 L = normalize(lightPos - ro);\n        vec3 R = reflect(L, N);\n        \n        diff += max(0.0, dot(L, N));\n        spec += pow(max(0.0, dot(V, -R)), shininess);\n    }\n    diff = clamp(diff, 0.0, 1.0);\n    spec = clamp(spec, 0.0, 1.0);\n    \n    vec3 tex = texture(iChannel0, reflect(rd, N)).rgb;\n    // vec3 etex = texture(iChannel0, e).rgb;\n    vec3 flesh = mix(vec3(228, 194, 152) / 255.0,\n                     vec3(148, 10, 0) / 255.0,\n                     0.75 * pow(0.5 + 0.5 * \n                                cos(e.x * 20.0 * e.z) * \n                                sin(e.y * 20.0 * e.x), 10.0));\n    \n    return vec3(diff + spec) * tex;//mix(tex, e, 0.75);\n}\n\nvec3 rayMarch(in vec3 ro, in vec3 rd) {\n    float d = EPSILON;\n    float td = 0.0;\n    \n    for (int i = 0; i < MAX_RAY_ITERS; i++) {\n        if (d < EPSILON ||\n            td > MAX_RAY_DIST) {\n            break;\n        }\n        \n        d = map(ro);\n        ro += rd * d;\n        td += d;\n    }\n    \n    if (d < EPSILON) {\n        return lighting(ro, rd, td);\n    } else {\n        return texture(iChannel0, rd).rgb;\n    }\n}\n\nvoid setupCamera(in vec2 uv, out vec3 ro, out vec3 rd) {\n    float theta = iMouse.x * MOUSE_SPEED + iTime * AUTOSPIN_SPEED;\n    float rho = (iMouse.y / iResolution.y) * PI;\n    ro = vec3(CAMERA_DIST * sin(theta),\n              CAMERA_DIST * cos(rho),\n              CAMERA_DIST * -cos(theta));\n    vec3 target = vec3(0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    vec3 cdir = normalize(target - ro);\n    vec3 cright = normalize(cross(cdir, up));\n    vec3 cup = cross(cright, cdir);\n    \n    rd = uv.x * cright + uv.y * cup + cdir;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = ((fragCoord.xy / iResolution.xy) - vec2(0.5)) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro, rd;\n    \n    setupCamera(uv, ro, rd);\n    \n    fragColor = vec4(rayMarch(ro, rd), 1.0);\n}","name":"","description":"","type":"image"}]}