{"ver":"0.1","info":{"id":"l3sfRB","date":"1728588890","viewed":79,"name":"Bernstein Bezier Triangle","username":"chronos","description":"Bezier Triangle","likes":8,"published":1,"flags":0,"usePreview":1,"tags":["bezier","decasteljau","bernstein","triangular"],"hasliked":0,"parentid":"lXsfRS","parentname":"Tri Bernstein Bezier deCasteljau"},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Bernstein Bezier Triangle by chronos\n    --------------------------------------\n    \n    Just a refresher for myself on bezier triangles :)\n    \n    self link: https://www.shadertoy.com/view/l3sfRB\n\n*/\n\n// Note: The algorithms below are very inefficient (and not checked for correctness)!\n\nconst int D=3; // polynomial degree\n\nfloat fac(float f) // dumbass factorial function\n{\n    float res = 1.;\n    for(float i = floor(f); i > 0.; i--)\n        res *= i;\n    return res;\n}\n\nvec3 get_control_point(int i, int j, int k)\n{\n    #if 1\n    vec3 ijk = vec3(i, j, k);\n    vec3 p = vec3(0);\n    p.x = ijk.x + 0.5 * ijk.y - float(D)*.5;\n    p.z = ijk.y  - float(D)*.5;\n    p.y = pow(ijk.y, .25) + 1.- p.x*p.x/float(D)/float(D) - float(D)*.5 + .5;\n    p/=float(D);\n    return 2.*p;\n    #else\n    return 2.*texelFetch(iChannel0, ivec2(i, j)+26, 0).rgb - 1.;\n    #endif\n}\n\nvec3 get_control_point_color(int i, int j, int k)\n{\n    return texelFetch(iChannel0, ivec2(i, j)+26, 0).rgb*.5+.125;\n}\n\nfloat getBernstein(int i, int j, int k, vec3 uvw)\n{        \n    float fac_d = fac(float(i+j+k));\n    float fac_i = fac(float(i));\n    float fac_j = fac(float(j));\n    float fac_k = fac(float(k));\n\n    float fac_ijk = fac_i * fac_j * fac_k;\n    vec3 uvw_ijk = pow(uvw, vec3(i,j,k));\n\n    float B = fac_d/fac_ijk * (uvw_ijk.x*uvw_ijk.y*uvw_ijk.z);\n    return B;\n}\n\n\nvec3 deCasteljau(vec3 uvw)\n{\n    vec3 value = vec3(0);\n    \n    vec3 control_points[(D+1)*(D+1)];\n    \n    for(int d = D; d > 0; d--)\n    {\n        for(int i = 0; i < d; i++)\n        {\n            for(int j = 0; j < d-i; j++)\n            {\n                int k = D - i - j;\n                vec3 C00 = d == D ?\n                    get_control_point(i, j, k)\n                    :\n                    control_points[i*D + j]\n                    ;\n                    \n                vec3 C10 = d == D ?\n                    get_control_point(i+1, j, k)\n                    :\n                    control_points[(i+1)*D + j]\n                    ;\n                vec3 C01 = d == D ?\n                    get_control_point(i, j+1, k)\n                    :\n                    control_points[i*D + j+1]\n                    ;\n                    \n                control_points[i*D + j] = uvw.z * C00 + uvw.x * C10 + uvw.y * C01;\n                \n            }\n        }\n    }\n    value = control_points[0];\n    return value;\n}\n\nmat3 deCasteljau_derivative(vec3 uvw)\n{\n    mat3 value = mat3(0);\n    \n    vec3 control_points[(D+1)*(D+1)];\n    \n    for(int d = D; d > 1; d--)\n    {\n        for(int i = 0; i < d; i++)\n        {\n            for(int j = 0; j < d-i; j++)\n            {\n                int k = D - i - j;\n                vec3 C00 = d == D ?\n                    get_control_point(i, j, k)\n                    :\n                    control_points[i*D + j]\n                    ;\n                    \n                vec3 C10 = d == D ?\n                    get_control_point(i+1, j, k)\n                    :\n                    control_points[(i+1)*D + j]\n                    ;\n                vec3 C01 = d == D ?\n                    get_control_point(i, j+1, k)\n                    :\n                    control_points[i*D + j+1]\n                    ;\n                    \n                control_points[i*D + j] = uvw.z * C00 + uvw.x * C10 + uvw.y * C01;\n                \n            }\n        }\n    }\n    value = mat3(control_points[0], control_points[1], control_points[D]);\n    return value;\n}\n\nfloat ray_triangle(vec3 ro, vec3 rd, mat3 T)\n{\n    ro -= T[0];\n    T[1] -= T[0];\n    T[2] -= T[0];\n    \n    vec3 N = cross(T[1], T[2]);\n    \n    // solve dot(ro + rd * t, n) = 0\n    float t = -dot(ro, N)/dot(rd, N);\n    return t;\n}\n\nvec3 ray_tri_barycentric(vec3 ro, vec3 rd, mat3 V)\n{\n    return inverse(mat3(V[0]-ro, V[1]-ro, V[2]-ro)) * rd;\n}\n\nfloat seg(vec3 a, vec3 b, vec3 p)\n{\n   p-=a; b-=a;\n   return length(clamp(dot(p,b)/dot(b,b), 0., 1.) * b - p);\n}\n\nfloat mul3(vec3 v) { return v.x * v.y * v.z; }\nfloat min3(vec3 v) { return min(min(v.x, v.y), v.z); }\nfloat in_range(float x) { return step(0., x) - step(1., x); }\nfloat in_range(vec3 x) { return step(0., min3(x)); }\n\nvec3 control_net(vec3 ro, vec3 rd, vec3 color)\n{\n    mat3 value = mat3(0);\n    \n    vec3 control_points[(D+1)*(D+1)];\n    for(int i = 0; i < D; i++)\n    {\n        for(int j = 0; j < D-i; j++)\n        {\n            int k = D - i - j;\n            vec3 C00 = get_control_point(i, j, k);\n            vec3 C10 = get_control_point(i+1, j, k);\n            vec3 C01 = get_control_point(i, j+1, k);\n            vec3 C00_color = get_control_point_color(i, j, k);\n            vec3 C10_color = get_control_point_color(i+1, j, k);\n            vec3 C01_color = get_control_point_color(i, j+1, k);\n            mat3 C = mat3(C00, C10, C01);\n            vec3 bary = ray_tri_barycentric(ro, rd, C);\n            color = mix(color, mat3(C00_color, C10_color, C01_color)*bary, in_range(bary)*.1);\n            \n            // if k > 1, add complementary triangle as well\n            if(k > 1)\n            {\n                vec3 C11 = get_control_point(i+1, j+1, k);\n                vec3 C11_color = get_control_point_color(i+1, j+1, k);\n                C = mat3(C10, C11, C01);\n                bary = ray_tri_barycentric(ro, rd, C);\n                color = mix(color, mat3(C10_color, C11_color, C01_color)*bary, in_range(bary)*.1);\n            }\n        }\n    }\n    return color;\n}\n\nfloat hit_sphere(vec3 ro, vec3 rd, vec3 C, float r)\n{\n    vec3 c = C-ro;\n    float scalar_proj = dot(c, rd); // assume length(rd) == 1.\n    vec3 proj = dot(c, rd) * rd;\n    float x = r*r - dot(proj, proj);\n    vec3 v = proj-c;\n    return step(dot(v,v), r*r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n\n    // uvw are the barycentric coordinates of the triangle\n    vec3 uvw = vec3(uv, 1.-uv.x- uv.y);\n\n    vec3 color = vec3(0);\n    \n    const int d = D;   // degree d\n    const int n = d+1; // order  n  (always d+1)\n    \n    vec3 value = vec3(0);\n        \n    float fac_d = fac(float(d));\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < n-i; j++)\n        {\n            int k = d - i - j;\n            \n            float B = getBernstein(i, j, k, uvw);\n            vec3 C = get_control_point(i, j, k);\n            \n            value += B * C;\n        }\n    }\n    \n    #if 0\n    if(mod(floor(iTime), 2.) == 0.)\n        color += value;\n    else\n    {\n        color += deCasteljau(uvw);\n        color *= step(0.0000001, uvw.z);\n    }\n    #endif\n    \n    float focal = 2.;\n    vec3 ro = vec3(0, 0.2, 3);\n    vec3 rd = normalize(vec3((2.*fragCoord-iResolution.xy)/iResolution.y, -focal));\n    \n    float c = cos(iTime), s = sin(iTime);\n    mat2 R = mat2(c,s,-s,c);\n    ro.xz = R*ro.xz;\n    rd.xz = R*rd.xz;\n    \n    // Draw control points\n    float r = 0.025;\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < n-i; j++)\n        {\n            int k = d - i - j;\n            vec3 C = get_control_point(i, j, k);\n            \n            if(hit_sphere(ro, rd, C, r) > 0.5) \n            {\n                color += get_control_point_color(i, j, k);\n                break;\n            }\n        }\n    }\n\n    vec2 mouse = iMouse.xy/iResolution.y;\n    if(length(iMouse.xy) < 10.) mouse = 0.3 + vec2(c, s)*.25;\n    if(mouse.x + mouse.y > 1.) mouse/=mouse.x+mouse.y;\n    color += smoothstep(2./iResolution.y, 1./iResolution.y, length(uv - mouse)-0.01);\n    \n    #if 1\n    // Draw parameter space\n    if(uv.x + uv.y < 1.) color += 0.005;\n    #endif\n    \n    vec3 xyz = vec3(mouse, 1. - mouse.x - mouse.y);\n    mat3 T = deCasteljau_derivative(xyz);\n        \n    #if 0\n    // draw tangent plane\n    float t = ray_triangle(ro, rd, T);\n    vec3 p = t * rd + ro;\n    if(length(p - deCasteljau(xyz)) < 0.5)\n    {\n        color += vec3(.1);\n    }\n    #endif\n    \n    vec3 bary = ray_tri_barycentric(ro, rd, T);\n    color = mix(color, bary, .5 * in_range(bary)); // draw last level (tangent) triangle\n        \n    #if 1\n    // Draw corresponding point on \n    color = mix(color, vec3(1), hit_sphere(ro, rd, deCasteljau(xyz), r));\n    #endif\n    \n    color = control_net(ro, rd, color);\n\n    color = pow(color, vec3(1./2.2));\n\n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}