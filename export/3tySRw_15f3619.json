{"ver":"0.1","info":{"id":"3tySRw","date":"1584693612","viewed":108,"name":"Disk Sampling Pattern","username":"iradicator","description":"Construction of a normalized uniform disk sampling pattern based on initial good guess and correction as needed.\n\nFor more details, check out my blog post: https://iradicator.com/normalized-uniform-disk-pattern/","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d","math","sampling","pattern","disk"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define MAX_FLT 3.402823e+38\n#define EPSILON 1.192093e-07\n\n//////////////\n// Controls //\n//////////////\n\nint L = 10;\nint S = 26;\n\n////////////////////\n// Final Approach //\n////////////////////\n\nint N(int L, int S)\n{\n    return ((L * L + L) >> 1) * S + 1;\n}\n\n// Returns the ith sampling location of a normalized disk sampling pattern\n// with 0 < L rings (layers) and 0 < S base-ring samples. 0 <= i < 1 + SL(L+1)/2.\nvec2 disk(int i, int L, int S)\n{    \n    float fS = float(S);\n    int x2S = 2 * i - 2;\n    int l = int(sqrt(max(0.0, float(x2S) / fS)));    \n    if (x2S >= ((l * l + l) * S)) ++l;\t\n    float fl = float(l);\n    \n    float r = fl / (float(L-1) + EPSILON);       \n    float theta = (2.0 * PI * float(i)) / (fS * fl + EPSILON);\n    \n    return r * vec2(cos(theta), sin(theta));    \n}\n\n////////////////////\n// Driver Program //\n////////////////////\n\nfloat sdDisk(vec2 p, int L, int S)\n{\n    float d = MAX_FLT;    \n    for (int i = 0; i < N(L-1,S); ++i)\n    {                     \n        vec2 q = disk(i, L, S);\n        d = min(d, length(p - q));        \n    }\n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat aspect = iResolution.x / iResolution.y;\n    vec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n    uv *= 1.2 * vec2(aspect, 1.0);\n        \n    float d = sdDisk(uv, max(1,L), max(1,S));\n    d = step(0.01, d);\n\t\n    vec3 bg_col = vec3(61, 15, 43) / 255.0;\n    vec3 fg_col = vec3(255, 246, 143) / 255.0;\n    vec3 col = mix(fg_col, bg_col, d);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}