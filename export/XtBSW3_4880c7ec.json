{"ver":"0.1","info":{"id":"XtBSW3","date":"1446692817","viewed":428,"name":"SineTree3d","username":"jt","description":"A tree-like structure without recursion, using trigonometric functions with fract for branching - suitable for ray-tracing :-)\n(see [url]https://www.shadertoy.com/view/MljXDV[/url], [url]https://www.shadertoy.com/view/ll2XDV[/url] for 2d variants).","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["raytracer","implicitsurface","floor","fract","ceil","trigonometricfunctions","pow","sign","sinetree"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// SineTree3d (a ray-traced Sine Tree) - written 2015-11-05 by Jakob Thomsen\n// A tree-like structure without recursion, using trigonometric functions with fract for branching - suitable for ray-tracing :-)\n// Thanks to FabriceNeyret2 for streamlining the functions.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// (ported from http://sourceforge.net/projects/shaderview/)\n\n#define pi 3.1415926\n\nfloat sfract(float val, float scale)\n{\n    return (2.0 * fract(0.5 + 0.5 * val / scale) - 1.0) * scale;\n}\n\nfloat mirror(float v)\n{\n    return abs(2.0 * fract(v * 0.5) - 1.0);\n}\n\nfloat sinetree2d(vec2 v)\n{\n    v.x = mirror(v.x);\n    float n = 3.0; // fract(t / 6.0) * 6.0;\n    float br = exp2(ceil(v.y * n));\n    float fr = fract(v.y * n);\n    float val = cos(pi * (v.x * br + pow(fr, 1.0 - fr) * 0.5 * sign(sin(pi * v.x * br))));\n    return 1.0 - pow(0.5 - 0.5 * val, (fr * 1.5 + 0.5) * 1.0);\n}\n\nfloat fn(vec3 v)\n{\n    return max(sinetree2d(vec2(length(v.xy), v.z)), sinetree2d(vec2(atan(v.x, v.y), v.z))); // JT's SineTree 3d (original)\n    // Variations by FabriceNeyret2\n    //return sinetree2d(vec2(atan(v.x, v.y), v.z));\n    //return sinetree2d(vec2(length(v.xy), v.z));\n}\n\nvec3 nrm(vec3 v)\n{\n    vec3 n;\n    float d = 0.01;\n    n.x = fn(v + vec3(d, 0.0, 0.0)) - fn(v + vec3(-d, 0.0, 0.0));\n    n.y = fn(v + vec3(0.0, d, 0.0)) - fn(v + vec3(0.0, -d, 0.0));\n    n.z = fn(v + vec3(0.0, 0.0, d)) - fn(v + vec3(0.0, 0.0, -d));\n    return normalize(n);\n}\n\nfloat comb(float v, float s)\n{\n    return pow(0.5 + 0.5 * cos(v * 2.0 * pi), s);\n}\n\nvec4 tex(vec3 v)\n{\n    float d = abs(v.z * 20. + sfract(-iTime, 4.) * 5.); \n    vec4 c0 = clamp(vec4(0, v.z, 1. - v.z, 0), 0.,1.);\n    vec4 c1 = vec4(0.5 + 0.5 * nrm(v), 1.0);\n    vec4 c = mix(c0, c1, vec4(0.5 - 0.5 * cos(0.05 * iTime * 2.0 * pi))); // change color-palette to enhance branching structure visibility\n    return exp(-d*d) + c * abs(nrm(v).x);\n}\n\nvec3 camera(vec2 uv, float depth)\n{\n    float phi = iTime*.1,  C=cos(phi), S=sin(phi);\n\n    vec3 v = vec3(uv, depth);\n    \n    v *= mat3( 0, 1,-1,\n              -1,-1,-1, \n               1,-1,-1 );\n\n    v.zy *=  mat2 (C,S,-S,C); // could be mixed above\n    \n    return v;\n}\n\nvoid mainImage( out vec4 o,  vec2 uv )\n{\n    float t = iTime * 0.1;\n    vec2 R  = iResolution.xy;\n        uv = ( 2. * uv - R)  / R.y;\n\n    vec3 w = vec3(0), v;\n    \n    for(float layer = 0.; layer < 1.; layer += 1./256.) \n        v = camera(uv, 2. * layer - 1.),\n        abs(v.x) < 1. && abs(v.y) < 1. && abs(v.z) < 1. && abs(fn(v)) < .05 ?  w = v : w;\n    \n    // o = tex(w);\n    o = all(equal(w, vec3(0))) ? vec4(0.0) : tex(w); // avoids flashing background\n}\n","name":"","description":"","type":"image"}]}