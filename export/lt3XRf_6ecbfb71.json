{"ver":"0.1","info":{"id":"lt3XRf","date":"1480813360","viewed":126,"name":"Coin","username":"bsugiarto","description":"It's a coin","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["coin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Coin by Bryan Sugiarto  */\n\nconst float MATH_PI = float( 3.14159265359 );\n\n/* documented in sun */\nfloat VisibilityTerm( float roughness, float ndotv, float ndotl )\n{\n\tfloat m2\t= roughness * roughness;\n\tfloat visV  = ndotl * sqrt( ndotv * ( ndotv - ndotv * m2 ) + m2 );\n\tfloat visL  = ndotv * sqrt( ndotl * ( ndotl - ndotl * m2 ) + m2 );\n\treturn 0.5 / max( visV + visL, 0.00001 );\n}\n\n/*documented in sun */\nfloat DistributionTerm( float roughness, float ndoth )\n{\n\tfloat m2\t= roughness * roughness;\n\tfloat d\t = ( ndoth * m2 - ndoth ) * ndoth + 1.0;\n\treturn m2 / ( d * d * MATH_PI );\n}\n\n/*documented in sun */\nvec3 FresnelTerm( vec3 specularColor, float vdoth )\n{\n\tvec3 fresnel = clamp( 50.0 * specularColor.y, 0.0, 1.0 ) * specularColor + ( 1.0 - specularColor ) * pow( ( 1.0 - vdoth ), 5.0 );\n\treturn fresnel;\n}\n\n/*documented in sun */\nvec3 LightSpecular( vec3 normal, vec3 viewDir, vec3 lightDir, vec3 lightColor, float roughness, vec3 specularColor )\n{\n\tvec3 halfVec = normalize( viewDir + lightDir );\n\n\tfloat vdoth = clamp( dot( viewDir,  halfVec  ), 0.0, 1.0 );\n\tfloat ndoth = clamp( dot( normal,   halfVec  ), 0.0, 1.0 );\n\tfloat ndotv = clamp( dot( normal,   viewDir  ), 0.0, 1.0 );\n\tfloat ndotl = clamp( dot( normal,   lightDir ), 0.0, 1.0 );\n\t\n\tvec3\tf = FresnelTerm( specularColor, vdoth );\n\tfloat   d = DistributionTerm( roughness, ndoth );\n\tfloat   v = VisibilityTerm( roughness, ndotv, ndotl );\n\t\n\tvec3 specular;\n\tspecular = lightColor * f * ( d * v * MATH_PI * ndotl );\n\treturn specular;\n}\n\n/* creates a cylinder */\nfloat Cylinder( vec3 p, float r, float height ) \n{\n\tfloat d = length( p.xz ) - r;\n\td = max( d, abs( p.y ) - height );\n\treturn d;\n}\n\n/*documented in sun */\nfloat Scene( vec3 p, mat3 localToWorld )\n{\n\tp = p * localToWorld;\n\tfloat a = Cylinder( p, 1.0, 0.1 );\n\treturn a;\n}\n\n/*documented in sun */\nfloat CastRay( in vec3 ro, in vec3 rd, mat3 localToWorld )\n{\n\tconst float maxd = 5.0;\n\t\n\tfloat h = 0.5;\n\tfloat t = 0.0;\n   \n\tfor ( int i = 0; i < 50; ++i )\n\t{\n\t\tif ( h < 0.001 || t > maxd ) \n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\th = Scene( ro + rd * t, localToWorld );\n\t\tt += h;\n\t}\n\n\tif ( t > maxd )\n\t{\n\t\tt = -1.0;\n\t}\n\t\n\treturn t;\n}\n\n/*documented in sun */\nvec3 SceneNormal( in vec3 pos, mat3 localToWorld )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t\tScene( pos + eps.xyy, localToWorld ) - Scene( pos - eps.xyy, localToWorld ),\n\t\tScene( pos + eps.yxy, localToWorld ) - Scene( pos - eps.yxy, localToWorld ),\n\t\tScene( pos + eps.yyx, localToWorld ) - Scene( pos - eps.yyx, localToWorld ) );\n\treturn normalize( -nor );\n}\n\n/* same main as sun but texture is modified */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0 + 2.0 * q;\n\tp.x *= iResolution.x / iResolution.y;\n\n\tvec3 rayOrigin  = vec3( 0.0, -0.28, -3.5 );\n\tvec3 rayDir\t = normalize( vec3( p.x, p.y, 2.0 ) );\n   \n\t\n\tvec2 mo = iMouse.xy / iResolution.xy;\t\n\tfloat phi = 0.25 * MATH_PI + 2.0 * iTime + 10.0 * mo.x;\t\n\tmat3 rotY = mat3(\n\t\tvec3( 1.0, 0.0, 0.0 ),\n\t\tvec3( 0.0, cos( phi ), sin( phi ) ),\n\t\tvec3( 0.0, -sin( phi ), cos( phi ) )\n\t);\n\t\n\tmat3 localToWorld = rotY;\t\n\n\n\tvec3 color = vec3(0,0,.2);\n\t\n\tfloat t = CastRay( rayOrigin, rayDir, localToWorld );\n\tif ( t > 0.0 )\n\t{\n\t\tvec3 pos = rayOrigin + t * rayDir;\n\t\tvec3 normal = SceneNormal( pos, localToWorld );\n\t\tvec3 lightDir = normalize( vec3( 0.5, 0.3, 1.0 ) );\n\t\tvec3 lightColor = vec3( 1.6 );\n\t\t\n\t\tvec3 posLS = pos * localToWorld;\n\t\tvec3 nrmLS = normal * localToWorld;\n\t\tvec2 uvX = posLS.yz;\n\t\tvec2 uvY = posLS.xz;\n\t\tvec2 uvZ = posLS.xy;\n\t\t\n\t\tvec3 textureX = texture( iChannel0, uvX ).xyz;\n\t\tvec3 textureY = texture( iChannel0, uvY ).xyz;\n\t\tvec3 textureZ = texture( iChannel0, uvZ ).xyz;\n\t\t\n\t\tvec3 weights = max( abs( nrmLS ), 0.00001 );\n\t\tweights /= weights.x + weights.y + weights.z;\n\t\t\n\t\tvec3 texture = textureX * weights.x + textureY * weights.y + textureZ * weights.z;\n\t\t\n\t\tfloat rustMask = 0.0;\n\t\t\t\t\n\t\tvec3 diffuseColor = mix( vec3( 0.0 ), texture, rustMask );\n\t\trustMask = 0.0;\n\t\tvec3 specularColor = mix( texture, vec3( 0.04 ), rustMask );\n\t\tfloat roughness = mix( 0.2, 0.6, rustMask );\n\t\t\n\t\tvec3 diffuse = lightColor * clamp( dot( normal, lightDir ), 0.0, 1.0 );\n\t\tcolor = diffuseColor * ( diffuse + 0.2 );\n\t\tcolor += LightSpecular( normal, rayDir, lightDir, lightColor, roughness, specularColor );\n\t}\n\t\n\tfragColor = vec4( color, 1.0 );\n}\n\n","name":"Image","description":"","type":"image"}]}