{"ver":"0.1","info":{"id":"mlSyWt","date":"1692415202","viewed":36,"name":"Van Der Waerden's quartic solver","username":"Envy24","description":"Quartic solver from this paper:\nhttps://quarticequations.com/Quartic.pdf\nTest-drive: https://www.shadertoy.com/view/dlScWt\nMore solvers: https://www.shadertoy.com/playlist/sfjBz1","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["solver","quartic","polynomial","modified","der","van","waerdens"],"hasliked":0,"parentid":"DtScDd","parentname":"NBS modified quartic solver"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCENE_SCALE               ( 2. )\n#define UNIT                      ( (3.0*SCENE_SCALE) / iResolution.y  )\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nfloat quarticSDF(vec2 NDC, float a, float b, float c, float d, float e)\n{\n    float df   = NDC.y - ((((a * NDC.x + b) * NDC.x + c) * NDC.x + d) * NDC.x + e),\n          dfdx = ((4.0 * a * NDC.x + 3.0 * b) * NDC.x + 2.0 * c) * NDC.x + d;\n    return abs(df) / sqrt(1.0 + dfdx * dfdx);\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0), true);\n\n    //float a = -0.8, b = -1.4, c = 0.8, d = 0.0, e = -1.0;\n    /* Quartic *\n    float a = 1., b = 12., \n          c = 48., d = 80.,\n          e = 48.;\n    /* Quartic */\n    float a = sinOSC(-1.25, 1.25, iTime * 0.15), b = sinOSC( -2.0,  2.0, iTime * 0.6), \n          c = sinOSC( -1.0,  1.0, iTime * 0.45), d = sinOSC( -1.0,  1.0, iTime * 0.25),\n          e = sinOSC( -1.0,  1.0, iTime * 0.17);\n    /* Cubic *\n    float a =                               0.0, b = sinOSC( -2.0,  2.0, iTime * 0.6), \n          c = sinOSC( -1.0,  1.0, iTime * 0.45), d = sinOSC( -1.0,  1.0, iTime * 0.25),\n          e = sinOSC( -1.0,  1.0, iTime * 0.17);\n    /* Quadratic *\n    float a =                               0.0, b =                               0.0, \n          c = sinOSC( -1.0,  1.0, iTime * 0.45), d = sinOSC( -1.0,  1.0, iTime * 0.25),\n          e = sinOSC( -1.0,  1.0, iTime * 0.17);\n    /* Linear *\n    float a =                               0.0, b =                               0.0,\n          c =                               0.0, d = sinOSC( -1.0,  1.0, iTime * 0.25),\n          e = sinOSC( -1.0,  1.0, iTime * 0.17);\n    /* Identity 0 == 0 *\n    float a =                               0.0, b =                              0.0,\n          c =                               0.0, d =                              0.0,\n          e =                               0.0;\n    /**/\n\n    // Cauchy's roots bounds.\n    float upper_bound = max(0.0, 1.0 + max(-a/a, max(-b/a, max(-c/a, max(-d/a, -e/a)))));\n    float lower_bound = max(0.0, 1.0 + max( a/a, max( b/a, max( c/a, max( d/a,  e/a)))));\n\n    vec3 color = (NDC.x <= upper_bound && NDC.x >= -lower_bound) ? vec3(.9,.9,.9) : vec3(1.);\n         color = mix( color, vec3(0.8), SMAA(cellsSDF(NDC)) );\n         color = mix( color, vec3(0), SMAA(x_axisSDF(NDC)) );\n         color = mix( color, vec3(0), SMAA(y_axisSDF(NDC)) );\n         color -= SMAA(quarticSDF(NDC, a, b, c, d, e));\n\n    vec2 roots[4]; float coef[5] = float[5]( a, b, c, d, e );\n      \n    // Non-numeric solvers.\n    int num = solve_quartic(roots, coef);\n\n    for (int r = 0; r < num; ++r) \n    {\n        float x = roots[r].x;\n        color = mix(color, vec3(1, 0, 0), SMAA(diskSDF(NDC, vec2(x, 0.0), 0.03)));\n    }\n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float diskSDF(vec2 NDC, vec2 C, float R) { return length(C - NDC)-R; }\nfloat y_axisSDF(vec2 NDC) { return abs(NDC.x); }\nfloat x_axisSDF(vec2 NDC) { return abs(NDC.y); }\nfloat vertical_lineSDF(vec2 NDC, float x0) { return abs(NDC.x-x0); }\nfloat horizontal_lineSDF(vec2 NDC, float y0) { return abs(NDC.y-y0); }\nfloat cellsSDF(vec2 NDC)\n{\n    //NDC *= 2.; // Finer cells\n    NDC = fract(NDC);\n    NDC = fract(min(NDC, 1. - NDC));\n    return\n        min(vertical_lineSDF(NDC, 0.), horizontal_lineSDF(NDC, 0.));\n}\n\n/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\n/*\n    Returns number of real roots.\n*/\nint solveQuadraticForReal(\n    out vec2[2] roots,\n    float a, float b, float c)\n{\n    float discriminant = b * b - 4.0 * a * c,\n          inv_a = 1.0 / (2. * a),\n          sqrt_D = sqrt(discriminant);\n\n    roots[0].x = ( sqrt_D - b) * inv_a;  roots[0].y = 0.0;\n    roots[1].x = (-b - sqrt_D) * inv_a; roots[1].y = 0.0;\n\n    return \n        discriminant < 0.0 ? // No real roots?\n        0 : 2;\n}\n\n//\n// Solves cubic polynomial.\n// Returns number of real roots.\n//    if returns 1, then roots[0] is real, other two complex.\n//    if returns 3, then all 3 roots are real and they sorted in descending order.\n//\nint solve_cubic(\n    out vec2 roots[3],\n    float a, float b, float c, float d)\n{\n    // To monic cubic.\n    float inv_a = 1./ a;\n    b *= inv_a; c *= inv_a; d *= inv_a; a = 1.;\n\n    // Helper constants and variables.\n    float TAU = 6.2831853071795862,     // 2. * PI\n          inv3 = 0.33333333333333331,   // 1. / 3.\n          inv9 = 0.11111111111111110,   // 1. / 9.\n          sqrt3 = 1.7320508075688772,   // sqrt(3)\n          g = c * inv3,\n          h = b * inv3;        \n    \n    // Solve depressed cubic.\n    float q = g - (b * b) * inv9,\n          r = ((c * b - 3. * d) * .5 - (b * b * b) * inv9) * inv3,\n          qqq = q*q*q;\n\n    if (r * r + qqq > 0.) // One real root?\n    {\n        float A = pow(abs(r) + sqrt(r * r + qqq), inv3),\n              k = q / A,\n              t1 = r >= 0. ? A - k : k - A;\n\n        float x2 = -t1 * .5 - h,\n              y2 = (sqrt3 * .5) * (A + k);\n\n        roots[0] = vec2(t1 - h, 0.);\n        roots[1] = vec2(x2, y2);\n        roots[2] = vec2(x2, -y2);\n\n        return 1;\n    }\n    \n    // Three real roots.\n    float theta = q < 0. ? acos(r / sqrt(-qqq)) : 0.,\n        phi1 = theta * inv3,\n        phi2 = phi1 - TAU * inv3,\n        phi3 = phi1 + TAU * inv3,\n        n = 2. * sqrt(-q);\n\n    roots[2] = vec2(n * cos(phi1) - h, 0.);\n    roots[1] = vec2(n * cos(phi2) - h, 0.);\n    roots[0] = vec2(n * cos(phi3) - h, 0.);\n    // if idx seq is {0,1,2} ther roots sorted in descending order: z0 >= z1 >= z2\n    // if idx seq is {2,1,0} ther roots sorted in ascending order: z0 <= z1 <= z2\n\n    return 3;\n}\n\n//\n// Solves quartic polynomial.\n// Returns number of real roots.\n//   If returns 2, then roots[0] and roots[1] are real, other comlex.\n//   If returns 2, then all roots are real.\n//\nint solve_quartic_VanDerWaerden_modified(\n    out vec2 roots[4],\n    float a, float b, float c, float d, float e)\n{\n    // Convert to monic quartic polynomial.\n    float inv_a = 1. / a;\n    b *= inv_a; c *= inv_a; d *= inv_a; e *= inv_a;\n\n    // Solve cubic resolvent\n    float C = b * 0.25, CC = C * C,\n        b2 = c - 6. * CC,\n        b1 = d - 2. * C * (c - 4. * CC),\n        b0 = e - C * (d - C * (c - 3. * CC));\n    float cb = -2. * b2,\n        cc = b2 * b2 - 4. * b0,\n        cd = b1 * b1;\n    vec2 cr[3]; int num = solve_cubic(cr, 1., cb, cc, cd);\n\n    // Calculate roots.\n    float sigma = b1 > 0. ? 1. : -1.,\n        t = sqrt(max(cr[1].x * cr[2].x + cr[1].y * cr[1].y, 0.)),\n        w = sqrt(max(-cr[0].x, 0.)),\n        v0 = -cr[1].x - cr[2].x - 2. * sigma * t,\n        v1 = -cr[1].x - cr[2].x + 2. * sigma * t,\n        sqrt_v0 = sqrt(abs(v0)),\n        sqrt_v1 = sqrt(abs(v1));\n    vec2 z[4];\n    //                        Real roots case                       Complex roots case\n    z[0] = v0 >= 0. ? vec2(0.5 * ( w + sqrt_v0) - C, 0.) : vec2(0.5 * ( w) - C, 0.5 * ( sqrt_v0));\n    z[1] = v0 >= 0. ? vec2(0.5 * ( w - sqrt_v0) - C, 0.) : vec2(0.5 * ( w) - C, 0.5 * (-sqrt_v0));\n    z[2] = v1 >= 0. ? vec2(0.5 * (-w + sqrt_v1) - C, 0.) : vec2(0.5 * (-w) - C, 0.5 * ( sqrt_v1));\n    z[3] = v1 >= 0. ? vec2(0.5 * (-w - sqrt_v1) - C, 0.) : vec2(0.5 * (-w) - C, 0.5 * (-sqrt_v1));\n\n    // Sort roots by type.       0b0x             0bx0\n    switch                (int(v0 >= 0.) | (int(v1 >= 0.) << 1)) {\n    case 2: // 0b10, second two roots are real, other complex.\n        roots[0] = z[2]; roots[1] = z[3]; roots[2] = z[0]; roots[3] = z[1]; break; \n    case 0: // 0b00, all 4 roots are complex.\n    case 1: // 0b01, first two roots are real, other complex.\n    case 3: // 0b11, all roots are real.\n        roots[0] = z[0]; roots[1] = z[1]; roots[2] = z[2]; roots[3] = z[3]; break;\n    }\n\n    // Count real roots.\n    num = 0; num = v0 >= 0. ? num + 2 : num; num = v1 >= 0. ? num + 2 : num;\n\n    return num;\n}\n\n/* \n    Returns number of real roots.       \n*/\nint solve_quartic(\n    inout vec2[4] roots,\n    in float[5] coef)\n{\n    // Quartic equation?\n    if (coef[0] != 0.0)\n    {\n        return solve_quartic_VanDerWaerden_modified(roots, coef[0], coef[1], coef[2], coef[3], coef[4]);\n    }\n    \n    // Cubic equation?\n    if (coef[1] != 0.0)\n    {\n        vec2 roots_[3];\n        int num = solve_cubic(roots_, coef[1], coef[2], coef[3], coef[4]);\n        roots[0] = roots_[0]; roots[1] = roots_[1]; roots[2] = roots_[2];\n        \n        return num;\n    }\n    \n    // Quadratic equation?\n    if (coef[2] != 0.0)\n    {\n        vec2 roots_[2];\n        int num = solveQuadraticForReal(roots_, coef[2], coef[3], coef[4]);\n        roots[0] = roots_[0]; roots[1] = roots_[1];\n        \n        return num;\n    }\n\n    // Linear equation?\n    if (coef[3] != 0.0)\n    {\n        // Solve linear equation.\n        roots[0].x = -coef[4]/coef[3]; roots[0].y = 0.0;\n\n        return 1;\n    }\n\n    // Identity 0 == 0? Infinitely many roots?\n    if (coef[4] == 0.0) \n    { \n        // Pick zero root.\n        roots[0].x = 0.0; roots[0].y = 0.0;\n\n        return 1;\n    }\n    \n    return 0;\n}\n\n// Archive\n/**\nint solve_quartic_Euler_modified2(\n    out vec2 roots[4],\n    float a, float A3, float A2, float A1, float A0)\n{\n    // Convert to monic polynomial.\n    float inv_a = 1. / a;\n    A3 *= inv_a; A2 *= inv_a; A1 *= inv_a; A0 *= inv_a;\n\n    // Solve cubic resolvent\n    float C = A3 / 4.,\n        b2 = A2 - 6. * C * C,\n        b1 = A1 - 2. * A2 * C + 8. * C * C * C,\n        b0 = A0 - A1 * C + A2 * C * C - 3. * C * C * C * C;   \n    float ca = 1.,\n        cb = (b2 / 2.),\n        cc = (b2 * b2 - 4. * b0) / 16.,\n        cd = -(b1 * b1) / 64.;   \n    vec2 cr[3];\n    int num = solve_cubic(cr, ca, cb, cc, cd);\n\n    // Calculate roots.\n    float sigma = b1 > 0. ? 1. : -1.,\n        u = sqrt(max(cr[0].x, 0.)),\n        w = 2. * sigma * sqrt(max(cr[1].x * cr[2].x + cr[1].y * cr[1].y, 0.)),\n        v0 = cr[1].x + cr[2].x - w,\n        v1 = cr[1].x + cr[2].x + w,\n        sqrt_v0 = sqrt(abs(v0)),\n        sqrt_v1 = sqrt(abs(v1));    \n    vec2 z[4];\n    //                        Real roots case            complex roots case\n    z[0] = v0 >= 0. ? vec2( u + sqrt_v0 - C, 0.) : vec2( u - C,  sqrt_v0);\n    z[1] = v0 >= 0. ? vec2( u - sqrt_v0 - C, 0.) : vec2( u - C, -sqrt_v0);\n    z[2] = v1 >= 0. ? vec2(-u + sqrt_v1 - C, 0.) : vec2(-u - C,  sqrt_v1);\n    z[3] = v1 >= 0. ? vec2(-u - sqrt_v1 - C, 0.) : vec2(-u - C, -sqrt_v1);\n\n    // Sort roots.       0b0x             0bx0\n    switch        (int(v0 >= 0.) | (int(v1 >= 0.) << 1)) {\n    case 2: // 0b10, second two roots are real, other complex.\n        roots[0] = z[2]; roots[1] = z[3], roots[2] = z[0]; roots[3] = z[1]; break; \n    case 0: // 0b00, all 4 roots are complex.\n    case 1: // 0b01, first two roots are real, other complex.\n    case 3: // 0b11, all roots are real.\n        roots[0] = z[0]; roots[1] = z[1]; roots[2] = z[2]; roots[3] = z[3]; break;\n    }\n\n    // Count real roots.\n    num = 0;\n    num = v0 >= 0. ? num + 2 : num;\n    num = v1 >= 0. ? num + 2 : num;\n\n    return num;\n}\n/**/","name":"Common","description":"","type":"common"}]}