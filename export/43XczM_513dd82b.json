{"ver":"0.1","info":{"id":"43XczM","date":"1725954987","viewed":60,"name":"Reflective Journey 69","username":"omansounds","description":"Reflections. Test.","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (sqrt(5.)*0.5 + 0.5)\n\nconst int STEPS = 128;\nconst float MAX_DIST = 500.;\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e ) {\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// Blobby ball object. You've probably seen it somewhere. This is not a correct distance bound, beware.\nfloat fBlob(vec3 p) {\n\tp = abs(p);\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\tfloat b = max(max(max(\n\t\tdot(p, normalize(vec3(1., 1., 1.))),\n\t\tdot(p.xz, normalize(vec2(PHI+1., 1.)))),\n\t\tdot(p.yx, normalize(vec2(1., PHI)))),\n\t\tdot(p.xz, normalize(vec2(1., PHI))));\n\tfloat l = length(p);\n\treturn l - 1.5 - 0.2 * (1.5 / 2.)* cos(min(sqrt(1.01 - b / l)*(PI / 0.25), PI));\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat Round(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\n\n// Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\n\nfloat map(vec3 p) {\n    //time\n    p.z += iTime;\n\n    //blob\n    vec3 q = (p - vec3(sin(iTime), cos(iTime *1.5), iTime + 3. + sin(iTime *2.)));\n\n    //sphere\n    float sphere = length(q) - 1.0;\n    sphere += sin(p.y*10.+iTime*6.)*0.05;\n    sphere += sin(p.x*10.+iTime*6.)*0.05;\n\n    //modulo\n    pMod3(p, vec3(2.5));\n\n    //box\n    float box = sdBoxFrame(p, vec3(1.0), 0.1);\n\n    //final\n    float map = Round(box, sphere, 0.5);\n\treturn map;\n\n\n}\n\nvec3 getNormal(vec3 p)\n{\n\tvec3 eps=vec3(.1,0,0);\n\treturn normalize(vec3(map(p+eps.xyy),map(p+eps.yxy),map(p+eps.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec4 col = vec4(0);\n\n    vec3 p = ro, pp;\n\n    float t = 0.;\n\n\t//First raymarching\n\tfor(int i = 0; i < STEPS; i++) {\n\n\t  \tfloat d = map(p);\n\n        t += d;\n\t\tp += d * rd;\n\n        if (t < .001 || t > 500.) break;\n\t}\n\tpp = p; \n\tfloat f = length(p - ro) * 0.02;\n\n\t/*\n    //Second raymarching (reflection)\n    rd = reflect(rd, getNormal(p));\n\tp += rd;\n    float reflectionType = 1.0;\n    for(int i = 0; i < STEPS/2; i++) {\n\n\t\tfloat d = map(p);\n\n\t \tp += d * rd * reflectionType;\n\t}\n    */\n\n    vec3 lightDir = normalize(vec3(0.0, 0.1, 0.2)); // Direction of the light\n    vec3 viewDir = normalize(ro - p); // View direction\n    vec3 normal = getNormal(p); // Surface normal\n    float distanceAttenuation = exp(-0.1 * length(p - ro));\n\n    // Diffuse lighting\n    //float diffuse = max(dot(normal, lightDir), 1.0);\n    float diffuse = clamp(dot(normal, lightDir), 0.0, 1.0);\n\n    // Bac ????\n    float bac = clamp(dot( normal, -lightDir), 0.0, 1.0 );\n\n    // Specular lighting\n    vec3 reflectDir = reflect(-lightDir, normal);\n    //float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0); // Shininess factor is 32.0\n\tfloat spec = pow(clamp(dot( reflect(rd, normal), lightDir ), 0.0, 1.0 ),400.);\n\n\t// Fresnal \n\tfloat fresnal = pow( clamp(1.0+dot(normal, rd),0.0,1.0), 2.0 );\n\n    // Brdf ????\n    vec3 brdf = vec3(0.10,0.11,0.13);\n    brdf += bac * vec3(0.1);\n    brdf += diffuse * vec3(1.00,0.90,0.60);\n    \n    col.rgb += vec3(0.3, cos(iTime * 0.5) * 0.5 + 0.5, sin(iTime * 0.5) * 0.5 + 0.5);\n\n    col.rgb = (col.rgb*(diffuse + .65) + vec3(1.0, 1.0, 1.0) * spec * 2.)*distanceAttenuation;\n\n\tcol.rgb = col.rgb * brdf + col.rgb*spec +.3*fresnal*mix(col.rgb,vec3(1),0.5);\n\n        \n    vec4 fcol = (col + vec4(f)) * distanceAttenuation * min(iTime * 0.5, 1.0);\n\n\n    fragColor = vec4(fcol.xyz, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}