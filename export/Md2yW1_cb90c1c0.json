{"ver":"0.1","info":{"id":"Md2yW1","date":"1492054210","viewed":233,"name":"Raycast with WASD Movement","username":"Polygon","description":"I've had no experience with raycasting, but I'm trying to teach myself. Something is off with the spheres, but I think that's due to the inaccuracy of floats and/or the sin function.\nedit: REFLECTION!! (it was actually surprisingly easy)","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["3d","simple","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.14159265\n#define d2r 0.0174533\n\n//Hit stores data of a point on a surface that a ray collides with\nstruct Hit {\n    float dist;\n    vec3 pos;\n    vec3 normal;\n};\n\n\nfloat square(float num);\n\nHit sphere(vec3 center, vec3 start, vec3 direction, float r);\nfloat sphereDist(vec3 center, vec3 start, vec3 direction, float r);\nvec3 sphereNormal(vec3 center, vec3 point);\n\nHit planeY (vec3 start, vec3 direction, float posY);\nvec2 planeYpos(vec3 start, vec3 direction, float posY);\nfloat distPlaneY(vec3 start, vec3 direction, float posY);\n\nvec3 reflection(vec3 direction, vec3 normal);\n\n\nvec4 checkCollisions(vec3 pos, vec3 direction, float startDist);\nvec4 render(vec2 i, vec4 o);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n    //Anti-Aliasing has been removed to increase performance.\n    \n    \n    //Anti-Aliasing by averaging colors of four points\n    /*\n    fragColor += render(fragCoord + vec2(0.25, 0.25), fragColor) / 4.0;\n    fragColor += render(fragCoord + vec2(-0.25, 0.25), fragColor) / 4.0;\n    fragColor += render(fragCoord + vec2(-0.25, -0.25), fragColor) / 4.0;\n    fragColor += render(fragCoord + vec2(0.25, -0.25), fragColor) / 4.0;\n\t*/\n\t\n    \n    fragColor = render(fragCoord, fragColor);\n}\n\nvec4 render(vec2 i, vec4 o) {\n    vec2 uv = i.xy / iResolution.xy;\n    vec2 uvM = iMouse.xy / iResolution.xy;\n    \n    float diagonal = sqrt(square(iResolution.x)+square(iResolution.y));\n    vec2 s = i.xy / diagonal - vec2(0.5 * iResolution.x / diagonal, 0.5 * iResolution.y / diagonal);\n    \n    vec3 pos = texture(iChannel1, vec2(0.5 / iResolution.x, 0.5 / iResolution.y)).xyz;\n    \n    //vec2 rot = vec2(2.0 * pi * (uvM.x - 0.5), pi * (uvM.y - 0.5));\n    vec2 rot = texture(iChannel1, vec2(2.5 / iResolution.x, 0.5 / iResolution.y)).xy;\n    \n    //Field of vision. Can be more than 360 degrees!\n    float fov = 100.0;\n    \n    //Distance between pixel from center of screen\n    float screenr = sqrt(s.x*s.x + s.y*s.y);\n    \n    //Direction of ray\n    vec3 direction = vec3(s.x / screenr * sin(fov * d2r * screenr), s.y / screenr * (sin(fov * d2r * screenr)), cos(fov * d2r * screenr));\n    //Rotations of screen\n    direction = vec3(direction.x, direction.y * cos(rot.y) + direction.z * sin(rot.y), direction.z * cos(rot.y) - direction.y * sin(rot.y));\n    direction = vec3(direction.x * cos(rot.x) + direction.z * sin(rot.x), direction.y, direction.z * cos(rot.x) - direction.x * sin(rot.x));\n    \n    \n    int closest = -1;\n    Hit[3] hits;\n    \n    //Sphere 1\n    hits[0] = sphere(vec3(0.0, sin(pi * iTime), 4.0), pos, direction, 1.0);\n    if (hits[0].dist > 0.0)\n    \tclosest = 0;\n    \n    //Plane\n    hits[1] = planeY(pos, direction, -3.0);\n    if (hits[1].dist > 0.0) {\n        if (closest > -1) {\n            if (hits[1].dist < hits[closest].dist)\n        \t\tclosest = 1;\n        } else {\n            closest = 1;\n        }\n\t}\n    \n    //Sphere 2\n    hits[2] = sphere(vec3(5.0, -3.0, 3.0), pos, direction, 1.0);\n    if (hits[2].dist > 0.0) {\n        if (closest > -1) {\n            if (hits[2].dist < hits[closest].dist)\n        \t\tclosest = 2;\n        } else {\n            closest = 2;\n        }\n\t}\n    \n    switch(closest) {\n    case 0:\n        o = checkCollisions(hits[closest].pos, reflect(direction, hits[closest].normal), hits[closest].dist);\n        break;\n    case 1:\n        o = texture(iChannel0, hits[closest].pos.xy) / square(hits[closest].dist / 200.0 + 1.0) + vec4(0.5, 0.7,1.0,1.0) * (1.0 - 1.0 / square(hits[closest].dist / 200.0 + 1.0));\n        break;\n    case 2:\n        o.xyz = hits[closest].normal;\n        break;\n    default:\n        o = vec4(0.5 - 0.5 * sin(direction.y), 0.7 - 0.3 * sin(direction.y),1.0,0.0);\n    }\n\n    return o;\n}\n\n\nvec4 checkCollisions(vec3 pos, vec3 direction, float startDist) {\n    vec4 o;\n    \n    int closest = -1;\n    Hit[3] hits;\n    \n    //Plane\n    hits[1] = planeY(pos, direction, -3.0);\n    if (hits[1].dist > 0.0) {\n        if (closest > -1) {\n            if (hits[1].dist < hits[closest].dist)\n        \t\tclosest = 1;\n        } else {\n            closest = 1;\n        }\n\t}\n    \n    //Sphere 2\n    hits[2] = sphere(vec3(5.0, -3.0, 3.0), pos, direction, 1.0);\n    if (hits[2].dist > 0.0) {\n        if (closest > -1) {\n            if (hits[2].dist < hits[closest].dist)\n        \t\tclosest = 2;\n        } else {\n            closest = 2;\n        }\n\t}\n    \n    hits[closest].dist += startDist;\n    \n    switch(closest) {\n    case 0:\n        o.xyz = hits[closest].normal;\n        break;\n    case 1:\n        o = texture(iChannel0, hits[closest].pos.xy) / square(hits[closest].dist / 200.0 + 1.0) + vec4(0.5, 0.7,1.0,1.0) * (1.0 - 1.0 / square(hits[closest].dist / 200.0 + 1.0));\n        break;\n    case 2:\n        o.xyz = hits[closest].normal;\n        break;\n    default:\n        o = vec4(0.5 - 0.5 * sin(direction.y), 0.7 - 0.3 * sin(direction.y),1.0,0.0);\n    }\n\n    return o;\n}\n\n\nfloat square(float num) {\n    return num * num;\n}\n\nfloat sec(float num) {\n    return(1.0 / cos(num));\n}\n\nfloat csc(float num) {\n    return(1.0 / sin(num));\n}\n\nHit sphere(vec3 center, vec3 start, vec3 direction, float r) {\n    float c = dot(start - center, start - center) - r*r;\n    float b = dot(direction, (start - center));\n    \n    if (square(b) > c) {\n        \n        float dist1 = -b - sqrt(square(b) - c);\n        float dist2 = -b + sqrt(square(b) - c);\n        \n        float dist;\n            \n        if (dist1 > 0.0 && dist2 > 0.0)\n            dist = min(dist1, dist2);\n        else if (dist1 > 0.0 && dist2 < 0.0)\n            dist = dist1;\n        else if (dist1 < 0.0 && dist2 > 0.0)\n            dist = dist2;\n        else\n            dist = -1.0;\n            \n        return Hit(dist, dist * direction + start, (dist * direction + start - center) / distance(center, dist * direction + start));\n    }\n    \n    return Hit(-1.0, vec3(0.0), vec3(0.0));\n}\n\nfloat sphereDist(vec3 center, vec3 start, vec3 direction, float r) {\n    float c = square(center.x - start.x) + square(center.y - start.y) + square(center.z - start.z) - r*r;\n    float b = -direction.x*(center.x - start.x) - direction.y*(center.y - start.y) - direction.z*(center.z - start.z);\n    \n    \n    if (square(b) > c) {\n        \n        float dist1 = -b - sqrt(square(b) - c);\n        float dist2 = -b + sqrt(square(b) - c);\n        \n        float dist;\n            \n        if (dist1 > 0.0 && dist2 > 0.0)\n            dist = min(dist1, dist2);\n        else if (dist1 > 0.0 && dist2 < 0.0)\n            dist = dist1;\n        else if (dist1 < 0.0 && dist2 > 0.0)\n            dist = dist2;\n        else\n            dist = -1.0;\n            \n        return dist;\n    }\n    \n    return -1.0;\n}\n\nvec3 sphereNormal(vec3 center, vec3 point) {\n    return (point - center) / distance(center, point);\n}\n\nHit planeY (vec3 start, vec3 direction, float posY) {\n    float dist = (posY - start.y) / direction.y;\n    return Hit(dist, vec3(direction.x * dist + start.x, direction.z * dist + start.z, posY), vec3(0.0, 1.0, 0.0));\n}\nvec2 planeYpos(vec3 start, vec3 direction, float posY) {\n    float dist = (posY - start.y) / direction.y;\n    return vec2(direction.x * dist + start.x, direction.z * dist + start.z);\n}\nfloat distPlaneY(vec3 start, vec3 direction, float posY) {\n    return (posY - start.y) / direction.y;\n}\n\nvec3 reflection(vec3 direction, vec3 normal) {\n    \n    \n    \n    return vec3(0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//This buffer is for storing data such as position, rotation, and mouse position\n\n#define pi 3.14159265\n#define d2r 0.0174533\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec2 prevMouse = texture(iChannel0, vec2(1.5 / iResolution.x, 0.5 / iResolution.y)).xy / iResolution.xy;\n\n    \n    vec3 pos = texture(iChannel0, vec2(0.5 / iResolution.x, 0.5 / iResolution.y)).xyz;\n    vec2 rot = texture(iChannel0, vec2(2.5 / iResolution.x, 0.5 / iResolution.y)).xy;\n    \n    \n    //Screen dragging\n    if (iMouse.z > 0.0) {\n        if (texture(iChannel0, vec2(1.5 / iResolution.x, 0.5 / iResolution.y)).z <= 0.0) {\n        \tprevMouse = mouse;\n        }\n        \n        rot += vec2(2.0 * pi * (mouse.x - prevMouse.x), pi * (mouse.y - prevMouse.y));\n        \n        if (rot.y > pi / 2.0)\n            rot.y = pi / 2.0;\n        if (rot.y < -pi / 2.0)\n            rot.y = -pi / 2.0;\n    }\n    \n    //Keyboard controls\n    if (texture(iChannel1, vec2(38.5 / 256.0, 1.0 / 6.0)).x > 0.0 || texture(iChannel1, vec2(87.5 / 256.0, 1.0 / 6.0)).x > 0.0) {\n        pos.z += 10.0 * iTimeDelta * cos(rot.x);\n        pos.x += 10.0 * iTimeDelta * sin(rot.x);\n    }\n    if (texture(iChannel1, vec2(40.5 / 256.0, 1.0 / 6.0)).x > 0.0 || texture(iChannel1, vec2(83.5 / 256.0, 1.0 / 6.0)).x > 0.0) {\n        pos.z -= 10.0 * iTimeDelta * cos(rot.x);\n        pos.x -= 10.0 * iTimeDelta * sin(rot.x);\n    }\n    if (texture(iChannel1, vec2(39.5 / 256.0, 1.0 / 6.0)).x > 0.0 || texture(iChannel1, vec2(68.5 / 256.0, 1.0 / 6.0)).x > 0.0) {\n        pos.z -= 10.0 * iTimeDelta * sin(rot.x);\n        pos.x += 10.0 * iTimeDelta * cos(rot.x);\n    }\n    if (texture(iChannel1, vec2(37.5 / 256.0, 1.0 / 6.0)).x > 0.0 || texture(iChannel1, vec2(65.5 / 256.0, 1.0 / 6.0)).x > 0.0) {\n        pos.z += 10.0 * iTimeDelta * sin(rot.x);\n        pos.x -= 10.0 * iTimeDelta * cos(rot.x);\n    }\n    if (texture(iChannel1, vec2(32.5 / 256.0, 1.0 / 6.0)).x > 0.0) {\n        pos.y += 10.0 * iTimeDelta;\n    }\n    if (texture(iChannel1, vec2(16.5 / 256.0, 1.0 / 6.0)).x > 0.0) {\n        pos.y -= 10.0 * iTimeDelta;\n    }\n    \n    \n    if (fragCoord.xy == vec2(0.5, 0.5)) {\n        fragColor.xyz = pos;\n    }\n    if (fragCoord.xy == vec2(1.5, 0.5)) {\n        fragColor = iMouse;\n    }\n    if (fragCoord.xy == vec2(2.5, 0.5)) {\n        fragColor.xy = rot;\n    }\n    \n    \n    \n}","name":"Buf A","description":"","type":"buffer"}]}