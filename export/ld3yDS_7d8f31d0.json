{"ver":"0.1","info":{"id":"ld3yDS","date":"1519983795","viewed":176,"name":"Wobbly checkerboard","username":"Ultraviolet","description":"Reproduction of [url]https://i.imgur.com/JT6i1Yp.jpg[/url].\nInterrestingly, the cross color distribution play a great role in the illusion.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["illusion","perception"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nmat2 rot(float alpha)\n{\n    return mat2(cos(alpha), sin(alpha), -sin(alpha), cos(alpha));\n}\n\nfloat hash(in ivec2 c)\n{\n  int x = 0x3504f333*c.x*c.x + c.y;\n  int y = 0xf1bbcdcb*c.y*c.y + c.x;\n    \n  return float(x*y)*(2.0/8589934592.0)+0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //*\n\n\t//Testing some drawing functions\n\n    vec2 p = (fragCoord -iResolution.xy*.5)/iResolution.y*2.;\n    vec2 m = (iMouse.xy -iResolution.xy*.5)/iResolution.y*2.;\n    \n    vec3 col = vec3(1.);\n    \n    if(max(abs(p.x), abs(p.y)) > 1.)\n    {\n    \tfragColor = vec4(.1);\n        return;\n    }\n        \n    \n    /*\n    // Background grid\n    DRAW_C(Grid(.1), p, vec3(.5), .5, col);\n    //DRAW(Grid(.1), p, vec3(.5), col);\n    DRAW_C(Ticks(1.), p, vec3(0.), .5, col);\n    DRAW_C(Ticks(.1), p, vec3(0.), .5, col);\n    \n    // Axis\n    DRAW_C(Ray(vec2(0.), vec2(1.,0.)), p, vec3(.1), 1., col);\n    DRAW_C(Ray(vec2(0.), vec2(0.,1.)), p, vec3(.1), 1., col);\n\t//*/\n    \n    float nb_cells = 16.;\n    \n    col = vec3(160., 215., 51.)/255.;\n    \n    DRAW(Grid(2./nb_cells), p, vec3(81., 186., 129.)/255., col);\n    \n    ivec2 pi = ivec2(floor(p*nb_cells*.5+.5));\n    \n    if(max(abs(pi.x), abs(pi.y))<int(nb_cells/2.))\n    {\n        p = mod(p+1./nb_cells, 2./nb_cells)-1./nb_cells;\n        p = abs(p);\n        if(p.y>p.x)\n        \tp = p.yx;\n\n\n        vec2 p0 = vec2(-.1, 0.);\n        vec2 p1 = vec2(.55, .35);\n        vec2 p2 = vec2(1., 0.);\n        vec2 p3 = p1*vec2(1., -1.);\n\n        float cross_scale = 1./nb_cells*0.4;\n        p0 *= cross_scale;\n        p1 *= cross_scale;\n        p2 *= cross_scale;\n        p3 *= cross_scale;\n\n        vec3 cross_col = vec3(1.);\n\n        //if((pi.x+pi.y)%2==0)\n        //if(hash(pi)>.5)\n        if(hash(ivec2(pi.x+pi.y, 0))>.5)\n            cross_col = vec3(174., 7., 121.)/255.;\n\n        DRAW(Quad(p0, p1, p2, p3), p, cross_col, col);\n\n        /*\n        mat2 r = rot(PI/2.);\n        p0 = r*p0;\n        p1 = r*p1;\n        p2 = r*p2;\n        p3 = r*p3;\n        DRAW(Quad(p0, p1, p2, p3), p, cross_col, col);\n\n        p0 = r*p0;\n        p1 = r*p1;\n        p2 = r*p2;\n        p3 = r*p3;\n        DRAW(Quad(p0, p1, p2, p3), p, cross_col, col);\n\n        p0 = r*p0;\n        p1 = r*p1;\n        p2 = r*p2;\n        p3 = r*p3;\n    \tDRAW(Quad(p0, p1, p2, p3), p, cross_col, col);\n*/\n    }\n    \n    //col = vec3(pi, 0.)/10.;\n    \n    fragColor = vec4(col, 0.);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI\t3.1415926535\n\n//---------------------------------------\n// Utils\n\n// Solve quadratic equation for roots\nvec2 solveQuadratic(float b, float c)\n{\n    float d = sqrt(b*b-4.*c);\n    return vec2((-b-d)/2., (-b+d)/2.);\n}\n\n\n// Solve cubic equation for roots\nvec3 solveCubic(float a, float b, float c)\n{\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\nfloat angle(vec2 p)\n{\n    return atan(p.y, p.x);\n}\n\nfloat angle(vec2 p0, vec2 p1)\n{\n    float a =  angle(p1) - angle(p0);\n    a = mod(a-PI, 2.*PI)-PI;\n    \n    return a;\n}\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb);\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\n\n//---------------------------------------\n// Point\n\nfloat dist(vec2 p0, vec2 p1)\n{\n    return length(p1-p0);\n}\n\n\n\n\n//---------------------------------------\n// Circle\n\nstruct Circle\n{\n    vec2 ctr;\n    float rad;\n};\n\nvec2 getPt(Circle c, float t)\n{\n    return c.ctr + c.rad*vec2(cos(t*PI*2.), sin(t*PI*2.));\n}\n    \nfloat dist(Circle c, vec2 p)\n{\n    return (length(c.ctr-p)-c.rad);\n}\n\n    \n    \n//---------------------------------------\n// Ray\n\nstruct Ray\n{\n    vec2 org;\n    vec2 dir;\n};\n    \nvec2 getPt(Ray r, float t)\n{\n    return r.org + t*r.dir;\n}\n\nfloat dist(Ray r, vec2 p)\n{\n    return abs(dot(r.dir.yx*vec2(-1., 1.), p-r.org)/dot(r.dir, r.dir));\n    \n    \n    float t = dot(r.dir, p-r.org);\n    t = max(t, 0.);\n    return length(getPt(r, t) - p);\n}\n\n\n\n\n//---------------------------------------\n// Segment\n\nstruct Segment\n{\n    vec2 A;\n    vec2 B;\n};\n\nvec2 getPt(Segment c, float t)\n{\n    return mix(c.A, c.B, t);\n}\n\nfloat dist(Segment s, vec2 p)\n{\n\tvec2 pa = p-s.A, ba = s.B-s.A;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n\n\n//---------------------------------------\n// Bezier3\n\nstruct Bezier3\n{\n    vec2 A;\n    vec2 B;\n    vec2 C;\n};\n    \nvec2 getPt(Bezier3 c, float t)\n{\n    return mix(mix(c.A, c.B, t), mix(c.B, c.C, t), t);\n}\n\nfloat dist(Bezier3 B, vec2 p)\n{\n    vec2 a = B.B - B.A, b = B.A - B.B * 2.0 + B.C, c = a * 2.0, d = B.A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);      \n    vec3 t = clamp(solveCubic(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = B.A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = B.A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = B.A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis;\n}\n\n    \n    \n    \n//---------------------------------------\n// Bezier4\n\nstruct Bezier4\n{\n    vec2 A;\n    vec2 B;\n    vec2 C;\n    vec2 D;\n};\n    \nvec2 getPt(Bezier4 c, float t)\n{\n    return mix(mix(mix(c.A, c.B, t), mix(c.B, c.C, t), t), mix(mix(c.B, c.C, t), mix(c.C, c.D, t), t), t);\n}\n\nfloat dist(Bezier4 BB, vec2 p)\n{\n    vec2 A = BB.A, B = BB.D;\n    \n    float ppt;\n    float At = .0;\n    float Bt = 1.;\n    \n    vec2 pp;\n    \n    float dis = dist(pp, p);\n    \n    for(int i=0; i<5; ++i)\n    {\n        ppt = (At+Bt)*.5;\n        pp = getPt(BB, ppt);\n        \n        if(dist(Segment(A, pp), p) < dist(Segment(pp, B), p))\n        {\n            Bt = ppt;\n        \tB = getPt(BB, Bt);\n        }\n        else\n        {\n            At = ppt;\n        \tA = getPt(BB, At);\n        }\n            \n    }\n    \n    return min(dist(Segment(A, pp), p), dist(Segment(B, pp), p));\n}\n\n    \n    \n    \n//---------------------------------------\n// Grid\n\nstruct Grid\n{\n    float inter;\n}; \n\nfloat dist(Grid g, vec2 p)\n{\n    vec2 d = abs(mod(p+g.inter*.5,g.inter*2.)-g.inter)-g.inter*.5;\n    //d = min(d, 2.*g.inter-d);\n    //return sqrt(abs(d.x*d.y))*sign(d.x*d.y);\n    //return d.x+d.y;\n    return max(min(d.x, d.y), min(-d.x, -d.y));\n    \n    //bvec2 l = greaterThan(mod(p,g.inter*2.),vec2(g.inter));\n    //return all(l)||all(not(l)) ? 1. : 0.;\n}\n\n\n    \n    \n//---------------------------------------\n// Ticks\n\nstruct Ticks\n{\n    float inter;\n};\n    \nfloat dist(Ticks g, vec2 p)\n{\n    vec2 dd = mod(p, g.inter);\n    dd = min(dd, g.inter-dd);\n    float d = min(dd.x, dd.y);\n    d = max(d, min(max(abs(p.x)-g.inter*.1, 0.), max(abs(p.y)-g.inter*.1, 0.)));\n    return d;\n}\n\n//---------------------------------------\n// Quad\n\nstruct Quad\n{\n    vec2 A;\n    vec2 B;\n    vec2 C;\n    vec2 D;\n};\n\nfloat winding(Quad q,vec2 p)\n{\n    float w = 0.0;\n    \n    w += angle(q.A-p, q.B-p);\n    w += angle(q.B-p, q.C-p);\n    w += angle(q.C-p, q.D-p);\n    w += angle(q.D-p, q.A-p);\n    \n    return w;\n}\n\nfloat dist(Quad q, vec2 p)\n{\n    float d = min(min(dist(Segment(q.A, q.B), p), \n                      dist(Segment(q.B, q.C), p)),  \n                  min(dist(Segment(q.C, q.D), p), \n                      dist(Segment(q.D, q.A), p)));\n    float w = winding(q, p);\n    if(abs(w)>0.001)\n        d *= -1.;\n    return d;\n}\n\n\n\n\n//---------------------------------------\n// Intersections\n\nbool intersect(Circle c, Ray r, out vec2 t)\n{\n    float A = dot(r.dir, r.dir);\n    float B = dot(r.dir, -c.ctr+r.org);\n    float C = dot(c.ctr, c.ctr) +dot(r.org, r.org) -2.*dot(c.ctr, r.org) - c.rad*c.rad;\n    \n    float delta = B*B-A*C;\n    \n    if(delta < 0.0)\n    \treturn false;\n\n    t = (vec2(-B) + vec2(sqrt(delta))*vec2(-1.,1.))/A;\n    return true;\n}\n\nbool intersect(Ray r0, Ray r1, out vec2 t)\n{\n    t = inverse(mat2(r0.dir, -r1.dir))*(r1.org-r0.org);\n    return true;\n}\n\n\n\n//---------------------------------------\n// Drawing Macros\n\n// draw the inside of the shape\n#define DRAW(O,P,C,CC)\tCC=mix(CC,C,mix(1.,0.,clamp(dist(O,P)*iResolution.y/2., -1., 1.)*.5+.5))\n\n// draw the contour of the shape \n#define DRAW_C(O,P,C,W,CC)\tCC=mix(CC,C,mix(1.,0.,clamp(abs(dist(O,P))*iResolution.y/2.-W, -1., 1.)*.5+.5))\n\n// draw the contour of the shape with alpha\n#define DRAW_CA(O,P,C,W,CC)\tCC=mix(CC,C.rgb,(mix(1.,0.,clamp(abs(dist(O,P))*iResolution.y/2. -  W, -1., 1.)*.5+.5))*(1.-C.a))\n\n// draw the contour of the shape with alpha\n#define DRAW_A(O,P,C,CC)\tCC=mix(CC,C.rgb,(mix(1.,0.,clamp((dist(O,P))*iResolution.y/2., -1., 1.)*.5+.5))*(1.-C.a))\n\n\n\n","name":"Common","description":"","type":"common"}]}