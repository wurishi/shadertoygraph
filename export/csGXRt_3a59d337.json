{"ver":"0.1","info":{"id":"csGXRt","date":"1681426232","viewed":78,"name":"williams_walk4 demo","username":"valalalalala","description":"Working on an animation workflow based on keyframes. The walk cycle is based on the canonical Richard Williams 4-frame cycle mirror (x,y) at the end of each cycle.  Feedback on improving the generated code greatly appreciated","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","animation","character","keyframes"],"hasliked":0,"parentid":"ddVXz3","parentname":"capsulistica!"},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"        //////////////////////////////////////////////////////////////////////\n       //                                                                 ////\n      // \"williams_walk4 demo\"                                           // //\n     //                                                                 //  //\n    // Working on an animation workflow based on keyframes. The walk   //   //\n   // cycle is based on the canonical Richard Williams 4-frame cycle  //    //\n  // mirror (x,y) at the end of each cycle.                          //     //\n //                                                                 //     ///\n/////////////////////////////////////////////////////////////////////     ////\n//                                                                 //    // //\n// Creative Commons Attribution-NonCommercial-ShareAlike           //   //  //\n// 3.0 Unported License                                            //  //   //\n//                                                                 // //    //\n// by Val \"valalalalala\" GvM ðŸ’ƒ 2023                               ////     //\n//                                                                 ///     //\n/////////////////////////////////////////////////////////////////////     //\n//                                                                 //    //\n// Been working on a pet project to do skeletal animations, it     //   //\n// saves a json file format and I wrote a converter to create glsl //  //\n// boilerplate. Suggestions on improvements greatly appreciated.   // //\n//                                                                 ////\n//                                                                 ///\n/////////////////////////////////////////////////////////////////////\n\nfloat tTime;\n\n// set this to 0 if you have performance issues\n#define FANCY 1\n\n#define HORDE 0\n\n/////////////////////////////////////////////////////////////////////\n\nfloat bulge(vec3 p, vec3 a, vec3 b, float r1, float r2, float bulgeAt ) {\n    vec3 ab = b - a;\n    float t = saturate(dot(p - a, ab) / dot(ab, ab));\n#if FANCY    \n    float d = pow( abs( t - bulgeAt ), 2. );\n    return length((ab*t + a) - p) - mix( r1, r2, d );\n#else\n    return length((ab*t + a) - p) - r1;\n#endif\n}\n\n// small bit of sdf adapter\nfloat limb( vec3 p, vec3 a, vec3 b ) {\n    return bulge( p, a, b, .066, .0011, .33 );\n}\n\n/////////////////////////////////////////////////////////////////////\n// GENERATED {\n\nconst vec3 williams_walk4_stride = vec3( 0.601, 0.0040000000000000036, 0 );\nconst float williams_walk4_max = 0.626 * 2.2;\nconst int williams_walk4_cycle = 4; // flatten is true\nconst int williams_walk4_frames = 8;\n\nconst vec3 williams_walk4_at[8] = vec3[](vec3( -0.234, -0.918, 0), vec3( 0.387, -0.957, 0), vec3( 0.051, -0.957, 0), vec3( 0.367, -0.914, 0), vec3( -0.234, -0.918, 0), vec3( 0.387, -0.957, 0), vec3( 0.051, -0.957, 0), vec3( 0.367, -0.914, 0));\nconst vec3 williams_walk4_face[8] = vec3[](vec3( 0.113, 0.621, 0), vec3( 0.265, 0.504, 0), vec3( 0.425, 0.538, 0), vec3( 0.565, 0.586, 0), vec3( 0.113, 0.621, 0), vec3( 0.265, 0.504, 0), vec3( 0.425, 0.538, 0), vec3( 0.565, 0.586, 0));\nconst vec3 williams_walk4_crown[8] = vec3[](vec3( 0, 0.617, 0), vec3( 0.155, 0.518, 0), vec3( 0.315, 0.555, 0), vec3( 0.453, 0.586, 0), vec3( 0, 0.617, 0), vec3( 0.155, 0.518, 0), vec3( 0.315, 0.555, 0), vec3( 0.453, 0.586, 0));\nconst vec3 williams_walk4_head[8] = vec3[](vec3( 0.004, 0.44, 0), vec3( 0.141, 0.343, 0), vec3( 0.309, 0.379, 0), vec3( 0.445, 0.41, 0), vec3( 0.004, 0.44, 0), vec3( 0.141, 0.343, 0), vec3( 0.309, 0.379, 0), vec3( 0.445, 0.41, 0));\nconst vec3 williams_walk4_neck[8] = vec3[](vec3( -0.017, 0.318, 0), vec3( 0.133, 0.222, 0), vec3( 0.319, 0.257, 0), vec3( 0.438, 0.288, 0), vec3( -0.017, 0.318, 0), vec3( 0.133, 0.222, 0), vec3( 0.319, 0.257, 0), vec3( 0.438, 0.288, 0));\nconst vec3 williams_walk4_ribs[8] = vec3[](vec3( -0.013, 0.069, 0), vec3( 0.13, -0.028, 0), vec3( 0.306, 0.007, 0), vec3( 0.436, 0.039, 0), vec3( -0.013, 0.069, 0), vec3( 0.13, -0.028, 0), vec3( 0.306, 0.007, 0), vec3( 0.436, 0.039, 0));\nconst vec3 williams_walk4_rump[8] = vec3[](vec3( -0.059, -0.156, 0), vec3( 0.082, -0.253, 0), vec3( 0.3, -0.225, 0), vec3( 0.409, -0.191, 0), vec3( -0.059, -0.156, 0), vec3( 0.082, -0.253, 0), vec3( 0.3, -0.225, 0), vec3( 0.409, -0.191, 0));\nconst vec3 williams_walk4_shoulderR[8] = vec3[](vec3( -0.115, 0.302, 0.1), vec3( 0.048, 0.184, 0.1), vec3( 0.234, 0.229, 0.1), vec3( 0.434, 0.245, 0.1), vec3( 0.061, 0.26, 0.1), vec3( 0.209, 0.167, 0.1), vec3( 0.351, 0.269, 0.1), vec3( 0.405, 0.286, 0.1));\nconst vec3 williams_walk4_elbowR[8] = vec3[](vec3( -0.289, 0.177, 0.1), vec3( -0.125, 0.101, 0.1), vec3( 0.234, 0.016, 0.1), vec3( 0.472, 0.038, 0.1), vec3( 0.132, 0.059, 0.1), vec3( 0.293, -0.022, 0.1), vec3( 0.325, 0.057, 0.1), vec3( 0.306, 0.116, 0.1));\nconst vec3 williams_walk4_wristR[8] = vec3[](vec3( -0.372, -0.024, 0.1), vec3( -0.208, -0.086, 0.1), vec3( 0.297, -0.19, 0.1), vec3( 0.566, -0.152, 0.1), vec3( 0.258, -0.116, 0.1), vec3( 0.452, -0.157, 0.1), vec3( 0.36, -0.155, 0.1), vec3( 0.283, -0.09, 0.1));\nconst vec3 williams_walk4_handR[8] = vec3[](vec3( -0.434, -0.109, 0.1), vec3( -0.304, -0.125, 0.1), vec3( 0.269, -0.29, 0.1), vec3( 0.591, -0.236, 0.1), vec3( 0.335, -0.182, 0.1), vec3( 0.543, -0.198, 0.1), vec3( 0.402, -0.25, 0.1), vec3( 0.273, -0.179, 0.1));\nconst vec3 williams_walk4_fingerR[8] = vec3[](vec3( -0.512, -0.109, 0.1), vec3( -0.35, -0.112, 0.1), vec3( 0.29, -0.364, 0.1), vec3( 0.626, -0.304, 0.1), vec3( 0.384, -0.244, 0.1), vec3( 0.595, -0.258, 0.1), vec3( 0.461, -0.304, 0.1), vec3( 0.263, -0.207, 0.1));\nconst vec3 williams_walk4_hipR[8] = vec3[](vec3( 0.033, -0.229, 0.1), vec3( 0.131, -0.243, 0.1), vec3( 0.258, -0.213, 0.1), vec3( 0.351, -0.214, 0.1), vec3( -0.133, -0.215, 0.1), vec3( 0.047, -0.276, 0.1), vec3( 0.336, -0.219, 0.1), vec3( 0.473, -0.224, 0.1));\nconst vec3 williams_walk4_kneeR[8] = vec3[](vec3( 0.108, -0.52, 0.1), vec3( 0.247, -0.518, 0.1), vec3( 0.251, -0.513, 0.1), vec3( 0.37, -0.512, 0.1), vec3( -0.088, -0.511, 0.1), vec3( 0.009, -0.575, 0.1), vec3( 0.387, -0.515, 0.1), vec3( 0.536, -0.518, 0.1));\nconst vec3 williams_walk4_heelR[8] = vec3[](vec3( 0.2, -0.864, 0.1), vec3( 0.2, -0.864, 0.1), vec3( 0.2, -0.864, 0.1), vec3( 0.221, -0.812, 0.1), vec3( -0.348, -0.753, 0.1), vec3( -0.304, -0.7, 0.1), vec3( 0.034, -0.548, 0.1), vec3( 0.408, -0.707, 0.1));\nconst vec3 williams_walk4_footR[8] = vec3[](vec3( 0.302, -0.797, 0.1), vec3( 0.317, -0.864, 0.1), vec3( 0.323, -0.869, 0.1), vec3( 0.31, -0.865, 0.1), vec3( -0.305, -0.867, 0.1), vec3( -0.262, -0.809, 0.1), vec3( 0.008, -0.668, 0.1), vec3( 0.447, -0.734, 0.1));\nconst vec3 williams_walk4_toeR[8] = vec3[](vec3( 0.361, -0.766, 0.1), vec3( 0.381, -0.872, 0.1), vec3( 0.389, -0.878, 0.1), vec3( 0.378, -0.879, 0.1), vec3( -0.238, -0.87, 0.1), vec3( -0.238, -0.86, 0.1), vec3( 0.036, -0.729, 0.1), vec3( 0.478, -0.763, 0.1));\nconst vec3 williams_walk4_shoulderL[8] = vec3[](vec3( 0.061, 0.26, -0.1), vec3( 0.209, 0.167, -0.1), vec3( 0.351, 0.269, -0.1), vec3( 0.405, 0.286, -0.1), vec3( -0.115, 0.302, -0.1), vec3( 0.048, 0.184, -0.1), vec3( 0.234, 0.229, -0.1), vec3( 0.434, 0.245, -0.1));\nconst vec3 williams_walk4_elbowL[8] = vec3[](vec3( 0.132, 0.059, -0.1), vec3( 0.293, -0.022, -0.1), vec3( 0.325, 0.057, -0.1), vec3( 0.306, 0.116, -0.1), vec3( -0.289, 0.177, -0.1), vec3( -0.125, 0.101, -0.1), vec3( 0.234, 0.016, -0.1), vec3( 0.472, 0.038, -0.1));\nconst vec3 williams_walk4_wristL[8] = vec3[](vec3( 0.258, -0.116, -0.1), vec3( 0.452, -0.157, -0.1), vec3( 0.36, -0.155, -0.1), vec3( 0.283, -0.09, -0.1), vec3( -0.372, -0.024, -0.1), vec3( -0.208, -0.086, -0.1), vec3( 0.297, -0.19, -0.1), vec3( 0.566, -0.152, -0.1));\nconst vec3 williams_walk4_handL[8] = vec3[](vec3( 0.335, -0.182, -0.1), vec3( 0.543, -0.198, -0.1), vec3( 0.402, -0.25, -0.1), vec3( 0.273, -0.179, -0.1), vec3( -0.434, -0.109, -0.1), vec3( -0.304, -0.125, -0.1), vec3( 0.269, -0.29, -0.1), vec3( 0.591, -0.236, -0.1));\nconst vec3 williams_walk4_fingerL[8] = vec3[](vec3( 0.384, -0.244, -0.1), vec3( 0.595, -0.258, -0.1), vec3( 0.461, -0.304, -0.1), vec3( 0.263, -0.207, -0.1), vec3( -0.512, -0.109, -0.1), vec3( -0.35, -0.112, -0.1), vec3( 0.29, -0.364, -0.1), vec3( 0.626, -0.304, -0.1));\nconst vec3 williams_walk4_hipL[8] = vec3[](vec3( -0.133, -0.215, -0.1), vec3( 0.047, -0.276, -0.1), vec3( 0.336, -0.219, -0.1), vec3( 0.473, -0.224, -0.1), vec3( 0.033, -0.229, -0.1), vec3( 0.131, -0.243, -0.1), vec3( 0.258, -0.213, -0.1), vec3( 0.351, -0.214, -0.1));\nconst vec3 williams_walk4_kneeL[8] = vec3[](vec3( -0.088, -0.511, -0.1), vec3( 0.009, -0.575, -0.1), vec3( 0.387, -0.515, -0.1), vec3( 0.536, -0.518, -0.1), vec3( 0.108, -0.52, -0.1), vec3( 0.247, -0.518, -0.1), vec3( 0.251, -0.513, -0.1), vec3( 0.37, -0.512, -0.1));\nconst vec3 williams_walk4_heelL[8] = vec3[](vec3( -0.348, -0.753, -0.1), vec3( -0.304, -0.7, -0.1), vec3( 0.034, -0.548, -0.1), vec3( 0.408, -0.707, -0.1), vec3( 0.2, -0.864, -0.1), vec3( 0.2, -0.864, -0.1), vec3( 0.2, -0.864, -0.1), vec3( 0.221, -0.812, -0.1));\nconst vec3 williams_walk4_footL[8] = vec3[](vec3( -0.305, -0.867, -0.1), vec3( -0.262, -0.809, -0.1), vec3( 0.008, -0.668, -0.1), vec3( 0.447, -0.734, -0.1), vec3( 0.302, -0.797, -0.1), vec3( 0.317, -0.864, -0.1), vec3( 0.323, -0.869, -0.1), vec3( 0.31, -0.865, -0.1));\nconst vec3 williams_walk4_toeL[8] = vec3[](vec3( -0.238, -0.87, -0.1), vec3( -0.238, -0.86, -0.1), vec3( 0.036, -0.729, -0.1), vec3( 0.478, -0.763, -0.1), vec3( 0.361, -0.766, -0.1), vec3( 0.381, -0.872, -0.1), vec3( 0.389, -0.878, -0.1), vec3( 0.378, -0.879, -0.1));\nconst vec3 williams_walk4_chin[8] = vec3[](vec3( 0.102, 0.422, 0), vec3( 0.24, 0.333, 0), vec3( 0.414, 0.359, 0), vec3( 0.549, 0.396, 0), vec3( 0.102, 0.422, 0), vec3( 0.24, 0.333, 0), vec3( 0.414, 0.359, 0), vec3( 0.549, 0.396, 0));\n\nfloat williams_walk4_limb( vec3 p, float t, float stride, vec3 a0, vec3 a1, vec3 b0, vec3 b1 ) {\n\tvec3 o = stride * williams_walk4_stride;\n\tvec3 a = mix( a0, a1 + o, t );\n\tvec3 b = mix( b0, b1 + o, t );\n\treturn limb( p, a, b );\n}\n\nfloat williams_walk4( vec3 p, float f ) {\n#if HORDE\n\tp.xz = MODO( p.xz, 4. * williams_walk4_stride.x ); // hacked in\n#endif\n    if ( max3( abs( p ) ) > williams_walk4_max ) return williams_walk4_max;\n\n\tint f0 = int( 0. + f ) % williams_walk4_frames;\n\tint f1 = int( 1. + f ) % williams_walk4_frames;\n\tfloat t = fract( f );\n\tfloat stride = step( float( f1 % williams_walk4_cycle ), .33 );\n\tfloat d = 3e3;\n\n\td = min( d, williams_walk4_limb( p, t, stride,      williams_walk4_face[ f0 ],      williams_walk4_face[ f1 ],     williams_walk4_crown[ f0 ],     williams_walk4_crown[ f1 ] ) );\n\td = min( d, williams_walk4_limb( p, t, stride,      williams_walk4_face[ f0 ],      williams_walk4_face[ f1 ],      williams_walk4_chin[ f0 ],      williams_walk4_chin[ f1 ] ) );\n\td = min( d, williams_walk4_limb( p, t, stride,     williams_walk4_crown[ f0 ],     williams_walk4_crown[ f1 ],      williams_walk4_head[ f0 ],      williams_walk4_head[ f1 ] ) );\n\td = min( d, williams_walk4_limb( p, t, stride,      williams_walk4_chin[ f0 ],      williams_walk4_chin[ f1 ],      williams_walk4_head[ f0 ],      williams_walk4_head[ f1 ] ) );\n\td = min( d, williams_walk4_limb( p, t, stride,      williams_walk4_head[ f0 ],      williams_walk4_head[ f1 ],      williams_walk4_neck[ f0 ],      williams_walk4_neck[ f1 ] ) );\n\td = min( d, williams_walk4_limb( p, t, stride,      williams_walk4_neck[ f0 ],      williams_walk4_neck[ f1 ],      williams_walk4_ribs[ f0 ],      williams_walk4_ribs[ f1 ] ) );\n\td = min( d, williams_walk4_limb( p, t, stride,      williams_walk4_neck[ f0 ],      williams_walk4_neck[ f1 ], williams_walk4_shoulderL[ f0 ], williams_walk4_shoulderL[ f1 ] ) );\n\td = min( d, williams_walk4_limb( p, t, stride,      williams_walk4_neck[ f0 ],      williams_walk4_neck[ f1 ], williams_walk4_shoulderR[ f0 ], williams_walk4_shoulderR[ f1 ] ) );\n\td = min( d, williams_walk4_limb( p, t, stride,      williams_walk4_ribs[ f0 ],      williams_walk4_ribs[ f1 ],      williams_walk4_rump[ f0 ],      williams_walk4_rump[ f1 ] ) );\n\td = min( d, williams_walk4_limb( p, t, stride, williams_walk4_shoulderL[ f0 ], williams_walk4_shoulderL[ f1 ],    williams_walk4_elbowL[ f0 ],    williams_walk4_elbowL[ f1 ] ) );\n\td = min( d, williams_walk4_limb( p, t, stride, williams_walk4_shoulderR[ f0 ], williams_walk4_shoulderR[ f1 ],    williams_walk4_elbowR[ f0 ],    williams_walk4_elbowR[ f1 ] ) );\n\td = min( d, williams_walk4_limb( p, t, stride,      williams_walk4_rump[ f0 ],      williams_walk4_rump[ f1 ],      williams_walk4_hipL[ f0 ],      williams_walk4_hipL[ f1 ] ) );\n\td = min( d, williams_walk4_limb( p, t, stride,      williams_walk4_rump[ f0 ],      williams_walk4_rump[ f1 ],      williams_walk4_hipR[ f0 ],      williams_walk4_hipR[ f1 ] ) );\n\td = min( d, williams_walk4_limb( p, t, stride,    williams_walk4_elbowL[ f0 ],    williams_walk4_elbowL[ f1 ],    williams_walk4_wristL[ f0 ],    williams_walk4_wristL[ f1 ] ) );\n\td = min( d, williams_walk4_limb( p, t, stride,    williams_walk4_elbowR[ f0 ],    williams_walk4_elbowR[ f1 ],    williams_walk4_wristR[ f0 ],    williams_walk4_wristR[ f1 ] ) );\n\td = min( d, williams_walk4_limb( p, t, stride,      williams_walk4_hipL[ f0 ],      williams_walk4_hipL[ f1 ],     williams_walk4_kneeL[ f0 ],     williams_walk4_kneeL[ f1 ] ) );\n\td = min( d, williams_walk4_limb( p, t, stride,      williams_walk4_hipR[ f0 ],      williams_walk4_hipR[ f1 ],     williams_walk4_kneeR[ f0 ],     williams_walk4_kneeR[ f1 ] ) );\n\td = min( d, williams_walk4_limb( p, t, stride,    williams_walk4_wristL[ f0 ],    williams_walk4_wristL[ f1 ],     williams_walk4_handL[ f0 ],     williams_walk4_handL[ f1 ] ) );\n\td = min( d, williams_walk4_limb( p, t, stride,    williams_walk4_wristR[ f0 ],    williams_walk4_wristR[ f1 ],     williams_walk4_handR[ f0 ],     williams_walk4_handR[ f1 ] ) );\n\td = min( d, williams_walk4_limb( p, t, stride,     williams_walk4_kneeL[ f0 ],     williams_walk4_kneeL[ f1 ],     williams_walk4_heelL[ f0 ],     williams_walk4_heelL[ f1 ] ) );\n\td = min( d, williams_walk4_limb( p, t, stride,     williams_walk4_kneeR[ f0 ],     williams_walk4_kneeR[ f1 ],     williams_walk4_heelR[ f0 ],     williams_walk4_heelR[ f1 ] ) );\n\td = min( d, williams_walk4_limb( p, t, stride,     williams_walk4_handL[ f0 ],     williams_walk4_handL[ f1 ],   williams_walk4_fingerL[ f0 ],   williams_walk4_fingerL[ f1 ] ) );\n\td = min( d, williams_walk4_limb( p, t, stride,     williams_walk4_handR[ f0 ],     williams_walk4_handR[ f1 ],   williams_walk4_fingerR[ f0 ],   williams_walk4_fingerR[ f1 ] ) );\n\td = min( d, williams_walk4_limb( p, t, stride,     williams_walk4_heelL[ f0 ],     williams_walk4_heelL[ f1 ],     williams_walk4_footL[ f0 ],     williams_walk4_footL[ f1 ] ) );\n\td = min( d, williams_walk4_limb( p, t, stride,     williams_walk4_heelR[ f0 ],     williams_walk4_heelR[ f1 ],     williams_walk4_footR[ f0 ],     williams_walk4_footR[ f1 ] ) );\n\td = min( d, williams_walk4_limb( p, t, stride,     williams_walk4_footL[ f0 ],     williams_walk4_footL[ f1 ],      williams_walk4_toeL[ f0 ],      williams_walk4_toeL[ f1 ] ) );\n\td = min( d, williams_walk4_limb( p, t, stride,     williams_walk4_footR[ f0 ],     williams_walk4_footR[ f1 ],      williams_walk4_toeR[ f0 ],      williams_walk4_toeR[ f1 ] ) );\n\treturn d;\n}\n\n// GENERATED }\n/////////////////////////////////////////////////////////////////////\n\nMapped map( vec3 p ) {\n    p.z += 3.3;\n\n    // hacked together by hand\n    float f = iTime * 24. / float( williams_walk4_cycle );\n    p -= float( int( f ) % 32 / 4 ) * williams_walk4_stride - 3. * williams_walk4_stride;\n    \n    Mapped williams = Mapped( williams_walk4( p, f ), EINS );\n    Mapped ground = Mapped( length( p.y + .94), 2. );\n    mino( williams, ground );\n    return williams;\n}\n\nMAP_TIME\n\nfloat shadow( vec3 p, vec3 n ) {\n    vec3 toLight = normalize( V101.yzy - p );\n    Marched other = march( Ray( p - n * .001, toLight ) );\n    return other.hit ? .44 :  EINS;\n}\n\nvec3 demo( in vec2 st ) {\n    INIT_SHADER_ENVIRONMENT(st)\n    \n    tTime = triangle( iTime * .2 );\n  \n    vec3 color;\n    Ray ray = makeRay( env );\n    Marched marched = march( ray );\n    \n    vec3 t = vec3( env.trigTime.xy * .011, ZED );\n    vec3 tx = ray.dir;\n    tx.xy += .02;\n    tx.z = 0.5;\n\n    if ( marched.hit ) {\n        vec3 p = marched.p;\n        vec3 n = mapNormal( p, marched.depth );\n        float l = dot( n, -ray.dir );\n        \n        if ( EINS == marched.mapped.type ) {\n            color = l * vec3( .8, .7, .4 );\n        } else {\n            l = mix( .22, EINS, abs( l ));\n#if FANCY\n            color = vec3( l * shadow( p, n ) * texture( iChannel0, tx ).rgb * 4.4 );\n#else\n            color = vec3( l );\n#endif\n        }\n    } else {\n#if FANCY\n\n        color = texture( iChannel0, tx ).rgb * .88;\n#else\n        color = vec3( .1776 );\n#endif\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 result, in vec2 st ){    \n    result = vec4( demo( st ), 1. );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"////////////////////////////////////////////////////////////////////////////////////\n\nconst float TAU = 99733. / 15873., ZED = .0, HALB = .5, EINS = 1., PI  = HALB * TAU;\n\nconst vec3 V101 = vec3( -EINS, ZED, +EINS );\nconst vec3 V000 = vec3( ZED );\n\nconst float EPSILON = .001, ZFAR = 199., VIEW_DISTANCE = 2.5;\n\nconst vec3 MAGIC = vec3( TAU * 3.3, 99.733, 15873. );\n\n////////////////////////////////////////////////////////////////////////////////////\n\nvec2 pixelToUv( vec2 st, vec2 resolution ) {\n    return ( st * 2. - resolution.xy ) / min( resolution.x, resolution.y );\n}\n\nfloat absMod( float f, float m ) {\n    return abs( mod( f, m ) - m *.5 );\n}\n\nfloat scalo( float f, float s ) {\n    return f * s - .5 * s;\n}\n\nfloat invert( float f ) {\n    return 1. - f;\n}\n\nfloat modScale( float f, float s ) {\n    return mod( f, s ) / s;\n}\n\nfloat triangle( float x ) {\n    return 4. * abs( modScale( x, TAU ) - .5 ) -1.;\n}\n\nfloat max3( vec3 a ) {\n    return max( a.x, max( a.y, a.z ) );\n}\n\n#define saturate(x) clamp(x, ZED, EINS)\n#define SCALE_AND_OFFSET(v,o)   (o + v * o)\n#define MODO(v,f)  ( mod( v + (.5 * f), f ) - .5 * (f) )\n\n/////////////////////////////////////////////////////////////////////\n\n#define qcos( x ) triangle( x )\n#define qsin( x ) triangle( x + TAU * .25 )\n\nvec2 trig( float angle ) {\n    return vec2( cos( angle ), sin( angle ) );\n}\n\nvec3 colorF( float f ) {\n    return vec3( f, SCALE_AND_OFFSET( trig( TAU * f ), .5 ) );\n}\n\n/////////////////////////////////////////////////////////////////////\n\nvec3 order( vec3 p )  {\n    vec3 q = vec3( min( p.x, min( p.y, p.z ) ), .0, max( p.x, max( p.y, p.z ) ) );\n    q.y = ( p.x + p.y + p.z ) - ( q.x + q.z );\n    return q;  \n}\n\nfloat langth( vec3 p ) {\n    return dot( order( abs( p ) ), vec3( .2, .4, .9 ) );\n}\n\n/////////////////////////////////////////////////////////////////////\n\nbool keyToggle( int key, sampler2D keyboardChannel ) {\n    return .0 < texelFetch( keyboardChannel, ivec2(key,2), 0 ).x;\n}\n\n/////////////////////////////////////////////////////////////////////\n\nconst int MOUSE_UP = -1, MOUSE_DOWN = 1, MOUSE_CLICKED = 2;\n\nstruct ShadEnv {\n    vec3      iResolution;           // viewport resolution (in pixels) \n    float     iTime;                 // shader playback time (in seconds)\n    float     iTimeDelta;            // render time (in seconds)\n    float     iFrameRate;            // shader frame rate\n    int       iFrame;                // shader playback frame\n    float     iChannelTime[4];       // channel playback time (in seconds)\n    vec3      iChannelResolution[4]; // channel resolution (in pixels) \n    vec4      iMouse;                // mouse pixel coords. xy: current (if MLB down), zw: click\n    vec4      iDate;                 // (year, month, day, time in seconds)\n    float     iSampleRate;           // sound sample rate (i.e., 44100)\n    vec2      st;                    // aka fragCoord\n    vec2      uv;\n    vec2      ms;\n    vec2      trigTime;\n    int       mouseStatus;\n    float     pixel1;\n};\n\n#define INIT_SHADER_ENVIRONMENT(st) ShadEnv env = ShadEnv( iResolution, iTime, iTimeDelta, iFrameRate, iFrame, iChannelTime, iChannelResolution, iMouse, iDate, iSampleRate, st, V101.xy, V101.xy, V101.xy, MOUSE_UP, EINS );     init( env ); \n\nvoid init( inout ShadEnv env ) {\n    env.uv = pixelToUv( env.st, env.iResolution.xy );\n    env.trigTime = trig( env.iTime );\n    env.mouseStatus = MOUSE_UP + int( 2. * step( 3e-3, env.iMouse.z ) + step( 3e-3, env.iMouse.w ) );\n    env.ms = pixelToUv( env.iMouse.xy, env.iResolution.xy ) * step( 3e-3, env.iMouse.z + env.iMouse.w );\n    env.pixel1 = max( EINS / env.iResolution.x, EINS / env.iResolution.y ); \n}\n\n/////////////////////////////////////////////////////////////////////\n\nstruct Ray { \n    vec3 eye; \n    vec3 dir; \n};\n\nmat3 makeCamera( vec3 a, vec3 b, float roll ) {\n    vec3 up = vec3( trig( roll ).yx, ZED );\n\tvec3 z = normalize( b - a );\n\tvec3 x = normalize( cross( z, up ) );\n\tvec3 y = normalize( cross( x, z ) );\n\treturn mat3( x, y, z );\n}\n\nRay makeRay( in ShadEnv env, float depth ) {\n    vec2 t = trig( env.ms.x * PI * .125 );\n    vec3 eye = depth * vec3( t.y, sin( env.ms.y * 1.88 * .125 ), t.x );    \n   \n    //eye = depth * V101.yyz; // disable mouse look\n    \n    vec3 dir = normalize( makeCamera( eye, V000, ZED ) * vec3( env.uv, EINS ) - eye );\n    \n    return Ray( eye, dir );\n}\n\nRay makeRay( inout ShadEnv env ) {\n    return makeRay( env, VIEW_DISTANCE );\n}\n\n/////////////////////////////////////////////////////////////////////\n\nstruct Mapped {\n    float depth;\n    float type;\n};\n\nstruct Marched {\n    vec3 p;\n    float depth;\n    bool hit;\n    Mapped mapped;\n};\n\nconst int MARCH_CONTINUE = 0, MARCH_SUCCESS = 1, MARCH_FAILED = 2;\n\n///////////////////////////////////////\n\nMapped newMapped( float depth ) { return Mapped( depth, -EINS ); }\nMapped newMapped() { return newMapped( 3e11 ); }\n\nMarched newMarch( Ray ray ) {\n    return Marched( ray.eye, ZED, false, newMapped( ZED ) );\n}\n\n///////////////////////////////////////\n\nvoid mino( inout Mapped m, in Mapped q ) {\n    if ( q.depth < m.depth ) {\n        m = q;\n    }\n}\n\n///////////////////////////////////////\n\nint _marchStep( in Ray ray, in float side, inout Marched marched, Mapped mapped ) {\n    marched.mapped = mapped;\n    marched.mapped.depth *= side;\n    marched.depth += marched.mapped.depth;\n        \n    if ( abs( marched.mapped.depth ) < EPSILON ) {\n        marched.hit = true;\n        return MARCH_SUCCESS;\n    }\n        \n    if ( marched.depth > ZFAR ) return MARCH_FAILED;\n    \n    marched.p = ray.eye + marched.depth * ray.dir;\n    return MARCH_CONTINUE;\n}\nMarched _marchMissed( in Marched marched ) {\n    marched.depth = -abs( marched.depth );\n    return marched;\n}\n\n///////////////////////////////////////\n\nMapped map( vec3 p ); // implement this, then use this macro: MAP_TIME\n\n#define MAP_TIME \\\nfloat mapDepth( vec3 p ) { return map( p ).depth; } \\\nvec3 mapNormal(vec3 p,float d) {\\\n    mat3 k = mat3(p,p,p) - mat3( d * EPSILON ); \\\n    return normalize( mapDepth(p) - vec3( mapDepth(k[0]), mapDepth(k[1]), mapDepth(k[2])) ); \\\n} \\\nvec3 mapNormal(vec3 p) { return mapNormal(p,EPSILON); }\\\nMarched march( in Ray ray, in float side ) { \\\n    Marched marched = newMarch( ray ); \\\n    for( int i = 0 ; i < int( ZFAR ) ; i++ ) { \\\n        switch( _marchStep( ray, side, marched, map( marched.p ) ) ) { \\\n            case MARCH_SUCCESS: return marched; \\\n            case MARCH_FAILED: i = int(ZFAR); \\\n        } \\\n    } \\\n    return _marchMissed( marched ); \\\n} \\\nMarched march( Ray ray ) { return march( ray, EINS ); }\n\n/////////////////////////////////////////////////////////////////////","name":"Common","description":"","type":"common"}]}