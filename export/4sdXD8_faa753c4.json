{"ver":"0.1","info":{"id":"4sdXD8","date":"1459078209","viewed":123,"name":"Death Race PGATR","username":"nibaroga","description":"Project to PGATR subject, of MIGJRV\n\npress R to restart. Use arrows to move the car left or right","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["pgatr","migjrv"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_ITER = 100; // 100 is a safe number to use, it won't produce too many artifacts and still be quite fast\nconst float MAX_DIST = 20.0; // Make sure you change this if you have objects farther than 20 units away from the camera\nconst float EPSILON = 0.001; // At this distance we are close enough to the object that we have essentially hit it\n\nconst vec2 txPlayerCar\t= vec2(0.0,0.0);\nconst vec2 txEnemyCar1\t= vec2(1.0,0.0);\nconst vec2 txEnemyCar2\t= vec2(2.0,0.0);\nconst vec2 txEnemyCar3\t= vec2(3.0,0.0);\nconst vec2 txState\t\t= vec2(4.0,0.0);\n\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\n\nfloat totalDist = 0.0;\n//vec3 pos = cameraOrigin;\nfloat playerCarPositionX = 0.0;\nfloat playerCarPositionZ = 0.0;\n\n//Enemy Car 1\nfloat enemyCarPositionX = 1.5;\nfloat enemyCarPositionZ = -20.0;\n\n//Enemy Car 2\nfloat enemyCar2PositionX = -1.5;\nfloat enemyCar2PositionZ = -20.0;\n\n//Enemy Car 2\nfloat enemyCar3PositionX = 0.0;\nfloat enemyCar3PositionZ = -20.0;\n\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr);\nfloat sphere(vec3 pos, float radius);\nvec2 opU( vec2 d1, vec2 d2) ;\nvec2 rayMarch(vec3 rayOrigin, vec3 rayDirection);\nfloat sdBox( vec3 p, vec3 b );\nfloat udRoundBox( vec3 p, vec3 b, float r );\nfloat sdCylinder( vec3 p, vec2 h );\nvec2 Hash2(vec2 p);\nvec3 calcNormal( in vec3 pos );\nfloat calcAO( in vec3 pos, in vec3 nor );\nfloat cellular(in vec2 x);\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax );\nvec4 renderScene(vec3 rayOrigin, vec3 rayDir, vec2 fragCoord);\nvec2 distfunc(vec3 pos);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //playerCarPositionX = playerCarPositionX - texture( iChannel0, vec2(KEY_LEFT,0.5)).x * 1.5;\n    //playerCarPositionX = playerCarPositionX + texture( iChannel0, vec2(KEY_RIGHT,0.5)).x * 1.5;\n    \n    playerCarPositionX = texture( iChannel0, (txPlayerCar+0.5)/iChannelResolution[0].xy ).x;\n    playerCarPositionZ = 0.0;\n    \n    enemyCarPositionX = texture( iChannel0, (txEnemyCar1+0.5)/iChannelResolution[0].xy ).x;\n\tenemyCarPositionZ = texture( iChannel0, (txEnemyCar1+0.5)/iChannelResolution[0].xy ).z;\n    \n    enemyCar2PositionX = texture( iChannel0, (txEnemyCar2+0.5)/iChannelResolution[0].xy ).x;\n\tenemyCar2PositionZ = texture( iChannel0, (txEnemyCar2+0.5)/iChannelResolution[0].xy ).z;\n    \n    enemyCar3PositionX = texture( iChannel0, (txEnemyCar3+0.5)/iChannelResolution[0].xy ).x;\n\tenemyCar3PositionZ = texture( iChannel0, (txEnemyCar3+0.5)/iChannelResolution[0].xy ).z;\n    \n    vec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\n\t// camera\t\n\tvec3 rayOrigin = vec3(0.0, 1.5, 4.0);\n\tvec3 target = vec3( 0.0, 0.5, 0.0 );\n\t\n\t// camera-to-world transformation\n    mat3 camera = setCamera( rayOrigin, target, 0.0 );\n    \n    // ray direction\n\tvec3 rayDir = camera * normalize( vec3(p.xy,2.0) );\n    \n    fragColor = renderScene(rayOrigin, rayDir, fragCoord);\n    \n    //Para que las coordenadas sean entre 1, -1\n\t/*float u = fragCoord.x * 2.0 /iResolution.x - 1.0;\n\tfloat v = fragCoord.y * 2.0 /iResolution.y - 1.0;\n\tu *= iResolution.x / iResolution.y;\n    \n    //1ÂºCamara\n    mat3 cameraResults = setCamera();\n    //2Âº Calcular la direccion del rayo y su origen\n    \n    float f = 1.0;\n    \n    vec3 rayOrigin = vec3(0, 0, 0) + cameraResults[0]*f + cameraResults[1]*u + cameraResults[2]*v; //Ortografica\n    //vec3 rayDir = normalize(cross(cameraResults[1], cameraResults[2]));\n    vec3 rayDir = normalize(cameraResults[1] * u + cameraResults[2]*u + cameraResults[0]);*/\n   \n    //fragColor = background;\n    //fragColor = raymarch(rayOrigin, rayDir);\n    //fragColor = vec4(texture( iChannel0, vec2(KEY_LEFT,0.5)).z,0.0,0.0,1.0);\n}\n\n//1Âº Configurar camara\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr){\n\t\n    vec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n    \n    //Posicion\n    /*vec2 mo = iMouse.xy/iResolution.xy;\n    float time = 15.0 + iTime;\n    vec3 cameraOrigin = vec3(-0.5, 1.0, 0.5); //eye\n\t//hacia donde mira(target)\n    vec3 cameraTarget = vec3(-0.5, -0.4, 0.5); //forward\n\t//up\n    vec3 upDirection = vec3(0, 1, 0); //up\n    //Direccion de la camara\n    vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n    \n    vec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n\t//vec3 cameraRight = vec3(1,0,0);\n    vec3 cameraUp = cross(cameraDir, cameraRight);\n       \n    return mat3(cameraTarget, cameraRight, upDirection);*/\n}\n\nvec4 renderScene(vec3 rayOrigin, vec3 rayDir, vec2 fragCoord){\n\tvec4 color = vec4(0.5, 0.7, 1.0, 1.0) +rayDir.y*0.8;\n    vec2 result = rayMarch(rayOrigin, rayDir);\n    if(result.y > -0.5){\n        \n        vec3 pos = rayOrigin + result.x*rayDir;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rayDir, nor );\n        \n    \tcolor = vec4(0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(result.y-1.0) ),1.0);\n    \n    \tif( result.y<1.5 ){\n            //Quitar luego para pintar suelo\n            //float f = ceil(0.5*mod(pos.x-1.5, 0.01*iResolution.x)+0.5);\n            color = vec4(0.5,0.3,0.0,1.0);\n            //if(pos.x\n            \n        }\n        \n        if(result.y==100.0){\n        \tcolor = texture(iChannel2,\tfragCoord.xy / iResolution.xy);\n        }\n        \n        //Light\n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(0.9, 0.5, 0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rayDir),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        if(result.y > 100.0)\n        \tdom *= softshadow( pos, ref, 0.02, 2.5 );\n        \n        vec3 lin = vec3(0.0);\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\n\t\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcolor = vec4(color.xyz*lin,1.0);\n\n    \tcolor = vec4(mix( color.xyz, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*result.x*result.x ) ),1.0);\n        \n    }\n    return color;\n}\n\n//Datos para las distancias\nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.yz),p.x)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 distfunc(vec3 pos)\n{\n    vec2 result = vec2(sdPlane(pos),1.0);\n    \n    ///////PLAYER CAR\n    result = opU(result, vec2(udRoundBox(pos - vec3(playerCarPositionX, 0.4, 0.0), vec3(0.5, 0.2, 1.0), 0.05), 295.0));\n    result = opU(result, vec2(udRoundBox(pos - vec3(playerCarPositionX, 0.75, 0.1), vec3(0.4, 0.15, 0.6), 0.05), 295.0));\n    \n    result = opU(result, vec2(sdCylinder(pos - vec3(playerCarPositionX + 0.51, 0.2, 0.7),vec2(0.2, 0.05)), 225.0));\n    result = opU(result, vec2(sdCylinder(pos - vec3(playerCarPositionX - 0.51, 0.2, 0.7),vec2(0.2, 0.05)), 225.0));\n    \n    result = opU(result, vec2(sdCylinder(pos - vec3(playerCarPositionX + 0.51, 0.2, -0.7),vec2(0.2, 0.05)), 225.0));\n    result = opU(result, vec2(sdCylinder(pos - vec3(playerCarPositionX - 0.51, 0.2, -0.7),vec2(0.2, 0.05)), 225.0));\n    \n    ///////ENEMY CAR\n    //float enemy1ZPos = mod(7.0*iTime, 35.0) -30.0;\n    result = opU(result, vec2(udRoundBox(pos-vec3(enemyCarPositionX,0.4,\tenemyCarPositionZ), vec3(0.5,0.2,1.0), 0.05), 200.0));\n    result = opU(result, vec2(udRoundBox(pos-vec3(enemyCarPositionX,0.75,\tenemyCarPositionZ), vec3(0.4,0.15,0.60), 0.05), 200.0));\n    \n    result = opU(result, vec2(sdCylinder(pos-vec3(enemyCarPositionX + 0.51,0.2,enemyCarPositionZ+0.7),vec2(0.2,0.05)), 225.0));\n    result = opU(result, vec2(sdCylinder(pos-vec3(enemyCarPositionX - 0.51,0.2,enemyCarPositionZ+0.7),vec2(0.2,0.05)), 225.0));\n    \n    result = opU(result, vec2(sdCylinder(pos-vec3(enemyCarPositionX + 0.51,0.2,enemyCarPositionZ-0.7),vec2(0.2,0.05)), 225.0));\n    result = opU(result, vec2(sdCylinder(pos-vec3(enemyCarPositionX - 0.51,0.2,enemyCarPositionZ-0.7),vec2(0.2,0.05)), 225.0));\n    \n    ///////ENEMY CAR 2\n    //float enemy2ZPos = mod(7.0*(iTime)+25.0, 35.0) -30.0;\n    result = opU(result, vec2(udRoundBox(pos-vec3( enemyCar2PositionX,0.40, enemyCar2PositionZ), vec3(0.5,0.20,1.00), 0.05), 170.0));\n    result = opU(result, vec2(udRoundBox(pos-vec3( enemyCar2PositionX,0.75, enemyCar2PositionZ), vec3(0.4,0.15,0.60), 0.05), 170.0));\n    \n    result = opU(result, vec2(sdCylinder(pos-vec3(enemyCar2PositionX + 0.51,0.2,enemyCar2PositionZ+0.7),vec2(0.2,0.05)), 225.0));\n    result = opU(result, vec2(sdCylinder(pos-vec3(enemyCar2PositionX - 0.51,0.2,enemyCar2PositionZ+0.7),vec2(0.2,0.05)), 225.0));\n    \n    result = opU(result, vec2(sdCylinder(pos-vec3(enemyCar2PositionX + 0.51,0.2,enemyCar2PositionZ-0.7),vec2(0.2,0.05)), 225.0));\n    result = opU(result, vec2(sdCylinder(pos-vec3(enemyCar2PositionX - 0.51,0.2,enemyCar2PositionZ-0.7),vec2(0.2,0.05)), 225.0));\n    \n    ///////ENEMY CAR 3\n    //float enemy3ZPos = mod(7.0*(iTime)+47.0, 35.0) -30.0;\n    result = opU(result, vec2(udRoundBox(pos-vec3( enemyCar3PositionX,0.40, enemyCar3PositionZ), vec3(0.5,0.20,1.00), 0.05), 50.0));\n    result = opU(result, vec2(udRoundBox(pos-vec3( enemyCar3PositionX,0.75, enemyCar3PositionZ), vec3(0.4,0.15,0.60), 0.05), 50.0));\n    \n    result = opU(result, vec2(sdCylinder(pos-vec3(enemyCar3PositionX + 0.51,0.2,enemyCar3PositionZ+0.7),vec2(0.2,0.05)), 225.0));\n    result = opU(result, vec2(sdCylinder(pos-vec3(enemyCar3PositionX - 0.51,0.2,enemyCar3PositionZ+0.7),vec2(0.2,0.05)), 225.0));\n    \n    result = opU(result, vec2(sdCylinder(pos-vec3(enemyCar3PositionX + 0.51,0.2,enemyCar3PositionZ-0.7),vec2(0.2,0.05)), 225.0));\n    result = opU(result, vec2(sdCylinder(pos-vec3(enemyCar3PositionX - 0.51,0.2,enemyCar3PositionZ-0.7),vec2(0.2,0.05)), 225.0));\n    \n    ///////WALL RIGTH\n    \n    result = opU(result, vec2(sdBox(pos-vec3(  22.5, 0.2, -15.0), vec3(20.0,0.20,30.0)), 100.0));\n    \n    ///////WALL LEFT\n    \n    result = opU(result, vec2(sdBox(pos-vec3( -22.5, 0.2, -15.0), vec3(20.0,0.20,30.0)), 100.0));\n    \n   return result;\n}\n\n//3ÂºAlgoritmo de raymarch\nvec2 rayMarch(vec3 rayOrigin, vec3 rayDirection){\n    vec2 result = vec2(0.0,-1.0);\n    float t = 0.0;\n    float tmin = 1.0;\n    float tmax = 100.0;\n    float dist = EPSILON;\n    //float diffuse = 0.0;\n    //float specular = 0.0;\n    //vec3 lightPos = vec3(1.0,1.0,-1.0);\n\tfor (int i = 0; i < MAX_ITER; i++)\n\t{\n        vec3 rayPos = rayOrigin+rayDirection*result.x;\n        vec2 res = distfunc(rayPos);\n        if (res.x < EPSILON){\n        \tbreak;\n        }  \n        result.x += res.x;\n        result.y  = res.y;\n\t}\n    if(result.x > tmax)\n        result.y = -1.0;\n\treturn result;\n}\n\nvec2 Hash2(vec2 p)\n{\n\tfloat r = 523.0*sin(dot(p, vec2(53.3158, 43.6143)));\n\treturn vec2(fract(15.32354 * r), fract(17.25865 * r));\n}\n\n\nfloat cellular(in vec2 x){\n    vec2 parteEntera =  floor(x); //celda\n    vec2 parteDecimal = fract(x);\n    vec2 pos = x;\n    vec2 centroCelda = Hash2(parteEntera);\n    float distancia = iResolution.x;\n    for(int i=-1; i<=1; i++){\n        for(int j=-1; j<=1; j++){\n            pos = vec2(float(i),float(j));\n        \tdistancia = min(distancia, length((parteEntera + parteDecimal) - (parteEntera + pos+ Hash2(parteEntera + pos))));\n        }\n    }\n    //float distancia =  length(parteDecimal - centroCelda);\n    float elemento = smoothstep(0.0, 1.0, distancia);\n    float color = elemento;\n    return color;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = distfunc( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( EPSILON, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    distfunc(pos+eps.xyy).x - distfunc(pos-eps.xyy).x,\n\t    distfunc(pos+eps.yxy).x - distfunc(pos-eps.yxy).x,\n\t    distfunc(pos+eps.yyx).x - distfunc(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = distfunc( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nconst vec2 txPlayerCar\t= vec2(0.0,0.0);\nconst vec2 txEnemyCar1\t= vec2(1.0,0.0);\nconst vec2 txEnemyCar2\t= vec2(2.0,0.0);\nconst vec2 txEnemyCar3\t= vec2(3.0,0.0);\nconst vec2 txState\t\t= vec2(4.0,0.0);\n\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_R     = 82.5/256.0;\n\nconst float INITIAL_Z_1 = -30.0;\nconst float INITIAL_Z_2 = -50.0;\nconst float INITIAL_Z_3 = -70.0;\n\nfloat enemy1Speed = 50.0;\nfloat enemy2Speed = 60.0;\nfloat enemy3Speed = 45.0;\n\nvec4 loadValue( in vec2 re );\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord );\nvoid storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord );\n\nfloat isInside( vec2 p, vec2 c );\nfloat isInside( vec2 p, vec4 c );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 playerCarPos \t= loadValue( txPlayerCar ).xyz;\n    vec3 enemyCar1Pos \t= loadValue( txEnemyCar1 ).xyz;\n    vec3 enemyCar2Pos \t= loadValue( txEnemyCar2 ).xyz;\n    vec3 enemyCar3Pos \t= loadValue( txEnemyCar3 ).xyz;\n    float state\t\t\t= loadValue( txState ).x;\n    \n    if( iFrame == 0)\n        state = -1.0;\n    \n    if( state < -0.5){\n        state = 0.0;\n\t\tplayerCarPos.z = 0.0;\n        enemyCar1Pos.z = INITIAL_Z_1;\n        enemyCar2Pos.z = INITIAL_Z_2;\n        enemyCar3Pos.z = INITIAL_Z_3; \n        \n        playerCarPos.y = 0.0;\n        enemyCar1Pos.y = 0.4;\n        enemyCar2Pos.y = 0.4;\n        enemyCar3Pos.y = 0.4; \n        \n        playerCarPos.x = 0.0;\n        enemyCar1Pos.x = 1.5;\n    \tenemyCar2Pos.x = -1.5;\n    \tenemyCar3Pos.x = 0.0;\n    }\n    \n    if(state == 0.0){\n    \n        //enemyCar1Pos.z =  -mod(enemyCar1Pos.z + enemy1Speed, 40.0) + 20.0;\n    \t//enemyCar1Pos.z = INITIAL_Z_1 + mod(float(iFrame) * enemy1Speed, 40.0);\n        //enemyCar2Pos.z = INITIAL_Z_2 + mod(float(iFrame) * enemy2Speed, 80.0);\n        //enemyCar3Pos.z = INITIAL_Z_3 + mod(float(iFrame) * enemy3Speed, 100.0); \n        \n        enemyCar1Pos.z = mod(enemyCar1Pos.z - INITIAL_Z_1 + enemy1Speed * iTimeDelta, 60.0) + INITIAL_Z_1;\n        enemyCar2Pos.z = mod(enemyCar2Pos.z - INITIAL_Z_2 + enemy2Speed * iTimeDelta, 100.0) + INITIAL_Z_2;\n        enemyCar3Pos.z = mod(enemyCar3Pos.z - INITIAL_Z_3 + enemy3Speed * iTimeDelta, 140.0) + INITIAL_Z_3;\n        \n        \n        playerCarPos.x = clamp(playerCarPos.x - texture( iChannel1, vec2(KEY_LEFT,0.5)).x * 1.5, -1.5, 1.5);\n    \tplayerCarPos.x = clamp(playerCarPos.x + texture( iChannel1, vec2(KEY_RIGHT,0.5)).x * 1.5,-1.5, 1.5);\n    \t//enemyCar1Pos.z = mod((7.0*iTime), 35.0) -30.0;\n    \t//enemyCar2Pos.z = mod(7.0*(iTime)+25.0, 35.0) -30.0;\n    \t//enemyCar3Pos.z = mod(7.0*(iTime)+47.0, 35.0) -30.0;\n        \n        if(length( enemyCar1Pos - playerCarPos) < 1.5) state = 1.0;\n    \tif(length( enemyCar2Pos - playerCarPos) < 1.5) state = 1.0;\n        if(length( enemyCar3Pos - playerCarPos) < 1.5) state = 1.0;\n    }\n    \n    if(texture( iChannel1, vec2(KEY_R,0.5)).x > 0.5)\n        state = -1.0;\n    \n    fragColor = vec4(0.0);\n    \n    storeValue(txPlayerCar, vec4(playerCarPos, 0.0), fragColor, fragCoord );\n    storeValue(txEnemyCar1, vec4(enemyCar1Pos, 0.0), fragColor, fragCoord );\n    storeValue(txEnemyCar2, vec4(enemyCar2Pos, 0.0), fragColor, fragCoord );\n    storeValue(txEnemyCar3,\tvec4(enemyCar3Pos, 0.0), fragColor, fragCoord );\n    storeValue(txState,\tvec4(state, 0.0, 0.0, 0.0),  fragColor, fragCoord );\n}\n\nvec4 loadValue( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\nvoid storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nfloat isInside( vec2 p, vec4 c ) { vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y); }","name":"Buf A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec2 Hash2(vec2 p)\n{\n\tfloat r = 523.0*sin(dot(p, vec2(53.3158, 43.6143)));\n\treturn vec2(fract(15.32354 * r), fract(17.25865 * r));\n}\n\n\nfloat algor(in vec2 x){\n    vec2 parteEntera =  floor(x); //celda\n    vec2 parteDecimal = fract(x);\n\tfloat difuminado = 1.0; //Numero alto mas nitido\n    vec2 pos = x;\n    float value= 0.0;\n    float accum = 0.0;\n    //pos = vec2(float(x),float(y));\n    vec2 centroCelda = Hash2(parteEntera);\n    float distancia = iResolution.x;\n    for(int i=-1; i<=1; i++){\n        for(int j=-1; j<=1; j++){\n            pos = vec2(float(i),float(j));\n        \tdistancia = min(distancia, length((parteEntera + parteDecimal) - (parteEntera + pos+ Hash2(parteEntera + pos))));\n        }\n    }\n    //float distancia =  length(parteDecimal - centroCelda);\n    float elemento = smoothstep(0.0, 1.0, distancia);\n    float color = elemento;\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//iResolution = vec2(200.0,9.0);\n    vec2 p = vec2(fragCoord.x/iResolution.x, fragCoord.y/iResolution.y);\n    float resultado = algor(6.0*p); // 12 = tamaÃ±o\n\tfragColor = vec4(resultado*0.6,1.0,resultado*0.6,1.0);\n}","name":"Buf B","description":"","type":"buffer"}]}