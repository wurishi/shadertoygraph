{"ver":"0.1","info":{"id":"ldcGWr","date":"1448943409","viewed":622,"name":"Bubbles in Diamond","username":"cabbibo","description":"Bubbles in a diamond","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["refract"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// The MINIMIZED version of https://www.shadertoy.com/view/Xl2XWt\n\n\nconst float MAX_TRACE_DISTANCE = 3.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.0001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 50;\n\n\n\n// From https://www.shadertoy.com/view/XtjSRm\n// shane code\nfloat vNoise( in vec3 p )\n{\n    vec3 i  = floor(p + dot(p, vec3(0.333333)) );  p -= i - dot(i, vec3(0.166666)) ;\n    vec3 i1 = step(0., p-p.yzx), i2 = max(i1, 1.0-i1.zxy); i1 = min(i1, 1.0-i1.zxy);    \n    vec3 p1 = p - i1 + 0.166666, p2 = p - i2 + 0.333333, p3 = p - 0.5;\n    vec3 rnd = vec3(7, 157, 113); \n    vec4 v = max(0.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);\n    vec4 d = vec4( dot(i, rnd), dot(i + i1, rnd), dot(i + i2, rnd), dot(i + 1., rnd) ); \n    d = fract(sin(d)*262144.)*v*2.; \n    v.x = max(d.x, d.y), v.y = max(d.z, d.w); \n    return max(v.x, v.y); \n}\n\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos , float io ){  \n    \n    float n = vNoise( pos * 4. + vec3( 0. , iTime * .1 , 0. ) );\n \tvec2 res = vec2( io *  ( sdSphere( pos  , .6 ) + .2 * n ) , 1. ); \n  \n    if( io < 0. ){\n        \n        n = vNoise( pos * 8. - vec3( 0. , iTime , 0. ) );\n        res = opU( res ,  vec2( sdSphere( pos  , .3 ) - .1 * n  , 2. ) );\n        \n        \n    }\n    \n    return res;\n    \n    \n    \n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd , float io ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t , io );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos, in float io ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy , io).x - map(pos-eps.xyy , io).x,\n\t    map(pos+eps.yxy , io).x - map(pos-eps.yxy , io).x,\n\t    map(pos+eps.yyx , io).x - map(pos-eps.yyx , io).x );\n\treturn normalize(nor);\n}\n\n\n\n// Gets background color if nothing is hit\n// also used for refraction\nvec3 bgCol( in vec3 p ){\n \n float n = vNoise( p );\n vec3 disPos = vec3( p +  .5 *  ( sin( p.x * 10. ) + sin( p.y  * 10. ) + sin( p.z * 10.)));\n \n return vec3( n );\n    \n\n}\n\n\nvec3 render( vec2 res , vec3 ro , vec3 rd ){\n   \n\n  vec3 color = vec3( 0. );\n    \n  vec3 lightPos = vec3( 1. , 4. , 3. );\n  \n     \n  float ior = .7; // index of refraction\n  float lba = .03; // light bend amount\n    \n    \n    \n  if( res.y > -.5 ){\n      \n    vec3 pos = ro + rd * res.x;\n    vec3 norm = calcNormal( pos , 1. );\n \n    vec3 lightDir = normalize( lightPos - pos );\n    \n    float match = max( 0. , dot( lightDir , norm ));\n      \n  \tvec3 refrR = refract( rd , norm , ior * (1. - lba) );\n    vec3 refrG = refract( rd , norm , ior * 1. );\n    vec3 refrB = refract( rd , norm , ior * (1. + lba) );\n      \n   \tvec3 posR = pos + refrR * INTERSECTION_PRECISION * 1000.;\n    vec3 posG = pos + refrG * INTERSECTION_PRECISION * 1000.;\n    vec3 posB = pos + refrB * INTERSECTION_PRECISION * 1000.;\n      \n      \n    //vec3 colR = texture( iChannel0 , refrR ).xyz * vec3( 1. , 0., 0. );\n    //vec3 colG = texture( iChannel0 , refrG ).xyz * vec3( 0. , 1., 0. );\n    //vec3 colB = texture( iChannel0 , refrB ).xyz * vec3( 0. , 0., 1. );\n      \n\n      \n    float r = 0.;\n    float g = 0.;\n    float b = 0.;\n      \n      \n    vec2 resR = calcIntersection( posR , refrR , -1. );\n    vec2 resG = calcIntersection( posG , refrG , -1. );\n    vec2 resB = calcIntersection( posB , refrB , -1. );\n      \n   \n    vec3 p2 , n2 , r2;\n        \n    if( resR.y == 2. ){\n      p2 = posR + refrR * resR.x;\n      n2 = calcNormal( p2 , -1. );\n        \n      \n      r = dot( n2 , normalize(vec3( 1. , 1. , 1. )));\n    }else{\n       \n      p2 = posR + refrR * resR.x;\n      n2 = calcNormal( p2 , -1. );\n      r2 = refract( refrR , n2 , ior * (1. - lba) );\n        \n      r = bgCol(p2 + r2 * MAX_TRACE_DISTANCE ).x;\n        \n    }\n      \n    if( resG.y == 2. ){\n      \n      p2 = posG + refrG * resG.x;\n      n2 = calcNormal( p2 , -1. );\n      g = dot( n2 , normalize(vec3( 1. , 1. , 1. )));\n\n    }else{\n       \n      p2 = posG + refrG * resG.x;\n      n2 = calcNormal( p2 , -1. );\n      r2 = refract( refrG , n2 , ior * 1. );\n        \n        \n      \n      g = bgCol(p2 + r2 * MAX_TRACE_DISTANCE ).y;\n        \n    }\n      \n    if( resB.y == 2. ){\n        \n      p2 = posB + refrB * resB.x;\n      n2 = calcNormal( p2 , -1. );\n      b = dot( n2 , normalize(vec3( 1. , 1. , 1. )));\n        \n    }else{\n       \n      p2 = posB + refrB * resB.x;\n      n2 = calcNormal( p2 , -1. );\n      r2 = refract( refrB , n2 , ior * (1. + lba) );\n        \n      b = bgCol(p2 + r2 * MAX_TRACE_DISTANCE ).z;\n        \n    }\n      \n      \n    color = vec3( r , g , b );\n          \n      \n    \n    \n      \n    \n      \n      \n      \n        \n        \n  }else{\n   \n  \tcolor = bgCol( rd * MAX_TRACE_DISTANCE );\n      \n  }\n   \n  return color;\n    \n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\n\tfloat angle =  iMouse.x / iResolution.x * 2. * 3.14 ;\n    vec3 ro = vec3( cos( angle ) * 2.  , 0., sin( angle ) * 2. );\n    vec3 ta = vec3( 0. , 0. , 0. );\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    vec2 res = calcIntersection( ro , rd , 1. );\n\n\t\n    vec3 color = render( res , ro , rd );\n    \n\tfragColor = vec4(color,1.0);\n\n    \n    \n}\n","name":"","description":"","type":"image"}]}