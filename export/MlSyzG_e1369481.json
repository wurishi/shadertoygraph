{"ver":"0.1","info":{"id":"MlSyzG","date":"1509175598","viewed":285,"name":"Raymarching Rule 110","username":"dust","description":"Rule 110 instantiated into a cube field and [max()'d] against a sphere; visualised with ray-marching, modelled with SDFs. Initial configurations might not be stable, so just refresh the page/hit the \"reset time\" button if nothing shows up :)","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","cellularautomata","cellularautomaton","eca","sdfs","elementarycellularautomaton","elementarycellularautomata"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define EPS 0.0001\n\n// Computes the inverse of a given quaternion\nvec4 QtnInverse(vec4 qtn)\n{\n    return vec4(qtn.xyz * -1.0, qtn.w);\n}\n\n// Compute the product of two quaternions\nvec4 QtnProduct(vec4 qtnA, vec4 qtnB)\n{\n    vec3 vecA = qtnA.w * qtnB.xyz;\n    vec3 vecB = qtnB.w * qtnA.xyz;\n    vec3 orthoVec = cross(qtnA.xyz, qtnB.xyz);\n\n    return vec4(vecA + vecB + orthoVec,\n                 (qtnA.w * qtnB.w) - dot(qtnA.xyz, qtnB.xyz));\n}\n\n// Perform rotation by applying the given quaternion to\n// the given vector\nvec3 QtnRotate(vec3 vec, vec4 qtn)\n{\n    vec4 qv = QtnProduct(qtn, vec4(vec, 0.0));\n    return QtnProduct(qv, QtnInverse(qtn)).xyz;\n}\n\nfloat SphereDF(vec3 coord, float r)\n{\n    vec3 sphPos = vec3(0.0, 0.0, 2.0);\n    return length(coord - sphPos) - r;\n}\n\nfloat CubeDF(vec3 coord, float scale)\n{\n    vec3 cubePos = vec3(0.0, 0.0, 0.0);\n\tvec3 d = abs(coord - cubePos) - scale;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat CubeFieldDF(vec3 coord, float cubeSize)\n{\n    coord = QtnRotate(coord, vec4(normalize(vec3(1.0, 1.0, 1.0)) * sin(iTime), cos(iTime)));\n    vec3 repAxes = vec3(0.5, 0.5, 0.5);\n    float dist = CubeDF(mod(coord, repAxes) - repAxes / 2.0, cubeSize);\n    \n    if (dist < EPS)\n    {\n        // Cube is regular, with X = n, Y = n, and Z = n\n        // Centroid will be at the endpoint of a half-size cube,\n        // so vec3(n / 2, n / 2, n / 2) for a cube sitting at the\n        // global origin\n        \n        // Our cubes aren't sitting at the origin and exist in\n        // ray-relative coordinates, which means we need to account\n        // for that when we calculate the centroid\n        \n        // Generate cube-relative ray position        \n        vec3 localCoord = mod(coord,\n                              repAxes);\n                \n        // Evaluate difference between the generated local position\n        // and the cube's local centroid\n        vec3 localCentro = vec3(repAxes.x / 2.0,\n                           \t\trepAxes.x / 2.0,\n                           \t\trepAxes.x / 2.0);\n        \n        vec3 offsets = localCentro - localCoord;\n        \n        // Add offsets back into the world-space ray position to locate\n        // the world-space centroid\n        vec3 centro = coord + offsets;\n                        \n        // Extract one-dimensional integer coordinate from the known centroid\n        vec3 ecaVec = normalize(centro) * 256.0;\n        float oneDTexel = ((ecaVec.x + (ecaVec.y * 256.0)) + \n            \t\t   \t   (ecaVec.z * (256.0 * 256.0)));\n        \n        // Map onto 2D (easier than 3D->2D for me, ymmv)\n        vec2 twoDTexel = vec2(mod(oneDTexel, 256.0), oneDTexel / 256.0);\n        \n    \t// Convert to useful uvs\n    \tvec2 ecaUV = twoDTexel / vec2(256.0, 256.0);\n        \n    \t// Extract ECA texel\n    \tfloat eca = texture(iChannel0, ecaUV).x;\n        \n        // Return valid distance if the ECA texel is nonzero; return absolute doubled offsets \n        // otherwise (will force rays to step through the cube) \n    \tif (eca > 0.0)\n    \t{\n    \t\treturn dist;\n    \t}\n    \n    \telse\n    \t{\n            // Evaluating the distance to the next cube in the current ray direction is\n            // /hard/ and requires rasterizing the current cube, so force the ray-marcher to continue\n            // by returning a value slightly above the draw threshold instead\n            return EPS * 10.0;\n    \t}                \n    }\n    \n    return dist;\n}\n\nfloat DistField(vec3 coord, float sphRad, float cubeSize)\n{\n    return max(SphereDF(coord, sphRad), \n               CubeFieldDF(coord, cubeSize));\n}\n\nvec3 GetNormal(vec3 samplePoint, float eps, \n               float r, float cubeSize)\n{\n    float normXA = DistField(vec3(samplePoint.x + eps, samplePoint.y, samplePoint.z), r, cubeSize);    \n    float normXB = DistField(vec3(samplePoint.x - eps, samplePoint.y, samplePoint.z), r, cubeSize);\n    float normYA = DistField(vec3(samplePoint.x, samplePoint.y + eps, samplePoint.z), r, cubeSize);    \n    float normYB = DistField(vec3(samplePoint.x, samplePoint.y - eps, samplePoint.z), r, cubeSize);\n    float normZA = DistField(vec3(samplePoint.x, samplePoint.y, samplePoint.z + eps), r, cubeSize);    \n    float normZB = DistField(vec3(samplePoint.x, samplePoint.y, samplePoint.z - eps), r, cubeSize);\n    return normalize(vec3(normXA - normXB,\n                          normYA - normYB,\n                          normZA - normZB));\n}\n\nvec3 RayDir(float fovRads, vec2 viewSizes, vec2 pixID)\n{\n    vec2 xy = pixID - (viewSizes / 2.0);\n    float z = viewSizes.y / tan(fovRads / 2.0);\n    return normalize(vec3(xy, z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float currRayDist = 0.0;\n\tvec3 rayDir = RayDir(3.14 / 2.0, iResolution.xy, fragCoord);\n    while (currRayDist < 5.0)\n    {\n        // Define eye position + ray vector\n        vec3 eyePos = vec3(0.0, 0.0, -3.0);\n    \tvec3 rayVec = eyePos + (rayDir * currRayDist);\n        \n        // March against distance field\n        float dist = DistField(rayVec, 2.0, 0.2);\n        if (dist < EPS)\n        {   \n            float nDL = dot(GetNormal(rayVec, EPS, 2.0, 0.2), \n                            normalize(vec3(1.0, 1.0, -1.0)));\n    \t\tfragColor = vec4(1.0, 1.0, 1.0, (1.0 / nDL)) * nDL;\n\t\t\treturn;\n        }\n        \n        currRayDist += dist;\n    }\n    \n    // Draw the state of the automaton for the current pixel to the background\n    fragColor = vec4(texture(iChannel0, fragCoord / iChannelResolution[0].xy).x, 0.8, 0.8, 1.0);    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define STEPPED_ECA_ITER\n#define ITER_STEP_SIZE 1.5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord / iChannelResolution[0].xy;\n    vec2 noiseUV = fragCoord / iChannelResolution[1].xy;\n  \tif (iTime < 0.1)\n    {\n        float baseVal = texture(iChannel1, noiseUV).x;\n    \tfragColor = vec4((baseVal < 0.5), 0.0, 0.0, 0.0);   \n    }\n    \n    else\n    {\n        #ifdef STEPPED_ECA_ITER\n        if (mod(iTime * 1000.0, ITER_STEP_SIZE) == 0.0)\n        {\n        #endif\n        \t// Rule 110 generation function found here:\n\t\t\t// https://en.wikipedia.org/wiki/Elementary_cellular_automaton\n    \t\tfloat l = texture(iChannel0, uv - vec2((1.0 / iChannelResolution[0].x), 0.0)).x;\n    \t\tfloat c = texture(iChannel0, uv).x;\n    \t\tfloat r = texture(iChannel0, uv + vec2((1.0 / iChannelResolution[0].x), 0.0)).x;\n        \tfloat n = float(int(c + r + (c * r) + (l * c * r)) % 2);\n        \tfragColor = vec4(n, 0.0, 0.0, 0.0);\n        #ifdef STEPPED_ECA_ITER\n        }\n        \n        else\n        {\n            fragColor = texture(iChannel0, uv);\n        }\n        #endif        \n    }\n}","name":"Buf A","description":"","type":"buffer"}]}