{"ver":"0.1","info":{"id":"3td3z8","date":"1575820065","viewed":84,"name":"RT in 1 Weekend","username":"nicholaschuayunzhi","description":"rt in 1 wkend","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["learning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Display the buffer\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.142\n\n#define DIFFUSE   0\n#define METAL     1\n#define DIELECT   2\n#define ISOTROPIC 3\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 dir;\t\n};\n    \nstruct Camera\n{\n    vec3 posW;\n    vec3 lookAt;\n    vec3 up;\n    float fovy;\n    float aspect; // W/H\n    float near;\n};\n    \nstruct Material\n{\n    vec3 albedo;\n    int type;\n    float fuzz;\n    float n;\n};\n    \nstruct Sphere\n{\n    vec3 posW;\n    float radius;\n    Material mat;\n};\n    \nstruct Hit\n{\n    vec3 posW;\n    vec3 norm;\n    float t;\n};\n\n        \nHit TraceSphere(Ray r, Sphere s)\n{\n    vec3 oc = r.origin - s.posW;\n    float a = dot(r.dir, r.dir);\n    float b = 2.0 * dot(oc, r.dir);\n    float c = dot(oc, oc) - s.radius * s.radius;\n    float disc = b * b - 4.0 * a * c;\n    Hit h;\n    h.t = -1.0;\n    if (disc < 0.0)\n        return h;\n    h.t = (-b - sqrt(disc)) / (2.0 * a);\n    if (h.t < 0.001)\n        h.t = (-b + sqrt(disc)) / (2.0 * a);\n    h.posW = r.origin + h.t * r.dir;\n    h.norm = (h.posW - s.posW) / s.radius;\n    \n    if (h.t < 0.001)\n        h.t = -1.0;\n    return h;\n}\n\nvec3 skyColour(Ray r)\n{\n    //return mix(vec3(1.0), vec3(0.5, 0.7, 1.0), (r.dir.y + 1.0) / 2.0); \n\treturn texture(iChannel1, r.dir).xyz;\n}\n\nuint initRand(uint val0, uint val1, uint backoff)\n{\n    uint v0 = val0, v1 = val1, s0 = uint(0);\n\n    for (uint n = uint(0); n < backoff; n++)\n    {\n        s0 += uint(0x9e3779b9);\n        v0 += ((v1 << 4) + uint(0xa341316c)) ^ (v1 + s0) ^ ((v1 >> 5) + uint(0xc8013ea4));\n        v1 += ((v0 << 4) + uint(0xad90777d)) ^ (v0 + s0) ^ ((v0 >> 5) + uint(0x7e95761e));\n    }\n    return v0;\n}\n\n// Takes our seed, updates it, and returns a pseudorandom float in [0..1]\nfloat nextRand(inout uint s)\n{\n    s = (1664525u * s + 1013904223u);\n    return float(s & uint(0x00FFFFFF)) / float(0x01000000);\n}\n\nvec3 randomUnitSphere(inout uint seed)\n{\n    vec3 p;\n    do\n    {\n        p = 2.0 * vec3(nextRand(seed), nextRand(seed), nextRand(seed)) - vec3(1);\n    }\n    while (length(p) >= 1.0);\n    return p;\n}\n\nfloat schlick(float cosine, float n)\n{\n    float r0 = (1.0 - n) / (1.0 + n);\n    r0 = r0 * r0;\n    return r0 + (1.0 - r0) * pow(1.0 - cosine, 5.0);\n}\n\n\nvec3 TraceWorld(Ray r, int depth, uint seed)\n{\n    Sphere spheres[5];\n    spheres[0].posW = vec3(0.0, 0.0, 1.0);\n    spheres[0].radius = 0.5;\n    spheres[0].mat.albedo = vec3(0.5, 0.1, 0.3);\n    \n    spheres[1].posW = vec3(0.0, -100.5, 1.0);\n    spheres[1].radius = 100.0;\n    spheres[1].mat.albedo = vec3(0.7, 0.8, 0.2);\n    \n    spheres[2].posW = vec3(1.0, 0.4, 1.0);\n    spheres[2].radius = 0.5;\n    spheres[2].mat.albedo = vec3(0.4, 0.5, 0.5);\n    spheres[2].mat.type = METAL;\n    spheres[2].mat.fuzz = 0.5;\n     \n    spheres[3].posW = vec3(-0.5, -0.1, -0.1);\n    spheres[3].radius = 0.3;\n    spheres[3].mat.albedo = vec3(1.0);\n    spheres[3].mat.type = DIELECT;\n    spheres[3].mat.n = 2.;\n    \n    spheres[4].posW = vec3(0.5, -0.1, -0.1);\n    spheres[4].radius = 0.3;\n    spheres[4].mat.albedo = vec3(1.0);\n    spheres[4].mat.type = ISOTROPIC;\n    spheres[4].mat.n = 2.;\n    \n    vec3 col = vec3(1.0);\n    for (int i = 0; i < depth; ++i)\n    {\n        Hit h;\n        h.t = -1.0;\n        vec3 alb = vec3(1.0);\n        Material mat;\n        for (int j = 0; j < 5; ++j)\n        {\n            Hit h1 = TraceSphere(r, spheres[j]);\n        \tif (h1.t >= 0.0 && (h.t < 0.0 || h1.t < h.t))\n            {\n                h = h1;\n                alb = spheres[j].mat.albedo;\n                mat = spheres[j].mat;\n            }\n        }\n        \n       \tif (h.t < 0.0)\n        {\n            col *= skyColour(r);\n            break;\n        }\n        \n        r.origin = h.posW;\n        \n        if (mat.type == DIFFUSE)\n        {\n        \tr.dir = normalize(h.norm + randomUnitSphere(seed));\n        }\n       \telse if (mat.type == METAL)\n        {\n        \tr.dir = reflect(r.dir, h.norm) + mat.fuzz * randomUnitSphere(seed);\n        }\n        else if (mat.type == DIELECT)\n        {\n            float niOverNt = 1.0 / mat.n;\n            float n = 1.0;\n            float cosine = -dot(r.dir, h.norm) / length(r.dir);\n            vec3 norm = h.norm;\n            \n            if (dot(r.dir, h.norm) > 0.0)\n            {\n                norm = -h.norm;\n                niOverNt = mat.n;\n                n = mat.n;\n                cosine = mat.n * dot(r.dir, h.norm) / length(r.dir);\n            }\n            vec3 refracted = refract(normalize(r.dir), normalize(norm), niOverNt);\n                \n            if (length(refracted) > 0.001)\n            {\n                float reflectProb = schlick(cosine, mat.n);\n                if (nextRand(seed) <= reflectProb)\n                {\n                    r.dir = reflect(r.dir, h.norm);\n                }\n                else\n                {\n                    r.dir = refracted;\n                }\n            }\n            else\n            {\n            \tr.dir = reflect(r.dir, norm);\n            }\n        }\n        else if (mat.type == ISOTROPIC)\n        {\n            if (dot(r.dir, h.norm) > 0.0)\n            {\n                float dist = distance(r.dir, r.origin);\n              \tfloat hitDist = -(1.0/0.8) * log(nextRand(seed));\n                if (hitDist < dist)\n                {\n                    r.origin = r.origin - hitDist * r.dir;\n                \tr.dir = randomUnitSphere(seed);\n                    alb = vec3(0.6, 0.6, 0.3);\n                }\n            } \n        }\n       \t\n        col *= alb;\n        \n        if (i == depth - 1)\n            col = vec3(0.0);\n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Camera cam;\n    cam.up = vec3(0, 1, 0);\n    cam.fovy = 90.0;\n    cam.aspect = iResolution.x / iResolution.y;\n    cam.near = 3.0;\n    \n    cam.posW = vec3(0, 0, -2);\n    cam.lookAt = vec3(0, 0, 1);\n    \n    float fovyRad = cam.fovy * PI / 180.0;\n    float halfHeight = tan(fovyRad / 2.0);\n    float halfWidth = cam.aspect * halfHeight;\n    \n    // to investigate cross product\n    vec3 viewDir = normalize(cam.lookAt - cam.posW);\n    vec3 right = normalize(cross(cam.up, cam.lookAt));\n    vec3 up = cross(viewDir, right);\n          \n    uint seed = initRand(uint(fragCoord.x + fragCoord.y * fragCoord.x), uint(iFrame), uint(16));\n    \n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n\tRay ray;\n    ray.origin = cam.posW;\n    vec2 st = uv * vec2(halfWidth, halfHeight);\n    vec2 jitter = (vec2(nextRand(seed), nextRand(seed)) - vec2(0.5));\n    st += jitter / 100.0; // hack\n    vec3 pixelPosW = ray.origin + viewDir * cam.near + st.x * right + st.y * up;\n \n    ray.dir = normalize(pixelPosW - ray.origin);\n    \n    vec3 old = texture(iChannel0, fragCoord/iResolution.xy).xyz; \n    float frame = float(iFrame);\n   \tvec3 new = TraceWorld(ray, 20, seed); //overflow\n    if (frame > 1.0)\n    \tfragColor.xyz = ((frame - 1.0) * old + new) / frame;\n    else\n        fragColor.xyz = new;\n}","name":"Buffer A","description":"","type":"buffer"}]}