{"ver":"0.1","info":{"id":"McG3WW","date":"1712761237","viewed":336,"name":"[zznewclear13] Tonemapping","username":"zznewclear13","description":"Comparison of different tonemappings. Press \"r\" to reset accumulation.\n\nBottom left: no tonemapping\nTop left: PBR neutral tonemapping\nBottom right: ACES tonemapping\nTop right: AgX tonemapping","likes":20,"published":1,"flags":48,"usePreview":0,"tags":["tonemapping","colorchecker","aces","agx","pbrneutral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// [zznewclear13] Tonemapping\n// https://www.shadertoy.com/view/McG3WW\n// Comparison of different tonemappings. Press \"r\" to reset accumulation.\n\n// Bottom left: no tonemapping\n// Top left: PBR neutral tonemapping\n// Bottom right: ACES tonemapping\n// Top right: AgX tonemapping\n\n// Disclaimer:\n// I am not an expert in color management, I merely just copy and paste stuffs.\n// The purpose is to test different tonemappings for my path tracing renderer.\n// All credit to links below and use at your own risk.\n\n\n\n// ACES\n// Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 tonemapping_ACES(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\n// AgX\n// https://github.com/sobotka/AgX\n// https://www.shadertoy.com/view/cd3XWr\n\n// Mean error^2: 3.6705141e-06\nvec3 agxDefaultContrastApprox(vec3 x) {\n    vec3 x2 = x * x;\n    vec3 x4 = x2 * x2;\n  \n    return + 15.5     * x4 * x2\n           - 40.14    * x4 * x\n           + 31.96    * x4\n           - 6.868    * x2 * x\n           + 0.4298   * x2\n           + 0.1191   * x\n           - 0.00232;\n}\n\nvec3 agx(vec3 val) {\n    const mat3 agx_mat = mat3(\n        0.842479062253094, 0.0423282422610123, 0.0423756549057051,\n        0.0784335999999992,  0.878468636469772,  0.0784336,\n        0.0792237451477643, 0.0791661274605434, 0.879142973793104);\n        \n    const float min_ev = -12.47393f;\n    const float max_ev = 4.026069f;\n    \n    // Input transform\n    val = agx_mat * val;\n      \n    // Log2 space encoding\n    val = clamp(log2(val), min_ev, max_ev);\n    val = (val - min_ev) / (max_ev - min_ev);\n      \n    // Apply sigmoid function approximation\n    val = agxDefaultContrastApprox(val);\n    \n    return val;\n}\n\nvec3 agxEotf(vec3 val) {\n    const mat3 agx_mat_inv = mat3(\n        1.19687900512017, -0.0528968517574562, -0.0529716355144438,\n        -0.0980208811401368, 1.15190312990417, -0.0980434501171241,\n        -0.0990297440797205, -0.0989611768448433, 1.15107367264116);\n        \n    // Undo input transform\n    val = agx_mat_inv * val;\n    \n    // I enabled this line to do linear to srgb in line 180 for all tonemappings.\n    // sRGB IEC 61966-2-1 2.2 Exponent Reference EOTF Display   \n    val = pow(val, vec3(2.2));\n    \n    return val;\n}\n\nvec3 agxLook(vec3 val) {\n    const vec3 lw = vec3(0.2126, 0.7152, 0.0722);\n    float luma = dot(val, lw);\n    \n    // Default look\n    vec3 offset = vec3(0.0);\n    vec3 slope = vec3(1.0);\n    vec3 power = vec3(1.0, 1.0, 1.0);\n    float sat = 1.0;\n    \n    // ASC CDL\n    val = pow(val * slope + offset, power);\n    return luma + sat * (val - luma);\n}\n\nvec3 tonemapping_AgX(vec3 color)\n{\n    color = agx(color);\n    color = agxLook(color);\n    color = agxEotf(color);\n    return color;\n}\n\n// PBR Neutral\n// https://modelviewer.dev/examples/tone-mapping\nconst float startCompression = 0.8 - 0.04;\nconst float desaturation = 0.15; \n\nvec3 tonemapping_PBR_Neutral(vec3 color)\n{\n    float x = min(color.r, min(color.g, color.b));\n    float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n    color -= offset;\n\n    float peak = max(color.r, max(color.g, color.b));\n    if (peak < startCompression) return color;\n\n    float d = 1. - startCompression;\n    float newPeak = 1. - d * d / (peak + d - startCompression);\n    color *= newPeak / peak;\n\n    float g = 1. - 1. / (desaturation * (peak - newPeak) + 1.);\n    return mix(color, newPeak * vec3(1, 1, 1), g);\n}\n\n// Uncharted tonemapping\n// http://filmicworlds.com/blog/filmic-tonemapping-operators/\n// https://www.gdcvault.com/play/1012351/Uncharted-2-HDR\n\nconst float A = 0.15;\nconst float B = 0.50;\nconst float C = 0.10;\nconst float D = 0.20;\nconst float E = 0.02;\nconst float F = 0.30;\nconst float W = 11.2;\n\nvec3 tonemapping_Uncharted(vec3 color)\n{\n    // I modified exposure bias to make it look brighter.\n    float ExposureBias = 3.0f; //2.0f\n    vec3 x = ExposureBias * color;\n    vec3 curr = ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n    vec3 whiteScale = vec3(1.0f/(((W*(A*W+C*B)+D*E)/(W*(A*W+B)+D*F))-E/F));\n    return curr*whiteScale;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iFragCoord = ivec2(fragCoord);\n    vec3 bufferA = texelFetch(iChannel0, iFragCoord, 0).rgb;\n    vec3 acesBufferA = tonemapping_ACES(bufferA);\n    vec3 agxBufferA = tonemapping_AgX(bufferA);\n    vec3 pbrNeutralBufferA = tonemapping_PBR_Neutral(bufferA);\n    vec3 unchartedBufferA = tonemapping_Uncharted(bufferA);\n    // bufferA = unchartedBufferA;  \n    \n    vec2 mouseCoord = iResolution.xy * 0.5f;\n    if (iMouse.z > 0.0f) mouseCoord = iMouse.xy;\n    \n    ivec2 iMouseCoord = ivec2(mouseCoord);\n    if (any(equal(iMouseCoord, iFragCoord)))\n    {\n        fragColor = vec4(0.0f, 0.0f, 0.0f, 1.0f);\n        return;\n    }\n    \n    // no tonemapping: bottom left\n    // pbr neutral: top left\n    // aces: buttom right\n    // agx: top right\n    vec2 weight = step(mouseCoord, fragCoord);      \n    vec3 color = mix(mix(bufferA, acesBufferA, weight.x),\n                     mix(pbrNeutralBufferA, agxBufferA, weight.x),\n                     weight.y);\n    color = pow(color, vec3(0.4545f));\n    \n    fragColor = vec4(color, 1.0f);    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Uncomment this line to use isotropic vndf importance sampling.\n// But it adds fireflies to my render, not sure if I did it right.\n// See line 198 and line 269.\n// #define VNDF_IMPORTANCE_SAMPLING_AN_ISOTROPIC_DISTRIBUTION\n\nQuad lights[1];\nQuad quads[7];\nSphere spheres[2];\nMaterialInput materials[8];\n\n// https://www.researchgate.net/figure/Layout-of-the-Color-Checker-Chart-Used-with-Known-RGB-Values-24-This-figure-provides_fig1_372038692\nvec3 colorChecker[24] = vec3[24]\n(\n    vec3(0.451,0.318,0.267),\n    vec3(0.753,0.588,0.510),\n    vec3(0.384,0.478,0.616),\n    vec3(0.341,0.424,0.263),\n    vec3(0.522,0.502,0.694),\n    vec3(0.404,0.741,0.667),\n    \n    vec3(0.839,0.494,0.172),\n    vec3(0.314,0.357,0.651),\n    vec3(0.757,0.353,0.388),\n    vec3(0.369,0.235,0.424),\n    vec3(0.616,0.737,0.251),\n    vec3(0.878,0.639,0.180),\n    \n    vec3(0.220,0.251,0.588),\n    vec3(0.274,0.580,0.286),\n    vec3(0.686,0.212,0.235),\n    vec3(0.906,0.780,0.122),\n    vec3(0.733,0.337,0.584),\n    vec3(0.031,0.522,0.631),\n    \n    vec3(0.953),\n    vec3(0.784),\n    vec3(0.627),\n    vec3(0.478),\n    vec3(0.333),\n    vec3(0.204)\n);\n\nvoid MakeScene()\n{\n    quads[0] = Quad(1, vec3(-6.0, 0.0, -6.0), vec3(0.0, 0.0, 12.0), vec3(12.0, 0.0, 0.0));\n    quads[1] = Quad(2, vec3(-6.0, 10.0, -6.0), vec3(12.0, 0.0, 0.0), vec3(0.0, 0.0, 12.0));\n    quads[2] = Quad(3, vec3(-6.0, 0.0, -6.0), vec3(0.0, 10.0, 0.0), vec3(0.0, 0.0, 12.0));\n    quads[3] = Quad(4, vec3(6.0, 0.0, -6.0), vec3(0.0, 0.0, 12.0), vec3(0.0, 10.0, 0.0));\n    quads[4] = Quad(2, vec3(-6.0, 0.0, 6.0), vec3(0.0, 10.0, 0.0), vec3(12.0, 0.0, 0.0));\n    quads[5] = Quad(5, vec3(-4.0, 4.0, 5.8), vec3(0.0, 5.0, 0.0), vec3(8.0, 0.0, 0.0));\n    \n    spheres[0] = Sphere(6, vec3(2.5, 2.0, 0.0), 2.0);\n    spheres[1] = Sphere(7, vec3(-2.5, 2.0, 0.0), 2.0);\n    \n    lights[0] = Quad(0, vec3(-2.0, 9.8, -2.0), vec3(4.0, 0.0, 0.0), vec3(0.0, 0.0, 4.0));\n    quads[6] = lights[0];\n    \n    materials[0] = InitMaterialInput(0, vec4(5.0f, 5.0f, 5.0f, 1.0f), 0.0f, 0.0f);\n    materials[1] = InitMaterialInput(2, vec4(0.85f, 0.85f, 0.85f, 1.0f), 0.8f, 0.0f);\n    materials[2] = InitMaterialInput(1, vec4(0.88f, 0.88f, 0.88f, 1.0f), 0.9f, 0.0f);\n    materials[3] = InitMaterialInput(1, vec4(1.00f, 0.00f, 0.00f, 1.0f), 0.9f, 0.0f);\n    materials[4] = InitMaterialInput(1, vec4(0.00f, 1.00f, 0.00f, 1.0f), 0.9f, 0.0f);\n    materials[5] = InitMaterialInput(3, vec4(1.00f, 1.00f, 1.00f, 1.0f), 1.0f, 0.0f);\n    materials[6] = InitMaterialInput(1, vec4(1.00f, 0.74f, 0.15f, 1.0f), 0.4f, 0.95f);\n    materials[7] = InitMaterialInput(1, vec4(0.98f, 0.98f, 0.98f, 1.0f), 0.8f, 0.0f);\n}\n\n///////////////////////////////////////////////////\n//             Scene Related Tracing             //\n///////////////////////////////////////////////////\n\nbool TraceScene(Ray ray, out Intersection intersection, out int materialID)\n{\n    float d = INFINITY;\n    bool hasHit = false;\n    for(int i = min(0, iFrame); i < quads.length(); i++)\n    {\n        float t;\n        Intersection tempIntersection;\n        bool isHit = RayQuadIntersect(ray, quads[i], t, tempIntersection);\n        if(isHit && t < d)\n        {\n            d = t;\n            hasHit = true;\n            \n            materialID = quads[i].materialID;\n            intersection = tempIntersection;\n        }\n    }\n    \n    for(int i = min(0, iFrame); i < spheres.length(); i++)\n    {\n        float t;\n        Intersection tempIntersection;\n        bool isHit = RaySphereIntersect(ray, spheres[i], t, tempIntersection);\n        if(isHit && t < d)\n        {\n            d = t;\n            hasHit = true;\n            \n            materialID = spheres[i].materialID;\n            intersection = tempIntersection;\n        }\n    }\n\n    return hasHit;\n}\n\nbool TraceLight(Ray ray, int lightMaterialID)\n{\n    float d = INFINITY;\n    int materialID = -1;\n    for(int i = min(0, iFrame); i < quads.length(); i++)\n    {\n        float t;\n        Intersection tempIntersection;\n        bool isHit = RayQuadIntersect(ray, quads[i], t, tempIntersection);\n        if(isHit && t < d)\n        {\n            d = t;\n            \n            materialID = quads[i].materialID;\n        }\n    }\n    \n    for(int i = min(0, iFrame); i < spheres.length(); i++)\n    {\n        float t;\n        Intersection tempIntersection;\n        bool isHit = RaySphereIntersect(ray, spheres[i], t, tempIntersection);\n        if(isHit && t < d)\n        {\n            d = t;\n            \n            materialID = spheres[i].materialID;\n        }\n    }\n\n    return materialID == lightMaterialID;\n}\n\nvec3 GetBackgroundColor(vec3 rd)\n{\n    return pow(texture(iChannel0, normalize(rd)).rgb, vec3(2.2f));\n}\n\n// https://iquilezles.org/articles/checkerfiltering/\nfloat Checkers(vec2 p)\n{\n    vec2 s = sign(fract(p*.5)-.5);\n    return .5 - .5*s.x*s.y;\n}\n\n/////////////////////////////////////////\n//              Sampling               //\n/////////////////////////////////////////\n\nvec3 SampleHemiSphere(vec2 rv)\n{\n    float theta = acos(rv.x);\n    float phi = 2.0 * PI * rv.y;\n    float sinTheta = sin(theta);\n\n    return vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cos(theta));\n}\n\nvec3 SampleHemiSphereGGX(vec2 rv, float roughness)\n{\n    float theta = acos(sqrt((1.0 - rv.x) / ((roughness * roughness - 1.0) * rv.x + 1.0)));\n    float phi = 2.0 * PI * rv.y;\n    float sinTheta = sin(theta);\n    \n    return vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cos(theta));\n}\n\n// Sampling Visible GGX Normals with Spherical Caps, Jonathan Dupuy 2023\nvec3 SampleVndf_SphericalCaps(vec2 rv, vec3 wi)\n{\n    float phi = 2.0f * PI * rv.x;\n    float z = (1.0f - rv.y) * (1.0f + wi.z) - wi.z;\n    float sinTheta = sqrt(clamp(1.0f - z * z, 0.0f, 1.0f));\n    float x = sinTheta * cos(phi);\n    float y = sinTheta * sin(phi);\n    vec3 c = vec3(x, y, z);\n    vec3 h = c + wi;\n    return h;\n}\n\nvec3 SampleVNDF_GGX(vec2 rv, vec3 viewTS, float roughness)\n{\n    vec3 wiStd = normalize(vec3(viewTS.xy * roughness, viewTS.z));\n    vec3 wmStd = SampleVndf_SphericalCaps(rv, wiStd);\n    vec3 wm = normalize(vec3(wmStd.xy * roughness, wmStd.z));\n    return wm;\n}\n\n// https://auzaiffe.wordpress.com/2024/04/15/vndf-importance-sampling-an-isotropic-distribution/\nvec3 SampleVNDF_GGX_Isotropic(vec2 rv, vec3 wi, float roughness, vec3 normal)\n{\n    vec3 wi_z = -normal * dot(wi, normal);\n    vec3 wi_xy = wi + wi.z;\n    \n    vec3 wiStd = -normalize(roughness * wi_xy + wi_z);\n    \n    float wiStd_z = dot(wiStd, normal);\n    float z = 1.0f - rv.y * (1.0f + wiStd_z);\n    float sinTheta = sqrt(clamp(1.0f - z * z, 0.0f, 1.0f));\n    float phi = 2.0f * PI * rv.x - PI;\n    float x = sinTheta * cos(phi);\n    float y = sinTheta * sin(phi);\n    vec3 cStd = vec3(x, y, z);\n    \n    vec3 up = vec3(0.0f, 0.0f, 1.00001f);\n    vec3 wr = normal + up;\n    vec3 c = dot(wr, cStd) * wr / wr.z - cStd;\n    \n    vec3 wmStd = c + wiStd;\n    vec3 wmStd_z = normal * dot(normal, wmStd);\n    vec3 wmStd_xy = wmStd_z - wmStd;\n    \n    return normalize(roughness * wmStd_xy + wmStd_z);\n}\n\nRay GetRandomRay(vec2 rv, vec3 lastRayDir, vec3 position, vec3 normal)\n{\n    Ray ray;\n    \n    vec3 s = SampleHemiSphere(rv);\n    s.z = abs(s.z);\n    \n    vec3 w = normal;\n    vec3 u, v;\n    if(abs(dot(normal, vec3(0.0, 1.0, 0.0))) <= SQRT2_2)\n    {\n        u = normalize(cross(vec3(0.0, 1.0, 0.0), w));\n        v = cross(w, u);\n    }\n    else\n    {\n        v = normalize(cross(w, vec3(1.0, 0.0, 0.0)));\n        u = cross(v, w);\n    }\n    ray.direction = s.x * u + s.y * v + s.z * w;\n    ray.origin = position + ray.direction * EPSILON;\n    \n    return ray;    \n}\n\nRay GetRandomRay_GGX(vec3 rv, vec3 lastRayDir, vec3 position, vec3 normal, float roughness, float t)\n{\n    Ray ray;\n\n    vec3 w = normal;\n    vec3 s, u, v;\n    \n    if(abs(dot(normal, vec3(0.0, 1.0, 0.0))) <= SQRT2_2)\n    {\n        u = normalize(cross(vec3(0.0, 1.0, 0.0), w));\n        v = cross(w, u);\n    }\n    else\n    {\n        v = normalize(cross(w, vec3(1.0, 0.0, 0.0)));\n        u = cross(v, w);\n    }\n\n    if(rv.x < t)\n    {\n#if defined(VNDF_IMPORTANCE_SAMPLING_AN_ISOTROPIC_DISTRIBUTION)\n        // https://auzaiffe.wordpress.com/2024/04/15/vndf-importance-sampling-an-isotropic-distribution/\n        s = SampleVNDF_GGX_Isotropic(rv.yz, -lastRayDir, roughness, normal);\n        ray.direction = reflect(lastRayDir, s);\n#else\n        //Sample specular, half vector.\n        mat3 tangnetToWorld = mat3(u, v, w);\n        vec3 viewTS = (-lastRayDir) * tangnetToWorld; // Notice the order of multiplication.\n        s = SampleVNDF_GGX(rv.yz, viewTS, roughness);\n        s.z = abs(s.z);\n        vec3 halfVec = s.x * u + s.y * v + s.z * w;\n        ray.direction = reflect(lastRayDir, halfVec);\n#endif\n    }\n    else\n    {\n        //Sample diffuse, sample vector;\n        s = SampleHemiSphere(rv.yz);\n        s.z = abs(s.z);\n        ray.direction = s.x * u + s.y * v + s.z * w;\n    }\n\n    ray.origin = position + ray.direction * EPSILON;\n\n    return ray;\n}\n\nRay GetRandomRay_NEE(vec2 rv, Quad light, vec3 position, vec3 normal, out float dist)\n{\n    vec3 lightTarget = light.p + light.w * rv.x + light.l * rv.y;\n\n    vec3 lightOrigin = position + normal * EPSILON;\n    vec3 lightDirection = normalize(lightTarget - lightOrigin);\n\n    Ray lightRay = Ray(lightOrigin, lightDirection);\n    dist = length(lightTarget - lightRay.origin);\n    return lightRay;\n}\n\n/////////////////////////////////////////\n//               PDFs                  //\n/////////////////////////////////////////\n\nfloat PDF_Lambert(vec3 wi, vec3 normal){\n    return INV_PI * max(dot(normal, wi), 0.0);\n}\n\nfloat PDF_GGX(vec3 wi, vec3 wo, vec3 normal, float roughness)\n{\n    vec3 h = normalize(wi + wo);\n    float NdotH = max(dot(normal, h), 0.0);\n    \n    return D_GGX(NdotH, roughness) * NdotH / (4.0 * max(dot(wo, h), EPSILON));\n}\n\nfloat PDF_VNDF(vec3 wi, vec3 wo, vec3 normal, float roughness)\n{\n    vec3 h = normalize(wi + wo);\n    float NoH = max(dot(normal, h), 0.0f);\n    float NoV = max(dot(normal, wo), 1e-5f);\n    \n    // Many terms are cancelled.\n    float a2 = roughness * roughness;\n    float G1 = 0.5f / (NoV + sqrt(NoV * NoV * (1.0f - a2) + a2));\n    return D_GGX(NoH, roughness) * G1;\n}\n\nfloat PDF_Quad(Quad light, Ray ray)\n{\n    vec3 lightNormal = cross(light.w, light.l);\n    float area = length(lightNormal);\n    lightNormal = normalize(lightNormal);\n    float LNoL = dot(lightNormal, -ray.direction);\n    if(LNoL <= 0.0f) return 0.0f;\n    \n    float t;\n    Intersection intersection;\n    bool hasIntersect = RayQuadIntersect(ray, light, t, intersection);\n    if(!hasIntersect) return 0.0f;\n    \n    return t * t / (area * LNoL); \n}\n\nfloat PDF_NEE(Ray ray)\n{\n    float pdfNEE = 0.0;\n    for (int i = min(0, iFrame); i < lights.length(); i++)\n    {\n        float pdfLight = PDF_Quad(lights[i], ray);\n        pdfNEE += pdfLight;\n    }\n    return pdfNEE / float(lights.length());\n}\n\nfloat PDF_BRDF(vec3 wi, vec3 wo, vec3 normal, float roughness, float t)\n{\n    return (1.0 - t) * PDF_Lambert(wi, normal) + t * PDF_VNDF(wi, wo, normal, roughness);  \n}\n\nvoid WeightPDF(Ray ray, vec3 wo, vec3 normal, float roughness, float t, out float weightNEE, out float weightBRDF)\n{\n    float pdfNEE = PDF_NEE(ray);\n    float pdfBRDF = PDF_BRDF(ray.direction, wo, normal, roughness, t);\n    \n    float squareSum = pdfNEE * pdfNEE + pdfBRDF * pdfBRDF;\n    if(squareSum == 0.0)\n    {\n        weightNEE = 1.0;\n        weightBRDF = 0.0;\n    }\n    else\n    {\n        weightNEE = pdfNEE / squareSum;\n        weightBRDF = pdfBRDF / squareSum;\n    }\n}\n\n/////////////////////////////////////////\n//              Evaluate               //\n/////////////////////////////////////////\n\nvec3 EvaluateBRDF(SurfaceInput si, MaterialInput mi)\n{\n    vec3 fr = Fr(si.NoV, si.NoL, si.NoH, si.LoH, mi.roughness, mi.specular);    \n    vec3 fd = Fd_Burley(si.NoV, si.NoL, si.LoH, mi.roughness) * mi.diffuse;    \n    return (fr + fd) * si.NoL;\n}\n\n///////////////////////////////////////////////////\n//                Main Function                  //\n///////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0)\n    {\n        fragColor = vec4(0.0f); return;\n    }\n\n    uvec2 iFragCoord = uvec2(fragCoord);\n    seed = pcg3d(uvec3(iFrame, iFragCoord.x, iFragCoord.y)).x;\n \n    MakeScene();\n    Camera camera = Camera(vec3(0.0f, 4.0f, -12.0f), vec3(0.0f, 4.0f, 0.0f), vec3(0.0f, 1.0f, 0.0f), 45.0f);  \n    Ray ray = InitRay(vec2(GetRandom(), GetRandom()), camera, fragCoord, iResolution.xy);\n    \n    vec3 color = vec3(0.0f);\n    vec3 lastBRDF = vec3(1.0f);\n    Intersection intersection;\n    int depth = 0;\n\n    while(depth < 10)\n    {\n        int materialID;\n        bool isHit = TraceScene(ray, intersection, materialID);      \n        if(!isHit)\n        {\n            color += lastBRDF * GetBackgroundColor(ray.direction);\n            break;\n        }\n        \n        MaterialInput mi = materials[materialID];      \n        if(mi.materialType == 0)\n        {\n            float frontLight = dot(intersection.normal, -ray.direction) > 0.0f ? 1.0f : 0.0f;\n            color += lastBRDF * mi.diffuse * frontLight;\n            break;\n        }\n        else if(mi.materialType == 2)\n        {\n            mi.diffuse = vec3(mix(0.2f, 0.95f, Checkers(intersection.uv * 10.0f)));\n        }\n        else if(mi.materialType == 3)\n        {\n            vec2 uv = intersection.uv;\n            vec2 fracUV = abs(fract(uv * vec2(4.0f, 6.0f)) - 0.5f);\n            int index = int(uv.y * 6.0f) + int((1.0f - uv.x) * 4.0f) * 6;\n            vec3 checkerColor = colorChecker[index];\n            mi.diffuse = vec3(0.0f);\n            \n            if (all(lessThanEqual(fracUV, vec2(0.45f)))) mi.diffuse = pow(checkerColor, vec3(2.2f));\n        }\n        \n        float diffuseSum = dot(mi.diffuse, vec3(1.0f));\n        float specularSum = dot(mi.specular, vec3(1.0f));\n        float t = max(specularSum / (diffuseSum + specularSum), 0.25);     \n        \n        float weightNEE, weightBRDF;\n        vec3 directBRDF = vec3(0.0f);\n        for(int i = ZERO; i < lights.length(); i++)\n        {\n            Quad light = lights[i];        \n            float dist;\n            Ray lightRay = GetRandomRay_NEE(vec2(GetRandom(), GetRandom()), light, intersection.position, intersection.normal, dist);\n            vec3 lightNormal = cross(light.w, light.l);\n            float LNoL = dot(lightNormal, -lightRay.direction);\n            if(LNoL > 0.0f)\n            {\n                WeightPDF(lightRay, -ray.direction, intersection.normal, mi.roughness, t, weightNEE, weightBRDF);\n                bool isShaded = TraceLight(lightRay, light.materialID);\n                if(isShaded)\n                {\n                    SurfaceInput si = InitSurfaceInput(intersection.position, intersection.normal, -ray.direction, lightRay.direction);\n                    MaterialInput lightMI = materials[light.materialID];\n                    directBRDF += EvaluateBRDF(si, mi) * weightNEE * lightMI.diffuse;\n                }  \n            }\n        }\n        color += lastBRDF * directBRDF;\n        \n        float probability = 1.0 - min(max(max(lastBRDF.r, lastBRDF.g), lastBRDF.b), 1.0);\n        if(GetRandom() < probability) break;\n         \n        Ray ggxRay = GetRandomRay_GGX(vec3(GetRandom(), GetRandom(), GetRandom()), ray.direction, intersection.position, intersection.normal, mi.roughness, t);\n        SurfaceInput si = InitSurfaceInput(intersection.position, intersection.normal, -ray.direction, ggxRay.direction);\n        WeightPDF(ggxRay, -ray.direction, intersection.normal, mi.roughness, t, weightNEE, weightBRDF);\n        lastBRDF *= EvaluateBRDF(si, mi) * weightBRDF / (1.0f - probability);\n        \n        ray = ggxRay;\n        depth++;\n    }\n    \n    vec4 bufferA = texelFetch(iChannel1, ivec2(iFragCoord), 0);\n    if(texelFetch(iChannel2,ivec2(82,0),0).x > 0.)\n    {\n        fragColor = vec4(color, 1.0);\n    }\n    else\n    {\n        bufferA.a += 1.0;\n        color = mix(bufferA.rgb, color, 1.0 / bufferA.a);\n        fragColor = vec4(color, bufferA.a);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define ZERO min(0, iFrame)\n\n#define INFINITY 1e10\n#define EPSILON 0.001\n\n#define PI 3.14159265359\n#define INV_PI 0.31830988618\n#define SQRT2_2 0.70710678118\n#define DegToRad 0.01745329252\n\n#define DIELETRIC_REFLECTANCE 0.04\n\n/////////////////////////////////////////\n//             Structures              //\n/////////////////////////////////////////\n\nstruct Camera\n{\n    vec3 position;\n    vec3 target;\n    vec3 upVec;\n    float fovy;\n};\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Sphere\n{\n    int materialID;\n\n    vec3 center;\n    float radius;\n};\n\nstruct Quad\n{\n    int materialID;\n    \n    vec3 p;\n    vec3 w;\n    vec3 l;\n};\n\nstruct Intersection\n{\n    vec3 position;\n    vec3 normal;\n    vec2 uv;\n};\n\nstruct SurfaceInput\n{\n    vec3 positionWS;\n    vec3 normalWS;\n    vec3 viewWS;\n    vec3 lightWS;\n    vec3 halfVec;\n    vec3 reflWS;\n    \n    float NoV;\n    float NoL;\n    float NoH;\n    float LoH;\n};\n\nstruct MaterialInput\n{\n    int materialType;\n    vec3 diffuse;\n    float alpha;\n    vec3 specular;\n    float perceptualRoughness;\n    float roughness;\n    float metallic;\n    float occlusion;\n    float f90;\n};\n\nRay InitRay(vec2 rv, Camera camera, vec2 fragCoord, vec2 resolution)\n{\n    vec3 forward = normalize(camera.target - camera.position);\n    vec3 right = normalize(cross(camera.upVec, forward));\n    vec3 up = cross(forward, right);\n       \n    vec2 realFragCoord = fragCoord + rv - 0.5;\n    realFragCoord = realFragCoord * 2.0 - resolution.xy;\n    \n    vec2 uv = tan(camera.fovy * DegToRad * 0.5) * (realFragCoord / resolution.yy);\n    vec3 rayDir = normalize(right * uv.x + up * uv.y + forward);\n    \n    return Ray(camera.position, rayDir);\n}\n\nSurfaceInput InitSurfaceInput(vec3 positionWS, vec3 normalWS, vec3 viewWS, vec3 lightWS)\n{\n\tSurfaceInput surfaceInput;\n\tsurfaceInput.positionWS = positionWS;\n\tsurfaceInput.normalWS = normalWS;\n\tsurfaceInput.viewWS = viewWS;\n\tsurfaceInput.lightWS = lightWS;\n    surfaceInput.halfVec = normalize(viewWS + lightWS);\n\tsurfaceInput.reflWS = reflect(-viewWS, normalWS);\n\n    surfaceInput.NoV = abs(dot(normalWS, viewWS)) + 1e-5f;\n    surfaceInput.NoL = max(dot(normalWS, lightWS), 1e-5f);\n    surfaceInput.NoH = dot(normalWS, surfaceInput.halfVec);\n    surfaceInput.LoH = dot(lightWS, surfaceInput.halfVec);\n\n\treturn surfaceInput;\n}\n\nfloat F90(vec3 f0)\n{\n\t// return clamp(dot(f0, 50.0 * 0.33), 0.0, 1.0);\n\treturn clamp(50.0 * f0.g, 0.0, 1.0);\n}\n\nMaterialInput InitMaterialInput(int materialType, vec4 albedoAlpha, float perceptualRoughness, float metallic)\n{\n\tMaterialInput materialInput;\n    materialInput.materialType = materialType;\n\tmaterialInput.perceptualRoughness = perceptualRoughness;\n\tmaterialInput.roughness = perceptualRoughness * perceptualRoughness;\n\tmaterialInput.metallic = metallic;\n\n\t// https://google.github.io/filament/Filament.html#materialsystem/parameterization\n\tfloat oneMinusMetallic = 1.0f - metallic;\n\tmaterialInput.diffuse = albedoAlpha.rgb * oneMinusMetallic;\n\tmaterialInput.specular = albedoAlpha.rgb * materialInput.metallic + DIELETRIC_REFLECTANCE * oneMinusMetallic;\n\tmaterialInput.f90 = F90(materialInput.specular);\n\n\tmaterialInput.alpha = albedoAlpha.a;\n\treturn materialInput;\n}\n\n/////////////////////////////////////////\n//           Help Functions            //\n/////////////////////////////////////////\n\nuint seed;\n// https://www.shadertoy.com/view/XlGcRh\nuvec3 pcg3d(uvec3 v) {\n\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v ^= v >> 16u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    return v;\n}\n\n// https://github.com/skeeto/hash-prospector/issues/19#issuecomment-1120105785\nuint lowbias32(uint x)\n{\n    x ^= x >> 16;\n    x *= 0x21f0aaadU;\n    x ^= x >> 15;\n    x *= 0x735a2d97U;\n    x ^= x >> 15;\n    return x;\n}\nfloat GetRandom(){return float(lowbias32(seed++))*uintBitsToFloat(0x2F7FFFFFu);}\n\n/////////////////////////////////////////\n//           Math Functions            //\n/////////////////////////////////////////\n\nbool SolveQuadratic(float a, float b, float c, out float x0, out float x1)\n{\n    float discriminant = b * b - 4.0 * a * c;\n    if(discriminant < 0.0){ return false;}\n    \n    float rootDisc = sqrt(discriminant);\n    float q = (b > 0.0) ? -0.5 * (b + rootDisc) : -0.5 * (b - rootDisc);\n    float temp0 = q / a;\n    float temp1 = c / q;\n    if (temp1 > temp0)\n    {\n        x0 = temp0;\n        x1 = temp1;   \n    }\n    else\n    {\n        x0 = temp1;\n        x1 = temp0;\n    }\n    return true;  \n}\n\nbool RayQuadIntersect(Ray ray, Quad quad, out float t, out Intersection intersection)\n{\n    vec3 edge1 = quad.w;\n    vec3 edge2 = quad.l;\n    vec3 h = cross(ray.direction, edge2);\n    float a = dot(edge1, h);\n    if(abs(a) < EPSILON) {return false;}\n    \n    float f = 1.0 / a;\n    vec3 s = ray.origin - quad.p;\n    float u = f * dot(s, h);\n    //I modified this a little bit to ensure there could be an intersection near edges.\n    //original:\n    //if(u < 0.0 || u > 1.0) {return false;}\n    if(u < -EPSILON || u > 1.0 + EPSILON) {return false;}\n    \n    vec3 q = cross(s, edge1);\n    float v = f * dot(ray.direction, q);\n    //origin:\n    //if(v < 0.0 || v > 1.0) {return false;}\n    if(v < -EPSILON || v > 1.0 + EPSILON) {return false;}\n    \n    t = f * dot(edge2, q);\n    if(t < EPSILON) {return false;}\n    \n    intersection.position = ray.origin + t * ray.direction;\n    intersection.normal = normalize(cross(edge1, edge2));\n    intersection.uv = vec2(u, v);\n    return true;\n}\n\nbool RaySphereIntersect(Ray ray, Sphere sphere, out float t, out Intersection intersection)\n{\n    bool hasIntersection = false;\n    \n    float t0, t1;\n    vec3 l = ray.origin - sphere.center;\n    float a = dot(ray.direction, ray.direction);\n    float b = 2.0 * dot(ray.direction, l);\n    float c = dot(l, l) - sphere.radius * sphere.radius;\n    if (!SolveQuadratic(a, b, c, t0, t1)) {return false;}\n    \n    if(t1 > 0.0)\n    {\n        t = t1;\n        hasIntersection = true;\n    }\n    \n    if(t0 > 0.0)\n    {\n        t = t0;\n        hasIntersection = true;\n    }\n    \n    intersection.position = ray.origin + t * ray.direction;\n    intersection.normal = normalize(intersection.position - sphere.center);\n    \n    float u = atan(intersection.normal.z, intersection.normal.x) / PI * 0.5f + 0.5f;\n    float v = acos(intersection.normal.y) / PI;\n    intersection.uv = vec2(u, v);\n    return hasIntersection;\n}\n\n/////////////////////////////////////////\n//                BRDF                 //\n/////////////////////////////////////////\n\n// Bruce Walter et al. 2007. Microfacet Models for Refraction through Rough Surfaces. Proceedings of the Eurographics Symposium on Rendering.\nfloat D_GGX(float NoH, float roughness) {\n    float a = NoH * roughness;\n    float k = roughness / (1.0 - NoH * NoH + a * a);\n    return k * k * INV_PI;\n}\n\n// Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs. Journal of Computer Graphics Techniques, 3 (2).\nfloat V_SmithGGXCorrelated(float NoV, float NoL, float roughness) {\n    float a2 = roughness * roughness;\n    float GGXV = NoL * sqrt(NoV * NoV * (1.0 - a2) + a2);\n    float GGXL = NoV * sqrt(NoL * NoL * (1.0 - a2) + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\n// Christophe Schlick. 1994. An Inexpensive BRDF Model for Physically-Based Rendering. Computer Graphics Forum, 13 (3), 233–246.\nfloat F_Schlick(float LoH, float f0, float f90) {\n    return f0 + (f90 - f0) * pow(1.0 - LoH, 5.0);\n}\n\nvec3 F_Schlick(float LoH, vec3 f0, vec3 f90) {\n    return f0 + (f90 - f0) * pow(1.0 - LoH, 5.0);\n}\n\nvec3 F_Schlick(float LoH, vec3 f0) {\n    return f0 + (vec3(1.0) - f0) * pow(1.0 - LoH, 5.0);\n}\n\nvec3 F0(vec3 baseColor, float metallic) {\n    return DIELETRIC_REFLECTANCE * (1.0 - metallic) + baseColor * metallic;\n}\n\n// Specular BRDF\nvec3 Fr(float NoV, float NoL, float NoH, float LoH, float roughness, vec3 f0) {\n    float D = D_GGX(NoH, roughness);\n    vec3 F = F_Schlick(LoH, f0);\n    float V = V_SmithGGXCorrelated(NoV, NoL, roughness);\n    return D * F * V;\n}   \n\nfloat Fd_Lambert() {\n    return INV_PI;\n}\n\n// Diffuse BRDF\n// Brent Burley. 2012. Physically Based Shading at Disney. Physically Based Shading in Film and Game Production, ACM SIGGRAPH 2012 Courses.\nfloat Fd_Burley(float NoV, float NoL, float LoH, float roughness) {\n    float f90 = 0.5 + 2.0 * roughness * LoH * LoH;\n    float lightScatter = F_Schlick(NoL, 1.0, f90);\n    float viewScatter = F_Schlick(NoV, 1.0, f90);\n    return lightScatter * viewScatter * INV_PI;\n}\n","name":"Common","description":"","type":"common"}]}