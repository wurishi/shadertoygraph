{"ver":"0.1","info":{"id":"dsBfRG","date":"1691461048","viewed":259,"name":"Follow You Waterfall","username":"kirickiri","description":"Forked from https://www.shadertoy.com/view/WsVcRt from Khrebtov_M \nchanged a bit on the interaction","likes":2,"published":1,"flags":34,"usePreview":1,"tags":["tracing","webcam","motion","movement"],"hasliked":0,"parentid":"cdSfzy","parentname":"Follow You Bubble"},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Cheap(ish) scrolling nebula effect (just noise mixing)\n// https://store.steampowered.com/app/1751970/A_Blast_From_The_Past/\n\n// noise, IQ - https://www.shadertoy.com/view/4sfGzS\n// (somewhat jigged)\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n//#define UI3 uvec3(UI0, UI1, 2798796415U)\n//#define UI4 uvec4(UI3, 1979697957U)\n#define UIF (1.0 / float(0xffffffffU))\n\n#define PI 3.14159265359\n\n// alternate the direction of rotation along a checker pattern\n#define CHECKERED\n\n\nmat2 rot(float angle) {\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));\n}\n\nfloat checkersign(vec2 uv) {\n#ifdef CHECKERED\n    uv = floor(uv);\n    return sign(mod(uv.x + uv.y, 2.) - .5);\n#else\n    return 1.;\n#endif\n}\n\n\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\n// https://github.com/ashima/webgl-noise/blob/master/src/noise3Dgrad.glsl\n// modified to allow for rotation \nfloat snoise(vec3 v, out vec3 gradient, float time)\n{\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n    \n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n    \n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// add rotation\n  x0.xy *= rot(time*checkersign(a0.xy));\n  x1.xy *= rot(time*checkersign(a0.zw));\n  x2.xy *= rot(time*checkersign(a1.xy));\n  x3.xy *= rot(time*checkersign(a1.zw));\n    \n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  vec4 m2 = m * m;\n  vec4 m4 = m2 * m2;\n  vec4 pdotx = vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3));\n\n// Determine noise gradient\n  vec4 temp = m2 * m * pdotx;\n  gradient = -8.0 * (temp.x * x0 + temp.y * x1 + temp.z * x2 + temp.w * x3);\n  gradient += m4.x * p0 + m4.y * p1 + m4.z * p2 + m4.w * p3;\n  gradient *= 42.0;\n\n  return 420.0 * dot(m4, pdotx);//origin 42->420 Kiri\n}\n\nfloat get_mask(vec2 uv) {\n    uv.y *= 4.;\n    uv.y -= 1.;\n    uv.x *= .6;\n    uv.x *= pow(uv.y, .15);\n    uv.x = abs(uv.x);\n\treturn (smoothstep(0.65, 1., uv.x) * step(0., uv.y));\n}\n\nfloat fbm(vec3 p, inout vec3 gradient) {\n\t// Initial values\n\tfloat value = 0.;\n\tfloat amplitude = .3;\n\tfloat frequency = 1.;\n\tfloat rotation = 1.5;\n\tvec3 grad;\n\t// Loop of octaves\n\tfor (int i = 0; i < 4; i++) {\n        value += amplitude * snoise(frequency*p - gradient, grad, iTime*rotation);\n\t\tgrad.z = 0.;\n\t\tgradient += amplitude*grad*.3;\n        frequency *= 2.;\n\t\tamplitude *= .5;\n\t\trotation *= 2.;\n\t}\n\treturn value;\n}\n\n\n#define SCALE 20.\n#define SPEED 9.\n#define FREQUENCY .93\n\nfloat d;\n#define C(p)  min(1., sqrt(10.*abs(length(p-.5)-.4)))\n#define D(p,o)  ( (d=length(p-o)*5.)<=.6 ? d:1. )\n\n\n\nvec2 distort(vec2 uv) {\n    vec2 a0 = vec2(0.5, 0.2);\n    vec2 a1 = vec2(0.6, -0.4);\n    vec2 a2 = vec2(0.2, 0.9);\n    vec2 a3 = vec2(-0.7, 0.9);\n    vec2 d = sin(17.4 * uv + 1.5 * sin(14.7 * uv.yx + 0.5 + a0 * iTime) + a1 * iTime);\n    d += sin(16.4 * uv.yx + 1.3 * sin(15.7 * uv + 0.8 + a2 * iTime) - a3 * iTime);\n    d.y -= 2.5;\n    return uv * 0.995 + d * 0.003;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n\n\n    vec3 colorvec=vec3(.0);\n    vec2 pvec = ( 2.0 * fragCoord - iResolution.xy ) / iResolution.x * 1000.0;\n    vec2 pv = fragCoord.xy / iResolution.xy;\n    pv.x = 1.0-pv.x;//uv.x=1.-uv.x;//(invert)\n\tvec2 pos = textureLod(iChannel1,vec2(0.0),0.0).xy;\n\tfragColor=(textureLod(iChannel0,pv,0.0).xxxw+texture(iChannel2,pv))*0.01;\n    \n    \n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x = uv.x*2.-1.;\n    uv.x *= iResolution.x / iResolution.y; \n    \n  float time = iTime * 1.;\n  \n  \n   \tfloat mask = get_mask(uv);\n        \n    vec3 background = vec3(0.,0.,0.);//texture(iChannel0, uv).rgb;\n    \n    vec3 p = vec3(uv, 0.);\n    p.x *= pow(p.y*(1.+pos.x), .3*pos.x*pos.x+abs(pos.x-0.5)*(0.5-pos.x));\n    p.y = pow(p.y, .5);\n\n    vec3 gradient = vec3(0.);\n    float noise = fbm(p + vec3(pos.x, iTime*.6*(1.5*abs(.5-abs(pos.x/iResolution.x))+1.), 0.), gradient);\n    noise = noise*.5+.5;\n    \n    vec3 color = vec3(0.);\n    color = mix(vec3(noise)*vec3(0.6, .6, .9)*2.,vec3(0.), mask)*(1.-pos.x/iResolution.x);\n    vec3 maskcolor=vec3(.5,.35,0.21);\n\n\t//fragColor = vec4(color*maskcolor,1.);\n\t\n\t\n/*\n\tif(min(low,min(mid,high))<.1)\n\t{\n\t//fragColor = vec4(color*maskcolor,Transparency);\n\t\tfragColor = mix(vec4(color*maskcolor,Transparency), vec4(color.x*(1.+max(low,max(mid,high)))*maskcolor.x,color.y*(1.+max(uvc.x,uvc.y)*min(low,min(mid,high)))*maskcolor.y,color.z*(1.+max(low,max(mid,high)))*maskcolor.z,TransparencyLow), 0.);\n\t}\n\telse{\n\t//fragColor = vec4(color.x*(1.+uvc.x*low),color.y*(1.+uvc.x*mid),color.z*(1.+uvc.x*high),1.0);\n\t//fragColor = vec4(color.x*(uv.x*low),color.y*(mid*uv.y-uv.x),color.z*(high*uv.x+uv.y),1.0);\n\t\n\tfragColor = vec4(color.x*(1.+max(low,max(mid,high)))*maskcolor.x,color.y*(1.+max(uvc.x,uvc.y)*min(low,min(mid,high)))*maskcolor.y,color.z*(1.+max(low,max(mid,high)))*maskcolor.z,TransparencyLow);\n\t}\n\t*/\n\n    \n\n  \tif((distance(pv.x,pos.x)<0.15 ||distance(pv.x,pos.x)<0.075) )   \n    fragColor+=vec4(color*maskcolor*1.2,1.);\n    else\n    \n    fragColor+=vec4(color*maskcolor,1.);\n    \n    \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* Buffer b stores camera image from the previous frame, and this buffer outputs \ndifference between previous frame and current frame, so,for pixels that moved\nthe output pixel is bright*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n\n\nfragColor = textureLod( iChannel0, uv,1.0 )-textureLod( iChannel1, uv,1.0);    \n}\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Thit is the buffer that stores current image from the camera\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n \n\n    fragColor = texture( iChannel1, uv);\n}\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\n/*this buffer is used to calculate the center of pixels from \nbuffer A  that are  bright enough  (those are the pixels that moved)\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //we want pixel(0;0) to output position of the center of bright pixels\n    \n    if( fragCoord.x>0.5) return;\n    if( fragCoord.y>0.5) return;\n    \n  /*we will calculate the sum of bright pixels'coordinates \n  and then divide it by the number of these pixels*/\n    \n    vec2 sum=vec2(0.0);\n    float g=0.0;\n    float threshold = 0.15;\n    for(float i=0.0;i<1.0;i+=0.01) for(float j=0.0;j<1.0;j+=0.01)\n \t    {\n            vec3 diff = textureLod(iChannel0,vec2(i,j)  ,3.0).xyz;\n            if(diff.r >= threshold || diff.g >= threshold || diff.b >= threshold)\n            {\n\t\t\t\tsum+=vec2(i,j);\n \t  \t        g++;\n \t        }\n  \t     \n\t   }\n    float  td= iTimeDelta;\n    \n    /*camera is not  a precise tool for tracking movement, so, if we just output\n     calculated center, it will be jittery. Instead, we can move cursor towards\n    the calculated center buy calculating the difference between this position\n   and previous position, and multiply this difference by some constant value*/\n\n\tvec4 te =texture(iChannel1,vec2(0.0,0.0));//xy-current coordinates;zw-desired coordinates;\n    vec2 delta = te.zw-te.xy;\n\tif(g<15.0) fragColor = te+vec4(3.0*delta*td,0.0,0.0);\n    else\n    {\n        te.zw =sum/g;\n    \tdelta = te.zw-te.xy;\n     \tfragColor =  te+vec4(3.0*delta*td,0.0,0.0);\n    }\n   \n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//this buffer if for the line that cursor traces \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor=.97*texture(iChannel0,uv);\n   \n    vec2 pos = textureLod(iChannel1,vec2(0.0),0.0).xy;\n    if(distance(uv,pos)<0.2)   fragColor =vec4(1.);\n    \n    \n\n}","name":"Buffer C","description":"","type":"buffer"}]}