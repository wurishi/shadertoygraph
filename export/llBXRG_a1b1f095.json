{"ver":"0.1","info":{"id":"llBXRG","date":"1444689049","viewed":573,"name":"TextureZoomPlanes","username":"dila","description":"First time trying to render textured sprites - camera facing quads. Excuse the size of the code. It... became something else.","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["sprites"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 rot(float t)\n{\n    return mat2(cos(t), sin(t), -sin(t), cos(t));\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat box(vec3 p, vec3 b)\n{\n    vec3 q = clamp(p, -b, b);\n    return length(p - q);\n}\n\nfloat sdBoxXY(vec3 p, vec3 b)\n{\n  vec2 d = abs(p.xy) - b.xy;\n  return min(max(d.x,d.y),0.0) +\n         length(max(d,0.0));\n}\n\nfloat map(vec3 p)\n{\n\tfloat d = length(p.xy) - 1.0;\n    \n    return -d;\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n\tfloat t = 0.0;\n    for (int i = 0; i < 8; ++i) {\n        vec3 p = o + r * t;\n        float d = map(p);\n        t += d;\n    }\n    return t;\n}\n\nvec3 normal(vec3 p)\n{\n\tvec3 o = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy) - map(p-o.xyy),\n                          map(p+o.yxy) - map(p-o.yxy),\n                          map(p+o.yyx) - map(p-o.yyx)));\n}\n\nvec2 texcoords(vec3 p)\n{   \n\treturn p.xy * 0.25;\n}\n\nvec3 textureGamma(sampler2D channel, vec2 uv)\n{\n    vec3 tex = texture(channel, uv).xyz;\n    return tex * tex;\n}\n\nfloat gray(sampler2D channel, vec2 uv)\n{\n    vec3 tex = textureGamma(channel, uv);\n    return (tex.x + tex.y + tex.z) / 3.0;\n}\n\nvec3 bump(sampler2D channel, vec2 p, float k)\n{\n    float d = 0.01;\n    float sx = gray(channel, p + vec2(d,0.0)) - gray(channel, p + vec2(-d,0.0));\n    float sy = gray(channel, p + vec2(0.0,d)) - gray(channel, p + vec2(0.0,-d));\n    return normalize(vec3(sx, sy, k));\n}\n\nmat3 basis(vec3 v)\n{\n\tmat3 r;\n    r[2] = v;\n    r[1] = vec3(0.0, 1.0, 0.0);\n    r[0] = cross(r[2], r[1]);\n    if (dot(r[0],r[0]) < 0.5) {\n        r[1] = vec3(1.0, 0.0, 0.0);\n        r[0] = cross(r[2], r[1]);\n    }\n    r[1] = normalize(cross(r[0], r[2]));\n    r[0] = normalize(r[0]);\n    return r;\n}\n\nvec3 shade(vec3 o, vec3 r, vec3 w, inout vec3 sn, float t)\n{\n    mat3 texb = basis(sn);\n    vec3 wq = fract(w) * 2.0 - 1.0;\n    vec2 texl = texcoords(wq * texb);\n    vec3 tex = textureGamma(iChannel0, texl);\n    sn = texb * bump(iChannel0, texl, 0.5);\n    \n    vec3 lp = vec3(0.0, 0.0, 0.0 + iTime);\n    vec3 lv = w - lp;\n    float ld = length(lv);\n    lv /= ld;\n    float lt = 0.0;//trace(lp + sn * 0.01, lv);\n    float lm = 1.0;\n    if (lt < ld) {\n        lm = 1.0;\n    }\n    float lb = max(dot(sn, -lv), 0.0);\n    float la = 1.0 / (1.0 + ld * ld * 0.1);\n    vec3 light = lb * la * lm * vec3(1.0, 1.0, 0.8);\n    \n    light += mix(vec3(0.0), vec3(1.0), 0.5+0.5*sn.y);\n\n    return light * tex * 1.0 / (1.0 + t * t);\n}\n\nvec3 test(vec3 o, vec3 r, vec3 p, float d)\n{\n    float pzd = 0.25;\n    p.z = floor(o.z / pzd) * pzd;\n    vec3 fc = vec3(0.0);\n    const int layers = 32;\n    float fl = float(layers);\n    for (int j = 0; j < layers; ++j) {\n        vec3 np = p + vec3(0.0, 0.0, (1.0 + float(j)) * pzd);\n        const int n = 1;\n        float rd = mod(float(j), 2.0) * 2.0 - 1.0;\n        float f = 0.0;//np.z;//iTime * 0.1 + float(i) / float(n);\n        vec3 lp = np + vec3(cos(f), sin(f), 0.0) * 0.0;\n\n        vec3 pv = lp - o;\n        float pd = length(pv);\n        pv /= pd;\n        //pv = vec3(0.0, 0.0, 1.0);\n        float t = dot(lp - o, pv) / dot(r, pv);\n\n        vec3 w = o + r * t;\n\n        mat3 pvb = basis(pv);\n\n        vec3 tuv = (w-lp) * pvb * 0.125;\n        tuv.xy *= rot(iTime);\n        tuv += sin(np.z);\n        vec3 tex = textureGamma(iChannel1, tuv.xy);\n        vec3 del = lp - w;\n        //tex /= 1.0 + dot(del,del);\n        tex *= 1.0 - clamp(abs(d-t) * 1.0, 0.0, 1.0);\n        tex *= clamp(pd * fl / pzd, 0.0, 1.0);\n        tex *= clamp(1.0 - pd / (fl * pzd), 0.0, 1.0);\n        //tex /= float(n + layers);\n        tex /= 1.0 + t * t * 0.1;\n\n        if (t > 0.0) {\n            fc += tex;\n        }\n    }\n    \n    return fc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.0));\n    vec3 o = vec3(0.0, 0.0, iTime);\n    \n    //r.xz *= rot(iTime);\n    \n    float t = trace(o, r);\n\tvec3 w = o + r * t;\n    vec3 sn = normal(w);\n    vec3 is = shade(o, r, w, sn, t);\n    \n    //vec3 rr = reflect(sn, -r);\n    //float rt = trace(w + sn * 0.1, rr);\n\t//vec3 rw = w + rr * rt;\n    //vec3 rsn = normal(rw);\n    //vec3 ris = shade(w, rr, rw, rsn, rt);\n    \n    //float fres = max(dot(sn, -r), 0.0);\n    //vec3 fc = mix(ris, is, fres);\n    \n    vec3 k = test(o, r, vec3(0.0, 0.0, 0), t);\n    \n    vec3 fc = vec3(k);\n        \n\tfragColor = vec4(sqrt(fc), 1.0);\n}","name":"Image","description":"","type":"image"}]}