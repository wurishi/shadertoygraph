{"ver":"0.1","info":{"id":"fttXWl","date":"1639992649","viewed":167,"name":"Recursive Swirls ","username":"domizai","description":"Reclusively swirling a uv with normals and light.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["swirl","light","normal","recursion"],"hasliked":0,"parentid":"fl3XDs","parentname":"Golden Swirls"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of https://www.shadertoy.com/view/fl3XDs\n\n#define PI 3.14159265358979323846\n#define RATIO iResolution.x / iResolution.y\n#define POINTS 10\n#define FORCE 2. // the larger the smaller the swirl\n#define ROTATION 2.\n\n\n// swirl uv at random point\nvec2 swirl (vec2 uv, float seed, inout float acc_frc, inout vec2 acc_rot)\n{\n    float tm = iTime * .3;\n    \n    // point\n    float n = n21(vec2(seed));\n    vec2 pnt = vec2(.5) + vec2(cos(tm + n * 423.1), sin(tm + n * 254.3) * .5);\n\n    // rotate point\n    vec2  dif = uv - pnt;\n    float dis = length(dif);\n    float frc = smoothstep(.0, 1., exp(dis * -FORCE) * (cos(dis * 10.) * .5 + .5));\n    float swl = frc * sin(tm + n * 624.8) * ROTATION; \n    vec2  rot = dif * rotate(swl);\n\n    // for normal map\n    acc_frc += frc;\n    acc_rot += rot * frc; \n\n    // rotated uv\n    return rot + pnt;\n}\n\n\nvec3 offsetLights (vec2 uv, vec3 normals)\n{\n    float tm  = iTime * 1.;\n    float off = .5; // offset\n    float sth = .8; // strength\n    float amb = .3; // ambient\n    float rad = 1.; // radius\n    vec3 pos  = vec3(.5, .5, 1.);\n    \n    float o2 = 1. * off;\n    float o3 = 2. * off;\n    \n    vec3 p1 = vec3(pos.x + cos(tm) * rad, pos.y + sin(tm + 0.) * rad, pos.z);\n    vec3 p2 = vec3(pos.x + cos(tm + o2) * rad, pos.y + sin(tm + o2) * rad, pos.z);\n    vec3 p3 = vec3(pos.x + cos(tm + o3) * rad, pos.y + sin(tm + o3) * rad, pos.z);\n    \n    vec3 l1 = diffuseLight(uv, normals, p1, vec3(sth, 0., 0.));\n    vec3 l2 = diffuseLight(uv, normals, p2, vec3(0., sth, 0.));\n    vec3 l3 = diffuseLight(uv, normals, p3, vec3(0., 0., sth));\n    \n    return l1 + l2 + l3 + amb;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord / iResolution.xy - .5) * vec2(RATIO, 1.) + .5;\n    vec3 col = vec3(0.);\n    float tm = iTime;\n      \n    // reclusively swirl th uv\n    float acc_frc = .0;\n    vec2  acc_rot = vec2(0.);\n    vec2  sv = uv;\n    for (int i = 0; i < POINTS; i++)\n        sv = swirl(sv, fract(float(i+1) * 123.45), acc_frc, acc_rot);\n\n    // normal map\n    vec3 normal = normalize(vec3(acc_rot, acc_frc * .01));\n    \n    // light\n    vec3 diffuse   = offsetLights(uv, normal);\n    vec3 specular  = smoothstep(.85, .95, diffuse);\n    vec3 light     = diffuse + specular;\n    \n    //col = light;\n    //col = normal;\n    col = light + sin(light * PI) - light; // Let's make it a bit more interesting\n \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float n21 (vec2 p)\n{\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\nvec2 n22 (vec2 p)\n{\n    float n = n21(p);\n    return vec2(n, n21(p+n));\n}\n\n\nmat2 rotate (float a) \n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nvec3 diffuseLight (vec2 uv, vec3 normals, vec3 pos, vec3 col)\n{\n    vec3 dif = pos - vec3(uv, 0.); // point light\n    //vec3 dif = pos; // directional light\n    vec3 dir = normalize(dif);\n    float intensity = 1. / length(dif); // inverse square law\n    float diffuse   = dot(normals, dir) * intensity;\n    return col * diffuse;\n}\n","name":"Common","description":"","type":"common"}]}