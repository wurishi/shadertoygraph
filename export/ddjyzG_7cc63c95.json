{"ver":"0.1","info":{"id":"ddjyzG","date":"1687865896","viewed":68,"name":"Configurable Fractal","username":"AlephNull","description":"Configurable fractal which can be zoomed and panned.\nParameters can be found in the \"Common\" tab. There are some example algorithms there you may want to play around with.\n\nControls:\n- pan - wasd or drag mouse\n- zoom - up/down or e/q key (zoom in/out)","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["fractal","math","mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 cpow(vec2 m, float p) {\n    float r = length(m);\n    float theta = atan(m.y, m.x);\n    r = pow(r, p);\n    theta *= p;\n    return vec2(r * cos(theta), r * sin(theta));\n}\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.y - a.y * b.y, a.x * b.y + a.y * b.x);\n}\nvec2 cdiv(vec2 a, vec2 b) {\n    return vec2(dot(a, b), a.y * b.x - a.x * b.y) / dot(b, b);\n}\n\nint mandelbrot(vec2 c) {\n    vec2 z = c;\n    for (int i = 0; i < ITERATIONS; ++i) {\n        if (dot(z, z) > THRESHOLD) {\n            return i;\n        }\n        z = ALGORITHM;\n    }\n    return ITERATIONS;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = ((fragCoord + vec2(0.0, (iResolution.x - iResolution.y) * 0.5)) / iResolution.x) * 2.0 - 1.0;\n    float zoom = fetchData(SCREEN_ZOOM_ADDR).x;\n    vec2 pan   = fetchData(SCREEN_PAN_ADDR).xy * 2.0;\n    \n    mat3 transform = mat3(\n        vec3(zoom, 0.0, 0.0),\n        vec3(0.0, zoom, 0.0),\n        vec3(-pan, 1.0)\n    );\n    \n    vec2 pos = (transform * vec3(uv, 1.0)).xy;\n    \n    int value = mandelbrot(pos);\n    float cVal = pow(\n        1.0 - float(value) * (1.0 / float(ITERATIONS)),\n        float(ITERATIONS) / 50.0\n    );\n    \n    vec3 color = vec3(0.0);\n    color = mix(color, vec3(0.5, 0.0, 0.0), smoothstep(0.0, 0.2, cVal));\n    color = mix(color, vec3(0.5, 0.5, 0.0), smoothstep(0.2, 0.4, cVal));\n    color = mix(color, vec3(0.0, 0.0, 0.5), smoothstep(0.4, 0.6, cVal));\n    color = mix(color, vec3(1.0), smoothstep(0.6, 1.0, cVal));\n    \n    fragColor = vec4(color, 1.0);\n    //if (min(abs(pos.x), abs(pos.y)) < 0.002 * zoom) fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (storeData(fragCoord, SCREEN_PAN_ADDR)) {\n        if (iFrame == 0) {\n            fragColor = SCREEN_PAN_DEFAULT;\n        } else {\n            vec4 currentPan = fetchData(SCREEN_PAN_ADDR);\n            float currentZoom = fetchData(SCREEN_ZOOM_ADDR).x;\n            vec2 mainPos = currentPan.xy;\n            vec2 lastPos = currentPan.zw;\n            \n            if (iMouse.z > 0.0 && iMouse.w < 0.0) { // Mouse down\n                vec2 dMouse = ((iMouse.xy - abs(iMouse.zw)) / iResolution.x) * currentZoom;\n                mainPos = lastPos + dMouse;\n            } else {\n                if (KEYDOWN(KEY_W)) {\n                    mainPos.y -= 0.01 * currentZoom;\n                }\n                if (KEYDOWN(KEY_A)) {\n                    mainPos.x += 0.01 * currentZoom;\n                }\n                if (KEYDOWN(KEY_S)) {\n                    mainPos.y += 0.01 * currentZoom;\n                }\n                if (KEYDOWN(KEY_D)) {\n                    mainPos.x -= 0.01 * currentZoom;\n                }\n                lastPos = mainPos;\n            }\n            fragColor = vec4(mainPos, lastPos);\n        }\n    } else if (storeData(fragCoord, SCREEN_ZOOM_ADDR)) {\n        if (iFrame == 0) {\n            fragColor = SCREEN_ZOOM_DEFAULT;\n        } else {\n            float currentZoom = fetchData(SCREEN_ZOOM_ADDR).x;\n            \n            if (KEYDOWN(KEY_UP_ARROW) || KEYDOWN(KEY_E)) {\n                currentZoom *= SCREEN_ZOOM_IN_FACTOR;\n            }\n            if (KEYDOWN(KEY_DOWN_ARROW) || KEYDOWN(KEY_Q)) {\n                currentZoom *= SCREEN_ZOOM_OUT_FACTOR;\n            }\n            fragColor = vec4(currentZoom, 0.0, 0.0, 0.0);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//// Parameters ////\n\n// Iterations affect the accuracy\n#define ITERATIONS 100\n// Thrshold is the cutoff point for when a value should be considered outside the set\n// Lower values can be slightly faster, but less accurate\n#define THRESHOLD 50.0\n// Fractal algorithm to be applied (set to `cpow(z, 2.0) + c` for the mandelbrot set)\n// See below for example algorithms\n#define ALGORITHM cpow(z, 4.0) - c * sin(2.2 * iTime) + z * cos(1.4 * iTime)\n\n//// Example Algorithms ////\n\n// cpow(z, 2.0) + c\n// cpow(z, -2.0) + c\n// cpow(z, sin(z.x + iTime) + cos(z.y + iTime)) + c\n// cpow(z, 2.0 * (-1.0 + sin(iTime))) - vec2(1)\n// cpow(z, 30.0 * cos(0.111 * iTime)) + cpow(c, 2.0 * sin(0.65 * iTime))\n// cpow(z, 30.0 * cos(0.111 * iTime)) + cpow(c, 2.0 * sin(0.65 * iTime)) - sin(iTime)\n// cpow(vec2(z.x * sin(0.93 * iTime), z.y * cos(0.72 * iTime)), 2.0) + c\n// cpow(z, 2.0) + c + z * vec2(cos(iTime), sin(iTime))\n\n//// Data ////\n\n#define SCREEN_PAN_ADDR ivec2(0, 0)\n#define SCREEN_PAN_DEFAULT vec4(0.0, 0.0, 0.0, 0.0)\n\n#define SCREEN_ZOOM_ADDR ivec2(1, 0)\n#define SCREEN_ZOOM_DEFAULT vec4(3.5, 0.0, 0.0, 0.0)\n#define SCREEN_ZOOM_IN_FACTOR 0.98\n#define SCREEN_ZOOM_OUT_FACTOR (1.0 / SCREEN_ZOOM_IN_FACTOR)\n\n#define fetchData(addr) texelFetch(iChannel0, addr, 0)\n#define storeData(pos, addr) ivec2(pos) == addr\n\n//// Keyboard ////\n\n#define KEYDOWN(key) texelFetch(iChannel1, ivec2(key, 0), 0).r > 0.5\n\n#define KEY_BACKSPACE 8\n#define KEY_TAB 9\n#define KEY_ENTER 13\n#define KEY_SHIFT 16\n#define KEY_CTRL 17\n#define KEY_ALT 18\n#define KEY_PAUSE_BREAK 19\n#define KEY_CAPS_LOCK 20\n#define KEY_ESCAPE 27\n#define KEY_SPACE 8\n#define KEY_PAGE_UP 33\n#define KEY_PAGE_DOWN 34\n#define KEY_END 35\n#define KEY_HOME 36\n#define KEY_LEFT_ARROW 37\n#define KEY_UP_ARROW 38\n#define KEY_RIGHT_ARROW 39\n#define KEY_DOWN_ARROW 40\n#define KEY_INSERT 45\n#define KEY_DELETE 46\n#define KEY_0 48\n#define KEY_1 49\n#define KEY_2 50\n#define KEY_3 51\n#define KEY_4 52\n#define KEY_5 53\n#define KEY_6 54\n#define KEY_7 55\n#define KEY_8 56\n#define KEY_9 57\n#define KEY_A 65\n#define KEY_B 66\n#define KEY_C 67\n#define KEY_D 68\n#define KEY_E 69\n#define KEY_F 70\n#define KEY_G 71\n#define KEY_H 72\n#define KEY_I 73\n#define KEY_J 74\n#define KEY_K 75\n#define KEY_L 76\n#define KEY_M 77\n#define KEY_N 78\n#define KEY_O 79\n#define KEY_P 80\n#define KEY_Q 81\n#define KEY_R 82\n#define KEY_S 83\n#define KEY_T 84\n#define KEY_U 85\n#define KEY_V 86\n#define KEY_W 87\n#define KEY_X 88\n#define KEY_Y 89\n#define KEY_Z 90\n#define KEY_LEFT_WINDOW_KEY 91\n#define KEY_RIGHT_WINDOW_KEY 92\n#define KEY_SELECT_KEY 93\n#define KEY_NUMPAD_0 96\n#define KEY_NUMPAD_1 97\n#define KEY_NUMPAD_2 98\n#define KEY_NUMPAD_3 99\n#define KEY_NUMPAD_4 100\n#define KEY_NUMPAD_5 101\n#define KEY_NUMPAD_6 102\n#define KEY_NUMPAD_7 103\n#define KEY_NUMPAD_8 104\n#define KEY_NUMPAD_9 105\n#define KEY_MULTIPLY 106\n#define KEY_ADD 107\n#define KEY_SUBTRACT 109\n#define KEY_DECIMAL_POINT 110\n#define KEY_DIVIDE 111\n#define KEY_F1 112\n#define KEY_F2 113\n#define KEY_F3 114\n#define KEY_F4 115\n#define KEY_F5 116\n#define KEY_F6 117\n#define KEY_F7 118\n#define KEY_F8 119\n#define KEY_F9 120\n#define KEY_F10 121\n#define KEY_F11 122\n#define KEY_F12 123\n#define KEY_NUM_LOCK 144\n#define KEY_SCROLL_LOCK 145\n#define KEY_SEMI_COLON 186\n#define KEY_EQUAL_SIGN 187\n#define KEY_COMMA 188\n#define KEY_DASH 189\n#define KEY_PERIOD 190\n#define KEY_FORWARD_SLASH 191\n#define KEY_GRAVE_ACCENT 192\n#define KEY_OPEN_BRACKET 219\n#define KEY_BACK_SLASH 220\n#define KEY_CLOSE_BRAKET 221\n#define KEY_SINGLE_QUOTE 222\n","name":"Common","description":"","type":"common"}]}