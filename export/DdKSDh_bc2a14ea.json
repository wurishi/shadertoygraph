{"ver":"0.1","info":{"id":"DdKSDh","date":"1681200468","viewed":105,"name":"Raytracing - Pavel","username":"0x706a","description":"My first raytracer","likes":2,"published":1,"flags":32,"usePreview":1,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 color, in vec2 coord) {\n    if (display_render) {\n        vec2 uv = coord / iResolution.xy;\n        color = vec4(vec3(texture(iChannel0, uv).xyz), 1); \n    } else {\n        color = vec4(1);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float infinity = 99999999.9;\nconst float pi = 3.1415926535897932385;\nconst int samples_per_pixel = 10;\nconst int max_depth = 5;\nconst bool render_with_time = true;\nconst bool display_render = true;\n\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n\nfloat really_random(float x) {\n    float res = x;\n    for(int i = 0; i < 10; i++) {\n        res = random(res);\n    }\n    return res;    \n}\n\nfloat random_float(float s, float min, float max) {\n    return min + (max - min) * random(s);\n}\nvec3 random_vec3(float s, float min, float max) {\n    return vec3(random_float(s * s * 435112.23, min, max), random_float(s * 1123.2112213, min, max), random_float(s * s / 43.2, min, max));\n}\nvec2 random_vec2(float s, float min, float max) {\n    return vec2(random_float(random(random(s) + s), min, max), random_float(s, min, max));\n}\nvec3 random_in_unit_sphere(float s) {\n    while (true) {\n        vec3 p = random_vec3(really_random(s), -1.0, 1.0);\n        if (dot(p, p) <= 1.0) {\n            return p;\n        } else {\n            s += 123123.45345;\n        }\n    }\n}\nvec3 random_unit_vector(float s) {\n    return normalize(random_in_unit_sphere(s));\n}\nvec3 random_in_unit_disk(float s) {\n    while (true) {\n        vec3 p = vec3(random_float(s, -1.0, 1.0), random_float(s, -1.0, 1.0), 0);\n        if (dot(p, p) <= 1.0) {\n            return p;\n        }\n        s *= 2322224.432322222;\n    }\n}\n\nbool near_zero(vec3 v) {\n    float s = 0.00000001;\n    return (abs(v.x) < s) && (abs(v.y) < s) && (abs(v.z) < s);\n}\n\nstruct Ray {\n    vec3 orig;\n    vec3 dir;\n};\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n    int mat;\n};\n\nstruct hit_record {\n    bool hit;\n    vec3 p;\n    vec3 normal;\n    float t;\n    int mat;\n    \n    bool front_face;\n};\n\nstruct material {\n    vec3 albedo;\n    vec3 attenuation;\n    hit_record rec;\n    Ray r_in;\n    Ray scattered;\n    float fuzz;\n    float ior;\n    int type; // 0 - diffuse, 1 - metal, 2 - glass\n};\n\nvec3 at(Ray r, float t) {\n    return r.orig + t * r.dir;\n}\n\nfloat reflectance(float cosine, float ref_idx) {\n    // use Schlick's approximation for reflectance\n    float r0 = (1.0 - ref_idx) / (1.0 + ref_idx);\n    r0 = r0 * r0;\n    return r0 + (1.0 - r0) * pow((1.0 - cosine), 5.0);\n}\n\nconst int sphere_count = 4 + 1;\nSphere sphere_list[sphere_count] = Sphere[sphere_count](\\\n    Sphere(vec3(0, 1, 0), 1.0, 4), \\\n    Sphere(vec3(-4, 1, 0), 1.0, 2), \\\n    Sphere(vec3(4, 1, 0), 1.0, 3), \\\n    Sphere(vec3(0, -2000, 0), 2000.0, 1), \\\n        Sphere(vec3(6, 0.5, 0), 0.5, 0)\n);\n    \n    \nconst int material_count = 5;\nmaterial material_list[material_count] = material[material_count](\\\n        // diffuse\n        material(vec3(0.9, 0.2, 0.2), vec3(0), hit_record(false, vec3(0), vec3(0), 0.0, 0, true), Ray(vec3(0), vec3(1)), Ray(vec3(0), vec3(0)), 0.0, 1.0, 0), \\\n        material(vec3(0.5), vec3(0), hit_record(false, vec3(0), vec3(0), 0.0, 0, true), Ray(vec3(0), vec3(1)), Ray(vec3(0), vec3(0)), 0.0, 1.0, 0), \\\n        material(vec3(0.3203125, 0.828125, 0.99609375), vec3(0), hit_record(false, vec3(0), vec3(0), 0.0, 0, true), Ray(vec3(0), vec3(1)), Ray(vec3(0), vec3(0)), 0.0, 1.0, 0), \\\n        // metal\n        material(vec3(1), vec3(0), hit_record(false, vec3(0), vec3(0), 0.0, 0, true), Ray(vec3(0), vec3(1)), Ray(vec3(0), vec3(0)), 0.0, 1.0, 1), \\\n        // glass\n        material(vec3(1), vec3(1), hit_record(false, vec3(0), vec3(0), 0.0, 0, true), Ray(vec3(0), vec3(1)), Ray(vec3(0), vec3(0)), 0.0, 1.5, 2)\\\n);\n\nmaterial lambertian(material m, float seed) {\n    vec3 scatter_direction = m.rec.normal + random_unit_vector(random(seed + random(m.rec.p)));\n    \n    if (near_zero(scatter_direction)) {\n        scatter_direction = m.rec.normal;\n    }\n    \n    m.scattered = Ray(m.rec.p, scatter_direction);\n    m.attenuation = m.albedo;\n    return m;\n}\n\nmaterial reflective(material m, float seed) {\n    vec3 reflected = reflect(normalize(m.r_in.dir), m.rec.normal);\n    m.scattered = Ray(m.rec.p, reflected);\n    m.scattered.dir += random_unit_vector(56874.01 * random(seed) * random(100.0 * seed)) * m.fuzz;\n    m.attenuation = m.albedo;\n    return m;\n}\n\nmaterial dielectric(material m, float seed) {\n    float refraction_ratio = m.rec.front_face ? (1.0 / m.ior) : m.ior;\n    \n    vec3 unit_direction = normalize(m.r_in.dir);    \n    float cos_theta = min(dot(-unit_direction, m.rec.normal), 1.0);\n    float sin_theta = sqrt(1.0 - cos_theta*cos_theta);\n    \n    vec3 direction;\n    \n    bool cannot_refract = refraction_ratio * sin_theta > 1.0;\n    float refl = reflectance(cos_theta, refraction_ratio);\n    float rand = random_float(seed * cos_theta * 14654432.14, 0.0, 1.0);\n    \n    if (cannot_refract || refl > rand) {\n        direction = reflect(unit_direction, m.rec.normal);\n    } else {\n        direction = refract(unit_direction, m.rec.normal, refraction_ratio);\n    }\n    \n    m.scattered = Ray(m.rec.p, direction);\n    return m;\n}\n\nhit_record set_face_normal(hit_record rec, Ray r, vec3 out_normal) {\n    rec.front_face = dot(r.dir, out_normal) <= 0.0;\n    rec.normal = rec.front_face ? out_normal : -out_normal;\n    return rec;\n}\n\nhit_record sphere_hit(Ray r, Sphere s, float t_min, float t_max) {\n    hit_record rec = hit_record(false, vec3(0), vec3(0), 0.0, 0, true);\n    vec3 oc = r.orig - s.center;\n    float a = dot(r.dir, r.dir);\n    float half_b = dot(oc, r.dir);\n    float c = dot(oc, oc) - s.radius * s.radius;\n    \n    float discriminant = half_b * half_b - a * c;\n    if (discriminant < 0.0) {\n        return rec;\n    } \n    \n    float sqrtd = sqrt(discriminant);\n    float root = (-half_b - sqrtd) / a;\n    if (root < t_min || t_max < root) {\n        root = (-half_b + sqrtd) / a;\n        if (root < t_min || t_max < root) {\n            return rec;\n        }\n    }\n    \n    rec.hit = true;\n    rec.t = root;\n    rec.p = at(r, root);\n    rec.mat = s.mat;\n    \n    vec3 outward_normal = (rec.p - s.center) / s.radius;\n    rec = set_face_normal(rec, r, outward_normal);\n    \n    return rec;\n}\n\nhit_record hittable_list_hit(Ray r, float t_min, float t_max) {\n    hit_record rec;\n    hit_record temp_rec;\n    bool hit_anything = false;\n    float closest_so_far = t_max;\n    \n    for(int i = 0; i < sphere_count; i++) {\n        temp_rec = sphere_hit(r, sphere_list[i], t_min, closest_so_far);\n        if (temp_rec.hit) {\n            hit_anything = true;\n            closest_so_far = temp_rec.t;\n            rec = temp_rec;\n        }\n    }\n    \n    return rec;\n}\n\nstruct Camera {\n    vec3 origin;\n    vec3 lower_left_corner;\n    vec3 horizontal;\n    vec3 vertical;\n    \n    float aspect_ratio;\n    float aperture;\n    float focus_dist;\n    float lens_radius;\n    \n    float viewport_height;\n    float viewport_width;\n    float focal_length;\n    \n    float vfov;\n    float theta;\n    float h;\n    \n    vec3 lookfrom;\n    vec3 lookat;\n    vec3 vup;\n    \n    vec3 w;\n    vec3 u;\n    vec3 v;\n};\n\nRay get_ray(Camera c, vec2 uv, float s) {\n    vec3 rd = c.lens_radius * random_in_unit_disk(s + 324.3 + uv.x * 23423342.23 - uv.y * 29991134.2);\n    vec3 offset = c.u * rd.x + c.v * rd.y;\n    return Ray(\\\n        c.origin + offset, \\\n        c.lower_left_corner + uv.x * c.horizontal + uv.y * c.vertical - c.origin - offset\\\n    );\n}\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 ray_color(Ray r, float seed) {\n    vec3 current_color = vec3(0);\n    vec3 color_multiplier = vec3(1);\n\n    for (int i = 0; i < max_depth; i++) {\n        hit_record rec = hittable_list_hit(r, 0.001, infinity);\n        if (rec.hit) {\n            material_list[rec.mat].rec = rec;\n            material_list[rec.mat].r_in = r;\n            \n            if (material_list[rec.mat].type == 0) {\n                material_list[rec.mat] = lambertian(material_list[rec.mat], random(seed + 2343.1211));\n            } else if (material_list[rec.mat].type == 1) {\n                material_list[rec.mat] = reflective(material_list[rec.mat], random(random(seed + 223.2323) * 23234.2343));\n            } else if (material_list[rec.mat].type == 2) {\n                material_list[rec.mat] = dielectric(material_list[rec.mat], random(seed + 8956342.999));\n            } else {\n                return vec3(252 / 2, 3, 236) / 256.0;\n            }\n            \n            \n            r = material_list[rec.mat].scattered;\n            color_multiplier *= material_list[rec.mat].attenuation;\n\n            \n        } else {\n            vec3 unit_direction = normalize(r.dir);\n            float t = 0.5 * (unit_direction.y + 1.0);\n            current_color = (1.0 - t) * vec3(1) + t * vec3(0.5, 0.7, 1.0);\n            break;\n        }\n    }\n    return current_color * color_multiplier;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Image\n    float image_width = iResolution.x;\n    float image_height = iResolution.y;\n\n    float rng_seed = really_random(random(fragCoord) + float(render_with_time) * random(float(iFrame) * 324.234234));\n\n    // Camera\n    Camera camera;\n    \n    camera.vfov = 20.0;\n    camera.aspect_ratio = image_width / image_height;\n    \n    camera.lookfrom = vec3(13, 2, 3);\n    camera.lookat = vec3(0, 0, 0);\n    camera.vup = vec3(0, 1, 0);\n    \n    camera.aperture = 0.1;\n    camera.focus_dist = length(camera.lookfrom - camera.lookat);\n    // camera.focus_dist = 10.0;\n    camera.lens_radius = camera.aperture / 2.0;\n    \n    camera.w = normalize(camera.lookfrom - camera.lookat);\n    camera.u = normalize(cross(camera.vup, camera.w));\n    camera.v = cross(camera.w, camera.u);\n    \n    \n    camera.theta = radians(camera.vfov);\n    camera.h = tan(camera.theta / 2.0);\n    camera.viewport_height = 2.0 * camera.h;\n    camera.viewport_width = camera.viewport_height * camera.aspect_ratio;\n    \n    camera.origin = camera.lookfrom;\n    camera.horizontal = camera.focus_dist * camera.viewport_width * camera.u;\n    camera.vertical = camera.focus_dist * camera.viewport_height * camera.v;\n    camera.lower_left_corner = camera.origin - camera.horizontal / 2.0 - camera.vertical / 2.0 - camera.focus_dist * camera.w;\n\n    \n    // Normalized pixel coordinates\n    vec2 uv = fragCoord / vec2(image_width - 1.0, image_height - 1.0);\n    \n    \n    vec3 color = vec3(0, 0, 0);\n    for(int s = 0; s < samples_per_pixel; s++) {\n        vec2 rand = random_vec2(random(float(s) + random(float(s))), -1.0, 1.0);\n        vec2 new_uv = uv + rand / vec2(image_width - 1.0, image_height - 1.0);\n        Ray r = get_ray(camera, new_uv, rng_seed);\n        \n        color += ray_color(r, random(rng_seed + random(float(s))));\n    }\n    // Output to screen\n    color /= float(samples_per_pixel);\n    color = sqrt(color);\n    \n    if (render_with_time) {\n        uv = fragCoord / iResolution.xy;\n        vec3 old_color = texture(iChannel0, uv).xyz;\n        if (iFrame == 1) {\n            old_color = -color;\n        }\n        color = (color + old_color * float(iFrame)) / float(iFrame + 1);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}