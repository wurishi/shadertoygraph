{"ver":"0.1","info":{"id":"tsSyzW","date":"1586203193","viewed":229,"name":"Kali Fractal Mix","username":"bignobody","description":"Saw someone else talk about something called a Kali fractal. Found the de(vec3) function on a forum and dropped it in to my test raymarcher. Then made some variations and blended them together and added some colour cycling. Fun stuff.\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","kalifractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 255\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n// Found the original de function here: https://www.reddit.com/r/fractals/comments/5kzv7w/raymarching_a_3d_clamped_kaliset_fractal/\nfloat de(vec3 p, int it) \n{\n    vec4 q = vec4(p - 1.0, 1);\n    for(int i = 0; i < it; i++) {\n        q.xyz = abs(q.xyz + 1.0) - 1.0;\n        q /= clamp(dot(q.xyz, q.xyz), 0.25, 1.00);\n        q *= 1.15;\n    }\n    return (length(q.zy) - 1.2)/q.w;\n}\n\n// made two variations\nfloat ee(vec3 p, int it) \n{\n    vec4 q = vec4(p - 1.0, 1);\n    for(int i = 0; i < it; i++) {\n        q.xyz = abs(q.zxy + 1.0) - 1.0;\n        q /= clamp(dot(q.zxy, q.zxy), 0.25, 1.00);\n        q *= 1.15;\n    }\n    return (length(q.zy) - 1.2)/q.w;\n}\n\nfloat fe(vec3 p, int it) \n{\n    vec4 q = vec4(p - 1.0, 1);\n    for(int i = 0; i < it; i++) {\n        q.xyz = abs(q.yzx + 1.0) - 1.0;\n        q /= clamp(dot(q.yzx, q.yzx), 0.25, 1.00);\n        q *= 1.15;\n    }\n    return (length(q.zx) - 1.2)/q.w;\n}\n\n\n// blend of all 3 fractals\nfloat sceneDistance(vec3 p)\n{\n    int it = int(floor(mod(iTime * 0.15, 8.0)+ 2.0));\n    float t = iTime * 0.1;\n\treturn mix(mix(de(p,it),ee(p,it), sin(t)), fe(p,it), sin(t*0.5));\n}\n\nfloat n21(vec2 p)\n{\n    \n    p = fract(p * vec2(3433.321,12.123));\n    p += (dot(p,p*442.1));\n    return (fract(p.x*p.y));\n}\n\nfloat rayMarch(vec3 rayOrigin, vec3 rayDirection) \n{\n\tfloat dist=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = rayOrigin + rayDirection*dist;\n        float d = sceneDistance(p);\n        dist += d;\n        if(dist>MAX_DIST || abs(d)<SURF_DIST) break;\n    }\n    \n    return dist;\n}\n\nvec3 getNormal(vec3 p) \n{\n\tfloat d = sceneDistance(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        sceneDistance(p-e.xyy),\n        sceneDistance(p-e.yxy),\n        sceneDistance(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\nvec3 rayCast(vec2 uv, vec3 pos, vec3 lookAt, float zoom) \n{\n    vec3 forward = normalize(lookAt-pos),\n    ray = normalize(cross(vec3(0,1,0), forward)),\n    up = cross(forward,ray),\n    center = pos+forward*zoom,\n    intersect = center + uv.x*ray + uv.y*up,\n    r = normalize(intersect-pos);\n    return r;\n}\n\nvec3 recolourNormal(vec3 n)\n{\n    return mix( vec3( clamp(n.x - (sin(n.y - n.z) * cos(dot(n.y,n.z))), 0.001, 0.9), clamp(n.y + (cos(dot(n.y , n.y))*sin(dot(n.x,n.z))), 0.007,0.7), clamp((sin(n.z) * cos(dot(n.x,n.y))) - dot(n.x+n.z, n.x+n.z), 0.001,0.95)),\n               vec3( clamp(n.x - (sin(dot(n.x,n.x)) * cos(dot(n.y,n.z))), 0.0001, 0.7), clamp(n.y - (cos(dot(n.y , n.y))*sin(dot(n.x,n.z))), 0.007,0.7), clamp((sin(n.z) * cos(dot(n.x,n.y))) - dot(n.x+n.y, n.x+n.z), 0.9,0.05)),\n               abs(cos(iTime* 0.8)));\n //   return vec3( clamp(n.x - (sin(n.y - n.z) * cos(dot(n.y,n.z))), 0.001, 0.9), abs(n.y - (cos(abs(n.x - n.z))*sin(dot(n.x,n.z)))), clamp((sin(n.z) * cos(dot(n.x,n.y))) - abs(n.x+n.y+n.z), 0.001,0.9));   \n//\treturn vec3( clamp(n.x - (sin(dot(n.x,n.x)) * cos(dot(n.y,n.z))), 0.0001, 0.7), clamp(n.y - (cos(dot(n.y , n.y))*sin(dot(n.x,n.z))), 0.007,0.7), clamp((sin(n.z) * cos(dot(n.x,n.y))) - dot(n.x+n.y, n.x+n.z), 0.0001,0.9));   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\tvec2 mouse = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0.0);\n    float ambientLight = 0.7;\n\tfloat t = (iTime+0.1) * 0.04;\n \tvec3 rayOrigin = vec3(0.0, (4.2+sin(t))*cos(t), (4.2+sin(t)) * sin(t));\n  //  rayOrigin.yz *= rotate2(-mouse.y*3.14+1.);\n   // rayOrigin.xz *= rotate2(-mouse.x*6.2831);\n    \n    vec3 rayDirection = rayCast(uv, rayOrigin, vec3(0,0.1,0), 1.0);\n\n    float dist = rayMarch(rayOrigin, rayDirection);\n    \n  \n\tif(dist<MAX_DIST) \n    {\n    \tvec3 p = rayOrigin + rayDirection * dist;\n    \tfloat at = smoothstep(dist, 1.0, 0.008);\n    \tvec3 dif = (recolourNormal(getNormal(p))*at);\n        dif += n21(p.xy) * (0.015 * at);\n    \tcol = dif;\n    }\n    else\n    {\n     \tcol = vec3(0.04,0.06,0.12);   \n    }\n    \n\tcol = pow(col * ambientLight,vec3(0.4545));\n    \n    \n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}