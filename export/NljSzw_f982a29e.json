{"ver":"0.1","info":{"id":"NljSzw","date":"1627330501","viewed":123,"name":"Ray Tracing Sphere Sun Light","username":"AshutoshR","description":"My first implementation of ray tracing.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","raysphereintersection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ray {\n    vec3 origin;\n    vec3 direction;\n} ray;\n\nstruct Sphere {\n    vec3 position;\n    float radius;\n    vec3 color;\n} sphere;\n\nstruct Camera {\n    vec3 position;\n    float aspectRatio;\n} camera;\n\nstruct DirectionalLight {\n    vec3 direction;\n    vec3 color;\n} sunLight;\n\nvoid setupScene() {\n    sphere.position = vec3(0 , 0 , 30);\n    sphere.radius = 1.0;\n    sphere.color = vec3(0.5, 0.5, 1.0);\n    \n    camera.position = vec3(0 , 0 , -5);\n    camera.aspectRatio = iResolution.x / iResolution.y;\n    \n    sunLight.direction = vec3(-0.5 , -0.5 , 0.8);\n    sunLight.color = vec3(1.);\n    \n    ray.origin = camera.position;\n}\n\nbool checkIntersect(vec2 px, out float p1, out float p2) {\n    ray.direction = normalize(vec3(px, 1.0) - ray.origin);\n\n    vec3 oc = ray.origin - sphere.position;\n    float a = dot(ray.direction, ray.direction);\n    float b = 2.0 * dot(ray.direction, oc);\n    float c = dot(oc,oc) - pow(sphere.radius, 2.0);\n    \n    float d = pow(b, 2.0) - (4.0 * a *c);\n    if (d < 0.0) {\n        return false;\n    }\n    if (d == 0.0) {\n        p1 = p2 = -b / 2.0 * a;\n        return true;\n    }\n    if (d > 0.0) {\n       p1 = (-b - sqrt(d)) / 2.0 * a;\n       p2 = (-b + sqrt(d)) / 2.0 * a;\n       return true;\n    }\n}\n\nvec3 calculateSunLight(vec3 hitPoint) {\n    vec3 sphereNormal = normalize(hitPoint - sphere.position);\n    vec3 invlDir = sunLight.direction * -1.;\n    float intensity =dot(invlDir, sphereNormal);\n    return sunLight.color * intensity;\n}\n\nvec3 calculateAmbientDiffuse(vec3 hitPoint) {\n    vec3 sphereNormal = normalize(hitPoint - sphere.position);\n    vec3 rayInv = ray.direction * -1.0;\n        \n    float lIntensity = dot(rayInv, sphereNormal);\n    return lIntensity * sphere.color;\n}\n\nvec3 rayTrace(vec2 fCord) {\n    float p1 , p2;\n    if(checkIntersect(fCord, p1, p2)) {\n        float p = p1;\n        if (p2 < p) {\n            p = p2;\n        }\n        vec3 hitPoint = ray.origin + (ray.direction * p);\n        vec3 ambientCol = calculateAmbientDiffuse(hitPoint);\n        vec3 sunCon = calculateSunLight(hitPoint);\n        return sunCon * sphere.color;\n    } else {\n        return vec3(0.0);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    setupScene();\n    \n    // sphere.position.z = sin(iTime) * 4. + 10.;\n    sphere.position.x = sin(iTime) * 1.5;\n    sphere.position.y = cos(iTime) * 1.5;\n    \n    sunLight.direction.x = sin(iTime);\n    sunLight.direction.y = cos(iTime);\n    \n    ray.origin = camera.position;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= camera.aspectRatio;\n    \n    vec3 col = rayTrace(uv);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}