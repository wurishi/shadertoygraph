{"ver":"0.1","info":{"id":"DdGcDK","date":"1715967762","viewed":92,"name":"Octopus SDF + Raymarching (WIP)","username":"Akuto","description":"Octopus generation using SDFs\ncredits : knarkowicz, iq","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float MATH_PI = float( 3.141592653589793238462643383279);\n\n\nfloat saturate( float x )\n{\n    return clamp( x, 0.0, 1.0 );\n}\n\nvoid Rotate( inout vec2 p, float a ) \n{\n    p = cos( a ) * p + sin( a ) * vec2( p.y, -p.x );\n}\n\nfloat RepeatAngle( inout vec2 p, float n ) \n{\n\tfloat angle = 2.0 * MATH_PI / n;\n\tfloat a = atan( p.y, p.x ) + angle / 2.0;\n\tfloat r = length( p );\n\tfloat c = floor( a / angle );\n\ta = mod( a, angle ) - angle / 2.;\n\tp = vec2( cos( a ), sin( a ) ) * r;\n\treturn c;\n}\n\n//smooth minimum\nfloat smin(in float a, in float b, float k)\n{\n    float h = max(k - abs(a-b), 0.0);\n\n    return min(a,b) - h*h/(k*4.0);\n}\n\n//smooth maximum\nfloat smax(in float a, in float b, float k)\n{\n    float h = max(k - abs(a-b), 0.0);\n\n    return max(a,b) + h*h/(k*4.0);\n}\n\nfloat SubstractRound( float a, float b, float r ) \n{\n\tvec2 u = max( vec2( r + a, r - b ), vec2( 0.0, 0.0 ) );\n\treturn min( -r, max( a, -b ) ) + length( u );\n}\n\n//SDF Sphere\nfloat sdSphere(in vec3 pos, float rad)\n{\n    return length(pos) - rad;\n}\n\n//SDF Elipsoid\nfloat sdElipsoid(in vec3 pos, vec3 rad)\n{\n    float k0 = length(pos/rad);\n    float k1 = length(pos/rad/rad);\n    return k0*(k0-1.0)/k1;\n}\n\n//SDF Capsule\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n//SDF Stick\nfloat sdStick( in vec3 p, vec3 a, vec3 b, float ra, float rb )\n{\n    vec3 ba = b-a;\n    vec3 pa = p-a;\n    \n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    \n    float r = mix(ra, rb, h);\n    return length(pa-h*ba) - r;\n}\n\n//SDF Tentacule\nfloat sdTentacule(in vec3 p)\n{\n    p.y += 0.3;\n    \n    float scale = 0.8 - 2.5 * saturate( abs( p.y ) * 0.3 ); // last param is the length of tent\n    \n    p.x = abs( p.x );\n    \n    p -= vec3( 1.0, -0.5, 0.0 );\n    Rotate( p.xy, 0.4 * MATH_PI );\n    p.x -= sin( p.y * 5.0 + iTime * 1.6 ) * 0.05;\n    \n    vec3 t = p;\n    \n    float ret = sdCapsule( p, vec3( 0.0, -1000.0, 0.0 ), vec3( 0.0, 1000.0, 0.0 ), 0.25 * scale );\n    \n    p.z = abs( p.z );\n    p.y = mod( p.y + 0.08, 0.16 ) - 0.08;\n    p.z -= 0.12 * scale;\n    float tent = sdCapsule( p, vec3( 0.0, 0.0, 0.0 ), vec3( -0.4 * scale, 0.0, 0.0 ), 0.1 * scale );\n    \n    float pores = sdSphere( p - vec3( -0.4 * scale, 0.0, 0.0 ), mix( 0.04, 0.1, scale ) );\n    tent = SubstractRound( tent, pores, 0.01 );\n    \n    //soft \n    ret = smin( ret, tent, 0.05 * scale );\n   \n    return ret;\n}\n\n//SDF Octopus\nvec2 sdOctopus(in vec3 pos)\n{\n\n    float t = fract(iTime); // iTime\n    float y = 4.0*t*(1.0-t);\n    float dy = 4.0*(1.0-2.0*t);\n    \n    vec2 u = normalize(vec2(1.0, -dy));\n    vec2 v = vec2(dy,1.0);\n    \n    vec3 cen = vec3(0.0, y, 0.0);\n    \n    float sy = 0.5 + 0.5*y;\n    float sz = 1.0/sy;\n    \n    //vec3 rad = vec3(0.2, 0.2*sy, 0.2*sz);\n    \n    // q is the origine of the octopus\n    vec3 q = pos; //vec3 q = pos-cent; // To make it jump\n    \n    //q.yz = vec2(dot(u,q.yz), dot(v, q.yz));\n    \n    \n    float body = sdElipsoid(q, vec3(0.2f));\n    \n    \n    //head of the octopus\n    vec3 h  = q;\n    vec3 sh = vec3(abs(h.x), h.yz); //symetrie\n    \n    float head = sdElipsoid(h - vec3(0.0, 0.28, 0.0), vec3(0.2));\n    float back_head = sdElipsoid(h - vec3(0.0, 0.28, -0.4), vec3(0.2,0.2,0.3));\n    float back_head2 = sdElipsoid(h - vec3(0.0, 0.1, -0.5), vec3(0.30, 0.25, 0.25));\n    \n    //eye\n    \n    float eyes = sdSphere(sh - vec3(0.08, 0.28, 0.15), 0.08);\n    \n    //eyebrown\n    vec3 eyebrownPos=sh-vec3(0.13, 0.36, 0.14);\n    eyebrownPos.xy = (mat2(8, 15, -15, 15)/17.0)* eyebrownPos.xy;\n    float eyebrown = sdElipsoid(eyebrownPos, vec3(0.08, 0.03,.05));\n    \n    //Tentacule\n    vec3 m = h - vec3(0.0, -0.1, 0.0) ;\n    float tentaculesNumber = 8.0;\n    RepeatAngle( m.xz, tentaculesNumber ); // Set the number of tentacules\n    float tent = sdTentacule(m - vec3(0.0, 0.4, 0.0));\n    \n    //ears\n    vec3 earsStartPos = vec3(0.2,0.3,0.05);\n    vec3 earsEndPos = vec3(0.3,0.3,0.05);\n    \n    float earsBase = sdStick(sh, earsStartPos, earsEndPos, 0.02, 0.03);\n    float earsHole = sdSphere(sh - earsEndPos, 0.03);\n    float ears = SubstractRound( earsBase, earsHole, 0.01 );\n    \n    \n    // Merger every part of the body. \n    // The last parameter is how smooth the merge is\n    \n    float d=smin(head, back_head2, 0.2);\n    d=min(tent, d);\n    d=smin(back_head, d, 0.2);\n    d=smin(body,d, 0.1);\n    //d=smin(eyes, d, 0.01);\n    d=smin(eyebrown, d, 0.06);\n    d=smin(ears, d, 0.03);\n    d=smin(ears, d, 0.01);\n    \n    \n    vec2 res = vec2(d, 2.0); //the first param is the sdf and the second is the distance to the closest intersection\n    if (eyes < d) res = vec2(eyes, 3.0); // The last param is like the index for which mat to apply\n    eyes = sdSphere(sh - vec3(0.09, 0.28, 0.18), 0.04);\n    if (eyes < d) res = vec2(eyes, 4.0);\n    \n    \n    return res;\n}\n\n// map is our global SDF, combination of every SDFs\n// If the distance is negative, it means we are inside the surface but if\n// it's positive, it means we are outside the circle\nvec2 map(in vec3 pos)\n{\n    vec2 guy = sdOctopus(pos);\n    \n    float ground_heigth = -1.8;\n    \n    float ground = pos.y - ground_heigth;\n    \n    \n    return (ground<guy.x) ? vec2(ground, 1.0) : guy; // return the closest\n}\n\n// Get the gradient which correspond to our normal\nvec3 clacNormal( in vec3 pos)\n{\n    vec2 e = vec2(0.0001, 0.0);\n    return normalize(vec3(map(pos+e.xyy).x - map(pos-e.xyy).x,\n                        map(pos+e.yxy).x - map(pos-e.yxy).x,\n                        map(pos+e.yyx).x - map(pos-e.yyx).x));\n    \n}\n\n\n// We are using ray marching to cast the shadow. Raymarching allows us to get\n// the proximity with shape during the ray travel. More it travel close to shapes,\n// blury the shadow will be\nfloat castShadow(in vec3 ro, vec3 rd)\n{\n    float res = 1.0;\n    return res;\n    float t = 0.001; // total lenght of the ray (with every steps)\n    for(int i=0; i<100; i++)\n    {\n        vec3 pos = ro + t*rd;\n        float h = map(pos).x;  // h is the distance between 2 steps\n        \n        res = min( res, 16.0*h/t);\n        \n        if( h<0.0001) break;\n        \n        t += h;\n        if (t>20.0) break;\n    }\n    return clamp(res, 0.0, 1.0); // res value will overcome 1 et undercome 0\n}\n\n// Function to get the color it take as param rayOrigin and rayDirection\nvec2 castRay(in vec3 ro, vec3 rd)\n{\n    float m = -1.0;// material\n\n    float t = 0.0; // Total distance\n    for(int i=0; i<100; i++)\n    {\n        vec3 pos = ro + t*rd;\n        \n        // map is every sdf and the ground combine\n        vec2 h = map(pos);\n        m = h.y;\n        // If the distance is negative, it mean we are inside the circle but if\n        // it's positive, it mean we are outside the circle\n        if(h.x<0.001)\n            break;\n        t += h.x;\n        if(t>20.0) break;\n    }\n    \n    if( t>20.0 ) m=-1.0; // set the material to negative when there is no intersection\n    \n    return vec2(t, m); // return the distance and the material\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * fragCoord - iResolution.xy)/iResolution.y;\n\n    float angleX = 10.0*iMouse.x/iResolution.x;\n    \n    float angleY = 10.0*iMouse.y/iResolution.y;\n    \n    \n    //lenght from the target and the camera\n    float cameraLength = 1.5;\n    \n    \n    //Place de camera on the zaxis\n    vec3 ta = vec3(0.0, 0.0, 0.0); // target of the camera\n    vec3 ro = ta + vec3(cameraLength*sin(angleX), cameraLength*sin(angleY), cameraLength*cos(angleX));//Ray origine\n\n    \n    vec3 ww = normalize(ta- ro);\n    vec3 uu = normalize(cross(ww, vec3(0,1,0)));\n    vec3 vv = normalize(cross(uu,ww));\n    \n    vec3 rd = normalize(p.x*uu + p.y*vv + 1.8*ww);//Ray direction (1.5 correspond to the lenght of the view cone of the camera)\n\n\n    \n    \n    vec3 col = vec3(0.65, 0.75, 0.9) - 0.8*rd.y; // Sky color\n    \n    vec2 tm = castRay(ro, rd); // Get distance and material\n    \n    \n    \n    if(tm.y>0.0)\n    {\n        float t = tm.x;\n        vec3 pos = ro + t*rd;\n        vec3 nor = clacNormal(pos);\n        \n        \n        vec3 mat = vec3(0.18);\n        \n        \n        if(tm.y<1.5)\n        {\n            // Set ground color\n            mat = vec3(0.05, 0.1, 0.02);\n            float f= smoothstep(-0.1,0.1,sin(18.0*pos.x)+sin(18.0*pos.z));\n            mat+=f*0.05;\n        }\n        else if(tm.y<2.5)\n        {\n            //octopus color\n            mat = vec3(0.9, 0.05, 0.2);\n        }\n        else if (tm.t < 3.5)\n        {\n            mat = vec3(0.4, 0.4, 0.4);\n        }\n        else if (tm.t < 4.5)\n        {\n            mat = vec3(0.001);\n        }\n        \n        \n        vec3 sun_dir = normalize(vec3(0.8, 0.4, 0.2));\n        float sun_dif = clamp(dot(nor, sun_dir), 0.0, 1.0); // clam() set a limit to the given first arg between the second arg and the third arg and dot() is the fonction for the dot product (produit scalaire)\n        \n        vec3 view_dir = normalize(ro - pos);\n        vec3 ref_dir = reflect(-sun_dir, nor);\n        \n        float sun_sha = castShadow(pos+nor*0.001, sun_dir);\n        float sky_dif = clamp( 0.5 + 0.5*dot(nor,vec3(0.0, 1.0, 0.0)), 0.0, 1.0 );\n        float bou_dif = clamp( 0.5 + 0.5*dot(nor, vec3(0.0, -1.0, 0.0)), 0.0, 1.0 );\n        float spec_intensity = 0.8;\n        float shininess = 32.0;\n        float spec = pow(max(dot(view_dir, ref_dir), 0.0), shininess);\n        vec3 spec_color = vec3(1.0, 1.0, 1.0) * spec_intensity * spec;\n\n        col  = mat * vec3(7.0,5.0,3.0)*sun_dif*sun_sha;\n        col += spec_color * sun_sha; // Adding specular highlights\n        col += mat * vec3(0.5, 0.8, 0.9)*sky_dif;\n        col += mat * vec3(0.7, 0.3, 0.2)*bou_dif;\n    }\n    \n    col = pow(col, vec3(0.4545));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}