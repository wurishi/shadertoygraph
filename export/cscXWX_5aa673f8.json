{"ver":"0.1","info":{"id":"cscXWX","date":"1680511007","viewed":374,"name":"Game of Light","username":"grom12345","description":"Conway's Game of Life mapped to a sphere and projected to the surface of an outer cube (inverted soft shadows + god rays).\nContains the sound shader.","likes":12,"published":1,"flags":40,"usePreview":0,"tags":["sound","rays","shadow","repetition","spherical","polar","automaton"],"hasliked":0,"parentid":"mstXR2","parentname":"Game of Light_1"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 scene = texture(iChannel0, uv);\n    vec3 color = scene.rgb;    \n    \n    fragColor = vec4(pow(color*10., vec3(1./2.2)), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Spherical mapping adopted from this:\n//https://www.shadertoy.com/view/wtVyRG\n\n#define TAU 6.28318530718 // 2 * pi\n#define PHI 1.57079632679 // pi / 2\n\n//Resolution of the automaton\nvec2 tResolution = vec2(100.0, 100.0);\n\n// Hash and random functions taken from: https://amindforeverprogramming.blogspot.com/2013/07/random-floats-in-glsl-330.html\nuint hash( uint x )\n{\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\nuint hash( uvec2 v )\n{\n    return hash( v.x ^ hash(v.y) );\n}\n\nfloat random( vec2 f )\n{\n    const uint mantissaMask = 0x007FFFFFu;\n    const uint one          = 0x3F800000u;\n   \n    uint h = hash( floatBitsToUint( f ) );\n    h &= mantissaMask;\n    h |= one;\n    \n    float  r2 = uintBitsToFloat( h );\n    return r2 - 1.0;\n}\n\n// oldschool rand() from Visual Studio\nint   seed = 1;\nvoid  srand(int s ) { seed = s; }\nint   rand(void)  { seed=seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n\n//coloring\nvec3 coloring(vec3 c){\n    vec3 norm = normalize(c);\n    vec3 div = vec3(2) * norm.z;    \n    vec3 rbcol = 0.1 + 0.2 * cross(norm.xyz, vec3(.1, -1.3, .2));\n    \n    return mix(c, (rbcol+div), .3);\n}\n\n//p in a sphere segment, uv mapped on sphere\nstruct Mod{\n   vec3 p;\n   vec2 uv;\n};\n\n// r: vec2(horizontal repeats, vertical repeats)\nMod pModSpherical(inout vec3 p, in vec2 r, float iTime) {\n    vec2 a = TAU / r, ha = 0.5 * a;\n    vec3 p1 = p;\n    Mod m;\n    \n    float axz = atan(p1.z, p1.x) + ha.x;\n    float mdxz = mod(axz, a.x);\n    m.uv.x = floor(axz / a.x);\n    p1.xz = sin(mdxz - ha.x + vec2(PHI, 0.0)) * length(p1.xz);\n    \n    float axy = atan(p1.y, p1.x) + ha.y;\n    float mdxy = mod(axy, a.y);\n    m.uv.y = floor(axy / a.y);\n    p1.xy = sin(mdxy - ha.y + vec2(PHI, 0.0)) * length(p1.xy);\n    \n    p1 = p1 - vec3(1.*(1.+1.*sin(TAU/2.+PHI+iTime*.5))+3., .0, 0.0);\n    \n    m.p = p1;\n    return m;\n}\n\nfloat sphere(vec3 p, float r){\n    return length(p)-r;\n}\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nstruct SceneMap{\n    float d;\n    int o;\n    vec2 uv;\n};\n\nSceneMap mapScene(in vec3 p, float iTime) {\n    float t = iTime*.5;\n    float c = cos(t), s = sin(t);\n    vec3 p1 = p;\n    p1.xz *= mat2(c, -s, s, c);\n    //p1.yx *= mat2(c, -s, s, c);\n\n    Mod m = pModSpherical(p1, tResolution, iTime);\n    p1 = m.p;\n    float boxes = box(p1, vec3(0.01,(1.2+sin(iTime)*.5)*vec2(.05)));\n    \n    float bbox = abs(box(p, vec3(8.)))-.1;\n    float sp = sphere(p+vec3(0, 0, 0), 0.5);\n    \n    float d = opUnion(bbox, boxes);\n    \n    SceneMap sm;\n    sm.d = d;\n    sm.uv = m.uv;\n    \n    if(d==bbox) sm.o = 0; else sm.o = 1; \n\n    return sm;\n}\n\nvec3 getNormal(in vec3 p, float iTime) {\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy, iTime).d - mapScene(p - e.xyy, iTime).d,\n                          mapScene(p + e.yxy, iTime).d - mapScene(p - e.yxy, iTime).d,\n                          mapScene(p + e.yyx, iTime).d - mapScene(p - e.yyx, iTime).d));\n}\n\n//Soft shadows adopted from these: \n//https://www.shadertoy.com/view/lsKcDD\n//https://www.shadertoy.com/view/fsXSzj\n\nfloat softShadow(vec3 pp, vec3 normal, vec3 ln, float iTime){\n\n    float eps = .001;\n    int maxSteps = 100;\n    float maxRange = 10.5;\n\t\n\tvec3 start_point = pp + normal * eps*20.;\n\tfloat t = 0.f;\n\tvec3 light_dir = ln;\n\tfloat offset = mapScene(start_point, iTime).d;\n\tfloat step = offset;\n\tvec3 p;\n\tfloat visibility = 1.f;\n\tfloat hardness = 100.f;\n\t\n\tfor(int i = 0;i<maxSteps;i++){\n\t\tt += step;// * (0.7 + 0.3 * frand());\n\t\tif(t > maxRange)\n\t\t\tbreak;\n\t\tp = start_point + light_dir * t;\n\t\tstep = mapScene(p, iTime).d;\n\t\t//float v_ = hardness * step / (t + hardness * offset);\n\t\tfloat v_ = max(step - offset,.0f) * hardness / t;\n\t\tif( v_ < visibility)\n\t\t\tvisibility = v_;\n        if( visibility < eps)\n            return 0.;\n\t}\n\t\n\treturn visibility;\n\t//return 1.f;\n\t\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 6.0);\n    vec3 rd = normalize(vec3(uv, -.3));\n    vec3 l = vec3(0, 0, 0);\n    vec3 l1 = vec3(0, 0, 6.);\n    \n    float tt = iTime;\n    vec3 color;\n    vec4 scene;\n    float t = 0.0;\n    vec2 uvt;\n    vec3 n;\n    vec3 p;\n    vec3 ln;\n    \n    vec3 sphColor = vec3(0.1);\n    \n    for (int i=0; i < 150; i++) {\n        p = ro + rd * t;\n        SceneMap sm = mapScene(p, tt);\n        uvt = sm.uv;\n        if (sm.d < 0.001) {\n            n = getNormal(p, tt);\n           \n            if(sm.o==0){//object is box\n                ln = normalize(l-p);\n                float light = max(.0, dot(n, ln));\n                light = pow(light, 5.)*.5;\n                scene = vec4(coloring((0.5+abs(n)))*light, 0);\n            }else{\n                scene.rgb = sphColor;\n                //a holds a mask for rays\n                scene.a = smoothstep(-1.5, 1.5, p.z);\n            }\n            \n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += sm.d;\n    }\n    \n    float tcol = texelFetch(iChannel0, ivec2(uvt+tResolution/2.), 0).r;\n    float sh = softShadow(p, n, ln, tt);\n    \n    vec4 col0 = scene * vec4(vec3(0.05), 0);\n    vec3 noisecol = texelFetch(iChannel1, ivec2(uvt+tResolution/2.),0).rgb;\n    noisecol = coloring(noisecol);\n    vec4 col1 = vec4(tcol*noisecol, scene.a);\n    if(tcol>0.)\n        scene = mix(col1, col0, sh);\n    else scene = col0;\n    \n    fragColor = scene;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//God rays\n//Based on this: https://www.shadertoy.com/view/wtVyRG\n\nfloat circle( vec2 pos, float r, vec2 uv )\n{\n    return distance(uv, pos) < r ? 1. : 0.;\n}\n\nvec3 sun( vec2 uv, vec2 p ) //x is result, yz are position in normalized coords.\n{\t\t\t\t\t\t\t //This is just a quick hack for this shader only.\n    vec3 res;\n    vec2 uv1 = uv-.5;\n    float aspect = (iResolution.x / iResolution.y);\n    uv1.y /= aspect;\n    float di = distance(uv1, p);\n    res.x =  di <= .1 ? sqrt(7. - di*.1) : 0.;\n    \n    res.yz = p;\n    res.y /= aspect;\n    res.yz = (res.yz+1.)*.5;\n    \n    return res;\n}\n\n#define DITHER\t\t\t//Dithering toggle\n#define QUALITY\t\t2\t//0- low, 1- medium, 2- high\n\n#define DECAY\t\t.974\n#define EXPOSURE\t.24\n#if (QUALITY==2)\n #define SAMPLES\t64\n #define DENSITY\t.97\n #define WEIGHT\t\t.25\n#else\n#if (QUALITY==1)\n #define SAMPLES\t32\n #define DENSITY\t.95\n #define WEIGHT\t\t.25\n#else\n #define SAMPLES\t16\n #define DENSITY\t.93\n #define WEIGHT\t\t.36\n#endif\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 coord = uv;\n    vec3 s = sun(uv, vec2(0));\n    vec2 lightpos = s.yz;\n    \n    s = min(s, 1.);\n    \n    vec4 obj = texture(iChannel0, uv); //objects\n    \n    vec3 occ = vec3(0); //light\n    \n    float dither = texture(iChannel1, fragCoord/iChannelResolution[1].xy).r;    \n        \n    vec2 dtc = (coord - lightpos) * (1. / float(SAMPLES) * DENSITY);\n    float illumdecay = 1.;\n    \n    for(int i=0; i<SAMPLES; i++)\n    {\n        coord -= dtc;\n        #ifdef DITHER\n        \tvec4 scene = texture(iChannel0, coord+(dtc*dither));\n        #else\n        \tvec4 scene = texture(iChannel0, coord);\n        #endif\n        \n        vec3 s = scene.a*scene.rgb;\n        \n        s *= illumdecay * WEIGHT;\n        occ += s;\n        illumdecay *= DECAY;\n    }\n    \n\tfragColor = vec4(obj.rgb*.2+occ*EXPOSURE,1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//Game of Life\n//Lazily copied..\n//https://www.shadertoy.com/view/4lBfDW\n\n#define GRID_SZ tResolution\n\nfloat get_cell(vec2 p, vec2 d)\n{\n    vec2 uv = mod(p + d, GRID_SZ) ;\n    return texture(iChannel0, uv /  iResolution.xy).r > 0. ? 1. : 0.;\n}\n    \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy; // UV coordinates\n    vec2 gc = floor(iResolution.xy * uv) + 0.5; // Grid Coordinates\n\n    if (iFrame == 0) {\n        fragColor = vec4(step(random(gc), 0.5));\n        return;\n    }\n        \n    bool is_alive = get_cell(gc, vec2(0)) > 0.;\n    \n    const vec3 o = vec3(0,1,-1); // Offsets\n    \n    float count = get_cell(gc, o.yx)\n        \t\t+ get_cell(gc, o.zx)\n        \t\t+ get_cell(gc, o.xy)\n        \t\t+ get_cell(gc, o.xz)\n        \t\t+ get_cell(gc, o.yy)\n        \t\t+ get_cell(gc, o.zz)\n        \t\t+ get_cell(gc, o.zy)\n        \t\t+ get_cell(gc, o.yz);\n    \n    float res = 0.;\n    \n    if (is_alive) {\n    // 1. Any live cell with fewer than two live neighbours dies, as if caused by underpopulation.\n    // 2. Any live cell with more than three live neighbours dies, as if by overcrowding.\n        \t if (count <  2. || count >  3.) res = 0.;\n    // 3. Any live cell with two or three live neighbours lives on to the next generation.\n\t//    Health points are stored in the map based on the number of neighbours.\n    \telse if (count == 2. || count == 3.) res = 1./count;\n    }\n    // 4. Any dead cell with exactly three live neighbours becomes a live cell.\n    else if (count == 3.) res = 1.;\n    \n\tfragColor = vec4(res);\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define pi 3.1415926535\n#define speed .01\n#define maxN 10.\n\nvec2 mainSound( int samp, float time )\n{\n   float freq = 20.;\n   float x = 0.;\n   float voices = 40.;\n   for(float i=1.;i<=voices;i++){\n     float k = i*(1.+i*(.002));\n     x+= (pow((voices-i+1.)/voices, 5.))\n     *(.5-pow(abs(sin(k*pi*2.*(freq+sin(mod(time, 2.)\n     *pi*speed*sin(speed*pi*mod(time,2.)*.2)))\n     *mod(time, 2.))),sin(time*pi*speed)\n     *(1.+sin(time*pi*speed))*2000.)\n     *pow(abs(sin(time*pi*speed)),1.-abs(sin(time*pi*speed))*15. ));\n   }\n\n   return vec2(x/voices)*.5;\n}","name":"Sound","description":"","type":"sound"}]}