{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Copyright Per Bloksgaard, 2014 - https://perbloksgaard.dk\n// Thanks to iq for letting me use his ray-marching, softshadow and ao code.\n\n#define PI 3.14159265358979\n\nfloat distPlane(in vec3 p)\n{\n\treturn p.y;\n}\n\nvec2 distTorus(in vec3 p, in vec2 t)\n{\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\tfloat a = (atan(q.x,q.y)+PI)/PI*4.0;\n\tfloat b = (atan(p.z,p.x)+PI)/PI*8.0;\n\tfloat s = clamp(abs(sin(iTime*0.05))*1.8-0.7,0.0,1.0);\n\tfloat c = a * s;\n\tfloat d = b * s;\t\n\tfloat m;\n\tif (fract(d)>0.5)\n\t{\n\t\tm = -s;\n\t\tif (fract(c)>0.5)\n\t\t{\n\t\t\tm = b*(1.0-s);\n\t\t}\n\t}\n\telse\n\t{\n\t\tm = a*(1.0-s);\n\t\tif (fract(c)>0.5)\n\t\t{\n\t\t\tm = -s;\n\t\t}\n\t}\n\treturn vec2((length(q)-t.y)*0.5,m);\n}\n\nvec2 maxOfTwo(in vec2 a, in vec2 b)\n{\n\treturn (a.x<b.x)?a:b;\n}\n\nvec3 doTwist(in vec3 p)\n{\n\tfloat f = sin(iTime)*12.0;\n\tfloat c = cos(f*p.y);\n\tfloat s = sin(f*p.y);\n\tmat2  m = mat2(c,-s,s,c);\n\treturn vec3(p.y,m*p.xz);\n}\n\nvec2 map(in vec3 pos)\n{\n\treturn maxOfTwo( vec2(distPlane(pos),-2.0), distTorus(doTwist(pos-vec3(0.0,0.25,0.0)),vec2(0.20,0.05)) );\n}\n\nvec2 castRay(in vec3 ro, in vec3 rd, in float maxd)\n{\n\tfloat precis = 0.0008;\n\tfloat h = precis*2.0;\n\tfloat t = 0.0;\n\tfloat m = -1.0;\n\tfor(int i=0; i<50; i++)\n\t{\n\t\tif(abs(h)<precis||t>maxd)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tt += h;\n\t\tvec2 res = map( ro+rd*t );\n\t\th = res.x;\n\t\tm = res.y;\n\t}\n\treturn vec2(t, m);\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k)\n{\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor(int i=0; i<30; i++)\n\t{\n\t\tif(t<maxt)\n\t\t{\n\t\t\tfloat h = map(ro + rd*t).x;\n\t\t\tres = min(res, k*h/t);\n\t\t\tt += 0.02;\n\t\t}\n\t}\n\treturn clamp(res,0.0,1.0);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\tmap(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\tmap(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\tmap(pos+eps.yyx).x - map(pos-eps.yyx).x);\n\treturn normalize(nor);\n}\n\nfloat calcAO(in vec3 pos, in vec3 nor)\n{\n\tfloat totao = 0.0;\n\tfloat sca = 1.0;\n\tfor(int aoi=0; aoi<5; aoi++)\n\t{\n\t\tfloat hr = 0.01+0.05*float(aoi);\n\t\tvec3 aopos = nor*hr+pos;\n\t\tfloat dd = map(aopos).x;\n\t\ttotao += -(dd-hr)*sca;\n\t\tsca *= 0.75;\n\t}\n\treturn clamp(1.0-4.0*totao,0.0,1.0);\n}\n\nvec3 render(in vec3 o, in vec3 d, in vec3 lig)\n{ \n\tvec3 col = vec3(0.0);\n\tvec2 res = castRay(o,d,7.0);\n\tfloat t = res.x;\n\tfloat m = res.y;\n\tvec3 pos = o + d*t;\n\tvec3 nor;\n\tif(m<-1.0)\n\t{\n\t\tnor = vec3(0.0,1.0,0.0);\n\t\tt = 7.0;\t\n\t\tif (d.y<0.0)\n\t\t{\n\t\t\tt = -o.y/d.y;\n\t\t\tpos = o + d*t;\n\t\t\tm = (fract(pos.x)>0.5)?0.0:1.0;\n\t\t\tm = (fract(pos.z)>0.5)?1.0-m:m;\n\t\t\tm -= 1.0;\n\t\t}\n\t}\n\telse\n\t{\n\t\tnor = calcNormal(pos);\n\t}\n\tfloat factor = clamp(1.0+m,0.0,1.0);\n\tfloat ao = calcAO(pos,nor);\n\tcol = vec3(0.5)+0.5*sin(vec3(PI,PI*0.25,PI*0.5)*m);\n\tfloat dif = clamp(dot(nor,lig),0.0,1.0);\n\tfloat bac = clamp(dot(nor,normalize(vec3(-lig.x,0.0,-lig.z))),0.0,1.0)*clamp(1.0-pos.y,0.0,1.0);\n\tfloat sh = softshadow(pos,lig,0.02,7.0,4.0); \n\tdif *= sh; \n\tvec3 brdf = dif*vec3(1.0);\n\tfloat pp = clamp(dot(reflect(d,nor),lig ),0.0,1.0);\n\tfloat fre = ao*pow(clamp(1.0+dot(nor,d),0.0,1.0),2.0);\n\tcol = col*brdf+fre*(0.5+0.5*col);\n\tcol *= factor;\n\tcol += vec3(1.5)*sh*pow(pp,8.0);\n\tt = clamp(t-3.2,0.0,10.0);\n\treturn mix(vec3(0.8,0.9,1.0),col,exp(-0.4*t*t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 s = (-iResolution.xy+2.*gl_FragCoord.xy)/iResolution.y;\n\tfloat u = iTime*0.5;\n\tfloat v = -PI*0.4-cos(iTime*0.7)*PI*0.10;\n\tfloat f = 0.5+abs(cos(iTime*0.1)*0.5);\n\tfloat time = -iTime*0.5;\n\tvec3 target = vec3(0.0,0.25,0.0);\n\tvec3 origin = vec3(cos(u)*sin(v)*f,cos(v)*f,sin(u)*sin(v)*f);\n\torigin += target;\n\tvec3 camForward = normalize(target-origin);\n\tvec3 wldUp = vec3(0.0,1.0,0.0);\n\tvec3 camRight = normalize(cross(camForward,wldUp));\n\tvec3 camUp = normalize(cross(camRight,camForward));\n\tvec3 d = normalize(s.x*camRight+s.y*camUp+camForward*2.1);\n\tvec3 c = render(origin,d,normalize(origin));\n\tfragColor = vec4(c,1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4d2GDV","date":"1393697627","viewed":504,"name":"Twisty Torus","username":"bloxard","description":"This shader uses both of raymarching and raytracing. Intersections with the torus are carried out using raymaching while intersections with the ground-plane uses raytracing for best accuracy.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarch","torus","proceduraltexture"],"hasliked":0,"parentid":"","parentname":""}}