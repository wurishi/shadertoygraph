{"ver":"0.1","info":{"id":"fsVczm","date":"1654726449","viewed":44,"name":"Distance estimated fractals","username":"aniolgarcia","description":"Some tests on distance estimated fractals","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["fractal","distanceestimator"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_STEPS = 1000;\nconst float EPSILON = 0.0001;\nconst float MAX_DIST = 50.0;\nconst float INF = 1E6;\n\n/*************************************/\n/* ESTIMADORS DE DISTÀNCIES          */\n/*************************************/\n\n//Estimador de distància d'una capsa de dimensions 2*(h, w, d) centrada a 0.\nfloat box_de(vec3 p, vec3 semi_dimensions)\n{\n    vec3 q = abs(p) - semi_dimensions;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\n//Estimador de distàncies de la creu infinita centrada a 0 a partir de la unió de capses\nfloat cross_de(vec3 p, float mult)\n{\n    float cross1 = box_de(p, vec3(1.f, 1.f, INF)*mult);\n    float cross2 = box_de(p, vec3(1.f, INF, 1.f)*mult);\n    float cross3 = box_de(p, vec3(INF, 1.f, 1.f)*mult);\n    float total_cross = min(cross1, min(cross2, cross3));\n   \n    return total_cross;\n}\n\n\n\n//Implementació elegant i senzilla de l'estimador de distància de Menger sponge,\n// però malauradament GLSL no admet recursió...\n/*\nfloat menger_sponge(vec3 p, float n)\n{\n    if(n == 0.f)\n    {\n        return box_de(p, vec3(3.f));\n    }\n    else\n    {\n        float pot = pow(3.f, n);\n        return max( menger_sponge(p, n-1.f), \n                   -menger_sponge(vec3(mod(pot*p.x + 3.f, 6.f)-3.f, mod(pot*p.y + 3.f, 6.f)-3.f, mod(pot*p.z + 3.f, 6.f)-3.f))/pot);\n    }\n}*/\n\n//Estimador de distància del menger sponge, ara sí funcional però bastant més complicat\nfloat menger_sponge(vec3 p, int n)\n{\n    float l = 2.0; //Longitud de l'aresta\n    \n    float d = box_de(p, vec3(l)/2.0); //Distància inicial és la del cub centrat a l'origen amb aresta l\n\n    float scale = 1.0;\n    for(int i = 0; i < n; i++ )\n    {\n      vec3 a = mod(scale*p, l) - l/2.0;     //Passem el punt a dins del cub d'aresta l centrat a l'origen\n      vec3 x = l/2.0 -3.0* abs(a);          //La creu és també d'aresta l, en lloc de reduir-la en 1/3, multipliquem per tres la distància\n      scale *= 3.0;                         //Fem l'escalat (el fem abans de dividir i així treiem el *3 que hem fet a dalt)\n      float c = cross_de(x, l/2.0)/(scale); //Dividim per l'escala (el factor en el que s'hauria d'haver dividit la creu)\n      d = max(d,c); \n    }\n    return d;\n}\n\n//Estimador de distànces del tetraerde de Sierpinski \n// basat en el que apareix a http://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-iii-folding-space/\nfloat sierpinski(vec3 p, float l, int n)\n{\n    float k = 2.0;\n\tvec3 v1 = vec3(1.0,1.0,1.0)*l;\n\tvec3 v2 = vec3(-1.0,-1.0,1.0)*l;\n\tvec3 v3 = vec3(1.0,-1.0,-1.0)*l;\n\tvec3 v4 = vec3(-1.0,1.0,-1.0)*l;\n    //return min(min(length(v1- p), min(length(v2-p), length(v3-p))), length(v4-p)) -1.0;\n\tvec3 closest_vertex;\n\tfloat min_dist, d;\n   \n    int i;\n    for(i = 0; i < n; i++)\n    {\n        //Suposem que el vèrtex més proper és v1\n        closest_vertex = v1;\n        min_dist = length(p - v1); \n        d = length(p - v2); if(d < min_dist) {closest_vertex = v2; min_dist = d; }\n        d = length(p - v3); if(d < min_dist) {closest_vertex = v3; min_dist = d; }\n        d = length(p - v4); if(d < min_dist) {closest_vertex = v4; min_dist = d; }\n\n        p = closest_vertex + k*(p - closest_vertex);\n        //v1 = closest_vertex + k*(closest_vertex - v1);\n        //v2 = closest_vertex + k*(closest_vertex - v2);\n        //v3 = closest_vertex + k*(closest_vertex - v3);\n        //v4 = closest_vertex + k*(closest_vertex - v4);\n    }\n    //return min(min_dist, dot(p-vec3(0.,-2.0,0.), vec3(0.,1.,0.)));\n    //return min_dist;\n    return (sqrt(length(p))-2.0)*pow(k, float(-i)); //Aquí hi hauria d'haver el DE d'un tetraedre, no d'una esfera, però no he tingut temps...\n\t//return length(p)/pow(k, float(n));\n}\n\n//Estimador de distància del mandelbulb\n// Obtingut de de http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\nfloat mandelbulb(vec3 pos)\n{\n    int Iterations = 10;\n    float Bailout = 8.0;\n    float Power = 8.0;\n    vec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < Iterations ; i++) {\n\t\tr = length(z);\n\t\tif (r>Bailout) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n//Funció que defineix quin estimador s'utilitzarà a l'escens\nfloat distance_estimator(vec3 p) \n{\n    return min(menger_sponge(p, 4), dot(p -vec3(0.0, -1.2, 0.0), vec3(0.0, 1.0, 0.0)));\n    //return mandelbulb(p);\n    //return cross_de(p, 0.25);\n    //return box_de(p, vec3(0.75));\n    //return max(box_de(p, vec3(0.75)), -cross_de(p, 0.25));\n    //return sierpinski(p, 1.0, 8);\n\n}\n\n/******************************************/\n/* FUNCIONS DE RAYMAECHING I IL·LUMINACIÓ */\n/******************************************/\n\nvec3 normal(vec3 p)\n{\n   return normalize(vec3(\n        distance_estimator(vec3(p.x + EPSILON, p.y, p.z)) - distance_estimator(vec3(p.x - EPSILON, p.y, p.z)),\n        distance_estimator(vec3(p.x, p.y + EPSILON, p.z)) - distance_estimator(vec3(p.x, p.y - EPSILON, p.z)),\n        distance_estimator(vec3(p.x, p.y, p.z  + EPSILON)) - distance_estimator(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nfloat shadow(vec3 p, vec3 ray_dir, float min_t, float max_t )\n{\n    float res = 1.0;\n    float k = 8.0; //K alta -> no soft shadows, k baixa -> soft\n    float t = min_t;\n    while(t < max_t)\n    {\n        float h = distance_estimator(p + ray_dir*t);\n        if(h < EPSILON)\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n//Implementació clàssica de phong, res especial\nvec3 phong(vec3 ka_l, vec3 kd_l, vec3 ks_l, vec3 ka_m, vec3 kd_m, vec3 ks_m, float shininess, vec3 light_pos, vec3 pos, vec3 look_from)\n{\n    vec3 L = normalize(light_pos - pos);\n    vec3 N = normal(pos);  \n    vec3 V = normalize(look_from - pos);\n    vec3 H;\n    \n    if(length(L+V) < EPSILON)\n    {\n        H = vec3(0.f);\n    }\n    else\n    {\n        H = normalize(L + V);\n    }\n    \n    vec3 ambient = ka_l * ka_m;\n    vec3 difuse = kd_l * kd_m * max(dot(L, N), 0.0);\n    vec3 specular = ks_l * ks_m * pow(max((dot(N, H)), 0.0), shininess);\n    \n    return ambient + difuse + specular;\n}\n\n//Funció on es defineixen les llums, els materials i si es posen ombres o no\nvec3 compute_color(vec3 p, vec3 dir, vec3 look_from)\n{\n    vec3 light_centre = vec3(0.0);\n    vec3 light_pos = vec3(4.0*sin(iTime*0.5),\n                          4.5,\n                          -3.0* cos(iTime*0.5));\n    //light_pos = vec3(4, 3, 1); //Sense moviment\n    vec3 ka_light = vec3(0.4);\n    vec3 kd_light = vec3(0.7);\n    vec3 ks_light = vec3(0.4);\n    \n    vec3 ka_material = vec3(0.3);\n    vec3 kd_material = vec3(0.2, 0.6, 0.7);\n    vec3 ks_material = vec3(0.4);\n    \n    float shininess = 10.0;\n    \n    //Sense ombra\n    //return phong(ka_light, kd_light, ks_light, ka_material, kd_material, ks_material, shininess, light_pos, p, look_from);\n    \n    //Amb ombra\n    return shadow(p, light_pos, 0.01, 20.0)*phong(ka_light, kd_light, ks_light, ka_material, kd_material, ks_material, shininess, light_pos, p, look_from);\n    \n}\n\n//Funció de raymarching a partir del que retorni distance_estimator\nfloat raymarch(vec3 pos, vec3 dir)\n{\n    float total_dist = 0.0f;\n    int steps;\n    for(steps = 0; steps < MAX_STEPS; steps++) \n    {\n        vec3 p = pos + total_dist * dir;\n        float dist = distance_estimator(p);\n        total_dist += dist;\n        if (dist < EPSILON) \n        {\n            return total_dist; //O bé retornem la distància \n            //return float(steps); //O bé retornem el nombre de passos que hem fet\n        }\n        if(total_dist > MAX_DIST)\n        {\n            return MAX_DIST;\n        }\n    }\n    return MAX_DIST;\n}\n\n/*************************************/\n/* FUNCIONS DE VISUALITZACIÓ         */\n/*************************************/\n\n/* funció per obtenir la direcció d'un raig en coordenades de càmera donat un píxel*/\nvec3 get_ray(vec2 fragCoord)\n{\n    float fov = 45.f;\n    vec2 xy = fragCoord - iResolution.xy/2.f;\n    float z = 0.5*iResolution.y /tan(radians(fov)/2.f);\n    return normalize(vec3(xy, z));\n}\n\n/* obtenir la matriu que passa de coordenade de view a coordenades de món\n    És literalment la implementació de gluLookAt */\nmat4 view_mat(vec3 look_from, vec3 look_at, vec3 v_up)\n{\n    vec3 forward = normalize(look_from - look_at);\n    vec3 side = normalize(cross(forward, v_up));\n    vec3 corrected_up = cross(side, forward); \n    //v_up el donem en coordenades de món, l'hem d'\"inclinar\" peruqè estigui en coordenades de view}\n    // (1,0,0) s'envia a side, (0,1,0) a corrected_up, (0,0,1) a fordward\n    return mat4(vec4(side, 0.f), vec4(corrected_up, 0.f), vec4(-forward, 0.f), vec4(0.f, 0.f, 0.f, 1.f));   \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    //Definim el sistema de càmera\n    vec3 look_from = vec3(2.f, 3.5f, -3.f);\n    //vec3 look_from = vec3(0.6, 0.4, -0.5); //Càmera pel mandelbulb d'aprop\n    vec3 look_at = vec3(0.f);\n    \n    //Calculem la matriu que passa de sistema de càmera a sistema de món\n    mat4 view = view_mat(look_from, look_at, vec3(0.f, 1.f, 0.f));\n    \n    //Obtenim el raig corresponent al fragment i sobre el que farem raymarching\n    vec3 camera_ray = get_ray(fragCoord);\n    vec3 world_ray = (view * vec4(camera_ray, 1.f)).xyz;\n\n    //Fem raymarching\n    float dist = raymarch(look_from, world_ray);\n\n    vec3 p = look_from + dist*world_ray; //Punt d'intersecció\n\n    //Pintem el píxel a la pantalla\n    //fragColor = vec4(vec3(1.0) - vec3(1.f)*dist/3.f,1.0);\n    fragColor = vec4(compute_color(p, world_ray, look_from), 1.0);\n}","name":"Image","description":"","type":"image"}]}