{"ver":"0.1","info":{"id":"NsscRN","date":"1642182756","viewed":123,"name":"Raytracing scene","username":"Pierre","description":"Made by Pierre for a school project, 2022.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/********************** SCENE GLOBAL VARIABLES ***********************/\nconst float FARAWAY=1e30;\nconst float EPSILON=1e-3;\nconst float PLANE_HEIGHT = -2.0;\nconst vec3 diffuseLight = vec3(0.0);\nconst float shineDamper = 2.0;\nconst vec3 fogColor = vec3(0.0);\n\n\n/********************** STRUCTS ***********************/\nstruct Material \n{\n    vec3 Kd;\n    vec3 Ke;\n};\n\nstruct Sphere \n{\n   vec3 Center;\n   float R;\n};\n\nstruct Box \n{\n    vec3 boxmin;\n    vec3 boxmax;\n    vec3 color;\n};\n\nstruct Object \n{\n   Sphere sphere;\n   Material material;\n};\n\nstruct Camera \n{\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray \n{\n    vec3 Origin;\n    vec3 Dir;\n};\n\nstruct intersection\n{\n    float distance;\n    vec3 normal;\n};\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) \n{\n   Camera C;\n   C.Obs = Obs;\n   C.View = normalize(LookAt - Obs);\n   C.Horiz = normalize(cross(vec3(0.0, 0.0, 1.0), C.View));\n   C.Up = cross(C.View, C.Horiz);\n   C.W = float(iResolution.x);\n   C.H = float(iResolution.y);\n   C.z = (C.H/2.0) / tan((aperture * 3.1415 / 180.0) / 2.0);\n   return C;\n}\n\nRay launch(in Camera C, in vec2 XY) \n{\n   return Ray(\n      C.Obs,\n      C.z*C.View+(XY.x-C.W/2.0)*C.Horiz+(XY.y-C.H/2.0)*C.Up \n   );\n}\n\nMaterial diffuse(in vec3 Kd) \n{\n   return Material(Kd, vec3(0.0, 0.0, 0.0));\n}\n\nMaterial light(in vec3 Ke) \n{\n   return Material(vec3(0.0, 0.0, 0.0), Ke);\n}\n\n\n/********************** SCENE CONSTRUCTION ***********************/\nObject spheres[2];\nObject lights[2];\nBox boxes[1];\n\nvoid init_scene() \n{\n   float beta = float(iFrame)/30.0; //  changement de p√©riode\n   float s = sin(beta);\n   float c = cos(beta); \n\n   spheres[0] = Object(\n      Sphere(vec3(-1.0, 1.0, 0.0),0.5), \n      diffuse(vec3(1.0, 1.0, 1.0))\n   );\n\n   spheres[1] = Object(\n      Sphere(vec3(-1.0 + 0.7*s, 1.0 + 0.7*c, 0.0),0.1), \n      diffuse(vec3(0.5, 0.5, 0.0))\n   );\n   \n   boxes[0] = Box(vec3(-0.0, -2.0, -1.0), vec3(1.0, -1.0, 0.0), vec3(1.0, 1.0, 1.0));\n\n\n   float light_movement_time = iTime / 2.0;\n   float light_movement = 5.0 * cos(light_movement_time);\n   float light_movement_2 = 5.0 * cos(light_movement_time + 0.2);\n\n   \n   lights[0] = Object(\n      Sphere(vec3(4.0 + light_movement,-4.0 - light_movement, 2.5),0.02),\n      light(vec3(0.5, 0.35, 0.2)) \n   );\n   \n   lights[1] = Object(\n      Sphere(vec3(2.0 - light_movement_2, 0.0 - light_movement_2, 5.0),0.02),\n      light(vec3(0.2, 0.35, 0.5)) \n   );\n}\n\n\n\n/********************** INTERSECTION ***********************/\nbool intersect_sphere(in Ray R, in Sphere S, out float t) \n{\n   vec3 CO = R.Origin - S.Center;\n   float a = dot(R.Dir, R.Dir);\n   float b = 2.0*dot(R.Dir, CO);\n   float c = dot(CO, CO) - S.R*S.R;\n   float delta = b*b - 4.0*a*c;\n   if(delta < 0.0) {\n      return false;\n   }\n   t = (-b-sqrt(delta)) / (2.0*a);\n   return true;\n}\n\nbool intersect_box(Ray ray, Box box, out float t)\n{\n    vec3 boxmin = box.boxmin;\n    vec3 boxmax = box.boxmax;\n    vec3 raypos = ray.Origin;\n    vec3 raydir = ray.Dir;\n    float t1 = (boxmin.x - raypos.x) / raydir.x;\n    float t2 = (boxmax.x - raypos.x) / raydir.x;\n    float t3 = (boxmin.y - raypos.y) / raydir.y;\n    float t4 = (boxmax.y - raypos.y) / raydir.y;\n    float t5 = (boxmin.z - raypos.z) / raydir.z;\n    float t6 = (boxmax.z - raypos.z) / raydir.z;\n\n    t = max(max(min(t1, t2), min(t3, t4)), min(t5, t6)); // tmin\n    float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));\n\n    if (tmax < 0.0) // box on ray but behind ray origin\n    {\n        t = FARAWAY;\n        return false;\n    }\n\n    if (t > tmax) // ray doesn't intersect box\n    {\n        t = FARAWAY;\n        return false;\n    }\n    return true;\n}\n\nbool intersect_plane(in Ray R, in float h, out float t) \n{\n   t = (h - R.Origin.z) / R.Dir.z;\n   return t > 0.0;\n}\n\n\n\n/********************** BOX DRAWING ***********************/\nvec3 cubenormal(vec3 v) // position relative to cube center\n{\n    vec3 s = sign(v);\n    vec3 a = abs(v);\n\n    vec3 n = mix(\n        mix(vec3(0.0, 0.0, s.z), vec3(s.x, 0.0, 0.0), step(a.z, a.x)),\n        mix(vec3(0.0, s.y, 0.0), vec3(s.x, 0.0, 0.0), step(a.y, a.x)),\n        step(a.z, a.y));\n\n    return n;\n}\n\nintersection get_box_intersection(Ray ray, Box box)\n{\n    intersection result;\n    vec3 raypos = ray.Origin;\n    vec3 raydir = ray.Dir;\n    intersect_box(ray, box, result.distance);\n\n    result.normal = mix(-raydir, cubenormal(raypos + raydir * result.distance - (box.boxmin + box.boxmax) / 2.0), step(result.distance, FARAWAY));\n\n    return result;\n}\n\n\n/************************** LIGHTING ****************************/\nbool isShadowed(in Ray ray) \n{\n    for(int i=0; i<spheres.length(); ++i) \n    {\n        float t;\n\n        if (intersect_sphere(ray, spheres[i].sphere, t))\n        {\n            if (t > EPSILON && t < 1.0) \n            {\n                return true;\n            }\n        }\n    }\n    for (int i =0; i<boxes.length(); ++i)\n    {\n        float t;\n        \n        if (intersect_box(ray, boxes[i], t))\n        {\n            if (t > EPSILON && t < 1.0) \n            {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n\nvec3 getCubeLighting(in vec3 position, in vec3 normal, in vec3 cubeColor)\n{\n    vec3 result = diffuseLight;\n\n    for(int i=0; i<lights.length(); ++i) \n    {\n        Ray R2 = Ray(position, lights[i].sphere.Center);\n\n        vec3 E = lights[i].sphere.Center - position;\n        float lamb = max(0.0, dot(E, normal) / length(E));\n        result += lamb * cubeColor * lights[i].material.Ke;\n    }\n    return result;\n}\n\n \nvec3 getSphereLighting(in vec3 P, in vec3 N, in Material material, in Camera C) \n{\n    vec3 result = diffuseLight;\n\n    for(int i=0; i<lights.length(); ++i) \n    {\n        Ray R2 = Ray(P, lights[i].sphere.Center);\n\n        if (!isShadowed(R2))\n        {\n            vec3 E = lights[i].sphere.Center - P;\n            float lamb = max(0.0, dot(E,N) / length(E));\n            result += lamb * material.Kd * lights[i].material.Ke;\n            \n            // Specular lighting\n            vec3 lightDir = -normalize(E);\n            vec3 unitNormal = normalize(N);\n            vec3 reflectedLightDir = reflect(lightDir, unitNormal);\n            \n            vec3 unitVectorToCamera = normalize(C.Obs - P);\n            float specular_factor = dot(reflectedLightDir, unitVectorToCamera);\n            specular_factor = max(0.0, specular_factor);\n            float dampedFactor = pow(specular_factor, shineDamper);\n            vec3 final_specular = dampedFactor * lights[i].material.Ke;\n            \n            result += final_specular;\n        }\n    }\n    return result;\n}\n\nvec3 getPlaneLighting(in vec3 P, in vec3 N)\n{\n    vec3 groundColor = diffuseLight;\n    \n    for(int i=0; i<lights.length(); ++i) \n    {\n        Ray R2 = Ray(P, lights[i].sphere.Center);\n\n        if (!isShadowed(R2))\n        {\n            if (mod(round(P.x) + round(P.y), 2.0) == 0.0)\n            {\n                groundColor += lights[i].material.Ke * vec3(1.0);\n                groundColor = min(groundColor, vec3(1.0));\n            }\n            else \n            {\n                groundColor += lights[i].material.Ke * vec3(0.5);\n                groundColor = min(groundColor, vec3(0.5));\n            }\n        }\n    }\n    \n    return groundColor;\n}\n\n\n\n\n/***************************** MAIN *******************************/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n   init_scene();\n\n   float camera_movement_time = iTime / 2.0;\n   float camera_movement = 1.0 * cos(camera_movement_time);\n   Camera C = camera(\n       vec3(4.0 + camera_movement, 3.0 + camera_movement, 2.0),\n       vec3(0.5, 0.5, 0.5),\n       50.0       \n   );\n   Ray R = launch(C, fragCoord);\n      \n   fragColor = vec4(fogColor, 0.0);\n\n   float t = FARAWAY;\n\n   vec3 P;\n   vec3 N;\n   Material material;\n    \n   // Draw spheres\n   for (int i=0; i<spheres.length(); ++i) \n   {\n       float cur_t;\n       if(\n          intersect_sphere(R, spheres[i].sphere, cur_t) \n          && cur_t < t // depth\n       ) \n       {\n           t = cur_t;\n           P = R.Origin + t*R.Dir;\n           N = normalize(P - spheres[i].sphere.Center);\n           material = spheres[i].material;\n       } \n   }\n   if(t != FARAWAY) \n   {\n      fragColor.rgb = getSphereLighting(P,N,material, C);\n   }\n   \n   \n   // Draw cube\n   for (int i=0; i<boxes.length(); ++i)\n   {\n        intersection result = get_box_intersection(R, boxes[i]);\n        t = min(t, result.distance);\n\n        vec3 position = R.Origin + result.distance * R.Dir;\n        vec3 normal = result.normal;\n        vec3 cubePixelColor = getCubeLighting(position, normal, boxes[i].color);\n\n        if(result.distance < FARAWAY) \n        {\n            fragColor.rgb = vec3(cubePixelColor);\n        }\n   }\n  \n   \n   // Plane section\n   float plane_t;\n   \n   if (intersect_plane(R, PLANE_HEIGHT, plane_t))\n   {\n       if (plane_t < t)\n       {\n           vec3 P_plane = R.Origin + plane_t*R.Dir;\n           vec3 N_plane = vec3(0.0, 0.0, 1.0);\n           fragColor.rgb = getPlaneLighting(P_plane, N_plane);\n               \n           float min_dist = 0.02;\n           float max_dist = 0.03;\n           if (plane_t > min_dist)\n           {\n               float factor = (plane_t - min_dist) / max_dist;\n               fragColor.rgb = mix(fragColor.rgb, fogColor, factor);\n           }\n       }\n   }\n}","name":"Image","description":"","type":"image"}]}