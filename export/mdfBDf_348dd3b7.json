{"ver":"0.1","info":{"id":"mdfBDf","date":"1689237190","viewed":38,"name":"sit-up by tongue","username":"taichi","description":"just wanted to draw person.\n\nharder than expected to draw shapes using combination of bezier curves.\nIf there are any advices, please let me know.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["situptongue"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Get the UV Coordinate of your texture or Screen Texture, yo!\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\t// Modify that X coordinate by the sin of y to oscillate back and forth up in this.\n\t//uv.x += sin(uv.y*10.0+iTime)/42.0;\n    vec4 face = texture(iChannel0, (uv+vec2(-.1375,-.475))*3.);\n    vec4 hands = texture(iChannel1, (uv+vec2(-0.025,-.35))*1.75);\n    vec4 body = texture(iChannel2, (uv+vec2(.2,.3))*1.25);\n    vec4 foot = texture(iChannel3, uv);\n    fragColor = min(foot,min(body,min(face, hands)));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Test if point p crosses line (a, b), returns sign of result\nfloat testCross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat signBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{ \n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0, \n        step(testCross(A, B, p) * testCross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * testCross(A, C, B);\n}\n\n// Solve cubic equation for roots\nvec3 solveCubic(float a, float b, float c)\n{\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a bezier curve\nfloat sdBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{    \n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);      \n    vec3 t = clamp(solveCubic(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis;    // * signBezier(A, B, C, p);  //No need for this sign\n}\n\n\n#define setX(f) if (f>=0.&& f<1. && mix(mix(a.x,b.x,f),mix(b.x,c.x,f),f)<X) odd=!odd;\n\n\tfloat polySpline(vec2 p,vec2 AA,vec2 BB,vec2 CC,vec2 FF,vec2 GG,vec2 HH,vec2 II, vec2 JJ) {\n\t\tbool odd = false;\n\t\tfloat eps = 1e-7, root, A, B, C, X = p.x, Y = p.y;\n\t\t\n\t\tvec2 a = AA.xy;\n\t\tvec2 b = BB.xy;\n\t\tvec2 c = CC.xy;\n\t\tA = a.y + c.y - b.y - b.y;\n\t\tB = 2.*(b.y - a.y);\n\t\tC = a.y - Y;\n\t\tif (abs(A)<eps) {\n\t\t\tsetX(-C / B);\n\t\t}\n\t\telse {\n\t\t\tfloat root = B*B - 4.*A*C;\n\t\t\tif (root>0.) {\n\t\t\t\troot = sqrt(root);\n\t\t\t\tsetX((-B - root) / (2.*A));\n\t\t\t\tsetX((-B + root) / (2.*A));\n\t\t\t}\n\t\t}\n\t\ta = c;\n\n\t\tb = FF.xy;\n\t\tc = GG.xy;\n\t\tA = a.y + c.y - b.y - b.y;\n\t\tB = 2.*(b.y - a.y);\n\t\tC = a.y - Y;\n\t\tif (abs(A)<eps) {\n\t\t\tsetX(-C / B);\n\t\t}\n\t\telse {\n\t\t\tfloat root = B*B - 4.*A*C;\n\t\t\tif (root>0.) {\n\t\t\t\troot = sqrt(root);\n\t\t\t\tsetX((-B - root) / (2.*A));\n\t\t\t\tsetX((-B + root) / (2.*A));\n\t\t\t}\n\t\t}\n\t\ta = c;\n\t\t\n\t\tb = HH.xy;\n\t\tc = II.xy;\n\t\tA = a.y + c.y - b.y - b.y;\n\t\tB = 2.*(b.y - a.y);\n\t\tC = a.y - Y;\n\t\tif (abs(A)<eps) {\n\t\t\tsetX(-C / B);\n\t\t}\n\t\telse {\n\t\t\tfloat root = B*B - 4.*A*C;\n\t\t\tif (root>0.) {\n\t\t\t\troot = sqrt(root);\n\t\t\t\tsetX((-B - root) / (2.*A));\n\t\t\t\tsetX((-B + root) / (2.*A));\n\t\t\t}\n\t\t}\n\t\ta = c;\n\t\t\n\t\tb = JJ.xy;\n\t\tc = AA.xy;\n\t\tA = a.y + c.y - b.y - b.y;\n\t\tB = 2.*(b.y - a.y);\n\t\tC = a.y - Y;\n\t\tif (abs(A)<eps) {\n\t\t\tsetX(-C / B);\n\t\t}\n\t\telse {\n\t\t\tfloat root = B*B - 4.*A*C;\n\t\t\tif (root>0.) {\n\t\t\t\troot = sqrt(root);\n\t\t\t\tsetX((-B - root) / (2.*A));\n\t\t\t\tsetX((-B + root) / (2.*A));\n\t\t\t}\n\t\t}\n\t\ta = c;\n\n\t\treturn float(odd);\n\t}\n    \n    float middlePolySpline(vec2 p,vec2 AA,vec2 BB,vec2 CC,vec2 FF,vec2 GG,vec2 HH) {\n\t\tbool odd = false;\n\t\tfloat eps = 1e-7, root, A, B, C, X = p.x, Y = p.y;\n\t\t\n\t\tvec2 a = AA.xy;// readCell(np - 1., 0.).xy;\n\t\n\t\tvec2 b = BB.xy;\n\t\tvec2 c = CC.xy;\n\t\tA = a.y + c.y - b.y - b.y;\n\t\tB = 2.*(b.y - a.y);\n\t\tC = a.y - Y;\n\t\tif (abs(A)<eps) {\n\t\t\tsetX(-C / B);\n\t\t}\n\t\telse {\n\t\t\tfloat root = B*B - 4.*A*C;\n\t\t\tif (root>0.) {\n\t\t\t\troot = sqrt(root);\n\t\t\t\tsetX((-B - root) / (2.*A));\n\t\t\t\tsetX((-B + root) / (2.*A));\n\t\t\t}\n\t\t}\n\t\ta = c;\n\n\t\t//------\n\t\tb = FF.xy;\n\t\tc = GG.xy;\n\t\tA = a.y + c.y - b.y - b.y;\n\t\tB = 2.*(b.y - a.y);\n\t\tC = a.y - Y;\n\t\tif (abs(A)<eps) {\n\t\t\tsetX(-C / B);\n\t\t}\n\t\telse {\n\t\t\tfloat root = B*B - 4.*A*C;\n\t\t\tif (root>0.) {\n\t\t\t\troot = sqrt(root);\n\t\t\t\tsetX((-B - root) / (2.*A));\n\t\t\t\tsetX((-B + root) / (2.*A));\n\t\t\t}\n\t\t}\n\t\ta = c;\n\t\t\n\t\t//------\n\t\tb = HH.xy;\n\t\tc = AA.xy;\n\t\tA = a.y + c.y - b.y - b.y;\n\t\tB = 2.*(b.y - a.y);\n\t\tC = a.y - Y;\n\t\tif (abs(A)<eps) {\n\t\t\tsetX(-C / B);\n\t\t}\n\t\telse {\n\t\t\tfloat root = B*B - 4.*A*C;\n\t\t\tif (root>0.) {\n\t\t\t\troot = sqrt(root);\n\t\t\t\tsetX((-B - root) / (2.*A));\n\t\t\t\tsetX((-B + root) / (2.*A));\n\t\t\t}\n\t\t}\n\t\ta = c;\n\n\t\treturn float(odd);\n\t}\n\n\tfloat smallPolySpline(vec2 p,vec2 AA,vec2 BB,vec2 CC) {\n\t\tbool odd = false;\n\t\tfloat eps = 1e-7, root, A, B, C, X = p.x, Y = p.y;\n\t\t\n\t\tvec2 a = AA.xy;\n\t\tvec2 b = BB.xy;\n\t\tvec2 c = CC.xy;\n\t\tA = a.y + c.y - b.y - b.y;\n\t\tB = 2.*(b.y - a.y);\n\t\tC = a.y - Y;\n\t\tif (abs(A)<eps) {\n\t\t\tsetX(-C / B);\n\t\t}\n\t\telse {\n\t\t\tfloat root = B*B - 4.*A*C;\n\t\t\tif (root>0.) {\n\t\t\t\troot = sqrt(root);\n\t\t\t\tsetX((-B - root) / (2.*A));\n\t\t\t\tsetX((-B + root) / (2.*A));\n\t\t\t}\n\t\t}\n\t\ta = c;\n\n\t\tb = CC.xy;\n\t\tc = AA.xy;\n\t\tA = a.y + c.y - b.y - b.y;\n\t\tB = 2.*(b.y - a.y);\n\t\tC = a.y - Y;\n\t\tif (abs(A)<eps) {\n\t\t\tsetX(-C / B);\n\t\t}\n\t\telse {\n\t\t\tfloat root = B*B - 4.*A*C;\n\t\t\tif (root>0.) {\n\t\t\t\troot = sqrt(root);\n\t\t\t\tsetX((-B - root) / (2.*A));\n\t\t\t\tsetX((-B + root) / (2.*A));\n\t\t\t}\n\t\t}\n\t\ta = c;\n\n\t\treturn float(odd);\n\t}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float upperLip(vec2 p) {\n    vec2 A = vec2(-1.5, 0.4);\n    vec2 B= vec2(-1.1,0.6);\n    vec2 C = vec2(-0.6, 0.9);\n    \n    vec2 F=vec2(-0.2,0.65);\n    vec2 G=vec2(0.25,.85);\n    vec2 H=vec2(1.2,.4);\n    \n    vec2 I = vec2(-.2, .44);\n    vec2 K = vec2(-1., .4);\n    \n    // Render the control points\n    float d = min(distance(p,K),min(distance(p,I),min(distance(p,H),min(distance(p,G), min(distance(p,B),   min(distance(p, A),(min(distance(p, F),distance(p, C)))))))) );\n    //if (d < 0.04) { return 1.0 - smoothstep(0.025, 0.034, d); };\n        \n    B+=(B-((A+C)*0.5));\t\t//Made the curve pass through the points\n    F+=(F-((C+G)*0.5));\n    H+=(H-((G+I)*0.5));\n    K+=(K-((I+A)*0.5));\n    \n    // Get the signed distance to bezier curve\n    d = sdBezier(A, B, C, p);\n    float d2 = sdBezier(C,F,G, p);\n    float d3 = sdBezier(G,H,I, p);\n    float d4 = sdBezier(I,K,A, p);\n       \n    float spSign =polySpline(p,A,B,C,F,G,H,I,K);\n    \n    d=min(abs(d),min(abs(d2),min(abs(d3),abs(d4))));\n    if (spSign<=0.){\n        d=-d;\n    }\n    return d;\n}\n\nfloat tongue(vec2 p) {\n    vec2 A = vec2(-.8, 0.);\n    vec2 B= vec2(-1.,0.4);\n    vec2 C = vec2(-1.0, 0.9);\n    \n    vec2 F=vec2(-0.55, 0.9);\n    vec2 G=vec2(-0.6,.5);\n    vec2 H=vec2(-0.3,.9);\n    \n    vec2 I = vec2(.2, .9);\n    vec2 K = vec2(-.3, .0);\n    \n    // Render the control points\n    float d = min(distance(p,K),min(distance(p,I),min(distance(p,H),min(distance(p,G), min(distance(p,B),   min(distance(p, A),(min(distance(p, F),distance(p, C)))))))) );\n    //if (d < 0.04) { return 1.0 - smoothstep(0.025, 0.034, d); };\n        \n    B+=(B-((A+C)*0.5));\t\t//Made the curve pass through the points\n    F+=(F-((C+G)*0.5));\n    H+=(H-((G+I)*0.5));\n    K+=(K-((I+A)*0.5));\n    \n    // Get the signed distance to bezier curve\n    d = sdBezier(A, B, C, p);\n    float d2 = sdBezier(C,F,G, p);\n    float d3 = sdBezier(G,H,I, p);\n    float d4 = sdBezier(I,K,A, p);\n       \n    float spSign =polySpline(p,A,B,C,F,G,H,I,K);\n    \n    d=min(abs(d),min(abs(d2),min(abs(d3),abs(d4))));\n    if (spSign<=0.){\n        d=-d;\n    }\n    return d;\n}\n\nfloat leftBottomLip(vec2 p) {\n    vec2 A = vec2(-1., 0.);\n    vec2 B= vec2(-1.5,0.3);\n    vec2 C = vec2(-.975, -0.4);\n    \n    // Render the control points\n    float d = min(distance(p,B),min(distance(p, A),distance(p, C)));\n    //if (d < 0.04) { return 1.0 - smoothstep(0.025, 0.034, d); };\n      \n    B+=(B-((A+C)*0.5));\t\t//Made the curve pass through the points\n    \n    // Get the signed distance to bezier curve\n    d = sdBezier(A, B, C, p);\n    \n    float spSign =smallPolySpline(p,A,B,C);\n    \n    d=abs(d);\n    if (spSign<=0.){\n        d=-d;\n    }\n    return d;\n}\n\nfloat rightBottomLip(vec2 p) {\n    vec2 A = vec2(.3, -0.3);\n    vec2 B= vec2(.8,-0.1);\n    vec2 C = vec2(1.5, 0.4);\n    \n    vec2 F = vec2(1.2, -.1);\n    vec2 G= vec2(.8,-.5);\n    vec2 H = vec2(.2, -.8);\n    \n    \n    // Render the control points\n    float d = min(distance(p,H),min(distance(p,G),min(distance(p,F),min(distance(p,B),min(distance(p, A),distance(p, C))))));\n    //if (d < 0.04) { return 1.0 - smoothstep(0.025, 0.034, d); };\n      \n    B+=(B-((A+C)*0.5));\t\t//Made the curve pass through the points\n    F+=(F-((C+G)*0.5));\n    H+=(H-((G+A)*0.5));\n    \n    // Get the signed distance to bezier curve\n    d = sdBezier(A, B, C, p);\n    float d2 = sdBezier(C,F,G, p);\n    float d3 = sdBezier(G,H,A, p);\n    \n    float spSign = middlePolySpline(p,A,B,C,F,G,H);\n    \n    d=d=min(abs(d),min(abs(d2),abs(d3)));\n    if (spSign<=0.){\n        d=-d;\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Flip horizontally\n    vec2 flippedFragCoord = vec2(iResolution.x - fragCoord.x, fragCoord.y);\n    \n    vec2 p = (2.0*flippedFragCoord.xy-iResolution.xy)/iResolution.y;\n    float d = upperLip((p+vec2(.0,-.1)) * 1.25);\n    float d2 = tongue((p+vec2(-.35,.8))*.85);\n    float d3 = leftBottomLip((p+vec2(.38,.04))*2.);\n    float d4 = rightBottomLip((p+vec2(-.28,-.1))*1.75);\n    d = max(d4,max(d3,max(d,d2)));\n\n    // Define your desired blue color\n    vec4 black = vec4(0.0,0.0,0.0,1.0);\n    vec4 yellow = vec4(0.956,0.909,0.471,1.0);\n\n    // If d < 0, fragColor is black, otherwise it's blue\n    fragColor = sign(d) < 0.0 ? yellow : black;\n}\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float rightArm(vec2 p) {\n    vec2 A=vec2(-1.1,0.2);\n    vec2 B=vec2(-1.25, 0.4);\n    vec2 C=vec2(-1.0, 0.5);\n    \n    vec2 F=vec2(-0.8,0.2);\n    vec2 G=vec2(-.95,-.55);\n    vec2 H=vec2(-1.1,-.65);\n    \n    vec2 I = vec2(-1.25, -.54);\n    vec2 K = vec2(-1.15, -.2);\n    \n    // Render the control points\n    float d = min(distance(p,K),min(distance(p,I),min(distance(p,H),min(distance(p,G), min(distance(p,B),   min(distance(p, A),(min(distance(p, F),distance(p, C)))))))) );\n    //if (d < 0.04) { return 1.0 - smoothstep(0.025, 0.034, d); };\n        \n    B+=(B-((A+C)*0.5));\t\t//Made the curve pass through the points\n    F+=(F-((C+G)*0.5));\n    H+=(H-((G+I)*0.5));\n    K+=(K-((I+A)*0.5));\n    \n    // Get the signed distance to bezier curve\n    d = sdBezier(A, B, C, p);\n    float d2 = sdBezier(C,F,G, p);\n    float d3 = sdBezier(G,H,I, p);\n    float d4 = sdBezier(I,K,A, p);\n       \n    float spSign =polySpline(p,A,B,C,F,G,H,I,K);\n    \n    d=min(abs(d),min(abs(d2),min(abs(d3),abs(d4))));\n    if (spSign<=0.){\n        d=-d;\n    }\n    return d;\n}\n\nfloat leftArm(vec2 p) {\n    vec2 A=vec2(.275,0.5);\n    vec2 B=vec2(.6,-0.);\n    vec2 C=vec2(.45,-0.5);\n    \n    vec2 F=vec2(.5,-0.52);\n    vec2 G=vec2(.7,-.55);\n    vec2 H=vec2(.7,.3);\n\n    // Render the control points\n    float d = min(distance(p,H),min(distance(p,G),min(distance(p,B),min(distance(p, A),(min(distance(p, F),distance(p, C)))))));\n    //if (d < 0.04) { return 1.0 - smoothstep(0.025, 0.034, d); };\n        \n    B+=(B-((A+C)*0.5));\t\t//Made the curve pass through the points\n    F+=(F-((C+G)*0.5));\n    H+=(H-((G+A)*0.5));\n    \n    // Get the signed distance to bezier curve\n    d = sdBezier(A, B, C, p);\n    float d2 = sdBezier(C,F,G, p);\n    float d3 = sdBezier(G,H,A, p);\n       \n    float spSign = middlePolySpline(p,A,B,C,F,G,H);\n    \n    d=min(abs(d),min(abs(d2),abs(d3)));\n    if (spSign<=0.){\n        d=-d;\n    }\n    return d;\n}\n\nfloat sweatFirst(vec2 p) {\n    vec2 A = vec2(.105, .035);\n    vec2 B= vec2(.105,-.1);\n    vec2 C = vec2(.275, -.05);\n    \n    vec2 F = vec2(.45, -.0);\n    vec2 G= vec2(.45, -.0);\n    vec2 H = vec2(.25, .1);\n    \n    \n    // Render the control points\n    float d = min(distance(p,H),min(distance(p,G),min(distance(p,F),min(distance(p,B),min(distance(p, A),distance(p, C))))));\n    //if (d < 0.04) { return 1.0 - smoothstep(0.025, 0.034, d); };\n      \n    B+=(B-((A+C)*0.5));\t\t//Made the curve pass through the points\n    F+=(F-((C+G)*0.5));\n    H+=(H-((G+A)*0.5));\n    \n    // Get the signed distance to bezier curve\n    d = sdBezier(A, B, C, p);\n    float d2 = sdBezier(C,F,G, p);\n    float d3 = sdBezier(G,H,A, p);\n    \n    float spSign = middlePolySpline(p,A,B,C,F,G,H);\n    \n    d=d=min(abs(d),min(abs(d2),abs(d3)));\n    if (spSign<=0.){\n        d=-d;\n    }\n    return d;\n}\n\nmat2 rot(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    float d = rightArm((p+vec2(-0.225,0.05))*.975);\n    float d2 = leftArm((p+vec2(-.21,-0.025))*1.);\n    float d3 = sweatFirst((p+vec2(1.3,-.51))*1.2);\n    \n     // Define your rotation angle\n    float angle = radians(-45.0); // for a 45 degree rotation\n\n    // Calculate d3 with rotation\n    vec2 rotatedP = rot(angle) * (p+vec2(1.05,-.925))*1.2;\n    float d4 = sweatFirst(rotatedP*1.);\n    d = max(d4,max(d3,max(d,d2)));\n    \n    //Visualize the distance field using iq's orange/blue scheme\n    //fragColor = vec4(1.0) - sign(d)*vec4(1.,1.1,1.1,1.0);\n    //fragColor = mix(fragColor, vec4(1.0), 1.0-smoothstep(0.0,0.02,abs(d)) );\n    \n        // Define your desired blue color\n    vec4 black = vec4(0.0,0.0,0.0,1.0);\n    vec4 yellow = vec4(0.956,0.909,0.471,1.0);\n\n    // If d < 0, fragColor is black, otherwise it's blue\n    fragColor = sign(d) < 0.0 ? yellow : black;\n}\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"float torse(vec2 p) {\n    vec2 A = vec2(-1.25, -0.1);\n    vec2 B= vec2(-1.45,0.55);\n    vec2 F = vec2(-.95, .9);\n    \n    vec2 C=vec2(-.95, 0.8);\n    vec2 G=vec2(-0.2,.9);\n    vec2 H=vec2(-0.1,.875);\n    \n    vec2 I = vec2(.24, .725);\n    vec2 K = vec2(-.2, -.05);\n    \n    // Render the control points\n    float d = min(distance(p,K),min(distance(p,I),min(distance(p,H),min(distance(p,G), min(distance(p,B),   min(distance(p, A),(min(distance(p, F),distance(p, C)))))))) );\n    //if (d < 0.04) { return 1.0 - smoothstep(0.025, 0.034, d); };\n        \n    B+=(B-((A+C)*0.5));\t\t//Made the curve pass through the points\n    F+=(F-((C+G)*0.5));\n    H+=(H-((G+I)*0.5));\n    K+=(K-((I+A)*0.5));\n    \n    // Get the signed distance to bezier curve\n    d = sdBezier(A, B, C, p);\n    float d2 = sdBezier(C,F,G, p);\n    float d3 = sdBezier(G,H,I, p);\n    float d4 = sdBezier(I,K,A, p);\n       \n    float spSign =polySpline(p,A,B,C,F,G,H,I,K);\n    \n    d=min(abs(d),min(abs(d2),min(abs(d3),abs(d4))));\n    if (spSign<=0.){\n        d=-d;\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Flip horizontally\n    vec2 flippedFragCoord = vec2(iResolution.x - fragCoord.x, fragCoord.y);\n    \n    vec2 p = (2.0*flippedFragCoord.xy-iResolution.xy)/iResolution.y;\n    float d = torse(p);\n    \n    // Define your desired blue color\n    vec4 black = vec4(0.0,0.0,0.0,1.0);\n    vec4 yellow = vec4(0.956,0.909,0.471,1.0);\n\n    // If d < 0, fragColor is black, otherwise it's blue\n    fragColor = sign(d) < 0.0 ? yellow : black;\n}\n\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XdfGR8","channel":0}],"code":"float rightFoot(vec2 p) {\n    vec2 A = vec2(.0, -0.35);\n    vec2 B= vec2(.8,-0.);\n    vec2 C = vec2(1.5, -0.4);\n    \n    vec2 F = vec2(1.6, -.95);\n    vec2 G= vec2(.9,-.5);\n    vec2 H = vec2(.2, -.7);\n    \n    \n    // Render the control points\n    float d = min(distance(p,H),min(distance(p,G),min(distance(p,F),min(distance(p,B),min(distance(p, A),distance(p, C))))));\n    //if (d < 0.04) { return 1.0 - smoothstep(0.025, 0.034, d); };\n      \n    B+=(B-((A+C)*0.5));\t\t//Made the curve pass through the points\n    F+=(F-((C+G)*0.5));\n    H+=(H-((G+A)*0.5));\n    \n    // Get the signed distance to bezier curve\n    d = sdBezier(A, B, C, p);\n    float d2 = sdBezier(C,F,G, p);\n    float d3 = sdBezier(G,H,A, p);\n    \n    float spSign = middlePolySpline(p,A,B,C,F,G,H);\n    \n    d=d=min(abs(d),min(abs(d2),abs(d3)));\n    if (spSign<=0.){\n        d=-d;\n    }\n    return d;\n}\n\nfloat leftFoot(vec2 p) {\n    vec2 A = vec2(.0, -0.55);\n    vec2 B= vec2(.7,-0.1);\n    vec2 C = vec2(1.5, -0.5);\n    \n    vec2 F = vec2(1.4, -.8);\n    vec2 G= vec2(.8,-.5);\n    vec2 H = vec2(.2, -.7);\n    \n    \n    // Render the control points\n    float d = min(distance(p,H),min(distance(p,G),min(distance(p,F),min(distance(p,B),min(distance(p, A),distance(p, C))))));\n    //if (d < 0.04) { return 1.0 - smoothstep(0.025, 0.034, d); };\n      \n    B+=(B-((A+C)*0.5));\t\t//Made the curve pass through the points\n    F+=(F-((C+G)*0.5));\n    H+=(H-((G+A)*0.5));\n    \n    // Get the signed distance to bezier curve\n    d = sdBezier(A, B, C, p);\n    float d2 = sdBezier(C,F,G, p);\n    float d3 = sdBezier(G,H,A, p);\n    \n    float spSign = middlePolySpline(p,A,B,C,F,G,H);\n    \n    d=d=min(abs(d),min(abs(d2),abs(d3)));\n    if (spSign<=0.){\n        d=-d;\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Flip horizontally\n    vec2 flippedFragCoord = vec2(iResolution.x - fragCoord.x, fragCoord.y);\n    \n    vec2 p = (2.0*flippedFragCoord.xy-iResolution.xy)/iResolution.y;\n    float d = rightFoot((p+vec2(.8,.4))*2.);\n    float d2 = leftFoot((p+vec2(.7,.15))*2.5);\n    d = max(d,d2);\n    \n    // Define your desired blue color\n    vec4 black = vec4(0.0,0.0,0.0,1.0);\n    vec4 yellow = vec4(0.956,0.909,0.471,1.0);\n\n    // If d < 0, fragColor is black, otherwise it's blue\n    fragColor = sign(d) < 0.0 ? yellow : black;\n}\n\n","name":"Buffer D","description":"","type":"buffer"}]}