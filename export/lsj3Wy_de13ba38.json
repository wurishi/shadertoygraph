{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define PI 3.14159265358979323846\n\n// Presets\nconst int pattern = 0; // 0: stripes, 1: checkerboard, 2: texture\n//\n\nfloat hash(float x)\n{\n    return fract(sin(x) * 43758.5453) * 2.0 - 1.0;\n}\nvec2 hashPosition(float x)\n{\n\treturn vec2(hash(x), hash(x * 1.1))*2.0-1.0;\n}\n\nbool xor(bool a, bool b) {\n\treturn (a && !b) || (!a && b);\n}\nfloat checkerBoardPattern(vec2 p) { // p in [0,1]x[0,1]\n\tbool x = p.x<0.5;\n\tbool y = p.y<0.5;\n\treturn ( xor(x,y) ) ? 1.:0.;\n}\n\nfloat stripes(vec2 p) {\n\tfloat aa = 0.02;\n\tfloat xVal = + smoothstep(0.0-aa, 0.0+aa, p.x)\n\t\t         + (1.0 - smoothstep(0.5-aa, 0.5+aa, p.x))\n\t\t         + smoothstep(1.0-aa, 1.0+aa, p.x);\n\treturn xVal-1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = (fragCoord.xy - 0.5*iResolution.xy) / iResolution.y;\n\t\n\t// move the center around\n\tr += vec2(0.35,0.0)*sin(0.92*sin(2.1*iTime)+0.2);\n\tr += vec2(0.0,0.5)*cos(0.45*iTime+0.3);\t\n\n\t// polar coordinates\n\tfloat mag = length(r);\n\tfloat angle = atan(r.y,r.x)/PI;\n\n\tfloat side = 1.0;\n\tfloat val = 0.0;\n\tif(pattern == 0) {\n\t\tvec2 tunnel = vec2(0.3/mag, angle);\n\t\ttunnel += vec2(2.5*iTime, 0.0);//forward speed and angular speed\t\t\n\t\tval = stripes(mod(tunnel, side));\n\t} else if(pattern == 1) {\n\t\tvec2 tunnel = vec2(0.8/mag, 5.*angle+2.*mag);\n\t\ttunnel += vec2(2.5*iTime,0.2*iTime);\t\t\n\t\tval = checkerBoardPattern(mod(tunnel, side));\n\t} else if (pattern == 2) {\n\t\tvec2 tunnel = vec2(0.3/mag, 2.*angle);\n\t\ttunnel += vec2(2.5*iTime,0.2*iTime);\t\t\n\t\tval = texture(iChannel0, tunnel*1.0).x;\n\t}\n\t// yellow and black colors\n\tvec3 color = mix(vec3(1.0,1.0,0.0), vec3(0.0,0.0,0.0), val);\n\t\n\t// the light ring that goes into the tunnel\n\tfloat signalDepth = pow(mod(1.5 - 0.9*iTime, 4.0),2.0);\n\tfloat s1 = signalDepth*0.9;\n\tfloat s2 = signalDepth*1.1;\n\tfloat dd = 0.05;\n\tcolor += 0.5*smoothstep(s1-dd,s1+dd, mag)*(1.0-smoothstep(s2-dd,s2+dd,mag))*vec3(1.0,1.0,0.5);\n\t\n\tcolor -= (1.0-smoothstep(0.0, 0.2, mag)); // shadow at the end of the tunnel\n\tcolor *= smoothstep( 1.8, 0.15, mag ); // vignette\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lsj3Wy","date":"1393169178","viewed":369,"name":"Study 7: Tunnel Effect","username":"vug","description":"The classic tunnel effect","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""}}