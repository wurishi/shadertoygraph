{"ver":"0.1","info":{"id":"MclBRn","date":"1723263798","viewed":26,"name":"Acumulation test 4","username":"pkncoder","description":"Played with specular reflections, lighting, and different values for bounce numbers.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","reflections","pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    fragColor = vec4(color, 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"precision highp float;\n\n#define time iTime * 10.0\n#define PI 3.14159265359\n\nstruct RayTracingMaterial {\n    vec3 color;\n    vec3 specularColor;\n    float emmisive;\n    float smoothness;\n    float specularProbability;\n};\n\nstruct Sphere {\n    vec3 coords;\n    float radius;\n    RayTracingMaterial material;\n};\n\nstruct HitInfo {\n    bool hit;\n    vec3 hitPos;\n    float dist;\n    vec3 normal;\n    RayTracingMaterial material;\n};\n\nstruct Ray {\n    vec3 orgin;\n    vec3 direction;\n};\n\nstruct Box {\n    vec3 orgin;\n    vec3 boxSize;\n    RayTracingMaterial material;\n};\n\nHitInfo intersect(Ray ray, Sphere sphere) {\n    HitInfo hit;\n\n    hit.hit = false;\n\n    vec3 rayOffset = ray.orgin - sphere.coords;\n\n    float a = dot(ray.direction, ray.direction);\n    float b = dot(rayOffset, ray.direction);\n    float c = dot(rayOffset, rayOffset) - sphere.radius * sphere.radius;\n\n    float det = b * b - a * c;\n\n    if (det < 0.0) {return hit;}\n\n    float t0 = (-b - sqrt(det)) / (a);\n\n    if (t0 < 0.0) {\n        return hit;\n    }\n\n    hit.hit = true;\n    hit.hitPos = ray.orgin + ray.direction * t0;\n    hit.dist = t0;\n    hit.normal = normalize(hit.hitPos - sphere.coords);\n    hit.material = sphere.material;\n\n    return hit;\n}\n\n//https://iquilezles.org/articles/intersectors/\n// axis aligned box centered at the origin, with size box.boxSize\nHitInfo intersect( Ray ray, Box box ) \n{\n\n    HitInfo hit;\n    hit.hit = false;\n\n    vec3 m = 1./ray.direction;\n    vec3 n = m*(ray.orgin - box.orgin);\n    vec3 k = abs(m) * box.boxSize;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.) return hit;\n    \n    float t = tN < 0.1 ? tF : tN;\n\n    hit.hit = true;\n    hit.hitPos = ray.orgin + ray.direction * t;\n    hit.dist = t;\n    hit.normal = -sign(ray.direction)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);;\n    hit.material = box.material;\n\n    return hit;\n}\n\nmat2 rot2D(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nint NextRandom(inout int state)\n{\n    state = state * 747796405 + 2891336453;\n    int result = ((state >> ((state >> 28) + 4)) ^ state) * 277803737;\n    result = (result >> 22) ^ result;\n    return result;\n}\n\nfloat RandomValue(inout int state)\n{\n    return float(NextRandom(state)) / 4294967295.0; // 2^32 - 1\n}\n\n// Random value in normal distribution (with mean=0 and sd=1)\nfloat RandomValueNormalDistribution(inout int state)\n{\n    // Thanks to https://stackoverflow.com/a/6178290\n    float theta = 2.0 * 3.1415926 * RandomValue(state);\n    float rho = sqrt(-2.0 * log(RandomValue(state)));\n    return rho * cos(theta);\n}\n\n// Calculate a random direction\nvec3 RandomDirection(inout int state)\n{\n    // Thanks to https://math.stackexchange.com/a/1585996\n    float x = RandomValueNormalDistribution(state);\n    float y = RandomValueNormalDistribution(state);\n    float z = RandomValueNormalDistribution(state);\n    return normalize(vec3(x, y, z));\n}\n\nHitInfo calculateClosestHit(Ray ray, int depth) {\n\n    Sphere[3] spheres;\n    //Box[7] boxes;\n\n    spheres[0] = Sphere(\n        vec3(-40.0, 20.0, 120.0),\n        60.0,\n        RayTracingMaterial(\n            vec3(1.0),\n            vec3(1.0),\n            10.0,\n            0.0,\n            0.0\n        )\n    );\n\n    spheres[1] = Sphere(\n        vec3(0.0, -20.0, 3.0),\n        20.0,\n        RayTracingMaterial(\n            vec3(0.2863, 0.2745, 1.0),\n            vec3(0.2863, 0.2745, 1.0),\n            0.0,\n            0.0,\n            0.0\n        )\n    );\n\n    spheres[2] = Sphere(\n        vec3(0.0, 3.0, 5.0),\n        3.0,\n        RayTracingMaterial(\n            vec3(0.9333, 0.2, 1.0),\n            vec3(0.9333, 0.2, 1.0),\n            0.0,\n            0.3,\n            0.02\n        )\n    );\n\n    HitInfo closestHit;\n    closestHit.hit = false;\n    closestHit.dist = 800000.0;\n\n    for (int i = 0; i < spheres.length(); i++) {\n        HitInfo sphereHit = intersect(ray, spheres[i]);\n\n        if (sphereHit.hit && sphereHit.dist < closestHit.dist) {\n            closestHit = sphereHit;\n        }\n    }\n    \n    return closestHit;\n}\n\nvec3 trace(Ray ray, int rngState) {\n    int numBounces = 100;\n\n    vec3 colorMult = vec3(1.0);\n    vec3 color = vec3(0.0);\n\n    for (int b = 0; b <= numBounces; b++) {\n\n        HitInfo closestHit = calculateClosestHit(ray, b);\n\n        rngState += b * -19485;\n\n        if (!closestHit.hit) {\n            break;\n        }\n\n        // check\n        vec3 offset = (closestHit.normal + RandomDirection(rngState));\n\n        if (dot(closestHit.normal, offset) < 0.0) {\n            offset = -offset;\n        }\n\n        // Figure out new ray position and direction\n\t\tfloat isSpecularBounce = 0.0;\n        \n        if (closestHit.material.specularProbability >= RandomValue(rngState)) {\n            isSpecularBounce = 1.0;\n        }\n\n        // check\n        ray.orgin = closestHit.hitPos + closestHit.normal * 0.1;\n\n        vec3 diffuseDirection = normalize(offset);\n        vec3 specularDirection = reflect(ray.direction, closestHit.normal);\n\n        ray.direction = normalize(mix(diffuseDirection, specularDirection, closestHit.material.smoothness * isSpecularBounce));\n\n        vec3 emittedLight = closestHit.material.emmisive * closestHit.material.color;\n        color += emittedLight * colorMult;\n        colorMult *= mix(closestHit.material.color, closestHit.material.specularColor, vec3(isSpecularBounce));\n\n        float rolette = max(colorMult.r, max(colorMult.g, colorMult.b));\n\n        if (rolette < 0.1) {\n            break;\n        }\n    }\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = ((fragCoord.xy / iResolution.xy) * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n    \n    float angle = tan((PI * 0.5 * 30.0) / 180.0);\n    vec2 xy = vec2(angle, angle);\n    uv *= xy;\n    \n    Ray ray = Ray(\n        vec3(-8.0, 0.0, -70.0),\n        normalize(vec3(uv, 1.0))\n    );\n    \n    float mouseModifier = 1.0;\n    \n    if (true) {\n        ray.orgin.xz *= rot2D(-1.0 * mouseModifier);\n        ray.direction.xz *= rot2D(-1.0 * mouseModifier);\n\n        ray.orgin.yz *= rot2D(0.0 * mouseModifier);\n        ray.direction.yz *= rot2D(0.0 * mouseModifier);\n    }\n    \n    int pixelIndex = int(fragCoord.y * iResolution.x + fragCoord.x);\n\tint rngState = int((float(pixelIndex) + time * -719393.0));\n\n    vec3 color = vec3(0.0);\n    \n    for (int r = 0; r < 100; r++) {\n        color += trace(ray, rngState + int(pow(float(r), 3.0)));\n    }\n    color = pow(color / 100.0, vec3(1.0 / 2.2));\n    \n    // average the frames together\n    vec3 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    color = mix(lastFrameColor, color, 1.0f / float(iFrame+1));\n\n    fragColor = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}