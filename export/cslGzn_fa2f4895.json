{"ver":"0.1","info":{"id":"cslGzn","date":"1666249702","viewed":122,"name":"Extruded Convolutional CA","username":"Envy24","description":"Description: https://neuralpatterns.io/\nHold LMB and drag to add noise.\n\nBufferA - Convolutional CA\nBufferB - Temporal blur (source: https://www.shadertoy.com/view/Dsl3Rn)\nImage  - Extrusion, Light, Color (source: https://www.shadertoy.com/view/Dsl3Rn)","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["cellular","convolutional","automat"],"hasliked":0,"parentid":"7s3yzn","parentname":"Convolutional Cellular Automat"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* More cellular automats: https://www.shadertoy.com/playlist/fXVSRy */\n\nvec2 grad(vec2 TC, float d)\n{\n    vec2 delta = vec2(d, 0);\n    return \n        vec2(TEX0(TC + delta.xy).x - TEX0(TC - delta.xy).x,\n             TEX0(TC + delta.yx).x - TEX0(TC - delta.yx).x);\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    /*Calculate diffuse light.*/\n    vec3 light_dir = normalize(vec3(1,-1,1));\n    vec2 gradient = grad(TO_TEX_COORDS(SC), 1./R.y);    \n    vec3 normal = normalize(vec3(gradient, 1.));\n    float diffuse = dot(normal, light_dir);\n    /**/\n    float saturation = 3.;  \n    vec3 color = mix(vec3(0.2,0.2,0.2), vec3(0.0,0.6,1), TEXF0(SC).rgb * saturation);  \n    \n    O = vec4(color * diffuse, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define ALIVE true\n#define DEAD  false\n#define READ_CELL(P) (TEX0(TO_TEX_COORDS(P)).r)\n\nconst int kernel_row_size = 7; // 3 minimum!\nconst int kernel_size = kernel_row_size * kernel_row_size;\nfloat kernel[kernel_size];\n\nfloat randomize_kernel(\n    int seed,\n    inout float[kernel_size] kernel,\n    int kernel_size)\n{\n    float weight = 0.0;\n    for (int s = 0; s < kernel_size; ++s)\n    {\n        kernel[s] = signedSample1DHashUI32(uint(seed + s));\n        weight += abs(kernel[s]);\n    }\n    \n    return weight; // if you want to normalize kernel.\n}\n\nfloat randomize_kernel_with_central_symmetry(\n    int seed,\n    inout float[kernel_size] kernel,\n    int kernel_size)\n{\n    const int h = kernel_row_size >> 1;\n    const int e = kernel_row_size - 1;\n    \n    float weight = 0.0;\n    \n\tint y = 0;\n\tint x = 0;\n    int offset = 0;\n\n\twhile (y != h && x != h)\n\t{\n\t\tfor (int l = x, r = e - x; l < r; ++l, --r)\n\t\t{\n\t\t\toffset = y * kernel_row_size + l;\n\n\t\t\tkernel[offset] = signedSample1DHashUI32(uint(seed + offset));\n\t\t\tkernel[y * kernel_row_size + r] = kernel[offset];\n\t\t\tkernel[(e - y) * kernel_row_size + l] = kernel[offset];\n\t\t\tkernel[(e - y) * kernel_row_size + r] = kernel[offset];\n\n\t\t\tkernel[l * kernel_row_size + y] = kernel[offset];\n\t\t\tkernel[r * kernel_row_size + y] = kernel[offset];\n\t\t\tkernel[l * kernel_row_size + (e - y)] = kernel[offset];\n\t\t\tkernel[r * kernel_row_size + (e - y)] = kernel[offset];\n            \n            weight += kernel[offset] * 8.;\n\t\t}\n\n\t\t++y; ++x;\n\t}\n\n\twhile (y >= 0)\n\t{\n\t\toffset = y * kernel_row_size + x;\n\n\t\tkernel[offset] = signedSample1DHashUI32(uint(seed + offset));\n\n\t\tkernel[(e - y) * kernel_row_size + x] = kernel[offset];\n\t\tkernel[x * kernel_row_size + y] = kernel[offset];\n\t\tkernel[x * kernel_row_size + (e - y)] = kernel[offset];\n        \n        weight += kernel[offset] * 4.;\n\n\t\t--y;\n\t}\n\n    offset = h * kernel_row_size + h;\n\tkernel[offset] = signedSample1DHashUI32(uint(seed + offset));\n\n    return weight + kernel[offset];\n}\n\nfloat convoluion(vec2 SC,\n    float[kernel_size] kernel,\n    int kernel_row_size)\n{\n    float weighted_sum = 0.0;\n    int k = kernel_row_size >> 1;\n    int r_offset = 0;\n    \n    for (int y = -k; y <= k; ++y)\n    {\n        for (int x = k; x >= -k; --x)\n        {      \n             weighted_sum += READ_CELL(SC + vec2( x,  y)) * kernel[r_offset];\n             \n             ++r_offset;\n        }\n    }\n    \n    return weighted_sum;\n}\n\nfloat init_one_pixel_in_center(vec2 SC)\n{\n    SC = floor(SC);\n    vec2 M = vec2(floor(R.x * 0.5), floor(R.y * 0.5));\n    return \n        SC.y == M.y && SC.x == M.x ?\n            0.0 :\n            1.0;\n}\n\n\nfloat randomize_part_of_frame(\n    in vec2 SC,\n    float amount)  // in range [0.0; 1.0]\n{\n    vec2 C = R.xy * 0.5;\n    vec2 Offset = C * amount;\n    \n    float hash = step(fract(sin(dot(SC, vec2(127.1,311.7))) * 43758.5453123), 0.5);\n\n    return \n       (SC.x > (C.x - Offset.x) &&\n        SC.x < (C.x + Offset.x) &&\n        SC.y > (C.y - Offset.y) &&\n        SC.y < (C.y + Offset.y)) == true ?\n            hash :\n            1.0;\n}\n\n/* Scenes */\n\nfloat random(in vec2 SC)\n{\n    float transition_number = 0.0;\n    \n    // Reinit every N frames.\n    bool s = transition(iFrame, 100, transition_number);\n    \n    transition(iFrame, 50, transition_number);\n    \n    randomize_kernel_with_central_symmetry(int(778. + transition_number), kernel, kernel_size);\n    //randomize_kernel(int(transition_number * 1000.0), kernel, kernel_size);\n    //float weighted_sum = convoluion(SC, kernel, kernel_row_size);\n    float weighted_sum = 5.0 * convoluion(SC, kernel, kernel_row_size);\n       \n    /* Sources: https://en.wikipedia.org/wiki/Activation_function\n                https://neuralpatterns.io/ */\n    \n    //weighted_sum = step(0.5, weighted_sum);\n    //weighted_sum = 1. / (1. + exp(-weighted_sum));\n    //weighted_sum = max(0., weighted_sum);\n    //weighted_sum = log(1. + exp(weighted_sum));\n    //weighted_sum = sin(weighted_sum);\n    //weighted_sum = tanh(weighted_sum);\n    //weighted_sum = (1. -cos(weighted_sum)) * 0.5;\n    //weighted_sum = exp(-weighted_sum *weighted_sum);\n    //weighted_sum = -1./ pow(2., weighted_sum *weighted_sum) + 1.;\n    //float a = 1.0507;  weighted_sum = weighted_sum <= 0. ? a * (exp(weighted_sum) - 1.) : weighted_sum;\n    //float a = 1.0507, g = 1.67326;  weighted_sum = g * (weighted_sum <= 0. ? a * (exp(weighted_sum) - 1.) : weighted_sum);\n    //weighted_sum = weighted_sum <= 0. ? 0.001 * weighted_sum : weighted_sum;\n    //float a = 1.0507;  weighted_sum = weighted_sum <= 0. ? a * weighted_sum : weighted_sum;\n     \n    return \n         s == true ?\n            //randomize_part_of_frame(SC, 0.4) :\n            //1.0 :\n            sample1DHashUI32(uint(SC.y * R.y + SC.x)) :\n            //init_one_pixel_in_center(SC) :\n            clamp(weighted_sum, 0., 1.);\n}\n\nfloat worms(in vec2 SC)\n{\n    kernel[0] = 0.68; kernel[1] = -0.9; kernel[2] = 0.68;\n    kernel[3] = -0.9; kernel[4] = -0.66; kernel[5] = -0.9;\n    kernel[6] = 0.68; kernel[7] = -0.9; kernel[8] = 0.68;\n    \n    float weighted_sum = convoluion(SC, kernel, 3);\n    weighted_sum = -1./ pow(2., 0.6*weighted_sum *weighted_sum) + 1.;\n      \n    return \n        iFrame == 0 ?\n            sample1DHashUI32(uint(SC.y * R.y + SC.x)) :\n            clamp(weighted_sum, 0., 1.);\n}\n\nfloat slime_mold(in vec2 SC)\n{\n    kernel[0] = 0.8; kernel[1] = -0.85; kernel[2] = 0.8;\n    kernel[3] =-0.85; kernel[4] = -0.2; kernel[5] = -0.85;\n    kernel[6] = 0.8; kernel[7] = -0.85; kernel[8] = 0.8;\n    \n    float weighted_sum = convoluion(SC, kernel, 3);\n    weighted_sum = -1./ (0.89*weighted_sum *weighted_sum + 1.) + 1.;\n      \n    return \n        iFrame == 0 ?\n            sample1DHashUI32(uint(SC.y * R.y + SC.x)) :\n            clamp(weighted_sum, 0., 1.);\n}\n\nfloat waves(in vec2 SC)\n{\n    kernel[0] =  0.565; kernel[1] = -0.716; kernel[2] =  0.565;\n    kernel[3] = -0.716; kernel[4] =  0.627; kernel[5] = -0.716;\n    kernel[6] =  0.565; kernel[7] = -0.716; kernel[8] =  0.565;\n    \n    float weighted_sum = convoluion(SC, kernel, 3);\n    weighted_sum = abs(1.2 * weighted_sum);\n    \n    return \n        iFrame == 0 ?\n            sample1DHashUI32(uint(SC.y * R.y + SC.x)) :\n            clamp(weighted_sum, 0., 1.);\n}\n\nfloat defined_by_integer(in vec2 SC, int kernel_idx)\n{\n    //                                  kernel idx\n    // kernel_row_size = 7,                23\n    // kernel_row_size = 7,                46\n    // kernel_row_size = 7,                87\n    // kernel_row_size = 7,                89 !\n    // kernel_row_size = 7,                95   Maze\n    // kernel_row_size = 7,                100 \n    // kernel_row_size = 7,                159, then without reset 160 \n    randomize_kernel_with_central_symmetry(kernel_idx, kernel, kernel_size);   \n    float weighted_sum = convoluion(SC, kernel, kernel_row_size);\n       \n    return \n        iFrame == 0 ?\n            //init_one_pixel_in_center(SC) :\n            //randomize_part_of_frame(SC, 0.4) :\n            sample1DHashUI32(uint(SC.y * R.y + SC.x)) :\n            clamp(weighted_sum, 0., 1.);\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    /* Demo */\n    float s = 0.0;\n    switch ((iFrame % 4000) / 1000)\n    {\n    case 0: s = defined_by_integer(SC, 89); break;\n    case 1: s = worms(SC); break;\n    case 2: s = slime_mold(SC); break;\n    case 3: s = waves(SC); break;\n    default: break;\n    }\n    \n    O = vec4(s);\n    /* Demo */\n\n    //O = vec4(random(SC));\n    //O = vec4(defined_by_integer(SC, 95));\n    //O = vec4(worms(SC));\n    //O = vec4(slime_mold(SC));\n    //O = vec4(waves(SC));\n    \n    O = \n        LMB_IS_HOLD == true && length(iMouse.xy - SC) < 50. ?\n            vec4( sample1DHashUI32(uint(SC.y * R.y + SC.x+iTime)) ) :\n            O;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define R                           iResolution\n#define PIXEL_SIZE                  2.\n#define PIXELATE(SC)              ( floor( (SC) / (PIXEL_SIZE) ) * (PIXEL_SIZE) )\n#define TEX0(TC)                  ( texture(iChannel0, (TC)) )\n#define TEXF0(SC)                 ( texelFetch(iChannel0, ivec2(PIXELATE(SC)), 0) )  // (channel, integer coordinates, mipmap level)\n#define TEXF1(SC)                 ( texelFetch(iChannel1, ivec2(PIXELATE(SC)), 0) )  // (channel, integer coordinates, mipmap level)\n#define TO_TEX_COORDS(SC)         ( (SC) / (R.xy) )                        // in range x=[0.0; 1.0], y=[0.0; 1.0]\n#define NMX                       ( iMouse.x / R.x )                       // in range [0.0; 1.0]\n#define NMY                       ( iMouse.y / R.y )                       // in range [0.0; 1.0]\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n\n/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\n/* Every num_of_frame returns true \nand number of detected transitions. */\nbool transition(\n    in int frame,\n    in int numOfFrames,\n    inout float quotent)\n{\n    // Convert to float.\n    float f = float(frame);\n    float inv = 1.0 / float(numOfFrames);\n    \n    // Calculate previous and current quotents.\n    float qc = floor(f * inv);\n    quotent = floor((f - 1.0) * inv);\n    \n    return quotent < qc;\n}\n\nuint hashUI32(uint value)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint entropy0 = 12345u;\n    const uint entropy1 = 67890u;\n\n    // Calculate hash.\n\tvalue += entropy1;\n\tvalue *= 445593459u;\n\tvalue ^= entropy0;\n\n    return value * value * value;\n}\n\n/*\n    Returns hash in range [-1.0; 1.0].\n*/\nfloat signedSample1DHashUI32(uint value)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint entropy0 = 12345u;\n    const uint entropy1 = 67890u;\n\n    // Calculate hash.\n\tvalue += entropy1;\n\tvalue *= 445593459u;\n\tvalue ^= entropy0;\n\n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n    \n    return float(value * value * value) * 4.6566128730773926e-10 - 1.0f;\n}\n\n/*  \n    Returns hash in range [0.0; 1.0].\n*/\nfloat sample1DHashUI32(uint value)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint entropy0 = 12345u;\n    const uint entropy1 = 67890u;\n\n    // Calculate hash.\n\tvalue += entropy1;\n\tvalue *= 445593459u;\n\tvalue ^= entropy0;\n\n    // 1.0f / 4294967295.0f = 2.32830644e-10\n    \n    return float(value * value * value) * 2.32830644e-10;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 O, in vec2 SC )\n{\n    float t = 0.9;\n\n    O = \n        iFrame == 0 ?\n            vec4( 0 ) :\n            TEXF0(SC) * (1. - t) + TEXF1(SC) * t;\n}","name":"Buffer B","description":"","type":"buffer"}]}