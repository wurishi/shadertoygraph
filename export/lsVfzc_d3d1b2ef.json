{"ver":"0.1","info":{"id":"lsVfzc","date":"1529889676","viewed":385,"name":"Mandelbrot tentacles","username":"rory618","description":"By multiplying by a random complex number near 1 at each iteration, the point where bulbs meet distort to reveal tentacles. Also trying out performance optimization here, to hit constant fps on all platforms by adapting maxiter.","likes":8,"published":1,"flags":48,"usePreview":0,"tags":["2d","fractal","mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Fork of \"Montecarlo Fractal Explorer\" by rory618. https://shadertoy.com/view/4t3GWS\n// 2018-06-25 00:23:53\n\nconst vec2 viewportLoc = vec2(0.5,0.5);\nconst vec2 mouseLoc = vec2(0.5,1.5);\n\nvec4 load(vec2 a) {\n    return texture( iChannel0, (a) / iChannelResolution[0].xy, -100.0 );\n}\nvec2 uvtoc(vec2 center, vec2 up, vec2 right, vec2 uv ) {\n    return center + right * uv.x + up * uv.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 viewport = load(viewportLoc);\n    vec4 mouse = load(mouseLoc);\n    \n    vec2 center = viewport.xy;\n    vec2 up = viewport.zw;\n    vec2 right = vec2(up.y, -up.x) * iResolution.x / iResolution.y;\n    \n    vec2 p = uvtoc(center, up, right, 2.0*(uv-vec2(.5)));\n    \n    fragColor = texture(iChannel1, uv);\n   \n    \n    \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define I vec2(0,1)\n#define R vec2(1,0)\n#define PI 3.14159\n#define E 2.71828\n\n//cproj\nfloat creal(vec2 z) {\n    return z.x;\n}\nfloat cimag(vec2 z) {\n    return z.y;}\nvec2 conj(vec2 z) {\n    return vec2(z.x,-z.y);\n}\nvec2 cprod(vec2 a, vec2 b){\n    return vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);\n}\nvec2 csqr(vec2 a){\n    return cprod(a,a);\n}\nfloat cabs(vec2 z) {\n    return sqrt(cprod(z,conj(z)).x);\n}\nfloat cabs2(vec2 z) {\n    return cprod(z,conj(z)).x;\n}\nvec2 cinv(vec2 z){\n    return conj(z)/cabs2(z);\n}\nvec2 cdivide(vec2 a, vec2 b){\n    return cprod(a,cinv(b));\n                            }\nfloat carg(vec2 z) {\n    if(z.x<0.){\n        if(z.y>0.){\n    \t\treturn PI + atan(z.y/z.x);\n        } else {\n            return -PI + atan(z.y/z.x);\n        }\n    }\n    return atan(z.y/z.x);\n}\nvec2 cexp(vec2 z) {\n    return exp(z.x)*vec2(cos(z.y),sin(z.y));\n}\nvec2 clog(vec2 z) {\n    return R*log(cabs(z))+I*carg(z);\n}\nvec2 cpow(vec2 a, vec2 b) {\n    return cexp(cprod(b,clog(a)));\n}\nvec2 csqrt(vec2 z){\n    return cpow(z, .5*R);\n}\nvec2 csinh(vec2 z){\n    return (cexp(z)-cexp(-z))/2.;\n}\nvec2 ccosh(vec2 z){\n    return (cexp(z)+cexp(-z))/2.;\n}\nvec2 ctanh(vec2 z){\n    return cdivide(csinh(z),ccosh(z));\n}\nvec2 casinh(vec2 z){\n    return clog(z + csqrt(R + cprod(z,z)));\n}\nvec2 cacosh(vec2 z){\n    return clog(z + csqrt(z + R) + csqrt(z - R));\n}\nvec2 catanh(vec2 z){\n    return (clog(z + R) + clog(z - R))/2.;\n}\nvec2 csin(vec2 z){\n    return cprod(-I,csinh(cprod(I,z)));\n}\nvec2 ccos(vec2 z){\n    return ccosh(cprod(I,z));\n}\nvec2 ctan(vec2 z){\n    return cprod(-I,ctanh(cprod(I,z)));\n}\nvec2 casin(vec2 z){\n    return cprod(-I,casinh(cprod(I,z)));\n}\nvec2 cacos(vec2 z){\n    return R*PI/2.+cprod(I, clog(cprod(I,z) + csqrt(R + cprod(z,z))));\n}\nvec2 catan(vec2 z){\n    return cprod(-I,catanh(cprod(I,z)));\n}\nvec2 gammagth(vec2 z) {\n    return cprod(cpow(cprod(z/E,csqrt(cprod(z,csinh(cinv(z))))),z),csqrt(cdivide(R*2.*PI,z)));\n}\nvec2 gamma(vec2 z){\n    if(z.x<.5){\n        return cdivide(PI*R,cprod(csin(cprod(PI*R,z)), gammagth(R-z)));\n    } else {\n        return gammagth(z);\n    }\n}\n\n\nconst vec2 viewportLoc = vec2(0.5,0.5);\nconst vec2 mouseLoc = vec2(0.5,1.5);\n\nconst vec2 param1Loc = vec2(0.5,2.5);\nconst vec2 param2Loc = vec2(0.5,3.5);\nconst vec2 param3Loc = vec2(0.5,4.5);\nconst vec2 param4Loc = vec2(0.5,5.5);\nconst vec2 param5Loc = vec2(0.5,6.5);\n\nvec2 seed = vec2(0);\nvec2 seed2 = vec2(0);\nvec2 r1 = vec2(1);\nvec2 r2 = vec2(0);\nvec2 r3 = vec2(3);\nvec2 r4 = vec2(4);\n\nconst float KEY_W  = 87.5/256.0;\nconst float KEY_R  = 82.5/256.0;\n\nconst float KEY_0 = 48.5/256.0;\nconst float KEY_1 = 49.5/256.0;\nconst float KEY_2 = 50.5/256.0;\nconst float KEY_3 = 51.5/256.0;\nconst float KEY_4 = 52.5/256.0;\nconst float KEY_5 = 53.5/256.0;\n\nfloat smoothing = 40.0;\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n\nbool keyIsDown( float key ) {\n    return texture( iChannel2, vec2(key,0.25) ).x > .5;\n}\nvec4 load(vec2 a) {\n    return texture( iChannel0, (a) / iChannelResolution[0].xy, -100.0 );\n}\nvec2 uvtoc(vec2 center, vec2 up, vec2 right, vec2 uv ) {\n    return center + right * uv.x + up * uv.y;\n}\n/*vec2 cprod(vec2 a, vec2 b) {\n    return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);\n}*/\nvec2 sqr(vec2 z) {\n    return cprod(z,z);\n}\nvec2 cpowi(vec2 z, int i) {\n    float theta = atan(z.y/z.x);\n    if (z.x<0.0){\n        theta += 3.1415926;\n    }\n    return vec2(cos(float(i)*theta),sin(float(i)*theta))*pow(length(z),float(i));\n}\nvec2 cpowf(vec2 z, float f) {\n    float theta = atan(z.y/z.x);\n    if (z.x<0.0){\n        theta += 3.1415926;\n    }\n    return vec2(cos(f*theta),sin(f*theta))*pow(length(z),f);\n}\n\nvec2 start(vec2 c) {\n    return vec2(c);\n}\nvec2 loop(vec2 z, vec2 c) {\n    return sqr(z) + c;\n}\n\nbool bailout(vec2 z) {\n    return length(z) > 1e4;\n}\n\nfloat smoothMandelbrot(vec2 z, int i) {\n    return float(i) + 1. - log(log(length(z)))/log(2.0);\n}\n\nvec3 color(vec2 z, int i){\n    if(i==0){ return vec3(0.0); }\n    float c = smoothMandelbrot(z, i);\n    return vec3(\n        .5+.5*sin(5.1*log(c)),\n        .5+.5*sin(5.2*log(c)),\n        .5+.5*sin(5.3*log(c)));\n}\n\n#define MAX_ITER 2000\nvec3 iteratedFractal(vec2 c) {\n    vec2 z = start(c);\n    float load = texelFetch(iChannel0,ivec2(0),0).x;\n    for(int i = 0; i < int(load); i++) {\n        z = loop(z, cprod(c,vec2(1,0)+.01*sin(hash23(vec3(i))*iTime/3.)));\n        if (bailout(z)) {\n        \treturn vec3(z, i);\n        }\n    }\n    return vec3(z, 0);\n}\n\nvec4 image(vec2 p) {\n    vec3 f = iteratedFractal(p);\n    return vec4(color(f.xy,int(f.z)),1.0);\n}\n\n\n///////////////////////////////////////////////////////*/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n\tvec2 uv = (fragCoord.xy - vec2(.5) + hash23(vec3(fragCoord, iTime))) / iResolution.xy;\n    \n    \n    vec4 viewport = vec4(-.75,0.0,0.02,.02);\n    //vec4 mouse = load(mouseLoc);\n    \n    vec2 center = viewport.xy;\n    vec2 up = viewport.zw;\n    vec2 right = vec2(up.y, -up.x) * iResolution.x / iResolution.y;\n    \n    \n    vec2 p = uvtoc(center, up, right, 2.0*(uv-vec2(.5)));\n    if ( keyIsDown(KEY_R) || keyIsDown(KEY_W) || iFrame <= 1) {\n        fragColor = image(p);\n    } else {\n    \tfragColor = (1.0-1.0/smoothing)*texture(iChannel1, fragCoord / iResolution.xy) + (1.0/smoothing)*image(p);\n    }\n    \n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"ivec2 hash(ivec2 i){\n    ivec2 c = i*ivec2(961748927,314606869)+ivec2(3947586,435789);\n    for(int h = 0; h < 2; h++){\n        i = ivec2(i.x*i.x-i.y*i.y,2*i.x*i.y)+c;\n    }\n    return i;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float load = (iFrame==0)?1000.:texelFetch(iChannel0,ivec2(0),0).x;\n    float targetFPS = 59.;\n    float fr = iFrameRate/targetFPS;\n    \n    load*= pow(fr,.05);\n    \n    ivec2 t = ivec2(0);\n    //for(int i = 0; i < int(load); i++){\n    //    t=hash(t);\n    //}\n    float f = fragCoord.x<1.?iFrameRate:texelFetch(iChannel0,ivec2(fragCoord)-ivec2(1,0),0).w;\n    \n    float v = texelFetch(iChannel0,ivec2(fragCoord),0).w;\n    float x = texelFetch(iChannel0,ivec2(fragCoord),0).z;\n    v+=(f-x)/40.;\n    v*=.95;\n    fragColor = fragCoord.x<1.?vec4(load,0,x+v/40.,v):texelFetch(iChannel0,ivec2(fragCoord)-ivec2(1,0),0);\n    fragColor.y += (float(t.x));\n}","name":"Buf A","description":"","type":"buffer"}]}