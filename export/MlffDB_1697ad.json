{"ver":"0.1","info":{"id":"MlffDB","date":"1513139220","viewed":263,"name":"standing wave modes","username":"ws","description":"Vibrations of a circular membrane (https://en.wikipedia.org/wiki/Vibrations_of_a_circular_membrane)","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["waves","bessel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Bessel code taken from https://www.atnf.csiro.au/computing/software/gipsy/sub/bessel.c\n// Any errors in conversion are mine\n\n#define ACC 10.0\n#define BIGNO 1.0e10\n#define BIGNI 1.0e-10\n\nfloat bessj0( float x )\n/*------------------------------------------------------------*/\n/* PURPOSE: Evaluate Bessel function of first kind and order  */\n/*          0 at input x                                      */\n/*------------------------------------------------------------*/\n{\n   float ax,z;\n   float xx,y,ans,ans1,ans2;\n\n   if ((ax=abs(x)) < 8.0) {\n      y=x*x;\n      ans1=57568490574.0+y*(-13362590354.0+y*(651619640.7\n         +y*(-11214424.18+y*(77392.33017+y*(-184.9052456)))));\n      ans2=57568490411.0+y*(1029532985.0+y*(9494680.718\n         +y*(59272.64853+y*(267.8532712+y*1.0))));\n      ans=ans1/ans2;\n   } else {\n      z=8.0/ax;\n      y=z*z;\n      xx=ax-0.785398164;\n      ans1=1.0+y*(-0.1098628627e-2+y*(0.2734510407e-4\n         +y*(-0.2073370639e-5+y*0.2093887211e-6)));\n      ans2 = -0.1562499995e-1+y*(0.1430488765e-3\n         +y*(-0.6911147651e-5+y*(0.7621095161e-6\n         -y*0.934935152e-7)));\n      ans=sqrt(0.636619772/ax)*(cos(xx)*ans1-z*sin(xx)*ans2);\n   }\n   return ans;\n}\n\nfloat bessj1( float x )\n/*------------------------------------------------------------*/\n/* PURPOSE: Evaluate Bessel function of first kind and order  */\n/*          1 at input x                                      */\n/*------------------------------------------------------------*/\n{\n   float ax,z;\n   float xx,y,ans,ans1,ans2;\n\n   if ((ax=abs(x)) < 8.0) {\n      y=x*x;\n      ans1=x*(72362614232.0+y*(-7895059235.0+y*(242396853.1\n         +y*(-2972611.439+y*(15704.48260+y*(-30.16036606))))));\n      ans2=144725228442.0+y*(2300535178.0+y*(18583304.74\n         +y*(99447.43394+y*(376.9991397+y*1.0))));\n      ans=ans1/ans2;\n   } else {\n      z=8.0/ax;\n      y=z*z;\n      xx=ax-2.356194491;\n      ans1=1.0+y*(0.183105e-2+y*(-0.3516396496e-4\n         +y*(0.2457520174e-5+y*(-0.240337019e-6))));\n      ans2=0.04687499995+y*(-0.2002690873e-3\n         +y*(0.8449199096e-5+y*(-0.88228987e-6\n         +y*0.105787412e-6)));\n      ans=sqrt(0.636619772/ax)*(cos(xx)*ans1-z*sin(xx)*ans2);\n      if (x < 0.0) ans = -ans;\n   }\n   return ans;\n}\n\nfloat bessj( float n, float x )\n/*------------------------------------------------------------*/\n/* PURPOSE: Evaluate Bessel function of first kind and order  */\n/*          n at input x                                      */\n/* The function can also be called for n = 0 and n = 1.       */\n/*------------------------------------------------------------*/\n{\n   float    j, jsum, m;\n   float ax, bj, bjm, bjp, sum, tox, ans;\n\n   if (n < 0.) return 0.; // setdblank\n\n   ax=abs(x);\n   if (n == 0.)\n      return( bessj0(ax) );\n   if (n == 1.)\n      return( bessj1(ax) );\n      \n   if (ax == 0.0)\n      return 0.0;\n   else if (ax > float(n)) {\n      tox=2.0/ax;\n      bjm=bessj0(ax);\n      bj=bessj1(ax);\n      for (j=1.;j<n;j+=1.) {\n         bjp=j*tox*bj-bjm;\n         bjm=bj;\n         bj=bjp;\n      }\n      ans=bj;\n   } else {\n      tox=2.0/ax;\n      m=2.*((n+floor(sqrt(ACC*n)))/2.);\n      jsum=0.;\n      bjp=ans=sum=0.0;\n      bj=1.0;\n      for (j=m;j>0.;j-=1.) {\n         bjm=j*tox*bj-bjp;\n         bjp=bj;\n         bj=bjm;\n         if (abs(bj) > BIGNO) {\n            bj *= BIGNI;\n            bjp *= BIGNI;\n            ans *= BIGNI;\n            sum *= BIGNI;\n         }\n         if (jsum != 0.) sum += bj;\n         jsum=(jsum == 0.) ? 1. : 0.;\n         if (j == n) ans=bjp;\n      }\n      sum=2.0*sum-bj;\n      ans /= sum;\n   }\n   return  x < 0.0 && mod(n,2.) == 1. ? -ans : ans;\n}\n\n// Goal is to find the n_th (positive) zero of J_m\n// This is my homebrew zero finder, caveat emptor\n// Initial guess calibrated for 0<=m<=10, 1<=n<=5\nfloat GetLambda(float m, float n) {\n    float guess = -0.98368854 + 1.3045853*m + 3.4110198*n +\n        (-0.0134096)*m*m + (-0.0491151)*n*n + 0.04748184*m*n;\n    // Take 1 Newton steps, use d/dx J_m(x) = (m/x)*J_m(x) - J_{m+1}(x)\n    for (int i = 0; i < 1; i++) {\n        float numer = bessj(m, guess);\n        float denom = numer*m/guess - bessj(m+1., guess);\n        guess -= numer/denom;\n    }\n    return guess;\n}\n\n// calculate the height function for p in unit disc\n// m,n,lmda harmonics parameters, t is time parameter\n// height between 0 and 1\nfloat GetHeight(vec2 p, float m, float n, float lmda, float t) {\n\tfloat theta = m*atan(p.y,p.x);\n\treturn .5+.25*(cos(8.*t) + sin(8.*t))*bessj(m, lmda * length(p)) * (cos(theta)+sin(theta));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0 * (fragCoord.xy / iResolution.xy) - 1.0;\n\n    // m and n are the mode parameters\n\tfloat m,n;\n    if (uv.x < 0. && uv.y < 0.) { m = 2.; n = 1.; }\n    else if (uv.x < 0. && uv.y > 0.) { m = 0.; n = 2.; }\n    else if (uv.x > 0. && uv.y > 0.) { m = 1.; n = 3.; }\n    else { m = 2.; n = 3.; }\n    float lmda = GetLambda(m, n);\n\n    // Redo uv per quadrant\n    uv = 2.*vec2(mod(uv.x, 1.), mod(uv.y, 1.)) - vec2(1.);\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    float scale = 4.;\n    float time = 6.283185*float(iFrame)/480.;\n    mat3 rotate = mat3(cos(time),0.,-sin(time),0.,1.,0.,sin(time),0.,cos(time));\n\tvec3 ro = rotate*vec3( 2., 2., 2.);\n    vec3 center = vec3( 0.0, 0.5, 0.0 );\n\tvec3 ww = normalize( center - ro );\n    vec3 uu = normalize(cross(ww, vec3(0.0,1.0,0.0) ));\n    vec3 vv = cross(uu,ww);\n\tvec3 rd = normalize( uv.x*uu + uv.y*vv + scale*ww );\n\n    const int steps=30;\n\tfloat t0=(1.-ro.y)/rd.y;\n\tfloat t1=(0.-ro.y)/rd.y;\n\n    vec3 prevp = ro+rd*t0;\n    vec3 p = prevp;\n    float ph = 1.;\n    float pt = t0;\n    \n    // Raymarch through the heightfield with a fixed number of steps.\n    // https://www.shadertoy.com/view/MdBSRW\n    for(int i=1; i<steps; i++)\n    {\n        float t=mix(t0,t1,float(i)/float(steps));\n        p=ro+rd*t;\n        float h = GetHeight(p.xz, m, n, lmda, time);\n\n        if(h>p.y)\n        {\n            // Refine the intersection point.\n            float lrd=length(rd.xz);\n            vec2 v0=vec2(lrd*pt, prevp.y);\n            vec2 v1=vec2(lrd*t, p.y);\n            vec2 v2=vec2(lrd*pt, ph);\n            vec2 dv=vec2(h-v2.y,v2.x-v1.x);\n            float inter=dot(v2-v0,dv)/dot(v1-v0,dv);\n            p=mix(prevp,p,inter);\n\n            // Re-evaluate the height using the refined intersection point.\n            ph=GetHeight(p.xz, m, n, lmda, time);\n            \n            break;\n        }\n        prevp=p;\n        ph = h;\n        pt = t;\n    }\n    \n    // color by height and constrain to circle (+antialias)\n\tfragColor = mix(vec4(.8, ph, 0.,1.), \n                    vec4(105., 105., 105., 256.)/256.,\n                    smoothstep(.999, 1.001, length(p.xz)));\n}","name":"Image","description":"","type":"image"}]}