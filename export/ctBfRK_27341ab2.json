{"ver":"0.1","info":{"id":"ctBfRK","date":"1694206157","viewed":25,"name":"T1-circles","username":"_gamma_001","description":"juust a basic shader for testing","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["basic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n#define PI2 2.0 * PI\n#define E 2.71828\n\n#define SMOOTH_HERMITE 0x00000001\n#define SMOOTH_COSH 0x00000002\n#define SMOOTH_TANH 0x00000003\n#define SMOOTH_SIGMOID 0x00000004\n#define SMOOTH_SPHERE 0x00000005\n#define SMOOTH_SPHERE_INV 0x00000006\n\nfloat hash(float seed) {\n    uint frac = uint((seed - floor(seed)) * 1000.0);\n    frac ^= frac << 13;\n    frac ^= frac >> 17;\n    frac ^= frac << 5;\n    \n    frac = frac % 1000u;\n    return float(frac) / 1000.0;\n}\n\nfloat cSmoothstep(float edge0, float edge1, float x, int method) {\n    x = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n    switch (method) {\n        case SMOOTH_HERMITE: return x * x * (3.0 - 2.0 * x);\n        case SMOOTH_COSH: return cosh(1.32 * x) - 1.0;\n        case SMOOTH_SIGMOID: return 1.0 / (1.0 + pow(E, -10.0*x + 5.0));\n        case SMOOTH_SPHERE: return sqrt(1.0 - pow(x - 1.0, 2.0));\n        case SMOOTH_SPHERE_INV: return 1.0 - sqrt(1.0 - pow(x, 2.0));\n        default: return x;\n    }\n}\n\nfloat sdfCircle(vec2 uv, float r, vec2 offset) {\n    float d = length(uv - offset) - r;\n    return 1.0 - cSmoothstep(0.0, 0.2, d, SMOOTH_SIGMOID);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5f;\n    uv.x *= float(iResolution.x) / iResolution.y;\n\n    vec3 color = vec3(0.0);\n    \n    float count = 6.0;\n    for (int i = 0; i < int(count); i++) {\n        float fi = float(i);\n        float theta = fi * PI2 / count - iTime;\n        float fac = sin(iTime);\n        \n        float mask = sdfCircle(\n            uv, \n            0.05 * fac,\n            vec2(\n                0.3 * fac * cos(theta), \n                0.3 * fac * sin(theta)\n            )\n        );\n        color = max(\n            mask * 1.5 * vec3(\n                hash(2.1 * float(i + 1) / (count + 2.0)),\n                hash(2.2 * float(i + 1) / (count + 2.0)),\n                hash(2.9 * float(i + 1) / (count + 2.0))\n            ) + (1.0f - mask) * vec3(0.0f), \n            color\n        );\n    }\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}