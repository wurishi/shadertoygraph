{"ver":"0.1","info":{"id":"4ctyWX","date":"1732108783","viewed":50,"name":"My second bad shader","username":"Relayx","description":"Simple shader with textures","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["study"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS    90\n#define MAX_DIST     10.0\n#define SHADOW_STEPS 20\n#define EPS          0.003\n\nconst vec3 eye   = vec3(0, 1, 5);\nconst vec3 light = vec3(2, 5, 5);\n\nfloat sphereSDF(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\n\nfloat planeSDF(vec3 p) {\n    return p.y + EPS;\n}\n\nvec3 getMovingSphereCenter() {\n    float shpereY = sin(iTime) * 1.0 + 2.0;\n    \n    return vec3(0, shpereY, 0);\n}\n\nfloat scene(vec3 point, out int objectID) {\n    float sphereDist = sphereSDF(point, getMovingSphereCenter(), 1.0);\n    float planeDist = planeSDF(point);\n\n\n    if (sphereDist < planeDist) {\n        objectID = 1;\n        return sphereDist;\n    } else {\n        objectID = 2;\n        return planeDist;\n    }\n}\n\nvec3 generateNormal(vec3 z, float d) {\n    float e = max(d * 0.5, EPS);\n    int temp;\n    \n    float dx1 = scene(z + vec3(e, 0, 0), temp);\n    float dx2 = scene(z - vec3(e, 0, 0), temp);\n    float dy1 = scene(z + vec3(0, e, 0), temp);\n    float dy2 = scene(z - vec3(0, e, 0), temp);\n    float dz1 = scene(z + vec3(0, 0, e), temp);\n    float dz2 = scene(z - vec3(0, 0, e), temp);\n    \n    return normalize(vec3(dx1 - dx2, dy1 - dy2, dz1 - dz2));\n}\n\nvec3 trace(vec3 from, vec3 dir, out bool hit, out int objectID) {\n    vec3 p = from;\n    float totalDist = 0.0;\n    hit = false;\n\n    for (int step = 0; step < MAX_STEPS; ++step) {\n        float dist = abs(scene(p, objectID));\n        if (dist < EPS) {\n            hit = true;\n            break;\n        }\n\n        totalDist += dist;\n\n        if (totalDist > MAX_DIST)\n            break;\n\n        p += dir * dist;\n    }\n    \n    return p;\n}\n\nfloat softShadow(vec3 from, vec3 dir, float minDist, float maxDist) {\n    float shadowFactor = 1.0;\n    float totalDist = minDist;\n\n    for (int i = 0; i < SHADOW_STEPS; ++i) {\n        int objID;\n        float dist = scene(from + dir * (totalDist + EPS), objID);\n\n        if (dist < EPS) {\n            return 0.0;\n        }\n\n        shadowFactor = min(shadowFactor, dist / totalDist);\n        totalDist += dist;\n\n        if (totalDist > maxDist) {\n            break;\n        }\n    }\n    \n    return shadowFactor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    bool hit;\n    int objectID;\n    \n    vec2 scale = 8.0 * iResolution.xy / max(iResolution.x, iResolution.y);\n    vec2 uv = scale * (fragCoord/iResolution.xy - vec2(0.5));\n    vec3 dir = normalize(vec3(uv, 0) - eye);\n    vec3 p = trace(eye, dir, hit, objectID);\n    \n    vec3 color = texture(iChannel0, dir).rgb;\n    \n    if (hit) {\n        vec3 l   = normalize(light - p);\n        vec3 v   = normalize(eye - p);\n        vec3 n   = generateNormal(p, EPS);\n        float nl = max(0.0, dot(n, l));\n        vec3 h   = normalize(l + n);\n        float hn = max(0.0, dot(h,n));\n        float sp = pow(hn, 100.0);\n        \n        float shadow = softShadow(p + n * EPS, l, EPS, 10.0);\n        \n        vec3 norm = abs(n);\n        norm /= (norm.x + norm.y + norm.z);\n        \n        if (objectID == 1) {\n            vec3 sphereCenter = getMovingSphereCenter();\n            vec3 localPos = p - sphereCenter;\n\n            float u = 0.5 + atan(localPos.z, localPos.x) / (2.0 * 3.14159);\n            float v = 0.5 - asin(localPos.y) / 3.14159;\n    \n            vec3 SphereAlbedo = texture(iChannel1, vec2(u, v)).rgb;\n              \n            color = SphereAlbedo * (0.7 * vec3(nl) + 0.3 * cos(iTime+uv.xyx+vec3(0,2,4)) + sp * vec3(1.0, 1.0, 1.0));\n        } else if (objectID == 2) {\n            vec3 PlainAlbedo = \n                norm.x * texture(iChannel2, p.yz).rgb +\n                norm.y * texture(iChannel2, p.xz).rgb +\n                norm.z * texture(iChannel2, p.xy).rgb;\n            color = PlainAlbedo * (vec3(0.4, 0.5, 0.5) * nl * shadow);\n        }\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    float stars = pow(fract(sin(dot(rayDir.xy, vec2(20.0, 70.0))) * sin(iTime) * 4000.0), 200.0);\n    \n    vec3 nebula = vec3(smoothstep(0.8, 1.0, fract(sin(dot(rayDir.xz, vec2(3.0, sin(iTime) * 100.0))) * 100.0f)));\n    nebula *= vec3(0.5, 0.4, 1.0);\n    \n    vec3 spaceColor = nebula + vec3(stars);\n    fragColor = vec4(pow(spaceColor, vec3(0.4545)), 1.0);\n}\n","name":"Cube A","description":"","type":"cubemap"}]}