{"ver":"0.1","info":{"id":"sdBfDy","date":"1646983761","viewed":60,"name":"Interactive Cellular Automata","username":"HyperChromatica","description":"bug notes : if executed on frame 1 texelFetch will always return 0. thus countNeighbors will always be 0 on first frame, fragColor doesn't apply to buffer till frame 2. \n\nisIn seems to be a taken name. ","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["automata","life","cellular","conway"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = .125;\n    fragColor = vec4(texture(iChannel0, zoom*fragCoord/iResolution.xy).rgb,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n    Each pixel in a cellular automata - each cell - determines its fate\n    by the number of living cells around it. This function takes in a position\n    for a cell, then looks around it for other living cells, returning the \n    amount it finds. \n    \n*/\n\n\nfloat countNeighbors(ivec2 pos)\n{\n    float numAlive = 0.0;\n    for(int y = -1 ; y <= 1; y++)\n    {\n        for(int x = -1; x<=1; x++)\n        {   \n            if(y==0 && x==0){continue;}\n            numAlive += round(texelFetch(iChannel0, pos + ivec2(x,y), 0).r);\n        }\n    }\n    return numAlive;\n}\n\n\n/*\n\n    This function interprets whether a certain number is 'in' our bitmask.\n    In practice, this means if our 'living neighbors' is an amount that should keep living or do something else.\n   \n*/\nbool inBitmask(uint query, uint bitmask) \n{\n    uint bitquery = 1u << query;\n    return (bitmask&bitquery) > 0u; \n}\n\n\n\nvec4 drawOnScreen(vec2 fragCoord, float zoom, vec4 fragColor)\n{\n    // if the pixel is close to the mouse, 1. otherwise dont modify it.\n    return( length(fragCoord - iMouse.xy/zoom ) < .5) ? vec4(1.0)  : fragColor; \n}\n\n\n/*\n\n    This applies the rules of the cellular automata :\n    when cells should keep living, \n    when they should die,\n    when they should become alive\n    \n*/\n\n/*\nsome other neat rulesets (survive : S , becomeAlive  : B): \n    S: 2,3,4,5,6  B : 2,6\n    S : 1,6  B:1,2,5\n    making it so everything survives\n    explosions : S12345678 B34\n*/\n\nfloat nextStep(bool isAlive, float livingNeighbors)\n{\n    //for easy changeability\n    uint survive =      0u<<0u | 0u<<1u |1u<<2u |1u<<3u |0u<<4u |0u<<5u |0u<<6u |0u<<7u |0u<<8u ; //0xcu;\n    uint becomeAlive =  0u<<0u | 0u<<1u |0u<<2u |1u<<3u |0u<<4u |0u<<5u |0u<<6u |0u<<7u |0u<<8u ; //0x8u;\n    \n    // inBitmask here equivalent to livingNeighbors==2 OR livingNeighbors==3\n    \n    if(isAlive && inBitmask(uint(livingNeighbors),survive))\n    {\n        return 1.0;\n    }\n    else if(!isAlive && inBitmask(uint(livingNeighbors),becomeAlive))//livingNeighbors == 3.0)\n    {\n        return 1.0;\n    }\n    else \n    {\n        return 0.0;\n    }    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    int frameSkip = 10;                                    //only recalculate every 10th frame\n    float zoom = 8.0;                                      //must match zoom in main file. \n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);  //set color to whatever it was at the end of last frame\n    \n                                                           \n    if(iFrame<120 || iMouse.z > 0.0)\n    {\n        fragColor = drawOnScreen(fragCoord,zoom,fragColor);//initialize using screen drawing\n    } \n    else\n    {\n        if(iFrame%frameSkip==0)                            //skip if not a 10th frame (if FrameSkip is 10)\n        {           \n            float livingNeighbors = countNeighbors(ivec2(fragCoord)); \n            float status = fragColor.r; \n            bool isAlive = status > .5;\n            fragColor = vec4(nextStep(isAlive,livingNeighbors)); \n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}