{"ver":"0.1","info":{"id":"lcVcWy","date":"1732350958","viewed":69,"name":"Maurdekye Caustics","username":"Maurdekye","description":"Simulates caustics","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\nuniform vec2 touch;\nuniform int pointerCount;\n\nconst int per_gridspace = 6;\nconst float gridsize = .33;\nconst float blendamt = .0275;\nconst int blendstacks = 4;\n\nconst float pi = 3.14159265369;\n\nfloat rand(vec2 n) {\n  return fract(sin(dot(n+vec2(1), vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nvec2 getcell(vec2 gridcoord, int index, float seed) {\n\tvec2 tuv = touch / iResolution.x;\n\tvec2 tcoord = floor(tuv/gridsize);\n\tif (gridcoord == tcoord && index == 0 && pointerCount > 0)\n\t  return tuv;\n\t//return gridcoord * gridsize + vec2(gridsize/2.);\n\tfloat perc = float(index) / float(per_gridspace);\n\tvec2 delta = vec2(rand(gridcoord + vec2(.25 + seed, perc)), rand(gridcoord + vec2(.75 + seed, perc)));\n\tvec2 origin = vec2(rand(gridcoord + vec2(seed, perc)), rand(gridcoord + vec2(.5 + seed, perc)));\n  vec2 final = (sin(origin*pi*2. + delta*iTime) + vec2(1.)) / vec2(2.);\n  final *= vec2(gridsize);\n  final += gridcoord * gridsize;\n  return final;\n}\n\nvec3 poscolor(vec2 pos) {\n\treturn vec3(rand(pos), rand(pos + vec2(0, .1)), rand(pos + vec2(.1, 0)));\n}\n\nfloat blend(float a, float b, float k) {\n  float diff = a - b;\n  if (abs(diff) >= 10.*k)\n    return min(a, b);\n  else {\n   return min(a, b) - k*exp(-abs(diff/k))/2.;\n  }\n}\n\nvec2 nearest(vec2 centercoord, vec2 pos, out float dist, out vec3 id, out float border_dist, float seed) {\n\tvec2 closest = vec2(100);\n\tdist = 100.;\n\tfor (int dx = -1; dx <= 1; dx++) {\n\t\tfor (int dy = -1; dy <= 1; dy++) {\n\t\t\tvec2 gridcoord = centercoord + vec2(dx, dy);\n\t\t\tfor (int i = 0; i < per_gridspace; i++) {\n\t\t\t\tvec2 cell = getcell(gridcoord, i, seed);\n\t\t\t\tfloat celldist = length(cell - pos);\n\t\t\t\tif (celldist < dist) {\n\t\t\t\t\tclosest = cell;\n\t\t\t\t\tdist = celldist;\n\t\t\t\t\tid = vec3(gridcoord, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tborder_dist = 100.;\n\tfor (int dx = -1; dx <= 1; dx++) {\n\t\tfor (int dy = -1; dy <= 1; dy++) {\n\t\t\tvec2 gridcoord = centercoord + vec2(dx, dy);\n\t\t\tfor (int i = 0; i < per_gridspace; i++) {\n\t\t\t\tvec2 cell = getcell(gridcoord, i, seed);\n\t\t\t\tif (cell != closest) {\n\t\t\t\t  if (closest != vec2(100)) {\n\t\t\t\t    vec2 mid = (closest - cell) / vec2(2);\n\t\t\t\t    vec2 pdelta = pos - cell;\n\t\t\t\t    vec2 line = closest - cell;\n\t\t\t\t    float proj = dot(pdelta, line) / dot(line, line);\n\t\t\t\t    float new_border = distance(proj * line, mid);\n\t\t\t\t    border_dist = blend(new_border, border_dist, blendamt);\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn closest;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 u) {\n\t\n    vec2 uv = u / min(iResolution.x, iResolution.y);\n\tvec3 final = vec3(0);\n\tfloat caustic = 1.;\n\n\tfor (int i = 0; i < blendstacks; i++) {\n\n    vec2 shift = (time+130.)*(vec2(rand(vec2(0,i)), rand(vec2(1,i)))-.5)/5.;\n    vec2 cuv = uv + shift;\n  \tvec2 coord = floor(cuv/gridsize);\n\n    float celldist;\n    vec3 id;\n    float border;\n    float seed = float(i);\n    vec2 cell = nearest(coord, cuv, celldist, id, border, seed);\n    //final *= poscolor(id.xy + vec2(id.z)/vec2(per_gridspace));\n\n  //final = (final * .6) + vec3(.4);\n  //final *= 1./(celldist*10. + 1.);\n  //vec2 delta = uv - cell;\n  //float angle = atan(delta.x / delta.y);\n  //if (mod(log(celldist)+time/5., .2) < .1) final *= .5;\n\n    //border = max(border, 0.);\n    //float borderval = border*20.;\n    //if (borderval < 1.) borderval = exp(borderval - 1.);\n\t  caustic = min(1./((max(border*100. +2., 0.))), caustic);\n\t}\n\n\tfinal = mix(vec3(.25, .62, .8), vec3(.74, .87, .91), vec3(clamp(0., caustic, 1.)));\n\t//final = vec3(caustic);\n\tif (caustic < 0.) final *= -vec3(1,0,0);\n\t//if (border < 0.01) final = vec3(1,0,0);\n\tvec2 relpos = mod(uv, gridsize);\n\t//if (min(relpos.x, relpos.y) < .005) final = vec3(0);\n\tfragColor = vec4(final, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}