{"ver":"0.1","info":{"id":"XtfcDX","date":"1506584410","viewed":89,"name":"Twin Shade C","username":"tgsstdio","description":"twin - duo shade C\nleft of screen: light pattern\nright of screen: dark pattern\n\nClick on screen to magnify area around mouse pointer","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// SHOULD BE SQUARE ON SCREEN NOT RECTANGULAR\n#define SUBDIVISION_LOOP_IN_SECS 18.0\n#define NO_OF_DIVISIONS 9\n\n#define MID_POINT 0.4\n#define TWO_PI 6.283185307179586476925286766559\n#define FREQUENCY 0.255\n#define RANGE_OF_TRIG_FUNC 0.2\n\n#define GRAD_MID_POINT 0.25\n#define GRAD_FREQUENCY 0.155\n#define GRAD_RANGE_OF_TRIG_FUNC 0.2\n\n// isLight: true for light shade pattern, false for darker shade pattern\n// uv: normalized uv coordinates\n// cellSize: in pixel size (0, inf)\n// screenRect: screen dimensions in pixels\n// lineWidth: percentage (0 - 1.0)\n// gradientWidth: percentage [0 - 1.0) w.r.t lineWidth\nfloat twinShadeC(bool isLight, vec2 uv, float cellSize, vec2 screenRect, float lineWidth, float gradientWidth)\n{\n   vec2 cellDims = cellSize / iResolution.xy;    \n    \n   vec2 bckSlash = vec2(screenRect.x / screenRect.y, 1.);\n   vec2 fwdSlash = vec2(-1, iResolution.y / iResolution.x);      \n  \n   vec2 bottomLeft = floor(uv / cellDims) * cellDims;          \n   vec2 bottomRight = bottomLeft + vec2(cellDims.x, 0.);   \n   \n   vec4 d0, d1;   \n   d0.xy = vec2(dot(fwdSlash, bottomLeft)); // fd0\n   d0.zw = vec2(dot(bckSlash, bottomRight)); // bd0\n    \n   d1.x = dot(fwdSlash, bottomRight); // fd2\n   d1.y = dot(fwdSlash, uv); // fd1\n\n   d1.z = dot(bckSlash, bottomLeft); // bd2    \n   d1.w = dot(bckSlash, uv); // bd1                                   \n\n   vec4 d2 = abs(d1 - d0);\n    \n   //float fwdEnd = abs(fd2 - fd0); // d2.x \n   //float fwdDiff = abs(fd1 - fd0); // d2.y     \n   //float bckEnd = abs(bd2 - bd0);  // d2.z        \n   //float bckDiff = abs(bd1 - bd0);  // d2.w \n    \n   float percent = lineWidth * (0.5 - gradientWidth);\n    \n   vec4 dMinMax = d2.xzxz;\n   dMinMax.xy *= percent;\n   dMinMax.zw *= (1. - percent);    \n    \n   //float fwdMin = percent * d2.x; dMinMax.x  \n   //float bckMin = percent * d2.z; dMinMax.y\n   //float fwdMax = (1. - percent) * d2.x; dMinMax.z   \n   //float bckMax = (1. - percent) * d2.z; dMinMax.w    \n   \n   float cutoff = isLight \n       ? dMinMax.z\n       : dMinMax.x;  \n    \n   vec3 compareLeft = vec3(d2.yw, cutoff);\n   vec3 compareRight = vec3(dMinMax.xy, d2.y);\n   \n   bvec3 result = lessThanEqual(compareLeft, compareRight);\n   \n   float color = 0.;    \n   if (any(bvec2(result.x, all(result.yz))))\n   {\n      color = 0.;\n   }\n   else\n   {              \n      vec2 halves = vec2(lineWidth, dMinMax.z + dMinMax.x) * 0.5;       \n      // float margin = width * 0.5; // halves.x\n      // float midpoint = 0.5 * (dMinMax.z + dMinMax.x); // halves.y      \n       \n      vec2 lightMin = d2.xz * halves.x;\n      // float fwdMin = margin * d2.x; // lightMin.x \n      // float bckMin = margin * d2.z; // lightMin.y      \n      \n      vec3 lightGrad = abs(vec3(dMinMax.x, lightMin.x, d2.y) - halves.y);\n       \n      // float lower = abs(dMinMax.x - midpoint); lightGrad.x\n      // float upper = abs(fwdMin - midpoint); lightGrad.y       \n      // float pt = abs(d2.y - midpoint);  lightGrad.z\n      \n      vec3 low = vec3(lightGrad.x, dMinMax.x, dMinMax.y);\n      vec3 high = vec3(lightGrad.y, lightMin.xy);\n      vec3 value = vec3(lightGrad.z, d2.y, d2.w);\n       \n      vec3 blending = smoothstep(low, high, value);\n       \n      //float lightGradient = smoothstep(lower, upper, pt); blending.x             \n      //float fwdRatio = smoothstep(dMinMax.x, fwdMin, d2.y); blending.y\n      //float bckRatio = smoothstep(dMinMax.y, bckMin, d2.w ); blending.z         \n\n      vec4 shadeLeft = vec4(d2.yw, lightMin.xy);\n      vec4 shadeRight = vec4(lightMin.xy, d2.yw);\n       \n      bvec4 shadeTest = greaterThanEqual(shadeLeft, shadeRight);\n       \n      // bool d2y_fMin = d2.y >= fwdMin; shadeTest.x    \n      // bool d2w_bMin = d2.w >= bckMin; shadeTest.y       \n      // bool fMin_d2y = fwdMin >= d2.y; shadeTest.z\n      // bool bMin_d2w = bckMin >= d2.w; shadeTest.w\n       \n       float factor = 1.;       \n       if (isLight)\n       {                       \n          factor = blending.x;                    \n       }      \n       else \n       {\n          bvec3 darkBlend0 = bvec3(!result.x, shadeTest.zy);\n           \n          //if (!result.x && shadeTest.z && shadeTest.y)\n          if (all(darkBlend0))\n   \t      {\n       \t\t factor = blending.y; \n  \t\t  }                                   \n           \n          bvec3 darkBlend1 = bvec3(!result.y, shadeTest.wx);\n           \n          //if (!result.y && shadeTest.w && shadeTest.x)\n          if (all(darkBlend1))\n   \t      {\n       \t\t factor = blending.z; \n  \t\t  } \n           \n          if (all(shadeTest.wz))\n    \t  // if (shadeTest.w && shadeTest.z)\n    \t  {         \n    \t     factor = clamp(blending.y * blending.z, 0., 1.0); \n          }            \n       }              \n       \n       color = factor;\n   }\n   return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n    // UPDATE: PATTERN MAGNIFICATION\n    float d = distance(fragCoord, iMouse.xy);\n    \n    if(d < 50.0)\n    {\n      fragCoord = (iMouse.xy + normalize(fragCoord - iMouse.xy) * d * 0.5);\n    }    \n    \n    // SELECTING CELL SIZE\n    float gapTimeStep = mod(iTime, SUBDIVISION_LOOP_IN_SECS) / SUBDIVISION_LOOP_IN_SECS;\n\n    float sections[NO_OF_DIVISIONS] = float[](\n        256.,        \n        128.,        \n        4.,\n        8.,\n        12.,\n        16.,\n        32.,        \n        64.,\n        96.\n   ); \n    \n   float lineWidth = MID_POINT + RANGE_OF_TRIG_FUNC * sin( FREQUENCY * TWO_PI * iTime);    \n    \n   float gradientWidth = GRAD_MID_POINT + GRAD_RANGE_OF_TRIG_FUNC * sin( GRAD_FREQUENCY * TWO_PI * iTime);    \n\n   float cellSize = sections[int(gapTimeStep * float(NO_OF_DIVISIONS))];       \n    \n   vec2 uv = fragCoord.xy / iResolution.xy;       \n        \n   if (uv.x < 0.5)    \n   \t fragColor = vec4(twinShadeC(true, uv, cellSize, iResolution.xy, lineWidth, gradientWidth));     \n   else \n     fragColor = vec4(twinShadeC(false, uv, cellSize, iResolution.xy, lineWidth, gradientWidth));   \n}","name":"Image","description":"","type":"image"}]}