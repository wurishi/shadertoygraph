{"ver":"0.1","info":{"id":"WstfzH","date":"1604382502","viewed":206,"name":"ps_Spherize","username":"bigt","description":"spherize\n鼠标移动改变圆心位置","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["distort","photoshop","spherize","ps"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int iSquare = 1;\nfloat fRadius = 0.3;\nfloat fThreshold = 10.0;// aa(单位:像素)\n\n#define pi 3.1415926\nvec4 spherizeFilter(vec2 pos)\n{\n    // 变换坐标系,决定是否使用宽高比\n    vec2 res = mix(min(iResolution.xx, iResolution.yy), iResolution.xy, float(iSquare));\n    pos = pos/iResolution.xy*res;\n    \n    // 圆心坐标\n    float mouseDown = step(0.1, iMouse.z);\n    vec2 O = mix(vec2(0.3,0.35)*res, iMouse.xy/iResolution.xy*res, mouseDown);\n    \n    float maxRadius = min(res.x, res.y) * fRadius;// x,y选取最小值作为半径\n\n    vec2 P = pos;\n    vec2 OtoP = P - O;\n    float R = length(OtoP);\n    \n\tfloat theta = atan(OtoP.y, OtoP.x);\n    // ---------------------------- 球面化主要代码 -------------------------------------\n    \n    // -------------------------------   凸   -----------------------------------------\n\t// 凸起的特征:离圆心越远,像素越密集,离圆心越近,像素越松散\n    // 所以用asin函数来模拟,参数范围是-1~1,值域是-pi/2~pi/2\n    // lengthPtoO/maxRadius范围是0~1,asin之后除了二分之pi,值域变成了0~1\n    // 转化为新的半径,计算新的直角坐标\n\tfloat convexR= asin(R/maxRadius)/(pi/2.0)*maxRadius;\n    P = O + vec2(convexR*cos(theta), convexR*sin(theta));\n    // -------------------------------------------------------------------------------\n    \n    float t = smoothstep(-fThreshold, fThreshold, R-maxRadius);// aa\n    vec3 col1 = texture(iChannel0, pos/res).rgb;\n    vec3 col2 = vec3(0.2,0.5,0.2) + texture(iChannel0, P/res).rgb;\n\tvec3 col = mix(col2, col1, t);\n    // -------------------------------------------------------------------------------\n    \n    \n    // -------------------------------   凹   -----------------------------------------\n    O = vec2(0.65,0.35)*res;\n    \n    P = pos;\n    OtoP = P - O;\n    R = length(OtoP);\n    \n    theta = atan(OtoP.y, OtoP.x);\n    \n    float concaveR = sin(R/maxRadius*pi/2.0)*maxRadius;\n\tP = O + vec2(concaveR*cos(theta), concaveR*sin(theta));\n    \n\tvec3 col3 = vec3(0.3,0.1,0.2) + texture(iChannel0, P/res).rgb;\n\tt = smoothstep(-fThreshold, fThreshold, R-maxRadius);// aa\n    col = mix(col3, col, t);\n    // -------------------------------------------------------------------------------\n    \n    return vec4( col, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = spherizeFilter(fragCoord);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// https://www.shadertoy.com/view/3sVyWh\nfloat checkerboard(vec2 pos, vec2 size, float threshold)\n{\n    vec2 gc = floor(pos/size);\n    float flag = abs(mod(gc.x,2.0) - mod(gc.y,2.0));\n    \n    // aa\n    vec2 t1 = smoothstep(size,size-threshold,pos - floor(pos/size)*size);\n    vec2 t2 = smoothstep(0.0,threshold,pos - floor(pos/size)*size);\n    float aa = t1.x*t1.y*t2.x*t2.y;\n    \n    return flag*aa;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 size = vec2(30.0,30.0);// 棋盘格的大小(单位:像素)\n    vec3 col1 = vec3(0.15);// 两个格子的颜色\n    vec3 col2 = vec3(0.85);\n    float threshold = 2.0;// aa(单位:像素)\n    \n    vec2 coord = fragCoord;\n    \n    float flag = checkerboard(coord, size, threshold);\n    vec3 col = mix(col1, col2, flag);\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}