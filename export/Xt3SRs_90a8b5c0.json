{"ver":"0.1","info":{"id":"Xt3SRs","date":"1481071710","viewed":852,"name":"Shell Game","username":"lara","description":"Wait until they're shuffled and then click on a cup to take a guess.\nToDo: increase difficulty with each successful guess.","likes":16,"published":3,"flags":32,"usePreview":0,"tags":["game","cups","shell","shuffle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0,fragCoord.xy/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define S 256   // Steps\n#define R 2.    // Sub steps\n#define P 0.001 // Precision\n#define D 20.   // Max distance\n#define A 5.    // AO steps\n\n#define T iTime\n#define PI 3.1415926\n#define TAU (PI*2.0)\n\n#define set(a,b) if(gl_FragCoord.x==a.x+0.5&&gl_FragCoord.y==a.y+0.5){b;return true;}\n#define get(a,b) texture(b,(a+0.5)/iResolution.xy)\n#define init(a)  if(iFrame<2){a;return true;}\n\nconst vec2 bufA_state1 = vec2(0,0);\nconst vec2 bufA_state2 = vec2(1,0);\n\nconst float SC  = 15.0; // shuffle count\nconst float SCI =  5.0; // shuffle count increment per level\nconst float SD  =  0.4; // shuffle duration\nconst float SDM =  0.9; // shuffle duration multiplier per level\n\nstruct Ray { vec3 o, d; }, _ray;\nstruct Camera { vec3 p, t; }, _cam;\nstruct Hit { vec3 p; float t, d; };\n\n// positions\nvec3 _pCupA;\nvec3 _pCupB;\nvec3 _pCupC;\n\n// distances\nfloat _d;\nfloat _dTable;\nfloat _dBall;\nfloat _dCupA;\nfloat _dCupB;\nfloat _dCupC;\nfloat _dSky;\nfloat _dQMark;\n\n// logic\nfloat _state;\nfloat _pBall;\nfloat _swap;\nfloat _dt;\nfloat _sd;\nfloat _pick;\nfloat _picked;\n\n// states\nbool _normalMarch = false;\n\n// spacing\nfloat _s = 1.5;\n\n/* ============= */\n/* === UTILS === */\n/* ============= */\n\nfloat hash11(float n)\n{\n    return fract(sin(dot(vec2(n),vec2(12.9898,78.233)))*43758.5453);\n}\n\nmat2 rot(float a)\n{\n    float c=cos(a),s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdBox(vec3 p,vec3 s)\n{\n    return length(max(p=abs(p)-s,0.))+min(max(p.x,max(p.y,p.z)),0.);\n}\n\nfloat sdCapsule(vec3 p,vec3 a,vec3 b,float r)\n{\n    return length(-clamp(dot(p-=a,b-=a)/dot(b,b),0.,1.)*b+p)-r;\n}\n\nfloat sdCup(vec3 p, float r1, float r2, float h)\n{\n\tfloat d = length(p.xz)-mix(r2,r1,abs(p.y+h)/h);\n    \n    return smin(\n        max(abs(d)-P,abs(p.y)-h),\n        max(d,abs(p.y-h-.02)-P)\n    ,.05);\n}\n\n/* ============= */\n/* === SCENE === */\n/* ============= */\n\nfloat scene(vec3 p)\n{\n    _d = 1e10;\n    \n    float r1 = 0.4; // upper radius\n    float r2 = 0.5; // lower radius\n    float h  = 0.5; // cup height\n    \n    _dTable = sdBox(p+vec3(0,h+.1,0),vec3(2.5,.02,1))-.05;\n    _dBall = _state < 2. || _state == 4. ? length(p-vec3(_pBall*_s,-.25,0))-.25 : 1e10;\n    _dSky = abs(length(p)-D+5.)-P;\n\t_dQMark = 1e10;\n    \n    _dCupA = sdCup(p-_pCupA,r1,r2,h);\n    _dCupB = sdCup(p-_pCupB,r1,r2,h);\n    _dCupC = sdCup(p-_pCupC,r1,r2,h);\n    \n    if (_normalMarch)\n    {\n        _dTable += texture(iChannel1,p.xz).r*.01;\n    }\n    \n    // display question mark\n    if (_state == 3.)\n    {\n       \tfloat d = 1e10;\n\n        p.xz *= rot(T);\n        \n        d = min(d,sdCapsule(p,vec3(-.1,h+.8,0),vec3(-.1,h+.9,0),.05));\n        d = min(d,sdCapsule(p,vec3(-.1,h+.9,0),vec3( .1,h+.9,0),.05));\n        d = min(d,sdCapsule(p,vec3( .1,h+.9,0),vec3( .1,h+.6,0),.05));\n        d = min(d,sdCapsule(p,vec3( .1,h+.6,0),vec3( .0,h+.6,0),.05));\n        d = min(d,sdCapsule(p,vec3( .0,h+.6,0),vec3( .0,h+.5,0),.05));\n        d = min(d,length(p-vec3(0,h+.35,0))-.05);\n        \n        _dQMark = d;\n    }\n  \n    _d = min(_d,_dTable);\n    _d = min(_d,_dBall);\n    _d = min(_d,_dQMark);\n\t_d = min(_d,_dCupA);\n    _d = min(_d,_dCupB);\n    _d = min(_d,_dCupC);\n    _d = min(_d,_dSky);\n    \n    return _d;\n}\n\n/* ================ */\n/* === MARCHING === */\n/* ================ */\n\nvec3 getNormal(vec3 p)\n{\n    _normalMarch = true;\n    \n\tvec2 e = vec2(P,0);\n    \n\treturn normalize(vec3(\n\t\tscene(p+e.xyy)-scene(p-e.xyy),\n\t\tscene(p+e.yxy)-scene(p-e.yxy),\n\t\tscene(p+e.yyx)-scene(p-e.yyx)\n\t));\n}\n\nHit march(Ray r)\n{\n    float t = 0.0, d;\n    \n    for(int i = 0; i < S; i++)\n    {\n        d = scene(r.o+r.d*t);\n        t += d/R;\n        \n        if (d < P || t > D) { break; }\n    }\n    \n    return Hit(r.o+r.d*t, t, d);\n}\n\nRay lookAt(Camera cam, vec2 uv)\n{\n    vec3 d = normalize(cam.t-cam.p);\n    vec3 r = normalize(cross(d, vec3(0,1,0)));\n    vec3 u = cross(r, d);\n\n    return Ray(cam.p,normalize(r*uv.x + u*uv.y + d));\n}\n\n/* =============== */\n/* === SHADING === */\n/* =============== */\n\nfloat getAmbientOcclusion(Hit h) \n{\n    float t = 0., a = 0.;\n    \n    for(float i = 0.; i < A; i++)\n    {\n        float d = scene(h.p-_ray.d*i/A*.1);\n        t += d;\n    }\n\n    return clamp(t/A*20.,0.,1.);\n}\n\nvec3 getColor(Hit h)\n{\n    if (h.d > P) { return vec3(0); }\n    \n    vec3 light = vec3(0,15,50); //_cam.p;\n    \n    vec3 c = vec3(0);\n    vec3 n = getNormal(h.p);\n\n    float diff = max(dot(n, normalize(light-h.p)),.4);\n    float spec = pow(max(dot(reflect(normalize(h.p-light),n),normalize(_cam.p-h.p)),0.),10.);\n    \n    // table\n    if (_d == _dTable)\n    {\n        c = mix(vec3(1,1,.8)*2., texture(iChannel1, h.p.xz).rrr*1.5, .5) * .5 + spec*.5;\n    }\n    // cups\n    else if (_d == _dCupA || _d == _dCupB || _d == _dCupC)\n    {\n        vec3 p = h.p - (_d == _dCupA ? _pCupA : _d == _dCupB ? _pCupB : _pCupC);\n        c = texture(iChannel1,vec2(atan(p.z,p.x),p.y*2.+.5)).rgb + spec*.2;\n    }\n    // ball\n    else if (_d == _dBall)\n    {\n        vec3 p = h.p - vec3(_pBall*_s,-.25,0);\n        c = texture(iChannel2,vec2(acos(p.z/length(p)),atan(p.y/p.x))).rgb*1.5+.2;\n    }\n    // question mark\n    else if (_d == _dQMark)\n    {\n        c = vec3(1) + spec;\n    }\n    // sky\n    else if (_d == _dSky)\n    {\n        c = texture(iChannel3,n).bbg;\n    }\n\n    return pow(abs(c*getAmbientOcclusion(h)),vec3(1.3))*1.3;\n}\n\n/* ================= */\n/* === ANIMATION === */\n/* ================= */\n\nvoid swap(inout vec3 p, vec3 o, float f)   \n{\n    p -= o;\n    p.xz *= rot(f*PI);\n    p += o;\n    p.z *= .5;\n}\n\nvoid animate()\n{\n    vec3 pCupA = vec3(-_s,0,0);\n    vec3 pCupB = vec3(  0,0,0);\n    vec3 pCupC = vec3( _s,0,0);\n    \n    vec3 rotA = mix(pCupA,pCupB,.5);\n    vec3 rotB = mix(pCupA,pCupC,.5);\n    vec3 rotC = mix(pCupB,pCupC,.5);\n    \n    _pCupA = pCupA;\n    _pCupB = pCupB;\n    _pCupC = pCupC;\n    \n    float f = smoothstep(0.,1.,min(T-_dt,1.));\n    \n    // initial\n    if (_state == 0.)\n    {\n             if (_pBall == -1.) _pCupA.y += 1.;\n        else if (_pBall ==  0.) _pCupB.y += 1.;\n        else if (_pBall ==  1.) _pCupC.y += 1.;\n    }\n    // hide\n    else if (_state == 1.)\n    {\n             if (_pBall == -1.) _pCupA.y += 1. - f;\n        else if (_pBall ==  0.) _pCupB.y += 1. - f;\n        else if (_pBall ==  1.) _pCupC.y += 1. - f;\n    }\n    // swap\n    else if (_state == 2.)\n    {\n        f /= _sd;\n        \n             if (_swap == 1.) { swap(_pCupA, rotA, f); swap(_pCupB, rotA, f); }\n        else if (_swap == 2.) { swap(_pCupA, rotB, f); swap(_pCupC, rotB, f); }\n        else if (_swap == 3.) { swap(_pCupB, rotC, f); swap(_pCupC, rotC, f); }\n    }\n    // reveal\n    else if (_state == 4. && _picked > 0.)\n    {\n             if (_pick == -1.) _pCupA.y += f;\n        else if (_pick ==  0.) _pCupB.y += f;\n        else if (_pick ==  1.) _pCupC.y += f;\n    }\n}\n\n/* ============= */\n/* === LOGIC === */\n/* ============= */\n\nvoid swap(inout vec4 F)\n{\n\tF.y = floor(hash11(T)*3.)+1.;\n    F.w = T;\n    \n         if (F.y == 1. && (F.z == -1. || F.z == 0.)) F.z = F.z == -1. ? 0. : -1.;\n    else if (F.y == 2. && (F.z == -1. || F.z == 1.)) F.z = F.z == -1. ? 1. : -1.;\n    else if (F.y == 3. && (F.z ==  1. || F.z == 0.)) F.z = F.z ==  1. ? 0. :  1.;\n}\n\nbool logic(inout vec4 F)\n{\n    set(bufA_state1,\n    {    \n        // x = state (0=show,1=hide,2=shuffle,3=select,4=reveal)\n        // y = swap bits (0,1=l+m,2=l+r,3=r+m)\n        // z = ball pos (-1=l,0=m,1=r)\n        // w = time delta\n        init(F = vec4(0,0,0,T));\n        \n        float dt = T-F.w;\n        vec4 o = get(bufA_state2,iChannel0);\n        \n        // lower the cups after showing the ball location for 3 seconds\n        if (F.x == 0. && F.w > 0. && dt > 2.)\n        {\n            F.x = 1.;\n            F.w = T;\n        }\n        // swap\n        else if ((F.x == 1. && dt > 1.) || (F.x == 2. && o.x > 0. && dt > SD))\n        {\n            F.x = 2.;\n            swap(F);\n        }\n        // select\n        else if(F.x == 2. && o.x == 0. && dt > SD)\n        {\n            F.x = 3.;\n        }\n        // reveal\n        else if (F.x == 3. && o.w == 1.)\n        {\n            F.x = 4.;\n            F.w = T;\n        }\n        //else if(F.x == 4. && dt > 2.)\n        //{            \n        //    F.x = 0.;\n        //    F.z = 0.;\n        //    F.w = T+2.;\n        //}\n    });\n    \n    set(bufA_state2,\n    {\n        // x = shuffle count\n        // y = shuffle duration\n        // z = selection\n        // w = selected?\n        init(F = vec4(SC,SD,0,0));\n        \n        vec4 s = get(bufA_state1,iChannel0);\n        float dt = T-s.w;\n        \n        // decrease shuffle count\n\t\tif(s.x == 2. && dt > SD)\n        {\n            F.x = max(F.x-1.,0.);\n        }\n        // cast a ray\n        else if (s.x == 3. && iMouse.w > 0.)\n        {\n            _cam = Camera(vec3(0,2,3), vec3(0));\n            march(lookAt(_cam,(2.0*iMouse.xy-iResolution.xy)/iResolution.xx));\n            \n                 if (_d == _dCupA) { F.z = -1.; F.w = 1.; }\n            else if (_d == _dCupB) { F.z =  0.; F.w = 1.; }\n            else if (_d == _dCupC) { F.z =  1.; F.w = 1.; }\n        }\n        //else if(s.x == 4.)\n        //{\n        //    // if (F.z == s.z)\n        //    \n        //    F.x = sc;\n        //    F.y = sd;\n        //}\n    });\n    \n    return false;\n}\n\n/* ============ */\n/* === MAIN === */\n/* ============ */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy);\n    \n    vec4 v = get(bufA_state1, iChannel0);\n\n    _state = v.x;\n    _swap  = v.y;\n    _pBall = v.z;\n\t_dt    = v.w;\n    \n    v = get(bufA_state2, iChannel0);\n    \n    _sd     = v.y;\n    _pick   = v.z;\n    _picked = v.w;\n    \n    animate();\n   \tif (logic(fragColor)) { return; }\n    \n    _cam = Camera(vec3(0,2,3), vec3(0));\n    _ray = lookAt(_cam,(2.0*fragCoord.xy-iResolution.xy)/iResolution.xx);  \n\n    float f = 1.-length((2.0*fragCoord.xy-iResolution.xy)/iResolution.xy)*0.25;\n    fragColor = vec4(getColor(march(_ray))*f, 1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}