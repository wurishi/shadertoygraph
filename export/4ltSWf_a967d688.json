{"ver":"0.1","info":{"id":"4ltSWf","date":"1483397517","viewed":2710,"name":"505","username":"mhorga","description":"testing AO","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nstruct Ray { \n\tvec3 origin;\n\tvec3 dir;\n};\n    \nstruct Light {\n    vec3 pos;\n};\n    \nstruct Camera {\n    vec3 pos;\n    Ray ray;\n    float rayDivergence;\n};\n\nstruct Sphere { \n\tvec3 center;\n\tfloat radius;\n};\n\nstruct Plane {\n    float yCoord;\n};\n    \nstruct Box {\n    vec3 center;\n    float size;\n};        \n    \nfloat unionOp(float d0, float d1) {\n    return min(d0, d1);\n}\n\nfloat differenceOp(float d0, float d1) {\n    return max(d0, -d1);\n}\n\nfloat distToSphere(in Ray r, in Sphere s) {\n\tfloat d = distance(r.origin, s.center);\n    return d - s.radius;\n}\n\nfloat distToPlane(in Ray r, in Plane p) {\n\treturn r.origin.y - p.yCoord;\n}\n\nfloat distToBox(in Ray r, in Box b) {\n    vec3 d = abs(r.origin - b.center) - vec3(b.size);\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat distToScene(in Ray r) {\n    Plane p = Plane(0.);\n    float d2p = distToPlane(r, p);\n    Sphere s1 = Sphere(vec3(0.0, 0.5, 0.0), 8.0);\n    Sphere s2 = Sphere(vec3(0.0, 0.5, 0.0), 6.0);\n    Sphere s3 = Sphere(vec3(10., -5., -10.), 15.0);\n    Sphere s4 = Sphere(vec3(2., 2., -2.), 2.0);\n    Box b = Box(vec3(1., 1., -4.), 1.);\n    float dtb = distToBox(r, b);\n    float d2s1 = distToSphere(r, s1);\n    float d2s2 = distToSphere(r, s2);\n    float d2s3 = distToSphere(r, s3);\n    float d2s4 = distToSphere(r, s4);\n    float dist = differenceOp(d2s1, d2s2);\n    dist = differenceOp(dist, d2s3);\n    dist = unionOp(dist, dtb);\n    dist = unionOp(d2p, dist);\n    return dist;\n}\n\nvec3 getNormal(in Ray ray) {\n \tvec2 eps = vec2(0.001, 0.0);\n    vec3 n = vec3(distToScene(Ray(ray.origin + eps.xyy, ray.dir)) - \n        \t\t  distToScene(Ray(ray.origin - eps.xyy, ray.dir)),\n        \t\t  distToScene(Ray(ray.origin + eps.yxy, ray.dir)) - \n        \t\t  distToScene(Ray(ray.origin - eps.yxy, ray.dir)),\n        \t\t  distToScene(Ray(ray.origin + eps.yyx, ray.dir)) - \n        \t\t  distToScene(Ray(ray.origin - eps.yyx, ray.dir)));\n    return normalize(n);\n}\n\nvec3 skyColor(in vec3 dir) {\n    return texture(iChannel0, dir).rgb;\n}\n\nfloat ao(in vec3 pos, in vec3 n) {\n    float eps = 0.01;\n    pos += n * eps * 2.0;\n    float occlusion = 0.0;\n    for (float i=1.0; i<10.0; i++) {\n        float d = distToScene(Ray(pos, vec3(0)));\n        float coneWidth = 2.0 * eps;\n        float occlusionAmount = max(coneWidth - d, 0.);\n        float occlusionFactor = occlusionAmount / coneWidth;\n        occlusionFactor  *= 1.0 - (i / 10.0);\n        occlusion = max(occlusion, occlusionFactor);\n        eps *= 2.0;\n        pos += n * eps;\n    }\n    return max(0.0, 1.0 - occlusion);\n}\n\nCamera setupCam(in vec3 pos, in vec3 target, in float fov, in vec2 uv) {\n    uv *= fov;\n    vec3 cw = normalize (target - pos);\n    vec3 cp = vec3 (0.0, 1.0, 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    vec3 dir = normalize (uv.x * cu + uv.y * cv + 0.5 * cw);\n    Ray ray = Ray(pos, dir);\n    Camera cam = Camera(pos, ray, fov / iResolution.x);\n    return cam;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.y *= iResolution.y / iResolution.x;\n    vec3 camPos = vec3(sin(iTime) * 10., 3., cos(iTime) * 10.);\n    Camera cam = setupCam(camPos, vec3(0), 1.25, uv);\n    vec3 col = vec3(1.);\n    bool hit = false;\n    float eps = 0.0;\n    for (int i=0; i<300; i++) {\n        float dist = distToScene(cam.ray); \n    \tif (dist < eps) {\n            hit = true;\n            break;\n        }\n        cam.ray.origin += cam.ray.dir * dist;\n        eps += cam.rayDivergence * dist;\n    }\n    if (!hit) { \n        col.rgb = skyColor(cam.ray.dir) + 0.3; \n    } else {\n        vec3 n = getNormal(cam.ray);\n\t\tfloat o = ao(cam.ray.origin, n);\n        col = col * o;\n    }\n    fragColor.rgb = col;\n}\n","name":"Image","description":"","type":"image"}]}