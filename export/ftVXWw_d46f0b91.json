{"ver":"0.1","info":{"id":"ftVXWw","date":"1640805049","viewed":174,"name":"Frankenshader's Lair","username":"Synthesoft","description":"I'm new to shader coding and this is a byproduct of my experimentation.  It's cobbled together from bits and pieces from a number of shaders but mostly from David Hoskins' amazing \"Remnant X\"","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["fractal","psychedelic","flythrough","mapmix"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This is a variation on Remnant X by David Hoskins.\n// Original: https://www.shadertoy.com/view/4sjSW1\n// \n// Frankeshaders Lair (https://www.shadertoy.com/view/ftVXWw)\n// Changes by Synthesoft: \n//     I took core + cinematics from Remnant X and...\n//      Added noise to surfaces\n//      Swapped out the original map() for two new ones which I mix together in Map() (Weight: fbvar2 & Mode: fbvar5) \n//         See MapA()/MapB() below for info on sources\n//         I was curious what it would look like to blend maps and was really pleased with the results\n//      Changed the Dizzolve sphere (fbvar3) 0.0-0.5 solid, 0.5..1.0 fuzz \n//      Parameterized FOV (fbvar4)   \n//      Replaced original color handling.  Made the colors annoyingly garish (it's a gift.  ...and a curse.)\n//      Added mix parameters\n//      Cleaned up vars\n//      Added some parmsets that produce interesting results \n//      Fixed lighting issues\n//      Added light originating from camera position\n\n//#define FLASHBACK\n#ifdef FLASHBACK\n// tl;dr - These are not the variables you're looking for (/gestures with hand)\n//\n// These vars are used by a Windows desktop application I'm writing called Flashback.  It \n// has sliders that adjust the values on-the-fly.  I've replaced them below with #defines for \n// some alternate configurations ( USE_PARMSET_[n] ) for ShaderToy\n//\n//#define FORCE_MISS_TO_BLACK\nuniform float iTime;\nuniform vec3 iResolution;\nuniform vec4 iMouse;\n\nuniform float fbvar1;  // fract iterations -- changes here are interesting\nuniform float fbvar2;  // Map weighting (when fbvar5 set to mix()) \nuniform float fbvar3;  // Dizzolve sphere: 0.0-0.5 solid, 0.5..1.0 fuzz \nuniform float fbvar4;  // FOV\nuniform float fbvar5;  // less than 0.5 = mix(), greater than 0.5 = min()    (Merge/mix vs Union)\nuniform float fbvar6;  // fractal calc tweaks\nuniform float fbvar7;  // brightness: light originating from camera position\nuniform float fbvar8;  // brightness: light originating from forward probe\nuniform float fbvar9;  // brightness: sun\n#else // not Flashback\n\n#define USE_PARMSET_1  // <-- Use this to change between parameter sets\n\n#ifdef USE_PARMSET_1  \n#define fbvar1 \t0.467\n#define fbvar2 \t0.399\n#define fbvar3 \t0.822\n#define fbvar4 \t0.128\n#define fbvar5 \t0.455\n#define fbvar6 \t0.115\n#define fbvar7 \t0.035\n#define fbvar8 \t0.060\n#define fbvar9 \t0.075\n#endif\n\n#ifdef USE_PARMSET_2\n#define fbvar1 \t0.536\n#define fbvar2 \t0.925\n#define fbvar3 \t0.888\n#define fbvar4 \t0.358\n#define fbvar5 \t0.461\n#define fbvar6 \t0.115\n#define fbvar7 \t0.027\n#define fbvar8 \t0.065\n#define fbvar9 \t0.080\n#endif\n\n\n#endif\n\n// #define STEREO\n\nvec3 sunDir = normalize(vec3(  0.35, 0.1,  0.3 ));\n\n#define pi 3.14159\n#define SCALE 2.8\n#define MINRAD2 .25\nfloat minRad2 = clamp(MINRAD2, 1.0e-9, 1.0);\n#define scale (vec4(SCALE, SCALE, SCALE, abs(SCALE)) / minRad2)\nvec3 col1,col2,col3;\nfloat gTime;\n\n\n//----------------------------------------------------------------------------------------\n\n#define CSize vec3(1., 1.7, 1.)\n\n// From Shane: https://www.shadertoy.com/view/lstGRB\nfloat Noise(vec3 p)\n{\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip; \n    p = p*p*(3. - 2.*p);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \n}\n\n//\n// Regular Menger Sponge formula. Very simple, but if you're not sure, look it\n// up on Wikipedia, and look up a Void Cube image.\n//\n// Pulled from source: https://www.shadertoy.com/view/ldyGWm\n//\nfloat MapB(vec3 q)\n{\n    \n    vec3 p;\n\t// Scale factor, and distance.\n    float s = 3., d = 0.;\n    \n    for(int i=0; i<int(fbvar1*6.+2.0); i++){\n \t\t// Repeat space.\n        p = abs(fract(q/s)*s - s/2.); // Equivalent to: p = abs(mod(q, s) - s/2.);\n\t\t// Repeat Void Cubes. Cubes with a cross taken out.\n \t\td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - s/3.);\n    \ts /= 3.; // Divide space (each dimension) by 3.\n    }\n \n \treturn d;    \n}\n\n// IFS, or KIFS in particular. The following explains the process in more detail.\n//\n// Kaleidoscopic (escape time) IFS - Knighty\n// http://www.fractalforums.com/ifs-iterated-function-systems/kaleidoscopic-(escape-time-ifs)/\n//\n// Here's a quick, rushed expanation. Take an input point, and repeat it. After that, rotate\n// it, fold it, stretch and translate it about an offset point. Form an object with it and compare\n// it to the object formed in the repeat layer. Repeat ad infinitum...\n//\n// OK, that was a little vague, but it really is a pretty simple process. Playing around with the \n// code will give it more meaning. Change the rotation angles, iteration number, comment some\n// things out, etc. I'd also recommend reading Syntopia's blog. He explains things really well...\n// and there's so many pretty pictures. :)\n//\n// Syntopia - http://blog.hvidtfeldts.net/\n//\n// Pulled from source: https://www.shadertoy.com/view/XsKXzc\n//\nfloat MapA(vec3 p){\n    \n    // I'm never sure whether I should take constant stuff like the following outside the function, \n    // or not. My 1990s CPU brain tells me outside, but it doesn't seem to make a difference to frame \n    // rate in this environment one way or the other, so I'll keep it where it looks tidy. If a GPU\n    // architecture\\compiler expert is out there, feel free to let me know.\n    \n    const vec3 offs = vec3(1, .75, .5); // Offset point.\n    const vec2 a = sin(vec2(0, 1.57079632) + 1.57/2.);\n    const mat2 m = mat2(a.y, -a.x, a);\n    const vec2 a2 = sin(vec2(0, 1.57079632) + 1.57/4.);\n    const mat2 m2 = mat2(a2.y, -a2.x, a2);\n    \n    const float s = 5.; // Scale factor.\n    \n    const float sz = .0355; // Box size.\n    #ifdef WIREFRAME\n    const float ew = .015; // Wireframe box edge width.\n    #endif\n    \n    float d = 1e5; // Distance.\n    \n    \n    p  = abs(fract(p*.5)*2. - 1.); // Standard spacial repetition.\n     \n    \n    float amp = 1./s; // Analogous to layer amplitude.\n    \n   \n    // With only two iterations, you could unroll this for more speed,\n    // but I'm leaving it this way for anyone who wants to try more\n    // iterations.\n    for(int i=0; i<int(1.+fbvar1*4.); i++){\n        \n        // Rotating.\n        p.xy = m*p.xy;\n        p.yz = m2*p.yz;\n        \n        p = abs(p);\n        //p = sqrt(p*p + .03);\n        //p = smin(p, -p, -.5); // Etc.\n        \n  \t\t// Folding about tetrahedral planes of symmetry... I think, or is it octahedral? \n        // I should know this stuff, but topology was many years ago for me. In fact, \n        // everything was years ago. :)\n\t\t// Branchless equivalent to: if (p.x<p.y) p.xy = p.yx;\n        p.xy += step(p.x, p.y)*(p.yx - p.xy);\n        p.xz += step(p.x, p.z)*(p.zx - p.xz);\n        p.yz += step(p.y, p.z)*(p.zy - p.yz);\n \n        // Stretching about an offset.\n\t\tp = p*s + offs*(1. - s);\n        \n\t\t// Branchless equivalent to:\n        // if( p.z < offs.z*(1. - s)*.5)  p.z -= offs.z*(1. - s);\n        p.z -= step(p.z, offs.z*(1. - s)*.5)*offs.z*(1. - s);\n        \n        // Loosely speaking, construct an object, and combine it with\n        // the object from the previous iteration. The object and\n        // comparison are a cube and minimum, but all kinds of \n        // combinations are possible.\n        p = abs(p);\n        vec3 q = p*amp;\n        //d = min(d, max(max(p.x, p.y), p.z)*amp - .035);\n        \n        // The object you draw is up to you. There are countless options.\n        float box = max(max(q.x, q.y), q.z) - sz;\n        //box = min(box, max(max(q.y, q.z) - sz*.33, q.x - sz*1.1));\n        //float box = max(length(q.yz) - sz*1.2, q.x - sz);\n        //float box = length(q) - sz; // A very spherical box. :)\n        #ifdef WIREFRAME\n        box = max(box, -(min(min(max(q.x, q.y), max(q.x, q.z)), max(q.y, q.z)) - sz + ew));\n        //box = max(box, -max(length(q.yz) - ew, q.x - sz - ew));\n        //box = max(box, -(max(length(q.yz - sz*.5) - ew*.35, q.x - sz - ew*.5)));\n        //box = max(box, -(max(q.y, q.z) - sz + ew));\n        #endif\n        // Vertices, of sorts.\n        //q = abs(q) - sz;\n        //box = min(box, length(q) - sz/3.);\n        d = min(d, box);\n        \n        \n        amp /= s; // Decrease the amplitude by the scaling factor.\n        \n    }\n \n \treturn d; // Return the distance.\n}\nfloat smin(float a, float b, float k)\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k)\n{\n    return smin(a, b, -k);\n}\n\nvec3 vmax(vec3 a, vec3 b)\n{\n    return vec3(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z));\n}\n\n\nfloat Map(vec3 v)\n{\n  if (fbvar5 < 0.5)\n\t\treturn mix(MapA(v),MapB(v), fbvar2);\n  else\n\t\treturn min(MapA(v),MapB(v));\n}\n\n//----------------------------------------------------------------------------------------\nfloat Hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 33758.5453)-.5;\n} \n\n//----------------------------------------------------------------------------------------\n\n\nvec3 Colour(vec3 pos) \n{\n  vec3 ca = (pos * col1);\n  vec3 cb = (pos * col2);\n  vec3 cc = (pos * col3);\n\n  vec3 c1 = vmax(ca,cb);\n  vec3 c2 = Noise(pos*100.) * cc;\nc1=abs(c1);\nc2=abs(c2);\n//  c1 *=c1;\n//  c2 *=c2;\n  return normalize(c1) + normalize(log(c2));\n}\n\n\n\n//----------------------------------------------------------------------------------------\nvec3 GetNormal(vec3 pos, float distance)\n{\n    distance *= 0.001+.0001;\n\tvec2 eps = vec2(distance, 0.0);\n\tvec3 nor = vec3(\n\t    Map(pos+eps.xyy) - Map(pos-eps.xyy),\n\t    Map(pos+eps.yxy) - Map(pos-eps.yxy),\n\t    Map(pos+eps.yyx) - Map(pos-eps.yyx));\n\treturn normalize(nor);\n}\n\n//----------------------------------------------------------------------------------------\nfloat BinarySubdivision(in vec3 rO, in vec3 rD, vec2 t)\n{\n    float halfwayT;\n  \n    for (int i = 0; i < 6; i++)\n    {\n\n        halfwayT = dot(t, vec2(.5));\n        float d = Map(rO + halfwayT*rD); \n        //if (abs(d) < 0.001) break;\n        t = mix(vec2(t.x, halfwayT), vec2(halfwayT, t.y), step(0.0005, d));\n\n    }\n\n\treturn halfwayT;\n}\n\n//----------------------------------------------------------------------------------------\nvec2 Scene(in vec3 rO, in vec3 rD, in vec2 fragCoord)\n{\n  float t;\n  if (fbvar3> 0.5)\n\t\tt = 0.001 + (1.0-fbvar3) + 0.04 * Hash(fragCoord*rO.x); // Dizzolve \n  else\n    t = 0.001 + (fbvar3);  // Clean\n\tvec3 p = vec3(0.0);\n  float oldT = 0.0;\n  bool hit = false;\n  float glow = 0.0;\n  vec2 dist;\n \n\tfor( int j=0; j < 100; j++ )\n\t{\n\t\tif (t > 12.0) break;\n        p = rO + t*rD;\n       \n\t\tfloat h = Map(p);\n        \n\t\tif (h  < 0.0005)\n\t\t{\n       dist = vec2(oldT, t);\n       hit = true;\n       break;\n    }\n\n   \tglow += clamp(.05-h, 0.0, .4);\n    oldT = t;\n  \tt +=  h + t*0.001;\n \t}\n\n#ifdef FORCE_MISS_TO_BLACK\n  if (!hit)\n    return vec2(0.0,0.0);\n  else     \n    t = BinarySubdivision(rO, rD, dist);\n#else\n\tif (!hit)\n     t = 1000.0;\n  else       \n     t = BinarySubdivision(rO, rD, dist);\n#endif\n\n  return vec2(t, clamp(glow*.25, 0.0, 1.0));\n}\n\n//----------------------------------------------------------------------------------------\nvec3 PostEffects(vec3 rgb, vec2 xy)\n{\n\t// Gamma first...\n\t\n\n\t// Then...\n\t#define CONTRAST 1.0\n\t#define SATURATION 1.2\n\t#define BRIGHTNESS 1.4\n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\n\t// Noise...\n\t//rgb = clamp(rgb+Hash(xy*iTime)*.1, 0.0, 1.0); \n\t// Vignette...\n\trgb *= .5 + 0.5*pow(20.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.2);\t\n\n    rgb = pow(rgb, vec3(0.47));\n\treturn rgb;\n}\n\n//----------------------------------------------------------------------------------------\nfloat Shadow( in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 0.05;\n\tfloat h;\n\t\n    for (int i = 0; i < 8; i++)\n\t{\n\t\th = Map( ro + rd*t );\n\t\tres = min(6.0*h / t, res);\n\t\tt += h;\n\t}\n    return max(res, 0.0);\n}\n\n//----------------------------------------------------------------------------------------\nmat3 RotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n//----------------------------------------------------------------------------------------\nvec3 LightSource(vec3 spotLight, vec3 dir, float dis)\n{\n    float g = 0.0;\n    if (length(spotLight) < dis)\n    {\n        float a = max(dot(normalize(spotLight), dir), 0.0);\n\t\tg = pow(a, 500.0);\n        g +=  pow(a, 5000.0)*.2;\n    }\n   \n    return vec3(.6) * g;\n}\n\n//----------------------------------------------------------------------------------------\nvec3 CameraPath( float t )\n{\n    vec3 p = vec3(-.78 + 3. * sin(2.14*t),.05+2.5 * sin(.942*t+1.3),.05 + 3.5 * cos(3.594*t) );\n\treturn p;\n} \n    \n//----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // three ever-changing colors used in\n    float fTime = iTime * 2.5;\n    col1 = vec3(sin(fTime/3.1), sin(fTime/4.3), sin(fTime/5.9)) + 2.1;  \n    col2 = vec3(cos(fTime/10.7), cos(fTime/8.9), cos(fTime/7.3)) + 2.1;  \n    col3 = vec3(sin(fTime/7.7), sin(fTime/9.3), sin(fTime/13.3)) + 2.1;  \n\t    \n    float m = (iMouse.x/iResolution.x)*300.0;\n\tgTime = (iTime+m)*.01 + 15.00;\n    vec2 xy = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (-1.0 + 2.0 * xy) * (vec2(iResolution.x/iResolution.y, 1.0) * (0.1+(fbvar4*5.0)));\n\t\n\t\n\t#ifdef STEREO\n\tfloat isRed = mod(fragCoord.x + mod(fragCoord.y, 2.0),2.0);\n\t#endif\n\n\tvec3 cameraPos\t= CameraPath(gTime);\n  vec3 camTar\t\t= CameraPath(gTime + .01);\n\n\tfloat roll = 13.0*sin(gTime*.5+.4);\n\tvec3 cw = normalize(camTar-cameraPos);\n\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\n\tvec3 cv = normalize(cross(cu,cw));\n  cw = RotationMatrix(cv, sin(-gTime*20.0)*.7) * cw;\n\tvec3 dir = normalize(uv.x*cu + uv.y*cv + 1.3*cw);\n\n\t#ifdef STEREO\n\tcameraPos += .008*cu*isRed; // move camera to the right\n\t#endif\n\n    vec3 spotLight = CameraPath(gTime + .05) + vec3(sin(gTime*19.4), cos(gTime*17.58), sin(gTime * 15.53))*.02;\n\t\tvec3 col = vec3(0.0);\n\t\tvec2 ret = Scene(cameraPos, dir,fragCoord);\n#ifdef FORCE_MISS_TO_BLACK\n    if (ret == vec2(0.0)) {\n\t\t\t\tfragColor=vec4(0.0,0.0,0.0,0.0);  // We missed so force to black\n\t\t\treturn;\n\t\t}\n#endif    \n\t\tif (ret.x < 900.0)\n    {\n\t\t\t\tvec3 p = cameraPos + ret.x*dir; \n\t\t\t\tvec3 nor = GetNormal(p, ret.x);\n        \n       \tvec3 spotDir = spotLight - p;\n        vec3 camDir = cameraPos - p;\n\n    \t\tfloat attenSpot = length(spotDir);\n    \t\tfloat attenCam = length(camDir);\n\n        spotDir /= attenSpot;\n        camDir /= attenCam;\n        \n        float shaSpot = Shadow(p, spotDir);\n        float shaSun = Shadow(p, sunDir);\n        float shaCam = 1.0;  // No need to calc shadows from light originating at the camera position\n        \n       \tfloat briCam = (max(dot(camDir, nor), 0.0) / pow(attenCam, 0.5)) * fbvar7;\n       \tfloat briSpot = (max(dot(spotDir, nor), 0.0) / pow(attenSpot, 1.5)) * fbvar8;\n        float briSun = max(dot(sunDir, nor), 0.0) * (fbvar9*2.);\n        \n       col = Colour(p) * 2.0;\n       col = (col * briSpot * shaSpot) + (col * briSun * shaSun)  + (col * briCam * shaCam);\n        \n       vec3 ref = reflect(dir, nor);\n       col += pow(max(dot(camDir,  ref), 0.0), 10.0) * 2.0 * shaCam * briCam;\n       col += pow(max(dot(spotDir,  ref), 0.0), 10.0) * 2.0 * shaSpot * briSpot;\n       col += pow(max(dot(sunDir, ref), 0.0), 10.0) * 2.0 * shaSun  * briSun;\n    }\n    \n    //col = mix(sky, col, min(exp(-ret.x+1.5), 1.0));\n    col += vec3(pow(abs(ret.y), 2.)) * vec3(.02, .04, .1); \n    col += LightSource(spotLight-cameraPos, dir, ret.x);\n\tcol = PostEffects(col, xy);\t\n\n\t\n\t#ifdef STEREO\t\n\tcol *= vec3( isRed, 1.0-isRed, 1.0-isRed );\t\n\t#endif\n\n\tcol = max(col, vec3(0.01,0.01,0.01)); // Force any hit to non-black\n\t\n\tfragColor=vec4(col,1.0);\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\n#ifdef FLASHBACK\nvoid main(void)\n{\n\t mainImage(gl_FragColor, gl_FragCoord.xy);\n} \n#endif\n\n","name":"Image","description":"","type":"image"}]}