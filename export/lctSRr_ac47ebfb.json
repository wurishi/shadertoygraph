{"ver":"0.1","info":{"id":"lctSRr","date":"1713809005","viewed":99,"name":"Progresive Penrose Pentagram","username":"mikceroese","description":"Spinning neon pink penrose tiling with progressive borders","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["neon","penrose"],"hasliked":0,"parentid":"lcK3Wd","parentname":"Penrose pentagram"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float GR = (1.0+sqrt(5.0))/2.0; // Golden ratio, diagonal of regular pentagon\nconst float GRI = 1.0/GR; // Inverse of the golden ratio\nconst float PI = 3.14159265; // Pi (duh)\nconst float DG_72 = PI/2.5; // 72 degrees\nconst float DG_36 = PI/5.0; // 36 degrees\nconst float COS_DG_36 = cos(DG_36); // Cosine of 36 degrees\nconst float SIN_DG_36 = sin(DG_36); // Sine of 36 degrees\nconst float DG_18 = PI/10.0; // 18 degrees\n\nconst vec2 SUN_TRI_A = vec2(0,0); // First half-dart vertex\nconst vec2 SUN_TRI_B = vec2(1,0); // Second half-dart vertex\nconst vec2 SUN_TRI_C = vec2(cos(DG_36),sin(DG_36)); // Third half-dart vertex\nconst float SUN_TRI_AREA = sin(DG_18)*cos(DG_18); // Area of a half-dart at step 0\n\nvoid triangle_area(out float area, out float height, in vec2 A, in vec2 B, in vec2 C)\n{\n    //Returns the area of a triangle,\n    //its height (assuming the B-C is the base)\n    area = abs((A.x*(B.y-C.y) + B.x*(C.y-A.y) + C.x*(A.y-B.y))/2.0);\n    height = 2.0*area/length(B-C);\n}\n\nvoid project_p_to_line(out float rel_proj, in vec2 P, in vec2 A, in vec2 B)\n{\n    //Returns the relative position of P's projection in the A-B line.\n    //(With a projection on A and B being a 0 and a 1, respectively)\n\n    vec2 ab = B-A;\n    vec2 ap = P-A;\n    float mag_ab = length(ab);\n\n    rel_proj = dot(ap,ab)/(mag_ab*mag_ab);\n\n}\n\nvoid is_p_in_tri(out bool is_in, out float dist, in vec2 P, in float target_area, in vec2 A, in vec2 B, in vec2 C)\n{\n    //Returns whether or not a point lies within a triangle of a given area, \n    //and how far it is from its nearest side.\n    \n    float area = 0.0, new_area;\n    float min_dist = 1.0, new_dist;\n    \n    triangle_area(new_area,new_dist,P,A,B);\n    min_dist = min(min_dist,new_dist);\n    area += new_area;\n    triangle_area(new_area,new_dist,P,B,C);\n    min_dist = min(min_dist,new_dist);\n    area += new_area;\n    triangle_area(new_area,new_dist,P,C,A);\n    min_dist = min(min_dist,new_dist);\n    area += new_area;\n    \n    dist = min_dist;    \n    \n    float area_diff = abs(area-target_area);\n    if(area_diff<1e-6){    \n        is_in = true;\n    } else {\n        is_in = false;\n    }\n    \n}\n\nvoid kite_or_dart(out float tile, out float dist, in float r, in float phi, in float steps){\n    // tile: Output 1 if the tile is a kite, or 0 if it is a dart.\n    // For steps with decimal part, tile is interpolated between the floor and ceil of steps.\n    // dist: Output the distance to the nearest side of the tile.\n    // For steps with decimal part, dist will consider unfinished sides and output\n    // the next shortest distance to a finished side.\n    \n    // Map every input to the same half-dart (radial simmetry, yay!)\n    // Angles are mirrored every 2 half-darts: 0ยบ to 36ยบ and back to 0ยบ\n    float new_phi = DG_36-abs(DG_36-(mod(phi,DG_72)));\n    // Radii are constrained to the triangle\n    // Small values are bumped up a little\n    // Big values are brought down to prevent them from strayin too far,\n    // down to the distance to the point of intersection between \n    // the uv vector and the far side of the triangle (or smaller)\n    float max_r = 1.0/(cos(new_phi)-sin(new_phi)*(COS_DG_36-1.0)/SIN_DG_36);\n    //float new_r = clamp(r,1e-6,max_r); // Using this one produces black outside\n    float new_r = max_r-abs(max_r-mod(r,2.0*max_r)); // This one mirrors the pattern outside-in\n    \n    vec2 uv = new_r*vec2(cos(new_phi),sin(new_phi));\n    \n    // The area of the tiles is always reduced by the inverse of the\n    // golden ratio every step, so you know the area they should\n    // have if you count the steps\n    float target_dart_area = SUN_TRI_AREA;\n    float target_kite_area = 0.0;\n    \n    // The Penrose Sun always starts as 10 half-darts\n    bool is_kite_ceil = false;\n    bool is_kite_floor = false;\n    float floor_dist = 1.0;\n    float ceil_dist = 1.0;\n    vec2 a = SUN_TRI_A;\n    vec2 b = SUN_TRI_B;\n    vec2 c = SUN_TRI_C;\n    \n    vec2 d, e, f;\n    vec2 cut_start, cut_stop;\n    float a1, a2, h1, h2;\n\n    d = a+(b-a)/GR;\n    e = b+(a-b)/GR;\n    f = b+(c-b)/GR;\n\n    bool is_in;\n    \n    float i = 0.0;\n    \n    // At every step\n    while (i<ceil(steps)){\n        // Precalc the area of kites and darts for next step\n        target_kite_area = target_dart_area*GRI;\n        target_dart_area = target_dart_area*(1.0-GRI);\n        is_kite_floor = is_kite_ceil;\n        floor_dist = ceil_dist;\n        // Split the current triangle\n        if (is_kite_floor){\n            // For kites, we need two cuts\n            is_p_in_tri(is_in,ceil_dist,uv,target_kite_area,f,c,a);\n            cut_start = a;\n            cut_stop = f;\n            if(is_in){\n                b = c;\n                c = a;\n                a = f;\n                //is_kite_ceil = true;\n            } else {\n                is_p_in_tri(is_in,ceil_dist,uv,target_kite_area,e,f,b);\n                if(is_in){\n                    cut_start = e;\n                    cut_stop = f;\n                    c = b;\n                    a = e;\n                    b = f;\n                    //is_kite_ceil = true;\n                } else {\n                    is_p_in_tri(is_in,ceil_dist,uv,target_dart_area,f,e,a);\n                    triangle_area(a1,h1,uv,a,f);\n                    triangle_area(a2,h2,uv,e,f);\n                    if(h1>h2){\n                        cut_start = e;\n                        cut_stop = f;\n                    }\n                    c = a;\n                    a = f;\n                    b = e;\n                    is_kite_ceil = false;\n                }\n            }\n        }else{\n            // For darts, we need one cut\n            is_p_in_tri(is_in,ceil_dist,uv,target_kite_area,d,c,a);\n            cut_start = d;\n            cut_stop = c;\n            if(is_in){\n                b = c;\n                c = a;\n                a = d;\n                is_kite_ceil = true;                \n            } else {\n                is_p_in_tri(is_in,ceil_dist,uv,target_dart_area,c,d,b);\n                a = c;\n                c = b;\n                b = d;\n                //is_kite_ceil = false;\n            }\n        }\n        \n        i += 1.0;\n\n        // Update the cut points for next iteration\n        d = a+(b-a)/GR;\n        e = b+(a-b)/GR;\n        f = b+(c-b)/GR;\n\n    }\n    \n    float p_proj;\n    project_p_to_line(p_proj,uv,cut_start,cut_stop);\n    //float dist_factor = float(p_proj<(steps-floor(steps)));\n    float dist_factor = 1.0-smoothstep(max(0.0,steps-floor(steps)-0.05),min(1.0,steps-floor(steps)+0.05),p_proj);\n    dist = dist_factor*min(floor_dist,ceil_dist) + (1.0-dist_factor)*floor_dist;\n    tile = float(is_kite_floor)*(1.0-steps+floor(steps)) + float(is_kite_ceil)*(1.0-ceil(steps)+steps);\n        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord *2.0 - iResolution.xy) / iResolution.y;\n    // Obtain distance to center and angle from +X axis\n    float r = length(uv);\n    float phi = atan(uv.x,uv.y) + PI;\n    // Define the number of subdivisions\n    float max_steps = 4.000;\n    float steps = 1.0001 + ((sin(iTime)+1.0)/2.0)*max_steps;\n    \n    float tile;\n    float d;\n    \n    phi += sin(iTime*0.2+1.0) + r*sin(iTime*0.2);\n    \n    kite_or_dart(tile,d,r,phi,steps);\n    \n    d = steps*sqrt(d)/sqrt(r);\n    \n    vec3 color = vec3((0.5 + 0.1*tile)/d,(0.3 - 0.2*tile)/d,(0.4 + 0.1*tile)/d);\n    //vec3 color = vec3(d,d,d);\n\n    // Output to screen\n    fragColor = vec4(0.6*color,1.0);\n}","name":"Image","description":"","type":"image"}]}