{"ver":"0.1","info":{"id":"tdsfDX","date":"1589228339","viewed":264,"name":"Monte Carlo Laplace 2D","username":"dreeves","description":"Testing mixed(?) boundary conditions in the Monte Carlo Laplace estimator from (1) by discarding samples from walks that terminate at certain boundary locations.\n\n1) http://www.cs.cmu.edu/~kmcrane/Projects/MonteCarloGeometryProcessing/index.html","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["2d","montecarlo","laplace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This is a 2D example of the Monte Carlo Laplace estimator introduced by\n// Keenan Crane and Rohan Sawhney in (1). It borrows liberally from previous\n// examples by Inigo Quilez (2, 3).\n//\n// This version experiments with mixed(?) boundary conditions by discarding\n// samples from walks that terminate at certain locations on the boundary.\n//\n// Click and drag to the right to increase the number of contours.\n//\n// 1) http://www.cs.cmu.edu/~kmcrane/Projects/MonteCarloGeometryProcessing/index.html\n// 2) https://www.shadertoy.com/view/WsXBzl\n// 3) https://www.shadertoy.com/view/WdXfzl\n\n#define GRAYSCALE 1\n#define ANIMATE 1\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float t = (data.y > 0.0)? data.x / data.y : 0.0;\n    \n    #if ANIMATE\n    t += iTime * 0.2;\n    #endif\n    \n    float width = mix(1.0, 0.01, iMouse.x / iResolution.x);\n    t = abs(fract(t / width) - 0.5) * 2.0;\n    \n    #if GRAYSCALE\t\n    fragColor = vec4(t, t, t, 1.0);\n    #else\n    vec3 col = palette(t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(2.0, 1.0, 0.0), vec3(0.5, 0.20, 0.25));\n\tfragColor = vec4(col, 1.0);\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define TWO_PI 6.283185\n#define RAND_MAX 32767\n\nint seed_ = 1;\n\nvoid srand(int seed)\n{\n    seed_ = seed;\n}\n\n// Returns a random integer between 0 and RAND_MAX exclusive\n// Copied from Inigo Quilez (https://www.shadertoy.com/view/wdfBRl)\nint rand()\n{\n    seed_ = seed_ * 0x343fd + 0x269ec3;\n    return (seed_ >> 16) & RAND_MAX;\n}\n\n// Returns a random float between 0.0 and 1.0 inclusive\nfloat rand01()\n{\n    return float(rand()) / float(RAND_MAX - 1);\n}\n\n// Cosine based color palette\n// Copied from Inigo Quilez (https://www.shadertoy.com/view/ll2GD3)\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    return a + b * cos(TWO_PI * (c * t + d));\n}\n\n//\nfloat clamp01(float x)\n{\n    return clamp(x, 0.0, 1.0);\n}\n\n//\nfloat squaredLength(vec2 x)\n{\n    return dot(x, x);\n}\n\n// Returns the projection of u onto v\nvec2 project(vec2 u, vec2 v)\n{\n    return (dot(u, v) / dot(v, v)) * v;\n}\n\n// Returns the rejection of u onto v\nvec2 reject(vec2 u, vec2 v)\n{\n    return u - project(u, v);\n}\n\n// For the given point, returns the parameter of the closest point on the given line.\nfloat lineClosestPoint(vec2 point, vec2 start, vec2 delta)\n{\n    return dot(point - start, delta) / dot(delta, delta);\n}\n\n// For the given point, returns the parameter of the closest point on the given line segment.\nfloat segmentClosestPoint(vec2 point, vec2 start, vec2 delta)\n{\n    return clamp01(lineClosestPoint(point, start, delta));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_DISTANCE 1.0e6\n#define MIN_DISTANCE 1.0e-2\n#define MAX_STEPS 128\n#define NUM_SEGMENTS 4\n\n// Start point of each boundary segment\nconst vec2 segmentStarts[NUM_SEGMENTS] = vec2[](\n    vec2(-1.0, -0.25), \n    vec2(1.0, -0.25), \n    vec2(-0.333, 0.0),\n    vec2(0.333, 0.0)\n);\n\n// End point of each boundary segment\nconst vec2 segmentEnds[NUM_SEGMENTS] = vec2[](\n    vec2(-1.0, 0.25), \n    vec2(1.0, 0.25),\n    vec2(-0.333, 0.5),\n    vec2(0.333, -0.5)\n);\n\n// Value associated with each boundary segment\nconst float segmentVals[NUM_SEGMENTS] = float[](\n    0.0, \n    1.0,\n    0.0,\n    0.0\n);\n\n// Sample weight associated with each boundary segment\nconst float segmentWeights[NUM_SEGMENTS] = float[](\n    1.0,\n    1.0,\n    0.0,\n    0.0\n);\n\nstruct BoundaryPoint\n{\n    int segment;\n    float t;\n};\n\n// Returns the closest point on the boundary along with the distance to that point.\nBoundaryPoint boundaryClosestPoint(vec2 point, out float distance)\n{\n    BoundaryPoint bp;\n    distance = MAX_DISTANCE * MAX_DISTANCE;\n\n    for(int i = 0; i < NUM_SEGMENTS; ++i)\n    {\n        vec2 p = segmentStarts[i];\n        vec2 d = segmentEnds[i] - p;\n\n        float t = segmentClosestPoint(point, p, d);\n        vec2 cp = p + d * t;\n\n        float dist = squaredLength(point - cp);\n\n        if(dist < distance)\n        {\n            distance = dist;\n            bp.segment = i;\n            bp.t = t;\n        }\n    }\n\n    distance = sqrt(distance);\n    return bp;\n}\n\n// Returns a random point on the unit circle.\nvec2 randomOnCircle()\n{\n    float t = TWO_PI * rand01();\n    return vec2(cos(t), sin(t));\n}\n\n// Returns a single Monte Carlo sample at the given point via \"Walk on Spheres\" method.\nfloat walk(vec2 point, out float weight)\n{\n    BoundaryPoint bp;\n\n    for(int i = 0; i < MAX_STEPS; ++i)\n    {\n        float dist;\n        bp = boundaryClosestPoint(point, dist);\n\n        if(dist < MIN_DISTANCE)\n            break;\n\n        point += dist * randomOnCircle();\n    }\n\n    weight = segmentWeights[bp.segment];\n    return segmentVals[bp.segment];\n}\n\n// Integer hash\n// Copied from Hugo Elias (https://www.shadertoy.com/view/llGSzw)\nint hash(int n) \n{\n    n = (n << 13) ^ n;\n    return n * (n * n * 15731 + 789221) + 1376312589;\n}\n\n// Seeds the random number generator with the given frag coord\nvoid seed(ivec2 fragCoord)\n{\n    srand(hash(fragCoord.x + hash(fragCoord.y + hash(iFrame))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    seed(ivec2(fragCoord));\n\n    // Create sample point with x in [-1, 1]\n    vec2 p = (fragCoord * 2.0 - iResolution.xy) / iResolution.x;\n\n    // Take sample\n    float w;\n    float u = walk(p, w);\n\n    // Add sample to running sum\n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = prev + vec4(u * w, w, 0.0, 0.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}