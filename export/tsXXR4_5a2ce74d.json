{"ver":"0.1","info":{"id":"tsXXR4","date":"1635062316","viewed":325,"name":"Caustic renderer","username":"KylBlz","description":"Just wanted to render some volume caustics using some better sampling techniques. The code is not properly done or even finished. There's plenty of messy dead code, too. No reprojection yet either.\nControls: WASD/arrow keys, shift, space, mouse","likes":11,"published":1,"flags":48,"usePreview":0,"tags":["volume","caustic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 smp = textureLod(iChannel0, uv, 0.);\n    //done\n    fragColor = vec4(ACESFilm(EXPOSURE * smp.rgb / smp.a), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define BOUNCE_PXL\t3\n#define GAMMA\t\t.6\n#define EXPOSURE\t20.\n\n// geometry\n#define SD_SAMPLES\t\t\t64\n// surface functions\n#define USE_BLINN_PHONG\n// volume functions\n#define USE_EAS\n#define     EAS_SAMPLES\t\t16\n#define     EAS_SAMPLES_RCP\t.0625\n#define CAUSTICS\n#define     CAUS_LIT_SAMPLES\t\t8\n#define     CAUS_EAS_SAMPLES\t\t8\n#define     CAUS_EAS_SAMPLES_RCP\t0.0625\n\n// Some shortcuts\n#define v20 vec2(0.)\n#define v21 vec2(1.)\n#define v30 vec3(0.)\n#define v31 vec3(1.)\n#define v40 vec4(0.)\n#define v41 vec4(1.)\n#define vec3max(a) max(a.x, max(a.y, a.z))\n#define vec3min(a) min(a.x, min(a.y, a.z))\n#define vec4max(a) max(max(a.x, a.y), max(a.z, a.w))\n#define vec4min(a) min(min(a.x, a.y), min(a.z, a.w))\n#define inRange(a,x,b) step(a,x)*step(x,b)\n#define tex(a,b) textureLod(a,b,0.)\n#define texComp(a,b,c) vec4max((tex(a, b) * c))\n// trick by klems\n#define ZERO (min(iFrame,0))\n\nconst float\teps = .0001, ieps = .9999, sml = .001, isml = .999, zfar = 33.,\n\t\t\tpi_rcp = .3183098, pi2_rcp = .1591549, pi4_rcp = .0795775,\n    \t\tpi_5 = 1.5707963, pi = 3.1415926, pi2 = 6.2831853, pi4 = 12.56637,\n\t\t\tsc45 = .7071067, s60 = .866025, sqrt2 = 1.4142135, sqrt3 = 1.732050808;\nconst vec2\tVEL = vec2(0.5), POS = vec2(1.5, 0.5), ROT = vec2(2.5, 0.5), MOU = vec2(3.5, 0.5);\n\n//Reflect, Transmit, Emit rgb wavelengths, Surface scatter, sUbsurface scatter, refractive index, Emission Uniformity, unique iDentifier\nstruct mat { vec3 r, t, e; float s, u, ior, eu; int d; };\n//1D line segment with signed IDs for each end point\nstruct seg { vec2 t; ivec2 d; };\n//Location, Normal, segment, Object id, current Material\nstruct hit { vec3 l, n; seg s; int o, m; };\n//Origin, Direction, Color, current Material\nstruct ray { vec3 o, d, c; mat m; };\n//Location, Normal, Distance, Object id\nstruct sdf { float d; int o, m; };\n//Output structure holding two colors\nstruct mad { vec3 m, a; };\n\n//center Location, Radius, Material, iDentifier\nstruct sph { vec3 l; float r; int m, d; };\n//Location, Normal, size, Material, iDentifier\nstruct pln { vec3 l; mat3 o; int m, d; };\n\nconst mat nullMat = mat(v30, v31, v30, 0., 0., 0., 0., -1);\nconst seg nullSeg = seg(vec2(zfar), ivec2(0));\nconst hit nullHit = hit(v30, v30, nullSeg, 0, -1);\nconst sdf nullSdf = sdf(zfar, -1, -1);\nconst vec2 nullT = vec2(zfar, 0.);\n\n\n//////////////////////////////// random ////////////////////////////////\n// generate a unique value for each pixel/sample/frame\nuvec3 seed(in uint iFrame, in uint smp, in uvec2 fragCoord) {\n    uvec2 s = fragCoord + iFrame + smp;\n    return uvec3(s, uint(s.x) ^ uint(s.y));\n}\n// fast and good quality, thanks iq https://www.shadertoy.com/view/4tXyWN\nfloat iqint3(uvec2 v) {\n    uvec2 q = 1103515245U * ((v>>1U) ^ (v.yx   ));\n    uint  n = 1103515245U * ((q.x  ) ^ (q.y>>3U));\n    return float(n) * (1.0 / float(0xffffffffU));\n}\n// even better quality, thanks markjarzynski https://www.shadertoy.com/view/XlGcRh\nfloat pcg1d(uint v) {\n\tuint state = v * 747796405u + 2891336453u;\n\tuint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n\treturn float((word >> 22u) ^ word) * (1.0 / float(0xffffffffU));\n}\nvec3 pcg3d(uvec3 v) {\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v ^= v >> 16u;\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    return vec3(v) * (1.0 / float(0xffffffffU));\n}\n// thanks hornet https://www.shadertoy.com/view/4ssXRX\nfloat hrg3d(uvec3 v) {\n\tfloat r0 = iqint3(v.xz);\n\tfloat r1 = iqint3(v.zy);\n\treturn 0.23 * sqrt(-log(r0 + 0.00001))*cos(pi2 * r1) + 0.5;\n}\n\nvec3 rotateXY(in vec3 p, in vec2 angle) {\n\tvec2 c = cos(angle), s = sin(angle); vec3 o = p;\n\to.yz *= mat2(c.x, s.x, -s.x, c.x); \n    o.xz *= mat2(c.y, s.y, -s.y, c.y);\n\treturn o;\n}\nvoid basis(in vec3 n, out vec3 f, out vec3 r) {\n    float s = (n.z >= 0.0)? 1.0: -1.0;\n    float a = 1.0 / (s + n.z);\n    float b = -n.x*n.y*a;\n    f = vec3(1.0 - n.x*n.x*a*s, b*s, -n.x*s);\n    r = vec3(b, s - n.y*n.y*a, -n.y);\n}\nvec3 slerp(in vec3 start, in vec3 end, in float percent) {\n\tfloat dt = dot(start, end),\n          theta = acos(dt)*percent;\n\treturn start*cos(theta) + normalize(end - start*dt)*sin(theta);\n}\n// tone mapping https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x) {\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), v30, v31);\n}\n// linear angle of sphere at distance D with radius R\nfloat linearAngle(float d, float r) {\n    return asin(clamp(r/d, 0.0, 1.0));\n}\n\n//////////////////////////////////////////// direct light sampling ////////////////////////////////////////////\n// uniform sample cone\nvec3 randomConeSample(out float density, vec3 lv, float lr, in uvec3 seed) {\n    float rad = hrg3d(seed);\n    float tha = iqint3(seed.xy) * pi2;\n    vec3 r, u;\n    basis(normalize(lv), r, u);\n    r *= cos(tha);\n    u *= sin(tha);\n    float llv = length(lv);\n    float sa = linearAngle(llv, lr);\n    density = 1.0 / (linearAngle(dot(lv, lv), lr) * pi);\n    return normalize((lv / llv) + (sin(sa) / cos(sa)) * rad * (r + u));\n}\n\n//////////////////////////////////////////// Normal functions ////////////////////////////////////////////\nvec3 nrm(in vec3 l, in sph s) {\n    return (l - s.l) / s.r;   \n}\nvec3 nrm(in vec3 l, in pln p) {\n    return p.o[1];\n}\n\n//////////////////////////////////////////// UV map functions ////////////////////////////////////////////\nvec2 map(in vec3 l, in vec3 n, in sph s) {\n    return vec2(atan(n.z, n.x) + pi, acos(-n.y)) / vec2(pi2, pi);\n}\nvec2 map(in vec3 l, in sph s) {\n    vec3 n = nrm(l, s);\n    return map(l, n, s);\n}\nvec2 map(in vec3 l, in pln p) {\n    return vec2(dot(l, p.o[0]), dot(l, p.o[2]));\n}\n\n//////////////////////////////////////////// Segment functions ////////////////////////////////////////////\nseg rs(in ray r, in sph s) {\n    vec3 oc = r.o - s.l;\n    float c = dot(oc, oc) - s.r * s.r,\n          b = -dot(oc, r.d), h = b*b - c;\n    if (h < 0.) return nullSeg;\n    h = sqrt(h);\n    return seg(vec2(b-h,b+h), ivec2(s.d, -s.d));\n}\nseg rs(in ray r, in pln p) {\n    float t = dot(p.o[1], p.l - r.o) / dot(p.o[1], r.d);\n\treturn seg(vec2(t, t + eps), ivec2(p.d, -p.d));\n}\n\n//////////////////////////////////////////// Segment operators ////////////////////////////////////////////\n#define len(a) (a.t.y - a.t.x)\n#define minT(a) ((a.y<a.x)? zfar: (a.x<0.)? (a.y<0.)? zfar: a.y: a.x)\n\nvoid lt(inout seg o, in seg s) {\n    if (minT(s.t) < minT(o.t))\n        o = s;\n}\nvec2 lt(in seg s) {\n    if (s.t.x < s.t.y && s.t.x > 0.) return vec2(s.t.x, float(s.d.x));\n    else if (s.t.y > 0.) return vec2(s.t.y, float(s.d.y));\n    return nullT;\n}\n////////////////////////////////////////// Hit functions //////////////////////////////////////////\nvoid lt(inout hit o, in hit h) { if (minT(h.s.t) < minT(o.s.t)) o = h; }\n// raytrace function\n#define _trc \\\n    seg s = rs(r, o); \\\n    vec3 l = r.o + r.d * minT(s.t); \\\n    hit h = hit(l, nrm(l, o), s, o.d, o.m)\n\nhit trace(in ray r, in sph o) { _trc; return h; }\nhit trace(in ray r, in pln o) { _trc; return h; }\n\n\n////////////////////////////////////////// Surface functions //////////////////////////////////////////\nfloat Schlick(in float r1, in float r2, in float vn) {\n\tfloat r0 = (r1 - r2) / (r1 + r2);\n\treturn mix(r0*r0, 1., pow(1. - vn, 5.));\n}\nfloat Blinn(in vec3 hn, in vec3 rd, in vec3 lv, in float roughness) {\n    vec3 H = normalize(rd + lv);\n    float dotNH = clamp(dot(hn, H), 0., 1.);\n    return (roughness + 2.) / (8. * pi) * pow(dotNH, roughness);\n}\nfloat Lambertian(in vec3 hn, in vec3 lv) {\n    return clamp(dot(hn, lv), 0., 1.) * pi_rcp;\n}\n// ratio of solid angles (new fixed normalization)\nfloat ROSA(in vec3 l, in sph lit, in sph occ) {\n    vec3 lv = lit.l - l,\n         ov = occ.l - l;\n    float ld = sqrt(dot(lv, lv)),\n          od = sqrt(dot(ov, ov)),\n          sal = linearAngle(ld, lit.r),\n          sao = linearAngle(od, occ.r),\n          fsa = sal;\n    if (od < ld) {\n        float theta = acos(dot(lv / ld, ov / od));\n\t    fsa *= 1. - clamp((sao - theta) / sal, 0., 1.);\n    }\n    return fsa / sal;\n}\n\n////////////////////////////////////////// Volume functions //////////////////////////////////////////\n//thanks sjb https://www.shadertoy.com/view/Xdf3zB\nvoid sampleEquiAngular(float u, float t2, vec3 ro, vec3 rd, vec3 l, out float d, out float pdf) {\n\t// get coord of closest point to light along (infinite) ray\n\tfloat delta = dot(l - ro, rd),\n          // get distance this point is from light\n          D = length(ro + delta*rd - l),\n          // get angle of endpoints\n          thetaA = atan(-delta, D),\n          thetaB = atan(t2 - delta, D),\n          t = D*tan(mix(thetaA, thetaB, u));\n    // take sample\n\td = delta + t;\n\tpdf = D / ((thetaB - thetaA) * (D*D + t*t));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// 3D scene\n\n#define LIGHT_COUNT 1\n#define LIGHT_COUNT_RCP 1.\n\n// IDs\nconst int\n// Materials\n_air = 0, _wht_e = 1, _mball = 2, _mgrnd = 3,\n// Primitivies\n_lit1 = 1, _sph1 = 2, _pln1 = 3;\n\n//////////////////////////////////////// Raytrace Primitives ////////////////////////////////////////\nsph[] lights = sph[] (\n    sph(v30, 0., 0, 0),\n    sph(vec3(1.0, 1.5, 0.5), .25, _wht_e, _lit1)\n);\nsph sph1 = sph(vec3(0., 0., 0.), .5, _mball, _sph1);\npln pln1 = pln(vec3(0., -2., 0.), mat3(1.), _mgrnd, _pln1);\n\n//////////////////////////////////////////// Materials /////////////////////////////////////////////\nconst mat[] matLib = mat[] (\n    mat(v31, v31, v30, .01, .01, 1.0003, 0., _air),\n\tmat(v31, v31, vec3(64.), 1., 1., -1., 0., _wht_e),\n    mat(vec3(.1,.15,.1), vec3(.1,.3,.9), v30, 64.0, 64.0, 2.0, 0.0, _mball),\n    mat(vec3(.02), v30, v30, .5, 1., -1., 0., _mgrnd)\n);\n\nvoid updateMaterials(inout ray r, inout hit res) {\n    if (res.m < 0) r.m = nullMat;\n    else r.m = matLib[res.m];\n}\n\n//////////////////////////////////////////// Scene //////////////////////////////////////////////\nhit traceScene(in ray r) {\n\thit ret = nullHit;\n    lt(ret, trace(r, pln1));\n    lt(ret, trace(r, sph1));\n    lt(ret, trace(r, lights[_lit1]));\n    if (dot(ret.n, r.d) > 0.) ret.n *= -1.;\n\treturn ret;\n}\n\n///////////////////////////////////////// Shading functions ////////////////////////////////////////\n// how the color integration behaves\nmad shade_blinn_phong(in ray r, in hit h) {\n\tvec3 col = v30;\n\tfor (int i = 1; i <= LIGHT_COUNT; ++i) {\n\t\tsph l = lights[i];\n\t\tvec3 Li = matLib[l.m].e,\n\t\t     nlv = normalize(l.l - h.l);\n\t\thit res = traceScene(ray(h.l + h.n*sml, nlv, v30, nullMat));\n\t\tfloat blinn = Blinn(h.n, -r.d, nlv, r.m.s * 256.) * r.m.s * .05,\n              lamb = Lambertian(h.n, nlv) / r.m.s,\n\t\t\t  thickness = len(res.s),\n              sa = ROSA(h.l, l, sph1);\n\t\tcol += lamb * r.m.r * sa * Li;\n\t}\n\tcol += r.m.e;\n    return mad(v31, col);\n}\n\n//how the ray behaves\nvoid brdf(inout ray r, inout hit res) {\n    mat m = matLib[res.m];\n    //calculate roughness (randomness) of surface\n    float roughness = m.s,\n          //calculate view angle of surface\n          ndotr = dot(res.n, -r.d),\n\t\t  //decide the ray's fate\n          sch = Schlick(r.m.ior, m.ior, ndotr),\n\t\t  //reflect or refract chance if \n\t\t  ror = step(m.ior, 0.) * 2. - 1.;\n\t//for insulators reduce roughness instead of refracting?\n\tvec3 newDir = (m.ior > 0.)? refract(r.d, res.n, r.m.ior / m.ior): reflect(r.d, res.n);\n    //new ray properties\n\tr.o = res.l + res.n*eps*ror;\n\tr.d = newDir;\n    r.c *= (m.ior > 0.)? m.t: m.r;\n    r.m = m;\n    // enter new medium\n    //if (m.ior > 0.) r.m = m;\n}\n\n////////////////////////////////////////// Volume functions //////////////////////////////////////////\nmad marchEAS(in ray r, in seg s, out vec2 occ, in uvec2 seed) {\n\tvec3 col = v30;\n\tfloat SIGMA = .1, SMP = float(EAS_SAMPLES), x;\n    bool is_occ = false;\n    \n\tfor (int i = 0; i < EAS_SAMPLES; ++i) {\n\t\tfor (int j = 1; j <= LIGHT_COUNT; ++j) {\n\t\t\tsph lit = lights[j];\n\t\t\tvec3 inten = matLib[lit.m].e;\n            seed += uint(i * LIGHT_COUNT + j);\n            // normalized progress, length of step, pdf\n\t\t\tfloat offset = iqint3(seed.xy),\n\t\t\t\t  u = (float(i) + offset) * EAS_SAMPLES_RCP, pdf;\n\t\t\tsampleEquiAngular(u, s.t.y, r.o, r.d, lit.l, x, pdf);\t\t\n\t\t\t// adjust for number of ray samples\n\t\t\tpdf *= SMP;\n\t\t\t// connect to light and check shadow ray\n\t\t\tvec3 h = r.o + r.d * x,\n                 lightVec = lit.l - h;\n\t\t\tfloat d = length(lightVec);\n\t\t\t\n            // use ROSA for shading?\n            float trans = exp(-SIGMA*(d + x)),\n                  geomTerm = ROSA(h, lit, sph1);\n            col += x*inten*geomTerm*trans / pdf;\n            \n\t\t\t// try to get the range where it is occluded\n            hit res = traceScene(ray(h, lightVec / d, v30, matLib[_air]));\n\t\t\tif (res.o == j) {\n                // keep track of caustic march start/end\n                if (is_occ) {\n                    occ.y = x;\n                    is_occ = false;\n                }\n            } else if (res.o == _sph1) {\n                // only do caustics around sph1\n                if (!is_occ) {\n                    occ.x = x;\n                    is_occ = true;\n                }\n            }\n\t\t}\n\t}\n    // keep track of caustic march start/end\n    if (is_occ) {\n        occ.y = x;\n        is_occ = false;\n    }\n    return mad(v31-len(s)/zfar, .0001*SIGMA*col);\n}\n\nmad marchCaustic(in ray r, in seg s, in uvec2 seed) {\n\tvec3 col = v30;\n\tfloat SIGMA = .01, SMP = float(CAUS_EAS_SAMPLES), x;\n    vec3 ss = r.o + r.d * s.t.x;\n    uvec3 seed3 = uvec3(seed.xy, seed.x ^ seed.y);\n    \n\tfor (int i = 0; i < CAUS_EAS_SAMPLES; ++i) {\n        vec3 inten = matLib[_lit1].e;\n        seed3 += uint(i * CAUS_EAS_SAMPLES);\n        \n        // normalized progress, length of step, pdf\n        float offset = iqint3(seed3.xy), pdf,\n              u = (float(i) + offset) * CAUS_EAS_SAMPLES_RCP; // + offset\n        sampleEquiAngular(u, s.t.y - s.t.x, ss, r.d, sph1.l, x, pdf);\t\t\n        // adjust for number of ray samples\n        pdf *= SMP;\n        \n        vec3 h = ss + r.d * (s.t.y - s.t.x) * x,\n             caustVec = (sph1.l - h);\n\n        for (int j = 0; j < CAUS_LIT_SAMPLES; ++j) {\n            \n            seed3 += uint(j * CAUS_LIT_SAMPLES);\n        \n            float pdf2;\n            vec3 rd = randomConeSample(pdf2, caustVec, sph1.r, seed3);\n            //vec3 rd = caustVec;\n            ray r2 = ray(h, rd, v30, matLib[_air]);\n            hit res = traceScene(r2);\n\n            // accumulate particle response if not occluded\n            if (res.m == _sph1) {\n                brdf(r2, res);\n                updateMaterials(r2, res);\n                res = traceScene(r2);\n\n                if (res.m == _sph1) {\n                    brdf(r2, res);\n                    updateMaterials(r2, res);\n                    res = traceScene(r2);\n\n                    if (res.m == _lit1) {\n                        col += 0.005 / (pdf * pdf2);\n                    }\n                }\n            }\n        }\n    }\n    float ls = len(s);\n    return mad(v31, col);\n}\n\n//////////////////////////////////////////// Main Image /////////////////////////////////////////////\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    uvec2 seed = uvec2(fragCoord.xy) ^ uint(iTime * iResolution.x);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float asp = iResolution.x / iResolution.y;\n    //get input\n\tvec3 l = tex(iChannel0, POS / iResolution.xy).xyz,\n\t\t o = tex(iChannel0, ROT / iResolution.xy).xyz,\n\t\t d = rotateXY(normalize(vec3(vec2(asp, 1.) * (uv * 2. - 1.), 2.)), o.xy);\n    \n    //update objects\n    //lights[_lit1].l = sph1.l - vec3(1.5*sin(iTime), -1.5, 1.5*cos(iTime));\n    //lights[_lit1].r = .6 + .59 * cos(iTime * 3.);\n    \n    //geometry information\n\thit res;\n\t//final color\n    vec3 final = v30;\n    //final depth\n    float fragDepth, firstDepth, a, b;\n    \n    //start the ray at the camera\n    ray r = ray(l, d, v31, matLib[_air]);\n    //bounce around a few times\n    for (int i = 0; i < BOUNCE_PXL; i++) {\n        //new random seed\n        seed += uint(i * 127);\n        vec3 col = v30;\n        vec2 occ;\n        mad md;\n        //do entire scene (raytrace and raymarch)\n        res = traceScene(r);\n        fragDepth = minT(res.s.t);\n        \n        if (i == 0) {\n        \tfirstDepth = fragDepth;\n\n            md = marchEAS(r, seg(vec2(0., min(zfar*.333,fragDepth)), ivec2(0)), occ, seed);\n            col += md.a * r.c;\n            \n            if (occ.y - occ.x > 0.) {\n                mad md2 = marchCaustic(r, seg(occ, ivec2(0)), seed);\n                col += md2.a * r.c;\n            }\n            r.c *= md.m;\n        }\n\n        if (res.m > 0) {\n        \n            if (res.m == _mgrnd) {\n                for (int j = 0; j < CAUS_LIT_SAMPLES; ++j) {\n\n                    uvec3 seed3 = seed.xyx ^ uvec3(341 * j * CAUS_LIT_SAMPLES);\n                    vec3 h = res.l + res.n*0.01, caustVec = (sph1.l - h);\n                    float pdf2 = 0.;\n                    vec3 rd = randomConeSample(pdf2, caustVec, sph1.r, seed3);\n                    //vec3 rd = caustVec;\n                    ray r2 = ray(h, rd, v30, matLib[_air]);\n                    hit res = traceScene(r2);\n\n                    // accumulate particle response if not occluded\n                    if (res.m == _sph1) {\n                        brdf(r2, res);\n                        updateMaterials(r2, res);\n                        res = traceScene(r2);\n\n                        if (res.m == _sph1) {\n                            brdf(r2, res);\n                            updateMaterials(r2, res);\n                            res = traceScene(r2);\n\n                            if (res.m == _lit1) {\n                                col += 0.01 / pdf2;\n                            }\n                        }\n                    }\n                }\n            }\n        \n            // get the properties of the material\n            brdf(r, res);\n            updateMaterials(r, res);\n\t\t\tmd = shade_blinn_phong(r, res);\n            col += md.a * r.c;\n            r.c *= md.m;\n        }\n        \n        final += col; // + vec3(0., 0., (occ.y - occ.x > 0.)? (occ.y - occ.x)*.1: 0.);\n\n        if (res.m <= 0) break;\n\n    }\n    \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    if (iMouse.z < 0.0001)\n        fragColor += textureLod(iChannel1, uv, 0.);\n    // the alpha channel is the blur strength\n    fragColor += vec4(final, 1.0);\n    \n    \n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// controls\n\n//#define INVERT_ROTATION\n\n#define MAX_ACCELERATION      4.\n#define MAX_VELOCITY          4.\n#define FRICTION              2.\n\n#define VALUE_VELOCITY        0\n#define VALUE_POSITION        1\n#define VALUE_ROTATION        2\n#define VALUE_MOUSE           3\n\n//controls\nconst vec2 KEY_W \t = vec2(87.5 / 256., 0.),\n    \t   KEY_S \t = vec2(83.5 / 256., 0.),\n    \t   KEY_A \t = vec2(65.5 / 256., 0.),\n    \t   KEY_D \t = vec2(68.5 / 256., 0.),\n\t\t   KEY_LEFT  = vec2(37.5 / 256., 0.),\n\t\t   KEY_UP    = vec2(38.5 / 256., 0.),\n\t\t   KEY_RIGHT = vec2(39.5 / 256., 0.),\n\t\t   KEY_DOWN  = vec2(40.5 / 256., 0.),\n    \t   KEY_SHIFT = vec2(16.0 / 256., 0.),\n    \t   KEY_SPACE = vec2(32.0 / 256., 0.);\n\nconst vec4 INIT_POS = vec4(-5.0, -0.75, 1.0, 0.),\n    \t   INIT_VEL = vec4(0.),\n    \t   INIT_ROT = vec4(0.0, 1.8, 0., 0.),\n    \t   INIT_MOU = vec4(0.);\n\nvec3 vRotateY(vec3 p, float angle) {\n    float c = cos(angle), s = sin(angle);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\n\nvec3 getAcceleration() {\n    return vec3(\n        tex(iChannel1, KEY_D).x - tex(iChannel1, KEY_A).x + tex(iChannel1, KEY_RIGHT).x - tex(iChannel1, KEY_LEFT).x,\n        tex(iChannel1, KEY_SPACE).x - tex(iChannel1, KEY_SHIFT).x,\n        tex(iChannel1, KEY_W).x - tex(iChannel1, KEY_S).x + tex(iChannel1, KEY_UP).x - tex(iChannel1, KEY_DOWN).x\n    );\n}\n\nvec4 getValue(int a) {\n    vec2 q = vec2(float(a) + 0.5, 0.0) / iResolution.x;\n    return tex(iChannel0, q);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if (fragCoord.y > 1.) discard;\n    \n    int a = int(fragCoord.x);\n    float q = fragCoord.x / iResolution.x;\n    vec4 value = tex(iChannel0, vec2(q, 0.));\n    \n    //set initial values\n    if (iFrame == 0) {\n        if (a == VALUE_ROTATION) {\n            value = INIT_ROT;\n        } else if (a == VALUE_MOUSE) {\n            value = INIT_ROT;\n        } else if (a == VALUE_VELOCITY) {\n            value = INIT_VEL;\n        } else if (a == VALUE_POSITION) {\n            value = INIT_POS;\n        }    \n    } else if (a == VALUE_ROTATION && iMouse.z > 0.) {\n        vec4 mouse = 2.0 * abs(iMouse) / iResolution.y;\n        vec4 rot = getValue(VALUE_MOUSE);\n      \tvalue.y = mouse.x - mouse.z + rot.y;\n      \tvalue.x = clamp(mouse.y - mouse.w + rot.x, -pi_5, pi_5);\n        \n    } else if (a == VALUE_MOUSE && iMouse.z < 0.) {\n        value = getValue(VALUE_ROTATION);\n        \n    } else if (a == VALUE_VELOCITY) {\n        float rot = getValue(VALUE_ROTATION).y;\n        vec3 acc = vRotateY(getAcceleration(), rot);\n        value.xyz += acc * MAX_ACCELERATION * iTimeDelta;\n        float speed = length(value.xyz);\n        //limit speed\n        if (speed > MAX_VELOCITY) {\n            value.xyz *= MAX_VELOCITY / speed;\n        } else if (speed > FRICTION * iTimeDelta) {\n            value.xyz *= (speed - FRICTION * iTimeDelta) / speed;\n        } else {\n            value.xyz = vec3(0.0, 0.0, 0.0);\n        }\n    } else if (a == VALUE_POSITION) {\n        vec3 velocity = getValue(VALUE_VELOCITY).xyz;\n        value.xyz += velocity * iTimeDelta;\n        //collision detection?\n        //value.y = max(value.y, -.999);\n    }\n    \n    fragColor = vec4(value);\n    return;\n}","name":"Buffer D","description":"","type":"buffer"}]}