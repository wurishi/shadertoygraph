{"ver":"0.1","info":{"id":"fsj3zW","date":"1617048218","viewed":181,"name":"detached stimuli","username":"tripzilch","description":"you know what, this sketch needs more sine waves.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["plasma"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// (c) Piter Pasma\n\n#define TAU 6.283185307179586 // 2 * PI\nconst vec3 gamma = vec3(2.2);\nconst vec3 igamma = 1.0 / gamma;\n\n// sequence 1/Î¦(12) from\n// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\nconst vec4 H0 = vec4(0.5138670813222691, 0.5431834938989584, 0.5741724246765705, 0.6069292917805363);\nconst vec4 H1 = vec4(0.6415549569952288, 0.678156036327837, 0.7168452282900885, 0.7577416609086309);\nconst vec4 H2 = vec4(0.8009712585325574, 0.846667129567511, 0.8949699763302439, 0.9460285282856136);\n\n// these numbers are random (except one digit--can you spot it?)\nconst vec4 R = vec4(0.632006, 0.128123, 0.223201, 0.988116);\n\nfloat wobbly(vec2 uv, float t, float seed) {\n  // wobbles vec2 to float using sine waves. the parameters for the\n  // sine waves are initialised randomly from the quasirandom sequence\n  // based on seed.\n  vec4 f = (fract(H0 * seed + R) - .5) * 2.4; f += .4 * sign(f);\n  vec4 g = (fract(H1 * seed + R) - .5) * 0.2; g += .1 * sign(g);\n  vec4 p = (fract(H2 * seed + R) - .5) * 2.0;\n  const float ma = 0.3; // modulation amount \n\n  vec2 a = sin((f.xy * uv + g.xy * t + p.xy) * TAU);\n  vec2 b = sin((f.zw * uv + g.zw * t + p.zw + ma * a.yx) * TAU);\n\n  return 0.5 * (b.x + b.y);\n}\n\nvec2 wobbly2(vec2 uv, float t, vec2 seed) {\n  // wobbles vec2 to vec2, using the other wobbly function. also vec2 for seed, now.\n  return (vec2(wobbly(uv, t, seed.x), wobbly(uv, t, seed.y))\n        + vec2(wobbly(uv * .5, t, seed.y + 2323.), wobbly(uv * .5, t, seed.x + 1123.))) * .5  ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  // gently show the pixels to their seating arrangement\n  vec2 iRes1 = 1. / iResolution.xy; \n  vec2 aspect = iResolution.xy * iRes1.y;\n  vec2 uv = (fragCoord.xy * iRes1 - 0.5) * aspect;\n\n  // scale adjustment, makes everything bigger or smaller\n  uv *= 1.2;\n  \n  // speed adjustment\n  float t = iTime * 0.1;\n\n  const float seedA = 1.0; // these three seeds can be any number. tested\n  const float seedB = 2.0; // with integers. but I think any value would\n  const float seedC = 3.0; // work.\n  const vec2 seedAB = vec2(seedA, seedB);\n  \n  // Because wobbly2 makes a vec2->vec2 field, we can take a small step in\n  // direction of that field, then get the new value, make another small step, etc.\n  // Modulating the step_size value in a circular wave from out to in \n  // creates the textural shifts.\n  float step_size = .025 * (.1 + .9 * smoothstep(-.4, .4, sin(4. * length(uv) + t * 1.9)));\n  \n  // We scale the step size slightly differently for the r, g and b channels. \n  // when step_size is small this difference becomes less, which is why those \n  // regions appear more grey / desaturated.\n  float r0 = step_size * 5., g0 = step_size * 6., b0 = step_size * 7.;\n\n  // and then we step on the field, a few times, for the r, g and b channels.\n  vec2 uvr = uv, uvg = uv, uvb = uv;\n  uvr += r0 * wobbly2(uvr, t, seedAB); uvr += r0 * wobbly2(uvr, t, seedAB);\n  uvr += r0 * wobbly2(uvr, t, seedAB); uvr += r0 * wobbly2(uvr, t, seedAB);\n  uvr += r0 * wobbly2(uvr, t, seedAB);\n  uvg += g0 * wobbly2(uvg, t, seedAB); uvg += g0 * wobbly2(uvg, t, seedAB);\n  uvg += g0 * wobbly2(uvg, t, seedAB); uvg += g0 * wobbly2(uvg, t, seedAB);\n  uvg += g0 * wobbly2(uvg, t, seedAB);\n  uvb += b0 * wobbly2(uvb, t, seedAB); uvb += b0 * wobbly2(uvb, t, seedAB);\n  uvb += b0 * wobbly2(uvb, t, seedAB); uvb += b0 * wobbly2(uvb, t, seedAB);\n  uvb += b0 * wobbly2(uvb, t, seedAB);\n\n  // I figured stripes would look cool. Stripes are based on the average dist\n  // moved over the 3 channels (I don't know, seemed like a good idea)\n  float strip = distance(uv, (uvr + uvg + uvb) / 3.);\n  strip = smoothstep(.22, .28, abs(fract(strip * 8.0) - 0.5));\n  \n  // Because we got 3 uv coordinates now, we need to feed those through the \n  // wobbly function one more time, in order to convert them to a float, one\n  // for each color channel.\n  vec3 col = vec3(\n    .5 + .5 * wobbly(uvr, t, seedC),\n    .5 + .5 * wobbly(uvg, t, seedC),\n    .5 + .5 * wobbly(uvb, t, seedC)\n  ) * strip; // apply stripes \n\n  // Intensify colors: Subtract the average value of the three channels, from\n  // each channel separately. Amplify contrast, then add back the average.\n  // Finally saturate values into a smoothstep.\n  const float intensity = 2.0;\n  float c_avg = (col.x + col.y + col.z) / 3.0;\n  col = smoothstep(0.0, 1.0, (col - c_avg) * intensity + c_avg);\n\n  // Output to screen\n  fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}