{"ver":"0.1","info":{"id":"wdcBWS","date":"1605861504","viewed":346,"name":"Stable random normalized float3","username":"Suslik","description":"This generates a random normalized (0.0f..1.0f) float3 from arbitrary float3 seed without using trigonometry or frac's or int->float conversions. Seems very stable for any range of inputs.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["hash","rand","stable"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// adapted from https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl by Spatial\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat constructFloat( uint uval )\n{\n    const uint ieee_mantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    //const uint ieee_mantissa = (~0u << 9u) >> 9u; // binary32 mantissa bitmask (23 lower bits)\n    const uint ieee_one      = 0x3F800000u; // 1.0 in IEEE binary32\n    //const uint ieee_one    = floatBitsToUint(1.0f); // should be exactly the same\n\n    uval &= ieee_mantissa;                     // Keep only mantissa bits (fractional part)\n    //uval >>= 9; \t\t\t\t\t\t\t   // Alternatively, instead of &= mantissa, we can discard first 9 bits to construct mantissa. \n    uval |= ieee_one;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( uval );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\nvec3 constructFloat3(uvec3 val)\n{\n    return vec3(constructFloat(val.x), constructFloat(val.y), constructFloat(val.z));\n}\n\n//adapted from https://stackoverflow.com/questions/664014/what-integer-hash-function-are-good-that-accepts-an-integer-hash-key/12996028#12996028\n//quality of this hash seems to improve with more permutations\nuvec3 hash33Uint( uvec3 val )\n{\n\tval = ((val >> 16u) ^ val.yzx) * 0x45d9f3bu;\n\tval = ((val >> 16u) ^ val.yzx) * 0x45d9f3bu;\n\tval = ((val >> 16u) ^ val.yzx) * 0x45d9f3bu;\n\t//val = ((val >> 16u) ^ val.yzx) * 0x45d9f3bu;\n    return val;\n}\n\nvec3 hash33Sin( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(p)*43758.5453123);\n}\n\n//http://www.jcgt.org/published/0009/03/02/paper.pdf\nuvec3 hash33UintPcg(uvec3 v)\n{\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n    //v += v.yzx * v.zxy; //swizzled notation is not exactly the same because components depend on each other, but works too\n\n    v ^= v >> 16u;\n    v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n    //v += v.yzx * v.zxy;\n    return v;\n}\n\n\nvec3 hash33(vec3 seed)\n{\n    uvec3 seed_uvec3 = uvec3(floatBitsToUint(seed.x), floatBitsToUint(seed.y), floatBitsToUint(seed.z));\n    uvec3 hash_uvec3 = seed_uvec3;\n    //for(int i = 0; i < 400; i++) //for hash perf testing\n        hash_uvec3 = hash33UintPcg(hash_uvec3);\n    //return constructFloat3(hash_uvec3); //constructing float from bits instead of converting it seems to be slightly slower\n    return vec3(hash_uvec3) * (1.0f / float(~0u));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pixel_hash = vec3(fragCoord.xy * 10.0, 0.0f);\n    for(int i = 0; i < 400; i++) //for hash + conversion perf testing\n        pixel_hash = hash33(pixel_hash);\n    \n    //pixel_hash = hash33(vec3(fragCoord.xy * 1e-6f, 0.0f)); //works for both very narrow\n    //pixel_hash = hash33(vec3(fragCoord.xy * 1e6f, 1.0f)); //and wide ranges as well\n    //fragColor = (pixel_hash.x < 0.5f) ? vec4(1.0f) : vec4(0.0f); //check bias in distribution\n    //fragColor = (pixel_hash.x < 0.0f || pixel_hash.x > 1.0f) ? vec4(1.0f, 0.0f, 0.0f, 1.0f) : vec4(0.0f, 1.0f, 0.0f, 1.0f); //check range\n    fragColor = vec4(pixel_hash,1.0);\n}","name":"Image","description":"","type":"image"}]}