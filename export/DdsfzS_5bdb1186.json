{"ver":"0.1","info":{"id":"DdsfzS","date":"1688892122","viewed":60,"name":"3D Sphere + Polygons","username":"HashSlasher666","description":"sssss","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sss"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float R=50.;\nconst int n = 4; // число фигур\nconst int m = 11; // число вершин\nfloat zAr[n] = float[n](0.,20.,40.,0.); // z-координаты плоских фигур\nint inds[n] = int[n](0, 4, 7,11); // массив индексов\nvec2 polygons[m] = vec2[m](vec2(124,110),vec2(155,160),vec2(300,150),vec2(320,70),vec2(350,350),vec2(210,100),vec2(100,220),vec2(250,100),vec2(200,200),vec2(300,250),vec2(600,100)); // массив координат вершин (крайних точек) полигонов\nvec2 centre[1]=vec2[1](vec2(300,200));\nvec3 colAr[n+1] = vec3[n+1](vec3(.5, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0), vec3(1.0, 0.0, 1.0),vec3(0.3, 0.1, 0.6));\nbool InPolygon(in int num, in vec2 coord)\n{\n    int point;\n    if(num==n)\n    {\n        if((coord.x - centre[0].x)*(coord.x - centre[0].x) + (coord.y - centre[0].y)*(coord.y - centre[0].y) < R*R) \n        return true;\n        else return false;\n    }\n    else\n    {\n        point=inds[num];\n        vec2 first=polygons[inds[num-1]];\n        vec2 b=polygons[inds[num-1]+1];\n        vec2 c=polygons[inds[num-1]+2];\n        int i=0;\n        while(inds[num-1]+2+i<point)\n        {\n            if(sign((first.x-coord.x)*(c.y-first.y)-(c.x-first.x)*(first.y-coord.y))==\n            sign((c.x-coord.x)*(b.y-c.y)-(b.x-c.x)*(c.y-coord.y)) && \n            sign((first.x-coord.x)*(c.y-first.y)-(c.x-first.x)*(first.y-coord.y))==\n            sign((b.x-coord.x)*(first.y-b.y)-(first.x-b.x)*(b.y-coord.y)))\n            return true;\n            i++;\n            b=polygons[inds[num-1]+1+i];\n            c=polygons[inds[num-1]+2+i];\n        }  \n    }\n    return false;\n}\nvoid initPolygons(out vec2 polygons[m], in float time)\n{\n    float special=1.8;\n    int point;\n    int i,j;\n    float sgn;\n    for(i=0;i<n;i++)\n    {\n        if(i%2==0) sgn=-1.0;\n        else sgn=1.0;\n        if(i==n-1) point=m;\n        else point=inds[i+1];\n        for(j=inds[i];j<point;j++)\n        {\n            polygons[j].x+=cos(time)*50.0*sgn;\n            polygons[j].y-=cos(time)*50.0*sgn*special;\n        }\n        special=1.0;\n    }\n    return;\n}\n\nfloat getZ(in vec2 p,in int k, in float time)\n{\n    if(k==n)\n    return sqrt(R*R - (p.x - centre[0].x)*(p.x - centre[0].x) - (p.y - centre[0].y)*(p.y - centre[0].y))+ 30.0*(sin(time/2.0));\n    else return zAr[k-1];\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    int i=0;\n    float z=-100.0;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col;\n    float dis;\n    initPolygons(polygons,iTime);\n    centre[0].x += 100.*sin(iTime);\n    i = 1;\n\n    while(i <= n)\n    {\n        if(InPolygon(i,fragCoord))\n        {\n            dis = getZ(fragCoord, i, iTime);\n        }\n        if(dis > z)\n        {\n            col = colAr[i-1];\n            z = dis;\n            if(i==1)\n            {\n                col.b += abs((polygons[3].x-fragCoord.x))*0.01;\n                col.r -= abs((polygons[3].x-fragCoord.x))*0.001;\n            }\n            if(i==2)\n            {\n                col.r += abs((polygons[6].x-fragCoord.x))*0.006;\n                col.g -= abs((polygons[6].x-fragCoord.x))*0.001;\n            }\n            if(i==3)\n            {\n                if(int(fragCoord.x+cos(iTime)*50.0)%20<10)\n                col=vec3(0.4,0.2,1.);\n                else col=vec3(0.4,0.5,0.25);\n            }\n            if(!InPolygon(i,fragCoord))\n            {\n                col = vec3(0.,0.,0.);\n            }\n        }\n        i++;\n    }\n    \n    fragColor = vec4(col,1.0);\n    return;\n}","name":"Image","description":"","type":"image"}]}