{"ver":"0.1","info":{"id":"lXfBWX","date":"1728975249","viewed":119,"name":"domain warp ball","username":"ruochen","description":"a ball with domain warp texture. ","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// a ball with domain wrap texture\n// https://iquilezles.org/articles/warp/\n\n// set SHOW_NOISE to 1 will display the noise texture\n#define SHOW_NOISE 0\n\nconst mat2 m2 = mat2(  0.80,  0.60,\n                      -0.60,  0.80 );\n\nfloat hash(in vec2 co)\n{\n\treturn fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\nfloat noise(vec2 p)\n{\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\tfloat res = mix(\n\t\tmix(hash(ip),hash(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(hash(ip+vec2(0.0,1.0)),hash(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\nfloat fbm_2d( in vec2 x )\n{   \t\n\tfloat f = 2.0;\n\tfloat a = 1.1;\n\tfloat t = 0.0;\n\tfor( int i=0; i<10; i++ )\n\t{\n\t\tt += a*noise(x);\n\t\t\n\t\ta *= 0.5;\n\n        x = f*m2*x;\n\t}\n\t\n\treturn smoothstep(0.,1.8,t);\n}\n\nfloat pattern(in vec2 p, out vec2 q, out vec2 r)\n{\n    //return fbm_2d(p);\n    q = vec2(fbm_2d(p), fbm_2d(p+vec2(1.5, 4.0)));\n    // return fbm_2d(p + 10.0*q);\n\n    r = vec2(fbm_2d(p+iTime + 4.0*q + vec2(1.7, 3.0)), fbm_2d(p+iTime+5.0*q + vec2(10.5, 7.8)));\n//    r = vec2(fbm_2d(p + 4.0*q + vec2(1.7, 3.0)), fbm_2d(p+5.0*q + vec2(10.5, 7.8)));\n\n    return fbm_2d(p+4.*r);\n}\n\nfloat DistanceFromSphere(vec3 point, vec3 sphere_center, float sphere_radius)\n{\n    return distance(point, sphere_center) - sphere_radius;    \n}\n\nfloat MapWorld(vec3 point)\n{   \n    float map_result = DistanceFromSphere(point, vec3(-.0), 1.0);\n    //float displacement = sin(5.0 * point.x) * cos(5.0 * point.y) * sin(5.0 * point.z - iTime) * 0.05;// * abs(cos(iTime));\n    // return map_result + displacement;\n    return map_result;\n}\n\nvec3 CalculateNormal(vec3 point)\n{\n    vec3 SMALL_STEP = vec3(1e-3, 0.0, 0.0);\n\n    float gradient_x = MapWorld(point + SMALL_STEP) - MapWorld(point - SMALL_STEP);\n    float gradient_y = MapWorld(point + SMALL_STEP.yxy) - MapWorld(point - SMALL_STEP.yxy);\n    float gradient_z = MapWorld(point + SMALL_STEP.yyx) - MapWorld(point - SMALL_STEP.yyx);\n\n\n    return normalize(vec3(gradient_x, gradient_y, gradient_z));\n}\n\nvec3 getDomainWrapColor(vec2 uv)\n{\n    vec2 q, r;\n    float density = pattern(uv*10.0, q, r);\n\n    vec3 color = mix(vec3(0), vec3(0.451, 1.0, 0.0), density);\n    // color = mix(color, vec3(1.0, 0.4353, 0.4353), q.y);\n    // color = mix(color, vec3(0.1098, 0.3922, 1.0), q.x);\n    color = mix(color, vec3(1.0, 1.0, 1.0), r.y);\n    return color;\n}\n\nvec3 light_position = vec3(20.0, -50.0, 50.0);\nvec3 RayMarch(vec3 ro, vec3 rd)\n{\n    float total_distance_traveled = 0.0;\n    const int STEPS = 32;\n    const float MINIMUM_HIT_DISTANCE = 1e-3;\n    const float MAXIMUM_TRACE_DISTANCE = 1e3;\n\n    for(int i = 0; i <STEPS; ++i)\n    {\n        vec3 current_position = ro + total_distance_traveled*rd;\n        //float distance_to_closest = MapWorld(current_position);\n        float distance_to_closest = MapWorld(current_position);\n        // close enough, hit the object\n        if(distance_to_closest < MINIMUM_HIT_DISTANCE)\n        {\n            vec3 normal = CalculateNormal(current_position);\n            vec2 color_coord = normal.xy + vec2(iTime/10.0, 0.0);\n            \n            vec3 diffuse_color = getDomainWrapColor(color_coord);\n            \n            vec3 direction_to_light = normalize(current_position - light_position);\n            float diffuse_intensity = max(0.0, dot(normal, direction_to_light));\n            vec3 ambient = vec3(0.05);\n            return diffuse_intensity*diffuse_color+ ambient;\n        }\n\n        // traveled long enough and hit nothing, return black color\n        if(total_distance_traveled > MAXIMUM_TRACE_DISTANCE)\n        {\n            break;\n        }\n\n        total_distance_traveled += distance_to_closest;\n    }\n    return vec3(0.2);\n}\n\nvoid GetPixelColor(vec3 ro, vec3 rd, out vec4 pixel_color)\n{    \n    pixel_color = vec4(RayMarch(ro, rd), 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n        \n#if SHOW_NOISE==1\n    fragColor = vec4(getDomainWrapColor(uv), 1.0);\n#else\n    vec3 ro = vec3(0.0, 0.0, -1.5);    \n    vec3 rd = normalize(vec3(uv, 1));\n\n    GetPixelColor(ro, rd, fragColor);\n#endif\n}","name":"Image","description":"","type":"image"}]}