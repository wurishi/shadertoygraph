{"ver":"0.1","info":{"id":"DslXW4","date":"1669039830","viewed":181,"name":"Cosmic Clock 5","username":"ChunderFPV","description":"Mouse X: radial blur\nMouse Y: exponent & zoom\nKey M: toggle mouse or default position\nKey C: toggle clock & digits","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["clock","spiral","buffer","fractions"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// digit display modified from https://www.shadertoy.com/view/stlSzM\n#define bcd(i) (i/10*6+i)\n#define digit(uv,i) texture(iChannel1, (uv)/16.+vec2(float(i)/16., .75)).x\n#define draw_digit(c,uv,i) if(abs(uv).x < .5 && abs(uv).y < .5) c += (1.-c)*digit(uv+.5, i)\n#define draw_bcd(c,uv,i,b) if (b) draw_digit(c, uv,(i&0xf0)>>4); draw_digit(c, uv-vec2(.5,0),(i&0xf))\n\nfloat draw_time(vec2 uv, vec2 xy, float s, float t)\n{\n    uv -= xy; // position\n    uv /= s; // size\n    float c = 0.;\n    int hour = int(mod(t/3600., 12.));\n    if (hour == 0) hour = 12;\n    int minute = int(mod(t/60., 60.));\n    uv.x += .85;\n    draw_bcd(c, uv, bcd(hour), (hour > 9)); // 1st & 3rd digits\n    uv.x -= .85;\n    draw_digit(c, uv, 10); // colon\n    uv.x -= .35;\n    draw_bcd(c, uv, bcd(minute), true); // 2nd & 4th digits\n    return c;\n}\n\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    float key_c = texture(iChannel3, vec2( (float(67)+.5)/256., 1.) ).x; // key c toggle\n    vec3 c = texture(iChannel0, XY/R, max(1., length(SC*2.))).rgb;\n    c *= c*2.5; // contrast\n    \n    vec2 sc = SC*SCALE; // screen coords\n    float a = atan(sc.x, sc.y); // arc\n    float r = length(sc); // radius\n    float ring = min(r, 1./r);\n    \n    vec3 dr = vec3(.6, .5, .7)*pow(ring, 5.)*0.25; // dot ring\n    dr += max(0., cos(a*60.))*pow(ring, 60.)*.5; // 60 pt ring\n    dr += pow(abs(cos(a*6.)), 60.)*pow(ring, 30.)*.75; // 12 pt ring\n    dr *= dr*2.;\n    \n    // moving points around circle\n    float sr = SR; // starting rotation\n    vec3 pts = vec3(0);\n    pts += PT(sc-CS(T.x*-TAU+sr), .045); // hour\n    pts += PT(sc-CS(T.y*-TAU+sr), .037); // min\n    pts += PT(sc-CS(T.z*-TAU+sr), .03); // sec\n    pts *= pts;\n    pts += PT(sc-CS(T.x*-TAU+sr), .15)*vec3(.9, .1, .3); // hour glow\n    pts += PT(sc-CS(T.y*-TAU+sr), .12)*vec3(.0, .5, .2); // min glow\n    pts += PT(sc-CS(T.z*-TAU+sr), .1)*vec3(.1, .3, 1.); // sec glow\n    \n    vec3 d = vec3(draw_time(SC, vec2(.0, .45), .1, iDate.w))*vec3(.5, .5, .8); // digital clock\n    d *= texture(iChannel2, XY/R.y+vec2(T.z, 0.), 3.).rgb*1.5; // digit texture\n    if (key_c < 1.) c += dr+pts+d;\n    \n    RGBA = vec4(c, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define SCALE 3.\n#define R iResolution.xy\n#define M iMouse\n#define T mod(iDate.w/vec3(43200., 3600., 60.), 1.)\n#define SC ((XY-.5*R)/R.y)\n#define CS(a) vec2(cos(a), cos(a-TAU/4.))\n#define TAU 6.2831853071795865\n#define SR (TAU/4.)\n#define DS(n,a,pr) max(0., 1.-length(sc-CS(a-n*TAU*rr)*l)/(pr))\n#define FS(n,a,pr) max(0., 1.-length(sc-CS(a-(TAU*sqrt(abs(n))*sign(n))*sqrt(rr*2.))*l)/(pr))\n#define R2N(m) (abs(m) > 1.) ? 1./(2.*sign(m)-m): m\n#define PT(xy,r) max(0., 1.-length(vec2(xy)/(r)))\n#define CL(x,a,b) smoothstep(0.,1.,(2./3.)*(x-a)/(b-a)+(1./6.))*(b-a)+a // https://www.shadertoy.com/view/Ws3Xzr\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 RGBA, in vec2 XY )\n{\n    float t = mod(iDate.w/3600., 12.); // value from 12 hour cycle\n    if (t < 1.) t += 12.; // change 0 to 12\n    float e = .3;  // exponent\n    vec2 m = (M.xy/R*4.)-2.; // mouse\n    float key_m = texelFetch(iChannel2, ivec2(77, 2), 0).x; // key m toggle\n    if (M.z > 0. || key_m > 0.) e = R2N(-m.y); // exponent from mouse y\n    float z = (e < 0.) ? pow(100., e): pow(500., e); // zoom based on exponent\n    z *= SCALE;\n    z = clamp(z, CL(z, 1e-16, 1e-15), CL(z, 1e+18, 1e+19)); // soft clamp at precision loss\n    vec2 sc = SC*z;\n    \n    vec2 tc = SC*SCALE; // texture coords\n    float tl = length(tc); // non-zoomed screen radius\n    float ring = pow(min(tl, 1./tl), 2.);\n    \n    float tr = sqrt(dot(tc, tc)); // transform\n    vec3 tex = texture(iChannel1, tc/tr+T.z, .5).rgb*tr;\n    \n    float bs = -.004; // radial blur strength\n    if (M.z > 0. || key_m > 0.) bs = -.005*m.x;\n    float maa = (e < 0.) ? pow(z/tl/SCALE, .25): .5; // mipmap aa\n    vec3 c = texture(iChannel0, mix(XY/R, vec2(.5), bs), .5).rgb*.96; // blend with previous frames\n    c += vec3(.1, .4, .7)*tex*.012; // background color\n    if (e < 0.) c += pow(z/tl*min(.5, abs(e)*25.), 1.25)*vec3(.1, .2, .3)*.005; // blue dot\n    c += vec3(.1, .2, .3)*ring*.03; // blue ring\n    \n    vec3 hour_c = vec3(.9, .1, .3)*ring*.5;\n    vec3 min_c = vec3(.0, .5, .2)*ring*.5;\n    vec3 sec_c = vec3(.3, .1, 1.)*ring*.5;\n    vec3 fc = vec3(1., .6, .3*tl)*pow(tl, clamp(-1./e, 0., .75))*.4;  // fs color\n    \n    float r = length(sc); // screen radius\n    float sr = SR; // starting rotation\n    float px = length(fwidth(sc))/1.414; // pixel radius\n    float pr = max(px*3., .005*z); // point radius\n    float cr = pow(z/SCALE, 1./e)*TAU; // counter rotation\n    float fscr = sqrt(abs(t)*cr*2.*TAU); // counter rotation\n    \n    float lim = 5.; // loop limit\n    for (float i=0.; i<lim; i++) // overlap cells for spirals\n    {\n        float rr = round((exp(log(r)/e)-i)/lim)*lim+i; // rounded radius\n        float l = pow(rr, e); // radius\n        c += DS(T.x, T.x*cr+sr, pr*.5)*hour_c; // hour\n        c += DS(T.y, T.y*cr+sr, pr*.5)*min_c; // min\n        c += DS(T.z, T.z*cr+sr, pr*.5)*sec_c; // sec\n        c += FS(t, fscr+sr, pr)*fc; // fraction spiral\n    }\n    vec2 b = abs(fract(XY/R+.5)-.5)/fwidth(XY/R)/5.; // black border\n    c = min(c, min(b.x, b.y)*.75); // blend with border\n    \n    RGBA = vec4(c, 1.);\n}","name":"Buffer A","description":"","type":"buffer"}]}