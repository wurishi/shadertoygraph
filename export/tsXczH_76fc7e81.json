{"ver":"0.1","info":{"id":"tsXczH","date":"1584228648","viewed":110,"name":"Sphere Lighting","username":"sevanetrebchenko","description":"A take on diffuse/specular lighting of a sphere from a variably positioned light source.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["reflection","lighting","sphere","specular","diffuse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float MapValueToRange(float val, float inmin, float inmax, float outmin, float outmax) {\n    return (val - inmin) * (outmax - outmin) / (inmax - inmin) + outmin;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float PI = 3.14159f;\n    float diameter = 1.f;\t\t\t\t\t// radius of the sphere\n    float reflectionStrength = 0.2f;\t\t// brightness of the reflection\n    float clampStrength = 0.15f;\t\t\t// dampening factor of the reflection\n    float lightStrength = 1.f;\t\t\t\t// power of the light source\n    vec3 lightTint = vec3(1.f, 1.f, 1.f);\t// tint of the sphere\n    vec3 finalColor;\t\t \n    \n    // get UV coordinates in a range from [0 to 1]\n    vec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n    // center (0, 0) UV values at center of the screen\n    // uv coordinates now go from [-0.5, 0.5]\n    uv -= 0.5;\n    // normalize UV coordinates to display resolution\n    uv /= vec2(iResolution.y / iResolution.x * (diameter / 2.f), (diameter / 2.f));\n    \n\t\t\n    // normalized mouse coordinates\n    //vec2 mouse = vec2(MapValueToRange(iMouse.x, .0f, iResolution.x, -1.f, 1.f), \n    //\t\t\t\t\tMapValueToRange(iMouse.y, .0f, iResolution.y, -1.f, 1.f));\n    // light direction with mouse input\n    // vec3 lightDirection = normalize(vec3(mouse.x, mouse.y, 1.f));\n\n    // light direction with waves\n    vec3 lightDirection = normalize(vec3(sin(iTime), cos(iTime), 1.f));\n\n    // center of the screen has normal that is (x, y, 1) so that\n    // it points directly towards the eye of the camera (part 2)\n    vec3 normal = vec3(uv, sqrt(1.0f - (uv.x * uv.x) - (uv.y * uv.y)));\n\n    // reflection on the non-illuminated side -> flip light direction and compare\n    if (dot(normal, lightDirection) > dot(normal, -lightDirection))\n        finalColor = vec3(dot(normal, lightDirection));\n    else \n        // clamp the reflected color so it's not as bright near the edges\n        finalColor = clamp(vec3(dot(normal, -lightDirection * reflectionStrength)), 0.f, clampStrength);\n\n    // Output to screen\n    fragColor = vec4(finalColor * (lightTint * lightStrength), 1.f);\n}","name":"Image","description":"","type":"image"}]}