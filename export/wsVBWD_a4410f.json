{"ver":"0.1","info":{"id":"wsVBWD","date":"1607196767","viewed":111,"name":"Stream_2020_12_05","username":"dreamur","description":"References for the class:\n\nhttps://thebookofshaders.com/07/\nhttps://www.colorhexa.com/8b4513\nhttps://www.desmos.com/calculator","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","waves","water","sailboat"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n#define TWO_PI 6.28318530718\n\nfloat sdCircle(in vec2 _st, in float _radius)\n{\n    return length(_st) - _radius;\n}\n\n\nfloat boxDist(vec2 p, vec2 size, float radius)\n{\n  \tvec2 d = abs(p) - size - radius;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\n// taken from Chapter 7 of \"The Book of Shaders\"\n//  https://thebookofshaders.com/07/\nfloat makeAPolygon(in float _numberOfSides, in vec2 _st)\n{\n    float a = atan(_st.x,_st.y);\n    float r = TWO_PI/float(_numberOfSides);   \n\treturn cos(floor(.5+a/r) * r - a) * length(_st);\n}\n\nfloat rect(vec2 coordSpace, vec2 dim)\n{          \n    vec2 tmp = smoothstep( dim, dim, coordSpace );\n    float pct = tmp.x * tmp.y;\n    \n    tmp = smoothstep( dim, dim, 1. - coordSpace );\n    pct *= tmp.x * tmp.y;\n\n    return pct;\n}\n\n// concept from \"Rainbow Showoff\"\n// by akufishi\n// https://www.shadertoy.com/view/lscBRf\nfloat rainDrop( vec2 coordSpace, float scalar, float timeOffset, float modVal)\n{      \n    float tempTime = iTime * 10.;\n    float initPos = fract( sin(coordSpace.x) * scalar ) / iTime + timeOffset;\n    return rect( vec2(mod(coordSpace.y + tempTime * initPos, modVal)) , vec2(0.485, .44) );\n}\n\nvec2 rotateOnZ(in vec2 _st, in float _angle)\n{\n    return mat2( cos(_angle * PI), -sin(_angle * PI),\n                 sin(_angle * PI),  cos(_angle * PI) ) * _st;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.0, 0.749, 1.0);\n    \n    col = mix(vec3(0.173, 0.149, 0.337), col, uv.y);    \n    float scalar = 20.0;\n    \n    for(float i = 3.0; i < 7.0; i++)\n    {\n        vec2 st = uv * scalar;\n        st -= scalar / i;\n        st += vec2(0.0, 2.0);\n        st += vec2(iTime * i, sin(iTime) / i / 2.0);  \n        \n        //sin(x)+ (0.3 * cos(0.5 * x))\n        float yVal = abs(sin(st.x)+ (0.3 * cos(i * iTime))) * -1.0;\n        float invertedI = 9.0 - i;\n        \n        // boat stuff\n        // credit to @neondactyl\n        if(i == 5.0)\n        {      \n            vec2 xy = uv - 0.5;\n            xy *= vec2(scalar / 5.0);          \n            xy += vec2(0.0, 1.25 + sin(iTime * 10.0) / 10.0);           \n            \n            float rotationVal = (abs(sin(iTime * 3.2)) - 0.5) / 10.0;\n            xy = rotateOnZ(xy, rotationVal);\n            \n            \n            float flagPoleDF = step(boxDist(xy * vec2(4.0, 1.0) - vec2(0.5, 0.0), vec2(0.00015, 1.5), 0.0), 0.15);\n            col = mix( col, vec3(0.33), flagPoleDF );\n            \n            vec2 sailScale = vec2(2.5+(0.6*cos(xy.y-iTime)/0.90), -1.0);                      \n            vec2 sailOffset = vec2(-0.35, 0.85);\n            \n            float tmpScale = mod(abs(iTime*5.0+1.5), 1.0) * sqrt(25.0-xy.y*xy.y)-1.8;\n            \n            //mod(iTime, 1.5) + 3.5\n            \n            sailScale = vec2(2.5+(0.6*cos(-xy.y-tmpScale /*xxx*/)/0.90), -1.0);\n            \n            vec2 wz = xy * sailScale + sailOffset;\n            \n            float sailDF = smoothstep(makeAPolygon(4.0, wz)-0.015, makeAPolygon(4.0, wz)+0.015,0.65);\n            col = mix( col, vec3(1.0), sailDF);\n \n            \n            if(xy.y < 0.05)\n            {          \n                float boatDF = smoothstep(sdCircle(xy*0.98, 0.5) + 0.015, sdCircle(xy*0.98, 0.5) - 0.015, 0.5);    \n            \tcol = mix(vec3(0.369, 0.184, 0.051), col, boatDF);                 \n            }  \n            \n            if(xy.y < 0.0)\n            {          \n                float boatDF = smoothstep(sdCircle(xy, 0.5) + 0.015, sdCircle(xy, 0.5) - 0.015, 0.5);    \n            \tcol = mix(vec3(0.545, 0.271, 0.075), col, boatDF);                 \n            }                         \n        }\n        \n        // water\n        if(st.y - 0.25 < yVal )\n        {\n            col = vec3(0.282 / (invertedI / 2.0), 0.239 / (invertedI / 2.0), 0.545 / (invertedI / 2.0));\n        }   \n        if(st.y < yVal )\n        {\n            col = vec3(0.0, 0.0, 0.545 / (invertedI / 2.0));\n        }\n        \n    }\n    \n    for(float i = 6.0; i > 2.0; i--)\n    {\n        vec2 st = uv * scalar * 1.75;\n        st -= scalar / i;\n                \n        float invertedI = (8.0 - i);        \n        st -= vec2(-iTime * (invertedI / 2.0), 28.0);\n        \n        \n        float yVal = 0.0;      \n        yVal = sin(pow(sin(st.x), 3.0) - pow(cos(st.y), 1.0) + abs(cos(iTime + i) ) );\n     \n        // clouds + borders\n        if(st.y + 0.25 > yVal)\n        {\n            col = vec3(1.0 / (i * i  / 1.5));\n        }       \n        if(st.y > yVal )\n        {\n            col = vec3(1.0 / i);\n        }   \n        \n        // rain\n        float rainDF = rainDrop(uv + vec2(0.2, 0.0), 5000.0, 0.2, 5.5 );\n    \tcol = mix(col, vec3(0.851, 0.851, 1.0), rainDF );          \n        \n    }\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}