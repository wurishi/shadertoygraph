{"ver":"0.1","info":{"id":"Xd2fDW","date":"1500901441","viewed":327,"name":"pt-5","username":"wuerzig","description":"pathtracing experiment with refraction and fresnel reflection. yo.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","reflection","refraction","glass","pathtracing","pathtracer","fresnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy);\n    vec3 col = texture(iChannel0, uv).xyz;\n\n   \tcol /= float(iFrame);\n\n    \n\tcol = pow( col, vec3(0.8,0.85,0.9) );\n    \n    col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define EPSILON 0.0005\n#define BOUNCES 15\n#define BOUNCES_F 15.0\n\nvec3 sunDir = vec3(10.0, 10.0, -10.0);\nvec3 sunColor = vec3(1.0, 1.0, 1.0);\nvec3 skyColor = vec3(0.0, 0.0, 0.0);\n\n// stolen from https://thebookofshaders.com/12/?lan=de\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\n\nfloat time;\n\nvec2 random2f(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nfloat sdDisplace(vec3 p) {\n    return 0.3*sin(20.0*p.x)+0.3*sin(10.0*p.y)+0.3*sin(10.0+p.z);\n}\n\nfloat sdPlaneZ(vec3 p) {\n\treturn abs(p.z);\n}\n\nfloat sdPlaneY(vec3 p) {\n\treturn abs(p.y);\n}\n\nfloat sdPlaneX(vec3 p) {\n\treturn abs(p.x);\n}\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdWobblySphere(vec3 p, float s) {\n    return sdSphere(p,s)+sdDisplace(p)*0.1;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y,d.z)), 0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n#define MAT_NOTHING -1\n#define MAT_CHECKER 0\n#define MAT_DIFF 1\n#define MAT_SPEC 2\n#define MAT_GLASS 3\n\nstruct Material {\n\tvec3 col;\n    vec3 emm;\n    int type;\t\t\t// 0..CHECKERBOARD 1..DIFF 2..SPEC\n};\n\nstruct dfObject {\n    float d; // distance\n    Material mat; // material\n};\n    \nstruct marchRes {\n\tvec3 p;\n    Material mat;\n};\n        \n\ndfObject dfUnion(dfObject d1, dfObject d2) {\n    if (d1.d < d2.d) {\n        return d1;\n    } else {\n        return d2;\n    }\n}\n\n// stolen from https://www.shadertoy.com/view/lsX3DH\nvec2 rv2;\nvec2 rv4;\nvec2 rv6;\nvec3 cosWeightedRandomHemisphereDirection2(const vec3 n) {\n\t\n    vec3  uu = normalize(cross(n, vec3(0.0,1.0,1.0)));\n\tvec3  vv = cross(uu, n);\t\n    \n\tfloat ra = sqrt(rv2.y);\n\tfloat rx = ra*cos(6.2831 * rv2.x); \n\tfloat ry = ra*sin(6.2831 * rv2.x);\n\tfloat rz = sqrt(1.0 - rv2.y);\n\tvec3  rr = vec3(rx*uu + ry*vv + rz*n);\n\n    return normalize(rr);\n}\n\nvec3 randomDirection() {\n\tvec3 res = vec3(-0.5 + rv2.x, -0.5 + rv2.y, -0.5 + rv4.x);\n    \n    res = normalize(res);\n    return res;\n}\n\n\ndfObject map(in vec3 p) {\n    \n    dfObject res;\n    \n    // bottom\n    res = dfObject(\n                    sdPlaneY(p), \n                    Material(vec3(0.), vec3(0.), MAT_CHECKER)\n                );\n    \n    // yellow sphere\n    res = dfUnion(res,\n                  \tdfObject(\n                        sdSphere(p-vec3(0.3, 0.3, 1.1), 0.3),\n                        Material(vec3(0.9, 0.7, 0.3), vec3(0.), MAT_DIFF)\n                    )\n                  );\n    // shiny sphere\n    res = dfUnion(res,\n                  \tdfObject(\n                        sdSphere(p - vec3(1.55, 0.5, 1.0), 0.5),\n                        Material(vec3(1.0), vec3(0.), MAT_SPEC)\n                    )\n                  );\n    \n    // glass sphere\n    res = dfUnion(res,\n                  \tdfObject(\n                        sdSphere(p - vec3(-0.3, 0.5, 0.5), 0.35),\n                        Material(vec3(1.0, 1.0, 1.0), vec3(0.), MAT_GLASS)\n                    )\n                  );\n    \n    // cube\n    res = dfUnion(res,\n                  \tdfObject(\n                        sdBox(p - vec3(-1.5, 0.6, 1.5), vec3(0.4)),\n                        Material(vec3(0.7), vec3(0.), MAT_DIFF)\n                    )\n                  );\n    \n    // light sphere\n    res = dfUnion(res,\n                  \tdfObject(\n                        sdSphere(p - vec3(-0.3, 2.5, 0.5), 1.0),\n                        Material(vec3(1.0, 1.0, 1.0), vec3(20.), MAT_DIFF)\n                    )\n                  );\n    \n    \n        \n    // right wall\n    res = dfUnion(res,\n                  \tdfObject(\n                        sdPlaneX(p - vec3(-3., 0., 0.)),\n                        Material(vec3(1.0, 0.0, 0.0), vec3(0.), MAT_DIFF)\n                    )\n                  );\n    // left wall\n    res = dfUnion(res,\n                  \tdfObject(\n                        sdPlaneX(p - vec3(3., 0., 0.)),\n                        Material(vec3(0.0, 0.0, 1.0), vec3(0.), MAT_DIFF)\n                    )\n                  );\n    \n    // top wall\n    res = dfUnion(res,\n                  \tdfObject(\n                        sdPlaneY(p - vec3(0.0, 3.0, 0.0)),\n                        Material(vec3(0.5), vec3(0.), MAT_DIFF)\n                    )\n                  );\n   \n    \n    // back wall\n\tres = dfUnion(res,\n                  \tdfObject(\n                        sdPlaneZ(p - vec3(0.0, 0.0, 3.0)),\n                        Material(vec3(1.0), vec3(0.), MAT_DIFF)\n                    )\n                  );\n    \n    // back wall behind cam\n\tres = dfUnion(res,\n                  \tdfObject(\n                        sdPlaneZ(p - vec3(0.0, 0.0, -3.0)),\n                        Material(vec3(0.0), vec3(0.), MAT_DIFF)\n                    )\n                  );\n    //res = dfUnion(res, vec2(sdTorus(p - vec3(-0.3, 1.8, 0), vec2(0.6, 0.1)), 200.9)); // 30.9\n    \n    // back wall\n    \n    return res;\n}\n\n\nmarchRes march(in vec3 rayStart, in vec3 rayDir) {\n    \n    // first step\n    float t = 100.0*EPSILON;//0.05;\n\n    // Far Clipping\n    float tmax= 50.0;\n    \n    Material obj = Material(vec3(0.), vec3(0.), MAT_NOTHING);\n    \n    vec3 p;\n    \n    for (int i = 0; i < 256; i++) {\n        // map on Distance Field\n        p = rayStart + t*rayDir;\n        dfObject res = map(p);\n        \n\n        // If we hit something, exit\n        if (abs(res.d) < EPSILON)\n        \tbreak;\n       \t\n        t += abs(res.d)*1.0;\n        obj = res.mat;\n    }\n    \n    return marchRes(p, obj);\n    \n}\n\n\n// Stolen from https://iquilezles.org\n// Calculate Normal in a Distance Field\nvec3 dfNormal( in vec3 p ) {\n    \n    \n\tvec3 eps = vec3(0.0005, 0.0, 0.0);\n\tvec3 res = vec3(\n\t    map(p+eps.xyy).d - map(p-eps.xyy).d,\n\t    map(p+eps.yxy).d - map(p-eps.yxy).d,\n\t    map(p+eps.yyx).d - map(p-eps.yyx).d);\n\treturn normalize(res);\n\t\n}\n\nmat3 makeCam( in vec3 origin, in vec3 target) {\n\tvec3 worldUp = vec3(0.0, 1.0, 0.0);\n    vec3 lookVec = normalize(target-origin);\n\tvec3 right = normalize(cross(lookVec, worldUp));\n\tvec3 camUp = normalize(cross(right, lookVec));\n    return mat3(right, camUp, lookVec);\n}\n\nvec3 getObjectColor(in Material obj, in vec3 p) {\n\t\n    if( obj.type == MAT_CHECKER ) {\n\t\t// checkboard pattern\n        float f = mod( floor(p.z) + floor(p.x), 2.0);\n        vec3 col = 0.2 + 0.2 * f * vec3(1.0);\n        return col;\n    } \n    return obj.col;\n}\n\n\n// ported from http://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-shading/reflection-refraction-fresnel\nfloat fresnel(in vec3 I, in vec3 N, float eps) \n{ \n    float cosi = clamp( dot(I, N), -1.0, 1.0); \n    \n    float etai = 1.0;\n    float etat = eps; \n    float tmp;\n    if (cosi > 0.0) { tmp = etai; etai = etat; etat = etai; /*swap(etai, etat);*/ } \n    \n    // Compute sini using Snell's law\n    float sint = etai / etat * sqrt(max(0.f, 1.0 - cosi * cosi)); \n    // Total internal reflection\n    if (sint >= 1.0) { \n        return 1.0f;\n    } \n    else { \n        float cost = sqrt(max(0.f, 1.0 - sint * sint)); \n        cosi = abs(cosi); \n        float Rs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost)); \n        float Rp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost)); \n        return  (Rs * Rs + Rp * Rp) / 2.0; \n    } \n    // As a consequence of the conservation of energy, transmittance is given by:\n    // kt = 1 - kr;\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n    // 0...fragCoord...iResolution.xy\n    // Texture Sampler 0...uv...1\n    vec3 rayStart;\n    vec3 rayDirection;\n    vec3 camTarget;\n    vec2 point;\n\n    float j_float;\n    \n    // we start from outside to inside\n    int refrDir = 0; \n    \n    vec3 totalEnergy = vec3(0.);\n    vec3 totalColor = vec3(1.);\n    vec3 col, emm;\n    \n    time = iTime + 5.;\n    float time2 = time;\n    \n//#ifdef SUPERPRETTY\n   \ttime2 = 8.0;\n//#endif    \n    \n    point = (-iResolution.xy + 2.0*fragCoord) / iResolution.y;\n    float seed = time + (point.x + iResolution.x*point.y) * 1.51269341231;\n\n\n\tcamTarget = vec3(0.0, 1.0, 0.0);\n\n    {\n        \n\n        rv2 = random2f(vec2(time + seed));\n        vec2 point2 = point + rv2/(1.5*iResolution.xy);\n        \n    \trayStart = vec3(-0.5 + 2.5*cos(-0.2*time2), 2.1, 0.5 + 2.5*sin(-0.2*time2));\n    \tmat3 cameraMatrix = makeCam(rayStart, camTarget);\n\n        rayDirection = cameraMatrix * normalize(vec3(point2.xy,3.0 /*fov*/));\n\t\t\n        \n        for (int j=0;j<BOUNCES;j++) {\n            \n            \n            j_float = float(j);\n\n            rv2 = random2f( vec2((rv2.x*2.4543263+rv2.y)*(time+1.)+.23 ));\n            \n            marchRes res = march(rayStart, rayDirection);\n            //float t = res.d;\n            Material obj = res.mat;\n            \n            vec3 intersection = res.p;\n            vec3 normal = dfNormal(intersection);\n        \n        \tif (obj.type >= 0) {\n            \t// we hit something, awesome!\n\t\t\t\tcol = getObjectColor(obj, intersection);\n\t\t\t\temm = obj.emm;\n\n                // Bounce Ray\n                if (obj.type == MAT_GLASS) {\n                    \t\n\t                float eps = 1.4;\n                    \n\t                // normal used for refraction calculation\n\t                vec3 refrNormal = normal;\n                    \n\t                // from outside to inside\n\t                if (refrDir == 0)\n\t                        eps = 1.0/eps;\n                        \n                    \n\t                // if from inside to outside, flip distance field normal\n\t                if (refrDir == 1)\n\t                \trefrNormal = -normal;\n\n                    // fake fresnel\n                    float fres = fresnel(rayDirection, refrNormal, 1.0/eps);\n                        \n                    if (rv2.x < fres) {\n                    \trayDirection = reflect(rayDirection, refrNormal);\n\t                \n    \t\t            totalEnergy += totalColor * emm;\n            \t        totalColor *= col;\n\n                        // total reflection\n                    } else {\n                    \n                    \n\t                    // refraction index\n                        \n                    \n    \t                vec3 refractResult = refract(normalize(rayDirection), normalize(refrNormal), eps);\n                    \n        \t            if (length(refractResult) < EPSILON) {\n                            // total inner reflection\n                \t        // we should not hit this branch because\n                            // fresnel already takes care of that\n                            rayDirection=reflect(rayDirection, refrNormal);\n                        \n\t                        totalEnergy += totalColor * emm;\n    \t                    totalColor *= col;\n        \t            } else {\n        \t            \n            \t            // do we go out or in? using a single bit value\n                \t        // but this means some limitations:\n\t    \t                // - camera must be outside refractive materials\n\t\t                    // - no nested refractive materials allowed\n                    \t\n\t                        rayDirection = refractResult;\n\t                        refrDir = 1-refrDir;\n    \t                }\n        \t            \n            \t        rayStart = intersection + EPSILON*rayDirection;\n                    }\n                    \n                    \n                   \n                } else {\n                \n                \n\t                if (obj.type == MAT_SPEC) {\n    \t                rayDirection = reflect(rayDirection, normal);\n\t                \n    \t\t            totalEnergy += totalColor * emm;\n            \t        totalColor *= col;\n                \t} else {\n                    \n                    \n\t                    rayDirection = cosWeightedRandomHemisphereDirection2(normal);\n\n    \t                totalEnergy += totalColor * emm;// + totalColor * col * e;\n        \t            totalColor *= col;\n                    }\n                    \n                    // get off the surface\n\t\t\t\t\trayStart = intersection + EPSILON*rayDirection;\n\n                }\n                \n                // if the material emits light we stop bouncing around\n                if (length(emm)>0.)\n                    break;\n                \n            \t\n            } else {\n                // hit sky\n                totalColor *= skyColor;\n                totalEnergy += skyColor * 100.;\n               \tbreak;\n            }\n\t\t}\n        // if were still inside a refractive material\n        // theres energy loss because we didnt connect to a light source\n        \n    }\n    \n    vec3 pxl = totalEnergy / (j_float + 1.0);\n\n    fragColor = vec4(clamp(pxl, 0.0, 1.0), 1.0);\n    \n   \tcol = texture( iChannel0, fragCoord/iResolution.xy ).xyz;\n   \tif( iFrame==0 ) col = vec3(0.0);\n   \tcol += pxl;    \n   \tfragColor = vec4( col, 1.0 );\n    \n}","name":"Buf A","description":"","type":"buffer"}]}