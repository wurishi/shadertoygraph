{"ver":"0.1","info":{"id":"lXfBW2","date":"1729192435","viewed":41,"name":"Ships on a water","username":"alexkozh","description":"a","likes":1,"published":1,"flags":48,"usePreview":1,"tags":["a"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415925359\n#define TWO_PI 6.2831852\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST .01\nvec3 boxSize = vec3(0.1f, 0.1f, 0.2f);\nvec3 boxPos2 = vec3(1.0f, 0.2f, 0.0f);\nvec3 lightDir = vec3(0.3f, 0.5f, 0.3f);\nvec3 lightPos = vec3(0.0f, 0.5f, 0.5f);\nfloat mastHight = 0.3f;\n\nfloat ShipDistance(vec3 pos);\nfloat Ship2Distance(vec3 pos);\nfloat FloorDistance(vec3 pos);\nfloat ShootDistance(vec3 pos);\n\nvec3 GetBox1Pos()\n{\n    return texelFetch(iChannel1, ivec2(0, 0), 0).xyz;\n}\n\nvec3 GetBox2Pos()\n{\n    return texelFetch(iChannel1, ivec2(1, 0), 0).xyz;\n}\n\nvec3 GetCamDir()\n{\n    return texelFetch(iChannel3, ivec2(1, 0), 0).xyz;\n}\n\nfloat GetFiringStatus()\n{\n    return texelFetch(iChannel1, ivec2(0, 0), 0).a;\n}\n\nvec3 GetShootPos()\n{\n    return texelFetch(iChannel1, ivec2(1, 0), 0).xyz;\n}\n\nmat4x4 GetRotMatX(float angle)\n{\n    return mat4x4(1.0f,  0.0f,       0.0f,       0.0f,\n                  0.0f,  cos(angle), sin(angle), 0.0f,\n                  0.0f, -sin(angle), cos(angle), 0.0f,\n                  0.0f,  0.0f,       0.0,        1.0f);\n}\nmat4x4 GetRotMatZ(float angle)\n{\n    return mat4x4(cos(angle), 0.0f, -sin(angle),  0.0f,\n                  0.0f,       1.0f,  0.0f,        0.0f,\n                  sin(angle), 0.0f,  cos(angle),  0.0f,\n                  0.0f,       0.0f,  0.0,         1.0f);\n}\n\nmat4x4 GetTransMat(vec3 pos)\n{\n    mat4x4 trans = mat4x4( 1.0f,  0.0f,  0.0f,   0.0f,\n                           0.0f,  1.0f,  0.0f,   0.0f,\n                           0.0f,  0.0f,  1.0f,   0.0f,\n                           pos.x, pos.y, pos.z,  1.0f);            \n    return trans;\n}\n\nfloat GetMaterialID(vec3 position) {\n    float minDistance = 100000000.0f;\n    float materialID = 0.0f;\n    \n    // Расстояние до основного танка\n    float distShip1 = ShipDistance(position);\n    if (distShip1 < minDistance) {\n        materialID = 1.0f;\n        minDistance = distShip1;\n    }\n    \n    // Расстояние до красного танка\n    float distShip2 = Ship2Distance(position);\n    if (distShip2 < minDistance) {\n        materialID = 2.0f;\n        minDistance = distShip2;\n    }\n\n    // Расстояние до границ карты\n    float distFloor = FloorDistance(position);\n    if (distFloor < minDistance) {\n        materialID = 3.0f;\n        minDistance = distFloor;\n    }\n    \n    // Расстояние до выстрела\n    if (GetFiringStatus() > 0.5f) {\n        float distShot = ShootDistance(position);\n        if (distShot < minDistance) {\n            minDistance = distShot;\n            materialID = 4.0f;\n        }\n    }\n\n    return materialID;\n}\n\nfloat GetDist(vec3 point)\n{\n    float ship = ShipDistance(point);\n    float ship2 = Ship2Distance(point);\n    float plane = FloorDistance(point);\n    \n    float d;\n    if(GetFiringStatus() > 0.5f)\n    {\n        float shoot = ShootDistance(point);\n        d = min(shoot,min(ship,min(plane, ship2)));\n    }\n    else\n    {\n        d = min(ship,min(plane, ship2));\n    }\n    \n    return d;\n}\n\nvec3 GetNormal(vec3 pos)\n{ \n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*GetDist( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*GetDist( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*GetDist( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*GetDist( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*GetDist(pos+0.0005*e);\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif \n}\n\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nfloat sdSphere( vec3 p, vec3 c, float r )\n{\n    mat4x4 trans = GetTransMat(-c);\n    p = (trans * vec4(p, 1.0f)).xyz;\n    return length(p)-r;\n}\n\nfloat sdBox( vec3 p, vec3 c, vec3 b )\n{\n    mat4x4 trans = GetTransMat(-c);\n    p = (trans * vec4(p, 1.0f)).xyz;\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0f)) + min(max(q.x,max(q.y,q.z)),0.0f);\n}\n\nfloat FloorDistance(vec3 pos)\n{\n    vec2 uv = vec2(pos.x, pos.z);\n    \n    float amplitude = 0.3f;\n    float freq = 1.2f;\n    float speed = 2.0f;\n    \n    \n    vec3 wave1 = vec3(0.0f, (cos((pos.x  + iTime * speed) * freq)*amplitude) , 0.0f);\n    vec3 wave2 = vec3(0.0f, (sin((pos.z  + iTime *speed) * freq)*amplitude), 0.0f);\n    vec3 floorPos = (wave1 + wave2) / 2.0f;\n    return sdBox(pos, floorPos, vec3(10.0f, 0.05f, 10.0f));\n}\n\nvec3 GetWaterNormal(vec3 pos)\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*FloorDistance( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*FloorDistance( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*FloorDistance( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*FloorDistance( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*FloorDistance(pos+0.0005*e);\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif\n}\n\n\nfloat ShipDistance(vec3 pos)\n{\n    float radiusSphere = 0.2f;\n    \n    //set pos\n    vec3 boxPos = GetBox1Pos();\n    vec3 point = boxPos - vec3(0.0f,1.0f, 0.0f) * radiusSphere;\n    vec3 normal = GetWaterNormal(point);\n    if(normal.y < 0.0f)\n    {\n        normal = -normal;\n    }\n    boxPos = boxPos + normal * (FloorDistance(point) + radiusSphere / 2.0f);\n    \n    vec3 upVec = normal;\n    vec3 viewCamDir = normalize(GetCamDir());\n    vec3 rightVec = normalize(cross(upVec, viewCamDir));\n    \n    mat4x4 trans = GetTransMat(boxPos);\n    mat4x4 changeBasis = mat4x4(viewCamDir.x, viewCamDir.y, viewCamDir.z, 0.0f,\n                                upVec.x, upVec.y, upVec.z, 0.0f,\n                                rightVec.x, rightVec.y, rightVec.z, 0.0f,\n                                0.0f,      0.0f,       0.0f,         1.0f);\n    \n    mat4x4 rotZ = GetRotMatZ(PI / 2.0f);\n    vec3 newPos = (trans * changeBasis * rotZ * inverse(trans) * vec4(pos, 1.0f)).xyz;\n    \n    //make form\n    float d1 = sdBox(newPos, boxPos + vec3(0.0f, radiusSphere, 0.0f), vec3(radiusSphere / 2.0f, 0.2f, radiusSphere));\n    \n    mat4x4 transToBoxPos = GetTransMat(boxPos);\n    vec4 posToChangeScale = inverse(transToBoxPos) * vec4(newPos, 1.0f);\n    posToChangeScale.z *= 0.5f;\n    posToChangeScale = transToBoxPos * posToChangeScale;\n    float d2 = sdSphere(posToChangeScale.xyz, boxPos, radiusSphere);\n    \n    float dMast = sdBox(newPos, boxPos, vec3(0.02f, mastHight, 0.02f));\n    float dGun = sdBox(newPos, boxPos + vec3(0.0f, mastHight, 0.05f), vec3(0.05f, 0.05f, 0.1f));\n    \n    return min(min(max(-d1, d2),dMast),dGun);\n}\n\nfloat Ship2Distance(vec3 pos)\n{\n    float radiusSphere = 0.2f;\n\n    float d1 = sdBox(pos, boxPos2 + vec3(0.0f, radiusSphere, 0.0f), vec3(radiusSphere / 2.0f, 0.2f, radiusSphere));\n    \n    mat4x4 trans = GetTransMat(boxPos2);\n    vec4 newPos = inverse(trans) * vec4(pos, 1.0f);\n    newPos.z *= 0.5f;\n    newPos = trans * newPos;\n    \n    float d2 = sdSphere(newPos.xyz, boxPos2, radiusSphere);\n    \n    float dMast = sdBox(pos, boxPos2, vec3(0.02f, mastHight, 0.02f));\n    float dGun = sdBox(pos, boxPos2 + vec3(0.0f, mastHight, 0.05f), vec3(0.05f, 0.05f, 0.1f));\n    return min(min(max(-d1, d2), dMast), dGun);\n}\n\nfloat ShootDistance(vec3 pos)\n{\n    return sdSphere(pos, GetShootPos(), 0.05f);\n}\n\nvec3 RayMarch(vec3 origin, vec3 rayDir, vec2 uv)\n{\n    float distOrigin = 0.0f;\n    float distOriginLight = 0.0f;\n    //get data about material and point\n    bool lightIsDone = false;\n    bool rayIsDone = false;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        //cam view raymarching\n        vec3 nowPoint = origin + rayDir * distOrigin;\n        float dist = GetDist(nowPoint);\n        distOrigin += dist;\n        \n        //light view raymarching\n        vec3 lightPoint = lightPos + lightDir * distOriginLight;\n        float distLight = GetDist(lightPoint);\n        distOriginLight += distLight;\n        \n        if(distOrigin > MAX_DIST || dist < SURFACE_DIST)\n            rayIsDone = true;\n        \n        if(distOriginLight > MAX_DIST || distLight < SURFACE_DIST)\n            rayIsDone = true;\n            \n        if(lightIsDone && rayIsDone)\n            break;\n    }\n    \n    \n    vec3 point = origin + rayDir * distOrigin;\n    \n    //materials\n    ///colors\n    vec3 box1Color = vec3(1.0f, 1.0f, 0.0f);\n    vec3 box2Color = vec3(0.0f, 1.0f, 0.0f);\n    vec3 floorColor = vec3(0.0f, 0.0f, 1.0f);\n    vec3 skyColor = vec3(0.3f, 0.8f, 1.0f);\n    ///vars\n    float alpha = 1.0f;\n    vec3 color = skyColor;\n    float metallica = 1.0f;\n    float smoothness = 0.0f;\n    //set colors\n    if (distOrigin < MAX_DIST) {\n        float materialID = GetMaterialID(point);\n        \n        if(abs(materialID - 1.0f) < 0.001f)\n        {\n            color = box1Color;\n            metallica = 0.3f;\n            smoothness = 1.0f;\n        }\n        if(abs(materialID - 2.0f) < 0.001f)\n        {\n            color = box2Color;\n            metallica = 0.3f;\n            smoothness = 0.5f;\n        }\n        if(abs(materialID - 4.0f) < 0.001f)\n        {\n            color = vec3(1.0f);\n            metallica = 0.0f;\n            smoothness = 1.0f;\n        }\n\n        if(abs(materialID - 3.0f) < 0.001f)\n        {\n            color = floorColor;\n            metallica = 0.1f;\n            smoothness = 0.5f;\n        }\n        \n        //set vecs for light\n        lightDir = normalize(lightDir);\n        vec3 normal = GetNormal(point);\n        vec3 middleVec = normalize(lightDir + rayDir);\n        //diffuse light\n        float diffuse = clamp(dot(lightDir, normal), 0.0f, 1.0f);\n        //specular\n        float specular = pow(clamp(dot(middleVec, normal), 0.0f, 1.0f),smoothness * 10.0f);\n        //shadows\n\n        //\n        float light = (specular * metallica + diffuse * (1.0f - metallica));\n        \n        return color * light;\n    }\n    else\n    {\n        return skyColor;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0f * fragCoord - iResolution.xy)/iResolution.y;\n    \n    float viewAngle = PI/4.0f;\n    float camAngle = iMouse.x * 0.1f;\n    vec4 anchorPoint = vec4(GetBox1Pos(), 1.0f);\n   \n    \n    vec3 camPos = texelFetch(iChannel3, ivec2(0,0),0).xyz;\n    vec3 viewCamDir = texelFetch(iChannel3, ivec2(1,0), 0).xyz;\n    \n    vec3 upVec = vec3(0.0f, 1.0f, 0.0f);\n    \n    upVec = upVec - dot(viewCamDir, upVec) * viewCamDir;\n    upVec = normalize(upVec);\n    mat4x4 rotDown   = GetRotMatX(viewAngle);\n    \n    vec3 rightVec = normalize(cross(viewCamDir, upVec));\n    \n    mat4x4 changeBasis = mat4x4(rightVec.x, upVec.x, viewCamDir.x, 0.0f,\n                                rightVec.y, upVec.y, viewCamDir.y, 0.0f,\n                                rightVec.z, upVec.z, viewCamDir.z, 0.0f,\n                                0.0f,      0.0f,       0.0f,         1.0f);\n               \n    mat4x4 lootAtMat = changeBasis;\n    \n    vec4 rayDir = vec4(uv.x, uv.y, 1.0f, 0.0f);\n    \n    rayDir = normalize(lootAtMat * rotDown * rayDir);\n    vec3 camDir = normalize(vec3(rayDir.x, 0.0f, rayDir.z));\n    \n    //set ray marching\n    vec3 color = RayMarch(camPos, rayDir.xyz, rayDir.xy);\n    \n    fragColor = vec4(color, 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void storeValue( in ivec2 re, in vec4 va, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    fragColor = (re.x==fragCoord.x && re.y==fragCoord.y ) ? va : fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 camDir = texelFetch(iChannel2, ivec2(1, 0), 0).xyz;\n    camDir = normalize(camDir);\n    vec3 upVec = vec3(0.0f, 1.0f, 0.0f);\n    vec3 rightVec = normalize(cross(upVec, camDir));\n    \n    ivec2 ifragCoord = ivec2(fragCoord);\n    if(iFrame == 0)\n    {\n        storeValue(ivec2(0,0), vec4(0.0f), fragColor, ifragCoord);\n        storeValue(ivec2(1,0), vec4(vec3(0.0f), 1.0f), fragColor, ifragCoord);\n    }\n    \n    float Wkeypressed = texelFetch(iChannel0, ivec2(87, 0), 0).x;\n    float Skeypressed = texelFetch(iChannel0, ivec2(83, 0), 0).x;\n    float SpaceKeyPressed = texelFetch(iChannel0, ivec2(32, 0), 0).x;\n    \n    vec3 ship1Pos = texelFetch(iChannel1, ivec2(0,0), 0).xyz;\n    vec3 shootPos = texelFetch(iChannel1, ivec2(1,0), 0).xyz;\n    vec3 shootDir = texelFetch(iChannel1, ivec2(2,0), 0).xyz;\n    float speed = 0.03f;\n    \n    float gotShoot = 0.0f;\n    \n    if(SpaceKeyPressed != 0.0f)\n    {\n        gotShoot = 1.0f;\n    }\n    \n    if(Wkeypressed != 0.0f)\n    {\n        ship1Pos = ship1Pos + camDir * speed;\n    }\n    if(Skeypressed != 0.0f)\n    {\n        ship1Pos = ship1Pos - camDir * speed;\n    }\n    \n    if(gotShoot > 0.5f)\n    {\n        shootPos = shootPos + shootDir * speed * 1.5f;\n    }\n    else\n    {\n        shootDir = camDir;\n        shootPos = ship1Pos + vec3(0.0f, 0.3f, 0.0f);\n    }\n    \n    storeValue(ivec2(0,0), vec4(ship1Pos, gotShoot), fragColor, ifragCoord);\n    storeValue(ivec2(1,0), vec4(shootPos, 0.0f), fragColor, ifragCoord);  \n    storeValue(ivec2(2,0), vec4(shootDir, 0.0f), fragColor, ifragCoord);  \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define PI 3.1415925359\n\nvec3 GetBox1Pos()\n{\n    return texelFetch(iChannel1, ivec2(0, 0), 0).xyz;\n}\n\nvec3 GetBox2Pos()\n{\n    return texelFetch(iChannel1, ivec2(1, 0), 0).xyz;\n}\n\nmat4x4 GetTransMat(vec3 pos)\n{\n    mat4x4 trans = mat4x4( 1.0f,  0.0f,  0.0f,   0.0f,\n                           0.0f,  1.0f,  0.0f,   0.0f,\n                           0.0f,  0.0f,  1.0f,   0.0f,\n                           pos.x, pos.y, pos.z,  1.0f);                  \n    return trans;\n}\n\nmat4x4 GetRotMatX(float angle)\n{\n    return mat4x4(1.0f,  0.0f,       0.0f,       0.0f,\n                  0.0f,  cos(angle), sin(angle), 0.0f,\n                  0.0f, -sin(angle), cos(angle), 0.0f,\n                  0.0f,  0.0f,       0.0,        1.0f);\n}\nmat4x4 GetRotMatZ(float angle)\n{\n    return mat4x4(cos(angle), 0.0f, -sin(angle),  0.0f,\n                  0.0f,       1.0f,  0.0f,        0.0f,\n                  sin(angle), 0.0f,  cos(angle),  0.0f,\n                  0.0f,       0.0f,  0.0,         1.0f);\n}\n\n\nvoid storeValue( in ivec2 re, in vec4 va, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    fragColor = (re.x==fragCoord.x && re.y==fragCoord.y ) ? va : fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0f * fragCoord - iResolution.xy)/iResolution.y;\n    ivec2 ifragCoord = ivec2(fragCoord);\n    if(iFrame == 0)\n    {\n        //base pos\n        storeValue(ivec2(2,0), vec4(0.0f), fragColor, ifragCoord);\n        storeValue(ivec2(0,0), vec4(vec3(0.5f, 1.0f, 0.5f), 1.0f), fragColor, ifragCoord);\n    }\n    \n    float camRotSpeed = 0.05f;\n\n    float Akeypressed = texelFetch(iChannel2, ivec2(65, 0), 0).x;\n    float Dkeypressed = texelFetch(iChannel2, ivec2(68, 0), 0).x;\n    \n    vec4 anchorPoint = vec4(GetBox1Pos(), 1.0f);\n    vec4 camPos = vec4(GetBox1Pos() - vec3(0.2f, 0.0f, 0.2f), 1.0f);\n    camPos.y = 1.0f;\n    \n    float viewAngle = PI/4.0f;\n    float camAngle = texelFetch(iChannel0, ivec2(2, 0), 0).x;\n    \n    if(Akeypressed != 0.0f)\n    {\n        camAngle += camRotSpeed;\n    }\n    if(Dkeypressed != 0.0f)\n    {\n        camAngle -= camRotSpeed;\n    }\n    \n    //cam pos\n    mat4x4 trans = GetTransMat(anchorPoint.xyz);\n    mat4x4 rotCamPos = GetRotMatZ(camAngle);\n    \n    //set cam pos\n    camPos = trans * rotCamPos * inverse(trans) * camPos;\n    \n    //set cam dir\n    vec3 viewCamDir = (anchorPoint - camPos).xyz;\n    viewCamDir.y = 0.0f;\n    viewCamDir = normalize(viewCamDir);\n    \n    storeValue(ivec2(0,0), camPos, fragColor, ifragCoord);\n    storeValue(ivec2(1,0), vec4(viewCamDir, 0.0f), fragColor, ifragCoord);\n    storeValue(ivec2(2,0), vec4(camAngle), fragColor, ifragCoord);\n}","name":"Buffer B","description":"","type":"buffer"}]}