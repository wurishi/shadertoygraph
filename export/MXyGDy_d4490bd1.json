{"ver":"0.1","info":{"id":"MXyGDy","date":"1718199259","viewed":84,"name":"Fork Slime Mold RGB - DJ","username":"DjBlueBear","description":"A simulation of slime mold inspired by Sebastian Lague's video on slime mold and ant colony simulations","likes":4,"published":3,"flags":48,"usePreview":0,"tags":["slimemold"],"hasliked":0,"parentid":"MXK3Rd","parentname":"Slime Mold 0 - DJ"},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int blurSize = 3;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 buffer = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    fragColor = buffer;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"struct agent{\n    vec2 pos;\n    float angle;\n};\n\nconst float pi = 3.141592653;\nconst float deg2Rad = pi / 180.0;\n\nuint hash(inout uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\nfloat rand(inout uint seed)\n{\n    return fract(float(hash(seed))/ 4294967296.0);//4294967296 2 ^ 32 / 32 bit unsigned integer limit\n}\n\nfloat randNorm(inout uint seed)\n{   \n    float theta = 2.0 * pi * rand(seed);\n    float rho = sqrt( -2.0 * log(rand(seed)));\n    return rho * cos(theta);\n}\n\nvec3 randVec3(inout uint seed)\n{\n    float rand0 = rand(seed);\n    float rand1 = rand(seed);\n    float rand2 = rand(seed);\n\n    return vec3(rand0, rand1, rand2);\n}\n\nvec3 randVec3Norm(inout uint seed)\n{\n    float rand0 = randNorm(seed);\n    float rand1 = randNorm(seed);\n    float rand2 = randNorm(seed);\n\n    return normalize(vec3(rand0, rand1, rand2));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float seedOffset = 0.0;\n\nconst uint agentNum = 800u;\n\nconst float decayRate = 1.005;//keep above 1, 1.03 is good\n\nconst float agentTrailWeight = 4.0;\n\nconst int sensorSize = 1;//keep low for good preformance\n\nconst float sensorForwardBias = 1.0;\n\nconst float sensorDistance = 2.0;//keep same or some factor of sensorSize\n\nconst float sensorGap = 2.0;\n\nconst float randomWalk = 0.01;\n\nconst float angleLimit = 1.0;//this is not in degrees or radians, it is not a measure of angle, check the code to see what it is\n//the higher this number is the narrower the angle the agents can move\nconst vec2 startingPos = vec2(0.75,0.75);\n\nconst float startingRad = 64.0;\n\nconst float maxInfluence = 1.0;\n\nvec2 loopCheck(in vec2 p)\n{\n    return mod(p, iResolution.xy);\n}\n// xy agent pos, z agent angle, w trail,\nvoid updateAgent(inout agent current, inout uint seed)\n{\n    float angle = current.angle;\n\n    vec2 forward = vec2(cos(angle), sin(angle));\n\n    vec2 right = vec2(forward.y, -forward.x);\n\n    current.pos += forward;\n    \n    current.pos = mod(current.pos, iResolution.xy);\n    \n    vec2 pos = current.pos;\n    \n    vec2 forwardOffset = forward * (sensorDistance + sensorForwardBias);\n    vec2 rightOffset = right * sensorGap + forward * sensorDistance;\n    vec2 leftOffset = -right * sensorGap + forward * sensorDistance;\n\n    float forwardSample = 0.0;\n    float rightSample = 0.0;\n    float leftSample = 0.0;\n\n    const float sensorCount = float(sensorSize * sensorSize) * 4.0;\n    for(int x = -sensorSize; x < sensorSize; x++)\n    {\n        for(int y = -sensorSize; y < sensorSize; y++)\n        {\n            forwardSample += texelFetch(iChannel0, ivec2(floor(loopCheck(pos + forwardOffset + vec2(x,y)))), 0).w;\n            rightSample += texelFetch(iChannel0, ivec2(floor(loopCheck(pos + rightOffset + vec2(x,y)))), 0).w;\n            leftSample += texelFetch(iChannel0, ivec2(floor(loopCheck(pos + leftOffset + vec2(x,y)))), 0).w;\n        }\n    }\n\n    forwardSample /= sensorCount;\n    rightSample /= sensorCount;\n    leftSample /= sensorCount;\n    \n    float forwardWeight = 1.0 + max(forwardSample, maxInfluence); \n\n    float rightWeight = max(rightSample, maxInfluence) - max(leftSample, maxInfluence);\n\n    float randomAngle = (rand(seed) * 2.0 - 1.0) * pi * randomWalk;\n\n    current.angle -= clamp(rightWeight / forwardWeight, -pi / (1.0 + angleLimit), pi / (1.0 + angleLimit)) + randomAngle;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float safeFrame = mod(float(iFrame + 1) + iDate.w, 1000.0);//(to avoid overflow of the seed)\n    uint seed = uint((fragCoord.x * iResolution.y + fragCoord.y) * safeFrame + seedOffset);\n    \n    uint id = uint(floor(fragCoord.y) * iResolution.x + floor(fragCoord.x));\n\n    vec4 buffer = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    float trail = buffer.w / decayRate;\n\n    for(uint i = 0u; i < agentNum; i++)\n    {\n        float x = mod(float(i), iResolution.x);\n        float y = floor(float(i) / iResolution.x);\n        vec2 pos = texelFetch(iChannel0, ivec2(x,y), 0).xy;\n        \n        if(floor(pos) == floor(fragCoord))\n        {\n            trail += agentTrailWeight;\n        }\n    }\n\n    if(id > agentNum)\n    {\n        fragColor = vec4(0.0,0.0,0.0,trail);\n        return;\n    }\n\n    if(iFrame == 1)\n    {\n        float angle = rand(seed) * pi * 2.0;\n        float dist = sqrt(rand(seed)) * startingRad;\n        vec2 pos = vec2(dist * cos(angle),dist * sin(angle)) + startingPos * iResolution.xy;\n        fragColor = vec4(pos,rand(seed) * 2.0 * pi,0.0);\n        return;\n    }\n    \n    agent current = agent(buffer.xy, buffer.z);\n\n    updateAgent(current, seed);\n\n    fragColor = vec4(current.pos,current.angle,trail);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"const int KEY_1 = 49;\nconst int KEY_2 = 50;\nconst int KEY_3 = 51;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float red =  texelFetch(iChannel3, ivec2(KEY_1,0.0), 0).x > 0.5 ? 0.0 : 1.0;\n    float green = texelFetch(iChannel3, ivec2(KEY_2,0.0), 0).x > 0.5 ? 0.0 : 1.0;\n    float blue = texelFetch(iChannel3, ivec2(KEY_3,0.0), 0).x > 0.5 ? 0.0 : 1.0;\n    vec4 bufferA = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 bufferB = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    vec4 bufferC = texelFetch(iChannel2, ivec2(fragCoord), 0);\n    \n    fragColor = vec4(bufferA.w * red, bufferB.w * green,bufferC.w * blue,0.0);\n    //fragColor = vec4(bufferA.w * red,0.0,0.0,0.0);\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const float seedOffset = 1.0;\n\nconst uint agentNum = 800u;\n\nconst float decayRate = 1.005;//keep above 1, 1.03 is good\n\nconst float agentTrailWeight = 4.0;\n\nconst int sensorSize = 1;//keep low for good preformance\n\nconst float sensorForwardBias = 1.0;\n\nconst float sensorDistance = 2.0;//keep same or some factor of sensorSize\n\nconst float sensorGap = 2.0;\n\nconst float randomWalk = 0.01;\n\nconst float angleLimit = 1.0;//this is not in degrees or radians, it is not a measure of angle, check the code to see what it is\n//the higher this number is the narrower the angle the agents can move\nconst vec2 startingPos = vec2(0.25,0.25);\n\nconst float startingRad = 50.0;\n\nconst float maxInfluence = 1.0;\n\nvec2 loopCheck(in vec2 p)\n{\n    return mod(p, iResolution.xy);\n}\n// xy agent pos, z agent angle, w trail,\nvoid updateAgent(inout agent current, inout uint seed)\n{\n    float angle = current.angle;\n\n    vec2 forward = vec2(cos(angle), sin(angle));\n\n    vec2 right = vec2(forward.y, -forward.x);\n\n    current.pos += forward;\n    \n    current.pos = mod(current.pos, iResolution.xy);\n    \n    vec2 pos = current.pos;\n    \n    vec2 forwardOffset = forward * (sensorDistance + sensorForwardBias);\n    vec2 rightOffset = right * sensorGap + forward * sensorDistance;\n    vec2 leftOffset = -right * sensorGap + forward * sensorDistance;\n\n    float forwardSample = 0.0;\n    float rightSample = 0.0;\n    float leftSample = 0.0;\n\n    const float sensorCount = float(sensorSize * sensorSize) * 4.0;\n    for(int x = -sensorSize; x < sensorSize; x++)\n    {\n        for(int y = -sensorSize; y < sensorSize; y++)\n        {\n            forwardSample += texelFetch(iChannel0, ivec2(floor(loopCheck(pos + forwardOffset + vec2(x,y)))), 0).w;\n            rightSample += texelFetch(iChannel0, ivec2(floor(loopCheck(pos + rightOffset + vec2(x,y)))), 0).w;\n            leftSample += texelFetch(iChannel0, ivec2(floor(loopCheck(pos + leftOffset + vec2(x,y)))), 0).w;\n        }\n    }\n\n    forwardSample /= sensorCount;\n    rightSample /= sensorCount;\n    leftSample /= sensorCount;\n    \n    float forwardWeight = 1.0 + max(forwardSample, maxInfluence); \n\n    float rightWeight = max(rightSample, maxInfluence) - max(leftSample, maxInfluence);\n\n    float randomAngle = (rand(seed) * 2.0 - 1.0) * pi * randomWalk;\n\n    current.angle -= clamp(rightWeight / forwardWeight, -pi / (1.0 + angleLimit), pi / (1.0 + angleLimit)) + randomAngle;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float safeFrame = mod(float(iFrame + 1) + iDate.w, 1000.0);//(to avoid overflow of the seed)\n    uint seed = uint((fragCoord.x * iResolution.y + fragCoord.y) * safeFrame + seedOffset);\n    \n    uint id = uint(floor(fragCoord.y) * iResolution.x + floor(fragCoord.x));\n\n    vec4 buffer = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    float trail = buffer.w / decayRate;\n\n    for(uint i = 0u; i < agentNum; i++)\n    {\n        float x = mod(float(i), iResolution.x);\n        float y = floor(float(i) / iResolution.x);\n        vec2 pos = texelFetch(iChannel0, ivec2(x,y), 0).xy;\n        \n        if(floor(pos) == floor(fragCoord))\n        {\n            trail += agentTrailWeight * rand(seed);\n        }\n    }\n\n    if(id > agentNum)\n    {\n        fragColor = vec4(0.0,0.0,0.0,trail);\n        return;\n    }\n\n    if(iFrame == 1)\n    {\n        float angle = rand(seed) * pi * 2.0;\n        float dist = sqrt(rand(seed)) * startingRad;\n        vec2 pos = vec2(dist * cos(angle),dist * sin(angle)) + startingPos * iResolution.xy;\n        fragColor = vec4(pos,rand(seed) * 2.0 * pi,0.0);\n        return;\n    }\n    \n    agent current = agent(buffer.xy, buffer.z);\n\n    updateAgent(current, seed);\n\n    fragColor = vec4(current.pos,current.angle,trail);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"const float seedOffset = 2.0;\n\nconst uint agentNum = 800u;\n\nconst float decayRate = 1.005;//keep above 1, 1.03 is good\n\nconst float agentTrailWeight = 4.0;\n\nconst int sensorSize = 1;//keep low for good preformance\n\nconst float sensorForwardBias = 1.0;\n\nconst float sensorDistance = 2.0;//keep same or some factor of sensorSize\n\nconst float sensorGap = 2.0;\n\nconst float randomWalk = 0.01;\n\nconst float angleLimit = 1.0;//this is not in degrees or radians, it is not a measure of angle, check the code to see what it is\n//the higher this number is the narrower the angle the agents can move\nconst vec2 startingPos = vec2(0.5,0.5);\n\nconst float startingRad = 50.0;\n\nconst float maxInfluence = 1.0;\n\nvec2 loopCheck(in vec2 p)\n{\n    return mod(p, iResolution.xy);\n}\n// xy agent pos, z agent angle, w trail,\nvoid updateAgent(inout agent current, inout uint seed)\n{\n    float angle = current.angle;\n\n    vec2 forward = vec2(cos(angle), sin(angle));\n\n    vec2 right = vec2(forward.y, -forward.x);\n\n    current.pos += forward;\n    \n    current.pos = mod(current.pos, iResolution.xy);\n    \n    vec2 pos = current.pos;\n    \n    vec2 forwardOffset = forward * (sensorDistance + sensorForwardBias);\n    vec2 rightOffset = right * sensorGap + forward * sensorDistance;\n    vec2 leftOffset = -right * sensorGap + forward * sensorDistance;\n\n    float forwardSample = 0.0;\n    float rightSample = 0.0;\n    float leftSample = 0.0;\n\n    const float sensorCount = float(sensorSize * sensorSize) * 4.0;\n    for(int x = -sensorSize; x < sensorSize; x++)\n    {\n        for(int y = -sensorSize; y < sensorSize; y++)\n        {\n            forwardSample += texelFetch(iChannel0, ivec2(floor(loopCheck(pos + forwardOffset + vec2(x,y)))), 0).w;\n            rightSample += texelFetch(iChannel0, ivec2(floor(loopCheck(pos + rightOffset + vec2(x,y)))), 0).w;\n            leftSample += texelFetch(iChannel0, ivec2(floor(loopCheck(pos + leftOffset + vec2(x,y)))), 0).w;\n        }\n    }\n\n    forwardSample /= sensorCount;\n    rightSample /= sensorCount;\n    leftSample /= sensorCount;\n    \n    float forwardWeight = 1.0 + max(forwardSample, maxInfluence); \n\n    float rightWeight = max(rightSample, maxInfluence) - max(leftSample, maxInfluence);\n\n    float randomAngle = (rand(seed) * 2.0 - 1.0) * pi * randomWalk;\n\n    current.angle -= clamp(rightWeight / forwardWeight, -pi / (1.0 + angleLimit), pi / (1.0 + angleLimit)) + randomAngle;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float safeFrame = mod(float(iFrame + 1) + iDate.w, 1000.0);//(to avoid overflow of the seed)\n    uint seed = uint((fragCoord.x * iResolution.y + fragCoord.y) * safeFrame + seedOffset);\n    \n    uint id = uint(floor(fragCoord.y) * iResolution.x + floor(fragCoord.x));\n\n    vec4 buffer = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    float trail = buffer.w / decayRate;\n\n    for(uint i = 0u; i < agentNum; i++)\n    {\n        float x = mod(float(i), iResolution.x);\n        float y = floor(float(i) / iResolution.x);\n        vec2 pos = texelFetch(iChannel0, ivec2(x,y), 0).xy;\n        \n        if(floor(pos) == floor(fragCoord))\n        {\n            trail += agentTrailWeight * rand(seed);\n        }\n    }\n\n    if(id > agentNum)\n    {\n        fragColor = vec4(0.0,0.0,0.0,trail);\n        return;\n    }\n\n    if(iFrame == 1)\n    {\n        float angle = rand(seed) * pi * 2.0;\n        float dist = sqrt(rand(seed)) * startingRad;\n        vec2 pos = vec2(dist * cos(angle),dist * sin(angle)) + startingPos * iResolution.xy;\n        fragColor = vec4(pos,rand(seed) * 2.0 * pi,0.0);\n        return;\n    }\n    \n    agent current = agent(buffer.xy, buffer.z);\n\n    updateAgent(current, seed);\n\n    fragColor = vec4(current.pos,current.angle,trail);\n}","name":"Buffer C","description":"","type":"buffer"}]}