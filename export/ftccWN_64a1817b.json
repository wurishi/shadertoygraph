{"ver":"0.1","info":{"id":"ftccWN","date":"1659837182","viewed":209,"name":"Voxel Compute Shader (Slow)","username":"Rugged","description":"use WASD to move, and ARROW keys to turn\n\nThough it only runs at 60fps (on my mobile RTX2060 + Chrome), it would run at that same speed with infinite voxels. Its not limited by voxel count but by precision and view distance.","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["voxels"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    vec4 col = vec4(0.);\n    \n    \n    \n    \n    //get the mouse location for look direction unless mouse is not down\n    vec2 muv = iMouse.xy / iResolution.xy;//iMouse.z > 0.0 ? iMouse.xy / iResolution.xy : vec2(0.5, 0.5);\n    \n    \n    float screenRatio = iResolution.y / iResolution.x;\n    \n    //Setting up the ray directions and other information about the point and camera\n    //##############################################################################\n    \n    \n    //camera direction angles phi (xy plane) and theta (xz plane)\n    float phi = radians(360. * (1. - muv.x));\n    float theta = radians(180. * (1. - muv.y));\n    \n    \n    phi = texelFetch(iChannel1, ivec2(1, 0), 0).x;\n    theta = texelFetch(iChannel1, ivec2(1, 0), 0).y;\n    \n    \n    //get the camera direction as the basis for the rotation (each ray direction is a rotation of the camera direciton vector)\n    //it is in quarternion form here so its a vec4 instead of a vec3\n    vec4 camD = vec4(0., cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta));\n    \n    \n    float rad90 = radians(90.);\n    \n    float fov = 100.;\n    \n    float xAng = radians(fov * (.5 - uv.x));\n    //replace \"fov\" with \"(fov + (110. * pow(.5 - uv.x, 2.)))\" below to add a counteractment to the fisheye lens effect\n    //it basically counteracts the artifact with quaternions that happens when you rotate by a large angle on one axis then try to rotate on another axis perpendicular, it just rotates around it thus making the new direction lesser\n    float yAng = radians(fov * screenRatio * (.5 - uv.y));\n    \n    //get the axes that the quarternions should be based around (perpendicular to the camera plane or dv)\n    vec3 xRotAxis = vec3(cos(phi) * sin(theta - rad90), sin(phi) * sin(theta - rad90), cos(theta - rad90));\n    vec3 yRotAxis = cross(xRotAxis, camD.yzw);//vec3(cos(phi - rad90) * sin(theta), sin(phi - rad90) * sin(theta), cos(theta));\n    \n    //get the quarternions of the ray direction rotations\n    vec4 xQuat = vec4(cos(xAng / 2.), xRotAxis * sin(xAng / 2.));\n    vec4 yQuat = vec4(cos(yAng / 2.), yRotAxis * sin(yAng / 2.));\n    \n    \n    \n    //combine the rotations\n    vec4 compQuat = quaternionMult(yQuat, xQuat);\n    \n    \n    \n    //get the conjugate of the compQuart\n    vec4 conjComp = vec4(compQuat.x, -compQuat.yzw);\n\n    \n    //ray direction\n    vec3 rayD = quaternionMult(quaternionMult(compQuat, camD), conjComp).yzw;\n    \n    \n    //############################################\n    \n    \n    vec3 rayO = texelFetch(iChannel1, ivec2(0), 0).xyz;\n    \n    vec3 p;\n    \n    float width = floor(pow(iResolution. x * iResolution.y, 1. / 3.));\n    \n    vec2 width2 = floor(iResolution.xy / width);\n    \n    float xLen = width2.x * width;\n    \n    float solidity = 1.;\n    \n\n    for(int i = 0; i < 500; i++){\n        \n        //as it gets further away take bigger steps\n        float stepSize = (0.005 * sqrt(float(i + 1) / .5));\n        \n        p = rayO + (float(i) * rayD * stepSize);\n        \n        if(true){//max(max(p.x, p.y), p.z) < width && min(min(p.x, p.y), p.z) >= 0.){\n            ivec2 texLoc = ivec2(int(floor(mod(p.z, width2.x)) * width), int(floor(p.z / width2.x) * width));\n            \n            texLoc += ivec2(int(p.x), int(p.y));\n            \n            vec4 c = texelFetch(iChannel0, texLoc, 0);\n            \n            solidity -= c.a;\n            \n            \n            \n            //shadow stuff\n            // https://www.desmos.com/calculator/xughxtwv2y\n            vec3 pCenterToP = normalize(p - (floor(p) + vec3(0.5)));\n            \n            float maxofd = max(abs(pCenterToP.x), max(abs(pCenterToP.y), abs(pCenterToP.z)));\n            \n            vec3 pD = vec3((floor(pCenterToP.x) + .5) * (maxofd - abs(pCenterToP.y)) * (maxofd - abs(pCenterToP.z)), (floor(pCenterToP.y) + .5) * (maxofd - abs(pCenterToP.x)) * (maxofd - abs(pCenterToP.z)), (floor(pCenterToP.z) + .5) * (maxofd - abs(pCenterToP.x)) * (maxofd - abs(pCenterToP.y)));\n            \n            vec3 lightD = normalize(vec3(.5));//normalize(vec3(cos(iTime), sin(iTime), 1.));\n            \n            float shadow = (dot(lightD, pD / (abs(pD) + .00001)) + 1.) / 2.;\n            \n            \n            \n            \n            col += c * c.a * shadow;\n            \n            if(solidity <= 0.){\n                break;\n            }\n            \n        }\n        \n    }\n    \n    \n    //col = texture(iChannel0, uv);\n\n    fragColor = vec4(col);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 col = vec4(0.);\n    \n    if(iFrame == 0){\n        col = vec4(hash3(uv), hash3(uv.yx), hash3(vec2(hash3(uv), uv.x)), hash3(vec2(hash3(uv.yx), uv.y)));\n        col *= floor(col.a * 1.9);\n        //col.a *= 0.5;\n\n    }\n    else{\n        col = texture(iChannel0, uv);\n    }\n    \n    float width = floor(pow(iResolution. x * iResolution.y, 1. / 3.));\n    \n    /*\n    if(mod(floor(fragCoord.x), width) == 0. || mod(floor(fragCoord.y), width) == 0.){\n        col = vec4(1., 0., 0., 1.);\n    }\n    */\n    \n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float hash3(vec2 xy){\n    xy = mod(xy, .19);\n    float h = dot(xy.yyx,vec3(.013, 27.15, 2027.3));\n    h *= h;\n    h *= fract(h);\n    \n    return fract(h);\n}\n\n//hamilton product and quaternion mult are equivalent\nvec4 hamiltonProduct(vec4 a, vec4 b){\n    float r = (a.x * b.x) - (a.y * b.y) - (a.z * b.z) - (a.w * b.w);\n    float x = (a.x * b.y) + (a.y * b.x) + (a.z * b.w) - (a.w * b.z);\n    float y = (a.x * b.z) - (a.y * b.w) + (a.z * b.x) + (a.w * b.y);\n    float z = (a.x * b.w) + (a.y * b.z) - (a.z * b.y) + (a.w * b.x);\n    return vec4(r, x, y, z);\n}\n\nvec4 quaternionMult(vec4 a, vec4 b){\n    return vec4(a.x * b.x - dot(a.yzw, b.yzw), a.x*b.yzw + b.x*a.yzw + cross(a.yzw, b.yzw));\n}\n\n\nvec3 quatToEuler(vec4 q){\n    float a = atan((2. * ((q.x * q.y) + (q.z * q.w))) / (1. - (2. * ((q.y * q.y) + (q.z * q.z)))));\n    float b = asin(2. * ((q.x * q.z) + (q.y * q.w)));\n    float c = atan((2. * ((q.x * q.w) + (q.y * q.z))) / (1. - (2. * ((q.z * q.z) + (q.w * q.w)))));\n    return vec3(a, b, c);\n}\n\nvec3 eulerToSph(vec3 a){\n    return vec3(cos(a.x) * sin(a.y), sin(a.x) * sin(a.y), cos(a.y));\n}\n\nvec3 quatToSph(vec4 q){\n    return vec3(2. * ((q.x * q.z) + (q.w * q.y)), 2. * ((q.y * q.z) - (q.w * q.x)), 1. - (2. * ((q.x * q.x) + (q.y * q.y))));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define turnSpeed 2.\n#define moveSpeed 30.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    \n    if(iFrame == 0){\n        if(floor(fragCoord.x) == 0. && floor(fragCoord.y) == 0.){\n            col = vec4(-10.);\n        }\n        else if(floor(fragCoord.x) == 1. && floor(fragCoord.y) == 0.){\n            col = vec4(0., 1.5, 0., 0.);\n        }\n    }\n    \n    //get the mouse location for look direction unless mouse is not down\n    vec2 muv = iMouse.xy / iResolution.xy;//iMouse.z > 0.0 ? iMouse.xy / iResolution.xy : vec2(0.5, 0.5);\n    \n    \n    float screenRatio = iResolution.y / iResolution.x;\n    \n    //Setting up the ray directions and other information about the point and camera\n    //##############################################################################\n    \n    \n    //camera direction angles phi (xy plane) and theta (xz plane)\n    float phi = radians(360. * (1. - muv.x));\n    float theta = radians(180. * (1. - muv.y));\n    \n    \n    phi = texelFetch(iChannel0, ivec2(1, 0), 0).x;\n    theta = texelFetch(iChannel0, ivec2(1, 0), 0).y;\n\n    \n    \n    //get the camera direction as the basis for the rotation (each ray direction is a rotation of the camera direciton vector)\n    //it is in quarternion form here so its a vec4 instead of a vec3\n    vec4 camD = vec4(cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta), 0.);\n    \n    \n    \n    if(floor(fragCoord.x) == 0. && floor(fragCoord.y) == 0.){\n        vec4 camPerp = vec4(0.);\n        if(iFrame > 0){\n            vec3 tem = cross(normalize(vec3(camD.xy, 0.)), vec3(0., 0., 1.));\n            camPerp = vec4(tem, 0.);\n        }\n    \n        //if W is pressed go forwards\n        col += camD * texelFetch(iChannel1, ivec2(87, 0), 0).x * iTimeDelta * moveSpeed;\n        \n        //if S is pressed go backwards\n        col -= camD * texelFetch(iChannel1, ivec2(83, 0), 0).x * iTimeDelta * moveSpeed;\n        \n        //if A is pressed go forwards\n        col -= camPerp * texelFetch(iChannel1, ivec2(65, 0), 0).x * iTimeDelta * moveSpeed;\n        \n        //if D is pressed go backwards\n        col += camPerp * texelFetch(iChannel1, ivec2(68, 0), 0).x * iTimeDelta * moveSpeed;\n        \n    }\n    else if(floor(fragCoord.x) == 1. && floor(fragCoord.y) == 0.){\n    \n        //if UP is pressed turn up\n        col.y -= texelFetch(iChannel1, ivec2(38, 0), 0).x * iTimeDelta * turnSpeed;\n        \n        //if DOWN is pressed turn down\n        col.y += texelFetch(iChannel1, ivec2(40, 0), 0).x * iTimeDelta * turnSpeed;\n        \n        //if LEFT is pressed turn up\n        col.x += texelFetch(iChannel1, ivec2(37, 0), 0).x * iTimeDelta * turnSpeed;\n        \n        //if RIGHT is pressed turn down\n        col.x -= texelFetch(iChannel1, ivec2(39, 0), 0).x * iTimeDelta * turnSpeed;\n    }\n    \n    fragColor = col;\n}","name":"Buffer B","description":"","type":"buffer"}]}