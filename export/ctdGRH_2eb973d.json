{"ver":"0.1","info":{"id":"ctdGRH","date":"1682016885","viewed":29,"name":"CG HW 1","username":"chaima","description":"simple Raytracing scene.","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["reflection","refraction","raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float pi = 3.1415926535897932384626433832795;\n\n#define LIGHT(r,g,b, ior) Material(vec3(r, g, b), 1.0, vec3(100.), 0.02, ior)\n#define METAL(r,g,b,m,ior) Material(vec3(r,g,b), float(m), vec3(0,0,0), 0.9, ior)\n#define NONMETAL(r,g,b,m,ior) Material(vec3(r,g,b), float(m), vec3(0,0,0), 0.02, ior)\n\n\nstruct Material {\n    vec3  color;        // [0,1/pi]\n    float roughness;    // [0,7]\n    vec3 emission;\t\t// [0, inf]\n    float metalness;    // 0.02-0.05 for non-metals, 0.6-0.9 for metals\n    float ior;\n\n};\n\nMaterial materials[8] = Material[](\n    //Non-metals\n    LIGHT(0.95, 0.85, 0.1, 1.0), //0\n    NONMETAL(0.8, 0.2, 0.2, 0.7, 0.1), //1 \n    NONMETAL(0.5, 0.5, 0.5, 0.5, 1.0), //2\n    //Metals\n    METAL(1.0, 0.3, 0.8 ,0.3,0.2), //3\n    METAL(0.9, 0.2, 0.2, 0.6, 0.4), //4\n    METAL(1., 0.9, 0.0, 0.3 ,0.1), //5\n    METAL(0.5, 0.5, 0.5, 0.3, 0.1), //6\n    NONMETAL(0.5, 3., 2., 0.1, 0.2) //7\n\n);\n\n\nstruct Sphere {\n    vec3 c;    // center\n    float r;   // radius\n    int material;\n    bool textured;\n};\n\nstruct Plane {\n    vec3 q0;    // any point on the plane\n    vec3 n;     // normal\n    int material;\n    bool textured;\n};\n\nstruct Triangle\n{\nvec3 a,b,c;\nint material;\nbool textured;\n};\n\nstruct Disk {\n    vec3 q0;   // point on the plane\n    vec3 n;    // normal vector of the plane\n    float R;    // disk outer radius\n    float r; // disk inner radius\n    int material;\n    bool textured;\n};\n\nstruct Ray\n{\n\tvec3 p0;    // ray origin if tmin=0\n\tfloat tmin; // omit solutions t<tmin\n\tvec3 v;     // direction\n\tfloat tmax; // omit solutions t>tmax\n};\n\nstruct TraceResult\n{\n    vec3 n;  // Normal vector on surface\n    float t; // Distance taken on ray\n    int material;\n    bool textured;\n};\n\n\n#define STACK_SIZE 10\n\nstruct Stack {\n    Ray rays[STACK_SIZE];\n    int topIndex;\n};\n\nvoid stackInit(Stack stack) {\n    stack.topIndex = -1;\n}\n\nbool stackIsEmpty(Stack stack) {\n    return stack.topIndex == -1;\n}\n\nbool stackIsFull(Stack stack) {\n    return stack.topIndex == STACK_SIZE - 1;\n}\n\nvoid stackPush(Stack stack, Ray ray) {\n    if (stackIsFull(stack)) {\n        return;\n    }\n    stack.topIndex++;\n    stack.rays[stack.topIndex] = ray;\n}\n\nRay stackPop(Stack stack) {\n    Ray ray;\n    if (stackIsEmpty(stack)) {\n        return ray;\n    }\n    ray = stack.rays[stack.topIndex];\n    stack.topIndex--;\n    return ray;\n}\n\n\n//https://www.shadertoy.com/view/4lSGRV\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a),   ca = cos(a);\n  return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int spheresNo = 2;\nSphere spheres[spheresNo];\n\nconst int planeNo = 1;\nPlane planes[planeNo];\n\nconst int triangleNo = 17;\nTriangle triangles[triangleNo];\n\nconst int disksNo = 2;\nDisk disks[disksNo];\n\nconst int MAX_DEPTH = 2;\nconst float INFINITY = 900.;\n\n\n\n// ---- CAMERA and EVENTs ----\n// Common key codes (WASD instead of arrows)\n\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nconst vec3 EyeStartPosition = vec3(-25.0, 5.0, -5.0);\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2)\n{\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    \n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw+EyeStartPosition;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 0.2;\n    if (isKeyHeld(KeyLeft )) eye -= u*speed;\n    if (isKeyHeld(KeyRight)) eye += u*speed;\n    if (isKeyHeld(KeyUp   )) eye += w*speed;\n    if (isKeyHeld(KeyDown )) eye -= w*speed;\n    \n    if(iMouse.z>=0.)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//P\n               0.5,\t\t\t\t\t\t\t//minT\n               normalize(w+px.x*u+px.y*v),\t//V\n               500.);\t\t\t\t\t\t//maxT\n}\n\n\n\nconst float maxT = 1000.0;\n\nTraceResult intersectSphere(Ray ray, Sphere s)\n{\n    vec3 p0c = ray.p0 - s.c;\n    float a = dot(ray.v, ray.v);\n    float b = 2.0 * dot(p0c, ray.v);\n    float c = dot(p0c,p0c) - s.r*s.r;\n    float discriminant = b*b - 4.0*a*c;\n    if(discriminant < 0.0)\n        return TraceResult(vec3(0),ray.tmax, -1, false); // no intersection\n    float sqd = sqrt(discriminant);\n    float numerator = -b - sqd;\n    if(numerator < 0.0)\n        numerator = -b + sqd;\n    float t = 0.5 * numerator / a;\n    vec3 p = ray.p0 + t * ray.v;\n    vec3 normal = normalize(p - s.c);\n    return TraceResult(normal, t, s.material, s.textured);\n}\n\nTraceResult intersectPlane(Ray ray, Plane plane)\n{\n    float t = dot(plane.q0-ray.p0,plane.n)/dot(ray.v,plane.n);\n    return TraceResult(plane.n, t, plane.material, plane.textured);\n}\n\nTraceResult intersectTriangle(Ray ray, Triangle triangle) {\n    const float EPSILON = 0.000001;\n    vec3 ab, ac, ap, f, g;\n    float q, denom, u, v;\n    ab = triangle.b - triangle.a;\n    ac = triangle.c - triangle.a;\n    f = cross(ray.v, ac);\n    q = dot(ab, f);\n    if (q > -EPSILON && q < EPSILON) { //to avoid division by zero in the calculation of 'denom'\n        return TraceResult(vec3(0), ray.tmax, -1, false);\n    }\n    denom = 1.0 / q;\n    ap = ray.p0 - triangle.a;\n    u = denom * dot(f, ap);\n    if (u < 0.0 || u > 1.0) { //to ensure that the intersection point is inside the triangle\n        return TraceResult(vec3(0), ray.tmax, -1, false);\n    }\n    g = cross(ap, ab);\n    v = denom * dot(ray.v, g);\n    if (v < 0.0 || 1.0 - u - v < 0.0) { //testing if the intersection point is inside the triangle.\n        return TraceResult(vec3(0), ray.tmax, -1, false);\n    }\n    float t = denom * dot(ac, g);\n    if (t > EPSILON) { //to prevent self-intersection\n        vec3 normal = normalize(cross(ab, ac));\n        return TraceResult(normal, t, triangle.material, triangle.textured);\n    } else {\n        return TraceResult(vec3(0), ray.tmax, -1, false);\n    }\n}\n\nTraceResult intersectDisk(Ray ray, Disk disk) {\n\n    float t = dot(disk.n, disk.q0 - ray.p0) / dot(disk.n, ray.v); //the intersection of the ray and the plane of the disk\n    vec3 p = ray.p0 + t * ray.v;\n    //Check if the intersection point is within the disk region \n    // disk.r < distance(p, disk.q0) < disk.R   ===> intersection\n    float d = distance(p, disk.q0);\n    if(d > disk.R || d < disk.r){\n        return TraceResult(vec3(0),ray.tmax, -1, false); // no intersection\n    }\n    \n    return TraceResult(disk.n, t, disk.material, disk.textured);\n}\n\nTraceResult raycast(Ray ray)\n{\n    TraceResult res = TraceResult(vec3(0), ray.tmax, -1, false);\n    for(int i = 0; i < spheresNo; ++i)\n    {\n        TraceResult res2 = intersectSphere(ray, spheres[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    for(int i = 0; i < planeNo; ++i)\n    {\n        TraceResult res2 = intersectPlane(ray, planes[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    for(int i = 0; i < triangleNo; ++i)\n    {\n        TraceResult res2 = intersectTriangle(ray, triangles[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    for(int i = 0; i < disksNo; ++i)\n    {\n        TraceResult res2 = intersectDisk(ray, disks[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    return res;\n}\n\n\nvec4 missColor(Ray ray)\n{\n    return vec4(texture(iChannel2, ray.v).xyz,1.);\n}\n\n\nfloat chiGGX(float v)\n{\n    return v > 0. ? 1. : 0.;\n}\n\n//GGX distribution\nfloat D_GGX(vec3 h, vec3 n, float roughness)\n{\n    float NdotH = clamp(dot(h,n),0.,1.);\n    float alpha = roughness;\n    float alphaSq = alpha * alpha;\n    float NdotHSq = NdotH * NdotH;\n    float denom = NdotHSq * alphaSq + (1.0 - NdotHSq);\n    return (chiGGX(NdotH) * alphaSq) / (pi * denom * denom);\n}\n\n\n//Cook-Torrance geometric attenuation\nfloat G_CookTorrance(vec3 h, vec3 n, vec3 l, vec3 v)\n{\n    float NdotH = max(dot(h, n), 0.0), NdotV = max(dot(v, n), 0.01);\n\tfloat NdotL = max(dot(l, n), 0.01), HdotV = max(dot(v, h), 0.0);\n    return min( 1.0, min(((2.*NdotH*NdotV)/HdotV), ((2.*NdotH*NdotL)/HdotV)));\n\n}\n\n// Computing the amount of reflected light using Schlick's approximation\nfloat Fresnel_Schlick(vec3 incident, vec3 normal, float n1, float n2)\n{\n    float r0 = pow((n1 - n2) / (n1 + n2), 2.);\n    float cosT = dot(incident, normal);\n    float Srefl = clamp(r0 + (1. - r0) * pow((1. - cosT), 5.), 0., 1.);\n    \n    return Srefl;\n}\n\n\n//http://www.codinglabs.net/article_physically_based_rendering_cook_torrance.aspx\n//https://graphicscompendium.com/references/cook-torrance\nvec3 brdf(vec3 n, vec3 l, vec3 v, in Material material)\n{\n        vec3  h = normalize(l + v);\n        float D = D_GGX(h, n, material.roughness);\n        float G = G_CookTorrance(h, n, l, v);\n        \n        // Calculate colour at normal incidence\n        vec3 F0 = vec3(abs ((1.0 - material.ior) / (1.0 + material.ior)));\n        F0 = F0 * F0;\n        F0 = mix(F0, material.color, material.metalness);\n          float cosT = dot(h, n);\n          vec3 F = F0 + (1. - F0)*pow(1.- cosT,5.);\n          \n          float NdotL = max(dot(l, n), 0.01), NdotV = max(dot(v, n), 0.01);\n          vec3 specular  = D*F*G / (4. * NdotV * NdotL);\n          \n          vec3 diffuse =  (1. - F)* (1.0 - material.metalness) * material.color / pi;\n    \n\treturn max(specular + diffuse,0.);\n}\n\n\n\nvec4 hitColor(Ray ray, TraceResult tr, vec3 lightPos)\n{\n    int matId = tr.material;\n    Material material = materials[matId];\n\n    \n    vec3 p = ray.p0 + ray.v*tr.t;\n    vec3 n = tr.n;\n    \n    vec3 v = -ray.v;\n    \n    vec3 ambient = dot(n, v) * material.emission;\n\n        \n    vec3 l = lightPos-p;\n    float lightDist = length(l);\n    l /= lightDist; // normalized direction to the light\n        \n    Ray shadowray = Ray(p+0.001*n, 0.001, l, lightDist);\n\n   TraceResult res = raycast(shadowray);\n    \n    vec3 col = vec3(0.); // remains 0 if in shadow\n    if(res.t==shadowray.tmax)\n    {               \n        //sum\n        col = ambient + brdf(n, l, v, material) * max(dot(n,l),0.);\n\n    \n    if(tr.textured) // add texture if any\n    {\n        vec3 tex = texture(iChannel3, p.xy).rgb;\n        col *= tex;\n    }\n \n    \n        \n    }\n    return vec4(col,1.);\n}\n\n/*\nvec4 hitColor(Ray ray, TraceResult tr, vec3 lightPos)\n{\n    \n    int matId = tr.material;\n    Material material = materials[matId];\n    \n    vec3 p = ray.p0 + ray.v*tr.t;\n    vec3 n = tr.n;\n    \n    \n    \n    vec3 l = lightPos-p;\n    float lightDist = length(l);\n    l /= lightDist; // normalized direction to the light\n    \n    Ray shadowray = Ray(p+0.001*n, 0.001, l, lightDist);\n    TraceResult res = raycast(shadowray);\n    \n    vec3 col = vec3(0.); // remains 0 if in shadow\n    if(res.t==shadowray.tmax)\n    {\n        vec3 v = -ray.v;\n      \n\n        //diffuse\n        float costheta = max(dot(n,l),0.);\n        vec3 k_d = material.color*material.roughness /pi;\n        \n        vec3 ambient = dot(n, v) * material.emission;\n\n\n        //specular\n        vec3 toLight = normalize(lightPos - p);\n        vec3 toEye = -ray.v;\n        vec3 k_s = vec3(material.metalness);\n\n        vec3 h = normalize(toLight+toEye);\n        float si = pow(clamp(dot(h,n),0.,1.), 100.);\n\n        //sum\n        col = ambient + (k_d + si*k_s)*costheta;\n    }\n    return vec4(col,1.);\n} \n*/\n\nvec4 recursive(Ray ray, TraceResult tr, vec3 lightPos)\n{\n    vec3 p = ray.p0 + ray.v * tr.t; //intersection with initial ray\n    vec3 origin;\n    vec3 direction;\n    float ior = materials[tr.material].ior;\n    \n    float reflectance = Fresnel_Schlick(p, tr.n, 1.0, ior); //calculate the amount of reflected light based on the angle of incidence and the refractive indices (IOR)\n    vec4 refractionColor = vec4(0.);\n    \n    if (reflectance < 1.) //If the reflectance is less than 1, calculate the color of the refracted ray\n    {\n        origin = p - 0.001;\n        direction = refract(p, -tr.n, 1.0 / ior); //refraction ray direction // Snell's law.\n        //When a ray of light passes from one medium to another with a different refractive index, \n       //its direction changes due to the difference in the speed of light in the two media. \n       // sin(theta_i) / sin(theta_t) = n_t / n_i\n       // -tr.n because the incident ray is coming from outside the object and the normal points outward from the surface.\n\n        Ray refractionRay = Ray(origin, 0.001, direction, 900.);\n        \n        TraceResult RefractionResult = raycast(refractionRay);\n        \n        vec3 refractionP = refractionRay.p0 + refractionRay.v * RefractionResult.t;\n        \n        refractionColor += (1. - reflectance) * hitColor(refractionRay, RefractionResult, refractionP); //color of refracted ray\n    }\n\n    vec4 finalCol = reflectance * hitColor(ray, tr, lightPos) + refractionColor; //color of reflected ray using origin ray p\n    \n    vec3 l = lightPos - p;\n    vec3 ReflectDir = reflect(-l, tr.n);\n    Ray refRay = Ray(p + 0.001 * tr.n, 0.001, ReflectDir, INFINITY);\n    TraceResult refRes = raycast(refRay);\n    p = refRay.p0 + refRay.v * refRes.t;\n    vec3 n;\n\n    //Each iteration of the loop calculates the reflectance and refraction color of the object \n    for(int bounce = 0; bounce < MAX_DEPTH; ++bounce)\n    {\n        if(refRay.tmax <= refRes.t || refRes.t <= refRay.tmin)\n        {\n            break;\n        }\n        \n        ior = materials[refRes.material].ior;\n        \n        //the sign of the dot product tells us whether the incident ray is coming from outside \n        //or inside the object\n        if (dot(refRay.v, refRes.n) < 0.) //coming from outside the object\n        {\n            n = refRes.n;\n            reflectance = Fresnel_Schlick(p, n, 1.0, ior);\n        }\n        else //coming from inside the object\n        {\n            n = -refRes.n;\n            reflectance = Fresnel_Schlick(p, n, ior, 1.0);\n        }\n        refractionColor = vec4(0.);\n        \n        if (reflectance < 1.) //some light is refracted\n        {  \n          // If the ray is coming from outside, we use the ratio of the refractive indices \n          // as the refractive index of the medium the ray is entering divided by the refractive \n          // index of the medium it is leaving. If the ray is coming from inside, we reverse the \n          // order of the refractive indices\n            if (dot(refRay.v, refRes.n) < 0.) //outside\n            {\n                origin = p - 0.001;\n                direction = refract(p, -tr.n, 1.0 / ior);\n            }\n            else\n            {\n                origin = p + 0.001;\n                direction = refract(p, tr.n, ior / 1.0);\n            }\n            Ray refractionRay = Ray(origin, 0.001, direction, INFINITY);\n\n            TraceResult refractionRes = raycast(refractionRay);\n\n            vec3 refractionP = refractionRay.p0 + refractionRay.v * refractionRes.t;\n\n            refractionColor += (1. - reflectance) * hitColor(refractionRay, refractionRes, refractionP);\n             }\n        \n        finalCol += reflectance * hitColor(ray, tr, lightPos) + refractionColor;\n        \n        //the reflection of the scene from the position of the light source \n        p = refRay.p0 + refRay.v * refRes.t;\n        l = lightPos - p;\n        ReflectDir = reflect(-l, n);\n        refRay = Ray(p + 0.001 * tr.n, 0.001, ReflectDir, INFINITY);\n        refRes = raycast(refRay);\n        \n    }\n    return finalCol;\n}\n/*\nvec4 recursive(Ray ray, TraceResult tr, vec3 lightPos)\n{\n    vec3 p = ray.p0 + ray.v * tr.t; //intersection with initial ray\n    vec3 origin;\n    vec3 direction;\n    float ior = materials[tr.material].ior;\n    \n    float reflectance = Fresnel_Schlick(p, tr.n, 1.0, ior); //calculate the amount of reflected light based on the angle of incidence and the refractive indices (IOR)\n    vec4 refractionColor = vec4(0.);\n    Stack rayStack;\n    // Initialize the stack\n    stackInit(rayStack);\n\n    \n    if (reflectance < 1.)\n    {\n        // calculate the refraction color \n        origin = p - 0.001;\n        direction = refract(p, -tr.n, 1.0 / ior); //refraction ray direction\n\n        Ray refractionRay = Ray(origin, 0.001, direction, 900.);\n        \n        TraceResult RefractionResult = raycast(refractionRay);\n        \n        vec3 refractionP = refractionRay.p0 + refractionRay.v * RefractionResult.t;\n        \n        refractionColor += (1. - reflectance) * hitColor(refractionRay, RefractionResult, refractionP);\n        \n        if (refractionRay.tmax > RefractionResult.t) // if refraction hit something, push the new ray onto the stack\n        {\n            stackPush(rayStack, refractionRay);\n        }\n    }\n\n    vec4 finalCol = reflectance * hitColor(ray, tr, lightPos) + refractionColor;\n    \n    vec3 l = lightPos - p;\n    vec3 ReflectDir = reflect(-l, tr.n);\n    Ray refRay = Ray(p + 0.001 * tr.n, 0.001, ReflectDir, INFINITY);\n    TraceResult refRes = raycast(refRay);\n    p = refRay.p0 + refRay.v * refRes.t;\n    vec3 n;\n\n    while (!stackIsEmpty(rayStack)) // process the stack\n    {\n        Ray curRay = stackPop(rayStack);\n        stackPop(rayStack);\n        \n        vec3 curP = curRay.p0 + curRay.v * refRes.t;\n        \n        ior = materials[refRes.material].ior;\n        \n        if (dot(curRay.v, refRes.n) < 0.) //outside when dot(v,n) < 0.\n        {\n            n = refRes.n;\n            reflectance = Fresnel_Schlick(curP, n, 1.0, ior);\n        }\n        else\n        {\n            n = -refRes.n;\n            reflectance = Fresnel_Schlick(curP, n, ior, 1.0);\n        }\n        refractionColor = vec4(0.);\n        \n        if (reflectance < 1.)\n        {\n            if (dot(curRay.v, refRes.n) < 0.) //outside\n            {\n                origin = curP - 0.001;\n                direction = refract(curP, -n, 1.0 / ior);\n            }\n            else\n            {\n                origin = curP + 0.001;\n                direction = refract(curP, n, ior / 1.0);\n            }\n            Ray refractionRay = Ray(origin, 0.001, direction, INFINITY); \n            \n          TraceResult RefractionResult = raycast(refractionRay);\n        \n        vec3 refractionP = refractionRay.p0 + refractionRay.v * RefractionResult.t;\n        \n        refractionColor += (1. - reflectance) * hitColor(refractionRay, RefractionResult, refractionP);\n        \n        if (refractionRay.tmax > RefractionResult.t) // if refraction hit something, push the new ray onto the stack\n        {\n            stackPush(rayStack, refractionRay);\n        }\n    }\n    \n    finalCol += reflectance * hitColor(curRay, refRes, lightPos) + refractionColor;\n    \n    l = lightPos - curP;\n    ReflectDir = reflect(-l, n);\n    refRay = Ray(curP + 0.001 * n, 0.001, ReflectDir, INFINITY);\n    refRes = raycast(refRay);\n    p = refRay.p0 + refRay.v * refRes.t;\n}\n\nreturn finalCol;\n}\n*/\n\n\n// ---- MAIN ----\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Description of 2 spheres\n    //spheres[0] = Sphere(vec3(3,40, 7), 10.f, 0, false);\n    spheres[1] = Sphere(vec3(15,5,30), 3.f, 3, false);\n    spheres[1].c = rotateY(spheres[1].c, 0.5 * iTime);\n    // Create rings\n    disks[0] = Disk(vec3(15,5,30), normalize(vec3(-sin(iTime) * 2., 5.0 + sin(iTime), 0)), 6.0, 4.0, 7, false);\n\n    for (int i = 0; i < 2; ++i)\n    {\n        disks[i].q0 = rotateY(disks[i].q0, 0.5 * iTime);\n       \n    }\n    \n    planes[0] = Plane(vec3(0), normalize(vec3(0,1,0)), 6, false);\n    \n    // pyramid 1\n    int b = 0; // base height\n    int h = 15; // peak height\n    int x1 = 4;\n    int x2 = 20;\n    int z1 = 0;\n    int z2 = 16;\n    int x = (x1 + x2) / 2;\n    int z = (z1 + z2) / 2;\n    \n    // the order in which the vertices defined is important because it scews up the shading\n    triangles[0] = Triangle(vec3(x2, b, z1), vec3(x1, b, z1), vec3(x, h, z), 5, false); //front\n    triangles[1] = Triangle(vec3(x1, b, z2), vec3(x2, b, z2), vec3(x, h, z), 5, false); // back\n    triangles[2] = Triangle(vec3(x1, b, z1), vec3(x1, b, z2), vec3(x, h, z), 5, false); // left\n    triangles[3] = Triangle(vec3(x2, b, z2), vec3(x2, b, z1), vec3(x, h, z), 5, false); // right\n    triangles[4] = Triangle(vec3(x1, b, z1), vec3(x2, b, z1), vec3(x2, b, z2), 5, false); // bottom right\n    triangles[5] = Triangle(vec3(x1, b, z1), vec3(x2, b, z2), vec3(x1, b, z2), 5, false); // bottom left\n\n    // pyramid 2\n    b = 0; // base height\n    h = 10; // peak height\n    x1 = -15;\n    x2 = -3;\n    z1 = 0;\n    z2 = 16;\n    x = (x1 + x2) / 2;\n    z = (z1 + z2) / 2;\n    // the order in which the vertices defined is important because it scews up the shading\n    triangles[6] = Triangle(vec3(x2, b, z1), vec3(x1, b, z1), vec3(x, h, z), 5, true); //front\n    triangles[7] = Triangle(vec3(x1, b, z2), vec3(x2, b, z2), vec3(x, h, z), 5, true); // back\n    triangles[8] = Triangle(vec3(x1, b, z1), vec3(x1, b, z2), vec3(x, h, z), 4, false); // left\n    triangles[9] = Triangle(vec3(x2, b, z2), vec3(x2, b, z1), vec3(x, h, z), 4, false); // right\n    triangles[10] = Triangle(vec3(x1, b, z1), vec3(x2, b, z1), vec3(x2, b, z2), 4, false); // bottom right\n    triangles[11] = Triangle(vec3(x1, b, z1), vec3(x2, b, z2), vec3(x1, b, z2), 4, false); // bottom left\n \n    // pyramid 3\n    b = 0; // base height\n    h = 8; // peak height\n    x1 = -6;\n    x2 = 4;\n    z1 = 18;\n    z2 = 28;\n    x = (x1 + x2) / 2;\n    z = (z1 + z2) / 2;\n    // the order in which the vertices defined is important because it scews up the shading\n    triangles[11] = Triangle(vec3(x2, b, z1), vec3(x1, b, z1), vec3(x, h, z), 7, false); //front\n    triangles[12] = Triangle(vec3(x1, b, z2), vec3(x2, b, z2), vec3(x, h, z), 7, false); // back\n    triangles[13] = Triangle(vec3(x1, b, z1), vec3(x1, b, z2), vec3(x, h, z), 7, false); // left\n    triangles[14] = Triangle(vec3(x2, b, z2), vec3(x2, b, z1), vec3(x, h, z), 7, false); // right\n    triangles[15] = Triangle(vec3(x1, b, z1), vec3(x2, b, z1), vec3(x2, b, z2), 7, false); // bottom right\n    triangles[16] = Triangle(vec3(x1, b, z1), vec3(x2, b, z2), vec3(x1, b, z2), 7, false); // bottom\n \n    vec3 eye; vec2 data;                    // this will be saved into first two pixels\n    Ray ray = Camera(fragCoord, eye, data); // Generate ray from pixel\n    \n    TraceResult result = raycast(ray);      // Raycast\n    \n    if(ray.tmax<=result.t)\n        fragColor = missColor(ray);    \n    else\n    {\n        vec3 lightPos1 = vec3(15.*cos(iTime),40.,15.*sin(iTime));\n        //vec3 lightPos1 = vec3(20, -50, 50);\n        vec3 lightPos2 = vec3(-20., 100., 0.);\n        \n        fragColor = recursive(ray, result, lightPos1);\n        fragColor += recursive(ray, result, lightPos2);\n        }\n\n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = 0.7*prev + 0.3*fragColor;   // Motion blur\n    fragColor.w = result.t;\n\n    // First two pixels are reserved\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixel (0,0)\n        fragColor.yzw = eye-EyeStartPosition;\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor.zw = data;\n}","name":"Buffer A","description":"","type":"buffer"}]}