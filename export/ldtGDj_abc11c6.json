{"ver":"0.1","info":{"id":"ldtGDj","date":"1452443030","viewed":523,"name":"shady snake","username":"Raxvan","description":"Nokia 3410, such phone, much awesome. Press ARROW KEYS to start and change direction, and SPACE to reset the game. KEY Q and W to increase/decrease speed","likes":19,"published":1,"flags":48,"usePreview":0,"tags":["game"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"//I took some ideas from IQ'q briks game regarding storing/loading state variables ( https://www.shadertoy.com/view/MddGzf )\n//The hardest part was to figure out how to place the apple in a random position\n//without having to iterate the grid. It is done using an index assigned to each empty position and\n//keeping the indices consistent in the grid by moving the indices from of the head cell to the tail cell on each step.\n\n//#define DEBUG_DATA\n//#define DEBUG_SNAKE\n//#define DEBUG_PUK\n\n//defines the grid play size\n#define GAME_GRID_SIZE  vec2(20.0,11.0) /*needs to be the same in Image shader*/\n\n#define HIGH_QUALITY /*game pixels with gaps*/\n#define USE_IDLE_ARROWS\n\n////////////////////////////////////////////////////////////////////////////////////////////////\n//visual\n\n#define PIXEL_GRID_SIZE vec2(GAME_GRID_SIZE.x * 4.0 + 2.0,GAME_GRID_SIZE.y * 4.0 + 10.0) \n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nvec4 read( in vec2 p )\n{\n    return texture( iChannel0, (0.5+p) / iChannelResolution[0].xy, -256.0 );\n}\n\nconst vec2  dataPos = vec2(0.0,GAME_GRID_SIZE.y);\n#ifdef HIGH_QUALITY\n    #define UNLIT_VALUE 0.35\n#else\n    #define UNLIT_VALUE 0.13\n#endif\n\nvec3 gamePixel(in vec2 g) //23 / 14\n{\n    vec2 p = g;\n    p.x = p.x > GAME_GRID_SIZE.x - 0.5 ? 0.0 : p.x;\n    p.y = p.y > GAME_GRID_SIZE.y - 0.5 ? 0.0 : p.y;\n    p.x = p.x < -0.5 ? GAME_GRID_SIZE.x - 1.0 : p.x;\n    p.y = p.y < -0.5 ? GAME_GRID_SIZE.y - 1.0 : p.y;\n    return read(p).xyz;\n}\n\nfloat statsPixels(in vec2 pixel_pos)\n{\n    if(abs(pixel_pos.y - PIXEL_GRID_SIZE.y + 7.0) < 0.5)\n        return 1.0;\n    \n    float digit_index = floor(pixel_pos.x / 4.0);\n    if(digit_index > 3.5)\n        return UNLIT_VALUE;\n    \n    float full_number = read(dataPos + vec2(1.0,0.0)).x;\n    \n    //number printing starts here:\n    float active_power = pow(10.0,3.0 - digit_index);\n    float active_digit = floor(full_number / active_power - floor(full_number / (active_power * 10.0)) * 10.0);\n    \n    float y = PIXEL_GRID_SIZE.y - pixel_pos.y - 1.0;//[0..5) \n    float x = pixel_pos.x - digit_index * 4.0;//[n..n + 3), where n is selected based on active digit\n\n    float l0 = y < 0.5 ? 1.0 : 0.0;\n    float l1 = y < 1.5 ? 1.0 - l0 : 0.0;\n    float l2 = y < 2.5 ? 1.0 - l1 - l0 : 0.0;\n    float l3 = y < 3.5 ? 1.0 - l2 - l1 - l0: 0.0;\n    float l4 = y < 4.5 ? 1.0 - l3 - l2 - l1 - l0: 0.0;\n    float lmask = l0 + l1 + l2 +l3 + l4;\n    \n    float c0 = x < 0.5 ? 1.0 : 0.0;\n    float c1 = x < 1.5 ? 1.0 - c0 : 0.0;\n    float c2 = x < 2.5 ? 1.0 - c1 - c0: 0.0;\n    float cmask = c0 + c1 + c2;\n    \n    float result = 0.0;\n    \n    if(active_digit < 0.5) //0\n        result = (c0 + c2 + l0 + l4);\n    else if(active_digit < 1.5) //1\n        result = max(c1,l4) + c0 * l1;\n    else if(active_digit < 2.5) //2\n        result = 1.0 - min((c0 + c1) * l1 + (c1 + c2) * l3,1.0);\n    else if(active_digit < 3.5) //3\n        result = 1.0 - min((c0 + c1) * (l1 + l3),1.0);\n    else if(active_digit < 4.5) //4\n        result = l2 + (l1 + l0) * c0 + (1.0 - l0) * c2;\n    else if(active_digit < 5.5) //5\n        result = 1.0 - min((c1 + c2) * l1 + (c0 + c1) * l3,1.0);\n    else if(active_digit < 6.5) //6\n        result = 1.0 - min(c1 * l3 + l1 * (1.0 - c0 * l1),1.0);\n    else if(active_digit < 7.5) //7\n        result = l0 + l1 * c2 + c1 * (l2 + l3 + l4);\n    else if(active_digit < 8.5) //8\n        result = 1.0 - c1 * (l1 + l3);\n    else if(active_digit < 9.5) //9\n        result = 1.0 - c1 * (l1 + l3) - c0 * l3;\n        \n    return mix(UNLIT_VALUE,1.0,clamp(result,0.0,1.0) * cmask * lmask);\n}\n\nfloat idleArrow(in vec2 pixel_pos, float inv)\n{\n    if(pixel_pos.x < -0.5 || pixel_pos.y < -0.5)\n        return 0.0;\n    if(pixel_pos.x > 8.5 || pixel_pos.y > 8.5)\n        return 0.0;\n    \n    float x = pixel_pos.x;\n    float y = pixel_pos.y;\n    \n    float l0 = y < 0.5 ? 1.0 : 0.0;\n    float ln = y > 7.5 ? 1.0 : 0.0;\n    \n    float c0 = x < 0.5 ? 1.0 : 0.0;\n    float cn = x > 7.5 ? 1.0 : 0.0;\n    \n    float border = max(c0,cn) + max(l0,ln);\n    \n    float cl = x < 4.5 ? 1.0 : 0.0;\n    float cr = x > 3.5 ? 1.0 : 0.0;\n    float cm = cl * cr;\n    \n    float fx = x;\n    if((cr - cm) > 0.5)\n        fx = 8.0 - x;\n    \n    float cx1 = fx < 1.5 ? 1.0 : 0.0;\n    float cx2 = fx < 2.5 ? 1.0 - cx1 : 0.0;\n    float cx3 = fx < 3.5 ? 1.0 - cx2 - cx1 : 0.0;\n    float result = 0.0;\n    \n    float lx = y > 6.5? 1.0 : 0.0;\n    float lx0 = y > 5.5? 1.0 - lx : 0.0;\n    float lx1 = y > 4.5? 1.0 - lx0 - lx : 0.0;\n    float lx2 = y > 3.5? 1.0 - lx1 - lx0 - lx : 0.0;\n    float lx3 = y > 2.5? 1.0 - lx2 - lx1 - lx0 - lx : 0.0;\n    \n    result += cm * (lx0 + lx1);\n    result += cx3 * (lx1 + lx2);\n    result += cx2 * (lx2 + lx3);\n    \n    result = min(border + result,1.0);\n    return mix(result,1.0 - result,inv);\n}\n\nfloat idleStatePixels(in vec2 pixel_pos)\n{\n    #ifdef USE_IDLE_ARROWS\n        vec2 final_pos = pixel_pos;\n\n        final_pos.x -= PIXEL_GRID_SIZE.x / 2.0 - 5.0;\n        final_pos.y -= PIXEL_GRID_SIZE.y / 2.0 - 3.0;\n\n        float seed = 1.0;\n        if(final_pos.y < -0.5)//down\n        {\n            seed = 1.5;\n            final_pos.y = -final_pos.y - 2.0;//down arrow\n\n            if(final_pos.x > 9.5)\n            {\n                final_pos.x -= 10.0;\n                final_pos.xy = final_pos.yx;\n                seed = 2.0;\n            }\n            if(final_pos.x < -0.5)\n            {\n                final_pos.x = -final_pos.x - 2.0;\n                final_pos.xy = final_pos.yx;\n                seed = 2.5;\n            }\n        }\n\n        float bleep = pow(sin((seed + 1.0) * iTime) * 0.5 + 0.5,32.0);\n        float a0 = idleArrow(final_pos,bleep);\n\n\n        return mix(UNLIT_VALUE,1.0,min(a0,1.0));\n    #else\n        return UNLIT_VALUE;\n    #endif\n}\nfloat identify_segment(in vec2 pos,in float segment_number)\n{\n    vec2 n = gamePixel(pos).xy;\n    return clamp((n.x > 0.5 && n.y < 0.5 ? -abs(segment_number - n.x) + 2.0 : 0.0),0.0,1.0);\n}\n\nfloat pixelColor(in vec2 pixelPos)//0 to 94x65\n{\n    //pixels outside of the grid:\n    if(min(pixelPos.x,pixelPos.y) < 0.0)\n        return 0.0;\n    if(pixelPos.x > PIXEL_GRID_SIZE.x - 0.5)\n        return 0.0;\n    if(pixelPos.y > PIXEL_GRID_SIZE.y - 0.5)\n        return 0.0;\n    \n    float border = 0.0;\n    \n    if(pixelPos.y > (PIXEL_GRID_SIZE.y - 9.0))\n        return statsPixels(pixelPos);\n    \n    border += abs(pixelPos.x) < 0.5 ? 1.0: 0.0;\n    border += abs(pixelPos.y) < 0.5 ? 1.0: 0.0;\n    border += abs(pixelPos.x - PIXEL_GRID_SIZE.x + 1.0) < 0.5 ? 1.0: 0.0;\n    border += abs(pixelPos.y - PIXEL_GRID_SIZE.y + 9.0) < 0.5 ? 1.0: 0.0;\n    \n    if(border > 0.5)\n        return 1.0;\n    \n    //read game state:\n    float game_state = read(dataPos).x;\n    float score = read(dataPos + vec2(1.0,0.0)).x;\n    \n    float game_pixel_intensity = 1.0;\n    if(game_state > 5.0)\n    {\n        //game over\n        float timer = iTime * 0.7;\n        timer = timer - floor(timer);\n        game_pixel_intensity = timer < 0.5 ? 1.0 : 0.0;\n    }\n    else if(game_state < 1.0)\n    {\n        return idleStatePixels(pixelPos);\n    }\n    \n    //read game grid:\n    vec2 game_pixel = floor((pixelPos - 1.0) / 4.0);\n    vec2 local_pixel = (pixelPos - 1.0) - game_pixel * 4.0;\n    \n    float cx = local_pixel.x > 0.5 && local_pixel.x < 2.5 ? 1.0 : 0.0;\n    float cy = local_pixel.y > 0.5 && local_pixel.y < 2.5 ? 1.0 : 0.0;\n    float center = cx * cy;\n    float box = 1.0 - center;\n    \n    vec3 px = gamePixel(game_pixel);\n    \n    float star = box * max(cx,cy);\n    if(px.y > 0.5)\n    {\n        //apple\n        #ifdef DEBUG_PUK\n            game_pixel_intensity = 1.0;\n        #else\n            game_pixel_intensity = star;\n        #endif\n    }\n    else if(px.x > 0.5)\n    {\n        #ifdef DEBUG_SNAKE\n        game_pixel_intensity = 1.0;\n        #else\n        //snake segment\n        game_pixel_intensity = game_pixel_intensity;\n        \n        float l = (identify_segment(game_pixel - vec2(1.0,0.0),px.x));\n        float r = (identify_segment(game_pixel + vec2(1.0,0.0),px.x));\n        float u = (identify_segment(game_pixel + vec2(0.0,1.0),px.x));\n        float d = (identify_segment(game_pixel - vec2(0.0,1.0),px.x));\n        \n        float lh = (local_pixel.x < 1.5 ? 1.0 : 0.0);\n        float rh = (local_pixel.x > 1.5 ? 1.0 : 0.0);\n        float uh = (local_pixel.y > 1.5 ? 1.0 : 0.0);\n        float dh = (local_pixel.y < 1.5 ? 1.0 : 0.0);\n        \n        float p0 = ((uh * lh) + (rh * dh));\n        float p1 = 1.0 - p0;\n        \n        float p = mix(p0,p1,max(l,r));\n        \n        float segment = center * mix(p,1.0 - p,min(max(l,u),max(r,d)));\n        segment += l * cy * lh * box;\n        segment += r * cy * rh * box;\n        segment += u * cx * uh * box;\n        segment += d * cx * dh * box;\n        segment = min(segment,1.0);\n        \n        float tail = (px.x < 1.5 ? 1.0 : 0.0);\n        float ptail = 0.0;\n        \n        ptail += max(max(rh,dh) * center,rh * star) * r * cy;\n        ptail += max(max(lh,uh) * center,lh * star) * l * cy;\n        ptail += max(max(uh,rh) * center,uh * star) * u * cx;\n        ptail += max(max(dh,lh) * center,dh * star) * d * cx;\n        ptail = min(ptail,1.0) * tail;\n        \n        float head = (l + r + u + d) < 1.5 && px.x > 2.5 ? 1.0 : 0.0;\n        float phead = 0.0;\n        \n        phead += max(cy * (1.0 - lh * center * uh),lh * star * uh) * l;\n        phead += max(cy * (1.0 - rh * center * uh),rh * star * uh) * r;\n        phead += max(cx * (1.0 - lh * center * dh),lh * star * dh) * d;\n        phead += max(cx * (1.0 - rh * center * uh),rh * star * uh) * u;\n        phead = min(phead,1.0);\n        \n        float papple = px.z > 0.5 ? max(star,segment * center) : 0.0;\n        \n        game_pixel_intensity *= max(max(mix(segment,phead,head),ptail) , papple);\n        #endif\n    }\n    else\n    {\n        game_pixel_intensity = 0.0;\n    }\n    return mix(UNLIT_VALUE,1.0,clamp(game_pixel_intensity,0.0,1.0));\n}\n\nfloat map(in vec2 screen_pos)\n{\n    vec2 px = (screen_pos - (iResolution.xy - PIXEL_GRID_SIZE * 6.0) * 0.5) / 6.0;\n    vec2 fpx = floor(px);\n    vec2 p = (px - fpx) * 6.0;\n    \n    float value = pixelColor(fpx);\n    #ifdef HIGH_QUALITY\n        float lvalue = pixelColor( fpx + vec2(1.0,0.0) );\n        float rvalue = pixelColor( fpx + vec2(0.0,1.0) );\n    \n        float x = p.x < 5.0 ? value : lvalue * 0.6;\n        float y = p.y < 5.0 ? value : rvalue * 0.6;\n    \n        return clamp(x * y,0.0,1.0);\n    #else\n        return value;\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    vec3 final_color = vec3(0.0);\n    vec2 c2 = vec2(0.0);\n    float c = 0.0;\n    \n    vec2 uv = pos.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //background\n    vec3 bkcolor = vec3(162.0,205.0,10.0) / 256.0;\n    vec3 pixelColor = vec3(55.0,75.0,16.0) * 0.9 / 256.0;\n    float noise = texture(iChannel2,uv).x;\n    \n    bkcolor *= texture(iChannel1,uv * 5.0).rgb * 0.1 + 0.95;\n    \n    final_color = mix(bkcolor,pixelColor,clamp(map(pos) + noise * 0.2,0.0,1.0));\n    \n    fragColor = vec4(final_color,1.0);\n#ifdef DEBUG_DATA\n    vec2 debug_uv = pos.xy / iResolution.xy;\n    fragColor = texture(iChannel0,debug_uv / 20.0);\n    fragColor.b = vec3(fragColor.w / (GAME_GRID_SIZE.x * GAME_GRID_SIZE.y)).x;\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MIN_SPEED 2.0\n#define MAX_SPEED 0.02\n#define DEFAULT_GAME_SPEED 0.20\n\n//defines the grid play size\n#define GAME_GRID_SIZE  vec2(20.0,11.0) /*needs to be the same in Image shader*/\n\n//#define DEBUG_SLOT_SELECTION\n\n////////////////////////////////////////////////////////////////////////////////////////////////\nfloat isTexel( vec2 coord, vec2 pos ) { vec2 d = abs(coord - pos - 0.5); return 0.5 - max(d.x,d.y); }\nvec4 get( in vec2 position )\n{\n    vec2 uv = (position + 0.5) / iChannelResolution[0].xy;\n    return texture( iChannel0, uv, -256.0 );\n}\nvec4 read( inout vec2 position )\n{\n    vec4 res = get(position);\n    position += vec2(1.0,0.0);\n    return res;\n}\nvoid write( in vec4 value, inout vec2 position, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isTexel(fragCoord,position ) > 0.0 ) ? value : fragColor;\n    position += vec2(1.0,0.0);\n}\nfloat isPressed(float key)\n{\n    float pressed = texture( iChannel1, vec2((key + 0.5) / 256.0,0.25) ).x;\n    return pressed;// > 0.0 if is pressed\n}\n////////////////////////////////////////////////////////////////////////////////////////////////\n\n\nconst float KEY_LEFT  = 37.0;\nconst float KEY_UP    = 38.0;\nconst float KEY_RIGHT = 39.0;\nconst float KEY_DOWN  = 40.0;\nconst float KEY_SPACE = 32.0;\nconst float KEY_Q     = 81.0;\nconst float KEY_W     = 87.0;\n\nconst vec2  dataPos = vec2(0.0,GAME_GRID_SIZE.y);\nconst float defaultLength = 3.0;\n\nstruct game_state\n{\n    vec4    grid_data;\n    \n    float   active_state;//current state of the game:0 idle start;1 playing;10 lost\n    float   score;\n    float   time;\n    float   game_speed;\n    float   snake_max_length;\n    float   snake_segment_count;\n    \n    vec2    head_direction;\n    vec2    last_direction;\n    vec2    head_position;\n    \n    float   random_slot;\n};\n////////////////////////////////////////////////////////////////////////////////////////////////\nvoid ReadState(inout game_state s)\n{\n    vec2 p = dataPos;\n    \n    s.active_state = read(p).x;\n    s.score = read(p).x;\n    s.time = read(p).x;\n    s.game_speed = read(p).x;\n    s.snake_max_length = read(p).x;\n    s.snake_segment_count = read(p).x;\n    \n    s.head_direction = read(p).xy;\n    s.last_direction = read(p).xy;\n    s.head_position = read(p).xy;\n    \n    s.random_slot = read(p).x;\n}\n\nvoid WriteState(in game_state s,in vec2 fragCoord,out vec4 fragColor)\n{\n    if(fragCoord.x < GAME_GRID_SIZE.x && fragCoord.y < GAME_GRID_SIZE.y)\n    {\n        //grid\n        fragColor = s.grid_data;\n    }\n    else\n    {\n        vec2 p = dataPos;\n        write(vec4(s.active_state,0.0,0.0,0.0), p, fragColor,fragCoord);\n        write(vec4(s.score,0.0,0.0,0.0), p, fragColor,fragCoord);\n        write(vec4(s.time,0.0,0.0,0.0), p, fragColor,fragCoord);\n        write(vec4(s.game_speed,0.0,0.0,0.0), p, fragColor,fragCoord);\n        write(vec4(s.snake_max_length,0.0,0.0,0.0), p, fragColor,fragCoord);\n        write(vec4(s.snake_segment_count,0.0,0.0,0.0), p, fragColor,fragCoord);\n\n        write(vec4(s.head_direction,0.0,0.0), p, fragColor,fragCoord);\n        write(vec4(s.last_direction,0.0,0.0), p, fragColor,fragCoord);\n        write(vec4(s.head_position,0.0,0.0), p, fragColor,fragCoord);\n        write(vec4(s.random_slot,0.0,0.0,0.0), p, fragColor,fragCoord);\n        \n    }\n}\nfloat init_grid_index(vec2 head,vec2 grid_position)\n{\n    float hp = GAME_GRID_SIZE.x * head.y + head.x;\n    float gp = GAME_GRID_SIZE.x * grid_position.y + grid_position.x;\n    return gp > hp ? gp - 1.0 : gp;\n}\nfloat my_fmod(float x,float y)\n{\n    return x - y * floor(x/y);\n}\ngame_state Update(in game_state s,in vec2 fragCoord)\n{\n    float now_time = iTime;\n    \n    if(isPressed(KEY_SPACE) > 0.0 || iFrame < 10)\n    {   \n        //reset game\n        s.active_state = 0.0;\n        s.score = 0.0;\n        s.game_speed = DEFAULT_GAME_SPEED;\n        s.time = now_time - s.game_speed * 2.0;//force next frame to be a logic frame\n        s.snake_max_length = defaultLength;\n        s.snake_segment_count = 1.0;//only one is visible at the start\n        \n        s.head_direction = vec2(0.0);\n        s.last_direction = vec2(0.0);\n        s.head_position = floor(GAME_GRID_SIZE / 2.0);\n        \n        float max_empty_slots = (GAME_GRID_SIZE.x * GAME_GRID_SIZE.y) - s.snake_segment_count;\n        s.random_slot = my_fmod(cos(iTime) * 20.0 + 25.0,max_empty_slots);\n        \n        float i = init_grid_index(s.head_position,floor(fragCoord));\n        if(isTexel(fragCoord,s.head_position) > 0.0)\n            s.grid_data = vec4(defaultLength,0.0,0.0,0.0);//write head\n        else\n            s.grid_data = vec4(vec3(0.0),i);//clear grid\n        \n        return s;        \n    }\n    float a = s.active_state;\n    float delta = now_time - s.time;\n    if(isPressed(KEY_RIGHT) > 0.0 && s.active_state < 5.0 && s.last_direction.x > -0.5)\n    {\n        s.active_state = 1.0;\n        s.head_direction = vec2(1.0,0.0) ;\n    }\n    if(isPressed(KEY_LEFT) > 0.0 && s.active_state < 5.0 && s.last_direction.x < 0.5)\n    {\n        s.active_state = 1.0;\n        s.head_direction = -vec2(1.0,0.0) ;\n    }\n    if(isPressed(KEY_UP) > 0.0 && s.active_state < 5.0 && s.last_direction.y > -0.5 )\n    {\n        s.active_state = 1.0;\n        s.head_direction = vec2(0.0,1.0) ;\n    }\n    if(isPressed(KEY_DOWN) > 0.0 && s.active_state < 5.0 && s.last_direction.y < 0.5)\n    {\n        s.active_state = 1.0;\n        s.head_direction = -vec2(0.0,1.0) ;\n    }\n    float speed_change = 0.0;\n    speed_change += (isPressed(KEY_Q) > 0.0) ? 1.0 : 0.0;\n    speed_change += (isPressed(KEY_W) > 0.0) ? -1.0 : 0.0;\n    \n    float first_move = abs(s.active_state - a);\n    \n    vec2 new_head_position;\n    if(s.active_state > 0.1 && s.active_state < 5.0)\n    {\n        //gameplay is running:\n        \n        if(delta > s.game_speed)\n        {\n            //fixed update:\n            \n            s.game_speed = clamp(s.game_speed + speed_change * 0.02,MAX_SPEED,MIN_SPEED);\n            s.time = now_time;\n            new_head_position = s.head_position + s.head_direction;\n            s.last_direction = s.head_direction;\n\n            //wrap arround the grid            \n            if(new_head_position.x > GAME_GRID_SIZE.x - 0.5)\n                new_head_position.x = 0.0;\n            if(new_head_position.y > GAME_GRID_SIZE.y - 0.5)\n                new_head_position.y = 0.0;\n\n            if(new_head_position.x < -0.5)\n                new_head_position.x = GAME_GRID_SIZE.x - 1.0;\n            if(new_head_position.y < -0.5)\n                new_head_position.y = GAME_GRID_SIZE.y - 1.0;\n\n            vec4 head_data = get(new_head_position);\n            vec2 old_head_position = s.head_position;\n\n            float snake_operation = -1.0;\n            float hit_apple = 0.0;\n\n            //check collisions:\n            if(head_data.x > 1.5 && head_data.y < 0.5)\n            {\n                //collision with self:\n                s.active_state = 10.0;\n                return s;\n            }\n            else if(head_data.y > 0.5)\n            {\n                //collision with apple:\n                s.snake_max_length += 1.0;\n                //s.head_position = new_head_position;\n                s.score += 1.0;\n                \n                snake_operation = 0.0;\n                hit_apple = 1.0;\n            }\n\n            s.head_position = new_head_position;\n            \n            //grid:\n            vec4 local_data = s.grid_data;\n            \n            float index_decrement = 0.0;\n            //grow snake size to maximum:\n            if(s.snake_segment_count < (s.snake_max_length - 0.5))\n            {\n                //in this step we grow the snake with one segment.\n                s.snake_segment_count = min(s.snake_segment_count + 1.0,s.snake_max_length);\n                \n                if(local_data.w > (head_data.w - 0.5))\n                {\n                    local_data.w -= 1.0;\n                    index_decrement = 1.0;\n                }\n            }\n\n            //grid objects:\n            if(isTexel(fragCoord,s.head_position) > 0.0)\n            {\n                //we are in grid with new head position\n                local_data = vec4(s.snake_max_length,0.0,local_data.y,0.0);//write head\n            }\n            else\n            {\n                if(local_data.x > 0.5)\n                {\n                    //game object:\n                    if(local_data.y < 0.5)\n                    {\n                        //snake segment:\n                        local_data.x += snake_operation;\n                        if(local_data.x < 0.5)\n                        {\n                            //tail segment\n                            local_data = vec4(vec3(0.0),head_data.w - index_decrement);//keep the index alive\n                        }\n                    }\n                    else\n                    {\n                        //apple:\n                    }\n                }\n            }\n            \n            //check empty slots for next random item\n            if(dot(local_data.xyz,vec3(1.0)) < 0.5)\n            {\n                if(hit_apple > 0.0 || first_move > 0.0)\n                {\n                    \n                    #ifdef DEBUG_SLOT_SELECTION\n                        float slot = 0.0;\n                    #else\n                        float slot = max(s.random_slot - 1.0,0.0);\n                    #endif \n                    \n                    if(abs(slot - local_data.w) < 0.5)\n                    {\n                        //make this slot the apple\n                        local_data.xy = vec2(0.0,1.0);\n                    } \n                    \n                }\n            }\n\n            s.grid_data = local_data;\n        }\n        else\n        {\n            float max_empty_slots = (GAME_GRID_SIZE.x * GAME_GRID_SIZE.y) - s.snake_segment_count;\n            \n            s.random_slot = s.random_slot + 1.0;\n            if((max_empty_slots - 0.5) < s.random_slot)\n                s.random_slot = 0.0;\n        }\n        \n    }\n    \n    return s;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.y > (dataPos.y + 1.0))\n        discard;\n    \n    fragColor = texture(iChannel0,fragCoord/iChannelResolution[0].xy);\n    game_state s;\n    s.grid_data = fragColor;\n    ReadState(s);\n    s = Update(s,fragCoord);\n\n    WriteState(s, fragCoord, fragColor);\n}","name":"Buf A","description":"","type":"buffer"}]}