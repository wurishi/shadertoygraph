{"ver":"0.1","info":{"id":"lt2SDd","date":"1447520555","viewed":240,"name":"Mines","username":"gaz","description":"3d","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","de","fold","sparsegrid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define PI  3.14159265359\n\nmat2 rotate(float a)\n{\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nfloat hash(in vec3 p)\n{\n    p  = fract(p * vec3(.16532,.17369,.15787));\n    p += dot(p.xyz, p.yzx + 19.19);\n    return fract(p.x * p.y * p.z);\n}\n\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b)\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba * h);\n}\n\n// 3D Folding (https://www.shadertoy.com/view/XlX3zB)\nvec3 fold(vec3 pos, float type) \n{\n    float cospin = cos(PI / type);\n    float scospin = sqrt(0.75 - cospin * cospin);\n    vec3 nc = vec3(-0.5, -cospin, scospin);\n    for(int i = 0;i < 5; i++)\n    {\n        pos.xy=abs(pos.xy);\n        pos-=2.0 * min(0.0, dot(pos, nc)) * nc;\n    }\n    return pos;\n}\n\nfloat map(in vec3 p)\n{   \n    p.yz *= rotate(iTime * 0.1);\n    p.zx *= rotate(iTime * 0.2);\n    vec3 q = p;\n    // Sparse grid (https://www.shadertoy.com/view/XlfGDs)\n    float c = 0.4;\n    vec3 ip  = floor(p / c);\n    p  = mod(p,c) - c / 2.0;\n    float rnd  = hash(ip);\n    float size = hash(ip + vec3(123.123)) * 0.05 + 0.1;  \n    float d2D;\n    float d3D = 0.3;\n    if (length(floor(abs(q)/c)) < 5.0) \n    if (rnd < 0.3)\n    {       \n        p.xy *= rotate(iTime * 5.0 * (hash(ip + vec3(456.456)) - 0.5));\n        p.yz *= rotate(iTime * 5.0 * (hash(ip + vec3(789.789)) - 0.5));\n        p = fold(p, 5.0);\n        if (rnd < 0.1) {\n\t        d2D = abs(abs(p.x) + abs(p.y) - 0.05);            \n        } else  if (rnd < 0.2) {\n\t        d2D =  length(normalize(p.xy) * 0.03 - p.xy);            \n        } else  {\n\t        d2D =   min(sdSegment(p.xy, vec2(0.5, 0.5), vec2(-0.5, -0.5)),\n                        sdSegment(p.xy, vec2(-0.5, 0.5), vec2(0.5, -0.5)));\n        }\n        p.z += -0.01 * smoothstep(0.01, 0.0, d2D);\n        d3D = min(d3D, length(p) - size);\n    }  \n    return 0.3 * d3D;\n    }\nvec3 calcNormal( in vec3 pos )\n    \n{\n    vec2 e = vec2(1.0, -1.0) * 0.002;\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\nfloat intersect(in vec3 ro, in vec3 rd)\n{\n    const float maxd = 10.0;\n    const float precis = 0.001;\n    float h = 1.0;\n    float t = 0.0;\n    for(int i = 0; i < 256; i++)\n    {\n        if(h < precis || t > maxd) break;\n        h = map(ro + rd * t);\n        t += h;\n    }\n    if( t > maxd ) t = -1.0;\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 col = vec3(length(p) * 0.1);\n    col.b += 0.15;\n    vec3 ro = vec3(0.0, 0.0, 3.5);\n    vec3 rd = normalize(vec3(p, -1.8));\n    float t = intersect(ro, rd);\n    if(t > -0.001)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n\t\tvec3 li = normalize(vec3(0.7, 1.0, 5.0));\n    \tcol = vec3(0.3,0.7,0.5);\n        col *= max(dot(li, nor), 0.2);\n        col += pow(max(dot(vec3(0.0, 0.0,1.0), reflect(-li, nor)), 0.0), 30.0);\n        col = pow(col, vec3(0.6)); \n    }\n    fragColor = vec4(col, 1.0);\n}\n","name":"","description":"","type":"image"}]}