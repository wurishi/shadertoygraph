{"ver":"0.1","info":{"id":"fdVfzD","date":"1657947275","viewed":305,"name":"Rotating Card","username":"chickenlegs","description":"A rotating 3D plane that is rendered by casting a ray from the camera to behind the plane, finding the point of intersection, and then projecting the point back to the screen.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","raycast","plane"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Check out these:\n    https://www.youtube.com/c/patrickjmt\n    https://www.youtube.com/c/ProfessorLeonard\n*/\n\n\n#define PI 3.1415926538\n\n#define PI 3.1415926538\n\n//// Comparison functions\nfloat gt(float v1, float v2)\n{\n    return step(v2,v1);\n}\n\nfloat lt(float v1, float v2)\n{\n    return step(v1, v2);\n}\n\nfloat between(float val, float start, float end)\n{\n    return gt(val,start)*lt(val,end);\n}\n\nfloat eq(float v1, float v2, float e)\n{\n    return between(v1, v2-e, v2+e);\n}\n\nfloat s_gt(float v1, float v2, float e)\n{\n    return smoothstep(v2-e, v2+e, v1);\n}\n\nfloat s_lt(float v1, float v2, float e)\n{\n    return smoothstep(v1-e, v1+e, v2);\n}\n\nfloat s_between(float val, float start, float end, float epsilon)\n{\n    return s_gt(val,start,epsilon)*s_lt(val,end,epsilon);\n}\n\nfloat s_eq(float v1, float v2, float e, float s_e)\n{\n    return s_between(v1, v2-e, v2+e, s_e);\n}\n\n//// Coloring functions\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from IÃ±igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n\n//// Shapes functions\nfloat circle_df(vec2 xy, vec2 pos)\n{\n    float d = distance(xy, pos);\n    //float d = dot(xy-pos, xy-pos)*2.; // Cheaper distance function but will require more epsilon if using with smoothstep\n    return d;\n}\n\nfloat circle(vec2 xy, vec2 pos, float r)\n{\n    float d = circle_df(xy, pos);\n    return lt(d, r);\n}\n\nfloat s_circle(vec2 xy, vec2 pos, float r, float e)\n{\n    float d = circle_df(xy, pos);\n    return s_lt(d, r, e);\n}\n\nfloat square_df(vec2 xy, vec2 pos, float l)\n{\n    vec2 v = abs(xy-pos)-l;\n    float d = length(max(v, 0.));\n    return d;\n}\n\nfloat square(vec2 xy, vec2 pos, float l, float roundness) // roundness == 0 means no roundess, roundness == 1 means full roundess\n{\n    float r = clamp(roundness, 0., 1.)*l;\n    float d = square_df(xy, pos, l-r);\n    return lt(d, r);\n}\n\nfloat s_square(vec2 xy, vec2 pos, float l, float roundness, float e) // roundness == 0 means no roundess, roundness == 1 means full roundess\n{\n    float r = clamp(roundness, 0., 1.)*l;\n    float d = square_df(xy, pos, l-r);\n    return clamp(s_lt(d, r, e*2.)*2., 0., 1.);\n}\n\nfloat rectangle_df(vec2 p, float w, float h)\n{\n    vec2 b = vec2(w, h);\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat rectangle(vec2 xy, vec2 pos, float w, float h, float roundness) // roundness == 0 means no roundess, roundness == 1 means full roundess\n{\n    h = h/2.;\n    w = w/2.;\n    float r = clamp(roundness, 0., 1.)*w;\n    float d = rectangle_df(xy-pos, w-r, h-r);\n    return lt(d, r);\n}\n\nfloat s_rectangle(vec2 xy, vec2 pos, float w, float h, float roundness, float e) // roundness == 0 means no roundess, roundness == 1 means full roundess\n{\n    h = h/2.;\n    w = w/2.;\n    float r = clamp(roundness, 0., 1.)*w;\n    float d = rectangle_df(xy-pos, w-r, h-r);\n    return s_lt(d, r, e);\n}\n\nfloat triangle_df(vec2 xy, vec2 pos, float l)\n{\n    vec2 p = (xy-pos)/l;\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat triangle(vec2 xy, vec2 pos, float l, float roundness) // roundness == 0 means no roundess, roundness == 1 means full roundess\n{\n    float r = clamp(roundness, 0., 1.)*l;\n    float d = triangle_df(xy, pos, l);\n    return lt(d, r);\n}\n\nfloat s_triangle(vec2 xy, vec2 pos, float l, float roundness, float e) // roundness == 0 means no roundess, roundness == 1 means full roundess\n{\n    float r = clamp(roundness, 0., 1.)*l;\n    float d = triangle_df(xy, pos, l);\n    return clamp(s_lt(d, r, e*2.)*2., 0., 1.);\n}\n\n//// Rotation function\nvec2 rotate(vec2 vec, float a)\n{\n    return vec2(vec.x*cos(a)-vec.y*sin(a), vec.x*sin(a)+vec.y*cos(a));\n}\n\n\n//// Line function\nvec2 lerp(vec2 p1, vec2 p2, float t)\n{\n    vec2 u = p2-p1;\n    return t*u+p1;\n}\n\nfloat line(vec2 xy, vec2 p1, vec2 p2, float w)\n{\n    xy -= lerp(p1, p2, 0.5);\n    float d = distance(p1, p2);\n    xy = rotate(xy, atan(p2.x-p1.x, p2.y-p1.y));\n\n    return rectangle(xy, vec2(0.), w, d, 1.);\n}\n\nfloat s_line(vec2 xy, vec2 p1, vec2 p2, float w, float e)\n{\n    xy -= lerp(p1, p2, 0.5);\n    float d = distance(p1, p2);\n    xy = rotate(xy, atan(p2.x-p1.x, p2.y-p1.y));\n\n    return s_rectangle(xy, vec2(0.), w, d, 1., e);\n}\n\n\nvec3 rotate(vec3 vec, float a, int axis) // 0 for x, 1 for y 2 for z\n{\n    mat3 rt;\n    switch (axis) {\n    case 0:\n        rt = mat3(1.,   0.  ,    0.  ,\n                  0., cos(a), -sin(a),\n                  0., sin(a),  cos(a));\n        break;\n    case 1:\n        rt = mat3(cos(a), 0., sin(a),\n                    0.,   1.,   0.  ,\n                  -sin(a), 0., cos(a));\n        break;\n    case 2:\n        rt = mat3(cos(a), -sin(a), 0.,\n                  sin(a),  cos(a), 0.,\n                    0.,      0.,   1.);\n        break;\n    }\n    return vec*rt;\n}\n\n\n\nvec2 projectPoint(vec3 p)\n{\n    vec3 ppc = vec3(0.,0., 1.);\n    vec3 n = vec3(0., 0., -1.);\n    \n    vec3 v = p-ppc;\n    float vp = dot(n, v);\n    \n    vec3 result = p-vp*n;\n    \n    return vec2(result.x, result.y);\n}\n\n\n// https://stackoverflow.com/questions/5666222/3d-line-plane-intersection\nvec3 intersect(vec3 p0, vec3 p1, vec3 p_co, vec3 p_no, float e)\n{\n    vec3 u = p1-p0;\n    float d = dot(p_no, u);\n\n    if (abs(d) > e)\n    {\n        vec3 w = p0-p_co;\n        float fac = -dot(p_no, w)/d;\n        u*=fac;\n        return p0+u;\n    }\n\n    return vec3(0.);\n}\n\nfloat getAngle(vec3 v1, vec3 v2)\n{\n    return acos(dot(v1,v2)/(length(v1)*length(v2)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float zoom = 20.;\n    \n    vec2 zoomCenter = vec2(0.);\n\n    float viewPortCenter = 0.5;\n    float ratio = iResolution.y/iResolution.x;\n    \n    vec2 xy = (uv - viewPortCenter) * zoom + zoomCenter;\n    xy = vec2(xy.x, xy.y*ratio);\n    \n    mouse.xy -= vec2(viewPortCenter);\n    mouse.y *= ratio;\n    \n\n    float pixel = 1. / iResolution.x;\n    vec3 col = vec3(0.);\n    \n    float x_r = cos(iTime/2.);\n    float y_r = iTime;\n    float z_r = sin(iTime);\n    \n    vec3 p = rotate(rotate(rotate(vec3(0.), x_r, 0), y_r, 1), z_r, 2);\n    vec3 n = normalize(rotate(rotate(rotate(vec3(0., 0., 1.), x_r, 0), y_r, 1), z_r, 2));\n    \n    vec3 y_axis = rotate(rotate(rotate(vec3(0., 1., 0.), x_r, 0), y_r, 1), z_r, 2);\n    vec3 x_axis = rotate(rotate(rotate(vec3(1., 0., 0.), x_r, 0), y_r, 1), z_r, 2);\n\n    \n    //vec3 l1 = vec3(xy.x, xy.y,1);\n    vec3 l1 = vec3(0.,0.,6); //perspective projection\n    vec3 l2 = vec3(xy.x, xy.y, -1);\n    \n    vec3 hit = intersect(l1, l2, p, n, 0.);\n    \n    float d = distance(hit, p);\n    \n    vec3 hit_p_v = hit-p;\n\n    float y = dot(hit_p_v, y_axis)/length(y_axis);\n    float x = dot(hit_p_v, x_axis)/length(x_axis);\n    vec2 hit_xy = vec2(x,y);\n\n    //vec2 pp = projectPoint(hit); // No need since we would know the x and y from the ray were hitting\n    vec2 pp = hit.xy;\n    \n    vec4 front = texture(iChannel0, hit_xy/3.)*gt(cos(getAngle(vec3(0,0,1),n)),0.);\n    vec4 back = texture(iChannel1, hit_xy/3.)*lt(cos(getAngle(vec3(0,0,1),n)),0.);\n    \n    col += front.rgb;\n    col += back.rgb;\n    \n    col *= s_rectangle(hit_xy, vec2(0), 3., 5., 0.5, pixel);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}