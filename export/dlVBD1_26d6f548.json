{"ver":"0.1","info":{"id":"dlVBD1","date":"1702047261","viewed":42,"name":"stars galaxy rotate","username":"nayk","description":"stars galaxy rotate","likes":1,"published":1,"flags":1,"usePreview":0,"tags":["rotate","galaxy","stars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*originals https://www.shadertoy.com/view/ml2BWt https://www.shadertoy.com/view/lslyRn*/\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000\n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n//get coords and direction\nvec3 dir=rd;\nvec3 from=ro;\n\n//volumetric rendering\nfloat s=0.1,fade=1.;\nvec3 v=vec3(0.);\nfor (int r=0; r<volsteps; r++) {\nvec3 p=from+s*dir*.5;\np = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\nfloat pa,a=pa=0.;\nfor (int i=0; i<iterations; i++) {\np=abs(p)/dot(p,p)-formuparam;\n            p.xy*=mat2(cos(iTime*0.005),sin(iTime*0.005),-sin(iTime*0.0050),cos(iTime*0.005));// the magic formula\na+=abs(length(p)-pa); // absolute sum of average change\npa=length(p);\n}\nfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\na*=a*a; // add contrast\nif (r>6) fade*=1.1; // dark matter, don't render near\n//v+=vec3(dm,dm*.5,0.);\nv+=fade;\nv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\nfade*=distfading; // distance fading\ns+=stepsize;\n}\nv=mix(vec3(length(v)),v,saturation); //color adjust\nfragColor = vec4(v*.03,1.);\n}\nconst float pi = 3.14159265359;\nconst float triangleScale = 0.816497161855865; // ratio of edge length and height\nconst vec3 orange = vec3(0.937, 0.435, 0.0);\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec4 getTriangleCoords(vec2 uv) {\n    uv.y /= triangleScale;\n    uv.x -= uv.y / 2.0;\n    vec2 center = floor(uv);\n    vec2 local = fract(uv);\n   \n    center.x += center.y / 2.0;\n    center.y *= triangleScale;\n   \n    if (local.x + local.y > 1.0) {\n    local.x -= 1.0 - local.y;\n        local.y = 1.0 - local.y;\n        center.y += 0.586;\n        center.x += 1.0;\n    } else {\n        center.y += 0.287;\n    center.x += 0.5;\n    }\n   \n    return vec4(center, local);\n}\n\nvec4 getLoader(vec4 triangle) {\n    if (length(triangle.xy) > 1.6) {\n        return vec4(0.0);\n    }\n   \n    float angle = atan(triangle.x, triangle.y);\n    float seed = rand(triangle.xy);\n    float dst = min(triangle.z, min(triangle.w, 1.0 - triangle.z - triangle.w)) * 15.0;\n    float glow = dst < pi ? pow(sin(dst), 1.5) : 0.0;\n   \n    return vec4(mix(orange, vec3(1.0), glow * 0.07), pow(0.5 + 0.5 * sin(angle - iTime * 6.0 + seed), 2.0));\n}\n\nfloat getBackground(vec4 triangle) {\n    float dst = min(triangle.z, min(triangle.w, 1.0 - triangle.z - triangle.w)) - 0.05;\n\n    if (triangle.y > 1.9 || triangle.y < -2.4 || dst < 0.0) {\n        return 0.0;\n    }\n\n    float value = pow(0.5 + 0.5 * cos(-abs(triangle.x) * 0.4 + rand(triangle.xy) * 2.0 + iTime * 4.0), 2.0) * 0.08;    \n    return value * (dst > 0.05 ? 0.65 : 1.0);\n}\n\nvec3 getColor(vec2 uv) {\n    uv *= 2.0 / iResolution.y;\n   \n    vec3 background = vec3(getBackground(getTriangleCoords(uv * 6.0 - vec2(0.5, 0.3))));\n  vec4 loader = getLoader(getTriangleCoords(uv * 11.0));\n   \n    vec3 color = mix(background, loader.rgb, loader.a);\n    return color;\n}\n#define S(a, b, t) smoothstep(a, b, t)\n\nfloat distLine(vec2 p, vec2 a, vec2 b){\nvec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba*t);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b){\nfloat d = distLine(p, a, b);\n    float m = S(0.03, 0.01, d);\n    float d2 =  length(a - b);\n    m *= S(1.2, 0.8, d2) * 0.5 + S(0.05, 0.03, abs(d2 - 0.75));\n    return m;\n}\n\nfloat distTriangle(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\nvec2 e0 = p1 - p0;\nvec2 e1 = p2 - p1;\nvec2 e2 = p0 - p2;\n\nvec2 v0 = p - p0;\nvec2 v1 = p - p1;\nvec2 v2 = p - p2;\n\nvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\nvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\nvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n   \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\nreturn -sqrt(d.x)*sign(d.y);\n}\n\nfloat triangle(vec2 p, vec2 a, vec2 b, vec2 c){\nfloat d = distTriangle(p, a, b, c);\n    float m = S(0.03, 0.01, d);\n    float d2 =  length(a - b);\n    m *= S(1.2, 0.8, d2) * 0.5 + S(0.05, 0.03, abs(d2 - 0.75));\n    return m;\n}\n\nfloat N21(vec2 p){\np = fract(p * vec2(233.34, 851.73));\n    p += dot(p, p + 23.45);\n    return fract(p.x * p.y);\n}\n\nvec2 N22(vec2 p){\nfloat n = N21(p);\n    return vec2(n, N21(p + n));\n}\n\nvec2 getPos(vec2 id, vec2 offset){\n    vec2 n = N22(id + offset) * iTime;\n    return offset + sin(n) * 0.4;\n}\nfloat bias(float t, float b) {\n    return (t / ((((1.0/b) - 2.0)*(1.0 - t))+1.0));\n}\n\n\nvec2 rotatePoint2d(vec2 uv, vec2 center, float angle)\n{\n    vec2 rotatedPoint = vec2(uv.x - center.x, uv.y - center.y);\n    float newX = cos(angle) * rotatedPoint.x - sin(angle) * rotatedPoint.y;\n    rotatedPoint.y = sin(angle) * rotatedPoint.x + cos(angle) * rotatedPoint.y;\n    rotatedPoint.x = newX;\n    return rotatedPoint;\n}\n\n\nvec3 rgb(float r, float g, float b)\n{\nreturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\nfloat computePeakyRadius(vec2 uv) {\n    float radius = 0.25 * iResolution.y;\n   \n    // Centered uv\n    vec2 uvCenter = (2.0f * uv - iResolution.xy);\n    // Get pixel angle around the center\n    float a = atan(uvCenter.x,uvCenter.y);\n   \n    float time = 20. * sin(1. * iTime);\n    float petals = 2.5;\n    /*\n    //every time 'time' equals 0, i.e. shape is back to circle\n    //randomize the number of cuts there are.\n    if (abs(time) < 0.01) {\n        petals = random(petals);\n    }\n    */\n    float offset = 50. * atan(tan(petals * a + time)); //https://en.wikipedia.org/wiki/Sawtooth_wave\n    float scale = (sin(iTime));\n    offset *= scale;\n   \n    radius = radius + offset;\n   \n    return radius;\n}\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\nfloat computeRadius(vec2 uv)\n{\n    float radius = 0.25 * iResolution.y;\n   \n    // Centered uv\n    vec2 uvCenter = (2.0f * uv - iResolution.xy);\n    // Get pixel angle around the center\n    float a = atan(uvCenter.x,uvCenter.y);\n    return radius;\n}\nvec3 random3(float seed) {\n    float bseed = bias(seed, 0.8);\n    return vec3(sin(bseed * 2342.43589),\n                sin(bseed * 12.2342),\n                sin(bseed * 901.2));\n}\nfloat layer(vec2 uv){\nvec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n\n    vec2 p[9];\n    int i = 0;\n    for(float y = -1.0; y <= 1.0; y++){\n    for(float x = -1.0; x <= 1.0; x++){\n        p[i++] = getPos(id, vec2(x, y));\n    }    \n    }\n   \n   \n    float t = iTime * 10.0;\n    float m = 0.0;\n    for(int i = 0; i < 9; i++){\n    m += line(gv, p[4], p[i]);\n       \n        vec2 j = (p[i] - gv) * 20.0;\n        float sparkle = 1.0 / dot(j, j);\n       \n        m += sparkle * (sin(t + fract(p[i].x) * 10.0) * 0.5 + 0.5);\n       \n        for(int yi= i + 1; yi < 9; yi++){\n    for(int zi= yi + 1; zi < 9; zi++){\n               \n                float len1 = abs(length(p[i] - p[yi]));\n                float len2 = abs(length(p[yi] - p[zi]));\n                float len3 = abs(length(p[i] - p[zi]));\n               \n                if((len1 + len2 + len3) < 2.8){\n                m += triangle(gv, p[i], p[yi], p[zi]) * 0.8;\n                }\n    }\n    }\n    }\n    m += line(gv, p[1], p[3]);\n    m += line(gv, p[1], p[5]);\n    m += line(gv, p[7], p[3]);\n    m += line(gv, p[7], p[5]);\n\n    return m;\n}\n#define C(t) ( vec3(1.5,.6,.6) + vec3(1.25,.38,-2.5) * cos(6.28318*(vec3(-3.142,-3.223,2)*(t)+vec3(.31,-1.42,1.75)))) //\n#define CS(a) vec2(cos(a),sin(a))\nfloat random(float seed) {\n    return (5. * sin(seed * iTime * 23.23)) + 1.;\n}\nvec4 circle(vec2 uv, vec2 center, float radius, vec3 color)\n{\n    // Get distance of point from center, get difference from given radius\nfloat d = length(center - uv) - radius;\nfloat t = clamp(d, 0.0, 1.0);\n   \n    // If point is smaller than radius, set color alpha to 1, otherwise 0\n    color = abs(random3(iTime * 0.00003));\nreturn vec4(color, 1.0 - t);\n}\n\n/*\n * Your work here!\n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//get coords and direction\nvec2 uv=fragCoord.xy/iResolution.xy-.5;\nuv.y*=iResolution.y/iResolution.x;\nvec3 dir=vec3(uv*zoom,(iTime*0.0002));\nfloat time=iTime*speed+.25;\n float m = 0.0;\n    float t = iTime * 0.1;\n   \n    vec4 O =fragColor;\n      vec4 O2 =fragColor;\n           O2 =vec4(0);\n    vec2 u =fragCoord;\n        vec2 C =fragCoord;\n    vec2 W = iResolution.xy,\n         U = (u - .5 * W) / W.y;\nvec3 p,q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<110.;\n        O2.xyz+=mix(vec3(1),H(g*.1),sin(.8))*1./e/8e3\n    )\n    {\n        p=g*d;\n        p.z+=iTime*10.5;\n        a=50.;\n        p=mod(p-a,a*2.)-a;\n        s=5.;\n        for(int i=0;i++<8;){\n            p=.3-abs(p);\n          \n            p.x<p.z?p=p.zyx:p;\n            p.z<p.y?p=p.xzy:p;\n            \n            s*=e=1.+sin(iTime*.234)*.1;\n            p=abs(p)*e-\n                vec3(\n                    5.+sin(iTime+.1+.5*cos(iTime*.3))*3.,\n                    50,\n                    8.+cos(iTime*.2)*5.\n                 );\n         }\n         g+=e=length(p.yz)/s;\n          g+=e=length(p.yx)/s;\n          g+=e=length(p.zx)/s;\n    }\n    vec3 col2 = vec3(0.0);\n   \n    for(float r = .05,m = 2.,R = 0.2,i,f,a ; i < 1e2; i++ )  {\n   \n        i+= f = sin(iTime*.01)*.5 + .8;\n        a = i/11.;\n\n\n        col2 += pow(.002/ length( U - f*(R + m*r) * CS(a) + m*R * CS(f*a + m*a) ) , 1.5)\n               * C( length(U) + i + iTime*.6 ); //циклоидальная кривая\n               \n        U*=mat2(sin(iTime*.1+vec4(0,11,33,0)));\n    }\n\n    O = vec4(col2, 1.0);\n    vec2 pos = uv;\n \n    pos.y /= iResolution.x/iResolution.y;\n   \n   \n    float dist = 1.0/length(pos);\n   \n    dist *= 0.1;\n   \n   \n    dist = pow(dist, 0.8);\n   \n   \n    vec3 col = dist * vec3(0.1, 0.1, 0.45);\n\n\n    col = 1.0 - exp( -col );\n    vec2 uv2 = fragCoord.xy;\n\nvec2 center = iResolution.xy * 0.5;\nfloat radius = computePeakyRadius(uv2.xy);\n  float t2 = iTime * .1 + ((.25 + .05 * sin(iTime * 10.1))/(length(dir.xy) + .312)) * 2.2;\nfloat si = sin(t);\nfloat co = cos(t);\nmat2 ma = mat2(co, si, -si, co); \ndir.xy*=ma;\n    // Background layer\nvec4 layer1 = vec4(rgb(255.0, 215.0, 210.0), 1.0);\n\n// Circle\nvec3 red = rgb(100.0, 50.0, 70.0);\nvec4 layer2 = circle(uv2, center, radius, red);\n   vec4 fragColor2 = mix(layer1, layer2, layer2.a);\nvec3 from=vec3(1.,.5,0.5)*fragColor2.xyz+O2.xyz;\nfrom+=vec3(time*2.,time,-2.);\n\n\nmainVR(fragColor, fragCoord, from, dir);\n    fragColor+=vec4(col+O.xyz,1.);\n}\n","name":"Image","description":"","type":"image"}]}