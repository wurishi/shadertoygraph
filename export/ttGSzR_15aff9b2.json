{"ver":"0.1","info":{"id":"ttGSzR","date":"1582297611","viewed":125,"name":"King Crown","username":"kuyuri_iroha","description":"hazy","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define LOOP_MAX 216\n#define EPS 1e-4\n#define HORIZONTAL_AA 1\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define sim(x, y) (abs(x - y) < EPS)\n\nconst float PI = acos(-1.0);\nconst float PI2 = PI * 2.0;\n\nvec2 uv = vec2(0.0, 0.0);\nconst vec3 dLight = normalize(vec3(0.2, 0.1, -0.5));\nconst vec3 pLight = vec3(0.0, 0.0, 0.6);\n\n// https://thebookofshaders.com/10/?lan=jp\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// https://qiita.com/kaneta1992/items/21149c78159bd27e0860\nmat2 rot(float r) {\n    float c = cos(r), s = sin(r);\n    return mat2(c, s, -s, c);\n}\n\nvec2 pmod(vec2 p, float r) {\n    float a =  atan(p.x, p.y) + PI/r;\n    float n = PI2 / r;\n    a = floor(a/n)*n;\n    return p*rot(-a);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat cappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 repLim2(vec3 p, vec3 c, vec3 l)\n{\n    return p - c * clamp(round(p / c), -l, l);\n}\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat octahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\n// http://mercury.sexy/hg_sdf/\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2.0 * s)) - s)));\n}\n\nfloat centerMap(vec3 p) {\n    vec3 centerP = p + vec3(0.0, -0.04, -0.6);\n\n    centerP.xz = centerP.xz * rot(iTime * PI * -0.4);\n    centerP.xz = centerP.xz * rot(PI * 4.0 * centerP.y);\n    centerP.xz = pmod(centerP.xz, 8.0) * 0.1;\n    centerP.z -= 0.05 * (1.8 - abs(centerP.y) / 0.1) * 0.1;\n    \n    return box(centerP, vec3(0.001, 0.2, 0.001));\n}\n\nfloat coreMap(vec3 p) {\n    vec3 coreP = p + vec3(0.0, -0.04, -0.6);\n    \n    coreP.xz = coreP.xz * rot(iTime * PI * 0.2);\n    \n    return octahedron(coreP, 0.05);\n}\n\nfloat map(vec3 p) {\n    vec2 seedP = p.xz;\n    seedP += vec2(EPS, 0.5);\n    vec2 seed = vec2(floor(seedP.x), floor(seedP.y + EPS));\n    \n    vec3 sphereP = p;\n    float sphereC = 0.6;\n    sphereP.xz += vec2(sphereC * 0.5, -0.3);\n    sphereP = repLim2(vec3(sphereP), vec3(sphereC, 0.0, 1.0), vec3(1.0, 1.0, 3.0));\n    sphereP.y -= mod(iTime * 0.1 - random(seed) * 5.0, 3.0);\n    sphereP.y += 0.5;\n    \n    vec3 pillarP = p;\n    float pillarC = 0.8;\n    pillarP.z -= 0.3;\n    pillarP.x = abs(pillarP.x) - 0.7;\n    pillarP.z = mod(pillarP.z + 0.5 * pillarC, pillarC) - 0.5 * pillarC - 0.2;\n    \n    vec3 dentP = pillarP;\n    dentP.y -= 0.94;\n    dentP.xz = pmod(dentP.xz, 20.0);\n    dentP.z -= 0.1;\n\n    float sphereDE = sphere(sphereP, 0.05);\n    float pillarDE = cappedCylinder(pillarP, 0.1, 1.1);\n    float dentDE = box(dentP, vec3(0.004, 1.1, 0.01));\n    float planeDE = dot(p, vec3(0.0, 1.0, 0.0)) + 0.2;\n    \n    float milk = fOpUnionRound(sphereDE, planeDE, 0.07);\n    float pillars = fOpUnionStairs(planeDE, max(-dentDE, pillarDE), 0.07, 5.0);\n    float center = min(centerMap(p), coreMap(p));\n    return min(min(milk, pillars), center);\n}\n\nvec3 norm(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(EPS, 0.0, 0.0)) - map(p + vec3(-EPS, 0.0, 0.0)),\n        map(p + vec3(0.0, EPS, 0.0)) - map(p + vec3(0.0, -EPS, 0.0)),\n        map(p + vec3(0.0, 0.0, EPS)) - map(p + vec3(0.0, 0.0, -EPS))\n    \t));\n}\n\nfloat fog(float depth) {\n    float density = 0.6;\n    return 1.0 - saturate(1.0 / exp(pow(density * depth, 2.0)));\n}\n\nfloat ao(vec3 p, vec3 n, float amp, float len) {\n\tfloat amt = 0.0;\n    for(int i = 0; i < 4; i++) {\n    \tp = p + len * n;\n        amt += amp * saturate(map(p) / len);\n        amp *= 0.5;\n        len += 0.02;\n    }\n    return amt;\n}\n\n// https://www.shadertoy.com/view/lsKcDD\nfloat softShadow(vec3 p, vec3 light) {\n    float minDist = 1e-6;\n    float maxDist = 10.0;\n    \n    float sharpness = 35.0;\n    \n    float s = 1.0;\n    float ph = 1e20;\n    float dist = minDist;\n    for(int i = 0; i < 32; i++) {\n    \tfloat st = centerMap(p + light * dist);\n        \n        float y = (i == 0) ? 0.0 : st * st / (2.0 * ph);\n        float d = sqrt(st * st - y * y);\n        s = min(s, sharpness * d / max(0.0, dist - y));\n        \n        ph = st;\n        dist += st;\n        \n        if(s < 1e-6 || maxDist < dist) {\n        \tbreak;\n        }\n    }\n    \n    return 1.0 - max(s, 0.0);\n}\n\nvec3 objMat(vec3 rp) {\n    vec3 no = norm(rp);\n    vec3 dpl = normalize(pLight - rp);\n    float ipl = distance(pLight, rp);\n    \n    vec3 albedo = vec3(0.4);\n    float pDiff = saturate(dot(dpl, no)) * (1.0 / (ipl * 1.5));\n    float shadow = softShadow(rp, dpl);\n    float a = ao(rp, no, 0.5, 0.01) * 0.7 + 0.5;\n    return (albedo + pDiff * 0.2) * a * (mix(0.6, 0.5, shadow) * (1.0 / (ipl * 3.0)));\n}\n\nvec3 centerMat(vec3 rp) {\n\tvec3 no = norm(rp);\n    vec3 invDLight = dLight * -1.0;\n    vec3 dpl = normalize(pLight - rp);\n    float ipl = distance(pLight, rp);\n    \n    vec3 albedo = vec3(0.15);\n    float dif = saturate(dot(invDLight, no));\n    float pDiff = saturate(dot(dpl, no)) * (1.0 / ipl);\n    float a = ao(rp, no, 1.8, 0.07) * 0.8 + 0.5;\n    return (albedo + dif * pDiff * 2.0) * (1.0 - a);\n}\n\nvec3 coreMat(vec3 rp) {\n\tvec3 no = norm(rp);\n    vec3 invDLight = dLight * -1.0;\n    \n    vec3 albedo = vec3(1.3);\n    float dif = saturate(dot(invDLight, no));\n    return albedo + dif;\n}\n\nvec3 skyMat() {\n    return mix(vec3(0.13), vec3(0.0), uv.y * 0.5);\n}\n\nvec3 march(vec3 ro, vec3 rd, out vec3 rp, out float depth) {\n    vec3 col = vec3(0.0);\n    depth = 1.0;\n    \n    for(int i = 0; i < LOOP_MAX; i++) {\n        rp = ro + rd * depth;\n        float dist = map(rp);\n        \n        if(abs(dist) < EPS) {\n            if(sim(dist, centerMap(rp))) {\n                col = centerMat(rp);\n            }\n            else if(sim(dist, coreMap(rp))) {\n                col = coreMat(rp);\n            }\n            else {\n                col = objMat(rp);\n            }\n            break;\n        }\n        else {\n        \tcol = skyMat();\n        }\n        \n        depth += dist;\n    }\n    return col;\n}\n\nvec3 render(vec2 p) {\n    float fov = 80.0 * 0.5 * PI / 180.0;\n    vec3 cp = vec3(0.0, 0.01, -0.7);\n    vec3 cd = normalize(vec3(0.0) - cp);\n    vec3 cs = normalize(cross(cd, vec3(0.0, 1.0, 0.0)));\n    vec3 cu = normalize(cross(cs, cd));\n    float td = 1.0 / tan(fov / 2.0);\n    \n    vec3 ro = cp;\n    vec3 rd = normalize(cs * p.x + cu * p.y + cd * td);\n    vec3 rp = vec3(0.0);\n    \n    vec3 col = vec3(0.0);\n    float depth = 1.0;\n    col += march(ro, rd, rp, depth);\n    \n    return mix(col, skyMat(), fog(depth));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec3 col = vec3(0.0);\n    for(int x = 0; x < HORIZONTAL_AA; x++)\n    {\n        vec2 delta = vec2(float(x - HORIZONTAL_AA / 2), 0.0) * 1e-3;\n        col += render(uv + delta);\n    }\n\n    fragColor = vec4(col / float(HORIZONTAL_AA), 1.0);\n}","name":"Image","description":"","type":"image"}]}