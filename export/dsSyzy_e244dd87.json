{"ver":"0.1","info":{"id":"dsSyzy","date":"1687834501","viewed":84,"name":"basica-espiral-2-Old School","username":"jorge2017a2","description":"basica-espiral-Old School","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["basicaespiraloldschool"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///por jorge flores-p.\n//basica-espiral-Old School\n//referencia de sdfs IQ.\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(5.0*antialiasing(1.0),b,d)\n#define PI 3.141516\n\nvec2 pold;\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nfloat sdCircle( vec2 p, float r )\n{return length(p) - r; }\n\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\nvec2 pa = p-a, ba = b-a;\nfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\nreturn length( pa - ba*h );\n}\n\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\ncolOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.001,0.0));\nreturn colOut;\n}\n\nvec3 drawgrafica(vec2 p, vec3 col)\n{\n    float fx;\n    float x,y,z,t;\n    float xp, yp;\n    float xm, ym;\n    vec2 pixel;\n    vec2 pold;\n    float d1,d2;\n    vec3 pt;    \nfloat foco = 10.0;\nfloat ClippingDistanceFar = -10.0; //'-5 '500\nfloat ClippingDistanceNear = 5.0; // '6 '-100\nfloat sngDeltaVisible = ClippingDistanceFar - ClippingDistanceNear;\nfloat dfin=999.9;\n\n   xm=0.5;\n   ym=0.5;\n    \n    for(int i=0; i<50;i++)\n    {   t=(1.0/20.0)*float(i);\n        x=t*cos(6.0*t);\n        y=t*sin(6.0*t);\n        z=t;\n\n        pt= rotate_z(vec3(x,y,z), radians(iTime*10.0));\n        x=pt.x; y=pt.y; z=pt.z;\n        pt= rotate_y(vec3(x,y,z), radians(iTime*12.0));\n        x=pt.x; y=pt.y; z=pt.z;\n        pt= rotate_x(vec3(x,y,z), radians(iTime*13.0));\n        x=pt.x; y=pt.y; z=pt.z;\n\n        xp = x + z / (sngDeltaVisible - foco) + xm;\n        yp = -y + z / (sngDeltaVisible - foco) + ym;\n        pixel.x = xp;\n        pixel.y = yp;\n        d1= sdCircle(p-pixel, 0.025 );\n\n        if(i>0)\n        {\n         d2= sdSegment(p, pixel, pold );\n         col=  DrawFigBorde(vec3(1.0,0.0,0.0), col, abs(d2)-0.025);\n        }\n        dfin=min(dfin,d1);\n        pold=pixel;\n\n    }\n    col=  DrawFigBorde(vec3(0.0), col, dfin );\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n     vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv.y=-uv.y;\n    vec2 uv0=uv;\n    vec2 pos=vec2(0.0,0.0);\n    uv-=pos; uv*=2.5;\n    vec3 col = vec3(0.35); //0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    col= drawgrafica(uv,col);\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}