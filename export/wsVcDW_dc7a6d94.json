{"ver":"0.1","info":{"id":"wsVcDW","date":"1602973673","viewed":162,"name":"for my daughters (with sound)","username":"snolot","description":"This one is for my daughters. I already used the post effect in a previous shader but they like the effect so... ","likes":6,"published":1,"flags":8,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//sign 3d almost identity smooth heart curvature\n//self: https://www.shadertoy.com/new\n\n/*\nto smoother curvature on a mirror axis (here a heart shape) (and better performance) just use;\nx=abs(p)\nx=almostIdentity(s,a,a*.5);\n x is a mirrored domain, assumed to have an L1 discontinuity (a sharp corner) , unless x is orthogonal to the mirror)\n a is \"smoothing delta\" == \"smoothing area\"\n\nthis is VERY useful for \"superprim\" generalizations.\nthis is a game changer for all typefaces \n and symbols and architecture with mirror symmetry.\nthis can solve all the continuity issues that you get with teleporters.\n as such, it even evades uncertainty of double-slit scenarios.\n by asserting that the double slit experiment is just a\n  special case of 2 linked-list-portals.\n\nparent shader had the solution to smoothing curvature along a mirror \n 1 day after i asked for it\n and 1 year before I noticed that it had it\n  and han I made this fork for it.\n*/\n\n//parent: https://www.shadertoy.com/view/4lK3Rc\n// Created by inigo quilez - iq/2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Code for the making of this video: https://www.youtube.com/watch?v=aNR4n0i2ZlM\n\n#define MULTI_SAMPLE_4 0\n#define MULTI_SAMPLE_8 0\n#define MULTI_SAMPLE_3 1\n#define MULTI_SAMPLE_2 0\n\n\n\n#define PI 3.14159265358979323846264338327950288\n#define DEG_TO_RAD (PI / 180.0)\n\n#define BEAT (time*170.0/60.0)\n#define time iTime\n#define lofi(x,d) (floor((x)/(d))*(d))\n#define saturate(a) (clamp((a),0.,1.))\n#define linearstep(a,b,t) (saturate(((t)-(a))/((b)-(a))))\n\nfloat accum;\nfloat seed;\n\nfloat fractsin(float v){\n  return fract(sin(v*121.445)*34.59);\n}\n\nfloat rand(){\n  seed=fractsin(seed);\n  return seed;\n}\nfloat hash1( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n\nconst float PHI = 1.6180339887498948482045868343656;\n\nvec3 forwardSF( float i, float n) \n{\n    float phi = 2.0*PI*fract(i/PHI);\n    float zi = 1.0 - (2.0*i+1.0)/n;\n    float sinTheta = sqrt( 1.0 - zi*zi);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\nfloat almostIdentity( float x, float m, float n )\n{\n    if( x>m ) return x;\n    float a = 2.0*n - m;\n    float b = 2.0*m - 3.0*n;\n    float t = x/m;\n    return (a*t + b)*t*t + n;\n}\n//below is special case of above; n=m*.5;\nfloat almostIdentity( float x, float m){\n    //x is asserted to be x=abs(x);\n    if(x>=m) return x;//sadly essential to also catch /0 case!\n    float t = x/m;\n    return (t*t+1.)*(.5*m);\n}\n\n\nvec2 map( vec3 q )\n{\n    q *= 100.0;\n\n    vec2 res = vec2( q.y, 2.0 );\n\n\n    float r = 15.0;\n    q.y -= r;\n    float ani = pow( 0.5+0.5*sin(6.28318*iTime + q.y/25.0), 4.0 );\n    q *= 1.0 - 0.2*vec3(1.0,0.5,1.0)*ani;\n    q.y -= 1.5*ani;\n    float x = abs(q.x);\n    \n    float m=1.0;//iMouse.y*20./iResolution.y;\n   // x = (almostIdentity((x), m, m*.5)); // remove discontinuity (https://iquilezles.org/articles/functions)\n    x = almostIdentity(x, m); // remove discontinuity (https://iquilezles.org/articles/functions)\n\n        \n    float y = q.y;\n    float z = q.z;\n    y = 4.0 + y*1.2 - x*sqrt(max((20.0-x)/15.0,0.0));\n    z *= 2.0 - y/15.0;\n    float d = sqrt(x*x+y*y+z*z) - r;\n    d = d/3.0;\n    if( d<res.x ) res = vec2( d, 1.0 );\n    \n    res.x /= 100.0;\n    return res;\n}\n\nvec2 intersect( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 1.0;\n\n    vec2 res = vec2(0.0);\n    float t = 0.2;\n    for( int i=0; i<300; i++ )\n    {\n\t    vec2 h = map( ro+rd*t );\n        if( (h.x<0.0) || (t>maxd) ) break;\n        t += h.x;\n        res = vec2( t, h.y );\n    }\n\n    if( t>maxd ) res=vec2(-1.0);\n\treturn res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.005,0.0,0.0);\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n    for( int i=0; i<64; i++ )\n    {\n        vec3 kk;\n        vec3 ap = forwardSF( float(i), 64.0 );\n\t\tap *= sign( dot(ap,nor) ) * hash1(float(i));\n        ao += clamp( map( pos + nor*0.01 + ap*0.2 ).x*20.0, 0.0, 1.0 );\n    }\n\tao /= 64.0;\n\t\n    return clamp( ao, 0.0, 1.0 );\n}\n\nvec2 glitch(vec2 v){\n    \n  vec2 vt=v;\n  for(int i=0;i<6;i++)\n  {\n    float fac=4.0*pow(2.2,-float(i));\n    float s=fractsin(lofi(vt.x,1.6*fac));\n    s+=fractsin(lofi(vt.y,0.4*fac));\n    s+=fractsin(time);\n    float proc=fractsin(s);\n    vt+=0.2*step(proc,0.4*exp(-3.0*mod(BEAT,8.0))-0.01)*(vec2(\n      fractsin(s+22.56),\n      fractsin(s+17.56)\n    )-0.5);\n  }\n  return vt;\n}\n\nvec3 render( in vec2 p,vec2 fragCoord )\n{\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n\tp = glitch(p);\n    \n\tfloat an = 0.2*(iMouse.x*40./iResolution.x+2.);\n\n\tvec3 ro = vec3(0.4*sin(an),0.25,0.4*cos(an));\n    vec3 ta = vec3(0.0,0.15,0.0);\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.7*ww );\n\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n    \n\tvec3 col = vec3(.3,0.02,0.01);\n\n\t// raymarch\n    vec3 uvw;\n    vec2 res = intersect(ro,rd);\n    float t = res.x;\n\n    if( t>0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\t\tvec3 ref = reflect( rd, nor );\n        float fre = clamp( 1.0 + dot(nor,rd), 0.0, 1.0 );\n        \n        float occ = calcAO( pos, nor ); occ = occ*occ;\n\n        if( res.y<1.5 ) // heart\n        {\n            col = vec3(0.9,0.02,0.01);\n            col = col*0.72 + 0.2*fre*vec3(1.0,0.8,0.2);\n            \n            vec3 lin  = 4.0*vec3(0.7,0.80,1.00)*(0.5+0.5*nor.y)*occ;\n            lin += 0.5*fre*vec3(1.0,1.0,1.00)*(0.6+0.4*occ);\n            col *= lin;\n            \n            col += 4.0*vec3(0.7,0.8,1.00)*smoothstep(0.0,0.4,ref.y)*(0.06+0.94*pow(fre,5.0))*occ;\n\t\t\tcol.rgb *= texture( iChannel2, ref).rgb * .75;\n            col = pow(col,vec3(0.4545));\n            vec3 grunge = texture( iChannel1, fragCoord/iChannelResolution[1].xy + vec2(.7549,.5698)*float(iFrame) ).rgb;\n    \t\tcol.rgb = mix( col.rgb*mix( vec3(1), grunge, .2 ), grunge*vec3(.3,1,.6), .02 );\n        }\n        else // ground\n        {\n            col *= clamp(sqrt(occ*1.8),0.0,1.0);\n            \n        }\n    }\n\n    col = clamp(col,0.0,1.0);\n\treturn col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragCoord.y += .2*tan(-.5*(iTime+1.4*sin(iTime*.8+.05))+.6*fragCoord.y/iResolution.y);\n    fragCoord.y += .6*tan(-.7*(iTime+1.6*sin(iTime*.8+.05))+.4*fragCoord.y/iResolution.y);\n    vec2 p = (-iResolution.xy+2.0*fragCoord)/iResolution.y;\n\n    vec3 col = render( p, fragCoord );\n   \n    vec2 q = fragCoord/iResolution.xy;\n    //col *= 0.2 + 0.8*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.2);\n    \n    fragColor = vec4( col, 1.0 );\n    fragColor.rgb *= smoothstep( 1.5, 0.4, length(fragCoord.xy-iResolution.xy*.5)/length(iResolution.xy*.5) );\n    \n    fragColor.rgb *= 1.+.4*sin(6.283185*fragCoord.y*.5*.618+iTime);\n    fragColor.rgb *= mix( 1., 1.8, smoothstep(.0,.3,cos(iTime/7.)) );    \n    fragColor.rgb = max(vec3(0),fragColor.rgb-.02);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// code inspired from Kali 'The Inversion Machine'  https://www.shadertoy.com/view/4dsGD7\nvec2 mainSound( in int samp, float time ){\n    float ti=time;\n    vec2 s = vec2(0.);\n    float t= mod(time,5.)-2.5;\n    float tb=mod(time,.9);\n    \n\tfloat x=t*.1;\n    \n    //s*=.2;\n\t//tb-=x*.0003;\n    s+=vec2(sin(time),cos(time))*sin(tb*tb*4000.)*exp(-15.*tb)*10.;\n\n    return vec2(s)*.5*clamp(60.-time,0.,1.);\n}","name":"Sound","description":"","type":"sound"}]}