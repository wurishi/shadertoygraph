{"ver":"0.1","info":{"id":"4fXcz7","date":"1720925411","viewed":35,"name":"DEEP ENTITY CRYSTAL","username":"netfetti","description":"mathematical headache, play with it!","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["geometry","reality","twisted"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Deep Entity Crystal Shader for Shadertoy\n\n#define PI 3.14159265359\n\nfloat sdOctahedron(vec3 p, float s) {\n    p = abs(p);\n    return (p.x + p.y + p.z - s) * 0.57735027;\n}\n\nfloat sdCrystal(vec3 p, float s) {\n    p = abs(p);\n    float m = max(p.x + p.y, max(p.y + p.z, p.z + p.x));\n    return m - s;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nvec3 rotateY(vec3 p, float a) {\n    float c = cos(a), s = sin(a);\n    return vec3(c*p.x - s*p.z, p.y, s*p.x + c*p.z);\n}\n\nvec3 rotateX(vec3 p, float a) {\n    float c = cos(a), s = sin(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n\nfloat scene(vec3 p) {\n    float t = iTime * 0.05; // Adjusted for animation speed\n    vec3 q = p;\n    q = rotateY(q, t * 1.7);\n    q = rotateX(q, t * -0.3);\n    \n    float complexity = 1.5; // Adjusted from u_fractalComplexity\n    float distortion = 1.0; // Adjusted from u_spatialDistortion\n    float iterations = 5.0; // Adjusted from u_complexIterations\n    \n    float d = sdCrystal(q, 1.0);\n    \n    for (float i = 0.7; i < 20.0; i++) {\n        if (i >= 10.0) break; // Adjusted from u_iterationDepth\n        float fi = float(i);\n        vec3 offset = vec3(\n            sin(fi * 1.1 + t * iterations) * complexity,\n            cos(fi * 1.3 + t * 1.1 * iterations) * complexity,\n            sin(fi * 1.7 + t * 1.2 * iterations) * complexity\n        );\n        float shape = sdOctahedron(q - offset, 0.3 + 0.1 * sin(fi + t * iterations));\n        d = smin(d, shape, distortion);\n    }\n    \n    return d;\n}\n\nvec3 getNormal(vec3 p) {\n    const float h = 0.0001;\n    const vec2 k = vec2(1, -1);\n    return normalize(k.xyy * scene(p + k.xyy*h) +\n                     k.yyx * scene(p + k.yyx*h) +\n                     k.yxy * scene(p + k.yxy*h) +\n                     k.xxx * scene(p + k.xxx*h));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.y, iResolution.x);\n    \n    float zoom = .6; // Adjusted from u_zoomLevel\n    uv *= zoom;\n\n    vec3 ro = vec3(0.0, 0.0, -4.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n\n    float t = 0.0;\n    for(int i = 0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        float h = scene(p);\n        if(h < 0.001 || t > 20.0) break;\n        t += h;\n    }\n    \n    vec3 p = ro + rd * t;\n    vec3 normal = getNormal(p);\n    vec3 light = normalize(vec3(1.0, 1.0, -1.0));\n    \n    float diff = max(dot(normal, light), 0.0);\n    float amb = 0.5 + 0.5 * dot(normal, vec3(0.0, 1.0, 0.0));\n    float spec = pow(max(dot(reflect(-light, normal), -rd), 0.0), 32.0);\n    \n    vec3 col = vec3(0.7, 0.8, 1.0) * diff + vec3(0.2, 0.3, 0.4) * amb + vec3(1.0) * spec;\n    \n    col = mix(col, vec3(0.0), 1.0 - exp(-0.1 * t));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}