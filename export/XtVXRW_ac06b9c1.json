{"ver":"0.1","info":{"id":"XtVXRW","date":"1483295102","viewed":377,"name":"Equirectangular stereo VR cam","username":"Nesvi7","description":"This is a camera for rendering 360 stereo SBS/OU images/video for VR.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["camera","vr","renderer","equirectangular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//By Nestor Vina\n\n/* With the GetEquirectangularStereoDirection function you can easily adapt existing shadertoys to\n * view them in VR equirectangular stereo images. This only affects the origin and direction of the\n * ray and you can see it in the mainImage function.\n * \n * The ideal scenario is to render this in very high resolutions, so if you comment the OverUnder \n * define you will be able to render the L and R eye independently and compose them in photoshop \n * for example. \n *\n * The best option is to use a custom renderer in SBS outside shadertoy to achieve the highest \n * resolution posible. So if you have one talk me about it, because with that we can even render\n * stereo video.\n *\n */\n\n#define OverUnder\n\n// ray marching\nconst int max_iterations = 100;\nconst float stop_threshold = 0.02;\nconst float grad_step = 0.01;\nconst float clip_far = 1000.0;\n\n// math\nconst float PI = 3.14159265358979323846264338327;\nconst float DEG_TO_RAD = PI / 180.0;\n\nconst vec3 sunDir = normalize(vec3(1.0,-1.0,1.0));\n\n//Stereo equirectangular part\nstruct StereoOutput{\n vec3 dir,originOffset;   \n};\n    \nStereoOutput GetEquirectangularStereoDirection(vec2 uv, float ipd){\n    #ifdef OverUnder\n        bool r = uv.y < 0.5;\n\n        if(r)\n            uv.y = uv.y*2.0;\n        else\n            uv.y = (uv.y-0.5)*2.0;\n\n        StereoOutput stereoOutput;\n        vec2 tp = ((uv*2.0)-vec2(1.0));\n        tp *= vec2(PI,PI*0.5); \n        stereoOutput.dir = vec3(cos(tp.y)*cos(tp.x),\n                                sin(tp.y),\n                                cos(tp.y)*sin(tp.x));\n        stereoOutput.dir.y = -stereoOutput.dir.y;\n        float angle = atan(stereoOutput.dir.z,stereoOutput.dir.x);\n        float ipdInfluence = 1.0-abs(dot(stereoOutput.dir,vec3(0.0,1.0,0.0)));\n\n        if(r)\n            angle -= PI/2.0;\n        else\n            angle += PI/2.0;\n\n        stereoOutput.originOffset = vec3(cos(angle),0.0,sin(angle))*ipd*0.5*ipdInfluence;\n    \n    #else\n        StereoOutput stereoOutput;\n        vec2 tp = ((uv*2.0)-vec2(1.0));\n        tp *= vec2(PI,PI*0.5); \n        stereoOutput.dir = vec3(cos(tp.y)*cos(tp.x),\n                                sin(tp.y),\n                                cos(tp.y)*sin(tp.x));\n        stereoOutput.dir.y = -stereoOutput.dir.y;\n        float angle = atan(stereoOutput.dir.z,stereoOutput.dir.x);\n        float ipdInfluence = 1.0-abs(dot(stereoOutput.dir,vec3(0.0,1.0,0.0)));\n\n        #if 1 //R\n            angle -= PI/2.0;\n        #else //L\n            angle += PI/2.0;\n        #endif\n        \n\n        stereoOutput.originOffset = vec3(cos(angle),0.0,sin(angle))*ipd*0.5*ipdInfluence;\n    #endif\n    return stereoOutput;    \n}\n\n//Operations\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nvec3 rotate( vec3 p, vec3 rot ){\n    rot.z = -rot.z;\n    mat3 ry = mat3(cos(rot.y), 0.0,-sin(rot.y),\n\t\t\t   0.0, 1.0, 0.0, \n\t\t\t   sin(rot.y), 0.0, cos(rot.y)  );\n    \n\tmat3 rz = mat3(cos(rot.z),-sin(rot.z), 0.0,\n\t\t\t   sin(rot.z), cos(rot.z), 0.0,\n\t\t\t   0.0, 0.0, 1.0 );\n     \n\tmat3 rx = mat3(1.0, 0.0, 0.0,\n\t\t\t   0.0, cos(rot.x), sin(rot.x), \n\t\t\t   0.0,-sin(rot.x), cos(rot.x) );\n    return p*rz*ry*rx;\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x, \n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\n//Primitives some/all of them by iq\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat sdCappedCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) ) * sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//Map\n\nvec2 K2SOEyes(vec3 p){\n    float theDist;    \n    \n    const float ipd = 0.37;\n    const float eyeHeight = 0.0;\n    float eyeL = length(p-vec3(-ipd,eyeHeight,-0.75))-0.15;\n    float eyeR = length(p-vec3(ipd,eyeHeight,-0.75))-0.15;\n    \n    \n    float eyeLHole = length((p-vec3(-ipd,eyeHeight,-0.9))*vec3(1.0,1.0,0.2))-0.07;\n    float eyeRHole = length((p-vec3(ipd,eyeHeight,-0.9))*vec3(1.0,1.0,0.2))-0.07;\n    \n    theDist = min(eyeL,eyeR);\n    theDist = max(theDist,-eyeLHole);\n    theDist = max(theDist,-eyeRHole);\n    return vec2(theDist,3.0);\n}\n\nvec2 K2SOHead( vec3 p ){\n\tvec2 theDist;\n    \n    const float cutSeparation = -0.9;\n    float verticalCutL = -p.x + cutSeparation;\n    float verticalCutR = p.x + cutSeparation;\n    \n    //return vec2(verticalCutR,0.0);\n    theDist = vec2(smin(length((p+vec3(0.0,-0.3,0.0))*vec3(1.0,0.8,0.9))-1.0,verticalCutL,-8.0),0.0);    \n    theDist.x = smin(theDist.x,verticalCutR,-8.0);  \n    \n    float horizontalCut = p.y - 0.5;\n    float horizontalCutTop = -p.y - 0.9;\n    \n    theDist.x = max(theDist.x,horizontalCut);\n    theDist.x = smin(theDist.x,horizontalCutTop,-8.0);\n    \n    const float ipd = 0.37;\n    const float eyeHeight = 0.0;\n    float eyeL = sdCapsule(p,vec3(-ipd,eyeHeight,0.0), vec3(-ipd,eyeHeight,-2.0),0.15);\n    float eyeR = sdCapsule(p,vec3(ipd,eyeHeight,0.0), vec3(ipd,eyeHeight,-2.0),0.15);\n    \n    theDist.x = max(theDist.x,-eyeL);\n    theDist.x = max(theDist.x,-eyeR);\n    \n    float mouthGroove = sdBox((p+vec3(0.0,-0.9,+1.0))*vec3(4.0*min(p.y+1.11-2.0,1.0),1.0,1.0),vec3(0.5,0.5,0.5));\n    theDist.x = max(theDist.x, -mouthGroove);\n    \n    float mouth = sdBox(p+vec3(0.0,-0.65,0.7),vec3(0.23,0.2,0.4));\n    mouth = max(mouth, -sdBox(p+vec3(0.0,-0.9,0.8),vec3(0.13,0.2,0.4)));\n    theDist = opU(theDist, vec2(mouth,1.0));//boca\n    \n    float mouthLateralThingL = sdBox(p+vec3(0.3+p.z*0.08,-0.75,0.6),vec3(0.07,0.07,0.4));\n    float mouthLateralThingR = sdBox(p+vec3(-0.3-p.z*0.08,-0.75,0.6),vec3(0.07,0.07,0.4));\n    theDist = opU(theDist, vec2(mouthLateralThingL,1.0));\n    theDist = opU(theDist, vec2(mouthLateralThingR,1.0));\n    \n    float cheekL = sdBox(p+vec3(0.3,-0.53,0.6),vec3(0.1,0.1,0.4));\n    cheekL = max(cheekL,-sdBox(p+vec3(0.4,-0.66,0.7),vec3(0.1,0.1,0.4)));\n    cheekL = min(cheekL,sdBox((p+vec3(0.26,-0.53,1.04))*rotationXY(vec2(0.0,-1.0)),vec3(0.03,0.03,0.05)));\n    float cheekR = sdBox(p+vec3(-0.3,-0.53,0.6),vec3(0.1,0.1,0.4));\n    cheekR = max(cheekR,-sdBox(p+vec3(-0.4,-0.66,0.7),vec3(0.1,0.1,0.4)));\n    cheekR = min(cheekR,sdBox((p+vec3(-0.26,-0.53,1.04))*rotationXY(vec2(0.0,1.0)),vec3(0.03,0.03,0.05)));\n    \n    theDist = opU(theDist, vec2(cheekL,1.0));\n    theDist = opU(theDist, vec2(cheekR,1.0));\n    \n    float chin = sdBox(p+vec3(0.0,-0.8,0.65),vec3(0.13,0.2,0.4));\n    chin = max(chin, -sdBox((p+vec3(0.0,-0.9,1.2))*rotationXY(vec2(-0.8,0.0)),vec3(0.5,0.13,0.4)));\n    theDist = opU(theDist, vec2(chin,2.0));\n    \n    float mandible = sdBox(p+vec3(0.0,-0.65,0.4),vec3(1.-p.y*0.9,0.2,0.2));\n    \n    theDist = opU(vec2(mandible,2.0),theDist);\n    \n    theDist = opU(theDist,K2SOEyes(p));\n    \n    return theDist;\n}\n\nvec2 K2SONeck(vec3 p ){\n\tfloat theDist = sdCappedCylinder(p+vec3(0.0,-1.0,0.0),vec2(0.25,0.7));\n    \n    return vec2(theDist,0.0);\n}\n\nvec2 K2SOBody(vec3 p ){\n    p += vec3(0.0,0.1,0.0);\n\tfloat theDist = sdEllipsoid(p+vec3(0.0,-3.5,-0.8), vec3(2.3,2.4,2.0) );\n    theDist = max(theDist, -(length(p+vec3(0.0,-0.85,0.3))-0.9));   \n    theDist = smin(theDist,-(length(p+vec3(5.0,-4.0,0.0))-3.0),-2.0); \n    theDist = smin(theDist,-(length(p+vec3(-5.0,-4.0,0.0))-3.0),-2.0);  \n    theDist = smin(theDist,length((p+vec3(0.0,-4.0,4.5))*vec3(7.0,1.0,1.0))-3.0,2.0);\n    theDist = max(theDist,-p.z-1.2);\n    \n    float shoulder = sdCappedCone( (p+vec3(2.8,-2.8,-0.7))*rotationXY(vec2(PI*0.5,-PI*0.5)), vec3(1.0,1.0,1.0) );\n    shoulder = max(shoulder, -(length(p+vec3(3.,-2.8,-0.7))-1.0));\n    shoulder = min(shoulder, sdCappedCone( (p+vec3(-2.8,-2.8,-0.7))*rotationXY(vec2(PI*0.5,PI*0.5)), vec3(1.0,1.0,1.0) ));\n    shoulder = max(shoulder, -(length(p+vec3(-3.,-2.8,-0.7))-1.0));\n    \n    theDist = smin(theDist, shoulder,8.0);\n    \n    return vec2(theDist,0.0);    \n}\n\nvec2 K2SOArms(vec3 p){\n    float theDist;\n    \n    vec3 armLP = p + vec3(-0.5,0.0,0.0);\n    float armL = sdCapsule(armLP,-vec3(2.8,-2.8,-0.7),-vec3(2.8,-5.0,-0.7),0.6);   \n    armL = max(armL, -armLP.x-3.3);\n    armL = max(armL, armLP.x+2.8);\n    \n    vec3 armRP = (p + vec3(0.5,0.0,0.0))*vec3(-1.0,1.0,1.0);\n    float armR = sdCapsule(armRP,-vec3(2.8,-2.8,-0.7),-vec3(2.8,-5.0,-0.7),0.6);   \n    armR = max(armR, -armRP.x-3.3);\n    armR = max(armR, armRP.x+2.8);\n    \n    theDist = min(armL,armR);\n    \n    return vec2(theDist,0.0);\n}\n\n\nvec2 K2SO( vec3 p ){\n    vec2 result = opU(K2SOHead(p*rotationXY(vec2(0.0,sin(iTime)))),K2SONeck(p));\n    result = opU(result,K2SOBody(p));\n    result = opU(result,K2SOArms(p));\n\treturn result;\n    \n}\n\nvec2 map( vec3 p) {\n    float theDist = length(p)-1.0;\n    theDist = min(theDist,K2SO((p+vec3(0.0,0.0,-20.0))/3.0).x*3.0);\n    theDist = min(theDist,sdBox( rotate((p+vec3(-10.0,0.0,-10.0)),vec3(709.26,2.3,2.1)),vec3(2.0,2.0,2.0)));\n    theDist = min(theDist,sdCappedCylinder( rotate((p+vec3(+10.0,0.0,-10.0)),vec3(709.26,2.3,2.1)),vec2(2.0,2.0)));\n    theDist = min(theDist,sdBox( rotate((p+vec3(0.0,-10.0,-10.0)),vec3(1.5,2.3,1.0)),vec3(10.0,1.0,1.0)));\n    theDist = min(theDist,sdBox( rotate((p+vec3(0.0,10.0,-10.0)),vec3(-1.5,2.3,1.0)),vec3(10.0,1.0,1.0)));\n    \n    return vec2(theDist,0.0);\n}\n// ray marching\nvec2 ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\t\n    float depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n        vec2 distResult = map( origin + dir * depth );\n\t\tfloat dist = distResult.x;\n\t\tif ( dist < stop_threshold ) {\n\t\t\treturn vec2(depth,distResult.y);\n\t\t}\n\t\tdepth += dist;\n\t\tif ( depth >= end) {\n\t\t\treturn vec2(end,-1.0);\n\t\t}\n\t}\n\treturn vec2(end,-1.0);\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\t\n\treturn normalize( vec3( -xy, -z ) );\n}\n\nvec3 normal( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tmap( pos + dx ).x - map( pos - dx ).x,\n\t\t\tmap( pos + dy ).x - map( pos - dy ).x,\n\t\t\tmap( pos + dz ).x - map( pos - dz ).x\t\t\t\n\t\t)\n\t);\n}\n\n\n\nfloat fresnel(vec3 n, vec3 d, float exp ){\n    return pow(1.0-dot(d,n),exp);\n}\n\nvec3 material( vec3 v, vec3 n, vec3 eye ) {    \n    //Texturing \n    vec2 uv = v.xz;    \n    vec3 albedo = vec3(0.5,0.0,0.0);\n    \n    vec3 viewDir = normalize(eye-v);    \n    vec3 fresnelColor = vec3(0.4,0.3,0.7) * fresnel(n,viewDir,2.0);    \n    \n    float diffuse = dot(sunDir,n)*0.3;\n    vec3 ambient = vec3(0.1,0.05,0.005);\n    \n    return albedo+diffuse+ambient;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    StereoOutput stereoOutput = GetEquirectangularStereoDirection(fragCoord.xy/iResolution.xy, 0.65);\n\tvec3 dir = stereoOutput.dir;\n\tvec3 eye = vec3( 0.0, 0.0, 10.0 ) + stereoOutput.originOffset;\n\n\tmat3 rot = rotationXY( vec2(0,0));//vec2(-0.2, iTime/2.0 ) );\n\tdir = rot * dir;\n\teye = rot * eye;\n\n    vec2 rayResult = ray_marching( eye, dir, 0.0, clip_far );\n\tfloat depth = rayResult.x;\n\tif ( depth >= clip_far ) {        \n\t\tfragColor = vec4(0.3,0.3,0.3,1.0);//Background color\n        return;\n\t}\n\t\n\tvec3 pos = eye + dir * depth;\n\tvec3 n = normal( pos );\n    vec3 fogColor = vec3(0.3,0.3,0.3);\n    \n    if( rayResult.y == 0.0 )\n    \tfragColor = vec4(material( pos, n, eye ), 1);\n    \n}","name":"Image","description":"","type":"image"}]}