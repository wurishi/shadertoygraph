{"ver":"0.1","info":{"id":"Dt3SW7","date":"1685508370","viewed":80,"name":"interactive exploring game!","username":"user333","description":"TO USE: click on the screen :) the universe is persistent!\ninspired by : https://www.youtube.com/watch?v=ZZY9YE7rZJw\ni was struggling with buffers so my variable storing code was based a lot on : https://www.shadertoy.com/view/tdGBDG","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["game","interactive","space","universe","movement","memory"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n   float rand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(11.912,80.776)))* 18922.89872);\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float speed = 50.0;\n\n    vec2 position_modif=fetchData(iChannel0, SCREEN_COLOR_ADDR).rb;\n    \n\n    // Normalized pixel coordinates (from 0 to 1)\n    float square_width = 10.0;\n    // Calculate the position within the grid\n    \n    vec2 real_pos = fragCoord+position_modif*speed;\n    \n    vec2 grid_pos = floor(real_pos / square_width);\n    \n    \n     vec3 col = vec3(0, 0, 0);\n    \n    \n    float rnd_num = rand(grid_pos);\n    \n    if(0.95<rnd_num)\n    {\n    \n    float rand_from_one_to_zero = (rnd_num - 0.95) / 0.05;\n    \n    float r = step(floor(rand_from_one_to_zero*10.0),5.0);\n    float g = step(floor(mod(rand_from_one_to_zero*100.0,10.0)),5.0);\n    float b = step(mod(floor(rand_from_one_to_zero*100.0),2.0),0.5);\n    \n    col = vec3(r,g,b) * step(distance(real_pos,  vec2(grid_pos.x*square_width+square_width/2.0,grid_pos.y*square_width+square_width/2.0)),(square_width/2.0)*(rnd_num-0.90)/0.1);    \n    }\n    \n  \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (storeData(fragCoord, SCREEN_COLOR_ADDR)) {\n        fragColor = vec4(0.0, 0.0, 1.0, 1.0); // Initial value\n    }\n\n    if (iFrame > 0) { // After initialization\n        if (storeData(fragCoord, SCREEN_COLOR_ADDR)) {\n            fragColor = fetchData(iChannel0, SCREEN_COLOR_ADDR); // Load value from previous frame\n\n\n            float speed = distance(iMouse.xy,iResolution.xy/2.0)*0.01;\n            vec2 nrm_vec_to_mouse = normalize(iMouse.xy-iResolution.xy/2.0);\n            \n            float cos_of_my_vec = dot(nrm_vec_to_mouse,vec2(1,0));\n            float sin_of_my_vec = dot(nrm_vec_to_mouse,vec2(0,1));\n            \n            // Update:\n            if (iMouse.z > 0.0 && speed>0.03) { //test of speed is so no funny buisness will happen if distance of mouse from center == 0\n              \n              \n                fragColor.r += 0.05*speed * cos_of_my_vec;\n                fragColor.b += 0.05*speed * sin_of_my_vec;\n              \n              \n                \n            \n            }\n\n\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Addresses:\n// These should be ivec2s containing the pixel coordinates of where certain data\n// should go. The coordinates are not normalize but can range from (0, 0) to\n// (iResolution.x, iResolution.y).\nconst ivec2 SCREEN_COLOR_ADDR = ivec2(0, 0);\n\n// Unfortunately, the only way to define functions that sample iChannels in Common\n// is with #define :(\n\n// buf - iChannel to read from\n// addr - the data address in the form of an ivec2 (vector containing two integers)\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n\n// buf_pos - fragment position (fragCoord)\n// addr - the data address in the form of an ivec2\n// storeData() just evaluates if the data address matches the fragment position\n// in which case the data should be stored in fragColor.\n#define storeData(buf_pos, addr) ivec2(buf_pos) == addr","name":"Common","description":"","type":"common"}]}