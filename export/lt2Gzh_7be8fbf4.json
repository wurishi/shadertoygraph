{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"const float farval = 1e5;\nconst vec3 tgt = vec3(0);\nvec3 cpos;\nconst int rayiter = 60;\nconst float dmax = 20.0;\nvec3 L = normalize(vec3(-0.3, 1.0, -1.0));\nmat3 Rview;\n\nconst float outline = 0.0225;\n\nmat3 rotX(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0, 0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\nmat3 rotY(in float t) {\n    float cy = cos(t), sy = sin(t);\n\treturn mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n\n}\n\nmat3 rotZ(in float t) {\n    float cz = cos(t), sz = sin(t);\n\treturn mat3(cz, -sz, 0.,\n                sz, cz, 0.,\n                0., 0., 1.);\n\n}\n\nfloat sdRibbon( vec3 p, vec2 h ) {\n\n\tvec2 q = vec2(length(p.xy)-h.x, p.z);\n    vec2 d = abs(q) - vec2(0.001, h.y);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    \n}\n\n\n\nvec2 opU(vec2 a, vec2 b) {\n\treturn a.x < b.x ? a : b;\n}\n\n\nvec2 map(in vec3 pos) {\t\n    \n    vec2 rval = vec2(farval, 0.0);\n        \n    const float k = 0.15;\n    const float r = 0.25;\n    const float m = 0.04;\n\t  \n#if 0\n   \n    // Lithium?\n    pos = pos.xzy;\n    pos = rotX(0.2)*pos;\n    vec3 p0 = rotY(-0.1*iTime)*rotZ(-0.2*iTime)*pos;\n    rval = opU(rval, vec2(length(p0-vec3(k))-r, 0.0));\n    rval = opU(rval, vec2(length(p0-vec3(k,-k,-k))-r, 0.01));\n    rval = opU(rval, vec2(length(p0-vec3(-k,k,-k))-r, 0.5));\n    rval = opU(rval, vec2(length(p0-vec3(-k,-k,k))-r, 0.51));\n            \n    vec3 p1 = rotX(0.1)*rotZ(-2.9*iTime)*pos;\n    rval = opU(rval, vec2(length(p1-vec3(1.8,0,0))-r, 0.14));\n    rval = opU(rval, vec2(sdRibbon(p1, vec2(1.8, m)), 0.7));\n\n    vec3 p2 = rotX(-0.07)*rotZ(1.7*iTime)*pos;\n    rval = opU(rval, vec2(length(p2-vec3(1.2,0,0))-r, 0.14));\n    rval = opU(rval, vec2(sdRibbon(p2, vec2(1.2, m)), 0.7));   \n\n#else\n        \n    // Beryllium?\n    pos = pos.xzy;\n    vec3 p0 = rotY(-0.3*iTime)*rotZ(-0.2*iTime)*pos;\n\n    float c = sign(p0.x)*sign(p0.y)*sign(p0.z)*0.25 + 0.25;\n    rval = opU(rval, vec2(length(abs(p0)-vec3(k))-r, c));\n    \n    float rx = 0.2;\n    float rz = 1.05;\n    float l = 1.0;\n    float s = 1.0;\n    \n    for (int i=0; i<4; ++i) {\n        vec3 pi = rotX(0.04)*rotZ(s*rz*iTime)*rotY(-s*rx)*rotX(s*rx*0.5+0.35)*pos;\n        rval = opU(rval, vec2(length(pi-vec3(l,0,0))-r, 0.14));\n        rval = opU(rval, vec2(sdRibbon(pi, vec2(l, m)), 0.7));\n        l += 0.4;\n        rx += 0.05;\n        rz += 0.2;\n        s *= -1.0;\n    }\n    \n#endif    \n   \n\treturn rval;\n    \n}\n\nvec3 hue(float h) {\n\t\n\tvec3 c = mod(h*6.0 + vec3(2, 0, 4), 6.0);\n\treturn h >= 1.0 ? vec3(h-1.0) : clamp(min(c, -c+4.0), 0.0, 1.0);\n}\n\n\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nvec4 castRay( in vec3 ro, in vec3 rd, in float maxd )\n{\n\tfloat precis = 0.002;\n    \n    float h=outline;\n    \n    float t = 0.0;\n    float m = -1.0;\n\n    float tclose = farval;\n    float hclose = 2.0*outline;\n    \n    for( int i=0; i<rayiter; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) continue;//break;\n        t += h;\n\t    vec2 res = map( ro+rd*t );\n        \n        if (h < outline && res.x > h && t < tclose) {\n            hclose = h;\n            tclose = t;\n            //t = maxd+1.;\n        } \n        \n        h = res.x;\n\t    m = res.y;        \n    }    \n    \n    if (t > maxd) {\n        m = -1.0;\n    }\n\n    return vec4(t, m, tclose, hclose);\n    \n}\n\nvec3 shade( in vec3 ro, in vec3 rd ){\n    \n    vec4 tm = castRay(ro, rd, dmax);        \n    \n    vec3 c;\n    \n    if (tm.y == -1.0) {\n        \n        c = vec3(step(farval, tm.z));\n        //c = vec3(smoothstep(0.5*outline, outline, tm.w)); // Bad anti-aliasing?\n        \n    } else {        \n        \n        vec3 pos = ro + tm.x*rd;\n        vec3 n = calcNormal(pos);        \n        vec2 res = map( pos + 0.5*outline*n );        \n        \n        if (res.y != tm.y) {\n            \n            c = vec3(0);\n            \n        } else {\n\n            vec3 color = hue(tm.y) * 0.4 + 0.6;\n            vec3 diffamb = (0.5*clamp(dot(n,L), 0.0, 1.0)+0.5) * color;\n            vec3 R = 2.0*n*dot(n,L)-L;\n            float spec = 0.5*pow(clamp(-dot(R, rd), 0.0, 1.0), 20.0);\n            c = diffamb + spec;\n            float u = clamp((tm.x-tm.z)*2.0, 0.0, 1.0);\n            c *= step(outline*u, tm.w);\n\n        }\n\n    }\n\n    \n    return c;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    cpos = vec3(0,0,3.5);\n\tvec2 uv = (fragCoord.xy - .5*iResolution.xy) * 1.25 / (iResolution.y);\n\t\n\tvec3 rz = normalize(tgt - cpos),\n        rx = normalize(cross(rz,vec3(0,1.,0))),\n        ry = cross(rx,rz);\n\t\n\tfloat thetax = 0.0, thetay = 0.0;\n\t\n\tif (max(iMouse.x, iMouse.y) > 20.0) { \n\t\tthetax = (iMouse.y - .5*iResolution.y) * 3.14/iResolution.y; \n\t\tthetay = (iMouse.x - .5*iResolution.x) * -6.28/iResolution.x; \n\t}\n\t\n    Rview = mat3(rx,ry,rz)*rotX(thetax)*rotY(thetay);\n    L = Rview*L;\n\n\tvec3 rd = Rview*normalize(vec3(uv, 1.)),\n        ro = tgt + Rview*vec3(0,0,-length(cpos-tgt));\n\t\n\tfragColor.xyz = shade(ro, rd);\n\n\t\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lt2Gzh","date":"1427043718","viewed":601,"name":"rutherford atom","username":"mattz","description":"Experiment in adding outlines to distance marched scenes. Looks better fullscreen.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["outlines"],"hasliked":0,"parentid":"","parentname":""}}