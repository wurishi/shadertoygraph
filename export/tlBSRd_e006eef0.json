{"ver":"0.1","info":{"id":"tlBSRd","date":"1566804261","viewed":213,"name":"metervara_raymarch_issue_2","username":"Metervara","description":"Unstable shape when raymarching sfd.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float MINIMUM_HIT_DISTANCE = 0.01;\nconst int MAX_STEP = 64;\nconst float MAX_CAST_DISTANCE = 20.;\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat displace( vec3 p ) \n{\n    float size = 5.0;\n    float amp = 0.2;\n \treturn sin(size*p.x)*sin(size*p.y)*sin(size*p.z)*amp;\n}\n\n// https://www.shadertoy.com/view/4djXDy\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nfloat map(vec3 p)\n{\n\tmat4 mat = rotationAxisAngle( normalize(vec3(sin(iTime * 0.5),1.0,0.0)), iTime );\n\tp = (mat * vec4(p,0.0)).xyz;\n    \n    float box = sdBox(p, vec3(1.0));\n    float displacement = displace(p);\n    return box + displacement;\n}\n\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n}\n\n// returns 1 if we hit something, Outputs the hit position\nint raymarch( in vec3 ro, in vec3 rd, out vec3 pos )\n{\n    int hit = 0;\n    float currentDistance = 0.0; // current distance traveled along ray\n    \n    for (int i = 0; i < MAX_STEP; ++i) {\n         if (currentDistance > MAX_CAST_DISTANCE) {\n            break;\n        }\n        \n        vec3 p = ro + rd * currentDistance; // sample position\n        float distance = map(p);\n        \n        if (abs(distance) < MINIMUM_HIT_DISTANCE) {\n            pos = p;\n            hit = 1;\n            break;\n        }\n        \n        currentDistance += 0.8 * distance; // Smaller step size to prevent stepping through the displacement field\n    }\n    \n    return hit;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n\tmat4 rotation = rotationAxisAngle( normalize(vec3(sin(iTime * 0.5),1.0,0.0)), iTime );\n    \n    vec2 rayUV = (uv * 2.0 - 1.0) * iResolution.xy * 0.001;\n    vec3 rayOrigin = vec3(0.0, 0.0, -7);\n    vec3 rayDirection = normalize(vec3(rayUV.x, rayUV.y, 1.0));//normalized, yay!\n    \n    \n    vec3 hitposition = vec3(0.0);\n    \n    if(raymarch(rayOrigin, rayDirection, hitposition) > 0) {\n        vec3 normal = calcNormal(hitposition);\n    \tfragColor = vec4(normal*0.5 + 0.5,1.0);\n    } else {\n        fragColor = vec4(0.0);\n    }\n\n}","name":"Image","description":"","type":"image"}]}