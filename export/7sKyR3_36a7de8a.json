{"ver":"0.1","info":{"id":"7sKyR3","date":"1656345399","viewed":245,"name":"HPG22 Entry, apvfirmino","username":"apvfirmino","description":"Submission to HPG22 Student Competition","likes":0,"published":1,"flags":32,"usePreview":1,"tags":["pathtracing","hpgconf"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Submission to HPG22 Student Competition\n//\n// Rewrote ray-scene intersection, with geometry represented as pre-computed \n//     4x4 matrices (inverses of their model-world transform matrix).\n//\n// Light sampling also uses pre-computed 4x4 matrices instead of computing \n//     rotation matrices and offsets.\n//\n// Used a simple linear congruential generator as the pseudo-random number generator.\n// \n// Limited ray depth to 4 to increase number of samples per frame. \n//\n// Implemented temporal re-projection and accumulation to improve quality.\n//\n// Implemented an image filter very similar to SVGF with a few differences: \n//     4 instead of 5 filter levels (due to ShaderToy limitation); \n//     7x7 kernel size instead of 5x5 (to increase pixel footprint); \n//     material based edge stopping function; \n//     temporal accumulation at each but the last filter level to improve stability;\n\nvoid mainImage(out vec4 fragColor, \n               in  vec2 fragCoord)\n{\n    BufferBCD pixel_p_d = decode_buffer_bcd(texelFetch(iChannel0, ivec2(fragCoord), 0));\n    if (pixel_p_d.mat_id == uint(0))\n    {\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    vec3 radiance = vec3(0.), W = vec3(0.);\n    for (int i = -3; i < 4; ++i)\n    {\n        for (int j = -3; j < 4; ++j)\n        {\n            ivec2 xy = ivec2(fragCoord) + 8 * ivec2(i, j);\n            BufferBCD pixel_q_d = decode_buffer_bcd(texelFetch(iChannel0, xy, 0));\n              \n            vec3 w = vec3(float(material_overlap(pixel_p_d.mat_id, pixel_q_d.mat_id)));\n            w *= exp(-abs(pixel_q_d.radiance - pixel_p_d.radiance) / (SIGMA_L * sqrt(pixel_p_d.variance) + vec3(1e-2)));\n            w *= coeffs[i + 3] * coeffs[j + 3];\n            radiance += w * pixel_q_d.radiance;\n            W += w;\n        }\n    }\n    radiance /= W;\n    \n    const float exposure = 2.;\n    fragColor = vec4(pow(exposure * MAX_RADIANCE * radiance, vec3(1.0 / 2.2)), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define MAT_LEFT        0\n#define MAT_RIGHT       1\n#define MAT_CEILING     2\n#define MAT_FLOOR       3\n#define MAT_BACK        4\n#define MAT_H           5\n#define MAT_P           6\n#define MAT_G           7\n#define MAT_2           8\n#define MAT_LIGHT0      9\n#define MAT_LIGHT1      10\n#define MAT_LIGHT2      11\n#define MAT_LIGHT3      12\n#define MAT_LIGHT4      13\n#define MAT_LIGHT5      14\n#define MAT_LIGHT6      15\n#define MAT_LIGHT7      16\n#define MAT_LIGHT8      17\n\nstruct Ray\n{\n\tvec3 origin, dir;\n};\n\nstruct AABB\n{\n\tvec3 min_, max_;\n};\n\nstruct MaterialSample\n{\n\tvec3 color;\n\tfloat roughness;\n\tbool is_light;\n};\n\nuint seed;\n\nconst float cube_light_size = 0.08;\n\nconst vec3 light_color[4] = vec3[4](\n    vec3(5),\n    vec3(5),\n    vec3(80.0, 50, 30),\n    vec3(30, 30, 80.0));\n\nMaterialSample get_material(int material)\n{\n    MaterialSample ms;\n    switch(material) \n    {\n        case MAT_LEFT   : ms = MaterialSample(vec3(0.9, 0.1, 0.1), 0.5,  false); break;\n        case MAT_RIGHT  : ms = MaterialSample(vec3(0.1, 0.9, 0.1), 0.5,  false); break;\n        case MAT_CEILING: ms = MaterialSample(vec3(0.7, 0.7, 0.7), 0.25, false); break;\n        case MAT_FLOOR  : ms = MaterialSample(vec3(0.7, 0.7, 0.7), 0.12, false); break;\n        case MAT_BACK   : ms = MaterialSample(vec3(0.7, 0.7, 0.7), 0.25, false); break;\n        case MAT_H      : ms = MaterialSample(vec3(1.0, 0.0, 0.0), 0.10, false); break;\n        case MAT_P      : ms = MaterialSample(vec3(0.0, 0.7, 0.7), 0.10, false); break;\n        case MAT_G      : ms = MaterialSample(vec3(0.1, 0.1, 0.7), 0.10, false); break;\n        case MAT_2      : ms = MaterialSample(vec3(0.8, 0.8, 0.8), 0.55, false); break;\n        default         : ms = MaterialSample(light_color[material - MAT_LIGHT0], intBitsToFloat(material - MAT_LIGHT0), true); break;\n    }\n    return ms;\n}\n\nconst mat4 lights_invobb[4] = mat4[4](\n    mat4(11.513262748718262, -0.0, -4.867729663848877, -0.0, -0.0, 12.5, -0.0, 0.0, 4.867729663848877, -0.0, 11.513262748718262, -0.0, 7.941298484802246, 12.505000114440918, -10.788914680480957, 1.0),\n    mat4(8.708833694458008, -0.0, -8.966951370239258, -0.0, -0.0, 12.5, -0.0, 0.0, 8.966951370239258, -0.0, 8.708833694458008, -0.0, -3.906040668487549, 12.504999160766602, 1.4483187198638916, 1.0),\n    mat4(12.5, -0.0, 0.0, -0.0, -0.0, 12.5, -0.0, 0.0, 0.0, -0.0, 12.5, -0.0, -9.999999046325684, 11.0, 8.0, 1.0),\n    mat4(12.5, -0.0, 0.0, -0.0, -0.0, 12.5, -0.0, 0.0, 0.0, -0.0, 12.5, -0.0, 11.0, 11.0, 8.0, 1.0));\n\nconst mat4 lights_obb[4] = mat4[4](\n    mat4(0.07368487864732742, 0.0, 0.031153466552495956, 0.0, 0.0, 0.07999999821186066, 0.0, 0.0, -0.031153466552495956, 0.0, 0.07368487864732742, 0.0, -0.9212656617164612, -1.0003999471664429, 0.5475808382034302, 1.0),\n    mat4(0.05573653429746628, 0.0, 0.057388484477996826, 0.0, 0.0, 0.07999999821186066, 0.0, 0.0, -0.057388484477996826, 0.0, 0.05573653429746628, 0.0, 0.30082598328590393, -1.0003999471664429, 0.1434374898672104, 1.0),\n    mat4(0.07999999821186066, 0.0, 0.0, 0.0, 0.0, 0.07999999821186066, 0.0, 0.0, 0.0, 0.0, 0.07999999821186066, 0.0, 0.7999999523162842, -0.8799999952316284, -0.64000004529953, 1.0),\n    mat4(0.07999999821186066, 0.0, 0.0, 0.0, 0.0, 0.07999999821186066, 0.0, 0.0, 0.0, 0.0, 0.07999999821186066, 0.0, -0.8799999952316284, -0.8799999952316284, -0.64000004529953, 1.0));\n    \nvec3 sample_light(vec3 position, \n                  vec4 rng, \n                  out vec3 normal, \n                  out float pdf, \n                  out vec3 Le)\n{\n    int cube_idx = int(rng.z * float(lights_invobb.length()));\n\n    int face_idx = int(rng.w * 6.);\n    Le = light_color[cube_idx];\n\n    vec3 p, n;\n    switch(face_idx) \n    {\n        case 0: p = vec3(rng.x, 0, rng.y); n = vec3( 0, -1,  0); break;\n        case 1: p = vec3(rng.x, 1, rng.y); n = vec3( 0,  1,  0); break;\n        case 2: p = vec3(rng.x, rng.y, 0); n = vec3( 0,  0, -1); break;\n        case 3: p = vec3(rng.x, rng.y, 1); n = vec3( 0,  0,  1); break;\n        case 4: p = vec3(0, rng.x, rng.y); n = vec3(-1,  0,  0); break;\n        case 5: p = vec3(1, rng.x, rng.y); n = vec3( 1,  0,  0); break;\n    }\n    p = (lights_obb[cube_idx] * vec4(p, 1.)).xyz;\n    normal = normalize((transpose(lights_invobb[cube_idx]) * vec4(n, 0.)).xyz);\n\n    pdf = 1.0 / (float(lights_invobb.length()) * 6.0 * cube_light_size * cube_light_size);\n\n    return p;\n}\n\nfloat\nget_light_pdf()\n{\n    return 1.0 / (float(lights_invobb.length()) * 6.0 * cube_light_size * cube_light_size);\n}\n\nbool intersect_aabb(Ray ray, \n                    vec3 p_lower, \n                    vec3 p_upper, \n                    float t_min, \n                    float t_max, \n                    out float t, \n                    out vec3 n)\n{\n    vec3 div = 1. / ray.dir;\n    vec3 t_lower = (p_lower - ray.origin) * div;\n    vec3 t_upper = (p_upper - ray.origin) * div;\n    vec3 t_mins = min(t_lower, t_upper);\n    vec3 t_maxs = max(t_lower, t_upper);\n    \n    float t_min_ = max(max(t_mins.x, t_mins.y), t_mins.z);\n    float t_max_ = min(min(t_maxs.x, t_maxs.y), t_maxs.z);\n\n    n = -sign(ray.dir) * step(t_mins.yzx ,t_mins.xyz) * step(t_mins.zxy ,t_mins.xyz);\n\n    t = t_min_;\n    return (t_min_ <= t_max_) && ((t_min <= t_min_ && t_min_ <= t_max) || (t_min <= t_max_ && t_max_ <= t_max));\n}\n\nvoid intersect_box(in Ray ray, \n                    in int box_material, \n                    in mat4 box_inv_obb,\n                    in float t_min,\n                    inout float t_max,\n                    inout int material,\n                    inout vec3 normal,\n                    inout float t)\n{\n    ray.origin = (box_inv_obb * vec4(ray.origin, 1.)).xyz;\n    ray.dir = (box_inv_obb * vec4(ray.dir, 0.)).xyz;\n    float t_; vec3 n_; \n    if (intersect_aabb(ray, vec3(0.), vec3(1.), t_min, t_max, t_, n_))\n    {\n        material = box_material;\n        normal = normalize((transpose(box_inv_obb) * vec4(n_, 0.)).xyz);\n        t = t_; t_max = t;\n    }\n}\n\n#define INTERSECT_BOX(box_material, box_inv_obb) intersect_box(ray, box_material, box_inv_obb, t_min, t_max, material, normal, t);\n\nbool intersect_boxes(Ray ray,\n                     float t_min, \n                     float t_max, \n                     inout vec3 p, \n                     inout vec3 normal, \n                     inout int material, \n                     inout float t)\n{\n    float t_ = t;\n    INTERSECT_BOX(0, mat4(986895.0625, -0.0, 0.0, -0.0, -0.0, 0.5, -0.0, 0.0, 0.0, -0.0, 0.5, -0.0, 986895.0625, 0.5, 0.5, 1.0))\n    INTERSECT_BOX(1, mat4(1048576.0, -0.0, 0.0, -0.0, -0.0, 0.5, -0.0, 0.0, 0.0, -0.0, 0.5, -0.0, -1048576.0, 0.5, 0.5, 1.0))\n    INTERSECT_BOX(2, mat4(0.5, -0.0, 0.0, -0.0, -0.0, 9.999999974752427e-07, -0.0, 0.0, 0.0, -0.0, 0.5, -0.0, 0.5, -9.999999974752427e-07, 0.5, 1.0))\n    INTERSECT_BOX(3, mat4(0.5, -0.0, 0.0, -0.0, -0.0, 986895.0625, -0.0, 0.0, 0.0, -0.0, 0.5, -0.0, 0.5, 986895.0625, 0.5, 1.0))\n    INTERSECT_BOX(4, mat4(0.5, -0.0, 0.0, -0.0, -0.0, 0.5, -0.0, 0.0, 0.0, -0.0, 986895.0625, -0.0, 0.5, 0.5, 986895.0625, 1.0))\n    INTERSECT_BOX(5, mat4(4.696863174438477, -0.0, -2.285985231399536, -0.0, -0.0, 1.3333332538604736, -0.0, 0.0, 1.7144889831542969, -0.0, 6.262483596801758, -0.0, 4.227176666259766, 1.3333332538604736, -2.0573863983154297, 1.0))\n    INTERSECT_BOX(5, mat4(4.696863651275635, -0.0, -2.285984992980957, -0.0, -0.0, 1.3333332538604736, -0.0, 0.0, 1.7144891023635864, -0.0, 6.262483596801758, -0.0, 2.092177152633667, 1.3333332538604736, -2.057386636734009, 1.0))\n    INTERSECT_BOX(5, mat4(2.3484320640563965, -0.0, -2.285985231399536, -0.0, -0.0, 7.142858028411865, -0.0, 0.0, 0.857244610786438, -0.0, 6.262484550476074, -0.0, 1.8235887289047241, 4.928572177886963, -2.057386875152588, 1.0))\n    INTERSECT_BOX(6, mat4(3.6584439277648926, -0.0, 4.544258117675781, -0.0, -0.0, 1.3333332538604736, -0.0, 0.0, -3.408193826675415, -0.0, 4.877925395965576, -0.0, 1.7060030698776245, 1.3333332538604736, 0.2968071699142456, 1.0))\n    INTERSECT_BOX(6, mat4(5.226348400115967, -0.0, 4.5442585945129395, -0.0, -0.0, 3.174603223800659, -0.0, 0.0, -4.868847846984863, -0.0, 4.877925395965576, -0.0, -0.41999551653862, 2.0317459106445312, 0.296807199716568, 1.0))\n    INTERSECT_BOX(6, mat4(1.7135571241378784, -0.0, 4.5442585945129395, -0.0, -0.0, 7.142856597900391, -0.0, 0.0, -1.5963438749313354, -0.0, 4.877925395965576, -0.0, 0.696020245552063, 5.085713863372803, 0.29680734872817993, 1.0))\n    INTERSECT_BOX(6, mat4(1.5534794330596924, -0.0, 4.544258117675781, -0.0, -0.0, 7.142857551574707, -0.0, 0.0, -1.4472160339355469, -0.0, 4.877924919128418, -0.0, 0.7244174480438232, 2.7857141494750977, 0.29680725932121277, 1.0))\n    INTERSECT_BOX(9, mat4(11.513262748718262, -0.0, -4.867729663848877, -0.0, -0.0, 12.5, -0.0, 0.0, 4.867729663848877, -0.0, 11.513262748718262, -0.0, 7.941298484802246, 12.505000114440918, -10.788914680480957, 1.0))\n    INTERSECT_BOX(7, mat4(4.605305194854736, -0.0, -2.5961220264434814, -0.0, -0.0, 1.6393440961837769, -0.0, 0.0, 1.9470916986465454, -0.0, 6.140406131744385, -0.0, -1.2224383354187012, 1.5409836769104004, 2.1367239952087402, 1.0))\n    INTERSECT_BOX(7, mat4(4.605305194854736, -0.0, -2.5961220264434814, -0.0, -0.0, 4.878048896789551, -0.0, 0.0, 1.9470916986465454, -0.0, 6.140406131744385, -0.0, -3.3474385738372803, 4.5853657722473145, 2.136723756790161, 0.9999999403953552))\n    INTERSECT_BOX(7, mat4(4.605305194854736, -0.0, -2.5961222648620605, -0.0, -0.0, 6.666665077209473, -0.0, 0.0, 1.9470919370651245, -0.0, 6.140406608581543, -0.0, -3.3474385738372803, 3.1999993324279785, 2.1367239952087402, 1.0))\n    INTERSECT_BOX(7, mat4(1.7544020414352417, -0.0, -2.5961222648620605, -0.0, -0.0, 7.142856597900391, -0.0, 0.0, 0.7417492270469666, -0.0, 6.140406608581543, -0.0, -0.6561670899391174, 7.142856597900391, 2.1367242336273193, 0.9999999403953552))\n    INTERSECT_BOX(7, mat4(2.9711647033691406, -0.0, -2.5961222648620605, -0.0, -0.0, 7.142856597900391, -0.0, 0.0, 1.2561882734298706, -0.0, 6.140406131744385, -0.0, -1.80479896068573, 5.249999523162842, 2.1367242336273193, 1.0))\n    INTERSECT_BOX(7, mat4(1.9472746849060059, -0.0, -2.5961222648620605, -0.0, -0.0, 7.142857551574707, -0.0, 0.0, 0.8232945203781128, -0.0, 6.140406131744385, -0.0, -0.6796779036521912, 2.7857143878936768, 2.1367239952087402, 1.0))\n    INTERSECT_BOX(8, mat4(14.285714149475098, -0.0, 0.0, -0.0, -0.0, 5.479452133178711, -0.0, 0.0, 0.0, -0.0, 8.0, -0.0, -1.4285715818405151, 1.0958904027938843, 8.0, 1.0))\n    INTERSECT_BOX(8, mat4(14.285712242126465, -0.0, 0.0, -0.0, -0.0, 6.34920597076416, -0.0, 0.0, 0.0, -0.0, 7.999999523162842, -0.0, -4.814284801483154, 0.1111110970377922, 7.999999523162842, 0.9999999403953552))\n    INTERSECT_BOX(8, mat4(3.5087716579437256, -0.0, 0.0, -0.0, -0.0, 14.285714149475098, -0.0, 0.0, 0.0, -0.0, 8.0, -0.0, -0.4280701279640198, 2.857142925262451, 8.0, 1.0))\n    INTERSECT_BOX(8, mat4(3.999999761581421, -0.0, 0.0, -0.0, -0.0, 14.285712242126465, -0.0, 0.0, 0.0, -0.0, 7.999999523162842, -0.0, -0.48799997568130493, 0.800000011920929, 7.999999523162842, 0.9999999403953552))\n    INTERSECT_BOX(8, mat4(4.0, -0.0, 0.0, -0.0, -0.0, 14.28571605682373, -0.0, 0.0, 0.0, -0.0, 8.0, -0.0, -0.4880000054836273, -1.500000238418579, 8.0, 1.0))\n    INTERSECT_BOX(8, mat4(14.285714149475098, -0.0, 0.0, -0.0, -0.0, 5.479452133178711, -0.0, 0.0, 0.0, -0.0, 8.0, -0.0, -6.4285712242126465, 1.0958904027938843, 8.0, 1.0))\n    INTERSECT_BOX(8, mat4(14.285712242126465, -0.0, 0.0, -0.0, -0.0, 6.34920597076416, -0.0, 0.0, 0.0, -0.0, 7.999999523162842, -0.0, -9.81428337097168, 0.1111110970377922, 7.999999523162842, 0.9999999403953552))\n    INTERSECT_BOX(8, mat4(3.5087716579437256, -0.0, 0.0, -0.0, -0.0, 14.285714149475098, -0.0, 0.0, 0.0, -0.0, 8.0, -0.0, -1.6561403274536133, 2.857142925262451, 8.0, 1.0))\n    INTERSECT_BOX(8, mat4(3.999999761581421, -0.0, 0.0, -0.0, -0.0, 14.285712242126465, -0.0, 0.0, 0.0, -0.0, 7.999999523162842, -0.0, -1.8880000114440918, 0.800000011920929, 7.999999523162842, 0.9999999403953552))\n    INTERSECT_BOX(8, mat4(4.0, -0.0, 0.0, -0.0, -0.0, 14.28571605682373, -0.0, 0.0, 0.0, -0.0, 8.0, -0.0, -1.8880001306533813, -1.500000238418579, 8.0, 1.0))\n    INTERSECT_BOX(9, mat4(11.513262748718262, -0.0, -4.867729663848877, -0.0, -0.0, 12.5, -0.0, 0.0, 4.867729663848877, -0.0, 11.513262748718262, -0.0, 7.941298484802246, 12.505000114440918, -10.788914680480957, 1.0))\n    INTERSECT_BOX(10, mat4(8.708833694458008, -0.0, -8.966951370239258, -0.0, -0.0, 12.5, -0.0, 0.0, 8.966951370239258, -0.0, 8.708833694458008, -0.0, -3.906040668487549, 12.504999160766602, 1.4483187198638916, 1.0))\n    INTERSECT_BOX(11, mat4(12.5, -0.0, 0.0, -0.0, -0.0, 12.5, -0.0, 0.0, 0.0, -0.0, 12.5, -0.0, -9.999999046325684, 11.0, 8.0, 1.0))\n    INTERSECT_BOX(12, mat4(12.5, -0.0, 0.0, -0.0, -0.0, 12.5, -0.0, 0.0, 0.0, -0.0, 12.5, -0.0, 11.0, 11.0, 8.0, 1.0))\n    if (t != t_)\n    {\n        t -= 1e-5;\n        p = ray.origin + t * ray.dir;\n        return true;\n    }\n    return false;\n}\n\nfloat intersect(Ray ray, \n                float t_min, \n                float t_max, \n                out vec3 p, \n                out vec3 normal, \n                out MaterialSample ms,\n                inout uint mat_id)\n{\n    float t = INFINITY; int material;\n    if (intersect_boxes(ray, t_min, t_max, p, normal, material, t))\n    {\n        mat_id |= uint(1 << material);\n        mat_id |= uint(1 << (13 + int(dot(step(1e-4, normal), vec3(1,2,4)))));\n        ms = get_material(material);\n        return t;\n    }\n    return INFINITY;\n}\n\nmat3 construct_ONB_frisvad(vec3 normal)\n{\n\tmat3 ret;\n\tret[1] = normal;\n\tif(normal.z < -0.999805696)\n    {\n\t\tret[0] = vec3(0.0, -1.0, 0.0);\n\t\tret[2] = vec3(-1.0, 0.0, 0.0);\n\t}\n\telse \n    {\n\t\tfloat a = 1.0 / (1.0 + normal.z);\n\t\tfloat b = -normal.x * normal.y * a;\n\t\tret[0] = vec3(1.0 - normal.x * normal.x * a, b, -normal.x);\n\t\tret[2] = vec3(b, 1.0 - normal.y * normal.y * a, -normal.y);\n\t}\n\treturn ret;\n}\n\nuint jenkinsHash(uint x) \n{\n    x += x << 10;\n    x ^= x >> 6;\n    x += x << 3;\n    x ^= x >> 11;\n    x += x << 15;\n    return x;\n}\n\nuint initRNG(uvec2 pixel, \n             uvec2 resolution, \n             uint frame) \n{\n\t uint rngState = (pixel.x  + pixel.y * resolution.x) ^ jenkinsHash(frame);\n\t return jenkinsHash(rngState);\n}\n\nfloat uintToFloat(uint x) \n{\n\treturn uintBitsToFloat(0x3f800000u | (x >> 9)) - 1.f;\n}\n\nuint rand_lcg(inout uint rngState)\n{\n\t// LCG values from Numerical Recipes\n\trngState = 1664525u * rngState + 1013904223u;\n\treturn rngState;\n}\n\nvec2 get_random()\n{\n\treturn vec2(uintToFloat(rand_lcg(seed)), uintToFloat(rand_lcg(seed)));\n}\n\n// adapted from https://cwyman.org/code/dxrTutors/tutors/Tutor14/tutorial14.md.html\nfloat ggxNormalDistribution(float NdotH, \n                            float roughness)\n{\n\tfloat a2 = roughness * roughness;\n\tfloat d = ((NdotH * a2 - NdotH) * NdotH + 1.0);\n\treturn a2 / (d * d * PI);\n}\n\nfloat schlickMaskingTerm(float NdotL, \n                         float NdotV, \n                         float roughness)\n{\n\t// Karis notes they use alpha / 2 (or roughness^2 / 2)\n\tfloat k = roughness*roughness / 2.0;\n\n\t// Compute G(v) and G(l).  These equations directly from Schlick 1994\n\t//     (Though note, Schlick's notation is cryptic and confusing.)\n\tfloat g_v = NdotV / (NdotV*(1.0 - k) + k);\n\tfloat g_l = NdotL / (NdotL*(1.0 - k) + k);\n\treturn g_v * g_l;\n}\n\nvec3 schlickFresnel(vec3 f0, \n                    float lDotH)\n{\n\treturn f0 + (vec3(1.0, 1.0, 1.0) - f0) * pow(1.0 - lDotH, 5.0);\n}\n\n// When using this function to sample, the probability density is:\n//      pdf = D * NdotH / (4 * HdotV)\nvec3 getGGXMicrofacetTS(vec2 randVal, \n                        float roughness, \n                        vec3 hitNorm)\n{\n\t// GGX NDF sampling\n\tfloat a2 = roughness * roughness;\n\tfloat cosThetaH = sqrt(max(0.0, (1.0 - randVal.x) / ((a2 - 1.0) * randVal.x + 1.0)));\n\tfloat sinThetaH = sqrt(max(0.0, 1.0 - cosThetaH * cosThetaH));\n\tfloat phiH = randVal.y * PI * 2.0;\n\n\t// Get our GGX NDF sample (i.e., the half vector)\n\treturn vec3(sinThetaH * cos(phiH), cosThetaH, sinThetaH * sin(phiH));\n}\n\n\nmat4 look_at(vec3 eye, \n             vec3 center, \n             vec3 up)\n{\n\tmat4 ret;\n\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, normalize(up)));\n\tvec3 u = cross(s, f);\n\n\tret[0][0] = s[0];\n\tret[1][0] = s[1];\n\tret[2][0] = s[2];\n\n\tret[0][1] = u[0];\n\tret[1][1] = u[1];\n\tret[2][1] = u[2];\n\n\tret[0][2] = -f[0];\n\tret[1][2] = -f[1];\n\tret[2][2] = -f[2];\n\n\tret[0][3] = ret[1][3] = ret[2][3] = 0.0;\n\n\tret[3][0] = -dot(s, eye);\n\tret[3][1] = -dot(u, eye);\n\tret[3][2] =  dot(f, eye);\n\n\tret[3][3] = 1.0;\n\treturn ret;\n}\n\n\n// convert pdf from area measure to solid angle\nfloat pdf_a_to_w(float pdf, \n                 float dist2, \n                 float cos_theta)\n{\n\tfloat abs_cos_theta = abs(cos_theta);\n\tif(abs_cos_theta < 1e-8)\n        return 0.0;\n\treturn pdf * dist2 / abs_cos_theta;\n}\n\nbool test_visibility(vec3 p1, \n                     vec3 p2)\n{\n\tconst float eps = 1e-5;\n\tRay r = Ray(p1, normalize(p2 - p1));\n    r.origin += eps * r.dir;\n\n\tvec3 n, p; MaterialSample ms; uint mid_;\n    return intersect(r, 0., distance(p1, p2) - 2.0 * eps, p, n, ms, mid_) == INFINITY;\n}\n\nvec3 pt_mis(Ray ray, \n            inout uint mat_id, \n            inout vec3 first_hit)\n{\n\tvec3 contrib = vec3(0);\n\tvec3 tp = vec3(1.0);\n\n\tvec3 position, normal;\n\tMaterialSample ms;\n\tfloat t = intersect(ray, 0., INFINITY, position, normal, ms, mat_id);\n\t\n    if(t == INFINITY)\n\t\treturn vec3(0.);\n        \n    first_hit = ray.origin + t * ray.dir;\n\n\tif(ms.is_light) /* hit light source */\n\t\treturn ms.color;\n\n\tfor(int i = 0; i < NUM_BOUNCES; i++) \n    {\n\t\tmat3 onb = construct_ONB_frisvad(normal);\n\n\t\tfloat NdotV = max(1e-4, dot(normal, -ray.dir));\n\n\t\t{ /* NEE */\n\t\t\tvec3 light_normal;\n\t\t\tfloat light_pdf;\n\t\t\tvec3 Le;\n\t\t\tvec3 pos_ls = sample_light(position, vec4(get_random(), get_random()), light_normal, light_pdf, Le);\n\t\t\tvec3 l_nee = pos_ls - position;\n\t\t\tfloat rr_nee = dot(l_nee, l_nee);\n\t\t\tl_nee *= inversesqrt(rr_nee);\n\n\t\t\tvec3 H = normalize(-ray.dir + l_nee);\n\t\t\tfloat NdotH = max(1e-6, dot(normal, H));\n\t\t\tfloat LdotH = max(1e-6, dot(l_nee, H));\n\t\t\tfloat NdotL = max(1e-6, dot(normal, l_nee));\n\n\t\t\tfloat D = ggxNormalDistribution(NdotH, ms.roughness);\n\t\t\tfloat G = schlickMaskingTerm(NdotL, NdotV, ms.roughness);\n\t\t\tvec3  F = schlickFresnel(ms.color, LdotH);\n\t\t\t{\n\t\t\t\tvec3 brdf = D * G * F / (4.0 * NdotV * NdotL);\n                float brdf_pdf = D * NdotH / (4.0 * LdotH);\n\n                float light_pdf_w = pdf_a_to_w(light_pdf, rr_nee, -dot(l_nee, light_normal));\n                float w = light_pdf / (light_pdf_w + brdf_pdf);\n\n\t\t\t\tif(test_visibility(position, pos_ls)) \n                {\n\t\t\t\t\tcontrib += w * tp * (Le * brdf) / light_pdf;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t{ /* brdf */\n\t\t\t// Randomly sample the NDF to get a microfacet in our BRDF\n\t\t\tvec3 H = onb * getGGXMicrofacetTS(get_random(), ms.roughness, normal);\n\n\t\t\t// Compute outgoing direction based on this (perfectly reflective) facet\n\t\t\tvec3 L = normalize(reflect(ray.dir, H));\n\n\t\t\t// Compute some dot products needed for shading\n\t\t\tfloat  NdotL = max(1e-6, dot(normal, L));\n\t\t\tfloat  NdotH = max(1e-6, dot(normal, H));\n\t\t\tfloat  LdotH = max(1e-6, dot(L, H));\n\n\t\t\t// Evaluate our BRDF using a microfacet BRDF model\n\t\t\tfloat D = ggxNormalDistribution(NdotH, ms.roughness);\n\t\t\tfloat G = schlickMaskingTerm(NdotL, NdotV, ms.roughness);\n\t\t\tvec3  F = schlickFresnel(ms.color, LdotH);\n\t\t\tvec3  brdf = D * G * F / (4.0 * NdotL * NdotV);\n\n\t\t\t// What's the probability of sampling vector H from getGGXMicrofacet()?\n\t\t\tfloat brdf_pdf = D * NdotH / (4.0 * LdotH);\n\n\t\t\tray = Ray(position, L);\n\n\t\t\tvec3 position_next, normal_next;\n\t\t\tMaterialSample ms_next;\n            uint mid_;\n\t\t\tfloat t = intersect(ray, 1e-5, INFINITY, position_next, normal_next, ms_next, mid_);\n\n\t\t\tif(t == INFINITY)\n\t\t\t\tbreak;\n\n            if(ms_next.is_light) \n            {\n                float light_pdf_a = get_light_pdf();\n\t\t\t\tfloat light_pdf_w = pdf_a_to_w(light_pdf_a, t * t, -dot(ray.dir, normal_next));\n\t\t\t\tfloat w = brdf_pdf / (brdf_pdf + light_pdf_w);\n\t\t\t\tcontrib += tp * (ms_next.color * w * brdf) / brdf_pdf;\n\t\t\t\tbreak;\n            }\n\n\t\t\ttp *= NdotL * brdf / brdf_pdf;\n\n\t\t\tposition = position_next;\n\t\t\tnormal = normal_next;\n\t\t\tms = ms_next;\n\t\t}\n\t}\n\n\treturn contrib;\n}\n\nvec2 stratified_sample(int index)\n{\n    vec2 r = 0.25 * get_random();\n    r += float(index & 1) * vec2(0.25);\n    r += float(index & 2) * vec2(0.25);\n    return r;\n}\n\nvoid mainImage(out vec4 fragColor, \n               in  vec2 fragCoord)\n{\n    seed = initRNG(uvec2(gl_FragCoord.xy), uvec2(iResolution.xy) , uint(iFrame));\n\n\tvec2 p = fragCoord.xy / vec2(iResolution) - vec2(0.5);\n\tfloat a = float(iResolution.x) / float(iResolution.y);\n\tif(a < 1.0)\n\t\tp.y /= a;\n\telse\n\t\tp.x *= a;\n        \n    vec3 cam_center = vec3(sin(TIME_FACTOR * iTime) * 0.25, sin(TIME_FACTOR * iTime * 0.7345) * 0.4 + 0.2, 6.0);\n\tvec3 cam_target = vec3(0, -0.1, 0);\n\tmat4 cam = transpose(look_at(cam_center, cam_target, vec3(0, 1, 0)));\n\n\tvec3 s = vec3(0);\n    float exposure = 2.0;\n    uint mat_id = uint(0); vec3 first_hit = vec3(0.);\n\tfor(int i = 0; i < NUM_SAMPLES; i++) \n    {\n        #if NUM_SAMPLES == 4 || NUM_SAMPLES == 8 || NUM_SAMPLES == 12 || NUM_SAMPLES == 16\n\t\tvec2 r = stratified_sample(i + iFrame);\n\t\t#else\n        vec2 r = get_random();\n        #endif\n        \n        Ray ray;\n\t\tray.origin = cam_center;\n        vec3 ray_dir = normalize(vec3(p + r.x * dFdx(p) + r.y * dFdy(p), -2.5));\n\t\tray.dir = vec3(cam * vec4(ray_dir, 0.0));\n\t\tvec3 c = pt_mis(ray, mat_id, first_hit);\n\t\ts += c;\n\t}\n    s /= float(NUM_SAMPLES);\n    s /= MAX_RADIANCE;\n    \n    // Temporal reprojection and accumulation\n    if (mat_id != uint(0))\n    {\n        float old_time = TIME_FACTOR * (iTime - iTimeDelta); \n        vec3 old_cam_center = vec3(sin(old_time) * 0.25, sin(old_time * 0.7345) * 0.4 + 0.2, 6.0);\n        mat4 old_cam = transpose(look_at(old_cam_center, cam_target, vec3(0, 1, 0)));\n        vec2 old_p = (inverse(old_cam) * vec4(normalize(first_hit - old_cam_center), 0)).xy;\n        old_p = 2.5 * old_p * inversesqrt(1. - dot(old_p, old_p));   \n        if (a < 1.)\n            old_p.y *= a;\n        else\n            old_p.x /= a;\n        old_p = vec2(iResolution.xy) * (old_p + vec2(0.5)) - vec2(0.5);\n\n        BufferA old_pixel = decode_buffer_a(texelFetch(iChannel0, ivec2(old_p), 0));   \n        if (mat_id == old_pixel.mat_id)\n        {\n            s = 0.25 * ALPHA * s + (1. - 0.25 * ALPHA) * old_pixel.radiance;\n        }\n        else\n        {\n            old_p = vec2(0.);\n        }\n        fragColor = encode_buffer_a(BufferA(s, old_p, mat_id));\n    }\n    else\n    {\n        fragColor = vec4(0.);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n#define ALPHA (13./16.)\n#define ENCODE_RES_FACTOR (1./8192.)\n#define ENCODE_VAR_FACTOR 10.\n#define NUM_BOUNCES 4\n#define NUM_SAMPLES 4\n#define INFINITY 9999999.0\n#define MAX_RADIANCE 10.0\n#define MAX_RES 8192.0\n#define PI 3.141592653589\n#define SIGMA_L 8.\n#define SIGMA_T 2.\n#define TIME_FACTOR 1.\n\nstruct BufferA\n{\n    vec3 radiance;\n    vec2 prev_coords;\n    uint mat_id;\n};\n\nstruct BufferBCD\n{\n    vec3 radiance;\n    vec3 variance;\n    uint mat_id;\n};\n\nvec4 encode_buffer_a(BufferA data)\n{\n    return vec4(uintBitsToFloat(packUnorm2x16(vec2(data.radiance.r, ENCODE_RES_FACTOR * data.prev_coords.x))), \n                uintBitsToFloat(packUnorm2x16(vec2(data.radiance.g, ENCODE_RES_FACTOR * data.prev_coords.y))),\n                uintBitsToFloat(packUnorm2x16(vec2(data.radiance.b, 0. ))),\n                uintBitsToFloat(data.mat_id));\n}\n\nvec4 encode_buffer_bcd(BufferBCD data)\n{\n    return vec4(uintBitsToFloat(packUnorm2x16(vec2(data.radiance.r, ENCODE_VAR_FACTOR * data.variance.r))), \n                uintBitsToFloat(packUnorm2x16(vec2(data.radiance.g, ENCODE_VAR_FACTOR * data.variance.g))),\n                uintBitsToFloat(packUnorm2x16(vec2(data.radiance.b, ENCODE_VAR_FACTOR * data.variance.b))),\n                uintBitsToFloat(data.mat_id));\n}\n\nBufferA decode_buffer_a(vec4 encoded)\n{\n    BufferA data;\n    vec2 temp = unpackUnorm2x16(floatBitsToUint(encoded.x));\n    data.radiance.r = temp.x;\n    data.prev_coords.x = temp.y / ENCODE_RES_FACTOR;\n    temp = unpackUnorm2x16(floatBitsToUint(encoded.y));\n    data.radiance.g = temp.x;\n    data.prev_coords.y = temp.y / ENCODE_RES_FACTOR;\n    temp = unpackUnorm2x16(floatBitsToUint(encoded.z));\n    data.radiance.b = temp.x;\n    data.mat_id = floatBitsToUint(encoded.w);\n    return data;\n}\n\nBufferBCD decode_buffer_bcd(vec4 encoded)\n{\n    BufferBCD data;\n    vec2 temp = unpackUnorm2x16(floatBitsToUint(encoded.x));\n    data.radiance.r = temp.x;\n    data.variance.r = temp.y / ENCODE_VAR_FACTOR;\n    temp = unpackUnorm2x16(floatBitsToUint(encoded.y));\n    data.radiance.g = temp.x;\n    data.variance.g = temp.y / ENCODE_VAR_FACTOR;\n    temp = unpackUnorm2x16(floatBitsToUint(encoded.z));\n    data.radiance.b = temp.x;\n    data.variance.b = temp.y / ENCODE_VAR_FACTOR;\n    data.mat_id = floatBitsToUint(encoded.w);\n    return data;\n}\n\nfloat coeffs[7] = float[7]( 1./32., 6./32., 15./32., 20./32., 15./32., 6./32., 1./32. );\n//float coeffs[7] = float[7](0., 1./16., 1./4., 3./8., 1./4., 1./16., 0.);\n//float coeffs[7] = float[7](0., 0., 0.5, 1., 0.5, 0., 0.);\n\nbool material_overlap(uint a, uint b)\n{\n    return a == b || ((a & b) == b && bool(b));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, \n               in  vec2 fragCoord)\n{  \n    BufferA pixel_p_a = decode_buffer_a(texelFetch(iChannel0, ivec2(fragCoord), 0));\n    if (pixel_p_a.mat_id == uint(0))\n    {\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    vec3 u1 = vec3(0.), u2 = vec3(0.), W = vec3(1e-4);\n    for (int i = -3; i < 4; ++i)\n    {\n        for (int j = -3; j < 4; ++j)\n        {\n            ivec2 xy = ivec2(fragCoord) + 1 * ivec2(i, j);\n            BufferA pixel_q_a = decode_buffer_a(texelFetch(iChannel0, xy, 0));\n \n            vec3 w = vec3(float(material_overlap(pixel_p_a.mat_id, pixel_q_a.mat_id)));\n            u1 += w * pixel_q_a.radiance;\n            u2 += w * w * pixel_q_a.radiance * pixel_q_a.radiance;\n            W += w;\n        }\n    }\n    vec3 variance = max(u2 / W - u1 * u1 / (W * W), vec3(0.));\n    \n    vec3 radiance = vec3(0.);\n    W = vec3(0.);\n    for (int i = -3; i < 4; ++i)\n    {\n        for (int j = -3; j < 4; ++j)\n        {\n            ivec2 xy = ivec2(fragCoord) + 1 * ivec2(i, j);\n            BufferA pixel_q_a = decode_buffer_a(texelFetch(iChannel0, xy, 0));\n            \n            vec3 w = vec3(float(material_overlap(pixel_p_a.mat_id, pixel_q_a.mat_id)));\n            w *= exp(-abs(pixel_q_a.radiance - radiance) / (SIGMA_L * sqrt(variance) + vec3(1e-2)));\n            w *= coeffs[i + 3] * coeffs[j + 3];\n            radiance += w * pixel_q_a.radiance;\n            W += w;\n        }\n    }\n    radiance /= W;\n    \n    BufferBCD pixel_p_b = decode_buffer_bcd(texelFetch(iChannel1, ivec2(pixel_p_a.prev_coords), 0));\n    if (pixel_p_a.mat_id == pixel_p_b.mat_id)\n    {\n        vec3 w = vec3(1.0) - 0.9 * exp(-abs(pixel_p_b.radiance - radiance) / (SIGMA_T * sqrt(variance) + vec3(1e-2)));\n        radiance = w * ALPHA * radiance + (1. - w * ALPHA) * pixel_p_b.radiance;\n        variance = w * ALPHA * w * ALPHA * variance + (1. - w * ALPHA) * (1. - w * ALPHA) * pixel_p_b.variance;\n    }\n\n    fragColor = encode_buffer_bcd(BufferBCD(radiance, variance, pixel_p_a.mat_id));\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, \n               in  vec2 fragCoord)\n{\n    BufferBCD pixel_p_b = decode_buffer_bcd(texelFetch(iChannel0, ivec2(fragCoord), 0));\n    if (pixel_p_b.mat_id == uint(0))\n    {\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    vec3 radiance = vec3(0.), variance = vec3(0.), W = vec3(0.);\n    for (int i = -3; i < 4; ++i)\n    {\n        for (int j = -3; j < 4; ++j)\n        {\n            ivec2 xy = ivec2(fragCoord) + 2 * ivec2(i, j);\n            BufferBCD pixel_q_b = decode_buffer_bcd(texelFetch(iChannel0, xy, 0));\n              \n            vec3 w = vec3(float(material_overlap(pixel_p_b.mat_id, pixel_q_b.mat_id)));\n            w *= exp(-abs(pixel_q_b.radiance - pixel_p_b.radiance) / (SIGMA_L * sqrt(pixel_p_b.variance) + vec3(1e-2)));\n            w *= coeffs[i + 3] * coeffs[j + 3];\n            radiance += w * pixel_q_b.radiance;\n            variance += w * pixel_q_b.variance;\n            W += w;\n        }\n    }\n    radiance /= W;\n    variance /= W * W;\n          \n    BufferA pixel_p_a = decode_buffer_a(texelFetch(iChannel2, ivec2(fragCoord), 0));\n    BufferBCD pixel_p_c = decode_buffer_bcd(texelFetch(iChannel1, ivec2(pixel_p_a.prev_coords), 0));\n    if (pixel_p_c.mat_id == pixel_p_b.mat_id)\n    {\n        vec3 w = vec3(1.) - 0.9 * exp(-abs(pixel_p_c.radiance - radiance) / (SIGMA_T * sqrt(variance) + vec3(1e-2)));\n        radiance = w * ALPHA * radiance + (1. - w * ALPHA) * pixel_p_c.radiance;\n        variance = w * ALPHA * w * ALPHA * variance + (1. - w * ALPHA) * (1. - w * ALPHA) * pixel_p_c.variance;\n    }\n    \n    fragColor = encode_buffer_bcd(BufferBCD(radiance, variance, pixel_p_b.mat_id));\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, \n               in  vec2 fragCoord)\n{\n    BufferBCD pixel_p_c = decode_buffer_bcd(texelFetch(iChannel0, ivec2(fragCoord), 0));\n    if (pixel_p_c.mat_id == uint(0))\n    {\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    vec3 radiance = vec3(0.), variance = vec3(0.), W = vec3(0.);\n    for (int i = -3; i < 4; ++i)\n    {\n        for (int j = -3; j < 4; ++j)\n        {\n            ivec2 xy = ivec2(fragCoord) + 4 * ivec2(i, j);\n            BufferBCD pixel_q_c = decode_buffer_bcd(texelFetch(iChannel0, xy, 0));\n              \n            vec3 w = vec3(float(material_overlap(pixel_p_c.mat_id, pixel_q_c.mat_id)));\n            w *= exp(-abs(pixel_q_c.radiance - pixel_p_c.radiance) / (SIGMA_L * sqrt(pixel_p_c.variance) + vec3(1e-2)));\n            w *= coeffs[i + 3] * coeffs[j + 3];\n            radiance += w * pixel_q_c.radiance;\n            variance += w * pixel_q_c.variance;\n            W += w;\n        }\n    }\n    radiance /= W;\n    variance /= W * W;\n          \n    BufferA pixel_p_a = decode_buffer_a(texelFetch(iChannel2, ivec2(fragCoord), 0));\n    BufferBCD pixel_p_d = decode_buffer_bcd(texelFetch(iChannel1, ivec2(pixel_p_a.prev_coords), 0));\n    if (pixel_p_d.mat_id == pixel_p_c.mat_id)\n    {\n        vec3 w = vec3(1.) - 0.9 * exp(-abs(pixel_p_d.radiance - radiance) / (SIGMA_T * sqrt(variance) + vec3(1e-2)));\n        radiance = w * ALPHA * radiance + (1. - w * ALPHA) * pixel_p_d.radiance;\n        variance = w * ALPHA * w * ALPHA * variance + (1. - w * ALPHA) * (1. - w * ALPHA) * pixel_p_d.variance;\n    }\n    \n    fragColor = encode_buffer_bcd(BufferBCD(radiance, variance, pixel_p_c.mat_id));\n}","name":"Buffer D","description":"","type":"buffer"}]}