{"ver":"0.1","info":{"id":"ws2Gz1","date":"1548208474","viewed":117,"name":"cant believe the way we flow","username":"wombleman","description":"inspired by the song, 'Can't Believe The Way We Flow' - James Blake","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["flow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision mediump float;\n\nconst float PI = 3.14159265359;\nconst int numberOfAxis = 10;\n\nconst float eps = 0.0000001;\n\n\nint intModulo(float a,float b) {\n    float m = mod(a, b);\n    return int(m+0.5);\n}\n\nvec4 colorCycle(vec4 inputColor, float offset) {\n\n\tfloat U = 1.0 + cos(offset * 0.9) * 3.0;\n\tfloat W = 1.0 + sin(offset * 0.9) * 3.0;\n    vec4 outputColor;\n\n\toutputColor.r = (.299+.701*U+.168*W)*inputColor.r\n\t+ (.587-.587*U+.330*W)*inputColor.g\n\t+ (.114-.114*U-.497*W)*inputColor.b;\n\toutputColor.g = (.299-.299*U-.328*W)*inputColor.r\n\t+ (.587+.413*U+.035*W)*inputColor.g\n\t+ (.114-.114*U+.292*W)*inputColor.b;\n\toutputColor.b = (.299-.3*U+1.25*W)*inputColor.r\n\t+ (.587-.588*U-1.05*W)*inputColor.g\n\t+ (.114+.886*U-.203*W)*inputColor.b;\n    outputColor.a = inputColor.a;\n\t\n\treturn outputColor;\n}\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 rgb2hsv( in vec3 c)\n{\n    vec4 k = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);\n    vec4 p = mix(vec4(c.zy, k.wz), vec4(c.yz, k.xy), (c.z<c.y) ? 1.0 : 0.0);\n    vec4 q = mix(vec4(p.xyw, c.x), vec4(c.x, p.yzx), (p.x<c.x) ? 1.0 : 0.0);\n    float d = q.x - min(q.w, q.y);\n    return vec3(abs(q.z + (q.w - q.y) / (6.0*d+eps)), d / (q.x+eps), q.x);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float angleFrac = (2.0 * PI) / float(2 * numberOfAxis);\n\n    vec2 c = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float phi = abs(atan(c.y, c.x)); \n    float r = length(c)*1.0;\n    float blah = r;\n    r = 0.1+pow(r,0.3);\n\tr += 0.02*sin((0.13+phi)*12.0);\n    float rahh = iTime * 2.0;\n    if (mod(r*10.0,1.0)<0.5) rahh *= -1.0;\n    r += 0.002*sin((0.13+phi)*100.0+rahh);\n    int count = int(phi / angleFrac);\n\n    phi = 0.0;\n    float x = r * cos(phi);\n    float y = r * sin(phi);\n\n    float frame = iTime * 0.003;\n    float zoom = 1.0;// + sin(iTime * 0.3) / 3.0;\n\t\n    vec2 cc = (vec2(x,y) * zoom) + frame; //map to range [0.0, 1.0]\n    vec4 color = texture(iChannel0, cc);\n    vec3 rgb = colorCycle(color, 0.15).xyz;\n    vec3 hsv = rgb2hsv(rgb);\n    hsv.z = pow(hsv.z,2.0);\n    hsv.y *= 0.5;\n    hsv.x *= 2.0;\n    hsv.x += 0.75;\n    r+= 0.3;\n    hsv.x += r*0.1+0.1;\n    hsv.y *= (r+0.4);\n    //hsv.z *= pow(r,0.5);\n    hsv.z = max(hsv.z,0.3);\n    hsv.x += 0.03;\n    vec3 rgb2 = hsv2rgb(hsv);\n    fragColor = vec4(rgb2, 1.0);\n}","name":"Image","description":"","type":"image"}]}