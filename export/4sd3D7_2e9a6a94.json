{"ver":"0.1","info":{"id":"4sd3D7","date":"1450150906","viewed":1002,"name":"Apollonian Voronoi","username":"rwvens","description":"Just a couple quick changes to iq's smooth voronoi shader to use what's called multiplicative weighting, or apollonian metric if I'm not mistaken. I'm using something like it in the procedural generation for a 2D strategy game I'm working on.","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["voronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Modified to use multiplicative weighting by Reinier Vens\n\n// Smooth Voronoi - avoiding aliasing, by replacing the usual min() function, which is\n// discontinuous, with a smooth version. That can help preventing some aliasing, and also\n// provides with more artistic control of the final procedural textures/models.\n\n// The parameter w controls the smoothness\n\nfloat hash1( float n ) { return fract(sin(n)*43758.5453); }\nvec2  hash2( vec2  p ) { p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) ); return fract(sin(p)*43758.5453); }\n\nvec4 voronoi( in vec2 x, float w )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec4 m = vec4( 8.0, 0.0, 0.0, 0.0 );\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n        vec2 o = hash2( n + g );\n        float weight = o.x * .5 + .5;\n\t\t\n\t\t// animate\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n\n        // distance to cell\t\t\n\t\tfloat d = length(g - f + o) * weight;\n\t\t\n        // do the smoth min for colors and distances\t\t\n\t\tvec3 col = 0.5 + 0.5*sin( hash1(dot(n+g,vec2(7.0,113.0)))*2.5 + 3.5 + vec3(2.0,3.0,2.0));\n\t\tfloat h = smoothstep( 0.0, 1.0, 0.5 + 0.5*(m.x-d)/w );\n\t\t\n\t    m.x   = mix( m.x,     d, h ) - h*(1.0-h)*w/(1.0+3.0*w); // distance\n\t\tm.yzw = mix( m.yzw, col, h ) - h*(1.0-h)*w/(1.0+3.0*w); // color\n    }\n\t\n\treturn m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy/iResolution.yy;\n\t\n\t//float k = 2.0 + 70.0 * pow( 0.5 + 0.5*sin(0.25*6.2831*iTime), 4.0 );\n\t//k = 0.5 - 0.5*cos(0.25*6.2831*iTime);\n    vec4 c = voronoi( 6.0*p, .005 );\n\n    vec3 col = c.yzw;\n\t\n\tcol *= 1.0 - .1 * smoothstep(0.04,0.05,c.x);//*step(p.y,0.33);\n\t//col *= mix(c.x,1.0,step(p.y,0.66));\n\t\n\t//col *= smoothstep( 0.005, 0.007, abs(p.y-0.33) );\n\t//col *= smoothstep( 0.005, 0.007, abs(p.y-0.66) );\n\t\n    fragColor = vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}