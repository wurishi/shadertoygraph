{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// 不同的palette映射函数，将t映射为较柔和的渐变色彩\nvec3 palette( float t ) {\n    // 使用不同的参数来产生与原版不一样的调色板效果\n    vec3 a = vec3(0.3, 0.3, 0.4);\n    vec3 b = vec3(0.3, 0.2, 0.1);\n    vec3 c = vec3(1.0, 0.9, 0.7);\n    vec3 d = vec3(0.0,0.15,0.35);\n    return a + b*cos(6.28318*(c*t+d));\n}\n\n// 简单的2D旋转函数\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // 标准化坐标，中心为0\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    \n    vec3 finalColor = vec3(0.0);\n    float time = iTime*0.4;\n    \n    // 将原来的循环次数和变化进行调整\n    for (float i = 0.0; i < 5.0; i++) {\n        // 增加旋转和缩放，使uv在每次迭代中变得不同\n        uv = uv * 1.2; \n        uv = uv * rot(0.4 + time*0.1 + i*0.5);\n        uv = fract(uv+0.5)-0.5; // 保留fractal特征，但加入旋转\n        \n        // 根据uv计算距离\n        float d = length(uv)*exp(-length(uv0)*0.7);\n        \n        // 使用新的palette和不同的时间偏移\n        vec3 col = palette(length(uv0)*0.5 + i*0.3 + time*0.7);\n        \n        // 使用sin与cos结合制造干涉条纹\n        float wave = sin(d*10.0 - time*2.0) * cos(d*10.0 + time);\n        wave = abs(wave);\n        \n        // 调整强度和衰减函数，增加exponential衰减\n        float intensity = pow(0.02 / (wave + 0.001), 1.1);\n        \n        // 将本次迭代颜色叠加\n        finalColor += col * intensity;\n    }\n    \n    // 输出颜色\n    fragColor = vec4(finalColor, 1.0);\n}\n\n\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"McVfWD","date":"1734064048","viewed":42,"name":"Whisper","username":"EileenXxx","description":"1","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["1"],"hasliked":0,"parentid":"","parentname":""}}