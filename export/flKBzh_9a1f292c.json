{"ver":"0.1","info":{"id":"flKBzh","date":"1664047232","viewed":61,"name":"squaring the circle","username":"DjinnKahn","description":"The same three pieces make a square and a circle. One of the pieces is scaled.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["fractal","recursive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float CIRCLE_SIZE = 1.;\nconst float BOX_SIZE = .6;\nconst float BOX_OFFSET = -.1;\nconst float RECURSIVE_SCALE = 3.;\n\nfloat opSubtraction( float d1, float d2 ) { return max(d1,-d2); }\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCirclyShape( vec2 p )\n{\n    float d = sdCircle( p, CIRCLE_SIZE );\n    d = opSubtraction( d, sdBox( p - vec2( 1. - BOX_SIZE ), vec2( 1., 1. ) ) );\n    d = opSubtraction( d, sdBox( p - vec2( 1. + BOX_SIZE, 0. ), vec2( 1., 5. ) ) );\n    return d;\n}\n\nfloat sdRecursiveCirclyShape( vec2 p )\n{\n    vec2 off = -vec2(BOX_SIZE, BOX_OFFSET);\n        \n    float d = 999.;\n    float totalScale = 1.;\n    for ( int i = 0; i < 8; i++, totalScale *= RECURSIVE_SCALE )\n    {\n        d = opUnion( d, sdCirclyShape( p ) / totalScale ); \n        p = (p-off) * -RECURSIVE_SCALE - off;   \n    }\n    return d;\n}\n\nfloat sdRecursiveBoxShape( vec2 p )\n{    \n    float d = sdBox( p, vec2( BOX_SIZE ) );\n    d = opSubtraction( d, sdRecursiveCirclyShape( p ) );\n    d = opSubtraction( d, sdRecursiveCirclyShape( -p ) );\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    p *= RECURSIVE_SCALE * BOX_SIZE * 1.02;\n    \n    float time = mod( iTime, 8. );  \n    \n    float circleTime = smoothstep( .8, 1.6, time ) - smoothstep( 4. + .8, 4. + 1.6, time );\n    float boxTime = smoothstep( 2., 2.8, time ) - smoothstep( 4. + 2., 4. + 2.8, time );\n    \n    float boxScale = mix( 1., RECURSIVE_SCALE, boxTime );\n    float dBox = sdRecursiveBoxShape( p / boxScale ) * boxScale;\n    \n    vec2 circleOffset = mix( vec2( 0. ), vec2( BOX_SIZE * (RECURSIVE_SCALE-1.), BOX_OFFSET*(RECURSIVE_SCALE-1.) ), circleTime );\n    circleOffset.y -= 3. * circleTime * (1.-circleTime);\n    float dCircle0 = sdRecursiveCirclyShape( p - circleOffset );\n    float dCircle1 = sdRecursiveCirclyShape( -p - circleOffset );\n    \n    float feathering = .005;\n    float colCircle0 = smoothstep( feathering, -feathering, dCircle0 ); \n    float colCircle1 = smoothstep( feathering, -feathering, dCircle1 ); \n    float colBox = smoothstep( feathering, -feathering, dBox ); \n        \n    float opacity = .9;\n    vec3 col = vec3( .2, .3, .2 );\n    col = mix( col, vec3( .7, .4, .2 ), colBox );\n    col = mix( col, vec3( .8, .6, .1 ), colCircle0 * opacity );\n    col = mix( col, vec3( .3, .7, .1 ), colCircle1 * opacity );\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}