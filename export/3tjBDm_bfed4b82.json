{"ver":"0.1","info":{"id":"3tjBDm","date":"1599105682","viewed":770,"name":"grass on heightmap","username":"osadchy","description":"Attempt to create grass material that will look okay on terrain","likes":28,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","terrain","grass","heightmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// *********\n// * grass *\n// *********\n\nconst float GAMMA = 2.2;\n\nconst float LIGHT_BRIGHTNESS = 2.0;\nconst vec3 \tLIGHT_COLOR = vec3(1, 0.9, 0.7) * LIGHT_BRIGHTNESS;\n\nconst float AMBIENT_BRIGHTNESS = 0.5;\nconst vec3 AMBIENT_COLOR = vec3(0.4, 0.55, 0.8) * AMBIENT_BRIGHTNESS;\n\nfloat get_mipmap_level(vec2 uv) {\n    vec2 dx = dFdx(uv);\n    vec2 dy = dFdy(uv);\n    return 0.5 * log2(max(dot(dx, dx), dot(dy, dy)));\n}\n\nvec4 sample_noise(sampler2D sampler, vec2 uv) {\n    ivec2 tex_size = textureSize(sampler, 0);\n    float mipmap_level = max(get_mipmap_level(uv * vec2(tex_size)), 0.0);\n    int lod = int(floor(mipmap_level));\n    float mix_factor = fract(mipmap_level);\n    ivec2 texcoords = ivec2(fract(uv) * vec2(tex_size));\n    texcoords /= int(pow(2.0, float(lod)));\n    texcoords *= int(pow(2.0, float(lod)));\n    ivec2 next_texcoords = texcoords;\n    next_texcoords /= int(pow(2.0, float(lod + 1)));\n    next_texcoords *= int(pow(2.0, float(lod + 1)));\n    return mix(texelFetch(sampler, texcoords, 0), texelFetch(sampler, next_texcoords, 0), mix_factor);\n}\n\nfloat get_occlusion_factor(vec3 normal, vec3 sight_dir) {\n    return abs(dot(sight_dir, normal));\n}\n\nfloat get_specular_factor(vec2 uv, vec3 normal, vec3 sight_dir) {\n    float occlusion_factor = 1.0 - get_occlusion_factor(normal, sight_dir);\n    float texture_factor = texture(iChannel1, uv * 0.9 + vec2(0.5)).x;\n\treturn pow(texture_factor, 2.0) * pow(occlusion_factor, 5.0);\n}\n\nvec3 get_noisy_normal(vec2 uv, vec3 normal, vec3 sight_dir) {\n    float noise_factor = pow(clamp(1.5 - abs(normal.z), 0.0, 1.0), 0.5) * 0.9;\n\tvec3 noisy_normal = normalize(normal + noise_factor * (sample_noise(iChannel0, uv).xyz - 0.5));\n    float mix_factor = pow(get_occlusion_factor(normal, sight_dir), 0.5);\n    return mix(normal, noisy_normal, mix_factor);\n}\n\nvec3 get_diffuse_color(vec2 uv, vec3 normal, vec3 sight_dir) {\n    vec3 base = vec3(0.02, 0.015, 0.005) * 0.5;\n    vec3 middle = vec3(0.1, 0.2, 0.0);\n    vec3 top = middle;\n    \n    float occlusion_factor = 1.0 - pow(1.0 - get_occlusion_factor(normal, sight_dir), 2.0);\n    \n    float base_factor = (1.0 - sample_noise(iChannel1, uv).x) * 2.0;\n    base_factor = clamp(base_factor - occlusion_factor, 0.0, 1.0);\n    base_factor = pow(base_factor, 0.5);\n    \n    float top_factor = sample_noise(iChannel1, uv).x * 1.5;\n    top_factor = clamp(top_factor - occlusion_factor, 0.0, 1.0);\n    top_factor = pow(top_factor, 1.0);\n    \n    vec3 color = mix(base, middle, base_factor);\n    color = mix(color, top, top_factor);\n    return color;\n}\n\nfloat light_ambient(vec2 uv, vec3 normal, vec3 sight_dir) {\n    float ao_original = sample_noise(iChannel1, uv).x;\n    float ao_decay = pow(get_occlusion_factor(normal, sight_dir), 2.0);\n    return mix(1.0, ao_original, ao_decay);\n}\n\nfloat light_diffuse(vec3 normal, vec3 light_dir, float scattering) {\n    float result = clamp(dot(-light_dir, normal) * (1.0 - scattering) + scattering, 0.0, 1.0);\n    return result;\n}\n\nfloat light_specular(vec3 normal, vec3 light_dir, vec3 sight_dir, float shininess, float scattering) {\n    vec3 reflected = reflect(light_dir, normal);\n    float result = max(dot(-sight_dir, reflected), 0.0);\n    result *= max(sign(dot(normal, -light_dir)), 0.0);\n    result = max(result * (1.0 - scattering) + scattering, 0.0);\n    result = pow(result, shininess);\n    return result;\n}\n\nvec3 render_grass(vec3 normal, vec2 uv, vec3 sight_dir, vec3 light_dir, vec3 light_color, vec3 ambient_color) {\n    vec3 noisy_normal = get_noisy_normal(uv, normal, sight_dir);\n    vec3 color = get_diffuse_color(uv, normal, sight_dir);\n    \n    float ambient = light_ambient(uv, noisy_normal, sight_dir) * 1.0;\n    \n    float diffuse = light_diffuse(noisy_normal, light_dir, 0.1) * 1.0;\n    diffuse *= 0.8 + pow(1.0 - get_occlusion_factor(normal, sight_dir), 5.0) * 0.5;\n\n    float specular = light_specular(noisy_normal, light_dir, sight_dir, 2.0, 0.0) * 0.75;\n    specular *= get_specular_factor(uv, noisy_normal, sight_dir);\n    \n    color *= (ambient * ambient_color + diffuse * light_color);\n    color += vec3(1.0, 1.0, 0.1) * light_color * specular;\n    return color;\n}\n\n// *************\n// * heightmap *\n// *************\n\nint TRACE_STEPS = 250;\nfloat STEP_LENGTH = 0.75;\nfloat FOCAL_LENGTH = 1.30;\n\nfloat get_height(vec2 pos) {\n    return pow(textureLod(iChannel3, pos * 0.03, 0.0).r, 1.5) * 1.5 - pow(length(pos), 2.0) * 0.002;\n}\n\nfloat get_distance(vec3 pos) {\n    return pos.z - get_height(pos.xy);\n}\n\nvec3 get_normal(vec3 pos) {\n    const vec3 small_step = vec3(1e-1, 0.0, 0.0);\n\n    float gradient_x = get_distance(pos + small_step.xyy) - get_distance(pos - small_step.xyy);\n    float gradient_y = get_distance(pos + small_step.yxy) - get_distance(pos - small_step.yxy);\n    float gradient_z = get_distance(pos + small_step.yyx) - get_distance(pos - small_step.yyx);\n    \n    return normalize(vec3(gradient_x, gradient_y, gradient_z));\n}\n\nbool trace(vec3 ray_origin, vec3 ray_dir, out vec3 hit_pos, out vec3 hit_normal) {\n    for (int i = 0; i < TRACE_STEPS; ++i) {\n        float dist = get_distance(ray_origin);\n        ray_origin += ray_dir * dist * STEP_LENGTH;\n        if (ray_origin.z > 3.0 && ray_dir.z > 0.0) {\n            break;\n        }\n        if (dist < 1e-2) {\n            hit_pos = ray_origin;\n            hit_normal = get_normal(hit_pos);\n            return true;\n        }\n    }\n    return false;\n}\n\n// *********\n// * image *\n// *********\n\nvec3 LIGHT_DIR = normalize(vec3(2, 0, -1));\n\nvoid mainImage( out vec4 frag_color, in vec2 frag_coord )\n{\n    float phase = - iTime * 0.2 + 2.0;\n    vec3 camera_pos = vec3(10.0 * sin(phase), 10.0 * cos(phase), 2);\n    vec3 camera_dir = normalize(-camera_pos);\n    vec3 camera_up = normalize(vec3(0, 0, 1) - camera_dir * camera_dir.z);\n    vec3 camera_right = normalize(cross(camera_dir, camera_up));\n    \n    vec2 uv = (2.0 * frag_coord - vec2(iResolution)) / iResolution.y;\n    \n    vec3 ray_dir = normalize(camera_dir * FOCAL_LENGTH + camera_right * uv.x + camera_up * uv.y);\n    vec3 ray_origin = camera_pos;\n    \n    vec3 hit_pos, hit_normal;\n    if (trace(ray_origin, ray_dir, hit_pos, hit_normal)) {\n        vec3 normal = hit_normal;\n        vec2 uv = hit_pos.xy; \n        vec3 sight_dir = normalize(hit_pos - camera_pos); \n        vec3 light_dir = LIGHT_DIR;\n        vec3 light_color = LIGHT_COLOR;\n        float dist = length(hit_pos - ray_origin);\n        \n        bool shadow = trace(hit_pos + vec3(0, 0, 1e-2), -light_dir, hit_pos, hit_normal);\n        if (shadow) {\n            light_color = vec3(0);\n        }\n        \n        vec3 ambient_color = AMBIENT_COLOR;\n        vec3 grass = render_grass(normal, uv, sight_dir, light_dir, light_color, ambient_color);\n        grass = mix(ambient_color, grass, exp(- dist * 0.01));\n        frag_color = vec4(grass, 1.0);\n    } else {\n        frag_color = vec4(mix(AMBIENT_COLOR, vec3(1), uv.y), 1);\n    }\n    \n    // Gamma-correction\n    frag_color = pow(frag_color, vec4(1.0 / GAMMA));\n}","name":"Image","description":"","type":"image"}]}