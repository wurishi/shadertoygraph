{"ver":"0.1","info":{"id":"ftK3RG","date":"1637987641","viewed":96,"name":"Video Cube","username":"rmmcal","description":"cube, video, raymarching","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","video","cube"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////////////////////////////////////////////\n//              ...  Video Cube ...                      ////\n/////////////////////////////////////////////////////////////\n// Brasil/Amazonas/Manaus\n// Created by Rodrigo Cal (twitter: @rmmcal)\n// - Published: 2021/11\n// https://www.shadertoy.com/view/ftK3RG\n/////////////////////////////////////////////////////////////\n\nconst float pi = 3.1415926;\nconst float pi2 = 2.*pi;\nconst float rad = pi/180.;\n\nmat2 rotate(float x){\n    float c = cos(x);\n    float s = sin(x);\n    return mat2(c,s,-s,c);\n}\n\nfloat sdBox( vec3 p, vec3 b ) // https://iquilezles.org/articles/distfunctions\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nstruct march{\n     float x;\n     vec3 p;\n     float id;\n};\n\nmarch mac(float x){\n    march m;\n    m.x = x;\n    return m;\n}\n\nmarch mac(float x, vec3 p){\n    march m;\n    m.x = x;\n    m.p = p;\n    return m;\n}\n\nmarch mac(float x, vec3 p, float id){\n    march m;\n    m.x = x;\n    m.p = p;\n    m.id = id;\n    return m;\n}\n\nmarch vmin(march d, march v){\n    if (d.x > v.x)\n        return v;\n    else \n        return d;\n   \n}\n\nbool renderFloor = true;\nmarch dist(vec3 p)\n{\n    march d = mac( 1.0 );\n    \n    d = vmin(d, mac(-p.z+7., p, 1.0));\n  \n    if (renderFloor){\n      vec3 p1 = p;\n      p1.yz *= rotate(-.15);\n      p1.yz *= rotate(cos((p1.x+p1.z+cos(p1.y+p.z))*2.+iTime)*.04);\n      d = vmin(d, mac(sdBox(p1-vec3(0.0,-2.,0.), vec3(4.0,0.1,4.)),p,1.0));\n    }\n    \n    p.z+=-2.;\n    p.y+=cos(iTime*1.5)-1.;\n    p.x+=cos(iTime);\n    p.xz *= rotate(iTime);\n    p.yz *= rotate(iTime*.3);    \n    d = vmin(d, mac(sdBox(p, vec3(1.0)),p));\n    \n    return d;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 d = vec2(0., 0.01);\n    float x = dist(p-d.yxx).x;\n    float y = dist(p-d.xyx).x;\n    float z = dist(p-d.xxy).x;\n    return normalize(vec3(x,y,z)-dist(p).x);\n}\n\nstruct raymarch{\n    float t; // distance\n    vec3 p;  // position\n    vec3 d;  // direction\n    march h; // hit\n    vec3 c;  // inv glow\n    vec3 b;  // glow\n    float m; // min hit\n    vec3 pn; // normal\n    vec3 dr; // reflect\n    vec3 pd; // penultimate hit\n    float len;\n};\n\nraymarch raymarching(vec3 p1, vec3 d1, float len, float maxd, float mind){\n    raymarch r;\n    r.t = 0.;\n    r.p = p1 ;\n    r.d = d1;\n    r.h;\n    r.c *= 0.0;\n    r.m  = 1.0;\n    int lenb = int(len);\n    for (int i = 0 ; i < lenb; i++)\n    {\n        r.h  = dist(r.p );\n        float h = r.h.x;\n        h = min(h, mind);\n        h = max(h, maxd);\n        //if (h < 0.01)\n        //  break;\n        r.t+=h;\n        r.p += r.d*h;\n        r.m = min(r.m, h);\n        r.c += r.m;\n        //r.b += 1./(sqrt(r.m));\n    }\n    r.c /= (len);  \n    r.b =  vec3(clamp(1.0-r.c*5.5,0.,1.));\n    r.len = len;\n    r.pn = getNormal(r.p); \n    r.dr = reflect( r.d, getNormal(r.p) ); \n    r.pd = r.p - r.d;\n    return r;\n}\n\nvec3 getVideoColor(raymarch r)\n{\n    return clamp(texture(iChannel0, ( (r.h.p.xy+vec2(r.h.p.z, 0.0))*vec2(0.25,.5)+vec2(0.5,.5)) ).rgb*vec3(r.pn.z),0.0,1.0);\n}\n\nfloat getFloorColor(raymarch r){\n\n    return clamp( step(.9, (r.h.id) ) + step(.9, abs(r.h.p.y) ), 0., 1. );\n    \n}\n\nvoid background(vec2 uv, inout vec3 c){\n    if (iTime < 20.0)\n        c += texture(iChannel0, mod(uv*10.0,1.0)).rgb*.5;\n    else\n        c += texture(iChannel0, uv).rgb*.5;\n\n    vec2 uvid = (floor(uv*10.0));\n    float index = mod(10.-uvid.y, 10.0)+ uvid.x/10.;\n    vec2 uvr = (mod(uv*10.0,1.0));\n    c *= smoothstep(0.,.1, uvr.x) ;     \n    c *= smoothstep(0.,.1, uvr.y) ;  \n    c *= smoothstep(-0.,1.,pow(iTime*5.+11.,1.0)-length(uvr-.5)-index*10.0)+.1 ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pc = (uv-.5)*vec2(1, iResolution.y/iResolution.x);\n    vec3 p1 = vec3(0,0.,-8);\n    vec3 d1 = normalize(vec3(pc,1.0));\n    \n    raymarch rFirst   = raymarching( p1, d1, 70. , .0, 1.);\n   \n    raymarch rShadow  = raymarching( rFirst.pd, vec3(0,1,0), 10., 0.0, 1. );\n    \n    raymarch rReflect = raymarching( rFirst.pd, rFirst.dr, 10., 0.0, 1. );\n    \n    renderFloor = false;\n    raymarch rGlow  = raymarching( p1, d1, 70. , .0, .5);\n     \n    vec3 c = getVideoColor(rFirst);                                      // ambient\n   \n    c = mix(c, vec3(0.3,0.7,rFirst.pn.z), getFloorColor(rFirst));        // color floor\n    \n    c += getVideoColor(rReflect);                                        // reflect\n    \n    c = c * rShadow.c+.25;                                               // shadow\n\n    c += pow(clamp(+1.-rFirst.pn.z, 0., 1.0), 20.0);                     // specular\n    \n    if (rFirst.t>15.0) background(uv, c);                                // background\n    \n    c = mix(c, vec3(0.0), smoothstep(0.0, 1.0, -.3+length(uv-.5))+.2);   // fade\n    \n    c += vec3(rGlow.b);                                                  // glow \n    \n    c += vec3(clamp(.9+pow(cos(iTime),1.0)*1.0-rGlow.c*8.,0.,1.));       // glow extra\n \n    fragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}]}