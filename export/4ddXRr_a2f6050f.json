{"ver":"0.1","info":{"id":"4ddXRr","date":"1536109791","viewed":197,"name":"Raytraced Rotating Hypercube","username":"RolandRock","description":"Just a 4D cube rotating","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float maxVal = 999999999999999999999.;\n\nfloat zoom = 500.;\n//In this case I am using \"threespace\" to refer to a hyperplane in 4-space (i.e. a 3-dimensional subset of 4-space);\nfloat threespaceY = -500.;\nconst int AA_AMOUNT = 4;\n\nmat4 RotXYPlane(float angle)\n{\n    return mat4(cos(angle), -sin(angle), 0, 0,\n                sin(angle),  cos(angle), 0, 0,\n                         0,           0, 1, 0,\n                         0,           0, 0, 1);\n}\nmat4 RotXZPlane(float angle)\n{\n     return mat4( cos(angle), 0, sin(angle), 0,\n                           0, 1,          0, 0,\n                 -sin(angle), 0, cos(angle), 0,\n                 0,           0,          0, 1);\n}\nmat4 RotYZPlane(float angle)\n{\n     return mat4(1, 0,          0,           0,\n                 0, cos(angle), -sin(angle), 0,\n                 0, sin(angle),  cos(angle), 0,\n                 0, 0,          0,           1);\n}\n\nmat4 RotXWPlane(float angle)\n{\n     return mat4(cos(angle), 0, 0, sin(angle),\n                          0, 1, 0,           0,\n                          0, 0, 1,           0,\n                 -sin(angle), 0, 0,  cos(angle));\n}\nmat4 RotYWPlane(float angle)\n{\n     return mat4(1,          0,           0,           0,\n                 0, cos(angle),           0, -sin(angle),\n                 0,          0,           1,           0,\n                 0, sin(angle),           0,  cos(angle));\n}\nmat4 RotZWPlane(float angle)\n{\n     return mat4(1, 0,           0,          0,\n                 0, 1,           0,          0,\n                 0, 0,  cos(angle),  sin(angle),\n                 0, 0, -sin(angle),  cos(angle));\n}\n\n\nvec4 Reflect(vec4 normal, vec4 dir)\n{\n    vec4 n = normalize(normal);\n    return dir - (2.*dot(dir, n))*n;\n}\n\nstruct Ray\n{\n    vec4 origin;\n    vec4 direction;\n};   \nvec4 PointAt(Ray ray, float val)\n{\n    return ray.origin + val * ray.direction;\n}\n\nstruct Hit\n{\n    bool isHit;\n    float dist;\n    vec3 color;\n};\n\nstruct Rect\n{\n    vec4 center;\n    vec4 radii;\n    mat4 rotationMatrix;\n};   \nHit RectHit(Rect cube, Ray ray)\n{\n    ray.direction = cube.rotationMatrix * ray.direction;\n    ray.origin = cube.center + (cube.rotationMatrix * (ray.origin - cube.center));\n    \n    vec4 upperBounds = cube.center + cube.radii;\n    vec4 lowerBounds = cube.center - cube.radii;\n    \n    vec4 vals1 = (upperBounds - ray.origin)/ray.direction;\n    vec4 vals2 = (lowerBounds - ray.origin)/ray.direction;\n    \n    bool hit = false;\n    float closestVal = maxVal;\n    vec3 color = vec3(0.);\n    \n    for(int comp = 0; comp < 4; comp++)\n    {\n        vec2 vals = vec2(vals1[comp], vals2[comp]);\n        //vec4 precolor = vec4(0.);\n        //precolor[comp] = 1.;\n        \n        for(int valNum = 0; valNum < 2; valNum++)\n        {\n            float val = vals[valNum];\n            if(val < closestVal && val > 0.)\n            {\n                vec4 pt = PointAt(ray, val);\n                bvec4 greaterThanLower = greaterThanEqual(pt, lowerBounds);\n                bvec4 lessThanUpper = lessThanEqual(pt, upperBounds);\n                greaterThanLower[comp] = lessThanUpper[comp] = true;\n                if(all(greaterThanLower) && all(lessThanUpper))\n                {\n                    int uid = comp * 2 + valNum;\n                    closestVal = val;\n                    color = vec3(mod(float(uid), 2.), mod(float(uid/2), 2.), mod(float(uid/4), 2.));\n                    //color = vec3(1.) * (pt.w - (cube.center.w - cube.radius)) / (cube.radius * 2.);\n                    hit = true;\n                }\n            }\n        }\n    }\n    \n    return Hit(hit, closestVal, color);\n    \n}\n    \nstruct Sphere\n{\n    vec4 center;\n    float radius;\n    vec3 color;\n};\nHit SphereHit(Sphere sphere, Ray ray)\n{\n    vec4 adjIntercept = ray.origin - sphere.center;\n    float a = dot(ray.direction, ray.direction);\n    float b = dot(ray.direction, adjIntercept) * 2.;\n    float c =  dot(adjIntercept, adjIntercept) - (sphere.radius * sphere.radius);\n    \n    if(a < 0.) return Hit(false, 0., vec3(0.)); //No dividing by zero\n    float numToSqrt = b*b - 4.*a*c;\n    if(numToSqrt < 0.) return Hit(false, 0., vec3(0.));\n    float high = (-b + sqrt(numToSqrt))/(2. * a);\n    float low  = (-b - sqrt(numToSqrt))/(2. * a);\n    \n    if(high <= 0. && low <= 0.) return Hit(false, 0., vec3(0.));\n    if (low <= 0.) return Hit(true, high, sphere.color);\n    return Hit(true, low, sphere.color);  \n}\n\nHit ThreespaceHit(Ray ray)\n{\n    float val = (threespaceY - ray.origin.y)/ray.direction.y;\n    if(val > 0. /*&& PointAt(ray, val).w == 0.*/)\n    {\n        vec4 point = PointAt(ray, val);\n\n        vec3 color;\n        point = mod(point/100., 2.);\n        //3-way XOR\n        if (((point.x < 1.) != (point.z < 1.)) != (point.w < 1.)) \n            color = vec3(1.);\n        else\n            color = vec3(0.);\n        \n        return Hit(true, val, color);\n    }\n    else\n    \treturn Hit(false, val, vec3(0)); \n    \n}\n\nvec4 ColorAt(vec2 pixelCoord)\n{\n    float a = iTime / 3.;\n    mat4 rotMatrix = RotYZPlane(0.3) * RotXZPlane(a);\n    \n    //Generate ray\n    vec2 adjPixel = pixelCoord - iResolution.xy/2.;\n    vec4 baseRayDir = vec4(adjPixel/zoom, 1., 0);\n    \n    Ray ray = Ray(vec4(0., 0., -1500., 0.) * rotMatrix, \n                  baseRayDir * rotMatrix);\n        \n    Rect rect = Rect(vec4(0., 0., 0., 0.), \n                     vec4(250., 250., 250., 250.), \n                     RotXWPlane(a * 3.)*RotZWPlane(a * 2.)*RotYWPlane(a * 5.)); \n    \n    Sphere sphere = Sphere(vec4(0., 0., 0., 0.), 250., vec3(1., 0., 0.));\n    \n    Hit nearest = Hit(false, 99999999999999., vec3(0.));\n        \n    //Sphere\n    //Hit sphereHit = SphereHit(sphere, ray);\n    //if(sphereHit.isHit && sphereHit.dist < nearest.dist)\n    //{\n    //   nearest = sphereHit;\n    //   float w = PointAt(ray, nearest.dist).w;\n    //   nearest.color *= (w - (sphere.center.w - sphere.radius)) / (cube.radius * 2.);\n    //}\n    \n    //Cube\n    Hit rectHit = RectHit(rect, ray);\n    if(rectHit.isHit && rectHit.dist < nearest.dist)\n    {\n       nearest = rectHit;\n       //float w = PointAt(ray, nearest.dist).w;\n       //nearest.color = vec3(1.) * (w - (cube.center.w - cube.radius)) / (cube.radius * 2.);\n    }\n    \n    //Checkerboard\n    Hit threespaceHit = ThreespaceHit(ray);\n    if(threespaceHit.isHit && threespaceHit.dist < nearest.dist)\n        nearest = threespaceHit;\n        \n    return vec4(nearest.color, 1.0);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    zoom *= iResolution.x / 1000.;\n    \n    fragColor = vec4(0.0);\n    \n    //antialiasing\n    for(float x = 0.; x < 1.; x += 1. / float(AA_AMOUNT)){\n    \tfor(float y = 0.; y < 1.; y += 1. / float(AA_AMOUNT)){    \n    \t\tfragColor += ColorAt(fragCoord + vec2(x, y));    \n    \t}\n    }\n    fragColor /= float(AA_AMOUNT * AA_AMOUNT);\n    \n}","name":"Image","description":"","type":"image"}]}