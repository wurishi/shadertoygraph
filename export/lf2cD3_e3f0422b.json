{"ver":"0.1","info":{"id":"lf2cD3","date":"1723130679","viewed":62,"name":"1st Raymarching study","username":"WilliamWang","description":"Raymarching study","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define mouseSen 1.\n#define maxStep 64\n#define minDist 0.001\n#define maxDist 100.\n\n// Palette function\nvec3 palette (float t) {\n    vec3 a = vec3(0.8, 0.8, 0.8);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(-3.142, -3.142, -3.142);\n    vec3 d = vec3(-1.0, 0.333, 0.667);\n    \n    return a + b*cos(6.29318*(c*t+d));\n}\n\n// Torus SDF\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n// Sphere SDF\nfloat sdSphere( vec3 p, float s) {\n\n    return length(p) - s;\n    \n}\n\n\n// Box SDF\nfloat sdBox( vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y, q.z)), 0.0);\n}\n\n\n// smoothMin function\nfloat smoothMin( float a, float b, float k) {\n    float h = max(k-abs(a-b), 0.0) / k;\n    return min( a, b) - h*h*h*k*(1.0/6.0);\n}\n\n// 2D Rotation\nmat2 rot2D(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n\n// distance to the scene\nfloat map(vec3 p){\n    \n    p.z += iTime * .4;   // Moving forward\n    \n    // Store the original position to create unique rotation speeds\n    vec3 originalP = p;\n   \n    // Shape repetition\n    p.xy = (fract(p.xy) - 0.5);  \n    p.z = mod(p.z, 0.4) - 0.25;\n    \n    p.xy *= rot2D(iTime);  // shape rotation\n    \n    float torus = sdTorus(p , vec2(0.1,0.05));  // torus SDF\n    \n    return torus;\n}\n\n   \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord  * 2. - iResolution.xy) / iResolution.y;\n   vec2 m = (iMouse.xy * 2. - iResolution.xy) / iResolution.y * mouseSen;\n   \n   \n   // Initialization\n   vec3 ro = vec3(0,0,-3);             // ray origin\n   vec3 rd = normalize(vec3(uv * 0.7,1));    // ray direction\n   vec3 col = vec3(0)        ;          // final pixel color\n   vec3 glow = vec3(0);  // glow accumulation\n   \n   float t = 0.;  // total distance travelled\n\n   // Default motion\n   if (iMouse.z < 0.0) {  \n   m = vec2(cos(iTime * 0.2), sin(iTime * 0.2));\n   }\n   \n   \n   // Ray marching\n   int i;\n   for (i = 0; i< maxStep ; i++) {\n   \n       vec3 p = ro + rd * t;  // position along the ray\n       \n       p.xy *= rot2D(t*0.2 * (m.x * mouseSen));  // rotate around Z axis\n        \n       p.y += sin(t*(m.y+1.0)*0.5) * 0.3;        // wiggle\n        \n       float d = map(p);    // current distance to the scene\n       \n       // Accumulate glow based on proximity to objects\n       glow += exp(-9.0 * abs(d)) * palette(t * 0.08 + float(i) * 0.005);  // glow color\n                \n       t += d;              // march the ray\n       \n       if (d < minDist || t > maxDist ) break; // exit the loop if the current distance is close enough\n                                               // or if the current distance if too far\n       \n   }\n   \n   // Apply glow to the final color\n   col += glow * 0.06;  // adjust glow intensity\n   \n   \n   fragColor = vec4 (col, 1);\n}\n\n","name":"Image","description":"","type":"image"}]}