{"ver":"0.1","info":{"id":"3tK3Rm","date":"1578549609","viewed":74,"name":"norm interpolated sphere ","username":"kaji","description":"test","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["imi202001"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\n#define PI 3.14159265359\n\nfloat euc(vec3 p, float e){\n    float scale = 1.0;\n    return scale * pow(pow(abs(p[0]),e)+pow(abs(p[1]),e)+pow(abs(p[2]),e),1.0/e) ;\n}\nfloat dist(vec3 p){\n    float max_p = 4.0;\n    float min_p = 0.2;\n    float t = (max_p-min_p)*(0.5*(sin(0.8*iTime)+1.0))+min_p;\n    return euc(p,t);\n}\nfloat ballSDF(vec3 p) {\n    return dist(p) - 1.;\n}\n\nvec3 gradSDF(vec3 p) {\n    float d = 0.0001;\n    return normalize(vec3(\n        ballSDF(p + vec3(d, 0.0, 0.0)) - ballSDF(p + vec3(-d, 0.0, 0.0)),\n        ballSDF(p + vec3(0.0, d, 0.0)) - ballSDF(p + vec3(0.0, - d, 0.0)),\n        ballSDF(p + vec3(0.0, 0.0, d)) - ballSDF(p + vec3(0.0, 0.0, - d))\n    ));\n}\n\nmat3 euler(float h, float p, float r){\n    return mat3(\n        cos(r)*cos(h)-sin(r)*sin(p)*sin(h), -sin(r)*cos(p), cos(r)*sin(h)+sin(r)*sin(p)*cos(h),\n        sin(r)*cos(h)+cos(r)*sin(p)*sin(h), cos(r)*cos(p), sin(r)*sin(h)-cos(r)*sin(p)*cos(h),\n        -cos(p)*sin(h), sin(p), cos(p)*cos(h)\n    ); \n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // fragment position\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    //camera transform\n    float t = 0.3 * iTime;\n    mat3 g = euler(t, t, t);\n\n    // camera\n    vec3 cPos = g * vec3(0.0, 0.0, 2.0);\n    vec3 cDir = g * vec3(0.0, 0.0, - 1.0);\n    vec3 cUp = g * vec3(0.0, 1.0, 0.0);\n    vec3 cSide = cross(cDir, cUp);\n    float targetDepth = 1.0;\n    \n    // light\n    vec3 lightPos = g *vec3(0.0, 1.0, 2.0);\n\n    // ray\n    vec3 ray = cSide * p.x + cUp * p.y + cDir * targetDepth;\n    ray = ray / dist(ray);\n    \n    // marching loop\n    // needs subpix sampling to cover sharp edges?\n    float hit_dist = 0.01;\n    vec3 rPos = cPos;\n    for(int i = 0; i < 1000; i++ ) {\n        rPos += ray * ballSDF(rPos);\n//        rPos += ray * hit_dist;\n//        if (abs(ballSDF(rPos)) < hit_dist){\n//           break;\n//        }\n    }\n    \n    // collision detection\n    if (abs(ballSDF(rPos)) < hit_dist) { //object\n        vec3 normal = gradSDF(rPos);\n        float diff = dot(normalize(lightPos - rPos), gradSDF(rPos));\n        vec3 amb = vec3(0.0, 1.0, 0.0);\n        fragColor = vec4(diff * amb, 1.0);\n    } else {    //background\n        fragColor = vec4(1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}