{"ver":"0.1","info":{"id":"NlVyDV","date":"1662538290","viewed":199,"name":"Eerie Cave Light","username":"totimannino","description":"Playing around with Ray-HeightMap intersection tests","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","heightmap"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"CameraDef camera;\nHeightMapDef hmapscene;\nPointLightDef ptlight[2];\n\n#define MAXMCOLOR 3\nvec3 mcolor[MAXMCOLOR];\n\nvoid createHeightMap(PlaneDef plane, vec2 maxht_scale)\n{\n    vec3 xAxis;\n    vec3 yAxis;\n    if(plane.norm.z >= 0.98)\n    {\n        xAxis = normalize(cross(plane.norm, vec3(0.,1.,0.)));\n    }\n    else\n    {\n        xAxis = normalize(cross(plane.norm, vec3(0.,0.,1.)));\n    }\n    \n    yAxis = cross(xAxis, plane.norm);\n    \n    hmapscene = HeightMapDef(plane, xAxis, yAxis, maxht_scale);\n}\n\nvec3 setMysteryColor(float tt)\n{\n    float tfract = fract(tt);\n    if(tfract < 0.33)\n    {\n        return mix(mcolor[0], mcolor[1], tfract);\n    } \n    else if(tfract < 0.66)\n    {\n        return mix(mcolor[1], mcolor[2], tfract);\n    } \n    else\n    {\n        return mix(mcolor[2], mcolor[0], tfract);\n    }\n}\n\nvoid constructScene(float time)\n{\n    createHeightMap(PlaneDef(vec3(0.,1.,0.), vec3(0.,0.,0.)), vec2(MAX_ROCK_HEIGHT, 0.05));\n    float dt = 1.2;\n    float dtt = 0.4;\n    float aa = 3.0;\n    float lateralPos = 3.*sin(time*0.2);\n    float mlateralPos = 20.*cos(time*0.1);\n    camera = CameraDef(vec3(10. - dt*time, 4.4, lateralPos), vec3(-dt*time, 0., lateralPos), 0.);\n    vec3 lampcolor = vec3(1.,0.8,0.7);\n    // flickering lamp light\n    ptlight[0] = PointLightDef(vec3(4. - dt*time, 6.0, -2.), lampcolor, 35. + 0.35*sin(47.*time) + 0.55*cos(27.*time)); \n    // mystery light\n    mcolor[0] = vec3(0.2,0.8,1.);\n    mcolor[1] = vec3(0.4,1.,0.4);\n    mcolor[2] = vec3(0.9,0.1,0.9);\n    vec3 mysterycolor = setMysteryColor(0.1*time);\n    ptlight[1] = PointLightDef(vec3(-40. - dt*time + 10.*(1.+sin(time)), 5.0 + 0.5*cos(0.5*time), mlateralPos), mysterycolor, 2575. + 2500.*cos(2.*time));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 pixOffset = (fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    float focalLength = 1.0;\n        \n    constructScene(iTime);\n    float whr = waterHeightRatio(iTime);\n    \n    mat3 camMat = constructCameraMat(camera.pos, camera.lookAt, camera.yaw);\n    vec3 rayDir = camMat*normalize(vec3(pixOffset, focalLength));\n    Ray ray = Ray(rayDir, camera.pos);\n        \n    HitInfo hitInfo;\n    hitInfo.dist = MAX_DIST;\n    vec3 surfaceNorm; \n    vec3 albedo = vec3(1.);\n    \n    mat4 hmapVal = heightMapIntersect(ray, hmapscene, iChannel0);\n    if(hmapVal[0].x > 0. && hmapVal[0].x < hitInfo.dist)\n    {\n        hitInfo.dist = hmapVal[0].x;\n        surfaceNorm = hmapVal[0].yzw;\n        albedo = hmapVal[1].xyz;\n    }\n    \n    vec3 col = vec3(0., 0., 0.);\n    if(hitInfo.dist > 0. && hitInfo.dist < MAX_DIST)\n    {\n        vec3 hitPos = rayHitPos(ray, hitInfo.dist);\n        \n        for(int i = 0; i < 2; ++i)\n        {\n            float lightDist = length(ptlight[i].pos - hitPos);\n            vec3 lightDir = normalize(ptlight[i].pos - hitPos);\n            vec3 camDir = normalize(camera.pos - hitPos);\n            if(dot(lightDir,surfaceNorm) > 0.0)\n            {\n                Ray lightToPtRay = Ray(-lightDir, ptlight[i].pos);\n                mat4 hmapLightVal = heightMapIntersect(lightToPtRay, hmapscene, iChannel0);\n                if(hmapLightVal[0].x + RAY_EPS >= lightDist)\n                {\n                    float refl = dot(surfaceNorm, lightDir)/(lightDist*lightDist);\n\n                    if(hitPos.y < MAX_ROCK_HEIGHT*whr)\n                    {\n                        refl += pow(1.0 - max(dot(surfaceNorm, normalize(camDir + lightDir)), 0.), 12.0);\n                    }\n                    col += refl*ptlight[i].color*ptlight[i].intensity*albedo;\n                }\n            }\n        }\n    }\n    \n    vec2 ldist = renderDirectLight(ray, ptlight[1].pos);\n    if(ldist.y < 1.0)\n    {\n        col = exp(-ldist.y*10.)*ptlight[1].color*ptlight[1].intensity;\n    }\n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265358979323846\n#define RAY_EPS 0.05\n#define MAX_DIST 99999999.\n\n#define MAX_ROCK_HEIGHT 3.0\n#define WATER_HEIGHT_RATIO 0.3\n\n// Camera\nstruct CameraDef\n{\n    vec3 pos;\n    vec3 lookAt;\n    float yaw;\n};\n\n// Objects\nstruct SphereDef\n{\n    vec3 center;\n    float radius;\n    int matId;\n};\n\nstruct PlaneDef\n{\n    vec3 norm;\n    vec3 pos;\n};\n\nstruct HeightMapDef\n{\n    PlaneDef plane;\n    vec3 xAxis;\n    vec3 yAxis;\n    vec2 maxht_scale;\n};\n\nstruct PointLightDef\n{\n    vec3 pos;\n    vec3 color;\n    float intensity;\n};\n\n// Materials\nstruct MaterialDef\n{\n    vec3 diffuseAlbedo;\n    float diffuseAngDev; // microfacet angle standard deviation\n};\n\nstruct Ray\n{\n    vec3 dir;\n    vec3 orig;\n};\n\nstruct HitInfo\n{\n    float dist;\n    vec2 uv;\n};\n\nfloat waterHeightRatio(float time)\n{\n    return 0.3 + 0.06*(0.5 + 0.5*cos(0.2*time));\n}\n\nvec2 sphereIntersect(Ray ray, SphereDef s)\n{\n    vec3 tcenter = s.center - ray.orig;\n \tfloat c = dot(tcenter,tcenter)-s.radius*s.radius;\n    float b = 2.0*dot(-tcenter, ray.dir);\n    //assumption is ray.dir is normalized\n    //float a = 1.0;//dot(ray.dir, ray.dir);\n    float det = b*b-4.0*c;\n    vec2 hits = vec2(-1.0,-1.0);\n    if(det > 0.0) {\n    \tfloat t1 = 0.5*(-b+sqrt(det));\n    \tfloat t2 = 0.5*(-b-sqrt(det));\n        if(t1 < t2) { hits = vec2(t1,t2); }\n        else { hits = vec2(t2,t1); }\n    }\n    return hits;\n}\n\n\nvec3 sphereNorm(SphereDef sd, vec3 pos)\n{\n    return normalize(pos-sd.center);\n}\n\nvec3 rayHitPos(Ray ray, float t)\n{\n    return ray.orig + t*ray.dir;\n}\n\nfloat planeIntersect(Ray ray, PlaneDef plane)\n{    \n    return dot(plane.norm, plane.pos-ray.orig)/dot(plane.norm, ray.dir);\n}\n\nvec4 heightMapNorm(vec2 fOffset, sampler2D samp)\n{\n    const vec2 size = vec2(0.05,0.0);\n    const vec3 off = vec3(-1,0,1)/255.;\n    float s11 = texture(samp, fract(fOffset)).r;\n    float s01 = texture(samp, fract(fOffset + off.xy)).r;\n    float s21 = texture(samp, fract(fOffset + off.zy)).r;\n    float s10 = texture(samp, fract(fOffset + off.yx)).r;\n    float s12 = texture(samp, fract(fOffset + off.yz)).r;\n    vec3 va = normalize(vec3(size.xy,s21-s01));\n    vec3 vb = normalize(vec3(size.yx,s12-s10));\n    return vec4(s11, cross(va,vb));\n}\n\nmat4 heightMapIntersect(Ray ray, HeightMapDef hmap, sampler2D samp)\n{\n    PlaneDef toppdef = hmap.plane;\n    toppdef.pos = hmap.plane.pos + hmap.plane.norm*hmap.maxht_scale.x;\n    float t0 = planeIntersect(ray, toppdef);\n    float t1 = planeIntersect(ray, hmap.plane);\n    const int maxIter = 150;\n    float dt = 1./float(maxIter);\n    float rstep = 0.;\n    if(t1 < t0)\n    {\n        dt = -dt;\n        rstep = 1.;\n        if(t1 < 0. && t0 > 0.)\n        {\n            rstep = abs(t0/(t0-t1));\n        }\n    }\n    vec3 pos0 = rayHitPos(ray, t0) - toppdef.pos;\n    vec3 pos1 = rayHitPos(ray, t1) - hmap.plane.pos;\n    vec2 uv0 = vec2(dot(hmap.xAxis, pos0), dot(hmap.yAxis, pos0));\n    vec2 uv1 = vec2(dot(hmap.xAxis, pos1), dot(hmap.yAxis, pos1));\n    \n    vec4 bsamp = vec4(0.);\n    bool isHit = false;\n    vec2 fOffset = vec2(0.);\n    for(int ii = 0; ii <= maxIter; ++ii) \n    {\n        fOffset = (uv0 + rstep*(uv1-uv0))*hmap.maxht_scale.y;\n        float dht = texture(samp, fract(fOffset)).r;\n        float currHt = 1.-rstep;\n        if(dht > currHt)\n        {\n            isHit = true;\n            float r0 = rstep - dt;\n            for(int jj = 0; jj < 4; ++jj)\n            {\n                float rmid = 0.5*(r0 + rstep);\n                fOffset = (uv0 + rmid*(uv1-uv0))*hmap.maxht_scale.y;\n                bsamp = texture(samp, fract(fOffset));\n                if(bsamp.r > 1.0-rmid) rstep = rmid;\n                else r0 = rmid;\n            }\n            break;\n        }\n        else\n        {\n            rstep = rstep + dt;\n        }\n    }\n    \n    mat4 rval;\n    if(isHit)\n    {\n        vec4 hm = heightMapNorm(fOffset, samp);\n        rval[0] = vec4(t0 + rstep*(t1-t0), (hm.y*hmap.xAxis + hm.z*hmap.yAxis) + hm.w*hmap.plane.norm);\n        rval[1] = vec4(bsamp.yzw, 0.0);\n    }\n    else\n    {\n        rval[0] = vec4(MAX_DIST, vec3(0.,0.,0.));\n    }\n    return rval;\n}\n\nvec2 renderDirectLight(Ray ray, vec3 lightPos)\n{\n    vec3 camToLight = lightPos - ray.orig;\n    float camToLightDist = length(camToLight);\n    float closestRayToLightDist = sqrt(camToLightDist*camToLightDist - pow(dot(ray.dir, camToLight),2.));\n    return vec2(camToLightDist, closestRayToLightDist);\n}\n\nmat3 constructCameraMat(vec3 pos, vec3 lookAt, float yaw) {\n\tvec3 cw = normalize(lookAt-pos);\n    vec3 cp;\n    if(abs(cw.x) > 0. || abs(cw.z) > 0.)\n    {\n        cp = vec3(sin(yaw), cos(yaw), 0.);\n    }\n    else\n    {\n        cp = vec3(sin(yaw), 0., cos(yaw));\n    }\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = cross(cu,cw);\n    return mat3(cu, cv, cw);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 fOffset = (fragCoord.xy - 0.5*iResolution.xy)/(iResolution.xy);\n    float h0 = texture(iChannel0, fract(fOffset)).r;\n    float h1 = texture(iChannel1, fract(fOffset+iTime*vec2(0.,0.2)).yx, 1.).r;\n    vec4 hout = vec4(0.);\n    float whr = waterHeightRatio(iTime);\n    if(h0 > whr)\n    {\n        vec3 r1 = textureLod(iChannel3,fract(10.0*fOffset),1.).rgb;\n        vec3 r2 = textureLod(iChannel3,fract(20.0*fOffset),1.).rgb;\n        vec3 r3 = textureLod(iChannel3,fract(50.0*fOffset),1.).rgb;\n        vec3 rockcolor = 0.3 + 0.4*(0.3*r1+0.6*r2+0.1*r3);\n        hout = vec4(h0, rockcolor);\n    }\n    else\n    {\n        h1 = 2.*(whr-0.15)*h1 + 0.5*texture(iChannel2, fract(vec2(5.0,1.0)*fOffset)).r;\n        vec3 water = vec3(0.0, 0.3, 0.5) + exp(-12.0*(whr-0.3))*vec3(0.0, 0.6, 0.3)*texture(iChannel1,fract(10.0*(fOffset)).yx).rrr;\n        hout = vec4(0.1*h1 + whr - 0.05, water);\n    }\n    \n    fragColor = hout;\n}","name":"Buffer C","description":"","type":"buffer"}]}