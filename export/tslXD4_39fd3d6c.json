{"ver":"0.1","info":{"id":"tslXD4","date":"1551314467","viewed":274,"name":"caged crystal (remix)","username":"_discovery","description":"remix of [url]https://www.shadertoy.com/view/tdlXW4[/url]\nDefinitely view the original, I just made some minor changes for personal fun.\nThe original was done on a livestream, see the link for more info!","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["sdf","raymarcher","crystal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* remix of https://www.shadertoy.com/view/tdlXW4 */\n\n#define pi acos(-1.)\n\nint mat;\nvec3 shift;\n\n// rough shadertoy approximation of the bonzomatic noise texture\nvec4 texNoise(vec2 uv)\n{\n    float f = 0.;\n    f += texture(iChannel0, uv*.125).r*.5;\n    f += texture(iChannel0, uv*.25).r*.25;\n    f += texture(iChannel0, uv*.5).r*.125;\n    f += texture(iChannel0, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\n\nvec2 rotate(vec2 a,float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x*c-a.y*s,\n        a.x*s+a.y*c\n    );\n}\n\nfloat sdBox(vec3 p, vec3 r)\n{\n    p=abs(p)-r;\n    return max(max(p.x,p.y),p.z);\n}\n\nfloat sdOctahedron(vec3 p, float r)\n{\n    p=abs(p);\n    return (p.x+p.y+p.z-r)/sqrt(3.);\n}\n\nfloat sdInk(vec3 p)\n{\n    float spacing = .15;\n    float thickness = .025;\n    p.y += sin(p.y*3.-iTime*2.)*.09;\n    p.xz = rotate(p.xz, (floor(p.y/spacing-.5)*spacing+spacing/2. + iTime*.0) * .9);\n    float w = .25 + pow(p.y,2.)*.5;\n    shift = p;\n    return max(\n        sdBox(p,vec3(w,.9,w)),\n        abs(mod(p.y-spacing/2.,spacing)-spacing/2.)-thickness\n    )*.8;\n}\n\nfloat sdGold(vec3 p)\n{\n    float q = sin(iTime)*.8;\n    q = sin(iTime-2.+cos(iTime*2.))*.1;\n    float box = max(sdBox(p,vec3(1.0)),-sdBox(p,vec3(.96)));\n    float oct = max(sdOctahedron(p,2.01+q),-sdOctahedron(p,1.99+q));\n    oct = min(oct, max(sdOctahedron(p,1.95+q),-sdOctahedron(p,1.9+q)));\n    float edges = 1.25;\n    float oct1 = max(sdOctahedron(p-edges,1.98+q),-sdOctahedron(p,1.850+q));\n    float oct2 = max(sdOctahedron(p+edges,1.98+q),-sdOctahedron(p,1.850+q));\n    return max(box, min(min(oct1,oct2), oct));\n}\n\nfloat sdGround(vec3 p)\n{\n    return p.y+1.2;\n}\n\nfloat tick(float t)\n{\n    float f=floor(t);\n    t=fract(t);\n    t=smoothstep(0.,1.,t);\n    t=smoothstep(0.,1.,t);\n    return f+t;\n}\n\nvec2 tickspin(vec2 a)\n{\n    return rotate(a,tick(iTime*.125)*pi*.5);\n}\n\nfloat scene(vec3 p)\n{\n    float ground = sdGround(p);\n\n    p.xz = tickspin(p.xz);\n\n    float ink = sdInk(p);\n    float gold = sdGold(p);\n    float best = min(min(ink,gold),ground);\n    if(ink==best)\n        mat=0;\n    else if(gold==best)\n        mat=1;\n  else\n    mat=2;\n  return best;\n}\n\nfloat noisefloor(vec2 uv,float t)\n{\n    float n = texNoise(uv*.1).r*4.-1.;\n    return texNoise(vec2(n+iTime*t)).r;\n}\n\nvec3 trace(vec3 cam, vec3 dir)\n{\n    float t =0.;\n    float k =0.;\n    vec3 accum = vec3(1);\n    vec3 emit = vec3(0);\n    for(int i=0;i<100;++i){\n        k=scene(cam+dir*t);\n        t+=k;\n        if(abs(k)<.001)\n        {\n            vec3 h = cam+dir*t;\n            vec2 o = vec2(.01,0);\n            vec3 n = normalize(vec3(\n                scene(h+o.xyy)-scene(h-o.xyy),\n                scene(h+o.yxy)-scene(h-o.yxy),\n                scene(h+o.yyx)-scene(h-o.yyx)\n            ));\n            if (mat == 0)\n            {\n                float f = -0.9*mod(1.0+abs(sin(iTime)), 8.42);\n                vec3 pos = floor(shift*10.+.5);\n                float noise = noisefloor(f*shift.xz*.5+pos.y*.9,0.)*2.-.25;\n                float fresnel = pow(max(0.,1.-dot(-dir,n)),5.)*.5;\n                accum *= fresnel;\n                cam = h+n*.01;\n                dir = reflect(dir,n);\n                t = 0.;\n                emit += pow(noise,6.5)*10. * vec3(19.1,.1,.4) * 2.;\n            }\n            else if (mat == 1)\n            {\n                accum *= vec3(1,.45,.1);\n                cam = h+n*.01;\n                dir = reflect(dir,n);\n                t = 0.;\n            }\n            else if (mat == 2)\n            {\n                float noise = noisefloor(h.xz,.1)*2.-.1;\n                accum *= noise*.7+.3;\n                accum *= vec3(.04,.04,0.05);\n                cam = h+n*.01;\n                dir = mix(reflect(dir,n),n,noise*.1);\n                t = 0.;\n            }\n        }\n    }\n    return accum+emit;\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n    vec2 uv = fragCoord/ iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 cam = vec3(0,0,-100);\n    vec3 dir = normalize(vec3(uv,25));\n\n    cam.yz = rotate(cam.yz, .3);\n    dir.yz = rotate(dir.yz, .3);\n\n    cam.xz = rotate(cam.xz, pi/8.);\n    dir.xz = rotate(dir.xz, pi/8.);\n\n    out_color.rgb = trace(cam,dir);\n    out_color.rgb = pow(out_color.rgb, vec3(.45));\n    out_color.rgb *= 1.-dot(uv,uv)*.4;\n}","name":"Image","description":"","type":"image"}]}