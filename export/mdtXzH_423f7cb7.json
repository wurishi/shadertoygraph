{"ver":"0.1","info":{"id":"mdtXzH","date":"1679415659","viewed":70,"name":"Lava Lamp blobs","username":"Zygal","description":"Credit to Inigo Quilez for the distance functions and to Nathan Vaughn as i used a modified version of his raymarching code.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","lavalamp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define PI 3.1415926535897932384626433832795\n\nconst int MAX_ITER = 100;\nconst float LIMIT = 0.001;//how close the ray have to be to trigger\n\nstruct Material {\n    vec3 color;\n    float specular;\n    float diffuse;\n    float ambient;\n    float shininess;\n};\nstruct Surface{\n    float depth;\n    Material mat;\n};\n\nstruct Final{\n    Surface s;\n    int iterations;\n};\n\nmat3x3 rotate(vec3 angle) {\n    return mat3(\n    cos(angle.y)*cos(angle.z), cos(angle.z)*sin(angle.x)*sin(angle.y)-cos(angle.x)*sin(angle.z), cos(angle.x)*cos(angle.z)*sin(angle.y)+sin(angle.x)*sin(angle.z),\n    cos(angle.y)*sin(angle.z), cos(angle.x)*cos(angle.z)+sin(angle.x)*sin(angle.y)*sin(angle.z), -cos(angle.z)*sin(angle.x)+cos(angle.x)*sin(angle.y)*sin(angle.z),\n    -sin(angle.y), cos(angle.y)*sin(angle.x), cos(angle.x)*cos(angle.y));\n}\n\nSurface opSmoothUnion(Surface d1, Surface d2, float k) {\n    float d = clamp(0.5 + 0.5*(d2.depth-d1.depth)/k, 0.0, 1.0);\n    Material material = Material(mix(d2.mat.color, d1.mat.color, d), mix(d2.mat.specular, d1.mat.specular, d), mix(d2.mat.diffuse, d1.mat.diffuse, d), mix(d2.mat.ambient, d1.mat.ambient, d), mix(d2.mat.shininess, d1.mat.shininess, d));\n    Surface s = Surface(mix(d2.depth, d1.depth, d) - k*d*(1.0-d), material);\n    return s;\n}\n\nSurface sfJoin(Surface d1, Surface d2) {\n    if(d1.depth < d2.depth)\n    return d1;\n    else\n    return d2;\n}\n\nSurface sdSphere(vec3 p, float r, vec3 offset, Material mat)\n{\n    return Surface(length(p-offset)-r, mat);\n}\n\n// bounce the balls of the walls\nvec3 position(float xSpeed, float ySpeed, float zSpeed, float time) {\n    float x = (2./PI)*(asin(sin((2.*PI/xSpeed) * time)));\n    float y = (1.5/PI)*(asin(sin((2.*PI/ySpeed) * time)));\n    float z = (1./PI)*(asin(sin((2.*PI/zSpeed) * time)));\n    return vec3(x, y, z);\n}\n\n/**\n* add all objects here\n*/\nSurface sdScene(vec3 p) {\n    float time = iTime/100.;\n    Surface d = Surface(100., Material(vec3(0.), 0., 0., 0., 0.));\n    //color, specular, diffuse, ambient, shininess\n    Material sphere1 = Material(vec3(1., 0., 0.), 0.25, 0.5, 0.15, 10.);\n    for (float  i = 0.; i < 15.; i++){\n        vec3 po = position(float(.4 / sin(i)), float(.3 / sin(i)), float(.2 / sin(i)), time) * 5.;\n        d = opSmoothUnion(d, sdSphere(p, 1., po, sphere1), 1.);\n    }\n    return d;\n}\n\nvec3 normal(vec3 p){ //finds the normal of a point on a surface\n    vec2 e = vec2(1.0, -1.0) * 0.0005;// epsilon\n    return normalize(\n    e.xyy * sdScene(p + e.xyy).depth +\n    e.yyx * sdScene(p + e.yyx).depth +\n    e.yxy * sdScene(p + e.yxy).depth +\n    e.xxx * sdScene(p + e.xxx).depth);\n}\n/**\n* o = ray origin\n* d = ray direction\n*/\nFinal rayMarch(vec3 o, vec3 d){\n    Surface sur;\n    Surface sc;\n    int iter = 0;\n    for (int i = 0; i < MAX_ITER; i++){\n        sc = sdScene(o + d*sur.depth);\n        sur.depth += sc.depth;\n        sur.mat = sc.mat;\n        if (sc.depth < LIMIT || sur.depth > 100.){\n            iter = (i);\n            break;\n        }\n    }\n    return Final(sur, iter);\n}\n/**\n* finds if an area should be in shadow\n* p: the ray intersection point\n* lPos: the location of the light source (not direction)\n* intensity: Normalized value of how dark the shadows should be, 1 = light, 0 = black\n*/\nfloat shadowMarch(vec3 p, vec3 lPos, float intensity){\n    float depth = LIMIT * 2.;\n    Surface sc;\n\n    vec3 dir = normalize(lPos - p);//the direction to the lightsource\n\n    //checks so it doesnt count its own surface\n    sc = sdScene(p + depth * dir);\n    depth += sc.depth;\n    if (sc.depth < LIMIT) return 1.;\n\n    for (int i = 1; i < MAX_ITER; i++) {\n        sc  = sdScene(p + depth * dir);\n        depth += sc.depth;\n        if (sc.depth < LIMIT){\n            return 1.-intensity;\n        }\n    }\n    return 1.;\n}\n/**\n* Calculates how light bounces on the surface\n* p: the intersect point\n* lPos: The light location (not direction)\n* N: the normal at p\n* RD: ray direction, from camea\n* m: the surface material\n*/\nvec3 phongLightning(vec3 p, vec3 lPos, vec3 N, vec3 RD, Material m){\n    vec3 L = normalize(lPos - p);\n    vec3 ambient = m.color * m.ambient;\n    vec3 diffuse = m.diffuse * clamp(dot(L, N), 0., 1.) * m.color;\n    vec3 specular = m.specular * pow(clamp(-dot(reflect(L, N), -RD), 0., 1.), m.shininess) * vec3(1.);\n    specular = vec3(max(specular.x, 0.), max(specular.y, 0.), max(specular.z, 0.));//removes any negative specular values\n\n    return ambient + diffuse + specular;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy - .5;\n    uv.x = uv.x * iResolution.x / iResolution.y;//make screen square\n\n    //camera and lgiht\n    vec3 rayOrigin = vec3(0., 0., 5.);\n    vec3 rayDir = normalize(vec3(uv, -1.));\n    vec3 light = vec3(cos(iTime) * 10., 10., sin(iTime) * 10.);//the direction of the light source\n\n    Final f = rayMarch(rayOrigin, rayDir);//finds the surface that the ray intersects\n    Surface d = f.s;//the surface that the ray intersects\n\n    if (d.depth < 100.){ //if the object is close enough to not be sky, basicly render distance, if changed, it must also be changed in raymarch\n        vec3 p = rayOrigin + rayDir * d.depth;//where the ray hit an object\n        vec3 N = normal(p);//the normal vector at the ray intersection\n        vec3 col = phongLightning(p, light, N, rayDir, d.mat);//applices light and shadow\n        fragColor = vec4(col, 1.);\n    } else {\n        vec3 col = vec3(0.) + vec3(0.01, 0., 0.) * float(f.iterations);//background color\n        fragColor = vec4(col, 1.); //background color\n    }\n}","name":"Image","description":"","type":"image"}]}