{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"#define PI 3.141592654\n#define fr fragCoord\n/*\n3D color picker, move around in 3D space inside a RGB color cube and go to your favorite color\n\nruns better while paused\n\nthe way to think of how the vision works is, the length away from the origin the larger the angle away from straight forward\nso (.5,0) is looking directly to the right and (1,0) (the right edge of the circle) is looking directly behind\ni did this so that when you are inside the color cube, all colors that are around you are always displayed\n\ncurrently where you click the mouse will determine the camera rotation. \nthe length away from origin *2PI is how much rotation in that direction. \nso dragging from origin to the edge of the display will rotate the camera a whole 360\n\noutside the main circlural display the 4 quadrants display different information.\nbottom left: is the color the camera is currently on\nbottom right: is the color directly infront of the camera, also the position the camera will move to when space is pressed\ntop left: is the currently saved favorite color (save by pressing \"s\")\ntop right: is the current look direction. used to help get bearings\n           if directly in the center of the cube, this color will be equal to\n           the color on the very edge of the cube in the direction of the camera\n           therefore, also, in general add top right color to bottom left is ~= bottom right\n\nCONTROLS\n\"space' jumps camera position in look direction by the minimum move (and see) dististance\n\"b\"     to move camera to the color directly behind you (kinda a backspace if u accidentaly press space)\n\"s\"     saves the color at the current camera position as you favorite color (top half of the non 3D view screen)\n\"t\"     moves camera position back to favorite color position\n\"r\"     moves camera position back to starting position\n\nmin movement starts at .25 (and cannot get smaller than .01) and move incr starts at .1\n\"d\"  dec min movement by move incr\n\"f\"  inc min movement by move incr\n\"c\"  half move incr\n\"v\"  double move incr\n\"g\"  resets the all min movement stuff to default\n*/\n\nvec3 getInfo(int i)\n{\n    //gets info from the buffer\n    return texelFetch(iChannel0,ivec2(i,0),0).xyz;\n}\n\nfloat dBox(vec3 p)\n{\n    //SDF cube of r=.5\n    p=abs(p)-.5;\n    return length(max(p,0.))+min(max(p.x,max(p.y,p.z)),0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fr)\n{\n    vec3 col=vec3(0.);\n    vec2 uv=(fr*2.-iResolution.xy)/iResolution.xy;\n    float le=length(uv);\n    vec3 r0=getInfo(32);  //set camera postition / ray origin\n    //because of how the unusual ray direction is calculated, keep display a circle\n    if(le<1.&&(le>.04||le<.02))\n    {\n        //ray direction for a pixel is being calculated and stored in its pixel location in the buffer\n        vec3 rd=texelFetch(iChannel0,ivec2(fragCoord),0).xyz; \n        //for normal ray marching t starts at 0 but here t starts = min distance since we are usually inside the cube\n        float t=getInfo(52).x;\n        vec3 p=vec3(0.);\n        int i=0;\n        while(i<20)\n        {\n            p=r0+rd*t;\n            float dis=dBox(p);\n            \n            if(dis<=0.) break;  //if hit a part of the box, exit loop and covert that position to a color\n            t+=dis;  //if not a hit keep marching\n            if(t>10.)\n            {\n                //if distance too big (probably because nothing to hit) goto background color\n                i=20;\n            }\n            i++;\n        }\n        //convert position of ray hit to color\n        col=vec3(p+.5);\n        if(i>20)\n        {\n            /*\n            if max distance was reached, display background pattern,\n            shows the current minimum movement and movement increment\n            when frequency in x direction is lower (looks bigger) minimum movement is higher\n            when frequency in y direction is lower (looks bigger) movement increment is higher\n            */\n            \n            float m=getInfo(52).x;  //min movement\n            float n=getInfo(72).x;  //movement incr\n            col=vec3(.5+sin(.05*fr.x/m)*sin(.03*fr.y/n)/20.);\n        }\n    }\n    else //outside the main display\n    {\n        ivec2 c=ivec2(iResolution.xy/2.);\n        vec3 lookdir=texelFetch(iChannel0,c,0).xyz;\n        if(uv.y>0.)\n        {\n            //top left quadrant displays the saved (with the \"s\" key) favorite color\n            //top right is the current look direction\n            col=(uv.x<0.)?getInfo(12):lookdir+1./2.;\n        }\n        else\n        {\n            //display color of current camera position on bottom left quadrant of secondary display\n            col=getInfo(32)+.5;\n            if(uv.x>0.)\n            {\n                //displays color that is currently directly infront of you, aka, where you would jump if you press space\n                //bottom right quadrant\n                col=col+lookdir*getInfo(52);\n            }\n            if(any(greaterThan(col,vec3(1.)))||any(lessThan(col,vec3(0.))))\n            {\n                col=vec3(0.);  //if outside the cube, make color black (helpful for knowing where you are)\n            }\n        }\n    }\n    //col=texelFetch(iChannel0,ivec2(fragCoord),0).xyz;  //shows buffer\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"#define fr fragCoord\n#define PI 3.141592654\nvec3 getInfo(int i)\n{\n    //gets info from the buffer\n    return texelFetch(iChannel0,ivec2(i,0),0).xyz;\n}\n\nbool getKey(int k)\n{\n    //returns if key k is up or down\n    return texelFetch(iChannel1,ivec2(k,1),0).x>.5;\n}\n\nvec3 rot(vec3 p, vec3 axis, float ang)\n{\n    axis=normalize(axis);\n    return mix(dot(axis,p)*axis,p,cos(ang))+cross(axis,p)*sin(ang);\n}\n\nvec3 prin(vec2 f,vec3 c,float p,vec3 co)\n{\n    //just a way to store info to the buffer idk why i do it like this\n    return (f.x>p&&f.x<p+18.)?co:c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col=texelFetch(iChannel0,ivec2(fragCoord),0).xyz;\n    //ray direction effected by display position and then mouse position\n    vec2 uv=(fragCoord*2.-iResolution.xy)/iResolution.xy;\n    float le=length(uv);\n    vec3 bdir=vec3(0.,0.,1.); //base look dir\n    vec3 campos=getInfo(32);  //camera pos\n    vec3 md=vec3((iMouse.xy/iResolution.xy-.5)*PI*4.,0.); // mose pos vector\n    vec3 mdir=rot(bdir,vec3(md.y,-md.x,0.),length(md));  // look dir\n    vec3 norm=vec3(-uv.y,uv.x,0.);                      // display to angle mapping (edge of vision pixels are behind camera)\n    bdir=rot(bdir,norm,le*PI);                         // display rotation\n    bdir=rot(bdir,vec3(md.y,-md.x,0.),length(md));    //mouse rotation \n    \n    if(iFrame<4)\n    {\n        //init\n        col=prin(fr,col,2.,vec3(0.));               //fav color\n        //col=prin(fr,col,22.,vec3(0.,0.,-1.));    //camera pos\n        //col=prin(fr,col,22.,vec3(0.,0.,0.));    //camera pos\n        col=prin(fr,col,22.,vec3(-.65,-.75,1.)); //camera pos\n        col=prin(fr,col,42.,vec3(.25));         //min movement\n        col=prin(fr,col,62.,vec3(.1));         //movement increment\n    }\n    else\n    {\n        if(getKey(32))\n        {\n            // \"space\" to move camera to current color you are looking at\n            vec3 t=campos+mdir*getInfo(52);\n            col=prin(fr,col,22.,t); //camera pos\n        }\n        if(getKey(66))\n        {\n            // \"b\" to move camera to the color directly behind you (kinda a backspace if u accidentaly press space)\n            vec3 t=campos-mdir*getInfo(52);\n            col=prin(fr,col,22.,t); //camera pos\n        }\n        if(getKey(83))\n        {\n            // \"s\" set favorite color\n            vec3 t=campos+.5;\n            if(!(any(greaterThan(t,vec3(1.)))||any(lessThan(t,vec3(0.)))))\n            {\n                col=prin(fr,col,2.,t);   //fav color\n            }\n        }\n        if(getKey(68))\n        {\n            // \"d\"  dec min movement by move incr\n            float t=getInfo(52).x-getInfo(72).x;\n            col=prin(fr,col,42.,vec3(max(t,.01)));       //min movement\n        }\n        if(getKey(70))\n        {\n            // \"f\"  inc min movement by move incr\n            float t=getInfo(52).x+getInfo(72).x;\n            col=prin(fr,col,42.,vec3(max(t,.01)));       //min movement\n        }\n        \n        if(getKey(67))\n        {\n            // \"c\"  half move incr\n            float t=getInfo(72).x;\n            col=prin(fr,col,62.,vec3(t/2.));       //move incr\n        }\n        if(getKey(86))\n        {\n            // \"v\"  double move incr\n            float t=getInfo(72).x;\n            col=prin(fr,col,62.,vec3(t*2.));       //move incr\n        }\n        if(getKey(84))\n        {\n            // \"t\"  move camera back to favorite color\n            vec3 t=getInfo(12).xyz;\n            col=prin(fr,col,22.,t-.5);       //cam pos\n        }\n        if(getKey(82))\n        {\n            // \"r\"  reset camera position\n            //col=prin(fr,col,22.,vec3(0.,0.,-1.));          //camera pos\n            col=prin(fr,col,22.,vec3(-.65,-.75,1.));       //cam pos\n        }\n        if(getKey(71))\n        {\n            // \"g\"  resets movement stuff to default\n            col=prin(fr,col,62.,vec3(.1));        //movement increment\n            col=prin(fr,col,42.,vec3(.25));       //min movement\n        }\n    }\n    \n    //camera rotation stuff\n    if(le<=1.) col=bdir;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":true,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"XcVBzK","date":"1734232272","viewed":52,"name":"psyph fav color picker 1.5","username":"Psyph","description":"I would like to make click and dragging to control the camera rotation more intuitively but its alot harder than what is implemented here (the bare min). would also like to add text to display info such as picked favorite color and current min move size.","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""}}