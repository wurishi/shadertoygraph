{"ver":"0.1","info":{"id":"MXlXzH","date":"1709401889","viewed":55,"name":"RayTracer123","username":"Devesh_Dayanidhi","description":"This a very much gooding of my ray tracing.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SKY_COLOR vec3(0.4f, 0.7f, 0.9f)\n#define ASPECT_RATIO (iResolution.x / iResolution.y)\n#define MAX_BOUNCES 2\n#define MAX_SPHERES 1000\n#define FLT_MAX 1000000.0f\n#define FAR_CLIP FLT_MAX\n\nstruct Ray\n{\n    vec3 Origin, Direction;\n};\n\nstruct Sphere\n{\n    vec3 Position, Albedo;\n    float Radius;\n};\n\nstruct HitPayload\n{\n    float HitDistance;\n    vec3 HitPosition;\n    vec3 HitNormal;\n    Sphere ObjectHit;\n};\n\nSphere g_Spheres[MAX_SPHERES];\nint g_SpheresCount = 0;\n\nvoid AddSphere(Sphere sphere)\n{\n    g_Spheres[g_SpheresCount] = sphere;\n    \n    g_SpheresCount++;\n}\n\nHitPayload ClosestHit(Ray ray, float hitDistance, Sphere closestSphere)\n{\n    HitPayload payload;\n    payload.HitDistance = hitDistance;\n    payload.ObjectHit = closestSphere;\n    payload.HitPosition = ray.Origin + ray.Direction * hitDistance;\n    payload.HitNormal = normalize(payload.HitPosition);\n    \n    return payload;\n}\n\nHitPayload Miss(Ray ray)\n{\n    HitPayload payload;\n    payload.HitDistance = -1.0f;\n    \n    return payload;\n}\n\nHitPayload TraceRay(Ray ray)\n{\n    Sphere closestSphere;\n    float closestT = FAR_CLIP;\n    \n    for (int i = 0; i < g_SpheresCount; i++)\n    {\n        Sphere sphere = g_Spheres[i];\n        \n        vec3 oc = ray.Origin - sphere.Position;\n        \n        float a = dot(ray.Direction, ray.Direction);\n        float b = 2.0f * dot(oc, ray.Direction);\n        float c = dot(oc, oc) - sphere.Radius * sphere.Radius;\n        \n        float discriminant = b * b - 4.0f * a * c;\n        \n        if (discriminant < 0.0f)\n        {\n            continue;\n        }\n        \n        float t = (-b - sqrt(discriminant)) / 2.0f * a;\n        \n        if (t < closestT)\n        {\n            closestT = t;\n            closestSphere = sphere;\n        }\n    }\n    \n    HitPayload payload;\n    \n    if (closestT == FAR_CLIP)\n        payload = Miss(ray);\n    else\n        payload = ClosestHit(ray, closestT, closestSphere);\n    \n    return payload;\n}\n\nvec4 PerPixel(Ray ray)\n{\n    vec3 finalColor = vec3(0.0f);\n\tfloat multiplier = 1.0f;\n\n\tfor (int i = 0; i < MAX_BOUNCES; i++)\n\t{\n\t\tHitPayload payload = TraceRay(ray);\n\n\t\tif (payload.HitDistance < 0.0f)\n\t\t{\n\t\t\tvec3 skyColor = vec3(0.6f, 0.7f, 0.9f);\n\t\t\tfinalColor += SKY_COLOR * multiplier;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tSphere closestSphere = payload.ObjectHit;\n\n\t\tvec3 lightDir = normalize(vec3(1.0f, 1.0f, 1.0f));\n\t\tfloat colorIntensity = max(dot(payload.HitNormal, lightDir), 0.0f);\n\n\t\tvec3 sphereColor = closestSphere.Albedo;\n\t\tsphereColor *= colorIntensity;\n\n\t\tfinalColor += sphereColor * multiplier;\n\n\t\tmultiplier *= 0.25f;\n\n\t\tray.Origin = payload.HitPosition + payload.HitNormal * 0.0001f;\n\t\tray.Direction = reflect(ray.Direction, payload.HitNormal);\n\t}\n\n\treturn vec4(finalColor, 1.0f);\n}\n\nvoid mainImage(out vec4 color, in vec2 fragCoord)\n{\n    vec2 coord = fragCoord.xy / iResolution.xy;\n    coord = coord * 2.0f - 1.0f;\n    coord.x *= ASPECT_RATIO;\n    \n    Ray ray;\n    ray.Origin = vec3(0.0f, 0.0f, 5.0f);\n    ray.Direction = normalize(vec3(coord.x, coord.y, -1.0f));\n    \n    {\n        Sphere sphere;\n        sphere.Position = vec3(0.0f, 0.0f, 0.0f);\n        sphere.Albedo = vec3(1.0f, 0.0f, 1.0f);\n        sphere.Radius = 0.5f;\n        AddSphere(sphere);\n    }\n    \n    {\n        Sphere sphere;\n        sphere.Position = vec3(0.0f, -101.0f, 0.0f);\n        sphere.Albedo = vec3(0.0f, 0.0f, 1.0f);\n        sphere.Radius = 100.f;\n        AddSphere(sphere);\n    }\n    \n    {\n        Sphere sphere;\n        sphere.Position = vec3(1.0f, 0.0f, -1.0f);\n        sphere.Albedo = vec3(1.0f, 0.0f, 0.0f);\n        sphere.Radius = 0.5f;\n        AddSphere(sphere);\n    }\n    \n    color = PerPixel(ray);\n}","name":"Image","description":"","type":"image"}]}