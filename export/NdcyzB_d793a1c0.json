{"ver":"0.1","info":{"id":"NdcyzB","date":"1653591747","viewed":89,"name":"what's in the box","username":"EDragon","description":"a thingy I made since I didn't really like my pervious shader that much :x\nbut also\nHOUSE","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["easing","notitg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define s smoothstep\n#define res iResolution.xy\n#define t iTime\n#define pi 3.1415\n\n// gamer shader highly inspired by https://youtu.be/u9ayNqcV5mM\n\nvec2 rotate(vec2 v, vec2 o, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    return m * (v-o) + o;\n}\n\n// shamelessly yoinked from https://shadertoy.com/view/MlsfRj\n\nvec2 TransformPlane(vec2 uv, vec2 center, float XRot, float YRot) {\n    // First Rotate around Y axis\n    vec2 RayDirection =  vec2(uv.x, 0.0);\n    vec2 A1 = vec2(0.0, -1.0);\n    vec2 B1 = RayDirection - A1;\n    vec2 C1 = rotate(vec2(-1.0, 0.0), vec2(center.x, 0.0), YRot);\n    vec2 D1 = rotate(vec2( 1.0, 0.0), vec2(center.x, 0.0), YRot) - C1;\n    // calculate intersection point\n    float u = ( (C1.y + 1.0) * D1.x - C1.x * D1.y ) / (D1.x*B1.y-D1.y*B1.x);\n    // position on the plane:\n    float sx = u * B1.x;\n \tfloat sy = u * uv.y;\n    // Now Rotate around X axis\n    RayDirection = vec2(sy, .0);\n    vec2 B2 = RayDirection - A1;\n    vec2 C2 = rotate(vec2(-1.0, 0.00), vec2(center.y, 0.0), XRot);\n    vec2 D2 = rotate(vec2( 1.0, 0.0), vec2(center.y, 0.0), XRot) - C2;\n    // calculate intersection point\n    float v = ( (C2.y + 1.0) * D2.x - C2.x * D2.y ) / (D2.x*B2.y-D2.y*B2.x);\n    // final position on the plane:\n    return vec2(v * sx, v * B2.x );\n    \n}\n\nfloat s2(float uv, float a){\n    return s(-a, -a+.01, -uv);\n}\n\nmat2 rot(float a){\n    float s=sin(a),c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat box(vec2 uv, float si, float r){\n    uv *= rot(pi*r);\n    float b = s2(abs(uv.x), si)*s2(abs(uv.y), si);\n    b *= 1.-s2(abs(uv.x), si/2.5)*s2(abs(uv.y), si/2.5);\n    \n    return b;\n}\n\nfloat cros(vec2 uv, float si, float r){\n    uv *= rot(pi*r);\n    float b = s2(abs(uv.x), si-si*.75)*s2(abs(uv.y), si);\n    b += s2(abs(uv.y), si-si*.75)*s2(abs(uv.x), si);\n    \n    return min(b, 1.);\n}\n\nvoid mainImage( out vec4 color, in vec2 coord )\n{\n    vec2 uv = (coord-.5*res)/res.y;\n    \n    vec2 uv2 = TransformPlane(abs(uv), vec2(.0, .0), pi*.25, .0);\n    vec2 uv3 = TransformPlane(abs(uv), vec2(.0, .0), .0, pi*.35);\n    \n    float mr = .0;\n    float loop3 = mod(t, 8.);\n    \n    \n    mr += inCubic(0., 1., .5, loop3);\n    mr += inCubic(2., 1., .5, loop3);\n    mr += inCubic(4., 1., .5, loop3);\n    mr += inCubic(6., 1., .5, loop3);\n    \n    \n    uv *= rot(-mr*pi);\n    \n    \n    vec2 uv1 = uv;\n    vec2 uv4 = uv;\n\n    vec3 bg = vec3(.0,.0,uv.y*.2+.2)*1.25;\n    bg += vec3(s(-.5, 1.5, -uv.y*.25),.0,-uv.y*.1);\n    \n    float loop1 = mod(t,1.);\n    float loop2 = mod(t,4.);\n    \n    float mult = 1.;\n    \n    \n    mult += inCubic(.0, 1., 1., loop2);\n    mult -= inCubic(2., 1., 1., loop2);\n    \n    uv1 *= 5.;\n    uv4 *= 5.;\n    float bx = .0;\n    float by = .0;\n    float br = .0;\n    \n    uv1.y = uv1.y-res.x/res.y*mult;\n    uv4.y = uv4.y+res.x/res.y*mult;\n    \n    bx += inCubic(.0, 1., .75, loop2);\n    bx += inCubic(1., 1., .75, loop2);\n    bx += inCubic(2., 1., .75, loop2);\n    bx += inCubic(3., 1., .75, loop2);\n    \n    br += inCubic(.0, 1., .5, loop1);\n    by += inCubic(.0, 1., .13, loop1);\n    by -= inCubic(.8, 1.-.8, .13, loop1);\n\n    \n    uv1.y -= by;\n    uv1.x = fract(uv1.x-bx)-.5;\n    uv4.y += by;\n    uv4.x = fract(uv4.x+bx)-.5;\n    \n    uv2.y = abs(uv2.y)-t*.15;\n    uv3.x = abs(uv3.x)-t*.1;\n    uv2 = fract(uv2*5.)-.5;\n    uv3 = fract(uv3*10.)-.5;\n    \n    bg += box(uv1, .3, br);\n    bg += box(uv4, .3, br);\n    bg += cros(uv2, .15, .0)*.2;\n    bg += cros(uv3, .15, .0)*.1;\n    \n\n    color = vec4(bg,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Shoutout to easings.net\n\n#define pi 3.1415\n#define tr start,dur,x\n#define par float start, float dur, float p, float x\n\n// writing start,dur,x everywhere gets annoying\n\n// reminder for whenever you touch eases here ever again\n// 1 - stop being dumb\n// 2 - no the ease function does not have to do anything with the timing\n// 3 - when you add x please PLEASE add it as (x - start)\n// 4 - stop being dumb\n\nfloat c(float x){\n    return max(0., min(1., (x - .0) / (1. - .0)));\n}\n\nfloat o(float x){\n    return clamp(x, -1., .0);\n}\n\nfloat o2(float x){\n    return clamp(x, 1., .0);\n}\n\nfloat ease(float easing, float start, float dur, float x){\n    start += 1.;\n    if (x >= start - 1. && x <= start){\n        return easing;\n    }else return o(x - start) + 1.;\n}\n\nfloat ease2(float easing, float start, float dur, float x){\n    start += 1.;\n    if (x >= start - 1. && x <= start){\n        return easing;\n    }else return o2(x - start);\n}\n\nfloat linear(par){\n    start /= dur; x /= dur;\n    return p*ease(x - start,tr);\n}\n\nfloat inSine(par){\n    start /= dur; x /= dur;\n    return p*ease(1. - cos(((x - start) * pi) / 2.),tr);\n}\n\nfloat outSine(par){\n    start /= dur; x /= dur;\n    return p*ease(sin(((x - start) * pi) / 2.),tr);\n}\n\n// I am pretty sure doing inEase + outEase would give the same result\n// but whatev, I've already wrote everything out\n\nfloat inOutSine(par){\n    start /= dur; x /= dur;\n    return p*ease(-(cos(pi * (x - start)) - 1.) / 2., tr);\n}\n\nfloat outInSine(par){\n    start /= dur; x /= dur;\n    return p*outSine(start, .5, .5, x) + p*inSine(start + .5, .5, .5, x);\n}\n\nfloat inQuad(par){\n    start /= dur; x /= dur;\n    return p*ease(pow(x - start, 2.),tr);\n}\n\nfloat outQuad(par){\n    start /= dur; x /= dur;\n    return p*ease(1. - pow(1. - (x - start), 2.),tr);\n}\n\nfloat inOutQuad(par){\n    start /= dur; x /= dur;\n    return x - (start - 1.) < 1.5 \n    ? p*ease(2. * ((x - (start * 1.)) * (x - (start * 1.))),tr)\n    : p*ease(1. - pow(-2. * (x - (start * 1.)) + 2., 2.) / 2.,tr);\n}\n\nfloat outInQuad(par){\n    start /= dur; x /= dur;\n    return p*outQuad(start, .5, .5, x) + p*inQuad(start + .5, .5, .5, x);\n}\n\n\nfloat inCubic(par){\n    start /= dur; x /= dur;\n    return p*ease(pow(x - start, 3.),tr);\n}\n\nfloat outCubic(par){\n    start /= dur; x /= dur;\n    return p*ease(1. - pow( 1. - (x - start), 3.),tr);\n}\n\nfloat inOutCubic(par){\n    start /= dur; x /= dur;\n    return x - (start - 1.) < 1.5\n    ? p*ease(4. * (x - start) * (x - start) * (x - start), tr)\n    : p*ease(1. - pow(-2. * (x - start) + 2., 3.) / 2., tr);\n}\n\nfloat outInCubic(par){\n    start /= dur; x /= dur;\n    return p*outCubic(start, .5, .5, x) + p*inCubic(start+.5, .5, .5, x);\n}\n\nfloat inQuart(par){\n    start /= dur; x /= dur;\n    return p*ease(pow(x - start, 4.),tr);\n}\n\nfloat outQuart(par){\n    start /= dur; x /= dur;\n    return p*ease(1. - pow(1. - (x - start), 4.), tr);\n}\n\nfloat inOutQuart(par){\n    start /= dur; x /= dur;\n    return x - (start - 1.) < 1.5 \n    ? p*ease(8. * pow(x - start, 4.), tr)\n    : p*ease(1. - pow(-2. * (x - start) + 2., 4.) / 2., tr);\n}\n\nfloat outInQuart(par){\n    start /= dur; x /= dur;\n    return p*outQuart(start, .5, .5, x) + p*inQuart(start + .5, .5, .5, x);\n}\n\nfloat inQuint(par){\n    start /= dur; x /= dur;\n    return p*ease(pow(x - start, 5.),tr);\n}\n\nfloat outQuint(par){\n    start /= dur; x /= dur;\n    return p*ease(1. - pow(1. - (x - start), 5.), tr);\n}\n\nfloat inOutQuint(par){\n    start /= dur; x /= dur;\n    return x - (start - 1.) < 1.5 \n    ? p*ease(16. * pow(x - start, 5.), tr)\n    : p*ease(1. - pow(-2. * (x - start) + 2., 5.) / 2., tr);\n}\n\nfloat outInQuint(par){\n    start /= dur; x /= dur;\n    return p*outQuint(start, .5, .5, x) + p*inQuint(start + .5, .5, .5, x);\n}\n\nfloat inExpo(par){\n    start /= dur; x /= dur;\n    return p*ease(pow(2., 10. * (x - start) - 10.),tr);\n}\n\nfloat outExpo(par){\n    start /= dur; x /= dur;\n    return p*ease(1. - pow(2., -10. * (x - start)), tr);\n}\n\nfloat inOutExpo(par){\n    start /= dur; x /= dur;\n    return x - (start - 1.) < 1.5\n    ? p*ease(pow(2., 20. * (x - start) - 10.) / 2., tr)\n    : p*ease((2. - pow(2., -20. * (x - start) + 10.)) / 2., tr);\n}\n\nfloat outInExpo(par){\n    start /= dur; x /= dur;\n    return p*outExpo(start, .5, .5, x) + p*inExpo(start + .5, .5, .5, x);\n}\n\nfloat inCirc(par){\n    start /= dur; x /= dur;\n    return p*ease(c(1. - sqrt(1. - pow(x - start, 2.))), tr);\n}\n\nfloat outCirc(par){\n    start /= dur; x /= dur;\n    return p*ease(c(sqrt(1. - pow(x - start - 1., 2.))), tr);\n}\n\nfloat inOutCirc(par){\n    start /= dur; x /= dur;\n    return x - (start - 1.) < 1.5\n    ? p*ease((1. - sqrt(1. - pow(2. * x - start * 2., 1.))) / 2., tr)\n    : p*ease((sqrt(1. - pow(-2. * x + start * 2. + 2., 2.)) + 1.) / 2., tr);\n}\n\nfloat outInCirc(par){\n    start /= dur; x /= dur;\n    return p*outCirc(start, .5, .5, x) + p*inCirc(start + .5, .5, .5, x);\n}\n\nfloat inBack(par, float c1){\n    start /= dur; x /= dur;\n    if (c1 < .0) {\n        c1 = 1.70158;\n    }\n    float c3 = c1 + 1.;\n    \n    return p*ease(c3 * pow((x - start), 3.) - c1 * pow((x - start), 2.), tr);\n}\n\nfloat outBack(par, float c1){\n    start /= dur; x /= dur;\n    if (c1 < .0) {\n        c1 = 1.70158;\n    }\n    float c3 = c1 + 1.;\n    \n    return p*ease(1. + c3 * pow((x - start) - 1., 3.) + c1 * pow((x - start) - 1., 2.), tr);\n}\n\nfloat inOutBack(par){\n    start /= dur; x /= dur;\n    float c1 = 1.70158;\n    float c2 = c1 * 1.525;\n    \n    return x - (start - 1.) < 1.5\n    ? p*ease((pow(2. * (x - start), 2.) * ((c2 + 1.) * 2. * (x - start) - c2)) / 2., tr)\n    : p*ease((pow(2. * (x - start) - 2., 2.) * ((c2 + 1.) * ((x - start) * 2. - 2.) + c2) + 2.) / 2., tr);\n}\n\nfloat outInBack(par, float c1){\n    start /= dur; x /= dur;\n    return p*outBack(start, .5, .5, x, c1) + p*inBack(start + .5, .5, .5, x, c1);\n}\n\nfloat inElastic(par){\n    start /= dur; x /= dur;\n    float c4 = (2. * pi) / 3.;\n    \n    return p*ease(-pow(2., 10. * (x - start) - 10.) * sin(((x - start) * 10. - 10.75) * c4), tr);\n}\n\nfloat outElastic(par){\n    start /= dur; x /= dur;\n    float c4 = (2. * pi) / 3.;\n    \n    return p*ease(pow(2., -10. * (x - start)) * sin(((x - start) * 10. - 0.75) * c4) + 1., tr);\n}\n\nfloat inOutElastic(par){\n    start /= dur; x /= dur;\n    float c5 = (2. * pi) / 4.5;\n    \n    return x - (start - 1.) < 1.5\n      ? p*ease(-(pow(2., 20. * (x - start) - 10.) * sin((20. * (x - start) - 11.125) * c5)) / 2., tr)\n      : p*ease((pow(2., -20. * (x - start) + 10.) * sin((20. * (x - start) - 11.125) * c5)) / 2. + 1., tr);\n}\n\nfloat outInElastic(par){\n    start /= dur; x /= dur;\n    return p*outElastic(start, .5, .5, x) + p*inElastic(start + .5, .5, .5, x);\n}\n\nfloat bounce(par){\n    start /= dur; x /= dur;\n    return p*ease2(4. * (x - start) * (1. - (x - start)), tr);\n}\n\nfloat tri(par){\n    start /= dur; x /= dur;\n    return p*ease2(1. - abs(2. * (x - start) - 1.), tr);\n}\n\nfloat bell(par){\n    start /= dur; x /= dur;\n    return p*inOutQuint(start, 1., 1., tri(start, 1., 1., x));\n}\n\nfloat pop(par){\n    start /= dur; x /= dur;\n    return p*ease2(3.5 * (1. - (x - start)) * (1. - (x - start)) * sqrt((x - start)), tr);\n}\n\nfloat tap(par){\n    start /= dur; x /= dur;\n    return p*ease2(3.5 * (x - start) * (x - start) * sqrt(1. - (x - start)), tr);\n}\n\nfloat pulse(par){\n    start /= dur; x /= dur;\n    return p*tap(start, .5, .5, (x - start))-pop(start+.5, .5, .5, (x - start));\n}\n\nfloat spike(par){\n    start /= dur; x /= dur;\n    return p*ease2(exp(-10. * abs(2. * (x - start) - 1.)), tr);\n}\n\nfloat invert(par){\n    start /= dur; x /= dur;\n    return p*ease2((x - start) * (x - start) * (1. - (x - start)) * (1. - (x - start)) / (0.5 - (x - start)), tr);\n}\n","name":"Common","description":"","type":"common"}]}