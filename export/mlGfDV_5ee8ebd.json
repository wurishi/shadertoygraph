{"ver":"0.1","info":{"id":"mlGfDV","date":"1702500741","viewed":54,"name":"4d raymarcher test","username":"LuckyLMJ","description":"raymarcher in 4d","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarcher","4d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926\nvec4 lightDirection = normalize(vec4(3, 15, 3, 0));\n\n//rotate a 2D point\nvec2 rotate_point2(vec2 point, float rot) {\n    float cs = cos(rot),\n          sn = sin(rot);\n    point = vec2(\n        point.x*cs - point.y*sn,\n        point.x*sn + point.y*cs\n    );\n    return point;\n}\n\n//rotate a point in 4-D space\nvec4 rotate_point4(vec4 point, vec3 rotA, vec3 rotB) {\n    //this is a bit confusing\n    //rotA: the classic 3-D rotation\n    //around the XW, YW, and ZW planes\n    \n    //rotB = wacky 4D rotation\n    //around the YZ, XZ, and XY planes\n    \n    //xw\n    point.yz = rotate_point2(point.yz, rotA.x);\n    //yw\n    point.xz = rotate_point2(point.xz, rotA.y);\n    //zw\n    point.xy = rotate_point2(point.xy, rotA.z);\n    \n    //yz\n    point.xw = rotate_point2(point.xw, rotB.x);\n    //xz\n    point.yw = rotate_point2(point.yw, rotB.y);\n    //xy\n    point.zw = rotate_point2(point.zw, rotB.z);\n    \n    return point;\n}\n\nfloat sphere_dist(vec4 p, vec4 sp, float r) {\n    return length(p - sp) - r;\n}\n\nfloat plane_dist(vec4 p, float h) {\n    return p.y - h;\n}\n\nfloat box_dist(vec4 p, vec4 sp, vec4 sc) {\n    vec4 q = abs(p-sp) - sc;\n    return length(max(q,0.0)) +\n        min(max(q.x, max(q.y, max(q.z, q.w))),0.0);\n}\n\nfloat line_dist(vec4 p, vec4 a, vec4 b, float r) {\n    vec4 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa - ba*h) - r;\n}\n\n/*float wireframe_box_dist(vec4 p, vec4 sp, vec4 sc, float w) {\n    float d = box_dist(p, sp, sc);\n    d = max(d, -box_dist(p, sp, sc - vec4(-sc.x, w, w, w)));\n    d = max(d, -box_dist(p, sp, sc - vec4(w, -sc.y, w, w)));\n    d = max(d, -box_dist(p, sp, sc - vec4(w, w, -sc.z, w)));\n    d = max(d, -box_dist(p, sp, sc - vec4(w, w, w, -sc.w)));\n    return d;\n}*/\n\nfloat wireframe_box_dist(vec4 p, vec4 bp, vec4 sc, float w){\n       p = abs(p-bp)-sc;\n  vec4 q = abs(p+w)-w;\n\n  return min(min(min(\n      length(max(vec4(p.x,q.y,q.z,q.w),0.0))+min(max(p.x,max(q.y,max(q.z,q.w))),0.0),\n      length(max(vec4(q.x,p.y,q.z,q.w),0.0))+min(max(q.x,max(p.y,max(q.z,q.w))),0.0)),\n      length(max(vec4(q.x,q.y,p.z,q.w),0.0))+min(max(q.x,max(q.y,max(p.z,q.w))),0.0)),\n      length(max(vec4(q.x,q.y,q.z,p.w),0.0))+min(max(q.x,max(q.y,max(q.z,p.w))),0.0));\n}\n\nfloat map(vec4 p) {\n    float d = plane_dist(p, -2.0);\n    //float d = 1e5;\n    d = min(d, box_dist(p, vec4(0), vec4(2)));\n    //d = min(d, wireframe_box_dist(p, vec4(0), vec4(2), 0.2));\n    d = min(d, sphere_dist(p, vec4(5, 0, 0, 0), 1.0));\n    d = min(d, box_dist(p, vec4(0, 5, 0, 0), vec4(1.0)));\n    d = min(d, line_dist(p, vec4(0, 0, 5, 0), vec4(0, 0, 10, 0), 0.5));\n    \n    return d;\n}\n\nvec4 getNormal(vec4 p) {\n    const vec2 h = vec2(1e-5, 0);\n    float mapP = map(p);\n    return normalize(vec4(\n        map(p+h.xyyy) - mapP,\n        map(p+h.yxyy) - mapP,\n        map(p+h.yyxy) - mapP,\n        map(p+h.yyyx) - mapP\n    ));\n}\n\nvec3 raymarch(vec4 p, vec4 d) {\n    float t = 0.0;\n    for (int i = 0; i < 1000; i++) {\n        float dist = map(p + t*d);\n        t += dist;\n        if (dist < 1e-5) {\n            //get light\n            vec4 normal = getNormal(p + t*d);\n            float light = dot(lightDirection, normal);\n            light *= 0.5;\n            light += 0.5;\n            light = max(light, 0.5);\n            \n            float ot = t;\n            //get shadows\n            p = p + t*d;\n            t = 1e-2;\n            d = lightDirection;\n            for (int j = 0; j < 250; j++) {\n                dist = map(p + t*d);\n                t += dist;\n                if (dist < 1e-6 || j >= 249) {\n                    light = 0.5;\n                    break;\n                }\n                if (dist > 40.0) {\n                    break;\n                }\n            }\n            \n            light *= 1.0-(ot/1000.0);\n            \n            normal = abs(normal);\n            \n            return vec3(1) * light; //* (normal.x*0.98 + normal.y * 0.96 + normal.z * 0.94);\n        }\n        if (dist > 40.0) {\n            return vec3(0);\n        }\n    }\n    return vec3(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 screenCoordinate = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec3 cameraRot = vec3(0.4, iTime, 0);\n    vec3 camera4DRot = vec3(iTime*0.082, 0, iTime*0.077);\n    //vec3 camera4DRot = vec3(0, 0, 0);\n    vec4 rayDirection = rotate_point4(\n        normalize(vec4(screenCoordinate, 1.5, 0)),\n        cameraRot,\n        camera4DRot\n    );\n    \n    vec4 cameraPos = vec4(0, 0, -20, 0);\n    cameraPos = rotate_point4(cameraPos, cameraRot, camera4DRot);\n    //cameraPos.w += 2.0;\n    //cameraPos.w += sin(iTime) * 2.0;\n    \n    vec3 col = raymarch(cameraPos, rayDirection);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}