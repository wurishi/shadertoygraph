{"ver":"0.1","info":{"id":"XdKBRK","date":"1529551027","viewed":3179,"name":"Superformulae","username":"gpfault","description":"https://en.wikipedia.org/wiki/Superformula","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["2d","curves"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel1, uv) + texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define LINE_THINNING_FACTOR 8.0\n#define PI 3.1415926\n#define NUM_CURVES 6\n\n/*\n  Calculates how close the given point is to the\n  superformula curve specified by the given parameters.\n  Note that just m is used instead of m1 and m2, since\n  for a lot of interesting curves m1 and m2 are the same anyway.\n*/ \nfloat shape(vec2 xy,  // input point\n            float m,  // superformula parameters\n            float n1,\n            float n2,\n            float n3,\n            vec2 offset, // offset of the curve origin\n            float rot,   // rotation around origin\n            float scale) {\n    xy += offset;\n    \n    /* Calculate 2d polar coordinates of the point. Note that phi needs to be\n       in the 0..2pi range, so we shift the result of atan by pi for points\n       with x < 0\n     */\n    float r   = length(xy) * (1.0/scale);\n    float phi = atan(xy.y / xy.x) + (xy.x < .0 ? PI : 0.0) + rot;\n\n    float f   = pow(pow(abs(cos(m * phi / 4.0)), n2) + pow(abs(sin(m * phi / 4.0)), n3), -1.0/n1);\n\n\treturn max(0.0, 1.0 - LINE_THINNING_FACTOR * abs(r-f));\n}\n\nfloat deg2rad(float x) {\n\treturn 180.0 * x / PI;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /* Calculate coordinates for this pixel and apply aspect ratio correction*/\n    vec2 xy = (2.0 * fragCoord/iResolution.xy - 1.0) * vec2(iResolution.x/iResolution.y, 1.0);\n    xy *= 15.0;\n\tvec4 params[NUM_CURVES] = vec4[](\n        vec4(5.0, 3.0, 7.0, 7.0),\n        vec4(17.0, 5.0, 3.0, 3.0),\n        vec4(4.0, 5.0, 17.0, 17.0),\n        vec4(16.0, 2.0, 0.5, 16.0),\n        vec4(1.0, 200.0, 1.0, 1.0),\n\t\tvec4(4.0, 12.0, 15.0, 15.0)\n    );\n    vec2 offsets[NUM_CURVES] = vec2[](\n        vec2(7.0 * cos(iTime / 2.0), 8.0 * sin(iTime * 2.0)),\n        vec2(7.0 * cos(iTime * 2.0), 7.0 * sin(iTime * 2.0)),\n        vec2(10.0 * sin(iTime), 5.0 * cos(iTime)),\n        vec2(2.0 * cos(iTime), 2.0 * sin(iTime)),\n        vec2(2.0 * cos(iTime), 2.0 * sin(iTime)),\n        vec2(10.0 * sin(iTime/8.0), 5.0 * cos(iTime*2.0))  \n    );\n    float rotations[NUM_CURVES] = float[](\n        deg2rad(iTime / 50.0),\n        deg2rad(iTime / 25.0),\n        deg2rad(iTime / 10.0),\n        deg2rad(iTime / 70.0),\n        0.0,\n        deg2rad(iTime / 20.0)\n    );\n    vec3 colors[NUM_CURVES] = vec3[](\n        vec3(1.0, 1.0, 0.0),\n        vec3(0.6, 0.5, 1.0),\n        vec3(0.7, 0.5, 0.1),\n        vec3(1.0, 0.0, 0.0),\n        vec3(1.0, 1.0, 0.0),\n\t\tvec3(0.0, 1.0, 1.0)\n    );\n    float scales[NUM_CURVES] = float[](\n        1.0,\n        1.5,\n        1.3,\n        1.5,\n        0.5,\n        1.0);\n    vec3 color = vec3(0.0);\n    for(int i = 0; i < NUM_CURVES; ++i) {\n    \tcolor += colors[i] * shape(xy,\n                                params[i][0],\n\t\t\t\t\t\t\t\tparams[i][1],\n                                params[i][2],\n                                params[i][3],\n                                offsets[i],\n                                rotations[i],\n                                scales[i]);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/* gaussian blur copied from https://www.shadertoy.com/view/XdfGDH */\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\t//declare stuff\n\t\tconst int mSize = 11;\n\t\tconst int kSize = (mSize-1)/2;\n\t\tfloat kernel[mSize];\n\t\tvec3 final_colour = vec3(0.0);\n\t\t\n\t\t//create the 1-D kernel\n\t\tfloat sigma = 7.0;\n\t\tfloat Z = 0.0;\n\t\tfor (int j = 0; j <= kSize; ++j)\n\t\t{\n\t\t\tkernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n\t\t}\n\t\t\n\t\t//get the normalization factor (as the gaussian has been clamped)\n\t\tfor (int j = 0; j < mSize; ++j)\n\t\t{\n\t\t\tZ += kernel[j];\n\t\t}\n\t\t\n\t\t//read out the texels\n\t\tfor (int i=-kSize; i <= kSize; ++i)\n\t\t{\n\t\t\tfor (int j=-kSize; j <= kSize; ++j)\n\t\t\t{\n\t\t\t\tfinal_colour += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel0, (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;\n\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfragColor = vec4(final_colour/(Z*Z), 1.0);\n}","name":"Buf B","description":"","type":"buffer"}]}