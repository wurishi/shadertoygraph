{"ver":"0.1","info":{"id":"fdjGzh","date":"1617117405","viewed":71,"name":"my test of ray marching","username":"Stazis","description":"asd","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float MAX_DIST = 100.0;\n\nconst float EPSILON = 0.00001;\nconst float Power = 2.0;\nconst float Bailout = 2.0;\nconst int Iterations = 100;\n\nfloat DE(vec3 pos) {\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < Iterations ; i++) {\n\t\tr = length(z);\n\t\tif (r>Bailout) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\nfloat spehereDista(vec3 point) {\n    return DE(point);\n    return length(point) - 1.0;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        spehereDista(vec3(p.x + EPSILON, p.y, p.z)) - spehereDista(vec3(p.x - EPSILON, p.y, p.z)),\n        spehereDista(vec3(p.x, p.y + EPSILON, p.z)) - spehereDista(vec3(p.x, p.y - EPSILON, p.z)),\n        spehereDista(vec3(p.x, p.y, p.z  + EPSILON)) - spehereDista(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = 0.010;\n    vec2 uv = (fragCoord - .5 * iResolution.xy)/iResolution.y * zoom;\n    \n    vec3 eye = vec3(0,0,10);\n    vec3 direction = normalize(vec3(uv.x, uv.y, -5));\n    \n    float dist = 0.0;\n    float depth = 0.0;\n    vec3 point = eye;\n    \n    for (int i = 0; i < 255; i++) {\n    \n        depth = spehereDista(point);\n        if (dist > MAX_DIST) {\n            fragColor = vec4(0, 0, 0, 1);\n            return;\n        }\n        dist += depth;\n        point = eye + dist * direction;\n        \n        if (depth < .00001) {\n            vec3 K_a = vec3(0.2, 0.2, 0.2);\n            vec3 K_d = vec3(0.7, 0.2, 0.2);\n            vec3 K_s = vec3(1.0, 1.0, 1.0);\n            float shininess = 10.0;\n            vec3 color = phongIllumination(K_a, K_d, K_s, shininess, point, eye);\n    \n            fragColor = vec4(color, 1.0);\n            return;\n        }\n        \n    }\n    \n        fragColor = vec4(0,0,0,1);\n    \n}\n","name":"Image","description":"","type":"image"}]}