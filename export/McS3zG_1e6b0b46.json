{"ver":"0.1","info":{"id":"McS3zG","date":"1704344153","viewed":100,"name":"Digital Storm","username":"DigitalShadow","description":"Happy accidental divide by zero :)","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["raymarch","mesh"],"hasliked":0,"parentid":"XfjGDR","parentname":"Raymarch Glow Effect"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Digital Storm\n        -by DigitalShadow\n    \n    Lisence Creative Commons BY-NC-SA  -  https://creativecommons.org/licenses/by-nc-sa/4.0/\n\n\n\n    Check common tab for settings\n\n\n\n    credits:\n        Raymarched Mesh Terrain   -    https://www.shadertoy.com/view/ltjSRD\n            -by Flyguy\n        Simple DOF                -    https://www.shadertoy.com/view/wsXBRf\n            -by 42yeah\n        Cone Tracing              -    https://www.shadertoy.com/view/4scBW8\n            -by Klems\n*/\n\n\n\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 texData = texture(iChannel0, uv);\n    vec3 col = vec3(0);\n\n    //Depth of feild effect\n    \n            /*\n                First Pass\n                    In buffer A, the raymarch algorithm's cone tracing achieves DOF in a fairly realistic way.\n                    Without a very small step size though, there are noticable artifacts, especially when the \n                    grid lines appear close to the camera\n            \n                Second Pass  \n                    Depth information, saved as the alpha channel value in the previous buffer, is used to \n                    determine a circle of confusion, a loop takes a number of samples radiating out in a golden\n                    spiral pattern bound by this circle, creating the appropriately sized blur.\n\n                By themselves, they do work, but each seem to have noticable weaknesses, and each scales badly \n                in terms of quality vs performance. By combining the two, however, they behave very complimentary\n                and create a much smoother final effect for surprisingly low overhead\n            */\n            \n    float coc = getCoC(texData.w, FOCAL_PLANE);\n    \n    float t = 0.0;\n    \n    #ifdef USE_DOF  \n    vec3 seed = texData.rgb + vec3(fragCoord.xy, iTime);    //random seed, for dithering\n    \n        for(int i = 0; i < DOF_SAMPLES; i++)\n        {\n            float radius = coc * sqrt(float(i) / float(DOF_SAMPLES));\n            float theta = float(i) * PHI + 0.7 * hash13(seed);\n            vec2 sampleUV = uv + sin(theta + vec2(0.0, PI/2.)) * radius;\n\n            vec4 sampleData = texture(iChannel0, sampleUV);\n            if(sampleData.w > 0.0)\n            {\n                float sampleCoC = getCoC(sampleData.w, FOCAL_PLANE);\n\n                float weight = max(0.001, sampleCoC);\n\n                col += sampleData.rgb * weight;\n                t += weight;\n            }\n        }\n        col /= t;\n    #else\n        col = texture(iChannel0, uv).rgb;\n    #endif\n    \n    \n    fragColor = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//comment to disable effect\n#define USE_CT                //Cone Tracing (Antialiasing, DOF)\n#define USE_DOF               //Depth of Feild\n#define USE_AO                //Ambeint Occlusion\n\n//global constants\n#define MAX_STEPS       128.             //Raymarch max steps\n#define MAX_DIST        50.              //Raymarch max distance\n#define PRECISION       0.001            //Raymarch precision (minimum distance to confirm hit)\n#define STEP_SIZE       0.666            //Raymarch step size multiplier\n#define NORMAL_EPSILON  0.001            //Normal sampling offset\n#define MAX_LIGHTS      4                //Maximum light sources\n#define DOF_SAMPLES     16               //Samples used to simulate depth of feild effect\n#define FOCAL_PLANE     10.              //DOF focal plane\n#define FOCAL_LENGTH    0.06             //DOF focal length\n#define CONE_SIZE       0.005            //Cone tracer size\n#define CONE_DOF        8.               //Cone tracer DOF size multiplier\n#define LINE_COLOR      vec3(1.4,0.8,0)  //Grid line color\n#define LINE_SIZE       0.02             //Grid line size\n#define AO_MULTI        0.5              //Ambient Occlusion Multiplier\nconst float PI = atan(1.) * 4.;\nconst float PHI = (1. + sqrt(5.)) / 2.;\n\nbool init = false;\n\n\n//Data structures\nstruct Light\n{\n    vec3 position;\n    vec3 direction;\n    float shadow;\n    float intensity;\n    vec3 color;\n};\n\nstruct Material\n{\n    vec3 ambientColor;\n    vec3 diffuseColor;\n    vec3 specularColor;\n    float alpha;\n};\n\nstruct RayHit\n{\n    vec3 p;          //position of ray collision in 3d space\n    vec2 screenUV;   //pixel coordinate\n    vec3 normal;     //surface normal at collision point\n    float dist;      //distance of collision point to camera\n    float steps;     //number of steps taken by raymarcher to collision\n    Material mat;    //material of collision object\n};\n\n\n\n//Math Functions\nmat3 rotate(vec3 a)    //return rotation matrix\n{\n    vec3 c = cos(a);\n    vec3 s = sin(a);\n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3(c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3(c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n    return rotX * rotY * rotZ;\n}\n\nfloat hash13(vec3 p3)\n{\n    p3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//Render Functions\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint)    //return rotation matrix for a camera looking at a point\n{\n    vec3 cd = normalize(lookAtPoint - cameraPos);\n    vec3 cr = normalize(cross(vec3(0, 0, 1), cd));\n    vec3 cu = normalize(cross(cd, cr));\n    return mat3(-cr, -cu, -cd);\n}\n\nfloat opS( float d1, float d2 )    //sdf subtraction operator\n{\n    return max(-d1, d2);\n}\n\nvec3 phong(vec3 lightDir, vec3 normal, vec3 rd, Material mat)  //return lighting color of a ray collision\n{\n    vec3 ambient = mat.ambientColor.rgb;\n    \n    float dotLN = clamp(dot(lightDir, normal), 0., 1.);\n    vec3 diffuse = mat.diffuseColor.rgb * dotLN;\n    \n    float dotRV = clamp(dot(reflect(lightDir, normal), rd), 0., 1.);\n    vec3 specular = mat.specularColor.rgb * pow(dotRV, mat.alpha);\n    \n    return ambient + diffuse + specular;\n}\n\nvec3 lighting(RayHit hit, Light light[MAX_LIGHTS], vec3 camDirection)    //return color of all lighting in scene\n{\n   \n\n    vec3 col = vec3(0);\n    \n    for(int i = 0; i < MAX_LIGHTS; i++)   //iterates over light array, exiting when encountering first unused asset (intensity = 0)\n    {\n        if(light[i].intensity == 0.) break;\n        light[i].direction = normalize(light[i].position - hit.p);\n        light[i].shadow = 1.0;    //shadows aren't used in this scene, but if they were they would be calculated here\n        light[i].intensity *= light[i].shadow;\n        col += light[i].intensity * light[i].color * phong(light[i].direction, hit.normal, camDirection, hit.mat);\n    }\n    \n    col /= 2.;\n    return col;\n}\n\nfloat getCoC(float depth, float focalPlane)    //return circle of confusion based on a depth vs focal plane\n{\n    float aperture = min(1.0, focalPlane * focalPlane);\n    return abs(aperture * (FOCAL_LENGTH * (focalPlane - depth)) /\n        (depth * (focalPlane - FOCAL_LENGTH)));\n}\n\n\n\n\n//Signed distance functions\n\nfloat sdPlane( vec3 p, vec3 p0, vec3 p1, vec3 p2 )    //return signed distance of point p to plane defined by 3 points\n{\n  return dot(p - p0, normalize(cross(p0 - p1, p0 - p2)));\n}\n\nfloat sdQuad( vec3 p, float h0, float h1, float h2, float h3 )    //return signed distance of point p (in range 0..1) to closest triangle in quad\n{\n    float s = 1.;\n       \n    float diag = sdPlane(p, vec3(0, 0, 0),vec3(s, s, 0),vec3(0, 0, s));\n    \n    float tri0 = sdPlane(p, vec3(0, 0,-h0),vec3(0, s,-h1),vec3(s, s,-h2)); \n    tri0 = opS(-diag, tri0);\n    \n    float tri1 = sdPlane(p, vec3(0, 0,-h0),vec3(s, s,-h2),vec3(s, 0,-h3));\n    tri1 = opS(diag, tri1);\n    \n    float d = min(tri0,tri1);\n    \n    return d;\n}\n\nfloat sdGrid(vec2 p)    //get signed distance to closest grid edge or diagonal\n{\n    vec2 gridPoint = fract(p.xy) - 0.5;\n    float grid = 0.5 - max(abs(gridPoint.x), abs(gridPoint.y));\n    grid = min\n        (\n            grid, abs\n            (\n                dot( gridPoint.xy, normalize(vec2(-1,1)) ) \n            )\n        );\n    return grid;\n}\n\n\n\n//Colors\nvec3 colMedGray = vec3(0.5);\n\n\n\n//Materials\nMaterial mDefault()\n{\n    return Material\n    (\n        vec3(0.0, 0.0, 0.0),    //ambient\n        vec3(0.1, 0.1, 0.1),    //diffuse\n        vec3(1.0, 1.0, 1.0),    //specular\n        5.                      //shine\n    );\n}\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"Light light[MAX_LIGHTS];\n\n\n\nvoid initialize()    //set up initial scene conditions\n{\n    light[0].position = vec3(2, 2, -7);\n    light[0].color = vec3(1,1,.8);\n    light[0].intensity = 0.4;\n    light[1].color = vec3(.8,.8,1);\n    light[1].intensity = 0.6;\n    init = true;\n}\n\n\n\nfloat heightMap(vec2 p)    //return height of a 3d surface given a 2d coordinate\n{\n    float h = 0.;\n    float l = length(p);\n    \n    h += 0.75 * sin(p.x / 3. + iTime / 1.5);\n    h += 1.75 * sin(p.y / 9. + iTime / 1.5);\n    \n    h += 0.25 * sin(p.x + p.y * 3.33 + iTime);\n    h += 0.25 * cos(p.y + p.x * 3.33 + iTime);\n    h += 0.25 * sin(l + iTime);\n\n\treturn h;\n}\n\n\n\nfloat sdScene(vec3 p)    //return distance to closest object in scene\n{\n    float d = MAX_DIST;\n    \n    //get grid index and grid uv\n    vec3 gridIndex = vec3(fract(p.xy), p.z);\n    vec2 uv = floor(p.xy);\n    \n    //get the height of each corner of the local quad\n    float v0 = heightMap(uv + vec2(0, 0));\n    float v1 = heightMap(uv + vec2(0, 1));\n    float v2 = heightMap(uv + vec2(1, 1));\n    float v3 = heightMap(uv + vec2(1, 0));    \n    \n    //get the distance from point p to both tris that make up local quad\n    d = sdQuad(gridIndex - vec3(0), v0, v1, v2, v3);\n\n\treturn d;\n}\n\n\n\nvec3 bgColor(vec2 p)    //returns background color\n{\n    return vec3(0);\n}\n\n\n\nvec3 fastColor(RayHit hit, vec3 camPosition, vec3 camDirection)    //returns approximation of color data with minimal data\n{\n    //exit early with background color if dist > max\n    if(hit.dist > MAX_DIST) return bgColor(hit.screenUV);\n    vec3 col = vec3(0);\n    \n    //fog\n    float fog = 1.0 - (hit.dist / MAX_DIST);\n    fog *= fog;\n\n    //grid pattern\n    float grid = sdGrid(hit.p.xy);\n    grid = smoothstep(LINE_SIZE + .001, LINE_SIZE, grid);\n    \n    \n    col += LINE_COLOR * grid * fog;\n    \n    \n    return col;\n}\n\n\n\nvec3 colorScene(RayHit hit, vec3 camPosition, vec3 camDirection)    //returns color data for ray in scene\n{\n    //exit early with background color if dist > max\n    if(hit.dist > MAX_DIST) return bgColor(hit.screenUV);\n    \n    //initialize color accumulator\n    vec3 col = vec3(1);\n    \n    //update light position and apply lighting\n    light[1].position = vec3(5. * cos(iTime), 5. * sin(iTime), -2);\n    col *= lighting(hit, light, camDirection);\n    \n    //fog\n    float distRatio = hit.dist / MAX_DIST;\n    float fog = 1.0 - distRatio;\n    fog *= fog;\n    col *= fog;\n    \n    //grid pattern, done separately in AA \n    #ifndef USE_CT\n        float grid = sdGrid(hit.p.xy);\n        grid = smoothstep(LINE_SIZE + .001, LINE_SIZE, grid);\n        grid *= grid;\n        col += LINE_COLOR * grid * fog;\n    #endif\n\n    return col;\n}\n\n\n\nvec3 getNormal(vec3 p)    //return surface normal vector for point in scene\n{\n    vec2 e = vec2(1., -1.) * NORMAL_EPSILON;\n    return normalize(\n        e.xyy * sdScene(p + e.xyy) +\n        e.yyx * sdScene(p + e.yyx) +\n        e.yxy * sdScene(p + e.yxy) +\n        e.xxx * sdScene(p + e.xxx)\n    );\n}\n\n\n\nRayHit rayMarch(vec2 uv, vec3 ro, vec3 rd, out vec3 pathColor)\n{\n    RayHit ray;\n    ray.mat = mDefault();\n    ray.screenUV = uv;\n    \n    //start with a minimum distance to reduce close up artifacts\n    ray.dist = 1.0;\n    \n    vec4 colAcc = vec4(0, 0, 0, 1);\n    float proximity;\n    float coneRadius;\n    float coneCoverage;\n\n    \n    for(ray.steps = 0.0; ray.steps < MAX_STEPS; ray.steps++)\n    {\n        //get closest point from ray to scene\n        proximity = sdScene(ro + rd * ray.dist);\n        \n        #ifdef USE_CT\n        //cone tracing is only used when Antialiasing is enabled\n        coneRadius = ray.dist * CONE_SIZE;\n        \n            #ifdef USE_DOF\n                //if both AA and DOF are enabled, adjust the cone's radius based on depth\n                coneRadius += CONE_DOF * getCoC(ray.dist, FOCAL_PLANE);\n            #endif\n        \n        if(proximity < coneRadius)\n        {\n        #endif\n            //update ray position\n            ray.p = ro + rd * ray.dist;\n            \n            #ifdef USE_CT\n                //approximate how much of the cone intersets scene\n                coneCoverage = smoothstep(coneRadius, -coneRadius, proximity);\n                \n                //get what color information we can get from the scene without costly normal and lighting\n                vec3 col = fastColor(ray, ro, rd);\n                \n                //Sum color influence from objects within the cone based on coverage and accumulated occlusion\n                colAcc.rgb += colAcc.a * (coneCoverage * col);\n                colAcc.a *= 1.0 - coneCoverage;\n            #endif\n            \n            if(proximity < PRECISION) break;\n        \n        #ifdef USE_CT\n        }\n        #endif\n        \n        if(ray.dist > MAX_DIST) break;\n        ray.dist += proximity * STEP_SIZE;  \n    }\n    \n    //return colors of both the final collision and any color accumulated during the ray's progression \n    ray.normal = getNormal(ray.p);\n    pathColor = vec3(colAcc.rgb);\n    return ray;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if(!init) initialize();\n\n    vec2 res = iResolution.xy / iResolution.y;\n    vec2 uv = fragCoord.xy / iResolution.y;\n    vec2 uvTex = fragCoord / iResolution.xy;\n\n    //camera stuff\n    mat3 rot = rotate(vec3(PI * 0.5,0,0));\n    vec3 lookAtPoint = vec3(0.,0.,0.);\n    vec3 camOrigin = vec3(15. * cos(iTime/10.), 3.5 + 1.5*sin(iTime/3.), 15. * sin(iTime/10.)) * rot;\n    vec3 camDirection = camera(camOrigin, lookAtPoint)*normalize(vec3(uv - res / 2., -1.));\n    \n    \n    //raymarch and color scene\n    vec3 pathCol;\n    RayHit hit = rayMarch(uvTex, camOrigin, camDirection, pathCol);\n    vec3 col = colorScene(hit, camOrigin, camDirection);\n\n    //combine ray collision and path color\n    col += pathCol;\n    \n    \n    //apply ambient occlusion\n    float occlusion = hit.steps / MAX_STEPS;\n    col *= 1.0 - occlusion * AO_MULTI;\n    \n    //glow effect\n    vec3 antiColor = 1.0 - LINE_COLOR;\n    vec3 glowColor = LINE_COLOR;\n    glowColor += antiColor / (0.2 * 0.1+sin(iTime + hit.p.z));      \n    col += glowColor * occlusion * (0.5 + 0.4*sin(iTime/2.));\n  \n\n    //store ray depth in alpha channel\n    fragColor = vec4(col, hit.dist);\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}