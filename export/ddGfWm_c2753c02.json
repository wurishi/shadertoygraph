{"ver":"0.1","info":{"id":"ddGfWm","date":"1698267457","viewed":40,"name":"ray.tracer_shp","username":"alesteba","description":"ray tracer","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["ray"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float boxIntersector( vec3 ro, vec3 rd ) \n{\n    vec3 boxSize = vec3(1.0);\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return -1.0; // no intersection\n    return tN;\n}\n\nfloat sph4Intersect( in vec3 ro, in vec3 rd, in float ra )\n{\n    float r2 = ra*ra;\n    vec3 d2 = rd*rd; vec3 d3 = d2*rd;\n    vec3 o2 = ro*ro; vec3 o3 = o2*ro;\n    float ka = 1.0/dot(d2,d2);\n    float k3 = ka* dot(ro,d3);\n    float k2 = ka* dot(o2,d2);\n    float k1 = ka* dot(o3,rd);\n    float k0 = ka*(dot(o2,o2) - r2*r2);\n    float c2 = k2 - k3*k3;\n    float c1 = k1 + 2.0*k3*k3*k3 - 3.0*k3*k2;\n    float c0 = k0 - 3.0*k3*k3*k3*k3 + 6.0*k3*k3*k2 - 4.0*k3*k1;\n    float p = c2*c2 + c0/3.0;\n    float q = c2*c2*c2 - c2*c0 + c1*c1;\n    float h = q*q - p*p*p;\n    if( h<0.0 ) return -1.0; //no intersection\n    float sh = sqrt(h);\n    float s = sign(q+sh)*pow(abs(q+sh),1.0/3.0); // cuberoot\n    float t = sign(q-sh)*pow(abs(q-sh),1.0/3.0); // cuberoot\n    vec2  w = vec2( s+t,s-t );\n    vec2  v = vec2( w.x+c2*4.0, w.y*sqrt(3.0) )*0.5;\n    float r = length(v);\n    return -abs(v.y)/sqrt(r+v.x) - c1/r - k3;\n}\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    vec3 qc = oc - b*rd;\n    float h = ra*ra - dot( qc, qc );\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nfloat sdOctahedron( vec3 p, float s )\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nint binarySearch(float[3] nums,float searchnum ){\n\n    int low = 0;\n    int high = 3 - 1;\n    int mid = (low + high) / 2;\n    \n    while(low < high){\n        if(nums[mid] < searchnum){\n            if(nums[mid + 1] > searchnum){\n                return mid;\n            }\n            else{\n                low = mid + 1;\n            }\n        }\n        else{\n            high = mid - 1;\n        }\n        mid = (low + high) / 2;\n    }\n    \n    return mid;\n}\n\n\nfloat lerp (float x0, float x1, float y0, float y1, float x)\n{\n    float d = x1 - x0;\n    \n    if (d == 0.0)\n        return (y0 + y1) / 2.0;\n        \n    return y0 + ( (x - x0) * (y1 - y0) ) / d;\n}\n\nfloat piecewise_lerp (float[3] Xs, float[3] Ys, float x)\n{\n    int index = int(binarySearch(Xs, x));\n\n    return lerp\n    (\n        Xs[index ], Xs[index+1],\n        Ys[index ], Ys[index+1],\n        x\n    );\n}\n\nfloat pulse(float time) {\n\n    float pi = 3.14;\n    float frequency = 0.1;\n    return 0.5*(1.0+sin(2.0 * pi * frequency * time));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = 0.5 + 0.5*cos( iTime+uv.xyx + vec3( 5, 10, 2.5 ) );\n\n    vec3 ro = vec3( 0.0, 0.0, 4.0 );\n    vec3 rd = normalize( vec3( ( -1.0 + 2.0 * uv ) * vec2( 1.78, 1.0 ), -1.0 ) );\n\n    float angle = iTime * 0.5;\n    mat3 rotX = mat3 ( \n        1.0, 0.0,           0.0, \n        0.0, cos( angle ), -sin( angle ), \n        0.0, sin( angle ),  cos( angle )\n    );\n    mat3 rotY = mat3( \n        cos( angle ),  0.0, sin( angle ), \n        0.0,           1.0, 0.0, \n        -sin( angle ), 0.0, cos( angle ) \n    );\n    \n    // map the function\n    float a = 1.0+cos(iTime)*0.15;\n    float b = 1.0+sin(iTime)*0.15;\n    float c = 1.0+cos(iTime)*0.15;\n    \n    mat3 scale = mat3(\n\n        a, 0, 0,\n        0, b, 0,\n        0 ,0, c\n    );\n\n    // Transform ray\n    vec3 ro1 = ro* rotY * rotX * scale;\n    vec3 rd1 = rd* rotY * rotX * scale;\n\n    // Intersection\n    float id_1 = boxIntersector( ro1, rd1 ) * 1.5; \n    float id_2 = sph4Intersect( ro1, rd1, 1.5) * 1.5;\n    float id_3 = sphIntersect( ro, rd, vec3(0), 0.5).x * 1.5;\n    \n    float id_00 = mix(id_1, id_2, abs(sin(iTime))+.05);\n    float id_01 = mix(id_3, id_2, abs(sin(iTime))+.05);\n    \n    float pulse = pulse(iTime);\n    \n    float x[3]=float[](0.0,0.5,1.0); \n    float y[3]=float[](id_00,id_1,id_01); \n    \n    float combination = piecewise_lerp(x,y,pulse);\n\n    fragColor = vec4(col + 0.15, 1.0) * combination + vec4(col + 0.1, 1.0) * (1.0 - combination);\n    \n}","name":"Image","description":"","type":"image"}]}