{"ver":"0.1","info":{"id":"wtSXWc","date":"1567286584","viewed":97,"name":"Colors from Hexagons","username":"gressettd","description":"Playing with coloring hexagonal grid.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["grid","color","hexagon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float SQRT3 = 1.7320508075688772935274463415059; \nvec3 TRI30_60_90 = vec3(1.0, SQRT3, 2.0);\n\nfloat Random1D(float seed)\n{\n\treturn fract(sin(seed)*32767.0);\n}\n\nfloat Random1DB(float seed)\n{\n\treturn fract(sin(seed)* (65536.0*3.14159265359));\n}\n\n\n\nfloat Random2D(vec2 p)\n{\n\tvec2 comparator = vec2(\n\t\t12.34 * Random1D(p.x), \n\t\t56.789 * Random1DB(p.y));\n\tfloat alignment = dot(p, comparator);\n\tfloat amplitude = sin(alignment) * 32767.0;\n\tfloat random = fract(amplitude);\n\treturn random;\n}\n\n// from https://iquilezles.org/articles/distfunctions2d\nfloat HexagonDistance(vec2 p, float r)\n{\n\tconst vec3 k = vec3(-0.866025404, 0.5, 0.577350269);\n\tp = abs(p);\n\tp -= 2.0*min(dot(k.xy, p), 0.0)*k.xy;\n\tp -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n\treturn length(p)*sign(p.y);\n}\n\n\n// http://glslsandbox.com/e#43182.0\n// This function returns the hexagonal grid coordinate for the grid cell, and the corresponding \n// hexagon cell ID - in the form of the central hexagonal point. That's basically all you need to \n// produce a hexagonal grid.\nvec4 HexagonGridId(vec2 p, float scale)\n{\n    p *= scale;\n    \n    vec4 center = floor(\n        vec4(p, \n             p - vec2(0.5, 1.0)) / TRI30_60_90.xyxy) + 0.5;\n    \n    vec4 h = vec4(p - center.xy*TRI30_60_90.xy, p - (center.zw + 0.5)*TRI30_60_90.xy);\n    return \n        dot(h.xy, h.xy) < dot(h.zw, h.zw) ? \n        \tvec4(h.xy, center.xy) \n          : vec4(h.zw, center.zw + 9.73);\n\n}\n\n\nvec4 ComputeHexagonGridPattern(vec2 p, float scale, float ccScale)\n{\n    vec4 h = HexagonGridId(p, scale);\n    float hexScale = 1.0/scale;\n    \n    float edgeDistance =  HexagonDistance(h.xy,hexScale);\n    float topo = fract(edgeDistance * ccScale);\n    \n    \n    return vec4(edgeDistance, topo, h.z, h.w);\n}\n\nvec4 ComputeWaveGradientRGB(float t, vec4 bias, vec4 scale, vec4 freq, vec4 phase)\n{\n\tvec4 rgb = bias + scale * cos(6.28 * (freq * t + phase));\n\treturn vec4(clamp(rgb.xyz,0.0,1.0), 1.0);\n}\n\n\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y *= float(iResolution.y) / float(iResolution.x);\n    uv += vec2(cos(iTime*0.2) + iTime*0.1,iTime * 0.05);\n\n    vec4 cc = ComputeHexagonGridPattern(uv, 10.0, 10.0* (1.0 + 0.5*cos(iTime)));\n    \n    /*\n    vec4 bias = vec4(0.350,0.906,0.689,1.0);\n    vec4 scale = vec4(0.772,0.114,0.263,1.0);\n    vec4 freq = vec4(0.077,0.368,1.016,1.0);\n    vec4 phase = vec4(3.859,3.252,5.857,1.0);\n    */\n    \n    vec4 bias = vec4(0.5, 0.5, 0.5, 1.0);\n    vec4 scale = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 freq = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 phase = vec4(0.0, 0.3333, 0.6666, 1.0);\n\n\n\tvec4 color;\n   \tcolor=ComputeWaveGradientRGB(Random2D(cc.zw), bias, scale, freq, phase);\n    color*=ComputeWaveGradientRGB(abs(cos(cc.x + cc.w + mod(iTime,10.0))), bias, scale, freq, phase);\n    color*=ComputeWaveGradientRGB(cc.y,bias,scale,freq,phase);\n    \n    \n    // Output to screen\n    fragColor = vec4(color.xyz,1.0);\n        \n   \n}","name":"Image","description":"","type":"image"}]}