{"ver":"0.1","info":{"id":"WstcWS","date":"1601638352","viewed":75,"name":"Destructured tilling","username":"HyiKing","description":"destructured Tiling rectangles squares","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["rectangles","square","chaos","tiling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.1415926535897932384626433832795\n\n// Palette one\n//vec3 blueYonder = vec3(88./255., 105./255., 148./255.);\n//vec3 laurelGreen = vec3(180./255., 196./255., 174./255.);\n//vec3 paleSpringBud = vec3(229./255., 232./255., 182./255.);\n//vec3 romanSilver = vec3(125./255., 134./255., 125./255.);//125, 134, 156  // 125, 1, 1\n\n// Palette two\nvec3 rootBeer = vec3(40./255., 15./255., 10./255.);\nvec3 paleTaupe = vec3(182./255., 155./255., 137./255.);\nvec3 milkChocolate = vec3(138./255., 84./255., 53./255.);\nvec3 liver = vec3(105./255., 47./255., 26./255.);\n\nfloat hash21(vec2 co) {\n    return fract(sin(dot(co.xy ,vec2(13.9098,78.2143))) * 43658.5553);\n}\n\nvec4 hash24(vec2 co) {\n \t   return vec4(fract(sin(dot(co.yx ,vec2(13.90128,78.2143))) * 43658.5453),\n                   fract(sin(dot(co.xy ,vec2(83.97128,68.2146))) * 48.5453),\n                   fract(sin(dot(co.yx ,vec2(53.9128,68.3346))) * 46.6453),\n                   fract(sin(dot(co.xy ,vec2(59.9158,68.1))) * 86.324));\n}\n\nvec2 rotate(vec2 uv, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * uv;\n}\n\nfloat Rect(vec2 uv, vec2 bottomLeft, vec2 topRight) {\n    vec2 step1 = step(bottomLeft, uv);\n    vec2 step2 = step(1.0-topRight, 1.0-uv);\n    return step1.x*step1.y*step2.x*step2.y;\n}\n\nvec3 chooseColor(float r) {\n    if (r > 0.75) {\n     \treturn paleTaupe;\n    } else if (r > 0.50) {\n        return milkChocolate;\n    } else if (r > 0.25) {\n        return liver;\n    } else {\n        return rootBeer;\n    }\n}\n\nvec3 drawTile(vec2 uv, float frot, vec4 colr) {\n    uv = rotate(uv, frot*M_PI/2.);\n    \n    float rtopleft = Rect(uv, vec2(-0.5, -0.2), vec2(-0.2, 0.5));\n    float rbottomleft = Rect(uv, vec2(-0.5, -0.5), vec2(-0.2, -0.2));\n    float rtopright = Rect(uv, vec2(-0.2, -0.2), vec2(0.5, 0.5));\n    float rbottomright = Rect(uv, vec2(-0.2, -0.5), vec2(0.5, -0.2));\n\n    vec3 col = vec3(0.3);\n    vec3 square1 = chooseColor(colr.x);\n    vec3 square2 = chooseColor(colr.y);\n    vec3 square3 = chooseColor(colr.z);\n    vec3 square4 = chooseColor(colr.t);\n    col = mix(col, square1, rtopleft);\n    col = mix(col, square2, rbottomleft);\n    col = mix(col, square3, rtopright);\n    col = mix(col, square4, rbottomright);\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    // Move to the right\n    uv.y += iTime/32.;\n    \n    // Scale for more tiles\n    uv *= 40.0;\n    \n    \n    // Tiling\n    vec2 gv = fract(uv)-0.5;\n    vec2 id = floor(uv);\n    \n    // Scale grid uv in order to add more chaos\n    gv.x /= sin(4.*iTime)+2.0;\n    gv.y /= cos(8.*iTime)+2.0;\n    \n    // Rotate the tile randomly\n    // choose 4 random colors for the rectangles in the tile\n    float frot = floor(hash21(id)*10.*iTime/5.);//;\n    vec4 colr = hash24(id+3.);\n            \n   \t// finaly draw the tile.\n    vec3 col = drawTile(gv, frot, colr);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}