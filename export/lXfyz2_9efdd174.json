{"ver":"0.1","info":{"id":"lXfyz2","date":"1727034127","viewed":19,"name":"CG-Lab-1","username":"Wesdmond","description":"game on shaders; homework for CG course","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["gd2023"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Check \"Common\" for settings and global variables\n*/\n\nvec2 getPlayerCoordOffset()\n{\n    return vec2(\n    \ttexelFetch(iChannel0, PLAYER_POS_TEXEL, 0).x,\n        texelFetch(iChannel0, PLAYER_POS_TEXEL, 0).y\n    );\n}\n\nvec2 getPlatformCoordOffset()\n{\n    return vec2(\n    \ttexelFetch(iChannel0, PLATFORM_POS_TEXEL, 0).x,\n        texelFetch(iChannel0, PLATFORM_POS_TEXEL, 0).y\n    );\n}\n\nvec3 debugPlatformColor() {\n    return texelFetch(iChannel0, PLATFORM_DEBUG_COL_TEXEL, 0).rgb;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord.xy / iResolution.xy; // uv normilized from 0 to 1\n    uv = uv * 2.0 - 1.0; // normilized uv from -1 to 1 with center on center of the screen\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect; // fix uv aspect ratio\n    \n    vec2 player_center = uv - getPlayerCoordOffset(); // player coordinates with relative to uv offset from buffer A\n    vec2 platform_center = uv - getPlatformCoordOffset(); // same for platform\n    \n    float sdPlayer = sdCircle(player_center, player.size);\n    float player_alpha = step(0.0, -sdPlayer);\n    float sdPlatform = sdBox(platform_center, platform.size);\n    float platform_alpha = step(0.0, -sdPlatform);\n    \n    // PLAYER RENDERING\n    #ifdef TEXTURE_ON_PLAYER\n        vec2 normilized_player_uv = (player_center / player.size + 1.) * 0.5;\n        vec3 texPlayer = texture(iChannel2, normilized_player_uv).rgb; // apply texture on player figure\n        vec3 col = mix(black, texPlayer, player_alpha);\n    #else\n        vec3 col = mix(black, player.color, player_alpha);\n    #endif\n    \n    // PLATFORM RENDERING\n    #ifdef PLATFORM_COLLISION_DEBUG_MODE\n        col = mix(col, debugPlatformColor(), platform_alpha);\n    #else\n        col = mix(col, platform.color, platform_alpha);\n    #endif\n    \n    #ifdef ENABLE_BG\n        vec4 bg = texelFetch(iChannel1, ivec2(fragCoord), 0).rgba;\n        col = mix(col, bg.rgb, bg.a - player_alpha - platform_alpha);\n    #endif\n    \n    fragColor = vec4(col, 0.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PLAYER_POSITION_CASE 0\n#define PLATFORM_POSITION_CASE 1\n\n#define FLOOR -1.0\n#define DEBUG_FLOOR -1.0 - platform.size.y - 0.3\n#define PLAYER_START_POSITION   vec2(0., -(1.-player.size))\n#define PLAYER_HIGHEST_POINT    -1.0 + player.size*2.0\n#define PLAYER_MOST_LEFT_POINT  player_current_pos.x - player.size\n#define PLAYER_MOST_RIGHT_POINT player_current_pos.x + player.size\n\n#define PLATFORM_MOST_LEFT_POINT  platform_current_pos.x - platform.size.x\n#define PLATFORM_MOST_RIGHT_POINT platform_current_pos.x + platform.size.x\n#define ASPECT_RATIO iResolution.x / iResolution.y\n\n// CONSTANTS\n//// KEYS\n    const int KEY_LEFT  = 37;\n    const int KEY_UP    = 38;\n    const int KEY_RIGHT = 39;\n    const int KEY_DOWN  = 40;\n\n//// WASD\n    const int KEY_W = 87;\n    const int KEY_A = 65;\n    const int KEY_S = 83;\n    const int KEY_D = 68;\n\n// PARAMS\n    vec2 player_current_pos;\n    vec2 platform_current_pos;\n    float gTime;\n\n\nfloat randomNumber(float _min, float _max) {\n    //float seed = 43758.5453;\n    float seed = 123123.3211;\n    return mix(_min, _max, fract(sin(iTime) * seed));\n}\n\nfloat randomNumber() {\n    return randomNumber(25., 935.);\n}\n\nvec2 handleInputs()\n{\n    vec2 outData;\n    float input_var;\n    \n    input_var =\n        texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).r - texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).r +\n        texelFetch(iChannel1, ivec2(KEY_D, 0), 0).r - texelFetch(iChannel1, ivec2(KEY_A, 0), 0).r;\n    outData.x = clamp(input_var, -1.0f, 1.0f) * iTimeDelta * player.speed;\n\n    input_var =\n        texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).r - texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).r +\n        texelFetch(iChannel1, ivec2(KEY_W, 0), 0).r - texelFetch(iChannel1, ivec2(KEY_S, 0), 0).r;\n    outData.y = clamp(input_var, -1.0f, 1.0f) * iTimeDelta * player.speed;\n    \n    return outData;\n}\n\nvec2 calculatePlayerCurrentPos() {\n    if (iFrame == 0) {\n        float player_height = 1. - player.size;\n        player_current_pos = PLAYER_START_POSITION;\n    }\n    else {\n        player_current_pos = texelFetch(iChannel0, ivec2(0), 0).xy;\n        float border = player.border_limit * ASPECT_RATIO - player.size;\n        player_current_pos.x = clamp(player_current_pos.x + handleInputs().x, -border, border);\n    }\n    return player_current_pos;\n}\n\nvec2 getRespawnPlatformPosition() {\n    vec2 respawnPlatformPosition = vec2(0., 1.0 - platform.size.y/2.0);\n    #ifdef RANDOM_PLATFORM_START_X_COORD\n        respawnPlatformPosition.x = randomNumber(-ASPECT_RATIO + platform.size.x, \n                                                  ASPECT_RATIO - platform.size.x);\n    #endif\n    return respawnPlatformPosition;\n}\n\nvoid restartGame( inout vec4 fragColor, in vec2 fragCoord ) // TODO\n{\n    switch(int(fragCoord.x)) {\n        case PLAYER_POSITION_CASE:\n            fragColor.xy = PLAYER_START_POSITION;\n            break;\n        case PLATFORM_POSITION_CASE:\n            fragColor.xy = getRespawnPlatformPosition();\n            fragColor.z = PLATFORM_START_SPEED_WITH_GRAVITY;\n            break;\n    }\n    \n    \n}\n\nvec2 calculatePlatformCurrentPos() {\n    if (iFrame == 0) {\n        platform_current_pos = getRespawnPlatformPosition();\n    } else {\n        #ifndef PLATFORM_APPLY_GRAVITY\n            platform_current_pos.y -= iTimeDelta * platform.speed;\n        #else\n            platform_current_pos.y = platform_current_pos.y - min(iTimeDelta * gTime * gTime * platform.gravity / 2.0, PLATFORM_MAX_SPEED);\n        #endif\n    }\n\n    return platform_current_pos;\n}\n\n/* Checking platform collision with floor or player\nreturn 0, if there was no collision\nreturn 1, if there was collision with player\nreturn 2, if there was collision with floor\nreturn 3, for debug mode feature\n*/\n#define PLATFORM_NO_COLLISION 0\n#define PLATFORM_PLAYER_COLLISION 1\n#define PLATFORM_FLOOR_COLLISION 2\n#define PLATFORM_DEBUG_COLLISION 3\nint checkPlatformCollision()\n{\n    if (iFrame == 0) return PLATFORM_NO_COLLISION;\n    #ifdef PLATFORM_COLLISION_DEBUG_MODE\n        if ((platform_current_pos.y - platform.size.y) <= DEBUG_FLOOR) {\n            return PLATFORM_DEBUG_COLLISION;\n    }\n    #endif\n    if ((platform_current_pos.y - platform.size.y) <= FLOOR) {\n        return PLATFORM_FLOOR_COLLISION;\n    }\n    #ifndef DISABLE_PLAYER_COLLISION\n    float playerHighestPoint = -1.0 + player.size*2.0;\n    bool platformHighCheck  = (platform_current_pos.y - platform.size.y) <= playerHighestPoint;\n    bool platformWidthCheck = (PLAYER_MOST_LEFT_POINT >= PLATFORM_MOST_RIGHT_POINT) ||\n                              (PLAYER_MOST_RIGHT_POINT <= PLATFORM_MOST_LEFT_POINT);\n    if (platformHighCheck && !platformWidthCheck)\n    {\n        return PLATFORM_PLAYER_COLLISION;\n    }\n    #endif\n    return PLATFORM_NO_COLLISION;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    player_current_pos   = texelFetch(iChannel0, PLAYER_POS_TEXEL, 0).xy;\n    platform_current_pos = texelFetch(iChannel0, PLATFORM_POS_TEXEL, 0).xy;\n    \n    #ifdef PLATFORM_APPLY_GRAVITY\n        if (iFrame == 0) gTime = PLATFORM_START_SPEED_WITH_GRAVITY;\n        else gTime = texelFetch(iChannel0, PLATFORM_POS_TEXEL, 0).z;\n        gTime += iTimeDelta;\n        if (ivec2(fragCoord) == PLATFORM_POS_TEXEL)\n            fragColor.z = gTime;\n    #endif\n    calculatePlayerCurrentPos();\n    calculatePlatformCurrentPos();\n    \n    switch(int(fragCoord.x)) {\n        case PLAYER_POSITION_CASE:\n            fragColor.xy = player_current_pos;\n           \n            #ifdef DYNAMIC_PLAYER_COLOR\n                if (int(fragCoord.y) == 1)\n                    fragColor.rgb = red;\n            #endif\n            break;\n        case PLATFORM_POSITION_CASE:\n            fragColor.xy = platform_current_pos;\n        \n            #ifdef DYNAMIC_PLATFORM_COLOR\n                if (int(fragCoord.y) == 1)\n                    fragColor.rgb = blue;\n            #endif\n            break;\n    }\n    \n    // COLLISION CHECKS\n    #ifndef DISABLE_PLATFORM_COLLISION\n    int platform_col_check = checkPlatformCollision();\n    switch(platform_col_check) {\n        case PLATFORM_FLOOR_COLLISION:\n            #ifndef PLATFORM_COLLISION_DEBUG_MODE\n                if (int(fragCoord.x) == PLATFORM_POSITION_CASE)\n                    fragColor.xy = getRespawnPlatformPosition();\n            #else\n                if (ivec2(fragCoord) == PLATFORM_DEBUG_COL_TEXEL)\n                    fragColor.rgb = yellow;\n                \n            #endif\n            break;\n        case PLATFORM_PLAYER_COLLISION:\n            #ifndef PLATFORM_COLLISION_DEBUG_MODE\n            restartGame(fragColor, fragCoord);\n            #else\n                #ifdef PLATFORM_APPLY_GRAVITY\n                    fragColor.z = PLATFORM_START_SPEED_WITH_GRAVITY;\n                #endif\n                if (ivec2(fragCoord) == PLATFORM_DEBUG_COL_TEXEL)\n                    fragColor.rgb = green;\n            #endif\n            break;\n        case PLATFORM_NO_COLLISION:\n            #ifdef PLATFORM_COLLISION_DEBUG_MODE\n                if (ivec2(fragCoord) == PLATFORM_DEBUG_COL_TEXEL)\n                    fragColor.rgb = purple;\n            #endif\n            break;\n        case PLATFORM_DEBUG_COLLISION:\n            if (ivec2(fragCoord) == PLATFORM_POS_TEXEL)\n                fragColor.xy = getRespawnPlatformPosition();\n            break;\n    }     \n    #endif\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// TODO fix collision box for circle\n// TODO make rotation matrix for figures\n\n// DEFINES\n     #define ENABLE_BG\n     #ifdef ENABLE_BG\n         #define BG_STAR_MOVING\n         #define STAR_MOVING_SPEED 0.8\n         #define BG_BLUR\n         #define BLUR_COOF 3\n     #endif\n    \n//// DEFINES FOR PLAYER\n/*\n    PLAYER_BORDER_LIMIT is in percentages (from 0.0 to 1.0)\n*/\n    #define PLAYER_SPEED 5.0\n    #define PLAYER_BORDER_LIMIT 1.0\n    #define PLAYER_SIZE 0.2\n    #define PLAYER_COLOR cyan\n    \n//// DEFINES FOR PLATFORM\n    #define PLATFORM_SPEED 1.30\n    #define PLATFORM_GRAVITY 0.2\n    #define PLATFORM_START_SPEED_WITH_GRAVITY 0.2\n    #define PLATFORM_SIZE vec2(0.4, 0.075)\n    #define PLATFORM_COLOR red\n    #define PLATFORM_APPLY_GRAVITY\n    #define PLATFORM_MAX_SPEED 0.5\n    #define RANDOM_PLATFORM_START_X_COORD\n    //#define DISABLE_PLATFORM_COLLISION\n    //#define DISABLE_PLAYER_COLLISION\n    /*\n        PLATFORM_COLLISION_DEBUG_MODE:\n        purple -  if no collision\n        green  -  if collision with player\n        yellow -  if collision with floor\n    */\n    #ifndef DISABLE_PLATFORM_COLLISION\n        // WARNING, DONT WORK WITH BASIC COLLISION MODE\n        //#define PLATFORM_COLLISION_DEBUG_MODE\n    #endif\n\n//// TEXELS\n    #define PLAYER_POS_TEXEL               ivec2(0., 0.)\n    #define PLAYER_COL_TEXEL               ivec2(0., 1.)\n    #define PLATFORM_POS_TEXEL             ivec2(1., 0.)\n    #define PLATFORM_COL_TEXEL             ivec2(1., 1.)\n    #define PLATFORM_DEBUG_COL_TEXEL       ivec2(1., 3.)\n\n//// EXTRA\n    #define ROTATING_PLATFORM // for rotating I use rotation matrix \n    #define ROTATING_TRIANGLE // for rotating I use rotation matrix \n    //#define TEXTURE_ON_PLAYER\n////// MY OWN IDEAS\n    //#define DYNAMIC_PLAYER_COLOR\n    //#define DYNAMIC_PLATFORM_COLOR\n        \n// CONSTANTS\n//// COLORS\n    const vec3 red    =  vec3(1.,0.,0.);\n    const vec3 green  =  vec3(0.,1.,0.);\n    const vec3 blue   =  vec3(0.,0.,1.);\n    const vec3 cyan   =  vec3(0.,1.,1.);\n    const vec3 purple =  vec3(1.,0.,1.);\n    const vec3 yellow =  vec3(1.,1.,0.);\n    const vec3 white  =  vec3(1.,1.,1.);\n    const vec3 black  =  vec3(0.,0.,0.);\n\n// STRUCTS\n    struct player_template {\n        float speed;\n        float border_limit; // in percentages\n        float size;\n        vec3 color;\n\n        #ifdef DYNAMIC_PLAYER_COLOR\n            vec3 dynamic_color;\n        #endif\n    };\n\n    const player_template player = player_template(PLAYER_SPEED, PLAYER_BORDER_LIMIT, PLAYER_SIZE, PLAYER_COLOR);\n\n    struct platform_template {\n        float speed;\n        float gravity;\n        vec2 size;\n        vec3 color;\n\n        #ifdef DYNAMIC_PLATFORM_COLOR\n            vec3 dynamic_color;\n        #endif\n    };\n\n    const platform_template platform = platform_template(PLATFORM_SPEED, PLATFORM_GRAVITY, PLATFORM_SIZE, PLATFORM_COLOR);\n\n\n// SDF FUNCS\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec4 col;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifndef ENABLE_BG\n        return;\n    #endif\n    vec2 uv = fragCoord / iResolution.xy;\n    #ifdef BG_BLUR\n        for (int i = -BLUR_COOF; i <= BLUR_COOF; i++) {\n            for (int j = -BLUR_COOF; j <= BLUR_COOF; j++) {\n                #ifndef BG_STAR_MOVING\n                col += texture(iChannel0, uv + vec2(i, j)/iResolution.xy);\n                #else\n                col += texture(iChannel0, uv + vec2(i, j)/iResolution.xy + vec2(sin(iTime * STAR_MOVING_SPEED), cos(iTime * STAR_MOVING_SPEED)));\n                #endif\n            }\n        }\n        float count = float(BLUR_COOF*2+1);\n        col = col / count / count;\n        fragColor = col;\n        return;\n    #endif\n    #ifdef BG_STAR_MOVING\n        col = texture(iChannel0, uv + vec2(sin(iTime * STAR_MOVING_SPEED), cos(iTime * STAR_MOVING_SPEED)));\n    #elif !defined(BG_BLUR)\n        if (iFrame == 0) {\n            col = texture(iChannel0, uv);\n        }\n        else\n            col = texture(iChannel1, uv);\n    #endif\n    fragColor = col;\n}","name":"Buffer B","description":"","type":"buffer"}]}