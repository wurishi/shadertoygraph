{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n*/\n\n//=======================================================================================\n\n#define FLT_MAX 3.402823466e+38\n\n//=======================================================================================\nstruct SMaterial\n{\n\tfloat m_diffuse;\n\tvec3 m_diffuseColor;\n\tfloat m_specular;\n\tvec3 m_specularColor;\n\tvec3 m_emissiveColor;\n\tfloat m_reflection;\t\n\tfloat m_refraction;\n\tfloat m_refractionIndex;\n};\n\n//=======================================================================================\nstruct SCollisionInfo\n{\n\tint\t\t\tm_Id;\n\tbool\t\tm_foundHit;\n\tbool \t\tm_fromInside;\n\tfloat \t\tm_collisionTime;\n\tvec3\t\tm_intersectionPoint;\n\tvec3\t\tm_surfaceNormal;\n\tSMaterial \tm_material;\n};\n\n//=======================================================================================\nstruct SSphere\n{\n\tint\t\t\tm_Id;\n\tvec3   \t\tm_center;\n\tfloat  \t\tm_radius;\n\tSMaterial\tm_material;\n};\n\t\n//=======================================================================================\nstruct SAxisAlignedBox\n{\n\tint\t\t\tm_Id;\n\tvec3\t\tm_pos;\n\tvec3\t\tm_scale;\n\tSMaterial\tm_material;\n};\n\t\n//=======================================================================================\nstruct SPointLight\n{\n\tvec3\t\tm_pos;\n\tvec3\t\tm_color;\n};\n\t\n//=======================================================================================\nstruct SDirLight\n{\n\tvec3\t\tm_reverseDir;\n\tvec3\t\tm_color;\n};\n\t\n//=======================================================================================\n// Scene parameters\n//=======================================================================================\n\n//----- settings\t\n#define DO_SHADOWS true // setting this to false will speed up rendering\nconst int c_maxRayBounces \t\t= 6;\n\t\n//----- camera\nvec2 mouse = iMouse.xy / iResolution.xy;\n\nvec3 cameraAt \t= vec3(0.0,0.0,0.0);\n\nfloat angleX = 3.14 + 6.28 * mouse.x;\nfloat angleY = 0.0 + mouse.y * 6.28;\nvec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 4.0;\n\nvec3 cameraFwd  = normalize(cameraAt - cameraPos);\nvec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\nvec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\nfloat cameraViewWidth\t= 6.0;\nfloat cameraViewHeight\t= cameraViewWidth * iResolution.y / iResolution.x;\nfloat cameraDistance\t= 6.0;  // intuitively backwards!\n\t\n//----- lights\nvec3 lightAmbient\t\t\t\t= vec3(0.1,0.1,0.1);\n\nSDirLight lightDir1 =\n\tSDirLight\n\t(\n\t\tnormalize(vec3(-1.0,1.0,-1.0)),\n\t\tvec3(1.0,1.0,1.0)\n\t);\n\nSPointLight lightPoint1 =\n\tSPointLight\n\t(\n\t\tvec3(sin(1.57 + iTime*1.3),0.3,cos(1.57 + iTime*1.3)),\n\t\tvec3(0.7,0.3,0.7)\n\t);\n\nSSphere lightPoint1Sphere =\n\tSSphere\n\t(\n\t\t1,\t\t\t\t\t\t//id\n\t\tlightPoint1.m_pos,\t\t//center\n\t\t0.03,\t\t\t\t\t//radius\n\t\tSMaterial\n\t\t(\n\t\t\t1.0,\t\t\t\t//diffuse amount\n\t\t\tvec3(0.0,0.0,0.0),\t//diffuse color\n\t\t\t1.0,\t\t\t\t//specular amount\n\t\t\tvec3(0.0,0.0,0.0),\t//specular color\n\t\t\tlightPoint1.m_color,//emissive color\n\t\t\t0.0,\t\t\t\t//reflection amount\n\t\t\t0.0,\t\t\t\t//refraction amount\n\t\t\t0.0\t\t\t\t\t//refraction index\n\t\t)\n\t);\t\n\n//----- primitives\nSSphere sphere1 =\n\tSSphere\n\t(\n\t\t4,\t\t\t\t\t\t//id\n\t\tvec3(0.0,0.0,0.0),\t\t//center\n\t\t0.3,\t\t\t\t\t//radius\n\t\tSMaterial\n\t\t(\n\t\t\t1.0,\t\t\t\t//diffuse amount\n\t\t\tvec3(0.05,0.1,0.05),//diffuse color\n\t\t\t80.0,\t\t\t\t//specular amount\n\t\t\tvec3(1.0,1.0,1.0),\t//specular color\n\t\t\tvec3(0.0,0.0,0.0),\t//emissive color\n\t\t\t0.0,\t\t\t\t//reflection amount\t\t\n\t\t\t1.0,\t\t\t\t//refraction amount\n\t\t\t0.7\t\t\t\t\t//refraction index\t\t\t\n\t\t)\n\t);\n\nSSphere sphere2 =\n\tSSphere\n\t(\n\t\t5,\t\t\t\t\t\t//id\n\t\tvec3(sin(iTime*1.3),sin(iTime * 1.4)*0.25,cos(iTime*1.3)),\t//center\n\t\t0.15,\t\t\t\t\t//radius\n\t\tSMaterial\n\t\t(\n\t\t\t1.0,\t\t\t\t//diffuse amount\n\t\t\tvec3(1.0,0.2,0.3),\t//diffuse color\n\t\t\t40.0,\t\t\t\t//specular amount\n\t\t\tvec3(1.0,1.0,1.0),\t//specular color\n\t\t\tvec3(0.0,0.0,0.0),\t//emissive\n\t\t\t1.0,\t\t\t\t//reflection amount\t\t\n\t\t\t0.0,\t\t\t\t//refraction amount\n\t\t\t0.0\t\t\t\t\t//refraction index\t\t\t\n\t\t)\n\t);\n\nSAxisAlignedBox orbitBox = \n\tSAxisAlignedBox\n\t(\n\t\t6,\t\t\t\t\t\t//Id\n\t\tvec3(sin(2.0 + iTime*1.3),cos(iTime * 1.4)*0.25,cos(2.0 + iTime*1.3)),\t//center\n\t\tvec3(0.5,0.5,0.5),\t//scale\n\t\tSMaterial\n\t\t(\n\t\t\t1.0,\t\t\t\t//diffuse amount\n\t\t\tvec3(0.0,0.0,0.0),//diffuse color\n\t\t\t20.0,\t\t\t\t//specular amount\n\t\t\tvec3(0.0,0.0,0.0),\t//specular color\n\t\t\tvec3(0.0,0.0,0.0),\t//emissive\n\t\t\t0.0,\t\t\t\t//reflection amount\t\t\t\n\t\t\t1.0,\t\t\t\t//refraction amount\n\t\t\t0.9\t\t\t\t\t//refraction index\t\t\t\n\t\t)\n\t);\n\nSAxisAlignedBox floorBox = \n\tSAxisAlignedBox\n\t(\n\t\t8,\t\t\t\t\t\t//Id\n\t\tvec3(0.0,-0.65,0.0),\t//center\n\t\tvec3(10.0,0.1,10.0),\t//scale\n\t\tSMaterial\n\t\t(\n\t\t\t1.0,\t\t\t\t//diffuse amount\n\t\t\tvec3(1.0,1.0,1.0),\t//diffuse color\n\t\t\t20.0,\t\t\t\t//specular amount\n\t\t\tvec3(0.0,0.0,0.0),\t//specular color\n\t\t\tvec3(0.0,0.0,0.0),\t//emissive\n\t\t\t0.0,\t\t\t\t//reflection amount\t\t\t\n\t\t\t0.0,\t\t\t\t//refraction amount\n\t\t\t0.0\t\t\t\t\t//refraction index\t\t\t\n\t\t)\n\t);\n\nSAxisAlignedBox backBox1 = \n\tSAxisAlignedBox\n\t(\n\t\t9,\t\t\t\t\t\t//Id\n\t\tvec3(0.0,0.0,4.1),\t\t//center\n\t\tvec3(10.0,2.0,0.1),\t\t//scale\n\t\tSMaterial\n\t\t(\n\t\t\t0.2,\t\t\t\t//diffuse amount\n\t\t\tvec3(1.0,1.0,0.8),  //diffuse color\n\t\t\t20.0,\t\t\t\t//specular amount\n\t\t\tvec3(0.0,0.0,0.0),\t//specular color\n\t\t\tvec3(0.0,0.0,0.0),\t//emissive\n\t\t\t1.0,\t\t\t\t//reflection amount\t\t\t\n\t\t\t0.0,\t\t\t\t//refraction amount\n\t\t\t0.0\t\t\t\t\t//refraction index\t\t\t\n\t\t)\n\t);\n\n//----- macro lists\n\n// sphere primitive list\n#define SPHEREPRIMLIST PRIM(sphere1) PRIM(sphere2)\n\n// sphere primitive list with light primitives\n#define SPHEREPRIMLISTWITHLIGHTS SPHEREPRIMLIST PRIM(lightPoint1Sphere)\n\n// box primitive list\n#define BOXPRIMLIST PRIM(orbitBox) PRIM(floorBox) PRIM(backBox1)\n\n// point light list\n#define POINTLIGHTLIST LIGHT(lightPoint1)\n\n// directional light list\n#define DIRLIGHTLIST LIGHT(lightDir1)\n\n//=======================================================================================\nbool RayIntersectSphere (inout SSphere sphere, inout SCollisionInfo info, in vec3 rayPos, in vec3 rayDir, in int ignorePrimitiveId)\n{\n\tif (ignorePrimitiveId == sphere.m_Id)\n\t\treturn false;\n\n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.m_center;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.m_radius * sphere.m_radius;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n\n\t//not inside til proven otherwise\n\tbool fromInside = false;\n\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat collisionTime = -b - sqrt(discr);\n\n\t//if t is negative, ray started inside sphere so clamp t to zero and remember that we hit from the inside\n\tif(collisionTime < 0.0)\n\t{\n\t\tcollisionTime = -b + sqrt(discr);\n\t\tfromInside = true;\n\t}\n\n\t//enforce a max distance if we should\n\tif(info.m_collisionTime >= 0.0 && collisionTime > info.m_collisionTime)\n\t\treturn false;\n\n\t// set all the info params since we are garaunteed a hit at this point\n\tinfo.m_fromInside = fromInside;\n\tinfo.m_collisionTime = collisionTime;\n\tinfo.m_material = sphere.m_material;\n\n\t//compute the point of intersection\n\tinfo.m_intersectionPoint = rayPos + rayDir * info.m_collisionTime;\n\n\t// calculate the normal\n\tinfo.m_surfaceNormal = info.m_intersectionPoint - sphere.m_center;\n\tinfo.m_surfaceNormal = normalize(info.m_surfaceNormal);\n\n\t// we found a hit!\n\tinfo.m_foundHit = true;\n\tinfo.m_Id = sphere.m_Id;\n\treturn true;\n}\n\n//=======================================================================================\nbool RayIntersectAABox (inout SAxisAlignedBox box, inout SCollisionInfo info, in vec3 rayPos, in vec3 rayDir, in int ignorePrimitiveId)\n{\n\tif (ignorePrimitiveId == box.m_Id)\n\t\treturn false;\n\t\n\tfloat rayMinTime = 0.0;\n\tfloat rayMaxTime = FLT_MAX;\n\t\n\t//enforce a max distance\n\tif(info.m_collisionTime >= 0.0)\n\t{\n\t\trayMaxTime = info.m_collisionTime;\n\t}\t\n\t\n\t// find the intersection of the intersection times of each axis to see if / where the\n\t// ray hits.\n\tfor(int axis = 0; axis < 3; ++axis)\n\t{\n\t\t//calculate the min and max of the box on this axis\n\t\tfloat axisMin = box.m_pos[axis] - box.m_scale[axis] * 0.5;\n\t\tfloat axisMax = axisMin + box.m_scale[axis];\n\n\t\t//if the ray is paralel with this axis\n\t\tif(abs(rayDir[axis]) < 0.0001)\n\t\t{\n\t\t\t//if the ray isn't in the box, bail out we know there's no intersection\n\t\t\tif(rayPos[axis] < axisMin || rayPos[axis] > axisMax)\n\t\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//figure out the intersection times of the ray with the 2 values of this axis\n\t\t\tfloat axisMinTime = (axisMin - rayPos[axis]) / rayDir[axis];\n\t\t\tfloat axisMaxTime = (axisMax - rayPos[axis]) / rayDir[axis];\n\n\t\t\t//make sure min < max\n\t\t\tif(axisMinTime > axisMaxTime)\n\t\t\t{\n\t\t\t\tfloat temp = axisMinTime;\n\t\t\t\taxisMinTime = axisMaxTime;\n\t\t\t\taxisMaxTime = temp;\n\t\t\t}\n\n\t\t\t//union this time slice with our running total time slice\n\t\t\tif(axisMinTime > rayMinTime)\n\t\t\t\trayMinTime = axisMinTime;\n\n\t\t\tif(axisMaxTime < rayMaxTime)\n\t\t\t\trayMaxTime = axisMaxTime;\n\n\t\t\t//if our time slice shrinks to below zero of a time window, we don't intersect\n\t\t\tif(rayMinTime > rayMaxTime)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\t\n\t//if we got here, we do intersect, return our collision info\n\tinfo.m_fromInside = (rayMinTime == 0.0);\n\tif(info.m_fromInside)\n\t\tinfo.m_collisionTime = rayMaxTime;\n\telse\n\t\tinfo.m_collisionTime = rayMinTime;\n\tinfo.m_material = box.m_material;\n\t\n\tinfo.m_intersectionPoint = rayPos + rayDir * info.m_collisionTime;\n\n\t// figure out the surface normal by figuring out which axis we are closest to\n\tfloat closestDist = FLT_MAX;\n\tfor(int axis = 0; axis < 3; ++axis)\n\t{\n\t\tfloat distFromPos= abs(box.m_pos[axis] - info.m_intersectionPoint[axis]);\n\t\tfloat distFromEdge = abs(distFromPos - (box.m_scale[axis] * 0.5));\n\n\t\tif(distFromEdge < closestDist)\n\t\t{\n\t\t\tclosestDist = distFromEdge;\n\t\t\tinfo.m_surfaceNormal = vec3(0.0,0.0,0.0);\n\t\t\tif(info.m_intersectionPoint[axis] < box.m_pos[axis])\n\t\t\t\tinfo.m_surfaceNormal[axis] = -1.0;\n\t\t\telse\n\t\t\t\tinfo.m_surfaceNormal[axis] =  1.0;\n\t\t}\n\t}\n\n\t// we found a hit!\n\tinfo.m_foundHit = true;\n\tinfo.m_Id = box.m_Id;\n\treturn true;\t\n}\n\n//=======================================================================================\nbool PointCanSeePoint(in vec3 startPos, in vec3 targetPos, in int ignorePrimitiveId)\n{\n\t// see if we can hit the target point from the starting point\n\tSCollisionInfo collisionInfo =\n\t\tSCollisionInfo\n\t\t(\n\t\t\t0,\n\t\t\tfalse,\n\t\t\tfalse,\n\t\t\t-1.0,\n\t\t\tvec3(0.0,0.0,0.0),\n\t\t\tvec3(0.0,0.0,0.0),\n\t\t\tSMaterial(\n\t\t\t\t1.0,\n\t\t\t\tvec3(0.0,0.0,0.0),\n\t\t\t\t1.0,\n\t\t\t\tvec3(0.0,0.0,0.0),\n\t\t\t\tvec3(0.0,0.0,0.0),\n\t\t\t\t0.0,\n\t\t\t\t0.0,\n\t\t\t\t0.0\n\t\t\t)\n\t\t);\t\n\t\n\tvec3 rayDir = targetPos - startPos;\n\tcollisionInfo.m_collisionTime = length(rayDir);\n\trayDir = normalize(rayDir);\n\n\t// run intersection against all non light primitives. return false on first hit found\n\treturn true\n\t#define PRIM(x) && !RayIntersectSphere(x, collisionInfo, startPos, rayDir, ignorePrimitiveId)\n\tSPHEREPRIMLIST\n\t#undef PRIM\n\t#define PRIM(x) && !RayIntersectAABox(x, collisionInfo, startPos, rayDir, ignorePrimitiveId)\n\tBOXPRIMLIST\n\t#undef PRIM\n\t;\n}\n\n//=======================================================================================\nvoid ApplyPointLight (inout vec3 pixelColor, in SCollisionInfo collisionInfo, in SPointLight light, in float reflectionAmount, in vec3 rayDir)\n{\n\tif (DO_SHADOWS == false || PointCanSeePoint(collisionInfo.m_intersectionPoint, light.m_pos, collisionInfo.m_Id))\n\t{\n\t\t// diffuse\n\t\tvec3 hitToLight = normalize(light.m_pos - collisionInfo.m_intersectionPoint);\n\t\tfloat dp = dot(collisionInfo.m_surfaceNormal, hitToLight);\n\t\tif(dp > 0.0)\n\t\t\tpixelColor += collisionInfo.m_material.m_diffuseColor * dp * light.m_color * collisionInfo.m_material.m_diffuse * reflectionAmount;\n\t\t\t\t\n\t\t// specular\n\t\tvec3 reflection = reflect(hitToLight, collisionInfo.m_surfaceNormal);\n\t\tdp = dot(rayDir, reflection);\n\t\tif (dp > 0.0)\n\t\t\tpixelColor += collisionInfo.m_material.m_specularColor * pow(dp, collisionInfo.m_material.m_specular) * light.m_color * reflectionAmount;\n\t}\n}\n\n//=======================================================================================\nvoid ApplyDirLight (inout vec3 pixelColor, in SCollisionInfo collisionInfo, in SDirLight light, in float reflectionAmount, in vec3 rayDir)\n{\n\tif (DO_SHADOWS == false || PointCanSeePoint(collisionInfo.m_intersectionPoint, collisionInfo.m_intersectionPoint + light.m_reverseDir * 1000.0, collisionInfo.m_Id))\n\t{\n\t\t// diffuse\n\t\tfloat dp = dot(collisionInfo.m_surfaceNormal, light.m_reverseDir);\n\t\tif(dp > 0.0)\n\t\t\tpixelColor += collisionInfo.m_material.m_diffuseColor * dp * light.m_color * collisionInfo.m_material.m_diffuse * reflectionAmount;\n\t\t\n\t\t// specular\n\t\tvec3 reflection = reflect(light.m_reverseDir, collisionInfo.m_surfaceNormal);\n\t\tdp = dot(rayDir, reflection);\n\t\tif (dp > 0.0)\n\t\t\tpixelColor += collisionInfo.m_material.m_specularColor * pow(dp, collisionInfo.m_material.m_specular) * light.m_color * reflectionAmount;\t\t\t\n\t}\n}\n\n//=======================================================================================\nvoid TraceRay (in vec3 rayPos, in vec3 rayDir, inout vec3 pixelColor, in int depth)\n{\n\tint lastHitPrimitiveId = 0;\n\tfloat colorMultiplier = 1.0; // used by reflections and refractions that aren't fully 1.0\n\t\n\tvec3 rayToCameraDir = rayDir;\n\t\n\tfor(int index = 0; index < c_maxRayBounces; ++index)\n\t{\n\t\t\n\t\tSCollisionInfo collisionInfo =\n\t\t\tSCollisionInfo\n\t\t\t(\n\t\t\t\t0,\n\t\t\t\tfalse,\n\t\t\t\tfalse,\n\t\t\t\t-1.0,\n\t\t\t\tvec3(0.0,0.0,0.0),\n\t\t\t\tvec3(0.0,0.0,0.0),\n\t\t\t\tSMaterial(\n\t\t\t\t\t1.0,\n\t\t\t\t\tvec3(0.0,0.0,0.0),\n\t\t\t\t\t1.0,\n\t\t\t\t\tvec3(0.0,0.0,0.0),\n\t\t\t\t\tvec3(0.0,0.0,0.0),\n\t\t\t\t\t0.0,\n\t\t\t\t\t0.0,\n\t\t\t\t\t0.0\n\t\t\t\t)\n\t\t\t);\n\n\t\t// run intersection against all objects, including light objects\t\t\n\t\t#define PRIM(x) RayIntersectSphere(x, collisionInfo, rayPos, rayDir, lastHitPrimitiveId);\n\t\tSPHEREPRIMLISTWITHLIGHTS\n\t\t#undef PRIM\n\t\t\t\n\t\t// run intersections against all boxes\n\t\t#define PRIM(x) RayIntersectAABox(x, collisionInfo, rayPos, rayDir, lastHitPrimitiveId);\n\t\tBOXPRIMLIST\n\t\t#undef PRIM\n\n\t\n\t\tif (collisionInfo.m_foundHit)\n\t\t{\t\n\t\t\t\n\t\t\t// do texture sampling for the floorbox\n\t\t\tif (collisionInfo.m_Id == floorBox.m_Id)\n\t\t\t{\n\t\t\t\tcollisionInfo.m_material.m_diffuseColor = \n\t\t\t\ttexture(iChannel0, collisionInfo.m_intersectionPoint.xz * 0.25).xyz;\n\t\t\t}\n\t\t\t\n\t\t\t// point lights\n\t\t\t#define LIGHT(light) ApplyPointLight(pixelColor, collisionInfo, light, colorMultiplier, rayDir);\n\t\t\tPOINTLIGHTLIST\n\t\t\t#undef LIGHT\n\t\t\t\t\n\t\t\t// directional lights\n\t\t\t#define LIGHT(light) ApplyDirLight(pixelColor, collisionInfo, light, colorMultiplier, rayDir);\n\t\t\tDIRLIGHTLIST\t\t\t\t\n\t\t\t#undef LIGHT\n\n\t\t\t// ambient light\n\t\t\tpixelColor += lightAmbient * collisionInfo.m_material.m_diffuseColor * collisionInfo.m_material.m_diffuse * colorMultiplier;\n\t\t\t\n\t\t\t// emissive color\n\t\t\tpixelColor += collisionInfo.m_material.m_emissiveColor * colorMultiplier;\t\t\n\t\t\t\n\t\t\t//do refraction if we should\n\t\t\tif (collisionInfo.m_material.m_refraction > 0.0)\n\t\t\t{\t\t\t\t\t\n\t\t\t\tif (collisionInfo.m_fromInside)\n\t\t\t\t\tcollisionInfo.m_surfaceNormal *= -1.0;\n\t\t\t\t\n\t\t\t\t// if we are entering a refractive object, we can't ignore it since we need to go out the back\n\t\t\t\t// side possibly.  Since we can't ignore it, we need to push a little bit past the point of\n\t\t\t\t// intersection so we don't intersect it again.\n\t\t\t\tlastHitPrimitiveId = 0;\t\t\t\t\n\t\t\t\trayPos = collisionInfo.m_intersectionPoint + rayDir * 0.001;\n\t\t\t\t\n\t\t\t\t// \n\t\t\t\trayDir = refract(rayToCameraDir, collisionInfo.m_surfaceNormal, collisionInfo.m_material.m_refractionIndex);\n\t\t\t\t\n\t\t\t\tcolorMultiplier *= collisionInfo.m_material.m_refraction;\n\t\t\t\tif (colorMultiplier < 0.1)\n\t\t\t\t\treturn;\t\t\t\t\n\t\t\t}\n\t\t\t//else do reflection if we should\n\t\t\telse if (collisionInfo.m_material.m_reflection > 0.0)\n\t\t\t{\t\t\t\n\t\t\t\trayPos = collisionInfo.m_intersectionPoint;\n\t\t\t\trayDir = reflect(rayDir, collisionInfo.m_surfaceNormal);\n\t\t\t\n\t\t\t\tlastHitPrimitiveId = collisionInfo.m_Id;\n\t\t\t\tcolorMultiplier *= collisionInfo.m_material.m_reflection;\n\t\t\t\n\t\t\t\tif (colorMultiplier < 0.1)\n\t\t\t\t\treturn;\n\t\t\t}\t\t\t\n\t\t\t// else we are done\n\t\t\telse\n\t\t\t\treturn;\n\t\t}\n\t\t// no hit means bail out\n\t\telse\n\t\t{\n\t\t\tpixelColor+= vec3(0.1,0.1,0.1) * colorMultiplier;\n\t\t\treturn;\n\t\t}\n\t}\t\t\t\n}\n\n//=======================================================================================\nfloat ToMonochrome(vec3 color)\n{\n\t//convert from RGB to greyscale\n\t//http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale\n\treturn color.x * 0.30 + color.y * 0.59 + color.z * 0.11;\t\n}\n\n//=======================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 rawPercent = (fragCoord.xy / iResolution.xy);\n\tvec2 percent = rawPercent - vec2(0.5,0.5);\n\t\n\tvec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n\t\t\t\t   - (cameraLeft * percent.x * cameraViewWidth)\n\t\t           + (cameraUp * percent.y * cameraViewHeight);\n\tvec3 rayDir = normalize(rayTarget);\n\t\n\tfloat isCyan = mod(fragCoord.x + mod(fragCoord.y,2.0),2.0);\n\t\n\tvec3 pixelColor = vec3(0.0,0.0,0.0);\n\tTraceRay(cameraPos - (cameraLeft * 0.2 * isCyan), rayDir, pixelColor, 0);\n\tfloat pixelShade = ToMonochrome(pixelColor);\n\tfragColor = vec4(pixelShade * (1.0 - isCyan), 0.0, pixelShade * isCyan, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lsf3Wf","date":"1380500069","viewed":459,"name":"Raytraced RedBlue 3d","username":"demofox","description":"Red/Blue 3d glasses mode real time raytracer.  Refraction + 3d FTW :P\n\nclick and drag the mouse to move the camera","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","raytracer","realtimeraytracing"],"hasliked":0,"parentid":"","parentname":""}}