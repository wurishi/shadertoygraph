{"ver":"0.1","info":{"id":"clcBDS","date":"1701509261","viewed":180,"name":"[Inércia] Reflecting Fragments","username":"Kamoshika","description":"Shader Royale Jam (with liveact by Parallel Pulse) @ Inércia 2023\nhttps://2023.inercia.pt/","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["reflection","raycasting","shadow","livecoding"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 乱数\n//#define hash(x) fract(sin(x) * 5456.7343)\n#define hash(x) fract(sinMod(x) * 5456.7343)\n//#define sinMod(x) sin((x) - 6.28318530718 * floor((x) / 6.28318530718))\n//#define sinMod(x) sin(fract((x) / 6.28318530718) * 6.28318530718)\n#define sinMod(x) sin(mod((x), 6.28318530718))\n\nconst float PI = acos(-1.); // 円周率\nconst float PI2 = acos(-1.) * 2.;\nconst float BPM = 135.;\nconst float EPS = 0.0001; // レイトレースに使う微小量\n\nconst float lightSize = 0.2; // 球体の半径\nvec3 lightPos; // 球体の中心座標\nfloat T; // BPMで速度調整した時間\n\n// 2Dの乱数\nfloat hash12(vec2 p) {\n    return hash(dot(p, vec2(23.6238, 11.7452)));\n}\n\n// レイと球の表面の交差判定関数\n// ref: sphIntersect() (Sphere) by iq\n// https://iquilezles.org/articles/intersectors\nfloat sphIntersect(vec3 ro, vec3 rd, vec3 ce, float ra) {\n    vec3 oc = ro - ce;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - ra * ra;\n    float h = b * b - c;\n    if(h < 0.) {\n        return -1.;\n    }\n    return -b - sqrt(h);\n}\n\n// カメラ(座標ro)から物体表面まで飛ばしたレイの長さ\n// ref: SphericalShellsWithSlits.shader by Kamoshika (myself)\n// https://github.com/Kamoshika-vrc/UnityShaders/blob/main/Shaders/SphericalShellsWithSlits.shader\nfloat castRay(vec3 ro, vec3 rd, out vec3 normal) {\n    float t = 1e5; // カメラからオブジェクトの表面まで伸ばしたレイの長さ\n    \n    // レイと円柱の交差判定のための準備\n    // ref: cylIntersect() (Cylinder) by iq\n    // https://iquilezles.org/articles/intersectors\n    float a = 1.0 - rd.z * rd.z;\n    float b = dot(ro.xy, rd.xy);\n    float co = dot(ro.xy, ro.xy);\n    float rc = sqrt(co); // Z軸とカメラの距離\n    \n    const int N = 10; // 円柱の枚数\n    //const int N = 7; // 円柱の枚数\n    const float delta = 1. / float(N); // 円柱の半径の刻み幅\n    for(int i = 0; i < N * 2; i++) { // N枚の円柱について、表側と裏側に分けて手前から順番に t を求める\n        float n = float(N - i); // 中心から数えて何番目の円柱か\n        float s = 1.; // 1のときは円柱の表側、-1の時は裏側\n        if(i >= N) { // 円柱の裏側\n            n = float(i - N + 1);\n            s = -1.;\n        }\n        float ra = n * delta; // 円柱の半径\n        \n        // 円柱が完全にカメラの背後にあるときはループを抜ける\n        if(b > ra) {\n            break;\n        }\n        \n        if(i == 0 && rc < ra) { // ループ1回目 & カメラが円柱の中にある\n            int nc = int(rc / delta); // カメラよりも内側にある円柱の枚数 (値は 0 以上 N 未満)\n            if(b < 0.) { // カメラの前方に円柱の表側があるので、そこまでループを飛ばす\n                i = N - nc - 1;\n            } else { // カメラの前方に円柱の表側はないので、一番近くの裏側までループを飛ばす\n                i = N + nc - 1;\n            }\n            continue; // 次の円柱\n        }\n        \n        float c = co - ra * ra;\n        float h = b * b - a * c; // 2次方程式の判別式\n        if(h < 0.) { // レイが円柱と交点をもたない\n            if(i < N) { // 円柱の表側\n                // 今の円柱と交点をもたないならばそれより内側の円柱と交点をもたないことは確定するので\n                // 交点をもつ可能性のある円柱の裏側までループを飛ばす\n                i = N * 2 - i - 1;\n            }\n            continue; // 次の円柱\n        }\n        \n        float tc = (-b - s * sqrt(h)) / a; // 2次方程式の解\n        if(tc < 1e-5) { // 円柱がカメラの後方にある\n            continue; // 次の円柱\n        }\n        \n        vec3 rp = ro + tc * rd; // レイを円柱まで伸ばす\n        float theta = atan(rp.y, rp.x);\n        theta += iTime * sin(n) * 0.5; // 円柱を軸周りに回転させる\n        theta = mod(theta, PI2); // 円柱を一周でつなげるために剰余をとる\n        \n        rp.z -= iTime * 0.5; // 円柱をZ軸の正方向に動かす\n        rp.z = fract(rp.z / 500.) * 500.; // 長時間経過時の精度低下対策\n        vec2 p = vec2(theta, rp.z * 2.) / PI2 * 6.; // 円柱表面上の座標\n        \n        // 矩形の四分木をつくる\n        for(int j = 0; j < 5; j++) {\n            if(hash12(floor(p)) < 0.5) {\n                break;\n            }\n            p *= 2.;\n        }\n        \n        //if(tc < t && hash12(floor(p) + n * 500. * PI) < 0.1) { // 円柱上のランダムな矩形が存在する場合\n        //if(tc < t && hash12(floor(p) + n * 50. * PI) < 0.1) { // 円柱上のランダムな矩形が存在する場合\n        if(hash12(floor(p) + n * 50. * PI) < 0.1) { // 円柱上のランダムな矩形が存在する場合\n            t = tc; // 円柱表面までのレイの長さ\n            normal = normalize(vec3(s * rp.xy, 0)); // 円柱の法線ベクトル\n            break;\n        }\n    }\n    \n    float ts = sphIntersect(ro, rd, lightPos, lightSize); // 球体までのレイの長さ\n    if(ts > 0. && ts < t) { // 球体がカメラの前方にある & 円柱よりも手前にある\n        t = ts; // 球体表面までのレイの長さ\n        normal = normalize(ro + t * rd - lightPos); // 球体の法線ベクトル\n    }\n    \n    vec2 srd = sign(rd.xy);\n    vec2 v = (srd * vec2(3, 1.3) - ro.xy) / rd.xy; // 左右と上下の壁までのレイの長さ\n    float tw = min(v.x, v.y);\n    //if(t > 1e5 - 10.) {\n    if(tw < t) { // 壁\n        t = tw; // 壁までのレイの長さ\n        normal = v.x < v.y ? vec3(-srd.x, 0, 0) : vec3(0, -srd.y, 0); // 壁の法線ベクトル\n    }\n    \n    return t;\n}\n\n// Schlickによるfresnel反射率の近似式\nfloat fs(float f0, float cosTheta) {\n    return f0 + (1. - f0) * pow(1. - cosTheta, 5.);\n}\n\n// 反射光の色\nvec3 reflCol(inout vec3 ro, inout vec3 rd, inout vec3 reflAtt) {\n    vec3 col = vec3(0); // 反射光の色\n    \n    vec3 normal; // 法線ベクトル\n    float t = castRay(ro, rd, normal); // 物体表面までレイを飛ばす\n    vec3 rp = ro + t * rd;\n    \n    vec3 lv = lightPos - rp; // 球体方向のベクトル\n    float L = length(lv); // 物体表面から球体中心までの距離\n    if(L < lightSize + EPS) {\n        col = vec3(1.);\n    }\n    \n    vec3 albedo = vec3(0.9); // アルベド（物体の色）\n    float amp = pow(sin(fract(T) * PI2) * 0.5 + 0.5, 2.);\n    float po = (0.02 + amp) * 30. / dot(lv, lv); // 光の強さ\n    vec3 ld = lv / L; // 光の向き（球体の方向）\n    float diff= max(dot(normal, ld), 0.); // 拡散反射\n    float spec = pow(max(dot(reflect(ld, normal), rd), 0.), 20.); // 鏡面反射\n    float sh = 1.; // 影\n    vec3 normal0 = normal;\n    if(castRay(rp + normal * EPS * 0.5, ld, normal) < L - lightSize - EPS) {\n        // 球体方向に飛ばしたレイが他の物体に遮られたので、影となる\n        sh = 0.5;\n    }\n    float m = 0.9; // メタルネス\n    col += albedo * (diff * (1. - m) + spec * m) * po * sh;\n    vec3 refl = reflect(rd, normal0); // レイの反射ベクトル\n    \n    //float invFog = exp(-t * t * .001);\n    //col *= invFog;\n    \n    col *= reflAtt; // 反射の減衰率を反映\n    \n    //refAtt *= albedo * fs(0.8, dot(refl, normal0)) * invFog;\n    reflAtt *= albedo * fs(0.8, dot(refl, normal0)); // 反射の減衰率を更新\n    \n    // レイの原点と方向を更新\n    ro = rp + normal0 * EPS;\n    rd = refl;\n    \n    return col;\n}\n\n// [-1.0, 1.0]の範囲でn通りの値をとる滑らかな階段状のノイズ\nfloat stepNoise(float x, float n) {\n    float i = floor(x);\n    float s = 0.2;\n    float u = smoothstep(.5 - s, .5 + s, fract(x));\n    float res = mix(floor(hash(i) * n), floor(hash(i + 1.) * n), u);\n    res /= (n - 1.) * 0.5;\n    return res - 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 画面上の座標の正規化\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1) * 0.5;\n    \n    vec3 col = vec3(0);\n    T = iTime * BPM / 60.;\n    \n    vec3 ro = vec3(0);\n    ro.x += stepNoise(T * 0.5, 5.) * 2.1; // カメラをx軸方向にランダムに動かす\n    ro.y += stepNoise(T * 0.5 - 500., 5.) * 1.1; // カメラをy軸方向にランダムに動かす\n    \n    float a = stepNoise(T * 0.5 - 1000., 2.) * 0.5 + 0.5;\n    a = 0.1 + a * 0.8;\n    vec3 ta = vec3(0, 0, ro.z - tan(a * PI * 0.5)); // カメラのターゲット座標\n    \n    vec3 dir = normalize(ta - ro); // カメラの向き\n    vec3 side = normalize(cross(dir, vec3(0, 1, 0)));\n    vec3 up = cross(side, dir);\n    \n    float fov = 60.; // FOV\n    fov += stepNoise(T * .5 - 1500., 2.) * 20.; // FOVをランダムに変える\n    vec3 rd = normalize(uv.x * side + uv.y * up + dir / tan(fov / 360. * PI)); // レイの方向（レイベクトル）\n    \n    // 球体を動かす\n    lightPos.xy = sin(vec2(8, 9) * iTime * 0.2) * 0.8;\n    lightPos.z = ro.z - 2. + sin(iTime);\n    \n    // カメラからレイを飛ばして物体表面で何回か反射させる\n    vec3 reflAtt = vec3(1); // 反射の減衰率\n    for(int i = 0; i < 4; i++) {\n        col += reflCol(ro, rd, reflAtt);\n    }\n    \n    col = pow(col, vec3(1. / 2.2)); // ガンマ補正\n    col = clamp(col, 0., 1.);\n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// 元のコード\n// N（円柱の枚数）が8以上だとAndroidのChromeでバグる\n// おそらく浮動小数点数の精度が原因で、sin((小さな値) + (Nに比例する大きな値)) の値が異なってしまう\n\n// 問題の箇所\n// if(hash12(floor(p) + n * 500. * PI) < 0.1) { // 円柱上のランダムな矩形が存在する場合\n\n/*\n// 乱数\n#define hash(x) fract(sin(x) * 5456.7343)\n\nconst float PI = acos(-1.); // 円周率\nconst float PI2 = acos(-1.) * 2.;\nconst float BPM = 135.;\nconst float EPS = 0.0001; // レイトレースに使う微小量\n\nconst float lightSize = 0.2; // 球体の半径\nvec3 lightPos; // 球体の中心座標\nfloat T; // BPMで速度調整した時間\n\n// 2Dの乱数\nfloat hash12(vec2 p) {\n    return hash(dot(p, vec2(23.6238, 11.7452)));\n}\n\n// レイと球の表面の交差判定関数\n// ref: sphIntersect() (Sphere) by iq\n// https://iquilezles.org/articles/intersectors\nfloat sphIntersect(vec3 ro, vec3 rd, vec3 ce, float ra) {\n    vec3 oc = ro - ce;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - ra * ra;\n    float h = b * b - c;\n    if(h < 0.) {\n        return -1.;\n    }\n    return -b - sqrt(h);\n}\n\n// カメラ(座標ro)から物体表面まで飛ばしたレイの長さ\n// ref: SphericalShellsWithSlits.shader by Kamoshika (myself)\n// https://github.com/Kamoshika-vrc/UnityShaders/blob/main/Shaders/SphericalShellsWithSlits.shader\nfloat castRay(vec3 ro, vec3 rd, out vec3 normal) {\n    float t = 1e5; // カメラからオブジェクトの表面まで伸ばしたレイの長さ\n    \n    // レイと円柱の交差判定のための準備\n    // ref: cylIntersect() (Cylinder) by iq\n    // https://iquilezles.org/articles/intersectors\n    float a = 1.0 - rd.z * rd.z;\n    float b = dot(ro.xy, rd.xy);\n    float co = dot(ro.xy, ro.xy);\n    float rc = sqrt(co); // Z軸とカメラの距離\n    \n    const int N = 10; // 円柱の枚数\n    const float delta = 1. / float(N); // 円柱の半径の刻み幅\n    for(int i = 0; i < N * 2; i++) { // N枚の円柱について、表側と裏側に分けて手前から順番に t を求める\n        float n = float(N - i); // 中心から数えて何番目の円柱か\n        float s = 1.; // 1のときは円柱の表側、-1の時は裏側\n        if(i >= N) { // 円柱の裏側\n            n = float(i - N + 1);\n            s = -1.;\n        }\n        float ra = n * delta; // 円柱の半径\n        \n        // 円柱が完全にカメラの背後にあるときはループを抜ける\n        if(b > ra) {\n            break;\n        }\n        \n        if(i == 0 && rc < ra) { // ループ1回目 & カメラが円柱の中にある\n            int nc = int(rc / delta); // カメラよりも内側にある円柱の枚数 (値は 0 以上 N 未満)\n            if(b < 0.) { // カメラの前方に円柱の表側があるので、そこまでループを飛ばす\n                i = N - nc - 1;\n            } else { // カメラの前方に円柱の表側はないので、一番近くの裏側までループを飛ばす\n                i = N + nc - 1;\n            }\n            continue; // 次の円柱\n        }\n        \n        float c = co - ra * ra;\n        float h = b * b - a * c; // 2次方程式の判別式\n        if(h < 0.) { // レイが円柱と交点をもたない\n            if(i < N) { // 円柱の表側\n                // 今の円柱と交点をもたないならばそれより内側の円柱と交点をもたないことは確定するので\n                // 交点をもつ可能性のある円柱の裏側までループを飛ばす\n                i = N * 2 - i - 1;\n            }\n            continue; // 次の円柱\n        }\n        \n        float tc = (-b - s * sqrt(h)) / a; // 2次方程式の解\n        if(tc < 1e-5) { // 円柱がカメラの後方にある\n            continue; // 次の円柱\n        }\n        \n        vec3 rp = ro + tc * rd; // レイを円柱まで伸ばす\n        float theta = atan(rp.y, rp.x);\n        theta += iTime * sin(n) * 0.5; // 円柱を軸周りに回転させる\n        theta = mod(theta, PI2); // 円柱を一周でつなげるために剰余をとる\n        \n        rp.z -= iTime * 0.5; // 円柱をZ軸の正方向に動かす\n        rp.z = fract(rp.z / 500.) * 500.; // 長時間経過時の精度低下対策\n        vec2 p = vec2(theta, rp.z * 2.) / PI2 * 6.; // 円柱表面上の座標\n        \n        // 矩形の四分木をつくる\n        for(int j = 0; j < 5; j++) {\n            if(hash12(floor(p)) < 0.5) {\n                break;\n            }\n            p *= 2.;\n        }\n        \n        if(hash12(floor(p) + n * 500. * PI) < 0.1) { // 円柱上のランダムな矩形が存在する場合\n            t = tc; // 円柱表面までのレイの長さ\n            normal = normalize(vec3(s * rp.xy, 0)); // 円柱の法線ベクトル\n            break;\n        }\n    }\n    \n    float ts = sphIntersect(ro, rd, lightPos, lightSize); // 球体までのレイの長さ\n    if(ts > 0. && ts < t) { // 球体がカメラの前方にある & 円柱よりも手前にある\n        t = ts; // 球体表面までのレイの長さ\n        normal = normalize(ro + t * rd - lightPos); // 球体の法線ベクトル\n    }\n    \n    vec2 srd = sign(rd.xy);\n    vec2 v = (srd * vec2(3, 1.3) - ro.xy) / rd.xy; // 左右と上下の壁までのレイの長さ\n    float tw = min(v.x, v.y);\n    //if(t > 1e5 - 10.) {\n    if(tw < t) { // 壁\n        t = tw; // 壁までのレイの長さ\n        normal = v.x < v.y ? vec3(-srd.x, 0, 0) : vec3(0, -srd.y, 0); // 壁の法線ベクトル\n    }\n    \n    return t;\n}\n\n// Schlickによるfresnel反射率の近似式\nfloat fs(float f0, float cosTheta) {\n    return f0 + (1. - f0) * pow(1. - cosTheta, 5.);\n}\n\n// 反射光の色\nvec3 reflCol(inout vec3 ro, inout vec3 rd, inout vec3 reflAtt) {\n    vec3 col = vec3(0); // 反射光の色\n    \n    vec3 normal; // 法線ベクトル\n    float t = castRay(ro, rd, normal); // 物体表面までレイを飛ばす\n    vec3 rp = ro + t * rd;\n    \n    vec3 lv = lightPos - rp; // 球体方向のベクトル\n    float L = length(lv); // 物体表面から球体中心までの距離\n    if(L < lightSize + EPS) {\n        col = vec3(1.);\n    }\n    \n    vec3 albedo = vec3(0.9); // アルベド（物体の色）\n    float amp = pow(sin(fract(T) * PI2) * 0.5 + 0.5, 2.);\n    float po = (0.02 + amp) * 30. / dot(lv, lv); // 光の強さ\n    vec3 ld = lv / L; // 光の向き（球体の方向）\n    float diff= max(dot(normal, ld), 0.); // 拡散反射\n    float spec = pow(max(dot(reflect(ld, normal), rd), 0.), 20.); // 鏡面反射\n    float sh = 1.; // 影\n    vec3 normal0 = normal;\n    if(castRay(rp + normal * EPS * 0.5, ld, normal) < L - lightSize - EPS) {\n        // 球体方向に飛ばしたレイが他の物体に遮られたので、影となる\n        sh = 0.5;\n    }\n    float m = 0.9; // メタルネス\n    col += albedo * (diff * (1. - m) + spec * m) * po * sh;\n    vec3 refl = reflect(rd, normal0); // レイの反射ベクトル\n    \n    //float invFog = exp(-t * t * .001);\n    //col *= invFog;\n    \n    col *= reflAtt; // 反射の減衰率を反映\n    \n    //refAtt *= albedo * fs(0.8, dot(refl, normal0)) * invFog;\n    reflAtt *= albedo * fs(0.8, dot(refl, normal0)); // 反射の減衰率を更新\n    \n    // レイの原点と方向を更新\n    ro = rp + normal0 * EPS;\n    rd = refl;\n    \n    return col;\n}\n\n// [-1.0, 1.0]の範囲でn通りの値をとる滑らかな階段状のノイズ\nfloat stepNoise(float x, float n) {\n    float i = floor(x);\n    float s = 0.2;\n    float u = smoothstep(.5 - s, .5 + s, fract(x));\n    float res = mix(floor(hash(i) * n), floor(hash(i + 1.) * n), u);\n    res /= (n - 1.) * 0.5;\n    return res - 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 画面上の座標の正規化\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1) * 0.5;\n    \n    vec3 col = vec3(0);\n    T = iTime * BPM / 60.;\n    \n    vec3 ro = vec3(0);\n    ro.x += stepNoise(T * 0.5, 5.) * 2.1; // カメラをx軸方向にランダムに動かす\n    ro.y += stepNoise(T * 0.5 - 500., 5.) * 1.1; // カメラをy軸方向にランダムに動かす\n    \n    float a = stepNoise(T * 0.5 - 1000., 2.) * 0.5 + 0.5;\n    a = 0.1 + a * 0.8;\n    vec3 ta = vec3(0, 0, ro.z - tan(a * PI * 0.5)); // カメラのターゲット座標\n    \n    vec3 dir = normalize(ta - ro); // カメラの向き\n    vec3 side = normalize(cross(dir, vec3(0, 1, 0)));\n    vec3 up = cross(side, dir);\n    \n    float fov = 60.; // FOV\n    fov += stepNoise(T * .5 - 1500., 2.) * 20.; // FOVをランダムに変える\n    vec3 rd = normalize(uv.x * side + uv.y * up + dir / tan(fov / 360. * PI)); // レイの方向（レイベクトル）\n    \n    // 球体を動かす\n    lightPos.xy = sin(vec2(8, 9) * iTime * 0.2) * 0.8;\n    lightPos.z = ro.z - 2. + sin(iTime);\n    \n    // カメラからレイを飛ばして物体表面で何回か反射させる\n    vec3 reflAtt = vec3(1); // 反射の減衰率\n    for(int i = 0; i < 4; i++) {\n        col += reflCol(ro, rd, reflAtt);\n    }\n    \n    col = pow(col, vec3(1. / 2.2)); // ガンマ補正\n    col = clamp(col, 0., 1.);\n    \n    fragColor = vec4(col, 1.);\n}\n*/","name":"Common","description":"","type":"common"}]}