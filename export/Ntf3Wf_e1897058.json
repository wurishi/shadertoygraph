{"ver":"0.1","info":{"id":"Ntf3Wf","date":"1622957724","viewed":87,"name":"SG_PerlinNoise","username":"soum1990","description":"Test perlin noise shader","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise","perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Perlin Noise study\n// Perlin Noise requires 3 steps:\n// 1) Generation of the perlin grid\n// 2) Calculation of dot product between a random gradient vector and the distance vector from each corner of the grid\n// 3) Bilinear interpolation of the calculated dot products onto the resulting pixel\n// 4*) Additional smoothiung function is applied so that noise transitions nicely between grids.\n*/\n\nstruct FSPNParms\n{\n    float octaves;\n    float fjump;\n    float roughness;\n    float frequency ;\n    vec2 translate;\n    float offset;\n    vec3 axis;\n    float angle;\n\n};\n\nFSPNParms _NoiseParms = FSPNParms(4.0, 1.8, 0.5, 0.66666, vec2(0,0), 0.0, vec3(0,1,0), 2.39996322972865332);\n\n\n\n//Picks a random gradiant direction to dot product with the distance vector\n\n/*\nfloat grad2(uint hash, float x , float y)\n{\n\n    uint h = uint(mod(float(hash),4.));\n    //uint h = hash & 3u;\n    vec2 gvec= vec2(0,0); \n    \n    switch(h){\n    case 0u: gvec = vec2(1.,1.); break;\n    case 1u: gvec = vec2(-1., 1.); break;\n    case 2u: gvec = vec2(1., -1.); break;\n    case 3u: gvec = vec2(-1., -1.); break;\n    }\n    return x*gvec.x + y*gvec.y; // Dot producting the distance vector with the gradient\n\n}\n*/\n\n/*\nfloat grad2(float hash, float x , float y)\n{\n    //int v = int(floor(N21(vec2(x,y))*4.));\n    int h = int(mod(hash, 4.));\n    vec2 gvec; \n    \n    switch(h){\n    case 0: gvec = vec2(1.,1.); break;\n    case 1: gvec = vec2(-1., 1.); break;\n    case 2: gvec = vec2(1., -1.); break;\n    case 3: gvec = vec2(-1., -1.); break;\n    }\n    return x*gvec.x + y*gvec.y;\n\n}\n*/\n\n\nfloat grad2( uint hash, float x, float y ) {\n    uint h = hash & 7u;      // Convert low 3 bits of hash code\n    float u = h<4u ? x : y;  // into 8 simple gradient directions,\n    float v = h<4u ? y : x;  // and compute the dot product with (x,y).\n    return ((h&1u)> 0u ? -u : u) + ((h&2u)>0u ? -2.0*v : 2.0*v);\n}\n\n\n\nfloat noise2d(vec2 uv)\n{\n    vec2 st = fract(uv);\n    // Grid points location\n    vec2 id = floor(uv);\n    id = mod(id, 255.);\n\n    // Smoothing function\n    vec2 lv =  st*st*st*(st*(st*6.-15.) + 10.);\n    vec4 hash = FAST_32_hash(uv);\n    \n    //Bilinear interpolation of the gradient dot products on each corner of the grid\n    \n    float ix0 = id.x;\n    float ix1 = mod(id.x + 1.0,255.);\n    //float ix1 = id.x + 1.;\n    float iy0 = id.y; \n    float iy1 = mod(id.y + 1.0,255.);\n    //float iy1 = id.y + 1.0;\n    \n    //Top left corner\n    //float nx0 = grad2(perm[int(mod(ix0 + float(perm[uint(iy0)]),255.))], st.x , st.y);\n    //float nx0 = grad2(id, lv.x, lv.y);\n    float nx0 = grad2(uint(hash1(uint(ix0 + hash1(uint(iy0))*255.))*255.), st.x , st.y);\n\n    \n    //bottom left corner\n    //float nx1 = grad2(perm[int(mod(ix0 + float(perm[uint(iy1)]),255.))], st.x, st.y-1.);\n    //float nx1 = grad2(id + vec2(0,1), lv.x , lv.y-1.);\n    float nx1 = grad2(uint(hash1(uint(ix0 + hash1(uint(iy1))*255.))*255.), st.x, st.y-1.);\n    \n    //Linear interpolation\n    float n0 = mix(nx0, nx1, lv.y);\n    \n    // top right corner\n    //nx0 = grad2(perm[int(mod(ix1 + float(perm[uint(iy0)]),255.))], st.x-1., st.y);\n\n    nx0 = grad2(uint(hash1(uint(ix1 + hash1(uint(iy0))*255.))*255.), st.x-1., st.y);\n    //nx0 = grad2(id + vec2(1,0), lv.x-1.,lv.y);\n    //nx0 = grad2( hash.y, st.x-1., st.y);\n    \n    // bottom right corner\n    //nx1 = grad2(perm[int(mod(ix1 + float(perm[uint(iy1)]),255.))], st.x-1., st.y-1.);\n\n    nx1 = grad2(uint(hash1(uint(ix1 + hash1(uint(iy1))*255.))*255.), st.x-1., st.y-1.);\n    //nx1 = grad2(id + vec2(1,1), st.x-1., st.y-1.);\n    //nx1 = grad2(hash.w, st.x-1., st.y-1.);\n    float n1 = mix(nx0,nx1, lv.y);\n    \n    // Bilinear final interp\n    return 0.507f * (mix(n0,n1, lv.x));\n}\n\n// Fractal Sum Perlin Noise\nfloat FSPN(vec2 x)\n{\n    float exponent = 1.;\n    float amplitude = 1.;\n    float accum = 0.;\n    int ioct = int(_NoiseParms.octaves);\n    vec2 X = (x - _NoiseParms.translate);\n    if( _NoiseParms.angle > 0.)\n    {\n        float ca = cos(_NoiseParms.angle);\n        float sa = cos(_NoiseParms.angle);\n        X = vec2(X.x*ca, X.y*sa);\n    \n    }\n    X *= _NoiseParms.frequency*exponent;\n    for (int oc=0; oc<ioct; oc++)\n    {\n       accum += amplitude * noise2d(X);\n       X *= _NoiseParms.fjump;\n       amplitude *= _NoiseParms.roughness;\n    }\n    float val = amplitude * noise2d(X);\n    accum += (_NoiseParms.octaves - floor(_NoiseParms.octaves))* val;\n    \n    return (accum+_NoiseParms.offset);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    //uv += iTime * .1;\n    uv *= 10.;\n    \n    _NoiseParms.translate.x = iTime;\n    //uv *= _NoiseParms.angle;\n    float c = smoothstep(-.9, .9, FSPN(uv));\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec2 col = floor (uv)/20.0;\n    // Output to screen\n    //fragColor = vec4(col,0.0,1.0);\n    fragColor = vec4(vec3(c),1.0);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"uint perm[] = uint[](151u,160u,137u,91u,90u,15u,\n  131u,13u,201u,95u,96u,53u,194u,233u,7u,225u,140u,36u,103u,30u,69u,142u,8u,99u,37u,240u,21u,10u,23u,\n  190u, 6u,148u,247u,120u,234u,75u,0u,26u,197u,62u,94u,252u,219u,203u,117u,35u,11u,32u,57u,177u,33u,\n  88u,237u,149u,56u,87u,174u,20u,125u,136u,171u,168u, 68u,175u,74u,165u,71u,134u,139u,48u,27u,166u,\n  77u,146u,158u,231u,83u,111u,229u,122u,60u,211u,133u,230u,220u,105u,92u,41u,55u,46u,245u,40u,244u,\n  102u,143u,54u, 65u,25u,63u,161u, 1u,216u,80u,73u,209u,76u,132u,187u,208u, 89u,18u,169u,200u,196u,\n  135u,130u,116u,188u,159u,86u,164u,100u,109u,198u,173u,186u, 3u,64u,52u,217u,226u,250u,124u,123u,\n  5u,202u,38u,147u,118u,126u,255u,82u,85u,212u,207u,206u,59u,227u,47u,16u,58u,17u,182u,189u,28u,42u,\n  223u,183u,170u,213u,119u,248u,152u, 2u,44u,154u,163u, 70u,221u,153u,101u,155u,167u, 43u,172u,9u,\n  129u,22u,39u,253u, 19u,98u,108u,110u,79u,113u,224u,232u,178u,185u, 112u,104u,218u,246u,97u,228u,\n  251u,34u,242u,193u,238u,210u,144u,12u,191u,179u,162u,241u, 81u,51u,145u,235u,249u,14u,239u,107u,\n  49u,192u,214u, 31u,181u,199u,106u,157u,184u, 84u,204u,176u,115u,121u,50u,45u,127u, 4u,150u,254u,\n  138u,236u,205u,93u,222u,114u,67u,29u,24u,72u,243u,141u,128u,195u,78u,66u,215u,61u,156u,180u,\n  151u,160u,137u,91u,90u,15u,\n  131u,13u,201u,95u,96u,53u,194u,233u,7u,225u,140u,36u,103u,30u,69u,142u,8u,99u,37u,240u,21u,10u,23u,\n  190u, 6u,148u,247u,120u,234u,75u,0u,26u,197u,62u,94u,252u,219u,203u,117u,35u,11u,32u,57u,177u,33u,\n  88u,237u,149u,56u,87u,174u,20u,125u,136u,171u,168u, 68u,175u,74u,165u,71u,134u,139u,48u,27u,166u,\n  77u,146u,158u,231u,83u,111u,229u,122u,60u,211u,133u,230u,220u,105u,92u,41u,55u,46u,245u,40u,244u,\n  102u,143u,54u, 65u,25u,63u,161u, 1u,216u,80u,73u,209u,76u,132u,187u,208u, 89u,18u,169u,200u,196u,\n  135u,130u,116u,188u,159u,86u,164u,100u,109u,198u,173u,186u, 3u,64u,52u,217u,226u,250u,124u,123u,\n  5u,202u,38u,147u,118u,126u,255u,82u,85u,212u,207u,206u,59u,227u,47u,16u,58u,17u,182u,189u,28u,42u,\n  223u,183u,170u,213u,119u,248u,152u, 2u,44u,154u,163u, 70u,221u,153u,101u,155u,167u, 43u,172u,9u,\n  129u,22u,39u,253u, 19u,98u,108u,110u,79u,113u,224u,232u,178u,185u, 112u,104u,218u,246u,97u,228u,\n  251u,34u,242u,193u,238u,210u,144u,12u,191u,179u,162u,241u, 81u,51u,145u,235u,249u,14u,239u,107u,\n  49u,192u,214u, 31u,181u,199u,106u,157u,184u, 84u,204u,176u,115u,121u,50u,45u,127u, 4u,150u,254u,\n  138u,236u,205u,93u,222u,114u,67u,29u,24u,72u,243u,141u,128u,195u,78u,66u,215u,61u,156u,180u\n);\n\nfloat N21(vec2 uv)\n{\n    return (fract(sin(uv.x*100. + uv.y*6574.)*5647.));\n\n}\n\nvec4 FAST_32_hash(vec2 gridcell)\n{\n    const vec2 OFFSET = vec2(26., 161.);\n    const float DOMAIN = 71.;\n    const float SOMELARGEFLOAT = 951.135664;\n    \n    vec4 p = vec4(gridcell.xy, gridcell.xy + vec2(1,1));\n    p = p - floor(p * (1./DOMAIN)) * DOMAIN;\n    p += OFFSET.xyxy;\n    p*=p;\n    return fract(p.xzxz * p.yyww *(1.0/SOMELARGEFLOAT));\n\n}\n\nfloat hash1( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}","name":"Common","description":"","type":"common"}]}