{"ver":"0.1","info":{"id":"3dVSRm","date":"1573733871","viewed":258,"name":"4.8^2 Truchet Weave","username":"fizzer","description":"A 'weaved' version of my 4.8^2 semi-regular Truchet tiling ([url=https://www.shadertoy.com/view/MlyBRG]this one[/url]).","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["truchet","tiling","weaving","weave","octagon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This is a 'weaved' version of my 4.8^2 semi-regular truchet tiling, which\n// you can see here: https://www.shadertoy.com/view/MlyBRG\n\nconst float pi = 3.141592653589;\nconst float r = .02;\nconst float r2 = .005;\nconst float slope = .1;\nconst vec2 dir = vec2(.1, slope);\nconst float r3 = (r + r2 * 0.15) / (dir.x / length(dir));\n\n// Pixel width for anti-aliasing.\nfloat w;\n\n\nfloat hash(vec2 p)\n{\n    return texelFetch(iChannel0, ivec2(p) & 255, 0).r;\n}\n\n// (via comments on https://www.shadertoy.com/view/wdBSRm):\n// adx's considerably more concise version of the method above.\n// On a side note, if you haven't seen it before, his \"Quake / Introduction\" \n// shader is well worth the look: https://www.shadertoy.com/view/lsKfWd\nvoid solveCircle(vec2 a, vec2 b, out vec2 o, out float r){\n    \n    vec2 m = a + b;\n    o = dot(a, a)/dot(m, a)*m;\n    r = length(o - a);\n    \n}\n\nfloat arcDistance(vec2 p, vec2 a, vec2 b)\n{\n    if(abs(a.x * b.y - a.y * b.x) < 1e-5)\n        return distance(p, mix(a, b, clamp(dot(p - a, b - a) / dot(b - a,b - a), 0., 1.)));\n\n    vec2 o;\n    float r;\n    solveCircle(a, b, o, r);\n    return abs(distance(p, o) - r);\n}\n\n// Draws a line or arc connecting a and b inside a polygon.\nfloat l(vec2 p, vec2 a, vec2 b)\n{\n    float d = arcDistance(p, a, b);\n    return smoothstep(0.03, 0.03 - w * 2., d - .04);\n}\n\n// Based on https://www.shadertoy.com/view/llGSzw\nuint hash1( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\n\nvoid sdRope(vec2 p, out float mask_d, out float outline_d)\n{    \n    float pd = dot(p, vec2(dir.y, -dir.x)) / ((r + r2 * 0.15) * 2. * length(dir));\n    \n    p.y += 2. * r3 * floor(pd) + r3;\n    \n    vec2 q = dir * clamp(dot(p, dir) / dot(dir, dir), -.5, +.5);\n    \n    float d = distance(p, q) - r;\n    \n    mask_d = d - r2;\n    outline_d = min(max(-d, abs(p.x) - r * 3.), abs(d) - r2);\n}\n\nvec4 arcDistanceRope(vec2 p, vec2 a, vec2 b)\n{\n    float mask_d;\n    float outline_d;\n    float mask2;\n\n    float sr = r3 * 2.;\n\n    if(abs(a.x * b.y - a.y * b.x) < 1e-5)\n    {\n    \tfloat ld = distance(p, mix(a, b, clamp(dot(p - a, b - a) / dot(b - a,b - a), 0., 1.)));\n        \n        vec2 n = normalize(b - a);\n\n        float da = dot(a, n);\n        float db = dot(b, n);\n        float d = dot(p, n);\n        \n        vec2 q = vec2(dot(p, -vec2(n.y,-n.x)), mix(round(da / sr) * sr, round(db / sr) * sr, (d - da) / (db - da)));\n\n        sdRope(q + vec2(0., r3), mask_d, outline_d);\n\n        mask2 = ld-.05;\n    }\n    else\n    {    \n        vec2 o;\n        float r;\n        solveCircle(a, b, o, r);\n        \n        vec2 nm = normalize((a + b) / 2. - o);\n        \n        vec2 na = normalize(a - o);\n        vec2 nb = normalize(b - o);\n        vec2 np = normalize(p - o);\n\n        float tha = asin(na.x * nm.y - na.y * nm.x) * r;\n        float thb = asin(nb.x * nm.y - nb.y * nm.x) * r;\n        float th = asin(np.x * nm.y - np.y * nm.x) * r;\n\n        vec2 q = vec2(length(p - o) - r, mix(round(tha / sr) * sr, round(thb / sr) * sr, (th - tha) / (thb - tha)));\n\n        sdRope(q + vec2(0., r3), mask_d, outline_d);\n\n        mask2 = abs(distance(p, o) - r)-.05;\n    }\n\n    vec3 col = vec3(mix(vec3(.02), vec3(.8), smoothstep(0.0, w, outline_d)));\n    \n    return vec4(col, 1. - smoothstep(0.0, w, mask2 - 0.05));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.y;\n    \n    fragColor = vec4(1);\n\n    vec2 p = uv.xy * 6. + iMouse.xy / iResolution.xy * 10.;\n\n    w = max(length(dFdx(p)), length(dFdy(p)));\n\n    p.x += iTime / 3.;\n\n    float el = tan(2. * pi / 16.);\n    float hyp = sqrt(1. - el * el);\n    float d = cos(2. * pi / 16.) * hyp;\n\n    vec2 ip = floor(p - .5) * 2.;\n    vec2 fpa = abs(fract(p) - .5);\n    vec2 fp = fract(p - .5) - .5;\n\n    vec4 a = vec4(vec3(.8), 0.);\n    float b = hash(ip);\n    float c = 0.;\n\n    uint num_inds = 0U;\n    float th = 0., thoffset = 0.;\n    float r = 1.;\n\n    if(fpa.x + fpa.y < (1. - sqrt(2.) / 2.))\n    {\n        // Square.\n        ip = floor(p) * 2. +1.;\n        b = hash(ip);\n        fp = fract(p) - .5;\n        if(b > .5)\n            fp = fp.yx * vec2(1, -1);\n\n        num_inds = 4U;\n        th = pi * 2. / 4.;\n        r = .5 * d;\n        thoffset = th / 2.;\n\n        c = max(c, smoothstep((1. - sqrt(2.) / 2.) - w * sqrt(2.) * 2., (1. - sqrt(2.) / 2.), max(abs(fp.x + fp.y), abs(fp.y - fp.x))));\n    }\n    else\n    {\n        // Octagon.\n        th = floor(mod(b,.25)/.25*8.) * pi * 2. / 8.;\n        fp *= mat2(cos(th), sin(th), -sin(th), cos(th));\n\n        th = pi * 2. / 8.;\n\n        num_inds = 8U;\n\n        float d = max(abs(fp.x + fp.y) / sqrt(2.), abs(fp.y - fp.x) / sqrt(2.));\n        c = max(c, smoothstep(.5 - w * 2., .5, max(d, max(abs(fp.x), abs(fp.y)))));\n    }\n\n    \n    // Shuffle the indices by using the Fisher-Yates algorithm\n    // https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle\n\n    uint inds[8];\n    \n\tinds[0] = 0U;\n    \n    uint seed = uint(ip.x + ip.y * 8192.)*319U;\n    for(uint j = 1U; j < num_inds; ++j)\n    {\n        seed = hash1(seed);\n        uint k = seed % j;\n        uint temp = inds[k];\n        inds[k] = j;\n        inds[j] = temp;\n    }\n\n    // Draw the arcs.\n    \n    for(uint j = 0U; j < num_inds; j += 2U)\n    {\n        uint ia = inds[j];\n        uint ib = inds[j + 1U];\n        vec2 pa = vec2(cos(th * float(ia) - thoffset), sin(th * float(ia) - thoffset)) * r / 2.;\n        vec2 pb = vec2(cos(th * float(ib) - thoffset), sin(th * float(ib) - thoffset)) * r / 2.;\n        vec4 d = arcDistanceRope(fp, pa, pb);\n        a = mix(a, d, d.a);\n    }\n    \n    \n    // Shade.\n    vec3 col = mix(vec3(1), vec3(.3), c);\n\n    float l = 1. - (min(fract(iTime / 6.) * 2., 2. - 2. * fract(iTime / 6.)) - .5) * 16.;\n\n    fragColor.rgb = mix(a.rgb, a.rgb * col, (1. - a.a) * smoothstep(0., 1., l));\n\n    // Gamma etc.\n    fragColor.rgb = pow(fragColor.rgb, vec3(1. / 2.2));\n}\n\n","name":"Image","description":"","type":"image"}]}