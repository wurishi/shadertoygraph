{"ver":"0.1","info":{"id":"4syGzW","date":"1453633447","viewed":234,"name":"Three Shapes","username":"mcjohnalds","description":"Draws some shapes using ray marching. Has bump maps thingies, AO, soft shadows (kinda broken).","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["procedural","raymarching","spheretracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"const bool MOUSE_ROTATION = true;\nconst int MAX_ITERATIONS = 255;\nconst float STOP_THRESHOLD = 0.001;\nconst float GRADIENT_STEP = 0.1;\nconst float CLIP_FAR = 500.0;\nconst int NUM_LIGHTS = 2;\nconst int NUM_MATERIALS = 4;\nconst vec3 SKY_COLOR = vec3(0.9, 0.9, 1.0);\nconst float FOG_FALLOFF = 0.1;\n\nconst float PI = 3.14159265359;\nconst float TAU = 2.0 * PI;\n\nstruct PointLight {\n    vec3 pos;\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n};\n\nstruct Material {\n    vec3 emission;\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float shininess;\n};\n\nstruct Camera {\n    vec3 pos;\n    vec2 angles;\n};\n\nstruct Scene {\n\tCamera camera;\n    PointLight lights[NUM_LIGHTS];\n    Material materials[NUM_MATERIALS];\n};\n  \nstruct RaymarchedObject {\n    float dist;\n    int material;\n};\n    \nfloat combine(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat difference(float d1, float d2) {\n    return max(d1, -d2);\n}\n\nfloat intersect(float d1, float d2) {\n    return max(d1, d2);\n}\n\nvec3 move(vec3 p, vec3 translation) {\n    return p - translation;\n}\n\nvec3 rotateX(vec3 p, float a) {\n\tfloat c = cos(a);\n    float s = sin(a);\n    float y = c * p.y - s * p.z;\n    float z = s * p.y + c * p.z;\n    return vec3(p.x, y, z);\n}\n\nvec3 rotateY(vec3 p, float a) {\n\tfloat c = cos(a);\n    float s = sin(a);\n\tfloat x = c * p.x + s * p.z;\n\tfloat z = -s * p.x + c * p.z;\n    return vec3(x, p.y, z);\n}\n\nvec3 rotateZ(vec3 p, float a) {\n\tfloat c = cos(a);\n    float s = sin(a);\n\tfloat x = c * p.x - s * p.y;\n\tfloat y = s * p.x + c * p.y;\n    return vec3(x, y, p.z);\n}\n\n// Distance functions.\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat boxUDF(vec3 p, vec3 size) {\n    return length(max(abs(p) - size, 0.0));\n}\n\nfloat boxSDF(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat roundBoxUDF(vec3 p, vec3 b, float r) {\n\treturn length(max(abs(p) - b, 0.0)) - r;\n}\n\nfloat planeSDF(vec3 p, vec4 n) {\n\treturn dot(p, n.xyz) + n.w;\n}\n\nfloat carvedBoxUDF(vec3 pos) {\n    float s = sphereSDF(pos, 2.5);\n    float b = boxUDF(pos, vec3(2.0));\n    return difference(b, s);\n}\n\nfloat cornerSDF(vec3 p) {\n    float outer = boxSDF(p, vec3(2.0));\n    float inner = boxSDF(p - vec3(0.5), vec3(2.0));\n    return difference(outer, inner);\n}\n\nRaymarchedObject combine(RaymarchedObject a, RaymarchedObject b) {\n    if (a.dist < b.dist) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\nfloat honeyDipperDistortion(vec3 p) {\n    return 0.1 * sin(5.0 * p.x);\n}\n\nfloat sandDistortion(vec3 p) {\n    return texture(iChannel0, p.xz * 0.1).r * 0.04 + texture(iChannel1, p.xz * 0.002).r * 4.0 - 3.0;\n}\n\nvec3 toGrayscale(vec3 color) {\n\tfloat average = (color.r + color.g + color.b) / 3.0;\n\treturn vec3(average);\n}\n\nfloat brushedMetalDistortion(vec3 p) {\n    return toGrayscale(texture(iChannel2, p.xz * 0.3).rgb).r * 0.1;\n}\n\nfloat woodDistortion(vec3 p) {\n    return toGrayscale(texture(iChannel2, p.yz * 0.3).rgb).r * 0.2;\n}\n\n// Get distance in the world.\nRaymarchedObject distanceField(vec3 pos) {\n    RaymarchedObject o;\n    o.dist = CLIP_FAR;\n    \n    RaymarchedObject plane;\n    plane.dist = planeSDF(pos, vec4(0.0, 1.0, 0.0, 0.0));\n    plane.dist -= sandDistortion(pos);\n    plane.material = 2;\n    o = combine(o, plane);\n    \n    RaymarchedObject sphere;\n    vec3 sphereP = pos - vec3(-6.0, 1.0, 0.0);\n    sphereP = rotateZ(sphereP, -0.01 * TAU);\n    sphere.dist = sphereSDF(sphereP, 2.7);\n    sphere.dist -= woodDistortion(sphereP);\n    sphere.dist -= honeyDipperDistortion(sphereP);\n    sphere.material = 1;\n    o = combine(o, sphere);\n    \n    RaymarchedObject cBox;\n    vec3 cBoxP = pos - vec3(6.0, 2.4, 0.0);\n    cBoxP = rotateX(rotateY(cBoxP, 0.2 * TAU), 0.01 * TAU);\n    cBoxP = cBoxP;\n    cBox.dist = carvedBoxUDF(cBoxP);\n    cBox.material = 3;\n    o = combine(o, cBox);\n    \n    RaymarchedObject corner;\n    vec3 cornerP = pos - vec3(0.0, 2.6, 0.0);\n    cornerP = rotateX(cornerP, 0.002 * TAU);\n    cornerP = rotateZ(cornerP, -0.002 * TAU);\n    corner.dist = cornerSDF(cornerP);\n    corner.dist -= brushedMetalDistortion(cornerP) * 0.2;\n    corner.material = 0;\n    o = combine(o, corner);\n    \n    return o;\n}\n\nfloat shadow(vec3 ro, vec3 rd)\n{\n    float res = 1.0;\n    const float mint = 0.5;\n    const float maxt = 13.5;\n    const float k = 2.0;\n    float t = mint;\n    \n    for (int i = 0; i < 16; i++) {\n        if (t > maxt) {\n            break;\n        }\n        float h = distanceField(ro + rd*t).dist;\n        res = min(res, k * h / t);\n        if (h < 0.001) {\n            return 0.0;\n        }\n        t += h;\n    }\n    return res;\n}\n\nfloat ambientOcclusion(vec3 pos, vec3 nor) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 6; i++) {\n        float hr = 0.02 + 0.1 * float(i) / 4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = distanceField(aopos).dist;\n        occ += -(dd - hr) * sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0 * occ, 0.0, 1.0 );    \n}\n\nMaterial getMaterial(Material materials[NUM_MATERIALS], int material) {\n    // materials[material] not allowd b.c non-constant array access isn't allowed.\n    for (int i = 0; i <= NUM_MATERIALS; i++) {\n        if (i == material) {\n        \treturn materials[i];\n        }\n    }\n    \n    return materials[0];\n}\n\nvec3 spotLight(vec3 point, vec3 normal, vec3 eye, PointLight light, Material mat) {\n    // Based off https://en.wikipedia.org/wiki/Phong_reflection_model#Description.\n    \n    // Ambient occlusion\n    float ao = ambientOcclusion(point, normal);\n    \n    // Direction from the point to the light source\n    vec3 wi = normalize(light.pos - point);\n    \n    // Ambient\n    vec3 ambient = light.ambient + mat.ambient;\n\n    // Diffuse\n    vec3 l = normalize(light.pos - point);\n    vec3 kd = light.diffuse * mat.diffuse;\n    vec3 diffuse = kd * dot(l, normal);\n    diffuse *= shadow(point, wi);\n    diffuse = clamp(diffuse, 0.0, 1.0);\n    \n    // Specular\n    vec3 specular = vec3(0.0);\n    vec3 r = reflect(l, normal);\n    vec3 ks = light.specular * mat.specular;\n    vec3 v = normalize(eye - point);\n    // TODO: Why do I have to max(0.0, -dot(r, v)) instead of dot(r, v)?\n    specular = ks * pow(max(0.0, -dot(r, v)), mat.shininess);\n    specular = clamp(specular, 0.0, 1.0);\n    \n    // Scene color\n    vec3 sceneColor = mat.emission + mat.ambient;\n    \n    // Total color\n    return sceneColor + ambient * ao + diffuse + specular;\n}\n\n// Phong shading.\nvec3 getSurfaceShading(Scene s, vec3 point, vec3 normal, vec3 eyePos, PointLight lights[NUM_LIGHTS], int matID) {\n    vec3 final = vec3(0.0);\n    Material mat = getMaterial(s.materials, matID);\n    \n    // Loop manually unrolled b.c stupid compiler bug\n    /*for (int i = 0; i < NUM_LIGHTS; i++) {\n        final += spotLight(point, normal, eyePos, lights[i], mat);\n    }*/\n    final += spotLight(point, normal, eyePos, lights[0], mat);\n    final += spotLight(point, normal, eyePos, lights[1], mat);\n    \n    if (matID == 0) {\n        return final * (0.5 + 0.5 * toGrayscale(texture(iChannel2, point.xz * 0.3).rgb));\n    } else if (matID == 1) {\n        return final * (0.5 + 0.5 * texture(iChannel2, point.xz * 0.3).rgb);\n    } else if (matID == 2) {\n        return final * (0.8 + 0.2 * texture(iChannel2, point.xz * 0.3).rgb);\n    } else if (matID == 3) {\n        return final * (0.5 + 0.5 * toGrayscale(texture(iChannel3, point.yx * 0.3).rgb));\n    } else {\n        return vec3(0.0);\n    }\n}\n\n// Get the surface normal.\nvec3 getSurfaceNormal(vec3 pos) {\n    const vec3 dx = vec3(GRADIENT_STEP, 0.0, 0.0);\n    const vec3 dy = vec3(0.0, GRADIENT_STEP, 0.0);\n    const vec3 dz = vec3(0.0, 0.0, GRADIENT_STEP);\n    return normalize(\n        vec3(\n            distanceField(pos + dx).dist - distanceField(pos - dx).dist,\n            distanceField(pos + dy).dist - distanceField(pos - dy).dist,\n            distanceField(pos + dz).dist - distanceField(pos - dz).dist\n        )\n    );\n}\n\n// Use the ray marching algo to get the depth at this pixel.\nRaymarchedObject raymarch(vec3 rayOrigin, vec3 rayDir) {\n    float depth = 0.0; // Starting depth is 0\n    for (int i = 0; i < MAX_ITERATIONS; i++) {\n        RaymarchedObject o = distanceField(rayOrigin + rayDir * depth);\n        if (o.dist < STOP_THRESHOLD) {\n            o.dist = depth;\n            return o;\n        }\n        depth += o.dist;\n        if (depth >= CLIP_FAR) {\n            o.dist = CLIP_FAR;\n            return o;\n        }\n    }\n    \n    RaymarchedObject o;\n    o.dist = CLIP_FAR;\n    return o;\n}\n\nvec3 getRayDirection(float fov, vec2 size, vec2 pos) {\n    vec2 xy = pos - size * 0.5;\n\n    float cotHalfFov = tan((90.0 - fov * 0.5) * PI / 180.0);\n    float z = size.y * 0.5 * cotHalfFov;\n\n    return normalize(vec3(xy, -z));\n}\n\n// Returns a rotation matrix around the x and y axes.\nmat3 rotationXY(vec2 angles) {\n    vec2 c = cos(angles);\n    vec2 s = sin(angles);\n\n    return mat3(\n        c.y, 0.0, -s.y,\n        s.y * s.x, c.x, c.y * s.x,\n        s.y * c.x, -s.x, c.y * c.x\n    );\n}\n\nvec3 applyFog(vec3 col, float dist) {\n    return mix(col, SKY_COLOR, 1.0 - exp(-FOG_FALLOFF * dist * dist / CLIP_FAR));\n}\n\nvec4 renderScene(vec2 fragCoord, Scene s) {\n    // Viewer's location\n    vec3 eye = s.camera.pos;\n    vec3 dir = getRayDirection(70.0, iResolution.xy, fragCoord.xy);\n\n    // Rotate camera\n    mat3 rot = rotationXY(s.camera.angles);\n    dir = rot * dir;\n    eye = rot * eye;\n    \n    // Ray marching\n    RaymarchedObject o = raymarch(eye, dir);\n    \n    if (o.dist >= CLIP_FAR) {\n        return vec4(SKY_COLOR, 1.0);\n    }\n\n    // Shading\n    vec3 pos = eye + dir * o.dist;\n    vec3 n = getSurfaceNormal(pos);\n    vec3 col = getSurfaceShading(s, pos, n, eye, s.lights, o.material);\n    col = applyFog(col, o.dist);\n    return vec4(clamp(col, 0.0, 1.0), 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    Scene s;\n    \n    s.camera.pos = vec3(0.0, 0.0, 10.0);\n    s.camera.angles = vec2(-TAU * 0.1, TAU * 0.1);\n    \n\tif (MOUSE_ROTATION) {\n        vec2 mouse = iMouse.xy / iResolution.xy;\n        vec2 mouseRot = vec2(0, -mouse.x * TAU - 0.13 * TAU);\n        s.camera.angles += mouseRot;\n    }\n    \n    s.lights[0].pos = vec3(-4.0, 4.0, 10.0);\n    s.lights[0].diffuse = vec3(0.7);\n    s.lights[0].specular = vec3(0.6, 0.6, 0.6);\n    s.lights[0].ambient = vec3(0.0);\n    \n    s.lights[1].pos = vec3(1.0, 200.0, 0.0);\n    s.lights[1].diffuse = vec3(0.85, 0.85, 0.7) * 0.7;\n    s.lights[1].specular = vec3(0.85, 0.85, 0.7) * 0.2;\n    s.lights[1].ambient = vec3(0.08, 0.08, 0.09) * 1.5;\n    \n    // Brushed metal\n    s.materials[0].diffuse = vec3(2.0);\n    s.materials[0].specular = vec3(0.9);\n    s.materials[0].emission = vec3(0.0);\n    s.materials[0].shininess = 10.0;\n    \n    // Polished wood\n    s.materials[1].diffuse = vec3(0.95, 0.9, 0.9);\n    s.materials[1].specular = vec3(0.8);\n    s.materials[1].emission = vec3(0.0);\n    s.materials[1].shininess = 4.0;\n    \n    // Sand\n    s.materials[2].diffuse = vec3(0.93, 0.89, 0.72);\n    s.materials[2].specular = vec3(0.0, 0.0, 0.0);\n    s.materials[2].emission = vec3(0.0);\n    s.materials[2].shininess = 1.0;\n    \n    // Something else\n    s.materials[3].diffuse = vec3(1.0, 1.0, 1.3);\n    s.materials[3].specular = vec3(1.0);\n    s.materials[3].emission = vec3(0.0);\n    s.materials[3].shininess = 16.0;\n    \n    fragColor = renderScene(fragCoord, s);\n}","name":"","description":"","type":"image"}]}