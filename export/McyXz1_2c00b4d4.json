{"ver":"0.1","info":{"id":"McyXz1","date":"1715310766","viewed":68,"name":"Fluid sim - krisp","username":"krisp","description":"based on https://www.researchgate.net/publication/229039366_Simple_and_Fast_Fluids","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["simulation","fluid","navierstrokes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 o, in vec2 p )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 res = iResolution.xy;\n    vec2 uv = p/res;\n\n    vec3 col =  texture(iChannel0, uv).rgb;\n    \n    //chromatic abberation\n    col.r =  texture(iChannel0, uv + vec2(2.0/res.x,0)).r;\n    col.b =  texture(iChannel0, uv - vec2(2.0/res.x,0)).b;\n    \n    //col.xy = col.xy*0.5+0.5;\n    \n    //col = texelFetch(iChannel1, ivec2(0), 0).rgb/vec3(1,1, 100000);\n    \n    //draw boundaries\n    col = boundaries(p,res) ? vec3(0.1) : col;\n    col += vec3(.05);\n    \n    //vignette\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 200.0;\n    vig = pow(vig, 0.25);\n    vig = clamp(vig, 0.0,1.0);\n\n    col *= vig;\n    \n    // Output to screen\n    o = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 o, in vec2 p )\n{\n    vec4 mouseOld = texelFetch(iChannel0, ivec2(0), 0) * vec4(iResolution.xy, 1, 1);\n    vec4 fluidData = simulateFluid(p, iResolution.xy, iChannel0, iMouse, mouseOld, iTime);\n       \n    if (ivec2(p) == ivec2(0)) \n    {\n        fluidData = iMouse / vec4(iResolution.xy, 1, 1);\n    }\n    \n    o = fluidData;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 o, in vec2 p )\n{\n    vec4 mouseOld = texelFetch(iChannel0, ivec2(0), 0) * vec4(iResolution.xy, 1, 1);\n    vec4 fluidData = simulateFluid(p, iResolution.xy, iChannel0, iMouse, mouseOld, iTime);\n       \n    if (ivec2(p) == ivec2(0)) \n    {\n        fluidData = iMouse / vec4(iResolution.xy, 1, 1);\n    }\n    \n    o = fluidData;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 o, in vec2 p )\n{\n    vec4 mouseOld = texelFetch(iChannel0, ivec2(0), 0) * vec4(iResolution.xy, 1, 1);\n    vec4 fluidData = simulateFluid(p, iResolution.xy, iChannel0, iMouse, mouseOld, iTime);\n       \n    if (ivec2(p) == ivec2(0)) \n    {\n        fluidData = iMouse / vec4(iResolution.xy, 1, 1);\n    }\n    \n    o = fluidData;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 o, in vec2 p )\n{\n    vec2 uv = p/iResolution.xy;\n    vec4 col = vec4(0,0,0,1);\n    \n    vec4 mouseOld = texelFetch(iChannel1, ivec2(0), 0);\n    \n    if (iFrame > 1 && !boundaries(p,iResolution.xy)) \n    { \n        //move colors by velocity\n        uv -= texture(iChannel0, uv).xy * dt/iResolution.xy;\n        //fade and diffuse old colors \n        col.rgb = texture(iChannel1, uv + colorDiffuse*(hash23(vec3(p, iFrame))-.5)).rgb * colorFade;\n        //draw colored segment between old and current mouse positions \n        col.rgb = sdSegment(p, iMouse.xy, mouseOld.xy, brushSize) < 0.0 && iMouse.z > 0.5 && mouseOld.z > 0.5 ? \n        pal( iTime, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) )\n        : col.rgb;\n    }\n    \n    if (ivec2(p) == ivec2(0)) {\n        col = iMouse;\n    }\n    \n    o = vec4(col);\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define K   0.2\n#define dt  0.1\n#define v   0.6\n#define stepSize 2.0\n\n#define brushSize 16.0\n#define noiseScale 8.0\n#define noiseStrength 0.25\n#define noiseSpeed 0.1\n\n#define colorDiffuse 0.0001\n#define colorFade 0.9995\n\nvec2 directions[] = vec2[](\nvec2( stepSize, 0),\nvec2(-stepSize, 0),\nvec2( 0, stepSize),\nvec2( 0,-stepSize));\n\n//hashes from https://www.shadertoy.com/view/4djSRW\n//based on the paper https://www.researchgate.net/publication/229039366_Simple_and_Fast_Fluids\n\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n//  2 out, 3 in... \nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//  2 out, 2 in... \nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, in float th )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2  q = pa-h*ba;\n    return length(q) - th;\n}\n\n//3D curl noise adapted from https://www.shadertoy.com/view/wstGDN and https://www.shadertoy.com/view/XsX3zB\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nvec3 curlNoise(vec3 p)\n{\n    const float dt0 = 1e-4;\n    vec2 ds = vec2(dt0, 0.0);\n    \n    float n0 = simplex3d(p);\n    float n1 = simplex3d(p + ds.xyy);\n    float n2 = simplex3d(p + ds.yxy);\n    \n    vec2 grad = vec2(n1 - n0, n2 - n0) / ds.x;\n    vec2 curl = vec2(grad.y, -grad.x);\n    return normalize(vec3(curl, n0));\n}\n\nbool boundaries (vec2 p, vec2 res) \n{    \n    //outer walls\n    bool b = p.x <= 4.0 || p.y <= 4.0 || p.x >= res.x - 4.0 || p.y >= res.y - 4.0;\n    \n    //obstacles\n    b = b || distance(fract(p/300.0), vec2(0.5)) < 0.1;\n    \n    return b;\n}\n\nvec4 simulateFluid( vec2 p, vec2 res, sampler2D tex, vec4 mouse, vec4 mouseOld, float time )\n{\n    float S = K/dt;\n    vec4 fc = texture(tex, p/res, 0.0);\n    vec3 fr = texture(tex, (p + vec2( stepSize, 0))/res, 0.0).xyz;\n    vec3 fl = texture(tex, (p + vec2(-stepSize, 0))/res, 0.0).xyz;\n    vec3 ft = texture(tex, (p + vec2( 0, stepSize))/res, 0.0).xyz;\n    vec3 fd = texture(tex, (p + vec2( 0,-stepSize))/res, 0.0).xyz;\n    \n    vec3 udx = (fr-fl) * 0.5;\n    vec3 udy = (ft-fd) * 0.5;\n    \n    float udiv = udx.x + udy.y;\n    vec2 ddx = vec2(udx.z, udy.z);\n    \n    //solve for density\n    fc.z -= dt*dot(vec3(ddx,udiv),fc.xyz);\n    fc.z = clamp(fc.z, 0.5, 3.0);\n    \n    //solve for velocity\n    vec2 pdx = S*ddx;\n    vec2 laplacian = fr.xy + fl.xy + ft.xy + fd.xy - 4.*fc.xy;\n    vec2 viscosityForce = v*laplacian;\n    \n    //semi-lagrangian advection\n    vec2 was = p - dt*fc.xy;\n    fc.xy = texture(tex, was/res).xy;\n    \n    //add external forces\n    vec2 force = curlNoise(vec3(p/res, time*noiseSpeed) * noiseScale).xy * dt * log(dot(fc.xy, fc.xy) + 1.0) * noiseStrength; \n    //this is terrible and wrong but it adds nice details\n    \n    if (mouse.z > 0.5 && mouseOld.z > 0.5 && sdSegment(p, mouse.xy, mouseOld.xy, brushSize) < 0.0)\n    {\n        force = (mouse.xy - mouseOld.xy) * 5.0;\n    }\n    \n    fc.xy += dt*(viscosityForce - pdx + force);\n\n    //boundary conditions \n    for (int i = 0; i < 4; i++) \n    {\n        if (boundaries(p+directions[i], res)) {\n            fc.xy *= vec2(1) - abs(directions[i]);\n        }\n    }\n    \n    return fc;\n}","name":"Common","description":"","type":"common"}]}