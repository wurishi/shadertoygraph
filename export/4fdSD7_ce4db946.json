{"ver":"0.1","info":{"id":"4fdSD7","date":"1714379123","viewed":89,"name":"Fork Gooey distance field","username":"chenxiang","description":"License CC0: Gooey distance field visualization\nWas trying to optimize my old Impulse logo but was bored with the simple visualization so played around a bit.\nGooey effect turned out quite nice so I share. Also quite cheap to compute","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"fssGR7","parentname":"Gooey distance field"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// License CC0: Gooey distance field visualization\n//  Was trying to optimize my old Impulse logo but was bored\n//  with the simple visualization so played around a bit.\n//  Gooey effect turned out quite nice so I share\n//  Also quite cheap to compute\n\n#define ROT(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\n#ifdef UNIFORM_PARAM\n\nuniform bool vertical; //[true]\nuniform bool vigneting; //[false]\n\nuniform float space; //[0.1,0.2,1.0]\nuniform float width; //[0.01,0.1,0.2]\nuniform float delay; //[0.1,1.0,2.0]\nuniform float speed; //[1.0,2.0,10.0]\nuniform float range; //[0.0,0.3,1.0]\nuniform float strike; //[0.0,0.5,1.0]\nuniform float offset; //[0.0,0.1,1.0]\nuniform float chroma; //[0.0,0.7,1.0]\nuniform float size; //[0.1,0.5,1.0]\nuniform float gap; //[0.4,0.6,1.0]\n\n#else\n\nconst bool vertical = false;\nconst bool vigneting = false;\n\nconst float space = 0.2;\nconst float width = 0.05;\nconst float delay = 1.0;\nconst float speed = 2.0;\nconst float range = 0.3;\nconst float strike = 0.5;\nconst float offset = 1.0;\nconst float chroma = 0.7;\nconst float size = 0.5;\nconst float gap = 0.6;\n\n#endif\n\nvec3 hsv2rgb(vec3 c)\n{\n    const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat shape1(vec2 p, float r)\n{\n    float k = sqrt(3.0);\n    p.x = abs(p.x);\n    p.y += 0.1;\n    if (p.x + k * p.y > 0.0) {\n        p = vec2(p.x - k * p.y, -k * p.x - p.y) / 2.0;\n    }\n    p -= vec2(clamp(p.x, -r, r), -r / k);\n    return -length(p) * sign(p.y);\n}\n\nfloat shape2(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat shape3(vec2 p, float r)\n{\n    vec2 d = abs(p) - vec2(r);\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat shape4(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x, k1.y);\n    p.x = abs(p.x);\n    p -= 2.0 * max(dot(k1, p), 0.0) * k1;\n    p -= 2.0 * max(dot(k2, p), 0.0) * k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf * vec2(-k1.y, k1.x) - vec2(0, 1);\n    float h = clamp(dot(p, ba) / dot(ba, ba), 0.0, r);\n    return length(p - ba * h) * sign(p.y * ba.x - p.x * ba.y);\n}\n\nfloat shape(vec2 p)\n{\n    vec2 p1 = p + vec2(gap, -gap);\n    vec2 p2 = p + vec2(-gap, gap);\n    vec2 p3 = p + vec2(-gap, -gap);\n    vec2 p4 = p + vec2(gap, gap);\n\n    float s1 = shape1(p1, 0.40);\n    float s2 = shape2(p2, 0.40);\n    float s3 = shape3(p3, 0.35);\n    float s4 = shape4(p4, 0.4, 0.4);\n\n    float d = 1E6;\n    d = min(d, abs(s1) - width);\n    d = min(d, abs(s2) - width);\n    d = min(d, abs(s3) - width);\n    d = min(d, abs(s4) - width);\n\n    return d;\n}\n\nfloat moveShapes(vec2 p, vec2 m, float delay)\n{\n    float a = range * sin(iTime * speed - delay);\n    p *= ROT(a);\n    p.x += sin(a);\n    //p -= m * sin(a);\n    return shape(p / size) * size;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 R = iResolution.xy;\n    vec2 q = fragCoord / R;\n    vec2 p = (2.0 * fragCoord - R) / min(R.x, R.y);\n    vec2 m = (2.0 * iMouse.xy - R) / min(R.x, R.y);\n\n    // Compute the \"gooey\" time. This will distort the distance field timewise\n    // based on the distance from the surface\n\n    float d1 = moveShapes(p, m, 0.0);\n    float d2 = moveShapes(p, m, d1 * delay);\n\n    d2 -= space * strike;\n\n    float a = 2.0 / min(R.x, R.y);\n    float d = smoothstep(-a, a, -d1);\n\n    // https://mercury.sexy/hg_sdf/\n    // float nd = mod1(d2, per);\n    float halfsize = space * 0.5;\n    float nd = floor((d2 + halfsize) / space);\n    d2 = mod(d2 + halfsize, space) - halfsize;\n\n    float h = fract(nd * space + offset);\n    float s = 0.5 * (1.0 - 0.5 * tanh(0.5 * dot(p, p)));\n    float v = 1.0 - abs(d2 / space);\n\n    vec3 col = hsv2rgb(vec3(h, s, v));\n\n    // mix orignal shape\n    col = mix(col, pow(col, vec3(0.66)), d);\n    col = clamp(col, 0.0, 1.0);\n\n    // post process\n    col = pow(col, vec3(chroma));\n    col = col * 0.6 + 0.4 * col * col * (3.0 - 2.0 * col);  // contrast\n    col = mix(col, vec3(dot(col, vec3(0.55))), -0.4);  // satuation\n\n    if (vigneting) {\n        col *= 0.5 + 0.5 * pow(19.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.7);\n    }\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}