{"ver":"0.1","info":{"id":"stX3Df","date":"1622989475","viewed":176,"name":"Orion","username":"ilyaev","description":"Orion over pyramids","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","orion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 200\n#define MAX_DIST 150.\n#define SURF_DIST .001\n#define MAT_SAND  1.\n#define MAT_PYRAMID  2.\n#define MAT_DOME  3.\n#define MAT_TOP 4.\n#define MAT_STAR 5.\n#define SINGLE_SCENE false\n#define TUNNEL_SPEED .4\n#define STAR_BLUE vec3(.2, .3, .9)\n#define STAR_ORANGE vec3(.9, .3, .1)\n\nfloat smin( float a, float b)\n{\n    float k = .4;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat n21(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nvec3 renderHollowbox(vec3 p) {\n    float d = 0.;\n    float id = 1.;\n    float mat = MAT_PYRAMID;\n    // p.y *= -1.;\n    p.xy *= Rot(abs(p.z) / 2.);\n    float box = sdBox(p, vec3(1.));\n    float ball = length(p) - 1.3;\n\n    float hollowBox = max(box, -ball);\n\n    d = hollowBox;\n\n    return vec3(d, id, mat);\n}\n\nvec3 drawStar(vec2 uv, vec2 id, vec2 pos, float size, vec3 color) {\n    vec3 col = vec3(0.);\n    if (id.x == pos.x && id.y == pos.y) {\n        // col += step(length(uv - .5) - .1, .3);\n        float d = length(uv - .5);\n        col += pow(size/d, 4.2) * color;\n    }\n    return col;\n}\n\nvec3 drawOrion(vec2 starsuv, vec2 id) {\n    vec3 col = vec3(0.);\n    vec2 pivot = vec2(22., 40.);\n    col += drawStar(starsuv, id, pivot, .09, STAR_BLUE);\n    col += drawStar(starsuv, id, pivot + vec2(1., 2.), .11, STAR_ORANGE);\n    col += drawStar(starsuv + vec2(-.2, .3), id, pivot + vec2(4., 0.), .08, STAR_BLUE);\n    col += drawStar(starsuv, id, pivot + vec2(3., -2.), .13, STAR_BLUE);\n\n    // BELT\n    float blink = iTime * 2.;\n    col += drawStar(starsuv + vec2(.25, .2), id, pivot + vec2(2., 0.), .06 + .02*sin(blink + 3.), STAR_BLUE);\n    col += drawStar(starsuv + vec2(.0, .0), id, pivot + vec2(2., 0.), .06 + .02*sin(blink + 2.), STAR_BLUE);\n    col += drawStar(starsuv + vec2(-.2, -.2), id, pivot + vec2(2., 0.), .06 + .02*sin(blink + 1.), STAR_BLUE);\n    return col;\n}\n\nvec3 starsField(vec2 uv) {\n    vec2 id = floor(uv);\n    vec2 starsuv = fract(uv);\n    vec3 col = vec3(0.);\n    float n = n21(id) - .5;\n\n    float d = length(starsuv - .5 - vec2(n, fract(n * 23423.) - .5));\n    float star = fract(n * 123.2) * .03 - .015;\n\n    if (star > 0.001) {\n        col += pow(star/d, 3.3) * vec3(5., 5., 5. + step(star, .01) * 20.);//vec3(abs(sin(id.x)), abs(cos(id.x)), abs(sin(id.x + id.y))) * 5.;\n    }\n    return col;\n}\n\nvec3 fallingStars(vec2 uv) {\n\n    // uv.yx *= Rot(iTime * .1);\n\n    vec3 col = vec3(0.);\n    vec2 id = floor(uv);\n    uv = fract(uv);\n\n    float n = n21(id - floor(iTime*10.));\n\n    float speed = iTime + (id.x + id.y)*10.*fract(n * 2342.22);\n\n    if (n < .03 && n21(vec2(floor(speed), iTime)) < .1) {\n        if (n < 0.008) {\n            uv.y *= -1.;\n        }\n        float width = .005;\n        float d = abs(abs(uv.x + uv.y) - .5);\n        float mask = smoothstep(.005, -.005, d - width );\n        col += mask * 10.;\n        col *= step(fract(speed) - .1, uv.x) - step(fract(speed)*3., uv.x);\n    }\n\n    // col += step(abs(uv.x + uv.y), .03) * 3.;\n\n    // col += n;\n\n\n    return col;\n}\n\nvec3 nebula(vec2 uv) {\n    float speed = iTime * .1;\n    for(float i = 1.0; i < 3.; i++){\n        uv.x += .8 / i * cos(i * 3.5 * uv.y + speed);\n        uv.y += 0.3 / i * cos(i * 4.5 * uv.x + speed);\n    }\n    uv.x = abs(uv.x);\n    uv.y = abs(uv.y);\n    vec3 col = 0.5 + 0.5*sin(speed*10.+uv.xyx+vec3(0,2,4));\n    return col/(2.1*abs(cos(speed-uv.y-uv.x))) * .1;\n}\n\nvec3 skyTexture(vec3 p) {\n    vec3 q1 = p;\n    p = q1;\n    vec3 col = vec3(.0);\n    float x = acos(p.y/length(p));\n    float y = atan(p.z, p.x) / 6.28;// + iTime*.1;\n    vec2 uv = vec2(x, y) + .5;\n    // uv = p.xz;\n\n    float size = 10.;\n\n    // stars\n    col += starsField(uv * vec2(size, size * 6.28)*1.5);\n    size *= 4.;\n    col += starsField(uv * vec2(size, size * 6.28)*1.5);\n    size /= 2.;\n    col += starsField(uv * vec2(size, size * 6.28)*1.5);\n\n    // orion\n    size = 10.;\n    vec2 orionuv = uv * vec2(size, size * 6.28)*1.5;\n    vec2 id = floor(orionuv);\n    orionuv = fract(orionuv);\n    col += drawOrion(orionuv, id);\n\n    //shooting stars\n    size = 3.;\n    col += fallingStars(uv * vec2(size, size * 6.28)*1.5);\n\n    //nebulas\n    col += nebula(uv + iTime*.1);\n\n    return col;\n}\n\n\nvec4 renderPyramid(vec3 p) {\n    float d = 0.;\n    float mat = MAT_PYRAMID;\n    vec3 l = vec3(1., 0., 0.);\n    float c = 1.8;\n    vec3 q = p - c * clamp(round(p/c), -l, l);\n\n\n    float id = round(p.x / c);\n\n    id += 2.;\n\n    if (id == 3.) {\n        q.y += .4;\n        q.z += c * 2.2;\n    }\n\n    if (id == 2.) {\n        // q.y += .1;\n        q.z += c;\n    }\n\n    if (id == 1.) {\n        q.y += .4;\n    }\n\n    q.y *= -1.;\n    float beacon = length(q + vec3(.0, 0.1, 0.)) - .3;\n    // q.y = abs(q.y);\n    q.y /= 1.6;\n    float pyramid = sdBox(q, clamp(vec3(q.y), vec3(0.001), vec3(.7)) + .01);\n    float top = sdBox(q, clamp(vec3(q.y*1.04), vec3(0.001), vec3(.15)) + .01);\n\n\n    float sand = p.y + 1.1 + sin(p.x/3. + cos(p.z) + 1.2 + iTime) * (.2 * min(1., max(0., abs(p.y*p.y)-.9)));\n\n    float dome = length(p) - 100.;\n\n    float ra = 0.;\n\n    d = min(pyramid, sand);\n    d = min(d, -dome);\n    d = min(d, top);\n\n\n    // d = min(d, beacon);\n\n    if (d == sand) {\n        mat = MAT_SAND;\n    }\n\n    if (d == -dome) {\n        mat = MAT_DOME;\n    }\n\n    if (d == top) {\n        mat = MAT_TOP;\n    }\n\n\n    if (min(d, beacon) == beacon) {\n        // d = beacon;\n        // mat = MAT_STAR;\n        ra = length(q);// - vec3(.0, 0.05, 0.));\n    }\n\n    if (abs(sand - pyramid) < .01) {\n        mat = MAT_SAND;\n    }\n\n\n    return vec4(d, id, mat, ra);\n}\n\n\n\nvec4 GetDist(vec3 p) {\n    // return renderHollowbox(p);\n    return renderPyramid(p);\n}\n\nmat4 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    vec4 res = vec4(0.);\n    float k = 0.;\n\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        res = GetDist(p);\n        float dS = res.x;\n        dO += dS*.7;\n        k += 1.;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n\n    return mat4(vec4(dO, res.y, res.z, k), vec4(res.a), vec4(0.), vec4(0.));\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n\n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Transform(vec3 p) {\n    return p - vec3(1.2, -.1, .5);\n    if (SINGLE_SCENE == true) {\n        return p;\n    }\n     return p + vec3(0. + cos(iTime)*.2,0. + sin(iTime)*.3,-iTime*2.);\n}\n\n\n\nvec3 getBackground(vec2 uv) {\n    return vec3(1.);\n}\n\nvec3 triPlanar(vec3 p, vec3 n) {\n    vec3 colXZ = texture(iChannel0, p.xz*3. * .5 + .5).xyz;\n    vec3 colYZ = texture(iChannel0, p.yz*3. * .5 + .5).xyz;\n    vec3 colXY = texture(iChannel0, p.xy*3. * .5 + .5).xyz;\n\n    n = abs(n);\n\n    n *= pow(n, vec3(20.));\n    n /= n.x + n.y + n.z;\n\n    vec3 col = n.z * colXY + colXZ * n.y + colYZ * n.x;\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n\n    // ro.yz *= Rot(-m.y*3.14+1.);\n    // ro.xz *= Rot(-m.x*6.2831);\n\n\n    ro.yz *= Rot(-.63*3.14+1.);\n    ro.xz *= Rot(-.305*6.2831);\n\n    ro.xy *= Rot(clamp(sin(iTime/3.), -1., 1.)*.05);\n    ro.xz *= Rot(clamp(cos(iTime / 2.), -1., 1.)*.1);\n\n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n\n    mat4 rmAll = RayMarch(Transform(ro), rd);\n    vec4 rm = rmAll[0];\n    float d = rm.x;\n    float k = rm.a;\n    float mat = rm.z;\n    float id = rm.y;\n\n    float ra = rmAll[1].x;\n\n    if(d<MAX_DIST) {\n        vec3 p = Transform(ro) + rd * d;\n        vec3 n = GetNormal(p);\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n\n        vec3 sc = vec3(0.9, 0.5 ,0.1);\n        if (mat == MAT_PYRAMID) {\n            col = vec3(dif) * k/40.;\n            col *= sc;\n            col *= triPlanar(p + id, n);\n\n            if (n21(vec2(floor(iTime), id)) < .07) {\n                vec3 r = reflect(rd, n);\n                vec3 refSky = skyTexture(Transform(r));\n                vec3 icol = col * refSky * 5.;\n                col = mix(col, icol, abs(sin(iTime*2. + id)));\n            }\n\n        }\n        else if (mat == MAT_TOP) {\n            col = vec3(dif) * k/40.;\n            col *= vec3(1.);\n            vec3 r = reflect(rd, n);\n            vec3 refSky = skyTexture(Transform(r));\n            col += refSky * 5.;\n            col *= triPlanar(p, n);\n        }\n        else if (mat == MAT_DOME) {\n            col = vec3(dif) * k/160.;\n            col *= skyTexture(p) + vec3(0.,0.,.1 * sin(iTime/4.));// + vec3(.9, .3,.5 * cos(iTime/4.)) * .2;\n            // col *= vec3(.2, .1, .1);\n        }\n         else {\n\n            col = vec3(dif) * k/160.;\n            col *= vec3(.7, .3, .1);\n\n            // vec3 r = reflect(rd, n);\n            // vec3 refSky = skyTexture(Transform(r));\n            // col += refSky;\n\n            // col\n        }\n        col = pow(col, vec3(.4545));\t// gamma correction\n    }\n\n    if (ra > 0.) {\n        col += vec3(pow((.05 + .02*sin(iTime*2. + id))/ra, 3.2)) * STAR_BLUE;\n    }\n\n\n    // col *= p;\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}