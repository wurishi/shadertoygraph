{"ver":"0.1","info":{"id":"wdKGWm","date":"1643161075","viewed":70,"name":"Window Wiper","username":"greyDogFish","description":"rect study_window_wiper","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["windowwiper"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI 3.14159265359\n\nfloat Wiper(vec2 uv){\n\n    //x&y have opposite cycles \n   uv.x += (sin(iTime*.5));\n    uv.y += (cos(iTime*.5));\n    \n    float right,left,top,bottom;\n    //x\n       \n       left = step(0.1,(1.-uv.x*2.+.0));     \n       right = step(0.1,(uv.x*2.-1.0)); \n      \n    //y\n     top = smoothstep(0.05,.15,(uv.y*2.-1.0));\n     bottom = step(0.1,(1.-uv.y*2.+.0));\n      \n    return (right+left)*(top+bottom);\n    //return  (right+left);\n}\n\nfloat RectFrame(vec2 uv, float xlength, float ylength, vec2 position){\n\n//adjust center of rect    \n    uv -= position;\n    \n    //border width\n    float bwidth = 0.1;    \n    \n    //4 corners\n      float left = step(bwidth,uv.x-xlength);  \n       float bottom = step(bwidth,uv.y-ylength);      \n       float right = step(bwidth,1.0-uv.x-xlength);\n       float top = step(bwidth, 1.0-uv.y-ylength);     \n        \n    return left*bottom*right*top;\n    //note!-overlapping windows will blow out colors\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    vec2 st = fragCoord.xy/iResolution.xy;\n    \n    //change only the blue channel here\n    float b = cos(iTime);    \n    vec3 color = vec3(st.xy,b);\n              \n    float wipe = Wiper(st);\n    //color = vec3(st,0);\n            \n  // float frame = (WindowFrame(st, 0.1));\n   \n   //make 2 rects based on centerpositions\n   vec2 centerPos1 = vec2(.2,.1);   \n   float rFrame1 = RectFrame(st,.2,.2,centerPos1);  \n   vec2 centerPos2 = vec2(-.3,-.2);   \n   float rFrame2 = RectFrame(st,.3,.15,centerPos2);\n   \n   //need to add these together first, before multiply into color, \n   //otherwise frames cancel each other out.\n   float bothFrames = rFrame1 + rFrame2;\n\n   fragColor = vec4(color*wipe*bothFrames,1.0);\n}\n\n\n//frames window of uv (evolved into RectFrame)\nfloat WindowFrame(vec2 uv, float bwidth){\n\n// Each result will return 1.0 (white) or 0.0 (black).\n   // float left = step(0.1,st.x);   // Similar to ( X greater than 0.1 )\n   // float bottom = step(0.1,st.y); // Similar to ( Y greater than 0.1 )  \n     // The multiplication of left*bottom will be similar to the logical AND.\n    //color = vec3( left * bottom );\n\n    //bwidth+=cos(iTime)*0.1;//contracting frame\n // bottom-left\n   // vec2 bl = step(vec2(0.1),uv);\n    //vec2 bl = smoothstep(0.05,.1,uv);\n    vec2 bl = floor(bwidth-uv);\n    float pct = bl.x * bl.y;\n    \n     // top-right\n    //vec2 tr = step(vec2(0.1),1.0-uv);\n    //vec2 tr = smoothstep(0.09,0.1,1.-uv);\n    vec2 tr = ceil((1.-bwidth)-uv);\n   \n     pct *= tr.x * tr.y;\n     \nreturn pct;\n\n}\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}