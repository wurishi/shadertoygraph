{"ver":"0.1","info":{"id":"cssXDs","date":"1669744125","viewed":144,"name":"Fork Juliation Morphing","username":"PhDFractal","description":"Folding a Circle into a Julia Set. Repeated Juliation will yield Juliation morphing. Hover mouse up ↑ for 3rd power and down ↓ for 2nd power. Use large shifts for large iterations. See Karl Sims' video: youtube.com/watch?v=R1gpm7WsNhg (@ksims42). ⚪","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["julia","mandelbrot","morph","toy"],"hasliked":0,"parentid":"DslXDX","parentname":"Juliation Morphing"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////////\n//\n// Juliation Morphing – Folding a Circle Fork\n//\n// See Decorated Mandelbrot Set: https://www.shadertoy.com/view/slyBzV\n//\n// And 6th Minibrot using Decorations: https://www.youtube.com/watch?v=Iozyi1mAjXg\n//\n// Forked from Juliation morphing. Powers 2 and 3 for Folding a Circle. See\n// Karl Sims' video in early 2013 @ksims42: youtube.com/watch?v=R1gpm7WsNhg\n// \n////////////////////////////////////////////////////////////////////////////////\n// Created by Fractal MathPro: https://www.youtube.com/channel/UCY-W4FvxaNRoZ8N5b-KzSZg\n// MathFractal: https://math.stackexchange.com/users/1013522/mathfractal\n// I share this piece (art and code) here in Shadertoy and through its Public API,\n// only for educational purposes. You cannot use, sell, share or host this piece\n// or modifications of it as part of your own commercial or non-commercial product\n// website or project. You cannot use, sell, share or host this piece or modifications\n// of it as part of your own commercial or non-commercial product, website or project.\n// You can share a link to it or an unmodified screenshot of it provided you attribute\n// \"by PhdFractal\".\nfloat pi=3.141592653589793;\nvec2 powers(vec2 z,float power){                                                     //float power\n    float magn=sqrt(z.x*z.x+z.y*z.y);\n    if(magn==0.) { return vec2(0.,0.); }\n    float arg=acos(z.x/magn);\n    if(z.y>=0.){ return pow(magn,power)*vec2(cos(power*arg),sin(power*arg)); }\n    else{ return pow(magn,power)*vec2(cos(power*arg),-sin(power*arg)); }\n}\nfloat mag(vec2 z){ return sqrt(z.x*z.x+z.y*z.y); }                                   //complex abs\nfloat arg(vec2 z){\n    if(mag(z)==0.){ return 0.; }\n    if(z.y>=0.){ return acos(z.x/mag(z)); }\n    else{ return -acos(z.x/mag(z)); }\n}                                                                                    //complex arg\nvec2 sqr(vec2 z){ return vec2(z.x*z.x-z.y*z.y,2.*z.x*z.y); }                         //squaring\nvec2 cub(vec2 z){ return vec2(z.x*z.x*z.x-3.*z.x*z.y*z.y,3.*z.x*z.x*z.y-z.y*z.y*z.y); }//cubing\nvec2 seed=vec2(0);\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{   int shift=0;\n    float time=float(shift)+.5*iTime-11.*floor(iTime/22.); float morph=floor(time); float rem=time-morph;\n    float inter=(1.-cos(pi*rem))/2.; float collapse=float(shift)+5.*(1.+cos(pi*rem));\n    float col=floor(collapse); float intcol=collapse-col; vec4 color=vec4(0.,0.,0.,1.);\n    if((iMouse.x==0.)&&(iMouse.y==0.)){ seed=vec2(-0.3905408702184,0.5867879073469687); }//Siegel Disk\n    else{ seed=4.*vec2(iMouse.x-.5*iResolution.x,iMouse.y-.5*iResolution.y)/iResolution.x; }\n    vec2 pix=4.*(fragCoord/iResolution.x-.5*vec2(1,iResolution.y/iResolution.x)); pix=pix-seed;\n    if(iMouse.y<.5*iResolution.y){\n    if(time<float(shift)+10.){ if(dot(pix,pix)<=16.) { pix=powers(pix+inter*seed,1.+inter)+seed; }\n    for(int i=0; i<int(morph); i++){ if(dot(pix,pix)<=16.){ pix=sqr(pix)+seed; } } }\n    else{ if(dot(pix,pix)<=16.) { pix=powers(pix+intcol*seed,1.+intcol)+seed; }\n    for(int i=0; i<int(col); i++){ if(dot(pix,pix)<=16.){ pix=sqr(pix)+seed; } } }\n    } //Only four changes: two \"sqr\" to \"cub\" formulas and two \"1.+inter\" to \"1+2.*inter\" in powers.\n    else{\n    if(time<float(shift)+10.){ if(dot(pix,pix)<=16.) { pix=powers(pix+inter*seed,1.+2.*inter)+seed; }\n    for(int i=0; i<int(morph); i++){ if(dot(pix,pix)<=16.){ pix=cub(pix)+seed; } } }\n    else{ if(dot(pix,pix)<=16.) { pix=powers(pix+intcol*seed,1.+2.*intcol)+seed; }\n    for(int i=0; i<int(col); i++){ if(dot(pix,pix)<=16.){ pix=cub(pix)+seed; } } } }\n    float r=mag(pix); float t=arg(pix);\n    if(r<2.){\n        if(r-.5*floor(2.*r)<0.07){ color=vec4(0.082,0.322,0.365,1.); }\n        else if(abs(t-pi/4.*round(t*4./pi))<.05){ color=vec4(0.067,0.220,0.451,1.); }\n        else{ color=vec4(0.,0.,0.,1.); } }\n    else{ color=vec4(1.,1.,1.,1.); }\n    fragColor=color;\n}","name":"Image","description":"","type":"image"}]}