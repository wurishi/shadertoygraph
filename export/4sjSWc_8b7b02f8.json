{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"\n// Intersection resul.\n// last component of pos is the distance of the intersection\n// last component of norm is the number of the sphere\nstruct Inter\n{\n    vec4 pos;\n    vec4 norm;\n};\n    \n#define radius 0.5\n#define inf 10000.0\n#define sphere1 0.0\n#define sphere2 1.0\n#define eta 0.6\n\nvec3 uvToRay(vec2 fragCoord)\n{\n    vec2 uv =  fragCoord.xy / iResolution.xy;\n    vec3 ray = vec3(uv*2.0-vec2(1.0), -1.73);\n    ray.y *= iResolution.y/iResolution.x;\n    return normalize(ray);\n}\n\n// itersect the ray (rpos, rdir) with the sphere at pos spos and radius sr\nInter sphereInter(vec3 rpos, vec3 rdir, vec3 spos, float sr)\n{    \n    vec3 oDiff = rpos-spos;\n    float t = dot(rdir, oDiff);\n    float D = t*t - dot(oDiff, oDiff) + sr*sr;\n    \n    Inter result;\n    result.norm;\n    result.pos.w = inf;\n    if(D>=0.0)\n    {\n        float sd = sqrt(D);\n        float r0 = -t+sd;\n        float r1 = -t-sd;\n        r0 = (r0 < 0.001)? inf : r0;\n        r1 = (r1 < 0.001)? inf : r1;\n        float mn = min(r0, r1);\n        \n        if (mn != inf)\n        {\n        \tresult.pos = vec4(rpos + rdir*mn, mn);\n        \tresult.norm = vec4((result.pos.xyz-spos) / sr, 0.0);\n            if(max(r0, r1) == inf)\n                result.norm = -result.norm;\n        }\n    }\n    return result;\n}\n\n// intersect both spheres with the ray\nInter sphereInter2(vec3 rpos, vec3 rdir, vec3 s1pos, vec3 s2pos)\n{\n    Inter i1 = sphereInter(rpos, rdir, s1pos, radius);\n    Inter i2 = sphereInter(rpos, rdir, s2pos, radius);\n   \ti1.norm.w = sphere1;\n    i2.norm.w = sphere2;\n    \n    \n    float first1 = step(i1.pos.w, i2.pos.w);\n    float first2 = 1.0-first1;\n     \n    Inter result;\n    result.pos = i1.pos*first1 + i2.pos*first2;\n    result.norm = i1.norm*first1 + i2.norm*first2;\n    \n    return result;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // first ray\n    vec3 ray = uvToRay(fragCoord);\n    \n    // define the spheres\n    vec3 spere1Pos = vec3(sin(iTime), cos(iTime*0.5), -4.0 + 0.4*sin(iTime*0.2));    \n    vec3 spere2Pos = vec3(cos(iTime*0.5), sin(iTime), -6.0 - 0.4*sin(iTime*0.2));\n    \n    vec3 result = vec3(0.0);\n    vec3 pos = vec3(0.0);\n    float coef = 1.0;\n    float eta2 = eta;\n    \n    // 5 successive rays are enough\n    for(int i = 0; i<5; i++)\n    {\n        Inter inter = sphereInter2(pos, ray, spere1Pos, spere2Pos);\n        if(inter.pos.w != inf)\n        {\n            vec3 refl = reflect(ray, inter.norm.xyz);\n            pos = inter.pos.xyz;\n            \n            // sphere 1 is refractive\n            if(inter.norm.w == sphere1)\n            {\n            \tvec3 refr = refract(ray, inter.norm.xyz, eta2);\n                \n                // fresnel (F(eta) = F(1/eta))\n                float F0 = (1.0-eta)/(1.0+eta); F0 *= F0;\n                float t = 1.0 + dot(inter.norm.xyz, ray);\n                float t2 = t*t;\n                float F = F0 + (1.0-F0)*t2*t2*t;\n                if(refr == vec3(0.0))\n                    ray = refl;\n                else\n                {\n                    result += coef*F*texture(iChannel0, refl).xyz;\n                    ray = refr;\n                    eta2 = 1.0 / eta2;\n                    coef *= (1.0-F);\n                }\n                \n            }\n            // sphere 2 is reflective\n            else\n                ray = refl;\n        }\n    }\n    result += coef * texture(iChannel0, ray).xyz;\n            \n    fragColor = vec4(result,1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sjSWc","date":"1417211312","viewed":313,"name":"Spheres Optics","username":"gcordonnier","description":"My first shader here: basic optics for 2 animated spheres","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","reflection","refraction","sphere","fresnel"],"hasliked":0,"parentid":"","parentname":""}}