{"ver":"0.1","info":{"id":"WsXfW2","date":"1589048676","viewed":94,"name":"base utils","username":"Variadicism","description":"This shader is just a collection of base utility functions, structs, and other useful things that can be used in a variety of shaders.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["base","utils","util","starter","utilities"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////////// SETTINGS //////////////////////////////////////\nconst vec3 BACKGROUND_COLOR = vec3(0.0);\n\n/////////////////////////// BASE UTILITIES ////////////////////////////////\n// TYPES:\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Surface {\n\tvec3 color;\n};\n\nstruct RayCollision {\n\tint index;\n\tfloat distance;\n};\n\n// CONSTANTS:\nconst float PI = 3.1415926535897932384626433832795;\nconst float INFINITY = 1e9;\nconst float sqrt2 = 1.41421356237;\n\nconst int NO_OBJECT_INDEX = -1;\nconst RayCollision NO_HIT = RayCollision(NO_OBJECT_INDEX, INFINITY);\nconst Surface BACKGROUND_SURFACE = Surface(BACKGROUND_COLOR);\n\n// MATH:\nfloat root(float value, float root) {\n\treturn exp(log(value) / root);\n}\n\n// TRANSFORMATIONS:\nvec3 apply(vec3 vector, mat4 transformation) {\n\tvec4 vector4d = vec4(vector, 1.0);\n    vec4 transformedVector4d = vector4d * inverse(transformation);\n    return transformedVector4d.xyz;\n}\n\nmat4 translate(vec3 translation) {\n    mat4 result = mat4(1.0);\n    result[3].xyz = translation;\n    return result;\n}\n\nmat4 scale(vec3 scale) {\n    mat4 result = mat4(1.0);\n    result[0][0] = scale.x;\n    result[1][1] = scale.y;\n    result[2][2] = scale.z;\n    return result;\n}\n\nmat4 rotate(vec3 axis, float angle) {\n    float cosA = cos(angle);\n    float sinA = sin(angle);\n    return mat4(mat3(\n        cosA + axis.x*axis.x*(1.0-cosA), axis.x*axis.y*(1.0-cosA) - axis.z*sinA, axis.x*axis.z*(1.0-cosA) + axis.y*sinA,\n        axis.x*axis.y*(1.0-cosA) + axis.z*sinA, cosA + axis.y*axis.y*(1.0-cosA), axis.y*axis.z*(1.0-cosA) - axis.x*sinA,\n        axis.x*axis.z*(1.0-cosA) - axis.y*sinA, axis.y*axis.z*(1.0-cosA) + axis.x*sinA, cosA + axis.z*axis.z*(1.0-cosA)));\n}\n\n// QUADRATICS:\nstruct QuadraticResult {\n    int results;\n    float largerResult;\n    float smallerResult;\n};\nconst QuadraticResult NO_SOLUTION = QuadraticResult(0, 0.0, 0.0);\n\nQuadraticResult solveQuadratic(float a, float b, float c) {\n    if (a == 0.0) {\n        return NO_SOLUTION;\n    }\n\n    float ac4 = 4.0*a*c;\n    float b2 = b*b;\n    if (ac4 > b2) {\n        return NO_SOLUTION;\n    }\n\n    float squareRoot = sqrt(b2 - ac4);\n    if (squareRoot == 0.0) {\n        return QuadraticResult(1, -b/(2.0*a), 0.0);\n    } else {\n        return QuadraticResult(2, (-b + squareRoot)/(2.0*a), (-b - squareRoot)/(2.0*a));\n    }\n}\n\n// RAY FUNCTIONS:\n\nvec3 rayAt(Ray ray, float distance) {\n\treturn ray.origin + ray.direction * distance;\n}\n\nRayCollision closer(RayCollision collision1, RayCollision collision2) {\n\tif (collision2.distance < 0.0 || collision1.distance <= collision2.distance)\n\t\treturn collision1;\n\telse\n\t\treturn collision2;\n}\n\n/////////////////////////// IMPLEMENTATION ////////////////////////////////\n// vec2 position (in pixels)\n// vec4 color (0 <= rgba <= 1)\nvoid mainImage(out vec4 color, in vec2 position) {\n    // TODO\n    color = vec4(position/iResolution.xy, 0.5, 1.0);\n}","name":"Image","description":"","type":"image"}]}