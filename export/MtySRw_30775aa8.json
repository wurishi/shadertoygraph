{"ver":"0.1","info":{"id":"MtySRw","date":"1483510359","viewed":3950,"name":"Viz of 4 disc/square maps","username":"MBR","description":"Viz of distortion of 4 disc->square->disc mappings","likes":14,"published":1,"flags":48,"usePreview":0,"tags":["map","square","disc"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// LICENSE: http://unlicense.org/\n\n// Viz of area distortions for 4 disc to square maps for both directions\n// 1) stretch    - simply rescale \n// 2) concentric - as per Shirley\n// 3) squircle   - as per Fong\n// 4) elliptical - as per Nowell\n\n// SPACE toggle animation vs. manual control\n\n// 1     toggle disc->square / square->disc\n// 2     toggle checkerboard / radial reference image\n// R/L   cheesy blend from orig to target space\n// U/D   forward/back through methods\n\n\n#define PI (52707180.0/16777216.0)\n\n\n// coloring tweekable constants\n\n// checkerboard viz\n#define R_GRID 10.0         // # squares on [0,1] (so twice/dim for square)\n\n// radial viz\n#define GRID_K  0.05\n#define GROW_K  0.5        // growth indication (smaller = more pronounced)\n#define RADIAL_LINES 12.0  // # radial rays\n\n// derived constants\n#define GROW_M  (1.0/(GROW_K+1.0))\n#define GRID_IK (1.0/GRID_K)\n#define RL (RADIAL_LINES/(2.0*PI))\n\nbool  vizSquare = false;   // direction of mapping\nfloat animPos   = 0.;      // lerp position\nbool  refGrid   = false;   // checkerboard or radial\n\n// binary32 ulp(1)\nconst float epsilon = exp2(-24.0);\n\nfloat sgn(float x) { return x>=0.0 ? 1.0 : -1.0; }\nvec2  sgn(vec2  x) { return vec2(sgn(x.x), sgn(x.y)); }\n\n\n// stretch: disc->square\nvec2 map0ds(vec2 z)\n{\n\n  float s = length(z);\n  float m = s/(max(abs(z.x),abs(z.y))+epsilon);\n  return m*z;\n}\n\n// stretch: square->disc\nvec2 map0sd(vec2 z)\n{\n\n  float s = inversesqrt(dot(z,z)+epsilon);\n  float m = s*max(abs(z.x),abs(z.y));\n \n  return m*z;\n}\n\n// concentric: square->disc\nvec2 map1sd(vec2 z)\n{\n#if 1\n  float phi,r;\n  float a = z.x;\n  float b = z.y;\n  \n  if (a*a > b*b) {\n    r = a;\n    phi = (PI/4.)*(b/a);\n  } else {\n    r = b;\n    phi = (PI/2.0) - (PI/4.0)*(a/(b+epsilon));\n  }\n  return vec2( r*cos(phi), r*sin(phi) );\n#else\n  float u,v,m,t;\n    \n  if (abs(z.x) > abs(z.y)) {\n    m = z.x;\n\tt = (PI/4.0)*z.y/z.x;\n    v = sin(t);\n    u = sqrt(1.0-v*v);     // or cos(t)\n  }\n  else {\n    m = z.y;\n    t = (PI/4.0)*z.y*z.x/(z.x*z.x+epsilon);\n\t//t = (PI/4.0)*z.x/z.y;\n    //t = z.y != 0.0 ? t : 0.0;\n    u = sin(t);\n    v = sqrt(1.0-u*u);    // or cos(t)\n  }\n    \n  return vec2(m*u, m*v);\n\n#endif\n}\n\n#define IPI (1.0/PI)\n\n\n// concentric: disc->square\nvec2 map1ds(vec2 z)\n{\n  float r = length(z);\n  float t = atan(z.y,z.x);\n   if (t < -.25*PI) t += 2.0*PI;\n    \n   if (t < .25*PI) {\n      return vec2(r,(4.0/PI)*r*t );\n    } \n    else if (t < .75*PI) {\n      return vec2(-(4.0/PI)*r*(t-.5*PI), r);\n    } \n    else if (t < 1.25*PI) {\n      return vec2(-r, -(4.0/PI)*r*(t-PI));\n    } \n    else {\n      return vec2((4.0/PI)*r*(t-1.5*PI), -r);\n    }\n}\n\n\n\n\n// squircular: disc->square\nvec2 map2ds(vec2 z)\n{\n  // animation specific hacks\n  if (min(abs(z.x),abs(z.y)) < epsilon) return z;  \n  \n  vec2  z2  = z*z;\n  float d   = z2.x+z2.y;\n  float uv  = z.x*z.y;\n  float suv = sgn(uv)*(1.0/sqrt(2.0));\n  float b   = d-4.*uv*uv;\n  float s   = suv*sqrt(d-sgn(b)*sqrt(d*abs(b)));\n    \n  z += epsilon;\n  \n  return vec2(s/z.y, s/z.x);\n}\n\n// squircular: square->disc\nvec2 map2sd(vec2 z)\n{\n\n  vec2  z2 = z*z;\n  float s  = sqrt(1. - (z2.x * z2.y)/(z2.x+z2.y+epsilon));\n  return z*s;  \n}\n\n\n// elliptical: square->disc\nvec2 map3sd(vec2 z)\n{\n  vec2 z2 = 0.5*z*z;\n  return vec2(sqrt(1.0-z2.y)*z.x, sqrt(1.0-z2.x)*z.y);\n}\n\nconst float twosqrt2 = 2.8284270763397216796875;//2.0*sqrt(2.0);\n\n\n// elliptical: disc->square\nvec2 map3ds(vec2 z)\n{\n // animation specific hacks\n vec2 z2 = z*z;\n vec2 a  = 2.+vec2(z2.x-z2.y, -z2.x+z2.y);\n vec2 b  = twosqrt2*z;\n vec2 p  = a+b;\n vec2 m  = a-b;\n vec2 r  = sgn(p)*sqrt(abs(p))-sgn(m)*sqrt(abs(m));\n return 0.5*r;\n}\n\n\n//----------------------\n\n\n\nvec3 hsv2rgb(vec3 c)\n{\n  const vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nfloat grid_step(float t)\n{\n  t = min(t, 1.0-t);\n  return smoothstep(0.0, GRID_K, t);\n}\n\n\nvec3 domainPlot(vec2 o, vec2 m)\n{\n  // fake animation: just lerping between map coordinate\n  vec2 c = mix(o,m,animPos);\n\n  // black if outside the domain\n  if (!vizSquare) {\n    if (dot(c,c) >= 1.0)  return vec3(0.);\n  }\n  else {  \n    if (max(abs(c.x),abs(c.y)) >= 1.0) return vec3(0.);\n  }\n\n  float d     = dot(c,c);\n  float theta = atan(c.y,c.x);\n  float sat   = 1.0;\n  float val   = 1.0;\n  float b     = 1.0;\n\n  if (refGrid) {\n    // grid reference image\n    float f = 0.75;\n    float x = floor(R_GRID*c.x);\n    float y = floor(R_GRID*c.y);\n    float t = mod(x+y,2.0);\n\n    if (mod(x+y,2.0)==1.0)  \n      sat*= sin(f);\n      else val *= sin(f);\n  }\n  else {\n    // domain plot reference image\n    float b1 = fract(0.5*log2(d));\n    float b0 = b1+b1;\n    if (b0 >= 1.0) b0 -= 1.0;\n    b = GROW_M*(b0+GROW_K);\n    if (b1 < 0.5) b = 1.0;    \n    sat = mix(0.0, sat, grid_step(fract(theta*RL)));\n    b   = mix(0.0, b,   grid_step(b0));\n  }\n    \n  // convert to RGB\n  float hue = theta*(1.0/(2.0*PI));\n  vec3  v   = hsv2rgb(vec3(hue,sat,val))*b;\n    \n  return v;\n}\n\n\n\n\n// This is from here: www.shadertoy.com/view/ltcXzs\nvec4 char(vec2 pos, float c)\n{\n  pos = clamp(pos,0.,1.);  // would be more efficient to exit if out.\n  return texture(iChannel0, pos/16. + fract( floor(vec2(c, 15.999-c/16.))/16.));\n}\n\n//const float _a = .97;\n#define _CAP -32.\n#define _a + 97.\n#define _b + 98.\n#define _c + 99.\n#define _d +100.\n#define _e +101.\n#define _f +102.\n#define _g +103.\n#define _h +104.\n#define _i +105.\n#define _j +106.\n#define _k +107.\n#define _l +108.\n#define _m +109.\n#define _n +110.\n#define _o +111.\n#define _p +112.\n#define _q +113.\n#define _r +114.\n#define _s +115.\n#define _t +116.\n#define _u +117.\n#define _v +118.\n#define _w +119.\n#define _x +120.\n#define _y +121.\n#define _z +122.\n\n\nfloat prints(inout vec2 o)\n{\n  float r = 0.0;\n  r += char(o, _s _CAP).x; o.x-=.5;\n  r += char(o, _q).x; o.x-=.5;\n  r += char(o, _u).x; o.x-=.5;\n  r += char(o, _a).x; o.x-=.5;\n  r += char(o, _r).x; o.x-=.5;\n  r += char(o, _e).x; o.x-=.5;\n  return r;\n}\n\nfloat printd(inout vec2 o)\n{\n  float r = 0.0;\n  r += char(o, _d _CAP).x; o.x-=.5;\n  r += char(o, _i).x; o.x-=.5;\n  r += char(o, _s).x; o.x-=.5;\n  r += char(o, _c).x; o.x-=.5;\n  return r;\n}\n\n\nfloat printsd(inout vec2 o)\n{\n  float r = 0.0;\n  if (vizSquare) {\n    r += prints(o);  o.x -= .3;\n    r += char(o, 18.).x; o.x -= .8;\n    r += printd(o);\n   } else {\n    r += printd(o);  o.x -= .3;\n    r += char(o, 18.).x; o.x -= .8;\n    r += prints(o);\n   }\n  return r;\n}\n\nfloat print0(inout vec2 o)\n{\n  float r = 0.0;\n  r += char(o, _s _CAP).x; o.x-=.5;\n  r += char(o, _t).x; o.x-=.5;\n  r += char(o, _r).x; o.x-=.5;\n  r += char(o, _e).x; o.x-=.5;\n  r += char(o, _t).x; o.x-=.5;\n  r += char(o, _c).x; o.x-=.5;\n  r += char(o, _h).x; o.x-=.5;\n  return r;\n}\n\nfloat print1(inout vec2 o)\n{\n  float r = 0.0;\n  r += char(o, _c _CAP).x; o.x-=.5;\n  r += char(o, _o).x; o.x-=.5;\n  r += char(o, _n).x; o.x-=.5;\n  r += char(o, _c).x; o.x-=.5;\n  r += char(o, _e).x; o.x-=.5;\n  r += char(o, _n).x; o.x-=.5;\n  r += char(o, _t).x; o.x-=.5;\n  r += char(o, _r).x; o.x-=.5;\n  r += char(o, _i).x; o.x-=.5;\n  r += char(o, _c).x; o.x-=.5; \n  return r;\n}\n\nfloat print2(inout vec2 o)\n{\n  float r = 0.0;\n  r += char(o, _s _CAP).x; o.x-=.5;\n  r += char(o, _q).x; o.x-=.5;\n  r += char(o, _u).x; o.x-=.5;\n  r += char(o, _i).x; o.x-=.5;\n  r += char(o, _r).x; o.x-=.5;\n  r += char(o, _c).x; o.x-=.5;\n  r += char(o, _l).x; o.x-=.5;\n  r += char(o, _e).x; o.x-=.5;\n  return r;\n}\n\n// Elliptical \nfloat print3(inout vec2 o)\n{\n  float r = 0.0;\n  r += char(o, _e _CAP).x; o.x-=.5;\n  r += char(o, _l).x; o.x-=.5;\n  r += char(o, _l).x; o.x-=.5;\n  r += char(o, _i).x; o.x-=.5;\n  r += char(o, _p).x; o.x-=.5;\n  r += char(o, _t).x; o.x-=.5;\n  r += char(o, _i).x; o.x-=.5;\n  r += char(o, _c).x; o.x-=.5;\n  r += char(o, _a).x; o.x-=.5;\n  r += char(o, _l).x; o.x-=.5;\n  return r;\n}\n\nint methodId = 0;\n\nvec2 map(vec2 z)\n{\n  vec2 m; \n  int  i = methodId;\n    \n  if (!vizSquare) {  \n    if     (i == 0) { m = map0sd(z); }\n    else if(i == 1) { m = map1sd(z); }\n    else if(i == 2) { m = map2sd(z); }\n    else if(i == 3) { m = map3sd(z); }\n  } else {\n    if     (i == 0) { m = map0ds(z); }\n    else if(i == 1) { m = map1ds(z); }\n    else if(i == 2) { m = map2ds(z); }\n    else if(i == 3) { m = map3ds(z); }\n  }\n  return m;\n}\n\n\nbool isBitSet(float a, int b)\n{\n  float t = exp2(-float(b+1));\n  float s = fract(a*t);\n  return s >= .5;  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float s  = 0.5*min(iResolution.x,iResolution.y)*.90;\n  vec2  uv = (fragCoord.xy - 0.5*iResolution.xy)/s;\n  vec3  c  = vec3(0.);\n  vec2  p  = fragCoord/iResolution.y;\n  vec4  d  = texture(iChannel1, (vec2(0.)+0.5)/iChannelResolution[1].xy);\n  \n  methodId  = int(d.x);\n  vizSquare = isBitSet(d.y, 1);\n  refGrid   = !isBitSet(d.y, 2);\n  animPos   = d.z;\n    \n  //if (vizSquare) { animPos = 1.-animPos; }\n    \n if (max(abs(uv.x),abs(uv.y)) <= 1.0) {\n    vec2  m = map(uv);\n    c = domainPlot(uv,m);\n  }\n      \n  p *= 13.; p.y -= .8;\n  \n  float t;\n  int  i = methodId;\n  if     (i == 0) { t = print0(p); }\n  else if(i == 1) { t = print1(p); }\n  else if(i == 2) { t = print2(p); }\n  else if(i == 3) { t = print3(p); }\n  \n  p  = 13.*fragCoord/iResolution.y;\n  t += printsd(p);\n    \n  c+=  t;\n    \n  fragColor = vec4(c,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define KEY_NUM(X) ((48.5+float(X))/256.)\n\nconst float KEY_SPACE = 32.5/256.;\nconst float KEY_LEFT  = 37.5/256.;\nconst float KEY_UP    = 38.5/256.;\nconst float KEY_RIGHT = 39.5/256.;\nconst float KEY_DOWN  = 40.5/256.;\n\nbool isKeyDown(float key) \n{\n  return texture(iChannel1, vec2(key, 0.5)).x > 0.5;\n}\n\n\nbool isBitSet(float a, int b)\n{\n  float t = exp2(-float(b+1));\n  float s = fract(a*t);\n  return s >= .5;  \n}\n\nfloat toggleBit(float a, float b)\n{\n  float t = exp2(-(b+1.));\n  float s = fract(a*t);\n  float o = exp2(b);\n    \n  o = (s>=.5) ? -o : o;\n\n  return a+o;  \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  // skip processing outside of state data\n  if (fragCoord.x > 1. || fragCoord.y > 1.) discard;\n    \n  // read state\n  // x = mapping\n  // y = direction (s->d or d->s)\n  // z = lerp between maps\n  // w = base time\n    \n  vec4  data = texture(iChannel0, vec2(.5)/iChannelResolution[0].xy, -100.0);\n \n  // key pressed this frame\n  bool p = false;\n  \n  if (isKeyDown(KEY_UP))     { p=true; data.x = data.x + 1.; }\n  if (isKeyDown(KEY_DOWN))   { p=true; data.x = data.x + 1.; }\n  if (isKeyDown(KEY_RIGHT))  { p=true; data.z = data.z + .125; }\n  if (isKeyDown(KEY_LEFT))   { p=true; data.z = data.z - .125; }\n  if (isKeyDown(KEY_SPACE))  { p=true; data.y = toggleBit(data.y, 0.); }\n  if (isKeyDown(KEY_NUM(1))) { p=true; data.y = toggleBit(data.y, 1.); }\n  if (isKeyDown(KEY_NUM(2))) { p=true; data.y = toggleBit(data.y, 2.); }\n\n    \n  if (p) { data.w = iTime; }\n  \n  if (!p && !isBitSet(data.y, 0)) {\n    float dt = (iTime-data.w)*.5;\n    data.z += dt;\n      \n    if (data.z > 1.0) { \n      data.z  = 0.;\n      data.x += 1.;\n      if (data.x > 3.0) {\n        data.y = toggleBit(data.y, 1.);\n        if (!isBitSet(data.y, 1)) {\n          data.y = toggleBit(data.y, 2.);\n        }\n      }\n    }\n      \n    data.w = iTime;\n  }\n\n    \n  data.x = mod(data.x, 4.);\n  data.z = clamp(data.z, 0., 1.);\n    \n  // store state (one element so sloppy)\n  fragColor = data; \n}","name":"Buf A","description":"","type":"buffer"}]}