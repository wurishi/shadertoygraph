{"ver":"0.1","info":{"id":"dtcBz4","date":"1717879034","viewed":40,"name":"õ","username":"998244353","description":"õ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":[],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 hash33(vec3 p3)\n{\np3 = round(p3);\n  p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nfloat dist(vec3 r) { return dot(r, r); }\nfloat area(vec3 r) { return abs(r.x * r.y * r.z); }\n\nvec3 noise(vec3 pos) {\n    // return texture(iChannel0, pos).xyz;\n    vec3 d = fract(pos);\n    vec3 o = floor(pos);\n    vec3 ans = vec3(0.0);\n    \n    // vec3 v = vec3(x,y,z);\n    // ans += hash33(o + v) * area(vec3(-1.0) + d + v);\n    \n    ans += hash33(o + vec3(0., 0., 0.)) * area(vec3(-1.0) + d + vec3(0., 0., 0.));\n    ans += hash33(o + vec3(0., 0., 1.)) * area(vec3(-1.0) + d + vec3(0., 0., 1.));\n    ans += hash33(o + vec3(0., 1., 0.)) * area(vec3(-1.0) + d + vec3(0., 1., 0.));\n    ans += hash33(o + vec3(0., 1., 1.)) * area(vec3(-1.0) + d + vec3(0., 1., 1.));\n    ans += hash33(o + vec3(1., 0., 0.)) * area(vec3(-1.0) + d + vec3(1., 0., 0.));\n    ans += hash33(o + vec3(1., 0., 1.)) * area(vec3(-1.0) + d + vec3(1., 0., 1.));\n    ans += hash33(o + vec3(1., 1., 0.)) * area(vec3(-1.0) + d + vec3(1., 1., 0.));\n    ans += hash33(o + vec3(1., 1., 1.)) * area(vec3(-1.0) + d + vec3(1., 1., 1.));\n    \n    return ans;\n}\n\nvec3 fbm(vec3 pos, int iter)\n{\n    vec3 w = vec3(0.5);\n    mat3 s = mat3\n    (\n    vec3(0.745,0.549,0.294),\n    vec3(0.329,0.420,0.490),\n    vec3(0.561,0.600,0.486)\n    );\n    s[0] *= inversesqrt(s[0]);\n    s[1] *= inversesqrt(s[1]);\n    s[2] *= inversesqrt(s[2]);\n    s *= 1.1;\n    vec3 W = w, S = vec3(1.0);\n    vec3 ans = vec3(0.0);\n    for (int i = 0; i < iter; ++i)\n    {\n        ans += W * noise(pos * S);\n        W *= w; S *= s;\n    }\n    return ans;\n}\n\nfloat hash13(vec3 p3)\n{\np3 = round(p3);\n  p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx).x;\n}\n\nfloat noise13(vec3 pos) {\n    // return texture(iChannel0, pos).xyz;\n    vec3 d = fract(pos);\n    vec3 o = floor(pos);\n    float ans = 0.0;\n    \n    // vec3 v = vec3(x,y,z);\n    // ans += hash33(o + v) * area(vec3(-1.0) + d + v);\n    \n    ans += hash13(o + vec3(0., 0., 0.)) * area(vec3(-1.0) + d + vec3(0., 0., 0.));\n    ans += hash13(o + vec3(0., 0., 1.)) * area(vec3(-1.0) + d + vec3(0., 0., 1.));\n    ans += hash13(o + vec3(0., 1., 0.)) * area(vec3(-1.0) + d + vec3(0., 1., 0.));\n    ans += hash13(o + vec3(0., 1., 1.)) * area(vec3(-1.0) + d + vec3(0., 1., 1.));\n    ans += hash13(o + vec3(1., 0., 0.)) * area(vec3(-1.0) + d + vec3(1., 0., 0.));\n    ans += hash13(o + vec3(1., 0., 1.)) * area(vec3(-1.0) + d + vec3(1., 0., 1.));\n    ans += hash13(o + vec3(1., 1., 0.)) * area(vec3(-1.0) + d + vec3(1., 1., 0.));\n    ans += hash13(o + vec3(1., 1., 1.)) * area(vec3(-1.0) + d + vec3(1., 1., 1.));\n    \n    return ans;\n}\n\nfloat fbm13(vec3 pos, int iter)\n{\n    float w = 0.5;\n    mat3 s = mat3\n    (\n    vec3(0.745,0.549,0.294),\n    vec3(0.329,0.420,0.490),\n    vec3(0.561,0.600,0.486)\n    );\n    s[0] *= inversesqrt(s[0]);\n    s[1] *= inversesqrt(s[1]);\n    s[2] *= inversesqrt(s[2]);\n    s *= 1.1;\n    float W = w; vec3 S = vec3(1.0);\n    float ans = 0.0;\n    for (int i = 0; i < iter; ++i)\n    {\n        ans += W * noise13(pos * S);\n        W *= w; S *= s;\n    }\n    return ans;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 uv = vec3((fragCoord.xy * 2.0 - iResolution.xy) / sqrt(iResolution.x * iResolution.y), 0.1 * iTime);\n    \n    vec3 col;\n\n\n    // float val = (dot(col, col)) / sqrt(2.8) * 1.0;\n    float val = fbm13(uv + 2.0 * fbm(uv * 4.0, 10), 5);;\n    col = vec3(val);\n\n    float grey = val;\n\n\n    if (0.0 <= grey && grey < 0.5) // water\n        { col = map(grey, 0.0, 0.5, vec3(0.000,0.000,0.000), vec3(0.000,0.000,1.000)); }\n    else if (0.5 <= grey && grey < 0.53) // sand\n        { col = map(grey, 0.5, 0.53, vec3(1.000,0.784,0.000), vec3(1.000,0.969,0.000)); }\n    else if (0.53 <= grey && grey < 0.75) // grass\n        { col = map(grey, 0.53, 0.75, vec3(0.086,0.400,0.000), vec3(0.773,1.000,0.141)); }\n    else if (0.75 <= grey && grey < 0.85) // rocks\n        { col = map(grey, 0.75, 0.85, vec3(0.580,0.580,0.580), vec3(0.243,0.243,0.255)); }\n    else if (0.85 <= grey && grey <= 1.0) // snow\n        { col = map(grey, 0.85, 1.0, vec3(0.894,0.906,0.902), vec3(1.000,1.000,1.000)); }\n    else { col = vec3(1.000,0.000,0.000); }\n\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nfloat map(float t, float l, float r, float x, float y)\n{\n    return ((t - r) / (l - r)) * x + ((t - l) / (r - l)) * y;\n}\n\nvec3 map(float t, float l, float r, vec3 x, vec3 y)\n{\n    return ((t - r) / (l - r)) * x + ((t - l) / (r - l)) * y;\n}","name":"Common","description":"","type":"common"}]}