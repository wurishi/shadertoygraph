{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Steel ball by @Polyflare (27/1/15)\n// License: Creative Commons Attribution 4.0 International\n\n// Thanks iq for your publications about raymarching!\n\n// Internal settings\n#define MAX_STEPS 100\n#define GEPS 0.0001\n#define REPS 0.005\n#define LIGHT_DIR vec3(0.57735, 0.57735, 0.57735)\n\n// Distance field functions are from:\n// https://iquilezles.org/articles/distfunctions\nfloat sphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\nfloat round_box(vec3 p, vec3 b, float r)\n{\n    return length(max(abs(p) - b,0.0)) - r;\n}\n\n// Calculates the distance to the closest object in the scene\nfloat scene(vec3 p)\n{\n    float a = sphere(p + vec3(0.0, 0.0, 0.0), 0.5);\n    float b = round_box(p + vec3(0.0, 0.881, 0.0), vec3(5.0, 0.25, 5.0), 0.125);\n    return min(a, b);\n}\n\n// Calculate the normal at a point using distance field gradients\nvec3 gradnormal(vec3 pos)\n{\n    vec3 v1 = vec3( 1.0, -1.0, -1.0);\n    vec3 v2 = vec3(-1.0, -1.0,  1.0);\n    vec3 v3 = vec3(-1.0,  1.0, -1.0);\n    vec3 v4 = vec3( 1.0,  1.0,  1.0);\n\treturn normalize(\n        v1 * scene(pos + v1 * GEPS) + \n\t\tv2 * scene(pos + v2 * GEPS) + \n\t\tv3 * scene(pos + v3 * GEPS) + \n\t\tv4 * scene(pos + v4 * GEPS)\n    );\n}\n\n// Base raymarching algorithm\nbool raymarch(inout vec3 pos, vec3 cdir)\n{\n    float dist = 0.0;\n    float d;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        d = scene(pos);\n        if(d < REPS)\n        \tbreak;\n        dist += d;\n        pos += cdir * d;\n    }\n    return d < REPS;\n}\n\n// How much is the specified point in shadow? 0 = Complete shadow\nfloat shadowamount(vec3 pos)\n{\n    const float off = REPS * 2.0;\n    float dist = off; // Prevent self-shadowing\n    float light = 1.0;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        float d = scene(pos + LIGHT_DIR * dist);\n        if(d < REPS) {\n            light = 0.0;\n        \tbreak;\n        }\n        dist += d;\n        //light = min(light, 16.0 * d / dist); // Soft shadow (Broken)\n    }\n    return light;\n}\n\n// Trace a ray and calculate resulting colour. `raydir` is replaced with\n// the reflected ray, `pos` is replaced with the hit position, `fres` is\n// the weighting of the reflected colour.\nvec3 render(inout vec3 raydir, inout vec3 pos, out float fres)\n{\n    if(!raymarch(pos, raydir))\n    \treturn texture(iChannel0, raydir).xyz; // Background\n    vec3 n = gradnormal(pos);\n    float bright = 0.25; // Ambient lighting\n    vec3 albedo;\n    float light = 1.0;\n    if(pos.y >= -0.5) {\n        // Sphere\n        albedo = 0.7 * (\n            texture(iChannel2, pos.yz) * abs(n.x) +\n            texture(iChannel2, pos.zx) * abs(n.y) +\n            texture(iChannel2, pos.xy) * abs(n.z)\n        ).rgb;\n    \tfres = 0.2 + 0.8 * pow(1.0 + dot(raydir, n), 4.0);\n    } else {\n        // Table\n        light = shadowamount(pos);\n        albedo = texture(iChannel1, pos.xz).rgb;\n    \tfres = 0.25 * pow(1.0 + dot(raydir, n), 6.0);\n    }\n    float spec = 0.0;\n    if(light > 0.0) {\n        // Diffuse lighting\n        bright += max(dot(n, LIGHT_DIR), 0.0) * 0.75 * light;\n        // Specular lighting\n        vec3 lrefl = reflect(-LIGHT_DIR, n);\n        spec = pow(max(-dot(lrefl, raydir), 0.0), 12.0);\n    }\n    raydir = reflect(raydir, n); // Calculate reflected ray\n    return albedo * bright + vec3(spec * 0.667) * light;\n}\n\n// Camera perspective based on [0..1] viewport\nvec3 pixtoray(vec2 uv)\n{\n    vec3 pixpos;\n    pixpos.xy = uv - 0.5;\n    pixpos.y *= iResolution.y / iResolution.x; // Aspect correction\n    pixpos.z = -0.6; // Focal length (Controls field of view)\n    return normalize(pixpos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Camera stuff\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 raydir = pixtoray(uv);\n    vec3 pos = vec3(0.0, 0.0, 2.0); // Camera position\n    // Rotating camera\n    float cost = cos(iTime * 0.15);\n    float sint = sin(iTime * 0.15);\n    pos.xz = cost * pos.xz + sint * vec2(-pos.z, pos.x);\n    raydir.xz = cost * raydir.xz + sint * vec2(-raydir.z, raydir.x);\n    \n    // Rendering stuff\n    float fres = 0.0, fres2 = 0.0;\n    vec3 direct = render(raydir, pos, fres);\n    pos += raydir * (REPS * 2.0); // Offset reflection origin\n    vec3 refl = render(raydir, pos, fres2); // Reflection\n    fragColor.rgb = mix(direct, refl, fres); // Mix reflection into colour\n    fragColor.a = 1.0;\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4tfGWM","date":"1422282813","viewed":284,"name":"Steel ball","username":"Polyflare","description":"Hello world! This is my first Shadertoy and my first attempt at raymarching. Enjoy! :D","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""}}