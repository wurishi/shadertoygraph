{"ver":"0.1","info":{"id":"ttBBRz","date":"1598198788","viewed":533,"name":"Raytraced Swept Surface II","username":"fizzer","description":"Another quartic surface. This time it's a line segment swept along two independent quadratic Bezier curves.","likes":46,"published":1,"flags":0,"usePreview":0,"tags":["raytrace","spline","quadratic","quartic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Supersampled anti-aliasing level. Sample count = AA x AA.\n#define AA 2\n#define N 6\n\nconst float pi = 3.14159265358979323;\n\n// Evaluate quadratic polynomial with given coefficients.\nfloat applyCoeffs(vec3 coeffs, float x)\n{\n    return (x * coeffs.x + coeffs.y) * x + coeffs.z;\n}\n\n// Polynomial coefficient factors for a section of a 1D quadratic uniform B-spline.\nvec3 coeffsForCP(float i)\n{\n    if(i < 1.)\n        return vec3(.5, 0, 0);\n    else if(i < 2.)\n        return vec3(-1., 1., .5);\n    return vec3(.5, -1., .5);\n}\n\n// Functions solve_quadric, solve_cubic, solve_quartic, and absmax are from Wyatt's\n// quartic solver collection: https://www.shadertoy.com/view/XddfW7\n// (Shane's version of the solver)\nint solve_quadric(vec2 coeffs, inout vec2 roots){\n    float p = coeffs.y / 2.;\n    float D = p*p - coeffs.x;\n    if (D <= 0.) return 0;\n    else {\n        roots = vec2(-1, 1)*sqrt(D) - p;\n        return 2;\n    }\n}\nint solve_cubic(vec3 coeffs, inout vec3 r){\n    float a = coeffs[2];\n    float b = coeffs[1];\n    float c = coeffs[0];\n    float p = b - a*a/3.;\n    float q = a * (2.*a*a - 9.*b)/27. + c;\n    float p3 = p*p*p;\n    float d = q*q + 4.*p3/27.;\n    float offset = -a/3.;\n    if(d >= 0.0) { \n        vec2 uv = (vec2(1, -1)*sqrt(d) - q)/2.;\n        uv = uv = sign(uv)*pow(abs(uv), vec2(1./3.));\n        r[0] = offset + uv.x + uv.y;\t\n        float f = ((r[0] + a)*r[0] + b)*r[0] + c;\n        float f1 = (3.*r[0] + 2. * a)*r[0] + b;\n        r[0] -= f/f1;\n        return 1;\n    }\n    float u = sqrt(-p/3.);\n    float v = acos(-sqrt(-27./p3)*q/2.)/3.;\n    float m = cos(v), n = sin(v)*1.732050808;\n    float f,f1;\n    r[0] = offset + u * (m + m);\n    f = ((r[0] + a)*r[0] + b)*r[0] + c;\n    f1 = (3.*r[0] + 2. * a)*r[0] + b;\n    r[0] -= f / f1;\n    r[1] = offset - u * (n + m);\n    f = ((r[1] + a)*r[1] + b) * r[1] + c;\n    f1=(3.*r[1] + 2. * a)*r[1] + b;\n    r[1] -= f / f1;\n    r[2] = offset + u * (n - m);\n    f = ((r[2] + a)*r[2] + b)*r[2] + c;\n    f1 = (3.*r[2] + 2. * a)*r[2] + b;\n    r[2] -= f / f1;\n    return 3;\n}\nbvec4 solve_quartic(vec4 coeffs, inout vec4 s){\n    bvec4 broots;\n    float a = coeffs[0];\n    float b = coeffs[1];\n    float c = coeffs[2];\n    float d = coeffs[3];\n    float sq_a = a * a;\n    float p = - 3./8. * sq_a + b;\n    float q = 1./8. * sq_a * a - 1./2. * a * b + c;\n    float r = - 3./256.*sq_a*sq_a + 1./16.*sq_a*b - 1./4.*a*c + d;\n    int num;\n    vec3 cubic_coeffs;\n    cubic_coeffs[0] = 1.0/2. * r * p - 1.0/8. * q * q;\n    cubic_coeffs[1] = - r;\n    cubic_coeffs[2] = - 1.0/2. * p;\n    solve_cubic(cubic_coeffs, s.xyz);\n    float z = s[0];\n    float u = z * z - r;\n    float v = 2. * z - p;\n    if(u > 0.) u = sqrt(abs(u));\n    else return bvec4(false);\n    if(v > 0.) v = sqrt(abs(v));\n    else return bvec4(false);\n    vec2 quad_coeffs;\n    quad_coeffs[0] = z - u;\n    quad_coeffs[1] = q < 0. ? -v : v;\n    num = solve_quadric(quad_coeffs, s.xy);\n    if (num == 0) broots.xy = bvec2(false);\n    if (num == 2) broots.xy = bvec2(true);\n    quad_coeffs[0] = z + u;\n    quad_coeffs[1] = q < 0. ? v : -v;\n    vec2 tmp = vec2(1e8);\n    int old_num = num;\n    num = solve_quadric(quad_coeffs, s.zw);\n    if (num == 0) broots.zw = bvec2(false);\n    if (num == 2) broots.zw = bvec2(true);\n    s -= a/4.;\n    \n#if 1\n    // Newton-Raphson iteration to improve root accuracy\n    for(int i = 0; i < 2; ++i)\n        s -= ((((s + a) * s + b) * s + c) * s + d) / \n            (((4. * s + 3. * a) * s + 2. * b) * s + c);\n#endif\n    \n    return broots;\n}\n\n// Ray-box intersection.\nvec2 box(vec3 ro,vec3 rd,vec3 p0,vec3 p1)\n{\n    vec3 t0 = (mix(p1, p0, step(0., rd * sign(p1 - p0))) - ro) / rd;\n    vec3 t1 = (mix(p0, p1, step(0., rd * sign(p1 - p0))) - ro) / rd;\n    return vec2(max(t0.x, max(t0.y, t0.z)),min(t1.x, min(t1.y, t1.z)));\n}\n\n\n// Assumes rd is normalized.\nvec2 intersectSphere(vec3 ro, vec3 rd, vec3 org, float rad)\n{\n    ro -= org;\n    float b = dot(rd, ro);\n    float c = dot(ro, ro) - rad * rad;\n    float desc = b * b - c;\n    if (desc < 0.)\n        return vec2(1, 0);\n\tdesc = sqrt(desc);\n    return vec2(-b - desc, -b + desc);\n}\n\n// From https://www.shadertoy.com/view/Xt3SzX\n// intersect capsule : https://iquilezles.org/articles/intersectors\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n\n        float y = baoa + t*bard;\n        \n        // body\n        if( y>0.0 && y<baba ) return t;\n\n        // caps\n        vec3 oc = (y<=0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - r*r;\n        h = b*b - c;\n        if( h>0.0 )\n        {\n            return -b - sqrt(h);\n        }\n    }\n    return -1.0;\n}\n\n// From https://www.shadertoy.com/view/Xt3SzX\n// compute normal\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r )\n{\n    vec3  ba = b - a;\n    vec3  pa = pos - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    return (pa - h*ba)/r;\n}\n\n// Tests for ray intersection with a parametric surface essentially defined as a linear interpolation\n// between two quadratic Bezier curves. cp0 and cp1 each contain 3 sets of quadratic polynomial\n// coefficients (one for each of x, y, and z).\nvec4 intersectSection(vec3 rd, mat3 cp0, mat3 cp1, inout vec2 out_uv)\n{\n    vec3 d0 = cp0[0];\n\tvec3 d1 = cp0[1];\n    vec3 d2 = cp0[2];\n\n    vec3 e0 = cp1[0];\n\tvec3 e1 = cp1[1];\n    vec3 e2 = cp1[2];\n    \n    // First solve for the U parameter of the surface.\n    // The equation to solve is dot(rd, cross(f(u), g(u))) == 0 for u where f and g are\n    // parametric 2nd-order Bezier curves.\n    // This produces a quartic polynomial equation.\n    \n\tfloat coeff0 = dot(cross(d0, e0), rd); // ^4\n    float coeff1 = dot(cross(d0, e1) + cross(d1, e0), rd); // ^3\n    float coeff2 = dot(cross(d0, e2) + cross(d2, e0) + cross(d1, e1), rd); // ^2\n    float coeff3 = dot(cross(d1, e2) + cross(d2, e1), rd); // ^1\n    float coeff4 = dot(cross(d2, e2), rd); // ^0\n\n    bool inverted = false;\n    \n    if(abs(coeff0) < abs(coeff4))\n    {\n        // Reverse the coefficients and solve for 1 / u instead.\n        // This helps to avoid catastrophic cancellation due to division by very small values\n        // when passing the depressed quartic to solve_quartic.\n        float temp = coeff0;\n        coeff0 = coeff4;\n        coeff4 = temp;\n        temp = coeff1;\n        coeff1 = coeff3;\n        coeff3 = temp;\n        inverted = true;\n    }\n    \n    vec4 roots;\n    bvec4 br = solve_quartic(vec4(coeff1, coeff2, coeff3, coeff4) / coeff0, roots);\n\n    vec2 hit_uv;\n\tfloat hit_t = 1e4;\n    \n    // Test each of the up-to-4 possible roots in turn.\n    for(int i = 0; i < 4; ++i)\n        if(br[i])\n        {\n            float u = inverted ? 1. / roots[i] : roots[i];\n            if(u > 0. && u < 1.)\n            {\n                // A value U parameter has been found. Now find the V parameter\n                // by intersecting the ray with the line segment defined the surface at U.\n                \n                // Evaluate the two Bezier curves. The line segment intersects the Bezier curves\n                // at p and q.\n                vec3 p = u * (u * d0 + d1) + d2;\n\t\t\t\tvec3 q = u * (u * e0 + e1) + e2;\n                vec3 qp = q - p;\n                \n                vec3 n = cross(p, q);\n                vec3 m = cross(n, qp);\n\n                float t = dot(p, m) / dot(rd, m);\n                \n                if(t > 0. && t < hit_t)\n                {\n                    vec3 rp = rd * t;\n                    float v = dot(rp - p, qp);\n                    float l = dot(qp, qp);\n                    if(v > 0. && v < l)\n                    {\n                        // A valid intersection has been found.\n                        hit_t = t;\n                        hit_uv = vec2(u, v / l);\n                    }\n                }\n\n            }\n        }\n    \n    if(hit_t > 1e3)\n    \treturn vec4(1e4, 0, 0, 0);\n\n    // Calculate surface normal from surface differentials.\n    \n    vec3 p = hit_uv.x * (hit_uv.x * d0 + d1) + d2;\n    vec3 q = hit_uv.x * (hit_uv.x * e0 + e1) + e2;\n\n    vec3 g0 = 2. * hit_uv.x * d0 + d1;\n\tvec3 g1 = 2. * hit_uv.x * e0 + e1;\n    \n    vec3 tangent_u = mix(g0, g1, hit_uv.y);\n    vec3 tangent_v = p - q;\n    \n    vec3 normal = cross(tangent_u, tangent_v);\n    \n    out_uv = hit_uv;\n    \n    return vec4(hit_t, normal);\n}\n\nvec3 sampleEnv(vec3 ro, vec3 rd)\n{\n    // Sample the environment map.\n    return texture(iChannel0, rd.zyx, 2.).rgb;\n}\n\n// Arbitrary quadratic B-Spline control points.\nmat2x3 controlPoints(int i)\n{\n    float t = float(i) / float(N);\n    float rd = sin(t * pi * 4. + iTime / 2.) * .5;\n    float r1 = 1.3 + rd;\n    float r0 = .7 + rd;\n    vec3 a = vec3(cos(t * pi * 2.) * r0, sin(float(i) + iTime) * .3, sin(t * pi * 2.) * r0);\n    vec3 b = vec3(cos(t * pi * 2.) * r1, sin(float(i * 2) + iTime) * .3, sin(t * pi * 2.) * r1);\n    return mat2x3(a, b);\n}\n\n// Tests for ray intersection with a surface made of stitched-together patches. Surface shape\n// is defined by a pair of quadratic B-Splines.\nvec4 traceScene(vec3 ro, vec3 rd, out int objid, inout vec3 out_uvw)\n{\n    float mt = 1e3;\n    vec3 normal;\n    \n    out_uvw = vec3(-1.);\n    \n    for(int i = 0; i < N; ++i)\n    {\n        int j = (i + 1) % N;\n        int k = (i + 2) % N;\n        \n        // The polynomial coefficients can be expressed as a linear combination of the 3 contributing\n        // control points.\n        \n        mat2x3 cp0 = controlPoints(i);\n        mat2x3 cp1 = controlPoints(j);\n        mat2x3 cp2 = controlPoints(k);\n\n        for(int m = 0; m < 2; ++m)\n        {\n            vec2 sphere_is = intersectSphere(ro, rd, cp0[m], .03);\n            if(sphere_is.x < sphere_is.y && sphere_is.x > 0. && sphere_is.x < mt)\n            {\n                out_uvw = vec3(.5, .5, 13.);\n                normal = ro + rd * sphere_is.x - cp0[m];\n                mt = sphere_is.x;\n            }\n            float capsule_is = capIntersect(ro, rd, cp0[m], cp1[m], .01);\n            if(capsule_is > 0. && capsule_is < mt)\n            {\n                out_uvw = vec3(.5, .5, 18.);\n                normal = capNormal(ro + rd * capsule_is, cp0[m], cp1[m], .01);\n                mt = capsule_is;\n            }\n        }\n        \n        \n        mat3 b = mat3(coeffsForCP(2.), coeffsForCP(1.), coeffsForCP(0.));\n\n        mat3 scp0 = mat3(cp0[0] - ro, cp1[0] - ro, cp2[0] - ro) * transpose(b);\n\t\tmat3 scp1 = mat3(cp0[1] - ro, cp1[1] - ro, cp2[1] - ro) * transpose(b);\n\n        // Get the worldspace Bezier-style control points for calculating a bounding box.\n        \n        vec3 P0 = scp0[2];\n        vec3 P1 = (scp0[1] + 2. * scp0[2]) / 2.;\n        vec3 P2 = scp0[0] + 2. * P1 - P0;\n\n        vec3 Q0 = scp1[2];\n        vec3 Q1 = (scp1[1] + 2. * scp1[2]) / 2.;\n        vec3 Q2 = scp1[0] + 2. * Q1 - Q0;\n        \n        vec3 box_min = min(Q0, min(Q1, min(Q2, min(P0, min(P1, P2)))));\n        vec3 box_max = max(Q0, max(Q1, max(Q2, max(P0, max(P1, P2)))));\n        \n        // Test bounding box.\n        \n        vec2 box_is = box(vec3(0), rd, box_min, box_max);\n        \n      \tif(box_is.y < 0. || box_is.x > box_is.y)\n       \t\tcontinue;\n        \n        // Start ray at bounding surface to help improve precision (slightly).\n        vec3 ro2 = ro + box_is.x * rd;\n        \n        scp0 = mat3(cp0[0] - ro2, cp1[0] - ro2, cp2[0] - ro2) * transpose(b);\n\t\tscp1 = mat3(cp0[1] - ro2, cp1[1] - ro2, cp2[1] - ro2) * transpose(b);\n        \n        vec2 uv = vec2(-1.);\n    \tvec4 res = intersectSection(rd, scp0, scp1, uv);\n\n        if(res.x > 1e-3)\n        {\n            res.x += box_is.x;\n\n            if(res.x < mt)\n            {\n                // A closer hit has been found.\n                out_uvw = vec3(uv, float(i));\n                normal = res.yzw;\n                mt = res.x;\n            }\n        }\n    }\n    \n    return vec4(mt, normal);\n}\n\n\nmat3 rotX(float a)\n{\n    return mat3(1., 0., 0., 0., cos(a), sin(a), 0., -sin(a), cos(a));\n}\n\nmat3 rotY(float a)\n{\n    return mat3(cos(a), 0., sin(a), 0., 1., 0., -sin(a), 0., cos(a));\n}\n\nmat3 rotZ(float a)\n{\n    return mat3(cos(a), sin(a), 0., -sin(a), cos(a), 0., 0., 0., 1.);\n}\n\nvoid render(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n\tuv.x *= iResolution.x / iResolution.y;\n    \n    // Camera position and target.\n    vec3 campos = vec3(0, .5, 2.);\n    vec3 camtarget = vec3(0, -.15, 0);\n\tvec3 ro = campos, rd = normalize(vec3(uv, 2.));\n    \n    // Camera lookat.\n    vec3 w = normalize(camtarget - campos);\n    vec3 u = normalize(cross(vec3(0, 1, 0), w));\n    vec3 v = cross(w, u);\n    rd = mat3(u, v, w) * rd;\n\n\t// Scene rotation and positioning\n    mat3 m = rotY(iTime / 8.);\n    ro = m * ro;\n    rd = normalize(m * rd);\n    \n    fragColor.rgb = vec3(0);\n    \n    vec3 fac = vec3(1);\n\n    rd = normalize(rd);\n    int objid;\n    vec3 uvw = vec3(-1);\n    vec4 res = traceScene(ro, rd, objid, uvw);\n\n    if(res.x > 1e2)\n    {\n        // Ray escaped the scene. Sample the environment map.\n        fragColor.rgb += texture(iChannel0, rd.zyx, 1.5).rgb * fac;\n        return;\n    }\n\n    vec3 normal = normalize(res.yzw);\n    vec3 forwardNormal = faceforward(normal, rd, normal);\n    vec3 rp = ro + rd * res.x;\n\n    // Texturing and shading.\n    \n    float fr = mix(.05, .3, clamp(pow(1. - dot(rd, -forwardNormal), 3.), 0., 1.));\n\n    uvw.xy *= 4.;\n    fragColor.rgb = vec3(.2 + .8 * step(fract(uvw.x + .5 * step(fract(uvw.y), .5)), .5));\n    fragColor.rgb *= cos(vec3(1, 2, 3) * uvw.z) * .5 + .5;\n    fragColor.rgb *= .1 + .9 * max(0., dot(forwardNormal, normalize(vec3(1, 1, 1))));\n    fragColor.rgb = mix(fragColor.rgb, sampleEnv(ro, reflect(rd, normal)) * fac, fr);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n\tuv.x *= iResolution.x / iResolution.y;\n    fragColor.rgb = vec3(0);\n    \n\tfor(int y = 0; y < AA; ++y)\n        for(int x = 0; x < AA; ++x)\n        {\n            vec4 col = vec4(0);\n            render(col, fragCoord + vec2(x, y) / float(AA));\n            fragColor.rgb += max(col.rgb, 0.);\n        }\n    \n    fragColor.rgb *= 1.2 / float(AA * AA);\n    \n    // Vignet,\n    fragColor.rgb *= vec3(1. - (pow(abs(uv.x), 4.) + pow(abs(uv.y * 1.5), 4.)) * .04);\n    \n    // Tonemapping.\n    fragColor.rgb /= (fragColor.rgb + 1.) * .5;\n    \n    // Gamma and dither.\n    fragColor.rgb = pow(fragColor.rgb, vec3(1. / 2.2)) +\n        \t\t\t\ttexelFetch(iChannel2, ivec2(fragCoord) & 1023, 0).rgb / 200.;\n}\n","name":"Image","description":"","type":"image"}]}