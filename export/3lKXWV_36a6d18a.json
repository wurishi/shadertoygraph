{"ver":"0.1","info":{"id":"3lKXWV","date":"1583632192","viewed":185,"name":"ClockEyes âš™","username":"HaleyHalcyon","description":"aeuaoeuaouou","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["spiral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265;\n\nfloat remap(float x, float lowIn, float rangeIn, bool invert)\n{\n    float o = clamp(clamp(x - lowIn, 0., rangeIn) / rangeIn, 0., 1.);\n    if (invert) {\n        return 1. - o;\n    }\n    return o;\n}\n\nvec3 blend(vec3 x1, vec3 x2, float factor)\n{\n    return x2 * factor + x1 * (1. - factor);\n}\n\nfloat zigzag(float x)\n{\n    return abs(1. - mod(x, 2.0));\n}\n  \nfloat eyeAccent(float x) {\n  if (x > 1.0) {\n    return 0.;\n  }\n  return 1.0 - x * x;\n}\n  \nfloat timeBounce(float x)\n{\n    return -3. * sin(PI * x) + x;\n}\n\nfloat gear(float d, float theta)\n{\n    // constants\n    // radii\n    const float scale = 0.5; // total size of the gear\n    d /= scale;\n    float smoothing = fwidth(d) * 1.5; // radial; teeth and spoke smoothing are defined separately\n    const float center = 0.2; // spokes start here\n    const float inner = 0.5; // spokes end here\n    const float outer = 0.75; // teeth start here\n    \n    // teeth\n    const float teethCount = 8.0;\n    const float teethWidth = 0.3; // from 0.0 to 1.0\n    const float teethSlant = 0.2; // purely radial sides don't look right\n    float teethSmoothing = min(fwidth(\n        theta / PI * teethCount\n    ), fwidth(\n        fract(0.5 + theta / PI) * teethCount\n    )) * 1.5;\n    // spokes\n    const float spokeCount = 4.0;\n    const float spokeWidth = 0.08; // from 0.0 to 1.0\n    const float spokeSlant = 0.3; // purely radial sides don't look right\n    float spokeSmoothing = fwidth(\n        zigzag(theta / PI * spokeCount)\n        - (d / (inner - center))\n        * (d / (inner - center))\n        * spokeSlant\n    ) * 1.5;\n    \n    if (d < center) {\n        return 1.;\n    } else if (d < inner) {\n        float slant = remap(\n            d, center, inner + smoothing - center, true\n        );\n        return clamp(\n            remap( // center\n                d, center, smoothing, true\n            )\n            +\n            remap( // spokes\n                1. - zigzag(\n                    theta / PI * spokeCount\n                ) - slant * slant * spokeSlant,\n                spokeWidth,\n                spokeSmoothing,\n                true\n            )\n            +\n            remap( // inner\n                d,\n                inner - smoothing,\n                smoothing,\n                false\n            )\n        , 0., 1.);\n    } else if (d < outer) {\n        return 1.;\n    } else if (d < 1.) {\n        return clamp(\n            min(\n                remap(d, outer, smoothing, true) // ring smoothing\n                +\n                remap( // teeth\n                    1. - zigzag(theta / PI * teethCount) - remap(\n                        d, outer, 1. + smoothing - outer, true\n                    ) * teethSlant,\n                    teethWidth,\n                    teethSmoothing,\n                    true\n                )\n            ,\n                remap( // smooth outer rim of gear\n             \t\td,\n                    1. - 2. * smoothing, // smooth double for outside\n                    smoothing,\n                    true\n                )\n            )\n        , 0., 1.);\n    }\n    return 0.;\n}\n\nfloat tick(float t){\n    const float ticksPerRot = 24.0;\n    const float tickLength = 0.125;\n    const float tickPeriod = 1.;\n    t += 0.5 * tickLength + 0.5 * tickPeriod;\n    return (\n        floor(t / tickPeriod) + smoothstep(0., 1., (mod(t / tickPeriod, 1.) - 0.5) / tickLength)\n \t\t) / ticksPerRot\n    ;\n}\n  \nfloat spiral(float x) {\n  return max(0.0, sin(x) * 0.75 + 0.25);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n  // colors\n  const vec3 colorBase = vec3(0.25, 0.75, 1);\n  const vec3 colorBase2 = vec3(-0.15, -0.35, -0.4);\n  const vec3 colorGear = vec3(0.9, 0.95, 0.95);\n  const vec3 colorSpiral = vec3(0.2);\n\n  // parameters to tweak\n  // more params for the gear inside the gear() function\n  const float eyesScale = 0.7;\n\n  // more params for the ticking inside the tick() function\n  float time = tick(iTime);\n\n  // Normalized pixel coordinates (from 0 to 1)\n  float scale = min(iResolution.x, iResolution.y);\n  vec2 uv = (gl_FragCoord.xy - 0.50 * iResolution.xy) / scale * 1.41421356;\n    \n  float dist = sqrt(uv.x*uv.x+uv.y*uv.y) / eyesScale;\n  /*if (dist > 1.1) {\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    return;\n  }*/\n  float angle = atan(uv.y, uv.x);\n\n  // Time varying pixel color\n  float cAccent = eyeAccent(dist);\n  float cGear = gear(dist, angle + 2. * PI * time);\n  \n  float logDist = log(dist);\n  float bounceTime = timeBounce(iTime * 2.0 + logDist * 0.4);\n  float ring = spiral(logDist * 8.0 + bounceTime);\n  \n  vec3 colBase = colorBase + cAccent * colorBase2 + ring * colorSpiral;\n\n  // Output to screen\n  fragColor =\n    vec4(\n      blend(\n        colBase,\n        colorGear,\n        cGear\n      ) // * remap(dist, 1.0, 0.1, true)\n      , 1\n    );\n}","name":"Image","description":"","type":"image"}]}