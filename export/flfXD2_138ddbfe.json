{"ver":"0.1","info":{"id":"flfXD2","date":"1722650003","viewed":39,"name":"Oscillating CellAut Maze","username":"MazeMason","description":"A cellular automata that generates mazes that are perfect on each iteration. Enter to reset, Space to stop/start, Down to erode, Up to rebuild.","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["maze","cellularautomata","multipass"],"hasliked":0,"parentid":"NllSW4","parentname":"Cellular Automata Perfect Maze"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const bool grid = false;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    ivec2 coord = ivec2((fragCoord  + iResolution.xy / 2.0 + zoom / 2.0) / zoom - iResolution.xy * (1.0 - zoom)/zoom); \n    vec4 col = texelFetch(iChannel0, coord / 2 , 0);\n    int comp = coord.x % 2 + 2 * (coord.y % 2); \n \n     // Output to screen\n     \n    float color = steps?col[comp]:max(outside * float(col[comp] != 0.0), float(col[comp] == 1.0));\n    fragColor = vec4(color - float(grid && any(equal(mod((fragCoord-.50)/ 2.0,zoom), vec2(.75*zoom, 7.)))));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_ENTER  = 13;\n\nfloat hash12(vec2 src) {\n    return abs(fract(hash14(vec4(iFrame,\n                                int(iDate.y * 32.0 + iDate.z),\n                                int(iDate.w),\n                                src.x + src.y * iResolution.x))));\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec4 color = texelFetch(iChannel0, ivec2(fragCoord - 0.5), 0);\n    \n                \n                \n    vec4 mem = texelFetch(iChannel0, ivec2(0), 0);\n    float reset = float(texelFetch( iChannel1, ivec2(KEY_ENTER,0),0 ).x == 1.0 ||\n                        all(notEqual(mem.xy, iResolution.xy)));\n    float dir = max(texelFetch( iChannel1, ivec2(KEY_UP,0),0 ).x, reset) - \n                    texelFetch( iChannel1, ivec2(KEY_DOWN,0),0 ).x;\n\n    float stop = texelFetch(iChannel1, ivec2(KEY_SPACE,2),0 ).x;\n\n    if(all(equal(fragCoord, vec2(0.5)))) {\n        color = vec4(vec2(iResolution.xy), // previous resolution\n                         (mem.z + 1.0) * (1.0 - reset),\n                          mem.w * (1. - abs(dir)) + abs(dir) * (dir / 2.0 +.5));\n        \n    } else {\n\n        int frame = int(mem.z);\n\n        if(frame == 0 && !all(equal(fragCoord, vec2(0.5)))) {\n\n            // one cell initial maze on reset\n            vec2 coord = fragCoord - 0.5 - iResolution.xy / 2.0;\n            color = vec4(outside * (1.0 - step(0.0, coord.x)*step(coord.x,1.0) *\n                                          step(0.0, coord.y)*step(coord.y,1.0)) ,\n                         outside * (1.0 - float(0.0 == coord.x) *\n                                          step(0.0, coord.y)*step(coord.y,1.0)),\n                         outside * (1.0 - float(0.0 == coord.y) *\n                                          step(0.0, coord.x)*step(coord.x,1.0)),\n                         max(outside, float(all(equal(coord, vec2(0.))))));\n\n        } else if(frame % delay == 0 && bool(1.0 - stop)) {\n            vec4 here = texelFetch(iChannel0, ivec2(fragCoord -.5), 0);\n            vec4 down = texelFetch(iChannel0, ivec2(fragCoord - vec2(0.5, 1.5)), 0);\n            vec4 left = texelFetch(iChannel0, ivec2(fragCoord - vec2(1.5, 0.5)), 0);\n            vec4 up = texelFetch(iChannel0, ivec2(fragCoord - vec2(0.5, -0.5)), 0);\n            vec4 right = texelFetch(iChannel0, ivec2(fragCoord - vec2(-.5, .5)), 0);\n\n            if(mem.w == 1.0) {\n                // open doors to outside based on random seeds for buffer B\n\n                if(here.x == block) {\n                    if(here.w == open &&\n                        ( down.w != open && down.w != block ||\n                          left.w != open && left.w != block )) {\n                            here = vec4(block, float(here.y == open || down.w == outside + north),\n                                               float(here.z == open || left.w == outside + east), open);             \n\n                    } else if(here.w != open && here.w != outside) {\n                             here = vec4(block, float(down.w == outside + north || here.w == outside + south), \n                                                float(left.w == outside + east || here.w == outside + west), open);             \n                    }\n                }\n            } else {\n            \n                if(here.w > outside && here.w < open) {\n                    here.w = outside;\n                } else if(here.w == open){\n\n                    float doors = step(1.0, here.z) + step(1.0, here.y) +\n                                    step(1.0, right.z) + step(1.0, up.y);\n            \n                    float outs = 4.0 - (step(1.0, up.w) + step(1.0, left.w) +\n                                    step(1.0, down.w) + step(1.0, right.w));\n \n                    if(doors == 1.0 && outs < 4.0) {\n                           \n                            here = vec4(block, \n                                            outside * (1.0 - step(open,here.y)) * (1.0 - step(open, down.w)),\n                                            outside * (1.0 - step(open,here.z)) * (1.0 - step(open, left.w)), \n                                            outside);             \n                    }\n                }\n            }\n            \n            color = here;\n\n        }\n    }    \n    \n    fragColor = color;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//Please change these to change the maze\nconst int delay = 1;\nconst float zoom = 1.;\nconst bool sparse = false;\nconst float square = .51;\n\n\nconst bool steps = false;\n\n\n// cell states, not to modified\nconst float block = 0.0;   // black\nconst float open  = 1.0;   // white\nconst float outside = 0.5; //grey\n\n// the randomized states to open the external blocks\nconst float north = 0.1;\nconst float west = 0.2;\nconst float south = 0.3;\nconst float east = 0.4;\n\nconst int KEY_SPACE = 32;\n\n\n\n\n\n\n\n// https://www.shadertoy.com/embed/ttc3zr\n// 1 output, 4 inputs\nuint murmurHash14(uvec4 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z; h *= M; h ^= src.w;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 1 output, 4 inputs\nfloat hash14(vec4 src) {\n    uint h = murmurHash14(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n\n\n\n\n\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 here = texelFetch(iChannel0, ivec2(fragCoord -.5), 0);\n    vec4 s = texelFetch(iChannel0, ivec2(fragCoord - vec2(0.5, 1.5)), 0);\n    vec4 sw = texelFetch(iChannel0, ivec2(fragCoord - vec2(1.5, 1.5)), 0);\n    vec4 se = texelFetch(iChannel0, ivec2(fragCoord - vec2(-.5, 1.5)), 0);\n    vec4 w = texelFetch(iChannel0, ivec2(fragCoord - vec2(1.5, 0.5)), 0);\n    vec4 n = texelFetch(iChannel0, ivec2(fragCoord - vec2(0.5, -.5)), 0);\n    vec4 nw = texelFetch(iChannel0, ivec2(fragCoord - vec2(1.5, -.5)), 0);\n    vec4 e = texelFetch(iChannel0, ivec2(fragCoord - vec2(-.5, 0.5)), 0);\n    \n    vec4 new = vec4(here.x, here.y, here.z, here.w);\n    \n    vec4 mem = texelFetch(iChannel0, ivec2(0), 0);\n    int stop = int(texelFetch( iChannel1, ivec2(KEY_SPACE,0),2 ).x);\n\n\n    int frame = int(mem.z) - 1;\n\n    if(!all(equal(fragCoord, vec2(0.5)))) {\n        if(frame % delay == int(steps) * delay /4 * (1 - stop)){\n            if(bool(int(step(1., mem.w)))) {\n\n                // close blocks around new open doors from buffer a to complete the maze\n                if(here.x == outside) {\n                    new.x = here.x * (1.0 - float(sw.w == open || s.w == open || w.w == open || e.z == open || n.y == open || se.z == open|| nw.y == open));\n                }\n\n                if(here.y == outside) {\n                    new.y = here.y * (1.0 - float(s.w == open || s.z == open || e.z == open || se.z == open || e.z == open || n.y == open));\n                }\n\n                if(here.z == outside) {\n                    new.z = here.z * (1.0 - float(w.w == open || w.y == open || n.y == open || nw.y == open || e.z == open ));\n                }\n\n                if(here.w != open && here.w != block ) {\n\n                    new.w = min(outside * (1.0 - float(here.z == open || here.y == open )) + float(n.y == open || e.z == open), 1.0);\n                }\n            } else {\n                if(here.x != outside) {\n                    new.x = outside * (1.0 - step(1.0, step(open,s.w) + step(open,sw.w) + step(open,w.w) + step(open,here.w)));\n                }\n\n                if(here.y != outside) {\n                    new.y = here.y * step(open, s.w) * step(open, here.w) + outside * step(here.w, outside) * (1.0 - step(open, s.w));\n                }\n\n                if(here.z != outside) {\n                    new.z = here.z * step(open, w.w) * step(open, here.w) + outside * step(here.w, outside) * (1.0 - step(open, w.w));\n                }\n\n            }\n        }\n    }\n    \n    fragColor = new;\n    \n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float hash12(vec2 src) {\n    return abs(fract(hash14(vec4(iFrame,\n                                int(iDate.y * 32.0 + iDate.z),\n                                int(iDate.w),\n                                src.x + src.y * iResolution.x))));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 here = texelFetch(iChannel0, ivec2(fragCoord -.5), 0);\n    vec4 s = texelFetch(iChannel0, ivec2(fragCoord - vec2(0.5, 1.5)), 0);\n    vec4 w = texelFetch(iChannel0, ivec2(fragCoord - vec2(1.5, 0.5)), 0);\n    vec4 n = texelFetch(iChannel0, ivec2(fragCoord - vec2(0.5, -.5)), 0);\n    vec4 e = texelFetch(iChannel0, ivec2(fragCoord - vec2(-.5, 0.5)), 0);\n    \n    vec4 mem = texelFetch(iChannel0, ivec2(0), 0);\n    int stop = int(texelFetch( iChannel1, ivec2(KEY_SPACE,2),0).x);\n\n    int frame = int(mem.z) -1;\n\n\n    if(frame % delay == int(steps) * delay /2 && mem.w == 1.0 && !bool(stop) &&\n        !all(equal(fragCoord, vec2(0.5)))) {\n    \n        // random seeds around external walls to open new doors on buffer a \n        if(here.w != open && here.w != block && \n                fragCoord.x > iResolution.x * (.5 - .25 / zoom) + .6 &&\n                fragCoord.y > iResolution.y * (.5 - .25 / zoom) + .6 &&\n                fragCoord.x < iResolution.x * (.5 + .25 / zoom) - .6 &&\n                fragCoord.y < iResolution.y * (.5 + .25 / zoom) - .6 ) {\n            \n            \n            float[4] dir = float[](0.0,0.0,0.0,0.0);\n            int i = 0;\n            \n             \n            if(n.y == block && n.w == open){\n                dir[i++] = north;\n            }\n            \n            if(here.z == block && w.w == open){\n                dir[i++] = west;\n            }\n\n            if(here.y == block && s.w == open){\n                dir[i++] = south;\n            }\n            \n\n            if(e.z == block && e.w == open){\n                dir[i++] = east;\n            }\n            \n            float r = hash12(fragCoord);\n            float rr = floor(r * 10.) / 10.;\n\n            float rand = float(square > rr) *\n                           float(i>0 && !sparse || i == 1) * \n                           dir[int(floor(float(i) * r))];\n \n            here.w = outside + rand;\n        }\n\n    }\n    \n    fragColor = here;\n}","name":"Buffer B","description":"","type":"buffer"}]}