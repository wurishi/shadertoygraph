{"ver":"0.1","info":{"id":"XttyW7","date":"1533116491","viewed":390,"name":"Circular Separable DoF ","username":"dybiszb","description":"Click LMB and move mouse to adapt bokeh.\nNOTE: IT IS by all means NOT OPTIMAL. Its purpose is purely educational. \nFollowing code implements ideas described here:\nhttps://www.ea.com/frostbite/news/circular-separable-convolution-depth-of-field","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["dof","field","field","depth","depth","circular","separable","of","of","kleber","garcia","fifa","madden"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ================================================================================\n// Following code implements ideas described in the following sources:\n// http://yehar.com/blog/?p=1495\n// https://www.ea.com/frostbite/news/circular-separable-convolution-depth-of-field\n// NOTE: IT IS by all means NOT OPTIMAL. Its purpose is purely educational. \n// ================================================================================\n// @author: bdybisz\n// --------------------------------------------------------------------------------\n#define _RADIUS  8.0\n#define _DOF_G   0\n#define _DOF_C1  1\n#define _DOF_C2  2\n#define _DOF_C3  3\n#define _TEX_OFF 0\n#define _TEX_ON  1\n\n// --------------------------------------------------------------------------------\n// Main settings: how many components should be used and should second input \n// texture be supported. The texture is meant to be used as a focus plane so\n// one can e.g cut out (offline) part of the image that he/she wants to keep\n// in focus and support it as a separate image. Please note that custom textures\n// are only supported when one has dedicated browser plugin like this one:\n// https://github.com/andrewhills/ShadertoyCustomTextures\n#define _METHOD_USED          _DOF_C1\n#define _SECOND_TEX_SUPPORTED _TEX_OFF\n\n// --------------------------------------------------------------------------------\nvec2 complexMultiply( in vec2 a, in vec2 b )\n{\n    return vec2\n    ( \n        a.x * b.x - a.y * b.y, // Re\n        a.x * b.y + b.x * a.y  // Im\n    );\n}\n\n// --------------------------------------------------------------------------------\n// Found online. Luma trick to mimic HDR, and take advantage of 16 bit buffers \n// shader toy provides.\nvec4 fetchImage(vec2 coords, sampler2D tex)\n{\n    vec4 colorImg = texture(tex, coords);    \n    \n    float lum = dot(colorImg.rgb,vec3(0.2126,0.7152,0.0722))*1.8;\n    return colorImg * mix(1.0,lum*lum*lum,0.35);\n}\n\n// --------------------------------------------------------------------------------\n#if ( _METHOD_USED == _DOF_C1 )\n// Normalized kernel - single component.\n// It assumes that radius is 8, hence number of componenet equals 17.\n// Values generated with: https://github.com/kecho/CircularDofFilterGenerator\n// NOTE: there is an error in the script. Proper values at line 31 should be:\n//       P = [[ 1.624835, -0.862325, 0.767583, 1.862321 ]]\nconst vec2 kernel0[] = vec2[]\n(\n    //              Re                     Im\n    vec2(  0.06323194702722068    , 0.0            ),\n    vec2( \t0.06323194702722068    , 0.0             ),\n    vec2( \t0.06323194702722068    , 0.0             ),\n    vec2( \t0.06323194702722068    , 0.0             ),\n    vec2( \t0.06323194702722068    , 0.0             ),\n    vec2( \t0.06323194702722068    , 0.0             ),\n    vec2( \t0.06323194702722068    , 0.0             ),\n    vec2( \t0.06323194702722068    , 0.0             ),\n    vec2( \t0.06323194702722068    , 0.0                   ),\n    vec2( \t0.0623655802828905     , 0.0015836805455391712 ),\n    vec2( 0.06323194702722068    , 0.0              ),\n    vec2( 0.06323194702722068    , 0.0              ),\n    vec2( 0.06323194702722068    , 0.0              ),\n    vec2( 0.06323194702722068    , 0.0              ),\n    vec2( 0.06323194702722068    , 0.0              ),\n    vec2( 0.06323194702722068    , 0.0              ),\n    vec2( 0.06323194702722068    , 0.0              )\n);\n\nconst vec2 kernel0ReImWeights = vec2( 0.767583, 1.862321 );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 pixelUVSize = 1.0 / iResolution.xy;\n    \n#if ( _SECOND_TEX_SUPPORTED == 1 )\n    vec4 originalTexel = texture( iChannel1, uv );\n    if( originalTexel.a == 1.0 )\n    {\n        fragColor = originalTexel;\n        return;\n    }\n#endif\n    \n    // Completely unefficient pass.\n    vec2 complexAccR = vec2( 0.0 );\n    vec2 complexAccG = vec2( 0.0 );\n    vec2 complexAccB = vec2( 0.0 );\n    \n    // Mouse control.\n    vec2 mouseCoords = ( iMouse.xy / iResolution.xy );\n    float filterSize = 2.0 * mouseCoords.x;\n\n    for( float y = -_RADIUS; y <= _RADIUS; y++ )\n    {\n        for( float x = -_RADIUS; x <= _RADIUS; x++ )\n    \t{\n            vec2 shiftedUV = uv + filterSize * vec2( x * pixelUVSize.x, y * pixelUVSize.y );\n            vec2 kernelX = kernel0[ int( x + _RADIUS ) ]; \n        \tvec2 kernelY = kernel0[ int( y + _RADIUS ) ]; \n            vec4 samp = fetchImage( shiftedUV, iChannel0 );\n\n            complexAccR += complexMultiply( complexMultiply(vec2(samp.r,0.0f), kernelX), kernelY );\n            complexAccG += complexMultiply( complexMultiply(vec2(samp.g,0.0f), kernelX), kernelY );\n            complexAccB += complexMultiply( complexMultiply(vec2(samp.b,0.0f), kernelX), kernelY );\n        }\n    }\n        \n    // Output to screen\n    fragColor = vec4\n    (\n        dot( complexAccR, kernel0ReImWeights ), \n        dot( complexAccG, kernel0ReImWeights ), \n        dot( complexAccB, kernel0ReImWeights ), \n        1.0\n    );\n}\n#endif\n\n// --------------------------------------------------------------------------------\n","name":"Image","description":"","type":"image"}]}