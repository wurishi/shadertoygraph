{"ver":"0.1","info":{"id":"7tSGDh","date":"1623944755","viewed":466,"name":"Atmospheric Scattering - Andrew","username":"andrew741","description":"The earth and moon with realistic atmospheric scattering. Fullscreen only works if you enter it within a second of the program starting or restarting. You can look around with the mouse.","likes":14,"published":1,"flags":32,"usePreview":0,"tags":["sun","earth","space","sky","moon","scattering","bumpmapping","atmosphere","specularreflection","triplannarmapping","speculardiffusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n// stores data on specualar refleciton and diffusion\nstruct SpecularLight\n{\n    float highlight;\n    float diffuse;\n};\n\n\n// calculates the speucalar reflection and diffusion\nSpecularLight Specular(float smoothness, vec3 normal, vec3 rd, vec3 sun_dir)\n{\n    float specularAngle = acos(dot(normalize(sun_dir - rd), normal));\n    float specularExponent = specularAngle / (1. - smoothness);\n    // finding the specular highlight\n    float specularHighlight = exp(-specularExponent * specularExponent);\n    // fidning the amount of diffused light\n    float diffseLighting = clamp(dot(normal, sun_dir), 0., 1.);\n    return SpecularLight(specularHighlight, diffseLighting);\n}\n\n\n// returns the signed distance to the earth\nfloat GetDst(vec3 p)\n{\n    return length(p) - 5.;\n}\n\n\n// returns the normal based on a signed distance feild\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDst(p);\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 normal = d - vec3(\n        GetDst(p - e.xyy),\n        GetDst(p - e.yxy),\n        GetDst(p - e.yyx));\n    \n    return normalize(normal);\n}\n\n\n// from another shadertoy shader\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n// from another shadertoy shader\nvec4 noised( in vec3 x )\n{\n    // grid\n    vec3 i = floor(x);\n    vec3 w = fract(x);\n    \n    // cubic interpolant\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    \n    // gradients\n    vec3 ga = hash( i+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( i+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( i+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( i+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( i+vec3(0.0,0.0,1.0) );\n\tvec3 gf = hash( i+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( i+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( i+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolations\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\n}\n\n\n// samples 3D nosie and stores it in one channel (x aka a float)\nfloat SampleNoise(vec3 p)\n{\n    float h = noised(p).x;\n    h += noised(p*2. + 100.).x * 0.5;\n    h += noised(p*4. - 100.).x * 0.25;\n    h += noised(p*8. + 1000.).x * 0.125;\n    return h / (1.865);\n}\n\n\n// samples 3D noise and stores it in the xyz channel (a vec3)\nvec3 SampleNoiseV3(vec3 p)\n{\n    // sampling at decreasing scale and height multiple tiles and returning that amount divided by the total possible amount (to normalize it)\n    vec3 h = noised(p).xyz;\n    h += noised(p*2. + 100.).xyz * 0.5;\n    h += noised(p*4. - 100.).xyz * 0.25;\n    h += noised(p*8. + 1000.).xyz * 0.125;\n    return h * 0.536193029;\n}\n\n\n// converts a vector3 to a float while randomizing it\nfloat hash31(vec3 p)\n{\n    return fract(sin(dot(p, vec3(64.25375463, 23.27536534, 86.29678483))) * 59482.7542);\n}\n\n\n// interpates the precalculated data for the inner sphere (earth)\nDepth GetSmallSphere(vec2 uv, vec3 rd, vec3 ro)\n{\n    vec3 data = textureLod(iChannel1, uv, 0.).xyz;\n    data.xy *= 25.;\n    bool collided = false;\n    if (data.z == 1.) collided = true;\n    vec3 cp = ro + rd * data.x;\n    Depth depth = Depth(data.x, data.y, collided, cp, cp + rd * data.y);\n    return depth;\n}\n\n\n// interprates the precalculated data for the distance to the outter sphere (the outside of the atmosphere)\nDepth GetBigSphere(vec2 uv, vec3 rd, vec3 ro)\n{\n    vec3 data = textureLod(iChannel2, uv, 0.).xyz;\n    data.xy *= 25.;\n    bool collided = false;\n    if (data.z == 1.) collided = true;\n    vec3 cp = ro + rd * data.x;\n    Depth depth = Depth(data.x, data.y, collided, cp, cp + rd * data.y);\n    return depth;\n}\n\n\n// triplannar mapping https://www.youtube.com/watch?v=lctXaT9pxA0&t=1031s\nvec3 TriplannarMoonTexture(vec3 p, vec3 normal)\n{\n    // the scale of the texture\n    float scale = 0.25;\n    // the sharpness of the blending between different axises\n    float blendSharpness = 1.;\n    // finding the different axise's color\n    vec3 colX = texture(iChannel3, p.zy * scale).rgb;\n    vec3 colY = texture(iChannel3, p.xz * scale).rgb;\n    vec3 colZ = texture(iChannel3, p.xy * scale).rgb;\n    \n    // finding the blending amount for each axis\n    vec3 bw = pow(abs(normal), vec3(blendSharpness));\n    // making it so the total (x + y + z) is 1\n    bw /= dot(bw, vec3(1.));\n    \n    // finding the final color\n    return colX * bw.x + colY * bw.y + colZ * bw.z;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // the uv and normalized mouse coordiante\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    // the mouse direction (changes the veiw direction)\n    if (iMouse.z < 0. || iMouse.xy == vec2(0))\n    {\n        m = vec2(sin(iTime) * 0.5 + 0.5, cos(iTime) * 0.25 + 0.75);\n    }\n    \n    // the direction and color of the sun\n    vec3 sun_col = vec3(1., 0.95, 0.6);\n    //vec3 sun_dir = normalize(vec3(sin(iTime), 0.75, cos(iTime)));\n    vec3 sun_dir = normalize(vec3(0., 0.75, -1.));\n    \n    // getting ray direction and position\n    vec3 ro = vec3(0, 1, -1) * 10.;\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    \n    // the texture coordinate for buffer channels\n    vec2 nuv = fragCoord.xy / iResolution.xy;\n    \n    vec3 col = vec3(0., 0., 0.);\n    // checking for collition with earth and the moon\n    Depth depth = GetSmallSphere(nuv, rd, ro);//GetDepth(ro, rd, 5.);\n    Ray moon = MarchMoon(rd, ro, iTime, vec3(sin(iTime) * 10.5, sin(iTime) * 0.5, cos(iTime) * 11.25));\n    // checking if there is any object in the way of the empty void\n    if (depth.collided || moon.collided)\n    {\n        vec3 oc;\n        if (moon.collided && moon.dst < depth.toSphere)\n        {\n            vec3 object_coord = moon.collideP - vec3(sin(iTime) * 10.5, sin(iTime) * 0.5, cos(iTime) * 11.25);  // returns a coord in object space to avoid issus with texture moving when moon moves\n            // noise for moon texture (like bumpyness)\n            vec3 moon_noise = SampleNoiseV3(object_coord * 10.);\n            // bump mapping (probably not the correct method but works perfectly for this)\n            vec3 sphere_normal = normalize(moon.normal + moon.normal * (moon_noise * 0.2 + 0.2));\n            // triplannar mapping for the moon texture for both color and bumpiness\n            vec3 texture_col = TriplannarMoonTexture(object_coord, moon.normal);\n            // second bump mapping (probably not the correct method but works perfectly for this)\n            sphere_normal = normalize(sphere_normal + sphere_normal * (texture_col * 600.));\n            //sphere_normal = normalize(sphere_normal + sphere_normal * vec3(crater.x * 2400.));\n            // finding color (and adding things like specular reflection, and other shading)\n            oc = texture_col * 0.5 + 0.5;\n            oc *= max(dot(sun_dir, sphere_normal), 0.);\n            // finding the amount of specualr reflection and diffusion\n            SpecularLight spec = Specular(0.85, sphere_normal, rd, sun_dir);\n            col *= spec.diffuse;\n            oc += sun_col * spec.highlight;\n            Depth bs = GetBigSphere(nuv, rd, ro);\n            // checking for collition with the atmosphere\n            if (bs.collided && bs.toSphere < moon.dst)\n            {\n                // adding the atmosphere ontop of the moon\n                vec4 scattering = textureLod(iChannel0, fragCoord.xy / iResolution.xy, 0.);\n                oc = oc * scattering.a + scattering.rgb;\n            }\n        }\n        else\n        {\n            // finding the noise representing the oceans and bumpiness\n            vec3 land_noise = SampleNoiseV3(depth.collidePIn * 0.4);\n            // getting the spheres normal\n            vec3 sphere_normal = GetNormal(depth.collidePIn);\n            // bump mappping (probably not the correct method but works perfectly for this)\n            sphere_normal = normalize(sphere_normal + sphere_normal * (land_noise * 0.25 + 0.25));\n            // finding the surface material (water or land/grass)\n            float surf_mat = pow(land_noise.x * 0.5 + 0.85, 6.);\n            // finding color (and adding things like specular reflection, and other shading)\n            oc = mix(vec3(0.2, 0.2, 0.8), vec3(0.2, 0.8, 0.2), surf_mat);\n            oc *= max(dot(sun_dir, sphere_normal), 0.);\n            SpecularLight spec = Specular(mix(0.65, 0.95, pow(surf_mat, 2.)), sphere_normal, rd, sun_dir);\n            col *= spec.diffuse;\n            oc += sun_col * spec.highlight;\n            // adding the atmosphere onto the earth\n            vec4 scattering = textureLod(iChannel0, nuv, 0.);\n            oc = oc * scattering.a + scattering.rgb;\n            oc = oc;\n        }\n        col = oc;\n    }\n    else\n    {\n        // finding the distance to the outer atmospher shell (for the atmospheric scattering)\n        Depth bs = GetBigSphere(fragCoord.xy / iResolution.xy, rd, ro);\n        // finding the intensity of the sun\n        float sun_int = pow(max(dot(rd, sun_dir), 0.), 280. + (smoothstep(0., 1., SampleNoise(vec3(rd.xy, iTime * 0.1) * 30.) * 0.5 + 0.5)) * 100.);\n        // adding the sun\n        // adding stars\n        float star = hash31(floor(rd * 150.) / 150.);\n        float star_power = pow(star * (1. - sun_int), 600.) * (1. - pow(smoothstep(0., 1., SampleNoise(rd * 24. + iTime * 2.) * 0.5 + 0.5), 2.));\n        col += star_power;\n        vec4 scattering = textureLod(iChannel0, nuv, 0.);\n        // checking if the view ray passes through the atmosphere\n        if (bs.collided)\n        {\n            // adding the atmosphere ontop of the sky based on the objet color transmittance (stored in the alpha channel)\n            col = col * scattering.a + scattering.rgb;\n        }\n        col = mix(col, sun_col + scattering.rgb, sun_int);\n    }\n    \n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    col =  clamp((col*(a*col+b))/(col*(c*col+d)+e), 0., 1.);\n    //col = smoothstep(0., 1., col);\n\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// small sphere\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame < 60)\n    {\n        vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n        vec2 m = iMouse.xy / iResolution.xy;\n        if (iMouse.z < 0. || iMouse.xy == vec2(0))\n        {\n            m = vec2(sin(iTime) * 0.5 + 0.5, cos(iTime) * 0.25 + 0.75);\n        }\n\n        vec3 sun_col = vec3(1., 0.95, 0.6);\n        vec3 sun_dir = normalize(vec3(0.2, 0.75, 1.));\n\n        vec3 ro = vec3(0, 1, -1) * 10.;\n        ro.yz *= Rot(-m.y*3.14+1.);\n        ro.xz *= Rot(-m.x*6.2831);\n        vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n        \n        Depth depth = GetDepth(ro, rd, 5.);\n        // calculate\n        fragColor = vec4(depth.toSphere / 25., depth.throughSphere / 25., depth.collided ? 1. : 0., 0.);\n    }\n    else\n    {\n        fragColor = textureLod(iChannel1, fragCoord.xy / iResolution.xy, 0.);\n    }\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4df3Rn","filepath":"/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","previewfilepath":"/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n// big sphere\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame < 60)\n    {\n        vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n        vec2 m = iMouse.xy / iResolution.xy;\n        if (iMouse.z < 0. || iMouse.xy == vec2(0))\n        {\n            m = vec2(sin(iTime) * 0.5 + 0.5, cos(iTime) * 0.25 + 0.75);\n        }\n\n        vec3 sun_col = vec3(1., 0.95, 0.6);\n        vec3 sun_dir = normalize(vec3(0.2, 0.75, 1.));\n\n        vec3 ro = vec3(0, 1, -1) * 10.;\n        ro.yz *= Rot(-m.y*3.14+1.);\n        ro.xz *= Rot(-m.x*6.2831);\n        vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n        \n        Depth depth = GetDepth(ro, rd, 10.);\n        // calculate\n        fragColor = vec4(depth.toSphere / 25., depth.throughSphere / 25., depth.collided ? 1. : 0., 0.);\n    }\n    else\n    {\n        fragColor = textureLod(iChannel2, fragCoord.xy / iResolution.xy, 0.);\n    }\n}\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n\n// from https://www.shadertoy.com/view/WtGXDD\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// from https://www.shadertoy.com/view/WtGXDD\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\n// stores data on the collition with a sphere (earth and the outter atmosphere)\nstruct Depth\n{\n    float toSphere;\n    float throughSphere;\n    bool collided;\n    vec3 collidePIn;\n    vec3 collidePOut;\n};\n\n\n// stores data on a ray (for ray marching the moon)\nstruct Ray\n{\n    bool collided;\n    float dst;\n    vec3 collideP;\n    vec3 normal;\n};\n\n\n// returns the signed distance to the moon\nfloat GetDst(vec3 p, float iTime)\n{\n    return length(p - vec3(sin(iTime) * 10.5, sin(iTime) * 0.5, cos(iTime) * 11.25)) - 1.;\n}\n\n\n// ray marches the moon (distance, if it collided, normal, and collition position)\nRay MarchMoon(vec3 rd, vec3 ro, float iTime, vec3 center)\n{\n    vec3 p = ro;\n    float dfs = 0.;\n    bool collided = false;\n    // 50 steps (spheres arnt to complicated and dont need to many steps)\n    for (int s = 0; s < 10; s++)\n    {\n        float dst = length(p - center) - 1.;\n        p += rd * dst;\n        dfs += dst;\n        \n        // a persition of 0.01\n        if (dst < 0.1)\n        {\n            collided = true;\n            break;\n        }\n        // stopping if the ray is far from the moon (farther then the moon will ever be from the camera)\n        else if (dfs > 25.) break;\n    }\n    float d = GetDst(p, iTime);\n    vec2 e = vec2(0.01, 0);\n    \n    // gets the normal of the moon\n    vec3 normal = d - vec3(\n        GetDst(p - e.xyy, iTime),\n        GetDst(p - e.yxy, iTime),\n        GetDst(p - e.yyx, iTime));\n    \n    // returns the foud data\n    vec3 norm = normalize(normal);\n    Ray ray = Ray(collided, dfs, p, norm);\n    return ray;\n}\n\n\n// returns data on the collition with a centered sphere (earth and the outter atmosphere)\nDepth GetDepth(vec3 p_, vec3 rd, float r)\n{\n    vec3 p = p_;\n    float depth = 0.;\n    bool collided = false;\n    // ray marching the outside very persisely\n    for (int s = 0; s < 340; s++)\n    {\n        float dst = length(p) - r;\n        p += rd * dst;\n        depth += dst;\n        if (dst < 0.001) collided = true;\n    }\n    \n    float depth2 = 0.;\n    vec3 p2 = p + rd * 0.01;\n    // ray marching the inside very persisely\n    for (int s = 0; s < 340; s++)\n    {\n        // inverting (0 - distance) the singed distance to make the inside hollow and the outside solid\n        float dst = -(length(p2) - r);\n        depth2 += dst;\n        p2 += rd * dst;\n    }\n    \n    // returning the gathered data\n    return Depth(depth, depth2, collided, p, p2);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n// the density at a given point in the atmosphere\nfloat GetDensity(float dstToPlannet)\n{\n    float density_fall_off = 6.;  // the falloff speed for the atmospheric density\n    float h = dstToPlannet * 0.2;  // normalizeing the distance to the plannet based on the difference between the raidius of the atmosphere and the plannet\n    float density = exp(-h * density_fall_off) * (1. - h);\n    return density;\n}\n\n\n// interpates the precalculated data for the inner sphere (earth)\nDepth GetSmallSphere(vec2 uv, vec3 rd, vec3 ro)\n{\n    vec3 data = textureLod(iChannel1, uv, 0.).xyz;\n    data.xy *= 25.;\n    bool collided = false;\n    if (data.z == 1.) collided = true;\n    vec3 cp = ro + rd * data.x;\n    Depth depth = Depth(data.x, data.y, collided, cp, vec3(0.));\n    return depth;\n}\n\n\n// interprates the precalculated data for the distance to the outter sphere (the outside of the atmosphere)\nDepth GetBigSphere(vec2 uv, vec3 rd, vec3 ro)\n{\n    vec3 data = textureLod(iChannel2, uv, 0.).xyz;\n    data.xy *= 25.;\n    bool collided = false;\n    if (data.z == 1.) collided = true;\n    vec3 cp = ro + rd * data.x;\n    Depth depth = Depth(data.x, data.y, collided, cp, cp + rd * data.y);\n    return depth;\n}\n\n\n// gets the optical depth based on the ray direction, length, and position\nfloat opticalDepth(vec3 ro, vec3 rd, float rl)\n{\n    vec3 p = ro;\n    float step_size = rl * 0.0909090909;  // 10 is the number of sample points\n    vec3 v3_step_size = rd * step_size;\n    float odepth = 0.;\n    float ldense;\n    for (int s = 0; s < 10; s++)\n    {\n        p += v3_step_size;\n        ldense = GetDensity(length(p) - 5.);\n        odepth += ldense * step_size;\n    }\n    return odepth;\n}\n\n\n// uses ray marching to find the distance through the plannet (for a given position and direction)\nfloat raySphere(vec3 ro, vec3 rd)\n{\n    float lp;\n    float dst;\n    vec3 p = ro;\n    float dfs = 0.;\n    for (int s = 0; s < 80; s++)\n    {\n        dst = -(length(p) - 10.);\n        \n        if (dst < 0.01) break;\n        dfs += dst;\n        p += rd * dst;\n    }\n    return dfs;\n}\n\n\n// triplannar mapping https://www.youtube.com/watch?v=lctXaT9pxA0&t=1031s\nvec3 blueNoise(vec3 p, vec3 normal)\n{\n    // the scale of the texture\n    float scale = 0.25;\n    // the sharpness of the blending between different axises\n    float blendSharpness = 1.;\n    // finding the different axise's color\n    vec3 colX = texture(iChannel0, p.zy * scale).rgb;\n    vec3 colY = texture(iChannel0, p.xz * scale).rgb;\n    vec3 colZ = texture(iChannel0, p.xy * scale).rgb;\n    \n    // finding the blending amount for each axis\n    vec3 bw = pow(abs(normal), vec3(blendSharpness));\n    // making it so the total (x + y + z) is 1\n    bw /= dot(bw, vec3(1.));\n    \n    // finding the final color\n    return colX * bw.x + colY * bw.y + colZ * bw.z;\n}\n\n\n// finding the scattering coefficents based on the wave lengths of different light colors\nvec3 scatteringCoefficents = pow(vec3(400.) / vec3(700, 530, 440), vec3(4.)) * 2.;  // the coefficents for the scattering of different wave lengths/colors of light\n\n\n// total density for when looking through plannet (for atmosphere)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    // the mouse direction (changes the veiw direction)\n    if (iMouse.z < 0. || iMouse.xy == vec2(0))\n    {\n        m = vec2(sin(iTime) * 0.4 + 0.5, cos(iTime) * 0.4 + 0.5);\n    }\n    \n    // the sun's color and dierection\n    vec3 sun_col = vec3(1., 0.95, 0.6);\n    //vec3 sun_dir = normalize(vec3(sin(iTime), 0.75, cos(iTime)));\n    vec3 sun_dir = normalize(vec3(0., 0.75, -1.));\n    \n    // getting ray direction and position\n    vec3 ro = vec3(0, 1, -1) * 10.;\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    \n    // finding the data on the plannet\n    vec2 nuv = fragCoord.xy / iResolution.xy;\n    Depth bs = GetBigSphere(nuv, rd, ro);\n    Depth ss = GetSmallSphere(nuv, rd, ro);\n    \n    vec3 col = vec3(0., 0., 0.);\n    \n    // checking if an atmosphere should be rendered\n    if (bs.collided)\n    {\n        // finding where the ray enters and exits/collides (with the plannet)\n        vec3 enter = bs.collidePIn;\n        vec3 exit = ss.collided ? ss.collidePIn : bs.collidePOut;\n        \n        float density;\n        vec3 p = enter;\n        float sun_length;\n        vec3 transmittance;\n        float sunRayOpticalDepth;\n        float veiwRayOpticalDepth;\n        vec3 inScatteredLight = vec3(0.);\n        // finding the step size\n        vec3 step_size = (exit - enter) / 31.;\n        float step_size_f = length(step_size);\n        vec3 mp = vec3(sin(iTime) * 10.5, sin(iTime) * 0.5, cos(iTime) * 11.25);  // moon pos\n        // taking 25 sample points on the rays path\n        for (int s = 0; s < 30; s++)\n        {\n            // moving the ray\n            p += step_size;\n            // finding the distance through the atmosphere in the direction of the sun\n            sun_length = raySphere(p, sun_dir);\n            // finding the optical depth for the view ray and sun ray\n            //Ray moon = MarchMoon(sun_dir, p, iTime, mp);\n            sunRayOpticalDepth = opticalDepth(p, sun_dir, sun_length);  // * (moon.collided ? 5. : 1.);\n            veiwRayOpticalDepth = opticalDepth(p, -rd, step_size_f * float(s));\n            // finding the transmittance\n            transmittance = exp(-(sunRayOpticalDepth + veiwRayOpticalDepth) * scatteringCoefficents);\n            density = GetDensity(length(p) - 5.);\n            \n            // finding the amount of addition light\n            inScatteredLight += density * transmittance * scatteringCoefficents * step_size_f;\n        }\n        float vod = exp(-veiwRayOpticalDepth);\n        col = inScatteredLight;\n        // saving the output to be used in the final render (and finding the amount of origonal color that made it through for blending the atmosphere with the other objects in the scene)\n        fragColor = vec4(col + vec3(blueNoise(rd * 5., rd).r * (1. - vod) * pow(1. - max(col.r, max(col.g, col.b)), 4.)) * 0.05, vod);\n    }\n}\n\n","name":"Buffer C","description":"","type":"buffer"}]}