{"ver":"0.1","info":{"id":"ml3cDX","date":"1699741991","viewed":143,"name":"Half-Life 2 Quick HUD Crosshair","username":"Uriah","description":"This is a recreation of the quick HUD crosshair from Half-Life 2 and episodes.\n\nThere's a group of #define that you can use to change the parameters.\nTry clicking and moving your mouse around!\n\nWarning! The code is a little messy!","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["procedural","valve","halflife","halflife","crosshair","health","ammo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright © 2023 Kyle W\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Recreation of the Half-Life 2 quick HUD crosshair!\n\n\n\n\n/*\n    These were used within the VSCode Shadertoy extension for input.\n    Shadertoy itself doesn't have a separate input section, so we must utilize another buffer shader for that.\n*/ \n/*\n#iUniform float dummy = 0.0\n#iUniform float dummy2 = 0.0\n#iUniform int EnableGrid = 0 in {0, 1} step 1\n#iUniform float Health = 0.0 in {0.0, 1.0}\n#iUniform float Ammo = 0.0 in {0.0, 1.0}\n#iUniform float ArcAngle = 90.0 in {0.0001, 90.0}\n#iUniform float InnerThickness = 16.0 in {0.0, 128.0}\n#iUniform float InnerSmoothness = 1.0 in {0.0, 16.0}\n#iUniform float OutlineDistance = 4.0 in {0.0, 128.0}\n#iUniform float OutlineThickness = 5.0 in {0.0, 128.0}\n#iUniform float OutlineSmoothness = 1.0 in {0.0, 16.0}\n#iUniform float CrosshairScale = 1.0 in {0.0, 16.0}\n#iUniform float HorizontalOffset = 0.0 in {-256.0, 512.0} step 1.0\n// #iUniform color3 WarningColor = vec3(0.8, 0.1, 0.1)\n*/\n\n// Health and Ammo values are currently disabled to use the mouse instead.\n// Try dragging your mouse up and down on the respective side!\n#define Health            1.0\n#define Ammo              1.0\n#define ArcAngle          60.0 // 45°-60° looks the best.\n#define InnerThickness    28.0\n#define InnerSmoothness   0.0 // Currently not functional.\n#define OutlineDistance   20.0\n#define OutlineThickness  4.0\n#define OutlineSmoothness 0.0 // No smoothing for the most crisp edges!\n#define CrosshairScale    1.0\n#define HorizontalOffset  0.0 // Try 128.0!\n\n#define HealthWarnRatio   0.3\n#define AmmoWarnRatio     0.3\n\n#define WarnFrequency     10.0\n\n// The grid is a little funky. I need to redo it.\n#define EnableGrid        0\n\n\n#define InputBuffer iChannel0\n\n/** Constants **/\n\nconst float PI = 3.1415926;\nconst float RASTER_SCALE = 1024.0; // The scale that all the units work off of throughout this shader.\n\n// Colors\nconst vec3 WHITE  = vec3(1.0, 1.0, 1.0);\nconst vec3 BLACK  = vec3(0.0, 0.0, 0.0);\nconst vec3 ORANGE = vec3(1.0, 0.8, 0.4);\nconst vec3 RED \t  = vec3(0.8, 0.1, 0.1);\n\n/** Utility Functions **/\n\n// Degrees to Radians\nfloat d2r(float d) {\n    return d * (PI / 180.0f);\n}\n\n// Radians to Degrees\nfloat r2d(float r) {\n    return r * (180.0f / PI);\n}\n\n\n/** SDF Functions */\n\n/**\n * Outline of SDF with specified Radius.\n * @param d float The SDF.\n * @param r float The radius of the outline.\n * @returns float The SDF distance to the outline.\n */\nfloat sdOutline(float d, float r) {\n    return abs(d) - r;\n}\n\n\n/**\n * SDF Arc.\n * @param p vec2 Fragment position.\n * @param sc vec2 The sin/cos of the aperture. Effectively the angle of the Arc.\n * @param ra float The Radius of the Arc's circle.\n * @param rb float The Thickness of the Arc?\n * @param aa float The angle of the Arc\n * @returns float The SDF distance to the Arc.\n */\nfloat sdArc(in vec2 p, in vec2 sc, in float ra, float rb, float aa)\n{\n    // p.x = abs(p.x);\n    // return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n    // \t\t\t\t\t\t\t  abs(length(p)-ra)) - rb;\n    // Rotate the point\n    vec2 rotatedP = vec2(\n        p.x * cos(aa) - p.y * sin(aa),\n        p.x * sin(aa) + p.y * cos(aa)\n    );\n\n    rotatedP.x = abs(rotatedP.x);\n\n    return ((sc.y * rotatedP.x > sc.x * rotatedP.y) ? length(rotatedP - sc * ra) : abs(length(rotatedP) - ra)) - rb;\n}\n\nfloat sdGrid(in vec2 position, in float margin)\n{\n    // Calculate per-axis distance from 0.5 to position mod 1\n    vec2 gridDist = abs(fract(position) - 0.5) - margin;\n    \n    // Calculate length for round outer corners, ripped from Inigo Quilez\n    float outsideDist = length(max(gridDist, 0.0));\n    // Calculate inside separately, ripped from Inigo Quilez\n    float insideDist = min(max(gridDist.x, gridDist.y), 0.0);\n    \n    return outsideDist + insideDist;\n}\n\n/**\n * Fill the SDF with a solid color.\n * @param d float The SDF.\n * @param r float The radius of the fill.\n * @param sm float The smoothing of the fill.\n * @returns float The SDF distance to the fill.\n */\nfloat sdFill(float d, float r, float sm) {\n    sm += fwidth(d);\n    return smoothstep(r - (sm*.5), r + sm, d);\n}\n\nfloat sdCross( in vec2 p, in vec2 b, float r ) \n{\n    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n    vec2  q = p - b;\n    float k = max(q.y,q.x);\n    vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n    return sign(k)*length(max(w,0.0)) + r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCrosshair(in vec2 p, in float size) {\n    // Offset to fix aliasing\n    p += 1.0;\n    vec2 scale = vec2(1.0) * fwidth(p);\n    float horz = 24.0 * size;\n    float vert = 16.0 * size;\n    // float d = sdCross(p, vec2(0.02, 0.0020), 0.01);\n\n    float d = \n        min( sdBox(p, scale), /* Center */\n        min( sdBox(p - vec2(horz, 0.0), scale), /* Left */\n        min( sdBox(p - vec2(-horz, 0.0), scale), /* Right */\n        min( sdBox(p - vec2(0.0, -vert), scale), /* Top */\n             sdBox(p - vec2(0.0, vert), scale) /* Bottom */\n        ))));\n\n    return d;\n}\n\n\nfloat left(vec2 p, in float perc, in float thickness) {\n    // Offset the arc\n    vec2 p_of = vec2(HorizontalOffset, 0.0);\n    p += p_of;\n\n    float arc_angle = ArcAngle;\n    float rotation = d2r(-90.0 - arc_angle);\n\n    float ang = perc * d2r(arc_angle);\n    vec2  sc = vec2(sin(ang), cos(ang));\n    float ra = 512.0;\n    float rb = thickness;\n\n    float aa = ang + rotation;\n    float dil = sdArc(p, sc, ra, rb, aa); // SDF of inner arc\n\n    ang = d2r(arc_angle);\n    sc = vec2(sin(ang), cos(ang));\n    aa = ang + rotation;\n    float dO = sdArc(p, sc, ra, rb+OutlineDistance, aa); // SDF of outer arc\n    float dol = sdOutline(dO, OutlineThickness); // SDF of outline of outer arc\n\n    float border = fwidth(dol);\n\n    float d = 1.0 - sdFill(dil, 1.0, 0.001); // Rasterize inner arc\n    float r = 1.0 - sdFill(dol, border - OutlineSmoothness, border + OutlineSmoothness); // Rasterize outer arc\n\n    return max(d, r);\n}\n\nfloat right(vec2 p, in float perc, in float thickness) {\n    // Mirror across the Y axis so the arc moves in the correct direction.\n    p.x = -p.x;\n    vec2 p_of = vec2(HorizontalOffset, 0.0); // Position offset of the arc.\n    p += p_of;\n    // To rotate the arc, we need to rotate about the center of the arc by some angle.\n    // Then, apply the transformation.\n\n    float arc_angle = ArcAngle;\n    float rotation = d2r(-90.0 - arc_angle);\n\n    float ang = perc * d2r(arc_angle);\n    vec2  sc = vec2(sin(ang), cos(ang));\n    float ra = 512.0; // 0.5\n    float rb = thickness;\n\n    float aa = ang + rotation;\n    float dil = sdArc(p, sc, ra, rb, aa); // SDF of inner arc\n\n    ang = d2r(arc_angle);\n    sc = vec2(sin(ang), cos(ang));\n    aa = ang + rotation;\n    float dO = sdArc(p, sc, ra, rb+OutlineDistance, aa); // SDF of outer arc\n    float dol = sdOutline(dO, OutlineThickness); // SDF of outline of outer arc\n\n    float border = fwidth(dol);\n\n    float d = 1.0 - sdFill(dil, 1.0, 0.001); // Rasterize inner arc\n    float r = 1.0 - sdFill(dol, border - OutlineSmoothness, border + OutlineSmoothness); // Rasterize outer arc\n\n    return max(d, r);\n}\n\nvec3 sdRingFrom(float sdf, float dist, float radius)\n{\n    const vec3 innerColor = WHITE;\n    const vec3 outerColor = BLACK;\n\n    float border = fwidth(sdf);  // Use fwidth to ensure smooth transitions\n\n    // Smoothstep function to create a smooth transition between innerColor and outerColor\n    float ring = smoothstep(radius - border, radius + border, sdf);\n\n    // Mix the innerColor and outerColor based on the smoothstep result\n    vec3 col = mix(innerColor, outerColor, ring);\n\n    return col;\n}\n\n\nvec3 ColorizeSDF(float d)\n{\n    vec3 col = (d>0.0) ? vec3(0.9, 0.6, 0.3) : vec3(0.65, 0.85, 1.0);\n    col *= 1.0 - exp(-6.0*abs(d));\n    col *= 0.8 + 0.2*cos(150.0*d);\n    col = mix(col, vec3(1.0), 1.0-smoothstep(0.0, 0.01, abs(d)));\n\n    return col;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // normalized pixel coordinates\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    // Normalized mouse coordinates\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    // This creates base resolution to work with for all the units.\n    uv *= RASTER_SCALE;\n    \n    // Now use the mouse as the Health and Ammo variables in their respective side of the screens\n    vec4 left_input = ReadColumn(InputBuffer, 0, iResolution);\n    vec4 right_input = ReadColumn(InputBuffer, 1, iResolution);\n    // Left side value\n    float lsv = left_input.x;\n    // Right side value\n    float rsv = right_input.x;\n    \n    // Left side SDF\n    float dl = left(uv, lsv, InnerThickness);\n    // Right side SDF\n    float dr = right(uv, rsv, InnerThickness);\n\n    vec3 lcol = vec3(dl);\n    vec3 rcol = vec3(dr);\n\n    // Take the final rasterized sdf and apply a color to it based on a threshold (Health < 0.2)\n    float wt = (sin(iTime*WarnFrequency)*.5+1.0); // 10.0 is the frequency of the warning flash\n    vec3 warn = wt * RED; // the warning flash when low\n\n    // Health transition value\n    float htr = step(lsv, HealthWarnRatio); // transition from white to red\n    lcol *= mix(ORANGE, warn, htr);\n    \n    // Ammo transition value\n    float atr = step(rsv, AmmoWarnRatio); // transition from white to red\n    rcol *= mix(ORANGE, warn, atr);\n\n    // Blend the two sides together\n    vec3 col = lcol + rcol;\n\n    if (EnableGrid==1) {\n        // Create a grid. Multiply the UV by a subdivision factor.\n        // Because the UV is scaled, the scalar here has to be really tiny.\n        float gs = sdGrid(uv/(RASTER_SCALE) * 2.0, 0.496);\n        gs = smoothstep(0.0, 0.001, gs);\n\n        // Mix the grid on top of everything else.\n        col = mix(col, WHITE, gs);\n    }\n\n    float t = sin(iTime)*.5+.5;\n\n    // Crosshair SDF\n    float dc = sdCrosshair( uv, 1.0 + CrosshairScale );\n    col += vec3( smoothstep(0.001, 0.0, dc) );\n    \n    // Uncomment to see the input control columns.\n    // col += texture(iChannel0, uv).rgb;\n\n    fragColor = vec4(col, 1.0);\n}\n\n\n\n\n\n\n\n\n\n/*\n    TO DO:\n    - Clean up the general layout of the code.\n    - Implement increasing warning frequency based on how close to 0 the value is. (upper freq, lower freq)\n    - Implement input for changing the crosshair size.\n    - Fix the grid.\n    - Add document comments to the rest of the functions and some of the math operations.\n      A pet-peeve of mine is when developers don't give doc comments, especially for shaders!\n    - Figure out what I broke with the smoothing. Not that anything besides 0 will want to be used anyways.\n    - Modify the SDF Arc to allow for an oblong shape.\n      This will allow for a higher arc angle, but the ability to make them taller or wider.\n*/","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define NUM_COLUMNS 2\n#define buffer iChannel0\n\nvec4 MouseNormal()\n{\n    vec2 m = iMouse.xy / iResolution.xy;\n   \n    return vec4(m.xy, iMouse.z, iMouse.w);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 m = MouseNormal();\n    \n    // The reading of the mouse should come from 0.1 to 0.9 as 0.0-1.0 to make it easier to use.\n    m.y = clamp(\n        (m.y - 0.1)/0.8,\n    0.0, 1.0);\n    \n    // Read the current buffer as to not overwrite it.\n    vec4 col = texture(buffer, uv);\n    \n    float columnWidth = iResolution.x / float(NUM_COLUMNS);\n    float columnIndex = floor(gl_FragCoord.x / columnWidth);\n\n    // Check if the mouse is inside the column\n    if (abs(gl_FragCoord.x - columnIndex * columnWidth) < columnWidth) {\n        // Check for mouse click (left button)\n        if (iMouse.z > 0.0 && iMouse.x >= columnIndex * columnWidth && iMouse.x < (columnIndex + 1.0) * columnWidth) {\n            col.rgb = m.yyy;\n        }\n    }\n    \n    // We want to default the color to 1.0 if the user hasn't interacted with their mouse yet!\n    float t = step(m.x, 0.0);\n    col = mix(col, vec4(1.0), t);\n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/**\n * Reads from a buffer from a specific column. Left to Right.\n * This is used to utilize input from another buffer into this shader.\n */\n\n#define NUM_COLUMNS 2\n\nvec4 ReadColumn(in sampler2D buffer, in int columnIndex, vec3 resolution) {\n    float columnWidth = resolution.x / float(NUM_COLUMNS);\n    vec4 value = texture(buffer, vec2(float(columnIndex) / float(NUM_COLUMNS), 0.5));\n    return value;\n}","name":"Common","description":"","type":"common"}]}