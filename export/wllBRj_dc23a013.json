{"ver":"0.1","info":{"id":"wllBRj","date":"1597206419","viewed":244,"name":"minimal raymarched volume fog","username":"snerp","description":"prototyping for floppy cat adventures","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fog"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// MIT license\n\nconst float quality = 10.0;\nconst float near = 5.0;\nconst float far = 90.0;\n#define use_noise 1\n#define wigglyness (4.0 * (1.0 + sin(iTime)))\n\nconst float insideOffset = 1.0 / quality;\nconst float fallofDist = 20.0;\nconst float opac = 1.0/ fallofDist;\nconst float fogFraction = opac * insideOffset;\n\nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise(vec3 x ){\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\nfloat cnoise(vec3 x) {\n    float f = noise(x);\n    vec3 q = 8.0*x;\n    f  = 0.5000*noise( q ); q = m*q*4.0;\n    f += 0.1750*noise( q ); q = m*q*4.0;\n    return f;\n}\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p)-s;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat map(vec3 pos ) {\n    float res = far;\n\n    res = min(res, sdSphere(pos-vec3(-20.0,0.25, 0.0), 10.25));    \n    res = min(res, sdSphere(pos-vec3(-2.0,0.25, 0.0), 0.3+2.25 * (1.0+sin(iTime))));\n\tres = min(res, sdBox(pos-vec3( 1.0+15.0*cos(-iTime),0.25, 0.0), vec3(1.3,1.25,13.5)));    \n    res = min(res, sdBox(pos-vec3( 20.0,0.25, 0.0), vec3(10.3,10.25,10.1)));\n\n    #if use_noise == 1\n    res += wigglyness * cnoise(0.1 * pos);\n    #endif\n    \n    return res;        \n}\n\nfloat raycast(vec3 campos, vec3 rd) {\n    float r = 0.0;    \n    float t = near;\n    for(int i = 0; i < 600; i++) {\n        float dist = map(campos+rd*t);\n        if(dist <= 0.01) { \n            r += fogFraction;\n            t += insideOffset;\n        } else {\n            t += dist;\n        }\n        if (t>far || r >= 1.0) {\n         break;   \n        }\n    }   \n    return r;\n}\n\nvec3 skycol = vec3(0.6,0.8,1.2);\nvec3 groundcol = vec3(0.1, 0.01, 0.0);\nvec3 fogcol = vec3(0.1, 0.3, 0.1);\nvec3 render(vec3 campos, vec3 ray) { \n\treturn mix(mix(skycol, groundcol, clamp(1.0 - 4.0 * ray.y, 0.0, 1.0)), fogcol, raycast(campos,ray));\n}\n\nmat3 setCamera(vec3 ro, vec3 ta, float cr ){\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0 + iTime*1.5;\n    // camera\t\n    vec3 ta = vec3( 0.5, -1.5, -0.6 );\n    vec3 ro = ta + vec3( 8.5*cos(0.1*time + 7.0*mo.x), -0.3 + 2.0*mo.y, 8.5*sin(0.05*time + 7.0*mo.x) );\n\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 ); \n    ro *= 4.0;\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    // ray direction\n    vec3 rd = ca * normalize(vec3(p,1.5));\n    \n    fragColor = vec4(pow(render(ro, rd), vec3(.4545)), 1.0);\n}","name":"Image","description":"","type":"image"}]}