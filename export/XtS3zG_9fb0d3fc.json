{"ver":"0.1","info":{"id":"XtS3zG","date":"1429785425","viewed":136,"name":"Test-shader","username":"FlorianDuf","description":"Created as part of my course-work.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["procedural","lave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// ---------------------------------------------------------------------------------------------\n// ---------------------------------------------------------------------------------------------\n// ---------------------------------------------------------------------------------------------\n\n// Noise ------------------------------------------------------------\n\n\n// hash simple avec un seed = 43758.5453123\n// n : le float a hasher\n// return un nombre hashÃ©\nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\n\n// hash simple\n// n : le float a hasher\n// seed : la graine d'alÃ©atoire\n// return un nombre hashÃ©\nfloat hash( float n, float seed ) { return fract(sin(n)*seed); }\n\n// gÃ©nÃ©ration d'un bruit (point par point)\n// x est la position du point sur le bruit\n// return : la valeur du piont dans le bruit\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n// gÃ©nÃ©ration d'un bruit (point par point)\n// x est la position du point sur le bruit\n// seed : la graine d'alÃ©atoire\n// return : la valeur du piont dans le bruit\nfloat noise(in vec3 x, in float seed) {\n    \n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0, seed), hash(n+  1.0, seed),f.x),\n                   mix( hash(n+157.0, seed), hash(n+158.0, seed),f.x),f.y),\n               mix(mix( hash(n+113.0, seed), hash(n+114.0, seed),f.x),\n                   mix( hash(n+270.0, seed), hash(n+271.0, seed),f.x),f.y),f.z);\n}\n\n\n// Noise adoucit ------------------------------------------------------------\n\n\n// matrice : filtre pour le flou\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\n// gÃ©nÃ©ration d'un bruit doux\n// p est la position du point sur le bruit\n// return : la valeur du point dans le bruit adoucit\nfloat smooth_noise(vec3 p) {\n\n    float v;\n    vec3 q = 8.0*p;\n    v  = 0.5000*noise( q ); q = m*q*2.01;\n    v += 0.2500*noise( q ); q = m*q*2.02;\n    v += 0.1250*noise( q ); q = m*q*2.03;\n    v += 0.0625*noise( q ); q = m*q*2.01;\n\n    return v;\n}\n\n// gÃ©nÃ©ration d'un bruit doux\n// p est la position du point sur le bruit\n// seed : la graine d'alÃ©atoire\n// return : la valeur du piont dans le bruit adoucit\nfloat smooth_noise(vec3 p, in float seed) {\n\n    float v;\n    vec3 q = 8.0*p;\n    v  = 0.5000*noise( q , seed); q = m*q*2.01;\n    v += 0.2500*noise( q , seed); q = m*q*2.02;\n    v += 0.1250*noise( q , seed); q = m*q*2.03;\n    v += 0.0625*noise( q , seed); q = m*q*2.01;\n\n    return v;\n}\n\n\n\n\n// ---------------------------------------------------------------------------------------------\n// ---------------------------------------------------------------------------------------------\n// ---------------------------------------------------------------------------------------------\n\n// Rotation ------------------------------------------------------------\n\n// Rotation around y axis\n// v : Vector\n// a : Angle\nvec3 rotate(in vec3 v,in float a)\n{\n    return vec3(v.x*cos(a)+v.z*sin(a),v.y,-v.x*sin(a)+v.z*cos(a));\n}\n\n// Textures ------------------------------------------------------------\n\nconst vec3 noire=vec3(0.0,0.0,0.0);\nconst vec3 blanc=vec3(1.0,1.0,1.0);\nconst vec3 dgris=vec3(0.1,0.1,0.1);\nconst vec3 gris=vec3(0.3,0.3,0.3);\nconst vec3 lgris=vec3(0.7,0.7,0.7);\nconst vec3 red=vec3(1.0,0.0,0.0);\nconst vec3 orange=vec3(1.0,0.4,0.0);\nconst vec3 yellow=vec3(1.0,1.0,0.0);\nconst vec3 bleu=vec3(0.5,0.5,1.0);\nconst vec3 cyan=vec3(0.5,0.8,1.0);\nconst vec3 violet=vec3(0.5,0.0,1.0);\n\nfloat M_PI = 3.141592;\n\n// Simple color\n// p : Point on object\n// n : Normal at point\nvec3 color(in vec3 p,in vec3 n)\n{\n    return vec3(1,1,1);\n}\n\n// Checker\n// p : Point on object\n// n : Normal at point\nvec3 checker(in vec3 p,in vec3 n)\n{\n    float v=mod(floor(p.x)+floor(p.y)+floor(p.z),2.0);\n    return mix(red,yellow,v);\n}\n\n// Color sine wave\nvec3 sine(in vec3 p,in vec3 n)\n{\n    vec3 pa=p-vec3(1.0,1.0,1.0);\n    float v=0.5*(1.0+cos(14.0*sqrt(dot(pa,pa))));\n    return mix(red,yellow,v);\n}\n\n// lave\nvec3 lava(in vec3 p, in  vec3 n)\n{\n    float temperature = 1.; // plus temperature est faible la lave est \"solide\"\n    \n    float v = smooth_noise(p);\n\n    vec3 pa=p-vec3(1.0,1.0,1.0);\n    v=0.5*(1.0+cos(v*8.0*sqrt(dot(pa,pa))));\n    \n    if(v != 0.) // on Ã©vite la division pas 0\n    \tv = abs(temperature/v);\n    else\n        v = 1.;\n    \n    return mix(noire,orange,v);\n}\n\n// rouille \nvec3 rouille(in vec3 p, in  vec3 n)\n{\n\n    float noise  = smooth_noise(1.5*p);\n    float v = max(exp(abs(sin(noise*5.0)*cos(noise*5.0))) - 0.90, 0.4*noise);\n    \n    if(v <  0.5*noise)\n        return mix(1.2*orange, noire, noise);\n    return 0.8*cyan* v;\n\n}\n\n// fumee = le noise adoucit\nvec3 fumee(in vec3 p, in  vec3 n)\n{\n\n    float v = smooth_noise(p);\n    return mix(noire,blanc,v);\n\n}\n\n// mars\nvec3 mars(in vec3 p, in  vec3 n)\n{\n\n    float v = smooth_noise(p);\n    v =abs(sin(p.x+v*5.0)*cos(p.y+v*5.0));\n\n    if(v < 0.5)\n        v*= 0.5;\n\n    return mix(mix(dgris,noire,sqrt(v)), orange,1.2*smooth_noise(p));\n\n}\n\n// marbre\nvec3 marbre(in vec3 p, in  vec3 n) {\n    \n    float param = 0.4; // augmente ou diminue le nombre de rainure\n\t\n    float noise  = smooth_noise(param*p);\n    \n    float v = 0.5 - sqrt(abs(sin(2. * 3.141592 * noise)));\n    return mix(blanc, lgris, v);\n}\n\n// nuage\nvec3 nuage(in vec3 p, in  vec3 n) {\n    \n    float taille_nuage = 0.4; // plus le nombre est grand, plus les nuages sont petits\n\n    float noise  = smooth_noise(taille_nuage*p);\n\n    float v = 0.5 - abs(fract(noise + 0.2 * noise));\n\n   \treturn mix(cyan*1.5,blanc*2., 2.0*v);\n\n\n}\n\n// metal brossÃ©\nvec3 metalbrosse(in vec3 p, in vec3 n) {\n    \n    float facteur_l = 3.5; // modifie l'espace entre les \"lignes\"\n    float frequence = 0.5;\n    float noise1 = smooth_noise(frequence*p + p.y * facteur_l);\n    float noise2  = smooth_noise(frequence*p+p.y* facteur_l, 656565656.56565);\n    float noise3  = smooth_noise(frequence*p+p.y* facteur_l,13756359.7428651);\n\n    noise1 = 1.0-sqrt(noise1);\n    noise2 = 1.-sqrt(noise2);\n    noise3 = 1.-sqrt(noise3);\n    \n    return mix(gris, mix(blanc, mix(gris, lgris, noise1), noise2), noise3);\n\n}\n\n// foudre\nvec3 foudre(in vec3 p, in  vec3 n) {\n    \n    \n    float frequence = 0.2;\n    float noise  = smooth_noise(frequence*p);\n\n    float v = 0.5 - sqrt(abs(sin(2. * 3.141592 * noise)));\n\n   \treturn mix(mix(noire*2.,cyan*2., 2.0*v),2.0*violet, v);\n}\n\n// bois\nvec3 bois(in vec3 p,in vec3 n)\n{\n    \n    float distortion = 2.; // plus c'est grand plus la perturbation aura d'impact\n    \n    float phi = asin(p.z);\n    float teta = atan(p.y,p.x) + M_PI;\n    \n    float phi2 = 0.; // modifier phi2 et teta2 permet de modifier la position du centre de l'ecorse\n    float teta2 = 0.;//255;165;79\n    \n    vec3 brown = vec3(255./255.,165./255.,79./255.), dark = vec3(139./255.,90./255.,43./255.);\n    \n    float dist = acos(cos(phi)*cos(phi2)*cos(teta-teta2)+sin(phi)*sin(phi2))*10.;\n    float noises = smooth_noise(p)*distortion;\n\treturn mix(brown,dark,sin(5.*(dist+noises)));\n}\n\n// terre\nvec3 earth(in vec3 p, in vec3 n){\n    \n    float frequence = 0.5; // modifie la taille des \"terres\"\n    \n    float noises = smooth_noise(p*frequence);\n    vec3 grass = vec3(0.,1.,0.);\n    vec3 couleur;\n    vec3 ocean = vec3(0.,0.,1.);\n    vec3 mountain = vec3(1.,0.,0.);\n    vec3 deep = vec3(0.,0.,0.);\n    vec3 snow = vec3(1.,1.,1.);\n    \n    float phi = asin(p.z);\n    float teta = atan(p.y,p.x) + M_PI;\n\n    \n    if(p.y > (1.4 * smooth_noise(p/4.))) {\n     \t  return snow;\n    }\n    \n    else if(p.y < -(1.4 * smooth_noise(p/4.))) {\n     \t   return  snow;\n    }\n    else if (noises<0.45){\n        return mix(mountain,grass,pow(noises/0.45,2.));\n    }\n    else\n        return mix(ocean,deep,pow((noises-0.45)/0.55,2.));\n    \n    \n}\n\n// terre avec nuages et la nuit\nvec3 nuage_earth(in vec3 p, in  vec3 n) {\n    \n    vec3 dark = vec3(0.,0.,0.);\n    \n    float frequence = 1.5; // ou taille des nuages\n\n    float noise  = smooth_noise(frequence*p);\n\n    float v = 0.5 - abs(fract(noise + 0.2 * noise));\n\n   \tvec3 jour =  mix(earth(p,n),vec3(1.,1.,1.), 4.0*v);\n\n    float nuit = 0.;\n    \n   \tif(p.x > 0.)\n    \tnuit = 0.75;\n    \n\treturn mix(jour,dark,nuit);\n}\n\n// granit\nvec3 granit(in vec3 p, in vec3 n){\n    \n    float frequence = 6.; // modifier la frequence permet de rendre les dÃ©tails petits ou grand\n    float seuil_noir=0.3; // change l'aspect du granite (le niveau de noir change)\n    \n    float noi = smooth_noise(frequence*p);\n    if (noi>seuil_noir){\n        float noi2 = 1.5*smooth_noise(frequence*p);\n        return vec3(noi2);\n    }\n    else\n\t\treturn vec3(0.,0.,0.);\n}\n\n//balle de tennis\nvec3 tennis(in vec3 p, in vec3 n){\n   \tif(abs(p.x*p.x-p.y*p.y - 2.* 0.1 * p.z) < 0.1)\n    \treturn vec3(1.,1.,1.);\n    return vec3(1.,1.,0.);\n}\n\n\n// Objects --------------------------------------------------------------\n\n// Intersection between a ray and a sphere\n// o : Ray origin\n// d : Ray direction\n// c : Center of sphere\n// r : Radius\n// t : Intersection depth\n// n : Normal at intersection point\nbool sphere(in vec3 o,in vec3 d,in vec3 c,in float r,out float t,out vec3 n)\n{\n    vec3 oc = o-c;\n\n    float b=dot(d,oc);\n    float k = dot(oc,oc)-r*r;\n    t=b*b-k;\n\n    if (t<=0.0) return false;\n\n    t=-b-sqrt(t);\n    if (t<0.0) return false;\n\n    // Normal\n    n=(o+t*d-c)/r;\n\n    return true;\n}\n\n// Lighting -------------------------------------------------------------\n\n// Background color\n// r : Ray direction\nvec3 background(in vec3 r)\n{\n    return mix(vec3(0.2, 0.3, 0.4), vec3(0.7, 0.8, 1.0), r.y*0.5+0.5);\n}\n\n// p : Point on object\n// n : normal at point\nvec3 shade(in vec3 p,in vec3 n)\n{\n    // Point light\n    const vec3 lightPos = vec3(1.0, 1.0,-5.0);\n    const vec3 lightColor = vec3(0.95, 0.95,0.95);\n\n    vec3 l = normalize(lightPos - p);\n\n    // Not even Phong shading, use weighted cosine instead for smooth transitions\n    float diff = 0.5*(1.0+dot(n, l)*dot(n, l));\n\n    // Change call to Texture there : apply either color() or sine() or checker() or whatever texture you wish\n    vec3 c = 0.2*background(n)+0.8*lava(p,n)*diff*lightColor;\n\n    return c;\n}\n\n// Vignetting\n// c : Color\n// p : Point in screen space\nvec4 Vignetting(in vec4 c,in vec2 p)\n{\n    return c * ( 0.5 + 0.5*pow( (p.x+1.0)*(p.y+1.0)*(p.x-1.0)*(p.y-1.0), 0.1 ) );\n}\n\n// Main -----------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n    vec2 uv = xy * vec2(iResolution.x/iResolution.y, 1.0);\n\n    // Ray origin and direction\n    vec3 o = vec3(0.0, 0.0, -2.0);\n    vec3 d = normalize(vec3(uv, 1.0));\n\n    o=rotate(o,0.5*iTime);\n    d=rotate(d,0.5*iTime);\n\n    vec3 n;\n    float t;\n\n    // Default background color\n    fragColor=vec4(background(d),1.0);\n    if (sphere(o, d, vec3(0.0, 0.0, 0.0), 1.0, t, n))\n    {\n        fragColor = vec4( mix(background(d), shade(o+d*t,n), step(0.0, t)), 1.0 );\n    }\n    fragColor=Vignetting(fragColor,xy);\n}","name":"Image","description":"","type":"image"}]}