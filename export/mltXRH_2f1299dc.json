{"ver":"0.1","info":{"id":"mltXRH","date":"1685041617","viewed":96,"name":"Noisy Contours & Gradients ","username":"gee8sh","description":"A tweak to my Noisy Contours shader that also shows the red/blue curves that are supposedly parallel to the gradients. I'm satisfied with it artistically, but I have doubts about the mathematical correctness. Will revisit it later.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = atan(0.0, -1.0);\n\nconst float animationSpeed = 1.0 / 32.0;\n\n// Noise params\nconst uint depth = 8u;\nconst float spaceScale = sqrt(2.0);\nconst float noiseScale = 1.0 / spaceScale;\nconst float scale = \n    (1.0 - noiseScale) / \n    (1.0 - pow(noiseScale, float(depth) + 1.0));\n\nvec4 base(in vec3 v) {\n    vec3 alias = 2.0 * fract(0.5 * v) - 1.0;\n    vec3 a = abs(alias);\n    vec3 s = smoothstep(0.0, 1.0, a);\n    vec3 deriv = alias * (1.0 - a);\n    vec3 factors = vec3(s.y * s.z, s.z * s.x, s.x * s.y);\n    vec3 grad = deriv * factors;\n    float w = s.x * factors.x;\n    return vec4(grad * 6.0, w);\n}\n\nvec4 noise(in vec3 pos, mat3 matrix, vec3 displacement) {\n    vec3 v = pos;\n    mat3 m = matrix;\n    float s = noiseScale;\n    vec4 result = base(v);\n    for (uint i = 1u; i < depth; i++) {\n        v = spaceScale * matrix * v + displacement;\n        vec4 r = base(v);\n        result.w += s * r.w;\n        result.xyz += r.xyz * m;\n        m *= matrix;\n        s *= noiseScale;\n    }\n    return result * scale;\n}\n\nmat3 rotation() {\n    float angle = iTime * PI * animationSpeed;\n    float s1 = sin(angle / 5.0);\n    float c1 = cos(angle / 5.0);\n    float s2 = sin(angle / 53.0);\n    float c2 = cos(angle / 53.0);\n    return mat3(\n        vec3( c1,  s1, 0.0),\n        vec3(-s1,  c1, 0.0),\n        vec3(0.0, 0.0, 1.0)\n    ) * mat3(\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0,  c1,  s1),\n        vec3(0.0, -s1,  c1)\n    );\n}\n\nvec2 pixelCoordinates(in vec2 fragCoord, in float halfPixelSize) {\n    float aspect = iResolution.x * halfPixelSize;\n    return 2.0 * halfPixelSize * fragCoord - vec2(aspect, 1.0);\n}\n\nvec4 sampleNoise(in vec2 xy, mat3 matrix, vec3 displacement) {\n    vec3 v = vec3(xy, -1.0);\n    mat3 r = rotation();\n    vec4 n = noise(r * v, matrix, displacement);\n    vec3 g = n.xyz * r;\n    float a = atan(g.y, g.x) * 8.0 / PI;\n    return pow(fract(vec4(a, n.w * 96.0, a + 0.5, 1.0)), vec4(16.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float halfPixelSize = 0.125 / iResolution.y;\n\n    vec3 displacement = vec3(0.6, 0.5, 0.4);\n    vec3 i = normalize(vec3(1.0, 2.0, 3.0));\n    vec3 k = normalize(cross(i, i.zxy));\n    vec3 j = normalize(cross(k, i));\n    mat3 matrix = mat3(i, j, k);\n\n    vec2 xy = pixelCoordinates(fragCoord, halfPixelSize);\n    \n    // Anti-aliasing\n    vec4 n = 0.25 * (\n        sampleNoise(xy, matrix, displacement) +\n        sampleNoise(xy + halfPixelSize * vec2(1.0, 0.0), matrix, displacement) +\n        sampleNoise(xy + halfPixelSize * vec2(0.0, 1.0), matrix, displacement) +\n        sampleNoise(xy + halfPixelSize * vec2(1.0, 1.0), matrix, displacement)\n    );\n\n    // Output to screen\n    fragColor = sqrt(n);\n}","name":"Image","description":"","type":"image"}]}