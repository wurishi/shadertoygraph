{"ver":"0.1","info":{"id":"X3BBzy","date":"1729585711","viewed":45,"name":"blood planet surface","username":"akr51","description":"Playing around with turbulence","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["turbulence"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define ITR 128\n#define DST 60.0\n#define SRF 0.0001\n\nfloat t = 0.0;\nfloat pl = 0.0;\n\nfloat noise(vec2 uv)\n{\n\n\n    return fract(sin(dot(uv, vec2(12.0, 1320.0))) * 1320.0);\n\n}\n\nfloat snoise(vec2 uv)\n{\n\n\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    vec2 w = (f * f * (3.0 - 2.0 * f));\n    float n[4];\n    int d = 0;\n    for (float r = 0.0; r <= 1.0; r++) {\n    \n        for (float c = 0.0; c <= 1.0; c++) {\n            \n            n[d++] = noise(i + vec2(r, c));\n        \n        }\n    \n    }\n    \n    float n0 = mix(n[0], n[2], w.x);\n    float n1 = mix(n[1], n[3], w.x);\n    return mix(n0, n1, w.y);\n\n}\n\nfloat turb(vec2 uv, float oct)\n{\n\n    float t = -0.5;\n    for (float f = 1.0; f <= oct; f++) {\n        \n        float pr = pow(2.0, f);\n        t += abs(snoise(uv * pr) / pr);\n    \n    }\n    \n    return t;\n\n}\n\nfloat sdf_plane(vec3 sp, vec3 n, float y)\n{\n\n    sp.z += t;\n   \n    return dot(sp, n) + y + turb(sp.xz * 0.2, 3.0) * 7.3;\n\n}\n\n\nvec2 map(vec3 sp)\n{\n    pl = length(sp);\n    float dst[2];\n    float id = 0.0;\n    dst[0] = sdf_plane(sp, normalize(vec3(0.0, 1.0, 0.0)), 0.6);\n    dst[1] = sp.y + 0.8 + turb(sp.xz + t, 1.0) * 0.2;\n    \n    for (int i = 1; i < 2; i++)\n    {\n    \n    \n        if (dst[i] < dst[0]) {\n        \n            dst[0] = dst[i];\n            id = float(i);\n        \n        }\n    \n    }\n    return vec2(dst[0], id);\n\n}\n\n\nvec2 mrch(vec3 ro, vec3 rd)\n{\n\n    float d0 = 0.0;\n    float id = 0.0;\n    for (int i = 0; i < ITR; i++) {\n        \n        vec3 sp = ro + rd * d0;\n        vec2 ds = map(sp);\n        d0 += ds.x * 0.4;\n        id = ds.y;\n        if (d0 > DST || ds.x < SRF) break;\n    \n    }\n    \n    if (d0 > DST) d0 = 0.0;\n    return vec2(d0, id);\n    \n\n}\n\n\nvec3 nml(vec3 sp)\n{\n\n\n    vec2 d = vec2(0.001, 0.0);\n    return normalize(map(sp).x - vec3(map(sp - d.xyy).x, map(sp - d.yxy).x, map(sp - d.yxx).x));\n\n}\n\n\nvoid mainImage(out vec4 c_out, in vec2 u)\n{\n    \n    \n    vec2 rr = iResolution.xy;\n    vec2 uv = (u + u - rr) / rr.y;\n    t = mod(iTime, 3.141592 * 2.0 * 13.0);\n    vec3 ro = vec3(1.0 + sin(t * 0.5) * 5.0, 13.1 + cos(t * 0.15), -5.0 + sin(t));\n    vec3 ww = normalize(vec3(0.0) - ro);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    vec3 rd = mat3(uu, vv, ww) * normalize(vec3(uv, 0.5));\n    \n    \n    vec3 l = normalize(vec3(0.1, 1.25, -1.0));\n    vec2 d0 = mrch(ro, rd);\n    float s = d0.x;\n   \n    vec3 colors[2] = vec3[2](vec3(0.2, 0.1, 0.1) * 0.001, vec3(11.0, 0.0, 0.0) * 0.1);\n   \n    vec3 clr = vec3(0.001);\n    \n    if (s > 0.0) {\n    \n        vec3 sp = ro + rd * s;\n        float fydst = -sp.y + 0.5;\n        float ffyf = clamp(fydst * 0.2, 0.0, 1.0);\n        vec3 n = nml(sp);\n        vec3 a = colors[int(d0.y)];\n        \n        if (d0.y == 0.0) {\n            \n            a += snoise(sp.xy * 122.0) * 0.01;\n        \n        }\n        \n        a += vec3(10.0, 0.0, 0.0) * ffyf;\n        \n        float dif = max(0.0, dot(n, l));\n        float spc = pow(max(dot(reflect(-l, n), -rd), 0.0), 3.0);\n        clr += dif * a + spc * 0.01;\n        \n    }\n    \n    \n    \n    c_out = vec4(pow(clr, vec3(0.45)), 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}