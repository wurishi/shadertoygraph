{"ver":"0.1","info":{"id":"Xdc3zS","date":"1450306394","viewed":422,"name":"Narves1","username":"rohtie","description":"Commercial I did for the Narves1 kiosk.\nhttp://i.imgur.com/34P4VNk.jpg","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["distancefields"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"float smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat capsule ( vec3 p, vec3 a, vec3 b, float r ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nbool distanceCmp(float distanceA, float distanceB, float eps) {\n    return distanceA > distanceB - eps && distanceA < distanceB + eps;\n}\n\nbool distanceCmp(float distanceA, float distanceB) {\n    return distanceCmp(distanceA, distanceB, 0.05);\n}\n\nvec2 map (vec3 point) {      \n    float material = 0.0;\n    \n    float t = 0.1 + sin(iTime * 0.001) * 50000.0;\n    float ti = 1.5 - sin(iTime) * 0.5;\n    float j = 1.12;\n    point.zx *= mat2(-sin(j), cos(j), cos(j), sin(j));\n    \n    point.zy *= mat2(-sin(ti), cos(ti), cos(ti), sin(ti));\n    \n    float body = capsule(point, vec3(0.0, 1.0, 0.0), vec3(0.0, -2.0, 0.0), 0.5);\n    \n    float mouth = smin(\n        capsule(point, vec3(-0.3, 0.35, 0.4), vec3(-0.1, 0.17, 0.5), 0.09),\n        capsule(point, vec3(0.3, 0.35, 0.4), vec3(0.1, 0.17, 0.5), 0.09),\n        0.2);\n    \n    vec3 q = point;\n    q.x += sin(q.y * 5.0) * 0.175;\n    float bodyDeco = capsule(q, vec3(0.0, -0.5, 0.5), vec3(0.0, -2.0, 0.5), 0.11);\n    \n    \n    point.x = abs(point.x);\n    \n    vec3 brow_point = point;\n    brow_point.y -= sin(point.x * 5.0) * 0.175;\n    float brows = capsule(brow_point, vec3(0.1, 0.8, 0.5), vec3(0.3, 0.7, 0.4), 0.05);\n    \n    \n    float eyes = length(point - vec3(0.2, 0.6, 0.5)) - 0.1;\n    \n    float pupils = length(point - vec3(0.2, 0.6, 0.6)) - 0.075;\n    \n    float arms = smin(\n        capsule(point, vec3(0.4, -0.3, 0.0), vec3(0.7, -0.75, 0.7), 0.21),\n        capsule(point, vec3(0.5, -0.75, 1.3), vec3(0.7, -0.75, 0.9), 0.21),\n        0.15);\n    \n    float fingers = min(capsule(point, vec3(0.6, -0.65, 1.1), vec3(0.2, -0.4, 1.1), 0.12),\n                        min(capsule(point, vec3(0.6, -0.65, 1.1), vec3(0.2, -0.4, 1.8), 0.09),\n                            min(capsule(point, vec3(0.4, -0.7, 1.5), vec3(0.4, -0.7, 1.8), 0.09),\n                                capsule(point, vec3(0.4, -0.8, 1.4), vec3(0.4, -0.9, 1.7), 0.09))));\n    \n    float composite = smin(body, eyes, 0.1);\n    composite = smin(composite, mouth, 0.07);\n    composite = smin(composite, arms, 0.15);\n    composite = min(composite, pupils);\n    composite = smin(composite, bodyDeco, 0.06);\n    composite = smin(composite, brows, 0.04);\n    composite = smin(composite, fingers, 0.2);\n    \n    \n    float distance = composite + \n        texture(iChannel0, point.xx * point.yy * point.zz *\n                             mat2(-sin(t), cos(t),\n                                  cos(t), sin(t))).r * (0.05) ;\n    \n    if (distanceCmp(distance, body)) {\n        material = 1.0;\n    }\n    else if (distanceCmp(distance, pupils, 0.02)) {\n        material = 4.0;\n    }\n    else if (distanceCmp(distance, eyes, 0.1)) {\n        material = 2.0;\n    }\n    else if (distanceCmp(distance, min(mouth, bodyDeco))) {\n        material = 3.0;\n    }\n\n    return vec2(distance, material);\n}\n\nvec2 intersect (vec3 rayOrigin, vec3 rayDirection) {\n    const float maxDistance = 10.0;\n    const float distanceTreshold = 0.001;\n    const int maxIterations = 50;\n    \n    float distance = 0.0;\n\n    float currentDistance = 1.0;\n    \n    vec2 result;\n    \n    for (int i = 0; i < maxIterations; i++) {\n        if (currentDistance < distanceTreshold || distance > maxDistance) {\n            break;\n        }\n\n        result = map(rayOrigin + rayDirection * distance);\n        currentDistance = result.x;\n        \n        distance += currentDistance;\n    }\n\n    if (distance > maxDistance) {\n        return vec2(-1.0, 0.0);\n    }\n\n    return vec2(distance, result.y);\n}\n\nvec3 getNormal(vec3 point) {\n    vec2 extraPolate = vec2(0.002, 0.0);\n\n    return normalize(vec3(\n        map(point + extraPolate.xyy).x,\n        map(point + extraPolate.yxy).x,\n        map(point + extraPolate.yyx).x\n    ) - map(point).x);\n}\n\nvec3 light = normalize(vec3(5.0, 5.0, 5.0));\n\nvoid mainImage (out vec4 color, in vec2 point) {\n    point /= iResolution.xy;\n    point = 2.0 * point - 1.0;\n    point.x *= iResolution.x / iResolution.y;\n    \n    vec2 p = point;\n    \n    vec3 cameraPosition = vec3(-0.5, 0.0, 2.0);\n    vec3 rayDirection = normalize(vec3(point, -1.0));\n    \n    vec2 result = intersect(cameraPosition, rayDirection);\n    \n    float distance = result.x;\n    float material = result.y;\n    \n    vec3 col = vec3(0.0);\n\n    if (result.x > 0.0) {\n        vec3 point = cameraPosition + rayDirection * distance;\n        vec3 normal = getNormal(point);\n        \n        if (material == 1.0) {\n            col += vec3(0.5, 0.21, 0.2);\n        }\n        else if (material == 2.0) {\n            col += vec3(0.5);\n        }\n        else if (material == 3.0) {\n            col += vec3(0.6, 0.0, 0.0);\n        }\n        else if (material == 4.0) {}\n        else {\n            col += vec3(0.5, 0.21, 0.2);\n        }\n        \n        col += vec3(0.7, 1.0, 0.95) * max(dot(normal, light), 0.0);\n        \n        vec3 halfVector = normalize(light + normal);\n        col += vec3(1.0) * pow(max(dot(normal, halfVector), 0.0), 1024.0);\n        \n        float att = clamp(1.0 - length(light - point) / 5.0, 0.0, 1.0); att *= att;\n        col *= att;\n        \n    }\n    else {\n        col = vec3(0.3 + p.x * 0.04, 0.05 + p.x * p.y * 0.2, smoothstep(0.2, 0.7 + sin(p.y * 52.0 * iTime), (length(p) - 1.0))) * 1.5;\n    }\n    \n    col *= 1.5;\n\n    color.rgb = col;\n}\n","name":"Image","description":"","type":"image"}]}