{"ver":"0.1","info":{"id":"ctdcDN","date":"1699230363","viewed":32,"name":"ProtoZoomerBW poc","username":"Longinus","description":"Prototype of autonomouys mandelbrot zoomer. Zoomer samples smaller pictures and calculates with boxcounting Minkowski-Bouligand dimension of sampled pictures and zooms in where it is highest.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["mandelbrot","animation","zoomer","automatic","proto","minkowskibouliganddimension","boxcounting"],"hasliked":0,"parentid":"DltyDN","parentname":"ProtoZoomerLonginus"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nfloat cubicInterpolate(float y0, float y1, float y2, float y3,float mu){\n\n    float a0 = y3 - y2 - y0 + y1,\n    a1 = y0 - y1 - a0,\n    a2 = y2 - y0,\n    a3 = y1;\n    return a0 * mu * mu*mu + a1 * mu*mu + a2 * mu + a3;\n}\n\nfloat logInterpolate(float y1,float y2,float mu){\n    return y1 * pow(2.,mu*log2(y2 / y1));\n}\n\nfloat mandel(vec2 tc,vec4 f) {\n    vec2 c = f.z*tc *vec2(float(iResolution.x)/float(iResolution.y),1.)+vec2(f);\n    vec2 z = c;\n    for (int n = 0; n < iterations; n++) {\n        z = vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y) + c;\n        float square = z.x*z.x+z.y*z.y;\n        if (square > 8.0) return (float(n) + 1. - log(log(square)/(logOf2*8.)) / logOf2);\n    }\n    return 0.0;\n}\n\nvec4 color(vec2 tc, vec4 f){\n    float n= mandel(tc,f);\n    return n==0.0?vec4(0, 0, 0, 1):vec4(vec3(float(n)/float(iterations)),1);\n}\n\n\nhighp vec4 colorss2(vec2 tc) {\n    int offset=(iFrame%interpolationFrames>=(interpolationFrames/2))?0:-1;\n    int numCoord = numCoords+offset;\n    vec4 offsetXYZ0 =texelFetch(iChannel1,ivec2(numCoord,0),0);\n    vec4 offsetXYZ1 = texelFetch(iChannel1,ivec2(numCoord-2,0),0);\n    vec4 offsetXYZ2 = texelFetch(iChannel1,ivec2(numCoord-4,0),0);\n    vec4 offsetXYZ3 = texelFetch(iChannel1,ivec2(numCoord-6,0),0);\n\n    float dt=float(iFrame%(interpolationFrames))/float((interpolationFrames));\n    float offsetX = cubicInterpolate(offsetXYZ0.x,offsetXYZ1.x,offsetXYZ2.x,offsetXYZ3.x,dt);\n    float offsetY = cubicInterpolate(offsetXYZ0.y,offsetXYZ1.y,offsetXYZ2.y,offsetXYZ3.y,dt);\n    float zoomi = logInterpolate(abs(offsetXYZ1.z),abs(offsetXYZ2.z),dt);\n    vec4 f = vec4(offsetX,offsetY, zoomi, 1.0);\n\n    vec2 dxy =tc/iResolution.xy;\n    vec4 sum = color(tc,f)*3.;\n\n    for(int i=0; i<6; i++){\n        float angle = float(i)*2.*PI/12.;\n        sum += color(tc+dxy*vec2(sin(angle),cos(angle)),f);\n    }\n    return sum/(9.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n/*\n    int  picsize = int(iResolution.x)/(frames);\n    vec4 col = colorss2(2.*fragCoord/iResolution.xy-1.0);\n    if (fragCoord.y>iResolution.y-100.){\n        fragColor = texelFetch(iChannel2,ivec2((fragCoord.x)/30.,(fragCoord.y-iResolution.y)/30.),0);\n    }\n    else\n    if(fragCoord.y>float(picsize+30)){\n    \n        fragColor = vec4(col);\n        \n        \n    }\n    else {\n    \n        fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    }\n*/    \n    fragColor = colorss2(2.*fragCoord/iResolution.xy-1.);\n    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Hash11 is borrowed from https://www.shadertoy.com/view/ctdcDN\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//calculate small pictures\n//fractal formula:\nvec3 formulaBW(vec2 oc,vec2 os, float zomg) {\n    float sum = 0.;\n    if(abs(os.x*os.x+os.y*os.y)>1.0) return vec3(0);\n    vec2 step = 1.0/iResolution.xy;\n    for(int j=0;j<2;j++){\n        for(int k=0;k<2;k++){\n            vec2 ij = vec2(float(j),float(k));\n            vec2 diff = (ij*step)*zomg;\n            vec2 c = oc+diff;\n            vec2 z = vec2(0.);\n            for (int i=0;i<iterations;i++) {\n                z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n                float square = z.x*z.x+z.y*z.y;\n                if (square > 8.0){ \n                    sum+=1.0;\n                    break;\n                }\n            }\n        }\n    }  \n    return sum>0.1&&sum<3.9?vec3(1):vec3(0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int  picsize = int(iResolution.x)/(frames);\n    \n    int frame = int(fragCoord.x)/picsize;\n    float xc = ((fragCoord.x-float(frame*picsize))/float(picsize)-.5)*2.;\n    float yc = ((fragCoord.y)/float(picsize)-.5)*2.;\n    vec3 offsetXYZ =texelFetch(iChannel0,ivec2(0,0),0).xyz;\n    float z =offsetXYZ.z;\n    float zomg = abs(z);\n    bool direction = z>0.0;\n    float angle = float(frame)*2.*PI/float(frames-2);\n    vec2 fxy = vec2(sin(angle),cos(angle))*(1.+hash11(iTime))*(frame==frames-1?0.0:1.0);\n    vec2 uv = vec2(xc,yc);\n    vec2 oc =uv*zomg;\n    vec2 offset = offsetXYZ.xy;\n    vec2 pc = fxy*zomg+offset;\n    oc += pc;\n\n    if(fragCoord.y < float(picsize)){\n        fragColor = vec4(formulaBW(oc,uv, zomg),1.);\n        return;\n    }\n    else if(fragCoord.y< float(picsize+2)){\n        fragColor = vec4(pc,offsetXYZ.z,1.);\n        return;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Calculate row sums for small pics\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int  picsize = int(iResolution.x)/(frames);\n    int frame = int(fragCoord.x)/picsize;\n    int xc = int(fragCoord.x)-frame*picsize;\n    ivec2 texCoord =ivec2(fragCoord);\n    \n    if(texCoord.y<picsize && xc<1){\n        float sum = 0.0;\n        for(int i=0; i< picsize; i++){\n            vec4 color = texelFetch(iChannel0, ivec2(texCoord)+ivec2(i,0),0);\n            sum = sum + color.r;\n        }\n        fragColor = vec4(sum,sum,sum,1.0);\n        return;\n    }\n    discard;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//calculate column sums for small pictures\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int  picsize = int(iResolution.x)/(frames);\n    int frame = int(fragCoord.x)/picsize;\n    ivec2 texCoord = ivec2(fragCoord);\n    if(texCoord.y<1 && texCoord.x<frames){\n        float sum = 0.0;\n        for(int i=0; i< picsize; i++){\n            sum += texelFetch(iChannel0, ivec2(texCoord.x*picsize,i),0).r;\n        }\n        fragColor = vec4(sum,sum,sum,1.0);\n        return;\n    }\n    discard;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int  picsize = int(iResolution.x)/(frames);\n    int frame = int(fragCoord.x)/picsize;\n    if(fragCoord.x<(float(numCoords)+1.)){\n        int coord = int(fragCoord.x);\n        if(iFrame<1){\n            fragColor = vec4(0.012,0.25,-0.8,1.);\n            return;\n        }\n        \n        int frame = 0;\n        float count = 0.;\n        float maxCount = 0.;\n        for(int i=0;i<frames;  i++){\n            vec4 pixColor = texelFetch(iChannel0, ivec2(i,0),0);\n            count = pixColor.r;\n            if(count>=maxCount) frame = i;\n            maxCount=max(count,maxCount);\n        }\n        \n        \n        float mzoom = texelFetch(iChannel1, ivec2(picsize*(frames-1),picsize+1),0).z;\n        bool direction = mzoom>0.0;\n        float zoom = abs(mzoom);\n        \n        if(zoom>0.5) direction=true;\n        if(zoom<0.000005) direction=false;\n        zoom=direction ? zoom/1.2:zoom*1.2;\n\n        float m = 0.4;//maxCount/(1.+maxCount+count);\n        float m1 = 1.-m;\n        \n        vec2 xy = texelFetch(iChannel1,ivec2(picsize*frame, picsize+1),0).xy;\n        vec2 offsetXY = texelFetch(iChannel1,ivec2(picsize*(frames-1),picsize+1),0).xy;\n        \n        xy = xy*m+offsetXY*m1;\n        if(iFrame%(interpolationFrames/2) == 0){\n            if(fragCoord.x<1.0){\n\n                fragColor = vec4(xy,direction?zoom:-zoom,1.);\n            }\n            else{\n                //move coords forward\n                vec4 value = texelFetch(iChannel2, ivec2(coord-1,0),0);\n                fragColor = value;\n            }\n        }else{\n            vec4 value = texelFetch(iChannel2, ivec2(coord,0),0);\n            fragColor = value;\n        }\n    }\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159;\nconst float logOf2 = log(2.0);\nconst int iterations = 255; // Iterations for mandelbrot calculation\nconst int frames = 16; //This is amount of small pictures used for sampling should be dividable by picture width\nconst int numCoords = 10; // buffer size of zooming path\nconst int interpolationFrames = 20; // how many frames interpolated between path points\n","name":"Common","description":"","type":"common"}]}