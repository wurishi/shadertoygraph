{"ver":"0.1","info":{"id":"dlcfDf","date":"1708412140","viewed":62,"name":"spheres and boxes everywhere","username":"eissa","description":"simple little raymarching world, last render with old raymarching renderer","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"csdfWB","parentname":"rayMarching realm"},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float _maxDistance;\nvec4 _sphere1, _box1;\nvec3 _lightDir;\nvec4 _mainColor;\n\n\nstruct Camera\n            {\n                vec2 uv;\n                vec3 ro;\n                vec3 rd;\n            };\n            \nvec4 tex3D( in vec3 pos, in vec3 normal, sampler2D sampler )\n{\n\treturn \ttexture( sampler, pos.yz )*abs(normal.x)+ \n\t\t\ttexture( sampler, pos.xz )*abs(normal.y)+ \n\t\t\ttexture( sampler, pos.xy )*abs(normal.z);\n}\n\n#define BUMP_FACTOR .03\n#define TEX_SCALE_FACTOR .4\n\n// Sphere\n// s: radius\nfloat sdSphere(vec3 p, float s)\n{\n    vec3 normal;\n\tfloat bump = 0.0;\n\tif(length(p) < s+BUMP_FACTOR)\n\t{\t\n\t\tnormal = normalize(p);\n\t}\n\treturn length(p) - s;\n}\n\n// Box\n// b: size of box in x/y/z\nfloat sdBox(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) +\n\t\tlength(max(d, 0.0));\n}\n\n// BOOLEAN OPERATORS //\n\n// Union\nfloat opU(float d1, float d2)\n{\n\treturn min(d1, d2);\n}\n\n// Subtraction\nfloat opS(float d1, float d2)\n{\n\treturn max(-d1, d2);\n}\n\n// Intersection\nfloat opI(float d1, float d2)\n{\n\treturn max(d1, d2);\n}\n\n// Mod Position Axis\nfloat pMod1 (inout float p, float size)\n{\n\tfloat halfsize = size * 0.5;\n\tfloat c = floor((p+halfsize)/size);\n\tp = mod(p+halfsize,size)-halfsize;\n\tp = mod(-p+halfsize,size)-halfsize;\n\treturn c;\n}\n\nfloat distanceField(vec3 p) \n{\n    float Box2 = sdBox(p-vec3(0.0,0.0,7.0), vec3(2.0, 0.5, 0.1));\n    \n    float modx = pMod1(p.x, 4.0);\n    float mody = pMod1(p.y, 4.0);\n    float modz = pMod1(p.z, 4.0);\n    \n    //play around with displacement, super cool!\n    float Sphere1 = sdSphere(p - _sphere1.xyz, _sphere1.w);\n    float Box1 = sdBox(p - _box1.xyz, _box1.www);\n    \n    return opS(Sphere1, Box1);\n    \n    \n    \n}\n\n\n\nvec3 getNormal(vec3 p)\n{\n    const vec2 offset = vec2(0.001, 0.0);\n    vec3 n = vec3(\n        distanceField(p + offset.xyy) - distanceField(p - offset.xyy),\n        distanceField(p + offset.yxy) - distanceField(p - offset.yxy),\n        distanceField(p + offset.yyx) - distanceField(p - offset.yyx));\n    return normalize(n);\n}\n\nfloat getLight(vec3 p) \n{\n    // Directional light\n    vec3 lightPos = vec3(0.0,0.0,smoothstep(3.2, 5.5, iTime)*4.0); // Light Position\n    vec3 l = normalize(lightPos-p); // Light Vector\n    vec3 n = getNormal(p); // Normal Vector\n   \n    float dif = dot(n,l); // Diffuse light\n    dif = clamp(dif,0.,1.); // Clamp so it doesnt go below 0\n    \n    float d = distanceField(p);\n    if(d<length(lightPos-p)) dif *= 0.004;\n    \n    return dif;\n}\n\n// returns color\nvec4 raymarching(vec3 ro, vec3 rd) \n{\n    vec4 result = vec4(0, 0, 0, 1);\n    const int max_iteration = 164;\n    float t = 0.0; // distance traveled along ray direction\n\n    // move forward along the ray until you hit something\n    for (int i = 0; i < max_iteration; i++) \n    {\n        if (t > _maxDistance)\n        {\n            result = vec4(0.0, 0.0, 0.0, 1.0);\n            break;\n        }\n\n        vec3 p = ro + rd * t;\n        // check for hit in distance field\n        float d = distanceField(p);\n        // hit if statement\n        if (d < 0.01) \n        {\n            // shading\n            \n            float light = getLight(p);\n            d*= .2;\n            result = vec4((_mainColor.rgb * light), 1);\n            break;\n        }\n\n        t += d;\n    }\n    return result;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n     vec2 mo = iMouse.xy/iResolution.xy;\n     \n    _maxDistance = 100.0;\n    _sphere1 = vec4(0.0, 0.0, 0.0, 2.5);\n    _box1 = vec4(0.0, 0.0, 0.0, 4.0);\n    _lightDir = vec3(1.0, 1.0, 1.0);\n    _mainColor = vec4(170.0, 170.0, 160.0, 1.0);\n    \n    vec2 uv = (gl_FragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    \n    Camera camera;\n    camera.ro = vec3(0.0, sin(iTime*2.)*0.04 , smoothstep(3.2, 5.5, iTime)*4.0); \n    camera.rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    vec4 result = raymarching(camera.ro, camera.rd);\n    \n    fragColor = vec4((1.0-result.w) + result.xyz * result.w, 1.0) * vec4(result.w + result.xyz * result.w, 1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}