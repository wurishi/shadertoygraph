{"ver":"0.1","info":{"id":"tljyD1","date":"1594319604","viewed":265,"name":"fractal spaghettification","username":"sukupaper","description":"A weird animated fractal","likes":20,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","fractal","abstract","blurry","spaghettification"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = gl_FragCoord.xy/iResolution.xy;\n    vec2 p = st; p.x *= iResolution.x/iResolution.y;\n    float aa = 1./max(iResolution.x,iResolution.y);\n    \n    vec2 cShift = vec2(0.,aa*2.);\n    vec3 color = vec3(0.);\n    float d = pow(texture(iChannel0,st).a*.11,8.);\n    const int BLURM = 4;\n    for(int x = -BLURM; x < BLURM; x++) {\n        for(int y = -BLURM; y < BLURM; y++) {\n            vec2 sh = vec2(float(x),float(y));\n            color += texture(iChannel0,st + sh*aa*2.).rgb;\n    \t}\n    }\n    color /= pow(float(BLURM)*2.,2.);\n    color = mix(vec3(\n    \ttexture(iChannel0,st + cShift.yy).r,\n    \ttexture(iChannel0,st + cShift.xx).g,\n    \ttexture(iChannel0,st + cShift.xx).b\n    ),color,clamp(d,0.,1.));\n    \n    fragColor = vec4(color - pow(length(st-.5)*1.2,3.),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define P 3.1415926535897932384\nfloat rd(in vec2 st){ return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.585); }\nfloat c(in vec3 p, in float s) { return length(p) - s; }\nmat2 rot(in float a) { float c = cos(a), s = sin(a); return mat2(c,s,-s,c); }\n\nfloat t;\nvec2 m;\nint no;\nfloat df(in vec3 p) {\n    p.xz *= rot(m.x*P*2.);\n    p.yz *= rot(m.y*P*2.);\n    p.xz *= rot(t*20.);\n    \n    float d = 10e9;\n    \n    float v1 = 1.;\n    vec3 pp = p;\n    float aaa = 0.6666 + t*8. + p.x*.05;\n    for(int i = 0; i < 9; i++) {\n        float pd = d;\n        d = min(d, c(p, .75*v1));\n        if(pd != d) {\n            no = i;\n        }\n        p.x  = abs(p.x) - v1;\n        p.xy *= rot(P*aaa);\n        p.z  = abs(p.z) - v1;\n        p.xz *= rot(P*aaa);\n        p.y  = abs(p.y) - v1;\n        p.yx *= rot(P*aaa);\n        v1 *= .5;\n    }\n    \n    return d;\n}\n\nvec3 normal(in vec3 p) { float d = df(p); vec2 u = vec2(0.,.001); return normalize(vec3(df(p+u.yxx),df(p+u.xyx),df(p+u.xxy)) - d); }\n\n#define MIN_DIST 0.\n#define MAX_DIST 12.\n#define MAX_STEPS 60\n#define LIM .0075\nfloat dist = 10.;\nvec3 rm(in vec3 c, in vec3 r) {\n    vec3 color = vec3(0.);\n    vec3 p = c + r*MIN_DIST;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        float d = df(p);\n        if(d < LIM) {\n            vec3 n = 1.-(normal(p)*.5 + .5);\n            n = pow(n,vec3(0.7));\n            n = vec3(n.r*n.g*n.b);\n            dist = distance(c,p);\n            return vec3(1.) * n + float(i)*.013 + pow(float(no)*.11,5.) - pow(distance(c,p)*.1,6.);\n        }\n        if(distance(c,p) > MAX_DIST)\n            return vec3(1.)*clamp(float(i)*.02,.3,1.);\n        p += d*r*.8;\n    }\n    return vec3(0.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = gl_FragCoord.xy/iResolution.xy - .5;\n    st.x *= iResolution.x/iResolution.y;\n    m = iMouse.xy/iResolution.xy - .5 + vec2(cos(iTime*.1),sin(iTime*.1))*.5;\n\tt = iTime*.0005 + length(st*.02) + m.x*.1 + m.y*.1;\n    \n    vec3 c = vec3(st*5.,(-8.));\n    vec3 r = normalize(vec3(vec2(0.),1.));\n    \n    vec3 color = rm(c,r);\n    fragColor = vec4(1.1 - color.r*color.g*color.b*vec3(1.),dist);\n}","name":"Buffer A","description":"","type":"buffer"}]}