{"ver":"0.1","info":{"id":"WtfXRj","date":"1563480150","viewed":1135,"name":"Speedpaint_2019_07_18","username":"Bers","description":"Anime Speed Trails (30 min speed painting)","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["speedpaint"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash( vec2 p ) {return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453123);} //Pseudo-random\nfloat smoothNoise( in vec2 p) { //Bilinearly interpolated noise (4 samples)\n    vec2 i = floor( p ); vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    float a = hash( i + vec2(0.0,0.0) );\n\tfloat b = hash( i + vec2(1.0,0.0) );\n\tfloat c = hash( i + vec2(0.0,1.0) );\n\tfloat d = hash( i + vec2(1.0,1.0) );\n    return float(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y)/4.;\n}\n//Funciton to make the noise continuous while wrapping around angle \nfloat rotatedMirror(float t, float r){\n    //t : 0->1\n    t = fract(t+r);\n    return 2.*abs(t-0.5);\n}\n//Some continous radial perlin noise\nconst mat2 m2 = mat2(0.90,0.44,-0.44,0.90);\nfloat radialPerlinNoise(float t, float d){\n    const float BUMP_MAP_UV_SCALE = 44.2;\n    d = pow(d,0.01); //Impression of speed : stretch noise as the distance increases.\n    float dOffset = -floor(iTime*10.)*0.1; //Time drift (animation)\n    vec2 p = vec2(rotatedMirror(t,0.1),d+dOffset);\n    float f1 = smoothNoise(p*BUMP_MAP_UV_SCALE);\n    p = 2.1*vec2(rotatedMirror(t,0.4),d+dOffset);\n    float f2 = smoothNoise(p*BUMP_MAP_UV_SCALE);\n    p = 3.7*vec2(rotatedMirror(t,0.8),d+dOffset);\n    float f3 = smoothNoise(p*BUMP_MAP_UV_SCALE);\n    p = 5.8*vec2(rotatedMirror(t,0.0),d+dOffset);\n    float f4 = smoothNoise(p*BUMP_MAP_UV_SCALE);\n    return (f1+0.5*f2+0.25*f3+0.125*f4)*3.;\n}\n//Colorize function (transforms BW Intensity to color)\nvec3 colorize(float f){\n    f = clamp(f*.95,0.0,1.0);\n    vec3 c = mix(vec3(0,0,1.1), vec3(0,1,1), f); //Red-Yellow Gradient\n         c = mix(c, vec3(1,1,1), f*4.-3.0);      //While highlights\n    vec3 cAttenuated = mix(vec3(0), c, f+0.1);       //Intensity ramp\n    return cAttenuated;\n}\n/*vec3 colorize(float f){\n    f = clamp(f,0.0,1.0);\n    vec3 c = mix(vec3(1.1,0,0), vec3(1,1,0), f); //Red-Yellow Gradient\n         c = mix(c, vec3(1,1,1), f*10.-9.);      //While highlights\n    vec3 cAttenuated = mix(vec3(0), c, f);       //Intensity ramp\n    return cAttenuated;\n}*/\n//Main image.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = 2.2*(fragCoord-0.5*vec2(iResolution.xy))/iResolution.xx;\n    float d = dot(uv,uv); //Squared distance\n    float t = 0.5+atan(uv.y,uv.x)/6.28; //Normalized Angle\n    float v = radialPerlinNoise(t,d);\n    //Saturate and offset values\n    v = -2.5+v*4.5;\n    //Intersity ramp from center\n    v = mix(0.,v,.8*smoothstep(0.1,0.65,d));\n    //Colorize (palette remap )\n    fragColor.rgb = colorize(v);\n}","name":"Image","description":"","type":"image"}]}