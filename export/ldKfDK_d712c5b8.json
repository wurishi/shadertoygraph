{"ver":"0.1","info":{"id":"ldKfDK","date":"1530631690","viewed":274,"name":"Gameboy SDF","username":"Daedelus","description":"I made a quick and dirty game boy SDF because I couldn't find one :)\n\nI know it's a bit incomplete, mostly no back / sides, but it's something!\nAlso missing: Headphones & off/on engravings; Ribs on the D-pad; D-pad arrows embossing","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","game","sdf","gameboy","distance","field","signed","boy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\nGameboy SDF for raymarching, hopefully not too broken.\n\nAnyone please feel free to use it for anything!\nNotice I'm using parts of http://mercury.sexy/hg_sdf/ library + my own minified versions and other inventions.\n\nUsed this blueprint for positioning:\nhttps://www.the-blueprints.com/modules/vectordrawings/preview-wm/nintendo_gameboy_classic.jpg\nAlso used a wikipedia graphic for colors and official specs for body and screen dimensions.\n\nI am aware there is a lot of code, I went for readable / tweakable dimension constants.\nIf there are serious performance optimizations please comment and I'd love to fix it for future reuse!\n**/\n/* Language extensions */\n#define sat(x) clamp(x, 0.0, 1.0)\n\nfloat vmin(vec2 v){return min(v.x, v.y);}\nfloat vmin(vec3 v){return min(v.x, max(v.y, v.z));}\nfloat vmax(vec2 v){return max(v.x, v.y);}\nfloat vmax(vec3 v){return max(v.x, max(v.y, v.z));}\n\n/* Spatial modifiers*/\nvoid pR(inout vec2 p, float a){p=cos(a)*p+sin(a)*vec2(p.y,-p.x);}\n\n// Modulo over a single axis, but limit the maximum number of steps, stopping tiling at the given start (s) and end (e) distance. Notice they should be mutliples of the size (z).\nfloat pModInterval(inout float p,float z,float s,float e){float c=floor(p/z+.5);p=(fract(p/z+.5)-.5)*z;if(c>e){p+=z*(c-e);return e;}if(c<s){p+=z*(c-s);return s;}return c;}\n\n/* SDF primitives(many from http://mercury.sexy/hg_sdf/)*/\n// Sphere\nfloat fSphere(vec3 p,float r){return length(p)-r;}\n\n// Infinite box\nfloat fBox(vec2 p,vec2 s){return vmax(abs(p)-s);}\n\n// Box\nfloat fBox(vec3 p,vec3 s){return vmax(abs(p)-s);}\n\n// Cylinder with rounded caps\nfloat fCapsule(vec3 p,float r,float h){p.y=max(0.,abs(p.y)-h);return length(p)-r;}\n\n// first object gets a capenter-style groove cut out\nfloat fOpGroove(float a, float b, float ra, float rb) {\n\treturn max(a, min(a + ra, rb - abs(b)));\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec2 p, vec2 a, vec2 b) {\n\tvec2 ab = b - a;\n\tfloat t = sat(dot(p - a, ab) / dot(ab, ab));\n\treturn length((ab * t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r\nfloat fCapsule(vec2 p, vec2 a, vec2 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n\tvec3 ab = b - a;\n\tfloat t = sat(dot(p - a, ab) / dot(ab, ab));\n\treturn length((ab * t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\n\n// Subtract from the result to get a round edge\nfloat fBoxRound(vec3 p,vec3 s)\n{\n\tvec3 q=abs(p)-s;\n\treturn length(max(q,vec3(0)))+vmax(min(q,vec3(0)));\n}\nfloat fBoxRound(vec2 p,vec2 s)\n{\n\tvec2 q=abs(p)-s;\n\treturn length(max(q,vec2(0)))+vmax(min(q,vec2(0)));\n}\n\n/* SDF boolean operators */\nvoid fOpUnion(inout float a,float b,inout vec4 m,vec4 n){if(b<a){a=b;m=n;}}\nvoid fOpIntersection(inout float a,float b,inout vec4 m,vec4 n){if(b>a){a=b;m=n;}}\nfloat fOpIntersectionRound(float a,float b,float r){return min(-r,max(a,b))+length(max(r+vec2(a,b),0.));}\nfloat fOpIntersectionChamfer(float a,float b,float r){return max(a,max(b,(a+b+r)*sqrt(.5)));}\n\n/* Main code */\nconst float gameBoyButtonPopOut = 0.15;\nconst vec3 gameBoySizeInCm = vec3(9.0, 14.8, 3.2);\nconst float gameBoyHalfThickness = gameBoySizeInCm.z / 2.0;\n\nvoid fABButton(inout float r, inout vec4 m, vec3 p)\n{\n    const float gameBoyButtonBevel = 0.02;\n    const float gameBoyButtonSize = 0.55;\n\n    // cylinder for the button\n    float a = length(p.xy) - gameBoyButtonSize;\n    // sphere for the cap\n    float b = length(p + vec3(0.0, 0.0, 0.25)) - 0.25 - gameBoyHalfThickness - gameBoyButtonPopOut;\n    // cut off at the back\n    float ir = max(-p.z, fOpIntersectionRound(a, b, gameBoyButtonBevel));\n    // create inset\n    r = fOpIntersectionRound(r, -ir + 0.03, 0.03);\n    // intersect round for the final shape\n    fOpUnion(r, ir, m, vec4(p, 3));\n}\n\nfloat fGameboy(vec3 p, out vec4 m)\n{\n    // I made it mirrored, oops\n    p.xz = -p.xz;\n    // animate it a bit\n    pR(p.xz, sin(iTime) * 0.4 + -0.2);\n    \n    vec2 quadrant = sign(p.xy);\n    const float cornerRadius = 0.2;\n    // one corner is rounder\n    float offset = cornerRadius;\n    if(quadrant.x == -1.0 && quadrant.y == -1.0)\n        offset = 1.7;\n\n    // body\n    float r = fOpIntersectionRound(abs(p.z) - gameBoyHalfThickness, fBoxRound(p.xy, gameBoySizeInCm.xy / 2.0 - offset) - offset, cornerRadius);\n    m = vec4(p, 0);\n\n    // top groove\n    const vec2 grooveInCm = vec2(0.03, 0.06);\n    const float topGrooveOffset = 6.65;\n    r = fOpGroove(r, min(p.y - topGrooveOffset, max(-p.y + topGrooveOffset, abs(p.x) - 3.8)), grooveInCm.x, grooveInCm.y);\n\n    // speaker grooves\n    vec3 cpy = p;\n    cpy.z -= gameBoyHalfThickness;\n    cpy.y += 5.8;\n    cpy.x += 2.85;\n    pR(cpy.xy, radians(-29.));\n    pModInterval(cpy.x, 0.5, -2., 3.);\n    float insetDepth = 0.08;\n    r = max(r, -max(gameBoyHalfThickness - p.z - insetDepth, fBoxRound(cpy.xy, vec3(0.0, 0.7, 0.0).xy) - 0.15));\n\n    // window inset\n    const vec2 insetSize = vec2(7.7, 5.7);\n    const vec2 screenSize = vec2(4.7, 4.3);\n    p.y -= 3.3;\n    quadrant = sign(p.xy);\n    offset = 0.3;\n    if(quadrant.x == -1.0 && quadrant.y == -1.0)\n        offset = 1.0;\n    insetDepth = 0.02;\n    float ir = max(-p.z + gameBoyHalfThickness - insetDepth, fBoxRound(p.xy, insetSize / 2.0 - offset) - offset);\n    fOpIntersection(r, -ir, m, vec4(p, 1));\n\n    // screen inset\n    insetDepth = 0.05;\n    ir = max(-p.z + gameBoyHalfThickness - insetDepth, fBox(p.xy, screenSize / 2.0));\n    if(r <= -ir)\n        m = vec4(p, 2);\n    r = fOpIntersectionRound(r,-ir,insetDepth);\n\n    // battery\n    ir = fSphere(p - vec3(3.3, 0.7, gameBoyHalfThickness), 0.1);\n    fOpUnion(r, ir, m, vec4(2.0, 0.1, 0.1, -1));\n\n    // indent AB\n    p.xy += vec2(3.3, 5.5);\n    float radius = 3.5;\n    ir = fCapsule(p, vec3(0.0, 0.0, gameBoyHalfThickness + radius),\n                     vec3(1.55, -0.7, gameBoyHalfThickness + radius),\n                      radius + 0.1);\n    r = max(r, -ir);\n    // A & B buttons\n    fABButton(r, m, p);\n    p.xy += vec2(-1.55, 0.7);\n    fABButton(r, m, p);\n\n    // indent D-Pad\n    p.xy -= vec2(4.43, 0.25);\n    radius = 8.0;\n    ir = fSphere(p - vec3(0.0, 0.0, gameBoyHalfThickness + radius), radius + 0.1);\n    r = max(r, -ir);\n\n    // D-pad\n    const float buttonBevel = 0.06;\n    const float crossThickness = 0.28;\n    const float crossSize = 1.0;\n    const float curveRadius = 18.0;\n    const float dimpleCurveRadius = 0.2;\n\n    // create an infinite cross\n    vec2 q = abs(p.xy);\n    ir = max(-p.z, max(vmax(q) - crossSize, vmin(q) - crossThickness));\n    // dimple\n    ir = max(ir, 0.04 + dimpleCurveRadius - length(p - vec3(0.0, 0.0, gameBoyHalfThickness + gameBoyButtonPopOut + dimpleCurveRadius)));\n    // cut off the front with a curve\n    cpy = p;\n    cpy.z -= curveRadius + gameBoyHalfThickness + gameBoyButtonPopOut;\n    cpy.z = min(cpy.z, 0.0);\n    ir = fOpIntersectionRound(curveRadius - length(cpy), ir, buttonBevel);\n\n    fOpUnion(r, ir, m, vec4(p, 4));\n\n    // indent start and select\n    ir = fCapsule(p.xy, vec3(-1.05, -2.4, gameBoyHalfThickness).xy, vec3(-1.75, -2.05, gameBoyHalfThickness).xy, -0.05);\n    ir = min(ir, fCapsule(p.xy + vec2(1.55, 0.0), vec3(-1.05, -2.4, gameBoyHalfThickness).xy, vec3(-1.75, -2.05, gameBoyHalfThickness).xy, -0.05));\n    float squishy = 3.0;\n    r = fOpIntersectionChamfer(r * squishy, -ir, 0.37) / squishy;\n\n    // select\n    ir = fCapsule(p, vec3(-1.05, -2.4, gameBoyHalfThickness), vec3(-1.75, -2.05, gameBoyHalfThickness), 0.15);\n    fOpUnion(r, ir, m, vec4(p, 5));\n    // start\n    p.x += 1.55;\n    ir = fCapsule(p, vec3(-1.05, -2.4, gameBoyHalfThickness), vec3(-1.75, -2.05, gameBoyHalfThickness), 0.15);\n    fOpUnion(r, ir, m, vec4(p, 5));\n\n\n    return r;\n}\nfloat fGameboy(vec3 p){vec4 m;return fGameboy(p,m);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rayDir = normalize(vec3((fragCoord * 2.0 - iResolution.xy) / iResolution.y, 4.0));\n    vec3 rayOrigin = vec3(0.0, 0.0, -40.0);\n    float s,t=0.1;\n    vec4 m;\n    vec3 p;\n    for(int i = 0 ; i < 100 ; ++i)\n    {\n        p=rayOrigin+rayDir*t;\n        s=fGameboy(p,m);\n        if(s<0.0001)break;\n        t+=s;\n        if(t>100.)break;\n    }\n    vec2 e = vec2(0.001, 0.0);\n    vec3 n = normalize(vec3(fGameboy(p+e.xyy),fGameboy(p+e.yxy),fGameboy(p+e.yyx))-s);\n    \n    vec3 albedo = vec3(0.0);\n    float cosinePower = 100.0;\n    float specularity = 0.1;\n    vec3 additive = vec3(0.0);\n    \n    int objectId = int(m.w);\n    if(objectId==-1) // emissive\n    {additive = vec3(1.0, 0.05, 0.1);}\n    if(objectId==0) // body\n    {albedo = vec3(0.6, 0.55, 0.5); cosinePower = 20.0;}\n    if(objectId==1) // gray plate\n    {albedo = vec3(0.2); specularity = 0.3; cosinePower = 2000.0;}\n    if(objectId==2) // screen\n    {albedo = vec3(0.3, 0.5, 0.1);}\n    if(objectId==3) // AB\n    {albedo = vec3(0.5, 0.02, 0.15); specularity = 0.4;}\n    if(objectId==4) // D-pad\n    {albedo = vec3(0.1); specularity = 0.4;}\n    if(objectId==5) // start & select\n    {albedo = vec3(0.2); cosinePower = 1.0;}\n    \n    \n    vec3 L = normalize(vec3(-0.5, 0.3, -1.8));\n    vec3 col = dot(n,L) * albedo; // basic lambert\n    col *= (1.0 - specularity);\n    col += specularity * pow(max(0.0,dot(reflect(rayDir,n),L)), cosinePower); // basic phong\n    col += additive;\n    vec3 background = vec3(0.05, 0.1, 0.3);\n    col = mix(col * 1.5, background, pow(sat(t/100.),8.));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}