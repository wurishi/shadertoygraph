{"ver":"0.1","info":{"id":"l3VSWy","date":"1720462661","viewed":106,"name":"| Differential Filters |","username":"___lampada","description":"This shader implements diferential filters.","likes":2,"published":1,"flags":2,"usePreview":0,"tags":["imageprocessing","derivative","laplacian","laplacianoperator"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nConvolves differential 3x3 filters to a given input.\n\nThe filters available here are:\n- Laplacian\n- Sobel (https://en.wikipedia.org/wiki/Sobel_operator)\n*/\n\n\n\nfloat grayscale(vec3 p){\n    /*Convertes a given pixel to grayscale.\n    Parameters\n    ----------\n    \n    p : vec3\n        rgb pixel.\n    */\n    return 0.299*p.r + 0.587*p.g + 0.114*p.b;\n}\n\nmat3 laplacian(){\n    /*Returns a laplacian 3x3 filter.*/\n    mat3 lapl;\n\n    lapl[0] = vec3(0.0,  1.0, 0.0);\n    lapl[1] = vec3(1.0, -4.0, 1.0);\n    lapl[2] = vec3(0.0,  1.0, 0.0);\n    \n    return lapl;\n}\n\nmat3 sobelx(){\n    /*Returns an x-directional sobel 3x3 filter.*/\n    mat3 sx;\n    \n    sx[0] = vec3(1.0, 0.0, -1.0);\n    sx[1] = vec3(2.0, 0.0, -2.0);\n    sx[2] = vec3(1.0, 0.0, -1.0);\n    \n    return sx;\n}\n\nmat3 sobely(){\n    /*Returns a sobel y-directional 3x3 filter*/\n    mat3 sy;\n    \n    sy[0] = vec3( 1.0,  2.0,  1.0);\n    sy[1] = vec3( 0.0,  0.0,  0.0);\n    sy[2] = vec3(-1.0, -2.0, -1.0);\n    \n    return sy;\n}\n\nmat3 cell3x3(vec2 uv, sampler2D channel){\n    /*Returns a 3x3 cell of a given texture.\n    \n    Parameters\n    ----------\n    \n    uv : vec2\n        Pixel position.\n    channel : sampler2D\n        Texture sampler.\n    */\n    mat3 cell;\n    float stepx = 1.0/iResolution.x;\n    float stepy = 1.0/iResolution.y;\n    \n    cell[0] = vec3(grayscale(texture(channel, uv + vec2(-stepx, -stepy)).rgb),\n                   grayscale(texture(channel, uv + vec2(0.0, -stepy)).rgb ), \n                   grayscale(texture(channel, uv + vec2(+stepx, -stepy)).rgb));\n                   \n    cell[1] = vec3(grayscale(texture(channel, uv + vec2(-stepx, 0.0)).rgb ), \n                   grayscale(texture(channel, uv + vec2(0.0, 0.0)).rgb ), \n                   grayscale(texture(channel, uv + vec2(+stepx, 0.0)).rgb ));\n                   \n    cell[2] = vec3(grayscale(texture(channel, uv + vec2(-stepx, +stepy)).rgb ), \n                   grayscale(texture(channel, uv + vec2(0.0, +stepy)).rgb ), \n                   grayscale(texture(channel, uv + vec2(+stepx, +stepy)).rgb ));   \n    \n    return cell;\n}\n\n\nfloat convolve(mat3 filt, mat3 cell){\n    /*Convolves a 3x3 filter with a 3x3 texture cell.\n    \n    Parameters\n    ----------\n    filt : mat3 \n        filter.\n    cell : mat3 \n        texture cell. */\n    return dot(filt[0], cell[0]) + dot(filt[1], cell[1]) + dot(filt[2], cell[2]);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    mat3 cell = cell3x3(uv, iChannel2);\n                   \n    float resultx = convolve(sobelx(), cell); \n    float resulty = convolve(sobely(), cell);\n    \n    float theta = atan(resulty, resultx);\n    \n    vec2 dir = vec2(0.5, 0.5) + 0.5*vec2(cos(theta), sin(theta)); // Direction of the gradient\n    float intensity = sqrt(resultx*resultx + resulty*resulty); // Magnitude of the gradient\n    \n    fragColor = vec4(dir, 1.0, 1.0);\n    fragColor = vec4(vec3(intensity), 1.0);\n\n\n}","name":"Image","description":"","type":"image"}]}