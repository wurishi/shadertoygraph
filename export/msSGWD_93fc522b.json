{"ver":"0.1","info":{"id":"msSGWD","date":"1667663865","viewed":465,"name":"Strange Virus","username":"Poisson","description":"Some mandelbulbs in a spectral pathtracer.","likes":28,"published":1,"flags":32,"usePreview":1,"tags":["3d","raytracing","raymarching","fractal","raytracer","ray","gi","cloud","mandelbulb","dof","volumetric","raymarcher","bloom","path","spectral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// bloom function\nvec4 bloom(sampler2D sam, vec2 p) {\n    vec4 col = vec4(0);\n    for (int i=-2; i<=2; i++) {\n    for (int j=-2; j<=2; j++) {\n        vec2 of = vec2(i,j)*.01;\n        col += textureLod(sam, p+of, 4.);\n    }\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    \n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 col = data.rgb/data.a;\n    \n    vec4 blur = bloom(iChannel0, p);\n    vec3 bloom = blur.rgb/blur.a;\n    \n    // post proscessing effects\n    \n    col = pow(col,vec3(.4545)); // gamma correction\n    col += .4*bloom;\n    col = pow(col,vec3(.9,.85,.75)); // color grade\n    \n    if (abs(p.y-.5)>.4) col *= 0.; // black bars\n        \n    // output\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//#define MODEL\n\nfloat seed; // randoms seed\nint ray; // ray idx: red, green or blue\n\n// hash functions by me\nfloat hash1() {return fract(sin(seed+=.1)*4561.7564);}\n\nvec2 hash2() {return fract(sin(seed+=.1)*vec2(8472.5636,9854.4213));}\n\nvec3 hash3() {return fract(sin(seed+=.1)*vec3(7653.1285,6912.8512,5914.7134));}\n\n// random unit vector\nvec3 uniformVector() {\n    vec3 v = hash3()*2.-1.;\n    return normalize(v);\n}\n\n// lambertian diffuse BRDF\nvec3 cosineDirection(vec3 n) {\n  \tvec2 r = hash2();\n    \n\tvec3 u = normalize(cross(n, vec3(0,1,1)));\n\tvec3 v = cross(u, n);\n\t\n\tfloat ra = sqrt(r.y);\n\tfloat rx = ra*cos(2.*3.141592*r.x); \n\tfloat ry = ra*sin(2.*3.141592*r.x);\n\tfloat rz = sqrt(1.-r.y);\n\treturn normalize(rx*u + ry*v + rz*n);\n}\n\n// ray vs sphere intersection\n// thanks to iq: https://iquilezles.org/articles/intersectors/\nfloat sphIntersect(vec3 ro, vec3 rd, vec3 ce, float ra) {\n    vec3 oc = ro - ce;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - ra*ra;\n    float h = b*b - c;\n    if(h<0.) return -1.;\n    return 1.;\n}\n\n// mandelbulb distance function\n// thanks to iq again: https://www.shadertoy.com/view/ltfSWn\n// \"d\" is the scattered light\nfloat sdMandelbulb(vec3 p, vec3 d, bool n) {\n    vec3 w = p;\n    float m = dot(w,w);\n\n    vec4 trap = vec4(abs(w),m);\n\tfloat dz = 1.;\n    \n\tfor (int i=0; i<3; i++) {\n\t\tdz = 8.*pow(m,3.5)*dz + 1.;\n      \n        float r = length(w);\n        float b = 8.*acos(w.y/r);\n        float a = 8.*atan(w.x, w.z);\n        w = p + pow(r,8.) * vec3(sin(b)*sin(a), cos(b), sin(b)*cos(a));\n        \n        trap = min(trap,vec4(abs(w),m));\n\n        m = dot(w,w);\n\t\tif(m > 256.)\n            break;\n    }\n    float h = .1*hash1()*(n?0.:1.)*(ray==0 ? d.x : ray==1 ? d.y : d.z); // volumetric\n    return .25*log(m)*sqrt(m)/dz + h;\n}\n\n// scene\nfloat map(vec3 p, bool n) {\n    float d = 1e10;\n    \n    d = min(d, sdMandelbulb(p, vec3(1.8,1.3,1.1), n));\n    #ifndef MODEL\n    d = min(d, sdMandelbulb(p-vec3(2.6,-.5,.5), vec3(1.3,1.8,1.1), n));\n    d = min(d, sdMandelbulb(p-vec3(-2.3,-1,-1.2), vec3(1.8,1.1,1.3), n));\n    d = min(d, sdMandelbulb(p-vec3(-3,1.5,3.5), vec3(1.3,1.8,1.1), n));\n    d = min(d, sdMandelbulb(p-vec3(3,2.5,4.5), vec3(1.8,1.1,1.3), n));\n    d = min(d, sdMandelbulb(p-vec3(1,-3,4), vec3(1.8,1.3,1.1), n));\n    #endif\n    \n    return d;\n}\n\n// raymarching loop\nfloat intersect(vec3 ro, vec3 rd) {\n    float t = 0.;\n    for (int i=0; i<512 && t<64.; i++) {\n        vec3 p = ro + rd*t;\n        float h = map(p, false);\n        if (h<.0001) break;\n        t += h;\n    }\n    return t;\n}\n\nvec3 calcNormal(vec3 p) {\n    float h = map(p, true);\n    const vec2 e = vec2(.0001,0);\n    \n    return normalize(h - vec3(map(p-e.xyy, true),\n                              map(p-e.yxy, true),\n                              map(p-e.yyx, true)));\n}\n\n// shadow function\nfloat shadow(vec3 ro, vec3 rd) {\n    for (float t=.01; t<16.;) {\n        vec3 p = ro + rd*t;\n        float h = map(p, false);\n        if (h<.001) return 0.;\n        t += h;\n    }\n    return 1.;\n}\n\nconst vec3 sunDir = normalize(vec3(1,2,0)); // sun direction (it's not a sun)\n\n// draw a particle\nfloat particle(vec3 ro, vec3 rd, vec3 ce) {\n    return step(0., sphIntersect(ro, rd, ce,.03));\n}\n\n// main rendering function\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0);\n    vec3 tro = ro; // save the first ray origin\n    vec3 trd = rd; // save the first ray direction\n    for (int i=0; i<3; i++) { // GI bounces\n        float t = intersect(ro, rd);\n        if (t<64.) {\n            vec3 p = ro + rd*t;\n            vec3 n = calcNormal(p);\n            \n            ro = p+n*.01;\n            rd = cosineDirection(n);\n                \n            float dif = clamp(dot(n,sunDir),0.,1.); // diffuse light\n            float sha = shadow(p,sunDir); // shadow\n            col += dif*sha;\n        } else {\n            break;\n        }\n    }\n    #ifndef MODEL\n    // draw the particles\n    col += particle(tro, trd, vec3(-1.4,1.8,1));\n    col += particle(tro, trd, vec3(1,0,-2.5));\n    col += particle(tro, trd, vec3(-.8,0,-1.5));\n    col += particle(tro, trd, vec3(-.2,-.9,-2.5));\n    col += particle(tro, trd, vec3(.8,3,2));\n    col += particle(tro, trd, vec3(1,-1.2,-2));\n    #endif\n    \n    // glare\n    col += hash1()<.2*pow(clamp(dot(trd, sunDir),0.,1.),4.) ? 1. : 0.;\n    \n    return col;\n}\n\n// camera function\nmat3 setCamera(vec3 ro, vec3 ta) {\n\tvec3 w = normalize(ta - ro);\n\tvec3 u = normalize(cross(w, vec3(0,1,0)));\n\tvec3 v = cross(u, w);\n    return mat3(u, v, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = iTime+dot(sin(fragCoord),vec2(443.712,983.234)); // init randoms seed\n    seed += hash1()*434.251;\n    \n    vec2 of = hash2()-.5; // antialiasing offset\n    vec2 p = (fragCoord+of - .5*iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(0, -.75, -5.); // ray origin\n    vec3 ta = vec3(0); // target\n    \n    mat3 ca = setCamera(ro, ta); // camera matrix \n    vec3 rd = ca * normalize(vec3(p,1.)); // ray direction\n    \n    // depth of field\n    float t = intersect(ro, normalize(ta-ro)); // distance to the scene in the forward vector\n    vec3 fp = ro + rd*t; // focus plane;\n    ro += uniformVector()*.05; // offsetting the ray direction\n    rd = normalize(fp-ro);\n    \n    ray = 0; // red render\n    float r = render(ro/.99, rd).r;\n    ray = 1; // green render\n    float g = render(ro, rd).g;\n    ray = 2; // blue render\n    float b = render(ro*.99, rd).b;\n    vec3 col = vec3(r,g,b);\n    \n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    data += vec4(col,1);\n\n    // output\n    fragColor = data;\n}","name":"Buffer A","description":"","type":"buffer"}]}