{"ver":"0.1","info":{"id":"wsVGWw","date":"1570353383","viewed":225,"name":"Pepelatz warping","username":"StrangerintheQ","description":"https://www.youtube.com/watch?v=4d34j56ERU8\n\nhttps://codepen.io/strangerintheq/pen/YzzzpOy","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst vec3 lightPos  = vec3(0.,4.,-4.);\n\n\nvec3 palette(float i) {\n    float time = iTime;\n    float T = 1400. + 1300.*i; \n    vec3 L = vec3(4.4, 5.6 + sin(time)/2., 6.4 + sin(time/2.)); \n    L = pow(L,vec3(5.0)) * (exp(1.43876719683e5/(T*L))-1.0);\n    return 1.0-exp(-5e8/L); \n}    \n\nvec3 hash33(vec3 p) { \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\nfloat voronoi(vec3 p) {\n\tvec3 b, r, g = floor(p);\n\tp = fract(p); \n\tfloat d = 1.; \n\tfor(int j = -1; j <= 1; j++) {\n\t    for(int i = -1; i <= 1; i++) {\n\t\t    b = vec3(i, j, -1);\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 0.0;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 1.;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\t\n\t    }\n\t}\n\treturn d;\n}\n\nfloat noiseLayers(in vec3 p) {\n        float time = iTime;\n    vec3 t = vec3(0., 0., p.z+time*1.7); \n    float tot = 0., sum = 0., amp = 1.; \n    for (int i = 0; i < 11; i++) {\n        tot += voronoi(p + t) * amp; \n        p *= 2.0; \n        t *= 1.5; \n        sum += amp; \n        amp *= 0.5; \n    }\n    return tot/sum; \n}\n  \n\nfloat sdBox( vec3 p, vec3 b ){\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat dot2( in vec2 v ) { \n  return dot(v,v); \n}\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 ){\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nvec2 rotate(vec2 p, float ang) {\n    float c = cos(ang), s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nvec2 repeatAng(vec2 p, float n) {\n    float ang = 2.0*3.14/n;\n    float sector = floor(atan(p.x, p.y)/ang + 0.5);\n    return rotate(p, sector*ang);\n}\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat spikes(vec3 p, float r, float count) {\n    p.xz = repeatAng(p.xz, count);\n    return sdCappedCone(p - vec3(0., 1.27, r), .07, .06, .01);\n}\n\nfloat legs(vec3 p) {\n    p.xz = repeatAng(p.xz, 3.);\n    return sdBox(p+vec3(0., 1.03, -1.05), vec3(.16,.2,.15));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h ) {\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nvec2 map(vec3 p) {\n     float time = iTime;\n // pepelatz body\n    float d = sdCappedCone(p, 1.2, 1.2, 1.);\n    d = smin(d, legs(p), 0.01);\n    d = smin(d, sdCappedCone(p+vec3(0.,-1.35,0.), .16, .2, .187), 0.01);\n    \n    // door\n    vec3 pd = vec3(p.x,rotate(p.yz, -0.08));\n    d = smin(d, sdBox(pd+vec3(.0, 0.2, 1.), vec3(0.34,.7,.08)), 0.03);\n    vec3 pd1 = vec3(p.x,rotate(p.yz, 1.57));\n    d = smin(d, sdCappedCone(pd1 + vec3(0.,-1.,-0.3), .09, .15, .15), 0.1);\n    d = max(d, -sdCappedCone(pd1 + vec3(0.,-1.,-0.3), .12, .13, .13));\n    d = smin(d, sdCappedCone(pd+vec3(-0.1,0.9,1.1), .16, .02, .02), 0.02);\n    d = smin(d, sdCappedCone(pd+vec3( 0.0,0.9,1.1), .16, .02, .02), 0.02);\n    d = smin(d, sdCappedCone(pd+vec3( 0.1,0.9,1.1), .16, .02, .02), 0.02);\n      \n    // roof spikes\n    d = smin(d, spikes(p,0.94,50.), 0.01);\n    d = smin(d, spikes(p,0.80,45.), 0.01);\n    d = smin(d, spikes(p,0.65,35.), 0.01);\n    d = smin(d, spikes(p,0.45,25.), 0.01);\n\n    // antenna\n    vec2 r = rotate(p.xz, time*3.);\n    vec3 pa = vec3(r.x, p.y-1.55, r.y);\n    vec3 pa1 = vec3(pa.x,rotate(pa.yz, 1.57));\n    pa1.z -= 0.2;\n    d = smin(d, sdBox(pa, vec3(0.01,.1,.1)), 0.01);\n    d = smin(d, sdBox(pa, vec3(0.1,.01,.7)), 0.01);\n    d = smin(d, sdCappedCone(pa1-vec3(0.,0.05,0.), .2, .1, .1), 0.1);\n    d = max(d, -sdCappedCone(pa1, .30, .09, .09));\n    d = max(d, -sdBox(pa1-vec3(-0.08,0.,-0.1), vec3(0.08,.3,.09)));  \n\n\n\n    return vec2(d, 2.5);\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size) {\n    vec2 xy = gl_FragCoord.xy - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(0.0, 0.0, 0.0, 1)\n\t);\n}\n\nvec2 castRay( vec3 ro, vec3 rd ) {\n    float tmin = 1.0;\n    float tmax = 32.0;\n    float t = tmin;\n    float m = -1.0;\n    for ( int i=0; i<64; i++ ) {\n\t    float precis = 0.0001*t;\n\t    vec2 res = map( ro+rd*t );\n        if ( res.x<precis || t>tmax )\n            break;\n        t += res.x;\n\t    m = res.y;\n    }\n    if ( t>tmax )\n        m=-1.0;\n    return vec2( t, m );\n}\n\nconst float NORMAL_EPSILON = 0.0005;\n\nvec3 estimateNormal(vec3 pos) {\n    vec2 e = vec2(1.0,-1.0)*0.5773*NORMAL_EPSILON;\n    return normalize( e.xyy*map( pos + e.xyy ).x +\n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x +\n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x +\n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nconst vec3 K_a = vec3(.5, .5, .5);\nconst vec3 K_d = vec3(.5, .5, .5);\nconst vec3 K_s = vec3(.0, .0, .0);\n\nconst float shininess = 3.5;\nconst vec3 lightIntensity = vec3(1., 1., 1.);\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, \n                          vec3 p, vec3 N, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    if (dotLN < 0.0) \n        return vec3(0.0, 0.0, 0.0);\n    if (dotRV < 0.0) \n        return lightIntensity * (k_d * dotLN);\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, \n                       float alpha, vec3 p, vec3 nor, \n                       vec3 eye, vec3 materialColor) {\n    vec3 color = materialColor * k_a;\n    color += phongContribForLight(k_d, k_s, alpha, p, nor, eye, \n                                  lightPos, lightIntensity);\n    return color;\n}\n\nvec3 decodeMaterial(float m) {\n    return vec3(1.-m/3.);\n}\n\nvec3 phong(vec3 p, vec3 nor, vec3 eye, float material) {\n    vec3 materialColor = decodeMaterial(material);\n    return phongIllumination(K_a, K_d, K_s, shininess, p, nor, eye, materialColor);\n}\n\nfloat softShadow( in vec3 ro, in vec3 rd, in float mint, in float tmax ){\n\t  float res = 1.0;\n    float t = mint;\n    for( int i=0; i!=16; i++ ) {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat ao( vec3 pos, vec3 nor ){\n\t  float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i!=5; i++ ){\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\nfloat fbm( vec3 p, vec3 n )\n{\n\tp *= 0.25;\n\tfloat x = noise(  p.yz );\n\tfloat y = noise(  p.zx );\n\tfloat z = noise(  p.xy );\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\n\nvec3 doBumpMap( in vec3 pos, in vec3 nor ){\n    float e = 0.0015;\n    float b = 0.01;\n    \n\tfloat ref = fbm( 28.0*pos, nor );\n    vec3 gra = -b*vec3( fbm(28.0*vec3(pos.x+e, pos.y, pos.z),nor)-ref,\n                        fbm(28.0*vec3(pos.x, pos.y+e, pos.z),nor)-ref,\n                        fbm(28.0*vec3(pos.x, pos.y, pos.z+e),nor)-ref )/e;\n\t\n\tvec3 tgrad = gra - nor * dot ( nor , gra );\n    return normalize ( nor - tgrad );\n}\n\n\n  \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float time = iTime;\n    float r = sin(time)*7. + 15.;\n    vec3 eye = vec3(sin(time)*r,5.,cos(time)*r);\n\tvec3 lookAt = vec3(0.,2.,0.);\n\n\tvec3 direction = rayDirection(60.0, iResolution.xy);\n    mat4 viewToWorld = viewMatrix(eye, lookAt, vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = (viewToWorld * vec4(direction, 0.0)).xyz;\n    vec2 dist = castRay(eye, worldDir);\n    if (dist.x > 32.) {\n        vec2 uv = (fragCoord.xy - iResolution.xy*0.5)/ iResolution.y;\n        uv += vec2(sin(time/7.)*0.1,cos(time/3.)*0.15);\n    float cs = cos(time/5.0), \n        si = sin(time/2.0);\n    uv.xy *= mat2(cs, -si, si, cs); \n        vec3 rd = normalize(vec3(uv.x, uv.y, 3.1415/(75.+sin(time)*32. + cos(time*10.)*3.)));\n        float d = noiseLayers(rd*2.);\n        fragColor = vec4(sqrt(palette(d)), 1.); \n        fragColor /= sqrt(sqrt(dot(uv, uv)));\n    } else {\n        vec3 pt = eye + dist.x * worldDir;\n        vec3 nor = estimateNormal( pt );\n          nor = doBumpMap(pt, nor);\n        float occ = ao( pt, nor );\n        float shadow = softShadow( pt, normalize(lightPos-pt), 0.1, 22.2);\n        vec3 color = phong(pt, nor, eye, dist.y)*sqrt(occ);\n        color += color * shadow;\n        fragColor = vec4(color, 1.0);\n    }\n\n}","name":"Image","description":"","type":"image"}]}