{"ver":"0.1","info":{"id":"7ddXDr","date":"1633111590","viewed":117,"name":"Alhambra Wine Gate fresco","username":"curena","description":"Reconstruction of the damaged fresco remains with periodic arc ribbons motif found on the Alhambra's Wine Gate south facade.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["tilings","symmetry","alhambra"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// -----------------------------------------------------------------------------------\n//\n// ALHAMBRA PATTERNS\n// Alhambra Wine Gate ribbons\n//\n// A model for reconstructng the fresco with periodic arc ribbons found on the Alhambra's \n// Wine Gate south facade.\n//\n// * The pattern has 'pg' symmetry, taking into account the correct, alternating, \n//   ribbons overlap rules.\n// * however, it has 'cm' symmetry, when ribbons overlaps are forgotten.\n//\n// Based on the analysis done by L.Bodner:\n//\n// B. Lynn Bodner. The Planar Crystallographic Groups Represented at the Alhambra\n// Proceedings of Bridges 2013: Mathematics, Music, Art, Architecture, Culture (2013),\n// Pages 225–232 Regular Papers\n// https://archive.bridgesmathart.org/2013/bridges2013-225.html\n//\n// Also based on additional insight by Alvaro M. Sevilla.\n//\n// This reconstruction was designed independently to a related (not exactly similar), \n// much earlier reconstruction by M. Dolores Martínez Aires and Rafael Pérez-Gómez, \n// which can be seen here:\n//\n// Alhambra, Belleza Abstracta. Ed. Patronato de la Alhambra y Generalife. Año: 2019\n// 408 pages. ISBN: 978-84-17518-07-3.\n// https://www.alhambra-patronato.es/publicaciones/alhambra-belleza-abstracta\n// https://docplayer.es/26171294-Un-matematico-pasea-por-la-alhambra.html\n// \n// This reconstruction was designed independently to a exactly similar reconstruction by \n// Manuel Martinez Vela, which can be seen here: \n//\n// The Alhambra with a Ruler and Compass: A step-by-step outlining of tilling and plasterwork\n// Manuel Martínez Vela. Ed Almizate, 3rd ed. (first ed. June 2022), 228 pages. ISBN 9788412066838.\n// https://www.agapea.com/Manuel-Martinez-Vela/The-Alhambra-with-a-Ruler-and-Compass-A-step-by-step-outlining-of-tilling-and-plasterwork-9788412066838-i.htm\n//\n// Source code by Carlos Ureña, Sept-Oct. 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// -----------------------------------------------------------------------------------\n\n\n\n// ------------------------------------------------------------------------------------\n// configurable constants (visualization)\n\nconst int   nspp_root        = 5 ;      // root of the number of samples per pixel \nconst bool  schematic_view   = false;   // set to true to highlight fundamental region and reflection axes\nconst float vis_width        = 11.6 ;   // visible region width in world coordinates  (size in X)\nconst float vis_width_schem  = 3.4 ;    // idem (for the schematic view)\nconst float arcs_width       = 0.18 ;   // arcs width\nconst float yellow_bands_wr  = 0.25  ;  // ratio of yellow bands width w.r.t. arcs_width\nconst float grid_edges_width = 0.0015 ; // grid edges widths for schematic view\n\nconst float vis_wcc_sx       = schematic_view ? vis_width_schem : vis_width;   \n\n// colors for 'normal' view\nconst vec4 black_color      = vec4( 0.0, 0.0, 0.0, 1.0 );     // dark or black colour \nconst vec4 dark_red_color   = vec4( 0.60, 0.10, 0.40, 1.0 );  // dark red-magenta colour\nconst vec4 yellow_color     = vec4( 0.90, 0.75, 0.30, 1.0 );  // dark yellow (gold like) colour\nconst vec4 background_color = vec4( 0.75, 0.80, 0.80, 1.0 );  // gray-greenish color for background\n\n// colors for schematic view \n\nconst vec4 sv_black_color      = vec4( 0.30, 0.30, 0.30, 1.0 );\nconst vec4 sv_dark_red_color   = vec4( 0.60, 0.60, 0.60, 1.0 );  \nconst vec4 sv_yellow_color     = vec4( 0.80, 0.80, 0.80, 1.0 );  \nconst vec4 sv_background_color = vec4( 0.90, 0.90, 0.90, 1.0 );  \nconst vec4 sv_fr_edge_color    = vec4( 0.50, 0.20, 0.20, 1.0 );  \n\n// ------------------------------------------------------------------------------------\n// other (fixed) constants \n\n// related to antialiasing\n\nconst int   nspp        = nspp_root*nspp_root; // number of samples per pixel\nconst float nspp_root_f = float(nspp_root);    // root of number of samples per pixel (as a float)\n\n// the inner ac radius is computed as the diagonal length minus the yellow band width\nconst float inner_arcs_radius = 0.25*sqrt(2.0) - yellow_bands_wr*arcs_width ;\n\n// rmin, rmax == minimun and maximun radiuses for points in the arcs\n\nconst float rmin = inner_arcs_radius ;\nconst float rmax = min( 0.95, rmin + arcs_width );\n\n// ------------------------------------------------\n// point coordinates in its orbit \n\nbool  glide ;\nivec2 pct_inte_i ;\nvec2  pct_frac ;\n\n// ------------------------------------------------------------------------------------\n//\n// compute point in the orbit of 'point_wcc', and also in the fundamental region\n// (by using 'pg' symmetry group)\n//\n// returns the point in the FR\n// (also writes 'glide', 'pct_inte_i', 'pct_frac')\n\nvec2 pg_ToFundamental( in vec2 point_wcc )\n{\n        \n    vec2 pct_inte = floor( point_wcc );\n          \n    pct_frac    = point_wcc - pct_inte ;\n    pct_inte_i  = ivec2( int( pct_inte.x ), int( pct_inte.y ) ) ;\n    \n    // glide is true iif the point must be transformed by the pg group's glide transform \n    // (in order to take it to the fundamental region)\n    // that is, it is true iif the point is above y==0.5 line,  \n    glide = (0.5 <= pct_frac.y) ;\n    \n    return glide ? vec2( 1.0-pct_frac.x, pct_frac.y-0.5 ) : pct_frac ;  \n}\n\n\n// --------------------------------------------------------------------------------\n\nvec4 WineDoorPatternWCC( in vec2 point_wcc )\n{ \n    // compute 'pc_fr' (== point in the orbit of point_wcc, and also in the fundamental region\n    // (this also computes glide, pct_inte_i, pct_frac)\n    vec2 pc_fr = pg_ToFundamental( point_wcc );\n       \n    \n    \n    // p = pc_fr, but mirrored (around x==0.75) when pc_fr.x is beyond 0.75\n    // (this uses the symmetry in the right halve of the fundamental region)\n    \n    vec2 p = vec2( (pc_fr.x <= 0.75) ? pc_fr.x : 1.5-pc_fr.x , pc_fr.y );\n    \n    // classify regions\n    bool in_fundamental = (pct_inte_i.x == 0) && (pct_inte_i.y == 0) && ( ! glide ) ;\n    bool in_fr_edges    = ( pc_fr.x <= grid_edges_width || 1.0-pc_fr.x <= grid_edges_width ||\n                            pc_fr.y <= grid_edges_width || 0.5-pc_fr.y <= grid_edges_width ) ;\n    \n    float r1   = length( p );\n    float r2   = length( p-vec2(0.5,0.0) ) ;\n    float r3   = length( p-vec2(1.0,0.5) ) ;\n    float rnc  = min( r1, min( r2, r3 )) ;    // radius to nearest center\n      \n    bool in1 = (rmin <= r1) && (r1 <= rmax) ;\n    bool in2 = (!in1) && (rmin <= r2) && (r2 <= rmax) && ( r2 <= r3);\n    bool in3 = (rmin <= r3) && (r3 <= rmax) && (r3 < r2 ) ;\n    \n    bool in_background  = (! in1) && (! in2) && (!in3) ;\n    \n    float rad = in1 ? r1 : (in2 ? r2 : r3) ;\n    float drn = (rad-rmin)/(rmax-rmin) ;\n        \n    const float w = 0.010 ;\n    \n    /// s = distance to thin black lines inside arcs ('black arcs')\n    float s = min( min( abs(drn-w), abs(drn-yellow_bands_wr) ),\n                   min( abs(drn-(1.0-yellow_bands_wr)), abs(drn-(1.0-w)) )  );\n\n    bool in_black_arcs  = (! in_background) && ( s <= w ) ;\n    bool in_yellow_arcs = (! in_background) && (! in_black_arcs) && ( (drn <= yellow_bands_wr) || ((1.0-yellow_bands_wr) <= drn) ) ;\n    bool in_red_arcs    = (! in_background) && (! in_black_arcs) && (! in_yellow_arcs) ;\n    \n    vec4 col ;\n    bool near_center = ( rnc <= 0.01 ); // true iif 'p' near the center of any point ...\n    \n    if ( schematic_view )\n    {\n        if ( in_black_arcs )       col = sv_black_color ; \n        else if ( in_yellow_arcs ) col = sv_yellow_color ; \n        else if ( in_red_arcs )    col = sv_dark_red_color ; \n        else if ( in_background )  col = sv_background_color ; \n         \n        col = in_fundamental ? vec4( 1.0, 0.7*col.r, 0.7*col.b, 1.0 ) : col ;\n        //col = near_center ? 0.5*col : col ;\n        col = in_fr_edges ? vec4( 0.8, 0.5*col.g, 0.5*col.b, 1.0 ) : col ;\n        \n    }\n    else \n    {\n        if ( in_black_arcs )        col = black_color ; \n        else if ( in_yellow_arcs )  col = yellow_color ; \n        else if ( in_red_arcs )     col = dark_red_color ; \n        else if ( in_background )   col = background_color ; \n    }\n    \n    return col ;\n}\n\n\n// ------------------------------------------------------------------------------------\n// Computes the point colour\n\nvec4 PointColor_WCC( in vec2 point_wcc )\n{\n   return WineDoorPatternWCC( point_wcc );\n}\n\n\n// ------------------------------------------------------------------------------------\n// Compute anti-aliased pixel colors for a point given in device coordinates\n// point_dcc = integer pixel coordinates, starting at zero (device coordinates)\n\nvec4 AAPixelColor( in vec2 point_dcc )\n{\n    vec4 sum  = vec4( 0.0, 0.0, 0.0, 1.0 ); // sum of samples colours \n     \n    for( int i = 0 ; i < nspp_root ; i++ )\n    for( int j = 0 ; j < nspp_root ; j++ )\n    {\n       // compute sample position in device coordinates, then in world coordinates\n       vec2 sample_dcc = point_dcc + (vec2(float(i)+0.5,float(j)+0.5)/nspp_root_f) ;\n       vec2 sample_wcc = vis_wcc_sx*(sample_dcc-0.5*iResolution.xy)/iResolution.xx ;\n       \n       // add this sample color to 'sum' \n       sum = sum + PointColor_WCC( sample_wcc +vec2( 0.5,0.25) ); // add this vector in order to center fund. region on the viewport\n    }\n    return sum/float( nspp_root*nspp_root ) ;\n}\n//-------------------------------------------------------------------------------------\n// main function\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // initialize 'c' and 's'\n    \n    \n    fragColor = AAPixelColor( fragCoord ) ;\n    \n}","name":"Image","description":"","type":"image"}]}