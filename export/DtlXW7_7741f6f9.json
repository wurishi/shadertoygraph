{"ver":"0.1","info":{"id":"DtlXW7","date":"1674888259","viewed":100,"name":"flakes_metallic","username":"HunterX","description":"flake base of VRay","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["cellnoise","flake"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"flakes\" by HunterX. https://shadertoy.com/view/DlX3z2\n// 2023-01-28 06:41:56\n\nvec3 hash( vec3 p ) \n{ \n\tfloat a=dot(p,vec3(127.1,311.7,1.0));\n\tfloat b=dot(p,vec3(269.5,183.3,1.0));\n\tp=vec3(a,b,1.0); \n    float mul=43758.5453;\n    float scale=0.05;\n\treturn fract(sin(p)*mul*scale); \n}\n\n// return distance, and cell id\nvec3 cellnoise( in vec3 x )\n{\n    vec3 n = floor( x );\n    vec3 f = fract( x );\n\n    vec4 m = vec4( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 g = vec3( float(i), float(j) ,1.0);\n        vec3  o = hash( n + g );\n        vec3  r = g - f + o;\n        float d = dot( r, r );\n        if( d<m.x )\n            m = vec4( d, o );\n    }\n    return vec3( sqrt(m.x), m.y, 1.0);\n}\n\n\nvec3 generateFlakes(vec2 p)\n{\n\tvec3 color;\n\tfloat flake_scale =50.0;\n    float flake_size = 0.5 ;\n    float flake_size_variance = 0.0;\n    float flake_normal_orientation = 0.1 ;\n\n\tfloat safe_flake_size_variance = clamp(flake_size_variance, 0.1, 1.0);\n\n\tvec3 cellCenters[9] ;\n\tcellCenters[0]=\t\tvec3( 0.5,  0.5,  0.0);\n\tcellCenters[1]= \tvec3( 1.5,  0.5,  0.0);\n\tcellCenters[2]=  \tvec3( 1.5,  1.5,  0.0);\n\tcellCenters[3]=     vec3( 0.5,  1.5,  0.0);\n\tcellCenters[4]=     vec3(-0.5,  1.5,  0.0);\n\tcellCenters[5]=     vec3(-0.5,  0.5,  0.0);\n\tcellCenters[6]=     vec3(-0.5, -0.5,  0.0);\n    cellCenters[7]=  \tvec3( 0.5, -0.5,  0.0);\n\tcellCenters[8]=     vec3( 1.5, -0.5,  0.0);\n\n\t vec3 position = vec3( p,0.0);\n     position = flake_scale * position;\n     \n    vec3 base = floor(position);\n         \n    vec3 nearestCell = vec3(0.0, 0.0, 1.0);\n    int nearestCellIndex = -1;\n    for(int cellIndex = 0; cellIndex < 9; ++cellIndex)   \n    {\n        vec3 cellCenter = base + cellCenters[cellIndex];\n         \n        vec3 centerOffset = cellnoise(cellCenter) * 2.0 - 1.0;\n        centerOffset[2] *= safe_flake_size_variance;\n        centerOffset = normalize(centerOffset);\n         \n        cellCenter += 0.5 * centerOffset;\n        float cellDistance = distance(position, cellCenter);\n        if(cellDistance < flake_size && cellCenter[2] < nearestCell[2]) {\n            nearestCell = cellCenter;\n            nearestCellIndex = cellIndex;\n        }\n\n    }\n\t//color = vec3(0.5,0.5,1.0);\n    color=vec3(0.0,0.0,0.0);  //非闪粉部分的金属值\n    if (nearestCellIndex != -1) {\n        vec3 randomNormal = cellnoise(base + cellCenters[nearestCellIndex] + vec3(0.0, 0.0, 1.5));\n        randomNormal = 2.0 * randomNormal - 1.0;\n        randomNormal = normalize(mix(randomNormal, vec3(0.0, 0.0, 1.0), flake_normal_orientation));\n\n  //      color = vec3(0.5*randomNormal[0]+0.5, 0.5*randomNormal[1]+0.5, randomNormal[2]);\n        color=vec3(1.0,1.0,1.0);  //闪粉部分的金属值\n\n    }\n\t\n\treturn color;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy/max(iResolution.x,iResolution.y);\n    \n\n    fragColor=vec4(generateFlakes( p),1.0);\n}","name":"Image","description":"","type":"image"}]}