{"ver":"0.1","info":{"id":"XcKXDw","date":"1715272358","viewed":80,"name":"4D Tetrahedra SDF","username":"TwentySeven","description":"Press space and move the mouse to rotate in four dimensions. WASD to move. QE to move 4D. and RF to move up and down.\n","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["4d"],"hasliked":0,"parentid":"lcGXDh","parentname":"4D Shapess"},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//Ray March Settings\n#define STEPS 64\n#define EPS 0.001\n \n//Render Settings\n#define AO_STRENGTH 0.5\n#define SHADOWBLUR 0.01\nconst vec4 lidir= vec4(3,4,-5,3);\n//Volume Mode\n//#define SmoothAxis\n#define BLUR 1\n#define BLURWIDTH PI/2.\nvec4 cross4D(in vec4 u, in vec4 v, in vec4 w) {\n    float a=v.x*w.y-v.y*w.x, b=v.x*w.z-v.z*w.x, c=v.x*w.w-v.w*w.x,\n          d=v.y*w.z-v.z*w.y, e=v.y*w.w-v.w*w.y, f=v.z*w.w-v.w*w.z;\n    return vec4( u.y*f - u.z*e + u.w*d,\n                -u.x*f + u.z*c - u.w*b,\n                 u.x*e - u.y*c + u.w*a,\n                -u.x*d + u.y*b - u.z*a);\n}\nfloat triangle(vec4 p, vec4 a, vec4 b, vec4 c){\nvec4 ba=b-a,cb=c-b,ac=a-c,pa=p-a,pb=p-b,pc=p-c;\nvec4 flnor = vec4(cross(ba.xyz,ac.xyz),0.);\nvec4 nor = cross4D(flnor,ba,ac);\nfloat pl1 =abs(dot(pa,normalize(nor)));\nfloat pl2=abs(dot(pa,normalize(flnor)));\nreturn  \n         (sign(dot(cross4D(ba,nor,flnor),pa)) + \n          sign(dot(cross4D(cb,nor,flnor),pb)) + \n          sign(dot(cross4D(ac,nor,flnor),pc))<3.0) \n?min(length(pa-(ba*clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 ))),\nmin( length(pb-(cb*clamp( dot(pb,cb)/dot(cb,cb), 0.0, 1.0 ))),\n     length(pc-(ac*clamp( dot(pc,ac)/dot(ac,ac), 0.0, 1.0 ))))):\nlength(vec2(pl1,pl2))\n\n;} \nfloat tetrahedron(vec4 p, vec4 a, vec4 b, vec4 c, vec4 d){\n\nvec4 ba=b-a,cb=c-b,dc=d-c,ad=a-d,pa=p-a,pb=p-b,pc=p-c,pd=p-d;\nvec4 nor = cross4D(a-b,a-c,a-d);\n\nreturn   (sign(dot(cross4D(ba,-nor,ad),pa)) + \n          sign(dot(cross4D(cb,nor,ba),pb)) + \n          sign(dot(cross4D(dc,-nor,cb),pc)) + \n          sign(dot(cross4D(ad,nor,dc),pd))<4.0) ?\n    min(min(triangle(p,a,b,c),triangle(p,b,c,d)),min(triangle(p,c,d,a),triangle(p,d,a,b))):\n    abs(dot(p-a,normalize(nor)));\n\n}\n\n\n\nvec4 sdf(vec4 p){\n//Object SDF\nfloat obj=tetrahedron(p,\nvec4( 1, 0, 3, 1),\nvec4(-1, 0, 3,-1),\nvec4( 0, 1, 1, 1),\nvec4( 0,-1, 1,-1))-.1;\n\n\n\nvec3 col = form(obj,vec3(1,0,0));\nvec3 checker=(mod(round(p.x+.502)+round(p.y+.502)+round(p.z+.502)+round(p.w+.502),2.)>.5)?\nvec3(1):vec3(0.9);\nreturn vec4(sat(col)*checker,obj);\n\n}\n\nvec4 normal(vec4 p, float dist, float eps){\nreturn normalize(vec4(\nsdf(p+vec4(eps,0,0,0)).w-sdf(p+vec4(-eps,0,0,0)).w,\nsdf(p+vec4(0,eps,0,0)).w-sdf(p+vec4(0,-eps,0,0)).w,\nsdf(p+vec4(0,0,eps,0)).w-sdf(p+vec4(0,0,-eps,0)).w,\nsdf(p+vec4(0,0,0,eps)).w-sdf(p+vec4(0,0,0,-eps)).w));}\nmat4x4 march(Ray Camera, int steps){\nfloat t, h,hit=0.;\nvec4 p = Camera.ori;\nvec4 d=normalize(Camera.dir);\nvec3 c= vec3(0);\nvec4 n=vec4(0);\nint stpcnt=0;\nfor(int i = 0;i<steps; i++){\nt=sdf(p).w;\np=p+(d*t);\nh=length(p-Camera.ori);\nstpcnt+=1;\nif(t<EPS)hit=1.;\nif(t<EPS||h>500.)\n\nbreak;}\nn=normal(p,h,EPS);\nc=sat(sdf(p).xyz);\nreturn mat4(p.x,n.x,c.x,h,p.y,n.y,c.y,t,p.z,n.z,c.z,stpcnt,p.w,n.w,0,hit)\n;\n}\nfloat isinshadow( in vec4 ro, in vec4 d, float mint, float maxt, float w ){\n    float res = 1.0;\n    float ph = 1e20;\n    float t = mint;\n    for( int i=0; i<STEPS && t<maxt; i++ )\n    {\n        float h = sdf(ro + d*t).w;\n        \n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, d/(w*max(0.0,t-y)) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\nfloat AO( in vec4 pos, in vec4 nor ){\n\tfloat occ = 0.0;\n    float sca = 1.0;\n  \n        float h = AO_STRENGTH;\n        float d = sdf( pos + (nor*h) ).w;\n        sca *= 0.5;\n    occ += (h-d)*sca;\n    \n    \n    return smoothstep(0.,1.,clamp( 1.0 - 1.5*occ, 0.0, 1.0 ));    \n}\nRender TurnToRender(Ray Cam, vec4 Lightpos,int steps){\nmat4 ma = march(Cam,steps);\nreturn Render(Cam,\ngetdis(ma),\ngetpos(ma),\ngetcol(ma),\ngetnor(ma),\nnormalize(Lightpos),\ngethit(ma)==1.);\n}\nRay Bounce(Ray r, int steps){\nmat4 ma = march(r, steps);\nreturn Ray(getpos(ma)+(getnor(ma)/10.),reflect(r.dir,getnor(ma)));\n}\nvec3 draw(Render Scene){\nvec3 clmov=vec3(iTime/100.,iTime/140.,iTime/200.);\nvec4 di=Scene.Camera.dir;\nfloat up=dot(di,vec4(0,1,0,0));\nfloat shadows=mix(0.5,1.,isinshadow(Scene.Position+(Scene.Normal/200.),Scene.LightDirection,0.,100.,SHADOWBLUR));\nfloat shading = sat((dot(Scene.Normal,Scene.LightDirection)+2.)/3.);\nvec3 col = sat(AO(Scene.Position,Scene.Normal))*sat(Scene.Color*shading*shadows);\nfloat cl1=texture(iChannel1,clmov.xzx+di.xzw*(1./up)).x;\nfloat cl2=texture(iChannel1,clmov.xyx+di.xzw*(.5/up)).y;\nfloat cl3=texture(iChannel1,clmov.xxx+di.xzw*(.25/up)).z;\nfloat cl4=texture(iChannel1,clmov.yzx+di.xzw*(.125/up)).w;\nfloat clouds = ((cl1+cl2+cl3+cl4)/3.)*mix(0.5,1.,up);\nvec3 sky =\nmix(vec3(.1,.3,.5),vec3(.4,.7,1),(1.+up)/2.)+\nmix(vec3(0,0,0),vec3(1,1,0),smoothstep(0.999,1.,dot(di,Scene.LightDirection)));\n\nvec3 skybox=max(sat(sky),dot(di,vec4(0,1,0,0))>0.?clouds:0.);\nreturn gethit(march(Scene.Camera,128))==1.?col:skybox;}\n\nvec4 loadValue4(in vec2 re){return texture(iChannel0,(.5+re)/iChannelResolution[0].xy,-100.).xyzw;}\nvec3 loadValue3(in vec2 re){return texture(iChannel0,(.5+re)/iChannelResolution[0].xy,-100.).xyz;}\nvec2 loadValue2(in vec2 re){return texture(iChannel0,(.5+re)/iChannelResolution[0].xy,-100.).xy;}\n//mainimage down here\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\nvec2 screen=(fragCoord/iResolution.xy);\n    vec2 uv =\n\n    ((fragCoord-(iResolution.xy/2.))/128.);\n    float u=uv.x,v=uv.y;\n    vec4 campos= (loadValue4(vec2(0,0)))/128.;\n    vec2 mou = loadValue2(vec2(1,0));\nvec4 blue=(texture(iChannel2,fragCoord/iChannelResolution[2].xy));\nfloat[4] ob=float[4](blue.x,blue.y,blue.z,blue.w);\n    mou*= TAU;\n \n    mat4 camrom = mat4(loadValue4(vec2(11,0)),loadValue4(vec2(12,0)),loadValue4(vec2(13,0)),loadValue4(vec2(14,0)));\n    mat4 camrom2 = mat4(loadValue4(vec2(15,0)),loadValue4(vec2(16,0)),loadValue4(vec2(17,0)),loadValue4(vec2(18,0)));\n#ifdef SmoothAxis\nfloat std=1.;\n    vec4 dirc = vec4(uv,1,0.);\n    fragColor=vec4(0);\nvec4 camdir =normalize(dirc)*camrom2*camrom;\nRay Cam = Ray(campos,normalize(vec4(uv,1,0.))*camrom2*camrom);\nRender Scene = TurnToRender(Cam,lidir,STEPS);\nRender Scene1;\nvec3 col=draw(Scene);\nvec3 col2=draw(Scene);\n\nfloat dith=(texture(iChannel3,(fragCoord/iChannelResolution[3].xy)).x*2.)-1.;\n\nfloat sfd=00.;\nfor(int i = 0; i<int(BLUR); i++){\n//float var=mix(-BLURWIDTH,BLURWIDTH,(dith+(float(i)/float(BLUR)))/2.);\nfloat var=mix(-BLURWIDTH,BLURWIDTH,(blue.x/float(BLUR))+(float(i)/float(BLUR)));\ndirc = normalize(vec4(uv*cos(var),cos(var),sin(var)));\nsfd=Scene1.Depth;\n\n\n    camdir =dirc*camrom2*camrom;\n   Cam = Ray(campos,camdir);\n\n   Scene1 = TurnToRender(Cam,vec4(1.,1.5,-0.5,0.25),STEPS);\n\nif((Scene1.Depth>min(sfd,Scene.Depth))||!Scene1.Hit)continue;\ncol2=draw(Scene1);\n\n\n\n\n\n    }\n    fragColor = vec4(col2,1.0);\n    \n\n\n#else\n    vec4 dirc = vec4(uv,1,0.);\n    vec4 camdir =normalize(dirc)*camrom2*camrom;\n    Ray Cam = Ray(campos,camdir);\n    Render Scene = TurnToRender(Cam,lidir,STEPS);\n    vec3 col =draw(Scene);\n    fragColor = vec4(col,1.0);\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define TAU 6.28318530718\n#define PI 3.14159265359\n#define revolve(a,b) length(vec2(a,b))\n#define pmod(a,b) (mod(a+(b/2.),b)-(b/2.))\n#define sat(value) clamp(value,0.,1.)\n\nstruct Ray{\nvec4 ori;\nvec4 dir;\n};\n\n\nstruct Render{\nRay Camera;\nfloat Depth;\nvec4 Position;\nvec3 Color;\nvec4 Normal;\nvec4 LightDirection;\nbool Hit;\n};\n\n\n\n\n\n\n//Matrix Stuffs\nmat4 RotationMatrix(vec3 axis, float angle){\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,0,\n                0,0,0,1);\n}\nmat4 RotateXW(float angle){\nfloat s=sin(angle);\nfloat c=cos(angle);\nfloat oc=1.-c;\nreturn mat4(c,0,0,-s,0,1,0,0,0,0,1,0,s,0,0,c);}\nmat4 RotateZW(float angle){\nfloat s=sin(angle);\nfloat c=cos(angle);\nfloat oc=1.-c;\nreturn mat4(1,0,0,0,0,1,0,0,0,0,c,-s,0,0,s,c);}\nmat4 RotateYW(float angle){\nfloat s=sin(angle);\nfloat c=cos(angle);\nfloat oc=1.-c;\nreturn mat4(1,0,0,0,0,c,0,-s,0,0,1,0,0,s,0,c);}\nvec2 rotate(float x, float y, float angle){\nreturn\nvec2(\n (cos(angle)*x)+(sin(angle)*y),\n-(sin(angle)*x)+(cos(angle)*y));\n}\nfloat smin( float a, float b, float k ){\n    k *= 1.0/(1.0-sqrt(0.5));\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min(a,b) - k*0.5*(1.0+h-sqrt(1.0-h*(h-2.0)));\n}    \nvec4 smin( vec4 a, vec4 b, float j ){\n    vec4 k=vec4(j);\n    k *= 1.0/(1.0-sqrt(0.5));\n    vec4 h = max( k-abs(a-b), 0.0 )/k;\n    return min(a,b) - k*0.5*(1.0+h-sqrt(1.0-h*(h-2.0)));\n}    \nvec3 form(float dist,vec3 Color){\nreturn Color*(dist<=0.01?1.:0.);\n}\nvec3 blend(float dist1,float dist2,vec3 col1,vec3 col2 ,float blend){\nfloat bl=smoothstep(-1.,1.,dist2-dist1);\nfloat fac=max(smin(dist1,dist2,blend),-min(dist1,dist2));\nreturn sat(mix(col1,col2,1.-bl)\n*sat(mix(1.,-50.,fac)))\n\n;\n}\nvec4 getpos(mat4x4 info){\nreturn vec4(info[0][0],info[1][0],info[2][0],info[3][0]);\n}\nvec4 getnor(mat4x4 info){\nreturn vec4(info[0][1],info[1][1],info[2][1],info[3][1]);\n}\nvec3 getcol(mat4x4 info){\nreturn vec3(info[0][2],info[1][2],info[2][2]);\n}\nfloat getdis(mat4x4 info){\nreturn info[0][3];\n}\nfloat getdist(mat4x4 info){\nreturn info[1][3];\n}\nfloat getstep(mat4x4 info){\nreturn info[2][3];\n}\n\nfloat gethit(mat4x4 info){\nreturn info[3][3];\n}\nvec4 qmul(vec4 a, vec4 b){\n    return vec4(a.w*b.xyz + b.w*a.xyz + cross(a.xyz, b.xyz), a.w*b.w - dot(a.xyz, b.xyz));\n}\nvec4 qrot(vec4 q, vec4 p){\nreturn qmul(p,-qmul(q,-p));\n}\nfloat hash(vec3 p3){\n\tp3  = fract(p3 * .10311);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 clickStore\t= vec2(4.,  0.);\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\n\nfloat loadValue1( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 ).x;\n}\n\nvoid storeValue1( in vec2 re, float va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? vec4(va, .0, .0, .0) : fragColor;\n}\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n\n\tfragColour = vec4(0);\n    float click = 0.0;\n    float oldClick = loadValue1(clickStore);\n    if (iFrame == 0) oldClick = 0.0;\n        \n    if (iMouse.z > 0.0)\n   \t{\n      if (oldClick == .0)\n        click = 1.0;\n    }\n  \n\tstoreValue1(clickStore, click,  fragColour, fragCoord);\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n// Flying camera code...\n// by David Hoskins\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nconst float KEY_I\t\t= 73.5/256.0;\nconst float KEY_J\t\t= 74.5/256.0;\nconst float KEY_K\t\t= 75.5/256.0;\nconst float KEY_L\t\t= 76.5/256.0;\nconst float KEY_Q\t\t= 81.5/256.0;\nconst float KEY_E\t\t= 69.5/256.0;\nconst float KEY_R\t\t= 82.5/256.0;\nconst float KEY_F\t\t= 70.5/256.0;\nconst float KEY_W\t\t= 87.5/256.0;\nconst float KEY_A\t\t= 65.5/256.0;\nconst float KEY_S\t\t= 83.5/256.0;\nconst float KEY_D\t\t= 68.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\nconst float KEY_SPACE\t= 32.5/256.0;\nconst float KEY_SHIFT\t= 16.5/256.0;\n\n\nvec2 clickStoreA = vec2(4.0,  0.0);\nvec2 camStore = vec2(0.0,  0.0);\nvec2 angStore = vec2(10.0,  0.0);\nvec2 mcolxStore = vec2(11.0,  0.0);\nvec2 mcolyStore = vec2(12.0,  0.0);\nvec2 mcolzStore = vec2(13.0,  0.0);\nvec2 mcolwStore = vec2(14.0,  0.0);\nvec2 mcolx2Store = vec2(15.0,  0.0);\nvec2 mcoly2Store = vec2(16.0,  0.0);\nvec2 mcolz2Store = vec2(17.0,  0.0);\nvec2 mcolw2Store = vec2(18.0,  0.0);\nvec2 rotationStore\t= vec2(1.,  0.);\nvec2 mouseStore = vec2(2.,  0.);\nvec2 startStore\t\t= vec2(3.,  0.);\nvec2 timeStore = vec2(6.0,  0.0);\n\n\nbool isKeyPressed(float key){return texture( iChannel2, vec2(key, 0.25) ).x > .0;}\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nvec4 loadValue4( in vec2 re ){return texture( iChannel1, (0.5+re) / iChannelResolution[1].xy, -100.0 );}\nvec3 loadValue3( in vec2 re ){return texture( iChannel1, (0.5+re) / iChannelResolution[1].xy, -100.0 ).xyz;}\nvec2 loadValue2( in vec2 re ){return texture( iChannel1, (0.5+re) / iChannelResolution[1].xy, -100.0 ).xy;}\nfloat loadValue1( in vec2 re ){return texture( iChannel1, (0.5+re) / iChannelResolution[0].xy, -100.0 ).x;}\nfloat loadValueA1( in vec2 re ){return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 ).x;}\nvoid storeValue4( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{fragColor = ( isInside(fragCoord, re) > 0.0 ) ? va : fragColor;}\nvoid storeValue3( in vec2 re, in vec3 va, inout vec4 fragColor, in vec2 fragCoord )\n{fragColor = ( isInside(fragCoord, re) > 0.0 ) ? vec4(va, 0.0) : fragColor;}\nvoid storeValue2( in vec2 re, in vec2 va, inout vec4 fragColor, in vec2 fragCoord )\n{fragColor = ( isInside(fragCoord, re) > 0.0 ) ? vec4(va, .0, .0) : fragColor;}\nvoid storeValue1( in vec2 re, in float va, inout vec4 fragColor, in vec2 fragCoord )\n{fragColor = ( isInside(fragCoord, re) > 0.0 ) ? vec4(va, .0, .0, .0) : fragColor;}\nvec2 rot2D(inout vec2 p, float a)\n{return cos(a)*p - sin(a) * vec2(p.y, -p.x);}\n\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n   \tfragColour = vec4(0);\n    \n    \n\tvec2 tempStart \t= loadValue2(startStore);\n\tfloat click \t= loadValueA1(clickStoreA);\n    float time \t\t= loadValue1(timeStore);\n    \n    vec4 camPos;\n    vec2 rot;\n    vec4 ang;\n    vec4 mcolx;\n    vec4 mcoly;\n    vec4 mcolz;\n    vec4 mcolw;\n    vec4 mcolx2;\n    vec4 mcoly2;\n    vec4 mcolz2;\n    vec4 mcolw2;\n\n    if (iFrame == 0)\n    {\n        camPos = vec4(0.5,0.5,0.5,0.5);\n        rot = vec2(0,0);\n        ang = vec4(0,0,1,0);\n        mcolx=vec4(1,0,0,0);\n        mcoly=vec4(0,1,0,0);\n        mcolz=vec4(0,0,1,0);\n        mcolw=vec4(0,0,0,1);\n        mcolx2=vec4(1,0,0,0);\n        mcoly2=vec4(0,1,0,0);\n        mcolz2=vec4(0,0,1,0);\n        mcolw2=vec4(0,0,0,1);\n\n    }else\n    {\n        camPos = loadValue4(camStore);\n        rot = loadValue2(rotationStore);\n        ang = loadValue4(angStore);\n        mcolx = loadValue4(mcolxStore);\n        mcoly = loadValue4(mcolyStore);\n        mcolz = loadValue4(mcolzStore);\n        mcolw = loadValue4(mcolwStore);\n        mcolx2 = loadValue4(mcolx2Store);\n        mcoly2 = loadValue4(mcoly2Store);\n        mcolz2 = loadValue4(mcolz2Store);\n        mcolw2 = loadValue4(mcolw2Store);\n    }\n\n\n    vec4 mouse = iMouse /iResolution.xyxy;\n    \n    if (click > 0.0)\n    {\n    \ttempStart = mouse.xy;// First clicked\n    }\n    if (mouse.z > 0.0)\n    \trot += mouse.xy - tempStart;\n        rot=rot/2.;\n    \n    \n\tstoreValue2(startStore, tempStart,  fragColour, fragCoord);\n\tstoreValue2(rotationStore, rot,  fragColour, fragCoord);\n    \n    rot*= TAU;\n    mat4 M = mat4(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);\n    mat4 cammat = mat4(mcolx,mcoly,mcolz,mcolw);\n    mat4 cammat2 = mat4(mcolx2,mcoly2,mcolz2,mcolw2);\n    mat4 mX=RotationMatrix(vec3(0,1,0),rot.x);\n    mat4 mY=RotationMatrix(vec3(1,0,0),-rot.y);\n    mat4 mI=RotateXW(rot.x);\n    mat4 mJ=RotateZW(rot.y);\n    mat4 mK=RotateYW(rot.y);\n\nif (isKeyPressed(KEY_SPACE))\n\t{cammat=mI*mJ*cammat;mX=M;mY=M;}\ncammat=mX*cammat;\ncammat2=mY*cammat2;\n\nmcolx=cammat[0];mcoly=cammat[1];mcolz=cammat[2];mcolw=cammat[3];\nmcolx2=cammat2[0];mcoly2=cammat2[1];mcolz2=cammat2[2];mcolw2=cammat2[3];\n\n\n    \n        storeValue4(angStore,ang,  fragColour, fragCoord);\n        storeValue4(mcolxStore,mcolx,  fragColour, fragCoord);\n        storeValue4(mcolyStore,mcoly,  fragColour, fragCoord);\n        storeValue4(mcolzStore,mcolz,  fragColour, fragCoord);\n        storeValue4(mcolwStore,mcolw,  fragColour, fragCoord);\n        storeValue4(mcolx2Store,mcolx2,  fragColour, fragCoord);\n        storeValue4(mcoly2Store,mcoly2,  fragColour, fragCoord);\n        storeValue4(mcolz2Store,mcolz2,  fragColour, fragCoord);\n        storeValue4(mcolw2Store,mcolw2,  fragColour, fragCoord);\n    time = iTime - time;\n    float speed = time*256.;\n    \n    if (isKeyPressed(KEY_SPACE) || isKeyPressed(KEY_SHIFT)) speed*=4.0;\n    if (isKeyPressed(KEY_W) || isKeyPressed(KEY_UP))\n\t{camPos +=(vec4(0,0,1,0) *cammat2*cammat)* speed;}\n    if (isKeyPressed(KEY_S) || isKeyPressed(KEY_DOWN))\n\t{camPos +=(vec4(0,0,-1,0)*cammat2*cammat)* speed;}\n  \tif (isKeyPressed(KEY_D) || isKeyPressed(KEY_RIGHT))\n\t{camPos +=(vec4(1,0,0,0) *cammat2*cammat)* speed;}\n\tif (isKeyPressed(KEY_A) || isKeyPressed(KEY_LEFT))\n\t{camPos +=(vec4(-1,0,0,0)*cammat2*cammat) * speed;}\n  \tif (isKeyPressed(KEY_Q) || isKeyPressed(KEY_RIGHT))\n\t{camPos +=(vec4(0,0,0,1) *cammat2*cammat)* speed;}\n\tif (isKeyPressed(KEY_E) || isKeyPressed(KEY_LEFT))\n\t{camPos +=(vec4(0,0,0,-1)*cammat2*cammat) * speed;}\n    if (isKeyPressed(KEY_R) || isKeyPressed(KEY_RIGHT))\n\t{camPos +=(vec4(0,1,0,0) *cammat2*cammat)* speed;}\n\tif (isKeyPressed(KEY_F) || isKeyPressed(KEY_LEFT))\n\t{camPos +=(vec4(0,-1,0,0)*cammat2*cammat) * speed;}\n    \n    storeValue4(camStore, camPos,  fragColour, fragCoord);\n\n    storeValue1(timeStore, iTime,  fragColour, fragCoord);\n            \n}","name":"Buffer B","description":"","type":"buffer"}]}