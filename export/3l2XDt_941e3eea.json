{"ver":"0.1","info":{"id":"3l2XDt","date":"1717420962","viewed":34,"name":"spook raymarch","username":"polariche","description":"spook","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["spook"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://iquilezles.org/articles/distfunctions\nfloat sphereDist(in vec3 p, in float r) {\n\treturn length(p) - r;\n}\n\n\nfloat vCapsuleDist(in vec3 p, in  float h, in  float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat opUnion(in  float d1,in  float d2 ) { return  min(d1,d2); }\n\nfloat opSubtraction(in  float d1,in  float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection(in  float d1,in  float d2 ) { return max(d1,d2); }\n\n\nfloat opSmoothUnion(in  float d1,in  float d2,in  float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction(in  float d1,in  float d2,in  float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection(in  float d1,in  float d2,in  float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\nfloat map(in vec3 p) {\n    float d = opSmoothUnion(vCapsuleDist(p-vec3(-.14,-.2+0.2*sin(iTime),1),0.3, 0.1), vCapsuleDist(p-vec3(.14,-.2+0.2*cos(iTime),1), 0.3 , 0.1), 0.1);\n\td = opSmoothUnion(sphereDist(p-vec3(0,0.2+0.1*sin(iTime*5.0),1), 0.2), d, 0.2);\n    \n    d = opSmoothUnion(sphereDist(p-vec3(-0.3+0.2*sin(iTime),0.2,1), 0.1), d, 0.1);\n    d = opSmoothUnion(sphereDist(p-vec3(0.3+0.2*sin(iTime),0.2,1), 0.1), d, 0.1);\n    \n    d = opSmoothUnion(sphereDist(p-vec3(0.07,0.2,0.8), 0.01*sin(iTime)), d, 0.02);\n    d = opSmoothUnion(sphereDist(p-vec3(-0.07,0.2,0.8), 0.01*sin(iTime)), d, 0.02);\n    \n    return d;\n}\n\nvec3 getnormal(vec3 p){\n  vec2 e = vec2(.001, -.001); \n  return normalize(\n      e.xyy * map(p + e.xyy) + \n      e.yyx * map(p + e.yyx) + \n      e.yxy * map(p + e.yxy) + \n      e.xxx * map(p + e.xxx));\n}\n\n\nvec3 rayMarch(in vec3 p, in vec3 d) {\n    int max_depth = 100;\n    vec3 light = normalize(vec3(1,1,-1));\n  \n    for (int i=0;i<max_depth;i++) {\n        float dist = map(p);\n        if (dist < 0.005)\n            return vec3(dot(getnormal(p), light));\n        \n    \tp += d*dist;\n    }\n    \n    \n    return vec3(0.2);\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - .5 * iResolution.xy ) / iResolution.y;\n    \n    vec3 p = vec3(0, 0, 0);\n    vec3 d = normalize(vec3(uv, 1) - p);\n\n    // Time varying pixel color\n    vec3 col = rayMarch(p, d);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}