{"ver":"0.1","info":{"id":"DsscW4","date":"1686822113","viewed":84,"name":"CCA von Neumann","username":"johnhearn","description":"Simplest Cyclic Cellular Automata using von Neumann neighbourhood and \"glow\" palette\nReset with space. \nFrom https://webbox.lafayette.edu/~reiterc/mvq/mscca/index.html","likes":8,"published":1,"flags":48,"usePreview":0,"tags":["ca","cellularautomata","cca"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 glow(in float i) {\n    float r = 46. * log(i*255.) / 255.;\n    float g = i;\n    float b = 1.55 * (exp(i*255./50.)-1.) / 255.;\n    return vec3(r, g, b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float val = texture(iChannel0, uv).x;\n    fragColor = vec4(glow(val) , 1);   \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Total number of states. Larger numbers produce smoother cycles but might get stuck\n#define N 18\n\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }\n\nint val2state(in vec2 xy) {\n    return int(floor(texture(iChannel0, xy).x * float(N)));\n}\n\nfloat state2val(in int state) {\n    return float(state % N) / float(N);\n}\n\nbool reset() {\n    return texture(iChannel3, vec2(32.5/256.0, 0.5) ).x > 0.5;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n\tvec2 xy = fragCoord.xy / iResolution.xy;\n\n\tvec2 texel = 1. / iResolution.xy;\n    \n    float delta_x = texel.x;\n    float delta_y = texel.y;\n    \n    vec2 n = vec2(0.0, delta_y);\n    vec2 ne = vec2(delta_x, delta_y);\n    vec2 e = vec2(delta_x, 0.0);\n    vec2 se = vec2(delta_x, -delta_y);\n    vec2 s = vec2(0.0, -delta_y);\n    vec2 sw = vec2(-delta_x, -delta_y);\n    vec2 w = vec2(-delta_x, 0.0);\n    vec2 nw = vec2(-delta_x, delta_y);\n    \n    int state =    val2state(xy);\n    int state_n =  val2state(xy+n);\n    int state_e =  val2state(xy+e);\n    int state_s =  val2state(xy+s);\n    int state_w =  val2state(xy+w);\n    int state_ne =  val2state(xy+ne);\n    int state_se =  val2state(xy+se);\n    int state_sw =  val2state(xy+sw);\n    int state_nw =  val2state(xy+nw);\n    \n    int update = 0;\n    int next_state = (state+1 ) % N;\n    if(   state_n == next_state \n       || state_e == next_state\n       || state_s == next_state\n       || state_w == next_state\n       //|| state_ne == next_state\n       //|| state_se == next_state\n       //|| state_sw == next_state\n       //|| state_nw == next_state\n       ) update = 1;\n\n\n    float new_state = (iFrame<2 || reset()) ? rand(xy*(time+1.)) : state2val(state + update);\n    \n    fragColor = vec4(new_state);\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}