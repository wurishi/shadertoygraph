{"ver":"0.1","info":{"id":"4sGyWy","date":"1523228036","viewed":434,"name":"Forn Sidr","username":"shau","description":"Glowing cubes","likes":21,"published":1,"flags":96,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define time iTime\n\nconst float GA = 4.399; \nconst mat2 rot = mat2(cos(GA), sin(GA), -sin(GA), cos(GA));\n\n//simplyfried version of Dave Hoskins blur borrowed from Virgilll\nvec3 dof(sampler2D tex,vec2 uv,float rad) {\n\tvec3 acc = vec3(0.0);\n    vec2 pixel = vec2(0.002 * iResolution.y / iResolution.x, 0.002), angle = vec2(0.0, rad);;\n    rad=1.;\n\tfor (int j = 0; j < 80; j++) {  \n        rad += 1.0 / rad;\n\t    angle*=rot;\n        vec4 col=texture(tex,uv+pixel*(rad-1.)*angle);\n\t\tacc+=col.xyz;\n\t}\n    \n\treturn acc/80.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n\tfragColor = vec4(dof(iChannel0, uv, texture(iChannel0, uv).w), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by SHAU - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define LOOP_LENGTH 32.0\n#define T mod(iTime, LOOP_LENGTH)\n#define N_PATH_POINTS 36\n\n//Spline curve - Dave Hoskins - Pylon \n//https://www.shadertoy.com/view/XltSRf\n//Catmull-rom spline\nvec3 spline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t) {\n    \n    vec3 c2 = -0.5 * p0\t+  0.5 * p2;\n\tvec3 c3 =        p0\t+ -2.5 * p1 +  2.0 * p2 + -0.5 * p3;\n    vec3 c4 = -0.5 * p0\t+  1.5 * p1 + -1.5 * p2 +  0.5 * p3;\n\t\n    return(((c4 * t + c3) * t + c2) * t + p1);\n}\n\nvoid positionsAtTime(inout vec3 cameraPosition, inout vec3 lookAtPosition) {\n    \n    //initialise camera arrays\n    //number of positions must be +3 number of seconds that loop plays\n    vec3 cameraPath[N_PATH_POINTS];\n    cameraPath[0]  = vec3( 0.0,  6.0,  0.0);\n    cameraPath[1]  = vec3(-1.0,  5.0,  0.0);\n    cameraPath[2]  = vec3(-1.4,  4.0,  0.0);\n    cameraPath[3]  = vec3(-1.7,  4.0, -0.8);\n    cameraPath[4]  = vec3(-1.9,  4.0, -1.7);\n    cameraPath[5]  = vec3(-1.1,  5.0, -3.0);\n    cameraPath[6]  = vec3(-0.8,  5.2, -3.1);\n    cameraPath[7]  = vec3(-0.0,  6.6, -2.7);\n    cameraPath[8]  = vec3( 0.1,  8.0, -2.0);\n    cameraPath[9]  = vec3( 0.2,  7.0, -0.2);\n    cameraPath[10] = vec3( 0.3,  6.2,  0.4);\n    cameraPath[11] = vec3( 0.7,  6.0,  0.9);\n    cameraPath[12] = vec3( 1.9,  5.7,  1.6);\n    cameraPath[13] = vec3( 3.0,  5.0,  2.5);\n    cameraPath[14] = vec3( 3.4,  5.0,  3.4);\n    cameraPath[15] = vec3( 3.6,  4.6,  7.5);\n    cameraPath[16] = vec3( 4.0,  4.4,  9.1);\n    cameraPath[17] = vec3( 4.5,  4.0,  8.9);\n    cameraPath[18] = vec3( 4.7,  4.4,  7.5);\n    cameraPath[19] = vec3( 5.0,  5.0,  6.7);\n    cameraPath[20] = vec3( 5.2,  5.8,  5.6);\n    cameraPath[21] = vec3( 5.7,  6.0,  5.2);\n    cameraPath[22] = vec3( 6.1,  6.9,  5.0);\n    cameraPath[23] = vec3( 4.4,  8.0,  4.0);\n    cameraPath[24] = vec3( 2.2,  9.1,  3.2);\n    cameraPath[25] = vec3( 0.6, 11.0,  2.4);\n    cameraPath[26] = vec3( 0.0, 10.5,  1.8);\n    cameraPath[27] = vec3(-0.4,  9.0,  0.5);\n    cameraPath[28] = vec3(-0.9,  7.0,  0.1);\n    cameraPath[29] = vec3(-2.0,  6.0, -1.0);\n    cameraPath[30] = vec3(-3.2,  6.0, -0.3);\n    cameraPath[31] = vec3(-1.0,  6.0,  0.0);\n    cameraPath[32] = vec3( 0.0,  6.0,  0.0);\n    //repeat first 3 points for smooth looping\n    cameraPath[33]  = vec3(-1.0,  5.0,  0.0);\n    cameraPath[34]  = vec3(-1.4,  4.0,  0.0);\n    cameraPath[35]  = vec3(-1.7,  4.0, -0.8);\n\n    vec3 lookAtPath[N_PATH_POINTS];\n    lookAtPath[0]  = vec3(-6.0,  0.0, -4.0);\n    lookAtPath[1]  = vec3(-5.2,  0.0, -2.5);\n    lookAtPath[2]  = vec3(-4.4,  0.0, -1.0);\n    lookAtPath[3]  = vec3(-3.6,  0.0, -0.5);\n    lookAtPath[4]  = vec3(-3.4,  0.0,  0.0);\n    lookAtPath[5]  = vec3(-2.8,  0.3,  0.5);\n    lookAtPath[6]  = vec3(-3.3,  0.8,  1.0);\n    lookAtPath[7]  = vec3(-3.9,  1.5,  1.8);\n    lookAtPath[8]  = vec3(-4.4,  2.2,  2.9);\n    lookAtPath[9]  = vec3(-3.5,  3.1,  3.8);\n    lookAtPath[10] = vec3(-1.0,  4.0,  5.0);\n    lookAtPath[11] = vec3(-0.5,  4.4,  4.6);\n    lookAtPath[12] = vec3( 0.0,  3.5,  3.1);\n    lookAtPath[13] = vec3( 0.5,  2.9,  4.0);\n    lookAtPath[14] = vec3( 1.0,  1.6,  4.4);\n    lookAtPath[15] = vec3( 1.5,  1.2,  4.4);\n    lookAtPath[16] = vec3( 2.0,  0.6,  3.6);\n    lookAtPath[17] = vec3( 2.0,  0.2,  3.0);\n    lookAtPath[18] = vec3( 2.0,  0.0,  2.2);\n    lookAtPath[19] = vec3( 2.0,  0.0,  1.5);\n    lookAtPath[20] = vec3( 2.0,  0.0,  0.0);\n    lookAtPath[21] = vec3( 2.0,  0.4, -0.5);\n    lookAtPath[22] = vec3( 2.0,  0.9, -1.0);\n    lookAtPath[23] = vec3( 2.0,  1.7, -1.5);\n    lookAtPath[24] = vec3( 2.0,  3.0, -2.0);\n    lookAtPath[25] = vec3( 2.0,  3.8, -2.6);\n    lookAtPath[26] = vec3( 1.5,  2.9, -3.4);\n    lookAtPath[27] = vec3( 1.0,  2.0, -5.0);\n    lookAtPath[28] = vec3( 0.5,  1.0, -4.0);\n    lookAtPath[29] = vec3( 0.0,  0.0, -3.0);\n    lookAtPath[30] = vec3(-0.5,  0.0, -2.0);\n    lookAtPath[31] = vec3(-3.0,  0.0, -3.4);\n    lookAtPath[32] = vec3(-6.0,  0.0, -4.0);\n    //repeat first 3 points for smooth looping\n    lookAtPath[33]  = vec3(-5.2,  0.0, -2.5);\n    lookAtPath[34]  = vec3(-4.4,  0.0, -1.0);\n    lookAtPath[35]  = vec3(-3.6,  0.0, -0.5);\n    \n    int nt = int(T);\n    float ft = fract(T);\n    \n    vec3 p0 = cameraPath[nt];\n    vec3 p1 = cameraPath[nt + 1];\n    vec3 p2 = cameraPath[nt + 2];\n    vec3 p3 = cameraPath[nt + 3];\n    \n    cameraPosition = spline(p0, p1, p2, p3, ft);\n    \n    p0 = lookAtPath[nt];\n    p1 = lookAtPath[nt + 1];\n    p2 = lookAtPath[nt + 2];\n    p3 = lookAtPath[nt + 3];\n\n    lookAtPosition = spline(p0, p1, p2, p3, ft);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n    \n    vec3 cameraPosition, lookAtPosition;\n    positionsAtTime(cameraPosition, lookAtPosition);\n    \n    if (int(fragCoord.y) == 0) {\n        if (int(fragCoord.x) == 0) {\n            fragColor = vec4(cameraPosition, 1.0);\n        } else if (int(fragCoord.x) == 1) {\n            fragColor = vec4(lookAtPosition, 1.0);\n        }\n    }\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdjXWm","filepath":"https://soundcloud.com/monismmusic/mo7s-kill-computer-null-space-remix-preview","previewfilepath":"https://soundcloud.com/monismmusic/mo7s-kill-computer-null-space-remix-preview","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Created by SHAU - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec4 currentSound = texture(iChannel0, uv / iResolution.xy);\n    \n    float level = currentSound.x;\n    float bass = currentSound.y;\n    float mid = currentSound.z;\n    float treble = currentSound.w;\n    \n    for (int x = 0; x < 512; x++) {\n        vec4 newSound = texelFetch(iChannel1, ivec2(x , 0), 0);\n        level += newSound.x;\n        if (x < 140) bass += newSound.x;\n        if (x > 139 && x < 300) mid += newSound.x;\n        if (x > 299) treble += newSound.x;\n    }\n    \n    level /= 60.0;\n    bass /= 60.0;\n    mid /= 20.0;\n    treble /= 36.0;\n    \n    fragColor = vec4(level, bass, mid, treble);    \n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Created by SHAU - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define T iTime\n#define PI 3.14159265359\n#define FAR 100.0\n#define EPS 0.005\n\n#define HASHSCALE1 .1031\n\n#define FLOOR 1.0\n#define CUBES 2.0\n\n#define CA vec3(0.5, 0.5, 0.5)\n#define CB vec3(0.5, 0.5, 0.5)\n#define CC vec3(1.0, 1.0, 1.0)\n#define CD vec3(0.0, 0.33, 0.67)\n\n#define CT T / 14.0\n\nstruct Box {\n    float tN;\n    float tF;\n    vec3 nN;\n    vec3 nF;\n};\n\nstruct SurfaceIntersection {\n    float tN;\n    float tF;\n    vec3 nN;\n    vec3 nF;\n    vec3 col;\n};\n    \nstruct Cubes {\n    SurfaceIntersection near;\n    SurfaceIntersection mid;\n    SurfaceIntersection far;\n};\n\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\nvec3 lightPosition() {return vec3(10.0, 10.0, -10.0);}\n\n//IQ cosine palattes\n//https://iquilezles.org/articles/palettes\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {return a + b * cos(6.28318 * (c * t + d));}\nvec3 glowColour() {return palette(T * 0.1, CA, CB, CC, CD);}\n\n//Dave Hoskins - hash without sine\nfloat hash13(vec3 p3) {\n\tp3 = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n\nfloat fbm(vec3 x) {\n    float r = 0.0;\n    float w = 1.0;\n    float s = 1.0;\n    for (int i = 0; i < 5; i++) {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * noise(s * x);\n    }\n    return r;\n}\n\n//IQ - Box functions\n// https://iquilezles.org/articles/boxfunctions\nBox boxIntersection(vec3 ro, vec3 rd, vec3 boxSize) {\n\n    Box box = Box(0.0, 0.0, vec3(0.0), vec3(0.0));\n\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * boxSize;\n\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n\n    if (tN > tF || tF < 0.0) return box;\n\n    vec3 nN = -sign(rd) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n    vec3 nF = -sign(rd) * step(t2.xyz, t2.yzx) * step(t2.xyz, t2.zxy); \n\n    return Box(tN, tF, nN, nF);\n}\n\nfloat boxDensity(vec3 wro, vec3 wrd, vec3 r, float dbuffer) {\n    \n    vec3 d = (vec4(wrd,0.0)).xyz;\n\tvec3 o = (vec4(wro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/d;\n    vec3 n = m*o;\n    vec3 k = abs(m)*r;\n    vec3 ta = -n - k;\n    vec3 tb = -n + k;\n\tfloat tN = max( max( ta.x, ta.y ), ta.z );\n\tfloat tF = min( min( tb.x, tb.y ), tb.z );\n\tif( tN > tF || tF < 0.0) return 0.0;\n\n    // not visible (behind camera or behind dbuffer)\n    if( tF<0.0 || tN>dbuffer ) return 0.0;\n\n    // clip integration segment from camera to dbuffer\n    tN = max( tN, 0.0 );\n    tF = min( tF, dbuffer );\n    \n    // move ray to the intersection point\n    o += tN*d; tF=tF-tN; tN=0.0;\n\n    // density calculation. density is of the form\n    //\n    // d(x,y,z) = [1-(x/rx)^2] * [1-(y/ry)^2] * [1-(z/rz)^2];\n    //\n    // this can be analytically integrable (it's a degree 6 polynomial):\n    \n    vec3 a = 1.0 -     (o*o)/(r*r);\n    vec3 b =     - 2.0*(o*d)/(r*r);\n    vec3 c =     -     (d*d)/(r*r);\n    \n    float t1 = tF;\n    float t2 = t1*t1;\n    float t3 = t2*t1;\n    float t4 = t2*t2;\n    float t5 = t2*t3;\n    float t6 = t3*t3;\n    float t7 = t3*t4;\n\n    float f = (t1/1.0) *(a.x*a.y*a.z) + \n              (t2/2.0) *(a.x*a.y*b.z + a.x*b.y*a.z + b.x*a.y*a.z) + \n              (t3/3.0) *(a.x*a.y*c.z + a.x*b.y*b.z + a.x*c.y*a.z + b.x*a.y*b.z + b.x*b.y*a.z + c.x*a.y*a.z) +\n              (t4/4.0) *(a.x*b.y*c.z + a.x*c.y*b.z + b.x*a.y*c.z + b.x*b.y*b.z + b.x*c.y*a.z + c.x*a.y*b.z + c.x*b.y*a.z) + \n              (t5/5.0) *(a.x*c.y*c.z + b.x*b.y*c.z + b.x*c.y*b.z + c.x*a.y*c.z + c.x*b.y*b.z + c.x*c.y*a.z) + \n              (t6/6.0) *(b.x*c.y*c.z + c.x*b.y*c.z + c.x*c.y*b.z) + \n              (t7/7.0) *(c.x*c.y*c.z);\n      \n    return f;   \n}\n\nfloat planeIntersection(vec3 ro, vec3 rd, vec3 n, vec3 o) {\n    return dot(o - ro, n) / dot(rd, n);\n}\n\n// Based on Voxel traversal from IQ\n// https://iquilezles.org/articles/voxellines\nCubes drawCubes(vec3 ro, vec3 rd, vec3 lookAt) {\n    \n\tSurfaceIntersection near = SurfaceIntersection(0.0, 0.0, vec3(0.0), vec3(0.0), vec3(0.0));\n\tSurfaceIntersection mid = SurfaceIntersection(0.0, 0.0, vec3(0.0), vec3(0.0), vec3(0.0));\n\tSurfaceIntersection far = SurfaceIntersection(0.0, 0.0, vec3(0.0), vec3(0.0), vec3(0.0));\n    \n    float nHits = 0.0;\n    \n    vec4 sound = texture(iChannel1, vec2(0.5) / iResolution.xy);\n    float level = 0.0;\n    \n    vec3 pos = floor(ro);\n    vec3 ri = 1.0 / rd;\n    vec3 rs = sign(rd);\n    vec3 dis = (pos - ro + 0.5 + rs * 0.5) * ri;\n\n    vec3 mm = vec3(0.0);\n    for( int i = 0; i < 128; i++) {\n        \n        float r = hash13(pos);\n        \n        if ((length(lookAt - pos) * 0.5) - r < 0.2) {\n            \n            vec3 box = vec3(clamp(r * 0.5, 0.1, 0.4));\n            Box bi = boxIntersection(ro - (pos + vec3(0.5)), rd, box);\n            \n            if (r < 0.5) level = sound.w; \n            if (r >= 0.5 && r < 0.8) level = sound.z;\n            if (r >= 0.8) level = sound.y;\n\n            if (bi.tN > 0.0) {\n\t\t\t    \n                float bd = boxDensity(ro - (pos + vec3(0.5)), rd, box, FAR);\n                vec3 col = palette(r, CA, CB, CC, CD) * bd * 2.0;\n                \n                if (nHits == 0.0) {\n                \n                    near.tN = bi.tN;\n                    near.tF = bi.tF;\n                    near.nN = bi.nN;\n                    near.nF = bi.nF;\n                    near.col = col * level;\n                    \n                } else if (nHits == 1.0) {\n                    \n                    mid.tN = bi.tN;\n                    mid.tF = bi.tF;\n                    mid.nN = bi.nN;\n                    mid.nF = bi.nF;\n                    mid.col = col * level;\n\n                } else if (nHits == 2.0) {\n                    \n                    far.tN = bi.tN;\n                    far.tF = bi.tF;\n                    far.nN = bi.nN;\n                    far.nF = bi.nF;\n                    far.col = col * level;\n                }\n               \n                nHits += 1.0;\n                if (nHits > 2.0) break;\n            }\n        }\n\n        mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n        dis += mm * rs * ri;\n        pos += mm * rs;\n    }\n\n    return Cubes(near, mid, far);\n}\n\n//Moody clouds from Patu\n//https://www.shadertoy.com/view/4tVXRV\nvec3 clouds(vec3 rd) {\n    vec2 uv = rd.xz / (rd.y + 0.6);\n    float nz = fbm(vec3(uv.yx * 1.4 + vec2(CT, 0.0), CT)) * 1.5;\n    return clamp(pow(vec3(nz), vec3(4.0)) * rd.y, 0.0, 1.0);\n}\n\n//IQ antialiasing\n//see https://www.shadertoy.com/view/MtffWs\nvec3 pri(vec3 x) {\n    vec3 h = fract(x / 2.0) - 0.5;\n    return x * 0.5 + h * (1.0 - 2.0 * abs(h));\n}\n\nfloat checkersTextureGradTri(vec3 p, vec3 ddx, vec3 ddy) {\n    vec3 w = max(abs(ddx), abs(ddy)) + 0.01; // filter kernel\n    vec3 i = (pri(p + w) - 2.0 * pri(p) + pri(p - w)) / (w * w); // analytical integral (box filter)\n    return 0.5 - 0.5 * i.x *  i.y * i.z; // xor pattern\n}\n\nvec3 texCoords(vec3 p) {\n\treturn 0.4 * p;\n}\n\nvec3 cubeColour(vec3 ro, vec3 rd, SurfaceIntersection surface) {\n\n    vec3 pc = vec3(0.0);\n    vec3 lp = lightPosition();\n    \n    vec3 rp = ro + rd * surface.tN;\n    vec3 ld = normalize(lp - rp);\n    float lt = length(lp - rp);\n    float atten = 1.0 / (1.0 + lt * lt * 0.005);\n    \n    //distance between near face and rear face\n    float ft = 1.0 / (1.0 + (surface.tF - surface.tN) * (surface.tF - surface.tN) * 10.0);\n\n    //near face\n    float specN = pow(max(dot(reflect(-ld, surface.nN), -rd), 0.0), 32.0);\n    float fresN = pow(clamp(dot(surface.nN, rd) + 1.0, 0.0, 1.0), 8.0);\n\n    //rear face\n    float specF = pow(max(dot(reflect(-ld, -surface.nF), -rd), 0.0), 32.0);\n    float fresF = pow(clamp(dot(-surface.nF, rd) + 1.0, 0.0, 1.0), 8.0);\n\n    vec3 gColN = vec3(1.0) * (specN + fresN * 0.2);\n    vec3 gColF = vec3(1.0) * (specF + fresF * 0.2) * ft * 0.6;\n    gColF = mix(gColF, surface.col, length(surface.col));\n    \n    pc = (gColN + gColF); // * 0.5;\n    pc *= atten;\n    \n    return pc;\n}\n\nvec4 background(vec3 ro, vec3 rd) {\n \n    float mint = 0.0;\n\n    //background\n    vec3 bgc = vec3(1.0) * clouds(rd) * 10.0;\n    vec3 fo = vec3(0.0, -3.0, 0.0);\n    vec3 fn = vec3(0.0, 1.0, 0.0);\n    float ft = planeIntersection(ro, rd, fn, fo);\n    if (ft > 0.0 && ft < FAR) {\n        \n        //hit floor\n        mint = ft;\n        \n        vec3 rp = ro + rd * ft;\n        vec3 ld = normalize(lightPosition() - rp);\n        float lt = length(lightPosition() - rp);\n        float atten = 1.0 / (1.0 + lt * lt * 0.005);\n        float diff = max(dot(ld, fn), 0.05);\n        float spec = pow(max(dot(reflect(-ld, fn), -rd), 0.0), 32.0);\n        \n        //nice antialiased checkrboard courtesy of IQ\n        //calc texture sampling footprint\t\n        vec3 uvw = texCoords(rp);\n\t\tvec3 ddx_uvw = dFdx(uvw); \n    \tvec3 ddy_uvw = dFdy(uvw);\n        float fc = checkersTextureGradTri(uvw, ddx_uvw, ddy_uvw);\n        \n        bgc = vec3(1.0) * clamp(fc, 0.3, 0.7) * diff;\n        bgc += vec3(1.0) * spec;\n        bgc *= atten;\n    }\n\n    return vec4(bgc, mint);\n}\n\nvec3 colourCubes(vec3 ro, vec3 rd, Cubes cubes, vec3 bgc) {\n \n    vec3 pc = bgc;\n    \n    vec3 sound = texture(iChannel1, vec2(0.5, 0.5) / iResolution.xy).xyz;\n    \n    if (cubes.near.tN > 0.0) {\n        \n        //distance between near face and rear face of neaar cube\n        float ftN = 1.0 / (1.0 + (cubes.near.tF - cubes.near.tN) * (cubes.near.tF - cubes.near.tN) * 10.0);\n\n        pc = cubeColour(ro, rd, cubes.near);\n        \n        if (cubes.mid.tN > 0.0) {\n            \n            //distance between near face and rear face of neaar cube\n            float ftM = 1.0 / (1.0 + (cubes.mid.tF - cubes.mid.tN) * (cubes.mid.tF - cubes.mid.tN) * 10.0);\n\n            //mix in mid cube\n            vec3 pc2 = cubeColour(ro, rd, cubes.mid);\n            \n            if (cubes.far.tN > 0.0) {\n                \n                //mix in far cube\n                vec3 pc3 = cubeColour(ro, rd, cubes.far);\n                pc2 += pc3 * ftM * 0.8;\n                \n            } else {\n                \n                //mix in background\n                pc2 += bgc * ftM * 0.4;\n            }\n            \n            pc += pc2 * ftN * 0.8;            \n            \n        } else {\n            \n            //mix in background\n            pc += bgc * ftN * 0.4;\n        }\n    }\n\n    return pc;\n}\n\nvec3 setupCamera(vec2 uv, vec3 ro, vec3 lookAt) {\n    \n    float FOV = PI / 3.0;\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0.0, -forward.x)); \n    vec3 up = cross(forward, right);\n\n    return normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec3 pc = vec3(0.0);\n    float mint = FAR;\n    \n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\n    vec3 lookAt = texture(iChannel0, vec2(1.5, 0.5) / iResolution.xy).xyz;\n    vec3 ro = texture(iChannel0, vec2(0.5, 0.5) / iResolution.xy).xyz;\n    vec3 rd = setupCamera(uv, ro, lookAt);\n    \n    vec4 bg = background(ro, rd);\n    if (bg.w < mint) mint = bg.w;\n    \n    //draw cubes\n    Cubes cubes = drawCubes(ro, rd, lookAt);\n\tpc = colourCubes(ro, rd, cubes, bg.xyz);  \n    \n    if (cubes.near.tN > 0.0) {\n        //reflection\n        mint = cubes.near.tN;\n        vec3 rro = ro + rd * (cubes.near.tN - EPS);\n        vec3 rrd = reflect(rd, cubes.near.nN); \n        vec4 reflectedBg = background(rro, rrd);\n        Cubes reflectedCubes = drawCubes(rro, rrd, lookAt);\n        vec3 rpc = colourCubes(rro, rrd, reflectedCubes, reflectedBg.xyz);\n        float ratten = 1.0 / (1.0 + reflectedCubes.near.tN * reflectedCubes.near.tN * 0.001);\n        rpc *= max(dot(rd, reflectedCubes.near.nN), 0.3);\n        pc += rpc * ratten * 0.6;\n    }\n    \n    fragColor = vec4(pc, mint / FAR);\n}","name":"Buf C","description":"","type":"buffer"}]}