{"ver":"0.1","info":{"id":"7ltcRn","date":"1659508009","viewed":375,"name":"Synthwave Road","username":"alexdav","description":"A simple synthwave road built with 2D techniques and a questionable glow effect.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["synthwave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// First attempt at a Synthwave Road\n// ... using 2D techniques\n\nconst vec3 sunsetUp = vec3(1., 0.59, 0.32);\nconst vec3 sunsetDown = vec3(0.58, 0.11, 0.44);\nconst vec3 sunUp = vec3(1, 0.9, 0);\nconst vec3 sunDown = vec3(0.75, 0.21, 0.44);\nconst float sunSize = 0.7;\nconst float sunStripe = 0.05;\nconst float sunStripeOffset = 0.04;\nconst vec2 sunPos = vec2(0, 0.1);\nconst float sunDistortFactor = 0.002;\nconst float sunStripeSpeed = 0.02;\n\nconst float horizonY = -.24;\nconst float roadScale = -0.2;\nconst float speed = 20.0;\nconst float bendingRate = 0.1;\n\nconst vec3 gridColor = vec3(0.8, 0.5, 0.75);\nconst vec3 gridColor2 = vec3(0.59, 0.05, 0.45);\nconst vec3 groundColor = vec3(0.24, 0.11, 0.26);\nconst vec3 roadColor = vec3(0.05, 0.05, 0.05);\nconst vec3 roadColor2 = vec3(0.1, 0.1, 0.1);\nconst vec3 paintColor = vec3(0.05, 0.05, 0.05);\nconst vec3 paintColor2 = vec3(1, 1, 0.33);\nconst vec3 centerLineColor = vec3(1, 1, 0.33);\nconst vec3 buildingsColor = vec3(0, 0, 0);\n\nconst float roadWidth = 2.8;\nconst float roadDetail = 4.0;\nconst float zoom = 0.05;\nconst float buildingsScrollSpeed = 20.;\nconst float buildingsHeight = 0.15;\nconst float buildingsWidthFactor = 25.;\nconst float sideLineWidth = 0.2;\nconst float centerWidth = 0.15;\nconst float gridLineWidth = 0.1;\n\nconst float glowIntensity = 1.2;\nconst float glowRadius = 0.1;\nconst float glowColorFactor = 0.4;\n\n#define hash21(p) fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n\nvec4 sky(vec2 p)\n{    \n    vec2 sunDistort = vec2(sin(60. * p.y + iTime * 2.) * sunDistortFactor);\n    float sun = length(p + sunDistort - sunPos);\n    vec3 skyColor = mix(sunsetDown, sunsetUp, p.y);\n\n    float sunStripe = mod(iTime * sunStripeSpeed + sunStripeOffset + (p.y - horizonY) * (p.y - horizonY), sunStripe);\n    vec3 ret = (sun < sunSize) && sunStripe > 0.01 ? mix(sunDown, sunUp, (p.y + sunPos.y) / sunSize) : skyColor;\n    \n    float scroll = buildingsScrollSpeed * cos(bendingRate * iTime);\n    float height = hash21(floor(scroll + p.xx * buildingsWidthFactor)) * buildingsHeight;\n    ret = p.y - horizonY < height ? buildingsColor : ret;\n    \n    return vec4(ret, 1.);\n}\n\nvec4 road(vec2 p)\n{\n    vec3 q = vec3(p, 1) / (roadScale - p.y);\n\n    float refl = 0.8 * (1. - abs(p.y - horizonY));\n    refl = refl * refl * refl;\n    \n    float k = zoom * sin(bendingRate * iTime);\n    float bendFactor = k * q.z * q.z;\n\n    float w = abs(q.x + bendFactor);\n    float road = sin(roadDetail * q.z + speed * iTime);\n\n    vec3 c;\n\n    if (w > roadWidth) {\n        bool vGrid = mod(w - roadWidth, 1.) > (1. - gridLineWidth);\n        bool hGrid = (road < 0. && road > -gridLineWidth * 3.);\n        \n        vec3 grid = (vGrid || hGrid) ? mix(gridColor, gridColor2, refl) : groundColor;\n        float blend = 1. - abs(p.y - horizonY);\n        c = mix(grid, groundColor, blend * blend);\n    }\n    else {\n        if (road > 0.) {\n            vec3 fragColor = w > (roadWidth - sideLineWidth) ? paintColor : roadColor;\n            c = fragColor;\n        }\n        else {        \n            vec3 fragColor = w > (roadWidth - sideLineWidth) ? paintColor2 : (w > (centerWidth * 0.5) ? roadColor2 : centerLineColor);   \n            c = fragColor;\n        }\n        \n        vec4 invSky = sky(-p + vec2(sin(30. * p.y + iTime * 2.) * 0.01, horizonY));\n        c.rgb = (invSky.rgb * refl) + c.rgb * (1. - refl);\n    }\n    \n    float d = abs(w - roadWidth);\n    d = min(d, w);    \n    d = max(d, road);\n    \n    return vec4(c, d);\n}\n\nvec3 scene(vec2 fragCoord)\n{\n    vec2 normFragCoord = ((fragCoord - 0.5 * iResolution.xy) / iResolution.yy) * 2.;\n    \n    vec4 c;\n    vec3 glowColor;\n    \n    if (normFragCoord.y > horizonY) {\n        c = sky(normFragCoord);\n    }\n    else {\n        vec4 skyColor = sky(normFragCoord);\n        vec4 roadColor = road(normFragCoord);\n    \n        c = roadColor;\n        glowColor = skyColor.a < roadColor.a ? sunDown : paintColor2;\n        c.a = min(skyColor.a, roadColor.a);\n        \n        c.rgb = roadColor.rgb;\n        \n        float glow = pow(glowRadius / c.a, glowIntensity);\n        c.rgb += glow * glowColor * glowColorFactor;\n    }\n    \n    return c.rgb;\n    //return 1. - c.aaa;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 c = scene(fragCoord);\n    fragColor.xyz = c.xyz;\n}","name":"Image","description":"","type":"image"}]}