{"ver":"0.1","info":{"id":"WlBXDR","date":"1565514517","viewed":120,"name":"Rocky sea","username":"jblanper","description":"Experimenting with noise functions and ray marching.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","noise","fbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float tt;\n\n// random / noise functions\n// htimeps://thebookofshaders.com/13/\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat random (in float n) {\n  //htimeps://thebookofshaders.com/11/\n  return fract(sin(n)*1e4);\n}\n\nfloat noise (float x) {\n  // htimeps://thebookofshaders.com/11/\n  float i = floor(x);\n  float f = fract(x);\n  return mix(random(i), random(i+1.), smoothstep(0., 1., f));\n}\n\n// Based on Morgan McGuire @morgan3d\n// htimeps://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\n// 3d functions\nvec2 map (vec3 p) {\n  float c = p.y;\n  c += fbm(p.xz) * fbm(vec2(fbm(p.zx + iTime), noise(vec2(iTime))));\n  c += noise(p.xx + length(iTime)) * .8;\n  vec2 t = vec2(c * .5, 1.);\n\n  return t;\n}\n\nvec2 trace (vec3 ro, vec3 rd) {\n  const float MAX_DEPTH = 50.;\n  vec2 h, t = vec2(.1);\n\n  for (int i = 0; i < 150; i++) {\n    h = map(ro + rd * t.x);\n    if (h.x < .0001 || t.x > MAX_DEPTH) break;\n    t.x += h.x; t.y = h.y;\n  }\n  if (t.x > MAX_DEPTH) t.x = 0.;\n  return t;\n}\n\nvec3 getNormal (vec3 p) {\n  float d = map(p).x;\n  vec2 e = vec2(.01, 0.);\n\n  return normalize(d - vec3(\n    map(p - e.xyy).x,\n    map(p - e.yxy).x,\n    map(p - e.yyx).x));\n}\n\nfloat getShadow(vec3 p, vec3 lightDir) {\n    float shadow = 1.0;\n    float t = 0.1;\n    for (int i = 0; i < 32; ++i)\n    {\n        vec3 ray = p + lightDir * t;\n        float d = map(ray).x;\n        shadow = min(shadow, d / t);\n        t += clamp(d, 0.0, 0.6);\n    }\n    return clamp(shadow * 2.0, 0.0, 1.0);\n}\n\nstruct Material {\n  float ambient;\n  float diffuse;\n  float specular;\n};\n\nfloat getLight (vec3 lightPos, vec3 p, vec3 rd, float lightOcclusion, Material material) {\n  // htimeps://www.shadertoy.com/view/ll2GW1\n  vec3 light = normalize(lightPos - p);\n  vec3 normal = getNormal(p);\n\n  float shadow = getShadow(p, light);\n\n  // phong reflection\n  float ambient = clamp(.5 + .5 * normal.y, 0., 1.);\n  float diffuse = clamp(dot(normal, light), 0., 1.) * shadow;\n  vec3 half_way = normalize(-rd + light);\n  float specular = pow(clamp(dot(half_way, normal), 0.0, 1.0), 16.) * (shadow + .5);\n\n  return (ambient * material.ambient * lightOcclusion) +\n   (diffuse * material.diffuse * lightOcclusion) +\n   (diffuse * specular * material.specular * lightOcclusion);\n}\n\nvec3 getRayDirection (vec2 uv, vec3 rayOrigin, vec3 lookat, float zoom) {\n  // htimeps://www.youtube.com/watch?v=PBxuVlp7nuM\n  vec3 forward = normalize(lookat - rayOrigin);\n  vec3 right = normalize(cross(vec3(0., 1., 0.), forward));\n  vec3 up = cross(forward, right);\n  vec3 center = rayOrigin + forward * zoom;\n  vec3 intersection = center + uv.x * right + uv.y * up;\n  return normalize(intersection - rayOrigin);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n  uv.x *= iResolution.x / iResolution.y;\n  tt = iTime * .3;\n\n  // camera\n  vec3 ro = vec3(0., 1., 2.);\n  vec3 rd = getRayDirection(uv, ro, vec3(0.), 2.);\n\n  // color, fog and light direction\n  vec3 ld = normalize(vec3(0., 25., -35.));\n  // vec3 ld = vec3(0., 2., 5.);\n  vec3 fogColor = vec3(.8, .4, .2);\n  vec3 fog = fogColor * (.5 + (length(uv) - .3));\n  vec3 color = fog;\n\n  // scene\n  vec2 sc = trace(ro, rd);\n  float t = sc.x;\n\n  if (t > 0.) {\n    vec3 p = ro + rd * t;\n    vec3 normal = getNormal(p);\n    vec3 albido = vec3(.8, .3, .2);\n\n    color = getLight(ld, p, rd, 1.5, Material(.2, .7, 1.2)) * vec3(.2, .4, .8);\n    color = mix(color, albido, .2);\n\n    color = mix(color, fog, 1. - exp(-.00002*t*t*t)); //gradient\n  }\n\n  fragColor = vec4(pow(color, vec3(.45)), 1.);\n}","name":"Image","description":"","type":"image"}]}