{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// 3D noise function\nfloat hash(vec3 p) {\n    p = fract(p * 0.3183099 + 0.1);\n    p *= 17.0;\n    return fract(p.x * p.y * p.z * (p.x + p.y + p.z));\n}\n\nfloat noise(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    \n    float n000 = hash(i + vec3(0, 0, 0));\n    float n100 = hash(i + vec3(1, 0, 0));\n    float n010 = hash(i + vec3(0, 1, 0));\n    float n110 = hash(i + vec3(1, 1, 0));\n    float n001 = hash(i + vec3(0, 0, 1));\n    float n101 = hash(i + vec3(1, 0, 1));\n    float n011 = hash(i + vec3(0, 1, 1));\n    float n111 = hash(i + vec3(1, 1, 1));\n\n    return 2.0*mix(\n        mix(mix(n000, n100, f.x), mix(n010, n110, f.x), f.y),\n        mix(mix(n001, n101, f.x), mix(n011, n111, f.x), f.y),\n        f.z\n    );\n}\n\n// SDF for a cylinder\nfloat cylinder(vec3 p, vec3 base, vec3 top, float radius) {\n    vec3 ba = top - base;\n    vec3 pa = p - base;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    vec3 closest = base + ba * h;\n    float dCylinder = length(p - closest) - radius;\n\n    // Flatten the bottom at `base.y`\n    float dPlane = p.y - base.y; // Distance above the base plane\n    return max(dCylinder, -dPlane); // Union with the base plane\n}\n\n\n// SDF for a smooshed sphere\nfloat smooshedSphere(vec3 p, vec3 center, vec3 radii) {\n    vec3 d = (p - center) / radii;\n    return length(d) - 1.0;\n}\n\n// SDF for a torus\nfloat torus(vec3 p, vec3 center, vec2 radii) {\n    vec3 q = p - center;\n    vec2 t = vec2(length(q.xz) - radii.x, q.y);\n    return length(t) - radii.y;\n}\n\n// Gradient function for coloring\nvec3 gradientColor(float t) {\n    if (t < 0.1) return mix(vec3(1.0), vec3(1.0, 1.0, 0.0), t / 0.1); // White to Yellow\n    if (t < 0.5) return mix(vec3(1.0, 1.0, 0.0), vec3(1.0, 0.5, 0.0), (t - 0.1) / 0.4); // Yellow to Orange\n    if (t < 0.9) return mix(vec3(1.0, 0.5, 0.0), vec3(0.5, 0.5, 0.5), (t - 0.5) / 0.4); // Orange to Gray\n    return mix(vec3(0.5, 0.5, 0.5), vec3(0.0), (t - 0.9) / 0.1); // Gray to Transparent\n}\n\n// Smooth emission intensity based on gradient\nfloat emissionIntensity(float t) {\n    if (t < 0.5) {\n        return smoothstep(0.5, 0.0, t);\n    }\n    return 0.0; // No emission beyond 0.5\n}\n\n// Animation for mushroom cloud with noise\nfloat animatedCap(vec3 p, float time, out float gradientValue) {\n    float loopTime = mod(time, 4.0);\n    float t = smoothstep(0.0, 1.0, loopTime / 4.0);\n    float delay = 0.0;\n\n    // Phase 1: Initial Burst (t < 0.1)\n    //if (t < 0.1) {\n    //    float normalizedT = t; // Normalize for smooth transitions\n    //    float cap = smooshedSphere(\n    //        p,    // Add turbulence\n    //        vec3(0.0, 0.0, 0.0),\n    //        vec3(0.5, 0.5, 0.5)\n    //    );\n    //    gradientValue = 0.1;\n    //    return cap;\n    //}\n\n    // Phase 2: Cloud Formation (t >= 0.1)\n    float normalizedT = (t - delay) / (1.0-delay); // Normalize for smooth transitions\n    float capHeight = mix(-1.5, 0.6, normalizedT); // Cap rising height\n    float capScale = mix(0.1, 2.0, normalizedT);   // Cap expands to maximum size\n    float cap = smooshedSphere(\n        p + noise(p * 2.0 + iTime * 0.5) * 0.1,    // Add turbulence\n        vec3(0.0, capHeight, 0.0),\n        vec3(capScale, capScale * 0.5, capScale)\n    );\n\n    // Add torus for billowing effect\n    vec3 torusCenter = vec3(0.0, capHeight - capScale * 0.25, 0.0);\n    float torusShape = torus(\n        p + noise(p * 3.0 + iTime * 0.3) * 0.05, // Add turbulence\n        torusCenter,\n        vec2(capScale * 0.8, 0.1)               // Major radius and thickness\n    );\n\n    // Column (base)\n    vec3 base = vec3(0.0, -1.5, 0.0);\n    vec3 top = vec3(0.0, capHeight, 0.0);\n    float columnRadius = mix(0.0, 1.25, normalizedT * 0.5);\n    float column = cylinder(\n        p + noise(p * 1.5 + iTime * 0.5) * 0.05, // Add turbulence\n        base, top, columnRadius\n    );\n\n    gradientValue = t;\n    return min(min(cap, column), torusShape); // Combine shapes\n}\n\n// Raymarching loop\nfloat raymarch(vec3 ro, vec3 rd, float time, out float gradientValue) {\n    float t = 0.0;\n    gradientValue = 0.0;\n    for (int i = 0; i < 128; i++) {\n        vec3 p = ro + rd * t;\n        float d = animatedCap(p, time, gradientValue);\n        if (d < 0.001) return t; // Surface hit\n        t += d;\n        if (t > 10.0) break;\n    }\n    return -1.0; // No hit\n}\n\n// Calculate normal using gradient approximation\nvec3 getNormal(vec3 p, float time) {\n    vec2 e = vec2(0.001, 0);\n    return normalize(vec3(\n        animatedCap(p + e.xyy, time, e.x) - animatedCap(p - e.xyy, time, e.x),\n        animatedCap(p + e.yxy, time, e.x) - animatedCap(p - e.yxy, time, e.x),\n        animatedCap(p + e.yyx, time, e.x) - animatedCap(p - e.yyx, time, e.x)\n    ));\n}\n\n// Render the scene\nvec4 render(vec3 ro, vec3 rd, float time) {\n    float gradientValue;\n    float t = raymarch(ro, rd, time, gradientValue);\n    if (t > 0.0) {\n        vec3 p = ro + rd * t;\n        vec3 normal = getNormal(p, time);\n        vec3 lightDir = normalize(vec3(1.0, 2.0, -1.0));\n        float lighting = dot(normal, lightDir) * 0.5 + 0.5;\n\n        // Apply gradient color\n        vec3 baseColor = gradientColor(gradientValue);\n\n        // Add emission with smooth transitions\n        float emission = emissionIntensity(gradientValue);\n        vec3 emissionColor = baseColor * emission;\n\n        // Combine lighting and emission\n        vec3 finalColor = baseColor * lighting + emissionColor;\n\n        return vec4(finalColor, 1.0 - gradientValue); // Add transparency\n    }\n    return vec4(0.0); // Background color\n}\n\n// Main entry point\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float duration = 2.0;\n    float timeFactor = 4.0/duration;\n    \n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, -4.0); // Camera position\n    vec3 rd = normalize(vec3(uv, 1.0)); // Ray direction\n\n    float time = iTime * timeFactor; // Animation time\n    fragColor = render(ro, rd, time);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lcGBRR","date":"1733674801","viewed":38,"name":"Rising Shroom","username":"b33j0r","description":"Start of a mushroom cloud sdf ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""}}