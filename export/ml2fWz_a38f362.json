{"ver":"0.1","info":{"id":"ml2fWz","date":"1693983662","viewed":23,"name":"Flower of Life Colored","username":"SyndaKai","description":"An animated, colored flower of life pattern","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","pattern","hex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// I wanted a new profile picture, and I've always been too stubborn\n// to learn basic tools like Illustrator et al, when I could\n// just program the darn thing! (I should've just learned it ;) )\n// But this is the result. The code is a bit of a mess, and I'm sure\n// people more familiar with this type of work could write it a lot more\n// succinctly, but I loved working on this either way, and I'm proud of it\n\n#define PI 3.1415926535\n\n// Convert 0-5 to the hex direction unit vectors\nvec2 dir(float i) {\n    float T = 2. * PI / 6.;\n    return vec2(cos(T*i), sin(T*i));\n}\n\nvec2 rotate(vec2 p, float r) {\n    return mat2(cos(r), sin(r), -sin(r), cos(r)) * p;\n}\n\nvec2 hexToUV(vec3 hex, float size) {\n    return mat2(\n        sqrt(3.), 0., \n        sqrt(3.)*.5, 3.*.5\n    ) * hex.xy * size;\n}\n\nvec3 UVToHex(vec2 uv, float size) {\n    vec2 axial = mat2(\n        sqrt(3.)/3., 0.,\n        -1./3., 2./3.\n    ) * uv.xy / size;\n    return vec3(axial, -axial.x-axial.y);\n}\n\n// Round fractional cube coordinate to the nearest hex\n// https://www.redblobgames.com/grids/hexagons/#rounding\nvec3 hexRound(vec3 frac) {\n    float q = round(frac.x);\n    float r = round(frac.y);\n    float s = round(frac.z);\n\n    float q_diff = abs(q - frac.x);\n    float r_diff = abs(r - frac.y);\n    float s_diff = abs(s - frac.z);\n\n    if (q_diff > r_diff && q_diff > s_diff) {\n        q = -r-s;\n    } \n    else if (r_diff > s_diff) {\n        r = -q-s;\n    }\n    else {\n        s = -q-r;\n    }\n    return vec3(q, r, s);\n}\n\nvec3 desaturate(vec3 color, float t) {\n    float lum = color.r * .3 + color.g * .59 + color.b * .11;\n    return mix(color, vec3(lum), t);\n}\n\nfloat sdCrescent(vec2 p, vec2 center, float rotation, float radius) {\n    float hexApothem = sqrt(3.)*.5;\n    vec2 offset = dir(rotation) * radius * hexApothem;\n    \n    vec2 centerA = center + offset;\n    float distA = length(p - centerA) - radius;\n    \n    vec2 centerB = center - offset;\n    float distB = length(p - centerB) - radius;\n    \n    return max(distA, distB);\n}\n\nfloat sdFlowerOfLife(float tiers, float radius, vec2 uv) {\n    float sdf = -1.;\n    float ir = sqrt(3.)*.5;\n    float adj = 1. - ir;\n    \n    int count = 0;\n    int totalCount = int(floor(iTime * 18.));\n    \n    for (float tier = 1.; tier <= tiers; tier++) {\n        vec2 cursor = vec2(.5, .5) + dir(0.)*radius*tier;\n        for (float side = 0.; side < 6.; side++) {\n            for (float hex = 0.; hex < tier; hex++) {\n                for (float segment = 0.; segment < 6.; segment++) {\n                    vec2 center = cursor + dir(segment+.5)*radius*ir;\n                    float c = -sdCrescent(uv, center, segment+.5, radius) / adj;\n                    sdf = max(sdf, c);\n                }\n                for (float segment = 0.; segment < 6.; segment++) {\n                    vec2 center = cursor + dir(segment)*radius*.5;\n                    float c = -sdCrescent(uv, center, segment+1.5, radius) / adj;\n                    sdf = max(sdf, c);\n                }\n                count++;\n                if (count >= totalCount) return sdf;\n                cursor += dir(side+2.)*radius;\n            }\n        }\n    }\n    return sdf;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Center uv coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv.x -= (iResolution.x-iResolution.y)*.5/iResolution.y;\n    \n    float radius = .14;\n    float ir = sqrt(3.)*.5; // Inner radius adjustment\n    float size = radius/ir;\n    \n    // Place segments for circles, tiers controls how many there are\n    float tiers = 2.;\n    float sdf = sdFlowerOfLife(tiers, radius, uv);\n    \n    // Each of the segments we placed will have a gradient\n    // unless we quantize the UV coordinates to the nearest rhombus\n    vec3 hexCoord = UVToHex(uv - vec2(0.5) - vec2(0.,.5)*size, size*.5);\n    vec3 hexCoordRounded = hexRound(hexCoord);\n    vec2 roundedUV = hexToUV(hexCoordRounded, size);\n    vec2 actualUV = hexToUV(hexCoord, size);\n    vec2 offset = actualUV - roundedUV;\n    \n    // Split hexagons into three rhombuses. \n    // A,B,C are 0 or 1 depending on which rhombus it is in\n    float slope = sqrt(3.)/3.;\n    float right = step(0., offset.x);\n    float left = 1. - right;\n    float A = step(abs(offset.x) * slope, offset.y);\n    float B = left * (1. - A);\n    float C = right * (1. - A);\n\n    // Sample at the center of the rhombus instead of at the given UV\n    vec2 sampleAt = roundedUV;\n    sampleAt += A * vec2(0., 1.) * size * .5;\n    sampleAt += B * vec2(-sqrt(3.)/4.,-1./4.) * size * .5;\n    sampleAt += C * vec2( sqrt(3.)/4.,-1./4.) * size * .5;\n\n    sampleAt += vec2(0., .5) * size; // loldunno\n    sampleAt = rotate(sampleAt, iTime*2.);\n\n    // Colors for each of the 6 directions\n    vec3 colors[] = vec3[](\n        vec3( 58./255., 52./255.,160./255.),//right\n        vec3( 37./255., 150./255.,191./255.),//right-up\n        vec3( 53./255.,119./255.,109./255.),//left-up\n        vec3(233./255.,216./255., 50./255.),//left\n        vec3(225./255., 94./255., 40./255.),//left-down\n        vec3(150./255., 40./255., 60./255.),//right-down\n        vec3( 58./255., 52./255.,160./255.) //right\n    );\n    \n    \n    float angle = atan(sampleAt.y, sampleAt.x);\n    \n    // Cool spiral (a little hard to notice without seeing underneath)\n    // angle -= length(sampleAt)*length(sampleAt)*.5;\n    \n    // Get angle in 0 - 2pi range\n    angle = mod(angle + 2.*PI, 2.*PI);\n    // Get to 0-6 rangle\n    angle = angle/2./PI*6.;\n    \n    // Sample nearest colors and lerp\n    vec3 lowColor = colors[int(floor(angle))];\n    vec3 highColor = colors[int(ceil(angle))];\n    vec3 sampledColor = mix(lowColor, highColor, mod(angle, 1.0));\n    \n    // Desaturate center, saturate edges\n    float desaturateAmount = .5 - length(sampleAt) * 1.5;\n    vec3 foreground = desaturate(sampledColor, desaturateAmount);\n    vec3 outline = vec3(208./255.,216./255.,229./255.);\n    vec3 background = vec3(53./255., 56./255., 63./255.) * .4;\n    \n    // Define outline based on SDF\n    float o = min(smoothstep(-0.01, 0.0, sdf), smoothstep(0.035, 0.025, sdf));\n    \n    // Convert SDF to 0-1 range\n    sdf = smoothstep(0., 0.01, sdf);\n    \n    vec3 col = mix(background, foreground, sdf);\n    col = mix(col, outline, o);\n    \n    fragColor = vec4(col, 1.0);\n    \n    // If you want to see the stuff underneath, uncomment this line\n    //fragColor = vec4(foreground, 1) + vec4(outline * o * .5, 1.);\n}","name":"Image","description":"","type":"image"}]}