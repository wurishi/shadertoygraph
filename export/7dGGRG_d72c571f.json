{"ver":"0.1","info":{"id":"7dGGRG","date":"1631771098","viewed":104,"name":"Ambient Occlusion CornellBox","username":"yunhai","description":"looks nice, just slow\nsettings is in 'Common'","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["gi","ao"],"hasliked":0,"parentid":"NdG3Ry","parentname":"RayMarching Env"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 O, in vec2 C )\n{\n    O=texelFetch(iChannel0,ivec2(C),0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n/*---------exp settings---------*/\n#define AO_ON\n//#define AO_ONLY\n\nconst float RAYNUM_PER_FRAME=10.;\nconst float RAYPASS_RADIUS=.4;\n/*------------------------------*/\n\n\n#define iR iResolution.xy\n#define iT iTime\n#define iM iMouse\nconst float MAX_DIST=20.;\nconst float MIN_DIST=1e-4;\nconst float MAX_STEP=50.;\nconst float EPS=1e-4;\nconst float PI=3.14159265;\nconst float DTA=PI/180.;\nstruct Ray\n{\n    vec3 o,d;\n};\nstruct Cam\n{\n    vec3 pos;\n}cam;\nstruct Point\n{\n    float d;\n    int id;\n};\nmat2x2 getRotMat(float r)\n{\n    r*=DTA;\n    float c=cos(r),s=sin(r);\n    return mat2x2(c,s,-s,c);\n}\nfloat sdCube(vec3 p,vec3 size)\n{\n    vec3 np=abs(p)-size*.5;\n    float o=length(max(np,vec3(0)));\n    float i=min(0.,max(np.x,max(np.y,np.z)));\n    return o+i;\n}\nfloat sdSphere(vec3 p,float s)\n{\n    return length(p)-s;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*------------OBJ DEFINE------------*/\nconst int OBJ_NUM=4;\nconst int ID_BOUND=0;\nconst int ID_BOX=1;\nconst int ID_LOWCUBE=2;\nconst int ID_HIGHCUBE=3;\nPoint sdf(vec3 p)\n{\n    Point[OBJ_NUM] objs;\n    objs[ID_BOUND]=Point(-sdSphere(p-vec3(0,0,0),MAX_DIST),ID_BOUND);//Bound\n\n    /*--------add objects begin--------*/\n    objs[ID_BOX]=Point(-sdCube(p-vec3(0,0,.5),vec3(1.3,1.,2.2)),ID_BOX);\n    \n    vec3 np=p;np-=vec3(.1,-.42,.83);\n    mat2x2 rot=getRotMat(-20.);np.xz*=rot;\n    objs[ID_LOWCUBE]=Point(sdCube(np,vec3(.2)),ID_LOWCUBE);\n    \n    np=p;np-=vec3(-.13,-.28,1.2);\n    rot=getRotMat(20.);np.xz*=rot;\n    objs[ID_HIGHCUBE]=Point(sdCube(np,vec3(.1,.2,.1)*2.3),ID_HIGHCUBE);\n    /*--------add objects end--------*/\n    \n    Point tar=objs[ID_BOUND];\n    for(int i=1;i<OBJ_NUM;i++)\n    {\n        if(tar.d>objs[i].d)\n            tar=objs[i];\n    }\n    return tar;\n}\nvec3 getNormal(vec3 p)\n{\n    vec2 e=vec2(0,EPS);\n    float c=sdf(p).d;\n    return normalize(vec3(sdf(p+e.yxx).d-c,\n                          sdf(p+e.xyx).d-c,\n                          sdf(p+e.xxy).d-c));\n}\n\nvec3 randomVec3(float off)\n{\n    float t=mod(iTime,iR.x);\n    vec3 a=texture(iChannel1,vec2(t,iTime/iR.x+off*2.)/iR).rgb;\n    return normalize((a-vec3(.5))*2.);\n}\nstruct FragInfo\n{\n    vec3 worldPos,normal,kc;\n    float ao;\n};\nvec3 pixelShade(in FragInfo I)\n{\n    vec3 lightPos=vec3(0.,.4,1.);\n    vec3 pl=lightPos-I.worldPos,ld;\n    float plLen=length(pl);\n    ld=pl/plLen;\n#ifndef AO_ONLY\n    vec3 diff=vec3(1)*max(dot(ld,I.normal),0.)/\n    (plLen*plLen)*.06;\n#else\n    vec3 diff=vec3(0);\n#endif\n    vec3 amb=vec3(0.1)*((1.-I.ao)*.8+.2);\n    return I.kc*(diff+amb);\n}\nPoint rayCast(Ray r)\n{\n    float d=0.;\n    Point point;\n    for(float i=0.;i<MAX_STEP;i++)\n    {\n        point=sdf(r.o+d*r.d);\n        if(abs(point.d)<MIN_DIST)\n            break;\n        float l=i/MAX_STEP;\n        d+=point.d*((1.-l*l*l)*0.5+0.5);\n        if(point.id==ID_BOUND)\n        {\n            d=MAX_DIST;\n            break;\n        }\n    }\n    point.d=d;\n    return point;\n}\nfloat getAO(vec3 p,vec3 n)\n{\n#ifndef AO_ON\n    return 0.;\n#else\n    float times=RAYNUM_PER_FRAME,dw=1./times;\n    float r=RAYPASS_RADIUS,acc=0.;\n    for(float f=0.;f<times;f++)\n    {\n        vec3 dir=normalize(n+randomVec3(f));\n        float d=rayCast(Ray(p+n*EPS,dir)).d;\n        acc+=(d<r?(1.-d/r):0.)*max(0.,dot(dir,n))*dw;\n    }\n    return acc;\n#endif\n}\n\nvec3 render(in Ray r)\n{\n    Point point=rayCast(r);\n    vec3 pos=r.o+r.d*point.d;\n    vec3 nml=getNormal(pos);\n    vec3 col=vec3(0);\n    switch (point.id)\n    {\n        case ID_BOUND:\n            break;\n        case ID_BOX:\n            vec3 kc=mix(vec3(1),nml.x*vec3(1,0,0)-nml.x*vec3(0,1,0),\n                        step(.5,abs(nml.x)));kc=max(kc,0.);\n            \n            col=pixelShade(FragInfo(pos,nml,kc,getAO(pos,nml)));\n            break;\n        case ID_LOWCUBE:\n        case ID_HIGHCUBE:\n            col=pixelShade(FragInfo(pos,nml,vec3(1),getAO(pos,nml)));\n            break;\n    }\n    return col;\n}\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    //AA\n    //C+=(vec2(iFrame%2,(iFrame/2)%2)-.5)*.5;\n    \n    \n    cam.pos=vec3(0,-.1,-.2);\n    Ray r=Ray(cam.pos,normalize(vec3((C-iR*.5)/iR.y,1.)));\n    vec3 col=render(r);\n    \n    /*interactive*/\n    O.rgb=col;\n    O=pow(O,vec4(.45));\n    /*offline*/\n    //O.rgb=mix(texture(iChannel0,C/iR).rgb,col,1./(float(iFrame)+1.));\n}","name":"Buffer A","description":"","type":"buffer"}]}