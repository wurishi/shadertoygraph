{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// Raymarching - Jose Angel Canabal\n// based on inigo quilez work\n\n// --------- Worley Noise ------------\n\n#define SIZE 6.0\n\n\nvec2 hash2D( vec2 p )\n{\n    float r = 523.0 * sin( dot( p, vec2( 53.3158, 43.6143 ) ) );\n    return vec2( fract( 15.32354 * r ), fract( 17.25865 * r ) );\n}\n\nvec3 hash3D( vec3 p )\n{\n    float r = 523.0 * sin( dot( p, vec3( 53.3158, 43.6143, 12.1687 ) ) );\n    return vec3( fract( 15.32354 * r ), fract( 17.25865 * r ), fract( 11.1021 * r ) );\n}\n\nmat4 getTranslationMatrix( vec3 t )\n{\n    mat4 tm = mat4( 1.0 );\n    \n    tm[0].z = t.x;\n    tm[1].z = t.y;\n    tm[2].z = t.z;\n    \n    return tm;\n}\n    \nvec3 worley( vec3 p, inout vec3 cp )\n{\n    // copy p if necessary\n    vec3 q = p;\n    \n    p *= SIZE;\n    \n    // get the pixel's cell\n    vec3 c = floor( p );\n    \n    // the three closest distances\n    vec3 f = vec3( 1e06 );\n    \n    // look for the closest point\n    for( int i=-1; i<=1; i++ )\n    for( int j=-1; j<=1; j++ )\n    for( int k=-1; k<=1; k++ )\n    {\n        // get the point at this grid cell\n        vec3 g = c + vec3( float( i ), float( j ), float( k ) );\n        vec3 o = g + hash3D( g);\n        // compute the distance between the current pixel and the grid point\n        vec3 r = p - o;\n        \n        // euclidean^2 distance\n        float d = dot( r, r );\n        // euclidean\n        //d = sqrt( d );\n        \n        //float d = length(r);\n        \n        // manhatan distance\n        //float d = abs( r.x ) + abs( r.y ) + abs( r.z );\n        \n        // check if it's the closest point\n        if( d < f.x )\n        {\n            f.z = f.y;\n            f.y = f.x;\n            f.x = d;\n            cp.x = o.x + o.y + o.z;\n        }\n        else if( d < f.y )\n        {\n            f.z = f.y;\n            f.y = d;\n            cp.y = o.x + o.y + o.z;\n        }\n        else if( d < f.z )\n        {\n            f.z = d;\n            cp.z = o.x + o.y + o.z;\n        }\n    }\n    \n    return f;\n}\n\n\n// signed distance field of a plane\nfloat sdPlane( vec3 p )\n{\n    return p.y;\n}\n\n// signed distance field of a sphere\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p) - s;\n}\n\n// sphere with a worley noise displacement\nfloat sdDisplacementSphere( vec3 p, vec3 f, vec3 cp, int fn )\n{\n    \n    float w = sqrt(f.x);\n    \n    // different combinations with the distances\n    if( fn == 1 ) \t\tw = 1.0 - f.x;\n    else if( fn == 2 ) \tw = f.y - f.x;\n    else if( fn == 3 )\tw = 0.5*f.x + 0.25*f.y + 0.125*f.z;\n    else if( fn == 4 )\tw = sqrt( 1.0 - 2.0*( 0.5*f.x - 0.1*f.y ) );\n\n    w = clamp( w, 0.0, 1.0 );\n        \n    float d1 = sdSphere( p, 1.0 );\n    float d2 = 0.06*( 1.0 - w );\n    //float d2 = 0.06*( 1.3 + 0.3*sin( 10.0*iTime ) )*(1.0 - w );\n    return d1 + d2;\n}\n\n// return the closest point\nvec2 computeVisibility( vec2 dm1, vec2 dm2 )\n{\n    return ( dm1.x < dm2.x ) ? dm1 : dm2;\n}\n\n// this function represent the scene. Return a signed distance and\n// a float that represents the material\nvec2 scene( vec3 pos )\n{  \n    vec3 cp = vec3( 2.0 );\n    vec3 f = worley( pos - vec3(  0.0, 1.0,  0.0  ), cp );\n    \n    vec2 dm = computeVisibility( \n        vec2( sdPlane( pos ), 1.0 ),\n        vec2( sdDisplacementSphere( pos - vec3( -5.0, 1.0, -2.0 ), f, cp, 0 ), 2.0 ) );\n    \n    dm = computeVisibility( dm, vec2( sdDisplacementSphere( pos - vec3(  -2.5, 1.0, -1.0 ), f, cp, 1 ), 3.0 ) );\n    dm = computeVisibility( dm, vec2( sdDisplacementSphere( pos - vec3(  0.0, 1.0,  0.0 ), f, cp, 2 ), 4.0 ) );\n    dm = computeVisibility( dm, vec2( sdDisplacementSphere( pos - vec3( 2.5, 1.0, -1.0 ), f, cp, 3 ), 3.0 ) );\n    dm = computeVisibility( dm, vec2( sdDisplacementSphere( pos - vec3( 5.0, 1.0, -2.0 ), f, cp, 4 ), 2.0 ) );\n    //vec2 dm = vec2( sdSphere( pos, 1.0 ), 1.0 );\n    return dm;\n}\n\n// computes the normal using finite differences\nvec3 calcNormal( vec3 pos )\n{\n    float eps = 0.01; // precission\n    float gradX = scene( pos + vec3(eps, 0.0, 0.0) ).x - scene( pos - vec3(eps, 0.0, 0.0)).x;\n    float gradY = scene( pos + vec3(0.0, eps, 0.0) ).x - scene( pos - vec3(0.0, eps, 0.0)).x;\n    float gradZ = scene( pos + vec3(0.0, 0.0, eps) ).x - scene( pos - vec3(0.0, 0.0, eps)).x;\n    return normalize( vec3( gradX, gradY, gradZ ) );\n}\n\nvec3 calcBackground( vec2 p )\n{\n    return vec3( 1.0 ) * ( 1.0 - 0.13 * length( p - vec2( 0.0 ) ) );\n}\n\nvec2 intersect( vec3 ro, vec3 rd )\n{\n    float e = 0.001;\t// precission\n    float tmin = 0.0;\t// minimum distance\n    float tmax = 32.0;\t// maximum distance\n    float t = 0.0;\t\t// intersection distance\n    float m = -1.0;\t\t// material representation\n    \n    // raymarching loop\n    for( int i=0; i<100; i++ )\n    {\n        vec2 dm = scene( ro + t*rd );\n        t += dm.x;\n        m = dm.y;\n        if( dm.x < e || t > tmax ) break;\n    }\n    \n    if( t > tmax ) m = -1.0;\n    return vec2( t, m );\n}\n\n// function that computes a hard shadow based on the position and light direction\nfloat shadow( vec3 pos, vec3 l )\n{\n    float tmin = 0.2;\n    float tmax = 6.0;\n    \n    float t = tmin;\n    for( int i=0; i<64; i++ )\n    {\n        vec2 dm = scene( pos + t*l );\n        if( dm.x < 0.001 ) return 0.0;\n        t += dm.x;\n    }\n    \n    return 1.0;\n}\n\n// function that computes a soft shadow based on the position and light direction\nfloat softShadow( vec3 pos, vec3 l )\n{\n    float tmin = 0.2;\n    float tmax = 6.0;\n    float k = 8.0;\t\t// small value produces more penumbra\n    float sh = 1.0;\t\t// initially not shadow\n    \n    float t = tmin;\n    for( int i=0; i<64; i++ )\n    {\n        float d = max( scene( pos + t*l ).x, 0.0 );\n        sh = min( sh, k*d / t );\n        t += clamp( d, 0.02, 0.1 );\n        if( d < 0.001 ) break;\n    }\n    \n    return clamp( sh, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // the coordinate of the pixel between [-1, 1]\n\tvec2 p = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    \n    // The ray equation r = ro + t*rd\n    // TODO: compute a real camera with FOV\n    vec3 ro = vec3( 0.0, 2.5, 3.6 );\t\t\t\t\t\t\t// camera position\n    \n    vec3 ta = vec3( 0.0, 0.5, 0.0 ); \t\t\t\t\t\t\t// target position\n    vec3 ww = normalize( ta - ro );\t\t\t\t\t\t\t\t// forward vector\n    vec3 uu = normalize( cross( ww, vec3( 0.0, 1.0, 0.0 ) ) );\t// right vector\n    vec3 vv = normalize( cross( uu, ww ) );\t\t\t\t\t\t// up vector\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    \n    // intersection\n    vec2 t = intersect( ro, rd );\n\n    // background\n    vec3 col = calcBackground( p );\n    \n    // check the intersection in order to get the color of the pixel\n    if( t.y > -0.5 )\n    {\n        vec3 pos = ro + t.x*rd;\n        vec3 n = calcNormal( pos );\n        \n        vec3 l = normalize( vec3( 1.5*sin(iTime), 0.8, 1.6 +0.6*cos(iTime) ) );\n        vec3 ref = reflect( rd, n );\n        \n        \n        float sh = softShadow( pos + 0.001*n, l );\n        \n        float con = 1.0;\n        float amb = 0.5 + 0.5*n.y;\n        float dif = max( dot( n, l ), 0.0 ) * sh;\n        float spe = pow( clamp( dot( ref, l ), 0.0, 1.0 ), 16.0 );\n        \n        \n        col  = 0.10 * con * vec3(0.80,0.90,1.00);\n        col += 0.70 * dif * vec3(1.00,0.97,0.85);\n        col += 0.60 * spe * vec3(0.80,0.90,1.00) * dif;\n        col += 0.20 * amb * vec3( 0.5, 0.4, 0.4 );\n        \n        if ( t.y < 1.5 ) \t\tcol *= 1.8*vec3( 0.3, 0.35, 0.40 ); \n        else if( t.y < 2.5 )\tcol *= vec3( 1.5, 0.9, 1.0 );\n        else if( t.y < 3.5 )\tcol *= vec3( 1.5, 0.75, 1.0 );\n        else if( t.y < 4.5 )\tcol *= vec3( 1.5, 0.6, 1.0 );\n        \n        //col = n;\n    }\n    \n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Mll3Wl","date":"1426259201","viewed":704,"name":"Raymarching displacement test","username":"jcanabald","description":"Testing some procedural displacements with raymarching techniques ","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","displacement","worley"],"hasliked":0,"parentid":"","parentname":""}}