{"ver":"0.1","info":{"id":"wdVBRh","date":"1677890438","viewed":535,"name":"Printf Debugging For Shaders!!!!","username":"foodini","description":"Replace render() in Common with your MainImage() function, and add TRACEs. Make whatever changes you like to debug_overlay in BufferA.  If anyone ends up using this, PLEASE COMPLAIN TO ME ABOUT PAIN POINTS!!! I want this to be something people use.","likes":9,"published":1,"flags":32,"usePreview":1,"tags":["debugging"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// CLICK ON A PIXEL YOU WANT TO DEBUG!!!\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//TODO:\n// * WASD to move the crosshairs by 1 pixel? If timedelta < 10fps, only move if \n//   iTime - iTimeDelta crosses a 100ms line so we have good control.\n// * Add zoom. A single pixel is too small to get a good look at. I'd like to\n//   have a way to zoom pixels to 4x4, 8x8, etc.\n\n//It just mysteriously fails if you use \"iTime\" or \"iResolution\" for these names. Sucks.\nfloat uniformTime;\nvec3 uniformResolution;\nint debug_trace_index;\nbool debug_trace_occurred;\nvec4 debug_trace_value;\n\nconst float reserved_float = -867.5309;\n\n#define DEBUG 1\n#if DEBUG\n\n//DEBUG_TRACE will not overwrite a previously-traced value in the current frame.\n#define DEBUG_TRACE(index, val) \\\n    do{\\\n        if(!debug_trace_occurred && index == debug_trace_index) {\\\n            debug_trace_value = val;\\\n            debug_trace_occurred = true;\\\n        }}while(false)\n//DEBUG_RETRACE will overwrite any value already recorded for this property.\n#define DEBUG_RETRACE(index, val) \\\n    do{\\\n        if(index == debug_trace_index) {\\\n            debug_trace_value = val;\\\n            debug_trace_occurred = true;\\\n        }}while(false)\n#define DEBUG_INCREMENT(index, val) \\\n    do{\\\n        if(index == debug_trace_index) {\\\n            if(debug_trace_val.x == reserved_float) \\\n                debug_trace_val = val;\\\n            else\\\n                debug_trace_val += val;\\\n        }}while(false)\n#else\n#define DEBUG_TRACE(index, val) do{}while(false)\n#define DEBUG_RETRACE(index, val) do{}while(false)\n#endif\n\nfloat sdRoundedBox( in vec3 p, in vec3 r) {\n    return length(max(abs(p) - r, 0.0)) - 0.20;\n}\n\nfloat map( in vec3 p) {\n\treturn sdRoundedBox(p, vec3(0.2, 0.2, 0.2));\n}\n\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float eps = 0.0001; // or some other value\n    const vec2 h = vec2(eps,0);\n    vec3 normal = normalize( \n        vec3(map(p+h.xyy) - map(p-h.xyy),\n             map(p+h.yxy) - map(p-h.yxy),\n             map(p+h.yyx) - map(p-h.yyx) ) );\n    return normal;\n}\n\nvoid render(out vec4 fragColor, in vec2 fragCoord, in vec3 resolutionIn, in float timeIn)\n{\n    uniformResolution = resolutionIn;\n    uniformTime = timeIn;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/uniformResolution.xy - 0.5) * 1.0;\n\n    uv.y /= uniformResolution.x/uniformResolution.y;\n\n\tvec3 view_plane = vec3(vec2(0.0) + (uv * 3.0), 0.0);\n    float view_plane_scale = 2.0;\n    vec3 cam_position = vec3(4.0 * sin(uniformTime), 3.0 + sin(uniformTime), 4.0*cos(uniformTime));\n    vec3 cam_lookat = vec3(0.0);\n    vec3 cam_direction = cam_lookat - cam_position;\n    vec3 cam_up = vec3(0.0, 1.0, 0.0); // This is only approximate. We'll fix it in a second.\n    vec3 cam_right = normalize(cross(cam_up, cam_direction));\n    cam_up = normalize(cross(cam_direction, cam_right));\n    \n    vec3 ray_direction = normalize(\n        cam_direction + view_plane_scale * cam_up * uv.y + view_plane_scale * cam_right * uv.x);\n    vec3 ray_pos = cam_position;\n    float dist;\n    float i;\n    float total_dist = 0.0;\n    for(i=0.0; i<100.0; i+=1.0) {\n        dist = map(ray_pos);\n        if(dist < 0.0001 || dist > 1000.0) {\n            break;\n        }\n        total_dist += dist;\n        ray_pos += ray_direction * (dist * 0.999);\n    }\n    DEBUG_TRACE(2, vec4(total_dist));\n    DEBUG_TRACE(3, vec4(i));\n    vec3 col;\n    if(dist < 1000.0) {\n        vec3 normal = calcNormal(ray_pos);\n        DEBUG_TRACE(0, vec4(normal, 1.0));\n        col = normal;\n    } else {\n        col = vec3(0.0);\n    }\n    col = max(col, 0.0);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    DEBUG_TRACE(1, fragColor);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// There are EIGHT coordinates reserved by this system. fragCoord == \n\n// iMouse.xy: fragCoord + 0.5 of the last mouse event \n// iMouse.z: Mouse button currently down.\n// iMouse.w: Mousedown event\n\n// fragCoord will be 0.5, 1.5, 2.5, etc.\n// iMouse will be 0.0, 1.0, 2.0... I've no fucking idea why.\n\n//thanks to Fabrice Neyret for algorhitm https://www.shadertoy.com/view/llySRh\n//and thanks to otaviogood for font texture\n#define C_r2l(c) out_color += char(U,64+c).xxxx; U.x+=.5\n#define C_l2r(c) out_color += char(U,64+c).xxxx; U.x-=.5\n\n#define _SPACE -32\n#define _MINUS -19\n#define _PERIOD -18\n#define _A 1\n#define _B 2\n#define _C 3\n#define _D 4\n#define _E 5\n#define _F 6\n#define _G 7\n#define _H 8\n#define _I 9\n#define _J 10\n#define _K 11\n#define _L 12\n#define _M 13\n#define _N 14\n#define _O 15\n#define _P 16\n#define _Q 17\n#define _R 18\n#define _S 19\n#define _T 20\n#define _U 21\n#define _V 22\n#define _W 23\n#define _X 24\n#define _Y 25\n#define _Z 26\n\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\n#define BLACK vec4(0.0) \n#define WHITE vec4(1.0)\n\nvec2 fragCoord_to_uv(in vec2 fragCoord) {\n    vec2 uv = fragCoord - iResolution.xy/2.0;\n    return uv*2.0/iResolution.x;\n}\n\nvec2 mouse_to_fragCoord() {\n    return iMouse.xy + 0.5;\n}\n\nvec2 mouse_to_uv() {\n    return fragCoord_to_uv(mouse_to_fragCoord());\n}\n\nvec4 draw_float(in float f, in vec2 position, in float fract_digits, in float font_size, in vec2 uv) {\n    vec4 out_color = vec4(0.0);\n    bool negative = false;\n\n    if(f == reserved_float) {\n        return vec4(0.0);\n    }\n\n\n    if(f < 0.0) {\n        negative = true;\n        f = -f;\n    }\n\n    // Add juuuuust enough to f that we'll round off the last digit. It'll turn\n    // 0.999999 into 0.9999995 which will then round off to 1.000000. Given how\n    // often normalized axial vectors end up being <0.999999, 0.0, 0.0>, this is\n    // a good thing.\n    f += 5.0 * pow(10.0, -(fract_digits + 1.0));\n\n    vec2 U = (uv - position)*64.0/font_size;\n    // Not sure I can explain this. It has to do with the default-to-centering of the font system and\n    // the left-to-right nature of printing in most cases.\n    U.x += (0.50 + 0.25); \n\n    int fraction = int(fract(f) * pow(10.0, fract_digits));\n    for(float i=0.0; i<fract_digits; i+=1.0) {\n        C_r2l((fraction%10) - 16);\n        fraction /= 10;\n    }\n    C_r2l(_PERIOD); // decimal point\n    \n    int mantissa = int(f);\n    \n    do{\n        C_r2l(mantissa%10 - 16);\n        mantissa /= 10;\n    } while(mantissa != 0);\n    if(negative) {\n        C_r2l(_MINUS);\n    }\n    \n    return out_color;\n}\n\nvec4 draw_string(in int[10]s, in vec2 position, in float font_size, in vec2 uv) {\n    vec4 out_color = vec4(0.0);\n\n    vec2 U = (uv - position)*64.0/font_size;\n    // Not sure I can explain this. It has to do with the default-to-centering of the font system and\n    // the left-to-right nature of printing in most cases.\n    U.x += (0.25); \n\n    for(int i=0; i<10; i++) {\n        C_l2r(s[i]);\n    }\n\n    return out_color;\n}\n\nint fps_string[10] = int[10](_F, _P, _S, _SPACE, _SPACE, _SPACE, _SPACE, _SPACE, _SPACE, _SPACE);\nint normal_string[10] = int[10](_N, _O, _R, _M, _A, _L, _SPACE, _SPACE, _SPACE, _SPACE);\nint color_string[10] = int[10](_C, _O, _L, _O, _R, _SPACE, _SPACE, _SPACE, _SPACE, _SPACE);\nint distance_string[10] = int[10](_D, _I, _S, _T, _A, _N, _C, _E, _SPACE, _SPACE);\nint iterations_string[10] = int[10](_I, _T, _E, _R, _A, _T, _I, _O, _N, _S);\nvec4 debug_overlay(vec2 fragCoord) {\n    vec2 uv = fragCoord_to_uv(fragCoord);\n    \n    vec4 out_color = BLACK;\n\n    float fps = 1.0/iTimeDelta;\n    vec2 position = vec2(1.0, -0.57);\n    float font_size = 2.9;\n    float char_width = font_size / 128.0;\n    float char_height = font_size / 64.0;\n    position.x -= char_width * 3.0;\n    out_color += draw_float(fps, position, 1.0, font_size, uv);\n    out_color += draw_string(fps_string, position, font_size, uv);\n\n    float str_left_side = -0.99;\n    float val_left_side = -0.33;\n    float first_row = 0.51;\n    float skip_right = 0.44;\n    float skip_down = char_height * 0.75;\n    position.y = first_row+skip_down;\n    vec4 texel;\n#if 1\n    position.x = str_left_side;\n    position.y -= skip_down;\n    \n    texel = texture(iChannel1, vec2(0.5, 0.5)/iResolution.xy);\n    out_color += draw_string(normal_string, position, font_size, uv);\n    position.x = val_left_side;\n    out_color += draw_float(texel.r, position, 6.0, font_size, uv);\n    position.x += skip_right;\n    out_color += draw_float(texel.g, position, 6.0, font_size, uv);\n    position.x += skip_right;\n    out_color += draw_float(texel.b, position, 6.0, font_size, uv);\n    position.x += skip_right;\n    out_color += draw_float(texel.a, position, 6.0, font_size, uv);\n#endif\n#if 1\n    position.x = str_left_side;\n    position.y -= skip_down;\n    \n    texel = texture(iChannel1, vec2(1.5, 0.5)/iResolution.xy);\n    out_color += draw_string(color_string, position, font_size, uv);\n    position.x = val_left_side;\n    out_color += draw_float(texel.r, position, 6.0, font_size, uv);\n    position.x += skip_right;\n    out_color += draw_float(texel.g, position, 6.0, font_size, uv);\n    position.x += skip_right;\n    out_color += draw_float(texel.b, position, 6.0, font_size, uv);\n    position.x += skip_right;\n    out_color += draw_float(texel.a, position, 6.0, font_size, uv);\n#endif\n#if 1\n    position.x = str_left_side;\n    position.y -= skip_down;\n    \n    texel = texture(iChannel1, vec2(2.5, 0.5)/iResolution.xy);\n    out_color += draw_string(distance_string, position, font_size, uv);\n    position.x = val_left_side;\n    out_color += draw_float(texel.x, position, 6.0, font_size, uv);\n#endif\n#if 1\n    position.x = str_left_side;\n    position.y -= skip_down;\n    \n    texel = texture(iChannel1, vec2(3.5, 0.5)/iResolution.xy);\n    out_color += draw_string(iterations_string, position, font_size, uv);\n    position.x = val_left_side;\n    out_color += draw_float(texel.r, position, 1.0, font_size, uv);\n#endif\n    \n    // \"Mouse Click To Debug\"\n    position.x = -0.485;\n    position.y = -0.5;\n    font_size = 6.0;\n    vec2 U = (uv - position)*64.0/font_size;\n    C_l2r(_M);C_l2r(_O);C_l2r(_U);C_l2r(_S);C_l2r(_E);C_l2r(_SPACE);\n    C_l2r(_C);C_l2r(_L);C_l2r(_I);C_l2r(_C);C_l2r(_K);C_l2r(_SPACE);\n    C_l2r(_T);C_l2r(_O);C_l2r(_SPACE);C_l2r(_D);C_l2r(_E);C_l2r(_B);C_l2r(_U);C_l2r(_G);\n    \n\n    return out_color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n#if DEBUG\n    debug_trace_index = -1;\n    debug_trace_occurred = false;\n    bool masked_overlay = false;\n    if(fragCoord.y == 0.5 && fragCoord.x < (0.5 + 8.0)) {\n        masked_overlay = true;\n        debug_trace_index = int(fragCoord.x);\n        render(fragColor, mouse_to_fragCoord(), iResolution, iTime);\n        fragColor=vec4(1.0);\n    } else {\n        render(fragColor, fragCoord, iResolution, iTime);\n    }\n    \n    if(debug_trace_index >= 0) {\n        if(debug_trace_occurred) {\n            fragColor = debug_trace_value;\n        } else {\n            fragColor = vec4(reserved_float);\n        }\n    }\n   \n    \n    // Protect the reserved pixels from being overwritten. Otherwise, the debug values\n    // we get in the next frame won't be the ones TRACEd, but the rgb values we wrote there\n    // as part of the overlay rendering.\n    if(!masked_overlay) {\n        float empty_radius = 3.0;\n        float reticle_size = 30.0;\n        if((abs(iMouse.x - fragCoord.x) <= 2.5 || abs(iMouse.y - fragCoord.y) <= 2.5) &&\n           (abs(iMouse.x - fragCoord.x) > empty_radius || abs(iMouse.y - fragCoord.y) > empty_radius) &&\n           (abs(iMouse.x - fragCoord.x) < reticle_size && abs(iMouse.y - fragCoord.y) < reticle_size)) {\n            if(abs(iMouse.x - fragCoord.x) <= 1.0 || abs(iMouse.y - fragCoord.y) <= 1.0) {\n                fragColor = vec4(1.0);\n            } else {\n                fragColor = vec4(0.0);\n            }\n        }\n\n        vec4 overlay = debug_overlay(fragCoord);\n        if(overlay != vec4(0.0)) {\n            fragColor = overlay;\n        }\n    }\n#else\n    render(fragColor, fragCoord, iResolution, iTime);\n#endif\n}","name":"Buffer A","description":"","type":"buffer"}]}