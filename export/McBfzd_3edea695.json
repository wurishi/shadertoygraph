{"ver":"0.1","info":{"id":"McBfzd","date":"1725456397","viewed":38,"name":"KNN","username":"Ultraviolet","description":"Uses the k nearest neighbors of each pixel to determine its color via majority pooling.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["knn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON (1e-8)\n#define SPEED 0.5\n#define NB_PARTICLES 50\n#define NB_CLASSES 3\n#define NB_NEIB 5\n#define WEIGHT_FALLOFF 0.05\n\n// display options\n//#define DRAW_GRID\n#define DRAW_PARTICLE\n\n// choose btw uniform and inv distance weights\n//#define UNIFORM_WEIGHTS\n\n// choose btw classification & regression\n//#define REGRESSION\n\nfloat radius = 0.03;\n\n\n#define SCREEN2WORLD(X)  ((X -iResolution.xy*.5)/iResolution.y*3.)\n\n\nvoid BoxReflect(inout float p, in float bbmin, in float bbmax)\n{    \n    p =  bbmax-(abs(bbmax-mod( p - bbmin, (bbmax-bbmin)*2.) - bbmin));    \n}\n\nvoid BoxReflect(inout vec2 p, in vec2 bbmin, in vec2 bbmax)\n{\n    BoxReflect(p.x, bbmin.x, bbmax.x);\n    BoxReflect(p.y, bbmin.y, bbmax.y);\n}\n\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb);\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// thx Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec2 rest_pos(int id) {\n    return SCREEN2WORLD(hash21(float(id)) * iResolution.xy);\n}\n\nvec2 speed(int id) {\n    float alpha = hash11(float(id)) * 2. * PI;\n    return vec2(cos(alpha), sin(alpha)) * SPEED;\n}\n\nvec2 pos(int id) {\n    vec2 low  = SCREEN2WORLD(vec2(0.));\n    vec2 high = SCREEN2WORLD(iResolution.xy);\n    \n    vec2 p = rest_pos(id) + iTime*speed(id);\n    BoxReflect(p, vec2(radius)+low, high-vec2(radius));\n    \n    return p;\n}\n\nint label(int id) {\n    return id % NB_CLASSES;\n}\n\nvec3 class_color(int c, float s) {\n    if(c < 0)\n        return vec3(1.);\n\n    float v = 1.;\n    return hsv2rgb_smooth(vec3(float(c) / float(NB_CLASSES), s, v));\n}\n\nint argmax(float pool[NB_CLASSES]) {\n    int cur = 0;\n    \n    for(int c=1; c < NB_CLASSES; ++c) {\n        if(pool[c] > pool[cur])\n            cur = c;\n    }\n    \n    // resolve equalities\n    for(int c=0; c < NB_CLASSES; ++c) {\n        if(c != cur && abs(pool[c] - pool[cur]) < EPSILON)\n            return -1;\n    }\n    \n    \n    return cur;\n}\n\nfloat maximum(vec2 x) {\n    return x.x>x.y?x.x:x.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 X = SCREEN2WORLD(fragCoord);\n    vec3 col = vec3(0.);\n    \n    float dists[NB_NEIB];\n    int neib[NB_NEIB];\n    \n    float lowest = 0.;\n    for(int n=0; n < NB_NEIB; ++n) {\n        dists[n] = 10000.;\n        neib[n] = -1;\n        for(int i=0; i < NB_PARTICLES; ++i) {\n            vec2 p0 = pos(i);\n            float d = length(p0 - X);\n            //float d = maximum(abs(p0 - X));\n            if(lowest + 1e-5 < d && d < dists[n])\n            {\n                dists[n] = d;\n                neib[n] = i;\n            }\n        }\n        lowest = dists[n];\n    }\n    \n    // DEBUG:\n    //col = vec3(dists[1]);\n    //col = class_color(label(neib[0]), 0.5);\n    //col = class_color(label(neib[1]), dists[1]);\n    \n#ifndef REGRESSION\n    \n    float class_pool[NB_CLASSES];\n    \n    for(int c=0; c < NB_CLASSES; ++c) {\n        class_pool[c] = 0.;\n    }\n    for(int n=0; n < NB_NEIB; ++n) {\n#ifdef UNIFORM_WEIGHTS\n        float w = 1.;\n#else\n        //float w = 1. / dists[n];\n        //float w = 1. / dists[n] / dists[n];\n        float w = exp(-dists[n] / WEIGHT_FALLOFF);\n#endif\n        class_pool[label(neib[n])] += w;\n    }\n    int majority_class = argmax(class_pool);\n    col = class_color(majority_class, 0.5);\n    \n#else\n    \n    float weight = 0.;\n    \n    for(int n=0; n < NB_NEIB; ++n) {\n#ifdef UNIFORM_WEIGHTS\n        float w = 1.;\n#else\n        //float w = 1. / dists[n];\n        //float w = 1. / dists[n] / dists[n];\n        float w = exp(-dists[n] / WEIGHT_FALLOFF);\n#endif\n        col = (col * weight + class_color(label(neib[n]), 0.5) * w) / (weight + w);\n        weight += w;\n    }\n    \n#endif\n\n\n#ifdef DRAW_GRID\n    DRAW_C(Grid(1.), X, vec3(.1), .5, col);\n    DRAW_C(Ray(vec2(0.), vec2(1.,0.)), X, vec3(.0), 1., col);\n    DRAW_C(Ray(vec2(0.), vec2(0.,1.)), X, vec3(.0), 1., col);\n#endif\n    \n    \n#ifdef DRAW_PARTICLE\n    for(int i=0; i < NB_PARTICLES; ++i) {\n        vec2 p0 = pos(i);\n        vec3 col_cir = class_color(label(i),1.);\n        \n        DRAW(Circle(p0, radius), X, col_cir, col);\n    }\n#endif\n\n    if(iMouse.z > 0.5) {\n    \n        vec2 m = SCREEN2WORLD(iMouse.xy);\n        float lowest = 0.;\n        for(int n=0; n < NB_NEIB; ++n) {\n            dists[n] = 10000.;\n            neib[n] = -1;\n            for(int i=0; i < NB_PARTICLES; ++i) {\n                vec2 p0 = pos(i);\n                float d = length(p0 - m);\n                //float d = maximum(abs(p0 - X));\n                if(lowest + 1e-5 < d && d < dists[n])\n                {\n                    dists[n] = d;\n                    neib[n] = i;\n                }\n            }\n            lowest = dists[n];\n        }\n        \n        for(int n=0; n < NB_NEIB; ++n) {\n            DRAW_C(Segment(m, pos(neib[n])), X, vec3(1.), 1., col);\n        }\n        \n        \n    }\n    \n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n\n////////////////////////////////////////////////////////////////////////////\n//      ___  ____  __   _  _  ____  ____  ____  _  _      __    __  ____ \n//     / __)(  __)/  \\ ( \\/ )(  __)(_  _)(  _ \\( \\/ )    (  )  (  )(  _ \\\n//    ( (_ \\ ) _)(  O )/ \\/ \\ ) _)   )(   )   / )  /     / (_/\\ )(  ) _ (\n//     \\___/(____)\\__/ \\_)(_/(____) (__) (__\\_)(__/      \\____/(__)(____/\n//\n////////////////////////////////////////////////////////////////////////////\n\n\n#define PI 3.14\n\n\n//---------------------------------------\n// Point\n\nfloat dist(vec2 p0, vec2 p1)\n{\n    return length(p1-p0);\n}\n\n\n\n\n//---------------------------------------\n// Circle\n\nstruct Circle\n{\n    vec2 ctr;\n    float rad;\n};\n\nvec2 getPt(Circle c, float t)\n{\n    return c.ctr + c.rad*vec2(cos(t*PI*2.), sin(t*PI*2.));\n}\n    \nfloat dist(Circle c, vec2 p)\n{\n    return (length(c.ctr-p)-c.rad);\n}\n\n    \n    \n//---------------------------------------\n// Ray\n\nstruct Ray\n{\n    vec2 org;\n    vec2 dir;\n};\n    \nvec2 getPt(Ray r, float t)\n{\n    return r.org + t*r.dir;\n}\n\nfloat dist(Ray r, vec2 p)\n{\n    return abs(dot(r.dir.yx*vec2(-1., 1.), p-r.org)/dot(r.dir, r.dir));\n    \n    \n    float t = dot(r.dir, p-r.org);\n    t = max(t, 0.);\n    return length(getPt(r, t) - p);\n}\n\n\n\n\n//---------------------------------------\n// Segment\n\nstruct Segment\n{\n    vec2 A;\n    vec2 B;\n};\n\nvec2 getPt(Segment c, float t)\n{\n    return mix(c.A, c.B, t);\n}\n\nfloat dist(Segment s, vec2 p)\n{\n\tvec2 pa = p-s.A, ba = s.B-s.A;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n\n\n\n\n//---------------------------------------\n// Triangle\n\nstruct Triangle\n{\n    vec2 p0;\n    vec2 p1;\n    vec2 p2;\n};\n\n\nfloat dist(Triangle t, in vec2 p )\n{\n\tvec2 e0 = t.p1 - t.p0;\n\tvec2 e1 = t.p2 - t.p1;\n\tvec2 e2 = t.p0 - t.p2;\n\n\tvec2 v0 = p - t.p0;\n\tvec2 v1 = p - t.p1;\n\tvec2 v2 = p - t.p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n\n//---------------------------------------\n// Grid\n\nstruct Grid\n{\n    float inter;\n}; \n\nfloat dist(Grid g, vec2 p)\n{\n    vec2 d = abs(mod(p+g.inter*.5,g.inter*2.)-g.inter)-g.inter*.5;\n    return max(min(d.x, d.y), min(-d.x, -d.y));\n}\n\n\n\n\n//---------------------------------------\n// Drawing Macros\n\n// draw the inside of the shape\n// O = object, P = point, C = drawing color, CC = original color\n#define DRAW(O,P,C,CC)\tCC=mix(CC,C,mix(1.,0.,clamp(dist(O,P)*iResolution.y/2., -1., 1.)*.5+.5))\n\n// draw the inside of the shape, with alpha\n#define DRAW_A(O,P,C,CC)\tCC=mix(CC,C.rgb,(mix(1.,0.,clamp(dist(O,P)*iResolution.y/2., -1., 1.)*.5+.5))*C.a)\n\n// draw the contour of the shape \n#define DRAW_C(O,P,C,W,CC)\tCC=mix(CC,C,mix(1.,0.,clamp(abs(dist(O,P))*iResolution.y/2.-W, -1., 1.)*.5+.5))\n\n// draw the contour of the shape with alpha\n#define DRAW_CA(O,P,C,W,CC)\tCC=mix(CC,C.rgb,(mix(1.,0.,clamp(abs(dist(O,P))*iResolution.y/2. -  W, -1., 1.)*.5+.5))*C.a)\n\n\n\n","name":"Common","description":"","type":"common"}]}