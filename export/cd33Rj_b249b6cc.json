{"ver":"0.1","info":{"id":"cd33Rj","date":"1677894032","viewed":185,"name":"The wall of speakers by yasuo","username":"curiouspers","description":"Animated and colorized Fork of \"The wall of speakers\" by yasuo https://shadertoy.com/view/DdSGWh\nI just added some materials and animated it a bit\nFXAA from Makio64 https://www.shadertoy.com\nsound:\nminutesunlimited\nhttps://soundcloud.com/minutesunlimited","likes":11,"published":1,"flags":96,"usePreview":1,"tags":["graphicdesign","cineshader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"The wall of speakers\" by yasuo. https://shadertoy.com/view/DdSGWh\n// I just added some materials and animated it a bit\n// Check BufferA\n\n// Image - FXAA from Makio64 https://www.shadertoy.com/view/Xst3WX\n// FXAA from https://github.com/mattdesl/glsl-fxaa\n\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#define FXAA_SPAN_MAX     16.0\n\nvoid texcoords(vec2 fragCoord, vec2 resolution,\n\t\t\tout vec2 v_rgbNW, out vec2 v_rgbNE,\n\t\t\tout vec2 v_rgbSW, out vec2 v_rgbSE,\n\t\t\tout vec2 v_rgbM) {\n\tvec2 inverseVP = 1.0 / resolution.xy;\n\tv_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n\tv_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n\tv_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n\tv_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n\tv_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\n            vec2 v_rgbNW, vec2 v_rgbNE, \n            vec2 v_rgbSW, vec2 v_rgbSE, \n            vec2 v_rgbM) {\n    vec4 color;\n    mediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n    vec3 rgbNW = texture(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture(tex, v_rgbSE).xyz;\n    vec4 texColor = texture(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n              dir * rcpDirMin)) * inverseVP;\n    vec3 rgbA = 0.5 * (\n        texture(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n        texture(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mediump vec2 v_rgbNW;\n\tmediump vec2 v_rgbNE;\n\tmediump vec2 v_rgbSW;\n\tmediump vec2 v_rgbSE;\n\tmediump vec2 v_rgbM;\n\ttexcoords(fragCoord, iResolution.xy, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n    fragColor = fxaa( iChannel0, fragCoord, iResolution.xy, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);   \n    //fragColor = texture( iChannel0, fragCoord/iResolution.xy);   \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4tBSDd","filepath":"https://soundcloud.com/minutesunlimited/violation-twanz-nola-bounce-flip","previewfilepath":"https://soundcloud.com/minutesunlimited/violation-twanz-nola-bounce-flip","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Fork of \"The wall of speakers\" by yasuo. https://shadertoy.com/view/DdSGWh\n// I just added some materials and animated it a bit\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .0005\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define Tri(p,s,a) max(-dot(p,vec2(cos(-a),sin(-a))),max(dot(p,vec2(cos(a),sin(a))),max(abs(p).x-s.x,abs(p).y-s.y)))\n#define DF(a,b) length(a) * cos( mod( atan(a.y,a.x)+6.28/(b*8.0), 6.28/((b*8.0)*0.5))+(b-1.)*6.28/(b*8.0) + vec2(0,11) )\n#define ZERO (min(iFrame,0))\n\n// materials\n#define BASE 10.\n#define MEMBRANE 11.\n#define METAL 12.\n#define BOLTS 13.\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(234.56,789.34));\n    p+=dot(p,p+34.56);\n    return fract(p.x+p.y);\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xy)-t.x,p.z);\n    return length(q)-t.y;\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\n// tweaked as the center aligned horizontal capsule. \nfloat sdHorizontalCapsule( vec3 p, float w, float r )\n{\n  p.x-= clamp( p.x, -w*0.5, w*0.5 );\n  return length( p ) - r;\n}\n\nvec2 speaker(vec3 p, vec4 sound){\n    vec3 prevP = p;\n    \n    float anim1 = sound.y*0.1;//sin(iTime*5.)*0.025;\n    float anim2 = sound.z*0.05;\n    \n    float d = sdBox(p, vec3(0.45,0.95,0.34))-0.03;\n    float d2 = length(p-vec3(0.,-0.2,-0.53-anim1))-0.38+anim1/5.;\n    d = max(-d2,d); // bowl\n    \n    d2 = sdTorus(p-vec3(0.,-0.2,-0.36),vec2(0.36,0.03));\n    d = min(d,d2);\n    \n    d2 = sdTorus(p-vec3(0.,-0.2,-0.32-anim1),vec2(0.32,0.025));\n    d = min(d,d2);\n    d2 = length(p-vec3(0.,-0.25,-0.08-anim1))-0.12;\n    d = min(d,d2);\n    \n    d2 = sdHorizontalCapsule(p-vec3(0.,-0.75,-0.36),0.6,0.06);\n    d = max(-d2,d);\n    \n    d2 = length(p-vec3(0.,0.55,-0.36+anim2))-0.2-anim2;\n    d = max(-d2,d); // small bowl\n    \n    \n    d2 = sdTorus(p-vec3(0.,0.55,-0.36),vec2(0.2,0.03));\n    d = min(d,d2);\n    \n    // color base\n    float mat = BASE;\n    // metal rim\n    mat = d > .001 ? METAL : mat;\n    // bolts \n    mat = d > .0005 ? BOLTS : mat;\n    // color membrane\n    float d3 = length(p-vec3(0.,-0.2,-0.53))-0.29;\n    mat = d3 < 0.1 ? MEMBRANE : mat;\n    mat = d3 > 0.1 && d3 < 0.1+0.035 ? METAL : mat;\n    d3 = length(p.xy-vec3(0.,0.55,-0.36).xy)-0.17;\n    mat = d3 < 0.06 ? MEMBRANE : mat;\n    mat = d3 > 0.06 && d3 < 0.06+0.025 ? METAL : mat;\n    \n    p.z-=-0.36;\n    p.x = abs(p.x)-0.4;\n    p.y = abs(p.y)-0.9;\n    d2 = length(p)-0.03;\n    d = min(d,d2);\n    \n    return vec2(d,mat);\n}\n\nvec2 speaker2(vec3 p, vec4 sound){\n    vec3 prevP = p;\n    \n    float anim = sound.z*0.1;\n    \n    float d = sdBox(p, vec3(0.95,0.45,0.34))-0.03;\n    float d2 = sdBox(p-vec3(0.,0.,-0.35), vec3(0.9,0.4,0.01))-0.03;\n    d = max(-d2,d);\n    \n    p.x = abs(p.x);\n    d2 = length(p-vec3(0.4,0.,-0.5-anim))-0.36;\n    d = max(-d2,d); // bowl\n    \n    d2 = sdTorus(p-vec3(0.4,0.,-0.3),vec2(0.34,0.03));\n    d = min(d,d2); // rim\n    \n    d2 = sdTorus(p-vec3(0.4,0.,-0.29-anim),vec2(0.3,0.025));\n    d = min(d,d2); // ring1\n    d2 = length(p-vec3(0.45,0.,-0.08-anim*2.))-0.1;\n    d = min(d,d2); // center\n    \n    // color base\n    float mat = BASE;\n    // metal rim\n    mat = d > .001 ? METAL : mat;\n    // bolts \n    mat = d > .0005 ? BOLTS : mat;\n    // color membrane\n    float d3 = length(p-vec3(0.4,0.,-0.5))-0.27;\n    mat = d3 < 0.11 ? MEMBRANE : mat;\n    mat = d3 > 0.11 && d3 < 0.11+0.036 ? METAL : mat;\n    \n    p.z-=-0.3;\n    p.x = abs(p.x)-0.86;\n    p.y = abs(p.y)-0.36;\n    d2 = length(p)-0.03;\n    d = min(d,d2);    \n    \n    \n    return vec2(d,mat);\n}\n\nvec2 speaker3(vec3 p, vec4 sound){\n    vec3 prevP = p;\n    float anim = sound.x*0.1;\n    anim += sound.y*0.05;\n    float d = sdBox(p, vec3(0.95,0.95,0.34))-0.03;\n    \n    float d2 = length(p-vec3(0.0,0.,-0.68-anim))-0.66;\n    d = max(-d2,d); // bowl\n    // color base\n    float mat = BASE;\n    // metal rim\n    mat = d > .0015 ? METAL : mat;\n    // bolts \n    mat = d > .011 ? BOLTS : mat;\n    // color membrane\n    float d3 = length(p-vec3(0.0,0.,-0.68))-0.66;\n    mat = d3 < 0.1 ? MEMBRANE : mat;\n    \n    d2 = sdTorus(p-vec3(0.0,0.,-0.35),vec2(0.64,0.05));\n    d = min(d,d2); // rim\n    \n    d2 = sdTorus(p-vec3(0.0,0.,-0.33),vec2(0.6,0.045));\n    d = min(d,d2);\n    \n    d2 = length(p-vec3(0.0,0.,0.1-anim))-0.2;\n    d = min(d,d2); // center\n    \n    d2 = sdTorus(p-vec3(0.0,0.,-0.3-anim*.6),vec2(0.56,0.035));\n    d = min(d,d2); // ring1\n    \n    d2 = sdTorus(p-vec3(0.0,0.,-0.24-anim*.9),vec2(0.52,0.035));\n    d = min(d,d2); // ring2\n        \n    d2 = sdTorus(p-vec3(0.0,0.,-0.19-anim),vec2(0.47,0.035));\n    d = min(d,d2); // ring3\n    \n    \n    d2 = abs(length(p.xy)-0.73)-0.07;\n    d = min(d,max((abs(p.z)-0.38),d2));\n    \n    p.z-=-0.37;\n    p.x = abs(p.x)-0.86;\n    p.y = abs(p.y)-0.86;\n    d2 = length(p)-0.03;\n    d = min(d,d2);    \n    \n    p = prevP;\n    p.z-=-0.37;\n    p.xy = DF(p.xy,3.0);\n    p.xy -= vec2(0.52);\n    d2 = length(p)-0.03;\n    d = min(d,d2); \n    \n    p = prevP;\n    p.xy*=Rot(radians(sin(iTime)*120.));\n    p.z-=-0.37;\n    p.y=abs(p.y)-0.93;\n    d2 = Tri(p.xy,vec2(0.08),radians(45.));\n    d = min(d,max((abs(p.z)-0.02),d2));    \n    \n    p = prevP;\n    p.xy*=Rot(radians(90.+sin(iTime)*120.));\n    p.z-=-0.37;\n    p.y=abs(p.y)-0.93;\n    d2 = Tri(p.xy,vec2(0.08),radians(45.));\n    d = min(d,max((abs(p.z)-0.02),d2));      \n    \n    return vec2(d,mat);\n}\n\nvec2 changeSpeakers(vec3 p, float start, float speed, vec4 sound){\n    vec3 prevP = p;\n    float endTime = 3.;\n    float t = iTime*speed;\n    float scenes[3] = float[](0.,1.,2.);\n    for(int i = 0; i<scenes.length(); i++){\n        scenes[i] = mod(scenes[i]+start,endTime);\n    }\n    \n    float scene = scenes[int(mod(t,endTime))];\n    \n    vec2 d = vec2(10.,-1.);\n    if(scene<1.) {\n        p.x=abs(p.x)-0.5;\n        d = speaker(p, sound);\n        //d.y = 1.;\n    } else if (scene >= 1. && scene<2.){\n        p.y=abs(p.y)-0.5;\n        d = speaker2(p, sound);\n        //d.y = 2.;\n    } else {\n        d = speaker3(p, sound);\n        //d.y = 3.;\n    }\n    \n    return d;\n}\n\nvec2 GetDist(vec3 p, vec4 sound) {\n    vec3 prevP = p;\n    \n    p.y -=iTime*0.5;\n    vec2 id = floor(p.xy*0.5);\n    p.z-=3.;\n    p.xy = mod(p.xy,2.0)-1.0;\n\n    id*=.5;\n    float rand = Hash21(id);\n    \n    vec2 d = vec2(10.,-1.);\n    p.z-=rand*0.3;\n    if(rand<0.3) {\n        d = changeSpeakers(p,1.,0.5+rand, sound);\n    } else if(rand>=0.3 && rand<0.7) {\n        d = speaker3(p, sound);\n    } else {\n        p.x=abs(p.x)-0.5;\n        d = speaker(p, sound);\n        //d.y = 5.;\n    }\n    \n    return d;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum, vec4 sound) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p, sound);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p, vec4 sound) {\n    float d = GetDist(p, sound).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy, sound).x,\n        GetDist(p-e.yxy, sound).x,\n        GetDist(p-e.yyx, sound).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor, vec4 sound )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos, sound ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col, float mat, vec4 sound) {\n    float occ = calcOcclusion(p,n, sound);\n    occ = pow(occ,1.5);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1.,10,-10));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15, sound).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*shadow*occ;\n    diffCol += col*vec3(1.0,1.0,0.9)*skyDiff*occ;\n    diffCol += col*vec3(0.3,0.3,0.3)*bounceDiff*occ;\n    \n    float specMul = mat == METAL ? 500. : mat == BOLTS ? 200. : mat == MEMBRANE ? 2.: 5.;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 60.)*specMul*occ; // spec\n        \n    return diffCol;\n}\nvec3 materials(float mat, vec3 n, vec3 rd, vec3 p, vec3 col, vec4 sound){\n    float depth = (length(p/100.));\n    depth = clamp(1.0-depth*20.,.0,1.0);\n    if (mat == 1.0)\n        col = vec3(.1);\n    else if (mat == 2.0)\n        col = vec3(.3);\n    else if (mat == 3.0)\n        col = vec3(.5);\n    else if (mat == 4.0)\n        col = vec3(.6);\n    else if (mat == 5.0)\n        col = vec3(.8);        \n    else if (mat == MEMBRANE) \n        col = vec3(.025);//+ ((sin((p.x)*1000.)+sin((p.y)*1000.))*.01*depth)*0.5;\n    else if (mat == METAL) \n        col = vec3(.25)+ (sin((p.x+p.y)*500.+cos(p.x*7.))*.2+.1)*(depth);\n    else if (mat == BOLTS) \n        col = vec3(.01);\n    else if (mat == BASE) \n        //col = vec3(0.600,0.557,0.502)+ (sin(p.y*100.+cos(p.x*7.))*.02+.1);\n        col = 1.3*vec3(0.666,0.6,0.529)+ (sin((p.y-iTime*0.3)*100.+cos(p.x*7.))*.02+.1);\n    else \n        col = vec3(1.3);\n    //col = vec3(mat*255);\n    col = diffuseMaterial(n,rd,p,col,mat, sound);\n    //col = vec3(depth);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy;\n    // sound\n    // thanks FabriceNeyret2 for \n    // https://www.shadertoy.com/view/lsscWH# and\n    // https://shadertoyunofficial.wordpress.com/2016/07/20/special-shadertoy-features/\n    float M = iSampleRate;\n    M = 44100.;    \n    // last FFT value in texture = iSampleRate/4\n    #define freq(f) abs( (f)/(M/4.)  -U.x) * R.x * scale    \n    \n    \n    vec2 suv = fragCoord/iResolution.xy;    \n    //float bass = texture(iChannel0, vec2(.0001,.75)).x; // music sample, not guaranteed\n    float bass = texture(iChannel0, vec2(.0001,.25)).x; // fft\n    float mid = texture(iChannel0, vec2(.25,.25)).x;\n    float high = texture(iChannel0, vec2(.75,.25)).x;\n    vec4 sound = vec4(bass,mid,high,0);\n    \n    if (suv.y>0.1)\n        bass = 0.;\n    if (suv.y<0.1 || suv.y>0.2)\n        mid = 0.;\n    if (suv.y<0.2 || suv.y>0.3)\n        high = 0.;\n    // sound\n    \n    vec3 ro = vec3(0, 0, -1.5);\n    if(iMouse.z>0.){\n        ro.yz *= Rot(m.y*3.14+1.);\n        ro.y = max(-0.9,ro.y);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        float scene = mod(iTime,15.);\n        float rotY = -10.;\n        float rotX = 0.;\n        if(scene>=5. && scene<10.){\n            rotY = 0.;\n            rotX = -30.;\n        } else if(scene>=10.){\n            rotY = 0.;\n            rotX = 30.;\n        }\n        \n        ro.yz *= Rot(radians(rotY));\n        ro.xz *= Rot(radians(rotX));\n    }\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS, sound);\n    vec3 col = vec3(.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p, sound);\n        float mat = d.y;\n        col = materials(mat,n,rd,p,col, sound);\n    }\n    \n    // gamma correction\n    col = pow( col, vec3(0.7545) );   \n    \n\n    fragColor = vec4(sqrt(col),1.0);\n    //fragColor = vec4(sqrt(col*0.),1.0)+sound/1.+bass + mid + high;\n    //fragColor = vec4(vec3(bass),1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}