{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"/*\nYellow Talking Circle -- Svenofnine / Erfurt 2024\nhttps://www.shadertoy.com/view/MXtyR8\n*/\n\nconst vec3 yellow = vec3( 1.0, 1.0, 0.0 ), white = vec3(1.);\n// const float unit = 1. / 700.;\nconst vec2 center = vec2( 0.5 );\n\n// geometry of the face\nconst float face_radius = 0.45;\nconst float eye_distance = 0.3;\nconst float eye_size = 0.13;\nconst float pupill_size = 0.05;\nvec2 c_mouth = center + vec2( 0.0, -0.2 );    // where is the mouth?\nfloat mouth_radius = 0.1;\n\n\n// different shapes for the mouth: x = width scale, y = height scale, z = x-offset, w = y-offset\nconst vec4[] mouth_shapes = vec4[] ( \n    vec4(1.0, 1.0, 0.0, 0.0),\n    vec4(2.0, 0.5, 0.0, 0.0),\n    vec4(1.6, 1.6, 0.0, 0.0),\n    vec4(1.0, 0.6, 0.0, 0.0),\n    vec4(0.7, 0.8, 0.0, 0.0),\n    vec4(2.0, 0.3, 0.0, 1.0),\n    vec4(0.5, 0.6, 0.0, 0.0),\n    vec4(1.5, 1.0, 0.0, 0.0),\n    vec4(0.7, 0.7, 0.5, 0.0),\n    vec4(0.7, 0.7, -0.5, 0.0)\n);\n\nfloat circle ( vec2 point, vec2 center, float radius, float unit ) {\n    point.x = (point.x - 0.5) * iResolution.x / iResolution.y + 0.5;\n    return 1. - smoothstep( radius-0.7*unit, radius+ 0.7*unit, distance(point,center) );\n}\n\n// returns angle and length of a given point (polar-coordinates)\n// if length > cutoff_length then it will return cutoff_length\nvec2 polar ( in vec2 cartesic, float cutoff_length ) {\n    float len = length(cartesic);\n    return vec2( \n        atan( cartesic.y, cartesic.x), \n        len > cutoff_length ? cutoff_length : len\n    );\n}\n\n// returns a point on the unit circle with given angle.\nvec2 rot_pt ( float angle ) {\n    return vec2( cos(angle), sin(angle) );\n}\n\n// 8< snip Hash function (for randomness) from here: https://www.shadertoy.com/view/4djSRW\n//  1 out, 1 in...\nfloat hash11(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n// 8< end snip\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ar = vec2(iResolution.x / iResolution.y,1.0);   // aspect ratio\n    float unit = 1. / min(iResolution.x, iResolution.y); // the smallest unit at current resolution \n    vec2 uv = fragCoord / iResolution.xy;                // normalize coordinates\n    vec2 mouse = iMouse.xy / iResolution.xy;             // normalized mouse pos\n    mouse = ( mouse-vec2(0.5) ) * ar + vec2(0.5);        // correction of aspect ratio\n  \n    // eyeballs\n    vec2 c_left_eye =  center + vec2(-eye_distance / 2., 0.1);\n    vec2 c_right_eye = c_left_eye + vec2(eye_distance, 0.0);\n\n    // pupills\n\n    vec2 left_pupill_pos = polar( mouse - c_left_eye, eye_size-pupill_size );\n    vec2 right_pupill_pos = polar( mouse - c_right_eye, eye_size-pupill_size );\n\n    // mouth\n\n\n    // mouth movement\n    bool speaks = sin(iTime * 0.3)*sin(iTime * 0.8) > - 0.5;\n    int m = speaks ? \n        //int m = int(floor(iTime*10.)) % mpos.length()   // all mouth positions in order of the array\n        int( floor( hash11( floor(iTime*10.) )*float(mouth_shapes.length()) ) )  // every 1/10th second a random mouth position\n    : 5;  // closed mouth\n\n    if( !speaks ) {\n        left_pupill_pos.y = 0.;\n        right_pupill_pos.y = 0.;\n    }\n\n    // draw face+eyes\n    vec3 col = (vec3(\n            circle( uv, center, face_radius, unit )                         // face\n            - circle( uv, c_left_eye, eye_size + unit, unit )      // left eye black\n            - circle( uv, c_right_eye, eye_size + unit, unit )      // right eye black\n        ) * yellow +\n        vec3(\n            circle( uv, c_left_eye, eye_size, unit )              // left eye white\n            + circle( uv, c_right_eye, eye_size, unit )            // right eye white\n        ) * white)*\n        vec3(    // multiply all black things inverse\n            1.-(circle( \n                (uv-c_mouth) / vec2(mouth_shapes[m].x,mouth_shapes[m].y) + c_mouth,   // relative position\n                c_mouth + vec2(mouth_shapes[m].z,mouth_shapes[m].w)*0.1,              // shape (multiplier for width and height)\n                mouth_radius, unit                                   // basic radius\n            )+\n            circle( uv, c_left_eye + rot_pt(left_pupill_pos.x) * left_pupill_pos.y, pupill_size, unit )+\n            circle( uv, c_right_eye + rot_pt(right_pupill_pos.x) * right_pupill_pos.y, pupill_size, unit ))\n        );\n    \n    // Output to screen\n    fragColor = vec4( col ,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MXtyR8","date":"1734800329","viewed":88,"name":"Yellow Talking Circle","username":"Svenofnine","description":"This started as a test with placing and drawing circles.\nNow it explains itself while looking at the mouse. If it stops talking, it looks at your reaction.\nEnjoy!","likes":6,"published":3,"flags":0,"usePreview":0,"tags":["circles","random","fun","atan"],"hasliked":0,"parentid":"","parentname":""}}