{"ver":"0.1","info":{"id":"ls3yWX","date":"1520795024","viewed":173,"name":"pointillism 3","username":"kariluoma","description":"Render splotches at multiple angles and sampling points, then combine. blur optional if CELL sizes are set finer (1: 65.0, 2: 95.0)","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["pointillism"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// thanks https://www.shadertoy.com/view/XdfGDH\nfloat normpdf(in float x, in float sigma) {\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\nvec4 gaussian_blur(sampler2D tex, vec2 fragCoord, float sigma) {\n    const int mSize = 11;\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    vec3 final_colour = vec3(0.0);\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j) {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j) {\n        Z += kernel[j];\n    }\n    for (int i=-kSize; i <= kSize; ++i) {\n        for (int j=-kSize; j <= kSize; ++j) {\n            final_colour += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel0, (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;\n    }}\n    return vec4(final_colour/(Z*Z), 1.0);\n}\n\n//iChannel0: Buffer A\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = gaussian_blur(iChannel0, fragCoord, 0.01);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// thanks https://gist.github.com/yiwenl/3f804e80d0930e34a0b33359259b556c\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\n// thanks https://www.shadertoy.com/view/XtVGD1\n#define AngleNum 1\n#define PI2 6.28318530717959\n\n//iChannel0: texture (e.g. Claude Van Damme)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float CELL_1 = 65.0;\n    const float CELL_2 = 95.0;\n    \n    vec2 xy = fragCoord.xy  / iResolution.xy; // xy in [0, 1]\n\n    vec2 s1 = floor(xy * CELL_1 ) / CELL_1; // sample bottom_left of CELL_1\n    vec4 clr1 = texture(iChannel0, s1);\n    vec2 s2 = floor(xy * CELL_2) / CELL_2;// sample bottom_left of CELL_2\n    vec4 clr2 = texture(iChannel0, s2);\n    \n    int i = 0;\n    float ang=PI2/float(AngleNum)*(float(i)+0.8); // rotate after sample, but before circle-boundary\n    vec2 t = rotate(xy-0.5, ang) + 0.5;\n    s2 = (floor(t * CELL_2 )) / CELL_2;\n    \n    \n\tvec2 d = (xy - s1) * CELL_1 - 0.5; // transform coordinates to unit circle\n    vec2 e = (t - s2) * CELL_2 - 0.5;\n\n    if (length(e) < 0.45)\n        fragColor = clr2;\n    else //if (length(d) < 0.75)\n   \t\tfragColor = clr1;\n}","name":"Buf A","description":"","type":"buffer"}]}