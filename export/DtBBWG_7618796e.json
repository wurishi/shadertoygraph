{"ver":"0.1","info":{"id":"DtBBWG","date":"1694415628","viewed":90,"name":"bound","username":"vivavolt","description":"Que feio! trocando dois par√¢metros e mostrando como um shader novo... ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["chain","gold","necklace","ouro"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Baguete \" by Elsio. https://shadertoy.com/view/DtjfR3\n// 2023-09-11 07:00:06\n\n#define R iResolution.xy\n#define rot(a) mat2 (cos(a), sin(a), -sin(a), cos(a))\n#define wmod(s, w) mod(s ,w) - w/2.\n\n#define PI 3.1415\n#define T  iTime * .15\n#define torus(p) length(vec2(length(p.xz) - .3, p.y)) - .08\n\n/*    relateds\n        https://www.shadertoy.com/view/ml2fRV \n        https://www.shadertoy.com/view/mlBBzK\n        https://www.shadertoy.com/view/ctSfRV *\n        https://www.shadertoy.com/view/dtSfRc\n        https://www.shadertoy.com/view/DlffD4\n        https://www.shadertoy.com/view/DlXfzj\n    \n*/ \n\n\nvec2 path(float z) {\n    return 1. * vec2(\n        sin(cos(z * .3)), \n        cos(z * .5) \n    );\n}\n\nvec2 path2(float z) {\n    return 1.3 * vec2(\n        sin(z * .3) + sin(z * 13.3) * .015 , \n        cos(z * .5) + cos(z * 17.5) * .015\n    );\n}\n\nvec3 cor; \n\nfloat chain(vec3 p){\n    p.z = 1. * p.z;\n    p.z -= 4. * T;\n\n    vec3 q = p;\n    q.xy *= rot(PI/2.);\n    q.z = fract(p.z + .5) - .5;\n    p.z = fract(p.z) - .5;\n    \n    return min(torus(p), torus(q));\n}\n\n\n\nfloat cabos(vec3 p){\n    p.z += T;\n    p.xy -= path(p.z) - path(T);\n    // \n        float ss = 1.5;\n        float s = 1.;\n\n        mat2 rotate = ss * rot(.5 * p.z);\n\n        float i = 0., d = 100.;\n        while(i++ < 2.){\n            p.xy = abs(p.xy * rotate) - s;\n            s /= ss;\n            \n            float c = chain(p) * s;\n            if (c < d){\n                d = c;\n                cor = vec3(.7) * (.125 * i + .2);\n            }\n        }\n        \n        return d;\n}\n\nfloat map(vec3 p){\n    float c = cabos(p);\n    \n    \n    p.z += T;\n    p.xy -= path2(p.z) - path(T);\n    \n    \n    // baguete\n    //float z = p.z * .1;\n    //p.z = (p.z - T + cos(.1 * T) * 13.7) * .06;\n    //p.y += .4; \n    \n    \n    \n    float d = length(p) - .2;\n    float ret = min(c, d);\n    if (ret == d) cor = vec3(.4,.3,0);\n    \n    \n    return ret;\n}\n\nvec3 normal(vec3 p) {\n\tfloat d = map(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        map(p-e.xyy),\n        map(p-e.yxy),\n        map(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat shadow(vec3 p) {\n    vec3 lightPos = vec3(-4.*sin(iTime), 15\n    , 1);\n    vec3 l = normalize(lightPos - p);\n    return dot(normal(p), l);\n}\n\nvec3 palette( in float t )\n{\n    vec3 col = vec3(0.4,0.4,0.4);\n    col += 0.12*cos(6.28318*t*  1.0+vec3(0.0,0.8,1.1));\n    col += 0.11*cos(6.28318*t*  3.1+vec3(0.3,0.4,0.1));\n    col += 0.10*cos(6.28318*t*  5.1+vec3(0.1,0.7,1.1));\n    col += 0.09*cos(6.28318*t*  9.1+vec3(0.2,0.8,1.4));\n    col += 0.08*cos(6.28318*t* 17.1+vec3(0.2,0.6,0.7));\n    col += 0.07*cos(6.28318*t* 31.1+vec3(0.1,0.6,0.7));\n    col += 0.06*cos(6.28318*t* 65.1+vec3(0.0,0.5,0.8));\n    col += 0.06*cos(6.28318*t*115.1+vec3(0.1,0.4,0.7));\n    col += 0.09*cos(6.28318*t*265.1+vec3(1.1,1.4,2.7));\n    return col;\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 getColor(float amount) {\n  vec3 color = 0.5 + 0.5 * cos(6.2831 * (vec3(0.0, 0.1, 0.2) + amount * vec3(1.0, 1.0, 1.0)));\n  return color * amount;\n}\n\n\nvoid mainImage(out vec4 O, vec2 u){\n    // resolution\n    vec2 uv = (u - .5 * R)/R.y;\n\n    // camera\n    vec3 ro = vec3(0, 0, -1),\n         rd = normalize(vec3(uv, 1));\n         \n\tif (length(iMouse.xy) > 40.) {\n        rd.yz *= rot(-PI * .5 + iMouse.y/R.y * PI);\n        rd.zx *= rot(PI - iMouse.x/R.x * PI * 2.);\n    }\n    \n    // raymarch\n    float s, i, d, far = 60.;\n    while(i++ < 200.) {\n        s = map(ro + d * rd);\n        d += s * .5;\n        if(d > far || s < .001) break;\n    }\n\n    vec3 col;\n    if(d < far){\n        // normal\n        vec2 e = vec2(.01, 0);\n        vec3 p = ro + rd * d,\n             n = normalize(\n                 map(p) - vec3(\n                     map(p-e.xyy), \n                     map(p-e.yxy),\n                     map(p-e.yyx)));\n                     \n        vec3 shad = vec3(shadow(p));\n        \n        vec3 q = vec3(1.);\n        col = pal(shad.y, q, q, q, 0.35 * vec3(0.,0.33,0.66)) / 2.;\n        col += getColor(shad.y * 4.);\n    \n        col = 1.1 * shad * shad * col + 0.1 * col;\n        col = pow(col * .9, vec3(3, 2.5, 2.2) * .2);\n        col = mix(col, shad, .3);\n        col -= pow(d, 2.) / 255.;\n        col = col * .8- .5 * length(uv);\n        \n\n        // colors\n        //col = cor;\n        //col *= -dot(reflect(n, rd), n) *.6 + 1.1;\n        //col = pow(col * .2, vec3(.88)) * 8. - .4;\n    } \n    \n    else{\n        col = vec3(0);\n    }\n\n    O = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}