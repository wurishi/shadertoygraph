{"ver":"0.1","info":{"id":"7ls3R4","date":"1621681442","viewed":261,"name":"Complex Plane","username":"NivBehar","description":"mobius(sin(cos(z)))","likes":5,"published":1,"flags":2,"usePreview":0,"tags":["complex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"# define PI 3.141592654\n# define time iTime\n\n// ** different visualisations - use one at a time **\n# define use_boxes false\n# define use_texture true\n# define use_camera false\n# define use_colors true\n\n# define use_axis false\n# define AXIS_WIDTH 0.02\n// transparent axis range 0..1\n# define TRANSPARENT_AXIS 0.1\n\n\n// complex division\nvec2 c_dev(vec2 a, vec2 b){return vec2(a.x*b.x+a.y*b.y,-a.x*b.y+a.y*b.x)/(b.x*b.x+b.y*b.y);}\n\n// complex multiplication\nvec2 c_mul(vec2 a,vec2 b){return vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);}\n\n// complex sin\nvec2 c_sin(vec2 a){return vec2(sin(a.x)*cosh(a.y),cos(a.x)*sinh(a.y));}\n\n// complex cos\nvec2 c_cos(vec2 a){return vec2(cos(a.x)*cosh(a.y),-sin(a.x)*sinh(a.y));}\n\n// mobius transformation\nvec2 mobius(vec2 z, vec2 a, vec2 b, vec2 c, vec2 d)\n{\n    vec2 z_new;\n    z_new = c_dev(c_mul(a,z) + b, c_mul(c,z) + d);\n    return z_new;\n}\n\nvec2 Log(vec2 p) // not sure about this\n{\n    vec2 q;\n    q.x = log(sqrt(p.x*p.x + p.y*p.y)); // natural log\n    q.y = atan(p.y,p.x);\n    return q;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv*=8.;\n    \n    vec3 col;\n\n    vec2 uv_old = uv; // temp for real plain\n    \n    // **apply changes to the uv plain here**\n    uv = c_cos(uv);\n    uv = c_sin(uv);\n    uv = mobius(uv,vec2(1.,0.),vec2(-1.,0.),vec2(1.,0.),vec2(1.,0.));\n    //uv = Log(uv);\n    \n    float timing = 0.475 + 0.525*sin(0.3*time);\n    uv = mix(uv_old, uv, timing <= 0.? 0.:timing); // linear interpolation between the real plain and the complex plain\n\n    // use texture instead of a plain\n    if(use_texture)\n    {\n        uv.x *= 0.1;\n        uv.x -= time*0.3;\n        col = texture(iChannel0, uv).xyz;\n    }\n    else if(use_camera)\n    {\n        uv *= .5;\n        col = texture(iChannel1, uv).xyz;\n    }\n    else if(use_colors)\n    {\n        //uv *= 3.;\n        col.x = sin(uv.x*2.);\n        col.y = cos(uv.y*2.);\n        col.z = sin(uv.x*7.)*cos(uv.y*7.);\n    }\n    else if(use_boxes)\n    {\n        //if(uv.y > 0.) // uncomment to use borders\n        //if(uv.x > 0.4 && uv.x < 1.)\n        {\n            // add lines\n            col = vec3(1,1,1);\n            col *= vec3(1,0,0) * smoothstep(0.,0.1,(0.5 + 0.5*sin(uv.y*10.))); // horizontal\n            col *= vec3(1,0,0) * smoothstep(0.,0.1,(0.5 + 0.5*sin(uv.x*10.))); // vertical\n        }\n    }\n    \n\n    // add white axis lines\n    if(use_axis)\n    {\n        float width = AXIS_WIDTH;\n        if(uv_old.y > -width && uv_old.y < width || uv_old.x > -width && uv_old.x < width )\n        {\n            col = mix(col, vec3(1), 1.-TRANSPARENT_AXIS);\n        }\n    }\n    \n    \n    fragColor = vec4(col,0.1);\n}","name":"Image","description":"","type":"image"}]}