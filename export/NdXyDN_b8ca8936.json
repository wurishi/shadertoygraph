{"ver":"0.1","info":{"id":"NdXyDN","date":"1642073100","viewed":161,"name":"3D Voronoi on sphere surface","username":"arkanis","description":"Constraints all random points to the surface of the sphere and only considers 3D grid cells that are close to the surface (right side).\nBased on https://www.shadertoy.com/view/ldl3Dl (left side) and similar to https://www.shadertoy.com but much simpler.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","voronoi","sphere","point"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright Â© 2022 Stephan Soller\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// \n// Directly based on  Voronoi - 3D by Inigo Quilez: https://www.shadertoy.com/view/ldl3Dl\n// Modified the 3D Voronoi noise function to constraint points to the surface\n// of the sphere (see voronoi_sphere()).\n\n\n//===============================================================================================\n//===============================================================================================\n\nvec3 hash( vec3 x )\n{\n\tx = vec3( dot(x,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(x,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(x,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(x)*43758.5453123);\n}\n\n// Modified the 3D Voronoi noise function to only sample grid cells that are close to the sphere\n// surface. The random points in those cells also get projected directly onto the sphere surface\n// instead of beeing free 3D points.\n// \n// x is a 3D position on the surface of the sphere where the origin (0,0,0) is the center of the\n// sphere.\n// Returns closest, second closest, and cell id.\nvec3 voronoi_sphere( in vec3 x )\n{\n    vec3 p = floor( x );  // position of the cell this fragment is in\n    vec3 f = fract( x );  // inter-cell offset of this fragment\n    \n    // Could be turned into an extra function parameter if you already know it from the scene\n    // setup and want to speed things up.\n    float sphere_radius = length(x);\n    \n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );  // offset of the scanned cell, relative to cell of fragment\n        vec3 r = vec3( b ) - f + hash( p + b );         // r is the random point within the scanned cell, relative to the fragments position\n        \n        // The center of the scanned cell in object space (_in_os suffix) where (0,0,0) is at the center of the sphere\n        vec3 cell_center_in_os = p + b + vec3(0.5);\n        float dist_between_cell_center_and_sphere_surface = abs(length(cell_center_in_os) - sphere_radius);\n        \n        // Cell centers have to be closer than this to be considered. Each cell is a 1x1x1 cube\n        // in 3D space and with 0.5 we should get almost all cells that intersect the sphere surface.\n        // Without this check the points of all scanned cells get mapped to the sphere surface and\n        // this will lead to sudden jumps between cells (since they scan different cells).\n        float max_cell_dist = 0.5;\n        if (dist_between_cell_center_and_sphere_surface < max_cell_dist)\n        {\n\t\t\t// Move the random point in the currently scanned cell directly on the sphere surface\n\t\t\tvec3 r_in_os = x + r;\n\t\t\tr_in_os = normalize(r_in_os) * sphere_radius;\n\t\t\tr = r_in_os - x;\n            \n            float d = dot( r, r );\n            if( d < res.x )\n            {\n                id = dot( p+b, vec3(1.0,57.0,113.0 ) );\n                res = vec2( d, res.x );\t\t\t\n            }\n            else if( d < res.y )\n            {\n                res.y = d;\n            }\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\n// Original voronoi() function by Inigo Quilez. Provided for comparison.\n// returns closest, second closest, and cell id\nvec3 voronoi_original( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + hash( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n//===============================================================================================\n\n// Almost completely unmodified code from https://www.shadertoy.com/view/ldl3Dl\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 1.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // sphere center\t\n\tvec3 sc = vec3(0.0,1.0,0.0);\n\n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tfloat occ = 1.0;\n\tvec3  pos = vec3(0.0);\n\t\n\t// raytrace-plane (removed, doesn't make sense because we constrainted the noise function to the sphere)\n\n\t// raytrace-sphere\n\tvec3  ce = ro - sc;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - 1.0;\n\tfloat h = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\th = -b - sqrt(h);\n\t\tif( h<tmin ) \n\t\t{ \n\t\t\ttmin=h; \n\t\t\tnor = normalize(ro+h*rd-sc); \n\t\t\tocc = 0.5 + 0.5*nor.y;\n\t\t}\n\t}\n\n    // shading/lighting\t\n\tvec3 col = vec3(0.9);\n\tif( tmin<100.0 )\n\t{\n\t    pos = ro + tmin*rd;\n\t\t\n        // voronoi_sphere() expects coordinates where (0,0,0) is the center of the sphere.\n        // So we use (pos - sc) instead of just pos as in the original version.\n        float f;\n        if (fragCoord.x< iResolution.x* 0.5)\n        {\n            f = voronoi_original( 4.0*(pos - sc) ).x;\n        }\n        else\n        {\n            f = voronoi_sphere( 4.0*(pos - sc) ).x;\n        }\n\t\t\n\t\tf *= occ;\n\t\tcol = vec3(f*1.2);\n\t\tcol = mix( col, vec3(0.9), 1.0-exp( -0.003*tmin*tmin ) );\n\t}\n\t\n\tcol = sqrt( col );\n\t\n\t\n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}