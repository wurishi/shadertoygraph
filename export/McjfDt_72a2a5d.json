{"ver":"0.1","info":{"id":"McjfDt","date":"1725667199","viewed":17,"name":"pleaseletmeusethisname","username":"gprudhomme","description":"box, it move. it round. animated texture, animated background","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["shape"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat3 rotation3dX(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n\n  return mat3(\n    1.0, 0.0, 0.0,\n    0.0, c, s,\n    0.0, -s, c\n  );\n}\n\nmat3 rotation3dY(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n\n  return mat3(\n    c, 0.0, -s,\n    0.0, 1.0, 0.0,\n    s, 0.0, c\n  );\n}\n\nmat3 rotation3dZ(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n\n  return mat3(\n    c,    s, 0.0,\n    -s,     c, 0.0,\n    0.0, 0.0, 1.0\n  );\n}\n\n//https://iquilezles.org/articles/distfunctions/\nfloat sdRoundBox(vec3 p, vec3 b, float r)\n{\n    vec3 q = abs(p) - b + r;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;\n}\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized y pixel coordinates (from 0 to 1)    \n    // apply same scale to x pixels\n    vec2 uv = fragCoord/iResolution.yy;\n    \n    vec2 uv2 = fragCoord/iResolution.yy;\n    \n    vec2 Mouseuv = iMouse.xy/iResolution.yy;\n    \n    //subtracting 0.5 moves origin to middle of window\n    //however x is at a different scale, so we need to scale\n    //based on aspect ratio\n    uv.x = uv.x - 0.5*(iResolution.x/iResolution.y);\n    uv.y = uv.y - 0.5;\n\n    uv2.x = uv2.x - 0.5*(iResolution.x/iResolution.y);\n    uv2.y = uv2.y - 0.5;\n    \n    Mouseuv.x = Mouseuv.x - 0.5*(iResolution.x/iResolution.y);\n    Mouseuv.y = Mouseuv.y - 0.5;\n\n    //set background color\n    vec3 col = vec3(0.0);\n    col = texture(iChannel0, texture(iChannel1, uv + iTime/3.0).xy).rgb;\n    \n    //distance along ray\n    float t = 0.0;\n    float tdx = 0.0;\n    float tdy = 0.0;\n    \n    //distance along ray\n    float t2 = 0.0;\n    float tdx2 = 0.0;\n    float tdy2 = 0.0;\n    \n    //small distance to offset point\n    float d = 0.001f;\n    \n    mat3 rotY = rotation3dY(iTime);\n    \n    //mat3 rotX = rotation3dX(iTime);\n    \n    //position and size of the roundbox\n    vec3 rboxPos = vec3(0.0,0.0,40.0);\n    vec3 rboxPos2 = vec3(0.0,0.0,.75);\n    vec3 rboxDim = vec3(0.1,0.2,0.3);\n    float rboxBev = .05;\n    \n    //position and size of the BoxFrame\n    vec3 boxFPos = vec3(0.0,0.2,1.0);\n    vec3 boxFPos2 = vec3(0.0,0.0,.75);\n    vec3 boxFDim = vec3(0.05,0.2,0.3);\n    float boxFE = .05;\n    \n    \n    vec3 lightPos = vec3(Mouseuv, 5.0);\n    \n    \n    //starting point of ray and the direction it follows\n    vec3 pt = vec3(uv.x, uv.y, 0.0);\n    vec3 ptdx = vec3(uv.x+d, uv.y, 0.0);\n    vec3 ptdy = vec3(uv.x, uv.y+d, 0.0);\n    vec3 dir = normalize(vec3(0.0, 0.0, 1.0));\n    \n    //starting point of ray and the direction it follows\n    vec3 pt2 = vec3(uv2.x, uv2.y, 0.0);\n    vec3 ptdx2 = vec3(uv2.x+d, uv2.y, 0.0);\n    vec3 ptdy2 = vec3(uv2.x, uv2.y+d, 0.0);\n    vec3 dir2 = normalize(vec3(0.0, 0.0, 1.0));\n     \n    // loop that allows us to keep moving along the ray \n    // until we hit the sphere or until we run out of \n    // loop iterations (and hit nothing)\n    for( int i = 0; i < 25; i++){\n    \n        //calc positions from view rays\n        vec3 pos = pt + dir * t;\n        vec3 posdx = ptdx + dir * tdx;\n        vec3 posdy = ptdy + dir * tdy;\n        \n        //calc positions from view rays\n        vec3 pos2 = pt2 + dir2 * t2;\n        vec3 posdx2 = ptdx2 + dir2 * tdx2;\n        vec3 posdy2 = ptdy2 + dir2 * tdy2;\n            \n        \n        // get distance from position to sphere\n        // subtract spherePos from pos allows us to \"move\"\n        // the position of the sphere in the world\n        // otherwise it is stuck at the world origi\n        float dist = sdRoundBox(pos - rboxPos - rotY*(rboxPos2), rboxDim, rboxBev);\n        float distdx = sdRoundBox(posdx -rboxPos- rotY*(rboxPos2), rboxDim, rboxBev);\n        float distdy = sdRoundBox(posdy -rboxPos- rotY*(rboxPos2), rboxDim, rboxBev);\n        \n        // the box frame\n        float fdist = sdBoxFrame(pos2 - boxFPos - rotY*(boxFPos2), boxFDim, boxFE);\n        float fdistdx = sdBoxFrame(posdx2 -boxFPos- rotY*(boxFPos2), boxFDim, boxFE);\n        float fdistdy = sdBoxFrame(posdy2 -boxFPos- rotY*(boxFPos2), boxFDim, boxFE);\n              \n        float eps = 0.0001;\n              \n        if(dist < eps && \n           distdx < eps && \n           distdy < eps){ //point on ray is close enough\n                          //we'll call this a \"hit\"\n                        \n            vec3 normal = normalize(vec3(\n    sdRoundBox(pos + vec3(d, 0.0, 0.0) - rboxPos - rotY * rboxPos2, rboxDim, rboxBev) - dist,\n    sdRoundBox(pos + vec3(0.0, d, 0.0) - rboxPos - rotY * rboxPos2, rboxDim, rboxBev) - dist,\n    sdRoundBox(pos + vec3(0.0, 0.0, d) - rboxPos - rotY * rboxPos2, rboxDim, rboxBev) - dist));\n                     \n            // normal = normalize(pos - rboxPos- rotY*(rboxPos2));\n            \n            vec3 lightDir = normalize(lightPos - pos);\n            float diffuse = max(dot(normal, lightDir), 0.0);\n            col = vec3(1.0) * diffuse;\n                     \n                   \n            col = vec3(1.0)*dot(normal, normalize(lightPos - pos));        \n            //col = normal;      \n            \n            //col -= texture(iChannel0, uv).rgb*0.5;\n            //col = texture (iChannel0, uv).rgb;\n            col = texture(iChannel1, texture(iChannel1, uv + iTime/100.0).xy).rgb;\n            //col = vec3(1.0);  //lets color this fragment\n                                // a \"sphere color\"\n                             \n            break;  //stop checking\n            \n        }else if (fdist < eps && fdistdx < eps && fdistdy < eps)\n        {\n                            //point on ray is close enough\n                            //we'll call this a \"hit\"\n            vec3 normal = normalize(vec3(\n                sdBoxFrame(pos2 + vec3(d, 0.0, 0.0) - boxFPos - rotY * boxFPos2, boxFDim, boxFE) - fdist,\n                sdBoxFrame(pos2 + vec3(0.0, d, 0.0) - boxFPos - rotY * boxFPos2, boxFDim, boxFE) - fdist,\n                sdBoxFrame(pos2 + vec3(0.0, 0.0, d) - boxFPos - rotY * boxFPos2, boxFDim, boxFE) - fdist));\n                     \n            // normal = normalize(pos - rboxPos- rotY*(rboxPos2));\n            \n            vec3 lightDir2 = normalize(lightPos - pos2);\n            float diffuse2 = max(dot(normal, lightDir2), 0.0);\n            col = vec3(1.0) * diffuse2;\n                     \n                   \n            col = vec3(1.0)*dot(normal, normalize(lightPos - pos2));        \n            //col = normal;      \n            \n            //col -= texture(iChannel0, uv).rgb*0.5;\n            //col = texture (iChannel0, uv).rgb;\n            col = texture(iChannel1, texture(iChannel1, uv + iTime/100.0).xy).rgb;\n            //col = vec3(1.0);  //lets color this fragment\n                                // a \"sphere color\"\n                             \n            break;  //stop checking\n        }\n        //update distance along ray if haven't hit yet\n        t += dist;\n        tdx += distdx;\n        tdy += distdy;\n        \n        t2 += fdist;\n        tdx2 += fdistdx;\n        tdy2 += fdistdy;\n    }\n\n    // Outputo screen\n    fragColor = vec4(col,1.0);\n    //col = texture(iChannel0, texture(iChannel1, uv + iTime/3.0).xy).rgb;\n}","name":"Image","description":"","type":"image"}]}