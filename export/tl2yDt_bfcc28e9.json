{"ver":"0.1","info":{"id":"tl2yDt","date":"1595756849","viewed":67,"name":"SardfUnion","username":"fayolle","description":"Sardf union function (smoothed Boolean union)\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf","boolean"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// sardf unions\n//\n\n\n//-----------------------------\n//https://www.shadertoy.com/view/XsGyDh\n//\nint solve_quadric(vec2 coeffs, inout vec2 roots){\n  float p = coeffs.y / 2.;\n  float D = p*p - coeffs.x;\n  if (D <= 0.) return 0;\n  else {\n    roots = vec2(-1, 1)*sqrt(D) - p;\n    return 2;\n  }\n}\n\nint solve_cubic(vec3 coeffs, inout vec3 r){\n  float a = coeffs[2];\n  float b = coeffs[1];\n  float c = coeffs[0];\n  float p = b - a*a/3.;\n  float q = a * (2.*a*a - 9.*b)/27. + c;\n  float p3 = p*p*p;\n  float d = q*q + 4.*p3/27.;\n  float offset = -a/3.;\n  if(d >= 0.0) { \n    vec2 uv = (vec2(1, -1)*sqrt(d) - q)/2.;\n    uv = uv = sign(uv)*pow(abs(uv), vec2(1./3.));\n    r[0] = offset + uv.x + uv.y;        \n    float f = ((r[0] + a)*r[0] + b)*r[0] + c;\n    float f1 = (3.*r[0] + 2. * a)*r[0] + b;\n    r[0] -= f/f1;\n    return 1;\n  }\n  float u = sqrt(-p/3.);\n  float v = acos(-sqrt(-27./p3)*q/2.)/3.;\n  float m = cos(v), n = sin(v)*1.732050808;\n  float f,f1;\n  r[0] = offset + u * (m + m);\n  f = ((r[0] + a)*r[0] + b)*r[0] + c;\n  f1 = (3.*r[0] + 2. * a)*r[0] + b;\n  r[0] -= f / f1;\n  r[1] = offset - u * (n + m);\n  f = ((r[1] + a)*r[1] + b) * r[1] + c;\n  f1=(3.*r[1] + 2. * a)*r[1] + b;\n  r[1] -= f / f1;\n  r[2] = offset + u * (n - m);\n  f = ((r[2] + a)*r[2] + b)*r[2] + c;\n  f1 = (3.*r[2] + 2. * a)*r[2] + b;\n  r[2] -= f / f1;\n  return 3;\n}\n\nbvec4 solve_quartic(vec4 coeffs, inout vec4 s){\n  bvec4 broots;\n  float a = coeffs[0];\n  float b = coeffs[1];\n  float c = coeffs[2];\n  float d = coeffs[3];\n  float sq_a = a * a;\n  float p = - 3./8. * sq_a + b;\n  float q = 1./8. * sq_a * a - 1./2. * a * b + c;\n  float r = - 3./256.*sq_a*sq_a + 1./16.*sq_a*b - 1./4.*a*c + d;\n  int num;\n  vec3 cubic_coeffs;\n  cubic_coeffs[0] = 1.0/2. * r * p - 1.0/8. * q * q;\n  cubic_coeffs[1] = - r;\n  cubic_coeffs[2] = - 1.0/2. * p;\n  solve_cubic(cubic_coeffs, s.xyz);\n  float z = s[0];\n  float u = z * z - r;\n  float v = 2. * z - p;\n  if(u > 0.) u = sqrt(abs(u));\n  else return bvec4(false);\n  if(v > 0.) v = sqrt(abs(v));\n  else return bvec4(false);\n  vec2 quad_coeffs;\n  quad_coeffs[0] = z - u;\n  quad_coeffs[1] = q < 0. ? -v : v;\n  num = solve_quadric(quad_coeffs, s.xy);\n  if (num == 0) broots.xy = bvec2(false);\n  if (num == 2) broots.xy = bvec2(true);\n  quad_coeffs[0] = z + u;\n  quad_coeffs[1] = q < 0. ? v : -v;\n  vec2 tmp = vec2(1e8);\n  int old_num = num;\n  num = solve_quadric(quad_coeffs, s.zw);\n  if (num == 0) broots.zw = bvec2(false);\n  if (num == 2) broots.zw = bvec2(true);\n  s -= a/4.;\n  return broots;\n}\n//-----------------------------\n\n\n//-----------------------------\n// union1: uses unbounded approach in quadrant 1\n// and bounded approach in quadrant 3\n// arguments:\n// xt, IN, value of first function at current point\n// yt, IN, value of second function at current point\n// R, IN, maximum radius of the bounded approach (quadrant 3)\n// alpha, IN, angle for the unbounded approach (quadrant 1)\nfloat\nuni_sardf_1(const float xt, const float yt, const float R,\n            const float alpha){        \n  float d=0.0;\n  float lim2;\n  float g,g2,gt;\n  float aa,b,c,Ds;\n  float d1,t;\n\n  if (abs(xt)<1.0e-7 && abs(yt)<1.0e-7) return 0.0;\n\n  // case when xt=0 and yt!=0\n  // or when xt!=0 and yt=0\n  if (abs(xt)<1.0e-7 && yt>0.0) {d=yt; return d;}\n  if (abs(xt)<1.0e-7 && yt<0.0) {d=0.0; return d;}\n  if (abs(yt)<1.0e-7 && xt>0.0) {d=xt; return d;}\n  if (abs(yt)<1.0e-7 && xt<0.0) {d=0.0; return d;}\n        \n        \n  // theta analysis for (x,y) point, gt=ctg(theta)\n  if((abs(yt)>1.0e-7 ) && (abs(xt)>1.0e-7 )) {  \n                \n    // II quarter\n    if(yt > 0.0 && xt<0.0) {d=yt; return d;} \n                \n    // IV quarter\n    if(xt > 0.0 && yt < 0.0) {d=xt; return d;} \n                \n    // I quarter\n    if((xt > 0.0) && (yt > 0.0)) {\n      g = 1.0 / (tan(alpha));\n      g2 = tan(alpha);\n      gt = xt/yt;\n                        \n      if ((gt < g) && (gt>g2)){\n        t=tan(alpha);\n        aa = t*t + 2.0 * t - 1.0;\n        b = -2.0 * t * (xt+yt);\n        c = xt*xt + yt*yt;\n        d1 = -b - sqrt(b*b - 4.0*aa*c); // +->-\n        d1 = d1 / (2.0*aa);\n        return d1;\n      }\n      else if (gt>=g) {\n        return xt;\n      }\n      else if (gt<=g2) {\n        return yt;\n      }\n                        \n    }\n    // end for I quarter\n                \n                \n    // definition of lim2\n    lim2 = ((xt + 2.0*R)*(xt+2.0*R)) + ((yt + 2.0*R)*(yt+2.0*R));\n                \n    // III quarter\n    if((xt < 0.0 ) && (yt < 0.0)) {\n                        \n      // angle approach: inside the boundary\n      if ( (xt >= -R) || (yt >= -R) || \n           ((xt >= -2.0*R) && (yt >= -2.0*R) && (lim2 >= R*R))) {\n\n        float xx = xt*xt;\n        float yy=yt*yt;\n        xx = -xx/(4.0*R);\n        yy = -yy/(4.0*R);\n\n        if((xt <= yy) && (yt<=xx)){\n\n          float c0 = -(xt*xt + yt*yt);\n          float c1 = -4.0 * sqrt(R) * (xt+yt);\n          float c2 = -4.0 * R;\n          float c3 = -4.0*sqrt(R);\n          float c4 = 1.0;\n\n          vec4 sol;\n          float m;\n          vec4 coeffs = vec4(c3,c2,c1,c0);\n          solve_quartic(coeffs, sol);\n          //m = sol.value[1];\n          m = sol.x;\n          m = -m*m;\n          return m;\n          \n        }// else means outside given angle\n        else{\n          if(yt>xx)  {d = yt; return d;} \n          if(yy<xt) {d = xt; return d;} \n          // end for inside given angle check\n        }//end of if inside angle\n                                \n      }\n      else\n        {\n          // inside the given stripe    \n          if((yt <= xt+R) && (yt >= xt-R)) { \n                                        \n            // coefficients of quadratic equation for distance d\n            aa = 2.0;\n            b = -2.0*xt - 4.0*R -2.0*yt;\n            c= xt*xt + yt*yt + R*R +2.0*xt*R +2.0*yt*R;\n                                        \n            //- solution of quadratic equation\n            Ds=b*b-4.0*aa*c;\n            if(Ds>=0.0) {\n              d=(-b-sqrt(Ds))/(2.0*aa);\n              return d;\n            }\n          }\n          // else means outside given stripe\n          else{\n            if(yt < xt-R) {d = xt;return d;} \n            if(yt > xt+R) {d = yt;return d;} \n            // end for inside given angle check\n          }\n                                \n        }// end of if angle approach or strip approach;\n                        \n      // end for III quarter\n    }\n                \n    // for y/=0 and x/=0\n  } \n  \n  return d; \n}\n\n// union2: uses bounded approach in quadrant 1\n// and bounded approach in quadrant 3\n// arguments:\n// xt, IN, first function value at current point,\n// yt, IN, second function value at current point, \n// R1, IN, maximum radius of the bounded approach (quadrant 1)\n// R2, IN, maximum radius of the bounded approach (quadrant 3)\nfloat\nuni_sardf_2(float xt, float yt, float R1,\n            float R2){  \n  float d=0.0;\n  float lim, lim2;\n  float aa,b,c,Ds;\n\n  if (abs(xt)<1.0e-7 && abs(yt)<1.0e-7) return 0.0;\n\n  // case when xt=0 and yt!=0\n  // or when xt!=0 and yt=0\n  if (abs(xt)<1.0e-7 && yt>0.0) {d=yt; return d;}\n  if (abs(xt)<1.0e-7 && yt<0.0) {d=0.0; return d;}\n  if (abs(yt)<1.0e-7 && xt>0.0) {d=xt; return d;}\n  if (abs(yt)<1.0e-7 && xt<0.0) {d=0.0; return d;}\n        \n        \n  // theta analysis for (x,y) point, gt=ctg(theta)\n  if((abs(yt)>1.0e-7 ) && (abs(xt)>1.0e-7 )) {  \n                \n    // II quarter\n    if(yt > 0.0 && xt<0.0) {d=yt; return d;} \n                \n    // IV quarter\n    if(xt > 0.0 && yt < 0.0) {d=xt; return d;} \n                \n    // I quarter\n    if((xt > 0.0) && (yt > 0.0)) {\n      lim=((xt-R1)*(xt-R1)) + ((yt-R1)*(yt-R1));\n      // angle approach: outside the boundary\n      if ( (xt <= R1) || (yt<=R1) || \n           ((xt<=2.0*R1) && (yt<=2.0*R1) && ( lim <= R1*R1 ) ) )  {\n                                \n        float xx = xt*xt;\n        float yy = yt*yt;\n        xx = xx/(4.0*R1);\n        yy =yy/(4.0*R1);\n                                \n        if((xx <= yt) && (yy <= xt)) { \n                                        \n          float c0 = xt*xt + yt*yt;\n          float c1 = 0.0;\n          float c2 = (-1.0/(2.0*R1))*(xt+yt+2.0*R1);\n          float c3 = (1.0/(2.0*R1));\n          float c4 = 1.0/(16.0*R1*R1);\n                                        \n          vec4 sol;\n          float m;\n          vec4 coeffs = vec4(c3/c4,c2/c4,c1/c4,c0/c4); \n          solve_quartic(coeffs,sol);\n          //m = sol.value[3];\n          m = sol.z;\n          return m;\n        }\n        // else means outside given angle\n        else{\n          if(xx>yt) {d = xt; return d;} \n          if(yy>xt) {d = yt; return d;} \n          // end for inside given angle check\n        }\n      }\n      else\n        {\n          // inside the given stripe    \n          if((yt <= xt+R1) && (yt >= xt-R1)) { \n                                        \n            // coefficients of quadratic equation for distance d\n            aa = 2.0;\n            b = -2.0*xt - 4.0*R1 -2.0*yt;\n            c= xt*xt + yt*yt + R1*R1 +2.0*xt*R1 +2.0*yt*R1;\n                                        \n            //- solution of quadratic equation\n            Ds=b*b-4.0*aa*c;\n            if(Ds>=0.0) {\n              d=(-b-sqrt(Ds))/(2.0*aa);\n              return d;\n            }\n          }\n          // else means outside given stripe\n          else{\n            if(yt < xt-R1) {d = xt; return d;} \n            if(yt > xt+R1) {d = yt; return d;} \n            // end for inside given angle check\n          }\n        }\n    }\n    // end for I quarter\n                \n    // definition of lim2\n    lim2 = ((xt + 2.0*R2)*(xt+2.0*R2)) + ((yt + 2.0*R2)*(yt+2.0*R2));\n                \n    // III quarter\n    if((xt < 0.0 ) && (yt < 0.0)) {\n      // angle approach: inside the boundary\n      if ( (xt >= -R2) || (yt >= -R2) || \n           ((xt >= -2.0*R2) && (yt >= -2.0*R2) && (lim2 >= R2*R2))) {\n\n        float xx = xt*xt;\n        float yy = yt*yt;\n        xx = -xx/(4.0*R2);      \n        yy = -yy/(4.0*R2);\n\n        if((xt <= yy) && (yt<=xx)){\n\n          float c0 = -(xt*xt + yt*yt);\n          float c1 = -4.0 * sqrt(R2) * (xt+yt);\n          float c2 = -4.0 * R2;\n          float c3 = -4.0*sqrt(R2);\n          float c4 = 1.0;\n\n          vec4 sol;\n          float m;\n          vec4 coeffs = vec4(c3,c2,c1,c0);\n          solve_quartic(coeffs, sol);\n          //m = sol.value[1];\n          m = sol.x;\n          m = -m*m;\n          return m;\n\n        }// else means outside given angle\n        else{\n          if(yt>xx)  {d = yt; return d;} \n          if(yy<xt) {d = xt; return d;} \n          // end for inside given angle check\n        }//end of if inside angle\n                                \n      }\n      else\n        {\n          // inside the given stripe    \n          if((yt <= xt+R2) && (yt >= xt-R2)) { \n                                        \n            // coefficients of quadratic equation for distance d\n            aa = 2.0;\n            b = -2.0*xt - 4.0*R2 -2.0*yt;\n            c= xt*xt + yt*yt + R2*R2 +2.0*xt*R2 +2.0*yt*R2;\n                                        \n            //- solution of quadratic equation\n            Ds=b*b-4.0*aa*c;\n            if(Ds>=0.0) {\n              d=(-b-sqrt(Ds))/(2.0*aa);\n              return d;\n            }\n          }\n          // else means outside given stripe\n          else{\n            if(yt < xt-R2) {d = xt;return d;} \n            if(yt > xt+R2) {d = yt;return d;} \n            // end for inside given angle check\n          }\n                                \n        }// end of if angle approach or strip approach;\n                        \n      // end for III quarter\n    }\n                \n    // for y/=0 and x/=0\n  } \n  \n  return d; \n}\n//-----------------------------\n\n\n//-----------------------------\n// MATLAB jet colormap\n// https://www.shadertoy.com/view/3tlGD4\n\n#define rescale(u, v, x) (x - u)/(v - u)\n\nvec3 jetLinear(float t)\n{\n  vec3 color0 = vec3(0.0, 0.0, 0.5625);\n  float u1 = 1.0/9.0;\n  vec3 color1 = vec3(0.0, 0.0, 1.0);\n  float u2 = 23.0/63.0;\n  vec3 color2 = vec3(0.0, 1.0, 1.0);\n  float u3 = 13.0/21.0;\n  vec3 color3 = vec3(1.0, 1.0, 0.0);\n  float u4 = 47.0/63.0;\n  vec3 color4 = vec3(1.0, 0.5, 0.0);\n  float u5 = 55.0/63.0;\n  vec3 color5 = vec3(1.0, 0.0, 0.0);\n  vec3 color6 = vec3(0.5, 0.0, 0.0);\n  \n  return\n    + mix(color0, color1, rescale(0.0, u1, t))\n    + (mix(color1, color2, rescale(u1, u2, t)) - mix(color0, color1, rescale(0.0, u1, t))) * step(u1, t)\n    + (mix(color2, color3, rescale(u2, u3, t)) - mix(color1, color2, rescale(u1, u2, t))) * step(u2, t)\n    + (mix(color3, color4, rescale(u3, u4, t)) - mix(color2, color3, rescale(u2, u3, t))) * step(u3, t)\n    + (mix(color4, color5, rescale(u4, u5, t)) - mix(color3, color4, rescale(u3, u4, t))) * step(u4, t)\n    + (mix(color5, color6, rescale(u5, 1.0, t)) - mix(color4, color5, rescale(u4, u5, t))) * step(u5, t)\n    ;\n}\n//-----------------------------\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n  // sdf\n  float d;\n  p *= 5.0;\n  d = uni_sardf_1(p.x, p.y, 0.1, 0.3); \n\n  // colorize\n  vec3 col = jetLinear(abs(d)/10.0);\n  col *= 0.8 + 0.2 * cos(40.0 * d);\n  col = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.05, abs(d)));\n\n  fragColor = vec4(sqrt(col), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}