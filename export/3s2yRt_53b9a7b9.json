{"ver":"0.1","info":{"id":"3s2yRt","date":"1588872610","viewed":74,"name":"Hw9 - Noise & UV Map","username":"vmoniqb","description":"hw9","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raycasting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FOVY = 3.14159 * 0.25;\nconst int RAY_STEPS = 256;\nconst float AO_DIST = 0.085;\nconst float AO_KVAL = 2.0;\n// The larger the DISTORTION, the smaller the glow\nconst float DISTORTION = 0.2;\n// The higher GLOW is, the smaller the glow of the subsurface scattering\nconst float GLOW = 5.0;\n// The higher the BSSRDF_SCALE, the brighter the scattered light\nconst float BSSRDF_SCALE = 2.0;\n// Boost the shadowed areas in the subsurface glow with this\nconst float AMBIENT = 2.0;\n\n    \nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\t// Assign every object in scene a unique ID int\n};\n\n    \n\n// Cosine palette VENUS\nconst vec3 av = vec3(0.5, 0.5, 0.5);\nconst vec3 bv = vec3(0.5, 0.5, 0.5);\nconst vec3 cv = vec3(2.0, 1.0, 0.0);\nconst vec3 dv = vec3(0.5, 0.2, 0.25);\n\n// Cosine palette EARTH\nconst vec3 ae = vec3(0.0, 0.58, 0.45 );\nconst vec3 be = vec3(0.5, 0.65, 0.31);\nconst vec3 ce = vec3(0.4, 0.8, 0.7);\nconst vec3 de = vec3(0.4, 0.15, 0.0);\n\t\n// Cosine palette MARS\nconst vec3 am = vec3(1.0, 0.0, 0.0);\nconst vec3 bm = vec3(0.4, 0.8, 0.0);\nconst vec3 cm = vec3(0.5, 0.34, 0.89);\nconst vec3 dm = vec3(0.5, 0.63, 0.9);\n\n// Cosine palette SATURN\nconst vec3 as = vec3(0.5, 0.5, 0.5);\nconst vec3 bs = vec3(0.5, 0.5, 0.5);\nconst vec3 cs = vec3(1.0, 1.0, 1.0);\nconst vec3 ds = vec3(0.0, 0.10, 0.20);\n\n// Cosine palette Background\nconst vec3 ab = vec3(0.8, 0.5, 0.4);\nconst vec3 bb = vec3(0.2, 0.4, 0.2);\nconst vec3 cb = vec3(2.0, 1.0, 1.0);\nconst vec3 db = vec3(0.0, 0.25, 0.25);\n\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b * cos(6.28318 * (c * t + d) );\n}\n\n\n\n// RANDOM NOISE FUNCTIONS\nfloat random1(vec3 p) {\n  return fract(sin(dot(p, vec3(127.1, 311.7, 191.999))) * 43758.5453);\n}\n\nvec2 random2(vec2 p) {\n  return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\nfloat smootherStep(float a, float b, float t) {\n  t = t*t*t*(t*(t*6.0 - 15.0) + 10.0);\n  return mix(a, b, t);\n}\n\nvec3 random3(vec3 p) {\n    return fract(sin(vec3(dot(p,vec3(127.1, 311.7, 191.999)),\n                          dot(p,vec3(269.5, 183.3, 765.54)),\n                          dot(p,vec3(420.6, 631.2, 109.23))\n                    )) * 43758.5453);\n}\n\n\n\n// PERLIN NOISE FUNCTION\nfloat perlin(vec3 p) {\n  vec3 pFract = fract(p);\n  float llb = random1(floor(p));\n  float lrb = random1(floor(p) + vec3(1.0,0.0,0.0));\n  float ulb = random1(floor(p) + vec3(0.0,1.0,0.0));\n  float urb = random1(floor(p) + vec3(1.0,1.0,0.0));\n\n  float llf = random1(floor(p) + vec3(0.0,0.0,1.0));\n  float lrf = random1(floor(p) + vec3(1.0,0.0,1.0));\n  float ulf = random1(floor(p) + vec3(0.0,1.0,1.0));\n  float urf = random1(floor(p) + vec3(1.0,1.0,1.0));\n\n  float lerpXLB = smootherStep(llb, lrb, pFract.x);\n  float lerpXHB = smootherStep(ulb, urb, pFract.x);\n  float lerpXLF = smootherStep(llf, lrf, pFract.x);\n  float lerpXHF = smootherStep(ulf, urf, pFract.x);\n\n  float lerpYB = smootherStep(lerpXLB, lerpXHB, pFract.y);\n  float lerpYF = smootherStep(lerpXLF, lerpXHF, pFract.y);\n\n  return smootherStep(lerpYB, lerpYF, pFract.z);\n}\n\n\n\n// FBM NOISE FUNCTION\nfloat fbm(vec3 p, float octaves) {\n  float amp = 0.5;\n  float freq = 8.0;\n  float sum = 0.0;\n  float maxSum = 0.0;\n  for(float i = 0.0; i < 10.0; ++i) {\n    if(i == octaves)\n    break;\n    maxSum += amp;\n    sum += perlin(p * freq) * amp;\n    amp *= 0.5;\n    freq *= 2.0;\n  }\n  return sum / maxSum;\n}\n\n\n\n// WORLEY NOISE FUNCTION\nfloat worley2D(vec2 p) {\n    vec2 pointInt = floor(p);\n    vec2 pointFract = fract(p);\n    float minDist = 1.0;\n    \n    for (int y = -1; y <= 1; y++) {\n        for (int x = -1; x <= 1; x++) {\n            vec2 neighbor = vec2(float(x), float(y));\n            vec2 point = random2(pointInt + neighbor);\n            point = 0.5 + 0.5 * sin(iTime * 0.01 + 6.2831 * point);  \n            vec2 diff = neighbor + point - pointFract;\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n\nfloat worley3D(vec3 p) {\n    p *= 0.3;\n    vec3 pointInt = floor(p);\n    vec3 pointFract = fract(p);\n    \n    float minDist = 1.0;\n    \n    for (int z = -1; z <= 1; z++) {\n        for (int y = -1; y <= 1; y++) {\n            for (int x = -1; x <= 1; x++) {\n                vec3 neighbor = vec3(float(x), float(y), float(z));\n                vec3 point = random3(pointInt + neighbor);\n                point = 0.5 + 0.5 * sin(iTime * 1.5 * 0.01 + 6.2831 * point);  \n                vec3 diff = neighbor + point - pointFract;\n                float dist = length(diff);\n                minDist = min(minDist, dist);\n            }\n        }\n    }\n    return minDist;\n}\n\n\n\n// COORDINATE & ROTATION FUNCTIONS\nvoid pR(inout vec2 p, float a)\n{\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec3 rotatePtY(vec3 pt, float a)\n{    \n    pR(pt.yz, 0.);\n    pR(pt.xz, a);\n    pR(pt.xy, 0.);\n    \n    return pt;\n}\n\nvec3 rotatePtX(vec3 pt, float a)\n{    \n    pR(pt.yz, a);\n    pR(pt.xz, 0.);\n    pR(pt.xy, 0.);\n    \n    return pt;\n}\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvoid CoordinateSystem(in vec3 v1, out vec3 v2, out vec3 v3) {\n    if (abs(v1.x) > abs(v1.y)) {\n    \tv2 = vec3(-v1.z, 0.0, v1.x) / sqrt(v1.x * v1.x + v1.z * v1.z);\n    } else {\n    \tv2 = vec3(0.0, v1.z, -v1.y) / sqrt(v1.y * v1.y + v1.z * v1.z);\n    }\n    v3 = cross(v1, v2);\n}\n\nmat3 TangentToWorld(vec3 nor) {\n    vec3 tangent, bitangent;\n    CoordinateSystem(nor, tangent, bitangent);\n    return mat3(tangent, bitangent, nor);\n}\n\n\n\nvoid rayCast(vec3 eye, vec3 ref, vec2 ndc, out vec3 dir) {    \n    float len = tan(3.14159 * 0.125) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    dir = normalize(p - eye);\n}\n\n\n    \n// SHAPE SDFs\nfloat sphere(vec3 p, float r, vec3 c) {\n\treturn distance(p, c) - r;\n}\n\nfloat cube(vec3 p, vec3 c) {\n    return length(max(abs(p) - c, 0.0));\n}\n\nfloat squarePlane(vec3 p, vec4 n)\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat torus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q) - t.y;\n}\n\n\n#define VENUS_SDF\t \tsphere(pos + vec3(0.0, 0., 0.0), 2.0, vec3(-8.0, 0.0, 4.0))\n#define VENUS_ID\t\t1\n#define EARTH_SDF\t\tcube(rotatePtX(rotatePtY(pos + vec3(0.0, 0.3, -0.9), 0.3 * iTime), 0.6), vec3(1.3, 1.3, 1.3))\n#define EARTH_ID\t\t2\n#define MARS_SDF\t\tsphere(pos, 2.5, vec3(12.0, 0.0, -5.5))\n#define MARS_ID\t\t\t3\n#define SATURN_SDF\t\tsphere(pos + vec3(0.0, -1.0, 0.1), 2.0, vec3(16.0, 0.0, -13.0))\n#define SATURN_ID\t\t4\n#define TORUS1_SDF\t\ttorus(rotatePtX(rotatePtY(pos + vec3(-15.9, -1.05, 13.0), -0.8 * iTime), 0.5 * iTime), vec2(2.7, 0.35))\n#define TORUS1_ID\t\t5\n#define TORUS2_SDF\t\ttorus(rotatePtX(rotatePtY(pos + vec3(-16.0, -1.1, 13.0), -0.8), -0.5 * iTime), vec2(3.7, 0.35))\n#define TORUS2_ID\t\t6\n#define NEPTUNE_SDF\t\tsphere(pos + vec3(0.0, -2.5, 0.0), 2.5, vec3(20.0, 0.0, -22.0))\n#define NEPTUNE_ID\t\t7\n#define BACK_SDF \t\tsquarePlane(pos + vec3(-60.0, 0.0, 0.0), vec4(-1., 0., 0., 1.))\n#define BACK_ID \t\t8\n#define LIGHT_SDF\t\tsphere(pos + vec3(0., 0., 0.), 2.0, lightPos)\n#define LIGHT_ID\t\t9\n\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj, vec3 lightPos) {\n    t = VENUS_SDF;\n    obj = VENUS_ID;\n    \n    float t2;\n    if ((t2 = EARTH_SDF) < t) {\n    \tt = t2;\n      \tobj = EARTH_ID;\n    }\n    \n    if ((t2 = MARS_SDF) < t) {\n    \tt = t2;\n      \tobj = MARS_ID;\n    }\n    \n    if ((t2 = SATURN_SDF) < t) {\n    \tt = t2;\n      \tobj = SATURN_ID;\n    }\n    \n    if ((t2 = TORUS1_SDF) < t) {\n    \tt = t2;\n      \tobj = TORUS1_ID;\n    }\n    \n    if ((t2 = TORUS2_SDF) < t) {\n    \tt = t2;\n      \tobj = TORUS2_ID;\n    }\n    \n    if ((t2 = NEPTUNE_SDF) < t) {\n    \tt = t2;\n      \tobj = NEPTUNE_ID;\n    }\n    \n    if ((t2 = BACK_SDF) < t) {\n    \tt = t2;\n      \tobj = BACK_ID;\n    }\n    \n    if ((t2 = LIGHT_SDF) < t) {\n    \tt = t2;\n    \tobj = LIGHT_ID;\n    }\n}\n\n\nfloat sceneMap3D(vec3 pos, vec3 lightPos) {\n    float t = VENUS_SDF;\n    \n    float t2;\n    if ((t2 = EARTH_SDF) < t) {\n    \tt = t2;\n    }\n    \n    if ((t2 = MARS_SDF) < t) {\n    \tt = t2;\n    }\n    \n    if ((t2 = SATURN_SDF) < t) {\n    \tt = t2;\n    }\n    \n    if ((t2 = TORUS1_SDF) < t) {\n    \tt = t2;\n    }\n    \n    if ((t2 = TORUS2_SDF) < t) {\n    \tt = t2;\n    }\n    \n    if ((t2 = NEPTUNE_SDF) < t) {\n    \tt = t2;\n    }\n    \n    if ((t2 = BACK_SDF) < t) {\n    \tt = t2;\n    }\n    \n    if ((t2 = LIGHT_SDF) < t) {\n    \tt = t2;\n    }\n    \n    return t;\n}\n\n\nfloat shadowMap3D(vec3 pos) {\n    float t = VENUS_SDF;\n    \n    float t2;\n    if ((t2 = EARTH_SDF) < t) {\n    \tt = t2;\n    }\n    \n    if ((t2 = MARS_SDF) < t) {\n    \tt = t2;\n    }\n    \n    if ((t2 = SATURN_SDF) < t) {\n    \tt = t2;\n    }\n    \n    if ((t2 = TORUS1_SDF) < t) {\n    \tt = t2;\n    }\n    \n    if ((t2 = TORUS2_SDF) < t) {\n    \tt = t2;\n    }\n    \n    if ((t2 = NEPTUNE_SDF) < t) {\n    \tt = t2;\n    }\n    \n    if ((t2 = BACK_SDF) < t) {\n    \tt = t2;\n    }\n    \n    return t;\n}\n\n\nvec3 computeNormal(vec3 pos, vec3 lightPos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx, lightPos) - sceneMap3D(pos - epsilon.yxx, lightPos),\n                            sceneMap3D(pos + epsilon.xyx, lightPos) - sceneMap3D(pos - epsilon.xyx, lightPos),\n                            sceneMap3D(pos + epsilon.xxy, lightPos) - sceneMap3D(pos - epsilon.xxy, lightPos)));\n}\n\n\nvec3 WorlyTangentSpaceNormal(vec3 pos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize(vec3(worley3D(pos + epsilon.yxx) - worley3D(pos - epsilon.yxx),\n                          worley3D(pos + epsilon.xyx) - worley3D(pos - epsilon.xyx),\n                          worley3D(pos + epsilon.xxy) - worley3D(pos - epsilon.xxy)));\n}\n\n\nvec3 FbmTangentSpaceNormal(vec3 pos, float a) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize(vec3(fbm(pos + epsilon.yxx, a) - fbm(pos - epsilon.yxx, a),\n                          fbm(pos + epsilon.xyx, a) - fbm(pos - epsilon.xyx, a),\n                          fbm(pos + epsilon.xxy, a) - fbm(pos - epsilon.xxy, a)));\n}\n\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj, vec3 lightPos) {\n    t = 0.001;\n    \n    for (int i = 0; i < RAY_STEPS; ++i) {\n    \tvec3 pos = origin + t * dir;\n        float m; // Minimum distance from this point to an object in the scene\n        sceneMap3D(pos, m, hitObj, lightPos);\n        if (m < 0.01) {\n        \treturn;\n        }\n        t += m;\n    }\n\t// We hit nothing\n    t = -1.0;\n    hitObj = -1;\n}\n\n\nfloat fiveTapAO(vec3 p, vec3 n, float k) {\n    float aoSum = 0.0;\n    for(float i = 0.0; i < 5.0; ++i) {\n        float coeff = 1.0 / pow(2.0, i);\n        aoSum += coeff * (i * AO_DIST - shadowMap3D(p + n * i * AO_DIST));\n    }\n    return 1.0 - k * aoSum;\n}\n\n\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float k) {\n    float res = 1.0;\n    float t = min_t;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        float m = shadowMap3D(origin + t * dir);\n        if(m < 0.0001) {\n            return 0.0;\n        }\n        res = min(res, k * m / t);\n        t += m;\n    }\n    return res;\n}\n\n\nfloat subsurfaceColor(vec3 lightDir, vec3 n, vec3 view, float thin) {\n\tvec3 scatterDir = lightDir + n * DISTORTION;\n\tfloat lightReachingEye = pow(clamp(dot(view, -scatterDir), 0.0, 1.0), GLOW) * BSSRDF_SCALE;\n\tfloat attenuation = max(0.0, dot(n, lightDir) + dot(view, -lightDir));\n    float totalLight = attenuation * (lightReachingEye + AMBIENT) * thin;\n    return totalLight;\n}\n\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 light, vec3 view, float thin) {\n    vec3 worley_normal = WorlyTangentSpaceNormal(p);\n    worley_normal = TangentToWorld(n) * worley_normal;\n    float worleyLambert = dot(light, worley_normal);\n    \n    vec3 fbm_normal = FbmTangentSpaceNormal(p, 4.0);\n    fbm_normal = TangentToWorld(n) * fbm_normal;\n    float fbmLambert = dot(light, fbm_normal);\n    \n    float lambert = max(0.0, dot(n,light));\n    \n    switch(hitObj) {\n        // Sphere 1\n        case VENUS_ID:\n        vec3 color1 = vec3(1.0,0.88,0.7) * vec3(1.0,0.7,0.4) * palette(fbm(p * sin(iTime * 0.05),4.0),av,bv,cv,dv) * softShadow(light,p,0.1,6.0);\n        return color1 + vec3(0.0,0.2,1.0) * subsurfaceColor(light,n,view,thin) * vec3(1.0,0.88,0.7);\n        break;\n        // Sphere 2\n        case EARTH_ID:\n        return palette(perlin(p),ae,be,ce,de) * softShadow(light,p,0.1,6.0);\n        break;\n        // Sphere 3\n        case MARS_ID:\n        vec3 color2 = vec3(0.6,0.5,0.5) * palette(worley3D(p * sin(iTime * 0.2) * 2.3),am,bm,cm,dm) * softShadow(light,p,0.1,6.0);\n        return color2 + vec3(0.2,0.8,0.5) * subsurfaceColor(light,n,view,thin);\n        break;\n        // Sphere 4\n        case SATURN_ID:\n        return vec3(0.9,0.9,0.9) * palette(fbm(p * sin(iTime * 0.05),4.) * 1.65,as,bs,cs,ds) * softShadow(light,p,0.1,6.0);\n        break;\n        // Torus 1\n        case TORUS1_ID:\n        vec3 color3 = vec3(0.3,0.1,0.8) * vec3(0.7,0.2,0.8) * lambert * softShadow(light,p,0.1,6.0);\n        return color3 + vec3(1.0,0.5,0.3) * subsurfaceColor(light,n,view,thin) * vec3(1.0,0.88,0.7);\n        break;\n        // Torus 2\n        case TORUS2_ID:\n        vec3 color4 = vec3(1.0,0.88,0.8) * vec3(0.9,0.2,0.8) * lambert * softShadow(light,p,0.1,6.0);\n        return color4 + vec3(1.0,0.7,0.3) * subsurfaceColor(light,n,view,thin) * vec3(1.0,0.88,0.7);\n        break;\n        // Sphere 5\n        case NEPTUNE_ID:\n        vec3 color5 = vec3(0.4,0.8,1.6) * vec3(1.0,0.4,0.8) * palette(lambert,av,bv,cv,dv) * softShadow(light,p,0.1,6.0) * worley3D(p);\n        return color5 + vec3(1.0,0.0,0.8) * subsurfaceColor(light,n,view,thin) * vec3(1.0,0.88,0.7) * worley3D(p);\n        break; \n        // BACKGROUND\n        case BACK_ID:\n        return vec3(0.0, 0.3, 0.4) * palette(worleyLambert,as,bs,cs,ds);\n        break;\n        // Light\n        case LIGHT_ID:\n        return vec3(1.0, 0.88, 0.7);\n        break;\n        // Background\n        case -1:\n        return vec3(0.0);\n        break;\n    }\n    return vec3(1.0);\n}\n\n\nIntersection sdf3D(vec3 dir, vec3 eye, vec3 lightPos) {\n\tfloat t;\n    int hitObj;\n    march(eye, dir, t, hitObj, lightPos);\n    \n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect, lightPos);\n    vec3 lightDir = normalize(lightPos - isect);\n    float thickness = fiveTapAO(isect, -nor, AO_KVAL);\n        \n    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect), thickness);\n        \n    return Intersection(t, surfaceColor, isect, hitObj);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 lightPos = rotateY(vec3(30.0, 4.0, -22.0), iTime * 0.5);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Convert to range [-1,1]\n    uv = uv * 2.0 - vec2(1.0, 1.0);\n    \n    vec3 eye = rotateY(vec3(0.0, 0.0, 15.0), sin(30.0) * 3.14159 * 0.5);\n    vec3 ref = vec3(0, 0, 0);\n    vec3 rayDir;\n    \n    rayCast(eye, ref, uv, rayDir);\n    \n    Intersection isect = sdf3D(rayDir, eye, lightPos);\n\n    // Output to screen\n    fragColor = vec4(isect.color, 1.);\n}\n","name":"Image","description":"","type":"image"}]}