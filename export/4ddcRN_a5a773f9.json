{"ver":"0.1","info":{"id":"4ddcRN","date":"1518127768","viewed":3120,"name":"Cubic Honeycombs","username":"mla","description":"3d honeycombs using the Wythoff construction.\n\nMouse to zoom and rotate\nSee code for keys.","likes":20,"published":3,"flags":16,"usePreview":0,"tags":["3d","raymarch","honeycomb","wythoff"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":" ////////////////////////////////////////////////////////////////////////////////\n//\n// Created by Matthew Arcus, 2018.\n//\n// Cubic honeycombs using the Wythoff construction.\n//\n// 'm': smooth transition between Wythoff symbols\n// 'a': control Wythoff symbol with keys '1'-'4'\n// 'i': invert in origin\n// 'c': translate Wythoff point to origin (before inversion)\n//\n////////////////////////////////////////////////////////////////////////////////\n\nbool invert = false;\nbool centre = false;\nbool morph = true;\n\nconst float scale = 1.0;\n\nvec4 tri0 = vec4(1,1,1,1);\n\nconst float fudge = 0.5; // Try to cope with non-linearity of inversion\n\nconst float sscale = 1.5;\nconst float swidth = sscale*0.05;\nconst float swidth2 = swidth*swidth;\nconst float twidth = sscale*0.02;\nconst float twidth2 = twidth*twidth;\n\nconst float PI =  3.141592654;\nconst float TWOPI =  2.0*PI;\n\n//-------------------------------------------------\n//From https://www.shadertoy.com/view/XtXGRS#\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\n// Setup folding planes and vertex\n\n// Vertices of fundamental region\nconst vec3 p0 = vec3(0,0,0);\nconst vec3 q0 = vec3(1,0,0);\nconst vec3 r0 = vec3(1,1,0);\nconst vec3 s0 = vec3(1,1,1);\n\n// The reflecting planes\n// Also the directions of the edges from the fundamental point\nconst float K = 1.41421356;\nconst vec3 P = vec3(-1, 0, 0); // Distance 1 from origin\nconst vec3 Q = 0.5*K*vec3(1,-1, 0);\nconst vec3 R = 0.5*K*vec3(0, 1,-1);\nconst vec3 S = vec3(0, 0, 1);\n\nvec4 tri2bary = vec4(1,K,K,1);\nvec3 a; // Wythoff point\n\nvoid init(vec4 tri) {\n  tri *= tri2bary;\n  a = tri[0]*p0 + tri[1]*q0 + tri[2]*r0 + tri[3]*s0;\n  a /= dot(tri,vec4(1));\n}\n\nvec3 fold(vec3 p, out float iscale) {\n  iscale = 1.0;\n  if (invert) {\n    float r2 = dot(p,p);\n    p /= r2;\n    iscale = fudge*r2;\n  }\n  if (centre) p = p+a; // Centre on Wythoff point rather than origin (ie. one of the polyhedra)\n\n  // Fold in to unit cube\n  // Make sure origin goes to origin\n  p = mod(1.0+p,2.0)-1.0;\n  p = abs(p);\n  // Now flip into main tetrahedron\n  p -= 2.0*min(0.0,dot(p,Q))*Q;\n  p -= 2.0*min(0.0,dot(p,R))*R;\n  p -= 2.0*min(0.0,dot(p,Q))*Q;\n  return p;\n}\n\nfloat scene(vec3 p) {\n  float d = 1e8;\n  p -= a; // Centre on Wythoff point\n  float dP = dot(p,P), dQ = dot(p,Q), dR = dot(p,R), dS = dot(p,S);\n  d = min(d,length(p)-swidth); // The vertex\n  d = min(d,max(dP,length(p-dP*P)-twidth)); // The four edges\n  d = min(d,max(dQ,length(p-dQ*Q)-twidth));\n  d = min(d,max(dR,length(p-dR*R)-twidth));\n  d = min(d,max(dS,length(p-dS*S)-twidth));\n  return d;\n}\n\nfloat eval(vec3 p) {\n  float iscale;\n  p *= scale;\n  p = fold(p,iscale);\n  float d = scene(p);\n  d *= iscale;\n  d /= scale;\n  return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n  const vec2 e = vec2(0.0001, 0.0);\n  return normalize(vec3(eval(p + e.xyy) - eval(p - e.xyy),\n                        eval(p + e.yxy) - eval(p - e.yxy),\n                        eval(p + e.yyx) - eval(p - e.yyx)));\n}\n\nfloat march(in vec3 ro, in vec3 rd) {\n  const float maxd = 25.0;\n  const float precis = 0.0002;\n  float h = precis * 2.0;\n  float t = 0.0;\n  float res = 1e8;\n  for (int i = 0; i < 200; i++) {\n    if (h < precis || t > maxd) break;\n    h = eval(ro + rd * t);\n    // When inverting, limit step size to prevent\n    // overshoot when coming in from a distance.\n    if (invert) h = min(h,0.5);\n    t += h;\n  }\n  if (t < maxd) res = t;\n  return res;\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = -(2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = -(2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,phi);\n    p.zx = rotate(p.zx,phi);\n  }\n  float t = iTime;\n  p.yz = rotate(p.yz,t * 0.125);\n  p.zx = rotate(p.zx,t * 0.2);\n  return p;\n}\n\nvec3 getcolor(vec3 p) {\n  float iscale;\n  p *= scale;\n  p = fold(p,iscale);\n  p -= a; // Centre on Wythoff point\n  float dP = dot(p,P), dQ = dot(p,Q), dR = dot(p,R), dS = dot(p,S);\n  float d0 = length(p)-swidth; // The vertex\n  float d1 = max(dP,length(p-dP*P)-twidth); // The four edges\n  float d2 = max(dQ,length(p-dQ*Q)-twidth);\n  float d3 = max(dR,length(p-dR*R)-twidth);\n  float d4 = max(dS,length(p-dS*S)-twidth);\n  int colindex = 0;\n  float d = d0;\n  if (d1 < d) { colindex = 1; d = d1; }\n  if (d2 < d) { colindex = 2; d = d2; }\n  if (d3 < d) { colindex = 3; d = d3; }\n  if (d4 < d) { colindex = 4; d = d4; }\n  if (colindex == 1) return 0.5*vec3(0,1,0);\n  if (colindex == 2) return 0.6*vec3(0,0,1);\n  if (colindex == 3) return 0.6*vec3(1,1,0);\n  if (colindex == 4) return 0.8*vec3(1,0,0);\n  return 0.1*vec3(1);\n}\n\nconst int CHAR_0 = 48;\nconst int CHAR_1 = 49;\nconst int CHAR_2 = 50;\nconst int CHAR_3 = 51;\nconst int CHAR_4 = 52;\nconst int CHAR_A = 65;\nconst int CHAR_C = 67;\nconst int CHAR_I = 73;\nconst int CHAR_M = 77;\n\nbool keypress(int code) {\n#if __VERSION__ < 300\n  return false;\n#else\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n#endif\n}\n\nint imod(int n,int m) {\n#if __VERSION__ >= 300\n  return n%m;\n#else\n  return n - n/m*m;\n#endif\n}\n\nvec4 gettri0(int i) {\n#if __VERSION__ >= 300\n  i += 9;\n  i = 1+i%15;\n  i = i^(i/2);\n#else\n  i += 14;\n  i = 1+imod(i,15);\n#endif\n  return vec4(imod(i,2),imod(i/2,2),imod(i/4,2),imod(i/8,2));\n}\n\nvec4 gettri() {\n  float t = 0.5*iTime;\n  int i = int(t);\n  float k = 0.0;\n  if (morph) k = fract(t);\n  return mix(gettri0(i),gettri0(i+1),k);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  invert = !keypress(CHAR_I);\n  centre = keypress(CHAR_C);\n  morph = !keypress(CHAR_M);\n  vec2 p = (2.0*fragCoord.xy - iResolution.xy) / iResolution.y;\n  float t = iTime/TWOPI;\n  if (keypress(CHAR_A)) {\n    tri0 = vec4(int(!keypress(CHAR_1)),int(!keypress(CHAR_2)),\n                int(!keypress(CHAR_3)),int(!keypress(CHAR_4)));\n  } else {\n    tri0 = gettri();\n  }\n  init(tri0);\n  vec3 bg = vec3(0.3 + p.y*0.1);\n  vec3 col = bg;\n  vec3 ro = vec3(0, 0, 2.0);\n  vec3 rd = normalize(vec3(p, -2.0));\n  vec3 li = normalize(vec3(0.5, 2, 3.0));\n  ro = transform(ro);\n  if (iMouse.y > 0.0) {\n    ro *= 2.0*iMouse.y/iResolution.y;\n  }\n  rd = transform(rd);\n  li = transform(li);\n\n  float k = march(ro,rd);\n  if (k < 1e8) {\n    vec3 pos = ro + k*rd;\n    vec3 n = calcNormal(pos);\n    col = 0.1+0.8*getcolor(pos);\n    float diffuse = clamp(dot(n, li), 0.0, 1.0);\n    col *= 0.4+0.6*diffuse;\n    if (invert) {\n      //col = mix(vec3(1,1,0.5), col, smoothstep(0.0,0.2,length(pos)));\n      col = mix(vec3(0), col, smoothstep(0.0,0.2,length(pos)));\n    }\n  }\n  //col = mix(col, 0.5*vec3(1,1,0.5), clamp(k/40.0,0.0,1.0));\n  col = mix(col, 0.1*vec3(0,0,1), clamp(k/25.0,0.0,1.0));\n  col = pow(col, vec3(0.4545));\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}