{"ver":"0.1","info":{"id":"3lcGzH","date":"1575597467","viewed":235,"name":"Simple 3D_Mirror reflection","username":"lypion","description":"ray tracing, sphere intersection, mirror reflection, Blinn-Phong lighting","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n---Base---\n\tThis one is created base one Simple 3D_sphere: https://www.shadertoy.com/view/wsGSDG\n\n---Main Content---\n\tBesides base content, it also include:\n\t1. Mirror reflection\n*/\n\n//define the global ambient lighting\n#define LIGHT_AMBIENT vec3(0.2)\n\n#define BACKGROUND_COLOR vec3(1.0)\n\n//whether or not open the mirror reflection\n#define MIRROR_REFLECTION\n#define MAX_REFLECTION_COUNT 3\n\n//All the objects is defined in its self space\nSphere yellowSphere = Sphere(vec3(0.0, 0.0, 0.0), Material(vec3(0.2), vec3(1.0, 1.0, 0.0), vec3(1.), vec3(1.0), 256.0), 4.0);  \nSphere redSphere = Sphere(vec3(0.0, 0.0, 0.0), Material(vec3(0.3), vec3(1.0, 0.2, 0.0), vec3(1.), vec3(1.0), 200.0), 4.0);  \nSphere blueSphere = Sphere(vec3(0.0, 0.0, 0.0), Material(vec3(0.5), vec3(0.0, 0.2, 1.0), vec3(1.0), vec3(1.0), 128.0), 4.0);  \nPlane plane = Plane(vec3(0.0), normalize(vec3(0.0, 1.0, 0.0)), Material(vec3(0.2), vec3(0.9), vec3(0.2), vec3(0.), 4.0));\n\nIntersection IntersectWithSphereFirst(Intersection intersection, Sphere sphere)\n{\n\tvec3 temp = intersection.ray.origin - sphere.position;\n    float a = dot(intersection.ray.direction, intersection.ray.direction);\n    float b = dot(intersection.ray.direction, temp);\n    float c = dot(temp, temp) - sphere.radius * sphere.radius;\n    float delta = b * b - a * c;\n    \n    if(delta > 0.00001)\n    {\n    \tfloat sqrtDelta = sqrt(delta);\n    \tfloat t1 = (-b + sqrtDelta) / a;\n        float t2 = (-b - sqrtDelta) / a;\n        \n        if(t2 > intersection.ray.tMIN && t2 < intersection.t)\n        {\n            vec3 point = intersection.ray.origin + intersection.ray.direction * t2;\n            vec3 normal = CalSphereNormal(sphere, point);\n        \tintersection.t = t2;\n            intersection.color = sphere.material;\n            intersection.normal = normal;\n            intersection.hasIntersect = true;\n        }        \t\n        else if(t1 > intersection.ray.tMIN && t1 < intersection.t)\n        {\n            vec3 point = intersection.ray.origin + intersection.ray.direction * t1;\n            vec3 normal = CalSphereNormal(sphere, point);\n        \tintersection.t = t1;\n            intersection.color = sphere.material;\n            intersection.normal = normal;\n            intersection.hasIntersect = true;\n        }        \t\n    }\n    return intersection;\n}\n\nIntersection IntersectWithPlaneFirst(Intersection intersection, Plane plane)\n{\n\tfloat denominator = dot(intersection.ray.direction, plane.normal);\n\tif(abs(denominator) < 0.00001)\n        return intersection; \n    \n    float t = dot((plane.point - intersection.ray.origin), plane.normal) / denominator;\n    if(t > intersection.ray.tMIN && t < intersection.ray.tMAX && t < intersection.t)\n    {\n    \tintersection.t = t;\n        intersection.color = plane.material;\n        intersection.normal = plane.normal;\n        intersection.hasIntersect = true;\n    } \n    return intersection;\n}\n\n//Generate the ray from the camera\n//return-return the ray in view space\nRay GenerateRay(Camera camera, vec2 uv)\n{\n    //map the center of the screen as the origin point\n\tuv -= vec2(0.5);\n    float halfHeight = tan(camera.fov / 2.0) * camera.frustum.nearestPlane;\n    float halfWidth = halfHeight / camera.aspectRatio;\n    vec3 pixelInViewSpace = vec3(0.0, 0.0, -camera.frustum.nearestPlane) + \n                 \t\t\tvec3(2.0 * uv.x * halfWidth * camera.aspectRatio * camera.aspectRatio, 0.0, 0.0) + \n                 \t\t\tvec3(0.0, 2.0 * uv.y * halfHeight, 0.0);\n    return Ray(vec3(0.0), normalize(pixelInViewSpace), RAY_MIN, RAY_MAX);\n}\n\n\n\nvec3 ShadowTest(Intersection intersection, vec3 lightDirect, Camera camera)\n{\n    vec3 point = intersection.ray.origin + intersection.ray.direction * intersection.t;\n\tvec3 newPoint = point - 0.01 * lightDirect;\n    Ray shadowRay = Ray(newPoint, -lightDirect, RAY_MIN, RAY_MAX); \n   \t\n    bool interWithYSphere = IsIntersectWithSphere(shadowRay, yellowSphere, camera, true);  \n    bool interWithRSphere = IsIntersectWithSphere(shadowRay, redSphere, camera, true);\n    bool interWithBSphere = IsIntersectWithSphere(shadowRay, blueSphere, camera, true);\n    if(interWithYSphere || interWithRSphere || interWithBSphere) \n    \treturn vec3(0.0);\n    else\n        return vec3(1.0);\n}\n\n\nvec3 RayTracing(Ray ray, DirectLight directLight, Camera camera)\n{\n\tMaterial defultMat = Material(vec3(1.0), vec3(1.0), vec3(1.0), vec3(0.0), 0.0);\n\tint count = 0, maxCount = 1;\n    vec3 result;\n#ifdef MIRROR_REFLECTION\n    maxCount = MAX_REFLECTION_COUNT;\n#endif\n    \n    //When we do not open the reflection, maxCount = 1, so this loop only conducts once\n    //otherwide, we reflect the rays until it hit something or it reachs the max reflection count\n    while(count < maxCount)\n    {\n        Intersection intersection = Intersection(ray, defultMat, vec3(1.0, 0.0, 0.0), RAY_MAX, false);\n    \tintersection = IntersectWithSphereFirst(intersection, yellowSphere); \n    \tintersection = IntersectWithSphereFirst(intersection, redSphere); \n    \tintersection = IntersectWithSphereFirst(intersection, blueSphere); \n    \tintersection = IntersectWithPlaneFirst(intersection, plane);\n        vec3 color = LIGHT_AMBIENT * intersection.color.ambient;\n        if(intersection.hasIntersect == true)\n        {\n            color = CalDirectLight(directLight, intersection, vec3(0.0));\n            color = color * ShadowTest(intersection, directLight.direction, camera);\n            //Actually this is a good habbit to put the constant to the left, in case of we \n            //mistakely losting one =, the compiler doesn't check this error.\n            \n            if(0 == count)       //It's the first-time calculation, so it's the object's original color\n                result += color;\n            else                 //frrom now on, we start to calculate the reflection, so we need to multiply the reflection param\n                result += (color * intersection.color.reflection);            \n#ifdef MIRROR_REFLECTION\n    \t\tvec3 point = intersection.ray.origin + intersection.ray.direction * intersection.t;\n        \tvec3 viewDir = point - vec3(0.0);\n        \tvec3 reflectDir = viewDir - 2.0 * intersection.normal * dot(intersection.normal, viewDir);\n\t\t\tvec3 newPoint = point + 0.01 * reflectDir;\n            //a new ray generates from the intersection point.\n            //for precision reason, we move it a little toward the reflection direction\n   \t\t\tray = Ray(newPoint, normalize(reflectDir), RAY_MIN, RAY_MAX);\n#endif      \n       }\n       else\n        {\n        \tbreak;\n        }\n        count++;\n    }\n    //we hit nothing\n    if(0 == count)\n       return BACKGROUND_COLOR;\n    else\n    \treturn result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    Frustum frustum = Frustum(2.0, 100.0);\n\tvec3 cameraPos = vec3(0.0, 4.0, 0.0);\n\tvec3 cameraTar = vec3(0.0, 4.0, -1.);\n\tCamera camera = Camera(cameraPos, cameraTar, vec3(0.0, 1.0, 0.0), frustum, \n                           80.0 / 180.0 * PI, iResolution.x / iResolution.y);\n    vec3 ySpherePos = vec3(-10., 4.1, -15.0);\n    vec3 rSpherePos = vec3(1., 4.1, -10.0);\n    vec3 bSpherePos = vec3(10., 4.1, -13.0);\n          \n    mat4 ySphereTransform = CalWorld2ViewMatrix(camera) * Translate(ySpherePos); \n    yellowSphere.position = vec3(ySphereTransform * vec4(yellowSphere.position, 1.0));  \n    \n    mat4 rSphereTransform = CalWorld2ViewMatrix(camera) * Translate(rSpherePos); \n    redSphere.position = vec3(rSphereTransform * vec4(redSphere.position, 1.0)); \n\n    mat4 bSphereTransform = CalWorld2ViewMatrix(camera) * Translate(bSpherePos); \n    blueSphere.position = vec3(bSphereTransform * vec4(blueSphere.position, 1.0)); \n    \n    mat4 planeTransform = CalWorld2ViewMatrix(camera); \n    plane.point = (planeTransform * vec4(plane.point, 1.0)).xyz;\n    \n    mat4 normalMat = planeTransform;\n    plane.normal = normalize((normalMat * vec4(plane.normal, 0.0)).xyz);\n    \n    vec3 direction = normalize(vec3(cos(iTime * 0.1) * 10.0, -abs(sin(iTime * 0.1)) * 10.0, cos(iTime * 0.1) * 10.0 - 12.));\n    DirectLight directLight = DirectLight(direction, vec3(0.8));      \n    directLight.direction = vec3(CalWorld2ViewMatrix(camera) * vec4(directLight.direction, 0.0)).xyz;\n    \n    Ray ray = GenerateRay(camera, uv);   \n    vec3 color = RayTracing(ray, directLight, camera);\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//The nearest intersect distance\n#define RAY_MIN 0.0001f\n//The farest intersect distance\n#define RAY_MAX 1.0e20f\n\n#define PI 3.1415\n\n//only see the outside\n#define OUTSIDE_ONLY\n\nstruct Ray\n{\n\tvec3 origin;\n    vec3 direction;\n    float tMIN;\n    float tMAX;       \n};\n    \nstruct DirectLight\n{\n\tvec3 direction;\n\tvec3 color;\n};\n    \nstruct Material\n{\n    vec3 ambient;\n\tvec3 diffuse;\n    vec3 specular;\n    vec3 reflection;\n    float shininess;\n};\n    \nstruct Intersection\n{\n    Ray ray;\n    Material color;\n    vec3 normal;\n\tfloat t;\n    bool hasIntersect;\n};\n    \nstruct Plane\n{\n\tvec3 point;\n    vec3 normal;\n    Material material;\n};\n    \nstruct Sphere\n{\n\tvec3 position;\n    Material material;\n    float radius;\n};\n    \nstruct Frustum\n{\n    //the distance between near plane and camera\n    float nearestPlane;\n    //the distance between far plane and camera\n    float farestPlane;\n};\n    \nstruct Camera\n{\n\tvec3 position;\n    vec3 target;\n    vec3 upGuide;   //the vector used to calculate the coordinate of camera, not the real up vector of camera\n    Frustum frustum;\n    float fov;\n    float aspectRatio;\n};\n\nmat4 Scale(vec3 param)\n{\n\treturn mat4(vec4(param.x, 0.0, 0.0, 0.0),\n                vec4(0.0, param.y, 0.0, 0.0),\n                vec4(0.0, 0.0, param.z, 0.0),\n                vec4(0.0, 0.0, 0.0, 1.0));\n}\n\nmat4 Translate(vec3 param)\n{\n\treturn mat4(vec4(1.0, 0.0, 0.0, 0.0),\n                vec4(0.0, 1.0, 0.0, 0.0),\n                vec4(0.0, 0.0, 1.0, 0.0),\n                vec4(param, 1.0));\n}\n\nmat4 Rotate(vec3 param)\n{\n\tmat4 xMat = mat4(vec4(1.0, 0.0, 0.0, 0.0),\n                     vec4(0.0, cos(param.x), sin(param.x), 0.0),\n                     vec4(0.0, -sin(param.x), cos(param.x), 0.0),\n                     vec4(0.0, 0.0, 0.0, 1.0));\n    mat4 yMat = mat4(vec4(cos(param.y), 0.0, -sin(param.y), 0.0),\n                     vec4(0.0, 1.0, 0.0, 0.0),\n                     vec4(sin(param.y), 0.0, cos(param.y), 0.0),\n                     vec4(0.0, 0.0, 0.0, 1.0));\n    mat4 zMat = mat4(vec4(cos(param.z), sin(param.z), 0.0, 0.0),\n                     vec4(-sin(param.z), cos(param.z), 0.0, 0.0),\n                    vec4(0.0, 0.0, 1.0, 0.0),\n                    vec4(0.0, 0.0, 0.0, 1.0));\n    return zMat * yMat * xMat;\n}\n\nmat4 CalWorld2ViewMatrix(Camera camera)\n{\n\tvec3 zDirec = normalize(camera.position - camera.target);\n    vec3 xDirec = normalize(cross(camera.upGuide, zDirec));\n    vec3 yDirec = cross(zDirec, xDirec);\n    mat4 view2World = mat4(vec4(xDirec, 0.0), \n                           vec4(yDirec, 0.0), \n                           vec4(zDirec, 0.0), \n                           vec4(0.0, 0.0, 0.0, 1.0));\n\t\n    mat4 translateMat = mat4(vec4(1.0, 0.0, 0.0, 0.0), \n                             vec4(0.0, 1.0, 0.0, 0.0), \n                             vec4(0.0, 0.0, 1.0, 0.0), \n                             vec4(-camera.position, 1.0));\n    return transpose(view2World) * translateMat;\n}\n\nmat4 CalView2WorldMatrix(Camera camera)\n{\n\tvec3 zDirec = normalize(camera.position - camera.target);\n    vec3 xDirec = normalize(cross(camera.upGuide, zDirec));\n    vec3 yDirec = cross(zDirec, xDirec);\n    mat4 view2World = mat4(vec4(xDirec, 0.0), \n                           vec4(yDirec, 0.0), \n                           vec4(zDirec, 0.0), \n                           vec4(0.0, 0.0, 0.0, 1.0)); \n    mat4 translateMat = mat4(vec4(1.0, 0.0, 0.0, 0.0), \n                             vec4(0.0, 1.0, 0.0, 0.0), \n                             vec4(0.0, 0.0, 1.0, 0.0), \n                             vec4(camera.position, 1.0));\n    return view2World * translateMat;\n}\n\nvec3 CalSphereNormal(Sphere sphere, vec3 point)\n{\n\treturn normalize(point - sphere.position);\n}\n\n//check whether the intersection point is outside the viewing frustum\nbool IsClip(Intersection intersection, Camera camera)\n{\n\tvec3 intersectPoint = intersection.ray.origin + intersection.ray.direction * intersection.t;\n    if(intersectPoint.z < -camera.frustum.nearestPlane && intersectPoint.z > -camera.frustum.farestPlane)\n        return false;\n    else\n        return true;\n}\n\n//param-outsideOnly: the viewer can see the inside of the object or not\nbool IsIntersectWithSphere(Ray ray, Sphere sphere, Camera camera, bool outsideOnly)\n{\n\tvec3 temp = ray.origin - sphere.position;\n    float a = dot(ray.direction, ray.direction);\n    float b = dot(ray.direction, temp);\n    float c = dot(temp, temp) - sphere.radius * sphere.radius;\n    float delta = b * b - a * c;\n    \n    if(delta > 0.0)\n    {\n        float sqrtDelta = sqrt(delta);\n    \tfloat t1 = (-b + sqrtDelta) / a;\n        float t2 = (-b - sqrtDelta) / a;\n        \n        Intersection inter;\n        inter.ray = ray;\n        \n        if(t2 > ray.tMIN && t2 < ray.tMAX)\n       \t{\n            inter.t = t2;\n            return !IsClip(inter, camera);\n        }\n        else if(outsideOnly)\n        {\n        \tif(t1 > ray.tMIN && t1 < ray.tMAX)\n            {\n                inter.t = t1;\n                return !IsClip(inter, camera);\n            }       \n        }\n    }        \n    return false;\n}\n\nbool IsIntersectWithPlane(Ray ray, Plane plane, Camera camera, bool outsideOnly)\n{\n    float denominator = dot(ray.direction, plane.normal);\n\tif(abs(denominator) < 0.00001)\n        return false;\n    \n    float t = dot((plane.point - ray.origin), plane.normal) / denominator;\n    bool flag = true;\n\tif(outsideOnly)\n    {\n        flag = denominator < 0.0;\n    }\n\tif(flag && t > ray.tMIN && t < ray.tMAX)\n    {\n    \tIntersection inter;\n        inter.ray = ray;\n        inter.t = t;\n        return !IsClip(inter, camera);\n    }\n    return false;\n}\n\n\n\nvec3 CalDirectLight(DirectLight light, Intersection intersection, vec3 viewPos)\n{   \n    //diffuse\n    float diff = max(0.0, dot(-light.direction, intersection.normal));\n    vec3 diffuse = diff * light.color * intersection.color.diffuse;\n    \n    //specular\n    vec3 viewDirect = normalize(viewPos - (intersection.ray.origin + intersection.t * intersection.ray.direction));\n    vec3 h = normalize(-light.direction + viewDirect);\n    vec3 specular = light.color * intersection.color.specular * pow(max(0.0, dot(intersection.normal, h)), intersection.color.shininess);\n\t\n    return diffuse + specular;\n}\n","name":"Common","description":"","type":"common"}]}