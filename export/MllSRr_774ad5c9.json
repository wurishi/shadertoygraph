{"ver":"0.1","info":{"id":"MllSRr","date":"1434168689","viewed":482,"name":"Microcosm","username":"Passion","description":"A slight variation of dgreensp's 'Magic Fractal' https://www.shadertoy.com/view/4ljGDd","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// variation of https://www.shadertoy.com/view/4ljGDd by dgreensp\n\nconst int MAGIC_BOX_ITERS = 16;\nconst float MAGIC_BOX_MAGIC = 0.325;\n\nfloat magicBox(vec3 p) {\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\n    // Take p anywhere in space and calculate the corresponding position\n    // inside the box, 0<(x,y,z)<1\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\n    \n    float lastLength = length(p);\n    float tot = 0.0;\n    // This is the fractal.  More iterations gives a more detailed\n    // fractal at the expense of more computation.\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\n      // The number subtracted here is a \"magic\" paremeter that\n      // produces rather different fractals for different values.\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\n      float newLength = length(p);\n      tot += abs(newLength-lastLength);\n      lastLength = newLength;\n    }\n\n    return tot;\n}\n\n// A random 3x3 unitary matrix, used to avoid artifacts from slicing the\n// volume along the same axes as the fractal's bounding box.\nconst mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                    0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                    -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n\n\nmat2 rot(float deg)\n{    \n    return mat2(cos(deg),-sin(deg),\n                sin(deg), cos(deg));\n        \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uv are screen coordinates, uniformly scaled to go from 0..1 vertically\n\tvec2 uv = fragCoord.xy / iResolution.yy;\n    float t = iTime*.25;\n    \n    uv*=3.5+.5-sin(t*.75);   //zoom in and out\n    //uv*=4.;\n   \n    // scroll a certain number of screenfuls/second\n    uv-=.5;                  // Center\n    uv*=rot(sin(-t*1.6)/3.); // a bit of rotation\n    uv.y -= t*1.8;           // move uv y coordinate\n    uv.x += sin(t*.12)*21.;  // move uv x coordinate side to side\n    \n    // Rotate uv onto the random axes given by M, and scale\n    // it down a bit so we aren't looking at the entire\n    // 1x1x1 fractal volume.  Making the coefficient smaller\n    // \"zooms in\", which may reduce large-scale repetition\n    // but requires more fractal iterations to get the same\n    // level of detail.\n    vec3 p = 0.5*M*vec3(uv, 0.0);\n    \n    float r = magicBox(p-t*.25);\n    // Scale to taste.  Also consider non-linear mappings.\n    r *= 0.05245;      // try .0245\n    // coloring\n\tfragColor = sqrt(vec4(vec3(cos(r*r-3.3),cos(r+r+r+2.49),cos(r+r+r+r-3.9)),1.0));\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"","description":"","type":"image"}]}