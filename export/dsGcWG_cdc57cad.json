{"ver":"0.1","info":{"id":"dsGcWG","date":"1696627360","viewed":29,"name":"Pure Distraction","username":"BadBadDog","description":"Set of random fx","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["fx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float Time = 0.0;\nvec2 Shift = vec2(0.0);\n\nvec4 Dots(float scale, vec2 uv)\n{\n    vec4 ret = vec4(0);\n    float localscale = 1.0/(scale*10.0);\n\n    vec2 uvmap = floor(uv*100.0*scale);\n    vec4 mapshift = texture(iChannel0, vec2(0, uvmap.y/(100.0*scale) + Shift/100.0));\n\n    uv.x += mapshift.x/(100.0*scale); \n    uvmap = floor(uv*100.0*scale);\n    vec4 map = texture(iChannel0, uvmap/(100.0*scale) + Shift/100.0);\n\n\n    vec2 point = (floor(uv*100.0*scale)+0.5)/(100.0*scale);\n    ret.a = smoothstep(0.06*localscale, 0.0, distance(uv, point));\n    ret.a += 0.5 * pow(smoothstep(0.05*localscale, 0.0, distance(uv, point)), 30.0);\n    ret.a = pow(ret.a, 2.0+3.0*abs(sin(Time*1.0))) * (1.0-abs(sin(Time*1.0)));\n\n    ret.r = ret.a * smoothstep(0.77, 0.78, map.r);\n    ret.g = ret.a * smoothstep(0.77, 0.78, map.g);\n    ret.b = ret.a * smoothstep(0.77, 0.78, map.b);\n    \n    ret.rgb += 2.0 * ret.r * vec3(pow(smoothstep(0.05*localscale, 0.0, distance(uv, point)), 10.0) * (1.0-abs(sin(Time*1.0))));\n    ret.rgb += 2.0 * ret.g * vec3(pow(smoothstep(0.05*localscale, 0.0, distance(uv, point)), 10.0) * (1.0-abs(sin(Time*1.0))));\n    ret.rgb += 2.0 * ret.b * vec3(pow(smoothstep(0.05*localscale, 0.0, distance(uv, point)), 10.0) * (1.0-abs(sin(Time*1.0))));\n\n    return ret;\n}\n\n\nvec4 Panels(float scale, vec2 uv)\n{\n    vec4 ret = vec4(0);\n    float localscale = 1.0/(scale*10.0);\n\n    vec2 uvmap = floor(uv*100.0*scale);\n    vec4 map = texture(iChannel0, uvmap/(100.0*scale) + Shift/100.0);\n\n    ret.a = (abs(fract(uv.x*100.0*scale)-0.5)-0.5) * (abs(fract(uv.y*100.0*scale)-0.5)-0.5);\n    ret.a = pow(ret.a, 0.1+0.9*abs(sin(Time*1.0))) * (1.0-abs(sin(Time*1.0)));\n\n    ret.r = ret.a * smoothstep(0.7, 0.8, map.r);\n    ret.g = ret.a * smoothstep(0.7, 0.8, map.g);\n    ret.b = ret.a * smoothstep(0.7, 0.8, map.b);\n\n    ret.r += 2.0 * pow(ret.a * smoothstep(0.7, 0.8, map.r), 2.0);\n    ret.g += 2.0 * pow(ret.a * smoothstep(0.7, 0.8, map.g), 2.0);\n    ret.b += 2.0 * pow(ret.a * smoothstep(0.7, 0.8, map.b), 2.0);\n\n    return ret;\n}\n\n\nvec4 Lamps(float scale, vec2 uv)\n{\n    vec4 ret = vec4(0);\n    float localscale = 1.0/(scale*10.0);\n\n    vec2 uvmap = floor(uv*100.0*scale);\n    vec4 map = texture(iChannel0, uvmap/(100.0*scale) + Shift/100.0);\n\n    vec2 point = (floor(uv*100.0*scale)+0.5)/(100.0*scale);\n    ret.a = smoothstep(0.06*localscale, 0.0, distance(uv, point));\n    ret.a += 0.5 * pow(smoothstep(0.05*localscale, 0.0, distance(uv, point)), 30.0);\n    ret.a = pow(ret.a, 2.0+3.0*abs(sin(Time*1.0))) * (1.0-abs(sin(Time*1.0)));\n\n\n    ret.r = ret.a * smoothstep(0.77, 0.78, map.r);\n    ret.g = ret.a * smoothstep(0.77, 0.78, map.g);\n    ret.b = ret.a * smoothstep(0.77, 0.78, map.b);\n    \n    ret.rgb += 2.0 * ret.r * vec3(pow(smoothstep(0.05*localscale, 0.0, distance(uv, point)), 10.0) * (1.0-abs(sin(Time*1.0))));\n    ret.rgb += 2.0 * ret.g * vec3(pow(smoothstep(0.05*localscale, 0.0, distance(uv, point)), 10.0) * (1.0-abs(sin(Time*1.0))));\n    ret.rgb += 2.0 * ret.b * vec3(pow(smoothstep(0.05*localscale, 0.0, distance(uv, point)), 10.0) * (1.0-abs(sin(Time*1.0))));\n\n    return ret;\n}\n\n\n\nvec4 Rings(float scale, vec2 uv)\n{\n    vec4 ret = vec4(0);\n    float localscale = 1.0/(scale*10.0);\n    vec2 center = vec2(0.5, 0.5);\n    int d = int(abs(distance(uv, center)*100.0*scale-iTime));\n    ret.rgb = vec3(float(d%2));\n    return ret;\n}\n\nvec4 RingsRGB(float scale, vec2 uv)\n{\n    vec4 ret = vec4(0);\n    float localscale = 1.0/(scale*10.0);\n    \n    vec2 center = vec2(0.5, 0.5);\n    int d = int(abs(distance(uv, center)*100.0*scale-iTime));\n\n    vec2 uvmap = floor(uv*100.0*scale);\n    vec4 map = texture(iChannel0, vec2(float(d)/(200.0), (float(d)+Shift.x)/10.0));\n    ret.rgb = vec3(float(d%2)) * smoothstep(0.4,0.7,map.rgb);\n    return ret;\n}\n\nvec4 RingsCrazy(float scale, vec2 uv)\n{\n    vec4 ret = vec4(0);\n    float localscale = 1.0/(scale*10.0);\n    \n    vec2 center = vec2(0.5, 0.5);\n    int q = int(abs(distance(uv, center)*100.0*scale-iTime));\n    float d = fract(abs(distance(uv, center)*100.0*scale+iTime));\n\n    vec2 uvmap = floor(uv*100.0*scale);\n    vec4 map = texture(iChannel0, vec2(float(d)/(200.0*Time), float(d)/30.0));\n    ret.rgb = vec3(float(q%2)) * smoothstep(0.4,0.7,map.rgb);\n    return ret;\n}\n\nvec4 HoopsRGB(float scale, vec2 uv)\n{\n    vec4 ret = vec4(0);\n    float localscale = 1.0/(scale*10.0);\n    \n    vec2 center = vec2(0.5, 0.5);\n    int q = int(abs(distance(uv, center)*100.0*scale-iTime)-0.5 + Shift);\n    float d = abs(fract(abs(distance(uv, center)*100.0*scale-iTime))-0.5);\n\n    vec2 uvmap = floor(uv*100.0*scale);\n    vec4 map = texture(iChannel0, vec2(float(q)/(200.0), float(q)/30.0));\n    ret.a = pow(d,1.6);\n    ret.r = ret.a * smoothstep(0.51, 0.52, map.r);\n    ret.g = ret.a * smoothstep(0.51, 0.52, map.g);\n    ret.b = ret.a * smoothstep(0.51, 0.52, map.b);\n    \n    ret.rgb += 9.0 * ret.r * vec3(pow(smoothstep(0.0, 0.7*localscale, d), 10.0) * (1.0-abs(sin(Time*1.0))));\n    ret.rgb += 9.0 * ret.g * vec3(pow(smoothstep(0.0, 0.7*localscale, d), 10.0) * (1.0-abs(sin(Time*1.0))));\n    ret.rgb += 9.0 * ret.b * vec3(pow(smoothstep(0.0, 0.7*localscale, d), 10.0) * (1.0-abs(sin(Time*1.0))));\n    \n    return ret;\n}\n\n\nvec4 RingsBeat(float scale, vec2 uv)\n{\n    vec4 ret = vec4(0);\n    float localscale = 1.0/(scale*10.0);\n    \n    vec2 center = vec2(0.5, 0.5);\n    float d = distance(uv, center);\n    vec2 r = uv-center;\n\n    vec2 uvmap = r;\n    vec4 map = texture(iChannel0, vec2(float(d)/(10.0+50.0*Time), float(d)/30.0));\n    \n    ret.rgb = map.rgb;\n\n    return ret;\n}\n\nvec4 Rays(float scale, vec2 uv)\n{\n    vec4 ret = vec4(0);\n    float localscale = 1.0/(scale*10.0);\n    \n    vec2 center = vec2(0.5, 0.5);\n    float d = distance(uv, center);\n    vec2 r = normalize(uv-center);\n    r = r/10.0;\n    vec4 map = texture(iChannel0, r+Shift/10.0);\n    \n    float speed_r = iTime*0.1;\n    float fr = float(int(floor(abs(d+map.g-speed_r)*50.0*scale))%2);\n    ret.r = 1.0 * pow(smoothstep(0.8+d*0.2, 1.0, map.r), 1.0) * fract((d-speed_r)*50.0*scale) * fr;\n    float speed_g = iTime*0.3;\n    float fg = float(int(floor(abs(d+map.b-speed_g)*50.0*scale))%2);\n    ret.g = 1.0 * pow(smoothstep(0.8+d*0.2, 1.0, map.g), 1.0) * fract((d-speed_g)*50.0*scale) * fg;\n    float speed_b = iTime*0.5;\n    float fb = float(int(floor(abs(d+map.r-speed_b)*50.0*scale))%2);\n    ret.b = 1.0 * pow(smoothstep(0.8+d*0.2, 1.0, map.b), 1.0) * fract((d-speed_b)*50.0*scale) * fb;\n\n    ret.r += 0.05 * smoothstep(0.5, 1.0, map.r) * fr;\n    ret.g += 0.05 * smoothstep(0.5, 1.0, map.g) * fg;\n    ret.b += 0.05 * smoothstep(0.5, 1.0, map.b) * fb;\n\n    return ret;\n}\n\n\n\n\n\nvec4 Kale(float scale, vec2 uv)\n{\n    vec2 center = vec2(0.5, 0.5);\n    float d = distance(uv, center);\n    uv -= center;\n    uv.x *= 1.0+0.2*sin(1.0+iTime)*(1.0+d*2.0);\n    uv.y *= 1.0+0.2*sin(1.0+iTime)*(1.0+d*2.0);\n\n    vec4 ret = vec4(0);\n    float localscale = 1.0/(scale*10.0);\n    \n\n    vec4 map = texture(iChannel0, vec2(float(d)/(20.0+5.0*sin(iTime)), float(d)/10.0));\n\n    vec2 point = (floor(uv*100.0*scale)+0.5)/(100.0*scale);\n    float r = abs(cos(iTime))*0.08;\n    ret.a = 0.9 * smoothstep(r*localscale-0.04, r*localscale, distance(uv, point)) * smoothstep(r*localscale+0.04, r*localscale, distance(uv, point));\n    //ret.a = pow(ret.a, 2.0+3.0*abs(sin(Time*1.0))) * (1.0-abs(sin(Time*1.0)));\n\n\n    ret.rgb = normalize(map.rgb) * pow(ret.a, 5.0);// * smoothstep(0.17, 0.18, map.r);\n    \n    ret.rgb += 2.0 * ret.a * vec3(pow(smoothstep(r*localscale-0.003, r*localscale, distance(uv, point)), 5.0) * pow(smoothstep(r*localscale+0.003, r*localscale, distance(uv, point)), 5.0) * (1.0-abs(sin(Time*1.0))));\n\n    return ret;\n}\n\n\n\nvec4 Stars(float scale, vec2 uv)\n{\n    vec2 center = vec2(0.5, 0.5);\n    float d = distance(uv, center);\n    //uv -= center;\n    //uv.x *= 1.0+0.2*sin(1.0+iTime)*(1.0+d*2.0);\n    //uv.y *= 1.0+0.2*sin(1.0+iTime)*(1.0+d*2.0);\n\n    vec4 ret = vec4(0);\n    float localscale = 1.0/(scale*10.0);\n    \n\n    vec4 map = texture(iChannel0, vec2(float(d)/(20.0+5.0*sin(iTime)), float(d)/10.0));\n\n    vec2 point = (floor(uv*100.0*scale)+0.5)/(100.0*scale);\n    float r = 0.11;//abs(cos(iTime))*0.08;\n    ret.a = 2.0*smoothstep(r*localscale-0.04, r*localscale, distance(uv, point));\n    //ret.a = pow(ret.a, 2.0+3.0*abs(sin(Time*1.0))) * (1.0-abs(sin(Time*1.0)));\n\n\n    ret.rgb = normalize(map.rgb) * pow(ret.a, 3.0);// * smoothstep(0.17, 0.18, map.r);\n    \n    ret.rgb += 9.0 * ret.a * vec3(pow(smoothstep(r*localscale-0.04, r*localscale, distance(uv, point)), 3.0) * (1.0-abs(sin(Time*1.0))));\n\n    return ret;\n}\n\n\n\nvec4 KaleRand(float scale, vec2 uv)\n{\n    vec2 center = vec2(0.5, 0.5);\n    float d = distance(uv, center);\n    uv -= center;\n    uv.x *= 1.0+0.2*sin(1.0+iTime)*(1.0+d*2.0);\n    uv.y *= 1.0+0.2*sin(1.0+iTime)*(1.0+d*2.0);\n\n    vec4 ret = vec4(0);\n    float localscale = 1.0/(scale*10.0);\n    \n\n    vec4 map = texture(iChannel0, vec2(float(d)/(20.0+15.0*sin(iTime)), float(d)/10.0));\n\n    vec2 point = (floor(uv*100.0*scale)+0.5)/(100.0*scale);\n    float r = map.a*0.03;\n    ret.a = 0.96 * smoothstep(r*localscale-0.03, r*localscale, distance(uv, point)) * smoothstep(r*localscale+0.03, r*localscale, distance(uv, point));\n    //ret.a = pow(ret.a, 2.0+3.0*abs(sin(Time*1.0))) * (1.0-abs(sin(Time*1.0)));\n\n\n    ret.rgb = normalize(map.rgb) * pow(ret.a, 9.0);// * smoothstep(0.17, 0.18, map.r);\n    \n    ret.rgb += 1.0 * ret.a * vec3(pow(smoothstep(r*localscale-0.003, r*localscale, distance(uv, point)), 5.0) * pow(smoothstep(r*localscale+0.003, r*localscale, distance(uv, point)), 5.0) * (1.0-abs(sin(Time*1.0))));\n\n    return ret;\n}\n\n\n\n\nvec4 Ring(float scale, vec2 uv)\n{\n    vec4 ret = vec4(0);\n    float localscale = 1.0/(scale*10.0);\n    \n    vec2 center = vec2(0.5, 0.5);\n    int q = int(abs(distance(uv, center)*100.0*scale-iTime)-0.5 + Shift);\n    float d = abs(fract(abs(distance(uv, center)*100.0*scale-iTime))-0.5);\n\n    vec2 uvmap = floor(uv*100.0*scale);\n    vec4 map = texture(iChannel0, vec2(float(q)/(200.0), float(q)/30.0));\n    float r = 0.2;\n    ret.a = smoothstep(r-0.05, r, distance(uv, center)) * smoothstep(r+0.05, r, distance(uv, center));\n    ret.r = 0.5 * pow(ret.a, 3.0);// * smoothstep(0.51, 0.52, map.r);\n    //ret.g = ret.a * smoothstep(0.51, 0.52, map.g);\n    //ret.b = ret.a * smoothstep(0.51, 0.52, map.b);\n    \n    //ret.rgb += 9.0 * ret.r * vec3(pow(smoothstep(0.0, 0.7*localscale, d), 10.0) * (1.0-abs(sin(Time*1.0))));\n    //ret.rgb += 9.0 * ret.g * vec3(pow(smoothstep(0.0, 0.7*localscale, d), 10.0) * (1.0-abs(sin(Time*1.0))));\n    //ret.rgb += 9.0 * ret.b * vec3(pow(smoothstep(0.0, 0.7*localscale, d), 10.0) * (1.0-abs(sin(Time*1.0))));\n    \n    return ret;\n\n}\n\n\n\nvec4 Disco(float scale, vec2 uv)\n{\n    vec4 ret = vec4(0);\n    float localscale = 1.0/(scale*10.0);\n    \n    vec2 center = vec2(0.5, 0.5);\n    int q = int(abs(distance(uv, center)*100.0*scale-iTime)-0.5 + Shift);\n    float d = abs(fract(abs(distance(uv, center)*100.0*scale-iTime*0.1))-0.5);\n\n    vec2 uvmap = floor(uv*100.0*scale);\n    vec4 map = texture(iChannel0, vec2(float(q)/(200.0), float(q)/30.0));\n    float r = 0.1;\n    ret.a = smoothstep(r+0.002, r, distance(uv, center)) * smoothstep(r*0.1, r*0.1+0.002, distance(uv, center));\n    ret.a *= smoothstep(r*0.9, r*0.9-0.002, distance(uv, center)) + smoothstep(r*0.92, r*0.91+0.002, distance(uv, center));\n\n    vec4 text = texture(iChannel0, uv);\n\n    ret.rgb = ret.a * smoothstep(0.51, 0.52, vec3(1,0,1));\n    \n    ret.rgb -= 0.5*text.r * smoothstep(r*0.6+0.02, r*0.6, distance(uv, center)) * smoothstep(r*0.3, r*0.3+0.02, distance(uv, center));\n\n    float rides = smoothstep(-0.9, -0.8, sin(distance(uv, center)*130.0)) * smoothstep(r*1.3, r*1.3+0.002, distance(uv, center));\n    rides *= sin(d*160.0);\n    //rides += smoothstep(0.01,0.0,sin((distance(uv, center)-iTime*0.02)*200.0)) * smoothstep(r*1.0, r*1.0+0.002, distance(uv, center)) * smoothstep(r*1.3+0.002, r*1.3, distance(uv, center));\n    \n    float hl = smoothstep(-0.3, 0.0, normalize(uv-center).x) * smoothstep(0.3, 0.0, normalize(uv-center).x);\n    ret += rides * (0.1 + 0.2*pow(hl,2.0) + 0.3*pow(hl,9.0));\n    \n    return ret;\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    Time = fract((iTime*10.0)/6.28);\n    Shift = vec2(floor((iTime*10.0)/6.28), floor((iTime*10.0)/6.28));\n\n    vec4 col = vec4(0.0);\n    \n    //vec4 col = Dots(0.2, uv);\n    //col = Panels(0.2, uv);\n    //vec4 col = Lamps(0.2, uv);\n    //vec4 col = Rings(0.1, uv);\n    //vec4 col = RingsRGB(0.1, uv);\n    //vec4 col = HoopsRGB(0.1, uv);\n    //vec4 col = Rays(0.1, uv);\n    col = Kale(0.1, uv);\n    //col *= Kale(0.2, uv);\n    //col *= Kale(0.4, uv);\n    //col = HoopsRGB(0.1, uv);\n    //col = Stars(0.2, uv);\n    //col = KaleRand(0.2, uv);\n    //col = Ring(0.1, uv);\n    //col = Disco(0.1, uv);\n    \n\n\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}