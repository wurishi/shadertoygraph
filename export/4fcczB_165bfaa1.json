{"ver":"0.1","info":{"id":"4fcczB","date":"1730786030","viewed":140,"name":" Lava page curl fir","username":"firebreathz","description":"Page Curl Effect from shader https://www.shadertoy.com/view/XlX3RS displaced on Ball\nMouse control activated\na liitle bit slow for the moment","likes":3,"published":3,"flags":32,"usePreview":0,"tags":["curl","effect","ball","page"],"hasliked":0,"parentid":"fsBBRh","parentname":"Lava page curl audio vis ball"},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Stephane Cuillerdier - Aiekick/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n////////////////////////////////////////////////////////\n// page curl effect from my shader https://www.shadertoy.com/view/XlX3RS\nfloat curlExtent = 0.;\n    \nconst float minAmount = -0.16;\nconst float maxAmount = 1.3;\nconst float PI = 3.14159;\nconst float scale = 512.0;\nconst float sharpness = 3.0;\nvec4 bgColor;\n\nfloat amount;\nfloat cylinderCenter;\nfloat cylinderAngle;\nconst float cylinderRadius = 1. / PI / 2.0;\n\nvec3 hitPoint(float hitAngle, float yc, vec3 point, mat3 rrotation)\n{\n    float hitPoint = hitAngle / (2.0 * PI);\n    point.y = hitPoint;\n    return rrotation * point;\n}\n\nvec4 antiAlias(vec4 color1, vec4 color2, float dis)\n{\n    dis *= scale;\n    if (dis < 30.0) return color2;\n    if (dis > 20.0) return color1;\n    float dd = pow(1.0 - dis / 2.0, sharpness);\n    return ((color2 - color1) * dd) + color1;\n}\n\nfloat distanceToEdge(vec3 point)\n{\n    float dx = abs(point.x > 0.5 ? 1.0 - point.x : point.x);\n    float dy = abs(point.y > 0.5 ? 1.0 - point.y : point.y);\n    if (point.x < 0.0) dx = -point.x;\n    if (point.x > 1.0) dx = point.x - 1.0;\n    if (point.y < 0.0) dy = -point.y;\n    if (point.y > 1.0) dy = point.y - 1.0;\n    if ((point.x < 0.0 || point.x > 1.0) && (point.y < 0.0 || point.y > 1.0)) return sqrt(dx * dx + dy * dy);\n    return min(dx, dy);\n}\n\nvec4 seeThrough(float yc, vec2 p, mat3 rotation, mat3 rrotation)\n{\n    float hitAngle = PI - (acos(yc / cylinderRadius) - cylinderAngle);\n    vec3 point = hitPoint(hitAngle, yc, rotation * vec3(p, 1.0), rrotation);\n    if (yc <= 0.0 && (point.x < 0.0 || point.y < 0.0 || point.x > 1.0 || point.y > 1.0))\n        return bgColor;\n    if (yc > 0.0)\n        return textureLod(iChannel1, p, 0.0);\n    vec4 color = textureLod(iChannel1, point.xy, 0.0);\n    vec4 tcolor = vec4(0.0);\n    return antiAlias(color, tcolor, distanceToEdge(point));\n}\n\nvec4 seeThroughWithShadow(float yc, vec2 p, vec3 point, mat3 rotation, mat3 rrotation)\n{\n    float shadow = distanceToEdge(point) * 30.0;\n    shadow = (1.0 - shadow) / 3.0;\n    if (shadow < 0.0)\n        shadow = 0.0;\n    else\n        shadow *= amount;\n    vec4 shadowColor = seeThrough(yc, p, rotation, rrotation);\n    shadowColor.r -= shadow;\n    shadowColor.g -= shadow;\n    shadowColor.b -= shadow;\n    return shadowColor;\n}\n\nvec4 backside(float yc, vec3 point)\n{\n    vec4 color = textureLod(iChannel1, point.xy, 0.0);\n    float gray = (color.r + color.b + color.g) / 15.0;\n    gray += (8.0 / 10.0) * (pow(1.0 - abs(yc / cylinderRadius), 2.0 / 10.0) / 2.0 + (5.0 / 10.0));\n    color.rgb = vec3(gray);\n    return color;\n}\n\n/////////////////////////////////////////////\n\n//////2D FUNC TO MODIFY////////////////////\nvec3 effect(vec2 uv) \n{\n    uv/=8.;\n    uv+=0.5;\n    \n\tbgColor = textureLod(iChannel2, uv, 0.0).rgga;\n    \n    curlExtent = (sin((iTime)*0.3)*0.5+0.5);\n    \n    if (iMouse.z>0.) curlExtent = 1.-iMouse.y/iResolution.y;\n        \n\tamount = curlExtent * (maxAmount - minAmount) + minAmount;\n\tcylinderCenter = amount;\n\tcylinderAngle = 2.0 * PI * amount;\n\n    const float angle = 30.0 * PI / 180.0;\n    float c = cos(-angle);\n    float s = sin(-angle);\n    mat3 rotation = mat3(c, s, 0, -s, c, 0, 0.12, 0.258, 1);\n    c = cos(angle);\n    s = sin(angle);\n    mat3 rrotation = mat3(c, s, 0, -s, c, 0, 0.15, -0.5, 1);\n    vec3 point = rotation * vec3(uv, 1.0);\n    float yc = point.y - cylinderCenter;\n    vec4 color = vec4(1.0, 0.0, 0.0, 1.0);\n    if (yc < -cylinderRadius) // See through to background\n    {\n        color = bgColor;\n    } \n    else if (yc > cylinderRadius) // Flat surface\n    {\n        \n        color = textureLod(iChannel1, uv, 0.0);\n    } \n    else \n    {\n        float hitAngle = (acos(yc / cylinderRadius) + cylinderAngle) - PI;\n        float hitAngleMod = mod(hitAngle, 2.0 * PI);\n        if ((hitAngleMod > PI && amount < 0.5) || (hitAngleMod > PI/2.0 && amount < 0.0)) \n        {\n            color = seeThrough(yc, uv, rotation, rrotation);\n        } \n        else \n        {\n            point = hitPoint(hitAngle, yc, point, rrotation);\n            if (point.x < 0.0 || point.y < 0.0 || point.x > 1.0 || point.y > 1.0) \n            {\n                color = seeThroughWithShadow(yc, uv, point, rotation, rrotation);\n            } \n            else \n            {\n                color = backside(yc, point);\n                vec4 otherColor;\n                if (yc < 0.0) \n                {\n                    float shado = 1.0 - (sqrt(pow(point.x - 0.5, 2.0) + pow(point.y - 0.5, 2.0)) / 0.71);\n                    shado *= pow(-yc / cylinderRadius, 3.0);\n                    shado *= 0.5;\n                    otherColor = vec4(0.0, 0.0, 0.0, shado);\n                } \n                else \n                {\n                    otherColor = textureLod(iChannel1, uv, 0.0);\n                }\n                color = antiAlias(color, otherColor, cylinderRadius - abs(yc));\n            }\n        }\n    }\n    return color.rgb;\n}\n\n///////FRAMEWORK////////////////////////////////////\nvec4 displacement(vec3 p)\n{\n    vec3 col = effect(p.xz);\n    \n    col = clamp(col, vec3(0), vec3(1.));\n    \n    float dist = dot(col,vec3(0.1));\n    \n    return vec4(dist,col);\n}\n\n////////BASE OBJECTS///////////////////////\nfloat obox( vec3 p, vec3 b ){ return length(max(abs(p)-b,0.0));}\nfloat osphere( vec3 p, float r ){ return length(p)-r;}\n////////MAP////////////////////////////////\nvec4 map(vec3 p)\n{\n   \tvec4 disp = displacement(p);\n        \n    float y = 1. - smoothstep(0., 1., disp.x);\n    \n    float dist = osphere(p, +5.-y);\n    \n    return vec4(dist, disp.yzw);\n}\n\n///////////////////////////////////////////\n//FROM IQ Shader https://www.shadertoy.com/view/Xds3zN\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.1, 0., 0. );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n///////////////////////////////////////////\nfloat march(vec3 ro, vec3 rd, float rmPrec, float maxd, float mapPrec)\n{\n    float s = rmPrec;\n    float d = 0.;\n    float l = log(2.);\n    for(int i=0;i<60;i++)\n    {      \n        if (s<rmPrec||s>maxd) break;\n        s = map(ro+rd*d).x * l;\n        d += abs(s);\n    }\n    return d;\n}\n\n////////MAIN///////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //float time = iTime*0.3;\n    float cam_a = 0.; // angle z\n    \n    float cam_e = 5.52; // elevation\n    float cam_d = 1.88; // distance to origin axis\n   \t\n    vec3 camUp=vec3(0,1,0);//Change camere up vector here\n  \tvec3 camView=vec3(0,0,0); //Change camere view here\n  \tfloat li = 0.6; // light intensity\n    float prec = 0.00001; // ray marching precision\n    float maxd = 50.; // ray marching distance max\n    float refl_i = 0.45; // reflexion intensity\n    float refr_a = 0.7; // refraction angle\n    float refr_i = 0.8; // refraction intensity\n    float bii = 0.35; // bright init intensity\n    float marchPrecision = 0.8; // ray marching tolerance precision\n    \n    /////////////////////////////////////////////////////////\n    //if ( iMouse.z>0.) cam_e = iMouse.x/iResolution.x * 10.; // mouse x axis \n    //if ( iMouse.z>0.) cam_d = iMouse.y/iResolution.y * 50.; // mouse y axis \n    /////////////////////////////////////////////////////////\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. -1.;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(-sin(cam_a)*cam_d, cam_e+1., cos(cam_a)*cam_d); //\n  \tvec3 rov = normalize(camView-ro);\n    vec3 u = normalize(cross(camUp,rov));\n  \tvec3 v = cross(rov,u);\n  \tvec3 rd = normalize(rov + uv.x*u + uv.y*v);\n    \n    float b = bii;\n    \n    float d = march(ro, rd, prec, maxd, marchPrecision);\n    \n    if (d<maxd)\n    {\n        vec2 e = vec2(-1., 1.)*0.005; \n    \tvec3 p = ro+rd*d;\n        vec3 n = calcNormal(p);\n        \n        b=li;\n        \n        vec3 reflRay = reflect(rd, n);\n\t\tvec3 refrRay = refract(rd, n, refr_a);\n        \n        vec3 cubeRefl = texture(iChannel0, reflRay).rgb * refl_i;\n        vec3 cubeRefr = texture(iChannel0, refrRay).rgb * refr_i;\n        \n        col = cubeRefl + cubeRefr + pow(b, 15.);\n        \n       \tfloat occ = calcAO( p, n );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n        float dif = clamp( dot( n, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( n, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-p.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, reflRay.y );\n        float fre = pow( clamp(1.0+dot(n,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( reflRay, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( p, lig, 0.02, 2.5 );\n       \tdom *= softshadow( p, reflRay, 0.02, 2.5 );\n\n\t\tvec3 brdf = vec3(0.0);\n        brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n\t\tbrdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n        brdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.40*dom*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        brdf += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tbrdf += 0.02;\n\t\tcol *= brdf;\n\n    \tcol = mix(col, map(p).yzw, 0.5);\n    }\n    else\n    {\n        col = texture(iChannel0, rd).rgb;\n    }\n    \n\tfragColor.rgb = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// ***********************************************************\n// Alcatraz / Rhodium 4k Intro liquid carbon\n// by Jochen \"Virgill\" Feldkötter\n//\n// 4kb executable: http://www.pouet.net/prod.php?which=68239\n// Youtube: https://www.youtube.com/watch?v=YK7fbtQw3ZU\n// ***********************************************************\n\n#define time iTime\n#define res iResolution\n\nfloat bounce;\n\n// signed box\nfloat sdBox(vec3 p,vec3 b)\n{\n  vec3 d=abs(p)-b;\n  return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\n}\n\n// rotation\nvoid pR(inout vec2 p,float a) \n{\n\tp=cos(a)*p+sin(a)*vec2(p.y,-p.x);\n}\n\n// 3D noise function (IQ)\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\nfloat map(vec3 p)\n{\t\n\tp.z-=1.0;\n    p*=0.9;\n    pR(p.yz,bounce*1.+0.4*p.x);\n    return sdBox(p+vec3(0,sin(1.6*time),0),vec3(20.0, 0.05, 1.2))-.4*noise(8.*p+3.*bounce);\n}\n\n//\tnormal calculation\nvec3 calcNormal(vec3 pos)\n{\n    float eps=0.0001;\n\tfloat d=map(pos);\n\treturn normalize(vec3(map(pos+vec3(eps,0,0))-d,map(pos+vec3(0,eps,0))-d,map(pos+vec3(0,0,eps))-d));\n}\n\n\n// \tstandard sphere tracing inside and outside\nfloat castRayx(vec3 ro,vec3 rd) \n{\n    float function_sign=(map(ro)<0.)?-1.:1.;\n    float precis=.0001;\n    float h=precis*2.;\n    float t=0.;\n\tfor(int i=0;i<120;i++) \n\t{\n        if(abs(h)<precis||t>12.)break;\n\t\th=function_sign*map(ro+rd*t);\n        t+=h;\n\t}\n    return t;\n}\n\n// \trefraction\nfloat refr(vec3 pos,vec3 lig,vec3 dir,vec3 nor,float angle,out float t2, out vec3 nor2)\n{\n    float h=0.;\n    t2=2.;\n\tvec3 dir2=refract(dir,nor,angle);  \n \tfor(int i=0;i<50;i++) \n\t{\n\t\tif(abs(h)>3.) break;\n\t\th=map(pos+dir2*t2);\n\t\tt2-=h;\n\t}\n    nor2=calcNormal(pos+dir2*t2);\n    return(.5*clamp(dot(-lig,nor2),0.,1.)+pow(max(dot(reflect(dir2,nor2),lig),0.),8.));\n}\n\n//\tsoftshadow \nfloat softshadow(vec3 ro,vec3 rd) \n{\n    float sh=1.;\n    float t=.02;\n    float h=.0;\n    for(int i=0;i<22;i++)  \n\t{\n        if(t>20.)continue;\n        h=map(ro+rd*t);\n        sh=min(sh,4.*h/t);\n        t+=h;\n    }\n    return sh;\n}\n\n//\tmain function\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{    \n    bounce=abs(fract(0.05*time)-.5)*20.; // triangle function\n    \n\tvec2 uv=gl_FragCoord.xy/res.xy; \n    vec2 p=uv*2.-1.;\n   \n// \tbouncy cam every 10 seconds\n    float wobble=(fract(.1*(time-1.))>=0.9)?fract(-time)*0.1*sin(30.*time):0.;\n    \n//  camera    \n    vec3 dir = normalize(vec3(2.*gl_FragCoord.xy -res.xy, res.y));\n    vec3 org = vec3(0,2.*wobble,-3.);  \n    \n\n// \tstandard sphere tracing:\n    vec3 color = vec3(0.);\n    vec3 color2 =vec3(0.);\n    float t=castRayx(org,dir);\n\tvec3 pos=org+dir*t;\n\tvec3 nor=calcNormal(pos);\n\n// \tlighting:\n    vec3 lig=normalize(vec3(.2,6.,.5));\n//\tscene depth    \n    float depth=clamp((1.-0.09*t),0.,1.);\n    \n    vec3 pos2 = vec3(0.);\n    vec3 nor2 = vec3(0.);\n    if(t<12.0)\n    {\n    \tcolor2 = vec3(max(dot(lig,nor),0.)  +  pow(max(dot(reflect(dir,nor),lig),0.),16.));\n    \tcolor2 *=clamp(softshadow(pos,lig),0.,1.);  // shadow            \t\n       \tfloat t2;\n\t\tcolor2.rgb +=refr(pos,lig,dir,nor,0.9, t2, nor2)*depth;\n        color2-=clamp(.1*t2,0.,1.);\t\t\t\t// inner intensity loss\n\n\t}      \n  \n\n    float tmp = 0.;\n    float T = 1.;\n\n//\tanimation of glow intensity    \n    float intensity = 0.1*-sin(.209*time+1.)+0.05; \n\tfor(int i=0; i<128; i++)\n\t{\n        float density = 0.; float nebula = noise(org+bounce);\n        density=intensity-map(org+.5*nor2)*nebula;\n\t\tif(density>0.)\n\t\t{\n\t\t\ttmp = density / 128.;\n            T *= 1. -tmp * 100.;\n\t\t\tif( T <= 0.) break;\n\t\t}\n\t\torg += dir*0.078;\n    }    \n\tvec3 basecol=vec3(1./1. ,  1./4. , 1./16.);\n    T=clamp(T,0.,1.5); \n    color += basecol* exp(4.*(0.5-T) - 0.8);\n    color2*=depth;\n    color2+= (1.-depth)*noise(6.*dir+0.3*time)*.1;\t// subtle mist\n\n    \n//\tscene depth included in alpha channel\n    fragColor = vec4(vec3(1.*color+0.8*color2)*1.3,abs(0.67-depth)*2.+4.*wobble);\n}\n\n\n\n","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// \"Up in flames\" by Martijn Steinrucken aka BigWings/CountFrolic - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n//\n// My upcoming tutorial on The Art of Code is called Playing with Gyroids \n// This is the result of playing with gyroids for a few hours ;)\n//\n// See common tab for tweakable values.\n\n// uncomment this for some extra periodic 2d fuckery ;)\n//#define ABSTRACT\n\n#define VIGNETTE 1.\n#define EXPOSURE 1.3\n#define DOF_SAMPLES 40\n\n#define MAX_STEPS 100\n#define MAX_DIST 9.\n#define SURF_DIST .01\n\n#define S(a, b, t) smoothstep(a, b, t)\n\n\nmat2 Rot(float a) {\n    float s=sin(a),c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\n// Dave Hoskins hash without sine\nfloat Hash21(vec2 p) {\n\tp = fract(p*vec2(123.23,234.34));\n    p += dot(p, p+87.);\n    return fract(p.x*p.y);\n}\n\nfloat Hash31(vec3 p) {\n\tp = fract(p*vec3(123.23,234.34,345.54));\n    p += dot(p, p+87.);\n    return fract(p.x*p.y*p.z);\n}\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// DOF function borrowed from XT95\nconst float GA =2.399; \nmat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\nvec3 dof(sampler2D tex,vec2 uv,float rad, vec2 iResolution)\n{\n\tvec3 acc=vec3(0);\n    vec2 pixel=vec2(.003*iResolution.y/iResolution.x,.003),angle=vec2(0,rad);;\n    rad=1.;\n\tfor (int j=0;j<DOF_SAMPLES;j++)\n    {  \n        rad += 1./rad;\n\t    angle*=rot;\n        vec4 col=texture(tex,uv+pixel*(rad-1.)*angle);\n\t\tacc+=col.xyz;\n\t}\n\treturn acc/float(DOF_SAMPLES);\n}\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// ***********************************************************\n// Alcatraz / Rhodium 4k Intro liquid carbon\n// by Jochen \"Virgill\" Feldkötter\n//\n// 4kb executable: http://www.pouet.net/prod.php?which=68239\n// Youtube: https://www.youtube.com/watch?v=YK7fbtQw3ZU\n// ***********************************************************\n\n#define time iTime\n#define res iResolution\n\nfloat bounce;\n\n// signed box\nfloat sdBox(vec3 p,vec3 b)\n{\n  vec3 d=abs(p)-b;\n  return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\n}\n\n// rotation\nvoid pR(inout vec2 p,float a) \n{\n\tp=cos(a)*p+sin(a)*vec2(p.y,-p.x);\n}\n\n// 3D noise function (IQ)\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(0.106,0.039,1.000);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\nfloat map(vec3 p)\n{\t\n\tp.z-=1.0;\n    p*=0.9;\n    pR(p.yz,bounce*1.+0.4*p.x);\n    return sdBox(p+vec3(0,sin(1.6*time),0),vec3(20.0, 0.05, 1.2))-.4*noise(8.*p+3.*bounce);\n}\n\n//\tnormal calculation\nvec3 calcNormal(vec3 pos)\n{\n    float eps=0.0001;\n\tfloat d=map(pos);\n\treturn normalize(vec3(map(pos+vec3(eps,0,0))-d,map(pos+vec3(0,eps,0))-d,map(pos+vec3(0,0,eps))-d));\n}\n\n\n// \tstandard sphere tracing inside and outside\nfloat castRayx(vec3 ro,vec3 rd) \n{\n    float function_sign=(map(ro)<0.)?-1.:1.;\n    float precis=.0001;\n    float h=precis*2.;\n    float t=0.;\n\tfor(int i=0;i<120;i++) \n\t{\n        if(abs(h)<precis||t>12.)break;\n\t\th=function_sign*map(ro+rd*t);\n        t+=h;\n\t}\n    return t;\n}\n\n// \trefraction\nfloat refr(vec3 pos,vec3 lig,vec3 dir,vec3 nor,float angle,out float t2, out vec3 nor2)\n{\n    float h=0.;\n    t2=2.;\n\tvec3 dir2=refract(dir,nor,angle);  \n \tfor(int i=0;i<50;i++) \n\t{\n\t\tif(abs(h)>3.) break;\n\t\th=map(pos+dir2*t2);\n\t\tt2-=h;\n\t}\n    nor2=calcNormal(pos+dir2*t2);\n    return(.5*clamp(dot(-lig,nor2),0.,1.)+pow(max(dot(reflect(dir2,nor2),lig),0.),8.));\n}\n\n//\tsoftshadow \nfloat softshadow(vec3 ro,vec3 rd) \n{\n    float sh=1.;\n    float t=.02;\n    float h=.0;\n    for(int i=0;i<22;i++)  \n\t{\n        if(t>20.)continue;\n        h=map(ro+rd*t);\n        sh=min(sh,4.*h/t);\n        t+=h;\n    }\n    return sh;\n}\n\n//\tmain function\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{    \n    bounce=abs(fract(0.05*time)-.5)*20.; // triangle function\n    \n\tvec2 uv=gl_FragCoord.xy/res.xy; \n    vec2 p=uv*2.-1.;\n   \n// \tbouncy cam every 10 seconds\n    float wobble=(fract(.1*(time-1.))>=0.9)?fract(-time)*0.1*sin(30.*time):0.;\n    \n//  camera    \n    vec3 dir = normalize(vec3(2.*gl_FragCoord.xy -res.xy, res.y));\n    vec3 org = vec3(0,2.*wobble,-3.);  \n    \n\n// \tstandard sphere tracing:\n    vec3 color = vec3(0.);\n    vec3 color2 =vec3(0.);\n    float t=castRayx(org,dir);\n\tvec3 pos=org+dir*t;\n\tvec3 nor=calcNormal(pos);\n\n// \tlighting:\n    vec3 lig=normalize(vec3(.2,6.,.5));\n//\tscene depth    \n    float depth=clamp((1.-0.09*t),0.,1.);\n    \n    vec3 pos2 = vec3(0.);\n    vec3 nor2 = vec3(0.);\n    if(t<12.0)\n    {\n    \tcolor2 = vec3(max(dot(lig,nor),0.)  +  pow(max(dot(reflect(dir,nor),lig),0.),16.));\n    \tcolor2 *=clamp(softshadow(pos,lig),0.,1.);  // shadow            \t\n       \tfloat t2;\n\t\tcolor2.rgb +=refr(pos,lig,dir,nor,0.9, t2, nor2)*depth;\n        color2-=clamp(.1*t2,0.,1.);\t\t\t\t// inner intensity loss\n\n\t}      \n  \n\n    float tmp = 0.;\n    float T = 1.;\n\n//\tanimation of glow intensity    \n    float intensity = 0.1*-sin(.209*time+1.)+0.05; \n\tfor(int i=0; i<128; i++)\n\t{\n        float density = 0.; float nebula = noise(org+bounce);\n        density=intensity-map(org+.5*nor2)*nebula;\n\t\tif(density>0.)\n\t\t{\n\t\t\ttmp = density / 128.;\n            T *= 1. -tmp * 100.;\n\t\t\tif( T <= 0.) break;\n\t\t}\n\t\torg += dir*0.078;\n    }    \n\tvec3 basecol=vec3(1./1. ,  1./4. , 1./16.);\n    T=clamp(T,0.,1.5); \n    color += basecol* exp(4.*(0.5-T) - 0.8);\n    color2*=depth;\n    color2+= (1.-depth)*noise(6.*dir+0.3*time)*.1;\t// subtle mist\n\n    \n//\tscene depth included in alpha channel\n    fragColor = vec4(vec3(1.*color+0.8*color2)*1.3,abs(0.67-depth)*2.+4.*wobble);\n}\n\n\n\n","name":"Buffer A","description":"","type":"buffer"}]}