{"ver":"0.1","info":{"id":"Dd2SD3","date":"1671020494","viewed":135,"name":"Ray Marching v1","username":"thom_bahm","description":"Part 1 of a ray marching tutorial http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n^Expanded on part 1 from that series.\n(commented heavily to explain and test my understanding) - Feedback Welcome!","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"llt3R4","parentname":"Ray Marching: Part 1"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.01;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\n \n//positions stored in sph.xyz, radius stored in sph.w\nvec4 sph = vec4(0.0,1.0,0.0,1.0);\n// SDF = sqrt(P^2-C^2)-r^2\n// where P is the point to check, C = center of sphere\nfloat sphereSDF(vec3 samplePoint) {\n    return length(samplePoint-sph.xyz) - sph.w;\n}\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n//plane is just the y (bottom-to-top) value of any point.\nfloat planeSDF(vec3 samplePoint) {\n    return samplePoint.y;\n}\nfloat sceneSDF(vec3 samplePoint) {\n    //return sphereSDF(samplePoint);\n    return min(sphereSDF(samplePoint),planeSDF(samplePoint));\n}\n\nvec3 estimateNormal(vec3 p) {\n    //using gradient of sdf by sampling points on the sphere and comparing their difference\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the eye to march before giving up\n */\n //Shortest distance to surface\nfloat rayMarch(vec3 eye, vec3 marchingDirection) {\n    float depth = MIN_DIST;    \n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        //depth is the position of the current marching step\n        vec3 pos = eye + depth * marchingDirection; //pos(depth)=origin+(depth*dir)\n        //find the distance from the current point along the marching ray to the scene\n        float dist = sceneSDF(pos);\n        //increment the depth (location along marching ray) until it has passed the MAX_DIST (end of scene)\n        depth += dist;\n        if (depth > MAX_DIST || depth < EPSILON) { break; }\n    }\n    return depth;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float fov = 45.0;\n    //create ray direction\n    vec2 uv = fragCoord - iResolution.xy / 2.0;\n    float z = iResolution.y / tan(radians(fov)/2.0);\n    vec3 dir = normalize(vec3(uv, -z));\n    //eye represents the ray's origin\n    vec3 eye = vec3(0.0, 1.0, 10.0);\n    float dist = rayMarch(eye, dir); //find distance to scene\n    vec3 col = vec3(0.0);\n    vec3 lightPos = vec3(0, 4, 0);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n\n    //lighting calculations\n    vec3 p_t = eye + dir*dist; //point along ray being marched\n    vec3 light = normalize(lightPos - p_t); //normalize lightPos-pos on scene.\n    vec3 normal = estimateNormal(p_t); //normal of (sphere)\n    float dif = dot(normal, light); //lighting more intense when normal pointing at light\n    \n    //following code (sort of)from [TUT] RayMarching for Dummies!: https://www.shadertoy.com/view/XlGBW3\n    \n    //shadows: raymarch from a point towards the light source.\n    float pointToSun = rayMarch(p_t, light);\n    //one way of doing it (basically if the ray shot from\n    //the point towards sun never intersects a surface, make the point dark)\n    //if (pointToSun < MAX_DIST) dif = 0.;\n    // other way: if the ray from point to sun get's intersected by the sphere\n    if (pointToSun<length(lightPos-p_t)) dif *= 0.1*pointToSun;\n    col = vec3(dif);\n    // gamma correction: (BigWIngs TUT)\n    col = pow(col, vec3(.4545));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}