{"ver":"0.1","info":{"id":"ctjGRD","date":"1673374597","viewed":208,"name":"Perspective Packing","username":"rory618","description":"Idea from reddit user /u/tasty_plots","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["reproduction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_SPHERES 200\n\nfloat seed = 0.;\nfloat rand() { return fract(sin(seed++)*43758.5453123); }\n\nstruct Ray { vec3 o, d; };\nstruct Sphere {\n\tfloat r;\n\tvec3 p, c;\n};\n\nSphere getSphere(int i){\n    ivec3 xyface = ivec3(i%1024,i/1024,1);\n    vec4 d = texture(iChannel0, XYFaceToRayDir(xyface));\n    vec3 c = vec3(1.,0,0)+vec3(-1,1,1)*texture(iChannel1,  fract(d.xy+d.z*100.)).xyz;\n    float p = 3.14159/2.* ( smoothstep(0.,2.,mod(iTime,4.)) + floor(iTime/4.)   );\n    float y = 3.14159/2.* ( smoothstep(0.,2.,mod(iTime+2.,4.)) + floor((iTime+2.)/4.)   );\n    d.xyz -= 512.;\n    d.yz = mat2(d.yz,-d.z,d.y) * vec2(cos(p), sin(p));\n\n    d.xz = mat2(d.xz,-d.z,d.x) * vec2(cos(y), sin(y));\n    return Sphere(d.w*0.01, vec3(d.xyz)*.01, c) ;\n    \n}\n\nfloat intersect(Sphere s, Ray r) {\n\tvec3 op = s.p - r.o;\n\tfloat t, epsilon = 1e-3, b = dot(op, r.d), det = b * b - dot(op, op) + s.r * s.r;\n\tif (det < 0.) return 0.; else det = sqrt(det);\n\treturn (t = b - det) > epsilon ? t : ((t = b + det) > epsilon ? t : 0.);\n}\n\nint intersect(Ray r, out float t, out Sphere s, int avoid) {\n\tint id = -1;\n\tt = 1e5;\n    s = getSphere(0);\n    \n\tfor (int i = 0; i < NUM_SPHERES; ++i) {\n\t\tSphere S = getSphere(i);\n\t\tfloat d = intersect(S, r);\n\t\tif (i!=avoid && d!=0. && d<t) { t = d; id = i; s=S; }\n\t}\n\treturn id;\n}\n\nvec3 shade(vec3 p, vec3 c, vec3 n, int v){\n    vec3 sd = normalize(vec3(1,3,4));\n    Ray l = Ray(p, sd);\n    float t;\n\tSphere obj;\n    int id;\n    if ((id = intersect(l, t, obj, v)) < 0){\n        return vec3(c*(dot(n,sd)+.2));\n    } else {\n        return vec3(c*dot(n,sd))/2.;\n    }\n}\n\n\nvec3 scene(Ray r){\n\tfloat t;\n\tSphere obj;\n    int id;\n    if ((id = intersect(r, t, obj, id)) < 0){\n        return vec3(0);\n    } else {\n        \n        vec3 h = r.o + r.d*t;\n        vec3 n = normalize(h-obj.p);\n        \n        \n    \n        return shade(h,obj.c,n,id);\n    }\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 I ) {\n    seed = iTime + iResolution.y * I.x / iResolution.x + I.y / iResolution.y;\n    vec3 r0 = vec3((I-R.xy/2.)/R.y*10.,10);\n    vec3 rd = vec3(0,0,-1);\n    rd /= length(rd);\n    r0 *= 2.;\n    \n    vec3 color = scene(Ray(r0, rd ));\n\tfragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"//SDF of spheres projected along x, y, and z\nvec3 multiProjectSphereSD(vec2 coord,  vec3 sphere, float r){\n    return vec3(\n        length(coord-sphere.xy)-r,\n        length(coord-sphere.yz)-r,\n        length(coord-sphere.zx)-r\n    );\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    ivec3 XYFace = RayDirToXYFace(rayDir);\n    vec2 c = vec2(XYFace.xy);\n    \n    // Output to cubemap\n    fragColor = texture(iChannel0, XYFaceToRayDir(XYFace));\n    int cnt = int( texture(iChannel0, XYFaceToRayDir(ivec3(1,1,2))).x);\n    if(iFrame<10){\n        if(XYFace.z==0){\n            fragColor.xyz = vec3(min(min(XYFace.x,XYFace.y),min(1023-XYFace.x,1023-XYFace.y)));\n        } else {\n            fragColor = vec4(0);\n        }\n    } else {\n        //Check 5 locations \n        for(int i=0;i<10;i++){\n            vec3 sph = rand3(IHash(iFrame*50+i))*1024.;\n            float da = texture(iChannel0, XYFaceToRayDir( ivec3(sph.xy,0)   )).x;\n            float db = texture(iChannel0, XYFaceToRayDir( ivec3(sph.yz,0)   )).y;\n            float dc = texture(iChannel0, XYFaceToRayDir( ivec3(sph.zx,0)   )).z;\n            float r = min(min(da,db),dc);\n            if(r>20.){\n                if(XYFace.z==0){\n                        fragColor.xyz = min(fragColor.xyz ,multiProjectSphereSD(c, sph,r));//Update SDFs in face #0\n                } else if(XYFace.z== 1){ //Store the found sphere in face #1\n                    if(cnt==XYFace.x+XYFace.y*1024){\n                        fragColor = vec4(sph,r);\n                    }\n                } else if(XYFace.z==2){ //Store number of found spheres in face #2\n                    fragColor+=1.;\n                }\n                \n                break;\n            }\n        }\n    }\n}","name":"Cube A","description":"","type":"cubemap"},{"inputs":[],"outputs":[],"code":"#define R iResolution\nint IHash(int a){\n\ta = (a ^ 61) ^ (a >> 16);\n\ta = a + (a << 3);\n\ta = a ^ (a >> 4);\n\ta = a * 0x27d4eb2d;\n\ta = a ^ (a >> 15);\n\treturn a;\n}\n\nfloat Hash(int a){\n\treturn float(IHash(a)) / float(0x7FFFFFFF);\n}\nvec4 rand4(int seed){\n    return vec4(Hash(seed^0x34F85A93),\n                Hash(seed^0x85FB93D5),\n                Hash(seed^0x6253DF84),\n                Hash(seed^0x25FC3625));\n}\nvec3 rand3(int seed){\n    return vec3(Hash(seed^0x348CD593),\n                Hash(seed^0x8593FD5),\n                Hash(seed^0x62A5D384));\n}\nvec2 rand2(int seed){\n    return vec2(Hash(seed^0x348C5F93),\n                Hash(seed^0x8593D5BB));\n}\n\nvec3 XYFaceToRayDir(ivec3 p){\n    vec2 x = vec2(p-512) + 0.5;\n           if (p.z==0){     return vec3( 512,-x.y,-x.x);\n    } else if (p.z==1){     return vec3( x.x, 512, x.y);\n    } else if (p.z==2){     return vec3( x.x,-x.y, 512);\n    } else if (p.z==3){     return vec3(-512,-x.y, x.x);\n    } else if (p.z==4){     return vec3( x.x,-512,-x.y);\n    } else if (p.z==5){     return vec3(-x.x,-x.y,-512);\n    } else return vec3(0);\n}\nivec3 RayDirToXYFace(vec3 dir){\n    \n    if        (dir.x>max(abs(dir.y),abs(dir.z))){\n        dir /= dir.x/512.;\n        return ivec3(-dir.z+512., -dir.y+512., 0);\n    } else if (dir.y>max(abs(dir.z),abs(dir.x))){\n        dir /= dir.y/512.;\n        return ivec3(dir.x+512., dir.z+512.,1);\n    } else if (dir.z>max(abs(dir.x),abs(dir.y))){\n        dir /= dir.z/512.;\n        return ivec3(dir.x+512.,-dir.y+512.,2);\n    } else if (-dir.x>max(abs(dir.y),abs(dir.z))){\n        dir /=-dir.x/512.;\n        return ivec3(dir.z+512.,-dir.y+512.,3);\n    } else if (-dir.y>max(abs(dir.z),abs(dir.x))){\n        dir /=-dir.y/512.;\n        return ivec3(dir.x+512.,-dir.z+512.,4);\n    } else if (-dir.z>max(abs(dir.x),abs(dir.y))){\n        dir /=-dir.z/512.;\n        return ivec3(-dir.x+512.,-dir.y+512.,5);\n    } else return ivec3(0,0,-1);\n}","name":"Common","description":"","type":"common"}]}