{"ver":"0.1","info":{"id":"4XlXRB","date":"1709675945","viewed":123,"name":"Improved Simplex Noise 4D/Ashima","username":"KdotJPG","description":"4D Simplex Noise function from Ashima Arts, with the following changes:\n- More visually-random hash function\n- More uniform gradient selection\n- Domain rotation to improve XYZ slices\n- Derivative/gradient output\n- More verbose variable names + comments","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["noise","perlin","simplex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float Frequency = 12.0;\nconst float BumpRadius = 6.0;\nconst float DerivativeRescale = 0.25;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 halfRes = iResolution.xy / 2.0;\n    vec2 uv = (fragCoord - halfRes) / max(halfRes.x, halfRes.y) * Frequency;\n    \n    float bump = sqrt(max(0.0, BumpRadius * BumpRadius - dot(uv, uv)));\n\n    vec4 gradient;\n    float noise = simplex_noise_with_improved_xyz_slices(vec4(uv, bump, iTime), gradient);\n    \n    vec3 col = uv.x > 0.0 ?\n        clamp(gradient.xyz * (DerivativeRescale * 0.5) + 0.5, 0.0, 1.0) :\n        0.5 + 0.5 * vec3(noise);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Hash adapted from https://www.shadertoy.com/view/4djSRW\n// MIT License, Copyright (c) 2014 David Hoskins.\n// See https://opensource.org/license/MIT\nvec4 hash54(vec4 p4, out float u1) {\n\tp4 = fract(p4 * vec4(.1031, .1030, .0973, .1099));\n\tp4 += dot(p4, p4.wzxy+33.33);\n\tu1 = fract((p4.y+p4.w)*p4.x);\n\treturn fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 snoise_prenormalized_vertex_gradient(vec4 p4) {\n\tfloat u1;\n\tvec4 h = hash54(p4, u1);\n\tvec4 axisSelector = vec4(equal(vec4(trunc(u1 * 4.0)), vec4(0, 1, 2, 3))); // Pick one of the four grid axes.\n\tvec4 gradBase = h * 2.0 - 1.0; // Select point within tesseract interior.\n\tgradBase = gradBase * (0.727095 + 0.272905 * (gradBase * gradBase)); // Roughly improve hyperspherical uniformity.\n\treturn mix(gradBase, sign(gradBase), axisSelector); // Push to tesseract surface.\n}\n\nvec4 snoise_tuned_quadratic_approx_inverse_sqrt_vec4(vec4 t) {\n\treturn 1.40678827414 + t * (-0.466818676014 + t * 0.0600304018695);\n}\n\nfloat snoise_tuned_quadratic_approx_inverse_sqrt_float(float t) {\n\treturn 1.40678827414 + t * (-0.466818676014 + t * 0.0600304018695);\n}\n\n// Noise adapted from https://github.com/ashima/webgl-noise\n// MIT License, Copyright (c) 2011 Ashima Arts.\n// See https://opensource.org/license/MIT\nfloat simplex_noise_with_improved_xyz_slices(vec4 inputCoord, out vec4 gradient) {\n\tconst vec4 C = vec4( 0.138196601125011, 0.276393202250021, 0.414589803375032, -0.447213595499958);\n\n\t// Simplex noise takes a hypercube and squashes it down the main diagonal.\n\t// The typical formula for that is `inputCoordSkewed = inputCoord + dot(inputCoord, vec4(SKEW_CONST));`.\n\t// The skew transform maps all simplex lattice vertices to integer hypercube lattice vertices.\n\t// Here, we will use an alternate skew that also bakes in a rotation, so that XYZ slices look better.\n\tvec4 inputCoordSkewed = vec4(\n\t\tinputCoord.xyz + dot(inputCoord, vec4(vec3(-0.16666666666666666), 1.118033988749894)),\n\t\tdot(inputCoord, vec4(vec3(-0.5), 1.118033988749894))\n\t);\n\t\n\t// First corner: skewed base coordinate and true offset.\n\tvec4 skewedBaseCoord = floor(inputCoordSkewed);\n\tvec4 cornerOffset0 = inputCoordSkewed - skewedBaseCoord;\n\tcornerOffset0 -= dot(cornerOffset0, C.xxxx);\n\n\t// The squashed hypercube has 24 paths to get from <0, 0, 0, 0> to <1, 1, 1, 1>.\n\t// Each different order defines the five vertices of a different simplex.\n\t// The orders are defined by the magnitudes of the components of cornerOffset0.\n\t// E.g. <0.6, 0.5, 0.4, 0.3> would be <3, 2, 1, 0>.\n\t// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n\tvec4 vertexTraversalPriority;\n\tvec3 comparisonsX  = step( cornerOffset0.yzw, cornerOffset0.xxx );\n\tvec3 comparisonsYZ = step( cornerOffset0.zww, cornerOffset0.yyz );\n\tvertexTraversalPriority.x = comparisonsX.x + comparisonsX.y + comparisonsX.z;\n\tvertexTraversalPriority.yzw = 1.0 - comparisonsX;\n\tvertexTraversalPriority.y += comparisonsYZ.x + comparisonsYZ.y;\n\tvertexTraversalPriority.zw += 1.0 - comparisonsYZ.xy;\n\tvertexTraversalPriority.z += comparisonsYZ.z;\n\tvertexTraversalPriority.w += 1.0 - comparisonsYZ.z;\n\n\t// vertexTraversalPriority now contains the unique values 0,1,2,3 in each channel.\n\t// Now we can threshold the vector to get the actual relative vertex coordinates.\n\t// E.g. <3,2,1,0> would be <0,0,0,0>, <1,0,0,0>, <1,1,0,0>, <1,1,1,0>, <1,1,1,1>.\n\tvec4 skewedCornerOffset1 = clamp( vertexTraversalPriority - 2.0, 0.0, 1.0 );\n\tvec4 skewedCornerOffset2 = clamp( vertexTraversalPriority - 1.0, 0.0, 1.0 );\n\tvec4 skewedCornerOffset3 = clamp( vertexTraversalPriority,       0.0, 1.0 );\n\tvec4 cornerOffset1 = cornerOffset0 - skewedCornerOffset1 + C.xxxx;\n\tvec4 cornerOffset2 = cornerOffset0 - skewedCornerOffset2 + C.yyyy;\n\tvec4 cornerOffset3 = cornerOffset0 - skewedCornerOffset3 + C.zzzz;\n\tvec4 cornerOffset4 = cornerOffset0 + C.wwww;\n\n\t// Vertex gradients (by hashing skewed coordinates)\n\tvec4 grad0 = snoise_prenormalized_vertex_gradient(skewedBaseCoord);\n\tvec4 grad1 = snoise_prenormalized_vertex_gradient(skewedBaseCoord + skewedCornerOffset1);\n\tvec4 grad2 = snoise_prenormalized_vertex_gradient(skewedBaseCoord + skewedCornerOffset2);\n\tvec4 grad3 = snoise_prenormalized_vertex_gradient(skewedBaseCoord + skewedCornerOffset3);\n\tvec4 grad4 = snoise_prenormalized_vertex_gradient(skewedBaseCoord + 1.0);\n\n\t// Roughly normalize gradients\n\tvec4 norm = snoise_tuned_quadratic_approx_inverse_sqrt_vec4(vec4(dot(grad0, grad0), dot(grad1, grad1), dot(grad2, grad2), dot(grad3, grad3)));\n\tgrad0 *= norm.x;\n\tgrad1 *= norm.y;\n\tgrad2 *= norm.z;\n\tgrad3 *= norm.w;\n\tgrad4 *= snoise_tuned_quadratic_approx_inverse_sqrt_float(dot(grad4, grad4));\n\n\t// Mix contributions from the five vertices\n\tvec3 falloffsA = max(0.6 - vec3(dot(cornerOffset0, cornerOffset0), dot(cornerOffset1, cornerOffset1), dot(cornerOffset2, cornerOffset2)), 0.0);\n\tvec2 falloffsB = max(0.6 - vec2(dot(cornerOffset3, cornerOffset3), dot(cornerOffset4, cornerOffset4)                                   ), 0.0);\n\tvec3 falloffsA2 = falloffsA * falloffsA;\n\tvec2 falloffsB2 = falloffsB * falloffsB;\n\tvec3 falloffsA4 = falloffsA2 * falloffsA2;\n\tvec2 falloffsB4 = falloffsB2* falloffsB2;\n\tvec3 gradRampValuesA = vec3( dot( grad0, cornerOffset0 ), dot( grad1, cornerOffset1 ), dot( grad2, cornerOffset2 ));\n\tvec2 gradRampValuesB = vec2( dot( grad3, cornerOffset3 ), dot( grad4, cornerOffset4 ) );\n\n\t// Gradient (partial derivative vector output)\n\tvec3 gradTempA = falloffsA2 * falloffsA * gradRampValuesA;\n\tvec2 gradTempB = falloffsB2 * falloffsB * gradRampValuesB;\n\tgradient = -8.0 * (\n\t\tgradTempA.x * cornerOffset0 + gradTempA.y * cornerOffset1 + gradTempA.z * cornerOffset2 +\n\t\tgradTempB.x * cornerOffset3 + gradTempB.y * cornerOffset4\n\t);\n\tgradient += falloffsA4.x * grad0 + falloffsA4.y * grad1 + falloffsA4.z * grad2 + falloffsB4.x * grad3 + falloffsB4.y * grad4;\n\tgradient *= 49.0;\n\t\n\t// Undo rotation from the alternative skew at the beginning.\n\tgradient = vec4(\n\t\tgradient.xyz + dot(gradient, vec4(vec3(-0.16666666666666666), -0.5)),\n\t\tdot(gradient, vec4(0.5))\n\t);\n\n    // Note: this is not 100% normalized\n\treturn 49.0 * (dot( falloffsA4, gradRampValuesA ) + dot( falloffsB4, gradRampValuesB ));\n}","name":"Common","description":"","type":"common"}]}