{"ver":"0.1","info":{"id":"fstSW8","date":"1633038497","viewed":207,"name":"Closest point on line","username":"zheck","description":"Shader to do some maths to find the closest point on a line to a point in space. If the red circle was to collide with the green circle then push it to a point along the line the minimum distance away without clipping it. ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["point","closest"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define UV_ORIGIN 0.5\n#define LINE_THICKNESS 0.0025\n\nconst vec3 red = vec3(1., 0., 0.);\nconst vec3 green = vec3(0., 1., 0.);\nconst vec3 blue = vec3(0., 0., 1.);\n\nfloat df_line(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0.0, 1.0);\t\n    float edge = 1.0/min(iResolution.x, iResolution.y);\n    return smoothstep(edge, -edge, length(pa - ba * h) - LINE_THICKNESS);\n}\n\nfloat drawCircle(vec2 position, float radius)\n{\n    float smaller = min(iResolution.x, iResolution.y);\n    float edge = 1.0/smaller;\n    return smoothstep(edge, -edge, length(position) - radius);\n}\n\nvec2 FindNearestPointOnLine(vec2 origin, vec2 end, vec2 point)\n{\n    //Get heading\n    vec2 heading = (end - origin);\n    float magnitudeMax = length(heading);\n    heading = normalize(heading);\n\n    //Do projection from the point but clamp it\n    vec2 lhs = point - origin;\n    float dotP = dot(lhs, heading);\n    dotP = clamp(dotP, 0.0f, magnitudeMax);\n    return origin + heading * dotP;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    // Basic setup stuff\n    float smaller = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord-UV_ORIGIN*iResolution.xy)/smaller;\n    \n    // Define some points to draw a white line\n    vec2 pointA = vec2(-0.35, 0.0);\n    vec2 pointB = vec2( 0.35, 0.0);\n    \n    vec2 greenCircle = vec2( 0.0, sin(iTime) * 0.1);\n    float greenRadius = 0.05;\n    \n    vec2 blueCircle = (iMouse.xy-UV_ORIGIN*iResolution.xy)/min(iResolution.x, iResolution.y);\n    float blueRadius = 0.025;\n    \n    vec2 redCircle = FindNearestPointOnLine(pointA, pointB, blueCircle);\n    float redRadius = 0.05;\n\n    vec2 pureCircle = redCircle;\n\n    // If red circle is inside green circle\n    if( distance(redCircle, greenCircle) < greenRadius + redRadius )\n    {\n        vec2 closestFromGreen = FindNearestPointOnLine(pointA, pointB, greenCircle);\n        float aLength = distance(greenCircle, closestFromGreen);\n        float cLength = redRadius + greenRadius;\n        float bLength = sqrt(pow(cLength, 2.0) - pow(aLength, 2.0));\n        redCircle = closestFromGreen + (normalize(redCircle - closestFromGreen) * bLength);\n    }\n    \n    // Draw all the stuff, basically. None of this has anything to do with the math involved in finding these points.\n    col += df_line(uv, pointA, pointB);\n    col += drawCircle(uv - greenCircle, greenRadius) * green;\n    col += drawCircle(uv - blueCircle, blueRadius) * blue;\n    col += drawCircle(uv - redCircle, redRadius) * red;\n    col = sqrt(col);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}