{"ver":"0.1","info":{"id":"DdVGW1","date":"1678466706","viewed":614,"name":"[zznewclear13] FreeCell","username":"zznewclear13","description":"A FreeCell game.\nCurrently you can only move one card at a time.\nDrag left mouse button to move a card.\nPress rewind to shuffle, takes 52 frames to shuffle.\nPress space to undo (max undo step is iRes.x / 2 - 1).\nPress \"a\" if any card is out of view.","likes":24,"published":1,"flags":56,"usePreview":0,"tags":["2d","game","sound","antialiasing","cards","freecell","playingcard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// [zznewclear13] FreeCell\n// A FreeCell game.\n// Currently you can only move one card at a time.\n// Drag left mouse button to move a card.\n// Press rewind to shuffle, takes 52 frames to shuffle.\n// Press space to undo (maximum undo step is iResolution.x / 2 - 1).\n// Press \"a\" if any card is out of view.\n// Features: gpu sound, victory animation.\n// Many thanks to iq's sdfs, FabriceNeyret2's char function, Dave_Hoskins's hash function, and athibaul's sound function!\n\n// Buffer A is for game logic.\n// Buffer B is for rendering.\n// Image is for final presenting.\n\n// WARNING: Highly unoptimized code, confusing namings, magic numbers, and bad comments.\n// Image tab is the only tab that I can fully understand :)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n    fragColor = vec4(color, 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define RESULT 0u\n#define SHUFFLE 1u\n#define STACK(N) 2u+N\n#define DECK(N) 10u+N\n#define CELL(N) 14u+N\n#define HAND 18u\n#define OPERATIONS 19u\n\nvec2 referenceRes = vec2(512.0f, 288.0f);\nvec2 cardSize = vec2(45.0f, 65.0f);\n// vec4(1.5f, 1.5f, cardSize-1.5f)\nvec4 cardParams = vec4(1.5f, 1.5f, 43.5f, 63.5f);\n// x: top of stack, y: vertical spacing, z: horizontal spacing.\nvec3 stackParams = vec3(180.0f, 15.0f, 14.0f);\nfloat deckOffset = 200.0f;\nfloat cardRadius = 2.0f;\nfloat cardOutlineWidth = 0.5f;\n\nvec3 backgroundColor = vec3(0.3f, 0.6f, 0.4f);\nvec3 blackColor = vec3(0.2f, 0.1f, 0.2f);\nvec3 redColor = vec3(1.0f, 0.2f, 0.3f);\nvec3 cardColor = vec3(0.98f, 0.98f, 0.85f);\nvec3 outlineColor = vec3(0.2f, 0.1f, 0.2f);\nvec3 frameColor = vec3(0.6f, 0.6f, 0.4f);\n\nfloat initFrameCount = 3.0f;\n\n// https://iquilezles.org/articles/distfunctions2d/\n// I modified some of these to accommodate my need.\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 c, in vec2 b )\n{\n    vec2 d = abs(p-c)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdRoundedBox( in vec2 p, in vec4 b, in float r )\n{\n    vec2 q = abs(p-b.xy)-b.zw+r;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r;\n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 bl, in vec2 tr, in float r )\n{\n    vec2 c = (bl+tr)*0.5;\n    vec2 s = (tr-bl)*0.5;\n    vec2 q = abs(p-c)-s+r;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r;\n}\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 c, in vec2 q )\n{\n    p = p-c;\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdHeart( in vec2 p, in vec2 c, in float s )\n{\n    p = p-c;\n    p.x = abs(p.x);\n\n    if( p.y+p.x>s )\n        return sqrt(dot2(p-vec2(0.25,0.75)*s)) - s*sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)*s),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nfloat sdRoundedCross( in vec2 p, in vec2 c, in float s, in float h )\n{\n    float k = 0.5*(h+1.0/h);               // k should be const/precomputed at modeling time\n    \n    p = abs(p-c);\n    return ( p.y<s && p.x<p.y*(k-h)+h*s ) ? \n             k*s-sqrt(dot2(p-vec2(k,1)*s))  :  // circular arc\n           sqrt(min(dot2(p-vec2(h,0)*s),     // top corner\n                    dot2(p-vec2(0,1)*s)));   // right corner\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid getSuitAndRank(float cardIndex, out uint suit, out uint rank)\n{\n    uint uCardIndex = uint(cardIndex);\n    suit = uCardIndex % 4u;\n    rank = uCardIndex / 4u;\n}\n\nfloat getCardIndex(uint suit, uint rank)\n{\n    return float(suit*13u+rank);\n}\n\n// Stack Params: x: top, y: horizontal spacing, z: vertical pacing\nvec2 getStackCoord(vec2 fragCoord, vec2 resolution, vec2 cardSize, vec3 stackParams, out float stackIndex)\n{\n    float width = cardSize.x;\n    float height = cardSize.y;\n    float stackSpacing = stackParams.z;\n\n    float halfStackCount = 4.0f;\n    float left = 0.5f * resolution.x + 0.5f * stackSpacing - halfStackCount * (width + stackSpacing);\n    stackIndex = clamp(floor((fragCoord.x - left) / (width + stackSpacing)), 0.0f, 7.0f);\n    float val = fragCoord.x - left - stackIndex * (width + stackSpacing);\n    \n    return vec2(val, fragCoord.y);\n}\n\n// Stack Params: x: top, y: horizontal spacing, z: vertical pacing\nvec2 getCardCoord(vec2 fragCoord, vec2 cardSize, vec3 stackParams, float count, out float inStackIndex)\n{\n    float y = fragCoord.y;\n    float width = cardSize.x;\n    float height = cardSize.y;\n    float top = stackParams.x;\n    float spacing = stackParams.y;\n    \n    float spacing0 = top - count * spacing;\n    float bottom = spacing0 - (height - spacing);\n    float bottomBasedY = y - bottom;\n    float spacingBasedY = y - spacing0;\n    float spacingCount = clamp(floor(spacingBasedY / spacing), 0.0f, count);\n    inStackIndex = count - spacingCount;\n    float val = bottomBasedY - spacingCount * spacing;\n    if(inStackIndex <= 0.0f) { val = -1.0f;}\n \n    return vec2(fragCoord.x, val);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Buffer A is for game logic.\n\nfloat loadFromTexel(uint y, uint x)\n{\n    return texelFetch(iChannel0, ivec2(x, y), 0).r;\n}\n\nvoid saveToTexel(ivec2 iFragCoord, uint y, uint x, float valueToSave, inout float prevVal)\n{\n    if(iFragCoord.x == int(x) && iFragCoord.y == int(y))\n    {\n        prevVal = valueToSave;\n    }\n}\n\nbool shuffle(ivec2 iFragCoord, inout float prevVal)\n{\n    float shuffleIndex = loadFromTexel(SHUFFLE, 0u);\n    bool shouldShuffle = shuffleIndex <= 52.0f;\n    if(shouldShuffle && iFragCoord.y == int(SHUFFLE))\n    {\n        if(iFragCoord.x == 0)\n        {\n            prevVal = shuffleIndex + 1.0f;\n        }        \n\n        if(iFragCoord.x >= 1 && iFragCoord.x <= 52)\n        {\n            // Initialize.\n            if(shuffleIndex == 0.0f)\n            {\n                prevVal = float(iFragCoord.x)-1.0f;\n            }\n            else\n            {\n                // This kind of shuffling is biased, see here.\n                // https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#Na%C3%AFve_method\n                \n                // Swap two values per frame.\n                uint swapIndex1 = uint(shuffleIndex);\n                uint swapIndex2 = uint(hash12(vec2(shuffleIndex, iDate.w)) * 52.0f)+1u;\n                \n                if(swapIndex1 != swapIndex2)\n                {\n                    float swapVal1 = loadFromTexel(SHUFFLE, swapIndex1);\n                    float swapVal2 = loadFromTexel(SHUFFLE, swapIndex2);\n                    saveToTexel(iFragCoord, SHUFFLE, swapIndex1, swapVal2, prevVal);                    \n                    saveToTexel(iFragCoord, SHUFFLE, swapIndex2, swapVal1, prevVal);     \n                }                        \n            }               \n        }           \n    }\n    return shouldShuffle;    \n}\n\nbool initStack(ivec2 iFragCoord, inout float prevVal)\n{\n    float shuffleIndex = loadFromTexel(SHUFFLE, 0u); \n    float shuffleRange = 52.0f*initFrameCount-1.0f;\n    bool shouldInitialize = (53.0f <= shuffleIndex && shuffleIndex <= 53.0f+shuffleRange);\n  \n    if(shouldInitialize)\n    {\n        bool isTargetFrame = mod(shuffleIndex-53.0f, initFrameCount) == 0.0f;\n        if(isTargetFrame)\n        {\n            float initTarget = (shuffleIndex-53.0f)/initFrameCount;\n            uint inStackIndex = uint(initTarget/8.0f)+1u;\n            uint stackIndex = uint(mod(initTarget, 8.0f));\n\n            float toWrite = loadFromTexel(SHUFFLE, uint(initTarget)+1u);\n            saveToTexel(iFragCoord, STACK(stackIndex), 0u, float(inStackIndex), prevVal);\n            saveToTexel(iFragCoord, STACK(stackIndex), inStackIndex, toWrite, prevVal);\n        }\n        \n        saveToTexel(iFragCoord, SHUFFLE, 0u, shuffleIndex+1.0f, prevVal);\n    }\n    return shuffleIndex <= 53.0f+shuffleRange;\n}\n\nbool checkIfWin(ivec2 iFragCoord, inout float prevVal)\n{\n    float lastResult = loadFromTexel(RESULT, 0u);\n    if(lastResult == 1.0f) return true;\n\n    float deck0 = loadFromTexel(DECK(0u), 0u);\n    float deck1 = loadFromTexel(DECK(1u), 0u);\n    float deck2 = loadFromTexel(DECK(2u), 0u);\n    float deck3 = loadFromTexel(DECK(3u), 0u);\n    bool currentResult = deck0+deck1+deck2+deck3 == 52.0f;\n    if(currentResult)\n    {\n        saveToTexel(iFragCoord, RESULT, 0u, 1.0f, prevVal);\n        saveToTexel(iFragCoord, RESULT, 1u, iTime, prevVal);\n    }\n    return currentResult;\n}\n\n// 0-7: stack, 8-11: deck, 12-15: cell \nbool generalToHand(ivec2 iFragCoord, uint index, inout float prevVal)\n{\n    if(iFragCoord.y <= int(OPERATIONS))\n    {\n        float hand = loadFromTexel(HAND, 0u);\n        if(hand == 0.0f)\n        {\n            float stackCount = loadFromTexel(STACK(index), 0u);\n            if(stackCount >= 1.0f)\n            {\n                float cardIndex = loadFromTexel(STACK(index), uint(stackCount));\n                stackCount-=1.0f;\n                saveToTexel(iFragCoord, STACK(index), 0u, stackCount, prevVal);\n                saveToTexel(iFragCoord, HAND, 0u, cardIndex+1.0f, prevVal);\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n// For cancel operation, ignores all limitations.\nvoid generalToGeneral(ivec2 iFragCoord, uint fromIndex, uint toIndex, inout float prevVal)\n{\n    if(iFragCoord.y <= int(OPERATIONS))\n    {\n        // Commenting this line will result in duplicating cards.\n        // Moving a card and putting it back into the same stack is counted as one (two actually) operation.\n        // Undo this operation will duplicate that card.\n        if(fromIndex == toIndex) return; \n             \n        float fromCount = loadFromTexel(STACK(fromIndex), 0u);\n        float toCount = loadFromTexel(STACK(toIndex), 0u);\n        float fromCardIndex = loadFromTexel(STACK(fromIndex), uint(fromCount));\n        toCount+=1.0f;\n        saveToTexel(iFragCoord, STACK(fromIndex), 0u, fromCount-1.0f, prevVal);\n        saveToTexel(iFragCoord, STACK(toIndex), 0u, toCount, prevVal);\n        saveToTexel(iFragCoord, STACK(toIndex), uint(toCount), fromCardIndex, prevVal);\n    }\n}\n\nbool canAttach(float cardIndex, float targetCardIndex)\n{\n    uint thisSuit, thisRank, targetSuit, targetRank;\n    getSuitAndRank(cardIndex, thisSuit, thisRank);\n    getSuitAndRank(targetCardIndex, targetSuit, targetRank);\n    return ((thisSuit%2u + targetSuit%2u) == 1u) && (thisRank+1u == targetRank);\n}\n\nbool handToStack(ivec2 iFragCoord, uint stackIndex, bool force, inout float prevVal)\n{\n    if(iFragCoord.y <= int(OPERATIONS))\n    {\n        float hand = loadFromTexel(HAND, 0u);\n        if(hand >= 1.0f)\n        {\n            float stackCount = loadFromTexel(STACK(stackIndex), 0u);\n            float lastCard = loadFromTexel(STACK(stackIndex), uint(stackCount));\n            if(stackCount==0.0f || canAttach(hand-1.0f, lastCard) || force)\n            {\n                saveToTexel(iFragCoord, STACK(stackIndex), 0u, stackCount+1.0f, prevVal);\n                saveToTexel(iFragCoord, STACK(stackIndex), uint(stackCount+1.0f), hand-1.0f, prevVal);                      \n                saveToTexel(iFragCoord, HAND, 0u, 0.0f, prevVal);\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool handToCell(ivec2 iFragCoord, uint cellIndex, bool force, inout float prevVal)\n{\n    if(iFragCoord.y <= int(OPERATIONS))\n    {\n        float hand = loadFromTexel(HAND, 0u);\n        if(hand >= 1.0f)\n        {\n            float cell = loadFromTexel(CELL(cellIndex), 0u);\n            if(cell <= 0.0f || force)\n            {\n                saveToTexel(iFragCoord, CELL(cellIndex), 0u, 1.0f, prevVal);\n                saveToTexel(iFragCoord, CELL(cellIndex), 1u, hand-1.0f, prevVal);\n                saveToTexel(iFragCoord, HAND, 0u, 0.0f, prevVal); \n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool handToDeck(ivec2 iFragCoord, out uint toIndex, bool force, inout float prevVal)\n{\n    if(iFragCoord.y <= int(OPERATIONS))\n    {\n        float hand = loadFromTexel(HAND, 0u);\n        if(hand >= 1.0f)\n        {\n            uint suit, rank;\n            getSuitAndRank(hand-1.0f, suit, rank);\n            toIndex = suit;\n            float cardCount = loadFromTexel(DECK(suit), 0u); \n            if(uint(cardCount) == rank || force)\n            {\n                saveToTexel(iFragCoord, DECK(suit), 0u, cardCount+1.0f, prevVal);\n                saveToTexel(iFragCoord, DECK(suit), rank+1u, hand-1.0f, prevVal);\n                saveToTexel(iFragCoord, HAND, 0u, 0.0f, prevVal);\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n// from: STACK(0)-STACK(7): 0-7, CELL(0)-CELL(3): 12-15\nvoid startOperation(ivec2 iFragCoord, float from, float operationCount, inout float prevVal)\n{\n    operationCount+=1.0f;\n    saveToTexel(iFragCoord, OPERATIONS, uint(2.0f * operationCount), from+2.0f, prevVal);\n    saveToTexel(iFragCoord, OPERATIONS, 0u, operationCount, prevVal);\n}\n\n// to: STACK(0)-CELL(3): 0-15\nvoid endOperation(ivec2 iFragCoord, float to, float operationCount, inout float prevVal)\n{\n    saveToTexel(iFragCoord, OPERATIONS, uint(2.0f*operationCount+1.0f), to+2.0f, prevVal);\n}\n\nvoid cancelLastOperation(ivec2 iFragCoord, float operationCount, inout float prevVal)\n{\n    if(operationCount <= 0.0f) return;\n\n    float from = loadFromTexel(OPERATIONS, uint(2.0f*operationCount));\n    float to = loadFromTexel(OPERATIONS, uint(2.0f*operationCount+1.0f));\n    if(to == 0.0f)\n    {\n        if(from <= 9.0f)\n        {\n            handToStack(iFragCoord, uint(from-float(STACK(0u))), true, prevVal);\n        }\n        else\n        {\n            handToCell(iFragCoord, uint(from-float(CELL(0u))), true, prevVal);\n        }  \n    }\n    else\n    {\n        generalToGeneral(iFragCoord, uint(to-2.0f), uint(from-2.0f), prevVal);\n    }\n    \n    saveToTexel(iFragCoord, OPERATIONS, uint(2.0f*operationCount), 0.0f, prevVal);\n    saveToTexel(iFragCoord, OPERATIONS, uint(2.0f*operationCount+1.0f), 0.0f, prevVal);\n    operationCount-=1.0f;    \n    saveToTexel(iFragCoord, OPERATIONS, 0u, operationCount, prevVal);\n}\n\nfloat mouseCoordToInStackIndex()\n{ \n    float stackIndex;\n    float scaleFactor = iResolution.y / referenceRes.y;\n    vec2 scaledMouseCoord = iMouse.xy / scaleFactor+0.5f*stackParams.z;\n    vec2 stackCoord = getStackCoord(scaledMouseCoord, referenceRes, cardSize, stackParams, stackIndex);\n    return stackIndex;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame == 0)\n    {\n        fragColor = vec4(0.0f); return;\n    }\n    \n    ivec2 iFragCoord = ivec2(floor(fragCoord));\n \n    float prevVal = loadFromTexel(uint(iFragCoord.y), uint(iFragCoord.x));\n    bool shouldShuffle = shuffle(iFragCoord, prevVal);\n    \n    float scaleFactor = iResolution.y / referenceRes.y;\n    float scaledDeckOffset = deckOffset * scaleFactor;\n    \n    if(!shouldShuffle)\n    {\n        bool initializing = initStack(iFragCoord, prevVal);     \n        bool win = checkIfWin(iFragCoord, prevVal);\n        if(win || initializing)\n        {\n            fragColor = vec4(prevVal, 0.0f, 0.0f, 1.0f);\n            return;\n        }\n        \n        float operationCount = loadFromTexel(OPERATIONS, 0u);   \n        if(texelFetch(iChannel1,ivec2(32,1),0).x > 0.0f)\n        {\n            cancelLastOperation(iFragCoord, operationCount, prevVal);\n        }\n        \n        bool hasInHand = loadFromTexel(HAND, 0u)>=1.0f;\n        \n        float currentStackIndex = mouseCoordToInStackIndex();\n        uint generalIndex = uint(currentStackIndex);   \n        if(iMouse.z > 0.0f)\n        {  \n            if(iMouse.y <= scaledDeckOffset || generalIndex >= 4u)\n            {\n                if(iMouse.y > scaledDeckOffset)\n                {\n                    generalIndex += 8u;\n                }\n                if(generalToHand(iFragCoord, generalIndex, prevVal))\n                {\n                    startOperation(iFragCoord, float(generalIndex), operationCount, prevVal);\n                }               \n            }           \n        }\n        else if(hasInHand)\n        {\n            float lastToHand = loadFromTexel(OPERATIONS, uint(operationCount*2.0f));\n            bool succeeded = false;\n            uint toIndex = 0u;\n            if(iMouse.y >= scaledDeckOffset)\n            {\n                if(currentStackIndex >= 4.0f)\n                {\n                    succeeded = handToCell(iFragCoord, generalIndex-4u, false, prevVal);\n                }\n                else\n                {\n                    succeeded = handToDeck(iFragCoord, generalIndex, false, prevVal);           \n                }\n                generalIndex += 8u;\n            }\n            else\n            {\n                succeeded = handToStack(iFragCoord, generalIndex, false, prevVal);\n            }\n            \n        \n            if(succeeded)\n            {\n                endOperation(iFragCoord, float(generalIndex), operationCount, prevVal);\n            }\n            else\n            {\n                cancelLastOperation(iFragCoord, operationCount, prevVal);\n            }\n        }    \n    }\n \n    fragColor = vec4(prevVal, 0.0f, 0.0f, 1.0f);  \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Buffer B is for rendering.\n\n// Feeling confused about text rendering and anti-aliasing? Me too!\n\n// I modified FabriceNeyret2's `char` function\n// Calculate ddxy manually because my `p` may not be continuous.\n// https://www.shadertoy.com/view/llySRh\nvec4 char(vec2 p, int c, vec4 ddxy) \n{\n    if (p.x<0.|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad(iChannel2, p/16. + fract( vec2(c, 15-c/16) / 16. ), ddxy.xy, ddxy.zw );\n}\n\nfloat loadFromTexel(uint y, uint x)\n{\n    return texelFetch(iChannel0, ivec2(x, y), 0).r;\n}\n\nvoid saveToTexel(ivec2 iFragCoord, uint y, uint x, float valueToSave, inout float prevVal)\n{\n    if(iFragCoord.x == int(x) && iFragCoord.y == int(y))\n    {\n        prevVal = valueToSave;\n    }\n}\n\n// I prefer X over 10\nint getCardChar(uint rank, out bool isTen)\n{\n    isTen = false;\n    if(rank >= 1u && rank <= 8u) return 49+int(rank);\n    if(rank == 0u) return 65;\n    if(rank == 10u) return 74;\n    if(rank == 11u) return 81;\n    if(rank == 12u) return 75;\n    if(rank == 9u)\n    {\n        isTen = true;\n        return 49;\n    }\n}\n\nvec3 getSuitColor(uint suit)\n{   \n    return mix(blackColor, redColor, float(suit%2u));\n}\n\n// Reference size: 30x30\n// Eeeewwwww, calling this will add 0.3s to compile time.\n// I called this three times :)\nfloat drawSuitIcon(vec2 fragCoord, float height, uint suit)\n{\n    float scaleFactor = 30.0f / height;\n    fragCoord *= scaleFactor;\n    \n    scaleFactor *= referenceRes.y /iResolution.y;\n    float sdSuit = 1e5;\n    if(suit == 0u)\n    {\n        // Spade\n        vec2 tempFragCoord = vec2(fragCoord.x, -fragCoord.y);\n        float sdHeart1 = sdHeart(tempFragCoord, vec2(15.0f, -32.0f), 25.0f)+3.0f;\n        float sdTri1 = sdTriangleIsosceles(fragCoord, vec2(15.0f, 18.0f), vec2(5.0f, -15.0f));\n        sdSuit = min(sdHeart1, sdTri1);\n    }\n    else if(suit == 1u)\n    {\n        // Heart  \n        float sdHeart1 = sdHeart(fragCoord, vec2(15.0f, 2.0f), 22.0f)+1.0f;\n        sdSuit = sdHeart1;\n    }\n    else if(suit == 2u)\n    {\n        // Club\n        float sdO1 = sdCircle(fragCoord, vec2(15.0f, 21.0f), 6.0f);\n        float sdO2 = sdCircle(fragCoord, vec2(9.0f, 13.5f), 6.0f);\n        float sdO3 = sdCircle(fragCoord, vec2(21.0f, 13.5f), 6.0f);\n        float sdTri1 = sdTriangleIsosceles(fragCoord, vec2(15.0f, 28.0f), vec2(5.0f, -25.0f));\n        sdSuit = min(min(min(sdO1, sdO2), sdO3), sdTri1);\n    }\n    else\n    {\n        // Diamond\n        float sdDiamond = sdRoundedCross(fragCoord, vec2(15.0f, 15.0f), 23.0f, 2.0f)+1.0f;       \n        sdSuit = sdDiamond;\n    }\n    float thickness = 1.0f * (scaleFactor-1.0f);\n    return smoothstep(-0.5f*scaleFactor + thickness, -2.0f*scaleFactor + thickness, sdSuit);\n}\n\nvoid drawFrame(vec2 fragCoord, vec4 cardParams, float radius, uint index, inout vec3 color)\n{  \n    float scaleFactor = iResolution.y / referenceRes.y;\n\n    float sdCard = sdRoundedBox(fragCoord, cardParams.xy, cardParams.zw, radius);\n    float cardAlpha = smoothstep(1.5f/scaleFactor, 0.0f, sdCard);\n    float outlineWidth = cardOutlineWidth;\n    float outlineAlpha = smoothstep(0.0f-outlineWidth, 1.5f/scaleFactor-outlineWidth, sdCard);\n    \n    vec3 tempFrameColor = mix(frameColor, outlineColor, outlineAlpha);\n    \n    if(index <= 3u)\n    {\n        uint suit = index;\n        vec3 suitColor = getSuitColor(suit);\n        vec2 suitSize2 = vec2(40.0f, 40.0f);\n        vec2 suitBottomLeft2 = (cardParams.xy+cardParams.zw)*0.5f-suitSize2*0.5f;\n        vec2 suitCoord2 = fragCoord - suitBottomLeft2;\n        float suitAlpha2 = drawSuitIcon(suitCoord2, suitSize2.y, suit);\n        tempFrameColor = mix(tempFrameColor, suitColor, suitAlpha2);\n    }  \n    \n    color = mix(color, tempFrameColor, cardAlpha * 0.5f);\n}\n\n// Fill the little gap in top two coreners.\nvoid drawCardBelow(vec2 fragCoord, vec4 cardParams, float radius, vec3 stackParams, inout vec3 color)\n{\n    float scaleFactor = iResolution.y / referenceRes.y;\n\n    fragCoord.y -= stackParams.z;\n    float sdCard = sdRoundedBox(fragCoord, cardParams.xy, cardParams.zw, radius);\n    \n    float cardAlpha = smoothstep(1.5f/scaleFactor, 0.0f, sdCard);\n    float outlineWidth = cardOutlineWidth;\n    float outlineAlpha = smoothstep(0.0f-outlineWidth, 1.5f/scaleFactor-outlineWidth, sdCard);\n    \n    vec3 tempCardColor = mix(cardColor, outlineColor, outlineAlpha);\n    color = mix(color, tempCardColor, cardAlpha); \n}\n\nvoid drawCard(vec2 fragCoord, vec4 cardParams, float radius, float cardIndex, vec3 stackParams, bool shouldDrawCardBelow, inout vec3 color)\n{\n    float scaleFactor = iResolution.y / referenceRes.y;\n\n    uint suit, rank;\n    getSuitAndRank(cardIndex, suit, rank);\n    bool isTen;\n    int cardChar = getCardChar(rank, isTen);\n    vec3 suitColor = getSuitColor(suit);\n\n    float suitHeight1 = 12.0f;\n    vec2 suitBottomLeft1 = vec2(2.0f, cardParams.w - suitHeight1 - 1.0f);\n    vec2 suitSize2 = vec2(40.0f, 40.0f);\n    vec2 suitBottomLeft2 = (cardParams.xy+cardParams.zw)*0.5f-suitSize2*0.5f;\n            \n    vec2 suitCoord1 = fragCoord - suitBottomLeft1;\n    float suitAlpha1 = drawSuitIcon(suitCoord1, suitHeight1, suit);\n    vec2 suitCoord2 = fragCoord - suitBottomLeft2;\n    float suitAlpha2 = drawSuitIcon(suitCoord2, suitSize2.y, suit);\n    \n    vec2 textSize = vec2(14.0f, 14.0f);\n    vec2 textBottomLeft = suitBottomLeft1 + vec2(8.0f, -1.3f);\n    vec2 textUV = (fragCoord-textBottomLeft) / textSize;\n    vec2 ddxy = 1.0f / 16.0f / textSize / scaleFactor;\n    float sdText = char(textUV, cardChar, vec4(ddxy.x, 0.0f, 0.0f, ddxy.y)).w;\n    // Almost consistent width for different resolutions.\n    float thickness = -4.0f + 1.0f * (scaleFactor-1.0f);\n    // Magic!\n    float textAlpha = smoothstep(0.5f + thickness*0.01f + 1.5f/textSize.y/scaleFactor, 0.5f+thickness*0.01f, sdText);\n    if(isTen)\n    {\n        textUV.x -= 0.4f;\n        sdText = char(textUV, 48, vec4(ddxy.x, 0.0f, 0.0f, ddxy.y)).w;\n        textAlpha += smoothstep(0.5f + thickness*0.01f + 1.5f/textSize.y/scaleFactor, 0.5f+thickness*0.01f, sdText);\n    }\n    \n    float sdCard = sdRoundedBox(fragCoord, cardParams.xy, cardParams.zw, radius);\n    float cardAlpha = smoothstep(1.5f /scaleFactor, 0.0f, sdCard);\n    \n    float outlineWidth = cardOutlineWidth;\n    float outlineAlpha = smoothstep(0.0f-outlineWidth, 1.5f/scaleFactor-outlineWidth, sdCard);\n    \n    vec3 tempCardColor = mix(cardColor, outlineColor, outlineAlpha);\n    tempCardColor = mix(tempCardColor, suitColor, textAlpha + suitAlpha1 + 0.5f*suitAlpha2);\n    \n    if(shouldDrawCardBelow) drawCardBelow(fragCoord, cardParams, radius, stackParams, color);\n    color = mix(color, tempCardColor, cardAlpha); \n}\n\nfloat mouseCoordToInStackIndex()\n{ \n    float stackIndex;\n    float scaleFactor = iResolution.y / referenceRes.y;\n    vec2 scaledMouseCoord = iMouse.xy / scaleFactor+0.5f*stackParams.z;\n    vec2 stackCoord = getStackCoord(scaledMouseCoord, referenceRes, cardSize, stackParams, stackIndex);\n    return stackIndex;\n}\n\nvoid offsetStack(ivec2 iFragCoord, inout vec2 stackCoord, float cardCount, float stackIndex, inout float alpha)\n{\n    float lastAlpha = texelFetch(iChannel1, ivec2(int(stackIndex), 0), 0).a;\n    float duration = 0.3f;\n    stackCoord.y -= smoothstep(1.0f, 1.0f-duration, lastAlpha) * stackParams.y * max(cardCount - 7.0f, 0.0f);\n       \n#ifdef IMOUSE_IS_VALID_WHEN_HOVERING\n    // Would be nice if we can have iMouse when hovering. \n    float mouseIndex = mouseCoordToInStackIndex();\n    if(iFragCoord.y==0 && iFragCoord.x<=7)\n    {\n        if(texelFetch(iChannel3,ivec2(65,0),0).x > 0.0f)\n        {\n            if(iFragCoord.x == int(mouseIndex))\n            {\n                alpha -= iTimeDelta;\n            }\n            else\n            {\n                alpha += iTimeDelta;\n            }\n        }\n    }\n#else\n    if(texelFetch(iChannel3,ivec2(65,0),0).x > 0.0f)\n    {   \n        if(iFragCoord.y==0 && iFragCoord.x<=7)\n        {\n            alpha -= iTimeDelta;   \n        }\n    }\n    else\n    {\n        if(iFragCoord.y==0 && iFragCoord.x<=7)\n        {\n            alpha += iTimeDelta;   \n        }\n    }\n#endif \n    alpha = clamp(alpha, 1.0f-duration, 1.0f);\n}\n\nvoid drawStack(vec2 stackCoord, float cardCount, float stackIndex, inout vec3 color)\n{\n    float inStackIndex;\n    vec2 cardCoord = getCardCoord(stackCoord, cardSize, stackParams, cardCount, inStackIndex);\n    float cardIndex = loadFromTexel(STACK(uint(stackIndex)), uint(inStackIndex));\n    \n    bool shouldDrawCardBelow = inStackIndex >= 2.0f;\n    drawCard(cardCoord, cardParams, cardRadius, cardIndex, stackParams, shouldDrawCardBelow, color);   \n}\n\nvoid drawDeckAndCell(vec2 stackCoord, float stackIndex, inout vec3 color)\n{\n    stackCoord.y -= deckOffset;\n    float cardCount = loadFromTexel(DECK(uint(stackIndex)), 0u);\n    if(cardCount >= 1.0f)\n    {\n        float cardIndex = loadFromTexel(DECK(uint(stackIndex)), uint(cardCount));\n        drawCard(stackCoord, cardParams, cardRadius, cardIndex, vec3(0.0f), false, color);\n    }\n    else\n    {\n        drawFrame(stackCoord, cardParams, cardRadius, uint(stackIndex), color);\n    }\n}\n\nvoid drawHand(vec2 fragCoord, inout vec3 color)\n{\n    float scaleFactor = iResolution.y / referenceRes.y;\n    float hand = loadFromTexel(HAND, 0u);\n    if(hand >= 1.0f)\n    {\n        vec2 cardCoord = fragCoord-iMouse.xy/scaleFactor+0.5f*cardSize;\n        drawCard(cardCoord, cardParams, cardRadius, hand-1.0f, vec3(0.0f), false, color);\n    }\n}\n\nvec2 parabola(vec2 c, float s, float g, float t)\n{\n    float t1 = sqrt(deckOffset*2.0f/g);\n    float b = 0.7f;\n    float vv = b*s*t1;\n    float h1 = -0.5f*g*t*t;\n    float h2 = -(1.0f-b*b)*deckOffset-0.5f*g*(t-(1.0f+b)*t1)*(t-(1.0f+b)*t1);\n    return c + vec2(s*t, max(h1, h2));\n}\n\n// Victory animation.\nbool checkIfWin(vec2 fragCoord, vec3 lastFrame, inout vec3 color)\n{\n    bool win = loadFromTexel(RESULT, 0u) == 1.0f;\n\n    if(win)\n    {\n        vec2 uv = fragCoord / iResolution.xy;\n        \n        float scaleFactor = iResolution.y / referenceRes.y;\n        float wonTime = loadFromTexel(RESULT, 1u);\n        float timeElapsed = iTime - wonTime;\n        \n        float cardIndex = floor(timeElapsed / 3.0f);\n        float cardTime = timeElapsed - 3.0f * cardIndex;\n        cardIndex = 51.0f - cardIndex;\n        \n        vec2 deckBottomLeft = vec2(referenceRes.x*0.5f-stackParams.z*3.5f-cardSize.x*4.0f, deckOffset);\n        if(cardIndex >= 0.0f)\n        {\n            uint suit, rank;\n            getSuitAndRank(cardIndex, suit, rank);\n            vec2 startPos = deckBottomLeft + float(suit) * vec2(cardSize.x + stackParams.z, 0.0f);\n            float speedX = 50.0f + 100.0f*hash12(vec2(cardIndex, wonTime));\n            vec2 currentPos = parabola(startPos, speedX, 300.0f, cardTime);\n            vec2 cardCoord = fragCoord-currentPos;\n            drawCard(cardCoord, cardParams, cardRadius, cardIndex, vec3(0.0f), false, lastFrame);\n            color = lastFrame;  \n        }    \n    }\n    return win;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iFragCoord = ivec2(floor(fragCoord));\n   \n    vec3 color = backgroundColor; \n    \n    vec2 scaledFragCoord = fragCoord * referenceRes.y / iResolution.y;\n    float stackIndex;\n    vec2 stackCoord = getStackCoord(scaledFragCoord, referenceRes, cardSize, stackParams, stackIndex);\n    \n    vec4 lastFrame = texture(iChannel1, fragCoord/iResolution.xy);\n    float alpha = lastFrame.a;\n    bool win = checkIfWin(scaledFragCoord, lastFrame.rgb, color);\n    \n    if(!win)\n    {\n        drawDeckAndCell(stackCoord, stackIndex, color);\n        \n        float cardCount = loadFromTexel(STACK(uint(stackIndex)), 0u);\n        offsetStack(iFragCoord, stackCoord, cardCount, stackIndex, alpha);\n        drawStack(stackCoord, cardCount, stackIndex, color);\n        \n        drawHand(scaledFragCoord, color);\n    }\n    \n    fragColor = vec4(color, alpha);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float singleCardVolume = 2.0f;\nfloat frameTime = 1.0f / 60.0f;\nfloat startTime = 52.0f / 60.0f;\n\n// I LOVE SOUND TAB!\n\n// Sound design comes from athibaul\n// https://www.shadertoy.com/view/sls3WM\n#define TAU (2.*3.1415926)\n\nvec2 rand2(float p)\n{\n    // Hash function by Dave Hoskins\n    // https://www.shadertoy.com/view/4djSRW\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 noise2(float s){\n    int si = int(floor(s));\n    float sf = fract(s);\n    sf = sf*sf*(3.-2.*sf); // smoothstep(0,1,sf)\n    return mix(rand2(float(si)), rand2(float(si+1)), sf) * 2. - 1.;\n}\n\nvec2 coloredNoise2(float t, float fc, float df)\n{\n    // Noise peak centered around frequency fc\n    // containing frequencies between fc-df and fc+df\n    vec2 noiz = noise2(t*df);\n    vec2 modul = vec2(cos(TAU*fc*t), sin(TAU*fc*t));\n    return modul*noiz;\n}\n\nvec2 hat2(float t, float fc)\n{\n    // Short hi-hat with tuneable center frequency\n    return coloredNoise2(t, fc, fc-500.) * smoothstep(0.,0.001,t) * smoothstep(0.03,0.01,t) * 0.1;\n}\nvec2 mainSound( int samp, float time )\n{\n    if(time <= startTime || time >= startTime+52.0f*frameTime*initFrameCount) return vec2(0.0f, 0.0f);\n    \n    vec2 sound = vec2(0.0f);\n    for(float i=0.0f; i<=51.0f;++i)\n    {\n        float tempTime = time-startTime-i*frameTime*initFrameCount;\n\n        float stackIndex = mod(i, 8.0f);\n        float spatio = (3.5f - stackIndex) * 0.25f * 0.3f + 0.5f;\n        vec2 volume = singleCardVolume * vec2(spatio, 1.0f - spatio);\n                \n        float fhat = 3000.0f;\n        sound += hat2(tempTime, fhat) * volume;\n    }\n\n    return sound;\n}","name":"Sound","description":"","type":"sound"}]}