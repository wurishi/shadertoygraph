{"ver":"0.1","info":{"id":"clsyWB","date":"1691130357","viewed":98,"name":"2D sphere normals with shading","username":"sspanky","description":"analytical normals for a sphere using 2d coords with some basic shading,\nunfortunately there are almost no comments because i was lazy","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["normals","analytical"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define _PI     3.14159265\n\nfloat dot2(vec2 v)\n{\n    return dot(v, v);\n}\n\nvec3 simpleRotation(vec3 v, float rot)\n{\n    vec3 rotated = vec3(\n        v.x * cos(rot) - v.y * sin(rot),\n        v.x * sin(rot) + v.y * cos(rot),\n        v.z\n    );\n    return rotated;\n}\n\nfloat fresnelSchlicks(vec3 incident, vec3 normal, float ior)\n{\n    float f0 = (ior - 1.0) / (ior + 1.0);\n    f0 *= f0;\n    return f0 + (1.0 - f0) * pow(1.0 - dot(normalize(incident), normalize(normal)), 5.0);\n}\n\n// stylized specular highlights\nfloat specularHighlight(vec3 reflected, vec3 sunDirection, float size, float strength)\n{\n    float bigOne = pow(max(0.0, dot(reflected, -sunDirection)), size * 0.5) * strength * 0.2;\n    float smallOne = pow(max(0.0, dot(reflected, -sunDirection)), size * 4.0) * strength;\n    return bigOne + smallOne;\n}\n\nconst float ambientStrength = 1.0;\nconst float sunStrength = 1.0;\n\nconst float floorAmbientStrength = 0.5;\nconst float halfLambertStrength = 0.2;\n\nconst float ior = 1.5;\n\n\n\nconst float exposure = 3.0;\nconst vec3 up = vec3(0.0, 0.0, 1.0);\nconst vec3 sunDirection = normalize(vec3(1.0, 1.0, 1.0));\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord / iResolution.xy);\n    uv = uv * 2.0 - 1.0;\n    uv.x = uv.x * (iResolution.x / iResolution.y);\n\n    \n    float r2 = dot2(uv);\n    \n    vec3 finalColor = vec3(0.0, 0.0, 0.0);\n    if(r2 <= 1.0)\n    {\n        vec3 normal = vec3(sqrt(1.0 - r2), -uv.x, uv.y);\n        vec3 incident = vec3(1.0, 0.0, 0.0);\n        \n        normal = simpleRotation(normal, iTime * 2.0);\n        incident = simpleRotation(incident, iTime * 2.0);\n        \n        vec3 reflectedIncident = reflect(incident, normal);\n        \n        vec3 diffuse = vec3(1.0, 1.0, 1.0);\n        vec3 sun = vec3(1.0, .7, .65) * 2.0;\n        vec3 ambient = vec3(.2, .3, .6) * 1.0;\n        vec3 floorColor = vec3(0.5, 0.5, 0.5); // color of the imaginary floor\n        \n        float lighting = max(0.0, dot(normal, sunDirection));\n        float lightingHalfLambert = dot(normal, sunDirection) * .5 + .5;\n        float ambientLighting = dot(normal, up) * .5 + .5;\n        float floorAmbientLighting = dot(normal, -up) * .5 + .5;\n        \n\n        float fres = fresnelSchlicks(incident, normal, ior); // fresnel approx\n        \n        float highlight = specularHighlight(reflectedIncident, sunDirection, 32.0, 32.0);\n        finalColor.rgb = (diffuse * (\n            (floorColor * sun * floorAmbientLighting * sunStrength * floorAmbientStrength) + // fake bounce lighting from an imaginary floor\n            \n            (ambient * ambientLighting * ambientStrength) +  // ambientlight coming from the top\n            \n            (sun * lighting * sunStrength) +// sun\n            \n            (sun * lightingHalfLambert * halfLambertStrength * sunStrength) // some fake GI approx used by Valve\n            \n            \n        )) + \n            // reflections for dielectrics should not be tinted by the diffuse color\n            (ambient * fres) +  // reflection\n            \n            // same goes for highlights because they are techically reflections\n            (sun * highlight * fres * sunStrength); // specular highlights\n            \n        \n        \n        \n    } else {\n        finalColor.rgb = vec3(.2, .3, .6) * 1.5;\n    }\n    // basic tonemapping\n    finalColor.rgb *= exposure;\n    finalColor.rgb /= (1.0 + finalColor.rgb);\n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}