{"ver":"0.1","info":{"id":"3sfXWj","date":"1552137619","viewed":182,"name":"BRDF Explorer Plaything","username":"krax","description":"Currently I have no great way to use BRDF explorer, my computer doesn't work and my girlfriend refuses to allow to install compilers on her macbook.\n\nYou can use the mouse to change the direction of the light around.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["brdf","brdfexplorer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This was inspired by the lovely BRDF explorer from Disney\n// https://www.disneyanimation.com/technology/brdf.html\n// https://github.com/wdas/brdf\n\n\n\n// Put your interesting BRDF code here\nvec3 BRDF( vec3 L, vec3 V, vec3 N, vec3 X, vec3 Y ) {\n\n  return vec3(dot(L,N));\n\n}\n\n\n////////////////////////////////////////////////////\n// Ignore everything under here\n#define PI 3.1415926535\nstruct Camera {\n  vec3 position;\n  vec3 look_at;\n  vec3 up;\n  float focus;\n};\n\nstruct Hit {\n  bool hit;\n  vec3 P;\n  vec3 N;\n};\n\nvec3 get_ray_direction(Camera cam, vec2 uv) {\n  // Get the direction the camera is facing, based on what\n  // it's supposed to be looking at\n  vec3 cam_direction = normalize(-cam.position - cam.look_at);\n  vec3 cam_side = cross(cam_direction, cam.up);\n  // Get the normalized ray direction\n  return normalize(\n      vec3(cam_side * uv.x + cam.up * uv.y + cam_direction * cam.focus));\n}\n\nHit intersect_scene(vec3 origin, vec3 direction) {\n\n  // sphere is at origin with a radius of 1\n  // For a better explanation of this:\n  // https://www.geogebra.org/3d/uxv5kfum\n  vec3 ray_to_sphere = origin;\n  float projection = dot(direction, -origin);\n  float disk_radius =\n      1. + projection * projection - dot(ray_to_sphere, ray_to_sphere);\n  if (disk_radius > 0.) {\n    float interval = min(projection + disk_radius, projection - disk_radius);\n    vec3 sphere_p = origin + direction * interval;\n    return Hit(true, sphere_p, normalize(sphere_p));\n  }\n  return Hit(false, vec3(0.), vec3(0.));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord.xy * 2. - iResolution.xy) / iResolution.y;\n  Camera camera = Camera(vec3(0., 0., 3.), // Position\n                         vec3(0., 0., 0.), // Look at\n                         vec3(0., 1., 0.), // Up\n                         1.3               // FL\n                         );\n  Hit hit = intersect_scene(camera.position, get_ray_direction(camera, uv));\n  vec3 col = vec3(0.);\n  if (hit.hit) {\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    if (mouse == vec2(0.)) {\n      mouse = vec2(0.5);\n    }\n    mouse -= 0.5;\n    mouse *= PI;\n    vec3 light = vec3(0., 0., 1.);\n    mat3 rx = mat3(cos(mouse.x), 0., -sin(mouse.x), 0., 1., 0., sin(mouse.x),\n                   0., cos(mouse.x));\n    mat3 ry = mat3(1., 0., 0., 0., cos(mouse.y), -sin(mouse.y), 0.,\n                   sin(mouse.y), cos(mouse.y));\n\n    // Figure out tangent and bitangent\n    float theta = acos(hit.N.z) + PI * 0.5;\n    vec3 tangent = normalize(\n        vec3(sin(theta) * cos(theta), sin(theta) * sin(theta), cos(theta)));\n    col = BRDF(ry * rx * light, normalize(camera.position - hit.P), hit.N,\n               tangent, cross(tangent, hit.N));\n  }\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}