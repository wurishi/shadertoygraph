{"ver":"0.1","info":{"id":"lXSfzm","date":"1729290604","viewed":66,"name":"Hexagonal grid tweak test","username":"stegu","description":"Hexagonal grid, done reasonably efficiently, with a slightly non-uniform scaling to place grid points at integer and half-integer positions. The cell boundaries are computed as if the grid was regular - scaling the pattern will yield regular hexagons.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["grid","tiling","hex","hexagonal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// All code below is hereby placed in the public domain by its\n// original author (me). Credit is appreciated, but not required.\n// Author: Stefan Gustavson 2024-10-19\n//\n// NOTE: If you just want fast code, there are better options.\n// This aims for \"reasonably fast code that is easy to understand\".\n// (And now misses the mark, after I optimized it too much.)\n\nfloat hash(vec2 p) {\n    float hash = mod(floor(p.x), 289.0);\n\thash = mod((hash*51.0 + 2.0)*hash + floor(p.y), 289.0);\n\thash = mod((hash*34.0 + 10.0)*hash, 289.0);\n    return hash;\n}\n\n// Find the closest point from p in a hexagonal grid.\n// The grid is not quite regular. Scale y by 2.0/sqrt(3.0) at\n// the start of the function and then back by sqrt(3.0)2.0\n// at the end if you prefer a regular hex grid. In that case\n// the grid points will be at pesky irrational coordinates in y.\n//\n// When determining which grid point is closest to p, the\n// distances are computed with a scaled local y coordinate, to\n// make cells congruent with a squished regular hexagonal grid.\n//\n// Performance-wise, this is fast. Maybe not optimally fast, but\n// it's only two floor(), 15 add/sub, 2 mult and three conditional\n// selections based on already-computed sign bits.\n// (Multiplications with constant powers of 2 count as add/sub.)\n// Scaling the grid to regular hexagons would add 2 mults to that,\n// one for the forward scaling and one for the inverse.\n\nvec2 hextiling(vec2 p) {\n\n//#define REGULAR\n\n#ifdef REGULAR\n    p.y *= 2.0/sqrt(3.0);\n#endif\n\t// Lower left vertex p0 of local integer-aligned 1x2 rectangular cell\n\tvec2 p0 = vec2( floor( p.x ), 2.0 * floor( p.y * 0.5 ));\n\t// Midpoint p4 of that cell\n\tvec2 p4 = p0 + vec2(0.5, 1.0);\n\t// Vector from midpoint to p (local cell coordinates)\n\tvec2 v4 = p - p4;\n\n\t// Set px to the closest corner, based on signs of v4.x and v4.y\n    vec2 dx = vec2( ( v4.x < 0.0 ? -0.5 : 0.5 ), ( v4.y < 0.0 ? -1.0 : 1.0 ) );\n\tvec2 px = p4 + dx;\n\n\t// Determine which of the two candidate points is closer.\n\tv4 = p - p4;\n    // Make a linear decision instead of computing the Euclidean distances.\n    // Half the work, but less obvious.\n    // Create the normal to the decision boundary\n    // (It's faster to re-select a different constant than to scale dx.x)\n\tvec2 ex = vec2(( v4.x < 0.0 ) ? -2.0/3.0 : 2.0/3.0, dx.y);\n\t// Use the line equation for points half-way between p4 and px\n\tfloat d = dot(v4, ex)- 2.0/3.0; // If this is negative, p4 is closer\n\t// Return the closest grid point\n    vec2 pc = ( d < 0.0 ? p4 : px );\n#ifdef REGULAR\n    pc.y *= sqrt(3.0)/2.0;\n#endif\n\treturn pc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Use device pixel coordinates for testing\n    vec2 p = fragCoord.xy * 0.015;\n    // p.y *= 2.0/sqrt(3.0); // Squash to regular hexagons\n\n    vec2 gridpoint = hextiling(p); // Nearest grid point\n    vec2 gridvec = p - gridpoint + 0.5;\n    float cell = hash(gridpoint) / 289.0;\n\n    fragColor = vec4(vec3(gridvec, cell),1.0);\n}\n","name":"Image","description":"","type":"image"}]}