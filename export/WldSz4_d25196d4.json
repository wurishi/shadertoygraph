{"ver":"0.1","info":{"id":"WldSz4","date":"1580509031","viewed":131,"name":"highway to miami","username":"Dijkstra","description":"Second try at learning shapes and functions","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarchingminimalist"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 100.\n#define MAX_ITERATION 200.\n\nvec3 hsb2rgb(in vec3 c){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    //rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat lampadaire(vec3 p){\n\tp.z = mod(p.z,50.);\n\tvec3 offset = vec3(-12.,-1.,-50.);\n\treturn min(\n\t\tsdCappedCylinder(p-vec3(0.,0.,0.)+offset, .1, 2.),\n\t\tmax(\n\t\t\tsdEllipsoid(p-vec3(-.4,2.,0.)+offset, vec3(.5,.3,.3)),\n\t\t\t-sdBox(p-vec3(-.4,1.66,0.)+offset, vec3(.5,.3,.3))\n\t\t)\n\t);\n}\n\nfloat sphere(vec3 p, vec3 sp, float radius){\n\treturn length(abs(p-sp))-radius;\n}\n\nfloat ground(vec3 p){\n\tif (abs(p.x) < 10.){\n\t\treturn p.y + max(cos(p.z*.5), .98) + .5;\n\t}\n\telse\n\t\treturn p.y + max(cos(p.z*.5), .98);\n}\n\nfloat scene(vec3 p){\n\treturn min(lampadaire(p), ground(p));\n}\n\nvec3 background(vec2 uv){\n\tvec3 col = hsb2rgb(vec3(.9,1.,1.));\n\tuv.y-=.05;\n\tif(length(uv) < .2 ){\n\t\tcol = hsb2rgb(vec3(.08,1.,1.));\n\t}\n\tcol += .1-log(length(uv)+.5);\n\treturn col;\n}\n\nvec3 reflection(vec2 uv){\n\tuv.y+=.150;\n\tuv.x*=1.2+0.01*sin(uv.y*500.);\n\tvec3 col = vec3(0.);\n\tif(length(uv) < .25 && uv.y<.125){\n\t\tcol = hsb2rgb(vec3(.08,.8-uv.y,1.));\n\t}\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv -= .5;\n    uv.x *= (iResolution.x/iResolution.y);\n\n    vec3 ro = vec3(0.,2.,-3.+iTime*20.); // ray origin\n    vec3 rd = normalize(vec3(uv,1.));\t// ray direction\n    vec3 rp = ro; \t\t\t\t\t\t// ray position\n\n    vec3 shading = background(uv);\n    for(float i=0.; i < MAX_ITERATION; ++i){\n    \tfloat dist = scene(rp);\n    \tif(dist < 0.01){\n    \t\tshading = vec3(i/MAX_ITERATION);\n    \t\tshading *= hsb2rgb(vec3(.64,.7,1.));\n    \t\tbreak;\n    \t}\n    \tif(length(rp-ro) > MAX_DIST) break;\n    \trp += rd * dist;\n    }\n\n    vec3 color = shading;\n    color += reflection(uv)*.05;\n\tcolor = pow(color,vec3(1./2.2)); \n    //color = background(uv);\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}