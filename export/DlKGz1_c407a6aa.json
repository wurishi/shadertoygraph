{"ver":"0.1","info":{"id":"DlKGz1","date":"1683570834","viewed":100,"name":"Code of toilet meme","username":"ilnarildarovuch","description":"Code, what used: https://www.shadertoy.com/view/MsyfRh  https://www.shadertoy.com/view/ltcGDl","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["toilet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\nprecision highp float;\n\nstruct Ray {\n\tvec3 pos;\n\tvec3 dir;\n};\n\n\n// exponential smooth min (k = 32);\nfloat smin( float a, float b, float k ) {\n\tfloat res = exp( -k*a ) + exp( -k*b );\n\treturn -log( res )/k;\n}\n\nvec3 rotX(vec3 v, float a) {\n\ta *= 3.141592 / 180.;\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn vec3(\n\t\tv.x,\n\t\tv.y * c - v.z * s,\n\t\tv.z * c + v.y * s\n\t);\n}\n\nvec3 rotY(vec3 v, float a) {\n\ta *= 3.141592 / 180.;\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn vec3(\n\t\tv.x * c - v.z * s,\n\t\tv.y,\n\t\tv.z * c + v.x * s\n\t);\n}\n\nfloat distBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat dist1(vec3 p) {\n\tif (abs(p.z) < 0.3) p.x += p.z * p.z * sign(p.x);\n\tp.x += p.y * sign(p.x) * 0.04;\n\treturn distBox(p, vec3(0.1, 0.15, 0.2)) - 0.01;\n}\n\nfloat dist2(vec3 p) {\n\tp.x /= 0.55;\n\tp.y -= 0.25;\n\tp.y /= 1.1;\n\tp /= 1.2;\n\tvec2 t = vec2(0.25, 0.06);\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\tfloat d = length(q)-t.y;\n\td = max(d, p.y - 0.01);\n\treturn d;\n}\n\nfloat lengthN(vec2 v, float n) {\n\tv.x = pow(v.x, n);\n\tv.y = pow(v.y, n);\n\treturn pow(v.x + v.y, 1./n);\n}\n\nfloat dist3(vec3 p) {\n\tp.y *= 2.5;\n\tp.x /= 0.55 * 1.3;\n\tp.y -= 0.7;\n\tp.z /= 1.3;\n\tvec2 t = vec2(0.25, 0.06);\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\tfloat d = length(q)-t.y;\n\treturn d;\n}\n\nfloat dist4(vec3 p) {\n\tp.y -= 0.55;\n\tp.y /= 1.4 - min(0., p.y) * 0.7;\n\tp.z += 0.34;\n\tfloat d = length(p.xy) - 0.2;\n\td = max(d, p.z - max(0., length(p.xy) - 0.19));\n\td = max(d, -p.z - 0.01);\n\treturn d;\n}\n\nfloat dist5(vec3 p) {\n    \n\tp.y -= 0.52;\n\tp.y = abs(p.y);\n\tp.y += 0.52;\n\tp.x = abs(p.x);\n\tp.y -= 0.66;\n\tp.x -= 0.12;\n\tp.z += 0.34;\n\n\tfloat d = length(p) - 0.015;\n\td = max(d, -p.z);\n\treturn d;\n}\n\nfloat dist6(vec3 p) {\n\tp.yz -= vec2(0.3, -0.34);\n\tp = rotX(p, 30. * sin(iTime * 10.) - 30.);\n\tp.yz += vec2(0.3, -0.34);\n\treturn min(dist4(p), dist5(p));\n}\n\nfloat dist(vec3 p) {\n\treturn min(min(smin(dist1(p), dist2(p), 25.), dist3(p)), dist6(p));\n}\n\nvec3 getNormal(vec3 p) {\n\tfloat eps = 1e-3;\n\treturn normalize(vec3(\n\t\tdist(p+vec3(eps,0,0)) - dist(p),\n\t\tdist(p+vec3(0,eps,0)) - dist(p),\n\t\tdist(p+vec3(0,0,eps)) - dist(p)\n\t));\n}\n\nvec3 getColor(Ray ray) {\n\tvec3 pos = ray.pos;\n\tfor (int i = 0; i < 100; i++) {\n\t\tfloat d = dist(pos);\n\t\tif (abs(d) < 1e-3) break;\n\t\tpos += ray.dir * d;\n\t}\n\tif (dist(pos) < 1e-3) {\n\t\tfloat ambient = 0.3;\n\t\tvec3 lightPos = vec3(3);\n\t\tvec3 normal = getNormal(pos);\n\t\tfloat diffuse = max(0., dot(normal, normalize(lightPos - pos)));\n\t\treturn vec3(ambient + diffuse);\n\t}\n\treturn vec3(0,0,0);\n}\n\nRay getRay(vec2 screenPos) {\n\tRay ray;\n\tray.pos = vec3(screenPos * 0.4,1);\n\tray.dir = normalize(vec3(screenPos*0.2, -1));\n\n    /*\n\tfloat angleX = -10.;\n\tangleX += sin(iTime) * 20.;\n\tray.pos = rotX(ray.pos, angleX);\n\tray.dir = rotX(ray.dir, angleX);\n\n\tfloat angleY = 0.;\n\tangleY += sin(iTime * 0.2) * 20.;\n\tray.pos = rotY(ray.pos, angleY);\n\tray.dir = rotY(ray.dir, angleY);\n*/\n    float b = -20.;\n\tray.pos = rotX(ray.pos, b);\n\tray.dir = rotX(ray.dir, b);\n        \n    float a = 20. * sin(iTime);\n    ray.pos = rotY(ray.pos, a);\n    ray.dir = rotY(ray.dir, a);\n    \n\n\tray.pos.y += 0.3;\n\treturn ray;\n}\n\n\nfloat fade(float value, float start, float end)\n{\n    return (clamp(value,start,end)-start)/(end-start);\n}\n\nfloat rand(float co) { return fract(sin(co*(1000.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(20.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }\n\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat terrainH( in vec2 p)\n{\n\n    //small\n\tfloat valS = noise(p * 0.5) + 0.5;//0~1\n    valS = 1.0 - abs(valS - 0.5) * 2.0;\n    valS = pow(valS,2.0);\n\n    //middle\n    float valM = noise(p * 0.26) + 0.5;//0~1\n    valM = 1.0 - abs(valM - 0.5) * 2.0;\n    valM = pow(valM,2.0);\n    \n    //big\n    float valB = smoothstep(0.0,1.0,noise(p * 0.2) + 0.5);//0~1\n\n    float val = valS * 0.01 + valM * 0.19 + valB * 0.8;\n\n    return val * 1.3 - 0.3;\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd )\n{\n    // real shadows\t\n    float res = 1.0;\n    float t = 0.001;\n\tfor( int i=0; i<40; i++ )\n\t{\n\t    vec3  p = ro + t*rd;\n        float h = p.y - terrainH( p.xz );\n\t\tres = min( res, 16.0*h/t );\n\t\tt += h;\n\t\tif( res<0.01 ||p.y>(200.0) ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\n\nfloat interesct( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    float t = tmin;\n\tfor( int i=0; i<128; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n\t\tfloat h = pos.y - terrainH( pos.xz );\n\t\tif( h<(0.002*t) || t>tmax ) break;\n\t\tt += 0.5*h;\n\t}\n\treturn t;\n}\n\n\nvec3 calcNormal( in vec3 pos, float t )\n{\n    vec2  eps = vec2( 0.002*t, 0.0 );\n    return normalize( vec3( terrainH(pos.xz-eps.xy) - terrainH(pos.xz+eps.xy),\n                            2.0*eps.x,\n                            terrainH(pos.xz-eps.yx) - terrainH(pos.xz+eps.yx) ) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{   \n    vec3 lightDir = normalize( vec3(-0.8,0.3,-0.3) );\n    vec3 lightColor = vec3(1.0);\n    vec3 sandColor = vec3(0.9,0.70,0.4);\n    vec3 ambientColor = vec3(0.5);\n\n    float tmin = 1.0;\n    float tmax = 30.0;\n    float t = interesct(ro,rd,tmin,tmax);\n\n    vec3 col;\n    if(t>tmax){\n        vec3 sky0 = vec3(0.8,0.7,0.5) * 1.2;\n        vec3 sky1 = vec3(0.4,0.6,0.8) * 1.2;\n        col = mix(sky0,sky1,pow(max(rd.y + 0.15,0.0),0.5));\n        col += vec3(pow(max(dot(rd,lightDir),0.0),50.0));\n    }\n    else{\n        vec3 pos = ro + t*rd;\n        \n        float shadow = softShadow(pos + lightDir *0.01,lightDir);\n        \n        vec3 normal = calcNormal( pos, t );\n        normal = normalize(normal + vec3(sin(pos.x * 100.0 + sin(pos.z * 31.0) + sin(pos.y) * 200.0) * 0.02,0,0));\n        vec3 viewDir = -rd;\n\n        float lambertian = max(dot(lightDir,normal), 0.0);\n\n        float shininess =  20.0;\n        vec3 halfDir = normalize(lightDir + viewDir);\n        float specAngle = max(dot(halfDir, normal), 0.0);\n        float specular1 = pow(specAngle, shininess);\n        float specular2 = pow(specAngle, shininess / 2.0) * noise(pos.xz * 10000.0) * 1.0f;// * pow(texture(iChannel0,pos.xz * 10.0).x,3.0);\n\n        vec3 diff = sandColor * lambertian * lightColor;\n        vec3 spec = (specular1 *0.3 + specular2 * 0.2) * lightColor;\n        vec3 ambient = ambientColor * sandColor;\n        col = shadow * (diff + spec) + ambient;\n\n    }\n    \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float time = iTime * 0.5;\n    //float yaw = time;//iMouse.x * 0.05;\n    //float pitch = 1.2;//clamp(iMouse.y * 2.0 /iResolution.y,-PI * 0.5,PI * 0.5);\n    \n    float yaw;\n    float pitch;\n    \n    if(iMouse.x == 0.0 && iMouse.y == 0.0){\n    \tyaw = time;\n    \tpitch = 1.2;        \n    }\n    else{\n        yaw = iMouse.x * 0.05;\n    \tpitch = clamp(iMouse.y  * 2.0 /iResolution.y,-PI * 0.5,PI * 0.5);\n    }\n    \n    vec2 p0 = fragCoord.xy / iResolution.xy;\n    p0.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = 1.1*vec3(2.5*sin(0.25*yaw),2.5 * cos(pitch),2.5*cos(0.25*yaw));\n    vec3 ww = normalize(vec3(0.0) - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p0.x*uu + p0.y*vv + 2.5*ww );\n\n    vec3 col3 = render( vec3(time,1.8,0.0), rd );\n    float fading = (fade(time,-2.,4.));\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 noise = vec3(rand(uv*(time / fading / time + (time * 0.001) )));\n    // Time varying pixel color\n    vec3 col2 = 1.0 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec2 screenPos = (fragCoord / iResolution.xy - 0.5) * vec2(iResolution.x /iResolution.y, 1) * 2.;\n\n\t// Main Code Here...\n\tvec3 col = getColor(getRay(screenPos));\n    // Output to screen\n    fragColor = vec4(pow(noise, vec3(0.000001))*col2*pow(col3, col),1.0);\n}","name":"Image","description":"","type":"image"}]}