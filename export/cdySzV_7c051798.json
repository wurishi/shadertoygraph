{"ver":"0.1","info":{"id":"cdySzV","date":"1724953502","viewed":80,"name":"neural network test123 copy0","username":"Anon3242","description":"This is very crude and dumb and bad implementation of a simple nn trying to fit a sine wave...\nThe blinking numbers are neural network weights and biases\nBackground dot cloud is live loss monitor\nThe blue/red checker is neurons\nView in 800x450","likes":4,"published":1,"flags":32,"usePreview":1,"tags":["nn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n    //sharper\n    //return ceil(textureGrad( iChannel3, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) ).xxxx-0.6);\n\t\n    return textureGrad( iChannel3, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) ).xxxx;\n}\n\nvec4 printdec(float n, vec2 U, vec4 O){\n    \n    //O+= char(U,61);\n    //U.x-=.5; \n    if(n<0.0){\n        O+=char(U,45);\n        U.x-=.5;\n        n=-n;\n    }else{U.x-=.5;}\n    \n    O+= char(U,48+int(mod(n/100000.0,10.0)));\n    U.x-=.5; \n    O+= char(U,48+int(mod(n/10000.0,10.0)));\n    U.x-=.5; \n    O+= char(U,48+int(mod(n/1000.0,10.0)));\n    U.x-=.5; \n    O+= char(U,48+int(mod(n/100.0,10.0)));\n    U.x-=.5; \n    O+= char(U,48+int(mod(n/10.0,10.0)));\n    U.x-=.5; \n    O+= char(U,48+int(mod(n,10.0)));\n    U.x-=.5; \n\n    return O;\n}\n\nvec4 printfloat(float n, vec2 U, vec4 O){\n    \n    //O+= char(U,61);\n    //U.x-=.5; \n    if(n<0.0){\n        O+=char(U,45);\n        U.x-=.5;\n        n=-n;\n    }else{U.x-=.5;}\n    O+= char(U,48+int(mod(n/1000.0,10.0)));\n    U.x-=.5; \n    O+= char(U,48+int(mod(n/100.0,10.0)));\n    U.x-=.5; \n    O+= char(U,48+int(mod(n/10.0,10.0)));\n    U.x-=.5; \n    O+= char(U,48+int(mod(n,10.0)));\n    U.x-=.5; \n    O+= char(U,46);\n    U.x-=.5; \n    O+= char(U,48+int(mod(n*10.0,10.0)));\n    U.x-=.5; \n    O+= char(U,48+int(mod(n*100.0,10.0)));\n    U.x-=.5; \n    O+= char(U,48+int(mod(n*1000.0,10.0)));\n    \n    return O;\n}\n\nvec4 pix(vec2 fragCoord,vec2 xy){\n    float size=0.6;\n    //if(fragCoord.x>=xy.x-size && fragCoord.x<=xy.x+size && fragCoord.y>=xy.y-size && fragCoord.y<=xy.y+size)\n    if(  fragCoord==vec2(float(int(xy.x))+0.5,float(int(xy.y))+0.5)  )\n    //if(fragCoord==xy)\n    {\n        return vec4(vec3(1.0),1.0);\n    }\n    else{return vec4(vec3(0.0),1.0);}\n}\n\nvoid mainImage( out vec4 O, vec2 coord )\n{\n    \n    O = vec4(0.0);\n    vec2 uv = coord/iResolution.y;\n    ivec2 icoord = ivec2(coord);\n    vec2 m = iMouse.xy/iResolution.y;\n    vec2 position = m;\n    position = vec2(0.0,0.0);\n    float FontSize = 4.92;\n    vec2 U = ( uv - position+vec2(0.015,0.002))*64.0/FontSize;\n\n\n    \n    O=printfloat(iTime,U,O);\n    \n    U.y-=0.8;\n    O=printdec(0.0+mod(iTime*2.0,256.0),U,O);\n    U.x-=3.5;O+=char(U,32);\n    U.x-=0.5;\n    O+= vec4(char(U,0+int(mod(iTime*2.0,256.0))).x,0,0,1.0);\n    U.x+=4.0;\n    \n    U.y-=0.8;\n    O=printfloat(iTimeDelta*10000.0,U,O);\n    \n    U.y-=0.8;\n    O=printdec(float(iFrame),U,O);\n    \n    //U.y-=1.6;\n    //O+= char(U,64+24);\n    //U.x-=.5; \n    //U.x-=.5;\n    //O=printfloat(m.x,U,O);\n    \n    //U.x-=5.0;\n    //O+= char(U,64+25);\n    //U.x-=.5; \n    //U.x-=.5;\n    //O=printfloat(m.y,U,O);\n    \n    \n    //U.y-=0.8;\n    //U.x+=7.0;\n    //O+= char(U,64+24);\n    //U.x-=.5; \n    //U.x-=.5;\n    //O=printfloat(iMouse.x,U,O);\n    \n    //U.x-=5.0;\n    //O+= char(U,64+25);\n    //U.x-=.5; \n    //U.x-=.5;\n    ///O=printfloat(iMouse.y,U,O);\n     \n    if(int(coord.x)>=401 && int(coord.x)<=799){\n        //O+=pix(coord,vec2(coord.x,GETVAL0(int(coord.x)-399,0).x));\n        //O+=pix(coord,vec2(coord.x,GETVAL0(int(coord.x),0).x));\n        O+=pix(coord,vec2(coord.x,1600.0*GETVAL0(int(coord.x)-399,2).x));\n    }\n    \n    //for(int i=1;i<=400;i++){\n        //O+=pix(coord,vec2(400+i,GETVAL(i,0)));\n    //}\n    //for(int i=401;i<=799;i++){\n    //    O+=pix(coord,vec2(i,GETVAL(i,0)));\n    //}\n    \n    U.x+=0.0;\n    U.y-=0.8;\n    \n    \n    //U.y-=0.8;O=printfloat(GETVAL0(0,2).x,U,O);\n    //U.y-=0.8;O=printfloat(GETVAL0(200,2).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(0,0).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(0,1).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(0,2).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(0,3).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(0,4).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(0,5).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(0,6).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(0,7).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL0(0,3).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL0(400,2).x,U,O);\n    U.y-=0.8;O=printfloat(sin(rand()*6.28 - 3.14)-GETVAL2(4,1).x,U,O);\n    \n    U.x-=5.0;\n    U.y+=8.0;\n    O=printfloat(GETVAL2(1,0).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(1,1).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(1,2).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(1,3).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(1,4).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(1,5).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(1,6).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(1,7).x,U,O);\n    \n    U.x-=5.0;\n    U.y+=5.6;\n    O=printfloat(GETVAL2(2,0).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(2,1).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(2,2).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(2,3).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(2,4).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(2,5).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(2,6).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(2,7).x,U,O);\n    \n    U.x-=5.0;\n    U.y+=5.6;\n    O=printfloat(GETVAL2(3,0).x,U,O);\n   \n    \n    //U.y-=0.8;O=printfloat(fract(sin((iFrame/100.+1.0)*(91.3458)) * 47453.5453),U,O);\n    //O=mix(O,vec4(uv.x,uv.y,0.0,1.0),m.y);\n    //O = O.xxxx;\n    //U.y-=0.8;\n    //if(uv.y>0.5)O=vec4(printfloat(1234.56,U,O).x,0,0,1.0);\n    \n    O += 0.4*vec4(uv.x,uv.y,0.0,0.0);\n    \n    //function print\n    if(int(coord.x)>=0 && int(coord.x)<=799){\n        //O+=pix(coord,vec2(coord.x,sin((coord.x-iMouse.y)/100.0*4.0*m.x)*100.0+200.0));\n        \n        //O+=pix(coord,vec2(coord.x,400.0*sigmoid(coord.x/50.0-8.0)));\n        //O+=pix(coord,vec2(coord.x,400.0*sigmoid_derivative(coord.x/50.0-8.0)));\n        //O+=pix(coord,vec2(coord.x,mod(coord.x,100.0)));\n    }\n    \n    if(int(coord.x)>=int(300.0-testrange*50.0) && int(coord.x)<=int(300.0+testrange*50.0-1.0)){\n        O+=pix(coord,vec2(coord.x,60.0+50.0*GETVAL2(6,coord.x-(300.0-testrange*50.0)).x));\n    }\n    \n    if(int(coord.x)>=int(300.0-(testrange*50.0)) && int(coord.x)<=int(300.0+testrange*50.0)){\n        float x=(coord.x-300.0)/(50.0*testrange)*testrange*pi;\n        O+=pix(coord,vec2(coord.x,60.0+50.0*sin(x)));\n    }\n    \n    O+=texelFetch(iChannel0,ivec2(int(coord.x),int(coord.y)),0).xyzw/200.0;\n    \n    if(icoord.x>=730 && icoord.x<=800 && icoord.y >=(450-(NHIDDEN+2)*10) && icoord.y <=450){\n        icoord=icoord-ivec2(730,(450-(NHIDDEN+2)*10));\n        float val=texelFetch(iChannel2,ivec2(icoord/10),0).x;\n        if(val>0.0){\n            O=0.7*abs(val*vec4(0.14, 0.36, 0.91,0));\n        }else{\n            O=0.7*abs(val*vec4(0.78,0.15,0.15,0));\n        }\n        if(icoord.x%10==0)O=vec4(0.2);\n        if(icoord.y%10==0)O=vec4(0.2);  \n    }\n    \n}\n\n\n//line 12 -> x,y coordinates of text, counted from left down corner","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define GETVAL0(INDEXX,INDEXY) texelFetch(iChannel0,ivec2(INDEXX,INDEXY),0)\n#define GETVAL0x(INDEXX,INDEXY) texelFetch(iChannel0,ivec2(INDEXX,INDEXY),0).x\n#define GETVAL1(INDEXX,INDEXY) texelFetch(iChannel1,ivec2(INDEXX,INDEXY),0)\n#define GETVAL2(INDEXX,INDEXY) texelFetch(iChannel2,ivec2(INDEXX,INDEXY),0)\n#define rand() fract(sin((float(iFrame)/100.+1.0)*(91.3458)) * 47453.5453)\n#define randidate() fract(sin((float(iDate.w)/100.+1.0)*(91.3458)) * 47453.5453)\n\n#define NHIDDEN 6\n#define LEARNING_RATE 0.01\n#define EPOCHS 1000000\n#define TESTINTERVAL 500.0\n#define pi 3.1416\n#define trainrange 1.0\n#define testrange 1.0\n\nfloat sigmoid(float x) {\n    return x>0.0?x:0.0;//ReLU\n    //return 1.0 / (1.0 + exp(-x));//Sigmoid\n}\n\nfloat sigmoid_derivative(float x) {\n    return x>0.0?1.0:0.0;//ReLU\n    //return x * (1.0 - x);//Sigmoid\n}\n\nfloat loss(float outp, float target) {\n    return pow(outp - target, 2.0);\n}\n\n//float rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\n//float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\n//float rand(vec3 co){ return rand(co.xy+rand(co.z)); }\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define SETVALX(INDEXX,INDEXY,VAL) if(int(fragCoord.x)==INDEXX && int(fragCoord.y)==INDEXY) fragColor=vec4(VAL,fragColor.y,fragColor.z,fragColor.w)\n#define SETVALY(INDEXX,INDEXY,VAL) if(int(fragCoord.x)==INDEXX && int(fragCoord.y)==INDEXY) fragColor=vec4(fragColor.x,VAL,fragColor.z,fragColor.w)\n#define SETVALZ(INDEXX,INDEXY,VAL) if(int(fragCoord.x)==INDEXX && int(fragCoord.y)==INDEXY) fragColor=vec4(fragColor.x,fragColor.y,VAL,fragColor.w)\n#define SETVALW(INDEXX,INDEXY,VAL) if(int(fragCoord.x)==INDEXX && int(fragCoord.y)==INDEXY) fragColor=vec4(fragColor.x,fragColor.y,fragColor.z,VAL)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // (DEFAULT) COPY\n    fragColor=texelFetch(iChannel0,ivec2(fragCoord),0);\n    //float arr[4];\n    \n    //y=0,3\n    if(int(fragCoord.y)>=0 && int(fragCoord.y)<=3){\n    \n        //[0-400,0]\n        if(int(fragCoord.x)>=0 && int(fragCoord.x)<=399 && int(fragCoord.y)==0){\n            //SETVALX(int(fragCoord.x),0,GETVAL0(int(fragCoord.x)+1,0).x);\n            fragColor=vec4(GETVAL0(int(fragCoord.x)+1,0).x,fragColor.y,fragColor.z,fragColor.w);\n        }\n        SETVALX(400,0,iTimeDelta*10000.0);\n        \n        //[401-799,0]\n        if(int(fragCoord.x)>=401 && int(fragCoord.x)<=798){\n            SETVALX(int(fragCoord.x),0,GETVAL0(int(fragCoord.x)+1,0).x);\n        }\n        SETVALX(799,0,iMouse.y);\n        \n        //[0-3,1]\n        if(int(fragCoord.x)>=0 && int(fragCoord.x)<=3 && int(fragCoord.y)==1){\n            fragColor=vec4(GETVAL0(fragCoord.x,1).x+1.0,fragColor.y,fragColor.z,fragColor.w);\n        }\n        \n        //LIVE LOSS MONITOR@[0-400,2]\n        if(int(fragCoord.x)>=0 && int(fragCoord.x)<=399 && int(fragCoord.y)==2){\n            //SETVALX(int(fragCoord.x),0,GETVAL0(int(fragCoord.x)+1,0).x);\n            fragColor=vec4(GETVAL0(int(fragCoord.x)+1,2).x,fragColor.y,fragColor.z,fragColor.w);\n        }\n        SETVALX(400,2,GETVAL1(4,0).x);\n        \n        //IF TEST: USING LATEST TEST TO UPDATE RMSE@0,3\n        if(mod(float(iFrame),TESTINTERVAL)==(testrange*100.0+1.0)){\n            float losssum=0.0;\n            for(int i=int(400.0+1.0-testrange*100.0);i<=400;i++){\n                losssum+=GETVAL0x(i,2);\n            }\n            SETVALX(0,3,sqrt(losssum/(testrange*100.0)));\n        }\n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define SETVALX(INDEXX,INDEXY,VAL) if(int(fragCoord.x)==INDEXX && int(fragCoord.y)==INDEXY) fragColor=vec4(VAL,fragColor.y,fragColor.z,fragColor.w)\n#define SETVALY(INDEXX,INDEXY,VAL) if(int(fragCoord.x)==INDEXX && int(fragCoord.y)==INDEXY) fragColor=vec4(fragColor.x,VAL,fragColor.z,fragColor.w)\n#define SETVALZ(INDEXX,INDEXY,VAL) if(int(fragCoord.x)==INDEXX && int(fragCoord.y)==INDEXY) fragColor=vec4(fragColor.x,fragColor.y,VAL,fragColor.w)\n#define SETVALW(INDEXX,INDEXY,VAL) if(int(fragCoord.x)==INDEXX && int(fragCoord.y)==INDEXY) fragColor=vec4(fragColor.x,fragColor.y,fragColor.z,VAL)\n//FORWARD PASS I->H\n//IN: input (GLOBAL: rand of iFrame, reranged), weights_ih [0,0-3], bias_h [2,0-3]\n//OUT: hidden [5, 0-3], DEFAULT COPY\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float inp=rand()*trainrange*pi*2.0 - trainrange*pi;\n    ivec2 icoord = ivec2(fragCoord);\n    fragColor=texelFetch(iChannel0,ivec2(fragCoord),0);\n    \n    //IF TEST\n    if(mod(float(iFrame),TESTINTERVAL)<(testrange*100.0)){\n        inp=(mod(float(iFrame),TESTINTERVAL)-(testrange*50.0))/(testrange*50.0)*testrange*pi;\n    }\n    \n    if(icoord.x == 5 && icoord.y>=0 && icoord.y<NHIDDEN){\n        for(int i=0;i<NHIDDEN;i++){\n            SETVALX(5,i,sigmoid(GETVAL0x(2,i)+inp*GETVAL0x(0,i)));\n            //---DEBUG---\n            //SETVALX(5,i,float(i)/5.0);\n            //SETVALX(5,i,sigmoid(GETVAL0x(2,i)+inp*GETVAL0x(0,i)));\n            //-----------\n        }\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define SETVALX(INDEXX,INDEXY,VAL) if(int(fragCoord.x)==INDEXX && int(fragCoord.y)==INDEXY) fragColor=vec4(VAL,fragColor.y,fragColor.z,fragColor.w)\n#define SETVALY(INDEXX,INDEXY,VAL) if(int(fragCoord.x)==INDEXX && int(fragCoord.y)==INDEXY) fragColor=vec4(fragColor.x,VAL,fragColor.z,fragColor.w)\n#define SETVALZ(INDEXX,INDEXY,VAL) if(int(fragCoord.x)==INDEXX && int(fragCoord.y)==INDEXY) fragColor=vec4(fragColor.x,fragColor.y,VAL,fragColor.w)\n#define SETVALW(INDEXX,INDEXY,VAL) if(int(fragCoord.x)==INDEXX && int(fragCoord.y)==INDEXY) fragColor=vec4(fragColor.x,fragColor.y,fragColor.z,VAL)\n//FORWARD PASS H->O\n//IN: hidden [5, 0-3], weights_ho [1, 0-3]\n//OUT: output@4,1, DEFAULT COPY\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 icoord = ivec2(fragCoord);\n    fragColor=texelFetch(iChannel0,ivec2(fragCoord),0);\n    \n    if(icoord.x==4 && icoord.y==1){\n        float actsum=0.0;\n        for(int i=0;i<NHIDDEN;i++){\n            actsum+=GETVAL0x(5,i) * GETVAL0x(1,i);\n        }\n        SETVALX(icoord.x,icoord.y,actsum);\n    }\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"#define SETVALX(INDEXX,INDEXY,VAL) if(int(fragCoord.x)==INDEXX && int(fragCoord.y)==INDEXY) fragColor=vec4(VAL,fragColor.y,fragColor.z,fragColor.w)\n#define SETVALY(INDEXX,INDEXY,VAL) if(int(fragCoord.x)==INDEXX && int(fragCoord.y)==INDEXY) fragColor=vec4(fragColor.x,VAL,fragColor.z,fragColor.w)\n#define SETVALZ(INDEXX,INDEXY,VAL) if(int(fragCoord.x)==INDEXX && int(fragCoord.y)==INDEXY) fragColor=vec4(fragColor.x,fragColor.y,VAL,fragColor.w)\n#define SETVALW(INDEXX,INDEXY,VAL) if(int(fragCoord.x)==INDEXX && int(fragCoord.y)==INDEXY) fragColor=vec4(fragColor.x,fragColor.y,fragColor.z,VAL)\n//IF FIRST FRAME THROW C OUT, INIT ALL PARAMS ONLY\n//BACKWARD PASS, EDITED FOR PARALLEL\n//IN: GLOBAL target=sin((ranged)rand()), GLOBAL input=(ranged)rand(), output@4,1,  hidden [5, 0-3], \n//OUT: weights_ho[1,0-3], bias_o@3,0, weights_ih[0,0-3], bias_h[2,0-3], loss@4,0, test_output[6,0-testrange*100-1]\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float inp=rand()*2.0*trainrange*pi - trainrange*pi;\n    \n    //IF TEST\n    if(mod(float(iFrame),TESTINTERVAL)<(testrange*100.0)){\n        inp=(mod(float(iFrame),TESTINTERVAL)-(testrange*50.0))/(testrange*50.0)*testrange*pi;\n    }\n    \n    float target=sin(inp);\n    ivec2 icoord = ivec2(fragCoord);\n    fragColor=texelFetch(iChannel0,ivec2(fragCoord),0);\n    \n    if(iFrame==0){//INIT AND RETURN\n        for(int i=0;i<NHIDDEN;i++){//INIT weights_ih\n            SETVALX(0,i,fract(randidate()+0.41+float(i)/30.0+0.07*float(i%2)+0.08*float(i%3))*2.0-1.0);\n        }\n        for(int i=0;i<NHIDDEN;i++){//INIT weights_ho\n            SETVALX(1,i,fract(randidate()+0.53+float(i)/30.0+0.063*float((i+3)%2)+0.072*float((i+2)%3))*2.0-1.0);\n        }\n        for(int i=0;i<NHIDDEN;i++){//INIT bias_h\n            SETVALX(2,i,fract(randidate()+0.66+float(i)/30.0+0.083*float((i+5)%2)+0.069*float((i+4)%3))*2.0-1.0);\n            //SETVALX(2,i,fract(randidate()+0.6+float(i)/30.0)*1.0-0.5);\n        }\n        SETVALX(3,0,fract(randidate()+0.75)*2.0-1.0);//INIT bias_o\n        //SETVALX(3,0,fract(randidate()+0.7)*1.0-0.5);//INIT bias_o\n        return;\n    } \n    \n    //SET LOSS FOR LOG\n    SETVALX(4,0,loss(GETVAL0x(4,1),target));\n    \n    //IF TEST, WRITE TEST OUTPUT DATA AND DO NOT UPDATE\n    if(mod(float(iFrame),TESTINTERVAL)<(testrange*100.0)){\n        SETVALX(6,int(mod(float(iFrame),TESTINTERVAL)),GETVAL0x(4,1));\n        return;\n    }\n    \n    if(icoord.x==3 && icoord.y==0){//update bias_o\n        SETVALX(icoord.x,icoord.y,fragColor.x-LEARNING_RATE*(GETVAL0x(4,1)-target));//BIASO\n    }\n    \n    if(icoord.x>=0 && icoord.x<=2 && icoord.y>=0 && icoord.y<NHIDDEN){\n        for(int i=0;i<NHIDDEN;i++){\n            //update weights_ho\n            SETVALX(1,i,fragColor.x-LEARNING_RATE*(GETVAL0x(4,1)-target)*GETVAL0x(5,i));\n            //update bias_h\n            SETVALX(2,i,fragColor.x-LEARNING_RATE*(GETVAL0x(4,1)-target)*(GETVAL0x(1,i)-LEARNING_RATE*(GETVAL0x(4,1)-target)*GETVAL0x(5,i))*sigmoid_derivative(GETVAL0x(5,i)));\n            //update weights_ih\n            SETVALX(0,i,fragColor.x-LEARNING_RATE*(GETVAL0x(4,1)-target)*(GETVAL0x(1,i)-LEARNING_RATE*(GETVAL0x(4,1)-target)*GETVAL0x(5,i))*sigmoid_derivative(GETVAL0x(5,i)) * inp);\n        }\n    }\n    \n    //DEBUGGING\n    //if(icoord.x>=0 && icoord.x<=2 && icoord.y>=0 && icoord.y<=3){fragColor=vec4(0.5,0,0,0);}\n    \n}","name":"Buffer D","description":"","type":"buffer"}]}