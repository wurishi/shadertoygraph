{"ver":"0.1","info":{"id":"3s33Wf","date":"1569868373","viewed":846,"name":"Transparent screen","username":"TambakoJaguar","description":"This is a screen of the newest technology, OLED on a glass plate. You can draw on it!\nKeyboard:\nUP/DOWN or PGUP/PGDOWN to change the zoom\nD: Draw\nF: Move around with the mouse\nLEFT/RIGHT: change thickness\n0-1: change pen color or R random\nC: clear screen","likes":38,"published":1,"flags":48,"usePreview":0,"tags":["screen","transparent"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float get_zoom()\n{\n    float zoomfact = texture(iChannel2, (addr_zoom + vec2(0.5, 0.5))/iResolution.xy).r;\n    return zoomfact==0.?1.:zoomfact;\n}\n\nbool get_dmode()\n{\n    float dmode = texture(iChannel2, (addr_mode + vec2(0.5, 0.5))/iResolution.xy).r;\n    return dmode==0.;\n}\n\nvec2 get_mouse()\n{\n    return texture(iChannel2, (addr_mouse + vec2(0.5, 0.5))/iResolution.xy).rg;\n}\n\n#ifdef wall_bump\nfloat getNormal2(vec3 pos, float objnr)\n{\n    if (int(objnr)==ROOM_OBJ && pos.y<roomSize.y - 0.012)\n    {\n        #ifdef doors\n        if ((abs(pos.z)>0.5*doorSize.x + 2.*dfSize.x || pos.y>doorSize.y + 2.*dfSize.x || abs(pos.x)>roomSize.x*1.5) && pos.y>2.*dfSize.x)\n        #endif\n        return -0.0022*noise(pos*58.);\n    }\n}\n#endif\n\nvec3 getNormal(vec3 pos, float e, bool inside)\n{  \n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e2 = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        vec2 mr = map(pos + e*e2, inside, false);\n        n += e2*mr.x;\n        #ifdef wall_bump\n        n += e2*getNormal2(pos + e*e2, mr.y);\n        #endif        \n    }\n    return normalize(n);\n}\n\n// Gets the color of the sky\nvec3 getSkyColor(vec3 ray)\n{ \n   return vec3(0.);\n}\n\nvec4 getScreenColor(vec3 pos)\n{\n   pos.xy = getScreenCords(pos);\n   vec4 col = texture(iChannel1, pos.xy + vec2(0.5)/iResolution.xy);\n   //col.a = 0.97 - min(pow((col.r + col.b + col.g)/3., 0.8), 0.6);\n   col.a = 1. - min(pow((col.r + col.b + col.g)/3., 0.8), 0.55);\n   if (col.rgb!=vec3(0.))\n      col.rgb = normalize(col.rgb);\n    \n   // Pixel texture\n   vec2 ppos = fract(pos.xy*iResolution.xy);\n   col.a = mix(col.a, 1. - 1.5*pow(abs(1. - 2.*ppos.x)*abs(1. - 2.*ppos.y), 0.38)*(1. - col.a), smoothstep(4.3, 9.2, get_zoom()));\n \n   return col;  \n}\n\nvec3 getFloorColor(vec3 pos)\n{\n    #ifdef parquet\n    pos.x+= mod(floor(pos.z/psize.y), 2.)==1.?psize.x*0.5:0.;\n    \n    float pnum = floor(pos.x/psize.x) + 1000.*floor(pos.z/psize.y);\n    vec2 offset = vec2(hash(pnum*851.12), hash(pnum*467.54));\n    vec3 cm = (0.5 + 0.5*hash(pnum*672.75))*floor_color;\n    float sf = 0.8 + 0.4*hash(pnum*218.47);\n    float ra = 0.15*hash(pnum*951.68);\n    \n    pos.xz = rotateVec(pos.xz, ra);\n    return mix(cm, texture(iChannel0, 0.35*sf*pos.xz + offset).rgb, 0.65);\n    #else\n    return floor_color;\n    #endif\n}\n\nvec3 getRoomColor(vec3 pos)\n{\n    vec3 col = pos.y<roomSize.y - 0.0106?walls_color:ceiling_color;\n    \n    #ifdef doors\n    if (abs(pos.z)<0.5*doorSize.x + 2.*dfSize.x && pos.y<doorSize.y + 2.*dfSize.x && abs(pos.x)<roomSize.x*1.5 || pos.y<2.*dfSize.x)\n       col = dframe_color;\n    #endif\n    return col;\n}\n\nfloat getClampsInt(vec3 pos)\n{\n    float ds = 0.05;\n    float lx = cLampSize.x*float(nbCLamps)/roomSize.x;\n    float ly = cLampSize.y*float(nbCLamps)/roomSize.z;\n    float lx2 = roomSize.x/float(nbCLamps) - cLampSize.x;\n    float ly2 = roomSize.z/float(nbCLamps) - cLampSize.y;\n    float tx = fract(float(nbCLamps)*(pos.x/(roomSize.x - lx2 + 0.75) + 0.5));\n    float ty = fract(float(nbCLamps)*(pos.z/(roomSize.z - ly2 + 0.75) + 0.5));\n    return smoothstep(.5 - lx/2. - ds/2., 0.5 - lx/2. + ds/2., tx)*smoothstep(0.5 + lx/2. + ds/2., 0.5 + lx/2. - ds/2., tx)*smoothstep(.5 - ly/2. - ds/2., 0.5 - ly/2. + ds/2., ty)*smoothstep(0.5 + ly/2. + ds/2., 0.5 + ly/2. - ds/2., ty);\n}\n\n// Combines the colors\nvec3 getColor(vec3 norm, vec3 pos, int objnr, vec3 ray)\n{\n   if (objnr==FLOOR_OBJ)\n      return getFloorColor(pos);   \n   else if (objnr==SUPPORT_OBJ)\n      return support_color;     \n   else if (objnr==ROOM_OBJ)\n      return getRoomColor(pos);\n}\n\n// Shading of the objects pro lamp\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, int objnr, int lampnr)\n{   \n    vec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n    float dnp = dot(norm, pli);\n      \n    // Diffuse shading\n    vec3 col = ocol*lamp.color*lamp.intensity*smoothstep(-0.1, 1., dnp); //clamp(dnp, 0., 1.);\n    \n    // Softshadow\n    #ifdef shadow\n    col*= shi*calcSoftshadow(pos, normalize(lamp.position - pos)) + 1. - shi;\n    #endif    \n    \n    // Specular shading\n    #ifdef specular\n    if (objnr!=ROOM_OBJ)\n       col+= lamp.color*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif  \n    \n    return col;\n}\n\n// Shading of the objects over all lamps\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, int objnr)\n{\n    vec3 col = vec3(0.);\n    for (int l=ZERO; l<lamps.length(); l++)\n       col+= lampShading(lamps[l], norm, pos, ocol, objnr, l);\n    \n    if (objnr==ROOM_OBJ && abs(pos.x)<roomSize.z*0.5)\n       col = mix(col, lampsColor, getClampsInt(pos));\n    \n    #ifdef show_leds        \n    if (objnr==RLED_OBJ)\n       col = (iMouse.w<0. || !get_dmode()?redledColor:orangeledColor)*(0.4 + 2.5*dot(norm, vec3(0., 0., -1.)));\n    if (objnr==GLED_OBJ)\n       col = greenledColor*(0.4 + 2.5*dot(norm, vec3(0., 0., -1.)));\n    if (objnr==SUPPORT_OBJ)\n       col+= 1.5*max(0.07 - map_rled(pos), 0.)*(iMouse.w<0. || !get_dmode()?redledColor:orangeledColor);\n    if (objnr==SUPPORT_OBJ)\n       col+= 1.5*max(0.07 - map_gled(pos), 0.)*greenledColor;    \n    #endif      \n    \n    return col;\n}\n\n// Tracing and rendering a ray\nRenderData trace0(vec3 tpos, vec3 ray, float maxdist, bool inside)\n{\n    vec2 tr = trace(tpos, ray, maxdist, inside);\n    float tx = tr.x;\n    int objnr = int(tr.y);\n    vec3 col;\n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    \n    if (tx<maxdist*0.95)\n    {\n        norm = getNormal(pos, normdelta, inside);\n        col = getColor(norm, pos, objnr, ray);\n      \n        // Shading\n        col = col*ambientColor*ambientint + lampsShading(norm, pos, col, objnr);\n    }\n    else\n    {\n        objnr = SKY_OBJ;\n        col = getSkyColor(ray);\n    }\n    return RenderData(col, pos, norm, objnr);\n}\n\n// Main render function with reflections and refractions\nvec4 render(vec2 fragCoord)\n{   \n  \tvec2 uv = fragCoord.xy / iResolution.xy; \n  \tuv = uv*2.0 - 1.0;\n  \tuv.x*= iResolution.x / iResolution.y;\n\n  \tvec3 ray = GetCameraRayDir(uv, camdir, fov*get_zoom());\n  \tRenderData traceinf = trace0(campos, ray, maxdist, false);\n  \tvec3 col = traceinf.col;\n  \tbool inside = false;\n  \tfloat cior = glassMat.ior;\n  \tvec3 glassf = vec3(1.);\n    vec3 refray;\n    vec3 pos0 = traceinf.pos;\n\n    glassf = vec3(1.);\n\n    for (int i=ZERO; i<nbref; i++)\n    {\n        if (traceinf.objnr==SCREEN_OBJ)\n        {\t \n            float rf;\n            \n            if(!inside)\n            {\n               refray = reflect(ray, traceinf.norm);\n               rf = fresnel(ray, traceinf.norm, glassMat.ior);\n               RenderData traceinfR = trace0(traceinf.pos, refray, maxdist, false);\n               col = mix(col, traceinfR.col, glassf*rf);\n               glassf*= (1. - rf);\n            }\n            \n            cior = inside?1./glassMat.ior:glassMat.ior;\n\n            vec3 ray_r = refract(ray, traceinf.norm, 1./cior);\n            if (length(ray_r)!=0.)\n                inside = !inside;\n            else\n                ray_r = reflect(ray, traceinf.norm);            \n\n            vec3 pos = traceinf.pos;\n\n            traceinf = trace0(pos + 0.03*ray_r, ray_r, maxdist, inside);\n            if (inside)\n                glassf*= getGlassAbsColor(distance(pos, traceinf.pos), glassMat.col_vol);\n            glassf*= glassMat.col_fil;\n            \n            if (pos.z<0.)\n            {\n               vec4 sc = getScreenColor(pos);\n               vec3 grc = mix((inside?1.3:1.1)*sc.rgb, clamp(traceinf.col, 0., 1.), sc.a);\n               col+= clamp(glassf*(grc + (inside?1.7:1.1)*sc.rgb*(1. - sc.a)), 0., 1.);                \n               glassf*= pow(sc.a, 3.);              \n            }\n            else\n               col+= clamp(traceinf.col*glassf, 0., 1.);\n\n            ray = ray_r;\n        }\n        if (traceinf.objnr==SKY_OBJ)\n        {\n            break;\n        }\n        #ifdef floor_reflection\n        if (traceinf.objnr==SUPPORT_OBJ || traceinf.objnr==FLOOR_OBJ)\n        {\n            refray = reflect(ray, traceinf.norm);\n           \n            float rf = fresnel(ray, traceinf.norm, 1.7);\n            traceinf = trace0(traceinf.pos, refray, maxdist*0.5, false);\n            traceinf.col*= 0.5 + 0.5*pow(smoothstep(roomSize.x*1.1, roomSize.x*0.5, abs(traceinf.pos.x)), 3.);\n           \n            col = clamp(mix(col, traceinf.col, rf*glassf), 0., 1.);\n            glassf*= rf;\n            ray = refray;\n        }\n        #endif\n    }\n    \n    #ifdef doors\n    col*= 0.3 + 0.7*pow(smoothstep(roomSize.x*1.4, roomSize.x*0.5, abs(pos0.x)), 3.);\n    #endif    \n    \n  \treturn vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    init(iTime);\n    setCamera(get_mouse(), iResolution.xy);\n    \n    // Antialiasing\n    #ifdef antialias\n    vec4 vs = vec4(0.);\n    for (aaj=0;aaj<aasamples ;aaj++)\n    {\n       float oy = float(aaj)*aawidth/max(float(aasamples-1), 1.);\n       for (aai=0;aai<aasamples ;aai++)\n       {\n          float ox = float(aai)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    fragColor = vs/vec4(aasamples*aasamples);\n    #else\n    fragColor = vec4(render(fragCoord));\n    #endif\n    \n    //vec2 uv = fragCoord/iResolution.xy;\n    //fragColor = texture(iChannel2, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float KEY_C = 67.5/256.0;\n\nfloat get_zoom()\n{\n    float zoomfact = texture(iChannel2, (addr_zoom + vec2(0.5, 0.5))/iResolution.xy).r;\n    return zoomfact==0.?1.:zoomfact;\n}\n\nbool get_dmode()\n{\n    float dmode = texture(iChannel2, (addr_mode + vec2(0.5, 0.5))/iResolution.xy).r;\n    return dmode==1.;\n}\n\nvec2 get_mouse()\n{\n    return texture(iChannel2, (addr_mouse + vec2(0.5, 0.5))/iResolution.xy).rg;\n}\n\nvec3 getDColor()\n{\n    return texture(iChannel2, (addr_color + vec2(0.5, 0.5))/iResolution.xy).rgb;\n}\n\nfloat getThickness()\n{\n    return texture(iChannel2, (addr_thkn + vec2(0.5, 0.5))/iResolution.xy).r;\n}\n\nbool isKeyPressed(float key)\n{\n\treturn texture(iChannel0, vec2(key, 0.25) ).x > .0;\n}\n\nvec4 combineCol(vec4 col1, vec3 col2, float dd)\n{\n    vec4 res = vec4(0.);\n    res.rgb = dd>0.01?mix(col1.rgb, col2, dd):col1.rgb;\n    res.a = min(col1.a, 1. - dd);\n    \n    return res;\n}\n\n// Main tracing function\nfloat trace_s(vec3 cam, vec3 ray, float maxdist, bool inside) \n{\n    float t = 0.001;\n    float objnr = 0.;\n    vec3 pos;\n    float dist;\n    \n  \tfor (int i = 0; i < 20; ++i)\n    {\n    \tpos = ray*t + cam;\n        float dist = map_screen(pos);\n        t+= dist;\n  \t}\n  \treturn t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    camtarget.y = 2.*supportSize.y + screenSize.y;    \n    vec2 cuv = iMouse.xy/iResolution.xy;     \n    setCamera(get_mouse(), iResolution.xy);\n  \tcuv = cuv*2.0 - 1.0;\n  \tcuv.x*= iResolution.x/iResolution.y;\n\n  \tvec3 ray = GetCameraRayDir(cuv, camdir, fov*get_zoom());\n    float tx = trace_s(campos, ray, maxdist, false);\n    vec3 mpos = campos + tx*ray;\n    vec2 muv = getScreenCords(mpos);\n    \n    vec2 uv = fragCoord/iResolution.xy;    \n    \n    float dd = (iMouse.w>0. && !get_dmode())?smoothstep(getThickness()*1.5, getThickness()*0.7, distance(muv*iResolution.xy, fragCoord)):0.;\n    \n    if (iFrame==0)\n       fragColor.a = 1.;\n    else\n       fragColor = texture(iChannel1, uv);\n    \n    if (fragColor.rgb==vec3(0.))\n        fragColor.a = 1.;    \n    \n    fragColor = combineCol(fragColor, getDColor(), dd);\n    \n    if (isKeyPressed(KEY_C))\n       fragColor = vec4(0., 0., 0., 1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\n\"Transparent screen\" by Emmanuel Keller aka Tambako - September 2019\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.14159265359\n#define ZERO int(min(iTime,0.))\n\n// Switches, you can play with them!\n#define specular\n// If drawing is too slow, please remove shadows!\n#define shadow\n#define floor_reflection\n#define parquet\n#define doors\n#define show_leds\n#define wall_bump\n\nstruct Lamp\n{\n  \tvec3 position;\n  \tvec3 color;\n  \tfloat intensity;\n  \tfloat attenuation;\n};\n    \nstruct TransMat\n{\n    vec3 col_vol;\n    vec3 col_dif;\n    vec3 col_fil;\n    vec3 col_dev;\n    float specint;\n    float specshin;\n    float ior;\n};\n\nstruct RenderData\n{\n  \tvec3 col;\n  \tvec3 pos;\n  \tvec3 norm;\n  \tint objnr;\n};\n   \n// Every object of the scene has its ID\n#define SKY_OBJ       0\n#define FLOOR_OBJ     1\n#define SCREEN_OBJ    2\n#define SUPPORT_OBJ   3\n#define ROOM_OBJ      4\n#define RLED_OBJ      5\n#define GLED_OBJ      6\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\n//#define antialias\nconst float aawidth = 0.8;\nconst int aasamples = 2;\n\n// Ambient light\nconst vec3 ambientColor = vec3(1.);\nconst float ambientint = 0.17;\n\n// Specular options\nconst float specint = 0.38;\nconst float specshin = 55.;\n\n// Shadow options\nconst float shi = 1.8;\n\n// Tracing options\nconst float normdelta = 0.0005;\nconst float maxdist = 70.;\nconst int nbref = 8;\n\n// Color options\nconst float gamma = 1.7;\nconst vec3 support_color = vec3(0.25, 0.27, 0.29);\nconst vec3 floor_color = vec3(0.98, 0.87, 0.63);\nconst vec3 walls_color = vec3(0.9, 0.93, 0.95);\nconst vec3 ceiling_color = vec3(1.45);\nconst vec3 dframe_color = vec3(0.89, 0.83, 0.77);\nconst vec3 redledColor = vec3(1., 0.15, 0.07);\nconst vec3 orangeledColor = vec3(1., 0.33, 0.07);\nconst vec3 greenledColor = vec3(0.2, 1., 0.07);\n\n// Geometry options\nconst vec3 supportSize = vec3(1., 0.32, 0.055);\nconst float supportRR = 0.017;\nconst vec3 screenSize = 1.2*vec3(1.6, 0.9, 0.025);\nconst float screenRR = 0.01;\nconst vec3 roomSize = vec3(18., 6.5, 18.);\nconst vec3 doorSize = vec3(2.5, 4.2, 0.6);\nconst vec2 dfSize = vec2(0.17, 0.07);\nconst vec2 psize = vec2(2.4, 0.3);\n\n// Lamps options\nvec3 lampsColor = vec3(1., 0.96, 0.91);\nconst float lampsInt = 10.2;\nconst vec2 cLampSize = vec2(3., 3.);\nconst int nbCLamps = 3;\nLamp lamps[9];\n\n// Campera options\nvec3 campos = vec3(0., 0., 8.);\nvec3 camtarget = vec3(0., 0., 0.);\nvec3 camdir = vec3(0., 0., 0.);\nfloat fov = 4.5;\n    \nvec3 colors[10];    \n\nTransMat glassMat;\n\nint aai;\nint aaj;\n\nconst vec2 addr_zoom = vec2(5., 5.);\nconst vec2 addr_color = vec2(10., 5.);\nconst vec2 addr_mode = vec2(15., 5.);\nconst vec2 addr_thkn = vec2(20., 5.);\nconst vec2 addr_mouse = vec2(25., 5.);\n\nvoid init(float time)\n{   \n    //lampsColor = 0.3 + 0.7*vec3(sin(0.42*time + 1.2), sin(0.73*time + 0.4), sin(1.08*time + 4.2));\n    \n    for (int yl=0; yl<nbCLamps; yl++)\n    {\n       for (int xl=0; xl<nbCLamps; xl++)\n       {\n          float lx2 = roomSize.x/float(nbCLamps) - cLampSize.x;\n          float ly2 = roomSize.z/float(nbCLamps) - cLampSize.y;       \n           \n          lamps[xl + nbCLamps*yl] = Lamp(vec3((float(xl) - float(nbCLamps - 1)/2.)*(roomSize.x - lx2 + 0.75)/float(nbCLamps), roomSize.y - 0.45, (float(yl) - float(nbCLamps - 1)/2.)*(roomSize.z - lx2 + 0.75)/float(nbCLamps)), lampsColor, lampsInt/float(nbCLamps*nbCLamps), 0.2);\n       }\n    }\n    \n    glassMat = TransMat(vec3(0.9, 0.99, 0.82),\n                        vec3(0.01, 0.02, 0.02),\n                        vec3(0.99),\n                        vec3(0.3, 0.5, 0.9),\n                        0.25,\n                        45.,\n                        1.47); \n    \n    camtarget.y = 2.*supportSize.y + screenSize.y;\n}\n\nfloat sdRoundBox(vec3 p, vec3 b, float r)\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\n// Union operation from iq\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) - vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) + vect.y*cos(angle);\n    return rv;\n}\n\n// 1D hash function\nfloat hash(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 333.33;\n    p *= p + p;\n    return fract(p);\n}\n\n// From https://www.shadertoy.com/view/4sfGzS\nfloat noise(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix(hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix(hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix(hash(n+113.0), hash(n+114.0),f.x),\n                   mix(hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat map_floor(vec3 pos)\n{\n   return pos.y;\n}\n\nfloat map_room(vec3 pos)\n{\n   vec3 roomSize2 = roomSize;\n   #ifdef doors\n   roomSize2.xz-= dfSize.y*smoothstep(2.*dfSize.x + 0.01, 2.*dfSize.x - 0.01, pos.y);\n   #endif    \n    \n   float room = -sdRoundBox(pos + vec3(0, -roomSize2.y*0.5 + 0.01, 0.), roomSize2*0.5, 0.);\n   #ifdef doors\n\n   vec3 pos2 = pos;\n   pos2.x = abs(pos.x);\n   room = max(room, -sdRoundBox(pos2 + vec3(-roomSize.z - doorSize.z, -roomSize.y*0.5 + 0.01, 0.), roomSize*0.5, 0.));\n   room = min(room, sdRoundBox(pos2 + vec3(-roomSize.z*0.5 - doorSize.z*0.5, -doorSize.y*0.5 + 0.01, 0.), doorSize.zyx*0.5 + vec3(0.5*dfSize.y, 2.*dfSize.x, 2.*dfSize.x), 0.));\n   room = max(room, -sdRoundBox(pos2 + vec3(-roomSize.z*0.5 - doorSize.z*0.5, -doorSize.y*0.5 + 0.01, 0.), doorSize.zyx*0.5 + vec3(0.5*dfSize.y + 0.01, 0., 0.), 0.));\n   #endif\n    \n   return room;\n}\n\nfloat map_screen(vec3 pos)\n{\n   return sdRoundBox(pos + vec3(0., -1.96*supportSize.y - screenSize.y, 0.), screenSize, screenRR);\n}\n\nfloat map_support(vec3 pos)\n{\n   float support = sdRoundBox(pos + vec3(0., -supportSize.y, 0.), supportSize, supportRR);\n    \n   float b = 0.05;\n   float vh0 = smoothstep(0.2, 0.2 + b, pos.x)*smoothstep(0.78*supportSize.x + b, 0.78*supportSize.x, pos.x);\n   vh0*= smoothstep(-0.7*supportSize.y - b, -0.7*supportSize.y, pos.y - supportSize.y)*smoothstep(0.7*supportSize.y + b, 0.7*supportSize.y, pos.y - supportSize.y);\n   float vh = pos.z>0.?.0:vh0*smoothstep(0., 0.8, fract(-4.9*pos.y/supportSize.y + 0.1))*smoothstep(1., 0.8, fract(-4.9*pos.y/supportSize.y + 0.1)); \n   //if (support<0.001);\n   //   support+= 0.001*(pos.z<0.?1. - vh0:1.)*noise(300.*pos);\n      \n   if (pos.z<0.)\n     support-= 0.015*vh;\n    \n   support = max(support, -map_screen(pos) + 0.003);\n    \n   return support;\n}\n\n#ifdef show_leds\nfloat map_gled(vec3 pos)\n{\n    return sdRoundBox(pos - vec3(-supportSize.x + 0.1, 2.*supportSize.y - 0.1, -supportSize.z - 0.01), vec3(0.038, 0.009, 0.009), 0.004);\n}\n\nfloat map_rled(vec3 pos)\n{\n    return sdRoundBox(pos - vec3(-supportSize.x + 0.25, 2.*supportSize.y - 0.1, -supportSize.z - 0.01), vec3(0.038, 0.009, 0.009), 0.004);\n}\n#endif\n      \nvec2 map(vec3 pos, bool inside, bool noroom)\n{\n    vec2 res;\n    float screen = map_screen(pos);\n    if (inside)\n       res = vec2(-screen, SCREEN_OBJ);\n    else\n    {\n       res = vec2(screen, SCREEN_OBJ);\n        \n       float support = map_support(pos);\n       res = opU(res, vec2(support, SUPPORT_OBJ));        \n        \n       if (!noroom)\n       {\n          float floor = map_floor(pos);\n          res = opU(res, vec2(floor, FLOOR_OBJ));           \n           \n          float room = map_room(pos);\n          res = opU(res, vec2(room, ROOM_OBJ));\n       }\n       \n       #ifdef show_leds\n       vec2 rled = vec2(map_rled(pos), RLED_OBJ);\n       vec2 gled = vec2(map_gled(pos), GLED_OBJ);\n\n       res = opU(res, rled);\n       res = opU(res, gled);\n       #endif        \n    }\n    return res;\n}\n\nvec3 getGlassAbsColor(float dist, vec3 color)\n{\n    return pow(color, vec3(0.1 + pow(dist*2.5, 2.)));\n}\n\n// Main tracing function\nvec2 trace(vec3 cam, vec3 ray, float maxdist, bool inside) \n{\n    float t = 0.001;\n    float objnr = 0.;\n    vec3 pos;\n    float dist;\n    \n  \tfor (int i = 0; i < 150; ++i)\n    {\n    \tpos = ray*t + cam;\n        vec2 res = map(pos, inside, false);\n        dist = res.x;\n        if (dist>maxdist || abs(dist)<0.0006)\n            break;\n        t+= dist*0.8;\n        objnr = abs(res.y);\n  \t}\n  \treturn vec2(t, objnr);\n}\n\n#ifdef shadow\nfloat calcSoftshadow(in vec3 ro, in vec3 rd)\n{\n    float res = 5.0;\n    float tmax = 6.0;  \n    \n    float t = 0.2;\n    for( int i=0; i<20; i++ )\n    {\n\t\tvec2 mr = map(ro + rd*t, false, true);\n        float h = mr.x;\n        res = min(res, 8.4*h/t);\n        t += clamp(h*(mr.y==float(SCREEN_OBJ)?0.17:1.), 0.0, 0.36);\n        if(res<0.1 || t>tmax) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n#endif\n\nvec2 getScreenCords(vec3 pos)\n{\n    pos.xy+= vec2(screenSize.x, - 1.96*supportSize.y);\n    pos.xy/= 2.*screenSize.xy;\n    \n    return pos.xy;\n}\n\n// Sets the position of the camera with the mouse and calculates its direction\nconst float axm = 2.*pi;\nconst float aym = 0.70;\nvoid setCamera(vec2 iMouse, vec2 iResolution)\n{\n   vec2 iMouse2;\n   if (iMouse.x==0. && iMouse.y==0.)\n      iMouse2 = vec2(0.75, 0.8);\n   else\n      iMouse2 = iMouse.xy;\n   \n   campos = vec3(8.5, 0., 0.);\n   campos.xy = rotateVec(campos.xy, 0.5 - iMouse2.y*aym + aym*0.5);\n   campos.yz = rotateVec(campos.yz, -iMouse2.y*aym + aym*0.5);\n   campos.xz = rotateVec(campos.xz, iMouse2.x*axm);\n\n   camdir = camtarget - campos;   \n}\n\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat fresnel(vec3 ray, vec3 norm, float n2)\n{\n   float n1 = 1.; // air\n   float angle = acos(-dot(ray, norm));\n   float r0 = dot((n1-n2)/(n1+n2), (n1-n2)/(n1+n2));\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\n   return clamp(r, 0., 0.8);\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// This buffer handles the keyboard\n\nconst float KEY_D\t\t= 68.5/256.0;\nconst float KEY_F\t\t= 70.5/256.0;\nconst float KEY_R\t\t= 82.5/256.0;\nconst float KEY_0\t\t= 48.5/256.0;\nconst float KEY_1\t\t= 49.5/256.0;\nconst float KEY_2\t\t= 50.5/256.0;\nconst float KEY_3\t\t= 51.5/256.0;\nconst float KEY_4\t\t= 52.5/256.0;\nconst float KEY_5\t\t= 53.5/256.0;\nconst float KEY_6\t\t= 54.5/256.0;\nconst float KEY_7\t\t= 55.5/256.0;\nconst float KEY_8\t\t= 56.5/256.0;\nconst float KEY_9\t\t= 57.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_PG_UP   = 33.5/256.0;\nconst float KEY_UP      = 38.5/256.0;\nconst float KEY_PG_DOWN = 34.5/256.0;\nconst float KEY_DOWN    = 40.5/256.0;\n\nconst float min_zoom = 0.15;\nconst float max_zoom = 35.;\nconst float zfact = 1.008;\nconst float tStep = 1.;\n\nvoid initc()\n{\n    float cc = 0.25;    \n    \n    colors[0] = vec3(1., 1., 1.);\n    colors[1] = vec3(1., cc, cc);\n    colors[2] = vec3(1., 0.5*(0.75 + cc), cc);\n    colors[3] = vec3(1., 1., cc);\n    colors[4] = vec3(cc, 1., cc);\n    colors[5] = vec3(cc, cc, 1.);\n    colors[6] = vec3(cc, 1., 1.);\n    colors[7] = vec3(1., cc, 1.);\n    colors[8] = vec3(0.55, 0.55, 0.55);\n    colors[9] = vec3(0.3, 0.3, 0.3);    \n}\n\nbool isKeyPressed(float key)\n{\n\treturn texture(iChannel0, vec2(key, 0.25) ).x > .0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    initc();\n    \n    bool dMode = texture(iChannel1, (addr_mode + vec2(0.5, 0.5))/iResolution.xy).r==0.;\n    \n    if (isKeyPressed(KEY_D))\n       dMode = true;\n    \n    if (isKeyPressed(KEY_F))\n       dMode = false;\n    \n    if (fragCoord==addr_mode + vec2(0.5, 0.5))\n       fragColor = vec4(dMode?0.:1., 0., 0., 0.);\n    \n    vec2 bmouse = texture(iChannel1, (addr_mouse + vec2(0.5, 0.5))/iResolution.xy).rg;\n    //if (bmouse==vec2(0.))\n    //   bmouse = vec2(iMouse.xy/iResolution.xy);\n    if (fragCoord==addr_mouse + vec2(0.5, 0.5))\n    {\n       if (dMode)\n          fragColor = vec4(bmouse, 0., 0.);\n       else\n          fragColor = vec4(iMouse.xy/iResolution.xy, 0., 0.);\n    }\n    \n    vec3 dcolor = texture(iChannel1, (addr_color + vec2(0.5, 0.5))/iResolution.xy).rgb;\n    if (dcolor==vec3(0.))\n        dcolor = colors[0];\n    if (isKeyPressed(KEY_0)) dcolor = colors[0];\n    if (isKeyPressed(KEY_1)) dcolor = colors[1];\n    if (isKeyPressed(KEY_2)) dcolor = colors[2];\n    if (isKeyPressed(KEY_3)) dcolor = colors[3];\n    if (isKeyPressed(KEY_4)) dcolor = colors[4];\n    if (isKeyPressed(KEY_5)) dcolor = colors[5];\n    if (isKeyPressed(KEY_6)) dcolor = colors[6];\n    if (isKeyPressed(KEY_7)) dcolor = colors[7];\n    if (isKeyPressed(KEY_8)) dcolor = colors[8];\n    if (isKeyPressed(KEY_9)) dcolor = colors[9];\n    if (isKeyPressed(KEY_R))\n        dcolor = vec3(0.2 + 0.8*hash(iDate.w*845.12), 0.2 + 0.8*hash(iDate.w*469.51), 0.2 + 0.8*hash(iDate.w*276.84));\n    if (fragCoord==addr_color + vec2(0.5, 0.5))\n        fragColor = vec4(dcolor, 0.);\n    \n    float thickness = texture(iChannel1, (addr_thkn + vec2(0.5, 0.5))/iResolution.xy).r;\n    if (thickness==0.)\n         thickness = 15.;    \n    \n    if (isKeyPressed(KEY_LEFT) && thickness>2.)\n       thickness-= tStep;\n    \n    if (isKeyPressed(KEY_RIGHT) && thickness<50.)\n       thickness+= tStep;\n    \n    if (fragCoord==addr_thkn + vec2(0.5, 0.5))\n       fragColor = vec4(thickness, 0., 0., 0.);      \n    \n    float zoom = texture(iChannel1, (addr_zoom + vec2(0.5, 0.5))/iResolution.xy).r;\n    if (zoom==0.)\n         zoom = 1.;\n    \n    if (isKeyPressed(KEY_UP) && zoom<max_zoom)\n       zoom*= zfact;\n    \n    if (isKeyPressed(KEY_DOWN) && zoom>min_zoom)\n       zoom/= zfact;\n    \n    if (isKeyPressed(KEY_PG_UP) && zoom<max_zoom)\n       zoom*= pow(zfact, 8.);\n    \n    if (isKeyPressed(KEY_PG_DOWN) && zoom>min_zoom)\n       zoom/= pow(zfact, 8.); \n    \n    if (fragCoord==addr_zoom + vec2(0.5, 0.5))\n       fragColor = vec4(zoom, 0., 0., 0.);   \n}","name":"Buffer B","description":"","type":"buffer"}]}