{"ver":"0.1","info":{"id":"wdtfDn","date":"1605199203","viewed":113,"name":"[JFIG] Shadow","username":"Delfeil","description":"Submission for the rendering contest organized for the JFIG 2020.\nUsing Implicit surface and signed distance field, rendered using sphere tracing algorithm.\n\nCasanova Delfeil, student Master's degree in computer science ID3D (Lyon 1).","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["distancefields","spheretracing","jfig2020"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based on the shader proposed by mr Galin Eric during my formation\n  // https://www.shadertoy.com/view/wtc3R8\nconst int Steps = 500;\nconst float Epsilon = 0.01; // Marching epsilon\nconst float T=0.5;\n\nconst float rA=10.0; // Maximum and minimum ray marching or sphere tracing distance from origin\nconst float rB=40.0;\n\nconst vec3 GREEN = vec3(0.635, 0.815, 0.247) * 0.4;\nconst vec3 GRAY = vec3(0.690, 0.690, 0.690) * 0.3;\n\n// Transforms\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.y, -sa*p.x + ca*p.y, p.z);\n}\n\n/**\n  Translation\n*/\nvec3 Translation(vec3 p, vec3 t) {\n  return vec3(p.x + t.x, p.y + t.y, p.z + t.z);\n}\n\n/**\n  Scale | Homothesie\n*/\nvec3 Scale(vec3 p, vec3 s) {\n  return vec3(p.x / s.x, p.y / s.y, p.z / s.z);\n}\n\n// Primitives\n// Based on the signed distance field primitives detailed by Inigo Quilez\n  // https://iquilezles.org/articles/distfunctions\n// SphÃ¨re\nvec4 sdSphere( vec3 p, float s, vec3 color )\n{\n  return vec4(length(p)-s, color);\n}\n\n// Plan\nvec4 sdPlane( vec3 p, vec3 n, float h, vec3 color )\n{\n  // n must be normalized\n  return vec4(dot(p,n) + h, color);\n}\nvec4 sdBox( vec3 p, vec3 b, vec3 color )\n{\n  vec3 q = abs(p) - b;\n  float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n  return vec4(d, color);\n}\n\nvec4 sdTorus( vec3 p, vec2 t, vec3 color )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  float d = length(q)-t.y;\n  return vec4(d, color);\n}\n\nvec4 sdCircle(vec3 p, vec3 c, vec3 n, float r, vec3 color) {\n  float ph = dot((p - c), n);\n  float hc = sqrt(dot((p-c), (p-c)) - pow(ph, 2.0));\n  float hq = hc - r;\n  float d = pow(ph, 2.0) + pow(hq, 2.0); \n  return vec4(d, color);\n}\n\nvec4 sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb, vec3 color)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  float d = sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n  return vec4(d, color);\n}\n\nvec4 sdVerticalCapsule( vec3 p, float h, float r, vec3 color )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  float d = length( p ) - r;\n  return vec4(d, color);\n}\n\n// Operators\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nvec4 sdUnion(vec4 a, vec4 b) {\n  float u = min(a.x, b.x);\n\n  return vec4(\n    u,\n    (u == a.x ? a.yzw : b.yzw)\n  );\n}\n\n/** Intersection\n  a : field function of left sub-tree\n  b : field function of right sub-tree\n*/\nvec4 sdIntersection(vec4 a, vec4 b) {\n  float i = max(a.x, b.x);\n  return vec4(i,\n    (i == a.x ? a.yzw : b.yzw) \n  );\n}\n\n/** Substraction\n  a : field function of left sub-tree\n  b : field function of right sub-tree\n*/\nvec4 sdSubstraction(vec4 a, vec4 b) {\n  float s = max(a.x, -b.x);\n  return vec4(s,\n    (s == a.x ? a.yzw : b.yzw)\n  );\n}\n\n/** SCENES OBJECTS **/\n\nvec4 logo(vec3 p) {\n  float z = -5.0;\n  float rotate_sin = sin((iTime) * 0.5);\n  float rotate_cos = cos((iTime) * 0.5);\n  float rotate_sin_2 = sin((iTime +1.0) * 2.0);\n  float rotate_cos_2 = cos((iTime +1.0) * 2.0);\n\n  vec4 grayPart = sdTorus(\n      rotateX(\n        Translation(p, vec3(0.0, 0.0, z))\n      , 1.58)\n    , vec2(5.0, 0.5), GRAY);\n  grayPart = sdSubstraction(grayPart, \n    sdBox(\n      rotateX(\n        Translation(p, vec3(-10.0, 0.0, z))\n      , 0.0)\n    , vec3(10.0, 10.0, 1.0), GRAY)\n  );\n\n  vec4 greenPart = sdTorus(\n      rotateX(\n        Translation(p, vec3(0.0, 0.0, z))\n      , 1.58)\n    , vec2(5.0, 0.5), GREEN);\n  greenPart = sdSubstraction(greenPart, \n    sdBox(\n      rotateX(\n        Translation(p, vec3(10.0, 0.0, z))\n      , 0.0)\n    , vec3(10.0, 10.0, 1.0), GREEN)\n  );\n\n  vec4 v = sdUnion(grayPart, greenPart);\n\n  v = sdSubstraction(v,\n    sdSphere(Translation(p,\n      vec3(-6.0 * rotate_sin, 6.0 * rotate_cos, z)\n      ), 4.0, GRAY)\n  );\n\n  v = sdSubstraction(v,\n    sdBox(\n      rotateX(\n        Translation(p, vec3(0.0, 6.0, z))\n      , 0.0)\n    , vec3(1.0, 20.0, 1.0), GRAY)\n  );\n\n  v = sdSubstraction(v,\n    sdBox(\n      rotateZ(\n        Translation(p, vec3(-6.0, 0.0, z))\n      , 1.5)\n    , vec3(1.0, 20.0, 1.0), GRAY)\n  );\n\n  v = sdUnion(v,\n    sdSphere(Translation(p,\n      vec3(-6.0 * rotate_sin, 6.0 * rotate_cos, z)\n    ), 2.0, GREEN)\n  );\n\n  v = sdUnion(v,\n    sdSphere(\n      Translation(p, vec3(-11.0 * rotate_sin_2, 11.0* rotate_cos_2, z)\n    ), 1.0, GREEN)\n  );\n\n  return v;\n}\n\nvec4 J(vec3 p) {\n  vec4 v =\n    sdBox(\n      rotateZ(\n        Translation(p, vec3(-1.0, 0.0, -0.9))\n      , 1.5)\n    , vec3(1.0, 2.0, 4.0), GRAY);\n  v = sdSubstraction(v,\n    sdBox(\n      rotateZ(\n        Translation(p, vec3(-2.5, 0.0, -4.0))\n      , 1.5)\n    , vec3(2, 1.5, 2.5), GREEN)\n  );\n  v = sdUnion(v,\n    sdBox(\n      rotateZ(\n        Translation(p, vec3(0.0, 0.0, -7.0))\n      , 1.5)\n    , vec3(1.0, 1.0, 1.0), GREEN)\n  );\n\n  return v;\n}\n\nvec4 F(vec3 p) {\n  vec4 v =\n    sdBox(\n      rotateZ(\n        Translation(p, vec3(1.75, 0, -0.9))\n      , 1.5)\n    , vec3(1.0, 3.0, 7.0), GRAY);\n  v = sdSubstraction(v,\n    sdBox(\n      rotateZ(\n        Translation(p, vec3(3.0, -0.15, -4.9))\n      , 1.5)\n    , vec3(2.0, 2.5, 1.0), GREEN)\n  );\n  v = sdSubstraction(v,\n    sdBox(\n      rotateZ(\n        Translation(p, vec3(3.0, -0.15, -0.9))\n      , 1.5)\n    , vec3(2.0, 2.5, 1.0), GREEN)\n  );\n  v = sdSubstraction(v,\n    sdBox(\n      rotateZ(\n        Translation(p, vec3(3.75, -0.15, -2.9))\n      , 1.5)\n    , vec3(2.0, 1.75, 1.5), GREEN)\n  );\n\n  return v;\n}\n\nvec4 I(vec3 p) {\n  vec4 v =\n    sdBox(\n      rotateZ(\n        Translation(p, vec3(0.0, 0.0, -0.9))\n      , 1.5)\n    , vec3(1.0, 1.0, 4.0), GRAY);\n  v = sdUnion(v,\n    sdBox(\n      rotateZ(\n        Translation(p, vec3(0.0, 0.0, -7.0))\n      , 1.5)\n    , vec3(1.0, 1.0, 1.0), GREEN)\n  );\n\n  return v;\n}\n\nvec4 G(vec3 p) {\n  vec4 v = \n    sdBox(\n      rotateZ(\n        Translation(p, vec3(0.0, 0.0, -0.9))\n      , 1.5)\n    , vec3(1.0, 4.0, 7.0), GRAY);\n  v = sdSubstraction(v,\n    sdBox(\n      rotateZ(\n        Translation(p, vec3(0.0, 0.0, -2.0))\n      , 1.5)\n    , vec3(2.0, 2.0, 0.75), GREEN)\n  );\n  v = sdSubstraction(v,\n    sdBox(\n      rotateZ(\n        Translation(p, vec3(-1.0, 0.0, -4.0))\n      , 1.5)\n    , vec3(2, 1.0, 2.0), GREEN)\n  );\n  v = sdSubstraction(v,\n    sdBox(\n      rotateZ(\n        Translation(p, vec3(1.5, 0.0, -5.0))\n      , 1.5)\n    , vec3(2, 3.5, 1.0), GREEN)\n  );\n\n  return v;\n}\n\nvec4 Dos(vec3 p) {\n  vec4 v = \n    sdBox(\n      rotateZ(\n        Translation(p, vec3(0.0, 0.0, -0.9))\n      , 1.5)\n    , vec3(1.0, 2.0, 5.0), GRAY);\n  v = sdSubstraction(v,\n    sdBox(\n      rotateZ(\n        Translation(p, vec3(1.0, 0.0, -1.5))\n      , 1.5)\n    , vec3(2.0, 1.5, 0.75), GREEN)\n  );\n  v = sdSubstraction(v,\n    sdBox(\n      rotateZ(\n        Translation(p, vec3(-1.0, 0.0, -4.0))\n      , 1.5)\n    , vec3(2.0, 1.5, 0.5), GREEN)\n  );\n  v = sdSubstraction(v,\n    sdBox(\n      rotateZ(\n        Translation(p, vec3(1.5, 0.0, -6.0))\n      , 1.5)\n    , vec3(2.0, 1.0, 1.5), GREEN)\n  );\n\n  return v;\n}\n\nvec4 Zero(vec3 p) {\n  vec4 v = \n    sdBox(\n      rotateZ(\n        Translation(p, vec3(0.0, 0.0, -0.9))\n      , 1.5)\n    , vec3(1.0, 2.5, 5.0), GRAY);\n  v = sdSubstraction(v,\n    sdBox(\n      rotateZ(\n        Translation(p, vec3(0.0, 0.0, -3.0))\n      , 1.5)\n    , vec3(2.0, 1.0, 1.75), GREEN)\n  );\n  v = sdSubstraction(v,\n    sdBox(\n      rotateZ(\n        Translation(p, vec3(2.0, 0.0, -6.25))\n      , 1.5)\n    , vec3(2.0, 1.0, 1.5), GREEN)\n  );\n  v = sdSubstraction(v,\n    sdBox(\n      rotateZ(\n        Translation(p, vec3(-2.0, 0.0, -6.25))\n      , 1.5)\n    , vec3(2.0, 1.0, 1.5), GREEN)\n  );\n  v = sdSubstraction(v,\n    sdBox(\n      rotateZ(\n        Translation(p, vec3(2.0, 0.0, 0.25))\n      , 1.5)\n    , vec3(2.0, 1.0, 1.5), GREEN)\n  );\n  v = sdSubstraction(v,\n    sdBox(\n      rotateZ(\n        Translation(p, vec3(-2.0, 0.0, 0.25))\n      , 1.5)\n    , vec3(2.0, 1.0, 1.5), GREEN)\n  );\n\n  return v;\n}\n\n// Potential field of the object\n// p : point\nvec4 Object(vec3 p)\n{\n  vec4 v = sdPlane(p, vec3(0.0, 0.0, 1.0), 0.0, vec3(0.25));\n  \n  v= sdUnion(v, logo(\n    rotateZ(\n    Translation(\n      rotateX(p, 0.25), vec3(0.0, -2.0, .0)\n    ), 2.5)\n  ));\n\n  v = sdUnion(v, J(\n    Translation(p, vec3(-8.0, 25.0, 0.0))\n  ));\n  v = sdUnion(v, F(\n    Translation(p, vec3(-4.0, 25.0, 0.0))\n    ));\n\n  v= sdUnion(v, I(\n    Translation(p, vec3(4.0, 25.0, 0.0))\n  ));\n  v= sdUnion(v, G(\n    Translation(p, vec3(11.5, 25.0, 0.0))\n  ));\n\n  // v= sdUnion(v, Dos(\n  //   Scale(\n  //     Translation(p, vec3(-4.0, 15.0, 0.0)),\n  //   vec3(0.5))\n  // ));\n  // v= sdUnion(v, Dos(\n  //   Scale(\n  //     Translation(p, vec3(4.0, 15.0, 0.0)),\n  //   vec3(0.5))\n  // ));\n\n  // v = sdUnion(v, Zero(\n  //   Scale(\n  //     Translation(p, vec3(0.0, 15.0, 0.0)),\n  //   vec3(0.5))\n  // ));\n  \n  // v = sdUnion(v, Zero(\n  //   Scale(\n  //     Translation(p, vec3(8.0, 15.0, 0.0)),\n  //   vec3(0.5))\n  // ));\n  \n\n  return vec4(v.x,\n    clamp(v.yzw, 0.0, 1.0)\n  );\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.0001;\n  vec3 n;\n  float v = Object(p).x;\n  n.x = Object( vec3(p.x+eps, p.y, p.z) ).x - v;\n  n.y = Object( vec3(p.x, p.y+eps, p.z) ).x - v;\n  n.z = Object( vec3(p.x, p.y, p.z+eps) ).x - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nvec4 SphereTrace(vec3 o, vec3 u, float rB, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n    vec4 v;\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    v = Object(p);\n    // Hit object\n      if (v.x < 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,abs(v.x)/2.0); // abs(v) -> pour avoir une valeur positive\n          // si lambda trop petit: se ratte sur la profondeur de l'objet\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return vec4(t, v.yzw);\n}\n\n// Shadows\n  // Based on an Inigo Quilez's article\n    // https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = Object( ro + normalize(rd)*t ).x;\n        // traditional technique\n        res = min( res, 30.0*h/t );\n        t += h;\n        if( res<0.0001 || t>tmax ) break; \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// Ambient occlusion\n// p : Point\n// n : Normal\n// a : Number of smaples\nfloat AmbientOcclusion(vec3 p,vec3 n, int a)\n{\n    if (a==0) { return 1.0; }\n    \n\tfloat ao=0.0; \n    \n    for (int i=0;i<a;i++)\n    {\n \t\tvec3 d = Cosine(581.123*float(i) , n);\n\n        int s;\n        bool h;\n        float t=SphereTrace(p,d,10.0,h,s).x;\n        if (!h) {ao+=1.0;}\n        else if (t>5.0)\n            {\n             ao+=1.0;   \n            }\n    }\n    \n    ao/=float(a);\n\treturn ao;\n}\n\n// Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(0.25, 0.25, 0.25), vec3(0.0, 0.0, 0.25), rd.z*0.5+0.5);\n}\n\n\nfloat Light(vec3 p,vec3 n, vec3 lp)\n{\n   // point light\n\n  vec3 l = normalize(lp - p);\n\n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = pow(0.5*(1.0+dot(n, l)),2.0);\n\n    bool h;\n    int s;\n// float t=SphereTrace(p+0.1*n,l,100.0,h,s).x;\n     return diff;\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\n// color: color of the object\nvec3 Shade(vec3 p, vec3 n, vec3 color, vec3 ro, vec3 rd)\n{\n    // vec3 col = vec3(0.0);\n    vec3 lp = vec3(5.0, 15.0, 10.0);\n    vec3  hal = normalize( lp-rd );\n    float dif = Light(p, n, lp);\n    dif *= calcSoftshadow( p, lp, 0.1, 15.0);\n\n    float spe = pow( clamp( dot( n, hal ), 0.0, 1.0 ),16.0)*\n      dif *\n      (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 )\n    );\n    vec3 c = color * 3.75*dif*vec3(0.75);\n    c +=      5.0*spe*vec3(0.75);\n\n\n    // float ao = AmbientOcclusion(p+0.1*n,n,15);\n    float amb = clamp( 0.5+0.5*n.z, 0.0, 1.0 );\n    c += color*amb*vec3(0.5);\n    return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return 0.5+mix(vec3(0.05,0.05,0.5),vec3(0.65,0.39,0.65),t);\n}\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel, out bool pip)\n{\n    // Pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;\n   if (pip==true)\n   {    \n    const float fraction=1.0/4.0;\n    // Recompute pixel coordinates in sub-picture\n    if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))\n    {\n        p=(-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);\n        pip=true;\n    }\n       else\n       {\n           pip=false;\n       }\n   }\n   return p;\n}\n\nuint[] jfig_bitfield = uint[]( 0x0u,0x0u,0x0u,0xf97800u,0x90900u,0xc91800u,0x890900u,0xf90900u,0x180u,0x0u,0x30e30e0u,0x4904900u,0x49e49e0u,0x4824820u,0x31e31e0u,0x0u,0x0u,0x0u );\nbool jfig(in uint x, in uint y) {\n    if (x>=32u || y>=18u) return false;\n    uint id = x + (17u-y)*32u;\n    return 0u != (jfig_bitfield[id/32u] & (1u << (id&31u)));\n}\n\n// Image\nvoid mainImage( out vec4 color, in vec2 pxy )\n{\n    // Picture in picture on\n    bool pip=false;\n    \n   // Pixel\n     vec2 pixel=Pip(pxy, pip);\n    \n    // Mouse\n    vec2 m=iMouse.xy/iResolution.xy;\n\n    // Camera\n    vec3 ro,rd;\n    Ray(m,pixel,ro,rd);\n\n  // Trace ray\n\n  // Hit and number of steps\n  bool hit;\n  int s;\n\n  vec4 t = SphereTrace(ro, rd, 100.0,hit, s);\n  \n    // Position \n    vec3 pt = ro + t.x * rd;\n    \n  // Shade background\n  vec3 rgb = background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pt);\n\n    // Shade object with light\n    rgb = Shade(pt, n, t.yzw, ro, rd);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  if (pip==true)\n  {\n      rgb = ShadeSteps(s); \n  }\n  // rgb = ShadeSteps(s); \n\n  color=vec4(rgb, 1.0);\n  vec2 coord = pxy/iResolution.xy*vec2(32u, 18u)*6.;\n  if (jfig(uint(coord.x), uint(coord.y)))\n        color.xyz = GREEN*2.0;\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Hashing function\n// Returns a random number in [-1,1]\nfloat Hash(float seed)\n{\n    return fract(sin(seed)*43758.5453 );\n}\n\n// Cosine direction \nvec3 Cosine( in float seed, in vec3 nor)\n{\n    float u = Hash( 78.233 + seed);\n    float v = Hash( 10.873 + seed);\n\n    \t// method 3 by fizzer: http://www.amietia.com/lambertnotangent.html\n        float a = 6.2831853 * v;\n        u = 2.0 * u - 1.0;\n        return normalize( nor + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}\n\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 rotate_X(float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return mat3(\n        1.0, 0.0, 0.0,\n        0.0, ca, sa,\n        0.0, -sa, ca\n  );\n}\n\nmat3 rotate_Y(float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return mat3(\n        ca, 0.0, -sa,\n        0.0, 1.0, 0.0,\n        sa, 0.0, ca\n  );\n}\n\nmat3 rotate_z(float a)\n{\n    float sa = sin(a); float ca = cos(a); \n    return mat3(\n        ca,sa,0.0,\n        -sa,ca,0.0,\n        0.0,0.0,1.0\n    );\n}\n\n// Compute the ray\n// m : Mouse position\n// p : Pixel\n// ro, rd : Ray origin and direction\nvoid Ray(in vec2 m, in vec2 p,out vec3 ro,out vec3 rd)\n{\n    float a = 3.0*3.14*m.x;\n   \tfloat le = 3.8;\n    \n    // ro=vec3(20.0,0.0,5.0);\n    ro=vec3(30.0,-20.0,20.0);\n    // ro*=rotate_z(3.0*3.14*m.x);\n    ro*=rotate_X(-0.2);\n    ro*=rotate_Y(-0.1);\n    // ro*=rotate_Y(3.0*3.14*m.y);\n    ro*=rotate_z(4.0);\n\n    vec3 ta = vec3(0.0,0.0,1.0);\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,0.0,1.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\trd = normalize( p.x*uu + p.y*vv + le*ww );\n}\n","name":"Common","description":"","type":"common"}]}