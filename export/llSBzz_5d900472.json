{"ver":"0.1","info":{"id":"llSBzz","date":"1514306500","viewed":603,"name":"Overwatch Loot Box Animation","username":"mmerchante","description":"An approximation of Overwatch's Winter Wonderland Lootbox. Not very optimized; will come back when I have more time...","likes":29,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","animation","overwatch","lootbox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define saturate(x) clamp(x, 0.0, 1.0)\n\n#define RIBBON_MATERIAL 2.0\n#define BOX_MATERIAL 3.0\n#define GOLD_MATERIAL 4.0\n#define GROUND_MATERIAL 5.0\n#define METAL_MATERIAL 6.0\n\n// ---------------------------------------------------------\n\n// hg\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// hg\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// hg\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n} \n\n// hg\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\n// hg\nfloat fBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\n// hg\nfloat fCapsule(vec3 p, float r, float c) {\n\treturn mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n// iq\nvec3 palette( float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    return saturate(a + b * cos(6.28318 * (c * t + d)));\n}\n\n// iq\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\n// iq\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\n// iq\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\n// iq\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.yz)-t.x,p.x);\n  return length(q)-t.y;\n}\n\n// iq\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.yz)-t.x,p.x);\n  return length8(q)-t.y;\n}\n\n// iq\nvec2 opU(vec2 d1, vec2 d2 )\n{\n    return d1.x < d2.x ? d1 : d2;\n}\n\n// iq\nvec3 rotateY( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.xz = mat2(co,-si,si,co)*p.xz;\n    return p;\n}\n\n// iq\nvec3 rotateX( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.yz = mat2(co,-si,si,co)*p.yz;\n    return p;\n}\n\n// iq\nvec3 rotateZ( in vec3 p, float t )\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.xy = mat2(co,-si,si,co)*p.xy;\n    return p;\n}\n\nfloat impulse( float k, float x )\n{\n    float h = k*x;\n    return h*exp(1.0-h);\n}\n\nfloat longTailImpulse(float k, float x)\n{\n    float c = .3;\n    return mix(impulse(k, x), impulse(k, (x+1.0/k) * c), step(1.0/k, x));\n}\n// ---------------------------------------------------------\n\n\nfloat animationTime()\n{\n\treturn mod(iTime, 10.0);\n}\n\nfloat mechTime()\n{\n    float t = smoothstep(2.0, 4.0, animationTime() + sin(iTime * 24.0) * .025);\n    \n    // ugly ugly\n    t *= smoothstep(4.5, 4.0, animationTime());    \n    return t;\n}\n\nfloat cameraIntroTime()\n{\n    float t = smoothstep(2.0, 4.0, animationTime() + sin(iTime * 24.0) * .025);\n    t *= smoothstep(4.5, 4.0, animationTime());\n    return t;\n}\n\nfloat explosionTime()\n{\n    return max(0.0, animationTime() - 3.5) / (10.0 - 3.5);\n}\n\nfloat glowTime()\n{\n    return max(0.0, animationTime() - 3.35) / 7.65;\n}\n\nvec3 debug(float factor)\n{\n\tvec3 a = vec3(0.5);\n\tvec3 b = vec3(0.35);\n\tvec3 c = vec3(1.25, 1.0, .5);\n\tvec3 d = vec3(0.75, .99, .35);\n\n\treturn palette(factor, a, b, c, d);\n}\n\nvec3 bend(vec3 p, float a)\n{    \n    float c = cos(p.y * a);\n    float s = sin(p.y * a);\n    mat2  m = mat2(c,-s,s,c);\n    \n    return vec3(m * p.xy, p.z);\n}\n\nfloat ribbon(vec3 p)\n{   \n    vec3 op = p;\n    float e = exp(-p.z * p.z * .8);\n    \n    p.y += .1;\n    p.y *= mix(1.1, 10.0, e);\n\n    p.y *= mix(6.0, 1.6, smoothstep(-.1, .1, p.y));\n    \n    p.y += .2;\n\n    p.z *= mix(1.0, 1.35, saturate(p.x * p.x * .5));\n    p.x *= mix(.3, .2, smoothstep(.5, 2.5, abs(p.z)));\n        \n    float d = sdTorus82(p, vec2(3.0, .01)) * .1 - .005;\n    \n    // sdf fix for ao/shadows\n    d = max(d, fBox(op, vec3(1.0, 1.3, 3.5)) * 1.5);\n        \n    return d;\n}\n\nfloat centerRibbon(vec3 p)\n{    \n    vec3 op = p;\n    p.y += .1;\n    p.y *= mix(1.5, 1.0, smoothstep(.0, .1, p.y));\n    p.x *= .5;\n    p.y *= 2.3;\n    float r = saturate(p.x * p.x);    \n    float d = sdTorus82(p, vec2(mix(.75, 1.9, r), .16)) * .1;\n    \n    // sdf fix for ao/shadows\n    d = max(d, fBox(op, vec3(.5, .5, 1.2)) * 1.5);\n    \n    return d;\n}\n\nfloat strap(vec3 p)\n{\n    p.x -= 1.9;\n    p.y += .35;\n    \n    float x = p.x - .75;\n    vec3 rp = p - vec3(0.0, -.5, 0.0);\n    p = mix(p, rotateZ(rp, -1.57), saturate(x * .35));\n    \n    p.x -= abs(p.z) * .4;\n    \n \treturn fBox(p, vec3(1.5, .075, .5)) * .5;   \n}\n\nfloat boxLid(vec3 p)\n{\n    p.y += 1.3;\n    p.xz *= mix(1.0, 1.1, saturate((p.y - .375) * 2.5));\n        \n    float r = 1.0 - (smoothstep(.6, .75, abs(p.z)) + smoothstep(.6, .75, abs(p.x)));\n    \n    float d = fBox(p, vec3(2.6, .6, 2.6) - r * .1);\n    \n    vec3 rp = rotateY(p, .787);\n    d = max(d, fBox(rp, vec3(3.7)));\n    \n    return d * .5;\n}\n\nfloat lidStraps(vec3 p)\n{\n    p.zx = mix(p.zx, p.xz, step(.65, abs(p.z)));\n    \n    p.y += 1.3;\n    p.xz *= mix(1.0, 1.1, saturate((p.y - .375) * 2.5));        \n    float r = 1.0 - (smoothstep(.6, .75, abs(p.z)) + smoothstep(.6, .75, abs(p.x)));    \n    float d = fBox(p, vec3(2.8, .75, .6));        \n    return d * .5;\n}\n\nfloat mainBox(vec3 p)\n{\n    p.y += 3.2;\n    \n    float r = 1.0 - (smoothstep(.6, .75, abs(p.z)) + smoothstep(.6, .75, abs(p.x)));    \n    float d = fBox(p, vec3(2.45, 2.25, 2.45) - r * .1);\n    \n    vec3 rp = rotateY(p, .787);\n    d = max(d, fBox(rp, vec3(3.45)));\n    \n    return d;\n}\n\nfloat mechGold(vec3 p)\n{\n    p.zx = mix(p.zx, p.xz, step(.8, abs(p.z)));\n    p.x = abs(p.x) - 2.4;\n    \n    p.y += 2.45 + mechTime() * 1.;\n    \n    return fBox(p, vec3(.3, .2, .6));\n}\n\nfloat mechInner(vec3 p)\n{\n    p.zx = mix(p.zx, p.xz, step(1.5, abs(p.z)));\n    p.x = abs(p.x);\n    \n    p.x -= 2.275;\n    p.y += 5.0;\n    \n    p -= vec3(0., 2.0, 0.0);    \n    \n    float d = fBox(p, vec3(.2, 1.7, .6)) * .5;\n    \n    p.x -=.1;\n    \n    p.y = mod(p.y * 3.0, 1.0) * .33;\n    d = max(d, -fCapsule(p.yzx, .2, .3));\n    \n    return d;\n}\n\nfloat mech(vec3 p)\n{\n    p.zx = mix(p.zx, p.xz, step(1.5, abs(p.z)));\n    p.x = abs(p.x);\n    \n    p.x -= 2.5;\n    p.y += 5.0;\n        \n    float d = fBox(p, vec3(.15, .5, .6));\n    \n    p -= vec3(-.1, 2.0, 0.0);\n        \n    float t = mechTime();\n    p.y += 1.0 + mechTime() * 1.;\n    \n    float e = p.y - .4 - t * .5;\n    p.x -= exp(- e * e * (4.0 + t * 16.0) ) * t * .3;\n    \n    d = min(d, fBox(p, vec3(.15, 1.7, .55)) * .5);\n    \n    return d;\n}\n\nvec3 lidAnimation(vec3 p)\n{\n    float buildup = mechTime();\n    \n    p.y += sin(buildup * 123.0) * buildup * buildup * .2;\n    \n    p = rotateX(p, sin(buildup * 36.0) * buildup * buildup * .055);\n    p = rotateZ(p, sin(buildup * 25.0 + 2.1) * buildup * buildup * .045);\n    p = rotateY(p, sin(buildup * 55.0 + 1.1) * buildup * buildup * .035);\n    \n    return p;\n}\n\nvec2 sdf(vec3 p)\n{\n    vec2 d = vec2(50.0, 0.0);\n    \n    float bounds = length(p + vec3(0.0, 3.0, 0.0)) - 5.0;\n    \n    if(bounds < .5)\n    {\n        vec3 lidP = lidAnimation(p);\n            \n    \td = opU(d, vec2(ribbon(lidP), RIBBON_MATERIAL));\n        d = opU(d, vec2(ribbon(rotateY(lidP, .5)), RIBBON_MATERIAL));        \n\t\t\n        d = opU(d, vec2(centerRibbon(rotateY(lidP, 1.87)), RIBBON_MATERIAL));\n        \n        d = opU(d, vec2(strap(rotateY(lidP, -.3)), RIBBON_MATERIAL));\n        d = opU(d, vec2(strap(rotateY(lidP, 1.23)), RIBBON_MATERIAL));\n        \n    \td = opU(d, vec2(mech(p), RIBBON_MATERIAL));\n        d = opU(d, vec2(mechGold(p), GOLD_MATERIAL));\n        d = opU(d, vec2(mechInner(p), METAL_MATERIAL));      \n\n        d = opU(d, vec2(mainBox(p), BOX_MATERIAL));\n        d = opU(d, vec2(boxLid(lidP), BOX_MATERIAL));\n        \n        d = opU(d, vec2(lidStraps(lidP), RIBBON_MATERIAL));\n        \n    }\n    else\n    {\n        d.x = min(d.x, bounds);\n    }\n    \n    d = opU(d, vec2(p.y + 5.7, GROUND_MATERIAL));\n\n\treturn d;\n}\n\n// No materials\nfloat sdf_simple(vec3 p)\n{\n    float d = 50.0;\n    \n    vec3 lidP = lidAnimation(p);\n            \n    d = min(d, ribbon(lidP));\n    d = min(d, ribbon(rotateY(lidP, .5))); \n\n    d = min(d, centerRibbon(rotateY(lidP, 1.87)));\n\n    d = min(d, strap(rotateY(lidP, -.3)));\n    d = min(d, strap(rotateY(lidP, 1.23)));\n\n    d = min(d, mech(p));\n    d = min(d, mechGold(p));\n    d = min(d, mechInner(p));\n\n    d = min(d, mainBox(p));\n    d = min(d, boxLid(lidP));\n\n    d = min(d, lidStraps(lidP));\n    d = min(d, p.y + 5.7);\n\n\treturn d;\n}\n\nfloat sdfDensity(vec3 p)\n{\n    p.y += 3.75;    \n    p.xz *= mix(1.0, 1.25, saturate(p.y * .6));\n    float d = fBox(p, vec3(2.65, 1., 2.65));    \n    float tx = (sin((p.x+ iTime) * 4.0) * .5 + .5) + (sin((p.z+ iTime*3.0) * 4.0) * .5 + .5);\n    \n    float density = saturate(1.0 - d * .9);    \n    density *= tx * pow(length(p.xz) * .3, 12.0) * smoothstep(0.0, 1.0, p.y);\n    \n    return density + max(0.0, 5.0 - length(p.xz)) * .0025;\n}\n\nvec3 sdfNormal(vec3 p, float epsilon)\n{\n    vec3 eps = vec3(epsilon, -epsilon, 0.0);\n    \n\tfloat dX = sdf_simple(p + eps.xzz) - sdf_simple(p + eps.yzz);\n\tfloat dY = sdf_simple(p + eps.zxz) - sdf_simple(p + eps.zyz);\n\tfloat dZ = sdf_simple(p + eps.zzx) - sdf_simple(p + eps.zzy); \n\n\treturn normalize(vec3(dX,dY,dZ));\n}\n\n// https://www.shadertoy.com/view/Xts3WM\nfloat curv(in vec3 p, in float w)\n{\n    vec2 e = vec2(-1., 1.) * w;   \n    \n    float t1 = sdf_simple(p + e.yxx), t2 = sdf_simple(p + e.xxy);\n    float t3 = sdf_simple(p + e.xyx), t4 = sdf_simple(p + e.yyy);\n    \n    return .25/e.y*(t1 + t2 + t3 + t4 - 4.0*sdf_simple(p));\n}\n\nfloat evaluateShadows(vec3 origin, vec3 toLight)\n{\n    float res = 1.0;\n    \n    for( float t = .05; t < 2.0; )\n    {\n        float h = sdf_simple(origin + toLight*t);\n        if( h < 0.001 )\n            return 0.0;\n        \n        res = min( res, 12.0*h/t );\n        t += h * .5 + .001;\n    }\n    return res;\n}\n\nconst int aoIter = 10;\nconst float aoDist = 0.01;\nconst float aoPower = 2.0;\n\n// https://www.shadertoy.com/view/XlXyD4\nfloat evaluateAmbientOcclusion(vec3 p, vec3 n) \n{\n    float dist = aoDist;\n    float occ = 1.0;\n    \n    for (int i = 0; i < aoIter; ++i) {\n        occ = min(occ, sdf_simple(p + dist * n) / dist);\n        dist *= aoPower;\n    }\n    occ = max(occ, 0.0);\n    return occ;\n}\n\nvec3 triplanar(vec3 P, vec3 N)\n{    \n    vec3 Nb = abs(N);\n    \n    float b = (Nb.x + Nb.y + Nb.z);\n    Nb /= vec3(b);\t\n    \n    vec3 c0 = texture(iChannel1, P.xy).rgb * Nb.z;\n    vec3 c1 = texture(iChannel1, P.yz).rgb * Nb.x;\n    vec3 c2 = texture(iChannel1, P.xz).rgb * Nb.y;\n    \n    return c0 + c1 + c2;\n}\n\nvec3 lighting(vec3 rayO, vec3 rayD, float t, vec2 d, float density)\n{\n    float m = d.y;\n    \n    if(m < .5)\n        return vec3(0.0);\n    \n    \n    vec3 lPos = vec3(4.0, 3.0, 4.0);\n    vec3 p = rayO + rayD * t;\n    vec3 normal = sdfNormal(p, .05);\n    float spotLight = smoothstep(12.0, 0.0, length(p.xz));\n    \n    if(m > GROUND_MATERIAL - .5 && m < GROUND_MATERIAL + .5)\n    {\n        normal = mix(normal, normalize(normal + texture(iChannel1, p.xz * .4).xyz * .2), spotLight);\n        \n        vec3 noise = texture(iChannel3, p.xz * .3).xyz;\n        normal = mix(normal, normalize(normal + (noise * 2.0 - vec3(1.0)) * .5), spotLight * smoothstep(.2, .3, noise.y * noise.x * noise.z));\n    }\n    \n    vec3 R = reflect(-rayD, normal);\n    \n    vec3 toLight = normalize(lPos - p);\n    vec3 H = normalize(toLight - rayD);\n    \n    float curvW = texture(iChannel0, p.xz + p.yy).r;\n    float curvature = curv(p, mix(.05, .2, curvW)) * 1.1; // :D\n    \n    float rim = pow(max(1.0 - dot(normal, -rayD), 0.0), 4.0) * .5;    \n   \tfloat diffuse = dot(normal, toLight);\n    float bounce = saturate(-diffuse); \n    diffuse = max(0.0, diffuse);\n    \n    \n    vec3 refl = pow(texture(iChannel2, R).rgb, vec3(2.2));\n    float tx = smoothstep(.2, .5, triplanar(p * .35, normal).x);\n    float specular = pow(saturate(dot(normal, H)), 8.0 + tx * 3.0);\n    \n    vec3 color = vec3(diffuse);    \n    vec3 lightColor = vec3(1.5, 1.5, 1.75);\n    vec3 specularColor = vec3(.9, .95, 1.0) * .45 * lightColor;\n    \n    float ao = evaluateAmbientOcclusion(p, normal);\n    ao = smoothstep(.0, .5, ao);\n    \n    float shadowStrength = .95;\n    float shadow = evaluateShadows(p, toLight);\n    shadow = mix(shadow, 1.0, 1.0 - shadowStrength);\n    \n    float r = 2.0 - (smoothstep(.4, .5, abs(p.z)) + smoothstep(.4, .5, abs(p.x)));\n    \n\tfloat lightTime = mechTime();\n    vec3 glowColor = pow(vec3(.4, .75, .15), vec3(2.2)) * lightTime;\n        \n    if(m < RIBBON_MATERIAL + .5)\n    {\n        color = vec3(.5, 0.1, 0.075) * (1.0 + curvature * 1.5);\n        \n        color += color * abs(sdf_simple(p - normal * .3) / .25);\n        specular *= specular * specular;\n        specularColor *= .25;\n        rim *= .25;\n    }\n    else if(m < BOX_MATERIAL + .5)\n    {\n        float pattern = smoothstep(-.15, .15, sin((p.x - p.y + p.z) * 2.3 - 1.1));\n        color = mix(vec3(.15, .4, .1), vec3(.2, .9, .2), pattern);\n        color += vec3(.5, 1.0, .5) * curvature * curvature * 4.0;\n        rim *= .2;\n        \n        color = mix(color, vec3(1.2, 1.0, .5) * 7.0, r);\n    }\n    else if(m < GOLD_MATERIAL + .5)\n    {\n\t\tcolor = (vec3(1.2, .9, .3) + refl * refl) * 1.5;\n        specularColor = refl * 2.0;\n    }\n    else if(m < GROUND_MATERIAL + .5)\n    {\n\t\tcolor = vec3(.2, .25, .275) * (1.4 + spotLight * diffuse) * 1.45;\n        \n        color += glowColor * .5 * saturate(1.0 - max(-fBox2(p.xz, vec2(4.0)), length(p.xz) - 5.25));\n        \n        specular *= .1;\n        rim = 0.0;\n        \n        normal = normalize(normal + texture(iChannel1, p.xz * .1).xyz); \n    }\n    else if(m < METAL_MATERIAL + .5)\n    {\n\t\tcolor = (vec3(.6) + refl * refl) * 1.5;\n        specularColor = refl * 2.0;\n    }\n    \n    color = pow(color, vec3(2.2)) * spotLight;\n    \n    vec3 ambientLight = vec3(.65, .5, 1.0);\n    \n    vec3 outColor = color * diffuse + specularColor * specular + ambientLight * rim;\n    outColor *= shadow;\n    outColor = mix(outColor * .1 * ambientLight, outColor, ao);\n    outColor += vec3(.3, .1, .1) * bounce * bounce * color;\n    \n    outColor += glowColor * density * .03;\n    \n    return pow(outColor * lightColor, vec3(.454));\n}\n\nvec4 trace(vec3 rayO, vec3 rayD)\n{    \n    float maxDistance = 35.0;\n    float t = 18.25;\n    vec2 d = vec2(0.0);\n    float density = 0.0;\n    \n\tfor(int j = 0; j < 200; j++)\n\t{\n        vec3 p = rayO + rayD * t;\n\t\td.x = sdf_simple(p);\n        density += sdfDensity(p);\n\n\t\tif(d.x < .01)\n            break;\n\n\t\tt += d.x;\n        \n        if(t > maxDistance)\n            break;\n\t}\n    \n    d = sdf(rayO + rayD * t);\n    \n    return vec4(t, d, density);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (-iResolution.xy + (fragCoord*2.0)) / iResolution.y;\n    \n    float vignette = 1.0 - pow(length(uv) / 2., 3.0);\n    \n    float time = .65 + iTime * .0;\n    vec3 target = vec3(0.0, -2.9, 0.0);\n    float dist = 22.0;\n    \n    float cT = cameraIntroTime();\n    \n    vec3 p = vec3(0.0, 3.5, 0.0) + vec3(cos(time), sin(cT * 6.28 * 2.0) * .02, sin(time)) * dist;\n    \n    vec3 offset = vec3(cos(cT * 83.0), -sin(cT * 55.0 + .4), sin(cT * 72.0)) * .1 * cT;    \n    offset.y += longTailImpulse(35.0, explosionTime()) * 15.0;\n    offset.y -= impulse(8.0, max(0.0, cameraIntroTime() - .8)) * 3.0;\n        \n    // Impulse doesn't get to 0 on time\n    target += offset * smoothstep(9.5, 8.5, animationTime());\n    \n    vec3 forward = normalize(target - p);\n    vec3 left = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(forward, left));    \n    \n    float zoom = mix(.25, .2, cT);\n    vec3 rayOrigin = p;\n    vec3 rayDirection = normalize(forward + left * uv.x * zoom - up * uv.y * zoom);\n    \n    vec2 screenUV = fragCoord / iResolution.xy;\n    \n    vec4 data = trace(rayOrigin, rayDirection);\n    \n    vec3 color = lighting(rayOrigin, rayDirection, data.x, data.yz, data.w);\n    \n    float gT = impulse(70.0, glowTime());\n    uv *= mix(1.0, .3, gT);\n \tvec3 glowColor = vec3(.3, .75, .15);\n    vec3 fx = glowColor * pow(saturate(1.0 - length(uv)), 2.0);\n    fx += glowColor * pow(saturate(1.0 - length(uv * vec2(.25, 1.0))), 2.0);\n    fx += glowColor * pow(saturate(1.0 - length(uv * vec2(.1, 7.0))), 2.0);\n    \n    color += fx * gT;\n\tfragColor = vec4(mix(color * color * vec3(1.0, .2, .9), color, vignette), 1.0);\n}","name":"Image","description":"","type":"image"}]}