{"ver":"0.1","info":{"id":"lfVyz3","date":"1732198238","viewed":95,"name":"wetland","username":"lerrain","description":"The wetland at the foot of the mountain; \nBy holding down the mouse button and dragging, you can adjust the perspective.\nthanks to IQ、otaviogood and XT95","likes":7,"published":3,"flags":0,"usePreview":0,"tags":["noise","wave","sea","cloud","water","landscape","snow","lake","rock","mountain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITER 5000\n#define MAX_FAR 40000.\n#define GROUND_ITER 12\n\n#define SEA_NORMAL_SC 5000.0\n#define SEA_MAX 1.\n\n#define CLOUD_MAX_ITER 1000\n#define CLOUD_RAY_STEP 0.02\n#define CLOUD_MIN 30.\n#define CLOUD_MAX 5000.\n#define CLOUD_MIN2 1200.\n#define CLOUD_MAX2 3000.\n\n#define TEX_N3D\n//#define TEX_N2D\n\nconst vec3 SUN_TD = normalize(vec3(.5, .4, -1.));\nconst vec3 SUN_COLOR = vec3(1.0f, 0.95f, 0.65f);\n\nmat3 setCamera(in vec3 ro, in vec3 ta) {\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(0, 1, 0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat n3d(in vec3 p) {\n    #ifdef TEX_N3D\n        vec3 c = floor(p);\n        vec3 f = fract(p);\n        f = f*f*(3.0-2.0*f);\n        vec2 uv = (c.xy+vec2(37.0,239.0)*c.z) + f.xy;\n        vec2 rg = textureLod(iChannel0,(uv+0.5)/256.0,0.0).yx;\n        return mix( rg.x, rg.y, f.z );\n    #else\n        const vec3 s = vec3(113, 157, 1);\n        vec3 ip = floor(p);\n        vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n        p -= ip;\n        p = p*p*(3. - 2.*p);\n        h = mix(fract(sin(h)*43758.5453123), fract(sin(h + s.x)*43758.5453123), p.x);\n        h.xy = mix(h.xz, h.yw, p.y);\n        return mix(h.x, h.y, p.z);\n    #endif\n}\n\nfloat fbm( in vec3 p, int iter ) {\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<iter; i++ ) {\n        a += b*n3d(p); \n        b *= .5;\n        p *= 2.;\n    }\n    return a;\n}\n\nfloat n2d(vec2 p) {\n    #ifdef TEX_N2D\n        vec2 c = floor(p);\n        vec2 f = fract(p); \n        f = f*f*(3.0-2.0*f);\n        return textureLod(iChannel0,(c + f +0.5)/256.0,0.0).x;\n    #else\n        vec2 i = floor(p); p -= i; \n        p *= p*(3. - p*2.);  \n        return dot(mat2(fract(sin(mod(vec4(0, 1, 113, 114) + dot(i, vec2(1, 113)), 6.2831853))*43758.5453))*vec2(1. - p.y, p.y), vec2(1. - p.x, p.x));\n    #endif\n}\n\nfloat fbm( in vec2 p, int iter ) {\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<iter; i++ ) {\n        a += b*n2d(p); \n        b *= .5;\n        p *= 2.;\n    }\n    return a;\n}\n\nfloat ground(in vec2 pos) {\n    float x = pos.x + sin(pos.y * 0.001) * 1000.;\n    float a = 0.;\n    if (x > 0.)\n        a = fbm(pos * 0.0007, GROUND_ITER) * 1800. * pow(smoothstep(0., 5000., x), 3.0);\n    float h = smoothstep(5000., 0., x);\n    if (h > 0.)\n        a += (fbm(pos * 0.005, GROUND_ITER) - .5) * 100. * h;\n    return a + x * 0.005;\n}\n\nvec3 calcNormal( in vec3 pos, float f ) {\n    vec2 eps = vec2( f, 0.0 );\n    return normalize( vec3(ground(pos.xz-eps.xy) - ground(pos.xz+eps.xy), 2.0*eps.x, ground(pos.xz-eps.yx) - ground(pos.xz+eps.yx)) );\n}\n\nfloat softShadow(in vec3 ro, float dis) {\n    float start = clamp(dis*0.01,0.01,150.0);\n    float res = 1.;\n    vec2 tp;\n    for( float t=start; t<3000.; t*=2. ) {\n        vec3 pos = ro + t*SUN_TD;\n        float h = pos.y - ground(pos.xz);\n        res = min( res, 16.0*h/t );\n        if( res<0.001 || pos.y>2000.0 ) break;\n    }\n    return clamp( res, 0., 1.0 );\n}\n\nfloat addFog(float y, float t, float step) {\n    float fog = 0.;\n    if (t > 10000.) {\n        float dp = smoothstep(3000.0, 100.0, y);\n        fog += pow(dp, .5) * 0.0001 * step;\n    }\n    if (t > 30000.) \n        fog += 0.0001 * step;\n    return fog;\n}\n\nfloat cloudsMap(vec3 pos) {\n    if (pos.y < CLOUD_MIN || pos.y > CLOUD_MAX)\n        return 0.;\n\n    vec3 p = vec3(pos.x*0.00075,pos.y*0.001,pos.z*0.00075)+0.07*vec3(iTime*3.0,1.7*iTime,-0.2*iTime);\n    float n = fbm(p, 6);\n    if (pos.y < CLOUD_MIN2)\n        n -= (CLOUD_MIN2 - pos.y) / (CLOUD_MIN2 - CLOUD_MIN);\n    else if (pos.y > CLOUD_MAX2)\n        n -= (pos.y - CLOUD_MAX2) / (CLOUD_MAX - CLOUD_MAX2);\n    return n;\n}\n\nvec3 drawCloud( in vec3 ro, in vec3 rd, in float resT ) {\n    float tmin = CLOUD_MIN > ro.y && rd.y > 0. ? (CLOUD_MIN-ro.y)/rd.y : 0.1;\n    float t = tmin;\n    float thick = 0.;\n    float light = 0.;\n    float dec = 1.;\n    float fog = 0., cFog = 0.;\n    //if (resT >= MAX_FAR) //高空可见度大 可以看的更远 云要接近地平线\n    //    resT = MAX_FAR * 10.;\n    for (int i=0; i<CLOUD_MAX_ITER && t < resT; i++) {\n        vec3 pos = ro + t*rd;\n        if (rd.y > 0. && pos.y >= CLOUD_MAX)\n            break;\n        if (rd.y < 0. && pos.y < CLOUD_MIN)\n            break;\n        float f1 = max(cloudsMap(pos) - 0.55, 0.) * 0.05;\n        float den = f1;\n        float dt = max(1.0,CLOUD_RAY_STEP*t);\n        float pl = 0.;\n        if (den > 0.001) {\n            float rDec = 1. - cloudsMap(pos+SUN_TD*200.);// * 1.9;\n            //for (float i=100.;i<1100.;i+=200.)\n            //    rDec -= cloudsMap(pos+SUN_TD*i) * .2;\n\n            float spk = den*0.1*dt; //反射率\n            dec *= (1.0 - spk * .5); //云内衰减\n            if (dec < 0.001)\n                break; \n\n            pl = max(0., rDec) * 3. * dec * spk;\n        }\n\n        if (t > 20000.) \n            fog += 0.0001 * dt;\n        //if (fog > 1.)\n        //    break;\n        //fog += addFog(pos.y, t, dt);\n        cFog += fog * pl;\n        light += pl;\n\n        t += dt;\n    }\n\n\n    return vec3(min(1., (1. - dec) * 1.1), light, cFog);\n    //return vec4(min(1., (1. - dec) * 1.1), light, light > 0. ? cFog / light : 0., t - tmin);\n}\n\nvec3 getSun(vec3 rd, float s, float shine) {\n    float mu = dot(rd, SUN_TD);\n    float opmu2 = 1. + mu*mu;\n    float phaseS = .1193662 * (1. - s) * opmu2 / ((2. + s) * pow(1. + s - 2.*s*mu, 1.5));\n    return vec3(shine) * SUN_COLOR * phaseS; \n}\n\nvec3 drawSky(vec3 ro, vec3 rd){ \n    vec3 sky = mix(vec3(.6, .7, .9), vec3(.35, .62, 1.2), pow(max(rd.y + .15, 0.), .5));\n    //vec3 sky = vec3(.42, .62, 1.1);\n    //vec3 sky = vec3(0.42,0.62,1.1) - rd.y*0.4;\n    sky *= .5;\n    sky += getSun(rd, 0.99999, 10.);\n    \n    const float sc = 1e5;\n    float t = (sc - ro.y - .15)/(rd.y + .15); \n    if (t > 0.) {\n        vec2 uv = (ro + t*rd).xz; \n        uv.x += iTime * 1000.;\n        sky =  mix(sky, vec3(2), smoothstep(.45, 1., fbm(1.5*uv/sc, 3))*smoothstep(.45, .55, rd.y*.5 + .5)*.4);\n    }\n    return sky;\n}\n\nfloat seaSurf(vec2 pxz, float far) {\n    float waterNoise = 0.;\n    if (far < 1000.)\n        waterNoise += n2d(pxz*.1+iTime)*0.5;\n    if (far < 500.)\n        waterNoise += n2d(pxz+iTime)*0.1;\n    if (far < 250.)\n        waterNoise += n2d(pxz*2.0+iTime)*0.03;\n    if (far < 125.)\n        waterNoise += n2d(pxz*4.0-iTime)*0.015;\n    if (far < 64.)\n        waterNoise += n2d(pxz*8.0-iTime)*0.005;\n    if (far < 32.)\n        waterNoise += n2d(pxz*16.0-iTime)*0.002;\n    return waterNoise * 2. * SEA_MAX;// * (0.8 + wave * 5.) * farSmooth;\n}\n\nvec3 drawMountain(vec3 pos, vec3 rd, float resT, bool wet) {\n    float h = smoothstep(700.0,1200.0,pos.y + 500.0*fbm(0.005*pos.xz, 3) );\n    vec3 col = vec3(0.18,0.12,0.10)*.85;\n    vec3 tnor;\n    float s;\n    if (h > 0.) {\n        tnor = calcNormal( pos, 0.0004*resT );\n        float e = smoothstep(1.0-0.5*h,1.0-0.1*h,tnor.y);\n        float o = 0.3 + 0.7*smoothstep(0.0,0.1,tnor.x+h*h);\n        s = smoothstep( 0.1, 0.9, h*e*o);\n    } else {\n        s = 0.;\n        tnor = calcNormal( pos, 0.0002*resT );\n    }\n    vec3 nor = tnor; //normalize( tnor + 0.8*(1.0-abs(tnor.y))*0.8*fbm((pos-vec3(0,600,0))*0.15*vec3(1.0,0.2,1.0), 12));\n    col = mix( col, vec3(0.1,0.1,0.0)*0.2, smoothstep(0.7,0.9,nor.y) );      \n    col = mix( col, 0.69*vec3(0.62,0.65,0.7), s);\n    float dif = clamp(dot( nor, SUN_TD), 0., 1.); \n    dif *= clamp(softShadow(pos,resT), 0., 1.);\n\n    float bac = clamp(dot(normalize(vec3(-SUN_TD.x,0.0,-SUN_TD.z)),nor),0.,1.);\n    // float foc = clamp( (pos.y/2.0-180.0)/130.0, 0.0,1.0);\n    float dom = clamp( 0.5 + 0.5*nor.y, 0.3, 1.0 );\n    vec3  lin  = 0.2*mix(0.8*vec3(0.1,0.2,0.1),vec3(0.7,0.9,1.5)*3.0,dom); //*foc;\n    lin += 8.5*vec3(1.0,0.9,0.8)*dif;        \n    lin += 0.27*vec3(1.1,1.0,0.9)*bac; //*foc;\n    col *= lin;\n\n    vec3  ref = reflect(rd,nor);\n    float fre = clamp(1.0+dot(nor,rd),0.,1.);\n    float spc = clamp(dot(ref,SUN_TD),0.,1.);\n    float spe = 3.0*pow(spc, 9.0)*(0.05+0.95*pow(fre,5.0));\n    col += spe*vec3(4.0)*dif;//smoothstep(0.0,200.0,pos.y-700.0);;\n    if (wet) {\n        float ran = n2d(pos.xz*.1);\n        if (pos.y < 5. + ran * 10.) {\n            float sc = smoothstep(5. + ran * 10., 1., pos.y);\n            col = mix(col, vec3(1.,.8,.5) * pow(spc, 50.) *dif* 200.*sc, sc*.5);\n        }\n    }\n    return col;\n}\n\nfloat raymarch(in vec3 ro, in vec3 rd, float scale, out int type) {\n    float t = 1.;\n    float y, h, step;\n    for( int i=0; i<MAX_ITER && t < MAX_FAR; i++) {\n        vec3 pos = ro + t*rd;\n        if (pos.y < 0.) {\n            type = 0;\n            return t;\n        }\n        if (rd.y > 0. && pos.y > 2000.)\n            break;\n\n        y = ground(pos.xz);\n        type = 1;\n\n        if (scale == 1. && y < SEA_MAX) {\n            float sy = seaSurf(pos.xz, t);\n            if (sy > y) {\n                y = sy;\n                type = 0;\n            }\n        }\n\n        float wd = t * .000125;\n        h = pos.y - y;\n        if (h < wd) {\n            return t;\n        }\n\n        step = max(0.001 * t, h * 0.5) * scale;\n        //fog += addFog(pos.y, t, step);\n        //if (fog >= 1.)\n        //    break;\n\n        t += step;\n    }\n    return MAX_FAR; //未命中\n}\n\nvec3 waterNormal( in vec2 pos, float resT ) {\n    vec2 eps = vec2( resT / SEA_NORMAL_SC * resT, 0.0 );\n    return normalize( vec3(seaSurf(pos-eps.xy,resT) - seaSurf(pos+eps.xy,resT), 2.0*eps.x, \n    seaSurf(pos-eps.yx,resT) - seaSurf(pos+eps.yx,resT)) );\n} \n\nvec3 drawSea(vec3 pos, vec3 rd, float sha, float resT) {\n    vec3 seaColor = vec3(0.002, 0.6, 0.51) * .7;\n    vec3 normal;\n    if (resT > 2000.)\n        normal = vec3(0,1,0);\n    else\n        normal = waterNormal(pos.xz, resT);\n\n    //折射\n    vec3 refract = refract( rd, normal, 1.0f / 1.3333f );\n    vec3 pis;\n    float a;\n    for(float rT = 0.01; rT < 150.; rT += 0.01 + max(a*.5, (resT + rT) * 0.001)) {\n        pis = pos + rT*refract;\n        float deep = ground(pis.xz);\n        a = pis.y - deep;\n        float wd = 0.001 * (resT + rT);\n        if (a <= wd) {\n            float ds = clamp(rT, 0., 50.) / 50.; //视线向深浅\n            if (ds < 1.) { \n                float sc = pow(ds, .5);\n                vec3 col = drawMountain(pis, refract, resT + rT, false);\n                seaColor = mix(col, seaColor, sc);\n            }\n            break;\n        }\n    }\n    seaColor = mix(seaColor, vec3(0), sha); //折射阴影\n\n    //反射\n    float fresnel = 0.02 + 0.98 * pow(1. - max(dot(-rd, normal), 0.), 5.);\n    vec3 ref = normalize(reflect(rd, normal));\n    ref.y = abs(ref.y);\n    vec3 fCol;\n    int refType;\n    //float fog;\n    float refResT = raymarch(pos, ref, 10., refType);\n    \n    vec3 refPos = pos + refResT * ref; \n    if (refResT < MAX_FAR) {\n        if (refType == 0) {\n            fCol = seaColor * (dot(SUN_TD, waterNormal(refPos.xz, resT / SEA_NORMAL_SC * resT)) + 2.0) / 3.0;\n            fCol *= softShadow(refPos, resT);\n        } else if (refType == 1) {\n            fCol = drawMountain(refPos, ref, refResT + resT, true);\n        } else {\n            fCol = vec3(1,0,0);\n        }\n        //反射的要考虑反射处的阴影，不明显先不画了\n    } else {\n        fCol = drawSky(refPos, ref);\n        fCol += getSun(ref, 0.99999, 200.);\n    }\n    \n    if ((pos.y > CLOUD_MIN || refPos.y > CLOUD_MIN) && (pos.y < CLOUD_MAX || refPos.y < CLOUD_MAX)) {\n        vec3 res = drawCloud( pos, ref, refResT ); \n        //fCol = mix(fCol, vec3(res.y*0.3 + .7), res.x);\n        //fCol = mix(fCol, mix(vec3(pow(clamp(res.y, 0., 1.), .2)*.4 + .6), vec3(.6, .7, .9), res.z), res.x); \n        vec3 cCol = vec3(pow(clamp(res.y, 0., 1.), .2)*.4 + .6);\n        if (res.y > 0.) {\n            cCol = mix(cCol, vec3(.6, .7, .9), res.z / res.y);\n        }\n        fCol = mix(fCol, cCol, res.x); \n    }\n\n    //迷雾也要考虑\n    return mix(seaColor, fCol, fresnel);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ro, ta;\n    if (iMouse.z + iMouse.w > 0.) {\n        vec2 lk = (iMouse.xy / iResolution.xy);\n        ro = vec3(-900, 20. + lk.y * 4900., (0.5-lk.x) * 5000.);\n        ta = vec3(lk.y * 5000., 20, 0);\n        ro.y += max(0., ground(ro.xz));\n        ta.y += max(0., ground(ta.xz));\n    } else {\n        int phase = int(iTime / 10.) % 4;\n        float time = mod(iTime, 10.);\n        if (phase == 3) {\n            float mv = 1. - time / 50.;\n            ro = vec3(-900. * mv, 30., 2500. * mv);\n            ta = vec3(0., 0, 0);\n        } else if (phase == 1) {\n            ro = vec3(-1000, 1000. + time * 400., -2000);\n            ta = vec3(time * 600., 20, 0);\n        } else if (phase == 2) {\n            float mv = 1. - time / 300.;\n            float mv2 = 1. - time / 150.;\n            ro = vec3(-1000. * mv, 30., -2500. * mv);\n            ta = vec3(-1000. * mv2, 0., -2500. * mv2);\n        } else {\n            float deg = (time-5.)/5.;\n            ro = vec3(-1000, 30, 0);\n            ta = vec3(cos(deg)*3000., 30, sin(deg) * 3000.);\n        }\n    }\n\n    mat3 ca = setCamera( ro, ta );\n    vec2 p = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n    vec3 rd = ca * normalize(vec3(p, sqrt(3.)));\n\n    float resT;\n\n    int type = -1;\n    vec3 fCol;\n    //float fog = 0.;\n    resT = raymarch(ro, rd, 1., type);\n    vec3 pos = ro + rd * resT;\n\n    if (resT < MAX_FAR) {\n        float sha = 0.;\n        if (SUN_TD.y > 0.) { \n            float cloudFar = (max(CLOUD_MIN2, pos.y) - pos.y) / SUN_TD.y;\n            //float cloudRest = MAX_FAR;\n            //vec4 cloud = drawCloud(pos, SUN_TD, cloudRest);\n            //fCol = mix(fCol, vec3(0), cloud.x * .7);\n            sha = smoothstep(0.4, 0.8, cloudsMap(pos + SUN_TD * cloudFar)) * .8;\n        }\n        if (type == 0) {\n            fCol = drawSea(pos, rd, sha, resT);\n        } else {\n            fCol = drawMountain(pos, rd, resT, true);  \n            fCol = mix(fCol, vec3(0), sha);\n        }\n    } else {\n        fCol = drawSky(ro, rd);\n    }\n\n    if ((ro.y > CLOUD_MIN || pos.y > CLOUD_MIN) && (ro.y < CLOUD_MAX || pos.y < CLOUD_MAX)) {\n        vec3 res = drawCloud( ro, rd, resT );\n        //fCol = mix(fCol, vec3(res.y*0.3 + .7), res.x);\n        vec3 cCol = vec3(pow(clamp(res.y, 0., 1.), .2)*.4 + .6);\n        if (res.y > 0.) {\n            cCol = mix(cCol, vec3(.6, .7, .9), res.z / res.y);\n        }\n        fCol = mix(fCol, cCol, res.x); \n    }\n    //fCol = mix(fCol, vec3(.6, .7, .9), fog);\n\n    // sun glare    \n    float sun = clamp( dot(SUN_TD,rd), 0.0, 1.0 );\n    fCol += 0.25*SUN_COLOR*pow( sun, 4.0 );\n    // gamma\n    fCol = pow( clamp(fCol*1.1-0.02,0.0,1.0), vec3(0.4545) );\n    // contrast\n    fCol = fCol*fCol*(3.0-2.0*fCol);            \n    // color grade    \n    //fCol = pow( fCol, vec3(1.0,0.92,1.0) );\n    //fCol *= vec3(1.02,0.99,0.9 );         \n    //fCol.z = fCol.z+0.1;   \n\n    fragColor = vec4(fCol, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}