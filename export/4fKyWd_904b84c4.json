{"ver":"0.1","info":{"id":"4fKyWd","date":"1732563571","viewed":51,"name":"Sometimes PI is not a constant","username":"kallaballa","description":"A  visualization of how much the cheap approximation for the perimeter of an ellipse differs from an infinite series.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["pi","ellipses","ramanujan"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Â© shadertoys@viel-zu.org \n// License: AGPL\n\nconst int maxRadius = 1000;\nconst float initialPI = radians(180.0);\nconst int maxSteps = 10000;\n\nfloat map( in vec3 pos ) {\n   return length(pos);\n}\n\nvec3 calcNormal(vec3 p )\n{\n    const float h = 0.0001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) + \n                      k.yyx*map( p + k.yyx*h ) + \n                      k.yxy*map( p + k.yxy*h ) + \n                      k.xxx*map( p + k.xxx*h ) );\n}\n\nfloat computeInfiniteSeriesCircumference(float a, float b) {\n    float h = pow((a - b) / (a + b), 2.0);\n    float seriesSum = 1.0;\n    float hPower = h;\n\n    for (int i = 1; i < maxSteps; ++i) {\n        seriesSum += (pow(0.5, float(2 * i)) * hPower) / float(2 * i - 1);\n        hPower *= h;\n    }\n    return initialPI * (a + b) * seriesSum;\n}\n\n\nfloat computeApproximationCircumference1(float a, float b, float piValue) {\n    float h = pow((a - b) / (a + b), 2.0);\n    return (piValue)*(a+b)*(1.+3.*h/(10.+sqrt(4.-3.*h)));\n}\n\nfloat computeApproximationCircumference2(float a, float b, float piValue) {\n    return 2.0 * piValue * sqrt((pow(a,2.0)+pow(b, 2.0)) / 2.0);\n}\n\nfloat refinePI(float a, float b) {\n    float piValue = initialPI;\n    float targetCircumference = computeInfiniteSeriesCircumference(a, b);\n    float approxCircumference;\n    float error;\n\n    for (int i = 0; i < maxSteps; ++i) {\n        approxCircumference = computeApproximationCircumference1(a, b, piValue);\n        error = approxCircumference - targetCircumference;\n\n        if (abs(error) < 0.0000001) break;\n        piValue -= error * 0.0001;\n    }\n    return piValue;\n}\n\n\nmat4 rotate(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;    \n\n    vec2 r = uv * 4.0 - 2.0;\n\n    if(length(vec2(r.x, r.y * (iResolution.y/iResolution.x))) > 0.70) {\n        fragColor = vec4(0);\n        return;\n    }\n\n    r.x = r.x  * float(maxRadius);\n    r.y = r.y * (iResolution.y/iResolution.x) * float(maxRadius);\n   \n\n    r = (rotate(vec3(0., 0., 1.), iTime) * vec4(r, 1., 1.)).xy;\n    \n\n    float adjustedPI = refinePI(r.x + float(maxRadius) / 2.0, r.y + float(maxRadius) / 2.0);\n    float f = 1500.;\n    vec2 ratio = normalize(vec2(abs((adjustedPI/initialPI)-1.0) * f, 1.0 - abs((adjustedPI/initialPI - 1.0)) * f));\n    vec3 col = vec3(0., 0, 1.0);\n    vec3 pos = vec3(uv, ratio.x);\n    vec3 nor = calcNormal(pos);\n    float dif = dot(nor,vec3(0.5));\n    float amb = 0.65 + 0.30 * dot(nor,vec3(sin(iTime), cos(iTime), 0.0));\n    col = col * dif * amb;\n    col.z = col.z;\n\n    fragColor = vec4(vec3(col), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}