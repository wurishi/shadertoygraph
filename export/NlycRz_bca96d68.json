{"ver":"0.1","info":{"id":"NlycRz","date":"1660827558","viewed":111,"name":"Hash-based non-colliding foliage","username":"GribUser","description":"After playing with https://www.shadertoy.com/view/NtccWs made a simple version, no distorted triangular grid, just plain hash-based noise. Not good (but still usable)","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["foliage"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float TreeCenterSize = TreeSize/2.0;\nvoid mainImage(out vec4 DotColor, vec2 inCoords) {\n\tvec2 ScaledCOords = inCoords / iResolution.x * VoxelsOnScreen;\n\n\tvec2 RelCoords = inCoords / iResolution.xy;\n\tvec2 VoxelSizeOnTexture = vec2(1.0 / VoxelsOnScreen * iResolution.y / iResolution.x,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t 1.0 / VoxelsOnScreen);\n\n\tfloat HasYong = 0.0;\n\tfloat HasMature = 0.0;\n\tfloat HasAging = 0.0;\n\tfloat StageProgress = fract(iTime/FOliageLifetime);\n\n\tfor (float x = -TreeSize; x < TreeSize; x += 1.0) {\n\t\tfor (float y = -TreeSize; y < TreeSize; y += 1.0) {\n\t\t\tvec2 Shift = vec2(x, y);\n\t\t\tfloat L = length(Shift);\n\t\t\tif (L > TreeSize) { continue; }\n\t\t\tvec2 ARelCoords = RelCoords + VoxelSizeOnTexture * vec2(x, y);\n\t\t\tfloat TreeMode = texture(iChannel0, ARelCoords).r;\n\t\t\tif (TreeMode >= 0.8) {\n\t\t\t\tfloat F = L > TreeCenterSize ? 0.3 : 0.6;\n\t\t\t\tif (F > HasAging) { HasAging = F; }\n\t\t\t} else if (TreeMode >= 0.4) {\n\t\t\t\tfloat F = L > TreeCenterSize ? 0.3 : 0.6;\n\t\t\t\tif (F > HasMature) { HasMature = F; }\n\t\t\t} else if (TreeMode > 0.15) {\n\t\t\t\tfloat GrowingTreeSize = TreeSize * StageProgress * 0.8 + 0.2;\n\t\t\t\tif (L <= GrowingTreeSize) {\n\t\t\t\t\tfloat F = L > GrowingTreeSize/2.0 ? 0.4 : 0.8;\n\t\t\t\t\tif (F > HasYong) { HasYong = F; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tDotColor = vec4(HasYong, HasMature, HasAging, 1.0);\n//\treturn;\n\tDotColor = texture(iChannel0, RelCoords);\n\n\tif (DotColor.r != 0.0) {\n        DotColor = vec4(0.1, 1.0, 0.1, 1.0);\n    } else {\n\t\tif (HasAging > 0.0 && (StageProgress < 0.5 || HasMature == 0.0)) {\n\t\t\tDotColor.r = HasAging * smoothstep(0.0, 1.0, StageProgress);\n\t\t\tDotColor.g = HasAging - DotColor.r / 2.0;\n\t\t} else if (HasMature > 0.0) {\n\t\t\tDotColor.g = HasMature;\n\t\t} else if (HasYong > 0.0) {\n\t\t\tDotColor.g = HasYong;\n\t\t\tDotColor.r = HasYong / 3.0;\n\t\t}\n\t}\n//\tfloat Noise = noise_sum(floor((ScaledCOords + iTime * 3.0)) / 100.0, 0.0) * 0.5 + 0.5;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Visual setup\nconst float VoxelsOnScreen = 200.0;\nconst float PlantSpotChance = 0.90;   // 0..100\nconst float PlantGrowIntencity = 0.88;   // 0..100\nconst float FOliageLifetime = 5.0; //sec\nconst float TreeSize = 7.0;\n\n// CityHash32, adapted from Hash32Len5to12 in https://github.com/google/cityhash\n#define c1 0xcc9e2d51u\n#define c2 0x1b873593u\nuint bswap32(uint x) {\n    return (((x & 0x000000ffu) << 24) |\n            ((x & 0x0000ff00u) <<  8) |\n            ((x & 0x00ff0000u) >>  8) |\n            ((x & 0xff000000u) >> 24));\n}\nuint fmix(uint h)\n{\n    h ^= h >> 16;\n    h *= 0x85ebca6bu;\n    h ^= h >> 13;\n    h *= 0xc2b2ae35u;\n    h ^= h >> 16;\n    return h;\n}\nuint rotr(uint x, uint r)\n{\n\treturn (x >> r) | (x << (32u - r));\n}\nuint mur(uint a, uint h) {\n    // Helper from Murmur3 for combining two 32-bit values.\n    a *= c1;\n    a = rotr(a, 17u);\n    a *= c2;\n    h ^= a;\n    h = rotr(h, 19u);\n    return h * 5u + 0xe6546b64u;\n}\n\nuint city(uvec2 s)\n{\n    uint len = 8u;\n    uint a = len, b = len * 5u, c = 9u, d = b;\n\n    a += bswap32(s.x);\n    b += bswap32(s.y);\n    c += bswap32(s.y);\n\n    return fmix(mur(c, mur(b, mur(a, d))));\n}\n// =========== common \nfloat PhaseAtXY(ivec2 Coords){\n    return float(city(uvec2(Coords))) * (1.0/float(0xffffffffu));\n}\nbool CanPlant(float Val){\n    return Val > PlantSpotChance;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 IntCoords = ivec2(floor(fragCoord / iResolution.x * VoxelsOnScreen + iTime * 5.0));\n    \n    bool PlantableVoxel = CanPlant(PhaseAtXY(IntCoords));\n    if (PlantableVoxel){\n        bool BusyPlace = CanPlant(PhaseAtXY(IntCoords + ivec2(1, -1)))\n            || CanPlant(PhaseAtXY(IntCoords + ivec2(0, -1)))\n            || CanPlant(PhaseAtXY(IntCoords + ivec2(-1, -1)))\n            || CanPlant(PhaseAtXY(IntCoords + ivec2(1, 0)));\n        if (BusyPlace){\n            PlantableVoxel = false;\n        }\n    }\n    if (!PlantableVoxel){\n        fragColor = vec4(0.0);\n        return;\n    }\n    int NoisePhase = int(iTime / FOliageLifetime);\n    fragColor = vec4(0.0, 0.3, 0.2, 1.0);\n    \n    float TreeState = 0.0; // no tree\n    if (PhaseAtXY(IntCoords + NoisePhase) > PlantGrowIntencity){\n        TreeState = 0.5;\n    } else {\n        bool AgesAgoGrowth = PhaseAtXY(IntCoords + NoisePhase - 1) > PlantGrowIntencity;\n        if (PhaseAtXY(IntCoords + NoisePhase + 1) > PlantGrowIntencity){\n            if (AgesAgoGrowth){\n                TreeState = 0.5;\n            } else {\n                TreeState = 0.3;\n            }\n        } else if (AgesAgoGrowth) {\n            TreeState = 0.9;\n        }\n    }\n    if (TreeState == 0.0){\n        // No plant here\n        return;\n    } else {\n        fragColor = vec4(TreeState);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}