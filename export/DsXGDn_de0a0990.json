{"ver":"0.1","info":{"id":"DsXGDn","date":"1665935239","viewed":552,"name":"Polar Worley","username":"Oneleven","description":"Another study. Hypertunnel or something. ","likes":45,"published":1,"flags":0,"usePreview":0,"tags":["noise","tunnel","fbm","worley","study","polar","hyper","fractalbrownianmotion"],"hasliked":0,"parentid":"fl3fDH","parentname":"Worley Noise + FMB Study 001"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n#define T iTime\n#define PI 3.141592\n\n//Tweak parameters here! More lines, but I prefer my settings in one place\n//Noise\n#define FREQUENCY 20.0\n#define OCTAVES 4.0\n#define AMPLITUDE 0.45\n#define GAIN 0.55\n#define LACUNARITY 3.\n\n//Scroll\n#define MOVESPEED 0.17\n#define WARPMIN 0.015\n#define WARPMAX 0.045\n\n#define ROTATIONSPEED 0.1\n#define ROTDELTAMIN 0.0\n#define ROTDELTAMAX 0.1\n\n//FabriceNeyret2 + IQ hash\n//https://www.shadertoy.com/view/fsKBzw\nfloat hash( vec2 f ) {   \n    uvec2 x = uvec2( floatBitsToUint(f.x), floatBitsToUint(f.y) ),\n          q = 1103515245U * ( x>>1U ^ x.yx    );\n    return float( 1103515245U * (q.x ^ q.y>>3U) ) / float(0xffffffffU);\n}\n\nfloat cosErp(float min, float max, float p) {\n    float delta = max - min;\n    return (cos(p)*delta + delta) * 0.5 + min;\n}\n\nfloat worley(vec2 uv) {\n    vec2 index = floor(uv);\n    uv = fract(uv);\n\n    float minDist = 2.0;\n    for (float y = -1.0; y<=1.0; y++)\n    {\n        for (float x=-1.0; x<=1.0; x++)\n        {\n            float cellHash = hash(mod(index + vec2(x,y), FREQUENCY));\n            float cellTime = T * (cellHash * 2.0 + 0.1);\n            vec2 offset = vec2(cos(cellTime + cellHash * 100.0), sin(cellTime + cellHash)) * 0.5;\n            float dist = distance(vec2(0.5) + vec2(x,y) + offset, uv);\n\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n\nvoid mainImage( out vec4 O, in vec2 fragCoord ){\n    vec2 uv = (fragCoord - 0.5*R)/R.y; \n    uv.x += sin(T)*0.2;\n    uv.y += cos(T)*0.2;\n    \n    vec2 pUV;\n    float d = dot(uv, uv);\n    pUV.x = pow(d, cosErp(WARPMIN, WARPMAX, T)) - T * MOVESPEED;\n    pUV.y = atan(uv.y, uv.x)/(2.*PI) + cosErp(ROTDELTAMIN, ROTDELTAMAX, T * 0.5) + T * ROTATIONSPEED;\n    \n    float frequency = FREQUENCY;\n    float amplitude = AMPLITUDE;\n    float value;\n    for (float i = 0.0; i < OCTAVES; i++)\n    {\n        value += worley(pUV * frequency) * amplitude;\n        amplitude *= GAIN;\n        frequency *= LACUNARITY;\n    }\n\n    vec3 col;\n    vec3 col1 = vec3(cosErp(2.5, 0.0, value),\n                     cosErp(3.0, 0.0, value),\n                     cosErp(5.0, 0.1, value));\n                     \n    vec3 col2 = vec3(cosErp(0.5, 0.0, value),\n                     cosErp(3.0, 0.1, value),\n                     cosErp(2.0, 0.1, value));\n                     \n    col = mix(col1, col2, worley(uv));\n               \n    //GLOW TUTORIAL by alro https://www.shadertoy.com/view/3s3GDn\n    vec3 glow = vec3(0.017 / pow(d, 0.5));\n    glow *= vec3(2.0, 2.7, 5.5);\n    glow = 1.0 - exp(-glow);\n    col += glow;\n    \n    col *= clamp(vec3(1.0 - pow(d, 0.7) * 1.1) + vec3(0.0, 0.35, 0.5), 0.0, 1.0); //vignette\n    \n    O = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}