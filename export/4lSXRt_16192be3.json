{"ver":"0.1","info":{"id":"4lSXRt","date":"1445646981","viewed":272,"name":"Bubbly blob","username":"ValXp","description":"My first ray marching shader. I am pretty bad at math so I am just playing with the numbers until I get something that looks funny :)","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["testraymarchingdistancefields"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define MAX_ITERATIONS 80.0\n#define MAX_RAY_DISTANCE 15.0\n\nvec3 lightPosition;\nmat4 rotation;\nvec3 diffuseColor = vec3(0.9, 0.02, 0.05);\nvec3 specularColor = vec3(0.1, 0.3, 0.6);\nvec3 ambientColor = vec3(0.01, 0.01, 0.01);\nfloat shininess = 20.0;\nfloat screenGamma = 2.2;\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           -5.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n// Distance field for a box\nfloat boxDist(vec3 point, vec3 box)\n{\n  vec3 d = abs(point) - box;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n// Distance field for a twisted box\nfloat boxTwistDist(vec3 point, vec3 box)\n{\n    float c = cos(.6 * point.y * sin(iTime));\n    float s = sin(.6 * point.y * sin(iTime));\n    mat2  m = mat2(c, -s, s, c);\n    vec3  q = vec3(m * point.xz, point.y);\n    return boxDist(q, box);\n}\n\n// Distance field equation for a sphere.\nfloat sphereDist(vec3 point, vec3 loc, float radius)\n{\n    return length(point - loc) - radius;\n}\n\nfloat bubblySphereDist(vec3 point, vec3 loc, float radius)\n{\n    float sphere1 = sphereDist(point, loc, radius);\n    float sphere2 = sphereDist(point, loc, radius - (radius/1.2));\n    float displacement = sin(6.0*(point.x+iTime))*sin(6.0*(point.y))*sin(6.0*(point.z));\n    return smin(sphere2 + displacement, sphere1, 1.0);\n}\n\nfloat mapBlob(vec3 position)\n{\n    float sphere1 = bubblySphereDist(position, vec3(3.0, -1.0, 8.0), 2.0);\n    \n    float sphere2 = sphereDist(position, vec3(3.0+2.0*sin(iTime), 2.0+0.5*cos(iTime), 8.0+1.0*sin(iTime)), 2.0);\n    float sphere3 = sphereDist(position, vec3(2.0+-2.0*sin(iTime), 1.0+-0.5*cos(iTime), 7.0+-1.0*sin(iTime)), 1.0);\n    \n\n    return smin(smin(sphere1, sphere2, 1.0), sphere3, 1.0);\n}\n\n\nfloat twistedBoxBlob(vec3 position)\n{\n    float twistedBox = boxTwistDist(position - vec3(-5.0, 0.0, 10.0), vec3(1.0, 1.0, 5.0));\n    float sphere1 = sphereDist(position, vec3(-5.0, -5.0, 10.0), 1.5);\n    float sphere2 = sphereDist(position, vec3(-5.0, 5.0, 10.0), 1.5);\n    return max(max(twistedBox, -sphere1), -sphere2);\n}\n\nvec2 matMin(vec2 left, vec2 right)\n{\n    return left.x > right.x ? right : left;\n}\n\n// Distance field.\n// Takes a 3D position and gives the distance value in the field.\nvec2 map(vec3 position)\n{\n    position.z -= 10.0;\n    position = (rotation * vec4(position, 0.0)).xyz;\n    position.z += 10.0;  \n    return matMin(vec2(twistedBoxBlob(position), 1.0), vec2(mapBlob(position), 2.0));\n}\n\nfloat mapf(vec3 position)\n{\n    return map(position).x;\n}\n\n// Ray marching.\n// Given a start point and a direction. Sample the distance field until collision with an object.\n// Return this 3D collision point.\nvec4 rayMarch(vec3 start, vec3 direction)\n{\n    float rayPrecision = 0.008;\n    float rayLength = 0.0;\n    vec3 intersection = vec3(0.0);\n    float material = 0.0;\n    for (float i = 0.0; i < MAX_ITERATIONS; i++)\n    {\n        vec3 intersection = start + (direction * rayLength);\n        vec2 ret = map(intersection);\n        // ret.x -> Distance. ret.y -> material\n        if (abs(ret.x) < rayPrecision)\n            return vec4(intersection, ret.y);\n        if (ret.x > MAX_RAY_DISTANCE)\n            return vec4(0.0);\n        rayLength += ret.x * .85;\n        material = ret.y;\n    }\n    return vec4(intersection, material);\n}\n\n\n// Calculate normal of a point.\n// Samples the distance field to find the direction at which the distance increases in 3D space.\nvec3 calcNormal(vec3 point)\n{\n    vec3 delta = vec3(0.001, 0.001, 0.001);\n    float x0 = mapf(point);\n    float xn = mapf(vec3(point.x + delta.x, point.yz)) - x0;//mapf(vec3(point.x - delta.x, point.yz));\n    float yn = mapf(vec3(point.x, point.y + delta.y, point.z)) - x0;//mapf(vec3(point.x, point.y - delta.y, point.z));   \n    float zn = mapf(vec3(point.xy, point.z + delta.z)) - x0;//mapf(vec3(point.xy, point.z - delta.z));\n    return normalize(vec3(xn, yn, zn));\n}\n\n// Simple shading function\nvec4 shade(vec4 intersection)\n{\n    vec3 point = intersection.xyz;\n    vec3 normal = calcNormal(point);\n    vec3 lightDir = normalize(lightPosition - point);\n    \n    float lambertian = max(dot(lightDir, normal), 0.0);\n    float specular = 0.0;\n    \n    if (lambertian > 0.0)\n    {\n        vec3 viewDir = normalize(-point);\n        \n        vec3 halfDir = normalize(lightDir + viewDir);\n        float specAngle = max(dot(halfDir, normal), 0.0);\n        specular = pow(specAngle, shininess);\n    }\n    \n    vec3 diffuse = vec3(0.0);\n    if (intersection.a == 2.0)\n    {\n        diffuse = diffuseColor;\n    } else if (intersection.a == 1.0)\n    {\n        diffuse = vec3(0.02, 0.05, 0.09);\n    }\n    \n    vec3 colorLinear = ambientColor;\n    colorLinear += specular * specularColor;\n    colorLinear += lambertian * diffuse;\n      \n    return vec4(colorLinear, 1.0);\n}\n                     \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    lightPosition = vec3(5.0 * sin(iTime/2.0), 1.0 * sin(iTime*4.0), 5.0 * cos(iTime/2.0));\n    rotation = rotationMatrix(vec3(0.0, 1.0, 0.0), iTime / 5.0 + (iMouse.x / iResolution.x) * 6.3);\n    \n    float screenZ = 1.0;\n    vec2 screenUV = fragCoord.xy / iResolution.xy;\n    screenUV.x *= iResolution.x/iResolution.y;\n    \n    vec3 eye = vec3(1.0, 0.5, 0.0);\n\tvec3 pixelLoc = vec3(screenUV, screenZ);\n    \n    vec3 ray = normalize(pixelLoc - eye);\n    vec4 intersection = rayMarch(pixelLoc, ray);\n    \n    fragColor = vec4(ambientColor, 1.0);\n    if (intersection.xyz != vec3(0.0)) {\n    \t//float depth = (intersection.z-3.0)/5.0;\n    \t//fragColor = vec4(depth, depth, 0.0, 1.0);\n        //fragColor = vec4(calcNormal(intersection.xyz), 1.0);\n        \n        fragColor = shade(intersection);\n    }\n    fragColor = vec4(pow(fragColor.xyz, vec3(1.0 / screenGamma)), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}