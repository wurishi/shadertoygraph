{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define TAU 6.28318530717958647693\n#define E   2.71828182845904523536\n#define PHI 1.618033988749894\n\nvec2 iexp(float i) {\n    return vec2(cos(i), sin(i));\n}\n\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nint hash(int seed) {\n    // Thomas Wang hash\n    // http://www.burtleburtle.net/bob/hash/integer.html\n    seed = (seed ^ 61) ^ (seed >> 16);\n    seed *= 9;\n    seed = seed ^ (seed >> 4);\n    seed *= 0x27d4eb2d;\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nint hash(ivec2 seed) {\n    return hash(hash(seed.x) + seed.y);\n}\n\nint hash(ivec3 seed) {\n    return hash(hash(seed.xy) + seed.z);\n}\n\nfloat hash(float seed) {\n    int hash = hash(floatBitsToInt(seed));\n    return intBitsToFloat(0x3f800000 | (0x007fffff & hash)) - 1.0; \n}\n\nvec2 hash(vec2 seed) {\n    return vec2(hash(seed.x), hash(seed.y));\n}\n\nvec3 hash(vec3 seed) {\n    return vec3(hash(seed.x), hash(seed.y), hash(seed.z));\n}\n\n// random 32-bit integer\nint rand(inout int seed) {\n    // Xorshift algorithm from George Marsaglia's paper.\n    seed ^= (seed << 13);\n    seed ^= (seed >> 17);\n    seed ^= (seed << 5);\n    return seed;\n}\n\n// random float in the range [0.0f, 1.0f)\nfloat frand(inout int seed) {\n    return intBitsToFloat(0x3f800000 | (0x007fffff & rand(seed))) - 1.0;\n}\nvec2 frand2(inout int seed) {\n    return vec2(frand(seed), frand(seed));\n}\nvec3 frand3(inout int seed) {\n    return vec3(frand(seed), frand(seed), frand(seed));\n}\n\nfloat noise(in vec2 p) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd);\n}\n\nfloat noise(in vec2 p, in int octaves) {\n    vec2 scale = 2.0 * iexp(TAU*PHI);\n\n    float v = 0.0;\n    float d = 0.0;\n    float s = 1.0;\n    for (int i = 0; i < octaves; i++) {\n        v += s*noise(p);\n        d += s;\n\n        p = cmul(scale, p);\n        s /= 4.0;\n    }\n    return v / d;\n}\n\n/*\nvec3 palette(float x, float t) {\n    x *= 0.5;\n    \n    vec2 phase = 0.5-0.5*(iexp(2.0*t));\n    phase.x *= 1.0;\n    phase *= 0.33;\n\n    vec3 a = vec3(0.5, 0.6, 0.2);\n    vec3 b = vec3(0.4, 0.3, 0.8);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    \n    return  \n} */\n\nvec3 spinnies(vec2 uv, float t) {\n     float r =  length(uv);\n     uv = cmul(iexp(0.3*TAU*r), uv);\n     uv *= noise(1.*uv, 8) + 0.1*vec2(sin(t+r), cos(t+r));\n\n    r = length(uv);\n\n    return vec3(uv, sin(6.*r));\n    // return vec3(sin(iTime*r));\n}\n\nvec3 ripples(vec2 uv, float t) {\n    vec3 col = vec3(0);\n    \n    uv = cmul(uv, iexp(.5*t + 0.1*length(uv)));\n\n    col += spinnies(uv, 0.2*t);\n    uv += 0.5*cos(0.3*t)*iexp(0.6*t);\n    \n    uv += 2.5*cos(0.4*t)*iexp(1.2*t);\n    col += spinnies(0.5*uv, 0.5*t);\n    \n    uv += 1.5*sin(0.6*t)*iexp(0.4*t);\n    col += spinnies(0.2*uv, 0.3*t);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 1.0 - 2.0*fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n\n    uv *= 0.66;\n\n    float t = 0.05*iTime*TAU;\n    \n    vec3 col = ripples(uv, t);\n   \n    float q = length(col);\n    vec2 d = vec2(dFdx(q), dFdy(q)) / fwidth(q);\n\n    // second iteration\n    uv += 0.5*normalize(d) / (2.0*q);\n    col = ripples(uv, t);\n    q = length(col);\n    d = vec2(dFdx(q), dFdy(q)) / fwidth(q);\n    \n    \n    mat3 cmap = mat3(0.0);\n    cmap[0] = vec3(0.843,0.337,0.733);\n    cmap[1] = vec3(0.875,0.745,0.165);\n    cmap[2] = vec3(0.102,0.267,0.302),\n\n    col = cmap * (vec3(d, q));\n\n    // Output to screen\n    fragColor = vec4(col,1.0); \n}\n   ","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MfGfzt","date":"1735183506","viewed":35,"name":"goooop womb","username":"spac","description":"goopy","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["interference","goop"],"hasliked":0,"parentid":"","parentname":""}}