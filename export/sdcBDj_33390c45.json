{"ver":"0.1","info":{"id":"sdcBDj","date":"1657194866","viewed":117,"name":"4D Raymarching2","username":"Proger","description":"-_-","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.1415926535;\nvec3 colorO = vec3(1);\nfloat wi = 0.0;\n\nfloat sdCylinder(in vec4 p,in vec2 h ) {\n  return max(length(p.xzw)-h.x, abs(p.y)-h.y );\n}\n\nfloat smin(float a, float b, float k)\n{\n   return log2(exp2(k * a) + exp2(k * b)) / k;\n}\n\nmat2 mrot(float a){\n  float c = cos(a);\n  float s = sin(a);\n  return mat2(c,-s,s,c);\n}\nfloat sdDuoCylinder( vec4 p, vec2 r1r2) {\n  vec2 d = abs(vec2(length(p.xz),length(p.yw))) - r1r2;\n  return min(max(d.x,d.y),0.) + length(max(d,0.));\n}\n\n\nfloat sdBox( vec4 p, vec4 b )\n{\n  vec4 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,max(q.z, q.w))),0.0);\n}\n\nfloat getDist(vec3 c){\n  vec4 p = vec4(c.xyz, wi);\n  vec4 t = p;\n  t.xw *= mrot(iTime);\n  t.zw *= mrot(iTime);\n  t.yw *= mrot(iTime);\n  float sdB = sdBox(t, vec4(1));\n  float plane = c.y + 2.;\n  float sp = length(p-vec4(3,0,0,0))-1.;\n  float sdT = sdDuoCylinder(p-vec4(-3,0,0,0), vec2(1, 1));  \n  float minim = min(min(sdB, min(plane,  sp)), sdT);\n  if(minim == sdB) colorO = vec3(1,0.5,0.5);\n  if(minim == sp) colorO = vec3(1.,1.,0.5);\n  if(minim == plane) colorO = vec3(0.3,0.3,0.3);\n  if(minim == sdT) colorO = vec3(0.5,0.5,1);\n  return minim;\n}\nvec3 getNormal(vec3 p){\n  vec2 e = vec2(0.001,0);\n  float d = getDist(p);\n  vec3 n = vec3(\n    d - getDist(p-e.xyy),\n    d - getDist(p-e.yxy),\n    d - getDist(p-e.yyx)\n  );\n  return normalize(n);\n}\nvec3 RayMarch(vec3 ro, vec3 rd){\n  float dO = 0.0;\n  for(int i = 0; i < 300; i++){\n    vec3 p = ro + rd*dO;\n    float ds = getDist(p);\n    dO += ds;\n    if(dO > 200.) break;\n    if(ds < 0.001) return p;\n  }\n  return vec3(0);\n}\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = getDist( ro + rd*t );\n\n        // traditional technique\n        if( technique==0 )\n        {\n        \tres = min( res, 10.0*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        }\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  wi = sin(iTime / 3.);\n  float m = min(iResolution.y,iResolution.x);\n  vec2 uv = ((fragCoord.xy-.5*iResolution.xy) / m);\n  vec3 color = vec3(1,5,-6);\n  vec3 light = vec3(3.,5,-1.);\n  vec3 rd = normalize(vec3(uv.xy, 1));\n  vec3 ro = vec3(0,0,-10);\n  ro.yz *= mrot(-iMouse.y/iResolution.y*PI*3.-PI*1.5);\n  ro.xz *= mrot(-iMouse.x/iResolution.x*PI*3.-PI*1.5);\n  rd.yz *= mrot(-iMouse.y/iResolution.y*PI*3.-PI*1.5);\n  rd.xz *= mrot(-iMouse.x/iResolution.x*PI*3.-PI*1.5);\n  vec3 d = RayMarch(ro,rd);\n  color = colorO;\n  float sp = pow(max(dot(reflect(-normalize(light - d), getNormal(d)), -rd), 0.1), 19.)/5.;\n  float df = max( (dot(getNormal(d), normalize(light))) * calcSoftshadow(d, normalize(light), 0.001, 5.0, 1 ), 0.1);\n  color *= vec3(sp + df);\n  //color = abs(getNormal(d));\n  color = pow(color, vec3(0.4545));\n  if(d == vec3(0))color = vec3(0.9,0.9,1)*min(max(dot(rd, vec3(0,1,0)),0.1), 1.) + pow(max(dot(rd, normalize(light)),0.),19.)/4.;\n  fragColor = vec4(color,1.);\n}","name":"Image","description":"","type":"image"}]}