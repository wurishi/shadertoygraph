{"ver":"0.1","info":{"id":"ltVXW1","date":"1484231798","viewed":128,"name":"2d Captain future F","username":"gigatron","description":"No one around the galaxy now can explain vectors  for me :))\nquick captain future 'F' vector ...the french version of soundtrack is better than german :)","likes":2,"published":1,"flags":64,"usePreview":0,"tags":["2d","line","vector"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"lsjGDG","filepath":"https://soundcloud.com/rickgoldman2/capitaine","previewfilepath":"https://soundcloud.com/rickgoldman2/capitaine","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define t mod(iTime,3.0)\n#define t2 iTime\n\n#define lf 24.0 // bold fct\n\nvec4 l( in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h )/1.3;\n          \n    vec4 c = vec4(0.9,0.95,0.9,1.0);\n    \n    \n    return smoothstep(lf/iResolution.y, 0., d ) * c *\n           smoothstep((lf/iResolution.y)*sin(t2*4.), 0.0, d )*\n           texture(iChannel1,p/2.).zxyw*2.;\n}\n \n\nmat4 setRotation( float x, float y, float z )\n{\n    float a = sin(x); float b = cos(x); \n    float c = sin(y); float d = cos(y); \n    float e = sin(z); float f = cos(z); \n\n    float ac = a*c;\n    float bc = b*c;\n\n    return mat4( d*f,      d*e,       -c, 0.0,\n                 ac*f-b*e, ac*e+b*f, a*d, 0.0,\n                 bc*f+a*e, bc*e-a*f, b*d, 0.0,\n                 0.0,      0.0,      0.0, 1.0 );\n}\n\nmat4 RotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 setTranslation( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,     y,   z, 1.0 );\n}\n\nstruct Triangle\n{\n    vec3 a; vec2 aUV;\n    vec3 b; vec2 bUV;\n    vec3 c; vec2 cUV;\n    vec3 n;\n};\n\n\nTriangle triangles[4];\n\nvoid createCube( void )\n{\n    vec3 verts[8];\n\n    verts[0] = vec3( -1.0, -1.0, -0.0 );\n    verts[1] = vec3( -1.0, -1.0,  0.0 );\n    verts[2] = vec3( -1.0,  1.0, -0.0 );\n    verts[3] = vec3( -1.0,  1.0,  0.0 );\n    verts[4] = vec3(  1.0, -1.0, -0.0 );\n    verts[5] = vec3(  1.0, -1.0,  0.0 );\n    verts[6] = vec3(  1.0,  1.0, -0.0 );\n    verts[7] = vec3(  1.0,  1.0,  0.0 );\n\n    triangles[0].a = verts[1]; triangles[0].aUV = vec2(0.0,0.0);\n    triangles[0].b = verts[5]; triangles[0].bUV = vec2(1.0,0.0);\n    triangles[0].c = verts[7]; triangles[0].cUV = vec2(1.0,1.0);\n    triangles[0].n = vec3( 0.0, 0.0, 0.0 );\n    triangles[1].a = verts[1]; triangles[1].aUV = vec2(0.0,0.0),\n    triangles[1].b = verts[7]; triangles[1].bUV = vec2(1.0,1.0),\n    triangles[1].c = verts[3]; triangles[1].cUV = vec2(0.0,1.0),\n    triangles[1].n = vec3( 0.0, 0.0, 0.0 );\n\n    triangles[2].a = verts[5]; triangles[2].aUV = vec2(0.0,0.0);\n    triangles[2].b = verts[4]; triangles[2].bUV = vec2(1.0,0.0);\n    triangles[2].c = verts[6]; triangles[2].cUV = vec2(1.0,1.0);\n    triangles[2].n = vec3( 0.0, 0.0, 0.0 );\n    triangles[3].a = verts[5]; triangles[3].aUV = vec2(0.0,0.0);\n    triangles[3].b = verts[6]; triangles[3].bUV = vec2(1.0,1.0);\n    triangles[3].c = verts[7]; triangles[3].cUV = vec2(0.0,1.0);\n    triangles[3].n = vec3( 0.0, 0.0, 0.0 );\n\n     \n}\n\nfloat crosss( vec2 a, vec2 b )\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nvec3 pixelShader( in vec3 nor, in vec2 p, in float z, in vec3 wnor )\n{\n    vec4 cl = vec4(0);\n    //p *= 2.0;\n   // p.y = p.y-0.5;\n    // set vector points over own texture ;\n \n  // 6 faces \n    \n    cl += l(p,vec2(-0.44,0.74),vec2(1.58,0.74));\n    cl += l(p,vec2(-0.38,0.66),vec2(1.52,0.66));\n    cl += l(p,vec2(1.58,0.74),vec2(2.28,0.10));\n    cl += l(p,vec2(1.52,0.66),vec2(2.14,0.10));\n    cl += l(p,vec2(2.28,0.10),vec2(1.58,-0.53));\n    cl += l(p,vec2(2.14,0.10),vec2(1.50,-0.46));\n    cl += l(p,vec2(1.58,-.53),vec2(-.55,-0.53));\n    cl += l(p,vec2(1.50,-.46),vec2(-0.48,-0.46));\n    cl += l(p,vec2(-0.55,-.53),vec2(-1.26,0.13));\n    cl += l(p,vec2(-0.48,-.46),vec2(-1.12,0.12));\n    cl += l(p,vec2(-1.26,.13),vec2(-0.44,0.74));\n    cl += l(p,vec2(-1.12,.12),vec2(-.38,0.66));\n // F of Future ..   \n      cl += l(p,vec2(-.35,.59),vec2(1.48,.59));\n    \n       cl += l(p,vec2(1.48,.59),vec2(1.29,.18));\n    \n       cl += l(p,vec2(1.29,.18),vec2(1.27,.30));\n    \n       cl += l(p,vec2(1.27,.30),vec2(1.25,.36));\n       cl += l(p,vec2(1.25,.36),vec2(1.19,.41));\n       \n       cl += l(p,vec2(1.19,.41),vec2(0.34,.41));\n       cl += l(p,vec2(0.34,.41),vec2(0.23,.19));\n       cl += l(p,vec2(0.23,.19),vec2(0.78,.19));\n       cl += l(p,vec2(0.78,.19),vec2(0.88,.22));\n       cl += l(p,vec2(0.88,.22),vec2(1.01,.29));\n    \n       cl += l(p,vec2(1.01,.29),vec2(0.87,.00));\n       cl += l(p,vec2(0.87,.00),vec2(0.80,.10));\n    \n       cl += l(p,vec2(0.80,.10),vec2(0.19,.10));\n    \n       cl += l(p,vec2(0.19,.10),vec2(0.07,-.16));\n       cl += l(p,vec2(0.07,-.16),vec2(0.42,-.16));\n     \n       cl += l(p,vec2(0.42,-.16),vec2(0.34,-.36));\n       cl += l(p,vec2(0.34,-.36),vec2(-0.51,-.36));\n    \n       cl += l(p,vec2(-.51,-.36),vec2(-0.39,-.28));\n       cl += l(p,vec2(-.39,-.28),vec2(-0.36,-.24));   \n       cl += l(p,vec2(-.36,-.24),vec2(-0.05,0.40)); \n       cl += l(p,vec2(-.05,.40),vec2(-0.46,0.40));  \n       cl += l(p,vec2(-.46,.40),vec2(-0.35,0.59)); \n    \n    return vec3(cl.xyz);\n}\n    \n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n        \nmat4 mdv = setTranslation( 0.0, 0.8, -6.0) * \n\t\t       setRotation( 0.,0. , 0. )*   setRotation( t*0.0,t2*2. , 0. )*\n               RotationAxisAngle(vec3(0.0,0.0,0.0), 0.0 );\n \n    vec2 px = ( 2.*fragCoord - iResolution.xy ) / iResolution.y;\n       \n     vec2 uv = fragCoord / iResolution.xy;\n    \n     vec3 tx=texture(iChannel0,uv).xyz;\n    \n    createCube();\n\t \n    float scl = mod(fragCoord.y ,2.0);\n    \n    vec3 color = vec3( 0.0, 0.0, 0.0 );\n\n    // clear zbuffer\n    float mindist = -1000000.0;\n\n    \n        // transform to eye space\n        vec3 ep0 = (mdv * vec4(triangles[1].a,1.0)).xyz;\n        vec3 ep1 = (mdv * vec4(triangles[1].b,1.0)).xyz;\n        vec3 ep2 = (mdv * vec4(triangles[1].c,1.0)).xyz;\n        vec3 nor = (mdv * vec4(triangles[1].n,0.0)).xyz;\n\n        // transform to clip space\n        float w0 = 1.0/ep0.z;\n        float w1 = 1.0/ep1.z;\n        float w2 = 1.0/ep2.z;\n\n        vec2 cp0 = 2.0*ep0.xy * -w0;\n        vec2 cp1 = 2.0*ep1.xy * -w1;\n        vec2 cp2 = 2.0*ep2.xy * -w2;\n\n        // fetch vertex attributes, and divide by z\n        vec2 u0 = triangles[1].aUV * w0;\n        vec2 u1 = triangles[1].bUV * w1;\n        vec2 u2 = triangles[1].cUV * w2;\n\n        // calculate areas for subtriangles\n        vec3 di = vec3( crosss( cp1 - cp0, px - cp0 ), \n\t\t\t\t\t    crosss( cp2 - cp1, px - cp1 ), \n\t\t\t\t\t    crosss( cp0 - cp2, px - cp2 ) );\n\t\t\n        // if all positive, point is inside triangle\n        if( all(greaterThan(di,vec3(-15.0))) )\n        {\n            // calc barycentric coordinates\n            vec3 ba = di.yzx / (di.x+di.y+di.z);\n\n            // barycentric interpolation of attributes and 1/z\n            float iz = ba.x*w0 + ba.y*w1 + ba.z*w2;\n            vec2  uv = ba.x*u0 + ba.y*u1 + ba.z*u2;\n\n            // recover interpolated attributes\n            float z = 1.0/iz;\n             uv *= z;\n \n\n\t\t\t\t// perform lighting/shading\n\t\t\t\tcolor = pixelShader( nor, uv, z, triangles[1].n );\n\t  \n    }\n\n    fragColor = vec4(mix(vec3(color*tx)*2.,vec3(0.4,0.4,tx.r)*1.2,0.2),1.0);\n     \n}","name":"Image","description":"","type":"image"}]}