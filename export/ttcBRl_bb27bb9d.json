{"ver":"0.1","info":{"id":"ttcBRl","date":"1613237798","viewed":171,"name":"Adaptive Quality delta^2","username":"spalmer","description":"Fixed framerate by adjusting amount of work per frame, using a simple delta squared controller, so that it tends to run at 30fps no matter hardware or window size.\nTo prevent slowing down thumbnail shader list, must click the mouse in the window to begin.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["fps","controller","pid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fork of my PID attempt https://shadertoy.com/view/ttcBRl\n// fork of FabriceNeyret2's https://shadertoy.com/view/Wl3BR2\n\n// decided PID wasn't working, did a simpler delta squared\n// controller instead, replaced lowpass filter\n\n// draw number from https://shadertoy.com/view/llySRh\n\n// Font texture cell size in pixels\n#define F 16.\n\nvec4 char(vec2 p, int c)\n{\n    vec2 u = dFdx(p/F), v = dFdy(p/F); // derivatives outside dynamic control flow\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.)\n        return vec4(0,0,0,1e5);\n\treturn textureGrad(iChannel3, p/F + fract(vec2(c, 15-c/16) / F), u, v);\n}\n\nfloat pInt(vec2 p, int n)\n{\n    float v = 0.;\n    if (n < 0) \n        v += char(p - vec2(-.5,0), 45).x,\n        n = -n;\n    for (int i = 4; i-- > 0; ) \n        v += char(p - .5*vec2(i,0), 48 + n % 10).x\n        , n /= 10;\n    return v;\n}\n\nvoid mainImage(out vec4 O, vec2 U)\n{ \n    vec4 d = T(0); // data pixel\n    O = T(U);\n    U = (U/R.y - vec2(.05,.0)) * 20.; \n    int n = int(d.w); // display iteration count\n    O -= pInt(U, n / 10000); U.x -= 2.1;\n    O -= pInt(U, n % 10000);\n    // display smooth fps\n    n = int(round(d.z)); U.y -= 2.; U.x += 2.1; \n    O -= pInt(U, n);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R     iResolution.xy\n#define T(U)  texelFetch(iChannel0, ivec2(U), 0)","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 O, vec2 U)\n{\n    vec4 N = T(0);\n    float targetfps = 30.\n    , limitfps = 60. // graph range\n    , t = iTimeDelta\n    , fps = 1./t\n    , y = U.y/R.y\n    , n = N.w;\n    if (all(lessThan(U,vec2(1)))) {\n        // frame-rate independent low-pass filter deltatime, store inverted as fps\n        float smoothfps = 1./mix(t, 1./N.z, exp2(-2. * t));\n        // PID controller\n        float err = 1./targetfps - 1./smoothfps\n        , err2 = err * abs(err)\n        , prevErr = N.y\n        , derivative = (prevErr - err) / t // also measured backward so will tend to cancel out progress\n        , Kp2 = 4e8 * inversesqrt(R.x*R.y); // slower in higher resolutions\n        n += Kp2 * err2;\n        O = vec4(0., err, smoothfps, n);\n        O.w = clamp(O.w, 0., 1e6);               // safeguard\n        if (abs(iTimeDelta - 1./60.) < 1e-2\n            && all(lessThan(iMouse.xy, vec2(1)))) \n            O.w = 0.; // thumbnails don't get real iTimeDelta\n        if (iFrame < 1) O = vec4(0, 0, targetfps, 1e3);     // init\n        return;\n    }\n    \n    O = U.x > 1.\n          ? T(U - vec2(1,0))                // scroll\n          : vec4(y < fps/limitfps);         // instant fps\n    float expensive = fract(iTime);\n    for (float i=0.; i < n; ++i)\n        expensive = cos(expensive); // costly adaptive computation\n    if (U.x < 1. && abs(y - targetfps/limitfps) < 1./R.y) \n        O = vec4(0,.7,0,0);    \n    O.b += 1e-7 * expensive; // prevent optimizer from cancelling loop            \n}","name":"Buffer A","description":"","type":"buffer"}]}