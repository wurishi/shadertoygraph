{"ver":"0.1","info":{"id":"XtB3DK","date":"1432288338","viewed":270,"name":"Circle Interference","username":"104","description":"classic demoscene effect using simple trig & multiplication","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["classic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// UTILITIES --------------------------------------------------------\nconst float pi2 = 3.14159 * 2.;\n\nvec2 getuv_centerX(vec2 fragCoord, vec2 newTL, vec2 newSize)\n{\n    vec2 ret = vec2(fragCoord.x / iResolution.x, (iResolution.y - fragCoord.y) / iResolution.y);// ret is now 0-1 in both dimensions\n    ret *= newSize;// scale up to new dimensions\n    float aspect = iResolution.x / iResolution.y;\n    ret.x *= aspect;// orig aspect ratio\n    float newWidth = newSize.x * aspect;\n    return ret + vec2(newTL.x - (newWidth - newSize.x) / 2.0, newTL.y);\n}\n\nvec4 mixColors(vec4 inp, vec4 other, float a)\n{\n    return vec4(mix(inp.rgb, other.rgb, other.a * a), inp.a);\n}\n\nfloat nsin(float a)// 0-1 sin\n{\n    return (sin(a)+1.)/2.;\n}\nfloat saturate(float a)\n{\n    return clamp(a,0.,1.);\n}\n\n// convert distance to alpha value\nfloat dtoa(float d, float amt)\n{\n    return clamp(1.0 / (clamp(d, 1.0/amt, 1.0)*amt), 0.,1.);\n}\n\n//--------------------------------------------------------\n// this function returns the \"distance\" to the interference pattern.\nfloat xorCircles_d(vec2 uv, vec2 p1, float p1period, vec2 p2, float p2period)\n{\n    float d1 = sin(distance(uv, p1) / p1period * pi2);\n    float d2 = sin(distance(uv, p2) / p2period * pi2);\n    return d1 * d2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // adjust global speed, and start at a nice offset to make the thumbnail look nice :P\n    float time = (iTime + 47.) * 0.8;\n    \n\tvec2 uv = getuv_centerX(fragCoord, vec2(-1.), vec2(2.));\n    fragColor = vec4(0.89,0.97,0.99,1.);// background\n    \n    // define positions & periods of the circles\n    vec2 p1 = vec2(sin(time * 1.7), sin(time * 0.55));\n    float p1period = (nsin(time * 1.8) / 3.) + 0.3;\n    \n    vec2 p2 = vec2(sin(time * .77), sin(time * 1.64));\n    float p2period = (nsin(time * 4.1) / 4.) + 0.3;\n\n    // distance to pattern\n    float d = xorCircles_d(uv, p1, p1period, p2, p2period);\n    \n    // generate a cool fill pattern by using the distance more\n    float fillA = nsin(d * d * 15.);\n    vec4 patternColor = vec4(.99,.7,.22,1.);\n    patternColor = mix(patternColor, vec4(.2,.7,.9,1.), saturate(d * d) * fillA);\n    \n    fragColor = mixColors(fragColor, patternColor, dtoa(d, 20.));\n    \n    // add a little vignette\n\tfragColor.rgb *= saturate(1.3 / length(uv));\n\n}\n\n","name":"","description":"","type":"image"}]}