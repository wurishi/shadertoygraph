{"ver":"0.1","info":{"id":"WsSXzz","date":"1552642227","viewed":595,"name":"Voronoi Comparison","username":"dr2","description":"Compare 1-pass (red - mine) and 2-pass (green - Shane) rounded hexagonal Voronoi \nmethods. For complete edge-distance contours two passes are needed, with  double the \nwork; one pass is enough for the outer contours.\n","likes":11,"published":3,"flags":0,"usePreview":0,"tags":["voronoi","hexagon","contour"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Voronoi Comparison\" by dr2 - 2019\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvoid HexVorInit ();\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nvec2 Hashv2v2 (vec2 p);\n\nvec2 gVec[7], hVec[7];\nfloat tCur;\nconst float pi = 3.14159, sqrt3 = 1.7320508;\n\nvec2 PRand (vec2 p)\n{\n  vec2 u;\n  u = Hashv2v2 (p);\n  return 0.3 * (0.4 + 0.6 * u.x) * sin ((u.y - 0.5) * pi * tCur + vec2 (0.5 * pi, 0.));\n}\n\nfloat HexVor1 (vec2 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    d = hVec[k] + PRand (ip + gVec[k]) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return SmoothMin (sd.y, sd.z, 0.2) - sd.x;\n}\n\nfloat HexVor2 (vec2 p)\n{\n  vec2 ip, ipMin, fp, hm, pMin, hr, sp;\n  float dd, ddm, d, sd1, sd2;\n  ip = PixToHex (p);\n  sp = HexToPix (ip) - p;\n  ddm = 4.;\n  for (int i = 0; i < 7; i ++) {\n    fp = sp + hVec[i] + PRand (ip + gVec[i]);\n    dd = dot (fp, fp);\n    if (dd < ddm) {\n      ddm = dd;\n      ipMin = ip + gVec[i];\n    }\n  }\n  pMin = HexToPix (ipMin);\n  hm = pMin + PRand (ipMin);\n  sd1 = 4.;\n  sd2 = 4.;\n  for (int j = 0; j < 7; j ++) {\n    hr = pMin + hVec[j] + PRand (ipMin + gVec[j]);\n    fp = hr - hm;\n    if (dot (fp, fp) > 0.) {\n      d = dot (0.5 * (hr + hm) - p, normalize (fp));\n      sd1 = min (sd1, d);\n      sd2 = SmoothMin (sd2, d, 0.1);\n    }\n  }\n  return mix (sd1, sd2, 0.9);\n}\n\nvec3 ShowScene (vec2 p)\n{\n  vec3 col;\n  float s;\n  col = vec3 (0.1, 0.1, 0.6);\n  s = HexVor1 (p - 10. * sin (0.03 * tCur + vec2 (0.5 * pi, 0.)));\n  col = mix (col, vec3 (1., 0., 0.), smoothstep (0.02, 0.05, s) *\n     SmoothBump (0.35, 0.65, 0.02, mod (8. * s, 1.)));\n  s = HexVor2 (p - 10. * sin (0.03 * tCur + vec2 (0.5 * pi, 0.)));\n  col = mix (col, vec3 (0., 1., 0.), smoothstep (0.02, 0.05, s) *\n     SmoothBump (0.4, 0.6, 0.02, mod (8. * s, 1.)));\n  return col;\n}\n\n#define AA  1\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec3 col;\n  vec2 canvas, uv;\n  float pSize, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  tCur += 20.;\n  pSize = canvas.x / 300.;\n  HexVorInit ();\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) \n     col += (1. / naa) * ShowScene (pSize * (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi)));\n  fragColor = vec4 (clamp (col, 0., 1.), 1.);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n","name":"Image","description":"","type":"image"}]}