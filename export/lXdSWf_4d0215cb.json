{"ver":"0.1","info":{"id":"lXdSWf","date":"1719717727","viewed":93,"name":"False cube illusion v 1.0.0","username":"DualVission","description":"Creates the false sensation that the source is on the surface of a cube. Similar to an effect I used when I streamed. Likely will use this set up instead of what I was doing before.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["cube","blur","illusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Inputs\n      // Percentage of viewport area scale\nfloat scale     = 0.65;  // (should be less than    1.)\n      // Percentage of right buffer edge\nfloat width     = 2.0;   // (should be greater than 1.)\n      // Percentage of bottom buffer edge\nfloat height    = 1.4;   // (should be greater than 1.)\n      // Absolute size increase of bottom buffer edge to the left of viewport\nfloat xStretch  = 0.05;  // (should be greater than 0.)\n      // Absolute size increase of right buffer edge to the top of viewport\nfloat yStretch  = 0.3;   // (should be greater than 0.)\n      // Power to which darkening effect is taken\nfloat fxDark    = 1.;    // (should be greater than 0., lower values will lighten the effect)\n      // Absolute color offset of darkening effect on right buffer edge\nfloat fxOffsetX = -0.05; // (can be any number, negative numbers darken the effect)\n      // Absolute color offset of darkening effect on right buffer edge\nfloat fxOffsetY = -0.1;  // (can be any number, negative numbers darken the effect)\n      // Power to which bluring effect is taken\nfloat blurFall  = .8;    // (should be greater than 0., smaller numbers increase the blur)\n\n\n// Functions\nfloat getBoundary( in vec2 inputMap )\n{\n    return step(inputMap.x, 1.) * step(0., inputMap.x) * step(inputMap.y, 1.) * step(0., inputMap.y);\n}\n\n// Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Calc variables\n    float squScale = pow(scale, 0.5);\n    float bufferScale = 1. - squScale;\n    vec2 uv = fragCoord/iResolution.xy;\n    float slope = (squScale + bufferScale * height + yStretch) / (squScale + bufferScale * width + xStretch);\n    vec2 cosSlope = vec2(\n                          pow(smoothstep(0.,1.,abs(atan(      slope))) + fxOffsetX, fxDark),\n                          pow(smoothstep(0.,1.,abs(atan(-1. / slope))) + fxOffsetY, fxDark)\n                        );\n    \n    // Primary Map\n    vec2 mapPrimary = uv / vec2(squScale) + vec2(0., 1. - 1. / squScale);\n    float boundaryPrimary = getBoundary(mapPrimary);\n    \n    // Right Map\n    vec2 mapRight;\n    mapRight.x = (1. + bufferScale - uv.x) / (bufferScale * width);\n    mapRight.y = (uv.y + bufferScale * height * (1. - mapRight.x) - bufferScale) / (squScale + (bufferScale * height + yStretch) * (1. - mapRight.x));\n    float boundaryRight = getBoundary(mapRight);\n    \n    // Bottom Map\n    vec2 mapBottom;\n    mapBottom.y = (1. - squScale - uv.y) / (bufferScale * height);\n    mapBottom.x = (uv.x + xStretch * mapBottom.y) / (squScale + (bufferScale * width + xStretch) * mapBottom.y);\n    float boundaryBottom = getBoundary(mapBottom);\n\n    // Output to screen\n    fragColor = mix(texture(iChannel0, mapBottom), texture(iChannel1, mapBottom), pow(texture(iChannel2, vec2(mapBottom.x, 1. - mapBottom.y)).r, blurFall / width ))   * vec4(boundaryBottom) * vec4(vec3(cosSlope.y), 1.)\n              + mix(texture(iChannel0, mapRight),  texture(iChannel1, mapRight),  pow(texture(iChannel2,                        mapRight.yx).r,  blurFall / height))   * vec4(boundaryRight)  * vec4(vec3(cosSlope.x), 1.)\n              + texture(iChannel0, mapPrimary)                                                                                                                         * vec4(boundaryPrimary);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * vec2(1.,-1.) + vec2(0.,1.);\n    fragColor = texture(iChannel0, uv);\n    // there is a glitch in Shadertoy where the unflipped mip is flipped\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float radius = 50.;\nint fragCount = 16;\n\n\n\n// Functions\nfloat getBoundary( in vec2 inputMap )\n{\n    return step(inputMap.x, 1.) * step(0., inputMap.x) * step(inputMap.y, 1.) * step(0., inputMap.y);\n}\n\n// Main\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 blur = vec2(radius/200.) * vec2(iResolution.x/iResolution.y, 1.);\n    float floatFrag = float(fragCount);\n    float sumFrag = 1.27323954474 * 2. * floatFrag; // area under int_-1to1{cos(pi*x / 2)}\n    \n    vec4 sum = vec4(0.);\n    vec2 offsetUV;\n    \n    for(float i = -1. * floatFrag;i<floatFrag;i++)\n    {\n        offsetUV = uv + vec2(blur.x/floatFrag * i, 0.);\n        sum += texture(iChannel0, offsetUV) * vec4(vec3(cos(3.1415926 * i / floatFrag / 2.) / sumFrag), 1.0) * vec4(getBoundary(offsetUV));\n    }\n    for(float j = -1. * floatFrag;j<floatFrag;j++)\n    {\n        offsetUV = uv + vec2(0., blur.y/floatFrag * j);\n        sum += texture(iChannel0, offsetUV) * vec4(vec3(cos(3.1415926 * j / floatFrag / 2.) / sumFrag), 1.0) * vec4(getBoundary(offsetUV));\n    }\n    fragColor = vec4(sum.rgb, 1.);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 noise = vec4(vec3(texture(iChannel0, uv).x), 0.);\n    \n    fragColor = mix(mix(vec4(1.), noise, uv.y), vec4(vec3(0.),1.), uv.y);\n}","name":"Buffer C","description":"","type":"buffer"}]}