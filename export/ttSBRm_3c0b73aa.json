{"ver":"0.1","info":{"id":"ttSBRm","date":"1598533687","viewed":451,"name":"Fractal engine","username":"gaz","description":"fractal","likes":24,"published":1,"flags":8,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n#define hash(n) fract(sin(n*234.567+123.34))\n\nfloat map1(vec3 p){\n\tp.xy *= rot(iTime*0.1);\n    p.yz *= rot(iTime*0.2);\n    float seed=dot(floor((p+3.5)/7.)+3.,vec3(123.12,234.56,678.22));   \n    p-=clamp(p,-3.5,3.5)*2.;\n\tp.xy *= rot(iTime*0.3);\n    p.yz *= rot(iTime*0.4);\n\tfloat scale=-5.;\n\tfloat mr2=.38;\n\tfloat off=1.2;\n\tfloat s=3.;\n\tp=abs(p);\n\tvec3  p0 = p;\n\tfor (float i=0.; i<4.+hash(seed)*6.; i++){\n    \tp=1.-abs(p-1.);\n    \tfloat g=clamp(mr2*max(1.2/dot(p,p),1.),0.,1.);\n    \tp=p*scale*g+p0*off;\n        s=s*abs(scale)*g+off;\n\t}\n\treturn length(cross(p,normalize(vec3(1))))/s-.005;\n}\n\nfloat map2(vec3 p){\n    float zoom=2.1;\n    p*=zoom;\n\tp.xy *= rot(iTime*0.1);\n    p.yz *= rot(iTime*0.2);\n    float seed=dot(floor((p+3.5)/7.)+3.,vec3(123.12,234.56,678.22));   \n    p-=clamp(p,-8.,8.)*2.;\n\tp.xy *= rot(iTime*0.3);\n    p.yz *= rot(iTime*0.4);\n\tfloat s=3.*zoom;\n\tp=abs(p);\n\tvec3  p0 = p*1.6;\n\tfor (float i=0.; i<10.; i++){\n        p=1.-abs(abs(p-2.)-1.); \n    \tfloat g=-8.*clamp(.43*max(1.2/dot(p,p),.8),0.,1.3);\n        s*=abs(g);\n\t\tp*=g;\n        p+=p0;\n    }\n\treturn length(cross(p,normalize(vec3(1))))/s-.005;\n}\n\nfloat map(vec3 p){\n    if(fract(iTime*.2)<0.5)\n        return map1(p);\n    else\n        return map2(p);\n}\n\n\nvec3 calcNormal(vec3 pos){\n  vec2 e = vec2(1,-1) * 0.002;\n  return normalize(\n    e.xyy*map(pos+e.xyy)+e.yyx*map(pos+e.yyx)+ \n    e.yxy*map(pos+e.yxy)+e.xxx*map(pos+e.xxx)\n  );\n}\n\nfloat march(vec3 ro, vec3 rd, float near, float far)\n{\n    float t=near,d;\n    for(int i=0;i<80;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if (d<0.001) return t;\n        if (t>=far) return far;\n    }\n    return far;\n}\n\nfloat calcShadow( vec3 light, vec3 ld, float len ) {\n\tfloat depth = march( light, ld, 0.0, len );\t\n\treturn step( len - depth, 0.01 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord* 2.0 - iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0,0,13.5);\n    vec3 rd = normalize(vec3(uv,-2.0));\n    vec3 col = vec3(0);\n\tconst float maxd = 40.0;\n    float t = march(ro,rd,0.0,maxd);\n    if(t<maxd)\n    {\n        vec3 p=ro+rd*t;\n        col=vec3(0.3,0.3,0.6)+cos(p*0.17)*0.5+0.5;\n        vec3 n = calcNormal(p);      \n\t\tvec3 lightPos=vec3(20);\n    \tvec3 li = lightPos - p;\n\t\tfloat len = length( li );\n\t\tli /= len;\n\t\tfloat dif = clamp(dot(n, li), 0.5, 1.0);\n        float sha = calcShadow( lightPos, -li, len );\n        col *= max(sha*dif, 0.4);\n        float rimd = pow(clamp(1.0 - dot(reflect(-li, n), -rd), 0.0, 1.0), 2.5);\n\t\tfloat frn = rimd+2.2*(1.0-rimd);\n    \tcol *= frn*0.9;\n        col *= max(0.5+0.5*n.y, 0.0);\n        col *= exp2(-2.*pow(max(0.0, 1.0-map(p+n*0.3)/0.3),2.0));\n        col += vec3(0.5,0.4,0.9)*pow(clamp(dot(reflect(rd, n), li), 0.0, 1.0), 50.0);\n        col = mix(vec3(0),col,exp(-t*t*.003));\n    }\n    fragColor.xyz = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// OSC\n#define osc_sin(x) sin(x*6.2832)\n#define osc_saw(x) (1.0-fract(x)*2.0)\n#define osc_sqr(x) sign(0.5-fract(x))\n#define osc_tri(x) asin(sin(x*6.2832))/1.5708\n\n// https://www.shadertoy.com/view/3ty3Wt\nconst float[16] nt=float[](2.,4.,8.,16.,32.,48.,64.,80.,101.,127.,190.,254.,381.,508.,1017.,2034.);\nfloat osc_nesnoise(float x,int i){return fract(sin(floor(x*1789772.5/nt[i])*179.2)*204.8);}\n\n// Frequency\nfloat note2freq(int n){\n    return 440.*exp2((float(n)-69.)/12.);\n}\n\n// Seqence Macro\n#define BPM(a) float BAR=240.0/float(a);int[4] CHO;\n#define TRACK {float T,V,tmp=time;int N; \n#define REST(a)tmp-=float(a)*BAR;\n#define LOOP(a)if(tmp>0.0){tmp=mod(tmp,float(a)*BAR);\n#define FOR(c)if(tmp>0.0)for(int i=0;i<c;i++){\n#define END }\n#define SEQ(a,s)\\\n\tif(tmp>0.0){\\\n\t    float n=BAR/float(s);\\\n\t    int c=a.length();\\\n    \tT=mod(tmp,n);\\\n    \tfor(int i=int(tmp/(n))%c;i>=0;i--){\\\n        \tif(a[i]>-1){N=a[i];break;}\\\n        \tT+=n;\\\n    \t}\\\n    \ttmp-=float(c)*n;\\\n\t}\n\n#define VEL(a,s) \\\n\tif(tmp>0.0)V=max(0.0,float(a[int(tmp/(BAR/float(s)))%a.length()]));\n\n// Note numbers\n#define _ -1\n#define C  60\n#define Cs 61\n#define D  62\n#define Ds 63\n#define E  64\n#define F  65\n#define Fs 66\n#define G  67\n#define Gs 68\n#define A  69\n#define As 70\n#define B  71\n#define UP +12\n#define DN -12\n\n//Chord types\n#define _M    int[](0,4,7,_)\n#define _m    int[](0,3,7,_)\n#define _6    int[](0,4,7,9)\n#define _7    int[](0,4,7,10)\n#define _M7   int[](0,4,7,11)\n#define _m7   int[](0,3,7,10)\n#define _add9 int[](0,4,7,14)\n#define _sus2 int[](0,2,7,_)\n#define _sus4 int[](0,5,7,_)\n#define _dim  int[](0,3,6,_)\n#define _aug  int[](0,4,8,_)\n\n// Chord fuctions\nint chord(int root, int[4] t, int inv)\n{\n    int[4] a;\n    if(t[3]<0){\n        for(int i=0;i<3;i++){\n           a[i]=root+int[](t[1]-12,t[2]-12,t[0],t[1],t[2])[i+2-inv];\n        }\n        a[3]=127;\n    }else {\n        for(int i=0;i<4;i++){\n           a[i]=root+int[](t[1]-12,t[2]-12,t[3]-12,t[0],t[1],t[2],t[3])[i+3-inv];\n        }\n    }\n    return a[0]+(a[1]<<7)+(a[2]<<14)+(a[3]<<21);\n}\n\n#define ChordInt2Arr(i) int[](i&127,i>>7&127,i>>14&127,i>>21&127)\n#define ChordSize(a) (a[3]<127?4:3)\n\n// Scale\n#define Major_scale(n)          int[](0,2,4,5,7,9,11)[(n-1)%7]\n#define Minor_scale(n)          int[](0,2,3,5,7,8,10)[(n-1)%7]\n#define Natural_minor_scale(n)  int[](0,2,3,5,7,8,10)[(n-1)%7]\n#define Harmonic_minor_scale(n) int[](0,2,3,5,7,8,11)[(n-1)%7]\n#define Melodic_minor_scale(n)  int[](0,2,3,5,7,9,11)[(n-1)%7]\n \n// Sound Sources\n\nfloat kick(float t){\n   return (sin(pow(1.0-min(1.0,t*3.5),15.0)*55.0+1.2)*exp(-t*3.0)\n    +0.3*sign(0.5-fract(70.0*t))*exp(-t*25.0))\n    *cos(120.0*exp(-t*2.0));\n}\n\nfloat snare(float t){\n    float n=osc_nesnoise(t,4)*exp(-t*10.);\n    float f=t*160.;\n    float m2=.3*osc_tri(1.2*f)*exp(-t*3.);\n    float m1=.05*osc_sin(10.*f+m2)*exp(-t*3.);\n    float c=osc_sin(f+m1)*exp(-t*15.);\nreturn n+c;\n}\n\nfloat hihat(float t)\n{\n    return osc_nesnoise(t,3)*exp(-t*15.);\n}\n\nfloat cymbal(float t)\n{\n    return osc_nesnoise(t,3)*exp(-t*3.);\n}\n\nfloat base(float t,float f)\n{\n\tf*=t;\n  \treturn clamp((\n        5.0*osc_sin(f)\n        + 2.0*osc_sin(f*2.0)\n        + osc_tri(f*3.0)\n    \t)/4.0,-1.0,1.0)*exp(-5.0*t);\n}\n\nfloat piano(float t,float f){\n    float g=0.,a,b=0.;\n    f*=t;\n    for(float j=1.;j<8.;j++){\n        b+=a=exp(-j*.5);\n        g+=a*osc_sin(f*j)*exp(-t*1.5/(1.-j*.1));\n    }\n    g*=1.+1.5*exp(-5.*t);\n    return g/b;\n}\n\nfloat lead(float t,float f)\n{\n    return clamp(-1.,1.,osc_sin(f*t)*2.)*exp(-t*1.);\n}\n\nvec2 mainSound( in int samp, float time )\n{ \n    vec2 gain=vec2(0);\n    BPM(96)\n    TRACK\n    \tLOOP(1)\n       \t\tSEQ(int[](1,1,1,1),4)\n        END\n        gain+= 0.3*kick(T);\n    END\n    \n    TRACK\n        LOOP(4)\n            FOR(3)\n       \t\t    SEQ(int[](_,1,_,1),4)\n       \t\tEND\n       \t\tSEQ(int[](_,_,1,_, _,1,1,1),8)\n        END\n        gain+=0.2*snare(T);\n    END\n    \n    TRACK\n        LOOP(4)\n        \tVEL(int[](_,_,1,_,_,_,1,_),8)\n        \tSEQ(int[](_,1,1,1,1,1,1,1),8)\n        \tFOR(3)\n        \t    VEL(int[](_,_,1,_,_,_,1,_),8)\n        \t    SEQ(int[](1,1,1,1,1,1,1,1),8)\n        \tEND\n        END\n        gain+= 0.3*(0.5+0.5*V) * hihat(T);\n    END     \n    \n    TRACK\n        LOOP(4)\n        \tSEQ(int[](1,_,_,_),1)\n        END\n        gain+= 0.3* cymbal(T);\n    END     \n    \n    #define X(n,t,i)chord(n,t,i)\n    TRACK\n\t    LOOP(4)\n          SEQ(int[](X(F,_M7,0),X(E,_m7,0),X(F,_M7,0),X(E,_m7,0)),0)\n        END\n        CHO=ChordInt2Arr(N);\n    END\n\n    #define M C+(N-1)/7*12+Major_scale(N)\n\tTRACK\n\t     LOOP(4)\n        \tSEQ(int[](5,4,3,_),4)\n        \tSEQ(int[](5,7,5,_),4)\n        \tSEQ(int[](5,4,3,_),4)\n        \tSEQ(int[](4,6,3,_),4)\n        END\n        gain+=0.1*lead(T,note2freq(M))*exp(-T*3.);\n    END\n    \n    TRACK\n\t    LOOP(1)\n        \tSEQ(int[](1,_,_,1,_,_,1,_),8)\n        END\n      \tfor(int i=0;i<ChordSize(CHO);i++)\n       \t\tgain += 0.05*piano(T,note2freq(CHO[i]-12));\n    END\n    \n\tTRACK\n\t    LOOP(1)\n         \tSEQ(int[](1,1,1,1),4)\n        END\n      \tgain += 0.1*base(T,note2freq(CHO[0]-24));\n    END\n    return 0.6*gain;\n}\n","name":"Sound","description":"","type":"sound"}]}