{"ver":"0.1","info":{"id":"tssXzr","date":"1550529389","viewed":496,"name":"[twitch] Scary Hairy","username":"NuSan","description":"Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS if too slow, or put CURLYHAIR to 0\n\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/ScaryHairy.glsl","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","hair","live","twitch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS if too slow, or put CURLYHAIR to 0\n\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/ScaryHairy.glsl\n*/\n\n#define MARCH_STEPS 100\n#define CURLYHAIR 1\n\n#define time iTime\n\nfloat PI = acos(-1.0);\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat smin(float a, float b, float h) {\n\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\nvec3 rotrep(vec3 p, float rep, float off) {\n  vec2 rp=vec2(atan(p.z,p.x)/(2.0*PI), length(p.xz));\n  rp.x = (fract(rp.x*rep-0.5+off)-0.5)/rep;\n  return vec3(cos(rp.x*2.0*PI)*rp.y,p.y,sin(rp.x*2.0*PI)*rp.y);\n}\n\nfloat rotid(vec3 p, float rep, float off) {\n  vec2 rp=vec2(atan(p.z,p.x)/(2.0*PI), length(p.xz));\n  return floor(rp.x*rep-0.5+off);\n}\n\nvec3 tmin(vec3 a, vec3 b) {\n  return a.x<b.x?a:b;\n}\n\nvec3 curly(vec3 p, float hole, float freq, float offset) {\n\n  \n  vec3 rp = rotrep(p, freq, offset);\n  float off = fract(sin(rotid(p, 30.0, 0.0)*780.4)*7842.25)*12.0;\n  \n  rp.xz *= rot(sin(rp.y*10.0+off)*0.01);\n\n  vec3 dp = p;\n  dp.y = max(-dp.y, 0.0);\n  float dec = 1.0-length(normalize(dp).xz);\n  float wid = 1.1 + sin(p.y*5.0+off*42.57)*0.3;\n    \n  vec3 cyl = vec3(length(rp.xz-vec2((1.0-dec)*1.49,0.0))-0.1*wid,atan(rp.z,rp.x)*1.0,rp.y);\n  cyl.x = smin(cyl.x, -1.85-p.y, -0.8);\n  cyl.x = smin(cyl.x, -5.9+p.y, -4.8);\n  cyl.x = smin(cyl.x, -hole,-.7);\n\n  return cyl;\n\n}\n\nvec3 hairbase(vec3 p, float r) {\n  vec3 lp = p;\n  lp.y = max(0.0,-lp.y);\n\n  \n  float edge = atan(p.z,p.x)/(2.0*PI);\n/*\n  p.x += sin(edge*3)*.1;\n  //p.x -= sin(p.y*6.8)*.1;\n  p.y += sin(p.x*30)*.01;\n  p.y += sin(p.z*13)*.03;\n*/\n  float sp = length(lp)-r;\n  float d = abs(sp)-0.05;\n  \n  \n  vec3 ph = p;\n  ph.y = max(0.0,0.8-ph.y);\n  float hole = (length(ph.xy)-0.5);\n  hole = max(hole, p.z);\n  \n  d = smin(d,-1.9+p.y + (sin(edge*50.0)+sin(edge*108.0)*0.5+sin(edge*138.0)*0.45)*0.3, -.3);\n\n  d = smin(d,-hole,-.9);\n\n  vec3 res = vec3(d, atan(p.z,p.x), p.y/r);\n#if CURLYHAIR\n  res = tmin(res, curly(p, hole, 15.0, 0.0));\n  res = tmin(res, curly(p, hole, 35.0, 0.5));\n  res = tmin(res, curly(p, hole, 13.0, 0.27));\n#endif  \n  return res;\n}\n\nfloat sph(vec3 p, float r) {\n  return length(p)-r;\n}\n\nvec3 body(vec3 p) {\n\n  vec3 cp2 = p;\n  cp2.y += sin(cp2.x*PI*5.0)*0.1;\n  cp2.x -= clamp(cp2.x,-0.3,0.3);  \n  \n  vec3 cp3 = p-vec3(-0.0,0.4,-1.5);\n  cp3.y -= clamp(cp3.y,-0.1,0.1);  \n  //cp3.yz *= rot(-0.2);\n  \n  p.x = smin(p.x, -p.x, 0.3);\n  \n  float b1 = sph(p,1.5);\n  b1 = smin(b1, sph(p-vec3(0,1,-0.3),1.2), 0.5);\n  b1 = smin(b1, -sph(p-vec3(-0.6,0.3,-1.8),0.4), -0.4);\n  b1 = smin(b1, sph(p-vec3(-0.45,0.3,-1.2),0.15), 0.05);\n\n  b1 = smin(b1, sph(p-vec3(-0.1,0.7,-1.6),0.1), 0.15);\n  b1 = smin(b1, sph(cp3,0.1), 0.2);\n  \n  b1 = smin(b1, -sph(cp2-vec3(0.0,1.3,-1.3),0.1), -0.2);\n\n  vec3 cp = p;\n  cp.y -= clamp(cp.y-2.0,0.0,1.0);\n  b1 = smin(b1, sph(cp-vec3(0,2,0.1),0.7), 0.2);\n  return vec3( b1, 0, 0);\n}\n\nfloat mat = 0.0;\nvec3 map(vec3 p) {\n  vec3 h = hairbase(p, 1.5);\n  vec3 b = body(p);\n  mat=(b.x<h.x)?1.0:0.0;\n  return tmin(h, b);\n}\n\nfloat mapx(vec3 p) {\n  return map(p).x;\n}\n\nfloat mapz(vec3 p) {\n  return map(p).z;\n}\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0);\n  return normalize(mapx(p)-vec3(mapx(p-off.xyy), mapx(p-off.yxy), mapx(p-off.yyx)));\n}\n\nvec3 tangent(vec3 p) {\n  vec2 off=vec2(0.01,0);\n  return normalize(mapz(p)-vec3(mapz(p-off.xyy), mapz(p-off.yxy), mapz(p-off.yyx)));\n}\n\nfloat noise(vec2 uv) {\n  vec2 iuv=floor(uv);\n  vec2 fuv=fract(uv);\n  fuv=smoothstep(0.0,1.0,fuv);\n  vec2 st=vec2(7,877);\n  vec2 m = dot(iuv,st)+vec2(0,st.y);\n  vec2 val = mix(fract(sin(m)*7584.522), fract(sin(m+st.x)*7584.522), fuv.x);\n  return mix(val.x,val.y, fuv.y);\n}\n\nfloat fractal(vec2 uv) {\n  float d=0.0;\n  for(int i=0; i<5; ++i) {\n    float s=pow(2.0,float(i));\n    d+=noise(uv*s)/s;\n  } \n  return d*0.5;\n}\n\nvoid cam(inout vec3 p) {\n  float t1=time*0.3;\n  p.xz *= rot(t1);\n  p.xy *= rot(sin(t1*1.3)*0.5);\n  //p.yz *= rot(0.9);\n  //p.xz *= rot(sin(time)*0.9);\n}\n\nfloat hair(vec3 tang, vec3 h, float power) {\n  float cosang = dot(tang, h);\n  float sinang = sqrt(1.0-cosang*cosang);\n  float spechair = pow(sinang, power);\n  return spechair;\n}\n\nvec3 light(vec3 l, vec3 p, vec3 r, vec3 n, vec2 tex, vec3 tang, float curmat) {\n  float rand = fractal(tex*vec2(150,3));\n  vec3 h = normalize(l-r);\n\n  vec3 col = vec3(0);\n\n  vec3 haircol = vec3(1,0.5,0.1);\n\n  vec3 diff = haircol * 0.3;\n\n  float aodist=0.2;\n  float ao = clamp(mapx(p+n*aodist)/aodist,0.0,1.0);\n  //ao = pow(ao, 3);\n\n  if(curmat<0.5) {\n    float spechair1 = hair(normalize(tang + n * (rand-0.3) * 1.0), h, 100.0);\n    float spechair2 = hair(normalize(tang + n * (rand-0.7) * 1.0), h, 10.0);\n    col = max(0.0, dot(n,l)*0.7+0.3) * (diff + spechair1 + spechair2 * haircol) * ao;\n  } else {\n  \n    vec3 eyep = p;\n    eyep.x=-abs(eyep.x);\n    float disteye = sph(eyep-vec3(-0.45,0.3,-1.2),0.15);\n    float eye = step(disteye, 0.03);\n\n    float spec = pow(max(0.0,dot(n,h)),6.0);\n    float spec2 = pow(max(0.0,dot(n,h)),50.0);\n\n    \n    if(eye>.0) {\n      col = vec3(1)*max(0.0, dot(n,l)*0.7+0.3) * step(0.007,disteye);\n    } else {\n      float fade = clamp((-p.y+2.7)*1.0,0.0,1.0);\n      col = max(0.0, dot(n,l)*0.7+0.3) * (vec3(1.0,0.7,0.5) * (1.0 + spec) + 0.2*spec2) * ao * fade;\n    }\n    \n  }\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 s = vec3(0.0,0.7,-5);\n  vec3 r = normalize(vec3(-uv, 0.8+sin(time*0.7)*0.2));\n\n  cam(s);\n  cam(r);\n\n  vec3 p=s;\n  float dd=0.0;\n  \n  for(int i=0; i<MARCH_STEPS; ++i) {\n    float d=mapx(p);\n    if(d<0.001) {\n      break;\n    }\n    if(dd>100.0) {\n      dd=100.0;\n      break;\n    }\n    p+=r*d*0.7;\n    dd+=d*0.7;\n  }\n  float curmat = mat;\n\n  vec3 n = norm(p);\n  vec3 tang = tangent(p);\n  vec3 bin = normalize(cross(n,tang));\n  tang = normalize(cross(n,bin));\n\n\n  vec2 tex = map(p).yz;\n\n  float fog = 1.0-clamp(dd/100.0,0.0,1.0);\n\n  vec3 col = vec3(0);\n\n  vec3 l = normalize(vec3(-1));\n  vec3 l2 = normalize(vec3(1.3,-0.7,0.5));\n  vec3 l3 = normalize(vec3(0.7,-0.7,0.5));\n  \n  col += light(l, p, r, n, tex, tang, curmat) * fog;\n  col += light(l2, p, r, n, tex, tang, curmat) * fog * vec3(0.7,0.5,0.8);\n  //col += light(l3, p, r, n, tex, tang, curmat) * fog * vec3(0.3,0.7,0.5);\n  \n  \n  //col = vec3(fractal(uv*10));\n\n  fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}