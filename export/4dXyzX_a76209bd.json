{"ver":"0.1","info":{"id":"4dXyzX","date":"1489023490","viewed":96,"name":"graprog ps20 - Belleza","username":"Cyrus_Darkhunter","description":"ps20","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["ps20"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define TWO_PI 6.28318530718\nvec3 yellow = vec3(1,1,0);\nvec3 blue = vec3(0,0,1);\nvec3 red = vec3(1,0,0);\nvec3 white = vec3(1,1,1);\n\n\nfloat rand(vec2 uv)\n{\n    return (fract(sin(dot(uv, vec2(12., 70.)))*43758.5453123));\n}\n\n// Value noise\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\nfloat circle(vec2 c, float r, vec2 uv)\n{\n    float value = step(distance(c, uv), r);\n    return value;\n}\n\nmat2 scale2d(vec2 value)\n{\n \treturn mat2(value.x, 0, 0, value.y);   \n}\n\n\nfloat polygon(float sides, vec2 uv, float ratio, vec2 pos)\n{\n    pos.x *= ratio;\n    uv -= pos;\n\n\t// Angle and radius from the current pixel\n\tfloat a = atan(uv.x,uv.y) + PI;\n\tfloat r = TWO_PI/float(sides);\n  \n\t// Shaping function that modulate the distance\n\tfloat dist = cos(floor(.5+a/r)*r-a)*length(uv);\n    \n    return dist;\n}\nfloat recRand(vec2 uv, vec2 size, vec2 pos)\n{\n    float noize = noise(uv + abs(sin(iTime)));\n \tfloat value = step(pos.x + noize, uv.x) - step(pos.x + noize+ size.x, uv.x); \n    value *= step(pos.y +sin(iTime) + noize, uv.y) - step(pos.y + sin(iTime) + size.y + noize, uv.y);\n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    uv.x*=ratio;\n    uv*=20.;\n    \n    float angle = atan(uv.y, uv.x);\n    float radius = cos(8. * angle);\n    \n    float value = recRand(uv, vec2(.5,10.5), vec2(13.0, 3.*abs(sin(iTime))));\n    value += recRand(uv, vec2(.5,10.5), vec2(15.0, 3.*abs(sin(iTime))));\n    value += recRand(uv, vec2(.5,10.5), vec2(17.0, 3.*abs(sin(iTime))));\n    value += recRand(uv, vec2(.5,10.5), vec2(19.0, 3.*abs(sin(iTime))));\n    \n    value += step(polygon(3., uv, ratio, vec2(9.5,13. + 3. * sin(iTime))), 2. + abs(sin(iTime)) + noise(uv + abs(cos(iTime))));\n    value += step(1.-circle(vec2(17.,15. + 3. * sin(iTime)), 4.5 + abs(sin(iTime)), uv), 0.2);\n    \n    fragColor = vec4(vec3(value), 0.);\n}","name":"Image","description":"","type":"image"}]}