{"ver":"0.1","info":{"id":"fdfSD7","date":"1618741844","viewed":108,"name":"Pyramid, fire, and illumination","username":"artnitolog","description":"Assignment for the Computer Graphics course, CMC MSU, spring 2021.\n\n== Links ==\n\nPipeline: https://youtu.be/idoj8QmFH_0\nFire: https://www.shadertoy.com/view/4ssGzn","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","raymarching","reflection","refraction","stochastic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Accumulation: divide by number of frames\n    fragColor = texture(iChannel0, uv) / float(iFrame + 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float INF = 1e10;\nconst float EPS = 1e-4;\nconst vec3 CAMERA_POS = vec3(2, 0, -8);\n\nconst int EMISSION = 0;\nconst int DIFFUSE = 1;\nconst int REFRACTION = 2;\nconst int REFLECTION = 3;\nconst int VOLUME = 4;\n\nstruct Material {\n    int base_type;\n    int alt_type;\n    float proba_alt;\n};\n\n// deterministic\nconst Material DetMats[] = Material[] (\n    Material(EMISSION, EMISSION, 0.0),\n    Material(DIFFUSE, DIFFUSE, 0.0),\n    Material(REFRACTION, REFRACTION, 0.0),\n    Material(REFLECTION, REFLECTION, 0.0),\n    Material(VOLUME, VOLUME, 0.0)\n);\n\nconst float ETA_AIR = 1.0;\nconst float ETA_CRYSTAL = 1.4;\nconst float ETA_RATIOS[2] = float[2](ETA_AIR/ETA_CRYSTAL, ETA_CRYSTAL/ETA_AIR);\nconst float CRYSTAL_R = (ETA_CRYSTAL - ETA_AIR) * (ETA_CRYSTAL - ETA_AIR) / (ETA_CRYSTAL + ETA_AIR) / (ETA_CRYSTAL + ETA_AIR);\n\nstruct Light {\n    vec3 pos;\n    float intensity;\n    vec4 color;\n};\n\nstruct Hit {\n    float t;\n    vec3 worldPos;\n    vec3 normal;\n    Material material;\n    vec4 color;\n};\n\nstruct Sphere {\n    vec3 center;\n    float r;\n    Material material;\n    vec4 color;\n};\n\nconst Light lights[] = Light[](\n    Light(vec3(3, 1, 1), 10.0, vec4(0.78125, 0.8863, 1.0, 1)),\n    Light(vec3(-1, -0.3, -4), 5.0, vec4(1, 0.95, 0.78, 1)),\n    //Light(vec3(-3, -0.5, 0), 10.0, vec4(1, 0.95, 0.78, 1)),\n    Light(vec3(0, 0.0, 0), 10.0, vec4(1.0,0.9,0.5,1))\n);\n\nconst int n_lights = lights.length();\n\n// no it doesn't help here\nconst vec4 AMBIENT = vec4(0);//vec4(0.1, 0.01, 0.1, 1.0);\n\nconst Sphere spheres[] = Sphere[](\n    Sphere(lights[0].pos, 0.4, DetMats[EMISSION], lights[0].color),\n    Sphere(lights[1].pos, 0.4, DetMats[EMISSION], lights[1].color)\n    //Sphere(vec3(1.5,0,4), 1.0, DetMats[DIFFUSE], vec4(1,0,0,1)),\n    //Sphere(vec3(1.2,0,0), 0.4, DetMats[REFRACTION], vec4(0,0,1,1)),\n    //Sphere(vec3(-1.2,0,0), 0.4, DetMats[REFLECTION], vec4(0,0,1,1)),\n    //Sphere(vec3(2, -0.2, 0.1), 0.1, DetMats[EMISSION], vec4(1,1,0,1)),\n    //Sphere(vec3(-2, -0.9, 0.1), 0.1, DetMats[EMISSION], vec4(1,0,1,1))\n);\n\nconst int n_spheres = spheres.length();\n\n// this mesh contains a lot of duplicates but it's still small\nconst vec3 vee_pyramid[] = vec3[](\n    vec3(0.0, 1.3, 0.0), vec3(-1.0, -2.3, -1.0), vec3(-1.0, -2.3, 1.0), \n    vec3(0.0, 1.3, 0.0), vec3(-1.0, -2.3, 1.0), vec3(1.0, -2.3, 1.0), \n    vec3(0.0, 1.3, 0.0), vec3(1.0, -2.3, 1.0), vec3(1.0, -2.3, -1.0), \n    vec3(0.0, 1.3, 0.0), vec3(1.0, -2.3, -1.0), vec3(-1.0, -2.3, -1.0), \n    vec3(-1.0, -1.0, -1.0), vec3(2.0, 0.0, 0.0), vec3(0.0, 0.0, 2.0), \n    vec3(1.0, -1.0, 1.0), vec3(-2.0, 0.0, 0.0), vec3(0.0, 0.0, -2.0)\n);\n\n\nconst Material PyrMaterial = Material(REFRACTION, REFLECTION, CRYSTAL_R * 10.0);\nconst vec4 PyrColor = vec4(1, 1, 0.9, 1);\n\nconst Material FloorMat = Material(DIFFUSE, REFLECTION, 0.5);\nconst float FloorPos = -1.1;\n\nconst vec3 FirePos = vec3(0,0.0,0);\nconst float ShellRadius = 0.5;\n\nconst int N_VOLUME_STEPS = 200;\nconst float VOLUME_DENSITY = 0.25;\nconst float STEP_SIZE = 0.014;\n\n\nfloat rand(int frame) {\n    return fract(sin(dot(vec3(frame), vec3(12.9898,78.233,45.5432))) * 43758.5453);\n}\n\nint whichMaterial(Material mat, float rv) {\n    if (mat.base_type == mat.alt_type) {\n        return mat.base_type;\n    }\n    if (rv < mat.proba_alt) {\n        return mat.alt_type;\n    } else {\n        return mat.base_type;\n    }\n}\n\nvoid traceFloor(vec3 pos, vec3 dir, inout Hit hit) {\n    float t = (FloorPos - pos.y) / dir.y;\n    if (t <= 0.0 || t > hit.t) {\n        return;\n    }\n    vec3 worldPos = pos + t * dir;\n    if (dot(worldPos.xz, worldPos.xz) > 50.0) {\n        return;\n    }\n    hit = Hit(t, worldPos, vec3(0, 1, 0), FloorMat,\n              texture(iChannel0, 0.1 * worldPos.xz));\n}\n\n\nvoid tracePedestal(vec3 pos, vec3 dir, inout Hit hit) {\n    const float PED_SQR = 6.0;\n    float t = (-1.0 - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return;\n    }\n    vec3 worldPos = pos + dir * t;\n    if (dot(worldPos.xz, worldPos.xz) < PED_SQR && t < hit.t) {\n        hit = Hit(t, worldPos, vec3(0, 1, 0), DetMats[DIFFUSE], texture(iChannel2, worldPos.xz * worldPos.y));\n        //return;\n    }\n    float k = dot(pos.xz, dir.xz);\n    float a = dot(dir.xz, dir.xz);\n    float D1 = k * k - (dot(pos.xz, pos.xz) - PED_SQR) * a;\n    if (D1 < 0.0) {\n        return;\n    }\n    t = (-k - sqrt(D1)) / a;\n    worldPos = pos + t * dir;\n    if (t < 0.0 || worldPos.y > -1.0 || t > hit.t) {\n        return;\n    }\n    vec3 normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n    hit = Hit(t, worldPos, normal, DetMats[DIFFUSE], texture(iChannel2, worldPos.xz * worldPos.y));\n}\n\nvoid traceSphere(vec3 pos, vec3 dir, Sphere S, inout Hit hit) {\n    vec3 cpos = pos - S.center;\n    float k = dot(cpos, dir);\n    float D1 = k * k - dot(cpos, cpos) + S.r * S.r;\n    if (D1 < 0.0) {\n        return;\n    }\n    float t = -k - sqrt(D1);\n    if (t < 0.0) {\n        t = -k + sqrt(D1);\n        if (t < 0.0) {\n            return;\n        }\n    };\n    if (t > hit.t) {\n        return;\n    }\n    vec3 normal = normalize(cpos + t * dir);\n    hit = Hit(t, pos + t * dir, normal, S.material, S.color);\n}\n\n\nvec3 traceTriangle(vec3 pos, vec3 dir, vec3 v0, vec3 e1, vec3 e2) {\n    vec3 T = pos - v0;\n    vec3 P = cross(dir, e2);\n    float det = dot(P, e1);\n    vec3 Q = cross(T, e1);\n    float t = dot(Q, e2) / det;\n    if (t < 0.0) {\n        return vec3(INF);\n    }\n    float u = dot(P, T) / det;\n    float v = dot(Q, dir) / det;\n    if (u < 0.0 || v < 0.0 || u + v > 1.0) {\n        return vec3(INF);\n    }\n    return vec3(t, u, v);\n}\n\nvoid tracePyramid(vec3 pos, vec3 dir, inout Hit hit) {\n    vec3 tuv = vec3(INF);\n    int idx = -1;\n    for (int i = 0; i < vee_pyramid.length(); i += 3) {\n        vec3 cur_tuv = traceTriangle(pos, dir, vee_pyramid[i], vee_pyramid[i + 1], vee_pyramid[i + 2]);\n        if (cur_tuv.x < tuv.x) {\n            tuv = cur_tuv;\n            idx = i;\n        }\n    }\n    if (tuv.x > hit.t) {\n        return;\n    }\n    vec3 norm = normalize(cross(vee_pyramid[idx + 1], vee_pyramid[idx + 2]));\n    hit = Hit(tuv.x, pos + tuv.x * dir, norm, PyrMaterial, PyrColor);\n}\n\nbool isOccluded(vec3 pos, vec3 target) {\n    vec3 dir = normalize(target - pos);\n    Hit hit;\n    hit.t = INF;\n    /*tracePyramid(pos, dir, hit);\n    if (hit.t != INF) {\n        return true;\n    }*/\n    tracePedestal(pos, dir, hit);\n    if (hit.t != INF) {\n        return true;\n    }\n    return false;\n}\n\nvec4 computeLight(vec3 pos, vec3 normal, vec4 color) {\n    vec4 diffuse = vec4(0);\n    for (int i = 0; i < n_lights; ++i) {\n        vec3 toLight = lights[i].pos - pos;\n        float attSq = isOccluded(pos + EPS * normal, lights[i].pos + 0.05 * lights[i].intensity * vec3(rand(-3 * iFrame), rand(-3 * iFrame + 1), rand(-3 * iFrame + 2))) ? 0.0 : lights[i].intensity / dot(toLight, toLight);\n        diffuse += lights[i].color * max(0.0, dot(normal, normalize(toLight))) * attSq;\n    }\n    return color * diffuse + AMBIENT;\n}\n\nvec3 hmRefract(vec3 dir, vec3 normal, inout int inside) {\n    if (dot(dir, normal) < 0.0) {\n        normal = -normal;\n    }\n    //inside = 1 - inside; LOOK OUT\n    float cosA = dot(dir, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 tang = normalize(dir - cosA * normal);\n    float sinB = sinA * ETA_RATIOS[inside];\n    if (sinB > 1.0) {\n        // Total internal reflection\n        \n        return reflect(dir, normal);\n        \n    }\n    inside = 1 - inside;\n    float cosB = sqrt(1.0 - sinB * sinB);\n    return sinB * tang + cosB * normal;\n}\n\n// Original idea:\n// https://www.shadertoy.com/view/4ssGzn\nfloat noise(in vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f * f * f * (3.0-2.0*f);\n\tvec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n\tvec2 rg = texture(iChannel3, (uv+0.5)/256.0, -100.0).xz;\n\treturn mix(rg.x, rg.y, f.z) * 2.0 - 1.0;\n}\n\nfloat fbm(vec3 p) {\n    float f = 0.0;\n    float amp = 0.5;\n    for (int i = 0; i < 4; ++i) {\n        f += noise(p) * amp;\n        p *= 2.03;\n        amp *= 0.5;\n\t}\n    return f;\n}\nconst float NOISE_FREQ = 1.5;\nconst float NOISE_AMP = 2.0;\n\nfloat distanceFunc(vec3 p) {\n    p *= 6.0;\n    float d = length(p) - 1.0;\n\td += fbm(p * NOISE_FREQ) * NOISE_AMP;\n\treturn d;\n}\n\nvec4 shade(float d) {\t\n    if (d >= 0.0 && d < 0.2) return (mix(vec4(3, 3, 3, 1), vec4(1, 1, 0, 1), d / 0.2));\n\tif (d >= 0.2 && d < 0.4) return (mix(vec4(1, 1, 0, 1), vec4(1, 0, 0, 1), (d - 0.2) / 0.2));\n\tif (d >= 0.4 && d < 0.5) return (mix(vec4(1, 0, 0, 1), vec4(0, 0, 0, 0), (d - 0.4) / 0.2));    \n    if (d >= 0.5 && d < 0.8) return (mix(vec4(0, 0, 0, 0), vec4(0, .5, 1, 0.2), (d - 0.6) / 0.2));\n    if (d >= 0.8 && d < 1.2) return (mix(vec4(0, .5, 1, .2), vec4(0, 0, 0, 0), (d - 0.8) / 0.2));            \n    return vec4(0.0, 0.0, 0.0, 0.0);\n}\n\nvec4 volumeFunc(vec3 p) {\n\tfloat d = distanceFunc(p);\n\treturn shade(d);\n}\n\nvec4 rayMarch(vec3 pos, vec3 ray_step) {\n    vec4 sum = vec4(0, 0, 0, 0);\n\tfor (int i = 0; i < N_VOLUME_STEPS; i++) {\n\t\tvec4 col = volumeFunc(pos);\n\t\tcol.a *= VOLUME_DENSITY;\n\t\tcol.rgb *= col.a;\n\t\tsum += col*(1.0 - sum.a);\n        pos += ray_step;\n\t}\n\treturn sum * 0.9;\n}\n\nvoid traceFire(vec3 pos, vec3 dir, inout Hit hit) {\n    vec3 cpos = pos - FirePos;\n    float k = dot(cpos, dir);\n    float D1 = k * k - dot(cpos, cpos) + ShellRadius * ShellRadius;\n    if (D1 < 0.0) {\n        return;\n    }\n    float t1 = -k - sqrt(D1);\n    float t2 = -k + sqrt(D1);\n    if (t1 < 0.0 || t1 > hit.t) {\n        return;\n    }\n    vec3 start = pos + dir * t1;\n    vec4 color = rayMarch(start, dir * STEP_SIZE);\n    hit = Hit(t1, pos + dir * t2, vec3(0), DetMats[VOLUME], color);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rvs = vec3(rand(3 * iFrame), rand(3 * iFrame + 1), rand(3 * iFrame + 2));\n    vec2 AA_shift = 2.0 * rvs.xy - 1.0;\n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + AA_shift) / iResolution.x;\n    vec3 front = normalize(-CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    vec3 viewVec = normalize(front + right * uv.x + up * uv.y);\n    \n    \n    vec3 pos = CAMERA_POS;\n    vec3 dir = viewVec;\n    \n    int inside = 0;\n    \n    fragColor = vec4(0, 0, 0, 0);\n    \n    for (int i = 0; i < 30; ++i) {\n        Hit hit = Hit(INF, vec3(0), vec3(0), DetMats[0], vec4(0));\n        traceFloor(pos, dir, hit);\n        tracePedestal(pos, dir, hit);\n        for (int j = 0; j < n_spheres; ++j) {\n            Sphere S = spheres[j];\n            if (S.material.base_type == EMISSION) {\n                vec3 toCenter = -normalize(S.center) * rvs.x * 0.4;\n                S.center += rvs * 0.2;\n            }\n            traceSphere(pos, dir, S, hit);\n        }\n        tracePyramid(pos, dir, hit);\n        traceFire(pos, dir, hit);\n        if (hit.t != INF) {\n            int material_type = whichMaterial(hit.material, rvs.x);\n            if (material_type == EMISSION) {\n                fragColor = hit.color;\n                break;\n            } else if (material_type == DIFFUSE) {\n                vec4 color = computeLight(hit.worldPos, hit.normal, hit.color);\n                fragColor.rgb += color.rgb * (1.0 - fragColor.a);\n                break;\n            } else if (material_type == REFLECTION) {\n                pos = hit.worldPos + hit.normal * EPS;\n                dir = reflect(dir, hit.normal);\n            } else if (material_type == REFRACTION) {\n                dir = hmRefract(dir, hit.normal, inside);\n                pos = hit.worldPos + dir * EPS;\n            } else if (material_type == VOLUME) {\n                pos = hit.worldPos + dir * EPS;\n                fragColor += hit.color * (1.0 - fragColor.a);\n            }\n        } else {\n            vec4 color = texture(iChannel1, dir);\n            fragColor += color * (1.0 - fragColor.a);\n            break;\n        }\n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}","name":"Buffer B","description":"","type":"buffer"}]}