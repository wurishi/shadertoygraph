{"ver":"0.1","info":{"id":"3ttyRr","date":"1608360509","viewed":117,"name":"raytracing, lighting and shadows","username":"wnu","description":"adapted from https://www.shadertoy.com/view/3sc3z4","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","lighting","shadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct HitData{\n    float rayLength;\n    vec3 normal;\n    vec3 color;\n    float dTS;\n};\n    \nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n \n    \nvec2 sphereIntersect(vec3 r0,vec3 rd,vec3 s0,float sr)\n{\n    float t = dot(s0-r0,rd);\n    vec3 p = r0 + rd*t;\n    float y = length(s0-p);\n    float x = sqrt(sr*sr-y*y);\n    float t1 = t-x;\n    \n    if(y<sr){\n     return vec2(t1,y);   \n    }\n    \n    return vec2(-1.,y);\n}\n\n#define sphereCount 3\nconst vec4 spheres[sphereCount] = vec4[sphereCount](\n    vec4(0.,0.,3.,1.),\n    vec4(0.,0.,3.,1.),\n    vec4(0.,-1001.,3.,1000.)\n);\n\nHitData getIntersection(vec3 r0,vec3 rd)\n{\n    HitData h;\n    h.rayLength = 999999.0;\n    h.color = vec3(0.5,0.7,0.3);\n    \n    for(int i = 0;i<sphereCount;i++){\n        vec3 s0 = spheres[i].xyz;\n        float sr = spheres[i].w;\n        \n        if(i==0){\n         s0.y += abs(cos(iTime*4.23));\n         s0.x += cos(iTime)*2.;\n         s0.z += sin(iTime)*2.;\n         //h.color = vec3(1.,0.07,0.3);\n        }\n        \n        vec2 sphereData = sphereIntersect(r0,rd,s0,sr);\n        float t = sphereData.x;\n        if(i==0){\n        h.dTS = sphereData.y;\n        }\n        \n    \n        if(t<h.rayLength && t >0.001){\n            //if(i==0){\n            //   h.color = vec3(1.,0.0,0.); \n            //}\n            //if(i==1){\n            //   h.color = vec3(0.0,0.0,1.); \n            //}\n            \n            h.color = hsl2rgb(vec3(float(i)/float(sphereCount),0.8,0.5));\n            h.rayLength = t;\n            \n            vec3 p = r0 + rd*t;\n            h.normal = normalize(p-s0);\n        }\n    }\n    //vec3 s0 = vec3(0.,0.,2.);\n    //float sr = 1.;\n    \n    \n    \n    //h.normal = vec3(0.);\n    \n    return h;\n}\nfloat rand01(float seed) { return fract(sin(seed)*43758.5453123); }\nvec3 randomUnitSphere(vec3 rd,vec3 r0,float seed)\n{\n     return vec3(rand01(iTime * (rd.x + r0.x + 0.357)*seed ),\n                rand01(iTime * (rd.y + r0.y + 16.35647)*seed ),\n                rand01(iTime * (rd.z + r0.z + 425.357)*seed));\n}\n\nvec3 getFinalColor(vec3 r0, vec3 rd,float AAIndex){\n    \n    int bounces = 32;\n    vec3 finalColor = vec3(0.6,0.7,0.8);\n    float absorbMult = 1.;\n    \n    vec3 sun_dir = normalize(vec3(0.8,0.4,0.2));\n    vec3 sky_dir = vec3(0.,1.,0.);\n    \n    \n    for(int i = 0;i<bounces;i++){\n        HitData h = getIntersection(r0 + rd*0.0001,rd);\n        \n        r0 += rd*h.rayLength;\n        float roughness = 0.007 + iMouse.x / iResolution.x;\n        rd = normalize(reflect(rd,h.normal + randomUnitSphere(rd,r0,AAIndex)*roughness));\n        \n        HitData sH = getIntersection(r0 + sun_dir*0.0001,sun_dir);\n        float sun_sha = step(99999.0,sH.rayLength);\n        float sun_dif = clamp(dot(h.normal,sun_dir),0.,1.);\n        vec3 sun = vec3(1.,0.7,0.5)*0.5*sun_dif*sun_sha;\n        float sky_dif = clamp(0.5 + 0.5*dot(h.normal,sky_dir),0.,1.);\n        vec3 sky = vec3(0.,0.0,0.3)*sky_dif;\n        \n        if(h.rayLength>99999.0){\n            //vec3 color = vec3(0.5,0.7,0.3);\n            vec3 color = vec3(0.7,0.85,1.0);\n            //finalColor = color*absorbMult;\n            finalColor = mix(finalColor,color+sun+sky,absorbMult);\n            break;\n        }\n        \n        finalColor = mix(finalColor,h.color+sun+sky,absorbMult);\n        \n        absorbMult *= 0.8;\n        \n        \n        \n    }\n    \n \treturn finalColor;   \n}\n\nvoid mainImage( out vec4 C, in vec2 U)\n{\n    vec2 R = iResolution.xy;\n    \n    U*= 2./R;\n    U -= 1.;\n    U.x *= R.x/R.y;\n    \n    vec3 r0 = vec3(0.,-sin(iTime)*2. + 1.,-6.);\n    vec3 focus = vec3(0.,sin(iTime)*1.2 -.2,0.);\n    vec3 rd = normalize(focus + vec3(U,4.));\n    vec3 c = vec3(0.);\n    int m = int(step(0.001,iMouse.x / iResolution.x)*15. +1.);\n    m= 16;\n    for(int i = 1;i<=m;i++){\n        c += getFinalColor(r0,rd,float(i));\n    }\n    c /= float(m);\n    //vec3 c = getFinalColor(r0,rd);\n    c.rgb = pow(c.rgb,vec3(1.0/2.2));\n    \n    C = vec4(c,1.);\n}","name":"Image","description":"","type":"image"}]}