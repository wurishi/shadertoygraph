{"ver":"0.1","info":{"id":"ts2BRR","date":"1589395931","viewed":1970,"name":"Animated 2D Perlin Noise","username":"dust","description":"An iteration on - https://www.shadertoy.com/view/MldfzB; seeing what I can get with minimal passes and animating by playing with the corner gradients instead of adding another dimension.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","noise","perlin","animated"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Specialty Perlin ease-in/out function\nvec2 soften(vec2 t)\n{\n    vec2 t3 = t * t * t;\n    vec2 t4 = t3 * t;\n    vec2 t5 = t4 * t;\n    return 6.0f * t5 - \n           15.0f * t4 +\n           10.0f * t3;\n}\n\n// Slow, high-quality 2D hash adapted from nimitz's\n// WebGL2 hash collection\n// (https://www.shadertoy.com/view/Xt3cDn)\nvec2 hash22(uvec2 p)\n{\n    const uint PRIME32_2 = 2246822519U, PRIME32_3 = 3266489917U;\n\tconst uint PRIME32_4 = 668265263U, PRIME32_5 = 374761393U;\n    uint h32 = p.y + PRIME32_5 + p.x*PRIME32_3;\n    h32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17))); //Initial testing suggests this line could be omitted for extra perf\n    h32 = PRIME32_2*(h32^(h32 >> 15));\n    h32 = PRIME32_3*(h32^(h32 >> 13));\n    h32 = h32^(h32 >> 16);\n    uvec2 rz = uvec2(h32, h32*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU)) / float(0x7fffffff);\n}\n\n// Perlin noise function, taking corner + pixel positions as input\nfloat Perlin(vec2 uv, vec2 fragCoord)\n{\n    // Find corner coordinates\n    vec4 lwrUpr = vec4(floor(uv), ceil(uv)); \n    mat4x2 crnrs = mat4x2(lwrUpr.xw, lwrUpr.zw,\n                          lwrUpr.xy, lwrUpr.zy);\n    \n    // Generate gradients at each corner\n    vec2 mUV = iMouse.zw / iResolution.xy;\n    vec2 scTime = abs(vec2(sin(iTime) + mUV.x, cos(iTime) + mUV.y)) + vec2(0.75);\n    mat4x2 dirs = mat4x2(hash22(uvec2(floatBitsToUint(crnrs[0]))) * scTime,\n                         hash22(uvec2(floatBitsToUint(crnrs[1]))) * scTime,\n                         hash22(uvec2(floatBitsToUint(crnrs[2]))) * scTime,\n                         hash22(uvec2(floatBitsToUint(crnrs[3]))) * scTime);\n    \n    // Shift gradients into [-1...0...1]\n    dirs *= 2.0f;\n    dirs -= mat4x2(vec2(1.0f), vec2(1.0f), \n                   vec2(1.0f), vec2(1.0f));\n    \n    // Normalize\n    dirs[0] = normalize(dirs[0]);\n    dirs[1] = normalize(dirs[1]);\n    dirs[2] = normalize(dirs[2]);\n    dirs[3] = normalize(dirs[3]);\n    \n    // Find per-cell pixel offset\n    vec2 offs = mod(uv, 1.0f);\n    \n    // Compute gradient weights for each corner; take each offset relative\n    // to corners on the square in-line\n    vec4 values = vec4(dot(dirs[0], (offs - vec2(0.0f, 1.0f))),\n                       dot(dirs[1], (offs - vec2(1.0f))),\n                       dot(dirs[2], (offs - vec2(0.0f))),\n                       dot(dirs[3], (offs - vec2(1.0f, 0.0f))));\n    \n    // Return smoothly interpolated values\n    vec2 softXY = soften(offs);\n    return mix(mix(values.z, \n                   values.w, softXY.x),\n               mix(values.x, \n                   values.y, softXY.x),\n               softXY.y);\n}\n\n#define GEOM_NOISE\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to [1.0 / [cellSize]])\n    const float cellSize = 0.0825f;\n    vec2 uv = vec2(fragCoord / iResolution.y);\n    uv = uv / cellSize;\n            \n    // Generate fractional noise\n    float f = 0.0f;\n    float ampl = 1.87f; // Output noise intensity\n    for (int i = 0; i < 2; i += 1)\n    {\n        float p = Perlin(uv/* + texture(iChannel0, uv).rg*/, fragCoord);\n    \tf = ampl * p * (1.0f - abs(p));\n        #ifdef GEOM_NOISE\n        \tuv = uv * p;\n        #endif\n    }\n    \n    // Output to screen\n    fragColor = vec4(vec3(f), 1.0);\n}","name":"Image","description":"","type":"image"}]}