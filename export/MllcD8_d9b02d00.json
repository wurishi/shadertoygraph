{"ver":"0.1","info":{"id":"MllcD8","date":"1512776029","viewed":664,"name":"sRGB Gamma Test Image","username":"Tynach","description":"Generates an image for testing how close to the sRGB standard your monitor's gamma ramp (transfer characteristics) is.\n\n2018-06-07: New macro generates slope&cutoffs from power and offset; good for high bit depths.\n2018-10-03: Added L* (perceptual) trc.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","test","gamma","srgb","transfer","trc","transfercharacteristics","gammaramp","gammacurve","characteristics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/****************************************************************************\n * Generates patterns that can be used to test the transfer characteristics *\n * of displays against various standards                                    *\n ****************************************************************************/\n\nprecision highp float;\n\n\n// Parameters for transfer characteristics (gamma curves)\nstruct transfer {\n\t// Exponent used to linearize the signal\n\tfloat power;\n\n\t// Offset from 0.0 for the exponential curve\n\tfloat off;\n\n\t// Slope of linear segment near 0\n\tfloat slope;\n\n\t// Values below this are divided by slope during linearization\n\tfloat cutoffToLinear;\n\n\t// Values below this are multiplied by slope during gamma correction\n\tfloat cutoffToGamma;\n};\n\n// Parameters for a BT.1886 electro-optical transfer function\nstruct bt1886 {\n\t// Contrast ratio\n\tfloat cRatio;\n\n\t// Offset applied before gamma\n\tfloat gamOffset;\n\n\t// Multiplier applied before division but after gamma\n\tfloat coeff;\n};\n\n// Automatically calculate the slope and cutoffs for transfer characteristics\n#define Transfer(po, of)\\\ntransfer(\\\n\t(po),\\\n\t(of),\\\n\t(pow((po)*(of)/((po) - 1.0), 1.0 - (po))*pow(1.0 + (of), (po)))/(po),\\\n\t(of)/((po) - 1.0),\\\n\t(of)/((po) - 1.0)*(po)/(pow((po)*(of)/((po) - 1.0), 1.0 - (po))*pow(1.0 + (of), (po)))\\\n)\n\n// BT.1886 defines its functions using a black luminosity level, and a white\n// luminosity level. However, in the range of 0 to 1, there's no difference\n// between input values of the same ratio to each other. As long as the contrast\n// ratio (white/black) remains the same, the output function does too\n#define Bt1886(black, white)\\\nbt1886(\\\n\t(white)/(black),\\\n\t1.0/(pow((white)/(black), 1.0/2.4) - 1.0),\\\n\tpow(pow((white)/(black), 1.0/2.4) - 1.0, 2.4)\\\n)\n\n\n/*\n * Gamma curve parameters\n */\n\n// Linear gamma\nconst transfer gam10 = transfer(1.0, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 1.8; not linear near 0. This is what older Apple devices used\nconst transfer gam18 = transfer(1.8, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.2; not linear near 0. Was defined abstractly to be used by early\n// NTSC systems, before SMPTE 170M was modified to specify a more exact curve.\n// Also what Adobe RGB uses\nconst transfer gam22 = transfer(2.2, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.4; not linear near 0. Used as the gamma value for BT.1886\nconst transfer gam24 = transfer(2.4, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.5; not linear near 0. Approximately what old Sony TVs used\nconst transfer gam25 = transfer(2.5, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.8; not linear near 0. Loosely defined gamma for European SDTV\nconst transfer gam28 = transfer(2.8, 0.0, 1.0, 0.0, 0.0);\n\n// Modern SMPTE 170M, as well as Rec. 601, Rec. 709, and a rough approximation\n// for Rec. 2020 content as well. Do not use with Rec. 2020 if you work with\n// high bit depths!\nconst transfer gam170m = transfer(1.0/0.45, 0.099, 4.5, 0.0812, 0.018);\n\n// Proper Rec. 2020 gamma, made using the new Transfer macro\nconst transfer gam2020 = Transfer(1.0/0.45, 0.099);\n\n// Gamma for sRGB\nconst transfer gamSrgb = transfer(2.4, 0.055, 12.92, 0.04045, 0.0031308);\n\n// A more continuous version of sRGB, for high bit depths\nconst transfer gamSrgbHigh = Transfer(2.4, 0.055);\n\n// Gamma for the CIE L*a*b* Lightness scale\nconst transfer gamLab = transfer(3.0, 0.16, 243.89/27.0, 0.08, 216.0/24389.0);\n\n// Gamma for a BT.1886 compliant monitor with a 1000:1 contrast ratio\nconst bt1886 gamThou = Bt1886(1.0, 1000.0);\n\n\n// Converts RGB colors to a linear light scale\nvoid toLinear(inout vec4 color, const transfer trc)\n{\n\tbvec4 cutoff = lessThan(color, vec4(trc.cutoffToLinear));\n\tbvec4 negCutoff = lessThanEqual(color, vec4(-1.0*trc.cutoffToLinear));\n\tvec4 higher = pow((color + trc.off)/(1.0 + trc.off), vec4(trc.power));\n\tvec4 lower = color/trc.slope;\n\tvec4 neg = -1.0*pow((color - trc.off)/(-1.0 - trc.off), vec4(trc.power));\n\n\tcolor = mix(higher, lower, cutoff);\n\tcolor = mix(color, neg, negCutoff);\n}\n\nvoid toLinear1886(inout vec4 color, const bt1886 trc)\n{\n\tcolor = (trc.coeff*pow(color + trc.gamOffset, vec4(2.4)) - 1.0)/(trc.cRatio - 1.0);\n}\n\n// Gamma-corrects RGB colors to be sent to a display\nvoid toGamma(inout vec4 color, const transfer trc)\n{\n\tbvec4 cutoff = lessThan(color, vec4(trc.cutoffToGamma));\n\tbvec4 negCutoff = lessThanEqual(color, vec4(-1.0*trc.cutoffToGamma));\n\tvec4 higher = (1.0 + trc.off)*pow(color, vec4(1.0/trc.power)) - trc.off;\n\tvec4 lower = color*trc.slope;\n\tvec4 neg = (-1.0 - trc.off)*pow(-1.0*color, vec4(1.0/trc.power)) + trc.off;\n\n\tcolor = mix(higher, lower, cutoff);\n\tcolor = mix(color, neg, negCutoff);\n}\n\nvoid toGamma1886(inout vec4 color, const bt1886 trc)\n{\n\tcolor = pow((color*(trc.cRatio - 1.0) + 1.0)/trc.coeff, vec4(1.0/2.4)) - trc.gamOffset;\n}\n\nvoid mainImage(out vec4 color, in vec2 fragCoord)\n{\n\t// Sets the current display's transfer characteristics\n\tconst transfer disp = gamSrgb;\n\n\t// Use sRGB's gradient for all tests; makes comparisons consistent\n\tconst transfer grad = gamSrgb;\n\n\t// Determine which 'slice' of the output is active\n\tint segment = int(fragCoord.x * 13.0/iResolution.x);\n\n\t// Background/smooth gradient; represents how a particular part should look\n\tcolor = vec4(vec3(fragCoord.y/iResolution.y), 1);\n\n\t// Convert to display gamma, clamp to whole values, then linearize them\n\ttoLinear(color, grad);\n\ttoGamma(color, disp);\n\tcolor.rgb = floor(color.rgb*256.0)/255.0;\n\ttoLinear(color, disp);\n\n\t// Low and high regions require different formulas so bright values don't go\n\t// over 100%, and dark values don't go below 0%\n\tbvec4 grad_half = lessThan(color, vec4(0.5));\n\tvec4 gray_high = mix(vec4(1), color * 2.0, grad_half);\n\tvec4 gray_low = color - (gray_high - color);\n\n\t// Determine which formula to use depending on whether the current pixel is\n\t// 'high' or 'low'. Also creates a 'checkerboard' pattern\n\tivec2 intCoord = ivec2(fragCoord.xy);\n\tvec4 gray = mix(gray_high, gray_low, bvec4((intCoord.x + intCoord.y) % 2));\n\n\t// Red channel test pattern\n\tvec4 red = gray;\n\tred.gb = color.gb;\n\n\t// Green channel test pattern\n\tvec4 green = gray;\n\tgreen.rb = color.rb;\n\n\t// Blue channel test pattern\n\tvec4 blue = gray;\n\tblue.rg = color.rg;\n\n\t// Display a different test pattern based on the calculated segment\n\tcolor = mix(red, color, bvec4((segment - 1) * (segment - 2)));\n\tcolor = mix(green, color, bvec4((segment - 4) * (segment - 5)));\n\tcolor = mix(blue, color, bvec4((segment - 7) * (segment - 8)));\n\tcolor = mix(gray, color, bvec4((segment - 10) * (segment - 11)));\n\n\t// Gamma-compress the values\n\ttoGamma(color, disp);\n\n\t// Set alpha to 1\n\tcolor.a = 1.0;\n}","name":"Image","description":"","type":"image"}]}