{"ver":"0.1","info":{"id":"tl2GD3","date":"1561480327","viewed":1124,"name":"Segment Light","username":"redorav","description":"This is a Segment Light (or Line Light but the name was taken) shader","likes":22,"published":1,"flags":32,"usePreview":0,"tags":["line","light","area","mrp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Implementation of http://www.elopezr.com/rendering-line-lights/\n\n// Make light color scroll. Looks awful but shows technique\n//#define SCROLL_LIGHT_COLOR\n\n// Use cubemap as color input\n//#define CUBEMAP_COLOR\n\n//#define ANALYTICAL\n\nconst float pi = 3.14159265359;\n\nstruct Camera\n{\n    vec3 position;\n    vec3 incident;\n};\n    \nstruct Surface\n{\n\tvec3 position;\n    vec3 normal;\n    vec3 albedo;\n    vec3 reflection;\n    float roughness;\n    float metalness;\n};\n\nstruct SegmentLight\n{\n    vec3 colorBegin;\n    vec3 colorEnd;\n    float intensity;\n    vec3 segmentBegin;\n\tvec3 segmentEnd;\n    \n    mat3 rotationMtx;\n    mat3 invRotationMtx;\n};\n\n// Old hlsl habits die hard\nfloat saturate(float x)\n{\n    return clamp(x, 0.0, 1.0);\n}\n\nbool IntersectPlane(Camera camera, out vec3 hit)\n{\n    vec3 planeNormal = vec3(0, 1, 0);\n    \n    float d = dot(camera.position, planeNormal) / -dot(camera.incident, planeNormal); // Analytical flat plane    \n    hit = camera.position + camera.incident * d;\n    return d >= 0.0;\n}\n\n// Get Most Representative Point for the diffuse part of a line light\nvec3 GetMRPDiffuse(vec3 P, vec3 A, vec3 B, out float t)\n{\n\tvec3 PA = A - P, PB = B - P, AB = B - A;\n\tfloat a = length(PA), b = length(PB);\n    t = saturate(a / (b + a));\n\treturn A + AB * t;\n}\n\n// Get Most Representative Point for the specular part of a line light\nvec3 GetMRPSpecular(vec3 P, vec3 A, vec3 B, vec3 R, out float t)\n{\n\tvec3 PA = A - P;\n\tvec3 PB = B - P;\n\tvec3 AB = B - A;\n\n    // If R is normalized, dot(R, R) = 1 and can be optimized away.\n    // After that dot(AB, P) - dot(AB, A) == dot(AB, P - A) and we can group terms\n\tfloat t_num = dot(R, A) * dot(AB, R) + dot(AB, P) * dot(R, R) - dot(R, P) * dot(AB, R) - dot(AB, A) * dot(R, R);\n    float t_denom = dot(AB, AB) * dot(R, R) - dot(AB, R) * dot(AB, R);\n\tt = saturate(t_num / t_denom);\n\n\treturn A + AB * t;\n}\n\nvec3 GetMRPSpecularOptimized(vec3 P, vec3 A, vec3 B, vec3 R, out float t)\n{\n\tvec3 PA = A - P;\n\tvec3 PB = B - P;\n\tvec3 AB = B - A;\n\n\tfloat t_num = dot(R, PA) * dot(R, AB) - dot(AB, PA);\n    float t_denom = dot(AB, AB) - dot(AB, R) * dot(AB, R);\n\tt = saturate(t_num / t_denom);\n\n\treturn A + AB * t;\n}\n\nvec3 ClosestPointOnSegment(vec3 A, vec3 B, vec3 P)\n{\n    vec3 AB = B - A;\n    float t = dot(P - A, AB) / dot(AB, AB);\n    return A + saturate(t) * AB;\n}\n\n// Compute standard point light falloff\nfloat ComputeFalloff(vec3 position, vec3 lightPosition)\n{\n    float d = distance(position, lightPosition);    \n    return 1.0 / (d * d);\n}\n\n// Illuminate a surface given a line light\nvec3 LightSurfaceSegmentLight(Camera camera, Surface surface, SegmentLight light)\n{\n    vec3 litSurface = vec3(0.0);    \n    vec3 finalLightColor = vec3(0.0);\n    \n   \tvec3 A = light.segmentBegin;\n   \tvec3 B = light.segmentEnd;\n    vec3 P = surface.position;\n    \n#if defined(ANALYTICAL)\n\n    float numSamples = 32.0;\n    vec3 delta = (B - A) / numSamples;\n\n    for(float i = 0.0; i < numSamples; ++i)\n    {\n        float t = i / numSamples;\n        vec3 pointOnLight = A + delta * i;\n        vec3 lightVector = normalize(pointOnLight - P);\n        float NdotL = saturate(dot(surface.normal, lightVector));\n        float falloff = ComputeFalloff(surface.position, pointOnLight);\n        finalLightColor = mix(light.colorBegin, light.colorEnd, t) / numSamples;\n        \n        // Diffuse\n        {\n            // Why no pi?\n            vec3 diffuse = (surface.albedo) * finalLightColor * light.intensity * falloff * NdotL;\n            litSurface += diffuse;\n        }\n    \n        // Specular\n        {\n            vec3 H = normalize(-camera.incident + lightVector);        \n            float NdotH = saturate(dot(surface.normal, H));\n\n            // Standard unnormalized Blinn-Phong specular BRDF. Replace with whatever you like\n            vec3 specular = 100.0 * vec3(pow(NdotH, pow(1000.0, 1.0 - surface.roughness))) * finalLightColor * light.intensity * falloff * vec3(NdotL);\n            litSurface += specular;\n        }\n    }\n\n#else\n    \n#if defined(CUBEMAP_COLOR)\n    \n    vec3 samplingVector = P - (A + B) / 2.0;\n    light.colorBegin = light.colorEnd = texture(iChannel2, samplingVector * light.invRotationMtx).rgb;\n    \n#endif\n    \n    // Horizon Handling\n    {\n        vec3 N = surface.normal;\n\n        vec3 PA = A - P;\n        vec3 PB = B - P;\n        vec3 AB = B - A;\n        \n        // If points are on opposite sides, guaranteed intersection\n        if(dot(PA, N) > 0.0 != dot(PB, N) > 0.0)\n        {\n            float t = -dot(PA, N) / dot(AB, N);\n            vec3 intersectionPoint = A + t * AB;\n            if (dot(PA, N) > 0.0)\n            {\n                B = intersectionPoint;\n            }\n            else\n            {\n\t\t\t\tA = intersectionPoint;\n            }\n        }\n    }\n    \n    // Diffuse evaluation\n    {\n        float t = 0.0;\n        vec3 diffuseMRP = GetMRPDiffuse(surface.position, A, B, t);\n\n#if defined(CUBEMAP_COLOR)\n        float s = 0.5;\n        vec3 closestPoint = ClosestPointOnSegment(A, B, P);\n        vec3 lerpedPoint = mix((A + B) / 2.0, closestPoint, saturate(s));\n        vec3 samplingVector = P - lerpedPoint;\n        light.colorBegin = light.colorEnd = texture(iChannel2, samplingVector * light.invRotationMtx).rgb;\n#endif\n\n        #if defined(SCROLL_LIGHT_COLOR)\n        finalLightColor = texture(iChannel1, (vec2(t + iTime, 0.0))).rgb;\n        #else\n        finalLightColor = mix(light.colorBegin, light.colorEnd, t);\n        #endif\n        \n        vec3 lightVector = diffuseMRP - surface.position;\n        lightVector = normalize(lightVector);\n        \n        float NdotL = saturate(dot(surface.normal, lightVector));\n        \n        float falloff = ComputeFalloff(surface.position, diffuseMRP);\n        \n        // Standard Lambert diffuse BRDF. Replace with whatever you like\n        litSurface += (surface.albedo / pi) * finalLightColor * light.intensity * falloff * NdotL;\n    }\n    \n    // Specular evaluation\n    {\n        float t = 0.0;\n        vec3 specularMRP = GetMRPSpecularOptimized(surface.position, A, B, surface.reflection, t);\n        \n        vec3 lightVector = specularMRP - surface.position;\n        lightVector = normalize(lightVector);\n        \n        float NdotL = saturate(dot(surface.normal, lightVector));\n        \n        vec3 H = normalize(-camera.incident + lightVector);\n        \n        float NdotH = saturate(dot(surface.normal, H));\n        \n        float falloff = ComputeFalloff(surface.position, specularMRP);\n        \n        // Standard unnormalized Blinn-Phong specular BRDF. Replace with whatever you like\n        litSurface += vec3(pow(NdotH, pow(1000.0, 1.0 - surface.roughness))) * finalLightColor * light.intensity * falloff * NdotL;\n    }\n    \n#endif\n    \n    return litSurface;\n}\n\n// Create a camera with the given parameters\nCamera BuildCamera(vec3 cameraPosition, vec3 lookAtPoint, vec2 screenUV, float aspectRatio)\n{\n    vec2 ndc = screenUV * 2.0 - 1.0;\n    ndc.x *= aspectRatio;\n    \n    float zoom = 3.0;\n    \n    vec3 worldUp = vec3(0.0, 1.0, 0.0);\n    \n    vec3 forward = normalize(lookAtPoint - cameraPosition);\n    vec3 right   = normalize(cross(worldUp, forward));\n    vec3 up      = normalize(cross(forward, right));\n    \n    vec3 c = cameraPosition + forward * zoom;\n    vec3 i = c + ndc.x * right + ndc.y * up;\n    \n    Camera camera;    \n    camera.position = cameraPosition;\n    camera.incident = normalize(i - cameraPosition);\n    \n    return camera;\n}\n\n// http://mathworld.wolfram.com/EulerAngles.html\nmat3 Get3DRotationMatrix(float x, float y, float z)\n{\n    mat3 rot;\n    \n    mat3 rotX = mat3\n    (\n        1.0, 0.0, 0.0,\n        0.0, cos(x), -sin(x),\n        0.0, sin(x), cos(x)\n    );\n    \n    mat3 rotY = mat3\n    (\n        cos(y), 0.0, sin(y),\n        0.0, 1.0, 0.0,\n        -sin(y), 0.0, cos(y)\n    );\n    \n    mat3 rotZ = mat3\n    (\n        cos(z), -sin(z), 0.0,\n        sin(z), cos(z), 0.0,\n        0.0, 0.0, 1.0\n    );\n    \n    rot = rotX * rotY * rotZ;\n    \n    return rot;\n}\n\n// Calculates a normal from a heightfield\nvec3 GetNormalFromHeightmap(vec2 uv)\n{\n    vec2 pixelSize = vec2(1.0) / iChannelResolution[0].xy;\n    \n    float height0 = texture(iChannel0, fract(uv.xy) + vec2(0.0        , 0.0)).x;\n    float height1 = texture(iChannel0, fract(uv.xy) + vec2(pixelSize.x, 0.0)).x;\n    float height2 = texture(iChannel0, fract(uv.xy) + vec2(0.0        , pixelSize.y)).x;\n    \n    vec3 p0 = vec3(0.0, height0, 0.0);\n    vec3 p1 = vec3(0.1, height1, 0.0);\n    vec3 p2 = vec3(0.0, height2, 0.1);\n\n    vec3 v0 = normalize(p1 - p0);\n    vec3 v1 = normalize(p2 - p0);\n    \n    vec3 normal = normalize(cross(v1, v0));\n    \n    return normal;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 screenUV = fragCoord / iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    float t = iTime;\n    \n    // 1. Create a camera\n    vec3 cameraPosition = vec3(6.0 + sin(0.0 * 0.5), 8.0, -6.0);\n    \n    Camera camera = BuildCamera(cameraPosition, vec3(0.0), screenUV, aspectRatio);\n    \n    // 2. Create the segment light\n    SegmentLight light;\n    light.colorBegin = texture(iChannel1, vec2(0.0)).rgb;\n    light.colorEnd = texture(iChannel1, vec2(0.5)).rgb;\n    //light.colorBegin = vec3(1.0);\n    //light.colorEnd = vec3(1.0);\n    light.intensity = 1.7;\n    \n    float lightLength = 7.0 / 2.0;\n    light.segmentBegin = vec3(-lightLength, 0.0, 0.0);\n    light.segmentEnd = vec3(lightLength, 0.0, 0.0);\n    \n    light.rotationMtx = Get3DRotationMatrix(0.0, t, 0.0);\n    light.invRotationMtx = transpose(light.rotationMtx);\n    \n    light.segmentBegin *= light.rotationMtx;\n    light.segmentEnd *= light.rotationMtx;\n    \n    light.segmentBegin += vec3(0.0, 0.8, 0.0);\n    light.segmentEnd += vec3(0.0, 0.8, 0.0);\n\n    // 3. Find intersection with plane\n    vec3 hit;\n    bool intersectedPlane = IntersectPlane(camera, hit);\n    \n    vec3 normal = GetNormalFromHeightmap(hit.xz * 0.5);\n    \n    // 4. Create the surface\n    Surface surface;    \n    surface.normal = normalize(normal);\n    surface.albedo = vec3(1.0, 1.0, 1.0);\n    surface.roughness = 0.0;\n    surface.reflection = reflect(-camera.incident, surface.normal);\n    surface.position = hit;    \n    \n\tif (intersectedPlane)\n    {\n        fragColor.rgb = LightSurfaceSegmentLight(camera, surface, light);\n    }\n    else\n    {\n        fragColor.rgb = vec3(0);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 screenUV = fragCoord / iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n    \n    vec3 lightColorBegin = vec3(255, 200, 100) / 255.0;\n    vec3 lightColorEnd   = vec3(255, 100, 150) / 255.0;\n    \n    float xCoord = screenUV.x * 2.0;\n    \n    xCoord = xCoord > 1.0 ? 2.0 - xCoord : xCoord;\n    \n    vec3 finalColor = mix(lightColorBegin, lightColorEnd, xCoord);\n    \n    fragColor = vec4(finalColor, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}