{"ver":"0.1","info":{"id":"Xsc3DX","date":"1452373094","viewed":389,"name":"CA Explorer","username":"stb","description":"Discrete, totalistic 2D cellular automata using the Moore neighborhood. Supports multiple cell states (2 & above). Features an editor for finding new and interesting rules :)","likes":11,"published":1,"flags":48,"usePreview":0,"tags":["2d","game","automata","life","cellular","ca","of","totalistic","moore","automaton","rule"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"/*\n\tCA Explorer\n\t2016-2020 stb\n\n\tControls:\n\t\tMOUSE .... highlight CA rule value\n\t\t1 ........ decrement highlighted rule value\n\t\t2 ........ increment highlighted rule value\n\t\tR ........ randomize all rule values\n\t\tDELETE ... clear all rule values to 0\n\t\tC ........ clear field with random values\n\t\tMINUS .... decrement number of cell states\n\t\tEQUALS ... increment number of cell states\n\t\tTAB ...... toggle CA rule editor\n\t\tLBRACKET . scale rule editor down\n\t\tRBRACKET . scale rule editor up\n\n\tEach row in the rule editor corresponds to the current cell state, starting at 0 (top).\n\tThe values in each row (starting at 0) indicate what happens to the cell after neighboring cells are added up.\n\tTake this, for instance:\n\n\t0 0 0 1 0 0 0 0 0\n\t0 0 1 1 0 0 0 0 0\n\n\tWe see that if a cell's state is 0 and the neighborhood total equals 3, the cell's state changes to 1.\n\tAnd if a cell's state is 1, and the total is <2 or >3, the cell changes to 0.\n\tSo the above is the rule for Conway's Game of Life!\n\n\tTry experimenting with higher cells states. Anything above 2 states is largely unexplored territory :)\n\n\t~~~\n\n\tUpdate: Can once again increment/decrement cell states, thanks to AntoineC's \"Utils - Keyboard codes\" shader (https://www.shadertoy.com/view/WsKGDV).\n    Update 2: fixed long key press\n\n*/\n\nconst float KEY_TAB = 9.5 / 256.;\n\n// build a glyph from a decimal value\nfloat glyph4x5(in vec2 p, float d) {\n\tp = 6. * p - vec2(1., 0.);\n    float g = float(1. < floor(mod(d*pow(2., -(floor(p.x)+floor(p.y)*4.-1.)), 4.)));\n    return g * float(p.x>=0. && p.x<4.);\n}\n\n// number chart 0-9\nfloat numStrip4x5(in vec2 p) {\n    float num4x5[10];\n\tnum4x5[0] = 432534.; num4x5[1] = 287822.; num4x5[2] = 431151.; num4x5[3] = 493191.; num4x5[4] = 696200.;\n    num4x5[5] = 989063.; num4x5[6] = 923542.; num4x5[7] = 1016865.; num4x5[8] = 431766.; num4x5[9] = 433798.;\n    float f = 0.;\n    p = mod(p, vec2(1., 10.));\n    for(int i=9; i>=0; i--)\n        if(p.y<1.+float(i))\n        \tf = glyph4x5(p-vec2(0., float(i)), num4x5[i]);\n    return f;\n}\n\n// display a number (tiled)\nfloat showNum(vec2 p, float n) {\n    return numStrip4x5(vec2(p.x, fract(p.y))+vec2(0., n));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 res = iResolution.xy;\n\tvec2 uv  = fragCoord / res;\n    \n    // get settings from Buf A\n    float numStates   = texture(iChannel0, vec2(0.5/res.x, 0.)).b;\n    float editorScale = texture(iChannel0, vec2(1.5/res.x, 0.)).b;\n    \n    vec2 mPos   = iMouse.xy / editorScale / 6.;\n    vec2 uvEdit = fragCoord / editorScale / 6.;\n\t\n    float F = 0., R, G;\n    \n    // display rule editor\n    if(uvEdit.x<(numStates-1.)*8.+1. && uvEdit.y<numStates && texture(iChannel3, vec2(KEY_TAB, 2./3.)).r==0.) {\n        F = showNum(uvEdit, texture(iChannel0, uvEdit/res).g);\n    \tR = float(floor(uvEdit)==floor(mPos));\n    }\n    else\n        F = texture(iChannel0, uv).r/(numStates-1.);\n    \n    // for locating hard-to-find keys\n    //F = texture(iChannel3, vec2(fragCoord.x/256., uv.y)).r;\n    \n    fragColor = vec4(vec3(F)+vec3(R, 0., 0.), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float NoisePow    = 28.; // higher values = more black\n\n// key defs\nconst float KEY_1 = 49.5 / 256.;\nconst float KEY_2 = 50.5 / 256.;\nconst float KEY_C = 67.5 / 256.;\nconst float KEY_R = 82.5 / 256.;\nconst float KEY_DEL    = 46.5 / 256.;\nconst float KEY_MINUS  = 189.5 / 256.;\nconst float KEY_EQUALS = 187.5 / 256.;\nconst float KEY_LBRACKET = 219.5 / 256.;\nconst float KEY_RBRACKET = 221.5 / 256.;\n\n\n// hash without sine\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p) {\n    vec3 MOD3 = vec3(443.8975, 397.2973, 491.1871);\n    vec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nbool isKeyPressed(float KEY_) {\n    return (texture(iChannel3, vec2(KEY_, .5)).r>0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 res  = iResolution.xy;\n    vec2 uv   = fragCoord.xy / res;\n    float total = 0., cellState, numStates, editorScale, R, G, B = 0.;\n    \n    bool doRand = false;\n    \n    // a couple defaults\n    if(iFrame==0) {\n    \tnumStates = 2.;\n        editorScale = 3.;\n        doRand = true;\n        // set initial rule to be the Game of Life\n        G = float(floor(fragCoord)==vec2(3., 1.) || floor(fragCoord)==vec2(2., 0.) || floor(fragCoord)==vec2(3., 0.));\n    }\n    else {\n        numStates   = texture(iChannel0, vec2(0.5/res.x, 0.)).b;\n        editorScale = texture(iChannel0, vec2(1.5/res.x, 0.)).b;\n        G = texture(iChannel0, uv).g;\n    }\n    \n    vec2 mPos = iMouse.xy / editorScale / 6.;\n    \n    // get total value from neighbors\n    for(float y=-1.; y<=1.; y++)\n        for(float x=-1.; x<=1.; x++)\n    \t\tif(!(x==0.&&y==0.)) total += texture(iChannel0, fract(uv-vec2(x, y)/res)).r;\n    \n\t// initial cell state\n\tcellState = texture(iChannel0, uv).r;\n    \n\t// determine new cell state from CA rule\n\tif(total<1.+8.*(numStates-1.))\n        cellState = texture(iChannel0, (.5+vec2(total, numStates-cellState-1.))/res).g;\n    R = cellState;\n    \n    bool isEditingDown = isKeyPressed(KEY_1);\n    bool isEditingUp   = isKeyPressed(KEY_2);\n    if(isEditingDown || isEditingUp) doRand = true;\n    \n    if(floor(fragCoord)==floor(mPos) && mPos.x<(numStates-1.)*8.+1. && mPos.y<numStates) {\n        // decrement rule value\n        if(isEditingDown)\n            G = max(G-1., 0.);\n        // increment rule value\n        if(isEditingUp)\n            G = min(G+1., numStates-1.);\n        \n    }\n    // randomize rule\n    if(isKeyPressed(KEY_R)) {\n\t\tG = floor(hash12(mod(uv+iTime/100., 100.))*numStates);\n        doRand = true;\n    }\n    if(isKeyPressed(KEY_DEL)) {\n        G = 0.;\n        doRand = true;\n    }\n    \n    // decrement number of states\n    if(isKeyPressed(KEY_MINUS)) {\n        numStates = max(2., numStates-1.);\n        G = 0.;\n        doRand = true;\n    }\n    // increment number of states\n    if(isKeyPressed(KEY_EQUALS)) {\n        numStates++;\n        G = 0.;\n        doRand = true;\n    }\n    \n    if(isKeyPressed(KEY_LBRACKET))\n        editorScale = max(1., editorScale-1.);\n    if(isKeyPressed(KEY_RBRACKET))\n        editorScale++;\n    \n    // store NumStates\n    if(floor(fragCoord)==vec2(0.))\n        B = numStates;\n    else\n    // store EditorScale\n    if(floor(fragCoord)==vec2(1., 0.))\n        B = editorScale;\n    \n\t// fill buffer with noise\n\tif(doRand || isKeyPressed(KEY_C))\n        R = numStates * pow(hash12(mod(uv+iTime/100., 100.)), NoisePow);\n        \n    fragColor = vec4(R, G, B, 0.);\n}","name":"Buffer A","description":"","type":"buffer"}]}