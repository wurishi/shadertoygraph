{"ver":"0.1","info":{"id":"ft23RW","date":"1623471049","viewed":121,"name":"Over The Mountains","username":"andrew741","description":"Ray marching a mountain scene. The clouds were copied and pasted from another one of my projects \"Sea of Clouds\". I hope you enjoy the mountains, clouds, valleys, snow capped peaks, and alpine lakes!","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","clouds","sky","shadows","spheretracing","mountains","lakes","volumetrics","specularreflection","ridgelines"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PERSITION 0.0025\n#define MAX_DST 25.\n#define STEPS 250\n#define S(k) smoothstep(0., 1., k)\n\n\n// remaps a value\nfloat map(float val, float cMin, float cMax, float nMin, float nMax)\n{\n    // a basic remapping function\n    // remapping from 0 - any\n    float nVal = val - cMin;\n    // scaling from 0 - (new_max - new_min)\n    nVal *= (nMax - nMin) / (cMax - cMin);\n    // adding the new min\n    nVal += nMin;\n    // returning it\n    return nVal;\n}\n\n\n// a heighly random persudo random number generator that takes in a vec3 and returns a vec3\nvec3 random(vec3 co)\n{\n    // note that this code is from another user (on shadertoy)\n    vec3 p = co;\n    p = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n    vec3 output_ = fract(sin(p)*43758.5453123);\n\treturn output_;\n}\n\n\n// a smoothstep function\nfloat Smoothstep(float x)\n{\n    float k = clamp(x, 0., 1.);\n    return k * k * (3. - 2. * k);\n}\n\n\nfloat hash(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nfloat SampleNoise(vec2 uv)\n{\n    uv *= 8.0;\n    mat2 m_ = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*noise( uv ); uv = m_*uv;\n\tf += 0.2500*noise( uv ); uv = m_*uv;\n\tf += 0.1250*noise( uv ); uv = m_*uv;\n\tf += 0.0625*noise( uv ); uv = m_*uv;\n    return f;\n\n}\n\n\nstruct SpecularLight\n{\n    float highlight;\n    float diffuse;\n};\n\n\nSpecularLight Specular(float smoothness, vec3 normal, vec3 rd, vec3 sun_dir)\n{\n    float specularAngle = acos(dot(normalize(sun_dir - rd), normal));\n    float specularExponent = specularAngle / (1. - smoothness);\n    float specularHighlight = exp(-specularExponent * specularExponent);\n    float diffseLighting = clamp(dot(normal, sun_dir), 0., 1.);\n    return SpecularLight(specularHighlight, diffseLighting);\n}\n\n\n// from https://www.shadertoy.com/view/WtGXDD\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// from https://www.shadertoy.com/view/WtGXDD\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\nstruct Ray\n{\n    vec3 rd, ro, pos, normal;\n    vec4 color;\n    float depth;\n    bool collided;\n    int steps;\n};\n\n\n/*\nfloat distToCone(vec3 p, float rBase, float height)\n{\n\tfloat dst1 = length(p.xz) - ((-p.y + height / 2.) / height * rBase);\n    dst1 = abs(p.y) > height / 2. ? 200000. : dst1;\n    return dst1;\n}\n\n\nfloat distToCillander(vec3 p, float rBase, float height)\n{\n\tfloat dst1 = length(p.xz) - rBase;\n    dst1 = abs(p.y) > height / 2. ? 200000. : dst1;\n    return dst1;\n}\n\n\nfloat DstTree(vec3 p, float dstGround)\n{\n    vec3 np = p;\n    np.xz = fract(p.xz) - 0.5;\n    //np.y += 1.;\n    np.y += dstGround + 1.;\n    //p *= 2.;\n    // add random offset to p\n    float dstTrunk = distToCillander(np - vec3(0., 0.025, 0.), 0.0125, 0.15);\n    float dstLeaves = distToCone(np - vec3(0., 0.05, 0.), 0.05, 0.1525);\n    return min(dstTrunk, dstLeaves);\n}\n*/\n\n\nfloat GetDst(vec3 p)\n{\n    vec2 uv = p.xz * 0.05;\n    float n = SampleNoise(uv);\n    float dst1 = p.y + 1. - mix(-1. * abs(n), (n * 0.5 + 0.5) * 0.5, SampleNoise(uv + 1000.));\n    //float dst2 = 200.;//DstTree(p, dst1);\n    \n    //return min(dst1, dst2) * 0.7;\n    return dst1 * 0.7;\n}\n\n\nvec3 GroundCol(float y, vec2 uv)\n{\n    y = y * 20.;\n    vec3 col;\n    \n    if      (y < -33.) col = vec3(0.2, 0.8, 0.2) * texture(iChannel3, uv).x;\n    else if (y < -23.) col = mix(vec3(0.4, 0.4, 0.4) * (texture(iChannel1, uv).x + 0.3), vec3(0.2, 0.8, 0.2) * texture(iChannel3, uv).x, 1. - S(fract((y + 33.) / 10.)));\n    else if (y < -18.) col = mix(vec3(1., 1., 1.) * (texture(iChannel2, uv).x + 0.9), vec3(0.4, 0.4, 0.4) * (texture(iChannel1, uv).x + 0.3), 1. - S(fract((y + 23.) / 5.)));\n    else col = vec3(1., 1., 1.) * (texture(iChannel2, uv).x + 0.9);\n        \n    return col;\n}\n\n\nfloat GroundShine(float y)\n{\n    y = y * 20.;\n    float shine;\n    \n    if      (y < -33.) shine = 0.99;\n    else if (y < -23.) shine = mix(0.95, 0.99, 1. - S(fract((y + 33.) / 10.)));\n    else if (y < -18.) shine = mix(0.5, 0.95, 1. - S(fract((y + 23.) / 5.)));\n    else shine = 0.5;\n    \n    return shine;\n}\n\n\nvec4 GetCol(vec3 p)\n{\n    vec2 uv = p.xz * 0.05;\n    float n = SampleNoise(uv);\n    float dst1 = p.y + 1. - mix(-1. * abs(n), (n * 0.5 + 0.5) * 0.5, SampleNoise(uv + 1000.));\n    //float dst2 = 200.;//DstTree(p, dst1);\n    \n    //float dst = min(dst1, dst2);\n    float dst = dst1;\n    \n    if (dst == dst1) return vec4(GroundCol(p.y, p.xz), 0.);\n    //if (dst == dst2) return vec4(vec3(0.2, 0.8, 0.2), 0.);\n    return vec4(0., 0., 0., -1.);\n}\n\n\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDst(p);\n    vec2 e = vec2(0.0035, 0);\n    \n    vec3 normal = d - vec3(\n        GetDst(p - e.xyy),\n        GetDst(p - e.yxy),\n        GetDst(p - e.yyx));\n    \n    return normalize(normal);\n}\n\n\nRay CastRay(vec3 rd, vec3 ro)\n{\n    float dst;\n    vec3 p = ro;\n    float depth = 0.;\n    bool collided = false;\n    int steped = 0;\n    for (int s = 0; s < STEPS; s++)\n    {\n        dst = GetDst(p);\n        p += rd * dst;\n        depth += dst;\n        steped++;\n        \n        if (dst < PERSITION)\n        {\n            collided = true;\n            break;\n        }\n        else if (depth > MAX_DST) break;\n    }\n    \n    Ray ray = Ray(\n                     rd,\n                     ro,\n                     p,\n                     GetNormal(p),\n                     GetCol(p),\n                     depth,\n                     collided,\n                     steped\n                 );\n    return ray;\n}\n\n\nvec2 LoadTexture(vec2 p)\n{\n    p *= 250.;\n    vec2 fp = floor(p);\n    vec2 cp = ceil(p);\n    vec3 tl = random(vec3(fp.x, cp.y, 0.));\n    vec3 tr = random(vec3(cp.x, cp.y, 0.));\n    vec3 bl = random(vec3(fp.x, fp.y, 0.));\n    vec3 br = random(vec3(cp.x, fp.y, 0.));\n    float fx = S(fract(p.x));\n    vec3 X1 = mix(tl, tr, fx);\n    vec3 X2 = mix(bl, br, fx);\n    vec3 Y = mix(X2, X1, S(fract(p.y)));\n    return Y.xy * (2./3.) + Y.z * (1./3.);\n}\n\n\n// this noise method is from https://www.shadertoy.com/view/XslGRr\n#define NOISE_METHOD 1\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\n#if NOISE_METHOD==0\n    x = p + f;\n    return textureLod(iChannel2,(x+0.5)/32.0,0.0).x*2.0-1.0;\n#endif\n#if NOISE_METHOD==1\n\tvec2 uv = (p.xy+vec2(37.0,239.0)*p.z) + f.xy;\n    vec2 rg = LoadTexture((uv+0.5)/256.);\n\treturn mix( rg.x, rg.y, f.z )*2.0-1.0;\n#endif    \n#if NOISE_METHOD==2\n    ivec3 q = ivec3(p);\n\tivec2 uv = q.xy + ivec2(37,239)*q.z;\n\tvec2 rg = mix(mix(texelFetch(iChannel0,(uv           )&255,0),\n\t\t\t\t      texelFetch(iChannel0,(uv+ivec2(1,0))&255,0),f.x),\n\t\t\t\t  mix(texelFetch(iChannel0,(uv+ivec2(0,1))&255,0),\n\t\t\t\t      texelFetch(iChannel0,(uv+ivec2(1,1))&255,0),f.x),f.y).yx;\n\treturn mix( rg.x, rg.y, f.z )*2.0-1.0;\n#endif    \n}\n\n\nfloat Hash31(vec3 p)\n{\n    vec3 r = random(p);\n    return r.x * r.y * r.z;\n}\n\n\n// generates a noise texture (a height from 0 - 1 based on position)\nfloat OctaveWorly(vec3 fragCoord, int octaves, float scale, float persistance, float luclarity)\n{\n    // initializing veriables\n    float height = 0.;\n    float l = 1.;\n    float total = 0.;\n    // looping over all octaves\n    for (int o = 0; o < octaves; o++)\n    {\n        // getting the height for that octave and adding it\n        vec3 p = fragCoord + float(o * 500);\n        height += noise(fragCoord / scale);  // WorlyNoise(p, scale, o) * l;\n        // this is to remap the final height\n        total += l;  // the 0.95 is because the height of the bumps (when added up) is almost never equal to the max height and thefore the more octaves, the duller the color\n        // changing the height and scale based on inputed paramaters\n        l *= luclarity;\n        scale *= persistance;\n    }\n    // remaping the final height\n    height /= total;\n    // returning the height\n    height *= 0.2;\n    //height *= smoothstep(0., 0.05, noise(fragCoord / 200.));\n    //height = clamp(height, 0.01, 0.5);\n    //return floor(Hash31(floor((fragCoord - vec3(0, 120, 0)) / 240.)) + 0.85) * 0.05;\n    return height;\n}\n\n\n// returns a scaler for density so the clouds arnt just cut off at the bounds of the cloud container\nfloat GetHeightFalloff(float y, float cloud_height, float cloud_thickness)\n{\n    float ny = (y - cloud_height);\n    float dstTop = cloud_thickness - ny / (cloud_thickness / 50.);\n    float dstBot = ny / (cloud_thickness / 2.);\n    return S(clamp(min(dstBot, dstTop), 0., 1.));\n}\n\n\nvec3 RenderClouds(vec3 col, vec3 camera_pos, vec3 rd, vec3 sun_derection, vec3 sun_col)\n{\n    // some parameters that change the look of the clouds and performance\n    int steps = 90;\n    int sun_steps = 10;\n    float cloud_height = 10.;\n    float cloud_thickness = 100.;\n    bool in_cloud = false;\n    \n    // generating the distance to the cloud and the distance through the cloud\n    float dst_to_cloud, dst_through_cloud;\n    \n    float rd2 = 1. / rd.y;\n    // the cloud is above the player\n    if (camera_pos.y < cloud_height)\n    {\n        // checking if the cloud is in view\n        if (rd.y > 0.)\n        {\n            // finding the dist to the cloud and through the cloud\n            dst_to_cloud = (cloud_height - camera_pos.y) * rd2;\n            dst_through_cloud = cloud_thickness * rd2;\n            // the cloud is in view\n            in_cloud = true;\n        }\n    }\n    // the cloud is in the player\n    else if (camera_pos.y < cloud_height + cloud_thickness)\n    {\n        // checking if the ray's direction is above or bellow\n        dst_to_cloud = 0.;  // the distance to the cloud is 0 because your in the cloud\n        // ray's going up\n        if (rd.y > 0.)\n        {\n            // finding the dist through the cloud\n            dst_through_cloud = (cloud_thickness - (camera_pos.y - cloud_height)) * rd2;\n        }\n        // the ray is going downwards\n        else\n        {\n            // finding the dist through the cloud\n            dst_through_cloud = (camera_pos.y - cloud_height) * abs(rd2);\n        }\n        // the cloud is in view\n        in_cloud = true;\n    }\n    // the cloud is bellow the player\n    else\n    {\n        // checking if the cloud is in view\n        if (rd.y < 0.)\n        {\n            // finding the dist to and through the cloud\n            dst_to_cloud = ((camera_pos.y - cloud_height) - cloud_thickness) * abs(rd2);\n            dst_through_cloud = cloud_thickness * abs(rd2);\n            // the cloud is in view\n            in_cloud = true;\n        }\n    }\n    \n    if (in_cloud)\n    {\n        // finding the step size\n        float step_size = min(dst_through_cloud / float(steps), 5.);\n        vec3 point_step_size = rd * step_size;\n        \n        // initializing some veriables\n        float transmittion = 1.;\n        float lightEnergy = 0.;\n        \n        // some peramaters related to transparency of the cloud and brightness\n        float lightApsorbtionToSun = 0.235;\n        float lightApsorbtion = 0.165;\n        float lightPhase = map(clamp(pow(dot(sun_derection, rd), 7.5), 0., 1.), 0., 1., 0.21, 0.5);//0.21;\n        \n        // the color of the cloud\n        vec3 cloud_color = sun_col;  // vec3(1., 0.9, 0.85);\n\n        // the starting position\n        vec3 p = camera_pos + rd * dst_to_cloud;\n        \n        // initializing some veriables that are going to be used later\n        \n        float density, dst_to_sun_through_cloud, lightTransmittion, density_in_cloud, sun_step_size, density_sun, sun_trans;\n        vec3 point_sun_step_size, p2;\n        \n        // stepping through the cloud\n        for (int s = 0; s < steps; s++)\n        {\n            p2 = vec3(p.x, p.y, p.z);\n            \n            // finding the density at this point using worly noise\n            density = max(OctaveWorly(p, 3, 120., 0.6, 0.5), 0.) * step_size * GetHeightFalloff(p.y, cloud_height, cloud_thickness);\n\n            // checking if the current sample point is in a cloud (within the container of clouds)\n            if (density > 0.)\n            {\n                // sun is upwards\n                if (sun_derection.y > 0.)\n                {\n                    // finding the distance through the cloud going in ther direction of the sun\n                    dst_to_sun_through_cloud = (cloud_thickness - (p.y - cloud_height)) / sun_derection.y;\n                }\n                // sun is downwards\n                else\n                {\n                    // finding the distance through the cloud going in ther direction of the sun\n                    dst_to_sun_through_cloud = (p.y - cloud_height) / abs(sun_derection.y);\n                }\n                // finding the step size through the cloud going twords the sun\n                sun_step_size = dst_to_sun_through_cloud / float(sun_steps);\n                point_sun_step_size = sun_derection * sun_step_size;\n            \n                // resetting some veriables for lighting\n                density_in_cloud = 0.;\n                // stepping through the cloud twords the sun\n                for (int sun_step = 0; sun_step < sun_steps; sun_step++)\n                {\n                    // moving twords the sun\n                    p2 += point_sun_step_size;\n                    // finding the density at the current point\n                    density_sun = max(OctaveWorly(p2, 3, 120., 0.6, 0.5), 0.) * sun_step_size * GetHeightFalloff(p.y, cloud_height, cloud_thickness);\n                    // adding up the total density\n                    density_in_cloud += density_sun;\n                }\n                // finding how much light made it through at this current point\n                sun_trans = exp(-density_in_cloud * lightApsorbtionToSun);\n                \n                // changing the light\n                lightTransmittion = sun_trans;\n                lightEnergy += density * transmittion * lightTransmittion * lightPhase;\n                // altering the cloud coverage\n                transmittion *= exp(-density * lightApsorbtion);\n            }\n\n            // increases preformace with no visual change\n            if (transmittion < 0.01)\n            {\n                break;\n            }\n\n            // moving further through the cloud\n            p += point_step_size;\n        }\n        // finding the new color\n        col = col * transmittion + cloud_color * lightEnergy;\n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;  // * vec2(1., 0.62);\n    if (iMouse.z < 0. || iMouse.xy == vec2(0.)) m = vec2(0.65 + sin(iTime) * 0.1, 0.9 + cos(iTime) * 0.1);\n    m.y /= 2. - 0.2;\n    vec3 col = vec3(0.);\n    \n    vec3 sun_dir = normalize(vec3(sin(iTime), 0.5, cos(iTime)));\n    vec3 sun_col = vec3(1., 0.95, 0.9);\n    \n    // from https://www.shadertoy.com/view/WtGXDD (getting ro and rd)\n    vec3 ro = vec3(0, 8, -8) * 0.1;\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    vec3 rd = GetRayDir(uv, ro, vec3(0., 0., 0.), 1.);\n    \n    ro = ro + vec3(-iTime - (sin(iTime) * 0.5 + 0.5), 0., -iTime * 0.5 - (cos(iTime) * 0.25 + 0.75));\n    //ro.y = -0.8;\n    ro.y = max(-GetDst(vec3(ro.x, 0., ro.z)), -1.5);\n    Ray ray = CastRay(rd, ro);\n    if (ray.collided)\n    {\n        float cloud_shadow = clamp((OctaveWorly(vec3(ray.pos.xz - iTime / 3., 0.) * 120., 3, 120., 0.6, 0.5) * 0.5 + 0.5) * 2.5 - 0.5, 0.5, 1.);\n        vec3 object_col = ray.color.rgb;\n        object_col *= dot(sun_dir, ray.normal) * 0.5 + 0.5;\n        object_col *= min(1. / (float(ray.steps) / MAX_DST), 1.);\n        //object_col *= CastRay(sun_dir, ray.pos + ray.normal * PERSITION * 1.).collided ? 0.5 : 1.;\n        SpecularLight spec = Specular(GroundShine(ray.pos.y), ray.normal, ray.rd, sun_dir);\n        //object_col *= spec.diffuse + 0.75;\n        object_col += sun_col * spec.highlight * cloud_shadow;\n        /*\n        float dst_to_cloud = (10. + ray.pos.y) / sun_dir.y;\n        vec3 cloud_p = ray.pos - vec3(-iTime, 0., -iTime * 0.5) + vec3(-iTime, 0., -iTime * 0.5) * 0.1 + sun_dir * dst_to_cloud;\n        float step_size = (100. / sun_dir.y) / 10.;\n        vec3 step_size_cloud = sun_dir * step_size;\n        float density;\n        float total_density = 1.;\n        for (int cloud_step = 0; cloud_step < 10; cloud_step++)\n        {\n            cloud_p += step_size_cloud;\n            density = max(OctaveWorly(cloud_p, 3, 120., 0.6, 0.5), 0.) * step_size * GetHeightFalloff(cloud_p.y, 10., 100.);\n            total_density *= exp(-density * 0.05);\n        }\n        object_col *= total_density;\n        */\n        object_col *= (cloud_shadow);\n        \n        if (ray.pos.y < -1.5)\n        {\n            float transmittance = exp((ray.pos.y + 1.5) * 24.);\n            vec3 water_col = mix(vec3(0.2, 0.2, 0.4), vec3(0.3, 0.3, 0.5), (ray.pos.y + 1.5) * 12. + 1.5);\n            water_col *= (ray.rd.y + 1.) + 0.5;\n            vec3 text_col = vec3(1., 1., 0.5) * texture(iChannel0, ray.pos.xz * 6.).r;  // vec3(0.8, 0.66, 0.5)\n            SpecularLight water_spec = Specular(0.75, normalize(vec3(0., 1., 0.)), ray.rd, sun_dir);\n            col = mix(mix(object_col, text_col, 1. - transmittance), water_col + sun_col * water_spec.highlight, 1. - transmittance);\n            spec.highlight *= transmittance;\n        }\n        else col = object_col;\n    }\n    else\n    {\n        col = vec3(0.3, 0.3, rd.y + 0.3);\n        col = mix(col, sun_col, pow(max(dot(rd, sun_dir), 0.), 24.));\n        col = RenderClouds(col, ro + vec3(-iTime, 0., -iTime * 0.5) * 100., rd, sun_dir, sun_col);\n    }\n\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}