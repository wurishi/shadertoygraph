{"ver":"0.1","info":{"id":"ctBBRz","date":"1693656738","viewed":91,"name":"cam distortion along vectorfield","username":"krushak","description":"distorts webcam input along random vector field","likes":0,"published":1,"flags":2,"usePreview":0,"tags":["webcam"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float random(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z)-.5;\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    //u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvec2 noise2(vec2 p){\n  return vec2(noise(p), noise(p+vec2(33.5,12.3)));\n\n}\n\nfloat between(float s, float edge1, float edge2, float x){\n  return smoothstep(edge1-s,edge1,x) * smoothstep(-edge2-s,-edge2,-x);\n}\n\n\nfloat line(vec2 dir, vec2 pos){\n  float t = dot(dir,pos) / dot(dir,dir);\n  float dist = length(pos - t * dir);\n  return between(0.02,0.0,1.0,t) * between(0.02,0.0,.02,dist);\n}\n\nfloat arrowhead(vec2 dir, vec2 pos){\n  float ldir = length(dir);\n  float loff = length(pos-dir);\n  float d = dot(pos-dir,dir);\n  return between(0.02,-0.12,-0.0,d/ldir) \n         *between(0.02,-1.0,-0.85,d/ldir/loff);\n  \n}\n\nfloat arrow(vec2 dir, vec2 pos){\n  return max(line(dir-0.1*dir/length(dir),pos), arrowhead(dir, pos));\n}\n\nvec2 field(vec2 ab){\n  return vec2(noise2(ab/6.0+vec2(27.3 * floor(iTime/3.0))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float RASTER_WIDTH=0.1;\n    vec2 uv = fragCoord/iResolution.y;\n    \n    vec2 ab = floor(uv/RASTER_WIDTH - vec2(0.5)) + vec2(1.0);\n    vec2 rest = uv/RASTER_WIDTH - ab;\n\n    float ar = 0.0;\n    for(int i=-1;i<=1;i++){\n      for(int j=-1;j<=1;j++){\n      \n        vec2 ab2 = ab + vec2(i,j);\n        vec2 rest2 = rest - vec2(i,j);\n        ar = max(ar, arrow(field(ab2)*2.0, rest2));\n      }       \n    }\n    vec2 uvFlow = uv;\n    for(int i=0;i<=10;i++){\n      uvFlow = uvFlow  -.01*mod(2.0*iTime,6.0)*field(uvFlow/RASTER_WIDTH);\n    }\n    vec4 col = texture(iChannel0, uvFlow*vec2(iResolution.y/iResolution.x,1.0));\n    col = mix(col, vec4(0.0), .2*ar);\n\n    \n    // Output to screen\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}