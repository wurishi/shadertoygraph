{"ver":"0.1","info":{"id":"sdXBDs","date":"1645552757","viewed":152,"name":"vector glyph + antialias","username":"swiftcoder","description":"Version of https://www.shadertoy.com/view/NdXfWs that antialiases by estimating the pixel coverage of each bezier intersection.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["bezier","antialias","font","quadratic","glyph"],"hasliked":0,"parentid":"NdXfWs","parentname":"vector glyph by even-odd"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// directly rasterise font glyphs from a list of quadratic bezier segments\n\n// bezier segments are stored as 2d vecs packed in to pairs of vec3,\n// i.e. segemnt a->b->c is stored as vec3(a.x, a.y, b.x), vec3(b.y, c.x, c.y).\n//\n// segments are preprocessed on the CPU to each be monotonically decreasing\n// along the y-axis.\nconst vec3 letter_e[] = vec3[] (\n    vec3(0.8253138,0.08301527,0.70711297), vec3(0,0.50627613,0),\n    vec3(0.50627613,0,0.39539748), vec3(0,0.30230126,0.035305344),\n    vec3(0.30230126,0.035305344,0.20920502), vec3(0.07061069,0.14225942,0.13549618),\n    vec3(0.9874477,0.2977099,0.94351465), vec3(0.16603054,0.8253138,0.08301527),\n    vec3(0.14225942,0.13549618,0.07531381), vec3(0.20038168,0.037656903,0.29007635),\n    vec3(0.25941423,0.22709924,0.3493724), vec3(0.14122137,0.51046026,0.14122137),\n    vec3(0.51046026,0.14122137,0.583682), vec3(0.14122137,0.6380753,0.15648855),\n    vec3(0.6380753,0.15648855,0.69246864), vec3(0.17175573,0.73117155,0.19847329),\n    vec3(0.73117155,0.19847329,0.76987445), vec3(0.22519083,0.79393303,0.26049617),\n    vec3(0.16317992,0.45419848,0.16945606), vec3(0.3129771,0.25941423,0.22709924),\n    vec3(0.79393303,0.26049617,0.8179916), vec3(0.29580152,0.832636,0.33587787),\n    vec3(0.037656903,0.29007635,0), vec3(0.379771,0,0.48854962),\n    vec3(0.832636,0.33587787,0.91004187), vec3(0.3167939,0.9874477,0.2977099),\n    vec3(1,0.5763359,1), vec3(0.5152672,1,0.45419848),\n    vec3(1,0.45419848,0.58158994), vec3(0.45419848,0.16317992,0.45419848),\n    vec3(0,0.48854962,0), vec3(0.5114504,0,0.53435117),\n    vec3(0,0.53435117,0), vec3(0.6335878,0.038702928,0.7194657),\n    vec3(0.9717573,0.71374047,1), vec3(0.639313,1,0.5763359),\n    vec3(0.83682007,0.59160304,0.832636), vec3(0.65267175,0.8043933,0.70229006),\n    vec3(0.16736402,0.59160304,0.50209206), vec3(0.59160304,0.83682007,0.59160304),\n    vec3(0.2039749,0.69751906,0.17573221), vec3(0.648855,0.16736402,0.59160304),\n    vec3(0.27719665,0.78244275,0.23221758), vec3(0.7461832,0.2039749,0.69751906),\n    vec3(0.8043933,0.70229006,0.77615064), vec3(0.7519084,0.73117155,0.78625953),\n    vec3(0.8838912,0.851145,0.94351465), vec3(0.78816795,0.9717573,0.71374047),\n    vec3(0.038702928,0.7194657,0.077405855), vec3(0.8053435,0.14644352,0.86736643),\n    vec3(0.38179916,0.83874047,0.32217574), vec3(0.8187023,0.27719665,0.78244275),\n    vec3(0.73117155,0.78625953,0.68619245), vec3(0.8206107,0.6286611,0.8396947),\n    vec3(0.51046026,0.85877866,0.44142258), vec3(0.85877866,0.38179916,0.83874047),\n    vec3(0.6286611,0.8396947,0.5711297), vec3(0.85877866,0.51046026,0.85877866),\n    vec3(0.73117155,0.95706105,0.8242678), vec3(0.91412216,0.8838912,0.851145),\n    vec3(0.14644352,0.86736643,0.21548118), vec3(0.9293893,0.30857742,0.9646947),\n    vec3(0.51046026,1,0.6380753), vec3(1,0.73117155,0.95706105),\n    vec3(0.30857742,0.9646947,0.40167364), vec3(1,0.51046026,1)\n);\n\n// evaluate only the x coordinate of the bezier specified by the control points\nfloat eval_bezier_x(float t, vec2 p1, vec2 p2, vec2 p3) {\n    float s = 1.0 - t;\n    return s * s * p1.x + 2.0 * s * t * p2.x + t * t * p3.x;\n}\n\n// returns the x coordinate of the intersection beteen a horizontal line at y=b, and the\n// bezier specified by the control points.\nfloat bezier_t_intersect_horizontal_line(float y, vec2 p1, vec2 p2, vec2 p3) {    \n    float a = p1.y - 2.0*p2.y + p3.y;\n    float q = p1.y - p2.y + sqrt(y*a + p2.y*p2.y - p1.y*p3.y);\n    float ta = q / a;\n    float tb = (p1.y - y) / q;\n    return (0.0 <= ta && ta <= 1.0) ? ta : tb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv = uv * 1.2 - 0.1;\n\n    // compute the pixel footprint\n    vec2 ddx = dFdx(uv);\n    vec2 ddy = dFdy(uv);\n    vec2 pixel_footprint = sqrt(ddx * ddx + ddy * ddy);\n\n    float coverage = 0.0;\n    for (int i = 0; i < 66; i+=2)\n    {\n        vec3 dataA = letter_e[i + 0];\n        vec3 dataB = letter_e[i + 1];\n        \n        // unpack the bezier control points\n        vec2 p1 = dataA.xy;\n        vec2 p2 = vec2(dataA.z, dataB.x);\n        vec2 p3 = dataB.yz;\n\n        // compute the overlap between pixel footprint and bezier in the y-axis\n        vec2 footprint_y = uv.y + vec2(-0.5, 0.5) * pixel_footprint.y;\n        vec2 window_y = clamp(vec2(p3.y, p1.y), footprint_y.x, footprint_y.y);\n        float overlap_y = (window_y.y - window_y.x) / pixel_footprint.y;\n\n        // no overlap, we're done here\n        if (overlap_y != 0.0) {\n            // grab the intersection in terms of t as well as x\n            float t = bezier_t_intersect_horizontal_line(0.5 * (window_y.x + window_y.y), p1, p2, p3);\n            float x = eval_bezier_x(t, p1, p2, p3);\n\n            // use the tangent at t to estimate overlap in the x-axis \n            vec2 tangent = mix(p2 - p1, p3 - p2, t);\n            float f = ((x - uv.x) * abs(tangent.y)) / length(pixel_footprint * tangent.yx);\n            float overlap_x = clamp(0.5 + 0.7 * f, 0.0, 1.0);\n\n            // sum up the overlap from each curve\n            coverage += overlap_x * overlap_y;\n        }\n    }\n\n\n    fragColor = vec4(sqrt(coverage));\n}","name":"Image","description":"","type":"image"}]}