{"ver":"0.1","info":{"id":"mdcGD7","date":"1677387110","viewed":149,"name":"clear skies","username":"hgn","description":"tried to make a relaxing skybox with day and night =)","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["sky"],"hasliked":0,"parentid":"ms3GD7","parentname":"skybox testing template"},"renderpass":[{"inputs":[{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3  DAYSKY_COLOUR   = vec3( 0.37, 0.54, 0.97 );\nconst vec3  NIGHTSKY_COLOUR = vec3( 0.03, 0.05, 0.20 );\nconst vec3  SUNSET_COLOUR   = vec3( 1.00, 0.32, 0.01 );\nconst vec3  AMBIENT_COLOUR  = vec3( 0.20, 0.20, 0.20 );\n\nconst float SUN_ANGLE       = 0.0001;\nconst float TIME_RATE       = 0.025;\n\nconst float PI              = 3.14159265;\n\nstruct world_info\n{\n   float time,\n         time_of_day,\n         day_phase,\n         sunset_phase;\n   \n   vec3 sun_dir;\n};\n\nfloat luminance( vec3 v )\n{\n   return dot( v, vec3(0.2126, 0.7152, 0.0722) );\n}\n\nvec3 scene_ambient( vec3 dir, const world_info w )\n{\n   float sun_azimuth  = dot( dir.xz, w.sun_dir.xz ) * 0.4 + 0.6;\n   float sky_gradient = dir.y;\n   \n   /* Blend phase colours */\n   vec3 ambient  = DAYSKY_COLOUR   * (w.day_phase-w.sunset_phase*0.1);\n        ambient += SUNSET_COLOUR   * (1.0-dir.y*0.5) * w.sunset_phase * sun_azimuth;\n        ambient += NIGHTSKY_COLOUR * (1.0-w.day_phase);\n   \n   /* Add gradient */\n        ambient -= sky_gradient * luminance(ambient);\n        \n   return ambient;\n}\n\nvec3 scene_sky( vec3 ray_dir, const world_info w )\n{\n   float brightness = 1.0 - step( ray_dir.y, 0.0 ) * 0.1;\n   ray_dir.y = abs( ray_dir.y );\n   \n   vec3 sky_colour  = scene_ambient( ray_dir, w );\n\n   \n   /* Sun */\n   float sun_theta  = dot( ray_dir, w.sun_dir );\n   float sun_size   = max( 0.0, sun_theta * 0.5 + 0.5 + SUN_ANGLE );\n   float sun_shape  = pow( sun_size, 2000.0 );\n         sun_shape += sun_size * max(w.sun_dir.y,0.0) * 0.5;\n         \n   vec3 sun_colour  = mix( vec3(1.0), SUNSET_COLOUR, w.sunset_phase*0.5 );\n        sun_colour *= sun_shape;\n   \n   vec3 composite   = sky_colour + sun_colour;\n   \n   /* clouds */\n   float cloud_accum    = 0.0;\n   \n   for( int i=0; i<5; i++ )\n   {\n   \n      vec2  cloud_plane    = (ray_dir.xz / ray_dir.y) * (0.5+float(i)*0.1) + vec2( 0.0, float(i)*0.4 );\n      float cloud_shape    = sin(cloud_plane.y + cos(cloud_plane.y) * 0.5);\n            cloud_plane.x += cloud_shape * 0.6;\n            \n      vec2  tex_uv         = cloud_plane * vec2( 0.1, 0.04 ) + vec2( 0.0, (w.time*20.0*(1.0/0.05)+float(i)*43.124) * 0.003 );\n            \n            cloud_accum   += pow( texture( iChannel0, tex_uv ).g, 7.0 );\n   }\n   \n   cloud_accum /= 2.0;\n   \n   vec3 cloud_colour    = mix( mix(NIGHTSKY_COLOUR,vec3(1.0),w.day_phase), SUNSET_COLOUR, w.sunset_phase );\n   return mix( composite, cloud_colour, cloud_accum ) * brightness;\n}\n\n/* todo */\nvec3 scene_lighting( vec3 normal, const world_info w )\n{\n   return scene_ambient( (normal * vec3(1.0,-1.0,1.0)) * 0.5 + 0.5, w );\n}\n\nvoid scene_state( float world_time, out world_info w )\n{\n   w.time         = world_time;\n   w.time_of_day  = fract( world_time );\n   w.day_phase    = cos( w.time_of_day * PI * 2.0 )      * 0.5 + 0.5;\n   w.sunset_phase = cos( w.time_of_day * PI * 4.0 + PI ) * 0.5 + 0.5;\n   w.sunset_phase = pow( w.sunset_phase, 6.0 );\n   \n   float a        = w.time_of_day * PI * 2.0;\n   w.sun_dir      = normalize( vec3( sin( a ), cos( a ), 0.7) );\n}\n\n/* Viewer\n * ------------------------------------------------------------\n */\n\nconst float VIEWER_RATIO  = 0.3;\nconst float SPHERE_RADIUS = 0.15;\nconst float VIEWER_FOV    = 0.6;\n\nmat2 rotate_mat2( float a ) \n{    \n   float c = cos( a );\n   float s = sin( a );\n   return mat2( c, s, -s, c );\n}\n\nvec3 ray_dir_rectangular( vec2 uv )\n{\n   float ray_phi   = -PI * uv.x * 2.0;\n   float ray_theta =  PI * uv.y;\n   \n   vec3  ray_dir = vec3\n   (\n      sin( ray_theta ) * cos( ray_phi ),\n     -cos( ray_theta ),\n      sin( ray_theta ) * sin( ray_phi )\n   );\n   \n   return ray_dir;\n}\n\nvec3 ray_dir_spherical( vec2 uv, float pitch, float yaw, vec2 ratio )\n{\n   vec3 ray_dir  = normalize( vec3( (uv-0.5) * ratio, VIEWER_FOV) );\n   ray_dir.yz   *= rotate_mat2( pitch );\n   ray_dir.xz   *= rotate_mat2( yaw );\n   \n   return ray_dir;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   world_info world;\n   scene_state( (iTime -1.0) * TIME_RATE, world );\n\n   vec2 uv = fragCoord.xy / iResolution.xy;\n   vec2 ratio = vec2( iResolution.x/iResolution.y, 1.0 );\n   \n   vec3 ray_dir = vec3(0.0);\n   float brightness = 1.0;\n   \n   float view_pitch = 0.5;\n   float view_yaw   = 0.8 + world.time * 0.8;\n   \n   if( iMouse.xy != vec2(0.0) )\n   {\n      vec2 mouse  = (iMouse.xy / iResolution.xy-0.5) * 2.0;\n      view_pitch += mouse.y;\n      view_yaw   += mouse.x * 2.0;\n   }\n \n   if( uv.x <= VIEWER_RATIO && uv.y <= VIEWER_RATIO )\n   {\n      ray_dir = ray_dir_rectangular( uv/VIEWER_RATIO );\n      \n      /* do the inverse of ray_dir_spherical to find out where we are looking */\n      vec3 deprojected     = ray_dir;\n           deprojected.xz *= rotate_mat2( -view_yaw );\n           deprojected.yz *= rotate_mat2( -view_pitch );\n           \n      vec3 plane_pos = deprojected / (deprojected.z * (1.0/VIEWER_FOV));\n      \n      float area_x = step( abs(plane_pos.x), 0.5 * ratio.x );\n      float area_y = step( abs(plane_pos.y), 0.5 );\n      float area_z = step( 0.0, deprojected.z );\n      \n      brightness -= (1.0 - (area_x*area_y*area_z)) * 0.2;\n   }\n   else\n   {\n      ray_dir = ray_dir_spherical( uv, view_pitch, view_yaw, ratio );\n   }\n   \n   fragColor = vec4( scene_sky( ray_dir, world ) * brightness, 1.0 );\n   \n   vec2 sphere_center     = vec2( 0.5, SPHERE_RADIUS );\n   vec2 sphere_delta      = (uv - sphere_center) * ratio * (1.0/SPHERE_RADIUS);\n   float sphere_dist2     = dot(sphere_delta,sphere_delta);\n   vec3 sphere_normal     = vec3( sphere_delta.xy, -sqrt(max( 0.0, 1.0 - sphere_dist2 )) );\n        sphere_normal.yz *= rotate_mat2( view_pitch );\n        sphere_normal.xz *= rotate_mat2( view_yaw );\n        \n   vec3 sphere_lit        = vec3(0.9) * scene_lighting( sphere_normal, world );\n   \n   fragColor.rgb = mix( fragColor.rgb, sphere_lit, smoothstep( 1.0, 0.98, sphere_dist2 ) );\n   \n}","name":"Image","description":"","type":"image"}]}