{"ver":"0.1","info":{"id":"ltycRG","date":"1536737529","viewed":121,"name":"polygon distance","username":"magician0809","description":"distance and direction of polygon","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["distance","polygon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DENS 16.\n#define ROT_SPEED 0.1\n\n#define POLY_EDGE 4\n\nfloat dot2(vec2 v)\n{\n    return dot(v, v);\n}\n\nfloat cross2(vec2 v0, vec2 v1)\n{\n    return v0.x * v1.y - v0.y * v1.x;\n}\n\nfloat proj01(vec2 src, vec2 dst)\n{\n    return dot(src, dst) / dot2(dst);\n}\n\nvec2 segmentDistance(vec2 dp, vec2 sd)\n{\n    float lp = proj01(dp, sd);\n    lp = clamp(lp, 0.0, 1.0);\n    return dp - lp * sd;\n}\n\nvec2 polygonDistance(vec2 p, vec2 poly[POLY_EDGE])\n{\n    vec2 dn, n;\n    dn = segmentDistance(p - poly[POLY_EDGE-1], poly[0] - poly[POLY_EDGE-1]);\n    for (int i = 0; i < POLY_EDGE-1; i++)\n    {\n        n = segmentDistance(p - poly[i], poly[i + 1] - poly[i]);\n        if (dot2(n) < dot2(dn)) dn = n;\n    }\n    return dn;\n}\n\nbool inConvexPolygon(vec2 p, vec2 poly[POLY_EDGE])\n{\n    float lc = cross2(p - poly[POLY_EDGE-1], p - poly[0]);\n    for (int i = 0; i < POLY_EDGE-1; i++)\n    {\n        float c = cross2(p - poly[i], p - poly[i + 1]);\n        if (c * lc < 0.0) return false;\n        lc = c;\n    }\n    return true;\n}\n\nfloat drawSegment(vec2 uv, vec2 sp, vec2 sq, float thinkness)\n{\n    vec2 pp = uv - sp;\n    vec2 pq = sq - sp;\n    float lp = proj01(pp, pq);\n    vec2 dn = pp - lp * pq;\n    float sw = dot2(dn);\n    return step(sw, thinkness * thinkness)\n         * step(0.0, lp)\n         * step(lp, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ouv = fragCoord / iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    vec2 cp = vec2((aspect - 1.0) * 0.5 + 0.5, 0.5);\n    float pu = 1.0 / iResolution.y;\n    vec2 uv = fragCoord / iResolution.y;\n    vec2 ms = iMouse.xy / iResolution.y;\n    \n    //generate polygon\n    float cs = cos(iTime * ROT_SPEED);\n    float sn = sin(iTime * ROT_SPEED);\n    mat2 mr = mat2(cs,sn,-sn,cs);\n    vec2 poly[POLY_EDGE];\n    poly[0] = mr * vec2(-0.25, 0.35) + cp;\n    poly[1] = mr * vec2(-0.25, -0.25) + cp;\n    poly[2] = mr * vec2(0.35, -0.25) + cp;\n    poly[3] = mr * vec2(0.2, 0.2) + cp;\n    \n    //distance per pixel\n    bool inConvex = inConvexPolygon(uv, poly);\n    float dist = length(polygonDistance(uv, poly));\n    float fd = fract(dist * DENS);\n    vec4 col = inConvex ? vec4(0.35, 0.5, 0.65, 1.0) : vec4(0.5, 0.5, 0.5, 1.0);\n    col.r = smoothstep(col.a, 0.0, abs(fd - col.r));\n    col.g = smoothstep(col.a, 0.0, abs(fd - col.g));\n    col.b = smoothstep(col.a, 0.0, abs(fd - col.b));\n    col *= 1.0 - step(dist, pu) * 0.5;\n    \n    //distance segment\n    vec2 dn = polygonDistance(ms, poly);\n    float s = drawSegment(uv, ms, ms - dn, pu);\n    col *= 1.0 - s * 0.5;\n    \n    //vignette effect\n    col *= smoothstep(0.7, 0.1, length(vec2(0.5) - ouv));\n    \n    //final\n    fragColor = vec4(col.rgb, 1);\n}","name":"Image","description":"","type":"image"}]}