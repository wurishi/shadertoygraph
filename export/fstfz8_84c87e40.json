{"ver":"0.1","info":{"id":"fstfz8","date":"1656369200","viewed":88,"name":"Lorenz fractal","username":"akoylasar","description":"Visualisation of Lorenz equation solved for fixed point dx/dt = 0, dy/dt = 0, dz/dt = 0.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["fractal","lorenzfractal","lorenzsystem"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2022-2022 Fouad Valadbeigi (akoylasar@gmail.com).\n\n// Iterations for root finder\n#define N 30.\n\n// Lorenz equation parameters\nvec3 getParams() {\n    return vec3(10. , 28., 8. / 3.); // sigma, r, beta\n}\n\n// Distinct roots of Lorenz equation when\n// dx/dt = 0, dy/dt = 0, dz/dt = 0\nconst float eps = .000001;\nint root(vec3 p, float r, float beta) {\n    float a = r - 1.;\n    float b = sqrt(beta * a);\n    if (distance(p,  vec3(0., 0., 0.))  <= eps) return 1; \n    if (distance(p,  vec3(b, b, a))     <= eps) return 2;\n    if (distance(p,  vec3(-b, -b, a))   <= eps) return 3;\n    return 0;\n}\n\n// Solving Ax = b where\n// A = [-sigma, sigma, 0\n//      r - z,  -1,    -x\n//      y,      x,     -beta]\n// and b = [-f -g -h]\nvec3 iterateOnce(vec3 p, float sigma, float r, float beta) {    \n    float f = sigma * (p.y - p.x);\n    float g = (p.x * (r - p.z) - p.y);\n    float h = (p.x * p.y - beta * p.z);\n    \n    float a = -g + p.x * h / beta;\n    float b = beta / (p.x * p.x + beta);\n    float c = r - p.z - p.x * p.y / beta;\n    \n    float deltaX = (a * b * sigma - f) / (c * b * sigma - sigma);\n    float deltaY = -(a - c * deltaX) * b;\n    float deltaZ = (h + p.y * deltaX + p.x * deltaY) / beta;\n    \n    return p + vec3(deltaX, deltaY, deltaZ);\n}\n\nvec3 drawFractal(vec3 p) {\n    vec3 params = getParams();\n    float sigma = params.x;\n    float r = params.y;\n    float beta = params.z;\n    \n    // Newton's method used to draw Lorenz fractal.\n    float n = 0.;\n    int res = 0;\n    for (; n <= N; n++) {\n        p = iterateOnce(p, sigma, r, beta);\n        res = root(p, r, beta);\n        if (res != 0) break;\n    }\n    vec3 col = vec3(0.);\n    if (res == 1) col = vec3(.173, .75, .125);\n    if (res == 2) col = vec3(.373, .294, .40);\n    if (res == 3) col = vec3(.655, .678, .776);\n    return (1. - n / N) * col;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float ar = iResolution.y / iResolution.x; \n    vec2 p = 2. * fragCoord / iResolution.xy - 1.;\n    p.y *= ar;\n    \n    \n    float period = 10.;\n    float t = abs(2. * fract(iTime / period) - 1.); \n    p *= mix(40., 400., smoothstep(0., 1., t));\n        \n    vec3 col = drawFractal(vec3(p.x, 3. * sqrt(2.), p.y));\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}