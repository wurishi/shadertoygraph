{"ver":"0.1","info":{"id":"XsfBRH","date":"1494746799","viewed":5782,"name":"sphere intersect pub","username":"nt4t","description":"sphere intersect","likes":173,"published":1,"flags":0,"usePreview":1,"tags":["procedural","3d","texture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define float3 vec3\n#define float3x3 mat3\n\nconst float MAX_RAY_LENGTH=1e4;\n\nfloat RSph(float3 p0, float r, float3 rp0, float3 rd)\n{\n    float t = 0.;\n\tfloat3 l=p0-rp0;\n\tfloat tc=dot(l,rd);\n\tif(tc<0.0)\n    {\n        t=MAX_RAY_LENGTH;\n        return t;\n    };\n\n    float d2=r*r+tc*tc-dot(l,l);\n\n\tif(d2<0.0)\n    {\n        t=MAX_RAY_LENGTH;\n        return t;\n    };\n\n\tfloat thc=sqrt(d2);\n    t=tc-thc;\n    return t;\n}\n\nfloat cube(float3 ray, float3 dir, float3 bmin, float3 bmax) {\n    vec3 ddir = 1.0 / dir;\n    vec3 t1 = (bmin - ray) * ddir;\n    vec3 t2 = (bmax - ray) * ddir;\n    vec3 tmin = vec3(min(t1.x, t2.x), min(t1.y, t2.y), min(t1.z, t2.z));\n    vec3 tmax = vec3(max(t1.x, t2.x), max(t1.y, t2.y), max(t1.z, t2.z));\n    float tmin_max = max(tmin.x, max(tmin.y, tmin.z));\n    float tmax_min = min(tmax.x, min(tmax.y, tmax.z));\n    return tmax_min >= tmin_max ? tmin_max : -1.0;\n}\n\nvec3 background(float t, vec3 rd)\n{\n    vec2 pos = (rd.xy +vec2(3.2,0.7))* vec2(0.55,0.55);\n    vec3 tex =  vec3(texture(iChannel0, pos));\n\n//\tvec3 light = normalize(vec3(3.14-((uSize.x/uTouch.x)*2.0), -0.5+(uSize.y/uTouch.y), -1.0));\n    vec3 light = normalize(vec3(2.0, 1.5, (cos(t))));\n\tfloat sun = max(0.0, -dot(rd, light));\n\n    vec3 light2 = normalize(vec3((sin(t/2.0)), 0.7, -abs(cos(t/2.0))));\n    float sun2 = max(0.0, -dot(rd+vec3(0.0,-0.0,0.01), light2));\n\n    vec3 light3 = normalize(vec3((cos(t/2.0)), -0.5, -abs(cos(t/2.0))));\n    float sun3 = max(0.0, -dot(rd+vec3(0.0,-0.1,0.06), light3));\n\n    float sky = max(0.0, dot(rd, vec3(1.0, 0.0, 0.0)));\n\tfloat ground = max(0.0, -dot(rd, vec3(1.0, 0.0, 0.0)));\n\n    tex = vec3(0.0);\n    vec3 outcolor =  (pow(sun, 256.0)+0.1*pow(sun, 1.0)+pow(sun2, 256.0)+0.2*pow(sun2, 1.0)+pow(sun3, 256.0))*vec3(1.0, 0.1, 0.1)+(tex.rgb / 4.0);\n\n    if (length(rd.xy) < 0.7)\n    {\n    }\n\n    return outcolor;\n    }\n\n\n// rendering params\nconst float sphsize=.7; // planet size\nconst float dist=.27; // distance for glow and distortion\nconst float perturb=.3; // distortion amount of the flow around the planet\nconst float displacement=.015; // hot air effect\nconst float windspeed=.4; // speed of wind flow\nconst float steps=15.; // number of steps for the volumetric rendering\nconst float stepsize=.025; \nconst float brightness=.43;\nconst vec3 planetcolor=vec3(0.55,0.4,0.3);\nconst float fade=.005; //fade by distance\nconst float glow=3.5; // glow amount, mainly on hit side\n\nconst int iterations=14; \nconst float fractparam=.7;\nconst vec3 offset=vec3(1.5,2.,-1.5);\n\nfloat wind(vec3 p) {\n\tfloat d=max(0.,dist-max(0.,length(p)-sphsize)/sphsize)/dist; // for distortion and glow area\n\tfloat x=max(0.2,p.x*2.); // to increase glow on left side\n\tp.y*=1.+max(0.,-p.x-sphsize*.25)*1.5; // left side distortion (cheesy)\n\tp-=d*normalize(p)*perturb; // spheric distortion of flow\n\tp+=vec3((iTime/4.0)*windspeed,0.,0.); // flow movement\n\tp=abs(fract((p+offset)*.1)-.5); // tile folding \n\tfor (int i=0; i<iterations; i++) {  \n\t\tp=abs(p)/dot(p,p)-fractparam; // the magic formula for the hot flow\n\t}\n\treturn length(p)*(1.+d*glow*x)+d*glow*x; // return the result with glow applied\n}\n\n\nfloat snow(vec2 uv)\n{\n        vec3 dir=vec3(-uv,1.0);\n\t\tvec3 tex3=vec3(0.0);\n\n        vec3 from = vec3(0.0,0.0,1.0);\n\n        float v=0., l=-0.0001;\n        float t=0.1*windspeed*0.2;\n\n        for (float r=8.0; r<steps; r++) {\n            vec3 p=from+r*dir*stepsize;\n            v+=min(50.,wind(p))*max(0.,1.-r*fade);\n            \n//            vec2 pol = vec2((cos(p.x),sin(p.y)*v));\n            vec2 pol = vec2((p.x+iTime/6.0),(p.y));\n            \n            tex3 = vec3(texture(iChannel0, vec2(pol.x,pol.y)*2.5));\n            }\n\n        v/=steps; v*=brightness;\n        \n    \n        return v*(tex3.r*(2.5+sin(iTime)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n     // camera movement\t\n//\tfloat an = 0.5*iTime;\n    float an = 1.5*1.;\n\tvec3 ro = vec3( 2.5*cos(an), 0., 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(iTime)/8.,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n\t\n    vec3 tex3 =  vec3(texture(iChannel0, rd.xy+sin(iTime)));\n    tex3 =  vec3(texture(iChannel0, vec2(rd.x+(iTime/4.), rd.y)));\n\n\t// raytrace-plane\n    float t = 1e4;\n    t = RSph(vec3(0. + cos(iTime) / 6.,0.,0.0 + sin(iTime) / 10.), 1.40 - ((tex3.r) * 0.05), ro, rd);\n//\tt = cube(ro, rd, vec3(0.01,0.01,0.1), vec3(1.0,1.0,1.0-tex3.r));\n\n\tvec3 nml = normalize(vec3(0.0) - (ro+rd*t));\n\trd = reflect(-rd, nml* 1.0);\n    \n    // shading/lighting\t\n\tvec3 col = vec3(0.0);\n\n\t\n\t\n\tcol = background(iTime, rd) * vec3(0.9, 0.8, 1.0) * 2.6;\n//    col -= background(iTime - 2.0, rd - vec3(0,-0.03,0.0)) * vec3(0.9, 0.8, 1.0);\n//    col = sqrt( col );\n    \n    rd = reflect(-rd, nml);\n    \n   \t// get ray dir\t\n\tvec2 uv = nml.xy;\n\tvec3 dir=vec3(uv,1.);\n//\tdir.x*=iResolution.x/iResolution.y;\n\n    \n    \n    float snoise = (snow(vec2(uv.x,uv.y)));\n    \n    if((iTime > 30.0)){\n    \tcol.b += snoise * abs(cos(iTime / 15.0)/1.0);\n    }\n    else{\n        col += snoise * abs(sin(iTime / 5.0)/2.5);\n    }    \n    \n    \n    if (length(nml.xy+vec2(0.0,0.0)) < 0.95)\n    {\n        if (t > 10.01)\n        {\n            col = vec3(0.0,0.0,0.0);\n//            col = vec3(1.0,1.0,1.0)*snoise;\n        }\n    }\n    \n\n    if (t < 10.0+sin(iTime))\n    {\n//    \tsnoise = (snow(nml.xy));\n    \tcol.r += snoise;\n    }\n\n    \n    \n    if (length(nml.xy+vec2(-0.5,0.0)*(snoise/1.0)) < 0.55)\n    {\n        if (t > 2.71)\n        {\n//            col = tex3 + (col.rgb / 4.);\n            col.r = snoise*2.0;\n        }\n    }\n    \n\tfragColor = vec4( col, 1.0 );\n//    fragColor = vec4( mix(col, col, step(0.0, t)), 1.0 );\n}","name":"Image","description":"","type":"image"}]}