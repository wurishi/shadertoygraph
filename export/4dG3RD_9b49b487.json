{"ver":"0.1","info":{"id":"4dG3RD","date":"1453383590","viewed":541,"name":"Wolf3D - Serious Version","username":"MonkeyIsBack","description":"No collisions yet.\nUse Arrows for moving.\nOther inputs : Press \"M\" to switch mode to AZERTY / QWERTY (ZQSD / WASD)\nOptimization level 0.","likes":13,"published":1,"flags":48,"usePreview":0,"tags":["keyboard","raycaster"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define load(a,b) texture(b,(fract(a.x)==0.1?vec2(fragCoord.x,a.y+0.5):(a+0.5))/iResolution.xy)\n\n#define MAX_VIEW_DISTANCE 1000.0\n#define PI 3.14159265359\n#define MAP_SIZE 10.0\n#define START_ANGLE 4.5\n\nconst vec2 bufA_mem_PlayerData = vec2(0.0,0);\n\nvoid drawWall( out vec4 fragColor, vec2 uv, float heightRatio, float angle, float coord_hit, int tex_id) {\n    float skyHeight = (1.0 - heightRatio) / 2.0;\n    float wallheight = heightRatio;\n    float floorheight = skyHeight;\n    \n    if (1.0 - uv.y < skyHeight) {\n        \n        \n        uv.x = angle / 2.0*PI;\n        uv.y = 1.0 - uv.y;\n        \n        fragColor = texture(iChannel0,uv);\n    }\n    else if (1.0 - uv.y < skyHeight + wallheight) {\n        uv.x = coord_hit; // de 0.0 Ã  1.0, it's ok\n        //uv.y = 1.0 - uv.y; // de 0.0 a 1.0, doit reprÃ©senter la hauteur sur le mur du y actuel;\n       \tuv.y = (uv.y - skyHeight) / wallheight;\n        \n        if (tex_id == 0)\n        \tfragColor = texture(iChannel1,uv);\n        else\n        \tfragColor = texture(iChannel1,uv);\n    }\n    else\n        fragColor = vec4(0.7, 0.2, 0.2, 1.0);\n        \n}\n\n/* map 10:10\n\n x 0 1 2 3 4 5 6 7 8 9\ny\n0  1 1 1 1 1 1 1 1 1 1\n1  1 0 0 0 0 0 0 0 0 1\n2  1 0 1 0 1 0 1 0 0 1\n3  1 0 0 0 0 0 0 0 0 1\n4  1 0 1 0 1 0 1 0 0 1\n5  1 0 0 0 0 0 0 0 0 1\n6  1 0 1 0 1 0 1 0 0 1\n7  1 0 1 0 1 0 1 0 0 1\n8  1 0 0 0 0 0 0 0 0 1\n9  1 1 1 1 1 1 1 1 1 1\n\n*/\n\nbool hitWall(float yIn, float xIn) {\n    int y = int(yIn);\n    int x = int(xIn);\n    if (yIn < 0.0)\n        y = -1;\n    if (xIn < 0.0)\n        x = -1;\n    \n    // bornes\n    if (y >= 0 && y <= 9) {\n        if (x == 0 || x == 9)\n            return true;\n    }\n    if (x >= 0 && x <= 9) {\n        if (y == 0 || y == 9)\n            return true;\n    }\n\n    if (x == 2 && y == 2)\n        return (true);\n    if (x == 2 && y == 4)\n        return (true);\n    if (x == 2 && y == 6)\n        return (true);\n    if (x == 2 && y == 7)\n        return (true);\n    \n    if (x == 4 && y == 2)\n        return (true);\n    if (x == 4 && y == 4)\n        return (true);\n    if (x == 4 && y == 6)\n        return (true);\n    if (x == 4 && y == 7)\n        return (true);\n    \n    if (x == 6 && y == 2)\n        return (true);\n    if (x == 6 && y == 4)\n        return (true);\n    if (x == 6 && y == 6)\n        return (true);\n    if (x == 6 && y == 7)\n        return (true);\n\n\treturn false;\n}\n\nfloat getXDistReduce(float posX, float posY, float angle, out float hit) {\n\n    for (float i = MAP_SIZE + 2.0; i >= -1.0; i--) {\n        if (i < posX && i >= 0.0) {\n            \n            float adj = posX - i;\n            float hyp = adj / cos(angle);\n            float opp = hyp * sin(angle);\n\n            if (hitWall(posY - opp, posX - adj - 1.0) == true) {\n\t\t\t\thit = posY - opp - floor(posY - opp);\n            \treturn (-hyp);\n            }\n            \n        }\n    }\n    return (MAX_VIEW_DISTANCE);\n}\n\nfloat getYDistReduce(float posX, float posY, float angle, out float hit) {\n\n    for (float i = MAP_SIZE + 1.0; i >= -1.0; i -= 1.0) {\n        if (i <= posY && i >= 0.0) {\n            \n            float adj = posY - i;\n            float hyp = adj / sin(angle);\n            float opp = hyp * cos(angle);\n            \n            if (hitWall(posY - adj - 1.0, posX - opp ) == true) {\n\t\t\t\thit = 1.0 - (posX - opp);\n            \treturn (-hyp);\n            }\n        }\n    }\n    return (MAX_VIEW_DISTANCE);\n}\n\nfloat getXDistIncrease(float posX, float posY, float angle, out float hit) {\n    for (float i = -1.0; i <= MAP_SIZE; i += 1.0) {\n        if (i > posX && i < MAP_SIZE) {\n            \n            float adj = i - posX;\n            float hyp = adj / cos(angle);\n            float opp = hyp * sin(angle);\n            \n            if (hitWall(posY + opp, adj + posX) == true) {\n\t\t\t\thit =  floor(posY + opp) - posY - opp;\n                return (abs(hyp));\n            }\n        }\n    }\n    return (MAX_VIEW_DISTANCE);\n}\n\nfloat getYDistIncrease(float posX, float posY, float angle, out float hit) {\n    for (float i = -1.0; i <= MAP_SIZE; i += 1.0) {\n        if (i > posY && i <= MAP_SIZE) {\n\n            float adj = i - posY;\n            float hyp = adj / sin(angle);\n            float opp = hyp * cos(angle);\n            \n            if (hitWall(posY + adj, posX + opp) == true) {\n\t\t\t\thit = posX + opp - floor(posX + opp);\n            \treturn (abs(hyp));\n            }\n        }\n    }\n\n    return (MAX_VIEW_DISTANCE);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy; // ratio x / screen_x actuel\n    \n    vec4 bufferPos = load(bufA_mem_PlayerData, iChannel3);\n    \n    float posPlayerX = 7.5 + bufferPos.x;\n    float posPlayerY = 7.5 + bufferPos.y;\n   \tfloat viewCenter = START_ANGLE + bufferPos.z;\n    float fieldOfView = 0.3 * PI;\n    float currentAngle = viewCenter + (0.5 * fieldOfView) - uv.x * fieldOfView;\n    float dist_x;\n    float dist_y;\n    float coord_hit_x;\n    float coord_hit_y;\n    float coord_hit;\n    int wall_tex;\n    \n    \n    if (currentAngle > 2.0 * PI)\n        currentAngle -= 2.0*PI;\n    if (currentAngle < 0.0)\n        currentAngle += 2.0*PI;\n    \n    \n    if (currentAngle >= 0.5 * PI && currentAngle <= 1.5 * PI) {\n\t\tdist_x = getXDistReduce(posPlayerX, posPlayerY, currentAngle, coord_hit_x);\n        coord_hit = coord_hit_x;\n        wall_tex = 0;\n    } else {\n\t\tdist_x = getXDistIncrease(posPlayerX, posPlayerY, currentAngle, coord_hit_x);\n        coord_hit = coord_hit_x;\n        wall_tex = 0;\n    }\n    \n    if (currentAngle >= 0.0 && currentAngle <= PI) {\n\t\tdist_y = getYDistIncrease(posPlayerX, posPlayerY, currentAngle, coord_hit_y);\n        if (dist_y < dist_x) {\n        \tcoord_hit = coord_hit_y;\n        \twall_tex = 1;\n        }\n    } else {\n\t\tdist_y = getYDistReduce(posPlayerX, posPlayerY, currentAngle, coord_hit_y);\n        if (dist_y < dist_x) {\n        \tcoord_hit = coord_hit_y;\n        \twall_tex = 1;\n        }\n    }\n    \n    float dist = min(dist_x, dist_y);\n    dist *= cos(currentAngle - viewCenter);\n    \n    drawWall(fragColor, uv, (1.0 / dist), currentAngle, coord_hit, wall_tex);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define inside(a) (fragCoord.y-a.y == 0.5 && (fract(a.x) == 0.1 || fragCoord.x-a.x == 0.5))\n#define load(a,b) texture(b,(a+0.5)/iResolution.xy)\n#define save(a,b) if(inside(a)){fragColor=b;return;}\n\n#define MOVE_SPEED 3.0\n#define TURN_SPEED 1.5\n#define START_ANGLE 4.5\n\n#define PI 3.14159265359\n\n#define KEY_LEFT\t37.5/256.0\n#define KEY_UP\t\t38.5/256.0\n#define KEY_RIGHT\t39.5/256.0\n#define KEY_DOWN\t40.5/256.0\n#define KEY_Z\t\t90.5/256.0\n#define KEY_Q\t\t81.5/256.0\n#define KEY_S\t\t83.5/256.0\n#define KEY_D\t\t68.5/256.0\n#define KEY_W\t\t87.5/256.0\n#define KEY_A\t\t65.5/256.0\n#define KEY_M\t\t77.5/256.0\n\nconst vec2 bufA_mem_PlayerData = vec2(0.0,0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // global buffer loading\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel0,uv);\n    \n    // if currentposition is in the player data position\n    if (inside(bufA_mem_PlayerData))\n    {\n        // fragColor.x = posX - 6.5\n        // fragColor.y = posY - 6.5\n        // fragColor.z = view_angle\n        // fragColor.w = keyboard mode, < 5.0 for azerty, > 6.0 for qwerty\n        \n        // read keyboard\n        float kUp = texture( iChannel1, vec2(KEY_UP,0.0) ).x;\n        float kRight = texture( iChannel1, vec2(KEY_RIGHT,0.0) ).x;\n        float kDown = texture( iChannel1, vec2(KEY_DOWN,0.0) ).x;\n        float kLeft = texture( iChannel1, vec2(KEY_LEFT,0.0) ).x;\n        float kZ = texture( iChannel1, vec2(KEY_Z,0.0) ).x;\n        float kQ = texture( iChannel1, vec2(KEY_Q,0.0) ).x;\n        float kS = texture( iChannel1, vec2(KEY_S,0.0) ).x;\n        float kD = texture( iChannel1, vec2(KEY_D,0.0) ).x;\n        float kW = texture( iChannel1, vec2(KEY_W,0.0) ).x;\n        float kA = texture( iChannel1, vec2(KEY_A,0.0) ).x;\n        float kM = texture( iChannel1, vec2(KEY_M,0.0) ).x;\n        \n        float posX = fragColor.x;\n        float posY = fragColor.y;\n        float angle = fragColor.z + START_ANGLE;\n        \n        // switch Keyboard mode\n        if (kM > 0.5) {\n            if (fragColor.w < 5.0)\n                fragColor.w = 8.0;\n            else\n                fragColor.w = 3.0;\n        }\n        \n        // turn right\n        if (kRight > 0.5) {\n            angle -= TURN_SPEED * iTimeDelta;\n        }\n        // turn left\n        if (kLeft > 0.5) {\n            angle += TURN_SPEED * iTimeDelta;\n        }\n        \n        if (angle < 0.0)\n            angle += 2.0 * PI;\n        if (angle > 2.0 * PI)\n            angle -= 2.0 * PI;\n        \n        // move front\n        if (kUp > 0.5 || (kZ > 0.5 && fragColor.w < 5.0) || (kW > 0.5 && fragColor.w > 6.0)) {\n\t\t\tposX += cos(angle) * (MOVE_SPEED * iTimeDelta);\n\t\t\tposY += sin(angle) * (MOVE_SPEED * iTimeDelta);\n        }\n        \n        // move back\n        if (kDown > 0.5 || kS > 0.5) {\n\t\t\tposX -= cos(angle) * (MOVE_SPEED * iTimeDelta);\n\t\t\tposY -= sin(angle) * (MOVE_SPEED * iTimeDelta);\n        }\n        \n        // left strafe\n        if ((kQ > 0.5 && fragColor.w < 5.0) || (kA > 0.5 && fragColor.w > 6.0)) {\n\t\t\tposY += cos(angle) * (MOVE_SPEED * iTimeDelta);\n\t\t\tposX -= sin(angle) * (MOVE_SPEED * iTimeDelta);\n        }\n        \n        // right strafe\n        if (kD > 0.5) {\n\t\t\tposY -= cos(angle) * (MOVE_SPEED * iTimeDelta);\n\t\t\tposX += sin(angle) * (MOVE_SPEED * iTimeDelta);\n        }\n\n\t\tfragColor = vec4(posX, posY, angle - START_ANGLE, fragColor.w);\n\n    }\n    else\n    {\n     \tdiscard;   \n    }\n}","name":"Buf A","description":"","type":"buffer"}]}