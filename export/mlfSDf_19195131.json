{"ver":"0.1","info":{"id":"mlfSDf","date":"1675425749","viewed":53,"name":"are you a robot ?","username":"Soupir","description":"swag","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["swag"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// thanks to green chicken, Patricio Gonzalez Vivo, The Art of Code yt channel and everyone else\n\n#define FOV 2.0\n#define max_iteration 64\n\n// cosine based palette, 4 vec3 params\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \n    \nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n   \n\n\n\nfloat getDist(vec3 p){\n\n    p.x += sin(iTime) * 0.5;\n\n    float offset = sin(iTime * 0.5)*0.001;\n    float bodyMovement = abs(sin(iTime * 2.)) * 0.01;\n    \n    vec4 sphere1 = vec4(0., 1. + bodyMovement, -7., 1.);\n    vec4 sphere2 = vec4(0., 2. + offset, -6., 0.5);\n    vec4 sphere3 = vec4(0.25, 2. + offset, -5.5, 0.15);\n    vec4 sphere4 = vec4(-0.25, 2. + offset, -5.5, 0.15);\n   \n\n    float sphere1Dist = length(p - sphere1.xyz) - sphere1.w;\n    float sphere2Dist = length(p - sphere2.xyz) - sphere2.w;\n    float sphere3Dist = length(p - sphere3.xyz) - sphere3.w;\n    float sphere4Dist = length(p - sphere4.xyz) - sphere4.w;\n    \n    float planeDist = p.y;\n    \n    float distance = opSmoothUnion(sphere1Dist, planeDist, 0.7);\n    distance = opSmoothUnion(distance, sphere2Dist, 0.9 + sin(iTime)*0.25);\n    distance = opSmoothSubtraction( sphere3Dist, distance, 0.02 + bodyMovement * 0.3);\n    distance = opSmoothSubtraction( sphere4Dist, distance, 0.02 + bodyMovement * 0.3);\n    return distance;\n\n}\n\nfloat rayMarch(vec3 rayOrigin, vec3 rayDirection)\n{\n    float distanceOrigin = 0.0;\n    \n    for(int i = 0; i < max_iteration; i++)\n    {\n        vec3 rayPosition = rayOrigin + rayDirection * distanceOrigin;\n        float distanceFromObject = getDist(rayPosition);\n        distanceOrigin += distanceFromObject;\n        \n        if(distanceOrigin > 64. || distanceFromObject < 0.01){\n            break;\n        }\n    }\n    \n    return distanceOrigin;\n}\n\nvec3 getNormal(vec3 p) {\n\tfloat d = getDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy),\n        getDist(p-e.yxy),\n        getDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\nfloat getLight(vec3 p)\n{\n    vec3 lightPos = vec3(0., 6., 3.);\n    lightPos.xz += vec2(sin(iTime * 0.5), cos(iTime * 0.25)) * 0.25;\n    vec3 lightVector = normalize(lightPos - p);\n    vec3 normal = getNormal(p);\n    \n    float dif = clamp(dot(normal, lightVector), 0., 1.);\n    float d = rayMarch(p + normal * 0.1, lightVector);\n    if(d<length(lightPos-p))\n    {\n        dif *= 0.1;\n    };\n    \n    return dif;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //uv from -1 to 1 with ratio adaptation\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    uv.x += iTime * 0.25;\n    uv.y += sin(iTime) * 0.05;\n    \n    float id = floor(uv.x);\n    float randomNb = fract(sin(id * 156.65) * 6543.) * 2. - 1.;\n    uv.x = fract(uv.x) - 0.5 + randomNb * 0.02;\n    \n    \n    // locators\n    vec3 camPos = vec3(0., 1., 0.);\n    vec3 camTarget = vec3(0., 2., -5);\n    \n    // cam axis\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(camForward, vec3(0., -1., 0.)));\n    vec3 camUp = normalize(cross(camForward, camRight));\n    \n    // the ray direction\n    vec3 viewDir = normalize(uv.x * camRight + uv.y * camUp + camForward * FOV);\n\n    vec3 col = vec3(0.0);\n    \n    float distance = rayMarch(camPos, viewDir);\n    distance +=sin(iTime)*0.02;\n    \n    vec3 closestShapePoint = camPos + viewDir * distance;\n    \n    float dif = getLight(closestShapePoint);\n    \n\n    vec3 palette =  palette(dif, vec3(0.05,0.1,0.6),vec3(0.15,0.6,0.4),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) );\n    col = vec3(palette);\n    \n    vec2 uvFade = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uvFade.x *= iResolution.x/iResolution.y;\n    uvFade.x += sin(iTime);\n    uvFade.y += cos(iTime * 2.) * 0.25;\n    \n    float circle = clamp(length(uvFade) * 0.35, 0.1, 1.);;\n    \n    col -= circle;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    }","name":"Image","description":"","type":"image"}]}