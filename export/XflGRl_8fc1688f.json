{"ver":"0.1","info":{"id":"XflGRl","date":"1703663028","viewed":41,"name":"Recursive triangular coordinates","username":"vichoeq","description":"Divide the plane into equilateral triangles, calculate an ID for each triangle, setup local coordinate system for each triangle, and turn this local coordinate system into local, cartesian coordinates. Apply recursively depending on triangle ID.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","triangle","study"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RECURSIVE\n\n// 0 for even triangles (upright), 1 for odd triangles \nfloat parity(vec3 id)\n{\n    return mod(id.x+id.y+id.z, 2.0) < 1.0 ? 0.0 : 1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    // Scale space\n    uv *= 2.0; \n    \n    // Shift center so origin is at the center of an upright triangle\n    uv += vec2(1./sqrt(3.), 1./3.);\n    \n    // Triangle coordinates: distance to a 60°, 120° and 180° line.\n    vec3 tuv;\n    \n    tuv.r = 0.866025 * uv.x - 0.5 * uv.y; // 60° line\n    tuv.g = 0.866025 * uv.x + 0.5 * uv.y; // 120° line\n    tuv.b = uv.y; // 180° (0°) line\n        \n    \n    \n        \n    // Domain repetition (periodic triangle coordinates)\n    vec3 ptuv = fract(tuv);\n    // Integer coordinates of the triangle\n    vec3 triangle_id = floor(tuv);\n    \n    #ifdef RECURSIVE\n    // Nesting\n    vec3 recursive_id = triangle_id;\n    // Noise determines whether of not we nest\n    float noise = hashwithoutsine13(triangle_id); \n    \n    for(int i = 0; i < 4; i++)\n    {\n        if (noise < 0.5)\n        {        \n            // Zoom in\n            tuv = 2.0*ptuv;\n            // Local coordinates, periodic\n            ptuv = fract(tuv);\n            // Local ID\n            triangle_id = floor(tuv);\n            // Global ID (should be recursive_id+0.1*triangle_id but it messes up with the hash)\n            recursive_id = 0.1*recursive_id+triangle_id;\n            // Recalculate noise\n            noise = hashwithoutsine13(recursive_id);\n        }\n        else break;\n    }\n    #endif\n    \n    // Make triangle center be (0,0,0):\n    \n    // Upright triangles\n    if(parity(triangle_id) == 0.0)\n    {\n        ptuv.g = 1.0 - ptuv.g;       \n    }\n    // Downright triangles\n    else\n    {        \n        ptuv.r = 1.0 - ptuv.r;\n        ptuv.b = 1.0 - ptuv.b;       \n    }    \n    ptuv -= 1./3.; \n     \n    // Color is literally the triangular coordinates\n    vec3 color = (0.5+vec3(ptuv));     \n          \n    // Turn the coordinates back into cartesian\n    uv.y = ptuv.b;\n    uv.x = (2.*ptuv.g + ptuv.b)/sqrt(3.);\n        \n    // Draw funny shape\n    float polygon = 1.0-step(0.0, polar_polygon(uv, 0.333, 3.0, iTime));        \n    color = mix(color, 1.0-color, polygon);    \n        \n        \n    fragColor = vec4(color, 1.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359 \n#define TWO_PI 6.28318530718\n\n\n//https://www.shadertoy.com/view/4djSRW\nfloat hashwithoutsine13(vec3 p3)\n{\n    p3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat polar_polygon(vec2 uv, float R, float n, float rotation)\n{\n    float theta = atan(uv.y,uv.x)+PI/2.+rotation;\n    \n    theta -= TWO_PI/n*floor((n*theta + PI)/TWO_PI);\n    \n    float r = R*cos(PI/n)/cos(theta);\n    \n    return length(uv)-r;\n}","name":"Common","description":"","type":"common"}]}