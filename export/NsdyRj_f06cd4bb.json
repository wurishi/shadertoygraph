{"ver":"0.1","info":{"id":"NsdyRj","date":"1653749714","viewed":113,"name":"Rotating Holey Cube","username":"Rrrrichard","description":"test","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf","neuralnetwork"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 200\n#define MAX_DIST 1e5\n#define EPS .0001\n#define PI 3.141592653\n\nvec3 rotate(vec3 v, float a, float b, float c)\n{\n    //rotational matrix from wikipedia\n    vec3 new_v = vec3(\n        cos(b)*cos(c)*v.x \n            + (sin(a)*sin(b)*cos(c) - cos(a)*sin(c))*v.y \n            + (cos(a)*sin(b)*cos(c) + sin(a)*sin(c))*v.z,\n            \n        cos(b)*sin(c)*v.x \n            + (sin(a)*sin(b)*sin(c) + cos(a)*cos(c))*v.y \n            + (cos(a)*sin(b)*sin(c) - sin(a)*cos(c))*v.z,\n            \n        -sin(b)*v.x + sin(a)*cos(b)*v.y + cos(a)*cos(b)*v.z\n    );\n    return new_v; \n}\n\nfloat cubeDist(vec3 eye, vec3 centre, vec3 size)\n{\n    \n    vec3 delta = eye - centre;\n    float theta = PI / 4.; \n    //float theta = iTime; \n\n    //vec3 new_delta_xz = vec3(delta.x *cos(theta)+ delta.z *sin(theta),\n    //    delta.y,\n    //    delta.x *-sin(theta)+ delta.z *cos(theta));\n    \n    //vec3 new_delta_xz = rotate(delta, iTime, iTime, iTime);\n\n    vec3 new_delta_xz = rotate(delta, theta+iTime, 0.*theta, theta);\n    \n    eye = centre + new_delta_xz; \n    \n    vec3 o = abs(eye-centre) -size;\n    float ud = length(max(o,0.));\n    float n = max(max(min(o.x,0.),min(o.y,0.)), min(o.z,0.));\n    return ud+n;\n}\n\nfloat sphereDist(vec3 point, vec4 sphere)\n{\n    float sphere_dist = length(point - sphere.xyz)-sphere.w;\n    return sphere_dist;\n}\n\nfloat GetSceneDistance(vec3 point)\n{\n    vec4 sphere = vec4(0, 1., 6, 1.1+ 0.15* sin(iTime)); // (xyz, radius)\n    vec3 cube_center = vec3(0, 1., 6.);\n    vec3 cube_size = vec3(1.,1.,1.) * 0.9;\n  \n    float sphere_dist = sphereDist(point, sphere);\n    float cube_dist = cubeDist(point, cube_center, cube_size);\n    float obj_dist = max(-sphere_dist, cube_dist);\n    \n    float plane_dist = point.y + 0.8; \n    \n    float d = min(obj_dist, plane_dist); \n    \n    return d; \n}\n\nfloat RayMarch(vec3 ray_origin, vec3 ray_dir)\n{\n    float d = 0.; \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ray_origin + ray_dir * d;\n        float ds = GetSceneDistance(p); \n        d += ds; \n        if(d > MAX_DIST || ds < EPS) \n            break;  // hit object or out of scene\n    }\n    return d; \n}\n\nvec3 GetNormal(vec3 point)\n{\n    float d = GetSceneDistance(point); \n    vec2 e = vec2(0.01, 0); \n    vec3 n = d - vec3(\n        GetSceneDistance(point - e.xyy),\n        GetSceneDistance(point - e.yxy),\n        GetSceneDistance(point - e.yyx)\n    );\n    \n    return normalize(n); \n}\n\nfloat GetLight(vec3 point)\n{    \n    vec3 light_pos = vec3(3, 5, 2); \n     \n    vec3 to_light = normalize(light_pos - point); \n    vec3 normal = GetNormal(point); \n    \n    float intensity = 0.6;\n    float light = intensity * clamp(dot(to_light, normal), 0., 1.); \n    \n    float d = RayMarch(point+normal*2.*EPS, to_light);\n    \n    if (d < length(light_pos - point))\n        light *= 0.6;\n    \n    return light;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.x;\n\n    // Time varying pixel color\n    vec3 ray_origin = vec3(0, 1, -1);\n    vec3 ray_dir = normalize(vec3(uv.x, uv.y, 1.));\n   \n    float d = RayMarch(ray_origin, ray_dir);\n    \n    vec3 point = ray_origin + d * ray_dir; \n   \n    float diffuse_light = GetLight(point); \n    \n    vec3 col = vec3(diffuse_light);\n    \n    col = pow(col, vec3(0.4545)); // Gamma correction\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}