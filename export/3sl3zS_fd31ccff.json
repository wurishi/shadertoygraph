{"ver":"0.1","info":{"id":"3sl3zS","date":"1546728561","viewed":152,"name":"Music Bowl","username":"slimyfrog","description":"Using fft and waveform to affect shapes","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["music"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGzn","filepath":"/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","previewfilepath":"/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DISTANCE   50.0\n#define MIN_DISTANCE   0.01\n\n\nmat3 rMatrix;\nmat3 ballMatrix;\nvec2 uv;\n\nmat3 rotateMat(float roll, float pitch, float yaw)\n{\n    float cp = cos(pitch);\n    float sp = sin(pitch);\n    float sr = sin(roll);\n    float cr = cos(roll);\n    float sy = sin(yaw);\n    float cy = cos(yaw);\n\n    return mat3(cp * cy, (sr * sp * cy) - (cr * sy), (cr * sp * cy) + (sr * sy),\n                cp * sy, (sr * sp * sy) + (cr * cy), (cr * sp * sy) - (sr * cy),\n                -sp, sr * cp, cr * cp);\n}\n\n// smooth min from iq\nfloat smoothmin( float a, float b)\n{\n    float h = max( 1.0-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*h*(1.0/6.0);\n}\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nfloat sdPlane(vec3 p)\n{    \n    // the sound texture is 512x2\n    int tx = int(length(p) * 5.0);\n\n    float fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n    \n    float wave = texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\n    \n\n    float dist;\n    if (length(p) < 4.0)\n    {\n        dist = p.y + (1.0 - fft * 1.0);\n    }\n   \telse\n    {\n        dist = p.y + (1.0 - fft * -2.0);\n    }\n    return dist;\n}\n\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nfloat sdBox( vec3 p, vec3 size)\n{\n  vec3 d = abs(p) - size;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nfloat sceneDf(vec3 p)\n{\n    int tx = int(uv.x*512.0);\n    float fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n    float wave = texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\n    \n    float dist = sdPlane(p);\n    \n    vec3 sp = ballMatrix * p/2.0;\n    float shapeDist = mix(sdBox(sp, vec3(wave)), sdTorus(sp, vec2(1.0 * wave, 0.5 * wave)),\n                         4.0 - wave * 4.0);\n\n    dist = smoothmin(dist, shapeDist);\n    return dist;\n}\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nvec3 calcNormal(vec3 p)\n{\n    float e = 0.02f;\n    \n    vec3 normal;\n    normal.x = sceneDf(vec3(p.x + e,p.y,p.z)) - sceneDf(vec3(p.x - e, p.y, p.z));\n    normal.y = sceneDf(vec3(p.x,p.y + e,p.z)) - sceneDf(vec3(p.x, p.y - e, p.z));\n    normal.z = sceneDf(vec3(p.x,p.y,p.z + e)) - sceneDf(vec3(p.x, p.y, p.z - e));\n    \n    return normalize(normal);\n}\n\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nfloat calcShadow(vec3 pt, vec3 dir)\n{\n    float shade = 1.0;\n\tfloat t = 0.001;\n    while(t < 6.0)\n    {\n        float dist = sceneDf(pt + dir * t);\n        t += dist;\n        shade = smoothmin(shade, 4.0 * dist/t);\n        if (dist <= 0.0001){\n            break;\n        }\n    }\n    return clamp(shade, 0.0, 1.0);\n}\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nvec3 processLighting(vec3 baseColor, vec3 eyePos, vec3 surfacePoint)\n{\n    vec3 normal = calcNormal(surfacePoint);\n    vec3 diffuseDir = normalize(vec3(sin(iTime),-1.0,cos(iTime)));\n    \n    float shaded = calcShadow(surfacePoint, -diffuseDir);\n    \n    float diffDot = clamp(dot(-diffuseDir, normal), 0.0, 1.0);\n    vec3 diffuse = (diffDot * vec3(0.0,1.0,1.0)) * shaded;\n            \n    vec3 fillDir = normalize(-diffuseDir * vec3(-1.0, 0.0, -1.0));\n    float fillDot = clamp(dot(fillDir, normal), 0.0, 1.0);\n    vec3 fill = (fillDot * vec3(1.0,1.0,0.4));\n  \n    vec3 color = vec3(0.1, 0.1, 0.1);\n    surfacePoint *= rMatrix;\n\n    vec3 material = vec3(1.0 - 0.5*sin(surfacePoint.x), 1.0 - 0.5*cos(iTime), 1.0 - 0.5*sin(surfacePoint.z));\n    vec3 material2 = normal;\n    if (length(surfacePoint) > 4.0){\n        material = diffuseDir * vec3(sin(iTime)*1.5, 1.2, cos(iTime)*1.5);\n    }\n    else{\n        material = mix(material , material2 , clamp(surfacePoint.y + 1.0, 0.0, 1.0));\n    }\n    return material * (diffuse + fill);\n}\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nvec3 marchRay(vec3 eyePos,vec3 dir, vec2 uv)\n{\n    vec3 color =  vec3(0.8) + dir;\n    float t = 0.0001;\n    while(t < MAX_DISTANCE)\n    {\n        vec3 currentPoint = eyePos + (t * dir);\n        float dist = sceneDf(currentPoint);\n        if(dist <= MIN_DISTANCE)\n        {\n            color = processLighting(vec3(0.1, 0.1, 0.1), eyePos, currentPoint);\n            break;\n        }\n        t += dist;\n    }\n    return color;\n}\n\n\n\n//------------------------------------------------------------\n//\n//------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // create pixel coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n     \n    rMatrix = rotateMat(0.0, iTime, 0.0);\n    ballMatrix = rotateMat(iTime, 0.0, iTime);\n     // camera\t\n\tvec3 eye = vec3(0.0,  3.0, 11.0);\n    vec3 lookat = vec3( 0.0, -0.2, 0.0 );\n    // camera matrix\n    vec3 forward = normalize( lookat - eye );\n    vec3 right = normalize( cross(forward,vec3(0.0,1.0,0.0) ) );\n    vec3 up = normalize( cross(right, forward));\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    // create view ray\n    vec3 dir = normalize( p.x*right + p.y*up + 3.5*forward );\n       \n    vec3 color = marchRay(eye, dir, uv);\n    color = pow(color, vec3(1.0/2.2));\n    fragColor = vec4(color,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}