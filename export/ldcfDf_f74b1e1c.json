{"ver":"0.1","info":{"id":"ldcfDf","date":"1527001968","viewed":350,"name":"Broken Cornell Box (PathTracing)","username":"fjavifabre","description":"Broken version of my previous shader: [url]https://www.shadertoy.com/view/XdcBWX[/url]\n\nUsing the random function from: [url]https://www.shadertoy.com/view/XstBzM[/url]","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["cornell","trace","path","render","broken"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by inigo quilez - iq/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n// Display : average down and do gamma adjustment\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 col = vec3(0.0);\n    \n    if( iFrame>0 )\n    {\n        col = texture( iChannel0, uv ).xyz;\n        col = pow( col, vec3(0.4545) );\n    }\n    \n    // color grading and vigneting\n    col = pow( col, vec3(0.8,0.85,0.9) );\n    \n    col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415927\n#define N_TRIANGLES 32\n#define INF 1000000.\n#define USE_ENV 0\n\n\n// Cornell Box colors\n#define CB_WHITE vec3(.7295, .7355, .729)\n#define CB_RED vec3(.611, .0555, .062)\n#define CB_GREEN vec3(.117, .4125, .115)\n#define CB_LIGHT vec3(16.86, 8.76 +2., 3.2 + .5)\n\n\n/* ray information */\nstruct Ray\n{\n    vec3 o;\n    vec3 d;\n};\n    \nstruct Triangle\n{\n    vec3 v0, v1, v2;\n    vec3 albedo;\n    bool isLight;\n    \n};\n\nstruct Intersection // t = -1 -> no intersection\n{\n\tfloat t;\n    vec3 pos;\n    vec3 albedo;\n    vec3 normal;\n    bool isLight;\n    \n    \n};\n\nIntersection IntersectTriangles(Triangle[N_TRIANGLES] tr, Ray r)\n{\n    Intersection its;\n    its.t = INF;\n    \n    // Temp data\n    vec3 Barycentric;\n    float lastT = INF;\n    int tIndex = -1;\n    \n    for(int i = 0; i<N_TRIANGLES; i++)\n    {\n    \t// Möller–Trumbore intersection algorithm\n        vec3 p0 = tr[i].v0;\n        vec3 e0 = tr[i].v1 - tr[i].v0;\n        vec3 e1 = tr[i].v2 - tr[i].v0;\n        vec3 pv = cross(r.d, e1);\n        \n        \n\n        float det = dot(e0, pv);\n        if(det > 1E-2)\n        {\n            vec3 tv = r.o - p0;\n            vec3 qv = cross(tv, e0);\n\n            vec4 uvt;\n            uvt.x = dot(tv, pv); \t// U\n            uvt.y = dot(r.d, qv);\t// V\n            uvt.z = dot(e1,qv); \t// T\n            uvt.xyz = uvt.xyz / (det);\n            uvt.w = 1. - uvt.x - uvt.y;\n            \n\n            \n\n            if(all(greaterThanEqual(uvt, vec4(0.))) && uvt.z < lastT)\n            {\n                Barycentric = uvt.ywx;\n                tIndex = i;\n                lastT =  uvt.z;\n                \n            }\n        }\n    }\n    \n    if(tIndex > -1)\n    {\n        \n        its.t = lastT;\n        its.pos = tr[tIndex].v2 * Barycentric.x +\n         \t\t\ttr[tIndex].v0 * Barycentric.y +\n            \t\ttr[tIndex].v1 * Barycentric.z;\n        \n        its.normal = normalize(\n            cross(\n                tr[tIndex].v1 - tr[tIndex].v0,\n                tr[tIndex].v2 - tr[tIndex].v0                \n            )\n        );\n        \n        \n        its.albedo = tr[tIndex].albedo;\n        \n        its.isLight = tr[tIndex].isLight;\n    }\n    return its;\n}\n\n\n/* Camera information */\nstruct Camera\n{\n    vec3 origin;\n    vec3 u,v,w;\n    \n    float fov;\n};\n\nCamera GenerateCamera(vec3 o, vec3 d, vec3 up, float fov)\n{\n    Camera c;\n    \n    c.origin = o;\n    c.w = normalize(d);\n    c.u = normalize(cross(c.w,up));\n    c.v = normalize(cross(c.u,c.w));\n    c.fov = fov;\n    \n  \treturn c;\n}\n\n\n\nvoid Vector2Spherical(vec3 v, inout float theta, inout float phi)\n{\n\ttheta = acos(v.y);\n\tphi = atan(v.x, v.z);\n\t//phi = (phi < 0.0) ? (phi + 2.0*PI) : phi;\n}\n\nvoid Vector2SphericalNormalized(vec3 v, inout float theta, inout float phi)\n{\n\ttheta = acos(v.y) / PI;\n\tphi = atan(v.x, v.z) / (2.0*PI);\n\t//phi = (phi < 0.0) ? (phi + 2.0*PI)/(2.0*PI) : (phi/(2.0*PI));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float seed;\t//seed initialized in main\n//float rnd() { return fract(sin(seed++)*43758.5453123); }\n#define RAND_PERIOD_SCALE 78.233\n#define RAND_SEED_SCALE 3758.5453\nfloat rnd() \n{\n\tfloat r = fract(sin(seed) * RAND_SEED_SCALE);\n\tseed += 43758.5453;\n    return r;    \n}\n\nvec2 rnd2()\n{\n\treturn vec2(\n    \tfract(sin((seed++)+78.233)*43758.5453123),\n    \tfract(sin((seed++)+10.873)*43758.5453123)\n    );\n}\n\nRay CameraGetRay(Camera cam, vec2 point)\n{\n    float halfAngle = radians(cam.fov) / 2.;\n\tfloat hSize = tan(halfAngle);\n\tfloat d = 1.0;\n\tfloat left = -hSize;\n\tfloat right = hSize;\n\tfloat top = hSize;\n\tfloat bottom = -hSize;\n\t\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n\t\n\tfloat x = bottom+(top-bottom)*point.y ;\n\tfloat y = (left+(right-left)*point.x)* aspectRatio;\n\tvec3 dir = (d*cam.w) + x*cam.v + y*cam.u;\n\n\tRay ray = Ray(cam.origin, normalize(dir));\n    \n    return ray;\n}\n\nvec3 generateCosineDirection(vec3 normal)\n{\n    vec3 n = normalize(normal);\n    vec2 r = rnd2();\n\n    vec3 uu = normalize(cross(n, vec3(0.0, 1.0, 1.0)));\n    vec3 vv = cross(uu, n);\n\n    float ra = sqrt(r.y);\n    float rx = ra * cos(6.2831 * r.x);\n    float ry = ra * sin(6.2831 * r.x);\n    float rz = sqrt(1.0 - r.y);\n    vec3 rr = vec3(rx * uu + ry * vv + rz * n);\n\n    return normalize(rr);\n}\n\nTriangle[N_TRIANGLES] CreateScene()\n{\n \treturn Triangle[N_TRIANGLES]\n        (\n            // Floor start\n            Triangle(\n                vec3(552.8,0,0),\n                vec3(0,0,0),\n                vec3(0,0,559.2),\n                CB_WHITE,\n                false\n            ),\n            Triangle(\n                vec3(552.8,0,0),\n                vec3(0.,0,559.2),\n                vec3(549.6,0,559.2),\n                CB_WHITE,\n                false\n            ),\n            // Floor end\n            \n            // Back wall start\n            Triangle(\n                vec3(549.6,0,559.2),\n                vec3(0.,0,559.2),\n                vec3(0,548.8,559.2),\n                CB_WHITE,\n                false\n            ),\n            Triangle(\n                vec3(549.6,0,559.2),\n                vec3(0,548.8,559.2),\n                vec3(556.0, 548.8, 559.2),\n                CB_WHITE,\n                false\n            ),\n            // Back wall end\n            \n            // Left wall start\n            Triangle(\n                vec3(552.8, 0.0, 0.0),\n                vec3(549.6, 0.0, 559.2),\n                vec3(556.0, 548.8, 559.2),\n                CB_RED,\n                false\n            ),\n            Triangle(\n                vec3(552.8, 0.0, 0.0),\n                vec3(556.0, 548.8, 559.2),\n                vec3(556.0, 548.8, 0.0),\n                CB_RED,\n                false\n            ),\n            // Left wall end\n            \n            // Right wall start\n            Triangle(\n                vec3(0.0,   0.0, 559.2),\n                vec3(0.0,   0.0,   0.0),\n                vec3(0.0, 548.8,   0.0),\n                CB_GREEN,\n                false\n            ),\n            Triangle(\n                vec3(0.0,   0.0, 559.2),\n                vec3(0.0, 548.8,   0.0),\n                vec3(0.0, 548.8, 559.2),\n                CB_GREEN,\n                false\n            ),\n            // Right wall end\n            \n            // Short block start\n            Triangle(\n                vec3(130.0, 165.0,  65.0),\n                vec3(82.0, 165.0, 225.0),\n                vec3(240.0, 165.0, 272.0),\n                CB_WHITE,\n                false\n            ),\n            Triangle(\n                vec3(130.0, 165.0,  65.0),\n                vec3(240.0, 165.0, 272.0),\n                vec3(290.0, 165.0, 114.0),\n                CB_WHITE,\n                false\n            ),\n            \n            Triangle(\n                vec3(290.0,   0.0, 114.0),\n                vec3(290.0, 165.0, 114.0),\n                vec3(240.0, 165.0, 272.0),\n                CB_WHITE,\n                false\n            ),\n            Triangle(\n                vec3(290.0,   0.0, 114.0),\n                vec3(240.0, 165.0, 272.0),\n                vec3(240.0,   0.0, 272.0),\n                CB_WHITE,\n                false\n            ),\n            \n            Triangle(\n                vec3(130.0,   0.0,  65.0),\n                vec3(130.0, 165.0,  65.0),\n                vec3(290.0, 165.0, 114.0),\n                CB_WHITE,\n                false\n            ),\n            Triangle(\n                vec3(130.0,   0.0,  65.0),\n                vec3(290.0, 165.0, 114.0),\n                vec3(290.0,   0.0, 114.0),\n                CB_WHITE,\n                false\n            ),\n            \n            Triangle(\n                vec3(82.0,   0.0, 225.0),\n                vec3(82.0, 165.0, 225.0),\n                vec3(130.0, 165.0,  65.0),\n                CB_WHITE,\n                false\n            ),\n            Triangle(\n                vec3(130.0,   0.0,  65.0),\n                vec3(82.0,   0.0, 225.0),\n                vec3(130.0, 165.0, 65.0),\n                CB_WHITE,\n                false\n            ),\n            \n            Triangle(\n                vec3(240.0,   0.0, 272.0),\n                vec3(240.0, 165.0, 272.0),\n                vec3(82.0, 165.0, 225.0),\n                CB_WHITE,\n                false\n            ),\n            Triangle(\n                \n                vec3(82.0,   0.0, 225.0),\n                vec3(240.0,   0.0, 272.0),\n                vec3(82.0, 165.0, 225.0),\n                CB_WHITE,\n                false\n            ),\n            // Short block end\n            \n            // Tall block start\n            Triangle(\n                vec3(423.0, 330.0, 247.0),\n                vec3(265.0, 330.0, 296.0),\n                vec3(314.0, 330.0, 456.0),\n                CB_WHITE,\n                false\n            ),\n            Triangle(\n                vec3(423.0, 330.0, 247.0),\n                vec3(314.0, 330.0, 456.0),\n                vec3(472.0, 330.0, 406.0),\n                CB_WHITE,\n                false\n            ),\n            \n            Triangle(\n                vec3(423.0,   0.0, 247.0),\n                vec3(423.0, 330.0, 247.0),\n                vec3(472.0, 330.0, 406.0),\n                CB_WHITE,\n                false\n            ),\n            Triangle(\n\t\t\t\tvec3(423.0,   0.0, 247.0),\n                vec3(472.0, 330.0, 406.0),\n                vec3(472.0,   0.0, 406.0),\n                CB_WHITE,\n                false\n            ),\n            \n            Triangle(\n                vec3(472.0,   0.0, 406.0),\n                vec3(472.0, 330.0, 406.0),\n                vec3(314.0, 330.0, 456.0),\n                CB_WHITE,\n                false\n            ),\n            Triangle(\n\t\t\t\tvec3(472.0,   0.0, 406.0),\n                vec3(314.0, 330.0, 456.0),\n                vec3(314.0,   0.0, 456.0),\n                CB_WHITE,\n                false\n            ),\n            \n            Triangle(\n                vec3(314.0,   0.0, 456.0),\n                vec3(314.0, 330.0, 456.0),\n                vec3(265.0, 330.0, 296.0),\n                CB_WHITE,\n                false\n            ),\n            Triangle(\n\t\t\t\tvec3(314.0,   0.0, 456.0),\n                vec3(265.0, 330.0, 296.0),\n                vec3(265.0,   0.0, 296.0),\n                CB_WHITE,\n                false\n            ),\n            //\n            Triangle(\n                vec3(265.0,   0.0, 296.0),\n                vec3(265.0, 330.0, 296.0),\n                vec3(423.0, 330.0, 247.0),\n                CB_WHITE,\n                false\n            ),\n            Triangle(\n\t\t\t\tvec3(265.0,   0.0, 296.0),\n                vec3(423.0, 330.0, 247.0),\n                vec3(423.0,   0.0, 247.0),\n                CB_WHITE,\n                false\n            ),\n            // Tall block end\n            \n            // Ceiling start\n            Triangle(\n                vec3(556.0, 548.8, 0.0),\n                vec3(556.0, 548.8, 559.2),\n                vec3(0.0, 548.8, 559.2),\n                CB_WHITE,\n                false\n            ),\n            Triangle(\n                vec3(556.0, 548.8, 0.0),\n                vec3(0.0, 548.8, 559.2),\n                vec3(0.0, 548.8,   0.0),\n                CB_WHITE,\n                false\n            ),\n            // Ceiling end\n            \n            // Light start\n            Triangle(\n                vec3(343.0, 548.79, 227.0),\n                vec3(343.0, 548.79, 332.0),\n                vec3(213.0, 548.79, 332.0),\n                CB_LIGHT,\n                true\n            ),\n            Triangle(\n                vec3(343.0, 548.79, 227.0),\n                vec3(213.0, 548.79, 227.0),\n                vec3(213.0, 548.79, 332.0),\n                CB_LIGHT,\n                true\n            )\n            // Light end\n            \n            \n        );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tseed = sin(iTime * RAND_PERIOD_SCALE);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord + rnd2())/iResolution.xy;\n    \n\tvec3 camPos = vec3(278., 273., -800.);\n    \n    // Generate camera\n    Camera cam = GenerateCamera(\n       \tcamPos,\n        vec3(0,0,1),\n       \tvec3(0,1,0),\n    \t37.);\n    \n\n    \n    Ray ray = CameraGetRay(cam, uv);\n    \n\t\n    \n    Triangle triangles[N_TRIANGLES] =\n        CreateScene();\n    \n   \n   int pathDepth = 5;\n   vec3 Li = vec3(0.);\n   vec3 th = vec3(1.);\n    \n   for(int i = 0; i<pathDepth; i++)\n   {\n       Intersection its = IntersectTriangles(triangles, ray);\n       \n       if(its.t == INF)\n       {\n#if USE_ENV\n           Li += th * texture(iChannel0, ray.d).rgb;\n//#else\n//           Li += th * vec3(0.); \n#endif\n           break;\n       }\n       else if(!its.isLight)\n       {\n           th *= its.albedo;\n           ray.o = its.pos;\n           ray.d = generateCosineDirection(its.normal);\n       }\n       else\n       {\n           Li += th * its.albedo;\n           ray.o = its.pos;\n           ray.d = generateCosineDirection(its.normal);\n       }\n   }\n   vec3 col_acc;\n   vec2 coord = floor(fragCoord.xy);\n   if(all(equal(coord.xy,vec2(0)))) {\n       \tif(\n           any(notEqual(texture( iChannel3, vec2(0.5, 0.5)/iResolution.xy ).yz, iResolution.xy))\n          )\n        {\n            col_acc = vec3(iFrame, iResolution.xy);\n        }\n       \telse\n       \t{\n   \t\t\tcol_acc = texture( iChannel3, vec2(0.5, 0.5)/iResolution.xy ).xyz;\n        }\n    } else {\n        if(iFrame == 0 \n           || any(notEqual(texture( iChannel3, vec2(0.5, 0.5)/iResolution.xy ).yz, iResolution.xy))) \n        {\n            col_acc = Li;\n        } else {\n            int frame_start = int(texture( iChannel3, vec2(0.5, 0.5) / iResolution.xy ).x);\n            int spp1 = iFrame - frame_start;\n            int spp2 = 1;\n            vec3 col_new = Li;\n            col_acc = texture( iChannel3, fragCoord/iResolution.xy ).xyz;\n            col_acc = mix(col_acc, col_new, float(spp2)/float(spp1+spp2));\n        }\n    }\n    \n   \n\n    // Output to screen\n    fragColor = vec4(col_acc,1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}