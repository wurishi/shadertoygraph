{"ver":"0.1","info":{"id":"ls2cDW","date":"1492209941","viewed":93,"name":"RaymarchingSIG tweak","username":"Loeizd","description":"fun with sphere generation and iq's smin\nUSE THE MOUSE\nfrom http://9bitscience.blogspot.de/2013/07/raymarching-distance-fields_14.html","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","mouse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592653589\n\n// Raymarching\nconst float rayEpsilon = 0.001;\nconst float rayMin = 0.1;\nconst float rayMax = 1000.0;\nconst int rayCount = 32;\n\n// Camera\nvec3 eye = vec3(0., 0, -2.);\nvec3 front = vec3(0, 0, 1);\nvec3 right = vec3(1, 0, 0);\nvec3 up = vec3(0, 1, 0);\n\n// Colors\nvec3 lightColor = vec3(1.0, 1.0, 1.0);\nvec3 skyColor = vec3(0, 0, 0.1);\nvec3 shadowColor = vec3(0, 0, 0);\n\nfloat sphere( vec3 p, float s ) { return length(p)-s; }\nfloat reflectance(vec3 a, vec3 b) { return dot(normalize(a), normalize(b)) * 0.5 + 0.5; }\nvec2 kaelidoGrid(vec2 p) { return vec2(step(mod(p, 2.0), vec2(1.0))); }\nvec3 rotateY(vec3 v, float t) { \n\tfloat cost = cos(t); float sint = sin(t);\n  \treturn vec3(v.x * cost + v.z * sint, v.y, -v.x * sint + v.z * cost); }\nvec3 rotateX(vec3 v, float t) { \n\tfloat cost = cos(t); float sint = sin(t);\n  \treturn vec3(v.x, v.y * cost - v.z * sint, v.y * sint + v.z * cost); }\nvec3 rotateZ(vec3 p, float angle) { \n\tfloat c = cos(angle); float s = sin(angle);\n  \treturn vec3(c*p.x+s*p.y, -s*p.x+c*p.y, p.z); }\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat PlaceSpheres(int n, float d, vec3 ray, float t)\n{\n\tfor (int i = 0; i < n; i++)\n    {\n        float w = sin(float(i)*(998.33+iDate.w));\n        float ww = sin(float(i)*(9948.33+iDate.w));\n        float rand = texture(iChannel0, vec2(w,w+iDate.w)).x;\n        vec3 inpu = rotateY(vec3(w, ww, -1.5)+ray*t,iDate.w);/// DOES NOT DO ANYTHING\n        d = smin(d, sphere(inpu, w*.1+.2-.3*pow(fract(iDate.w*4.), 2.)), .1);//0.5*sin(float(i)*9348.32*.5+1.)));\n    }\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Ray from UV\n\tvec2 uv = fragCoord.xy * 2.0 / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ray = normalize(front + right * uv.x + up * uv.y);\n    \n    ray = rotateY(ray, iMouse.x / iResolution.x *2. - 1.);\n        \n    // Color\n    vec3 color = skyColor;\n    \n    // Animation\n    float translationTime = iTime * 0.5;\n    \n    // Raymarching\n    float t = 0.0;\n    for (int r = 0; r < rayCount; ++r)\n    {\n        // Ray Position\n        vec3 p = eye + ray * t;\n        \n        // Distance to Sphere\n        float d = 1.0;//sphere(p, 0.5);\n        //d = min(sphere(p+.2, 0.3),sphere((vec3(0, 1, -1.5)+ray*t),0.5));\n        d= PlaceSpheres(int(floor(sin(iDate.w*3.)*8.+15.)), d, ray, t);\n        \n        // Distance min or max reached\n        if (d < rayEpsilon || t > rayMax)\n        {\n            // Shadow from ray count\n            color = mix(lightColor, shadowColor, float(r) / float(rayCount));\n            \n            // Sky color from distance\n            color = mix(color, skyColor, smoothstep(rayMin, rayMax, t));\n            break;\n        }\n        \n        // Distance field step\n        t += d;\n    }\n    \n    // Hop\n\tfragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}