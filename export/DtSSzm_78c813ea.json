{"ver":"0.1","info":{"id":"DtSSzm","date":"1675805218","viewed":151,"name":"Ocean Simulator 4","username":"ianertson","description":"Use the mouse to look around :)","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","noise","raymarch","water","water","ocean","raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n#define T ((iTime + 15.52))\n#define ZERO (min(0, int(iTime)))\n\n#define NEAR 0.003\n#define FAR 300.0\n#define STEPS 60\n#define BOUNCES 2\n\n#define ID_NONE 0\n#define ID_WATER 1\n\n#define SAMPLE(var, id_) if (id_ != data.skip && var < dist) { data.id = id_; dist = var; }\n\n#define rgb(r, g, b) (vec3(r, g, b) / 255.0)\n\n#define SKY_COLOR (vec3(0.16, 0.6, 0.8))\n\n#define LIGHT_POINT 0\n#define LIGHT_AMBIENT 1\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n    float strength;\n    int type;\n};\n\nvec3 getLightDir(Light light, vec3 p) {\n    return normalize(light.pos);\n}\n\nvec3 getLightAtt(Light light, vec3 p, vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = max(0.0, dot(n, L));\n    float s = pow(light.strength, 2.0);\n    return light.color * NdotL * s;\n    //float dist = pow(distance(light.pos, p), 2.0);\n   // return light.color * NdotL * (s / max(0.0001, dist));\n}\n\nstruct Data {\n    vec3 point;\n    vec3 normal;\n    vec2 uv;\n    float dist;\n    float depth;\n    int id;\n    int skip;\n};\n\nvoid dataInit(inout Data data) {\n    data.point = vec3(0.0);\n    data.normal = vec3(0.0);\n    data.uv = vec2(0.0);\n    data.dist = FAR;\n    data.depth = 1.0;\n    data.id = 0;\n    data.skip = 0;\n}\n\nfloat waterSDF(inout Data data, vec3 p) {\n    float h = 0.0;\n    vec2 uv = p.xz*0.7;\n    const float seed = 1.29156;\n    float freq = 0.06;\n    float mt = T*0.5;\n    \n    uv += vec2(cos(mt-1.291692), sin(mt-0.321671));\n    \n    vec3 reg = noise23(uv*0.016, seed+9.28156);\n    \n    uv = mix(uv, (uv * 0.5) + (0.5*reg.xz), 0.5 + (reg.y*0.5));\n    \n    vec2 shiftLow = vec2(cos(mt+(reg.x*2.)), sin(mt+(reg.y*2.)))*2.;\n    vec2 shiftHigh = vec2(sin((mt*2.)-reg.y), cos((mt*2.)-reg.x))*(2.+length(reg));\n    \n    vec3 low0 = noise23((uv*0.01) + shiftLow, seed);\n    vec3 low1 = noise23((((uv*0.02) + (low0.xz*0.2))) + shiftLow, seed+6.31925);\n    vec3 high0 = noise23((uv*0.4) + shiftHigh, seed+10.912);\n    \n    vec3 ag = noise23((uv*2.)+shiftHigh+shiftLow, 3.20165);\n    ag = ((ag*0.1) + low0 + low1 + (high0*0.5)) / 4.0;\n    \n    vec3 r2 = fastNoise3(iChannel3, (uv*0.05)-((shiftHigh+shiftLow)*reg.z*0.2), 0.28915, 0.01);\n    \n    ag *= (((ag.z*0.33)+0.5)+(r2*1.6));\n    \n   \n    h += low0.x * 6.;\n    h += pow(low1.x*1.1, 4.2) * (32.0 + (reg.y*12.0));\n    h += high0.x * 2.;\n    \n    h *= length(reg);\n    \n    h *= length(ag);\n    \n    h /= 2.2;\n    \n    float dist = (p.y + 16.0) - h;\n    \n    dist /= (1.0+(h*0.2));\n    \n    return dist;\n}\n\nfloat getDist(inout Data data, vec3 p) {\n    float dist = FAR;\n    \n    float water = waterSDF(data, p);\n    \n    SAMPLE(water, ID_WATER);\n    \n    return dist;\n}\n\nvec3 getNormal(inout Data data, vec3 p, float s) {\n    vec2 e = vec2(s, 0.0);\n    return normalize(getDist(data, p) - vec3(\n        getDist(data, p - e.xyy),\n        getDist(data, p - e.yxy),\n        getDist(data, p - e.yyx)\n    ));\n}\n\nvec2 getUv(inout Data data) {\n    vec3 p = data.point;\n    vec3 n = data.normal;\n    vec2 uv = vec2(0.0);\n    uv = mix(uv, p.yx, abs(dot(n, vec3(0, 0, 1))));\n    uv = mix(uv, p.zx, abs(dot(n, vec3(0, 1, 0))));\n    uv = mix(uv, p.yz, abs(dot(n, vec3(1, 0, 0))));\n    return uv;\n}\n\nbool march(inout Data data, vec3 ro, vec3 rd) {\n    float dist = 0.0;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p);\n        dist += next;\n        if (abs(next) <= NEAR || abs(dist) >= FAR) break;\n    }\n    \n    dist = abs(dist);\n    if (dist >= FAR) return false;\n    \n    vec3 p = ro+rd*dist;\n    data.point = p;\n    data.dist = dist;\n    data.depth = dist / FAR;\n    data.normal = getNormal(data, p, 0.1);\n    data.uv = getUv(data);\n    \n    return true;\n}\n\nvec3 getAlbedoWater(inout Data data, vec2 uv) {\n    uv = data.point.xz;\n    vec3 col = vec3(0.0);\n    vec3 blue0 = rgb(23,77,103);\n    vec3 blue1 = rgb(115,148,174);\n    vec3 blue2 = rgb(5,129,189);\n    \n    vec3 n = noise23(uv*0.2, 0.32156);\n    \n    col = mix(col, blue0, n.x);\n    col = mix(col, blue1, n.y);\n    col = mix(col, blue2, n.z);\n    \n    col += SKY_COLOR / M_PI;\n    \n    return pow(col / M_PI, vec3(2.9));\n}\n\n//vec3 getAlbedo(inout Data data, vec2 uv) {\n  //  switch (data.id) {\n    //    case ID_WATER: return getAlbedoWater(data, uv); break;\n   //     \n   // }\n    \n   // return vec3(0.0);\n//}\n\nvec3 getClouds(inout Data data, vec3 ro, vec3 rd) {\n    vec2 uv = rd.xz / rd.y;\n    \n    float reg = 4.0*fastNoise(iChannel3, ((uv+0.3271)+vec2(0.0021, -0.2145))*0.02, 0.02);\n    \n    float shift = ((T*0.5+(reg))*0.2);\n    \n    uv.x += shift + (cos((reg*0.0001)*T)*0.5);\n    uv.y -= shift + (sin((reg*0.0001)*T)*0.5);\n    \n    float f = fastNoise(iChannel3, uv*0.5, 0.02);\n    \n    f *= (0.5+(reg/2.0));\n    \n    f = pow(f, 3.0);\n    \n    return vec3(f);\n}\n\nvec3 getSky(inout Data data, vec3 ro, vec3 rd) {\n    vec3 blue0 = SKY_COLOR;\n    vec3 col = blue0;\n    \n    vec3 clouds = getClouds(data, ro, rd);\n    \n    //col = mix(col, clouds, length(clouds));\n    col += clouds;\n    \n    \n    return col;\n}\n\nvec3 render(inout Data data, vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.0);\n    \n    Light light = Light(vec3(1, 4, 3), rgb(250,238,170), 2.0, LIGHT_AMBIENT);\n    \n   // vec3 sky = getSky(data, ro, rd);\n    \n    float pwr = 1.0;\n    float depth = 0.0;\n    \n    for (int i = ZERO; i < BOUNCES; i++) {\n        float dotup = max(0.0, dot(rd, vec3(0, 1, 0)));\n    \n        if (march(data, ro, rd)) {\n            vec2 uv = data.uv;\n            vec3 albedo = getAlbedoWater(data, uv);\n            vec3 diffuse = albedo / M_PI;\n            vec3 p = data.point;\n            vec3 n = data.normal;\n\n            vec3 L = getLightDir(light, p);\n\n\n\n            vec3 att = getLightAtt(light, p, n);\n\n            vec3 ref = normalize(reflect(L, n));\n            float VdotR = max(0.0, dot(rd, ref));\n            float spec = pow(VdotR, 32.0) / M_PI;\n\n            col += (diffuse + spec) * att;\n            \n            \n            vec3 reflectDir = normalize(reflect(rd, n));\n            ro = p + (n*0.5);\n            rd = reflectDir;\n            \n        } else {\n            depth = max(depth, data.depth) * max(0.0, 1.0 - dotup);\n            col += getSky(data, ro, rd)*pwr;\n            \n            break;\n        }\n        \n        depth = max(depth, data.depth) * max(0.0, 1.0 - dotup);\n        \n        \n        \n        pwr *= 0.05;\n        \n    }\n    col += (depth*depth);\n    return col;\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec2 m = (iMouse.xy-0.5*R.xy)/R.y;\n    \n    vec3 ro = vec3(0., 10., -5.0);\n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n   \n    ro.y += 9.0*(0.5+(0.5*cos(T*1.1)));\n    \n    if (iMouse.z > 0.01) {\n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n    } else {\n        rd.yz *= rot((0.2*cos(T*0.5)));\n        rd.xy *= rot((0.2*sin(T*0.5)));\n        \n    }\n    \n    Data data;\n    dataInit(data);\n    \n    col += render(data, ro, rd);\n    \n    col += (col*luma(col));\n    \n    col /= vec3(0.98278) + col;\n    \n    col = pow(col, vec3(1.0 / 2.2));\n    \n    \n    O = vec4(clamp(col, 0.0, 1.0), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define M_PI (3.1416)\n#define TAU (M_PI * 2.0)\n#define FU(v) (floatBitsToUint(v))\n\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat2(c, s, -s, c);\n}\n/*\nfloat log10(in float n) {\n\tconst float b10 = 1.0 / log2(10.0);\n\treturn log2(n) * b10;\n}*/\n\n//uint digit(uint v, uint i) { return (v / uint(pow(10.0, float(i) - 1.))) % 10u; }\n//uint diglen(uint v) { return uint(ceil(log10(float(v)))); }\n\nfloat hash(uvec2 x, uint seed) {\n    const uint G = 2207509273U;\n    uvec2 w = G * ((x>>1U) ^ (x.yx + seed));\n    return float(G * ((w.x + seed) ^ ((w.y+seed)>>3U))) * (1.0/float(0xffffffffU));\n}\n\nfloat hash2(vec2 x, float seed) { return hash(uvec2(FU(x.x), FU(x.y)), FU(seed)); }\n\nfloat fastNoise(sampler2D tex, vec2 p, float freq) {\n    float n = 0.0;\n    n += texture(tex, p*freq).r; freq *= 2.0;\n    n += 0.8*texture(tex, p*freq).r; freq *= 2.0;\n    n += 0.9*texture(tex, p*freq).r; freq *= 2.0;\n    n += 0.7*texture(tex, p*freq).r; freq *= 2.0;\n    n += 0.6*texture(tex, p*freq).r; freq *= 2.0;\n    n += 0.5*texture(tex, p*freq).r; freq *= 2.0;\n    return n / 6.0;\n}\n\nfloat fastNoise(sampler2D tex, vec2 p, float seed, float freq) {\n    p.x += seed;\n    p.y -= seed;\n    return fastNoise(tex, p, freq);\n}\n\nvec3 fastNoise3(sampler2D tex, vec2 p, float seed, float freq) {\n    float x = fastNoise(tex, p, seed, freq);\n    float y = fastNoise(tex, p, seed+3.2125, freq);\n    float z = fastNoise(tex, p, seed+8.9398, freq);\n    return vec3(x, y, z);\n}\n\nfloat noise(vec2 p, float seed) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p);\n    lv = lv * lv * (3.0 - 2.0 * lv);\n    float ab = mix(hash2(id, seed), hash2(id+vec2(1.0, 0.0), seed), lv.x);\n    float cd = mix(hash2(id+vec2(0.0, 1.0), seed), hash2(id+vec2(1.0, 1.0), seed), lv.x);\n    return mix(ab, cd, lv.y);\n}\n\nvec3 noise23(vec2 p, float seed) {\n    float x = noise(p, 2.2014 + seed);\n    float y = noise(p, 6.9915 + seed);\n    float z = noise(p, 9.9281 + seed);\n    return vec3(x, y, z);\n}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}","name":"Common","description":"","type":"common"}]}