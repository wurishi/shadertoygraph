{"ver":"0.1","info":{"id":"msfGDf","date":"1666884406","viewed":164,"name":"LBM but add Viscosity","username":"lyxnb2333","description":"First attempt at a lattice Boltzmann simulation in shader toy.\nThe classic Karman vortex street.\n4 pixels are required to store all 9 distribution functions per node.\nchange tau (viscosity) to make the fluid hard to move","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["vortex","karman","latticeboltzmann"],"hasliked":0,"parentid":"Xdy3zG","parentname":"LBM 1"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//fancy function to compute a color from the velocity\nvec4 computeColor(float normal_value)\n{\n    vec3 color;\n    if(normal_value<0.0) normal_value = 0.0;\n    if(normal_value>1.0) normal_value = 1.0;\n    float v1 = 1.0/7.0;\n    float v2 = 2.0/7.0;\n    float v3 = 3.0/7.0;\n    float v4 = 4.0/7.0;\n    float v5 = 5.0/7.0;\n    float v6 = 6.0/7.0;\n    //compute color\n    if(normal_value<v1)\n    {\n      float c = normal_value/v1;\n      color.x = 70.*(1.-c);\n      color.y = 70.*(1.-c);\n      color.z = 219.*(1.-c) + 91.*c;\n    }\n    else if(normal_value<v2)\n    {\n      float c = (normal_value-v1)/(v2-v1);\n      color.x = 0.;\n      color.y = 255.*c;\n      color.z = 91.*(1.-c) + 255.*c;\n    }\n    else if(normal_value<v3)\n    {\n      float c = (normal_value-v2)/(v3-v2);\n      color.x =  0.*c;\n      color.y = 255.*(1.-c) + 128.*c;\n      color.z = 255.*(1.-c) + 0.*c;\n    }\n    else if(normal_value<v4)\n    {\n      float c = (normal_value-v3)/(v4-v3);\n      color.x = 255.*c;\n      color.y = 128.*(1.-c) + 255.*c;\n      color.z = 0.;\n    }\n    else if(normal_value<v5)\n    {\n      float c = (normal_value-v4)/(v5-v4);\n      color.x = 255.*(1.-c) + 255.*c;\n      color.y = 255.*(1.-c) + 96.*c;\n      color.z = 0.;\n    }\n    else if(normal_value<v6)\n    {\n      float c = (normal_value-v5)/(v6-v5);\n      color.x = 255.*(1.-c) + 107.*c;\n      color.y = 96.*(1.-c);\n      color.z = 0.;\n    }\n    else\n    {\n      float c = (normal_value-v6)/(1.-v6);\n      color.x = 107.*(1.-c) + 223.*c;\n      color.y = 77.*c;\n      color.z = 77.*c;\n    }\n    return vec4(color.r/255.0,color.g/255.0,color.b/255.0,1.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //only one pixel out of 4 stores the moments\n    int ix = int(floor(fragCoord.x/2.0));\n    int iy = int(floor(fragCoord.y/2.0));\n    vec3 m = texture(iChannel0, (vec2(2*ix+1,2*iy+1)+0.5)/iResolution.xy).xyz;\n    float rho = m.x;\n    float vx  = m.y;\n    float vy  = m.z;\n    float U = sqrt(vx*vx+vy*vy);\n    fragColor = computeColor(U/0.2);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//map distribution functions to texture coordinates\n//4 texels are used to store the 9 distribution functions in one cell\n#define f0(x,y) texture(iChannel0, (vec2(2*x,2*y)+0.5)/iResolution.xy).r;\n#define f1(x,y) texture(iChannel0, (vec2(2*x,2*y)+0.5)/iResolution.xy).g;\n#define f2(x,y) texture(iChannel0, (vec2(2*x,2*y)+0.5)/iResolution.xy).b;\n#define f3(x,y) texture(iChannel0, (vec2(2*x+1,2*y)+0.5)/iResolution.xy).r;\n#define f4(x,y) texture(iChannel0, (vec2(2*x+1,2*y)+0.5)/iResolution.xy).g;\n#define f5(x,y) texture(iChannel0, (vec2(2*x+1,2*y)+0.5)/iResolution.xy).b;\n#define f6(x,y) texture(iChannel0, (vec2(2*x,2*y+1)+0.5)/iResolution.xy).r;\n#define f7(x,y) texture(iChannel0, (vec2(2*x,2*y+1)+0.5)/iResolution.xy).g;\n#define f8(x,y) texture(iChannel0, (vec2(2*x,2*y+1)+0.5)/iResolution.xy).b;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tau = 0.51;\n    //fragColor=texture(iChannel0, fragCoord/iResolution.xy);\n    int LatSizeX = int(iResolution.x/2.0);\n    int LatSizeY = int(iResolution.y/2.0);\n    //all 4 pixels do the same computations\n    int ix = int(floor(fragCoord.x/2.0));\n    int iy = int(floor(fragCoord.y/2.0));\n    if( ix >= LatSizeX || iy >= LatSizeY )\n    {\n        return;\n    }\n    int itx = int(fragCoord.x) - 2*ix;\n    int ity = int(fragCoord.y) - 2*iy;\n    float f0,f1,f2,f3,f4,f5,f6,f7,f8; //distribution functions\n    float rho, vx, vy; //moments\n    f0 = f0(ix,iy);\n    if( (iFrame==0) || (f0==0.0) ) //initialisation\n    {\n        rho = 1.0;\n        // vx  = 0.1*(1.0+0.1*fragCoord.y/iResolution.y);\n        vx  = 0.03;\n        //vy  = 0.0;\n        vy = 0.06;\n        float sq_term = -1.5 * (vx*vx+vy*vy);\n        f0 = 4./9. *rho*(1. + sq_term);\n        f1 = 1./9. *rho*(1. + 3.*vx      + 4.5*vx*vx             + sq_term);\n        f2 = 1./9. *rho*(1. - 3.*vx      + 4.5*vx*vx             + sq_term);\n        f3 = 1./9. *rho*(1. + 3.*vy      + 4.5*vy*vy             + sq_term);\n        f4 = 1./9. *rho*(1. - 3.*vy      + 4.5*vy*vy             + sq_term);\n        f5 = 1./36.*rho*(1. + 3.*( vx+vy)+ 4.5*( vx+vy)*( vx+vy) + sq_term);\n        f6 = 1./36.*rho*(1. - 3.*( vx+vy)+ 4.5*( vx+vy)*( vx+vy) + sq_term);\n        f7 = 1./36.*rho*(1. + 3.*(-vx+vy)+ 4.5*(-vx+vy)*(-vx+vy) + sq_term);\n        f8 = 1./36.*rho*(1. - 3.*(-vx+vy)+ 4.5*(-vx+vy)*(-vx+vy) + sq_term);\n    }\n    else //normal time-step\n    {\n        //=== STREAMING STEP (PERIODIC) =======================\n        int xplus  = ((ix==LatSizeX-1) ? (0) : (ix+1));\n        int xminus = ((ix==0) ? (LatSizeX-1) : (ix-1));\n        int yplus  = ((iy==LatSizeY-1) ? (0) : (iy+1));\n        int yminus = ((iy==0) ? (LatSizeY-1) : (iy-1));\n        //f0 = f0( ix    ,iy    );\n        f1 = f1( xminus,iy    );\n        f2 = f2( xplus ,iy    );\n        f3 = f3( ix    ,yminus);\n        f4 = f4( ix    ,yplus );\n        f5 = f5( xminus,yminus);\n        f6 = f6( xplus ,yplus );\n        f7 = f7( xplus ,yminus);\n        f8 = f8( xminus,yplus );\n\n        //=== COMPUTE MOMENTS =================================\n        //density\n        rho = f0+f1+f2+f3+f4+f5+f6+f7+f8;\n        //velocity\n        vx = 1./rho*(f1-f2+f5-f6-f7+f8);\n        vy = 1./rho*(f3-f4+f5-f6+f7-f8);\n        /*\n        if(ix==0||ix==LatSizeX-1)//boundary condition\n        {\n            rho = 1.0;\n            vx = 0.1;\n            vy = 0.0;\n        }\n        */\n\n        //cylinder\n        /*\n        vec2 center = vec2(50.0,LatSizeY/2);\n        if( iMouse.w>0.01 )\n            center = iMouse.xy/2.0;\n        if( distance(center,vec2(ix,iy)) < 10.0 )\n        {\n            rho = 1.0;\n            vx  = 0.0;\n            vy  = 0.0;\n        }\n        */\n        \n\n        if( iMouse.w>0.01 ){        \n            vec2 center = iMouse.xy/2.0;\n            if( distance(center,vec2(ix,iy)) < 10.0 )\n            {\n                rho = 1.0;\n                vx  = 0.0;\n                vy  = 0.0;\n                // w = 1.0;\n            }\n        }\n        \n\n        float sq_term = -1.5 * (vx*vx+vy*vy);\n        float f0eq = 4./9. *rho*(1. + sq_term);\n        float f1eq = 1./9. *rho*(1. + 3.*vx      + 4.5*vx*vx             + sq_term);\n        float f2eq = 1./9. *rho*(1. - 3.*vx      + 4.5*vx*vx             + sq_term);\n        float f3eq = 1./9. *rho*(1. + 3.*vy      + 4.5*vy*vy             + sq_term);\n        float f4eq = 1./9. *rho*(1. - 3.*vy      + 4.5*vy*vy             + sq_term);\n        float f5eq = 1./36.*rho*(1. + 3.*( vx+vy)+ 4.5*( vx+vy)*( vx+vy) + sq_term);\n        float f6eq = 1./36.*rho*(1. - 3.*( vx+vy)+ 4.5*( vx+vy)*( vx+vy) + sq_term);\n        float f7eq = 1./36.*rho*(1. + 3.*(-vx+vy)+ 4.5*(-vx+vy)*(-vx+vy) + sq_term);\n        float f8eq = 1./36.*rho*(1. - 3.*(-vx+vy)+ 4.5*(-vx+vy)*(-vx+vy) + sq_term);\n        //=== RELAX TOWARD EQUILIBRIUM ========================\n        f0 = f0 + (f0eq - f0) / tau;\n        f1 = f1 + (f1eq - f1) / tau;\n        f2 = f2 + (f2eq - f2) / tau;\n        f3 = f3 + (f3eq - f3) / tau;\n        f4 = f4 + (f4eq - f4) / tau;\n        f5 = f5 + (f5eq - f5) / tau;\n        f6 = f6 + (f6eq - f6) / tau;\n        f7 = f7 + (f7eq - f7) / tau;\n        f8 = f8 + (f8eq - f8) / tau;\n        //f0 = (1.-w) * f0 + w * f0eq;\n        //f1 = (1.-w) * f1 + w * f1eq;\n        //f2 = (1.-w) * f2 + w * f2eq;\n        //f3 = (1.-w) * f3 + w * f3eq;\n        //f4 = (1.-w) * f4 + w * f4eq;\n        //f5 = (1.-w) * f5 + w * f5eq;\n        //f6 = (1.-w) * f6 + w * f6eq;\n        //f7 = (1.-w) * f7 + w * f7eq;\n        //f8 = (1.-w) * f8 + w * f8eq;\n    }\n    if(itx==0&&ity==0)//stores f0,f1,f2\n        fragColor.rgb = vec3(f0,f1,f2);\n    else if(itx==1&&ity==0)//stores f3,f4,f5\n        fragColor.rgb = vec3(f3,f4,f5);\n    else if(itx==0&&ity==1)//stores f6,f7,f8\n        fragColor.rgb = vec3(f6,f7,f8);\n    else //stores rho,vx,vy\n        fragColor.rgb = vec3(rho,vx,vy);\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//map distribution functions to texture coordinates\n//4 texels are used to store the 9 distribution functions in one cell\n#define f0(x,y) texture(iChannel0, (vec2(2*x,2*y)+0.5)/iResolution.xy).r;\n#define f1(x,y) texture(iChannel0, (vec2(2*x,2*y)+0.5)/iResolution.xy).g;\n#define f2(x,y) texture(iChannel0, (vec2(2*x,2*y)+0.5)/iResolution.xy).b;\n#define f3(x,y) texture(iChannel0, (vec2(2*x+1,2*y)+0.5)/iResolution.xy).r;\n#define f4(x,y) texture(iChannel0, (vec2(2*x+1,2*y)+0.5)/iResolution.xy).g;\n#define f5(x,y) texture(iChannel0, (vec2(2*x+1,2*y)+0.5)/iResolution.xy).b;\n#define f6(x,y) texture(iChannel0, (vec2(2*x,2*y+1)+0.5)/iResolution.xy).r;\n#define f7(x,y) texture(iChannel0, (vec2(2*x,2*y+1)+0.5)/iResolution.xy).g;\n#define f8(x,y) texture(iChannel0, (vec2(2*x,2*y+1)+0.5)/iResolution.xy).b;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tau = 0.51;\n    //fragColor=texture(iChannel0, fragCoord/iResolution.xy);\n    int LatSizeX = int(iResolution.x/2.0);\n    int LatSizeY = int(iResolution.y/2.0);\n    //all 4 pixels do the same computations\n    int ix = int(floor(fragCoord.x/2.0));\n    int iy = int(floor(fragCoord.y/2.0));\n    if( ix >= LatSizeX || iy >= LatSizeY )\n    {\n        return;\n    }\n    int itx = int(fragCoord.x) - 2*ix;\n    int ity = int(fragCoord.y) - 2*iy;\n    float f0,f1,f2,f3,f4,f5,f6,f7,f8; //distribution functions\n    float rho, vx, vy; //moments\n    f0 = f0(ix,iy);\n    if( (iFrame==0) || (f0==0.0) ) //initialisation\n    {\n        rho = 1.0;\n        // vx  = 0.1*(1.0+0.1*fragCoord.y/iResolution.y);\n        vx  = 0.03;\n        //vy  = 0.0;\n        vy = 0.06;\n        float sq_term = -1.5 * (vx*vx+vy*vy);\n        f0 = 4./9. *rho*(1. + sq_term);\n        f1 = 1./9. *rho*(1. + 3.*vx      + 4.5*vx*vx             + sq_term);\n        f2 = 1./9. *rho*(1. - 3.*vx      + 4.5*vx*vx             + sq_term);\n        f3 = 1./9. *rho*(1. + 3.*vy      + 4.5*vy*vy             + sq_term);\n        f4 = 1./9. *rho*(1. - 3.*vy      + 4.5*vy*vy             + sq_term);\n        f5 = 1./36.*rho*(1. + 3.*( vx+vy)+ 4.5*( vx+vy)*( vx+vy) + sq_term);\n        f6 = 1./36.*rho*(1. - 3.*( vx+vy)+ 4.5*( vx+vy)*( vx+vy) + sq_term);\n        f7 = 1./36.*rho*(1. + 3.*(-vx+vy)+ 4.5*(-vx+vy)*(-vx+vy) + sq_term);\n        f8 = 1./36.*rho*(1. - 3.*(-vx+vy)+ 4.5*(-vx+vy)*(-vx+vy) + sq_term);\n    }\n    else //normal time-step\n    {\n        //=== STREAMING STEP (PERIODIC) =======================\n        int xplus  = ((ix==LatSizeX-1) ? (0) : (ix+1));\n        int xminus = ((ix==0) ? (LatSizeX-1) : (ix-1));\n        int yplus  = ((iy==LatSizeY-1) ? (0) : (iy+1));\n        int yminus = ((iy==0) ? (LatSizeY-1) : (iy-1));\n        //f0 = f0( ix    ,iy    );\n        f1 = f1( xminus,iy    );\n        f2 = f2( xplus ,iy    );\n        f3 = f3( ix    ,yminus);\n        f4 = f4( ix    ,yplus );\n        f5 = f5( xminus,yminus);\n        f6 = f6( xplus ,yplus );\n        f7 = f7( xplus ,yminus);\n        f8 = f8( xminus,yplus );\n\n        //=== COMPUTE MOMENTS =================================\n        //density\n        rho = f0+f1+f2+f3+f4+f5+f6+f7+f8;\n        //velocity\n        vx = 1./rho*(f1-f2+f5-f6-f7+f8);\n        vy = 1./rho*(f3-f4+f5-f6+f7-f8);\n        /*\n        if(ix==0||ix==LatSizeX-1)//boundary condition\n        {\n            rho = 1.0;\n            vx = 0.1;\n            vy = 0.0;\n        }\n        */\n\n        //cylinder\n        /*\n        vec2 center = vec2(50.0,LatSizeY/2);\n        if( iMouse.w>0.01 )\n            center = iMouse.xy/2.0;\n        if( distance(center,vec2(ix,iy)) < 10.0 )\n        {\n            rho = 1.0;\n            vx  = 0.0;\n            vy  = 0.0;\n        }\n        */\n        \n\n        if( iMouse.w>0.01 ){        \n            vec2 center = iMouse.xy/2.0;\n            if( distance(center,vec2(ix,iy)) < 10.0 )\n            {\n                rho = 1.0;\n                vx  = 0.0;\n                vy  = 0.0;\n                // w = 1.0;\n            }\n        }\n        \n\n        float sq_term = -1.5 * (vx*vx+vy*vy);\n        float f0eq = 4./9. *rho*(1. + sq_term);\n        float f1eq = 1./9. *rho*(1. + 3.*vx      + 4.5*vx*vx             + sq_term);\n        float f2eq = 1./9. *rho*(1. - 3.*vx      + 4.5*vx*vx             + sq_term);\n        float f3eq = 1./9. *rho*(1. + 3.*vy      + 4.5*vy*vy             + sq_term);\n        float f4eq = 1./9. *rho*(1. - 3.*vy      + 4.5*vy*vy             + sq_term);\n        float f5eq = 1./36.*rho*(1. + 3.*( vx+vy)+ 4.5*( vx+vy)*( vx+vy) + sq_term);\n        float f6eq = 1./36.*rho*(1. - 3.*( vx+vy)+ 4.5*( vx+vy)*( vx+vy) + sq_term);\n        float f7eq = 1./36.*rho*(1. + 3.*(-vx+vy)+ 4.5*(-vx+vy)*(-vx+vy) + sq_term);\n        float f8eq = 1./36.*rho*(1. - 3.*(-vx+vy)+ 4.5*(-vx+vy)*(-vx+vy) + sq_term);\n        //=== RELAX TOWARD EQUILIBRIUM ========================\n        f0 = f0 + (f0eq - f0) / tau;\n        f1 = f1 + (f1eq - f1) / tau;\n        f2 = f2 + (f2eq - f2) / tau;\n        f3 = f3 + (f3eq - f3) / tau;\n        f4 = f4 + (f4eq - f4) / tau;\n        f5 = f5 + (f5eq - f5) / tau;\n        f6 = f6 + (f6eq - f6) / tau;\n        f7 = f7 + (f7eq - f7) / tau;\n        f8 = f8 + (f8eq - f8) / tau;\n        //f0 = (1.-w) * f0 + w * f0eq;\n        //f1 = (1.-w) * f1 + w * f1eq;\n        //f2 = (1.-w) * f2 + w * f2eq;\n        //f3 = (1.-w) * f3 + w * f3eq;\n        //f4 = (1.-w) * f4 + w * f4eq;\n        //f5 = (1.-w) * f5 + w * f5eq;\n        //f6 = (1.-w) * f6 + w * f6eq;\n        //f7 = (1.-w) * f7 + w * f7eq;\n        //f8 = (1.-w) * f8 + w * f8eq;\n    }\n    if(itx==0&&ity==0)//stores f0,f1,f2\n        fragColor.rgb = vec3(f0,f1,f2);\n    else if(itx==1&&ity==0)//stores f3,f4,f5\n        fragColor.rgb = vec3(f3,f4,f5);\n    else if(itx==0&&ity==1)//stores f6,f7,f8\n        fragColor.rgb = vec3(f6,f7,f8);\n    else //stores rho,vx,vy\n        fragColor.rgb = vec3(rho,vx,vy);\n\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//map distribution functions to texture coordinates\n//4 texels are used to store the 9 distribution functions in one cell\n#define f0(x,y) texture(iChannel0, (vec2(2*x,2*y)+0.5)/iResolution.xy).r;\n#define f1(x,y) texture(iChannel0, (vec2(2*x,2*y)+0.5)/iResolution.xy).g;\n#define f2(x,y) texture(iChannel0, (vec2(2*x,2*y)+0.5)/iResolution.xy).b;\n#define f3(x,y) texture(iChannel0, (vec2(2*x+1,2*y)+0.5)/iResolution.xy).r;\n#define f4(x,y) texture(iChannel0, (vec2(2*x+1,2*y)+0.5)/iResolution.xy).g;\n#define f5(x,y) texture(iChannel0, (vec2(2*x+1,2*y)+0.5)/iResolution.xy).b;\n#define f6(x,y) texture(iChannel0, (vec2(2*x,2*y+1)+0.5)/iResolution.xy).r;\n#define f7(x,y) texture(iChannel0, (vec2(2*x,2*y+1)+0.5)/iResolution.xy).g;\n#define f8(x,y) texture(iChannel0, (vec2(2*x,2*y+1)+0.5)/iResolution.xy).b;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tau = 0.51;\n    //fragColor=texture(iChannel0, fragCoord/iResolution.xy);\n    int LatSizeX = int(iResolution.x/2.0);\n    int LatSizeY = int(iResolution.y/2.0);\n    //all 4 pixels do the same computations\n    int ix = int(floor(fragCoord.x/2.0));\n    int iy = int(floor(fragCoord.y/2.0));\n    if( ix >= LatSizeX || iy >= LatSizeY )\n    {\n        return;\n    }\n    int itx = int(fragCoord.x) - 2*ix;\n    int ity = int(fragCoord.y) - 2*iy;\n    float f0,f1,f2,f3,f4,f5,f6,f7,f8; //distribution functions\n    float rho, vx, vy; //moments\n    f0 = f0(ix,iy);\n    if( (iFrame==0) || (f0==0.0) ) //initialisation\n    {\n        rho = 1.0;\n        // vx  = 0.1*(1.0+0.1*fragCoord.y/iResolution.y);\n        vx  = 0.03;\n        //vy  = 0.0;\n        vy = 0.06;\n        float sq_term = -1.5 * (vx*vx+vy*vy);\n        f0 = 4./9. *rho*(1. + sq_term);\n        f1 = 1./9. *rho*(1. + 3.*vx      + 4.5*vx*vx             + sq_term);\n        f2 = 1./9. *rho*(1. - 3.*vx      + 4.5*vx*vx             + sq_term);\n        f3 = 1./9. *rho*(1. + 3.*vy      + 4.5*vy*vy             + sq_term);\n        f4 = 1./9. *rho*(1. - 3.*vy      + 4.5*vy*vy             + sq_term);\n        f5 = 1./36.*rho*(1. + 3.*( vx+vy)+ 4.5*( vx+vy)*( vx+vy) + sq_term);\n        f6 = 1./36.*rho*(1. - 3.*( vx+vy)+ 4.5*( vx+vy)*( vx+vy) + sq_term);\n        f7 = 1./36.*rho*(1. + 3.*(-vx+vy)+ 4.5*(-vx+vy)*(-vx+vy) + sq_term);\n        f8 = 1./36.*rho*(1. - 3.*(-vx+vy)+ 4.5*(-vx+vy)*(-vx+vy) + sq_term);\n    }\n    else //normal time-step\n    {\n        //=== STREAMING STEP (PERIODIC) =======================\n        int xplus  = ((ix==LatSizeX-1) ? (0) : (ix+1));\n        int xminus = ((ix==0) ? (LatSizeX-1) : (ix-1));\n        int yplus  = ((iy==LatSizeY-1) ? (0) : (iy+1));\n        int yminus = ((iy==0) ? (LatSizeY-1) : (iy-1));\n        //f0 = f0( ix    ,iy    );\n        f1 = f1( xminus,iy    );\n        f2 = f2( xplus ,iy    );\n        f3 = f3( ix    ,yminus);\n        f4 = f4( ix    ,yplus );\n        f5 = f5( xminus,yminus);\n        f6 = f6( xplus ,yplus );\n        f7 = f7( xplus ,yminus);\n        f8 = f8( xminus,yplus );\n\n        //=== COMPUTE MOMENTS =================================\n        //density\n        rho = f0+f1+f2+f3+f4+f5+f6+f7+f8;\n        //velocity\n        vx = 1./rho*(f1-f2+f5-f6-f7+f8);\n        vy = 1./rho*(f3-f4+f5-f6+f7-f8);\n        /*\n        if(ix==0||ix==LatSizeX-1)//boundary condition\n        {\n            rho = 1.0;\n            vx = 0.1;\n            vy = 0.0;\n        }\n        */\n\n        //cylinder\n        /*\n        vec2 center = vec2(50.0,LatSizeY/2);\n        if( iMouse.w>0.01 )\n            center = iMouse.xy/2.0;\n        if( distance(center,vec2(ix,iy)) < 10.0 )\n        {\n            rho = 1.0;\n            vx  = 0.0;\n            vy  = 0.0;\n        }\n        */\n        \n\n        if( iMouse.w>0.01 ){        \n            vec2 center = iMouse.xy/2.0;\n            if( distance(center,vec2(ix,iy)) < 10.0 )\n            {\n                rho = 1.0;\n                vx  = 0.0;\n                vy  = 0.0;\n                // w = 1.0;\n            }\n        }\n        \n\n        float sq_term = -1.5 * (vx*vx+vy*vy);\n        float f0eq = 4./9. *rho*(1. + sq_term);\n        float f1eq = 1./9. *rho*(1. + 3.*vx      + 4.5*vx*vx             + sq_term);\n        float f2eq = 1./9. *rho*(1. - 3.*vx      + 4.5*vx*vx             + sq_term);\n        float f3eq = 1./9. *rho*(1. + 3.*vy      + 4.5*vy*vy             + sq_term);\n        float f4eq = 1./9. *rho*(1. - 3.*vy      + 4.5*vy*vy             + sq_term);\n        float f5eq = 1./36.*rho*(1. + 3.*( vx+vy)+ 4.5*( vx+vy)*( vx+vy) + sq_term);\n        float f6eq = 1./36.*rho*(1. - 3.*( vx+vy)+ 4.5*( vx+vy)*( vx+vy) + sq_term);\n        float f7eq = 1./36.*rho*(1. + 3.*(-vx+vy)+ 4.5*(-vx+vy)*(-vx+vy) + sq_term);\n        float f8eq = 1./36.*rho*(1. - 3.*(-vx+vy)+ 4.5*(-vx+vy)*(-vx+vy) + sq_term);\n        //=== RELAX TOWARD EQUILIBRIUM ========================\n        f0 = f0 + (f0eq - f0) / tau;\n        f1 = f1 + (f1eq - f1) / tau;\n        f2 = f2 + (f2eq - f2) / tau;\n        f3 = f3 + (f3eq - f3) / tau;\n        f4 = f4 + (f4eq - f4) / tau;\n        f5 = f5 + (f5eq - f5) / tau;\n        f6 = f6 + (f6eq - f6) / tau;\n        f7 = f7 + (f7eq - f7) / tau;\n        f8 = f8 + (f8eq - f8) / tau;\n        //f0 = (1.-w) * f0 + w * f0eq;\n        //f1 = (1.-w) * f1 + w * f1eq;\n        //f2 = (1.-w) * f2 + w * f2eq;\n        //f3 = (1.-w) * f3 + w * f3eq;\n        //f4 = (1.-w) * f4 + w * f4eq;\n        //f5 = (1.-w) * f5 + w * f5eq;\n        //f6 = (1.-w) * f6 + w * f6eq;\n        //f7 = (1.-w) * f7 + w * f7eq;\n        //f8 = (1.-w) * f8 + w * f8eq;\n    }\n    if(itx==0&&ity==0)//stores f0,f1,f2\n        fragColor.rgb = vec3(f0,f1,f2);\n    else if(itx==1&&ity==0)//stores f3,f4,f5\n        fragColor.rgb = vec3(f3,f4,f5);\n    else if(itx==0&&ity==1)//stores f6,f7,f8\n        fragColor.rgb = vec3(f6,f7,f8);\n    else //stores rho,vx,vy\n        fragColor.rgb = vec3(rho,vx,vy);\n\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//map distribution functions to texture coordinates\n//4 texels are used to store the 9 distribution functions in one cell\n#define f0(x,y) texture(iChannel0, (vec2(2*x,2*y)+0.5)/iResolution.xy).r;\n#define f1(x,y) texture(iChannel0, (vec2(2*x,2*y)+0.5)/iResolution.xy).g;\n#define f2(x,y) texture(iChannel0, (vec2(2*x,2*y)+0.5)/iResolution.xy).b;\n#define f3(x,y) texture(iChannel0, (vec2(2*x+1,2*y)+0.5)/iResolution.xy).r;\n#define f4(x,y) texture(iChannel0, (vec2(2*x+1,2*y)+0.5)/iResolution.xy).g;\n#define f5(x,y) texture(iChannel0, (vec2(2*x+1,2*y)+0.5)/iResolution.xy).b;\n#define f6(x,y) texture(iChannel0, (vec2(2*x,2*y+1)+0.5)/iResolution.xy).r;\n#define f7(x,y) texture(iChannel0, (vec2(2*x,2*y+1)+0.5)/iResolution.xy).g;\n#define f8(x,y) texture(iChannel0, (vec2(2*x,2*y+1)+0.5)/iResolution.xy).b;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tau = 0.51;\n    //fragColor=texture(iChannel0, fragCoord/iResolution.xy);\n    int LatSizeX = int(iResolution.x/2.0);\n    int LatSizeY = int(iResolution.y/2.0);\n    //all 4 pixels do the same computations\n    int ix = int(floor(fragCoord.x/2.0));\n    int iy = int(floor(fragCoord.y/2.0));\n    if( ix >= LatSizeX || iy >= LatSizeY )\n    {\n        return;\n    }\n    int itx = int(fragCoord.x) - 2*ix;\n    int ity = int(fragCoord.y) - 2*iy;\n    float f0,f1,f2,f3,f4,f5,f6,f7,f8; //distribution functions\n    float rho, vx, vy; //moments\n    f0 = f0(ix,iy);\n    if( (iFrame==0) || (f0==0.0) ) //initialisation\n    {\n        rho = 1.0;\n        // vx  = 0.1*(1.0+0.1*fragCoord.y/iResolution.y);\n        vx  = 0.03;\n        //vy  = 0.0;\n        vy = 0.06;\n        float sq_term = -1.5 * (vx*vx+vy*vy);\n        f0 = 4./9. *rho*(1. + sq_term);\n        f1 = 1./9. *rho*(1. + 3.*vx      + 4.5*vx*vx             + sq_term);\n        f2 = 1./9. *rho*(1. - 3.*vx      + 4.5*vx*vx             + sq_term);\n        f3 = 1./9. *rho*(1. + 3.*vy      + 4.5*vy*vy             + sq_term);\n        f4 = 1./9. *rho*(1. - 3.*vy      + 4.5*vy*vy             + sq_term);\n        f5 = 1./36.*rho*(1. + 3.*( vx+vy)+ 4.5*( vx+vy)*( vx+vy) + sq_term);\n        f6 = 1./36.*rho*(1. - 3.*( vx+vy)+ 4.5*( vx+vy)*( vx+vy) + sq_term);\n        f7 = 1./36.*rho*(1. + 3.*(-vx+vy)+ 4.5*(-vx+vy)*(-vx+vy) + sq_term);\n        f8 = 1./36.*rho*(1. - 3.*(-vx+vy)+ 4.5*(-vx+vy)*(-vx+vy) + sq_term);\n    }\n    else //normal time-step\n    {\n        //=== STREAMING STEP (PERIODIC) =======================\n        int xplus  = ((ix==LatSizeX-1) ? (0) : (ix+1));\n        int xminus = ((ix==0) ? (LatSizeX-1) : (ix-1));\n        int yplus  = ((iy==LatSizeY-1) ? (0) : (iy+1));\n        int yminus = ((iy==0) ? (LatSizeY-1) : (iy-1));\n        //f0 = f0( ix    ,iy    );\n        f1 = f1( xminus,iy    );\n        f2 = f2( xplus ,iy    );\n        f3 = f3( ix    ,yminus);\n        f4 = f4( ix    ,yplus );\n        f5 = f5( xminus,yminus);\n        f6 = f6( xplus ,yplus );\n        f7 = f7( xplus ,yminus);\n        f8 = f8( xminus,yplus );\n\n        //=== COMPUTE MOMENTS =================================\n        //density\n        rho = f0+f1+f2+f3+f4+f5+f6+f7+f8;\n        //velocity\n        vx = 1./rho*(f1-f2+f5-f6-f7+f8);\n        vy = 1./rho*(f3-f4+f5-f6+f7-f8);\n        /*\n        if(ix==0||ix==LatSizeX-1)//boundary condition\n        {\n            rho = 1.0;\n            vx = 0.1;\n            vy = 0.0;\n        }\n        */\n\n        //cylinder\n        /*\n        vec2 center = vec2(50.0,LatSizeY/2);\n        if( iMouse.w>0.01 )\n            center = iMouse.xy/2.0;\n        if( distance(center,vec2(ix,iy)) < 10.0 )\n        {\n            rho = 1.0;\n            vx  = 0.0;\n            vy  = 0.0;\n        }\n        */\n        \n\n        if( iMouse.w>0.01 ){        \n            vec2 center = iMouse.xy/2.0;\n            if( distance(center,vec2(ix,iy)) < 10.0 )\n            {\n                rho = 1.0;\n                vx  = 0.0;\n                vy  = 0.0;\n                // w = 1.0;\n            }\n        }\n        \n\n        float sq_term = -1.5 * (vx*vx+vy*vy);\n        float f0eq = 4./9. *rho*(1. + sq_term);\n        float f1eq = 1./9. *rho*(1. + 3.*vx      + 4.5*vx*vx             + sq_term);\n        float f2eq = 1./9. *rho*(1. - 3.*vx      + 4.5*vx*vx             + sq_term);\n        float f3eq = 1./9. *rho*(1. + 3.*vy      + 4.5*vy*vy             + sq_term);\n        float f4eq = 1./9. *rho*(1. - 3.*vy      + 4.5*vy*vy             + sq_term);\n        float f5eq = 1./36.*rho*(1. + 3.*( vx+vy)+ 4.5*( vx+vy)*( vx+vy) + sq_term);\n        float f6eq = 1./36.*rho*(1. - 3.*( vx+vy)+ 4.5*( vx+vy)*( vx+vy) + sq_term);\n        float f7eq = 1./36.*rho*(1. + 3.*(-vx+vy)+ 4.5*(-vx+vy)*(-vx+vy) + sq_term);\n        float f8eq = 1./36.*rho*(1. - 3.*(-vx+vy)+ 4.5*(-vx+vy)*(-vx+vy) + sq_term);\n        //=== RELAX TOWARD EQUILIBRIUM ========================\n        f0 = f0 + (f0eq - f0) / tau;\n        f1 = f1 + (f1eq - f1) / tau;\n        f2 = f2 + (f2eq - f2) / tau;\n        f3 = f3 + (f3eq - f3) / tau;\n        f4 = f4 + (f4eq - f4) / tau;\n        f5 = f5 + (f5eq - f5) / tau;\n        f6 = f6 + (f6eq - f6) / tau;\n        f7 = f7 + (f7eq - f7) / tau;\n        f8 = f8 + (f8eq - f8) / tau;\n        //f0 = (1.-w) * f0 + w * f0eq;\n        //f1 = (1.-w) * f1 + w * f1eq;\n        //f2 = (1.-w) * f2 + w * f2eq;\n        //f3 = (1.-w) * f3 + w * f3eq;\n        //f4 = (1.-w) * f4 + w * f4eq;\n        //f5 = (1.-w) * f5 + w * f5eq;\n        //f6 = (1.-w) * f6 + w * f6eq;\n        //f7 = (1.-w) * f7 + w * f7eq;\n        //f8 = (1.-w) * f8 + w * f8eq;\n    }\n    if(itx==0&&ity==0)//stores f0,f1,f2\n        fragColor.rgb = vec3(f0,f1,f2);\n    else if(itx==1&&ity==0)//stores f3,f4,f5\n        fragColor.rgb = vec3(f3,f4,f5);\n    else if(itx==0&&ity==1)//stores f6,f7,f8\n        fragColor.rgb = vec3(f6,f7,f8);\n    else //stores rho,vx,vy\n        fragColor.rgb = vec3(rho,vx,vy);\n\n}","name":"Buffer D","description":"","type":"buffer"}]}