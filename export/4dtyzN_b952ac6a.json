{"ver":"0.1","info":{"id":"4dtyzN","date":"1518132206","viewed":224,"name":"GameCube Startup","username":"salaark","description":"Ray marching shader made to look like the Nintendo Gamecube startup animation.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["intro","gamecube","nintendo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 60;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 30.0;\nconst float EPSILON = 0.001;\nconst float M_PI = 3.14159265359;\nconst float SPEED = 6.0;\n\nvec3 transform( vec3 p, mat4 m ) {\n    vec3 q = (inverse(m)*vec4(p,1)).xyz;\n    return q;\n}\n\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat quadSDF( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d ) {\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross( ba, ad );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat squareSDF( vec3 p, vec3 o, float s, int x ) {\n    s /= 2.0;\n    vec3 a,b,c,d;\n    if(x == 0) {\n        a = o-vec3(s*1.414,0,s*1.414);\n        b = o+vec3(s*-1.414,0,s*1.414);\n        c = o+vec3(s*1.414,0,s*1.414);\n        d = o+vec3(s*1.414,0,s*-1.414);\n    } else if(x == 1) {\n        a = o-vec3(s*1.414,s*1.414,0);\n        b = o+vec3(s*-1.414,s*1.414,0);\n        c = o+vec3(s*1.414,s*1.414,0);\n        d = o+vec3(s*1.414,s*-1.414,0);\n    } else {\n        a = o-vec3(0,s*1.414,s*1.414);\n        b = o+vec3(0,s*-1.414,s*1.414);\n        c = o+vec3(0,s*1.414,s*1.414);\n        d = o+vec3(0,s*1.414,s*-1.414);\n    }\n    return quadSDF(p,a,b,c,d);\n}\n\nconst int sqaxes[17] = int[17](\n      0,0,0,0,1,1,1,1,1,1,2,2,2,2,2,2,2);\n\nfloat gsquaresSDF( vec3 p ) {\n    float result = MAX_DIST+1.0;\n    vec3 start = vec3(-2.5,-0.1,-4);\n    vec3 offs[17] = vec3[17]( vec3(0),\n        vec3(-1.6, 0, 0), vec3(-1.6, 0, 1.6),\n        vec3(-1.6, 0, 3.2), vec3(0), vec3(-2.5, -1.5, 3.3),\n        vec3(-2.5, -3.1, 3.3), vec3(-2.5, -4.7, 3.3),\n        vec3(-0.9, -4.7, 3.3), vec3(0.7, -4.7, 3.3), vec3(0),\n        vec3(1.5, -4.7, 2.5), vec3(1.5, -4.7, 0.9),\n        vec3(1.5, -4.7, -0.7), vec3(1.5, -3.1, -0.7),\n        vec3(1.5, -1.5, -0.7), vec3(1.5, -1.5, 0.9));\n    \n    int num = min(int(mod(floor(iTime*SPEED),23.0)), 17);\n    for(int i = 0; i < num; i++) {\n        if(i == 0 || sqaxes[i] == sqaxes[i-1]) {\n        \tresult = min(result, squareSDF(p,start+offs[i],1.0,sqaxes[i]));\n        }\n    }\n    return result;\n}\n\nfloat spincubeSDF( vec3 p ) {\n    float cosTheta = cos(fract(iTime*SPEED)*M_PI*0.5);\n    float sinTheta = sin(fract(iTime*SPEED)*M_PI*0.5);\n    \n    mat4 rotx = mat4(1, 0, 0, 0,\n    \t\t\t\t 0, cosTheta, sinTheta, 0,\n                     0, -sinTheta, cosTheta, 0,\n\t \t\t\t\t 0, 0, 0, 1);\n    mat4 roty = mat4(cosTheta, 0, -sinTheta, 0,\n    \t\t\t\t 0, 1, 0, 0,\n                     sinTheta, 0, cosTheta, 0,\n\t \t\t\t\t 0, 0, 0, 1);\n    mat4 roty2 = mat4(cosTheta, 0, sinTheta, 0,\n    \t\t\t\t 0, 1, 0, 0,\n                     -sinTheta, 0, cosTheta, 0,\n\t \t\t\t\t 0, 0, 0, 1);\n    mat4 rotz = mat4(cosTheta, sinTheta, 0, 0,\n    \t\t\t\t -sinTheta, cosTheta, 0, 0,\n                     0, 0, 1, 0,\n\t \t\t\t\t 0, 0, 0, 1);\n    mat4 roti = mat4(1, 0, 0, 0,\n    \t\t\t\t 0, 1, 0, 0,\n                     0, 0, 1, 0,\n\t \t\t\t\t 0, 0, 0, 1);\n    \n    vec3 pos = vec3(-0.9,0.5,-4);\n    vec3 scale = vec3(0.6);\n    int num = min(int(mod(floor(iTime*SPEED),23.0)), 21);\n    mat4 rotm;\n    vec3 rotp;\n    if(num < 2) {\n        pos.x -= float(num)*1.6;\n        rotm = rotz;\n        rotp = vec3(0.8,0.8,0);\n    } else if(num < 5) {\n        pos.x -= 3.2;\n        pos.z += float(num-2)*1.6;\n        rotm = rotx;\n        rotp = vec3(0,0.8,-0.8);\n    } else if(num < 8) {\n        pos.x -= 3.4;\n        pos.z += 4.5;\n        pos.y -= -0.2 + float(num-5)*1.6;\n        rotm = rotx;\n        rotp = vec3(0,0.8,0.8);\n    } else if(num < 11) {\n        pos.x -= 3.4 - float(num-8)*1.6;\n        pos.z += 4.6;\n        pos.y -= 4.6;\n        rotm = roty;\n        rotp = vec3(-0.8,0,0.8);\n    } else if(num < 14) {\n        pos.x += 1.0;\n        pos.z += 4.6 - float(num-11)*1.6;\n        pos.y -= 5.0;\n        rotm = roty;\n        rotp = vec3(0.8,0,0.8);\n    } else if(num < 16) {\n        pos.x += 0.7;\n        pos.z -= 0.8;\n        pos.y += float(num-14)*1.6 - 5.0;\n        rotm = rotz;\n        rotp = vec3(0.8,-0.8,0);\n    } else if(num < 17) {\n        pos.x += 0.7;\n        pos.z += float(num-16)*1.6-0.5;\n        pos.y += -1.8;\n        rotm = roty2;\n        rotp = vec3(0.8,0,-0.8);\n    } else if(num < 20){\n        float off = mod(iTime*SPEED,23.0)-17.0;\n        pos.x = -0.2;\n        pos.z += min(1.1 + off, 3.8);\n        pos.y += max(-1.8 + sin(off*1.0)*5.0, -1.8);\n        rotm = inverse(roty)*rotx;\n        rotp = vec3(0);\n    } else {\n        pos = vec3(-0.2);\n        rotm = roti;\n        rotp = vec3(0);\n        scale = vec3(0.8);\n    }\n    \n    p -= pos;\n    p = transform(p+rotp, rotm);\n    p -= rotp;\n\treturn length(max(abs(p)-scale,0.0))-0.07;\n}\n\nfloat sceneSDF(vec3 pos) {\n    return min(spincubeSDF(pos), gsquaresSDF(pos));\n}\n\nfloat shortestDistance(vec3 eye, vec3 marchingDirection) {\n    float depth = MIN_DIST;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= MAX_DIST) {\n            return MAX_DIST;\n        }\n    }\n    return MAX_DIST;\n}\n            \nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 getNormal(vec3 p) {\n    if(spincubeSDF(p) > EPSILON) {\n        return vec3(0,1,0);\n    }\n    return normalize(vec3(\n        spincubeSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        spincubeSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        spincubeSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(9.0);\n    \n    if(mod(iTime*SPEED,23.0) > 20.0) {\n        eye.y += max(sin((mod(iTime*SPEED,23.0)-20.0)*M_PI*0.5)*2.5, -0.5);\n    }\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = shortestDistance(eye, worldDir);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    vec3 p = eye + dist * worldDir;\n    \n    vec3 color = vec3(0.2588, 0.1608, 0.6706);\n    float diffuseTerm = 1.0;\n    vec3 specularColor = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    vec3 light = vec3(5,3,7);\n    vec4 refl = normalize(normalize(vec4(eye,1.0)-vec4(p,1))+normalize(vec4(light,1)));\n\tfloat specularTerm = pow(max(dot(refl,vec4(getNormal(p),1)),0.0),shininess);\n    \n    fragColor = vec4(color * diffuseTerm + specularColor * specularTerm,1);\n}","name":"Image","description":"","type":"image"}]}