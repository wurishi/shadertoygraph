{"ver":"0.1","info":{"id":"dlBfRK","date":"1694225348","viewed":19,"name":"Rotating simple Triangular Prism","username":"JoshM","description":"It spin","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["triangularprism"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//from https://iquilezles.org/articles/distfunctions/\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float s = sin(iTime);\n    float c = cos(iTime);\n    mat3 rotX = mat3(\n        1.0, 0.0, 0.0,\n        0.0, c,   s,\n        0.0, -s,  c\n      );\n     \n     mat3 rotZ = mat3(\n        c,   s, 0.0,\n        -s,  c, 0.0, \n        0.0, 0.0, 1.0\n      ); \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(1.0);\n    \n    //create a ray!\n    //assume orthographic projection\n    vec3 rayPt = vec3(uv.xy, 0);\n    vec3 rayPtdx = vec3(uv.x + 0.00001, uv.y, 0);\n    vec3 rayPtdy = vec3(uv.x, uv.y + 0.00001, 0);\n    vec3 rayDir = vec3(0,0,1);\n    float t = 0.0, tdx = 0.0, tdy = 0.0; //ray parameter\n    \n    //define the Triangular prism properties\n    vec2 TPrisProps = vec2(0.2, 0.1);\n    vec3 TPrisPos = vec3(0.5,0.5,5.0);\n    \n    for(int i = 0; i < 20; i++){\n        //calculate a point 5 units along the ray\n        vec3 pos = rayPt + rayDir * t;    \n        vec3 posdx = rayPtdx + rayDir * tdx;\n        vec3 posdy = rayPtdy + rayDir * tdy;\n        \n        //subtract object position from ray position and check if that point\n        //is in the world origin sphere\n        float dist = sdTriPrism(rotZ*rotX*(pos - TPrisPos), TPrisProps);\n        float distdx = sdTriPrism(rotZ*rotX*(posdx - TPrisPos), TPrisProps);\n        float distdy = sdTriPrism(rotZ*rotX*(posdy - TPrisPos), TPrisProps);\n        \n        if(dist < 0.004  && distdx < 0.004 && distdy < 0.004){\n        \n            vec3 lightDir = rayDir;\n            vec3 torusCol = vec3(1,0,0);\n            //I now have 3 points on the surface...\n            //pos, posdx, posdy...\n            \n            //output color = surfacecolor * dot (-Light Direction, surface normal)\n            col = torusCol*dot(-lightDir, normalize(cross(posdy - pos, posdx - pos)));\n            \n            //col = normalize(pos - torusPos);\n            //col.z = -col.z;            \n            break;\n        } \n                \n        t = t + dist;\n        tdx = tdx + distdx;\n        tdy = tdy + distdy;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}