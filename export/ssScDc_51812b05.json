{"ver":"0.1","info":{"id":"ssScDc","date":"1644223635","viewed":254,"name":"refractal_mandelbulb","username":"milez770","description":"implementing The Art of Code tutorial","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","refract"],"hasliked":0,"parentid":"tlGcWw","parentname":"mandelbulb ray"},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ITER 3\n#define MAX_STEPS 100\n#define MAX_DIST 10.\n#define SURF_DIST 0.002\n#define SPEED 2.\n\nvec3 rotate( vec3 pos, float x, float y, float z )\n{\n\tmat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0, cos( x ), -sin( x ), 0.0, sin( x ), cos( x ) );\n\tmat3 rotY = mat3( cos( y ), 0.0, sin( y ), 0.0, 1.0, 0.0, -sin(y), 0.0, cos(y) );\n\tmat3 rotZ = mat3( cos( z ), -sin( z ), 0.0, sin( z ), cos( z ), 0.0, 0.0, 0.0, 1.0 );\n\n\treturn rotX * rotY * rotZ * pos;\n}\n\n\nfloat dist(vec2 p, vec2 t){\n    float dx = p.x-t.x;\n    float dy = p.y-t.y;\n    return sqrt(dx*dx+dy*dy);\n}\n\n// 3d mandelbulb\nfloat mandel3(in vec3 v){\n    vec3 r = v;\n    vec3 rNext = r;\n    float m = dot(v, v);\n    //vec4 trap = vec4(abs(r), m);\n    \n    int i = 0;\n    float d = 1.;\n    float n =  8.;\n    \n    float col = 0.;\n    for(i=0; i<ITER; i++){\n         \n        \n        \n        float cr = length(r);\n        \n        float nr = pow(cr, n);\n        //*abs(sin(iTime/5.) )\n        float accos = acos(r.z/cr*abs( sin(iTime/10.) ));\n        float actan = atan(r.y/r.x);\n        \n        d = pow(cr, n-1.) *n * d + 1.0;\n        \n        rNext.x = nr*sin(accos*n)*cos(n*actan);\n        rNext.y = nr*sin(accos*n)*sin(n*actan);\n        rNext.z = nr*cos(n*accos);\n        r = v + rNext;\n        \n        //trap = min(trap, vec4(abs(r), m));\n\n        m = dot(r,r);\n        \n        if(m > 256.){\n            break;\n        }\n       \n    }\n    //return col;\n    return  .2*log(m) * sqrt(m) / d;\n        \n    \n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d; \n}\n\nfloat RayMarch(in vec3 ro, in vec3 rd, in float side){\n    \n    \n\tfloat dO=0.;\n    \n    \n    \n    for(int i=0; i<MAX_STEPS; i++){\n        vec3 p = ro+rd*dO;\n\n        p = rotate( p, sin(iTime), cos(iTime), 0.0 );\n        \n        float mbd = mandel3(abs(p));\n        float dS = mbd*side;\n        dO += dS;\n        \n        if(dO > MAX_DIST || dS<SURF_DIST) break;\n        \n    }\n    \n    return dO;\n}\nvec3 GetNormal(vec3 p){\n    vec3 col;\n    // my e value made black artifacts\n    // so I took a look at iq's normal epsilone. \n    // don't exactly know how this is calculated.\n    // looks like it is relevant to some screen pixel size calculation..?\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.25*2.0/(iResolution.y*1.5);\n    \n    // getting vector with very small vector\n    vec3 n = vec3(\n        e.xyy*mandel3(p+e.xyy)+\n        e.yxy*mandel3(p+e.yxy)+\n        e.yyx*mandel3(p+e.yyx)+\n        e.xxx*mandel3(p + e.xxx) \n    );\n    \n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/(iResolution.y);\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(1.3*cos(iTime/10.),1.3*sin(iTime/10.), 1.3);\n    vec3 rd = R(uv, ro, vec3(0,0,0), .7);\n    \n    vec3 backgrounduv;\n    \n    \n    float d = RayMarch(ro, rd, 1.);\n    \n    col = texture(iChannel0, rd).rgb;\n    \n    if(d < MAX_DIST){\n    vec3 p = ro + rd * d;\n    vec3 n = GetNormal(p);\n    vec3 r = reflect(rd, n);\n        \n    float IOR = 1.25;\n        \n    //inner raymarch\n    vec3 rdIn = refract(rd, n, 1./IOR);\n    vec3 pEnter = p - n*SURF_DIST*3.;\n    float dIn = RayMarch(pEnter, rdIn, -1.);\n\n    vec3 pExit = pEnter + rdIn * dIn;\n    vec3 nExit = -GetNormal(pExit);\n        \n        \n    vec3 reflTex = vec3(0);\n\n    float abbs = .03;\n\n\n    vec3 rdOutR = refract(rdIn, nExit, IOR-abbs);\n    if(length(rdOutR) == 0.){\n        rdOutR = reflect(rdIn, nExit);\n    } \n    reflTex.r = texture(iChannel0, rdOutR).r;\n    //float dIn = RayMarch(pExit, rdOut, 1.);\n\n\n    vec3 rdOutG = refract(rdIn, nExit, IOR);\n    if(length(rdOutG) == 0.){\n        rdOutG = reflect(rdIn, nExit);\n    } \n    reflTex.g = texture(iChannel0, rdOutG).g;\n\n\n    vec3 rdOutB = refract(rdIn, nExit, IOR+abbs);\n    if(length(rdOutB) == 0.){\n        rdOutB = reflect(rdIn, nExit);\n    } \n    reflTex.b = texture(iChannel0, rdOutB).b;\n\n\n    //float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n    col = vec3(reflTex);\n    \n    //col += pow(clamp(backgrounduv.z, 0., .97), 10.)*vec3(.8, .1, .1);\n    }\n    col = pow(col, vec3(.4545));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}