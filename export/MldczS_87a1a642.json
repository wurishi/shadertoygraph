{"ver":"0.1","info":{"id":"MldczS","date":"1533074888","viewed":145,"name":"m6cI31x6ohnri8CM6Hgj","username":"liurui39660","description":"The texture image is about 2MiB, it may take seconds to load.\nRun the command in the browser console to load the external texture.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["none"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Use these combination to open command line.\n\tChrome:  ctrl + shift J\n\tFirefox: ctrl + shift K\n    IE:      F12  \n\nRun the command below to load external texture.\ngShaderToy.SetTexture(0, {mSrc:'https://eoimages.gsfc.nasa.gov/images/imagerecords/73000/73826/world.topo.bathy.200410.3x5400x2700.jpg', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n*/\n\nconst float PI = atan(1., 1.)*4.;\n\nconst vec3 BACKGROUND_COLOR = vec3(0, 0, 0);\nconst float FOVY = 50.0 * PI / 180.0;\nconst float DEFAULT_TMIN = 10.0e-4;\nconst float DEFAULT_TMAX = 10.0e6;\nconst int NUM_ITERATIONS = 1;\n\nstruct Ray_t {\n\tvec3 o;  // Ray Origin.\n\tvec3 d;  // Ray Direction. A unit vector.\n};\nstruct Plane_t {\n\t// The plane equation is Ax + By + Cz + D = 0.\n\tfloat A, B, C, D;\n\tint materialID;\n};\nstruct Sphere_t {\n\tvec3 center;\n\tfloat radius;\n\tint materialID;\n};\nstruct Light_t {\n\tvec3 position;  // Point light 3D position.\n\tvec3 I_a;       // For Ambient.\n\tvec3 I_source;  // For Diffuse and Specular.\n};\nstruct Material_t {\n\tvec3 k_a;   // Ambient coefficient.\n\tvec3 k_d;   // Diffuse coefficient.\n\tvec3 k_r;   // Reflected specular coefficient.\n\tvec3 k_rg;  // Global reflection coefficient.\n\tfloat n;    // The specular reflection exponent. Ranges from 0.0 to 128.0. \n};\n\n#define HitType_t int\n#define NOTHING 0\n#define PLANE 1\n#define SPHERE 2\n\nvec2 Cart2Geo(vec3 coord) {\n\tcoord = normalize(coord);\n\treturn vec2(atan(coord.x, coord.z), asin(coord.y));\n}\n\nconst int NUM_SPHERES = 1;\nconst float RADIUS = 1.0 / 4.0;\nSphere_t Sphere[NUM_SPHERES];\nvoid InitSphere() {\n\tSphere[0].radius = 1.0;\n\tSphere[0].center = vec3(0, 0, 0);\n\tSphere[0].materialID = -1;\n}\nconst int NUM_PLANES = 5;\nPlane_t Plane[NUM_PLANES];\nvoid InitPlane() {\n\t// Plane[0].A = 0.0;\n\t// Plane[0].B = 1.0;\n\t// Plane[0].C = 0.0;\n\t// Plane[0].D = 0.0;\n\t// Plane[0].materialID = -1;\n\n\t// Plane[1].A = 0.0;\n\t// Plane[1].B = 0.0;\n\t// Plane[1].C = 1.0;\n\t// Plane[1].D = 5.0;\n\t// Plane[1].materialID = -1;\n\n\t// Plane[2].A = 1.0;\n\t// Plane[2].B = 0.0;\n\t// Plane[2].C = 0.0;\n\t// Plane[2].D = 5.0;\n\t// Plane[2].materialID = -1;\n\n\t// Plane[3].A = 0.0;\n\t// Plane[3].B = 0.0;\n\t// Plane[3].C = -1.0;\n\t// Plane[3].D = 5.0;\n\t// Plane[3].materialID = -1;\n\n\t// Plane[4].A = -1.0;\n\t// Plane[4].B = 0.0;\n\t// Plane[4].C = 0.0;\n\t// Plane[4].D = 5.0;\n\t// Plane[4].materialID = -1;\n}\nconst int NUM_LIGHTS = 4;\nLight_t Light[NUM_LIGHTS];\nvoid InitLight() {\n\tLight[0].position = vec3(5, 0, 5);\n\tLight[1].position = vec3(-5, 0, 5);\n\tLight[2].position = vec3(-5, 0, -5);\n\tLight[3].position = vec3(5, 0, -5);\n\tLight[0].I_a = vec3(0.1, 0.1, 0.1);\n\tLight[1].I_a = vec3(0.1, 0.1, 0.1);\n\tLight[2].I_a = vec3(0.1, 0.1, 0.1);\n\tLight[3].I_a = vec3(0.1, 0.1, 0.1);\n\tLight[0].I_source = vec3(1.0, 1.0, 1.0);\n\tLight[1].I_source = vec3(1.0, 1.0, 1.0);\n\tLight[2].I_source = vec3(1.0, 1.0, 1.0);\n\tLight[3].I_source = vec3(1.0, 1.0, 1.0);\n}\nconst int NUM_MATERIALS = 1;\nMaterial_t Material[NUM_MATERIALS];\nvoid InitMaterial() {\n\tMaterial[0].k_d = vec3(0.1, 0.6, 0.8);\n\tMaterial[0].k_a = 0.2 * Material[0].k_d;\n\tMaterial[0].k_r = 2.0 * Material[0].k_d;\n\tMaterial[0].k_rg = 0.5 * Material[0].k_r;\n\tMaterial[0].n = 64.0;\n}\n\nvoid InitScene() {\n\tInitSphere();\n\tInitPlane();\n\tInitLight();\n\tInitMaterial();\n}\nbool IntersectPlane(in Plane_t pln, in Ray_t ray, in float tmin, in float tmax, out float t, out vec3 hitPos, out vec3 hitNormal, out HitType_t hitType) {\n\tvec3 N = vec3(pln.A, pln.B, pln.C);\n\tfloat NRd = dot(N, ray.d);\n\tfloat NRo = dot(N, ray.o);\n\tfloat t0 = (-pln.D - NRo) / NRd;\n\tif (t0 < tmin || t0 > tmax) return false;\n\n\tt = t0;\n\thitPos = ray.o + t0 * ray.d;\n\thitNormal = normalize(N);\n\thitType = PLANE;\n\treturn true;\n}\nbool IntersectPlane(in Plane_t pln, in Ray_t ray, in float tmin, in float tmax) {\n\tfloat _;\n\tvec3 _1;\n\tHitType_t _2;\n\treturn IntersectPlane(pln, ray, tmin, tmax, _, _1, _1, _2);\n}\nbool IntersectSphere(in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax, out float t, out vec3 hitPos, out vec3 hitNormal, out HitType_t hitType) {\n\tray.o -= sph.center;\n\tfloat a = dot(ray.d, ray.d);\n\tfloat b = 2.0 * dot(ray.d, ray.o);\n\tfloat c = dot(ray.o, ray.o) - sph.radius*sph.radius;\n\tfloat d = b * b - 4.0 * a*c;\n\tif (d > 0.0) {\n\t\tfloat solutionA = (-b + sqrt(d)) / (2.0 * a);\n\t\tfloat solutionB = (-b - sqrt(d)) / (2.0 * a);\n\t\tif (solutionB > 0.0)\n\t\t\tt = solutionB;\n\t\telse if (solutionA > 0.0)\n\t\t\tt = solutionA;\n\t\telse\n\t\t\treturn false;\n\t}\n\telse if (d == 0.0)\n\t\tt = -b / (2.0*a);\n\telse\n\t\treturn false;\n\thitPos = ray.o + t * ray.d + sph.center;\n\thitNormal = normalize(hitPos - sph.center);\n\thitType = SPHERE;\n\treturn tmin < t&&t < tmax;\n}\nbool IntersectSphere(in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax) {\n\tfloat _;\n\tvec3 _1;\n\tHitType_t _2;\n\treturn IntersectSphere(sph, ray, tmin, tmax, _, _1, _1, _2);\n}\nvec3 PhongLighting(in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n\tin Material_t mat, in Light_t light) {\n\tif (inShadow) {\n\t\treturn light.I_a * mat.k_a;\n\t}\n\telse {\n\t\tvec3 R = reflect(-L, N);\n\t\tfloat N_dot_L = max(0.0, dot(N, L));\n\t\tfloat R_dot_V = max(0.0, dot(R, V));\n\t\tfloat R_dot_V_pow_n = (R_dot_V == 0.0) ? 0.0 : pow(R_dot_V, mat.n);\n\t\treturn light.I_a * mat.k_a + light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n\t}\n}\nvec2 TexCoord(HitType_t hitType, int hitIndex, vec3 hitPos) {\n\tswitch (hitType) {\n\tcase SPHERE:\n\t\thitPos = normalize(hitPos - Sphere[hitIndex].center);\n\t\treturn vec2(atan(hitPos.x, hitPos.z) / (2.0*PI), (asin(hitPos.y) + PI / 2.0) / PI);\n\t}\n}\nMaterial_t TexColor(HitType_t hitType, int hitIndex, vec3 hitPos) {\n\tswitch (hitType) {\n\tcase SPHERE:\n\t\tvec3 color = texture(iChannel0, TexCoord(hitType, hitIndex, hitPos)).xyz;\n\t\treturn Material_t(0.0*color, 2.0*color, 0.0*color, 0.0*color, 64.0);\n\t}\n}\nvec3 CastRay(in Ray_t ray,\n\tout bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg) {\n\tbool hasHitSomething = false;\n\tfloat nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n\tvec3 nearest_hitPos;              // 3D position of the nearest hit point.\n\tvec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n\tint nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\tHitType_t nearest_hitType = NOTHING;\n\tint nearest_hitIndex;\n\tfloat temp_t;\n\tvec3 temp_hitPos;\n\tvec3 temp_hitNormal;\n\tbool temp_hasHit;\n\tHitType_t temp_hitType;\n\tMaterial_t mat;\n\tfor (int i = 0; i < NUM_PLANES; i++) {\n\t\ttemp_hasHit = IntersectPlane(Plane[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal, temp_hitType);\n\t\tif (temp_hasHit&&temp_t < nearest_t) {\n\t\t\thasHitSomething = true;\n\t\t\tnearest_t = temp_t;\n\t\t\tnearest_hitPos = temp_hitPos;\n\t\t\tnearest_hitNormal = temp_hitNormal;\n\t\t\tnearest_hitMatID = Plane[i].materialID;\n\t\t\tnearest_hitType = temp_hitType;\n\t\t\tnearest_hitIndex = i;\n\t\t}\n\t}\n\tfor (int i = 0; i < NUM_SPHERES; i++) {\n\t\ttemp_hasHit = IntersectSphere(Sphere[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal, temp_hitType);\n\t\tif (temp_hasHit&&temp_t < nearest_t) {\n\t\t\thasHitSomething = true;\n\t\t\tnearest_t = temp_t;\n\t\t\tnearest_hitPos = temp_hitPos;\n\t\t\tnearest_hitNormal = temp_hitNormal;\n\t\t\tnearest_hitMatID = Sphere[i].materialID;\n\t\t\tnearest_hitType = temp_hitType;\n\t\t\tnearest_hitIndex = i;\n\t\t}\n\t}\n\thasHit = hasHitSomething;\n\tif (!hasHitSomething) return BACKGROUND_COLOR;\n\tvec3 I_local = vec3(0.0);\n\tbool inShadow[NUM_LIGHTS];\n\tRay_t rayHitPosToLight[NUM_LIGHTS];\n\tfor (int i = 0; i < NUM_LIGHTS; i++) {\n\t\tinShadow[i] = false;\n\t\trayHitPosToLight[i] = Ray_t(nearest_hitPos, normalize(Light[i].position - nearest_hitPos));\n\t\tfor (int j = 0; j < NUM_PLANES; j++)\n\t\t\tif (IntersectPlane(Plane[j], rayHitPosToLight[i], DEFAULT_TMIN, length(Light[i].position - nearest_hitPos)))\n\t\t\t\tinShadow[i] = true;\n\t\tfor (int j = 0; j < NUM_SPHERES; j++)\n\t\t\tif (IntersectSphere(Sphere[j], rayHitPosToLight[i], DEFAULT_TMIN, length(Light[i].position - nearest_hitPos)))\n\t\t\t\tinShadow[i] = true;\n\t}\n\tfor (int i = 0; i < NUM_LIGHTS; i++) {\n\t\tif (nearest_hitMatID >= 0)\n\t\t\tmat = Material[nearest_hitMatID];\n\t\telse\n\t\t\tmat = TexColor(nearest_hitType, nearest_hitIndex, nearest_hitPos);\n\t\tI_local += PhongLighting(rayHitPosToLight[i].d, nearest_hitNormal, normalize(-ray.d), inShadow[i], mat, Light[i]);\n\t}\n\thitPos = nearest_hitPos;\n\thitNormal = nearest_hitNormal;\n\tk_rg = Material[nearest_hitMatID].k_rg;\n\treturn I_local;\n}\nRay_t Camera(vec3 position, vec3 lookAt, vec3 upVector) {\n\tvec3 positionPixel = vec3((2.0 * gl_FragCoord.xy - iResolution.xy) / iResolution.y, -1.0 / tan(FOVY / 2.0));\n\tvec3 z = normalize(position - lookAt);\n\tvec3 x = normalize(cross(upVector, z));\n\tvec3 y = normalize(cross(z, x));\n\treturn Ray_t(position, normalize(positionPixel.x*x + positionPixel.y*y + positionPixel.z*z));\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tInitScene();\n\tRay_t nextRay = Camera(vec3(2.5*sin(-0.1*iTime), 0.0, 2.5*cos(-0.1*iTime)), vec3(0, 0, 0), vec3(0., 1, 0));\n\tfragColor = vec4(0, 0, 0, 1);\n\tvec3 compounded_k_rg = vec3(1.0);\n\tfor (int level = 0; level <= NUM_ITERATIONS; level++) {\n\t\tbool hasHit;\n\t\tvec3 hitPos, hitNormal, k_rg;\n\t\tvec3 I_local = CastRay(nextRay, hasHit, hitPos, hitNormal, k_rg);\n\t\tfragColor.xyz += compounded_k_rg * I_local;\n\t\tif (!hasHit)\n\t\t\tbreak;\n\t\tcompounded_k_rg *= k_rg;\n\t\tnextRay = Ray_t(hitPos, normalize(reflect(nextRay.d, hitNormal)));\n\t}\n}\n","name":"Image","description":"","type":"image"}]}