{"ver":"0.1","info":{"id":"wdyGWh","date":"1570089206","viewed":57,"name":"test stuff","username":"dennens","description":"stuff test","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 50.\n#define MAX_MARCHES 70\n#define SURF_DIST .01\n#define SKYBOX_COLOR vec3(0.3, 0.7, 0.8)\n\nfloat getRandom(float v)\n{\n    return 2. * fract(sin(v * 123.45) * 456.78) - 1.;\n}\n\nvec3 getCameraPos()\n{\n    if (iMouse.xy == vec2(0))\n    {\n        return vec3(5., 1.7, -4.2);\n    }\n    \n    vec2 mousePos = (iMouse.xy / iResolution.y * 4.) - 1.;\n    return vec3(0. + sin(mousePos.x) * 3., 1., cos(mousePos.x) * -3.) * mousePos.y;\n}\n\nvec4 addPlane(float yPos, vec3 color, vec3 p, vec4 currentValue)\n{\n    float d = p.y - yPos;\n    if (d < currentValue.w)\n    {\n    \tcurrentValue.w = d;\n        currentValue.rgb = color;\n    }\n    return currentValue;\n}\n\nvec4 addSphere(vec3 pos, float radius, vec3 color, vec3 p, vec4 currentValue)\n{\n\tfloat sd = length(p-pos) - radius;\n    if (sd < currentValue.w)\n    {\n    \tcurrentValue.w = sd;\n        currentValue.rgb = color;\n    }\n    return currentValue;\n}\n\nvec4 addTorus(vec2 radii, vec3 color, vec3 p, vec4 currentValue)\n{\n\tfloat td = length(vec2(length(p.xz) - radii.x, p.y)) - radii.y;\n    if (td < currentValue.w)\n    {\n    \tcurrentValue.w = td;\n        currentValue.rgb = color;\n    }\n    return currentValue;\n}\n\nvec4 getColorAndDist(vec3 p)\n{\n    vec4 value = vec4(SKYBOX_COLOR, MAX_DIST);\n    // ADD THINGS TO SCENE HERE\n    value = addPlane(-0.5, \t\t\t\t\tvec3(1., 0., 0.), p, value);\n    value = addTorus(vec2(1, 0.5), \t\t\tvec3(1., 1., 0.), p, value);\n    for (int i = -20; i < 6; i += 4)\n    {\n    \tvalue = addSphere(vec3(i, abs(sin(iTime * 2. + (float(i) * .25))), 0), 0.4, \tvec3(0., 1., 0.), p, value);\n    }\n    \n\treturn value;\n}\n\nfloat getDist(vec3 p)\n{\n\treturn getColorAndDist(p).w;   \n}\n\nvec4 rayMarchWithColor(vec3 origin, vec3 direction)\n{\n    vec3 p;\n    vec4 dO;\n    for (int i = 0; i < MAX_MARCHES; ++i)\n    {\n        p = origin + direction * dO.w;\n        vec4 dS = getColorAndDist(p);\n        dO.w += dS.w;\n        if (dS.w < SURF_DIST || dO.w > MAX_DIST)\n        {\n        \tif (dS.w < SURF_DIST) dO.rgb = dS.rgb;\n            break;\n        }\n    }\n    return dO;\n}\n\nfloat rayMarch(vec3 origin, vec3 direction)\n{\n\treturn rayMarchWithColor(origin, direction).w;   \n}\n\nvec3 getNormal(vec3 p)\n{\n\tfloat d = getDist(p);\n    vec2 e = vec2(.01, 0);\n    vec3 n = d - vec3(\n        getDist(p - e.xyy),\n        getDist(p - e.yxy),\n        getDist(p - e.yyx)\n        );\n    \n    return normalize(n);\n}\n\nvec3 addLight(vec3 pos, vec3 lightColor, vec3 p, vec3 n)\n{\n    vec3 l = normalize(pos - p);\n    float dif = clamp(dot(l, n), 0., 1.);\n    float d = rayMarch(p+n*SURF_DIST*2., l);\n    if (d < length(pos - p))\n    {\n    \tdif *= 0.;   \n    }\n    \n    // SPECULAR SETTINGS\n    float specIntensity = .3;\n\tfloat specShininess = 16.;\n    vec3 r = reflect(-l, n);\n    vec3 viewDir = normalize(getCameraPos());\n    float dotProduct = dot(r, viewDir);\n    vec3 specular = lightColor * specIntensity * pow(max(dot(viewDir, r), 0.0), specShininess) * dif;\n    \n    \n    return (lightColor * dif) + specular;\n}\n\nvec3 getLight(vec3 p)\n{\n    vec3 n = getNormal(p);\n    vec3 diff;\n    // ADD LIGHTS TO SCENE HERE\n    vec3 ambientColor = vec3(0.1);\n    diff += addLight(vec3(3, 5, -6) /*+ vec3(sin(iTime), cos(iTime), 0) * 4.*/, vec3(0.7), p, n);\n    diff += addLight(vec3(-3, 5, -6), vec3(0.2, 0.4, 0.75), p, n);\n    return diff + ambientColor;\n}\n\nvec3 getFog(float dist, vec3 color)\n{\n    // FOG SETTINGS\n    vec3 fogColor = vec3(0.3, 0.7, 0.8);\n    float maxFogDistance = 40.;\n    float minFogDistance = 0.;\n    float fog = clamp((dist - minFogDistance) / maxFogDistance, 0., 1.);\n    return mix(color, fogColor, fog);\n}\n\nfloat getFresnel(vec3 viewDir, vec3 normal)\n{\n    // FRESNEL SETTINGS\n    float bias = 0.1;\n    float scale = 1.;\n    float power = 2.;\n    \n\treturn clamp(bias + scale * pow(1. + dot(normalize(viewDir), normal), power), 0., 1.);\n}\n\nvec3 getReflections(vec3 p, vec3 camera)\n{\n    vec3 reflectedColor;\n    float reflectIntensity = .9;\n    float numReflectionRays = 35.;\n\tfloat reflectionDiffuseness = .3;\n    \n    vec3 normal = getNormal(p);\n    vec3 viewDir = normalize(p - camera);\n    vec3 dir = reflect(viewDir, normal);\n    \n    for (float r = 0.; r < numReflectionRays; ++r)\n    {\n        float div = r / numReflectionRays;\n        vec3 addDir = vec3(getRandom(p.x + r), getRandom(p.y + r), getRandom(p.z + r)) * reflectionDiffuseness * div;\n        vec4 res = rayMarchWithColor(p + normal * SURF_DIST * 2., normalize(dir + addDir));\n        vec3 pos = p + dir * res.w;\n        vec3 light = getLight(pos);\n        float fresnel = 1.;\n        reflectedColor += res.rgb * reflectIntensity * light * getFresnel(p - camera, normal);\n    }\n    reflectedColor /= float(numReflectionRays);\n    return reflectedColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 lookat = vec3(0);\n    vec3 cameraPos = getCameraPos();\n    float zoom = 1.;\n    \n    vec3 forward = normalize(lookat - cameraPos),\n        right = normalize(cross(vec3(0,1,0), forward)),\n        up = cross(forward, right),\n        c = cameraPos + forward * zoom,\n        i = c + uv.x * right + uv.y * up,\n        rd = normalize(i - cameraPos);\n    \n    vec4 colorAndDist = rayMarchWithColor(cameraPos, rd);\n    vec3 p = cameraPos + rd * colorAndDist.w;\n    vec3 color = colorAndDist.rgb;\n    \n    if (colorAndDist.w < MAX_DIST)\n    {\n    \tcolor += getReflections(p, cameraPos);\n    }\n    color *= getLight(p);\n    \n    color = getFog(colorAndDist.w, color);\n    \n    //color = (getNormal(p) * vec3(1., 1., -1.) + 1.) / 2.;\n    //color = (lookat - cameraPos) * 0.1;\n    //color = vec3(getFresnel(p - cameraPos, getNormal(p)));\n    \n    fragColor = vec4(color,colorAndDist.w);\n}","name":"Image","description":"","type":"image"}]}