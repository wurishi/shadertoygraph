{"ver":"0.1","info":{"id":"flXXWn","date":"1625413554","viewed":324,"name":"Orthographic camera from Blender","username":"Envy24","description":"Orthographic camera with lookat.\nUse mouse to change view direction.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","raymarching","camera","orthographic","blender"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n                        Perspective camera: https://www.shadertoy.com/view/NtsXz4\n    Perspective camera with depth of field: https://www.shadertoy.com/view/NlsXRf\n*/\n\n#define TAU 6.2831853071795862 // 2*PI\n#define TO_RAD 0.017453292519943295\n#define R iResolution\n\n// Camera positions for viewing scene from different sides.\n#define FRONT  vec3(0.0, 0.0, 2.0)\n#define BACK   vec3(0.0, 0.0, -2.0)\n#define LEFT   vec3(-2.0, 0.0, 0.0)\n#define RIGHT  vec3(2.0, 0.0, 0.0)\n#define TOP    vec3(0.0001, 2.0, 0.0)\n#define BOTTOM vec3(0.0001, -2.0, 0.0)\n\nvec4 scene(vec2 uv)\n{\n    float T = iTime;\n    float o = 4.0;\n    float my = iMouse.z > 0.0 ? o * 0.5 - (iMouse.y / R.y) * o : 0.0;\n    float mx = iMouse.z > 0.0 ? o * 0.5 - (iMouse.x / R.x) * o : 0.0;\n\n\n\n    /* Axis-aligned ortographic camera (Blender). *\n    float aspectRatio = R.x / R.y;\n    float orthographicScale = 5.0;\n    float vpWidth = orthographicScale;\n    float vpHeight = vpWidth / aspectRatio;\n    float zViewPlane = FRONT.z;\n         \n    vec3 ray = vec3(\n        (uv.x * vpWidth - vpWidth * 0.5),\n        (uv.y * vpHeight - vpHeight * 0.5), \n       zViewPlane);\n    vec3 rayDir = vec3(0.0, 0.0, -1.0);\n    /* Axis-aligned orthogonal camera */\n\n\n\n    /* Ortographic camera (Blender). */\n    vec3 lookAt = vec3(mx, my, 0.0);\n    //vec3 vp = vec3(sin(T), cos(-T), cos(T));\n    vec3 vp = FRONT;\n    \n    vec3 f = normalize(lookAt - vp);                   // forward\n    vec3 r = normalize(cross(f, vec3(0.0, 1.0, 0.0))); // right\n    vec3 u = normalize(cross(r, f));                   // up\n    \n    float aspectRatio = R.x / R.y;\n    float orthographicScale = 5.0;\n    float vpWidth = orthographicScale;\n    float vpHeight = vpWidth / aspectRatio;\n   \n    uv.x = (uv.x * vpWidth) - vpWidth * 0.5;\n    uv.y = (uv.y * vpHeight) - vpHeight * 0.5;\n         \n    vec3 ray = vp + uv.x * r + uv.y * u;\n    vec3 rayDir = f;\n    /* Ortographic camera. */\n  \n  \n  \n  \n \n    /* Scene stuff */\n    float d = 0.5;\n    vec3 c[9];\n    c[0] = vec3(0.0, 0.0, 0.0); // central\n    \n    c[1] = vec3(d, d, -d);\n    c[2] = vec3(-d, d, -d);\n    c[3] = vec3(d, -d, -d);\n    c[4] = vec3(-d, -d, -d);\n    \n    c[5] = vec3(d, d, d);   \n    c[6] = vec3(-d, d, d);   \n    c[7] = vec3(d, -d, d);   \n    c[8] = vec3(-d, -d, d);\n       \n    float radius = 0.2;\n    \n    float t = 99999.0;\n    int num = 8;\n    vec3 normal = vec3(0.0, 0.0, 0.0);\n\n    for (int s = 0; s < num; ++s)\n    {\n        for (int i = 0; i < 9; ++i)\n        {\n            /* Rotate scene */\n            c[i] = rotateAroundY(c[i], iTime * 40.0 * TO_RAD);\n            c[i] = rotateAroundX(c[i], iTime * 30.0 * TO_RAD);\n            /* Rotate scene */\n\n            float tmp = shootRayInSphere(ray, rayDir, c[i], radius - float(i) * 0.02);       \n\n            if (tmp > 0.0 && tmp < t) // hit\n            {\n                t = min(t, tmp);\n                normal =(ray + rayDir * t) - c[i];\n            }\n        }\n    }\n\n    \n    if (t > 10.0) { return vec4(normalize(ray), 1.0); } // Background color.\n\n    float exposureTime = 32.0;\n   \n    return vec4(normal.xyz * exposureTime / radius, 1.0);\n    //return vec4(vec3((1.0 + normalize(normal)) * 0.5), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/R.xy;\n \n    // Output to screen\n    fragColor = scene(uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define T_NEAR 0.0001\n\nfloat shootRayInSphere(\n    vec3 ray,\n    vec3 rayDir,\n    vec3 sphereCenter,\n    float sphereRadius)\n{\n    vec3 tmp = ray - sphereCenter;\n    \n    float a = dot(rayDir, rayDir);\n    float b = 2.0 * dot(tmp, rayDir);\n    float c = dot(tmp, tmp) - sphereRadius * sphereRadius;\n    float discriminant = b * b - 4.0 * a * c;\n    \n    if (discriminant < 0.0) { return -1.0; }\n      \n    float e = sqrt(discriminant);\n\n    float t = (-b - e) / (2.0 * a);\n\n    if (t >= T_NEAR)\n    {\n       return t;\n    }\n\n    t = (-b + e) / (2.0 * a);\n\n    if (t >= T_NEAR)\n    {\n       return t;\n    }\n    \n    return -1.0;\n}\n\nvec3 rotateAroundX(vec3 p, float a)\n{\n    float s = sin(-a);\n    float c = cos(-a);\n\n    return vec3(\n        p.x,\n        p.y * c + p.z * s,\n        p.z * c - p.y * s);\n}\n\nvec3 rotateAroundY(vec3 p, float a)\n{\n    float s = sin(-a);\n    float c = cos(-a);\n\n    return vec3(\n        p.x * c + p.z * s,\n        p.y,\n        p.z * c - p.x * s);\n}\n\nvec3 rotateAroundZ(vec3 p, float a)\n{\n    float s = sin(-a);\n    float c = cos(-a);\n\n    return vec3(\n        p.x * c + p.y * s,\n        p.y * c - p.x * s,\n        p.z);\n}","name":"Common","description":"","type":"common"}]}