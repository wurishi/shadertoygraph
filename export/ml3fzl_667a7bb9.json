{"ver":"0.1","info":{"id":"ml3fzl","date":"1701944721","viewed":32,"name":"D1 - Day Night Cycle","username":"SilverFox","description":"Advent of shader code\nGradient Sky: Create a dynamic day-night cycle with smooth color transitions.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["aoc","gradientsky"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// IChannel0 - used for gradient sky calculation\n// IChannel1 - Day texture png\n// IChannel2 - Night texture png\n\n// Dawn\nvec3 dawnStartColor = vec3(1.0, 0.8, 0.8); \nvec3 dawnEndColor = vec3(1.0, 1.0, 0.8);\n\n// Midday\nvec3 middayStartColor = vec3(0.0, 0.6, 1.0);\nvec3 middayEndColor = vec3(0.5, 0.8, 1.0);\n\n// Dusk\nvec3 duskStartColor = vec3(1.0, 0.55, 0.0);\nvec3 duskEndColor = vec3(0.5, 0.3, 0.5);\n\n// Night\nvec3 nightStartColor = vec3(0.0, 0.0, 0.3);\nvec3 nightEndColor = vec3(0.0, 0.0, 0.0);\n\n// Generate white mask of non transparent pixels if isInvert is false\nvec3 getAlphaMaskOfTexture(sampler2D tex, vec2 uv, bool isInvert) \n{\n    float texelAlpha = texture(tex, uv).a;\n    return isInvert ? (texelAlpha > 0.0 ? vec3(0.0, 0.0, 0.0) : vec3(1.0, 1.0, 1.0)) \n                    : (texelAlpha > 0.0 ? vec3(1.0, 1.0, 1.0) : vec3(0.0, 0.0, 0.0));\n}\n\n// Generate colored mask for non transparent pixels\n// for transparent pixels use white color\nvec3 getColoredMaskOfTexture(sampler2D tex, vec2 uv) \n{\n    vec4 texel = texture(tex, uv);\n    return texel.a > 0.0 ? texel.rgb : vec3(1.0, 1.0, 1.0);\n}\n\n// Generate gradient color based on uv.y and start vertical offset\nvec3 verticalGradient(vec2 uv, vec3 colorStart, vec3 colorEnd, float startOffsetPercentage) \n{\n    // offseting uv.y based on startOffsetPercentage\n    float factor = (uv.y - startOffsetPercentage) / (1.0 - startOffsetPercentage);\n    factor = clamp(factor, 0.0, 1.0);\n    return mix(colorStart, colorEnd, factor);\n}\n\nfloat getDayCycleBlendTexValue(float time)\n{\n   float dayCycle;\n    if (time < 12.0) {\n        // From midnight to midday, decrease to 1\n        dayCycle = 1.0 - (time / 12.0);\n    } else {\n        // From midday to midnight, increase to 1\n        dayCycle = (time - 12.0) / 12.0;\n    }\n\n    //NOTE: more optimal caclulation - abosulute distance from midday\n    //float dayCycle = 1.0 - abs(time - 12.0) / 12.0;\n    return dayCycle;\n}\n\nvec3 blendGradientInRangeOfHours(vec3 startGradient, vec3 endGradient, float startHour, float endHour, float time)\n{\n  return mix(startGradient, endGradient, smoothstep(startHour, endHour, time));\n}\n\n// Used for apply texture on top of colored mask of sky background\nvec3 multiplicativeBlendIfCloseToWhite(vec3 baseMaskColor, vec3 multiplicativeColor, float tolerance) \n{\n    float distanceFromWhite = length(vec3(1.0, 1.0, 1.0) - baseMaskColor);\n    if (distanceFromWhite < tolerance) \n    {\n        return baseMaskColor * multiplicativeColor;\n    }\n\n    return baseMaskColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    // Normalize coordinates\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Time-based variables for day-night cycle\n    float time = mod(iTime, 24.0); // To get 24-hour cycle\n\n    vec3 backgroundColor = texture(iChannel0, uv).rgb;\n    vec3 treesDayTexture = texture(iChannel1, uv).rgb;\n    vec3 treesNightTexture = texture(iChannel2, uv). rgb;\n    vec3 invertWhiteMask = getAlphaMaskOfTexture(iChannel1, uv, true);\n    vec3 treesDayTextureColorMask = getColoredMaskOfTexture(iChannel1, uv);\n    vec3 treesNightTextureColorMask = getColoredMaskOfTexture(iChannel2, uv);\n    \n    // Blending skyColor based on day/night cycle factor\n    vec3 middayGradient = verticalGradient(uv, middayStartColor, middayEndColor, 0.8);\n    vec3 duskGradient = verticalGradient(uv, duskStartColor, duskEndColor, 0.0);\n    vec3 nightGradient = verticalGradient(uv, nightStartColor, nightEndColor, 0.8);\n    \n    vec3 skyColor;\n    if (time < 12.0)\n    {\n        skyColor = blendGradientInRangeOfHours(nightGradient, middayGradient, 0.0, 12.0, time);\n    } \n    else if (time < 18.0) \n    {\n        skyColor = blendGradientInRangeOfHours(middayGradient, duskGradient, 12.0, 18.0, time);\n    } \n    else \n    {\n        skyColor = blendGradientInRangeOfHours(duskGradient, nightGradient, 18.0, 24.0, time);\n    }\n     \n    // Blending day/night texture based on blendFactor\n    float textureBlendBasedOnDayFactor = getDayCycleBlendTexValue(time);\n    vec3 treesTextureColor = mix(treesDayTexture, treesNightTexture, textureBlendBasedOnDayFactor);\n    \n    vec3 skyColorWithInvertTreesMask = skyColor * invertWhiteMask;\n    \n    vec3 whiteTreeMask = getAlphaMaskOfTexture(iChannel1, uv, false);\n    vec3 skyColorWithTreesMask = skyColorWithInvertTreesMask + whiteTreeMask;\n\n    vec3 finalColor = multiplicativeBlendIfCloseToWhite(skyColorWithTreesMask, treesTextureColor, 0.05);\n    \n    fragColor = vec4(finalColor, 1);\n}\n","name":"Image","description":"","type":"image"}]}