{"ver":"0.1","info":{"id":"XlKGRt","date":"1476210194","viewed":299,"name":"Cube surface","username":"Nesvi7","description":"Surface made of rotating cubes. Looks better in fullscreen scale.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","cube","rotations","module"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//By Nestor Vina\n\n// ray marching\nconst int max_iterations = 100;\nconst float stop_threshold = 0.02;\nconst float grad_step = 0.1;\nconst float clip_far = 1000.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nconst vec3 sunDir = normalize(vec3(1.0,-1.0,1.0));\n\n\nvec3 rotate( vec3 p, vec3 rot ){\n    rot.z = -rot.z;\n    mat3 ry = mat3(cos(rot.y), 0.0,-sin(rot.y),\n\t\t\t   0.0, 1.0, 0.0, \n\t\t\t   sin(rot.y), 0.0, cos(rot.y)  );\n    \n\tmat3 rz = mat3(cos(rot.z),-sin(rot.z), 0.0,\n\t\t\t   sin(rot.z), cos(rot.z), 0.0,\n\t\t\t   0.0, 0.0, 1.0 );\n     \n\tmat3 rx = mat3(1.0, 0.0, 0.0,\n\t\t\t   0.0, cos(rot.x), sin(rot.x), \n\t\t\t   0.0,-sin(rot.x), cos(rot.x) );\n    return p*rz*ry*rx;\n}\n\n\nfloat cubes( vec3 p, vec3 b,float c )\n{\n  p = rotate(p,vec3(-PI*0.3,0.0,0.0));\n  vec3 initialp = p;\n  p.xz = mod(p.xz,c) - 0.5 * c;\n  vec2 index = floor(initialp.xz/c);\n  \n  float incidence = length(index)*0.1;\n  incidence += sin((index.x + index.y)*0.1 + iTime*0.1)*0.03;\n\n  p = rotate(p,vec3(iTime*incidence,iTime*incidence,0.0));\n  \n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n//Map\nvec2 mapCubeSkin(vec3 p){\n    float c = 1.0;\n    vec2 index = floor(p.xz/c);\n    float minDist = cubes(p,vec3(0.5,0.5,.5),c);\n   \tfloat color = (1.0+sin(length(index.xy)*0.2+iTime))*0.5;\n\treturn vec2(minDist, color);\n}\nvec2 map( vec3 p) {\n    p.y += sin((p.x+p.z)*0.3+iTime*3.0);\n    return mapCubeSkin(p);\n}\n\nvec2 rayMarching( vec3 origin, vec3 dir, float start, float end ) {\n\t\n    float depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n        vec2 distResult = map( origin + dir * depth );\n\t\tfloat dist = distResult.x;\n\t\tif ( dist < stop_threshold ) {\n\t\t\treturn vec2(depth,distResult.y);\n\t\t}\n\t\tdepth += dist;\n\t\tif ( depth >= end) {\n\t\t\treturn vec2(end,-1.0);\n\t\t}\n\t}\n\treturn vec2(end,-1.0);\n}\n\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\t\n\treturn normalize( vec3( -xy, -z ) );\n}\n\nvec3 normal( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tmap( pos + dx ).x - map( pos - dx ).x,\n\t\t\tmap( pos + dy ).x - map( pos - dy ).x,\n\t\t\tmap( pos + dz ).x - map( pos - dz ).x\t\t\t\n\t\t)\n\t);\n}\n\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x, \n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nfloat fresnel(vec3 n, vec3 d, float exp ){\n    return pow(1.0-dot(d,n),exp);\n}\n\nvec3 material( vec3 v, vec3 n, vec3 eye,float randomIndex ) {    \n    //Texturing \n    vec2 uv = v.xz;    \n    \n    //vec3 albedo = texture(iChannel0,vec2(randomIndex,0.0)).xyz;//vec3(0.5,0.0,0.0);\n    vec3 albedo = mix(vec3(0.5,0.1,0.4),vec3(0.1,0.1,0.6),randomIndex);\n    \n    vec3 viewDir = normalize(eye-v);    \n    vec3 fresnelColor = vec3(0.4,0.3,0.7) * fresnel(n,viewDir,2.0);    \n    \n    float diffuse = dot(sunDir,n)*0.3;\n    vec3 ambient = vec3(0.1,0.05,0.005);\n    \n    return albedo+diffuse+ambient;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// default ray dir\n\tvec3 dir = ray_dir( 45.0, iResolution.xy, fragCoord.xy );\n\t\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, -6.0, 45.0 );\n\n\t// rotate camera\n\tmat3 rot = rotationXY( vec2(0,2.0*PI));\n\tdir = rot * dir;\n\teye = rot * eye;\n\t\n\t// ray marching\n    vec2 rayResult = rayMarching( eye, dir, 2.0, clip_far );\n\tfloat depth = rayResult.x;\n\tif ( depth >= clip_far ) {        \n\t\tfragColor = vec4(0.3,0.3,0.3,1.0);//Background color\n        return;\n\t}\n\t\n\t// shading\n\tvec3 pos = eye + dir * depth;\n\tvec3 n = normal( pos );\n    vec3 fogColor = vec3(0.3,0.3,0.3);\n    \n   \tfragColor = vec4(material( pos, n, eye,rayResult.y ), 1);\n    \n}","name":"Image","description":"","type":"image"}]}