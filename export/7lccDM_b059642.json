{"ver":"0.1","info":{"id":"7lccDM","date":"1659916128","viewed":120,"name":"Pade Approximation [1/1], [2/2]","username":"Envy24","description":"Supports expressions only with this operations: add, sub, mul, div, sqrt, exp, log (ln), pow, sin, cos.\nTaylor-mode for forward automatic differentiation is used to calculate higher-order derivatives.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["approximation","derivative","polynomial","taylor","mode","series","rational","automaticdifferentiation","forward","pade"],"hasliked":0,"parentid":"NlccDN","parentname":"Taylor Approximation"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define AR                        ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define UNIT                      (  10.0 / R.y  )\n#define SMAA(x)                   ( smoothstep(UNIT, 0., (x)) )\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define PI                          3.1415926535897932\n#define NZMX                      ( (iMouse.x+iMouse.x-R.x) / R.x )  // in range [-1.0; 1.0]\n\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat draw_func(vec2 NDC, float f, float dfdx)\n{\n    float df   = NDC.y - f;\n    return SMAA(abs(df) / sqrt(1.0 + dfdx * dfdx));\n}\n\n// 0 - f(x) = (sin(x)*sin(x) + cos(x))*x\n// 1 - f(x) = sqrt(x)\n// 2 - f(x) = log(x)  // ln x\n#define FUNC 0\n\n/* Function that you want to approximate. */\nvoid f(\n    inout float[max_degree] X,\n    float x)\n{\n    // Example: f(x) = (sin(x)*sin(x) + cos(x))*x\n    float x0[max_degree]; initialize(x0, x); // x\n    float x1[max_degree]; initialize(x1, x); // x\n    \n#if FUNC == 0\n    sine(x0, x0);       // sin(x)\n    mul(x0, x0, x0);    // sin(x)*sin(x)\n    \n    cosine(x1, x1);     // cos(x)\n    \n    add(x0, x0, x1);    // sin(x)*sin(x) + cos(x)\n    \n    mul(X, X, x0);      // (sin(x)*sin(x) + cos(x)) * x\n#elif FUNC == 1 \n    square_root(X, x0); // sqrt(x)\n#else\n    ln(X, x0);\n#endif\n}\n\n/*\n    a - offset, for centering approximation around a  \n*/\nfloat Pade_approximation1ov1(\n    in float x,\n    in float a)\n{\n    float fact = 1.;\n    \n    float der[max_degree];\n    initialize(der, a); \n    // Now der == { a, 1, 0, 0, ... };\n    \n    f(der, a); // Calculate Taylor coefficients\n    \n    mat3 INV = mat3(\n        1., 0., 0.,\n        0., 1., -der[0],\n        0., 0., -der[1]);\n    INV = transpose(INV);\n    INV = inverse(INV);\n    \n    // Calculate Pade coeffitients\n    vec3 coefs = INV * vec3(der[0], der[1], der[2]);\n    return (coefs[0] + coefs[1] * (x-a)) / (1. + coefs[2] * (x-a));\n}\n\nfloat Pade_approximation2ov2(\n    in float x,\n    in float a)\n{\n    float fact = 1.;\n    \n    float der[max_degree];\n    initialize(der, a); \n    // Now der == { a, 1, 0, 0, ... };\n    \n    f(der, a); // Calculate Taylor coefficients\n    \n    float M[matrix_size];\n    float E[extended_size];\n    \n    identity(M, row_length);\n    write_right_matrix(E, M, row_length);\n    \n    M = float[matrix_size](\n        1., 0., 0.,      0.,      0.,\n        0., 1., 0., -der[0],      0.,\n        0., 0., 1., -der[1], -der[0],\n        0., 0., 0., -der[2], -der[1],\n        0., 0., 0., -der[3], -der[2]\n    );\n    write_left_matrix(E, M, row_length);\n    \n    Jordan_Gauss_inverse(E, row_length);\n    \n    read_right_matrix(E, M, row_length);\n    \n    float V[row_length] = float[row_length]( der[0], der[1], der[2], der[3], der[4] );\n    \n    // Calculate Pade coeffitients\n    multiply_matrix_and_vector(V, M, row_length);\n\n    return (V[0] + V[1] * (x-a) + V[2] * (x-a)*(x-a)) / (1. + V[3] * (x-a) + V[4] * (x-a)*(x-a));\n}\n\n/* Matrix for Pade[1/1] and its equation:\n    1, 0,   0,                            (V[0] + V[1] * (x-a)) /\n    0, 1, -c0,                              (1. + V[2] * (x-a))\n    0, 0, -c1\n/* Matrix for Pade[2/2] and its equation:\n    1, 0, 0,   0,   0,                    (V[0] + V[1] * (x-a) + V[2] * (x-a)*(x-a)) / \n    0, 1, 0, -c0,   0,                      (1. + V[3] * (x-a) + V[4] * (x-a)*(x-a))\n    0, 0, 1, -c1, -c0,\n    0, 0, 0, -c2, -c1,\n    0, 0, 0, -c3, -c2\n/* Matrix for Pade[3/3] and its equation:\n    1, 0, 0, 0,   0,   0,   0,            (V[0] + V[1] * (x-a) + V[2] * (x-a)^2 + V[3] * (x-a)^3) /\n    0, 1, 0, 0, -c0,   0,   0,              (1. + V[4] * (x-a) + V[5] * (x-a)^2 + V[6] * (x-a)^3)\n    0, 0, 1, 0, -c1, -c0,   0,\n    0, 0, 0, 1, -c2, -c1, -c0,\n    0, 0, 0, 0, -c3, -c2, -c1,\n    0, 0, 0, 0, -c4, -c3, -c2,\n    0, 0, 0, 0, -c5, -c4, -c3,\n    https://www.shadertoy.com/view/dtfcRS\n/* Matrix for Pade[4/4] and its equation:\n    1, 0, 0, 0, 0,   0,   0,   0,   0,    (V[0] + V[1] * (x-a) + V[2] * (x-a)^2 + V[3] * (x-a)^3 + V[4] * (x-a)^4) /\n    0, 1, 0, 0, 0, -c0,   0,   0,   0,      (1. + V[5] * (x-a) + V[6] * (x-a)^2 + V[7] * (x-a)^3 + V[8] * (x-a)^4)\n    0, 0, 1, 0, 0, -c1, -c0,   0,   0,\n    0, 0, 0, 1, 0, -c2, -c1, -c0,   0,    \n    0, 0, 0, 0, 1, -c3, -c2, -c1, -c0,\n    0, 0, 0, 0, 0, -c4, -c3, -c2, -c1,\n    0, 0, 0, 0, 0, -c5, -c4, -c3, -c2,\n    0, 0, 0, 0, 0, -c6, -c5, -c4, -c3,\n    0, 0, 0, 0, 0, -c7, -c6, -c5, -c4\n  And e.t.c. */\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n#define GSCALE 4.0\n#define YSCALE 1.0\n#define OFFSET vec2(0., 0.)\n\n    vec2 NDC = \n        LMB_IS_HOLD ?\n            GSCALE*(TO_CENTERED_NDC(SC-(iMouse.xy-R.xy*0.5))+OFFSET) :\n            GSCALE*(TO_CENTERED_NDC(SC)+OFFSET);\n\n    vec3 color = vec3(1.);\n         color -= x_axis(NDC); color -= y_axis(NDC);\n  \n    /* Function */\n#if FUNC == 0\n#define func(x)  ( (sin(x)*sin(x)+cos(x))*x )\n#define deriv(x) ( sin(x)*sin(x) + (2.*x*cos(x)-x)*sin(x)+cos(x) )\nfloat a = sinOSC(-2., 2., iTime * 0.5);\n#elif FUNC == 1\n#define func(x)  ( sqrt(x) )\n#define deriv(x) ( 1./(2.*sqrt(x)) )\nfloat a = sinOSC(0., 2., iTime * 0.5);\n#else\n#define func(x)  ( log(x) )\n#define deriv(x) ( 1./(x) )\nfloat a = sinOSC(0., 2., iTime * 0.5);\n#endif\n         color.rb -= draw_func(NDC, YSCALE*func(NDC.x), YSCALE*deriv(NDC.x));\n         \n    /* Taylor approximation */\n    \n    float dx = 0.01;\n    float y0 = Pade_approximation2ov2(NDC.x, a);\n    float y1 = Pade_approximation2ov2(NDC.x+dx, a);\n    \n        color.gb -= draw_func(NDC, YSCALE*y0, YSCALE*((y1 - y0)/dx));\n\n        color = mix(color, vec3(1, 0, 1), SMAA(diskSDF_L2(NDC, vec2(a, YSCALE*func(a)), UNIT*2.0)));\n         \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R)\n{\n    return length(C - NDC)-R;\n}\n\nfloat segmentSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0));\n}\n\nconst int min_degree = 2; // Don't change.\nconst int max_degree = max(min_degree, 5); // Pick derivative degree (number of derivatives - 1).\n\nvoid initialize(\n    inout float v[max_degree],\n    float v0)\n{\n    //     x          x'\n    v[0] = v0; v[1] = 1.;\n\n    for (int i = 2; i < max_degree; ++i) { v[i] = 0.0; }\n}\n\nvoid copy(\n    inout float dst[max_degree],\n    in float src[max_degree])\n{\n    for (int i = 0; i < max_degree; ++i) { dst[i] = src[i]; }\n}\n\nvoid extract_derivatives(inout float v[max_degree])\n{\n    float fact = 1.;\n\n    for (int i = 1; i < max_degree; ++i)\n    {\t\t\n        fact *= float(i);\n        v[i] *= fact;\n    }\n}\n\nvoid add(\n    inout float res[max_degree],\n    in float L[max_degree],\n    in float R[max_degree])\n{\n    for (int i = 0; i < max_degree; ++i)\n    {\n        res[i] = L[i] + R[i];\n    }\n}\nvoid add(\n    inout float res[max_degree],\n    in float L[max_degree],\n    in float S)\n{\n    res[0] = L[0] + S;\n    \n    for (int i = 1; i < max_degree; ++i)\n    {\n        res[i] = L[i];\n    }\n}\n\nvoid sub(\n    inout float res[max_degree],\n    in float L[max_degree],\n    in float R[max_degree])\n{\n    for (int i = 0; i < max_degree; ++i)\n    {\n        res[i] = L[i] - R[i];\n    }\n}\nvoid sub(\n    inout float res[max_degree],\n    in float L[max_degree],\n    in float S)\n{\n    res[0] = L[0] - S;\n    \n    for (int i = 1; i < max_degree; ++i)\n    {\n        res[i] = L[i];\n    }\n}\n\nvoid mul(\n    inout float res[max_degree],\n    in float L[max_degree],\n    in float R[max_degree])\n{\n    for (int k = 0; k < max_degree; ++k)\n    {\n        res[k] = 0.0;\n\n        for (int j = 0; j <= k; ++j)\n        {\n            res[k] += L[j] * R[k - j];\n        }\n    }\n}\nvoid mul(\n    inout float res[max_degree],\n    in float L[max_degree],\n    in float S)\n{\n    for (int k = 0; k < max_degree; ++k)\n    {\n        res[k] = L[k] * S;\n    }\n}\n\nvoid div(\n    inout float res[max_degree],\n    in float L[max_degree],\n    in float R[max_degree])\n{\n    float inv = 1.0 / R[0];\n\n    for (int k = 0; k < max_degree; ++k)\n    {\n        float sum = 0.0;\n\n        for (int j = 0; j < k; ++j)\n        {\n            sum += res[j] * R[k - j];\n        }\n\n        res[k] = (L[k] - sum) * inv;\n    }  \n}\nvoid div(\n    inout float res[max_degree],\n    in float L[max_degree],\n    in float S)\n{\n    float inv = 1.0 / S;\n\n    for (int k = 0; k < max_degree; ++k)\n    {\n        res[k] = L[k] * inv;\n    }\n}\n\nvoid square_root(\n    inout float res[max_degree],\n    in float V[max_degree])\n{\n    res[0] = sqrt(V[0]);\n    float inv = 1.0 / (2.0 * res[0]);\n\n    for (int k = 1; k < max_degree; ++k)\n    {\n        float sum = 0.0;\n\n        for (int j = 1; j < k; ++j)\n        {\n            sum += res[j] * res[k - j];\n        }\n\n        res[k] = (V[k] - sum) * inv;\n    }\n}\n\nvoid expf(\n    inout float res[max_degree],\n    in float V[max_degree])\n{\n    res[0] = exp(V[0]);\n\n    for (int k = 1; k < max_degree; ++k)\n    {\n        float sum = 0.0;\n\n        for (int j = 1; j <= k; ++j)\n        {\t\n            sum += res[k - j] * V[j] * float(j);\n        }\n\n        res[k] = sum / float(k);\n    }\n}\n\nvoid ln(\n    inout float res[max_degree],\n    in float V[max_degree])\n{\n    res[0] = log(V[0]);\n\n    float inv = 1.0 / V[0];\n\n    for (int k = 1; k < max_degree; ++k)\n    {\n        float sum = 0.0;\n\n        for (int j = 1; j < k; ++j)\n        {\n            sum += V[k - j] * res[j] * float(j);\n        }\n\n        res[k] = ((float(k) * V[k] - sum) * inv) / float(k);\n    }\n}\n\nvoid power(\n    inout float res[max_degree],\n    in float V[max_degree],\n    in float exponent)\n{\n    res[0] = pow(V[0], exponent);\n\n    float inv = 1.0 / V[0];\n\n    for (int k = 1; k < max_degree; ++k)\n    {\n        float sumL = 0.0, sumR = 0.0;\n\n        for (int j = 1; j < k; ++j)\n        {\n            sumL += res[k - j] * V[j] * float(j);\n            sumR += V[k - j] * res[j] * float(j);\n        }\n        sumL += res[0] * V[k] * float(k);\n\n        res[k] = ((exponent * sumL - sumR) * inv) / float(k);\n    }\n}\n\nvoid sine(\n    inout float res[max_degree],\n    in float V[max_degree])\n{\n    res[0] = sin(V[0]);\n    \n    float c[max_degree];\n    for (int i = 1; i < max_degree; ++i) { c[i] = 0.0; }\n    c[0] = cos(V[0]);\n\n    for (int k = 1; k < max_degree; ++k)\n    {\n        float sumS = 0.0, sumC = 0.0;\n\n        for (int j = 1; j <= k; ++j)\n        {\n            sumS += V[j] * c[k - j] * float(j);\n            sumC += -V[j] * res[k - j] * float(j);\n        }\n\n        float inv = 1.0 / float(k);\n\n        res[k] = sumS * inv;\n        c[k] = sumC * inv;\n    }\n}\n\nvoid cosine(\n    inout float res[max_degree],\n    in float V[max_degree])\n{\n    float s[max_degree];\n    for (int i = 1; i < max_degree; ++i) { s[i] = 0.0; }\n    s[0] = sin(V[0]);\n\n    res[0] = cos(V[0]);\n\n    for (int k = 1; k < max_degree; ++k)\n    {\n        float sumS = 0.0, sumC = 0.0;\n\n        for (int j = 1; j <= k; ++j)\n        {\n            sumS += V[j] * res[k - j] * float(j);\n            sumC += -V[j] * s[k - j] * float(j);\n        }\n\n        float inv = 1.0 / float(k);\n\n        s[k] = sumS * inv;\n        res[k] = sumC * inv;\n    }\n}\n\n\n\nconst int row_length = 5;\nconst int matrix_size = row_length * row_length;\nconst int extended_size = matrix_size * 2;\n\n// if return_value >= N OR return_value == -1, then matrix is probably singular.\nint to_upper_triangle(\n    inout float[extended_size] M,\n    in int N) // sqrt(extended_size / 2)\n{\n    int numOfSwaps = 0;\n    int rowSize = 2 * N;\n\n    for (int sub = 0; sub < N - 1;)\n    {\n        float diag = M[sub * rowSize + sub];\n\n        if (diag == 0.0)\n        {\n            int r = sub + 1;\n            while (M[r * rowSize + sub] == 0.0 && r < N) { ++r; }\n\n            if (r == N) { return -1; } // singular matrix\n\n            for (int c = 0; c < rowSize; ++c)\n            {\n                float t = M[r * rowSize + c];\n                M[r * rowSize + c] = M[sub * rowSize + c];\n                M[sub * rowSize + c] = t;\n            }\n\n            diag = M[sub * rowSize + sub];\n\n            if (numOfSwaps >= N) { return numOfSwaps; }\n\n            ++numOfSwaps;\n\n            continue;\n        }\n\n        for (int r = sub + 1; r < N; ++r)\n        {\n            if (M[r * rowSize + sub] == 0.0)\n            {\n                continue;\n            }\n\n            float ratio = M[r * rowSize + sub] / diag;\n\n            for (int c = sub; c < rowSize; ++c)\n            {\n                M[r * rowSize + c] -= M[sub * rowSize + c] * ratio;\n            }\n        }\n        ++sub;\n    }\n\n    return numOfSwaps;\n}\n\n// if return_value >= N OR return_value == -1, then matrix is probably singular.\nint to_lower_triangle(\n    inout float[extended_size] M,\n    in int N) // sqrt(extended_size / 2)\n{\n    int numOfSwaps = 0;\n    int Ndec = N - 1;\n    int rowSize = 2 * N;\n\n    for (int sub = 0; sub < Ndec;)\n    {\n        int mirror = (Ndec - sub);\n        float diag = M[mirror * rowSize + mirror];\n\n        if (diag == 0.0)\n        {\n            int r = mirror - 1;\n\n            while (M[r * rowSize + mirror] == 0.0 && r < N) { ++r; }\n\n            if (r == N) { return -1; } // singular matrix\n\n            for (int c = 0; c < N; ++c)\n            {\n                float t = M[r * rowSize + c];\n                M[r * rowSize + c] = M[mirror * rowSize + c];\n                M[mirror * rowSize + c] = t;\n            }\n\n            diag = M[mirror * N + mirror];\n\n            if (numOfSwaps >= N) { return numOfSwaps; }\n\n            ++numOfSwaps;\n\n            continue;\n        }\n\n        for (int r = mirror - 1; r >= 0; --r)\n        {\n            if (M[r * rowSize + mirror] == 0.0)\n            {\n                continue;\n            }\n\n            float ratio = M[r * rowSize + mirror] / diag;\n\n            for (int c = rowSize - 1; c > mirror - 1; --c)\n            {\n                M[r * rowSize + c] -= M[mirror * rowSize + c] * ratio;\n            }\n        }\n        ++sub;\n    }\n\n    return numOfSwaps;\n}\n\nvoid Jordan_Gauss_inverse(\n    inout float[extended_size] M,\n    in int N) // sqrt(extended_size / 2)\n{\n    to_upper_triangle(M, N);\n    to_lower_triangle(M, N);\n\n    int rowSize = 2 * N;\n\n    for (int r = 0; r < N; ++r)\n    {\n        float invDiag = 1.0 / M[r * rowSize + r];\n\n        for (int c = 0; c < N; ++c)\n        {\n            M[N + r * rowSize + c] *= invDiag;\n        }\n        M[r * rowSize + r] *= invDiag;\n    }\n}\n\nvoid read_right_matrix(\n    in float[extended_size] M,\n    inout float[matrix_size] I,\n    in int N) // sqrt(matrix_size)\n{\n    int rowSize = 2 * N;\n    int wOffset = 0;\n\n    for (int r = 0; r < N; ++r)\n    {\n        for (int c = 0; c < N; ++c)\n        {\n            I[wOffset++] = M[r * rowSize + N + c];\n        }\n    }\n}\n\nvoid write_right_matrix(\n    inout float[extended_size] M,\n    in float[matrix_size] I,\n    in int N) // sqrt(matrix_size)\n{\n    int rowSize = 2 * N;\n    int wOffset = 0;\n    for (int r = 0; r < N; ++r)\n    {\n        for (int c = 0; c < N; ++c)\n        {\n            M[r * rowSize + N + c] = I[wOffset++];\n        }\n    }\n}\n\nvoid read_left_matrix(\n    in float[extended_size] M,\n    inout float[matrix_size] O,\n    in int N) // sqrt(matrix_size)\n{\n    int rowSize = 2 * N;\n    int wOffset = 0;\n\n    for (int r = 0; r < N; ++r)\n    {\n        for (int c = 0; c < N; ++c)\n        {\n            O[wOffset++] = M[r * rowSize + c];\n        }\n    }\n}\n\nvoid write_left_matrix(\n    inout float[extended_size] M,\n    in float[matrix_size] O,\n    in int N) // sqrt(matrix_size)\n{\n    int rowSize = 2 * N;\n    int wOffset = 0;          \n\n    for (int r = 0; r < N; ++r)\n    {\n        for (int c = 0; c < N; ++c)\n        {\n            M[r * rowSize + c] = O[wOffset++];\n        }\n    }\n}\n\nvoid multiply_matricies(\n    inout float[matrix_size] R,\n    in float[matrix_size] A,\n    in float[matrix_size] B,\n    in int N) // sqrt(matrix_size)\n{\n    int wOffset = 0;     \n    int rIdx = 0;        \n    int NN = N * N;\n\n    do\n    {\n        for (int r = 0; r < N; ++r)\n        {\n            float weighted_sum = 0.0;\n\n            for (int c = 0; c < N; ++c)\n            {\n                weighted_sum += A[rIdx * N + c] * B[c * N + r];\n            }\n\n            R[wOffset++] = weighted_sum;\n        }\n\n        ++rIdx;\n    } while (wOffset < NN);\n}\n\nvoid multiply_matrix_and_vector(\n    inout float V[row_length],\n    in float M[matrix_size],\n    in int N) // sqrt(matrix_size), e.g. row_length\n{\n    float T[row_length];\n    for (int i = 0; i < row_length; ++i) { T[i]=V[i]; }\n    for (int r = 0; r < row_length; ++r)\n    {\n        V[r] = 0.;\n        \n        for (int c = 0; c < row_length; ++c)\n        {\n            V[r] += T[c] * M[r * row_length + c];\n        }\n    }\n\n}\n\nvoid identity(\n    inout float[matrix_size] I,\n    in int N) // not extended row size\n{\n    for (int r = 0; r < N; ++r)\n    {\n        for (int c = 0; c < N; ++c)\n        {\n            I[r * N + c] = float(r == c);\n        }\n    }\n}","name":"Common","description":"","type":"common"}]}