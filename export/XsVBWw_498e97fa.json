{"ver":"0.1","info":{"id":"XsVBWw","date":"1529235011","viewed":301,"name":"Analytic Spline Distance","username":"nr4","description":"Distance to a quadratic spline by solving a cubic equation.\nAcknowledgement to LordVetinari for the discussion and proof-reading my derivation steps.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["spline","distance","quadratic","analytic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Analytic Spline Distance\n * \n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n//changes: fixed clamping of t.\n\nconst vec2 k = vec2(1.,0.);\nconst float pi = acos(-1.);\n\nfloat dist(vec2 p_0,vec2 p_1,vec2 p_2,vec2 x,float t)\n{\n    return length(x-pow(1.-t,2.)*p_0-2.*(1.-t)*t*p_1-t*t*p_2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.yy-.5;\n    \n    //control points. Uncomment to make it move ;-)\n    vec2 p_0 = vec2(-.25,-.25)+.15*vec2(sin(iTime), cos(3.*iTime)), \n        p_1 = vec2(.25,-.25)+.5*vec2(sin(iTime), .5-sin(iTime)),\n        p_2 = vec2(.25,.25)+.15*vec2(cos(iTime), sin(iTime));\n\n\t//coefficients for 0 = t^3 + a * t^2 + b * t + c\n    vec2 E = uv-p_0, F = p_2-2.*p_1+p_0, G = p_1-p_0;\n    vec3 coeff = vec3(3.*dot(G,F), 2.*dot(G,G)-dot(E,F), -dot(E,G))/dot(F,F);\n\n    float a = coeff.x, b = coeff.y, c = coeff.z;\n\n\t//discriminant and helpers\n    float p = b-a*a/3., q = 2.*a*a*a/27.-a*b/3.+c, dis = q*q/4.+p*p*p/27.,\n        tau = a/3.;\n    \n    //solution with cardan formula\n    float k1 = -.5*q+sqrt(dis), k2 = -.5*q-sqrt(dis);\n    float u = sign(k1)*pow(abs(k1), 1./3.), v = sign(k2)*pow(abs(k2), 1./3.);\n    \n    float t_min = 1.;\n    if(dis > 0.)\n    {\n        t_min = u+v-tau;\n        t_min = clamp(t_min, 0.,1.);\n    }\n    else if(dis < 0.)\n    {\n        float fac = sqrt(-4./3.*p), arg = -.5*q*sqrt(-27./p/p/p),\n            t1 = -fac*cos(acos(arg)/3.+pi/3.)-tau,\n            t2 = fac*cos(acos(arg)/3.)-tau,\n            t3 = -fac*cos(acos(arg)/3.-pi/3.)-tau;\n        t1 = clamp(t1,0.,1.);\n        t2 = clamp(t2,0.,1.);\n        t3 = clamp(t3,0.,1.);\n        float b1 = dist(p_0,p_1,p_2,uv,t1),\n            b2 = dist(p_0,p_1,p_2,uv,t2),\n            b3 = dist(p_0,p_1,p_2,uv,t3);\n        t_min = mix(mix(t1, t2, step(b2, b1)), t3, step(b3, min(b1, b2)));\n    } \n    float dis_min = dist(p_0,p_1,p_2,uv,t_min);\n\n    vec3 col = k.yyy;\n    //spline distance isolines\n    col += (0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)))*mod(dis_min,0.1)*10.+vec3(1.,0.,0.)*step(dis_min,.05);\n    //control points\n    col += k.yxx*step(length(uv-p_0), .05)+k.xyx*step(length(uv-p_1), .05)+k.yxx*step(length(uv-p_2), .05);\n    \n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}