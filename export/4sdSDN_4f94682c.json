{"ver":"0.1","info":{"id":"4sdSDN","date":"1459460256","viewed":253,"name":"Rotating ball","username":"martk","description":"Raymarched ball with bumpy effect, some light, rotation.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","rotate","ball","diffuse","spectral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ZMAX 50.0\n#define EP 0.01\n#define ITER 50\n\nvoid rotate(inout vec2 p, float ang) {\n    float c = cos(ang), s = sin(ang);\n    p = vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat map(vec3 m) {\n    \n    rotate(m.xy,iTime/8.);\n    rotate(m.yz,iTime/8.);\n    rotate(m.xz,iTime/8.);\n    \n    float d = sin(iTime)/10.+0.9;\n    float bumps = sin(d*m.x)*\n        \t\t  sin(d*m.y)*\n        \t\t  sin(d*m.z);\n    \n    return length(m) - 30.0 + bumps;   \n}\n\nvec3 getNormal(vec3 v) {\n \n    vec3 e = vec3(EP,0.,0.);\n    return normalize(vec3(\n    \tmap(v + e.xyy) - map(v - e.xyy),\n    \tmap(v + e.yxy) - map(v - e.yxy),\n    \tmap(v + e.yyx) - map(v - e.yyx)\n    ));\n    \n}\n\n\nfloat march(vec3 o,vec3 r,out vec3 m) {\n \n    float t = 0.0;\n        \n    for(int i=0;i<ITER;i++) {\n            \n    \tm = o + r*t;\n        float d = map(m);\n        \n        if(d < EP) {\n            break;\n        }\n        else{\n        \tt+=d;\n            if(t>=ZMAX){break;}\n        }\n    }\n    \n    return t;\n}\n\nvec3 colorize(vec3 m,vec3 normal,vec3 r,vec3 lightPos) {\n    \n    vec3 lightRay = normalize(m-lightPos);\n    float diffuse = max(0.0, dot(normal,-lightRay));\n    \n    vec3 reflectionDirection = reflect(lightRay, normal);\n    float spectral = pow(max(dot(reflectionDirection,-r), 0.0), 20.0);\n    \n    vec3 diff = vec3(1.0,0.0,0.0)*diffuse; //normal light, the farther the darker\n    vec3 spec = vec3(1.0,1.0,1.0)*spectral;//the shiny part of the light\n    vec3 ambi = vec3(0.2,0.0,0.0);\t\t   //ambient color\n    \n    return ambi+spec+diff;\n}\n\nvec3 getRayDir(vec2 screenPos, vec3 origin, vec3 lookAt, vec3 up, float fov) {\n    \n    vec3 d = normalize(lookAt-origin);\n    vec3 rayRight = normalize(cross(d, up));\n    \n    return normalize(screenPos.x*rayRight + screenPos.y*up + \n                     1.0/tan(radians(fov/2.0)) * d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec3 cameraPos = vec3(0.0, 0.0, 43);\n\tvec3 cameraUp = vec3(0.0, 1.0, 0.0);\n\tvec3 cameraLookAt = vec3(0.0, 0.0, -50.0);\n    \n\tvec2 origin = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    vec3 lightPos = vec3(0.0, 8.0, 200.0);\n    vec3 ray = getRayDir(origin, cameraPos, cameraLookAt, cameraUp, 90.0);\n    \n        \n    vec3 m;\n    float t = march(cameraPos,ray,m);\n    \n    if(t<ZMAX) {\n        //fog function makes the object darker the farther away it is\n        //diffuse light kinda does the same thing\n    \tfloat f = 1.0 / (1.0 + t*t*0.004);\n    \tfragColor = vec4(colorize(m,getNormal(m),ray,lightPos)*f,1.0);\n    }\n    else {\n        //the background\n    \tfragColor = vec4(0.2,0.2,0.2,0.);\n\n    }\n\t\n}","name":"Image","description":"","type":"image"}]}