{"ver":"0.1","info":{"id":"ss3BzS","date":"1656671407","viewed":118,"name":"berry-dm","username":"yui","description":"berry-dm: Display Manager for Berry Linux\n\nhttps://github.com/yui0/berry-dm","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["ui"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// berry-dm\n// Copyright Â© 2022 Yuichiro Nakada\n\n//\n/* Panteleymonov Aleksandr Konstantinovich 2015\n//\n// if i write this string my code will be 0 chars, :) */\n\n#define iterations 15.0\n#define depth 0.0125\n#define layers 8.0\n#define layersblob 20\n#define step 1.0\n#define far 10000.0\n\nfloat radius=0.25; // radius of Snowflakes. maximum for this demo 0.25.\nfloat zoom=4.0; // use this to change details. optimal 0.1 - 4.0.\n\nvec3 light=vec3(0.0,0.0,1.0);\nvec2 seed=vec2(0.0,0.0);\nfloat iteratorc=iterations;\nfloat powr;\nfloat res;\n\nvec4 NC0=vec4(0.0,157.0,113.0,270.0);\nvec4 NC1=vec4(1.0,158.0,114.0,271.0);\n\nlowp vec4 hash4( mediump vec4 n )\n{\n\treturn fract(sin(n)*1399763.5453123);\n}\nlowp float noise2( mediump vec2 x )\n{\n\tvec2 p = floor(x);\n\tlowp vec2 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tfloat n = p.x + p.y*157.0;\n\tlowp vec4 h = hash4(vec4(n)+vec4(NC0.xy,NC1.xy));\n\tlowp vec2 s1 = mix(h.xy,h.zw,f.xx);\n\treturn mix(s1.x,s1.y,f.y);\n}\n\nlowp float noise222( mediump vec2 x, mediump vec2 y, mediump vec2 z )\n{\n\tmediump vec4 lx = vec4(x*y.x,x*y.y);\n\tmediump vec4 p = floor(lx);\n\tlowp vec4 f = fract(lx);\n\tf = f*f*(3.0-2.0*f);\n\tmediump vec2 n = p.xz + p.yw*157.0;\n\tlowp vec4 h = mix(hash4(n.xxyy+NC0.xyxy),hash4(n.xxyy+NC1.xyxy),f.xxzz);\n\treturn dot(mix(h.xz,h.yw,f.yw),z);\n}\n\nlowp float noise3( mediump vec3 x )\n{\n\tmediump vec3 p = floor(x);\n\tlowp vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tmediump float n = p.x + dot(p.yz,vec2(157.0,113.0));\n\tlowp vec4 s1 = mix(hash4(vec4(n)+NC0),hash4(vec4(n)+NC1),f.xxxx);\n\treturn mix(mix(s1.x,s1.y,f.y),mix(s1.z,s1.w,f.y),f.z);\n}\nlowp vec2 noise3_2( mediump vec3 x )\n{\n\treturn vec2(noise3(x),noise3(x+100.0));\n}\n\nfloat map(mediump vec2 rad)\n{\n\tfloat a;\n\tif (res<0.0015) {\n\t\t//a = noise2(rad.xy*20.6)*0.9+noise2(rad.xy*100.6)*0.1;\n\t\ta = noise222(rad.xy,vec2(20.6,100.6),vec2(0.9,0.1));\n\t} else if (res<0.005) {\n\t\t//float a1 = mix(noise2(rad.xy*10.6),1.0,l);\n\t\t//a = texture(iChannel0,rad*0.3).x;\n\t\ta = noise2(rad.xy*20.6);\n\t\t//if (a1<a) a=a1;\n\t} else {\n\t\ta = noise2(rad.xy*10.3);\n\t}\n\treturn (a-0.5);\n}\n\nvec3 distObj(vec3 pos,vec3 ray,float r,vec2 seed)\n{\n\tmediump float rq = r*r;\n\tmediump vec3 dist = ray*far;\n\n\tmediump vec3 norm = vec3(0.0,0.0,1.0);\n\tmediump float invn = 1.0/dot(norm,ray);\n\tmediump float depthi = depth;\n\tif (invn<0.0) {\n\t\tdepthi =- depthi;\n\t}\n\tmediump float ds = 2.0*depthi*invn;\n\tmediump vec3 r1 = ray*(dot(norm,pos)-depthi)*invn-pos;\n\tmediump vec3 op1 = r1+norm*depthi;\n\tmediump float len1 = dot(op1,op1);\n\tmediump vec3 r2 = r1+ray*ds;\n\tmediump vec3 op2 = r2-norm*depthi;\n\tmediump float len2 = dot(op2,op2);\n\n\tmediump vec3 n = normalize(cross(ray,norm));\n\tmediump float mind = dot(pos,n);\n\tmediump vec3 n2 = cross(ray,n);\n\tmediump float d = dot(n2,pos)/dot(n2,norm);\n\tmediump float invd = 0.2/depth;\n\n\tif ((len1<rq || len2<rq) || (abs(mind)<r && d<=depth && d>=-depth)) {\n\t\tmediump vec3 r3 = r2;\n\t\tmediump float len = len1;\n\t\tif (len>=rq) {\n\t\t\tmediump vec3 n3 = cross(norm,n);\n\t\t\tmediump float a = inversesqrt(rq-mind*mind)*abs(dot(ray,n3));\n\t\t\tmediump vec3 dt = ray/a;\n\t\t\tr1 =- d*norm-mind*n-dt;\n\t\t\tif (len2>=rq) {\n\t\t\t\tr2 =- d*norm-mind*n+dt;\n\t\t\t}\n\t\t\tds = dot(r2-r1,ray);\n\t\t}\n\t\tds = (abs(ds)+0.1)/(iterations);\n\t\tds = mix(depth,ds,0.2);\n\t\tif (ds>0.01) {\n\t\t\tds=0.01;\n\t\t}\n\t\tmediump float ir = 0.35/r;\n\t\tr *= zoom;\n\t\tray = ray*ds*5.0;\n\t\tfor (float m=0.0; m<iterations; m+=1.0) {\n\t\t\tif (m>=iteratorc) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmediump float l = length(r1.xy); //inversesqrt(dot(r1.xy,r1.xy));\n\t\t\tlowp vec2 c3 = abs(r1.xy/l);\n\t\t\tif (c3.x>0.5) {\n\t\t\t\tc3=abs(c3*0.5+vec2(-c3.y,c3.x)*0.86602540);\n\t\t\t}\n\t\t\tmediump float g = l+c3.x*c3.x; //*1.047197551;\n\t\t\tl *= zoom;\n\t\t\tmediump float h = l-r-0.1;\n\t\t\tl = pow(l,powr)+0.1;\n\t\t\th = max(h,mix(map(c3*l+seed),1.0,abs(r1.z*invd)))+g*ir-0.245; //0.7*0.35=0.245 //*0.911890636\n\t\t\tif ((h<res*20.0) || abs(r1.z)>depth+0.01) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr1 += ray*h;\n\t\t\tray*=0.99;\n\t\t}\n\t\tif (abs(r1.z)<depth+0.01) {\n\t\t\tdist=r1+pos;\n\t\t}\n\t}\n\treturn dist;\n}\n\nvec3 nray;\nvec3 nray1;\nvec3 nray2;\nfloat mxc=1.0;\n\nvec4 filterFlake(vec4 color,vec3 pos,vec3 ray,vec3 ray1,vec3 ray2)\n{\n\tvec3 d=distObj(pos,ray,radius,seed);\n\tvec3 n1=distObj(pos,ray1,radius,seed);\n\tvec3 n2=distObj(pos,ray2,radius,seed);\n\n\tvec3 lq=vec3(dot(d,d),dot(n1,n1),dot(n2,n2));\n\tif (lq.x<far || lq.y<far || lq.z<far) {\n\t\tvec3 n=normalize(cross(n1-d,n2-d));\n\t\tif (lq.x<far && lq.y<far && lq.z<far) {\n\t\t\tnray = n;//normalize(nray+n);\n\t\t\t//nray1 = normalize(ray1+n);\n\t\t\t//nray2 = normalize(ray2+n);\n\t\t}\n\t\tfloat da = pow(abs(dot(n,light)),3.0);\n\t\tvec3 cf = mix(vec3(0.0,0.4,1.0),color.xyz*10.0,abs(dot(n,ray)));\n\t\tcf=mix(cf,vec3(2.0),da);\n\t\tcolor.xyz = mix(color.xyz,cf,mxc*mxc*(0.5+abs(dot(n,ray))*0.5));\n\t}\n\n\treturn color;\n}\n\nvoid _mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime*0.2;//*0.1;\n\tres = 1.0 / iResolution.y;\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) *res;\n\n\tvec3 rotate;\n\n\tmat3 mr;\n\n\tvec3 ray = normalize(vec3(p,2.0));\n\tvec3 ray1;\n\tvec3 ray2;\n\tvec3 pos = vec3(0.0,0.0,1.0);\n\n\tfragColor = vec4(0.0,0.0,0.0,0.0);\n\n\tnray = vec3(0.0);\n\tnray1 = vec3(0.0);\n\tnray2 = vec3(0.0);\n\n\tvec4 refcolor=vec4(0.0);\n\titeratorc=iterations-layers;\n\n\tvec2 addrot = vec2(0.0);\n\tif (iMouse.z>0.0) {\n\t\taddrot=(iMouse.xy-iResolution.xy*0.5)*res;\n\t}\n\n\tfloat mxcl = 1.0;\n\tvec3 addpos=vec3(0.0);\n\tpos.z = 1.0;\n\tmxc=1.0;\n\tradius = 0.25;\n\tfloat mzd=(zoom-0.1)/layers;\n\tfor (int i=0; i<layersblob; i++) {\n\t\tvec2 p2 = p-vec2(0.25)+vec2(0.1*float(i));\n\t\tray = vec3(p2,2.0)-nray*2.0;\n\t\t//ray = nray;//*0.6;\n\t\tray1 = normalize(ray+vec3(0.0,res*2.0,0.0));\n\t\tray2 = normalize(ray+vec3(res*2.0,0.0,0.0));\n\t\tray = normalize(ray);\n\t\tvec2 sb = ray.xy*length(pos)/dot(normalize(pos),ray)+vec2(0.0,time);\n\t\tseed=floor((sb+vec2(0.0,pos.z)))+pos.z;\n\t\tvec3 seedn = vec3(seed,pos.z);\n\t\tsb = floor(sb);\n\t\tif (noise3(seedn)>0.2 && i<int(layers)) {\n\t\t\tpowr = noise3(seedn*10.0)*1.9+0.1;\n\t\t\trotate.xy=sin((0.5-noise3_2(seedn))*time*5.0)*0.3+addrot;\n\t\t\trotate.z = (0.5-noise3(seedn+vec3(10.0,3.0,1.0)))*time*5.0;\n\t\t\tseedn.z += time*0.5;\n\t\t\taddpos.xy = sb+vec2(0.25,0.25-time)+noise3_2(seedn)*0.5;\n\t\t\tvec3 sins = sin(rotate);\n\t\t\tvec3 coss = cos(rotate);\n\t\t\tmr=mat3(vec3(coss.x,0.0,sins.x),vec3(0.0,1.0,0.0),vec3(-sins.x,0.0,coss.x));\n\t\t\tmr=mat3(vec3(1.0,0.0,0.0),vec3(0.0,coss.y,sins.y),vec3(0.0,-sins.y,coss.y))*mr;\n\t\t\tmr=mat3(vec3(coss.z,sins.z,0.0),vec3(-sins.z,coss.z,0.0),vec3(0.0,0.0,1.0))*mr;\n\n\t\t\tlight = normalize(vec3(1.0,0.0,1.0))*mr;\n\t\t\t//vec4 cc=filterFlake(fragColor,(pos+addpos)*mr,normalize(ray*mr+nray*0.1),normalize(ray1*mr+nray*0.1),normalize(ray2*mr+nray*0.1));\n\t\t\tvec4 cc = filterFlake(fragColor,(pos+addpos)*mr,ray*mr,ray1*mr,ray2*mr);\n\t\t\t//if (i>0 && dot(nray,nray)!=0.0 && dot(nray1,nray1)!=0.0 && dot(nray2,nray2)!=0.0) refcolor=filterFlake(refcolor,(pos+addpos)*mr,nray,nray1,nray2);\n\t\t\t//cc+=refcolor*0.5;\n\t\t\tfragColor=mix(cc,fragColor,min(1.0,fragColor.w));\n\t\t}\n\t\tseedn = vec3(sb,pos.z)+vec3(0.5,1000.0,300.0);\n\t\tif (noise3(seedn*10.0)>0.4) {\n\t\t\tfloat raf = 0.3+noise3(seedn*100.0);\n\t\t\taddpos.xy = sb+vec2(0.2,0.2-time)+noise3_2(seedn*100.0)*0.6;\n\t\t\tfloat l = length(ray*dot(ray,pos+addpos)-pos-addpos);\n\t\t\tl = max(0.0,(1.0-l*10.0*raf));\n\t\t\tfragColor.xyzw += vec4(1.0,1.2,3.0,1.0)*pow(l,5.0)*(pow(0.6+raf,2.0)-0.6)*mxcl;\n\t\t}\n\t\tmxc -= 1.1/layers;\n\t\tpos.z += step;\n\t\titeratorc += 2.0;\n\t\tmxcl -= 1.1/float(layersblob);\n\t\tzoom-= mzd;\n\t}\n\n\tvec3 cr = mix(vec3(0.0),vec3(0.0,0.0,0.4),(-0.55+p.y)*2.0);\n\tfragColor.xyz += mix((cr.xyz-fragColor.xyz)*0.1,vec3(0.2,0.5,1.0),clamp((-p.y+1.0)*0.5,0.0,1.0));\n\n\tfragColor = min( vec4(1.0), fragColor );\n\tfragColor.a = 1.0;\n}\n\n\n#define DEBUG\n#define HIGHQ\n#define BORDERIZE\n\nconst int shader5x7[144] = int[144](\n\t0x00000000, 0x00000000, 0x000000f6, 0x60006000, 0xfe280000, 0x0028fe28, 0x92ff9264, 0xc8c6004c, \n\t0x00c62610, 0x046a926c, 0x0000000a, 0x00000060, 0x42241800, 0x42000000, 0x00001824, 0x083e0814, \n\t0x10100014, 0x0010107c, 0x06010000, 0x10100000, 0x00101010, 0x00060600, 0x04020000, 0x00201008, \n\t0xa2928a7c, 0x4200007c, 0x000002fe, 0x928a8642, 0x82840062, 0x008cd2a2, 0xfe482818, 0xa2e40008, \n\t0x009ca2a2, 0x9292523c, 0x8e80000c, 0x00c0a090, 0x9292926c, 0x9260006c, 0x00789492, 0x006c6c00, \n\t0x6d000000, 0x0000006e, 0x82442810, 0x28280000, 0x00282828, 0x10284482, 0x8a800000, 0x00006090, \n\t0x525a423c, 0x907e0034, 0x007e9090, 0x929292fe, 0x827c006c, 0x00448282, 0x448282fe, 0x92fe0038, \n\t0x00828292, 0x809090fe, 0x827c0080, 0x005c9292, 0x101010fe, 0x828200fe, 0x008282fe, 0xfe818102, \n\t0x10fe0080, 0x00824428, 0x020202fe, 0x40fe0002, 0x00fe4020, 0x081020fe, 0x827c00fe, 0x007c8282, \n\t0x909090fe, 0x827c0060, 0x007a848a, 0x949890fe, 0x92640062, 0x004c9292, 0x80fe8080, 0x02fc0080, \n\t0x00fc0202, 0x040204f8, 0x02fc00f8, 0x00fc021c, 0x281028c6, 0x20c000c6, 0x00c0201e, 0xa2928a86, \n\t0xfe0000c2, 0x00008282, 0x08102040, 0x82000004, 0x0000fe82, 0x40804020, 0x01010020, 0x00010101, \n\t0x20400000, 0x2a040000, 0x001e2a2a, 0x222214fe, 0x221c001c, 0x00042222, 0x1422221c, 0x2a1c00fe, \n\t0x00102a2a, 0x40483e08, 0x25180020, 0x003e2525, 0x202010fe, 0x2200001e, 0x000002be, 0x00be0102, \n\t0x08fe0000, 0x00002214, 0x02fe8200, 0x203e0000, 0x001e2018, 0x2020103e, 0x221c001e, 0x001c2222, \n\t0x2424183f, 0x24180018, 0x003f1824, 0x2020103e, 0x2a120010, 0x0000242a, 0x227e2020, 0x023c0022, \n\t0x00023c02, 0x04020438, 0x023c0038, 0x003c0204, 0x14081422, 0x39000022, 0x003e0505, 0x322a2a26, \n\t0x6c100000, 0x00008282, 0x00ee0000, 0x82820000, 0x0000106c, 0x08102010, 0x00000010, 0x00000000\n);\n\nconst int ipow10[12] = int[12](1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 2147483647, 2147483647);\n#define calc_ipow10(x) ipow10[x]\n\n#define _SP 0\n#define _BANG 1\t// !\n#define _QUO 2\t// \"\n#define _NUM 3\t// #\n#define _DOL 4\t// $\n#define _PER 5\t// %\n#define _AMP 6\t// &\n#define _APO 7\t// '\n#define _LPA 7\t// (\n#define _RPA 8\t// )\n#define _AST 9\t// *\n#define _PLU 10\t// +\n#define _COM 11\t// ,\n#define _MIN 12\t// -\n#define _DOT 13\t// .\n#define _SLA 14\t// /\n#define _0 15\t// 0\n#define _CL 26\t// : colon\n#define _SCL 27\t// ; semicolon\n#define _LT 28\t// <\n#define _EQ 29\t// =\n#define _GT 30\t// >\n#define _QUE 31\t// ?\n#define _AT 32\t// @\n#define _A 33\n#define _B 34\n#define _C 35\n#define _D 36\n#define _E 37\n#define _F 38\n#define _G 39\n#define _H 40\n#define _I 41\n#define _J 42\n#define _K 43\n#define _L 44\n#define _M 45\n#define _N 46\n#define _O 47\n#define _P 48\n#define _Q 49\n#define _R 50\n#define _S 51\n#define _T 52\n#define _U 53\n#define _V 54\n#define _W 55\n#define _X 56\n#define _Y 57\n#define _Z 58\n// [\\]^_`\n\n#define _a 65\n#define _b 66\n#define _c 67\n#define _d 68\n#define _e 69\n#define _f 70\n#define _g 71\n#define _h 72\n#define _i 73\n#define _j 74\n#define _k 75\n#define _l 76\n#define _m 77\n#define _n 78\n#define _o 79\n#define _p 80\n#define _q 81\n#define _r 82\n#define _s 83\n#define _t 84\n#define _u 85\n#define _v 86\n#define _w 87\n#define _x 88\n#define _y 89\n#define _z 90\n// {|}~\n\n#define XPOS\t\t15\n#define YPOS\t\t3\n#define COLUMN\t\t30\n#define MAXCOLUMN\t60\n#ifdef DEBUG\nconst int data[1 +COLUMN*8 +MAXCOLUMN*2] = int[](\n0,\n_S, _E, _S, _S, _I, _O, _N, _SP, _CL,        _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP,\n_SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP,\n_U, _S, _E, _R, _SP, _SP, _SP, _SP, _CL,     _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP,\n_SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP,\n_P, _A, _S, _S, _W, _O, _R, _D, _CL,         _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP,\n_SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP,\n_L, _A, _N, _G, _U, _A, _G, _E, _CL,         _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP,\n_M, _E, _S, _S, _A, _G, _E, _SP, _SP,        _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP, _SP,\n1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,\n33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,\n_S,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,\n33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60\n);\n#endif\n\n#ifdef HIGHQ\n\n// Perform a fake \"texel\" lookup, and return all 4 cells.\nvec4 g5x7d(int ch, vec2 uv)\n{\n\tivec2 cell = ivec2(uv);\n\tint x = ch * 6 + cell.x;\n\tivec2 xres = ivec2(x, x-1);\n\t// Fixup gross edges.\n\tif (cell.x >= 6) xres.x = 0; //Special shader5x7 #0 is all zeroes.\n\tivec2 cv = ivec2(shader5x7[xres.x/4], shader5x7[xres.y/4]);\n\tivec2 movfs = (xres%4)*8;\n\tcv = (cv>>movfs)&0xff;\n\tivec4 value = ivec4(cv>>(cell.yy-1), cv>>(cell.yy+0))&1;\n\n\treturn vec4(value.yxwz);\n}\n\nvec2 fast_inverse_smoothstep(vec2 x)\n{\n\t// Uncomment for blobbier letters\n\t//return x;\n\treturn 0.5 - sin(asin(1.0-2.0*x)/3.0); //Inigo Quilez trick.\n}\n\nvec2 roundstep(vec2 x)\n{\n\tvec2 coss = cos(x*3.14159 + 3.14159);\n\tvec2 sins = sign(coss);\n\tcoss = abs(coss);\n\tcoss = pow(coss, vec2(1.0));\n\tcoss *= sins;\n\treturn coss / 2.0 + 0.5;\n}\n\nvec3 char5x7(int ch, vec2 uv)\n{\n#ifdef BORDERIZE\n\tuv *= vec2(7./6., 9./8.);\n\tuv += vec2(0.0, 0.0);\n#else\n\tuv += vec2(0., -.25);\n#endif\n\tvec4 d = g5x7d(ch, uv);\n\n\tvec2 lp = fast_inverse_smoothstep(fract(uv));\n\n\tfloat top =  mix(d.x, d.y, lp.x);\n\tfloat bottom = mix(d.z, d.w, lp.x);\n\tfloat v = (mix(top, bottom, lp.y));\n\n\t// This makes it be a harder edge (But still kinda soft)\n\tv = (v-.25)*(4.+ 1./length(dFdx(uv) + dFdy(uv)));\n\n\tv = clamp(v, 0., 1.);\n\n\tvec3 col = mix(vec3(0, 0, 0)*.5, vec3(uv.y+3., uv.y+3., 10.0)/10.0, float(v));\n\treturn col;\n}\n\n#else // HIGHQ\n\nvec3 char5x7(int ch, vec2 uv)\n{\n#ifdef BORDERIZE\n\tuv *= vec2(7./6., 9./8.);\n\tif (uv.x < 0. || uv.y < 0. || uv.x > 6. || uv.y > 8.) return vec3(0);\n#endif\n\tivec2 cell = ivec2(uv);\n\tint x = ch * 6 + int(cell.x);\n\tint cv = shader5x7[x/4];\n\tint movfs = (x%4)*8;\n\tint value  = ((cv>>(movfs+cell.y))&1);\n\tint value2 = ((cv>>(movfs+int(uv.y+.5)))&1);\n\tif (uv.y >= 7.0) value2 = 0;\n\tvec3 col = mix(vec3(value2, 0, value2)*.5, vec3(cell.y+3, cell.y+3, 10.0)/10.0, float(value));\n\treturn col;\n}\n\n#endif\n\nvec3 print5x7int(int num, vec2 uv, int places, int leadzero)\n{\n\tvec2 cuv = uv*vec2(places, 1.);\n\tvec2 luv = cuv*vec2(6, 8.);\n\tivec2 iuv = ivec2(luv);\n\tint posi = int(iuv.x)/6;\n\tint marknegat = -1;\n\tif (num < 0) marknegat = places-int(log(-float(num))/log(10.0))-2;\n\tnum = abs(num);\n\tint nn = (num/calc_ipow10(places-posi-1));\n\tif (posi == marknegat) nn = -3;\n\telse if (nn <= 0 && posi != places-1) nn = leadzero;\n\telse nn %= 10;\n\tint ch = nn+48-32;\n\treturn char5x7(ch, fract(cuv)*vec2(6.,8.));\n}\n\n// Zero Leading Integer Print\nvec3 print5x7intzl(int num, vec2 uv, int places)\n{\n\tvec2 cuv = uv*vec2(places, 1.);\n\tvec2 luv = cuv*vec2(6, 8.);\n\tivec2 iuv = ivec2(luv);\n\tint posi = int(iuv.x)/6;\n\tint nn = (num/calc_ipow10(places-posi-1));\n\tnn %= 10;\n\tint ch = nn+48-32;\n\treturn char5x7(ch, fract(cuv)*vec2(6.,8.));\n}\n\nvec3 print5x7float(float num, vec2 uv, int wholecount, int decimalcount)\n{\n\tvec2 cuv = uv*vec2(wholecount+decimalcount+1, 1.);\n\tvec2 luv = cuv*vec2(6, 8.);\n\tivec2 iuv = ivec2(luv);\n\tint posi = int(iuv.x)/6;\n\tint nn = -2;\n\n\tint marknegat = -1;\n\tif (num < 0.0) {\n\t\tmarknegat = wholecount-2-int(log(-num)/log(10.0));\n\t}\n    \n\tnum = abs(num);\n\tnum +=  pow(.1f,float(decimalcount))*.499;\n\tint nv = int(num);\n    \n\tif (posi < wholecount) {\n\t\tint wholediff = posi - wholecount+1;\n\t\tfloat v = (pow(10.0 , float(wholediff)));\n\t\tint ni = int(float(nv) * v);\n\t\tif (posi == marknegat) nn = -3;\n\t\telse if (ni <= 0 && wholediff != 0) nn = -16; //Blank out.\n\t\telse nn = ni%10;\n\t} else if (posi > wholecount) {\n\t\tnum -= float(nv);\n\t\tnn = int(num * pow(10.0, float(posi-wholecount)));\n\t\tnn %= 10;\n\t}\n\tint ch = nn+48-32;\n\n\treturn char5x7(ch, fract(cuv)*vec2(6, 8.));\n}\n\nfloat getData(int pos)\n{\n//\treturn texture(iChannel3, vec2((float(pos) + 0.5) / 256., .5/3.)).r;\n\tint x = pos % 256;\n\tint y = pos / 256;\n\treturn texture(iChannel3, vec2((float(x) + 0.5) / 256., (float(y) + 0.5)/3.)).r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\t// Normalized pixel coords only in X - y still free range.)\n\tvec2 uv = fragCoord/iResolution.xx;\n\tuv.y += (1.-(iResolution.y/iResolution.x))/2.0;\n\n\t// Rotozoom or adjust the uv coordinates.\n\tuv -= vec2(.5, .5);\n#ifdef ROTOZOOM\n\tuv.xy*=sin(iTime)*1.+1.;\n\tfloat theta = iTime*.1;\n\tuv = vec2(uv.x*cos(theta)-uv.y*sin(theta),\n\t\t  uv.x*sin(theta)+uv.y*cos(theta));\n#endif\n\tuv += vec2(.5, .3);\n\n\t// Make our \"screen size\" \n\tuv.y *= 40.0;\t// height: 40\n\tuv.x *= 5.0;\t// width : 60 (5*12)\n\n\t// Find our line and column.\n\tvec3 col = vec3(0.0); // black\n\tint line = 20-int(uv.y);\n\tint column = int(uv.x*12.);\n\n\tif (line>=YPOS && line<=YPOS+6 && column>=XPOS && column<XPOS+COLUMN) {\n\t\t// menu\n\t\tline -= YPOS;\n\t\tcolumn -= XPOS;\n#ifdef DEBUG\n\t\tint sel = data[0];\n\t\tint char = data[1 +line*COLUMN +column];\n#else\n\t\tint sel = int(getData(0)*255.);\n\t\tint char = int(getData(1 +line*COLUMN +column)*255.)-32;\n#endif\n\t\tcol = char5x7(char, mod(uv*vec2(6*12, 8), vec2(6, 8)));\n\n\t\tif (sel*2 == line) col = 1.0 - col; // selected\n\t} else if (line>=YPOS+9 && line<=YPOS+9 && column>=XPOS && column<XPOS+COLUMN) {\n\t\t// message\n\t\tcolumn -= XPOS;\n#ifdef DEBUG\n\t\tint char = data[1 +7*COLUMN +column];\n#else\n\t\tint char = int(getData(1 +7*COLUMN +column)*255.)-32;\n#endif\n\t\tcol = char5x7(char, mod(uv*vec2(6*12, 8), vec2(6, 8))) +vec3(0.2, 0., 0.);\n\t} else if (line>=19 && line<20 && column>=0 && column<MAXCOLUMN) {\n\t\t// statusbar\n\t\tline -= 19;\n\n\t\tuv.x *= 10.0/5.0; // 1/2 font size\n\t\tint column = int(uv.x*12.);\n#ifdef DEBUG\n\t\tcol = char5x7(data[1 +COLUMN*8 +MAXCOLUMN*line +column], mod(uv*vec2(6*12, 8), vec2(6, 8)));\n#else\n\t\tint char = int(getData(1 +COLUMN*8 +MAXCOLUMN*2*line +column)*255.);\n\t\tif (char>31 && char<176) char -= 32;\n\t\telse char = _SP;\n\t\tcol = char5x7(char, mod(uv*vec2(6*12, 8), vec2(6, 8)));\n#endif\n\t}\n\n\t// Output to screen\n//\tfragColor = vec4(col, 1.0);\n\n\t// Output to screen\n\t_mainImage(fragColor, fragCoord);\n\tfragColor += vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}