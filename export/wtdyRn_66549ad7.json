{"ver":"0.1","info":{"id":"wtdyRn","date":"1608395051","viewed":130,"name":"Hammer projection ellipsoid","username":"d_makarov_d","description":"Hammer map projection of a texture on an elipsoid","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shader for projecting coordinates on some rectangle to planetocentric \n// spherical coordinates, and then mapping this coordinates to a texture using \n// Hammer map projection, thus redusing distortion of the texture in the poles.\n//\n// Mathematics for projecting image coordinates to planetocentric were taken \n// from this article http://www.astron.kharkov.ua/dslpp/cartography/carthography.pdf\n// Surface texture\n// gShaderToy.SetTexture(1, {mSrc:'https://dl.dropboxusercontent.com/s/nv3uyznc1u34ecy/planet2.png?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'clamp', vflip:'true', srgb:'false', internal:'byte' }});\n// Normal map\n// gShaderToy.SetTexture(2, {mSrc:'https://dl.dropboxusercontent.com/s/n4bri3nv57qw41o/planet2_norm.png?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'clamp', vflip:'true', srgb:'false', internal:'byte' }});\nstruct Planet {\n    float b0;   // Declination\n    float l0;   // Inclination\n    vec3 ax;    // Semiaxes\n    vec3 pos;   // Position\n};\n\nstruct Camera {\n    vec3 pos;  // Position\n    vec3 dir;  // Direction\n    vec3 up;   // Upward direction\n};\n\nfloat modulus(vec3);\nfloat scalMul(vec3, vec3);\nvec3 scr2crt(vec2, Planet, Camera);\nvec2 crt2sphere(vec3);\nvec3 normal(Planet, vec3);\nvec2 hammer(vec2);\nvec2 aitoff(vec2);\nvec2 eqEarth(vec2);\nvec2 spher(vec3);\nfloat atmosphere(vec3, vec3);\nfloat pi = 3.141592653589793238;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 dm = (iMouse.zw - iMouse.xy + iResolution.xy) / iResolution.xy / 2.0;\n    // dm = dm - vec2(0.5, 0.5);\n    dm = dm * 4.0 * pi;\n    Planet p = Planet(0.0 + dm.y, 0.0 + dm.x + iTime / 16.0, vec3(0.45, 0.45, 0.45), vec3(0.0, 0.0, -2.0));\n    Camera c = Camera(vec3(0.0, 0.0, 0.0),\n                      vec3(0.0, 0.0, -1.0),\n                      vec3(0.0, 1.0, 0.0));\n    // light settings\n    float b0 = 0.0;\n    float l0 = mod(iTime / 16.0, 2.0 * pi);\n    mat3 rotb0 = mat3(1.0, 0.0,      0.0,   \n                      0.0, cos(b0),  sin(b0),\n                      0.0, -sin(b0), cos(b0));\n    mat3 rotl0 = mat3( cos(l0), 0.0, sin(l0),\n                      0.0,      1.0, 0.0,\n                      -sin(l0), 0.0, cos(l0));\n    vec3 lightDir = vec3(1.0, 0.0, 0.5) * 0.8 * rotb0* rotl0;\n    float ambient = 0.0;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.yy;\n    uv = uv - vec2(0.5, 0.5);\n    \n    vec3 crt = scr2crt(uv, p, c);\n    if (isnan(crt.x) || isnan(crt.y) || isnan(crt.z)) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    } else {\n        // get spherical coordinates\n        vec2 latLon = crt2sphere(crt);\n        // Coordinates on texture\n        vec2 onTex = aitoff(latLon);\n        // Color from texture\n        vec4 texColor = texture(iChannel1, onTex);\n        vec4 normals = texture(iChannel2, onTex);\n        // Normal to the ellipsoid\n        vec3 n = normal(p, crt);\n        normals.xyz = normalize(normals.xyz);\n        n = n * max(dot(n, normals.xyz), 0.0);\n        // diffuse light intensity\n        float diff = max(dot(n, lightDir), 0.0);\n        \n        // Output to screen\n        fragColor = texColor * diff;\n    }\n    \n    Planet atm = Planet(p.b0, p.l0, p.ax*1.12, p.pos);\n    vec3 crt2 = scr2crt(uv, atm, c);\n    vec3 n = normalize(normal(atm, crt2));\n    vec3 l = normalize(lightDir);\n    if (!isnan(crt2.x) && isnan(crt.x)) {\n        float i = min(0.0, dot(n, l));\n        i = 1.0 - abs(i);\n        i = pow(i, 8.0) * (1.0 - pow(length(uv) / length(crt2), 5.0));\n        fragColor = normalize(vec4(0.0, i, i, 1.0));\n    } else {\n        float aIntense = max(0.0, dot(n, l)) * length(uv) * length(uv);\n        fragColor = fragColor + vec4(0.0, aIntense, aIntense, aIntense);\n    }\n}\n\n/**\n  * Project \"Image\" coordinates (the ones, got from interpolating \n  * vertices, bounding the planet) to a point on an ellipsoid surface\n  * in planetocentric certesian coordinates\n  * @param xp Abscissa of the image coordinate system, directed\n  * from left to right\n  * @param yp Ordinate of the image coordinate system, directed\n  * from bottom to the top\n  * @param D distance to the planet from camera\n  * @param b0 Lattitude of the observer in planetocentric coordinates\n  * @param l0 Longitude of the observer in planetocentric coordinates\n  * @param A, B, C Elipsoid semiaxes\n  * @param theta Azimuth to the planet in image plane\n  * @param rho Displacement of the planet from the line of sight\n  * @param P0 Position angle of the planet. From \"The North is above\" position\n  * @return vec2(b, l) where b stands for lattitude and l dor longitude\n  */\nvec3 img2crt(float xp, float yp, float D, \n             float b0, float l0, float A, float B, float C,\n             float theta, float rho, float P0) {\n    // transformation to decart coordinate system with origin in the center of the planet\n    // rotate around Z axis\n    mat4 rotZ = mat4( cos(theta), sin(theta), 0.0, 0.0,\n                     -sin(theta), cos(theta), 0.0, 0.0,\n                     0.0,         0.0,        1.0, 0.0,\n                     0.0,         0.0,        0.0, 1.0);\n    // translation to observer point\n    mat4 trObz = mat4(1.0, 0.0, 0.0, 0.0,\n                      0.0, 1.0, 0.0, 0.0,\n                      0.0, 0.0, 1.0, -D,\n                      0.0, 0.0, 0.0, 1.0);\n    // rotate around X\n    mat4 rotX = mat4(1.0, 0.0,       0.0,      0.0,\n                     0.0, cos(rho),  sin(rho), 0.0,\n                     0.0, -sin(rho), cos(rho), 0.0,\n                     0.0, 0.0,       0.0,      1.0);\n    // translate to the planet center\n    mat4 trPlan = mat4(1.0, 0.0, 0.0, 0.0,\n                       0.0, 1.0, 0.0, 0.0,\n                       0.0, 0.0, 1.0, D,\n                       0.0, 0.0, 0.0, 1.0);\n    // place planet central meridian along Y\n    mat4 rotPos = mat4( cos(P0 - theta),  sin(P0 - theta), 0.0, 0.0,\n                        -sin(P0 - theta), cos(P0 - theta), 0.0, 0.0,\n                        0.0,         0.0,        1.0, 0.0,\n                        0.0,         0.0,        0.0, 1.0);\n    // rotate on b0 and l0\n    mat4 rotb0 = mat4(1.0, 0.0,       0.0,      0.0,\n                      0.0, cos(b0),  sin(b0),   0.0,\n                      0.0, -sin(b0), cos(b0),   0.0,\n                      0.0, 0.0,       0.0,      1.0);\n    mat4 rotl0 = mat4( cos(l0), 0.0, sin(l0), 0.0,\n                      0.0,      1.0, 0.0,     0.0,\n                      -sin(l0), 0.0, cos(l0), 0.0,\n                      0.0,      0.0, 0.0,     1.0);\n    // apply all transformations\n    // vec4 xyzA = rotl0 * rotb0 * rotPos * trPlan * rotX * trObz * rotZ * vec4(xp, yp, 0, 0);\n    vec4 xyzA = vec4(xp, yp, 0, 0) * rotZ * trObz * rotX * trPlan * rotPos * rotb0 * rotl0;\n    \n    // coordinates of the observer\n    vec3 obs = vec3(\n        D * sin(l0) * cos(b0), \n        D * sin(b0),\n        D * cos(l0) * cos(b0)\n    );\n    // find intersections with the elipsoid\n    float a1 = 1.0 / A * (xyzA.x - obs.x) / (xyzA.z - obs.z);\n    float a2 = obs.x / A - a1 * obs.z;\n    float a3 = (xyzA.y - obs.y) / (xyzA.z - obs.z) / B;\n    float a4 = obs.y / B - a3 * obs.z;\n    float c1 = a1 * a2 + a3 * a4;\n    float c2 = a1 * a1 + a3 * a3 + 1.0 / (C * C);\n    \n    float z1 = (-c1 + sqrt(c1 * c1 - c2 * (a2 * a2 + a4 * a4 - 1.0))) / c2;\n    float z2 = (-c1 - sqrt(c1 * c1 - c2 * (a2 * a2 + a4 * a4 - 1.0))) / c2;\n    vec3 p1 = vec3(A * (a1 * z1 + a2), B * (a3 * z1 + a4), z1);\n    vec3 p2 = vec3(A * (a1 * z2 + a2), B * (a3 * z2 + a4), z2);\n    // take the closest point\n    vec3 p;\n    if (modulus(obs - p1) < modulus(obs - p2)) {\n        p = p1;\n    } else {\n        p = p2;\n    }\n    \n    return p;\n}\n\n/**\n  * Hammer map rojection\n  * @param lb Lattitude and Longitude\n  * @retunr X and Y in decatr coordinate system\n  */\nvec2 hammer(vec2 bl) {\n    bl.y = bl.y - pi / 2.0;\n    float s = sqrt(1.0 + cos(bl.x) * cos(bl.y / 2.0));\n    float x = cos(bl.x) * sin(bl.y / 2.0) / s;\n    float y = sin(bl.x) / s;\n    y = (y + 1.0) / 2.0;\n    x = (x + 1.0) / 2.0;\n    return vec2(x, y);\n}\n\nvec2 aitoff(vec2 bl) {\n    bl.y = bl.y - pi / 2.0;\n    float coef = 1.2;\n    float a = acos(cos(bl.x) * cos(bl.y / 2.0));\n    float x = 2.0*(cos(bl.x / coef) * sin(bl.y / 2.0)) / (sin(a) / a);\n    float y = sin(bl.x) / (sin(a) / a);\n    y = (y / (pi/2.0) + 1.0) / 2.0;\n    x = (x / (pi) + 1.0) / 2.0;\n    return vec2(x, y);\n}\n\nvec2 eqEarth(vec2 bl) {\n    bl.y = bl.y - pi / 2.0;\n    float theta = asin(sqrt(3.0) / 2.0 * sin(bl.x));\n    float A1 = 1.340264;\n    float A2 = -0.081106;\n    float A3 = 0.000893;\n    float A4 = 0.003796;\n    float x = 2.0 * sqrt(3.0) * bl.y * cos(theta) / 3.0 / (9.0 * A4 * pow(theta, 8.0) + 7.0 * A3 * pow(theta, 6.0) + 3.0 * A2 * pow(theta, 2.0) + A1);\n    float y = A4 * pow(theta, 9.0) + A3 * pow(theta, 7.0) + A2 * pow(theta, 3.0) + A1 * theta;\n    float p1 = 2.7;\n    float p2 = 1.5;\n    x = (x + p1) / (p1 * 2.0);\n    y = (y + p2) / (p2 * 2.0);\n    return vec2(x, y);\n}\n\n/**\n  * Project coordinates from the screen to planetocentric certesian coordinates\n  */\nvec3 scr2crt(vec2 scr, Planet p, Camera c) {\n    float D = modulus(p.pos - c.pos);\n    float theta = atan(c.up.y, c.up.x);\n    float rho = 0.0;//acos(scalMul(p.pos, c.pos) / (modulus(p.pos) * modulus(c.pos)));\n    float P0 = 0.0;\n    vec3 plan2cam = c.pos - p.pos;\n    vec2 b0l0 = spher(plan2cam);\n    vec3 planetCrt = img2crt(scr.x, scr.y, \n                            D, b0l0.x + p.b0, b0l0.y + p.l0, p.ax.x, p.ax.y, p.ax.z, \n                            theta, rho, P0);\n    return planetCrt;\n}\n\n// get lattitude and longitude from certesian coordinates of a pont on the ellipsoid\nvec2 crt2sphere(vec3 crt) {\n    // get spherical coordinates\n    float b = asin(crt.y / modulus(crt));\n    float l = atan(crt.x / crt.z) - pi * sign(crt.z) * (1.0 - sign(crt.z)) / 2.0;\n    return vec2(b, l);\n}\n\n/**\n  * Calculate normal to the ellipsoid\n  * @param p Planet\n  * @param point Certesian coordinates of a point on the ellipsoid\n  * @return normal vector\n  */\nvec3 normal(Planet p, vec3 point) {\n    float b0 = -p.b0;\n    float l0 = -p.l0;\n    mat3 rotb0 = mat3(1.0, 0.0,      0.0,   \n                      0.0, cos(b0),  sin(b0),\n                      0.0, -sin(b0), cos(b0));\n    mat3 rotl0 = mat3( cos(l0), 0.0, sin(l0),\n                      0.0,      1.0, 0.0,\n                      -sin(l0), 0.0, cos(l0));\n    vec3 F = vec3(2.0 / p.ax.x * p.ax.x, \n                  2.0 / p.ax.y * p.ax.y, \n                  2.0 / p.ax.z * p.ax.z);\n    point = point * rotl0 * rotb0;\n    vec3 n = F * point;\n    return normalize(n);\n}\n\nfloat modulus(vec3 v) {\n    return sqrt(pow(abs(v.x), 2.0) + pow(abs(v.y), 2.0) + pow(abs(v.z), 2.0));\n}\n\nfloat scalMul(vec3 v1, vec3 v2) {\n    return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n}\n\nvec2 spher(vec3 v) {\n    float phi = atan(v.y, v.x);\n    float theta = acos(v.z / modulus(v));\n    return vec2(theta, phi);\n}","name":"Image","description":"","type":"image"}]}