{"ver":"0.1","info":{"id":"tss3Rs","date":"1547245586","viewed":536,"name":"[twitch] Gold and Silver","username":"NuSan","description":"Shader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can disable the FRINGE effect at the top.\nYou can also lower the STEPS if too slow","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","transparency","live","twitch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can disable the FRINGE effect with the define below.\nYou can also lower the STEPS if too slow\n*/\n                             \n#define FRINGE 1\n#define STEPS 100\n\n#define time (iTime*0.3)\n//float time = texture(texFFTIntegrated, 0.01).x*0.2;\n\nfloat sph(vec3 p, float r) {\n  return length(p)-r;\n}\n\nfloat cyl(vec2 p, float r) {\n  return length(p)-r;\n}\n\nfloat box(vec3 p, vec3 r) {\n  vec3 ap=abs(p)-r;\n  return length(max(vec3(0), ap)) + min(0.0, max(ap.x,max(ap.y,ap.z)));\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);  \n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*843.231)*8631.1423);\n}\n\nfloat curve(float t, float d) {\n  float g=t/d;\n  return mix(rnd(floor(g)), rnd(floor(g)+1.0), pow(smoothstep(0.0,1.0,fract(g)),10.0));\n}\n\nfloat mat=0.0;\n\nfloat map(vec3 p) {\n\n  vec3 bp=p;\n\n  float t = time*0.17;\n\n  for(int i=0; i<5; ++i) {\n    float t1 = curve(t+float(i)*0.42,0.4) * 2.0;\n    p-=0.1+0.1*float(i)+t1*0.1;\n    p.xy *= rot(t1*0.7);\n    p.yz *= rot(t1);\n    p=abs(p);\n    p-=0.2;\n  }\n  vec3 rp=p;\n\n  float t1 = curve(t+98.7424,0.7) * 3.0;\n  p-=0.3 - t1*.1;\n  p.xy *= rot(t1*0.7);\n  p.yz *= rot(t1);\n  p-=0.2;\n\n  float trans=box(rp, vec3(0.5));\n  float opa=box(p, vec3(0.05+curve(time, 1.2)*0.2));\n  opa = min(opa, cyl(rp.xy,0.05));\n  opa = smin(opa, sph(bp, 7.0), -3.0);\n  //opa = 10000;\n\n  \n  trans = max(trans, -opa+.02);\n  opa = max(opa, -trans+.02);\n\n  mat=0.0;\n  if(trans>opa) mat=1.0;\n\n  return min(trans, opa);\n}\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n}\n\nvoid cam(inout vec3 p) {\n  float t1=time*0.3 + curve(time, 0.7)*3.0;\n  p.zx *= rot(t1);\n  p.zy *= rot(t1*1.2);\n}\n\nvec3 ref(vec3 r) {\n  float px = pow(1.0-abs(fract(abs(r.x)*10.0)-0.5)*2.0, 3.0);\n  float py = pow(1.0-abs(fract(abs(r.y)*10.0)-0.5)*2.0, 3.0);\n  vec3 col = vec3(1,0.8,0.2)*px;\n  //col = mix(col, vec3(1,1.0,1.4)*0.7, py);\n  return col*0.5;\n}\n\nvec2 mir(vec2 uv, float a) {\n  uv *= rot(a);\n  uv.x = abs(uv.x);\n  return uv;\n}\n\nvec4 color(vec2 uv)\n{\n  float fsize=1.0;\n  #if FRINGE\n  \tfloat fringe = fract(floor(gl_FragCoord.y/fsize)*fsize/3.0);\n  \tvec3 fcol = 1.0-abs(fringe*3.0-vec3(0,1,2));\n  \tfcol = mix(fcol, vec3(1), 0.5);\n  #else\n\tfloat fringe = 0.5;\n    vec3 fcol=vec3(0.8);\n  #endif\n  float cx = (curve(time, 0.7)-0.5)*7.0;\n  float cy = (curve(time, 0.8)-0.5)*3.0;\n\n  vec3 s=vec3(cx,cy,-10);\n  vec3 r=normalize(vec3(-uv,0.6 + curve(time, 0.3)));\n\n  cam(s);\n  cam(r);\n\n  vec3 col = vec3(0);\n\n  vec3 p=s;\n  float dd=0.0;\n  float side=sign(map(p));\n  vec3 prod = vec3(1.0);\n  int i=0;\n  for(i=0; i<STEPS; ++i) {\n    float d=map(p)*side;\n    if(d<0.001) {\n      \n      vec3 n=norm(p)*side;\n      vec3 l = normalize(vec3(-1));\n\n      if(dot(l,n)<0.0) l=-l;\n\n      vec3 h = normalize(l-r);\n\n      float opa = mat;\n      vec3 diff=mix(vec3(1), vec3(1,0.8,0.2), mat);\n      vec3 diff2=mix(vec3(1), vec3(1,0.7,0.0), mat);\n      float spec=mix(0.2, 1.5, mat);\n      float fresnel = pow(1.0-max(0.0,dot(n,-r)),5.0);\n      \n      col += max(0.0, dot(n,l)) * (spec*(pow(max(0.0,dot(n,h)),50.0) * 0.5 + 0.5*diff2*pow(max(0.0,dot(n,h)),12.0)  )) * diff * prod;\n      \n      vec3 back = ref(reflect(r,n))*0.5*fresnel;\n      col += back;\n\n      side = -side;\n      d = 0.01;\n      r = refract(r,n,1.0 - 0.05*side*(0.5+0.5*fringe));\n      prod *= fcol*0.9;\n      if(opa>0.5) {\n        /*vec3 back = ref(r)*1.0*fresnel;\n        col = mix(col, back, prod);*/\n        prod=vec3(0);\n        break;\n      }\n    }\n    if(dd>100.0) {\n      dd=100.0;\n      break;\n    }\n    p+=r*d;\n    dd+=d;\n  }\n  if(i>99) {\n    prod=vec3(0);\n  }\n\n  vec3 back = ref(r);\n  col = mix(col, back, prod);\n  //col *= 3;\n\n  //col *= 3*pow(1-length(uv),0.7);\n  vec2 auv = abs(uv)-vec2(0.5,0.0);\n  col *= vec3(2.0*pow(1.0-clamp(pow(length(max(vec2(0),auv)),3.0),0.0,1.0),10.0));\n\n  #if 1\n    col = smoothstep(0.0,1.0,col);\n    col = pow(col, vec3(0.4545));\n  #endif\n  \n  //col = vec3( step(curve(uv.x, 0.04), uv.y*5) );\n  //col = fcol;\n\n  return vec4(col,1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec4 col = color(uv);\n\n  fragColor = vec4(col.xyz, 1);\n}","name":"Image","description":"","type":"image"}]}