{"ver":"0.1","info":{"id":"XtlSDn","date":"1435850165","viewed":670,"name":"Rolling Marbles (with shadows)","username":"rubixcom","description":"This version of the marbles has soft shadows but only one light source and is bit slower than my colourful version (https://www.shadertoy.com/view/ltXSWr)","likes":15,"published":3,"flags":1,"usePreview":0,"tags":["raymarching","reflection","simple","shadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int maxSteps = 80;\nconst int shadowSteps = 30;\nconst int reflectionSteps = 5;\n\n#define LIGHTS 1\n#define SHADOWS \n#define REFLECTIONS\n\nconst vec4 lightColor = vec4(1.0,.75,0.6,0.0); \nconst vec4 lightColor2 = vec4(0.0,1.0,0.6,0.0);\nconst vec4 lightColor3 = vec4(0.75,0.0,1.0,0.0);\n\nvec3 rayVector(in vec3 position, in vec3 target, in vec2 fragCoord)\n{\n    vec3 eye = normalize(target - position);\n    vec3 up = vec3(0., 1., 0.);\n    vec3 right = cross(eye, up);\n    up = cross(eye,right);\n\n    mat3 cameraMatrix = mat3(right.x, up.x, eye.x,\n                \t\t\t right.y, up.y, eye.y,\n                \t\t\t right.z, up.z, eye.z);\n\n    vec2 uv = fragCoord.xy / iResolution.xy - vec2(.5);\n    uv.x = uv.x * iResolution.x/iResolution.y;\n    uv.y = -uv.y;\n    float focalDistance = 0.6 + .3 * sin(iTime* .25);\n    return (normalize(vec3(uv.x,uv.y,focalDistance)) * cameraMatrix) * .5;\n}\n\nvec4 textureBall (in vec2 pos)\n{\n\treturn vec4(step(.5,fract((pos.x+pos.y)*4.)));\n}\n\nvec4 texturePlane (in vec2 pos)\n{\n\treturn vec4(abs(step(0.5,fract(pos.x*3.)) - step(0.5,fract(pos.y*3.))));\n}\n\nvec4 shade(in vec3 pos, in vec3 normal, in vec3 cameraVector, in vec3 lightPos, in vec4 lightColor, in vec4 surface)\n{\n    vec3 light = normalize(lightPos - pos);\n    float dotlight = dot(normal,light);\n\n    vec3 cameraReflected = normalize(reflect(cameraVector,normal));\n    float spec = 0.0;\n    if (dot(cameraReflected,light) < 0.0)\n        spec = min(1.0,pow(dot(cameraReflected,light),2.0));\n    return (surface\n        * vec4(0.2+dotlight) * lightColor\n        + vec4(0.5*spec)) * 10.0/length(lightPos - pos); // Sphere color\n}\n\nfloat map(in vec3 p, in vec3 shapeLoc, out vec3 pm)\t\n{\n\tfloat bounce = 1.6*abs(sin(iTime + float(int(p.y/6.0) + int(p.x/6.0))));\n\tpm = vec3(mod(p.x,6.0),p.y-bounce,mod(p.z,6.0)) - shapeLoc;\n\t\n\treturn min(length(pm) - 1.8, p.y); \n}\n\t\nvec3 normal(in vec3 p, in vec3 pm)\n{\n\tif (p.y < 0.1)\n\t{\n\t\treturn vec3(0.,1.,0.);\n\t}\n\telse\n\t{\n\t\treturn normalize(pm);\n\t}\n}\n\nvec4 textured(in vec3 p, in vec3 pm, in mat3 rotation)\n{\n\tif (p.y < 0.1)\n\t{\n\t\treturn texturePlane( vec2(p.x *.1 - 3.1415 * .5 * iTime,p.z *.1));\n\t}\n\telse\n\t{\n\t\tvec3 pmr = rotation * pm; \n\t\treturn textureBall( vec2(atan(pmr.x,pmr.z)*.20,pmr.y*.25));\n\t}\n}\n\nfloat shadow(in vec3 ro, in vec3 rd, in vec3 shapeLoc, in vec3 lightPos)\n{\n\tfloat res = 1.0;\n\tfloat t = 1.0;\n    for(int i = 1; i < shadowSteps; ++i)\n    {\n        vec3 pm = vec3(0.,0.,0.);\n\t\tvec3 p = ro + rd * t;\n\t\tfloat h = map(p, shapeLoc, pm);\n\t\tif ( h < 0.01 )\n\t\t\treturn 0.01;\n\t\t\n\t\tres = min( res, 4. * h / t);\n\t\tt += h;\n\t}\n\t\n\treturn res;\n}\n\nvec4 reflection(in vec3 ro, in vec3 rd, in vec3 shapeLoc, in mat3 rotation, in vec3 lights[3])\n{\n    vec4 color = vec4(0.0);\n\n    float t = 1.6;\n    for(int i = 0; i < reflectionSteps; ++i)\n    {\n        vec3 p = ro + rd * t;\n        \n        vec3 pm = vec3(0.,0.,0.);\n\t\tfloat d = map(p, shapeLoc, pm);\n        if(d < 0.1)\n        {\n\t\t\tvec3 normal = normal(p, pm); vec4 texc = textured(p, pm, rotation);\n\n\t\t\tcolor = (0.0\n#if (LIGHTS >= 1)\n\t\t\t\t+ shade(p, normal, -rd, lights[0], lightColor, texc)\n#endif\n#if (LIGHTS >= 2)\n\t\t\t    + shade(p, normal, -rd, lights[1], lightColor2, texc)\n#endif\n#if (LIGHTS >= 3)\n                + shade(p, normal, -rd, lights[2], lightColor3, texc)\n#endif\n\t\t\t) / float(LIGHTS);\n            break;\n        }\n\n        t += d;\n    }\n\n    return color;\n}\n\nvec4 march(in vec3 ro, in vec3 rd, in vec3 shapeLoc, in mat3 rotation, in vec3 lights[3])\n{\n    vec4 color = vec4(0.0);\n\n    float t = 0.0;\n    for(int i = 0; i < maxSteps; ++i)\n    {\n        vec3 p = ro + rd * t;\n\n        vec3 pm = vec3(0.,0.,0.);\n\t\tfloat d = map(p, shapeLoc, pm);\n        if (d <= 0.01)\n        {\n\t\t\tvec3 normal = normal(p, pm); vec4 texc = textured(p, pm, rotation);\n\n            vec3 cameraReflected = normalize(reflect(rd, -normal));\n\n\t\t\tcolor = (0.0\n#if (LIGHTS >= 1)\n\t\t\t\t+ shade(p, normal, -rd, lights[0], lightColor, texc)\n\t#ifdef SHADOWS\n\t\t\t\t* shadow(p, normalize(lights[0]-p), shapeLoc, lights[0])\n\t#endif\n#endif\n#if  (LIGHTS >= 2)\n\t\t\t\t+ shade(p, normal, -rd, lights[1], lightColor2, texc)\n\t#ifdef SHADOWS\n\t\t\t\t* shadow(p, normalize(lights[1]-p), shapeLoc, lights[1])\n\t#endif\n#endif\n#if  (LIGHTS >= 3)\n\t\t\t\t+ shade(p, normal, -rd, lights[2], lightColor3, texc)\n\t#ifdef SHADOWS\n\t\t\t\t* shadow(p, normalize(lights[2]-p), shapeLoc, lights[2])\n\t#endif\n#endif\n\t\t\t) / float(LIGHTS)\n#ifdef REFLECTIONS\n\t\t\t+ .5*reflection(p, cameraReflected, shapeLoc, rotation, lights)\n#endif\n\t\t\t;\n\t\t\tbreak;\n        }\n\n        t += d;\n    }\n    return color;\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n    vec3 shapeLoc = vec3(3.0,1.8,3.0);\n    vec3 lights[3];\n#if (LIGHTS >= 1)\n\tlights[0] = //vec3(-cameraLoc.x, 3.*cameraLoc.y, -cameraLoc.z);\n\t\tvec3(3. + 4.0 * sin(iTime*2.), 16.0 + 8.0 * sin(0.4*iTime) , 3.+4.0 * cos(2.*iTime));\n#endif\n#if (LIGHTS >= 2)\n\tlights[1] = vec3(3. + 4.0 * sin(iTime*3.), 4.0 + 4.0 * sin(0.2*iTime) , 3.+8.0 * cos(3.*iTime));\n#endif\n#if (LIGHTS >= 3)\n\tlights[2] = vec3(3. + 8.0 * sin(iTime*4.), 4.0 + 4.0 * sin(0.1*iTime) , 3.+4.0 * cos(4.*iTime));\n#endif\n    \n    mat3 rotation = mat3(cos(iTime*5.),-sin(iTime*5.), 0.,\n                  sin(iTime*5.),cos(iTime*5.), 0.,\n                   0.,0.,1.);\n    \n    ro *= 3.;\n    ro.y += 6.;\n    \n    fragColor = march(ro, rd, shapeLoc, rotation, lights);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 shapeLoc = vec3(3.0,1.8,3.0);\n    vec3 cameraLoc = vec3(4.0 * sin(iTime), 6.0 + 4.0 * sin(0.4*iTime) , 4.0 * cos(iTime)) + shapeLoc;\n    vec3 cameraTarget = shapeLoc + vec3(0.0,1.+1.*sin(iTime*.01),0.0);\n    vec3 lights[3];\n#if (LIGHTS >= 1)\n\tlights[0] = //vec3(-cameraLoc.x, 3.*cameraLoc.y, -cameraLoc.z);\n\t\tvec3(3. + 4.0 * sin(iTime*2.), 16.0 + 8.0 * sin(0.4*iTime) , 3.+4.0 * cos(2.*iTime));\n#endif\n#if (LIGHTS >= 2)\n\tlights[1] = vec3(3. + 4.0 * sin(iTime*3.), 4.0 + 4.0 * sin(0.2*iTime) , 3.+8.0 * cos(3.*iTime));\n#endif\n#if (LIGHTS >= 3)\n\tlights[2] = vec3(3. + 8.0 * sin(iTime*4.), 4.0 + 4.0 * sin(0.1*iTime) , 3.+4.0 * cos(4.*iTime));\n#endif\n    \n    vec3 ro = cameraLoc;\n    vec3 rd = rayVector(cameraLoc, cameraTarget, fragCoord);\n\n    mat3 rotation = mat3(cos(iTime*5.),-sin(iTime*5.), 0.,\n                  sin(iTime*5.),cos(iTime*5.), 0.,\n                   0.,0.,1.);\n\n    \n    fragColor = march(ro, rd, shapeLoc, rotation, lights);\n}\n","name":"Image","description":"","type":"image"}]}