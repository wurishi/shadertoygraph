{"ver":"0.1","info":{"id":"llyyRm","date":"1538697620","viewed":377,"name":"Cheap Gravitational Lensing","username":"NAME_REDACTED","description":"A very quick, cheap way to do artificial graviational lensing.  Is it physically accurate?  No.  Does it look pretty accurate?  I think so.  Drag mouse to change viewpoint.","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["blackhole","gravity","lensing","relativity","gravitation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define S_RADIUS .3\n#define HALO_BRIGHTNESS .25\n\n#define PI 3.14159265358979\n\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    float aspectRatio = iResolution.x/iResolution.y;\n\n    vec2 blackHolePos = vec2(\n        sin(iTime) + aspectRatio,\n        (cos(iTime * 1.22) + sin(iTime * .57))\n        ) * .2 + .5;\n    vec2 coord = uv - blackHolePos;\n    \n    //really cheap gravitational lensing approximation follows\n    \n    float len = 1. + (length(coord) - S_RADIUS) / S_RADIUS;\n    \n    if (len < S_RADIUS)\n    {\n        fragColor = vec4(0,0,0,0);\n        return;\n    }\n    \n    vec2 k = (coord / (len * len));\n    \n    //uncommenting this will darken and hide the edge of the black hole\n    //float brightness = atan((len - S_RADIUS) * 60.) / 1.5;\n    \n    vec2 mouse = vec2(iMouse.x * 2., iMouse.y) / length(iResolution.xy); //mouse offset\n    \n    vec2 vCoord = uv - vec2(0.5 * aspectRatio, 0.5);\n    vCoord *= cos(length(vCoord) * .5); //fake cheap 3d effect so it looks like we're rotating around the black hole\n\n    vec2 sCoord = vCoord - k - mouse - vec2(0., .25);// + vec2(iTime / 3., 0.);\n    \n    vec2 tCoord = sCoord;\n    tCoord.y = clamp(tCoord.y + .9, 0., 1.);\n    \n    // compute halo\n    float haloBrightness = sin(tCoord.y * PI);//sin(fragCoord.y / iResolution.y * PI);\n    haloBrightness = pow(haloBrightness, 4.);\n    vec3 hsv = vec3(tCoord.x * .3, .6, haloBrightness);\n    vec4 haloColor = vec4(hsv2rgb(hsv), 1.);\n\thaloColor = texture(iChannel1, tCoord * 2. - vec2(0., .5)) * haloColor;\n    haloBrightness = (haloColor.r + haloColor.g + haloColor.b) * HALO_BRIGHTNESS;\n    haloColor = haloColor * HALO_BRIGHTNESS + vec4(haloBrightness, haloBrightness, haloBrightness, 1.);\n    \n    fragColor = (texture(iChannel0, sCoord) + haloColor);// * brightness;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//starfield adapted from https://www.shadertoy.com/view/lsfGWH\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //recompute the star field once per second - in case they changed the screen size\n    if (iFrame % 60 == 0)\n    {\n        float size = 36.0;\n        float prob = 0.9;\n\n        vec2 pos = floor(1.0 / size * fragCoord.xy);\n\n        float color = 0.0;\n        float starValue = rand(pos);\n\n        if (starValue > prob)\n        {\n            vec2 center = size * pos + vec2(size, size) * 0.5;\n\n            float t = 0.9 + 0.2 * sin((starValue - prob) / (1.0 - prob) * 45.0);\n            t=t*t*t;\n\n            color = 1.0 - distance(fragCoord.xy, center) / (0.5 * size);\n            color = color * t / (abs(fragCoord.y - center.y)) * t / (abs(fragCoord.x - center.x));\n        }\n        else if (rand(fragCoord.xy / iResolution.xy) > 0.996)\n        {\n            float r = rand(fragCoord.xy);\n            color = r * 0.75;\n        }\n\n        fragColor = vec4(vec3(color), 1.0);\n    }\n    else\n    {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}