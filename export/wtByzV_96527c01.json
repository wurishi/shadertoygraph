{"ver":"0.1","info":{"id":"wtByzV","date":"1594821785","viewed":130,"name":"Diamond, Circle, Square Normals","username":"jt","description":"Like [url]https://www.shadertoy.com/view/wtSyzV[/url] but with explicitly computed normal vectors.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["normals","circle","square","diamond","norm","pnorm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2020 by jt\n// A unit-circle of norm 1/q with normal vectors.\n// Interpolating q from 1 to 0 results in a smooth transition from diamond (q=1) via circle (q=0.5) to square (q=0).\n// Instead of taking the limit for q=0 to avoid division by zero for visualization purpose some small q is sufficient.\n\n// (If square flickers reduce epsilon)\n#define EPS 1e-7\n\nvoid mainImage( out vec4 o, in vec2 I )\n{\n    vec2 R = iResolution.xy;\n    I = (2. * I - R) / R.y;\n\n    //float q = .5 + .5 * cos(iTime); // exact but division-by-zero occurs \n    float q = .5 + (.5 - EPS) * cos(iTime); // inexact but avoids division-by-zero\n    //o = vec4(dot(pow(abs(I), vec2(1./q)), vec2(1)) < pow(1., 1./q));\n    float p = 1./q;\n    float m = max(abs(I.x), abs(I.y));\n    //float d = pow(dot(pow(abs(I), vec2(p)), vec2(1)), q); // numerically unstable for large exponents\n    float d = m * pow(dot(pow(abs(I / m), vec2(p)), vec2(1)), q); // numerically stable for large exponents (maximal component normalized to 1)\n    //o = vec4(d < 1.); // easy but shows aliasing artifacts\n    o = vec4(smoothstep(1., .99, d)); // antialiased\n    //vec2 n = normalize(p * I * pow(abs(I), vec2(p - 2.))); // numerically unstable for large exponents\n    vec2 n = normalize(p * I * pow(abs(I / m), vec2(p - 2.))); // numerically stable for large exponents (maximal component normalized to 1)\n    o.xy *= 0.5 + 0.5 * n;\n    o.z = 0.;\n}\n","name":"Image","description":"","type":"image"}]}