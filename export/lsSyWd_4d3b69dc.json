{"ver":"0.1","info":{"id":"lsSyWd","date":"1494333224","viewed":334,"name":"Force Field 2.0","username":"Draedrus","description":"sci-fi force shield","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["scifi","scifi","atmosphere","forceshield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy /iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n    \n    vec2 ruv = uv;\n    float eps = 1.0/iResolution.y*0.75;\n    color += texture(iChannel0, uv+vec2(eps, 0.0)).rgb;\n    color += texture(iChannel0, uv+vec2(-eps, 0.0)).rgb;\n    color += texture(iChannel0, uv+vec2(0.0, eps)).rgb;\n    color += texture(iChannel0, uv+vec2(0.0, -eps)).rgb;\n    \n    color *= 0.25;\n    \n    fragColor = vec4(color, 1.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define RAYMARCH_ITERATIONS 120\n#define RAYMARCH_NEAR 0.05\n#define RAYMARCH_FAR 50.0\n\n#define TYPE_DEFAULT 0.0\n#define TYPE_GRASS 1.0\n#define TYPE_TREE 2.0\n\n#define PI 3.1418\n#define TREE_MAX_HEIGHT 1.1\n\n#define TIME iTime*0.01\n\n//max(0.9, sin(CAMERATIME))*40.0\n\nvec2 rot(vec2 X, float a)\n{\n \tfloat s = sin(a); float c = cos(a);\n    return mat2(c, -s, s, c)*X;\n}\n\n// noise for terrain heightmap\n\nfloat hash(vec2 uv)\n{\n \tvec2 suv = sin(uv);\n    suv = rot(suv, uv.x);\n    return fract(mix(suv.x*13.13032942, suv.y*12.01293203924, dot(uv, suv)));\n}\n\nfloat custom_perlin_hash(vec2 uv)\n{\n \tvec2 lower\t= floor(uv);\n    vec2 frac \t= fract(uv);\n    vec2 f = frac*frac*(3.0-2.0*frac);\n    \n    return mix(\n        \tmix(hash(lower+vec2(0.0, 0.0)), hash(lower+vec2(1.0, 0.0)), f.x),\n        \tmix(hash(lower+vec2(0.0, 1.0)), hash(lower+vec2(1.0, 1.0)), f.x),\n        \tf.y);\n}\n\nfloat fbm_hash(vec2 uv)\n{\n    float total = 0.0;\n    total += 0.5000*custom_perlin_hash(uv); uv*=2.001;\n    total += 0.2500*custom_perlin_hash(uv); uv*=2.003;\n    total += 0.1250*custom_perlin_hash(uv); uv*=2.002;\n    total += 0.0625*custom_perlin_hash(uv); uv*=2.001;\n    return clamp(total, 0.0, 1.0);\n}\n// end\n\nmat2 m2 = mat2(0.8, -0.6, 0.6, 0.8);\n\nfloat hash1(float p)\n{\n    return fract(p*1.32034232);\n}\n\n\nfloat hash2(vec2 p)\n{\n    return fract(dot(p, p*p)*1.32034232);\n}\n\nfloat hash3(vec3 p)\n{\n    return fract(dot(p, p*p)*1.32034232);\n}\n\nvec2 hash22(vec2 p)\n{\n    return fract(vec2(dot(p, p*p)*1.32034232, dot(p+1.0, (p+1.0)*(p+1.0))*1.55930423));\n}\n\nfloat fbm(vec3 p)\n{\n\tvec2 x = p.xz;\n    float f = 1.9;\n    float res = 1.0;\n    for(int i=0;i<4;++i)\n    {\n    \tfloat n=hash2(x);\n        res += res*n;\n        x = f*(m2*x);\n    }\n    return res;\n}\n\n/**************\nDepth calculus\n****************/\nfloat sdEllipsoidY( in vec3 p, in vec2 r )\n{\n    return (length( p/r.xyx ) - 1.0) * r.x;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n/*float opRepTrees( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return sdSphere(q, 0.8)+hash(q)*0.1;\n}*/\n\nfloat map_trees(vec3 p)\n{\n    p.y += 0.5f;\n\tfloat d = 100.0;\n\tvec2 n = floor( p.xz );\n    vec2 f = fract( p.xz * mix(1.0, 2.0, fbm_hash(p.xz)));\n    for( int j=-1; j<=1; j++ )\n\tfor( int i=-1; i<=1; i++ )\n\t{\n\t\tvec2  g = vec2( float(i), float(j) );\n\t\tvec2  o = hash22( n + g );\n        vec2  v = hash22( n + g + vec2(1.5,1.5) );\n\t\tvec2  r = g - f + o;\n\n        float height = TREE_MAX_HEIGHT * (0.4+0.3*v.x);\n        float width = 0.3*(0.9 + 0.2*v.x + 0.4*v.y);\n        vec3  q = vec3(r.x,p.y-height*0.9,r.y);\n        float k = sdEllipsoidY( q, vec2(width*0.8,height*0.9) );\n\n        d = min(d, k);\n\t}\n    \n    d-= .2*fbm_hash(2.*p.xz);\n\treturn max(0., d);\n}\n\nfloat map_terrain(vec3 p)\n{\n    return p.y+fbm_hash(p.xz*1.0)*2.0;//cos((p.x+p.z))*0.5+sin((0.5+p.z))*0.5;\n}\n\nvec2 opMin(vec2 a, vec2 b)\n{\n\treturn a.x<b.x?a:b;\n}\n\nvec2 map(vec3 p)\n{\n    float hm = map_terrain(p);\n    //return vec2(min(map_trees(p), hm), TYPE_GRASS);\n    vec3 ptrees = p;\n    p.y = hm;\n    return opMin(\n        \tvec2(hm, TYPE_GRASS),\n        \tvec2(map_trees(p*2.0), TYPE_TREE));\n}\n\nvec3 mapNormal(vec3 pt, float e)\n{\n    vec3 normal;\n    normal.y = map(pt).x;    \n    normal.x = map(vec3(pt.x+e,pt.y,pt.z)).x - normal.y;\n    normal.z = map(vec3(pt.x,pt.y,pt.z+e)).x - normal.y;\n    normal.y = e;\n    return normalize(normal);\n}\n\nvec2 raymarch(vec3 ro, vec3 rd, float tmin, float tmax)\n{\n    vec2 nearest = vec2(tmin, TYPE_DEFAULT);\n    for(int i=0;i<RAYMARCH_ITERATIONS;i++)\n    {\n        vec3 p = ro+rd*nearest.x;\n        vec2 res = map(p);\n        if(res.x<tmin || nearest.x>tmax)\n            break;\n        nearest.x += 0.5*res.x*res.x; // res square solves a lot of temporal depth noise\n        nearest.y = res.y;\n    }\n    return nearest;\n}\n\nvec2 normal_pack(vec3 n)\n{\n    return n.xy*0.5+0.5;\n}\n\nvoid StoreValue( vec2 re, vec4 va, inout vec4 fragColor, vec2 fragCoord )\n{\n    fragCoord = floor( fragCoord );\n    fragColor = ( fragCoord.x == re.x && fragCoord.y == re.y ) ? va : fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv, uvm, pixel;\n    ComputeUV(fragCoord, iMouse.xy, iResolution.xy, uv, uvm, pixel);\n    \n    vec3 ro, rd, target;\n    mat3 ca = GetCamera(CAMERA_TIME, pixel, uvm, ro, rd, target);\n    \n    vec2 rm = raymarch(ro, rd, RAYMARCH_NEAR, RAYMARCH_FAR);\n    float depth = rm.x;\n    \n    vec3 nrm = mapNormal(ro+rm.x*rd, 0.001);\n    vec2 nrmp = normal_pack(nrm);\n\tvec4 gbuffer = vec4(depth, nrmp.x, nrmp.y, rm.y);\n    \n    fragColor = gbuffer;\n    \n    StoreValue(vec2(0.0, 0.0), vec4(ro, RAYMARCH_NEAR), fragColor, fragCoord);\n    StoreValue(vec2(1.0, 0.0), vec4(target, RAYMARCH_FAR), fragColor, fragCoord);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n#define RAYMARCH_NEAR 0.01\n#define RAYMARCH_FAR 50.0\n\n#define TIME iTime*0.01\n\nfloat IntersectSphere(vec3 ro, vec3 rd, vec3 sc, float sr, out float tmin, out float tmax) {\n    vec3 Z = ro-sc;\n    float B = 2.0 * dot(rd, Z);\n    float C = Z.x*Z.x+Z.y*Z.y+Z.z*Z.z-sr*sr;\n    float D = B*B - 4.0*C;\n    float d = -1.0;\n    if(D>=0.0) {\n        if(C==0.0) {\n            tmax = -B/2.0;\n            d = 0.0;\n        }else{\n            tmin = (-B-sqrt(D))/2.0;\n            tmax = (-B+sqrt(D))/2.0;\n            d = 1.0;\n        }\n    }\n    return d;\n}\n\nfloat hash2D(vec2 x) {\n\treturn fract(sin(dot(x, vec2(13.454, 7.405)))*12.3043);\n}\n\n\nfloat hash3D(vec3 x) {\n\treturn fract(dot(x, vec3(12.4955, 49.4294, 42.40594))*13.4959451);    \n}\n\nfloat voronoi2D(vec2 uv) {\n    vec2 fl = floor(uv);\n    vec2 fr = fract(uv);\n    float res = 1.0;\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec2 p = vec2(i, j);\n            float h = hash2D(fl+p);\n            vec2 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nfloat voronoi3D(vec3 uv) {\n    vec3 fl = floor(uv);\n    vec3 fr = fract(uv);\n    float res = 1.0;\n    for(int k=-1;k<=1;k++)\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec3 p = vec3(i, j, k);\n            float h = hash3D(fl+p);\n            vec3 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nvec2 normal_pack(vec3 n)\n{\n    return n.xy*0.5+0.5;\n}\n\nvec4 LoadValue( vec2 tx )\n{\n    return floor( texture( iChannel0, ( tx + 0.5 ) / iChannelResolution[ 0 ].xy ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv, uvm, pixel;\n    ComputeUV(fragCoord, iMouse.xy, iResolution.xy, uv, uvm, pixel);\n    \n    // BAD READING VALUES\n    /*vec4 ro = LoadValue(vec2(0.0, 0.0)).xyzw;\n    vec4 target = LoadValue(vec2(1.0, 0.0)).xyzw;\n    \n    mat3 ca = setCamera(ro.xyz, target.xyz, vec3(0.0, 1.0, 0.0));\n    vec3 rd = ca*normalize(vec3(pixel.xy+uvm, 2.0));*/\n    \n    vec3 ro, rd, target;\n    mat3 ca = GetCamera(CAMERA_TIME, pixel, uvm, ro, rd, target);\n    \n        \n    float tmin = 0.0;\n    float tmax = 0.0;\n    float radius = 2.0;\n    \n    float x = IntersectSphere(ro.xyz, rd, target, radius, tmin, tmax);\n    float a1, a2;\n    /*vec4 h = hex((ro.xyz+tmax*rd).xz*1.0, a1, a2);\n    if(length(h)>0.8)\n    {\n        x= -1.0;\n    }*/\n    \n    float near = tmin;\n    float far = tmax;\n    \n    fragColor = vec4(near, far, radius, x);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n#define RAYMARCH_NEAR 0.01\n#define RAYMARCH_FAR 50.0\n\n#define TYPE_DEFAULT 0.0\n#define TYPE_GRASS 1.0\n#define TYPE_TREE 2.0\n\n#define GRASS_DIFFUSE vec3(0.05, 0.6, 0.1)\n#define DIRT_DIFFUSE vec3(0.6, 0.59, 0.3)\n#define TREE_DIFFUSE vec3(0.0, 0.3, 0.05)\n\n#define AIR_REFRACTION_INDEX 0.8\n#define MOLECURAL_DENSITY_SEA_LEVEL 1.0\n#define SCALE_HEIGHT 8000.0\n#define SUNDIST 149597870700.0\n#define ATMOSPHERERADIUS 6420e3\n#define EARTHRADIUS 6360e3\n#define SUNINTENSITY 20.0\n#define MOONINTENSITY 5.0\n#define SUNRADIUS 695700000.0\n#define EARTHPOS vec3(0.0, 0.0, 0.0)\n#define NORMALIZEDEPTH(_d) 1.0-(RAYMARCH_FAR-_d)/(RAYMARCH_FAR-RAYMARCH_NEAR)\n\n#define TIME iTime*0.01\n\nvec3 gTarget = vec3(0.0);\nfloat gNear = RAYMARCH_NEAR;\nfloat gFar = RAYMARCH_FAR;\n\nvec3 normal_decode(vec2 enc)\n{\n    vec3 n;\n    n.xy = enc*2.0-1.0;\n    n.z = sqrt(1.0-dot(n.xy, n.xy));\n    return n;\n}\n\nmat2 m2 = mat2(0.8, -0.6, 0.6, 0.8);\n\n\nfloat hash1(float p)\n{\n    return fract(p*1.3203423);\n}\n\nfloat hash2(vec2 p)\n{\n    return fract(dot(p, p*p)*1.3203423);\n}\n\nfloat hash3(vec3 p)\n{\n    return fract(dot(p, p*p)*1.3203423);\n}\n\nvec2 hash22(vec2 p)\n{\n    return fract(vec2(dot(p, p*p)*1.320342, dot(p+1.0, (p+1.0)*(p+1.0))*1.559304));\n}\n\nvec3 hash33(vec3 p)\n{\n    vec3 sp = sin(p*vec3(1.3203423, 1.50214323, 1.89853));\n    return fract(sp);   \n}\n\nvec2 rot(vec2 X, float a)\n{\n \tfloat s = sin(a); float c = cos(a);\n    return mat2(c, -s, s, c)*X;\n}\n\n\nfloat hash(vec2 uv)\n{\n \tvec2 suv = sin(uv);\n    suv = rot(suv, uv.x);\n    return fract(mix(suv.x*13.13032942, suv.y*12.01293203924, dot(uv, suv)));\n}\n\nfloat custom_perlin_hash(vec2 uv)\n{\n \tvec2 lower\t= floor(uv);\n    vec2 frac \t= fract(uv);\n    vec2 f = frac*frac*(3.0-2.0*frac);\n    \n    return mix(\n        \tmix(hash(lower+vec2(0.0, 0.0)), hash(lower+vec2(1.0, 0.0)), f.x),\n        \tmix(hash(lower+vec2(0.0, 1.0)), hash(lower+vec2(1.0, 1.0)), f.x),\n        \tf.y);\n}\n\nfloat fbm_hash(vec2 uv)\n{\n    float total = 0.0;\n    total += 0.5000*custom_perlin_hash(uv); uv*=2.001;\n    total += 0.2500*custom_perlin_hash(uv); uv*=2.003;\n    total += 0.1250*custom_perlin_hash(uv); uv*=2.002;\n    total += 0.0625*custom_perlin_hash(uv); uv*=2.001;\n    return clamp(total, 0.0, 1.0);\n}\n\nvec3 detailsNormalTrees(vec3 n, vec3 p)\n{\n    return normalize(n+hash33(p));\n}\n\nfloat IntersectSphere(vec3 ro, vec3 rd, vec3 sc, float sr, out float tmin, out float tmax) {\n    vec3 Z = ro-sc;\n    float B = 2.0 * dot(rd, Z);\n    float C = Z.x*Z.x+Z.y*Z.y+Z.z*Z.z-sr*sr;\n    float D = B*B - 4.0*C;\n    float d = -1.0;\n    if(D>=0.0) {\n        if(C==0.0) {\n            tmax = -B/2.0;\n            d = 0.0;\n        }else{\n            tmin = (-B-sqrt(D))/2.0;\n            tmax = (-B+sqrt(D))/2.0;\n            d = 1.0;\n        }\n    }\n    return d;\n}\n\n// From http://www.scratchapixel.com/old/lessons/3d-advanced-lessons/simulating-the-colors-of-the-sky/atmospheric-scattering/\nvec3 getSkyLight(vec3 ro, vec3 rd, vec3 L, vec3 betaR, vec3 betaM, out vec3 miecolor)\n{\n    vec3 light = vec3(0.0);\n    float tmin = 0.0;\n    float tmax = 0.0;\n    float d = IntersectSphere(ro, rd, EARTHPOS, ATMOSPHERERADIUS, tmin, tmax);\n    vec3 Pa = ro+rd*tmax;\n    /*if(d>0.0)\n        Pa = ro+rd*(tmax-tmin);*/\n    float RdotL = dot(rd, L);\n    float tCurrent = 0.0;\n    float segL = tmax/16.0;\n    /*if(d>0.0)\n        segL = (tmax-tmin)/16.0;*/\n    float g = 0.76; // 0.76\n    float g2 = g*g;\n    float hr = 7994.0; // 7994\n    float hm = 300.0; // 1200\n    // Rayleigh\n    vec3 sumR = vec3(0.0);\n    float phaseR = 3.0/(16.0*3.14)*(1.0+RdotL*RdotL);\n    //vec3 betaR = vec3(5.5e-6, 13.0e-6, 22.4e-6);\n    float opticalDepthR = 0.0;\n    // Mie\n    vec3 sumM = vec3(0.0);\n    //float phaseM = 3.0/(8.0*3.14)*((1.0-g*g)+(1.0+RdotL*RdotL))/((2.0+g*g)+pow(1.0+g*g-2.0*g*RdotL, 1.5));\n    // correction thanks to from http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter16.html\n    // my implementation has an error with the first terms in the equation\n    float phaseM = (\n        \t\t\t(3.0*(1.0-g2))/\n        \t\t\t(2.0*(2.0+g2))\n        \t\t\t)*\n        \t\t\t(\n                        (1.0+RdotL*RdotL)/\n                        pow(1.0+g2-2.0*g*RdotL, 1.5)\n                    );\n    //vec3 betaM = vec3(21e-6);\n    float opticalDepthM = 0.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        vec3 X = ro+rd*(tCurrent+0.5*segL);\n        float h = length(X) - EARTHRADIUS;\n        float _hr = exp(-h/hr)*segL;\n        float _hm = exp(-h/hm)*segL;\n        opticalDepthR += _hr;\n        opticalDepthM += _hm;\n        vec3 lRay = L;//normalize((SUNDIST*L)-X);\n        float tlmin = 0.0;\n        float tlmax = 0.0;\n        float dl = IntersectSphere(X, L, EARTHPOS, ATMOSPHERERADIUS, tlmin, tlmax);\n        float segLLight = tlmax/8.0;\n        float tCurrentLight = 0.0;\n        float opticalDepthLightR = 0.0;\n        float opticalDepthLightM = 0.0;\n        bool ended = true;\n        for (int j = 0; j < 8; ++j)\n        {\n            vec3 samplePositionLight = X+L*(tCurrentLight + 0.5 * segLLight);\n            float hLight = length(samplePositionLight) - EARTHRADIUS;\n            if (hLight < 0.0)\n            {\n                ended = false;\n                break;\n            }\n            opticalDepthLightR += exp(-hLight / hr) * segLLight;\n            opticalDepthLightM += exp(-hLight / hm) * segLLight;\n            tCurrentLight += segLLight;\n        }\n        if (ended)\n        {\n            vec3 tau = betaR * (opticalDepthR + opticalDepthLightR) + betaM * 1.1 * (opticalDepthM + opticalDepthLightM);\n            vec3 attenuation = vec3(exp(-tau.x), exp(-tau.y), exp(-tau.z));\n            sumR += _hr * attenuation;\n            sumM += _hm * attenuation;\n        }\n        tCurrent += segL;\n    }\n    miecolor = SUNINTENSITY * sumM * phaseM;\n    return SUNINTENSITY * (sumR * phaseR * betaR + sumM * phaseM * betaM);\n}\n\nvec3 getSkyColor(vec3 ro, vec3 rd, vec3 _light, bool sunFlareTwoSides)\n{\n    vec3 betaR = vec3(5.5e-6, 13.0e-6, 22.4e-6);\n    vec3 betaM = vec3(21e-6);\n    vec3 color = vec3(0.0);\n    vec3 miecolor = vec3(0.0);\n    \n    vec3 L = _light;\n    \n    color = getSkyLight(ro, rd, L, betaR, betaM, miecolor);//mix(COLORSKYB, COLORSKYT, clamp(rd.y+0.5, 0.0, 1.0));\n    \n\tfloat tmin = 0.0;\n    float tmax = 0.0;\n    float sunGrad = 0.0;\n    \n    float RdotL = dot(rd, L);\n    if(/*rd.y>(0.033) && */sunFlareTwoSides || RdotL>0.0/* && tmin>0.0*/)\n    {\n        sunGrad = pow(max(0.0, pow(RdotL, 2.0)-0.35), SUNINTENSITY);\n        sunGrad += pow((pow(RdotL, 256.0)), SUNINTENSITY);\n    }\n    \n    //return color;\n    return mix(color, miecolor, clamp(sunGrad, 0.0, 1.0));\n}\n\nvec3 getMieColor(vec3 ro, vec3 rd, vec3 _light)\n{\n    vec3 betaR = vec3(5.5e-6, 13.0e-6, 22.4e-6);\n    vec3 betaM = vec3(21e-6);\n    vec3 miecolor = vec3(0.0);\n    \n    vec3 L = _light;\n    \n    getSkyLight(ro, rd, L, betaR, betaM, miecolor);\n    \n    return miecolor;\n}\n\n// https://www.shadertoy.com/view/lstSRS\nvec3 tonemapping(vec3 color)\n{\n    //Tonemapping and color grading\n    color = pow(color, vec3(1.5));\n    color = color / (1.0 + color);\n    color = pow(color, vec3(1.0 / 1.5));\n\n    \n    color = mix(color, color * color * (3.0 - 2.0 * color), vec3(1.0));\n    color = pow(color, vec3(1.3, 1.20, 1.0));    \n\n\tcolor = clamp(color * 1.01, 0.0, 1.0);\n    \n    color = pow(color, vec3(0.7 / 2.2));\n    return clamp(color, 0.0, 1.0);\n}\n\nfloat blend(float val, float val0, float val1, float res0, float res1)\n{\n    if(val <= val0) return res0;\n    if(val >= val1) return res1;\n    return res0 + (val-val0)*(res1-res0)/(val1-val0);\n}\n\nvec3 SSG(vec2 _uv, vec3 _color, vec3 _grassColor, float depth, float _Time)\n{\n    vec2 dp = _uv;\n    //dp.y = 1.0-dp.y;\n\tfloat xx = dp.x;\n    float yy = dp.y;\n    \n    float d = depth*20.0;\n    \n    yy += xx*1000.0;\n    yy += _Time;\n\n\tfloat yoffset = fract(yy * d) / d;\n\n    vec2 uvoffset = _uv-vec2(0.0, yoffset);\n\n\tfloat depthShifted = texture(iChannel0, uvoffset).r;\n    //return vec3(yoffset*10000.0);\n\n    float alpha = clamp(1.0 - (yoffset*d)/3.8, 0.0, 1.0);\n    //alpha = clamp(1.0 - (yoffset*dclose/d)/3.8, 0.0, 1.0);\n    //return vec3(0.0, fract(yy * d), 0.0);\n    //return vec3(alpha);\n    /*return vec3(abs(depthShifted-depth)*10000.0);\n    return vec3(depthShifted<depth?1.0f:0.0f);*/\n\tif (depthShifted < depth)\n\t\treturn _color;\n\treturn mix(_color, _grassColor, alpha);\n}\n\nvec3 lightingGrass(\n    float depth,\n    vec3 P,\n    vec3 N,\n    vec3 L,\n    float type,\n\tvec2 _screenpos)\n{\n    float Lfact = max(0.0, dot(N, L));\n    \n    vec3 grassDff = GRASS_DIFFUSE;\n    grassDff = SSG(_screenpos.xy, grassDff, grassDff*vec3(0.4), depth, TIME);\n    \n    vec3 dirtDff = DIRT_DIFFUSE;\n    \n    vec3 grassDiffuse = mix(\n                        grassDff,\n                        dirtDff,\n                        fbm_hash(N.xz*0.6)\n                    ) * fbm_hash((N*10.1).xz) * Lfact;\n    //grassDiffuse = vec3(1., 0., 0.);\n    vec3 treeDiffuse = TREE_DIFFUSE * Lfact * Lfact;\n    return clamp(mix(\n        \t\t\tgrassDiffuse, // TYPE_GRASS\n        \t\t\ttreeDiffuse, // TYPE_TREE\n        \t\t\tclamp(type-TYPE_GRASS, 0.0, 1.0)\n    \t\t\t\t), 0.0, 1.0);\n}\n\nfloat phaseHenyeyGreenstein(float g, float cosTeta)\n{\n    return (1.-g*g)/(4.*3.14*pow(1.+g*g-2.*g*cosTeta, 1.5))\n        //+g*(1.+cosTeta)*.5 // from http://www.csroc.org.tw/journal/JOC25-3/JOC25-3-2.pdf\n        ;\n}\n\nvec3 applyFog(vec3 _color, vec3 _fColor, float cosTeta, float _d, float offset)\n{\n\tfloat uvfy = abs(1.0-_d)-offset;\n    return mix(_color,\n                _fColor*phaseHenyeyGreenstein(mix(-.2, .5, .5), cosTeta),\n                clamp(uvfy, 0.0, 1.0)\n                );\n}\n\nvec2 clouds(vec2 uv, float l, float cosTeta)\n{\n    float d = pow(fbm_hash(uv*20.1), 8.0);\n    float bl = exp(-d*l);\n    return vec2(bl, bl*SUNINTENSITY*phaseHenyeyGreenstein(mix(-.4, .8, .5), cosTeta));\n}\n\nfloat Fresnel_Schlick(float n1, float n2, float NdotV)\n{\n    float R0 = (n1-n2)/(n1+n2);\n    R0 *= R0;\n    return R0+(1.0-R0)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV);\n}\n\nvec3 lighting(\n    float depth,\n    vec3 ro,\n    vec3 rd,\n    vec3 n,\n    vec3 _light,\n    float type,\n    vec4 shield,\n    mat3 M,\n    vec2 _screenpos)\n{\n    vec3 roWorld = ro+vec3(0.0, EARTHRADIUS, 0.0);\n    float dnz = NORMALIZEDEPTH(depth);\n    mat2 R2D = mat2(0.6, -0.4, 0.4, 0.6);\n    mat3 R3D = mat3(0.6, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.6);\n\tvec3 color = vec3(0.0);\n\n    float ground = float(depth>RAYMARCH_NEAR && depth<RAYMARCH_FAR);\n \n    \n    vec3 colorGround = vec3(0.0);\n    \n    vec3 Pground = (roWorld+depth*rd);\n    float depthS = 1.0-abs(rd.y-0.5)*2.0;\n    vec3 Psky = vec3(rd.x*depthS, 1000.0, rd.z*depthS);\n    vec3 Nground = mix(\n                n,\n                detailsNormalTrees(n, n*1000.0),\n        \ttype-TYPE_GRASS);\n    vec3 L = -normalize(_light);\n    \n    vec3 rdmie = -normalize(vec3(L.x, L.y, SUNDIST));\n    rdmie = normalize(vec3(0.0, 1.2, 1.0));\n    vec3 mieColor = getMieColor(roWorld, rdmie, L);\n    \n    colorGround = lightingGrass(depth, Pground, Nground, L, type, _screenpos);\n    \n    // adding dirt\n    float dirtA = hash1(Pground.x);\n    \n    float RoL = dot(-rd, L);\n    \n    // SKY\n    vec2 C = clouds(Psky.xz*0.1+TIME*0.005, 100., RoL);\n    float Cc = C.x * (1.0-C.x)*max(0.0, dot(-L, vec3(C.x)));\n    vec3 colorSky = getSkyColor(roWorld, rd, L, false);\n    colorSky = C.x*colorSky+(1.-C.x)*C.y*tonemapping(mieColor);\n        //clamp(mix(C.x, Cc, C.x), 0.0, 1.0);\n    \n    // fog\n    // wtf...\n    vec3 fogColor = tonemapping(mieColor);\n\n    color = mix(\n        \t\tcolorSky,\n        \t\tcolorGround,\n        \t\tground);\n    float fogContrib = max(rd.y*4., exp(-4.*dnz));\n    color = applyFog(color, fogColor, RoL, clamp(3.*rd.y, 0., 1.)+exp(-4.*dnz), 0.);\n    //return vec3(clamp(4.*rd.y, 0., 1.));\n\n    // shield\n        \n    float tmin = 0.0;\n    float tmax = 0.0;\n    float radius = 1.0;\n    \n    vec3 Pshield = ro+rd*shield.x;\n    \n    vec3 Nshield = normalize(Pshield-gTarget);\n    vec2 tilesUV = Pshield.xz;\n    tilesUV.y += sin((Pshield.x)*10.0)*0.01;\n    float a;\n    Nshield += hex(tilesUV*1.5, a, a).xyz;\n    Nshield = normalize(Nshield);\n    \n    float Lfact = max(0.0, dot(Nshield, L));\n    \n    float F = Fresnel_Schlick(1.0, 1.9, max(0.0, dot(Nshield, -rd)));\n    \n    vec4 gbuffer = texture(iChannel0, _screenpos+F);\n    float depthr = gbuffer.x;\n    float typer = gbuffer.w;\n    vec3 ror = Pground;\n    vec3 nr = normal_decode(gbuffer.yz);\n    vec3 NR = mix(\n                n,\n                detailsNormalTrees(nr, nr*1000.0),\n        \ttype-TYPE_GRASS);\n    float dnzr = NORMALIZEDEPTH(depthr);\n    \n    vec3 rdr = rd*F;\n    vec3 colorRefrGround = lightingGrass(\n        \t\t\tdepthr,\n        \t\t\tPshield+rdr*max(0., shield.y-shield.x),\n        \t\t\tNground,\n        \t\t\tL,\n        \t\t\ttyper,\n        \t\t\t_screenpos);\n    vec3 rdReflect = reflect(rd, Nshield);\n    vec3 colorReflSky = getSkyColor(\n        Pshield+vec3(0.0, EARTHRADIUS, 0.0), rdReflect, L, false);\n    colorReflSky = applyFog(colorReflSky, fogColor, RoL, rdReflect.y, 0.012);\n\n    vec3 colorShield = vec3(1.0, 1.0, 1.0)*mix(\n    \t                depthr<RAYMARCH_FAR?colorRefrGround:color,\n       \t\t\t\t \tcolorReflSky,\n        \t\t\t\tF);\n    if(shield.w>0.0 && shield.x<depth)\n    {\n    \tcolor = colorShield*max(0., (1.-.05*(shield.y-shield.x)));\n    }\n    /*if(shield.w>0.0 && shield.x<depth)\n    {\n        float F4 = (1.0-F)*(1.0-F)*(1.0-F)*(1.0-F);\n        colorShield = mix(\n            \tcolorShield,\n            \tvec3(0.2, 0.4, 0.6),\n            \tF4*F4*F4);\n        color = colorShield+Lfact*F;\n        color = mix(color,\n                    clamp(color, 0.0, 1.0),\n                    clamp(\n                        max(1.0-abs(shield.y-depth),\n                        1.0-abs(shield.x-depth)),\n                        0.0, 1.0)\n                    );\n    }*/\n\t//return fogColor;\n    return tonemapping(color);\n}\n\nvec2 normal_pack(vec3 n)\n{\n    return n.xy*0.5+0.5;\n}\n\nvec4 LoadValue( vec2 tx )\n{\n    return floor( texture( iChannel0, ( tx + 0.5 ) / iChannelResolution[ 0 ].xy ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv, uvm, pixel;\n    ComputeUV(fragCoord, iMouse.xy, iResolution.xy, uv, uvm, pixel);\n    \n    /*vec3 ro = CAMERA_ORIGIN;\n    vec3 target = CAMERA_LOOKAT;\n    mat3 ca = setCamera(ro, target, CAMERA_UP);\n    vec3 rd = ca*normalize(vec3(pixel.xy, 2.0));*/\n\n    vec4 gbuffer = texture(iChannel0, uv);\n\n    vec3 N = normal_decode(gbuffer.yz);\n    float T = iTime*0.01;\n    /*\n    vec4 ro = LoadValue(vec2(0.0, 0.0)).xyzw;\n    vec4 target = LoadValue(vec2(1.0, 0.0)).xyzw;\n    vec4 shield = texture(iChannel1, uv).rgba;\n    mat3 ca = setCamera(ro.xyz, target.xyz, vec3(0.0, 1.0, 0.0));\n    vec3 rd = ca*normalize(vec3(pixel.xy+uvm, 2.0));*/\n    \n    vec3 ro, rd, target;\n    mat3 ca = GetCamera(CAMERA_TIME, pixel, uvm, ro, rd, target);\n\n    vec3 L = normalize(vec3(1.0, -1., 0.0));\n    \n    vec4 shield = texture(iChannel1, uv).rgba;\n    \n    gTarget = target;\n    gNear = RAYMARCH_NEAR;\n    gFar = RAYMARCH_FAR;\n    \n    vec3 color = lighting(gbuffer.x, ro, rd, N, L, gbuffer.a, shield, ca, uv);\n    //color = rd;\n    //color = P;\n    //color = vec3(gbuffer.x);\n    //color = N;\n    //color = detailsNormalTrees(N, (ro+gbuffer.x*rd)*100000.0);\n    //color = vec3(gbuffer.w/3.0);\n    //color = ro;\n    //color = vec3(N);\n    fragColor = vec4(color, 1.0);\n    \n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define CAMERA_LOOKAT vec3(0.0, -1.0, 0.0)\n#define CAMERA_UP vec3(0.0, 1.0, 0.0)\n#define CAMERA_TIME TIME*10.0\n#define CAMERA_DIST 6.0\n\n#define CAMERA_ORIGIN vec3(6.0, 0.5, -10.0)\n\n\n// the camera construction method is inspired by the one from IQ\nmat3 setCamera( in vec3 origin, in vec3 target, vec3 viewUp )\n{\n\tvec3 cw = normalize(target-origin);\n\tvec3 cu = normalize( cross(cw,viewUp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid ComputeUV(in vec2 pix, in vec2 mouse, in vec2 res, out vec2 uv, out vec2 uvm, out vec2 pixel)\n{\n    uv = pix.xy /res.xy;\n    uvm = mouse.xy /res.xy;\n    vec2 ratio = vec2(res.x/res.y, 1.0);\n    pixel = (-1.0 + 2.0*uv)*res.y/res.y*ratio;\n}\n\nmat3 GetCamera(float t, vec2 pixel, vec2 uvm, inout vec3 ro, inout vec3 rd, inout vec3 target)\n{\n    /*\n    vec4 ro = LoadValue(vec2(0.0, 0.0)).xyzw;\n    vec4 target = LoadValue(vec2(1.0, 0.0)).xyzw;\n    vec4 shield = texture(iChannel1, uv).rgba;\n    mat3 ca = setCamera(ro.xyz, target.xyz, vec3(0.0, 1.0, 0.0));\n    vec3 rd = ca*normalize(vec3(pixel.xy+uvm, 2.0));*/\n    \n    ro = CAMERA_ORIGIN;\n    ro = vec3(cos(t)*CAMERA_DIST, CAMERA_ORIGIN.y, sin(t)*CAMERA_DIST);\n    //ro = rot*ro;\n    target = CAMERA_LOOKAT;\n    mat3 ca = setCamera(ro, target, CAMERA_UP);\n    rd = ca*normalize(vec3(pixel.xy+uvm, 2.0));\n    rd = normalize(rd);\n    return ca;\n}\n\n/***************************************\n * Hexagonal tiles thanks to klk from https://www.shadertoy.com/view/lt2SzG\n ***************************************/\n\n#define pi 3.14159\n\n\nfloat vlx(vec2 uv, out float a)\n{\n    float v=0.0;\n    vec2 lp=uv-vec2(-0.5,0.5*tan(pi/6.0));\n    v=length(lp);a=atan(lp.y, lp.x);\n\n    vec2 lp1=uv-vec2(0.5,0.5*tan(pi/6.0));\n    float v1=length(lp1);\n    if(v1<v){v=v1;a=atan(lp1.y, lp1.x);}\n\n    vec2 lp2=uv-vec2( 0.0,-0.5/cos(pi/6.0));\n    float v2=length(lp2);\n    if(v2<v){v=v2;a=atan(lp2.y, lp2.x);}\n    \n    a=(a/pi*0.5+0.5);\n    \n    return v;\n}\n\nvec4 hex(vec2 uv, out float ang1, out float ang2)\n{\n    float x=uv.x;\n    float y=uv.y;\n    float h=1.0/cos(pi/6.0);\n    \n\tx+=(fract(y*h/2.0)>0.5?0.0:0.5);\n    x=fract(x)-0.5;\n    y=fract(y*h)/h-0.5/h;\n    float n=6.0;\n    float a=atan(x,y)/pi/2.0;\n    float v=length(vec2(x,y));\n    vec2 p=vec2(0,0);\n    vec2 p0=vec2(sin(pi/6.0),cos(pi/6.0));\n    if(y<0.0)p0.y=-p0.y;\n    if(x<0.0)p0.x=-p0.x;\n\tfloat v0=length(vec2(x,y)-p0);\n    if(v0<v)\n    {\n        v=v0;p=p0;\n\t    x=x-p.x;\n\t    y=y-p.y;\n    }\n\n    a=atan(x,y);\n    v=length(vec2(x,y))*2.0;\n    v=(v*5.0+a*pi/32.0)*10.0;\n\tfloat v1=0.0;\n    float v2=0.0;\n\n    v1=vlx(vec2(x,y), ang1);\n    v2=vlx(vec2(x,-y), ang2);\n    return vec4(x,y,v1,v2);\n}","name":"Common","description":"","type":"common"}]}