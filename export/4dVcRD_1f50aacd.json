{"ver":"0.1","info":{"id":"4dVcRD","date":"1521283139","viewed":256,"name":"Electrostatic Field Lines","username":"Mehigh","description":"Draws the direction of an electric field per cell. This is a very basic way to visualize the electrostatic field with basic electrostatisticity knowledge.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["electric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Physic Constants\nconst float _CoulombK = 1.0;\n//\n\nconst float _CellSubdivision = 0.04; // Normalized\nconst int _ChargeCount = 3;\nvec2 ChargePos[_ChargeCount] = vec2[]( vec2(0.3, 0.6), vec2(1.3, 0.3), vec2(1.0, 0.9) );\nfloat Charge[_ChargeCount] = float[] ( 1.0, -1.0, 1.0 );\n\nvec2 normalizedField(vec2 cellPos)\n{\n    vec2 field = vec2(0.0, 0.0);\n    \n    for(int i = 0; i < _ChargeCount; i++)\n    {\n        field += (_CoulombK * Charge[i] / pow(length(ChargePos[i] - cellPos), 3.0)) * (ChargePos[i] - cellPos);\n    }\n    \n    return field / length(field);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x = uv.x * iResolution.x/iResolution.y;\n    \n    // ChargePos[1] = vec2(iMouse.x * iResolution.x/iResolution.y, iMouse.y) / iResolution.xy; // grab mouse pos\n    ChargePos[1] = vec2(abs(sin(iTime)), abs(cos(iTime)));\n    \n    vec3 col = vec3(0.0, 0.0, 0.0);\n    vec2 cellPos = vec2(ceil(uv.x / _CellSubdivision) * _CellSubdivision, ceil(uv.y / _CellSubdivision) * _CellSubdivision);\n    vec2 cellCenter = cellPos - vec2(_CellSubdivision * 0.5, _CellSubdivision * 0.5);\n    \n    vec2 electricField = normalizedField(cellCenter) * _CellSubdivision + cellCenter;\n    float m = (electricField.y - cellCenter.y) / (electricField.x - cellCenter.x);\n    float c = cellCenter.y - m*cellCenter.x;\n    \n    // draw line here\n    float dist = abs(m*uv.x - uv.y + c)/sqrt(1.0 + m*m);\n    float lineBounds = (0.25 / iResolution.y) * (2.0 - (distance(electricField, uv)/_CellSubdivision)); // This gives the arrow head effect\n    float smoothFactor = 5.0 * lineBounds;\n    \n    if(dist <= lineBounds)\n    {\n        col = vec3(1.0, 1.0, 1.0);\n    }\n    else if(dist > lineBounds && dist <= smoothFactor) // Edge smoothness\n    {\n        col = (1.0 - ((dist - lineBounds) / smoothFactor)) * vec3(1.0, 1.0, 1.0);\n    }\n    \n    \n    col += vec3(0.1, 0.1, 0.4);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}