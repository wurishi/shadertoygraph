{"ver":"0.1","info":{"id":"3ldyzs","date":"1609743278","viewed":118,"name":"Wordsonplay: Tree experiments","username":"wordsonplay","description":"Attempting to write an SDF for a tree\n\nTwo implementations:\n1) Uses the branch number as a bitstring to calculate its position - O(nlogn)\n2) Uses a stack to compute branch positions recursively - O(n)\n\nit seems that #1 runs faster in real terms.\n\n","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["sdf","tree"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \"Tree distance\", by wordsonplay\n\n   License: Creative Commons Attribution ShareAlike 4.0\n   https://creativecommons.org/licenses/by-sa/4.0/\n       \n   Based on iq's \"Segment - distance 2D\"\n   https://www.shadertoy.com/view/3tdSDj\n\n*/\n\n//////////////////////////////////////////////////////////////////////\n\n#define MAX_DIST 1e38\n#define SCALE 2.0\n#define TAU 6.2831853071\n\nfloat rand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b, in float th, in float d )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return min(d, length(pa-h*ba) - th);\n}\n\nfloat sdSegment2( in vec2 p, in vec2 a, in vec2 b, in float th0, in float th1, in float d )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return min(d, length(pa-h*ba) - mix(th0, th1, h));\n}\n\n\nfloat sdCircle( in vec2 p, in vec2 c, float r, in float d)\n{\n    vec2 v = p - c;\n    return min(d, length(v) - r);\n}\n\nfloat sdGround( in vec2 p, in float d)\n{\n    vec2 size = SCALE * iResolution.xy / iResolution.y;\n    vec2 v1 = vec2(size.x, -1.5);\n\tvec2 v2 = vec2(-size.x, -1.5);;\n    float th = 0.01;\n    \n    return sdSegment(p, v1, v2, th, d);\n}\n\nfloat sdSun( in vec2 p, in float d)\n{\n    vec2 size = SCALE * iResolution.xy / iResolution.y;\n    vec2 v = vec2(-size.x * 0.75, 0.75);    \n    return sdCircle(p, v, 0.2, d);\n}\n\nmat2 rotate(float a)\n{\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nconst float pruneProb = 0.01;\nconst float angleL = -TAU / 12.;\nconst float angleR = TAU / 30.;\nconst mat2 rotL = mat2(cos(angleL), sin(angleL), -sin(angleL), cos(angleL));\nconst mat2 rotR = mat2(cos(angleR), sin(angleR), -sin(angleR), cos(angleR));\n\nconst mat2 flip = mat2(-1, 0, 0, 1);\n\nconst float scaleLeft = 0.8;\nconst float scaleRight= 0.99;\nconst float scaleThickness = 0.8;\n\nconst vec2 vUp = vec2(0,1);\n\n#define DEPTH 9\nconst int branches = (1 << DEPTH) -1;\n\n// IMPLEMENTATION 1\n//\n// This version should take O(nlogn) time to draw n branches\n// but it seems faster in real terms\n\nfloat sdBranch( in vec2 p, vec2 root, int i, in float d) \n{\n    float h = 0.6;\n    mat2 mat = mat2(1);\n    float th = 0.1;\n    vec2 v = root;\n        \n    int depth = 0;\n    float scale = 1.0;\n    int branch = 1;\n    bool skip = false;\n        \n    for (int j = i; j > 1; j = j / 2) \n    {\n        v = v + mat * vUp * h;\n            \n        float r = rand(vec2(branch) + root);\n            \n        int b = j % 2;\n        branch = branch * 2 + b;\n        mat *= (b == 0 ? rotR : rotL);\n        mat = (r > 0.5 ? mat * flip : mat);\n        scale = (b == 0 ? scaleRight : scaleLeft); \n        scale *= mix(scaleLeft, scaleRight, r);\n        h *= scale;\n        th *= scale * scaleThickness;\n        depth += 1;\n            \n        // drop some branches\n        if (abs(2. * r - 1.) < pruneProb)\n        {\n            return d;\n        }\n    }\n\n\n    return sdSegment2(p, v, v + mat * vUp * h, th, th * scaleThickness, d);\n}\n\nfloat sdTree(in vec2 p, in vec2 root, in float d)\n{\n\n    for (int i = 1; i <= branches; i++)\n    {\n        d = sdBranch(p, root, i, d);\n    }\n    \n    return d;\n}\n\n\n// IMPLEMENTATION 2\n//\n// Stack-based implementation\n// This version should take O(n) time to draw n branches\n// but it seems slower in real terms\n\nfloat h[DEPTH];\nmat2 mat[DEPTH];\nfloat th[DEPTH];\nvec2 v[DEPTH];\nint dd[DEPTH];\n\nfloat sdTree2(in vec2 p, in vec2 root, in float d)\n{\n    int stack = 1;\n\n    h[0] = 0.6;\n    mat[0] = mat2(1);\n    th[0] = 0.1;\n    v[0] = root;\n    dd[0] = 1;\n\n    int branch = 0;\n\n    while (stack > 0)\n    {\n        branch += 1;\n        \n        // pop entry off stack\n        stack -= 1;\n        mat2 m = mat[stack];\n        float thickness = th[stack];\n        float height = h[stack];\n        int depth = dd[stack];\n\n        float rnd = rand(vec2(branch) + root);\n        \n        // drop some branches\n        if (abs(2. * rnd - 1.) > pruneProb) \n        {\n            // flip 50% of the time\n            m = (rnd > 0.5 ? m * flip : m);\n        \n            // build branch\n            vec2 v1 = v[stack] + m * vUp * height;\n\n                d = sdSegment2(p, v[stack], v1, thickness, thickness * scaleThickness, d);\n\n                // recurse\n                if (depth < DEPTH)\n                {\n                    // left branch\n                    v[stack] = v1;\n                    mat[stack] = m * rotL;\n                    float scale = scaleLeft * mix(scaleLeft, scaleRight, rnd);\n                    h[stack] = height * scale;\n                    th[stack] = thickness * scale * scaleThickness;\n                    dd[stack] = depth + 1;                    \n                    stack += 1;\n\n                    // right branch\n                    v[stack] = v1;\n                    mat[stack] = m * rotR;\n                    scale = scaleRight * mix(scaleLeft, scaleRight, rnd);\n                    h[stack] = height * scale;\n                    th[stack] = thickness * scale * scaleThickness;\n                    dd[stack] = depth + 1;\n                    stack += 1;\n                }\n        }\n    }\n    \n    return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    p *= SCALE;\n\n    float d = MAX_DIST;\n\n    d = sdGround(p, d);\n    d = sdTree(p, vec2(-1.2, -1.5), d);\n    d = sdTree(p, vec2(1.2, -1.5), d);\n \n    vec3 col = vec3(1.0) - sign(d)*vec3(0.4,0.7,0.1);\n\tcol *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n    \n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}