{"ver":"0.1","info":{"id":"tdVSDd","date":"1575379625","viewed":117,"name":"3D sonograph","username":"alquipe_3","description":"Based on video heightfield by @simesgreen, https://www.shadertoy.com/view/Xss3zr\nRaycasting of a heightfield defined by luminance of sonograph\nThanks to mattz for the matploit colormaps: https://www.shadertoy.com/view/WlfXRN","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["heightfield","audio"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based on video heightfield by @simesgreen, https://www.shadertoy.com/view/Xss3zr\n\nconst int _Steps = 64;\nconst vec3 lightDir = vec3(0.577, 0.577, 0.577);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5*iResolution.xy)/iResolution.y * vec2(-0.6, 0.9) + vec2(0., -0.05);\n    \n    vec3 ro = vec3(0, 3., -3.);\n    vec3 lookat = vec3(0., 0, 0.);\n    float zoom = 1.;\n    \n    vec3 f = normalize(lookat-ro),\n    r = normalize(cross(vec3(0,1,0), f)),\n    u = cross(f, r),\n    c = ro + f * zoom,\n    i = c + uv.x * r + uv.y * u,\n    rd = normalize(i-ro);\n    \n\t// intersect with bounding box\n    float hit;\t\n\tconst vec3 boxMin = vec3(-1.0, -0.00, -1.);\n\tconst vec3 boxMax = vec3(1.0, 1.5, 1.0);\n\tfloat tnear, tfar;\n\t//hit = intersectBox(ro, rd, boxMin, boxMax, tnear, tfar);\n    // compute intersection of ray with all six bbox planes\n\tvec3 invR = 1.0 / rd;\n\tvec3 tbot = invR * (boxMin - ro);\n\tvec3 ttop = invR * (boxMax - ro);\n\t// re-order intersections to find smallest and largest on each axis\n\tvec3 tmin = min (ttop, tbot);\n\tvec3 tmax = max (ttop, tbot);\n\t// find the largest tmin and the smallest tmax\n\tvec2 t0 = max (tmin.xx, tmin.yz);\n\ttnear = max (t0.x, t0.y) - 0.001;\n\tt0 = min (tmax.xx, tmax.yz);\n\ttfar = min (t0.x, t0.y);\n\t// check for hit\n    if (tnear > tfar){\n\t\thit = 0.;\n    }\n    else{\n\t\thit = 1.;\n    }\n\n\tvec3 pnear = ro + rd*tnear;\n    vec3 pfar = ro + rd*tfar;\n\t\n    float stepSize = length(pfar - pnear) / float(_Steps);\n\tfloat rabolargo = 0.;\n    vec4 rgb = vec4(0.);//background(rd);\n    \n//DANGERZONE-----DANGERZONE-----DANGERZONE-----DANGERZONE-----DANGERZONE-----DANGERZONE-----\n//-----DANGERZONE-----DANGERZONE-----DANGERZONE-----DANGERZONE-----DANGERZONE-----DANGERZONE\n//RZONE-----DANGERZONE-----DANGERZONE-----DANGERZONE-----DANGERZONE-----DANGERZONE-----DANGE\n//DANGERZONE-----DANGERZONE-----DANGERZONE-----DANGERZONE-----DANGERZONE-----DANGERZONE-----\n\t\n    float rabo = 0.;\n    vec2 rabo2 = vec2(0., 0.);\n    vec3 rabo3 = vec3(0., 0., 0.);\n    \n    if(hit == 1.)\n    {\n    \t// intersect with heightfield\n\t\tro = pnear;\n\t\tvec3 hitPos;\n\t\t//hit = traceHeightField(ro, rd*stepSize, hitPos);\n        \n\t\tvec3 p2 = ro;\n\t\tfloat hit2 = 0.0;\n\t\tfloat pH = 0.0;\n\t\tvec3 pP = p2;\n        vec3 rayStep = rd*stepSize;\n\t\tfor(int i=0; i<_Steps; i++) {\n\t\t\t//float h = heightField(p2);\n            \t//return luminance(iChannel0, worldToTex(p))*0.5;\n            //World to texture\n            vec2 nuv = p2.xz*0.5+0.5;\n            rabo2 = nuv;\n\t\t\tnuv.y = 1.0 - nuv.y;\n            //Lum\n            vec4 c = texture(iChannel0, nuv);\n\t\t\tfloat h = dot(c, vec4(0.33, 0.33, 0.33, 0.33))*0.5;\n            \t\t//\n            /*\n\t\t\trabolargo = h;\n\t\t\tif ((p2.y < h) && hit2 == 0.) {\n\t\t\t\thit2 = 1.;\n\t\t\t\t//hitPos = p;\n\t\t\t\t// interpolate based on height\n            \thitPos = mix(pP, p2, (pH - pP.y) / ((p2.y - pP.y) - (h - pH)));\n\t\t\t}\n\t\t\t*/\n\t\t\tpH = h;\n\t\t\tpP = p2;\n\t\t\t//p2 += rayStep;\n\t\t}\n\t\t//return hit;\n\t\t\n        //rgb = vec4(hit2, hitPos);\n\t\tif (hit2 == 1.) {\n\t\t\t//rgb = hitPos*0.5+0.5;\n\t\t\t//vec2 uv = worldToTex(hitPos);\n            vec2 suv = hitPos.xz*0.5+0.5;\n\t\t\tsuv.y = 1.0 - suv.y;\n\t\t\trgb = texture(iChannel0, suv);\n            //rgb = vec4(1.);\n\t\t}\n    }\n\n    fragColor=vec4(rgb);\n\t//fragColor = vec4(vec3(tfar - tnear)*0.2, 1.0);\n    //fragColor=vec4(rabo2, 0., 1.);\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*based on darkeclipz's \"Sound & buffer test\".\nhttps://www.shadertoy.com/view/3sfXR4\n*/\n\n#define R iResolution.xy\n\nvec3 palette( in float t) {\n   \tconst vec3 c0 = vec3(-0.002136485053939582, -0.000749655052795221, -0.005386127855323933);\n    const vec3 c1 = vec3(0.2516605407371642, 0.6775232436837668, 2.494026599312351);\n    const vec3 c2 = vec3(8.353717279216625, -3.577719514958484, 0.3144679030132573);\n    const vec3 c3 = vec3(-27.66873308576866, 14.26473078096533, -13.64921318813922);\n    const vec3 c4 = vec3(52.17613981234068, -27.94360607168351, 12.94416944238394);\n    const vec3 c5 = vec3(-50.76852536473588, 29.04658282127291, 4.23415299384598);\n    const vec3 c6 = vec3(18.65570506591883, -11.48977351997711, -5.601961508734096);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))))*1.;\n}\n\nvec3 map(float w) {\n\treturn palette(w);\n}\n//Horizontal\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec4 fft = vec4(0.);\n    if(uv.x > 0.99){\n    \tfft = vec4(map(texture(iChannel1, vec2(uv.y, 0.)).x), 0); // set initial color..\n    }\n    else{\n    \tfft = (texture(iChannel0, uv + vec2(1./R.x, 0.)));\t// grab color from pixel\n    }\n    //fft.y = fft.x;\n    fft.z = fft.z;\n    fragColor = fft;\n}\n/*\n//Vertical\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec4 fft = vec4(0.);\n    if(uv.y > 0.99){\n    \tfft = vec4(map(texture(iChannel1, vec2(uv.x, 0.)).x), 0); // set initial color..\n    }\n    else{\n    \tfft = (texture(iChannel0, uv + vec2(0., 1./R.y)));\t// grab color from pixel\n    }\n\n    // Output to screen\n    fragColor = fft;\n}\n*/\n","name":"Buffer A","description":"","type":"buffer"}]}