{"ver":"0.1","info":{"id":"NttSD4","date":"1639134537","viewed":192,"name":"20211210_polar smooth fold","username":"0b5vr","description":"haha\n\nshoutouts to gaz\nRef: https://www.shadertoy.com/view/7sKGzR\n","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"flcXDH","parentname":"20211209_fold"},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// (c) 2021 0b5vr, CC4.0 BY-NC-SA\n// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n// https://creativecommons.org/licenses/by-nc-sa/4.0/\n\nfloat sdbox( vec3 p, vec3 s ) {\n    vec3 d = abs( p ) - s;\n    return min( 0.0, max( max( d.x, d.y ), d.z ) ) + length( max( d, 0.0 ) );\n}\n\n/**\n * gaz's 2D polarSmoothFold function.\n * Source: https://www.shadertoy.com/view/7sKGzR (CC3.0 BY-NC-SA)\n * @param p the input position\n * @param n fold frequency\n * @param k smoothness factor\n */\nvec2 polarSmoothFold( vec2 p, float n, float k ) {\n  n *= 0.5;\n  float a = asin( sin( atan( p.x, p.y ) * n ) / ( k + 1.0 ) ) / n;\n  return vec2( sin( a ), cos( a ) ) * length( p );\n}\n\nmat2 rotate2D( float t ) {\n    return mat2( cos( t ), -sin( t ), sin( t ), cos( t ) );\n}\n\nfloat map( vec3 p ) {\n    // random rotation\n    p.yz = rotate2D( 0.1 * iTime ) * p.yz;\n    p.zx = rotate2D( 0.2 * iTime ) * p.zx;\n    \n    // polar smooth fold here\n    p.zx = polarSmoothFold( p.zx, 6.0, 0.5 );\n\n    // offset to the valid region\n    p.x -= 2.0;\n\n    // random rotation\n    p.xy = rotate2D( 0.7 * iTime ) * p.xy;\n    p.zx = rotate2D( 0.4 * iTime ) * p.zx;\n    \n    // rounded box\n    return sdbox( p, vec3( 0.9, 0.4, 0.1 ) ) - 0.1;\n}\n\nvec3 nMap( vec3 p ) {\n    vec2 d = vec2( 0, 1E-3 );\n\n    return normalize( vec3(\n        map( p + d.yxx ) - map( p - d.yxx ),\n        map( p + d.xyx ) - map( p - d.xyx ),\n        map( p + d.xxy ) - map( p - d.xxy )\n    ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 p = uv * 2.0 - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3( 0, 0, 5 );\n    vec3 rd = normalize( vec3( p, -2 ) );\n\n    float rl = 0.0;\n    vec3 rp = ro + rd * rl;\n    float dist;\n\n    for ( int i = 0; i < 64; i ++ ) {\n        dist=map( rp );\n        rl += dist;\n        rp = ro + rd * rl;\n    }\n    \n    if ( dist < 1E-2 ) {\n        vec3 N = nMap( rp );\n\n        fragColor = vec4( 0.5 + 0.5 * N, 1 );\n    } else {\n        fragColor = vec4( 0, 0, 0, 1 );\n    }\n}\n","name":"Image","description":"","type":"image"}]}