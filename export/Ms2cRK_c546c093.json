{"ver":"0.1","info":{"id":"Ms2cRK","date":"1498057809","viewed":735,"name":"Hapke BRDF [WIP]","username":"TinyTexel","description":"left:   Lambert BRDF \nright: Hapke BRDF with isotropic phase function\n-> see line 610-675\nlight controls via W & S","likes":8,"published":1,"flags":48,"usePreview":0,"tags":["shading","brdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n\n/*\nleft:   Lambert BRDF \nright: Hapke BRDF with isotropic phase function\n-> see line 648-675\n\nlight controls via W & S\n\n\nHEAVILY WIP TEXT:\n\nIn the general case, the light reflection/re-emission behavior of the surface of an object \ncan be described by the BSSRDF. Often it is reasonable to assume that the light is reflected/re-emitted\nin close proximity to its incident position on the surface. In this case, the BSSRDF reduces to the BRDF. \nThis f.i. is the case when specular light reflection at the material interface is \nmodeled using microfacet theory. \nAnd/Or when sub-surface-scattering (SSS) of light is modeled using Lambert's Law.\n(A surface obeying Lambert's Law re-emits light isotropically and independently of the \nincident direction.) In the case of SSS, the assumption that the light is re-emitted at the incident\nsurface position requires the material to be dense enough to allow the local geometry\nand material properties of a small surface patch to be\napproximated using a flat, horizontally homogeneous, semi-infinite/finite slab of the material.\n\nThis approximation is commonly used in the context of studying the propagation of radiation \ninside optical media  (cloud/snow covers, bodies of water, (stellar) dust, etc.)\nusing radiative transfer theory (RTT). The reason for this is that this setup \nallows the application of approximate asymptotic solutions of the radiative transfer formula.\n\nSome of these solutions are compact enough to be used for computer graphics purposes.\n\nIn his 1960 work \"Radiative Transfer\", S. Chandrasekhar presented a solution for the reflectance\nof a flat, homogeneous, isotropically scattering, semi-infinite slab. The material properties\nare only parametrized by the single-scattering albedo of the particles the material of \nthe slab is composed of. The single-scattering albedo a_ss is the likelihood that\na photon is scattered instead of beeing absorbed on interaction with a particle:\n\na_ss = simga_s / simga_e = sigma_s / (sigma_s + sigma_a)\n\na_ss..    single-scattering albedo\nsigma_e.. extinction coefficient\nsigma_s.. scattering coefficient\nsigma_a.. absorption coefficient.\n\nIn terms of simplicity, the resulting BRDF is the closest we can get to the Lambert BRDF, while\ndescribing the reflection properties of a flat surface solely as the result of SSS.\nThe difference beeing that, instead of empirically modelling the\nreflectance resulting from SSS directly (as the Lambert BRDF does), \nwe now describe the scattering behavior of the individual particles constituting the material. \nThe reflectance behavior of the material's surface follows implicitly.\n\nUnfortunately, the reflectance formula as described by Chandrasekhar depends on a function H(mu),\nwhich itself has no closed from. However, Bruce Hapke derived a first-order approximation for H(mu)\nthat only depends on a_ss and becomes increasingly accurate for a_ss -> 0.\n\nThe rendering shown here compares the lighting result for a Lambert BRDF (left) and Chandrasekhar's model\nusing Hapke's first order approximation of H(mu) (Hapke BRDF, right).The black-white background\nwas chosen so as to make it easier to discern limb darkening/brightening.\n\nUnlike the Hapke BRDF, the Lambert BRDF is parametrized by the spherical albedo a_s (aka 'albedo')\ninstead of the single-scattering albedo a_ss. The spherical albedo of a surface is simply its BRDF\nintegrated over all light directions and oberservation directions (weighted by the appropriate \ncosine factors). Therefore, for the purpose of matching\nthe surface appearance resulting from the Lambert BRDF to that of the Hapke BRDF and vice versa, it is\n usefull to have a function that returns the a_s of the Hapke BRDF for a given a_ss. \nUnsurpringly, the integration of the Hapke BRDF over all incoming and\noutgoing direction does not appear to have a closed-form solution. However, I was able to find a\nsurprisingly good approximation to this function and its inverse. (Consider this to be my humble\nconstribution here (there might very well already exist such a function, but up to now I haven't \nstumbled over it).)\n\n...much more text...\n\noverview of hapke's works: \nhttps://www.mps.mpg.de/phd/theses/disk-resolved-photometry-of-small-bodies\n*/\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\n#define Frame float(iFrame)\n#define Time iTime\n//#define PixelCount iResolution.xy\n#define OUT\n\n/*\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define frac fract\n/**/\n\n#define Frame float(iFrame)\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nvec3 AngToVec(vec2 ang)\n{\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    return vec3(cosPhi * cosTheta, \n                         sinTheta, \n                sinPhi * cosTheta); \n}\n\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\n\nvec3 sRGB_EOTF(vec3 rgb)\n{\n    return If(greaterThan(rgb, vec3(0.0031308)), pow(rgb, vec3(1.0/2.4)) * 1.055 - 0.055, rgb * 12.92);\n}\n//=======================================================================//\n///////////////////////////////////////////////////////////////////////////\n\nstruct Cam\n{\n\tvec3 Front, Right, Up;\n\tfloat Aspect;\n\tfloat AxisLen;\t\n};\n\nCam NewCam(vec2 ang, float fov, float aspect)\n{\n    Cam cam;\n\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    cam.Front = vec3(cosPhi * cosTheta, \n                              sinTheta, \n                     sinPhi * cosTheta);\n\n    cam.Right = vec3(-sinPhi, 0.0, cosPhi);\n    cam.Up    = cross(cam.Right, cam.Front);\n\n    cam.Aspect = aspect;\n    cam.AxisLen = aspect * tan(Pi05 - fov * 0.5);\n\n    return cam;\n}\n\n// tc [-1..1]\nvec3 NewRay(Cam cam, vec2 tc)\n{\n    tc.x *= cam.Aspect;\n\n    vec3 imgPos = cam.Front * cam.AxisLen + (cam.Right * tc.x + cam.Up * tc.y);\n    \n    vec3 dir = normalize(imgPos);\n\n    return dir;\n}\n\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tcp\t\t: cube position\n\tcth\t\t: cube thickness (cth = 0.5 -> unit cube)\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\tt.x = max(uf.x, max(uf.y, uf.z));\n\tt.y = min(ub.x, min(ub.y, ub.z));\n\t\n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) {t.xy = t.yx;  return 1.0;}\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n/*\n[...]\n\nOUT:\n\tn0 : normal for t.x\n\tn1 : normal for t.y\n\nEXAMPLE:\t\n\tvec2 t; vec3 n0, n1;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t, n0, n1);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t, out vec3 n0, out vec3 n1)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n    vec3 os = If(lessThan(rd, vec3(0.0)), vec3(1.0), vec3(-1.0));\n    //vec3 os = sign(-rd);\n\tvec3 o = -cth * os;\n\t\n    \n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\t//t.x = max(uf.x, max(uf.y, uf.z));\n\t//t.y = min(ub.x, min(ub.y, ub.z));\n\t\n    if(uf.x > uf.y) {t.x = uf.x; n0 = vec3(os.x, 0.0, 0.0);} else \n                    {t.x = uf.y; n0 = vec3(0.0, os.y, 0.0);}\n    if(uf.z > t.x ) {t.x = uf.z; n0 = vec3(0.0, 0.0, os.z);}\n    \n    if(ub.x < ub.y) {t.y = ub.x; n1 = vec3(os.x, 0.0, 0.0);} else \n                    {t.y = ub.y; n1 = vec3(0.0, os.y, 0.0);}\n    if(ub.z < t.y ) {t.y = ub.z; n1 = vec3(0.0, 0.0, os.z);}\n    \n    \n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) \n    {\n        t.xy = t.yx;  \n        \n        vec3 n00 = n0;\n        n0 = n1;\n        n1 = n00;\n        \n        return 1.0;\n    }\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tsp2\t\t: sphere position\n\tsr2\t\t: sphere radius squared\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Sphere(pos, dir, vec3(0.0), 1.0, OUT t);\n*/\nfloat Intersect_Ray_Sphere(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\tif(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(D);\n\t// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;\n\tt = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;\n\t\n\t// if(start == inside) ...\n\tif(c < 0.0) t.xy = t.yx;\n\n\t// t.x > 0.0 || start == inside ? infront : behind\n\treturn t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////\n//=================================================================================================//\n\nconst float RcpPi  = 1.0 / (1.0 * Pi);\nconst float RcpPi2 = 1.0 / (2.0 * Pi);\nconst float RcpPi4 = 1.0 / (4.0 * Pi);\n\n\nfloat HapkeBRDF(float mu, float mu0, float a_ss)\n{\n    float s = sqrt(1.0 - a_ss);\n\n    //vec3 H  = (1.0 + 2.0 * mu ) / (1.0 + 2.0 * mu  * s);\n    //vec3 H0 = (1.0 + 2.0 * mu0) / (1.0 + 2.0 * mu0 * s);            \n\n    float HH0 = ((1.0 + 2.0 * mu    ) * (1.0 + 2.0 * mu0    )) / \n                ((1.0 + 2.0 * mu * s) * (1.0 + 2.0 * mu0 * s));           \n\n    float R = a_ss * HH0 / (mu + mu0) * RcpPi4;\n    \n    return R;\n}\n\nfloat HapkeBRDF(float mu, float mu0, float a_ss, float phFunc)\n{\n    float s = sqrt(1.0 - a_ss);            \n\n    float HH0 = ((1.0 + 2.0 * mu    ) * (1.0 + 2.0 * mu0    )) / \n                ((1.0 + 2.0 * mu * s) * (1.0 + 2.0 * mu0 * s));\n    \n    float R = a_ss * (HH0 - 1.0 + phFunc) / (mu + mu0) * RcpPi4;\n\n    return R;\n}\n\nvec3 HapkeBRDF(float mu, float mu0, vec3 a_ss)\n{\n    return vec3(HapkeBRDF(mu, mu0, a_ss.r),\n                HapkeBRDF(mu, mu0, a_ss.g),\n                HapkeBRDF(mu, mu0, a_ss.b));\n}\n\nvec3 HapkeBRDF(float mu, float mu0, vec3 a_ss, float phFunc)\n{\n    return vec3(HapkeBRDF(mu, mu0, a_ss.r, phFunc),\n                HapkeBRDF(mu, mu0, a_ss.g, phFunc),\n                HapkeBRDF(mu, mu0, a_ss.b, phFunc));\n}\n\nvec3 HapkeBRDF(float mu, float mu0, vec3 a_ss, vec3 phFunc)\n{\n    return vec3(HapkeBRDF(mu, mu0, a_ss.r, phFunc.r),\n                HapkeBRDF(mu, mu0, a_ss.g, phFunc.g),\n                HapkeBRDF(mu, mu0, a_ss.b, phFunc.b));\n}\n                          \n\nvec3 LommelSeeligerBRDF(float mu, float mu0, vec3 a_ss, float phFunc)\n{\n    vec3 R = a_ss * phFunc / (mu + mu0) * RcpPi4;\n    \n    return R;\n}\n\nvec3 LommelSeeligerBRDF(float mu, float mu0, vec3 a_ss, float phFunc, float tau, vec3 r)\n{\n   //float transm = exp(-tau * (1.0/mu + 1.0/mu0));\n   float transm = exp(-tau * (mu + mu0) / (mu * mu0));\n\n   vec3 layer = LommelSeeligerBRDF(mu, mu0, a_ss, phFunc);\n    \n   return mix(layer, r, transm);\n}\n\n// using exp(-x)=1-x for x->0\nvec3 LommelSeeligerBRDF2(float mu, float mu0, vec3 a_ss, float phFunc, float tau, vec3 r)\n{\n   //float transm = clamp01(1.0 - tau * (1.0/mu + 1.0/mu0));\n   float transm = clamp(1.0 - tau * (mu + mu0) / (mu * mu0), 0.0, 1.0);\n    \n   vec3 layer = LommelSeeligerBRDF(mu, mu0, a_ss, phFunc);\n    \n   return mix(layer, r, transm);\n}\n\n\nfloat HapkeNonAbsBRDF(float mu, float mu0, float phFunc)\n{\n    float R = (mu * mu0 * RcpPi + phFunc) / (mu + mu0) + RcpPi2;\n\n    return R;\n}\n\nfloat HapkeNonAbsBRDF(float mu, float mu0)\n{\n    float R = (mu * mu0 + 0.25) / (mu + mu0) * RcpPi + RcpPi2;\n\n    return R;// * 0.888;\n}\n\n\nfloat H(float mu)\n{\n    mu = max(0.0001, mu);\n    return 1.0 / (1.0 - mu * (1.0 + (0.5 - mu) * log(1.0 / mu + 1.0)));\n}\n\nfloat HapkeNonAbsBRDF2(float mu, float mu0)\n{\n    float R = H(mu) * H(mu0) / (mu + mu0) * RcpPi4;\n    \n    return R;// * 0.9605;\n}\n\nfloat HapkeNonAbsBRDF3(float mu, float mu0)\n{\n    float Hmu  = (0.291559 + (0.589061 - 0.0657408 * mu ) * mu );\n    float Hmu0 = (0.291559 + (0.589061 - 0.0657408 * mu0) * mu0);\n    \n    float R = (Hmu * Hmu0) / (mu + mu0);\n    \n    return R;\n}\n\nvec3 HapkeSimpleBRDF(float mu, float mu0, vec3 baseC, vec3 topC)\n{\n    float Hmu  = mu  * 2.0 + 1.0;\n    float Hmu0 = mu0 * 2.0 + 1.0;\n    \n    return ((Hmu * Hmu0 - 1.0) * baseC + topC) / (mu + mu0) * RcpPi4;\n}\n\nvec3 HapkeSimpleBRDF3(float mu, float mu0, vec3 baseC, vec3 topC)\n{\n    float Hmu  = (0.291559 + (0.589061 - 0.0657408 * mu ) * mu );\n    float Hmu0 = (0.291559 + (0.589061 - 0.0657408 * mu0) * mu0);\n    \n    return ((Hmu * Hmu0 - RcpPi4) * baseC + topC * RcpPi4) / (mu + mu0);\n}\n\n// pow-like + inverse build by rescaling [exp(x * s) + exp(-x * s) - 2]  \nfloat PowL_Exp(float x, float s)\n{\n    return exp(s - s * x) * Pow2(exp(s * x) - 1.0) / Pow2(exp(s) - 1.0);\n}\n\nfloat PowL_ExpInv(float x, float s)\n{\n    float expS = exp(s);\n    float exp2S = expS * expS;\n    \n    float t0 = 2.0 * expS + x - 2.0 * expS * x + exp2S * x;\n    \n    float t1 = sqrt((-2.0 * expS * (x - 2.0) + x + exp2S * x) * x) * (expS - 1.0);\n    \n    return log((t0 + t1) * exp(-s) * 0.5) / s;\n}\n\n////////////////////////////////////////\n//------------------------------------//\n// single scattering albedo <-> (spherical) albedo mappings (by me)\n// assumes first order approx of H and iso scattering\n// primarily utility functions; not at all essential\n\nconst float HapkeMaxAlbedo = (11.0 + 28.0 * log(2.0)) / 30.0;// 1.0136 (> 1 due to error in H approx)\n\n// SSAlbedo_to_Albedo has no closed form (plane albedo has but the spherical one apparently doesnt)\n// this approx has mean-absolute-error of 0.000971859 (which is mostly likely good enough for graphics)\nfloat SSAlbedo_to_Albedo(float a_ss)\n{\n    return (1.0 - PowL_ExpInv(1.0 - a_ss, 4.776)) * HapkeMaxAlbedo;\n}\n\nfloat Albedo_to_SSAlbedo(float a)\n{\n    return 1.0 - PowL_Exp(a * (-1.0 / HapkeMaxAlbedo) + 1.0, 4.776);\n}\n\n    \nvec3 SSAlbedo_to_Albedo(vec3 a_ss)\n{\n    return vec3(SSAlbedo_to_Albedo(a_ss.r),\n                SSAlbedo_to_Albedo(a_ss.g),\n                SSAlbedo_to_Albedo(a_ss.b));\n}\n\nvec3 Albedo_to_SSAlbedo(vec3 a)\n{\n    return vec3(Albedo_to_SSAlbedo(a.r),\n                Albedo_to_SSAlbedo(a.g),\n                Albedo_to_SSAlbedo(a.b));\n}\n//------------------------------------//\n////////////////////////////////////////\n\n\nfloat ShadowHiding(float cosTheta, float h, float B0)\n{\n    float tan05 = (1.0 + cosTheta) * rsqrt(1.0 - cosTheta*cosTheta);\n    \n    float B = B0 / (1.0 + tan05 / h);\n    \n    return B + 1.0;\n}\n\n\nfloat HenyeyGreensteinPhF(float cosTheta, float g)\n{\n\tfloat sqrG = g * g;\n\t\n\tfloat t0 = 1.0 - sqrG;\n\tfloat t1 = 1.0 + sqrG - 2.0 * g * cosTheta;\n\t\n\t// return t0 * rsqrt(max(0.0, t1*t1*t1));// nan if ct&&g==-1 or ct&&g==1\n\treturn t0 * rsqrt(max(1.0e-37, t1*t1*t1));\n}\n\nfloat SchlickPhF(float cosTheta, float k)\n{\t\n\tfloat t0 = 1.0 - k * k;\n\tfloat t1 = 1.0 - k * cosTheta;\n\t\n\t//return t0 / (t1 * t1);// nan if ct&&g==-1 or ct&&g==1\n\treturn t0 / max(1.0e-37, t1 * t1);    \n}\n\nfloat LambertPhF(float cosTheta)\n{\n    return 0.83564 + (1.32872 + 0.49308 * cosTheta) * cosTheta;\n}\n\nfloat LunarPhF(float cosTheta)\n{\n    return 0.813235 + (0.588656 + 0.560296 * cosTheta) * cosTheta;\n}\n\n\nfloat HenyeyGreensteinPDF(float cosTheta, float g)\n{\n    return HenyeyGreensteinPhF(cosTheta, g) * RcpPi4;\n}\n\nfloat SchlickPDF(float cosTheta, float k)\n{\n    return SchlickPhF(cosTheta, k) * RcpPi4;\n}\n\n\n// minimizes RMS error between HG and Schlick\nfloat GtoSchlickK(float g)\n{\t\n    const float a = -0.1322072338291953;\n    const float b = -0.7355855323416429;\n    const float c = 0.5 + a;\n \n    float k = g * (1.5 + g*g * (a + (b + c * abs(g)) * abs(g)));\n\n    return k;\n}\n//=================================================================================================//\n/////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n\n// http://www1.cs.columbia.edu/CAVE/publications/pdfs/Oren_SIGGRAPH94.pdf\nfloat OrenNayarBRDF(vec3 N, vec3 L, vec3 V, float NdL, float NdV, float sigma)\n{\n    float sqrSig = sigma * sigma;\n    \n\t//float A = sqrSig / (sqrSig + 0.33) * -0.5 + 1.0;\n\t//float B = sqrSig / (sqrSig + 0.09) *  0.45;\n\t\n    float A = sqrSig / (sqrSig + 0.33) * (-0.5  * RcpPi) + RcpPi;\n\tfloat B = sqrSig / (sqrSig + 0.09) * ( 0.45 * RcpPi);\n    \n\t// float theta_i = acos(NdV);\n\t// float theta_r = acos(NdL);\n\t\n\t// float alpha = max(theta_i, theta_r);\n\t// float beta  = min(theta_i, theta_r);\n\t\n\t// float term0 = sin(alpha) * tan(beta);\n\t// float term0 = (sin(alpha) * sin(beta)) / cos(beta);\n\t// float term0 = (sqrt(1.0 - NdV*NdV) * sqrt(1.0 - NdL*NdL)) / max(NdL, NdV);\n\tfloat term0 = sqrt((1.0 - NdV*NdV) * (1.0 - NdL*NdL)) / max(NdL, NdV);\n\t\n\tvec3 V_proj = normalize(V - N * NdV);\n\tvec3 L_proj = normalize(L - N * NdL);\n\t\n\tfloat term1 = clamp(dot(V_proj, L_proj), 0.0, 1.0);\n\t\n\treturn term1 * term0 * B + A;\n}\n\nfloat FresnelSchlick(float ct, float f0, float f90)\n{\n\tfloat x = 1.0 - ct;\n    float w = (x*x) * (x*x) * x;\n\n    return mix(f0, f90, w);\n}\n\nvec3 FresnelSchlick(float ct, vec3 f0, vec3 f90)\n{\n    float x = 1.0 - ct;\n    float w = (x*x) * (x*x) * x;\n\n    return mix(f0, f90, w);\n}\n\n/* https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf */\nfloat Fr_DisneyDiffuse(float NdotV, float NdotL, float LdotH, float linearRoughness)\n{\n\tfloat energyBias   = mix(0.0,     0.5 , linearRoughness);\n\tfloat energyFactor = mix(1.0, 1.0/1.51, linearRoughness);\n    \n\tfloat fd90 = energyBias + 2.0 * (LdotH*LdotH) * linearRoughness;\n    \n\tconst float f0 = 1.0;\n    \n\tfloat lightScatter = FresnelSchlick(NdotL, f0, fd90);\n\tfloat viewScatter  = FresnelSchlick(NdotV, f0, fd90);\n\t\n\treturn lightScatter * viewScatter * energyFactor;\n}\n\nvec3 Fr_DisneyDiffuse(float NdotV, float NdotL, float LdotH, float linearRoughness, vec3 a)\n{\n\tfloat energyBias   = mix(0.0,     0.5 , linearRoughness);\n\tfloat energyFactor = mix(1.0, 1.0/1.51, linearRoughness);\n    \n\tfloat fd900 = energyBias + 2.0 * (LdotH*LdotH) * linearRoughness;\n    vec3 aa = 1.0-(1.0-a)*(1.0-a);\n    aa = mix(a, vec3(1.0), 0.5);\n    //aa = Albedo_to_SSAlbedo(a);\n    //aa = vec3(1.0);\n    aa = mix(vec3(1.0), (1.0-a)*2.0, 0.25);\n    //aa = mix(vec3(1.0), (a)*1.5, 0.25);\n    //aa = sqrt(a);\n    //aa = a;\n    vec3 fd90 = fd900 * aa;\n\tconst float f0 = 1.0;\n    \n\tvec3 lightScatter = FresnelSchlick(NdotL, vec3(f0), fd90);\n\tvec3 viewScatter  = FresnelSchlick(NdotV, vec3(f0), fd90);\n\t\n\treturn lightScatter * viewScatter * energyFactor*1.35;\n}\n\n\nvec3 EvalSceneCol(\n    vec3 rp, Cam cam, vec2 uv0, vec3 light, bool right)\n{\n    vec3 col = vec3(0.0);\n    vec2 PixelCount = iResolution.xy * vec2(0.5, 1.0);\n    \n    vec2 tex = uv0.xy / PixelCount;\n    vec2 tex21 = tex * 2.0 - vec2(1.0);\n    \n    vec3 rd = NewRay(cam, tex21);\n    \n    float t; vec3 n; vec3 a;\n    float hit = 0.0;\n\n    {\n        vec2 tt;\n\t\tfloat th = Intersect_Ray_Sphere(rp, rd, vec3(0.0), 1.0, OUT tt);\n        \n        if(th > 0.0)\n        if(hit <= 0.0 || tt.x < t)\n        {\n            t = tt.x;\n            n = normalize(rp + rd * tt.x);\n            a = vec3(1.0);\n            \n            hit = 1.0;\n        }\n    }\n    \n \n    if(hit > 0.0)\n    {\n        vec3 p = rp + rd * t;\n     \n        //vec3 amb = vec3(0.05, 0.2, 1.0) * 0.1;\n        //if(right) amb = vec3(0.0);\n        \n        \n        float mu  = clamp01(dot(-rd  , n));  \n        float mu0 = clamp01(dot(light, n));\n              \n        \n        vec3 a_ss;// = vec3(0.1, 0.93, 0.95);// single scattering albedo\n        vec3 a = vec3(0.95, 0.15, 0.05);// (spherical) albedo\n        //a = vec3(0.4, 0.9, 0.04);\n        \n        a_ss = Albedo_to_SSAlbedo(a);\n        //a = SSAlbedo_to_Albedo(a_ss);\n        \n        \n        if(right)\n        {\n            float ct = dot(light, rd);\n            ct = max(-0.9999, ct);\n            \n           #if 1\n            \n            col = HapkeBRDF(mu, mu0, a_ss) * mu0;// simple version with isotropic phase function\n            \n           #elif 1\n            \n            col = HapkeBRDF(mu, mu0, vec3(0.99909)) * mu0;\n            col = HapkeBRDF(mu, mu0, vec3(1.0)) * mu0;\n        \t//col = HapkeBRDF(mu, mu0, vec3(0.99) * 0.99909, HenyeyGreensteinPhF(ct, -0.2)) * mu0;\n            //col = HapkeBRDF(mu, mu0, vec3(1.0, 0.5, 0.2) * 0.99909) * mu0;\n        \tcol = vec3(HapkeNonAbsBRDF3(mu, mu0) * mu0);          \n        \t//col = vec3(HapkeNonAbsBRDF3(mu, mu0) * mu0);\n            col = HapkeSimpleBRDF(mu, mu0, a, LunarPhF(-ct) * mix(a, vec3(1.0), 0.9)) * mu0;\n            vec3 a2 = 1.0-(1.0-a)*(1.0-a)*(1.0-a)*(1.0-a);\n            //a2 = sqrt(a2);\n            col = HapkeSimpleBRDF(mu, mu0, mix(a, a*a, 0.66667), a2) * mu0;\n            \n            a = vec3(0.3, 0.9, 0.0) * 0.5;\n            vec3 a3 = mix(a, vec3(1.0, 1.0, 0.0)*3.0, pow(ct*0.5+0.5, 4.0));\n            //a3 = vec3(1.0, 1.0, 0.0);\n            //col = HapkeSimpleBRDF(mu, mu0, a, a3) * mu0;\n            \n            //col = HapkeSimpleBRDF(mu, mu0, mix(a,a*a,0.6), mix(1.0, 3.0 * ct*ct, 0.09993333) * mix(a2, vec3(1.0), 0.0099)) * mu0;\n            //col = mix(vec3(0.0), vec3(1.0), greaterThan(col, vec3(1.0/Pi)));\n            //col = abs(col)*10.0;\n            //col = vec3(mu0 * RcpPi);\n           #else\n            \n            float sh = ShadowHiding(ct, 0.995, 1.0);\n            float phF = HenyeyGreensteinPhF(ct, 0.449) * sh;\n            phF = SchlickPhF(ct, GtoSchlickK(0.449)) * sh;\n            col = HapkeBRDF(mu, mu0, vec3(1.0) * 0.995, phF) * mu0;// fit for snow BRDF (TODO: provide source)\n            \n           #endif\n        }\n        else// left\n        {\n           #if 1\n            \n            col = vec3(mu0 * RcpPi);// + amb;\n        \t//col = vec3(OrenNayarBRDF(n, light, -rd, mu0, mu, 0.5)) * mu0;\n            //col *= ;\n            col *= a;\n           \n           #else\n            \n            vec3 N = n;\n            vec3 V = -rd;\n            vec3 L = light;\n            \n            vec3 H = normalize(L + V);\n            float NoV = clamp01(dot(N, V));\n            float NoL = clamp01(dot(N, L));\n            float HoL = clamp01(dot(H, L));\n            \n            float linearRoughness = 1.0;\n            //col = a * Fr_DisneyDiffuse(NoV, NoL, HoL, linearRoughness, a) * NoL * RcpPi;\n            col = a * Fr_DisneyDiffuse(NoV, NoL, HoL, linearRoughness) * NoL * RcpPi;\n            //col = a * NoL * RcpPi;\n            \n            vec3 a_ss = 1.0-(1.0-a)*(1.0-a);\n            //a_ss = a*a;\n            //a = 1.0-(1.0-a)*(1.0-a);\n            //a_ss = sqrt(a);\n            \n            //col = mix(a * RcpPi, LommelSeeligerBRDF(NoV, NoL, a_ss, 1.0)*2.0, 0.5) * NoL;\n            //col = LommelSeeligerBRDF(NoV, NoL, a_ss, 1.0, 0.05, a*RcpPi*0.5)*2.0 * NoL;\n            //vec3 LommelSeeligerBRDF(float mu, float mu0, vec3 a_ss, float phFunc)\n\t\t\t//vec3 LommelSeeligerBRDF(float mu, float mu0, vec3 a_ss, float phFunc, float tau, vec3 r)\n           \n           #endif\n        }\n        //col = cf.zzz;\n        \n        col *= vec3(Pi);\n    }\n    else\n    {\n        //col = texture(iChannel1, rd).bbb * vec3(0.1);\n    \tcol = vec3(uv0.x < iResolution.x * 0.25 ? 0.0 : 1.0);\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    vec3 col = vec3(0.0);\n    \n    vec2 uv = uv0.xy - 0.5;\n    \n    vec2 PixelCount = iResolution.xy * vec2(0.5, 1.0);\n    \n    bool right = uv.x > PixelCount.x;\n    if(right) uv.x -= PixelCount.x;\n    \n    \n    vec4 mouseAccu = texelFetch(iChannel0, ivec2(1, 0), 0); \n    vec4 wasdAccu  = texelFetch(iChannel0, ivec2(2, 0), 0); \n\n    vec2 lightAng = vec2(Pi * 0.0, Pi * 0.5);\n    lightAng.x += (wasdAccu.y - wasdAccu.w) * 0.06; \n    lightAng.y += (wasdAccu.x - wasdAccu.z) * 0.04;    \n    \n    vec3 light = AngToVec(lightAng);\n    \n    vec2 ang = vec2(0.0, 0.0);\n    ang += mouseAccu.xy * 0.008;\n\n    Cam cam = NewCam(ang, Pi * 0.5, PixelCount.x / PixelCount.y);\n    vec3 cpos = -cam.Front * 2.0;\n    cpos = -cam.Front * (exp2(0.7 + mouseAccu.w * 0.02));\n    \n\n    const vec2 AA_Smpls3[3] = vec2[]\n    (\n        vec2(3.0, 1.0) / 6.0,\n        vec2(5.0, 3.0) / 6.0,\n        vec2(1.0, 5.0) / 6.0     \n    );\n    \n    bvec2 tl = greaterThan(fract(uv * 0.5), vec2(0.5));    \n    vec2 flip = vec2(tl.y ? 1.0 : 0.0, tl.x ? 0.0 : 1.0);\n    \n    for(uint i = 0u; i < 3u; ++i) \n        col += EvalSceneCol(cpos, cam,  uv + abs(flip - AA_Smpls3[i]), light, right);\n    \n    col /= 3.0;   \n    \n\n    \n    //if(col.x > 1.0) col = vec3(1.0, 0.0, 1.0);\n    //if(col.x >\n    \n\t//outCol = vec4(sRGB_EOTF(clamp01(vec3(uv0.x/iResolution.x))), 1.0);return;\n\toutCol = vec4(sRGB_EOTF(clamp01(col)), 1.0);\n    \n    vec2 tex = uv0 / iResolution.yy;\n    //outCol = vec4(Albedo_to_SSAlbedo(tex.x) > tex.y ? 1.0 : 0.0);\n    // nan and range tests\n    float g  = clamp((uv0.x/iResolution.x*2.0-1.0)*1.1,-1.0,1.0);\n    float ct = clamp((uv0.y/iResolution.y*2.0-1.0)*1.1,-1.0,1.0);\n    //outCol = vec4(HenyeyGreensteinPhF(ct, g) + 1.0);\n    //outCol = vec4(SchlickPhF(ct, g) + 1.0);\n    //outCol = vec4(GtoSchlickK(g) == 1.0 ? 1.0 : 0.0);\n    \n    //outCol = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Hapke BRDF [WIP]\n// Created by TinyTexel\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n\nvoid mainImage( out vec4 col, in vec2 uv0 )\n{  \n    col = vec4(0.0);\n    \n    vec2 uv = uv0 - 0.5;\n    \n    \n    vec4 iMouseLast     = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec4 iMouseAccuLast = texelFetch(iChannel0, ivec2(1, 0), 0);\n    vec4 wasdAccuLast   = texelFetch(iChannel0, ivec2(2, 0), 0);\n\n    bool shift = texelFetch(iChannel1, ivec2(16, 0), 0).x != 0.0;\n    \n    float kW = texelFetch(iChannel1, ivec2(0x57, 0), 0).x;\n    float kA = texelFetch(iChannel1, ivec2(0x41, 0), 0).x;\n    float kS = texelFetch(iChannel1, ivec2(0x53, 0), 0).x;\n    float kD = texelFetch(iChannel1, ivec2(0x44, 0), 0).x;\n    \n    vec4 wasdAccu = wasdAccuLast + vec4(kW, kA, kS, kD);\n    \n    vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n    \n    bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n    vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n    vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n    \n    vec2 iMouseAccu1 = iMouseAccuLast.xy + mouseDelta2;\n    vec2 iMouseAccu2 = iMouseAccuLast.zw + mouseDelta3;\n    \n    if(uv.x == 0.0 && uv.y == 0.0) col = iMouse;  \n    if(uv.x == 1.0 && uv.y == 0.0) col = vec4(iMouseAccu1, iMouseAccu2);\n    if(uv.x == 2.0 && uv.y == 0.0) col = wasdAccu;\n}","name":"Buffer D","description":"","type":"buffer"}]}