{"ver":"0.1","info":{"id":"fsKGWR","date":"1631342277","viewed":76,"name":"lava lamp thing with perlin nois","username":"HaleyHalcyon","description":"a","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["perlinnoise"],"hasliked":0,"parentid":"fsKGRD","parentname":"blotchy spirals"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU (6.283185307)\n#define HEX(x) (vec3((x >> 16) & 255, (x >> 8) & 255, x & 255) / 255.)\n\n// like smoothstep but linear and keeps the value between and 0 1\nfloat map(float vmin, float vmax, float v) {\n    return clamp(\n        (v-vmin)/(vmax-vmin), // reverse lerp\n        0., 1. // clamp\n    );\n}\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash(uint x) {\n    x &= 65535u;\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x & 65535u;\n}\n// fade function defined by ken perlin\nvec2 fade(vec2 t) {\n  return t * t * t * (t * (t * 6. - 15.) + 10.);\n}\n// corner vector\nvec2 cvec(vec2 uv, float time) {\n  uint x = uint(mod(uv.x, 256.));\n  uint y = uint(mod(uv.y, 256.));\n  float n = (float(hash(x + hash(y))) / 65535. + time) * TAU;\n  return vec2(\n      sin(n), cos(n)\n  );\n}\n// perlin generator\n// coordinates can loop in\n// integer number of cells\nfloat perlin(vec2 uv, float offset, vec2 loop) {\n  if (loop.x > 0.) {uv.x = mod(uv.x, loop.x);}\n  if (loop.y > 0.) {uv.y = mod(uv.y, loop.y);}\n  vec2 i = floor(uv);\n  vec2 n = floor(uv + 1.); //next\n  if (loop.x > 0.) {n.x = mod(uv.x + 1., loop.x);}\n  if (loop.y > 0.) {n.y = mod(uv.y + 1., loop.y);}\n  vec2 f = fract(uv);\n\n  vec2 u = fade(f);\n  offset = fract(offset);\n\n  return\n  mix(\n    mix(\n      dot( cvec(i, offset ), f - vec2(0.0,0.0) ),\n      dot( cvec(vec2(n.x, i.y), offset ), f - vec2(1.0,0.0) ),\n    u.x),\n    mix(\n      dot( cvec(vec2(i.x, n.y), offset ), f - vec2(0.0,1.0) ),\n      dot( cvec(n, offset ), f - vec2(1.0,1.0) ),\n    u.x),\n  u.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float time = fract(iTime / 10.0);\n  // Normalized pixel coordinates (from 0 to 1)\n  float scale = min(iResolution.x, iResolution.y);\n  vec2 uv = (gl_FragCoord.xy - 0.50 * iResolution.xy) / scale;\n  float dist = log(uv.x * uv.x + uv.y * uv.y);\n  float angle = atan(uv.y, uv.x) / TAU;\n\n  float noise = perlin(\n      uv * 5. - vec2(0., 10.) * time,\n      time,\n      vec2(0., 10.)\n  );\n  noise += 0.3  * perlin(\n      uv * 15.3 - vec2(0., 20.) * time,\n      -2. * time,\n      vec2(0., 20.)\n  );\n  noise += 0.03  * perlin(\n      uv * 54.6 - vec2(0., 20.) * time,\n      -2. * time,\n      vec2(0., 20.)\n  );\n  //noise *= max(0.0, dist * 0.2 + 2.);\n  float bright = noise * 0.5 - uv.y * 0.6;\n  float bright0 = map(\n      -0.2, 0.0, bright\n  );\n  float bright1 = map(\n      0.0, 0.2, bright\n  );\n  vec3 col = mix(\n      HEX(0x602000), mix(\n          HEX(0xFF9F36),\n          HEX(0xFFFF80),\n          bright1\n      ), bright0\n  );\n  // Output to screen\n  fragColor = vec4(\n    col, 1.0\n  );\n}","name":"Image","description":"","type":"image"}]}