{"ver":"0.1","info":{"id":"Nstfzj","date":"1656803838","viewed":66,"name":"WEREM:Softshadows reflections","username":"weremsoft","description":"just a practice ttrying to get some ambient reflection.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarchingcubemapreflections"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MAX_STEPS 100\n#define MAX_DIST 70.\n#define SURF_DIST .1\n#define TAU 6.283185\n#define PI 3.141592\n\nstruct Camera\n{\n    vec3 position;\n    vec3 direction;\n    vec3 lookAt;\n};\n\nstruct CollisionInfo\n{\n    float distance;\n    vec4 color;\n    vec3 normal;\n};\n\nstruct Shape\n{\n    vec3 position;\n    vec4 color;\n    vec3 rotation;\n};\n\nstruct Torus\n{\n    Shape parent;\n    vec2 radiouses;\n};\n\nstruct Box\n{\n    Shape parent;\n    vec3 size;\n};\n\nstruct Sphere\n{\n    Shape parent;\n    float radius;\n};\n\nmat2 getRotationMatrix(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat smoothMin(float a, float b, float ammount)\n{\n    float h = clamp(.5 + .5 * (b - a) / ammount, 0., 1.);\n    return mix(b, a, h) - ammount * h * (1. - h);\n}\n\nCollisionInfo getSphereDistance(Sphere sphere, vec3 point)\n{\n    CollisionInfo returnValue;\n    returnValue.color = sphere.parent.color;\n    returnValue.distance = length(point - sphere.parent.position) - sphere.radius;\n    return returnValue;\n}\n\nCollisionInfo getTorusDistance(Torus torus, vec3 point)\n{\n    CollisionInfo returnValue;\n    returnValue.color = torus.parent.color;\n    vec3 position = point - torus.parent.position;\n    float x = length(position.xz) - torus.radiouses.x;\n    returnValue.distance = length(vec2(x, position.y)) - torus.radiouses.y;\n    return returnValue;\n}\n\nCollisionInfo getBoxDistance(Box box, vec3 point)\n{\n    CollisionInfo returnValue;\n    returnValue.color = box.parent.color;\n    mat2 rotationMatrix = getRotationMatrix(iTime);\n    vec3 position = point - box.parent.position;\n    position.xz *= rotationMatrix;\n\n    returnValue.distance = length(max(abs(position) - box.size, 0.));\n    return returnValue;\n}\n\nCollisionInfo getDistance(vec3 point)\n{\n    CollisionInfo returnValue;\n    returnValue.color = vec4(1.);\n\n    Sphere sphere;\n    sphere.parent.position = vec3(0, 1., 6.);\n    sphere.radius = 1.;\n    sphere.parent.color = vec4(1., 1., 0, 1.);\n\n    Torus torus;\n    torus.radiouses = vec2(2., .3);\n    torus.parent.position = vec3(-1., .5, 6.);\n    torus.parent.color = vec4(1., 0, 0, 1.);\n\n    Box box;\n    box.size = vec3(.5);\n    box.parent.position = vec3(-5., .5, 6.);\n    box.parent.color = vec4(1., 0, 1., 1.);\n\n    sphere.parent.position.x = sin(iTime + PI) * 3.;\n    sphere.parent.position.z = cos(iTime + PI) * 3. + 6.;\n    sphere.parent.color = vec4(1., .5, .5, 1.);\n    CollisionInfo distanceToSphere = getSphereDistance(sphere, point);\n\n    sphere.parent.position.x = sin(iTime) * 3.;\n    sphere.parent.position.z = cos(iTime) * 3. + 6.;\n    sphere.parent.color = vec4(0, 1, 0, 1.);\n    CollisionInfo distanceToSphere2 = getSphereDistance(sphere, point);\n\n    torus.radiouses.x = abs(sin(iTime * .2)) + 0.5;\n    torus.radiouses.y = abs(sin(iTime * 0.5)) + 0.1;\n    torus.parent.position.y = abs(sin(iTime * 0.7)) + 0.5;\n    CollisionInfo distanceToTorus = getTorusDistance(torus, point);\n    float distanceToPlane = point.y;\n\n    CollisionInfo distanceToBox = getBoxDistance(box, point);\n\n    returnValue = distanceToSphere2;\n\n    if (distanceToSphere.distance < distanceToSphere2.distance)\n    {\n        returnValue = distanceToSphere;\n    }\n\n    if (distanceToTorus.distance < returnValue.distance)\n    {\n        returnValue = distanceToTorus;\n    }\n\n    if (distanceToBox.distance < returnValue.distance)\n    {\n        returnValue = distanceToBox;\n    }\n\n    if (distanceToPlane < returnValue.distance)\n    {\n        returnValue.distance = distanceToPlane;\n        returnValue.color = vec4(1.);\n    }\n\n    return returnValue;\n}\n\nvec3 getNormal(vec3 point)\n{\n    vec2 e = vec2(.01, 0);\n    CollisionInfo distanceToPoint = getDistance(point);\n    vec3 n = vec3(\n        distanceToPoint.distance - getDistance(point - e.xyy).distance,\n        distanceToPoint.distance - getDistance(point - e.yxy).distance,\n        distanceToPoint.distance - getDistance(point - e.yyx).distance);\n\n    return normalize(n);\n}\n\nCollisionInfo rayMarch(vec3 rayOrigin, vec3 rayDirection, float maxDist)\n{\n    CollisionInfo distanceToOrigin;\n\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 point = rayOrigin + rayDirection * distanceToOrigin.distance;\n        CollisionInfo distanceToScene = getDistance(point);\n\n        distanceToOrigin.distance += distanceToScene.distance;\n        distanceToOrigin.color = distanceToScene.color;\n        if (distanceToOrigin.distance > maxDist || distanceToScene.distance < SURF_DIST)\n            break;\n    }\n\n    return distanceToOrigin;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        CollisionInfo ci = getDistance(ro + rd*t);\n        float h = ci.distance;\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\nfloat getLight(vec3 point)\n{\n#define LIGHT_PATH_RADIOUS 2.\n    vec3 lightPosition = vec3(3, 12., 6);\n    vec3 lightPosNormalized = normalize(lightPosition - point);\n    vec3 n = getNormal(point);\n    float diffuse = clamp(dot(n, lightPosNormalized), 0., 1.);\n\n    CollisionInfo d = rayMarch(point + n * SURF_DIST * 5., lightPosNormalized, length(lightPosition - point));\n\n    float penumbra = softshadow(point, lightPosNormalized, .1, 10., 2.);\n\n    return diffuse * penumbra;\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z)\n{\n    vec3 f = normalize(l - p),\n         r = normalize(cross(vec3(0, 1, 0), f)),\n         u = cross(f, r),\n         c = f * z,\n         i = c + uv.x * r + uv.y * u,\n         d = normalize(i);\n    return d;\n}\n\nCamera getCamera(vec2 mousePosition, vec2 screenPosition)\n{\n    Camera camera;\n    camera.position = vec3(0, 5., -20);\n    camera.lookAt = vec3(0, 5., 6);\n\n    camera.position.yz *= getRotationMatrix(-mousePosition.y * PI + 1.);\n    camera.position.xz *= getRotationMatrix(-mousePosition.x * TAU);\n    camera.direction = GetRayDir(screenPosition, camera.position, camera.lookAt, 1.);\n    return camera;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    vec3 light = vec3(0, 5., 5);\n\n    Camera camera = getCamera(m, uv);\n\n    CollisionInfo colInfo = rayMarch(camera.position, camera.direction, MAX_DIST);\n\n    vec4 col = vec4(0);\n\n    vec3 rd = normalize(vec3(uv, 1.));\n    rd.xz *= -getRotationMatrix(iTime);\n\n    vec3 p = camera.position + camera.direction * colInfo.distance;\n    vec3 r = reflect(camera.direction, getNormal(p));\n    vec4 refl = texture(iChannel0, r);\n\n    \n\n    vec3 collisionPoint = camera.position + camera.direction * colInfo.distance;\n\n    if (colInfo.distance < MAX_DIST)\n    {\n        vec4 cubeMapColor = texture(iChannel0, r);\n\n        col = vec4(vec3(getLight(collisionPoint)), 1.);\n        \n        col = mix(mix(colInfo.color, col, 0.5), cubeMapColor, .5);\n    } else {\n        vec4 cubeMapColor = texture(iChannel0, camera.direction);\n    \n        col = cubeMapColor;\n    \n    }\n\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}