{"ver":"0.1","info":{"id":"cd3GDs","date":"1681705601","viewed":68,"name":"Weird sphere halo","username":"jKubitschek","description":"generated from a simple sphere + floor raymarch and murdering the accuracy\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","beginner"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//void mainImage( out vec4 fragColor, in vec2 fragCoord )\n// {\n    // Normalized pixel coordinates (from 0 to 1)\n    // vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n//    fragColor = vec4(col,1.0);\n//}\n\n// Adapted from Peter Shirley's Raytracing in one Weekend Book\n// Will be a fairly naive implementation, but I hope that I can find a way to optimize this quite a bit more and hopefully do\n// something more interesting with it\n// I'm gonna use raymarching\n\n\n\n// sdf of p and circle with center c and rad r\n\n\nfloat hash(float s) {\n    return fract(sin(s*153.1725 + 739.6921) + 66.672);\n}\n\n\nfloat hash(vec2 v) {\n    return hash(hash(v.x) + 218.7137*hash(v.y));\n}\n\n\n\n\nfloat sdSp(vec3 p, vec3 c, float r) {\n    return length(p - c) - r; // 0.1*sin(iTime + (p.x - 0.7*sin(0.5*iTime))*(p.z + 1.0/iTime)*(p.y - 3.0) * 5.0);\n}\n\nfloat map(vec3 p) {\n    return min(sdSp(p, vec3(0.0, 0.0, -1.0), 0.5),\n               p.y + 2.0);\n    //return sdSp(p, vec3(0.0, 0.0, -1.0), 0.5);\n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n                          map(p + e.yxy) - map(p - e.yxy),\n                          map(p + e.yyx) - map(p - e.yyx)));\n}\n\n\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0)/k;\n    return min(a, b) - h*h*k*(1.0/4.0);\n}\n\n\nfloat smvoronoi(vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    \n    float res = 10.0; // some large number;\n    for (int j = -1; j <= 1; ++j) // Checks dist to cell pt is in, and all 8 neighbors (p + cell generates all of them)\n    for (int i = -1; i <= 1; ++i) {\n        vec2 cell = vec2(i, j);\n\n        vec2 pt = vec2(hash(p + cell));\n        pt = 0.5 + 0.5*sin(pt*321.2803 + iTime/4.0);\n        vec2 r = cell - f + pt;\n        float dist = length(r);\n        res = smin(res, dist, 0.1);\n        // res += exp2(-32.0*dist);\n    }\n    return 1.0 - sqrt(res);\n    // Interesting idea - arrived via experimentation, basically taking sqrt of dist to voronoi point\n    //return -(1.0/32.0)*log2(res);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 p = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    \n    // vec2 rvec = vec2(rand(fragCoord.y/iResolution.x), rand(fragCoord.x/iResolution.x))/iResolution.xy;\n    \n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 look = normalize(vec3(p, -1.0));\n    \n    vec3 col = (1.0 - (p.y + 1.0)/2.0)*vec3(1.0, 1.0, 1.0) + (p.y + 1.0)/2.0*vec3(0.5, 0.7, 1.0);\n    \n    float t = 0.0;\n    for (int i = 0; i < 1000; ++i) {\n    \n        if (t > 1.0) {\n            break;\n        }\n        \n        vec3 pos = ro + t*look;\n        \n        float h = map(pos);\n        \n        if (h < 0.001) {\n            break;\n        }\n        \n        t += h;\n    }\n    \n    if (t < 20.0) {\n        col = normal(ro + t*look);\n    } else {\n        //float smvor = smvoronoi(p);\n        //col = smvor*vec3(0.55, 0.49, 0.71);\n        //col = vec3(0.23, 0.22, 0.35)*(1.0 - smvor) + smvor*col; \n    }\n    \n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}