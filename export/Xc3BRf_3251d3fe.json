{"ver":"0.1","info":{"id":"Xc3BRf","date":"1733318337","viewed":27,"name":"Gabrielle's Horn","username":"hazelwu","description":"Torricelli's Trumpet: z = 1 / sqrt(x*x + y*y)\nwith loads of aliasing and catastrophic cancellation","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"4fKyR3","parentname":"embedded polyhedra"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ITERATIONS 3000\n\nfloat horn(vec3 r, float s) {\n    float a = sqrt(r.x * r.x + r.y * r.y);\n    float b = r.z;\n    if (a * b < s) {\n        return -1.0;\n    } // inside\n    float p = a - s / b;\n    float q = b - s / a;\n    float d = sqrt(p * p + q * q);\n    return 0.5 * d;\n}\n\nvec3 rotateh(vec3 r, float theta) {\n    float c = cos(theta); float s = sin(theta);\n    return vec3(c*r.x - s*r.z, r.y, s*r.x + c*r.z);\n}\nvec3 rotatev(vec3 r, float theta) {\n    float c = cos(theta); float s = sin(theta);\n    return vec3(r.x, c*r.y - s*r.z,  s*r.y + c*r.z);\n}\n\nvec4 mapN(vec3 p) { // for multiple objects\n\n    // horizontal and vertical rotation\n    float alpha = 9.*(iMouse.x/iResolution.x - 0.5);\n    float beta = 9.*(iMouse.y/iResolution.y - 0.5);\n    vec3 r = rotateh(rotatev(p, beta), alpha);\n    \n    float dist = horn(r, 0.2);;\n    vec3 color = vec3(1.,1.,1.);\n    vec4 horn = vec4(color, dist);\n    \n    return horn;\n    \n}\n\nfloat map(vec3 r) { // just the SDF\n    return mapN(r).w;\n}\n\nvec3 surfaceN(vec3 s) {\n    const float eps = 0.0001;\n    const vec2 h = vec2(eps,0);\n    float dx = map(s + vec3(eps, 0.0, 0.0)) - map(s - vec3(eps, 0.0, 0.0));\n    float dy = map(s + vec3(0.0, eps, 0.0)) - map(s - vec3(0.0, eps, 0.0));\n    float dz = map(s + vec3(0.0, 0.0, eps)) - map(s - vec3(0.0, 0.0, eps));\n    return normalize(vec3(dx, dy, dz));\n}\n\nvec4 raymarch(vec3 ro, vec3 rd) {\n    vec4  res = vec4(0.0);\n    float t = 0.0;\n    for (int k = 0; k < ITERATIONS; k++) {\n        vec3 rt = ro + rd * t;\n        vec4 f = mapN(rt);\n        vec3 col = f.xyz;\n        float d = f.w;\n        t += d;\n        if (d < 0.0001) {\n            res.xyz = col;\n            res.w = t;\n            return res;\n        }\n    }\n    res.w = -1.0;\n    return res;\n}\n\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt ) {\n    float t = mint;\n    for( int i = 0; i < ITERATIONS && t <maxt; i++) {\n        float h = map(ro + rd * t);\n        if (h < 0.001) {\n            return 0.0;\n        }\n        t += h;\n    }\n    return 1.0;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec4 f = raymarch(ro,rd);\n    vec3 color = f.xyz;\n    float t = f.w;\n    if(t == -1.0) {\n        return vec3(0.2);\n    }\n    \n    vec3 s = ro + t * rd; // the point on the surface\n    vec3 n = surfaceN(s); // and the normal there\n    \n    vec3 light = vec3(50., 50., 40.); // light\n    vec3 l = normalize(light - s); // light ray\n    float shade = shadow(s, l, 0.03, length(light - s));\n\n    return color * dot(l, n) * shade; // shading\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec3 pixel = vec3(uv, 0.0); // pixel location\n    vec3 ro  = vec3(400., 400., 300.); // ray origin (eye position)\n    vec3 rd  = normalize(pixel - ro);// ray direction\n    \n    vec3 color = render(ro, rd);\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}