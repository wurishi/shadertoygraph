{"ver":"0.1","info":{"id":"ssByWy","date":"1643996410","viewed":147,"name":"Graphics Card Profiling","username":"mgrant8164","description":"A shader testing how texels are grouped into threads.\n\nIt works by running a resource intensive workload or no workload for alternate texel groups, and because threads terminate when all texels complete, the no-load thread should take almost no time.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["test","performance","optimization","profiling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// See: https://www.shadertoy.com/view/stKGWK\n//Key for the different types of coordinates\n//========================================\n//fragCoord| input given to shader\n//cf_coord | Centered Fragment Coordinates\n//ss_coord | Scaled Screen Coordinates\n//ix_coord | Integereal teXel Coordinates\n//fx_coord | Floating-point teXel Coordinates\n//ii_coord | Integereal texel Index [Coordinates] (zig-zag order, in order of buffer memory allocation)\n//fi_coord | Same as ii_cord, but as floats\n\n//shader constants\n//coordinate space limits/resolution\n vec2 cf_res;\n vec2 ss_res;\nivec2 ix_res;\n vec2 fx_res;\n  int ii_res;\nfloat fi_res;\n\n\nint rio_call_count;\nvec4 resourceIntensiveOperation(ivec2 ix_coord) {\n    //temporary variables to calculate 'hash'\n    int fi_coord = ix_coord.x + (ix_coord.y * ix_res.x);\n    float time_seed = 0.0;\n    float seed = 0.0; //result\n    \n    const int NUM_ITER = 50;\n    for(int i = 0; i < NUM_ITER; ++i) {\n        //Increment call count to change the seed\n        fi_coord = ((fi_coord * (++rio_call_count % 23)) + (rio_call_count % 37)) % 377387;\n        time_seed = abs(sin((time_seed + iTime) * 100000.0 / cos(float(rio_call_count % 42))));\n        seed = abs(cos(pow(seed * 0.125 + float(fi_coord) + 1.0, time_seed)));\n    }\n    \n    //return a result\n    return vec4(vec3(seed),1.0);\n}\n\n/*==[Results]==\nsmall-X index:\n| step |  fps |\n|   3  | 29.0 |\n|   8  | 32.9 |\n|  16  | 50.3 | !\n|  24  | 29.0 |\n|  32  | 29.0 |\n|  48  | 29.0 |\n|  64  | 29.0 |\nsmall-Y index:\n| step |  fps |\n|   3  | 29.0 |\n|   8  | 29.0 |\n|  16  | 35.7 |\n|  24  | 29.0 |\n|  32  | 41.3 | !\n|  48  | 29.0 |\n|  64  | 29.0 |\ncheckered square (X x Y steps):\n|  steps  | step |  fps |\n|  1 x  1 |   1  | 29.0 |\n|  2 x  2 |   4  | 29.0 |\n|  3 x  3 |   9  | 29.0 |\n|  4 x  4 |  16  | 29.0 |\n|  4 x  8 |  32  | 54.3 | * <----\n|  8 x  4 |  32  | 29.0 |\n|  8 x  8 |  64  | 54.3 | *\n| 16 x 16 | 256  | 50.3 | *\n\nCONCLUSION:\nThreads are processed in groups of 4(X) x 8(Y) pixels \nwhich are indexed starting from x=0, y=0 (the corner origin).\n\nThis test done an a GTX 1070 Ti\n12/1/2021 10:15AM\n*/\nvec4 tempMain(ivec2 ix_coord) {\n    const int STEP = 8;\n    //initialize test variables\n    rio_call_count = 0;\n    //try out a coordinate scheme\n    //int ii_coord = ix_coord.x + (ix_coord.y * ix_res.x); //small-X\n    int ii_coord = ix_coord.y + (ix_coord.x * ix_res.y); //small-Y\n    //if((ii_coord / STEP) % 2 == 0) { //linear indexed\n    if(((ix_coord.x / 4) + (ix_coord.y / 8)) % 2 == 0) { //checkered\n        //\n        return resourceIntensiveOperation(ix_coord);\n    } else {\n        return vec4(vec3(1.0), 1.0);\n    }\n}\n\n//calculates color based on scaled screen space coordinates\nvoid main_texel(inout vec4 color, in vec2 ss_cord) {\n    if(all(lessThanEqual(abs(ss_cord), vec2(1.0))))\n        color = vec4(vec3(0.0), 1.0);\n    else\n        color = vec4(vec3(1.0), 1.0);\n}\n\n//calculates and assigns texel color\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //constants per resolution\n    //scaling factor for scaled screen space coordinates\n    float ss_scaling_factor = 0.5 * min(iResolution.x, iResolution.y);\n    //set the maximum resolution of the various coordinate spaces\n    cf_res = iResolution.xy - (0.5*iResolution.xy);\n    ss_res = cf_res / ss_scaling_factor;\n    ix_res = ivec2(iResolution.xy);\n    fx_res = iResolution.xy;\n    ii_res = ix_res.x * ix_res.y;\n    fi_res = float(ii_res);\n    \n    \n    //center coordinates at middle of screen\n    vec2 cf_coord = fragCoord - (0.5*iResolution.xy);\n    //calculate ss_cord: have the middle 1:1 square of the image be -1:+1 units, with 0 at the center\n    //[de-]scale coordinates by the scaling factor\n    vec2 ss_cord = cf_coord / ss_scaling_factor;\n    //assign texel coordinate values\n    ivec2 ix_coord = ivec2(fragCoord);\n    vec2 fx_coord = fragCoord;\n    //assign texel index values (curently unused)\n    int ii_coord = ix_coord.x + (ix_coord.y * ix_res.x);\n    float fi_coord = float(ii_coord) + 0.5;\n    \n    //calculate texel value and display it\n    fragColor = vec4(0.0);\n    //main_texel(fragColor, ss_cord);\n    fragColor = tempMain(ix_coord);\n}","name":"Image","description":"","type":"image"}]}