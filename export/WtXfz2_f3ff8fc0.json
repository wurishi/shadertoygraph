{"ver":"0.1","info":{"id":"WtXfz2","date":"1597137057","viewed":74,"name":"RayMarchTest_DB","username":"db009","description":"followed a tutorial on RayMarching just doing research!","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","basics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MaxSteps 100\n#define MaxDist 100.\n#define SurfDist .01\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t= dot(ab,ap)/dot(ab,ab);\n    t= clamp(t,0.,1.);\n    \n    vec3 c = a+t*ab;\n    return length(p-c)-r;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t= dot(ab,ap)/dot(ab,ab);\n    //t= clamp(t,0.,1.);\n    \n    vec3 c = a+t*ab;\n    float x = length(p-c)-r;\n    float y= (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x,y),0.));//exterior\n    float i= min(max(x,y),0.);//interior\n    return e+i;\n}\n\nfloat sdTorus(vec3 p, vec2 r)\n{\n float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat sdBox(vec3 p,vec3 size)\n{\n    return length(max(abs(p)-size,0.));\n}\n\nmat2 Rot(float a)\n{\n \tfloat s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat sdUnion(float a, float b, float k)\n{\n    float h = clamp(.5+.5*(b-a)/k,0.,1.);\n    return mix(b,a,h)-k*h*(1.0-h);\n}\n\nfloat GetDist(vec3 p)\n{\n    float planeDist = p.y;//plane pos\n    \n \tvec4 s1= vec4(3,1,6,1);//sphere 1 pos\n    vec4 s2= vec4(4,1,6,1);//sphere2 pos\n    //sphere dist\n    float sphereDist = length(p-s1.xyz)-s1.w;//sphere1\n    float sphereDist2 = length(p-s2.xyz)-s2.w;//sphere2\n    //float subtraction = max(-sphereDist,sphereDist2);//boolean subtraction    \n    //float d = min(subtraction, planeDist);//add objects to d to draw em\n    \n    float intersection = max(sphereDist,sphereDist2);//boolean intersection    \n    float d = min(intersection, planeDist);//add objects to d to draw em\n    \n    float capsuleDis = sdCapsule(p,vec3(0,1,6),vec3(1,2,6),.2);\n    \n    float torusDist = sdTorus(p-vec3(0,.5,6), vec2(1.5,.3));\n    //d= min(d,torusDist);//add torus to d to draw it\n    \n    vec3 boxPos = p-vec3(-3,.75,6);\n    boxPos.xz *= Rot(iTime);//rotate    \n    float boxDist = sdBox(boxPos, vec3(.75));\n    //d= min(d, boxDist);//add rotating box to D for drawing\n    \n    //union of box and torus\n    float union1 = sdUnion(boxDist,torusDist,1.2);//use sdUnion\n    d = min(d,union1);//add fused object drawing\n    \n    float cylinderDis1 = sdCylinder(p,vec3(0,.3,3),vec3(3,.3,5),.3);\n    d= min(d, cylinderDis1);//add cylinder to d\n    \n    vec3 boxPos2 = p-vec3(-1,.75,3);   \n    float boxDist2 = sdBox(boxPos2, vec3(.25));\n     vec4 s3= vec4(-1,.75,3,.5);//sphere3 pos\n     float sphereDist3 = length(p-s3.xyz)-s3.w;//sphere3\n    float mixObj = mix(boxDist2,sphereDist3,sin(iTime)*.5+.5);\n    d= min(d, mixObj);//add mixedObj to d\n    \n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    float dO=0.;\n        \n        for(int i=0; i<MaxSteps; i++)\n        {\n    \t    vec3 p = ro+rd*dO;\n            float ds = GetDist(p);\n            dO+= ds;\n            if(dO>MaxDist || ds<SurfDist) break;\n        }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p)\n{\n float d = GetDist(p);\n    vec2 e = vec2(.01,0);\n    \n    vec3 normal = d- vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(normal);\n}\n\nfloat GetLight(vec3 p)\n{\n    vec3 lightPos = vec3(0,5,6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 normal = GetNormal(p);\n    \n    float diffuse = clamp(dot(normal,l),0.,1.);\n    float d = RayMarch(p+normal*SurfDist*2.,l);\n    if(d<length(lightPos-p)) diffuse*=.3;\n    return diffuse;\n}\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(1,.5,0);\n    //rayOrigin Camera origin\n\tvec3 ro = vec3(0,2,0);\n    //raydirection\n    vec3 rd = normalize(vec3(uv.x,uv.y-.2,1));\n    \n    float d = RayMarch(ro,rd);\n    vec3 p = ro+rd*d;\n    \n    float diffuse = GetLight(p);//get light of raymarched position\n   \n    col =vec3(diffuse)*vec3(sin(iTime),-sin(iTime),sin(iTime));\n   \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}