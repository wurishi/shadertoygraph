{"ver":"0.1","info":{"id":"ftlXWl","date":"1626813141","viewed":1104,"name":"Lambertian Microsphere BRDF","username":"AndrewHelmer","description":"Implementation of the fast version of Eugeon d'Eon's paper: \"An analytic BRDF for materials with spherical Lambertian scatterers\"\nMeant to replicate the figures from the paper. Left sphere is Lambert BRDF, right sphere is new BRDF.","likes":27,"published":1,"flags":0,"usePreview":0,"tags":["brdf","spherical","lambertian","deon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Implementation of fast BRDF from\n// \"An analytic BRDF for materials with spherical Lambertian scatterers\" \n// (d'Eon 2021, winner of EGSR Best Paper)\n// https://developer.nvidia.com/blog/nvidia-research-an-analytic-brdf-for-materials-with-spherical-lambertian-scatterers/\nconst vec3 lightCol = vec3(1.0, 1.0, 1.0);\nconst float PI = 3.141592653589;\nconst vec3 kd = vec3(0.5, 0.25, 0.12);  // Diffuse color parameterization.\nconst vec3 c = (1.0 - pow(1.0 - kd, vec3(2.73556))) / (1.0 - 0.184096*pow(1.0 - kd, vec3(2.48423)));\nconst float whitePoint = 1.0;\n\n// From https://gamedev.stackexchange.com/questions/96459/fast-ray-sphere-collision-code.\nfloat intersectSphere(vec3 ro, vec3 rd, vec3 center, float rad) {\n    ro -= center;\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - rad*rad;\n    if (c > 0.0f && b > 0.0) return -1.0;\n    float discr = b*b - c;\n    if (discr < 0.0) return -1.0;\n    // Special case: inside sphere, use far discriminant\n    if (discr > b*b) return (-b + sqrt(discr));\n    return -b - sqrt(discr);\n}\n\nfloat safeacos(const float x) {\n    return acos(clamp(x, -1.0, 1.0));\n}\n\nfloat phase(float u) {\n    return (2.0*(sqrt(1.0 - u*u) - u*acos(u)))/(3.0*PI*PI);\n}\n\nvec3 shadeLambertianSphereBRDF(vec3 wi, vec3 wo, vec3 norm) { \n    float ui = dot(wi, norm);\n    float uo = dot(wo, norm);\n    if (ui <= 0.0 || uo <= 0.0) return vec3(0.0);\n    \n    float ui2 = ui*ui;\n    float uo2 = uo*uo;\n    float S = sqrt((1.0-ui2)*(1.0-uo2));\n    float cp = -((-dot(wi, wo) + ui*uo)/S);\n    float phi = safeacos(cp);\n    float iodot = dot(wi, wo);\n    \n    // Single-Scattering component, corresponds to \"f_1\" in the paper.\n    vec3 SS = c*(phase(-iodot) / (ui + uo));\n    \n    // These next two blocks are identical. The first block is a copy of the implementation from\n    // https://github.com/eugenedeon/mitsuba/blob/master/src/bsdfs/lambert_sphere_fast.cpp\n    // The second block is a literal coding of Equation 48 from the paper.\n#if 1\n    float p = ui * uo;\n    return PI * uo * max(\n        vec3(0.0), \n        0.995917*SS+(0.0684744*(((phi+sqrt(p))*(-0.249978+c)/(4.50996*((safeacos(S)/S)+0.113706)))+pow(max(1.94208*kd,0.0),vec3(1.85432))))\n    );\n    \n#else\n    vec3 fr = max( \n        vec3(0.0), \n        SS + 0.234459*pow(kd, vec3(1.85432)) \\\n           + (0.0151829*(c-0.24998)*(abs(phi)+sqrt(ui*uo))) / (0.113706 + (safeacos(S)/S))\n    );\n    return PI * uo * fr;\n#endif\n}\n\nvec3 shadeLambertBRDF(vec3 wi, vec3 wo, vec3 norm) {\n    return kd * (lightCol * clamp(dot(norm, wo), 0.0, 1.0));\n}\n\nvec3 adjustExposureGamma(vec3 col) {\n    col /= whitePoint;\n    col = pow(col, vec3(1.0/2.2));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 xy = 2.0 * (fragCoord.xy / iResolution.xy) - 1.0;\n    vec3 rayDir = vec3(0.0, 0.0, -1.0);\n    vec3 rayOrigin = vec3(2.0*xy*vec2((iResolution.x / iResolution.y), 1.0), 10.0);\n    \n    float lightAngle = PI*(iTime/5.0 + 0.5);\n    vec3 lightPos = vec3(-cos(lightAngle)*10.0, 0.0, sin(lightAngle)*10.0);\n    \n    vec3 center = vec3(1.5, 0.0, 0.0);\n    float rad = 1.3;\n    float t = intersectSphere(rayOrigin, rayDir, center, rad);\n    if (t >= 0.0) {\n        vec3 position = rayOrigin+t*rayDir;\n        vec3 norm = normalize(position-center);\n        vec3 offsetLightPos = lightPos+center;\n        vec3 lightDir = normalize(offsetLightPos-position);\n        \n        vec3 col = shadeLambertianSphereBRDF(-rayDir, lightDir, norm);\n        fragColor = vec4(adjustExposureGamma(col), 1.0);\n        return;\n    }\n    \n    center = vec3(-1.5, 0.0, 0.0);\n    t = intersectSphere(rayOrigin, rayDir, center, rad);\n    if (t >= 0.0) {\n        vec3 position = rayOrigin+t*rayDir;\n        vec3 norm = normalize(position-center);\n        vec3 offsetLightPos = lightPos+center;\n        vec3 lightDir = normalize(offsetLightPos-position);\n        \n        vec3 col = shadeLambertBRDF(-rayDir, lightDir, norm);\n        fragColor = vec4(adjustExposureGamma(col), 1.0);\n        return;\n    }\n    \n    fragColor = vec4(vec3(0.0), 1.0);\n}","name":"Image","description":"","type":"image"}]}