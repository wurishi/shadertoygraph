{"ver":"0.1","info":{"id":"dlccz7","date":"1699546288","viewed":41,"name":"stars universe","username":"loki123123","description":"random implementation","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"dtccz7","parentname":"random noise test1"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define hashblocksize 0.001\n#define viewRange 100.\n\nfloat rand(float seed){\n // Uncomment for calculated rand\n        return fract(sin((seed)) * 125.5453);\n    \n}\n\n// https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nfloat rand2(vec2 co){\n    return fract(sin(dot(co ,vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\nfloat rand3(vec3 co){\n    return fract(sin(dot(co ,vec3(11.4514,12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 uv = (fragCoord-iResolution.xy+iMouse.xy)/iResolution.x;\n  \n    \n     vec3 ray = vec3(uv,1.);\n     vec3 pos = vec3(0.,0.,iTime/20.);\n    // ray+=normalize(vec3(iMouse.x-iResolution.x,iMouse.y-iResolution.y,iResolution.x));\n\n     //sky color\n     fragColor = vec4(0);    \n     for(float i=0.;i<viewRange;i+=1.){\n         vec3 oriviewpos = pos+ ray*hashblocksize*i;\n          vec3 viewpos=floor(oriviewpos/hashblocksize)*hashblocksize+vec3(hashblocksize)/2.;\n         if(rand3(viewpos)<0.001&& length(oriviewpos-viewpos)<hashblocksize/2.){\n              float x= rand(viewpos.x);\n             float y= rand(viewpos.y);\n             float z= rand(viewpos.z);\n             vec3 color = vec3((y+z)/2.,(x+z)/2.,(x+y)/2.);\n             float alpha=pow(0.08,(length(oriviewpos-viewpos))/hashblocksize*2.);\n             color*=alpha;\n         fragColor.xyz=vec3(hashblocksize*viewRange)/length(pos-viewpos)*color;\n    \n           return;\n         }\n     }\n     \n     \n}","name":"Image","description":"","type":"image"}]}