{"ver":"0.1","info":{"id":"l3ffzH","date":"1730560227","viewed":351,"name":"Spheres 2 with pathtracing","username":"morimea","description":"Spheres on square voxels with pathtracing.\n\nUncomment define ULTRA_WIDE_RES_LOOPS in Common - to have more spheres and larger rendering limit.","likes":33,"published":3,"flags":48,"usePreview":1,"tags":["procedural","3d","raytracing","grid","spheres","rectangle","pathtracer"],"hasliked":0,"parentid":"MXsyWB","parentname":"Spheres with pathtracing"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Created by Danil (2024+) https://github.com/danilw\n// https://mastodon.gamedev.place/@danil\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// self https://www.shadertoy.com/view/l3ffzH\n\n\n// if you look for templates - look\n// https://danilw.github.io/blog/my_shader_templates_list/\n\n\n\n// CONTROL:\n// Mouse - look\n// Space keyboard key - stop movement\n\n\n\n// using\n// https://iquilezles.org/articles/intersectors/\n// palette from iq https://www.shadertoy.com/view/ll2GD3\n// TAA from gelami https://www.shadertoy.com/view/DsfGWX\n\n\n\n// for ULTRA-WIDE monitors and more spheres\n// uncomment define ULTRA_WIDE_RES_LOOPS in Common\n\n\n\n\n\n\n\n// remember to set mipmaps to iChannel3 in Image to use bloom\n//#define use_bloom\n#ifdef use_bloom\nmat3 gaussianFilter = mat3(41, 26, 7,\n                           26, 16, 4,\n                           7,  4,  1) / 273.;\n// bloom\nvec3 bloom(float scale, float threshold, vec2 fragCoord, sampler2D ich){\n    // this does not alway work\n    // Shadertoy allocate mipmap once and forever - no way to know if they exit actually\n    // maybe this is another webbrower WebGL implementation feature/bug idk\n    if(textureSize(ich,1).x<10) return vec3(0.);\n    float logScale = log2(scale);\n    vec3 bloom = vec3(0);\n    for(int y = -2; y <= 2; y++)\n        for(int x = -2; x <= 2; x++)\n            bloom += gaussianFilter[abs(x)][abs(y)] * textureLod(ich, (fragCoord+vec2(x, y)*scale)/iResolution.xy, logScale).rgb;\n    return max(bloom - vec3(threshold), vec3(0.));\n}\n#endif\n\n#ifdef use_dynamic_TAA\n#ifdef enable_volume\n// from https://www.shadertoy.com/view/Xltfzj\nvec4 GaussianBlur(in vec2 fragCoord, sampler2D ich)\n{\n    float Directions = 6.0;\n    float Quality = 3.0;\n    float Size = 3.0;\n    vec2 Radius = Size/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 Color = texture(ich, uv);\n    for( int i=0; i<int(Directions); i++)\n    {\n        float d=float(i)*TAU/Directions;\n\t\tfor(int j=0; j<int(Quality); j++)\n        {\n            float ti=1.0/Quality+float(j)*1.0/Quality;\n\t\t\tColor += textureLod( ich, uv+vec2(cos(d),sin(d))*Radius*ti, 0.);\t\n        }\n    }\n    Color /= Quality * Directions+1.;\n    return Color;\n}\n#endif\n#endif\n\n// volume raymarch mix color\n//----------------------------------------------\n#ifdef enable_volume\n\nvec3 raymarchVolume_image(vec3 backGround, float absorb, vec3 sunColor, float lDotV, float lDotU, float fogLitPercent){\n    \n    //return vec3(absorb)*0.15;\n    \n    float phaseMie = hGPhase(lDotV, 0.8);\n    \n\n    vec3 c_fogColorLit = backGround+sunColor * phaseMie*0.5+0.0005*(0.5+sunColor*0.5);\n    vec3 c_fogColorUnlit = vec3(0.);\n    \n    vec3 fogColor = mix(c_fogColorUnlit, c_fogColorLit, fogLitPercent*fogLitPercent*fogLitPercent);\n    return mix(fogColor, backGround, absorb);\n}\n#endif\n//----------------------------------------------\n\nvec3 ACESFilm(vec3 x);\nvec3 srgb_encode (vec3 v);\nvec3 color2agx(vec3 col);\nvec3 linearTosRGB(vec3 col)\n{\n    return mix(1.055 * pow(col, vec3(1.0 / 2.4)) - 0.055, col * 12.92, lessThan(col, vec3(0.0031308)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n/*\nvec4 dt = texture(iChannel0,fragCoord/iResolution.xy);\n//fragColor = vec4(dt.xyz,0.);\n//fragColor = vec4(dt.z<-0.7);\nfragColor = vec4(dt.x/800.);\nfragColor = vec4(dt.y/5.);\nreturn;\n*/\n    vec2 fc = fragCoord.xy;\n    vec3 texture_color = vec3(1.);\n#ifdef use_dynamic_TAA\n    vec3 color = texelFetch(iChannel3, ivec2(fc), 0).rgb;\n#else\n    vec3 color = texelFetch(iChannel2, ivec2(fc), 0).rgb;\n#ifdef enable_textures\n    texture_color = unpack_Unormfloat3x10(texelFetch(iChannel2, ivec2(fc), 0).a);\n#endif\n#endif\n\n#ifndef enable_textures\n#ifdef enable_volume\n    \n    // unjittering volume fog\n    vec2 halton_px_shift = vec2(load(HALTON0,iChannel0),load(HALTON1,iChannel0));\n    if(load(INPUT0,iChannel0)<1.) halton_px_shift =vec2(0.);\n    \n#ifdef use_dynamic_TAA\n    //float absorb = texelFetch(iChannel3, ivec2(fc), 0).a;\n    float absorb = GaussianBlur(fc, iChannel3).a; //additional Blur on top of TAA\n    float fogLitPercent = GaussianBlur(fc-halton_px_shift, iChannel1).a;\n    //float fogLitPercent = textureLod(iChannel1, vec2(fc-halton_px_shift)/iResolution.xy, 0.).a;\n#else\n    float absorb = textureLod(iChannel2, vec2(fc-halton_px_shift)/iResolution.xy, 0.).a;\n    float fogLitPercent = textureLod(iChannel1, vec2(fc-halton_px_shift)/iResolution.xy, 0.).a;\n#endif\n    \n    absorb = clamp(absorb,0.,1.);\n    vec2 uv = (fragCoord)/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    vec3 ro;\n    vec3 rd;\n    SetCamera(uv, iChannel0, ro, rd, iResolution.xy);\n    \n    vec3 sunColor = calculateSunColor(lightDir.y);\n    float lDotV = dot(rd, lightDir);\n    float lDotU = dot(rd, upVec);\n    color = raymarchVolume_image(color, absorb, sunColor, lDotV, lDotU, fogLitPercent);\n    \n#endif\n#endif\n    vec3 blom = vec3(0.);\n#ifdef use_bloom\n#ifdef use_dynamic_TAA\n    blom += bloom(.015 * iResolution.y, 0.002,fragCoord,iChannel3)*0.105;\n    blom += bloom(.05 * iResolution.y, 0.002,fragCoord,iChannel3)*0.05;\n#else\n    blom += bloom(.015 * iResolution.y, 0.002,fragCoord,iChannel2)*0.105;\n    blom += bloom(.05 * iResolution.y, 0.002,fragCoord,iChannel2)*0.05;\n#endif\n#endif\n    //color = ACESFilm(color*texture_color+blom);\n    //color = srgb_encode(color);\n    color = color2agx(color*texture_color+blom);\n\tfragColor = vec4(color, 1.0 );\n   \n}\n\n\n\nvec3 ACESFilm(vec3 x){\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n\nvec3 srgb_encode (vec3 v) {\n  return mix(12.92*v,1.055*pow(v,vec3(.41666))-.055,step(.0031308,v));\n}\n\n\n\n// Agx from https://www.shadertoy.com/view/cd3XWr\n#define AGX_LOOK 2\n\n// AgX\n// ->\n\n// Mean error^2: 3.6705141e-06\nvec3 agxDefaultContrastApprox(vec3 x) {\n  vec3 x2 = x * x;\n  vec3 x4 = x2 * x2;\n  \n  return + 15.5     * x4 * x2\n         - 40.14    * x4 * x\n         + 31.96    * x4\n         - 6.868    * x2 * x\n         + 0.4298   * x2\n         + 0.1191   * x\n         - 0.00232;\n}\n\nvec3 agx(vec3 val) {\n  const mat3 agx_mat = mat3(\n    0.842479062253094, 0.0423282422610123, 0.0423756549057051,\n    0.0784335999999992,  0.878468636469772,  0.0784336,\n    0.0792237451477643, 0.0791661274605434, 0.879142973793104);\n    \n  const float min_ev = -12.47393f;\n  const float max_ev = 4.026069f;\n\n  // Input transform\n  val = agx_mat * val;\n  \n  // Log2 space encoding\n  val = clamp(log2(val), min_ev, max_ev);\n  val = (val - min_ev) / (max_ev - min_ev);\n  \n  // Apply sigmoid function approximation\n  val = agxDefaultContrastApprox(val);\n\n  return val;\n}\n\nvec3 agxEotf(vec3 val) {\n  const mat3 agx_mat_inv = mat3(\n    1.19687900512017, -0.0528968517574562, -0.0529716355144438,\n    -0.0980208811401368, 1.15190312990417, -0.0980434501171241,\n    -0.0990297440797205, -0.0989611768448433, 1.15107367264116);\n    \n  // Undo input transform\n  val = agx_mat_inv * val;\n  \n  // sRGB IEC 61966-2-1 2.2 Exponent Reference EOTF Display\n  //val = pow(val, vec3(2.2));\n\n  return val;\n}\n\nvec3 agxLook(vec3 val) {\n  const vec3 lw = vec3(0.2126, 0.7152, 0.0722);\n  float luma = dot(val, lw);\n  \n  // Default\n  vec3 offset = vec3(0.0);\n  vec3 slope = vec3(1.0);\n  vec3 power = vec3(1.0);\n  float sat = 1.0;\n \n#if AGX_LOOK == 1\n\n  slope = vec3(1.25);\n  power = vec3(.75);\n  sat = 1.28;\n#elif AGX_LOOK == 2\n  slope = vec3(1.25);\n  power = vec3(.95);\n  sat = 1.58;\n#elif AGX_LOOK == 3\n  // Punchy\n  slope = vec3(1.0);\n  power = vec3(1.35, 1.35, 1.35);\n  sat = 1.4;\n#endif\n  \n  // ASC CDL\n  val = pow(val * slope + offset, power);\n  return luma + sat * (val - luma);\n}\n\n// <-\n\nvec4 toLinear(vec4 sRGB) {\n  bvec4 cutoff = lessThan(sRGB, vec4(0.04045));\n  vec4 higher = pow((sRGB + vec4(0.055))/vec4(1.055), vec4(2.4));\n  vec4 lower = sRGB/vec4(12.92);\n  \n  return mix(higher, lower, cutoff);\n}\n\nvec3 color2agx(vec3 col)\n{\n  //col = toLinear(vec4(col, 1.0)).rgb;\n\n  col = agx(col);\n  col = agxLook(col);\n  col = agxEotf(col);\n\n  return col;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// do not use this - made for this exact case\n// template with camera https://danilw.github.io/blog/my_shader_templates_list/\n\n#define iTLime (45.+timerl*0.055)\n\n// this exist just because Shadertoy has only 4 buffers\n\nconst vec2 start_mouse_0 = vec2(0.5, -0.65);\n\n#define iTimeDelta min(iTimeDelta,1./10.)\n\nvoid store(ivec2 P, ivec2 ipx, float V, inout vec4 fc){ if(ipx==P) fc.a = V;}\n\nvec3 CameraDirInput(float timerl) {\n    return vec3(220.*sin(iTLime*(1./75.)*(3.14159265*2.))+2.+400.,220.*cos(iTLime*(1./75.)*(3.14159265*2.))+2.+400.,2.9).xzy;\n}\n\nvec2 render_new_minDist(in vec2 fragCoord, vec2 halton_px_shift, vec3 ro, vec2 m) {\n\n    vec2 fc=fragCoord.xy;\n    fragCoord.xy += halton_px_shift;\n    \n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    vec3 rd;\n    SetCamera_m(uv, m, rd, iResolution.xy);\n    \n    HitInfo hit;\n\tbool rayHit = minDist(ro, rd, hit, VOX_LP);\n    \n    return vec2(float(hit.obj_type)+0.5,hit.t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    ivec2 ipx = ivec2(fragCoord);\n    \n// moved because BufB moved here\n//--------------------\n    vec2 res_l = vec2(load(RES_LAST0,iChannel0),load(RES_LAST1,iChannel0));\n    bool input_registered = false;\n    bool res_ch = ivec2(res_l)!=ivec2(iResolution.xy);\n    input_registered = res_ch;\n    // resolution control\n    input_registered = input_registered||(load(ivec2(iResolution.xy)-1, iChannel0))<0.5;\n    //input_registered=true;\n    bool input_registered_TMP = input_registered;\n    \n    \n    vec3 target      = vec3(load(TARGET0, iChannel0),load(TARGET1, iChannel0),load(TARGET2, iChannel0));   \n    vec3 position    = vec3(load(POSITION0, iChannel0),load(POSITION1, iChannel0),load(POSITION2, iChannel0));\n    vec3 position_l = position;\n    \n    vec2 pm          = vec2(load(PMOUSE0, iChannel0),load(PMOUSE1, iChannel0));\n    vec3 vm          = vec3(load(VMOUSE0, iChannel0),load(VMOUSE1, iChannel0),load(VMOUSE2, iChannel0));\n    \n    float timerl = load(TIMER_L, iChannel0);\n    \n    bool is_init = load(INIT0, iChannel0)<1.;\n    \n    vec3 start_pos = CameraDirInput(timerl);\n    vec2 start_mouse = start_mouse_0;\n\n    if (iFrame == 0 || is_init) \n    {\n        target = start_pos;\n        position = start_pos;\n        position_l = start_pos;\n        pm = start_mouse;\n        vm.xy = start_mouse.xy;\n    }\n    \n    vec3 ptarget = target;\n    target = CameraDirInput(timerl);\n\n    vec3 lp = position;\n    position += (target - position) * min(iTimeDelta,1./10.) * 2.5;\n    position.y = target.y;\n\n    \n    if(length(abs(position)-abs(lp))>0.0001)input_registered=true;\n    \n    vec3 ro = position;\n    vec2 im = vec2(0.);\n    \n    if (iMouse.z>0.0) {\n        vec2 tpm = pm + (abs(iMouse.zw) - iMouse.xy)/iResolution.y;\n        input_registered=input_registered||(abs(tpm.x-vm.x)>.5/iResolution.y||abs(tpm.y-vm.y)>.5/iResolution.y);\n    \tim = tpm;\n    }\n    else {\n    \tim = vm.xy;\n    }\n    //input_registered=true;\n    \n#ifdef use_dynamic_TAA\n    vec2 halton = (halton(iFrame % 360 + 1) - 0.5f);\n#else\n    vec2 halton = input_registered?vec2(0.):halton(iFrame % 360 + 1) - 0.5f;\n#endif\n    \n    fragColor.rg = render_new_minDist(fragCoord, halton, ro, im);\n    fragColor.b = texelFetch(iChannel0,ipx,0).y;\n    fragColor.a = texelFetch(iChannel0,ipx,0).a;\n    \n    if(ipx==ivec2(iResolution.xy)-1){\n        fragColor.a=2.; // resolution control for pause case\n        return;\n    }\n//--------------------\n    \n    \n    float bnoise=fragColor.a;\n    if(input_registered_TMP||iFrame==0)\n    if (any(greaterThan(ipx, MEMORY_BOUNDARY))){bnoise=Bnoise(fragCoord+iDate.w*0.01);fragColor.a=bnoise;}\n    \n    if (any(greaterThan(ipx, MEMORY_BOUNDARY))) return;\n    \n    vec2 vm_l = vec2(load(VMOUSE0, iChannel0),load(VMOUSE1, iChannel0));\n    \n    if (iFrame == 0 || is_init) {\n        vm_l=start_mouse;\n        vec3 position_l=start_pos;\n        store(POSITION0, ipx, start_pos.x, fragColor); // ro\n        store(POSITION1, ipx, start_pos.y, fragColor);\n        store(POSITION2, ipx, start_pos.z, fragColor);\n        store(POSITION_last0, ipx, position_l.x, fragColor); // last_ro\n        store(POSITION_last1, ipx, position_l.y, fragColor);\n        store(POSITION_last2, ipx, position_l.z, fragColor);\n        store(TARGET0, ipx, start_pos.x, fragColor); // mouse look\n        store(TARGET1, ipx, start_pos.y, fragColor);\n        store(TARGET2, ipx, start_pos.z, fragColor);\n        store(VMOUSE0, ipx, start_mouse.x, fragColor); // virtual mouse (rotation_mat)\n        store(VMOUSE1, ipx, start_mouse.y, fragColor);\n        store(VMOUSE_last0, ipx, vm_l.x, fragColor); // last virtual mouse\n        store(VMOUSE_last1, ipx, vm_l.y, fragColor);\n        store(PMOUSE0, ipx, start_mouse.x, fragColor); // real mouse pos\n        store(PMOUSE1, ipx, start_mouse.y, fragColor);\n        store(INIT0, ipx, 2., fragColor); // is_init(0 false, 2 true)\n        store(INPUT0_timer, ipx, 0., fragColor);\n        store(RES_CHANGE, ipx, 0., fragColor); // 0 true 1 false\n        store(INPUT0, ipx, 2., fragColor); // key_pressed(0 false, 2 true) \n        store(RES_LAST0, ipx, iResolution.x, fragColor); // xy = last_resolution\n        store(RES_LAST1, ipx, iResolution.y, fragColor);\n        store(HALTON0, ipx, halton.x, fragColor);\n        store(HALTON1, ipx, halton.y, fragColor);\n        store(HALTON_last0, ipx, 0., fragColor);\n        store(HALTON_last1, ipx, 0., fragColor);\n        store(TIMER_L, ipx, 0., fragColor);\n        store(IMONC, ipx, 0., fragColor);\n        return;\n    }\n    \n    \n    store(TARGET0, ipx, target.x, fragColor);\n    store(TARGET1, ipx, target.y, fragColor);\n    store(TARGET2, ipx, target.z, fragColor);\n    store(POSITION0, ipx, position.x, fragColor);\n    store(POSITION1, ipx, position.y, fragColor);\n    store(POSITION2, ipx, position.z, fragColor);\n\n    store(POSITION_last0, ipx, position_l.x, fragColor);\n    store(POSITION_last1, ipx, position_l.y, fragColor);\n    store(POSITION_last2, ipx, position_l.z, fragColor);\n    store(VMOUSE_last0, ipx, vm_l.x, fragColor);\n    store(VMOUSE_last1, ipx, vm_l.y, fragColor);\n    \n    if (iMouse.z>0.0) {\n        vec2 tpm = pm + (abs(iMouse.zw) - iMouse.xy)/iResolution.y;\n        input_registered=input_registered||(abs(tpm.x-vm.x)>.5/iResolution.y||abs(tpm.y-vm.y)>.5/iResolution.y);\n    \tstore(VMOUSE0, ipx, tpm.x, fragColor);\n        store(VMOUSE1, ipx, tpm.y, fragColor);\n        store(VMOUSE2, ipx, 1., fragColor);\n    }\n    else if (vm.z > 0.5) {\n    \tstore(PMOUSE0, ipx, vm.x, fragColor);\n        store(PMOUSE1, ipx, vm.y, fragColor);\n        store(VMOUSE2, ipx, 0., fragColor);\n    }\n    \n    store(INPUT0, ipx, input_registered?2.:0., fragColor);\n    float iot = load(INPUT0_timer, iChannel0);\n    store(INPUT0_timer, ipx, input_registered?0.:iot+iTimeDelta, fragColor);\n    \n    timerl+=min(iTimeDelta,1./10.)*(1.-step(0.5, texelFetch(iChannel3, ivec2(32, 2), 0).x));\n    store(TIMER_L, ipx, timerl, fragColor);\n    \n    //store(IMONC, ipx, 0., fragColor);\n    \n    store(HALTON0, ipx, halton.x, fragColor);\n    store(HALTON1, ipx, halton.y, fragColor);\n    \n    vec2 halton_last = vec2(load(HALTON0,iChannel0),load(HALTON1,iChannel0));\n    store(HALTON_last0, ipx, halton_last.x, fragColor);\n    store(HALTON_last1, ipx, halton_last.y, fragColor);\n    \n    store(RES_LAST0, ipx, iResolution.x, fragColor);\n    store(RES_LAST1, ipx, iResolution.y, fragColor);\n    \n    store(RES_CHANGE, ipx, res_ch?0.:1., fragColor);\n    \n    \n\n}\n\n\n\n\n\n\n\n\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n\n// define this for ultra-wide screen\n// or change number of loops in define VOX_LP below\n//#define ULTRA_WIDE_RES_LOOPS\n\n#define AORays 8\n#define reflectionRays 6\n#define shadowRays 6\n\n#ifndef ULTRA_WIDE_RES_LOOPS\n#define VOX_LP 30\n#define VOX_LP_shd 6\n#else\n#define VOX_LP 80\n#define VOX_LP_shd 10\n#define SPHERE_POS_LP\n#endif\n\n// edit parameters\n// ---------------\n\n// when enabled 2nd light bounce (num of rays=AORays)\n#define sunlight_2nd_bounce\n\n#define enable_reflections\n#define reflection_color_emi\n// edit/search PixelAcceptance to remove edge-trail from emission, closer to 1 better \n// but closer to 1 will remove all reprojection from thin edges on far - so balance\n\n// when ConeVector used in bounce light and emision light have not correct form \n// (compare to CosineWeightedSample, comment define below)\n#define use_ConeVector\n#define use_reproject_TAA\n\n// when turned off dymanic TAA - BufD is unused\n#define use_dynamic_TAA\n\n// texture or volume, texture use single float in BufB\n// and BufC copy to self alpha, just to have less texture reads in BufD that apply albedo TAA\n// albedo addition to color moved to BufD because TAA-pixel-jitter\n//#define enable_textures\n\n// when enabled dynamic TAA - there visible \"border\" on volume-shadow and object edges\n// look enable_volume in Image - ther unjittering and TAA applied to one component\n// there is small 1-2 pixel border on object-volume, look/remove GaussianBlur\n#define enable_volume\n\n#ifndef ULTRA_WIDE_RES_LOOPS\n#define volumeSteps 6\n#else\n#define volumeSteps 10\n#endif\nconst float volume_fogDensity = .0725;\n\nconst float camera_fov = 70.;\n\n// ---------------\n\n//#define ANGLE_loops 0\n#define ANGLE_loops min(iFrame,0)\n\n// weird Android bug fix? idk\n// https://www.shadertoy.com/view/4cGGWw\nvec4 my_texelFetch(highp sampler2D chan, ivec2 p, int l) {\n return texelFetch(chan,p,l);\n}\n#define texelFetch(a,b,c) my_texelFetch(a,b,c)\n\n\n\n#define MAX_DIST 1000.\n#define MIN_DIST .0001\n\n\n// OBJ_ is >=0, not negative\n#define OBJ_SKY 0\n#define OBJ_FLOOR 1\n#define OBJ_BOX 10\n#define OBJ_BOX_R 40\n#define OBJ_SPHERE 100\n#define OBJ_SPHERE2 650000\n\n\n//const vec3 lightDir = normalize(vec3(0.72155,0.514495,0.4633));\nconst vec3 lightDir = normalize(vec3(0.5, .45, 1.0));\n\n\n\nconst vec3 upVec = vec3(0.0, 1.0, 0.0);\n\n#define PI 3.141592653589793\n#define TAU 6.283185307179586\n#define c_goldenRatioConjugate 0.61803398875f\n\n\n\n// Camera related (just to have less code in buffers)\n// ---------------\nconst ivec2 MEMORY_BOUNDARY = ivec2(2, 15); //BufA reserved (and top right pixel)\n\nconst ivec2 RES_LAST0 = ivec2(0, 0);\nconst ivec2 RES_LAST1 = ivec2(0, 1);\nconst ivec2 INIT0 = ivec2(0, 2);\nconst ivec2 TARGET0 = ivec2(0, 3);\nconst ivec2 TARGET1 = ivec2(0, 4);\nconst ivec2 TARGET2 = ivec2(0, 5);\n\nconst ivec2 POSITION0 = ivec2(0, 6);\nconst ivec2 POSITION1 = ivec2(0, 7);\nconst ivec2 POSITION2 = ivec2(0, 8);\nconst ivec2 POSITION_last0 = ivec2(0, 9);\nconst ivec2 POSITION_last1 = ivec2(0, 10);\nconst ivec2 POSITION_last2 = ivec2(0, 11);\n\nconst ivec2 VMOUSE0 = ivec2(1, 0);\nconst ivec2 VMOUSE1 = ivec2(1, 1);\nconst ivec2 VMOUSE2 = ivec2(1, 2);\nconst ivec2 VMOUSE_last0 = ivec2(1, 3);\nconst ivec2 VMOUSE_last1 = ivec2(1, 4);\n\nconst ivec2 INPUT0 = ivec2(1, 5);\nconst ivec2 HALTON0 = ivec2(1, 6);\nconst ivec2 HALTON1 = ivec2(1, 7);\nconst ivec2 HALTON_last0 = ivec2(1, 8);\nconst ivec2 HALTON_last1 = ivec2(1, 9);\nconst ivec2 PMOUSE0 = ivec2(1, 10);\nconst ivec2 PMOUSE1 = ivec2(1, 11);\n\nconst ivec2 RES_CHANGE = ivec2(0, 12);\nconst ivec2 INPUT0_timer = ivec2(1, 12);\n\nconst ivec2 TIMER_L = ivec2(1, 14);\nconst ivec2 IMONC = ivec2(0, 14);\n\nfloat load(ivec2 P, sampler2D self){return texelFetch(self, ivec2(P), 0).a;}\nmat2 MD(float a){float s = sin( a );float c = cos( a );return mat2(vec2(c, -s), vec2(s, c));}\n\n// Camera\nmat3 rotationMatrix(vec2 m){\n  mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n  mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n  return rotY*rotX;\n}\n\nvoid SetCamera(vec2 uv, sampler2D caminfo, out vec3 ro, out vec3 rd, vec2 ires)\n{\n    ro = vec3(load(POSITION0,caminfo),load(POSITION1,caminfo),load(POSITION2,caminfo));\n    vec2 m = vec2(load(VMOUSE0,caminfo),load(VMOUSE1,caminfo));\n    m.y = -m.y;\n    float fov=camera_fov;\n    float aspect = ires.x / ires.y;\n    float screenSize = (1.0 / (tan(((180.-fov)* (3.1415926 / 180.0)) / 2.0)));\n    rd = vec3(uv*screenSize, 1./aspect);\n    \n    //rd+=0.000001*(1.-abs(sign(rd)));\n    rd = normalize(rd);\n    rd = rotationMatrix(m) * rd;\n}\n\nvoid SetCamera_prev(vec2 uv, sampler2D caminfo, out vec3 ro, out vec3 rd, vec2 ires)\n{\n    ro = vec3(load(POSITION_last0,caminfo),load(POSITION_last1,caminfo),load(POSITION_last2,caminfo));\n    vec2 m = vec2(load(VMOUSE_last0,caminfo),load(VMOUSE_last1,caminfo));\n    m.y = -m.y;\n    float fov=camera_fov;\n    float aspect = ires.x / ires.y;\n    float screenSize = (1.0 / (tan(((180.-fov)* (3.1415926 / 180.0)) / 2.0)));\n    rd = vec3(uv*screenSize, 1./aspect);\n    \n    //rd+=0.000001*(1.-abs(sign(rd)));\n    rd = normalize(rd);\n    rd = rotationMatrix(m) * rd;\n}\n\nvoid SetCamera_m(vec2 uv, vec2 m, out vec3 rd, vec2 ires)\n{\n    m.y = -m.y;\n    float fov=camera_fov;\n    float aspect = ires.x / ires.y;\n    float screenSize = (1.0 / (tan(((180.-fov)* (3.1415926 / 180.0)) / 2.0)));\n    rd = vec3(uv*screenSize, 1./aspect);\n    \n    //rd+=0.000001*(1.-abs(sign(rd)));\n    rd = normalize(rd);\n    rd = rotationMatrix(m) * rd;\n}\n\n// ---------------\n\n\n\n// ---------------\n\n// material by object id\n// remember about dFd bugs\n// ---------------\n\nvec3 get_pal(float td);\nfloat hash12(vec2 p);\nvoid material_OBJ_SPHERE(ivec2 tid, vec3 norm, out vec3 albedo, out vec3 emission, \n                        out float roughness, out float metalness){\n    float h1 = hash12(vec2(tid)+2.3);\n    albedo = get_pal(h1);\n    if(albedo.b<0.001){albedo+=0.001;albedo.b=0.002;}\n    albedo =normalize(albedo+vec3(0.5,0.75,0.5)*albedo.bbr);\n    albedo*=0.3;\n    if(albedo.b*0.9>albedo.g)albedo=vec3(0.88,0.94,0.95)*0.5;\n    //albedo = norm;\n    emission = vec3(1., 5., 15.)*0.;\n    roughness = 0.621-0.4*h1;\n    metalness = 0.25021;\n}\n\nvoid material_OBJ_FLOOR(vec3 pos, vec3 norm, out vec3 albedo, out vec3 emission, \n                        out float roughness, out float metalness){\n    albedo = vec3(1.,1.,1.);\n    emission = vec3(0.,0.,0.);\n    roughness = 0.2531;\n    metalness = 0.521;\n}\n\nvoid material_OBJ_BOX(int idx, vec3 norm, out vec3 albedo, out vec3 emission, \n                        out float roughness, out float metalness){\n    idx = ((idx-OBJ_BOX)/10)%2;\n    albedo = mix(vec3(0.43,0.79,0.86)*.35,vec3(0.88,0.94,0.95)*0.5,float(idx));\n    emission = mix(vec3(10.,5.,0.),vec3(0.),float(1-idx))*0.;\n    roughness = 0.31;\n    metalness = 0.05021;\n}\n\nvoid material_OBJ_BOX_R(int idx, vec3 norm, out vec3 albedo, out vec3 emission, \n                        out float roughness, out float metalness){\n    idx = ((idx-OBJ_BOX_R)/10)%2;\n    albedo = mix(vec3(0.43,0.79,0.86)*.35,vec3(0.88,0.94,0.95)*0.5,float(idx));\n    emission = 0.5*mix(vec3(0.88,0.94,0.95)*10.,vec3(0.),float(1-idx))*0.;\n    roughness = 0.31;\n    metalness = 0.05021;\n}\n\nvec3 get_normal_OBJ_SPHERE(vec3 pos){\n    if(length(pos)<0.0001)return vec3(0.001,0.001,0.99);\n    return normalize(pos);\n}\n\nvec3 get_normal_OBJ_FLOOR(vec3 pos){\n    return vec3(0.,1.,0.);\n}\n\nvec3 boxNormal(vec3 pos,vec3 p0,vec3 p1, vec3 bsize);\nvec3 get_normal_OBJ_BOX(vec3 pos, vec3 opos, vec3 box){\n    vec3 p = box*0.5+opos;\n    vec3 q = -box*0.5+opos;\n    vec3 tnorm = boxNormal(pos, p, q, box);\n    return normalize(tnorm);\n}\n\nvec3 get_normal_OBJ_FBOX(int idx){\n    int tid = (idx-OBJ_BOX)%10; \n    if(tid==0)return vec3(1.,0.,0.);\n    if(tid==1)return vec3(-1.,0.,0.);\n    if(tid==2)return vec3(0.,1.,0.);\n    if(tid==3)return vec3(0.,-1.,0.);\n    if(tid==4)return vec3(0.,0.,1.);\n    return vec3(0.,0.,-1.);\n}\n\nmat4 txxg = mat4(vec4(normalize(vec3(0.5,0.,0.5)),0.),vec4(0.,1.,0.,0.),vec4(normalize(vec3(-0.5,0.,0.5)),0.),vec4(0.,0.,0.,1.));\nvec3 get_normal_OBJ_RBOX(int idx){\n    vec3 n = vec3(0.,0.,-1.);\n    int tid = (idx-OBJ_BOX_R)%10; \n    if(tid==0)n=vec3(1.,0.,0.);\n    if(tid==1)n=vec3(-1.,0.,0.);\n    if(tid==2)n=vec3(0.,1.,0.);\n    if(tid==3)n=vec3(0.,-1.,0.);\n    if(tid==4)n=vec3(0.,0.,1.);\n    return (txxg*vec4(n,0.0)).xyz;\n}\n\n// ---------------\n\n\n\n// sky\n//----------------------------------------------\n\nconst float sunAngularDiameter = 15.5;\n\nconst float sunIluminance = 1.5;\n\nconst float goldenAngle = 2.3999632297286533;\n\n// sky from https://www.shadertoy.com/view/3dlSW7\n\nfloat hGPhase(float cosTheta, const float g){\n\tfloat g2 = g * g;\n    \n    return 0.25 * (1.0 - g2) * pow(g2 - 2.0 * g * cosTheta + 1.0, -1.5);\n}\n\nvec3 calculateSunColor(float sunZenith){\n\treturn mix(vec3(1., 0.84, 0.7), vec3(1.0), max(sunZenith, 0.0));\n}\n\nfloat calculateSun(float lDotV){\n    const float cosRad = cos(radians(sunAngularDiameter));\n    const float sunLuminance = sunIluminance / ((1.0 - cosRad) * TAU);\n    \n    return smoothstep(cosRad,cosRad*1.001, lDotV) * sunLuminance;\n}\n\nvec3 calculateSky(vec3 background, float lDotU, float lDotV){\n    float phaseMie = hGPhase(lDotV, 0.8);\n    \n    float zenith = max(lDotU, 0.0);\n    \n    float sunZenith = lightDir.y;\n    const vec3 topCol = vec3(0.1, 0.34, 1.0);\n    const vec3 bottomCol = vec3(.0);\n    \n    //vec3 sky = mix(topCol, (bottomCol + topCol), exp2(-zenith * 8.0));\n    \n    float ma = (1.-smoothstep(0.2,0.3,abs(lDotU)));\n    ma = lDotU>0.?1.:ma;\n    vec3 sky = mix(topCol, (bottomCol+topCol*ma), exp2(-zenith * 8.0));\n         sky += phaseMie * exp2(-zenith * 6.0);\n    \n    vec3 absorbColor = calculateSunColor(1.0 - exp2(-zenith * 2.0));\n    absorbColor = vec3(0.);\n    \n    sky = sky * mix(absorbColor * 0.9 + 0.1, vec3(1.0), sunZenith);\n\tvec3 tret = background * absorbColor + sky * sunIluminance * (1.0 - clamp(-sunZenith * 10.0, 0.0, 1.0));\t\n    return tret;\n}\nvec3 calculateSky_nb(vec3 background, float lDotU, float lDotV){\n    float phaseMie = hGPhase(lDotV, 0.8);\n    \n    float zenith = max(lDotU, 0.0);\n    \n    float sunZenith = lightDir.y;\n    const vec3 topCol = vec3(0.1, 0.34, 1.0);\n    const vec3 bottomCol = vec3(.0);\n    \n    vec3 sky = mix(topCol, (bottomCol + topCol), exp2(-zenith * 8.0));\n         sky += phaseMie * exp2(-zenith * 6.0);\n\n    vec3 absorbColor = calculateSunColor(1.0 - exp2(-zenith * 2.0));\n    absorbColor = vec3(0.0);\n    \n    sky = sky * mix(absorbColor * 0.9 + 0.1, vec3(1.0), sunZenith);\n\tvec3 tret = background * absorbColor + sky * sunIluminance * (1.0 - clamp(-sunZenith * 10.0, 0.0, 1.0));\t\n    return tret;\n}\n\n//----------------------------------------------\n\n\n\n// pathtracing functions\n//----------------------------------------------\n\n// with ConeVector better visual result\n// ConeVector distribution, look this screenshots\n// https://danilw.github.io/GLSL-howto/vulkan_sh_launcher/upl_demos/pathtracer/ray_distr1.jpg\n// https://danilw.github.io/GLSL-howto/vulkan_sh_launcher/upl_demos/pathtracer/ray_distr2.png\n#ifdef use_ConeVector\n\nmat3 calculateTangentMatrix(vec3 direction){\n\tvec3 c1 = cross(direction, vec3(0.0, 0.0, 1.0));\n\tvec3 c2 = cross(direction, vec3(0.0, 1.0, 0.0));\n    \n    vec3 tangent = dot(c1, c1) > dot(c2, c2) ? c1 : c2;\n    vec3 biDir = cross(direction, tangent);\n    \n    return mat3(tangent, biDir, direction);\n}\n\nvec3 calculateConeVector(const float i, const float angularRadius, const int steps) {\n    float x = i * 2.0 - 1.0;\n    float y = i * float(steps) * 16.0 * 16.0 * goldenAngle;\n    \n    float angle = acos(x) * radians(angularRadius) * 1./PI;\n    float c = cos(angle);\n    float s = sin(angle);\n\n    return vec3(cos(y) * s, sin(y) * s, c);\n}\n\nvec3 calculateRoughSpecular(const float i, const int steps, float roughness) {\n    float r = roughness * roughness * roughness * roughness;\n    float x = (r * i) / max(1.0 - i,0.0001);\n    float y = i * float(steps) * 16.0 * 16.0 * goldenAngle;\n    //if(1.0 - i<0.)\n    //x = (r * i)*1000.;\n    float c = inversesqrt(x + 1.0);\n    float s = sqrt(x) * c;\n\n    return vec3(cos(y) * s, sin(y) * s, c);\n}\n\n#else\n\n// CosineWeightedSample\n\nfloat seed=0.;\nfloat hash11_seed()\n{\n    float p=seed;\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    seed+=1.33;\n    return fract(p);\n}\n\nvec3 ortho(vec3 v) {\n  return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)  : vec3(0.0, -v.z, v.y);\n}\n\nvec3 getCosineWeightedSample(vec3 dir, float radius) {\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = vec2(hash11_seed(), hash11_seed());\n\tr.x = r.x * 2.0 * PI;\n\tr.y = pow(r.y, radius);\n\tfloat oneminus = sqrt(abs(1.0-r.y*r.y));\n\treturn cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir;\n}\n\n\n#endif\n//----------------------------------------------\n\n// reprojection\n//----------------------------------------------\n\nvec2 pos2uv(vec3 pos, sampler2D caminfo, vec2 ires){\n    vec3 ro_old = vec3(load(POSITION_last0,caminfo),load(POSITION_last1,caminfo),load(POSITION_last2,caminfo));\n    vec2 m_old = vec2(load(VMOUSE_last0,caminfo),load(VMOUSE_last1,caminfo))*vec2(1.,-1.);\n    vec3 td = pos - ro_old;\n    if(length(td)<0.0001)return vec2(-1.);\n    vec3 dir = normalize(td) * (rotationMatrix(m_old));\n    float fov=camera_fov;\n    float aspect = ires.x / ires.y;\n    float screenSize = (1.0 / (tan(((180.-fov)* (3.1415926 / 180.0)) / 2.0)));\n    dir.z+=0.0001*(1.-abs(sign(dir.z)));\n    return dir.xy * (.5/screenSize) / dir.z ;\n}\n\nfloat distancePixel( vec2 prevFragCoord, vec3 pos, sampler2D samplerx, vec2 ires, vec3 p_ro, vec3 p_rd){\n    if(  min(ires.xy-1., prevFragCoord) != prevFragCoord\n      || max(vec2(0.)      , prevFragCoord) != prevFragCoord) return MAX_DIST;\n    \n    float prev_d = textureLod(samplerx, prevFragCoord/ires.xy,0.).b;\n    vec3 prevPos = p_ro + p_rd*prev_d;\n    return length(prevPos-pos);\n}\n\n\n#define PixelAcceptance 1.5\n#define PixelCheckDistance .75\nvec4 previousSample(vec3 ro, vec3 pos, sampler2D caminfo, sampler2D last_pos_fbo, sampler2D last_color, vec2 ires){\n    vec2 old_halton_px_shift=vec2(load(HALTON_last0,caminfo),load(HALTON_last1,caminfo));\n    vec2 prevUv = pos2uv(pos, caminfo, ires) - old_halton_px_shift/ires.y;\n    vec2 prevFragCoord = prevUv * ires.y + ires.xy/2.0;\n    \n    vec2 pfc=vec2(0.);\n    vec2 finalpfc=vec2(0.);\n    float dist, finaldist = MAX_DIST;\n    for(int x = -1; x <= 1; x++){\n        for(int y = -1; y <= 1; y++){\n            pfc = prevFragCoord + PixelCheckDistance*vec2(x, y);\n            vec2 tuv = pfc/ires.xy * 2.0 - 1.0;\n            tuv.y *= ires.y/ires.x;\n            vec3 p_ro;\n            vec3 p_rd;\n            SetCamera_prev( tuv, caminfo, p_ro, p_rd, ires);\n            dist = distancePixel(pfc, pos, last_pos_fbo, ires, p_ro, p_rd);\n            if(dist < finaldist){\n                finalpfc = pfc;\n                finaldist = dist;\n            }\n      }\n    }\n    \n    if(finaldist < (PixelAcceptance/ires.y)*(length(pos-ro)))\n        return textureLod(last_color, finalpfc/ires.xy,0.);\n    return vec4(0.);\n}\n\n//----------------------------------------------\n\n\n\n\n\n\n// intersection template\n//----------------------------------------------\n\nstruct HitInfo {\n    float t;\n    vec3 norm;\n    vec4 color;\n    vec3 emisson;\n    float rough;\n    float metal;\n    int obj_type;\n};\n\n\nbool PlaneIntersect(vec4 Plane, vec3 ro, vec3 rd, out float t, out vec3 norm) {\n    norm=vec3(0.,1.,0.);\n    t=-1.;\n    float dd = dot(rd, Plane.xyz);\n    if (dd == 0.0) return false;\n    float t1 = -(dot(ro, Plane.xyz) + Plane.w) / dd;\n    if (t1 < 0.0) return false;\n    norm = normalize(Plane.xyz);\n    t = t1;\n    return true;\n}\n\n\nbool SphereIntersect(vec3 SpPos, float SpRad, vec3 ro, vec3 rd, out float t, out vec3 norm) {\n    ro -= SpPos;\n\n    float A = dot(rd, rd);\n    float B = 2.0*dot(ro, rd);\n    float C = dot(ro, ro)-SpRad*SpRad;\n    float D = B*B-4.0*A*C;\n    t=-1.;\n    norm=vec3(0.,1.,0.);\n    if (D < 0.0) return false;\n\n    D = sqrt(D);\n    A *= 2.0;\n    float t1 = (-B+D)/A;\n    float t2 = (-B-D)/A;\n    if (t1 < 0.0) t1 = t2;\n    if (t2 < 0.0) t2 = t1;\n    t1 = min(t1, t2);\n    if (t1 < 0.0) return false;\n    norm = ro+t1*rd;\n    t = t1;\n    norm = normalize(norm);\n    return true;\n}\n\n\n\nvoid GroundIntersectMin(vec3 ro, vec3 rd, inout bool result, inout HitInfo hit) {\n    float tnew;\n    vec3 normnew;\n    vec4 pp=vec4(0., 1., 0., 0.);\n    if (PlaneIntersect(pp, ro+vec3(0.,2.,0.), rd, tnew, normnew)) {\n        if (tnew < hit.t) {\n            hit.t = tnew;\n            hit.norm = normnew;\n            \n            hit.emisson = vec3(0.,0.,0.);\n            vec3 albedo;\n            material_OBJ_FLOOR(ro+rd*hit.t, hit.norm,  albedo, hit.emisson, hit.rough, hit.metal);\n            hit.color = vec4(albedo, 1.);\n            hit.obj_type = OBJ_FLOOR;\n            result = true;\n        }\n    }\n}\n\nvec2 hash22(vec2 p);\nfloat fix_float(float x);\nfloat get_sp(vec2 tspi){\n    float thb = hash12(tspi*1.1+2.1);\n    float thb22 = hash12(tspi*1.31+3.3);\n    ivec2 ttidx = ivec2(tspi);\n    ttidx=(ttidx+1)/2;\n    float thbr = 0.3+0.7*hash12(vec2(ttidx)*1.25+1.1);\n    thb+=max((thbr-thb)*(0.25+0.75*thb22),0.);\n    thb = min(thb,thbr);\n    return 0.0+0.9*thb*thb;\n}\nvoid SphereIntersectMin(vec3 ro, vec3 rd, inout bool result, inout HitInfo hit, int objid, vec2 tid, int ps, float hs) {\n    float tnew;\n    vec3 normnew;\n    \n    ivec2 idx = ivec2(tid);\n    vec2 ttn = 0.5*vec2(float(((idx.x+ps)%2)*2-1),float(((idx.y+ps)%2)*2-1));\n    idx=(idx+1+ps)/2;\n    \n    float th2 = hash12(vec2(idx)*1.23+fix_float(0.23+hs));\n    float th = hash12(vec2(idx.yx)*2.7+th2*133.143+fix_float(0.43+fix_float(hs*1.5)));\n    if(th<0.433)return;\n    \n    vec2 tps = (hash22(vec2(idx)*.93+fix_float(0.3+hs))-0.5)*2.;\n    float SpRad = 0.3+0.5*th2*th2;\n    tps*=1.-SpRad;\n    \n    vec3 SpPos = vec3(tid.x+0.5+ttn.x+tps.x, 0.75, tid.y+0.5+ttn.y+tps.y);\n    \n    vec2 tspi = floor(SpPos.xz);\n    vec2 tspu = (SpPos.xz-tspi-0.5)*2.;\n    SpPos.y = get_sp(tspi);\n#ifndef SPHERE_POS_LP\n    if(SpRad-length(tspu)*0.6>0.){}\n    else {SpPos.y = SpPos.y*SpPos.y;} //cheap replacement\n    SpPos.y+=0.5+SpRad;\n#else\n    SpPos.y+=0.5+SpRad;\n    // cost 30% of performance - not worth it\n    if(SpRad-length(tspu)*0.8>0.){}\n    else {\n        float tax=SpPos.y;\n        for(int i=0;i<2;i++){\n            for(int j=0;j<2;j++){\n                tax=min(tax,get_sp(tspi-sign(tspu)+vec2(float(i*2-1),float(j*2-1)))+0.5+SpRad);\n            }\n        }\n        SpPos.y = tax;\n    }\n#endif\n    \n    if (SphereIntersect(SpPos, SpRad, ro, rd, tnew, normnew)) {\n        if (tnew < hit.t) {\n            hit.t = tnew;\n            hit.norm = normnew;\n            vec3 albedo;\n            material_OBJ_SPHERE(idx, hit.norm,  albedo, hit.emisson, hit.rough, hit.metal);\n            hit.color = vec4(albedo, 1.);\n            ivec2 tidx = ivec2(tid);\n            hit.obj_type = objid+tidx.x*800+tidx.y;\n            result = true;\n        }\n    }\n}\n\nmat4 translate( vec3 t )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n                 0.0, 1.0, 0.0, 0.0,\n                 0.0, 0.0, 1.0, 0.0,\n                 t.x, t.y, t.z, 1.0 );\n}\n\nbool BoxIntersect( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad, out float tN, out vec3 norm) \n{\n\n    vec3 rdd = (txx*vec4(rd,0.0)).xyz;\n    rdd += 0.0001 * (1.0 - abs(sign(rdd)));\n    \n    vec3 roo = (txx*vec4(ro,1.0)).xyz;\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\n    norm=vec3(0.,1.,0.);\n\n    if( tN > tF || tF < 0.0) return false;\n    if(tN<MIN_DIST && tN>MAX_DIST )return false;\n\n    vec3 nor = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    //norm = (txi * vec4(nor,0.0)).xyz;\n    norm = nor;\n\n    return true;\n}\n\n\nvec2 Box_hit(vec3 ro,vec3 rd,vec3 p0,vec3 p1)\n{\n    vec3 t0 = (mix(p1, p0, step(0., rd * sign(p1 - p0))) - ro) / rd;\n    vec3 t1 = (mix(p0, p1, step(0., rd * sign(p1 - p0))) - ro) / rd;\n    return vec2(max(t0.x, max(t0.y, t0.z)),min(t1.x, min(t1.y, t1.z)));\n}\n\nvec3 boxNormal(vec3 pos,vec3 p0,vec3 p1, vec3 bsize)\n{\n    pos = pos - (p0 + p1) / 2.;\n    vec3 arp = abs(pos) / bsize;\n    return step(arp.yzx, arp) * step(arp.zxy, arp) * sign(pos);\n}\n\n\nbool BoxIntersect_min( in vec3 ro, in vec3 rd, vec3 opos, vec3 size, out float tN, out vec3 norm){\n    vec3 p = size*0.5+opos;\n    vec3 q = -size*0.5+opos;\n    vec2 b = Box_hit(ro, rd, p, q);\n    tN=MIN_DIST;\n    norm=vec3(0.,1.,0.);\n\n    if(b.x > MIN_DIST && b.x < b.y && b.x < MAX_DIST)\n    {\n        tN = b.x;\n        vec3 pos = ro + rd * tN;\n        norm = boxNormal(pos, p, q, size);\n        return true;\n    }\n    return false;\n}\n\n// box intersection, inverted faces\nbool BoxIntersect_min_inv( in vec3 ro, in vec3 rd, vec3 opos, vec3 size, out float tN, out vec3 norm){\n    vec3 p = size*0.5+opos;\n    vec3 q = -size*0.5+opos;\n    vec2 b = Box_hit(ro, rd, p, q);\n    tN=MAX_DIST;\n    norm=vec3(0.,1.,0.);\n\n    if(b.y > MIN_DIST && b.x < b.y && b.y < MAX_DIST)\n    {\n        tN = b.y;\n        vec3 pos = ro + rd * tN;\n        norm = -boxNormal(pos, p, q, size);\n        return true;\n    }\n    return false;\n}\n\n//----------------------------------------------\n\n\nvoid BoxIntersectMin_r(vec3 ro, vec3 rd, inout bool result, inout HitInfo hit, vec2 obj_id, float thbr) {\n    float tnew;\n    vec3 normnew;\n    ivec2 idx = ivec2(obj_id);\n    vec2 ttn = 0.5*vec2(float((idx.x%2)*2-1),float((idx.y%2)*2-1));\n    idx=(idx+1)/2;\n    \n    float th2 = hash12(vec2(idx)*2.3+0.33);\n    float th = hash12(vec2(idx.yx)*3.3+0.73+th2*123.123);\n    if(th<0.55)return;\n    \n    float bh = 0.2+0.5*th2*th2;\n    vec3 box = vec3(bh,.5,bh);\n    \n    vec3 opos = vec3(obj_id.x+0.5+ttn.x, thbr, obj_id.y+0.5+ttn.y);\n    //mat4 rot = rotationAxisAngle( normalize(vec3(0.0,1.0,0.0)),  angle);\n    mat4 rot = txxg;\n    mat4 tra = translate(opos);\n    mat4 txi = tra * rot; \n    mat4 txx = inverse( txi );\n    if(determinant(txi)==0.)txx=txi;\n    if (BoxIntersect(ro, rd, txx, txi, box, tnew, normnew)) {\n        if (tnew < hit.t) {\n            if(abs(normnew.y)<0.5){\n                if((ttn.y>0.&&ttn.x>0.)||(ttn.y<0.&&ttn.x<0.)){if(abs(normnew.z)>0.5)return;}\n                if((ttn.y>0.&&ttn.x<0.)||(ttn.y<0.&&ttn.x>0.)){if(abs(normnew.x)>0.5)return;}\n            }else{\n                vec2 tuv = (ro+rd*tnew-opos).xz;\n                if(sign(-tuv)!=sign(ttn))return;\n            }\n            \n            hit.t = tnew;\n            hit.norm = normnew;\n            \n            int tid = 0;\n            if(hit.norm.x>0.5)tid=0;else{\n            if(hit.norm.x<-0.5)tid=1;else{\n            if(hit.norm.y>0.5)tid=2;else{\n            if(hit.norm.y<-0.5)tid=3;else{\n            if(hit.norm.z>0.5)tid=4;else{tid=5;}}}}}\n            \n            \n            hit.norm = (txxg*vec4(hit.norm,0.0)).xyz;\n            \n            \n            int a = int(hash12(vec2(idx)*1.3+0.44)*hash12(vec2(idx.yx)*4.3+0.23)<0.24);\n            tid = OBJ_BOX_R+tid+10*a;\n            vec3 albedo;\n            material_OBJ_BOX_R(tid, hit.norm,  albedo, hit.emisson, hit.rough, hit.metal);\n            \n            hit.color = vec4(albedo,1.);\n            hit.obj_type = tid;\n            \n            result = true;\n        }\n    }\n}\n\nvoid BoxIntersectMin_minimal(vec3 ro, vec3 rd, vec3 box, vec3 opos, inout bool result, inout HitInfo hit, vec2 obj_id) {\n    float tnew;\n    vec3 normnew;\n    if(BoxIntersect_min(ro, rd, opos, box*2., tnew, normnew)){\n        if (tnew < hit.t) {\n            hit.t = tnew;\n            hit.norm = normnew;\n            \n            int tid = 0;\n            if(hit.norm.x>0.5)tid=0;else{\n            if(hit.norm.x<-0.5)tid=1;else{\n            if(hit.norm.y>0.5)tid=2;else{\n            if(hit.norm.y<-0.5)tid=3;else{\n            if(hit.norm.z>0.5)tid=4;else{tid=5;}}}}}\n            float th = hash12(obj_id*1.15+0.33)*hash12(obj_id.yx*5.+0.23);\n            int a = int(th>0.65);\n            tid = OBJ_BOX+tid+10*a;\n            vec3 albedo;\n            material_OBJ_BOX(tid, hit.norm,  albedo, hit.emisson, hit.rough, hit.metal);\n            \n            hit.color = vec4(albedo,1.);\n            hit.obj_type = tid;\n            result = true;\n        }\n    }\n}\n\nfloat heightField(vec2 uv)\n{\n    //return hash21u(uv);\n    return 0.5;\n}\n\n// ffix float precision fix, fix reflections 0.0001 main, -0.0009 refl\nbool VoxelsIntersect(int steps, float max_h, float ffix, in vec3 ro, in vec3 rd, out vec3 normal , out float tnew, out vec2 idx, out HitInfo thit) {\n    vec2 pos = floor(ro.xz);\n    rd += 0.0001 * (1.0 - abs(sign(rd)));\n    vec3 rdi = 1./rd;\n\n    vec3 rda = abs(rdi);\n    vec3 rds = sign(rd);\n    vec2 dis = (pos - ro.xz + .5 + rds.xz*.5) * rdi.xz;\n    \n    vec3 roi = rdi*(ro-vec3(.5,0.,.5));\n\n    vec2 mm = vec2(0.0);\n    for( int i=0; i<steps; i++ ) { \n        if(pos.x<0.||pos.y<0.||pos.x>800.||pos.y>800.){}\n        else\n        {\n            float thb = hash12(pos*1.1+2.1);\n            float thb22 = hash12(pos*1.31+3.3);\n            ivec2 ttidx = ivec2(pos);\n            ttidx=(ttidx+1)/2;\n            float thbr = 0.3+0.7*hash12(vec2(ttidx)*1.25+1.1);\n            thb+=max((thbr-thb)*(0.25+0.75*thb22),0.);\n            thb = min(thb,thbr);\n            vec3 box=vec3(0.5,0.5,0.5)-0.0003; //0.0003 > *0.0002 light leak in BufB/C\n            vec3 bpos=vec3(pos.x+0.5, 0.0+0.9*thb*thb, pos.y+0.5);\n            thit.t = MAX_DIST;\n            thit.obj_type = OBJ_SKY;\n            thit.norm = vec3(0.,1.,0.);\n            bool tresult = false;\n\n            BoxIntersectMin_minimal(ro, rd, box, bpos, tresult, thit, pos);\n            \n            BoxIntersectMin_r(ro, rd, tresult, thit, pos, thbr);  \n\n            {\n                float txnew=MAX_DIST;\n                vec3 normxnew;\n                bool tb = BoxIntersect_min_inv(ro, rd, bpos, vec3(0.5,0.5,0.5)*2.*vec3(1.,10.,1.), txnew, normxnew);\n                if(tb)\n                {\n                    HitInfo oth = thit;\n                    bool otr = tresult;\n                    tresult = false;\n                    SphereIntersectMin(ro, rd, tresult, thit, OBJ_SPHERE, pos, 1, 0.);\n                    if(tresult){\n                        if(thit.t>txnew)\n                        {\n                            thit=oth;\n                            tresult=otr;\n                        }\n                    }else{tresult=otr;}\n#ifdef ULTRA_WIDE_RES_LOOPS\n                    oth = thit;\n                    otr = tresult;\n                    tresult = false;\n                    SphereIntersectMin(ro, rd, tresult, thit, OBJ_SPHERE2, pos, 2, 3.123);\n                    if(tresult){\n                        if(thit.t>txnew)\n                        {\n                            thit=oth;\n                            tresult=otr;\n                        }\n                    }else{tresult=otr;}\n#endif\n                }\n            }\n\n\n            if(tresult){\n                normal=thit.norm;\n                tnew=thit.t;\n                idx = pos;\n                return true;\n            }\n        }\n        mm = step( dis.xy, dis.yx ); \n        dis += mm*rda.xz;\n        pos += mm*rds.xz;\n    }\n\n    return false;\n}\n\nvoid VoxelsIntersectMin(vec3 ro, vec3 rd, inout bool result, inout HitInfo hit, int vlp) {\n    \n    float tnew;\n    vec2 idx;\n    vec3 normnew;\n    HitInfo thit;\n    if(VoxelsIntersect(vlp, 3., 0.0001, ro, rd, normnew, tnew, idx, thit)){\n        if (tnew < hit.t) {\n            hit.obj_type = thit.obj_type;\n            hit.emisson = thit.emisson;\n            hit.rough = thit.rough;\n            hit.metal = thit.metal;\n            hit.color = thit.color;\n            result = true;\n            hit.t = tnew;\n            hit.norm = normnew;\n        }\n    }\n}\n\n\n//----------------------------------------------\n\n\nbool minDist(vec3 ro, vec3 rd, out HitInfo hit, int vlp)\n{\n    hit.t = MAX_DIST;\n    hit.obj_type = OBJ_SKY;\n    hit.norm = vec3(0.,1.,0.);\n    \n    float lDotU = dot(rd, upVec);\n    float lDotV = dot(rd, lightDir);\n    \n    hit.color=vec4(calculateSky(calculateSun(lDotV)*calculateSunColor(lightDir.y), lDotU, lDotV),1.);\n    hit.emisson = vec3(0.,0.,0.);\n    bool result = false;\n\n    VoxelsIntersectMin(ro, rd, result, hit, vlp);\n    \n    vec3 box=vec3(1.0, 1.0, 1.0);\n    vec3 bpos=vec3(0.0, 1.0, 0.0);\n    \n\n    return result;\n}\n\n//----------------------------------------------\n\n\n// palette from iq https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 get_pal(float td){\n    td = td*0.25+0.45;\n    vec3 c1 = pal( td, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n    return c1;\n}\n\n\n// noise https://www.shadertoy.com/view/7sGBzW\n// hash https://www.shadertoy.com/view/4djSRW\n\n\n// look https://www.shadertoy.com/view/4fsSRn\n// read https://arugl.medium.com/hash-noise-in-gpu-shaders-210188ac3a3e\n\n#define FIX_FRACT_HASH 1000.\n\n// change fix_float to return x;\n// https://danilw.github.io/GLSL-howto/vulkan_sh_launcher/images_bugs/l3ffzH_floats.png\n#ifdef FIX_FRACT_HASH\nfloat fix_float(float x){return sign(x)*(floor(abs(x))+floor(fract(abs(x))*FIX_FRACT_HASH)/FIX_FRACT_HASH);}\n#else\nfloat fix_float(float x){return x;}\n#endif\n\nfloat hash12(vec2 p)\n{\n#ifdef FIX_FRACT_HASH\n    p = sign(p)*(floor(abs(p))+floor(fract(abs(p))*FIX_FRACT_HASH)/FIX_FRACT_HASH);\n#endif\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash11(float p)\n{\n#ifdef FIX_FRACT_HASH\n    p = sign(p)*(floor(abs(p))+floor(fract(abs(p))*FIX_FRACT_HASH)/FIX_FRACT_HASH);\n#endif\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 hash22(vec2 p)\n{\n#ifdef FIX_FRACT_HASH\n    p = sign(p)*(floor(abs(p))+floor(fract(abs(p))*FIX_FRACT_HASH)/FIX_FRACT_HASH);\n#endif\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\n\n// saved in BufA as alpha\nfloat Bnoise(vec2 U) {\n    float v = 0.;\n    for (int k=0; k<9; k++)\n        v += hash12( U + vec2(k%3-1,k/3-1) ); \n    v=.9 *( 1.125*hash12(U)- v/8.) + .5;\n    //return clamp(v,0.,1.);\n    //return fract(abs(v));\n    return v < 0. ? -v : v > 1. ? 2.-v : v ;\n}\n\n// halton low discrepancy sequence, from https://www.shadertoy.com/view/wdXSW8\nvoid halton_loop(inout vec2 s, inout vec4 a){\n    const vec2 coprimes = vec2(2.0f, 3.0f);\n    a.xy = a.xy/coprimes;\n    a.zw += a.xy*mod(s, coprimes);\n    s = floor(s/coprimes);\n}\nvec2 halton (int index){\n    vec2 s = vec2(index, index);\n\tvec4 a = vec4(1,1,0,0);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    return a.zw;\n}\n\n\n\n// https://www.shadertoy.com/view/3ddfDj\nvec4 biplanar( sampler2D sam, in vec3 p, in vec3 n, vec3 dpdx, vec3 dpdy )\n{\n    n = abs(n);\n\n    // major axis (in x; yz are following axis)\n    ivec3 ma = (n.x>n.y && n.x>n.z) ? ivec3(0,1,2) :\n               (n.y>n.z)            ? ivec3(1,2,0) :\n                                      ivec3(2,0,1) ;\n    // minor axis (in x; yz are following axis)\n    ivec3 mi = (n.x<n.y && n.x<n.z) ? ivec3(0,1,2) :\n               (n.y<n.z)            ? ivec3(1,2,0) :\n                                      ivec3(2,0,1) ;\n        \n    // median axis (in x;  yz are following axis)\n    ivec3 me = ivec3(3) - mi - ma;\n    \n    // project+fetch\n    vec4 x = textureGrad( sam, vec2(   p[ma.y],   p[ma.z]), \n                               vec2(dpdx[ma.y],dpdx[ma.z]), \n                               vec2(dpdy[ma.y],dpdy[ma.z]) );\n    vec4 y = textureGrad( sam, vec2(   p[me.y],   p[me.z]), \n                               vec2(dpdx[me.y],dpdx[me.z]),\n                               vec2(dpdy[me.y],dpdy[me.z]) );\n    \n    // blend and return\n    vec2 m = vec2(n[ma.x],n[me.x]);\n    m = clamp( (m-0.5773)/(1.0-0.5773), 0.0, 1.0 );\n\n\treturn (x*m.x + y*m.y) / (m.x + m.y);\n}\n\nvec4 triplanar( sampler2D sam, in vec3 p, in vec3 n, vec3 dpdx, vec3 dpdy )\n{\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n    \n    vec3 m = pow( abs(n), vec3(8.0) );\n\treturn (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);\n}\n\n\n\n// https://www.shadertoy.com/view/Nls3Rn\n\n#define pack_Snormfloat3x10(x) uintBitsToFloat(packSnorm3x10(x))\n#define unpack_Snormfloat3x10(x) unpackSnorm3x10(floatBitsToUint(x))\n//#define pack_Unormfloat3x10(x) uintBitsToFloat(packSnorm3x10((x-0.5)*2.))\n//#define unpack_Unormfloat3x10(x) (unpackSnorm3x10(floatBitsToUint(x))/2.+0.5)\n\n// NOTE - Unormfloat3x10 above result noticeable \"jump\" when color~=0.5\n// Unormfloat3x10 will down/upscale 0.5+-0.001 to 0.5\n// look last few lines in BufB where pack_Unormfloat3x10 used for TAA feedback\n\n// As solution I use only >0 region of Snorm\n\n#define pack_Unormfloat3x10(x) uintBitsToFloat(packSnorm3x10(x))\n#define unpack_Unormfloat3x10(x) (unpackSnorm3x10(floatBitsToUint(x)))\n\nuint packSnorm3x10(vec3 x) {\n    x = clamp(x,-1., 1.) * 511.;\n    uvec3 sig = uvec3(mix(vec3(0), vec3(1), greaterThanEqual(sign(x),vec3(0))));\n    uvec3 mag = uvec3(abs(x));\n    uvec3 r = sig.xyz << 9 | mag.xyz;\n    return r.x << 22 | r.y << 12 | r.z << 2;\n}\n\nvec3 unpackSnorm3x10(uint x) {\n    uvec3 r = (uvec3(x) >> uvec3(22, 12, 2)) & uvec3(0x3FF);\n    uvec3 sig = r >> 9;\n    uvec3 mag = r & uvec3(0x1FF);\n    vec3 fsig = mix(vec3(-1), vec3(1), greaterThanEqual(sig, uvec3(1)));\n    vec3 fmag = vec3(mag) / 511.;\n    return fsig * fmag;\n}\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n\n// using pathtracer functions https://www.shadertoy.com/view/3dlSW7\n// using reprojection functions https://www.shadertoy.com/view/WdjcDd\n\n// BufB - pathtraced bounce lighting and AO with reprojection of last frame \n// BufB (alpha) save fogLitPercent or Albedo when #define enable_textures set in Common\n\n\n//----------------------------------------------\n\nfloat get_scene_intersect(vec3 ro, vec3 rd, vec3 norm){\n    HitInfo hit;\n    //0.002 is light leak\n    return (minDist(ro+0.0002*norm, rd, hit, VOX_LP_shd)?0.:1.);\n}\n\nfloat get_scene_bounce_light(vec3 ro, vec3 rd, vec3 innorm, out vec3 ndir, out vec3 albedo, out vec3 emission, out vec3 norm){\n    HitInfo hit;\n    bool d = minDist(ro+innorm*0.0002, rd, hit, VOX_LP_shd);\n    ndir=vec3(0.0001);\n    albedo=vec3(0.0);\n    emission=vec3(0.0);\n    norm = vec3(0.0001);\n    if(d){\n        ndir=ro+rd*hit.t;\n        albedo=hit.color.rgb;\n        emission=hit.emisson;\n        norm = hit.norm;\n    }\n    \n    return d?0.:1.;\n}\n\nvoid get_scene_material(bool d, vec3 pos, vec3 norm, int obj_id, out vec3 albedo, out vec3 emission, \n                        out float roughness, out float metalness){\n    albedo=vec3(0.0);\n    emission=vec3(0.0);\n    roughness=0.0001;\n    metalness=0.0001;\n    // pos+= objpos todo\n    if(d){\n        if(obj_id==OBJ_FLOOR)\n            material_OBJ_FLOOR(pos, norm, albedo, emission, roughness, metalness);\n        else if(obj_id>=OBJ_BOX&&obj_id<OBJ_BOX+20)material_OBJ_BOX(obj_id, norm, albedo, emission, roughness, metalness);\n        else if(obj_id>=OBJ_BOX_R&&obj_id<OBJ_BOX_R+20)material_OBJ_BOX_R(obj_id, norm, albedo, emission, roughness, metalness);\n        else if(obj_id>=OBJ_SPHERE){\n            int ax = 2*int(obj_id>=OBJ_SPHERE2)+1;\n            ivec2 tid = ivec2((obj_id-(OBJ_SPHERE*(1-ax/2)+OBJ_SPHERE2*(ax/2)))/800,(obj_id-(OBJ_SPHERE*(1-ax/2)+OBJ_SPHERE2*(ax/2)))%800);\n            ivec2 idx = ivec2(tid);\n            idx=(idx+2+ax/2)/2;\n            material_OBJ_SPHERE(idx, norm, albedo, emission, roughness, metalness);\n        }\n    }\n    \n}\n\n//----------------------------------------------\n\n\n\n\n\n// pathtracing functions\n//----------------------------------------------\n\n\n\n\nfloat calculateShadow(vec3 ro, vec3 rd, vec3 normal, float dither, int rays_shadow){\n\tfloat shadow = 0.0;\n    float rShadowRays = 1.0 / float(rays_shadow);\n    \n#ifdef use_ConeVector\n    mat3 tbl = calculateTangentMatrix(rd);\n#endif\n\tfor (int i = 0; i < rays_shadow+ANGLE_loops; ++i){\n#ifdef use_ConeVector\n        vec3 dir = tbl * calculateConeVector((float(i) + dither) * rShadowRays, sunAngularDiameter, rays_shadow);\n#else\n        vec3 dir = normalize(rd+radians(sunAngularDiameter)*getCosineWeightedSample(lightDir,0.15));\n#endif\n        float lDotN = dot(dir, normal);\n        if (lDotN <= 0.0) continue;\n        \n        lDotN = sqrt(clamp(lDotN, 0.0, 1.0));\n        \n\t\tfloat light = sunIluminance * lDotN;\n        float rayHit = get_scene_intersect(ro, dir, normal);\n\t\t\n\t\tshadow += rayHit * light;\n\t}\n    \n    return shadow * rShadowRays;\n}\n\nvec3 calculate_bouncelight_AO(vec3 ro, vec3 rd, vec3 normal, float percentSpecular, float roughness, vec3 sunColor, float noise){\t\n    vec3 AO = vec3(0.0);\n    const float rAORays = 1.0 / float(AORays);\n    \n#ifdef sunlight_2nd_bounce\n    vec3 bouncedLight = vec3(0.0);\n    vec3 abso = vec3(1.);\n#endif\n    \n#ifdef use_ConeVector\n    mat3 tbn = calculateTangentMatrix(normal);\n#endif\n\tfor (int i = 0; i < AORays+ANGLE_loops; ++i){\n#ifdef use_ConeVector\n\t\tvec3 dir = tbn * calculateConeVector((float(i) + noise) * rAORays, 90.0, AORays);\n#else\n\t\tvec3 dir = normalize(normal + 5.*getCosineWeightedSample(normal,0.5));\n#endif\n        float lDotN = dot(dir, normal);\n        if (lDotN <= 0.0) continue;\n        \n        lDotN = sqrt(clamp(lDotN, 0.0, 1.0));\n        float lDotU = dot(dir, upVec);\n        float lDotV = dot(dir, lightDir);\n        \n\t\tvec3 light = calculateSky(vec3(0.0), lDotU, lDotV) * lDotN;\n        \n#ifdef sunlight_2nd_bounce\n        vec3 bouncePos;\n        vec3 bounceNormal;\n        vec3 bouncedAlbedo;\n        vec3 bouncedEmissive;\n        float rayHit = get_scene_bounce_light(ro, dir, normal, bouncePos, bouncedAlbedo, bouncedEmissive, bounceNormal);\n        if(rayHit<0.5)\n        {\n            vec3 bouncedLighting = calculateShadow(bouncePos, lightDir, bounceNormal, noise, 2)*sunColor;\n            bouncedLighting += abso * (bouncedEmissive + bouncedAlbedo*bouncedLighting);\n            abso *= bouncedAlbedo;\n            bouncedLight += bouncedLighting * (1.0 - rayHit) * lDotN;\n        }\n#else\n        float rayHit = get_scene_intersect(ro, dir, normal);\n#endif\n\t\tAO += rayHit * light;\n\t}\n    \n    AO = AO * rAORays * 2./PI;\n#ifdef sunlight_2nd_bounce\n    bouncedLight = bouncedLight * rAORays;\n    AO+=bouncedLight;\n#endif\n    \n\treturn AO;\n}\n\n//----------------------------------------------\n\n// volume\n//----------------------------------------------\n#ifdef enable_volume\nfloat raymarchVolume(vec3 ro, vec3 rd, float noise){\n    const float rSteps = 1.0 / float(volumeSteps);\n    \n    vec3 start = vec3(0.0);\n    vec3 end = ro;\n    float endDepth = length(end);\n    end /= max(endDepth,0.0001);\n    endDepth = min(length(ro), MAX_DIST);\n    end *= endDepth;\n    \n    vec3 increment = (end - start) * rSteps;\n    vec3 rayPosition = noise * increment + start;\n    \n    float fogLitPercent = 0.0f;\n    for (int i = 0; i < volumeSteps+ANGLE_loops; i++){\n        float volumetricShadow = get_scene_intersect(rayPosition + rd, lightDir, rayPosition + rd);\n        fogLitPercent = mix(fogLitPercent, volumetricShadow, 1.0 / float(i+1));\n        rayPosition +=  increment;\n     }\n    return fogLitPercent;\n}\n#endif\n//----------------------------------------------\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n#ifndef use_ConeVector\n    seed = hash12(fragCoord.xy+hash21(float(iFrame%10000)*0.333)*1234.123);\n#endif\n    vec2 fc=fragCoord.xy;\n    vec2 halton_px_shift = vec2(load(HALTON0,iChannel0),load(HALTON1,iChannel0));\n    fragCoord.xy += halton_px_shift;\n\n    vec2 screen_uv = fc.xy / iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    vec3 ro;\n    vec3 rd;\n    SetCamera(uv, iChannel0, ro, rd, iResolution.xy);\n    \n    float noise=0.; \n    \n#ifdef use_ConeVector\n    // noise for ConeVector\n    \n    ivec2 ipx = ivec2(fc);\n    ivec2 reserv = ivec2(5,MEMORY_BOUNDARY.y+5);\n    ipx=ipx%(ivec2(textureSize(iChannel0,0).xy)-reserv);\n    float n0 = texelFetch(iChannel0, textureSize(iChannel0,0).xy-ipx-1, 0).a;\n    noise = fract(n0 + 0.75*float(iFrame % 264) * c_goldenRatioConjugate);\n\n    // test hash12 as noise\n    //vec2 tfc = fc.xy+hash21(float(iFrame%10000)*0.333)*iResolution.y*2.;\n    //noise = hash12(tfc);\n    \n#endif\n\n    vec2 this_id_d = texelFetch(iChannel0, ivec2(fc), 0).xy;\n    int obj_id = int(this_id_d.x);\n    vec3 pos=ro+rd*this_id_d.y;\n    bool rayHit = obj_id>0;\n    vec3 normal;\n    vec3 albedo;\n    vec3 emission;\n    float rough;\n    float metal;\n    \n \n    if(obj_id==OBJ_FLOOR)normal=get_normal_OBJ_FLOOR(pos);\n    if(obj_id>=OBJ_SPHERE){\n        int ax = 2*int(obj_id>=OBJ_SPHERE2)+1;\n        ivec2 tid = ivec2((obj_id-(OBJ_SPHERE*(1-ax/2)+OBJ_SPHERE2*(ax/2)))/800,(obj_id-(OBJ_SPHERE*(1-ax/2)+OBJ_SPHERE2*(ax/2)))%800);\n\n        ivec2 idx = ivec2(tid);\n        float tis = ((1-ax/2)==0?3.123:0.);\n        vec2 ttn = 0.5*vec2(float(((idx.x+1+ax/2)%2)*2-1),float(((idx.y+1+ax/2)%2)*2-1));\n        idx=(idx+2+ax/2)/2;\n        float th2 = hash12(vec2(idx)*1.23+fix_float(0.23+tis));\n        float th = hash12(vec2(idx.yx)*2.7+th2*133.143+fix_float(0.43+fix_float(tis*1.5)));\n\n        vec2 tps = (hash22(vec2(idx)*.93+fix_float(0.3+tis))-0.5)*2.;\n        float SpRad = 0.3+0.5*th2*th2;\n        tps*=1.-SpRad;\n        vec3 SpPos = vec3(float(tid.x)+0.5+ttn.x+tps.x, 0.75, float(tid.y)+0.5+ttn.y+tps.y);\n        vec2 tspi = floor(SpPos.xz);\n        vec2 tspu = (SpPos.xz-tspi-0.5)*2.;\n        SpPos.y = get_sp(tspi);\n#ifndef SPHERE_POS_LP\n        if(SpRad-length(tspu)*0.6>0.){}\n        else {SpPos.y = SpPos.y*SpPos.y;} //cheap replacement\n        SpPos.y+=0.5+SpRad;\n#else\n        SpPos.y+=0.5+SpRad;\n        if(SpRad-length(tspu)*0.8>0.){}\n        else {\n            float tax=SpPos.y;\n            for(int i=0;i<2;i++){\n                for(int j=0;j<2;j++){\n                    tax=min(tax,get_sp(tspi-sign(tspu)+vec2(float(i*2-1),float(j*2-1)))+0.5+SpRad);\n                }\n            }\n            SpPos.y = tax;\n        }\n#endif\n        normal=get_normal_OBJ_SPHERE(pos-SpPos);\n    }\n    if(obj_id>=OBJ_BOX&&obj_id<OBJ_BOX+20)normal=get_normal_OBJ_FBOX(obj_id);\n    if(obj_id>=OBJ_BOX_R&&obj_id<OBJ_BOX_R+20)normal=get_normal_OBJ_RBOX(obj_id);\n    \n    get_scene_material(rayHit, pos, normal, obj_id, albedo, emission, rough, metal);\n    \n    vec3 sunColor = calculateSunColor(lightDir.y);\n\tvec3 color_light_AO = calculate_bouncelight_AO(pos, rd, normal, metal, rough, sunColor, noise);\n    vec3 shadow = calculateShadow(pos, lightDir, normal, noise, shadowRays)*sunColor;\n    vec3 color = mix(color_light_AO+shadow,vec3(0.),dot(emission,vec3(1.))/3.);\n    //fragColor = vec4(color,1.);\n    //return;\n    color = mix(albedo*color, emission, dot(emission,vec3(1.))/3.);\n    float lDotU = dot(rd, upVec);\n    float lDotV = dot(rd, lightDir);\n    if (!rayHit) \n    {\n        color=vec3(0.);\n        color = calculateSun(lDotV)*calculateSunColor(lightDir.y);\n        color = calculateSky(color, lDotU, lDotV);\n    }\n    \n    float fogLitPercent = 0.;\n#ifdef enable_textures\n    fogLitPercent = pack_Unormfloat3x10(triplanar( iChannel3, pos, normal, dFdx(pos), dFdy(pos) ).rgb);\n    // avoiding dfd bugs\n    if(obj_id==OBJ_SKY)fogLitPercent=pack_Unormfloat3x10(vec3(1.));\n#else\n#ifdef enable_volume\n    #ifdef use_ConeVector\n    fogLitPercent = raymarchVolume(pos - ro, ro, noise);\n    #else\n    fogLitPercent = raymarchVolume(pos - ro, ro, hash11_seed());\n    #endif\n#endif\n#endif\n    \n    color = max(color, vec3(0.0));\n    //vec3 sky_c = calculateSky_nb(calculateSun(lDotV)*calculateSunColor(lightDir.y), lDotU, lDotV);\n    //vec2 tpd = abs((this_id_d.y*rd.xz)*MD(3.1415926/4.));\n    //color =mix(color, sky_c, smoothstep(float(VOX_LP)*0.5, float(VOX_LP)*0.6, max(tpd.x,tpd.y)));\n\n    bool input_registered = load(INPUT0,iChannel0)>1.;\n    fragColor = vec4(color, fogLitPercent);\n    //protection when camera go inside of shape and intersection function may return inf or nan\n    fragColor=clamp(fragColor,0.,100.); \n#ifdef enable_textures\n    fragColor.a = fogLitPercent;\n#endif\n#ifdef use_reproject_TAA\n    // reprojection TAA\n    bool res_ch = load(RES_CHANGE,iChannel0)<0.5;\n    if(input_registered||res_ch){\n        vec4 oldCol = previousSample(ro, pos,iChannel0, iChannel0, iChannel1, iResolution.xy);\n        float factor = (oldCol.a == 0.||res_ch) ? 0. : .95;\n        fragColor.rgb = mix(fragColor.rgb, oldCol.rgb, factor);\n#ifndef enable_textures\n        fragColor.a = mix(fragColor.a, oldCol.a, factor*0.75); \n#endif\n        //fragColor.a=fogLitPercent; // to disable reproj for volumtertic shadow\n    }else\n#endif\n    // default TAA\n    {\n        vec4 backColor = texelFetch(iChannel1, ivec2(fc),0);\n        float iot = smoothstep(5.5,12.5,load(INPUT0_timer, iChannel0));\n        fragColor.rgb = mix(fragColor.rgb, backColor.rgb, (0.95+0.048*iot) * (1.-float(input_registered)));\n#ifndef enable_textures\n        fragColor.a = mix(fragColor.a, backColor.a, (0.95+0.048*iot) * (1.-float(input_registered)));\n#else\n        fragColor.a = pack_Unormfloat3x10(mix(unpack_Unormfloat3x10(fragColor.a), unpack_Unormfloat3x10(backColor.a), (0.95+0.048*iot) * (1.-float(input_registered))));\n#endif\n        \n    }\n#ifndef enable_textures\n    fragColor.a=max(fragColor.a,0.00001); // reprojection flag for previousSample in Comon, it return alpha 0. when no reprojection\n#endif\n\n}\n\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n\n// using https://www.shadertoy.com/view/3dlSW7\n// using https://www.shadertoy.com/view/WdjcDd\n\n// fragColor = vec4(color, absorb); // absorb for volumetric, volumetric rendered in Image\n\n//----------------------------------------------\n\n\nfloat get_scene_intersect(vec3 ro, vec3 rd, vec3 norm){\n    HitInfo hit;\n    //0.002 is light leak\n    return (minDist(ro+0.0002*norm, rd, hit, VOX_LP_shd)?0.:1.);\n}\n\nfloat get_scene_bounce_light(vec3 ro, vec3 rd, vec3 innorm, out vec3 ndir, out vec3 albedo, out vec3 emission, out vec3 norm){\n    HitInfo hit;\n    bool d = minDist(ro+innorm*0.0002, rd, hit, VOX_LP_shd);\n    ndir=vec3(0.0001);\n    albedo=vec3(0.0);\n    emission=vec3(0.0);\n    norm = vec3(0.0001);\n    if(d){\n        ndir=ro+rd*hit.t;\n        albedo=hit.color.rgb;\n        emission=hit.emisson;\n        norm = hit.norm;\n    }\n    \n    return d?0.:1.;\n}\n\nvoid get_scene_material(bool d, vec3 pos, vec3 norm, int obj_id, out vec3 albedo, out vec3 emission, \n                        out float roughness, out float metalness){\n    albedo=vec3(0.0);\n    emission=vec3(0.0);\n    roughness=0.0001;\n    metalness=0.0001;\n    // pos+= objpos todo\n    if(d){\n        if(obj_id==OBJ_FLOOR)\n            material_OBJ_FLOOR(pos, norm, albedo, emission, roughness, metalness);\n        else if(obj_id>=OBJ_BOX&&obj_id<OBJ_BOX+20)material_OBJ_BOX(obj_id, norm, albedo, emission, roughness, metalness);\n        else if(obj_id>=OBJ_BOX_R&&obj_id<OBJ_BOX_R+20)material_OBJ_BOX_R(obj_id, norm, albedo, emission, roughness, metalness);\n        else if(obj_id>=OBJ_SPHERE){\n            int ax = 2*int(obj_id>=OBJ_SPHERE2)+1;\n            ivec2 tid = ivec2((obj_id-(OBJ_SPHERE*(1-ax/2)+OBJ_SPHERE2*(ax/2)))/800,(obj_id-(OBJ_SPHERE*(1-ax/2)+OBJ_SPHERE2*(ax/2)))%800);\n            ivec2 idx = ivec2(tid);\n            idx=(idx+2+ax/2)/2;\n            material_OBJ_SPHERE(idx, norm, albedo, emission, roughness, metalness);\n        }\n    }\n    \n}\n\n//----------------------------------------------\n\n\n\n\n\n// pathtracing functions\n//----------------------------------------------\n\nfloat calculateFresnel(float cosTheta, float f0){\n    cosTheta = 1.0 - cosTheta;\n\tcosTheta = cosTheta * cosTheta * cosTheta * cosTheta * cosTheta;\n    \n    return cosTheta * (1.0 - f0) + f0;\n}\n\n#ifdef enable_reflections\nvec3 calculateReflection(vec3 ro, vec3 rd, vec3 normal, float percentSpecular, float roughness, vec3 totalLighting, float noise){\t\n#ifdef use_ConeVector\n    mat3 tbn = calculateTangentMatrix(normal);\n#endif\n    vec3 reflection = vec3(0.0);\n    float rReflectionRays = 1.0 / float(reflectionRays);\n    float fresnel = 0.0;\n    for (int i = 0; i < reflectionRays+ANGLE_loops; ++i){\n#ifdef use_ConeVector\n        vec3 dir = tbn * calculateRoughSpecular(fract((float(i) + noise) * rReflectionRays), reflectionRays, roughness);\n#else\n        vec3 dir = normalize(normal + 3.5*roughness*roughness*getCosineWeightedSample(normal,0.1+0.4*roughness));\n#endif\n\n        dir = reflect(rd, dir);\n        float lDotN = dot(dir, normal);\n        float f = lDotN;\n        if (lDotN <= 0.0) continue;\n\n        float lDotU = dot(dir, upVec);\n        float lDotV = dot(dir, lightDir);\n\n        fresnel += calculateFresnel(f, percentSpecular);\n\n        vec3 light = calculateSky(vec3(0.0), lDotU, lDotV);\n        \n#ifdef reflection_color_emi\n        vec3 bouncePos;\n        vec3 bounceNormal;\n        vec3 bouncedAlbedo;\n        vec3 bouncedEmissive;\n        float rayHit = get_scene_bounce_light(ro, dir, normal, bouncePos, bouncedAlbedo, bouncedEmissive, bounceNormal);\n        reflection += rayHit * light;\n        reflection += (1.-rayHit) * bouncedEmissive;\n#else\n        float rayHit = get_scene_intersect(ro, dir, normal);\n        reflection += rayHit * light;\n#endif\n    }\n    \n    reflection = reflection * rReflectionRays;\n    fresnel = fresnel * rReflectionRays;\n\n    totalLighting = mix(totalLighting, reflection, fresnel);\n\t\n\treturn totalLighting;\n}\n#endif\n//----------------------------------------------\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n#ifndef use_ConeVector\n    seed = hash12(fragCoord.xy+hash21(float(iFrame%10000)*0.333)*1234.123);\n#endif\n    vec2 fc=fragCoord.xy;\n    vec2 halton_px_shift = vec2(load(HALTON0,iChannel0),load(HALTON1,iChannel0));\n    fragCoord.xy += halton_px_shift;\n\n    vec2 screen_uv = fc.xy / iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    vec3 ro;\n    vec3 rd;\n    SetCamera(uv, iChannel0, ro, rd, iResolution.xy);\n    \n    \n    float noise=0.; \n    \n#ifdef use_ConeVector\n    // noise for ConeVector\n    \n    ivec2 ipx = ivec2(fc);\n    ivec2 reserv = ivec2(5,MEMORY_BOUNDARY.y+5);\n    ipx=ipx%(ivec2(textureSize(iChannel0,0).xy)-reserv);\n    float n0 = texelFetch(iChannel0, textureSize(iChannel0,0).xy-ipx-1, 0).a;\n    noise = fract(n0 + 0.75*float(iFrame % 264) * c_goldenRatioConjugate);\n\n    // test hash12 as noise\n    //vec2 tfc = fc.xy+hash21(float(iFrame%10000)*0.333)*iResolution.y*2.;\n    //noise = hash12(tfc);\n    \n#endif\n\n    vec2 this_id_d = texelFetch(iChannel0, ivec2(fc), 0).xy;\n    int obj_id = int(this_id_d.x);\n    vec3 pos=ro+rd*this_id_d.y;\n    \n    bool rayHit = obj_id>0;\n    vec3 normal;\n    vec3 albedo;\n    vec3 emission;\n    float rough;\n    float metal;\n    \n    if(obj_id==OBJ_FLOOR)normal=get_normal_OBJ_FLOOR(pos);\n    if(obj_id>=OBJ_SPHERE){\n        int ax = 2*int(obj_id>=OBJ_SPHERE2)+1;\n        ivec2 tid = ivec2((obj_id-(OBJ_SPHERE*(1-ax/2)+OBJ_SPHERE2*(ax/2)))/800,(obj_id-(OBJ_SPHERE*(1-ax/2)+OBJ_SPHERE2*(ax/2)))%800);\n\n        ivec2 idx = ivec2(tid);\n        float tis = ((1-ax/2)==0?3.123:0.);\n        vec2 ttn = 0.5*vec2(float(((idx.x+1+ax/2)%2)*2-1),float(((idx.y+1+ax/2)%2)*2-1));\n        idx=(idx+2+ax/2)/2;\n        float th2 = hash12(vec2(idx)*1.23+fix_float(0.23+tis));\n        float th = hash12(vec2(idx.yx)*2.7+th2*133.143+fix_float(0.43+fix_float(tis*1.5)));\n\n        vec2 tps = (hash22(vec2(idx)*.93+fix_float(0.3+tis))-0.5)*2.;\n        float SpRad = 0.3+0.5*th2*th2;\n        tps*=1.-SpRad;\n        vec3 SpPos = vec3(float(tid.x)+0.5+ttn.x+tps.x, 0.75, float(tid.y)+0.5+ttn.y+tps.y);\n        vec2 tspi = floor(SpPos.xz);\n        vec2 tspu = (SpPos.xz-tspi-0.5)*2.;\n        SpPos.y = get_sp(tspi);\n#ifndef SPHERE_POS_LP\n        if(SpRad-length(tspu)*0.6>0.){}\n        else {SpPos.y = SpPos.y*SpPos.y;} //cheap replacement\n        SpPos.y+=0.5+SpRad;\n#else\n        SpPos.y+=0.5+SpRad;\n        if(SpRad-length(tspu)*0.8>0.){}\n        else {\n            float tax=SpPos.y;\n            for(int i=0;i<2;i++){\n                for(int j=0;j<2;j++){\n                    tax=min(tax,get_sp(tspi-sign(tspu)+vec2(float(i*2-1),float(j*2-1)))+0.5+SpRad);\n                }\n            }\n            SpPos.y = tax;\n        }\n#endif\n        normal=get_normal_OBJ_SPHERE(pos-SpPos);\n    }\n    if(obj_id>=OBJ_BOX&&obj_id<OBJ_BOX+20)normal=get_normal_OBJ_FBOX(obj_id);\n    if(obj_id>=OBJ_BOX_R&&obj_id<OBJ_BOX_R+20)normal=get_normal_OBJ_RBOX(obj_id);\n    \n    \n    get_scene_material(rayHit, pos, normal, obj_id, albedo, emission, rough, metal);\n    \n    vec3 sunColor = calculateSunColor(lightDir.y);\n    vec3 color = texelFetch(iChannel1, ivec2(fc), 0).rgb;\n#ifdef enable_reflections\n    color = calculateReflection(pos, rd, normal, metal, rough, color, noise);\n#endif\n    \n\tfloat lDotU = dot(rd, upVec);\n\tfloat lDotV = dot(rd, lightDir);\n\t\n    if (!rayHit) \n    {\n        color = vec3(0.0);\n        color += calculateSun(lDotV)*calculateSunColor(lightDir.y);\n        color = calculateSky(color, lDotU, lDotV);\n    }\n    float absorb = 0.;\n    \n#ifdef enable_textures\n    absorb = texelFetch(iChannel1, ivec2(fc), 0).a;\n#else\n#ifdef enable_volume\n    float depth = length(ro-pos);\n    absorb = exp(-depth * volume_fogDensity);\n    absorb = clamp(absorb,.25,1.);\n    absorb = 1.-(1.-smoothstep(MAX_DIST-MAX_DIST*0.1,MAX_DIST,depth))*(1.-absorb);\n    vec2 tpdl = abs((this_id_d.y*rd.xz)*MD(3.1415926/4.));\n    absorb=mix(absorb,1.,smoothstep(float(VOX_LP)*0.5, float(VOX_LP)*0.6, max(tpdl.x,tpdl.y)));\n#endif\n#endif\n    \n    color = max(color, vec3(0.0));\n    vec3 sky_c = calculateSky_nb(calculateSun(lDotV)*calculateSunColor(lightDir.y), lDotU, lDotV);\n    vec2 tpd = abs((this_id_d.y*rd.xz)*MD(3.1415926/4.));\n    color =mix(color, sky_c, smoothstep(float(VOX_LP)*0.5, float(VOX_LP)*0.6, max(tpd.x,tpd.y)));\n\n    bool input_registered = load(INPUT0,iChannel0)>1.;\n    fragColor = vec4(color, absorb);\n    //protection when camera go inside of shape and intersection function may return inf or nan\n    fragColor.rgb=clamp(fragColor.rgb,0.,100.); \n#ifdef use_reproject_TAA\n    // reprojection TAA\n    bool res_ch = load(RES_CHANGE,iChannel0)<0.5;\n    if(input_registered||res_ch){\n        vec4 oldCol = previousSample(ro, pos,iChannel0, iChannel0, iChannel2, iResolution.xy);\n        float factor = (oldCol.a == 0.||res_ch) ? 0. : .90;\n        fragColor.rgb = mix(fragColor.rgb, oldCol.rgb, factor);\n#ifndef enable_textures\n        fragColor.a = mix(fragColor.a, oldCol.a, factor*0.75); \n#endif\n        //fragColor.a=absorb; // to disable reproj for volumtertic shadow\n    }else\n#endif\n    // default TAA\n    {\n        vec4 backColor = texture(iChannel2, screen_uv);\n        float iot = smoothstep(5.5,12.5,load(INPUT0_timer, iChannel0));\n        fragColor.rgb = mix(fragColor.rgb, backColor.rgb, (0.905+0.08*iot) * (1.-float(input_registered)));\n#ifndef enable_textures\n        fragColor.a = mix(fragColor.a, backColor.a, (0.905+0.08*iot) * (1.-float(input_registered)));\n#else\n        fragColor.a = fragColor.a; //copy BufB texture color\n#endif\n    }\n#ifndef enable_textures\n    fragColor.a=max(fragColor.a,0.00001); // reprojection flag for previousSample in Comon, it return alpha 0. when no reprojection\n#endif\n\n}\n\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\n#ifndef use_dynamic_TAA\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    discard;\n}\n#else\n\n// from https://www.shadertoy.com/view/DsfGWX\n\n#define ENABLE_TAA\n#define TEMPORAL_REPROJECT\n\n#define VARIANCE_CLIPPING\n\n// debug\n//#define SHOW_MOTION\n//#define SHOW_DISOCCLUSION\n\n// TAA\n// alpha of this shader is unused, it used to store curr_d but hist.a used only in SHOW_DISOCCLUSION\n// when define enable_volume set - this Alpha used to filter absorb from BufC - so debug wont work here\n\n#define EPS 1e-4\n\n\n\n#define OFFSET_COUNT 4\n\nconst ivec2 off[OFFSET_COUNT] = ivec2[OFFSET_COUNT](\n \tivec2( 1,  0), ivec2( 0, -1), \n\tivec2( 0,  1), ivec2(-1,  0)\n);\n/*\n#define OFFSET_COUNT 8\n\nconst ivec2 off[OFFSET_COUNT] = ivec2[OFFSET_COUNT](\n    ivec2(-1, -1), ivec2(-1,  1), \n\tivec2( 1, -1), ivec2( 1,  1), \n\tivec2( 1,  0), ivec2( 0, -1), \n\tivec2( 0,  1), ivec2(-1,  0)\n);\n*/\n\n\nvec3 rgb2ycocg(in vec3 rgb)\n{\nreturn rgb;\n    float co = rgb.r - rgb.b;\n    float t = rgb.b + co / 2.0;\n    float cg = rgb.g - t;\n    float y = t + cg / 2.0;\n    return vec3(y, co, cg);\n}\n\n\nvec3 ycocg2rgb(in vec3 ycocg)\n{\nreturn ycocg;\n    float t = ycocg.r - ycocg.b / 2.0;\n    float g = ycocg.b + t;\n    float b = t - ycocg.g / 2.0;\n    float r = ycocg.g + b;\n    return vec3(r, g, b);\n}\n\nvec3 RGBtoYCoCg(vec3 c)\n{\nreturn c;\n    //return rgb2ycocg(c);\n    return mat3(0.25, 0.5, -0.25, 0.5, 0, 0.5, 0.25, -0.5, -0.25) * c;\n}\n\nvec3 YCoCgToRGB(vec3 c)\n{\nreturn c;\n    //return ycocg2rgb(c);\n    return mat3(1, 1, 1, 1, 0, -1, -1, 1, -1) * c;\n}\n\nvec4 clipToAABB(in vec4 cOld, in vec4 cNew, in vec4 center, in vec4 halfSize)\n{\n    vec4 r = cOld - cNew;\n    vec4 m = (center + halfSize) - cNew;\n    vec4 n = (center - halfSize) - cNew;\n    \n    if (r.x > m.x + EPS)\n\t\tr *= (m.x / r.x);\n\tif (r.y > m.y + EPS)\n\t\tr *= (m.y / r.y);\n\tif (r.z > m.z + EPS)\n\t\tr *= (m.z / r.z);\n    if (r.w > m.w + EPS)\n\t\tr.w *= (m.w / r.w);\n\n\tif (r.x < n.x - EPS)\n\t\tr *= (n.x / r.x);\n\tif (r.y < n.y - EPS)\n\t\tr *= (n.y / r.y);\n\tif (r.z < n.z - EPS)\n\t\tr *= (n.z / r.z);\n    if (r.w < n.w - EPS)\n\t\tr.w *= (n.w / r.w);\n\n\treturn cNew + r;\n}\n\nvec4 SampleTextureCatmullRom(sampler2D tex, vec2 texSize, vec2 uv)\n{\n    vec2 samplePos = uv * texSize;\n    vec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n\n    vec2 f = samplePos - texPos1;\n\n    vec2 w0 = f * ( -0.5 + f * (1.0 - 0.5*f));\n    vec2 w1 = 1.0 + f * f * (-2.5 + 1.5*f);\n    vec2 w2 = f * ( 0.5 + f * (2.0 - 1.5*f) );\n    vec2 w3 = f * f * (-0.5 + 0.5 * f);\n    \n    vec2 w12 = w1 + w2;\n    vec2 offset12 = w2 / w12;\n\n    vec2 texPos0 = texPos1 - vec2(1.0);\n    vec2 texPos3 = texPos1 + vec2(2.0);\n    vec2 texPos12 = texPos1 + offset12;\n\n    texPos0 /= texSize;\n    texPos3 /= texSize;\n    texPos12 /= texSize;\n\n    vec4 result = vec4(0.0);\n    result += textureLod(tex, vec2(texPos0.x,  texPos0.y), 0.) * w0.x * w0.y;\n    result += textureLod(tex, vec2(texPos12.x, texPos0.y), 0.) * w12.x * w0.y;\n    result += textureLod(tex, vec2(texPos3.x,  texPos0.y), 0.) * w3.x * w0.y;\n\n    result += textureLod(tex, vec2(texPos0.x,  texPos12.y), 0.) * w0.x * w12.y;\n    result += textureLod(tex, vec2(texPos12.x, texPos12.y), 0.) * w12.x * w12.y;\n    result += textureLod(tex, vec2(texPos3.x,  texPos12.y), 0.) * w3.x * w12.y;\n\n    result += textureLod(tex, vec2(texPos0.x,  texPos3.y), 0.) * w0.x * w3.y;\n    result += textureLod(tex, vec2(texPos12.x, texPos3.y), 0.) * w12.x * w3.y;\n    result += textureLod(tex, vec2(texPos3.x,  texPos3.y), 0.) * w3.x * w3.y;\n\n    return result;\n}\n\nfloat distancePixel22( vec2 prevFragCoord, vec3 pos, sampler2D samplerx, vec2 ires, vec3 p_ro, vec3 p_rd){\n    if(  min(ires.xy-1., prevFragCoord) != prevFragCoord\n      || max(vec2(0.)      , prevFragCoord) != prevFragCoord) return MAX_DIST;\n    \n    float prev_d = textureLod(samplerx, prevFragCoord/ires.xy,0.).a;\n    vec3 prevPos = p_ro + p_rd*prev_d;\n    return length(prevPos-pos);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float a = .1;\n    \n    ivec2 ipx = ivec2(fragCoord);\n    \n    // adding halton_px_shift to fragCoord not needed\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    vec2 halton_px_shift = vec2(load(HALTON0,iChannel0),load(HALTON1,iChannel0));\n    float curr_d = textureLod(iChannel0, (fragCoord - halton_px_shift) / iResolution.xy, 0.).y;\n    vec4 curr_color = textureLod(iChannel2, (fragCoord - halton_px_shift) / iResolution.xy, 0.).rgba;\n    vec3 curr_texture_col = vec3(1.);\n    \n#ifdef enable_textures\n    //texelFetch because data packed\n    curr_texture_col = unpack_Unormfloat3x10(texelFetch(iChannel2, ivec2(fragCoord - halton_px_shift), 0).a);\n#endif\n    vec4 new = vec4(RGBtoYCoCg(curr_color.rgb*curr_texture_col),curr_color.a);\n\n#ifdef TEMPORAL_REPROJECT\n\n    vec3 ro;\n    vec3 rd;\n    SetCamera(uv, iChannel0, ro, rd, iResolution.xy);\n    \n    vec3 pro;\n    vec3 prd;\n    SetCamera_prev(uv, iChannel0, pro, prd, iResolution.xy);\n    \n    vec3 pos = ro + rd * curr_d;\n    \n    // adding prevUv to fragCoord not needed\n    vec2 prevUv = pos2uv(pos, iChannel0, iResolution.xy);\n    vec2 prevFragCoord = prevUv * iResolution.y + iResolution.xy/2.0;\n    vec2 puv = prevFragCoord/iResolution.xy;\n    \n    \n    //vec4 hist = texture(iChannel3, puv);\n    //vec4 hist = getTextureSmooth(iChannel3, iResolution.xy, puv);\n    vec4 hist = SampleTextureCatmullRom(iChannel3, iResolution.xy, puv);\n\n    vec4 old = vec4(RGBtoYCoCg(hist.rgb),hist.a);\n#else\n    ivec2 sp = ivec2(fragCoord);\n    vec4 old = vec4(RGBtoYCoCg(texelFetch(iChannel3, sp, 0).rgb),texelFetch(iChannel3, sp, 0).a);\n#endif\n\n#ifdef VARIANCE_CLIPPING\n    vec4 avg = new;\n    vec4 var = new * new;\n    \n    for (int i = 0; i < OFFSET_COUNT; i++)\n    {\n        vec4 tex_data = texelFetch(iChannel2, ipx + off[i], 0);\n        vec3 tex_color = vec3(1.);\n#ifdef enable_textures\n        tex_color = unpack_Unormfloat3x10(tex_data.a);\n#endif\n        vec4 tex = vec4(RGBtoYCoCg(tex_data.rgb*tex_color),tex_data.a);\n        \n        avg += tex;\n        var += tex * tex;\n    }\n    avg /= float(OFFSET_COUNT + 1);\n    var /= float(OFFSET_COUNT + 1);\n\n    vec4 sig = sqrt(max(var - avg * avg, vec4(0)));\n    \n    const float g = 1.;\n    vec4 cmin = avg - sig * g;\n    vec4 cmax = avg + sig * g;\n    \n    #if 0\n    vec4 clip = clamp(old, cmin, cmax);\n    #else\n    vec4 clip = clipToAABB(old, clamp(avg, cmin, cmax), avg, sig);\n    #endif\n    \n    old = mix(old, clip, 1.);\n#endif\n    bool res_ch = load(RES_CHANGE,iChannel0)<0.5;\n    vec4 col = iFrame != 0 && !res_ch ? mix(old, new, a) : new;\n#ifdef ENABLE_TAA\n#ifdef enable_volume\n    fragColor = vec4(YCoCgToRGB(col.rgb), col.a);\n#else\n    fragColor = vec4(YCoCgToRGB(col.rgb), curr_d);\n#endif\n    float iot = smoothstep(1.5,4.5,load(INPUT0_timer, iChannel0));\n    if(iot>0.001){\n        curr_color = textureLod(iChannel2, fragCoord / iResolution.xy, 0.).rgba;\n        curr_texture_col = vec3(1.);\n    #ifdef enable_textures\n        //texelFetch because data packed\n        curr_texture_col = unpack_Unormfloat3x10(texelFetch(iChannel2, ivec2(fragCoord), 0).a);\n    #endif\n        fragColor.rgb = mix(fragColor.rgb,curr_color.rgb*curr_texture_col,iot);\n    }\n#else\n    fragColor = vec4(texelFetch(iChannel2, ivec2(fragCoord), 0).rgb, curr_d);\n#endif\n\n\n#ifdef SHOW_DISOCCLUSION\n\n    if (puv.x < 0. || puv.x >= 1. || puv.y < 0. || puv.y >= 1. ||\n        distance(pos, (pro+prd*hist.a)) > 2.*0.1*curr_d)\n    {\n        fragColor = vec4(1, 0, 0, curr_d);\n    }\n#endif\n\n#ifdef SHOW_MOTION\n    fragColor = vec4((fragCoord/iResolution.xy - puv) * 50., 0, curr_d);\n#endif\n    fragColor.rgb=clamp(fragColor.rgb,0.,100.); // seems color can be little negative\n}\n#endif","name":"Buffer D","description":"","type":"buffer"}]}