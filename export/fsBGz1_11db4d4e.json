{"ver":"0.1","info":{"id":"fsBGz1","date":"1616914602","viewed":263,"name":"Atmosphere Scattering Shader","username":"playbyan1453","description":"Sky texture modified with rayleigh and mie scattering, this is forked shader. The original one was 2D version of this. Shold be great because now it actually has sun angle, math of the sun itself gave me headaches.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["scattering","rayleigh","tonemap","scatter","mie","robobo1221"],"hasliked":0,"parentid":"4llfDS","parentname":"Another atmosphere i made"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code Witten By robobo1221\n// Got it working on 3D space\n#define rayleighCoeff vec3(0.27, 0.5, 1.0)\n#define mieCoeff 0.1\n#define pi 3.14159265358979\n// 0.545 degrees by default.\n#define sunSize 5.45 * pi / 180.0\n\nvec3 totalCoeff = rayleighCoeff + mieCoeff;\n\nvec3 scatter(vec3 coeff, float depth) {\n    return coeff * depth;\n}\n\nvec3 absorb(vec3 coeff, float depth) {\n    return exp2(scatter(coeff, -depth));\n}\n\nfloat calcParticleThickness(float depth) {\n    depth = max(depth, 1e-4);\n    depth = 1.0 / depth;\n    \n    return depth;\n}\n\nfloat rayleighPhase(vec3 p, vec3 lp) {\n    return 0.375 * (1.0 + pow(dot(p, lp), 2.0));\n}\n\nfloat miePhase(vec3 p, vec3 lp, float depth) {\n    float g = exp2(-depth);\n    float g2 = pow(g, 2.0);\n    return 0.25 * ((1.0 - g2) * pow(1.0 + g2 - 2.0 * g * dot(p, lp), -1.5));\n}\n\n// https://github.com/blender/cycles/blob/main/src/kernel/osl/shaders/node_sky_texture.osl\nfloat precise_angle(vec3 a, vec3 b) {\n    return 2.0 * atan(length(a - b), length(a + b));\n}\n\nvec3 calcAtmosphericScatter(vec3 p, vec3 lp) {\n    const float ln2 = log(2.0);\n    \n    float opticalDepth = calcParticleThickness(p.y);\n    float opticalDepthLight = calcParticleThickness(lp.y);\n    \n    vec3 scatterView = scatter(totalCoeff, opticalDepth);\n    vec3 absorbView = absorb(totalCoeff, opticalDepth);\n    \n    vec3 scatterLight = scatter(totalCoeff, opticalDepthLight);\n    vec3 absorbLight = absorb(totalCoeff, opticalDepthLight);\n    \n    vec3 absorbSun = abs(absorbLight - absorbView) / abs((scatterLight - scatterView) * ln2);\n    vec3 rayleighScatter = scatterView * rayleighPhase(p, lp);\n    vec3 mieScatter = scatterView * miePhase(p, lp, opticalDepth);\n    vec3 scatterSun = rayleighScatter + mieScatter;\n    \n    float sdAng = precise_angle(p, lp);\n    float haAng = sunSize * 0.5;\n    float fracAng = sdAng / haAng;\n    vec3 sunDisk  = sdAng < haAng ? (1.0 - (1.0 - sqrt(1.0 - fracAng * fracAng))) * absorbView : vec3(0);\n         sunDisk *= vec3(10.0);\n    \n    return (scatterSun * absorbSun + sunDisk) * pi;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv - 0.5) * vec2(2, 1) * pi;\n    vec3 rd = normalize(vec3(cos(uv.x), tan(uv.y), sin(uv.x)) * cos(uv.y));\n\n    vec3 col = vec3(0);\n    float epsilon = 0.0;\n    float e = iTime * 0.1;\n    vec3 l = normalize(vec3(0, sin(e), -cos(e)));\n    col = calcAtmosphericScatter(rd, l);\n    col = max(col, 0.0);\n    col = tanh(pow(col, vec3(0.4545)));\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}