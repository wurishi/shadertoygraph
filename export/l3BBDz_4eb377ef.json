{"ver":"0.1","info":{"id":"l3BBDz","date":"1729325993","viewed":40,"name":"20241019_1718_sample_light_sin","username":"tono","description":"shader","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["shader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//回転の関数\nmat2 rot(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    mat2 m = mat2(c, -s, s, c);\n    return m;\n}\n\n// 立方体の距離関数\nfloat boxSDF(vec3 p, vec3 size) {\n    vec3 d = abs(p) - size;\n    float outsideDistance = length(max(d, 0.0));\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    return outsideDistance + insideDistance;\n}\n\n// 距離関数\nfloat sceneSDF(vec3 p) {\n    //ねじる\n    p.xz *= rot( sin(p.y / 2.) /2. );\n    //変わった複製\n    p = sin(p/5.) * 5.;\n    p -= vec3( 0., sin(iTime),cos(iTime));\n    float o = 0.;\n    //縦に長く\n    o = boxSDF(p , vec3(1.,5.,1.));\n    return o;\n}\n\nvec3 calculateNormal(vec3 p) {\n    float epsilon = 0.0001;\n    vec3 n;\n    n.x = sceneSDF(p + vec3(epsilon, 0.0, 0.0)) - sceneSDF(p - vec3(epsilon, 0.0, 0.0));\n    n.y = sceneSDF(p + vec3(0.0, epsilon, 0.0)) - sceneSDF(p - vec3(0.0, epsilon, 0.0));\n    n.z = sceneSDF(p + vec3(0.0, 0.0, epsilon)) - sceneSDF(p - vec3(0.0, 0.0, epsilon));\n    return normalize(n);\n}\n//光を当てる\nvec3 lighting(vec3 p) {\n    vec3 lightDir = normalize(vec3(1.0, -1.0, 1.0)); // 光の方向\n    //ライトを回転させる\n    lightDir.xz *= rot(iTime * 12.);\n    vec3 n = calculateNormal(p); // 法線\n    float diff = max(dot(n, lightDir), 0.0); // 拡散反射\n    \n    vec3 matCol = vec3(0.,0.8,0.9);\n    return matCol * pow(diff , 3.) ; // 明るさを計算 diffを３乗する\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // カメラの設定\n    vec2 p = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    // カメラの設定\n    vec3 target = vec3(0.0, 0.0, 0.0);      // カメラが注目するターゲット位置\n    vec3 cp = vec3(1.5, -7.0, -15.0);       // カメラの位置\n    vec3 cd = normalize(target - cp);       // カメラの視線方向\n    vec3 cs = normalize(cross(cd, vec3(0.0, 1.0, 0.0))); // 右方向\n    vec3 cu = normalize(cross(cd, cs));     // 上方向\n    \n    float fov = 2.5; // 視野角\n    vec3 rd = normalize(cs * p.x + cu * p.y + cd * fov); // レイの方向\n    \n    // レイマーチングのループ\n    float t = 0.0;\n    int maxSteps = 100;\n    bool hit = false;\n    float maxDistance = 100.0;\n    float epsilon = 0.001;\n    \n    for (int i = 0; i < maxSteps; i++) {\n        vec3 currentPos = cp + t * rd;\n        float distance = sceneSDF(currentPos); \n        if (distance < epsilon) {\n            hit = true;\n            break;\n        }\n        t += distance;\n        if (t > maxDistance) break;\n    }\n    \n    // ヒットしたかどうかで色を決定\n    if (hit) {\n        vec3 currentPos = t * rd + cp; \n        vec3 normal = calculateNormal(currentPos);\n        \n        col = vec3(1.0, 0.0, 0.0); // 赤色\n        col = lighting(currentPos);\n        \n    } else {\n        col = vec3(0.0); // 黒色\n    }\n    \n    // フラグメントカラーを設定\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}