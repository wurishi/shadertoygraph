{"ver":"0.1","info":{"id":"flXcRB","date":"1648932073","viewed":211,"name":"Petal Fractal with Orbit Traps","username":"c0rymcg","description":"A flower-like fractal colored with orbit trap-based brightness\nReminds me of Queen Anne's Lace","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["fractal","orbittrap","pickover"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n#define TAU 6.28318\n#define maxIterations 100\n#define AA 2\n\n\nvec2 cMult(vec2 c1, vec2 c2){\n   //complex mult\n    float newR = c1.x*c2.x - c1.y*c2.y;\n\tfloat newI = c1.y*c2.x + c1.x*c2.y;\n\treturn vec2(newR,newI);\n}\nvec2 cDivide(vec2 c1, vec2 c2){\n\t//conjugate = a - bi;\n\t//to divide, multiply both sides by complex conjugate of denom\n\n\tfloat divisor = dot(c2,c2);\n\t\n\treturn vec2((c1.x*c2.x + c1.y*c2.y)/divisor, (c1.y*c2.x - c1.x*c2.y)/divisor);\n}\nvec2 cPow(vec2 z, float p){\n    if (p==1.) return z;\n\tfloat radius = sqrt(z.x*z.x + z.y*z.y);\n\tfloat theta = atan(z.y,z.x);\n\tfloat newR = pow(radius, p);\n\treturn vec2(newR * cos(theta*p), newR * sin(theta*p));\n}\nvec2 cPow(vec2 c1, vec2 c2){\n    return vec2(0);\n}\n\nvec2 f1(vec2 z, vec2 c) {\n    return cPow(c,17.)+cMult(c,z);\n}\n\nvec3 palette(float loc, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b*cos( TAU*(c*loc+d) );\n}\n\nfloat logPotential(float d,float i){\n  \n\tfloat base=log(2.);\n\treturn i-(log(log(d)/base)/base);\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 aacol=vec3(0.);\n    float time = iTime;\n    \n    //aa code here\n    for (int aax=0; aax<AA; aax++){\n    for (int aay=0; aay<AA; aay++){\n        vec2 c = vec2(0.);\n        vec2 z = vec2(0.);\n    \n        vec2 uv = (fragCoord + vec2(aax,aay)/float(AA))/iResolution.xx;\n        uv -= 0.5;uv *= 1.3;uv += 0.5;\n    \n        z.x = (uv.x - 0.5) ;\n        z.y = (uv.y - 0.22) ;\n        float zoom = 3.;\n        z*=zoom;\n        \n        bool escaped = false;\n            \n        int i = 0;\n        c = vec2(sin(iTime/20.),cos(iTime/20.))*(1.1+cos(iTime/27.)*0.1);\n        \n        float orbit = 100.;\n        \n        vec2 jPos = vec2(0);\n        if(iMouse.z>0.){\n            vec2 mPos = iMouse.xy/iResolution.xx;\n            mPos -= 0.5; mPos *= 1.3; mPos += 0.5;\n            mPos=zoom*(mPos-vec2(0.5,0.22));\n            c=mPos;\n            \n\n        \n        }\n    \n        float brightness = 0.;\n        float totalBs = 0.;\n        float avgI = 0.;\n        float biggestI = 0.;\n        float maxB = 0.;\n\t\t\n\t\t//iterate\n        for (i = 0; i < maxIterations; i++) {\n          orbit = min(length(z), orbit);\n          z = f1(c,z);\n          \n          //calculate orbit trap values:\n          float newDist = min(abs(z.x),abs(z.y));\n\t\t  if (newDist < 1.){\n\t\t\tfloat b = max(0., 0.-log(newDist + 0.0001)*0.05);\n\t\t\tavgI += float(i) * b; //this is a weighted average function that will help decide what color to use.\n\t\t\ttotalBs += b; //still for the weighted average function\n\t\t\tif (b > brightness) biggestI = float(i);\n\t\t\tbrightness = 1. - (1. - brightness) * (1. - b); //screen function\n\t\t\tmaxB = max(maxB, b);\n\t\t  }\n            \n\n        }\n        avgI = avgI*2. / totalBs;\n\n\tfloat fractionOfOrbit = avgI / float(maxIterations);\n\tbrightness = (brightness + maxB)/2.;\n\t\n    \n    vec3 iterationCol = vec3(palette(fractionOfOrbit, vec3(0.5),vec3(0.5),vec3(1.0, 1.0, 0.0),vec3(0.3, 0.2, 0.2)));\n\n\taacol+= vec3(iterationCol * brightness*3.);\n\t\t\n    }\n    }\n    fragColor=vec4(aacol.xyz/4.,1.);\n}\n\n","name":"Image","description":"","type":"image"}]}