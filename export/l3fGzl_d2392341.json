{"ver":"0.1","info":{"id":"l3fGzl","date":"1707821460","viewed":95,"name":"Crumbling Breach 2 (voronoi SDF)","username":"Cellulose","description":"A hexagonal grid is distorted, edges inset, and sampled as a voronoi pattern.  We consider both the current voronoi cell and adjacent ones because the widening factor may vary.\nClick to test the SDF.  It's a lower bound (min/max CSG of edges), not exact.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","sdf"],"hasliked":0,"parentid":"M3sGzf","parentname":"Crumbling Breach"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nconst float FARAWAY = 65000.0;\n\nvec2 project(vec2 a, vec2 b)    {return b * (dot(a,b) / dot(b,b));}\nvec2 project_abs(vec2 a, vec2 b)    {return b * (abs(dot(a,b)) / dot(b,b));}\nvec2 reject (vec2 a, vec2 b)    {return a - project(a,b);}\n\nconst vec2 gridscale = vec2(.866, 1);\n\nvec2 voronoi_pos(ivec2 cell)\n{\n    vec2 corner = vec2(cell)*gridscale;\n    corner.y += (mod(float(cell.x),2.0)<=0.5) ? -.25 : +.25;\n    vec2 center = corner + vec2(.5, .5)*gridscale;\n\n    float ang = rand(.81*center) * 6.2831853072;\n    float offm = .5 * rand(corner);\n\n    return center + offm * vec2(cos(ang), sin(ang));\n}\n\nconst vec2 CENTER = vec2(7,4);\n\nvec2 cameraShift()\n{\n    return 50.0 * vec2(cos(.01*iTime), sin(.01*iTime));\n}\n\nfloat widen_factor(vec2 pos)\n{\n    //return 0.0;\n    \n    //*/\n    float circle_rad = (2.5 + 1.5 * sin(iTime));\n    float circle_dist = distance(pos, CENTER + cameraShift());\n    \n    float x = 1.0 - clamp(circle_dist / circle_rad, 0.0, 1.0);\n\n    return x * x * (3.0f - 2.0f * x);\n    //return x * x * x * (x * (6.0f * x - 15.0f) + 10.0f); //*/\n}\n\nvec2 rot90(vec2 v)\n{\n    return vec2(-v.y, v.x);\n}\n\nfloat voronoi_sdf(vec2 uv)\n{\n    //uv.x *= 1.3;\n    ivec2 gridp = ivec2(round(uv.x/gridscale.x), round(uv.y/gridscale.y));\n    \n    \n    // First find the nearest point.\n    vec3 nearest = vec3(0,0,FARAWAY);\n    \n    ivec2 off;\n    for (off.x = -2; off.x <= 2; ++off.x)\n        for (off.y = -2; off.y <= 2; ++off.y)\n    {\n        vec2 pt = voronoi_pos(gridp + off);\n        float dist = distance(uv, pt);\n        \n        if (dist < nearest.z) nearest = vec3(pt, dist);\n    }\n    \n    // Then assess voronoi's signed distance function by checking each edge.\n    //vec3 nearer[2];\n    //nearer[0] = vec3(0,0, -FARAWAY);\n    \n    float dist_to_nearest_cell = -FARAWAY;\n    float dist_to_another_cell =  FARAWAY;\n    \n    for (off.x = -2; off.x <= 2; ++off.x)\n        for (off.y = -2; off.y <= 2; ++off.y)\n    {\n        vec2 pt = voronoi_pos(gridp + off);\n        \n        if (pt != nearest.xy)\n        {\n            vec2 mid = .5 * (nearest.xy + pt.xy), orth = rot90(pt.xy - nearest.xy);\n            vec2 diff = uv-mid;\n            \n            vec2 proj = project(diff, orth);\n            float this_edge_sdf = -length(diff-proj);\n            \n            // Decide the nature of the crack-widening.\n            vec2 widen_pt = mid;\n            widen_pt += .5*proj; //narrower further away\n            //widen_pt -= .25 * project_abs(normalize(orth), mid-CENTER); // wider radial\n            \n            float widen = widen_factor(widen_pt);\n            dist_to_another_cell = min(widen-this_edge_sdf, dist_to_another_cell);\n            dist_to_nearest_cell = max(widen+this_edge_sdf, dist_to_nearest_cell);\n            \n            this_edge_sdf += widen;\n        }\n    }\n    \n    return min(dist_to_nearest_cell, dist_to_another_cell);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    \n    uv *= 8.0;\n    vec2 mousePos = 8.0 * iMouse.xy/iResolution.y;\n    //uv.y = 1.2 * uv.y - .1;\n    \n    \n    {\n        uv += cameraShift();\n        mousePos += cameraShift();\n    }\n    \n    //*\n    {\n        //vec2 distort = ;\n        uv       += .03 * cos(3.0*sin(dot(uv.yx, vec2(3.6, 3.1))));\n        mousePos += .03 * cos(3.0*sin(dot(mousePos.yx, vec2(3.6, 3.1))));\n    } //*/\n    \n    \n    // Projecting onto the voronoi line gives us a messed up distance function, bad.\n    //vec2 mid = .5 * (near1.xy + near2.xy), orth = (near2.xy - near1.xy);\n    //orth = vec2(orth.y, -orth.x);\n    //float surface_dist = -length(reject(uv-mid, orth));\n    \n    \n    float dist = voronoi_sdf(uv);\n    \n    float mouse_dist = voronoi_sdf(mousePos);\n    \n    //dist += widen_factor(mix(nearest.xy, uv, .75));\n    \n    \n    vec3 col = max(vec3(0), vec3(1.0 + float(dist > 0.0), exp2(dist*5.0), exp2(dist)) - vec3(1));\n    //    - vec3(clamp(dist*.4, -0.35, 0.0));\n    \n    if (dist < 0.0)\n    {\n        float capdist = -dist;\n        vec3 normal = normalize(vec3(dFdx(capdist), dFdy(capdist), dFdx(uv.x)));\n        col += .25 * dot(normal, vec3(.48, -.6, .64));\n    }\n    \n    //col = mix(col, vec3(center_dist, 0.0, 0.0), .5+.5*sin(iTime));\n    \n    //col.r = max(0.0, 1.0-5.0*(near2.z-near1.z));\n    //col.g = near1.z;\n    \n\n    float mouse_ring = mouse_dist - length(uv-mousePos);\n    if (mouse_ring > 0.0 && mouse_ring < 0.1) col = vec3(.3,.6,1);\n    \n    \n    //vec3 col = vec3(max(0.0, 1.0-5.0*(near2.z-near1.z))); // Crude dividing lines\n    \n    //vec3 col = vec3(max(0.0,\n    //    (30.0 + 15.0 * sin(iTime))-10.0*distance(uv, vec2(7,4))-20.0*sqrt(near2.z-near1.z)));\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n// This function isn't actually used, just something I tried\nvec3 circumcircle(vec2 p1, vec2 p2, vec2 p3)\n{\n    /*vec2\n        a0 = .5 * (nearer[0].xy + nearest.xy),\n        a1 = .5 * (nearer[1].xy + nearest.xy),\n        d0 = rot90(nearer[0].xy - nearest.xy),\n        d1 = rot90(nearer[1].xy - nearest.xy);*/\n    \n    // Reduce cancellation error?\n    vec2 offset = (p1+p2+p3)/3.0;\n    p1 -= offset;\n    p2 -= offset;\n    p3 -= offset;\n\n    mat3 ma, mx, my;\n    my[0] = ma[0] = vec3(p1.x, p2.x, p3.x);\n    mx[1] = ma[1] = vec3(p1.y, p2.y, p3.y);\n    mx[0] = my[1] = vec3(dot(p1,p1), dot(p2,p2), dot(p3,p3));\n    ma[2] = mx[2] = my[2] = vec3(1);\n\n    vec2 cen = .5 * vec2(determinant(mx), determinant(my)) / determinant(ma);\n        \n    return vec3(offset + cen, length(p1-cen));\n}\n","name":"Image","description":"","type":"image"}]}