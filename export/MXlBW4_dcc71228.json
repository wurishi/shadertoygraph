{"ver":"0.1","info":{"id":"MXlBW4","date":"1728412438","viewed":58,"name":"cosmic semaphore","username":"nayk","description":"very like cosmos\noriginals  https://www.shadertoy.com/view/MdXSzS https://www.shadertoy.com/view/tllfRX https://www.shadertoy.com/view/XlfGRj and other","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["fractal","galaxy","cosmos"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n//</3d simplex noise by nikat https://www.shadertoy.com/view/XsX3zB>\nfloat fbm(vec2 xy, float z, int octs){\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    float a_bound = 0.0;\n    for(int i=0;i<octs;i++){\n        t += a*simplex3d(vec3(xy*f,z*f));\n        f *= 2.0;\n        a_bound += a;\n        a *= 0.5;\n    }\n    return t/a_bound;\n}\nfloat noise_final_comp(vec2 xy, float z){\n    float value = fbm(vec2(xy.x / 200.0+513.0, xy.y / 200.0+124.0), z, 3);\n    value = 1.0-abs(value);\n    value = value*value;\n    return value*2.0-1.0;\n}\nfloat noise_final(vec2 xy, float z){\n        float value = fbm(vec2((noise_final_comp(xy, z)*15.0+xy.x) / 100.0,(noise_final_comp(xy+300.0, z)*15.0+xy.y) / 100.0), z*1.5, 5);\n        return max(0.0, min(1.0, (value*0.5+0.5)*1.3));\n}\nfloat easeFade(float x)\n{\n    return 1.-(2.*x-1.)*(2.*x-1.)*(2.*x-1.)*(2.*x-1.);\n}\nfloat holeFade(float t, float life, float lo)//lifeOffset\n{\n    return easeFade(mod(t-lo,life)/life);\n}\nvec2 getPos(float t, float life, float offset, float lo)\n{\n    return vec2(cos(offset+floor((t-lo)/life)*life)*iResolution.x/2.,\n    sin(2.*offset+floor((t-lo)/life)*life)*iResolution.y/2.);\n\n}\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) - .5;\n    vec2 uv3 = (fragCoord.xy / iResolution.xy) - .5;\n\tfloat t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .57)) * 12.2;\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\tmat2 ma = mat2(co, si, -si, co);\n // pixel position normalised to [-1, 1]\n\tvec2 cPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n     vec2 R = iResolution.xy; \n     vec4 o=fragColor;\n     vec2 F=fragCoord;\n    o-=o;\n       // Centered position\n    vec2 coord = fragCoord * 2. - iResolution.xy;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv2 = coord / iResolution.y;\n    \n    \n    \n    float holeSize = iResolution.y/10.;\n    float holeLife = 1.;\n    \n    \n    vec3 final;\n    uv2*=ma;\n    for (int i = 0; i<15; i++) {\n        vec3 col = 0.05 + 0.5*cos(iTime+uv2.xyx+vec3(float(i),2.*float(i)+4.,4.*float(i)+16.));\n\n        float s = holeSize;\n        float lifeOffset = float(i)/2.;\n\n        vec2 pos = getPos(iTime, holeLife, float(i)*4.5,lifeOffset);\n\n        float d = distance(coord,pos)/s;\n        d = 1./d-.1;\n        \n        final += mix(vec3(0),col, d)*holeFade(iTime,holeLife,lifeOffset);\n    }\n    for(float d,t = -iTime*.01, i = 0. ; i > -1.; i -= .06 )          \t\n    {   d = fract( i -3.*t );                                          \t\n        vec4 c = vec4( ( F - R *.5 ) / R.y *d ,i,0 ) * 28.;            \t\n        for (int j=0 ; j++ <27; )                                      \t\n            c.xzyw = abs( c / dot(c,c)                                 \t\n                    -vec4( 7.-.2*sin(t) , 6.3 , .7 , 1.-cos(t/.8))/7.);\t\n       o -= c * c.yzww  * d--*d  / vec4(3,5,1,1);                     \n    }\n    // distance of current pixel from center\n\tfloat cLength = length(cPos);\n\n\t uv += (cPos/cLength)*cos(cLength*12.0-iTime*4.0) * 0.03;\n\t\n\tfloat v1, v2, v3;\n\tv1 = v2 = v3 = 0.0;\n\t float p2 = noise_final(uv,iTime*0.025+0.05*sin(iTime*0.2+(uv.x*0.3*(sin(iTime/30.0)-0.3)+uv.y)/265.0));\n    vec2 rC = vec2(max(iResolution.x,iResolution.y),\n                   min(iResolution.x,iResolution.y));\n    p2*=clamp(1.3-1.5*length(fragCoord-0.5*vec2(rC.x,rC.y))/rC.y,0.0,1.0);\n\tfloat s = 0.0;\n\tfor (int i = 0; i < 90; i++)\n\t{\n\t\tvec3 p = s * vec3(uv, 0.0);\n\t\n\t\tp += vec3(.22, .3, s - 1.5 - sin(iTime * .13) * .1)+p2*o.xyz;\n\t\tfor (int i = 0; i < 8; i++)\tp = abs(p) / dot(p,p) - 0.659;\n\t\tv1 += dot(p,p+p2) * .0015 * (1.8 + sin(length(uv.xy * 13.0) + .5  - iTime * .2));\n\t\tv2 += dot(p+p2,p) * .0013 * (1.5 + sin(length(uv.xy+p2 * 14.5) + 1.2 - iTime * .3));\n\t\tv3 += length(p.xy*10.) * .0003;\n\t\ts  += .035;\n\t}\n\t\n\tfloat len = length(uv);\n\tv1 *= smoothstep(.7, .0, len);\n\tv2 *= smoothstep(.5, .0, len);\n\tv3 *= smoothstep(.9, .0, len);\n\t\n\tvec3 col = vec3( v3 * (1.5 + sin(iTime * .2) * .4),\n\t\t\t\t\t(v1 + v3) * .3,\n\t\t\t\t\t v2) + smoothstep(0.2, .0, len) * .85 + smoothstep(.0, .6, v3) * .3;\n\n\tfragColor=vec4(min(pow(abs(col), vec3(1.2))*o.xyz*final*10., 1.0), 1.0);\n     uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n    fragColor+= vec4(happy_star(uv2, anim) * vec3(0.35,0.2,0.35)*0.1, 1.0);\n}","name":"Image","description":"","type":"image"}]}