{"ver":"0.1","info":{"id":"7tG3Rt","date":"1638157875","viewed":269,"name":"yab","username":"thepheer","description":"My little experiment of making a basic color space by simply rotating and scaling an rgb cube.\n\nSee the common tab for more details about the color space.\nSee my comment [url=stVGzV]here[/url] for explanations about shaders like this one.","likes":7,"published":3,"flags":0,"usePreview":0,"tags":["yab","ych"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU radians(360.0)\n#define rep(m, x) (mod(x, 2.0*(m)) - (m))\n#define sdf(w, d) smoothstep(1.5*(w), 0.0, d)\n#define plot(w, x, y) sdf(w, abs((x) - (y)))\n#define range(t, a, b) (step(a, t) * step(t, b))\n\nvoid mainImage(out vec4 rgba, vec2 xy) {\n    vec2 px = 1.0/iResolution.xy;\n    vec2 uv = xy*px;\n    \n    // color generation happens here, feel free to play with\n    float y = 0.50 + 0.49*sin(TAU*(0.2*uv.x - 0.1*iTime));\n    float c = 0.75*y*(1.0 - y);\n    float h = TAU*(fract(uv.x + 0.5*iTime) - 0.5);\n\n    // ych → yab → rgb → yab → ych\n    vec3 ych1 = vec3(y, c, h);\n    vec3 yab1 = ych_to_yab(ych1);\n    vec3 sRGB = yab_to_rgb*yab1;\n    vec3 yab2 = rgb_to_yab*sRGB;\n    vec3 ych2 = yab_to_ych(yab2);\n    \n    float dashed = sdf(1.0, abs(rep(6.0, xy.x)) - 4.0);\n    float dotted = sdf(1.0, abs(rep(2.0, xy.x)));\n    vec3 split = 0.025*vec3(-1.0, 0.0, 1.0);\n    \n    vec3 rgb =\n        range(uv.y, 0.9, 1.0)*sRGB +\n        plot(px.y, uv.y, 0.775 + 1e3*(ych2 - ych1) - split) +\n        plot(px.y, uv.y, 0.625 + 1e5*(yab2 - yab1) - split) +\n        plot(px.y, uv.y, 0.100 + 0.4*sRGB) +\n        plot(px.y, uv.y, 0.500)*dotted*0.1 +\n        plot(px.y, uv.y, 0.100)*dotted*0.1;\n\n    rgba = vec4(sRGB_OETF(rgb), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// A small experiment of turning just a regular rgb cube in such a way so\n// its black and white corners become (0, 0, 0) and (1, 0, 0) coordinates\n// in yab respectively, so basically y component controls lightness and\n// ab components control chroma: a - cyan/red, b - magenta/green (roughly).\n//\n// In other words it's just the same rgb cube but scaled and rotated so it\n// kind of stands on its black corner now. Interpolating colors in yab will\n// give exactly the same outcome as doing it in rgb.\n//\n// And there's also ych space which is a cylindrical representation of yab.\n// Essentially: y - lightness, c - chroma, h - hue.\n//\n// So \"what's the point?\" you may ask. Well, even though by some properties\n// it's exactly the same as rgb space, there are some in which it differs:\n// - changing y makes the color darker/lighter, it changes all three\n//   components of the color in rgb space by equal amount\n// - changing a or b shifts the color towards cyan/red or magenta/green\n//   while the sum of its rgb values stays the same\n// - changing c makes the color more or less saturated\n//   while the sum of its rgb values stays the same\n// - changing h, yeah, you guessed it, changes hue of the color\n//   while the sum of its rgb values stays the same\n//\n// The difference with other \"real\" colors spaces is that yab is kind of a\n// silly one, it's not defined in terms of CIE XYZ (because there's no sense\n// to do that) and it doesn't really have obvious practical applications.\n//\n// After reading my explanations above one could think that it should be\n// great for image manipulations but actually for this purpose it's as good\n// as rgb, which is awful, because it's not perceptually uniform by any means.\n//\n// With that being said, it was still an interesting exercise to figure out\n// the transformation matrices, and I kind of have a feeling this stuff is\n// potentially useful for me if not today but later, so I'm gonna keep it\n// here as a shader.\n\n// ScalingMatrix[{1, 1, 1}/Sqrt[3]] .\n// RotationMatrix[1/2 Pi - ArcTan[1/Sqrt[2]], {0, 0, 1}] .\n// RotationMatrix[3/4 Pi, {1, 0, 0}]\nconst mat3 rgb_to_yab = 1.0/6.0*mat3(\n    2.0, 2.0*sqrt(2.0), 0.0,\n    2.0, -sqrt(2.0), sqrt(6.0),\n    2.0, -sqrt(2.0), -sqrt(6.0)\n);\n\n// = inverse(rgb_to_yab)\n// = 3.0*transpose(rgb_to_yab)\nconst mat3 yab_to_rgb = 1.0/2.0*mat3(\n    2.0, 2.0, 2.0,\n    2.0*sqrt(2.0), -sqrt(2.0), -sqrt(2.0),\n    0.0, sqrt(6.0), -sqrt(6.0)\n);\n\nvec3 ych_to_yab(vec3 ych) {\n    return vec3(ych.x, ych.y*vec2(cos(ych.z), sin(ych.z)));\n}\n\nvec3 yab_to_ych(vec3 yab) {\n    return vec3(yab.x, length(yab.yz), atan(yab.z, yab.y));\n}\n\n// ---\n\nvec3 sRGB_OETF(vec3 c) {\n    vec3 a = 12.92*c;\n    vec3 b = 1.055*pow(c, vec3(1.0/2.4)) - 0.055;\n    return mix(a, b, greaterThan(c, vec3(0.00313066844250063)));\n}\n\nvec3 sRGB_EOTF(vec3 c) {\n    vec3 a = c/12.92;\n    vec3 b = pow((c + 0.055)/1.055, vec3(2.4));\n    return mix(a, b, greaterThan(c, vec3(0.0404482362771082)));\n}","name":"Common","description":"","type":"common"}]}