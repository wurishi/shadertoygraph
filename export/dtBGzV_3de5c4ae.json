{"ver":"0.1","info":{"id":"dtBGzV","date":"1673537200","viewed":68,"name":"Separating Grid 887985595558","username":"HaleyHalcyon","description":"ee","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["ee"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Subdividing grid inspired by the Cantor Set\n\n// 2π for radial grid\n#define TURN (6.283185307)\n// Fold range from 0 to 1\n#define ZIG(x) 1. - abs(1. - 2. * fract(x))\n\n// Eases between size 1 and size 1/3 grids\nfloat cantor(float x, float t) {\n    float zx = ZIG(x);\n    // Do this to smooth out discontinuity in theta\n    float dx = min(\n      fwidth(x),\n      fwidth(fract(x + 0.25))\n    ) * .75;\n    // Size 1 grid\n    float s0 = smoothstep(\n      -dx, dx,\n      zx - 0.5\n    );\n    // Size 1/3 grid eased in based on t value\n    float s1 = smoothstep(\n      -dx, dx,\n      -zx + (t / 6.)\n    ) + smoothstep(\n      -dx, dx,\n      zx - (6. - t) / 6.\n    );\n    s1 *= smoothstep(0.0, 0.01, t);\n    return mix(s0, 1.-s0, s1);\n}\n\n// Expanding then subdividing grid\nfloat cantorChecker(vec2 uv, float t) {\n    float scale = pow(3., -t);\n    float grid = cantor(\n        uv.x * scale, t\n    );\n    grid = mix(\n        grid, 1.-grid,\n        cantor(\n            uv.y * scale, t\n        )\n    );\n    return grid;\n}\n\n// Expanding radial grid\nfloat cantorRadial(vec2 uv, float t, vec2 baseScale) {\n    vec2 polar = vec2(\n        log2(length(uv)) + 1.,\n        atan(uv.x, uv.y) / TURN\n    );\n    float t_i = floor(t);\n    float t_f = fract(t);\n    float scaleInt = pow(3., t_i);\n    float scaleFract = pow(3., t_f);\n    // radial doesn’t subdivide\n    float grid = cantor(baseScale.x * polar.x * scaleInt * scaleFract + t * 1., 0.);\n    // circular subdivides\n    grid = mix(\n        grid, 1. - grid,\n        cantor(\n            step(1., mod(t, 2.)) * 0.5 +\n            baseScale.y * polar.y * scaleInt, t_f\n        )\n    );\n    return grid;\n}\n\n// Hex code to RGB vec3\n#define HEX(x) (vec3((x >> 16) & 255, (x >> 8) & 255, x & 255) / 255.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Loop every 15sec.\n    float t = fract(iTime / 15.);\n    // Center is 0, horiz is length 1\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.xx;\n    // Splitscreen\n    float useRadial = step(0., uv.x);\n    uv.x += 0.5 - useRadial;\n    \n    float v = mix(\n        cantorChecker(uv * 8., fract(t * 4.)),\n        cantorRadial(uv, ZIG(t) * 4., vec2(2.5, 27.)),\n        useRadial\n    );\n    // Time varying pixel color\n    vec3 col = mix( HEX(0x207089), HEX(0xabcdef), v);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}