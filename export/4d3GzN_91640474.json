{"ver":"0.1","info":{"id":"4d3GzN","date":"1448314571","viewed":187,"name":"Mute City","username":"jameswilddev","description":"dun dun - dun dun dun - dun dun dun dun dun","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["mutecity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\n/* \n   These functions take a \"camera\" variable specifying:\n     X/Y: Where on the screen we are rendering.\n     Z: How far forwards we are.\n   And return the world-space coordinate at which the camera hits the plane.\n*/\n\n/* A wall directly in front of you. */\nvec3 planeZ(float z, vec3 camera) {\n    return vec3(camera.xy * (z - camera.z), z);\n}\n\n/* Parallel walls to the left/right of you. */\nvec3 planeX(float x, vec3 camera) {\n    float divisor = x / camera.x;\n    return vec3(x, camera.y * divisor, abs(divisor) + camera.z);\n}\n        \n/* Parallel floor and ceiling. */\nvec3 planeY(float y, vec3 camera) {\n    float divisor = y / -camera.y;\n    return vec3(camera.x * -divisor, y, abs(divisor) + camera.z);\n}\n\n/* -------------------------------------------------------- */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Almost normalized device coordinates, but aspect-corrected.\n    vec2 aspectNdc = (fragCoord.xy - (iResolution.xy / 2.0)) / (min(iResolution.x, iResolution.y) / 2.0);\n \n    // Distortion which sort of looks like rotating the camera.\n    vec2 mouse = (iMouse.xy - (iResolution.xy / 2.0)) / min(iResolution.x, iResolution.y);\n    if(iMouse.z <= 0.0) mouse = vec2(0.0);\n    mouse *= 2.0;\n    mouse.y += 0.3;\n    aspectNdc -= mouse.xy;\n    aspectNdc /= 1.0 + dot(mouse.xy, aspectNdc);\n    \n    vec3 camera = vec3(aspectNdc, iTime);\n    vec3 col;\n    \n    if(camera.y > 0.0) {\n        if(camera.y > 0.0 && camera.y < 0.18 - abs(sin(camera.x * 1.2 + 1.4) * 0.1) - abs(sin(camera.x * 3.0) * 0.05)) \n            // Mountain.\n            col = vec3(0.0, 0.0, 1.0);\n       \telse\n            // Sky.\n            col = vec3(0.3, 0.7, 1.0);\n        \n        // Fade to white on horizon.\n        col = mix(col, vec3(0.8, 0.9, 1.0), 1.0 / (1.0 + camera.y * 4.0));\n    } else {\n        \n        // Houses/streets.\n        #define GROUND_ALTITUDE -4.3\n        #define ROOF_ALTITUDE -4.0\n        #define BUILDING_SIZE 0.6\n        #define ROAD_WIDTH (BLOCK_SIZE - BUILDING_SIZE)\n        #define BLOCK_SIZE 1.0\n\n        vec3 roof = planeY(ROOF_ALTITUDE, camera);\n\n        vec2 tile = floor(roof.xz / BLOCK_SIZE) * BLOCK_SIZE;\n\n        float leftX = tile.x + ROAD_WIDTH / 2.0;\n        float rightX = tile.x + BUILDING_SIZE + ROAD_WIDTH / 2.0;\n        float frontZ = tile.y + ROAD_WIDTH / 2.0;\n        float backZ = tile.y + BUILDING_SIZE + ROAD_WIDTH / 2.0;\n        float sideX = roof.x > 0.0 ? leftX : rightX;\n\n        vec3 front = planeZ(frontZ, camera);\n        vec3 side = planeX(sideX, camera);\n        vec3 ground = planeY(GROUND_ALTITUDE, camera);\n\n        vec3 compute;\n        col = vec3(0.12, 0.09, 0.04);\n\n        float brightness;\n\n        if(roof.x > leftX && roof.x < rightX && roof.z > frontZ && roof.z < backZ) {\n            compute = roof;\n            brightness = 0.0;\n        } else {\n            if(front.x > leftX \n               && front.x < rightX \n               && front.y > GROUND_ALTITUDE \n               && front.y < ROOF_ALTITUDE\n            ) {\n                compute = front;\n                brightness = 0.4;  \n            } else {\n                if(side.z > frontZ \n                   && side.z < backZ \n                   && side.y > GROUND_ALTITUDE \n                   && side.y < ROOF_ALTITUDE) {\n                    compute = side;\n                    brightness = 0.7;\n                } else {\n                    compute = ground;\n                    brightness = 1.0;\n                }\n            }\n        }\n\n        // Apply streetlights.\n        vec2 groundUV = cos(compute.xz * PI / BLOCK_SIZE * 2.0) * 0.5 + 0.5;\n\n        col += vec3(0.5, 0.7, 1.3) * brightness * ((groundUV.x * groundUV.y + 0.01) / (((compute.y - GROUND_ALTITUDE)* 10.0) + 1.0));\n\n        #define OVERPASS_ALTITUDE -3.5\n        #define OVERPASS_2_ALTITUDE -3.0\n\n        #define OVERPASS_SPACING 12.0\n        #define OVERPASS_2_SPACING 7.0\n        #define OVERPASS_WIDTH 0.125\n\n        // Pink overpass.\n        vec3 overpass = planeY(OVERPASS_ALTITUDE, camera);\n\n        float overpassY = \n            min(abs(mod(overpass.z, OVERPASS_SPACING) - OVERPASS_WIDTH),\n                abs(mod(overpass.x, OVERPASS_SPACING) - OVERPASS_WIDTH))\n                / OVERPASS_WIDTH;\n        \n        if(overpassY < 1.0) {\n            col = mix(vec3(0.5, 0.1, 0.4), vec3(1.0), (overpassY * overpassY) + sin(((overpass.x + overpass.z) * 5.0) + iTime * 30.0) * 0.2);\n\t\t\tcompute = overpass;\n        }\n\n        // Blue overpass.\n        overpass = planeY(OVERPASS_2_ALTITUDE, camera);\n\n        overpass.xy += 12.0;\n\n        overpassY = \n            min(abs(mod(overpass.z, OVERPASS_2_SPACING) - OVERPASS_WIDTH), \n                abs(mod(overpass.x, OVERPASS_2_SPACING) - OVERPASS_WIDTH))\n                / OVERPASS_WIDTH;\n        \n        if(overpassY < 1.0) {\n            col = mix(vec3(0.2, 0.5, 1.0), vec3(1.0), (overpassY * overpassY) + sin(((overpass.x + overpass.z) * -8.0) + iTime * 30.0) * 0.2);\n            compute = overpass;\n        }\n\n        // Fog.\n        col = mix(vec3(1.0, 0.6, 0.7), col, 1.0 / (1.0 + (compute.z - camera.z) * 0.03));\n        col = mix(vec3(0.8, 0.9, 1.0), col, 1.0 / (1.0 + (compute.z - camera.z) * 0.005));\n    }\n        \n    // Gamma correct and put on screen.\n    fragColor = vec4(pow(col, vec3(1.0 / 2.2)), 1.0);\n}","name":"","description":"","type":"image"}]}