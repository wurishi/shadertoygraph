{"ver":"0.1","info":{"id":"ftjfRh","date":"1652088578","viewed":130,"name":"Black Hole Observer","username":"freemeson","description":"Stars are generated during the first few frames.\nA Schwarzschild black hole seen by a moving observer. The black hole is always in the middle, its distortions and shift is due to Lorentz contraction, relativistic beaming and doppler effects. ","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["blackholeschwarzschild"],"hasliked":0,"parentid":"NlXBDj","parentname":"Analytic Black Hole"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    This shader calculates the photon trajectories of a Schwarzschild black hole analytically, \n    and finds intersections with quick root solvers.\n    It solves the radially symmetric u(phi) = 1/r(phi) polynomial for the Binet differential equation:\n    u(phi)'' = -u(phi) + 3/2 *R_sch * u(phi)^2\n    \n    The accretion disk is treated as a white object shining only in the visible spectrum, \n    in order to demonstrate the doppler effect due to its rotation, the gravitational well and \n    the movement of the observer.\n    The observer is not moving on a free path (orbit), that's hard to parametrize, but the \n    doppler is consistent with its velocity.\n    \n    \n    The sole copyright owner of the work is the user freemeson - 2022\n    I've uploded it for educational purposes. You may use it fully or partially\n    for non-commercial cases, but not for any commercial materia, including NFTs.\n    Contact me for exeptions.\n    \n    Many inspirations were taken from:\n    https://rantonels.github.io/starless/\n    and Inigo Quilez's works\n    \n    also see:\n    Black hole without Dopppler effect:\n    https://www.shadertoy.com/view/NlXBDj\n    Reference for the infrared and UV color spectrum:\n    https://www.shadertoy.com/view/ft2fzm\n    \n*/\n\n#define PI 3.14159265\n//Schwarzschild radius\n#define RS 1.0\n//polynomial degree+1, nDegree=16 is extremely puncual, \n// 8 is usually enough for a fullHD render. The difference is mainly at the photon sphere.\n// I plan to rewrite the storage and calculations to use vec4[2] instead of float[nDegree]\n#define nDegree 8\n//The maximal number of steps. Each step is a 1 radian distance in the u(phi)=1/r(phi) trajectory. \n//Most rays don't need more than 3, 60 means ten revolutions around the black hole\n#define MAX_STEPS 10\n\n//I've set up a reasonable path for the camera, but in case you change it, there is a limiter on in its doppler effect\n//beta = speed/speed_of_light, so don't set it to be larger than one, or smaller than zero.\n//Setting to zero disables the camera-dopplers (beaming and color doppler)\n#define CAM_MAX_BETA 0.99\n\n//You may define the infrared and ultraviolet colors noisy\n//#define NOISY_NONVISBLE_COLORS\n\n\nstruct light_params{\n    float u0;\n    float dudphi0;\n    float alpha;\n    float cam_Doppler;\n    vec3 r_hat;\n    vec3 r_perp;\n};\n\n\nlight_params startParams(in vec3 ro, in vec3 rd, in float cam_Doppler){\n    float u0 = 1.0/length(ro);\n    vec3 r_hat = normalize(ro);\n    vec3 v_hat = normalize(rd);\n    vec3 r_perp = normalize(v_hat - dot(r_hat, v_hat)*r_hat);\n    float alpha = acos(dot(r_hat, v_hat));\n    float dudphi0 = -1.0/tan(alpha)*u0;\n    \n    return light_params( u0, dudphi0, alpha, cam_Doppler, r_hat, r_perp  );\n}\n\n\n//polynomial Solution to the Binet differential equation for the Schwarzschild metric for zero mass objects\n//u''(phi) = - u + 3/2 * RS * u*u\nvoid calcWeierstrass(inout float coeff[nDegree], in float u0, in float dudphi0){\n    coeff[0] = u0;\n    coeff[1] = dudphi0;\n    for(int index=0; index<nDegree-2; index++){\n        float csum = 0.0;\n        for(int i=0; i<=index; i++ ){\n            csum += coeff[i]*coeff[index-i];\n        }\n        coeff[index+2] = (-coeff[index] + 1.5*RS*csum)/float( (index+1)*(index+2)   );\n    }\n}\n\n//evaluate polynomial segment at deltaPhi angle, using the Horner's quick poly method\nfloat evalPoly(in float v[nDegree], in float deltaPhi){\n    float res = v[nDegree-1];\n    for(int i=nDegree-2; i>=0; i--){\n        res = v[i] + deltaPhi*res;\n    }\n    return res;\n}\n\n//evaluate once derivated polynomial segment at deltaPhi angle, using the Horner's quick poly method\nfloat evalDerivPoly(in float v[nDegree], in float deltaPhi){\n    float res = float(nDegree-1)*v[nDegree-1];\n    for(int i=nDegree-2; i>=1; i--){\n        res = float(i)*v[i] + deltaPhi*res;\n    }\n    return res;\n}\n\n\n\n\n//Newton iteration to find u(phi) = 0 root\n//vec2 output for debugging\n//phi should be around the working point of the polynomial\nfloat skyEventSolver(in float coeff[nDegree],in float in_local_phi_guess){\n    int i=0;\n    float relDelta = 1e5;\n    float local_phi_guess = in_local_phi_guess;\n    if(!(in_local_phi_guess>0.0) || !(in_local_phi_guess < 1.0)){\n        return 0.0;\n    }\n    \n    \n    \n    //float u;\n    while(i<5 && relDelta>1e-5 ){\n        //u = evalPoly(coeff, local_phi_guess);\n        //float delta = -u/evalDerivPoly(coeff, local_phi_guess);\n        float delta_nominator = -evalPoly(coeff, local_phi_guess);\n        float delta_denominator = evalDerivPoly(coeff, local_phi_guess);\n        if (abs(delta_denominator)<0.001) {\n            delta_denominator = 0.001*sign(delta_denominator);\n        }\n        float delta = delta_nominator/delta_denominator;\n        local_phi_guess += clamp(delta, -0.1, 0.1); //clamping for the rare cases, so it does not jump out of the work region               \n        relDelta = abs(delta)/(abs(local_phi_guess)+1e-2);\n        i++;\n    }\n\n    //return vec2(local_phi_guess, u); // u should be around zero \n    if ((local_phi_guess)< 1.0 && local_phi_guess > 0.0) {\n        return local_phi_guess; // u should be around zero \n    } else {\n        return in_local_phi_guess;\n    }\n    \n}\n\n//Newton iteration to find u(phi) = 1 root\n//vec2 output for debugging\nfloat eventHorizonEventSolver(in float coeff[nDegree],in float local_phi_guess){\n    int i=0;\n    float relDelta = 1e5;\n    //float u;\n    while(i<5 && relDelta>1e-5){\n        //u = evalPoly(coeff, local_phi_guess);\n        //float delta = -(u-1.0)/evalDerivPoly(coeff, local_phi_guess);\n        float delta = -(evalPoly(coeff, local_phi_guess)-1.0)/evalDerivPoly(coeff, local_phi_guess);\n        local_phi_guess += clamp(delta, -0.1, 0.1);\n        relDelta = abs(delta/local_phi_guess);\n        i++;\n    }\n\n    //return vec2(local_phi_guess, u); // u should be around 1.0\n    return local_phi_guess;\n}\n\n//this evaluates the polynomial at phi=1.0\nfloat sum(in float v[nDegree]){\n    float s = 0.0;\n    for(int i=0; i!= nDegree; i++){\n        s+=v[i];\n    }\n    return s;\n}\n\n//this evaluates the derivative of the polynomial at phi=1.0\nfloat dsum(in float v[nDegree]){\n    float s = 0.0;\n    for(int i=1; i!= nDegree; i++){\n        s+=float(i)*v[i];\n    }\n    return s;\n}\n\n//disk is at z=0, all we need to do is \n//solving (r_hat_z * cos(phi) + r_perp_z*sin(phi)) = 0 for phi\n//it is based on the trigonometric identity\n//cos(phi)*cos(alpha) +- sin(phi)*sin(alpha) = cos(phi -+ alpha) = 0\n//we don't need to know the r(phi) trajectory/geodetic \nfloat diskEventSolver(in float r_hat_z, in float r_perp_z){\n    vec2 a = normalize(vec2(r_hat_z,r_perp_z));\n    float alpha = atan(a.x, a.y); //the normalization is not necessary\n    if (alpha >0.0) alpha-=PI; //the disk events are periodic in phi, we need one in front of us, phi>0\n    if (alpha >0.0) alpha-=PI;\n    float phi = -alpha; \n    return phi;\n    \n}\n\n\nfloat PHI = 1.61803398874989484820459;  // Î¦ = Golden Ratio   \n\n\nfloat gold_noise(in vec3 randSeed){\n       return fract(tan(distance(randSeed.xy*PHI, randSeed.xy)*randSeed.z*2323.0)*randSeed.x);\n}\n\nfloat gold_noise(in vec2 xy, in float seed){\n       return fract(tan(distance(xy*PHI, xy)*seed*333.992+1.597)*xy.x+0.88678676);\n}\n\n\n\nvec3 waveLengthToRGB(float hue)\n{\n    // https://www.shadertoy.com/view/ll2cDc\n\n\treturn vec3(.5 + .5 * clamp( 1.3*cos(-0.3 + 6.28 * hue + vec3(0,0.66666*6.28, 0.3333*6.28)), -1.0, 1.0));\n//approximate colors\n//red is hue = 0.05\n//green is 0.38\n//blue is 0.71\n}\n\n#ifdef NOISY_NONVISBLE_COLORS\n\nvec3 wideSpectrum(float hue,vec3 randSeed) {\n\tif (hue<0.0) {\n\t\tvec3 red = waveLengthToRGB(0.0);\n\t    float noise = (1.0-exp(10.0*hue))*gold_noise(randSeed);\n\t\t\n\t\treturn exp(2.0*hue)*(red-noise*red);\n    }\n\tif (hue>0.8) {\n\t\tvec3 violet =  waveLengthToRGB(0.8);//*exp(-0.1*(hue-0.8));\n\t\tvec3 antiViolet = waveLengthToRGB(0.8)*(1.0-exp(-0.2*(hue-0.8)));\n\t\tfloat noise = gold_noise(randSeed);\n\t\treturn (violet+pow(hue, 2.0)*(noise-0.5  )*vec3(0.0, 0.0, 1.0)   +1.2*(1.0 -exp(-0.14*(hue-0.8) ))*vec3(1.0))*pow(hue+0.2, 1.4) ;\n    }\n\n\n\treturn waveLengthToRGB(hue);\n}\n\n#else\n\n\nvec3 wideSpectrum(float hue,vec3 randSeed) {\n\tif (hue<0.0) {\n\t\tvec3 red = waveLengthToRGB(0.0);\n\t    float noise = (1.0-exp(10.0*hue));\n\t\t\n\t\treturn exp(2.0*hue)*(red-noise*red);\n    }\n\tif (hue>0.8) {\n\t\tvec3 violet =  waveLengthToRGB(0.8);\n\t\tvec3 antiViolet = waveLengthToRGB(0.8)*(1.0-exp(-0.2*(hue-0.8)));\n\t\t\n\t\treturn (violet   +1.2*(1.0 -exp(-0.14*(hue-0.8) ))*vec3(1.0))*pow(hue+0.2, 1.4) ;\n    }\n\n\n\treturn waveLengthToRGB(hue);\n}\n\n\n#endif\n\n\n\n//Must be beta = length(v)\nmat4 LorentzBoost(in vec3 v, in float beta) {\n     float gamma = 1.0/sqrt(1.0-beta*beta);\n     vec3 gv = gamma * v;\n     float gm1 = gamma-1.0;\n     return mat4( 1.0+gm1*v.x*v.x,     gm1*v.x*v.y ,    gm1*v.x*v.z , -gv.x ,\n     \t       \t      gm1*v.x*v.y ,1.0+gm1*v.y*v.y ,    gm1*v.y*v.z , -gv.y ,\n\t\t              gm1*v.x*v.z,     gm1*v.y*v.z ,1.0+gm1*v.z*v.z , -gv.z ,\n\t\t                    -gv.x,           -gv.y ,          -gv.z , gamma );\n     //we only need the last column for the Doppler effect\n     //but for aberrations we need the full matrix\n}\nmat4 LorentzBoost(in vec3 v){\n    return LorentzBoost(v, length(v));\n}\n\n\nfloat DopplerShift(float hue, float factor){\n\tfloat freq = 1.0/(hue+1.0);\n\t//hue=1/freq-1\n\tfloat freqDoppl = freq*factor;\n\tfloat hueDoppl = 1.0/freqDoppl - 1.0;\n\treturn hueDoppl;\n}\n\nvec3 integrateRay(in light_params photon,in float real_vs_sim, in vec3 randSeed){\n   float coeffs[nDegree];\n   //float old_coeffs[nDegree];\n   float u0 = photon.u0;\n   float dudphi0 = photon.dudphi0;\n   float phi_approx = 1e5;\n   \n   float disk_phi = diskEventSolver(photon.r_hat.z, photon.r_perp.z);\n   vec3 color = vec3(0.0,0.0,1.0);\n   vec3 color_real = vec3(0.0,0.0,1.0);\n   int i=0;\n   vec3 disk_color = vec3(0.0, 0.0, 0.0);\n   vec3 disk_color_real = vec3(0.0, 0.0, 0.0);\n\n   int n_disk_passes = 0;\n   int n_disk_passes_real = 0;\n   const float blending_factor = 0.6;\n   float grav_well_Doppler = sqrt(1.0 - photon.u0);\n   \n   while(i<=MAX_STEPS && phi_approx>1e4){\n       calcWeierstrass( coeffs, u0, dudphi0 );\n       \n       float u1 = sum(coeffs);\n       float dudphi1 = dsum(coeffs);\n       \n       if(sign(u0)!=sign(u1) && u0>0.0 && u0 < 1.0){\n           //sky event          \n           phi_approx = -u0/(u1-u0) ;//+ float(i);\n//#ifdef USE_NEWTON_REFINE\n           phi_approx = skyEventSolver(coeffs, phi_approx);\n//#endif\n           phi_approx += float(i);\n           vec3 iDir = (photon.r_hat*cos(phi_approx) + photon.r_perp*sin(phi_approx));\n           float alpha = atan(iDir.x, iDir.y);\n           float beta = acos(iDir.z/length(iDir));\n           float shade =     mod(floor(alpha/PI*40.0) + floor(beta/PI*40.0),2.0); \n           \n           vec3 red = wideSpectrum(DopplerShift(0.05, photon.cam_Doppler*abs(grav_well_Doppler)),randSeed);\n           vec3 green = wideSpectrum(DopplerShift(0.38, photon.cam_Doppler*abs(grav_well_Doppler)),randSeed);\n           vec3 blue = wideSpectrum(DopplerShift(0.71, photon.cam_Doppler*abs(grav_well_Doppler)),randSeed);\n               \n           color_real = texture(iChannel0,vec2(alpha/PI/2.0 +0.5, beta/PI)).rgb  * grav_well_Doppler*grav_well_Doppler;\n           color_real = red*color_real.r + green*color_real.g + blue*color_real.b;\n           color = (shade * vec3(0.1, 0.1, 0.1) + (1.0-shade)*vec3(0.15,0.15,0.15));\n           //color_real = red*color.r + green*color.g + blue * color.b;\n           \n           \n       }\n       if(sign(u0-1.0)!=sign(u1-1.0) && u0>0.0 && u0<1.0 && u1 > 0.0){\n           //event horizon event\n           \n           float phi_approx_eh = -(u0-1.0)/(u1-u0);\n           phi_approx_eh = eventHorizonEventSolver(coeffs, phi_approx_eh); //Refining the event horizon is not really necessary if it is black\n           phi_approx_eh += float(i);\n           if(phi_approx_eh<phi_approx){\n               vec3 iDir = (photon.r_hat*cos(phi_approx_eh) + photon.r_perp*sin(phi_approx_eh));\n\n               float alpha = atan(iDir.x, iDir.y);\n               float beta = acos(iDir.z/length(iDir));\n               float shade =  mod(floor(alpha/PI*8.0) + floor(beta/PI*8.0),2.0); \n               phi_approx = phi_approx_eh;\n \n               color = shade * vec3(0.3, 0.0, 0.0) + (1.0-shade)*vec3(0.2,0.2,0.0);\n               color_real = vec3(0.0, 0.0, 0.0);\n            }\n       }\n       //phi_approx is the endpoint of the trajectory\n       if( float(i)<=disk_phi && float(i+1)>disk_phi && disk_phi < phi_approx ){\n           float u_disk = evalPoly(coeffs,disk_phi - float(i));\n           \n           if(1.0/u_disk>1.5 && 1.0/u_disk<100.0){\n               vec3 iDir = (photon.r_hat*cos(disk_phi) + photon.r_perp*sin(disk_phi));\n               float alpha = atan(iDir.x, iDir.y);\n               \n               \n               if( 1.0/u_disk<7.0){\n                   float shade =  mod(floor(1.0/u_disk) + floor(alpha/PI*10.0),2.0); \n                   disk_color = 0.9*disk_color + shade * vec3(0.7 ,.7 ,.4) + \n                                     (1.0-shade)*vec3(0.01, 0.01, 0.9)  ;\n                           //.0-blending_factor)*disk_color + \n                           //      blending_factor*( shade * vec3(0.7 ,.7 ,.4) + \n                           //          (1.0-shade)*vec3(0.01, 0.01, 0.9)  );\n                   n_disk_passes++;\n               }\n               float u_disk_diff = evalDerivPoly(coeffs,disk_phi - float(i));\n               vec3 photon_dir =  normalize(u_disk_diff*iDir + u_disk * (-photon.r_hat*sin(disk_phi) + photon.r_perp*cos(disk_phi)));\n               float disk_rot_beta_2 = 1.0/(2.0/u_disk - 2.0);\n               vec3 disk_rot_speed = -sqrt(disk_rot_beta_2)*vec3( cos(alpha), -sin(alpha), 0.0   ) ; \n               float gamma = 1.0/sqrt(1.0-disk_rot_beta_2);\n               vec3 gv = disk_rot_speed*gamma;\n               vec4 Lorentz_Last_Column = vec4( gv, gamma  );\n               vec4 photon_4vec_conjugate = vec4(photon_dir, 1.0); //the forth component is frequency\n               float velocityDoppler = photon_4vec_conjugate.w/dot(photon_4vec_conjugate, Lorentz_Last_Column);\n               float grav_Doppler = 1.0/sqrt(1.0 - u_disk)*grav_well_Doppler;\n               float fullDoppler = photon.cam_Doppler*velocityDoppler*grav_Doppler;\n               \n               vec3 d_orig_col =  2.0*exp(-0.25/u_disk + 0.36)* abs(texture(iChannel1,vec2((1.0/u_disk-3.0)/7.0, 0.98*abs(alpha+PI)/2.0/PI +0.01 )).rgb) / pow(fullDoppler,2.0);\n               \n               d_orig_col = clamp(d_orig_col, 0.0, 1.0);\n               \n               vec3 red = wideSpectrum(DopplerShift(0.05, abs(fullDoppler)),randSeed);\n               vec3 green = wideSpectrum(DopplerShift(0.38, abs(fullDoppler)),randSeed);\n               vec3 blue = wideSpectrum(DopplerShift(0.71, abs(fullDoppler)),randSeed);\n    \n               \n               disk_color_real += red*d_orig_col.r + green*d_orig_col.g + blue*d_orig_col.b;\n               n_disk_passes_real++;\n           }\n           disk_phi += PI; //the next disk event will be PI radian degrees further\n       }\n       \n       i++;\n       u0 = u1;\n       dudphi0 = dudphi1;\n   }\n//   if(n_disk_passes==0){\n//       return color;\n       //return mix(color, color_real, real_vs_sim);\n//   } else {\n       //float two_power = 1.0/float(1 << n_disk_passes);\n       //color = two_power*color + (1.0-two_power)*disk_color;\n       if(n_disk_passes!=0){\n           float blending_power = pow(blending_factor, float(n_disk_passes));\n           color = blending_power*disk_color + (1.0 - blending_power)*color;\n           color+=disk_color;\n       }\n       color_real += disk_color_real;\n       return mix(color, color_real, real_vs_sim);\n  // }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //added a small const, so the accreation disk is never seen from the edge\n    \n    vec2 mouse = -vec2(iMouse.x/iResolution.x * 2.0*PI  ,\n                        PI*iMouse.y/iResolution.y + PI/2.0 +0.01); \n                        \n    if (iMouse.xy==vec2(0)){\n        mouse = -vec2(0.0  , PI - 0.3); \n    }\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 randSeed = vec3(uv, iTime);\n    float screen_ratio = iResolution.y/iResolution.x;\n\n    \n    float dist = sin(iTime/3.0)*15.0+ 20.0;\n    float rot_phi = -mod(iTime/6.0, 2.0*PI);\n    float rot_psy = sin(iTime*0.1);\n    \n    \n    \n    \n    float psy = mouse.y ;//+ rot_psy;\n    float phi = mouse.x + rot_phi;\n    float invFOV = 0.5;\n\tvec3 ro = vec3(dist, 0.0, 0.0);\n    \n    \n    //Camera facing the black hole\n    vec3 rd=normalize(vec3(-invFOV,\n            uv.x - 0.5 , \n            screen_ratio*(0.5-uv.y )\n            ));\n            \n\n    \n    mat3 rotationYZ = mat3(cos(psy), 0.0, -sin(psy),\n                             0.0, 1.0, 0.0,   \n                         sin(psy), 0.0, cos(psy) );\n    mat3 rotationXZ = mat3( cos(phi), -sin(phi),0.0,                             \n                            sin(phi), cos(phi), 0.0,\n                            0.0, 0.0, 1.0);\n\n    float real_vs_sim = 1.0;//smoothstep(0.5, 1.5,   abs(phi) );   \n\n#define CAMLOR\n\n#ifdef CAMLOR\n    float ddist = cos(iTime/3.0)*5.0 ;\n    float dphi = -1.0/6.0*dist;\n    float dpsy = 0.0;//0.1* cos( iTime*0.1 )*dist;\n    \n    vec3 e_r = vec3(cos(psy)*cos(phi), -cos(psy)*sin(phi),    -sin(psy)  );  \n    vec3 e_phi = vec3( -cos(psy)*sin(phi), -cos(psy)*cos(phi), 0.0  );\n    vec3 e_psy = vec3( -sin(psy)*cos(phi), sin(psy)*sin(phi), -cos(psy)  );\n    vec3 cam_velocity = 0.1*(ddist*e_r + dphi*e_phi + dpsy * e_psy);\n    \n    float cam_beta = length(cam_velocity);    \n    float cam_beta_clamp = clamp(cam_beta,0.0, CAM_MAX_BETA);\n    mat4 cam_Lorentz = mat4( 1.0, 0.0, 0.0, 0.0, \n                             0.0, 1.0, 0.0, 0.0, \n                             0.0, 0.0, 1.0, 0.0,\n                             0.0, 0.0, 0.0, 1.0);\n\n\n    if(cam_beta>1e-6){\n       cam_Lorentz = LorentzBoost(cam_velocity*cam_beta_clamp/cam_beta,cam_beta_clamp);\n    }\n    \n    \n    vec4 ro4 = cam_Lorentz*vec4(rotationXZ*rotationYZ *ro, 1.0);\n    vec4 rd4 = cam_Lorentz*vec4(rotationXZ*rotationYZ *rd, 1.0);\n    vec3 cg = integrateRay(startParams(ro4.xyz, rd4.xyz,abs(rd4.w)), real_vs_sim,randSeed);\n        \n   \n    \n#else\n    \n    //ro = rotationXZ*rotationYZ *ro;\n    rd = rotationXZ*rotationYZ *rd;\n    vec3 cg = integrateRay(startParams(ro, rd, 1.0), real_vs_sim,randSeed);\n#endif\n    // Output to screen\n    \n    //vec3 color = shade * vec3(0.1, 0.1, 0.1) + (1.0-shade)*vec3(0.15,0.15,0.15);\n    fragColor = vec4(cg,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* \nThis buffer generates a starry background with nebulae and galaxies \n*/\n\n#define PI 3.14159265\n\nvec3 objDirection( in vec2 polar_angles ){\n    float sp = sin(polar_angles.y);\n    return normalize(vec3(  sp*sin(polar_angles.x), sp*cos(polar_angles.x),    cos(polar_angles.y)  ));\n}\n\nvec3 localObjCoordinates0(in vec2 polar_angles){\n   float cp = cos(polar_angles.y);\n    float sp = sin(polar_angles.y);\n    float cl = cos(polar_angles.x);\n    float sl = sin(polar_angles.x);\n    return normalize(vec3(  sp*cl , -sp*sl , 0.0 )); \n    //vec3 e0 = vec3(  sp*cl , -sp*sl , 0.0 );\n    //return e0/length(e0);\n}\n\nvec3 localObjCoordinates1(in vec2 polar_angles){\n   float cp = cos(polar_angles.y);\n    float sp = sin(polar_angles.y);\n    float cl = cos(polar_angles.x);\n    float sl = sin(polar_angles.x);\n    return normalize(vec3(  cp*sl, cp*cl,    -sp  ));\n    //vec3 e1 = vec3(  cp*sl, cp*cl,    -sp  );\n    //return e1/length(e1);\n}\n\n/*\nfloat wobbleSDF(in vec3 dirDiff, in vec2 starPolar, in float radius){\n    vec3 localCoordBase0 = localObjCoordinates0(starPolar);\n    vec3 localCoordBase1 = localObjCoordinates1(starPolar);\n    vec2 lc = vec2( dot(dirDiff, localCoordBase0), dot(dirDiff, localCoordBase1)  );\n    float lr = length(lc);\n    float lphi = atan(lc.y, lc.x);\n    //return lr; //disk\n    return lr - radius*pow(sin(6.0*lphi + 10.0*lr/radius),3.0); //spiral galaxy\n    //return lr - 0.01/abs(lc.y)- 0.01/abs(lc.x);// cross    \n}\n*/\n\n/*\n    Comments in structures are giving compilation errors in some browsers.\n    So here is the struct, need to start with the float:\n    \n    radius\n    polar angles\n    color and brightness\n    sinus amplitudes for spikes\n*/\n\nstruct skyObj{\n    float radius; \n    vec2 pos; \n    vec3 color; \n    vec4 spikes; \n};\n\nfloat wobbleSDFskyObj(in vec3 dirDiff, in skyObj obj){\n    vec3 localCoordBase0 = localObjCoordinates0(obj.pos);\n    vec3 localCoordBase1 = localObjCoordinates1(obj.pos);\n    \n    vec2 lc = vec2( dot(dirDiff, localCoordBase0), dot(dirDiff, localCoordBase1)  );\n    float lr = length(lc);\n    float lphi = atan(lc.y, lc.x);\n    \n    return lr - ( obj.spikes.x*pow(sin( obj.spikes.y*lphi + 10.0*lr/obj.radius  ), 3.0) + \n                        obj.spikes.z*pow(sin( obj.spikes.w*lphi + 10.0*lr/obj.radius   ), 3.0) )\n                        ;\n\n}\n\nfloat wobbleSDFstar(in vec3 dirDiff, in skyObj obj){\n    vec3 localCoordBase0 = localObjCoordinates0(obj.pos);\n    vec3 localCoordBase1 = localObjCoordinates1(obj.pos);\n    \n    vec2 lc = vec2( dot(dirDiff, localCoordBase0), dot(dirDiff, localCoordBase1)  );\n    float lr = length(lc);\n    float lphi = atan(lc.y, lc.x);\n    \n    return lr;\n\n}\n\n\n\n/*float starIntegralVec(in vec2 fragCoord){\n    vec2 uv = vec2(2.0*fragCoord.x, fragCoord.y)*PI/iResolution.xy; \n    vec3 myDir = objDirection(uv);\n    const vec4[NOBJ] stars = vec4[NOBJ](\n        vec4(0.1, 0.001, 0.03, 0.5),\n        vec4(1.2, 2.5, 0.2, 0.5),\n        vec4(PI, PI/2.0, 0.2, 0.5)\n    );\n    float color = 0.0;\n    for(int i=0; i!=NOBJ; i++){\n       vec3 starDir = objDirection(stars[i].xy);\n       float dist = acos(dot(starDir, myDir));\n       if( dist < stars[i].z*3.0 ){\n           //color+=stars[i].w;// + wobbleSDF( myDir - starDir, stars[i].xy);\n           float wsdf = wobbleSDF( myDir - starDir, stars[i].xy, stars[i].z);\n           if(wsdf < stars[i].z){ \n              \n               color+=stars[i].w - pow(wsdf,1.0) ;\n           }\n       }\n    }\n    return color;\n}*/\n\n//#define NOBJ 60\n#define NOBJ 21\n\n                           \nconst float phi=1.0;\nconst mat3 rotation = mat3(   cos(phi), 0.0 , sin(phi), \n                               0.0,      1.0,  0.0, \n                             -sin(phi), 0.0,  cos(phi));\nconst mat3 squeeze = mat3(   0.92, 0.0, 0.0, \n                             0.0, 1.0, 0.0,\n                             0.0, 0.0, 1.0);                           \n                           \nfloat sumReduction(in vec4 v){\n    return dot(v, vec4(1.0));\n}\n\n//Two Box-Mullers performed to create four normally distributed numbers\nvec4 BoxMuller(in vec4 u){\n    vec2 r = sqrt(-2.0*log(u.xy));\n    vec4 sc = vec4(sin(2.0*PI*u.z), cos(2.0*PI*u.z), sin(2.0*PI*u.w), cos(2.0*PI*u.w));\n    return vec4( r.x*sc.xy, r.y*sc.zw  );\n}\n\n#define NOffset 4\nivec2 tcoord(in int objIndex, in int objJ){\n    int linearIndex = objIndex*NOffset+objJ;\n    int i = linearIndex % 64;//mod(linearIndex,256);\n    int j = linearIndex / 64;\n    return ivec2( i, j   );\n}\n\nskyObj createObj(in int i){   \n   //vec4 rand0 = BoxMuller(texture(iChannel1, (vec2(tcoord(i, 0))  )/63.0));\n   //vec4 rand1 = texture(iChannel1, (vec2(tcoord(i, 1)))/63.0 );\n   vec4 rand0 = BoxMuller(\n          texelFetch(iChannel1, tcoord(i, 0), 0)  \n          +texelFetch(iChannel1, tcoord(i, 0), 2)/256.0\n          +texelFetch(iChannel1, tcoord(i, 0), 3)/65536.0\n          );\n   vec4 rand1 = texelFetch(iChannel1, tcoord(i, 1), 0 );\n   \n   \n   \n   \n   vec3 objDir = normalize(rand0.xyz);\n   float alpha = atan(objDir.x, objDir.y);\n   float beta = acos(objDir.z);\n   float radius = 0.0004*exp( -rand1.x ) + 0.00001;\n   float color_r = rand1.y;\n   vec3 color = vec3(0.0);\n   float brightness = -log(rand1.z*0.9+0.1) + 0.001;\n   if (color_r<0.2){\n       color+=(0.2-color_r) * vec3(1.0, 0.0, 0.0)/0.2;\n       color+=color_r*vec3(1.0)/0.2;\n   }\n   if(color_r>=0.2 && color_r<0.8){\n       color+=vec3(1.0);\n   }\n   if(color_r>=0.8){\n       color+=(1.0-color_r)*vec3(1.0)/0.2;\n       color+=(color_r-0.8)*vec3(0.0, 0.0, 1.0)/0.2;\n   }\n   \n   return skyObj(10.0*radius, vec2(alpha, beta), brightness*color, vec4(0.0));\n   \n}\n\nvec3 starIntegral(in vec2 fragCoord, in int frame){\n    vec2 uv = vec2(2.0*fragCoord.x, fragCoord.y)*PI/iResolution.xy; \n    vec3 myDir = objDirection(uv);\n    skyObj[NOBJ] stars = skyObj[NOBJ](\n        skyObj(0.03, vec2(0.1, 0.001),  vec3(0.5, 0.0, 0.1), vec4(0.03, 4.0, 0.01, 0.5)  ),\n        skyObj(0.2, vec2(1.2, 2.5),  vec3(0.0, 0.0, 0.6), vec4(0.2, 2.0, 0.01, 6.0)  ),\n        skyObj( 0.1, vec2(3.0, 2.0), vec3(0.0, 0.0, 0.9), vec4(0.2, 4.0, 0.01, 6.0)  ),\n        skyObj(0.03, vec2(PI, PI/2.0),  vec3(0.6, 0.6, 0.6), vec4(0.00, 0.0, 0.0, 0.0)  ),\n\n\n\nskyObj( 0.5895682477844743 ,vec2( 1.051379823603185 ,  1.078610375258671 ),  vec3( 0.19306572138150715 , 0.5336519324477846 , 0.5336519324477846 ), vec4(0.0)),\nskyObj( 0.8177603717044551 ,vec2( 0.5937326068279923 ,  1.1529192113546567 ),  vec3( 0.7296975533493334 , 0.3905712739723294 , 0.3905712739723294 ), vec4(0.0)),\nskyObj( 0.667531430516605 ,vec2( -0.19648224299024097 ,  1.6812410945458292 ),  vec3( 0.4970886048035049 , 0.7324469109291358 , 0.7324469109291358 ), vec4(0.0)),\nskyObj( 0.39488627406269533 ,vec2( -1.1328422152853173 ,  2.1741393011863104 ),  vec3( 0.7722633426101153 , 0.2853540822936024 , 0.2853540822936024 ), vec4(0.0)),\nskyObj( 0.4575862311522736 ,vec2( 2.2169331607093716 ,  1.0860685447660925 ),  vec3( 0.4980938899704889 , 0.8089088617871849 , 0.8089088617871849 ), vec4(0.0)),\nskyObj( 0.4067925890214923 ,vec2( 0.7592271743105445 ,  1.1226966658459079 ),  vec3( 0.5114328502000743 , 0.3007534426412809 , 0.3007534426412809 ), vec4(0.0)),\nskyObj( 0.6192115814514281 ,vec2( -1.261177280422573 ,  2.1273552695591706 ),  vec3( 0.4710599585277372 , 0.20254137176260537 , 0.20254137176260537 ), vec4(0.0)),\nskyObj( 0.48496550798755156 ,vec2( 1.0790349375070547 ,  1.0820218287510963 ),  vec3( 0.020296721551705456 , 0.8949977678622768 , 0.8949977678622768 ), vec4(0.0)),\nskyObj( 0.4429298310270741 ,vec2( -2.576893701344248 ,  1.921005321692863 ),  vec3( 0.06586706922876227 , 0.07483811253563419 , 0.07483811253563419 ), vec4(0.0)),\nskyObj( 0.7108242529316935 ,vec2( -0.724386680686273 ,  1.9558486300291247 ),  vec3( 0.7748984408940287 , 0.35980590654262734 , 0.35980590654262734 ), vec4(0.0)),\nskyObj( 0.8516061502448958 ,vec2( 3.121713842344482 ,  1.5456790412837376 ),  vec3( 0.6393492890498187 , 0.02955727033366964 , 0.02955727033366964 ), vec4(0.0)),\nskyObj( 0.42221342866544026 ,vec2( 0.5210768973077231 ,  1.2821786106349895 ),  vec3( 0.8872914408870712 , 0.5263036490581232 , 0.5263036490581232 ), vec4(0.0)),\nskyObj( 0.45809939188203147 ,vec2( -0.6817778261159484 ,  1.9758043012111692 ),  vec3( 0.7409674868288219 , 0.5572181894858742 , 0.5572181894858742 ), vec4(0.0)),\nskyObj( 0.6475139222415268 ,vec2( -0.3425334648189494 ,  1.7821863915823615 ),  vec3( 0.6263824668075911 , 0.11665921223893021 , 0.11665921223893021 ), vec4(0.0)),\nskyObj( 0.443086913595654 ,vec2( -1.2722324515403032 ,  2.132526967308545 ),  vec3( 0.6719952313615954 , 0.5308818488794469 , 0.5308818488794469 ), vec4(0.0)),\nskyObj( 0.5527654464526504 ,vec2( 1.8011120434927574 ,  1.0037420321112778 ),  vec3( 0.05510072179038692 , 0.63322482182783 , 0.63322482182783 ), vec4(0.0)),\nskyObj( 0.5609174909165113 ,vec2( 0.14981349269307548 ,  1.4875613687171219 ),  vec3( 0.7116289995687916 , 0.5391677461113722 , 0.5391677461113722 ), vec4(0.0))\n\n\n        \n\n\n\n\n\n);\n    vec3 color = vec3(0.0);\n    \n    if(frame == 0){\n        for(int i=0; i!=NOBJ; i++){\n           vec3 starDir = objDirection(stars[i].pos);\n           float dist = acos(dot(starDir, myDir));\n           if( dist < stars[i].radius*3.0 ){\n\n               float wsdf = wobbleSDFskyObj( myDir - starDir, stars[i]);\n               if(wsdf < stars[i].radius){ \n\n                   color+=max(stars[i].color - wsdf*vec3(1.0)/stars[i].radius,0.0 );\n               }\n           }\n        }\n    } \n    for(int i=frame*10; i!=frame*10+10; i++){\n       skyObj myStar = createObj(i);\n       vec3 starDir = objDirection(myStar.pos);\n       float dist =  acos(dot(starDir, myDir) );\n               //(1.0 - (dot(starDir, myDir)))*2.0*PI;\n       \n       if( dist < 3.0*myStar.radius ){\n           \n           //float wsdf = wobbleSDFstar( myDir - starDir, myStar);\n              \n               //color+=max(1.0-dist/myStar.radius, 0.0)*myStar.color;\n               color+=max(  myStar.color -  0.1*dist/myStar.radius*vec3(1.0),0.0   );\n       }\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    bool reset = iFrame == 0;        \n    vec2 mo = iMouse.xy == vec2(0) ? vec2(.125) : \n              abs(iMouse.xy)/iResolution.xy - .5;\n    mo = iChannelResolution[1].xy; \n    vec4 data = texelFetch(iChannel0, ivec2(0), 0);\n    if (round(mo*iResolution.xy) != round(data.yz) || round(data.w) != round(iResolution.x)) {\n        reset = true;\n    }\n    //reset = true;\n    if(all(equal(ivec2(fragCoord), ivec2(0)))) {\n        float iFr = data.x;\n        if(reset){\n            iFr = float(iFrame);\n        }\n        \n\t\tfragColor = vec4(iFr, mo*iResolution.xy, iResolution.x);\n    } else { \n        if( reset ){\n\n \n            vec3 col = starIntegral(fragCoord, 0);\n            fragColor = vec4(col,1.0); \n        } else {\n            fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n            if(iFrame - int(data.x)< 100){\n                fragColor += vec4(starIntegral(fragCoord, iFrame-int(data.x)), 0.0);\n            }\n        }\n    }\n   \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"struct specks{\n    vec2 pos; //start pos polar coordinates, r-3.0, phi/2/PI\n    vec2 width; //length in polar coordinates\n    vec3 color;\n};\n\nfloat lineSDF(in vec2 point, in vec2 start, in vec2 end){\n    vec2 line = end-start;\n    vec2 p2s = point-start;\n    float affine = clamp( dot(p2s, line)/dot(line, line), 0.0, 1.0);\n    return length(p2s - affine*line);\n}\n\n#define NOBJ 8\nvec3 diskIntegral( in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy; \n    \n    specks[NOBJ] objs = specks[NOBJ](\n        specks(vec2( 0.1, 0.6  ), vec2(0.1, 0.7) , 0.4*vec3(0.2, 1.0, 0.0)),\n        specks(vec2( 0.2, 0.2  ), vec2(0., 0.5), vec3(1.0, 1.0, 1.0) ),\n        specks(vec2( 0.34, 0.8  ), vec2(0.0,0.95) , 0.4*vec3(1.0, 1.0, 1.0)),\n        specks(vec2( 0.6, 0.7  ), vec2(0., 0.8) , 0.2*vec3(1.0, 1.0, 0.0)),\n        specks(vec2( 0.73, 0.1  ), vec2(0., 0.9) , 0.6*vec3(1.0, 1.0, 0.4)),\n        specks(vec2( 0.75, 0.1  ), vec2(0., 1.0) , 0.3*vec3(1.0, 1.0, 1.0)),\n        specks(vec2( 0.83, 0.8  ), vec2(0.01, 0.7) , 0.6*vec3(0.2, 0.2, 0.0)),\n        specks(vec2( 0.9, 0.0  ), vec2(0., 0.94) , 0.5*vec3(1.0, 1.0, 1.0))\n        \n    );\n    vec3 color = vec3(1.0);\n    for(int i=0; i<NOBJ; i++){\n        \n        float dist = lineSDF( uv, objs[i].pos, objs[i].pos + objs[i].width );\n        float ampl = exp( -20.0*dist );\n        dist = lineSDF( vec2(uv.x, uv.y+1.0), objs[i].pos, objs[i].pos + objs[i].width );\n        ampl += exp( -20.0*dist );\n        dist = lineSDF( vec2(uv.x, uv.y-1.0), objs[i].pos, objs[i].pos + objs[i].width );\n        ampl += exp( -20.0*dist );\n        color -= ampl*objs[i].color;\n    }\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool reset = iFrame == 0;        \n    vec2 mo = iMouse.xy == vec2(0) ? vec2(.125) : \n              abs(iMouse.xy)/iResolution.xy - .5;\n    mo = vec2(0.0); //removed the mouse trigger, so the Buffer is not redwrawn on a click\n    vec4 data = texelFetch(iChannel0, ivec2(0), 0);\n    if (round(mo*iResolution.xy) != round(data.yz) || round(data.w) != round(iResolution.x)) {\n        reset = true;\n    }\n    \n    if(all(equal(ivec2(fragCoord), ivec2(0)))) {\n        \n        \n\t\tfragColor = vec4(0.0, mo*iResolution.xy, iResolution.x);\n    } else { \n        if( reset ){\n\n            vec3 s = diskIntegral(fragCoord);\n            fragColor = vec4(s, 1.0);\n\n        } else {\n            fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        }\n    }\n   \n}","name":"Buffer B","description":"","type":"buffer"}]}