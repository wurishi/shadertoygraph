{"ver":"0.1","info":{"id":"dlSGDV","date":"1673930371","viewed":84,"name":"Infinite Crossing","username":"Aurcereal","description":"a bit claustrophobic - goes faster with song.. unfortunately wrote this for a 144hz monitor","likes":2,"published":1,"flags":96,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"clSGWy","parentname":"Infinite Cells v0.6"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define D2R .0174533\n#define R2D 57.29578\n#define PI 3.14159265\n\n#define MAXSTEPS 100\n#define MAXDIST 90.\n#define SDEPS 0.002 //0.005\n#define NORMEPS 0.001 //0.05\n\nvec3 camPos;\nfloat cellSize = 3.*2.;\nfloat simSpd = 0.14; //0.5\nfloat simTime = 0.;\nfloat t;\n\n//-=-=-=- Audio Stuff -=-=-=- unused rn\nfloat cellPosToVolume(vec3 cellPos) \n{\n    vec3 dim = vec3(6.0*cellSize, 6.0*cellSize, 2.0*cellSize);\n    \n    cellPos -= camPos;\n    cellPos += dim*.5;\n    \n    float unravel = cellPos.x + cellPos.y * dim.x *.1  + mod(cellPos.z, dim.z) * dim.x * dim.y*.001;\n    unravel /= 10000.;\n    float volume = texture(iChannel0, vec2(unravel, 0.)).x;\n    \n    return smoothstep(0.6, 1.0, volume); //.9, .85, .4, .6\n}\n//-=-=-=-\n\nfloat deadCell(vec3 cell)\n{\n    float size = cellSize;//+0.1+25.0;\n    cell = abs(cell);\n    return MAXDIST*(1.-min(1., step(size, cell.x) + step(size, cell.y) + step(size, cell.z)));\n}\n\nfloat boundCell(float boundID, vec2 boundedRegion, vec3 cellPos) //boundedRegion is normalized where [-1, 1] is max boundId\n{\n    float dist = cellSize*2.;\n    float interpolation = clamp(1.0 - (length(cellPos - camPos)-cellSize*(.4+.3+.4) + 0.0*pow(length(cellPos.xy - camPos.xy), 1.4))/dist, 0., 1.);\n    interpolation = (1.0 - pow(1.0 - interpolation, 1.5)) * smoothstep(1.0, .8, 1.0-interpolation);\n    \n    return mix(boundID, (boundedRegion.x + boundedRegion.y)*.5 + boundID * (boundedRegion.y-boundedRegion.x)*.5, interpolation);\n}\n\nfloat sdf(vec3 p)\n{\n    //setup\n    vec3 fo = vec3(0.0, 0.0, 1.0), up = vec3(0.0, 1.0, 0.0), ri = vec3(1.0, 0.0, 0.0);\n    \n    float dim = .5*cellSize*.15;//.25;\n    \n    p += cellSize*.5;\n    vec3 lp = mod(p, cellSize);\n    //lp -= cellSize*.5;\n    \n    vec3 cellPos = p - lp + cellSize*.5;\n    lp -= cellSize*.5;\n    \n    //time\n    float tt = iTime*.5+texelFetch(iChannel0, ivec2(1), 0).x*.003; //.4, .005\n\n    //ids .25 .9, .1 .8\n    vec2 idRi = sin(600.*hash32flr(cellPos + ri*cellSize*.5)+3.*tt+1.*cellPosToVolume(cellPos+ri*cellSize*.5)); idRi = vec2(boundCell(idRi.x, vec2(.6, 1.), cellPos+ri*cellSize*.5), idRi.y)*(cellSize*.5-dim);\n    vec2 idLe = sin(600.*hash32flr(cellPos - ri*cellSize*.5)+3.*tt+1.*cellPosToVolume(cellPos-ri*cellSize*.5)); idLe = vec2(boundCell(idLe.x, vec2(.6, 1.), cellPos-ri*cellSize*.5), idLe.y)*(cellSize*.5-dim);\n    \n    vec2 idUp = sin(600.*hash32flr(cellPos + up*cellSize*.5)+3.*tt+1.*cellPosToVolume(cellPos+up*cellSize*.5)); idUp = vec2(boundCell(idUp.x, vec2(.6, 1.), cellPos+up*cellSize*.5), idUp.y)*(cellSize*.5-dim);\n    vec2 idDo = sin(600.*hash32flr(cellPos - up*cellSize*.5)+3.*tt+1.*cellPosToVolume(cellPos-up*cellSize*.5)); idDo = vec2(boundCell(idDo.x, vec2(.6, 1.), cellPos-up*cellSize*.5), idDo.y)*(cellSize*.5-dim);\n    \n    //vec2 idFo = sin(600.*hash32flr(cellPos + fo*cellSize*.5)+3.*simSpd*iTime)*(cellSize*.5-dim);\n    //vec2 idBa = sin(600.*hash32flr(cellPos - fo*cellSize*.5)+3.*simSpd*iTime)*(cellSize*.5-dim);\n    \n    //xDists\n    float xSplit = idUp.x;\n    float dRi = sdCubeTube(lp, vec3(cellSize*.8, idRi), vec3(xSplit, idRi.x, idRi.y), dim, up) + deadCell(cellPos + ri*cellSize);\n    float dLe = sdCubeTube(lp, vec3(-cellSize*.8, idLe), vec3(idDo.x, idLe), dim, up) + deadCell(cellPos - ri*cellSize);\n    \n    float compHor = dim*.5*sign(idRi.y-idLe.y);\n    float compVer = dim*.5*sign(idRi.x-idLe.x);\n    float dConXHo = sdCubeTube(lp, vec3(xSplit, idLe.x, idLe.y-compHor), vec3(xSplit, idLe.x, idRi.y+compHor), dim, up) + deadCell(cellPos + ri*cellSize);\n    float dConXVe = sdCubeTube(lp, vec3(xSplit, idLe.x, idRi.y), vec3(xSplit, idRi.x+compVer, idRi.y), dim, ri) + deadCell(cellPos + ri*cellSize);\n    \n    float dUp = sdCubeTube(lp, vec3(idUp.x, cellSize*.8, idUp.y), vec3(idUp.x, (idLe.x + idRi.x)*.5, idUp.y), dim, ri) + deadCell(cellPos + up*cellSize);\n    float dConUpHo = sdCubeTube(lp, vec3(idUp.x, (idLe.x + idRi.x)*.5, idUp.y - dim*.5*sign(idRi.y - idUp.y)), vec3(idUp.x, (idLe.x + idRi.x)*.5, idRi.y), dim, up) + deadCell(cellPos + up*cellSize);\n    \n    float dDo = sdCubeTube(lp, vec3(idDo.x, -cellSize*.8, idDo.y), vec3(idDo.x, idLe.x, idDo.y), dim, ri) + deadCell(cellPos - up*cellSize);\n    float dConDoHo = sdCubeTube(lp, vec3(idDo.x, idLe.x, idDo.y - dim*.5*sign(idLe.y - idDo.y)), vec3(idDo.x, idLe.x, idLe.y + dim*.5*sign(idLe.y - idDo.y)), dim, up) + deadCell(cellPos - up*cellSize);\n    \n    \n    \n    //2nd degree dist\n    float dOut = -1.*sdRectPrism(lp, fo, up, 1.1*cellSize, 1.1*cellSize);\n    \n    //cut camera\n    float dCam = -1.;//*sdRectPrism(p - camPos, fo, up, 2.5*cellSize, 2.5*cellSize);//(length(p - cellSize*.5 - camPos) - cellSize*.3);\n    \n    return min(dOut,deadCell(cellPos)+min(min(min(min(min(min(min(dRi, dLe), dConXHo), dConXVe), dUp), dConUpHo), dDo), dConDoHo));\n    \n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(NORMEPS, 0.0);\n\n    return normalize(\n        vec3(sdf(p + e.xyy) - sdf(p - e.xyy),\n             sdf(p + e.yxy) - sdf(p - e.yxy),\n             sdf(p + e.yyx) - sdf(p - e.yyx)\n             ));\n             \n}\n\nvec3 normal(vec3 p, float edge) //dont wanna do usual overloading cuz extra method call idk if inline\n{\n    vec2 e = vec2(edge, 0.0);\n\n    return normalize(\n        vec3(sdf(p + e.xyy) - sdf(p - e.xyy),\n             sdf(p + e.yxy) - sdf(p - e.yxy),\n             sdf(p + e.yyx) - sdf(p - e.yyx)\n             ));\n}\n\nfloat trace(vec3 ro, vec3 rd, out int steps)\n{\n    float d = 0.0, sd;\n    steps = 0;\n    \n    for(int i=0; i<MAXSTEPS; i++)\n    {\n        sd = sdf(ro+rd*d);\n        d += sd; steps++;\n    \n        if(abs(sd) < SDEPS || d >= MAXDIST) {return d;}\n    }\n    return MAXDIST; //better to cut then to badly sample normal\n}\n\nvec3 shade1(vec3 pos, vec3 norm)\n{\n    return floor(max(0., dot(norm, normalize(vec3(1.,1.,1.))))*4.0)/4. * vec3(1.0);\n}\n\nvec3 shade2(vec3 pos, vec3 norm, float steps) //maybe shade3 domain repeated lights?\n{\n    vec3 lightPos = camPos;\n    vec3 lightDir = normalize(pos - lightPos);\n    \n    float diffuseFalloff = dot(norm, -lightDir);\n    diffuseFalloff = max(0.1, diffuseFalloff) * (9.5 / pow(length(pos - camPos), .8)); //100-2, 30-1.3, \n    \n    vec3 camRay = normalize(pos - camPos);\n    float spec = dot(normalize(camRay - dot(camRay, norm) * 2.0 * norm), -lightDir);\n    spec = pow(max(0., spec), 64.0);\n    \n    //vec3 edgeNorm = normal(pos, 0.08);\n    //float edge = step(0.04, 1.0-dot(edgeNorm, norm));\n    //maybe try to implement different way where you go along the two axis projected on the norm\n    //and more detailed like see if the distance changes A LOT or maybe it goes negative which would be inside the wall so we dont care\n    //abt that\n    \n    return diffuseFalloff * vec3(.7) + spec * vec3(0.) + vec3(.05) * (1.0 - steps/128.0);// vec3(cellPosToVolume(pos - camPos)); \n    \n}\n\nvec3 render(vec2 fragCoord)\n{\n    //get sim time\n    //simTime = texelFetch(iChannel0, ivec2(1), 0).x*.5;\n    t = iTime*1.3 + texelFetch(iChannel0, ivec2(1), 0).x*.035; //.08, .095, .05, 1.3-.035\n    \n    //cam specs (fo .7 sincos switch)\n    vec3 fo = vec3(sin(iTime*.0*simSpd), 0.0, cos(iTime*.0*simSpd)), up = vec3(sin(t*.2), cos(t*.2), 0.0), ri = cross(up, fo); //HARDCODE cam space\n    float fovMultX = 1.0, fovMultY = .57735;                                           //HARDCODE fov TRIG\n    camPos = vec3(1.*cos(2.*iTime), -5.*0., 3.2*t);                                                //HARDCODE cam pos\n    \n    //make rayWS\n    vec3 ray = normalize(vec3(((fragCoord/iResolution.xy)*2.0-1.0) * vec2(fovMultX, fovMultY), 1.0));\n    ray = ray.z * fo + ray.y * up + ray.x * ri;\n    \n    //trace\n    int steps;\n    float dist = trace(camPos, ray, steps);\n    \n    //vignette\n    vec2 dists = (1.0 - abs(fragCoord/iResolution.xy*2.0-1.0)) * vec2(iResolution.x/iResolution.y, 1.0);\n    float vignette = max(0., 1.0 - pow(min(dists.x, dists.y), 2.0)) * .4;\n    \n    //skybox\n    if(dist >= MAXDIST) { return mix(acos(-ray.y) * vec3(.1), vec3(0.), vignette);}\n    \n    //hit\n    return mix(mix(shade2(camPos + ray*dist, normal(camPos + ray*dist), float(steps)), acos(-ray.y) * vec3(.1), smoothstep(MAXDIST - 40.0-10., MAXDIST-10., dist)), vec3(0.), vignette);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 e = vec2(.5, 0.);\n    //vec3 col = .25*(render(fragCoord) + render(fragCoord+e.xy) + render(fragCoord+e.yx)+render(fragCoord+e.xx));\n    fragColor = vec4(render(fragCoord), 1.0);\n    //fragColor = vec4(vec3(smoothstep(.5, 1., texelFetch(iChannel0, ivec2(0), 0).x)), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec2 hash32(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash32flr(vec3 p3) //floor is useful since unwanted tiny variations can lead to major different results\n{\n    p3 = floor(p3);\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash31flr(vec3 p3)\n{\n    p3 = floor(p3);\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//-=-=- HELP -=-=-\n\nvec3 arot(vec3 vec, vec3 axis, float o)\n{\n    \n    vec3 proj = vec - dot(vec, axis) * axis;\n    vec3 right = normalize(proj);\n    vec3 up = cross(axis, right);\n    \n    return length(proj) * cos(o) * right + length(proj) * sin(o) * up + dot(vec, axis) * axis;\n    \n    //gonna try to twist while marching like that tentacle shader\n}\n\nvec2 regionSelect(vec2 r1, vec2 r2, float split, float a)\n{\n    float select = step(split, a);\n    return r2 * select + r1 * (1.-select);\n}\n\n//-=-=- SD Funcs -=-=-\n\nfloat sdCircle(vec3 p, float r) //origin = vec3(0.)\n{\n    return length(p) - r;\n}\n\nfloat sdRectPrism(vec3 p, vec3 forward, vec3 up, float thickness, float len) //origin = vec3(0.0)\n{\n    vec3 right = cross(forward, up);\n\n    p = vec3(dot(p, right), dot(p, up), dot(p, forward));\n    //p = vec3(p.x - .5*thickness, p.y - .5*thickness, p.z - len * .5);\n    p = abs(p);\n    \n    float dist2D = 0.0;\n    \n    float distX = p.x - .5*thickness;\n    float distY = p.y - .5*thickness;\n    float distZ = p.z - .5 * len;\n    \n    if(distX > 0. && distY > 0.)\n    {\n        dist2D = sqrt(distX*distX + distY*distY);\n    }\n    else if(distY > 0.)\n    {\n        dist2D = distY;\n    }\n    else if(distX > 0.)\n    {\n        dist2D = distX;\n    }\n    else\n    {\n        return max(distZ, max(distX, distY));\n    }\n    \n    return sqrt(pow(dist2D,2.) + pow(max(0., distZ),2.));\n    \n}\n\nfloat sdCubeTube(vec3 p, vec3 origin, vec3 end, float thickness, vec3 up)\n{\n    float DNE = step(length(end - origin), 0.);\n    return sdRectPrism(p - (end+origin)*.5, normalize(end-origin), up, thickness, length(origin - end)) + DNE*1000.;\n}\n\nfloat sdCylinder(vec3 p, vec3 pos, vec2 dim, vec3 fo) //scaled out of fo and ba\n{\n    float y = abs(dot(p - pos, fo));\n    float x = length(cross(p - pos, fo));\n    \n    if(y > dim.y*.5)\n    {\n        return sqrt(pow(y-dim.y*.5, 2.) + pow(max(x-dim.x, 0.), 2.));\n    }\n    \n    return max(y - dim.y*.5, x - dim.x);\n}\n\nfloat sdCylinder(vec3 p, vec3 origin, vec3 end, float thickness)\n{\n    return sdCylinder(p, (origin + end)*.5, vec2(thickness, length(end - origin)), normalize(end - origin));\n}\n\n//-=-=-=- Hash Boundary -=-=-=-\n//unused\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"lljSWc","filepath":"https://soundcloud.com/gayger_lame/the-bridge-people-no-longer-cross","previewfilepath":"https://soundcloud.com/gayger_lame/the-bridge-people-no-longer-cross","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define ROUGHNESS .005 //.005, .003\n\nfloat sampleAverageVolume()\n{\n    //sample average from the first 8th of the waveform\n    //we wont use for loop we'll unravel everything even if it makes it look horrible (for performance)\n    \n    return .2*(texture(iChannel0, vec2(0. * .125, 0.)) + texture(iChannel0, vec2(.25 * .125, 0.)) + texture(iChannel0, vec2(.5 * .125, 0.)) + texture(iChannel0, vec2(.75 * .125, 0.)) + texture(iChannel0, vec2(1. * .125, 0.))).x;\n    \n}\n\nfloat linearstep(float e1, float e2, float val)\n{\n    return clamp((val-e1)/(e2-e1), 0., 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    /*if(iTime < 0.01 || ivec2(fragCoord) != ivec2(0, 0))\n    {\n        fragColor = vec4(0., 0., 0., 1.);\n    }\n    else\n    {\n        fragColor = vec4(texelFetch(iChannel1, ivec2(0), 0).x * (1.-ROUGHNESS) + ROUGHNESS * sampleAverageVolume(), 0., 0., 1.);\n    }\n    */\n    \n    fragColor = vec4(0.,0.,0.,1.);\n    \n    if(iTime > 0.01) //.5-1., .63-.8, .4-1.\n    {\n        if(ivec2(fragCoord) == ivec2(0))\n            fragColor = vec4(texelFetch(iChannel1, ivec2(0), 0).x * (1.-ROUGHNESS) + ROUGHNESS * pow(linearstep(.57, .8, min(.7, sampleAverageVolume())), .5), 0., 0., 1.);\n        if(ivec2(fragCoord) == ivec2(1))\n            fragColor = vec4(texelFetch(iChannel1, ivec2(1), 0).x + texelFetch(iChannel1, ivec2(0), 0).x, 0., 0., 0.);\n    }\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}