{"ver":"0.1","info":{"id":"dd2GzW","date":"1667334752","viewed":74,"name":"Gaussian function __","username":"Envy24","description":"https://en.wikipedia.org/wiki/Gaussian_function\n\nefr:\nhttps://www.shadertoy.com/view/Xl2yRV","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["normal","derivative","gaussian","integral","error","distribution","erf","graphs","definite","indefinite"],"hasliked":0,"parentid":"mdjGzW","parentname":"Exponential Impulse"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* This method works for explicit ( y=f(x) ) and implicit ( d=f(x,y,...) ) functions. */\n#define R                         ( iResolution )\n#define AR                        ( R.x / R.y )                      // Aspect ratio.\n#define UNIT                      ( 8.0 / R.y )                      // Affects AA and thickness\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n#define SCENE_SCALE               ( 1.5 )\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat draw_explicit_func(vec2 NDC, float fx, float dfdx)\n{\n    float sdf = NDC.y - fx;\n    return SMAA(abs(sdf) / sqrt(1.0 + dfdx * dfdx)); // absolute value / arclenght over unit length interval\n}\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - R.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin)\n{\n    return ((2. * (SC - MOUSE_OFFSET) - R.xy) / R.y) * scale - origin;\n}\n\nvec3 colorize_area_under_curve(\n    vec2 NDC,\n    float fx,\n    float dfdx,\n    vec2 range,\n    vec3 color)\n{\n    float sign = \n        fx > 0. ? 1. : -1.;\n    float sdf = (NDC.y - fx);\n\n    vec3 c =\n        (fx >= 0. && NDC.y < 0.) ||\n        (fx < 0. && NDC.y >= 0.) ?\n            color :\n            mix( color, vec3(1,0,1), SMAA(sign*sdf / sqrt(1.0 + dfdx * dfdx)) );\n            \n    return \n        NDC.x >= min(range.x, range.y) &&\n        NDC.x <= max(range.x, range.y) ?\n            c :\n            color;\n}\n\n/* f(x) = a*exp( -[(x-b)*(x-b)]/(2*c*c ) */\nfloat f(\n    float x,\n    float scale, // a\n    float width, // c\n    float offset)// b\n{\n    float X = x - offset;\n    return scale*exp(-(X*X) / (2.*width*width));\n}\nfloat deriv(\n    float x,\n    float scale,\n    float width,\n    float offset)\n{\n    float X = x - offset,\n          inv_ww = 1./(width*width);\n    return scale*exp(-(X*X)*(0.5*inv_ww))*(-X*inv_ww);\n}\n/**\nfloat erf(float x)\n{\n    const float PI = 3.1415926535897932;\n    float count = 128.,\n          dx = x / count,\n          dxdx = dx*dx,\n          C = 2./sqrt(PI);\n          x = 0.;\n          \n    for (float i = 1.; i < count; i += 1.)\n    {\n        x += C*exp(-((i*i * dxdx)));\n    }\n    \n    return x*dx;\n}\n/**/\n// https://en.wikipedia.org/wiki/Error_function#Approximation_with_elementary_functions\n// https://www.shadertoy.com/view/Xl2yRV\nfloat erf(float x)\n{\n\tbool neg = x < 0.0;\n    \n    const float a = 0.147;\n    const float b = 1.27324;//4.0/Pi\n    \n    float xx = x*x;\n    float xxa = xx*a;\n    float y = sqrt(1.0 - exp(-xx * (xxa + b) / (xxa + 1.0)));\n    \n    return neg ? -y : y;\n}\n/**\n//https://www.shadertoy.com/view/7sKSRh\nfloat erf(in float x) {\n    //return sign(x) * sqrt(1.0 - exp(-1.239192 * x * x));\n    return sign(x) * sqrt(1.0 - exp2(-1.787776 * x * x)); // likely faster version by @spalmer\n}\n/**/\nfloat indef(\n    float x,\n    float scale,\n    float width,\n    float offset)\n{\n    // 1/sqrt(2) = 0.70710678118\n    // sqrt(PI)/sqrt(2.) = 1.25331413732\n    return scale*width*1.25331413732*erf(0.70710678118*(x-offset)/width);\n}\nfloat def(\n    float l,\n    float r,\n    float scale,\n    float width,\n    float offset)\n{\n    return indef(r, scale, width, offset) - indef(l, scale, width, offset);\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0, -1));\n\n    vec3 color = vec3(1.);\n \n/* Define explicit function and derivative. */\n     float scale = sinOSC(1., 2., iTime),\n           width = sinOSC(0.25, 3., iTime * 1.3),\n           offset = sinOSC(-1., 1., iTime * 0.3);\n#define func(x) ( f(x, scale, width, offset) )\n#define dfdx(x) ( deriv(x, scale, width, offset) )\n#define I(x)    ( indef(x, scale, width, offset) )\n/**/     \n    float fx = func(NDC.x), deriv = dfdx(NDC.x);\n   \n    float l = sinOSC(-AR * SCENE_SCALE, AR * SCENE_SCALE, iTime*0.3),\n          r = sinOSC(-AR * SCENE_SCALE, AR * SCENE_SCALE, iTime);\n    vec2 range = vec2(l, r);\n    \n    /* Ranges */\n    color -= vertical_line(NDC, l)*.5;  color -= vertical_line(NDC, r)*.5;\n    \n    /* Area under curve. */\n    color = colorize_area_under_curve(NDC, fx, deriv, range, color);\n      \n    /* Explicit function y=f(x) */\n    color = mix(color, vec3(0,1,0), draw_explicit_func(NDC, fx, deriv));\n\n    /* Coordinates axis */\n    color -= x_axis(NDC); color -= y_axis(NDC);\n\n    /* Cells */\n#define CELL_SIZE 1\n         NDC = mod(NDC, vec2(CELL_SIZE)); \n         color -= vertical_line(NDC, 0.)*.2;  color -= horizontal_line(NDC, 0.)*.2; // comment this line if you not use mod\n         color -= vertical_line(NDC, -1.)*.2; color -= horizontal_line(NDC, -1.)*.2;         \n         color -= vertical_line(NDC, 1.)*.2;  color -= horizontal_line(NDC, 1.)*.2; \n    /* */ \n        \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}","name":"Common","description":"","type":"common"}]}