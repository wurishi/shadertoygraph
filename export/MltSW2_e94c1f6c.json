{"ver":"0.1","info":{"id":"MltSW2","date":"1481712385","viewed":145,"name":"Rectangle AA","username":"kd_christoph","description":"playing around with fwidth","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d","antialiasing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const highp float pi = 3.14159;\n\n#define adaptive\n#define AA\n\n//Rect (2point)   x1  y1   x2   y2\nvec4 rect = vec4(0.1, 0.2, 0.7, 0.6);\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv - vec2(0.5);\n    \n    //rotMatrix\n    float angle = (45.0/360.0 * 2.0 * pi);\n    mat2 rot = mat2( cos(angle), -sin(angle),\n                     sin(angle),  cos(angle) );\n    vec2 uv_rot = uv * rot;\n    \n    rect *=0.5+(sin(iTime*0.05))/2.0;\n    \n    vec2 d = max(rect.xy-uv_rot, uv_rot-rect.zw);\n    float dist = length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));\n\n//calculate AA amount based on distance in terms of pixels\n#ifdef adaptive\n    vec2 thresh = vec2(fwidth(dist)*2.0);\n//calculate AA based on fixed value\n#else\n    vec2 thresh = vec2(0.003);\n#endif\n\n//smoothstep --> AA\n#ifdef AA\n    vec2 hv = smoothstep(rect.xy-thresh, rect.xy, uv_rot) * smoothstep(uv_rot-thresh, uv_rot, rect.zw);\n//step --> no AA\n#else\n    vec2 hv = step(rect.xy, uv_rot) * step(uv_rot, rect.zw);\n#endif\n\n    //build the rectangle out of 2 infinite quadrants\n    float onOff = hv.x * hv.y;\n    \n    //draw background\n    vec4 col = vec4(0,0,0,0);\n    //draw rectangle\n    col =  mix(col, vec4(1,0,0,0), onOff);\n    //optionally draw distance field ontop\n    col = mix(col, vec4(1.0,1.0,0,0), -dist*10.0);\n\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}