{"ver":"0.1","info":{"id":"NttfDB","date":"1663617932","viewed":275,"name":"Fork Rocket Mach","username":"Carandiru","description":"400s @ 75FPS converged mach bands. screenshot posted below.\nThis is a forked shader, original by  michael0884  @  https://www.shadertoy.com/view/3llcRj\nIntended to show how to amplify mach bands..","likes":9,"published":3,"flags":32,"usePreview":0,"tags":["particles","ca"],"hasliked":0,"parentid":"3llcRj","parentname":"Rocket Mach Diamonds"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 400s @ 75FPS converged mach bands. screenshot posted below.\n// This is a forked shader, original by  michael0884  @  https://www.shadertoy.com/view/3llcRj\n// Intended to show how to amplify mach bands. amplify thrust, etc.\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    //pos = R*0.5 + pos*0.1;\n    ivec2 p = ivec2(pos);\n    \n    //cur particle\n    vec4 U = decode(texel(ch0, pos).zw);\n    \n    //pressure\n    vec4 P = textureLod(ch1, pos/R, 0.);\n    \n    //border render\n    vec3 bord = smoothstep(border_h-1.,border_h-3.,border(pos))*vec3(1.);\n    \n    //particle render\n    float rho = 0.;\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec4 data = texel(ch0, p + ivec2(i,j));\n        vec4 vm0 = decode(data.zw);\n        vec2 x0 = data.xy; //update position\n        //how much mass falls into this pixel\n        rho += 1.*vm0.z*G((pos - x0)/1.);\n    }\n    \n    rho = tanh(8.*rho);\n    \n     vec4 D = pixel(ch2, pos);\n    float ang = atan(D.x, D.y);\n    float mag = 0. + 40.*dot(D.xy,D.xy)*rho*rho*rho;\n    \n    // Output to screen\n    fragColor = vec4(1.*vec3(0.4,0.5,1.)*rho + mag + bord + 0.*abs(P.x),0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define Bf(p) p\n#define Bi(p) ivec2(p)\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.\n\n#define border_h 5.\nvec2 R;\nfloat time;\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdSph( in vec2 p, in float r )\n{\n    return length(p) - r; \n}\n\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.52, 0.5)); \n    \n    float box = 100000.;//sdSph(p - R*vec2(0.2, 0.3), R.x*0.04);\n    //box =min(box, sdSph(p - R*vec2(0.2, 0.7), R.x*0.04));\n    float drain = -sdBox(p - R*vec2(0.9, 0.05), vec2(0));\n    return max(drain,min(bound, box));\n}\n\n#define h 0.1\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(x.x) + 65535u*uint(x.y);\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec4 decode(vec2 x)\n{\n    uint v = floatBitsToUint(x.x);\n    //uint m = floatBitsToUint(x.y);\n    return vec4(unpack(v),x.yy); \n}\n\nvec2 encode(vec4 x)\n{\n    uint v = pack(x.xy);\n    //uint m = pack(x.zw/1.);\n    return vec2(uintBitsToFloat(v),x.z); \n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define mass 0.1\n#define div 0.7\n\nvec2 Force(vec2 dx)\n{\n    return 0.*dx*exp(-dot(dx,dx));\n}\n\nvec2 P(vec2 p)\n{\n    return pixel(ch1, p).zw;\n}\n\n//diffusion amount\n#define dif 1.07\nvec3 distribution(vec2 x, vec2 p)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - dif*0.5, x + dif*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(dif*dif); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime;\n    ivec2 p = ivec2(pos);\n        \n    //particle velocity, mass and grid distributed density\n    vec4 vm = vec4(0.);\n    vec2 F = vec2(0., -0.00);\n    vec2 dF = vec2(0.);\n    \n    //particle position\n    vec2 x = pos*vm.z;\n\n    //reintegration advection\n    //basically sum over all updated neighbors \n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec4 data = texel(ch0, p + ivec2(i,j));\n        vec4 vm0 = decode(data.zw);\n       \n        vec2 vv = vm0.xy;\n        vec2 xx = data.xy + vv*dt; //integrate position\n\n        vec3 D = distribution(xx, pos);\n\n        //the deposited mass into this cell\n        float m = vm0.z*D.z;\n        //local center of mass in this cell\n        xx = D.xy; \n\n        //add weighted positions by mass\n        x += xx*m;\n        //add weighted velocities by mass\n        vm.xy += vv*m;\n        //add mass\n        vm.z += m;\n    }\n    \n    if(vm.z != 0.)\n    {\n        //normalize\n        x /= vm.z;\n        vm.xy /= vm.z;\n\n        //update velocity\n        //border \n        vec3 N = bN(x);\n        N.z += 0.1;\n\n        float vdotN = step(abs(N.z), border_h)*dot(N.xy, vm.xy);\n        vm.xy = vm.xy - 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n        F += 2.0f*N.xy*step(abs(N.z), border_h)/N.z;\n\n         vec3 dx = vec3(-1., 0., 1.) + 1.;\n        //global force field\n        vec2 pressure = P(x);\n\n        F += 0.1*pressure;// - 1.1*vm.xy*step(N.z, border_h + 5.);\n        if(iMouse.z > 0.)\n        {\n            vec2 dm =(iMouse.xy - iMouse.zw)/10.; \n            float d = distance(iMouse.xy, x)/20.;\n            F += 0.01*dm*exp(-d*d);\n        }\n        vm.xy += 0.99*F*dt;\n        \n        //velocity limit\n        float v = length(vm.xy);\n        vm.xy /= max(v,1.0);//(v > 1.)?v:1.;\n    }\n\n    //if(pos.x < 3.)\n    //{\n    //    x = mix(pos, x, 0.);\n    //   vm.xyz = vec3(0.01, 0., 0.5*mass);\n    //}\n    \n    //rocket nozzle \n    if(distance(R*vec2(0.5, (((0.5f * 1.0f - 0.25) * 0.5f + 0.25f) * 0.5f + 0.25f) * 0.5f + 0.295f), pos) < R.x*0.012)\n    {\n        x = pos;\n        vm.xyz = vec3(0.45, 0., 0.225*mass);\n    }\n    #define nozzle_count 2.0\n    for (float nozzles = 1.0f ; nozzles < (nozzle_count + 1.0) ; ++nozzles) {\n    \n        if(distance(R*vec2(0.4, (0.5f * nozzles - 0.25) * 0.5f + 0.25f), pos) < R.x*0.012)\n        {\n            x = pos;\n            vm.xyz = vec3(0.4, 0., 0.225*mass);\n        }\n    }\n    #undef nozzle_count\n    #define nozzle_count 3.0\n    for (float nozzles = 1.0f ; nozzles < (nozzle_count + 1.0) ; ++nozzles) {\n    \n        if(distance(R*vec2(0.3, (0.5f * nozzles - 0.25) * 0.5f + 0.125f), pos) < R.x*0.012)\n        {\n            x = pos;\n            vm.xyz = vec3(0.35, 0., 0.225*mass);\n        }\n    }\n    #undef nozzle_count\n    #define nozzle_count 4.0\n    for (float nozzles = 1.0f ; nozzles < (nozzle_count + 1.0) ; ++nozzles) {\n    \n        if(distance(R*vec2(0.2, ((0.5f * nozzles - 0.25) * 0.5f + 0.25f) * 0.5f + 0.125f), pos) < R.x*0.012)\n        {\n            x = pos;\n            vm.xyz = vec3(0.3, 0., 0.225*mass);\n        }\n    }\n    #undef nozzle_count\n    #define nozzle_count 8.0\n    for (float nozzles = 1.0f ; nozzles < (nozzle_count + 1.0) ; ++nozzles) {\n    \n        if(distance(R*vec2(0.1, (((0.8f * nozzles - 1.5) * 0.5f + 0.25f) * 0.5f + 0.125f) * 0.5f + 0.1225), pos) < R.x*0.012)\n        {\n            x = pos;\n            vm.xyz = vec3(0.25, 0., 0.225*mass);\n        }\n    }\n    //initial condition\n    if(iFrame < 1)\n    {\n        //random\n        vec3 rand = hash32(pos);\n        if(rand.z < 0.1) \n        {\n            x = pos;\n            vm = vec4(0.5*(rand.xy-0.5) + vec2(0., 0.), 4.*mass, mass);\n        }\n        else\n        {\n            x = pos;\n        \tvm = vec4(0.);\n        }\n    }\n    \n    U = vec4(x, encode(vm));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//velocity blur\n\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime;\n    \n\tU = texel(ch1, pos);\n    vec4 av = vec4(0.); float s = 0.0001;\n    range(i, -3, 3) range(j, -3, 3)\n    {\n        vec2 dx = vec2(i,j);\n        vec4 dc = decode(texel(ch0, pos + dx).zw);\n        float k = dc.z*G(dx/2.);\n        s += k;\n        av += k*dc.xyzz;\n    }\n    U = av/s; \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//pressure solve\n\nvec2 V(vec2 p)\n{\n    vec4 d =texel(ch0, p); \n    return d.xy;\n}\n\nfloat P(vec2 p)\n{\n    return texel(ch1, p).x;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime;\n    \n    float b = border(pos);\n      \n    \n    vec3 dx = vec3(-1., 0., 1.);\n    //velocity divergence\n    float div = 0.5*(V(pos + dx.zy).x - V(pos + dx.xy).x +\n                     V(pos + dx.yz).y - V(pos + dx.yx).y);\n    //neighbor average\n    float L = 0.25*(P(pos + dx.zy) + P(pos + dx.xy) +\n                    P(pos + dx.yz) + P(pos + dx.yx));\n    U.x = 0.995*L + div;\n  \n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//pressure solve + gradient\n\nvec2 V(vec2 p)\n{\n    vec4 d =texel(ch0, p); \n    return d.xy;\n}\n\nfloat sqr(float x)\n{\n\treturn x*x;\n}\n\nfloat Pf(float rho)\n{\n    return 6.*rho; //gas\n    return 0.*rho*clamp(pow(abs(rho/0.2), 5.) - 1., -1., 1.); //water pressure\n}\n\nfloat P(vec2 p)\n{\n    return -Pf(texel(ch0, p).z)+ 0.*texel(ch1, p).x;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime;\n    \n    float b = border(pos);\n      \n    if(b > 0. || true) \n    {\n        vec3 dx = vec3(-1., 0., 1.);\n        //velocity divergence\n        float div = 0.5*(V(pos + dx.zy).x - V(pos + dx.xy).x +\n                         V(pos + dx.yz).y - V(pos + dx.yx).y);\n        //neighbor average\n        float L = 0.25*(P(pos + dx.zy) + P(pos + dx.xy) +\n                       P(pos + dx.yz) + P(pos + dx.yx));\n        U.x = 0.995*L + div;\n    }  \n    \n    \n    vec3 dx = vec3(-1., 0., 1.);\n    //global force field\n    vec2 pressure = 0.5*vec2(P(pos + dx.zy) - P(pos + dx.xy),\n                             P(pos + dx.yz) - P(pos + dx.yx));\n    U.zw = pressure;\n}","name":"Buffer D","description":"","type":"buffer"}]}