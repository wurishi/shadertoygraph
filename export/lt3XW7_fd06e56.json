{"ver":"0.1","info":{"id":"lt3XW7","date":"1481286899","viewed":897,"name":"Spherical Images","username":"soma_arc","description":"Deformation of spherical images. Rotation -> Translation -> Scaling\nReference:\nSquares that Look Round: Transforming Spherical Images by Saul Schleimer and Henry Segerman\nhttp://archive.bridgesmathart.org/2016/bridges2016-15.html\n","likes":30,"published":1,"flags":0,"usePreview":0,"tags":["3d","equirectangular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nCreated by soma_arc - 2016\nThis work is licensed under Creative Commons Attribution-ShareAlike 3.0 Unported.\n*/\n\n\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n    seed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nconst float NO_ANSWER = -999999.;\n\nconst float PI = 3.14159265359;\nconst float fourPI = 12.566368;\nconst float EPSILON = 0.01;\n\nconst vec3 BLACK = vec3(0);\nconst vec3 WHITE = vec3(1);\nconst vec3 LIGHT_GRAY = vec3(0.78);\nconst vec3 RED = vec3(1, 0, 0);\nconst vec3 GREEN = vec3(0, .78, 0);\nconst vec3 BLUE = vec3(0, 0, 1);\nconst vec3 YELLOW = vec3(1, 1, 0);\nconst vec3 PINK = vec3(.78, 0, .78);\nconst vec3 LIGHT_BLUE = vec3(0, 1, 1);\n\nconst vec3 AMBIENT_FACTOR = vec3(0.1);\n\nconst float NO_HIT = 99999999.;\n\nconst int MTL_DIFFUSE = 0;\nconst int MTL_TRANSPARENT = 1;\n\nconst int OBJ_PLANE = 0;\nconst int OBJ_SPHERE = 1;\n\nstruct SL2C{\n\tvec2 a;\n    vec2 b;\n    vec2 c;\n    vec2 d;\n};\n    \nSL2C g_mobius;    \n\nconst vec2 COMPLEX_ONE = vec2(1, 0);\nconst vec2 COMPLEX_ZERO = vec2(0);\nconst SL2C MAT_UNIT = SL2C(COMPLEX_ONE, COMPLEX_ZERO,\n                      \t   COMPLEX_ZERO, COMPLEX_ONE);\nconst float PI_2 = PI / 2.;\nconst float TWO_PI = PI * 2.;\nconst float THREE_PI_2 = 3. * PI / 2.;\n\nvec2 equirectangularCoord(vec3 coordOnSphere){\n\tvec3 dir = (coordOnSphere);\n    float l = atan(dir.z, dir.x);\n    if (l < 0.) l += TWO_PI;\n    return vec2(l, acos(dir.y));\n}\n\nvec3 coordOnSphere(float theta, float phi){\n\treturn vec3(sin(phi) * cos(theta), \n                cos(phi),\n                sin(phi) * sin(theta));\n} \n\nvec2 compProd(const vec2 a, const vec2 b){\n\treturn vec2(a.x * b.x - a.y * b.y,\n                a.x * b.y + a.y * b.x);\n}\n\nvec2 compQuot(const vec2 a, const vec2 b){\n\tfloat denom = dot(b, b);\n    return vec2((a.x * b.x + a.y * b.y) / denom,\n                (a.y * b.x - a.x * b.y) / denom);\n}\n\nvec2 conjugate(const vec2 a){\n\tconst vec2 conj = vec2(1, -1);\n    return a * conj;\n}\n\nSL2C matInverse(const SL2C m){\n    vec2 invDet =  compQuot(COMPLEX_ONE, (compProd(m.a, m.d)-compProd(m.b, m.c)));\n\treturn SL2C(compProd(m.d, invDet), compProd(m.b * -1., invDet),\n                compProd(m.c * -1., invDet), compProd(m.a, invDet));\n}\n\nSL2C matProd(const SL2C m1, const SL2C m2){\n    return SL2C(compProd(m1.a, m2.a) + compProd(m1.b, m2.c),\n                compProd(m1.a, m2.b) + compProd(m1.b, m2.d),\n                compProd(m1.c, m2.a) + compProd(m1.d, m2.c),\n                compProd(m1.c, m2.b) + compProd(m1.d, m2.d));\n}\n\nvec4 applyMatVec(const SL2C m, const vec4 c){\n\treturn vec4(compProd(m.a, c.xy) + compProd(m.b, c.zw),\n                compProd(m.c, c.xy) + compProd(m.d, c.zw));\n}\n\nvec4 CP1FromSphere(vec3 pos){\n\tif(pos.y < 0.)\n        return vec4(pos.x, pos.z, 1. - pos.y, 0);\n    else\n        return vec4(1. + pos.y, 0, pos.x, -pos.z);\n}\n\nvec3 sphereFromCP1(vec4 p){\n\tvec2 z1 = p.xy;\n    vec2 z2 = p.zw;\n    if(length(z2) > length(z1)){\n    \tvec2 z = compQuot(z1, z2);\n        float denom = 1. + dot(z, z);\n        return vec3(2. * z.x / denom, (denom - 2.) / denom, 2. * z.y / denom);\n    }else{\n    \tvec2 z = conjugate(compQuot(z2, z1));\n        float denom = 1. + dot(z, z);\n        return vec3(2. * z.x / denom, (2. - denom) / denom, 2. * z.y / denom);\n    }\n}\n\nvec2 reverseStereoProject(const vec3 pos){\n\treturn vec2(pos.x, pos.z) / (1. - pos.z);\n}\n\nvec3 stereoProject(vec2 pos){\n    pos *= .5;\n    float x = pos.x;\n    float y = pos.y;\n    float x2y2 = x * x + y * y;\n    return vec3((2. * x) / (1. + x2y2),\n                (-1. + x2y2) / (1. + x2y2),\n                (2. * y) / (1. + x2y2));\n}\n\nSL2C infZeroOneToTriple(const vec4 p, const vec4 q, const vec4 r){\n\tvec2 p1 = p.xy; vec2 p2 = p.zw;\n    vec2 q1 = q.xy; vec2 q2 = q.zw;\n    vec2 r1 = r.xy; vec2 r2 = r.zw;\n    SL2C m = SL2C(p1, q1, p2, q2);\n    SL2C mInv = matInverse(m);\n    vec4 v = applyMatVec(mInv, r);\n    return SL2C(compProd(v.xy, p1), compProd(v.zw, q1),\n                compProd(v.xy, p2), compProd(v.zw, q2));\n}\n\nSL2C twoTriplesToSL(const vec4 a1, const vec4 b1, const vec4 c1,\n                    const vec4 a2, const vec4 b2, const vec4 c2){\n\treturn matProd(infZeroOneToTriple(a2, b2, c2), \n                   matInverse(infZeroOneToTriple(a1, b1, c1)));\n}\n\nvec3 vectorPerpToPQ(vec3 p, vec3 q){\n    if(abs(dot(p, q) + 1.) < 0.0001){\n        if(abs(dot(p, vec3(1, 0, 0))) > 0.999){\n        \treturn vec3(0, 1, 0);\n        }else{\n        \treturn normalize(cross(p, vec3(1, 0, 0)));\n        }\n    }else{\n    \treturn normalize(cross(p, q));\n    }\n}\n\nSL2C rotateAroundAxisSpherePointsPQ(const vec3 p, const vec3 q, const float theta){\n\tvec4 CP1p = CP1FromSphere(p);\n    vec4 CP1q = CP1FromSphere(q);\n\tvec3 r = vectorPerpToPQ(p, q);\n    vec4 CP1r = CP1FromSphere(r);\n    SL2C st = twoTriplesToSL(CP1p, CP1q, CP1r, \n            \t           vec4(0, 0, 1, 0),\n                           vec4(1, 0, 0, 0), \n                           vec4(1, 0, 1, 0));\n    SL2C mTheta = SL2C(vec2(cos(theta), sin(theta)), COMPLEX_ZERO,\n                       COMPLEX_ZERO, COMPLEX_ONE);\n    return matProd( matProd(matInverse(st), mTheta), st);\n}\n\nSL2C rotateSpherePointsPQ(const vec3 p, const vec3 q){\n\tvec4 CP1p = CP1FromSphere(p);\n    vec4 CP1q = CP1FromSphere(q);\n    if(abs(dot(p, q) - 1.) < 0.0001){\n    \treturn SL2C(COMPLEX_ONE, COMPLEX_ZERO, COMPLEX_ZERO, COMPLEX_ONE);\n    }else{\n    \tvec3 r = vectorPerpToPQ(p, q);\n        vec4 CP1r = CP1FromSphere(r);\n        vec4 CP1mr = CP1FromSphere(-r);\n        return twoTriplesToSL(CP1p, CP1r, CP1mr, CP1q, CP1r, CP1mr);\n    }\n}\n\nSL2C rotateAroundAxis(const vec3 p, const float theta){\n\treturn rotateAroundAxisSpherePointsPQ(p, -p, theta);\n}\n\nSL2C threePointsToThreePoints(const vec3 p1, const vec3 q1, const vec3 r1,\n                              const vec3 p2, const vec3 q2, const vec3 r2){\n\treturn twoTriplesToSL(CP1FromSphere(p1), CP1FromSphere(q1), CP1FromSphere(r1),\n                          CP1FromSphere(p2), CP1FromSphere(q2), CP1FromSphere(r2));\n}\n\nSL2C translateAlongAxis(const vec3 p, const vec3 q,\n                        const vec3 r1, const vec3 r2){\n\treturn threePointsToThreePoints(p, q, r1, p, q, r2);\n}\n\nSL2C zoomIn(const vec3 p, const float zoomFactor){\n\tSL2C rot = rotateSpherePointsPQ(p, coordOnSphere(0., 0.));\n    SL2C scl = SL2C(vec2(zoomFactor, 0), COMPLEX_ZERO,\n                    COMPLEX_ZERO, COMPLEX_ONE);\n    return matProd(matProd(matInverse(rot), scl), rot);\n}\n\nint g_objId = -1;\nint g_mtl = -1;\nvec4 intersectSphere(int objId, int mtl,\n                     vec3 sphereCenter, float radius,\n                     vec3 rayOrigin, vec3 rayDir,\n                     vec4 isect){\n    vec3 v = rayOrigin - sphereCenter;\n    float b = dot(rayDir, v);\n    float c = dot(v, v) - radius * radius;\n    float d = b * b - c;\n    if(d >= 0.){\n        float s = sqrt(d);\n        float t = -b - s;\n        if(t <= EPSILON) t = -b + s;\n        if(EPSILON < t && t < isect.x){\n            vec3 intersection = (rayOrigin + t * rayDir);\n            g_objId = objId;\n            g_mtl = mtl;\n            return vec4(t, normalize(intersection - sphereCenter));\n        }\n    }\n    return isect;\n}\n\nvec4 intersectPlane(int objId, int mtl,\n                    vec3 p, vec3 n,\n                    vec3 rayOrigin, vec3 rayDir, vec4 isect){\n    float d = -dot(p, n);\n    float v = dot(n, rayDir);\n    float t = -(dot(n, rayOrigin) + d) / v;\n    if(EPSILON < t && t < isect.x){\n        g_objId = objId;\n        g_mtl = mtl;\n        return vec4(t, n);\n    }\n    return isect;\n}\n\n\nvec2 circleInverse(vec2 pos, vec2 circlePos, float circleR){\n    return ((pos - circlePos) * circleR * circleR)/(length(pos - circlePos) * length(pos - circlePos) ) + circlePos;\n}\n\nconst float RECT_SIZE = PI/18.;\nvec3 equirectangularMap(const vec2 angles){\n    float theta = angles.x; float phi = angles.y;\n    if(abs(phi - PI_2) < .05) return BLUE;\n    if( phi <= .1 ) return PINK;\n    if( phi >= PI - .1) return LIGHT_BLUE;\n    if(abs(theta - PI) <= .05) return RED;\n    if(abs(theta - PI_2) <= .05) return GREEN;\n    if(abs(theta - THREE_PI_2) <= .05) return GREEN;\n    if(theta <= .025 || theta >= TWO_PI - .025) return RED;\n\n    int x = int(mod(floor(theta / RECT_SIZE)+floor(phi / RECT_SIZE), 2.));\n    if(x == 0){\n    \treturn WHITE;\n    }else{\n    \treturn BLACK;\n    }\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 getIntersection(vec3 eye, vec3 ray){\n    vec4 isect = vec4(NO_HIT);\n    isect = intersectPlane(OBJ_PLANE, MTL_DIFFUSE,\n                           vec3(0, -1, 0), vec3(0, 1, 0),\n                           eye, ray, isect);\n    isect = intersectSphere(OBJ_SPHERE, MTL_DIFFUSE,\n                            vec3(0), 1.,\n                            eye, ray, isect);\n    return isect;\n}\n\nbool visible(vec3 eye, vec3 target){\n    vec3 v = normalize(target - eye);\n    return getIntersection(eye, v).x == NO_HIT;\n}\n\nvec3 diffuseLighting(const vec3 p, const vec3 n, const vec3 diffuseColor,\n                     const vec3 lightPos, const vec3 lightPower){\n    vec3 v = lightPos - p;\n    float d = dot(n, normalize(v));\n    float r = length(v);\n    return (d > 0. )//&& visible(p + EPSILON * n, lightPos)) \n        ?\n        (lightPower * (d / (fourPI * r * r))) * diffuseColor\n        : BLACK;\n}\n\nconst vec3 LIGHT_DIR = normalize(vec3(0.0, 1., 0.5));\nconst vec3 LIGHT_POS = vec3(3, 5, 0);\nconst vec3 LIGHT_POWER = vec3(300.);\n\nvec3 calcColor(vec3 eye, vec3 ray){\n    vec3 l = BLACK;\n    vec4 isect = getIntersection(eye, ray);\n\tif(isect.x != NO_HIT){\n\t\tvec3 matColor = WHITE;\n        vec3 normal = isect.yzw;\n\t\tvec3 intersection = eye + isect.x * ray;\n\t\tif(g_objId == OBJ_PLANE){\n\t\t\tvec4 z = CP1FromSphere(stereoProject(intersection.xz));\n            vec3 s = sphereFromCP1(applyMatVec(g_mobius, z));\n\t\t\tvec2 angles = equirectangularCoord(s);\n\t\t\tmatColor = equirectangularMap(angles);\n\t\t\t//matColor = LIGHT_GRAY;\n\t\t}else if(g_objId == OBJ_SPHERE){\n            vec4 z = CP1FromSphere(intersection);\n\t\t\tvec3 s = sphereFromCP1(applyMatVec(g_mobius, z));\n            vec2 angles = equirectangularCoord(s); \n\t\t\tmatColor = equirectangularMap(angles);\n\t\t}\n\t\t// diffuse lighting by directionalLight\n\t\t//vec3 diffuse = clamp(dot(normal, LIGHT_DIR), 0., 1.) * matColor;\n\t\tvec3 diffuse = diffuseLighting(intersection, normal, matColor,\n\t\t\t\t\t\t\t\t\t   LIGHT_POS, LIGHT_POWER);\n\t\tvec3 ambient = matColor * AMBIENT_FACTOR;\n\t\tl += (diffuse + ambient);\n\t}  \n    return l;\n}\n\nvec3 calcRay (const vec3 eye, const vec3 target,\n              const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n    float imagePlane = (height * .5) / tan(radians(fov) * .5);\n    vec3 v = normalize(target - eye);\n    vec3 focalXAxis = normalize(cross(v, up));\n    vec3 focalYAxis =  normalize(cross(v, focalXAxis ));\n    vec3 center = v * imagePlane;\n    vec3 origin = center - (focalXAxis * (width  * .5)) - (focalYAxis * (height * .5));\n    return normalize(origin + (focalXAxis * coord.x) + (focalYAxis * (height - coord.y)));\n}\n\nvec3 sphericalView(vec3 dir){\n    vec4 z = CP1FromSphere(dir);\n    vec2 angles = equirectangularCoord(sphereFromCP1(applyMatVec(g_mobius, z)));\n\treturn equirectangularMap(angles);\n\n}\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n\treturn vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n\t\t\t\t(min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n\t\t\t\t(min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nfloat scene(float t, float w, float s){\n    return clamp(t - w, 0.0, s) / s;  \n}\n\nconst float SAMPLE_NUM = 5.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = mod(iTime, 18.);\n    float rotateT = scene(t, 0., 6.) * TWO_PI;\n\tfloat translateT = scene(t, 6., 6.) * TWO_PI;\n\tfloat zoomT = scene(t, 12., 6.) * TWO_PI;\n\n    \n    vec3 s1 = coordOnSphere(PI, 0.);\n    vec3 s2 = coordOnSphere(PI, PI);\n    vec3 r1 = coordOnSphere(PI, PI_2);\n    vec3 r2 = coordOnSphere(PI + sin(translateT), PI_2 + sin(translateT));\n    vec3 s = coordOnSphere(PI, PI_2);\n    g_mobius = MAT_UNIT;\n    g_mobius = matProd(matInverse(rotateAroundAxis(s, PI/4. * sin(rotateT))),\n                       g_mobius);\n    g_mobius = matProd(translateAlongAxis(s1, s2, r1, r2),\n                       g_mobius);\n\tg_mobius = matProd(zoomIn(s, 1. + 2. * abs(sin(zoomT))),\n                       g_mobius);\n    float ratio = iResolution.x / iResolution.y / 2.0;\n    const vec3 up = vec3(0, 1, 0);\n    const float fov = 60.;\n    vec3 sum = vec3(0);\n    for(float i = 0. ; i < SAMPLE_NUM ; i++){\n        vec2 coordOffset = rand2n(fragCoord.xy, i);\n        if(fragCoord.x < iResolution.x/2.){\n            float r = 3.;\n            vec3 eye = vec3(r * sin(iTime), 1.5, r * cos(iTime));\n    \t\tvec3 target = vec3(0, 0, 0);\n        \tvec3 ray = calcRay(eye, target, up, fov,\n                         \t   iResolution.x/2., iResolution.y,\n                         \t   gl_FragCoord.xy + coordOffset);\n        \tsum += calcColor(eye, ray);\n        }else{\n            vec2 halfRes = iResolution.xy / 2.;\n            vec2 size = iResolution.xx / vec2(2, 4); // 2:1\n        \tvec2 p = vec2(fragCoord.x - size.x, fragCoord.y) / size;//[0, 1]\n            if(p.y <= 1.){\n                float theta = p.x * 2. * PI;\n                float phi = p.y * PI;\n                vec4 z = CP1FromSphere(coordOnSphere(theta, phi));\n\t\t\t\tvec2 angles = equirectangularCoord(sphereFromCP1(applyMatVec(g_mobius, z)));\n                sum += equirectangularMap(angles);\n                //sum += equirectangularMap(theta, phi);\n            }else{\n                vec3 eye = vec3(0, 0, 0);\n    \t\t\tvec3 target = vec3(1, 0, 0);//vec3(sin(iTime), sin(iTime), cos(iTime));\n            \tvec3 ray = calcRay(eye, target, up, fov,\n                         \t  \t   iResolution.x/2., iResolution.y - size.y,\n                         \t   \t   gl_FragCoord.xy - vec2(iResolution.x/2., size.y) + coordOffset);\n\n        \t\tsum += sphericalView(ray);\n            }\n        }\n    }\n    fragColor = vec4(gammaCorrect(sum/SAMPLE_NUM), 1.);\n\n}","name":"Image","description":"","type":"image"}]}