{"ver":"0.1","info":{"id":"ssBGzm","date":"1617483616","viewed":108,"name":"Easter Eggs","username":"szazo","description":"Learning the ropes of ray tracing","likes":6,"published":1,"flags":48,"usePreview":1,"tags":["camera","postprocess","spheretracing","buffer","lesson"],"hasliked":0,"parentid":"fs23Rh","parentname":"WithMaterial"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = 2.*texelFetch(iChannel0,ivec2(fragCoord),0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This file contains the \n\n// ---- SPHERE TRACING ----\n\nconst float Tmin = 0.;\nconst float Tmax = 500.;\nconst float epsilon = 0.006;\nconst int maxIters = 128;\n\nconst float shadowEpsilon = 0.06;\nconst int shadowMaxIters = 128;\nconst float shadowBias = 0.08;\n\nconst float reflectionTmax = 500.;\nconst float reflectionEpsilon = 0.06;\nconst int reflectionMaxIters = 64;\n\nconst bool manualCamera = false; \n\nstruct Ray\n{\n\tvec3 P;\n\tfloat Tmin;\n\tvec3 V;\n\tfloat Tmax;\n};\n\nstruct TraceResult\n{\n    float T;\t\t// Distance taken on ray\n    int matid;      // If it is a surface it, returns the material of the surface\n    int flags;\t\t// bit 0:   distance condition:     true if travelled to far t > t_max\n                    // bit 1:   surface condition:      true if distance to surface is small < error threshold\n};                  // bit 2:   iteration condition:    true if took too many iterations\n\nstruct SphereTraceDesc\n{\n    float epsilon;  //Stopping distance to surface\n    int maxiters;   //Maximum iteration count\n};\n\nTraceResult sphere_trace(in Ray ray, in SphereTraceDesc params)\n{\n    TraceResult ret = TraceResult(ray.Tmin, -1, 0);\n    float d;\n    int matid;\n        \n    int i = 0; do\n    {\n        Value value = sdf(ray.P+ret.T*ray.V, iTime);\n        d = value.sdf;\n        matid = value.matid;\n        ret.matid = value.matid; // we store last matid for returning later\n        ret.T+=d;\n        ++i;\n    } while (\n\t\tret.T < ray.Tmax &&       \t\t\t// Stay within bound box\n\t\td\t  > params.epsilon * ret.T &&\t// Stop if cone is close to surface\n\t\ti     < params.maxiters\t        \t// Stop if too many iterations\n\t);\n    \n    ret.flags =  int(ret.T >= ray.Tmax)\n              | (int(d <= params.epsilon* ret.T)  << 1)\n              | (int(i >= params.maxiters) << 2);\n    return ret;\n}\n\n// ---- SHADING ----\n\nvec3 normal(const in vec3 p, float time)\n{\n    const float eps=0.001;\n    vec3 plus = vec3(sdf(p+vec3(eps,0,0), time).sdf,sdf(p+vec3(0,eps,0), time).sdf,sdf(p+vec3(0,0,eps), time).sdf);\n    vec3 minu = vec3(sdf(p-vec3(eps,0,0), time).sdf,sdf(p-vec3(0,eps,0), time).sdf,sdf(p-vec3(0,0,eps), time).sdf);\n    return normalize(plus-minu);\n}\n\nvec4 missColor(Ray ray)\n{\n    return vec4(texture(iChannel2, ray.V).xyz,1.);\n}\nvec4 errorColor(Ray ray, float t)\n{\n    return missColor(ray);\n    //return vec4(materials[MATERIAL_SOIL].color, 1.0);\n}\n\nvec3 shadeByLight(in vec3 lightPos, \n           in float lightIntensity,\n           in vec3 toEye, \n           in vec3 p, \n           in vec3 normal, \n           Material mat)\n{\n    vec3 toLight = normalize(lightPos - p);\n    float lightDist = length(toLight);\n    float costheta = max(dot(normal, toLight), 0.);\n    \n    // diffuse\n    vec3 k_d = mat.color;\n\n    // specular\n    vec3 k_s = vec3(mat.metalness);\n    \n    vec3 h = normalize(toLight + toEye);\n    float si = pow(clamp(dot(h, normal),0.,1.),100.);\n    \n    // emission\n    vec3 k_e = mat.emission;\n    \n    vec3 col = (k_d + si * k_s) * costheta + k_e;\n \n    vec3 intensity = vec3(lightIntensity / 4. * pi * lightDist); \n \n    return col * intensity;\n}\n\nfloat blinkingLightIntensity(float time)\n{\n    return sin(time);\n}\n\nvec3 reflectionDir(vec3 inner, vec3 normal)\n{\n    return inner - 2. * dot(normal, inner) * normal;\n}\n\nvec4 hitColor(Ray ray, float t, int matid)\n{\n    vec3 toEye = -ray.V;\n    vec3 p = ray.P + ray.V * t;\n    vec3 n = normal(p, iTime);\n\n    vec3 light1 = flowerCoord(6, 3);\n    vec3 light2 = flowerCoord(6, 0);\n\n    const int lightCount = 3;\n    vec3 lights[lightCount] = vec3[] (\n        light1 + vec3(2.8, 0.9, 0.),\n        light2 + vec3(2.8, 0.9, 0.),\n        vec3(0., 30., 0.));\n        \n    // animate light intensities\n    float intensities[lightCount] = float[] (\n        blinkingLightIntensity(iTime *1. + pi) * 0.9 + 0.5,\n        blinkingLightIntensity(iTime *1.) * 0.9 + 0.5,\n        1.5\n    );\n\n    // animate material too\n    Material mat = materials[matid];\n    if (matid == MATERIAL_FLOWER_GLOW_1) {\n        mat.emission = vec3(intensities[0]);\n        mat.color += vec3(0., intensities[1], intensities[1]);\n    } else if (matid == MATERIAL_FLOWER_GLOW_2) {\n        mat.emission = vec3(intensities[1]);\n        mat.color += vec3(0., intensities[0], intensities[0]);\n    }\n    \n    // this will be the final color\n    vec3 col = vec3(0., 0., 0.);\n    \n    // reflection\n    vec3 reflectionColor = vec3(0.);\n    if (mat.metalness > 0.) {\n        vec3 reflection = reflectionDir(-toEye, n);\n        Ray reflectionRay = Ray(p, Tmin, reflection, reflectionTmax);\n        SphereTraceDesc params = SphereTraceDesc(reflectionEpsilon, reflectionMaxIters);\n        TraceResult result = sphere_trace(reflectionRay, params);\n        if (bool(result.flags &  2)) {\n            Material reflectedMaterial = materials[result.matid];\n            reflectionColor = reflectedMaterial.color;\n        } else if (bool(result.flags & 1)) {\n            reflectionColor = missColor(reflectionRay).xyz;\n        }\n    }\n        \n    // lights and shadow for each\n    float shadow = 1.;\n    for (int i = 0; i < lightCount; i++) {\n        vec3 toLight = normalize(lights[i] - p);\n        float lightDist = length(toLight);\n        \n        vec3 start = p + normalize(n)  * shadowBias;\n    \n        Ray shadowRay = Ray(start, Tmin, toLight, lightDist);\n    \n        SphereTraceDesc params = SphereTraceDesc(shadowEpsilon, shadowMaxIters);\n        TraceResult result = sphere_trace(shadowRay, params);\n        Material shadowMat = materials[result.matid];\n        \n        if(shadowMat.emission[0] < 0.001 && bool(result.flags & 2)) {\n            // only cast ray if non emission object hit \n            shadow -= 0.1;\n        }\n        \n        \n        col += shadeByLight(lights[i], intensities[i], toEye, p, n, mat);\n    }\n    \n    col = ((mat.metalness * reflectionColor) + ((1. - mat.metalness) * col)) * shadow;\n\n    return vec4(col,1.);\n}\n\n// ---- CAMERA and EVENTs ----\n// Common key codes (WASD instead of arrows)\n\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nconst vec3 EyeStartPosition = vec3(-10.9,4.1,1.5);\n\nRay automaticCamera(vec2 fragCoord, float time)\n{\n    const float r = 12.0;\n    const float speed = 0.2;\n    const vec3 at = vec3(0, 0, 0);\n    const vec3 up = vec3(0,1,0);\n\n    float x = sin(time * speed) * r;\n    float y = cos(time * speed) * r;\n    \n    const float height = 4.1;\n    \n    vec3 eye = vec3(x, height, y);\n    vec3 w = normalize(at - eye);\n    vec3 u = normalize(cross(up, w));\n    vec3 v = cross(w, u);\n    \n    vec2 px = (fragCoord / iResolution.xy * 2. - 1.) * 1. * normalize(iResolution.xy);\n    \n    vec3 p = normalize(w + px.x * u + px.y * v);\n   \n    return Ray(eye, Tmin, p, Tmax);\n}\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2)\n{\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    \n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw+EyeStartPosition;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 0.2;\n    if (isKeyHeld(KeyLeft )) eye -= u*speed;\n    if (isKeyHeld(KeyRight)) eye += u*speed;\n    if (isKeyHeld(KeyUp   )) eye += w*speed;\n    if (isKeyHeld(KeyDown )) eye -= w*speed;\n    \n    if(iMouse.z>=0.)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//V\n               Tmin,\t\t\t\t\t\t//minT\n               normalize(w+px.x*u+px.y*v),\t//P\n               Tmax);\t\t\t\t\t\t//maxT\n}\n\n// ---- MAIN ----\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Generate ray from pixel\n    Ray ray;\n    if (manualCamera) {\n        vec3 eye; vec2 data; // this will be saved into first two pixels\n        ray = Camera(fragCoord, eye, data);\n        \n        // First two pixels are reserved\n        if(fragCoord.x == 0.5 && fragCoord.y == 0.5) { // pixel (0,0)\n            fragColor.yzw = eye-EyeStartPosition;\n            return;\n        }\n        if(fragCoord.x == 1.5 && fragCoord.y == 0.5) { //pixel (1,0)\n            fragColor.zw = data;\n            return;\n        }\n    } else {\n        ray = automaticCamera(fragCoord, iTime);\n    }\n    \n    // Set epsilon and maximum iteration\n    \n    SphereTraceDesc params = SphereTraceDesc(epsilon, maxIters);\n    \n    // Raytrace\n    TraceResult result = sphere_trace(ray, params);\n    \n    /* //Debug\n\tfragColor=vec4(0.,0.,0.,1.); //debug\n    if(bool(result.flags & 1)) fragColor.r=1.;\n    if(bool(result.flags & 2)) fragColor.g=1.;\n    if(bool(result.flags & 4)) fragColor.b=1.;\n    */\n    if(bool(result.flags & 1))    fragColor = missColor(ray);    \n    else if(bool(result.flags&2)) fragColor = hitColor(ray, result.T, result.matid);\n    else \t        \t\t\t  fragColor = errorColor(ray, result.T);\n\n\n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = 0.3*prev + 0.7*fragColor;\n    fragColor.w = result.T;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//This file contains the code for the scene\n\n\nconst float pi = 3.1415926535897932384626433832795;\n\n// materials\n\nstruct Material {\n    vec3 color;         // [0, 1/pi]\n    float roughness;    // [0, ~7]\n    vec3 emission;      // [0, inf]\n    float metalness;    // 0.02 - 0.05 for non metals, 0.6 - 0.9 for metals\n};\n\nstruct Value {\n    float sdf;\n    int matid;\n};\n\nconst float cf = 2. / pi / 255.;\n\nMaterial materials[13] = Material[](\n  Material(vec3(65. * cf, 152. * cf, 10. * cf), 4., vec3(0, 0, 0), 0.), // grass\n  Material(vec3(96. * cf, 128. * cf, 56. * cf), 4., vec3(0., 0., 0.), 0.), // soil\n  Material(vec3(234. * cf, 182. * cf, 79. * cf), 4., vec3(0, 0, 0), 0.), // basket\n  Material(vec3(255. * cf, 0. * cf, 0. * cf), 4., vec3(0, 0, 0), 0.), // egg red\n  Material(vec3(32. * cf, 80. * cf, 164. * cf), 4., vec3(0, 0, 0), 0.6), // egg blue\n  Material(vec3(255. * cf, 204. * cf, 0. * cf), 4., vec3(0, 0, 0), 0.), // egg yellow\n  Material(vec3(201. * cf, 71. * cf, 245. * cf), 4., vec3(0, 0, 0), 0.6), // egg purple\n  Material(vec3(255. * cf, 102. * cf, 0. * cf), 4., vec3(0, 0, 0), 0.4), // egg orange\n  Material(vec3(172. * cf, 255. * cf, 126. * cf), 4., vec3(0, 0, 0), 0.), // egg green\n  Material(vec3(68. * cf, 64. * cf, 101. * cf), 4., vec3(0, 0, 0), 0.), // flower blue\n  Material(vec3(238. * cf, 68. * cf, 67. * cf), 4., vec3(0., 0., 0.), 0.), // flower corall\n  Material(vec3(255. * cf, 254. * cf, 234. * cf), 4., vec3(2., 2., 2.), 0.), // flower glow 1\n  Material(vec3(255. * cf, 254. * cf, 234. * cf), 4., vec3(2., 2., 2.), 0.) // flower glow 2\n);\n\nconst int flowerCount = 6;\n\nconst int MATERIAL_GRASS = 0;\nconst int MATERIAL_SOIL = 1;\nconst int MATERIAL_BASKET = 2;\nconst int MATERIAL_EGG_RED = 3;\nconst int MATERIAL_EGG_BLUE = 4;\nconst int MATERIAL_EGG_YELLOW = 5;\nconst int MATERIAL_EGG_PURPLE = 6;\nconst int MATERIAL_EGG_ORANGE = 7;\nconst int MATERIAL_EGG_GREEN = 8;\nconst int MATERIAL_FLOWER_BLUE = 9;\nconst int MATERIAL_FLOWER_CORALL = 10;\nconst int MATERIAL_FLOWER_GLOW_1 = 11;\nconst int MATERIAL_FLOWER_GLOW_2 = 12;\n\nValue material(float sdf, int matid)\n{\n    return Value(sdf, matid);\n}\n\n//\tPRIMITIVES are from\n//\thttps://iquilezles.org/articles/distfunctions\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdSolidAngle(vec3 p, vec2 c, float ra)\n{\n  // c is the sin/cos of the angle\n  vec2 q = vec2( length(p.xz), p.y );\n  float l = length(q) - ra;\n  float m = length(q - c*clamp(dot(q,c),0.0,ra) );\n  return max(l,m*sign(c.y*q.x-c.x*q.y));\n}\n\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n  p = abs(p);\n  vec2 b = vec2(la,lb);\n  float f = clamp( (dot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n  vec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n/// set operations\n\nValue opUnion(Value f, Value g)\n{\n    if (f.sdf <= g.sdf) {\n        return f;\n    } else {\n        return g;\n    }\n}\n\nfloat opUnion(float f, float g)\n{\n    return min(f, g);\n}\n\nfloat opIntersection (float f, float g )\n{\n    return max(f, g);\n}\n\nfloat opDifference (float f, float g)\n{\n    return max(f, -g);\n}\n\nvec3 opRep( in vec3 p, in vec3 c )\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    \n    return q;\n}\n\n// taken from http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 transform(in vec3 p, in mat4 transform)\n{\n    mat4 inverseTransform = inverse(transform);\n    vec3 transformed = (inverseTransform * vec4(p, 1.0)).xyz;\n    return transformed;\n}\n\n\nValue handle(in vec3 p)\n{\n    float sdf = sdCappedTorus(p, vec2(0.6, 0.01), 0.4, 0.1);\n    return Value(sdf, MATERIAL_BASKET);\n}\n\nValue basket(in vec3 p)\n{\n    p -= vec3(0., 0.7, 0.);\n    float sdfOuter = sdRoundedCylinder(p , 1.8, 0.1, 0.5);\n    float sdfInner = sdRoundedCylinder(p- vec3(0., 0.2, 0.), 1.7, 0.1, 0.5);\n    \n    float diff = opDifference(sdfOuter, sdfInner);\n    \n    Value handle1 = handle(p - vec3(0., 0.6, -3.5));\n    Value handle2 = handle(p - vec3(0., 0.6, 3.5));\n    \n    Value handles = opUnion(handle1, handle2);\n    \n    return opUnion(Value(diff, MATERIAL_BASKET), handles);\n}\n\nValue grass(in vec3 p)\n{\n    vec3 q = opRep(p, vec3(0.60, 0, 0.60));\n    float sdf = sdVerticalCapsule(q, 0.25, 0.01);\n    float hex = sdRoundedCylinder(p, 9.0, 0.1, 0.5);\n    return Value(opIntersection(sdf, hex), MATERIAL_GRASS);\n}\n\nValue egg(in vec3 p, in int materialId)\n{\n    p -= vec3(0., 1.5, 0.);\n    vec3 rotate = transform(p, rotationMatrix(vec3(1.0, 0.1, 0.), pi / 2.));\n    float sdf = sdEllipsoid(rotate, vec3(1., 1., 1.5));\n    return Value(sdf, materialId);\n}\n\nvec3 eggPosition(in vec3 p, float time)\n{\n    float dtime = mod(time, 1.0);\n    const float g = 9.81;\n    const float v0 = 5.;\n    float h = v0 * dtime - 0.5 * g * (dtime * dtime);\n\n    return vec3(0., h, 0.);    \n}\n\nValue eggs(in vec3 p, float time)\n{   \n    vec3 positions[6];\n    for (int i = 0; i < 6; i++) {\n        positions[i] = eggPosition(p, time + float(i) * 0.12);    \n    }\n        \n    p -= vec3(0., 1.5, 0.);\n    \n    int matid = MATERIAL_EGG_BLUE;\n    if (positions[0].y < 0.)\n    {\n        matid = MATERIAL_EGG_RED;\n    }\n    \n    vec3 size = vec3(1., 1.5, 1.* 1.);\n    vec3 rotate = p;\n    \n    Value egg1 = material(sdEllipsoid(p - positions[5] + vec3(0.1, 0., -1.5), size), MATERIAL_EGG_RED);\n    Value egg2 = material(sdEllipsoid(p - positions[1] + vec3(1.9, 0., -0.6), size), matid);\n    Value egg3 = material(sdEllipsoid(p - positions[2] + vec3(1.8, 0., 1.6), size), MATERIAL_EGG_YELLOW);\n    Value egg4 = material(sdEllipsoid(p - positions[3] + vec3(-0.1,0., 2.2), size), MATERIAL_EGG_ORANGE);\n    Value egg5 = material(sdEllipsoid(p - positions[0] + vec3(-1.9, 0, 1.), size), MATERIAL_EGG_GREEN);\n    Value egg6 = material(sdEllipsoid(p - positions[4] + vec3(-2.0, 0., -1.1), size), MATERIAL_EGG_PURPLE);   \n    \n    return opUnion(opUnion(opUnion(opUnion(opUnion(egg1, egg2), egg3), egg4), egg5), egg6);\n}\n\n\n///SDF\n\nfloat flower1(in vec3 p, float time)\n{\n    mat4 horizontalRotation = rotationMatrix(vec3(0., 1., 0.), time);\n    vec3 rotate = transform(p, horizontalRotation);\n    rotate += vec3(0., -0.3, 0.);\n    float sdf = sdOctahedron(rotate, .3);\n    \n    return sdf;\n}\n\nfloat flower2(in vec3 p, float time)\n{\n    mat4 horizontalRotation = rotationMatrix(vec3(0.1, 1., 0.), time * 1.4);\n    p = transform(p, horizontalRotation);\n    float sdf = sdSolidAngle(p, vec2(3,4)/5.0, 0.4);\n    \n    return sdf;\n}\n\nfloat flower3(in vec3 p, float time)\n{\n    mat4 horizontalRotation = rotationMatrix(vec3(0., 1., 0.), time * 1.4);\n    mat4 verticalRotation = rotationMatrix(vec3(0., 0., 1.), pi / 2.);\n    p = transform(transform(p, horizontalRotation), verticalRotation);\n    p += vec3(0.4, 0., 0.);\n    float sdf = sdRhombus(p, 0.4, 0.05, 0.02, 0.02 );\n    return sdf;\n\n}\n\nvec3 flowerCoord(int flowerCount, int index)\n{\n    float theta = pi * 2. / float(flowerCount) * float(index);\n    float r = sin(theta / 7.) * 7. +6.;\n    float x = cos(theta) * r;\n    float y = sin(theta) * r;\n\n    return vec3(x, 0., y);\n}\n\nValue flowers(in vec3 p, float time)\n{\n    Value v = Value(999999., -1);\n    for (int i = 0; i < flowerCount; i++) { \n        vec3 flowerCoord = flowerCoord(flowerCount, i);\n        \n        int which = int(mod(float(i), 3.));\n        float sdf;\n        vec3 coord = p + flowerCoord;\n        if (which == 0) {\n            sdf = flower1(coord, time);\n        } else if (which == 1) {\n            sdf = flower2(coord, time);\n        } else if (which ==2) {\n            sdf = flower3(coord, time);\n        }\n        \n        int whichmat = int(mod(float(i), 3.));\n        int matid;\n        if (whichmat == 0 && i == 0) {\n            matid = MATERIAL_FLOWER_GLOW_1;\n        } else if (whichmat == 0 && i > 0) {\n            matid = MATERIAL_FLOWER_GLOW_2;\n        } else if (whichmat == 1) {\n            matid = MATERIAL_FLOWER_BLUE;\n        } else if (whichmat == 2) {\n            matid = MATERIAL_FLOWER_CORALL;\n        }\n    \n        Value flower = material(sdf, matid);\n        v = opUnion(v, flower);\n    }\n    \n    return v;\n}\n\nValue sdf(in vec3 p, float time)\n{    \n    vec3 repetition = opRep(p, vec3(1., 0., 1.));\n    Value egg = egg(p, MATERIAL_EGG_RED);\n    Value eggs = eggs(p, time);\n    \n    Value plane = Value(p.y, MATERIAL_SOIL);\n    Value grass = grass(p);\n    \n    Value flowers = flowers(p, time);\n    Value basket = basket(p);\n    \n    return opUnion(plane, opUnion(eggs, opUnion(basket, opUnion(flowers, grass))));\n}\n","name":"Common","description":"","type":"common"}]}