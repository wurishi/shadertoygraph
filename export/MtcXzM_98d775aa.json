{"ver":"0.1","info":{"id":"MtcXzM","date":"1480722636","viewed":189,"name":"TP MG ","username":"spartan117","description":"This is a lava lamp draft for my Geometric Modelisation Labs\nThe aim of this lab is just to play with implicit surfaces","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["implicit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Blobs\n// Eric Galin\n\nconst int Steps = 1000;\nconst float Epsilon = 0.05; // Marching epsilon\nconst float T=0.5;\n\nconst float rA=10.0; // Maximum ray marching or sphere tracing distance from origin\nconst float rB=40.0; // Minimum\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n  float x = clamp(r/R,0.0,1.0);\n  float y = (1.0-x*x);\n  return y*y*y;\n}\n\nfloat dist_cube(vec3 p, vec3 c, float power, float scale) {    \n    vec3 d = vec3(scale, scale, scale) ;    \n    vec3 cp = (p - c) - (scale / 2.0) ;\n    \n   \tvec3 cpT = max(abs(cp) - d,0.0) ;\n    \n    float lcp = pow(pow(cpT.x, power) + pow(cpT.y, power) + pow(cpT.z, power), 1.0 / power) ;\n    \n    return lcp ;\n}\n\nfloat cube(vec3 p, vec3 c, float power, float scale, float iso, float R) {\n \treturn iso * falloff(dist_cube(p, c, power, scale), R) ;    \n}\n\n\nfloat dist_cercle(vec3 p, vec3 c, float r, vec3 rotationAxis) {\n    vec3 cp = p - c ;\n    \n    vec3 yAxis = normalize(rotationAxis) ;\n    vec3 zAxis = cross(cp, yAxis) ;\n    vec3 xAxis = cross(yAxis, zAxis) ;\n                                 \n    float lcbP = abs(dot(xAxis, cp) / length(xAxis)) ;\n    \n    vec3 e = normalize(xAxis) * r  + c ;\n        \n    return length(e - p) ;   \n}\n\nfloat cercle(vec3 p, vec3 c, float r, vec3 rotationAxis, float iso, float R) {\n \treturn iso * falloff(dist_cercle(p, c, r, rotationAxis), R) ;\n}\n\nfloat dist_disque(vec3 p, vec3 c, float r, vec3 rotationAxis) {\n    vec3 cp = p - c ;\n    \n    vec3 yAxis = normalize(rotationAxis) ;\n    vec3 zAxis = cross(cp, yAxis) ;\n    vec3 xAxis = cross(yAxis, zAxis) ;\n                                 \n    float lcbP = abs(dot(xAxis, cp) / length(xAxis)) ;\n    \n    if(lcbP > r) {\n        vec3 e = normalize(xAxis) * r  + c ;\n        \n     \treturn length(e - p) ;   \n    }\n    else {\n        float a2 =  lcbP * lcbP ;\n        float C = length(cp) ;\n        float C2 = C * C ;\n        return sqrt(C2 - a2) ;\n    }\n}\n\n\nfloat disque(vec3 p, vec3 c, float r, vec3 rotationAxis, float iso, float R) {\n \treturn iso * falloff(dist_disque(p, c, r, rotationAxis), R) ;\n}\n\n//Calcul de distance\nfloat dist_segment(vec3 p, vec3 a, vec3 b) {\n \tvec3 ab = b - a ;\n \tvec3 ap = p - a ;\n \tvec3 bp = p - b ;\n    float dABAP = dot(ab, ap) ;\n    if(dot(ab, bp) >= 0.0)\n        return length(bp) ;\n    else if(dABAP <= 0.0)\n        return length(ap) ;\n    else {\n        float lap = length(ap) ;\n        float lab = length(ab) ;\n        float oa = dABAP / lab ;\n        float l2 = (lap * lap) - (oa * oa) ;\n        return sqrt(l2) ;\n    }\n}\n\nfloat segment(vec3 p, vec3 a, vec3 b, float iso, float R) {\n    return iso * falloff(dist_segment(p, a, b), R) ;\n}\n\n// Transforms\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.y, -sa*p.x + ca*p.y, p.z);\n}\n\n\n\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, vec3 c, float e,float R)\n{\n  return e*falloff(length(p-c),R);\n}\n\n// Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Blend(float a,float b) {\n    return a + b ;\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Union(float a,float b) {\n    return max(a,b);\n}\n\n// Intersection\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Intersection(float a,float b) {\n    return min(a,b);\n}\n\nfloat LampStructure(vec3 p) {    \n  float s1 = segment(p,\n                     vec3(-1.00, -3.0, 0.0),\n                     vec3(-3.00, 2.0, 0.0), 0.6, 0.6) ;\n  float s2 = segment(p,\n                     vec3(1.00, -3.0, 0.0),\n                     vec3(3.00, 2.0, 0.0), 0.6, 0.6) ;\n  float s3 = segment(p,\n                     vec3(0.0, -3.0, -1.0),\n                     vec3(0.0, 2.0, -3.0), 0.6, 0.6) ;\n  float s4 = segment(p,\n                     vec3(0.0, -3.0, 1.0),\n                     vec3(0.0, 2.0, 3.0), 0.6, 0.6) ;\n   float lowPart = Union(Union(s1, s2), Union(s3, s4)) ;\n   \n  float s5 = segment(p,\n                     vec3(-1.00, 7.0, 0.0),\n                     vec3(-3.00, 2.0, 0.0), 0.6, 0.6) ;\n  float s6 = segment(p,\n                     vec3(1.00, 7.0, 0.0),\n                     vec3(3.00, 2.0, 0.0), 0.6, 0.6) ;\n  float s7 = segment(p,\n                     vec3(0.0, 7.0, -1.0),\n                     vec3(0.0, 2.0, -3.0), 0.6, 0.6) ;\n  float s8 = segment(p,\n                     vec3(0.0, 7.0, 1.0),\n                     vec3(0.0, 2.0, 3.0), 0.6, 0.6) ;\n    \n   float hiPart = Union(Union(s5, s6), Union(s7, s8)) ;\n    \n   float top = point(p, vec3(0.0, 7.0, 0.0), 1.0, 2.2) ;\n  float base = disque(p,\n                   vec3(0.00, -3.0, 0.0), 2.0, vec3(0.0, 1.0, 0.0), 0.7, 0.7) ;\n    \n   \n   float c = cercle(p,\n                   vec3(0.00, 2.0, 0.0), 3.0, vec3(0.0, 1.0, 0.0), 0.7, 0.7) ;\n    \n   return Union(Union(Union(Union(lowPart, hiPart), top), base), c) ;\n}\n\nfloat computeBalls(vec3 p) {\n    float b1T = -cos(iTime) ;\n    float b1Y = mix(-2.0, 6.0, (b1T + 1.0) / 2.0) ;\n    float b1X = mix(0.3, 0.7, 1.0 - abs(b1T)) ;\n  \tvec3 b1Pos = vec3(b1X, b1Y, 0.0) ;\n  \tfloat b1 = point(p, b1Pos, 1.0, 1.7) ;\n    \n    float b2T = -cos(iTime / 1.5) ;\n    float b2Y = mix(-2.0, 6.0, (b2T + 1.0) / 2.0) ;\n    float b2X = mix(0.0, 0.0, 1.0 - abs(b2T)) ;\n  \tvec3 b2Pos = vec3(b2X, b2Y, 0.0) ;\n  \tfloat b2 = point(p, b2Pos, 1.0, 1.7) ;\n    \n    float b3T = -cos(iTime / 1.2) ;\n    float b3Y = mix(-2.0, 6.0, (b3T + 1.0) / 2.0) ;\n    float b3X = mix(-0.2, -0.8, 1.0 - abs(b3T)) ;\n  \tvec3 b3Pos = vec3(b3X, b3Y, 0.0) ;\n  \tfloat b3 = point(p, b3Pos, 1.0, 1.7) ;\n    \n    \n    float res = b1 + b2 + b3 ;\n    return res ;\n    \n}\n\n\n// Potential field of the object\n// p : point\nfloat object(vec3 p) {\n  p.z = -p.z ;\n  float v = 0.0 ;\n  \n  float res = Union(LampStructure(p), computeBalls(p)) ;\n    res = Union(res, cube(p, vec3(6.0, 1.0, 0.0), 10.0, 2.0, 1.0, 1.0)) ;\n    \n  return res - T ;\n  //return c - T ;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.0001;\n  vec3 n;\n  float v = object(p);\n  n.x = object( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool h,out int s) {\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += Epsilon;\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i < Steps; i++) {\n    s = i ;\n    vec3 p = o + t * u ;\n    float v = object(p) ;\n    // Hit object\n      if(v > 0.0) {\n          s=i ;\n          h = true ;\n          break ;\n      }\n      // Move along ray\n      t += max(Epsilon, abs(v) / 10.0 * 9.0) ;\n      // Escape marched far away\n      if (t > rB) {\n          break;\n      }\n  }\n  return t;\n}\n\n\n// Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(0.4, 0.3, 0.0), vec3(0.7, 0.8, 1.0), rd.y*0.5+0.5);\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n)\n{\n  // point light\n  const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n  const vec3 lightColor = vec3(0.5, 0.5, 0.5);\n\n  vec3 c = 0.25*background(n);\n  vec3 l = normalize(lightPos - p);\n\n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = 0.5*(1.0+dot(n, l));\n\n  c += diff*lightColor;\n\n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return vec3(t,0.25+0.75*t,0.5-0.5*t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*3.0-1.0;\n\n  // compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -4.0));\n  vec3 ro = vec3(0.0, 0.0, 20.0);\n\n  // vec2 mouse = iMouse.xy / iResolution.xy;\n  float a=iTime * 2.0 ;\n  //ro = rotateY(ro, a);\n  //rd = rotateY(rd, a);\n\n  // Trace ray\n  bool hit;\n\n  // Number of steps\n  int s;\n\n  float t = SphereTrace(ro, rd, hit,s);\n  //float t = Trace(ro, rd, hit,s);\n  vec3 pos=ro+t*rd;\n  // Shade background\n  vec3 rgb = background(rd);\n\n  if(hit) {\n    // Compute normal\n    vec3 n = ObjectNormal(pos);\n\n    // Shade object with light\n    rgb = Shade(pos, n);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  //rgb = ShadeSteps(s) ;\n\n  fragColor=vec4(rgb, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}