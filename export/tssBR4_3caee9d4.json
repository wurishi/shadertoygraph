{"ver":"0.1","info":{"id":"tssBR4","date":"1587825535","viewed":142,"name":"REMAINDER","username":"os0450","description":"Day 25: remainder","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["dailycodingchallenge"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float rand(vec2 p) {\n    return fract(sin(dot(p, vec2(2321.32132, 18390.32873))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = fragCoord/iResolution.xy;\n    float eps = 0.041*(1./(1.+exp(sin(-2.*iTime)))-0.5) + rand(p)*0.02;\n    vec3 col = vec3(texture(iChannel0, vec2(p.x-eps, p.y)).r,\n                    texture(iChannel0, vec2(p.x, p.y)).g,\n                    texture(iChannel0, vec2(p.x+eps, p.y)).b);\n    \n    // Output to screen\n    col += rand(p*10.)*0.01;\n    col = pow(col, vec3(0.4545));\n    fragColor = vec4(col,1.0);\n    return;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"mat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat map(vec3 p, float delay) {\n    float d = 1e10;\n    float tau = acos(-1.)*2.;\n    float hpi = tau/4.0;\n    float ph = fract( (iTime-delay) /2.);\n    \n    for(int i=-4; i<4; i++) {\n    \tvec3 q = p;\n        float fi = float(i);\n        \n        q.y -= fi;\n        q.x -= cos(fi+ph*(tau))*2.0;\n        q.z -= sin(fi+ph*(tau))*2.0;\n        d = min(d, length(q)-0.5);\n        \n        q = p;\n        q.y -= fi-0.7;\n        q.x -= cos(fi+(ph+0.5)*(tau))*3.0;\n        q.z -= sin(fi+(ph+0.5)*(tau))*3.0;\n        q.yz *= rot(hpi);\n        q.xy *= rot(ph*tau);\n        vec2 r = vec2(length(q.xz)-0.8,q.y);\n        d = min(d, length(r)-0.1);\n    }\n    \n    return d;\n}\n\nvec3 getNormal(vec3 p, float delay) {\n    vec2 eps = vec2(0.000001, 0.0);\n    return normalize(vec3(\n        map(p - eps.xyy, delay) - map(p + eps.xyy, delay),\n        map(p - eps.yxy, delay) - map(p + eps.yxy, delay),\n        map(p - eps.yyx, delay) - map(p + eps.yyx, delay)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.xx;\n\n    vec3 cPos = vec3(0.0, 0.0, -6.0);\n    vec3 cTar = vec3(0.0, 0.0, 0.0);\n    vec3 cDir = normalize(cTar - cPos);\n    vec3 cR = normalize(cross(cDir, vec3(0.0, 1.0, 0.0)));\n    vec3 cU = normalize(cross(cR, cDir));\n    \n    vec3 ro = cPos;\n    vec3 rd = normalize(cDir + cR*p.x + cU*p.y);\n    vec3 rp;\n    \n    float t = 0.0;\n    float delay = floor(p.x*40.)*0.03;\n    bool render = false;\n    for(int i=0; i<99; i++) {\n        rp = ro + rd*t;\n        \n        float d = map(rp, delay);\n        t += d;\n        \n        if(t > 30.) {\n            break;\n        }\n    }\n    \n    vec3 col = vec3(0.0);\n    if(t < 30.) {\n        vec3 lDir = vec3(0.5, -0.5, 0.5);\n        \n        vec3 norm = getNormal(rp, delay);\n        float diff = dot(lDir, norm);\n        \n        float pi = acos(-1.);\n        col += vec3(0.8, 0.8, 0.2)*dot(vec3(0.0, -1.0, 0.3), norm);\n        col += vec3(0.2, 0.8, 0.8)*dot(vec3(cos(pi/3.), sin(pi/3.), 0.3), norm);\n        col += vec3(0.8, 0.2, 0.8)*dot(vec3(cos(pi*2./3.), sin(pi*2./3.), 0.3), norm);\n        col += 0.5;\n        \n        vec3 fog = vec3(0.);\n        col = mix(col, fog, 1.0-exp(-t*t*t*t*t*0.00003));\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}