{"ver":"0.1","info":{"id":"MtjfDt","date":"1517942236","viewed":107,"name":"Sweet Swing","username":"kingish","description":"An oddly satisfying animation.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["procedural"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float EPSILON = 0.01;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nint MAX_MARCHING_STEPS = 128;\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(radians(angle));\n    float c = cos(radians(angle));\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nmat4 translationMatrix(vec3 translation)\n{\n  return mat4(1,0,0,0,\n              0,1,0,0,\n              0,0,1,0,\n              translation.x, translation.y, translation.z, 1);\n}\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nstruct SDFData {\n    float SDV;\n    float id;\n};\n\nfloat SDFCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat SDFSphere( vec3 p ) {\n    return length(p) - 1.0;\n}\n\nfloat SDFBox( vec3 p, vec3 b ) {\n  return length(max(abs(p)-b,0.0));\n}\n\n\nfloat SDFTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat SDFCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 opCheapBend( vec3 p, float n )\n{\n    float c = cos(n*p.y);\n    float s = sin(n*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat TIMESPEED = 2.0;\n\nSDFData objBall(vec3 p) {\n    float n = sin(TIMESPEED * iTime);\n    float smoothValue = smoothstep(-1.00f, 1.0f, n) * 2.0 - 1.0;\n    smoothValue = (smoothValue + n) / 2.0f;\n    mat4 trans =  translationMatrix(vec3(0, 0.2, -4.5 * smoothValue)) * translationMatrix(vec3(0,3,0)) * translationMatrix(vec3(0,10,0)) *\n        rotationMatrix(vec3(1,0,0), 57.0 * smoothValue) * translationMatrix(vec3(0,-10,0));\n    \n    vec3 q = vec3(inverse(trans)*vec4(p,1));\n    float scale = 0.64;\n    return SDFData(scale*SDFSphere(q/scale), 1.0f);\n}\n\nSDFData objBackFloor(vec3 p) {\n    mat4 trans = translationMatrix(vec3(-1007,0.75,1));\n    vec3 q = vec3(inverse(trans)*vec4(p,1));\n\treturn SDFData(SDFBox(q, vec3(1000,0.5,1000)), 2.0f);\n}\n\nSDFData objFrontFloor(vec3 p) {\n    mat4 trans = translationMatrix(vec3(-10,0,1));\n    vec3 q = vec3(inverse(trans)*vec4(p,1));\n\treturn SDFData(SDFBox(q, vec3(25,0.5,60)), 3.0f);\n}\n\nfloat objWoodHelper(vec3 p, float rot) {\n    float globalZTrans = 3.5;\n\tmat4 trans1 = rotationMatrix(vec3(0,1,0), rot) * \n                  translationMatrix(vec3(0,3.8,globalZTrans)) *\n        \t\t  rotationMatrix(vec3(0,1,0), 90.0) *\n        \t\t  rotationMatrix(vec3(0,0,1), 45.0);\n    vec3 q1 = vec3(inverse(trans1)*vec4(p,1));\n    q1 = opCheapBend(q1/5.0, 0.7);\n    float s1 = 0.4*SDFBox(q1, vec3(0.04,0.6,0.55));\n    s1 = s1 * 10.0;\n    \n    mat4 trans2 = rotationMatrix(vec3(0,1,0), rot) * \n                  translationMatrix(vec3(0,1.22,-2.40 + globalZTrans)) *\n        \t\t  rotationMatrix(vec3(0,1,0), 90.0) *\n        \t\t  rotationMatrix(vec3(0,0,1), 142.0);\n    vec3 q2 = vec3(inverse(trans2)*vec4(p,1));\n    q2 = opCheapBend(q2/4.9, 2.6);\n    float s2 = 0.4*SDFBox(q2, vec3(0.07,0.3,0.55));\n    s2 = s2 * 10.0;\n    \n    mat4 trans3 =  rotationMatrix(vec3(0,1,0), rot) * \n                   translationMatrix(vec3(0,0.8,29.0f + globalZTrans));\n    vec3 q3 = vec3(inverse(trans3)*vec4(p,1));\n    float s3 = SDFBox(q3, vec3(2.68,0.25,30.0));\n    \n    return min(s3, min(s1, s2));\n}\n\nSDFData objWood(vec3 p) {\n    float first = objWoodHelper(p, 0.0f);\n    float second = objWoodHelper(p, 180.0f);\n    return SDFData(min(first, second), 4.0f);\n}\n\nSDFData objWasher(vec3 p) {\n    float n = sin(TIMESPEED * iTime);\n    float smoothValue = smoothstep(-1.00f, 1.0f, n) * 2.0 - 1.0;\n    smoothValue = (smoothValue + n) / 2.0f;\n\tmat4 trans = translationMatrix(vec3(0,3.5,0)) * translationMatrix(vec3(0,10,0)) * rotationMatrix(vec3(0,0,1), 37.0 * smoothValue) *\n        \t\ttranslationMatrix(vec3(0,-10,0)) * rotationMatrix(vec3(1,0,0), 90.0);\n        \n    vec3 q = vec3(inverse(trans)*vec4(p,1));\n    float scale = 0.57;\n    return SDFData(scale*SDFTorus82(q/scale, vec2(2.5,0.9)), 5.0f);\n}\n\nSDFData objString(vec3 p) {\n    float n = sin(TIMESPEED * iTime);\n    float smoothValue = smoothstep(-1.00f, 1.0f, n) * 2.0 - 1.0;\n    smoothValue = (smoothValue + n) / 2.0f;\n    mat4 trans = translationMatrix(vec3(0,3.5,0)) * translationMatrix(vec3(0,10,0)) * rotationMatrix(vec3(0,0,1), 37.0 * smoothValue) *\n        \t\ttranslationMatrix(vec3(0,-10,0)) * rotationMatrix(vec3(0,1,0), 90.0) *\n        translationMatrix(vec3(0,8,0));\n\n    vec3 q = vec3(inverse(trans)*vec4(p,1));\n    float scale = 0.7;\n    return SDFData(scale*SDFCappedCylinder(q/scale, vec2(0.01,9.0)), 6.0f);\n}\n\nSDFData SDFScene(vec3 p) {\n    const int size = 6;\n    SDFData objects[size] = SDFData[](\n                                    objBall(p),\n                                    objBackFloor(p),\n                                    objFrontFloor(p),\n                                    objWood(p),\n                                    objWasher(p),\n                                    objString(p)\n                                  );\n    \n    SDFData bestData = SDFData(100000000.0f,0.0f);\n    for(int i = 0; i < size; i++) {\n        if(objects[i].SDV < bestData.SDV) {\n            bestData = objects[i];\n        }\n    }\n    \n    return bestData;\n}\n\nSDFData raymarch(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        SDFData data = SDFScene(eye + depth * marchingDirection);\n        float dist = data.SDV;\n        if (dist < EPSILON) {\n            return SDFData(depth, data.id);\n        }\n        depth += dist;\n        if (depth >= end) {\n            return SDFData(end, 0.0f);\n        }\n    }\n    return SDFData(end, 0.0f);\n}\n\nvec3 estimateNormal(vec3 p) {\n    float epsilon = 0.01;\n    return normalize(vec3(\n        SDFScene(vec3(p.x + epsilon, p.y, p.z)).SDV - SDFScene(vec3(p.x - epsilon, p.y, p.z)).SDV,\n        SDFScene(vec3(p.x, p.y + epsilon, p.z)).SDV - SDFScene(vec3(p.x, p.y - epsilon, p.z)).SDV,\n        SDFScene(vec3(p.x, p.y, p.z  + epsilon)).SDV - SDFScene(vec3(p.x, p.y, p.z - epsilon)).SDV\n    ));\n}\n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n  vec3 f = normalize(center - eye);\n  vec3 s = normalize(cross(f, up));\n  vec3 u = cross(s, f);\n  return mat4(vec4(s, 0.0), vec4(u, 0.0), vec4(-f, 0.0), vec4(0.0, 0.0, 0.0, 1));\n}\n\nfloat lambert(vec3 N, vec3 L)\n{\n    vec3 nrmN = normalize(N);\n    vec3 nrmL = normalize(L);\n    float result = dot(nrmN, nrmL);\n    return max(result, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    if(uv.x < 0.15 || uv.x > 0.85) {\n    \tfragColor = vec4(0,0,0,1);\n        return;\n    }\n\n    vec3 dir = rayDirection(55.0, vec2(iResolution.x,iResolution.y), vec2(gl_FragCoord.x, gl_FragCoord.y));\n    vec3 eye = vec3(17.0, 14.0, 18.5);\n    vec3 lightPosition = vec3(1,1,1);\n\n    mat4 viewToWorld = viewMatrix(eye, vec3(-3.0, 2.0, -3.0), vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = (viewToWorld * vec4(dir, 0.0)).xyz;\n    \n    SDFData data = raymarch(eye, worldDir, MIN_DIST, MAX_DIST);\n    float dist = data.SDV;\n    \n    if (dist > MAX_DIST - EPSILON) {\n    \tfragColor = vec4(0,0,0,1);\n        return;\n    }\n    \n    vec3 p = eye + dist * worldDir;\n    vec3 normal = estimateNormal(p);\n\n    vec3 color;\n    if(data.id == 1.0f) {\n        color = vec3(1,0,0);\n    } else if(data.id == 2.0f) {\n        color = vec3(48, 101, 186) / 255.0f;\n    } else if(data.id == 3.0f) {\n        color = vec3(74, 105, 155) / 255.0f;\n    } else if(data.id == 4.0f) {\n        color = vec3(209, 174, 104) / 255.0;\n    } else if(data.id == 5.0f) {\n        color = vec3(168,168,168) / 255.0;\n    } else if(data.id == 6.0f) {\n    \tcolor = vec3(1,0,1);\n    }\n    vec3 col = color * lambert(normal, eye - lightPosition);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}