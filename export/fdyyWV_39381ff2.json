{"ver":"0.1","info":{"id":"fdyyWV","date":"1655584653","viewed":65,"name":"Premier test sur la plateforme","username":"Chama_lo","description":"Premier test pour prendre en main les notions de shaders, de rayons et d'intersections.\nEssaies sur un plan, une sphère et un cube.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//oscillation nombre de fois par seconde 0 -> 1\n\nconst float min_dist = 0.0;   // correspond à la distance minimal de détection à la caméra des intersection\nconst float max_dist = 100.0;// correspond à la distance maximal de détection à la caméra des intersection\n\nstruct Coord {float x; float y; float z;};\n\n\n//fonction qui donne une oscillation de 0 à 1 nb fois par secondes\nfloat oscPS(float nb, float pow)\n{\n    float returnValue = (abs(sin(iTime * nb)))*pow;\n    return returnValue;\n\n}\n\n\nbool rayonSphereInterscte(vec3 pointCentreSphere, float rayonSphere ,vec3 originRay, vec3 normalDirRay)\n{\n    \n    //float b = dot(2*originRay,(originRay-pointCentreSphere))\n    return false;\n}\n\n\n//calcul si un plan et un rayon s'intersecte \nbool rayonPlanInterscte(vec3 normalPlan, vec3 normalDirRay)\n{\n    if(dot(normalPlan,normalDirRay) == 0.0)\n    {\n        return false;\n    }\n    else\n    {\n        return true;\n    }\n\n}\n\n\nbool rayonLigneInterscte(vec3 originRay,vec3 normalDirRay,vec3 originDroite,vec3 normalDirDroite)\n{\n    return false;\n}\n\n\n//calcul la distance sur intersection vecteur sphere\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\n\n//renvoie la distance entre la caméra et le plan\nfloat rayonPlanIntersecteDistance(vec3 pointplan, vec3 normalPlan,vec3 originRay, vec3 normalDirRay)\n{\n    return (dot(normalPlan, pointplan - originRay) / dot(normalPlan,normalDirRay));\n}\n\n\n\n\n//Affiche une image sous condition par frag color\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 outputColor= vec4 (0.0,0.0,0.0,0.0);\n\n    //definition du plan de sol\n    //point central du plan\n    vec3 pointPlan = vec3 (0.0,-1.0,0.0);\n    \n    //vecteur normal à la central du plan\n    vec3 normalPlan = vec3 (0.0,1.0,0.0);\n    \n    //point central sphere\n    vec3 pointSphere = vec3 (0.0,5.0,10.0);\n    \n    \n    //transformation des pixels de l'écran en des coordonnées dans l'espace avec 0,0,0 centre de l'écran\n    // -0.5, 0,5 ,0 bord en haut à gauche\n    // 0.5 ,-0,5 ,0 bord en bas à droite\n    vec2 ScreePixel = vec2 (fragCoord.x / iResolution.x-0.5,fragCoord.y / iResolution.y-0.5 );\n    \n    //emplacement de la caméra\n    vec3 camOrigin = vec3 (0.0,0.0,-5.0 );\n    \n    //direction du rayon Caméra écran\n    vec3 RayDir = vec3(ScreePixel,0.0);\n    \n    \n    if(rayonPlanInterscte(normalPlan,RayDir)== true)\n    {\n       float distance = rayonPlanIntersecteDistance(pointPlan, normalPlan, camOrigin, RayDir);\n       \n       if(distance > 0.0 && distance< max_dist)\n       {\n           outputColor = vec4 (1.0-distance/max_dist,1.0-distance/max_dist,1.0-distance/max_dist,1.0);\n       }\n    }\n    \n    if(sphIntersect(camOrigin,RayDir,vec4(pointSphere,1.0)) > 0.0)\n    {\n        outputColor = vec4 (1.0,1.0,1.0,1.0);\n    }\n\n    // Output to screen\n    fragColor = outputColor;\n}","name":"Image","description":"","type":"image"}]}