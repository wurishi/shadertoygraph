{"ver":"0.1","info":{"id":"MfGyDR","date":"1731688367","viewed":87,"name":"Parameter Space Distance Field","username":"chronos","description":"Visualizing the distance field as a scalar field over the parameter space of a line segment and a quadratic Bernstein-Bezier curve.","likes":14,"published":1,"flags":0,"usePreview":1,"tags":["3d","sdf","visualization","bezier","space","distance","curve","field","decasteljau","bernstein","parameter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Parameter Space Distance Field Visualization by chronos\n    --------------------------------------------------------\n    \n    Interactive, click and drag in inset.\n    \n    plots distance, gradient and contours for distance between a line segment\n    and quadratic Bernstein Bezier curve over the parameter space.\n    X-axis: Line segment parameter\n    Y-Axis: Bezier curve parameter\n    \n    --------------------------------------------------------\n    self link: https://www.shadertoy.com/view/MfGyDR\n    \n\n*/\nfloat sRGBencode(float C_linear) { return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear); }\nvec3 sRGBencode(vec3 C_linear) { C_linear = clamp(C_linear, 0., 1.); return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z)); }\n\n\nfloat seg(vec3 a, vec3 b, vec3 p)\n{\n    b-=a; p-=a;\n    return length(clamp(dot(p,b)/dot(b,b), 0., 1.)*b - p);\n}\n\nvec3 deCasteljau(vec3 a, vec3 b, vec3 c, float t)\n{\n    return mix(\n        mix(a, b, t),\n        mix(b, c, t),\n        t\n    );\n}\n\nvec3 draw_inset(vec3 C0, vec3 C1, vec3 C2, vec3 A, vec3 B, vec2 uv, vec2 mouse)\n{\n    float seg_t = uv.x;\n    float bez_t = uv.y;\n    \n    // Evaluate Bezier curve and line segment:\n    vec3 C = deCasteljau(C0, C1, C2, bez_t);\n    vec3 P = mix(A, B, seg_t);\n    \n    float dist = distance(P, C);\n    \n    // This should be updated if the scene changes:\n    float min_dist = 0.6;\n    float max_dist = 1.5;\n    \n    float remapped_dist = clamp((dist-min_dist)/(max_dist-min_dist), 0., 1.);\n    \n    vec2 gradient = vec2(dFdx(dist), dFdy(dist));\n\n    float hue = atan(gradient.y, gradient.x);\n    vec3 gradient_color = (vec3(cos(hue), sin(hue), 0.) * max(1.-length(gradient), 0.) + vec3(0,0, sqrt(max(1.-dot(gradient,gradient), 0.))) )*.5 + .5;\n    \n    float perceptual_brightness = pow(remapped_dist, 3.);\n    \n    vec3 color = perceptual_brightness * gradient_color;\n    \n    // Draw topograpic / contour plot\n    const float freq = 17.76125;\n    float ps = length(fwidth(freq * dist));\n    color *= (smoothstep(0.5+.5*ps,0.5+1.5*ps, fract(freq * dist)) + smoothstep(0.5-.5*ps,0.5-1.5*ps, fract(freq * dist)))*.6+.4;\n    \n    // Draw mouse parameter position\n    ps = 2./iResolution.y;\n    color = mix(color, vec3(0,0,0), smoothstep(ps, -ps, length(mouse-uv)-0.03));\n    color = mix(color, vec3(1), smoothstep(ps, -ps, length(mouse-uv)-0.02));\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0);\n    \n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    // Camera parameters\n    float focal = 2.;\n    vec3 rd = normalize(vec3(uv, -focal));\n    vec3 ro = vec3(0, 1, 2.*focal);\n    \n    float time = iTime*.6;\n    float c = cos(time), s = sin(time);\n    mat3 R = mat3( c,0,s, 0,1,0,  -s,0,c );\n    \n    // Idle mouse animation\n    if(length(iMouse.xy) < 10.)\n    {\n        time = iTime*.8;\n        c = cos(time), s = sin(time);\n        mouse = vec2(c, s) * .35 + vec2(1, .5);\n    }\n   \n    // Rotate camera\n    rd *= R;\n    ro *= R;\n   \n    float eps = 1e-3;\n    \n    // Line segment endpoints\n    vec3 A = vec3(0.5,1.5,0.5);\n    vec3 B = vec3(-.5,0.5,-.5);\n    \n    // Bernstein-Bezier curve controlpoints\n    vec3 C0 = vec3(-1,.75,-1);\n    vec3 C1 = vec3(-2,.5,2);\n    vec3 C2 = vec3( 1,.25,1);\n    \n    // Render scene\n    float min_t = 9e9;\n    float t = 0.;\n    for(int i = 0; i < 100; i++)\n    {\n        vec3 p = rd * t + ro;\n        \n        float d = seg(A, B, p)-0.01;\n        d = min(d, length(p-A)-0.02);\n        d = min(d, length(p-B)-0.02);\n        \n        d = min(d, length(p-C0)-0.02);\n        d = min(d, length(p-C2)-0.02);\n        \n        \n        vec3 AB = mix(A,B, clamp(mouse.x-.5, 0., 1.));\n        vec3 C = deCasteljau(C0, C1, C2, clamp(mouse.y, 0., 1.));\n        d = min(d, length(p-AB)-0.03);\n        d = min(d, length(p-C)-0.03);\n        d = min(d, seg(AB, C, p)-0.01);\n        \n        vec3 C_prev = C0;\n        for(float x = 0.1; x <= 1.01; x+=0.1)\n        {\n            C = deCasteljau(C0, C1, C2, x);\n            d = min(d, seg(C_prev, C, p)-0.01);\n            C_prev = C;\n        }\n        \n        if(d < eps)\n        {\n            color += 1.;\n            min_t = t;\n            break;\n        }\n        \n        t += d;\n    }\n    \n    \n    // Draw ground plane:\n    \n    t = -ro.y/rd.y;\n    if(t >= 0. && t < min_t)\n    {\n        vec3 p = rd * t + ro;\n        vec2 tex_uv = fract(p.xz*.5+.5);\n        vec3 tex = pow(texture(iChannel3, tex_uv).rgb, vec3(2.2));\n        color += tex * step(abs(p.x),1.)* step(abs(p.z),1.);\n    }\n    \n    \n    // Draw inset\n    {\n        uv.x -= .5; mouse.x-=.5;\n        if(uv.x>= 0. && uv.y >= 0. && uv.x <= 1. && uv.y <= 1.)\n        {\n            color = draw_inset(C0, C1, C2, A, B, uv, clamp(mouse, 0., 1.));\n        }\n    }\n\n    fragColor = vec4(sRGBencode(color), 1);\n}","name":"Image","description":"","type":"image"}]}