{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define time (iTime * 0.5 - 2.0)\n\n#define dithering\t\t\t2.01\n\n#define samples 32\n\n#define brightness\t1.0\n#define gamma\t\t1.0\n\n//#define crossEyeStereo\n//#define nonlinearPerspective\n\nstruct material {\n\tvec3 color;\n\tvec3 light;\n\tfloat spec;\n};\n\nstruct hit {\n\tvec3 p;\n\tvec3 n;\n\tfloat t;\n\tmaterial m;\n};\n\n\nvec2 sphere (vec3 v, float f, vec3 p, vec3 d) {\n\tvec3 rp = p - v;\n\t\n\tfloat b = dot (d, rp);\n\tfloat c = dot (rp, rp) - f*f;\n\t\n\tfloat g = b*b - c;\n\t\n\tif (g < 0.0)\n\t\treturn vec2 (-1);\n\t\n\tfloat root = sqrt (g);\n\treturn vec2 (-root, root) - b;\n\n}\n\nhit scene (const in vec3 p, const in vec3 d) {\n\thit h;h.t = 1e20;\n\tfloat c = sin (time * 2.0) * 0.5 + 1.5;\n\t\n\tfloat t;\n\tvec2 t2;\n\tvec3 t3;\n\t\n\tvec3 invd = 1.0 / d;\n\t\n\tmaterial m1 = material (vec3 ( 1.0, 1.0, 1.0), vec3 ( 0.0, 0.0, 0.0),-1.0);\n\tmaterial m2 = material (vec3 ( 0.8, 0.5, 0.2), vec3 ( 0.0, 0.0, 0.0),-1.0);\n\tmaterial m3 = material (vec3 ( 0.2, 0.5, 0.8), vec3 ( 0.0, 0.0, 0.0),-1.0);\n\tmaterial m4 = material (vec3 ( 0.5, 0.7, 0.8), vec3 ( 0.0, 0.0, 0.0),-1.0);\n\tmaterial m5 = material (vec3 ( 1.0, 1.0, 1.0), vec3 ( 1.0, 1.0, 1.0),-1.0);\n\tmaterial m6 = material (vec3 ( 1.0, 0.0, 0.0), vec3 ( 0.0, 0.0, 0.0), 2.0);\n\t\n\tt3 = vec3 (0,0.5,0);\n\tt2 = sphere (t3, 0.5, p, d);\n\t\n\tt = t2.x;\n\tif (all (greaterThan (vec2 (t, h.t), vec2 (0, t)))) {\n\t\tvec3 r = p + d * t;\n\t\tif (r.y < 0.25)\n\t\t\th = hit (r, normalize (r - t3), t, m2);\n\t}\n\tt = t2.y;\n\tif (all (greaterThan (vec2 (t, h.t), vec2 (0, t)))) {\n\t\tvec3 r = p + d * t;\n\t\tif (r.y < 0.25) {\n\t\t\th = hit (r, normalize (r - t3), t, m1);\n\t\t\th.m.color *= mod (dot (fract (r * 4.0), vec3 (1)), 2.0) * 0.5 + 0.5;\n\t\t}\n\t}\n\tt2 = sphere (t3, 0.4, p, d);\n\tt = t2.x;\n\tif (all (greaterThan (vec2 (t, h.t), vec2 (0, t)))) {\n\t\tvec3 r = p + d * t;\n\t\th = hit (r, normalize (r - t3), t, m1);\n\t\th.m.spec = \n\t\t\tdot (cos (h.p.yz * 20.0), vec2 (h.p.x*h.p.x)) +\n\t\t\tdot (cos (h.p.xz * 20.0), vec2 (h.p.y*h.p.y)) +\n\t\t\tdot (cos (h.p.xy * 20.0), vec2 (h.p.z*h.p.z));\n\t\th.m.spec *= 10.0;\n\t}\n\t\n\tt2 = sphere (t3, 1.0, p, d);\n\t\n\tt = t2.x;\n\tif (all (greaterThan (vec2 (t, h.t), vec2 (0, t)))) {\n\t\tvec3 r = p + d * t;\n\t\tfloat m = dot (r.yz, r.yz) * 0.9999999;\n\t\tif (any (lessThan (vec2 (abs (r.z), m), vec2 (0.25, 0.5)))) {\n\t\t\th = hit (r, normalize (r - t3), t, m3);\n\t\t}\n\t}\n\tt = t2.y;\n\tif (all (greaterThan (vec2 (t, h.t), vec2 (0, t)))) {\n\t\tvec3 r = p + d * t;\n\t\tfloat m = dot (r.yz, r.yz) * 0.9999999;\n\t\tif (any (lessThan (vec2 (abs (r.z), m), vec2 (0.25, 0.5)))) {\n\t\t\th = hit (r, normalize (r - t3), t, m5);\n\t\t\th.m.light = fract (floor (m * 6.0) * 0.5) * vec3 (0.0, 1.0, 1.0);\n\t\t\th.m.color = vec3 (0.8, 0.2, 0.5);\n\t\t}\n\t}\n\t\n\tt = -p.y * invd.y;\n\tif (all (greaterThan (vec2 (t, h.t), vec2 (0, t)))) {\n\t\tvec3 r = p + d * t;\n\t\th = hit (r, vec3 (0,1,0), t, m4);\n\t\th.m.color *= mod (dot (floor (r.xz), vec2 (1)), 2.0) * 0.5 + 0.5;\n\t}\n\tt = (3.0 - p.y) * invd.y;\n\tif (all (greaterThan (vec2 (t, h.t), vec2 (0, t)))) {\n\t\tvec3 r = p + d * t;\n\t\th = hit (r, vec3 (0,1,0), t, m5);\n\t\th.m.light *= sin (time * 0.2) * 0.5 + 0.5;\n\t}\n\tt = (4.0 - p.x) * invd.x;\n\tif (all (greaterThan (vec2 (t, h.t), vec2 (0, t)))) {\n\t\tvec3 r = p + d * t;\n\t\th = hit (r, vec3 (1,0,0), t, m1);\n\t}\n\tt = (-4.0 - p.x) * invd.x;\n\tif (all (greaterThan (vec2 (t, h.t), vec2 (0, t)))) {\n\t\tvec3 r = p + d * t;\n\t\th = hit (r, vec3 (1,0,0), t, m1);\n\t}\n\tt = (4.0 - p.z) * invd.z;\n\tif (all (greaterThan (vec2 (t, h.t), vec2 (0, t)))) {\n\t\tvec3 r = p + d * t;\n\t\th = hit (r, vec3 (0,0,1), t, m6);\n\t}\n\tt = (-4.0 - p.z) * invd.z;\n\tif (all (greaterThan (vec2 (t, h.t), vec2 (0, t)))) {\n\t\tvec3 r = p + d * t;\n\t\th = hit (r, vec3 (0,0,1), t, m1);\n\t}\n\t\n\th.n = faceforward (h.n, h.n, d);\n\t\n\treturn h;\n}\n\nfloat seed1;\nfloat rndValue () {\n\tseed1 = fract (seed1 * 3.01);\n\treturn seed1;\n}\nvec2 rndUnit2D () {\n\tfloat angle = rndValue () * 6.28318530718;\n\treturn vec2 (sin (angle), cos (angle));\n}\nvec2 rnd2D () {\n\tfloat radius = sqrt (rndValue ());\n\treturn rndUnit2D () * radius;\n}\nvec3 rndUnit3D () {\n\tfloat z = rndValue () * 2.0 - 1.0;\n\tvec2 xy = rndUnit2D () * sqrt (1.0 - z*z);\n\treturn vec3 (xy, z);\n}\n\nvec3 dir (const in vec3 n, const in vec3 d, const in float p) {\n\tvec3 r = reflect (d, n);\n\tvec3 b = rndUnit3D ();\n\t\n\tvec3 na = normalize (cross (n, b));\n\tvec3 nb = cross (n, na);\n\t\n\tvec3 ra = normalize (cross (r, b));\n\tvec3 rb = cross (r, ra);\n\t\n\tvec2 ng = rnd2D ();\n\tfloat nl = length (ng);\n\t\n\tfloat t = pow (nl, p);\n\tvec2 rg = ng * t;\n\tfloat rl = nl * t;\n\t\n\tvec3 o;\n\tif (p < 0.0)\n\t\to = ng.x * na + ng.y * nb + n * sqrt (1.0 - nl*nl);\n\telse\n\t\to = rg.x * ra + rg.y * rb + r * sqrt (1.0 - rl*rl);\n\t\n\treturn o + n * clamp (-dot (o, n), 0.0, 1.0) * 2.0;\n}\n\nvec3 rayColor (const in vec3 p, const in vec3 d) {\n\thit h;\n\tvec3 p1 = p;\n\tvec3 d1 = d;\n\t\n\tvec3 light = vec3 (0);\n\tvec3 color = vec3 (1);\n\tfor (int i = 0; i < 3; i++) {\n\t\th = scene (p1, d1);\n\t\tlight += h.m.light * color;\n\t\tcolor *= h.m.color;\n\t\t\n\t\td1 = dir (h.n, d1, h.m.spec);\n\t\tp1 = h.p + d1 * 0.001;\n\t}\n\t\n\treturn light;\n}\n\nvec3 rayDirection (const in vec3 r, const in vec3 u, const in vec3 f, const in float fov, in vec2 cr) {\n\tvec2 rs = cr * 3.14159 * fov;\n\tvec2 sn = sin (rs);\n\tvec2 cs = cos (rs);\n\t\n\t#ifdef nonlinearPerspective\n\treturn normalize (r * sn.x + u * sn.y + f * cs.x * cs.y);\n\t#else\n\treturn normalize (r * cr.x * 4.0 * fov + u * cr.y * 4.0 * fov + f);\n\t#endif\n}\n\nvoid camera (inout vec3 right, inout vec3 up, inout vec3 forward, inout vec3 p, inout vec2 cr) {\n\tforward = normalize (forward);\n\tright = normalize (cross (up, forward));\n\tup = normalize (cross (forward, right));\n\t\n\t#ifdef crossEyeStereo\n\tfloat s = sign (cr.x);\n\tcr.x = (cr.x - s * 0.25);\n\tp -= right * s / iResolution.x * 200.0;\n\t#endif\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tseed1 = 1.0;\n\t\n\tvec2 tmp = mod (fragCoord.xy + time, dithering);\n\tseed1 += tmp.x + tmp.y / dithering;\n\t\n\t//seed1 += mod (fragCoord.x + fragCoord.y * 2.0, dithering);\n\t\n\tvec2 cr = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.x;\n\tvec3 p = vec3 (sin (time) * 2.0, sin (time) + 1.25, cos (time) * 2.0);\n\n\tvec3 right, up = vec3 (0,1,0), forward = vec3 (0,0.75,0)-p;\n\tcamera (right, up, forward, p, cr);\n\t\n\tvec3 color = vec3 (0);\n\tfor (int i = 0; i < samples; i++) {\n\t\tvec3 d = rayDirection (\n\t\t\tright, up, forward, 1.0,\n\t\t\tcr + vec2 (rndValue (), rndValue ()) / iResolution.x);\n\t\t\n\t\tcolor += rayColor (p, d);\n\t}\n\tcolor = pow (color / float (samples), vec3 (gamma));\n\tfragColor = vec4 (color * brightness, 0.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdBGDt","date":"1394837035","viewed":939,"name":"Door Knob","username":"DiLemming","description":"asd","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","lighting"],"hasliked":0,"parentid":"","parentname":""}}