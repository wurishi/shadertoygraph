{"ver":"0.1","info":{"id":"M3XBzN","date":"1728080978","viewed":45,"name":"MIS - Infinity Spiral","username":"nbardy","description":"https://github.com/NeoVertex1/MIS + ChatGPT = This!?","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["math"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nMorphing Infinity Spiral (MIS) Fractal - Enhanced Version\nAuthor: NeoVertex1\nEnhancements: Dynamic Zooming, Multi-Scale Rendering, Enhanced Coloring, Interactive Controls\n*/\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define MAX_ITER 30\n#define ESCAPE_RADIUS 10000.0\n\n// Complex number operations\nvec2 complexMul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 complexExp(vec2 a) {\n    return exp(a.x) * vec2(cos(a.y), sin(a.y));\n}\n\nvec2 complexLog(vec2 z) {\n    float magnitude = length(z);\n    float angle = atan(z.y, z.x);\n    return vec2(log(magnitude), angle);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize pixel coordinates to range [-1, 1]\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Time parameter\n    float t = iTime * 0.8; // Slower time scaling for smoother animation\n    \n    // Interactive zoom and pan based on mouse position\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    // Map mouse to zoom and pan factors\n    float zoom = 1.0 + 2.0 * sin(t); // Dynamic zoom oscillates between -1 and 1\n    vec2 pan = vec2( (mouse.x - 0.5) * 2.0, (mouse.y - 0.5) * 2.0 ) * 0.5;\n    \n    // Apply zoom and pan to UV coordinates\n    uv = (uv - pan) * zoom;\n    \n    // Parameters α and β (dynamic variation for more intricate patterns)\n    vec2 alpha = vec2(0.5 + 0.3 * sin(t * 0.5), 0.3 * cos(t * 0.5)); // α changes over time\n    vec2 beta  = vec2(0.5 + 0.3 * cos(t * 0.3), 0.3 * sin(t * 0.3)); // β changes over time\n    \n    // Initialize z\n    vec2 z = uv;\n    \n    int iter;\n    float smoothColor = 0.0;\n    \n    for(iter = 0; iter < MAX_ITER; iter++) {\n        // Compute z^alpha using polar coordinates\n        float r = length(z);\n        float theta = atan(z.y, z.x);\n        float r_alpha = pow(r, alpha.x) * exp(-alpha.y * theta);\n        float theta_alpha = alpha.x * theta + alpha.y * log(r);\n        vec2 z_alpha = vec2(r_alpha * cos(theta_alpha), r_alpha * sin(theta_alpha));\n        \n        // Compute (log(z))^beta\n        vec2 logz = complexLog(z);\n        float logz_mag = length(logz);\n        float logz_angle = atan(logz.y, logz.x);\n        float logz_beta_mag = pow(logz_mag, beta.x) * exp(-beta.y * logz_angle);\n        float logz_beta_angle = beta.x * logz_angle + beta.y * logz_mag;\n        vec2 logz_beta = vec2(logz_beta_mag * cos(logz_beta_angle), logz_beta_mag * sin(logz_beta_angle));\n        \n        // Compute exp(i * t * (log(z))^beta\n        vec2 exponent = vec2(-t * logz_beta.y, t * logz_beta.x);\n        vec2 exp_term = complexExp(exponent);\n        \n        // S_{alpha, beta}(z, t) = z_alpha * exp(i * t * (log(z))^beta)\n        vec2 z_next = complexMul(z_alpha, exp_term);\n        \n        // Check for divergence\n        if(length(z_next) > ESCAPE_RADIUS) {\n            // Smooth coloring\n            smoothColor = float(iter) + 1.0 - log(log(length(z_next)))/log(ESCAPE_RADIUS);\n            break;\n        }\n        \n        z = z_next;\n    }\n    \n    // Normalize iteration count for coloring\n    float normIter = float(iter) / float(MAX_ITER);\n    \n    // Enhanced Coloring: Use smooth iteration count and color cycling\n    vec3 color;\n    if(iter < MAX_ITER) {\n        // Map the smooth iteration count to colors using HSV to RGB conversion\n        float hue = 0.5 + 0.5 * sin(0.3 * t + normIter * 6.2831);\n        float saturation = 0.6;\n        float value = 1.0;\n        \n        // HSV to RGB\n        float c = value * saturation;\n        float x_col = c * (1.0 - abs(mod(hue * 6.0, 2.0) - 1.0));\n        float m = value - c;\n        vec3 rgb;\n        \n        if(hue < 1.0/6.0) {\n            rgb = vec3(c, x_col, 0.0);\n        }\n        else if(hue < 2.0/6.0) {\n            rgb = vec3(x_col, c, 0.0);\n        }\n        else if(hue < 3.0/6.0) {\n            rgb = vec3(0.0, c, x_col);\n        }\n        else if(hue < 4.0/6.0) {\n            rgb = vec3(0.0, x_col, c);\n        }\n        else if(hue < 5.0/6.0) {\n            rgb = vec3(x_col, 0.0, c);\n        }\n        else {\n            rgb = vec3(c, 0.0, x_col);\n        }\n        \n        color = rgb + vec3(m);\n    }\n    else {\n        // Points inside the set are colored black\n        color = vec3(0.0);\n    }\n    \n    // Multi-Scale Rendering: Overlay multiple scales for depth\n    // Example: Render additional layers with different zoom factors\n    for(int s = 1; s < 3; s++) {\n        float scaleFactor = 1.5 * float(s);\n        vec2 z_scaled = uv * scaleFactor;\n        vec2 z_temp = z_scaled;\n        int iter_scaled;\n        for(iter_scaled = 0; iter_scaled < MAX_ITER / 2; iter_scaled++) {\n            // Repeat MIS function\n            float r_s = length(z_temp);\n            float theta_s = atan(z_temp.y, z_temp.x);\n            float r_alpha_s = pow(r_s, alpha.x) * exp(-alpha.y * theta_s);\n            float theta_alpha_s = alpha.x * theta_s + alpha.y * log(r_s);\n            vec2 z_alpha_s = vec2(r_alpha_s * cos(theta_alpha_s), r_alpha_s * sin(theta_alpha_s));\n            \n            vec2 logz_s = complexLog(z_temp);\n            float logz_mag_s = length(logz_s);\n            float logz_angle_s = atan(logz_s.y, logz_s.x);\n            float logz_beta_mag_s = pow(logz_mag_s, beta.x) * exp(-beta.y * logz_angle_s);\n            float logz_beta_angle_s = beta.x * logz_angle_s + beta.y * logz_mag_s;\n            vec2 logz_beta_s = vec2(logz_beta_mag_s * cos(logz_beta_angle_s), logz_beta_mag_s * sin(logz_beta_angle_s));\n            \n            vec2 exponent_s = vec2(-t * logz_beta_s.y, t * logz_beta_s.x);\n            vec2 exp_term_s = complexExp(exponent_s);\n            \n            vec2 z_next_s = complexMul(z_alpha_s, exp_term_s);\n            \n            if(length(z_next_s) > ESCAPE_RADIUS) {\n                float normIter_s = float(iter_scaled) / float(MAX_ITER / 2);\n                float hue_s = 0.5 + 0.5 * sin(0.3 * t + normIter_s * 6.2831 + float(s) * 1.0);\n                float saturation_s = 0.6;\n                float value_s = 0.5;\n                \n                float c_s = value_s * saturation_s;\n                float x_s = c_s * (1.0 - abs(mod(hue_s * 6.0, 2.0) - 1.0));\n                float m_s = value_s - c_s;\n                vec3 rgb_s;\n                \n                if(hue_s < 1.0/6.0) {\n                    rgb_s = vec3(c_s, x_s, 0.0);\n                }\n                else if(hue_s < 2.0/6.0) {\n                    rgb_s = vec3(x_s, c_s, 0.0);\n                }\n                else if(hue_s < 3.0/6.0) {\n                    rgb_s = vec3(0.0, c_s, x_s);\n                }\n                else if(hue_s < 4.0/6.0) {\n                    rgb_s = vec3(0.0, x_s, c_s);\n                }\n                else if(hue_s < 5.0/6.0) {\n                    rgb_s = vec3(x_s, 0.0, c_s);\n                }\n                else {\n                    rgb_s = vec3(c_s, 0.0, x_s);\n                }\n                \n                color += rgb_s + vec3(m_s);\n                break;\n            }\n            z_temp = z_next_s;\n        }\n    }\n    \n    // Apply final color\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}