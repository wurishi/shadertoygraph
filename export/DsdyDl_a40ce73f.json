{"ver":"0.1","info":{"id":"DsdyDl","date":"1699648697","viewed":29,"name":"Tp 1 informatique graphique","username":"Ryuki","description":"ellipsoide","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["workonellipsoide"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Sphere{\n    vec3 c;// Center\n    float r;// Radius\n    int i;// Texture Id\n};\n\nstruct Ellipsoide{\n    vec3 e; //centre\n    vec3 a; \n    vec3 b;\n    vec3 c;\n    int i; //TextureID\n};\n\nstruct Box {\n    vec3 min; // Minimum corner\n    vec3 max; // Maximum corner\n    int i;    // Texture Id\n};\n\nstruct Cylindre{\n    vec3 a,b;// \n    float r;// Radius\n    int i;// Texture Id\n\n};\n\n\n\n\nstruct Plane{\n    vec3 n;// Normal\n    vec3 p;// Point\n    int i;// Texture Id\n};\n\nstruct Hit{\n    float t;// Intersection depth\n    vec3 n;// Normal\n    int i;// Texture Id\n};\n\nstruct Ray{\n    vec3 o;// Origin\n    vec3 d;// Direction\n};\n\n\n   struct Material\n{   vec3 kd; // Composante diffuse\n    vec3 ka; // Composante ambiante\n    \n    vec3 ks; // Composante spéculaire\n    float shininess; // Exposant de brillance pour le terme spéculaire\n    //float reflectivity;\n};\n\n\n\n\n\nfloat Checkers(in vec2 p)\n{\n    // Filter kernel\n    vec2 w=fwidth(p)+.001;\n    // Box box filter\n    vec2 i=2.*(abs(fract((p-.5*w)*.5)-.5)-abs(fract((p+.5*w)*.5)-.5))/w;\n    // xor pattern\n    return.5-.5*i.x*i.y;\n}\n\n\n\n\n\n\nfloat RadialPattern(in vec2 p)\n{\n    // Calculate the distance from the center\n    float distanceFromCenter = length(p);\n\n    // Define the number of radial segments and their width\n    int numSegments = 12;\n    float segmentWidth = 0.2;\n\n    // Calculate the angle of the current point\n    float angle = atan(p.y, p.x);\n\n    // Map the angle to [0, 1] and repeat it for the segments\n    float angleMapped = mod(angle / (2.0 * 3.14159265359), 1.0);\n\n    // Create a pattern based on the angle and distance\n    float pattern = mod(angleMapped * float(numSegments), 1.0);\n\n    // Apply a smoothstep to create transitions between segments\n    float smoothPattern = smoothstep(segmentWidth, segmentWidth + 0.05, pattern);\n\n    return smoothPattern;\n}\n\nvec3 UniformTexture(vec3 color) {\n    return color;\n}\n\nvec3 ConcentricTexture(vec3 p, vec3 center, vec3 color1, vec3 color2, float bandWidth) {\n    float distance = length(p - center);\n    float pattern = sin(distance / bandWidth);\n    return mix(color1, color2, (pattern + 1.0) / 2.0);\n}\n\nvec3 RadialTexture(vec3 p, vec3 axis, vec3 color1, vec3 color2, float bandWidth) {\n    // Project the point onto the axis to find the radial distance\n    vec3 projection = dot(p, axis) * axis;\n    float distance = length(p - projection);\n    float pattern = sin(distance / bandWidth);\n    return mix(color1, color2, (pattern + 1.0) / 2.0);\n}\n\n\n\n\n\n// Compute point on ray\nvec3 Point(Ray ray,float t)\n{\n    return ray.o+t*ray.d;\n}\n\nvec3 ambient = vec3(0.1, 0.1, 0.1);\nvec3 diffuse = vec3(0.75, 0.3, 0.3);\nvec3 specular = vec3(1.0, 1.0, 1.0);\nfloat shininess = 50.0;\n\n\n\n// Compute color\n// i : Texture index\n// p : Point\nMaterial Texture(vec3 p, int i) {\n    Material mat;\n    \n    // Assume some parameters for textures\n    float checkerSize = 1.0;\n    vec3 concentricCenter = vec3(0.0);\n    float concentricBandWidth = 1.0;\n    vec3 radialAxis = vec3(0.0, 1.0, 0.0);\n    float radialBandWidth = 1.0;\n\n    if (i == 0) {\n        // Checker texture\n        float f = Checkers(p.xy * checkerSize);\n        vec3 color = mix(vec3(1.0), vec3(0.0), f); // White and black checkers\n        mat.kd = color;\n    } else if (i == 1) {\n        // Uniform texture\n        mat.kd = vec3(0.8, 0.5, 0.4); // Some color\n    } else if (i == 2) {\n        // Concentric texture\n        mat.kd = ConcentricTexture(p, concentricCenter, vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), concentricBandWidth);\n    } else if (i == 3) {\n        // Radial texture\n        mat.kd = RadialTexture(p, radialAxis, vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), radialBandWidth);\n    } else {\n        // Fallback texture, maybe some ground or default texture\n        mat.kd = vec3(0.5); // Grey color\n    }\n    \n    // Set the other material properties (for simplicity, using same for all)\n    mat.ka = ambient;\n    mat.ks = specular;\n    mat.shininess = shininess;\n    //mat.reflectivity = some value based on the material; // Uncomment and set appropriately if you have reflectivity\n\n    return mat;\n}\n\n// RotateRay function\n// Function to create a rotation matrix from an axis and an angle\n\nRay translateRay(Ray ray, vec3 offset) {\n    ray.o += offset*cos(iTime);\n    return ray;\n}\n\n\nRay RotateRay(Ray ray, float angle, vec3 axis) {\n    // Ensure the axis is normalized\n    axis = normalize(axis);\n    \n    // Create the rotation matrix\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    mat3 rotationMatrix = mat3(\n        oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.x * axis.z + axis.y * s,\n        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\n    );\n    \n    // Rotate the ray's direction\n    ray.d = rotationMatrix * ray.d;\n    \n    // Rotate the ray's origin\n    ray.o = rotationMatrix * (ray.o - axis) + axis; // Rotate around the given axis\n    \n    return ray;\n}\n\n\nRay scaleRay(Ray ray, vec3 scaleFactor) {\n    ray.o *= scaleFactor;\n    // ray.d remains unchanged because direction scale is not meaningful\n    return ray;\n}\n\nRay homothetieRay(Ray ray, float rapport){\n    ray.d=(1.005+rapport*0.005*(cos(iTime)))*ray.d;\n    return ray;\n}\n\n// Sphere intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectSphere(Ray ray,Sphere sph,out Hit x)\n{\n    \n\n    vec3 oc=ray.o-sph.c;\n    float b=dot(oc,ray.d);\n    float c=dot(oc,oc)-sph.r*sph.r;\n    float d=b*b-c;\n    if(d>0.)\n    {\n        float t=-b-sqrt(d);\n        if(t>0.)\n        {\n            vec3 p=Point(ray,t);\n            x=Hit(t,normalize(p-sph.c),sph.i);\n            \n            return true;\n        }\n    }\n    return false;\n    \n}\n\nbool IntersectCylinder(Ray ray, Cylindre cy, out Hit x)\n\n{\n    \n    \n    vec3 AxeCylindre = normalize(cy.b - cy.a);\n    vec3 ao = ray.o - cy.a;\n    float a = dot(ray.d - (dot(ray.d, AxeCylindre) * AxeCylindre), ray.d - (dot(ray.d, AxeCylindre) * AxeCylindre));\n    float b = 2.0 * dot(ray.d - (dot(ray.d, AxeCylindre) * AxeCylindre), ao - dot(ao, AxeCylindre) * AxeCylindre);\n    float c = dot(ao - dot(ao, AxeCylindre) * AxeCylindre, ao - dot(ao, AxeCylindre) * AxeCylindre) - cy.r * cy.r;\n\n    float discriminant = b * b - 4.0 * a * c;\n    bool test1=false;\n    bool test11=false;\n    bool test12=false;\n    bool test2=false;\n    bool test3=false;\n    float t1=0.;\n    float t2=0.;\n    float tTop=0.;\n    float tBottom=0.;\n    vec3 p;\n    float h;\n    \n\n    if (discriminant > 0.0)\n    {\n        t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n        t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n\n        if (t1 > 0.0)\n        {\n            p = ray.o + t1 * ray.d;\n            h = dot(p - cy.a, AxeCylindre);\n            if (h >= 0.0 && h <= length(cy.b - cy.a))\n            {\n                // Intersection avec la surface laterale\n                vec3 n = normalize(p - (cy.a + h * AxeCylindre));\n                x = Hit(t1, n, cy.i);\n                test1=true;\n                test11=true;\n            }\n        }\n        else if (t2 < 0.0)\n        {\n            test1=false;\n        }\n        else\n        {\n            vec3 p = ray.o + t2 * ray.d;\n            float h = dot(p - cy.a, AxeCylindre);\n            if (h >= 0.0 && h <= length(cy.b - cy.a))\n            {\n                // Intersection with the cylinder's lateral surface\n                vec3 n = normalize(p - (cy.a + h * AxeCylindre));\n                x = Hit(t2, n, cy.i);\n                \n                test1= true;\n                test12=true;\n            }\n        }\n    }\n\n    // Teste l'intersection avec la face superieure\n    tTop = dot(cy.a - ray.o, AxeCylindre) / dot(ray.d, AxeCylindre);\n    vec3 topIntersection = ray.o + tTop * ray.d;\n    float topDistance = length(topIntersection - cy.a);\n    if (tTop > 0.0 && topDistance <= cy.r)\n    {\n        x = Hit(tTop, normalize(cy.a - topIntersection), cy.i);\n        test2=true;\n    }\n\n    // Teste l'intersection avec la face infÃ©rieure\n    tBottom = dot(cy.b - ray.o, AxeCylindre) / dot(ray.d, AxeCylindre);\n    vec3 bottomIntersection = ray.o + tBottom * ray.d;\n    float bottomDistance = length(bottomIntersection - cy.b);\n    if (tBottom > 0.0 && bottomDistance <= cy.r)\n    {\n        x = Hit(tBottom, normalize(cy.b -bottomIntersection), cy.i);\n        test3=true;\n    }\n    \n    if (test2 && test3) {\n        if (tTop<tBottom)\n            {x = Hit(tTop, normalize(cy.a - topIntersection), cy.i);\n             return true;};}\n    if (test1 && test2){\n        if (test11 && t1<tTop){\n             vec3 n = normalize(p - (cy.a + h * AxeCylindre));\n                x = Hit(t1, n, cy.i);\n             return true;};\n        if (test12 && (t2<tTop)){\n              vec3 n = normalize(p - (cy.a + h * AxeCylindre));\n                x = Hit(t2, n, cy.i);\n                return true;}\n        }\n     if (test1 && test3){\n        if (test11 && t1<tBottom){\n             vec3 n = normalize(p - (cy.a + h * AxeCylindre));\n                x = Hit(t1, n, cy.i);\n             return true;};\n        if (test12 && (t2<tBottom)){\n              vec3 n = normalize(p - (cy.a + h * AxeCylindre));\n                x = Hit(t2, n, cy.i);\n                return true;};\n        }\n                \n\n    return test1||test2||test3;\n}\n\n\nbool IntersectEllipsoide(Ray ray,Ellipsoide el,out Hit x)\n\n{ \n\n // Define the rotation axis and angle for the ellipsoid here as constants\n    // Or calculate them based on some logic you have\n    const vec3 rotationAxis = vec3(1.0, 0.0, 0.0); // Rotate around the x-axis\n    float rotationAngle = iTime; // Rotate by 45 degrees, converted to radians\n\n    // Apply the rotation to the ray before the intersection test\n    ray = RotateRay(ray, rotationAngle, rotationAxis);\n\n\n  float dx=ray.d.x;\n  float dy=ray.d.y;\n  float dz=ray.d.z;\n  \n  float a=((dx*dx)/dot(el.a,el.a)) + ((dy*dy)/dot(el.b,el.b)) + ((dz*dz)/dot(el.c,el.c));\n  float b=2.0*(dx*((ray.o.x-el.e.x)/dot(el.a,el.a)) + dy*((ray.o.y-el.e.y)/dot(el.b,el.b)) + dz*((ray.o.z-el.e.z)/dot(el.c,el.c)));\n  float c=((ray.o.x-el.e.x)*(ray.o.x-el.e.x)/dot(el.a,el.a)) + ((ray.o.y-el.e.y)*(ray.o.y-el.e.y)/dot(el.b,el.b)) + ((ray.o.z-el.e.z)*(ray.o.z-el.e.z)/dot(el.c,el.c))-1.0;\n  \n  float d= b*b -4.0*a*c;\n  \n  if (d>0.)\n  \n  {\n      float t1=(-b - sqrt(d))/(2.0*a);\n      float t2=(-b + sqrt(d))/(2.0*a);\n      if (t1>0.)\n     {   vec3 p=Point(ray,t1);\n         x=Hit(t1,p-el.e,el.i);\n         return true;\n     }\n     else if (t2<0.) \n     {return false;}\n     else\n     {   vec3 p=Point(ray,t2);\n         x=Hit(t2,p-el.e,el.i);\n     }\n   }\n   \n   return false;\n   \n}\n\n\n\n\n\n\n\nbool IntersectBox(Ray ray, Box box, out Hit hit) {\n    ray = translateRay(ray,vec3(0.,0.,1.));\n    // Calculate the intersection distances along each axis\n    vec3 invDir = 1.0 / ray.d;\n    vec3 t1 = (box.min - ray.o) * invDir;\n    vec3 t2 = (box.max - ray.o) * invDir;\n\n    // Find the intersections for the near and far planes\n    vec3 tmin = min(t1, t2);\n    vec3 tmax = max(t1, t2);\n\n    // Find the largest tmin and the smallest tmax\n    float near = max(max(tmin.x, tmin.y), tmin.z);\n    float far = min(min(tmax.x, tmax.y), tmax.z);\n\n    if (near <= far && far >= 0.0) {\n        // The ray intersects the box\n\n        // Calculate the intersection point\n        vec3 intersectionPoint = ray.o + ray.d * near;\n\n        // Calculate the normal at the intersection point\n        vec3 normal = vec3(0.0);\n\n        if (abs(intersectionPoint.x - box.max.x) < 0.001) normal = vec3(1.0, 0.0, 0.0);\n        else if (abs(intersectionPoint.x - box.min.x) < 0.001) normal = vec3(1.0, 0.0, 0.0);\n        else if (abs(intersectionPoint.y - box.max.y) < 0.001) normal = vec3(0.0, 1.0, 0.0);\n        else if (abs(intersectionPoint.y - box.min.y) < 0.001) normal = vec3(0.0, -1.0, 0.0);\n        else if (abs(intersectionPoint.z - box.max.z) < 0.001) normal = vec3(0.0, 0.0, 1.0);\n        else if (abs(intersectionPoint.z - box.min.z) < 0.001) normal = vec3(0.0, 0.0, -1.0);\n\n        hit.t = near;\n        hit.n = normal;\n        hit.i = box.i;\n\n        return true;\n    }\n\n    return false;\n}\n\n\n\n\n// Plane intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectPlane(Ray ray,Plane pl,out Hit x)\n{\n    float t=-dot(ray.o-pl.p,pl.n)/dot(ray.d,pl.n);\n    if(t>0.)\n    {\n        \n        x=Hit(t,vec3(0,0,1),0);\n        return true;\n    }\n    return false;\n}\n\n// Scene intersection\n// ray : The ray\n//   x : Returned intersection information\nbool Intersect(Ray ray,out Hit x)\n{\n    // Spheres\n    const Sphere sph1=Sphere(vec3(0.,0.5,4.),1.,1);\n    const Sphere sph2=Sphere(vec3(5.,0.5,4.),1.,1);\n    const Plane pl=Plane(vec3(0.,0.,4.),vec3(5.,0.,-8.),0);\n    \n    //ellipsoides\n    const Ellipsoide el1=Ellipsoide(vec3(-5.,1.,4),vec3(2.,0.,0.),vec3(0.,0.,1.),vec3(0.,1.,0.),2);\n    \n    \n    //intersect Box\n    const Box myBox = Box(vec3(-10.5, 0.0, 3.5),vec3(-9.5, 1.0, 4.5), 1);\n    \n    \n    \n    //intersect Cylindre\n    \n    const Cylindre cy1= Cylindre(vec3(5.,1.,1.),vec3 (5.,1.,-4.), 2.,6);\n    const Cylindre cy2= Cylindre(vec3(0.,1.,1.),vec3 (0.,1.,-4.), 2.,6);\n    const Cylindre cy3= Cylindre(vec3(-5.,1.,1.),vec3 (-5.,1.,-2.), 2.,6);\n    const Cylindre cy4= Cylindre(vec3(-10.,1.,1.),vec3 (-10.,1.,-4.), 2.,6);\n    const Cylindre cy5= Cylindre(vec3(-15.,1.,1.),vec3 (-15.,1.,-4.), 2.,6);\n    \n    const Sphere sph4=Sphere(vec3(-14.,1.,4.),0.5,6);\n    const Sphere sph5=Sphere(vec3(-17., 1., 4.),0.5,6);\n    const Cylindre cyl6 = Cylindre(vec3(-14., 1., 4.), vec3(-17., 1., 4.), 0.5, 6);\n    \n    //const Cylindre myCylindre = Cylindre(vec3(0.0, 0.0, 0.0), 0.1, 0.5, 1);\n    \n    //intersect Torus\n    \n   // const Torus myTorus = Torus(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 0.2, 0.2,1);\n\n\n\n    \n    \n    x=Hit(1000.,vec3(0),-1);\n    Hit current;\n    bool ret=false;\n    if(IntersectSphere(homothetieRay(ray,0.5),sph1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n    if(IntersectSphere(homothetieRay(ray,1.0),sph2,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectPlane(ray,pl,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n     if(IntersectEllipsoide(ray,el1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n     if(IntersectBox(ray,myBox,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n     if(IntersectCylinder(ray,cy1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n     if(IntersectCylinder(ray,cy2,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n     if(IntersectCylinder(ray,cy3,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n     if(IntersectCylinder(ray,cy4,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectSphere(ray,sph4,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectSphere(ray,sph5,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectCylinder(ray,cyl6,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n     if(IntersectCylinder(ray,cy5,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n  \n  /* if(IntersectTorus(ray,myTorus,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }*/\n  \n  \n    return ret;\n}\n\n/*float GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}*/\n\nvec3 Background(vec3 rd)\n{\n    return mix(vec3(.8,.8,.9),vec3(.7,.7,.8),rd.z);\n}\n\n// Camera rotation matrix\n// ro : Camera origin\n// ta : Target point\nmat3 setCamera(in vec3 ro,in vec3 ta)\n{\n    vec3 cw=normalize(ta-ro);\n    vec3 cp=vec3(0,0,1);\n    vec3 cu=-normalize(cross(cw,cp));\n    vec3 cv=-normalize(cross(cu,cw));\n    return mat3(cu,cv,cw);\n}\n\n// Hemisphere direction\n\nvec3 Hemisphere(int seed,vec3 n)\n\n{\n\n    float a=fract(sin(176.19*float(seed)));// Uniform randoms\n\n    float b=fract(sin(164.19*float(seed)));\n\n   \n\n    float u=2.*3.1415*a;// Random angle\n\n    float v=acos(2.*b-1.);// Arcosine distribution to compensate for poles\n\n   \n\n    vec3 d=vec3(cos(u)*cos(v),sin(u)*cos(v),sin(v));// Direction\n\n    if(dot(d,n)<0.){d=-d;}// Hemishpere\n\n   \n\n    return d;\n\n}\n\n\n\nfloat AmbientOcclusion(vec3 p, vec3 n, int N) {\n    float occlusion = 0.0;\n    float radius = 1.0; // The radius within which to check for occluding geometry\n\n    for (int i = 0; i < N; i++) {\n        vec3 d = Hemisphere(i, n); // Direction in the hemisphere\n        Ray aoRay;\n        aoRay.o = p + n * 0.01; // Offset the origin a bit along the normal\n        aoRay.d = d;\n\n        Hit hit;\n        if (Intersect(aoRay, hit) && hit.t < radius) {\n            occlusion += (1.0 - hit.t / radius); // Weight by distance to simulate falloff\n        }\n    }\n\n    return 1.0 - occlusion / float(N); // Average the occlusion and subtract from 1 to get the occlusion factor\n}\n\n\n\n\n\n\n// Apply color model\n// m : Material\n// n : normal\nvec3 Color(Material mat, vec3 n, vec3 p, vec3 v, vec3 l, int N) {\n\n Hit osef;\n   \n    \n    vec3 light=normalize(vec3(0,1,1));\n     if(!Intersect(Ray(p+n*0.1,light),osef)){\n    // Calculate the ambient occlusion factor\n    float ao = AmbientOcclusion(p, n, N);\n    \n    // Calculate the light direction\n    vec3 lightDir = normalize(l - p);\n    \n    // Reflect view vector about the normal for the specular term\n    vec3 r = reflect(-lightDir, n);\n    \n    // Calculate the ambient term with occlusion\n    vec3 ambient = ao * mat.ka;\n    \n    // Calculate the diffuse term\n    float diff = max(dot(n, lightDir), 0.0);\n    vec3 diffuse = mat.kd * diff;\n    \n    // Calculate the specular term\n    float spec = pow(max(dot(v, r), 0.0), mat.shininess);\n    vec3 specular = mat.ks * spec;\n    \n    // Combine the terms\n    return ambient + diffuse + specular;\n    }\n}\n\n\n\n\n\n// Compute color\n// i : Texture index\n// p : Point\n\n\n\n\n// Rendering\nvec3 Shade(Ray ray)\n{\n    vec3 col = vec3(0.0); // Initialize the color to black\n\n    // The maximum number of reflections\n    int maxReflections = 2;\n\n    for (int numReflections = 0; numReflections < maxReflections; numReflections++) {\n        Hit x;\n        bool idx = Intersect(ray, x);\n        vec3 p = Point(ray, x.t);\n\n        if (idx)\n        {\n            Material mat = Texture(p, x.i);  \n             // View direction is from the point to the ray origin\n        vec3 viewDir = normalize(ray.o - p);\n        \n        // For simplicity, using a fixed light direction\n        vec3 lightDir = normalize(vec3(1, 1, 1));\n            \n            if (x.i == 6) {\n               \n                vec3 normal = x.n;\n                vec3 reflectionDir = reflect(ray.d, normal); // Reflect the ray\n\n                // Create a new ray for the reflection\n                ray = Ray(p + 0.001 * reflectionDir, reflectionDir);\n\n               \n            }\n            else {\n                // Apply the color model without reflection for other objects\n                col += Color(mat, x.n, p,  viewDir, lightDir,1);\n                break; // Exit the loop\n            }\n                        \n        \n        }else {\n            // If there's no intersection, return the background color\n            col += Background(ray.d);\n            break; // Exit the loop\n        }\n            \n            \n    }\n\n    return col;\n}\n\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    // From uv which are the pixel coordinates in [0,1], change to [-1,1] and apply aspect ratio\n    vec2 uv=(-iResolution.xy+2.*fragCoord.xy)/iResolution.y;\n    \n    // Mouse control\n    vec2 mouse=iMouse.xy/iResolution.xy;\n    \n    // Ray origin\n    vec3 ro=20.*normalize(vec3(sin(2.*3.14*mouse.x),cos(2.*3.14*mouse.x),1.4*(mouse.y-.1)));\n    vec3 ta=vec3(-5.,2.,0.5);\n    mat3 ca=setCamera(ro,ta);\n    \n    // Ray\n    vec3 rd=ca*normalize(vec3(uv.xy*tan(radians(30.)),1.));\n    \n    // Render\n   vec3 lightDirection = normalize(vec3(1.0, 1.0, 1.0)); // Example light direction\n   vec3 lightPosition = vec3(5.0, 2.0, 5.0); // You can adjust the light position\n   vec3 viewPosition = vec3(5.0, 2.0, 5.0);\n\n// Calculate the direction of the ray from the view position to the current pixel\n    vec3 rayDirection = normalize(rd);\n    \n\n   \n\n// Call the Shade function with the necessary parameters\n   vec3 col = Shade(Ray(ro, rd));\n\n    \n    fragColor=vec4(col,1.);\n    \n    \n}","name":"Image","description":"","type":"image"}]}