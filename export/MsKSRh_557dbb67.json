{"ver":"0.1","info":{"id":"MsKSRh","date":"1462960198","viewed":541,"name":"SDF Visualizer","username":"daseyb","description":"Making images for presentations.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////\n// Settings\n////////////////////////\n#define VISUALIZE_GRADIENT_ERROR false\n#define VISUALIZE_GRADIENT_ONLY false\n#define VIS_STEP_SIZE 10.0\n#define GRADIENT_FALL_OFF 0.02\n#define GRADIENT_MOVEMENT_SPEED 10.0\n#define SOLID_INSIDE true\n#define COLOR_INSIDE vec3(32.0/255.0, 72.0/255.0, 211.0/255.0)\n#define COLOR_OUTSIDE vec3(211.0/255.0, 72.0/255.0, 23.0/255.0)\n\n// I recommend http://mercury.sexy/hg_sdf/ for more primitives and operations.\n////////////////////////\n// Utility Methods\n////////////////////////\n\n#define PHI (sqrt(5.0)*0.5 + 0.5)\n#define PI 3.14159265\n\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);   \n}\n\n////////////////////////\n// Operations\n////////////////////////\nfloat opUnion(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat opSubtract(float d1, float d2) {\n    return max(d1, -d2);\n}\n\nfloat opIntersect(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat opUnionSoft(float a, float b, float r) {\n\tfloat e = max(r - abs(a - b), 0.0);\n\treturn min(a, b) - e*e*0.25/r;\n}\n\nfloat opUnionChamfer(float a, float b, float r) {\n\treturn min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\nfloat opUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nfloat opSSoft(float d1, float d2, float r) {\n\tfloat e = max(r - abs(-d1 - d2), 0.0); \n\tfloat factor = (e*e*0.25)/r;\n\treturn max(-d1, d2) + factor;\n}\n\n////////////////////////\n// Primitives\n////////////////////////\nfloat sdBox(vec2 p, vec2 pos, vec2 e) {\n\tvec2 d = abs(p-pos)-e;\n    return length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\nfloat sdCircle (vec2 p, vec2 pos, float r) {\n\treturn length(p - pos) - r;\n}\n\nfloat sdHexPrism(vec2 p, vec2 pos, vec2 h )\n{\n    vec2 q = abs(p-pos);\n    return max(-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat fCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n////////////////////////\n// Scene\n////////////////////////\n// EDIT THIS TO CHANGE WHAT'S BEING RENDERED\nfloat scene(vec2 p) {\n    p -= - iResolution.xy/vec2(2.0);\n    return fCappedCylinder( vec3(p.x, p.y, iMouse.x), 100.0, 100.0);\n    return opSSoft(length(p - iResolution.xy/vec2(2.0)) - 100.0, \n               length(p - iResolution.xy/vec2(2.0) + vec2(80.0)) - 30.0, 1.0);\n}\n\n////////////////////////\n// Visualization\n////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord.xy;\n    float dist = scene(uv);\n    float absDist = abs(dist);\n    vec3 finalColor;\n    \n    // Rings\n    float visDist = mod(abs(dist) - iTime * GRADIENT_MOVEMENT_SPEED, VIS_STEP_SIZE)/VIS_STEP_SIZE;\n    visDist = abs(visDist - 0.5) * 2.0;\n\n    float visDistFac = pow(visDist, 3.0) * exp(-absDist * GRADIENT_FALL_OFF);\n\n    vec3 white = vec3(1, 1, 1);\n    vec3 black = vec3(0, 0, 0);\n\n    vec3 colorOutside = mix(COLOR_OUTSIDE, vec3(0, 0, 0), dist * GRADIENT_FALL_OFF); \n    vec3 colorInside = mix(COLOR_INSIDE  * 3.0, vec3(0, 0, 0), -dist * GRADIENT_FALL_OFF); \n\n    finalColor = dist < 0.0 ? (SOLID_INSIDE ? white : mix(colorInside, white, visDistFac)) : mix(colorOutside, white, visDistFac);\n\n    finalColor = mix(black, finalColor, smoothstep(0.0, 2.0, absDist));\n    \n    finalColor = clamp(finalColor, vec3(0, 0, 0), vec3(1, 1, 1));\n    \n    if(VISUALIZE_GRADIENT_ERROR) {\n        vec2 distGradient = vec2(scene(uv + vec2(1, 0)), scene(uv + vec2(0, 1))) - vec2(dist);\n        float gradLength = length(distGradient);\n        if(gradLength < 1.0) {\n            finalColor = mix(finalColor * 0.5, vec3(0.2, .0, 1.0), 1.0 -gradLength);\n        } else {\n            finalColor = mix(finalColor * 0.5, vec3(1.0, .0, 0.2), gradLength - 1.0);\n        }\n        \n        if(VISUALIZE_GRADIENT_ONLY) {\n            finalColor = vec3(0.5 + (gradLength-1.0) * 0.5);\n        }\n    } \n    \n\n    \n\tfragColor = vec4(finalColor,1.0);\n}","name":"Image","description":"","type":"image"}]}