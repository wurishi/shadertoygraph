{"ver":"0.1","info":{"id":"cdlXz7","date":"1668657146","viewed":151,"name":"Fake Emmisive ?","username":"Chango","description":"In working... Result not pleasure for now.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["emissiveraymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Work Here!\n#define OBJNUM 3\n\n#define MaxTraceDis 100.\n#define MaxTraceTime 640\n#define TraceThre 0.001f\n#define NormalEpsilon 0.01f\n\n//Work Here!\nfloat GetObjSDF(int inx, vec3 p, in TraceInfo traceInfo)\n{ \n    switch(inx)\n    {\n        case 0: \n            float t = fract(0.3*iTime);\n            if(t<0.5)\n            {\n            float r = 0.8*fbm4(vec3(1.0)*p+0.5*iTime);\n            return 0.5*SDFSphere(p,vec3(0.),r);\n            }\n            else\n            {\n            return SDFBox(p,vec3(0.,1.*sin(iTime),0.),0.5*vec3(1.,1.,1.));\n            }\n        case 1: \n            return SDFBox(p,vec3(0.,-1.1,0.),vec3(3.,0.1,3.));\n        case 2:\n            return SDFBox(p,vec3(0.,0.,-1.1),vec3(3.,3.,0.1));\n    }\n}\n\nvec3 GetObjSDFNormal(int inx, vec3 p, in TraceInfo traceInfo);\n//Can optimize Here!\nvec3 GetObjNormal(int inx, vec3 p, in TraceInfo traceInfo)\n{\n\treturn GetObjSDFNormal(inx, p, traceInfo);\n}\n\n//Work Here!\nMaterial_PBR GetObjMaterial_PBR(int obj)\n{\n\tMaterial_PBR re;\n\tInit(re);\n\n\t//Work Here!\n    if(obj == 0)\n    {\n        re.albedo = vec3(1.,0.,0.5);\n    }\n    \n    switch(obj)\n    {\n        case 0: \n            re.albedo = vec3(1.,0.,0.5);\n    }\n    \n\treturn re;\n}\n\n//Work Here!\nint GetObjRenderMode(int obj)\n{\n\tswitch(obj)\n    {\n        case 0: \n            return 0;\n    }\n    return 0;\n}\n\n//Can Work Here!\nvoid ObjPreRender(inout int mode, inout Material_PBR mat, inout Ray ray, inout HitInfo minHit)\n{\n    \n}\n\n\n//Can Work Here!\nvoid ObjPostRender(inout vec3 result, inout int mode, inout Material_PBR mat, inout Ray ray, inout HitInfo minHit)\n{\n\n    int inx = minHit.obj;\n    if(inx == 0)\n    {\n        TraceInfo tt;\n        Init(tt);\n        float s = GetObjSDF(0,minHit.P,tt);\n        s -= 0.12;\n        float fakeEmmisive = -0.1*1./s;//pow(s+2.,-2.);\n        fakeEmmisive = pow(fakeEmmisive,1.0);\n        result += fakeEmmisive * vec3(1.,0.,0.5);\n        vec3 l = normalize(vec3(0,0,1));\n        float nl = saturate(dot(minHit.N,l));\n        nl = nl*0.5+0.5;\n        result += 0.1*vec3(nl)* vec3(1.,0.,0.5);\n        float nv = saturate(dot(minHit.N,-ray.dir));\n        result += 0.1*pow(1.0-nv,1.)* vec3(1.0);\n    }\n    \n    if(inx >0)\n    {\n        TraceInfo tt;\n        Init(tt);\n        float s = 0.01*GetObjSDF(0,minHit.P,tt);\n        s = max(0.,s);\n        float f1 = clamp(1.-pow(s,0.5),0.,1.);//pow(s+2.,-2.);\n         f1 = 1.*pow(f1,10.);\n        result += f1 * vec3(1.,0.,0.5);\n        //result += 0.5*saturate(1./s)*vec3(1.,0.,0.);\n    }\n\n    result = pow(result,vec3(2.2));\n}\n//------------------------------------------------\n\nvec3 GetObjSDFNormal(int inx, vec3 p, in TraceInfo traceInfo)\n{\n float eplisonScale = 1.;\n\tfloat normalEpsilon = NormalEpsilon;\n\treturn normalize(vec3(\n\t\tGetObjSDF(inx, vec3(p.x + NormalEpsilon*eplisonScale, p.y, p.z), traceInfo) - GetObjSDF(inx, vec3(p.x - NormalEpsilon*eplisonScale, p.y, p.z), traceInfo),\n\t\tGetObjSDF(inx, vec3(p.x, p.y + NormalEpsilon*eplisonScale, p.z), traceInfo) - GetObjSDF(inx, vec3(p.x, p.y - NormalEpsilon*eplisonScale, p.z), traceInfo),\n\t\tGetObjSDF(inx, vec3(p.x, p.y, p.z + NormalEpsilon*eplisonScale), traceInfo) - GetObjSDF(inx, vec3(p.x, p.y, p.z - NormalEpsilon*eplisonScale), traceInfo)\n\t\t));\n}\n\n//Can Change Here\nvoid TraceScene(Ray ray, out HitInfo info)\n{\n\tfloat traceThre = TraceThre;\n\n\tInit(info);\n\n\tTraceInfo traceInfo;\n\tInit(traceInfo);\n\tvec3 oriPos = ray.pos;\n\n\tfloat objSDF[OBJNUM];\n\tint objInx = -1;\n\tfloat sdf = MAXFLOAT;\n\n\twhile (traceInfo.traceCount <= MaxTraceTime)\n\t{\n\t\tobjInx = -1;\n\t\tsdf = MAXFLOAT;\n\n\t\tfor (int inx = 0; inx < OBJNUM; inx++)\n\t\t{\n\t\t\tobjSDF[inx] = GetObjSDF(inx, ray.pos, traceInfo);\n\t\t\tif (objSDF[inx] < sdf)\n\t\t\t{\n\t\t\t\tsdf = objSDF[inx];\n\t\t\t\tobjInx = inx;\n\t\t\t}\n\t\t}\n\n\n\t\tif(objInx == -1)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sdf > MaxTraceDis)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sdf <= traceThre)\n\t\t{\n\t\t\tinfo.bHit = 1;\n\t\t\tinfo.obj = objInx;\n\t\t\tinfo.N = GetObjNormal(objInx, ray.pos, traceInfo);\n\t\t\tinfo.P = ray.pos;\n\t\t\tbreak;\n\t\t}\n\t\tray.pos += sdf * ray.dir;\n\t\tUpdate(traceInfo,sdf);\n\t\ttraceInfo.traceSum = length(ray.pos - oriPos);\n\t}\n}\n\nfloat GetPntlightAttenuation(vec3 pos, vec3 lightPos)\n{\n\tfloat d = length(pos - lightPos);\n\treturn saturate(1. / (d*d));\n\t//return 1 / (1 + 0.01*d + 0.005*d*d);\n}\n\nvec3 RenderSceneObj(Ray ray, inout HitInfo minHit, inout Material_PBR mat)\n{\n\tint mode = GetObjRenderMode(minHit.obj);\n\tObjPreRender(mode, mat, ray, minHit);\n\tvec3 result = vec3(0.);\n\t//###BLOCK ObjRender\n\t//Can Work Here!\n\tif(mode==0)\n\t{\n\t\tvec3 lightDirs[2];\n\t\tvec3 lightColors[2];\n        vec3 lightPos[2];\n        lightPos[0] = vec3(0.,1.,1.);\n        \n\t\tlightDirs[0] = normalize(minHit.P - lightPos[0]);\n\t\tlightColors[0] = 0.*vec3(0., 0., 1.) * GetPntlightAttenuation(minHit.P, lightPos[0]);\n\t\tlightDirs[1] = vec3(0.4255954, -0.7770073, -0.4638191);\n\t\tlightColors[1] = (fract(0.1*iTime)<0.5?0.:3.)*vec3(1, 1, 1);\n\t\tresult.rgb = 0.03 * mat.albedo * mat.ao;\n\t\tfor(int i=0;i<2;i++)\n\t\t{\n\t\t\tresult.rgb += PBR_GGX(mat, minHit.N, -ray.dir, -lightDirs[i], lightColors[i]);\n\t\t}\n\t}\n\t//###BLOCK\n\tObjPostRender(result, mode, mat, ray, minHit);\n\treturn result;\n}\n\nvec3 GetSDFGameColor(in Ray ray, out HitInfo minHit, out Material_PBR mat)\n{\n\tInit(mat);\n\tvec3 re = vec3(0.);\n\t//---Trace\n\tInit(minHit);\n\tTraceScene(ray, minHit);\n\t//___Trace\n\nif (minHit.bHit == 1)\n{ \n\tmat = GetObjMaterial_PBR(minHit.obj);\n\t//if(mat.reflective<0.001)\n\t//{\n\tre = RenderSceneObj(ray, minHit, mat);\n\t//}\n\t//else if (mat.reflective<0.999)\n\t//{\n\t//\tre = lerp(RenderSceneObj(ray, minHit, mat),SceneRenderReflect(ray, minHit,mat),mat.reflective);\n\t//}\n\t//else\n\t//{\n\t//re = SceneRenderReflect(ray, minHit,mat);\n\t//}\n\t//re *= RenderSceneSDFShadow(minHit);\n}\nelse\n{\n\t//re = (@BackGroundColor);\n\t//re = GetEnvIrradiance_equirectangular(envBgTex, ray.dir, true);\n\t//re = stars(ray.pos, ray.dir);\n\tre = vec3(0.);\n}\n\n\treturn re;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    HitInfo minHit;\n    Material_PBR mat;\n    \n    Ray ray;\n    vec2 rotCenter = vec2(0.);\n    vec2 eye = vec2(0.0, 10.0);\n    ray.pos = vec3(eye.x, 0.0, eye.y);\n    ray.dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 re = GetSDFGameColor(ray,minHit,mat);\n\n    // Output to screen\n    fragColor = vec4(re,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAXFLOAT 3.402823e38f\n#define PI 3.1415926\n\nvec2 rotate(vec2 p, float a)\n{\n\tfloat c = cos(a), s = sin(a);\n\tmat2 m = mat2(c,-s,s,c);\n\treturn m*p;\n}\n\nfloat saturate(float x)\n{\n    return clamp(x,0.,1.);\n}\n    \nstruct Ray\n{\n\tvec3 pos;\n\tvec3 dir;\n};\n\nstruct HitInfo\n{\n\tint bHit;\n\tint obj;\n\tvec3 N;\n\tvec3 P;\n};\n\nstruct TraceInfo\n{\n\tint traceCount;\n\tfloat traceSum;\n\tfloat lastTrace;\n};\n\nvoid Init(out HitInfo re)\n{\n\tre.bHit = 0;\n\tre.obj = -1;\n\tre.N = vec3(0.);\n\tre.P = vec3(0.);\n}\n\nvoid Init(out TraceInfo re)\n{\n\tre.traceCount = 0;\n\tre.traceSum = 0.;\n\tre.lastTrace = MAXFLOAT;\n}\n\nvoid Update(inout TraceInfo traceInfo, float sdf)\n{\n\ttraceInfo.traceCount += 1;\n\ttraceInfo.lastTrace = sdf;\n}\n\nfloat SDFSphere(vec3 p, vec3 center, float radius)\n{\n\treturn length(p - center) - radius;\n}\n\nfloat SDFBox(vec2 p, vec2 center, vec2 bound)\n{\n\tvec2 q = abs(p - center) - bound;\n\treturn length(max(q, 0.0)) + min(max(q.x, q.y), 0.0);\n}\n\nfloat SDFBox(vec3 p, vec3 center, vec3 bound)\n{\n\t//return SDFSphere(p, center, 1);\n\tvec3 q = abs(p - center) - bound;\n\treturn length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nstruct Material_PBR\n{\n\tvec3 albedo;\n\tfloat metallic;\n\tfloat roughness;\n\tfloat ao;\n\tfloat reflective;\n\tvec2 reflect_ST;\n\tfloat alpha;\n};\n\nvoid Init(out Material_PBR mat)\n{\n\tmat.albedo = vec3(1.);\n\tmat.metallic = 0.;\n\tmat.roughness = 1.;\n\tmat.ao = 1.;\n\tmat.reflective = 0.;\n\tmat.reflect_ST = vec2(1.,0.);\n\tmat.alpha = 1.;\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n\treturn F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n\tfloat r = (roughness + 1.0);\n\tfloat k = (r*r) / 8.0;\n\n\tfloat nom = NdotV;\n\tfloat denom = NdotV * (1.0 - k) + k;\n\n\treturn nom / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n\tfloat NdotV = max(dot(N, V), 0.0);\n\tfloat NdotL = max(dot(N, L), 0.0);\n\tfloat ggx2 = GeometrySchlickGGX(NdotV, roughness);\n\tfloat ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n\treturn ggx1 * ggx2;\n}\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n\tfloat a = roughness * roughness;\n\tfloat a2 = a * a;\n\tfloat NdotH = max(dot(N, H), 0.0);\n\tfloat NdotH2 = NdotH * NdotH;\n\n\tfloat nom = a2;\n\tfloat denom = (NdotH2 * (a2 - 1.0) + 1.0);\n\tdenom = PI * denom * denom;\n\n\treturn nom / denom;\n}\n\nvec3 PBR_GGX(Material_PBR param, vec3 n, vec3 v, vec3 l, vec3 Li)\n{\n\tvec3 h = normalize(l + v);\n\n\t//Calculate F\n\tvec3 F0 = vec3(0.04);\n\tF0 = mix(F0, param.albedo, param.metallic);\n\tvec3 F = fresnelSchlick(max(dot(h, v), 0.0), F0);\n\n\t//Calculate diffuse\n\tvec3 kD = 1.0 - F;\n\tvec3 diffuse = (1.0 - param.metallic) * kD * param.albedo / PI;\n\n\t//Calculate specular\n\tfloat G = GeometrySmith(n, v, l, param.roughness);\n\tvec3 nominator;\n\tfloat NDF = DistributionGGX(n, h, param.roughness);\n\tnominator = NDF * G * F;\n\tfloat denominator = 4.0 * max(dot(n, v), 0.0) * max(dot(n, l), 0.0) + 0.001;\n\tvec3 specular = nominator / denominator;\n\n    float diffuseRate = 1.0f;\n    float specularRate = 1.0f;\n\tvec3 Lo = diffuse * diffuseRate + specular * specularRate;\n\tLo *= Li * max(dot(n, l), 0.);\n\n\treturn Lo;\n}\n\nfloat iqhash(float n)\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat noise_computational(in vec3 x)\n{\n\t// The noise function returns a value in the range -1.0f -> 1.0f\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\n\tf = f * f*(3.0 - 2.0*f);\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\treturn mix(mix(mix(iqhash(n + 0.0), iqhash(n + 1.0), f.x),\n\t\tmix(iqhash(n + 57.0), iqhash(n + 58.0), f.x), f.y),\n\t\tmix(mix(iqhash(n + 113.0), iqhash(n + 114.0), f.x),\n\t\t\tmix(iqhash(n + 170.0), iqhash(n + 171.0), f.x), f.y), f.z);\n}\n\nfloat noise(in vec3 x)\n{\n\t//return noise_texBase(x);\n\treturn noise_computational(x);\n}\n\nfloat fbm4(in vec3 p)\n{\n\tfloat n = 0.0;\n\tn += 1.000*noise(p*1.0);\n\tn += 0.500*noise(p*2.0); \n\tn += 0.250*noise(p*4.0);\n\tn += 0.125*noise(p*8.0);\n\treturn n;\n}","name":"Common","description":"","type":"common"}]}