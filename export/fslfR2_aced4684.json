{"ver":"0.1","info":{"id":"fslfR2","date":"1645087041","viewed":103,"name":"Checkerboard Colored","username":"Chromozob","description":"C bo","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["checkerboard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"bool inside_circle(in vec2 frag, in vec2 center, in float radius)\n{\n    return length(frag - center) < radius;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float Xspeed = 0.2;\n    float Yspeed = 0.5;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    uv.y += sin(iTime) * Yspeed;\n    uv.x += cos(iTime) * Xspeed;\n    \n    \n    //Calcul du ratio de l'ecran\n    float ratio = iResolution.x/iResolution.y;\n    //On applique le ratio à notre uv en x pour obtenir des carrés \n    uv.x *= ratio;\n    \n    float modulo = 0.2; //Correspond à la taille d'un grand carré de 4 carrés\n    \n    //On veut savoir dans quel carré de notre grand carré se situe notre pixel (noir ou blanc grossierement)\n    //Autrement dit, on veut savoir si notre pixel est > la moitité de notre grand carré en x et en y ou non\n    //Pour nos calculs, on se place dans le référentiel d'un grand carré, c'est à dire qu'on applique un modulo à la position de notre pixel \n    float  valueA = floor(mod(uv.x,modulo)/(modulo*0.5)); // = 1 si > la moitié en x (0.5), sinon 0\n    float valueB = floor(mod(uv.y,modulo)/(modulo*0.5));  // = 1 si > la moitié en y (0.5), sinon 0\n    \n    float value = mod(valueA + valueB, 2.) == 0. ? 0. : 1.;\n     \n    vec3 color = vec3(value, value-uv.x*sin(iTime), value-uv.y*sin(iTime));\n     \n    if(inside_circle(fragCoord, iMouse.xy, 100.)){   \n        fragColor = vec4(1.-color.x, 1.-color.y, 1.-color.z, 1.0);\n    }\n    else{\n        fragColor = vec4(color, 1.0);\n\n    }\n}","name":"Image","description":"","type":"image"}]}