{"ver":"0.1","info":{"id":"tlB3D3","date":"1561333458","viewed":95,"name":"Ray Tracing in a Weekend, Ch. 6","username":"fhecht","description":"This is a tutorial style implementation of classic ray tracing following the \"Ray Tracing in One Weekend\" course by Peter Shirley. This is the code up to chapter 6.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Read the Buffer A texel and write it to the main frame buffer\n    fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// -------------------------------------------------------------------------\n// Struct definitions and scene setup\n// -------------------------------------------------------------------------\n\n// Camera parameters\nvec3 lower_left_corner = vec3(-1.0, -1.0, -1.0);\nvec3 horizontal = vec3(2, 0, 0);\nvec3 vertical = vec3(0, 2, 0);\nvec3 origin = vec3(0, 0, 0);\n\n// Ray struct\nstruct Ray {\n    vec3 o;\n    vec3 d;\n    float mint;\n    float maxt;\n};\n\n// Scene\nstruct Sphere {\n    vec3 c;\n    float r;\n};\nSphere sphere = Sphere(vec3(0.0, 0.0, -1.0), 0.5);\n\nconst int NUM_SPHERES = 2;\nconst Sphere spheres[NUM_SPHERES] = Sphere[NUM_SPHERES](\n    Sphere(vec3(0.0, 0.0, -1.0), 0.5),\n    Sphere(vec3(0.0, -100.5, -1.0), 100.)\n);\n\n// Hit record information\nstruct HitRecord {\n    float t;\n    vec3 P;\n    vec3 N;\n};\n\n// -------------------------------------------------------------------------\n// Probabilistic math helper functions\n// -------------------------------------------------------------------------\n\n// commonly used randomizer function from shadertoy\nfloat nrand(vec2 n)\n{\n    return fract(sin(dot(n.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// -------------------------------------------------------------------------\n// Intersection code\n// -------------------------------------------------------------------------\n\n// intersect a ray with a single sphere\n// returns true if there was a valid intersection, which includes checks\n// against the mint and maxt range of the ray. In case of a valid\n// intersection the information in the HitRecord is filled in\nbool hitSphere(Ray r, Sphere s, out HitRecord hit)\n{\n    vec3 oc = r.o - s.c;\n    float a = dot(r.d, r.d);\n    float b = 2.0 * dot(oc, r.d);\n    float c = dot(oc, oc) - s.r * s.r;\n    float det = b*b - 4.0*a*c;\n    if (det < 0.0) {\n        return false;\n    }\n    \n    // first possible intersection\n    float t = (-b - sqrt(det)) / (2.0 * a);\n    if (r.mint <= t && t < r.maxt) { \n        hit.t = t;\n        hit.P = r.o + t * r.d;\n        hit.N = normalize(hit.P - s.c);\n        return true;\n    }\n\n    // second possible intersection\n    t = (-b + sqrt(det)) / (2.0 * a);\n    if (r.mint <= t && t < r.maxt) { \n        hit.t = t;\n        hit.P = r.o + t * r.d;\n        hit.N = normalize(hit.P - s.c);\n        return true;\n    }\n\n    return false;\n}\n\n// intersect against all spheres and return the first hit\nbool hitSpheres(Ray r, Sphere spheres[NUM_SPHERES], out HitRecord hit)\n{\n    bool hitSomething = false;\n    for (int i = 0; i < spheres.length(); ++i) {\n        if (hitSphere(r, spheres[i], hit)) {\n            hitSomething = true;\n            // if we hit a sphere we update maxt on the ray to only find\n            // intersections that are even closer\n            r.maxt = hit.t;\n        }\n    }\n    \n    return hitSomething;\n}\n\n// -------------------------------------------------------------------------\n// Core integrator\n// -------------------------------------------------------------------------\n\nvec3 missedColor(vec3 rayDir)\n{\n    vec3 unitDir = normalize(rayDir);\n    float t = 0.5 * (unitDir.y + 1.0);\n    return mix(vec3(1.0,1.0,1.0), vec3(.5, .7, 1.0), t);\n}\n\nvec3 traceRay(Ray r)\n{\n    HitRecord hit;\n    //if (hitSphere(r, sphere, hit)) {\n    if (hitSpheres(r, spheres, hit)) {\n        return 0.5 * (hit.N + 1.0);\n    }\n    return missedColor(r.d);\n}\n\n// -------------------------------------------------------------------------\n// Camera code\n// -------------------------------------------------------------------------\n\nRay computeCameraRay(vec2 uv)\n{\n    // compute two random numbers [0, 1) that are different each frame\n    float xi0 = nrand(uv * 0.123 * float(iFrame));\n    float xi1 = nrand(uv * 0.456 * float(iFrame));\n    // move the pixel position by a fraction of a pixel for anti-aliasing\n    uv += vec2(xi0, xi1) / iResolution.xy;\n\n    float aspectRatio = iResolution.x / iResolution.y;\n    Ray r;\n    r.o = origin;\n    r.d = lower_left_corner * vec3(aspectRatio, 1.0, 1.0) +\n          uv.x * horizontal * aspectRatio +\n          uv.y * vertical;\n    r.mint = 0.0;\n    r.maxt = 1e20;\n    return r;\n}\n\n// -------------------------------------------------------------------------\n// Frame accumulator\n// -------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (iFrame == 0) {\n        // reset the color on the first frame\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    } else {\n        vec2 uv = fragCoord/iResolution.xy;\n\n        // Compute ray for pixel\n    \tRay r = computeCameraRay(uv);\n    \n    \t// Compute pixel color\n    \tvec3 current = traceRay(r);\n        \n        // read the previous value from buffer A\n        vec3 prev = texture(iChannel0, uv).xyz;\n        \n        // running average\n        vec3 new = (float(iFrame-1) * prev + current) / float(iFrame);\n\n        // output to buffer A\n        fragColor = vec4(new, 1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}