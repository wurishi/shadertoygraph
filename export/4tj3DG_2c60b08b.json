{"ver":"0.1","info":{"id":"4tj3DG","date":"1432030192","viewed":2948,"name":"Grid Paper (+mouse)","username":"104","description":"Utility function to control the viewport. And some accurate 2D grid line, hline, and vline distance functions. And fractal worley noise for crumpled effect. Use the mouse to change light position. The crumpled effect is not really very pretty i admit...","likes":76,"published":1,"flags":0,"usePreview":0,"tags":["2d","grid","paper","aspect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"float nsin(float a)\n{\n    return (sin(a)+1.)/2.;\n}\nfloat rand(float n)\n{\n \treturn fract(cos(n*89.42)*343.42);\n}\nvec2 rand(vec2 n)\n{\n \treturn vec2(rand(n.x*23.62-300.0+n.y*34.35),rand(n.x*45.13+256.0+n.y*38.89)); \n}\n\n// returns (dx, dy, distance)\nvec3 worley(vec2 n,float s)\n{\n    vec3 ret = vec3(s * 10.);\n    // look in 9 cells (n, plus 8 surrounding)\n    for(int x = -1;x<2;x++)\n    {\n        for(int y = -1;y<2;y++)\n        {\n            vec2 xy = vec2(x,y);// xy can be thought of as both # of cells distance to n, and \n            vec2 cellIndex = floor(n/s) + xy;\n            vec2 worleyPoint = rand(cellIndex);// random point in this cell (0-1)\n            worleyPoint += xy - fract(n/s);// turn it into distance to n. ;\n            float d = length(worleyPoint) * s;\n            if(d < ret.z)\n                ret = vec3(worleyPoint, d);\n        }\n    }\n    return ret;\n}\n\nvec2 mouse = vec2(1.);// how do i initialize this??\n\nvec4 applyLighting(vec4 inpColor, vec2 uv, vec3 normal, vec3 LightPos, vec4 LightColor, vec4 AmbientColor)\n{\n   // if(distance(uv.xy, LightPos.xy) < 0.01) return vec4(1.,0.,0.,1.);\n    vec3 LightDir = vec3(LightPos.xy - uv, LightPos.z);\n    vec3 N = normalize(normal);\n    vec3 L = normalize(LightDir);\n    vec3 Diffuse = (LightColor.rgb * LightColor.a) * max(dot(N, L), 0.0);\n    vec3 Ambient = AmbientColor.rgb * AmbientColor.a;\n    vec3 Intensity = Ambient + Diffuse;\n    vec3 FinalColor = inpColor.rgb * Intensity;\n    return vec4(FinalColor, inpColor.a);\n}\n\n\n\n// convert distance to alpha value (see https://www.shadertoy.com/view/ltBGzt)\nfloat dtoa(float d)\n{\n    const float amount = 800.0;\n    return clamp(1.0 / (clamp(d, 1.0/amount, 1.0)*amount), 0.,1.);\n}\n\n\n// distance to edge of grid line. real distance, and centered over its position.\nfloat grid_d(vec2 uv, vec2 gridSize, float gridLineWidth)\n{\n    uv += gridLineWidth / 2.0;\n    uv = mod(uv, gridSize);\n    vec2 halfRemainingSpace = (gridSize - gridLineWidth) / 2.0;\n    uv -= halfRemainingSpace + gridLineWidth;\n    uv = abs(uv);\n    uv = -(uv - halfRemainingSpace);\n    return min(uv.x, uv.y);\n}\n// centered over lineposy\nfloat hline_d(vec2 uv, float lineposy, float lineWidth)\n{\n\treturn distance(uv.y, lineposy) - (lineWidth / 2.0);\n}\n// centered over lineposx\nfloat vline_d(vec2 uv, float lineposx, float lineWidth)\n{\n\treturn distance(uv.x, lineposx) - (lineWidth / 2.0);\n}\nfloat circle_d(vec2 uv, vec2 center, float radius)\n{\n\treturn length(uv - center) - radius;\n}\n\n// not exactly perfectly perfect, but darn close\nfloat pointRectDist(vec2 p, vec2 rectTL, vec2 rectBR)\n{\n  float dx = max(max(rectTL.x - p.x, 0.), p.x - rectBR.x);\n  float dy = max(max(rectTL.y - p.y, 0.), p.y - rectBR.y);\n  return max(dx, dy);\n}\n\n\nvec2 getuv(vec2 fragCoord, vec2 newTL, vec2 newSize, out float distanceToVisibleArea, out float vignetteAmt)\n{\n    vec2 ret = vec2(fragCoord.x / iResolution.x, (iResolution.y - fragCoord.y) / iResolution.y);// ret is now 0-1 in both dimensions\n    \n    // warp\n    //ret = tvWarp(ret / 2.) * 2.;// scale it by 2.\n    distanceToVisibleArea = pointRectDist(ret, vec2(0.0), vec2(1.));\n\n    // vignette\n    vec2 vignetteCenter = vec2(0.5, 0.5);\n\tvignetteAmt = 1.0 - distance(ret, vignetteCenter);\n    vignetteAmt = 0.03 + pow(vignetteAmt, .25);// strength\n    vignetteAmt = clamp(vignetteAmt, 0.,1.);\n    \n    \n    ret *= newSize;// scale up to new dimensions\n    float aspect = iResolution.x / iResolution.y;\n    ret.x *= aspect;// orig aspect ratio\n    float newWidth = newSize.x * aspect;\n    return ret + vec2(newTL.x - (newWidth - newSize.x) / 2.0, newTL.y);\n}\n\nvec4 drawHole(vec4 inpColor, vec2 uv, vec2 pos)\n{\n    vec4 circleWhiteColor = vec4(vec3(0.95), 1.);\n\tfloat d = circle_d(uv, pos, 0.055);\n    return vec4(mix(inpColor.rgb, circleWhiteColor.rgb, circleWhiteColor.a * dtoa(d)), 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float distanceToVisibleArea;\n    float vignetteAmt;\n\tvec2 uv = getuv(fragCoord, vec2(-1.,1.), vec2(2., -2.), distanceToVisibleArea, vignetteAmt);\n    float throwaway;\n    mouse = getuv(iMouse.xy, vec2(-1.,1.), vec2(2., -2.), throwaway, throwaway);\n\n    fragColor = vec4(0.94, 0.96, 0.78, 1.0);// background\n    float d;\n    \n    // grid\n    vec4 gridColor = vec4(0.2,0.4,.9, 0.35);\n\td = grid_d(uv, vec2(0.10), 0.001);\n\tfragColor = vec4(mix(fragColor.rgb, gridColor.rgb, gridColor.a * dtoa(d)), 1.);\n    \n    // red h line\n    vec4 hlineColor = vec4(0.8,0.,.2, 0.55);\n\td = hline_d(uv, 0.60, 0.003);\n\tfragColor = vec4(mix(fragColor.rgb, hlineColor.rgb, hlineColor.a * dtoa(d)), 1.);\n    \n    // red v line\n    vec4 vlineColor = vec4(0.8,0.,.2, 0.55);\n\td = vline_d(uv, -1.40, 0.003);\n\tfragColor = vec4(mix(fragColor.rgb, vlineColor.rgb, vlineColor.a * dtoa(d)), 1.);\n\n    \n    // fractal worley crumpled paper effect\n    float wsize = 0.8;\n    const int iterationCount = 6;\n    vec2 normal = vec2(0.);\n    float influenceFactor = 1.0;\n    for(int i = 0; i < iterationCount; ++ i)\n    {\n        vec3 w = worley(uv, wsize);\n\t\tnormal.xy += influenceFactor * w.xy;\n        wsize *= 0.5;\n        influenceFactor *= 0.9;\n    }\n    \n    // lighting\n    vec3 lightPos = vec3(mouse, 8.);\n    vec4 lightColor = vec4(vec3(0.99),0.6);\n    vec4 ambientColor = vec4(vec3(0.99),0.5);\n\tfragColor = applyLighting(fragColor, uv, vec3(normal, 4.0), lightPos, lightColor, ambientColor);\n\n    // white circles\n    fragColor = drawHole(fragColor, uv, vec2(-1.6, 0.2));\n\tfragColor = drawHole(fragColor, uv, vec2(-1.6, -.7));\n    \n    // post effects\n\tfragColor.rgb *= vignetteAmt;\n}\n\n","name":"Image","description":"","type":"image"}]}