{"ver":"0.1","info":{"id":"ssBczD","date":"1643478505","viewed":196,"name":"hypergrapes","username":"pb","description":"spheres at xyz coords of xyzw cube rotating in various planes","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["spheres","4d","pb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Philip Bertani - philip.bertani@gmail.com\n\n//put spheres at the xyz coords of rotating 4d cube, then \n//sin and cos every parameter to death\n\n//drag mouse to add rotations\n//dragging on the right causes the use of simpler rotation matrix\n//change whatever suits your fancy\n\n#define MAX_RAY_STEPS 300\n#define MAX_PRIME_RAY_DIST 50.\n#define PI 3.14159265\n\nvec3 ambientL  = vec3(.3,0.,.5);\nvec3 diffuseL  = vec3(.4,0.,.4);\nvec3 specularL = vec3(.8,.4,.1);\nvec3 ambdir    = vec3(1.,0.,1.);\n//do something interesting with spheres located at xyz projection points of hypercube\n//have to rotate the hypercube in at least 2 planes to get something interesting\nvec4 hc[16] = vec4[16] (\nvec4(-1.,-1.,-1.,-1.),\nvec4(-1.,-1.,-1.,1.),\nvec4(-1.,-1.,1.,-1.),\nvec4(-1.,-1.,1.,1.),\nvec4(-1.,1.,-1.,-1.),\nvec4(-1.,1.,-1.,1.),\nvec4(-1.,1.,1.,-1.),\nvec4(-1.,1.,1.,1.),\nvec4(1.,-1.,-1.,-1.),\nvec4(1.,-1.,-1.,1.),\nvec4(1.,-1.,1.,-1.),\nvec4(1.,-1.,1.,1.),\nvec4(1.,1.,-1.,-1.),\nvec4(1.,1.,-1.,1.),\nvec4(1.,1.,1.,-1.),\nvec4(1.,1.,1.,1.)\n);\n\nstruct RAYMARCH_RESULT {\n    vec3  raypos;\n    float dist_from_origin;\n    float object_id;\n};\n\nfloat hc_scale = 1.200;\nvec3  light_pos = vec3(0.,0., 1.);\nvec2  myMouse;\n\nfloat sphere_sdf( vec3 pos, float r ) {\n    return length(pos) - r;\n}\n\n\nmat4 rot4d_xz_xw_yw_zw( vec4 inputs ) {\n    float cxz = cos(inputs.x);\n    float sxz = sin(inputs.x);\n    float cxw = cos(inputs.y);\n    float sxw = sin(inputs.y);\n    float cyw = cos(inputs.z);\n    float syw = sin(inputs.z);\n    float czw = cos(inputs.w);\n    float szw = sin(inputs.w);\n    \n    return mat4( vec4( cxz*cxw, -cxz*sxw*syw, -cxz*sxw*cyw*szw-sxz*czw, -cxz*sxw*cyw*czw+sxz*szw ),\n                 vec4(  0.,      cyw,           0.,     -syw*czw ),\n                 vec4( sxz*cxw, -sxz*sxw*syw, -sxz*sxw*cyw*szw+cxz*czw, -sxz*sxw*cyw*czw-cxz*szw ),\n                 vec4( sxw,  cxw*syw,  cxw*cyw*szw,  cxw*cyw*czw )\n                 );\n}\n\n//thick line from IQ master\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  \n  //here is a mod for tapering the capsule\n  float dist_from_zero = length(p);\n  \n  float radius = max(r * ( 3. - 3.*smoothstep( 0., 1., dist_from_zero)) , 0.008);\n  \n  return length( pa - ba*h ) - radius;\n}\n\nvec2 dist_func01( vec3 pos ) {\n\n    vec4 inputs = vec4( iTime/2., iTime/3., iTime/5. + 2.*myMouse.x, 2.*myMouse.y );\n    if ( myMouse.x > 0. ) {\n        inputs = vec4( iTime/2., 0., myMouse.y, 0. );\n    }\n    mat4 rot4d =  rot4d_xz_xw_yw_zw( inputs );\n        \n    float radius = min(max(1.5 * cos(iTime/2.),.4),.8) + .3*cos(iTime/3.); \n\n    vec2 sphere_info = vec2( 0., -1.); //.y is the sphere number\n    float min_dist = 1e10;\n    \n    for (int i=0;i<16;i+=1) {\n    \n        vec3 hc_vertex = hc_scale*(rot4d*hc[i]).xyz;  //hypercube vertex\n        float test_dist = sphere_sdf( pos-hc_vertex, radius);\n        if (test_dist < min_dist) {\n            min_dist = test_dist;\n            sphere_info.x = test_dist;\n            sphere_info.y = float(i);\n        }\n        \n            \n        float line_dist = sdCapsule(  pos , hc_vertex, vec3(0.), .04 );\n        if ( line_dist < min_dist ) {\n            min_dist = line_dist;\n            sphere_info.x = line_dist;\n            sphere_info.y = float(i)*2.;\n        }\n \n        \n    }\n\n\n    return sphere_info;\n}\n\nvec3 estimate_normal_vec( vec3 pos, float neps ) {\n\n    // in other words - the Gradient Vector...\n    \n    float norm_sign = mod(iTime/30.,1.) * 2. -1.;\n\n    vec2  np = norm_sign * normalize(vec2( 1., -1)); //putting the wrong sign here makes a glossy effect\n\n    vec2  dp = vec2( neps, -neps);\n   \n    vec3 df1 = np.xxx * dist_func01( pos + dp.xxx ).x;\n    vec3 df2 = np.xyy * dist_func01( pos + dp.xyy ).x;\n    vec3 df3 = np.yxy * dist_func01( pos + dp.yxy ).x;\n    vec3 df4 = np.yyx * dist_func01( pos + dp.yyx ).x;\n    vec3 df5 = np.yyy * dist_func01( pos + dp.yyy ).x;\n    vec3 df6 = np.xxy * dist_func01( pos + dp.xxy ).x;\n    vec3 df7 = np.xyx * dist_func01( pos + dp.xyx ).x;\n    \n    return normalize( df1 + df2 + df3 + df4 + df5 + df6 + df7 );\n\n}\n\n\nRAYMARCH_RESULT raymarch( vec3 ro, vec3 rd, float eps, float initial_object_id ) {\n\n    float dist_from_origin = 0.; \n    vec3 raypos = ro;\n    RAYMARCH_RESULT result;\n    result.object_id = initial_object_id; \n    result.dist_from_origin = 0.;\n   \n    \n    for (int i=0; i<MAX_RAY_STEPS && dist_from_origin < MAX_PRIME_RAY_DIST; i++) {\n    \n        vec3 raypos = ro + dist_from_origin * rd;\n        vec2 dist_to_closest = dist_func01(raypos);\n        if ( abs(dist_to_closest.x) < eps ) {\n        \n            result.object_id = dist_to_closest.y;\n            result.raypos = raypos;\n            result.dist_from_origin = dist_from_origin;\n            \n            break;\n        }\n        \n        raypos += dist_from_origin*rd; \n\n        dist_from_origin += dist_to_closest.x;\n        \n    }\n    \n    \n    return result;\n    \n}\n\nvec3  main_loop( vec3 ro, vec3 rd ) {\n    \n    RAYMARCH_RESULT prime_ray = raymarch( ro, rd, .000001, 100.);\n    \n    vec3 color = vec3(0.);\n    \n    if (prime_ray.object_id > -1. ) { \n    \n        vec3 nn = estimate_normal_vec( prime_ray.raypos, .0001 );\n        \n        vec3 lt_pos = light_pos + vec3( 6.*cos(iTime/3.), .5*sin(iTime/5.) , 6.*sin(iTime/2.) );  \n        float spec_pow = 32. + 30.*sin(iTime/2.);\n        float spec_amp = 1.2 + .8*sin(iTime);\n        \n        vec3 light_dir=normalize(lt_pos-prime_ray.raypos); \n        float diffuse_light = clamp(dot(light_dir, nn), 0., 1.);\n        float ambient_light = 0.1 + 0.5 * dot(nn, ambdir);\n     \n        vec3 refl=reflect(light_dir,nn);\n        vec3 view_dir= rd;\n        float specular_light=pow(max(dot(refl,view_dir),0.0),spec_pow);\n        \n\n        color = ambient_light  * ambientL + \n                diffuse_light  * diffuseL +\n                spec_amp*specular_light * specularL;\n             \n        \n        vec3 new_ro = prime_ray.raypos + nn*.00001;\n        vec3 new_rd = reflect( rd, nn );\n        RAYMARCH_RESULT reflection = raymarch( new_ro, new_rd, .000001, 100.);\n        \n        if ( reflection.object_id > -1. ) {\n            \n            vec3 nn2 = estimate_normal_vec( reflection.raypos, \n                       .0002 + .02*(1.-cos(iTime/5.))  );\n         \n            vec3 light_dir2=normalize(lt_pos-reflection.raypos); \n            \n            float diffuse_light2 = clamp(dot(light_dir2, nn2), 0., 1.);\n            float ambient_light2 = 0.1 + 0.5 * dot(nn2, ambdir);\n                 \n            vec3 refl2=reflect(light_dir2,nn);\n            vec3 view_dir2 = new_rd;\n            float specular_light2 = pow(max(dot(refl2,view_dir2),0.0),spec_pow);\n        \n            vec3 reflect_color = ambient_light2 * ambientL +\n                                 diffuse_light2 * diffuseL +\n                                 spec_amp*specular_light2 * specularL; \n                                 \n            float color_fac = 1.;\n\n            color += color_fac *  reflect_color;\n            \n        }\n        \n        \n                      \n    }\n\n    return clamp(color, 0., 1.);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float myTime = iTime;\n    \n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    myMouse = (iMouse.xy*2.0 - iResolution.xy) / iResolution.y;\n    \n    vec3 ro = vec3(sin(myTime/7.),sin(myTime/4.),-5.5 + 3.*sin(myTime/3.) );  //ray origin\n    vec3 rd = normalize( vec3(uv, 1.8) );  //ray direction\n    \n    vec3 color = main_loop(ro, rd);\n \n    color = pow( color, vec3(1.3) );\n    \n    fragColor = vec4(color,1.);\n}\n","name":"Image","description":"","type":"image"}]}