{"ver":"0.1","info":{"id":"Xt2SDG","date":"1446178790","viewed":165,"name":"Nine Circles","username":"soma_arc","description":"It is constructed by inversion of circles.\nSee also https://www.shadertoy.com/view/4lBSDR.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nCreated by soma_arc, Kazushi Ahara - 2015\nThis work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported.\n*/\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nconst vec2 c1Pos = vec2(1, 1);\nconst vec2 c2Pos = vec2(-1, 1);\nconst vec2 c3Pos = vec2(1, -1);\nconst vec2 c4Pos = vec2(-1, -1);\nconst vec2 c5Pos = vec2(0, 2.73205080757);//2 * sqrt(3) + 1;\nconst vec2 c6Pos = vec2(0, -2.73205080757);\nconst vec2 c7Pos = vec2(2.73205080757, 0.);\nconst vec2 c8Pos = vec2(-2.73205080757, 0.);\nconst vec2 c9Pos = vec2(0, 0);\nconst float r = 1.;\nconst float c9R = 0.4142;//2 * sqrt(2) - 2\n\nvec2 circleInverse(vec2 pos, vec2 circlePos, float circleR){\n\treturn ((pos - circlePos) * circleR * circleR)/(length(pos - circlePos) * length(pos - circlePos) ) + circlePos;\n}\n\nconst int ITERATIONS = 50;\nfloat IIS(vec2 pos){\n    float loopNum = 0.;\n\tbool cont = false;\n\tfor(int i = 0 ; i < ITERATIONS ; i++){\n\t\tcont = false;\n\t\tif(distance(pos,c1Pos) < r){\n\t\t\tpos = circleInverse(pos, c1Pos, r);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(distance(pos, c2Pos) < r){\n\t\t\tpos = circleInverse(pos, c2Pos, r);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(distance(pos, c3Pos) < r){\n\t\t\tpos = circleInverse(pos, c3Pos, r);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(distance(pos, c4Pos) < r){\n\t\t\tpos = circleInverse(pos, c4Pos, r);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(distance(pos, c5Pos) < r){\n\t\t\tpos = circleInverse(pos, c5Pos, r);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(distance(pos, c6Pos) < r){\n\t\t\tpos = circleInverse(pos, c6Pos, r);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(distance(pos, c7Pos) < r){\n\t\t\tpos = circleInverse(pos, c7Pos, r);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(distance(pos, c8Pos) < r){\n\t\t\tpos = circleInverse(pos, c8Pos, r);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(distance(pos, c9Pos) < c9R){\n\t\t\tpos = circleInverse(pos, c9Pos, c9R);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}\n\t\tif(cont == false) break;\n\t}\n\n\treturn loopNum;\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nconst float SAMPLE_NUM = 20.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 sum = vec3(0);\n\tfloat ratio = iResolution.x / iResolution.y / 2.0;\n    for(float i = 0. ; i < SAMPLE_NUM ; i++){\n        vec2 position = ( (fragCoord.xy + rand2n(fragCoord.xy, i)) / iResolution.yy ) - vec2(ratio, 0.5);\n\t\tposition = position * 5.3;\n\n        float loopNum = IIS(position);\n\n        if(loopNum > 0.){\n            sum += hsv2rgb(vec3(iTime/1.5 + 0.04 * loopNum,1.0,1.0));\n        }else{\n            sum += vec3(0.,0.,0.);\n        }\n    }\n    fragColor = vec4(sum/SAMPLE_NUM, 1.);\n}","name":"Image","description":"","type":"image"}]}