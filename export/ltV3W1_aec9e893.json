{"ver":"0.1","info":{"id":"ltV3W1","date":"1474522856","viewed":158,"name":"hidden nyan","username":"impiaaa","description":"A GLSL version of my attempt to hide information from digital video compression (https://twitter.com/impiaaa/status/778483458251165696). See if you can find the cat, then try recording it with your phone or a screen capture and finding it in that.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","noise","video"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// https://en.wikipedia.org/wiki/Linear_congruential_generator\nint lcg_1(int seed, int a, int c)\n{\n    return seed * a + c;\n}\n\nint rand(int seed)\n{\n    int r = lcg_1(seed, 1103515245, 12345);\n    return r;\n}\n\nfloat normrand(int r)\n{\n    return mod(float(r), 65536.0)/65536.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // make some noise\n\tvec2 uv = fragCoord.xy / iResolution.x;\n    uv.xy *= 1.512;\n    // calculate a random x/y offset\n    int r = rand(iFrame);\n    uv.x += normrand(r);\n    r = rand(r);\n    uv.y += normrand(r);\n    // sample the noise texture at a random spot\n    float hue = texture(iChannel0, uv).r;\n    // convert to hsv to make extra colorful\n\tfragColor = vec4(hsv2rgb(vec3(hue, 1.0, 1.0)), 0.0);\n    \n    // generate uv to animate cute cat\n    uv = fragCoord.xy / iResolution.y;\n    \n    r = rand(r);\n    float angle = normrand(r)*0.02+0.1;\n    vec2 uv2;\n    uv2.x = uv.x*cos(angle) - uv.y*sin(angle);\n    uv2.y = uv.x*sin(angle) + uv.y*cos(angle);\n\n    uv2.x /= 6.5;\n    uv2.xy += vec2(-0.05, -0.1);\n    r = rand(r);\n    uv2.x += normrand(r)*0.005;\n    //r = rand(r);\n    //uv2.y += ((float(r)/65536.0)*0.00004);\n    uv2.x = clamp(uv2.x, 0.0, 1.0/6.5);\n    uv2.x += floor(mod(iTime, 1.0)*6.0)/6.5;\n    \n    // sample and saturate the hidden message texture\n    // samples should really only be 1 or 0\n    float cat = floor(texture(iChannel1, uv2).r*2.0);\n    // use the noise or its inverse depending on the message\n    fragColor = mix(fragColor, vec4(1.0-fragColor), cat);//vec4(cat);\n}\n","name":"Image","description":"","type":"image"}]}