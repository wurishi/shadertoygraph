{"ver":"0.1","info":{"id":"mlSyWw","date":"1691831661","viewed":93,"name":"Doraemon Hand","username":"amuda","description":"\"Ta-Da\", doraemon took out something amazing!","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["2d","fbm","doraemon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SMOOTH_RATIO 0.03\n#define LINE_WIDTH 0.05\n#define PI 3.141593\n\nvec2 move(in vec2 uv, in vec2 offset)\n{\n    return uv - offset;\n}\n\nvec2 scale(in vec2 uv, in vec2 scaleRatio)\n{\n    return vec2(uv.x / scaleRatio.x, uv.y / scaleRatio.y);\n}\n\nvec2 rotate(in vec2 uv, float angle)\n{\n    mat2 rotateMat = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    return rotateMat * uv;\n}\n\nfloat circleIn(in vec2 uv, in vec2 scaleRatio)\n{\n    uv = move(uv, vec2(0.85, -1.9));\n    uv = scale(uv, scaleRatio);\n\n    float R = 0.9;\n    float r = length(uv);\n    return 1.0 - smoothstep(R - LINE_WIDTH * 0.5 - SMOOTH_RATIO, R - LINE_WIDTH * 0.5 , r);\n}\n\nfloat arm(in vec2 uv, in vec2 scaleRatio)\n{\n    uv = move(uv, vec2(0.0, -1.7));\n    uv = scale(uv, scaleRatio);\n\n    uv = rotate(uv, PI / 6.5);\n\n    float l = smoothstep(-LINE_WIDTH * 0.5, -LINE_WIDTH * 0.5 - SMOOTH_RATIO, uv.x);\n    uv = rotate(uv, PI * 0.07);\n    float a = 1.2;\n    float r = smoothstep( a - LINE_WIDTH * 0.5,  a - LINE_WIDTH * 0.5 + SMOOTH_RATIO, uv.x);\n\n    float b = -0.5;\n    float y = smoothstep(b + SMOOTH_RATIO, b, uv.y);\n\n    return (1.0 - (l + r)) * y;\n}\n\nvec2 RightDownUV(in vec2 uv)\n{\n    return 2.0 * (uv - vec2(iResolution.x, 0)) / min(iResolution.x, iResolution.y) + vec2(1.0, -1.0);\n}\n\nfloat hash( int n ) \n{\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*float( n & ivec3(0x0fffffff))/float(0x0fffffff);\n}\n\nfloat gnoise( in float p )\n{\n    int   i = int(floor(p));\n    float f = fract(p);\n    float u = f*f*(3.0-2.0*f);\n    return mix( hash(i+0)*(f-0.0), \n                hash(i+1)*(f-1.0), u);\n}\n\nfloat fbm( in float x, in float G )\n{    \n    x += 26.06;\n    float n = 0.0;\n    float s = 1.0;\n    float a = 0.0;\n    float f = 1.0;    \n    for( int i=0; i<4; i++ )\n    {\n        n += s*gnoise(x*f);\n        a += s;\n        s *= G;\n        f *= 2.0;\n        x += 0.31;\n    }\n    return n;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 backGroundColor = vec3(1.0);\n    vec3 armColor = vec3(0.43);\n    vec3 lineColor = vec3(0.0, 0.0, 0.0);\n    vec3 color = backGroundColor;\n\n    // background\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    float angle = atan(uv.x, uv.y);\n    if (angle > PI)\n    {\n        angle = -angle + 2.0 * PI;\n    }\n    uv += normalize(uv) * 0.7 * fbm(20.0 * angle, 0.6);\n    if (iResolution.x < iResolution.y)\n    {\n        uv *= vec2(1.0, iResolution.x / iResolution.y);\n    }\n    else\n    {\n        uv *= vec2(iResolution.y / iResolution.x,  1.0);\n    }\n    float r = smoothstep(0.0, SMOOTH_RATIO, sdBox(uv, vec2(0.96, 0.96)));\n    color = mix(color, lineColor, r);\n\n    // hand\n    uv = RightDownUV(fragCoord);\n    uv = scale(uv, vec2(0.25));\n    color = mix(color, lineColor, arm(uv, vec2(1.1)));\n    color = mix(color, armColor, arm(move(uv, vec2(0.0, 0.18)), vec2(0.94)));\n    color = mix(color, lineColor, circleIn(uv, vec2(1.09)));\n    color = mix(color, backGroundColor, circleIn(uv, vec2(1.0)));\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}