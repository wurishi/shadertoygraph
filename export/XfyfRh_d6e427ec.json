{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":3,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 bg = texture(iChannel0, uv); // raw BG\n    vec4 depthMask = vec4(1.0) - texture(iChannel3, uv); // raw depth mask;\n    \n    //vec4 bg_r = render(fragCoord, iResolution.xy, iMouse.xy, iChannel0, vec4(1.0)); // rendered BG\n    vec4 fg_r = render(fragCoord, iResolution.xy, iMouse.xy, iChannel1, depthMask); // rendered FG\n    vec4 pp = render(fragCoord, iResolution.xy, iMouse.xy, iChannel2, vec4(1.0)); // rendered pointer light\n    \n    float dm_threshold = 0.95; // don't want this to be 1 because of aliasing in the depth mask\n    \n    if (depthMask.r > dm_threshold) fragColor = fg_r;\n    else fragColor = max(pp+bg,fg_r);\n\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"const float pi=3.1416;\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nfloat smooth_step( float min, float max, float x )\n{\n    float t =(x - min) / (max - min);\n    t = clamp(t, 0.0, 1.0);\n    t = t * t * (3.0 - 2.0 * t); // smoothstep formula   \n    return t;\n}\n\nfloat step2( float min, float max, float x )\n{\n    float t =(x - min) / (max - min);\n    t = clamp(t, 0.0, 1.0); \n    return t;\n}\n\nvec4 render(in vec2 fragCoord, in vec2 iResolution,\n            in vec2 iMouse, in sampler2D iChannel0, in vec4 depthMask)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 col = vec4(0.0);\n    vec4 img0 = texture(iChannel0, uv);\n    //vec4 img1 = texture(iChannel1, uv);\n    vec4 img2 = vec4(0.0,0.0,0.0,1.0);\n    vec4 img3 = vec4(1.0,1.0,1.0,1.0);\n    \n    //vec3 normals= 2.0*img1.rgb - vec3(1.0); \n    //normals = normals/length(normals); \n    \n    \n    int num_of_Samples=100; \n    float d=0.5;\n    float R=d; \n    vec3 shader_point=vec3(fragCoord,(1.0+d)*img0.x-d);\n    float a=5.0;\n    \n    vec3 light_position = vec3(iMouse.x,iMouse.y,3.00); \n    vec3 light_vector = light_position - shader_point;\n    vec3 light_dir=light_vector/length(light_vector); \n    \n    \n    for (int i=0; i<num_of_Samples; i++) {\n    vec3 pos=shader_point+float(i)*d*a*light_dir+ 0.00125*vec3(random(shader_point.xy));\n    vec2 pos_uv= pos.xy/iResolution.xy; \n    vec4 H = texture(iChannel0,pos_uv);\n    if(H.x>pos.z) R=R+d;\n    }\n    \n    float t=d/R;\n    t=2.0*pow(t,0.45);\n    t=clamp(t,0.0,1.0);\n    \n    //float dif= 0.5*dot(light_dir,normals)+0.5;\n    //float W=pow(dif,10.0);\n    \n    //if(texelFetch( iChannel2, ivec2(KEY_UP,0),0).x == 1.0) t=dif;\n    //if(texelFetch( iChannel2, ivec2(KEY_DOWN,0),0).x == 1.0)\n    /*\n    {float W=0.10; t=W*dif+(1.0-W)*t;}\n    if(texelFetch( iChannel2, ivec2(KEY_LEFT,0),0).x == 1.0)\n    {W=W/2.0; t=W*dif+(1.0-W)*t;}\n    if(texelFetch( iChannel2, ivec2(KEY_RIGHT,0),0).x == 1.0)\n    {W=W/3.0; t=W*dif+(1.0-W)*t;}\n    \n    */\n    col = img2*(1.0-t)+img3*t;  \n \n    vec4 fragColor = vec4(col);\n    // we don't want to shade areas of the image where the depth mask is 0,\n    // so instead just return a black pixel\n    if (depthMask.r < 0.1) return vec4(0.0);\n    \n    return fragColor;\n}","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XfyfRh","date":"1733728785","viewed":70,"name":"sundos hw","username":"aksel","description":"for sundos","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["stuff"],"hasliked":0,"parentid":"","parentname":""}}