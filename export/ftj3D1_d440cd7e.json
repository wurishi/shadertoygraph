{"ver":"0.1","info":{"id":"ftj3D1","date":"1623851351","viewed":133,"name":"marching_scene_n","username":"skaplun","description":"Sorry for the naming\nOriginal - https://angulargeometry.tumblr.com/post/173654378690/mint-interior-gif-daily-c4d\nShading by @gltracy","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sdf","reproduction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_MARCHING_STEPS 128\n#define EPSILON .0001\n\nHit world(vec3 p){\n  \tHit res = Hit(max(plane(p, UP, 0.), -distance(max(abs(p.x), abs(p.z)), 1.23) + .77), mat3(1.));\n    mat3 m = rz(fbm1x(1.1, iTime) * 2.);\n    vec3 mp = p * m;\n    res = opMin(res, Hit(max(plane(mp, UP, 0.), distance(max(abs(mp.x), abs(mp.z)), 1.74) - .25), m));\n    m = rz(fbm1x(1.2, iTime - .1) * 2.);\n    mp = p * m;\n    res = opMin(res, Hit(max(plane(mp, UP, 0.), distance(max(abs(mp.x), abs(mp.z)), 1.23) - .25), m));\n    m = rz(fbm1x(1.3, iTime - .2) * 2.);\n    mp = p * m;\n    res = opMin(res, Hit(max(plane(mp, UP, 0.), distance(max(abs(mp.x), abs(mp.z)),  .72) - .25), m));\n    return res;\n}\n\nHit march(vec3 eye, vec3 marchingDirection, float start, float end){\n    float t = start;\n    for(int i=0; i<MAX_MARCHING_STEPS; i++){\n\t    Hit h = world( eye + marchingDirection * t );\n        if( h.dist < EPSILON ) return Hit(t, h.mat);\n        t += h.dist;\n        if ( t >= end)\n\t\t\treturn Hit(-end, mat3(0.));\n    }\n    return Hit(-1., mat3(0.));\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        world(vec3(p.x + EPSILON, p.y, p.z)).dist - world(vec3(p.x - EPSILON, p.y, p.z)).dist,\n        world(vec3(p.x, p.y + EPSILON, p.z)).dist - world(vec3(p.x, p.y - EPSILON, p.z)).dist,\n        world(vec3(p.x, p.y, p.z  + EPSILON)).dist - world(vec3(p.x, p.y, p.z - EPSILON)).dist\n    ));\n}\n\nfloat shadow( vec3 v, vec3 light ) {\n\tvec3 lv = v - light;\n\tfloat end = length( lv );\n\tlv /= end;\n\tfloat depth = abs(march( light, lv, 0.0, end ).dist);\n\treturn step( end - depth, 0.03 );\n}\n\nconst int   ao_iterations = 10;\nconst float ao_step = 0.1;\nconst float ao_scale = .8;\nfloat ao( vec3 v, vec3 n ) {\n\tfloat sum = 0.0;\n\tfloat att = 1.0;\n\tfloat len = ao_step;\n\tfor ( int i = 0; i < ao_iterations; i++ ) {\n\t\tsum += ( len - world( v + n * len ).dist ) * att;\n\t\tlen += ao_step;\n\t\tatt *= 0.5;\n\t}\n\treturn max( 1.0 - sum * ao_scale, 0.0 );\n}\n\nconst vec3 GREEN = vec3(54., 245., 142.)/255.;\nconst vec3 GREY = vec3(163., 167., 171.)/255.;\nvec3 shading( vec3 v, vec3 n, vec3 eye, mat3 m ) {\n    vec3 albedo = mix(GREEN, GREY, step(.5, dot(abs(n * m), UP)));\n\tvec3 final = albedo;\n\t\n\tvec3 ev = normalize( v - eye );\n\tvec3 ref_ev = reflect( ev, n );\n\t\n\t// light 0\n\t{\n\t\tvec3 light_pos   = vec3( 10.0 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, 12.0 );\n\t\t\n\t\tfinal *= (.2 + diffuse + specular * .25) * shadow( v, light_pos ); \n\t}\n\t\n\t// light 1\n\t{\n\t\tvec3 light_pos   = vec3( 5., 5., -5. );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, 64.0 );\n\t\t\n\t\tfinal += vec3( 0.1 ) * ( diffuse * 0.4 + specular * 0.9 ); \n\t}\n\n\tfinal *= ao(v, n);\n\t\n\treturn final;\n}\n\nvec3 render(in vec2 fragCoord){\n\tvec3 color = vec3(0.);\n    float a = (iMouse.x/iResolution.x) * PI;\n    vec3 eye = vec3(5. * sin(a), 3., 5. * cos(a)) * 1.3;\n    vec3 viewDir = rayDirection(60., iResolution.xy, fragCoord);\n    vec3 worldDir = viewMatrix(eye, vec3(0., -.5, 0.), vec3(0., 1., 0.)) * viewDir;\n\t\n    Hit h = march(eye, worldDir, 0., 1000.);\n    if (h.dist >= 0.) {\n        vec3 p = (eye + h.dist * worldDir);\n    \tvec3 norm = estimateNormal(p);\n        color = shading(p, norm, eye, h.mat);\n    }\n    return color;\n}\n\n#define AA 2\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ){\n    fragColor -= fragColor;\n    for(int y = 0; y < AA; ++y)\n        for(int x = 0; x < AA; ++x)\n            fragColor.rgb += clamp(render(fragCoord + vec2(x, y) / float(AA)), 0., 1.);\n    fragColor.rgb /= float(AA * AA);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MIN_FLOAT 1e-6\n#define MAX_FLOAT 1e6\nconst float PI = acos(-1.);\nconst vec3 UP = vec3(0., 1., 0.);\n\nstruct Ray{vec3 origin, direction;};\nstruct Hit{float dist; mat3 mat;};\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nfloat sdBox(vec3 p, vec3 b){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdPlane(vec3 p, vec3 n, float h ) {\n    return dot(p,n) + h;\n}\n\nconst float CUTOFF_PLANES_THICKNESS = .1;\nfloat plane(vec3 pos, vec3 nrm, float dist){\n    return max(-sdPlane(pos, nrm, -dist + CUTOFF_PLANES_THICKNESS),\n               -sdPlane(pos, nrm * -1., dist + CUTOFF_PLANES_THICKNESS));\n}\n\n#define rz(a) mat3(cos(a),-sin(a), 0.0, sin(a), cos(a), 0.0, 0.0, 0.0, 1.0)\nvec3 r(vec3 p, float a){\n    return (p * rz(a));\n}\n\nHit opMin(Hit a, Hit b){\n    if (a.dist <= b.dist) return a;\n    else return b;\n}\n\nfloat fbm1x(float x, float time){\n\tfloat amplitude = 1.;\n    float frequency = 1.;\n    float y = sin(x * frequency);\n    float t = 0.01*(-time * 130.0);\n    y += sin(x*frequency*2.1 + t)*4.5;\n    y += sin(x*frequency*1.72 + t*1.121)*4.0;\n    y += sin(x*frequency*2.221 + t*0.437)*5.0;\n    y += sin(x*frequency*3.1122+ t*4.269)*2.5;\n    y *= amplitude*0.06;\n    return y;\n}","name":"Common","description":"","type":"common"}]}