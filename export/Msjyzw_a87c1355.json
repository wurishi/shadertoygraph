{"ver":"0.1","info":{"id":"Msjyzw","date":"1491787699","viewed":483,"name":"dots..","username":"Shimmen","description":"Just some experiment. It's not too interesting, but it's fun to look at.","likes":4,"published":1,"flags":8,"usePreview":0,"tags":["procedural","2d","test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI     = 3.14159265359;\nconst float TWO_PI = 2.0 * PI;\n\nconst vec3 luma = vec3(0.2126,0.7152,0.0722);\n\nconst float ballEdge = 1.3;\n\n// From https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(vec2 c) {\n\treturn fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat renderDot(vec2 pos, float radius, float edge, vec2 fragCoord) {\n    return 1.0 - smoothstep(radius - edge, radius + edge, length(fragCoord - pos.xy));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float time = iTime;\n\t\n    // Background\n    fragColor = vec4(\n        sin(uv.x) + cos(time * 1.8) / 2.0,\n        cos(uv.y) + sin(time * 1.5) / 3.0,\n        0.5 + 0.5 * sin(time * 2.0) * cos(time * 2.0) / 9.0,\n        1.0\n    );\n\n    // Draw \"balls\"/dots\n    const int numBalls = 50;\n    float ballRadius = iResolution.y / 3.0;\n    float xInset = iResolution.x / 5.1;\n    float yAmplitude = 0.15 * iResolution.y;\n    \n    float xOffsetPerBall = (iResolution.x - 2.0 * xInset) / float(numBalls - 1);\n    float yCenter = 0.5 * iResolution.y;\n    \n    for (int i = 0; i < numBalls; i++) {\n        \n        float x = xInset + float(i) * xOffsetPerBall;\n        \n        float speed = 2.3;\n        float wavelength = 2.0;\n        float yOffset = float(i) / float(numBalls - 1) * TWO_PI * 1.0 / wavelength;\n        float y = yCenter + yAmplitude * sin(yOffset + (time * speed));\n        \n        float edgeBlur = ballEdge + 1.4 * (1.0 - abs(sin(yOffset + (time * speed))));\n        \n        float dot = renderDot(vec2(x, y), ballRadius, edgeBlur, fragCoord);\n        fragColor = mix(fragColor, vec4(1.15, 1.15, 1.28, 1.0) - fragColor, dot);\n    }\n    \n    // Desaturate\n    float fragLuma = dot(fragColor.rgb, luma);\n    vec3 grayscale = vec3(fragLuma);\n    fragColor = vec4(mix(grayscale, fragColor.rgb, 0.32), 1.0);\n    \n    // Add noise\n    float noise = rand(uv + sin(time) + cos(time));\n    float noiseAmount = 0.09 * smoothstep(0.7, 0.9, fragLuma);\n    fragColor += noiseAmount * (vec4(noise, noise, noise, 1.0) * 2.0 - 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"XsfGRr","channel":0}],"code":"const float PI     = 3.14159265359;\nconst float TWO_PI = 2.0 * PI;\n\n// Util\n//\n\nfloat Hz(float freq, float time)\n{\n    return TWO_PI * freq * time;\n}\n\n// Oscilators\n//\n\nfloat sine(float freq)\n{\n    return sin(freq);\n}\n\nfloat square(float freq)\n{\n    return clamp(10000.0 * sin(freq), -1.0, 1.0);\n}\n\n// Instruments\n//\n\n#define ADD(s, w) sound += s; weight += w;\n\nfloat flute(float freq)\n{\n    float weight = 0.0;\n    float sound = 0.0;\n    \n    ADD(sine(freq), 0.95);\n    ADD(sine(freq), 0.36);\n    ADD(sine(freq), 0.29);\n    ADD(sine(freq), 0.42);\n    ADD(sine(freq), 0.10);\n    \n    return sound / weight;\n}\n\n// Effects\n//\n\nfloat vibra(float sound, float time)\n{\n    return sound * (1.0 + 0.17 * sin(time * 50.0));\n}\n\n// Final\n//\n\nfloat left(float time)\n{\n    return vibra(flute(Hz(87.0, time)), time);\n}\n\nfloat right(float time)\n{\n    return vibra(flute(Hz(88.0, time)), time);\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    return 0.1 * vec2(left(time), right(time));\n    //return vec2(0.0);\n}","name":"Sound","description":"","type":"sound"}]}