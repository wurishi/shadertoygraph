{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// EVERY THING COOL COMES FROM:`\n//Fast Edge detection by nimitz (twitter: @stormoid)\n//https://www.shadertoy.com/view/4s2XRd\n\n// Also IQ:\n// https://iquilezles.org/www/index.htm\n// https://www.shadertoy.com/user/iq\n\n\n#define EDGE_SIZE 0.14\n#define SMOOTH 0.01\n\n#define ITR 120\n#define FAR 40.\n#define time iTime\n\nvec4 spherePos[10];\n\nfloat hash( float n ) { return fract(sin(n)*43758.5453); }\n\n// exponential smooth min (k = 32);\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat opBlend( vec2 d1, vec2 d2 )\n{\n\n    return smin( d1.x , d2.x , 8.);\n}\n\nfloat sdSphere( vec3 p, float s){\n\treturn length( p ) - s * 1.;\n}\n\nvec2 map(vec3 pos)\n{\n\t\n   \tvec2 res = vec2( 10000. , 0.);// vec2( sdPlane( pos - vec3( 0. , -1. , 0. )), 0.0 );\n   \n    for( int i = 0; i < 10; i++ ){\n   \t\t\n        vec2 res2 = vec2( sdSphere( (pos - spherePos[i].xyz) , spherePos[i].w ) , float(i) + 1.);\n        //vec2 res2 = vec2( udRoundBox( (pos - spherePos[i].xyz) , vec3( spherePos[i].w  ) ,spherePos[i].w * .2 ) , float(i) + 1.);\n   \t\tres.x = opBlend( res ,  res2 );\n        \n   \t}\n    \n   \treturn res;\n    \t\n}\n\n\n\n\n//Fast Edge detection by nimitz (twitter: @stormoid)\n//https://www.shadertoy.com/view/4s2XRd\n/*\t\n\tKeeping track of min distance, then, when the min distance \n\tis both under a given threshold and starts increasing (meaning that\n\ta fold was just passed) then I mark that pixel as an edge. The min\n\tdistance can then be smoothed allowing for arbitrarily smooth edges.\n*/\nvec4 calcIntersection(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.01;\n    float h=precis*2.0;\n    vec2 d = vec2(0.,10000.);\n    float md = 1.;\n    float id = 0.;;\n    bool stp = false;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d.x>=FAR ) break;\n        d.x += h;\n\t   \tvec2 res = map(ro+rd*d.x);\n        if (!stp) \n        {\n            md = min(md,res.x);\n            if (h < EDGE_SIZE && h < res.x && i>0)\n            {\n                stp = true;\n                d.y = d.x;\n            }\n        }\n        h = res.x;\n        id = res.y;\n    }\n    \n    if (stp) md = smoothstep(EDGE_SIZE-SMOOTH, EDGE_SIZE+0.01, md);\n    else md = 1.;\n\treturn vec4(d, md, id);\n}\n\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3 + 10.0*mouseX;\n\tcamPos = vec3(3.5*sin(an),1.0,3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<30; i++ )\n    {\n        float hr = 0.01 + 0.612*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.5;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\n\t\n    for( int i =0; i < 10; i++ ){\n        \n        float x = 1. * cos(iTime *.13 * (float( i )+2.));\n        float y = 1. * sin(iTime * .075 * (float( i )+4.));\n        float z = 1. * sin(iTime * .1 * (float( i )+3.3));\n        float r = .2 * ( sin( iTime * .1  *( float( i) +1.))+2.);\n    \tspherePos[i] = vec4( x ,  y ,  z , r  );\n        \n        \n    }\n\n        \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    vec4 res = calcIntersection( ro , rd  );\n\n    vec3 col = vec3( 1. , 0. , 0. );\n    \n    if ( res.x < FAR )\n    {\n        vec3 pos = ro+res.x*rd;\n        float d = distance(ro,pos);\n        vec3 nor= calcNormal(pos);\n        \n        float amb = calcAO( pos,  nor );\n        float match = max( 0. , dot( -nor , rd ));\n\n      \n        col = vec3(amb * match )*vec3( 1., .2, .2 ) *(1.-res.z); //* vec3(res.z); //(nor * .5 +.5);\n        col += ( nor * .5 +.5)* vec3( 0.2 , .2 , 1.) * vec3(amb * (1.-match) );\n    }else{\n    \n        vec3 pos = ro+res.x*rd;\n        float d = distance(ro,pos);\n        vec3 nor= calcNormal(pos);\n       \n        float bg = 1. - res.z;\n       // col = nor * .5 + .5;\n \t\tcol = vec3( 1., .8 , .2 ) * vec3( bg ); //+ vec3(1. , 0. , 0. ) * res.z;\n        \n    }\n\n\t\n\tfragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4tf3Rl","date":"1424117147","viewed":362,"name":"SHADE A DAY ( 2 / 16 / 2015 ) ","username":"cabbibo","description":"Trying out the march function from https://www.shadertoy.com/view/4s2XRd by @nimitz","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytrace"],"hasliked":0,"parentid":"","parentname":""}}