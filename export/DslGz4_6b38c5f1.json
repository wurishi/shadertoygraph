{"ver":"0.1","info":{"id":"DslGz4","date":"1665752849","viewed":71,"name":"Screenspace coat","username":"berkbig","description":"screenspace grid shader","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"ftXyW4","parentname":"Colored Bulbs"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Raymarching parameters\n#define MAX_STEPS 512\n#define NEAR_ENOUGH 0.001\n#define TOO_FAR 85.0\n\n// Lighting parameters\n#define DIFFUSE_FACTOR 0.6\n#define SPECULAR_FACTOR .9\n#define SHININESS 16.\n\n#define BACKGROUND_COLOR vec3(0., 0., 0.)\n#define SMOOTH_FACTOR 0.3\n\nfloat sphere(vec3 point, vec3 center, float radius) {\n    return length(point - center) - radius;\n}\n\n// Big thanks to Inigo Iquilez\nfloat smooth_min(float a, float b, float k) {\n    float h = max(k - abs(a-b), 0.) / k;\n    return min(a, b) - h*h*h*k*(1./6.);\n}\n\nfloat distance_from_everything(vec3 point) {\n    float d = sphere(point, vec3(sin(iTime), 0, 0), .8);\n    d = smooth_min(d, sphere(point, vec3(cos(iTime), .8, -.5), .6), SMOOTH_FACTOR);\n    d = smooth_min(d, sphere(point, vec3(sin(1.1*iTime+.5), -.8, -.3), .6), SMOOTH_FACTOR);\n    d = smooth_min(d, sphere(point, vec3(1.2, 0, 0), 1.), SMOOTH_FACTOR);\n    d = smooth_min(d, sphere(point, vec3(-1.2, 0, 0), 1.), SMOOTH_FACTOR);\n    d = smooth_min(d, sphere(point, vec3(0, 1, 0), 1.), SMOOTH_FACTOR);\n    return d;\n}\n\nfloat ray_march(vec3 ray_origin, vec3 ray_direction) {\n    // How far we've traveled\n    float d = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        // Where we stand\n        vec3 point = ray_origin + ray_direction*d;\n        // How far anything is from us\n        float current_distance = distance_from_everything(point);\n        // March on\n        d += current_distance;\n        // Check status - have we reached a surface?\n        if (current_distance < NEAR_ENOUGH || d > TOO_FAR)\n            break;\n    }\n    return d;\n}\n\n// See https://iquilezles.org/articles/normalsSDF\nvec3 estimate_normal(vec3 point) {\n    vec2 e = vec2(NEAR_ENOUGH, 0); // x smol, y none\n    // Find normal as tangent of distance function\n    return normalize(vec3(\n        distance_from_everything(point + e.xyy) - distance_from_everything(point - e.xyy),\n        distance_from_everything(point + e.yxy) - distance_from_everything(point - e.yxy),\n        distance_from_everything(point + e.yyx) - distance_from_everything(point - e.yyx)\n    ));\n}\n\nfloat phong_light(vec3 point, vec3 light_position, vec3 n, vec3 camera) {\n    vec3 l = normalize(light_position-point);\n    vec3 c = normalize(camera-point);\n    // Standard diffuse term\n    float diffuse = max(dot(n, l), 0.);\n    float specular = pow(max(dot(reflect(-l, n), -c), 0.), SHININESS);\n\n    return DIFFUSE_FACTOR * diffuse + SPECULAR_FACTOR * specular;\n}\n\nvec3 lighting(vec3 point, vec3 camera, vec3 camDir, float dist) {\n    // Avoid casting specular highlight from the void\n    if (length(point - camera) > TOO_FAR*0.99)\n        return BACKGROUND_COLOR;\n\n    vec3 changing_color = vec3(1., cos(point.y +.9), sin(point.x));\n    return phong_light(point, vec3(1, 1, -2), estimate_normal(point), camera) * vec3(1.5,1.5,1.5)\n;\n}\n\n\nvec3 coat(in vec2 fragCoord )\n{\n    vec3 purple=vec3(1,0,1);\n    vec3 blue=vec3(0,0,1);\n    bool isblue=(int(fragCoord.x)%40<3) || (int(fragCoord.y)%40<3);\n    // Output to screen\n    return (isblue?blue:purple);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 xy = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n\n    // Ray origin\n    vec3 camera = vec3(0., 0.3, -4.);\n    // Ray direction\n    vec3 ray_direction = vec3(xy, 1.);\n\n    float d = ray_march(camera, ray_direction);\n    \n    vec3 point = camera + ray_direction * d;\n    \n    vec3 base_color = lighting(point, camera, ray_direction, d);\n\n    fragColor = vec4(base_color*coat(fragCoord), 1.);\n}\n","name":"Image","description":"","type":"image"}]}