{"ver":"0.1","info":{"id":"lf2SDD","date":"1706379797","viewed":157,"name":"Physical Donuts","username":"spalmer","description":"Takes advantage of voronoi particle tracking to make stiff verlet soft-bodies.\nStripped down fork.\n\n","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["voronoi","particles","tracking","physics","jelly","verlet","softbody"],"hasliked":0,"parentid":"4cfSz8","parentname":"Left Over Cuttings"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// http://shadertoy.com/view/lf2SDD\n// fork of \"Left Over Cuttings\" by UnstableLobster  http://shadertoy.com/view/4cfSz8\n// see also  \"Shapes and Sizes\" by UnstableLobster  http://shadertoy.com/view/XcXGW7\n\nfloat smin(float a, float b, float k, float p) //, out float t)\n{\n    float h = max(k - abs(a - b), 0.) / k,\n         m = .5 * pow(h, p);\n    //t = a < b ? m : 1. - m;\n    return min(a, b) - m * k / p;\n}\n// but FIXME sqrt smoothmin is most efficient\n\nvoid mainImage(out vec4 O, in vec2 pos)\n{\n    vec2 res = iResolution.xy;\n    // FIXME refactor this please, occurs many places in code\n    vec2 middle = floor(.5 * res.xy - vec2(int(res.x) % 2, int(res.y) % 2));\n    \n    // closest particles to this pixel    \n    ivec4 ids = ivec4(texel(ch0, pos * voronoi_res));\n    \n    float pSize = 2. * particle_rad;\n\n    particle Pa = getParticle(ids.x,                                    middle, ch3);\n    particle Pb = getParticle(ids.x + 1,                                middle, ch3);\n    particle Pc = getParticle(ids.x - 1,                                middle, ch3);\n    particle Pd = getParticle(ids.x + int(res.x / pSize * voronoi_res), middle, ch3);\n    particle Pe = getParticle(ids.x - int(res.x / pSize * voronoi_res), middle, ch3);\n       \n    float da = distance(Pa.NX, pos * voronoi_res) - Pa.R;\n    float db = distance(Pb.NX, pos * voronoi_res) - Pb.R;\n    float dc = distance(Pc.NX, pos * voronoi_res) - Pc.R;\n    float dd = distance(Pd.NX, pos * voronoi_res) - Pd.R;\n    float de = distance(Pe.NX, pos * voronoi_res) - Pe.R;\n    \n    float k = 4.0;\n    float p = 2.0;\n    //float t;\n    da = smin(da, db, k, p); //, t); //min(da, db); //\n    da = smin(da, dc, k, p); //, t); //min(da, dc); //\n    da = smin(da, dd, k, p); //, t); //min(da, dd); //\n    da = smin(da, de, k, p); //, t); //min(da, de); //\n    \n    //rng_initialize(vec2(Pa.GID), 0);\n    O = vec4(.5 - da);\n}\n\n//#define aaSoft 0.8\n//#define erf(x) tanh( clamp( 2.0/sqrt(PI) * (x + (11.0/123.0)*x*x*x), -10.0, 10.0) )\n//#define mixSDF(a, b, s, t) mix(a, b, erf((-(s)/(t)*2.0*aaSoft))*0.5+0.5)\n\n    /*\n    vec2 V = (Pa.NX - Pa.X)/dt;\n    V =  mix(dir(rand()), V, min(length(V)+rand(), 1.0));\n    float v = atan(V.y, V.x) + rand()*TAU;\n    vec3 vc = vec3(\n        dot(vec2(1,0), dir(v + TAU*1.0/3.0) * 0.5 + 0.5),\n        dot(vec2(1,0), dir(v + TAU*2.0/3.0) * 0.5 + 0.5),\n        dot(vec2(1,0), dir(v + TAU*3.0/3.0) * 0.5 + 0.5)\n    );*/\n    \n    //particle Pr = getParticle(ids.x, middle, ch2);\n    /*vec2 A = (V - (Pr.NX-Pr.X))/dt;\n    float a = atan(A.y, A.x) + rand()*TAU;\n    vec3 ac = vec3(1);\n    ac *= vec3(\n        dot(vec2(1,0), dir(a + TAU*1.0/3.0) * 0.5 + 0.5),\n        dot(vec2(1,0), dir(a + TAU*2.0/3.0) * 0.5 + 0.5),\n        dot(vec2(1,0), dir(a + TAU*3.0/3.0) * 0.5 + 0.5)\n    );*/\n    // shadow\n    //particle Ps = getParticle(int(texel(ch0, pos*voronoi_res - vec2(10.0, 5.0)).x), middle, ch3);\n    //float ds = distance(Ps.X, pos*voronoi_res - vec2(10.0, 5.0)) - Ps.R;\n    //ds = smin(ds, ds, 4.0, 2.0, t);\n    \n    //O = vec4(.5 - da);\n    //O.xyz = mixSDF(vec3(0.75), vec3(0.68), ds, 1.0);\n    //O.xyz = mixSDF(O.xyz, vec3(0.5 + rand()*0.2) * sin(-da) + (vc-ac) * length(V) * 0.08 + hash4(uvec4(ids.x)).x*0.15, da, 1.0);\n    \n    //O.xyz = pow(O.xyz, vec3(1.2));\n//}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\nconst float PI = acos(-1.),\n    TAU = radians(360.); //2. * PI;\n\n#define snormalize(x) (dot(x, x) > 0. ? normalize(x) : x)\n\n//#define saturate(x) clamp(x, 0.0, 1.0)\n\n// Sim settings\nconst float voronoi_res = 1.0,\n    particle_rad = 2.0,\n    compression_compliance = 0.0,\n    tension_compliance = 0.0;\n\n//#define dt min(1. / 13., timeDelta) //(1. / 13.) //\n    // TODO \n    \nconst int\n    distance_loops = 2;\n\n    //particle_count = 1, //int(R.x*R.y*voronoi_res*voronoi_res/(particle_rad*particle_rad*4.0)), //\n\n\n\n// RNG\nuvec4 s0; \n\nvoid rng_initialize(vec2 p, int frame)\n{\n    s0 = uvec4(p, frame, p.x + p.y);\n}\n\n// http://pcg-random.org/\nvoid pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n}\n//float rand() { pcg4d(s0); return float(s0.x ) / float(0xffffffffu); }\nvec2 rand2() { pcg4d(s0); return vec2(s0.xy ) / float(0xffffffffu); }\n//vec3 rand3() { pcg4d(s0); return vec3(s0.xyz) / float(0xffffffffu); }\n//vec4 rand4() { pcg4d(s0); return vec4(s0    ) / float(0xffffffffu); }\nvec4 hash4(uvec4 seed) { pcg4d(seed); return vec4(seed) / float(0xffffffffu); }\n\nvec2 dir(float rad)\n{\n    return vec2(cos(rad), sin(rad));\n}\n\nmat2 rot(float rad)\n{\n    float c = cos(rad), s = sin(rad);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec2 p, vec2 b)\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.)) + min(max(d.x, d.y), 0.);\n}\n/*\nfloat sdCross(vec2 p, vec2 b, float r) \n{\n    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n    vec2  q = p - b;\n    float k = max(q.y,q.x);\n    vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n    return sign(k) * length(max(w,0.0)) + r;\n}\n*/\n\nfloat border(vec2 p, vec2 R)\n{\n    return -sdBox(p - R * .5, R * vec2(.5)) - 1.;\n}\n\nvec3 bN(vec2 p, vec2 R)\n{\n    const float hh = 1.;\n    const vec3 dx = vec3(-hh, 0, hh);\n    const vec4 idx = vec4(-1./hh, 0., 1./hh, .25);\n    vec3 r = idx.zyw * border(p + dx.zy, R)\n           + idx.xyw * border(p + dx.xy, R)\n           + idx.yzw * border(p + dx.yz, R)\n           + idx.yxw * border(p + dx.yx, R);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\n\nvec2 idToPos(int id, vec2 m)\n{\n    int x = int(m.x);\n    return vec2(id % x, id / x);\n}\n\nint posToId(vec2 p, vec2 m)\n{\n    return (int(p.y) * int(m.x)) + int(p.x);\n}\n\n\nstruct particle\n{\n    vec2 X;     // position\n    vec2 NX;    // corrective position\n    \n    float R;    // radius\n    float M;    // mass\n    bool A;     // active\n    int GID;    // group ID\n};\n\nparticle getParticle(vec2 p, vec2 m, sampler2D ch)\n{\n    particle P;\n    vec4 data0 = texel(ch, p);\n    vec4 data1 = texel(ch, p + vec2(m.x, 0.0));\n\n    P.X = data0.xy;\n    P.NX = data0.zw;\n    \n    P.R = data1.x;\n    P.M = data1.y;\n    P.A = data1.z > 0.5;\n    P.GID = int(data1.w);\n        \n    return P;\n}\n\nparticle getParticle(int id, vec2 m, sampler2D ch)\n{\n    return getParticle(idToPos(id, m), m, ch);\n}\n\nivec4 getClosestIDs(particle P, sampler2D ch)\n{\n    return ivec4(texel(ch, P.NX));\n}\n\n/*\n// tiny discs\nfloat particleSDF(particle P, vec2 pos)\n{\n    float s = distance(P.NX, pos) - P.R;\n    return s;\n}\n\nvec2 particleNormal(particle P, vec2 pos)\n{\n    float e = 0.001,   \n        dx = particleSDF(P, pos + vec2(e, 0)) - particleSDF(P, pos - vec2(e, 0)),\n        dy = particleSDF(P, pos + vec2(0, e)) - particleSDF(P, pos - vec2(0, e));\n    return normalize(vec2(dx, dy));\n}\n\n\nvoid compare(inout ivec4 nn, ivec4 n)\n{\n    if (any(equal(ivec4(nn.x), n))) nn.x = -1;\n    if (any(equal(ivec4(nn.y), n))) nn.x = -1;\n    if (any(equal(ivec4(nn.z), n))) nn.x = -1;\n    if (any(equal(ivec4(nn.w), n))) nn.x = -1;\n}\n*/\n\n// Simulation\nvoid Integrate(inout particle P, vec4 mouse, vec2 R, float dt)\n{\n    vec2 V = (P.NX - P.X) / dt;\n    vec2 A; // = vec2(0);\n\n    // mouse\n    if (mouse.z > 0.0)\n    {\n        vec2 dx = mouse.xy * voronoi_res - P.NX;\n        float d = length(dx);\n        float f = exp(-d*d / (R.x*voronoi_res) / 10.0) * 5.;\n        \n        vec2 mx = mouse.xy - abs(mouse.zw);\n        \n        A += snormalize(dx) * f;// * snormalize(mx);\n    }\n\n    // gravity\n    A += vec2(0.0, -0.1);\n\n    if (length(V) > 4.25) V = normalize(V) * 4.25;\n\n    P.X = P.NX;\n    P.NX += (A * dt + V) * dt;\n}\n\nconst int NMAX = 4;\n\nvoid Substep(inout particle P, int id, sampler2D ch, vec2 middle, int neis[NMAX], int nn, vec2 R, float dt)\n{\n    vec2 F; // = vec2(0.0);\n\n    // collisions\n    for (int i = 0; i < nn; ++i)\n    {\n        int pid = neis[i];\n        if (pid == id || pid < 0) continue;\n\n        particle P0 = getParticle(pid, middle, ch);\n        \n        if (P.GID == P0.GID) continue;\n\n        vec2 dx = P.NX - P0.NX;\n        float d = length(dx);\n        vec2 n = snormalize(dx);\n        float r = (P.R + P0.R);\n        float m = P0.M / (P.M+P0.M); \n\n        // collision\n        float C = d - r;\n        float l = -C * m;\n        \n        if (d < r)\n           F += n * l * 0.5 / (1.0 + compression_compliance / dt / dt);\n           \n        // friction\n        vec2 pv = P.NX - P.X;\n        vec2 p0v = P0.NX - P0.X;\n        \n        vec2 ta = vec2(n.y, -n.x);\n        vec2 fta = ta * dot(ta, (pv-p0v));\n        \n        if (d <= r)\n            F -= fta * m;\n    }\n    \n    // connections\n    for (int i = -distance_loops; i <= distance_loops; ++i)\n    for (int j = -distance_loops; j <= distance_loops; ++j)\n    if (abs(i) + abs(j) > 0)\n    {\n        float pSize = 2.0 * particle_rad;\n    \n        int pid = id;\n        pid += i;\n        pid += j * int(R.x / pSize * voronoi_res);\n        pid = max(pid, 0);\n        \n        particle P0 = getParticle(pid, middle, ch);\n        if (!P0.A) continue;\n        if (P.GID != P0.GID) continue;\n\n        vec2 dx = P.NX - P0.NX;\n        float d = length(dx);\n        vec2 n = snormalize(dx);\n        float r = length(vec2(i, j)) * pSize;\n        float m = P0.M / (P.M + P0.M);\n        \n        // distance\n        float C = d - r;\n        float l = -C * m;\n        \n        if (l > 0.0) l /= 1.0 + compression_compliance / dt / dt;\n        if (l < 0.0) l /= 1.0 + tension_compliance / dt / dt;\n        \n        F += n * l / r / r * pSize * pSize * 0.25;\n    }\n\n    // border\n    vec2 m2vr = middle*2.0*voronoi_res;\n    vec2 n = bN(P.NX, m2vr).xy;\n    float d = border(P.NX, m2vr) - P.R;\n    if (d < 0.0)\n        F -= n*d * 1.0;\n        \n    // border friction\n    if (d < 0.0)\n    {\n        vec2 v = P.NX - P.X;\n        vec2 p = vec2(n.y, -n.x);\n        vec2 tang = p * dot(p, v);\n\n        F -= tang * 1.0;\n    }\n\n    P.NX += F;\n}\n\nfloat initialMap(vec2 pos, vec2 R, out int i)\n{\n    float div = 100.;\n    // TODO vectors\n    int idx = int(floor(pos.x / div));\n    int idy = int(floor(pos.y / div));\n    i = idx + idy * int(floor(R.x / div));\n    \n    pos = mod(pos, div);\n    // no partial shapes\n    if (float(idx + 1) * div > R.x ||\n        float(idy + 1) * div > R.y) return 9.;\n    pos -= 50.;    \n    vec4 h = hash4(uvec4(i));\n    return abs(length(pos) - 35.) - 7.5; // donut\n    //return length(pos) - 35.;\n    //return length(pos/50.) - .4;\n    //return sdBox(pos-vec2(0.0, -10.0), vec2(20.0) + (h.yz-0.5)*10.0);\n}\n\n// particle substep\nvoid initialConditions(inout vec4 O, vec2 pos, vec2 middle, vec2 R)\n{\n    int gid = 0;\n    \n    // positions\n    if (pos.y <= middle.y && pos.x <= middle.x)\n    {\n        int id = posToId(pos, middle);\n        \n        //O.xy = rand2() * R.xy * voronoi_res;\n        int pr = int(2. * particle_rad);\n        O.xy = vec2(id*pr % int(R.x*voronoi_res),\n                    id*pr / int(R.x*voronoi_res) * pr) + particle_rad;\n        O.zw = O.xy + (rand2() - .5) * .5;      \n        \n        if (initialMap(O.xy, R, gid) >= 0.0)\n        {\n            O = vec4(-10.0);\n        }\n    }\n    // radius - mass - active - groupID\n    else if (pos.y <= middle.y && pos.x > middle.x)\n    {\n        int id = posToId(pos - vec2(middle.x, 0), middle);\n    \n        O.x = particle_rad;\n        O.y = O.x * O.x*PI;\n        \n        int pr = int(2. * particle_rad);\n        vec2 p = vec2(id * pr % int(R.x * voronoi_res), \n                      id * pr / int(R.x * voronoi_res) * pr) + particle_rad;\n        \n        O.z = 0.0;\n        if (initialMap(p, R, gid) < 0.0)\n        {\n            O.z = 1.0;\n            O.w = float(gid);\n        }\n    }\n}\n\n// FIXME still unable to gracefully handle resolution changes\n\nvoid bufMain(out vec4 O, vec2 pos, \n            sampler2D chOld, sampler2D chDat,\n            vec4 mouse, vec2 res, int frame, float timedelta)\n{\n    float dt = clamp(timedelta, 1./30., 1./30.);\n    rng_initialize(pos, frame);\n    // TODO refactor\n    vec2 middle = floor(res * 0.5 - vec2(ivec2(res) % ivec2(2)));\n       \n    // initial conditions\n    if (frame < 2 || texel(chOld, res-1.).zw != res)\n    {\n        O *= 0.0;\n        initialConditions(O, pos, middle, res.xy);\n        //O = texelFetch(chOld, ivec2(pos), 0);\n        if (!any(lessThan(pos, res-1.))) O.zw = res;\n        return;\n    }\n    \n    // simulation substep\n    if (pos.y <= middle.y && pos.x <= middle.x)\n    {\n        int id = posToId(pos, middle);\n              \n        //if (id < particle_count)\n        {\n            particle P = getParticle(id, middle, chOld);\n            if (!P.A) return;\n            \n            ivec4 neis = ivec4(texel(chDat, P.NX));\n            int nn = 3;\n            int n[NMAX];\n\n            n[0] = neis.y; n[1] = neis.z; n[2] = neis.w;\n                       \n            Substep(P, id, chOld, middle, n, nn, res, dt);\n            Integrate(P, mouse, res, dt);\n                        \n            O = vec4(P.X, P.NX);\n        }       \n    }  \n    else \n        // thank you UnstableLobster!  finally fixes resolution change\n        O = texel(chOld, pos);\n        //discard;\n}\n\n#define MAIN(chOld, chDat) \\\nvoid mainImage(out vec4 O, vec2 pos) { \\\n    bufMain(O, pos, chOld, chDat, iMouse, iResolution.xy, iFrame, iTimeDelta); \\\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// voronoi particle tracking structure http://shadertoy.com/view/WltSz7\n\nvoid insertionSort(inout ivec4 i, inout vec4 d, int ni, float nd)\n{\t \n         if (nd < d[0]) { i = ivec4(   ni, i.xyz ); d = vec4(    nd, d.xyz); }\n    else if (nd < d[1]) { i = ivec4(i.x, ni, i.yz); d = vec4(d.x, nd, d.yz); }\n    else if (nd < d[2]) { i = ivec4(i.xy, ni, i.z); d = vec4(d.xy, nd, d.z); }\n    else if (nd < d[3]) { i = ivec4(i.xyz, ni    ); d = vec4(d.xyz, nd    ); }\n}\n\n\nvoid mainImage(out vec4 O, vec2 pos)\n{\n    vec2 res = iResolution.xy;\n    rng_initialize(pos, iFrame);\n    // TODO refactor \n    vec2 middle  = floor(res.xy * voronoi_res - vec2(ivec2(res.xy) % ivec2(2)));\n    vec2 pMiddle = floor(res.xy * .5          - vec2(ivec2(res.xy) % ivec2(2)));\n    \n    // initial conditions\n    if (iFrame == 0 || texel(ch0, res-1.).zw != res)\n    {\n        // was 3 random particle ids and one approximately where we are\n        O.xw = rand2() * float(65535.); //particle_count-1); \n        float pSize = 2. * particle_rad;\n        O.x = pos.x / pSize + floor(pos.y / pSize) * middle.x / pSize;\n        //O.x = min(O.x, float(particle_count-1));\n        // but I'm thinking we can get away with just the immediate neighbors\n        O.yz = O.x + vec2(1,-1);\n    } else {\n        // voronoi tracking\n        if (pos.y <= middle.y && pos.x <= middle.x)\n        {\n            vec4 dis = vec4(res.x*res.y);\n\n            ivec4 new = ivec4(-1),\n                o = ivec4(texel(ch0, pos              )),      \n                e = ivec4(texel(ch0, pos + vec2( 1, 0))),\n                n = ivec4(texel(ch0, pos + vec2( 0, 1))),\n                w = ivec4(texel(ch0, pos + vec2(-1, 0))),\n                s = ivec4(texel(ch0, pos + vec2( 0,-1))), \n                r = ivec4(texel(ch0, pos + round(rand2()) * 2. - 1.));\n\n            ivec4[] candidates = ivec4[]( o, e, n, w, s, r ); \n\n            for (int i = 0; i < candidates.length(); ++i)\n            for (int j = 0; j < 4; ++j)\n            {\n                int id = candidates[i][j];      \n\n                if (id < 0) continue;\n                if (any(equal(ivec4(id), new))) continue; // id already contained\n\n                particle P0 = getParticle(id, pMiddle, ch3); \n                if (!P0.A) continue;\n\n                float pd = distance(P0.NX, pos); //particleSDF(P0, pos);  // FIXME wasted sqrts            \n                if (pd < dis.w)\n                    insertionSort(new, dis, id, pd);\n            } \n\n            // random recovery\n            //int h = int(rand() * float(particle_count-1));\n            //particle rP = getParticle(h, pMiddle, ch3);\n            //int rPid = int(texel(ch0, rP.X).x);\n            //if (rP.A && h != rPid) // force insertion only if particle is not being tracked\n            //    new.w = h;\n\n            O = vec4(new);\n        }\n    }\n    if (!any(lessThan(pos, res - 1.))) O.zw = res;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"MAIN(ch3,ch0)\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"MAIN(ch1,ch0)\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"MAIN(ch2,ch0)\n","name":"Buffer D","description":"","type":"buffer"}]}