{"ver":"0.1","info":{"id":"fsK3zG","date":"1631810824","viewed":55,"name":"Purplish Spheres","username":"personalizedrefrigerator","description":"Based partially on http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Licensed under the MIT\n\n#define MAX_MARCHING_STEPS 100\n#define SMALL 0.001\n#define MIN_DEPTH 0.01\n#define MAX_DEPTH 1000.0\n#define PI 3.1415927\n\n#define CENTER vec3(0.0, 0.0, 50.0)\n\n\nfloat scene_sdf(vec3 p)\n{\n    float background_sphere_sdf = sphere_sdf\n    (\n        Sphere(vec3(0.0), (sin(iTime * 10.0 + floor(p.x / 40.0 * p.y / 40.0)) + 3.0) / 3.0),\n        vec3(-10.0) + mod(-abs(p), 40.0)\n    );\n\n    return min\n    (\n        min\n        (\n            smax\n            (\n                9.0, // k\n                sphere_sdf(Sphere(CENTER, 7.0), p),\n                sphere_sdf(Sphere(vec3(0.0,sin(iTime) * 10.9, 0.0) + CENTER, 4.0), p)\n            ),\n            smin\n            (\n                1.1 + sin(iTime),\n                sphere_sdf(Sphere(CENTER - vec3(4.0, 0.0, -10.0), 8.0), p),\n                sphere_sdf(Sphere(CENTER - vec3(4.0, 6.0, -10.0), 4.0), p)\n            )   \n        ),\n        min\n        (\n            sphere_sdf(Sphere(CENTER - vec3(sin(iTime), 0.0, cos(iTime)) * 20.0, 1.0), p),\n            background_sphere_sdf\n        )\n    );\n}\n\nvec3 get_scene_normal(vec3 p)\n{\n    return normalize(vec3(\n        scene_sdf(p + vec3(SMALL, 0.0, 0.0)) - scene_sdf(p - vec3(SMALL, 0.0, 0.0)),\n        scene_sdf(p + vec3(0.0, SMALL, 0.0)) - scene_sdf(p - vec3(0.0, SMALL, 0.0)),\n        scene_sdf(p + vec3(0.0, 0.0, SMALL)) - scene_sdf(p - vec3(0.0, 0.0, SMALL))\n    ));\n}\n\n/**\n * Get the (approximate) length of the ray (in the given direction) from the camera\n * to the scene.\n *\n * @param camera Camera position\n * @param direction Normalized direction to extend\n * @return Distance to scene, MIN_DEPTH, or MAX_DEPTH.\n */\nfloat march(in vec3 camera, in vec3 direction)\n{\n    float depth = MIN_DEPTH;\n    \n    for (int i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n        float dist = scene_sdf(camera + depth * direction);\n        \n        // If we're close enough...\n        if (dist < MIN_DEPTH)\n        {\n            return depth;\n        }\n        \n        depth += dist;\n        \n        if (depth >= MAX_DEPTH)\n        {\n            return MAX_DEPTH;\n        }\n     }\n     \n     return MAX_DEPTH;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = display_to_world(fragCoord.xy, iResolution.xy);\n    srand(uv.x + uv.y);\n\n    float camera_angle = (iMouse.x / iResolution.x - 0.5) * 0.2 * PI;\n    vec3 camera = vec3(0.0, iMouse.y / iResolution.y - 0.5, 0.0) * 300.0;\n    vec3 ray = normalize(vec3(uv, 1.0));\n    vec3 origin = vec3(0.0);\n    \n    if (iMouse.xy == vec2(0, 0))\n    {\n        camera = vec3(0.0);\n        camera_angle = 0.0;\n    }\n    \n    rotate_camera(vec3(-atan((camera.y - CENTER.y) / (camera.z - CENTER.z)), camera_angle, 0.0), origin, ray);\n    \n    // Cast the ray into the scene.\n    float dist = march(camera, ray);\n    \n    vec3 light_pos = vec3(camera.x, 0.0, camera.z);//vec3(cos(iTime * 0.3), tan(iTime), sin(iTime * 0.3)) * 30.0;\n    \n    vec3 hit_pos = dist * ray + camera;\n\n    // Output to screen, if we hit something.\n    if (dist < MAX_DEPTH)\n    {\n        float dist_to_light = length(light_pos - hit_pos);\n        vec3 to_light = normalize(light_pos - hit_pos);\n        vec3 normal = get_scene_normal(hit_pos);\n        vec3 to_camera = normalize(camera - hit_pos);\n        vec3 half_vec = normalize((to_camera + to_light) / 2.0);\n        \n        float shadow_march = min(march(hit_pos + normal * 0.2, to_light + rand_v3() * 0.01), dist_to_light);\n        float shadow_frac = shadow_march / dist_to_light;\n        \n        // Get the cosine of the angle between the normal and the light to\n        // approximate the brightness.\n        float brightness = max(dot(normal, to_light), 0.0);\n        \n        // Cos(Angle between halv_vec and normal) can be used to approximate\n        // specular lighting.\n        // See https://webglfundamentals.org/webgl/lessons/webgl-3d-lighting-point.html\n        float shine = max(dot(half_vec, normal), 0.0);\n        shine = pow(shine, 100.0);\n        \n        brightness *= max(shadow_frac, 0.4);\n        if (shadow_frac < 0.8)\n        {\n            shine = 0.0;\n        }\n        \n        vec3 color = (sin(normal.xzy) + vec3(1.0)) / 2.0 * brightness + vec3(shine);\n        fragColor = vec4(color, 1.0);\n    }\n    else\n    {\n        // Case where we didn't hit anything.\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Licensed under the MIT\n\nprecision mediump float;\n\nstruct Sphere\n{\n    vec3 pos;\n    float radius;\n};\n\nfloat sphere_sdf(Sphere obj_data, in vec3 p)\n{\n    return length(p - obj_data.pos) - obj_data.radius;\n}\n\nfloat _rand_seed = 0.2;\n\nfloat rand()\n{\n    return sin(tan(_rand_seed * 1023.2));\n}\n\nvoid srand(float seed)\n{\n    _rand_seed = seed;\n}\n\nvec3 rand_v3()\n{\n    return vec3(rand(), rand(), rand());\n}\n\nfloat sigmoid(float t)\n{\n    return 1.0 / (1.0 + exp(-t));\n}\n\n/**\n * A soft max function based on sigmoids.\n * Make [k] larger for a sharper transition between [a] and [b].\n */\nfloat smax(float k, float a, float b)\n{\n    return a * sigmoid(k * (a - b)) + b * sigmoid(k * (b - a));\n}\n\n/**\n * Returns an approximation of the lesser of [a] and [b]\n */\nfloat smin(float k, float a, float b)\n{\n    return b * sigmoid(k * (a - b)) + a * sigmoid(k * (b - a));\n}\n\n/**\n * Gets the location of the pixel corresponding to [fragCoord]\n * on the screen.\n */\nvec2 display_to_world(in vec2 fragCoord, in vec2 resolution)\n{\n    // Normalize <x, y> so that they range from <0, 0> to <1, 1>\n    vec2 uv = fragCoord/resolution.xy;\n    \n    // Shift so we have coordinates from -0.5 to 0.5\n    uv -= vec2(0.5);\n    uv *= vec2(resolution.x, resolution.y) / resolution.x;\n    \n    return uv;\n}\n\n/**\n * Creates and applies a rotation matrix to a ray with origin\n * [camera]\n */\nvoid rotate_camera(vec3 rotate, inout vec3 camera, inout vec3 ray)\n{\n    // x' = |r| cos(atan(y/x) + Δϑ)\n    //    = |r| (cos (atan y/x))(cos Δϑ) - |r| (sin (atan y/x))(sin Δϑ)\n    //    = (|r|·x/|r|)(cos Δϑ) - (|r|·y/|r|)(sin Δϑ)\n    //    = x cos Δϑ - y sin Δϑ for non-zero |r|.\n    // Similar process for y', where (x', y') are the transformed coordinates\n    // in the PLANE THAT WE'RE ROTATING IN.\n    \n    // Rotation in the XY plane\n    mat3 transform_z = mat3\n    (\n        cos(rotate.z), -sin(rotate.z), 0.0,\n        sin(rotate.z), cos(rotate.z), 0.0,\n        0.0, 0.0, 1.0\n    );\n    \n    // Rotation in the XZ plane\n    mat3 transform_y = mat3\n    (\n        cos(rotate.y), 0.0, -sin(rotate.y),\n        0.0, 1.0, 0.0,\n        sin(rotate.y), 0.0, cos(rotate.y)\n    );\n    \n    // Rotation in the YZ plane\n    mat3 transform_x = mat3\n    (\n        1.0, 0.0, 0.0,\n        0.0, cos(rotate.x), -sin(rotate.x),\n        0.0, sin(rotate.x), cos(rotate.x)\n    );\n    \n    mat3 transform = transform_z * transform_y * transform_x;\n    \n    camera *= transform;\n    ray *= transform;\n    \n    ray = normalize(ray);\n}\n","name":"Common","description":"","type":"common"}]}