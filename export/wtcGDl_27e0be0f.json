{"ver":"0.1","info":{"id":"wtcGDl","date":"1577921864","viewed":179,"name":"2K20","username":"Gaxil","description":"Just a first quick shader to celebrate 2020 ... Happy new year to all shader fans (and to the others too, you just don't know what you're missing)","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["tunnel","raymarch","kifs","celebration"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SURF_DIST 0.001\n#define MAX_STEPS 64\n\nfloat PI = 3.1415926535897932384626433832795;\n\n// Many functions are directly taken from IQ's site : https://iquilezles.org/articles/distfunctions\n// So many thanks for this, IQ\n\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nmat2x2 rot(float angle)\n{\n    return mat2x2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nfloat sdTorus( vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r, float angle )\n{\n  p.xy = p.xy*rot(angle);\n  \n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb, float angle)\n{\n  p.xy = p.xy*rot(angle);\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat sdLine(vec2 pos, float r)\n{\n    return length(pos)-r;\n}\n\nfloat sdZero(vec3 p)\n{\n  return sdLink(p+ vec3(0,0.125,0), 1.125, 1.0, 0.5);  \n}\n\nfloat sdTwo(vec3 p)\n{\n  float dist;\n  float an = 1.57*1.25;\n  vec2 c = vec2(sin(an),cos(an));\n  dist = sdCappedTorus(p + vec3(0,-1.45,0), c, 1.0, 0.5, 0.39);  \n  dist = opSmoothUnion(dist, sdVerticalCapsule(p + vec3(1,1.75,0), 2.5, 0.5, 1.57),0.05);\n  dist = opSmoothUnion(dist, sdVerticalCapsule(p + vec3(1,1,0), 2.25, 0.5, 1.57*0.5),0.05);\n  dist = opSmoothUnion(dist, sdVerticalCapsule(p + vec3(1,1.75,0.0), 0.5, 0.5, 0.0),0.05);\n  return dist;  \n}\n\nfloat sd2020(vec3 p)\n{\n  float dist;\n  \n  dist = sdZero(p-vec3(5.0, 0.5, 0.));\n  dist = min(dist, sdZero(p-vec3(-1.55, 0.5, 0.)));\n  dist = min(dist, sdTwo(p-vec3(1.55, 0., 0.)));\n  dist = min(dist, sdTwo(p-vec3(-5.0, 0., 0.)));\n  \n  return dist;\n}\n\n// Thanks to Antoine Zanuttini for this : https://www.youtube.com/channel/UCdiiD1ukw39XTRj9h6LKCeQ/videos\nfloat sdKIFF(vec3 pos)\n{\n  vec3 oPos = pos;\n  \n  float dist = 100000.;\n\n  pos.xz = pos.xz * rot(iTime*0.2);\n  pos.xy = pos.xy * rot(iTime*0.3);\n\n  mat3x3 rMat = mat3x3(1,0,0, 0,1,0, 0,0,1);\n  \n \n  float scale = 2.0;\n  float rScale = 5.0;\n  for(int i=0;i<8;i++)\n  {\n    pos = abs(pos);\n    pos -= vec3(1.5,1.5,1.5)*scale;\n    pos.xz = pos.xz * rot(1.0+iTime*0.1*rScale);\n    pos.zy = pos.zy * rot(2.0+iTime*0.15*rScale);\n    scale *= 0.5;\n    rScale -= 2.5;\n  }\n  \n  dist = min(dist, sdSphere(pos, 2.5 * scale));\n  return dist; \n}\n\n// From http://www.timotheegroleau.com/Flash/experiments/easing_function_generator.htm\nfloat elastic(float t)\n{\n  float ts= t*t;\n  float tc = ts*t;\n\treturn (56.*tc*ts + -175.*ts*ts + 200.*tc + -100.*ts + 20.*t);\n}\n\nfloat getDist2020(vec3 pos)\n{ \n  float dist = 0.0; \n  \n  float angle = atan(pos.x, pos.y);\n  vec3 oPos = pos;\n  \n  pos.xy = rot(sin(iTime*.021)*0.1) * pos.xy;\n  pos.xz = rot(sin(iTime*0.121)*0.25) * pos.xz;\n  \n  float delta = elastic(min(fract(iTime*0.1)*2., 1.))*10.;\n  \n  float tDist = sd2020(pos-vec3(0.0, 0.0, 11.-delta));\n  dist = tDist;\n  dist = opSmoothSubtraction(tDist-.5, sdKIFF(pos-vec3(0.0, 0.0, 8.)), .25);\n  dist = min(dist, tDist);\n\n\n  return dist;\n}\n\nvec3 calcNormal2020(vec3 pos)\n{\n  vec2 delta = vec2(-1, 1) * 0.01f;\n\n  return normalize(\n    delta.xyy * getDist2020(pos + delta.xyy) +\n    delta.yyx * getDist2020(pos + delta.yyx) +\n    delta.yxy * getDist2020(pos + delta.yxy) +\n    delta.xxx * getDist2020(pos + delta.xxx)); \n}\n\nvec4 getColor2020(vec3 ro, vec3 rd, out vec3 emissive)\n{\n  float d0 = 2.0f;\n  vec3 p = vec3(0.0);\n  float dS = 0.0f;\n  float acc = 0.0f;\n  float glow = 0.0f;\n  \n  for(int i=0;i<MAX_STEPS;i++)\n  {\n    p = ro + rd * d0;\n    dS = abs(getDist2020(p));\n    d0 += dS*0.75;\n    if (dS<1000.)\n      glow += 0.001/(0.01+dS*0.1);\n    \n    if (dS<SURF_DIST) break;   \n  }\n\n  vec4 rm = vec4(p, dS); \n  \n  vec4 color;\n  \n\n  if (dS < SURF_DIST)\n  {\n    // Object hit\n    color = vec4(1.0);\n    \n    vec3 nrm = calcNormal2020(rm.xyz);\n    vec3 light = vec3(0, 3, -5.);\n    vec3 dirLight = light - rm.xyz;\n    \n    float intensity = clamp(dot(nrm, normalize(dirLight)), 0., 1.);\n    intensity *= 8./dot(dirLight, dirLight);\n    intensity += 0.005;\n  \n    glow *= 0.1;\n    \n    color.rgb *= intensity;  \n  }\n  else \n  {\n    color = vec4(0);\n  }\n  \n  emissive = glow*vec3(1.0, 0.35, 0.1);\n    \n  return color;\n  \n}\n\nvec3 radial(vec3 p, float rep, float off)\n{\n  vec2 rp = vec2(atan(p.y,p.x)/(2.0*PI), length(p.xy));\n  rp.x=(fract(rp.x*rep-0.5+off)-0.5)/rep;\n  rp.x *= 2.0*PI;\n  return vec3(cos(rp.x)*rp.y,sin(rp.x)*rp.y,p.z);\n}\n\nfloat getDistTunnel(vec3 pos)\n{ \n  float dist = 0.0; \n  pos.xy *= rot(pos.z*0.3 + iTime + sin(pos.z*1.3 +iTime*0.3));\n  pos = radial(pos, 3., 0.);\n  dist = sdLine(pos.xy + vec2(-2.+sin(pos.z*10. - iTime*5.)*0.25,0.), 0.1);\n  \n  return dist;\n}\n\nvec3 calcNormalTunnel(vec3 pos)\n{\n  vec2 delta = vec2(-1, 1) * 0.01f;\n\n  return normalize(\n    delta.xyy * getDistTunnel(pos + delta.xyy) +\n    delta.yyx * getDistTunnel(pos + delta.yyx) +\n    delta.yxy * getDistTunnel(pos + delta.yxy) +\n    delta.xxx * getDistTunnel(pos + delta.xxx)); \n}\n\nvec4 getColorTunnel(vec3 ro, vec3 rd, out vec3 Emissive)\n{\n  float d0 = 2.0f;\n  vec3 p = vec3(0.0);\n  float dS = 0.0f;\n  float acc = 0.0f;\n  float glow = 0.0f;\n  Emissive =vec3(0.);\n  \n  for(int i=0;i<MAX_STEPS;i++)\n  {\n    p = ro + rd * d0;\n    dS = abs(getDistTunnel(p));\n    d0 += dS*0.1;\n    if (dS<1000.)\n      glow += 0.005/(0.1+dS);\n    \n    if (dS<SURF_DIST) break;   \n  }\n\n  vec4 rm = vec4(p, dS); \n  \n  vec4 color;\n  \n\n  if (dS < SURF_DIST)\n  {\n    color = vec4(1.0);\n   \n    vec3 nrm = calcNormalTunnel(rm.xyz);\n    vec3 light = vec3(-3, 2, -4);\n    vec3 dirLight = light - rm.xyz;\n    \n    float intensity = clamp(dot(nrm, normalize(dirLight)), 0., 1.);\n    intensity *= 30./dot(dirLight, dirLight);\n    intensity += 0.005;\n  \n    color.rgb *= intensity;\n    color.a = 1.0;\n    Emissive += vec3(0.1, 0.35, 1.0);\n  }\n  else \n  {\n    color = vec4(0);\n  }\n\n  glow*=glow;\n  Emissive += glow*vec3(0.1, 0.35, 1.0);\n\n  return color;  \n}\n\n// From http://filmicworlds.com/blog/filmic-tonemapping-operators/\nvec3 tonemapFilmic(const vec3 color) \n{\n\tvec3 x = max(vec3(0.0), color - 0.004);\n\treturn (x * (6.2 * x + 0.5)) / (x * (6.2 * x + 1.7) + 0.06);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  vec3 ro = vec3(0.0, 0.0, -15);\n  vec3 rd = normalize(vec3(uv, 1.0));\n  \n  vec4 color = vec4(0.0); \n  vec3 colorEmissive2020;\n  vec4 color2020 = getColor2020(ro, rd, colorEmissive2020);\n  vec3 colorEmissiveTunnel;\n  vec4 colorTunnel = getColorTunnel(ro, rd, colorEmissiveTunnel);\n  color = colorTunnel; \n  color = mix(color, color2020, color2020.a); \n  color.rgb += colorEmissive2020+colorEmissiveTunnel*(1.0-color2020.a);\n\n  color.rgb = tonemapFilmic(color.rgb);\n  fragColor = color;    \n}","name":"Image","description":"","type":"image"}]}