{"ver":"0.1","info":{"id":"lsscz7","date":"1487808498","viewed":84,"name":"MIDTERM - PATTERN - 02/19/17","username":"KennySans37","description":"patt","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["pattern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592\n#define TWO_PI 6.2831\n#define pattern 0\n\n\nvec3 colorWhite = vec3(1.,1.,1.);\nvec3 colorBlack = vec3(0., 0., 0.);\nvec3 colorRed = vec3(1., 0., 0.);\nvec3 colorBlue = vec3(0., 0., 1.);\nvec3 colorYellow = vec3(1., 1., 0.);\nfloat border = 0.01;\n\nmat2 rotate2d(float angle);\nmat2 scale2d(float scale);\nfloat polygonStep(vec2 uv, float side, vec2 pos, float rot);\nfloat polygonSmoothStep(vec2 uv, float side, vec2 pos, float blur);\nvec3 circleStep(vec2 uv, vec2 pos, float rad);\nvec3 quadFloor(vec2 size, vec2 pos, float border, vec2 uv, vec3 color);\n\n#if pattern == 0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    fragColor = vec4(vec3(0.),1.0);\n}\n#elif pattern == 1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n    \n    \n    uv *= 10.;\n    vec2 tile = floor(uv);\n    uv = fract(uv);\n    vec2 pos = vec2(0.5 , 0.5);\n   \tuv -= pos;\n    uv *= rotate2d(floor(-iTime) * .2);\n    uv += pos;\n    \n    vec3 polygon = vec3(polygonSmoothStep(uv, 2.,pos , sin(iTime)));\n    \n    if(mod(tile.x, 2.) == mod(tile.y, 2.))\n    {\n        uv -= pos;\n    \tuv *= rotate2d(iTime * 10.);\n    \tuv += pos;\n        polygon = vec3(polygonSmoothStep(uv, 4.,pos , sin(iTime)));\n    }\n\t\n    \n    fragColor = vec4(polygon,1.0);\n}\n\n\n#elif pattern == 2\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n    \n    vec2 pos = vec2(0.5 , 0.5);\n    uv *= 4.;\n    vec2 tile = floor(uv);\n    uv = fract(uv);\n    \n    uv-= pos;\n    uv *= rotate2d(iTime);\n    \n    uv += pos;\n    vec2 pos2 = vec2(0.75 , 0.5);\n    vec2 pos3 = vec2(0.25 , 0.5);\n    vec2 pos4 = vec2(0.5 , 0.75);\n    vec2 pos5 = vec2(0.5 , 0.25);\n  \n    \n    vec3 polygon = vec3(polygonStep(uv, 6.,pos , PI/2.));\n    \n    polygon +=  vec3(polygonStep(uv, 3.,pos2 , PI)) ;\n    polygon +=  vec3(polygonStep(uv, 3.,pos3, 0.));\n    polygon +=  vec3(polygonStep(uv, 3.,pos4 , PI/2.));\n    polygon +=  vec3(polygonStep(uv, 3.,pos5, 270. * PI / 180.));\n    \n\t\n        uv-= pos;\n    \tuv *= rotate2d(180.-iTime * 10.);\n        uv +=pos;\n    \tpolygon +=  vec3(polygonStep(uv, 3.,pos2 , PI));\n    \tpolygon +=  vec3(polygonStep(uv, 3.,pos3, 0.));\n    \tpolygon +=  vec3(polygonStep(uv, 3.,pos4 , PI/2.));\n    \tpolygon +=  vec3(polygonStep(uv, 3.,pos5, 270. * PI / 180.));\n    \n    \n   \n\tfragColor = vec4(polygon,1.0);\n}\n\n#elif pattern == 3\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n    \n    \n    uv *= 10.;\n    vec2 tile = floor(uv);\n    uv = fract(uv);\n    vec2 pos = vec2(0.5 , 0.5);\n   \tuv -= pos;\n    uv *= rotate2d(iTime);\n    uv += pos;\n    \n    \n    vec3 polygon = vec3(polygonSmoothStep(uv, 3.,pos , 3.));\n    \n    if(mod(tile.x, 2.) == mod(tile.y, 2.))\n    {\n        uv -= pos;\n    \tuv *= rotate2d(PI);\n    \tuv += pos;\n        polygon = vec3(polygonSmoothStep(uv, 3.,pos , 3.));\n    }\n\t\n    \n    fragColor = vec4(polygon,1.0);\n}\n\n#elif pattern == 4\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n \t//uv.x *= ratio;\n    \n    \n    uv *= 10.;\n    vec2 tile = floor(uv);\n    uv = fract(uv);\n    vec2 pos = vec2(0.15 , 1.);\n    vec2 pos2 = vec2(1. , 0.15);\n \t//uv -= pos2;\n    //uv *= rotate2d(iTime);\n \t//uv += pos2;   \n    \n    vec3 polygon = vec3(circleStep(uv, pos, 0.5)) - vec3(circleStep(uv, pos, 0.4));\n    \n      \n    polygon += vec3(circleStep(uv, pos2, 0.5)) - vec3(circleStep(uv, pos2, 0.4));\n\t\n    \n    fragColor = vec4(polygon ,1.0);\n}\n\n#elif pattern == 5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    //uv.x *= ratio;\n    \n    vec2 pos = vec2(0.5 , 0.5);\n    uv *= 5.;\n    vec2 tile = floor(uv);\n    uv = fract(uv);\n    \n    uv-= pos;\n    uv *= rotate2d(iTime);\n    uv *= scale2d((sin(iTime) + 1. ) /2.);\n    uv += pos;\n    vec2 pos2 = vec2(0.15 , 1.);\n    vec2 pos3 = vec2(0.35 , 0.75);\n    vec2 pos4 = vec2(0.15 , .50);\n    vec2 pos5 = vec2(0.35 , 0.25);\n    vec2 pos6 = vec2(0.15 , 0.);\n    vec2 pos7 = vec2(0.35 , 0.75);\n    \n    vec2 pos8 = vec2(0.85 , 1.);\n    vec2 pos9 = vec2(0.65 , 0.75);\n    vec2 pos10 = vec2(0.85 , .50);\n    vec2 pos11 = vec2(0.65 , 0.25);\n    vec2 pos12 = vec2(0.85 , 0.);\n    vec2 pos13 = vec2(0.65 , 0.75);\n   \n  \n    \n    vec3 polygon = vec3(0.);\n    \n\n    polygon +=  vec3(polygonStep(uv, 3.,pos2 , PI));\n    polygon +=  vec3(polygonStep(uv, 3.,pos3, 0.));\n    polygon +=  vec3(polygonStep(uv, 3.,pos4 , PI));\n    polygon +=  vec3(polygonStep(uv, 3.,pos5, 0.));\n    polygon +=  vec3(polygonStep(uv, 3.,pos6 , PI));\n    polygon +=  vec3(polygonStep(uv, 3.,pos7, 0.));\n    \n    \n    polygon +=  vec3(polygonStep(uv, 3.,pos8, 0.));\n    polygon +=  vec3(polygonStep(uv, 3.,pos9 , PI));\n    polygon +=  vec3(polygonStep(uv, 3.,pos10, 0.));\n    polygon +=  vec3(polygonStep(uv, 3.,pos11 , PI));\n    polygon +=  vec3(polygonStep(uv, 3.,pos12, 0.));\n    polygon +=  vec3(polygonStep(uv, 3.,pos13 , PI));\n  \n   \n\tfragColor = vec4(polygon,1.0);\n}\n\n#elif pattern == 6\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n \tuv.x *= ratio;\n    \n    \n    uv *= 10.;\n    vec2 tile = floor(uv);\n    uv = fract(uv);\n    vec2 pos = vec2(fract(iTime +0.15 ), 1.);\n    vec2 pos2 = vec2(fract(iTime +1. ), 0.15);\n    vec2 pos3 = vec2(fract(iTime +0.15) , 0.15);\n    vec2 pos4 = vec2(fract(iTime +1. ), 1.);\n \n    \n    \n    vec3 polygon = vec3(circleStep(uv, pos, 0.5)) - vec3(circleStep(uv, pos, 0.4));\n    polygon += vec3(circleStep(uv, pos2, 0.5)) - vec3(circleStep(uv, pos2, 0.4));\n    polygon += vec3(circleStep(uv, pos3, 0.5)) - vec3(circleStep(uv, pos3, 0.4));\n    polygon += vec3(circleStep(uv, pos4, 0.5)) - vec3(circleStep(uv, pos4, 0.4));\n\t\n    \n    fragColor = vec4(polygon,1.0);\n}\n\n#elif pattern == 7\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n \t//uv.x *= ratio;\n    \n    \n    uv *= 10.;\n    vec2 tile = floor(uv);\n    uv = fract(uv);\n    vec2 pos = vec2(0.5, 1.25);\n    vec2 pos2 = vec2(0.5, -0.25);\n    vec2 pos3 = vec2(1.25 , 0.5);\n    vec2 pos4 = vec2(-0.25, 0.5);\n \n    \n    \n    vec3 polygon = vec3(circleStep(uv, pos, 0.5));// - vec3(circleStep(uv, pos, 0.4));\n    polygon += vec3(circleStep(uv, pos2, 0.5));// - vec3(circleStep(uv, pos2, 0.4));\n    polygon += vec3(circleStep(uv, pos3, 0.5));// - vec3(circleStep(uv, pos3, 0.4));\n    polygon += vec3(circleStep(uv, pos4, 0.5));// - vec3(circleStep(uv, pos4, 0.4));\n\t\n    \n    fragColor = vec4(polygon * (abs(sin(iTime))),1.0);\n}\n\n#elif pattern == 8\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n \tuv.x *= ratio;\n    \n    \n    uv *= 5.;\n    vec2 tile = floor(uv);\n    uv = fract(uv);\n    vec2 pos = vec2(0.5, 0.5);\n   \n \n    \n    \n    vec3 polygon = vec3(polygonStep(uv, 4., pos, PI / 4.));\n    uv -= pos;\n    uv *= scale2d(sin(iTime) * 4.);\n    uv+=pos;\n    polygon += vec3(polygonStep(uv, 2., pos, PI/2.));\n    polygon += vec3(polygonStep(uv, 2., pos, PI));\n    \n    fragColor = vec4(polygon,1.0);\n}\n\n#elif pattern == 9\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n \tuv.x *= ratio;\n    \n    \n    uv *= 5.;\n    vec2 tile = floor(uv);\n    uv = fract(uv);\n    vec2 pos = vec2(0.5, 0.5);\n   \n \n    uv -= pos;\n    uv *= scale2d(0.27);\n    uv *= rotate2d(floor(iTime));\n    uv +=pos;\n    \n    vec3 polygon = vec3(polygonStep(uv, 4., pos, PI / 4.));\n    polygon += vec3(polygonStep(uv, 4., pos, PI ));\n    \n    uv -= pos;\n    uv *= scale2d(1.5);\n    uv *= rotate2d(floor(-iTime) * 2.);\n    uv +=pos;\n    \n    \n    polygon -= vec3(polygonStep(uv, 4., pos, PI / 4.));\n    polygon -= vec3(polygonStep(uv, 4., pos, PI ));\n\t\n    fragColor = vec4(polygon,1.0);\n}\n\n#elif pattern == 10\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n \tuv.x *= ratio;\n    \n    \n    uv *= 5.;\n    vec2 tile = floor(uv);\n    uv = fract(uv);\n    vec2 pos = vec2(0.5, 0.5);\n   \n \n    uv -= pos;\n    uv *= scale2d(0.22);\n    uv *= rotate2d(iTime);\n    uv +=pos;\n    \n    vec3 polygon = vec3(polygonStep(uv, 4., pos, PI / 8.));\n    polygon += vec3(polygonStep(uv, 4., pos, PI * 3. /8.));\n    \n    uv -= pos;\n    uv *= scale2d(1.05);\n    uv *= rotate2d(-iTime * 2.);\n    uv +=pos;\n    \n    \n    polygon -= vec3(polygonStep(uv, 4., pos, PI / 8.));\n    polygon -= vec3(polygonStep(uv, 4., pos, PI * 3./8.));\n\t\n    fragColor = vec4(polygon,1.0);\n}\n\n#elif pattern == 11\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 Size = vec2(iResolution.x/ 8.0, iResolution.y / 8.0);\n    \n    vec2 Pos = floor(fragCoord / Size);\n    \n    vec3 check = vec3(mod(Pos.x + Pos.y, 2.0));\n    \n    fragColor = vec4(check, 1.0);\n}\n\n#elif pattern == 12\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n \n    vec2 size = vec2(0.11, 0.4);\n\tvec2 pos = vec2(0., 0.);\n    vec3 quad = quadFloor(size, pos, border, uv, colorYellow);\n    \n    size = vec2(0.22, 0.52);\n\tpos = vec2(0.13, 0.);\n    quad += quadFloor(size, pos, border, uv, colorWhite);\n    \n    size = vec2(0.5025, 0.25);\n\tpos = vec2(0.37, 0.);\n    quad += quadFloor(size, pos, border, uv, colorWhite);\n    \n    size = vec2(0.1675, 0.25);\n\tpos = vec2(0.89, 0.);\n    quad += quadFloor(size, pos, border, uv, colorBlue);\n    \n    size = vec2(0.67, 0.25);\n\tpos = vec2(0.37, 0.27);\n    quad += quadFloor(size, pos, border, uv, colorWhite);\n    \n    size = vec2(0.35, 0.35);\n\tpos = vec2(0., 0.55);\n    quad += quadFloor(size, pos, border, uv, colorWhite);\n    \n    size = vec2(0.7, 0.7);\n\tpos = vec2(0.37, 0.55);\n    quad += quadFloor(size, pos, border, uv, colorRed);\n    \n    \n\tfragColor = vec4(quad,1.0);\n}\n\n#elif pattern == 13\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 colorA = vec3(0.0, 0.0, 1.0);\n    vec3 colorB = vec3(1.,1.,1.);\n    vec3 colorC = vec3(1.,0.,0.);\n    \n    vec3 firstSegment = ((step(0.0, uv.x)) - (step(0.33, uv.x)))*colorA;\n    vec3 secondSegment= ((step(0.33, uv.x)) - (step(0.66, uv.x)))*colorB;\n    vec3 thirdSegment = ((step(0.66, uv.x)) - (step(1., uv.x)))*colorC;\n\tfragColor = vec4((firstSegment + secondSegment + thirdSegment),1.0);\n}\n#endif\n\n\nmat2 rotate2d(float angle)\n{\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nmat2 scale2d(float scale)\n{\n    return mat2(scale, 0.0, 0.0, scale);\n}\n\nfloat polygonStep(vec2 uv, float side, vec2 pos, float rot)\n{   \n    uv -= pos;\n    float a=atan(uv.y, uv.x) + rot;\n    float b=TWO_PI/side;\n    float edge = cos(floor(.5+a/b)*b-a)*length(uv);\n    float polygon = step(edge, 0.1);\n    \n    return polygon;\n}\n\nfloat polygonSmoothStep(vec2 uv, float side, vec2 pos, float blur)\n{   \n    uv -= pos;\n    float a=atan(uv.y, uv.x);\n    float b=TWO_PI/side;\n    float edge = cos(floor(.5+a/b)*b-a)*length(uv);\n    float polygon = smoothstep(edge - (blur * 0.5),edge + (blur * 0.5), 0.1);\n    \n    return polygon;\n}\n\nvec3 circleStep(vec2 uv, vec2 pos, float rad)\n{\n    float ratio = iResolution.x / iResolution.y;\n    \n    float x = step(distance(uv, pos) , rad );\n\n    return vec3( x );\n}\n\nvec3 quadFloor(vec2 size, vec2 pos, float border, vec2 uv, vec3 color)\n{\n    float left = pos.x; \n    float right = pos.x + size.x;\n    float top = pos.y + size.y;\n    float bottom = pos.y;\n    \n    vec3 quadx = (min(floor(uv.x/left), 1.) - min(floor(uv.x/ right) ,1.)) * color;\n    vec3 quady = (min(floor(uv.y/bottom), 1.) - min(floor(uv.y/ top) ,1.)) * color;\n    \n   \t//vec3 quadw = (min(floor(uv.x/(left + (border))), 1.) - min(floor(uv.x/ (right - (border))) ,1.)) * color;\n    //vec3 quadz = (min(floor(uv.y/(bottom+ (border))), 1.) - min(floor(uv.y/ (top- (border))) ,1.)) * color;\n    \n    return (quadx * quady); // (quadw * quadz));\n}\n\n","name":"Image","description":"","type":"image"}]}