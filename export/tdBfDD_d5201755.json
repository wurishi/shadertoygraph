{"ver":"0.1","info":{"id":"tdBfDD","date":"1590070873","viewed":279,"name":"Blur Bilateral Gauss","username":"spalmer","description":"simply blurs an image or video the most efficient way I know how without involving mipmaps.\nIf nothing shows, try picking video for iChannel2 in BufferA","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["blur","filter","gauss","bilateral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BufA iChannel0\n\nfloat Dither(vec2 p) // lame hash\n{\n    return sin(dot(p, vec2(1./23., 1./23./17.)) * 23456.);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    // horizontal blur from Buffer A to final Image\n    vec2 ra = iResolution.xy\n    , rs = iChannelResolution[0].xy\n    , fc = fragCoord/ra;\n    vec3 col  = bilateral(BufA\n        , fc\n        , vec2(1,0)\n        , blursize * rs.y / rs.x\n        , nsamples\n        , bgCol\n        , 1. // was left in linear gamma\n        ).rgb;\n    // gamma correct back to approximately sRGB gamut for output\n    col = pow(col, vec3(1./useGamma));\n    col += .5/256. * Dither(fragCoord);\n    fragColor = vec4(col, 1);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define Source iChannel2\n\n#define SRes iChannelResolution[2]\n\n\n\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    // vertical blur from source to Buffer A\n    vec2 ra = iResolution.xy        \n    , rs = SRes.xy;\n    float ar = ra.x * rs.y / ra.y / rs.x;\n    vec2 fc = (fragCoord - .5*ra) * vec2(.5*ar,1.) / ra.y + .5;\n    vec3 col = bilateral(Source\n        , fc\n        , vec2(0,1)\n        , blursize\n        , nsamples\n        , bgCol\n        , useGamma\n        ).rgb;\n    fragColor = vec4(col, 1);\n}\n\n// carefully unstretch video to preserve aspect ratio\n// leave intermediary in linear gamma\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float blursize = .12; //.2; //.1; //.3; //.05; //\nconst int nsamples = 31; //63; //47; //15; //\n\nconst float useGamma = 2.2; //1.; // sRGB-ish gamma in lieu of proper sRGB encoding/decoding is good enough\n\nconst vec4 bgCol = vec4(.5,.5,.5,1);\n\n//  is q in the 0..1 rect?\nbool in01(vec2 q)\n{\n    return all(greaterThanEqual(q, vec2(0))) && all(lessThan(q, vec2(1)));\n}\n\nvec4 gtex(sampler2D ch, vec2 uv, float gamma)\n{\n    vec4 c = texture(ch, uv);\n    return vec4(pow(c.rgb, vec3(gamma)), c.a);\n}\n\n// see http://wikipedia.org/wiki/Bilateral_filter\n// half of a seperable gaussian filter\n// bilateral filter blur of image\n// ch is which texture channel to use\n// uv is texcoord of query\n// v should be the axis the bilateral applies along (usually vec2(1,0) or vec2(0,1))\n// w is blur width\n// n is half number of taps (not counting center tap)\nvec4 bilateral(sampler2D ch, vec2 uv, vec2 v, float w, int n, vec4 bg, float gamma)\n{\n    vec4 t = gtex(ch, uv, gamma);\n    float z = in01(uv) ? 1. : 0.;\n    t = mix(bg, t, z); // background\n    for (int i = n; i > 0; --i) {\n        float f = float(i)/float(n);\n        // http://wikipedia.org/wiki/Gaussian_function\n        // simple gaussian exponential falloff using exp2 for speed\n        float s = exp2(-8. * f * f);\n        vec2 m = f * w * v;\n        if (in01(uv + m)) {\n    \t    t += gtex(ch, uv + m, gamma) * s; z += s; \n        }\n        if (in01(uv - m)) {\n\t        t += gtex(ch, uv - m, gamma) * s; z += s; \n        }\n    }\n\t// total number of taps per pixel per frame is nsamples*2 + 1 \n    // not counting the hw bilinear filtering, but it's cached, \n    // works out about the same anyway.\n    return t / max(z, 1.);\n}\n\n// NOTE doing vertical first works better for caching\n// if original source is lower resolution than intermediate buffers\n","name":"Common","description":"","type":"common"}]}