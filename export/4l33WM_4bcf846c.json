{"ver":"0.1","info":{"id":"4l33WM","date":"1595944848","viewed":106,"name":"edgy archy","username":"Daedelus","description":"making old shaders public~","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["edgyarchy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void pR(inout vec2 p, float a)\n{\n    float sa = sin(a), ca = cos(a);\n        p *= mat2(ca, sa, -sa, ca);\n}\n\nfloat grid(vec3 p, float r, float r2)\n{\n    float s = 2.0;\n    vec3 c = floor(p * s + 0.5);\n    p = (fract(p * s + 0.5) - 0.5) / s;\n    float rand = texture(iChannel0, c.xz * 0.011).x;\n    return length(p) - (sin(iTime) * r + r + rand * r2) / s;\n}\n\nfloat fOpPipe(float a, float b, float r)\n{\n    return length(vec2(a, b)) - r;\n}\n\nfloat perlin2(vec2 p)\n{\n    float n = texture(iChannel0, p).x;\n    n += texture(iChannel0, p * 2.0).x * 0.5;\n    n += texture(iChannel0, p * 4.0).x * 0.25;\n    //n += texture(iChannel0, p * 8.0).x * 0.125;\n    //n += texture(iChannel0, p * 16.0).x * 0.0625;\n    return n / 1.9375;\n}\n\nfloat map(vec3 p, out float m)\n{\n    float terrain = p.y - 0.5 + perlin2(p.xz * 0.002) * 1.5 + perlin2(p.xz * 0.05) * 0.05;\n    \n    float solid = grid(p, 0.1, 0.9);\n    float wire = grid(p, 0.1, 0.7);\n    if(fract(p.z * 0.25 / 3.14159265359 + 0.43) >= 0.5)\n        p.x = -p.x;\n    p.x -= cos(p.z);\n    p.y = abs(p.y + sin(p.z));\n    float tubes = length(p.xy) - 0.3;\n    tubes = min(max(tubes, -solid), fOpPipe(tubes, wire, 0.015));\n    m = 1.0;\n    if(tubes < terrain)\n\t    m = 0.0;\n    return min(terrain, tubes);\n}\n\nfloat map(vec3 p)\n{\n    float m;\n    return map(p, m);\n}\n\nvec3 normal(vec3 p, float s)\n{\n    vec2 e = vec2(0.005, 0.0);\n    return normalize(vec3(map(p + e.xyy), map(p + e.yxy), map(p + e.yyx)) - s);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    float m, s, td = 0.1;\n    vec3 is, c, n, o = vec3(0.0, 0.25, 4.0 * iTime), d = vec3(0.0, 0.0, 1.0);\n    pR(d.xz, uv.x * 0.3);\n    pR(d.yz, uv.y * 0.3 - 0.06);\n    for(int i = 0 ; i < 200 ; ++i)\n    {\n        is = o + d * td;\n        s = map(is, m) * 0.5;\n        td += s;\n        if(s<=0.0||td>25.0)\n            break;\n    }\n    n = normal(is, s);\n    \n\tfragColor = vec4(\n        mix(\n        (m == 1.0 ? vec3(0.1, 0.05, 0.05) + vec3(0.1, 0.3, 0.0) * pow(n.y * 0.5 + 0.5, 12.0) : vec3(0.0)) * (n.y * 0.5 + 0.5)\n        + (m == 1.0 ? 0.1 : 1.0) * pow(max(0.0, reflect(d, n).y), 22.0)\n        + (m == 1.0 ? 0.5 : 0.4)  * vec3(0.1, 0.4, 0.45) * pow(clamp(1.0 + dot(d, n), 0.0, 1.0), 6.0)\n            , mix(vec3(1.0), vec3(0.2, 0.4, 0.7), pow(abs(d.y), 0.25))\n            , min(1.0, td / 25.0))\n        ,1.0);\n}\n","name":"Image","description":"","type":"image"}]}