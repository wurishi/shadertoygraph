{"ver":"0.1","info":{"id":"ddtGW7","date":"1677583034","viewed":35,"name":"bouncing_marble","username":"tve","description":"learning about 3d. I forgot which example inspired this, but this is largely based on an example of 3d rendering.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","simple"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 200.\n#define SURF_DIST .01\n\nfloat getDist(vec3 p){\n    return p.y;\n}\n\n\nvec2 rotate(vec2 p,float a){ //rot 2d\n\tfloat c = cos(a);\n    float s = sin(a);\n    return p*mat2(c,s,-s,c);\n}\n\n\nfloat ray_march(vec3 ro, vec3 rd){\n    float dO = 0.0;\n    \n    for (int i=0 ; i<MAX_STEPS; i++){\n        \n        vec3 p  = ro +  rd * dO ;\n        float dS = getDist(p);\n        dO += dS ;\n        \n        if(dO > MAX_DIST || dS <SURF_DIST) break;\n        \n    }\n    \n    return dO ;\n}\n\nvec3 get_sphere(vec2 uv, float sz) {\n\n    float d = abs(length( uv - vec2(-0.0+sin(iTime*1.5)*0.1, -0.25+abs(cos(iTime*8.0))*0.1) ));\n    if( d < 0.1 ) {\n      return vec3(0.5-d*d*152.0);\n    }\n    else {\n      return vec3(0.0);\n    }\n}\n\nvec3 get_cb(vec2 uv) {  //checker board\n    vec3 col = vec3(0);\n    float n = floor(uv.y*8.0);\n    if(mod(n,2.0)==0.0) {\n        col +=vec3( step(fract(uv.x*5.0),0.5) );\n    } else {\n        col +=vec3( step(fract(0.5+uv.x*5.0),0.5) );\n    }\n    col = mix(col, texture(iChannel0,uv,1.0).rgb, 0.5);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = (fragCoord - 0.5 * iResolution.xy) / iResolution.y ; \n    \n    float time = mod(iTime, 60.0);\n\n    vec3 la = vec3(0.0, 10.0, time*25.0);\n    \n\tvec3 ro = la + vec3(0.0,1.0, -331.25);\n    \n    la.xz = rotate(la.xz, cos(time*0.5)*0.4+0.5);    \n    \n    \n    float fov = 3.14159/3.;\n    vec3 forward = normalize(la - ro);\n    \n    vec3 right = normalize(vec3(forward.z, 0, -forward.x )); \n    vec3 up = cross(forward, right);\n\n    vec3 rd = normalize(forward + fov*u.x*right + fov*u.y*up);\n    \n    float d = ray_march(ro, rd) ;\n    \n    vec3 p = ro + rd * d ;\n    \n    vec3 col = get_cb(p.xz * 0.05).xyz;\n    \n    vec3 scol = get_sphere(u, 1.0);\n    \n    if (d>=MAX_DIST) col=texture(iChannel1, rd).xyz ;\n    \n    if( length(scol)==0.0 ) {\n        col = mix( vec3(0.3, 0.3, 0.0), col, 6.0*abs(rd.y)*abs(rd.y) );\n    }\n    else {\n        col += scol;\n        #if 1\n        col.rg *= vec2(15.0,6.2);\n        col *= 0.05;\n        #endif\n    }\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}