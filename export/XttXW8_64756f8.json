{"ver":"0.1","info":{"id":"XttXW8","date":"1479314762","viewed":567,"name":"Hypercube","username":"lara","description":"A very cheap method. :P","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","4d","tesseract","hypercube"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define S 128  // Steps\n#define P 0.01 // Precision\n#define D 5.   // Max distance\n\n#define T iTime+1.0\n//#define CROSSEYE 0.2\n\nstruct Ray { vec3 o, d; };\nstruct Camera { vec3 p, t; };\nstruct Hit { vec3 p; float t, d; };\n\nCamera _cam = Camera(vec3(0,0,-2.3),vec3(0));\n\nfloat sdLine(vec3 p, vec3 a, vec3 b)\n{\n\tvec3 ab = b-a, ap = p-a;\n\treturn length(ap-ab*clamp(dot(ap,ab)/dot(ab,ab),0.,1.))-0.025;\n}\n\nmat2 rot(float a)\n{\n    float c=cos(a),s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\n// Vertices\nconst vec3 lbf = vec3(-0.5,-0.5,-0.5);\nconst vec3 rbf = vec3( 0.5,-0.5,-0.5);\nconst vec3 lbb = vec3(-0.5,-0.5, 0.5);\nconst vec3 rbb = vec3( 0.5,-0.5, 0.5);\n\nconst vec3 ltf = vec3(-0.5, 0.5,-0.5);\nconst vec3 rtf = vec3( 0.5, 0.5,-0.5);\nconst vec3 ltb = vec3(-0.5, 0.5, 0.5);\nconst vec3 rtb = vec3( 0.5, 0.5, 0.5);\n\nvec3 lbfi,rbfi,lbbi,rbbi,ltfi,rtfi,ltbi,rtbi,lbf_lbfi,ltf_ltfi,lbb_lbbi,ltb_ltbi,rbb_lbb,rbf_lbf,rtf_ltf,rtb_ltb,lbfi_rbfi,lbbi_rbbi,ltfi_rtfi,ltbi_rtbi,rbbi_rbb,rbfi_rbf,rtfi_rtf,rtbi_rtb;\n\nfloat scene(vec3 p)\n{\n    float d = 1e10;\n\n\t// outside\n\td = min(d,sdLine(p,lbf_lbfi,rbf_lbf));\n\td = min(d,sdLine(p,lbb_lbbi,rbb_lbb));\n\td = min(d,sdLine(p,ltf_ltfi,rtf_ltf));\n\td = min(d,sdLine(p,ltb_ltbi,rtb_ltb));\n\n\td = min(d,sdLine(p,lbf_lbfi,lbb_lbbi));\n\td = min(d,sdLine(p,ltf_ltfi,ltb_ltbi));\n\td = min(d,sdLine(p,lbf_lbfi,ltf_ltfi));\n\td = min(d,sdLine(p,lbb_lbbi,ltb_ltbi));\n\n\td = min(d,sdLine(p,rbf_lbf,rbb_lbb));\n\td = min(d,sdLine(p,rtf_ltf,rtb_ltb));\n\td = min(d,sdLine(p,rbf_lbf,rtf_ltf));\n\td = min(d,sdLine(p,rbb_lbb,rtb_ltb));\n\n    // inside\n\td = min(d,sdLine(p,lbfi_rbfi,lbbi_rbbi));\n\td = min(d,sdLine(p,ltfi_rtfi,ltbi_rtbi));\n\td = min(d,sdLine(p,lbfi_rbfi,ltfi_rtfi));\n\td = min(d,sdLine(p,lbbi_rbbi,ltbi_rtbi));\n\n\td = min(d,sdLine(p,lbbi_rbbi,rbbi_rbb));\n\td = min(d,sdLine(p,lbfi_rbfi,rbfi_rbf));\n\td = min(d,sdLine(p,ltfi_rtfi,rtfi_rtf));\n\td = min(d,sdLine(p,ltbi_rtbi,rtbi_rtb));\n\n\td = min(d,sdLine(p,rbfi_rbf,rtfi_rtf));\n\td = min(d,sdLine(p,rbbi_rbb,rtbi_rtb));\n\td = min(d,sdLine(p,rbfi_rbf,rbbi_rbb));\n\td = min(d,sdLine(p,rtfi_rtf,rtbi_rtb));\n\n    // connections\n\td = min(d,sdLine(p,rtbi_rtb,rtb_ltb));\n\td = min(d,sdLine(p,rbfi_rbf,rbf_lbf));\n\td = min(d,sdLine(p,rbbi_rbb,rbb_lbb));\n\td = min(d,sdLine(p,rtfi_rtf,rtf_ltf));\n\t\n\td = min(d,sdLine(p,ltfi_rtfi,ltf_ltfi));\n\td = min(d,sdLine(p,ltbi_rtbi,ltb_ltbi));\n\td = min(d,sdLine(p,lbfi_rbfi,lbf_lbfi));\n\td = min(d,sdLine(p,lbbi_rbbi,lbb_lbbi));\n\t\n\treturn d;\n}\n\nvec3 getNormal(vec3 p)\n{\n\tvec2 e = vec2(P,0);\n\t\n\treturn normalize(vec3(\n\t\tscene(p+e.xyy)-scene(p-e.xyy),\n\t\tscene(p+e.yxy)-scene(p-e.yxy),\n\t\tscene(p+e.yyx)-scene(p-e.yyx)\n\t));\n}\n\nRay lookAt(Camera cam, vec2 c)\n{\n\tvec3 dir = normalize(cam.t-cam.p);\n\tvec3 right = normalize(cross(dir,vec3(0,1,0)));\n\tvec3 up = cross(right,dir);\n\n\treturn Ray(cam.p,normalize(right*c.x+up*c.y+dir));\n}\n\nHit march(Ray r)\n{\n\tfloat t = 0.0, d;\n\t\n\tfor(int i = 0; i < S; i++)\n\t{\n\t\td = scene(r.o+r.d*t);\n\t\tt += d;\n\t\t\n\t\tif (d < P || t > D) { break; }\n\t}\n\t\n\treturn Hit(r.o+r.d*t, t, d);\n}\n\n\nvec3 getColor(Hit h)\n{\t\n\tif (h.d > P) { return vec3(1); }\n\n\tvec3 n = getNormal(h.p);\n\tvec3 light = _cam.p+vec3(0,0.1,0);\n\t\n\tfloat d = 1e10;\n    float diff = 1.-max(dot(normalize(light-h.p),n),0.0);\n    float spec = pow(max(dot(normalize(reflect(h.p-_cam.p,n)),-normalize(h.p-light)),0.0),100.);\n\n\treturn (vec3(2,0,1)*diff+spec);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.xx;\n    \n\t#ifdef CROSSEYE\n    _cam.p.x += sign(uv.x)*CROSSEYE;\n    uv.x = mod(uv.x,1.)-0.5;\n    #endif\n    \n    _cam.p.zy *= rot(T);\n    _cam.p.xy *= rot(T);\n\n\tfloat t = mod(T,1.0);\n\tfloat s = (sin(T*0.5)+1.0)/2.0*0.15+0.15;\n\n\tlbfi = vec3(-0.5+s,-0.5+s,-0.5+s);\n\trbfi = vec3( 0.5-s,-0.5+s,-0.5+s);\n\tlbbi = vec3(-0.5+s,-0.5+s, 0.5-s);\n\trbbi = vec3( 0.5-s,-0.5+s, 0.5-s);\n\tltfi = vec3(-0.5+s, 0.5-s,-0.5+s);\n\trtfi = vec3( 0.5-s, 0.5-s,-0.5+s);\n\tltbi = vec3(-0.5+s, 0.5-s, 0.5-s);\n\trtbi = vec3( 0.5-s, 0.5-s, 0.5-s);\n    \n\tlbf_lbfi = mix(lbf,lbfi,t);\n\tltf_ltfi = mix(ltf,ltfi,t);\n\tlbb_lbbi = mix(lbb,lbbi,t);\n\tltb_ltbi = mix(ltb,ltbi,t);\n    \n\trbb_lbb = mix(rbb,lbb,t);\n\trbf_lbf = mix(rbf,lbf,t);\n\trtf_ltf = mix(rtf,ltf,t);\n\trtb_ltb = mix(rtb,ltb,t);\n    \n\tlbfi_rbfi = mix(lbfi,rbfi,t);\n\tlbbi_rbbi = mix(lbbi,rbbi,t);\n\tltfi_rtfi = mix(ltfi,rtfi,t);\n\tltbi_rtbi = mix(ltbi,rtbi,t);\n    \n\trbbi_rbb = mix(rbbi,rbb,t);\n\trbfi_rbf = mix(rbfi,rbf,t);\n\trtfi_rtf = mix(rtfi,rtf,t);\n\trtbi_rtb = mix(rtbi,rtb,t);\n\n\tvec3 f = 1.0-length(uv)*vec3(1.2,1.2,1)*0.5;\n\tfragColor = vec4(getColor(march(lookAt(_cam,uv)))*f,1.0);\n}","name":"Image","description":"","type":"image"}]}