{"ver":"0.1","info":{"id":"MsGGzW","date":"1453569904","viewed":827,"name":"LEGO Plasma Mosaic","username":"elfprince13","description":"Run your shader on a virtual \"Lego Mosaic\" screen, using the provided baseXY vector in place of the usual uv vector. Currently using a cool \"plasma\" pattern. Adjust yGridDivisor to change the resolution of the individual bricks.","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["procedural","framework","plasma","lego","mosaic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"const float pi = 3.1415926535897;\nconst float studRad = 0.3;\nconst float studHeight = 0.2;\nconst float studBorder = 0.03;\nconst vec2 halfXY = vec2(0.5, 0.5);\n\nconst float yGridDivisor = 20.;\n\nfloat yGrid;\nvec2 gridRes;\nvec2 scaledUv;\nvec2 gridC;\n\nfloat atan2(float y, float x)\n{\n    bool s = (abs(x) > abs(y));\n    return mix(pi/2.0 - atan(x,y), atan(y,x), s ? 1. : 0.);\n}\n\n// Photoshop/GIMP style multiplicative-ish style filter.\nfloat blend(float a, float b){\n    return (a < 0.5) ? 2.*a*b : (1. - 2.*(1.-a)*(1.-b));\n}\n\nvec4 blend(vec4 a, vec4 b){\n    return vec4(blend(a.x, b.x),\n                blend(a.y, b.y),\n                blend(a.z, b.z),\n                      1);\n}\n\n// Chunks up the screen into blocks.\nvec2 baseXY(vec2 uv) {\n\tscaledUv = uv*gridRes;\n    gridC = floor(scaledUv);\n    return (gridC / gridRes);\n}\n    \n// Essentially convolves a virtual pixel with the stud pattern.\nvec4 brickify(vec4 baseColor) {\n    vec2 subGrid = scaledUv - gridC - halfXY;\n    float rad = length(subGrid);\n    \n    float lightFactor = smoothstep(-studRad, studRad, subGrid.y);\n    \n    float pixelsPerGrid = iResolution.x / gridRes.x;\n\tvec4 borderColor = vec4(lightFactor, lightFactor, lightFactor, (abs(rad - (studRad - 0.5*studBorder)) <= 0.5*studBorder) ? 0.5*clamp(pixelsPerGrid*(0.5 * studBorder - abs(rad - (studRad - 0.5*studBorder))), 0., 1.) : 0.);\n    \n    \n    float rightFactor = 0.3;\n    vec4 rightColor = vec4(rightFactor, rightFactor, rightFactor, (0.5 - subGrid.x) <= studBorder ? 0.3 : 0.);\n    \n    float bottomFactor = 0.3;\n    vec4 bottomColor = vec4(bottomFactor, bottomFactor, bottomFactor, (0.5 + subGrid.y) <= studBorder ? 0.3 : 0.);\n    \n    vec4 fragColor = vec4(0.5,0.5,0.5,1);\n    fragColor = mix(fragColor, borderColor, borderColor.w);\n    \n    if(abs(subGrid.x) <= studRad - 1./pixelsPerGrid && subGrid.y <= 0.){\n        float angle = acos(subGrid.x / studRad);\n        float yInt = -sin(angle) * studRad;\n        \n        float vFac = 0.5*smoothstep(0., studHeight, (yInt - subGrid.y) * 1.5*exp(-pow(subGrid.x,2.))/**/);\n        float sFac = vFac;\n        vec4 shadowColor = vec4(sFac, sFac, sFac, subGrid.y <= yInt ? 1. : clamp(1. - pixelsPerGrid*abs(rad - studRad), 0., 1.));\n        fragColor = mix(fragColor, shadowColor, 0.5*shadowColor.w);\n    }\n    \n    \n    fragColor = mix(fragColor, rightColor, rightColor.w);\n    fragColor = mix(fragColor, bottomColor, bottomColor.w);\n    \n    fragColor = blend(baseColor, fragColor);\n    \n    return fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    \n    yGrid = iResolution.y / yGridDivisor;\n\tgridRes = vec2(iResolution.x/iResolution.y * yGrid,yGrid);\n   \n    vec2 uv = /**/baseXY/**/(fragCoord.xy / iResolution.xy);\n    float time = iTime * 5.;\n    \n    uv = uv - halfXY;\n    uv += vec2(sin(time / 47.), cos(time / 37.));\n    \n    float theta = atan2(uv.x, uv.y);\n    float r = length(uv);\n    \n    vec2 rg = vec2(0.5 + 0.5*cos(theta+time / 37. + sin(7.*r + time / 5.)), 0.5 + 0.5*sin(theta+time / 13. + cos(11.*r + time / 17.)));\n    \n    vec2 uvN = sqrt(abs(uv - rg));\n    float thetaN = atan2(uvN.y, uvN.x);\n    float rN = length(uvN);\n    rg = rg*halfXY + halfXY * vec2(rg.x + pow(cos(thetaN + sin(rN + time / 5.) + time / 43.),2.), rg.y + pow(sin(thetaN + cos(rN + time / 11.) + time / 31.),2.));\n    rg *= vec2(abs(sin(rg.x * 17. / 5.)), abs(cos(rg.y * 23. / 3.)));\n    float thetaR = atan2(rg.x, rg.y);\n    float rgM = length(rg);\n    rg = halfXY * (rg + (halfXY+halfXY*vec2(sin(thetaR * rgM)*cos(thetaR * rgM),cos(thetaR + time / 47.)*sin(rgM))));\n    \n    rg = vec2(mix(sqrt(rg.x),rg.x*rg.x,clamp(rg.y - rg.x,0.,1.)),mix(sqrt(rg.y),rg.y*rg.y,clamp(rg.x - rg.y,0.,1.)));\n        \n    \n    vec4 baseColor = vec4(rg * rg/**/, 0.2,1.0);\n\tfragColor = /**/brickify/**/(baseColor);\n    \n}","name":"Image","description":"","type":"image"}]}