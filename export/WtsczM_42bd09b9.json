{"ver":"0.1","info":{"id":"WtsczM","date":"1591705540","viewed":149,"name":"randomwalk(using shader)","username":"darkfox","description":"random walk.\ninitialize: press SPACE KEY. ","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["randomwalk"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 p = fragCoord.xy / iResolution.xy;\n\n  // Time varying pixel color\n  vec4 col = texture(iChannel0, p);\n  vec4 rw = texture(iChannel1, p);\n  col = mix(col, rw, rw.a);\n\n  // Output to screen\n  fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// background.\n\n// for noise.\nconst vec3 r_vec_30 = vec3(127.1, 311.7, 251.9);\nconst vec3 r_vec_31 = vec3(269.5, 183.3, 314.3);\nconst vec3 r_vec_32 = vec3(419.2, 371.9, 218.4);\nconst vec3 u_100 = vec3(1.0, 0.0, 0.0);\nconst vec3 u_010 = vec3(0.0, 1.0, 0.0);\nconst vec3 u_001 = vec3(0.0, 0.0, 1.0);\nconst vec3 u_110 = vec3(1.0, 1.0, 0.0);\nconst vec3 u_101 = vec3(1.0, 0.0, 1.0);\nconst vec3 u_011 = vec3(0.0, 1.0, 1.0);\nconst vec3 u_111 = vec3(1.0, 1.0, 1.0);\nconst float r_coeff = 43758.5453123;\nconst int octaves = 6;\n// hsb to rgb.\nvec3 getRGB(float r, float g, float b){\n  vec3 c = vec3(r, g, b);\n  vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n    rgb = rgb * rgb * (3.0 - 2.0 * rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n// 3D random vector.(-1.0～1.0)\nvec3 random3(vec3 st){\n  vec3 v;\n  v.x = sin(dot(st, r_vec_30)) * r_coeff;\n  v.y = sin(dot(st, r_vec_31)) * r_coeff;\n  v.z = sin(dot(st, r_vec_32)) * r_coeff;\n  return -1.0 + 2.0 * fract(v); // -1.0～1.0\n}\n// simplex noise.\nfloat snoise3(vec3 st){\n  vec3 p = st + (st.x + st.y + st.z) / 3.0;\n  vec3 f = fract(p);\n  vec3 i = floor(p);\n  vec3 g0, g1, g2, g3;\n  vec4 wt;\n  g0 = i;\n  g3 = i + u_111;\n  if(f.x >= f.y && f.x >= f.z){\n    g1 = i + u_100;\n    g2 = i + (f.y >= f.z ? u_110 : u_101);\n    wt = (f.y >= f.z ? vec4(1.0 - f.x, f.x - f.y, f.y - f.z, f.z) : vec4(1.0 - f.x, f.x - f.z, f.z - f.y, f.y));\n  }else if(f.y >= f.x && f.y >= f.z){\n    g1 = i + u_010;\n    g2 = i + (f.x >= f.z ? u_110 : u_011);\n    wt = (f.x >= f.z ? vec4(1.0 - f.y, f.y - f.x, f.x - f.z, f.z) : vec4(1.0 - f.y, f.y - f.z, f.z - f.x, f.x));\n  }else{\n    g1 = i + u_001;\n    g2 = i + (f.x >= f.y ? u_101 : u_011);\n    wt = (f.x >= f.y ? vec4(1.0 - f.z, f.z - f.x, f.x - f.y, f.y) : vec4(1.0 - f.z, f.z - f.y, f.y - f.x, f.x));\n  }\n  float value = 0.0;\n  wt = wt * wt * wt * (wt * (wt * 6.0 - 15.0) + 10.0);\n  value += wt.x * dot(p - g0, random3(g0));\n  value += wt.y * dot(p - g1, random3(g1));\n  value += wt.z * dot(p - g2, random3(g2));\n  value += wt.w * dot(p - g3, random3(g3));\n  return value;\n}\n// fbm.\nfloat fbm(vec3 st){\n  float value = 0.0;\n  float amplitude = 0.5;\n  for(int i = 0; i < octaves; i++){\n    value += amplitude * snoise3(st);\n    st *= 2.0;\n    amplitude *= 0.5;\n  }\n  return value;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  float minLength = min(iResolution.x, iResolution.y);\n  vec2 p = fragCoord.xy / minLength;\n  p = (p + vec2(0.1, 0.18) * iTime) * 3.0;\n  float n = 0.5 + 0.5 * fbm(vec3(p, iTime * 0.2)); // ノイズ計算\n  vec3 fireColor = getRGB((n - 0.46) * 0.78, 1.0, 1.0);\n  vec3 skyColor = vec3(0.0);\n  vec3 col = skyColor + (fireColor - skyColor) * smoothstep(0.44, 0.56, n);\n  fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// random walk main.\n\n// key input.\n// SPACE KEY: initialize pattern.\n#define SPACE_KEY 32\n// constants.\nconst float pi = 3.14159;\nconst float gridsize = 10.0;\nconst float Lfactor = 0.1; // 1.0 / length.\n// random.\nconst vec2 r_vector = vec2(12.9898, 78.233);\nconst vec3 r3_vector = vec3(124.98, 782.33, 415.69);\nconst float r_coeff = 43758.5453123;\nfloat random(vec2 st){\n  return fract(sin(dot(st.xy, r_vector)) * r_coeff);\n}\nfloat random(vec3 st){\n  return fract(sin(dot(st, r3_vector)) * r_coeff);\n}\n// hsb to rgb.\nvec3 getRGB(float r, float g, float b){\n  vec3 c = vec3(r, g, b);\n  vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n    rgb = rgb * rgb * (3.0 - 2.0 * rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n// get cellColor. (centerColor)\nvec4 getColor(vec2 i){\n  vec2 pos = (i + vec2(0.5, 0.5)) * gridsize * vec2(1.0 / iResolution.x, 1.0 / iResolution.y);\n  if(min(pos.x, pos.y) < 0.0 || max(pos.x, pos.y) > 1.0){ return vec4(-1.0); }\n  //pos.y = pos.y;\n  return texture(iChannel0, pos);\n}\n// there is less than two vivid color cell.\nbool nonConflict(vec2 i){\n  vec2 dir = vec2(1.0, 0.0);\n  vec4 neighborColor;\n  int check = 0;\n  for(int s = 0; s < 4; s++){\n    neighborColor = getColor(i + dir);\n    dir = dir.yx * vec2(-1.0, 1.0);\n    if(neighborColor.a > 1.0 - (0.5 * Lfactor)){ check++; }\n    if(check > 1){ return false; }\n  }\n  return true;\n}\n// comingWalker.\nvec4 comingWalker(vec2 i){\n  // if conflict, remain current.\n  if(!nonConflict(i)){ return vec4(0.0); }\n\n  vec2 dir[4];\n  dir[0] = vec2(1.0, 0.0);\n  dir[1] = vec2(0.0, 1.0);\n  dir[2] = vec2(-1.0, 0.0);\n  dir[3] = vec2(0.0, -1.0);\n\n  float k = -1.0;\n  vec2 neighbor;\n  vec4 neighborColor;\n  for(int s = 0; s < 4; s++){\n    neighbor = i + dir[s];\n    neighborColor = getColor(neighbor);\n    if(neighborColor.a > 1.0 - (0.5 * Lfactor)){ k = float(s); break; }\n  }\n\n  // if no vivid color cell around, remain current.\n  if(k < 0.0){ return vec4(0.0); }\n\n  // direction inversion.\n  k = mod(k + 2.0, 4.0);\n\n  vec2 around;\n  vec4 aroundColor;\n  float n = 0.0;\n  float tmp[4];\n  for(int s = 0; s < 4; s++){ tmp[s] = 4.0; }\n  for(int s = 0; s < 4; s++){\n    around = neighbor + dir[s];\n    aroundColor = getColor(around);\n    // blanc and nonConflict.\n    if(aroundColor.a > -0.5 && aroundColor.a < 0.5 * Lfactor && nonConflict(around)){ n += 1.0; }\n    else{ tmp[s] = float(s); }\n  }\n\n  // define walking direction.\n  float walkerDir = floor(random(vec3(neighbor, iTime + mod(iDate.w, 61.0))) * n);\n  for(int s = 0; s < 4; s++){\n    if(walkerDir >= tmp[s]){ walkerDir += 1.0; }\n  }\n\n  // if direction is to current cell, copy this color.\n  if(walkerDir == k){ return neighborColor; }\n  return vec4(0.0);\n}\n// initialize.\nvec4 initialize(vec2 p){\n  vec2 i = floor(p);\n  for(float x = 2.0; x < iResolution.x; x += 6.0){\n    if(x * gridsize >= iResolution.x){ break; }\n    for(float y = 2.0; y < iResolution.y; y += 6.0){\n      if(y * gridsize >= iResolution.y){ break; }\n      if(i.x == x && i.y == y){\n        float rnd1 = random(vec3(x, y, mod(iDate.w, 53.0)));\n        float rnd2 = random(vec3(-y, x, mod(iDate.w, 37.0)));\n        return vec4(getRGB(0.55 + 0.25 * rnd1, 1.0 - 0.5 * rnd2, 1.0), 1.0);\n      }\n    }\n  }\n  return vec4(0.0);\n}\n// not blanc, or blanc and conflict.\nbool immovable(vec2 i){\n  vec2 dir = vec2(1.0, 0.0);\n  vec2 neighbor;\n  vec4 neighborColor;\n  for(int s = 0; s < 4; s++){\n    neighbor = i + dir;\n    neighborColor = getColor(neighbor);\n    dir = dir.yx * vec2(-1.0, 1.0);\n    if(neighborColor.a > -0.5 && neighborColor.a < 0.5 * Lfactor && nonConflict(neighbor)){ return false; }\n  }\n  return true;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  float minLength = min(iResolution.x, iResolution.y);\n  vec2 p = fragCoord.xy / minLength;\n  float scale = minLength / gridsize;\n  p *= scale;\n  vec4 col;\n\n  // initialize.\n  if(floor(iTime * 60.0) == 1.0 || bool(texelFetch(iChannel1, ivec2(SPACE_KEY, 1), 0).x)){\n    col = initialize(p);\n    fragColor = col;\n    return;\n  }\n\n  vec2 i = floor(p);\n  vec4 cur = getColor(i);\n  // \"cur\" is current cell color.\n  // validate with cur.a value.\n\n  if(cur.a > 1.0 - (0.5 * Lfactor)){\n    // if cur is vivid color.\n    if(immovable(i)){ col = cur; }else{ col = cur - vec4(vec3(0.0), Lfactor); }\n  }else if(cur.a > 1.5 * Lfactor){\n    col = cur - vec4(vec3(0.0), Lfactor);\n  }else if(cur.a > 0.5 * Lfactor){\n    col = vec4(0.0);\n  }else{\n    // if cur is blanc.\n    // if walker is coming, change to vivid color.\n    col = comingWalker(i);\n  }\n  fragColor = col;\n}","name":"Buffer B","description":"","type":"buffer"}]}