{"ver":"0.1","info":{"id":"MfX3zf","date":"1703470072","viewed":61,"name":"Mars Ingenuity  Morning Flight","username":"DwayneBrah","description":"Actual footage from the helicopter thingy called \"Ingenuity\" they chucked at Mars - A planet that has been proven to be entirely populated by robots. (As far as we know...)\n\nCrazy good footage from something they got from AliExpress for $27.95 (inc del)","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","terrain","planet","landscape","shadows","alien","mars","flight","flying"],"hasliked":0,"parentid":"XffGz4","parentname":"PROPER WORKING SHADOW!"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Super simple raymarching example. Created by Reinder Nijhoff 2017\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n// @reindernijhoff\n// \n// https://www.shadertoy.com/view/4dSBz3\n\nvec3 material_color;\n\nfloat t_height;    \nfloat terrain_height(vec3 p) {\n    \n    t_height = 0.0;\n    t_height += terrain(p.xz);\n    \n    t_height *= terrain_depth;\n    \n    return(t_height);\n    \n}\n\n\n\nfloat obj_land(vec3 p, float d_last) {\n    \n    float height = terrain_height(p);\n    \n    \n    float d = min(d_last, p.y +(map_bottom + height));\n    \n    return(d);\n    \n}\n\n\n\nfloat map(vec3 p) {\n    \n    vec3 cam_pos = get_campos(iTime);\n    p.x -= cam_pos.x;\n    p.y -= cam_pos.y;\n    p.z -= cam_pos.z;\n    \n    p.y -= 1.6;\n    \n    float d = 1.0;\n    d = obj_land(p, d);\n    \n    return d;\n    \n}\n\n//\n// Calculate the normal by taking the central differences on the distance field.\n//\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n        e.xyy * map(p + e.xyy) +\n        e.yyx * map(p + e.yyx) +\n        e.yxy * map(p + e.yxy) +\n        e.xxx * map(p + e.xxx));\n}\n\n\nfloat shade( vec3 p, vec3 light ) {\n    \n    // FACE LIGHT SOURCE //\n\tvec3 toLight = light.xyz - p;\n    \n    // PROCESS LENGTH AND NORMALISE //\n\tfloat toLightLen = length( toLight );\n\ttoLight = normalize( toLight );\n    \n    // March the distance field until a surface is hit.\n    float h, t = 1.;\n    vec3 hit_point;\n    for (int i = 0; i < 128; i++) {\n        hit_point = p + toLight * t;\n        h = map(p + toLight * t);\n        t += h;\n        if (h < 0.01) return(0.0);\n    }\n    \n    \n    return(1.0);\n    \n}\n\nfloat lightsource(vec3 normal, vec3 p, vec4 position_intensity, bool shadow) {\n    \n    vec3 position = position_intensity.xyz;\n    float intensity = position_intensity.a;\n    \n    position -= get_campos(iTime);\n\n    \n    float diffuse = clamp(dot(normal, normalize(position - p)), 0.0, 1.0) * intensity;\n    if (shadow) {\n        float shade = shade( p, position );\n        diffuse *= shade;\n    };\n\n    \n    \n    return(diffuse);\n    \n    \n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv_mouse = iMouse.xy / iResolution.xy;\n    vec3 out_col = sky_backdrop(uv);\n    \n    vec2 cam_move = uv_mouse.xy;\n\n    vec3 ro = vec3(0.0, 0.6, -3.0);                           // ray origin\n\n    vec2 q = (fragCoord.xy - .5 * iResolution.xy ) / iResolution.y; // FROM CENTRE //\n    vec3 rd = normalize(vec3(q, 0.) - ro);             // ray direction for fragCoord.xy\n    \n    //rd.x += cam_move.x;\n    //ro.x += cam_move.x;\n\n    // March the distance field until a surface is hit.\n    float h, t = 0.2;\n    vec3 hit_point;\n    for (int i = 0; i < 128; i++) {\n        hit_point = ro + rd * t;\n        h = map(ro + rd * t);\n        t += h;\n        if (h < 0.01) break;\n    }\n    \n    float hit_distance = distance(ro, hit_point);\n    //float shade_amount = 0.0;\n    \n    if (rd.y < 0.0) {\n        out_col = COl_LAND;\n    } else {\n        out_col = COl_SKY * clamp(0.01/rd.y, 0.0, 3.0);\n    };\n    \n    \n    \n    if (h < 0.01) {\n    \n        vec3 p = ro + rd * t;\n    \n        float col_mixer = clamp(abs(t_height*3.0)-1.5, 0.0, 1.0);\n        material_color = mix(COl_LAND, COl_LAND_2, col_mixer);\n    \n\n        vec3 normal = calcNormal(p);\n        \n        float diffuse;\n        \n        \n        // SUNLIGHT //\n        diffuse += lightsource(normal, p, vec4(9000, 2300.0, 4000, 1.00), true);\n        \n        // ABOVE NONSHADOW \"NONPOINT\" LIGHT //\n        vec4 lightsource_2 = vec4(0, 1500.0, 0, 0.12);\n        diffuse += clamp(dot(normal, normalize(lightsource_2.xyz - p)), 0.0, 1.0) * lightsource_2.a;\n        \n        \n        \n        // DIMINISHING //\n        // dif *= (20.0*shade) / (dot(light - p, light - p));\n        \n        \n        // AMBIENT LIGHT //\n        diffuse += 0.02;\n        \n        \n        \n        float shaded = pow(diffuse, 0.88);     // Gamma correction\n        \n        vec3 col_shaded = material_color * shaded;\n        \n        \n        out_col = vec3(col_shaded);\n\n        \n    };\n    \n    // ATMOS //\n    /*\n    vec3 foging = COl_FOG*clamp(hit_distance*0.01, 0.0, 0.5);\n    if (rd.y > 0.0) {\n        foging *= 0.01/rd.y;\n    };\n    out_col += foging;\n    */\n    \n    fragColor = vec4(out_col, 1.0);\n\n\n    \n    \n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// MAFFS //\nfloat PI = 3.14159;\n\n\n\n// COLORS //\nvec3 COl_BLACK = vec3(0.2,  0.0,  0.0);\n\nvec3 COl_LAND =  vec3(0.4,  0.4,  0.4);\nvec3 COl_LAND_2 =  vec3(0.4,  0.3,  0.2);\nvec3 COl_SKY =   vec3(0.2,  0.7,  1.0);\nvec3 COl_FOG =   vec3(0.8,  0.8,  0.8);\n\n// TERRAIN SETTINGS //\nconst float START_HEIGHT = 0.4;\nconst float WEIGHT = 0.6;\nconst float MULT = 0.35;\n\nfloat fadeout = 0.3;\nfloat map_bottom = 2.0;\n\n// GEOMETRY //\nvec3 start_pos = vec3(1.0, 0, -3);\nfloat terrain_depth = 1.0;\nfloat terrain_xy_scale = 0.6;\n\n\n\nvec2 map_xy_pos(float iTime) {\n    \n    float progress = iTime*0.005;\n    \n    vec2 xy_pos = vec2(sin(progress), cos(progress*0.5 + 0.8));\n    \n    return(xy_pos*20.0);\n    \n}\n\n\n// CAMERA POSITOIN //\nvec3 get_campos(float iTime) {\n    \n    vec2 xy_pos = map_xy_pos(iTime);\n    \n    float z_pos = sin(iTime*0.5)*0.14;\n    \n    vec3 cam_pos = vec3(xy_pos.x, z_pos, xy_pos.y+8.0);\n    \n    return(start_pos+cam_pos);\n\n}\n\n// Simple 2d noise algorithm from http://shadertoy.wikia.com/wiki/Noise\n// I tweaked a few values\nfloat noise( vec2 p ) {\n\tvec2 f = fract(p);\n\tp = floor(p);\n\tfloat v = p.x+p.y*1000.0;\n\tvec4 r = vec4(v, v+1.0, v+1000.0, v+1001.0);\n\tr = fract(10000.0*sin(r*.001));\n\tf = f*f*(3.0-2.0*f);\n\treturn 2.0*(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y))-1.0;\n}\n\n\n\n//generate terrain using above noise algorithm\nfloat terrain( vec2 p) {\n\n    int freq = 12;\n\n    p *= terrain_xy_scale;\n\n\tfloat h = START_HEIGHT; // height, start at higher than zero so there's not too much snow/ice\n\tfloat w = WEIGHT; \t// weight\n\tfloat m = MULT; \t// multiplier\n    \n\tfor (int i = 0; i < freq; i++) {\n\t\th += w * noise((p * m)); // adjust height based on noise algorithm\n\t\tw *= 0.5;\n\t\tm *= 2.0;\n\t}\n    \n    // FLATTEN LAND?\n    float near_sea = clamp(1.0-abs(1.0-h), 0.0, 0.96);\n    h = near_sea + h*(0.66-(near_sea*near_sea));\n    \n\treturn h;\n    \n}\n\n\n\n\n\n\nvec3 sky_backdrop(vec2 uv) {\n    \n    vec3 backdrop = COl_SKY * (1.1-uv.y) * uv.y;\n\n    return(backdrop);\n    \n}","name":"Common","description":"","type":"common"}]}