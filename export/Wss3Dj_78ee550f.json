{"ver":"0.1","info":{"id":"Wss3Dj","date":"1547605640","viewed":299,"name":"Explorable Mandelbrot","username":"rmccampbell7","description":"Mandelbrot fractal with controllable zoom. Click or \"+\" key to zoom in, ctrl+click or \"-\" key to zoom out. Arrow keys to pan.\nEdit: added alternate color scheme, uncomment \"PRIDE\"","likes":8,"published":1,"flags":48,"usePreview":0,"tags":["fractal","mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Uncomment for fun colors\n// #define PRIDE\n#define PRINT\n#define SAMPLES 2\n#define MAXIT 2048\n#define RAD 8.\n#define COLOR_FREQ 0.5 // Change to 1.0 to get more interesting color patterns in deep zooms\n#define COLOR_SHIFT 0.5\n\nint mandelbrot(vec2 c, out vec2 z) {\n    z = c;\n    for (int i=1; i<=MAXIT; i++) {\n        if (dot(z, z) > RAD*RAD) return i;\n        //z = vec2(z.x*z.x - z.y*z.y, 2.*z.x*z.y) + c;\n        z = mat2(z, -z.y, z.x) * z + c;\n    }\n    return -1;\n}\n\n// https://en.wikipedia.org/wiki/Mandelbrot_set#Continuous_(smooth)_coloring\nfloat smooth_color(vec2 z, int n) {\n    //return float(n) - log2(log2(length(z)));\n    return float(n) - log2(.5*log2(dot(z, z)));\n}\n\n// Colormap is matplotlib.cm.twilight: https://matplotlib.org/tutorials/colors/colormaps.html\nvec3[] colors = vec3[] (\n    vec3(0.88575016, 0.85000925, 0.88797365),\n    vec3(0.76751109, 0.80980076, 0.83252817),\n    vec3(0.58301487, 0.70958888, 0.77925782),\n    vec3(0.44802471, 0.59238331, 0.75574176),\n    vec3(0.38407269, 0.46139019, 0.73094665),\n    vec3(0.36987980, 0.31638410, 0.67703755),\n    vec3(0.35060304, 0.16595130, 0.56147965),\n    vec3(0.27008638, 0.07548368, 0.36056376),\n    vec3(0.18488036, 0.07942573, 0.21307652),\n    vec3(0.29128515, 0.07489905, 0.25755102),\n    vec3(0.45383005, 0.11622184, 0.30970441),\n    vec3(0.59659918, 0.20721296, 0.31258523),\n    vec3(0.69806082, 0.33828976, 0.32207479),\n    vec3(0.76257334, 0.48718907, 0.38675335),\n    vec3(0.80029415, 0.64098213, 0.53730535),\n    vec3(0.84892246, 0.77992021, 0.74663719)\n);\n\nconst int N = colors.length();\n\nvec3 colormap(float v) {\n#ifdef PRIDE\n    return 0.5 + 0.5*cos(iTime+v*6.28+vec3(0,2,4));\n#else\n    float i = clamp(v, 0., 1.)*float(N);\n    int i0 = int(i) % N;\n    int i1 = (i0+1) % N;\n    float f = fract(i);\n    return mix(colors[i0], colors[i1], f);\n#endif\n}\n\nvec3 sample_color(vec2 pix, vec2 center, float zoom) {\n    vec2 uv = (2.*pix - iResolution.xy)/iResolution.y;\n    vec2 c = uv * pow(2., -zoom) + center;\n    vec2 z;\n    int n = mandelbrot(c, z);\n    if (n < 0) return vec3(0);\n    float val = log(max(smooth_color(z, n), 1.));\n    return colormap(fract(val*COLOR_FREQ + COLOR_SHIFT));\n}\n\n// Text printing\n#define BOTLEFT vec2(0)\n#define BOTRIGHT vec2(iResolution.x, 0)\n#define TOPLEFT vec2(0, iResolution.y)\n#define TOPRIGHT iResolution.xy\n#define CENTER (iResolution.xy / 2.)\n#define CENTERX (iResolution.x / 2.)\n#define CENTERY (iResolution.y / 2.)\n\nconst vec2 ASPECT = vec2(.7, 1);\n\nvec2 fsize(float scale) { return ASPECT * scale; }\n\nvec2 fpos(vec2 pos, vec2 anchor, vec2 offset, float size) {\n    return (pos - anchor) / fsize(size) - offset;\n}\n\nfloat print(vec2 pos, int char) {\n    if (pos.x < 0.05 || pos.y < 0.05 || pos.x >= 0.95 || pos.y >= 0.95)\n        return 0.;\n    vec2 cell = vec2(char % 16, 15 - char / 16);\n    pos = (pos - .5)*ASPECT + .5;\n    vec4 pix = texture(iChannel1, (cell + pos) / 16., -1.);\n    return pix.r;\n}\n\nfloat print_num(vec2 pos, float n, int before, int after, bool signed) {\n    int len = before + after + int(after > 0) + int(signed);\n    if (pos.x < 0. || pos.y < 0. || pos.x >= float(len) || pos.y >= 1.)\n        return 0.;\n    int ind = int(pos.x) - int(signed);\n    int char;\n    if (signed && ind == -1) {\n        char = n < 0. ? 45 : 32; // '-' : ' '\n    } else if (ind == before) {\n        char = 46; // '.'\n    } else {\n        float rounded = round(abs(n) * pow(10., float(after)));\n        int power = ind - (before + after) - int(ind > before);\n        int dig = int(fract(rounded * pow(10., float(power))) * 10.);\n        char = dig + 0x30; // '0'\n    }\n    return print(fract(pos), char);\n}\n\nfloat print_num_r(vec2 pos, float n, int before, int after, bool signed) {\n    int len = before + after + int(after > 0) + int(signed);\n    return print_num(pos + vec2(len, 0), n, before, after, signed);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 state = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec2 center = state.xy;\n    float zoom = state.z;\n\n    vec3 col = vec3(0);\n    for (int i=0; i<SAMPLES; i++) {\n\t    for (int j=0; j<SAMPLES; j++) {\n            vec2 pix = fragCoord + vec2(i, j)/float(SAMPLES);\n        \tcol += sample_color(pix, center, zoom);\n        }\n    }\n    col /= float(SAMPLES*SAMPLES);\n\n#ifdef PRINT\n    col += print(fpos(fragCoord,BOTRIGHT,vec2(-8,2),24.), 0x32); // '2'\n    col += print(fpos(fragCoord,BOTRIGHT,vec2(-7,2),24.), 0x5e); // '^'\n    col += print_num_r(fpos(fragCoord,BOTRIGHT,vec2(0,2),24.), zoom, 2, 2, true);\n    col += print_num_r(fpos(fragCoord,BOTRIGHT,vec2(0,1),24.), center.x, 1, 8, true);\n    col += print_num_r(fpos(fragCoord,BOTRIGHT,vec2(0,0),24.), center.y, 1, 8, true);\n#endif\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define INITCENTER vec2(-.5, 0)\n#define INITZOOM -0.2\n#define MAXZOOM 18.\n#define ZOOMSPEED 1.\n#define PANSPEED 1.\n\n#define KEY_CTRL 17\n#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n#define KEY_PLUS 187\n#define KEY_MINUS 189\n#define KEY_ZERO 48\n\nbool key_down(int key) {\n    return texelFetch(iChannel1, ivec2(key, 0), 0).x > .5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center = INITCENTER;\n    float zoom = INITZOOM;\n    \n    if (iFrame > 0) {\n        vec4 state = texelFetch(iChannel0, ivec2(0, 0), 0);\n        center = state.xy;\n        zoom = state.z;\n    }\n    \n    if (key_down(KEY_LEFT))\n        center.x -= PANSPEED * iTimeDelta * pow(2., -zoom);\n    if (key_down(KEY_RIGHT))\n        center.x += PANSPEED * iTimeDelta * pow(2., -zoom);\n    if (key_down(KEY_DOWN))\n        center.y -= PANSPEED * iTimeDelta * pow(2., -zoom);\n    if (key_down(KEY_UP))\n        center.y += PANSPEED * iTimeDelta * pow(2., -zoom);\n    if (key_down(KEY_PLUS))\n        zoom += ZOOMSPEED * iTimeDelta;\n    if (key_down(KEY_MINUS))\n        zoom -= ZOOMSPEED * iTimeDelta;\n    if (key_down(KEY_ZERO)) {\n        center = INITCENTER;\n        zoom = INITZOOM;\n    }\n    \n    if (iMouse.z > 0.) {\n        float sgn = 1. - 2.*float(key_down(KEY_CTRL));\n        float dzoom = sgn * ZOOMSPEED * iTimeDelta;\n        vec2 mouse = (2.*iMouse.xy - iResolution.xy)/iResolution.y;\n        vec2 disp = mouse * pow(2., -zoom);\n        center += disp * (1. - pow(2., -dzoom));\n        zoom += dzoom;\n    }\n    zoom = min(zoom, MAXZOOM);\n    \n    fragColor = vec4(center, zoom, 0.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}