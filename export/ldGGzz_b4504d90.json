{"ver":"0.1","info":{"id":"ldGGzz","date":"1453056762","viewed":379,"name":"Liquid sphere","username":"And390","description":"I've used the distance field method with exponential smooth, reflection and soft shadows.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["smooth","morphing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 directLightDir = vec3(1.0, 1.0, -1.0);\nconst float directLightPow = 0.7;\nconst float ambientLight = 0.4;\nconst float epsilon = 0.001;\nfloat PI = acos(-1.);\n\nconst float groundY = 0.0;\n\nconst vec3 startPos = vec3(0., 5., 0.);\nconst float startRad = 1.0;\nconst float partRad = 0.5;\nconst float ballRad = startRad * partRad;\nconst float puddleRad = ballRad * 2.;\nconst int partCount = 8;\n\nconst float roomSize = 100.;\n\nconst float stayDuration = 2.0;\nconst float explosionDuration = 3.0;\nconst float disintegrationDuration = 0.5;\nconst float mergeDuration = 15.0;\nconst float riseDuration = 4.0;\nconst float totalDuration = stayDuration + explosionDuration + mergeDuration + riseDuration;\n\nconst int BACKGROUND = 0;  //background room\nconst int SPHERE = 1;\n\nfloat rand(float n, float cycleNum)  {  return fract(sin(cycleNum * 2345.523 + n) * 43758.5453123);  }\nvec3 rand3D(float p, float cycleNum)  {  return vec3(rand(p, cycleNum), rand(p+44346.1872, cycleNum), rand(p+4123.1414, cycleNum));  }\n\nfloat mapPuddle(vec3 p, vec3 pos, float rad) {\n    const float squeeze = 3.5;\n    pos.y = groundY;\n    p.y = (p.y - groundY) * squeeze + groundY;  //transform\n    return (length(p - pos) - rad) / squeeze;  //reverse transform for distance (roughly)\n}\n\nfloat mapBalls(vec3 p)  {\n    const float mergeK = 5.;\n    const vec3 g = vec3(0., -5., 0.);  //gravity\n    const float ballSpeed = 7.;\n    const float puddleSpeed=1.;\n\n    float cycleTime = mod(iTime, totalDuration);\n    float cycleNum = floor(iTime / totalDuration);\n\n    //    stay stage\n    float time = cycleTime;\n    if (time < stayDuration)\n    {\n        return length(p - startPos) - startRad;\n    }\n    time -= stayDuration;\n\n    //    explosion stage\n    if (time < explosionDuration)\n    {\n        float rad = time < disintegrationDuration ? mix(startRad, ballRad, time/disintegrationDuration) : ballRad;\n        vec3 base = startPos + g*time*time;\n\n        float res = 0.;\n        for (int i=0; i<partCount; i++)  {\n            vec3 v = (rand3D(float(i),cycleNum) * 2. - 1.) * ballSpeed;\n            vec3 ballCenter = base + v*time;\n            float maxT = (-v.y - sqrt(v.y*v.y - 4.*g.y*(startPos.y-groundY))) / (2.*g.y);  //time to drop on the ground\n            vec3 puddleCenter = time<maxT ? base + v*time : startPos + g*maxT*maxT + v*maxT;\n            //    add dist to ball\n            float dist = length(p - ballCenter) - rad;\n            res += exp(-mergeK * dist);\n            //    add dist to puddle\n            float diving = groundY + ballRad - ballCenter.y;\n            if (diving > 0.)  {\n                float rad = diving < ballRad*2. ? puddleRad * (3.*pow(diving/ballRad, 2.) - pow(diving/ballRad, 3.)) / 4. : puddleRad;\n                dist = mapPuddle(p, puddleCenter, puddleRad);\n                res += exp(-mergeK * dist);\n            }\n        }\n        return -log(res) / mergeK;\n    }\n    time -= explosionDuration;\n\n    //    merge stage\n    if (time < mergeDuration)\n    {\n        float res = 0.;\n        for (int i=0; i<partCount; i++)  {\n            vec3 v = (rand3D(float(i),cycleNum) * 2. - 1.) * ballSpeed;\n            float maxT = (-v.y - sqrt(v.y*v.y - 4.*g.y*(startPos.y-groundY))) / (2.*g.y);  //time to drop on the ground\n\n            vec3 xz = vec3(v.x, 0, v.z) * maxT;\n            float l0 = length(xz);\n            float l1 = max(l0 - time*puddleSpeed, 0.);\n            xz = xz / l0 * l1;\n\n            float dist = mapPuddle(p, startPos + xz, puddleRad);\n            res += exp(-mergeK * dist);\n        }\n        return -log(res) / mergeK;\n    }\n    time -= mergeDuration;\n\n    //    rise stage\n    float res = 0.;\n\n    vec3 ballCenter = startPos;\n    ballCenter.y = mix(groundY-startRad, startPos.y, time/riseDuration);\n    float ballDist = length(p - ballCenter) - startRad;\n    res += exp(-mergeK * ballDist);\n\n    float puddleK = (groundY+startRad-ballCenter.y) / startRad;\n    if (puddleK > 0.)  {\n        float sizeK = (3.*pow(puddleK, 2.) - pow(puddleK, 3.)) / 4.;  //segment volume\n        float puddleDist = mapPuddle(p, startPos, puddleRad*sizeK);\n        puddleDist = puddleDist - log(float(partCount)) / mergeK * sizeK;\n        res += exp(-mergeK * puddleDist);\n    }\n\n    return -log(res) / mergeK;\n}\n\nint map(vec3 src, vec3 dir, out vec3 resultPos)\n{\n    //    balls\n    float t=0.;\n    for (int i=0; i<200; i++) {\n        vec3 p = src + dir * t;\n        if (p.y < groundY)  break;\n        float dist = mapBalls(p);\n        if (dist < epsilon)  {\n            resultPos = p;\n            return SPHERE;\n        }\n        t += dist;\n        if (t > 1000.)  break;\n    }\n    //    background room\n    float ty;\n    if (dir.y < 0.)  ty = (groundY - src.y) / dir.y;\n    else  ty = (groundY - src.y + roomSize) / dir.y;\n    float tx;\n    if (dir.x < 0.)  tx = - (roomSize/2. + src.x) / dir.x;\n    else  tx = (roomSize/2. - src.x) / dir.x;\n    float tz;\n    if (dir.z < 0.)  tz = - (roomSize/2. + src.z) / dir.z;\n    else  tz = (roomSize/2. - src.z) / dir.z;\n    t = min(ty, min(tx, tz));\n    resultPos = src + dir * t;\n    return BACKGROUND;\n}\n\nfloat map(vec3 p)  {\n    return mapBalls(p);\n}\n\nfloat shadow(vec3 src, vec3 dir)\n{\n    const float k = 4.;\n    float res = 1.0;\n    float t = 0.01;  //prevent self-collision\n    for (int i=0; i<200; i++) {\n        vec3 p = src + dir * t;\n        if (p.y < groundY)  break;\n        float dist = map(p);\n        if (dist < epsilon)  return 0.0;\n        res = min(res, k*dist/t);\n        t += dist;\n        if (t > 1000.)  break;\n    }\n    return res;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(epsilon, 0.0);\n    return normalize(vec3(map(p+e.xyy) - map(p-e.xyy),\n                          map(p+e.yxy) - map(p-e.yxy),\n                          map(p+e.yyx) - map(p-e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    directLightDir = normalize(directLightDir);\n\n    //    camera\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1. + 2.*uv;\n\n    p.y /= iResolution.x / iResolution.y;\n\n    float mx = iMouse.xy == vec2(0.) ? 0.5 : iMouse.x / iResolution.x;\n    float my = iMouse.xy == vec2(0.) ? 0.5 : iMouse.y / iResolution.y;\n\n    float r = 12.;\n    float ay = my * 0.5 * PI;\n    float ax = (mx - 1.) * PI;\n    ax += iTime*0.05;\n    vec3 ro = vec3(cos(ax)*cos(ay)*r, sin(ay)*r, sin(ax)*cos(ay)*r);  //camera position\n    ro.y += 3.0;\n    vec3 rd = normalize(vec3(p, 1.0));  //view direction\n    ay = -ay;\n    ax = -PI/2. -ax;\n    rd = vec3(rd.x, rd.z*sin(ay)+rd.y*cos(ay), rd.z*cos(ay)-rd.y*sin(ay));  //rotate by x\n    rd = vec3(rd.z*sin(ax)+rd.x*cos(ax), rd.y, rd.z*cos(ax)-rd.x*sin(ax));  //rotate by y\n\n    float time = iTime;\n\n    vec3 col = vec3(0.);\n    float reflection = 1.0;\n    for (int r=0; r<10; r++) {\n        //    ray tracing\n        vec3 pos;\n        int result = map(ro, rd, pos);\n\n        //    color and lighting\n        if (result==SPHERE)  {\n            vec3 normal = calcNormal(pos);\n            float lightness = ambientLight;\n            //    direct light with shadow\n            vec3 lightDir = directLightDir;\n            lightness += shadow(pos, lightDir) * max(0.0, dot(normal, lightDir) * directLightPow);\n            col = mix(col, vec3(0.7, 0.7, 0.7) * lightness, reflection);\n            //    reflection\n            reflection = 0.25;\n            ro = pos + normal * (epsilon * 10.);\n            rd = reflect(rd, normal);\n            continue;\n        }\n        //    background\n        else  {\n            vec3 uv = pos - vec3(0., roomSize/2.+groundY, 0.) + vec3(0., roomSize*0.4, 0.);\n            col = mix(col, texture(iChannel0, uv, -100.).xyz, reflection);\n            //    shadow\n            float lightness = ambientLight;\n            vec3 lightDir = directLightDir;\n            lightness += shadow(pos, lightDir) * directLightPow;\n            lightness /= (ambientLight + directLightPow);\n            col *= lightness;\n        }\n        break;\n    }\n\n\tfragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}