{"ver":"0.1","info":{"id":"fdjcRy","date":"1643714645","viewed":208,"name":"Eulerian particles","username":"Ultraviolet","description":"Euler-style particle system, same idea as [url]https://www.shadertoy.com/view/ll3SWs[/url] and [url]https://www.shadertoy.com/view/MdtGDX[/url].\n\nSPACE to reset (e.g in full screen), and A to generate new particles.\n\nYou can set USE_V8 in commons.","likes":8,"published":1,"flags":48,"usePreview":0,"tags":["particle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 col, in vec2 xy )\n{\n    vec4 val = getA(xy);\n    \n    col.rgb = hsv2rgb(vec3(val.z,0.8, sqrt(val.x*0.5)));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// col.x : status (0->empty, 1->trace, 2->current_particle)\n// col.y : direction (0->right, 1->up, 2->left, 3->down)\n// col.z : id (only if status is 1 or 2)\n// col.w : ?\n\nvoid mainImage( out vec4 col, in vec2 xy )\n{\n    // INIT   \n    if(iFrame == 0 || texelFetch(iChannel1, ivec2(32,0), 0).x>0.5) {\n\n        //*\n        // if(all(equal(ivec2(xy),ivec2(R)/2)))\n        if(hash13(vec3(xy, iDate.w))> 0.995 && int(xy.x)%2 == 0 && int(xy.y)%2 == 0)\n            col = vec4(2.,floor(hash13(vec3(xy, 1.))*float(nb_dir)),hash13(vec3(xy, 2.)),0.);\n        else\n        //*/\n            col = vec4(0.);\n        return;\n    }\n    \n    vec4 val = getA(xy);\n    \n    if(texelFetch(iChannel1, ivec2(65,0), 0).x>0.5 && feq(val.x, 0.) && hash13(vec3(xy, iDate.w))> 0.9998 && int(xy.x)%2 == 0 && int(xy.y)%2 == 0) {\n        col = vec4(2.,floor(hash13(vec3(xy, 1.))*float(nb_dir)),hash13(vec3(xy, 2.)),0.);\n    }\n    \n    // trace status : do nothing\n    if(feq(val.x, 1.) || (iFrame%2 == 0 && feq(val.x, 2.)))\n    {\n        col = val;\n        col.x = 1.;\n        return;\n    }\n    \n    // on even frames : empty cells check for incoming particles\n    if(iFrame%2 == 0 && feq(val.x, 0.))\n    {\n        for(int i=0; i<nb_dir; ++i) {\n            vec4 val_neib = getA(xy+dir[i]);\n            \n            if(feq(val_neib.x, 2.) && feq(val_neib.y, mod(float(i)+float(nb_dir)/2.,float(nb_dir)))) {\n                val = val_neib;\n                break;\n            }\n        }\n        col = val;\n        \n        col.w = 1.-col.w;\n        return;\n    }\n    \n    // on odd frames : particle cells check that the current direction is valid\n    else if(iFrame%2 == 1 && feq(val.x, 2.))\n    {\n        col = val;\n        \n        int d_valid = -1;\n        \n        //*\n        for(int i=0; i<nb_dir; ++i) {\n            int d = (int(val.y)+i)%nb_dir;\n            //d = i;\n            vec2 n = xy+2.*dir[d];\n            vec4 val_neib = getA(n);\n            if(is_inside(n) \n            && feq(val_neib.x, 0.) \n            && feq(getA(xy+dir[d]+dir[(d+1)%nb_dir]).x, 0.) \n            && feq(getA(xy+dir[d]+dir[(d-1)%nb_dir]).x, 0.)\n            ) {\n                d_valid = d;\n                break;\n            }\n        }\n        //*/\n                \n        col.y = float(d_valid);\n        \n        if(d_valid == -1)\n            col.x = 1.;\n            \n        return;\n    }\n    \n    \n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n#define R (iResolution.xy)\n#define getA(xy) (texture(iChannel0, (xy)/R))\n#define feq(x,y) (abs(x-y) < 1e-6)\n\n#define is_inside(xy) ((xy).x > -0.5 && (xy).y > -0.5 && (xy).x < R.x && (xy).y < R.y)\n\n//#define USE_V8\n\n#ifndef USE_V8\nconst int nb_dir = 4;\nconst vec2 dir[4] = vec2[4](vec2(0.,1.), vec2(1.,0.), vec2(0.,-1.), vec2(-1.,0.));\n\n#else\nconst int nb_dir = 8;\nconst vec2 dir[8] = vec2[8](vec2(0.,1.), vec2(1.,1.), vec2(1.,0.), vec2(1.,-1.), vec2(0.,-1.), vec2(-1., -1.), vec2(-1.,0.), vec2(-1, 1.));\n#endif\n\n\n// hash from Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec3 hsv2rgb(vec3 hsv) {\n\tvec3 rgb = pow(cos((vec3(-hsv.x)+vec3(0., 0.33, 0.66))*3.14), vec3(2.));\n    rgb /= length(rgb);\n    rgb *= hsv.z;\n    rgb = mix(vec3(hsv.z), rgb, hsv.y);\n    return rgb;\n}","name":"Common","description":"","type":"common"}]}