{"ver":"0.1","info":{"id":"M3BSWR","date":"1717958314","viewed":25,"name":"Closest Tangent Point - Triangle","username":"natevm","description":"Minimal tangent cone to a segment. Work in progress...","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","sdf","capsule","closest"],"hasliked":0,"parentid":"4XBXzz","parentname":"Closest Tangent Point - Segment"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright © 2024 Nate Morrical\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// cheaper alternative to acos intrinsic\n// https://developer.download.nvidia.com/cg/acos.html\nfloat swacos(float x) {\n  float negate = float(x < 0.f);\n  x = abs(x);\n  float ret = -0.0187293f;\n  ret = ret * x;\n  ret = ret + 0.0742610f;\n  ret = ret * x;\n  ret = ret - 0.2121144f;\n  ret = ret * x;\n  ret = ret + 1.5707288f;\n  ret = ret * sqrt(1.f-x);\n  ret = ret - 2.f * negate * ret;\n  return negate * 3.14159265358979f + ret;\n}\n\n// Given an angular similarity, returns the corresponding angle in radians. \n//   s - the similarity measure, s = (dot(d, ∆) |dot(d, ∆)| / |∆|^2)\nfloat similarityToAngle(float s) {\n    if (0.f <= s && s <= 1.f) {\n        return swacos(2.f * s - 1.0) / 2.0;\n    }\n    else if (-1.f <= s) {\n        return (swacos(2.f * s + 1.0) / 2.0) + radians(90.);\n    }\n}\n\n// Returns the angular similarity between two directions. \n// Similarity is expressed as s = dot(d, ∆) |dot(d, ∆)| / |∆|^2\n//  d - the direction of a ray\n//  ∆ - a vector relative to ray's origin. (∆ = p - o)\nfloat angularSimilarity(vec3 d, vec3 delta) {    \n    // length squared of delta\n    float deltaNorm2 = dot(delta, delta);\n    \n    // proportional to cos(theta) between d and ∆\n    float dDotDelta = dot(d, delta);\n    \n    // similarity = dot(d, ∆) |dot(d, ∆)| / |∆|^2\n    return dDotDelta * abs(dDotDelta) / deltaNorm2;\n}\n\n// Returns a maximal angular similarity to the segment relative to the cone, \n// as well as the parameterization \"t\" along the segment to the corresponding point. \n// Similarity is expressed as s = dot(d, ∆) |dot(d, ∆)| / |∆|^2\n//  a  - the apex of the cone\n//  d  - the direction of the cone, perpendicular to it's base.\n//  v0 - the starting point of the segment\n//  v1 - the ending point of the segment\nvec2 mtcSegmentQuery(vec3 a, vec3 d, vec3 v0, vec3 v1)\n{\n    //  ∆0 and ∆1 are vectors from segment to the apex\n    vec3 d0 = v0 - a;\n    vec3 d1 = v1 - a;\n    \n    // α - angle between d and ∆0\n    // β - angle between d and ∆1\n    // γ - angle between ∆0 and ∆1\n    // θ - minimizing angle between D and the segment\n    \n    // Values are:\n    \n    // |∆0|^2\n    float dd00 = dot(d0, d0);\n    \n    // |∆1|^2\n    float dd11 = dot(d1, d1);\n    \n    // |∆0||D|cos(α)\n    float dd0d = dot(d0, d);\n    \n    // |∆1||D|cos(β)\n    float dd1d = dot(d1, d);\n    \n    // |∆0||∆1|cos(γ)\n    float dd01 = dot(d0, d1);\n    \n    // Vector perpendicular to triangle from edge to apex, scaled by parallelogram.\n    // Equivalent to great circle normal connecting ∆0 and ∆1, but scaled.\n    // |∆0x∆1| = |∆0||∆1|sin(γ)\n    vec3 n = cross(d0, d1);\n    \n    // |N|^2\n    float dnn = dot(n, n);\n    \n    // |D||N|cos(θ)\n    float ddn = dot(d, n);\n    \n    // Project d onto plane containing the triangle.\n    // (aka, project point onto great circle containing arc from v0 to v1)\n    // p = D - (D·N)/(N·N) * N\n    vec3 d2 = d - (ddn / dnn) * n;\n    \n    // Find planes perpendicular to great circle containing the arc\n    // (using triple vector product rule to avoid cross products)\n    //   A × (B × C) = B (A · C) − C (A · B),\n    //   (A × B) × C = C (A · B) - B (A · C),\n    //   N0 = Nx∆0 = (∆0x∆1)x∆0 = ∆1(∆0·∆0) - ∆0(∆0·∆1)\n    //   N1 = Nx∆1 = (∆0x∆1)x∆1 = ∆0(∆1·∆1) - ∆1(∆0·∆1)\n    vec3 n0 = d1 * dd00 - d0 * dd01;\n    vec3 n1 = d0 * dd11 - d1 * dd01;\n    \n    // Test if projection falls outside the arc \n    if (dot(d2, n0) < 0.f || dot(d2, n1) < 0.f) {\n        // Compute angular similarity measure to the end points\n        // similarity = dot(d, ∆) |dot(d, ∆)| / |∆|^2\n        float sa = dd0d * abs(dd0d) / dd00;\n        float sb = dd1d * abs(dd1d) / dd11;\n        \n        // Pick the closer of the two ends\n        if (sa > sb) return vec2(sa, 0.);\n        else return vec2(sb, 1.);\n    }\n        \n    // Projection is on the triangle / within the arc.\n    // Compute the barycentrics of the projected point within \n    // that triangle to recover the \"t\" parameter interpolating the edge.\n    float d20 = dot(d2,d0);\n    float d21 = dot(d2,d1);\n    float dd2 = dot(d, d2);\n    float d22 = dot(d2, d2);    \n    float area = (dd00*dd11 - dd01*dd01);\n    float v = ((dd11*d20) - (dd01*d21)) / area;    \n    float w = ((dd00*d21) - (dd01*d20)) / area;\n    float t = w / (w + v);\n\n    // similarity = dot(d, ∆) |dot(d, ∆)| / |∆|^2\n    float s = dd2 * abs(dd2) / d22;\n    return vec2(s, t);\n}\n\n\n\n// Returns { s, t, u, v }\n// Returns a maximal angular similarity to the surface of the triangle relative to the cone, \n// as well as the varycentrics \"u\" and \"v\" along the triangle to the corresponding point. \n// Similarity is expressed as s = dot(d, ∆) |dot(d, ∆)| / |∆|^2\n//  a  - the apex of the cone\n//  d  - the direction of the cone, perpendicular to it's base.\n//  v0 - the 1st tri vertex, corresponds to 1 - u - v\n//  v1 - the 2nd tri vertex, corresponds to u\n//  v2 - the 3rd tri vertex, corresponds to v\nvec3 mtcTriangleQuery(vec3 a, vec3 d, vec3 v0, vec3 v1, vec3 v2)\n{   \n    vec2 st0 = mtcSegmentQuery(a, d, v0, v1);\n    vec2 st1 = mtcSegmentQuery(a, d, v1, v2);\n    vec2 st2 = mtcSegmentQuery(a, d, v2, v0);\n    \n    if (st0.x >= st1.x && st0.x >= st2.x) {\n        return mix(v0, v1, st0.y);\n    }\n    if (st1.x >= st0.x && st1.x >= st2.x) {\n        return mix(v1, v2, st1.y);\n    }\n    if (st2.x >= st1.x && st2.x >= st0.x) {\n        return mix(v2, v0, st2.y);\n    }\n    return a;\n}\n\n//------------------------------------------------------------\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat maxcomp( in vec2 v ) { return max(v.x,v.y); }\n\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, vec3 cen, float rad )\n{\n    return length(p-cen)-rad;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat udTriangle( in vec3 p, in vec3 v1, in vec3 v2, in vec3 v3)\n{\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v32 = v3 - v2; vec3 p2 = p - v2;\n    vec3 v13 = v1 - v3; vec3 p3 = p - v3;\n    vec3 nor = cross( v21, v13 );\n\n    return sqrt( (sign(dot(cross(v21,nor),p1)) + \n                  sign(dot(cross(v32,nor),p2)) + \n                  sign(dot(cross(v13,nor),p3))<2.0) \n                  ?\n                  min( min( \n                  dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), \n                  dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), \n                  dot2(v13*clamp(dot(v13,p3)/dot2(v13),0.0,1.0)-p3) )\n                  :\n                  dot(nor,p1)*dot(nor,p1)/dot2(nor) );\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\nvec3 angleAxis(float angle, vec3 axis, vec3 v) {\n    vec3 k = normalize(axis); // Ensure the axis is a unit vector\n    float cosTheta = cos(angle);\n    float sinTheta = sin(angle);\n\n    // Rodrigues' rotation formula\n    vec3 rotated = v * cosTheta + \n                   cross(k, v) * sinTheta + \n                   k * dot(k, v) * (1.0 - cosTheta);\n\n    return rotated;\n}\n\n//https://www.shadertoy.com/view/NttcW8\nfloat sdArrow(vec3 position, vec3 start, vec3 end, float baseRadius, float tipRadius, float tipHeight) {\n    vec3 t = start - end;\n    float l = length(t);\n    t /= l;\n    l = max(l, tipHeight);\n\n    position -= end;\n    if (t.y + 1.0 < 0.0001) {\n        position.y = -position.y;\n    } else {\n        float k = 1.0 / (1.0 + t.y);\n        vec3 column1 = vec3(t.z * t.z * k + t.y, t.x, t.z * -t.x * k);\n        vec3 column2 = vec3(-t.x, t.y, -t.z);\n        vec3 column3 = vec3(-t.x * t.z * k, t.z, t.x * t.x * k + t.y);\n        position = mat3(column1, column2, column3) * position;\n    }\n \n    vec2 q = vec2(length(position.xz), position.y);\n    q.x = abs(q.x);\n   \n    // tip\n    vec2 e = vec2(tipRadius, tipHeight);\n    float h = clamp(dot(q, e) / dot(e, e), 0.0, 1.0);\n    vec2 d1 = q - e * h;\n    vec2 d2 = q - vec2(tipRadius, tipHeight);\n    d2.x -= clamp(d2.x, baseRadius - tipRadius, 0.0);\n    \n    // base\n    vec2 d3 = q - vec2(baseRadius, tipHeight);\n    d3.y -= clamp(d3.y, 0.0, l - tipHeight);\n    vec2 d4 = vec2(q.y - l, max(q.x - baseRadius, 0.0));\n\n    float s = max(max(max(d1.x, -d1.y), d4.x), min(d2.y, d3.x));\n    return sqrt(min(min(min(dot(d1, d1), dot(d2, d2)), dot(d3, d3)), dot(d4, d4))) * sign(s);\n}\n\nfloat sdSolidAngle(vec3 p, vec3 a, vec3 d, vec3 b) {\n    // Length of the side of the solid angle conic\n    float ra = distance(a, b);    \n    \n    // The angle between the direction of the conic and a point\n    // on the base.\n    float s = angularSimilarity(d, b-a);\n    float ang = similarityToAngle(clamp(s, 0.0, 1.0));\n    \n    // Transform query point s.t. apex is origin\n    p = p-a;\n    \n    // Rotate query point such that conic direction is aligned to \"y\"\n    vec3 yAxis = vec3(0, 1, 0);\n    vec3 rotAxis = cross(d, yAxis);\n    float rotAngle = acos(dot(yAxis, d));\n    vec3 pRot = angleAxis(rotAngle, rotAxis, p);\n\n    // Now compute the SDF as before with the rotated point\n    vec2 q = vec2( length(pRot.xz), pRot.y );\n    \n    vec2 c = vec2(sin(ang), cos(ang)); \n    float l = length(q) - ra;\n    float m = length(q - c*clamp(dot(q,c),0.0,ra) );\n    return max(l,m*sign(c.y*q.x-c.x*q.y));\n}\n\n//------------------------------------------------------------\nconst vec3 pa = 1.5f * vec3(-0.6,-0.2,0.4);\nconst vec3 pb = 1.5f * vec3( 0.7,0.2,-0.1);\nconst vec3 pc = 1.5f * vec3( -.3,-0.2,-0.5);\n\n//const vec3 pa = 1.5f * vec3(-0.6,-0.0,0.4);\n//const vec3 pb = 1.5f * vec3( 0.7,0.0,-0.1);\n//const vec3 pc = 1.5f * vec3( -.3,-0.0,-0.5);\n\nbool showCone = true;\nvec2 map( in vec3 pos, bool showSolidAngle, in vec3 apex, in vec3 dir )\n{\n    vec2 res = vec2(1e38f);\n    vec3 p = mtcTriangleQuery(apex, dir, pa, pb, pc);\n    \n    // point on surface which lies tangent to the cone\n    {\n    float d = sdSphere( pos, p, 0.06 );\n    if( d<res.x ) res = vec2( d, 1.0 );\n    }\n    \n    // triangle's surface\n    {\n    float d = udTriangle(pos, pa, pb, pc) - .001;\n    if( d<res.x ) res =  vec2(d, 5.0);\n    }\n    \n    // Arrow representing the ray\n    {\n    float d = sdArrow(pos, apex, apex+dir, .01, .06, .08);\n    if( d<res.x ) res =  vec2( d, 0.0 );\n    }\n    \n    // Query cone   \n    if (showSolidAngle) \n    {    \n    float d = sdSolidAngle(pos, apex, dir, p);\n    if( d<res.x ) res =  vec2( d, 1.0 );\n    }\n    \n    \n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, bool showSolidAngle, in vec3 apex, in vec3 dir )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps, showSolidAngle, apex, dir ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps, showSolidAngle, apex, dir ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps, showSolidAngle, apex, dir ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps, showSolidAngle, apex, dir ).x );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftShadow( vec3 ro, vec3 rd, bool showSolidAngle, in vec3 apex, in vec3 dir )\n{\n    float res = 1.0;\n    const float tmax = 2.0;\n    float t = 0.001;\n    for( int i=0; i<64; i++ )\n    {\n     \tfloat h = map(ro + t*rd, showSolidAngle, apex, dir).x;\n        res = min( res, 64.0*h/t );\n    \tt += clamp(h, 0.01,0.5);\n        if( res<-1.0 || t>tmax ) break;\n        \n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep, in [-1,1]\n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord)*AA + ivec2(m,n);\n        // time sample\n        float td = 0.5+0.5*sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1);\n        float time = iTime - 0.5*(1.0/60.0)*(td+float(m*AA+n))/float(AA*AA-1);\n        #else    \n        // pixel coordinates\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        // pixel sample\n        ivec2 samp = ivec2(fragCoord);\n        // time sample\n        float time = iTime;\n        #endif\n\n        //time = 3307.44 + sin(iTime * .5) * 2.f;\n\n        // animate camera\n        float an = 0.25*time + 6.283185*iMouse.x/iResolution.x;\n        vec3 ro = vec3( 2.4*cos(an), 0.7, 2.4*sin(an) );\n        vec3 ta = vec3( 0.0, 0.0, 0.0 );\n\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.2,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n\n        // animate the tangent cone\n        vec3 start = -1.5f*sin(time*0.5*vec3(1.0,1.1,1.2)+vec3(4.0,2.0,1.0));\n        vec3 stop  = -1.5f*cos(time*0.5*vec3(1.0,1.1,1.2)+vec3(4.0,2.0,1.0));\n\n        vec3 apex = start;\n        vec3 dir = normalize(stop - start);\n        \n        // Make bounding capsule transparent\n        bool showSolidAngle = ((samp.x+samp.y+1)&1)==0; \n        \n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raycast\n        const float tmax = 5.0;\n        float t = 0.0;\n        float m = -1.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            vec2 hm = map(pos, showSolidAngle, apex, dir);\n            m = hm.y;\n            if( hm.x<0.0001 || t>tmax ) break;\n            t += hm.x;\n        }\n    \n        // shade background\n        vec3 col = vec3(0.05)*(1.0-0.2*length(p));\n        \n        // shade objects\n        if( t<tmax )\n        {\n            // geometry\n            vec3  pos = ro + t*rd;\n            vec3  nor = calcNormal(pos, showSolidAngle, apex, dir);\n\n            // color\n            vec3  mate = 0.55 + 0.45*cos( m + vec3(0.0,1.0,1.5) );\n            \n            \n            vec3 p = mtcTriangleQuery(apex, dir, pa, pb, pc);\n            //float angle = similarityToAngle(result.x);\n            float run = dot(dir, p - apex);\n            float rise = distance(apex + dir * run, p);\n                \n            // Show distance isolines on query\n            if( abs(m-1.0)<0.6 || abs(m-3.0)<0.6)\n            {     \n                float dref = sdCone(p, apex, apex + dir * run, 0.f, rise);               \n                float dsam = length(pos-p);\n                mate += smoothstep(0.8,0.9,sin((dsam-dref)*80.0))*exp2(-2.0*(dsam-dref)*(dsam-dref));\n            }\n            \n            // Show distance isolines on surface\n            if (abs(m-5.0) < .6) {\n                float dref = udTriangle(p, pa, pb, pc);\n                float dsam = length(pos-p);\n                mate += smoothstep(0.8,0.9,sin((dsam-dref)*80.0))*exp2(-2.0*(dsam-dref)*(dsam-dref));\n            }\n                       \n            // lighting\t\n            col = vec3(0.0);\n            {\n              // key light\n              vec3  lig = normalize(vec3(0.3,0.7,0.2));\n              float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n              if( dif>0.001 ) dif *= calcSoftShadow(pos+nor*0.001,lig, showSolidAngle, apex, dir);\n              col += 0.75*mate*vec3(1.0,0.9,0.8)*dif;\n            }\n            {\n              // dome light\n              float dif = 0.5 + 0.5*nor.y;\n              col += 0.75*mate*vec3(0.2,0.3,0.4)*dif;\n            }\n        }\n\n        // gamma        \n        col = pow( col, vec3(0.4545) );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}