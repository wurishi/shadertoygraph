{"ver":"0.1","info":{"id":"7dKyRc","date":"1655405276","viewed":152,"name":"Lorentz contraction+retardation","username":"Amirk","description":"A white cube is orbiting at 80% speed of light. Hence it is contracted in the direction of its velocity. Also, the information takes time to reach an observer (us), which causes further optical distortions. What we would actually see is the purple cube.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["relativity","lorentz","retardation"],"hasliked":0,"parentid":"7sVczK","parentname":"Retard3D"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//note: This demo is unable to account for the relativistic precession\n//that an orbiting cube experiences (Thomas precession). I now have other shaders\n//to take such effects into account.\n\n#define MAX_ITER 500.\n#define MAX_DIST 1000.\n#define SURF .05\n#define BOX 0\n\n//visual parameters:\nvec3 RO= vec3(120.,80.,0.);\nvec3 SIZE= vec3(20,20,20); \n\n//retardation effect ON/OFF:\nconst bool retardON = true;\n\n\nfloat gamma;\n\nvoid LorentzFactor(vec2 v){\n    gamma = pow(1.-length(v)*length(v)/(c*c),-.5);\n}\n\nfloat sdBox(vec3 p , vec3 s){\n    p=scale(p, getVel(center.xz, t), gamma); \n    p= abs(p)-s;\n    return length(max(p,0.))+ min(max(p.x,max(p.y,p.z)),0.);  \n}\n\n\nfloat getDist(vec3 p, float time){\n    //retarded cube:\n    float dist = MAX_DIST;\n    if(retardON){\n        vec2 pos=getPos(center.xz, time); //change t to time to include retardation.\n        dist= sdBox(p.xzy-vec3(pos,0),SIZE);\n    }\n    //realtime cube:\n    vec2 truepos=getPos(center.xz, t); //change t to time to include retardation.\n    float truedist= sdBox(p.xzy-vec3(truepos,0),SIZE);\n\n    return .9*(1.-speed)*min(truedist,dist);\n}\n\n\n\nvec3 getRayDir(vec2 uv, vec3 ro,vec3 lookAt, float zoom){\n\n    vec3 f= normalize(lookAt-ro);\n    vec3 r= normalize(cross(vec3(0,1,0),f));\n    vec3 u= cross(f,r);\n    vec3 i= ro+f*zoom+uv.x*r+uv.y*u;\n    return normalize( i-ro);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float time, float side){\n    float dO=0.;\n    float i=0.;\n   while(i<MAX_ITER){\n      vec3 p= ro+dO*rd;\n      \n      float dS=side*getDist(p,time-dO/c); //we look back in time as we march further away\n\n      dO+=dS;\n  \n      if(dO>MAX_DIST||dS<SURF){\n          break;\n      }\n      i++;\n    } \n    \n      return dO;\n}\n\nvec3 getNormal(vec3 p, float time){\n  vec2 e= vec2(0.01,0);\n   float d=getDist(p,time);\n   vec3 n = d-vec3(getDist(p- e.xyy, time),getDist(p- e.yxy,time),getDist(p- e.yyx,time));\n   \n   return normalize(n);\n}\n\n\n\nint getMaterial(vec3 p){\n    vec2 truePos=getPos(center.xz, t);\n    float trueDist= sdBox(p.xzy-vec3(truePos,0), SIZE);\n    if(trueDist<20.*SURF)\n        return 0;\n    else return 1;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = (iMouse.xy-.5)/iResolution.xy;\n\n    vec3 col = vec3(0);\n\n    float zoom= 1.;\n    vec3 lookAt = vec3(0);\n    \n    //ro.xz*=rot(PI/2.);\n\n    if(sign(iMouse.z)>0.){\n        RO.xy*=rot(-(m.y-.5)*PI);\n        RO.x+=-(m.x-.5)*200.;\n    }else{\n      //  ro.yz*=rot(sin((t*.5-.5)*PI)*.5-PI*.2);\n    }\n  \n    vec3 rd= getRayDir(uv, RO, lookAt,zoom);\n\n\n    \n    LorentzFactor(getVel(center.xz,t));\n    \n    float d= RayMarch(RO, rd, t, 1.);\n    \n    vec3 p=RO;\n    \n     if(d<MAX_DIST){ //if we hit the object:\n          p= p+ d*rd;\n          vec3 n= getNormal(p,t-d/c);\n      \n          float dif= dot(n, normalize(vec3(1,2,0)))*.5+.5;\n          if(getMaterial(p)==BOX)\n              col.rgb=vec3(1)*(.9*pow(sin(t*10.),8.)+.3);\n          else\n              col.rb=vec2(1)*(.9*pow(sin((t-d/c)*10.),8.)+.3);\n          col*=dif;          \n         //second raymarch inside the box \n         float d2= RayMarch(p-20.*SURF*n, rd,t-d/c,-1.);\n         \n         p=p+d2*rd;\n         vec3 n2= getNormal(p, t-(d+d2)/c);         \n         vec3 col2=vec3(1,0.5,0.5)*(dot(n2, normalize(vec3(1,2,0)))*.5+.5);\n                \n          \n         col=mix(col,col2,.3);\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define t iTime\n#define PI 3.14159265359\nconst float speed= 0.80; //as a fraction of the speed of light\nconst float radius=50.; //radius of the circle\nconst float c=100.; //speed of information and light\nfloat freq = c/radius*speed; //freq*radius ought to be less than c\nconst int iterations=100; //accuracy to calculate the retarded position.\n\nvec3 center= radius* vec3(0,0,1);\n\nmat2 rot(float a){ \n    return mat2(cos(a), -sin(a),sin(a),cos(a));\n}\n\nvec3 scale(vec3 p, vec2 dir, float scl){\n    float angle= atan(dir.y,dir.x);\n    p.xy*=rot(angle);\n    p.x*=scl;\n    p.xy*=rot(-angle);\n    \n    return p;\n}\n\nvec2 getPos(vec2 p0, float time){\n    return rot(freq*time)*p0;\n    //return mat2(1, 0,0,cos(freq*time))*p0;\n}\n\nvec2 getVel(vec2 p0, float time){\n    //return rot(freq*time)*p0;\n    return mat2(-freq*sin(freq*time), -freq*cos(freq*time),freq*cos(freq*time),-freq*sin(freq*time))*p0;\n}\n\n\nvec2 retardedPos(vec2 uv, vec2 p0, float time){\n    float upper =time;\n    float lower =0.;\n    float tr = time*.5;\n    int n=0;\n    vec2 retardedP=getPos(p0, tr);\n    while(n<iterations){\n        retardedP=getPos(p0, tr);\n        float dist= length(uv-retardedP);\n        if(dist/c>(time-tr)){\n            upper = tr;\n            tr=(upper+lower)*.5;\n        }else{\n            lower= tr;\n            tr=(upper +lower)*.5;\n        }if(tr<.001){\n           tr=0.;\n           break;\n        }\n        retardedP=getPos(p0, tr);\n        n++;\n    }\n    \n    return retardedP;\n}","name":"Common","description":"","type":"common"}]}