{"ver":"0.1","info":{"id":"tlKSWh","date":"1600463890","viewed":760,"name":"Smoothstep function","username":"GCScholar","description":"An implementation of the smoothstep function that does not use the build-in GLSL function. The blue and red thick lines are my implementations, , the central lines are the build-in.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["smoothstep"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Draw a circular point P with a radius of r\n#define drawPoint(P, r) step( length(U - P), r)\n\nfloat mySmoothstep(float edge0, float edge1, float x) {\n  \n    // Scale the value of x respect to edge0 edge1, and clamp in the interval [0.0, 1.0]  \n  \tx = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0); \n  \t\n    // Evaluate a polinomial\n  \treturn x * x * (3. - 2. * x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalizing coordinates: the center of the screen is (0,0)\n    //  and the coordinates range from -1 to 1 along the y axis\n\tvec2 U = ( 2. * fragCoord - iResolution.xy ) / iResolution.xy.y;\n    \n    \n    // Compute the minimum and maximum x coord normalized coordinates\n    float min_x = - iResolution.xy.x / iResolution.xy.y;\n    float max_x = -min_x;\n    \n    \n    // The size of 1 pixel in normalized coordinates\n    float px_size = 2. / iResolution.y;\n    \n    // Thickness\n    float thickness = px_size;\n    \n    // Coordinates the points of the function at discrete intervals\n    float f = 0.;\n    float r = 0.;\n    float b = 0.;\n    for(float x = min_x; x <= max_x ; x += .01) \n    {\n        // The position of the point to be drawn\n        //vec2 P = vec2 (x, smoothstep(min_x, max_x, x));\n    \t\n        vec2 L = vec2 (x, smoothstep(0., 1., x));\n        vec2 L2 = vec2 (x, mySmoothstep(0., 1., x));\n \n        vec2 S = vec2 (x, smoothstep(min_x, max_x, x));\n        vec2 S2 = vec2 (x, mySmoothstep(min_x, max_x, x));\n        \n        // f will be 1.0 if the actual pixel belong to one of the function point \n        f += drawPoint(S, thickness*2.5);\n        r += drawPoint(S2, thickness * 6.);\n        \n        f += drawPoint(L, thickness*2.5);\n        b += drawPoint(L2, thickness * 6.);\n    }\n    \n    fragColor = vec4(r,f,b,1.);\n}","name":"Image","description":"","type":"image"}]}