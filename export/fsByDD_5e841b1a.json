{"ver":"0.1","info":{"id":"fsByDD","date":"1643943986","viewed":87,"name":"M-brot with circle reflectors","username":"c0rymcg","description":"The Mandelbrot set formula with reflections interrupting the regular orbits. The reflections happen at two circular boundaries, one inside and one outside, making it difficult for the orbits to attract or escape.\n\nwith log-potential smooth coloring","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbrot","inversion"],"hasliked":0,"parentid":"Nd2cWz","parentname":"Orbiting tricorns and mbrots"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define PI 3.14159\n#define TAU 6.28318\n#define reflectionRecursion 2\n#define AA 2\n#define maxIterations 200\nvec2 f(vec2 z, vec2 c) {\n    return mat2(z,-z.y,z.x)*z + c;\n}\n\nvec3 palette(float loc, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b*cos( TAU*(c*loc+d) );\n}\n\nfloat logPotential(float d,float i){\n  \n\tfloat base=log(2.);\n\treturn i-(log(log(d)/base)/base);\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 aacol=vec3(0.);\n    float t = iTime;\n    \n    float reflDist1 = (cos(t/6.)+1.)*2.+12.;\n    float reflDist2 = (cos(t/8.)+1.)*1.5;\n    \n    //describe leminscate of bernoulli for the circle reflectors to trace\n    float sint=sin(t/7.);\n    float cost=cos(t/7.);\n    vec2 reflPos = vec2(cost/(1.+sint*sint), sint*cost/(1.+sint*sint));\n    \n    \n    \n    \n    vec2 c = vec2(0.);\n    vec2 z = vec2(0.);\n    \n    \n    \n    //aa code here\n    for (int aax=0; aax<AA; aax++){\n    for (int aay=0; aay<AA; aay++){\n        vec2 c = vec2(0.);\n      vec2 z = vec2(0.);\n    \n    vec2 uv = (fragCoord + vec2(aax,aay)/float(AA))/iResolution.x;\n    uv.x-=0.2;\n    uv.y+=0.2;\n    uv -= 0.5;\n    uv *= 1.3;\n    uv += 0.5;\n    \n    c = 3.0 * (uv - 0.5);\n    \n    int escaped = -1;\n    int iterations;\n    \n    \n    \n    for (int i = 0; i < maxIterations; i++) {\n        iterations = i;\n        z = f(z, c);\n           \n\n        //handle reflections\n        for(int r = 0; r < reflectionRecursion; r++){\n        if (length(z+reflPos) > reflDist1){\n            z = z+reflPos;\n            float theta=atan(z.y, z.x);\n            float dist = reflDist1/length(z);\n            z = vec2(sin(theta),cos(theta))*dist;            \n            z = z-reflPos;\n        }\n        if(length(z+reflPos) < reflDist2){\n           z = z+reflPos;\n            float theta=atan(z.y, z.x);\n            float dist = reflDist2/length(z);\n            z = vec2(sin(theta),cos(theta))*dist;            \n            z = z-reflPos;\n        }\n        }\n\n       \n        \n        if (dot(z,z) > 80.0) {\n            escaped = i;\n            break;\n        }\n    }\n\n\t\t\t\n    float potential=logPotential(length(z),float(escaped));\n    \n    vec3 iterationCol = vec3(palette(potential/20., vec3(0.3,0.4,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.22)));\n\t\t\n\n    aacol+= vec3((escaped>=0) ? iterationCol : vec3(0.));\n    }\n    }\n    fragColor=vec4(aacol.xyz/4.,1.);\n}\n\n","name":"Image","description":"","type":"image"}]}