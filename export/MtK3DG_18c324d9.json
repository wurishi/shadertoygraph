{"ver":"0.1","info":{"id":"MtK3DG","date":"1476614054","viewed":320,"name":"Reflections And Patterns","username":"decrooks","description":"Raytracing with signed distance functions, an evolving pattern and reflections.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","reflection","torus","sphere","pattern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by David Crooks\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// This is just me learning raytracing.\n//Use of signed differance functions based on work by inigo quilez  e.g. https://www.shadertoy.com/view/Xds3zN  which I'm sure most people on theis site will be familar with.\n//https://iquilezles.org/articles/distfunctions\n// Other sources, for reflection etc:\n//https://www.cs.unc.edu/~rademach/xroads-RT/RTarticle.html#internet\n//https://www.cs.uaf.edu/2012/spring/cs481/section/0/lecture/02_07_recursion_reflection.html\n\n#define TWO_PI 6.283185\n#define PI 3.14159265359\n\n\nstruct Ray {\n   vec3 origin;\n   vec3 direction;\n};\n\nstruct LightColor {\n\tvec3 diffuse;\n\tvec3 specular;\n};\n    \n    \nstruct Material {\n    LightColor  color;\n    float shininess;\n    float mirror;\n    float refractiveIndex;\n    float opacity;  \n};\n    \n    \nstruct MapValue {\n    float \t  signedDistance;\n    Material  material;\n};\n\nstruct Trace {\n    float    dist;\n    vec3     p;\n    vec3 normal;\n    Ray \t ray;\n    Ray reflection;\n   //Ray refraction;\n    Material material;\n    bool hit;\n};\n    \n\nstruct PointLight {\n    vec3 position;\n    LightColor color;\n};\n    \nstruct DirectionalLight {\n    vec3 direction;\n    LightColor color;\n};\n    \nPointLight  light1,light2,light3;\nDirectionalLight dirLight;\n\nMaterial blackMat,whiteMat,bluishMat,yellowMat,oscMat,tableMat,tableDarkMat;\n\n\n    \nvec3 rayPoint(Ray r,float t) {\n \treturn r.origin +  t*r.direction;\n}\n\nbool checker3D(vec3 p)\n{\n    //Is this point in a white cube or a black cube in a 3d checkerboard? \n    p = floor(p);\n    \n    if (mod(p.x + p.y + p.z, 2.0)>0.0){\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\n\nMapValue cube( vec3 p, float d , Material m)\n{\n  MapValue mv;\n  mv.material = m;\n  mv.signedDistance = length(max(abs(p) -d,0.0));\n  return mv; \n}\n\nMapValue torus( vec3 p, vec2 t ,Material m)\n{\n  MapValue mv;\n  mv.material = m;\n \n   vec2 q = vec2(length(p.xz)-t.x,p.y);\n  mv.signedDistance =length(q)-t.y;\n    return mv;\n}\nMapValue checkerdCube( vec3 p, float d , Material m1,Material m2)\n{\n  Material  m;\n    if(checker3D(6.0*p)){\n        m = m1;\n    }\n    else {\n       m = m2 ;\n    }\n  return cube(p,d, m); \n}\n \nMapValue xzPlane( vec3 p ,float y, Material m)\n{\n  MapValue mv;\n  mv.material = m;\n  mv.signedDistance = p.y - y;\n  return mv;\n}\n\nMapValue tableTop( vec3 p ,float y, Material m1,Material m2)\n{\n \tMaterial  m;\n    //Draw a pattern on the table top by taking a 2d slice through a 3d checkerboard.\n    float t = iTime;\n    float a = sqrt(3.0)/2.0;\n   \tvec3 u = vec3(1.0,-0.5,-0.5);\n   \tvec3 v = vec3(0,a,-a);\n    \n    vec3 n = vec3(0.5);\n   \tfloat scaleFactor = 3.0;\n    vec2 q = p.xz*scaleFactor;\n    vec3 plane = n + q.x*u +q.y*v;\n    \n    \n    if(checker3D(plane + vec3(0.2*t))){\n        m = m1;\n    }\n    else {\n       m = m2 ;\n    }\n    \n  return xzPlane( p ,y, m);\n}\n\nMapValue plane(vec3 p, vec3 origin, vec3 normal , Material m ){\n  vec3 a = p - origin;\n  MapValue mv;\n  mv.material = m;\n  mv.signedDistance = dot(a,normal);\n  return mv;\n}\n\nMapValue sphere(vec3 p, vec3 center, float radius, Material m) {\n  MapValue mv;\n  mv.material = m;\n  mv.signedDistance = distance(p, center) - radius;\n  return mv;\n}\n\nMapValue addObjects(MapValue d1, MapValue d2 )\n{\n    if (d1.signedDistance<d2.signedDistance) {\n    \treturn    d1 ;\n    }\n    else {\n    \treturn d2;\n    }\n}\n\n\nMapValue subtractObjects( MapValue A, MapValue B )\n{\n    //A-B\n    if (-B.signedDistance>A.signedDistance){\n        B.signedDistance *= -1.0;\n        B.material = A.material;\n    \treturn    B ;\n    }\n    else {\n       \n    \treturn A;\n    }\n}\n\nMapValue intersectObjects( MapValue d1, MapValue d2 )\n{\n    if (d1.signedDistance>d2.signedDistance){\n    \treturn    d1 ;\n    }\n    else {\n        d2.material = d1.material;\n    \treturn d2;\n    }\n}\n\nvoid setMaterials() {\n    float t  = iTime;\n    float s = 0.4*(1.0+sin(t));\n    vec3 specular = vec3(0.3); \n    float shininess = 16.0;\n    blackMat = Material(LightColor(vec3(0.0,0.0,0.01),vec3(0.1,0.1,0.1)) ,35.0,0.75,1.0,1.0);\n    whiteMat = Material(LightColor(0.95*vec3(1.0,1.0,0.9),0.3*vec3(1.0,1.0,0.9)) ,shininess ,0.75,1.0,1.0);\n    bluishMat = Material(LightColor(vec3(0.3,0.3,0.5),vec3(0.3,0.3,0.5)) ,shininess ,0.75,1.0,1.0);\n    yellowMat = Material(LightColor(vec3(0.6,0.6,0.4),vec3(0.8,0.8,0.2)) ,shininess ,0.75,1.0,1.0);\n    oscMat = Material(LightColor(vec3(1.0-s,1.0-s,0.9-0.7*s),vec3(1.0-s,1.0-s,0.9-0.7*s)) ,shininess ,0.75,1.0,1.0);\n    tableMat = Material(LightColor(vec3(0.33,0.33,0.31),vec3(0.33,0.33,0.31)) ,shininess ,0.00,1.0,1.0);\n    tableDarkMat = Material(LightColor(vec3(0.3,0.3,0.32),vec3(0.33,0.33,0.31)) ,shininess ,0.75,1.0,1.0);   \n}\n\nMapValue map(vec3 p){\n   \tfloat t  = iTime;\n   \tMapValue bigSphere = sphere(p,vec3(0.0),0.5,bluishMat);\n    \n    bigSphere = subtractObjects(bigSphere,sphere(p,0.5*vec3(cos(0.9*t),1.0,sin(0.9*t)),0.3,oscMat));\n    float ssh = 0.85;\n    MapValue obj  = addObjects(sphere(p,0.55*vec3(cos(t),ssh,sin(t)),0.125,blackMat),sphere(p,0.55*vec3(cos(t+ TWO_PI/3.0),ssh,sin(t+TWO_PI/3.0)),0.125,whiteMat));\n    obj  = addObjects(obj,sphere(p,0.55*vec3(cos(t+ 2.0*TWO_PI/3.0),ssh,sin(t + 2.0*TWO_PI/3.0)),0.125,yellowMat));                      \n    obj  = addObjects(obj,bigSphere);\n    obj  = addObjects(obj,torus(p+vec3(0.0,0.15+ 0.2*sin(t),0.0),vec2(0.75,0.1),whiteMat));\n   \tobj  = addObjects( obj ,tableTop(p,-0.5,tableMat,tableDarkMat));\n    obj  = addObjects( obj ,xzPlane(-p,-2.0,yellowMat));\n   \treturn obj;\n}\n\nvec3 calculateNormal(vec3 p) {\n    float epsilon = 0.001;\n    \n    vec3 normal = vec3(\n                       map(p +vec3(epsilon,0,0)).signedDistance - map(p - vec3(epsilon,0,0)).signedDistance,\n                       map(p +vec3(0,epsilon,0)).signedDistance - map(p - vec3(0,epsilon,0)).signedDistance,\n                       map(p +vec3(0,0,epsilon)).signedDistance - map(p - vec3(0,0,epsilon)).signedDistance\n                       );\n    \n    return normalize(normal);\n}\n\nTrace castRay(in Ray ray, float maxDistance){\n    float dist = 0.01;\n    float presicion = 0.001;\n\tvec3 p;\n    MapValue mv;\n    bool hit = false;\n    for(int i=0; i<64; i++){\n    \tp = rayPoint(ray,dist);\n       \tmv = map(p);\n         dist += 0.5*mv.signedDistance;\n        if(mv.signedDistance < presicion )\n        {\n          hit = true; \n            break;\n        } \n         if(dist>maxDistance) break;\n       \n    }\n    return Trace(dist,p,p,ray,ray,mv.material,hit);\n}\n\nTrace traceRay(in Ray ray, float maxDistance) {\n    Trace trace = castRay(ray,maxDistance);\n    trace.normal = calculateNormal(trace.p);\n    trace.reflection = Ray(trace.p,reflect(ray.direction, trace.normal));\n\n    return trace;\n}\n\nfloat castShadow(in Ray ray, float dist){\n    Trace trace = castRay(ray,dist);\n    float maxDist = min(1.0,dist);\n    float result = trace.dist/maxDist;\n   \n    return clamp(result,0.0,1.0);\n}\n\nRay cameraRay(vec3 viewPoint, vec3 lookAtCenter, vec2 p , float d){ \n\tvec3 v = normalize(lookAtCenter -viewPoint);\n    \n    vec3 n1 = cross(v,vec3(0.0,1.0,0.0));\n    vec3 n2 = cross(n1,v);  \n        \n    vec3 lookAtPoint = lookAtCenter + d*(p.y*n2 + p.x*n1);\n                                    \n    Ray ray;\n                    \n    ray.origin = viewPoint;\n   \tray.direction =  normalize(lookAtPoint - viewPoint);\n    \n    return ray;\n}\n\nvec3 diffuseLighting(in Trace trace, vec3 lightColor,vec3 lightDir){\n    float lambertian = max(dot(lightDir,trace.normal), 0.0);\n  \treturn  lambertian * trace.material.color.diffuse * lightColor; \n}\n\n\n\nvec3 cookTorranceSpecularLighting(in Trace trace, vec3 lightColor,vec3 L){\n    //https://en.wikipedia.org/wiki/Specular_highlight#Cook.E2.80.93Torrance_model\n    //https://renderman.pixar.com/view/cook-torrance-shader\n    \n    \n    vec3 V = -trace.ray.direction;\n\n    vec3 H = normalize(L + V);\n    \n    float NdotH = dot(trace.normal, H);\n    float NdotV = dot(trace.normal, V);\n    float VdotH = dot(V ,H );\n    float NdotL = dot(trace.normal , L);\n    \n    float lambda  = 0.25;\n    float F = pow(1.0 + NdotV, lambda);\n    \n    float G = min(1.0,min((2.0*NdotH*NdotV/VdotH), (2.0*NdotH*NdotL/VdotH)));\n    \n    \n   // Beckmann distribution D\n    float alpha = 5.0*acos(NdotH);\n    float gaussConstant = 1.0;\n\tfloat D = gaussConstant*exp(-(alpha*alpha));\n    \n    \n    float c = 1.0;\n    float specular = c *(F*D*G)/(PI*NdotL*NdotV);\n    \n    \n    return specular * trace.material.color.specular * lightColor;\n}\n\n\n\n\nvec3 pointLighting(in Trace trace, PointLight light){\n    vec3 lightDir = light.position - trace.p;\n\tfloat d = length(lightDir);\n  \tlightDir = normalize(lightDir);\n   \n  \tvec3 color =  diffuseLighting(trace, light.color.diffuse, lightDir);\n\n     color += cookTorranceSpecularLighting(trace, light.color.specular, lightDir);\n\n    float  attenuation = 1.0 / (1.0 +  0.1 * d * d);\n    float shadow = castShadow(Ray(trace.p,lightDir),d);\n    color *= attenuation*shadow;\n    return  color;\n}\n\nvec3 directionalLighting(Trace trace, DirectionalLight light){\n\n    vec3 color =  diffuseLighting(trace, light.color.diffuse, light.direction);\n    \n    color += cookTorranceSpecularLighting(trace, light.color.specular, light.direction);\n    \n    float shadow = castShadow(Ray(trace.p,light.direction),3.0);\n    color *= shadow;\n    return  color;\n}\n\n\nvoid setLights(){\n  \tfloat  time = iTime;\n    vec3 specular = vec3(0.7);\n  \tlight1 = PointLight(vec3(cos(1.3*time),1.0,sin(1.3*time)),LightColor( vec3(0.7),specular));\n  \tlight2 = PointLight(vec3(0.7*cos(1.6*time),1.1+ 0.35*sin(0.8*time),0.7*sin(1.6*time)),LightColor(vec3(0.6),specular)); \n    light3 = PointLight(vec3(1.5*cos(1.6*time),0.15+ 0.15*sin(2.9*time),1.5*sin(1.6*time)),LightColor(vec3(0.6),specular));\n    dirLight = DirectionalLight(normalize(vec3(0.0,1.0,0.0)),LightColor(vec3(0.1),vec3(0.5)));\n} \n\n\nvec3 lighting(in Trace trace){\n    vec3 color = vec3(0.01,0.01,0.1);//ambient color\n        \n\tcolor += pointLighting(trace, light1);\n\tcolor += pointLighting(trace, light2) ;\n    color += pointLighting(trace, light3) ;\n\tcolor += directionalLighting(trace, dirLight);\n    \n    return color;\n}\n\nfloat rayDistance(Ray r,vec3 p){\n    vec3 v = r.origin - p;\n    return length(v - dot(v,r.direction)*r.direction);\n}\n\nvec3  drawLight(PointLight light, Ray ray, vec3 color, float dist){\n    float rayDist = rayDistance(ray,light.position);\n    \n    \n    float lightRadius = 0.1;\n    if(rayDist < lightRadius && distance(light.position,ray.origin) < dist){\n       float a = 1.0-rayDist/lightRadius;\n       return  mix(color,vec3(1.0),a*a*a*a);\n    }\n    return color;\n}\n\nvec3 drawLights(Ray ray,vec3 color,float dist){\n    vec3 c = drawLight(light1,ray,color,dist);\n    c = drawLight(light2,ray,c,dist);\n    c = drawLight(light3,ray,c,dist);\n    return c;\n}\n\nvec3 render(vec2 p){\n    vec3 viewpoint = vec3(-1.0,1.7,-2.2);\n    \n    vec3 lookAt = vec3(0.0,-0.1,0.0);\n    \n  \tRay ray = cameraRay(viewpoint,lookAt,p,2.4);\n    vec3 color = vec3(0.0);\n    float frac = 1.0;\n   \n    float d = 0.0;\n    float maxDist = 10.0;\n    for(int i = 0; i<10; i++) {\n        Trace trace = traceRay(ray,maxDist);\n        \n \t\tif(i==0) d = trace.dist;\n        maxDist -= trace.dist;\n       \n    \tcolor += lighting(trace)*(1.0 - trace.material.mirror)*frac;\n        if(!trace.hit) break;\n        \n        frac *= trace.material.mirror;\n        if(frac < 0.1 || maxDist < 0.0 ) break;\n        ray = trace.reflection;\n    }\n   \t\n    \n    //color = drawLights(ray,color,10.0);\n   \treturn color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    \n  \tsetLights();\n    setMaterials();\n    \n   \tvec3 colorLinear =  render(p);\n    float screenGamma = 2.2;\n    vec3 colorGammaCorrected = pow(colorLinear, vec3(1.0/screenGamma));\n\tfragColor = vec4(colorGammaCorrected,1.0);\n}","name":"Image","description":"","type":"image"}]}