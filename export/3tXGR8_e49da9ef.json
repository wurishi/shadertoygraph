{"ver":"0.1","info":{"id":"3tXGR8","date":"1555545281","viewed":184,"name":"Sun on the water","username":"jojobavg","description":"raymarching first test scene\nNoise based on Morgan McGuire @morgan3d https://www.shadertoy.com/view/4dS3Wd","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime\n\n\nfloat random (float x) {\n    return fract(sin(x)*1e4);\n}\n\nfloat noise2(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,37,289);\n  vec4 pos=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 val=mix(fract(sin(pos)*7894.552), fract(sin(pos+st.x)*7894.552), p.x);\n  vec2 val2=mix(val.xz,val.yw, p.y);\n  return mix(val2.x,val2.y, p.z);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise( vec3 p) {\n    const vec3 step = vec3(110.0, 241.0, 171.0);\n\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n    // For performance, compute the base input to a\n    // 1D random from the integer part of the\n    // argument and the incremental change to the\n    // 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix( mix(mix(random(n + dot(step, vec3(0.0,0.0,0.0))),\n                        random(n + dot(step, vec3(1.0,0.0,0.0))),\n                        u.x),\n                    mix(random(n + dot(step, vec3(0.0,1.0,0.0))),\n                        random(n + dot(step, vec3(1.0,1.0,0.0))),\n                        u.x),\n                u.y),\n                mix(mix(random(n + dot(step, vec3(0.0,0.0,1.0))),\n                        random(n + dot(step, vec3(1.0,0.0,1.0))),\n                        u.x),\n                    mix(random(n + dot(step, vec3(0.0,1.0,1.0))),\n                        random(n + dot(step, vec3(1.0,1.0,1.0))),\n                        u.x),\n                u.y),\n            u.z);\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat sphere( vec3 p, in vec3 centerPos, float radius) {\n\treturn length(p-centerPos) - radius;\n}\n\nfloat fire( vec3 p, vec3 centerPos, float scale,float radius ) {\n  float l=min(length(p-centerPos)/radius,1.0)*0.7+0.3;\n  float nl = (1.0-l);\n  float x=(noise((p+sin(time)*2.0*l)*0.2)*2.0-1.0)*15.0*nl;\n  float y=(noise((p+sin(time+5.0)*2.0*l)*0.2)*2.0-1.0)*15.0*nl;\n  float z=(noise((p+sin(time+3.5)*2.0*l)*0.2)*2.0-1.0)*15.0*nl;\n  p+=vec3(x,y,z);\n  return max((noise(p*scale)+noise(p*2.0*scale)*0.5+\n              noise(p*3.0*scale)*0.33+\n              noise(p*4.0*scale)*0.25)*0.4807-(l*l*l*l),0.0);\n}\n  \nfloat flow(vec3 p,float scale){\n  float l=length(p-vec3(0,-20,0));\n  return mix(sin(l-time*10.0)+cos(l-time*10.0),\n             0.0,\n             min(1.0-(100.0-l)*0.01,1.0));\n}\nfloat map(vec3 p){\n  return sphere(p,vec3(0.0,0.0,0.0),20.0);\n  }\n  \nfloat map2(vec3 p){\n  return sphere(p,vec3(0.0,0.0,0.0),10.0);\n  }\n \nfloat mapHyper(vec3 p){\n  return fire(p,vec3(0.0,0.0,0.0),0.3,20.0);\n  }  \n\n  \nfloat dot2(  vec3 v ) { return dot(v,v); }\n\nfloat udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    \n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross( ba, ad );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat map3(vec3 p){\nreturn udQuad(p,\n              vec3(10000, 20.0, 10000.0),\n              vec3(-10000.0, 20.1, 10000.0), \n              vec3(-10000.0, 20.0, -10000.0),\n              vec3(10000.0, 20.0, -10000.0));\n  }\n  \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  vec3 s=vec3(0,0,-100);\n  float t2=(time*0.5+10.0);\n  s.y = -abs(cos(t2*0.1)*100.0);\n  s.xz *= rot(t2*0.1);\n \n  vec3 t=vec3(0,0,0);\n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n  vec3 r=normalize(uv.x*cx+uv.y*cy+cz*0.7);\n  \n// real fireball/////////////////////////\n  vec3 p=s;\n  float dd=0.0;\n  for(int i=0; i<60; ++i) {\n    float d=map(p);\n    if(d<0.0001) break;\n    if(dd>500.0) {dd=500.0; break;}\n    p+=d*r*0.8;\n    dd+=d;\n  }\n  \n  vec2 c= vec2(0,0);\n  for(int i=0; i<400; ++i) {\n    float d=map(p);\n    float d2=map2(p);\n    c+=vec2(mapHyper(p)*0.018,0);\n    c.y=1.0;\n    if(dd>=500.0) {dd=500.0;c.y=0.0; break;}\n    if( d2<0.001 ){c.x+=0.5;c.y=2.0;break;}\n    if( d>0.001 ){ break;}\n    p+=r*(0.1);\n    dd+=0.1;\n  }\n  \n  //////////////////////////////////////////////////////////////////////////////////////////////\n  \n  //water\n  p=s;\n  dd=0.0;\n  int hit = 1;\n  for(int i=0; i<60; ++i) {\n    float d=map3(p);\n    if(d<0.0001) break;\n    if(dd>500.0) {dd=500.0;hit =0; break;}\n    p+=d*r*0.8;\n    dd+=d;\n  }\n  // reflection on the water\n  vec2 off=vec2(0.01,0);\n  p.y=p.y+flow( p,0.1)*2.0;\n  vec3 n=normalize(map3(p)-vec3(map3(p-off.xyy), map3(p-off.yxy), map3(p-off.yyx)));\n  if(hit==1){r=reflect(p-s,n);s=p-r;r=normalize(r);}\n    \n  p=s;\n  dd=0.0;\n  for(int i=0; i<60; ++i) {\n    float d=map(p);\n    if(d<0.0001) break;\n    if(dd>500.0) {dd=500.0; break;}\n    p+=d*r*0.8;\n    dd+=d;\n  }\n  \n  //sky\n  float dotr=(dot(r,normalize(vec3(0,-1,1))));\n    \n  vec3 sky = mix(vec3(0.2,0.1,0.1),\n                 vec3(0.1,0.1,0.2),\n                 min(dotr+0.2,1.0));\n    \n  vec3 star=vec3(dot(r,normalize(vec3(1.0,0.0,0.0))),\n                 dot(r,normalize(vec3(0.0,1.0,0.0))),\n                 dot(r,normalize(vec3(0.0,0.0,1.0))));\n    \n  float starPoint=noise(star*200.0)*30.0;\n    \n  vec3 b = mix(vec3(1.0,1.0,0.5),\n               sky,\n               min(starPoint+0.2,1.0));\n  \n  // fire ball reflection\n  vec2 c2= vec2(0,0);\n  if(hit==1){\n    for(int i=0; i<400; ++i) {  \n      float d2=map2(p);\n      c2+=vec2(mapHyper(p)*0.018,0);\n      c2.y=1.0;\n      if(dd>=500.0) {dd=500.0;c2.y=0.0; break;}\n      if( d2<0.001 ){c2.x+=0.5;c2.y=2.0;break;}\n      p+=r*(0.1);\n      dd+=0.1;\n      }\n  }\n  \n  //compositing\n  vec3 col=vec3(0.0);\n  if(c.y==1.0)col = mix(vec3(1.0,0.0,0.0),vec3(1.0,1.0,0.0),c.x);\n  if(c.y==2.0)col = mix(vec3(1.0,0.0,0.0),vec3(1.0,1.0,0.0),c.x);\n \n  vec3 col2=vec3(0.0);\n  if(c2.y==1.0) col2 = mix(vec3(1.0,0.0,0.0),vec3(1.0,1.0,0.0),c2.x);\n  if(c2.y==2.0) col2 = mix(vec3(1.0,0.0,0.0),vec3(1.0,1.0,0.0),c2.x);\n  if(c2.y==0.0) col2 = b;\n  else{\n    if(c2.y!=2.0)col2 = mix(b,col2,c2.x);\n  }\n  if(c.y==0.0)col = col2;\n  else {\n    if(c.y!=2.0)col = mix(col2,col,c.x);\n  }\n  \n  fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}