{"ver":"0.1","info":{"id":"DlXXWr","date":"1674602920","viewed":176,"name":"Worley Crater","username":"enuyeel","description":"Worley Crater by Yune '23 (twitter: @yuneismyname / website: https://yuneismyname.com)\n\nA detailed breakdown of @OliverSchaff's crater texture generation logic demonstrated in his submission 'Apollo 2001'.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","noise","texture","heightmap","crater"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Worley Crater\n// by Yune 2023 (twitter: @yuneismyname / website: https://yuneismyname.com)\n// https://www.shadertoy.com/view/DlXXWr\n\n/*\n    A breakdown of @OliverSchaff's crater-ish (in cross-section) 2D heightmap\n    texture generation logic demonstrated in his submission 'Apollo 2001' \n    [https://www.shadertoy.com/view/ttf3DX#].\n    \n    I came across @OliverSchaff's submission on Shadertoy during my research \n    on the topic of the procedurally generated planet and thought its crater\n    generation logic is worth delving into. Hopefully, this would help anybody\n    looking into the same stuff ;)\n    \n    TODO:\n        - Translate to 3D noise.\n        - [Debug Only Feature] Plotting each random points as one pixel wide\n        consistently; dFdx, dFdy might be the key?\n        \n    Updated:\n        - (02/20/23) Added a diagonal scrolling to spice things up a lil'.\n        - (02/07/23) Removed a couple of preprocessor directives (ITERATIONS, ...)\n    inside the worleyCraterNoise2D(), and added fbm() to achieve similar result.\n        - (02/01/23) Fixed division by zero issue, which caused gaps realizing\n    intermittently across the grid.\n*/\n\n//----------------------------------------------------------------------------------------\n//[https://www.shadertoy.com/view/ttf3DX#]\n//by @OliverSchaff \nfloat craterProfile(\n    in float pX // px; positive X [0, 1]\n)\n{\n    //The rest of the lines are mathematical black majik;\n    //refer to the below link for visualization\n    //https://graphtoy.com/?f1(x,t)=0.03*(1.0-smoothstep(0.0,0.08,x))&v1=false&f2(x,t)=1.0-smoothstep(0.4,0.455,x)&v2=false&f3(x,t)=0.3-0.85*sqrt(abs((x+0.5)-(x+0.5)*(x+0.5)))&v3=false&f4(x,t)=f1(x,t)+(f2(x,t)*f3(x,t))&v4=false&f5(x,t)=f4(x,t)+clamp((0.05/x-0.05)*smoothstep(0.4,0.45,x),0.0,1.0)&v5=true&f6(x,t)=&v6=false&grid=1&coords=1.0240853083253485,0.3403142695827652,3.475972556840282\n    float z = 0.03 * (1.0 - smoothstep(0.0, 0.08, pX));\n    float a = 1.0 - smoothstep(0.4, 0.455, pX);\n\tfloat b = 0.3 - 0.85 * sqrt(abs((pX + 0.5) - (pX + 0.5) * (pX + 0.5)));\n    z += b * a;\n    z += clamp((0.05 / pX - 0.05)*smoothstep(0.4, 0.45, pX), 0.0, 1.0);\n    \n    return z;\n}\n\nfloat worleyCraterNoise2D(\n    in vec2 p \n#ifdef DEBUG_DISPLAY\n    ,out float mind\n#endif\n)\n{   \n    //return height value\n    float height = 0.0;\n    \n#ifdef DEBUG_DISPLAY\n    //Euclidean distance; \n    //sqrt((2.0)^2 + (2.0)^2) for the initial maximum distance\n    mind = SQRT8; \n#endif\n    //maximum value returned by the hash function\n    float radius = 1.0;\n    \n    //returns the cell current p belongs to\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n\n    //check total of 9 cells; 8 neighboring cells + (1) itself; Worley noise style\n    for (int i = -1; i <= 1; ++i)\n    {\n        for (int j = -1; j <= 1; ++j)\n        {\n            //random point's offset from the (bottom-left) lattice of the cell it belongs to\n            vec2 rp = hash22(ip + vec2(i, j));\n\n            //distance between the random point and the current input point; [0, sqrt(8)]\n            float d = length(vec2(i, j) + rp - fp); //(ip + vec2(i, j) + rp) - (ip + fp);\n\n#ifdef DEBUG_DISPLAY\n            //keeping track of the minimum distance for debugging purpose; Worley noise style\n            mind = min(mind, d);\n#endif\n\n            //(random) radius of the crater centered at random point (inside neighboring grid);\n            //notice the returned hash depends on the nearest grid's (bottom-left) lattice\n            float radius = hash12(ip + vec2(i, j));\n\n            //'d' is divided by 'radius' in the next line, so we have to make sure 'radius' is not (near) 0.\n            float isZero = step(-EPSILON, radius) * (1.0 - step(EPSILON, radius));\n            //set 'radius' to 1.0 if it's near 0.\n            radius = (1.0 - isZero) * radius + isZero * 1.0;\n\n            //this line scales the distance 'd' accordingly to its radius counterpart\n            d /= radius;\n\n            //current crater profile returns negative value, so it's a signed one;\n            //hence the 'offset'\n            float ho = craterProfile(d);\n\n            height += ho;\n        }\n    }\n        \n    //original code returns this line for extra height\n    //return height + 0.5;\n    return height;\n}\n//----------------------------------------------------------------------------------------\n\n//increase iteration for additional layers of frequent & smaller (in diameter) craters \nfloat fbm(\n    vec2 p\n#ifdef DEBUG_DISPLAY\n    ,out float mind\n#endif\n)\n{\n    float lacunarity = 2.0;\n    float gain = 0.5;\n    \n    float f = 1.0;\n    float amplitude = 1.0;\n    //float nf = 0.0;\n    \n    float noise = 0.0;\n    \n    for(int i = 0; i < 2; ++i)\n    {\n#ifdef DEBUG_DISPLAY\n        float signal = worleyCraterNoise2D(f * p, mind);\n#else\n        float signal = worleyCraterNoise2D(f * p);\n#endif  \n        noise += amplitude * signal;\n        //nf += amplitude;\n\n        f *= lacunarity;\n        amplitude *= gain;\n    }\n\n    return noise;\n    //return noise / nf;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float uvScale = 20.0;\n    float uvOffset = 0.0;\n    uv *= uvScale;\n    uv += uvOffset;\n    uv += vec2(iTime) * 2.0;\n\n    vec3 color = vec3(0.0);\n\n#ifdef DEBUG_DISPLAY\n    float mind; //minimum distance\n    color = vec3(fbm(uv, mind));\n    color += 1.0 - step(POINT_SIZE * uvScale, mind); //add debug-only specks\n#else\n    color = vec3(fbm(uv));\n#endif\n    \n    //color = color / (color + vec3(1.0)); //Reinhard Tonemapping\n    //color = pow(color, vec3(INV2P2));    //Gamma Correction\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//* Uncomment this line to display the random point on each 1x1 grid.\n//#define DEBUG_DISPLAY\n\n#define POINT_SIZE 0.002\n#define INV2P2 0.4545454545454545\n#define SQRT8 2.82842712475\n#define EPSILON 0.0001\n\n//----------------------------------------------------------------------------------------\n// [https://www.shadertoy.com/view/4djSRW]\n// Hash without Sine\n// MIT License...\n// Copyright (c)2014 David Hoskins.\n// by @Dave_Hoskins\n\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n//----------------------------------------------------------------------------------------","name":"Common","description":"","type":"common"}]}