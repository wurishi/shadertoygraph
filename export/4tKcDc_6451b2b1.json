{"ver":"0.1","info":{"id":"4tKcDc","date":"1538007430","viewed":89,"name":"Wine bottle shape","username":"toothmang","description":"just a wine bottle","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["shape","wine"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGRr","filepath":"/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","previewfilepath":"/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat easeInOutQuad(float t) \n{ \n    return t<.5 ? 2.*t*t : -1.+(4.-2.*t)*t;\n}\n\nvec4 botBottleNeck = vec4(0.2, 0.4, 0.2, 0.1);\nvec4 topBottleNeck = vec4(0.2, 0.5, 0.2, 0.1);\nvec4 bottleBase = vec4(0.4, 0.4, 0.4, 0.2);\n\nvec4 bgColor = vec4(vec3(0.9), 1.0);\nvec4 bottleColor = vec4(0.2, 0.6, 0.01, 1.0);\n\nfloat attenuation = 1.;\nfloat shininess = 5.;\n\n// Text taken from https://github.com/knarkowicz/ShadertoyText\nfloat GlyphSDF( vec2 p, float glyph )\n{\n    p = abs( p.x - .5 ) > .5 || abs( p.y - .5 ) > .5 ? vec2( 0. ) : p;\n    return 2. * ( texture( iChannel2, p / 16. + fract( vec2( glyph, 15. - floor( glyph / 16. ) ) / 16. ) ).w - 127. / 255. );\n}\t\n\nvoid Text( inout vec3 color, vec2 p )\n{    \n    float glyphRatio = 2.0;\n    vec2 glyphScale = 6. * vec2( 1., glyphRatio );\n    vec2 t = floor( p / glyphScale );\n\n    uint v = 0u;\n    v = t.y == 0. ? ( t.x < 4. ? 1768972627u : ( t.x < 8. ? 1461743205u : 6647401u ) ) : v;\n\tv = t.x >= 0. && t.x < 12. ? v : 0u;\n\n\tfloat c = float( ( v >> uint( 8. * t.x ) ) & 255u );\n    \n    p = ( p - t * glyphScale ) / glyphScale;\n    p.x = ( p.x - .5 ) / glyphRatio + .5;\n\n    float sdf = GlyphSDF( p, c );\n    if ( c != 0. )\n    {\n    \tcolor = mix( vec3( .4 ), color, smoothstep( -.04, +.04, sdf ) );\n    }\n}\n\n\nvec4 lighting(vec3 normalDirection)\n{\n    vec3 viewDirection = vec3(0., 0., 1.);\n    vec3 lightDirection = normalize(vec3(0., 0., 1.));\n   \n    float dn = dot(normalDirection, lightDirection);\n    \n    vec3 diffuseReflection = attenuation * bottleColor.xyz * max(0.0, dn);\n    \n    vec3 specularReflection = vec3(0.);\n    if (dn >= 0.0) // light source on the wrong side?\n    {\n        specularReflection = attenuation * vec3(1.) \n            * pow(max(0.0, dot(reflect(-lightDirection, normalDirection), viewDirection)),\n                  shininess);\n    }\n    return vec4(diffuseReflection + specularReflection, 1.);\n}\n\nvec2 rotate(vec2 uv)\n{\n    float ar = iResolution.x / iResolution.y;\n    vec2 diff = vec2(0.5) - uv;\n    float dl = length(diff);\n    diff = normalize(diff);\n    \n    diff = vec2(diff.x * ar, diff.y);\n    \n    float t = iTime * 1.5;\n    \n    float st = sin(t);\n    float ct = cos(t);\n    \n    mat2 rot = mat2(ct, st,\n                    -st, ct);\n    \n    vec2 uvr = rot * diff;\n    return vec2(0.5) + dl * uvr;\n    \n    vec2 result = vec2(0.5) + (dl * normalize(vec2(ct * diff.x, st * diff.y)));\n    \n    return result;\n}\n\nbool within(vec4 rect, vec2 uv, out vec4 col)\n{\n    vec2 diff = uv - rect.xy;\n    \n    bool result = (diff.x >= 0. && diff.x < rect.z && diff.y >= 0. && diff.y < rect.w);\n    \n    // Let's add some flare!\n    if (result)\n    {\n        float yv = diff.y/rect.w;\n        col = vec4(vec3(yv), 1.);\n        \n        // Generate faked normal from the y-coordinate\n        float ny = (0.5 - yv) / 0.5;\n        float nz = 1. - ny;\n        vec3 fakeNormal = normalize(vec3(0., ny, nz));\n        col = lighting(fakeNormal);\n            \n    }\n    else\n    {\n        col = bgColor;\n    }\n    \n    return result;\n}\n\nbool withinNeck(vec4 neck, vec2 uv, bool top, out vec4 col)\n{\n    bool evenIn = within(neck, uv, col);\n    \n    if (!evenIn)\n    {\n        return false;\n    }\n\n    float tx = (uv.x - neck.x) / neck.z;\n    float ty = (uv.y - neck.y) / neck.w;\n    \n    if (!top) ty = 1. - ty;\n    \n    //ty = clamp(ty, 0.1, 1.);\n    \n\n    float ex = easeInOutQuad(tx);\n    float ey = easeInOutQuad(ty);\n    \n    float tc = 0.25;\n    \n    bool result = ex > ty || ty < tc;\n    \n    if (result)\n    {\n        float shade = ty;\n\n        // Generate faked normal from the y-coordinate\n        float nz = 1. - shade;\n        vec3 fakeNormal = normalize(vec3(0., shade, nz));\n        col = lighting(fakeNormal) * 0.75;\n    }\n    else\n    {\n        col = bgColor;\n    }\n    \n    return result;\n}\n\nvec4 bottle(vec2 uv)\n{\n    vec2 og_uv = uv;\n    uv = rotate(uv);\n    vec4 col = bgColor;\n    if (within(bottleBase, uv, col))\n    {\n        col *= texture(iChannel0, uv);\n        \n        vec2 p = 2. * uv - vec2(1.);\n        //p.x *= iResolution.x / iResolution.y;    \n        p = p * 125. + vec2(10, 5 );\n\n        vec3 textColor = vec3( mix( 1., .5, smoothstep( 0., 1., abs( .5 - uv.y ) ) ) );\n        Text( textColor, p );\n       \tcol *= vec4( textColor, 1. );\n    }\n    else if (withinNeck(topBottleNeck, uv, true, col))\n    {\n        col *= texture(iChannel1, uv);\n    }\n    else if (withinNeck(botBottleNeck, uv, false, col))\n    {\n        col *= texture(iChannel1, uv);\n    }\n    else\n    {\n        float t = iTime * 0.25;\n        float s = 0.;\n        float ms = modf(t, s);\n        if (ms > 0.5)\n        {\n            ms = (1.0 - ms) / 0.5;\n        }\n        vec4 tc = texture(iChannel0, og_uv);\n        col = vec4(tc.x * ms + tc.y * tc.z * ms);\n    }\n\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = bottle(uv);\n}","name":"Image","description":"","type":"image"}]}