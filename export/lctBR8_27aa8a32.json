{"ver":"0.1","info":{"id":"lctBR8","date":"1732720294","viewed":158,"name":"无限之环-“Rings of Infinity”","username":"xiaoyezhi","description":"此着色器生成一个发光的、多彩的动态螺旋环，旋转并脉动，呈现出迷人的、不断变化的效果。\nThis shader generates a glowing, colorful spiral of dynamic rings, rotating and pulsating in a mesmerizing, ever-changing pattern. Vibrant gradients and a soft glow create a dreamy, sci-fi vortex effect.","likes":7,"published":3,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXSTEPS 128\n#define MAXDIST 100.0\n#define PI 3.1415926535898\n#define TWOPI 6.28318530718\n#define EPSILON 0.01\n\n// 动态控制参数\n#define PHASE mod(iTime * 0.15, 1.0)\n#define RINGS 6.0\n#define GLOW_INTENSITY 1.2\n#define SPIRAL_SPEED 3.0\n\nvec3 glow = vec3(0.0);\n\n// 旋转矩阵\nmat2 rotate2D(float angle) {\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\n// 彩色渐变\nvec3 colorGradient(float t) {\n    return vec3(0.5 + 0.5 * sin(TWOPI * t + vec3(1,2.5, 6)));\n}\n\n// 螺旋位移\nvec3 spiralDisplacement(vec3 p) {\n    float angle = PHASE * TWOPI * SPIRAL_SPEED + p.z * 0.9;\n    p.xy += vec2(cos(angle), sin(angle)) * 0.5;\n    return p;\n}\n\n// 圆环距离函数\nfloat sdRing(vec3 p, float innerRadius, float thickness) {\n    p.xy *= rotate2D(PHASE * TWOPI); // 动态旋转\n    float r = length(p.xy) - innerRadius;\n    return abs(r) - thickness;\n}\n\n// 距离场定义\nfloat map(vec3 p) {\n    p = spiralDisplacement(p); // 应用螺旋位移\n    float d = 1e6;\n    for (float i = 0.0; i < RINGS; i++) {\n        float radius = 1.2 + 0.6 * i; // 每个圆环半径增加\n        float thickness = 0.04 + 0.02 * sin(iTime + i); // 动态厚度\n        d = min(d, sdRing(p, radius, thickness));\n    }\n    return d;\n}\n\n// 距离场交互\nvoid intersect(vec3 ro, vec3 rd) {\n    float d = 0.0;\n    for (int i = 0; i < MAXSTEPS; i++) {\n        vec3 p = ro + rd * d;\n        float res = map(p);\n        if (res < EPSILON || d > MAXDIST) {\n            glow += colorGradient(length(p.xy) * 0.2) * exp(-0.15 * d) * GLOW_INTENSITY;\n            break;\n        }\n        d += res;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // 归一化像素坐标\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n    // 相机设置\n    vec3 ro = vec3(0.0, 0.0, -8.0); // 摄像机位置\n    vec3 rd = normalize(vec3(uv, 1.0)); // 光线方向\n\n    // 计算交点\n    intersect(ro, rd);\n\n    // 渲染最终颜色\n    fragColor = vec4(glow, 1.0);\n}","name":"Image","description":"","type":"image"}]}