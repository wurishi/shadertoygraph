{"ver":"0.1","info":{"id":"clsGRf","date":"1672331297","viewed":101,"name":"Darko's Sea","username":"omegasbk","description":"Just a stylized sea.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sea"],"hasliked":0,"parentid":"Nl23DG","parentname":"Sphere SDF by Darko"},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Made by Darko Supe (omegasbk)\n// 28.12.2022.\n// Made in haste, for fun, hence all the duplications :) \n\n#define MAX_STEPS 100\n#define MAX_DIST 120.\n#define SURF_DIST .05\n\n#define PI 3.14159265359\n\nfloat noise(vec2 uv)\n{\n    return fract(sin(uv.x * 113. + uv.y * 412.) * 6339.);\n}\n\nvec3 noiseSmooth(vec2 uv)\n{\n    vec2 index = floor(uv);\n    \n    vec2 pq = fract(uv);\n    pq = smoothstep(0., 1., pq);\n     \n    float topLeft = noise(index);\n    float topRight = noise(index + vec2(1, 0.));\n    float top = mix(topLeft, topRight, pq.x);\n    \n    float bottomLeft = noise(index + vec2(0, 1));\n    float bottomRight = noise(index + vec2(1, 1));\n    float bottom = mix(bottomLeft, bottomRight, pq.x);\n    \n    return vec3(mix(top, bottom, pq.y));\n}\n\nfloat getDist(vec3 p) \n{\n    float time = iTime * 3.;\n    \n    float x = iTime + (p.x+p.z);\n    float y = iTime + (p.x);\n    \n    float seaDist = dot(p, vec3(0., 1., 0.)) + 5.\n        + sin(iTime*3.4 + p.z / 4.) / 2.\n        + sin(iTime*10.4 + (p.x+p.z) / 2.) / 16. \n        + sin(iTime + p.x / 4.)/4.\n        + noiseSmooth(iTime + p.xz*2.).x/128.\n        + noiseSmooth(iTime + p.zz*2.).x/256.\n        + noiseSmooth(iTime + p.xz/8.).x/2.\n        + noiseSmooth(-iTime + p.xz/4.).x/4.\n        + noiseSmooth(iTime + p.zz/16.).x/2.;\n        \n    vec2 uv = p.xz / 16. + iTime/4.;\n    uv.x += iTime / 40.;\n    vec3 h = noiseSmooth(uv * 4.); \n\n    vec2 uv2 = uv;\n    uv2.x += iTime / 20.;\n\n    vec2 uv3 = uv;\n    uv3.x += iTime / 30.;\n\n    h += noiseSmooth(uv * 8.) * 0.5;\n    h += noiseSmooth(uv2 * 16.) * 0.25;\n    h += noiseSmooth(uv3 * 32.) * 0.125;\n    h += noiseSmooth(uv3 * 64.) * 0.0625;\n\n    h /= 2.;  \n\n    h *= smoothstep(0.2, .6, h);  \n    \n    float landDist = dot(p, vec3(0., 1., 0.)) + 10.;\n    \n    if (seaDist < -0.1) return landDist;\n\n    seaDist = seaDist +h.x/20.;\n    \n    return min(seaDist, landDist);\n}\n\nvec3 getNormal(vec3 p) \n{\n    int body;\n    float d = getDist(p);\n    \n    vec2 e = vec2(.01, 0); \n    \n    vec3 n = d - vec3(\n        getDist(p - e.xyy), \n        getDist(p - e.yxy), \n        getDist(p - e.yyx));\n        \n    return normalize(n);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd)\n{\n    float dO = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * dO;\n        float dS = getDist(p);\n        dO += dS;\n        \n        if (dO > MAX_DIST || dS < SURF_DIST) \n            break;\n    }\n    \n    return dO;\n}\n\nfloat getLight(vec3 p, vec3 rd)\n{\n    vec3 lightVector = vec3(0., 300., 380.);\n    vec3 lightDir = normalize(p - lightVector);\n    \n    float amb = 0.55;\n    float diff = 0.6;\n    float shine = 40.;\n    float spec = 1.;\n    \n    float intensity = 0.9;\n    \n    \n    float lightIntensity = (pow(0.1, 2.) / pow(sqrt(dot(lightVector, lightVector)), 2.)) * intensity;\n    \n    float coeff = -dot(lightDir, getNormal(p));     \n    \n    vec3 ambient = amb * vec3(1.);\n        \n    vec3 diffuse = diff * max(coeff, 0.) * vec3(1.) * intensity;\n       \n    vec3 halfwayDir = normalize(lightDir + rd);  \n    vec3 specular = pow(max(-dot(getNormal(p), halfwayDir), 0.0), shine) * spec * vec3(1.) * intensity;\n    \n    vec3 color = ambient + diffuse + specular;\n    \n    return color.r; \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float time = iTime / 10.;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    vec2 origUv = uv;\n\n    vec3 col = vec3(0);\n    \n    // Camera \n    float focalDist = 0.6;\n    vec3 ro = vec3(0., 0., -focalDist);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 0.) - ro);   \n    \n    float d = rayMarch(ro, rd);\n    vec3 n = vec3(0.);\n    \n    vec3 sky = vec3(0.5, 0.7, 0.85) * ((1. - uv.y) + 1.5) / 2.;\n    \n    if (d < MAX_DIST)\n    {\n        vec3 p = ro + rd * d; \n        float dist = d;\n        float alt = p.y;\n        \n        n = getNormal(p);\n        col = vec3(getLight(p, rd)) * sky; \n                \n        vec3 rdRefl = normalize(refract(rd, n, 1.06));\n        d = rayMarch(p, rdRefl);\n        p = p + rdRefl * d;\n        n = getNormal(p);\n        \n        float mixture = texture(iChannel0, p.xz/10.).r;\n        \n        col = mix(col, vec3(mixture/3.)*vec3(0.8, 0.8, 0.5), max(0.0, -dot(rdRefl, vec3(0., 1., 0.))));\n        \n        col = mix(col, sky, dist/100.);\n    }\n    else\n    {\n        uv.x /= 2.5;\n        uv.x += time / 40.;\n        col = noiseSmooth(uv * 4.); \n\n        vec2 uv2 = uv;\n        uv2.x += time / 10.;\n\n        vec2 uv3 = uv;\n        uv3.x += time / 30.;\n    \n        col += noiseSmooth(uv * 8.) * 0.5;\n        col += noiseSmooth(uv2 * 16.) * 0.25;\n        col += noiseSmooth(uv3 * 32.) * 0.125;\n        col += noiseSmooth(uv3 * 64.) * 0.0625;\n\n        col /= 2.;  \n\n        col *= smoothstep(0.2, .6, col);   \n        col = mix(1. - (col / 7.), sky, 1. - col);\n        col = mix(sky, col, origUv.y+3.4);\n        col = mix(col, sky, 1.-origUv.y);\n        \n        col = mix(col, vec3(0.8,0.8,0.7)*1.67, (1.-smoothstep(0.02, 0.13, length(origUv-vec2(0., 0.3)))));\n    }\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}