{"ver":"0.1","info":{"id":"dsfGDl","date":"1666982651","viewed":72,"name":"Integral Plotter (Implicit)","username":"Envy24","description":"For visualizing \"complicated\" implicit functions (like heart curve):\nhttps://www.shadertoy.com/view/slVSWV // two pass shader, slow, but nice looking curve\nhttps://www.shadertoy.com/view/stKXWc // one pass shader, fast, but not always nice curves","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["template","implicit","integral","plotter","graphs","definite"],"hasliked":0,"parentid":"msX3Wl","parentname":"Integral Plotter (Explicit)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* This method works for explicit ( y=f(x) ) and implicit ( d=f(x,y,...) ) functions. */\n#define R                         ( iResolution )\n#define AR                        ( R.x / R.y )                      // Aspect ratio.\n#define UNIT                      ( 16.0 / R.y )                     // Affects AA and thickness\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n#define SCENE_SCALE               ( 3.5 )\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat draw_implicit_func(vec2 NDC, float fxy, vec2 grad) { return SMAA(abs(fxy) / sqrt(1.0 + grad.x*grad.x + grad.y*grad.y)); }\nfloat draw_implicit_func(vec2 NDC, float fxyz, vec3 grad) { return SMAA(abs(fxyz) / sqrt(1.0 + grad.x*grad.x + grad.y*grad.y + grad.z*grad.z)); }\n// e.t.c.\nfloat draw_area_under_curve(\n    vec2 NDC,\n    float fxy,\n    vec2 grad,\n    vec4 ranges) \n{ \n    return \n        (NDC.x >= min(ranges.x, ranges.y) && NDC.x <= max(ranges.x, ranges.y)) &&\n        (NDC.y >= min(ranges.z, ranges.w) && NDC.y <= max(ranges.z, ranges.w)) ?\n            SMAA(fxy / sqrt(1.0 + grad.x*grad.x + grad.y*grad.y)) :\n            0.;\n}\n\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin)\n{\n    /**/\n    vec2 M = \n        iMouse.z > 0. ?\n            iMouse.xy - R.xy * 0.5 : // map xy from [0; R.x][0; R.y] to [-R.x/2; R.x/2][-R.y/2; R.y/2]\n            vec2(0);                 // supress mouse offset\n    SC -= M;                         // apply mouse offset\n    /**/\n    SC = 2. * SC - R.xy;             // map xy from [0; R.x][0; R.y] to [-R.x; R.x][-R.y; R.y]\n    SC /= R.y;                       // map xy from [-R.x; R.x][-R.y; R.y] to [-AR; AR][-1; 1]\n    SC *= scale;                     // map xy from [-AR;AR][-1;1] to [-AR*scale; AR*scale][-scale; scale]\n    \n    return SC - origin;              // shift to new origin.\n}\n\nfloat heart_curve(float x, float y)\n{\n    float term = x*x + y*y - 1.0;\n    return term * term * term - x*x * y*y*y;\n}\n\nvec2 heart_gradient(float x, float y)\n{\n    float t = x*x + y*y - 1.;\n    return vec2(\n        6.*x*t*t - 2.*y*y*y*x,\n        6.*y*t*t - 3.*x*x*y*y\n    );\n}\n\n/*Gradient calculator:\nhttps://www.symbolab.com/solver/gradient-calculator/gradient%20?or=input*/\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0));\n\n    vec3 color = vec3(1.);\n\n/* Ugly result for this curve. *\n#define FUNC(x, y) ( (heart_curve(x,y)) )\n#define GRAD(x, y) ( (heart_gradient(x, y)) )\n/**\n#define FUNC(x, y) ( (x*x*x+y*y-1.) )\n#define GRAD(x, y) ( (vec2(3.*x*x, 2.*y)) )\n/*https://www.mathworks.com/matlabcentral/answers/805111-area-of-a-implicit-curve*/\n#define FUNC(x, y) ( -(sin(x)*sin(y)-0.5) )\n#define GRAD(x, y) ( vec2(-cos(x)*sin(y), -sin(x)*cos(y)) )\n\n/* Numeric gradient is bad( *\n#define DFDX(x, y, dx) ( ( FUNC((x)+dx, y)-FUNC((x)-dx, y) ) )\n#define DFDY(x, y, dy) ( ( FUNC(x, (y)+dy)-FUNC(x, (y)-dy) ) )\n#define GRAD(x, y)     ( vec2(DFDX(x, y, 0.25), DFDY(x, y, 0.25)) )\n    /**/\n    float lx = sinOSC(-AR*SCENE_SCALE, AR*SCENE_SCALE, iTime), rx = -lx,\n          ly = sinOSC(SCENE_SCALE, -SCENE_SCALE, iTime),       ry = -ly;\n\n    vec4 ranges = vec4(lx, rx, ly, ry);\n    float thickness = 0.5,\n          fxy = FUNC(NDC.x, NDC.y)/thickness;\n    vec2 grad = GRAD(NDC.x, NDC.y);\n\n    /* Ranges */\n    color -= horizontal_line(NDC, ly)*.5; color -= horizontal_line(NDC, ry)*.5;\n    color -= vertical_line(NDC, lx)*.5; color -= vertical_line(NDC, rx)*.5;          \n\n    /* Area under curve. */\n    color = mix( color, vec3(1, 0, 1), draw_area_under_curve(NDC, fxy, grad, ranges) );\n      \n    /* Implicit function d=f(x,y) */\n    color = mix( color, vec3(0,1,0), draw_implicit_func(NDC, fxy, grad) );\n    \n    /* Coordinates axis */\n    color -= x_axis(NDC); color -= y_axis(NDC);\n    /**/  \n\n    /* Cells */\n#define CELL_SIZE 1\n         NDC = mod(NDC, vec2(CELL_SIZE)); \n         color -= vertical_line(NDC, 0.)*.2;  color -= horizontal_line(NDC, 0.)*.2; // comment this line if you not use mod\n         color -= vertical_line(NDC, -1.)*.2; color -= horizontal_line(NDC, -1.)*.2;         \n         color -= vertical_line(NDC, 1.)*.2;  color -= horizontal_line(NDC, 1.)*.2; \n    /* */ \n        \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}","name":"Common","description":"","type":"common"}]}