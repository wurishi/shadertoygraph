{"ver":"0.1","info":{"id":"XljGWR","date":"1428102442","viewed":986,"name":"One more glass","username":"andregc","description":"This shader calculates a full set of reflection and refraction rays recursively. Use mouse to look around. Comment or set OBJECT_MAP_FUNCTION to see other objects","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection","refraction","glass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Distance function, camera setup and base for raymarching from iq's // https://www.shadertoy.com/view/Xds3zN\n\n//comment it or set to map1..map4 to see other objects (it is a bit slower when uncommented)\n#define OBJECT_MAP_FUNCTION map1\n\n\n#define RECURSION\n#define RAY_COUNT 15 //valid if RECURSION IS OFF: total number of rays (refl+reft) = 2^n-1, where n number of contact surfaces\n#define calcRecursion rec4 //valid if RECURSION IS ON: use n rays levels: total  RAY_COUNT = 2^n-1\n#define DIST_EPSILON 0.005\n\n#define ID_SKY 3.\n#define ID_FLOOR 1.\n#define ID_GLASS_WALL 2.\n#define ETA 0.75\n#define M_PI\t\t\t\t3.1415926535897932384626433832795\n\n#define DENSITY_MIN 0.1\n#define DENSITY_MAX 1.\n#define MATERIAL_COLOR vec3(0.5,0.8,1)*0.1\n#define AIR_COLOR vec3(0.5,0.8,1)*0.1\n\n#define SURFACE_COLOR vec3(0.8,1.,0.8)*1.6\n//#define SURFACE_COLOR vec3(0.8,1.,0.8)*(1.-0.2* mod( floor(5.0*p.z) + floor(5.1*p.x) + floor(5.1*p.y), 2.0))\n//#define SURFACE_COLOR vec3(0.8,1.,0.8)*(1.+0.6*noise(p.xz*30. + p.yy*23.));\n\n//-------------------------------------------------------------------------------\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n\tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nstruct CP {\n    float dist;\n    vec3 normal;\n    float mat;\n    vec3 p;\n};\n    \n    \nstruct Ray {\n    vec3 rd;\n    CP cp;\n    vec3 col;\n    float share;\n    float eta;\n};\n    \n    \n//-------------------------------------------------------------------------------\n//  https://www.shadertoy.com/view/Xds3zN\nfloat sdBox( vec3 p, vec3 b )\n{\n   vec3 d = abs(p) - b;\n   return (min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)));\n}\n\nfloat sdSphere( vec3 p, float r)\n{\n   return (length(p)-r);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return abs(length(max(abs(p)-b,0.0))-r);\n}\n\nvec3 opU( vec3 d1, vec3 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opS(  vec3 d1, vec3 d2 )\n{\n    return -d1.x>d2.x ? d2: d1;\n}\n\n//-------------------------------------------------------------------------------\n\nvec3 map3(in vec3 pos) {\n    \n    vec3 res =  vec3(sdBox(pos-vec3(0,0.29,0), vec3(0.5)),ID_GLASS_WALL, ETA);\n    res.x =abs(res.x);\n    res = opU(res, vec3(sdSphere(pos-vec3(0,0.8,0),0.4),ID_GLASS_WALL, ETA)); \n    res.x =abs(res.x);\n\treturn res;\n}\n\nvec3 map4(in vec3 pos) {\n    \n    vec3 res =  vec3(sdBox(pos-vec3(0,0.29,0), vec3(0.5)),ID_GLASS_WALL, ETA);\n    res = opU(res, vec3(sdSphere(pos-vec3(0,0.8,0),0.4),ID_GLASS_WALL, ETA)); \n    res.x =abs(res.x);\n\treturn res;\n}\n\nvec3 map2(in vec3 pos) {\n   vec3 res =  vec3((sdCappedCylinder(pos-vec3(0,0.4,0), vec2(0.8,0.5))), ID_GLASS_WALL, ETA);\n    res = opS(res, vec3(sdSphere(pos-vec3(0,0.8,0),0.4),ID_GLASS_WALL, ETA)); \n    res.x =abs(res.x);\n \treturn res;\n}\n\n\nvec3 map1(in vec3 pos) {\n    vec3 res =  vec3(sdBox(pos-vec3(0,0.29,0), vec3(0.5)),ID_GLASS_WALL, ETA);\n    res = opS(res, vec3(sdSphere(pos-vec3(0,0.8,0),0.4),ID_GLASS_WALL, ETA)); \n    res.x =abs(res.x);\n \treturn res;\n}\n\nvec3 map(in vec3 pos) {\n    vec3 plane = vec3(sdPlane(pos), ID_FLOOR, -1. );\n\n    vec3 res = plane;\n#ifdef OBJECT_MAP_FUNCTION    \n\tres =opU(res, OBJECT_MAP_FUNCTION(pos));    \n#else\n    float t = mod(iTime*0.1, 4.);\n    if (t < 1.) {\n    \tres = opU(res, map1(pos));\n    } else if (t<2.) {\n       \tres = opU(res, map2(pos));\n    } else if (t<3.) {\n        res = opU(res, map3(pos));\n    } else if (t<4.) {\n        res = opU(res, map4(pos));\n    }\n#endif\n    return res;\n}\n\n//-------------------------------------------------------------------------------\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.0001, 0.0, 0.0 );\n    float d = map(pos).x;\n    return normalize( vec3(\n\t    map(pos+eps.xyy).x - d,\n\t    map(pos+eps.yxy).x - d,\n\t    map(pos+eps.yyx).x - d)\n\t);\n\n}\n\n\n              \nCP findIntersection(vec3 p, vec3 rd) {\n     \n    float tmin = 0.000;\n    float tmax = 50.0;\n    \n\tfloat precis = DIST_EPSILON;\n    float t = tmin;\n    float eta = -1.;\n    vec3 res;\n    for( int i=0; i<200; i++ )\n    {\n\t     res = map(p+rd*t);\n      \n\n        eta = res.z;\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n    }\n    \n    p+=rd*t;\n    // calculate normal in the father point to avoid artifacts\n    vec3 n = calcNormal(p-rd*(precis-res.x));\n    CP cp = CP(t, n, res.y, p);\n\n    return cp;\n}\n\n//-------------------------------------------------------------------------------\n\n\nvec3 getColor(in Ray ray, vec3 pos) {\n    vec3 col = vec3(0);\n    if (ray.cp.mat == ID_FLOOR) {\n        const float m = 3.;\n        vec2 p = fract(vec2(-pos.x+0.5,pos.z+0.5)/m)*m;\n        col = texture(iChannel0, p.xy).xyz;\n    } else {\n        col = ray.col * SURFACE_COLOR;\n    }\n\n \treturn col;\n\n}    \n\n//-------------------------------------------------------------------------------\n\n\n#ifdef RECURSION\n\nvec3 getRayColor(Ray ray) {\n\n    vec3 p =  ray.cp.p;\n    float d = mix(DENSITY_MIN, DENSITY_MAX, (ray.eta - ETA)/(1./ETA-ETA));\n    vec3 matColor = mix(AIR_COLOR, MATERIAL_COLOR, (ray.eta - ETA)/(1./ETA-ETA));\n    vec3 col = getColor(ray,p);\n\n    float q = exp(-d*ray.cp.dist);\n    col = col*q+matColor*(1.-q);\n    return col*ray.share;\n}\n\nvoid getRays(inout Ray ray, out Ray r1, out Ray r2) {\n     vec3 p = ray.cp.p;\n    float cs = dot(ray.cp.normal, ray.rd);\n    // simple approximation\n    float fresnel = 1.0-abs(cs);\n    vec3 normal = sign(cs)*ray.cp.normal;\n    vec3 refr = refract(ray.rd, -normal, ray.eta);\n    vec3 refl = reflect(ray.rd, ray.cp.normal);\n    vec3 z = normal*DIST_EPSILON*2.;\n    p += z;\n    r1 = Ray(refr, findIntersection(p, refr),  vec3(0),1.-fresnel, 1./ray.eta);\n    p -= 2.*z;\n    r2 = Ray( refl, findIntersection(p, refl), vec3(0),fresnel, ray.eta);\n}\n    \n// set of \"recursion\" functions\nvoid rec2(inout Ray ray) {\n\t\n    Ray r1,r2;\n    getRays(ray, r1, r2);\n\n    ray.col += getRayColor(r1);\n    ray.col += getRayColor(r2);\n}\n\nvoid rec3(inout Ray ray) {\n    Ray r1,r2;\n    getRays(ray, r1, r2);\n    \n    rec2(r1);\n    ray.col += getRayColor(r1);\n    rec2(r2);\n    ray.col += getRayColor(r2);\n}\n\nvoid rec4(inout Ray ray) {\n    Ray r1,r2;\n    getRays(ray, r1, r2);\n    \n    rec3(r1);\n    ray.col += getRayColor(r1);\n    rec3(r2);\n    ray.col += getRayColor(r2);\n}\n\nvoid rec5(inout Ray ray) {\n    Ray r1,r2;\n    getRays(ray, r1, r2);\n    \n    rec4(r1);\n    ray.col += getRayColor(r1);\n    rec4(r2);\n    ray.col += getRayColor(r2);\n}\n\nvoid rec6(inout Ray ray) {\n    Ray r1,r2;\n    getRays(ray, r1, r2);\n    \n    rec5(r1);\n    ray.col += getRayColor(r1);\n    rec5(r2);\n    ray.col += getRayColor(r2);\n}\n\n\n\nvec3 castRay(vec3 p, vec3 rd) {\n    CP cp = findIntersection(p, rd);\n   \n    Ray ray = Ray( rd, cp, vec3(0), 1., ETA);\n    calcRecursion(ray);\n    ray.col += getRayColor(ray);\n\treturn ray.col;\n    \n}\n\n#else\n//-------------------------------------------------------------------------------\n\n// shorter but a bit slower \n    \nRay rays[RAY_COUNT];\nvec3 castRay(vec3 p, vec3 rd) {\n   \n   \n    CP cp = findIntersection(p, rd);\n   \n    rays[0] = Ray( rd, cp, vec3(0), 1., ETA);\n\n    for(int i = 0; i < RAY_COUNT/2; ++i) {\n        Ray ray = rays[i];\n        \n\t\tvec3 p = ray.cp.p;\n       \t float cs = dot(ray.cp.normal, ray.rd);\n        float fresnel = 1.0-abs(cs);\n        //float fresnel =mix(0.2, 1., pow(1.-abs(cs),2.));\n         vec3 normal = sign(cs)*ray.cp.normal;\n    \tvec3 refr = refract(ray.rd, -normal, ray.eta);\n        vec3 refl = reflect(ray.rd, ray.cp.normal);\n        vec3 z = normal*DIST_EPSILON*2.;\n        p += z;\n        rays[i*2+1] = Ray(refr, findIntersection(p, refr),  vec3(0),1.-fresnel, 1./ray.eta);\n        p -= 2.*z;\n        rays[i*2 + 2] = Ray( refl, findIntersection(p, refl), vec3(0),fresnel, ray.eta);\n    }\n    \n    for(int i = RAY_COUNT-1; i>=0;--i) {\n        Ray ray = rays[i];\n        vec3 p =  ray.cp.p;\n\t\tvec3 atColor;\n        float  d = mix(DENSITY_MIN, DENSITY_MAX, (ray.eta - ETA)/(1./ETA-ETA));\n        vec3 matColor = mix(AIR_COLOR, MATERIAL_COLOR, (ray.eta - ETA)/(1./ETA-ETA));\n        vec3 col = getColor(ray, p);\n        float q = exp(-d*ray.cp.dist);\n        col = col*q+matColor*(1.-q);\n        rays[(i-1)/2].col += col*ray.share;\n\n    }\n   \n\treturn rays[0].col;\n}\n\n#endif\n\n\nvec3 render(vec3 p, vec3 rd) {\n    vec3 col= castRay(p, rd);\n    return col;\n}\n\n// https://www.shadertoy.com/view/Xds3zN\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy-0.5;\n\n    uv.x*=iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    if (mo.x==mo.y && mo.x==0.) {\n        mo = vec2(0.42,0.4);\n    }\n\n    mo.y+=0.02;\n\tmo.y *=1.57;\n    float time =iTime*0.1;;\n\tmo.x*=10.;\n    float R = 4.3;\n    \n    float Y = sin(mo.y);\n    float X = cos(mo.y);\n\tvec3 ro = vec3(cos(time + mo.x)*X, Y, X*sin(time + mo.x) )*R;\n\tvec3 ta = vec3( 0,0.4,0);\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta,0. );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(uv.xy,2.5) );\n    \n    vec3 c = render(ro, rd);\n\n\tfragColor = vec4(c, 1);\n}","name":"","description":"","type":"image"}]}