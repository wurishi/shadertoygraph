{"ver":"0.1","info":{"id":"WlVSWm","date":"1582861174","viewed":193,"name":"Ray March 5","username":"baksej","description":"Ray March 5","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void pR(inout vec2 p, float a) {\n    p = cos(a) * p + sin(a) * vec2(p.y, - p.x);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat sphere(vec3 pos, float radius) {\n    return length(pos) - radius;\n}\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat map(float v, float a, float b, float x, float y) {\n    float n = (v - a) / (b - a);\n    return x + n * (y - x);\n}\n\nfloat ground(vec3 pos) {\n    return pos.y;\n    \n}\n\n\nfloat scene(vec3 pos) {\n    \n    vec3 i = floor(pos / 0.5);\n    \n    vec3 pos1 = pos;\n    pos1.xz = mod(pos1.xz, 0.5) - 0.25;\n    pos1.y += .1 + sin(iTime + random(i.xz) * 6.2) * .1;\n    float s1 = sphere(pos1, 0.05);\n    \n    vec3 pos1b = pos;\n    pos1b.xz = mod(pos1b.xz, 0.5) - 0.25;\n    pos1b.y += .1 + sin(iTime + random(i.xz) * 6.2) * .2;\n    pos1b.x +=  sin(iTime + random(i.xz+1.0) * 6.2) * .05;\n    pos1b.z +=  sin(iTime + random(i.xz+2.0) * 6.2) * .05;\n    float s1b = sphere(pos1b, 0.02);\n    \n    s1 = smin(s1, s1b, .15);\n    \n    \n    \n    vec3 pos2 = pos;\n    pos2.y += 300.0 + 0.1;\n    pos2.z -= 1.0;\n    float s2 = sphere(pos2, 300.0);\n    \n    return smin(s1, s2, 0.15);\n}\n\nvec3 estimateNormal(vec3 pos) {\n    \n    return normalize(\n        vec3(\n            scene(pos - vec3(0.001, 0.0, 0.0)) - scene(pos + vec3(0.001, 0.0, 0.0)),\n            scene(pos - vec3(0.0, 0.001, 0.0)) - scene(pos + vec3(0.0, 0.001, 0.0)),\n            scene(pos - vec3(0.0, 0.0, 0.001)) - scene(pos + vec3(0.0, 0.0, 0.001))\n            \n        ));\n    }\n    \n    //https://iquilezles.org/articles/rmshadows\n    // these probably have pretty bad performance\n    // they are modified from iq's, but I made a lot of changes\n    // to explore how they work without worrying about speed\n\n    // float jshadow( in vec3 light, in vec3 pos)\n    // {\n        //     float dist = distance(light, pos);\n        //     vec3 dir = normalize(pos - light);\n        \n        //     for( float t=.1; t<dist-.01; )\n        //     {\n            //         float h = scene(light + dir*t);\n            //         if( h<0.001 )\n            //             return 0.0;\n            //         t += clamp(h, 0.01, 0.50);\n        //     }\n        //     return 1.0;\n    // }\n    \n    float jsoftshadow(in vec3 light, in vec3 pos, float w)\n    {\n        float dist = distance(light, pos);\n        vec3 dir = normalize(pos - light);\n        \n        float s = 1.0;\n        for(float t = 0.1; t < dist - 0.1; )\n        {\n            float h = scene(light + dir * t);\n            s = min(s, 0.5 + 0.5 * h / (w * t));\n            if (s < 0.0)break;\n            t += clamp(h, 0.01, 0.50);\n        }\n        s = max(s, 0.0);\n        \n        return s * s*(3.0 - 2.0 * s); // smoothstep\n    }\n    \n    vec3 lightOrigin = vec3(-0.3, 0.6, - 0.3);\n    \n    vec3 trace(vec3 camOrigin, vec3 dir, out float totalDist) {\n        const int maxSteps = 1024;\n        vec3 ray = camOrigin;\n        totalDist = 0.0;\n        \n        // hacky near plane clipping\n        totalDist += 0.1;\n        ray += totalDist * dir;\n        \n        for(int i = 0; i < maxSteps; i ++ ) {\n            float dist = scene(ray);\n            if (abs(dist) < 0.001) {\n                vec3 lightDir = normalize(ray - lightOrigin);\n                // this is not how falloff works!\n                float lightFalloff = 2.0 - pow(length(ray - lightOrigin) * 0.5, 2.0);\n                float diffuse = clamp(dot(lightDir, estimateNormal(ray)) * lightFalloff, 0.0, 1.0);\n                \n                float s = jsoftshadow(lightOrigin, ray, 0.02);\n                diffuse *= s;\n                \n                vec3 ambient = vec3(0.1, 0.1, 0.2);\n                return vec3(1.0, 0.8, 0.6) * diffuse + ambient;\n                \n            }\n            totalDist += dist;\n            ray += dist * dir;\n        }\n        \n        return vec3(0.0);\n    }\n    \n    void mainImage(out vec4 fragColor, in vec2 fragCoord)\n    \n    {\n        lightOrigin = vec3(sin(iTime * 0.7), 0.5, cos(iTime * 0.7));\n        \n        // Normalized pixel coordinates (from 0 to 1)\n        vec2 uv = fragCoord / iResolution.xy;\n        uv = uv * 2.0 - 1.0;\n        uv.y /= iResolution.x / iResolution.y;\n        \n        vec3 camOrigin = vec3(0.0, 0.5, - 3.0);\n        vec3 rayOrigin = vec3(camOrigin.xy + uv, camOrigin.z + 3.0);\n        \n        \n        vec3 color = vec3(0.0);\n        float passes = 1.;\n        float blur = .00;\n        for (float pass = 0.; pass < passes; pass++){\n        \tcamOrigin.x += random(rayOrigin.xy + pass/passes) * blur;\n        \tcamOrigin.y += random(rayOrigin.xy + pass/passes - 1.0) * blur;\n        \n        \tvec3 dir = normalize(rayOrigin - camOrigin);\n        \n        \tpR(dir.yz, - 0.1);\n        \n        \tfloat dist;\n        \tvec3 c = trace(camOrigin, dir, dist);\n        \n        \tfloat fog = clamp(map(dist, 6.0, 7.0, 1.0, 0.0), 0.0, 1.0);\n        \tc = mix(vec3(0.0), c, fog);\n        \tcolor += c;\n        \n        }\n        \n        // Output to screen\n        \n        fragColor = vec4(color / passes, 1.0);\n    }","name":"Image","description":"","type":"image"}]}