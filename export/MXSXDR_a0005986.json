{"ver":"0.1","info":{"id":"MXSXDR","date":"1710457567","viewed":102,"name":"metatron","username":"UnMouflon","description":"I tried to do the same shape as in https://www.thingiverse.com/thing:1146870","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reproduction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// variant of https://shadertoy.com/view/NltyWX\n// variant of https://shadertoy.com/view/7lcyDf\n\n#define rot(a)      mat2(cos(a+vec4(0,11,33,0)))           // rotation \n#define rot3(P,A,a) ( mix( A*dot(P,A), P, cos(a) ) + sin(a)*cross(P,A) )\n\nfloat L(vec3 p, vec3 a, vec3 b) {\n    p -= (a+b)/2.;\n    p = rot3(p,normalize(b-a),radians(100.));\n    p = rot3(p,vec3(0,1,0),radians(-45.)); \n    float s = sign(p.x);\n    p.x = abs(p.x);\n    p *= vec3(1,0.7,1);\n    float ra = length(b-a)/2.;\n    vec2 sc = vec2(sin(radians(85.-s*15.)),cos(radians(85.-s*15.)));\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - 0.15;\n}\n\n\n//taken from https://iquilezles.org/articles/smin/\nfloat opSmoothUnion( float d1, float d2)\n{\n    float k = 0.15;\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\n\n\nfloat map(vec3 q) {\n    vec3 A = vec3( 1 ), \n          B = vec3( 0, 0.7, 0.);\n    vec3 axe = vec3(1./sqrt(3.));\n    float d = 100000.;\n    for(float cx = -0.; cx < 1.5; cx+=1.) for(float cy = -0.; cy < 1.5; cy+=1.) for(float cz = -0.; cz < 1.5; cz+=1.){\n        vec3 q2 = q;\n        q2 = rot3(q2,vec3(1,0,0),radians(cy*90.));\n        q2 = rot3(q2,vec3(1,0,0),radians(cz*180.));\n        q2 = rot3(q2,vec3(0,0,1),radians(cx*180.));\n        d = opSmoothUnion(d, \n                 opSmoothUnion( opSmoothUnion( L(q2,A,B) ,\n                      L(rot3(q2,axe,radians(240.)),A,B) ),\n                      L(rot3(q2,axe,radians(120.)),A,B)\n                ));\n    }\n    return d;\n}\n\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.;\n    vec3  R = iResolution, N, e = vec3(.01,0,0),\n          D = vec3(U*.4 - R.xy*.2, -R.y) / R.y,            // ray direction\n          p = vec3(0,0,10), q, r,                          // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5\n              :  vec3(.1,0,0) * cos(iTime + vec3(0,11,0)); \n    for (O=vec4(1); O.x > 0. && t > .01; O-=.01)           // march scene\n        q = p,\n        q.yz *= rot(.78-6.*M.y),                           // rotations\n        q.xz *= rot(.78-6.*M.x), \n        t = map(q),\n     // t = min(t, map(q)),\n        p += t*D;                                          // step forward = dist to obj          \n\n   if (t<.01) \n       N = normalize( t - vec3( map(q+e), map(q+e.yxy), map(q+e.yyx) ) ),\n       O -= dot(N,vec3(.7)) +O;\n}\n\n","name":"Image","description":"","type":"image"}]}