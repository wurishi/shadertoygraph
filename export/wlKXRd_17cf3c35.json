{"ver":"0.1","info":{"id":"wlKXRd","date":"1583419747","viewed":112,"name":"Conductive Fresnel (Obsolete)","username":"bhouston","description":"This is now obsolete, please see: https://www.shadertoy.com/view/ttySzt","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["obsolete"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 sphere = vec3(0, 0, 2);\nfloat sphere_size = 1.3;\n\nconst float INFINITY = 100000.0;\n\n#define GOLD // change metal type\n#define ENV_MAP // enable envmap\n//#define REFLETIVITY_METAL_APPROX // replace dieletric Fresnel with just 1.0    \n\n//\n// Wavelength dependent IOR and Extinction derived from\n// https://refractiveindex.info/\n// \n// Wavelength micrometers used are r = 0.63, g = 0.532, b = 0.465\n// \n\n#ifdef GOLD\n\t// NOTE: almost no difference between Dielectric and Conductive Fresnel\n\tvec3 n = vec3(0.18299, 0.42108, 1.3734);\n\tvec3 k = vec3(3.4242, 2.3459, 1.7704);\n#endif\n\n#ifdef SILVER\n\t// NOTE: almost no difference between Dielectric and Conductive Fresnel\n\tvec3 n = vec3(0.056909, 0.054007, 0.046878);\n\tvec3 k = vec3(4.2543, 3.429, 2.8028);\t\n#endif\n\n#ifdef COPPER\n    vec3 n = vec3(0.27527,1.1159,1.2469);\n\tvec3 k = vec3(3.3726, 2.5956, 2.4562);\n#endif\n    \n#ifdef ALUMINIUM\n\tvec3 n = vec3(1.1167, 0.97274, 0.57037);\n\tvec3 k = vec3(6.8768, 6.5119, 5.2086);\t\n#endif\n\n#ifdef NICKEL\n\tvec3 n = vec3(1.9479, 1.8975, 1.7094);\n\tvec3 k = vec3(3.7424, 3.5489, 2.8128);\t\n#endif\n\n#ifdef IRON\n\tvec3 n = vec3(2.943, 2.9211, 2.4728);\n\tvec3 k = vec3(2.9718, 2.9236, 2.7067);\t\n#endif\n\n\nfloat pow2( const in float a ) { return a *a; }\nvec3 pow2( const in vec3 a ) { return a *a; }\n\n//\n// Approximation of Spectral Complex Fresnel based on just sampling RGB wavelengths\n//\n// source: https://docs.chaosgroup.com/display/OSLShaders/Complex+Fresnel+shader\n//\nvec3 F_ConductiveFresnel( const in vec3 n, const in vec3 k, const in float dotNV ) {\n\n    vec3 rs_num = pow2( n ) + pow2( k ) - 2.0 * n * dotNV + pow2( dotNV );\n    vec3 rs_den = pow2( n ) + pow2( k ) + 2.0 * n * dotNV + pow2( dotNV );\n    vec3 rs = rs_num / rs_den;\n     \n    vec3 rp_num = ( pow2( n ) + pow2( k ) ) * pow2( dotNV ) - 2.0 * n * dotNV + 1.0;\n    vec3 rp_den = ( pow2( n ) + pow2( k ) ) * pow2( dotNV ) + 2.0 * n * dotNV + 1.0;\n    vec3 rp = rp_num / rp_den;\n     \n    return clamp( 0.5 * ( rs + rp ), vec3(0.0), vec3(1.0) );\n}\n\nvec3 F_DielectricFresnel( const in vec3 reflectivity, const in float dotNV ) {\n\t// Based on the standard Schlick approximation\n\tfloat fresnel = pow( 1.0 - dotNV, 5.0 );\n\treturn vec3( ( 1.0 - reflectivity ) * fresnel + reflectivity );\n}\n\nfloat raySphere(vec3 rpos, vec3 rdir, vec3 sp, float radius, inout vec3 point, inout vec3 normal) {\n\tradius = radius * radius;\n    vec3 tmp = rpos - sp;\n\tfloat dt = dot(rdir, -tmp);\n\tif (dt < 0.0)\n\t\treturn INFINITY;\n\ttmp.x = dot(tmp, tmp);\n\ttmp.x = tmp.x - dt*dt;\n\tif (tmp.x >= radius)\n\t\treturn INFINITY;\n\tdt = dt - sqrt(radius - tmp.x);\n\tpoint = rpos + rdir * dt;\n\tnormal = normalize(point - sp);\n\treturn dt;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\tuv.y = -uv.y;\n\tvec3 ray = vec3(uv.x, uv.y, 1.0);\n\tray = normalize(ray);\t\n\t\n\tvec3 point, normal; \n\tfloat dist = raySphere(vec3(0.0), ray, sphere, sphere_size, point, normal);\n    \n    vec3 viewDir = normalize( -point );\n    float dotVN = dot( viewDir, normal );\n    \n    // Calculate reflectivity (F0) from the conductive Fresnel\n    vec3 reflectivity = F_ConductiveFresnel( n, k, 1.0 );\n    \n    vec3 reflection = reflect( viewDir, normal );\n\n    vec3 env = texture( iChannel2, reflection ).xyz;\n    \n    vec3 F = vec3( 0.0 );\n                  \n\tif (dist < INFINITY) {\n\t  \n        if( ( uv.y + sin( iTime ) ) < 0.0 ) {  \n#ifdef REFLETIVITY_METAL_APPROX        \n\t\t\tF = reflectivity;\n#else\n            F = F_DielectricFresnel( reflectivity, dotVN );\n#endif\n        }\n        else {\n\t\t\tF = F_ConductiveFresnel( n, k, dotVN );\n        }\n    }\n    \n    vec3 result = F;\n    \n#ifdef ENV_MAP\n    result *= env * 1.5;\n#endif\n    \n    if (dist >= INFINITY) {\n\t  \n        if( ( uv.y + sin( iTime ) ) > 0.0 && abs( uv.x ) > 0.9 ) {  \n            result = vec3( 0.2 );\n\t    }\n            \n    }\n    fragColor.rgb = result;\n    \n\tfragColor.w = 1.0;\n}","name":"Image","description":"","type":"image"}]}