{"ver":"0.1","info":{"id":"ctsXzB","date":"1685459117","viewed":56,"name":"try cloud shape","username":"cailuming","description":"just for simplification to see the perlin-worley noise shape","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["2d","perlin","worley"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":" \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0,uv).xyz;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UI4 uvec4(UI3, 1979697957U)\n#define UIF (1.0 / float(0xffffffffU)) \n\nmat2 rot2D(float a){\n   float c = cos(a);\n   float s = sin(a);\n   \n   return mat2(c,s,-s,c);\n}\n \nvec2 hash22(uvec2 q)\n{\n\tq *= UI2;\n\tq = (q.x ^ q.y) * UI2;\n\treturn vec2(q) * UIF;\n}\n \nvec2 hashwithoutsine22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\nfloat noise2D(vec2 uv){\n    vec2 p = floor(uv);\n    vec2 f = fract(uv);\n    vec2 e = vec2(1.0,0.0);\n    \n    vec2 p00 = p;\n    vec2 p01 = p+e.yx;\n    vec2 p10 = p+e.xy;\n    vec2 p11 = p+e.xx;\n    \n    float v00 = dot(f-e.yy,hash22(uvec2(p00)));\n    float v01 = dot(f-e.yx,hash22(uvec2(p01)));\n    float v10 = dot(f-e.xy,hash22(uvec2(p10)));\n    float v11 = dot(f-e.xx,hash22(uvec2(p11)));\n    \n    f = f*f*f*(f*(f*6.-15.)+10.); \n    \n    return mix(mix(v00,v01,f.y),mix(v10,v11,f.y),f.x);\n}\n\nfloat woley(vec2 uv){\n  vec2 p = floor(uv);\n  vec2 f = fract(uv);\n  vec2 interV = f*f*f*(f*(f*6.0-15.0)+10.0);\n     ;\n  float minv = 888.0;\n  int r = 1;\n  for(int i=-r;i<=r;i++){\n    for(int j=-r;j<=r;j++){\n       vec2 nb = vec2(i,j);\n       vec2 rp = hashwithoutsine22(vec2(p+nb));\n       minv= min(length(f-nb-rp),minv);\n    }\n  }\n  return minv;\n}\n\n\n\nfloat fbm(vec2 uv){\n   float freq = 1.0;\n   float amp = 1.0;\n   float ret = 0.0;\n   \n   for(int i=0;i<8;i++){\n      ret+= woley(uv*freq+iTime*0.4)*amp;\n      freq*=1.7;\n      amp*=0.5;\n   }\n   return ret;\n}\n\nfloat fbmP(vec2 uv){\n   float freq = 1.0;\n   float amp = 2.0;\n   float ret = 0.5;\n   \n   for(int i=0;i<10;i++){\n      ret+= noise2D(uv*freq+iTime*0.1)*amp;\n      freq*=1.6;\n      amp*=0.5;\n    \n   }\n   return ret;\n}\n\nfloat remap(float x,float a,float b,float na,float nb){\n   return (x-a)/(b-a)*(nb-na)+na;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float asp = iResolution.x/iResolution.y;\n    vec2 cuv = uv - vec2(0.5);\n    cuv.x*=asp;\n      \n    float v = fbm(uv*10.0);\n    float v1 = fbmP(uv*2.0);\n    v = remap(v,0.0,1.0+0.8*sin(iTime),v,v1);\n    // Time varying pixel color\n    vec3 col = vec3(pow(max(0.0,v),0.2));\n    \n    col = smoothstep(0.0,1.0,col);\n    col = mix(vec3(0.5,0.6,0.8),col,col.x*col.x);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}