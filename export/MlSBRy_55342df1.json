{"ver":"0.1","info":{"id":"MlSBRy","date":"1516226438","viewed":194,"name":"15/2018","username":"rimina","description":"This shader is part of my daily shader challenge. Today I continued to figure out ways to visualize voronoi. I combined my noise volume march thing from day 2 to my voronoi thing from day 13.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","dailyshader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS 12\n#define PI 3.14159265\n\n\n//Hash method from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n\nfloat dist(vec3 q){\n    vec3 f = fract(q);\n    vec3 i = floor(q);\n    \n    vec3 n[27];  \n    n[0] = vec3(-1.0, -1.0, -1.0);\n    n[1] = vec3(-1.0,  0.0, -1.0);\n    n[2] = vec3(-1.0,  1.0, -1.0);\n    \n    n[3] = vec3(0.0,  -1.0, -1.0);\n    n[4] = vec3(0.0,   0.0, -1.0);\n    n[5] = vec3(0.0,   1.0, -1.0);\n    \n    n[6] = vec3(1.0,  -1.0, -1.0);\n    n[7] = vec3(1.0,   0.0, -1.0);\n    n[8] = vec3(1.0,   1.0, -1.0);\n    \n    n[9] = vec3(-1.0, -1.0,\t 0.0);\n    n[10] = vec3(-1.0, 0.0,  0.0);\n    n[11] = vec3(-1.0, 1.0,  0.0);\n    \n    n[12] = vec3(0.0,  -1.0,  0.0);\n    n[13] = vec3(0.0,   0.0,  0.0);\n    n[14] = vec3(0.0,   1.0,  0.0);\n    \n    n[15] = vec3(1.0,  -1.0,  0.0);\n    n[16] = vec3(1.0,   0.0,  0.0);\n    n[17] = vec3(1.0,   1.0,  0.0);\n    \n    n[18] = vec3(-1.0, -1.0,  1.0);\n    n[19] = vec3(-1.0,  0.0,  1.0);\n    n[20] = vec3(-1.0,  1.0,  1.0);\n    \n    n[21] = vec3(0.0,  -1.0,  1.0);\n    n[22] = vec3(0.0,   0.0,  1.0);\n    n[23] = vec3(0.0,   1.0,  1.0);\n    \n    n[24] = vec3(1.0,  -1.0,  1.0);\n    n[25] = vec3(1.0,   0.0,  1.0);\n    n[26] = vec3(1.0,   1.0,  1.0);\n    \n    float t = 1000.0;\n    for(int it = 0; it < 27; ++it){\n        vec3 p = hash33(i+n[it]);\n        p = (1.0+sin(iTime*0.5 + 2.0*PI*p))*0.5;\n        float d = length(n[it]+p-f);\n        t = min(t, d);\n    }\n    return t;\n}\n\nfloat trace(vec3 ro, vec3 rd){\n    \n    float t = 0.0;\n    //the offset IS intentional\n    vec3 p = ro+rd;\n    \n    for(int i = 0; i < STEPS; ++i){\n        float d = dist(p-length(hash33(p+iTime*0.25))*0.03)*0.02;\n        t += d;\n        p += rd*d;\n        \n    }\n    \n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 ro = vec3(0.0, 0.0, iTime*0.25);\n\tvec3 rt = vec3(0.0, 0.0, -1.0);\n    \n    vec3 z = normalize(rt-ro);\n    vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n    vec3 y = normalize(cross(x, z));\n    vec3 rd = mat3(x, y, z)*vec3(uv, radians(50.0));\n    \n    //Tiling space..\n    vec3 q = rd*10.0;\n    \n    float t = trace(ro, q);\n    \n    vec3 col = vec3(0.7, 0.65, 0.5)+vec3(t);\n    col = 1.0 - col;\n    col = smoothstep(0.2, 0.8, col);\n    \n    col = pow(col, 1.0/vec3(2.2));\n    \n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}