{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"mat4 cam;\nmat3 rot;\nvec3 lookFrom;\nvec3 lookAt;\n\nvec4 fcolor;\nvec2 fcoord;\n\nstruct Sphere\n{\n    vec3 position;\n    float radius;\n    vec4 color;\n    \n};\n    \nstruct Ray\n{\n    vec3 from;\n    vec3 direction;\n};\n    \nSphere spheres[1];\n\n\nfloat distort = 1.0;\nfloat d;\n\nvec3 lightPos = vec3(0.0, 0.0, -100.0);\nvec4 ambient = vec4(0.20, 0.0, 0.0, 0.15);\n\nvec3 rotatey(float angle, vec3 point)\n{\n    mat3 mat;\n    mat[0] = vec3(cos(angle), 0.0, sin(angle));\n    mat[1] = vec3(0.0, 1.0, 0.0);\n    mat[2] = vec3(-sin(angle), 0.0, cos(angle));\n    return mat * point;\n}\n\nvec3 rotatez(float angle, vec3 point)\n{\n    mat3 mat;\n    mat[0] = vec3(cos(angle), -sin(angle), 0.0);\n    mat[1] = vec3(sin(angle), cos(angle), 0.0);\n    mat[2] = vec3(0.0, 0.0, 1.0);\n    return mat * point;\n}\n\nvec3 rotatex(float angle, vec3 point)\n{\n    mat3 mat;\n    mat[0] = vec3(1.0, 0.0, 0.0);\n    mat[1] = vec3(0.0, cos(angle), -sin(angle));\n    mat[2] = vec3(0.0, sin(angle), cos(angle));\n    return mat * point;\n}\n\n// create normals out of texture\nvec3 getNormal(vec2 uv)\n{\n    float noisep = texture(iChannel0, uv).r;\n    \n    float offset = 0.01;\n    float noise = 0.0;\n    ////////////////////////////\n    vec2 uv2 = uv + vec2(offset, 0.0);\n    noise = texture(iChannel1, uv2).r;    \n    vec3 v2 = vec3(1.0, 0.0, noise - noisep);\n    ////////////////////////\n    vec2 uv3 = uv + vec2(0.0, offset);    \n    noise = texture(iChannel1, uv3).r;\n    vec3 v3 = vec3(0.0, 1.0, noise - noisep);\n    ///////////////////////////\n    vec3 normal = cross(v2, v3);\n    normal = normalize(normal);\n    return normal;\n}\n\nvec4 ColorCircle(Sphere sp, Ray ray, float t, vec3 temp)\n{\n    vec3 hitp = ray.from + t * ray.direction;\n    vec3 normal = hitp - sp.position;\n    vec3 local = sp.position - hitp;\n    local = normalize(local);\n    normal = normalize(normal);\n    \n    vec3 lightDir = normalize(lightPos - sp.position );\n    vec3 ldiff = lightPos - sp.position;\n    \n    float d = dot(normal, normalize(lightDir));  \n    d = max(d, 0.0);\n   \tvec3 V = normalize(lookFrom - lookAt);\n    vec3 L = normalize(lightPos - hitp);\n    vec3 H = normalize(V + L);\n    \n    float spec = dot(H, normal) * d;\n    spec = clamp(spec, 0.0, 1.0);\n    spec = pow(spec, 0.2);\n    spec *= 5.0;\n    float base = 1.0 - dot(V, normal);\n    base = clamp(base, 0.0, 1.0);\n    \n    float exponential = pow(base, 5.0);\n    float F0 = 0.0011;\n    float fresnel = exponential + F0 * (1.0 - exponential);\n    fresnel *= 4.0;\n    \n    vec2 uv;\n    vec3 l = local;\n    \n    uv.x = 0.5 + atan(l.z, l.x) / 3.14159 * 2.0;\n    uv.y = 0.5 - asin(l.y) / 3.14159;\n    vec2 uv2 = uv;\n/*\n    vec4 tex = texture(iChannel0, uv);\n    vec2 uv2 = uv;\n    uv2.x += 2.4;\n    uv2.y += 0.1;\n    uv2 *= 0.16;\n */  \n    vec4 tex2 = texture(iChannel1, uv2);\n    float m_filter = 0.05;\n    \n    tex2 *= max(tex2.r - m_filter, 0.0) / (1.0 - m_filter);\n    tex2.g = 0.0;\n    tex2.b = 0.0;\n    \n    tex2.r = max(tex2.r, 0.05);\n    tex2.b = max(tex2.b, 0.05);\n    tex2.g = max(tex2.g, 0.05);\n\t\n    /*\n    tex.g = 0.0;\n    tex.b = 0.0;\n    tex *= tex2;\n    */\n    // sphere texturing\n    vec2 uvv;\n    uvv.x = 0.5 + atan(local.z, local.x) / 3.14159 * 2.0;\n    uvv.y = 0.5 - asin(local.y) / 3.14159;\n    \n    vec3 texnormal = getNormal(uvv);\n\t// trasform normals to world space\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 w = cross(local, up);\n    vec3 u = cross(local, w);\n    mat3 r;\n    \n    r[0] = w;\n    r[1] = u;\n    r[2] = local;\n    \n    texnormal *= r;    \n    float dd = dot(texnormal, -lightDir);\n    dd *= 1.0;\n    dd = max(dd, 0.0);\n    \n    vec4 color = vec4( spec * fresnel * dd) * tex2 + ambient + tex2 * dd ;\n    \n    // out of gamut correction\n    float m = max(color.r, color.b);\n    m = max(m, color.g);\n    if (m > 1.0)\n    {\n\t    color /= m;\n    }    \n    return color;\n    \n}\n\n\n\nvec4 traceSphere(Sphere sp, Ray ray)\n{\n    \n    float d;\n    vec3 temp = ray.from - sp.position;\n    float a = dot(ray.direction, ray.direction);\n    float b = 2.0 * dot(temp, ray.direction);\n    float c = dot(temp, temp) - sp.radius * sp.radius;\n    float disc = b * b - 4.0 * a * c;\n    \n    \n    \n    if (disc >= 0.0)\n    {\n        float e = sqrt(disc);\n        float denom = 2.0 * a;\n        float t = (-b - e) / denom;\n        if ( t > 0.0)\n        {\n            return ColorCircle(sp, ray, t, temp);\n        }\n        \n        t = (-b + e) / denom;\n        \n        if (t > 0.0)\n        {\n            return ColorCircle(sp, ray, t, temp);\n        }        \n    }\n    vec2 uv = fcoord.xy / iResolution.xy;\n    return vec4(0.05 * uv.y + 0.2, 0.0, 0.0, 0.0);\n}\n\n\nvec4 traceSpheres(Ray ray)\n{\n    \n    \n    for (int i = 0; i < 1; ++i)\n    {\n        vec4 result = traceSphere(spheres[i], ray);\n        \n        if (result != vec4(0.0, 0.0, 0.0, 0.0))\n        {\n            return result;\n        }\n    }\n    return vec4(0.0, 0.0, 0.0, 0.0);\n}\n\n\nvec2 getNormalizedPosition(vec2 screenCoord)\n{\n    float midx = iResolution.x * 0.5;\n    float midy = iResolution.y * 0.5;\n    \n    float mx = screenCoord.x - midx;\n    float my = screenCoord.y - midy;\n    return vec2(mx / midx, my / midx);\n}\n\n\nRay getRay(vec2 screenCoord)\n{\n    vec3 p = vec3(getNormalizedPosition(screenCoord), 0.0);\n    p.z = 1.0 * d;\n    Ray r;\n    r.from = lookFrom;\n    \n    p = normalize(p);\n    r.direction = p;\n    r.direction *= rot;\n    return r;\n}\n\n\nvoid lookat(vec3 to)\n{\n    lookAt = to;\n    vec3 fwd = normalize(to - lookFrom) ;\n    vec3 up = vec3(0.0, 0.995, 0.0);\n    \n    vec3 v = normalize(cross(fwd, up));\n    vec3 w = normalize(cross(fwd, v));\n    \n    rot[0] = v;\n    rot[1] = w;\n    rot[2] = fwd;\n\n\n}\n\nvoid draw()\n{\n    \n    vec4 totalCol = vec4(0.0, 0.0, 0.0, 0.0);    \n\tconst int kernel = 9;\n    const float filterOffset = 1.0 / float(kernel);\n    for (int x = -kernel; x < kernel; x+=2)\n    {\n        for (int y= -kernel; y < kernel; y+=2)\n        {\n            vec2 offset = vec2(x, y) * filterOffset;\n            \n            vec2 pos = fcoord.xy + offset;\n\t\t    Ray r = getRay(pos);\n\t\t    totalCol += traceSpheres(r);\n        }\n    }\n    vec4 col = totalCol / float (kernel * kernel);\n    fcolor = col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nd = 1.0 / distort;\n\n    float zoffset = 0.0;\n    float r = mod(iTime, 4.0);\n    fcoord = fragCoord;\n    d = 4.0 / distort;\n    \n    lookFrom = vec3(sin(iTime) * 0.0, 0.0, 60.0);\n    lookFrom = rotatey(-iTime * 0.23, lookFrom);\n    //lookFrom = vec3(0.0, 0.0, -60.0);\n    vec3 at = vec3(0.0, 0.0, 0.0);\n    lightPos = rotatey(iTime * 0.5, vec3(0.0, 0.0, -100.0));\n    //lightPos = rotatez(sin(iTime * 0.25), lightPos);\n    \n    lookat(vec3(0.0, sin(iTime * 0.00) * 0.0, 0.0));\n    \n    Sphere s1;\n    s1.position = vec3(0.0, -0.0, -0.0);\n    s1.radius = 7.0;\n    s1.color = vec4(1.0, 0.0, 0.0, 0.0);\n \n    spheres[0] = s1;\n    draw();\n    fragColor = fcolor;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dBSzV","date":"1413648859","viewed":341,"name":"redplanet","username":"kuvkar","description":"textured ray-traced sphere planet with rim light","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""}}