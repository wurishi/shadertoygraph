{"ver":"0.1","info":{"id":"ll2XDy","date":"1534620148","viewed":640,"name":"blue dots","username":"TinyTexel","description":"a shader","likes":28,"published":1,"flags":0,"usePreview":0,"tags":["bloom","glow","blue","dots"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float Pi = 3.14159265359;\n\n#define Time iTime\n#define Frame iGlobalFrame\n#define PixelCount iResolution.xy\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define mad(x, a, b) ((x) * (a) + (b))\n#define rsqrt(x) inversesqrt(x)\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\n\n    \nfloat SDFtoMask(float sdf)\n{\n   return sdf / length(vec2(dFdx(sdf), dFdy(sdf))) * 1.2; \n}\n\nfloat Hash(float v)\n{\n    return fract(sin(v) * 43758.5453);\n}\n\nfloat Hash(vec2 v)\n{\n\treturn Hash(v.y + v.x * 12.9898);\n}\n\nfloat Hash(vec3 v)\n{\n\treturn Hash(v.y + v.x * 12.9898 + v.z * 33.7311);\n}\n\n\nfloat Pow2(float v){return v * v;}\nfloat Pow3(float v){return v * v * v;}\nfloat Pow4(float v){return Pow2(Pow2(v));}\nfloat Pow8(float v){return Pow2(Pow4(v));}\nfloat Pow16(float v){return Pow4(Pow4(v));}\nfloat Pow32(float v){return Pow16(Pow2(v));}\n\nfloat SqrLen(vec2 v){return dot(v, v);}\nfloat SqrLen(vec3 v){return dot(v, v);}\nfloat SqrLen(vec4 v){return dot(v, v);}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//=============================================================================================================================================//\n// \"Hash without Sine\"        | https://www.shadertoy.com/view/4djSRW \n//  Created by David Hoskins  | \n//  used under CC BY-SA 4.0   | https://creativecommons.org/licenses/by-sa/4.0/             \n//  reformatted from original |              \n//---------------------------------------------------------------------------------------------------------------------------------------------//\n\n// Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\nfloat Hash11I(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nfloat Hash12I(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nfloat Hash13I(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nvec2  Hash21I(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec2  Hash22I(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec2  Hash23I(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec3  Hash31I(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xxy  + p3.yzz ) * p3.zyx );}\nvec3  Hash32I(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE3); p3 += dot(p3, p3.yxz  + 19.19); return fract((p3.xxy  + p3.yzz ) * p3.zyx );}\nvec3  Hash33I(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE3); p3 += dot(p3, p3.yxz  + 19.19); return fract((p3.xxy  + p3.yxx ) * p3.zyx );}\nvec4  Hash41I(float p ){vec4 p4 = fract(vec4(p     ) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash42I(vec2  p ){vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash43I(vec3  p ){vec4 p4 = fract(vec4(p.xyzx) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash44I(vec4  p4){     p4 = fract(    (p4    ) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\n \n#undef HASHSCALE1\n#undef HASHSCALE3\n#undef HASHSCALE4\n\n//---------------------------------------------------------------------------------------------------------------------------------------------//\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\n\nfloat Hash11F(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nfloat Hash12F(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nfloat Hash13F(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nvec2  Hash21F(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec2  Hash22F(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec2  Hash23F(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec3  Hash31F(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xxy  + p3.yzz ) * p3.zyx );}\nvec3  Hash32F(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE3); p3 += dot(p3, p3.yxz  + 19.19); return fract((p3.xxy  + p3.yzz ) * p3.zyx );}\nvec3  Hash33F(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE3); p3 += dot(p3, p3.yxz  + 19.19); return fract((p3.xxy  + p3.yxx ) * p3.zyx );}\nvec4  Hash41F(float p ){vec4 p4 = fract(vec4(p     ) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash42F(vec2  p ){vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash43F(vec3  p ){vec4 p4 = fract(vec4(p.xyzx) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash44F(vec4  p4){     p4 = fract(    (p4    ) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\n\n#undef HASHSCALE1\n#undef HASHSCALE3\n#undef HASHSCALE4\n\n//=============================================================================================================================================//\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n/*\nfloat PowL_Exp(float x, const float f)\n{\n    const float d = 1.0 / (exp2(f) - 1.0);\n    \n    return mad(exp2(x * f), d, -d);\n}\n*/\n\nfloat EvalIntensityCurve(vec2 id, float time)\n{\n    time += Hash(id.yx * 1.733);\n    //time += Hash12I(id.yx);\n    \n    float iTime = floor(time);\n    float fTime = fract(time);\n    \n    float h = Hash(vec3(id, iTime));\n    //float h = Hash13I(vec3(id, iTime));\n    \n    //if(h < 0.9) h = 0.0;\n    //h = fract(id.x*0.23+id.y*0.1+iTime*0.09);\n    h *= h;\n    h *= h;\n    \n    float falloff = 1.0 - Pow2(fTime * 2.0 - 1.0);\n    \n    /*\n    falloff = Pow32(falloff);\n    /*/\n    {\n        const float f = 100.0;\n        const float d = 1.0 / (exp2(f) - 1.0);\n\n        falloff = mad(exp2(falloff * f), d, -d);\n    }\n    //*/\n    \n    //falloff = exp2(falloff * 100.1) - 1.0;\n    //falloff /= exp2(1.0 * 100.1) - 1.0;\n    \n    return h * falloff*1.0;\n}\n\nfloat GlowKern1(float x, float s)\n{\n    float rx = sqrt(x);\n    \n    return (exp(-s * rx) * s) / (2.0 * rx);\n}\n\nfloat GlowKern2(float x, float s)\n{\n    float rx = sqrt(x);\n    \n    return s / (2.0 * Pow2(1.0 + s * rx) * rx);\n}\n\nfloat GlowKern3(float x, float s)\n{    \n    return s / Pow3(1.0 + s * x);\n}\n\nfloat GlowKern4(float x, float c)\n{\n    return c * rsqrt(x * Pow3(x + c)) * 0.5;\n}\n\nfloat CurveU(float x, float u)\n{\n    return (u - u * x) / (u + x);\n}\n\nfloat EvalGlow3(vec2 uv, vec2 off, float time)\n{\n    vec2 iUV = floor(uv) + off;\n    vec2 fUV = fract(uv) - off;\n\n    vec2 fUV2 = fUV * 2.0 - 1.0;\n    \n    float dist2 = SqrLen(fUV2);\n    \n    float l = length(fUV2);\n    l = max(0.0, l - 0.7);\n    float glow = 0.0;\n    //glow = GlowKern1(l, 2.5);\n    //glow = GlowKern2(l, 4.0);\n    glow = GlowKern3(l, 1.2);\n  //glow = GlowKern4(l, 0.4);\n    //glow = CurveU(l * 0.25, 0.04);\n    \n    glow = clamp01(glow);\n    \n    glow *= clamp01(1.0 - Pow2(l*0.25));// window\n    \n    return EvalIntensityCurve(iUV.xy, time) * glow;\n}\n\n\nfloat PlotDot(vec2 sp, vec2 dp, float dr)\n{\n    float v = length(sp - dp);\n    \n    float d = v - dr;\n    //return d < 0.0 ? 1.0 : 0.0;\n    d /= length(vec2(dFdx(v), dFdy(v)));   \n    //d += 0.5;\n    d = clamp01(1.0 - d * 1.2);\n    \n    return d;\n}\n\nfloat EvalGlyph(vec2 uv, vec2 off, float time)\n{\n    vec2 iUV = floor(uv) + off;\n    vec2 fUV = fract(uv) - off;\n\n    vec2 fUV2 = fUV * 2.0 - 1.0;\n    \n    float distToCenter = length(fUV2);\n    \n    float gMask = distToCenter - 0.75;\n    \t  gMask = SDFtoMask(gMask);\n          gMask = clamp01(1.0 - gMask);\n    \n    gMask = PlotDot(fUV2, vec2(0.0), 0.75);\n    \n    return EvalIntensityCurve(iUV.xy, time) * gMask;\n}\n\n\nvec3 EvalTile(vec2 uv, vec2 off, float time)\n{\n    vec2 iUV = floor(uv) + off;\n    vec2 fUV = fract(uv) - off;\n\n    vec3 blue1 = vec3(0.02, 0.1, 1.0);\n    \n    float nTime = time*50.0;\n    float iTime = floor(nTime);\n    float fTime = fract(nTime);\n    \n    float n0 = Hash(vec3(uv, iTime));\n    float n1 = Hash(vec3(uv, iTime + 1.0));\n\n    //n0 = n1 = 1.0;\n    \n    float glyph = EvalGlyph(uv, off, time);\n    \n    float glow = 0.0;\n    \n    for(float i = -2.0; i <= 2.0; ++i)\n    for(float j = -2.0; j <= 2.0; ++j)\n    {\n        glow += EvalGlow3(uv, off + vec2(i, j), time); \n    }\n    \n\n\treturn vec3(mix(glow, glyph, 0.94)).xxx * blue1 * 32.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 uv0 )\n{\n\tvec2 uv = uv0.xy / iResolution.xy;\n    \n    vec2 coord = (uv0.xy - 0.5) * 0.1;\n    float time = iTime * 0.1;\n     \n    \n    \n    \n    vec3 outCol = vec3(1.0, 1.0, 1.0);\n    \n    outCol = vec3(0.0);\n    \n\toutCol = EvalTile(coord, vec2(0.0), time);\n    \n    //outCol = EvalTile(coord, vec2(0.0, 0.0), time);\n    \n    //fragColor = vec4(vec3(saturate(gMask)).xxx * vec3(Hash(iCoord)).xxx, 1.0); return;\n    //fragColor = vec4(outCol.xyz, 1.0); return;\n    fragColor = vec4(GammaEncode(clamp01(outCol.xyz)), 1.0); return;\n\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime*0.0),1.0);\n}","name":"Image","description":"","type":"image"}]}