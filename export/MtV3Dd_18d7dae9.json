{"ver":"0.1","info":{"id":"MtV3Dd","date":"1477550346","viewed":785,"name":"Fisheye projections for raymarch","username":"AmazingThew","description":"Sample code for raymarching using various curvilinear perspective projections, i.e. \"fisheye lens\"\n\nCouldn't find any clear examples of how to do this, so made one.\n\nMouse Y controls camera angle\nMouse X controls FOV","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","camera","fisheye","curvilinear"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**************************************************\nHOPEFULLY REUSABLE COLLECTION OF CAMERA PROJECTIONS\n\nThe raymarching/rendering code here is pretty much\nstandard tutorial fare. Only bit you're interested\nin is the code to find the raymarch direction.\n\nCREDITS:\nIq's ubiquitous distance functions: https://iquilezles.org/articles/distfunctions\nSimple raymarching setup adapted from some deleted reddit user's tutorial: https://www.reddit.com/r/twotriangles/comments/1hy5qy/tutorial_1_writing_a_simple_distance_field/\nUseful maths: http://paulbourke.net/dome/fisheye/\nConvenient list of lens functions: https://en.wikipedia.org/wiki/Fisheye_lens#Mapping_function\n(if you know of more projections described in similar polar form let me know!)\n\n**************************************************/\n\n// CAMERA TYPE:\n//#define PINHOLE\t\t\t\t//Traditional videogame camera. Looks weird unless FOV is relatively narrow\n#define STEREOGRAPHIC\t\t\t//Cool property: Spheres keep round silhouettes\n//#define EQUIANGULAR\n//#define EQUISOLID_ANGLE\n//#define ORTHOGRAPHIC_FISHEYE\n\n// WORLD\n#define ORBS\n//#define SCAFFOLDS\n//#define CAMERA_TARGET\n\n// Dithering looks cool since there's no AA\n#define DITHER\n\n\n//************************************************\n\n\n#define PI 3.14159265359\n\nconst int MAX_ITER = 100;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.00001;\nconst float FOG_START = 10.0;\nconst float FOG_END = 100.0;\nconst float SPIN_SPEED = 0.25;\n\nconst vec4 fogColor = vec4(0.08, 0.15, 0.22, 1.0);\nconst vec4 shadowColor = vec4(1.0, 0.15, 0.22, 1.0);\nconst vec4 lightColor  = vec4(1.00, 0.96, 0.91, 1.0);\n\nvec2 aux;\nvec3 cameraTarget;\nvec3 cameraPosition;\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = -sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat distanceField(vec3 p)\n{\n    vec3 c, q;\n    float xBox, yBox, zBox;\n    float dist = MAX_DIST;\n    float minor = 0.05;\n    float major = 2.5;\n    float soften = 0.05;\n    float separation = 5.;\n    \n    #ifdef ORBS\n        c = vec3(5.);\n        q = mod(p,c)-0.5*c;\n        dist = min(dist, sdSphere(q, 0.47));\n    #endif\n    \n    #ifdef SCAFFOLDS\n        c = vec3(separation);\n        q = mod(p,c)-0.5*c;\n\n        xBox = udRoundBox(q, vec3(major,minor,minor), soften);\n        yBox = udRoundBox(q, vec3(minor,major,minor), soften);\n        zBox = udRoundBox(q, vec3(minor,minor,major), soften);\n\n        dist = min(dist, min(min(xBox, yBox), zBox));\n    #endif\n    \n    #ifdef CAMERA_TARGET\n    \tq = p - cameraTarget;\n    \n    \txBox = udRoundBox(q, vec3(major,minor,minor), soften);\n        yBox = udRoundBox(q, vec3(minor,major,minor), soften);\n        zBox = udRoundBox(q, vec3(minor,minor,major), soften);\n\n        dist = min(dist, min(min(xBox, yBox), zBox));\n    #endif\n    \n    return dist;\n}\n\nvec3 getNormal(vec3 pos)\n{\n    vec2 eps = vec2(0.0, EPSILON);\n\treturn normalize(vec3(\n        distanceField(pos + eps.yxx) - distanceField(pos - eps.yxx),\n        distanceField(pos + eps.xyx) - distanceField(pos - eps.xyx),\n        distanceField(pos + eps.xxy) - distanceField(pos - eps.xxy)\n    ));\n}\n\nfloat dither(vec2 position, float brightness) {\n    #ifdef DITHER\n        float bayer = texture(iChannel0, position).r;\n        bayer = pow(bayer, 1.0 / 2.2);\n        bayer = (bayer + 1./64.) / (1.+1.2/64.); //Highly unscientific remap to allow full black/white\n        return step(bayer, brightness);\n    #endif\n    \n    return brightness;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    aux = iMouse.xy / iResolution.xy;\n    if (length(aux) == 0.0) aux = vec2(0.25);\n    mat4 rotMat = rotationMatrix(vec3(0., 1., 0.), iTime*SPIN_SPEED);\n    \n    \n    //HERE'S THE PART YOU CARE ABOUT\n    //********************************************\n    \n    vec3 up = vec3(0., 1., 0.);\n    cameraPosition = (vec4(-15., 1.5, -15., 1.) * rotMat).xyz;\n    cameraTarget   = vec3(0., mix(-50., 50., aux.y), 0.);\n    \n    \n    vec3 cameraForward = normalize(cameraTarget - cameraPosition);\n    vec3 cameraRight = normalize(cross(cameraForward, up));\n    vec3 cameraUp = cross(cameraForward, cameraRight);\n    \n    //Need camera orientation as 3D matrix; construct as you see fit\n    mat3 cameraOrientation = mat3(cameraRight, cameraUp, cameraForward);\n    \n    //Fragment coords remapped to -1,1 range\n    vec2 screenPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    //Aspect correction\n\tscreenPos.x *= iResolution.x / iResolution.y;\n    \n    //Calculate ray direction for current fragment\n    float aperture = aux.x * 2.0*PI;\n    float f = 1.0/aperture;\n    float r = length(screenPos);\n    float phi = atan(screenPos.y, screenPos.x);\n    float theta;\n    \n    #ifdef PINHOLE\n    \ttheta = atan(r/f);\n    #endif\n    \n    #ifdef STEREOGRAPHIC\n    \ttheta = atan(r/(2.0*f))*2.0;\n    #endif\n    \n    #ifdef EQUIANGULAR\n    \ttheta = r/f;\n    #endif\n    \n    #ifdef EQUISOLID_ANGLE\n    \ttheta = asin(r/(2.0*f))*2.0;\n    #endif\n    \n    #ifdef ORTHOGRAPHIC_FISHEYE\n    \ttheta = asin(r/f);\n    #endif\n    \n    //March in this direction for Good Graphics\n    vec3 rayDir = cameraOrientation * vec3(sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta));\n    \n    //********************************************\n    //END PART YOU CARE ABOUT\n    \n    \n    \n    vec3 normal;\n    vec2 ditherCoords = fragCoord/iChannelResolution[0].xy;\n    vec4 finalColor = fogColor;\n    vec3 sunDir = (vec4(normalize(vec3(-1., -1., 0.)), 1.0) * rotMat).xyz;\n    \n    //Raymarch\n    float totalDist = 0.0;\n    vec3 pos = cameraPosition;\n    float dist = EPSILON;\n\n    for (int i = 0; i < MAX_ITER; i++)\n    {\n        if (dist < EPSILON || totalDist > MAX_DIST)\n            break;\n\n        dist = distanceField(pos);\n        totalDist += dist;\n        pos += dist * rayDir;\n    }\n    \n    //Shade\n    if (dist < EPSILON)\n    {\n        normal = getNormal(pos);\n        float lightStrength = max(0.0, dot(sunDir, normal));\n      \tlightStrength = pow(lightStrength, 4.);\n        lightStrength = dither(ditherCoords, lightStrength);\n        \n        finalColor = mix(shadowColor, lightColor, lightStrength);\n        \n        float fogStrength = smoothstep(FOG_START, FOG_END, totalDist);\n        fogStrength = dither(ditherCoords, fogStrength);\n        \n        finalColor = mix(finalColor, fogColor, fogStrength);\n    }\n    \n    fragColor = finalColor;\n}","name":"Image","description":"","type":"image"}]}