{"ver":"0.1","info":{"id":"MX2BWR","date":"1729343338","viewed":50,"name":"shape_unyo","username":"enomotoai","description":"glsl is test","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["glsl"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 球の距離関数\nfloat sphereSDF(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\n// 立方体の距離関数\nfloat boxSDF(vec3 p, vec3 size) {\n    vec3 d = abs(p) - size;\n    float outsideDistance = length(max(d, 0.0));\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    return outsideDistance + insideDistance;\n}\n\n// スムーズな最小値を計算する関数\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat sceneSDF(vec3 p) {\n    // 時間に基づいてオブジェクトの位置と動きを変化させる\n    float time = iTime;\n    \n    // 初期値を大きな数に設定しておく\n    float d = 100.0;\n    \n    // 球の数を定義\n    int numSpheres = 10;  // ここで作りたい球の数を指定\n    \n    // 複数の球を生成して結合するためのループ\n    for (int i = 0; i < numSpheres; i++) {\n        // インデックスに基づいて動的に位置を設定\n        float angle = float(i) * 1.3 + time;  // 球の動きを調整\n        vec3 spherePos = vec3(sin(angle), cos(angle * 0.5), sin(angle * 0.7));\n        \n        // インデックスに基づいて半径を変える\n        float radius = 0.4 + 0.1 * float(i % 3);  // 球の半径を少し変化させる\n        \n        // 各球のSDFを計算し、他の球とスムーズに結合\n        float dSphere = sphereSDF(p - spherePos, radius);\n        d = smin(d, dSphere, 0.5);  // sminで滑らかに結合\n    }\n    \n    return d;  // 最終的なSDFを返す\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // 画面の座標を正規化\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // カメラの設定\n    vec3 cp = vec3(0.0, 0.0, -5.0);  // カメラの位置を近づける\n    vec3 target = vec3(0.0, 0.0, 0.0); // 注目するターゲット\n    vec3 cd = normalize(target - cp);   // カメラの向き\n    vec3 cs = normalize(cross(cd, vec3(0.0, 1.0, 0.0)));  // カメラの右方向\n    vec3 cu = normalize(cross(cs, cd)); // カメラの上方向\n    \n    // レイの方向\n    vec3 rd = normalize(cs * uv.x + cu * uv.y + cd);  // 視野角調整\n    \n    // レイマーチングのループ\n    float t = 0.0;\n    float maxDistance = 100.0;\n    int maxSteps = 100;\n    float d;\n    for (int i = 0; i < maxSteps; i++) {\n        vec3 p = cp + t * rd;  // 現在のレイの位置\n        d = sceneSDF(p);       // 距離を計算\n        if (d < 0.001) break;  // 十分近づいたら終了\n        t += d;                // レイを進める\n        if (t > maxDistance) break;  // 最大距離を超えたら終了\n    }\n    \n    // ヒットしたかどうかで色を決定\n    vec3 color;\n    if (t < maxDistance) {\n   // オブジェクトがヒットしたらkのグラデーションを作成\n        float b = 0.5 + 0.5 * sin(iTime + t * 0.2);  // kを動的に計算\n        float g = 0.2 + 0.2 * cos(iTime + t * 0.2);  // kを動的に計算\n        color = vec3(0.0, g, b);  // kに基づいて青からのグラデーション\n\n    } else {\n        color = vec3(0.0);  // ヒットしなかったら黒色\n    }\n    \n    // 最終的なフラグメントの色を設定\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}