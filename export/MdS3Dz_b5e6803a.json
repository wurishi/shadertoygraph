{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define AA4\n\nconst float DIST_EPS = .0001;\nconst float LIGHT_EPS = .01;\nconst float EPS = .0001;\nconst int LEN = 10;\n\nvec3 ulf = vec3(1,1,1);\nvec3 brn = vec3(0,0,0);\nconst vec4 cu = vec4(0,1,1,.3);\nconst vec4 cb = vec4(1,0,1,.3);\nconst vec4 cl = vec4(0,1,0,.3);\nconst vec4 cr = vec4(1,0,0,.3);\nconst vec4 cf = vec4(0,0,1,.3);\nconst vec4 cn = vec4(1,1,0,.3);\n\nstruct Ray{\n\tvec3 point, dir;\n\tvec4 col;\n\tfloat dist;\n};\nstruct Sphere{\n\tvec3 orig;\n\tfloat r2;\n\tvec4 col;\n};\nfloat maxG(const in vec3 v){\n\treturn max(v.x,max(v.y,v.z));\n}\nvec4 secCol(\n\tconst in vec4 _col,\n\tconst in vec4 col\n){\n\treturn vec4(\n\t\t\t_col.rgb + col.rgb * _col.a,\n\t\t\t_col.a * col.a\n\t);\n}\nfloat orbit(const in float time){\n\treturn .5 + sin(time) * .4;\n}\nfloat orbit(const in float a, const in float b){\n\treturn orbit(iTime / a + b);\n}\nvoid secSphere(\n\tconst in Sphere s,\n\tconst in Ray ray,\n\tinout Ray _ray\n){\n\tvec3 pos = s.orig - ray.point;\n\tvec3 prod = cross(pos, ray.dir);\n\tfloat h2 = dot(prod, prod);\n\tif(h2 >= s.r2)\n\t\treturn;\n\tfloat len = dot(pos, ray.dir);\n\tif(len <= 0.)\n\t\treturn;\n\tfloat d = len - sqrt(s.r2 - h2);\n\tif(d >= _ray.dist)\n\t\treturn;\n\tvec3 path = ray.dir * d;\n\tvec3 r = path - pos;\n\tfloat pr = dot(r, ray.dir) / dot(r,r);\n\t_ray.col = secCol(ray.col, s.col);\n\t_ray.dir = normalize(ray.dir - r * (pr * 2.));\n\t_ray.point = ray.point + path + _ray.dir * DIST_EPS;\n\t_ray.dist = d;\n}\n\nvoid secCube(\n\tconst in Ray ray,\n\tout Ray _ray\n){\n\tvec3 t1 = ray.dir / (brn - ray.point);\n\tvec3 t2 = ray.dir / (ulf - ray.point);\n\tfloat mt1 = maxG(t1), mt2 = maxG(t2);\n\tfloat mt = max(mt1,mt2);\n\tvec3 path = ray.dir / mt;\n\t_ray.point = ray.point + path;\n\tvec4 col = vec4(0);\n\t_ray.dir = ray.dir;\n\tif(mt - EPS <= mt1){\n\t\tif(mt - EPS <= t1.x){\n\t\t\tcol = cl;\n\t\t\t_ray.dir.x *= -1.;\n\t\t}else if(mt - EPS <= t1.y){\n\t\t\tcol = cu;\n\t\t\t_ray.dir.y *= -1.;\n\t\t}else{\n\t\t\tcol = cn;\n\t\t\t_ray.dir.z *= -1.;\n\t\t}\n\t}else{\n\t\tif(mt - EPS <= t2.x){\n\t\t\tcol = cr;\n\t\t\t_ray.dir.x *= -1.;\n\t\t}else if(mt - EPS <= t2.y){\n\t\t\tcol = cb;\n\t\t\t_ray.dir.y *= -1.;\n\t\t}else{\n\t\t\tcol = cf;\n\t\t\t_ray.dir.z *= -1.;\n\t\t}\n\t}\n\t_ray.point += _ray.dir * DIST_EPS;\n\tcol.xyz *= (1. - col.w);\n\t_ray.col = secCol(ray.col, col);\n\t_ray.dist = dot(path, ray.dir);\n}\n\nconst Sphere s1 = Sphere(\n\t\tvec3(.5,.5,.5),\n\t\t.09,\n\t\tvec4(0.,0.,0.,.9)\n);\nconst Sphere s2 = Sphere(\n\t\tvec3(.8,.8,.21),\n\t\t.04,\n\t\tvec4(0.,0.,0.,.9)\n);\nconst Sphere s3 = Sphere(\n\t\tvec3(.95,.95,.055),\n\t\t.0025,\n\t\tvec4(0.,0.,0.,.9)\n);\nconst Sphere s4 = Sphere(\n\t\tvec3(.2,.7,.4),\n\t\t.0144,\n\t\tvec4(0.,0.,0.,.7)\n);\n\nSphere motion;\n\nRay secAll(\n\tconst in Ray ray\n){\n\tRay _ray;\n\tsecCube(ray, _ray);\n\tsecSphere(s1, ray, _ray);\n\tsecSphere(s2, ray, _ray);\n\tsecSphere(s3, ray, _ray);\n\tsecSphere(s4, ray, _ray);\n\tsecSphere(motion, ray, _ray);\n\treturn _ray;\n}\n\nvec3 raycast(const in vec2 uv) {\n\tRay ray = Ray(\n\t\t\tvec3(uv,DIST_EPS),\n\t\t\tnormalize(vec3(\n\t\t\t\tuv - vec2(\t\t\t//* <- add one '/'\n\t\t\t\t\torbit(2.9, .1), orbit(1.9, 34.)\t\t/*/\n\t\t\t\t\t.5, .5\t//*/\n\t\t\t\t),\n\t\t\t\t1.5\n\t\t\t)),\n\t\t\tvec4(0., 0., 0., 1.),\n\t\t\t0.\n\t);\n    for(int i=0; i<LEN; i++) {\n\t\tif(ray.col.a < LIGHT_EPS)\n\t\t\tbreak;\n\t\telse{\n\t\t\tRay _ray = secAll(ray);\n\t\t\tray = _ray;\n\t\t}\n    }\n    return ray.col.xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat d = min(iResolution.x, iResolution.y);\n\tvec2 scale = vec2(d, d);\n\tulf = vec3(iResolution.xy / scale, 1);\n\tbrn = vec3((vec2(1, 1) - ulf.xy) / 2., 0);\n\tulf += brn;\n\tmotion = Sphere(\n\t\tvec3(\n\t\t\torbit(2., 1.),\n\t\t\torbit(3., 6.),\n\t\t\torbit(5., .0)\n\t\t),\n\t\t.005 * orbit(4., .0),\n\t\tvec4(0.,0.,0.,.9)\n\t);\n    #ifdef AA4\n    vec3 color = (\n        raycast((fragCoord.xy + vec2( .25,  .25)) / scale + brn.xy) +\n        raycast((fragCoord.xy + vec2( .25, -.25)) / scale + brn.xy) +\n        raycast((fragCoord.xy + vec2(-.25,  .25)) / scale + brn.xy) +\n        raycast((fragCoord.xy + vec2(-.25, -.25)) / scale + brn.xy)\n    ) * .25;\n    #else\n    vec3 color = raycast(fragCoord.xy / scale + brn.xy);\n    #endif\n\tfragColor = vec4(\n\t\t\tcolor,\n\t\t\t1.\n\t);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdS3Dz","date":"1386028209","viewed":272,"name":"Spheres trash","username":"Izokina","description":"Just tried to make spheres","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","simple"],"hasliked":0,"parentid":"","parentname":""}}