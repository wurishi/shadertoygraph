{"ver":"0.1","info":{"id":"ldjBD1","date":"1500657779","viewed":385,"name":"Medal for discord II","username":"SudoNhim","description":"Another discord avatar","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["medal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n#define TWOPI PI*2.0\n\n/* Want to make your own medal!? :D\n\nSteps:\n\t1] define the surface of your new medal in the height() function\n\t2] tweak the coloring as desired in the main() function\n\t3] mouse around to get the lighting *just right* and take a screenie\n\t4] crop it down in a paint program\n\t5] use another tool like http://www.online-image-editor.com/ to make the background transparent\n*/\n\n// There's a simplex noise implementation at the end of this file. We'll forward-declare it here.\n// This is just a way to make smoothly varying random surfaces. Scale the input coords to change\n// frequency, scale the output to change amplitude. Add multiple frequencies and amplitudes to make\n// more realistic surfaces. Output is over [-1, 1]\nfloat snoise(vec2 v);\n\n// This defines the 3D shape of the medal as a heightmap. The input vector varies from (-1,-1) to (1,1)\n// over the medal area. You probably want the output to vary over about [0, 0.1]. A few examples of how\n// to construct this are included. By far the most useful GLSL function here is smoothstep().\n// See: https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/smoothstep.xhtml\nfloat height(vec2 p, vec3 tex) {\n\n\t// Polar coordinates on a medal will surely be useful!\n\tfloat r = length(p);\n\tfloat theta = atan(p.x, p.y) + PI; // [0, TWOPI] is often more useful than [-PI, PI]\n\t\n\t// A ridge around the perimeter of the medal, nothing in the center. You may want to re-use this.\n\tfloat h1 = smoothstep(0.875, 0.9, r); // h1 goes from 0->1 towards the outside, as r goes from 0.8->0.85\n\tfloat h2 = smoothstep(1.0, 0.975, r); // h2 goes from 0->1 towards the inside as r goes from 1.0->0.95\n\tfloat base = h1*h2*0.025; // multiply them together to get a ridge to 1.0 centred on r=0.9. Scale by 0.03\n    \n    base += texture(iChannel1, p/6.0 + 0.5).r*0.02;\n\t\n\t/* An unfinished spiral shape\n\tfloat spiral = smoothstep(0.0, 1.0, theta) * smoothstep(6.0, 5.0, theta);\n\tspiral *= smoothstep(0.4, 0.5, r + theta*0.08) * smoothstep(0.6, 0.5, r + theta*0.07);\n\tspiral *= 0.1;\n\t*/\n\t\n\t/* A flared cross\n\tfloat flare = r*0.2;\n\tvec2 crossvals = (\n\t\tsmoothstep(-0.7, -0.6, p) * smoothstep(0.7, 0.6, p) *\n\t\tsmoothstep(0.12+flare, 0.1+flare*0.6, p.yx) * smoothstep(0.12+flare, 0.1+flare*0.6, -p.yx));\n\tfloat crssh = max(crossvals.x, crossvals.y)*0.05;\n\t*/\n\t\n\t// A yin-yang\n\tp *= 1.0/0.78; // scale down coordinate space so we aren't drawing on the border ridge\n\tfloat edge = 0.06; // how sharp to make the edges of the geometry\n\tfloat hole = 0.1; // what size to make the small holes\n\tfloat yinR = length(p-vec2(0.0, 0.5));\n\tfloat yanR = length(p+vec2(0.0, 0.5));\n\tfloat whole = smoothstep(1.0+edge/2.0, 1.0-edge/2.0, length(p));\n\tfloat yinBig = smoothstep(0.5+edge/2.0, 0.5-edge/2.0, yinR);\n\tfloat yanBig = smoothstep(0.5+edge/2.0, 0.5-edge/2.0, yanR);\n\tfloat yinSmall = smoothstep(hole+edge, hole, yinR);\n\tfloat yanSmall = smoothstep(hole+edge, hole, yanR);\n\tfloat leftSide = smoothstep(edge, -edge, p.x);\n\tfloat yinyang = max(yinBig*(1.0-yinSmall), yanSmall);\n\tyinyang = max(yinyang, whole*leftSide*(1.0-yanBig)*(1.0-yinSmall))*0.04;\n\t\n\t\n\treturn (tex.b*0.05-0.03) + max(base,  yinyang);\n}\n\n// A hacky little fake ambient occlusion calculation. Samples a 10x10 grid around the position and returns\n// an estimation of how much ambient light will be blocked\nfloat occlusion(vec2 p, vec3 tex) {\n\tfloat result = 0.0; float h1=height(p, tex);\n\tfor (float dx=-0.1; dx<=0.1; dx+=0.02)\n\tfor (float dy=-0.1; dy<=0.1; dy+=0.02) {\n\t\tfloat adj = pow(10.0*(0.2-length(vec2(dx, dy))), 2.0);\n\t\tresult += max(0.0, min(0.015, height(p+vec2(dx, dy), tex)-h1))*adj;\n\t}\n\treturn result/3.0;\n}\n\n// Calculate the surface normal at a position p by sampling the heightmap.\n// This is also hacky - it intentionally uses an overly course sample to smooth sharp edges a little so\n// you can get that nice specular gleaming edge without having to put extra detail into your height()\nvec3 normal(vec2 p, vec3 tex) {\n\tvec2 dd = vec2(0.0, 0.02);\n\treturn normalize(vec3(\n\t\theight(p+dd.xy, tex)-height(p-dd.xy, tex),\n\t\theight(p+dd.xy, tex)-height(p-dd.yx, tex),\n\t\tdd.y*2.0));\n}\n\n// Entry point for the shader program\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\t// Set up coordinate space\n\tvec2 uv = fragCoord / iResolution.yy;\n\tuv = uv*2.0-1.0;\n\t\n\t// Hack warning! This here distorts the coordinate space slightly, scaling it unevenly\n\t// so that the medal fits within the specified size but is not perfectly circular. I think\n\t// it makes it look better :)\n\tuv = uv * (1.04 + 0.04*snoise(uv*0.4));\n\t\n\t// Cut out medal circle\n\tif (length(uv) > 1.0) { \n\t\tfragColor = vec4(vec3(0.05), 1.0);\n\t\treturn;\n\t}\n    \n    // A good tex combination for a kind of \"weathered stone\" surface\n\tvec3 tex = texture(iChannel0, uv/2.0 + 0.5).rgb;\n\t\n\t// Gather all our information....\n\tfloat h = height(uv, tex);\n\tvec3 nrm = normal(uv, tex);\n\tvec3 refl = reflect(vec3(0.0, 0.0, 1.0), nrm);\n\tfloat occ = occlusion(uv, tex);\n\t\n\t// We aren't fancy, Blinn-Phong shading is good enough for us!\n\t// Use a light direction based on the mouse position\n\tvec3 lightDir = normalize(-vec3(iMouse.xy/iResolution.xy-0.5, 0.2));\n\t\n\t// How much light does the surface get from the light source?\n\tfloat diffuse = max(dot(lightDir, -nrm)/3.0, 0.0); \n\t\n\t// Add a little extra light everywhere\n\tfloat ambient = (1.0-occ)*0.3; \n\t\n\t// Do we see a reflection of the light source?\n\tfloat specular = pow(max(0.0, dot(refl, lightDir)), 32.0); \n\t\n\t// Build a color out of everything we know. You can just go nuts here.\n\t// Although if you want to play it safe and just change the colors, modify\n\t// the vec3(r,g,b)s.\n\tvec3 color = vec3(0.0);\n\tcolor += vec3(0.7, 0.8, 0.9) * (1.0-occ) * 2.0;\n\tcolor += vec3(1.0, 0.3, 0.3) * occ * 0.3; // you can exploit occ make fake rust/weathering\n\tcolor += vec3(1.0, 0.9, 0.4) * h * 25.0;\n    color *= (0.5 + tex);\n\t\n\tcolor = (1.0 + 9.0*diffuse + 3.0*ambient) * color + 5.0*specular;\n\tcolor *= log(color)/35.0;\n\t\n\tfragColor = vec4(color, 1.0);\n}\n\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n","name":"Image","description":"","type":"image"}]}