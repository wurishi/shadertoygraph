{"ver":"0.1","info":{"id":"4XsSRB","date":"1709674582","viewed":136,"name":"Grassy lanscape raymarched","username":"MonadoMaster0","description":"maybe it is more like a forest but hey, this is juast a start","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","landscape","valuenoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat map(vec3 p) {\n    float val = 0.0;\n    \n    //landscape\n    vec3 land = p;\n    land.yz*=rot(0.3);\n    land.y += 0.4 + fbm(p.xz*0.2,1)*5.0;\n    val = land.y;\n    land.x += fbm(p.xz+iTime*0.1,3);\n    vec3 gr = land;\n    gr.xz = fract(gr.xz*8.)-0.5;\n    if (gr.y==0.0) {\n        gr.xz += -hash22(gr.xz);\n    }\n    val = min(val, sdVerticalCapsule(gr, 0.3, 0.3));\n    \n    return val;\n}\n\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float eps = 0.00001; // or some other value\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(map(p+h.xyy) - map(p-h.xyy),\n                           map(p+h.yxy) - map(p-h.yxy),\n                           map(p+h.yyx) - map(p-h.yyx) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    \n    //Initialization\n    float zoom = 0.0;\n    vec3 ro = vec3(0,0,zoom-3.0);\n    vec3 rd = normalize(vec3(uv,zoom+1.0));\n    float t = 0.0; //total distance travelled\n    int i;\n    vec3 p;\n    \n    //Raymarching\n    for (i=0;i++<80;) {\n        p = ro + rd * t;\n        float d = map(p);\n        t+=d;\n        \n        if (d<0.001 || t>100.) break;\n    }\n    \n    //Lighting\n    vec3 norm = calcNormal(p);\n    vec3 lo = normalize(vec3(-1,1,-3));\n    float light = dot(lo,norm);\n    \n    col+= t*0.00+float(i)/80.;\n    //col+= light;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n\nfloat quinticHermite(float f)\n{\n    return f*f*f*(f*(6.0*f-15.0)+10.);\n}\n\nvec2 quinticHermite(vec2 f)\n{\n    return f*f*f*(f*(6.0*f-15.0)+10.);\n}\n\nmat2 rot(float t) {\n    float c=cos(t), s=sin(t);\n    return mat2(c,-s,s,c);\n}\n\nfloat hash21(vec2 p) {\n    vec2 seed = vec2(4.537, 56.12);\n    float h = dot(p,seed);\n    return fract(sin(h)*67777.532);\n}\n\nvec2 hash22(vec2 p) {\n    float s = dot(p, vec2(716.837,433.103));\n    float d = dot(p, vec2(261.293,102.063));\n    return fract(sin(vec2(s,d))*(47546.9294))*0.4;\n}\n\nfloat vnoise(vec2 p) {\n    p += PI*2.0;\n    p *= 1.0;\n    float c = 0.0;\n\n    vec2 id = mod(floor(p),289.0);\n    vec2 gv = fract(p);\n    gv = quinticHermite(gv);\n\n    float topLeft = hash21(id+vec2(-0.5,0.5)),\n          topRight = hash21(id+vec2(0.5,0.5)),\n          botLeft = hash21(id+vec2(-0.5,-0.5)),\n          botRight = hash21(id+vec2(0.5,-0.5));\n    float top = mix(topLeft,topRight,gv.x),\n          bottom = mix(botLeft, botRight, gv.x);\n    c += mix(bottom,top, gv.y);\n\n    return mix(bottom,top, gv.y);\n    }\n\nfloat fbm(vec2 p, int oct) {\n    \n    float brightness = 0.5;\n    \n    float val = 0.0;\n    float amp = 0.5;\n    float freq = 2.0;\n    float back = 0.0;\n    \n    //val+=amp*noise(p*freq);\n    for (int i=0;i<oct;i++) {\n        val += amp*vnoise(p);\n        //p.x+=vnoise(p)*4.0;\n        p*=freq;\n        p*=rot(1.0);\n        amp*=exp(-float(i));\n        freq*=2.0;\n        \n    }\n    return val;\n}","name":"Common","description":"","type":"common"}]}