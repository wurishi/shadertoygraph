{"ver":"0.1","info":{"id":"3ldcR4","date":"1608651931","viewed":96,"name":"Raymarched Equilateral Triangles","username":"Xenation","description":"A simple raymarching shader of infinitely tilling equilateral triangles.\nContains some unused code and proper lighting (PBR style) although it isn't really showcased here.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shader by Xenation / HalfRed\n// some signed distance functions from Inigo Quilez: https://iquilezles.org/articles/distfunctions\n// most lighting code is based upon what I made in my experimental engine: https://github.com/Xenation/IonEngine\n\n#define TWO_PI 6.28318530718\n#define PI 3.14159265359\n#define HALF_PI 1.5707963268\n#define THIRD_PI 1.0471975512\n#define QUARTER_PI 0.7853981634\n#define DEG_TO_RAD 0.0174533\n\nconst float MAX_DISTANCE = 50.0;\nconst float EPSILON = 0.0001;\n\nconst float ROTATION_SPEED = 0.2;\n\n// ---- UTILITIES ----\n// Structures\nstruct CameraDescriptor {\n    vec3 position;\n    vec3 target;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Light {\n    vec3 position;\n    vec3 intensity;\n    int type; // 0: ambient, 1: directional, 2: point\n};\n\nstruct Material {\n    vec3 albedo;\n    vec3 emissive;\n    float metallic;\n    float reflectance;\n    float roughness;\n};\n\nstruct SurfaceData {\n    vec3 diffuse;\n    float roughness;\n    vec3 f0;\n};\n\n// Functions\nfloat remap(float val, float inMin, float inMax, float outMin, float outMax) {\n\treturn (val - inMin) / (inMax - inMin) * (outMax - outMin) + outMin;\n}\n\nmat3 ViewToWorld(CameraDescriptor cam) {\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    vec3 f = normalize(cam.target - cam.position);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n    return mat3(s, u, f);\n\t/*return mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(0.0, 0.0, 0.0, 1.0)\n\t);*/\n}\n\nvec3 RayDirection(in float fov, in vec2 size, in vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, z));\n}\n\nSurfaceData CreateSurfaceData(in Material material) {\n    SurfaceData data;\n    data.f0 = material.albedo * material.metallic + (material.reflectance * (1.0 - material.metallic));\n    data.diffuse = (1.0 - material.metallic) * material.albedo;\n    data.roughness = material.roughness * material.roughness;\n    return data;\n}\n\nMaterial BlendMaterial(Material m1, Material m2, float w) {\n    Material blendMat;\n    blendMat.albedo = mix(m1.albedo, m2.albedo, w);\n    blendMat.emissive = mix(m1.emissive, m2.emissive, w);\n    blendMat.metallic = mix(m1.metallic, m2.metallic, w);\n    blendMat.reflectance = mix(m1.reflectance, m2.reflectance, w);\n    blendMat.roughness = mix(m1.roughness, m2.roughness, w);\n    return blendMat;\n}\n\n// ---- SDFs ----\nfloat sdSphere(vec3 pos, float radius) {\n    return length(pos) - radius;\n}\n\nfloat sdBox(vec3 pos, vec3 b) {\n  vec3 q = abs(pos) - b;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdTriPrism(vec3 pos, vec2 h) {\n    vec3 q = abs(pos);\n    return max(q.z - h.y, max(q.x * 0.866025 + pos.y * 0.5, -pos.y) - h.x * 0.5);\n}\n\nfloat sdFloor(vec3 pos, float height) {\n    return pos.y - height;\n}\n\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nvec3 opRepeat(in vec3 pos, in vec3 size) {\n    return mod(pos + 0.5 * size, size) - 0.5 * size;\n}\n\nvec3 rotateY(in vec3 p, float t) {\n    float co = cos(t);\n    float si = sin(t);\n    p.xz = mat2(co,-si,si,co)*p.xz;\n    return p;\n}\n\nvec3 rotateX(in vec3 p, float t) {\n    float co = cos(t);\n    float si = sin(t);\n    p.yz = mat2(co,-si,si,co)*p.yz;\n    return p;\n}\nvec3 rotateZ(in vec3 p, float t) {\n    float co = cos(t);\n    float si = sin(t);\n    p.xy = mat2(co,-si,si,co)*p.xy;\n    return p;\n}\n\nfloat opSmoothUnionMat(float d1, float d2, Material m1, Material m2, float k, out Material blendMat) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    blendMat = BlendMaterial(m1, m2, h);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\n// Scene\nfloat sdScene(vec3 pos, out Material material) {\n    Material matFloor;\n    matFloor.albedo = vec3(0.1, 0.1, 0.1);\n    matFloor.metallic = 0.0;\n    matFloor.reflectance = 0.0;\n    matFloor.roughness = 0.2;\n    \n    const float waveSpeed = 1.0;\n    const float waveLength = 2.0;\n    const float waveAmplitude = 5.0;\n    const float wavePow = 5.0;\n    Material matShapes;\n    matShapes.emissive = vec3(1.0, 0.1, 0.1);\n    matShapes.emissive += vec3(1.0, 0.0, 0.0) * pow(clamp(sin(length(pos.xz / waveLength) - iTime * waveSpeed), 0.0, 1.0), wavePow) * waveAmplitude;\n    matFloor.roughness = 0.9;\n\n    float boxDist = 0.0;\n    vec3 boxPos = pos;\n    vec3 subPos = opRepeat(pos, vec3(0.866025 * 2.0, 100, 3.0)) + vec3(0.0, 0.0, -1.00);\n    \n    boxDist = sdBox(boxPos, vec3(1000.0, 0.05, 1000.0));\n    boxDist = opSubtraction(sdBox(rotateY(subPos + vec3(0.0, 0.0, -0.5), HALF_PI), vec3(0.05, 0.5, 5.0)), boxDist);\n    boxDist = opSubtraction(sdBox(rotateY(subPos + vec3(0.0, 0.0, 1.0), HALF_PI), vec3(0.05, 0.5, 5.0)), boxDist);\n    boxDist = opSubtraction(sdBox(rotateY(subPos + vec3(0.0, 0.0, 2.5), HALF_PI), vec3(0.05, 0.5, 5.0)), boxDist);\n    boxDist = opSubtraction(sdBox(rotateY(subPos + vec3(0.433012, 0.0, 0.25), HALF_PI - THIRD_PI), vec3(0.05, 0.5, 5.0)), boxDist);\n    boxDist = opSubtraction(sdBox(rotateY(subPos + vec3(-0.433012, 0.0, 0.25), HALF_PI + THIRD_PI), vec3(0.05, 0.5, 5.0)), boxDist);\n    \n    float finalDist = opSmoothUnionMat(boxDist, sdFloor(pos, 0.0), matShapes, matFloor, 0.05, material);\n    \n    return finalDist;\n}\n\n// ---- Lighting ----\nvec3 EstimateNormal(vec3 pos) {\n    Material dummyMat;\n    return normalize(vec3(\n        sdScene(vec3(pos.x + EPSILON, pos.y, pos.z), dummyMat) - sdScene(vec3(pos.x - EPSILON, pos.y, pos.z), dummyMat),\n        sdScene(vec3(pos.x, pos.y + EPSILON, pos.z), dummyMat) - sdScene(vec3(pos.x, pos.y - EPSILON, pos.z), dummyMat),\n        sdScene(vec3(pos.x, pos.y, pos.z  + EPSILON), dummyMat) - sdScene(vec3(pos.x, pos.y, pos.z - EPSILON), dummyMat)\n    ));\n}\n\nfloat D_GGX(float NoH, float a) {\n\tfloat a2 = a * a;\n\tfloat f = (NoH * a2 - NoH) * NoH + 1.0;\n\treturn a2 / (PI * f * f);\n}\n\nvec3 F_Schlick(float VoH, vec3 f0) {\n\treturn f0 + (vec3(1.0) - f0) * pow(1.0 - VoH, 5.0);\n}\n\nfloat V_SmithGGXCorrelatedFast(float NoV, float NoL, float roughness) {\n\tfloat GGXV = NoL * (NoV * (1.0 - roughness) + roughness);\n\tfloat GGXL = NoV * (NoL * (1.0 - roughness) + roughness);\n\treturn 0.5 / (GGXV + GGXL);\n}\n\nfloat Fd_Lambert() {\n\treturn 1.0 / PI;\n}\n\nvec3 EnvironmentColor(vec3 direction) {\n\tfloat DoU = dot(direction, vec3(0.0, 1.0, 0.0));\n\tfloat s = clamp(remap(acos(DoU), 110.0 * DEG_TO_RAD, 90.0 * DEG_TO_RAD, 0.0, 1.0), 0.0, 1.0);\n\treturn mix(vec3(0.10, 0.10, 0.10), vec3(0.85, 1.00, 1.00), s);\n}\n\nvec3 Environment(SurfaceData surfData, vec3 envColor) {\n\tenvColor *= surfData.f0;\n\tenvColor /= surfData.roughness + 1.0;\n\treturn envColor;\n}\n\nvec3 BRDF(SurfaceData surfData, vec3 normal, vec3 lightDir, vec3 viewDir) {\n    vec3 halfDir = normalize(viewDir + lightDir);\n\n\tfloat NoV = abs(dot(normal, viewDir)) + 1e-5;\n\tfloat NoL = clamp(dot(normal, lightDir), 0.0, 1.0);\n\tfloat NoH = clamp(dot(normal, halfDir), 0.0, 1.0);\n\tfloat LoH = clamp(dot(lightDir, halfDir), 0.0, 1.0);\n\n\tfloat a = NoH * surfData.roughness;\n\n\tfloat D = D_GGX(NoH, a);\n\tvec3 F = F_Schlick(LoH, surfData.f0);\n\tfloat V = V_SmithGGXCorrelatedFast(NoV, NoL, surfData.roughness);\n\n\tvec3 Fr = (D * V) * F;\n\n\tvec3 Fd = surfData.diffuse;// * Fd_Lambert(); // Removed Lambert to avoid huge diffuse loss\n\n\treturn Fr + Fd + Environment(surfData, EnvironmentColor(reflect(-viewDir, normal)));\n}\n\nvec3 ComputeAmbient(vec3 pos, vec3 normal, Ray ray, SurfaceData surfData, Light light) {\n    return surfData.diffuse * light.intensity;\n}\n\nvec3 ComputeDirectionalLight(vec3 pos, vec3 normal, Ray ray, SurfaceData surfData, Light light) {\n    vec3 lightDir = normalize(-light.position);\n\tvec3 lightColor = light.intensity;\n\n\tfloat lightAtten = 1.0;\n\tfloat NoL = clamp(dot(normal, lightDir), 0.0, 1.0);\n\tvec3 radiance = lightColor.rgb * (lightAtten * NoL);\n\treturn BRDF(surfData, normal, lightDir, -ray.direction) * radiance;\n}\n\nvec3 ComputePointLight(vec3 pos, vec3 normal, Ray ray, SurfaceData surfData, Light light) {\n    vec3 lightDir = light.position - pos;\n\tfloat dist = sqrt(dot(lightDir, lightDir));\n\tfloat lightAtten = 1.0 / dist;\n    lightDir /= dist;\n\n\tfloat NoL = clamp(dot(normal, lightDir), 0.0, 1.0);\n\tvec3 radiance = light.intensity * (lightAtten * NoL);\n\treturn BRDF(surfData, normal, lightDir, -ray.direction) * radiance;\n}\n\nvec3 ComputeIllumination(vec3 pos, vec3 normal, Ray ray, SurfaceData surfData, Light light) {\n    if (light.type == 0) {\n        return ComputeAmbient(pos, normal, ray, surfData, light);\n    } else if (light.type == 1) {\n        return ComputeDirectionalLight(pos, normal, ray, surfData, light);\n    } else if (light.type == 2) {\n        return ComputePointLight(pos, normal, ray, surfData, light);\n    }\n}\n\n// ---- Ray Marching ----\nvec4 March(Ray ray, out Material material) {\n    float rayDistance = 0.0;\n    \n    vec3 pos = ray.origin;\n    while (rayDistance < MAX_DISTANCE) {\n        pos = ray.origin + ray.direction * rayDistance;\n        float dist = sdScene(pos, material);\n        \n        if (dist < EPSILON) {\n            break;\n        }\n        \n        rayDistance += dist;\n    }\n    \n    return vec4(pos, rayDistance);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Setting up the camera\n    CameraDescriptor cam;\n    cam.position = vec3(cos(iTime * ROTATION_SPEED - HALF_PI) * 5.0, 3.0, sin(iTime * ROTATION_SPEED - HALF_PI) * -5.0);\n    cam.target = vec3(0.0);\n    \n    mat3 vtw = ViewToWorld(cam);\n    \n    // Setting up 4 rays per pixel with coords roughly similar to 4x MSAA sampling\n    vec2 rayCoord = fragCoord - vec2(0.5);\n    Ray rays[4];\n    rays[0].origin = cam.position;\n    rays[1].origin = cam.position;\n    rays[2].origin = cam.position;\n    rays[3].origin = cam.position;\n    rays[0].direction = vtw * RayDirection(90.0, iResolution.xy, rayCoord + vec2(0.4, 0.1));\n    rays[1].direction = vtw * RayDirection(90.0, iResolution.xy, rayCoord + vec2(0.9, 0.4));\n    rays[2].direction = vtw * RayDirection(90.0, iResolution.xy, rayCoord + vec2(0.6, 0.9));\n    rays[3].direction = vtw * RayDirection(90.0, iResolution.xy, rayCoord + vec2(0.1, 0.6));\n    \n    // Setting up lights\n    Light ambient;\n    ambient.type = 0;\n    ambient.intensity = vec3(0.9, 1.0, 0.9) * 0.1;\n    \n    Light point;\n    point.type = 2;\n    point.position = vec3(0.0, 2.0, 0.0);\n    point.intensity = vec3(1.0);\n    \n    Light dirLight;\n    dirLight.type = 1;\n    dirLight.position = vec3(-0.3, -1, 0.5);\n    dirLight.intensity = vec3(0.5);\n    \n    // Raymarch each ray\n    fragColor = vec4(0.0);\n    for (int i = 0; i < 4; i++) {\n        Material material;\n        vec4 marchResult = March(rays[i], material);\n        vec3 pos = marchResult.xyz;\n        float depth = marchResult.w;\n\n        if (depth > MAX_DISTANCE) {\n            fragColor = vec4(0.0);\n            return;\n        }\n\n        SurfaceData surfData = CreateSurfaceData(material);\n        vec3 normal = EstimateNormal(pos);\n\n        fragColor.rgb += material.emissive;\n        fragColor.rgb += ComputeIllumination(pos, normal, rays[i], surfData, ambient);\n        fragColor.rgb += ComputeIllumination(pos, normal, rays[i], surfData, point);\n        fragColor.rgb += ComputeIllumination(pos, normal, rays[i], surfData, dirLight);\n    }\n    fragColor.rgb /= 4.0;\n}","name":"Image","description":"","type":"image"}]}