{"ver":"0.1","info":{"id":"DdBcDc","date":"1688245033","viewed":90,"name":"Cosine gradient generator cartes","username":"Envy24","description":"Recreation of this great site:\nhttp://dev.thi.ng/gradients/\nPolar part: https://www.shadertoy.com/view/ddSyWd\nIn my case x used in range [0., 2.], which is slightly differs from site [0., 1.] by a factor of 2.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["gradient","cosine","generator"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define UNIT                      ( 4.0 / iResolution.y )\n#define SMAA(d)                   ( smoothstep(UNIT, 0., d) )\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat draw_explicit_func(vec2 NDC, float fx, float dfdx)\n{\n    float sdf = NDC.y - fx;\n    return SMAA(abs(sdf) / sqrt(1.0 + dfdx * dfdx)); // absolute value / arclenght over unit length interval\n}\n\n#define DC_OFFSET  vec3(0.500, 0.500, 0.500)\n#define AMP        vec3(1.000, 1.000, 1.000)\n#define FREQ       vec3(1.000, 1.000, 1.000)\n#define PHASE      vec3(0.000, 0.333, 0.667)\nfloat cosOSC(float x, float DC, float A, float F, float P)\n{\n#define TAU                         6.2831853071795862\n#define PI                          3.1415926535897932\n    return clamp(( DC + A * cos(P*TAU + F*x*PI) ), 0., 1.);    // for x in range [0., 2.]\n    //return clamp(( DC + A * cos(TAU*(P + F*x)) ), 0., 1.);; // for x in range [0., 1.]\n}\nfloat dydx(float x, float DC, float A, float F, float P)\n{\n    const float dx = 0.01;\n    return (cosOSC(x+dx, DC, A, F, P) - cosOSC(x-dx, DC, A, F, P) ) / (2.*dx);\n}\n/**\nvec3 palette(float x) // x=[0; 1]\n{\n    //             R      G      B\n    vec3 DC= vec3(0.500, 0.500, 0.500);\n    vec3 A = vec3(1.000, 1.000, 1.000);\n    vec3 F = vec3(1.000, 1.000, 1.000);\n    vec3 P = vec3(0.000, 0.333, 0.667);\n    const float TAU = 6.2831853071795862;\n    return clamp(( DC + A * cos(TAU*(P + F*x)) ), 0., 1.);\n}\n/**/\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, 1.0, vec2(1.0, 0.35), false);\n    // Background.\n    vec3 color = vec3(1.);\n    // Bounding lines.\n         color -= vertical_line(NDC, 0.); color -= horizontal_line(NDC, 0.);\n         color -= vertical_line(NDC, 2.); color -= horizontal_line(NDC, 1.);\n    // Cos oscillators.\n    float r = cosOSC(NDC.x, DC_OFFSET.r, AMP.r, FREQ.r, PHASE.r),\n          g = cosOSC(NDC.x, DC_OFFSET.g, AMP.g, FREQ.g, PHASE.g),\n          b = cosOSC(NDC.x, DC_OFFSET.b, AMP.b, FREQ.b, PHASE.b),\n    // Derivatives.\n          dydx_r = dydx(NDC.x, DC_OFFSET.r, AMP.r, FREQ.r, PHASE.r),\n          dydx_g = dydx(NDC.x, DC_OFFSET.g, AMP.g, FREQ.g, PHASE.g),\n          dydx_b = dydx(NDC.x, DC_OFFSET.b, AMP.b, FREQ.b, PHASE.b);\n    // Functions visualization.\n         color = mix(color, vec3(1,0,0), draw_explicit_func(NDC, r, dydx_r));\n         color = mix(color, vec3(0,1,0), draw_explicit_func(NDC, g, dydx_g));\n         color = mix(color, vec3(0,0,1), draw_explicit_func(NDC, b, dydx_b));\n    // Gradient visualization.\n    if (NDC.x >= 0. && NDC.x <= 2. && NDC.y <= -0.1 && NDC.y >= -0.4)\n    {\n        color = min(vec3(r, g, b), color);\n        color -= horizontal_line(NDC, -0.1); color -= horizontal_line(NDC, -0.4);      \n    }\n    // Cells visualization.\n    if (NDC.y >= 0.0 && NDC.y <= 1.0)\n    {\n         NDC = mod(NDC, vec2(2./8., 1./10.));        // Wrap cells\n         NDC = min(NDC, vec2(2./8., 1./10.) - NDC);  // AA from other side\n         color -= vertical_line(NDC, 0.)*.2;  color -= horizontal_line(NDC, 0.)*.2; // comment this line if you not use mod\n    }\n    // Output.\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}