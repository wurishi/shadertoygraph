{"ver":"0.1","info":{"id":"4tlBzX","date":"1525561556","viewed":125,"name":"qbEarlyOut","username":"dahart","description":"Attempts to make ray marching quadratic bezier curves w/ subdivision faster using early out tests. Nothing tried overcomes the recursion thread divergence, so subdivision seems not worth it no matter how clever I try to be. Stress test controls in code.\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["bezier","quadratic","out","early"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define SHOW_EARLY_OUTS 0\n\n#define SUBD_DEPTH 3\n\n// 12/20 fps test w/ radius:0.01, db:2.0, dd:0.25, subd:4, +bent, cam dist 6.0? gp100?\n// 12/26 radius:0.01, db:1.5, dd:0.25, subd:1, sdBezier, cam dist 8.0 gp100\n// none       0x000000: 3.4 - 3.6\n// plane      0x000001: 3.4 - 6.0\n// inner tri  0x100000: 5.1 - 6.7\n// outer apex 0x010000: 5.6 - 7.8\n// sphere     0x000010: 11.6 - 13.1\n// cylinder   0x000100: 13.1 - 15.0\n// outer tri  0x001000: 16.3 - 18.2\n\n// all           0x111111: 23.2 - 24.4\n// no plane      0x111110: 23.2 - 24.4\n// no sphere     0x111101: 23.2 - 24.4\n// no outer apex 0x101111: 22.5 - 24.4\n// no outer tri  0x110111: 21.8 - 23.2\n// no cylinder   0x111011: 21.3 - 22.5\n// no inner tri  0x011111: 20.6 - 22.5\n\n// 0x101100 : 20.6 - 22.0\n// 0x111100 : 23.2 - 24.4 *** winner: plane & sphere test may be ineffective\n// 0x110100 : 17.6 - 20.0\n\n#define DO_EARLY_OUT ( \\\n\t  (0<<0) /* plane test     */ \\\n    | (0<<1) /* sphere test    */ \\\n    | (0<<2) /* cylinder test  */ \\\n    | (0<<3) /* outer triangle */ \\\n    | (0<<4) /* outer apex     */ \\\n    | (0<<5) /* inner triangle */ \\\n    | (0<<6) /* 2d projection  */ \\\n    | (0<<7) /* interval       */ \\\n)\n\n#define EARLY_OUT_DEPTH 1\n#define USE_BENT_CYL 0\n\n//---------------------------\n\n// db:0   dd:1   -- 1 curve\n// db 0.5 dd 1   -- 2^3 8 curves\n// db:0.5 dd 0.5 -- 3^3 27 curves\n// db:1   dd:1   -- 3^3 27 curves\n// db:1.5 dd:1   -- 4^3 64 curves\n// db:2.0 dd:1   -- 5^3 125 curves\n// db:1   dd:0.5 -- 5^3 125 curves\n// db:2   dd:0.5 -- 9^3 729 curves\n// db:2   dd:0.25 -- 17^3 4,913 curves\n// db:4   dd:0.5 -- 17^3\n// db:8   dd:1.0 -- 17^3\n          \nconst float radius = 0.1;\nconst float db = 0.;\nconst float dd = 2.;\n\nconst float camDist = 6.0;\n\nconst bool curves = true;\nconst bool mincurves = false;\nconst bool spheres = false;\nconst bool cylinders = false;\n\n//---------------------------\n\nconst float tau = 6.28318;\nconst float inf = 999.0;\nconst float almostInf = inf - 1.0;\n\nconst int curveLen = 15;\nvec3 pts[curveLen];\n\nvec3 zero = vec3(0.0, 0.0, 0.0);\nvec3 one = vec3(1.0, 1.0, 1.0);\n\nstruct Hit { \n    float t; \n    vec3 p; \n    vec3 n;\n    int id;\n};\n\nconst int noId = -1;\nHit noHit;\n\n\nHit sphereHit(vec3 center, float radius, vec3 rayOrigin, vec3 rayDirection, int id) {\n    float a = dot(rayDirection, rayDirection);\n    vec3 L = rayOrigin - center;\n    float b = 2.0 * dot(rayDirection, L);\n    float c = dot(L, L) - radius*radius;\n    float discrim = b*b - 4.0*a*c;\n    if (discrim < 0.0) return noHit;\n    float t = (-b - sqrt(discrim)) / (2.0 * a);\n    if (t < 0.0) return noHit;\n    vec3 p = rayOrigin + t*rayDirection;\n    return Hit(t, p, normalize(p-center), id);\n}\n\nvec3 closestPointOnLineToP(vec3 La, vec3 Lb, vec3 P) {\n    vec3 d = Lb - La;\n    float t = dot(P - La, d) / dot(d, d);\n    return La + t * d;\n}\n\nHit qbHitInner(vec3 A, vec3 B, vec3 C, float r, vec3 ro, vec3 rd, int id) {\n    Hit minHit = noHit;\n    float n = 20.0 * length(A-C) / r;\n    float step = 1.0 / n;\n    for (float u = 0.0; u <= 1.0; u += step) {\n        float iu = 1.0 - u;\n        vec3 x = A * iu*iu + B * 2.0*u*iu + C * u*u;\n        Hit hit = sphereHit(x, r, ro, rd, id);\n        if (hit.t > 0.0 && hit.t < minHit.t) minHit = hit;\n    }\n\n    return minHit;\n}\n\n\n// This is the \"bad\" method from: http://jcgt.org/published/0006/01/02/paper.pdf\n// Improved accuracy when building an orthonormal basis\n// Nelson Max, University of California, Davis\nmat3x3 frisvad(vec3 n)\n{\n    vec3 b1, b2;\n    if(n.z < -0.9999999) // Handle the singularity\n    {\n        b1 = vec3( 0.0, -1.0, 0.0);\n        b2 = vec3( -1.0, 0.0, 0.0);\n    } else {\n        float a = 1.0f /(1.0f + n.z);\n        float b = -n.x*n.y*a;\n        b1 = vec3 (1.0f - n.x*n.x*a, b, -n.x);\n        b2 = vec3 (b, 1.0f - n.y*n.y*a, -n.y);\n    }\n    return mat3x3(b1, b2, n);\n}\n\nvoid branchlessONB(vec3 n, out vec3 b1, out vec3 b2)\n{\n    float snz = sign(n.z);\n    float a = -1.0f / (snz + n.z);\n    float b = n.x * n.y * a;\n    b1 = vec3(1.0f + snz * n.x * n.x * a, snz * b, -snz * n.x);\n    b2 = vec3(b, snz + n.y * n.y * a, -n.y);\n}\n\n\nHit cylinderIntersect(vec3 A, vec3 B, float r, vec3 ro, vec3 rd, int id) {\n    vec3 d = normalize(B - A);\n    mat3x3 cylToWorld = frisvad(d);\n    mat3x3 worldToCyl = transpose(cylToWorld);\n    vec3 roLocal = (ro - A) * worldToCyl;\n    vec3 rdLocal = rd * worldToCyl;\n    roLocal.z = 0.0;\n    rdLocal.z = 0.0;\n    bool cylhit = false;\n    Hit localHit = sphereHit(zero, r, roLocal, rdLocal, id);\n    if (localHit.id >= 0) cylhit = true;\n    vec3 p = ro + rd * localHit.t;\n    \n    if (dot(p-A, d) < 0.0) return noHit;\n    if (dot(p-B, d) > 0.0) return noHit;\n\n    //if (dot(p-A+d*r, d) < 0.0) return noHit;\n    //if (dot(p-A, d) < 0.0) return sphereHit(A, r, ro, rd, id);\n    //if (dot(p-B-d*r, d) > 0.0) return noHit;\n    //if (dot(p-B, d) > 0.0) return sphereHit(B, r, ro, rd, id);\n    \n    return Hit(localHit.t, p, localHit.n*cylToWorld, localHit.id);\n}\n\n\n// remove r from n, i.e., project n onto plane with normal r\nvec3 remove(vec3 r, vec3 n) {\n    return n - r * dot(n, r) / dot(r, r);\n}\n\nfloat sdBentCyl( vec3 p, vec3 a, vec3 b, vec3 c, vec3 r, out vec3 n ) {\n    // d . (a + td - p) = 0\n    vec3 h = 0.5*(a+c) - b;\n    \n    vec3 d = c - a; // cylinder axis\n    float tRaw = dot(p - a, d) / dot(d, d); // parameter between cylinder endpoints\n    float t = min(1.0, max(0.0, tRaw));\n    float it = 1.0 - t;\n    \n    //vec3 closestP = a + t * d; // 3d pos for closest cylinder axis point\n    float rAtT = it*it*r.x + 2.0*t*it*r.y + t*t*r.z;\n    vec3 closestP = it*it*a + 2.0*t*it*b + t*t*c;\n    float closestPDist = length(p - closestP) - rAtT;\n    \n    /*\n    // optional -- if you need rounded ends on your curve\n    if (tRaw < 0.0) {\n        // distance to plane p+td, d\n        // (p + td - a) . d = 0\n        // p.d + td.d - a.d = 0\n        // td.d = a.d - p.d = 0\n        // t = (a-p).d / d.d\n        \n        //float t2 = dot(a - p, d) / dot(d, d);\n        // note t2 == -t\n        n = p - a;\n        return max(closestPDist, -t);\n    } else if (tRaw > 1.0) {\n        //float t2 = abs(dot(p - c, d / dot(d,d)));\n        // note t2 == t-1.0\n        n = p - c;\n        return max(t-1.0, closestPDist);\n    }\n\t//*/\n    \n    vec3 tAtT = (-2.0 + 2.0*t)*a + (2.0 - 4.0*t)*b + 2.0*t*c;\n    n = remove(tAtT, p - closestP);\n    return closestPDist;\n}\n\n\nfloat sdFatLine(vec3 p, vec3 a, vec3 b, float ra, float rb, out vec3 n) {\n    vec3 d = b - a;\n    float t = dot(p - a, d) / dot(d, d);\n    t = min(1.0, max(0.0, t));\n    vec3 cp = a + t * d;\n    float cr = ra + t * (rb - ra);\n    n = p - cp;\n    return length(n) - cr;\n}\n\n//https://www.shadertoy.com/view/ltXSDB\n// Solve cubic equation for roots\nvec3 solveCubic(float a, float b, float c)\n{\n    float p = (b - a*a/3.)/3., p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3;\n    float offset = -a / 3.0;\n    if(d >= 0.0) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-1.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*sqrt(3.0);//1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p) + offset;\n}\n\n//https://www.shadertoy.com/view/ltXSDB\n// Find the signed distance from a point to a bezier curve\nfloat sdBezier(vec3 p, vec3 A, vec3 B, vec3 C, vec3 r, out vec3 n)\n{    \n    B = mix(B + vec3(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    \n    vec3 a = B - A;\n    vec3 b = A - B * 2.0 + C;\n    vec3 c = a * 2.0;\n    vec3 d = A - p;\n    \n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);      \n    vec3 t = clamp(solveCubic(k.x, k.y, k.z), 0.0, 1.0);\n    vec3 it = vec3(1.0) - t;\n\n    float ra = r.y - r.x;\n    float rb = r.x - r.y * 2.0 + r.z;\n    float rc = ra * 2.0;\n\n    mat3x3 pos;\n    float[3] rad;\n    float[3] dis;\n\n    pos[0] = A + (c + b*t.x)*t.x;\n    pos[1] = A + (c + b*t.y)*t.y;\n    pos[2] = A + (c + b*t.z)*t.z;\n\n    rad[0] = r.x + (rc + rb*t.x)*t.x;\n    rad[1] = r.x + (rc + rb*t.y)*t.y;\n    rad[2] = r.x + (rc + rb*t.z)*t.z;\n    \n    dis[0] = length(pos[0] - p) - rad[0];\n    dis[1] = length(pos[1] - p) - rad[1];\n    dis[2] = length(pos[2] - p) - rad[2];\n    \n    int whichMin = 0;\n    if (dis[1] < dis[whichMin]) whichMin = 1;\n    if (dis[2] < dis[whichMin]) whichMin = 2;\n    \n    n = normalize(p - pos[whichMin]);\n    return dis[whichMin];\n}\n\n// http://research.microsoft.com/en-us/um/people/hoppe/ravg.pdf\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nfloat getClosest( vec2 b0, vec2 b1, vec2 b2 ) \n{\n    float a =     det(b0,b2);\n    float b = 2.0*det(b1,b0);\n    float d = 2.0*det(b2,b1);\n    float f = b*d - a*a;\n    vec2  d21 = b2-b1;\n    vec2  d10 = b1-b0;\n    vec2  d20 = b2-b0;\n    vec2  gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n    vec2  pp = -f*gf/dot(gf,gf);\n    vec2  d0p = b0-pp;\n    float ap = det(d0p,d20);\n    float bp = 2.0*det(d10,d0p);\n    float t = clamp( (ap+bp)/(2.0*a+b+d), 0.0 ,1.0 );\n    return t;\n    //return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\n\nfloat sdBezier2( vec3 p, vec3 a, vec3 b, vec3 c, vec3 r, out vec3 n )\n{\n\tvec3 w = normalize( cross( c-b, a-b ) );\n\t//vec3 u = normalize( c-b );\n\t//vec3 v = normalize( cross( w, u ) );\n    vec3 u, v;\n    branchlessONB(w, u, v);\n\n\tvec2 a2 = vec2( dot(a-b,u), dot(a-b,v) );\n\tvec2 b2 = vec2( 0.0 );\n\tvec2 c2 = vec2( dot(c-b,u), dot(c-b,v) );\n\tvec3 p3 = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n\tfloat t = getClosest( a2-p3.xy, b2-p3.xy, c2-p3.xy );\n    \n    vec3 patt = mix(mix(a,b,t),mix(b,c,t),t);\n    float ratt = mix(mix(r.x,r.y,t),mix(r.y,r.z,t),t);\n\n\t//return vec4( sqrt(dot(cp.xy,cp.xy)+p3.z*p3.z), cp.z, length(cp.xy), p3.z );\n\t//return vec4( length(p-patt), cp.z, length(cp.xy), p3.z );\n    n = p - patt;\n    return length(n)-ratt;\n}\n\n\n\nHit qbRayMarch( vec3 a, vec3 b, vec3 c, vec3 r, vec3 ro, vec3 rd, int id )\n{\n    float tmin = 0.0;\n    float tmax = 12.0;\n   \n#if 1\n    float da = length(a-ro);\n    float db = length(b-ro);\n    float dc = length(c-ro);\n    float mr = 2.0 * max(r.x, max(r.y, r.z));\n    tmin = min(da, min(db, dc)) - mr;\n    tmax = max(da, max(db, dc)) + mr;\n#endif\n\n#if 1 // this does help... ~10%\n    vec3 Z = normalize(cross(b-a, c-a));\n    //float mr = max(r.x, max(r.y, r.z));\n\n    vec3 po1 = b + Z * mr;\n    vec3 po2 = b - Z * mr;\n\n    float nDotD = dot(Z, rd);\n    float s1 = dot(po1 - ro, Z) / nDotD;\n    float s2 = dot(po2 - ro, Z) / nDotD;\n    \n    tmin = max(0.0, min(s1, s2));\n    tmax = max(0.0, max(s1, s2));\n#endif\n\n    float t = tmin;\n    //float m = -1.0;\n    vec3 p, n;\n    float res, u;\n    //float precis = 0.001 * max(r.x, r.z);\n    for( int i=0; i<64; i++ )\n    {\n\t    float precis = 0.0001*t;\n        p = ro+rd*t;\n#if USE_BENT_CYL\n\t    //res = sdBentCyl( p, a, b, c, r, n );\n\t    res = sdBezier( p, a, b, c, r, n );\n#else\n\t    res = sdFatLine( p, a, c, r.x, r.z, n );\n#endif\n\n        if( res<precis || t>tmax ) break;\n        t += res;\n    }\n\n    if( t > tmax ) return noHit;\n    \n    // from calcNormal()\n    //vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    \n    /*\n    vec3 n = normalize( \n        e.xyy*sdBentCyl( p + e.xyy, a, b, c, r ) + \n\t\te.yyx*sdBentCyl( p + e.yyx, a, b, c, r ) + \n\t\te.yxy*sdBentCyl( p + e.yxy, a, b, c, r ) + \n        //e.xxx * res / 2.0\n\t\te.xxx*sdBentCyl( p + e.xxx, a, b, c, r ) \n    );\n\t*/\n\n    return Hit(t, p, normalize(n), id);\n}\n\n\n\nvec2 Cmul(vec2 a, vec2 b) {\n    return vec2(dot(a,vec2(b.x,-b.y)), dot(a.yx,b));\n}\n\nvec2 Cdiv(vec2 b, vec2 a) { // NOTE reversed args!\n    if (a == vec2(0.0, 0.0)) {\n        return a;\n    } \n    \n    if (abs(a.x) >= abs(a.y)) {\n        float r = a.y / a.x;\n        float den = a.x + r * a.y;\n        return vec2(b.x + r * b.y, b.y - r * b.x) / den;\n    } \n    \n    float r = a.x / a.y;\n    float den = a.y + r * a.x;\n    return vec2(b.x * r + b.y, b.y * r - b.x) / den;\n}\n\nvec2 Csqrt(vec2 a) {\n    if ((a.x == 0.0) && (a.y == 0.0)) {\n        return vec2(0.0, 0.0);\n    } \n\n    vec2 aa = abs(a);\n    float w;\n    if (aa.x >= aa.y) {\n        float r = aa.y / aa.x;\n        w = sqrt(aa.x) * sqrt(0.5 * (1.0 + sqrt(1.0 + r * r)));\n    } else {\n        float r = aa.x / aa.y;\n        w = sqrt(aa.y) * sqrt(0.5 * (r + sqrt(1.0 + r * r)));\n    }\n\n    if (a.x >= 0.0) {\n        return vec2(w, a.y / (2.0 * w));\n    } else {\n        vec2 c;\n        c.y = (a.y >= 0.0) ? w : -w;\n        c.x = a.y / (2.0 * c.y);\n        return c;\n    }\n}\n\n// vec2 RCmul(float x, vec2 a) { return vec2(x * a.x, x * a.y); }\n\n#define MAX_ORDER_PLUS_ONE 5\n#define EPSS 1.0e-7\n#define MR 8\n#define MT 10\n#define MAXIT (MT * MR)\n// Here EPSS is the estimated fractional roundoff error. We try to break (rare)\n// limit cycles with\n// MR different fractional values, once every MT steps, for MAXIT total allowed\n// iterations.\n\nconst float[9] frac = float[9](0.0,  0.5,  0.25, 0.75, 0.13, 0.38, 0.62, 0.88, 1.0);\n\n// vec3 function laguer(vec2 a[], int m)\nvec2 laguer(vec2[MAX_ORDER_PLUS_ONE] a, int m, vec2 x, inout int iters)\n// Given the degree m and the m+1 complex coefficients a[0..m] of the polynomial\n// sum(i=0..m, a[i]xi),\n// and given a complex value x, this routine improves x by Laguerre’s method\n// until it converges,\n// within the achievable roundoff limit, to a root of the given polynomial. The\n// number of iterations\n// taken is returned as iters.\n{\n    float fm = float(m);\n    // Fractions used to break a limit cycle.\n    for (iters = 1; iters <= MAXIT; iters++) // Loop over iterations up to allowed maximum.\n    {\n        vec2 b = a[m];\n        float err = length(b);\n        vec2 d = vec2(0.0, 0.0);\n        vec2 f = vec2(0.0, 0.0);\n        float abx = length(x);\n        for (int j = m - 1; j >= 0; j--) {\n            // Efficient computation of the polynomial and\n            // its first two derivatives. f stores P''/2\n            f = Cmul(x, f) + d;\n            d = Cmul(x, d) + b;\n            b = Cmul(x, b) + a[j];\n            err = length(b) + abx * err;\n        }\n        err *= EPSS;\n        // Estimate of roundoff error in evaluating polynomial.\n        if (length(b) <= err) return x;  // We are on the root.\n        vec2 g = Cdiv(d, b);  // The generic case: use Laguerre’s formula.\n        vec2 g2 = Cmul(g, g);\n        vec2 h = g2 - (2.0 * Cdiv(f, b));\n        vec2 sq = Csqrt( (fm - 1.0) * ((fm * h) - g2) );\n        vec2 gp = g + sq;\n        vec2 gm = g - sq;\n        float abp = length(gp);\n        float abm = length(gm);\n        if (abp < abm) gp = gm;\n        vec2 dx = ((max(abp, abm) > 0.0\n           ? Cdiv(vec2(m, 0.0), gp)\n           : (\n                (1.0 + abx) * //Math.exp(Math.log(1 + abx)),\n                vec2(cos(float(iters)), sin(float(iters)))\n           )));\n        vec2 x1 = x - dx;\n        if (x == x1) return x;  // Converged.\n        if (iters % MT > 0) x = x1;\n        else x = x - (frac[iters / MT] * dx);\n        // Every so often we take a fractional step, to break any limit cycle\n        // (itself a rare occurrence).\n    }\n    //throw (\"too many iterations in laguer\");\n    // Very unusual — can occur only for complex roots. Try a different starting\n    // guess for the root.\n    return x;\n}\n\n\n// Here is a driver routine that calls laguer in succession for each root, performs\n// the deflation, optionally polishes the roots by the same Laguerre method — if you\n// are not going to polish in some other way — and finally sorts the roots by\n// their real parts. (We will use this routine in Chapter 13.)\n#define EPS 4.0e-6\n// A small number, and maximum anticipated value of m.\n// void zroots(vec2 a[], int m, vec2 roots[], int polish)\nvoid zroots(vec2[MAX_ORDER_PLUS_ONE] a, int m, bool polish, inout vec2[MAX_ORDER_PLUS_ONE] roots, inout int iters)\n// Given the degree m and the m+1 complex coefficients a[0..m] of the polynomial\n// sum(i=0..m, a(i)xi),\n// this routine successively calls laguer and finds all m complex roots in roots[1..m]. The\n// boolean variable polish should be input as true (1) if polishing (also by Laguerre’s method)\n// is desired, false (0) if the roots will be subsequently polished by other means.\n{\n    vec2[MAX_ORDER_PLUS_ONE] ad;\n    for (int j = 0; j <= m; j++) {\n        ad[j] = a[j];  // Copy of coefficients for successive deflation.\n    }\n    for (int j = m; j >= 1; j--)  // Loop over each root to be found.\n    {\n        // Start at zero to favor convergence to smallest remaining root, and find the root.\n        // vec3 ans = laguer(ad, j, vec2(0.0, 0.0));\n        vec2 x = laguer(ad, j, vec2(0.0, 0.0), iters);\n        // its = ans.z;\n        if (abs(x.y) <= EPS * abs(x.x)) x.y = 0.0;\n        roots[j] = x;\n        vec2 b = ad[j];  // Forward deflation.\n        for (int jj = j - 1; jj >= 0; jj--) {\n            vec2 c = ad[jj];\n            ad[jj] = b;\n            b = Cmul(x, b) + c;\n        }\n    }\n    if (polish) \n    {\n        for (int j = 1; j <= m; j++) // Polish the roots using the undeflated coeffi-cients.\n        {\n            roots[j] = laguer(a, m, roots[j], iters);\n        }\n    }\n    for (int j = 2; j <= m; j++) // Sort roots by their real parts by straight insertion.\n    {\n        int i;\n        vec2 x = roots[j];\n        for (i = j - 1; i >= 1; i--) {\n            if (roots[i].x <= x.x) break;\n            roots[i + 1] = roots[i];\n        }\n        roots[i + 1] = x;\n    }\n}\n\n\n\nstruct qbhFrame {\n    vec3 a;\n    vec3 b;\n    vec3 c;\n    vec3 r;\n    int depth;\n};\n\nconst int MAX_QBH_STACK_SIZE = 5;\nqbhFrame stack[MAX_QBH_STACK_SIZE];\n\nHit qbHit(vec3 A, vec3 B, vec3 C, vec3 R, vec3 ro, vec3 rd, mat3x3 cam, int id) {\n    int stackEmptyIdx = 0;\n    vec3 a, b, c, r;\n    vec3 pmid;\n    int depth;\n    \n    stack[0] = qbhFrame(A, B, C, R, 0);\n    stackEmptyIdx++;\n        \n    Hit minHit = noHit;\n    Hit hit = noHit;\n    \n    int p1Region = 0;\n    int p2Region = 0;\n\n    bool p1Out, p2Out;\n\n#if (DO_EARLY_OUT & (1<<6))\n    //mat3x3 frisvad(vec3 n)\n    mat3x3 basis = frisvad(rd); // basis[2] == rayDirection\n    \n    vec2[3] cp2;\n\n    // project control points to 2d\n    vec3 aro = A - ro;\n    vec3 bro = B - ro;\n    vec3 cro = C - ro;\n    cp2[0] = vec2(dot(aro, basis[0]), dot(aro, basis[1]));\n    cp2[1] = vec2(dot(bro, basis[0]), dot(bro, basis[1]));\n    //cp2[2] = vec2(dot(cro, basis[0]), dot(cro, basis[1]));\n                \n    vec2 F = cp2[0] - 2.0 * cp2[1] + cp2[2];\n    vec2 G = 2.0 * (cp2[1] - cp2[0]);\n    vec2 H = cp2[0];\n    \n    float f = R.x - 2.0 * R.y + R.z;\n    float g = 2.0 * (R.y - R.x);\n    float h = R.x;\n\n    float aa = dot(F, F) - f*f;\n    float bb = 2.0 * (dot(F, G) - f*g);\n    float cc = 2.0 * (dot(F, H) - f*h) + dot(G, G) - g*g;\n    float dd = 2.0 * (dot(G, H) - g*h);\n    float ee = dot(H, H) - h*h;\n    \n    vec2[MAX_ORDER_PLUS_ONE] coeffs = vec2[MAX_ORDER_PLUS_ONE]( \n        vec2(ee, 0.0), \n        vec2(dd, 0.0), \n        vec2(cc, 0.0), \n        vec2(bb, 0.0), \n        vec2(aa, 0.0) \n    );\n\n    vec2[MAX_ORDER_PLUS_ONE] roots = vec2[MAX_ORDER_PLUS_ONE](\n        vec2(0.0, 0.0),\n        vec2(0.0, 0.0),\n        vec2(0.0, 0.0),\n        vec2(0.0, 0.0),\n        vec2(0.0, 0.0)\n    );\n    //for (int i = 0; i < 5; i++) roots[i] = vec2(0.0, 0.0);\n\n    //try { roots = \n    int iters;\n    //void zroots(vec2[MAX_ORDER_PLUS_ONE] a, int m, bool polish, inout vec2[MAX_ORDER_PLUS_ONE] roots, inout int iters)\n\n    zroots(coeffs, 4, true, roots, iters); \n    //} catch(e) { return inf; }\n    //Hit minHit;\n    bool didHit = false;\n    for (int i = 1; i < 5; i+=2) {\n        if (abs(roots[i].y) < 0.001\n            && (roots[i].x > 0.0 || roots[i+1].x > 0.0)\n            && (roots[i].x < 1.0 || roots[i+1].x < 1.0)\n            )\n        {\n            didHit = true;\n        }\n    }\n    if (!didHit) return Hit(inf-3.0, zero, zero, noId);\n#endif\n\n    while (stackEmptyIdx > 0) {\n        stackEmptyIdx--;\n        a = stack[stackEmptyIdx].a;\n        b = stack[stackEmptyIdx].b;\n        c = stack[stackEmptyIdx].c;\n        r = stack[stackEmptyIdx].r;\n        depth = stack[stackEmptyIdx].depth;\n\n        float maxr = max(r.x, max(r.y, r.z));\n        vec3 Z = normalize(cross(B-A, C-A));\n\n        vec3 po1 = b + Z * maxr;\n        vec3 po2 = b - Z * maxr;\n\n        float nDotD = dot(Z, rd);\n        float s1 = dot(po1 - ro, Z) / nDotD;\n        float s2 = dot(po2 - ro, Z) / nDotD;\n                \n        Z *= maxr;\n        \n#if (DO_EARLY_OUT & (1<<0))\n        // plane test\n        //\n        if (s1 < 0.0 && s2 < 0.0) \n        {\n            if (minHit.t == inf) minHit = Hit(inf-1.0, zero, zero, noId); \n            continue;\n        }\n#endif\n        \n#if (DO_EARLY_OUT & (1<<7))\n        // sort s1,s2\n        if (s2 < s1) {\n            float temp = s1;\n            s1 = s2;\n            s2 = temp;\n        }\n\n        float da = dot(a-ro, rd);\n        float db = dot(b-ro, rd);\n        float dc = dot(c-ro, rd);\n                    \n        float pt1 = min(da-r.x, min(db-r.y, dc-r.z));\n        if (s2 < pt1) {\n            if (minHit.t == inf) minHit = Hit(inf-2.0, zero, zero, noId); \n            continue;\n        }\n        float pt2 = max(da+r.x, max(db+r.y, dc+r.z));\n        if (s1 > pt2) {\n            if (minHit.t == inf) minHit = Hit(inf-2.0, zero, zero, noId); \n            continue;\n        }\n#endif\n        \n        vec3 p1 = ro + s1 * rd;\n        vec3 p2 = ro + s2 * rd;\n\n        vec3 h;\n        \n#if (DO_EARLY_OUT & (1<<1))\n        // sphere test\n        vec3 m = (a + b + c) / 3.0;\n        float la = length(a-m);\n        float lb = length(b-m);\n        float lc = length(c-m);\n        float sr = max(la + r.x, max(lb + r.y, lc + r.z));\n        float dr = length( (ro-m) - rd * (dot(rd, ro-m)) );\n        if (dr > sr) {\n            if (minHit.t == inf) minHit = Hit(inf-1.0, zero, zero, noId);\n            continue;\n        }\n                        \n#endif\n\n#if (DO_EARLY_OUT & (1<<2))\n        // cylinder test\n        vec3 ac = c - a;\n        h = 0.5 * (a + c);\n        vec3 bh = b - h;\n        float mr = max(r.x, r.z) + 0.25*length(bh) + r.y;\n\n        // http://mathworld.wolfram.com/Line-LineDistance.html\n        // line (ro, p1) vs (a, c)\n        vec3 aa = rd; //ro - p1;\n        vec3 bb = c - a; \n        vec3 cc = a - (p1 - 0.25*bh);\n        vec3 aaCrossBb = cross(aa,bb);\n        float D = dot(cc, aaCrossBb) / length(aaCrossBb);\n        if (abs(D) > mr) {\n            if (minHit.t == inf) minHit = Hit(inf-2.0, zero, zero, noId);\n            continue; \n        }\n#endif\n\n#if (DO_EARLY_OUT & (1<<3))\n        // outer triangle test\n        vec3 nBAZ = normalize(cross(Z, b-a));\n        vec3 pBAZ = a - max(r.x, r.y) * nBAZ;\n        p1Out = dot(nBAZ, (p1 - pBAZ)) < 0.0;\n        p2Out = dot(nBAZ, (p2 - pBAZ)) < 0.0;\n        if (p1Out && p2Out) { \n            if (minHit.t == inf) minHit = Hit(inf-1.0, zero, zero, noId); \n            continue; \n        }\n\n        vec3 nCBZ = normalize(cross(Z, c-b));\n        vec3 pCBZ = b - max(r.y, r.z) * nCBZ;\n        p1Out = dot(nCBZ, (p1 - pCBZ)) < 0.0;\n        p2Out = dot(nCBZ, (p2 - pCBZ)) < 0.0;\n        if (p1Out && p2Out) { \n            if (minHit.t == inf) minHit = Hit(inf-1.0, zero, zero, noId);\n            continue; \n        }\n\n        vec3 nACZ = normalize(cross(Z, a-c));\n        vec3 pACZ = c - max(r.x, r.z) * nACZ;\n        p1Out = dot(nACZ, (p1 - pACZ)) < 0.0;\n        p2Out = dot(nACZ, (p2 - pACZ)) < 0.0;\n        if (p1Out && p2Out) { \n            if (minHit.t == inf) minHit = Hit(inf-1.0, zero, zero, noId); \n            continue; \n        }\n#else\n        vec3 nBAZ = normalize(cross(Z, b-a));\n        vec3 nCBZ = normalize(cross(Z, c-b));\n        vec3 nACZ = normalize(cross(Z, a-c));\n#endif\n\n        \n#if (DO_EARLY_OUT & (1<<4))\n        // outer apex test\n        // cull everything north of the midpoint + radius\n        pmid = 0.25 * (2.0*b + a + c);\n        vec3 pApexOut = pmid + r.y * nACZ;\n        p1Out = dot(nACZ, (p1 - pApexOut)) >= 0.0;\n        p2Out = dot(nACZ, (p2 - pApexOut)) >= 0.0;\n        if (p1Out && p2Out) { \n            if (minHit.t == inf) minHit = Hit(inf-2.0, zero, zero, noId); \n            continue; \n        }\n#endif\n\n#if (DO_EARLY_OUT & (1<<5))\n        // inner triangle test\n        // cull the inner triangle\n        vec3 pApexIn = pmid - r.y * nACZ;\n        vec3 pBAZin = (a + r.x * nBAZ);\n        vec3 pCBZin = (c + r.z * nCBZ);\n        vec3 normalA = cross(Z, (pmid - pBAZin));\n        vec3 normalC = cross(Z, (pCBZin - pmid));\n        p1Out = dot(normalA, (p1 - pApexIn)) >= 0.0 && dot(normalC, (p1 - pApexIn)) >= 0.0;\n        p2Out = dot(normalA, (p2 - pApexIn)) >= 0.0 && dot(normalC, (p2 - pApexIn)) >= 0.0;\n        if (p1Out && p2Out) { \n            if (minHit.t == inf) minHit = Hit(inf-3.0, zero, zero, noId); \n            continue; \n        }\n#endif\n\n        if (depth >= SUBD_DEPTH) {\n            hit = qbRayMarch( a, b, c, r, ro, rd, id );\n            if (hit.id >= 0 && hit.t > 0.0 && hit.t < minHit.t) minHit = hit;\n            continue;\n        }\n\n        pmid = 0.25 * (2.0*b + a + c);\n\n        h = 0.5 * (a + c);\n        vec3 nBHZ = normalize(cross(Z, h - b)) * r.y; // points to the left half\n\n        vec3 pLeft = (pmid + nBHZ);\n        vec3 pRight = (pmid - nBHZ);\n\n        bool p1isLeft = dot(nBHZ, (p1 - pLeft)) >= 0.0;\n        bool p2isLeft = dot(nBHZ, (p2 - pLeft)) >= 0.0;\n\n        bool p1isRight = dot(nBHZ, (p1 - pRight)) < 0.0;\n        bool p2isRight = dot(nBHZ, (p2 - pRight)) < 0.0;\n\n        bool rayHitsLeftOnly  = p1isLeft  && p2isLeft;\n        bool rayHitsRightOnly = p1isRight && p2isRight;\n\n        vec3 ab = ((a + b) * 0.5);\n        vec3 bc = ((b + c) * 0.5);\n        vec3 abc = ((ab + bc) * 0.5);\n\n        if (!rayHitsRightOnly)\n        {\n            if (stackEmptyIdx < MAX_QBH_STACK_SIZE)\n            stack[stackEmptyIdx++] = qbhFrame(a, ab, abc, vec3(r.x, 0.5*(r.x+r.y), 0.25*(r.x+2.0*r.y+r.z)), depth+1);\n        }\n        if (!rayHitsLeftOnly)\n        {\n            if (stackEmptyIdx < MAX_QBH_STACK_SIZE)\n            stack[stackEmptyIdx++] = qbhFrame(abc, bc, c, vec3(0.25*(r.x+2.0*r.y+r.z), 0.5*(r.y+r.z), r.z), depth+1);\n        }\n    }\n    \n    return minHit;\n}\n\nHit qbCurveHit(vec3[curveLen] pts, int n, float r, vec3 ro, vec3 rd, mat3x3 cam, int id) {\n    Hit minT = noHit;\n    vec3 a, c;\n    for (int i = 2; i < n; i++) {\n        a = 0.5 * (pts[i-2] + pts[i-1]);\n        c = 0.5 * (pts[i-1] + pts[i]);\n        Hit hit = qbHit(a, pts[i-1], c, vec3(r, r, r), ro, rd, cam, id);\n        if (hit.t >= 0.0 && hit.t < minT.t) {\n            minT = hit;\n           // return minT;// debug -- bail early on first hit. remove when t is real\n        }\n    }\n    return minT;\n}\n\n\n\nHit hitSomething(vec3 ro, vec3 rd, mat3x3 cam, float time) {\n    const int ns = 2;\n    float fns = float(ns);\n    float sr = 1.0;\n    \n    Hit minHit = noHit;\n    \n    if (cylinders) {\n        Hit hit;\n\n        //*\n        hit = cylinderIntersect(vec3(0.0, -1.0, 0.0), vec3(0.0, 1.0, 0.0), 0.25, ro, rd, 2);\n        if (hit.id >= 0 && hit.t > 0.0 && hit.t < minHit.t) minHit = hit;\n\n        hit = cylinderIntersect(vec3(-1.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), 0.25, ro, rd, 2);\n        if (hit.id >= 0 && hit.t > 0.0 && hit.t < minHit.t) minHit = hit;\n\n        hit = cylinderIntersect(vec3(0.0, 0.0, -1.0), vec3(0.0, 0.0, 1.0), 0.25, ro, rd, 2);\n        if (hit.id >= 0 && hit.t > 0.0 && hit.t < minHit.t) minHit = hit;\n\t\t//*/\n        \n        \n        //hit = sphereHit(vec3(0.0, -1.0, 0.0), 0.25, ro, rd, 2);\n        //if (hit.id >= 0 && hit.t > 0.0 && hit.t < minHit.t) minHit = hit;\n\n    }\n\n    if (spheres)\n    for (int i = 0; i < ns; i++) \n    {\n        float fi = float(i);\n        float fni = fi / fns;\n        float d = 3.0 * sin(time * fni + fi);\n        vec3 sc=vec3(d*cos(tau*fni+time*10.0*fni)+sin(time*10.0), \n                     d*sin(tau*fni+time*10.0*fni), \n                     d*sin(0.5*tau*fni+time*fni*1.4142)+cos(time*10.0));\n        \n        Hit hit = sphereHit(sc, sr, ro, rd, 0);\n        if (hit.t <= 0.0 || hit.t > minHit.t) continue;\n        minHit = hit;\n    }\n    \n    if (curves) {\n        const float r = radius;\n\n        for (int i = 0; i < curveLen; i++) {\n            float fi = float(i);\n            pts[i] = vec3(1.5 * sin(fi), fi*1.0 - 6.0, 1.5 * cos(fi));\n        }\n        \n        int i = 0;\n        for (float ox = -db; ox <= db + dd/2.0; ox += dd) {\n        for (float oy = -db; oy <= db + dd/2.0; oy += dd) {\n        for (float oz = -db; oz <= db + dd/2.0; oz += dd, i++) {\n#if 1\n            Hit qbt = qbHit(\n                vec3(-2.0+ox, -1.0+oy, 0.0+oz), \n                vec3(1.0+ox, -1.0+oy+4.0*sin(10.0*tau*(time+2.0/6.0)+float(i)), 0.0+oz), \n                vec3(2.0+ox, -1.0+oy, 0.0+oz), \n                vec3(r, r, 0), \n                ro, rd, cam, 1);\n#else\n            Hit qbt = qbCurveHit(pts, curveLen, 0.05, ro, rd, cam, 1);\n            //float qbCurveHit(vec3[] pts, int n, float r, vec3 ro, vec3 rd, mat3x3 cam) {\n#endif\n            if (qbt.t > 0.0 && qbt.t < minHit.t) {\n                minHit = qbt;\n                //color = vec3(0.0, 0.0, 0.0);\n            }\n        }\n        }\n        }\n    }\n\n    if (mincurves) {\n        float tmin = 0.0;\n        float tmax = 20.0;\n   \n        float t = tmin;\n        vec3 p, n;\n        vec3 minN;\n        float res = inf, minRes = inf;\n        \n        for( int m=0; m<64; m++ )\n        {\n            float precis = 0.0001*t;\n            p = ro+rd*t;\n\n            minRes = inf;\n            \n            int i = 0;\n            for (float ox = -db; ox <= db + dd/2.0; ox += dd) {\n            for (float oy = -db; oy <= db + dd/2.0; oy += dd) {\n            for (float oz = -db; oz <= db + dd/2.0; oz += dd, i++) {\n                res = sdBezier( p, \n                    vec3(-2.0+ox, -1.0+oy, 0.0+oz), \n                    vec3(1.0+ox, -1.0+oy+4.0*sin(10.0*tau*(time+2.0/6.0)+float(i)), 0.0+oz), \n                    vec3(2.0+ox, -1.0+oy, 0.0+oz), \n                    vec3(radius, radius, 0), \n                    n );\n                if (res < minRes) {\n                    minRes = res;\n                    minN = n;\n                }\n            }\n            }\n            }\n\n            if( minRes<precis || t>tmax ) break;\n            t += minRes;\n        }\n\n        if( t > tmax ) return noHit;\n\n\n        return Hit(t, p, normalize(minN), 1);\n        \n    }\n\n    return minHit;\n}\n\nvec3 colorSomething(Hit hit, vec3 ro, vec3 rd, mat3x3 cam, float time) {\n\n    vec3 color = vec3(0.0, 0.0, 0.0);\n\n#if SHOW_EARLY_OUTS\n    if (hit.t > inf - 0.5)\n    {\n        return vec3(0.0, 0.15+0.05*sin(iTime), 0.4);\n    }\n    else if (hit.t > inf - 1.5)\n    {\n    \tcolor = vec3(1.0, 0.0, 0.0);\n    }\n    else if (hit.t > inf - 2.5)\n    {\n    \treturn vec3(1.0, 1.0, 0.0);\n    }\n    else if (hit.t > inf - 3.5)\n    {\n    \treturn vec3(0.0, 1.0, 0.0);\n    }\n    else \n#endif\n    if (hit.t > inf - 4.5)\n    {\n        return vec3(0.0, 0.15+0.05*sin(iTime), 0.4);\n    }\n    \n    vec3 normal = hit.n;\n\n    float dup    =  dot(normal, cam[1]);\n    float dright =  dot(normal, cam[0]);\n    float dfwd   = -dot(normal, cam[2]);\n\n    // diffuse\n    if (hit.id == 0) {\n        color += vec3(dright, dup, dfwd);\n    } else if (hit.id == 1) {\n        color += dfwd * vec3(0.5, 1.0, 0.5);\n    } else if (hit.id == 2) {\n        color += 1.0 * dfwd * vec3(0.5, 0.5, 1.0);\n    }\n\n    // specular\n    vec3 refl = reflect(rd, normal);\n    float spec = pow(dot(refl, cam[1]), 20.0);\n    if (spec > 0.0) color += vec3(spec, spec, spec);\n\n    //color = normal;\n    //float j = t/10.0; color = vec3(j, j, j);\n    //color = vec3(mod(hit.p.x, 1.0), mod(hit.p.y, 1.0), 0.0);\n\n    return color;\n}\n\nconst int maxDepth = 1;\nvec3 trace( vec3 rayOrigin, vec3 rayDirection, mat3x3 cam, float time )\n{\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    float ref = 1.0;\n    for (int i = 0; i < maxDepth; i++) {\n        Hit minHit = hitSomething(rayOrigin, rayDirection, cam, time);\n        color += ref * colorSomething(minHit, rayOrigin, rayDirection, cam, time);\n        if (minHit.id == noId || minHit.t <= 0.0) break;\n        ref *= 0.7;\n        rayOrigin = minHit.p;\n        rayDirection = reflect(rayDirection, minHit.n);\n    }\n    //color = color * 0.8;\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    noHit = Hit(inf, zero, zero, noId);\n    \n    float time = 0.25 * iMouse.x / iResolution.x + iTime / 40.0;\n    vec3 ro = vec3(camDist*sin(tau * time), 0.0, camDist*cos(tau * time));\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - vec2(1.0, 1.0);\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 lookat = vec3(0.0, -1.0, 0.0);\n    vec3 fwd   = normalize(lookat - ro);\n    vec3 right = normalize(cross(fwd, up));\n    vec3 camup = normalize(cross(right, fwd));\n    vec3 rd = normalize(fwd + 0.5 * (uv.x * right + uv.y * up));\n    \n    fragColor = vec4(trace(ro, rd, mat3x3(right, camup, fwd), time), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}