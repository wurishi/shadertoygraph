{"ver":"0.1","info":{"id":"ld33z2","date":"1450856109","viewed":357,"name":"Terrain thingy - Raymarching","username":"Lallis","description":"Trying out some terrain marching. It's obviously still lacking clouds (and maybe rivers?) but I don't think I'll ever get them done so publishing this as it is. :)","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["procedural","raymarching","terrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//some fbm for water color; quite expensive and doesn't make much of a difference\n#define WATERFBM\n\n//mouse rotate\n#define MOUSE\n\n#define DRAWDISTANCE 100.0\n#define time iTime*0.75\n#define WATERH 1.75\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,12.7378))) * 43758.5453);\n}\n\nfloat smooth3D(vec3 p)\n{\n    vec3 f = fract(p);\n    p = floor(p);\n    f = f*f*(3.0-2.0*f);\n    \n\tfloat p0 = noise3D(p);\n\tfloat x = noise3D(p+vec3(1.0,0.0,0.0));\n\tfloat y = noise3D(p+vec3(0.0,1.0,0.0));\n\tfloat z = noise3D(p+vec3(0.0,0.0,1.0));\n\tfloat xy = noise3D(p+vec3(1.0,1.0,0.0));\n\tfloat xz = noise3D(p+vec3(1.0,0.0,1.0));\n\tfloat yz = noise3D(p+vec3(0.0,1.0,1.0));\n\tfloat xyz = noise3D(p+1.0);\n\t\n    return mix(\tmix(\tmix(p0, x, \t f.x), \n                    \tmix(y, \txy,  f.x), \tf.y), \n               \tmix(\tmix(z, \txz,\t f.x), \n                    \tmix(yz, xyz, f.x), \tf.y), \tf.z);\n}\n\nfloat fbm3D(vec3 p)\n{\n \tfloat f = 0.5000*smooth3D(p*1.00);\n    \t  f+= 0.2500*smooth3D(p*2.01);\n    \t  f+= 0.1250*smooth3D(p*4.02);\n    \t  f/= 0.875;\n    return f;\n}\n\nmat3 rot(vec3 ang)\n{\n\tmat3 x = mat3(1.0,0.0,0.0,0.0,cos(ang.x),-sin(ang.x),0.0,sin(ang.x),cos(ang.x));\n\tmat3 y = mat3(cos(ang.y),0.0,sin(ang.y),0.0,1.0,0.0,-sin(ang.y),0.0,cos(ang.y));\n\tmat3 z = mat3(cos(ang.z),-sin(ang.z),0.0,sin(ang.z),cos(ang.z),0.0,0.0,0.0,1.0);\n\treturn x*y*z;\n}\n\nfloat noise2D(vec2 p){\n    return fract(sin(dot(p ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nfloat smooth2D(vec2 p)\n{\n    vec2 f = fract(p);\n    p = floor(p);\n    f = f*f*(3.0-2.0*f); // smoothing\n    \n\tfloat p0 = noise2D( p );\n\tfloat x = noise2D( p+vec2( 1.0, 0.0 ) );\n\tfloat y = noise2D( p+vec2( 0.0, 1.0 ) );\n\tfloat xy = noise2D( p+vec2( 1.0, 1.0 ) );\n    return mix(\tmix( p0, x, f.x ),\n        \t\tmix( y, xy, f.x ), f.y );\n}\nfloat fbm(vec2 rp)\n{\n    float f = 0.0;\n    f += smooth2D( rp*1.0 )*0.5;\n    f += smooth2D( rp*2.0 )*0.25;\n    f += smooth2D( rp*4.0 )*0.125;\n    f += smooth2D( rp*8.0 )*0.0625;\n    f /= 0.9375;\n    return f;\n}\nfloat terrain(vec3 rp)\n{\n    float d = 0.0;\n    d += smooth2D( rp.xz*0.25 )*2.5;\n    d += smooth2D( rp.xz*0.5 )*1.0; \n    d += abs(sin((rp.x+rp.z)+fbm(rp.xz)*3.14*2.0))*0.10;\n    d += abs(sin((rp.x-rp.z)+fbm(rp.xz)*3.14*2.0))*0.10;\n    float f = 7.5;\n    rp/=f;\n    float asd1 = clamp(abs(2.0/3.14*asin( sin(2.0*3.14/16.0*((rp.x+rp.z)+fbm(rp.xz+21.)*3.14*8.0) ) ) ), 0.0, 1.0)*1.5;\n    rp*=f;\n\td += asd1;\n    d = min(rp.y-d, rp.y-WATERH); \n    return d;\n}\n\nvec3 normal(vec3 rp)\n{\n    vec3 eps = vec3( 0.02 ,0.0,0.0);\n\treturn normalize( vec3(\n           terrain(rp+eps.xyy) - terrain(rp-eps.xyy),\n           terrain(rp+eps.yxy) - terrain(rp-eps.yxy),   //from iq\n           terrain(rp+eps.yyx) - terrain(rp-eps.yyx) ) );\n\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float td, float dmax)\n{\n\tfloat res = 1.0;\n    float ld = 0.1;\n    float ldmax = 25.0; \n    vec3 rp = ro+rd*ld;\n    \n\tfor(int i = 0; i<128; i++ )\n\t{\n\t\tfloat d = terrain(rp);\n\t\tif(d < 0.01) return 0.0;\n\t\tres = min(res, 8.0*d);\n        if(ld>ldmax) break;\n        ld += d*0.5*(1.0+td/dmax);\n\t\trp = ro+rd*ld;\n\t}\n\treturn res;\n}\n\nvec3 terrainColor( vec3 rp, vec3 n )\n{\n    vec3 col = texture( iChannel1, rp.xz).rgb*0.15;\n    float snow = texture(iChannel2, rp.xz*1.0).r;\n    col = mix(col,vec3(0.5),clamp(rp.y-1.5-snow*7.0*fbm(rp.xz),0.0,1.0)*smoothstep(0.5,1.0,dot(n,normalize(vec3(1.0,1.0,0.0)))));\n    \n    col = mix( col, vec3( 0.035,0.045,0.025)*fbm(rp.xz*100.0), smoothstep(0.65, 0.9, n.y)*smoothstep(2.25, 1.0, rp.y-WATERH) );\n    col = mix( col, vec3( 0.085,0.075,0.05 ), smoothstep(0.80, 0.9, n.y)*smoothstep(0.25, 0.0, rp.y-WATERH ) );\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = 2.0*uv-1.0;\n    p.x*= iResolution.x/iResolution.y;\n    vec3 col = vec3( 0.0 );\n    \n    float z = -9.0;\n    \n    vec3 ro = vec3( 0.0, 0.0, -(1.5+sin(time*0.11))+z );\n    vec3 rd = normalize( vec3( p, z ) - ro );\n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 ang = vec3( 3.14*0.25, 3.14*1.75, 0.0 );\n    ro *= rot( ang );\n    \n    rd *= rot( ang );\n\trd *= rot( vec3(0.0, 4.0-time*0.06, 0.0) );\n   \n    #ifdef MOUSE\n    rd *= rot(vec3(0.0, m.x*6.28,0.0)); \n    #endif\n    \n    ro.z += sin(time*0.01)*50.0;\n    ro.x += cos(time*0.01)*50.0;\n    \n    float d = 0.0;\n    float td = 0.5;\n    float dmax= DRAWDISTANCE;\n    vec3 rp = ro+rd*td;\n    \n    for( int i = 0; i < 256; i++ )\n    {\n     \td = terrain( rp );\n        if( d < 0.001 ) break;\n        td += d*0.25*(1.0+td/dmax);\n        if( td > dmax ) \n        {\n            td = dmax;\n            break;\n        }\n        rp = ro+rd*td;\n    }\n    rp = ro+rd*td;\n    vec3 s = normalize(vec3(1.0,0.5,0.0));  \n    if( d < 0.001 )\n    {             \n        vec3 n = normal(rp);\n        \n        // https://iquilezles.org/articles/outdoorslighting\n        float sha = softShadow( rp, s, td, dmax );\n        float sun = clamp( dot( n, s ), 0.0, 1.0 );\n        float sky = clamp( 0.5 + 0.5*n.y, 0.0, 1.0 );\n        float ind = clamp( dot( n, s*vec3(-1.0,0.0,-1.0) ), 0.0, 1.0 );                       \n        \n        vec3 lighting = vec3(0.0);\n        lighting += sun*vec3(1.34,1.27,0.99)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n        lighting += sky*vec3(0.16,0.20,0.28);\n        lighting += ind*vec3(0.40,0.28,0.20);\n        \n        if( rp.y < WATERH+0.001 )\n        {\t\t\t\t\t\t\t\t\t\n            col = vec3( 0.10, 0.13, 0.16 );\n            #ifdef WATERFBM\n            col *= (1.0+0.5*fbm3D(vec3(rp.xz*0.1,time*0.07)*10.0+fbm3D(vec3(rp.xz*0.5,time*0.07)*10.0)));\n            #endif\n        }\n        else\n        {\n            col = terrainColor( rp, n );\n        }\n        \n        col *= lighting;\n    }\n\n\n    float r = min(1.0, td/40.0);\n    r*=r;\n    float rpy = rp.y/4.0;\n    col = mix( col, vec3( 0.68, 0.84, 1.0 )*0.8, min(1.0,r/rpy));  \n    vec3 tmp1 = vec3(smooth3D(rd*200.0))*vec3(0.99,0.99,1.0);\n    tmp1 -= 0.95;\n    tmp1 = max(vec3(0.0),tmp1)*20.0;\n    vec3 tmp2 = mix( vec3( 0.05, 0.15, 0.35 ), tmp1, smoothstep( 0.0, 30.0, rp.y )*smoothstep( 15.0, 35.0, td) );\n    col = mix( col, tmp2, smoothstep( 0.0, 15.0, rp.y )*smoothstep( 15.0, 35.0, td) );  \n    \n    rd -= s;\n\tfloat rdatan = atan(rd.y, rd.z);\n    rd += s;\n    \n    float srd = max(0.0,dot(s,rd))*fbm(vec2(rdatan*4.0,time*0.5)); \n    col = mix(col,vec3(1.0,0.8,0.4),0.18*srd );\n    \n  \tfloat ss = clamp( dot(rd, s), 0.0, 1.0);         //\n    col += 0.4*pow(ss,5.0)*vec3(1.0,0.7,0.5)*2.0;    // from iq's shader https://www.shadertoy.com/view/llj3Rz\n    col += 0.4*pow(ss,64.0)*vec3(1.0,0.9,0.7)*2.0;   //\n    \n    col = clamp(col, 0.0, 1.0);\n    col = pow(col, vec3(0.45));\n    \n    float t = 0.5;\n    float f = 8.0;\n    col = (1.0/(1.0+exp(4.0-f*col))-0.0003)/(0.982-0.018);\n    \n    p.x/=iResolution.x/iResolution.y;\n    col *= smoothstep( 1.325, 0.825, abs(p.x) );\n    col *= smoothstep( 1.325, 0.825, abs(p.y) );\n    \n     float jitter = (noise3D(rd)*2.0-1.0)*2.0/256.0;\n    col += jitter;\n    \n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}