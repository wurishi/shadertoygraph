{"ver":"0.1","info":{"id":"fsKczG","date":"1655090561","viewed":79,"name":"RayMarcherInit","username":"alanza","description":"attempting to undestand raymarching","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdSphere (in vec3 point, in vec4 sphere) {\n    return length(point - sphere.xyz) - sphere.w;\n}\n\nfloat sdFloor (in vec3 point) {\n    return point.y;\n}\n\nfloat map (in vec3 point) {\n    float ground = sdFloor(point);\n    float sphere = sdSphere(point, vec4(0,2,5,1.5));\n    float sphere2 = sdSphere(point, vec4(3,.5,3,.25));\n    float woggle = sin(5.*point.x + iTime) * sin(5.*point.y + iTime) * sin(5.*point.z + iTime) * .25;\n    return min(ground, min(sphere + woggle, sphere2 - woggle));\n}\n\nvec3 normalToMap (in vec3 point) {\n    const vec2 eps = vec2(0.0005,0.0);\n    return normalize(\n        eps.xyy * map(point + eps.xyy) +\n        eps.yxy * map(point + eps.yxy) +\n        eps.yyx * map(point + eps.yyx) -\n        eps.xxx * map(point + eps.xxx));\n}\n\nmat3 makeCamera (in vec3 point, in vec3 ta, float tilt) {\n    vec3 camera_w = normalize(ta-point);\n    vec3 camera_p = vec3(sin(tilt), cos(tilt), 0.0);\n    vec3 camera_u = normalize(cross(camera_w, camera_p));\n    vec3 camera_v = normalize(cross(camera_u, camera_w));\n    return mat3(camera_u, camera_v, camera_w);\n}\n\nvec3 toLight (in vec4 light, in vec3 position) {\n    return light.w * normalize(light.xyz - position);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.x;\n    \n    vec3 ta = vec3(0,1,5);\n    vec3 ro = ta + vec3(5.*sin(.5*iTime),0,5.*cos(.5*iTime));\n    float fl = .5;\n    vec3 rd = makeCamera(ro, ta, 0.0) * normalize(vec3(uv,fl));\n    vec4 light = vec4(-1,3,20,1);\n    vec4 light2 = vec4(10,5,-10,5);\n\n    // Time varying pixel color\n    vec3 col = vec3(0,0,0);\n    \n    const int NUMBER_OF_STEPS = 32;\n    const float MINIMUM_HIT_DISTANCE = 0.001;\n    const float MAXIMUM_TRACE_DISTANCE = 1000.0;\n    \n    float dist_traveled = 0.0;\n    \n    for (int i = 0; i < NUMBER_OF_STEPS; i++) {\n        vec3 pos = ro + dist_traveled * rd;\n        float dist = map(pos);\n        if (dist < MINIMUM_HIT_DISTANCE) {\n            float shade2 = softshadow(pos, toLight(light2, pos), 0.1, 10.0, 5.0);\n            float shade = softshadow(pos, toLight(light, pos), 0.1, 10.0, 10.0);\n            col = max(0.0,shade*dot(toLight(light, pos), normalToMap(pos)))*(0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)));\n            col += max(0.0,shade*dot(toLight(light2, pos), normalToMap(pos)))*(0.5 + 0.5*cos(iTime+uv.xyx+vec3(1,2,3)));\n            break;\n        }\n        dist_traveled += dist;\n        if (dist_traveled > MAXIMUM_TRACE_DISTANCE) {\n            col = vec3(0,0,0);\n            break;\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}