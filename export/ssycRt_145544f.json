{"ver":"0.1","info":{"id":"ssycRt","date":"1655456420","viewed":221,"name":"Simple Text Editor","username":"rmccampbell7","description":"A text editor that supports all printable ascii characters and basic navigation keys: arrows, backspace, return, etc.","likes":11,"published":1,"flags":48,"usePreview":0,"tags":["text","font","keyboard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 COLOR = vec3(.5, 1, 1);\n\n// Note these are octal literals\nconst int[] font = int[](\n    //           !       \"       #       $       %       &       '\n    000000, 020222, 000055, 067676, 036736, 041241, 065252, 000022,\n    //   (       )       *       +       ,       -       .       /\n    021112, 024442, 000525, 002720, 012000, 000700, 020000, 011244,\n    //   0       1       2       3       4       5       6       7\n    025552, 022232, 071243, 034243, 044755, 034317, 025716, 022447,\n    //   8       9       :       ;       <       =       >       ?\n    025252, 034752, 002020, 012020, 042124, 007070, 012421, 020243,\n    //   @       A       B       C       D       E       F       G\n    025643, 055752, 035353, 061116, 035553, 071317, 011317, 065516,\n    //   H       I       J       K       L       M       N       O\n    055755, 072227, 025446, 055355, 071111, 055575, 055553, 075557,\n    //   P       Q       R       S       T       U       V       W\n    011353, 065552, 055353, 034216, 022227, 075555, 025555, 057555,\n    //   X       Y       Z       [       \\       ]       ^       _\n    055255, 022255, 071247, 031113, 044211, 064446, 000052, 070000,\n    //   `       a       b       c       d       e       f       g\n    000021, 065600, 035311, 061600, 065644, 061720, 022724, 034656,\n    //   h       i       j       k       l       m       n       o\n    055311, 022202, 012202, 053511, 022223, 057700, 055300, 075700,\n    //   p       q       r       s       t       u       v       w\n    013530, 046560, 011300, 032130, 042272, 065500, 025500, 077500,\n    //   x       y       z       {       |       }       ~\n    052500, 034650, 031230, 062326, 022222, 032623, 000630, 000000\n);\n\nvec4 read_mem(int addr) {\n    return texelFetch(iChannel0, addr_to_coord(addr), 0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y = 1. - uv.y;\n    ivec2 px = ivec2(uv * vec2(SCREEN_DIM));\n    ivec2 cell = px / CHAR_DIM;\n    ivec2 cp = px % CHAR_DIM;\n\n    int ind = cell.x + cell.y * 40;\n    int char = int(read_mem(TEXT_ADDR + ind).r);\n    int cursor = int(read_mem(CURSOR_ADDR).r);\n    float press_time = read_mem(PRESS_TIME_ADDR).r;\n\n    int bits = font[clamp(char-32, 0, font.length()-1)];\n    bool v = cp.y < 5 && cp.x < 3 && bool(bits >> (3*cp.y + cp.x) & 1);\n    if (ind == cursor) {\n        bool blink = fract((iTime - press_time) / 1.) < .5;\n        v = v || (cp.y == 5 && blink);\n    }\n\n    vec3 col = float(v) * COLOR;\n\n    // Display memory contents\n    //col = texture(iChannel0, uv/8.).rgb/256.;\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/// Keyboard input\n\nconst int K_BACKSPACE = 8;\nconst int K_TAB = 9;\nconst int K_ENTER = 13;\nconst int K_SHIFT = 16;\nconst int K_CAPSLOCK = 20;\nconst int K_ESCAPE = 27;\nconst int K_SPACE = 32;\nconst int K_PGUP = 33;\nconst int K_PGDN = 34;\nconst int K_END = 35;\nconst int K_HOME = 36;\nconst int K_LEFT = 37;\nconst int K_UP = 38;\nconst int K_RIGHT = 39;\nconst int K_DOWN = 40;\nconst int K_INSERT = 45;\nconst int K_DELETE = 46;\nconst int K_0 = 48;\nconst int K_9 = 57;\nconst int K_A = 65;\nconst int K_Z = 90;\n\n// Key codes (-32) to ASCII\nconst int[] key_map = int[](\n    32,  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n    48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  0,   0,   0,   0,   0,   0,\n    0,   97,  98,  99,  100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,\n    112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 0,   0,   0,   0,   0,\n    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   59,  61,  44,  45,  46,  47,\n    96,  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   91,  92,  93,  39\n);\n\nconst int[] shift_key_map = int[](\n    32,  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n    41,  33,  64,  35,  36,  37,  94,  38,  42,  40,  0,   0,   0,   0,   0,   0,\n    0,   65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,\n    80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  0,   0,   0,   0,   0,\n    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   58,  43,  60,  95,  62,  63,\n    126, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   123, 124, 125, 34\n);\n\nbool key_down(int key) {\n    return texelFetch(iChannel1, ivec2(key, 0), 0).r > 0.;\n}\n\nbool key_pressed(int key) {\n    return texelFetch(iChannel1, ivec2(key, 1), 0).r > 0.;\n}\n\nbool key_toggled(int key) {\n    return texelFetch(iChannel1, ivec2(key, 2), 0).r > 0.;\n}\n\nint get_key_press() {\n    for (int k = 1; k < 256; k++) {\n        if (key_pressed(k)) {\n            return k;\n        }\n    }\n    return 0;\n}\n\nint key_to_char(int key, bool shift, bool caps) {\n    if (key < 32 || key >= 32 + key_map.length())\n        return 0;\n    if (key >= K_A && key <= K_Z)\n        shift = shift ^^ caps;\n    return shift ? shift_key_map[key-32] : key_map[key-32];\n}\n\n/// Memory\n\nint mem_addr;\nvec4 mem_cell;\n\nvec4 read_mem(int addr) {\n    return texelFetch(iChannel0, addr_to_coord(addr), 0);\n}\n\nvoid write_mem(int addr, vec4 val) {\n    if (mem_addr == addr) mem_cell = val;\n}\n\nvoid clear_mem() {\n    mem_cell = vec4(0);\n}\n\n// Initial text\nconst int[] START_TEXT = int[](\n    72,101,108,108,111,44,32,87,111,114,108,100,33\n);\n\nvoid init_text() {\n    int start_row = TEXT_DIM.y / 2;\n    int start_col = (TEXT_DIM.x - START_TEXT.length()) / 2;\n    int start_addr = TEXT_ADDR + start_row*TEXT_DIM.x + start_col;\n    for (int i = 0; i < START_TEXT.length(); i++) {\n        write_mem(start_addr + i, vec4(START_TEXT[i]));\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 coord = ivec2(fragCoord);\n    mem_addr = coord_to_addr(coord);\n    mem_cell = texelFetch(iChannel0, coord, 0);\n    \n    if (iFrame < 4) {\n        init_text();\n    }\n\n    int cursor = int(read_mem(CURSOR_ADDR).r);\n\n    bool shift = key_down(K_SHIFT);\n    bool caps = key_toggled(K_CAPSLOCK);\n    bool ins = key_toggled(K_INSERT);\n    int key = get_key_press();\n\n    int char = key_to_char(key, shift, caps);\n    if (char > 0) {\n        write_mem(TEXT_ADDR + cursor, vec4(char));\n        if (!ins) cursor += 1;\n    }\n    else if (key == K_BACKSPACE) {\n        if (cursor > 0) {\n            cursor -= 1;\n            write_mem(TEXT_ADDR + cursor, vec4(0));\n        }\n    }\n    else if (key == K_DELETE) {\n        write_mem(TEXT_ADDR + cursor, vec4(0));\n    }\n    else if (key == K_ENTER) {\n        cursor = (cursor / TEXT_DIM.x + 1) * TEXT_DIM.x;\n    }\n    else if (key == K_LEFT) {\n        cursor -= 1;\n    }\n    else if (key == K_RIGHT) {\n        cursor += 1;\n    }\n    else if (key == K_UP) {\n        cursor -= TEXT_DIM.x;\n    }\n    else if (key == K_DOWN) {\n        cursor += TEXT_DIM.x;\n    }\n    else if (key == K_HOME) {\n        cursor = cursor / TEXT_DIM.x * TEXT_DIM.x;\n    }\n    else if (key == K_END) {\n        cursor = (cursor / TEXT_DIM.x + 1) * TEXT_DIM.x - 1;\n    }\n    else if (key == K_PGUP) {\n        cursor = cursor % TEXT_DIM.x;\n    }\n    else if (key == K_PGDN) {\n        cursor = cursor % TEXT_DIM.x + TEXT_SIZE - TEXT_DIM.x;\n    }\n    else if (key == K_TAB) {\n        if (shift) {\n            cursor = (cursor - 1) / 8 * 8;\n        } else {\n            cursor = (cursor / 8 + 1) * 8;\n        }\n    }\n    else if (key == K_ESCAPE) {\n        clear_mem();\n        cursor = 0;\n    }\n    \n    if (key != 0) {\n        write_mem(PRESS_TIME_ADDR, vec4(iTime));\n    }\n\n    cursor = clamp(cursor, 0, TEXT_SIZE-1);\n    write_mem(CURSOR_ADDR, vec4(cursor));\n\n    fragColor = mem_cell;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const int MEM_WIDTH = 64;\n\nconst int CURSOR_ADDR = 0;\nconst int PRESS_TIME_ADDR = 1;\nconst int TEXT_ADDR = 2;\n\nconst ivec2 TEXT_DIM = ivec2(40, 15);\nconst int TEXT_SIZE = TEXT_DIM.x * TEXT_DIM.y;\nconst ivec2 CHAR_DIM = ivec2(4, 6);\nconst ivec2 SCREEN_DIM = TEXT_DIM * CHAR_DIM;\n\nint coord_to_addr(ivec2 coord) {\n    return coord.x < MEM_WIDTH ? coord.x + MEM_WIDTH*coord.y : -1;\n}\n\nivec2 addr_to_coord(int id) {\n    return ivec2(id % MEM_WIDTH, id / MEM_WIDTH);\n}\n","name":"Common","description":"","type":"common"}]}