{"ver":"0.1","info":{"id":"3lsyD4","date":"1592102858","viewed":679,"name":"@Party4KExeGfx-Orange On A Table","username":"bitnenfer","description":"[url]https://www.pouet.net/prod.php?which=85864[/url]\nPort of my 4K executable graphics entry for @party 2020. The original was written in HLSL and rendered using DX12.\nYou can click on the screen to re-render the scene.","likes":24,"published":1,"flags":32,"usePreview":1,"tags":["raymarching","pathtracing","creepy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 c = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n    fragColor = vec4(clamp((c * (2.51 * c + 0.03)) / (c * (2.43 * c + 0.59) + 0.14), 0.0, 1.0), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159265359\n#define TAU (PI*2.0)\n#define mul(a, b) ((a) * (b))\n\nvec3 seed = vec3(0);\nfloat random()\n{\n    return fract(sin(fract(sin(dot(seed.xy, vec2(12.9898, 78.233)) * (seed.z += 1.0)) * 43758.5453))*753.5453123);\n}\n\n// Original from http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\n// Based from yx pathtracers https://www.shadertoy.com/view/ts2cWm\nvec3 ortho(vec3 v) {\n\t//  See : http://lolengine.net/blog/2013/09/21/picking-orthogonal-vector-combing-coconuts\n\treturn abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0) : vec3(0.0, -v.z, v.y);\n}\n\nvec3 getSampleBiased(vec3 dir, float power) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\n\tvec2 r = vec2(random(), random());\n\tr.x = r.x * 2. * PI;\n\tr.y = pow(r.y, 1.0 / (power + 1.0));\n\tfloat oneminus = sqrt(1.0 - r.y * r.y);\n\treturn cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir;\n}\n\nmat2 rot(float r)\n{\n    float c = cos(r), s = sin(r);\n    return mat2(c, s, -s, c);\n}\n\nstruct HitData\n{\n    float dist;\n    vec3 color;\n    bool emissive;\n    bool specular;\n};\n\n/* iq's distance functions */\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n    \nHitData opUnion(HitData a, HitData b)\n{\n    if (a.dist < b.dist) return a;\n    return b;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat palm(vec3 p)\n{\n    p.x += p.x * 0.3;\n    p.yz *= rot(0.3);\n    p.xy *= rot(-p.x * 0.07);\n    p.zy *= rot(p.x * 0.01);\n    float topPalm = sdRoundedCylinder(p + vec3(0.0, 0.7, -3.9), 3.0, 1.5, 0.1);\n    return topPalm;\n}\n\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\nfloat finger3(vec3 p, float len, float r)\n{\n    float d = 100.;\n    float rotation = -0.01;\n    float sc = 0.8;\n    for (int i = 0; i < 3; ++i)\n    {\n        p.yz *= rot(rotation);\n        p.z += len*1.4;\n        float dd = sdCapsule(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, len), sc);\n        d = smin(d, dd, 1.2);\n        rotation += r;\n        sc *= 0.65;\n    }\n    return d;\n}\n\nfloat fingers(vec3 p)\n{\n    vec3 pd1 = p;\n    vec3 pd2 = p - vec3(2.5, 0.0, -0.5);\n    vec3 pd3 = p + vec3(2.5, 0.8, 1.0);\n    vec3 pd4 = p - vec3(0.0, -2.9, 3.7);\n    \n    pd1.xz *= rot(-0.25);\n    pd2.xz *= rot(-0.1);\n    pd3.xz *= rot(-0.5);\n    pd4.xy *= rot(-2.8);\n    pd4.yz *= rot(1.2);\n    \n    float right = finger3(pd2, 3.1, -0.57);    \n    float middle = finger3(pd1, 3.2, -0.7);\n    float left = finger3(pd3, 2.5, -0.7);\n    float thumb = finger3(pd4, 3.5, -0.2);\n    \n    return min(min(min(right, middle), left), thumb);\n}\n\nfloat hand(vec3 p, float thickAdded)\n{\n    p *= 2.0;\n    float pl = (palm(p) - thickAdded) * 0.7;\n    float fing = fingers(p + vec3(0.0, 0.4, 0.0));\n    \n    pl = smin(pl, fing, 1.0);\n    \n    return pl * 0.5\n        ;\n}\n\nfloat fingers2(vec3 p)\n{\n    vec3 pd1 = p;\n    vec3 pd2 = p - vec3(2.5, 0.0, -0.5);\n    vec3 pd3 = p + vec3(2.5, 0.8, 1.0);\n    //vec3 pd4 = p - vec3(0.0, -2.9, 3.7);\n    \n    pd1.xz *= rot(-0.25);\n    pd2.xz *= rot(-0.1);\n    pd3.xz *= rot(-0.5);\n    //pd4.xy *= rot(-2.8);\n    //pd4.yz *= rot(2.2);\n    \n    float right = finger3(pd2, 3.1, -0.6);    \n    float middle = finger3(pd1, 3.2, -0.5);\n    float left = finger3(pd3, 2.5, -0.2);\n    //float thumb = finger3(pd4, 3.5, -0.2);\n    \n    //return min(min(min(right, middle), left), thumb);\n    return min(min(right, middle), left);\n}\n\nfloat hand2(vec3 p, float thickAdded)\n{\n    p *= 2.0;\n    float pl = (palm(p) - thickAdded) * 0.7;\n    float fing = fingers2(p + vec3(0.0, 0.4, 0.0));\n    \n    pl = smin(pl, fing, 1.0);\n    \n    return pl * 0.5\n        ;\n}\n\nHitData getCeilingAndWalls(vec3 p)\n{\n\tfloat topWidth = 0.8;\n    float ceilingSdf = 100.0;\n    vec3 rp = p - vec3(7, 1, 7);\n    rp.xz = mul(rp.xz, rot(-90.0*PI/180.0));\n    float wallWidth = 0.3;\n    float wallY = -8.0;\n    float w2 = sdBox(p - vec3(25.2, wallY, 0), vec3(wallWidth, 12, 10));\n\n    vec2 offset = vec2(-6,3);\n    w2 = max(w2, -sdBox(p - vec3(15, -10.+ offset.y, 0.+ offset.x), vec3(20, 1.5, 1.5)));\n    w2 = max(w2, -sdBox(p - vec3(15, -13.5+ offset.y, 0.+ offset.x), vec3(20, 1.5, 1.5)));\n    w2 = max(w2, -sdBox(p - vec3(15, -10.+ offset.y, 3.5+ offset.x), vec3(20, 1.5, 1.5)));\n    w2 = max(w2, -sdBox(p - vec3(15, -13.5+ offset.y, 3.5+ offset.x), vec3(20, 1.5, 1.5)));\n    \n    ceilingSdf = min(ceilingSdf, sdBox(p - vec3(-2, 0, 5), vec3(topWidth, 3, 15)));\n    ceilingSdf = min(ceilingSdf, sdBox(p - vec3(6, 0, 5), vec3(topWidth, 3, 15)));\n    ceilingSdf = min(ceilingSdf, sdBox(p - vec3(25, 0, 0), vec3(topWidth, 3, 10)));\n    ceilingSdf = min(ceilingSdf, sdBox(rp - vec3(-2, 0, 10), vec3(topWidth+1., 3, 10)));\n    ceilingSdf = min(ceilingSdf, sdBox(rp - vec3(-2, -9.,4+5), vec3(topWidth, 12, 10)));\n    ceilingSdf = min(ceilingSdf, sdBox(p - vec3(0, 2, 5), vec3(25, 1, 15)));\n    ceilingSdf = min(ceilingSdf, sdBox(p - vec3(-2.2, wallY, 5), vec3(wallWidth, 12, 15)));\n    ceilingSdf = min(ceilingSdf, w2);\n    ceilingSdf = min(ceilingSdf, sdBox(p - vec3(6.7, wallY, 15), vec3(wallWidth+1.0, 12, 8)));\n    ceilingSdf = min(ceilingSdf, sdBox(p - vec3(24.5, -8, 8), vec3(2, 12, 1)));\n    ceilingSdf = min(ceilingSdf, sdBox(p - vec3(0, -8, 20), vec3(5, 12, 1)));\n    ceilingSdf = max(ceilingSdf, -sdBox(p - vec3(-1, -10, 15), vec3(2, 7, 4)));\n    ceilingSdf = min(ceilingSdf, sdBox(p - vec3(0, -7, 20), vec3(25, 10, 1)));\n    ceilingSdf = min(ceilingSdf, sdBox(p - vec3(-13, -7, 10), vec3(12, 10, 1)));\n    HitData res = HitData( ceilingSdf-0.1, vec3(0.6, 0.9, 1.0), false, false );\n    return res;\n}\n\nHitData getHand(vec3 p)\n{\n    float scene = 100.0;\n    p += vec3(3.1, 4.9, -12.2);\n    p.zx = mul(p.zx, rot(0.3));\n    p.yz = mul(p.yz, rot(80.*PI/180.));\n    p.xz = mul(p.xz, rot(110.*PI/180.));\n    scene = min(scene, hand(p, 0.0));\n\tHitData res = HitData( scene, vec3(0.3, 0.3, 0.3), false, false );\n\treturn res;\n}\n\nHitData getHand2(vec3 p)\n{\n    float scene = 100.0;\n    p += vec3(3.1, 9.9, -17.2);\n    p.zx = mul(p.zx, rot(0.3));\n    p.yz = mul(p.yz, rot(-80.*PI/180.));\n    p.xz = mul(p.xz, rot(90.*PI/180.));\n    scene = min(scene, hand2(p, 0.0));\n\tHitData res = HitData( scene, vec3(0.3, 0.3, 0.3), false, false );\n\treturn res;\n}\n\nHitData getHead(vec3 p)\n{\n    float scene = 100.0;\n    p += vec3(-2.5, -1.9, 6);\n    scene = min(scene, length(p - vec3(-2, -3.5, 17)) - 0.07);\n    scene = min(scene, length(p - vec3(0.0, -4.0, 18)) - 0.07);\n    float he = length((p - vec3(-1.9, -4.0, 20)) * vec3(1, 0.8, 1)) - 2.5;\n    he = smin(he, length(p - vec3(-2.9, -7.0, 20)) - 1.0, 0.8);\n    he = smin(he, length(p - vec3(-4.1, -7.5, 20)) - 1.3, 0.8);\n    he = smin(he, length(p - vec3(-5.9, -8.0, 20)) - 1.5, 0.8);\n    \n    HitData a = HitData(scene, vec3(1,1,0.5)*1.5, true, false);\n    HitData b = HitData(he, vec3(0.2, 0.2, 0.2), false, false);\n\n    return opUnion(a, b);\n}\n\nfloat getChair(vec3 p)\n{\n\tfloat bounds = sdBox(p, vec3(1.5, 4, 1.5));\n    if (bounds < 0.1)\n    {\n\t    float scene = sdBox(p - vec3(0, -1.5, 0), vec3(1.3, 0.1, 1.4));\n\t    scene = min(scene, sdBox(p - vec3(1.1, -1.5, -1.25), vec3(0.1, 3, 0.1)));\n\t    scene = min(scene, sdBox(p - vec3(-1.1, -1.5, -1.25), vec3(0.1, 3, 0.1)));\n\t    scene = min(scene, sdBox(p - vec3(-1.1, -3.5, 1.3), vec3(0.1, 2, 0.1)));\n\t    scene = min(scene, sdBox(p - vec3(1.1, -3.5, 1.3), vec3(0.1, 2, 0.1)));\n\t    scene = min(scene, sdBox(p - vec3(0.0, 1.0, -1.3), vec3(1.3, 0.5, 0.1)));\n\t    scene = min(scene, sdBox(p - vec3(0.0, 0.5, -1.3), vec3(1.3, 0.5, 0.1)));\n\t    return scene;\n\t}\n\treturn bounds;\n}\n\nHitData getTable(vec3 p)\n{\n    float scene = sdBox(p - vec3(15.5, -15, 2), vec3(7.0, 4.0, 5));\n    if (scene < 0.1)\n    {\n\t     p -= vec3(15, -13, 2);\n\t    p.xz = mul(p.xz, rot(0.05));\n\t    scene = max(sdBox(p - vec3(0, -0.3, 0), vec3(5, 0.2, 3))-0.3,-sdBox(p - vec3(0, -0.7, 0), vec3(7, 0.5, 5)));\n\t    scene = min(scene, sdBox(p - vec3(-4, -3, -2), vec3(0.2, 3, 0.2)));\n\t    scene = min(scene, sdBox(p - vec3(-4, -3, 2), vec3(0.2, 3, 0.2)));\n\t    scene = min(scene, sdBox(p - vec3(4, -3, -2), vec3(0.2, 3, 0.2)));\n\t    scene = min(scene, sdBox(p - vec3(4, -3, 2), vec3(0.2, 3, 0.2)));\n\t    vec3 cp = p - vec3(-1.5, 0, -3);\n\t    cp.xz = mul(cp.xz, rot(-0.4));\n\t    scene = min(scene, getChair(cp));\n\t\tvec3 cp2 = p - vec3(6, 0, 0);\n\t    cp2.xz = mul(cp2.xz, rot(1.8));\n\t    scene = min(scene, getChair(cp2));\n  \t}\n    HitData res = HitData( scene, vec3(1, 0.9, 0.8), false, true );\n    return res;\n}\n\nHitData map(vec3 p)\n{\n\tfloat c = mod((floor(p.x*.5) + floor(p.z*.5) + floor(p.y*.5)), 2.0);\n\tHitData scene = getCeilingAndWalls(p);\n    HitData ground = HitData( sdBox(p - vec3(11, -18, 5), vec3(15, 1, 15)), vec3(0.9, 0.9, 0.9) * clamp(0.5 + abs(c)*0.5, 0., 1.0), false, true );\n\tscene = opUnion(scene, ground);\n\n\tif (sdBox(p - vec3(-1.5, -5.9, 13), vec3(6, 8, 6)) < 0.1)\n\t{\n\t\tif (sdBox(p - vec3(-1.5, -5.0, 9), vec3(2, 4, 2)) < 0.1)\n\t\t{\n\t\t\tscene = opUnion(scene, getHand(p));\n\t\t}\n\t\tif (sdBox(p - vec3(0, -10.0, 16), vec3(4, 4, 2)) < 0.1)\n\t\t{\n\t\t\tscene = opUnion(scene, getHand2(p));\n\t\t}\n\t\tscene = opUnion(scene, getHead(p));\n\t}\n\tscene = opUnion(scene, getTable(p - vec3(-2, 0, 0)));\n\tHitData a = HitData( length(p - vec3(15, -12.6, 1.2)) - 0.25, vec3(1, 0.2, 0.0)*2.0, false, false );\n\tHitData b = HitData( length(p - vec3(15.4, -12.65, 1.5)) - 0.20, vec3(1, 0.3, 0.0)*1.0, false, false );\n \tscene = opUnion(scene, a);\n \tscene = opUnion(scene, b);\n \treturn scene;\n}\n\nbool raytrace(vec3 ro, vec3 rd, out HitData data)\n{\n    float t = 0.0;\n    for (int i = 0; i < 150+min(0,iFrame); ++i)\n    {\n    \tHitData d = map(ro + rd * t);\n        if (d.dist < 0.001)\n        {\n\t\t\tdata = d;\n            data.dist = t;\n        \treturn true;\n        }\n        t += d.dist;\n        if (t > 80.0) break;\n    }\n\treturn false;\n}\n\n// Original from http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec3 pathtrace(vec2 uv)\n{\n   \tvec3 ro = vec3(14,-7.0,-28);\n    vec3 rd = normalize(vec3(uv.x-0.4, uv.y-0.3, 3.5));\n    vec3 sunDir = normalize(vec3(0.9, 0.3, -0.4));\n    vec3 sunColor = vec3(1, 0.9, .7)*6.;\n    vec3 direct = vec3(0, 0, 0), luminance = vec3(1, 1, 1);\n\n\tfor (int b = 0; b < 4+min(0,iFrame); ++b)\n    {    \n\t    HitData data;\n        if (raytrace(ro, rd, data))\n        {\n            vec2 e = vec2(0, 0.01);\n            vec3 p = ro + rd * data.dist;\n            vec3 n = normalize(vec3(\n                map(p + e.yxx).dist - map(p - e.yxx).dist,\n                map(p + e.xyx).dist - map(p - e.xyx).dist,\n                map(p + e.xxy).dist - map(p - e.xxy).dist\n            ));\n            // return n;\n            if (data.specular)\n\t           \trd = getSampleBiased(normalize(reflect(rd, n)), 500.0);\n            else\n\t           \trd = getSampleBiased(n, 1.0);\n    \n            ro = p + rd * 0.2;\n            luminance *= data.color;\n\t\t\t\n            if (!data.emissive)\n            {\n\t\t\t\tvec3 sunSampleDir = getSampleBiased(sunDir, 980.0);\n                float ndl = dot(n, sunSampleDir);\n                HitData tmp;\n                if (ndl > 0.0 && !raytrace(ro, sunSampleDir, tmp))\n                {\n                    direct += luminance * ndl * sunColor;\n                }\n            }\n            else\n            {\n\t\t\t\tdirect += luminance;\n            }\n        }\n        else\n        {\n            return direct + luminance * vec3(0.4, 0.9, 0.7) * 0.1;\n        }\n    }\n\treturn vec3(0, 0, 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    if (uv.y < 0.07 || uv.y > 0.93)\n    {\n        fragColor = vec4(0,0,0,0);\n        return;\n    }\n    vec4 prevFrame = texture(iChannel0, uv);\n    seed = vec3(uv,iTime);\n    uv = (uv * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 jitter = 2.0 / iResolution.xy * (vec2(random(), random()) * 2.0 - 1.0);\n\tvec3 color = pathtrace(uv + jitter);\n    // demofox blend :D\n    float blend = (prevFrame.a == 0.0f || iFrame == 0 || iMouse.z > 0.0) ? 1.0f : 1.0f / (1.0f + (1.0f / prevFrame.a));\n\tfragColor = vec4(mix(prevFrame.rgb, color, blend), blend);\n}","name":"Buffer A","description":"","type":"buffer"}]}