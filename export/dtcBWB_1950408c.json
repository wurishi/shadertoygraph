{"ver":"0.1","info":{"id":"dtcBWB","date":"1701794866","viewed":39,"name":"morphing shapes//","username":"mazek","description":"morphing. Need to figure out how to set a max and min sizes that the shapes can get. the square gets too big and the circle doesn't get big enough","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["morphingshapesfromonetoanother"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.;\nconst float MAX_DIST = 100.;\nconst float EPSILON = .0001;\n\nfloat sphereSDF(vec3 samplePoint, float size){\n    return length(samplePoint) - size;\n}\n\nfloat cubeSDF(vec3 p, vec3 size){\n    vec3 d = abs(p) - size;\n    float insideDistance = min(max(d.x, max(d.y,d.z)),0.);\n    float outsideDistance = length(max(d,0.));\n    return insideDistance + outsideDistance;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sceneSDF(vec3 samplePoint){\n    float d1 = sphereSDF(samplePoint,(abs(sin(.8+iTime/4.))));\n    float d2 = cubeSDF(samplePoint, vec3(abs(sin(.8-iTime/4.))));\n    float dt = opSmoothUnion(d1, d2, .25);\n    return dt;\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end){\n    float depth = start;\n    for(int i=0;i<MAX_MARCHING_STEPS;i++){\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if(dist<EPSILON){\n            return depth;\n        }\n        depth += dist;\n        if(depth>=end){\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord){\n    vec2 xy = fragCoord - size/2.;\n    float z = size.y / tan(radians(fieldOfView)/2.);\n    return normalize(vec3(xy,-z));\n}\n\nvec3 estimateNormal(vec3 p){\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON,p.y,p.z)) - sceneSDF(vec3(p.x - EPSILON,p.y,p.z)),\n        sceneSDF(vec3(p.x,p.y + EPSILON,p.z)) - sceneSDF(vec3(p.x,p.y - EPSILON,p.z)),\n        sceneSDF(vec3(p.x,p.y,p.z + EPSILON)) - sceneSDF(vec3(p.x,p.y,p.z - EPSILON))));\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye, vec3 lightPos, vec3 lightIntensity){\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if(dotLN < 0.){\n        return vec3(0.,0.,0.);\n    }\n    if(dotRV < 0.){\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye){\n    const vec3 ambientLight = .5 * vec3(1.,1.,1.);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(-3.,3.,3.);\n    vec3 light1Intensity = vec3(.85,.85,.85);\n    color += phongContribForLight(k_d, k_s, alpha, p, eye, light1Pos, light1Intensity);\n    \n    vec3 light2Pos = vec3(3.,3.,0.);\n    vec3 light2Intensity = vec3(.6,.6,.6);\n    color += phongContribForLight(k_d, k_s, alpha, p, eye, light2Pos, light2Intensity);\n    return color;\n}\n\nmat4 camMat(vec3 eye, vec3 center, vec3 up){\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(vec4(s,0.), vec4(u,0.), vec4(-f,0.), vec4(0.,0.,0.,1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dir = rayDirection(45., iResolution.xy, fragCoord);\n    vec3 eye = vec3(5.,3.,5.);\n    mat4 viewWorld = camMat(eye, vec3(0.,0.,0.), vec3(0.,1.,0.));\n    vec3 worldDir = (viewWorld * vec4(dir, 0.)).xyz;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if(dist > MAX_DIST - EPSILON){\n        fragColor = vec4(0.,0.,0.,0.);\n        return;\n    }\n    vec3 p = eye + dist * worldDir;\n    vec3 K_a = vec3(0.,0.,1.);\n    vec3 K_d = vec3(1.,1.,1.);\n    vec3 K_s = vec3(.4,.4,.4);\n    float shine = 10000.;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shine, p, eye);\n    color = color * color;\n\n    fragColor = vec4(color,1.);\n}","name":"Image","description":"","type":"image"}]}