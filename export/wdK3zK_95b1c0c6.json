{"ver":"0.1","info":{"id":"wdK3zK","date":"1571155079","viewed":142,"name":"First Ray Marching Experiment","username":"msiddeek","description":"First experiment","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["ray"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 100.\n#define PREC .01\n#define PREC1 .03\n#define SHADOW_QUAL 100.\n\n#define LIGHT_POS vec3(2., 2.8, 2.)\n#define LIGHT_DIR vec3(-sin(iTime * .81) * .25, -1., +sin(iTime * 4.12) * .125)\n\n\nfloat plane(vec3 p, vec4 n) {\n    return dot(p, normalize(n.xyz)) - n.w;\n}\nfloat planeX(vec3 p, float d) {\n    return plane(p, vec4(1., 0., 0., d));\n}\nfloat planeY(vec3 p, float d) {\n    return plane(p, vec4(0., 1., 0., d));\n}\nfloat planeZ(vec3 p, float d) {\n    return plane(p, vec4(0., 0., 1., d));\n}\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nvec4 map(vec3 p) {\n    float d = MAX_DIST;\n    float m = .0;\n\n    float px1 = planeX(p, -3.);\n    float px2 = -planeX(p, 3.);\n    float pz1 = -planeZ(p, 3.);\n    float pz2 = planeZ(p, -3.);\n    float py1 = planeY(p, 0.);\n    float py2 = -planeY(p, 4.);\n    if (d > px1) {\n        d = px1;\n        m = 1.;\n    }\n    if (d > px2) {\n        d = px2;\n        m = 5.;\n    }\n    if (d > pz1) {\n        d = pz1;\n        m = 2.;\n    }\n    if (d > pz2) {\n        d = pz2;\n        m = 3.;\n    }\n    if (d > py1) {\n        d = py1;\n        m = 0.;\n    }\n    if (d > py2) {\n        d = py2;\n        m = 4.;\n    }\n    float pl = plane(p, vec4(-1., -1., -1., -4.8));\n    if (d > pl) {\n        d = pl;\n        m = 6.;\n    }\n\n    float s = sphere(p - vec3(0., 1.25 - pow(fract(iTime * 1.) - .5, 2.) * 3., 0.), .5);\n    if (s < d) {\n        m = 7.;\n        d = s;\n    }\n\treturn vec4(d, m, 0., 0.);\n}\nvec3 normal(vec3 p) {\n    vec2 t = vec2(PREC, -PREC) * .001;\n    return normalize(\n    \tt.xyy * map(p + t.xyy).x +\n    \tt.yxy * map(p + t.yxy).x +\n    \tt.yyx * map(p + t.yyx).x +\n    \tt.xxx * map(p + t.xxx).x);\n}\nvec4 march(vec3 ro, vec3 rd, float maxD) {\n    vec4 res;\n    float d = 0.;\n    float newD = PREC;\n    while (newD >= PREC && d < maxD) {\n        res = map(ro + rd * d);\n        newD = res.x;\n        d = min(maxD, d + newD);\n    }\n \treturn vec4(d, res.yzw);\n}\nfloat shadow(vec3 ro, vec3 rd, float maxD) {\n    float soft = 1.;\n    float d = PREC;\n    float newD = PREC;\n    while (newD >= PREC && d < maxD) {\n        newD = map(ro + rd * d).x;\n        soft = min(soft, 4. * max(0., newD - PREC) / d);\n        d += min(newD, maxD / SHADOW_QUAL);\n    }\n \treturn soft;\n}\nvec3 color(float c) {\n    if (c < 1.) {\n    \treturn vec3(1., 1., 0.) * .8;\n    } else if (c < 2.) {\n    \treturn vec3(1., 0., 1.) * .8;\n    } else if (c < 3.) {\n    \treturn vec3(.0, 1., .0) * .8;\n    } else if (c < 4.) {\n    \treturn vec3(0., 1., 1.) * .8;\n    } else if (c < 5.) {\n    \treturn vec3(1., 0., 0.) * .8;\n    } else if (c < 6.) {\n    \treturn vec3(0., .0, 1.) * .8;\n    } else if (c < 7.) {\n    \treturn vec3(2., 2., 2.);\n    } else if (c < 8.) {\n    \treturn vec3(1., 1., 1.) * .1;\n    }\n}\nfloat reflection(float c) {\n    if (c < 6.) {\n    \treturn 0.;\n    } else if (c < 8.) {\n    \treturn 1.;\n    }\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0);\n\n    vec4 m = march(ro, rd, MAX_DIST); \n    float hd = m.x;\n    vec3 h = ro + rd * (hd - PREC1);\n    vec3 n = normal(h);\n    vec3 lh = h - LIGHT_POS;\n    vec3 diff = dot(n, -normalize(lh)) * color(m.y);\n    if (color(m.y).x <= 1.) {\n        float shad = clamp(0., 1., shadow(h, normalize(-lh), length(lh)) + .25);\n        diff *= shad;\n    }\n\n    if (reflection(m.y) > .1 && color(m.y).x <= 1.) {\n        vec3 r = rd - 2. * dot(normalize(rd), n) * n;\n        vec4 mr = march(h, r, MAX_DIST);\n        float hdr = mr.x;\n        vec3 hr = h + r * (hdr - PREC1);\n        vec3 nr = normal(hr);\n        vec3 lhr = hr - LIGHT_POS;\n        diff = color(mr.y) * dot(nr, -normalize(lhr)) * (1.8 + dot(rd, n));\n\t    float shadr = clamp(0., 1., shadow(hr, normalize(-lhr), length(lhr)) + .25);\n        diff *= shadr;\n    }\n\n    col += diff;\n\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { \n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 ro = vec3(0., 1.25, -2.9);\n    float a = iTime * .5;\n    ro.xz = mat2(cos(a), sin(a), -sin(a), cos(a)) * ro.xz;\n    float cp = 1.;\n    vec3 rd = normalize(vec3(uv.x, uv.y, cp));\n    rd.xz = mat2(cos(a), sin(a), -sin(a), cos(a)) * rd.xz;\n\n    vec3 col = render(ro, rd);\n    col = pow(col, vec3(0.4545));\n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}