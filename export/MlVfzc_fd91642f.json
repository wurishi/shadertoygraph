{"ver":"0.1","info":{"id":"MlVfzc","date":"1543678207","viewed":296,"name":"Raytracing Grid Structure","username":"oalpha","description":"An acceleration structure where a ray is intersected with objects only in the grid boxes that the ray passes through. The reflection uses 3 bounces and 3 branches (i.e. 27 rays per sample). The reflections are best seen in full screen.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","grid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float dot2(vec2 v) {\n    return dot(v, v);\n}\nfloat dot2(vec3 v) {\n    return dot(v, v);\n}\nfloat maxc(vec2 v) {\n    return max(v.x, v.y);\n}\nfloat minc(vec2 v) {\n    return min(v.x, v.y);\n}\nfloat maxc(vec3 v) {\n    return max(maxc(v.xy), v.z);\n}\nfloat minc(vec3 v) {\n    return min(minc(v.xy), v.z);\n}\nfloat prode(vec2 v) {\n    return v.x * v.y;\n}\nvec2 affineTransform(mat3 t, vec2 v, bool d) {\n    vec3 V = t * vec3(v, d ? 0. : 1.);\n    return V.xy;\n}\nvec3 affineTransform(mat4 t, vec3 v, bool d) {\n    vec4 V = t * vec4(v, d ? 0. : 1.);\n    return V.xyz;\n}\n#define affine affineTransform\nvoid rot(out mat3 t, out mat3 it, float a) {\n    float c = cos(a), s = sin(a);\n    t = mat3(\n        1.,0.,0.,\n        0.,c,s,\n        0.,-s,c\n    );\n    it = mat3(\n        1.,0.,0.,\n        0.,c,-s,\n        0.,s,c\n    );\n}\nvoid trans(out mat3 t, out mat3 it, vec2 v) {\n    t = mat3(\n        1.,0.,v.x,\n        0.,1.,v.y,\n        0.,0.,1.\n    );\n    it = mat3(\n        1.,0.,-v.x,\n        0.,1.,-v.y,\n        0.,0.,1.\n    );\n}\nvoid scale(out mat3 t, out mat3 it, vec2 s) {\n    vec2 is = 1. / s;\n    t = mat3(\n        s.x,0.,0.,\n        0.,s.y,0.,\n        0.,0.,1.\n    );\n    it = mat3(\n        is.x,0.,0.,\n        0.,is.y,0.,\n        0.,0.,1.\n    );\n}\nvoid rotX(out mat4 t, out mat4 it, float a) {\n    float c = cos(a), s = sin(a);\n    t = mat4(\n        1.,0.,0.,0.,\n        0.,c,s,0.,\n        0.,-s,c,0.,\n        0.,0.,0.,1.\n    );\n    it = mat4(\n        1.,0.,0.,0.,\n        0.,c,-s,0.,\n        0.,s,c,0.,\n        0.,0.,0.,1.\n    );\n}\nvoid rotY(out mat4 t, out mat4 it, float a) {\n    float c = cos(a), s = sin(a);\n    t = mat4(\n        c,0.,-s,0.,\n        0.,1.,0.,0.,\n        s,0.,c,0.,\n        0.,0.,0.,1.\n    );\n    it = mat4(\n        c,0.,s,0.,\n        0.,1.,0.,0.,\n        -s,0.,c,0.,\n        0.,0.,0.,1.\n    );\n}\nvoid rotZ(out mat4 t, out mat4 it, float a) {\n    float c = cos(a), s = sin(a);\n    t = mat4(\n        c,s,0.,0.,\n        -s,c,0.,0.,\n        0.,0.,1.,0.,\n        0.,0.,0.,1.\n    );\n    it = mat4(\n        c,-s,0.,0.,\n        s,c,0.,0.,\n        0.,0.,1.,0.,\n        0.,0.,0.,1.\n    );\n}\nvoid trans(out mat4 t, out mat4 it, vec3 v) {\n    t = mat4(\n        1.,0.,0.,v.x,\n        0.,1.,0.,v.y,\n        0.,0.,1.,v.z,\n        0.,0.,0.,1.\n    );\n    it = mat4(\n        1.,0.,0.,-v.x,\n        0.,1.,0.,-v.y,\n        0.,0.,1.,-v.z,\n        0.,0.,0.,1.\n    );\n}\nvoid scale(out mat4 t, out mat4 it, vec3 s) {\n    vec3 is = 1. / s;\n    t = mat4(\n        s.x,0.,0.,0.,\n        0.,s.y,0.,0.,\n        0.,0.,s.z,0.,\n        0.,0.,0.,1.\n    );\n    it = mat4(\n        is.x,0.,0.,0.,\n        0.,is.y,0.,0.,\n        0.,0.,is.z,0.,\n        0.,0.,0.,1.\n    );\n}\nvoid compose(\n    out mat3 t,\n    out mat3 it,\n    in mat3 t1,\n    in mat3 it1,\n    in mat3 t2,\n    in mat3 it2\n) {\n    t = t2 * t1;\n    it = it1 * it2;\n}\nvoid compose(\n    out mat4 t,\n    out mat4 it,\n    in mat4 t1,\n    in mat4 it1,\n    in mat4 t2,\n    in mat4 it2\n) {\n    t = t2 * t1;\n    it = it1 * it2;\n}\nint mini(vec2 v) {\n    return v.x < v.y ? 0 : 1;\n}\nint mini(vec3 v) {\n    if(v.x < v.y)\n        return v.x < v.z ? 0 : 2;\n    return v.y < v.z ? 1 : 2;\n}\n\nstruct Ray2 {\n    // base\n    vec2 b;\n    // direction\n    vec2 d;\n};\n#define eray2 Ray2(O2,O2)\n#define nray2(b,d) Ray2(b,normalize(d))\nstruct Ray3 {\n    // base\n    vec3 b;\n    // direction\n    vec3 d;\n};\n#define eray3 Ray3(O3,O3)\n#define nray3(b,d) Ray3(b,normalize(d))\n    \nRay3 cameraRay(\n    vec3 camera,\n    vec3 focus,\n    vec3 up,\n    vec2 fov,\n    float screen,\n    vec2 uv\n) {\n    vec3 z = normalize(camera - focus);\n    vec3 x = normalize(cross(up, z));\n    vec3 y = normalize(cross(z, x));\n    \n    mat3 raycaster = screen * mat3(\n        fov.x,0.,0.,\n        0.,fov.y,0.,\n        0.,0.,1.\n    ) * mat3(x, y, -z);\n    \n    Ray3 ray = nray3(\n        camera,\n        raycaster * vec3(uv, 1.)\n    );\n    \n    return ray;\n}\n\n// center (xy) and radius (z)\n#define Sphere2 vec3\nfloat SphereHit(Ray2 r, Sphere2 s) {\n    vec2 D = s.xy - r.b;\n    if(length(D) <= s.z)\n        return 1.;\n    if(dot(r.d, D) < 0.)\n        return 0.;\n    float D2 = dot2(D), dD = dot(r.d, D);\n    float h = D2 / dD * sqrt(1. - dD * dD / D2);\n    return h <= s.z ? 1. : 0.;\n}\n// center (xyz) and radius (w)\n#define Sphere3 vec4\nfloat SphereHit(Ray3 r, Sphere3 s) {\n    vec3 D = s.xyz - r.b;\n    if(length(D) <= s.w)\n        return 1.;\n    if(dot(r.d, D) < 0.)\n        return 0.;\n    float D2 = dot2(D), dD = dot(r.d, D);\n    float h = D2 / dD * sqrt(1. - dD * dD / D2);\n    return h <= s.w ? 1. : 0.;\n}\n\nstruct RPrism2 {\n    vec2 c;\n    vec2 s;\n};\nfloat RPrismHit(Ray2 r, RPrism2 p) {\n    vec2 c0 = p.c, c1 = p.c + p.s;\n    vec2 d0 = c0 - r.b, d1 = c1 - r.b;\n    vec2 t0 = d0 / r.d, t1 = d1 / r.d;\n    vec2 T0 = min(t0, t1), T1 = max(t0, t1);\n    float w0 = maxc(T0), w1 = minc(T1);\n    return w0 <= w1 ? 1. : 0.;\n}\nstruct RPrism3 {\n    vec3 c;\n    vec3 s;\n};\nfloat RPrismHit(Ray3 r, RPrism3 p) {\n    vec3 c0 = p.c, c1 = p.c + p.s;\n    vec3 d0 = c0 - r.b, d1 = c1 - r.b;\n    vec3 t0 = d0 / r.d, t1 = d1 / r.d;\n    vec3 T0 = min(t0, t1), T1 = max(t0, t1);\n    float w0 = maxc(T0), w1 = minc(T1);\n    return w0 <= w1 && w0 > 0. ? 1. : 0.;\n}\n\n#define XMAX 20\n#define YMAX 20\n#define CMAX 20\nivec2 grid(\n    Ray2 r,\n    vec2 B,\n    vec2 S,\n    ivec2 XY,\n    float R,\n    inout ivec2[CMAX] cells,\n    inout vec2[XMAX] Ixs,\n    inout vec2[YMAX] Iys,\n    out int cnum,\n    out int xnum,\n    out int ynum\n) {\n    vec2 dt = abs(S / r.d);\n    \n    ivec2 cell = max(\n        min(\n            ivec2(floor((r.b - B) / S)),\n            XY\n        ),\n        ivec2(-1)\n    );\n    vec2 t = max(\n        ((vec2(cell) + 1.) * S - r.b + B) / r.d,\n        (vec2(cell) * S - r.b + B) / r.d\n    );\n    cnum = xnum = ynum = 0;\n    cells[cnum++] = cell;\n    Ixs[xnum++] = r.b + r.d * t.x;\n    Iys[ynum++] = r.b + r.d * t.y;\n    float hit = 0.;\n    while(\n        all(lessThanEqual(cell, XY)) &&\n        all(greaterThanEqual(cell, ivec2(-1))) &&\n        hit < .5\n    ) {\n        cells[cnum++] = cell;\n        if(\n            all(lessThan(cell, XY)) &&\n            all(greaterThan(cell, ivec2(-1)))\n        )\n        hit = SphereHit(r, vec3((vec2(cell) + .5) * S + B, .1));\n        if(hit > .5)\n            return cell;\n        else {\n            int d = mini(t);\n            t[d] += dt[d];\n            if(d == 0)\n                Ixs[xnum++] = r.b + r.d * t.x;\n            else\n                Iys[ynum++] = r.b + r.d * t.y;\n            cell[d] += int(sign(r.d[d]));\n        }\n    }\n    return ivec2(-1);\n}\n//*\n#define ZMAX 3\nivec3 grid(\n    Ray3 r,\n    vec3 B,\n    vec3 S,\n    ivec3 XYZ,\n    float R,\n    inout ivec3[CMAX] cells,\n    inout vec3[XMAX] Ixs,\n    inout vec3[YMAX] Iys,\n    inout vec3[ZMAX] Izs,\n    out int cnum,\n    out int xnum,\n    out int ynum,\n    out int znum\n) {\n    vec3 dt = abs(S / r.d);\n    \n    ivec3 cell = max(\n        min(\n            ivec3(floor((r.b - B) / S)),\n            XYZ\n        ),\n        ivec3(-1)\n    );\n    vec3 t = max(\n        ((vec3(cell) + 1.) * S - r.b + B) / r.d,\n        (vec3(cell) * S - r.b + B) / r.d\n    );\n    cnum = xnum = ynum = 0;\n    cells[cnum++] = cell;\n    Ixs[xnum++] = r.b + r.d * t.x;\n    Iys[ynum++] = r.b + r.d * t.y;\n    float hit = 0.;\n    while(\n        all(lessThanEqual(cell, XYZ)) &&\n        all(greaterThanEqual(cell, ivec3(-1))) &&\n        hit < .5\n    ) {\n        cnum++;\n        cnum -= (cnum / CMAX) * CMAX;\n        cells[cnum++] = cell;\n        if(\n            all(lessThan(cell, XYZ)) &&\n            all(greaterThan(cell, ivec3(-1)))\n        )\n        {\n            int cs = cell.x + cell.y + cell.z;\n            int csm = cs - (cs / 2) * 2;\n        hit = csm > 1 ?\n            RPrismHit(r, RPrism3(\n                (vec3(cell) + .5) * S + B - R * .5,\n                vec3(R)\n            )) :\n            SphereHit(r, vec4((vec3(cell) + .5) * S + B, R));\n        }\n        if(hit > .5)\n            return cell;\n        else {\n            int d = mini(t);\n            t[d] += dt[d];\n            if(d == 0)\n                Ixs[xnum++] = r.b + r.d * t.x;\n            else if(d == 1)\n                Iys[ynum++] = r.b + r.d * t.y;\n            else\n                Izs[znum++] = r.b + r.d * t.z;\n            cell[d] += int(sign(r.d[d]));\n        }\n    }\n    return ivec3(-1);\n}\n//*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float tm = iTime * 0.25;\n    \n    const int N = 6;\n    const int X = N, Y = N, Z = N;\n    const float R = 6. / float(N) * .4;\n    const ivec2 XY = ivec2(X, Y);\n    const ivec3 XYZ = ivec3(X, Y, Z);\n    int cnum = 0, xnum = 0, ynum = 0, znum = 0;\n    \n    #define GRID3D\n    #ifdef GRID3D\n    \n    float D = sqrt(2.) * 3. * 1.1;\n    vec3\n        camera = vec3(\n            D * vec2(cos(tm), sin(tm)),\n            D\n            //D * 2. * vec2(cos(tm), sin(tm)),\n            //D * .5\n        ),\n        focus = vec3(0.),\n        up = vec3(0., 0., 1.);\n    vec2 fov = vec2(1.);\n    float screen = 1.;\n    \n    const int SAMPLES = 2;\n    const int SAMPLES2 = SAMPLES * SAMPLES;\n    vec4 pixel = vec4(0.);\n    for(int si = 0; si < SAMPLES2; si++) {\n        int sx = si / SAMPLES;\n        int sy = si - sx * SAMPLES;\n        vec2 shift = vec2(ivec2(sx, sy) + 1) / (float(SAMPLES) * 2.);\n        shift /= iResolution.x;\n        Ray3 r = cameraRay(\n            camera,\n            focus,\n            up,\n            fov,\n            screen,\n            ((uv + shift) * 2. - 1.) * vec2(1., iResolution.y / iResolution.x)\n        );\n\n        ivec3 cells[CMAX];\n        vec3 Ixs[XMAX], Iys[YMAX], Izs[ZMAX];\n        vec3 B = vec3(-3.);\n        vec3 S = 2. * -B / vec3(XYZ);\n\n        ivec3 target = ivec3(-1);\n        const int BOUNCES = 3;\n        const int BRANCHES = 1;\n        const int BB = 3;\n        int levels[BB];\n        float weights[BB];\n        Ray3 rays[BB];\n        int bi = 0, bn = 0;\n        vec4 cur = vec4(0.);\n        levels[bn] = 0;\n        weights[bn] = 1.;\n        rays[bn++] = r;\n        for(; bi < bn; bi++) {\n            int bc = bi - (bi / BB) * BB;\n            int level = levels[bc];\n            float weight = weights[bc];\n            r = rays[bc];\n            target = grid(\n                r,\n                B,\n                S,\n                XYZ,\n                R,\n                cells,\n                Ixs,\n                Iys,\n                Izs,\n                cnum,\n                xnum,\n                ynum,\n                znum\n            );\n\n            const float SHININESS = 100.;\n            if(all(equal(target, ivec3(-1)))) {\n                cur += weight * texture(iChannel0, r.d.xzy);\n            }\n            else {\n                vec3 center = B + S * (vec3(target) + .5);\n                vec3 w = center + 3. / 6.;\n                vec3 D = center - r.b;\n                float dD = dot(r.d, D), DD = dot2(D);\n                float len = dD - sqrt(dD * dD - DD + R * R);\n                vec3 point = len * r.d + r.b, ray = normalize(point - center);\n                r = Ray3(\n                    center,\n                    r.d - 2. * dot(r.d, ray) * ray\n                );\n                r.b += R * ray * 1.1;\n                if(level + 1 < BOUNCES) {\n                    vec3 rx = cross(r.d, vec3(1., 0., 0.));\n                    if(length(rx) < .001)\n                        rx = cross(r.d, vec3(0., 1., 0.));\n                    rx = normalize(rx);\n                    vec3 ry = normalize(cross(r.d, rx));\n                    for(int j = 0; j < BRANCHES; j++) {\n                        vec2 ruv = rvec2(\n                            vec4(r.b + ray, float(j)),\n                            rs1,\n                            rs2\n                        );\n                        ruv *= ruv;\n                        vec3 rr = normalize(r.d + .01 * (ruv.x * rx + ruv.y * ry));\n                        int bN = bn - (bn / BB) * BB;\n                        bn++;\n                        levels[bN] = level + 1;\n                        float shininess = mix(0., SHININESS, w.x);\n                        weights[bN] = weight * pow(dot(r.d, rr), shininess) / float(BRANCHES);\n                        rays[bN] = Ray3(r.b, rr);\n                    }\n                }\n                else\n                    cur += weight * texture(iChannel0, r.d.xzy);\n            }\n        }\n        pixel += cur;\n    }\n    fragColor = pixel / float(SAMPLES2);\n    \n    #else\n    \n    uv.y *= iResolution.y / iResolution.x;\n    uv *= 6.2;\n    uv -= .1;\n    \n    vec2 S = vec2(\n        .3 * cos(3. * tm + 3.) + .9,\n        .12 * cos(2. * tm + 9.) + .6\n    );\n    vec2 B = vec2(\n        .8 * cos(1.3 * tm + 7.) + 1.4,\n        .25 * cos(.8 * tm - .6) + .6\n    );\n    Ray2 r = Ray2(\n        (S + 2.) * .5 * (vec2(\n            cos(1.2 * tm + 5.),\n            cos(.9 * tm - 2.)\n        ) + 1.) + B - 1.,\n        vec2(0.)\n    );\n    r.d = \n        normalize(S * .5 * (vec2(\n            cos(.8 * tm + 9.),\n            cos(.9 * tm + 3.)\n        ) + 1.) + B - r.b);\n    ivec2 cells[CMAX];\n    vec2 Ixs[XMAX], Iys[YMAX];\n    \n    ivec2 uvcell = ivec2(floor((uv - B) / S));\n    \n    ivec2 target = grid(\n        r,\n        B,\n        S,\n        XY,\n        cells,\n        Ixs,\n        Iys,\n        cnum,\n        xnum,\n        ynum\n    );\n    \n    float circle = 1. - step(.1, length(mod(uv - B, S) - S * .5));\n    vec3 color = (\n        all(equal(target, uvcell)) ?\n        vec3(1., 0., 0.) :\n        vec3(0., 0., 1.)\n    ) * circle;\n    \n    float grid = step(.48, maxc(abs(fract((uv - B) / S) - .5)));\n    color = mix(color, vec3(1.), grid);\n    \n    float inner = prode(step(vec2(0.), uv - B)) *\n        prode(1. - step(vec2(XY) * S, uv - B));\n    color = mix(vec3(0.), color, inner);\n    \n    vec3 n = normalize(cross(vec3(0., 0., 1.), vec3(r.d, 0.)));\n    float p = abs(dot(uv - r.b, n.xy));\n    float l = dot(uv - r.b, r.d);\n    float line = 1. - step(.01, p);\n    color = mix(color, vec3(1., 1., 0.), line);\n    float arrow = (1. - step(.025, p)) *\n        (1. - step(.95, l)) *\n        step(0., l);\n    arrow = max(arrow, step(.9, l) * (1. -step(1., p + l)));\n    color = mix(color, vec3(1., .5, 0.), arrow);\n    \n    float start = 1. - step(.05, length(uv - r.b));\n    color = mix(color, vec3(1., 0., 0.), start);\n    \n    for(int k = 0; k < CMAX; k++)\n        if(k < cnum) {\n            float icell = all(equal(cells[k], uvcell)) ? 1. : 0.;\n            float bg = float(k) / float(cnum);\n            color = mix(\n                vec3(bg, 1., 1.),\n                color,\n                clamp(step(.1, length(color)) + 1. - icell, 0., 1.)\n            );\n        }\n    for(int i = 0; i < X; i++)\n        if(i < xnum) {\n            float xdot = 1. - step(.05, length(uv - Ixs[i]));\n            float bg = float(i) / float(xnum);\n            color = mix(color, vec3(bg, 1., bg), xdot);\n        }\n    for(int j = 0; j < Y; j++)\n        if(j < ynum) {\n            float ydot = 1. - step(.05, length(uv - Iys[j]));\n            float bg = float(j) / float(ynum);\n            color = mix(color, vec3(1., bg, 1.), ydot);\n        }\n    \n    fragColor = vec4(color, 1.);\n    \n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI  3.141592653589793238462643383279\n#define PI2 6.283185307179586476925286766559\n\nfloat map(vec2 uv, mat2 q, vec2 l) {\n    return sin(2.0 * pow(dot(q * uv + l, uv), 6.0 / 11.0));\n}\nfloat map(vec3 uv, mat3 q, vec3 l) {\n    return sin(2.0 * pow(dot(q * uv + l, uv), 6.0 / 11.0));\n}\nfloat map(vec4 uv, mat4 q, vec4 l) {\n    return sin(2.0 * pow(dot(q * uv + l, uv), 6.0 / 11.0));\n}\n\nstruct RSet2 {\n    mat2 q;\n    vec2 l;\n    vec4 r;\n};\n    RSet2 rset2() {\n        return RSet2(\n            mat2(1.0),\n            vec2(0.0),\n            vec4(0.0)\n        );\n    }\nstruct RSet3 {\n    mat3 q;\n    vec3 l;\n    vec4 r;\n};\n    RSet3 rset3() {\n        return RSet3(\n            mat3(1.0),\n            vec3(0.0),\n            vec4(0.0)\n        );\n    }\nstruct RSet4 {\n    mat4 q;\n    vec4 l;\n    vec4 r;\n};\n    RSet4 rset4() {\n        return RSet4(\n            mat4(1.0),\n            vec4(0.0),\n            vec4(0.0)\n        );\n    }\nstruct RDoublet2 {\n    RSet2 a;\n    RSet2 b;\n};\n    RDoublet2 rdoublet2() {\n        return RDoublet2(rset2(), rset2());\n    }\nstruct RDoublet3 {\n    RSet3 a;\n    RSet3 b;\n};\n    RDoublet3 rdoublet3() {\n        return RDoublet3(rset3(), rset3());\n    }\nstruct RDoublet4 {\n    RSet4 a;\n    RSet4 b;\n};\n    RDoublet4 rdoublet4() {\n        return RDoublet4(rset4(), rset4());\n    }\nstruct RTriplet2 {\n    RSet2 a;\n    RSet2 b;\n    RSet2 c;\n};\n    RTriplet2 rtriplet2() {\n        return RTriplet2(rset2(), rset2(), rset2());\n    }\nstruct RTriplet3 {\n    RSet3 a;\n    RSet3 b;\n    RSet3 c;\n};\n    RTriplet3 rtriplet3() {\n        return RTriplet3(rset3(), rset3(), rset3());\n    }\nstruct RTriplet4 {\n    RSet4 a;\n    RSet4 b;\n    RSet4 c;\n};\n    RTriplet4 rtriplet4() {\n        return RTriplet4(rset4(), rset4(), rset4());\n    }\n\nconst RSet4 rs1 = RSet4(mat4(\n    7.3220e-1,   2.6310e-1,   1.4850e-1,   7.6960e-1,\n    2.6740e-1,   1.0910e+0,   6.7950e-1,   4.9680e-1,\n    8.1250e-1,   4.2080e-1,   6.4640e-1,   7.9180e-1,\n    6.1310e-1,   2.0290e-1,   9.1990e-1,   7.1260e-1\n) * 0.5 + 0.85, vec4(\n    6.8440e-1,   5.7020e-1,   3.5730e-1,   7.2590e-1\n) * 0.55 + 0.95, vec4(\n    3.3540e-1,   7.2490e-1,   6.9690e-1,   5.2740e-1\n) * vec4(400, 20, 80, 100) + vec4(1200, 20, 120, 300));\nconst RSet4 rs2 = RSet4(mat4(\n    4.4400e-1,   6.7810e-1,   8.0430e-1,   1.0410e-1,\n    3.2070e-1,   4.9350e-2,   4.9570e-1,   5.2650e-1,\n    4.4050e-1,   3.9120e-1,   9.4240e-1,   3.1780e-1,\n    1.3450e-1,   3.5410e-1,   7.3850e-1,   1.1920e+0\n) * 0.5 + 0.85, vec4(\n    4.9660e-1,   9.6230e-1,   7.0430e-1,   9.7450e-1\n) * 0.55 + 0.95, vec4(\n    2.7730e-2,   5.1710e-1,   3.3970e-1,   1.0300e-1\n) * vec4(400, 20, 80, 100) + vec4(1200, 20, 120, 300));\nconst RSet4 rs3 = RSet4(mat4(\n    6.0970e-1,   4.2360e-1,   6.5270e-1,   5.9520e-1,\n    3.7520e-1,   4.3880e-1,   9.5880e-3,   1.0380e+0,\n    5.1200e-1,   3.6450e-1,   6.3090e-1,   8.0340e-1,\n    5.4470e-1,   9.0890e-1,   7.6810e-1,   5.9460e-1\n) * 0.5 + 0.85, vec4(\n    6.5350e-1,   5.0250e-1,   1.5460e-1,   1.0800e-1\n) * 0.55 + 0.95, vec4(\n    4.4190e-1,   7.6040e-1,   7.7920e-1,   3.7080e-1\n) * vec4(400, 20, 80, 100) + vec4(1200, 20, 120, 300));\nconst RSet3 rs1_3 = RSet3(mat3(rs1.q), vec3(rs1.l), rs1.r);\nconst RSet3 rs2_3 = RSet3(mat3(rs2.q), vec3(rs2.l), rs2.r);\nconst RSet3 rs3_3 = RSet3(mat3(rs3.q), vec3(rs3.l), rs3.r);\nconst RTriplet3 RT = RTriplet3(rs1_3, rs2_3, rs3_3);\n\nfloat randSin(float x, vec4 ss) {return fract(sin(x * ss.x + ss.y) * ss.z + ss.z);}\nvec2  randSin(vec2  x, vec4 ss) {return fract(sin(x * ss.x + ss.y) * ss.z + ss.z);}\nvec3  randSin(vec3  x, vec4 ss) {return fract(sin(x * ss.x + ss.y) * ss.z + ss.z);}\nvec4  randSin(vec4  x, vec4 ss) {return fract(sin(x * ss.x + ss.y) * ss.z + ss.z);}\n#define RAND randSin\n\nfloat rmap(vec2 uv, RSet2 rs) {\n    return RAND(map(uv, rs.q, rs.l), rs.r);\n}\nfloat rmap(vec3 uv, RSet3 rs) {\n    return RAND(map(uv, rs.q, rs.l), rs.r);\n}\nfloat rmap(vec4 uv, RSet4 rs) {\n    return RAND(map(uv, rs.q, rs.l), rs.r);\n}\n\nvec2 rvec2(vec2 uv, RSet2 r1, RSet2 r2) {\n    return vec2(rmap(uv, r1), rmap(uv, r2));\n}\nvec2 rvec2(vec3 uv, RSet3 r1, RSet3 r2) {\n    return vec2(rmap(uv, r1), rmap(uv, r2));\n}\nvec2 rvec2(vec4 uv, RSet4 r1, RSet4 r2) {\n    return vec2(rmap(uv, r1), rmap(uv, r2));\n}\n\nvec3 rvec3(vec2 uv, RSet2 r1, RSet2 r2, RSet2 r3) {\n    return vec3(rmap(uv, r1), rmap(uv, r2), rmap(uv, r3));\n}\nvec3 rvec3(vec3 uv, RSet3 r1, RSet3 r2, RSet3 r3) {\n    return vec3(rmap(uv, r1), rmap(uv, r2), rmap(uv, r3));\n}\nvec3 rvec3(vec4 uv, RSet4 r1, RSet4 r2, RSet4 r3) {\n    return vec3(rmap(uv, r1), rmap(uv, r2), rmap(uv, r3));\n}\nvec3 rvec3(vec3 uv, RTriplet3 r) {\n    return vec3(rmap(uv, r.a), rmap(uv, r.b), rmap(uv, r.c));\n}\n\nfloat rand1(vec2  v, vec2 d, vec4 s) {return RAND( dot(d, RAND(v, s)), s);}\nfloat rand1(vec3  v, vec3 d, vec4 s) {return RAND( dot(d, RAND(v, s)), s);}\nfloat rand1(vec4  v, vec4 d, vec4 s) {return RAND( dot(d, RAND(v, s)), s);}\nvec2  rand2(vec2  v, mat2 d, vec4 s) {return RAND( d * RAND(v, s), s);}\nvec2  rand2(vec4  v, mat4 d, vec4 s) {return RAND( d * RAND(v, s), s).xy;}\nvec3  rand3(vec3  v, mat3 d, vec4 s) {return RAND( d * RAND(v, s), s);}\nvec4  rand4(vec4  v, mat4 d, vec4 s) {return RAND( d * RAND(v, s), s);}","name":"Common","description":"","type":"common"}]}