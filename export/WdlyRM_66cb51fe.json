{"ver":"0.1","info":{"id":"WdlyRM","date":"1584405547","viewed":427,"name":"Truchet Planet","username":"NivBehar","description":"2D truchet effect on a raymarched scene","likes":25,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","torus","truchet","hexagons"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//to do:\n\n// mode = 0. for a convenient environment to develop\n// mode = 1. for a regular environment\n# define mode 1.\n\n# define MaxSteps 100\n# define MaxDist 20.\n# define time iTime\nfloat PI = acos(-1.); //3.141592654;\nvec2 UVPIMUL = vec2(2., 1.)*2.;\nvec2 UVPIADD = vec2(0., 0.);   \nvec2 UVMUL = vec2(7., 6.93);\nvec2 UVADD() { return vec2(time*0., 0.); }\n\nfloat camSpeed() {return mode*.3*time;}\nfloat pipeSpeed() {return 0.*15.*time;}\nfloat Hash21(vec2 p)\n{\n    vec3 a = fract(p.xyx*vec3(123.34, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    return fract(a.y*a.z*a.x);\n}\n// ---------------------------------------------------------------------------\n// Hexagon Dist by BigWings\nfloat HexDist(vec2 p) {\n\tp = abs(p);\n    \n    float c = dot(p, normalize(vec2(1.,1.73)));\n    c = max(c, p.x);\n    \n    return c;\n}\n// Hash function by BigWings\nvec2 N22(vec2 p)\n{\n    vec3 a = fract(p.xyx*vec3(123.34, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    return fract(vec2(a.x*a.y, a.y*a.z));\n}\n// Hexagon Coords by BigWings\nvec4 HexCoords(vec2 UV) \n{\n    vec2 r = vec2(1., sqrt(3.));\n    vec2 h = r*.5;\n    \n    vec2 a = mod(UV, r)-h;\n    vec2 b = mod(UV-h, r)-h;\n    \n    vec2 gv = dot(a, a) < dot(b,b) ? a : b;\n    \n    float x = atan(gv.x, gv.y);\n    float y = .5-HexDist(gv);\n    vec2 id = UV - gv;\n    return vec4(x, y, id.x,id.y);\n}\nvec3 Hive(vec2 UV, float a)\n{\n    vec3 col = vec3(0);\n    vec4 hc = HexCoords(UV);\n    float c = smoothstep(0.08, 0.11, hc.y); // inside each hexagon (without the edges)\n    \n    // waves based on hexagon's ID\n    //float b1 = 0.5 + 0.43*sin(hc.z*5. + hc.w*3. + 4.*time);\n    float b1 = 0.5 + 0.43*sin(hc.z*24. + hc.w*3.*34. + 4.*time);\n    // Spirals on each hexagon\n    float b2 = 0.5 + 0.5*cos(hc.x*10. + hc.y*45. + 8.*time);\n    \n    //vec4 ehc = HexCoords((hc.xz+0.1*vec2(0., time))*3.*vec2(2.0693,2.5) + 100. + vec2(4.,0.));\n    //float hexagons = smoothstep(0.,0.01, ehc.y)*mod(ehc.z,2.)*mod(ehc.w,2.);\n    //float b3 = b1*(1.-hexagons);\n\n    float everyOtherTile = mod(floor(hc.z),2.);\n\n    float edges = 1.-c;\n    float eSquares = cos(hc.y*20. + time)*sin(hc.x*20. + time); // edges squares\n    eSquares = smoothstep(0.,0.01,eSquares);\n    float b4 = edges * eSquares; \n\n    // bottom color\n    vec3 col1 = b2*c*vec3(0.4274,0.847,0.8941) // azur color for the inverse of the waves\n          + 2.*b1*c*vec3(0.4078,0.1725,0.0705)  // brown color for the waves\n          + 5.*vec3(b1,0,(1.-b1))*c*0.2          // add some rg colors to the waves and to the inverse of them\n          + b4*2.*vec3(0.8431,0.7607,0.5019);   // brown-ish color for the edges of each hexagon\n    // top color\n    vec3 col2 = b2*(1.-b1)*c*vec3(0.4745,0.3705,0.9039) //  purple color for the inverse of the waves\n          + b1*c*vec3(0.8431,0.7607,0.5019)  // brown color for the waves\n          + vec3(b1,0,(1.-b1))*c*0.08          // add some rg colors to the waves and to the inverse of them\n          + b4*1.3;   // white color for the edges of each hexagon\n    \n    col = mix(col1,col2, a);\n    \n    //vec3 test = vec3(hc.zw*0.005,0.);//everyOtherTile;\n    \n    return col;//vec3(edges);\n}\n// ---------------------------------------------------------------------------\nfloat torusRipples(vec2 torusUVPI)\n{\n\treturn 0.5+0.5*sin(torusUVPI.x * 150. + pipeSpeed());\n}\n// ---------------------------------------------------------------------------\nvec2 GetTorusUV(vec3 p, vec2 r, float rot, float checker)\n{\n    if(rot == 1.)\n        p = RotZ(p, PI);\n    //float checker2 = rot == 1.? 1. : 0.;\n    float x = atan(p.x, p.z)/(PI*0.5);\n    float y = atan(length(p.xz)-r.x, p.y)/PI*0.5 + 0.5;\n    //if(rot == 1.)\n    //    y = 1. - y;//0.5;\n    return vec2(x,y);    \n}\nvec2 GetTorusUVPI(vec3 p, vec2 r, float rot, float checker)\n{\n    if(rot == 1.)\n        p = RotZ(p, PI);\n    float x = atan(p.x, p.z);\n    float y = atan(length(p.xz)-r.x, p.y);\n    //if(rot == 1.)\n    //    y += PI;\n    return vec2(x,y);    \n}\n// ---------------------------------------------------------------------------\nfloat sdTorus(vec3 p, vec2 r, float rot, float checker, vec2 torusUV)\n{\n    //vec2 flag = torusFlag(p, r, rot, checker);\n    //vec2 torusUV = GetTorusUV(p, r, rot, checker);\n    //float ripples =  + 0.004*torusRipples(torusUVPI);\n    float torusDist = length(vec2(length(p.xz) - r.x, p.y) ) - r.y;\n    vec4 h = HexCoords(torusUV);\n    float hive = 0.015*smoothstep(0.,0.1,h.y) - 0.015*smoothstep(0.1,0.2,h.y);\n    \n    float hiveTorus = torusDist + hive;\n    float holesTorus = max(-hiveTorus,torusDist);\n    return hiveTorus*0.6;\n}\n// ---------------------------------------------------------------------------\nvec3 spherePos() {\n    return vec3(0.,1.2 + 0.3*sin(time),0.);\n}\n// ---------------------------------------------------------------------------\nfloat Hash31(vec3 p)\n{\n    vec3 a = fract(p*vec3(123.34, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    return (a.x*a.y*a.z);\n}\n// ---------------------------------------------------------------------------\nfloat sdBox2(vec3 p, vec3 s, float speed) \n{\n  vec3 a = vec3(0.05*sin(p.y*p.z*3. + speed), 0.,0.);\n  vec3 q = abs(p + a.xyy) - s - s*0.5*a.xyx;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n// ---------------------------------------------------------------------------\nfloat GetWaves(vec3 p)\n{\n    float waves =  0.05*sin(p.z*1.76+ 2.12*p.x)*cos(p.z + p.x*3.321) \n        \t\t   + 0.1*sin(p.x*2.571 + p.z*2.512)\n                   + (0.5 + 0.5*sin(p.x*1. + p.z*4.))*0.1*cos(cos(p.z*2. + p.x*4.142)*sin(p.z*1.123 + p.x*3.13))\n        \t\t   + 0.1*sin(sin(0.*p.x*4. + p.z)*cos(p.x*2.22 + p.z*4.193) + p.x*2.)\n        \t\t   + 0.2*sin(p.z*0.385 + p.x*0.941 + 0.2*cos(p.x*5.));\n    return waves;\n}\n\nvec3 GetTorusCol(vec2 torUVPI, vec2 torUV, vec2 ID)\n{\n    vec3 tex = texture(iChannel2, torUV + time*0.6).xyz;\n    \n    vec3 torCol;\n    \n    float ripples = torusRipples(torUVPI);\n    torCol += vec3(1.,0.7,0.6)*ripples*tex; // low brown flow\n    \n    float waves = 0.5+0.5*sin(torUVPI.x*2. + 3.*time);\n    waves = smoothstep(0.3, 0., waves);\n    vec3 wavesCol = vec3(3.8, 0.87, 2. + 1.5*sin(time*5.)) * tex*tex;\n    wavesCol *= 2.;\n    torCol += waves*wavesCol; // strong flow\n    \n    float lines = 0.5+0.5*sin(torUVPI.y*7. + 0.*10.*time);\n    lines = smoothstep(0.4, 0., lines);\n    vec3 linesCol = vec3(0., 3.4, 10.66);\n    float ripples2 = 0.5 + 0.5*sin(torUVPI.x*30. + 10.*time);\n    linesCol = ripples2*lines*(linesCol);;\n    linesCol *= 3.5 + 3.3*sin(time*7.);\n    torCol += linesCol;\n    \n    //return waves*wavesCol;\n    //return  vec3(1.,0.7,0.6)*ripples*tex;\n    return torCol;\n}\n// ---------------------------------------------------------------------------\nvec4 Truchet(vec3 p)\n{\n    //vec3 p_temp = p;\n    vec2 ID = floor(p.xz);\n    float hash = Hash21(ID);\n    float checker = mod(ID.x + ID.y, 2.)*2. -1.;\n    vec2 torusRad = vec2(0.5, 0.15);\n    float rot = -1.;\n    if(hash < 0.5)\n    {\n        p = RotZ(p, PI);\n        rot = 1.;\n    }\n\tvec3 truchetBoxPos = p - vec3(0.5, 0., 0.5);\n    truchetBoxPos.x = fract(truchetBoxPos.x + 0.5) - 0.5;\n    truchetBoxPos.z = fract(truchetBoxPos.z + 0.5) - 0.5;\n    \n    \n    vec3 torus1Pos = truchetBoxPos - vec3(0.5, 0., 0.5);\n    //float torusUVScale = 1.;\n    vec2 torus1UV = GetTorusUV(torus1Pos, torusRad, rot, checker);\n    torus1UV *= checker * rot * UVMUL;\n    torus1UV += UVADD();\n    \n    vec2 torus1UVPI = GetTorusUVPI(torus1Pos, torusRad, rot, checker);\n    torus1UVPI *= checker * rot * UVPIMUL;\n    torus1UVPI += UVPIADD;\n    vec3 hive1 = Hive(torus1UV, 0.);\n    vec3 torus1Col = hive1;//GetTorusCol(torus1UVPI, torus1UV, ID);\n    //torus1Col.x = torus1UV.x;\n    //torus1Col = texture(iChannel0, torus1UV + time*0.1).xyz;\n    //torus1Col = vec3(smoothstep(0.,0.1,sin(torus1UVPI.x + time*4.)*cos(torus1UVPI.y + time*4.)));\n\tvec4 torus1Dist = vec4(torus1Col, sdTorus(torus1Pos, torusRad, rot, checker, torus1UV));\n    \n    vec3 torus2Pos = truchetBoxPos + vec3(0.5, 0., 0.5);\n    vec2 torus2UV = GetTorusUV(torus2Pos, torusRad, rot, checker);\n    torus2UV *= checker * rot * UVMUL;\n    torus2UV += UVADD();\n    \n\tvec2 torus2UVPI = GetTorusUVPI(torus2Pos, torusRad, rot, checker);\n    torus2UVPI *= checker * rot * UVPIMUL;\n    torus2UVPI += UVPIADD;\n    vec3 hive2 = Hive(torus2UV, 0.);\n    vec3 torus2Col = hive2;//GetTorusCol(torus2UVPI, torus2UV, ID);\n    //torus2Col.x = torus2UV.x;\n    //torus2Col = texture(iChannel0, torus2UV + time*0.1).xyz;\n    //torus2Col = vec3(smoothstep(0.,0.1,sin(torus2UVPI.x + time*4.)*cos(torus2UVPI.y + time*4.)));\n    vec4 torus2Dist = vec4(torus2Col, sdTorus(torus2Pos, torusRad, rot, checker, torus2UV));\n    \n    vec4 torusDist = min2(torus1Dist, torus2Dist);\n\n    return torusDist;\n}\n// ---------------------------------------------------------------------------\nvec4 GetDist(vec3 p) // return vec4(Object color, min Distance)\n{    \n    p = RotZ(p, sin(p.x*0.025 + PI));\n    vec3 p2 = p;\n\tif(p.y < 0.)\n    p.y = fract(p.y-0.5)-0.5;\n    float ID = floor(p2.y-0.5);\n    float h = fract(sin(ID*241.42)*cos(ID*841.24));\n\tif(h < 0.5)\n        p.xz += ID*123.;\n    \n\tvec4 res = Truchet(p - vec3(0., 0., 0.));\n    //res.w = -max(p2.y - 1., -res.w);\n    \n    return res;\n}\n// ---------------------------------------------------------------------------\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p).w;\n    vec2 e = vec2(.01, 0.);\n \n    vec3 n = d-vec3(GetDist(p-e.xyy).w, \n                        GetDist(p-e.yxy).w, \n                        GetDist(p-e.yyx).w);\n    return normalize(n);\n}\n// ---------------------------------------------------------------------------\n// fog by iq\nvec3 applyFog( vec3  rgb, float distance, float strength, vec3 fogColor)\n{\n    float fogAmount = 1.0 - exp( -distance*strength );\n    return mix( rgb, fogColor, fogAmount );\n}\n// ---------------------------------------------------------------------------\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayDir,   // camera to point vector\n               in vec3  sunDir,   // sun light direction\n               in float strength,\n               in vec2 mou)  \n{\n    float fogAmount = 1.0 - exp( -distance*strength );\n    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n    vec3  fogColor  = mix( mix(vec3(0.1,0.0,0.3), vec3(0.7,0.4,1.), sunDir.y),\n                           vec3(1.2,1.,0.5),\n                           pow(sunAmount,10.) );\n    fogColor = mix(fogColor, vec3(0.3,0.5,1.), rayDir.y + 0.2);\n    fogColor += -rayDir.y*vec3(1.5,1.3,0.3);\n    fogColor -= vec3(1.)*clamp(abs(rayDir.x), 0., 1.);\n    fogColor += 0.25*(1. - vec3(1.)*clamp(abs((rayDir.y*15. * rayDir.x))*1.5, 0., 1.)) * smoothstep(-0.5, 0.05, rayDir.y);\n    rayDir = RotZ(rayDir, 0.5*PI);\n    rayDir = abs(rayDir);\n    //fogColor = max(vec3(-0.2), fogColor);\n    fogColor += 0.25*(1. - vec3(1.)*clamp(abs((rayDir.y*15. * rayDir.x))*1.5, 0., 1.)) * smoothstep(-0.05, 0.05, rayDir.y);\n    \n    return mix( rgb, fogColor, fogAmount );\n}\n// ---------------------------------------------------------------------------\nvec4 RayMarch(vec3 ro, vec3 rd, int steps) \n{\n    vec3 result= vec3(1.,1.,0.)*0.;\n    vec4 dS;\n    float dO;;\n    vec3 p;  \n    for(int i = 0; i<steps; i++)\n    {\n        p = ro + rd * dO;\n        if(dO > MaxDist) {\n            result = vec3(0.);\n            break;\n        }\n        dS = GetDist(p);\n        if(abs(dS.w) < 0.0001) {\n            result = dS.xyz;\n            break; \n        }\n        dO += dS.w;\n    }     \n    return vec4(result.xyz,dO);\n}\n// ---------------------------------------------------------------------------\nfloat softShadow( in vec3 ro, in vec3 rd, float mint, float maxt, float w )\n{\n    float s = 1.0;\n    float t = mint;\n    for( float i=0.; i<maxt; i++ )\n    {\n        float h = GetDist(ro + rd*t).w;\n        s = min( s, 0.5+0.5*h/(w*t) );\n        if( s<0.0 ) break;\n        t += h;\n    }\n    s = max(s,0.0);\n    return s*s*(3.0-2.0*s); // smoothstep\n}\n// ---------------------------------------------------------------------------\nfloat GetLight(vec3 p, vec3 lightPos, float lightPower, float shadowStrength, int steps)\n{\n    vec3 l = normalize(lightPos - 0.*p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l*lightPower), 0., 1.);\n    //float d = RayMarch(p + n*0.001, l, steps).w;\n    //if(d < length(lightPos-p*0.)) {dif *= shadowStrength;}\n    float sunShadow = softShadow(p + n*0.001, lightPos, 0., 100., 0.1);\n    return clamp(0.5 + 0.5*dif, 0., 1.)*clamp((0.2 + 0.8*sunShadow), 0., 1.);\n}\n// ---------------------------------------------------------------------------\nfloat specularReflection(vec3 p, vec3 rd, vec3 lightPos, float intensity, float shininessVal)\n{\n    vec3 N = GetNormal(p);\n    vec3 L = normalize(lightPos - 0.*p);\n    float lambertian = max(dot(L, N), 0.0);\n    float specular = 0.;\n  \tif(lambertian > 0.0) {\n        vec3 R = reflect(-L, N);      // Reflected light vector\n        vec3 V = normalize(-rd); // Vector to viewer\n        // Compute the specular term\n        float specAngle = max(dot(R, V), 0.0);\n        specular = pow(specAngle, shininessVal);\n  \t}\n    return specular * intensity;\n}\n// ---------------------------------------------------------------------------\n// calcOcclusion by iq\nfloat calcOcclusion(vec3 p)\n{\n    vec3 n = GetNormal(p);\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = p + h*n;\n        float d = GetDist(opos).w;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n// ---------------------------------------------------------------------------\nvoid cam(vec2 mou, inout vec3 ro, inout vec3 lookat)\n{\n    ro = vec3(0.7, 1., 0.7);\n    if(time < 10.)\n        ro.y = 7. + 6.*sin(time/20.*PI + PI);\n    ro.z -= time*2.;\n    ro.x += sin(time*0.2)*4.;\n\tlookat = ro + vec3(0.5*sin(time*0.2287),  -0.2 + 0.4*sin(time*0.3752), -1.);\n\n}\n// ---------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    \n    vec3 col = vec3(0.,0.,0.);\n \n    \n\n    float zoom = 1.;\n    \n    vec2 mou = 5.*(iMouse.xy-.5*iResolution.xy)/iResolution.y;\n\n    vec3 ro;\n    vec3 lookat;\n\tcam(mou, ro, lookat);\n    \n    //lookat = ro + vec3(0.5*sin(time*0.2287),  -0.2 + 0.4*sin(time*0.3752), -1.);\n    \n    if(mode == 0.) {\n    ro = vec3(0.01, 3., -1.);\n    //ro.xz *= Rot(mou.x);\n    ro.x += mou.x*5.;\n    ro.y += mou.y*5.;\n    lookat = vec3(0.01, 0., -11.1);\n    }\n\n    vec3 F = normalize(lookat-ro); // Forward\n    vec3 R = normalize(cross(vec3(0., 1., 0.), F)); //Right\n    vec3 U = cross(F, R); //Up\n\n    vec3 C = ro + F*zoom;\n    vec3 I = C + uv.x*R + uv.y*U;\n    vec3 rd = normalize(I-ro);\n\n    vec4 d = RayMarch(ro,rd, MaxSteps); \n    vec3 p = ro + rd*d.w;\n    \n    //vec3 lightPos = normalize(vec3(0.,max(0.2,1. - 0.02*time) + 0.*mou.y,-1.));// + ro;//vec3(1.) + ro;//ro + 0.1*normalize(lookat);\n\tvec3 lightPos = vec3(0.,0.3,-1.);\n    //if(mode == 0.)\n    //    lightPos = ro;\n    \n    float dif = GetLight(p, lightPos, 1., 0.5, MaxSteps);\n    vec3 n = GetNormal(p);\n    //float sunShadow = softShadow(p + n*0.001, lightPos, 0., 100., 0.1);\n    float occ = calcOcclusion(p);\n    float spRefSun = specularReflection(p, rd, lightPos, 1., 7.);\n    float spRefSky = specularReflection(p, rd, vec3(0., 5., 0.), 1., 5.);\n    float skyDif = clamp(dot(vec3(0.,1.,0), n), 0., 1.);\n    float groundDif = clamp(dot(vec3(0.,-1.,0.), n), 0., 1.);\n    \n\tcol = d.xyz * dif * occ\n          + spRefSun * vec3(1.,1., 0.9)\n          + skyDif * vec3(0.1, 0.2, 0.5)\n          + spRefSky*vec3(0.1,0.2,1.)\n    \t  + groundDif * vec3(0.5,0.4,0.1);\n\n    //col = applyFog(col, d.w, 0.15, vec3(0.6,0.5,0.4));\n    \n    rd = RotZ(rd, sin(rd.x + PI));\n    col = applyFog(col, d.w, rd, normalize(lightPos), 0.21, mou);\n    //col = pow3(col,1.3);\n    //col = vec3(groundDif);\n   //col = skyDif * vec3(0.1, 0.2, 0.5);\n    fragColor = vec4(col,0.1);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//# define time iTime\n//# define PI 3.141592654\nvec3 pow3(vec3 a, float b)\n{\n    return vec3(pow(a.x,b), pow(a.y,b), pow(a.z,b));\n}\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nvec3 RotX (vec3 p, float speed)\n{   \n    float ss = sin(speed), cc = cos(speed);\n    return vec3(p.x, p.y*cc + p.z*-ss,  p.y*ss + p.z*cc);\n}\nvec3 RotY (vec3 p, float speed)\n{   \n    float ss = sin(speed), cc = cos(speed);\n    return vec3(p.x*cc + p.z*ss, p.y, p.x*-ss + p.z*cc);\n}\nvec3 RotZ (vec3 p, float speed)\n{   \n    float ss = sin(speed), cc = cos(speed);\n    return vec3(p.x*cc  + p.y*-ss, p.x*ss + p.y*cc, p.z);\n}\nfloat opUS( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    float dist = mix( d2, d1, h ) - k*h*(1.0-h); \n \treturn dist;\n}\nvec4 opUS( vec4 d1, vec4 d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2.w-d1.w)/k, 0.0, 1.0 );\n    vec3 color = mix(d2.xyz, d1.xyz, h);\n    float dist = mix( d2.w, d1.w, h ) - k*h*(1.0-h); \n \treturn vec4(color, dist);\n}\nfloat opSS( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\nfloat opSI( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\nvec4 min2(vec4 d1, vec4 d2)\n{\n    return min(d1.w,d2.w) == d1.w ? d1 : d2;\n}\nfloat sdBox(vec3 p, vec3 s) \n{\n  vec3 q = abs(p) - s;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdRoundBox( vec3 p, vec3 s, float r )\n{\n  vec3 q = abs(p) - s;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\nfloat sdCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\nvec2 GetSphereUV(vec3 p, float r)\n{\n    vec3 n = normalize(p);\n    float x = atan(n.x, n.z);///(2.*PI) + 0.5;\n    float y = n.y;//0.5 + 0.5*n.y;\n    return vec2(x,y);\n}\nfloat sdSphere( vec3 p, float r) {\n    float d =  length(p) - r;\n    return d;\n}","name":"Common","description":"","type":"common"}]}