{"ver":"0.1","info":{"id":"DsGBRd","date":"1698507278","viewed":90,"name":"Library of noise made of isoline","username":"Adegmood","description":"Demonstration of popular noises using isoline.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","3d","fractal","noise","simple","gradient","cellular","isoline"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec2 tiling = vec2(20.0, 12.0);\nconst vec2 offset = vec2(0.0, 0.0);\n\nvec2 transform(vec2 uv, vec2 tiling, vec2 offset)\n{\n    return uv * tiling + offset;\n}\nvec2 transform(vec2 uv)\n{\n    return transform(uv, tiling, offset);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float speed = iTime * 0.5;\n    float view = 0.0;\n    vec2 tile2D = vec2(transform(uv));\n    vec3 tile3D = vec3(tile2D, speed);\n    \n    tile2D.x += speed;\n    \n    switch (int(fragCoord.y / iResolution.y * 4.0))\n    {\n        case 0:\n        {\n            switch (int(fragCoord.x / iResolution.x * 6.0)) \n            {\n                case 0:\n                    view = isoline_form(fractal_form(1, tile2D));\n                    break;\n                case 1:\n                    view = isoline_form(fractal_form(1, tile3D));\n                    break;\n                case 2:\n                    view = isoline_form(fractal_form(2, tile2D));\n                    break;\n                case 3:\n                    view = isoline_form(fractal_form(2, tile3D));\n                    break;\n                case 4:\n                    view = isoline_form(fractal_form(3, tile2D));\n                    break;\n                case 5:\n                    view = isoline_form(fractal_form(3, tile3D));\n                    break;\n            }\n        } break;\n        \n        case 1:\n        {\n            switch (int(fragCoord.x / iResolution.x * 6.0)) \n            {\n                case 0:\n                    view = fractal_form(1, tile2D);\n                    break;\n                case 1:\n                    view = fractal_form(1, tile3D);\n                    break;\n                case 2:\n                    view = fractal_form(2, tile2D);\n                    break;\n                case 3:\n                    view = fractal_form(2, tile3D);\n                    break;\n                case 4:\n                    view = fractal_form(3, tile2D);\n                    break;\n                case 5:\n                    view = fractal_form(3, tile3D);\n                    break;\n            }\n        } break;        \n        \n        case 2:\n        {\n            switch (int(fragCoord.x / iResolution.x * 6.0)) \n            {\n                case 0:\n                    view = isoline_form(simple_noise(tile2D));\n                    break;\n                case 1:\n                    view = isoline_form(simple_noise(tile3D));\n                    break;\n                case 2:\n                    view = isoline_form(cellular_noise(tile2D));\n                    break;\n                case 3:\n                    view = isoline_form(cellular_noise(tile3D));\n                    break;\n                case 4:\n                    view = isoline_form(gradient_noise(tile2D));\n                    break;\n                case 5:\n                    view = isoline_form(gradient_noise(tile3D));\n                    break;\n            }\n        } break;\n        \n        case 3:\n        {\n            switch (int(fragCoord.x / iResolution.x * 6.0)) \n            {\n                case 0:\n                    view = simple_noise(tile2D);\n                    break;\n                case 1:\n                    view = simple_noise(tile3D);\n                    break;\n                case 2:\n                    view = cellular_noise(tile2D);\n                    break;\n                case 3:\n                    view = cellular_noise(tile3D);\n                    break;\n                case 4:\n                    view = gradient_noise(tile2D);\n                    break;\n                case 5:\n                    view = gradient_noise(tile3D);\n                    break;\n            }\n        } break;\n    }\n\n    fragColor = vec4(vec3(view), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const uint max32 = 0xffffffffu;\n\n// taken from https://nullprogram.com/blog/2018/07/31/\nuint hash(uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\n// 1D noise\nfloat hash1(uint seed)\n{\n    return float(hash(seed)) / float(max32);\n}\nfloat hash1(float seed)\n{\n    return hash1(floatBitsToUint(seed));\n}\nfloat hash1(vec2 seed)\n{\n    return hash1(floatBitsToUint(seed.x) ^ floatBitsToUint(seed.y));\n}\nfloat hash1(vec3 seed)\n{\n    return hash1(floatBitsToUint(seed.x) ^ floatBitsToUint(seed.y) ^ floatBitsToUint(seed.z));\n}\nfloat hash1(vec4 seed)\n{\n    return hash1(floatBitsToUint(seed.x) ^ floatBitsToUint(seed.y) ^ floatBitsToUint(seed.z) ^ floatBitsToUint(seed.w));\n}\n\n// 2D noise\nvec2 hash2(uint seed)\n{\n    return vec2(hash1(seed), hash1(seed ^ 0x1u));\n}\nvec2 hash2(float seed)\n{\n    return hash2(floatBitsToUint(seed));\n}\nvec2 hash2(vec2 seed)\n{\n    return hash2(floatBitsToUint(seed.x) ^ floatBitsToUint(seed.y));\n}\nvec2 hash2(vec3 seed)\n{\n    return hash2(floatBitsToUint(seed.x) ^ floatBitsToUint(seed.y) ^ floatBitsToUint(seed.z));\n}\nvec2 hash2(vec4 seed)\n{\n    return hash2(floatBitsToUint(seed.x) ^ floatBitsToUint(seed.y) ^ floatBitsToUint(seed.z) ^ floatBitsToUint(seed.w));\n}\n\n// 3D noise\nvec3 hash3(uint seed)\n{\n    return vec3(hash1(seed), hash1(seed ^ 0x1u), hash1(seed ^ 0x2u));\n}\nvec3 hash3(float seed)\n{\n    return hash3(floatBitsToUint(seed));\n}\nvec3 hash3(vec2 seed)\n{\n    return hash3(floatBitsToUint(seed.x) ^ floatBitsToUint(seed.y));\n}\nvec3 hash3(vec3 seed)\n{\n    return hash3(floatBitsToUint(seed.x) ^ floatBitsToUint(seed.y) ^ floatBitsToUint(seed.z));\n}\nvec3 hash3(vec4 seed)\n{\n    return hash3(floatBitsToUint(seed.x) ^ floatBitsToUint(seed.y) ^ floatBitsToUint(seed.z) ^ floatBitsToUint(seed.w));\n}\n\n// 4D noise\nvec4 hash4(uint seed)\n{\n    return vec4(hash1(seed), hash1(seed ^ 0x1u), hash1(seed ^ 0x2u), hash1(seed ^ 0x3u));\n}\nvec4 hash4(float seed)\n{\n    return hash4(floatBitsToUint(seed));\n}\nvec4 hash4(vec2 seed)\n{\n    return hash4(floatBitsToUint(seed.x) ^ floatBitsToUint(seed.y));\n}\nvec4 hash4(vec3 seed)\n{\n    return hash4(floatBitsToUint(seed.x) ^ floatBitsToUint(seed.y) ^ floatBitsToUint(seed.z));\n}\nvec4 hash4(vec4 seed)\n{\n    return hash4(floatBitsToUint(seed.x) ^ floatBitsToUint(seed.y) ^ floatBitsToUint(seed.z) ^ floatBitsToUint(seed.w));\n}\n\n// 1D-4D normalized direction noise\nfloat hash_norm(float seed)\n{\n    return normalize(hash1(seed) - 0.5);\n}\nvec2 hash_norm(vec2 seed)\n{\n    return normalize(hash2(seed) - 0.5);\n}\nvec3 hash_norm(vec3 seed)\n{\n    return normalize(hash3(seed) - 0.5);\n}\nvec4 hash_norm(vec4 seed)\n{\n    return normalize(hash4(seed) - 0.5);\n}\n\n// simple noise\nfloat simple_noise(vec2 uv)\n{        \n    vec2 cell = floor(uv);\n    vec2 sub = uv - cell;\n    \n    vec2 cube = sub * sub * (3.0 - 2.0 * sub);\n    \n    vec2 c00 = cell + vec2(0.0, 0.0);\n    vec2 c10 = cell + vec2(1.0, 0.0);\n    vec2 c01 = cell + vec2(0.0, 1.0);\n    vec2 c11 = cell + vec2(1.0, 1.0);\n    \n    return mix(mix(hash1(c00), hash1(c10), cube.x),\n               mix(hash1(c01), hash1(c11), cube.x), cube.y);\n}\nfloat simple_noise(vec3 uvw)\n{\n    vec3 cell = floor(uvw);\n    vec3 sub = uvw - cell;\n    \n    vec3 cube = sub * sub * (3.0 - 2.0 * sub);\n    \n    vec3 c000 = cell + vec3(0.0, 0.0, 0.0);\n    vec3 c100 = cell + vec3(1.0, 0.0, 0.0);\n    vec3 c010 = cell + vec3(0.0, 1.0, 0.0);\n    vec3 c110 = cell + vec3(1.0, 1.0, 0.0);\n    vec3 c001 = cell + vec3(0.0, 0.0, 1.0);\n    vec3 c101 = cell + vec3(1.0, 0.0, 1.0);\n    vec3 c011 = cell + vec3(0.0, 1.0, 1.0);\n    vec3 c111 = cell + vec3(1.0, 1.0, 1.0);\n\t\n    return mix(mix(mix(hash1(c000), \n                       hash1(c100), cube.x),\n                   mix(hash1(c010), \n                       hash1(c110), cube.x), cube.y),\n               mix(mix(hash1(c001), \n                       hash1(c101), cube.x),\n                   mix(hash1(c011), \n                       hash1(c111), cube.x), cube.y), cube.z);\n}\n\n// cellular noise\nfloat cellular_noise(vec2 uv, bool reverse)\n{\n    vec2 cell = floor(uv);\n    float range_cell = 1.0;\n    \n    for(int x = -1; x <= 1; x++)\n    for(int y = -1; y <= 1; y++)\n    {\n        vec2 nearby_cell = cell + vec2(x, y);\n        vec2 direction = hash2(nearby_cell) + nearby_cell - uv;\n        range_cell = min(range_cell, length(direction));\n    }\n    \n    return 1.0 * float(reverse) + range_cell;\n}\nfloat cellular_noise(vec2 uv)\n{\n    return cellular_noise(uv, false);\n}\nfloat cellular_noise(vec3 uvw, bool reverse)\n{\n    vec3 cell = floor(uvw);\n    float range_cell = 1.0;\n    \n    for(int x = -1; x <= 1; x++)\n    for(int y = -1; y <= 1; y++)\n    for(int z = -1; z <= 1; z++)\n    {\n        vec3 nearby_cell = cell + vec3(x, y, z);\n        vec3 direction = hash3(nearby_cell) + nearby_cell - uvw;\n        range_cell = min(range_cell, length(direction));\n    }\n    \n    return  1.0 * float(reverse) + range_cell;\n}\nfloat cellular_noise(vec3 uvw)\n{\n    return cellular_noise(uvw, false);\n}\n\n// gradient noise\nfloat gradient_noise(vec2 uv, float smooth_range)\n{\n    vec2 cell = floor(uv);\n    vec2 sub = uv - cell;\n    \n    vec2 quint = sub * sub * sub * (sub * (sub * 6.0 - 15.0) + 10.0);\n    \n    float c00 = dot(hash_norm(cell), sub);\n    float c01 = dot(hash_norm(cell + vec2(0.0, 1.0)), sub - vec2(0.0, 1.0));\n    float c10 = dot(hash_norm(cell + vec2(1.0, 0.0)), sub - vec2(1.0, 0.0));\n    float c11 = dot(hash_norm(cell + vec2(1.0, 1.0)), sub - vec2(1.0, 1.0));\n\n    float noise = mix(mix(c00, c01, quint.y),\n                      mix(c10, c11, quint.y), quint.x);\n    \n    return noise * (1.0 - smooth_range) + smooth_range;\n}\nfloat gradient_noise(vec2 uv)\n{\n    return gradient_noise(uv, 0.5);\n}\nfloat gradient_noise(vec3 uvw, float smooth_range)\n{\n    vec3 cell = floor(uvw);\n    vec3 sub = uvw - cell;\n    \n    vec3 quint = sub * sub * sub * (sub * (sub * 6.0 - 15.0) + 10.0);\n    \n    float c000 = dot(hash_norm(cell + vec3(0.0, 0.0, 0.0)), sub - vec3(0.0, 0.0, 0.0));\n    float c100 = dot(hash_norm(cell + vec3(1.0, 0.0, 0.0)), sub - vec3(1.0, 0.0, 0.0));\n    float c010 = dot(hash_norm(cell + vec3(0.0, 1.0, 0.0)), sub - vec3(0.0, 1.0, 0.0));\n    float c110 = dot(hash_norm(cell + vec3(1.0, 1.0, 0.0)), sub - vec3(1.0, 1.0, 0.0));\n    float c001 = dot(hash_norm(cell + vec3(0.0, 0.0, 1.0)), sub - vec3(0.0, 0.0, 1.0));\n    float c101 = dot(hash_norm(cell + vec3(1.0, 0.0, 1.0)), sub - vec3(1.0, 0.0, 1.0));\n    float c011 = dot(hash_norm(cell + vec3(0.0, 1.0, 1.0)), sub - vec3(0.0, 1.0, 1.0));\n    float c111 = dot(hash_norm(cell + vec3(1.0, 1.0, 1.0)), sub - vec3(1.0, 1.0, 1.0));\n    \n    float noise = mix(mix(mix(c000, c100, quint.x),\n                          mix(c010, c110, quint.x), quint.y),\n                      mix(mix(c001, c101, quint.x),\n                          mix(c011, c111, quint.x), quint.y), quint.z);\n    \n    return noise * (1.0 - smooth_range) + smooth_range;\n}\nfloat gradient_noise(vec3 uvw)\n{\n    return gradient_noise(uvw, 0.5);\n}\n\n// noise library: 1-simple, 2-cellular, 3-gradient\nfloat noise_library(int num_noise, vec2 uv)\n{ \n    switch(num_noise)\n    {\n        default: case(1): return simple_noise(uv);\n        case(2): return cellular_noise(uv);\n        case(3): return gradient_noise(uv);\n    }\n}\nfloat noise_library(int num_noise, vec3 uvw)\n{ \n    switch(num_noise)\n    {\n        default: case(1): return simple_noise(uvw);\n        case(2): return cellular_noise(uvw);\n        case(3): return gradient_noise(uvw);\n    }\n}\n\n// isoline noise(form)\nfloat isoline_form(float noise, float wave)\n{\n    return noise * (cos(pow(2.0, wave) * noise));\n}\nfloat isoline_form(float noise)\n{\n    return noise * (cos(noise * 64.0));\n}\n\n// fractal noise(form)\nfloat fractal_form(int num_noise, vec2 uv, float num_octaves, float scale)\n{\n    float noise_sum = 0.0;\n    float weight_sum = 0.0;\n    float weight = 1.0;\n\n    for(float octave = 0.0; octave < num_octaves; octave++)\n    {\n        noise_sum += noise_library(num_noise, uv * pow(2.0, octave) * scale)  * weight;\n        weight_sum += weight;\n        weight *= 0.5;\n    }\n    \n    return noise_sum / weight_sum;\n}\nfloat fractal_form(int num_noise, vec2 uv)\n{\n    return fractal_form(num_noise, uv, 4.0, 0.5); \n}\nfloat fractal_form(int num_noise, vec3 uvw, float num_octaves, float scale)\n{\n    float noise_sum = 0.0;\n    float weight_sum = 0.0;\n    float weight = 1.0;\n\n    for(float octave = 0.0; octave < num_octaves; octave++)\n    {\n        noise_sum += noise_library(num_noise, uvw * pow(2.0, octave) * scale)  * weight;\n        weight_sum += weight;\n        weight *= 0.5;\n    }\n    \n    return noise_sum / weight_sum;\n}\nfloat fractal_form(int num_noise, vec3 uvw)\n{\n    return fractal_form(num_noise, uvw, 4.0, 0.5); \n}","name":"Common","description":"","type":"common"}]}