{"ver":"0.1","info":{"id":"7ttBDj","date":"1663679816","viewed":577,"name":"Torus Knotus Rotatus","username":"panna_pudi","description":"(•̀⌄•́)","likes":49,"published":1,"flags":32,"usePreview":0,"tags":["3d","torus","truchet","conformal","knot","arrow","donut","weave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Torus Knotus Rotatus by Pudi\n// Email: k.a.komissar@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Thanks to Flopine, provod, YX, NuSan, slerpy, Shane, z0rg, Tater, nekos in general\n// BigWings, FabriceNeyret, iq, and Blackle for sharing their knowledge\n//\n// Specifically thanks morimea for giving good references and guiding me\n// and wrighter for hanging out with me on modeling stage.\n//\n// 'Square Truchet Flow' by Shane\n// I actually spoilered myself how to make pretty arrows\n// on truchet by casually browsing shadertoy. And it's super pretty!\n// https://www.shadertoy.com/view/XtfyDX\n//\n// 'Conformal Torus Mapping' by Fabrice\n// It took me some time to ungold this shader and\n// I was surprised it's working for knot variations\n// https://www.shadertoy.com/view/sdd3R4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).rgb;\n    col = pow(col, vec3(1. / 2.2));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float PI = acos(-1.);\nconst float TAU = PI * 2.;\n\n#define AAstep(x0, x) clamp(((x) - (x0)) / (2. * 2. / iResolution.y), 0., 1.)\n\nfloat hash31(vec3 p) {\n    float n = sin(dot(p, vec3(7, 157, 113)));\n    return fract(262144. * n);\n}\nfloat hash21(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nmat2 rot(float a){\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\nfloat trig(vec2 p, float tF, float s) {\n    return max(abs(p.x) * .866025 + tF * p.y * .5, -tF * p.y) - s;\n}\n\nfloat box(float a, float s) {\n    return abs(a) - s;\n}\n\nstruct Res {\n    vec3 col;\n    float contour;\n    float depth;\n};\n\nRes truschet(vec2 p, bool var) {\n    vec2 ip = floor(p);\n    float rng = hash21(ip);\n    p = fract(p) - 0.5;\n    float dir = mod(ip.x + ip.y, 2.) > 0.5 ? 1. : -1.;\n\n    p.y *= rng < 0.5 ? -1. : 1.;\n    p *= p.x > -p.y ? 1. : -1.;\n\n    const float th = 0.3;\n    vec2 cp = p - 0.5;\n    float d = length(cp);\n    d = abs(d - 0.5) - th / 2.;\n\n    float border = max(d - 0.010, -d);\n    border = AAstep(0.015, border);\n\n    float angle = atan(cp.y, cp.x);\n    cp *= rot(-iTime * dir);\n\n    const float aNum = 6.;\n    float a = atan(cp.y, cp.x);\n    float ia = floor(a / TAU * aNum) + .5;\n\n    cp *= rot(-ia * TAU / aNum);\n    cp.x -= 0.5;\n\n    float arrow = box(mod(a - .30 * dir, TAU / aNum) - .5 * TAU / aNum, .35);\n    arrow = max(d + .14, -arrow);\n    arrow = min(arrow, trig(cp, dir, .025));\n    arrow = smoothstep(0., 0.01, arrow);\n\n    float sep = mod(a * dir + d + 0.8, TAU / aNum) - .5 * TAU / aNum;\n    sep = abs(abs(sep) - 0.07) - 0.03;\n    sep = smoothstep(0., .02, sep);\n\n    d = AAstep(0.01, d);\n\n    vec3 col;\n    if (var) {\n        col = vec3(1.2);\n        col = mix(col, vec3(0.13), (1. - sep));\n        col = mix(col, vec3(0.013), 1. - border);\n        col = mix(col, vec3(.5, .05, .05), (1. - arrow) * .95);\n    } else {\n        col = vec3(.1);\n        col = mix(col, vec3(1.4), (1. - sep));\n        col = mix(col, vec3(0.013), 1. - border);\n        col = mix(col, vec3(0.2, 0.4, .9), (1. - arrow));\n    }\n\n    float depth = cos(3. * angle * dir) * .5 + .5;\n    col *= mix(0.0, 1., depth);\n\n    return Res(col * (1. - d), d, depth * (1. - d));\n}\n\nvec3 pattern(vec2 p, vec3 ref_col) {\n    vec3 col = vec3(0.);\n\n    vec2 ip = floor(p);\n    vec2 q = p - ip - 0.5;\n    q.y *= mod(ip.x + ip.y, 2.) > 0.5 ? 1. : -1.;\n    col += (abs(fract((q.x + q.y) * 20. + .5) - .5) * 2. - .5) / 20.;\n    col += ref_col;\n    Res t1 = truschet(p, true);\n    Res t2 = truschet(p - 0.5, false);\n\n   if (t1.depth > t2.depth) {\n        col = mix(t2.col, t1.col, 1. - t1.contour);\n    }\n    if (t2.depth > t1.depth) {\n        col = mix(t1.col, t2.col, 1. - t2.contour);\n    }\n    return col;\n}\n\n// https://www.shadertoy.com/view/7sKGzR\nvec2 polar_smooth_fold(vec2 p, float n, float k) {\n    n *= 0.5;\n    float a = asin(sin(atan(p.x, p.y) * n) / (k + 1.0)) / n;\n    return vec2(sin(a), cos(a)) * length(p);\n}\n\nconst vec2 TORUS = vec2(1.0, 0.33);\nfloat knot(vec3 p) {\n    float time = iTime;\n\n    float f = length(p.xz) - TORUS.x;\n    vec2 tube = vec2(f, p.y);\n    float xz = atan(p.x, p.z);\n\n    tube *= rot(time * 0.25);\n\n    tube *= rot(xz * 1. / 3.);\n    tube = polar_smooth_fold(tube, 3., 0.1);\n    tube.y = (tube.y) - 0.48;\n\n    float w = TORUS.y;\n    return length(tube) - w;\n}\n\nvec4 map(vec3 p) {\n    float t = iTime * smoothstep(5., 10., iTime);\n    p.xy *= rot(t * 0.1);\n    p.zy *= rot(t * 0.2);\n    return vec4(knot(p), p);\n}\n\nvec2 trace(vec3 ro, vec3 rd, out vec3 q) {\n    float t = 0.;\n    for (int i = 0; i < 150; i++) {\n        vec3 pos = ro + rd * t;\n        vec4 res = map(pos);\n        float d = res.x; q = res.yzw;\n        if (abs(d) < 0.0001) { return vec2(t, 1.); }\n        t += d;\n        if (t > 10.) { break; };\n    }\n    return vec2(t, -1.);\n}\n\nvec3 get_norm(vec3 p) {\n    mat3 k = mat3(p,p,p) - mat3(0.001);\n    return normalize(map(p).x - vec3(map(k[0]).x, map(k[1]).x, map(k[2]).x));\n}\n\nmat3 get_cam(vec3 eye, vec3 target) {\n    vec3 zaxis = normalize(target - eye);\n    vec3 xaxis = normalize(cross(zaxis, vec3(0, 1., 0.)));\n    vec3 yaxis = cross(xaxis, zaxis);\n    return mat3(xaxis, yaxis, zaxis);\n}\n\n//  https://iquilezles.org/articles/rmshadows/\nfloat soft_shadow(vec3 ro, vec3 lp, vec3 n, float k) {\n    ro += n * .0015;\n    vec3 rd = lp - ro;\n\n    float shade = 1.;\n    float t = 0.;\n    float end = max(length(rd), .0001);\n    rd /= end;\n\n    for (int i = 0; i < 24; i++) {\n        float d = map(ro + rd * t).x;\n        shade = min(shade, k * d / t);\n        t += clamp(d, .01, .25);\n        if (d < 0. || t > end) break;\n    }\n\n    return max(shade, 0.);\n}\n\n// https://iquilezles.org/articles/multiresaocc/\nfloat calcAO(in vec3 p, in vec3 n) {\n    float sca = 2., occ = 0.;\n    for (int i = 0; i < 5; i++) {\n        float hr = float(i + 1) * .25 / 5.;\n        float d = map(p + n * hr).x;\n        occ += (hr - d) * sca;\n        sca *= .75;\n        if (occ > 1e5) break;\n    }\n\n    return clamp(1. - occ, 0., 1.);\n}\n\nvec3 sky(vec3 rd) {\n    vec3 col = vec3(0.);\n    col += mix(0.5 * vec3(0.75, 0.4, 0.4), 0.9 * vec3(0.25, 0.5, 1.0),\n               0.5 + 0.5 * normalize(rd).y);\n    col += mix(0.9 * vec3(0., 0., 0.), 0.1 * vec3(0., 0., 0.0),\n               0.9 + 0.5 * normalize(-rd).y);\n    col += smoothstep(-0.4, 0.4,\n               dot(rd + vec3(0.0, 0.7, 0.0), normalize(vec3(0.0, -0.2, 0.0)))) *\n           vec3(0.1, 0.0, 0.3) * 1.3;\n    return col * 0.1 + hash31(rd) * 0.02;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(-2.5, 3., 2.5);\n    /* ro.xz *= rot(pc.time); */\n    mat3 cam = get_cam(ro, vec3(0., 0.15, 0.));\n    vec3 rd = cam * normalize(vec3(uv, 1.4));\n\n    vec3 q;\n    vec2 res = trace(ro, rd, q);\n\n    vec3 lp = ro + vec3(.25, .75, -1);\n    float fblend = 0.;\n\n    vec3 col = sky(rd);\n    if (res.y > 0.) {\n        vec3 pos = ro + rd * res.x;\n        vec3 nor = get_norm(pos);\n\n        vec3 ld = lp - pos;\n        float ldist = max(length(ld), .001);\n        ld /= ldist;\n\n        float ao = calcAO(pos, nor);\n        float sh = soft_shadow(pos, lp, nor, 3.);\n\n        float diff = max(dot(nor, ld), 0.);\n        float spec = pow(max(dot(reflect(ld, nor), rd), 0.), 15.);\n\n        vec3 ref = reflect(rd, nor);\n        vec3 ref_col = sky(-ref);\n        float sp_ref = pow(max(dot(normalize(-rd + ld), nor), 0.), 16.);\n        ref_col = sp_ref * ref_col * ref_col * 6.;\n\n        vec3 tex;\n        {\n            float d = length(q.xz) - TORUS.x;\n            float a = atan(q.z, q.x), b = atan(q.y, d);\n\n            float r = TORUS.y / TORUS.x;\n            float ir = sqrt(1. - r * r);\n            b = 2. / ir * atan((r + 0.3) / ir * tan(b / 2.));\n            vec2 uv = vec2(a, b) * vec2(4.00, 4.) / PI;\n\n            tex = pattern(uv, ref_col);\n        }\n\n        fblend = 1. - smoothstep(-.2, .2, abs(dot(rd, nor)) - .2);\n\n        col =  0.05 * tex * diff * vec3(1.15, 0.90, 0.55);\n        col += tex * (diff * sh + vec3(1, .7, .4) * spec * sh);\n\n        col *=  1. / (1. + ldist * .05);\n    }\n    \n    vec2 in_uv = fragCoord / iResolution.xy;\n    col *= pow(100. * in_uv.x * in_uv.y * (1. - in_uv.x) * (1. - in_uv.y), .256);\n    \n    // Thanks Shane for a nice trick. Removes a good amount of flickering on edges\n    // https://www.shadertoy.com/view/7dyfRc\n    vec4 precol = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float blend = (iFrame < 2) ? 1. : 1./(1. + fblend*8.); \n    fragColor = mix(precol, vec4(clamp(col, 0., 1.), 1), blend);\n}","name":"Buffer A","description":"","type":"buffer"}]}