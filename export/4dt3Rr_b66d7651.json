{"ver":"0.1","info":{"id":"4dt3Rr","date":"1447763051","viewed":446,"name":"Yet Another Raytraced Plane","username":"bananaboy","description":"There are two shaders: the slow version implements the full algorithm and performs all steps in order to demonstrate the algorithm, and the optimised version demonstrates shortcuts that can be taken. Comment out the #ifdef SLOW to try them out.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["2d","raytracingmplane"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SLOW\n\n#ifdef SLOW\n\n// Slow version that demonstrates the algorithm.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Ray starts at the origin and travels through the pixel in the positive z direction.\n    vec3 rayDir = vec3(- 1.0 + 2.0 * (fragCoord.xy / iResolution.xy), 1.0);\n    rayDir = normalize(rayDir);\n    \n    // Plane is pointing up and at a height of 1.\n    vec3 planeNormal = vec3(0, 1, 0);\n    const float planeHeight = 1.0;\n\n    // Calculate intersection time along ray direction.\n    float t = planeHeight / dot(planeNormal, rayDir);\n\n    // Calculate intersection point.\n    vec3 intersection = t * rayDir;\n\n    // Use planar mapping to calculate uv from the intersection point.\n    vec2 uv = vec2(intersection.xz);\n\n    // Scale by the sign because otherwise the bottom plane moves in the opposite direction!\n    uv.y *= sign(uv.y);\n\n    // Add time to the texture v to simulate motion.\n    uv.y += iTime;\n\n    // Look up the texture and also scale it by the ray direction y to simulate depth cueing.\n    vec4 tex = texture(iChannel0, uv) * abs(rayDir.y);\n\n    fragColor = vec4(tex.xyz, 1.0);\n}\n\n#else\n\n// Optimised version.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Ray starts at the origin and travels through the pixel in the positive z direction.\n    // We don't need to specify z because it just becomes (1 / rayDir.y).\n    vec2 rayDir = vec2(- 1.0 + 2.0 * (fragCoord.xy / iResolution.xy));\n    \n    // As an optimisation, we don't normalise the ray direction. This results in slightly darker\n    // colours when we apply depth cueing.\n \n    // Calculate intersection point and use planar mapping to calculate uv.\n    // This combines the calculation of 't' in the slow version with the\n    // calculation of the intersection point.\n\tvec2 uv = vec2(rayDir.x, 1.0) / rayDir.y;\n\n    // Scale by the sign because otherwise the bottom plane moves in the opposite direction!\n    uv.y *= sign(uv.y);\n\n    // Add time to the UVs to simulate moving.\n    uv.y += iTime;\n\n    // Look up the texture and also scale it by the ray direction y to simulate depth cueing.\n    vec4 tex = texture(iChannel0, uv) * abs(rayDir.y);\n\n    fragColor = vec4(tex.xyz, 1.0);\n}\n#endif\n","name":"Image","description":"","type":"image"}]}