{"ver":"0.1","info":{"id":"4dBfD3","date":"1527270986","viewed":202,"name":"Analytic distortion Debugger","username":"asiJa","description":"Shader made to get insight into recursive wrap functions with analytic derivatives. Long term goal is to do nice turbulences. \nLeft : distorted grid texture; \nRight :  derivatives encoded as x=Red,y=Green; Top: finite difference; Bottom: analytic;","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","distortion","wrapping","derivaties"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \n\nvec3 lorenz( vec2 p, float w2 ){\n\tfloat D  = 1.0/(w2+dot(p,p));\n\treturn vec3( p*(-2.0*D*D), D );\n}\n\nvec3 sin_fd( vec2 p, vec2 freq ){\n    p *=freq;\n    vec2 sp = sin(p);\n    vec2 cp = cos(p) * freq;\n    return vec3( cp.x*sp.y, sp.x*cp.y, sp.x*sp.y );\n}\n\nvec3 sin_poles( vec2 p, vec2 freq, float w2 ){\n    p *=freq;\n    vec2 sp = sin(p);\n    vec2 cp = cos(p);\n    float D = 1.0/(w2 + dot(sp,sp) );\n    return vec3( -2.0*freq*D*D*cp*sp, D )*w2;\n}\n\nvec3 sin_poles_signed( vec2 p, vec2 freq, float w2 ){\n    p *=freq;\n    vec2 sp = sin(p);\n    vec2 cp = cos(p);\n    float s = cp.x*cp.y;\n    float D = 1.0/(w2 + dot(sp,sp) );\n    //return vec3( -2.0*freq*D*D*cp*sp*s - freq*sp*cp.yx*D, D*s )*w2;\n    return vec3( (-2.0*D*cp*s - cp.yx)*freq*sp, s )*D*w2;\n}\n\nvec3 sin_net( vec2 p, vec2 freq, float w2 ){\n    p *=freq;\n    vec2 sp = sin(p);\n    vec2 cp = cos(p);\n    // --- type 1 - with singularities\n    //float D  = 1.0/(w2 + sp.x*sp.y );\n    //cp*=-2.0*freq*D*D;\n    //return vec3( cp.x*sp.y, sp.x*cp.y, D )*w2;\n    \n    // --- type 2 - without nodes\n    //vec2  D  = 1.0/(w2 + sp );\n    //float D2 = dot(D,D);\n    //cp*=-3.0*freq*D*D*D;\n    //return vec3( cp.x, cp.y, D2 )*w2*w2;\n    \n    // --- type 3 - with nodes\n    vec2  D  = 1.0/(w2 + sp*sp );\n    float D2 = D.x*D.y;\n    cp*=-freq*freq*D;\n    return vec3( cp*sp, 1.0 )*D2*w2*w2;\n\n}\n\nvec3 func( vec2 p ){\n/*\n    return   0.5 *lorenz( p+vec2( 1.0, 0.5), 1.0 ) \n           - 1.5 *lorenz( p+vec2(-1.0,-0.5), 2.0 )\n           - 0.5 *lorenz( p+vec2(-1.0,4.5), 0.5 );    \n*/\n//    return sin_fd( p, vec2(1.5) )*0.3;\n//    return lorenz   ( p, 1.0 );\n//    return sin_poles( p, vec2(1.5), 0.4 )*0.1;\n//    return sin_net( p, vec2(1.5), 0.4 )*0.1;\n//    return sin_poles_signed( p, vec2(1.5), 0.4 )*0.1;\n\n//    return sin_poles_signed( p, vec2(1.5), 0.8 )*0.1 + lorenz( p, 8.0 )*8.0;\n        return sin_poles_signed( p, vec2(1.0), 0.8 )*0.1 + sin_poles_signed( p, vec2(2.0), 0.4 )*0.02;\n}\n\nvoid move( inout vec2 p, float dt ){\n    vec3 fd = func( p );\n    //p += fd.xy*dt;                // gradient  move\n    p += vec2( -fd.y, fd.x ) * dt;  // vorticity move     \n}\n\nvec3 bgtex( vec2 p ){\n    vec2 sp = sin(p*10.0); \n    float w2 = 0.16;\n    //float grid = w2/(w2 + dot(sp,sp));              // grid only nodes\n    sp = w2/(w2 + sp*sp); float grid = dot(sp,sp);    // grid only lines\n    //sp = w2/(w2 + sp*sp); float grid = sp.x*sp.y;   // grid with nodes, lines\n    //return vec3( val );\n    vec2 bg = sin(p*2.0)*0.5 + 0.5;\n    //return vec3( bg.x, grid*0.5, bg.y ); \n    return vec3( bg.x, (bg.x+bg.y)*0.4, bg.y ) + vec3(grid*0.3); \n}\n\nvec2 checkFuncDeriv( vec2 p ){\n    vec3 fd = func( p );\n    if(p.x>0.0){\n        float dd = 0.001;\n        fd.xy=vec2(\n            func( p + vec2(dd,0.0) ).z - fd.z ,\n            func( p + vec2(0.0,dd) ).z - fd.z\n        )/dd;\n    }\n    //return vec4( vec3(fd.xy,0.0)*0.1 + vec3(fd.z*0.5+0.5), 0.0);\n    //return vec4( vec3(fd.z*0.5+0.5), 0.0);\n    //return vec4( vec3(fd.xy,0.0)*0.1 + 0.5, 0.0);\n    return fd.xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 p0    = 2.0 * gl_FragCoord.xy / iResolution.xy - 1.0;\n\tvec2 p     = 6.0*p0;\t\n\t\n\tfloat val = func( p ).z;\n\t//float dt = 0.0625;\n\tfloat sint = sin(iTime*0.1);\n\tfloat wt2 = 0.4;\n\tfloat dt = (wt2/(wt2+sint*sint)-(wt2/(1.0+wt2)))*0.0625*32.0;\n\tvec4 clr = vec4(0.0,0.0,0.0,1.0);\n\tfloat t = 0.0;\n\tfor(int i=0; i<32; i++){ \n\t    move( p, dt ); \n\t    //clr.xyz += bgtex( p )*vec3(t,0.5,1.0-t)*dt*4.0;\n\t    //clr.xyz += bgtex( p )*t*dt*4.0;\n\t    t += dt;\n\t};\n        \n    clr.xyz = func( p )*10.0;\n    if( p0.y > 0.0 ) clr.xy = checkFuncDeriv( p )*5.0;\n    clr.xy +=vec2(0.5,0.5);\n    if( p0.x > 0.0 )clr.xyz = bgtex( p ); \n    fragColor = clr;\n}","name":"Image","description":"","type":"image"}]}