{"ver":"0.1","info":{"id":"tdBcz3","date":"1691674579","viewed":80,"name":"SimpleWaterTestAnalysis","username":"Lemlog","description":"Trying to create natural water using ray marching.","likes":4,"published":1,"flags":0,"usePreview":1,"tags":["raymarchingperlinnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MIN_DIST 1e-02\n#define MAX_DIST 100.\n#define MAX_ITER 64\n#define pi 3.14\n#define FOG_COLOR vec3(0.6,0.7,0.8)\n#define FOG_K 4e-03\n#define LIGHT_ALPHA 40.\n#define LIGHT_SPEC_K 0.3\n\n#define STRETCH_CONSTANT_2D -0.211324865405187\n#define SQUISH_CONSTANT_2D 0.366025403784439\n#define STRETCH_CONSTANT_3D -1./6.\n#define SQUISH_CONSTANT_3D 1./3.\n#define RADIUS 1.25\n#define SCALE_VAL 4.\n\nvec2 getAngle()\n{\n    vec2 uv = vec2(0., 0.1);\n    if (iMouse.z > 0.)\n        uv = iMouse.xy/iResolution.xy - vec2(0.5, 0.4);\n    return vec2(uv.x*pi, uv.y*pi);\n}\nvec3 getCam(vec2 uv, vec2 a)\n{\n    float k = iResolution.x/iResolution.y;\n    vec3 rd;\n    vec3 rd0 = vec3((uv.x - 0.5)*k, uv.y - 0.3, 1.);\n    vec3 rd1 = vec3((uv.x - 0.5)*k/2.5, (uv.y - 0.5)/2.5, 0.0);\n    vec3 ord = normalize(rd0 - rd1);\n    \n    rd.y = ord.y*cos(a.y) - ord.z*sin(a.y);\n    rd.z = ord.y*sin(a.y) + ord.z*cos(a.y);\n    rd.x = ord.x;\n    ord = rd;\n    rd.x = ord.x*cos(a.x) - ord.z*sin(a.x);\n    rd.z = ord.x*sin(a.x) + ord.z*cos(a.x);\n    rd.y = ord.y;\n    return rd;\n}\n\nfloat hash(vec3 z)\n{\n    return fract(sin(dot(z, vec3(129.5, 119.17, 331.9))) * 350182.123);\n}\n\nvec3 gradients[] = vec3[] (\n\tvec3(-11,  4,  4), vec3(-4,  11,  4), vec3(-4,  4,  11),\n    vec3(11,  4,  4),  vec3(4,  11,  4),  vec3(4,  4,  11),\n\tvec3(-11, -4,  4), vec3(-4, -11,  4), vec3(-4, -4,  11),\n    vec3(11, -4,  4),  vec3(4, -11,  4),  vec3(4, -4,  11),\n\tvec3(-11,  4, -4), vec3(-4,  11, -4), vec3(-4,  4, -11),\n\tvec3(11,  4, -4),  vec3(4,  11, -4),  vec3(4,  4, -11),\n\tvec3(-11, -4, -4), vec3(-4, -11, -4), vec3(-4, -4, -11),\n\tvec3(11, -4, -4),  vec3(4, -11, -4),  vec3(4, -4, -11)\n);\n\nint getInd(vec3 sb)\n{\n    float ind = floor(24.*hash(sb));\n    return int(ind);\n}\n\nfloat value(vec3 u, vec3 b)\n{\n    float r = length(u - b)/RADIUS;\n    if (r > 1.)\n        return 0.;\n    return dot(u - b, gradients[getInd(b)])* pow(1. - r*r, 4.);\n}\n\nvec2 stretch(vec2 u)\n{\n    float str = (u.x + u.y) * STRETCH_CONSTANT_2D;\n    return u + str;\n}\nvec2 squish(vec2 u)\n{\n    float str = (u.x + u.y) * SQUISH_CONSTANT_2D;\n    return u + str;\n}\n\nfloat calc(vec3 u, vec3 sb, vec3 shift)\n{\n    vec3 sbn = sb + shift;\n    vec3 bn = vec3(squish(sbn.xy), sbn.z);\n    return value(u, bn);\n}\n\nfloat noise(vec3 u)\n{\n    vec3 s = vec3(stretch(u.xy), u.z);\n    vec3 sb = floor(s);\n    vec3 b = vec3(squish(sb.xy), sb.z);\n    bool is_up = (u.z - sb.z > 0.5);\n    float val = value(u, b);\n    if (u.x + u.y > 1.)\n    {\n    \tval += calc(u, sb, vec3(2,0,0));\n    \tval += calc(u, sb, vec3(0,2,0));\n    \tval += calc(u, sb, vec3(2,0,1));\n    \tval += calc(u, sb, vec3(0,2,1));\n        if (is_up)\n        {\n    \t\tval += calc(u, sb, vec3(2,0,2));\n    \t\tval += calc(u, sb, vec3(0,2,2));\n        }\n        else\n        {\n    \t\tval += calc(u, sb, vec3(2,0,-1));\n    \t\tval += calc(u, sb, vec3(0,2,-1));\n        }\n    }\n    else\n    {\n    \tval += calc(u, sb, vec3(-1,1,0));\n    \tval += calc(u, sb, vec3(1,-1,0));\n    \tval += calc(u, sb, vec3(-1,1,1));\n    \tval += calc(u, sb, vec3(1,-1,1));\n        if (is_up)\n        {\n    \t\tval += calc(u, sb, vec3(-1,1,2));\n    \t\tval += calc(u, sb, vec3(1,-1,2));\n        }\n        else\n        {\n    \t\tval += calc(u, sb, vec3(-1,1,-1));\n    \t\tval += calc(u, sb, vec3(1,-1,-1));\n        }\n    }\n    val += calc(u, sb, vec3(0,0,1));\n    \n    val += calc(u, sb, vec3(1,1,0));\n    val += calc(u, sb, vec3(1,0,0));\n    val += calc(u, sb, vec3(0,1,0));\n    \n    val += calc(u, sb, vec3(1,1,1));\n    val += calc(u, sb, vec3(1,0,1));\n    val += calc(u, sb, vec3(0,1,1));\n    \n    if (is_up)\n    {\n    \tval += calc(u, sb, vec3(0,0,2));\n        val += calc(u, sb, vec3(1,1,2));\n        val += calc(u, sb, vec3(1,0,2));\n        val += calc(u, sb, vec3(0,1,2));\n    }\n    else\n    {\n    \tval += calc(u, sb, vec3(0,0,-1));\n        val += calc(u, sb, vec3(1,1,-1));\n        val += calc(u, sb, vec3(1,0,-1));\n        val += calc(u, sb, vec3(0,1,-1));\n    }\n    \n    return val/SCALE_VAL;\n}\n\nfloat sum_noise(vec3 p)\n{\n    float f = 0.0;\n    p = p;\n    f += 1.0000 * noise(p); p = 1.5 * p;\n    f += 0.5000 * noise(p); p = 2.0 * p;\n\t//f += 0.2500 * noise(p); p = 3.0 * p;\n\t//f += 0.1250 * noise(p); \n    \n    return f;\n}\n\n#define H_PLANE 6.5\nfloat dist(vec3 p)\n{\n    float noi = sum_noise(vec3(p.xz, iTime));\n    float d = p.y + H_PLANE + .15*noi;\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    if (abs(rd.y) < 6e-02)\n        return MAX_DIST;\n    float dO = -(H_PLANE - ro.y)/rd.y;\n    if (dO < 0.)\n        return MAX_DIST;\n    float d;\n    for(int i = 0; i < MAX_ITER; i++)\n    {\n        vec3 p = ro + dO*rd;\n        d = dist(p);\n        dO += d;\n        if ((d < MIN_DIST) || (dO > MAX_DIST)){\n            return dO;\n        }\n    }\n    return dO;\n}\n\nvec3 getNorm(vec3 p)\n{\n    vec2 d = vec2(0.0001, 0.);\n    float t  = dist(p);\n    vec3 v = vec3(t, t, t);\n    vec3 v1 = vec3(dist(p - d.xyy),\n\t\t\t\t\tdist(p - d.yxy),\n\t\t\t\t\tdist(p - d.yyx));\n    return (v - v1)/d.x;\n}\n\nfloat getLight(vec3 p, vec3 lightPos)\n{\n    vec3 l = normalize(lightPos - p);\n    vec3 n = getNorm(p);\n    float diff = max(0., dot(n, l))/2.;\n    vec3 v = normalize(-p);\n    vec3 h = normalize(v + l);\n    float spec = LIGHT_SPEC_K*pow(max(0., dot(n, h)), LIGHT_ALPHA);\n    return diff + spec;\n}\n\nvec3 applyFog( in vec3  rgb,       // original color of the pixel\n               in float dO ) // camera to point distance\n{\n    float fogAmount = 1.0 - exp( -FOG_K*dO*sqrt(dO) );\n    return mix( rgb, FOG_COLOR, fogAmount );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = FOG_COLOR;\n    vec3 ro = vec3(0.,0.,0.);\n    float dO;\n    vec2 ang = getAngle();\n    vec3 rd = getCam(uv, ang);\n    \n    dO = RayMarch(ro, rd);\n    if (abs(dO) < MAX_DIST)\n    {\n        vec3 p = ro + rd*dO;\n        float light = getLight(p, vec3(0,100,500));\n        col = vec3(light/2.1, light/2.1, light);\n    \tcol = applyFog(col, dO);\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}