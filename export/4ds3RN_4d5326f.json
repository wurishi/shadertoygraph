{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"cubemap","id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"vec3 sampleHemisphere(float u1, float u2, vec3 normal)\n{\n\tvec3 u = normal;\n\tvec3 v = abs(u.y) < abs(u.z) ? vec3(0.0, 1.0, 0.0) : vec3(0.0, 0.0, 1.0);\n\tvec3 w = normalize(cross(u, v));\n\tv = cross(w, u);\n\n\tfloat r = sqrt(u1);\n\tfloat theta = 2.0 * 3.1415926535 * u2;\n\tfloat x = r * cos(theta);\n\tfloat y = r * sin(theta);\n\treturn normalize(u * sqrt(1.0 - u1) + v * x + w * y);\n}\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 intersectSphere(vec3 rpos, vec3 rdir)\n{\n\tvec3 op = vec3(0.0, 0.0, 0.0) - rpos;\n\tfloat rad = 5.0;\n\t\n\tfloat eps = 1e-5;\n\tfloat b = dot(op, rdir); \n\tfloat det = b*b - dot(op, op) + rad*rad; \n\t\t\n\tif (det > 0.0)\n\t{\n\t\tdet = sqrt(det);\n\t\tfloat t = b - det;\n\t\tif (t > eps)\n\t\t\treturn vec4(normalize(rpos+rdir*t), t);\n\t}\n\t\n\treturn vec4(0.0);\n}\n\nvec3 diffuse(vec3 p, vec2 n)\n{\t\n\tvec3 col = vec3(0.0);\n\tfor (float i = 0.0; i < 4.0; i++)\n\t\tfor (float j = 0.0; j < 8.0; j++)\t\t\n\t\t{\n\t\t\tvec2 s = vec2(i, j)+n;\n\t\t\tfloat u = (rand(p.xy+s)+i)*0.25;\n\t\t\tfloat v = (rand(p.yz+s)+j)*0.125;\n\t\t\t\n\t\t\tvec3 ns = sampleHemisphere(u*0.5, v, p);\n\t\t\tcol += pow(texture(iChannel1, ns).rgb, vec3(2.2));\n\t\t}\n\t\n\treturn col * 0.25 * 0.125;\n}\n\nvec3 rotate(vec3 p, float theta)\n{\n\treturn vec3(p.x * cos(theta) + p.z * sin(theta), p.y,\n\t\t\t\tp.z * cos(theta) - p.x * sin(theta));\n}\n\nvec3 trace(vec3 rayPos, vec3 rayDir, vec2 fragCoord)\n{\n\tvec3 col = pow(texture(iChannel0, rayDir).rgb, vec3(2.2));\n\t\n\tvec4 r = intersectSphere(-rayPos, rayDir);\n\t\n\tif (r.w > 0.0)\n\t{\n\t\tvec3 n = r.xyz;\n\t\tvec3 diff = diffuse(n, vec2(sin(iTime))*fragCoord);\n\t\tvec3 spec = pow(texture(iChannel0, reflect(rayDir, n)).rgb, vec3(2.2));\n\t\t\n\t\tfloat costheta = -dot(n, rayDir);\n\t\t\n\t\tfloat f = 1.0 - pow(1.0 - clamp(costheta, 0.0, 1.0), 5.0);\n\t\t\n\t\tcol = mix(spec, diff, f);\n\t}\n\t\n\treturn col;\n}\n\nvec3 camera(vec2 px)\n{\n\tvec2 rd = (px / iResolution.yy - vec2(iResolution.x/iResolution.y*0.5-0.5, 0.0)) * 2.0 - 1.0;\n\t\n\tfloat time = iTime * 0.2;\n\tvec3 rayDir = rotate(normalize(vec3(rd.x, rd.y, 1.0)), time);\n\tvec3 rayPos = rotate(vec3(0.0, 0.0, 10.0), time);\n\t\t\n\treturn trace(rayPos, rayDir,px);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t/// Set to 1 to apply AA\n\t#if 1\n\tvec3 col = vec3(0.0);\n\t\n\tfor (float x = 0.0; x < 1.0; x += 0.5)\n\t\tfor (float y = 0.0; y < 1.0; y += 0.5)\n\t\t\tcol += camera(fragCoord.xy + vec2(x, y)) * 0.25;\n\t#else\n\tvec3 col = camera(fragCoord.xy);\n\t#endif\n\t\t\n\tfragColor = vec4(pow(col, vec3(0.4545)), 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4ds3RN","date":"1364160832","viewed":1904,"name":"Cubemap Shading","username":"vanburgler","description":"Shades a sphere using a cube-map. Uses Schlick's approximation of the fresnel equation.","likes":39,"published":1,"flags":0,"usePreview":0,"tags":["cubemap","raytrace"],"hasliked":0,"parentid":"","parentname":""}}