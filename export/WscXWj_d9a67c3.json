{"ver":"0.1","info":{"id":"WscXWj","date":"1572843536","viewed":195,"name":"Raymarch Blobs","username":"Jordan","description":"A modification of my first attempt at raymarching:\nhttps://www.shadertoy.com/view/tdtXRl","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","blob"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define MAX_STEPS 100\n#define MIN_DIST 0.01\n#define MAX_DIST 50.\n\n\nfloat GetDist(vec3 p)\n{\n    vec4 sphere = vec4(0.,pow(sin(iTime),2.)+1.,6.+pow(sin(iTime),2.)*0.5,1.);\n    float d_sphere = length(p-sphere.xyz) - sphere.w - 0.8*sin((p.x+iTime)*3.)*cos((p.y+iTime)*1.4) - cos((p.y+iTime)*2.1313)*sin((p.x+iTime)*1.2)*0.7 - abs(cos((p.x*p.y*p.z*0.1-iTime*0.1)*2.2412421 - 0.6214))*0.5;\n    //float d_plane = p.y - (0.1*sin((sin(p.x+iTime+p.z)*0.6+p.x+iTime)*5.)*cos((p.z+sin(iTime)*0.1)*2.)*2. - cos((p.z+iTime)*2.)*cos((sin(p.y*0.2)+sin(iTime)*0.1)*2.)*0.1)*(1.-sin((p.x+p.z+iTime)*0.2)) + 0.5*sin((p.x+p.z+iTime)*0.2)+0.5;\n    float d = d_sphere;//min(d_plane,d_sphere);\n    return d;\n}\n\n\n\nvec2 RayMarch(vec3 r_origin, vec3 r_direction)\n{\n    float d_origin = 0.;\n    float min_dist = 1000000.0;\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n        vec3 p = r_origin + d_origin*r_direction;\n        float d_surf = GetDist(p);\n        min_dist = min(d_surf, min_dist);\n        d_origin += d_surf;\n        if(d_surf<MIN_DIST || d_origin>MAX_DIST) break;\n    }\n    \n    return vec2(d_origin,min_dist);\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p);\n    vec2 e = vec2(.01,0);\n    \n    vec3 n = d - vec3( \n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n        \n    return normalize(n);\n}\n\nvec3 GetLight(vec3 p)\n{\n\n    vec3 rgb = vec3(0.,0.,0.);\n    vec3 lightPos = vec3(0,3,6);\n    vec3 lightPos2 = vec3(0,3,6);\n    vec3 lightCol = vec3(0,0,0);\n    \n    vec3 l ;\n    vec3 n ;\n    float dif = 0.;\n    vec2 rm ;\n    float mindist ;\n    float d ;\n    \n    \n    lightPos.xz += vec2(5.*sin(iTime),5.*cos(iTime));\n    l = normalize(lightPos - p);\n    n = GetNormal(p);\n    dif += clamp(dot(n,l),0.,1.);\n    rm = RayMarch(p+n*(MIN_DIST+0.5),l);\n    mindist = rm.y;\n    d = rm.x;\n    lightCol+= vec3(abs(sin(1./rm.x*0.1)))*0.2;\n    if(d<length(lightPos-p)) dif*=0.03;\n    \n    if(d>=MAX_DIST)\n    {\n     lightCol += 0.05*(vec3(10./(mindist+0.09),1./(mindist+0.5),1./(mindist+0.09)));\n     }\n     \n    \n    lightPos2.xz += vec2(5.*cos(iTime+3.14159),5.*sin(iTime+3.14159));\n    l = normalize(lightPos2 - p);\n    dif += clamp(dot(n,l),0.,1.);\n    rm = RayMarch(p+n*(MIN_DIST+0.5),l);\n    mindist = rm.y;\n    d = rm.x;\n    lightCol+= vec3(abs(sin(1./rm.x*0.1)))*0.2;\n    if(d<length(lightPos-p)) dif*=0.03;\n    \n    if(d>=MAX_DIST)\n    {\n     lightCol += 0.05*(vec3(10./(mindist+0.09),1./(mindist+0.5),1./(mindist+0.09)));\n     }\n    \n    rgb = dif+lightCol;\n    \n    \n    return rgb;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy) / iResolution.y;\n\n    vec3 r_origin = vec3(0,1.5,0);\n    vec3 r_direction = normalize(vec3(uv.x,uv.y,1));\n    vec2 rm = RayMarch(r_origin, r_direction);\n    float mindist = rm.y;\n    float dist = rm.x;\n    vec3 p = r_origin + r_direction*dist;\n    vec3 diffuse = GetLight(p);\n    vec3 col = diffuse;\n    \n    fragColor = vec4(vec3((mindist*0.2)+1.5*col.y/dist,0.3*col.z/dist,0.3*col.x/dist),1.0);\n}","name":"Image","description":"","type":"image"}]}