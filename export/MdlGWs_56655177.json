{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define PI 3.1415326\n\nmat2 rotate2D(float r) {\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\n// Distance of point p to cube #cubeNum\nfloat distanceTo(vec3 p, float cubeNum) {\n    float size = exp(-cubeNum);  // Cube size\n    p.y += size*3.;  // Cube location, space out a bit\n    p.xz *= rotate2D(cubeNum*PI/4.);\n    return length(p-clamp(p, -size, size));\n}\n\n// Distance to closest cube\nfloat worldSDF(vec3 p) {\n    float minDist=1.;\n    for(float j=0.; j<6.; j++) { // number of cubes\n        float curDist = distanceTo(p, j); // Distance to cube #j\n        //p.xz *= rotate2D(PI/4.);\n        minDist = min(minDist, curDist); \n    }\n    return minDist;\n}\n\nvec3 cameraMotion(vec3 p) {\n    p.yz *= rotate2D(-0.8);\n    p.xz *= rotate2D(iTime);\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float i;\n    float minDist, eyeDist;\n\n    vec3 eyePos = vec3(0, 0, -1);\n    vec3 ray = vec3((fragCoord.xy-.5*iResolution.xy)/iResolution.x, 1.);\n    ray = normalize(ray);\n\n    // Camera motion\n    eyePos = cameraMotion(eyePos);\n    ray = cameraMotion(ray);\n\n    for(minDist=1.; i<100. && minDist>.001; i++) {  \n        // Point to check\n        vec3 p = eyePos+eyeDist*ray;\n        \n        minDist = worldSDF(p);\n        // Move point forward\n        eyeDist += minDist*.5;\n    }\n    // Adjust steps by current distance to surface to fix banding\n    i += minDist*2000.;\n    fragColor = vec4(0) + 100./(i*i);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdlGWs","date":"1382051748","viewed":345,"name":"Boxes1","username":"rudros","description":"Very small but (hopefully) readable ray-caster","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","mini"],"hasliked":0,"parentid":"","parentname":""}}