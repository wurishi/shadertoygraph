{"ver":"0.1","info":{"id":"sdcfz7","date":"1656234660","viewed":131,"name":"Boundary Shader","username":"Cow_Bandit","description":"Shader that highlights boundaries in black based on the CIELAB model.","likes":0,"published":1,"flags":2,"usePreview":0,"tags":["webcam","cielab"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// XYZ Reference illuminant values for a D55 illuminant at 10 degrees (Mid-morning Daylight)\nvec3 d55 = vec3(95.799,100.,90.926);\n\n// All Converter functions have been derived from this site : http://www.easyrgb.com/en/math.php\n// Do check it out; it's quite interesting and useful\n\n// Converter function from RGB to XYZ models\nvec3 rgbToXYZ(vec3 rgb)\n{   \n    vec3 nrgb = rgb;\n\n    if(nrgb.x>0.04045) nrgb.x = pow(((nrgb.x+0.055)/1.055),2.4);\n    else nrgb.x /= 12.92;\n    if(nrgb.y>0.04045) nrgb.y = pow(((nrgb.y+0.055)/1.055),2.4);\n    else nrgb.y /= 12.92;\n    if(nrgb.z>0.04045) nrgb.z = pow(((nrgb.z+0.055)/1.055),2.4);\n    else nrgb.z /= 12.92;\n    \n    nrgb *= 100.;\n    \n    vec3 xyz;\n    xyz.x = nrgb.x*0.4124 + nrgb.y*0.3576 + nrgb.z*0.1805;\n    xyz.y = nrgb.x*0.2126 + nrgb.y*0.7152 + nrgb.z*0.0722;\n    xyz.z = nrgb.x*0.0193 + nrgb.y*0.1192 + nrgb.z*0.9505;\n\n    return xyz;\n}\n\n// Converter function from XYZ to CIELAB (l*a*b*) models\nvec3 xyzToCIELAB(vec3 xyz)\n{\n    vec3 nxyz = vec3(xyz.x/d55.x,xyz.y/d55.y,xyz.z/d55.z);\n    \n    if(nxyz.x>0.008856) nxyz.x = pow(nxyz.x,(1./3.));\n    else nxyz.x = (7.787*nxyz.x)+(16./116.);\n    if(nxyz.y>0.008856) nxyz.y = pow(nxyz.y,(1./3.));\n    else nxyz.y = (7.787*nxyz.y)+(16./116.);\n    if(nxyz.z>0.008856) nxyz.z = pow(nxyz.z,(1./3.));\n    else nxyz.z = (7.787*nxyz.z)+(16./116.);\n    \n    vec3 cielab;\n    \n    cielab.x = (116.*nxyz.y)-16.;\n    cielab.y = 500.*(nxyz.x-nxyz.y);\n    cielab.z = 200.*(nxyz.y-nxyz.z);\n    \n    return cielab;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Get current cell color from iChannel0\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 srcColor = texture(iChannel1,uv);\n    \n    // How many adjacent cells?\n    float range = 1.;\n    // Is the current cell a boundary?\n    bool bound = false;\n    // What difference in L* value is considered a boundary?\n    float lDiff = 10.;\n    \n    //Current cell CIELAB model value\n    vec3 CIE = srcColor.xyz;\n    CIE = xyzToCIELAB(rgbToXYZ(CIE));\n    \n    for(float i = fragCoord.x-range; i <= fragCoord.x+range; i++)\n    {\n        for(float j = fragCoord.y-range; j <= fragCoord.y+range; j++)\n        {\n            vec2 curuv = vec2(i,j)/iResolution.xy;\n            vec4 curColor = texture(iChannel1,curuv);\n            vec3 curCIE = xyzToCIELAB(rgbToXYZ(curColor.xyz));\n            \n            // Is the difference in l* value greater than that of the boundary condition?\n            if(abs(curCIE.x - CIE.x)>=lDiff) bound = true;\n        }\n    }\n    \n    if(bound == false)\n        fragColor = vec4(srcColor.xyz,1);\n    else\n        fragColor = vec4(0,0,0,1);\n}","name":"Image","description":"","type":"image"}]}