{"ver":"0.1","info":{"id":"XXsXWX","date":"1710079383","viewed":27,"name":"Local Star","username":"inverse_transpose","description":"Local Star.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","lighting","projection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return (fract((p3.x + p3.y) * p3.z)-.5)*1.5;\n}\n\n\n#define iterations 1\n#define flowintensity 1.25\n#define numOctaves 5\n#define flowoffset 0.25\n\nvec4 noised( in vec3 x )\n{\n    vec3 i = vec3(floor(x));\n    vec3 w = fract(x);\n    \n    // cubic interpolation\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w); \n    \n    float a = hash(i+vec3(0,0,0));\n    float b = hash(i+vec3(1,0,0));\n    float c = hash(i+vec3(0,1,0));\n    float d = hash(i+vec3(1,1,0));\n    float e = hash(i+vec3(0,0,1));\n\tfloat f = hash(i+vec3(1,0,1));\n    float g = hash(i+vec3(0,1,1));\n    float h = hash(i+vec3(1,1,1));\n    \n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\nvec4 fbm( vec3 x )\n{    \n    float G = exp2(-1.);\n    float f = 1.0;\n    float a = 1.0;\n    vec4 t;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        t += a*noised(x * f);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\n\n//@CollinInMySternum function to make swirly noise using fbm\nfloat curl(vec3 p, vec3 n)\n{\n    for(int i=0; i<iterations; i++)\n    {\n        vec3 x = p + flowoffset;\n        vec3 g = cross(fbm(x).yzw, n);\n        p -= (flowintensity / float(iterations)) * g;\n    }\n    \n    return (fbm(p).x + 1.0) / 2.0;\n}\n\nfloat iSphere(in vec3 ro, in vec3 rd, in vec3 sc, in float r)\n{\n    vec3 oc = ro - sc;\n    float b = dot(rd, oc);\n    float c = dot(oc, oc) - r*r;\n    float t = b*b - c;\n    \n    if (0.0 > t)\n        return -1.0;\n        \n    float g = sqrt(t);\n    return min((-b + g), (-b - g));\n}\n\n// Assumes we are dealing with a linear subspace.\nfloat iPlane(in vec3 ro, in vec3 rd, in vec3 n)\n{\n    return dot(normalize(n), vec3(0.0) - ro) / dot(normalize(n), rd);\n}\n\n// Handles hyperplanes.\nfloat iPlaneQ(in vec3 ro, in vec3 rd, in vec3 n, in vec3 q)\n{\n    vec3 nn = normalize(n);\n    return -dot(nn, ro - q) / dot(nn, rd);\n}\n\nvec3 get_colour(in vec3 p, in vec3 n)\n{\n    vec3 col = vec3(1.0, 0.475, 0.1);\n    return mix(col*0.3, 2.2*col, curl(p - 0.025*iTime,n));\n}\n\nvoid star(in vec3 ro, in vec3 rd, in vec3 cs, in float r, inout float mdist, inout vec3 col)\n{\n    float t = iSphere(ro, rd, cs, r);\n    if (!(0.0 > t) && t < mdist)\n    {\n        mdist = t;\n        vec3 p = ro + t*rd;\n        col = get_colour(p, normalize(p - cs));\n    }\n    \n    vec3 pn = normalize(vec3(0.0, 0.0, 1.0));\n    t = iPlaneQ(ro, rd, pn, vec3(0.0, 0.0, cs.z));\n    if (!(0.0 > t) && t < mdist)\n    {\n        mdist = t;\n        vec3 p = ro + t*rd;\n        vec3 fs = normalize(p - cs);\n        vec3 ts = cs - p;\n        float g = max(0.01,length(ts)-r);\n        float l = 1.0 / (g*4.5);\n       // float l = 1.0 / (length(ts)*0.395);\n        float d = 0.5 + 0.5*dot(normalize(ts), pn);\n        vec3 c = get_colour((fs*r)+cs, fs);\n        col = mix(col, c, d*l*l);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * fragCoord/iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0.0,0.0,1.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    vec3 col = vec3(0.0);\n    vec3 sc = vec3(0.0, 0.0, -1.0);\n    float radius = 1.0;\n   \n    float mdist = 1000000.0;\n    star(ro, rd, sc, radius, mdist, col);\n    //star(ro, rd, vec3(\n#if 0\n    float t = iSphere(ro, rd, sc, radius);\n    if (!(0.0 > t))\n    {\n        mdist = min(mdist, t);\n        col = get_colour(ro+t*rd, normalize((ro+t*rd)-sc));\n    }\n\n    vec3 pn = normalize(vec3(0.0, 0.0, 1.0));\n    t = iPlaneQ(ro, rd, pn, vec3(0.0, 0.0, -1.25));\n    if (!(0.0 > t) && t < mdist)\n    {\n        vec3 p = ro + t*rd;\n        vec3 fs = normalize(p - sc);\n        vec3 ts = sc - p;\n        float g = max(0.01,length(ts)-radius);\n        float l = 1.0 / (g*2.25);\n       // float l = 1.0 / (length(ts)*0.395);\n        float d = 0.5 + 0.5*dot(normalize(ts), pn);\n        vec3 c = get_colour((fs*radius)+sc, fs);\n        col = mix(col, c, d*l*l*l);\n    }\n#endif\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}