{"ver":"0.1","info":{"id":"7s3GR7","date":"1629374674","viewed":81,"name":"like water molecule","username":"grandmaster_xav","description":"first raymarching","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MIN_DIST 0.0\n#define MAX_DIST 30.0\n#define EPSILON 0.001\n#define MAX_MARCHING_STEPS 255\n#define M_PI 3.1415926535897932384626433832795\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\n/*\n**\t3D Mouvement\n*/\n\nmat3 rotate_X(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotate_Y(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotate_Z(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\n/*\n**\t3D Primitive\n*/\n\nfloat rhombus_2D(in vec2 p, in vec2 b)\n{\n    vec2 q = abs(p);\n    float h = clamp((-2.0*dot(q,b)+dot(b,b))/dot(b,b),-1.0,1.0);\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\n}\n\nfloat circle_2D(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat round_box_2D(in vec2 p, in vec2 b, in vec4 r)\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\n/*\n**\t3D Primitive\n*/\n\nfloat box_SDF(vec3 p, vec3 l)\n{\n\tvec3 d = abs(p) - l;\n\treturn (length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0));\n}\n\nfloat round_box_SDF(vec3 p, vec3 l, float r)\n{\n\treturn (box_SDF(p, l) - r);\n}\n\nfloat sphere_SDF(vec3 p, float radius)\n{\n\treturn (length(p) - radius);\n}\n\nfloat cylinder_SDF(vec3 p, float h, float r)\n{\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - vec2(h, r);\n\treturn (min(max(d.x, d.y), 0.0) + length(max(d, 0.0)));\n}\n\nfloat torus_SDF(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat cone_SDF(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\nfloat onion_SDF( in float sdf, in float thickness )\n{\n    return (abs(sdf)-thickness);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\n/*\n** \tBuilding 3D\n*/\n\nfloat smooth_util_SDF(float d1, float d2, float k)\n{\n\treturn (clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0));\n}\n\nfloat union_SDF(float d1, float d2)\n{\n\treturn min(d1, d2);\n}\n\nfloat smooth_union_SDF(float d1, float d2, float k)\n{\n    float h = smooth_util_SDF(d1, d2, k);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat substraction_SDF(float d1, float d2)\n{\n\treturn max(d1, -d2);\n}\n\nfloat smooth_substraction_SDF(float d1, float d2, float k)\n{\n    float h = smooth_util_SDF(d1, d2, k);\n    return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\nfloat intersect_SDF(float d1, float d2)\n{\n\treturn max(d1, d2);\n}\n\nfloat smooth_intersect_SDF( float d1, float d2, float k)\n{\n    float h = smooth_util_SDF(d1, d2, k);\n    return mix(d2, d1, h) + k * h * (1.0 - h);\n}\n\n/*\n** Initial VEC modifier\n*/\n\nvec3 repetition_SDF(vec3 p, in vec3 c)\n{\n    vec3 q = mod(p + 0.5 * c, c) - 0.5 * c;\n    return (q);\n}\n\nvec3 symmetry_X(vec3 p)\n{\n    p.x = abs(p.x);\n    return (p);\n}\n\nvec3 symmetry_Y(vec3 p)\n{\n    p.y = abs(p.y);\n    return (p);\n}\n\nvec3 symmetry_Z(vec3 p)\n{\n    p.z = abs(p.z);\n    return (p);\n}\n\n// vec3 T_x( in vec3 p, in transform t, in sdf3d primitive )\n// {\n//     return primitive( invert(t)*p );\n// }\n\n// float scale( in vec3 p, in float s)\n// {\n//     return primitive(p/s)*s;\n// }\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\n/*\n** 3D from 2D primitives\n*/\n\nfloat opExtrussion(in vec3 p, in float sdf, in float h)\n{\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w, 0.0));\n}\n\nvec2 opRevolution(vec3 p, float w)\n{\n    return vec2(length(p.xz) - w, p.y);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\n/*\n** Render\n*/\n#define pa vec3(1., 57., 21.)\n#define pb vec4(0., 57., 21., 78.)\n\nfloat perlin(vec3 p)\n{\n\tvec3 i = floor(p);\n\tvec4 a = dot( i, pa ) + pb;\n\tvec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\n\ta = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n\ta.xy = mix(a.xz, a.yw, f.y);\n\treturn mix(a.x, a.y, f.z);\n}\n\nfloat scene_SDF(vec3 p)\n{\n\tfloat smoother = 0.15;\n    p.z -= 1.;\n\tp *= rotate_Y(iTime);\n    p.z += 1.;\n\tfloat s = onion_SDF(sphere_SDF(p, 0.5), 0.04);\n\t// float s = substraction_SDF(sphere_SDF(p, 0.4), sphere_SDF(p, 0.3));\n\tfloat an = 2.5 * (0.5 + 0.5 * sin(iTime * 1.1 + 3.0));\n    vec2 c = vec2(sin(an),cos(an));\n\tfloat t1 = torus_SDF(p, c, 0.2, 0.1);\n\tfloat t2 = torus_SDF(p * rotate_X(iTime) * rotate_Y(1.5), c, 0.54, smoother);\n\tfloat t3 = torus_SDF(p * rotate_X(iTime * 0.2) * rotate_Z(iTime * 0.8), c, 0.4, smoother);\n\n\tfloat t = smooth_union_SDF(t3, smooth_union_SDF(t1, t2, smoother), smoother);\n\tfloat ball = union_SDF(sphere_SDF(p, 0.1), intersect_SDF(s, t));\n\n\tfloat cube;\n\tcube = sphere_SDF(p + vec3(0.4 * cos(iTime)), 0.07);\n\tball = smooth_union_SDF(ball, cube, 0.2);\n\tp *= rotate_X(iTime * 0.27);\n\tcube = sphere_SDF(p + vec3(0.3 * sin(iTime)), 0.1);\n\tball = smooth_union_SDF(ball, cube, 0.2);\n\n\tp *= rotate_Y(iTime * 0.2) * rotate_X(iTime * 0.75);\n\tcube = sphere_SDF(p + vec3(0.4 * cos(iTime)), 0.07);\n\tball = smooth_union_SDF(ball, cube, 0.2);\n\n\tp *= rotate_Z(iTime * 0.6) * rotate_X(iTime * 0.25);\n\tcube = sphere_SDF(p + vec3(0.33 * cos(iTime)), 0.07);\n\tball = smooth_union_SDF(ball, cube, 0.2);\n\n\tfloat total = smooth_union_SDF(ball, cube, 0.2);\n\t\n    return (total);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\n/*\n**  Ligth\n*/\n\nvec3 estimateNormal(vec3 p)\n{\n\treturn normalize(vec3(\n\t\tscene_SDF(vec3(p.x + EPSILON, p.y, p.z)) - scene_SDF(vec3(p.x - EPSILON, p.y, p.z)),\n\t\tscene_SDF(vec3(p.x, p.y + EPSILON, p.z)) - scene_SDF(vec3(p.x, p.y - EPSILON, p.z)),\n\t\tscene_SDF(vec3(p.x, p.y, p.z  + EPSILON)) - scene_SDF(vec3(p.x, p.y, p.z - EPSILON))\n\t));\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n\t\t\t\t\t\t  vec3 lightPos, vec3 lightIntensity) {\n\tvec3 N = estimateNormal(p);\n\tvec3 L = normalize(lightPos - p);\n\tvec3 V = normalize(eye - p);\n\tvec3 R = normalize(reflect(-L, N));\n\t\n\tfloat dotLN = dot(L, N);\n\tfloat dotRV = dot(R, V);\n\t\n\tif (dotLN < 0.0)\n\t\treturn vec3(0.0, 0.0, 0.0);\n\tif (dotRV < 0.0)\n\t\treturn lightIntensity * (k_d * dotLN);\n\treturn lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n\tvec3 ambientLight = 0.9 * abs(cos(iTime * 0.2)) * vec3(1.0, 1.0, 1.0);\n\tvec3 color = ambientLight * k_a;\n\t\n\tvec3 light1Pos = vec3(4.0 * sin(iTime),\n\t\t\t\t\t\t  2.0,\n\t\t\t\t\t\t  4.0 * cos(iTime));\n\tvec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n\t\n\tcolor += phongContribForLight(k_d, k_s, alpha, p, eye,\n\t\t\t\t\t\t\t\t  light1Pos,\n\t\t\t\t\t\t\t\t  light1Intensity);\n\t\n\tvec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n\t\t\t\t\t\t  2.0 * cos(0.37 * iTime),\n\t\t\t\t\t\t  2.0);\t\n\tvec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n\t\n\tcolor += phongContribForLight(k_d, k_s, alpha, p, eye,\n\t\t\t\t\t\t\t\t  light2Pos,\n\t\t\t\t\t\t\t\t  light2Intensity);    \n\treturn color;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\n/*\n**  Matrix / View\n*/\n\nfloat short_d1nce_surf(vec3 eye, vec3 dir, float start, float end)\n{\n\tfloat depth = start;\n\n\tfor (int i = 0; i < MAX_MARCHING_STEPS; i++)\n\t{\n\t\tfloat dist = scene_SDF(eye + depth * dir);\n\t\tif (dist < EPSILON)\n\t\t\treturn (depth);\n\t\tdepth += dist;\n\t\tif (depth >= end)\n\t\t\treturn (end);\n\t}\n\treturn (end);\n}\nmat4 view_matrix(vec3 eye, vec3 center, vec3 up)\n{\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(0.0, 0.0, 0.0, 1)\n\t);\n}\n\nvec3 ray_direction(float fov, vec2 size, vec2 fragCoord)\n{\n\tvec2 xy = fragCoord - size / 2.0;\n\tfloat z = size.y / tan(radians(fov) / 2.0);\n\treturn (normalize(vec3(xy, -z)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 eye = vec3(8.0, 5.0, 7.0);\n\tvec3 view_dir = ray_direction(45.0, iResolution.xy, gl_FragCoord.xy);\n\tmat4 view_world = view_matrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n\tvec3 dir = (view_world * vec4(view_dir, 0.0)).xyz;\n\t\n\tfloat dist = short_d1nce_surf(eye, dir, MIN_DIST, MAX_DIST);\n\n\tif (dist > MAX_DIST - EPSILON) {\n\t\tfragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn ;\n\t}\n\t\n\tvec3 p = eye + dist * dir;\n\t\n\tvec3 K_a = vec3(0.0, 0.7647, 1.0);\n\tvec3 K_d = vec3(0.2157, 0.2431, 0.4196);\n\tvec3 K_s = vec3(1.0, 0.0, 0.0);\n\tfloat shininess = 10.0;\n\t\n\tvec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n\t// vec3 color = vec3(dist, , 0.);\n\n\tfragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}