{"ver":"0.1","info":{"id":"clKGDG","date":"1684619234","viewed":25,"name":"Stickbug","username":"Omniscience","description":"SDF Testbed","likes":1,"published":1,"flags":64,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Md33R4","filepath":"https://soundcloud.com/slam-jam-936723906/stick-bug-song-bee-swarm-simulator?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","previewfilepath":"https://soundcloud.com/slam-jam-936723906/stick-bug-song-bee-swarm-simulator?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float SUPERSAMPLE_POS_STD = 0.001;\nconst float SUPERSAMPLE_DIR_STD = 0.01;\n\nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n};\n\nfloat sdfPoint(vec3 p, vec3 center) {\n    return length(p - center);\n}\n\nvec2 sdfLineSegment2(vec3 p, vec3 a, vec3 b) {\n    vec3 d = b-a;\n    float d2 = dot(d, d);\n    if (d2 == 0.0) return vec2(length(p - a), 0.0);\n    float t = clamp(dot(p-a, b-a) / d2, 0.0, 1.0);\n    vec3 proj = a + d*t;\n    return vec2(length(p - proj), t);\n}\n\nfloat sdfLineSegment(vec3 p, vec3 a, vec3 b) {\n    return sdfLineSegment2(p, a, b).x;\n}\n\nfloat sdfSphere(vec3 p, vec3 center, float radius) {\n    return sdfPoint(p, center) - radius;\n}\n\nfloat headThk(float t) { return 0.04 + 0.025*pow(abs(t-0.3)/0.7, 2.0); }\nfloat tailThk(float t) { return 0.03 + 0.025*pow(abs(t-0.7)/0.7, 2.0); }\nfloat bodyThk(float t) { return 0.04 + 0.025*pow(abs(t-0.5)/0.5, 2.0); }\nfloat thighThk(float t) { return 0.02 + 0.01*pow(abs(t-0.4)/0.6, 2.0); }\nfloat calfThk(float t) { return 0.02 + 0.01*pow(abs(t-0.4)/0.6, 2.0); }\n\nfloat sdfScene(vec3 p) {\n    vec3 XM = vec3(-1.0, 1.0, 1.0);\n    vec3 YM = vec3(1.0, -1.0, 1.0);\n    float t = iTime * 7.5;\n    vec3 c = vec3(0.0, 0.0, 0.0);\n    vec3 cm = c + vec3(sin(t)*0.125, sin(t*2.0)*0.05, 0.0);\n    vec3 legyo = vec3(0.0, sin(t)*0.25, 0.0);\n    vec3 leg1zo = FWD*0.7;\n    vec3 leg2zo = FWD*0.2;\n    vec3 leg3zo = -FWD*0.3;\n    vec3 rs = RIGHT*0.05;\n    vec3 fs = FWD*0.05;\n    vec3 elb1 = RIGHT*0.5-UP*0.05;\n    vec3 p1 = cm+leg1zo;\n    vec3 p2 = cm+leg2zo;\n    vec3 p3 = cm+leg3zo;\n    vec3 q1 = c+leg1zo+elb1+fs-rs;\n    vec3 q2 = c+leg2zo+elb1;\n    vec3 q3 = c+leg3zo+elb1-fs-rs;\n    vec3 r1 = c+leg1zo+RIGHT*0.675-UP*0.5+fs*2.0-rs;\n    vec3 r2 = c+leg2zo+RIGHT*0.675-UP*0.5;\n    vec3 r3 = c+leg3zo+RIGHT*0.675-UP*0.5-fs*2.0-rs;\n    \n    vec2 bseg1 = sdfLineSegment2(p, cm+FWD, cm+leg1zo);\n    vec2 bseg2 = sdfLineSegment2(p, cm+leg1zo, cm+leg2zo);\n    vec2 bseg3 = sdfLineSegment2(p, cm+leg2zo, cm+leg3zo);\n    vec2 bseg4 = sdfLineSegment2(p, cm+leg3zo, cm-FWD + UP*0.25);\n    \n    vec2 tseg1 = sdfLineSegment2(p, p1, q1+legyo);\n    vec2 tseg2 = sdfLineSegment2(p, p2, q2+legyo);\n    vec2 tseg3 = sdfLineSegment2(p, p3, q3+legyo);\n    vec2 tseg4 = sdfLineSegment2(p, p1, q1*XM+legyo*YM);\n    vec2 tseg5 = sdfLineSegment2(p, p2, q2*XM+legyo*YM);\n    vec2 tseg6 = sdfLineSegment2(p, p3, q3*XM+legyo*YM);\n    \n    vec2 cseg1 = sdfLineSegment2(p, q1+legyo, r1);\n    vec2 cseg2 = sdfLineSegment2(p, q2+legyo, r2);\n    vec2 cseg3 = sdfLineSegment2(p, q3+legyo, r3);\n    vec2 cseg4 = sdfLineSegment2(p, q1*XM+legyo*YM, r1*XM);\n    vec2 cseg5 = sdfLineSegment2(p, q2*XM+legyo*YM, r2*XM);\n    vec2 cseg6 = sdfLineSegment2(p, q3*XM+legyo*YM, r3*XM);\n    \n    float d = 1.0;\n    //d = sdfSphere(p, cm+FWD*len, 0.1),\n    d = min(d, bseg1.x - headThk(bseg1.t));\n    d = min(d, bseg2.x - bodyThk(bseg2.t));\n    d = min(d, bseg3.x - bodyThk(bseg3.t));\n    d = min(d, bseg4.x - tailThk(bseg4.t));\n    \n    d = min(d, tseg1.x - thighThk(tseg1.t));\n    d = min(d, tseg2.x - thighThk(tseg2.t));\n    d = min(d, tseg3.x - thighThk(tseg3.t));\n    d = min(d, tseg4.x - thighThk(tseg4.t));\n    d = min(d, tseg5.x - thighThk(tseg5.t));\n    d = min(d, tseg6.x - thighThk(tseg6.t));\n    \n    d = min(d, cseg1.x - calfThk(cseg1.t));\n    d = min(d, cseg2.x - calfThk(cseg2.t));\n    d = min(d, cseg3.x - calfThk(cseg3.t));\n    d = min(d, cseg4.x - calfThk(cseg4.t));\n    d = min(d, cseg5.x - calfThk(cseg5.t));\n    d = min(d, cseg6.x - calfThk(cseg6.t));\n    return d-0.0;\n}\n\n#define ZERO (min(iFrame,0))\nvec3 sdfNormal(vec3 p)\n{\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdfScene(p+0.0005*e);\n    }\n    return normalize(n);\n}\n\nvec3 shade(vec3 E, vec3 P, vec3 N, vec3 L) {\n    vec3 R = reflect(E, N);\n    float kD = clamp(dot(N, L), 0.0, 1.0);\n    float kS = pow(clamp(dot(-R, L), 0.0, 1.0), 2.0) * 0.125;\n    return kD * vec3(0.5, 1.0, 0.5) + kS * vec3(1.0, 1.0, 1.0);\n}\n\nvec3 sampleRay(Ray ray) {\n    vec3 P = ray.pos;\n    vec3 D = ray.dir;\n    float dPrev = 0.0;\n    for (int i=0; i<32; i++) {\n        float d = sdfScene(P);\n        P += D * max(d * 0.99, 0.0001);\n        if (d <= 0.0) {\n            vec3 N = sdfNormal(P);\n            return shade(-D, P, N, -D);\n        }\n    }\n    return texture(iChannel0, D).xyz;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    wgSeed = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    \n    vec2 kres = 1.0 / iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec4 screenPos = vec4(-1.0 + 2.0 * fragCoord * kres, 0.0, 1.0);\n    screenPos.x *= aspectRatio;\n    \n    float angle = (-30.0 + iTime*5.0);\n    vec3 pos = vec3(0.0, 0.0, 0.0);\n    vec4 rot = quatFromEulerDeg(vec3(45.0, 2.0*angle, 0.0));\n    pos -= qmulv(rot, FWD*3.0);\n    mat4 view = matrixFromTransform(Transform(pos, rot));\n    \n    vec4 rayPos = view * vec4(ZERO3, 1.0);\n    vec3 rayDir = normalize(vec3(screenPos.xy, 2.0));\n    \n    //rayPos.xyz += randnorm() * normDistPositive(hash(), SUPERSAMPLE_POS_STD);\n    //rayDir = gaussHemisphere(rayDir, SUPERSAMPLE_DIR_STD);\n    \n    rayDir = mat3(view) * rayDir;\n    Ray ray = Ray(rayPos.xyz, rayDir);\n    \n    vec3 color = sampleRay(ray);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define BW_NOT(x)        (0xffffffffU - (x))\n#define BIT_GET(x, n)    (0x1U & ((x) >> n))\n#define BIT_SET(x, n, v) x = (x & BW_NOT(0x1U << n)) | (v << n)\n\n#define GET_FLAG(x, n)    bool(BIT_GET(x, n))\n#define SET_FLAG(x, n, v) BIT_SET(x, n, uint(v))\n\nconst float EPSILON = 0.0001;\nconst float PI = 3.141592653589793238462643327950;\nconst float TWO_PI = PI * 2.0;\nconst float PI_BY_TWO = PI / 2.0;\nconst float PI_BY_90 = PI / 90.0;\nconst float PI_BY_360 = PI / 360.0;\nconst float DEG_TO_RAD = PI / 180.0;\nconst vec3 FWD = vec3(0.0, 0.0, 1.0);\nconst vec3 UP = vec3(0.0, 1.0, 0.0);\nconst vec3 RIGHT = vec3(1.0, 0.0, 0.0);\nconst vec3 ZERO3 = vec3(0.0, 0.0, 0.0);\nconst vec3 ONE3 = vec3(1.0, 1.0, 1.0);\n\nuvec4 vec4BitsToUvec4(vec4 v) {\n    return uvec4(\n        floatBitsToUint(v.x),\n        floatBitsToUint(v.y),\n        floatBitsToUint(v.z),\n        floatBitsToUint(v.w)\n    );\n}\nvec4 uvec4BitsToVec4(uvec4 v) {\n    return vec4(\n        uintBitsToFloat(v.x),\n        uintBitsToFloat(v.y),\n        uintBitsToFloat(v.z),\n        uintBitsToFloat(v.w)\n    );\n}\n\nfloat lerp(float a, float b, float x) { return a + (b-a) * x; }\nvec3 lerp(vec3 a, vec3 b, float x) { return a + (b-a) * x; }\n\nfloat unmix(float y0, float y1, float y) { return (y-y0)/(y1-y0); }\nvec3 unmix(vec3 y0, vec3 y1, vec3 y) { return (y-y0)/(y1-y0); }\n\nfloat remix(float x0, float x1, float x, float y0, float y1) { return mix(y0, y1, unmix(x0, x1, x)); }\nvec3 remix(vec3 x0, vec3 x1, vec3 x, vec3 y0, vec3 y1) { return mix(y0, y1, unmix(x0, x1, x)); }\nvec3 remix(float x0, float x1, float x, vec3 y0, vec3 y1) { return mix(y0, y1, unmix(x0, x1, x)); }\n\nmat4 identity() {\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\nmat4 scale(vec3 s) {\n    return mat4(\n        s.x, 0.0, 0.0, 0.0,\n        0.0, s.y, 0.0, 0.0,\n        0.0, 0.0, s.z, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\nmat4 translate(vec3 pos) {\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        pos.x, pos.y, pos.z, 1.0\n    );\n}\nmat4 rotateX(float t) {\n    float s = sin(t);\n    float c = cos(t);\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0,   c,   s, 0.0,\n        0.0,  -s,   c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\nmat4 rotateY(float t) {\n    float s = sin(t);\n    float c = cos(t);\n    return mat4(\n          c, 0.0,  -s, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n          s, 0.0,   c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\nmat4 rotateZ(float t) {\n    float s = sin(t);\n    float c = cos(t);\n    return mat4(\n          c,   s, 0.0, 0.0,\n         -s,   c, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 matrixFromQuat(vec4 q) {\n    float x = q.x, y = q.y, z = q.z, w = q.w;\n    float x2 = x*x, y2 = y*y, z2 = z*z;\n    \n    float xy = x*y, xz = x*z, yz = y*z,\n          xw = x*w, yw = y*w, zw = z*w;\n    \n    return identity() + 2.0 * mat4(\n        -(y2 + z2),  (xy + zw),  (xz - yw), 0.0,\n         (xy - zw), -(x2 + z2),  (yz + xw), 0.0,\n         (xz + yw),  (yz - xw), -(x2 + y2), 0.0,\n               0.0,        0.0,        0.0, 0.0\n    );\n}\n\nvec4 quatConjugate(vec4 q) {\n    return vec4(-q.xyz, q.w);\n}\n\nvec4 qmul(vec4 a, vec4 b) {\n    float ax = a.x, ay = a.y, az = a.z, aw = a.w;\n    float bx = b.x, by = b.y, bz = b.z, bw = b.w;\n    return vec4(\n        aw*bx + ax*bw + ay*bz - az*by,\n        aw*by + ay*bw + az*bx - ax*bz,\n        aw*bz + az*bw + ax*by - ay*bx,\n        aw*bw - ax*bx - ay*by - az*bz\n    );\n}\n\nvec3 qmulv(vec4 q, vec3 v) {\n    vec4 vq = vec4(v, 0.0);\n    vec4 c = quatConjugate(q);\n    q = qmul(q, vq);\n    q = qmul(q, c);\n    return q.xyz;\n}\nvec4 qmulv(vec4 q, vec4 v) {\n    return vec4(qmulv(q, v.xyz), v.w);\n}\n\nvec4 quatFromAxisAngle(vec3 axis, float angle) {\n    angle *= 0.5;\n    float sa = sin(angle);\n    float ca = cos(angle);\n    return vec4(\n        axis.x * sa,\n        axis.y * sa,\n        axis.z * sa,\n        ca\n    );\n}\n\nvec4 quatFromEulerDeg(vec3 euler) {\n    float ex = euler.x, ey = euler.y, ez = euler.z;\n    float ep = ey * PI_BY_360,\n          eq = ez * PI_BY_360,\n          er = ex * PI_BY_360,\n        sinp = sin(ep),\n        siny = sin(eq),\n        sinr = sin(er),\n        cosp = cos(ep),\n        cosy = cos(eq),\n        cosr = cos(er);\n    vec4 q = vec4(\n        sinr * cosp * cosy - cosr * sinp * siny,\n        cosr * sinp * cosy + sinr * cosp * siny,\n        cosr * cosp * siny - sinr * sinp * cosy,\n        cosr * cosp * cosy + sinr * sinp * siny\n    );\n    return normalize(q);\n}\n\nvec4 quatBetweenTwoVecs(vec3 a, vec3 b) {\n    float dp = dot(a, b);\n    if (dp == 1.0) return vec4(0.0, 0.0, 0.0, 1.0);\n    vec3 c = RIGHT;\n    if (dp == -1.0) c = cross(a, b);\n    float amag2 = dot(a, a);\n    float bmag2 = dot(b, b);\n    return normalize(vec4(c, sqrt(amag2 + bmag2) + dp));\n}\n\nvec4 quatBetweenTwoNorms(vec3 a, vec3 b) {\n    float dp = dot(a, b);\n    if (dp == 1.0) return vec4(0.0, 0.0, 0.0, 1.0);\n    vec3 c = RIGHT;\n    if (dp != -1.0) c = cross(a, b);\n    return normalize(vec4(c, 1.0 + dp));\n}\n\nstruct Transform {\n    vec3 pos;\n    vec4 rot;\n};\n\nTransform t_identity() {\n    return Transform(ZERO3, vec4(0.0, 0.0, 0.0, 1.0));\n}\n\nmat4 matrixFromTransform(Transform xform) {\n    mat4 m = identity();\n    m *= translate(xform.pos);\n    m *= matrixFromQuat(xform.rot);\n    return m;\n}\n\n// wang_hash, GetRandom(), randnorm() lifted from https://www.shadertoy.com/view/wlsyRN\n// thanks, ShnitzelKiller\nuint wgSeed;\nvoid wang_seed(float seed) {\n    wgSeed = uint(seed * 4294967296.0);\n}\nuint wang_hash() {\n    wgSeed = uint(wgSeed ^ uint(61)) ^ uint(wgSeed >> uint(16));\n    wgSeed *= uint(9);\n    wgSeed = wgSeed ^ (wgSeed >> 4);\n    wgSeed *= uint(0x27d4eb2d);\n    wgSeed = wgSeed ^ (wgSeed >> 15);\n    return wgSeed;\n}\nfloat GetRandom() {\n    return float(wang_hash()) / 4294967296.0;\n}\n// My own trig hashes\n/*\nconst vec4 gSeed = vec4(12.9898, 77.233, 14.66337, 23.53277);\nfloat hash(float p) { return fract(sin(p * gSeed.x)*43758.5453123); }\nfloat hash(vec2 p) { return fract(sin(dot(p, gSeed.xy))*43758.5453123); }\nvec2 hash2(vec2 p) { return fract(sin(p * gSeed.xy)*43758.5453123); }\n*/\n\nint hashui(int modulo) { return int(wang_hash()) % modulo; }\nfloat hash() { return GetRandom(); }\nvec2 hash2() { return vec2(GetRandom(), GetRandom()); }\nvec3 hash3() { return vec3(GetRandom(), GetRandom(), GetRandom()); }\n\nvec2 rand2() {\n    return hash2();\n}\nvec3 rand3() {\n    return hash3();\n}\n\nfloat stdNormDistPositive(float x) {\n    return sqrt(-2.0 * log(max(x, EPSILON)));\n}\nfloat normDistPositive(float x, float std) {\n    return std * stdNormDistPositive(x);\n}\nfloat stdNormDist(float x) {\n    if (x < 0.0) return -stdNormDistPositive(-x);\n    return stdNormDistPositive(x);\n}\nfloat normDist(float x, float std) {\n    return std * stdNormDist(x);\n}\nvec2 randBoxMuller(vec2 U) {\n    float r = normDistPositive(U.x, EPSILON);\n    float t = 2.0 * PI * U.y;\n    return vec2(\n        r*cos(t),\n        r*sin(t)\n    );\n}\n\nvec3 randnorm() {\n    vec2 utheta = hash2() * 2. - 1.;\n    utheta.y *= PI;\n    float rho = sqrt(1.-utheta.x * utheta.x);\n    return vec3(cos(utheta.y)*rho, sin(utheta.y)*rho, utheta.x);\n}\n\nvec3 gaussUpHemisphere(float std) {\n    float t = hash() * TWO_PI - PI;\n    float r = std * clamp(normDistPositive(hash(), std), -TWO_PI, TWO_PI);\n    \n    // TODO: why does this work? shouldn't we need [-pi/2, pi/2] for a hemisphere?\n    r = fract(r+0.5) - 0.5; //[-0.5, 0.5]\n    r *= TWO_PI;            //[-pi, pi]\n    \n    vec3 right = vec3(cos(t), 0.0, -sin(t));\n    return qmulv(quatFromAxisAngle(right, r), UP);\n}\n\nvec3 gaussHemisphere(vec3 fwd, float std) {\n    vec3 v = gaussUpHemisphere(std);\n    vec4 q = quatBetweenTwoNorms(UP, fwd);\n    return qmulv(q, v);\n}\n\nvec3 gaussReflect(vec3 v, vec3 n, float std) {\n    vec3 rIdeal = reflect(v, n);\n    vec3 rRand = gaussHemisphere(rIdeal, std);\n    if (dot(rRand, n) < 0.0)\n        rRand = reflect(rRand, n);\n    return rRand;\n}\n\nvec3 heatMap(float x) {\n    if (x < 0.25) return remix(0.0 , 0.25, x, vec3(0.0, 0.0, 0.125), vec3(0.0, 0.0, 1.0));\n    if (x < 0.5)  return remix(0.25, 0.5,  x, vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 0.0));\n    if (x < 0.75) return remix(0.5 , 0.75, x, vec3(0.0, 1.0, 0.0), vec3(1.0, 1.0, 0.0));\n    if (x < 1.0)  return remix(0.75, 1.0,  x, vec3(1.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0));\n    return vec3(1.0, 0.0, 0.0);\n}\n\n","name":"Common","description":"","type":"common"}]}