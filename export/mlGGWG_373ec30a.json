{"ver":"0.1","info":{"id":"mlGGWG","date":"1684532613","viewed":91,"name":"A 3D cube spinning","username":"wednesdei","description":"I was asking ChatGPT4 to help me learn about shaders. After many iterations, and playing around, this is where I decided to call it quits and take a break. Its pretty neat.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["cube","supersampling","rotating"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This is a basic raymarching setup. Raymarching is a technique often used for rendering scenes\n// with complex geometries, usually defined by signed distance functions (SDFs). In this case, the\n// SDF describes a unit cube centered at the origin. The scene is rendered by marching along rays \n// cast from each pixel of the image. This is done in the raymarch function. The rays are generated \n// in the mainImage function, which is the main entry point of the shader.\n// - ChatGPT4 May12 Version\n\nfloat strokeSize = 0.05; // Control the thickness of the edge stroke\n\n// A signed distance function (SDF) for a unit cube centered at origin\nfloat map(vec3 p) {\n    vec3 d = abs(p) - vec3(0.5);  // subtract cube half-dimensions from absolute position\n    // if the point is inside the cube, max(d.x, max(d.y, d.z)) will be negative\n    // otherwise, it will be the shortest distance to the cube\n    // the final step adjusts the distance for the rounded corners and edges of the cube\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nvec3 raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;  // Initialize raymarch distance\n    for (int i=0; i<64; i++) {  // Limit the number of steps to prevent infinite loop\n        vec3 p = ro + rd * t;  // Calculate current ray position\n        float d = map(p);  // Evaluate the SDF at current position\n\n        // When the ray hits the surface (d is close to zero)\n        if (d < 0.01) {\n            // Calculate the gradient (normal) of the SDF by finite differences\n            vec3 normal = normalize(vec3(\n                map(p + vec3(strokeSize, 0.0, 0.0)) - map(p - vec3(strokeSize, 0.0, 0.0)),\n                map(p + vec3(0.0, strokeSize, 0.0)) - map(p - vec3(0.0, strokeSize, 0.0)),\n                map(p + vec3(0.0, 0.0, strokeSize)) - map(p - vec3(0.0, 0.0, strokeSize))\n            ));\n\n            // If the normal and ray direction are facing each other (dot product is positive),\n            // return the edge color, otherwise return the box color.\n            if (dot(normal, rd) > 0.0) {\n                return vec3(0.6, 0.6, 0.6); // edge color\n            } else {\n                return vec3(0.5); // box color\n            }\n        }\n\n        t += d;  // Advance the ray\n\n        // Exit the loop if raymarching took too many steps or has gone too far\n        if (t > 10.0) {\n            break;\n        }\n    }\n\n    return vec3(0.0); // Return background color if no object was hit\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 color = vec4(0.0);  // Initialize final color to black\n    float samples = 4.0;  // Number of samples for super-sampling anti-aliasing (SSAA)\n\n    // Super-sampling loop\n    for(float x = 0.0; x < samples; x++) {\n        for(float y = 0.0; y < samples; y++) {\n            vec2 samplePosition = (fragCoord + vec2(x, y) / samples) / iResolution.xy - vec2(0.5);\n\n            // Compute ray origin (camera position) and direction for the current pixel\n            vec3 ro = vec3(1.5 * cos(iTime/2.0), 1.0, 1.5 * sin(iTime/2.0));  // Rotate the camera around the Y axis\n            vec3 ta = vec3(0.0);  // Target (look-at) position\n            vec3 worldUp = vec3(0.0, 1.0, 0.0);  // Up vector in world space\n\n            // Compute camera basis\n            vec3 cw = normalize(ta - ro);  // Forward vector\n            vec3 cu = normalize(cross(cw, worldUp));  // Right vector\n            vec3 cv = normalize(cross(cu, cw));  // Up vector in camera space\n\n            // Generate ray direction\n            vec3 rd = normalize(cw + samplePosition.x * cu + samplePosition.y * cv);\n\n            vec3 sampleColor = raymarch(ro, rd);  // Raymarch the scene\n\n            color += vec4(sampleColor, 1.0);  // Add color of the current sample\n        }\n    }\n\n    fragColor = color / (samples * samples);  // Average colors of all samples\n}\n","name":"Image","description":"","type":"image"}]}