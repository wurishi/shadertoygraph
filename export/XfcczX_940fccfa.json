{"ver":"0.1","info":{"id":"XfcczX","date":"1730928753","viewed":45,"name":"simple raycast in 2d","username":"coco1001coco","description":"a simple raycast","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["raycast"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BLOCK_SIZE 32\n\nconst int thick = 2;\n\nint level[] = int[](\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,\n    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0,\n    0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0,\n    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0,\n    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0\n);\n\nivec2 level_size = ivec2(13,10);\n\nbool is_out_level(ivec2 pos) {\n    return pos.x < 0 || pos.y < 0 || pos.x >= level_size.x || pos.y >= level_size.y;\n}\n\nbool is_block(ivec2 pos) {\n    if (is_out_level(pos)) {\n        return false;\n    }\n    if (level[pos.x+(pos.y*level_size.x)]==1) {\n        return true;\n    }\n    return false;\n}\n\nbool tolerate(int x) {\n    return x%BLOCK_SIZE < thick || x%BLOCK_SIZE > BLOCK_SIZE - thick;\n}\n\nbool raycast(vec2 original_pos, vec2 pos) {\n    vec2 coef = normalize(iMouse.xy-original_pos);\n    vec2 coef_direction = sign(coef);\n    \n    ivec2 ray = ivec2(original_pos/float(BLOCK_SIZE));\n    \n    vec2 tDelta = abs(vec2(length(coef)) / coef);\n    \n    vec2 map = original_pos/float(BLOCK_SIZE);\n    \n    vec2 sideDist;\n    if (coef_direction.x < 0.0){\n        sideDist.x = (map.x - float(ray.x)) * tDelta.x;\n    } else {\n        sideDist.x = (float(ray.x) + 1.0 - map.x) * tDelta.x;\n    }\n    \n    if (coef_direction.y < 0.0) {\n        sideDist.y = (map.y - float(ray.y)) * tDelta.y;\n    } else {\n        sideDist.y = (float(ray.y) + 1.0 - map.y) * tDelta.y;\n    }\n    \n    while (!is_out_level(ray)) {\n        if (distance(vec2(ray*BLOCK_SIZE), pos) < 5.0) {\n            return true;\n        }\n        if (is_block(ray)) {\n            return false;\n        }\n        if (sideDist.x<sideDist.y) {\n            sideDist.x += tDelta.x;\n            ray.x += int(coef_direction.x);\n        } else {\n            sideDist.y += tDelta.y;\n            ray.y += int(coef_direction.y);\n        }\n    }\n    return false;\n}\n\nbool on_line(vec2 pos) {\n    vec2 original_pos = iResolution.xy/2.0;\n    // vec2 original_pos = vec2(0.0,0.0);\n    // vec2 coef = vec2(max(iMouse.x, original_pos.x)/min(iMouse.x, original_pos.x), max(iMouse.y, original_pos.y)/min(iMouse.y, original_pos.y));\n    \n    // original_pos = vec2(ivec2(original_pos/float(BLOCK_SIZE))*BLOCK_SIZE);\n    vec2 coef = normalize(iMouse.xy-original_pos);\n    coef *= 10.0;\n    vec2 i_pos = original_pos;\n    for (int i= 0; i<1000; i++) {\n        if (distance(i_pos, pos) < 3.0) {\n            return true;\n        }\n        if (is_block(ivec2(i_pos)/BLOCK_SIZE)) {\n            return false;\n        }\n        i_pos+= coef;\n        if (i_pos.x < 0.0 || i_pos.y < 0.0 || i_pos.x > iResolution.x || i_pos.y > iResolution.y) {\n            return false;\n        }\n    }\n    return false;\n}\n\nvec3 get_color_case(ivec2 pos) {\n    if (is_block(pos/BLOCK_SIZE)) {\n        return vec3(0.5, 0.5, 0.5);\n    }\n    return vec3(1.0, 1.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = get_color_case(ivec2(fragCoord));\n    \n    if (tolerate(ivec2(fragCoord).x) || tolerate(ivec2(fragCoord).y)) {\n        col = vec3(0.0, 0.0, 0.0);\n    }\n    \n    if (raycast(iResolution.xy/2.0, fragCoord)) {\n        col = vec3(1.0, 0.0, 0.0);\n    }\n    \n    if (on_line(fragCoord)) {\n        col = vec3(0.0, 0.0, 1.0);;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}