{"ver":"0.1","info":{"id":"ssKGDz","date":"1631823357","viewed":102,"name":"Driving in the Rain","username":"Dave_Green","description":"The Art of Code, Driving home tut","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["rain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define S(a, b, t) smoothstep(a, b, t)\n\nfloat noise(float t)\n{\n    return fract(sin(t*3456.)*6547.);\n}\n\nvec4 noise14(float t)\n{\n    return fract(sin(t*vec4(123., 1024., 3567., 8745.))*vec4(4568., 345, 9821., 8632.));\n}\n\nstruct ray\n{\n    vec3 origin, direction;\n};\n\nray getRay(vec2 uv, vec3 camPos, vec3 lookAt, float zoom)\n{\n    ray a;\n    a.origin = camPos;\n    \n    // Basis vectors for the camera.\n    vec3 forward = normalize(lookAt - camPos);\n    vec3 right = cross(vec3(0., 1., 0.), forward);\n    vec3 up = cross(forward, right);\n    vec3 centerScreen = a.origin + forward*zoom;\n    vec3 intersectionPoint = centerScreen + uv.x*right + uv.y*up;\n    \n    a.direction = normalize(intersectionPoint - a.origin);\n    \n    return a;\n}\n\nvec3 closestPoint(ray r, vec3 point)\n{\n    return r.origin + max(0., dot(point - r.origin, r.direction))*r.direction;\n}\n\nfloat distToRay(ray r, vec3 point)\n{\n    return length(point - closestPoint(r, point));\n}\n\nfloat bokeh(ray r, vec3 point, float size, float blur)\n{\n    float dist = distToRay(r, point);\n    size *= length(point);\n    float s = S(size, size*(1.-blur), dist);\n    s *= mix(.6, 1., S(size*.8, size, dist));\n    return s;\n}\n\nvec3 streetLights(ray r, float time)\n{\n    float side = step(r.direction.x, 0.);\n    r.direction.x = abs(r.direction.x);\n    \n    float s = 1./10.; // 0.1\n    float mask = 0.;\n    for(float i = 0.; i < 1.; i += s)\n    {\n        float ti = fract(time + i + side*s*.5);\n        vec3 point = vec3(2., 2., 100. -ti*100.);\n    \n    \tmask += bokeh(r, point, .05, .1)*ti*ti*ti;\n    }\n    \n    return vec3(1., .5, 0.)*mask;\n}\n\nvec3 envLights(ray r, float time)\n{\n    float side = step(r.direction.x, 0.);\n    r.direction.x = abs(r.direction.x);\n    \n    float s = 1./10.; // 0.1\n    vec3 col_1 = vec3(0.);\n    for(float i = 0.; i < 1.; i += s)\n    {\n        float ti = fract(time + i + side*s*.5);\n        \n        vec4 noise = noise14(i+side*100.);\n        float fade = ti*ti*ti;\n        \n        float occlusion = sin(ti*6.28*10.*noise.x)*.5+.5;\n        \n        fade = occlusion; \n        float x = mix(2.5, 10., noise.x);\n        float y = mix(.1, 1.5, noise.y);\n        vec3 point = vec3(x, y, 50. -ti*50.);\n        \n        vec3 col_2 = noise.wzy;\n    \n    \tcol_1 += bokeh(r, point, .05, .1)*fade*col_2*.5;\n    }\n    \n    return col_1;\n}\n\nvec3 headLights(ray r, float time)\n{\n    time *= 2.;\n    float w1 = .25;\n    float w2 = w1*1.2;\n    float s = 1./30.; // 0.1\n    float mask = 0.;\n    \n    for(float i = 0.; i < 1.; i += s)\n    {\n        float noise = noise(i);\n        \n        if(noise > .1)\n        {\n            continue;\n        }\n        \n        float ti = fract(time + i);\n        float z = 100. -ti*100.;\n        float fade = ti*ti*ti*ti*ti;\n        float focus = S(.8, 1., ti);\n        \n        float size = mix(.05, .03, focus);\n    \tmask += bokeh(r, vec3(-1.-w1, .15, z), size, .1)*fade;\n        mask += bokeh(r, vec3(-1.+w1, .15, z), size, .1)*fade;\n        \n        mask += bokeh(r, vec3(-1.-w2, .15, z), size, .1)*fade;\n        mask += bokeh(r, vec3(-1.+w2, .15, z), size, .1)*fade;\n        \n        float reflection = 0.;\n        reflection += bokeh(r, vec3(-1.-w2, -.15, z), size*3., 1.)*fade;\n        reflection += bokeh(r, vec3(-1.+w2, -.15, z), size*3., 1.)*fade;\n        \n        mask += reflection*focus;\n        \n    }\n    \n    return vec3(.9, .9, 1.)*mask;\n}\n\nvec3 tailLights(ray r, float time)\n{\n    time *= .25;\n    float w1 = .25;\n    float w2 = w1*1.2;\n    float s = 1./15.;\n    float mask = 0.;\n    \n    for(float i = 0.; i < 1.; i += s)\n    {\n        float noise = noise(i);\t\t// At this point noise is between 0 - 1.\n        \n        if(noise > .5)\n        {\n            continue;\n        }\n        \n        // If we get this far we know that noise value is between 0 - 0.5\n        \n        // This says if noise is < 0.25 then lane = 0\n        // If noise is > 0.25 then lane = 1\n        float lane = step(.25, noise);\n        \n        float ti = fract(time + i);\n        float z = 100. -ti*100.;\n        float fade = ti*ti*ti*ti*ti;\n        float focus = S(.9, 1., ti);\n        \n        float size = mix(.05, .03, focus);\n        float laneShift = S(1., .96, ti);\n        float x = 1.5 - lane * laneShift;\n        float indicator = step(0., sin(time*500.))*7.*lane*step(.96, ti);\n        \n        // Left bokeh\n    \tmask += bokeh(r, vec3(x-w1, .15, z), size, .1)*fade;\n        mask += bokeh(r, vec3(x+w1, .15, z), size, .1)*fade;\n        \n        // Right bokeh\n        mask += bokeh(r, vec3(x-w2, .15, z), size, .1)*fade;\n        mask += bokeh(r, vec3(x+w2, .15, z), size, .1)*fade*(1.+ indicator);\n        \n        float reflection = 0.;\n        reflection += bokeh(r, vec3(x-w2, -.15, z), size*3., 1.)*fade;\n        reflection += bokeh(r, vec3(x+w2, -.15, z), size*3., 1.)*(1.+ indicator*.1);\n        \n        mask += reflection*focus;\n        \n    }\n    \n    return vec3(1., .1, .03)*mask;\n}\n\nvec2 rain(vec2 uv, float time)\n{\n    time *= 40.;\n    vec2 a = vec2(3., 1.);\n    vec2 st = uv*a;\n    vec2 id = floor(st);\n    st.y += time*.22;\n    float noise = fract(sin(id.x*76.34)*758.58);\n    st.y += noise;\n    uv.y += noise;\n    uv.x += noise*.08;\n    id = floor(st);\n    st = fract(st)-.5;\n    \n    time += fract(sin(id.x*76.34 +id.y*135.97)*758.58)*6.28;\n    \n    float y = -sin(time+sin(time+sin(time)*.5))*.43;\n    vec2 pos_1 = vec2(0., y);\n    vec2 offset_1 = (st-pos_1)/a;\n    float dist = length((st - pos_1)/a);\n    \n    float mask_1 = S(.07, .0, dist);\n    vec2 offset_2 = (fract(uv*a.x*vec2(1., 2.))-.5)/vec2(1., 2.);\n    \n    dist = length(offset_2);\n    \n    float mask_2 = S(.3*(.5-st.y), .0, dist)*S(-.1, .1, st.y-pos_1.y);\n    //if(st.x > .46 || st.y > .49)\n    //{\n    //    mask_1 = 1.;\n    //}\n    \n    return vec2(mask_1*offset_1*30.+mask_2*offset_2*10.);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv.x -= .75;\n    uv.y -= .35;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    vec3 camPos = vec3(.5, .2, 0.);\n    vec3 lookAt = vec3(.5, .2, 1.);\n    float time = iTime * .04+m.x;\n    \n    //uv.x += sin(uv.y*40.)*.1;\n    \n    vec2 rainDistort = rain(uv*5., time)*.1;\n    rainDistort += rain(uv*9., time)*.45;\n    \n    uv.x += sin(uv.y*20.)*.009;\n    uv.y += sin(uv.y*90.)*.004;\n    ray r = getRay(uv-rainDistort*.5, camPos, lookAt, 2.0);\n    \n    vec3 col = streetLights(r, time);\n    \n    col += headLights(r, time);\n    col += tailLights(r, time);\n    col += envLights(r, time);\n    col += (r.direction.y+.25)*vec3(.2, .1, .5);\n\n    //col = vec3(rainDistort, 0.);\n    // Output to screen\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}