{"ver":"0.1","info":{"id":"tdycWt","date":"1603997067","viewed":103,"name":"donutScanimation","username":"Kaeylos","description":"#8 ray/inverted\nmade during the Ink-MAC-tober 2020","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["motion","imac","scanimation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ----- Ray marching options ----- //\n// #define LOW_QUALITY // if your computer isn't powerful enough\n#ifdef LOW_QUALITY\n    #define MAX_STEPS 30\n#else\n    #define MAX_STEPS 150\n#endif\n#define MAX_DIST 10.\n#define SURF_DIST 0.001\n\n\n// ----- UsefulConstants ----- //\n#define PI  3.14159265358979323846264338327\n\nfloat easeInOutSine(float t) { return -(cos(PI * t) - 1.) / 2.; }\nfloat easeInOutCubic(float t) { return t < 0.5 ? 4. * t * t * t : 1. - pow(-2. * t + 2., 3.) / 2.; }\n\n// ----- Useful functions ----- //\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\nfloat maxComp(vec2 v) { return max(v.x , v.y); }\nfloat maxComp(vec3 v) { return max(max(v.x , v.y), v.z); }\nfloat cro(vec2 a,vec2 b) { return a.x*b.y - a.y*b.x; }\nfloat map(float t, float a, float b) {return a + t * (b - a); } // considering that t is in [0-1]\nfloat map(float t, float a, float b, float c, float d) { return c + (t - a) * (d - c) / (b - a); }\nfloat mult(vec2 v) { return v.x*v.y; }\nfloat mult(vec3 v) { return v.x*v.y*v.z; }\nfloat sum(vec2 v) { return v.x+v.y; }\nfloat sum(vec3 v) { return v.x+v.y+v.z; }\n#define saturate(v) clamp(v, 0., 1.)\n\nfloat torusSDF(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat scene(vec3 p, float time) {\n\tvec3 q = p;\n\tq.xz *= rot(2.*PI*time);\n\tq.yz=rot(PI/8.)*q.yz;\n\treturn torusSDF(q, vec2(1., 0.33));\n}\n\nfloat rayMarching(vec3 O, vec3 D, float time) { // ray origin and dir\n    float t = 0.0;\n    float marchingCount = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++) {\n    \tvec3 p = O + D * t;\n        float d = scene(p, time);\n        \n        // If we are very close to the object, consider it as a hit and exit this loop\n        if( t > MAX_DIST || abs(d) < SURF_DIST*0.99) break;\n        t += d * 1.; // precision handling\n    }\n    if(t > MAX_DIST) t=-1.0;\n    return t;\n}\n    \nvec3 render(vec3 O, vec3 D, float time) { // ray origin and dir\n\t\n    vec3 col = vec3(1.);\n    \n    float d = rayMarching(O, D, time);\n    // draw using depthMap grayscale \n    if( d > 0. ) {\n        col = vec3(pow(map(d, 4., 0.5, 1., 0.), 1.5));\n\t\tcol *= 1.5;\n    }\n\treturn vec3(saturate(col));\n}\n\nvec3 computeCamDir(vec2 uv, vec3 camPos, vec3 camUp, vec3 lookAtPos) {\n\tvec3 camVec = normalize(lookAtPos - camPos);\n\tvec3 sideNorm = normalize(cross(camUp, camVec));\n\tvec3 upNorm = cross(camVec, sideNorm);\n\tvec3 worldFacing = (camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm + uv.y * upNorm;\n\treturn normalize(worldPix - camPos);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\tvec2 Uuv = (fragCoord-.5 * iResolution.xy)/iResolution.y; // uniform uv\n\tvec2 uv = (fragCoord-.5 * iResolution.xy)/iResolution.xy;\n\tvec4 m = iMouse / iResolution.xyxy;\n\n\tvec3 O = vec3(2., 0., 0.); // origin\n\tvec3 D = computeCamDir(Uuv*1.8, O, vec3(0.,1.,0.), vec3(0.)); // dir\n\t\n\tfloat scale = 24.;\n    int imagesNb = 8; // for the whole animation\n    float animationDuration = 2.; // in second\n \n    float po = 0.0;// pattern offset\n    float scaledX = fract(Uuv.x*scale + po);\n\t\n\tfloat time = floor(scaledX*float(imagesNb))/float(imagesNb);\n\tvec3 col = render(O, D, time);\n\t\n\t// col = 1. - col; // negative color\n\t\n\t// ----- Filter ----- //\n    \n    float scaledXAnimated;\n    float x;\n    \n    if(iMouse.z > 0.0f) {\n        scaledXAnimated = fract((Uuv.x-m.x*iResolution.x/iResolution.y)*scale);\n        x = m.x;\n    }else {\n        float slideDuration = 12.; // in second\n        x = fract(iTime/slideDuration)*2.;\n        if (x > 1.) x = 2.- x;\n        x = easeInOutCubic(x);\n        scaledXAnimated = fract((Uuv.x-iTime/(scale*animationDuration))*scale);\n    }\n\n    if(uv.x + 0.5 < x) {\n\t\tfloat frameLength = 1./float(imagesNb);\n    \tcol *= step(scaledXAnimated, frameLength);\n    }\n    \n\n\tfragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}