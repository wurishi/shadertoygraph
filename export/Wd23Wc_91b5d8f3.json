{"ver":"0.1","info":{"id":"Wd23Wc","date":"1550770543","viewed":1219,"name":"Rain in the mud","username":"Gaxil","description":"Procedural raindrops with water flowing on the terrain. Heavy usage of noises with derivatives from IQ","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["water","rain","flowmap","mud"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define WATER_LEVEL 0.075\t\t\t// from -0.2 to 0.2\n#define RAIN_INTENSITY 1.0\n#define RAIN_DROPS_SIZE 96.0\n\nfloat GetHash1D(vec2 p)\n{\n    // from IQ\n\tp  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat Noise1D(vec2 x)\n{\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n   \tf = f*f*(3.0-2.0*f);\n\n\treturn \n\t\tmix(\n\t\t\tmix(GetHash1D(p), GetHash1D(p+vec2(1.0, 0.0)), f.x),\n\t\t\tmix(GetHash1D(p+vec2(0.0, 1.0)), GetHash1D(p+vec2(1.0, 1.0)), f.x),\n\t\t\tf.y);\n}\n\nvec3 GetHash3D( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat Noise3D( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( GetHash3D( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( GetHash3D( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( GetHash3D( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( GetHash3D( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( GetHash3D( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( GetHash3D( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( GetHash3D( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( GetHash3D( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nvec2 GetHash2D( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 Noise2DDer( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = GetHash2D( i + vec2(0.0,0.0) );\n    vec2 gb = GetHash2D( i + vec2(1.0,0.0) );\n    vec2 gc = GetHash2D( i + vec2(0.0,1.0) );\n    vec2 gd = GetHash2D( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\nvec3 GetFBM( vec2 position)\n{\n\tvec3 f = vec3(0.0);\n\n\tvec3 warping = Noise2DDer( position*2.5 )*0.45 + Noise2DDer( position*1.1 ) ;\n\tposition += warping.yz*0.07;\n\n\tvec2 q = vec2(8.0)*position;\n\tf  = vec3(0.5000)*Noise2DDer( q ); q = q*vec2(2.01);\n\tf += vec3(0.2500*Noise2DDer( q )); q = q*vec2(2.02);\n\tf += vec3(0.1250*Noise2DDer( q )); q = q*vec2(2.03);\n\tf += vec3(0.0625*Noise2DDer( q )); q = q*vec2(2.01);\n\tf += vec3(0.03125*Noise2DDer( q )); q = q*vec2(2.02);\n\n\treturn f;\n}\n\n\nvec2 Rotate(vec2 pos, float angle) \n{\n\treturn vec2(\n        pos.x * cos(angle) - pos.y * sin(angle),\n        pos.x * sin(angle) + pos.y * cos(angle)\n    );\n}\n\nvec2 getRainNormal(vec2 position)\n{\n\tfloat gridSize = RAIN_DROPS_SIZE;\n\tvec2 normal2D = vec2(0.0);\n\n\tfor(float i=0.0; i<15.0 * RAIN_INTENSITY; i++)\n\t{\n\t\tvec2 coord = Rotate(position, .25*i) + vec2(3.0, 7.0)*i;\n\t\tvec2 gridPos = round(coord / vec2(gridSize))*vec2(gridSize);\n\t\tfloat offset = GetHash1D(gridPos+vec2(153.0*i, 127.0*i));\n\t\tvec2 delta = gridPos - coord;\n\t\tfloat dist = length(delta);\n\t\tdelta /= dist;\n\t\tdist /= gridSize;\n\t\tfloat mask = 1.0 - clamp((dist)*4.0 - 1.0, 0.0, 1.0);\n\t\toffset = mod(iTime + offset*3.0, 3.0)-1.0;\n\t\tfloat ripple = sin((dist - offset)*60.0);\n\t\tfloat dRipple = cos((dist - offset)*60.0);\n\t\tfloat rippleMask = clamp(abs(dist - offset)*10.0, 0.0, 1.0);\n\t\tfloat height = ((1.0-rippleMask)*1.0) * mask;\n\t\tnormal2D += delta * dRipple * height;\n\t}\n\n\treturn normal2D;\n}\n\nvec3 getWaterNormal(vec2 position)\n{\n\tfloat noiseScale = 0.01;\n\tvec3 bpos = vec3(position.x, position.y, iTime*400.0);\n\tfloat base = Noise3D(bpos*noiseScale);\n\tfloat N = Noise3D((bpos + vec3( 0.0, 10.0, 0.0))*noiseScale);\n\tfloat S = Noise3D((bpos + vec3( 0.0,-10.0, 0.0))*noiseScale);\n\tfloat E = Noise3D((bpos + vec3( 10.0, 0.0, 0.0))*noiseScale);\n\tfloat W = Noise3D((bpos + vec3(-10.0, 0.0, 0.0))*noiseScale);\n\tvec2 baseNormal = vec2((N-base)-(S-base),(E-base)-(W-base))*.6;\n\n\treturn vec3(base, baseNormal.x, baseNormal.y);\n}\n\nvec3 getCheckerBackground(vec2 position)\n{\n\tfloat checkerSize = 64.0;\n\tvec2 checkerPos = round(position / vec2(checkerSize));\n\tfloat checker = step(mod(checkerPos.x + checkerPos.y, 2.0), 0.0);\n\n\treturn mix (vec3(0.3, 0.3, 0.3), vec3(0.7, 0.7, 0.7), checker);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tfragCoord = Rotate(fragCoord - iResolution.xy*0.5, iTime*0.06);\n\tfragCoord += vec2(sin(iTime*0.015), cos(iTime*0.03))*3000.0;\n\n\t// light dir\n\tvec3 l = normalize(vec3(1.0, -1.0, 2.0));\t\n\tl.xy = Rotate(l.xy, iTime*0.06);\n\n\tvec3 groundBase =  GetFBM((fragCoord)*0.0005);\n\tvec3 water = getWaterNormal(fragCoord);\n\tfloat waterDepth = clamp((WATER_LEVEL - water.x*0.02 - groundBase.x), 0.0, 1.0);\n\tvec3 nUnderwater = normalize(vec3(groundBase.y, groundBase.z, 1.0));\n\tfloat diffuseUnderwater = clamp(dot(nUnderwater, l), 0.0, 1.0);\n\tfloat waterLimitSharp = clamp(waterDepth*30.0, 0.0, 1.0);\n\tfloat waterLimitSmooth = clamp(waterDepth*20.0, 0.0, 1.0);\n\tvec2 normal2D = getRainNormal(fragCoord + groundBase.yz*50.0 *(1.0 - waterLimitSharp))*0.5 + water.yz*1.0;\n\n\n\t// flowmap\n\tfloat timing1 = fract(iTime*0.25);\n\tvec3 waterFlowing = Noise2DDer((fragCoord + groundBase.yz*timing1 * 150.0) * 0.07) * (1.0 - abs(timing1*2.0 - 1.0));\n\tfloat timing2 = fract(iTime*0.25 + 0.5);\n\twaterFlowing += Noise2DDer((fragCoord + vec2(500.0) + groundBase.yz*timing2 * 150.0) * 0.07) * (1.0 - abs(timing2*2.0 - 1.0));\n\tfloat flatGround = clamp(dot(normalize(vec3(groundBase.yz, 1.0)), vec3(0.0, 0.0, 1.0)), 0.0, 1.0);\n\twaterFlowing *= 1.0 - flatGround;\n\tnormal2D *= flatGround;\n\n\t// Ground color - mix with water ponds\n\tvec3 ground =  GetFBM((fragCoord + normal2D * 500.0 * waterDepth + waterFlowing.yz * RAIN_INTENSITY * 800.0 * (1.0 - flatGround))*0.0005);\n\tvec3 col = mix (vec3(0.5, 0.3, 0.2), vec3(0.3, 0.25, 0.25), ground.x);\n\tcol = mix (col, mix (vec3(0.4, 0.2, 0.00), vec3(0.0, 0.0, 0.0), waterDepth*3.0), waterLimitSmooth) * diffuseUnderwater;\n\tnormal2D = mix (ground.yz + normal2D*0.1 + waterFlowing.yz * 0.15 * RAIN_INTENSITY, vec2(0.0)+ normal2D, waterLimitSharp);\n\n\tvec3 n = normalize(vec3(normal2D.x, normal2D.y, 1.0));\n\tvec3 v = vec3(0.0, 0.0 ,1.0);\n\n\tvec3 reflect = normalize(2.0 * n - l); \n\tfloat specular = pow(clamp(dot(reflect, v), 0.0, 1.0), 65.0)*3.0;\n\tfloat diffuse = clamp(dot(n, l), 0.0, 1.0);\n\tvec3 light = vec3(specular);\n\n\tcol = col* diffuse + light*0.25;\n\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}