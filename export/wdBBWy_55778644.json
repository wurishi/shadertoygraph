{"ver":"0.1","info":{"id":"wdBBWy","date":"1590705801","viewed":191,"name":"Nicely Lit Hydraulic Terrain","username":"coler706","description":"A lot of stuff from \nhttps://www.shadertoy.com/view/4td3Ws\nAnd IQ sd marching\nAlso wrapping terrain and other tweaks and improvements.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["terrain","water","erosion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 col = vec3(0.0);\n    \n    if( iFrame>0 )\n    {\n        col = texture( iChannel3, uv ).xyz;\n        col /= float(3.0);\n        //col = pow( col, vec3(0.4545) );\n    }\n    \n    \n    // color grading and vigneting\n    col = pow( col, vec3(0.8,0.85,0.9) );\n    \n    col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 hashg( in sampler2D tex ,in vec2 p)\n{\n    vec2 p2=round(mod(mod(p,iResolution.xy)+iResolution.xy,iResolution.xy));\n    return texture(tex,(p2+0.5)/(iResolution.xy));\n}\nvec4 textureN( in sampler2D tex ,in vec2 pg)\n{\n    vec2 p=pg*(iResolution.xy)-0.5;\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\n    return (hashg( tex,i + vec2(1.0,0.0))*f.x+hashg( tex,i + vec2(0.0,0.0))*(1.0-f.x))*(1.0-f.y)+f.y*(hashg( tex,i + vec2(1.0,1.0))*f.x+hashg( tex,i + vec2(0.0,1.0))*(1.0-f.x));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float qq=1.0;\n\n    //current\n    vec4 outflow = textureN(iChannel0, uv);//outflow        \n    vec4 height = textureN(iChannel1, uv);//main haight\n    float totalHeight = height.x + height.y;\n    float waterHeight = height.y;\n\n    //neighbour\n    vec4 heightL = textureN(iChannel1,mod(mod(uv + qq*vec2(-1.0,0.0) / iResolution.yy,1.0)+1.0,1.0));\n    vec4 heightR = textureN(iChannel1,mod(mod(uv + qq*vec2( 1.0,0.0) / iResolution.yy,1.0)+1.0,1.0));\n    vec4 heightB = textureN(iChannel1,mod(mod(uv + qq*vec2(0.0,-1.0) / iResolution.yy,1.0)+1.0,1.0));\n    vec4 heightT = textureN(iChannel1,mod(mod(uv +qq* vec2(0.0, 1.0) / iResolution.yy,1.0)+1.0,1.0));\n    vec4 totalHeightN = vec4(\n        heightL.x + heightL.y, \n        heightR.x + heightR.y, \n        heightB.x + heightB.y, \n        heightT.x + heightT.y\n    );\n\n    //outflowN\n    vec4 outflowL = textureN(iChannel0,mod(mod(uv + qq*vec2(-1.0,0.0) / iResolution.yy,1.0)+1.0,1.0));\n    vec4 outflowR = textureN(iChannel0,mod(mod(uv + qq*vec2( 1.0,0.0) / iResolution.yy,1.0)+1.0,1.0));\n    vec4 outflowB = textureN(iChannel0,mod(mod(uv + qq*vec2(0.0,-1.0) / iResolution.yy,1.0)+1.0,1.0));\n    vec4 outflowT = textureN(iChannel0,mod(mod(uv + qq*vec2(0.0,1.0) / iResolution.yy,1.0)+1.0,1.0));\n\n    //\n    vec4 diffHeight = (vec4(totalHeight).xxxx - totalHeightN);\n\n    //damp\n    float flowdamp = 1.0;\n\n    float flowSpeed = 0.125;\n\n    vec4 distance = sqrt(diffHeight * diffHeight/100.0  + 1.0 * 1.0);\n\n\n    //\n    outflow *= flowdamp;\n    outflow += diffHeight * flowSpeed / distance;\n    outflow = max(outflow, vec4(0.00000000000001));\n\n    //\n    float outflowScale = waterHeight / (outflow.x + outflow.y + outflow.z + outflow.w);\n    outflowScale = min(1.0, outflowScale);\n    outflow *= outflowScale;\n\n    fragColor = outflow;\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define _EvaporateSpeed 0.0005\n#define _RainSpeed 0.000005\n#define _StartWater 0.001\n\nfloat seed = 1.0;\nvec2 hash( vec2 p,vec2 md )\n{\n    p=floor(mod(mod(p,md)+md,md));\n    p = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*(43758.5453123 * seed));\n}\n\nfloat noise( in vec2 p ,in vec2 md)\n{\n    \n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( p + vec2(0.0,0.0) ,md), f - vec2(0.0,0.0) ), \n                     dot( hash( p + vec2(1.0,0.0),md ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( p + vec2(0.0,1.0) ,md), f - vec2(0.0,1.0) ), \n                     dot( hash( p + vec2(1.0,1.0) ,md), f - vec2(1.0,1.0) ), u.x), u.y);\n}\nvec4 hashg( in sampler2D tex ,in vec2 p)\n{\n    vec2 p2=round(mod(mod(p,iResolution.xy)+iResolution.xy,iResolution.xy));\n    return texture(tex,(p2+0.5)/(iResolution.xy));\n}\nvec4 textureN( in sampler2D tex ,in vec2 pg)\n{\n    vec2 p=pg*(iResolution.xy)-0.5;\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\n    return (hashg( tex,i + vec2(1.0,0.0))*f.x+hashg( tex,i + vec2(0.0,0.0))*(1.0-f.x))*(1.0-f.y)+f.y*(hashg( tex,i + vec2(1.0,1.0))*f.x+hashg( tex,i + vec2(0.0,1.0))*(1.0-f.x));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvLastInfo0 = vec2(0.5,0.5) / iResolution.yy;\n    vec4 lastResolution = textureN(iChannel2, uvLastInfo0);\n    if(iFrame == 0|| iMouse.z>0.5){\n        seed = mod(iTime*71.0,123.0);\n        vec2 qv=uv*iResolution.yy;\n        float h = 0.0;\n        float size = ceil(iResolution.y/480.0)/iResolution.y;\n        float scale = 1.0/480.0/size*0.5;\n        for(int i =0; i<15; i++){\n            h += (noise(qv* size,(iResolution.yy)*size) + 0.5) * scale;\n            size *= 2.0;\n            scale *= 0.5;\n        }\n        fragColor = vec4(h,_StartWater,0.0,h);\n        return;\n    }\n    else{\n    \tfloat qq=1.0;\n        //current\n        vec4 outflow = textureN(iChannel0, uv);//outflow\n        vec4 height = textureN(iChannel1, uv);//main\n        float terrainHeight = height.x;\n        float waterHeight = height.y;\n        float totalHeight = terrainHeight + waterHeight;\n\n        //neighbour\n        vec4 heightL = textureN(iChannel1,mod(mod(uv + qq*vec2(-1.0,0.0) / iResolution.yy,1.0)+1.0,1.0));\n    vec4 heightR = textureN(iChannel1,mod(mod(uv + qq*vec2( 1.0,0.0) / iResolution.yy,1.0)+1.0,1.0));\n    vec4 heightB = textureN(iChannel1,mod(mod(uv + qq*vec2(0.0,-1.0) / iResolution.yy,1.0)+1.0,1.0));\n    vec4 heightT = textureN(iChannel1,mod(mod(uv +qq* vec2(0.0, 1.0) / iResolution.yy,1.0)+1.0,1.0));\n        vec4 terrainN = vec4(heightL.x, heightR.x, heightB.x, heightT.x);\n        vec4 waterN = vec4(heightL.y, heightR.y, heightB.y, heightT.y);\n        vec4 sedimentN = vec4(heightL.z, heightR.z, heightB.z, heightT.z);\n   \t\tvec4 fluidN = waterN + sedimentN;\n\n        //inflow\n        vec4 outflowL = textureN(iChannel0,mod(mod(uv + qq*vec2(-1.0,0.0) / iResolution.yy,1.0)+1.0,1.0));\n    vec4 outflowR = textureN(iChannel0,mod(mod(uv + qq*vec2( 1.0,0.0) / iResolution.yy,1.0)+1.0,1.0));\n    vec4 outflowB = textureN(iChannel0,mod(mod(uv + qq*vec2(0.0,-1.0) / iResolution.yy,1.0)+1.0,1.0));\n    vec4 outflowT = textureN(iChannel0,mod(mod(uv + qq*vec2(0.0,1.0) / iResolution.yy,1.0)+1.0,1.0));\n        vec4 inflow = vec4(outflowL.y, outflowR.x, outflowB.w, outflowT.z);\n\n        ////suspended\n        vec2 fluxOutflow = vec2(outflow.y - outflow.x, outflow.w - outflow.z);\n        vec2 fluxInflow = vec2(inflow.x - inflow.y, inflow.z - inflow.w);\n        vec2 flux = (fluxInflow + fluxOutflow) * 0.5 ;//\n        vec2 velocity = flux / (height.y + 0.000000001);\n\n        float sediment = height.z + dot(inflow * sedimentN / (waterN + vec4(0.000000001)), vec4(1));\n        sediment -= dot(outflow,vec4(1)) * height.z / (height.y + 0.000000001);\n        sediment = max(0.000000001, sediment);\n\n        //float4 srcHeight = tex2D(_MainTex, i.uv - flux * _MainTex_TexelSize.xy * 1000);\n        //float4 srcHeight = tex2D(_MainTex, i.uv - velocity * _MainTex_TexelSize.xy * 1);\n        //float suspendedSolid = height.z;\n\n        vec4 forwardHeight = textureN(iChannel1, mod(mod(uv + normalize(flux) * 1.0 / iResolution.yy,1.0)+1.0,1.0));\n        float abrupt = (height.x - forwardHeight.x) * (1.0 + height.w * 5.0);\n        float newCapacity = (abrupt + 0.0005) * pow(length(flux),1.0) * 10.0;\n        newCapacity = clamp(newCapacity,0.0,height.y * 0.5);\n\n        //update water\n        vec4 diffFlow = inflow - outflow;\n        waterHeight += dot(diffFlow,vec4(1.0));\n\n        //evaporate and rain\n        float x = 1.0 - (1.0 / (waterHeight * 10.0 + 1.0));//\n        waterHeight -= _EvaporateSpeed * x * 3.0;\t//evaporate\n        waterHeight += _RainSpeed;\t\t\t//rain\n        waterHeight = max(waterHeight, 0.0);\n\n        //update terrain height\n        float newTerrainHeight = height.x + (sediment - newCapacity);\n        //newTerrainHeight = lerp(newTerrainHeight,dot(terrainN,(1).xxxx) * 0.25,0.01);\n        newTerrainHeight = max(0.0, newTerrainHeight);\n        float sedimentChange = height.x - newTerrainHeight;\n        float newSuspendedSolid = sediment + sedimentChange;\n        waterHeight += sedimentChange;\n\n        fragColor = vec4(newTerrainHeight, waterHeight, newSuspendedSolid, mix(height.w,height.x,0.01));\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define PI 3.14159265359\nvec4 hashg( in sampler2D tex ,in vec2 p)\n{\n    vec2 p2=round(mod(mod(p,iResolution.xy)+iResolution.xy,iResolution.xy));\n    return texture(tex,(p2+0.5)/(iResolution.xy));\n}\nvec4 textureN( in sampler2D tex ,in vec2 pg)\n{\n    vec2 p=pg*(iResolution.xy)-0.5;\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\n    return (hashg( tex,i + vec2(1.0,0.0))*f.x+hashg( tex,i + vec2(0.0,0.0))*(1.0-f.x))*(1.0-f.y)+f.y*(hashg( tex,i + vec2(1.0,1.0))*f.x+hashg( tex,i + vec2(0.0,1.0))*(1.0-f.x));\n}\n\n\nfloat terrainH( in vec2 p)\n{\n    //return noise(p);\n    //p=p*1.0;\n    vec2 uv = p * 50.0 + vec2(0.15);\n    uv/=iResolution.y;\n        uv=mod(uv,1.0);\n    //if((uv.x > 0.0 && uv.x < 1.0 && uv.y > 0.0 && uv.y < 1.0) ||true){\n    \t//uv.x /= iResolution.x/iResolution.y;\n\t\tvec4 height = textureN(iChannel1,uv );//main haight\n    \tfloat h = height.x + height.y-0.5;\n    \treturn h * 6.0;\n   // }\n    //else{\n        return -1000.0;\n    //}\n}\n\n\n\n// Created by inigo quilez - iq/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n// Pathtrace the scene. One path per pixel. Samples the sun light and the\n// sky dome light at each vertex of the path.\n\n// More info here: https://iquilezles.org/articles/simplepathtracing\n\n\n//------------------------------------------------------------------\n\nfloat hash(float seed)\n{\n    return fract(sin(seed)*43758.5453 );\n}\n\nvec3 cosineDirection( in float seed, in vec3 nor)\n{\n    float u = hash( 78.233 + seed);\n    float v = hash( 10.873 + seed);\n\n    \n    // Method 1 and 2 first generate a frame of reference to use with an arbitrary\n    // distribution, cosine in this case. Method 3 (invented by fizzer) specializes \n    // the whole math to the cosine distribution and simplfies the result to a more \n    // compact version that does not depend on a full frame of reference.\n\n    #if 0\n        // method 1 by http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content\n        vec3 tc = vec3( 1.0+nor.z-nor.xy*nor.xy, -nor.x*nor.y)/(1.0+nor.z);\n        vec3 uu = vec3( tc.x, tc.z, -nor.x );\n        vec3 vv = vec3( tc.z, tc.y, -nor.y );\n\n        float a = 6.2831853 * v;\n        return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n    #endif\n\t#if 0\n    \t// method 2 by pixar:  http://jcgt.org/published/0006/01/01/paper.pdf\n    \tfloat ks = (nor.z>=0.0)?1.0:-1.0;     //do not use sign(nor.z), it can produce 0.0\n        float ka = 1.0 / (1.0 + abs(nor.z));\n        float kb = -ks * nor.x * nor.y * ka;\n        vec3 uu = vec3(1.0 - nor.x * nor.x * ka, ks*kb, -ks*nor.x);\n        vec3 vv = vec3(kb, ks - nor.y * nor.y * ka * ks, -nor.y);\n    \n        float a = 6.2831853 * v;\n        return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n    #endif\n    #if 1\n    \t// method 3 by fizzer: http://www.amietia.com/lambertnotangent.html\n        float a = 6.2831853 * v;\n        u = 2.0*u - 1.0;\n        return normalize( nor + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n    #endif\n}\n\n//------------------------------------------------------------------\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\nfloat map( vec3 p )\n{\n    vec3 w = p;\n    vec3 q = p;\n\n    q.xz = mod( q.xz+1.0, 2.0 ) -1.0;\n    \n    float d = (p.y-terrainH(p.xz));\n    d=d*min(max(abs(d),0.001)*1000.0,0.125);\n    //d=d*d*10.0;\n\n    \n   return d;\n}\n\n//------------------------------------------------------------------\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.0001,0.0,0.0);\n\n    return normalize( vec3(\n      map( pos+eps.xyy ) - map( pos-eps.xyy ),\n      map( pos+eps.yxy ) - map( pos-eps.yxy ),\n      map( pos+eps.yyx ) - map( pos-eps.yyx ) ) );\n}\nvec4 terrainColor(in vec2 p)\n{\n    vec3 norm=calcNormal(vec3(p.x,terrainH(p),p.y));\n    vec4 sandColor = vec4(0.9,0.70,0.4,0.0);//w is glossiness\n    vec4 waterColor = vec4(0.9,0.9,1.0,1.0);\n    //vec3 stoneColor = vec3(0.4,0.4,0.4);\n    vec4 stoneColor = vec4(textureN(iChannel0,p).rgb * 0.5+0.5,0.1);\n    vec4 grassColor = vec4(0.2,0.4,0.0,0.1);\n    \n    vec2 uv = p * 50.0 + vec2(0.15);\n    uv/=iResolution.y;\n    //uv.x /= iResolution.x/iResolution.y;\n\tuv=mod(uv*1.0,1.0);\n    vec4 height = textureN(iChannel1,uv );\n    float erosion = height.w + height.z - height.x;\n    vec4 color = mix(sandColor,grassColor,clamp(pow(-(height.y - 0.001) * 8000.0,3.0)+1000000.0,0.0,1.0));\n    color = mix(color,stoneColor,pow(clamp(erosion * 18000.0,0.0,1.0),6.0)>0.5?1.0:0.);\n    color = mix(color,waterColor,pow(clamp(height.y * 400.0,0.0,1.0),3.0)>0.99?1.0:0.0); \n    return color;\n\n}\n\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n    float res = -1.0;\n    float tmax = 20.0;\n    float t = 0.01;\n    for(int i=0; i<512; i++ )\n    {\n        float h = map(ro+rd*t);\n        if( h<0.001 || t>tmax ) break;\n        t +=  h;\n    }\n    \n    if( t<tmax ) res = t;\n\n    return res;\n}\n\nfloat shadow( in vec3 ro, in vec3 rd )\n{\n    float res = 0.0;\n    \n    float tmax = 10.0;\n    \n    float t = 0.001;\n    for(int i=0; i<200; i++ )\n    {\n        float h = map(ro+rd*t);\n        if( h<0.0001 || t>tmax) break;\n        t += h;\n    }\n\n    if( t>tmax ) res = 1.0;\n    \n    return res;\n}\n\n\nvec3 sunDir = normalize(vec3(-1.3,1.3,0.1));\nvec3 sunCol =  6.0*vec3(1.0,0.8,0.6);\nvec3 skyCol =  4.0*vec3(0.2,0.35,0.5);\n\n\nvec3 calculateColor(vec3 ro, vec3 rd, float sa )\n{\n    const float epsilon = 0.0001;\n\n    vec3 colorMask = vec3(1.0);\n    vec3 accumulatedColor = vec3(0.0);\n\n    float fdis = 0.0;\n    for( int bounce = 0; bounce<2; bounce++ ) // bounces of GI\n    {\n        rd = normalize(rd);\n       \n        //-----------------------\n        // trace\n        //-----------------------\n        float t = intersect( ro, rd );\n        if( t < 0.0 )\n        {\n            if( bounce==0 ) return mix( vec3(0.9,1.0,1.0)*2.0, skyCol, smoothstep(0.1,0.25,rd.y) );\n            break;\n        }\n\n        if( bounce==0 ) fdis = t;\n\n        vec3 pos = ro + rd * t;\n        vec3 nor = calcNormal( pos );\n        vec4 su=terrainColor(pos.xz);\n        vec3 surfaceColor = su.xyz;//vec3(0.4)*vec3(1.2,1.1,1.0);\n        float glossiness = su.w;\n\n        //-----------------------\n        // add direct lighitng\n        //-----------------------\n        colorMask = surfaceColor*colorMask;\n\n        vec3 iColor = vec3(0.0);\n\n        // light 1        \n        float sunDif =  max(0.0, dot(sunDir, nor));\n        float sunSha = 1.0; if( sunDif > 0.00001 ) sunSha = shadow( pos + nor*epsilon, sunDir);\n        iColor += sunCol * sunDif * sunSha*(1.0-glossiness);\n        // todo - add back direct specular\n\n        // light 2\n        vec3 skyPoint = cosineDirection( sa + 7.1*float(iFrame) + 5681.123 + float(bounce)*92.13, nor);\n        float skySha = shadow( pos + nor*epsilon, skyPoint);\n        iColor += skyCol * skySha;\n       \n\n        accumulatedColor += colorMask * iColor;\n\n        //-----------------------\n        // calculate new ray\n        //-----------------------\n        float isDif = 0.8+100.0;\n        if( hash(sa + 1.123 + 7.7*float(bounce)) < isDif && false )\n        {\n           rd = cosineDirection(76.2 + 73.1*float(bounce) + sa + 17.7*float(iFrame), nor);\n        }\n        else\n        {\n            \n            rd = cosineDirection(76.2 + 73.1*float(bounce) + sa + 17.7*float(iFrame), nor)*(1.0-glossiness)+normalize(reflect(rd, nor))*glossiness;\n            //rd =  cosineDirection(sa + 111.123 + 65.2*float(bounce),normalize(reflect(rd, nor))) * glossiness;\n        }\n\n        ro = pos;\n   }\n\n   float ff = exp(-0.001*fdis*fdis);\n   accumulatedColor *= ff; \n   accumulatedColor += (1.0-ff)*vec3(0.9,1.0,1.0)*2.0;\n\n   return accumulatedColor;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in float cr )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sa = hash( dot( fragCoord, vec2(12.9898, 78.233) ) + 1113.1*float(iFrame) );\n    \n    vec2 of = -0.5 + vec2( hash(sa+13.271), hash(sa+63.216) );\n    vec2 p = (-iResolution.xy + 2.0*(fragCoord+of)) / iResolution.y;\n\n    vec3 ro = vec3(0.0,0.0,0.0);\n    ro.y=2.5;//terrainH(ro.xz)+0.25;\n        vec3 ta=ro+vec3(1.5,-2.0,1.5);\n   \n    mat3  ca = setCamera( ro, ta, 0.0 );\n    vec3  rd = normalize( ca * vec3(p,-1.3) );\n\n    vec3 col = texture( iChannel2, fragCoord/iResolution.xy ).xyz*0.9;\n    if( iFrame==0 ) col = vec3(0.0);\n    \n    col += calculateColor( ro, rd, sa )*0.1;\n\n    fragColor = vec4( col, 1.0 );\n}","name":"Buffer C","description":"","type":"buffer"}]}