{"ver":"0.1","info":{"id":"Ms33Rn","date":"1447645743","viewed":191,"name":"Moderate Raymarcher","username":"jackdavenport","description":"Two raymarched spheres, intersecting with each other, with soft shadows.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define MAX_ITERATIONS 256\n#define MIN_DISTANCE  .001\n\n#define SUN_DIR vec3(45., 90., -45.)\n\nstruct Ray {\nvec3 ori;\nvec3 dir;\n};\nstruct Dist {\nfloat dst;\nint id;\n};\nstruct Hit {\nvec3 p;\nDist dist;\n};\n\nfloat distPlane(vec3 p, float y) {\n\n    return p.y - y;\n    \n}\n    \nfloat distBall(vec3 p, vec3 pos, float radius) {\n\n    return length(pos - p) - radius;\n    \n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n    \nDist distScene(vec3 p) {\n \n    float s = .4 * sin(iTime);\n    \n    float ball1 = distBall(p, vec3(-.5, s,0.), .6);\n    float ball2 = distBall(p, vec3(.5,-s,0.), .6);\n    float balls = smin(ball1, ball2, .3);\n    \n    float pln   = distPlane(p, -1.);\n    \n    float dst = min(balls, pln);\n    return Dist(dst, dst == balls ? 0 : 1);\n    \n}\n\nHit raymarch(Ray ray) {\n \n    vec3 p = ray.ori;\n    Dist d = Dist(0., -1);\n    \n    for(int i = 0; i < MAX_ITERATIONS; i++) {\n     \n        Dist dst = distScene(p);\n        p += ray.dir * dst.dst;\n        \n        if(dst.dst <= MIN_DISTANCE) {\n         \n            d = dst;\n            break;\n            \n        }\n        \n    }\n    \n    return Hit(p,d);\n    \n}\n\n// Borrowed from iq's Primitives\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    distScene(pos+eps.xyy).dst - distScene(pos-eps.xyy).dst,\n\t    distScene(pos+eps.yxy).dst - distScene(pos-eps.yxy).dst,\n\t    distScene(pos+eps.yyx).dst - distScene(pos-eps.yyx).dst);\n\treturn normalize(nor);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat lighting(vec3 p, vec3 n, vec3 ld) {\n        \n    const float amb = 0.;\n    \n    vec3 l = normalize(ld);\n    float df = amb + max(dot(l,n), 0.);\n        \n    float sf = 0.;\n    int i = 0;\n    \n    for(int j = 0; j < 16; j++) {\n     \n        vec3 sd = l + .1 * rand(vec2(p.x+p.y+p.z,float(j)+iTime));\n        \n        Ray sr = Ray(p + (sd * .01), sd);\n    \tHit sh = raymarch(sr);\n    \tif(sh.dist.id != -1) sf += 1.;\n        \n        i++;\n        \n    }\n    \n    sf /= float(i);\n    return df * (1. - sf);\n    \n}\n\nvec3 clearColor(vec3 dir) {\n \n    return texture(iChannel0, dir).xyz;\n    \n}\n\nvec3 shade(Ray ray) {\n \n    Hit scene = raymarch(ray);\n    \n    if(scene.dist.id == 0) {\n     \n        vec3 n = calcNormal(scene.p);\n        vec3 rd = normalize(reflect(ray.dir,n));\n        vec3 sc = vec3(1.) * max(pow(dot(rd,normalize(SUN_DIR)), 25.), 0.);\n        \n        vec3 col = mix(clearColor(rd), vec3(.8,.2,.2), .5);\n        return (col + sc) * lighting(scene.p, n, SUN_DIR);\n        \n    } else if(scene.dist.id == 1) {\n\n        vec3 n = calcNormal(scene.p);\n        return vec3(lighting(scene.p, n, SUN_DIR));\n        \n    }\n    \n    return clearColor(ray.dir);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy / 2.) / iResolution.y;\n    \n    vec3 ori = vec3(0., -.2, -2.);\n    vec3 dir = vec3(uv, 1.);\n    \n    ori.z -= distScene(ori).dst;\n    \n    vec3 col = shade(Ray(ori,dir));\n    fragColor = vec4(col, 1.);\n}","name":"","description":"","type":"image"}]}