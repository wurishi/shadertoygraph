{"ver":"0.1","info":{"id":"ttSfzt","date":"1599597439","viewed":116,"name":"Hexagon pixelation 1","username":"Zumer_Vlad","description":"based on : https://www.shadertoy.com/view/wtSfzt\n\ngive the hexagons bands proper uvs","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["hexagon","pixelation","hexuv"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// by Vlad-Alexandru Zumer\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define sqrt3 \t\t1.732\n#define half_sqrt3\t0.866\n\nfloat HexDist(vec2 p) {\n\tp = abs(p);\n    \n    float c = dot(p, normalize(vec2(1,sqrt3)));\n    c = max(c, p.x);\n    \n    return c;\n}\n\nstruct hexCoordsOuts\n{\n  vec2 UV;\n  vec2 ID;\n};\n\nhexCoordsOuts HexCoords(vec2 uv) {\n\t\n    vec2 r = vec2(1, sqrt3); // 1, sqrt3\n    vec2 h = r*.5;\n    \n    vec2 a = mod(uv, r)-h; // tile UV coords and move 0,0 to center of tile\n    vec2 b = mod(uv-h, r)-h; // move uv coords, tile and move 0,0 to centre of tile\n    \n    float isB = dot(a, a) < dot(b,b) ? 0. : 1.;\n    vec2 gv = (1.-isB)*a + isB*b; // select which tile are in based on distance from the origin of the tile\n    \n    \n    // fix UVs back to square\n    gv.y = gv.y*h.y;\n    gv += 0.5;\n    \n    //ids\n    float x_id = floor(uv.x+isB*0.5/1.);\n    float y_id = isB * 2.*floor((uv.y+ half_sqrt3)/sqrt3) + (1.-isB)* (2.*floor((uv.y)/sqrt3)+1.);\n        \n    return hexCoordsOuts(gv, vec2(x_id,y_id));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 uvBoundsMin = (vec2(0)-.5*iResolution.xy)/iResolution.y;\n    vec2 uvBoundsMax = (iResolution.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    \n    float size = 40.; //1.154; //30.*sin(iTime)+30.;\n    \n    uv *= size;\n    //uv += .5*size*(iResolution.xy/iResolution.y);\n    \n    uvBoundsMin *=size;\n    uvBoundsMax *=size;\n        \n    hexCoordsOuts hco = HexCoords(uv);\n    \n    // get hex id for that started as pixel 0,0\n    hexCoordsOuts aux = HexCoords(uvBoundsMin);\n    uvBoundsMin = aux.ID;\n    \n    // get hex id for that started as pixel iResolution\n    aux = HexCoords(uvBoundsMax);\n    uvBoundsMax = aux.ID;\n    \n    // max - min + 1\n    vec2 bounds = uvBoundsMax - uvBoundsMin + vec2(1.);\n    \n    vec2 remappedIDs = floor(hco.ID+.5*bounds);\n    \n    col += vec3(remappedIDs/bounds,0.);\n    \n    col = texture(iChannel0,remappedIDs/bounds).rgb;\n    \n    if(abs(remappedIDs.y - floor(mod(1.5*iTime,8.)*bounds.y)) <= 1. || \n       abs(remappedIDs.y - floor(mod(1.51*iTime,8.)*bounds.y)) <= 0.001)\n    {\n        col *= vec3(.4,.0,.9);\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}