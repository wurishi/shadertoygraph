{"ver":"0.1","info":{"id":"4ltSzX","date":"1480876028","viewed":158,"name":"#Devember 2016 - day 03","username":"theGiallo","description":"First attempt at ray-marching a distance field.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","learning","devember"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SQRT2 1.4142135623730950488016887242096980785696\n#define PI    3.1415926535897932384626433832795\n#define HPI   1.57079632679489661923132169\n#define QPI   0.785398163397448309615660845819875721\n#define TAU   6.283185307179586476925286766559\n\nfloat\nmanhattan( vec2 p )\n{\n    p = abs ( p );\n    float ret = p.x + p.y;\n    return ret;\n}\nfloat\nmanhattan( vec2 p0, vec2 p1 )\n{\n    float ret;\n    \n    vec2 d = abs ( p1 - p0 );\n    ret = d.x + d.y;\n    \n    return ret;\n}\nvec4\ncircle( vec4 color, vec2 pos, float radius, float border_width, vec2 point )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float dist = length( point - pos );\n    ret = color * (1.0 - smoothstep( radius, radius + border_width, dist ) );\n    \n    return ret;\n}\nvec4\nsquare( vec4 color, vec2 pos, float side, float border_width, float rot_rad, vec2 point )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float max_d = SQRT2 * side;\n    vec2 rd = point - pos;\n    float tot_rad = QPI + rot_rad;\n    vec2 rd_rot;\n    rd_rot.x = rd.x * cos( tot_rad ) + rd.y * sin( tot_rad );\n    rd_rot.y = rd.x * sin( tot_rad ) - rd.y * cos( tot_rad );\n    float dist = manhattan( rd_rot );\n    ret = color * (1.0 - smoothstep( max_d, max_d + border_width, dist ) );\n    \n    return ret;\n}\nvec4\nsquare_tex( vec4 color, vec2 pos, float side, float border_width, float rot_rad, vec2 point, sampler2D tex )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float max_d = SQRT2 * side;\n    vec2 rd = point - pos;\n    float tot_rad = QPI + rot_rad;\n    vec2 rd_rot;\n    rd_rot.x = rd.x * cos( tot_rad ) + rd.y * sin( tot_rad );\n    rd_rot.y = rd.x * sin( tot_rad ) - rd.y * cos( tot_rad );\n    float dist = manhattan( rd_rot );\n    ret = color * (1.0 - smoothstep( max_d, max_d + border_width, dist ) );\n    ret *= texture( tex, rd_rot * (0.5 / side ) + 0.5 );\n    \n    return ret;\n}\n\n// NOTE(theGiallo): pre-multiplied alpha\nvoid\nblend_pma( inout vec4 dst, in vec4 src )\n{\n    dst.rgb = src.rgb + dst.rgb * ( 1.0 - src.a );\n    dst.a = min( 1.0, dst.a + src.a );\n}\n\nfloat\nmirror( float x )\n{\n    x *= 0.5;\n    return 1.0 - abs( 2.0 * ( x - floor(x) ) - 1.0 );\n}\n\nfloat\ndecimal( float x )\n{\n    return x - floor(x);\n}\n\n// NOTE(theGiallo): h in [0,1)\nvec4\nrgb_from_hsv( vec4 hsv )\n{\n\tvec4 ret;\n\tret.a = hsv.a;\n\tfloat c = hsv.g * hsv.b;\n\tfloat hh = hsv.r * 6.0;\n\n\tfloat x = c * ( 1.0 - abs( hh - 2.0 * floor( hh / 2.0 ) - 1.0 ) );\n\n\tif ( hh < 1.0 || hh >= 6.0 )\n\t{\n\t\tret.r = c;\n\t\tret.g = x;\n\t\tret.b = 0.0;\n\t} else\n\tif ( hh < 2.0 )\n\t{\n\t\tret.r = x;\n\t\tret.g = c;\n\t\tret.b = 0.0;\n\t} else\n\tif ( hh < 3.0 )\n\t{\n\t\tret.r = 0.0;\n\t\tret.g = c;\n\t\tret.b = x;\n\t} else\n\tif ( hh < 4.0 )\n\t{\n\t\tret.r = 0.0;\n\t\tret.g = x;\n\t\tret.b = c;\n\t} else\n\tif ( hh < 5.0 )\n\t{\n\t\tret.r = x;\n\t\tret.g = 0.0;\n\t\tret.b = c;\n\t} else\n\tif ( hh < 6.0 )\n\t{\n\t\tret.r = c;\n\t\tret.g = 0.0;\n\t\tret.b = x;\n\t}\n\n\tfloat m = hsv.b - c;\n\tret.r += m;\n\tret.g += m;\n\tret.b += m;\n\n\treturn ret;\n}\n\n#define ORANGE_RGB vec3(1.0,0.4,0.0)\n#define T_EPS 0.001\n\nfloat\nsphere_distance( in vec3 sph_c, in float sph_r, in vec3 p )\n{\n    return length( p - sph_c ) - sph_r;\n}\n\nvec4\nunion_op( vec4 v0, vec4 v1 )\n{\n    if ( v0.x < v1.x )\n    {\n        return v0;\n    }\n    return v1;\n}\n\nvec4\nmap( in vec3 pos )\n{\n    float r = 1.1;\n    float h = decimal( ( floor( pos.x / r + 0.5 ) + 50.0 ) / 10.0 );\n    float s = mirror( ( floor( pos.s / r + 0.5 ) + 50.0 ) / 30.0 );\n    vec3 color = rgb_from_hsv( vec4( h, s, 1.0, 1.0 ) ).rgb;\n    pos.x = mirror( pos.x / r ) * r;\n    pos.y = mirror( pos.y / r ) * r;\n\n    float sr = 0.5;\n    float sd = 0.5;\n    vec4 res;\n    res = union_op( vec4( sphere_distance( sd * vec3(0.0, cos( HPI             ), sin( HPI             ) ), sr, pos ), color ),\n                    vec4( sphere_distance( sd * vec3(0.0, cos( HPI + TAU / 3.0 ), sin( HPI + TAU / 3.0 ) ), sr, pos ), color ) );\n    res = union_op( vec4( sphere_distance( sd * vec3(0.0, cos( HPI - TAU / 3.0 ), sin( HPI - TAU / 3.0 ) ), sr, pos ), color ), res );\n\treturn res;\n}\n\nvec3\ncalc_normal( in vec3 pos, in float t )\n{\n    vec3 eps = vec3( max(0.02,T_EPS*t),0.0,0.0);\n\treturn normalize( vec3(\n           map( pos + eps.xyy ).x - map( pos - eps.xyy ).x,\n           map( pos + eps.yxy ).x - map( pos - eps.yxy ).x,\n           map( pos + eps.yyx ).x - map( pos - eps.yyx ).x ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 qc = 2.0 * q - 1.0;\n\tvec2 p = ( 2.0 * fragCoord.xy - iResolution.xy ) / min( iResolution.y, iResolution.x );\n    vec4 col = vec4(0);\n        \n    vec3 sun_light_dir = normalize( vec3( 0.0, 1.0, 0.0 ) );\n    \n    float img_plane_dist = 0.05;\n    float img_scale = 0.1;\n    float time = iTime * PI * 0.125;\n    float d0 = 1.2;\n    vec3 camera_pos = vec3(cos(time) * d0, sin(time) * d0,1.0);\n    vec3 look = normalize( -camera_pos );\n    camera_pos.z += 3.0;\n    vec3 up = vec3(0.0,0.0,1.0);\n    vec3 right = cross( look, up );\n    vec3 img_up = cross( right, look );\n    vec3 dir = look * img_plane_dist + right * p.x * img_scale + img_up * p.y * img_scale;\n    vec3 start = camera_pos + dir;\n    dir = normalize( dir );\n    vec4 distance_color;\n    float t = 0.0, t_max = 1e2;\n    for ( int it=0; it!=120; ++it )\n    {\n        vec3 here = start + dir * t;\n        distance_color = map( here );\n        if ( distance_color.x < ( T_EPS * t ) || t > t_max )\n        {\n        \tbreak;\n        }\n        t += distance_color.x;\n    }\n    if ( t > t_max )\n    {\n        t = -1.0;\n    }\n    if ( t > 0.0 )\n    {\n        vec3 point = start + dir * t;\n        vec3 normal = calc_normal( point, t );\n        col.rgb = 0.5 + normal * 0.5;\n        float diffuse = max( 0.0, dot( normal, -sun_light_dir ) );\n        float spec = pow( max( 0.0, dot( reflect( dir, normal ) , -sun_light_dir ) ), 15.0 );\n        float ambient = 0.3;\n        col.rgb = ( diffuse + ambient ) * distance_color.yzw + spec * vec3(0.8,1.0,1.0);\n    }\n\n    fragColor = vec4(col.rgb,1);\n}","name":"Image","description":"","type":"image"}]}