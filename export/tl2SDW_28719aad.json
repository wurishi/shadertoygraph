{"ver":"0.1","info":{"id":"tl2SDW","date":"1565942327","viewed":213,"name":"Gray Scott in Color","username":"Clocktown","description":"Gray Scott reaction diffusion in color. Previous attempt failed, learned from https://www.shadertoy.com/view/4d3GWS then changed it to single-buffer and added some different modes. See also: https://mrob.com/pub/comp/xmorphia/","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["color","reactiondiffusion","grayscott"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 color = texture(iChannel0, uv).rgb;\n    float U = color.r;\n    float V = color.g;\n    float P = 1.0 - (U+V);\n    fragColor = vec4(P,V,U, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Comment this define to start with a simple rectangle instead of iChannel0\n#define USE_CHANNEL0\n// Uncomment this line to make f/k be different according to uv coordinates\n#define USE_DYNAMIC\n\n// if you get weird behaviour, ru/rv/rp are too large for the timestep - reduce timestep!\nconst float timestep = 0.95;\n// controls the distance between pixels, i.e. the scale of the simulation\nconst float grid_spacing = 1.0;\nconst float ru = 0.2;\nconst float rv = 0.1;\nconst float f = 0.03; // rate at which U is fed and U, V, P are drained\nconst float k = 0.06; // rate at which V is converted to P\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv_step = vec2(1)/iResolution.xy;\n    \n    // Spacebar to reset\n    if(iFrame <= 20 || texture(iChannel1,uv).w == 0.0 || texture(iChannel3,  vec2(0.126953125, .25)).x > 0.) {\n      #ifndef USE_CHANNEL0\n        if(max(uv.r,uv.g) < 0.75 && min(uv.r,uv.g) > 0.25)\n        \tfragColor.rgb = vec3(0.5, 0.25, 0.0);\n        else\n            fragColor.rgb = vec3(1,0,0);\n      #else\n        \tfragColor.rgb = vec3(0.5, 0.25, 0) * texture(iChannel0, uv).rrr;\n      #endif\n        fragColor.w = 1.0;\n        return;\n    }\n    \n  #ifndef USE_DYNAMIC\n    float F = f;\n    float K = k;\n  #else\n    float F = 0.11 * uv.y;\n    float K = 0.02 + 0.05 * uv.x;\n  #endif\n    \n    vec2 u = texture(iChannel1, uv).rg;\n    vec2 laplacian = (texture(iChannel1, uv + vec2(1,0) * uv_step)\n        \t\t+ texture(iChannel1, uv - vec2(1,0) * uv_step)\n        \t\t+ texture(iChannel1, uv + vec2(0,1) * uv_step)\n        \t\t+ texture(iChannel1, uv - vec2(0,1) * uv_step)).rg\n        \t\t- 4.0 * u;\n    laplacian *= grid_spacing * grid_spacing;\n    \n    vec2 udt = vec2(ru,rv) * laplacian;\n    udt.r = udt.r - u.r*u.g*u.g + F * (1.0 - u.r);\n    udt.g = udt.g + u.r*u.g*u.g - (F + K) * u.g;\n    \n    vec2 nu = u + timestep * udt;\n    \n    // Simulation is error-prone for some values if timestep is too large\n    // Thus, do some sanity checks and ensure that 0 <= U + V <= 1 holds\n    // This is what you call a hack.\n    nu.x = max(nu.x, 0.0);\n    nu.y = max(nu.y, 0.0);\n    float nu_sum = nu.x + nu.y;\n    if(nu_sum > 1.0) {\n        // Ensure they sum up to 1 by subtracting according to their ratio\n        nu.x -= (nu_sum - 1.0) * (nu.x / nu_sum);\n        nu.y -= (nu_sum - 1.0) * (nu.y / nu_sum);\n    }\n    nu.x = max(nu.x, 0.0);\n    nu.y = max(nu.y, 0.0);\n    fragColor = vec4(nu,0.0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}