{"ver":"0.1","info":{"id":"fdjBRm","date":"1645896119","viewed":201,"name":"Lunar Phase Simulation","username":"batersy","description":"I don't know how to upload self-define texture here,  you may custom with this texture for better experience:\nhttps://svs.gsfc.nasa.gov/vis/a000000/a004700/a004720/lroc_color_poles_1k.jpg\nGlobal variables can be modified as needed.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["lunarphasemoon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n * Contact: seplanely@gmail.com\n */\n\n// lunar orbit cycle\nfloat T = 10.;\n// lunar orbit radius\nfloat orbitRadius = 4.;\n// lunar size\nfloat lunarRadius = 2.;\n// sunlight direction(Parallel light source)\nvec3 lig = normalize(vec3(1.,-0.7,0.));\n// camera field of view(angle from 0 to 90)\nfloat cameraAngle = 40.;\n\nfloat PI = 3.1415926;\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\nvec3 sphNormal( in vec3 pos, in vec4 sph )\n{\n    return normalize(pos-sph.xyz);\n}\n\nvec3 lookAt( in vec3 ro, in vec3 ta, in vec3 rd)\n{\n    vec3 cw = normalize(ro - ta);\n    vec3 cu = normalize(cross(vec3(0.0, 1.0, 0.0), cw));\n    vec3 cv = normalize(cross(cw, cu));\n    mat3 cam = mat3(cu, cv, cw);\n    return cam * rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    // camera and earth position\n\tvec3 ro = vec3(0.0, 0.0, 0.0);\n    // lunar orbit angle\n    float theta = 2. * PI * mod(iTime, T) / T;\n    float screenResizeRatio = tan(cameraAngle * PI / 180.);\n    p.xy *= screenResizeRatio;\n    \n    // current lunar positoin\n    vec3 ta = vec3(-sin(theta), 0, cos(theta)) * orbitRadius;\n    // look from earth to moon and get primary ray\n    vec3 rd = lookAt(ro, ta, normalize(vec3(p.xy, -1.)));\n\t// lunar sphere\n    vec4 sph = vec4(ta, lunarRadius);\n\n    vec3 col = vec3(0.0);\n    vec3 nor = vec3(0.0);\n    \n    float renderRadius = lunarRadius / orbitRadius / screenResizeRatio;\n    if(length(p) < renderRadius) {\n      // sphere shader mapping\n      float theta = asin(p.y / renderRadius);\n      float phi = asin(p.x / (renderRadius * cos(theta)));\n      vec2 uv = vec2(phi, theta);\n      uv = (uv + PI / 2.) / PI;\n      uv.x /= 2.;\n      uv.x = mod(uv.x + 0.26, 1.);\n      col = texture(iChannel0, uv).rgb;\n      \n      // ray tracing\n      float t2 = sphIntersect( ro, rd, sph );\n      if( t2>0.0) {\n        vec3 pos = ro + t2*rd;\n        nor = sphNormal( pos, sph);\n        col = texture(iChannel0, uv).rgb;\n      }\n    }\n\n    col *= clamp( dot(nor,lig), 0.0, 1.0 );\n    col = sqrt(col);\n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}