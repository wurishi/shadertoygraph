{"ver":"0.1","info":{"id":"3ts3zf","date":"1557159412","viewed":138,"name":"shadows_v1","username":"JabberSnatch","description":"Experimenting with shadow rays and glitch screen effects","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf","glitch","hardshadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ================================================================================\n// MATHS\n// ================================================================================\n\n#define PI 3.1415926535\n\nmat3 rotateX(float alpha)\n{\n\treturn mat3(\n\t\t1.0, 0.0, 0.0,\n\t\t0.0, cos(alpha), sin(alpha),\n\t\t0.0, -sin(alpha), cos(alpha)\n\t);\n}\n\nmat3 rotateY(float alpha)\n{\n\treturn mat3(\n\t\tcos(alpha), 0.0, -sin(alpha),\n\t\t0.0, 1.0, 0.0,\n\t\tsin(alpha), 0.0, cos(alpha)\n\t);\n}\n\n// ================================================================================\n// PRIMITIVES\n// ================================================================================\n\nfloat sdCube(vec3 p, float side)\n{\n\tvec3 rm_dist = abs(p) - vec3(side * 0.5);\n\tvec3 sqrRmDist = rm_dist * rm_dist;\n\treturn max(rm_dist.x, max(rm_dist.y, rm_dist.z)) -\n\t\t   sqrt(abs(sqrRmDist.x + sqrRmDist.y + sqrRmDist.z)) * 0.5;\n}\n\nfloat sdOctahedron(vec3 p, float side)\n{\n\tvec3 rm_dist = abs(p) - vec3(side * 0.5);\n\treturn (rm_dist.x + rm_dist.y + rm_dist.z) / 3.0;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat scene(vec3 p)\n{\n\tfloat stride = 3.0;\n    vec3 cp = vec3(3.0, 3.0, 5.0);\n\tp.x = mod(p.x - cp.x + stride, stride*2.0) - stride + cp.x;\n\tp.y = mod(p.y - cp.y + stride, stride*2.0) - stride + cp.y;\n    p.z = mod(max(p.z, 0.0), stride*4.0);\n\n\tfloat time = iTime * 10.0;\n\tfloat x_angle = mod(time, 360.0) * PI / 180.0;\n\tfloat y_angle = mod(time, 360.0) * PI / 180.0;\n\tmat3 local_space = inverse(rotateX(x_angle) * rotateY(y_angle));\n\tmat3 static_rotation = rotateX(PI / 4.0) * rotateY(PI / 4.0);\n\n    return sdCube(local_space * (p - cp), 2.0);\n}\n\nvec3 scene_color(vec3 p)\n{\n\treturn vec3(0.2, 0.3, 0.5) * 2.0;\n}\n\nvec3 normal(vec3 p)\n{\n\tfloat delta = 0.0001;\n\treturn normalize(\n\t\t   vec3(scene(p + vec3(delta, 0.0, 0.0)) - scene(p - vec3(delta, 0.0, 0.0)),\n\t\t   \t\tscene(p + vec3(0.0, delta, 0.0)) - scene(p - vec3(0.0, delta, 0.0)),\n\t\t\t\tscene(p + vec3(0.0, 0.0, delta)) - scene(p - vec3(0.0, 0.0, delta))));\n}\n\n// ================================================================================\n// RAYCASTING\n// ================================================================================\n\nvec3 target_half_diagonal_hfov(float n, float alpha, float aspect)\n{\n\tfloat half_width = tan(alpha * 0.5) * n;\n\tfloat half_height = half_width * aspect;\n\treturn vec3(half_width, half_height, n);\n}\n\nvec3 compute_ray_plane(vec3 half_diagonal, vec2 clip_coord)\n{\n\tvec3 target = half_diagonal * vec3(clip_coord, 1.0);\n\treturn normalize(target);\n}\n\n// ================================================================================\n// LIGHTING\n// ================================================================================\n\nfloat fresnel_term(vec3 l, vec3 n, float ior_out, float ior_in)\n{\n\tfloat c = abs(dot(-l, n));\n\tfloat g_squared = ((ior_in * ior_in) / (ior_out * ior_out)) - 1.0 + (c * c);\n\tif (g_squared < 0.0) return 1.0;\n\tfloat g = sqrt(g_squared);\n\tfloat gmc = g - c;\n\tfloat gpc = g + c;\n\tfloat T0 = c*gpc - 1.0;\n\tfloat T1 = c*gmc + 1.0;\n\tfloat result = 0.5 * ((gmc * gmc)/(gpc * gpc)) * (1.0 + ((T0 * T0) / (T1 * T1)));\n\treturn result;\n}\n\n// ================================================================================\n// MAIN\n// ================================================================================\n\n#define SHADOW_RAYS\nconst int kMaxStep = 256;\nconst int kShadowStep = 64;\nconst float kStepMultiplier = 1.0;\n\nvoid mainImage(out vec4 frag_color, vec2 frag_coord)\n{\n    if (floor(mod(iTime * 6.0, 3.0)) <= 1.0 &&\n       floor(mod(iTime * 0.5, 2.0)) == 0.0 &&\n       floor(mod(iTime * 0.8, 2.0)) == 0.0)\n    {\n        if (floor(mod(frag_coord.y, 15.0 * (sin(iTime * 5.0) + 2.0))) < 1.0 ||\n           floor(mod(frag_coord.y, 17.0)) < 2.0)\n           frag_coord.x += 10.0 * (sin(iTime * 100.0) + 1.0);\n    }\n\n\n\tfloat aspect_ratio = iResolution.y / iResolution.x;\n\tfloat fov = 60.0 * PI / 180.0;\n\tfloat near = 0.1;\n\tvec3 half_diagonal = target_half_diagonal_hfov(near, fov, aspect_ratio);\n\tvec2 clip_coord = ((frag_coord / iResolution.xy) - 0.5) * 2.0;\n\tvec3 ray = compute_ray_plane(half_diagonal, clip_coord);\n    ray = rotateX(-sin(iTime) * PI / 64.0) * ray;\n\n\tvec3 position = vec3(cos(iTime), 0.0, -20.0);\n    vec3 start_pos = position;\n\tfloat rm_dist = scene(position);\n\n    int rm_step = 0;\n\tfor (; rm_step < kMaxStep; rm_step++)\n\t{\n\t\tposition += ray * rm_dist * kStepMultiplier;\n\t\trm_dist = scene(position);\n        if (rm_dist < 0.005)\n           break;\n\t}\n\n\tvec3 bg_color = vec3(0.2);\n\n\tfloat light_intensity = 5.0;\n\tvec3 lp = vec3(sin(iTime) * 7.0, cos(iTime) * 7.0, 3.0);\n\n\tvec3 n = normal(position);\n\tvec3 l = normalize(lp - position);\n\tfloat Li = dot(n, l) * light_intensity / distance(lp, position);\n\tfloat F = fresnel_term(l, n, 1.0, 2.0);\n\tvec3 base_color = scene_color(position);\n\n#ifdef SHADOW_RAYS\n    vec3 sp = lp;\n    int srm_step = 0;\n    float srm_dist = scene(sp);\n\tfor (; srm_step < kShadowStep; srm_step++)\n\t{\n\t\tsp -= l * srm_dist;\n        srm_dist = scene(sp);\n        if (srm_dist < 0.005)\n           break;\n   \t}\n\tfloat occlusion = clamp(1.0 - distance(position, sp), 0.0, 1.0);\n    occlusion += 1.0 - step(srm_dist, 0.1);\n    occlusion = min(occlusion, 1.0);\n#else\n    float occlusion = 1.0;\n#endif\n\n\tfrag_color.xyz = base_color * (Li * (1.0 + F)) * occlusion;\n    if (floor(mod(iTime * 6.0, 3.0)) <= 1.0 &&\n       floor(mod(iTime * 0.5, 2.0)) == 0.0 &&\n       floor(mod(iTime * 0.8, 2.0)) == 0.0)\n    {\n        frag_color.xyz = vec3((float(rm_step) / float(kMaxStep)));\n    }\n}","name":"Image","description":"","type":"image"}]}