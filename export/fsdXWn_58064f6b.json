{"ver":"0.1","info":{"id":"fsdXWn","date":"1632942549","viewed":127,"name":"Sandstorm test","username":"sergei_am","description":"Fog density generated using the shape of the terrain to simulate sandstorm","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fog","volumetrics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FOG_HEIGHT_FALLOFF = 0.04;\nconst float FOG_GLOBAL_DENSITY = 0.01;\n\nconst int FOG_TRACE_STEPS = 32;\n\nconst float FOG_NOISE_SCALE = 0.004;\nconst float FOG_NOISE_SPEED = 0.09;\nconst float FOG_NOISE_CONTRAST = 0.9;\n\nconst float CLOUDS_DENSITY = 0.2;\nconst float CLOUDS_MAX_DENSITY_HEIGHT  = -10.0;\nconst float CLOUDS_ZERO_DENSITY_HEIGHT = 10.0;\n\nconst vec3  SUN_COLOR = vec3(20.0, 19.0, 13.0);\nconst vec3  SKY_COLOR = vec3(1.2, 1.5, 2.0);\nconst float SUN_SCATTERING_ANISO = 0.7;\n\n\nconst float CAMERA_PITCH = 0.4;\n\nconst float PI = 3.14159265359;\n\nconst bool SANDSTORM = true;\n\n\n\nvec2 rotate( in vec2 v, in float angle )\n{\n    float c = cos(angle), s = sin(angle);\n    return vec2( v.x*c - v.y*s, v.x*s + v.y*c );\n}\n\nfloat get_terrain_height( in vec3 pos )\n{\n    const float xw[12] = float[](40.0, 25.0, 112.0, 23.0,12.0,37.0, 13.0,6.0,41.0, 7.0,5.0,27.0);\n    \n    float h = 0.0;\n    for(int i=0; i<12; i += 3)\n    {\n        h += sin(pos.x / xw[i])*xw[i+1]*cos(pos.z / xw[i+2])*2.0;\n        h += cos(pos.z / xw[i] + 0.6)*xw[i+1]*cos(pos.x / xw[i+2])*2.0;\n    }\n    return h*0.5;\n}\n\nvec3 get_terrain_albedo( in vec3 pos )\n{\n    vec3 color = texture(iChannel0, pos.xz * 0.015).xyz;\n    color = vec3(0.7,0.7,0.7) + color * 0.3;\n    color *= vec3(1.0,0.7,0.3);\n    \n    color.xyz *= texture(iChannel2, pos.xz/20.0).x*0.5 + 0.5;\n    \n    return color;\n}\n\nvec3 terrain_intersect_precise( in vec3 p_below, in vec3 p_above, int num_steps )\n{\n    for( int i=0; i<num_steps; ++i )\n    {\n        vec3 mid = (p_below + p_above)*0.5;\n        float h = get_terrain_height( mid );\n        if( h < mid.y )\n            p_above = mid;\n        else\n            p_below = mid;\n    }\n    \n    return p_below;\n}\n\nbool terrain_intersect(in vec3 eye, in vec3 ray, in float step_size, in int num_steps, in int num_precise_steps, out vec3 I)\n{\n    vec3 ray_step = normalize(ray);\n    ray_step *= step_size;\n    \n    for( int i=0; i<num_steps; ++i )\n    {\n        float h = get_terrain_height( eye );\n        if( h > eye.y )\n        {\n            I = terrain_intersect_precise( eye, eye - ray_step, num_precise_steps );\n            return true;\n        }\n        eye += ray_step;\n    }\n    return false;\n}\n\nvec3 terrain_normal( in vec3 pos )\n{\n    float h00 = get_terrain_height(pos);\n    float h10 = get_terrain_height(pos + vec3(0.5, 0.0, 0.0) );\n    float h01 = get_terrain_height(pos + vec3(0.0, 0.0, 0.5));\n    vec3 N = normalize(vec3(h00-h10, 0.5, h00-h01));\n    return N;\n}\n\nfloat get_sky_visibility(in vec3 N)\n{\n    return pow(N.y*0.5 + 0.5, 0.5);\n}\n\nvec3 get_sun_direction()\n{\n    //return SUN_DIRECTION;\n\n    float angle = iTime/16.0;\n    \n    angle = 2.1;\n    \n    vec3 dir = vec3(cos(angle), 0.2, sin(angle));\n    dir = normalize(dir);\n    \n    //dir = vec3(0.0, 1.0, 0.0);\n    \n    return dir;\n}\n\nfloat get_shadow(in vec3 wpos)\n{\n    vec3 dummy;\n\treturn terrain_intersect(wpos + vec3(0.0, 0.1, 0.0), get_sun_direction(), 4.0, 40, 0, dummy) ? 0.0 : 1.0;\n}\n\nfloat get_fog_density(in vec3 pos, in vec3 pos2)\n{\n    vec3 coord = pos*FOG_NOISE_SCALE;\n    coord.x += iTime * FOG_NOISE_SPEED;\n    \n    float noise = texture(iChannel1, coord).x;\n    float exp_fog = exp(-pos.y*FOG_HEIGHT_FALLOFF)*FOG_GLOBAL_DENSITY;//*noise;\n    \n    float cloud_fog = CLOUDS_DENSITY;\n    float k = clamp((pos.y - CLOUDS_MAX_DENSITY_HEIGHT) / (CLOUDS_ZERO_DENSITY_HEIGHT - CLOUDS_MAX_DENSITY_HEIGHT), 0.0, 1.0);\n    cloud_fog *= 1.0 - k;\n    \n    vec3 dummy;\n    float debris = 0.0;\n    if(terrain_intersect(pos2 + vec3(0.,1.,0.), normalize(vec3(1.0, 0.2, 0.0)), 2.0, 50, 0, dummy))\n    {\n        debris = CLOUDS_DENSITY*(1.0 - length(pos-dummy)/100.0);\n    }\n\n    cloud_fog = debris;\n\n    cloud_fog = max(cloud_fog, debris);\n    cloud_fog *= clamp(noise*FOG_NOISE_CONTRAST + 1.0 - FOG_NOISE_CONTRAST, 0.0, 1.0);\n    \n    return exp_fog + cloud_fog;\n}\n\n// Henyey-Greenstein phase function\nfloat HG_phase(in vec3 L, in vec3 V, in float aniso)\n{\n    float cosT = dot(L,-V);\n    float g = aniso;\n    return (1.0-g*g) / (4.0*PI*pow(1.0 + g*g - 2.0*g*cosT, 3.0/2.0));\n}\n\n#define DV(n) (1.0/30.0)*float(n)\nfloat dith[16] = float[16]( DV(0),DV(8),DV(2),DV(10), DV(12),DV(4),DV(14),DV(6), DV(3),DV(11),DV(1),DV(9), DV(15),DV(7),DV(13),DV(5) );\n#undef DV\n\nvec3 apply_volumetric_fog(in vec3 eye, in vec3 pos, in vec3 scene_color, in float noise, vec2 fragCoord)\n{\n    vec3 dir = eye - pos;\n    vec3 V = normalize(dir);\n    vec3 L = get_sun_direction();\n    \n    vec3 accum = scene_color;\n    \n    float sun_phase = HG_phase(L, V, SUN_SCATTERING_ANISO)*3.0;\n    \n    float step = length(dir) / float(FOG_TRACE_STEPS) / 1.0;\n    \n    float jitter = noise*2.5;\n    vec2 fv = fract(fragCoord*(1.0/16.0));\n\tfloat d = dith[int(fv.x*15.0)] + dith[int(fv.y*15.0)];\n    \n    for(int i=0; i<FOG_TRACE_STEPS; ++i)\n    {\n        float k = float(i)/float(FOG_TRACE_STEPS-1);\n        float k2 = (float(i) + d*0.5)/float(FOG_TRACE_STEPS-1);\n        k += jitter;\n        \n        vec3  pi = pos + dir*k;\n        vec3  pi2 = pos + dir*k2;\n        \n        float s = get_shadow(pi2);\n        float f = get_fog_density(pi, pi2);\n        \n        float T = exp(-f*step);\n        \n        vec3 sky = SKY_COLOR * step;\n        vec3 sun = SUN_COLOR * sun_phase * s * step;\n        \n        vec3 tint = vec3(0.7,0.5,0.2);\n        \n        accum = accum*T;\n        accum += sky * f * tint;\n        accum += sun * f * tint;\n    }\n    return accum;\n}\n\nvec3 tonemap(in vec3 hdr)\n{\n    return hdr / (hdr + vec3(1.0, 1.0, 1.0));\n}\n\nvec3 light_terrain( in vec3 pos, in vec3 eye, in vec3 ray, in float noise )\n{\n    vec3 N = terrain_normal( pos );\n    vec3 L = get_sun_direction();\n    vec3 V = normalize(-ray);\n    float S = get_shadow(pos + N);\n    \n    vec3 ambient;\n    \n    ambient = SKY_COLOR;\n    ambient *= get_sky_visibility(N);\n    \n    vec3 diffuse = max(dot(N, L), 0.0)*SUN_COLOR;\n    diffuse *= S;\n    \n    vec3 H = (L+V)*0.5;\n    \n    vec3 specular = SUN_COLOR * pow(max(0.0, dot(N,H)), 32.0) * S * 65.0;\n    \n    vec3 albedo = get_terrain_albedo(pos);\n    \n    vec3 color;\n    \n    color += ambient; \n    color += diffuse;\n    \n    color *= albedo;\n\n    \n    return color;\n}\n\nbool intersect_sphere( in vec3 ray, in vec3 center, in float R )\n{\n    float B = dot(center, ray);\n    float det = B*B - dot(center,center) + R * R;\n    if( det < 0.0 ) return false;\n    \n    float T = dot(ray, center) - sqrt(det);\n    return T > 0.0;\n}\n\nvec3 compute_sky( vec3 ray )\n{\n    vec3 color = mix( SKY_COLOR, SKY_COLOR*0.5, ray.y );\n    if( intersect_sphere( ray, get_sun_direction(), 0.05 ))\n    {\n        color += vec3(13.0,13.0,13.0);\n    }\n    return color;\n}\n\n\nvec3 shade_ray( vec3 eye, vec3 ray, float noise, in vec2 fc )\n{\n    vec3 pos, color;\n    \n    if( terrain_intersect( eye, ray, 3.0, 300, 5, pos ))\n    {\n        color = light_terrain( pos, eye, ray, noise );\n    }\n    else\n    {\n         color = compute_sky(ray);\n         pos = eye + ray*1000.0;\n    }\n    color = apply_volumetric_fog(eye, pos, color, 0.0, fc);\n    color = tonemap(color);\n\treturn color;\n}\n\nfloat compute_average_terrain_height(in vec3 pos, in float radius)\n{\n    vec3 offset = vec3(1.0,0.0,0.0);\n    \n    float angle_step = 6.28/8.0;\n    float h0 = get_terrain_height(pos);\n    float h = h0;\n    float sum = 1.0;\n    \n    for(int j=1; j<=3; ++j)\n    {\n        float R = radius * float(j) * (1.0/3.0);\n        float weight = mix(1.0, 0.25, float(j)/8.0);\n        for(int i=0; i<8; ++i)\n        {\n            h += get_terrain_height(pos + offset*R)*weight;\n            sum += weight;\n            offset.xz = rotate(offset.xz, angle_step);\n        }\n    }\n    h /= sum;\n   \n    return max( h, h0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 fc = fragCoord;\n    fragCoord.xy = (fragCoord.xy - iResolution.xy*0.5)/iResolution.yy + vec2(0.5,0.5);\n\n    vec3 ray = normalize( vec3( fragCoord*2.0 - 1.0, 1.0 ));\n    ray.yz = rotate( ray.yz, CAMERA_PITCH );\n    \n    vec3 eye = vec3(iTime*2.0, 0.0, iTime*24.0);\n    eye.y = max( eye.y, compute_average_terrain_height(eye, 60.0) + 65.0);\n    \n    float fragment_noise = abs(sin(fragCoord.x*453.0 + iTime*40.0)*sin(fragCoord.y*3489.124));\n\n    vec3 color  = shade_ray(eye, ray, fragment_noise, fc);\n    \n    fragColor = vec4( color, 1.0 );\n}","name":"Image","description":"","type":"image"}]}