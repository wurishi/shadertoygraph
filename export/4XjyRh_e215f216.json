{"ver":"0.1","info":{"id":"4XjyRh","date":"1726939466","viewed":21,"name":"raymarched swirling field","username":"woksan","description":"some raymarching stuff test","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MIN_DISTANCE 0.01\n#define MAX_DISTANCE 1000.0\n#define MAX_STEPS 64\n\n#define M_PI 3.14159265358979323846264338327950288\n\nmat4 rotate_x(float t)\n{\n  return mat4(\n    vec4(1.0, 0.0, 0.0, 0.0),\n    vec4(0.0, cos(t), -sin(t), 0.0),\n    vec4(0.0, sin(t), cos(t), 0.0),\n    vec4(0.0, 0.0, 0.0, 1.0)\n  );\n}\n\nmat4 rotate_y(float t)\n{\n  return mat4(\n    vec4(cos(t), 0.0, -sin(t), 0.0),\n    vec4(0.0, 1.0, 0.0, 0.0),\n    vec4(sin(t), 0.0, cos(t), 0.0),\n    vec4(0.0, 0.0, 0.0, 1.0)\n  );\n}\nfloat rand(vec2 co){\n  return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\nfloat cube(vec3 p, vec3 o, vec3 s)\n{\n  vec3 d = abs(p - o) - s;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat plane(vec3 p, vec3 n, float d)\n{\n  return dot(p, n) - d;\n}\n\nfloat sphere(vec3 p, vec3 o, float r)\n{\n  return length(p - o) - r;\n}\n\nfloat map(vec3 p)\n{\n  float d = plane(p, vec3(0.0, 1.0, 0.0), -4.0);\n  \n  float gap = 32.0;\n  vec3 a = fract(p / gap) * gap;\n  vec3 b = floor(p / gap) * gap;\n  vec3 q = vec3(a.x, p.y, a.z);\n  float h = 8.0;\n  \n  float ot = rand(b.xz);\n  float os = (rand(b.zx) * 2.0 - 1.0) * 4.0;\n\n  vec3 o = vec3(16.0, h / 2.0, 16.0);\n  \n  for (float z = -gap; z <= gap; z += gap) {\n    for (float x = -gap; x <= gap; x += gap) {\n      float s = pow(cos(-p.y + iTime * 4.0), 2.0) * pow(cos(-p.y * 0.3 + iTime * 3.0), 2.0) * 0.4 + 0.1;\n      float pole = cube(q, o + vec3(x, 0.0, z), vec3(s, h, s));\n      \n      float rt = iTime * os + ot;\n      vec3 qo = (q - o);\n      vec3 rq = qo * mat3(rotate_y(rt)) + o;\n      vec3 ro = o + vec3(0.0, cos(atan(qo.z, qo.x) * 3.0), 0.0);\n      \n      float r1 = cube(rq, ro + vec3(0.0, 5.0, 0.0), vec3(3.0, 0.5, 3.0));\n      float r2 = cube(rq, ro + vec3(0.0, 5.0, 0.0), vec3(2.5, 2.0, 2.5));\n      \n      d = min(d, min(pole, max(r1, -r2)));\n    }\n  }\n  \n  return d;\n}\n\n\nfloat ray_march(vec3 ro, vec3 rd)\n{\n  float td = 0.0;\n  for (int i = 0; i < MAX_STEPS; i++) {\n    float d = map(ro + rd * td);\n    if (d < MIN_DISTANCE) return td;\n    if (td > MAX_DISTANCE) break;\n    td += d;\n  }\n  return MAX_DISTANCE;\n}\n\nvec3 map_normal(vec3 p)\n{\n  float dp = 0.001;\n  float d = map(p);\n  float dx = map(p + vec3(dp, 0.0, 0.0));\n  float dy = map(p + vec3(0.0, dp, 0.0));\n  float dz = map(p + vec3(0.0, 0.0, dp));\n  \n  vec3 N = normalize(vec3(dx, dy, dz) - d);\n  \n  return N;\n}\n\nfloat shadow(vec3 pt, vec3 rd, float ld)\n{\n  vec3 p = pt;\n  float td = MIN_DISTANCE;\n  float kd = 1.0;\n  \n  for (int i = 0; i < MAX_STEPS && kd > 0.01; i++) {\n    p = pt + rd * td;\n    \n    float d = map(p);\n    \n    if (td > MAX_DISTANCE || td + d > ld) break;\n    if (d < 0.001) kd = 0.0;\n    // else kd = min(kd, 16.0 * d / td);\n    \n    td += d;\n  }\n  \n  return kd;\n}\nfloat ray_intersect(vec3 ro, vec3 rd)\n{\n  vec3 n = vec3(0.0, 1.0, 0.0);\n  float d = -4.0;\n  \n  float td = dot(n * d - ro, n) / dot(rd, n);\n  \n  if (td < 0.0) {\n    return MAX_DISTANCE;\n  }\n  \n  return td;\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord)\n{\n  vec2 uv = frag_coord / iResolution.xy * 2.0 - 1.0;\n  uv.x *= iResolution.x / iResolution.y;\n  vec2 mouse = iMouse.xy / iResolution.xy * 2.0 - 1.0;\n  \n  vec3 view_pos = vec3(0.0, 0.0, iTime * 4.0);\n  mat4 view_mat = mat4(1.0) * rotate_y(mouse.x) * rotate_x(mouse.y);\n  \n  vec3 ld = normalize(vec3(+0.5, -0.5, +0.25));\n  \n  vec3 rd = normalize(vec3(view_mat * vec4(uv, 1.0, 1.0)));\n  float td = ray_march(view_pos, rd);\n  td = min(td, ray_intersect(view_pos, rd));\n  \n  if (td < MAX_DISTANCE) {\n    vec3 p = view_pos + td * rd;\n    vec3 V = normalize(view_pos - p);\n    vec3 N = map_normal(p);\n    \n    vec3 light = 0.5 + 0.5 * vec3(1.0) * dot(-ld, N) * shadow(p, -ld, 1000.0);\n    \n    frag_color.xyz = light;\n  } else {\n    float q = 0.5 + (0.5 - uv.y) * 0.3;\n    frag_color.xyz = vec3(q, q, 1.0);\n  }\n  frag_color.w = 1.0;\n}\n","name":"Image","description":"","type":"image"}]}