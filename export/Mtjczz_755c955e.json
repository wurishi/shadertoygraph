{"ver":"0.1","info":{"id":"Mtjczz","date":"1507277593","viewed":729,"name":"Spot White Balance","username":"Tynach","description":"This shader lets you click on a particular point and use the color at that point in the picture to calculate the color temperature. It will attempt to make that point grey.\n\nIt calculates the CIE 1931 xy chromaticities to perform the white balancing.","likes":2,"published":1,"flags":0,"usePreview":1,"tags":["rgb","xyz","colorspaces","white","colorspace","whitepoint","whitebalance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\n\n\nstruct transfer {\n\tfloat power;\n\tfloat off;\n\tfloat slope;\n\tfloat cutoffToLinear;\n\tfloat cutoffToGamma;\n\tbool tvRange;\n};\n\nstruct rgb_space {\n\tmat3 primaries;\n\tvec3 whitePoint;\n\ttransfer trc;\n};\n\n\n/*\n * Preprocessor 'functions' that help build colorspaces as constants\n */\n\n// Turns 6 chromaticity coordinates into a 3x3 matrix\n#define \\\nprimaries(r1, r2, g1, g2, b1, b2)\\\n\tmat3(\\\n\t\tr1, r2, 1.0 - r1 - r2,\\\n\t\tg1, g2, 1.0 - g1 - g2,\\\n\t\tb1, b2, 1.0 - b1 - b2)\n\n// Creates a whitepoint's xyz chromaticity coordinates from the given xy coordinates\n#define \\\nwhite(x, y)\\\n\tvec3(x, y, (1.0 - x - y))\n\n// Creates a scaling matrix using a vec3 to set the xyz scalars\n#define \\\ndiag(v)\\\n\tmat3(\\\n\t\tv.x, 0.0, 0.0,\\\n\t\t0.0, v.y, 0.0,\\\n\t\t0.0, 0.0, v.z)\n\n// Creates a conversion matrix that turns RGB colors into XYZ colors\n#define \\\nrgbToXyz(space)\\\n\tspace.primaries*diag((inverse(space.primaries)*(space.whitePoint/space.whitePoint.y)))\n\n// Creates a conversion matrix that turns XYZ colors into RGB colors\n#define \\\nxyzToRgb(space)\\\n\tinverse(rgbToXyz(space))\n\n// Creates a conversion matrix converts linear RGB colors from one colorspace to another\n#define \\\nconversionMatrix(f, t)\\\n\txyzToRgb(t)*rgbToXyz(f)\n\n\nconst mat3 primaries709 = mat3(\n\t0.64, 0.33, 0.03,\n\t0.3, 0.6, 0.1,\n\t0.15, 0.06, 0.79\n);\n\n\nconst vec3 whiteD65 = vec3(0.312713, 0.329016, 0.358271);\n\nconst transfer gamSrgb = transfer(2.4, 0.055, 12.92, 0.04045, 0.0031308, false);\n\nconst rgb_space Srgb = rgb_space(primaries709, whiteD65, gamSrgb);\n\n\n// Radius for the color sampling; keep low for your GPU's sake!\nconst int r = 1;\n\n// Change this to decide what colorspace the original image uses\nconst rgb_space from = Srgb;\n\n\nvec4 toLinear(vec4 color, transfer trc)\n{\n\tif (trc.tvRange) {\n\t\tcolor = color*85.0/73.0 - 16.0/219.0;\n\t}\n\n\tbvec4 cutoff = lessThan(color, vec4(trc.cutoffToLinear));\n\tbvec4 negCutoff = lessThanEqual(color, vec4(-1.0*trc.cutoffToLinear));\n\tvec4 higher = pow((color + trc.off)/(1.0 + trc.off), vec4(trc.power));\n\tvec4 lower = color/trc.slope;\n\tvec4 neg = -1.0*pow((color - trc.off)/(-1.0 - trc.off), vec4(trc.power));\n\n\tcolor = mix(higher, lower, cutoff);\n\tcolor = mix(color, neg, negCutoff);\n\n\treturn color;\n}\n\nvec4 toGamma(vec4 color, transfer trc)\n{\n\tbvec4 cutoff = lessThan(color, vec4(trc.cutoffToGamma));\n\tbvec4 negCutoff = lessThanEqual(color, vec4(-1.0*trc.cutoffToGamma));\n\tvec4 higher = (1.0 + trc.off)*pow(color, vec4(1.0/trc.power)) - trc.off;\n\tvec4 lower = color*trc.slope;\n\tvec4 neg = (-1.0 - trc.off)*pow(-1.0*color, vec4(1.0/trc.power)) + trc.off;\n\n\tcolor = mix(higher, lower, cutoff);\n\tcolor = mix(color, neg, negCutoff);\n\n\tif (trc.tvRange) {\n\t\tcolor = color*73.0/85.0 + 16.0/255.0;\n\t}\n\n\treturn color;\n}\n\n// Scales a color to the closest in-gamut representation of that color\nvec4 gamutScale(vec4 color, float luma)\n{\n\tfloat low = min(color.r, min(color.g, min(color.b, 0.0)));\n\tfloat high = max(color.r, max(color.g, max(color.b, 1.0)));\n\n\tfloat lowScale = low/(low - luma);\n\tfloat highScale = max((high - 1.0)/(high - luma), 0.0);\n\tfloat scale = max(lowScale, highScale);\n\tcolor.rgb += scale*(luma - color.rgb);\n\n\treturn color;\n}\n\n// Converts from one RGB colorspace to another\nvec4 convert(vec4 color, rgb_space from, rgb_space to)\n{\n\tcolor = toLinear(color, from.trc);\n\n\tcolor.xyz = rgbToXyz(from)*color.rgb;\n\tfloat luma = color.y;\n\n\tcolor.rgb = xyzToRgb(to)*color.rgb;\n\tcolor = gamutScale(color, luma);\n\n\treturn toGamma(color, to.trc);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\trgb_space to = from;\n\n\tvec2 texRes = vec2(textureSize(iChannel0, 0));\n\tvec2 texCoord = fragCoord/texRes;\n\ttexCoord *= texRes.x/iResolution.x;\n\n\tvec2 mouseCoord = vec2(0.0);\n\tvec3 whiteColor = vec3(0.0);\n\n\tfor (int i = -r; i <= r; ++i) {\n\t\tfor (int j = -r; j <= r; ++j) {\n\t\t\tmouseCoord = (texCoord*texRes*iMouse.xy/fragCoord + vec2(i, j))/texRes;\n\t\t\twhiteColor += toLinear(texture(iChannel0, mouseCoord), from.trc).rgb;\n\t\t}\n\t}\n\n\twhiteColor /= float((r*2+1)*(r*2+1));\n\n\twhiteColor = rgbToXyz(to)*whiteColor;\n\twhiteColor /= dot(whiteColor, vec3(1.0));\n\tto.whitePoint = whiteColor;\n\n\t// Uncomment this portion (remove the '/*' and '*/') for half of the\n\t// image to remain untouched\n\t/*bool left = bool(int(texCoord.x*2.0));\n\n\tif (!left) {\n\t\tfrom = Srgb;\n\t\tto = from;\n\t}*/\n\n\tfragColor = convert(texture(iChannel0, texCoord), from, to);\n}","name":"Image","description":"","type":"image"}]}