{"ver":"0.1","info":{"id":"XlGfWW","date":"1542477155","viewed":147,"name":"WarpingFloor","username":"Falko","description":"move mouse to rotate camera","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["procedural","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 v;\nvec3 lightSource = vec3(20.0, 0.0, 6.0);\nfloat bLightSource = 0.6;\nfloat ba = 0.4;\n\nvec2 random2(vec2 st){\n    //hash function to generate noise\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.177);\n    }\n    \nfloat gNoise(vec2 st) {\n    //gradient noise\n\tvec2 i = floor(st);\n\tvec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n    }\n\nfloat pi(){\n \treturn radians(180.0);   \n}\n\nvec2 intersectCircle(vec2 cp, vec2 rView){\n    \t\t//compute p and q from pq-formula\n            float cp_projected = dot(rView, cp);\n            return vec2(cp_projected, pow(cp_projected, 2.0)-dot(cp, cp));\n    }\n\n\n\nfloat diffuse(vec3 p, vec3 normal){\n            vec3 dirLight = normalize(lightSource-p);\n            return bLightSource*max(0.0, dot(normal, dirLight));\n    }\n\nvec3 chess(vec3 p, vec3 pFrag, vec3 normal){\n    //computes the chess pattern with diffuse lightning\n    vec3 cSand = vec3(0.76, 0.7, 0.5);\n    vec3 cSandStone = vec3(0.76, 0.57, 0.5);\n    vec3 cRock = vec3(0.71, 0.7, 0.65);\n \t\n    float tileSize = 4.0;\n    float pixSize = 3.0*2.0*length(v-p)\n        \t\t\t\t\t\t\t/(min(iResolution.x, iResolution.y)\n                                    *length(v-pFrag)\n                                    *tileSize);\n    \n    vec2 ij = floor(p.xy/tileSize);\n   \tvec3 cChess;\n    if(mod(ij.x, 2.0)==mod(ij.y, 2.0)){\n        cChess = cSand;\n    }\n    else{\n     \tcChess = cSandStone;   \n    }\n    \n    vec2 pLocal = abs(fract(p.xy/tileSize)-0.5);\n    float maxLocal = max(pLocal.x, pLocal.y);\n    \n    float bd = diffuse(p, normal);\n    return (ba+bd)*mix(cRock, cChess, smoothstep(0.0, pixSize, 0.49-maxLocal));  \n}\n\nvec3 rostrum(vec3 p, vec3 rView, float radius){\n    //essentially intersect ray with cylinder\n    vec3 cRock = vec3(0.71, 0.7, 0.65);\n    float h = 2.0;\n \t\n    vec2 sol = intersectCircle(-p.xy, normalize(rView.xy));\n    \n    vec3 pCylinder = p + rView*\n        \t\t\t\t(sol.x+sqrt(sol.y+pow(radius, 2.0)))\n                         /length(rView.xy);\n    \n    vec3 nCylinder = normalize(vec3(-pCylinder.xy, 0.0));\n    vec3 pPlane = p - (p.z-h) * rView / rView.z;\n    \n    float bd = mix(diffuse(pCylinder, nCylinder),\n             diffuse(pPlane, vec3(0.0, 0.0, 1.0)),\n             smoothstep(h-0.1, h, pCylinder.z));\n    return (ba+bd)*cRock;\n}\n\nvec3 computeBackground(vec3 p, vec3 rView){\n \tvec3 cSand = vec3(0.76, 0.7, 0.5);\n    vec3 cSandStone = vec3(0.76, 0.57, 0.5);\n    vec3 cSky = vec3(0.5, 0.76, 0.7);\n    \n    //check if XY-plane is visible\n    if(dot(rView, vec3(0.0, 0.0, 1.0))>-0.01*3.14){\n     \treturn cSky;   \n    }\n    \n    //calculate intersection with XY-plane\n    vec3 pXY = p - p.z * rView / rView.z;\n    float l0 = length(pXY);\n    float l1 = length(p - (p.z-2.0) * rView / rView.z);\n    vec2 polar = vec2(acos(pXY.x/l0)*sign(pXY.y)+pi(), l0);\n    \n    if(l1>30.0){\n        \n     \treturn cSky;  \n    }\n    else if(l0>25.0){\n        //compute rostrum\n        vec3 cRostrum = rostrum(p, rView, 25.0);\n        vec3 mix0 = mix(chess(pXY, p, vec3(0.0, 0.0, 1.0)),\n                        cRostrum,\n                   \t\tsmoothstep(25.0, 25.4, l0));  \n     \treturn mix(mix0, cSky,\n                   smoothstep(29.3, 30.0, l1));   \n    }\n    else{\n        //compute chess pattern\n        return chess(pXY, p, vec3(0.0, 0.0, 1.0));   \n    }\n}\n\n\n    \n\nmat3 rotationMatrix(const float angle, const vec3 axis){\n \tfloat alpha = radians(angle);\n    float c = cos(alpha);\n    float s = sin(alpha);\n    mat3 R;\n    R[0] = axis * axis.x * (1.0-c) + vec3(c, axis.z*s, -axis.y*s);\n    R[1] = axis * axis.y * (1.0-c) + vec3(-axis.z*s, c, axis.x*s);\n    R[2] = axis * axis.z * (1.0-c) + vec3(axis.y*s, -axis.x*s, c);\n    return R;\n}\n\nvec3 getCameraPosition(vec4 mouse){\n    //computes position of camera from difference between\n    //clicked and current pixel-coordinates\n    vec3 v0 = 20.0*vec3(1.0, 0.0, 1.0);\n    \n    if(iMouse.w<0.){\n        return v0;\n    }\n    else{\n        vec3 v;\n    \tvec2 angle = 200.0*(mouse.xy-mouse.zw);\n        angle.y = min(abs(angle.y), 40.0)*sign(angle.y);\n        \n        vec3 axVert = vec3(0.0, 0.0, 1.0);\n        mat3 rVert = rotationMatrix(angle.x, axVert);\n        v = rVert*v0;\n        \n        vec3 axFlat = normalize(cross(-v, axVert));\n\t\tmat3 rFlat = rotationMatrix(angle.y, axFlat);\n        return rFlat*v;\n    }\n}\n\nbool overlap(vec2 i0, vec2 i1){\n    //true if intervall 0 overlaps with intervall 1\n    if(i0.x>i0.y){\n      float temp = i0.x;\n      i0.x = i0.y;\n      i0.y = temp;  \n    }\n    return (clamp(i0.x, i1.x, i1.y)!=clamp(i0.y, i1.x, i1.y));\n}\n\nfloat f(vec2 pxy, float radius){\n \t//height of floor\n    float smoother = smoothstep(-radius, -0.3*radius, -length(pxy));\n    return 0.5*smoother*(1.0+sin(iTime+10.0*gNoise(0.2*pxy)));\n}\n\nvec3 raymarch(vec3 p, vec3 r, float radius, vec2 center){\n            float tol = 0.01;\n    \t\tvec3 pHat = p;\n            float fValue=1000.0;\n            float tolMarch = 30.0*tol;\n            \n    \t\tint iMax = 1000;\n            int i = 0;\n    \n    \t\t//first perform simple raymarch\n            while(fValue>0.0 && i<iMax){\n            pHat = pHat+tolMarch*r;\n            fValue = min(pHat.z-f(pHat.xy, radius),\n                         radius-length(center-pHat.xy));\n            }\n    \t\t\n    if(pHat.z-f(pHat.xy, radius)>0.0){\n        //terminate if ray hit boundary of cylinder\n        return vec3(1000.0);\n    }\n    else{\n        //perform local bisection for better quality\n        float b1 = (pHat.z-p.z)/r.z;\n        float b0 = b1-tolMarch;\n    \n    \n        float eta = 10000.0;\n            \n        i = 0;\n        float b;\n        while(abs(eta)>tol && i<iMax){\n                    b = 0.5*(b0+b1);\n                    pHat = p+b*r;\n                    eta = pHat.z-f(pHat.xy, radius);\n                    if(eta<0.0){\n                            b1 = b;\n                    }\n                    else{\n                            b0 = b;\n                    }\n                    i = i+1;\n            }\t\t\n    \treturn pHat;\n    }\n}\n\nvec4 warpedFloor(vec3 pFrag, vec3 p0, vec3 rView, float radius, vec2 center){\n       \n \tvec3 pSurface = raymarch(p0, rView, radius, center);\n    if (length(center-pSurface.xy)>radius){\n        \t//if ray hit cylinder return vector with alpha = 0\n        \treturn vec4(0.0);\n    \t}\n    else{\n        \tvec3 pProjected = vec3(pSurface.xy, 0.0);\n        \tfloat h = 0.001;\n            \n            float fValue = f(pProjected.xy, radius);\n            float dx = (f(pProjected.xy+vec2(h, 0.0), radius)-fValue)/h;\n            float dy = (f(pProjected.xy+vec2(0.0, h), radius)-fValue)/h;\n    \t\t\n        \tvec3 normal = normalize(cross(vec3(1.0, 0.0, dx), vec3(0.0, 1.0, dy)));\n        \t\n        \n        \treturn vec4(chess(pProjected, pFrag, normal), 1.0);\n    }\n        \n            \n}\n\nvec4 computeObject(vec3 p, vec3 rView){\n    vec3 cBrick = vec3(0.8, 0.25, 0.33);\n    vec2 center = vec2(0.0);\n    float radius =  10.0;\n    float h =1.0;\n    \n    //check if ray intersects a covering cylinder\n    //if yes, perform raymarch to compute the pixels color\n    vec2 sol = intersectCircle(center-p.xy, normalize(rView.xy));\n    float lxy = length(rView.xy);\n    \n    if(pow(radius, 2.0)+sol.y<=0.0){\n        return vec4(cBrick, 0.0);\n    }\n    \n    float temp = sol.x+sqrt(sol.y+pow(radius, 2.0));\n    vec3 p0 = p+(-sol.y-pow(radius, 2.0)+pow(sol.x, 2.0))*rView/(temp*lxy);\n    vec3 p1 = p+temp*rView/lxy;\n     \n    \n    if(overlap(vec2(p1.z, p0.z), vec2(0, h))){\n        return warpedFloor(p, p0, rView, radius, center);\n        \n    }\n       else{\n           \n           return vec4(cBrick, 0.0);\n       }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0*(fragCoord-0.5*iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec4 mouse = iMouse/min(iResolution.x, iResolution.y);\n    \n    // set up camera\n    //vec3 v = 10.0*vec3(1.0, 0.0, 1.0);\n    v = getCameraPosition(mouse);\n    vec3 vDir = normalize(-v);\n    vec3 vLeft = normalize(cross(vDir, vec3(0.0, 0.0, 1.0)));\n    vec3 vUp = cross(vLeft, vDir);\n    float dScreen = 2.5;\n    \n    //calculate fragment position in space\n    vec3 pFrag = v + dScreen * vDir + uv.x*vLeft + uv.y * vUp;\n    \n    vec3 rView = normalize(pFrag-v);\n    \n    //compute the warped segment and if visible\n    //the background\n    vec4 color = computeObject(pFrag, rView);\n    if(color.w<0.5){\n       color = vec4(computeBackground(pFrag, rView), 1.0);\n    }\n\n\n    // Output to screen\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}