{"ver":"0.1","info":{"id":"Xc2fWG","date":"1725488868","viewed":68,"name":"Gordei_HW1","username":"GISwarm","description":"My first ever shader","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","phong","basic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// utils\n\nfloat random(vec2 p) {\n    vec2 K1 = vec2(\n        23.14069263277926,\n        2.665144142690225\n    );\n    return fract(cos(dot(p,K1)) * 12345.6789);\n}\n\nfloat max3(float a, float b, float c) {\n    return max(a, max(b, c));\n}\n\nfloat max4(float a, float b, float c, float d) {\n    return max(max(a, b), max(c, d));\n}\n\nfloat max6(float a, float b, float c, float d, float e, float f) {\n    return max(max3(a, b, c), max3(d, e, f));\n}\n\nfloat min3(float a, float b, float c) {\n    return -max3(-a, -b, -c);\n}\n\nfloat min4(float a, float b, float c, float d) {\n    return -max4(-a, -b, -c, -d);\n}\n\nfloat min6(float a, float b, float c, float d, float e, float f) {\n    return -max6(-a, -b, -c, -d, -e, -f);\n}\n\nvec3 mirror(in vec3 target, in vec3 axis) {\n    vec3 axis_normalized = axis * dot(target, axis) / length(axis);\n    return 2.0 * axis_normalized - target;\n}\n\nvec3 clamp_color(in vec3 color) {\n    return vec3(\n        max(0.0, min(1.0, color[0])),\n        max(0.0, min(1.0, color[1])),\n        max(0.0, min(1.0, color[2]))\n    );\n}\n\n\n\n// sdf for primitives\n\nfloat sdf_sphere(in vec3 pos, vec3 center, float radius) {\n    return length(pos - center) - radius;\n}\n\nfloat sdf_semispace(in vec3 pos, in vec3 point, in vec3 norm) {\n    return dot(point - pos, norm) / length(norm);\n}\n\nfloat sdf_box(in vec3 pos, vec3 corner, vec3 up, vec3 right, vec3 far) {\n    return max6(\n        sdf_semispace(pos, corner, up),\n        sdf_semispace(pos, corner + up, -up),\n        sdf_semispace(pos, corner, right),\n        sdf_semispace(pos, corner + right, -right),\n        sdf_semispace(pos, corner, far),\n        sdf_semispace(pos, corner + far, -far)\n    );\n}\n\n// sdf for objects\n\nfloat sdf_wall(in vec3 pos) {\n    vec3 CENTER = vec3(0, 0, 45);\n    vec3 NORM = vec3(0, 0, 1);\n    return sdf_semispace(pos, CENTER, NORM);\n}\n\nfloat sdf_ball(in vec3 pos) {\n    vec3 CENTER = vec3(5, -5, 15);\n    float RADIUS = 3.0;\n    return sdf_sphere(pos, CENTER, RADIUS);\n}\n\nfloat sdf_melon(in vec3 pos) {\n    vec3 CENTER = vec3(-15, -5, 15);\n    float RADIUS = 5.0;\n    return sdf_sphere(pos, CENTER, RADIUS) + dot(sin((pos - CENTER) * 2.0), vec3(1.0, 1.0, 1.0)) / 20.0;\n}\n\nfloat sdf_box(in vec3 pos) {\n    vec3 CORNER = vec3(0, 0, 5);\n    vec3 UP = vec3(4.0, 4.0, 0.0);\n    vec3 RIGHT = vec3(-4.0, 4.0, 0.0);\n    vec3 FAR = vec3(0.0, 0.0, 4.0);\n    return sdf_box(pos, CORNER, UP, RIGHT, FAR);\n}\n\n\nfloat sdf_cheese(in vec3 pos) {\n    vec3 CORNER = vec3(-13.2, -2.7, 6);\n    vec3 UP = vec3(3.0, 0.0, 1.5);\n    vec3 RIGHT = vec3(0.0, 2.0, 0.0);\n    vec3 FAR = vec3(-1, 0.0, 2.0);\n    vec3 CENTER = vec3(-12, -4, 7);\n    float RADIUS = 3.0;\n    return max(sdf_sphere(pos, CENTER, RADIUS), sdf_box(pos, CORNER, UP, RIGHT, FAR));\n}\n\n// sdf for scene\n\nfloat sdf(in vec3 pos) {\n    return min6(sdf_wall(pos), sdf_wall(pos), sdf_ball(pos), sdf_melon(pos), sdf_box(pos), sdf_cheese(pos));\n}\n\nvec3 sdf_normal(vec3 point) {\n    float DELTA = 0.001;\n    return vec3(\n        (sdf(vec3(point[0]+DELTA, point[1], point[2])) - sdf(vec3(point[0]-DELTA, point[1], point[2]))) / 2.0 / DELTA,\n        (sdf(vec3(point[0], point[1]+DELTA, point[2])) - sdf(vec3(point[0], point[1]-DELTA, point[2]))) / 2.0 / DELTA,\n        (sdf(vec3(point[0], point[1], point[2]+DELTA)) - sdf(vec3(point[0], point[1], point[2]-DELTA))) / 2.0 / DELTA\n    );\n}\n\n\n\n\n// lights\n\nconst int LIGHTS_DIRECTIONAL_AMOUNT = 3;\nvec3[LIGHTS_DIRECTIONAL_AMOUNT] LIGHTS_DIRECTIONAL_DIRECTION = vec3[](\n    vec3(1.0, 1.0, 2.0),\n    vec3(0.0, 0.0, 1.0),\n    vec3(-1.0, 0.0, 0.0)\n);\nvec3[LIGHTS_DIRECTIONAL_AMOUNT] LIGHTS_DIRECTIONAL_COLOR = vec3[](\n    vec3(1.0, 0.0, 0.0),\n    vec3(0.3, 0.3, 1.0),\n    vec3(0.0, 1.0, 0.0)\n);\n\n\n\n// raytracing\n\nvec3 trace(vec3 position, in vec3 ray, out bool hit) {\n    float SDF_STEP = 0.8;\n    float MAX_STEP = 1000.0;\n    float MIN_STEP = 0.00001;\n    hit = true;\n    vec3 ray_step = ray / length(ray);\n    for (int i = 0; i < 500; ++i) {\n        float step_size = sdf(position);\n        \n        if (step_size < 0.0) break;\n        if (step_size < MIN_STEP) return position;\n        if (step_size > MAX_STEP) break;\n        \n        position += step_size * ray_step * SDF_STEP;\n    }\n    hit = false;\n    return vec3(0, 0, 0);\n}\n\n\n\n// calculating Phong color\n\nvec3 get_color(in vec3 point, in vec3 ray) {\n    vec3 AMBIENT_LIGHT = vec3(0.2, 0.2, 0.2);\n    float DIFFUSE_VAL = 0.3;\n    float SPEC_POW = 20.0;\n    float SPEC_VAL = 0.8;\n    vec3 norm = sdf_normal(point);\n    vec3 mirrored_ray = -mirror(ray, norm);\n    // ambient\n    vec3 result = AMBIENT_LIGHT;\n    // change ambient color for fun\n    result *= vec3(texture(iChannel0, vec2(sin((point.x + point.z) / 50.0), sin((point.y + point.z) / 50.0))));\n    // diffuse\n    for (int i = 0; i < LIGHTS_DIRECTIONAL_AMOUNT; ++i) {\n        vec3 light_direction = LIGHTS_DIRECTIONAL_DIRECTION[i];\n        vec3 light_color = LIGHTS_DIRECTIONAL_COLOR[i];\n        float cos_angle = dot(-light_direction, norm) / length(light_direction) / length(norm);\n        if (cos_angle > 0.0) {\n            // check shadow\n            bool shadow = false;\n            trace(point-light_direction*0.01, -light_direction, shadow); // TODO separate sdfs? or how to cast ray\n            if (!shadow) result += cos_angle * DIFFUSE_VAL * light_color;\n        }\n    }\n    // specular\n    for (int i = 0; i < LIGHTS_DIRECTIONAL_AMOUNT; ++i) {\n        vec3 light_direction = LIGHTS_DIRECTIONAL_DIRECTION[i];\n        vec3 light_color = LIGHTS_DIRECTIONAL_COLOR[i];\n        if (dot(-light_direction, norm) > 0.0) {\n            float cos_angle = abs(dot(-light_direction, mirrored_ray)) / length(light_direction) / length(mirrored_ray);\n            // check shadow\n            bool shadow = false;\n            trace(point-light_direction*0.01, -light_direction, shadow); // TODO separate sdfs? or how to cast ray\n            if (!shadow) result += pow(cos_angle, SPEC_POW) * SPEC_VAL * light_color;\n        }\n    }\n    // return result\n    return result;\n}\n\n\n\n// main logic\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // position\n    vec2 mouse = iMouse.xy / iResolution.xy - vec2(0.0, 0.5);\n    vec3 position = 30.0 * vec3(sin(mouse.x * 6.28), cos(mouse.x * 6.28) * sin(-mouse.y * 6.28), cos(mouse.x * 6.28) * cos(-mouse.y * 6.28));\n    //position *= 0.0;\n    // ray\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ray = vec3(uv[0], uv[1], 1.0);\n    ray /= length(ray);\n    mat3 camera = mat3(\n        1, 0, 0,\n        0, cos(-mouse.y * 6.28), -sin(-mouse.y * 6.28),\n        0, sin(-mouse.y * 6.28), cos(-mouse.y * 6.28)\n    ) * mat3(\n        cos(mouse.x * 6.28), 0, sin(mouse.x * 6.28),\n        0, 1, 0,\n        -sin(mouse.x * 6.28), 0, cos(mouse.x * 6.28)\n    );\n    ray *= -camera;\n    \n    vec3 result_color = vec3(0.0, 0.0, 0.0);\n    for (int i = 0; i < 10; ++i) {\n        bool hit = false;\n        vec3 point = trace(position, ray, hit);\n        if (hit) {\n            vec3 color = clamp_color(get_color(point, ray));\n            result_color += color * pow(2.0, float(-i) * 2.0);\n            position = point - ray * 0.01; // TODO separate sdfs? or how to cast ray\n            ray = -mirror(ray, sdf_normal(point));\n        } else {\n            break;\n        }\n    }\n    fragColor = vec4(result_color, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}