{"ver":"0.1","info":{"id":"l3lyWH","date":"1726491288","viewed":98,"name":"Desert Sanctum","username":"Timbrhoggvandi","description":"Just testing some stuff out, there isn't much coherency between the different areas here. I probably should have made separate shaders for each as the compile time is pretty bad :P","likes":22,"published":1,"flags":0,"usePreview":1,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// still need to try ray differentials for proper filtering of bump maps -\n// will implement if I eventually come back to this.\n// probably also add dust/fog at some point\n\n// compile time is very bad, especially since I added reflections\n\n#define PI 3.1415926535897932384626433832795\n#define E 2.718281828459045235360287471352\n\n#define FOV 1.\n\n#define MAX_STEPS 256\n#define MAX_DIST 256.\n#define HIT_DIST 0.001\n\n#define ID_SAND 0.\n#define ID_STONE 1.\n#define ID_GOLD 2.\n#define ID_MARBLE 3.\n#define ID_LIGHT 4.\n#define ID_MIRROR 5.\n#define ID_GREYSTONE 6.\n#define ID_WHITEMARBLE 7.\n#define ID_WHITETILE 8.\n#define ID_ANOMALY 9.\n\n#define ID_GOLD_DISGUISE 12.\n#define ID_WHITEMARBLE_DISGUISE 17.\n#define ID_MARBLE_DISGUISE 13.\n#define ID_GREYSTONE_DISGUISE 16.\n\n#define LIGHT_DIR normalize(vec3(-4, 2, -3))\n\n#define ZERO (min(iFrame,0))\n\nfloat time = 0.;\n\n// silly hash functions for silly geese\nfloat hash11(float p) {\n\tfloat p1 = 379.33562438*fract(p*0.125789109301) + 833.33176;\n    return fract(p1*p1+p);\n}\n\nvec4 hash11(vec4 p) {\n\tvec4 p1 = 379.33562438*fract(p*0.125789109301) + 833.33176;\n    return fract(p1*p1+p);\n}\n\nfloat hash12(vec2 p) {\n\treturn hash11(p.x + 1.2769328514*p.y);\n}\n\nfloat hash13(vec3 p) {\n\treturn hash11(p.x + 1.2769328514*p.y + 1.1121514132*p.z);\n}\n\nfloat noise(vec2 p) {\n    vec2 coord = floor(p);\n    vec2 f = fract(p);\n    vec2 a = f * f * (3.0 - 2.0 * f);\n    \n    vec4 r = vec4(hash12(coord),\n        hash12(coord + vec2(0,1)),\n        hash12(coord + vec2(1,0)),\n        hash12(coord + vec2(1,1)));\n\n    r.xy = mix(r.xy, r.zw, a.x);\n    return mix(r.x, r.y, a.y);\n}\n\n/*\nfloat noise(vec3 p) {\n    vec3 coord = floor(p);\n    vec3 f = fract(p);\n    vec3 a = f * f * (3.0 - 2.0 * f);\n    \n    float r000 = hash13(coord);\n    float r001 = hash13(coord + vec3(0,0,1));\n    float r010 = hash13(coord + vec3(0,1,0));\n    float r011 = hash13(coord + vec3(0,1,1));\n    float r100 = hash13(coord + vec3(1,0,0));\n    float r101 = hash13(coord + vec3(1,0,1));\n    float r110 = hash13(coord + vec3(1,1,0));\n    float r111 = hash13(coord + vec3(1,1,1));\n    \n    return mix(\n    mix(\n        mix(r000, r100, a.x),\n        mix(r010, r110, a.x),\n        a.y),\n    mix(\n        mix(r001, r101, a.x),\n        mix(r011, r111, a.x),\n        a.y),\n        a.z);\n}\n*/\n\n// This version of noise is based on Shane's implementation of iq's 3d noise https://www.shadertoy.com/view/lstGRB\n// Results in discontinuities for large values of p\n// but on my machine it compiles way faster that the above implementation. It's much shorter too :)\nfloat noise(vec3 p) {\n    vec3 coord = floor(p);\n    p -= coord;\n    p = p * p * (3.0 - 2.0 * p);\n    \n    // I should try out more values for s to find some that give good results\n    // original just used 7, 157, 113, but these vaules work better with the hash function I'm using here\n    // be careful with what values you choose to not get discontinuities\n    const vec3 s = vec3(0.109375, 2.453125, 1.0625);\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(coord, s);\n\n    h = mix(hash11(h), hash11(h+s.x), p.x);\n    \n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    return mix(h.x, h.y, p.z);\n}\n\nfloat fbm(vec2 p, int octaves) {\n    float sum = 0.0;\n    float scale = 0.5;\n    float freq = 1.0;\n    for(int i = ZERO; i < octaves; i++) {\n        sum += scale*noise(freq*p);\n        freq *= 1.9;;\n        scale *= 0.48;\n        p.xy = p.xy * 0.6 + p.yx * vec2(-0.8, 0.8);\n    }\n    return sum;\n}\n\nfloat fbm(vec3 p, int octaves) {\n    float sum = 0.0;\n    float scale = 0.5;\n    float freq = 1.0;\n    for(int i = ZERO; i < octaves; i++) {\n        sum += scale*noise(freq*p);\n        freq *= 1.9;\n        scale *= 0.48;\n        p.xy = p.xy * 0.6 + p.yx * vec2(-0.8, 0.8);\n    }\n    return sum;\n}\n\nvec2 rotate2D(vec2 p, float angle) {\n    return vec2(p.x*cos(angle) - p.y*sin(angle), p.x*sin(angle) + p.y*cos(angle));\n}\n\nvec2 minDist(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nvec3 getLightLoc() {\n    vec3 lightPos = vec3(0,0,0.7);\n    float t = time;\n    if(t > 10.1) {\n        t -= 10.1;\n        lightPos.y -= t*5.5;\n        lightPos.xz = rotate2D(lightPos.xz, t);\n    }\n    lightPos += vec3(-5,-7.0,72.9);\n    if(t > 18.0) {\n        float t2 = t - 18.0;\n        lightPos = mix(lightPos, vec3(-5, -115.0, 72), clamp(t2/2.0, 0., 1.));\n    }\n    if(t > 20.0) {\n        t -= 20.0;\n        vec3 lightPos2 = lightPos;\n        lightPos2.xz += rotate2D(vec2(0,3), 0.7*t);\n        lightPos = mix(lightPos, lightPos2, clamp(t/2.0, 0., 1.));\n    }\n    return lightPos;\n}\n\n// smooth subtraction and union, along with many of the signed distance functions used\n// from https://iquilezles.org/articles/distfunctions/\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat terrainCoarse(vec2 p) {\n    p.x *= 0.4;\n    float h = fbm(0.02*p.xy, 2) - 0.5;\n    float height = -35.0*sqrt(h*h + 0.0000001);\n    return height;\n}\n\nfloat terrainFine(vec2 p) {\n    p.x *= 0.4;\n    float height = -2.5 * fbm(0.12*p.xy, 2);\n    return height;\n}\n\nfloat terrainRipples(vec2 p) {\n    float offset = fbm(0.4*p.xy, 2);\n    float magnitude = 0.05*fbm(0.5*p.xy + 50.0, 1);\n    float ripple = sin(5.0*p.y + 10.0*offset);\n    return -magnitude*sqrt(ripple*ripple + 0.03);\n}\n\nfloat terrainGrains(vec2 p) {\n    return 0.007*fbm(150.0*p, 1);\n}\n\nfloat terrain(vec2 p) {\n    return terrainCoarse(p) + terrainFine(p) + terrainRipples(p) + terrainGrains(p);\n}\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p)-s;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCylinder(vec3 p, float h, float r) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// triangular prism sdf from https://www.shadertoy.com/view/Nld3DB\nfloat prism(vec3 position, float halfWidth, float halfHeight, float halfDepth) {\n    position.x = abs(position.x);\n    position.xy -= vec2(halfWidth, -halfHeight);\n    vec2 e = vec2(-halfWidth, 2.0 * halfHeight);\n    vec2 q = position.xy - e * clamp(dot(position.xy, e) / dot(e, e), 0.0, 1.0);\n    float d1 = length(q);\n    if (max(q.x, q.y) < 0.0) {\n        d1 = -min(d1, position.y);\n    }\n    float d2 = abs(position.z) - halfDepth;\n    return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.0);\n}\n\nfloat sdWall(vec3 p, vec3 b, float h, float l, bool e) {\n    float range = floor(l/2.0) - 1.0;\n    float rangeLow = -range;\n    if(mod(l,2.0) != 0.0) {\n        rangeLow -= 1.0;\n        p.x -= 0.5*b.x;\n    }\n    if(e ^^ mod(p.y - 0.5*b.y,2.0*b.y) > b.y) {\n        range += 1.0;\n        p.x += 0.5*b.x;\n    }\n    p.y = p.y - b.y*clamp(round(p.y/b.y),0.,h-1.);\n    p.x = p.x - b.x*clamp(round(p.x/b.x),rangeLow,range);\n    b -= 0.2;\n    return(sdBox(p, 0.5*b) - 0.13);\n}\n\nfloat sdPillar(vec3 p, float w, float h) {\n    float d = sdBox(p - vec3(0,0.5*h,0), 0.5*vec3(w,h,w)) - 0.1;\n    p.y = 0.5*h - abs(p.y - 0.5*h);\n    d = min(d,sdBox(p - vec3(0,0.05,0), 0.5*vec3(w+0.8, 0.3, w+0.8)));\n    return min(d,sdBox(p - vec3(0,0.2,0), 0.5*vec3(w+0.4, 0.3, w+0.4))) - 0.03;\n}\n\nfloat mapEntrance(vec3 p) {\n    float bound = sdBox(p, vec3(5.3,10.0,8.45));\n    if(bound > 1.0) {\n        return bound;\n    }\n    vec3 baseP = p - vec3(0,3,0);\n    baseP.y = abs(baseP.y) - 3.4;\n    float d = sdBox(baseP, vec3(5.0,0.4,8.0));\n    d = max(-sdBox(p-vec3(0,-60,2), vec3(2,62,2)), d);\n    \n    vec3 wallP = p - vec3(0,0.45,1.5);\n    wallP.z = abs(wallP.z) - 6.5;\n    float wall = sdWall(wallP, vec3(2,1,1), 6., 5., false);\n    wallP = p - vec3(0,0.45,1.5);\n    wallP.xz = wallP.zx;\n    wallP.z = abs(wallP.z) - 4.5;\n    wall = min(wall, sdWall(wallP, vec3(2,1,1), 6., 7., true));\n    wall = max(-sdBox(p - vec3(0,0,-5.0), vec3(1,3,1)), wall);\n    d = min(d,wall);\n    \n    float door = sdBox(p - vec3(0,3,-5.0), vec3(1.25,0.2,0.54)) - 0.02;\n    vec3 doorP = p - vec3(0,1.45,-5.0);\n    doorP.x = abs(doorP.x) - 1.05;\n    door = min(door, sdBox(doorP, vec3(0.19,1.5,0.52)) - 0.02);\n    d = min(d,door);\n    \n    d = min(d, prism(p - vec3(0,7.7,0), 5.3, 1.0, 8.3) - 0.05);\n    \n    p.z += 7.;\n    p.x = abs(p.x) - 3.8;\n    float pillar = sdPillar(p, 1.05, 6.0);\n    d = min(d, pillar);\n    \n    return d;\n}\n\nvec2 mapTunnel(vec3 p) {\n    float bound = sdBox(p, vec3(2.25,50.0,2.25));\n    if(bound > 1.0) {\n        return vec2(bound,ID_MARBLE);\n    }\n    \n    p.xz = rotate2D(p.xz, 0.0628319*p.y);\n    vec3 tunP = p;\n    tunP.xz = abs(tunP.xz) - 2.0;\n    tunP.xz = (tunP.x<tunP.z) ? tunP.zx : tunP.xz;\n    float tunnel = sdBox(tunP, vec3(0.26,50.0,2.25));\n    vec2 d = vec2(tunnel,ID_WHITETILE);\n    \n    vec3 id = floor((p-0.19)/0.38);\n    \n    // timestamp's rectangle domain repetition\n    p.xz = abs(p.xz/0.38) - 5.;\n    p.xz = (p.x<p.z) ? p.zx : p.xz;\n    p.z -= min(0.0, round(p.z));\n    p.xz *= 0.38;\n    \n    p.y -= 0.38*clamp(round(p.y/0.38),-131.,131.);\n    float tunnelBlocks = sdBox(p, vec3(0.18));\n    \n    float blockMat = ID_WHITETILE;\n    float pr = hash13(id);\n    if(pr < 0.2) {\n        blockMat = ID_MIRROR;\n    }\n    else if(pr < 0.4) {\n        blockMat = ID_GOLD;\n    }\n    \n    d = minDist(d,vec2(tunnelBlocks, blockMat));\n    \n    return d;\n}\n\nvec2 sdAnom(vec3 p) {\n    p.xz = rotate2D(p.xz, 0.3*time);\n    p.xy = rotate2D(p.xy, 0.4*time);\n    float dist = sdSphere(p, 0.7);\n    float mix1 = clamp(0.3333*(time-43.),0.,1.);\n    float amplitude = mix(0.05, 0., mix1);\n    \n    float mix2 = clamp(0.3333*(time - 51.), 0., 1.);\n    float mix3 = clamp(0.25*(time - 55.), 0., 1.);\n    \n    float d = mix(0.7, 5.0, mix3);\n    \n    float cube = sdBox(p, vec3(d));\n    \n    dist = mix(dist, cube, mix2);\n    amplitude = mix(amplitude, 0.04, mix2);\n    \n    return vec2(dist, ID_ANOMALY); // 0.4 offset\n}\n\nvec2 mapVault(vec3 p) {\n    vec2 d = vec2(999.,ID_STONE);\n    \n    vec3 vaultFRP = p;\n    vaultFRP.y = abs(vaultFRP.y) - 3.0;\n    float vaultFR = sdBox(vaultFRP, vec3(9,0.1,9));\n    if(time < 29.) {\n        vaultFR = max(-sdBox(p-vec3(0,4,0),vec3(2)), vaultFR);\n    }\n    \n    vec3 vaultWP = p;\n    vaultWP.xz = abs(vaultWP.xz) - 9.;\n    vaultWP.xz = (vaultWP.x<vaultWP.z) ? vaultWP.zx : vaultWP.xz;\n    float vaultW = sdBox(vaultWP,vec3(0.1,3,9));\n\n    d.x = min(vaultFR, vaultW);\n    \n    vec2 d2 = vec2(d.x,ID_GREYSTONE_DISGUISE);\n    \n    float pool = sdBox(p+vec3(0,3,0),vec3(1.5,1,1.5));\n    pool = max(-sdSphere(p+vec3(0,2,0),1.35), pool);\n    d2 = minDist(d2,vec2(pool, ID_MARBLE_DISGUISE));\n    \n    vec3 anomPos = p - vec3(0, -3.2, 0);\n    anomPos.y = mix(anomPos.y, anomPos.y-3.0, clamp(0.5*(time-42.),0.,1.));\n    \n    vec2 anom = sdAnom(anomPos);\n    d2 = minDist(d2, anom);\n    \n    float molten = sdBox(p+vec3(0,3,0),vec3(1.4,0.9,1.4));\n    if(molten < 1.0) {\n        molten += 0.1*fbm(7.*p+vec3(0,time,0),2);\n    }\n    if(time < 44.0) {\n        molten = opSmoothUnion(molten, anom.x, 0.4);\n    }\n    else {\n        d2 = minDist(d2, anom);\n    }\n    d2 = minDist(d2,vec2(molten,ID_GOLD_DISGUISE));\n    \n    p.xz = abs(p.xz) - 4.0;\n    p.xz = rotate2D(p.xz, 0.7*p.y);\n    float pillar = sdBox(p, vec3(0.3,2.0,0.3));\n    d2 = minDist(d2, vec2(pillar, ID_GOLD_DISGUISE));\n    \n    p.y = abs(p.y) - 3.0;\n    float pillar1 = sdCylinder(p, 1.0, 0.5);\n    pillar1 = min(pillar1, sdCylinder(p, 0.667, 0.7));\n    pillar1 = min(pillar1, sdCylinder(p, 0.333, 0.9));\n    d2 = minDist(d2, vec2(pillar1, ID_WHITEMARBLE_DISGUISE));\n    \n    if(time < 34.) {\n        float transition = clamp(0.25*(time - 30.),0.,1.);\n        d.x = mix(d.x,d2.x,transition);\n    }\n    else {\n        d = d2;\n    }\n    \n    return d;\n}\n\nvec2 mapStructure(vec3 p) {\n    vec2 d = vec2(length(p - getLightLoc())-0.04,ID_LIGHT);\n    vec2 entrance = vec2(mapEntrance(p - vec3(-5, -12.1, 70)),ID_STONE);\n    d = minDist(d,entrance);\n    if(time < 29.) {\n        vec2 tunnel = mapTunnel(p - vec3(-5, -62., 72));\n        d = minDist(d, tunnel);\n    }\n    \n    vec2 vault = vec2(999.,ID_STONE);\n    if(time > 12.) {\n        vault = mapVault(p - vec3(-5, -114, 72));\n        d = minDist(d,vault);\n    }\n    \n    vec3 fb = vec3(0);\n    if(d == entrance) {fb = vec3(0.06,8,2);}\n    \n    if(d.x < fb.x) {\n        d.x += fb.x*fbm(fb.y*p,int(fb.z));\n    }\n    return d;\n}\n\nvec2 map(vec3 p) {\n    vec2 d = vec2(999., ID_SAND);\n    if(time < 10.1) {\n        float terr = p.y - terrainCoarse(p.xz);\n        if(terr < 1.) {\n            terr -= terrainFine(p.xz);\n        }\n        terr = opSmoothSubtraction(sdBox(p - vec3(-5, -8, 70.5), vec3(4.5,5.0,7.5)), terr, 0.5);\n        terr = max(-sdBox(p-vec3(-5,-60,72), vec3(2,50,2)), terr);\n        d.x = min(d.x, 0.96*terr);\n    }\n    vec2 structure = mapStructure(p);\n    d = minDist(d, 0.98*structure);\n    return d;\n}\n\nvec2 raymarch(vec3 ro, vec3 rd, out vec3 p) {\n    float t = 0.;\n    p = ro;\n    vec2 d;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        d = map(p);\n        if(d.x < HIT_DIST || t > MAX_DIST) break;\n        t += d.x;\n        p = ro + rd*t;\n    }\n    return vec2(t,d.y);\n}\n\n// tetrahedron technique\nvec3 normal(vec3 p, float h, vec3 fb) {\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*(mapStructure(p+e*h).x + fb.x*fbm(fb.y*(p+e*h),int(fb.z)));\n        if( n.x>10000.0 ) break;\n    }\n    return normalize(n);\n}\n\n// central difference for terrain heightmap\nvec3 normal(vec2 p, float eps)\n{\n    vec2 h = vec2(eps,0);\n    return normalize( vec3( terrain(p-h.xy) - terrain(p+h.xy),\n                            2.0*h.x,\n                            terrain(p-h.yx) - terrain(p+h.yx) ) );\n}\n\nvec3 fresnel(vec3 f0, float dotnv) {\n    return f0 + (1.0 - f0) * pow(1.0 - max(0.0, dotnv), 5.0);\n}\n\n// BRDF implementation mostly based on https://google.github.io/filament/Filament.html\nvec3 BRDF(vec3 l, vec3 v, vec3 n, vec3 cDif, vec3 f0, float r, float s) {\n    vec3 h = normalize(l + v);\n    vec3 nhlv = max(vec3(dot(n,h),dot(n,l),dot(n,v)),0.0);\n    \n    // Schlick's approximation\n    vec3 F = fresnel(f0, nhlv.z);\n    \n    // Trowbridge-Reitz / GGX\n    float a1 = nhlv.x * r;\n    float k = r / (1.0 - nhlv.x * nhlv.x + a1 * a1);\n    float D = k * k * (1.0/PI);\n    \n    // approximated Smith shadow masking function\n    float a2 = r*r;\n    vec2 GGX = nhlv.yz * sqrt(nhlv.yz * nhlv.yz * (1.0 - a2) + a2);\n    float G = 0.5 / (GGX.x + GGX.y);\n    \n    // disney diffuse BRDF\n    float f90 = 0.5 + 2.0 * r * nhlv.y * nhlv.y;\n    vec2 scatter = 1.0 + (f90 - 1.0) * pow(1.0 - nhlv.yz, vec2(5.0));\n    vec3 diffuse = cDif * scatter.x * scatter.y / PI;\n    \n    return (s*F*D*G + diffuse) * nhlv.y;\n}\n\nvoid material(vec3 p, float mat, out vec3 cDif, out vec3 f0, out float r, out float s, out vec3 fb) {\n    fb = vec3(0);\n    s = 1.;\n    if(mat >= 10.0) {\n        float centerDist = length(p - vec3(-5, -115, 72)) + 2.5*(34.-time);\n        if(time > 41.) {\n            mat -= 10.0;\n        }\n        else if(centerDist < -2.0*fbm(2.0*p, 3)) {\n            mat -= 10.0;\n        }\n        else {\n            mat = ID_STONE;\n        }\n    }\n    if(mat <= ID_SAND) {\n        cDif = vec3(0.949,0.588,0.290);\n        f0 = vec3(0.03);\n        r = 0.75;\n        s = 0.2;\n        return;\n    }\n    if(mat <= ID_STONE) {\n        cDif = vec3(0.961,0.553,0.220);\n        f0 = vec3(0.035);\n        r = 0.5;\n        fb = vec3(0.025,20,2);\n        return;\n    }\n    if(mat <= ID_GOLD) {\n        cDif = vec3(0);\n        f0 = vec3(1.0,0.782,0.344);\n        r = 0.06;\n        return;\n    }\n    if(mat <= ID_MARBLE) {\n        cDif = vec3(0.005) + clamp(2.0*fbm(4.0*p,3) - 0.9, 0.,1.);\n        f0 = vec3(0.038);\n        r = 0.06;\n        return;\n    }\n    if(mat <= ID_LIGHT) {\n        cDif = vec3(99999);\n        f0 = vec3(0.1);\n        r = 0.05;\n        return;\n    }\n    if(mat <= ID_MIRROR) {\n        cDif = vec3(0.00);\n        f0 = vec3(0.95);\n        r = 0.01;\n        return;\n    }\n    if(mat <= ID_GREYSTONE) {\n        cDif = vec3(0.478,0.478,0.478);\n        f0 = vec3(0.045);\n        r = 0.45;\n        fb = vec3(0.07,4,4);\n        return;\n    }\n    if(mat <= ID_WHITEMARBLE) {\n        cDif = vec3(0.9) - clamp(1.3*fbm(4.0*p,3) - 0.4, 0.,1.);\n        f0 = vec3(0.07);\n        r = 0.05;\n        return;\n    }\n    if(mat <= ID_WHITETILE) {\n        cDif = vec3(0.95);\n        f0 = vec3(0.09);\n        r = 0.41;\n        return;\n    }\n    if(mat <= ID_ANOMALY) {\n        cDif = vec3(0);\n        f0 = vec3(1.0,0.782,0.344);\n        r = 0.06;\n        if(time > 48.0) {\n            float mix1 = clamp(0.5*(time - 48.), 0., 1.);\n            f0 = f0 = mix(f0, vec3(0.05), mix1);\n            r = mix(r, 0.15, mix1);\n            s = mix(s, 0.6, mix1);\n            fb = mix(fb, vec3(0.05,5,2),mix1);\n        }\n        return;\n    }\n}\n\n// ao from https://www.shadertoy.com/view/Xds3zN\nfloat ao( in vec3 pos, in vec3 nor ) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = mapStructure( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nfloat shadow(vec3 p, vec3 l, float ld) {\n    float t = 0.03;\n    for(int i = ZERO; i < 64; i++) {\n        float d = mapStructure(p + l*t).x;\n        if(d < 0.001) {\n            return 0.0;\n        }\n        t += max(d, 0.01);\n        if(t > ld) {\n            return 1.0;\n        }\n    }\n    return 1.0;\n}\n\nvec3 lighting(vec3 p, vec3 v, float t, float mat) {\n    if(t > MAX_DIST) {\n        return vec3(0.600,0.722,1.000) + 0.7*v.y;\n    }\n    float h = max(0.00005, 2.0 * t / iResolution.y);\n    \n    vec3 cDif, f0, fb;\n    float r, s;\n    \n    material(p,mat,cDif,f0,r,s,fb);\n    \n    vec3 n;\n    if(mat <= ID_SAND) {\n        n = normal(p.xz,h);\n    }\n    else {\n        n = normal(p,h,fb);\n    }\n    \n    vec3 l, light, lightCol;\n    float d, dsq;\n    if(time > 10.1) {\n        light = getLightLoc();\n        l = light - p;\n        d = length(l) - 0.05;\n        dsq = d*d;\n        l = normalize(l);\n        lightCol = mix(vec3(0),vec3(16), clamp((time-10.1)/4.,0.,1.));\n    }\n    else {\n        l = LIGHT_DIR;\n        d = 99.;\n        dsq = 1.;\n        lightCol = vec3(5);\n    }\n    \n    vec3 lightDirect = lightCol*BRDF(l,v,n,cDif,f0,r,s)/dsq;\n    lightDirect *= shadow(p, l, d);\n    \n    float ambientScale = mix(0.0, 0.04,clamp(exp(0.3*p.y+2.4), 0.3, 1.0));\n    vec3 lightAmbient = ambientScale*(cDif + r*s * f0) * ao(p,n);\n    \n    vec3 col = lightDirect + lightAmbient;\n    \n    if(r < 0.4) {\n        vec3 reflection = -v + 2.0*n*dot(n,v);\n        vec3 refScale = (f0 + (1.0 - f0) * pow(1.0 - max(0.0, dot(n,v)), 5.0))*(1.0 - sqrt(r))*s;\n        \n        vec3 refP;\n        vec2 ref = raymarch(p+0.01*reflection, reflection, refP);\n        \n        if(time > 10.1) {\n            l = light - refP;\n            d = length(l) - 0.05;\n            dsq = d*d;\n            l = normalize(l);\n        }\n        material(refP,ref.y,cDif,f0,r,s,fb);\n        \n        n = normal(refP,h, fb);\n        \n        lightDirect = lightCol*BRDF(l,-reflection,n,cDif,f0,r,s)/dsq;\n        lightDirect *= shadow(refP, l, d);\n        float ambientScale = mix(0.0, 0.04,clamp(exp(0.3*refP.y+2.4), 0.3, 1.0));\n        vec3 lightAmbient = ambientScale*(cDif + r*s * f0) * ao(refP,n);\n        \n        col += refScale*(lightDirect+lightAmbient);\n    }\n    \n    return col;\n}\n\nvec3 lookAt(vec3 ro, vec3 rd, vec3 p, vec3 up) {\n    vec3 w = normalize(p-ro);\n    vec3 u = normalize(cross(up,w));\n    vec3 v = cross(w,u);\n    return mat3(u,v,w)*rd;\n}\n\n// this is all pretty janky, I'll take the time to make a better camera movement system one day :P\n// I should probably smooth the camera movement so the velocity doesn't suddenly change\nvoid camera(out vec3 ro, out vec3 ld, float t) {\n    int index;\n    vec3 pos[7] = vec3[7](\n        vec3(0,-2,0),\n        vec3(0,1,7),\n        vec3(-5,-10,65),\n        vec3(-5,-10,71.9),\n        vec3(-5,-113,71.9),\n        vec3(-5,-115,68),\n        vec3(-5,-115,68)\n    );\n    vec3 dir[7] = vec3[7](\n        vec3(0,-10,100),\n        vec3(0,-10,100),\n        vec3(0,-10,100),\n        vec3(-5, -50.0, 72),\n        vec3(-5,-120,72),\n        vec3(-5,-115,79),\n        vec3(-5,-115,79)\n    );\n    float times[7] = float[7](\n        0.,\n        3.,\n        10.,\n        14.,\n        28.,\n        31.,\n        70.\n    );\n    for(int i = 0; i < 6; i++) {\n        if(times[i] <= t && times[i + 1] > t) {\n            index = i;\n            break;\n        }\n    }\n    float range = times[index+1] - times[index];\n    float pct = (t - times[index]) / range;\n    ro = mix(pos[index], pos[index+1], pct);\n    ld = mix(dir[index], dir[index+1], pct);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    time = mod(iTime, 60.);\n    \n    vec3 ro, ld;\n    camera(ro, ld, time);\n    vec3 rd = normalize(vec3(uv, 1.0 / tan(0.5*FOV)));\n    rd = lookAt(ro, rd, ld, vec3(0,1,0));\n    \n    vec3 p;\n    vec2 t = raymarch(ro, rd, p);\n    vec3 col = lighting(p, -rd, t.x, t.y);\n    \n    col = mix(col, vec3(0), 0.25*max(0.,4.-time));\n    \n    col = pow(col, vec3(1.0/2.2));\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}