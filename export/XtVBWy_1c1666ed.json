{"ver":"0.1","info":{"id":"XtVBWy","date":"1546313498","viewed":262,"name":"SNR 0509-67.5","username":"WB","description":"A spherical supernova remnant in the Large Magellanic Cloud (LMC). The bubble is expanding outward at over 18 million km/h and has a diameter of 26 light years.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","nebula"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 128\n#define STEP_SIZE 0.04\n#define _FoV 55.0\n#define OPTICAL_ONLY\n\n#define BACKGROUND\n\n#define JITTER\n\n#define ROTATE\n\nconst vec3 _Emission = vec3(0.5,0.15,0.12);\nconst vec3 _LightColor = vec3(0.4,0.2,0.05);\nconst vec3 _LightPos = vec3(0.0, 0.02, 0.05);\nconst float _LightIntensity = 0.0;\nconst float _Falloff = 0.05;\nconst float _Density = 35000.0;\nconst float _DensityExp = 32.0;\nconst float _Radius = 1.0;\n\n//Ray-sphere intersection\nbool raycastSphere(vec3 ro, vec3 rd, out vec3 p0, out vec3 p1, vec3 center, float r)\n{\n    float A = 1.0; //dot(rd, rd);\n    float B = 2.0 * (rd.x * (ro.x - center.x) + rd.y * (ro.y - center.y) + rd.z * (ro.z - center.z));\n    float C = dot(ro - center, ro - center) - (r * r);\n\n    float D = B * B - 4.0 * A * C;\n    if (D < 0.0)\n    {\n        return false;\n    }\n    else\n    {\n        float t0 = (-B - D)/(2.0 * A);\n        float t1 = (-B + D)/(2.0 * A);\n        p0 = ro + rd * t0;\n        p1 = ro + rd * t1;\n        return true;\n    }\n}\n\nvec3 rotateY(vec3 p, float t)\n{\n    float cosTheta = cos(t);\n    float sinTheta = sin(t);\n    mat3 rot = mat3(cosTheta, 0.0, sinTheta,\n        \t\t\t0.0, 1.0, 0.0,\n    \t\t\t    -sinTheta, 0.0, cosTheta);\n    \n    return rot * p;\n}\n\nvec3 rotateX(vec3 p, float t)\n{\n    float cosTheta = cos(t);\n    float sinTheta = sin(t);\n    mat3 rot = mat3(1.0, 0.0, 0.0,\n        \t\t\t0.0, cosTheta, -sinTheta,\n    \t\t\t    0.0, sinTheta, cosTheta);\n    \n    return rot * p;\n}\n\n//iq's lut based value noise\nfloat noise(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0).yx;\n    float result = mix( rg.x, rg.y, f.z );\n    result = (2.0 * result) - 1.0;\n\treturn result;\n}\n\nfloat fbm(vec3 seed, int octaves, float freq, float lac)\n{\n    float val;\n    float j = 1.0;\n    for (int i = 0; i < octaves; i++, j+=1.0)\n    {\n        val += noise(seed * freq * j) / pow(j, lac);\n    }\n\n    return val;\n}\n\nfloat sdSphere(vec3 pos, vec3 center, float radius)\n{\n    return length(center-pos) - radius;\n}\n\n//Density distribution function\nfloat sampleVolume(vec3 pos)\n{\n    float d = sdSphere(pos, vec3(0.0), _Radius * 0.85);\n    float p = 0.75-abs(d + abs(fbm(100.0+pos, 8, 2.5, 1.5)) * 0.055);\n    p = max(0.0,p);\n    p = pow(p, _DensityExp);\n    p *= _Density;\n  \n    if (p <= 0.0 || d > 0.6 )\n        return 0.0;\n    \n    p -= smoothstep(0.0,0.5,abs(fbm(400.0+pos, 8, 8.0, 0.5)) * 0.25);\n\n    p = max(0.0,p);\n                \n    return p;\n}\n\nfloat sampleXRay(vec3 pos)\n{\n    float result = abs(fbm(pos, 4, 4.0, 2.0));\n    float r = length(pos);\n    result *= smoothstep(0.9,0.5,r) * 2.0 * r;\n    return result;\n}\n\n//Raymarching loop\nvec4 raymarch(vec3 pos, vec3 dir, float ds, int s)\n{\n    vec4 result = vec4(0.,0.0,0.0,1.0);\n    int steps = min(s, MAX_STEPS);\n    for (int i = 0; i < steps; i++)\n    {\n        float p = sampleVolume(pos);\n        if (p >0.0)\n        {\n            result.rgb += _Emission * p * ds;\n            result.a *= exp(-p * ds);\n        }\n        \n        #ifndef OPTICAL_ONLY\n        float xray = sampleXRay(pos);\n        result.rgb += xray * vec3(0.0,1.0 * (1.0+noise(pos*4.0))*0.5,1.0) * ds;\n        #endif\n            \n        pos += dir * ds;\n    }\n        \n    return result;\n}\n\n//4x4 Bayer matrix for ordered dithering\nconst mat4 _Bayer4x4 = mat4(vec4(0,0.5,0.125,0.625),\n                        vec4(0.75,0.25,0.875,.375), \n                        vec4(0.1875,0.6875,0.0625,0.5625), \n                        vec4(0.9375,0.4375,0.8125,0.3125));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = iMouse.y/iResolution.y;\n    vec3 rayOrigin = vec3(0.0, 0.0, -5.0 + (5.0 * zoom));\n    //Compute eye vector from field of view\n    vec2 uv = fragCoord/iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n    float d = ar/tan(radians(_FoV/2.0));    \n    vec3 rayDir = normalize(vec3((-1.0 + 2.0 * uv) * vec2(ar, 1.0), d));\n    \n    #ifdef ROTATE\n    float t = iMouse.x * 0.01 + iTime * 0.2;\n\t#else\n    float t = iMouse.x * 0.01;\n    #endif\n    \n    rayDir = rotateY(rayDir, t);\n    rayOrigin = rotateY(rayOrigin, t);\n    \n    vec4 col = vec4(0.0,0.0,0.0,1.0);\n    \n    //Background\n    float starfield = smoothstep(0.9, 1.0, abs(noise(rayDir * 140.0)));\n    col.rgb += starfield * mix(vec3(1.0,0.5,0.3),vec3(0.7,0.8,1.0), starfield);\n    \n    #ifdef BACKGROUND\n    float nebula = abs(fbm(rayDir, 6, 2.0, 1.0));\n    nebula = smoothstep(0.5, 1.25,nebula);\n    nebula = max(0.0, nebula - abs(0.25*fbm(128.0 + rayDir, 6, 32.0, 1.0)));\n    col.rgb += nebula * mix(vec3(1.0, 0.4, 0.0), vec3(0.0,0.9,1.0),nebula-0.4) * 0.5;\n    #endif\n    \n    vec3 p0, p1;\n    if (raycastSphere(rayOrigin, rayDir, p0, p1, vec3(0.0), _Radius))\n    {        \n        #ifdef JITTER\n        //Bayer matrix ordered depth jittering\n        float width = (uv.x * iResolution.x);\n        float height = (uv.y * iResolution.y);\n        width = mod(width, 4.0);\n        height = mod(height, 4.0);\n        float offset = _Bayer4x4[int(width)][int(height)];\n        p0 -= rayDir * offset * STEP_SIZE*2.0;\n        #endif\n        \n        float dist = length(p1 - p0);\n        int s = int(dist/STEP_SIZE) + 1;\n        \n        vec4 integral = raymarch(p0, rayDir, STEP_SIZE, s);\n                \n        col.rgb = mix(integral.rgb, col.rgb, integral.a);\n    }\t\n       \n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}