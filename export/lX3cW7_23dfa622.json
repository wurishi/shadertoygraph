{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define PI 3.1415\n#define EPSILON 0.0005\n#define MIN_DISTANCE 0.005\n#define MAX_DISTANCE 150. \n#define PRECISION 0.001\n#define MERGE_RADIUS 0.5\n#define MAX_STEPS 155\n\nstruct Material {\n    vec3 ambientColor;\n    vec3 diffuseColor;\n    vec3 specularColor;\n    float alpha;\n};\n\n\nMaterial red() {\n  vec3 ambientColor = vec3(0., 0., 0.);\n  vec3 diffuseColor = vec3(1., 0., 0.);\n  vec3 specularColor = vec3(1, 1, 1);\n  float alpha = 20.;\n\n  return Material(ambientColor, diffuseColor, specularColor, alpha);\n}\n\nMaterial blue() {\n  vec3 ambientColor = 0.25 * vec3(0., 0., 0.9);\n  vec3 diffuseColor = 0.3 * vec3(0.9);\n  vec3 specularColor = 0.99 * vec3(1, 1, 1);\n  float alpha = 20.;\n\n  return Material(ambientColor, diffuseColor, specularColor, alpha);\n}\n\nMaterial green() {\n  vec3 ambientColor = 0.25 * vec3(0., 0.9, 0.);\n  vec3 diffuseColor = 0.3 * vec3(0.9);\n  vec3 specularColor = 0.99 * vec3(1, 1, 1);\n  float alpha = 20.;\n\n  return Material(ambientColor, diffuseColor, specularColor, alpha);\n}\n\n\n\nMaterial silver() {\n  vec3 ambientColor = 0.45 * vec3(0.8);\n  vec3 diffuseColor = 0.3 * vec3(0.3);\n  vec3 specularColor = 0.9 * vec3(1, 1, 1);\n  float alpha = 5.;\n\n  return Material(ambientColor, diffuseColor, specularColor, alpha);\n}\n\nMaterial gold() {\n  vec3 aCol = 0.5 * vec3(0.7, 0.5, 0);\n  vec3 dCol = 0.6 * vec3(0.7, 0.7, 0);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\n\nMaterial checkboard(vec3 p) {\n  //float f = mod(floor(1.5 * p.z) + floor(1.5 * p.x), 2.0);\n  //float f = mod(floor(1.5 * sin(p.x)), 2.0);\n  //float f = mod(floor(2.5 * sin(p.z)) + floor(2.5 * sin(p.x)), 2.0);\n  //float f = mod(floor(2.5 * sin(p.z)) + floor(2.5 * sin(p.x)), 3.0);\n  //float f = mod(floor(2.5 * sin(p.z)) + floor(2.5 * sin(p.x)), 4.0);\n  //float f = mod(floor(2.5 * tan(p.z)) + floor(2.5 * tan(p.x)), 5.0);\n  //float f = mod((0.3 * tan(p.z)) + (0.3 * tan(p.x)), 5.0);\n  //float f = mod((sin(p.z)) + (sin(p.x)), 2.0);\n  //float f = mod((sin(p.z)) + (sin(p.x)), 2.0);\n  //float f = mod((sin(cos(p.z))) + (sin(p.x)), 2.0);\n  float f = mod((atan(cos(p.z + iTime))) + (cos(2.*p.x + 3.*iTime )), 2.0);\n  \n//  vec3 ambientColor = 0.35 * vec3(0.3 + 1.*mod((floor(p.x) + floor(p.z)) , 2.0));\n  vec3 ambientColor = 0.35 * vec3(0.3 + 1.*f);\n  vec3 diffuseColor =  vec3(0.9);\n  vec3 specularColor = vec3(0.2);\n  float alpha = 3.;\n\n  return Material(ambientColor, diffuseColor, specularColor, alpha);\n}\n\nstruct Surface {\n    Material m; // material\n    float d; // distance\n};\n\n\nvec3 lightEmissionColor = vec3(1., 1., 1.);\n\n// return a distance from point p and a sphere with center c and radius r and tm (transform matrix)\nSurface sdSphere(vec3 p, vec3 c, float r, Material m, mat3 tm) {\n    return Surface(m, length(p  * tm - c) - r);\n}\n    \n    \n// return a distance from a point p and a floow at a height y (height of which the floor starts)\nSurface sdFloor(vec3 p, float y, Material m) {\n    //float f = mod(floor(1.5 * p.z) + floor(1.5 * p.x), 2.0);\n    //return Surface(m, f >= 0. ? p.y + y : 1000.); // hole or max\n    return Surface(m, p.y + y);\n}\n\n// based on  https://iquilezles.org/articles/distfunctions/\n\nSurface sdTorus(vec3 pr, vec2 t, Material m, mat3 tm) {\n  vec3 p = pr * tm;\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return Surface(m, length(q)-t.y);\n}\n\n// Euclidean distance function (same as builtin length(p)?)\n// source https://www.shadertoy.com/view/ltyXD3\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\n// Non-Euclidean distance function, so the sphere \"length8(p) = k\" is more squarish.\n// source https://www.shadertoy.com/view/ltyXD3\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\n// A torus with a squarish minor cross section, using non-Euclidean distance function.\n// source https://www.shadertoy.com/view/ltyXD3\nSurface sdTorus82(vec3 pr, vec2 t, Material m, mat3 tm)\n{\n   vec3 p = pr * tm;\n   vec2 q = vec2(length2(p.xz)-t.x,p.y);\n   return Surface(m, length8(q)-t.y);\n}\n\n\nSurface minSurface(Surface s1, Surface s2) {\n    Surface res = s1;\n    if (res.d > s2.d) res = s2;\n    return res;\n}\n\n/*\n        k *= 4.0;\n        float h = max(k-abs(a-b),0.0);\n        return min(a, b) - h*h*0.25/k;\n*/\n// based on https://iquilezles.org/articles/smin/\nSurface roundMerge(Surface surface1, Surface surface2, float radius) {\n   /*\n    float item1 = surface1.d;\n    float item2 = surface2.d;\n    float touchDistance = abs(item1 - item2);\n    \n    \n    vec2 intersection = vec2(item1 - radius, item2 - radius);\n    intersection = min(intersection, 0.0);\n    float insideDistance = length(intersection);\n    float simpleUnion = min(item1, item2);\n    float outsideDistance = max(simpleUnion, radius);\n    Surface res; res.d = outsideDistance - insideDistance;\n    \n    \n    if (touchDistance >= radius) {\n        if (item1 <= item2) res.m = surface1.m; else res.m = surface2.m;\n    } else {\n        float rr = touchDistance / MERGE_RADIUS;\n        res.m = surface1.m;\n        \n        if (surface1.d < surface2.d) {\n            res.m = Material(mix(surface2.m.ambientColor, surface1.m.ambientColor, rr), \n                             mix(surface2.m.diffuseColor, surface1.m.diffuseColor, rr), \n                             mix(surface2.m.specularColor, surface1.m.specularColor, rr), \n                             mix(surface2.m.alpha, surface1.m.alpha, rr));\n        } else {\n            res.m = surface2.m;\n        }\n    }\n   */\n    float item1 = surface1.d;\n    float item2 = surface2.d;\n    float touchDistance = abs(item1 - item2);\n    Surface res;\n    radius *= 4.0;\n    \n    float tmp = max(radius - touchDistance, 0.0);\n    tmp = tmp * tmp * 0.25 / radius;\n    //vec3 tmp3 = vec3(tmp);\n    res.d = min(surface1.d, surface2.d) - tmp;\n\n    if (touchDistance >= radius) {\n        if (item1 <= item2) res.m = surface1.m; else res.m = surface2.m;\n    } else {\n        float rr = touchDistance / MERGE_RADIUS / 4.;\n        res.m = surface1.m;\n        \n        if (surface1.d < surface2.d) {\n            res.m = Material(mix(surface2.m.ambientColor, surface1.m.ambientColor, rr), \n                             mix(surface2.m.diffuseColor, surface1.m.diffuseColor, rr), \n                             mix(surface2.m.specularColor, surface1.m.specularColor, rr), \n                             mix(surface2.m.alpha, surface1.m.alpha, rr));\n/*\n            res.m = Material(clamp(mix(surface2.m.ambientColor, surface1.m.ambientColor, rr) + surface1.m.ambientColor, 0., 1.),\n                             clamp(mix(surface2.m.diffuseColor, surface1.m.diffuseColor, rr) + surface1.m.diffuseColor, 0., 1.), \n                             clamp(mix(surface2.m.specularColor, surface1.m.specularColor, rr)+ surface1.m.specularColor, 0., 1.),\n                             clamp(mix(surface2.m.alpha, surface1.m.alpha, rr) + surface1.m.alpha, 0., 1.));\n                            \n*/\n        } else {\n            res.m = surface2.m;\n        }\n    }\n    \n    return  res;\n}\n\nSurface scene(vec3 pr) {\n    float sTime = iTime / 2.;\n    \n    // multiply pattern by mod'uling x,y,z coordinates\n    float cx = 0.;\n    float cy = 0.;\n    float cz = 0.;\n    float nx = cx > 0. ? mod(pr.x + 0.5 * cx, cx) - 0.5 * cx : pr.x;\n    float ny = cy > 0. ? mod(pr.y + 0.5 * cy, cy) - 0.5 * cy : pr.y;\n    float nz = cz > 0. ? mod(pr.z + 0.5 * cz, cz) - 0.5 * cz : pr.z;\n    //ny += 1.6 + sin(iTime);\n    vec3 p = vec3(nx, ny, nz);\n    \n    Surface sphere1 = sdSphere(pr + vec3(cos(sTime * 1.3) * 5.5, 0.0, -5.0), vec3(0.), 1., red(), identity());\n    Surface sphere2 = sdSphere(pr + vec3(sin(sTime) * 6.5, 3.0 + sin(iTime) * 2., -5.0), vec3(0.), 1., red(), identity());\n    Surface sphere3 = sdSphere(vec3(pr.x, pr.y + sin(sTime) * 6., pr.z - 5.), vec3(0.), 1., red(), identity());\n   \n    Surface res = roundMerge(sphere1, sphere2, MERGE_RADIUS);\n    res = roundMerge(res, sphere3, MERGE_RADIUS);\n    \n    //Surface res = minSurface(sphere1, sphere2);\n    //res = minSurface(res, sphere3);\n\n\n    float tR1 = 3.2;\n    Surface torus1 = sdTorus(vec3(pr.x, pr.y, pr.z - tR1 * 2.), vec2(3.2, 0.4), red(), rotateY(sTime) * rotateX(PI / 4.) * rotateZ(iTime));\n    res = roundMerge(res, torus1, MERGE_RADIUS);\n    //res = minSurface(res, torus1);\n        \n    \n    res = roundMerge(sdFloor(pr, 4., checkboard(pr)), res, MERGE_RADIUS / 2.);\n    //res = minSurface(sdFloor(pr, 4., checkboard(pr)), res);\n    return res;\n}\n\n\n\n\n// vector normal to sphere with cener c and radius r\nvec3 calcNormal(vec3 p) {\n  vec2 e = vec2(1.0, -1.0) * EPSILON;\n  return normalize(\n    e.xyy * scene(p + e.xyy).d +\n    e.yyx * scene(p + e.yyx).d +\n    e.yxy * scene(p + e.yxy).d +\n    e.xxx * scene(p + e.xxx).d);\n}\n\n\nstruct RaymarchRes {\n    Surface s;\n    vec3 p; // surface hit point\n    float d; // distance\n};\n\nRaymarchRes raymarch(vec3 ro, vec3 rd) {\n    float t = MIN_DISTANCE; \n    RaymarchRes res;\n    res.d = MAX_DISTANCE;\n        \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + t * rd;\n        Surface sf = scene(p); \n        t += sf.d;\n        \n        if (sf.d < PRECISION) { // we hit the surface at point p\n            //vec3 normalToSurfaceVector = calcNormal(p);\n            //res.l = clamp(dot(normalToSurfaceVector, normalize(lightVector - p)), 0.1, 1.);\n            res.p = p;\n            res.s = sf;\n            break;\n        } else if (sf.d > MAX_DISTANCE) break; // we did not hit anything but are to far away from camera \n            //t += sf.d; // we did not hit anything, keep on trying\n    }\n    \n    res.d = t;\n    return res;\n}\n    \nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n    vec3 cd = normalize(lookAtPoint - cameraPos);\n    vec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n    vec3 cu = normalize(cross(cd, cr));\n\n    return mat3(-cr, cu, -cd);\n}\n\n\nvec3 calculateCameraPosition(vec3 lookAt, vec2 uv) {\n    float cameraTime = iTime * 0.2;   \n    float phi = cameraTime + PI; \n    float theta = 0.24; \n\n    //vec3 ro = vec3(cos(theta) * cos(phi), sin(theta), cos(theta)*sin(phi)) * 6.0;\n    vec3 ro = vec3(0., 0., -5.);\n     \n    return ro;\n}\n\nvec3 calculateLightPosition() {\n    // calculate position of the light\n    float lightTime = iTime * 1.;\n    float lightRadius = 2.;\n    vec3 lightVector;\n    lightVector.x = 5.;//lightRadius * sin(lightTime) * 2.;\n    lightVector.y = -8.2;// + sin(iTime * 0.8);// * 3.2;\n    \n    lightVector.z = 10.;//2. + lightRadius * sin(lightTime); \n    \n    //lightVector = vec3(-2.0, 2.0, 5.0);\n    return lightVector;\n}\n\n\nfloat calcShadow(in vec3 ro, vec3 rd, float softness){ \n    //float t = MIN_DISTANCE; \n    float res = 1.0;\n    float t = 0.;\n   \n    ro += rd * MIN_DISTANCE * 2.;\n        \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + t * rd;\n        Surface sf = scene(p); \n        \n        if (abs(sf.d) < PRECISION) { // we hit the surface at point p so we have not reached light source\n            return 0.;\n        } else if (sf.d > MAX_DISTANCE) break; // we did not hit anything but are to far away from camera \n        \n        t += sf.d;\n        \n        res = min(res, softness * sf.d / t);\n    }\n        \n    return res;\n}\n\n\nvec3 calculateLight(vec2 fragCoord, RaymarchRes rr, vec3 rd, vec3 lo) {\n    vec3 normalToSurfaceVector = calcNormal(rr.p);\n    vec3 l = normalize(-lo + rr.p); // light direction\n    \n    vec3 diffusion = clamp(dot(l, normalToSurfaceVector), 0., 1.) * rr.s.m.diffuseColor * lightEmissionColor; // diffusion light\n    \n    vec3 newRayOrigin = rr.p + normalToSurfaceVector * PRECISION * 2. ;\n    float dotRV = clamp(dot(reflect(l, normalToSurfaceVector), rd), 0., 1.);\n    vec3 specular =  clamp(pow(dotRV, rr.s.m.alpha), 0., 1.) * rr.s.m.specularColor * lightEmissionColor;; // specular light\n    float shadowMask = calcShadow(newRayOrigin, normalize(rr.p - lo), 3.3);\n    \n    vec3 color = rr.s.m.ambientColor; // ambient light\n    color += (specular + diffusion) * shadowMask;\n    \n    //czy uzywac rr.p czy newRayOrigin\n    //if (shadowMask > -10.) {\n        // calculate reflection\n        //RaymarchRes ref = raymarch(rr.p, normalize(normalToSurfaceVector));\n        // r + g+ b divided by 3 is to calclute how 'dark' reflected light should be\n        //color += (ref.d < MAX_DISTANCE / 10.) ? ref.s.m.ambientColor * (color.r + color.g + color.b) / 3.  : vec3(0.); \n        // end of reflection calculation\n    //}\n  \n    color = clamp(color, 0., 1.);\n    \n\n    // gamma correction\n    float shadowGammaCorr = 0.8;\n    float lightGammaCorr = 1.0;\n    float shadowTreshold = 0.3;\n    color = mix(pow(color, vec3(1.0 / shadowGammaCorr)),\n            pow(color, vec3(1.0 / lightGammaCorr)), smoothstep(shadowTreshold, shadowTreshold + 0.1, (color.r + color.g + color.b) / 3.));\n\n    // vigniete\n    vec2 q = fragCoord.xy / iResolution.xy;\n    color = vec3(color * pow(20. * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.2)); // vigniete\n    color = mix(color, vec3(0.0,0.0,0.0), 1.0 - exp(-0.00006*rr.d*rr.d*rr.d)); // fog to black\n    \n    \n    // gamma correction basic\n    /*\n    float gammaCorr = 0.45;\n    color = pow(color, vec3(0.45));\n    */\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 lookAt = vec3(0.0,0., 0.);\n\n    vec3 ro = calculateCameraPosition(lookAt, uv);\n    vec3 rd = camera(ro, lookAt) * normalize(vec3(uv, -1.));\n    \n\n    //float stepSize = 2.0;     \n    //float smoothness = 0.9;  \n    //float wave = smoothIncreasingWave(iTime, stepSize, smoothness);\n    \n    //rd *= rotateY(wave);\n    //rd += vec3(fract(iTime), 0., 0.);\n    vec3 lo = calculateLightPosition();\n\n    //vec4 backgroundColor = vec4(mix(vec3(0., 0.1, .2), vec3(0., 0., 0.), uv.y) * 1.6, 1.0);\n    vec4 backgroundColor = vec4(mix(vec3(0., 0.1, .2), vec3(0., 0., 0.), uv.y) * 1.1, 1.0);\n    //RaymarchRes rr = raymarch(ro, rd);\n    RaymarchRes rr = raymarch(vec3(ro.x, ro.y, ro.z), rd);\n    fragColor = (rr.d < MAX_DISTANCE) ? vec4(calculateLight(fragCoord, rr, rd, lo), 1.0) : backgroundColor;    \n}\n","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"mat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lX3cW7","date":"1735161406","viewed":39,"name":"Phong balls play floor var #1","username":"cesio","description":"raymarching, phong, shadow, reflection, playing with floor pattern","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection","phong","shadow"],"hasliked":0,"parentid":"XXtcR7","parentname":"Phong balls play"}}