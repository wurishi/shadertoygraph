{"ver":"0.1","info":{"id":"msX3Rs","date":"1666636840","viewed":113,"name":"Truchet study 2","username":"Alpaga","description":"The tiles cannot be chosen completely at random because they won't match. Tiles on the horizontal and vertical axes are chosen at random, which completely determines all the other tiles.\n\nDrag the mouse horizontally to stay on one of the 5 patterns.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["gears","truchet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Thanks to BigWings - The Art of Code for explaining Truchet tilings:\n// https://www.shadertoy.com/view/3lBXWK\n// https://www.youtube.com/watch?v=2R7h76GoIJM&ab_channel=TheArtofCode\n\n// Truchet study 1: https://www.shadertoy.com/view/ddXGzS\n// A 3D application of Truchet study 2: https://www.shadertoy.com/view/cdsGzX\n\n// This study is my second study to understand how to make consistent tilings\n// when the tiles are assymmetric.\n\n// Contrary to study 1, it is not possible to choose each tile at random\n// depending on the parity of the cell. The reason is that no two tiles share\n// the same boundary.\n\n// The trick is to observe that some tiles share the same vertical boundary\n// and some tiles share the same horizontal boundary. We then choose at random\n// the tiles on the horizontal and vertical axes, which then entirely determines\n// the other tiles.\n\n// There are 5 patterns.\n\n// Durations\nconst float pause = 2., transition = 1.;\nconst float scale = 4.;\nconst float cameraSpeed = .2;\n\nconst int patterns = 5;\n\nconst vec3 yellow = vec3(1,1,0);\nconst vec3 orange = vec3(1,.5,0);\nconst vec3 blue = vec3(0,0,1);\nconst vec3 cyan = vec3(0,.5,1);\nconst vec3 black = vec3(0);\n\nconst float pi = 3.14159;\n\n// Hash functions from Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat rdBit(vec2 p) {\n    return step(.5,hash12(p));\n}\n// A pair of random bits, each one depending on\n// only one coordinate of p.\nvec2 rdBits(vec2 p) {\n    return step(.5,vec2(hash11(p.x), hash11(p.y+138.215)));\n}\nvoid flip(inout float x, float bit) {\n    x = mix(x,1.-x,bit);\n}\nvoid flip(inout vec2 p, vec2 bits) {\n    p = mix(p,1.-p,bits);\n}\n\n// Change col to targetColor if l>=threshold.\n// The change is smooth for antialiasing.\nvoid setColor(inout vec3 color, float l, float threshold, vec3 targetColor) {\n    float e = 2.*scale/iResolution.y;\n    color = mix(color,targetColor,smoothstep(threshold-e,threshold+e,l));\n}\n\n// The tile functions draw the lower left part of a tile,\n// consisting of an arc with more or less decorations.\n\n// Plain arc\nvec3 basicTile(vec2 p, float bit) {\n    flip(p.x,bit);\n    // Central symmetry\n    if(p.x+p.y>1.)\n        p = 1.-p;\n\n    float l = length(p);\n    float a = atan(p.y,p.x)*2./pi;// From 0 to 1\n    a = max(abs(mod(.6*a,.2)-.1)-.04,0.);\n    \n    vec3 col = black;\n    setColor(col,l,.35,orange);\n    setColor(col,l,.5-a,black);\n    setColor(col,l,.5+a,orange);\n    setColor(col,l,.65,black);\n    \n    return col;\n}\n\n// Arc with colored sides\n// side = 0: yellow inside, cyan outside\n// side = 1: cyan inside, yellow outside \nvec3 bicolorTile(vec2 p, vec2 parity, vec2 bits) {\n    flip(p,mod(parity+bits.yx,2.));\n    \n    vec3 color = yellow;\n    \n    if(p.x+p.y>1.) {\n        p = 1.-p;\n        color = cyan;\n    }\n    float l = length(p);\n    \n    vec3 col = black;\n    setColor(col,l,.35,color);\n    setColor(col,l,.65,black);\n    \n    return col;\n}\n\n// Arc with filled sides\n// side = 0: yellow inside, cyan outside\n// side = 1: cyan inside, yellow outside \nvec3 bicolorFilledTile(vec2 p, vec2 parity, vec2 bits) {\n    flip(p,mod(parity+bits.yx,2.));\n    \n    float par = mod(bits.x+bits.y,2.);\n    vec3 inside = mix(orange,blue,par);\n    vec3 outside = mix(blue,orange,par);\n    \n    vec3 color = yellow;\n    if(p.x+p.y>1.) {\n        p = 1.-p;\n        color = cyan;\n    }\n    float l = length(p);\n    \n    vec3 col = inside;\n    setColor(col,l,.35,color);\n    setColor(col,l,.65,outside);\n    \n    return col;\n}\n\n// Arc with oriented arrows\n// orientation = 0: arrows oriented from bottom edge to left edge\n// orientation = 1: arrows oriented from left edge to bottom edge\nvec3 arrowsTile(vec2 p, float parity, float bit) {\n    flip(p.x,mod(parity+bit,2.));\n    p = mix(p,p.yx,parity);\n    // Central symmetry\n    if(p.x+p.y>1.)\n        p = 1.-p;\n    \n    float l = abs(length(p)-.5);\n    float a = atan(p.y,p.x)*2./pi;// From 0 to 1\n        \n    // Arrows pattern\n    a = smoothstep(0.03,0.07,abs(mod(a+2.*l-.2*iTime,.2)-.1));\n    vec3 arrows = a * orange;\n    \n    vec3 col = arrows;\n    setColor(col,l,.15,black);\n\n    return col;\n}\n\n// Arc with peaks moving in a direction\n// orientation = 0: peaks moving from bottom edge to left edge\n// orientation = 1: peaks moving from left edge to bottom edge\nvec3 gearsTile(vec2 p, vec2 parity, vec2 bits) {\n    vec2 xor = mod(parity+bits,2.);\n    flip(p,xor.yx);\n    // Symmetry around antidiagonal\n    if(p.x+p.y>1.)\n        p = 1.-p.yx;\n    \n    float l = length(p);\n    float a = atan(p.y,p.x)*2./pi;// From 0 to 1\n    \n    // 3 gears inside\n    float b = min(abs(mod(1.2*a+.4*iTime,.4)-.2),.1);\n    // 5 gears outside\n    float c = min(abs(mod( 2.*a+.4*iTime,.4)-.2),.1);\n    \n    vec3 col = black;\n    setColor(col,l,.39-b,orange);\n    setColor(col,l,.61+c,black);\n\n    return col;\n}\n\n// Arc with oriented arrows + colored sides\n// (combination of arrowsTile and sidesTile)\n// orientation = 0: arrows oriented from bottom edge to left edge\n// orientation = 1: arrows oriented from left edge to bottom edge\n// side = 0: yellow inside, cyan outside\n// side = 1: cyan inside, yellow outside \nvec3 arrowsSidesTile(vec2 p, float parity, float bit) {\n    vec3 arrows = arrowsTile(p,parity,bit);\n\n    flip(p.x,mod(parity+bit,2.));\n    p = mix(p,p.yx,parity);\n    vec3 inside = mix(yellow,cyan,bit);\n    vec3 outside = mix(cyan,yellow,bit);\n    // Central symmetry\n    if(p.x+p.y>1.)\n        p = 1.-p;\n    \n    float l = length(p);\n    \n    vec3 col = inside;\n    setColor(col,l,.35,arrows);\n    setColor(col,l,.65,outside);\n    \n    return col;\n}\n\n// Arc with moving peaks. The peaks inside and\n// outside move in opposite directions.\n// flipping = 0: inside peaks moving from bottom edge to left edge\n// flipping = 1: inside peaks moving from left edge to bottom edge\nvec3 gearsTileBis(vec2 p, vec2 parity, vec2 bits) {\n    vec2 xor = mod(parity+bits,2.);\n    flip(p,xor.yx);\n    \n    // Symmetry around antidiagonal\n    if(p.x+p.y>1.) {\n        p = 1.-p.yx;\n    }\n    float bit = mod(bits.x+bits.y,2.);\n    vec3 inside = mix(yellow,cyan,bit);\n    vec3 outside = mix(cyan,yellow,bit);\n    \n    float l = length(p);\n    float a = atan(p.y,p.x)*2./pi;// From 0 to 1\n\n    float b = min(abs(mod(1.2*a+.4*iTime,.4)-.2),.1);\n    float c = min(abs(mod( 2.*a+.4*iTime,.4)-.2),.1);\n    \n    \n    vec3 col = black;\n    setColor(col,l,.39-b,inside);\n    setColor(col,l,.49,black);\n    setColor(col,l,.51,outside);\n    setColor(col,l,.61+c,black);\n\n    return col;\n}\nvec3 oppositeGearsTile(vec2 p, vec2 parity, vec2 bits) {\n    vec2 xor = mod(parity+bits.yx,2.);\n    flip(p,xor.yx);\n    \n    float bit = mod(bits.x+bits.y,2.);\n    vec3 inside = mix(yellow,cyan,bit);\n    vec3 outside = mix(cyan,yellow,bit);\n    \n    float l = length(p);\n    float a = atan(p.y,p.x)*2./pi;// From 0 to 1\n\n    // Shift peaks to makes the gears nest\n    float shift = .1*mod(xor.x+xor.y,2.);\n    float b = abs(mod(.6*a-.2*iTime+shift,.2)-.1);\n    float c = abs(mod(   a+.2*iTime+shift,.2)-.1);\n    \n    vec3 col = black;\n    setColor(col,l,.35-b,inside);\n    setColor(col,l,.49,black);\n    setColor(col,l,.51,outside);\n    setColor(col,l,.65+c,black);\n    \n    p = 1.-p.yx;\n    shift = .1-shift;\n    \n    l = length(p);\n    a = atan(p.y,p.x)*2./pi;// From 0 to 1\n\n    b = abs(mod(.6*a-.2*iTime+shift,.2)-.1);\n    c = abs(mod(   a+.2*iTime+shift,.2)-.1);\n    \n    setColor(col,.65+c,l,outside);\n    setColor(col,.51,l,black);\n    setColor(col,.49,l,inside);\n    setColor(col,.35-b,l,black);\n\n    return col;\n}\n\n\nvec3 tile(vec2 p, int n, vec2 parity, vec2 bits) {\n    n = n%patterns;\n    switch(n) {\n        case 0:\n            return bicolorTile(p,parity,bits);\n        case 1:\n            return gearsTile(p,parity,bits);\n        case 2:\n            return bicolorFilledTile(p,parity,bits);\n        case 3:\n            return gearsTileBis(p,parity,bits);\n        case 4:\n            return oppositeGearsTile(p,parity,bits);\n          break;\n    }\n}\n\nvec3 color(vec2 p, int n) {\n    vec2 g = floor(p);\n    vec2 f = fract(p);\n    \n    // A. Cell parity\n    vec2 parity = mod(g,2.);\n    // B. Random bit\n    vec2 bits = rdBits(g);\n        \n    return tile(f, n, parity, bits);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 col;\n    float size = iResolution.y/6.;\n    float margin = iResolution.y/20.;\n    \n    float leftpanel = 2.*size+3.*margin;\n\n    float t = mod(iTime, pause+transition);\n    // Pattern number\n    int n = int(floor(iTime/(pause+transition)))%patterns;\n    if(iMouse.z > 0.) {\n        n = int(floor(float(patterns)*iMouse.x/iResolution.x))%patterns;\n    }\n    \n    vec2 p;\n    vec2 parity, bits;\n\n    if(fragCoord.x < leftpanel) {\n        p = fragCoord;\n        // Patterns 0 and 1 have 4 tiles\n        float shift = n<=1 ? leftpanel : 4.*size+5.*margin;\n        p.y -= 0.5*(iResolution.y-shift);\n        vec2 g = floor(p/(size+margin));\n        p = mod(p,size+margin);\n        \n        // Patterns 0 and 1 have 4 tiles\n        float m = n<=1 ? 2. : 4.;\n        if(g.y >=0. && g.y<m && p.x>=margin && p.y>=margin) {\n            // Tile set\n            p = (p-margin)/size;\n        \n            parity = mod(g,2.);\n            bits = vec2(0,floor(g.y/2.));\n        \n            col = tile(p, n, parity, bits);\n        } else {\n            col = vec3(.5,0,0);\n            \n            fragColor = vec4(col,1.);\n            return;\n        }\n    } else {\n        vec2 center = 0.5+iResolution.xy;\n        center.x += leftpanel;\n    \n        p = (fragCoord-center)/iResolution.y;\n\n        p *= scale;\n        p += cameraSpeed * iTime;\n\n        vec2 g = floor(p);\n        p = fract(p);\n        \n        // A. Cell parity\n        parity = mod(g,2.);\n        // B. Random bit\n        bits = rdBits(g);\n    }\n    \n    if(iMouse.z > 0.) {\n        col = tile(p,n,parity,bits);\n    } else {\n        if(t<pause) { // Pause on a pattern\n            col = tile(p,n,parity,bits);\n        } else { // Transition between patterns\n            float x = (t-pause)/transition;\n            col = mix(tile(p,n,parity,bits),tile(p,n+1,parity,bits),x);\n        }\n    }\n   \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}