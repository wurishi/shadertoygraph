{"ver":"0.1","info":{"id":"4sBcDV","date":"1493794052","viewed":303,"name":"Heart Transplant","username":"SudoNhim","description":"IQ's heart code, transplanted into a voxel thingie\n\nBy request for Lara <3","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["voxels","heart"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n\n\n//[Scene]========================================\\\n\n#define VOXEL_ERROR 0\n#define VOXEL_NONE 1\n#define VOXEL_STONE 2\n#define VOXEL_HEART 3\n#define VOXEL_THEVOID 4\n\n#define EDGE_RADIUS 0.2\n\n// from Shane: Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D channel, vec3 p, vec3 n){\n    \n    n = max(abs(n) - .2, 0.001); // n = max(n*n, 0.001); // Etc.\n    n /= dot(n, vec3(1));\n    vec3 tx = textureLod(channel, p.zy*0.3, 0.0).xyz;\n    vec3 ty = textureLod(channel, p.xz*0.3+0.3, 0.0).xyz;\n    vec3 tz = textureLod(channel, p.xy*0.3+0.6, 0.0).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. \n    // Once the final color value is gamma corrected, you see should correct looking colors.\n    return tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n}\n\n// heart transplanted from iq: https://www.shadertoy.com/view/4lK3Rc\nfloat heart( vec3 q )\n{\n    q *= 1.3;\n    q.y += 8.0;\n    \n    float r = 15.0;\n    q.y -= r;\n    float ani = pow( 0.5+0.5*sin(6.28318*iTime + q.y/25.0), 4.0 );\n    q *= 1.0 - 0.2*vec3(1.0,0.5,1.0)*ani;\n    q.y -= 1.5*ani;\n    float x = abs(q.x);\n    \n    float y = q.y;\n    float z = q.z;\n    y = 4.0 + y*1.2 - x*sqrt(max((20.0-x)/15.0,0.0));\n    z *= 2.0 - y/15.0;\n    \n    return sqrt(x*x+y*y+z*z) - r;\n}\n\nfloat hemisphere(vec3 p)\n{\n    float sd = abs(length(p) - 20.0);\n    return max(p.y, sd);\n}\n\nbool isTerrainAt(ivec3 ip)\n{\n    vec3 v = tex3D(iChannel0, normalize(vec3(ip)), normalize(vec3(ip)));\n    bool h = heart(vec3(ip)) < 0.0;\n    bool t = hemisphere(vec3(ip)) * v.r * 2.0 < 1.8;\n    bool r = length(vec3(ip)) > 36.0;\n    \n    return t || h || r;\n}\n\nint getTerrainTypeAt(ivec3 ip)\n{    \n    if (length(vec3(ip)) > 36.0) return VOXEL_THEVOID;\n    if (heart(vec3(ip)) < 0.0) return VOXEL_HEART;\n    else if (isTerrainAt(ip)) return VOXEL_STONE;\n    else return VOXEL_ERROR;\n}\n\nfloat dfVoxel(vec3 p, bvec3 adj)\n{\n    vec3 cube = vec3(0.5, 0.5, 0.5) + vec3(adj);\n    return length(max(abs(p)-(cube - EDGE_RADIUS),0.0)) - EDGE_RADIUS;\n}\n\nvec3 nrmVoxel(vec3 p, bvec3 adj) \n{\n    p += 0.01 * normalize(p);\n    vec2 dd = vec2(0.001,0.0);\n    float base = dfVoxel(p, adj);\n    return normalize(vec3(\n        dfVoxel(p+dd.xyy, adj) - base,\n        dfVoxel(p+dd.yxy, adj) - base,\n        dfVoxel(p+dd.yyx, adj) - base\n    ));\n}\n\nbvec3 voxelAdjAt(ivec3 mapPos, vec3 p)\n{\n    ivec3 sp = ivec3(sign(p));\n    return bvec3(\n    \tisTerrainAt(mapPos + ivec3(sp.x, 0, 0)),\n    \tisTerrainAt(mapPos + ivec3(0, sp.y, 0)),\n        isTerrainAt(mapPos + ivec3(0, 0, sp.z)));\n}\n        \n//[/Scene]========================================/\n        \n        \n//[Voxel Marcher]=================================\\\n        \n#define MAX_HITS 4\n\nivec3 g_mapPos, g_rayStep;\nvec3 g_ro, g_rd, g_deltaDist, g_sideDist;\nivec3 g_hits[MAX_HITS];\nint g_nHits;\n        \nvoid voxelMarchInit(vec3 ro, vec3 rd)\n{\n    g_ro = ro;\n    g_rd = rd;\n\tg_mapPos = ivec3(floor(ro));\n    g_deltaDist = abs(vec3(length(rd)) / rd);\n    g_rayStep = ivec3(sign(rd));\n    g_sideDist = (sign(rd) * (vec3(g_mapPos) - ro) + (sign(rd) * 0.5) + 0.5) * g_deltaDist;\n    g_nHits = 0;\n}\n        \nvoid voxelMarchStep()\n{\n    vec3 mi = step( g_sideDist.xyz, g_sideDist.yzx ); \n    vec3 mm = mi*(1.0-mi.zxy);\n    g_sideDist += mm * vec3(g_rayStep) / g_rd;\n    g_mapPos += ivec3(mm)*g_rayStep;\n    if (isTerrainAt(g_mapPos) && g_nHits < MAX_HITS)\n        g_hits[g_nHits++] = g_mapPos;\n}\n\nstruct VoxelHit\n{\n    int terrainType;\n\tivec3 mapCoord;\n    vec3 hitLocation;\n    vec3 normal;\n    float weight;\n};\n        \nstruct VoxelMarchResult\n{\n    VoxelHit first;\n    VoxelHit second;\n};\n        \nVoxelMarchResult voxelMarchResolve()\n{\n    VoxelMarchResult result;\n    result.first.terrainType = VOXEL_NONE;\n    result.second.terrainType == VOXEL_NONE;\n    \n    if (g_nHits == 0) return result;\n    \n    // for hits before the last hit, do distance field intersection\n\tfor (int i=0; i<MAX_HITS-1; i++)\n    {\n        if (i == g_nHits-1) break;\n        \n        VoxelHit hit;\n        hit.mapCoord = g_hits[i];\n        hit.terrainType = getTerrainTypeAt(hit.mapCoord);\n        \n        // intersect with voxel cube\n        vec3 hitVoxelCenter = vec3(hit.mapCoord) + 0.5;\n        vec3 cubeIntersect = (hitVoxelCenter - g_ro - 0.5*sign(g_rd))/g_rd;\n        float dist = max(cubeIntersect.x, max(cubeIntersect.y, cubeIntersect.z));\n        \n        // get adjacency\n        bvec3 adj = voxelAdjAt(hit.mapCoord, g_ro + g_rd * dist - hitVoxelCenter);\n        \n        // distance march\n        float diff; float mindiff = 1.0; float finaldist = 0.0;\n        for (int i=0; i<8; i++) {\n            vec3 p = g_ro + g_rd * dist;\n            diff = dfVoxel(p - hitVoxelCenter, adj);\n            if (diff < mindiff) {\n                mindiff = diff;\n                finaldist = dist;\n            }\n            dist += diff; \n        }\n        \n        float pixSizeApprox = 2.0/iResolution.x * finaldist; // the FOV is actually about 1 radian :)\n        hit.weight = smoothstep(pixSizeApprox, 0.0, mindiff - 0.01); // anti-alias blend\n        hit.hitLocation = g_ro + g_rd * finaldist - hitVoxelCenter;\n        hit.normal = nrmVoxel(hit.hitLocation, adj);\n        \n        if (hit.weight > 0.0)\n            if (result.first.terrainType == VOXEL_NONE)\n                result.first = hit;\n            else {\n                result.second = hit;\n                return result;\n            }\n    }\n    \n    VoxelHit hit;\n    hit.mapCoord = g_hits[g_nHits-1];\n    hit.terrainType = getTerrainTypeAt(hit.mapCoord);\n    \n    // for the last hit, just do cube intersection\n    vec3 hitVoxelCenter = vec3(hit.mapCoord) + 0.5;\n    vec3 cubeIntersect = (hitVoxelCenter - g_ro - 0.5*sign(g_rd))/g_rd;\n    float dist = max(cubeIntersect.x, max(cubeIntersect.y, cubeIntersect.z));\n    bvec3 adj = voxelAdjAt(hit.mapCoord, g_ro + g_rd * dist - hitVoxelCenter);\n    \n    hit.weight = 1.0;\n    hit.hitLocation = g_ro + g_rd * dist - hitVoxelCenter;\n    hit.normal = nrmVoxel(hit.hitLocation, adj);\n    \n    if (result.first.terrainType == VOXEL_NONE)\n        result.first = hit;\n    else\n        result.second = hit;\n    \n    return result;\n}\n        \n//[/Voxel Marcher]================================/\n\n\n//[Render]========================================\\\n\nvec3 g_lightDir;\n\nfloat calcAmbientOcclusion(VoxelHit hit)\n{\n    float ambientOcc = 0.0;\n    \n    // for each of the 28 voxels surrounding the hit voxel\n    for (int i=-1; i<=1; i++) for (int j=-1; j<=1; j++) for (int k=-1; k<=1; k++) {\n        if (i == 0 && j == 0 && k == 0) continue; // skip the hit voxel\n        ivec3 offset = ivec3(i, j, k);\n\n        if (dot(hit.normal, vec3(offset)) <= 0.0) continue; \n        \n        int terrainType=VOXEL_STONE;\n        if (isTerrainAt(hit.mapCoord + offset)) {\n            \n            // use the distance from just above the intersection to estimate occlusion\n            float dist = dfVoxel(hit.hitLocation + hit.normal*0.5 - vec3(offset), bvec3(false));\n            ambientOcc += smoothstep(1.0, 0.0, dist);\n        }\n    }\n    \n    return ambientOcc / 8.0;\n}\n\nvec3 renderVoxelHit(VoxelHit hit)\n{\n    vec3 v = tex3D(iChannel0, normalize(vec3(hit.mapCoord)), normalize(vec3(hit.mapCoord)));\n    v.g = v.r*v.r;\n    v.r = 0.3 + 0.7*v.r;\n    \n    vec3 color = vec3(1.0, 0.0, 0.0);\n    if (hit.terrainType == VOXEL_THEVOID)\n        color = vec3(v*0.3);\n    if (hit.terrainType == VOXEL_STONE)\n        color = v * vec3(0.2, 0.1, 0.33);\n    if (hit.terrainType == VOXEL_HEART)\n        color = v*1.3;\n    \n    float ambient = 0.4*(1.0-calcAmbientOcclusion(hit));\n    float diffuse = 0.6*max(dot(hit.normal, g_lightDir), 0.0);\n    float diffuseH = 0.0;\n    if (hit.terrainType != VOXEL_HEART)\n        diffuseH = 3.0*max(dot(hit.normal, -normalize(vec3(hit.mapCoord))), 0.0)/heart(vec3(hit.mapCoord));\n    \n    return (ambient + diffuse) * color + diffuseH*vec3(1.0, 0.0, 0.0);\n}\n\n//[/Render]=======================================/\n\n\n//[Main]==========================================\\\n\nmat3 lookAt(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv = (fragCoord - iResolution.xy*.5 )/iResolution.y;\n    vec3 ro = vec3(sin(iTime*0.3)*24.0, sin(iTime*0.23)*6.0 + 20.0, cos(iTime*0.3)*24.0);\n    mat3 camMat = lookAt(ro, vec3(0.0), sin(iTime*0.1)*0.1);\n    vec3 rd = normalize(camMat*vec3(uv, (1.-dot(uv, uv)*.5)*.5));\n    \n    voxelMarchInit(ro, rd);\n    \n    for (int i=0; i<128; i++)\n        voxelMarchStep();\n    \n    VoxelMarchResult result = voxelMarchResolve();\n    \n    vec3 color = vec3(0.0);\n    g_lightDir = camMat*normalize(vec3(-1.0, -0.2, -.4));\n    if (result.first.terrainType != VOXEL_NONE)\n    {\n        color = renderVoxelHit(result.first);\n        if (result.second.terrainType != VOXEL_NONE)\n            color = mix(color, renderVoxelHit(result.second), 1.0-result.first.weight);\n    }\n    \n\tfragColor = vec4(color,1.0);\n}\n\n//[/Main]=========================================/","name":"Image","description":"","type":"image"}]}