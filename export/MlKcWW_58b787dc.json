{"ver":"0.1","info":{"id":"MlKcWW","date":"1536657338","viewed":266,"name":"bubbles_in_cube","username":"skaplun","description":"The main intention is to reproduce a 'sieve' animation from this post https://necessarydisorder.wordpress.com/\nBut this one is quite good-looking for me, so further work will be done in separate project.\nNeed to add AA.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define thickness .0025\n#define sqrt3 1.73205080757\n#define d .0125\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n    \nconst vec3 boxmin = vec3(-1., -1., -1.);\nconst vec3 boxmax = -boxmin;\n\nbool intersect(in vec3 orig, in vec3 dir, out float minDist, out float maxDist) {\n    float tmin = (boxmin.x - orig.x) / dir.x; \n    float tmax = (boxmax.x - orig.x) / dir.x; \n \n    if (tmin > tmax){\n    \tfloat tmp = tmin;\n        tmin = tmax;\n        tmax = tmp;\n    }\n \n    float tymin = (boxmin.y - orig.y) / dir.y; \n    float tymax = (boxmax.y - orig.y) / dir.y; \n \n    if (tymin > tymax){\n    \tfloat tmp = tymin;\n        tymin = tymax;\n        tymax = tmp;\n    }\n \n    if ((tmin > tymax) || (tymin > tmax)) \n        return false; \n \n    if (tymin > tmin) \n        tmin = tymin; \n \n    if (tymax < tmax) \n        tmax = tymax; \n \n    float tzmin = (boxmin.z - orig.z) / dir.z; \n    float tzmax = (boxmax.z - orig.z) / dir.z; \n \n    if (tzmin > tzmax){\n    \tfloat tmp = tzmin;\n        tzmin = tzmax;\n        tzmax = tmp;\n    }\n \n    if ((tmin > tzmax) || (tzmin > tmax)) \n        return false; \n \n    if (tzmin > tmin) \n        tmin = tzmin; \n \n    if (tzmax < tmax)\n        tmax = tzmax;\n \n    minDist = tmin;\n    maxDist = tmax;\n    return true;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvec3 clrInside(in float lmin, in float lmax, in vec3 origin,  vec3 dir){\n\tfloat iter = lmin + .01;\n    while(iter < lmax){\n    \tvec3 intersectionNormalized = vec3(.5) + (origin + dir * iter) * .5;\n        float y = floor(intersectionNormalized.y / thickness) * thickness;\n        float n = floor(fract(random(floor(intersectionNormalized.xz/d)) + iTime * .15) / thickness) * thickness;\n        float t = floor((sin(iTime) * .5 + .5) / thickness) * thickness;\n        vec2 muv = mod(intersectionNormalized.xz, d) * 2. - d;\n        if(y == max(n, t) && step(length(vec2(muv)), d * .75) == 1.)\n        \treturn vec3(y, 0., 0.);\n        iter += thickness;\n    }\n    return vec3(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(6. * sin(iTime * .25), 3., 6. * cos(iTime * .25));\n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float lmin, lmax;\n    if (intersect(eye, worldDir, lmin, lmax)) {\n        vec3 point = eye + worldDir * lmin;\n        fragColor = vec4(clrInside(lmin, lmax, eye, worldDir), 1.);\n        return;\n    }\n    \n    fragColor = vec4(0);\n}","name":"Image","description":"","type":"image"}]}