{"ver":"0.1","info":{"id":"mdjBzG","date":"1690126524","viewed":49,"name":"shader study 01","username":"yipooo","description":"这是我的设计稿 https://dribbble.com/shots/20532058-caustics-loading , 因为希望使用 shader 来实现 loading 效果,所以开始研究了起来;\n数学真有趣,发现每行代码去理解并翻译成母语之后学习效率好像提高了些;\nCan you give me some suggestions for improvement ?","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["simple","colorful","rgb","study","study","raymatching","primarycolors","motiondesign"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 主要参考了这两位大佬的shader,结构清晰真不错\n// https://www.shadertoy.com/view/XdfGRn\n// https://www.shadertoy.com/view/Xds3zN\n\n// 绕x轴旋转的函数\nmat3 rotationMatrixX(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c, -s,\n        0.0, s, c\n    );\n}\n\n// 绕y轴旋转的函数\nmat3 rotationMatrixY(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat3(\n        c, 0.0, s,\n        0.0, 1.0, 0.0,\n        -s, 0.0, c\n    );\n}\n\n// 绕z轴旋转的函数\nmat3 rotationMatrixZ(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat3(\n        c, -s, 0.0,\n        s, c, 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\n//=======================================================================\n\nvec3 circleColor( in vec3 pos, in vec3 nor, out vec2 spe ,float time,vec3 color)//输入物体的点,输入对应法线,输出颜色\n{\n\n    pos *= rotationMatrixY(3.14159*0.5)*rotationMatrixZ(-time*3.14159*2.0/6.0);\n    pos *= rotationMatrixY(sin(time)*3.14159*2.0/12.0+3.14159*2.0/24.0);\n    pos *= rotationMatrixX(-time*3.14159*2.0/6.0);\n    \n    //spe.x = 1.0;\n    //spe.y = 1.0;\n\n    float a = atan(pos.x,pos.z);\n    float r = length(pos.xz);\n\n    vec3 col = vec3(1.0,1.0,1.0);\n    \n    vec3 center = vec3(0.0,1.0,0.0); // 渐变的中心\n    float maxDistance = 2.0; // 根据需要调整这个值，它表示从中心开始，渐变应该完全变为vec3(1.0, 1.0, 1.0)的最大距离\n    vec3 posRelativeToCenter = pos - center; // 当前位置相对于中心的位置\n    float distance = length(posRelativeToCenter) / maxDistance; // 计算距离并进行归一化\n    float gradient = smoothstep(0.0, 1.0, distance); // 使用smoothstep函数生成渐变\n    vec3 gradientColor = mix(color, vec3(1.0, 1.0, 1.0), gradient); // 根据渐变值计算颜色\n    col = gradientColor; // 设置颜色\n\n    return col;\n}\n\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r,float time)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    \n    float smoothRadius = 0.001;\n    float result = sign(d)*sqrt(abs(d))/baba;\n    return result;\n}\n\n\nvec2 map( vec3 p ,float time)//定义场景\n{\n    p *=  rotationMatrixY(3.14159*0.5)*rotationMatrixZ(-time*3.14159*2.0/6.0);\n    p *=  rotationMatrixY(sin(time)*3.14159*2.0/12.0+3.14159*2.0/24.0);\n    p *=  rotationMatrixX(-time*3.14159*2.0/6.0);\n    \n    float cylinder = sdCylinder(p,vec3(0.001,0.0,0.0),vec3(-0.001,0.0,0.0),1.0,time);\n    \n    //vec2 d = abs(vec2(length(p.xz),p.y)) - 1.0;\n\n    return vec2(cylinder,1);\n}\n\nvec2 intersect( in vec3 ro, in vec3 rd,float time) //计算光线与场景中物体焦点,输入的是光线的发射位置和发射角度\n{\n    float t=0.0;\n    float lm = -1.0;\n    \n    for(int i=0;i<128;i++)\n    {\n        vec2 ma = map(ro+rd*t,time);\n        \n        if( abs(ma.x)<(0.0001*t) )\n            { \n                lm=ma.y; \n                break;\n            }\n        t += ma.x;\n        \n    }\n    return vec2(t,lm);\n}\n\n\nvec3 calcNormal( in vec3 pos ,float time)\n{\n    vec2 eps = vec2(.001,0.0);\n    return normalize( vec3(map(pos+eps.xyy,time).x - map(pos-eps.xyy,time).x,\n                           map(pos+eps.yxy,time).x - map(pos-eps.yxy,time).x,\n                           map(pos+eps.yyx,time).x - map(pos-eps.yyx,time).x ) );\n}\n\n\n\n//=======================================================================\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;//归一化坐标,左下角为0,0原点\n    vec2 p = -1.0 + 2.0 * q;//把原点移动到中间,中间为0,0\n    p.x *= iResolution.x/iResolution.y;//还原画布比例\n    \n     // camera\n    vec3 ro = 3.2*normalize(vec3(0.0,0.0,-1.0));//设置相机位置\n    vec3 ww = normalize(vec3(0.0,0.0,0.0) - ro);//相机朝向(0,1,0)目标点点减去ro点得到矢量方向ww\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));//相机的水平朝向,cross(叉积)计算同时垂直于两条直线的一条直线\n    vec3 vv = normalize(cross(ww,uu));//相机垂直朝向\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );//从相机出发发射的光线方向\n    \n    // raymarch\n    vec3 col1 = vec3(1.0,1.0,1.0);//设定基础颜色\n    vec3 col2 = vec3(1.0,1.0,1.0);//设定基础颜色\n    vec3 col3 = vec3(1.0,1.0,1.0);//设定基础颜色\n    \n    float time = iTime+2.1;\n    float d2 = 0.5;\n    float d3 = 1.0;\n    vec2 tmat = intersect(ro,rd,time);//输入光线位置,光线朝向,返回t值(射线距离t),lm()是一个标识符桌子是2 苹果是1\n    vec2 tmat2 = intersect(ro,rd,time+d2);//输入光线位置,光线朝向,返回t值(射线距离t),lm()是一个标识符桌子是2 苹果是1\n    vec2 tmat3 = intersect(ro,rd,time+d3);//输入光线位置,光线朝向,返回t值(射线距离t),lm()是一个标识符桌子是2 苹果是1\n    \n    \n    if( tmat.y>0.5 )//>0.5包括了是2的桌子,和是1的苹果\n    {\n        \n        ///第一组\n        vec3 pos = ro + tmat.x*rd; //射线击中的物体表面的点\n        vec3 colorB = vec3(1,1,0);\n        vec3 nor = calcNormal(pos,time);//计算这个表面点法线\n        vec2 pro; //\n        col1 = circleColor(pos,nor,pro,time,colorB);//输入物体表面的点,物体表面的点法线,和二位空?        \n    }\n    \n    if( tmat2.y>0.5 )//>0.5包括了是2的桌子,和是1的苹果\n    {\n\n        \n        ///第二组\n        vec3 pos2 = ro + tmat2.x*rd; //射线击中的物体表面的点\n        vec3 colorP = vec3(1,0,1);\n        vec3 nor2 = calcNormal(pos2,time+d2);\n        vec2 pro2; //\n        col2 = circleColor(pos2,nor2,pro2,time+d2,colorP);\n        \n    }\n    \n    if( tmat3.y>0.5 )//>0.5包括了是2的桌子,和是1的苹果\n    {\n        ///第二组\n        vec3 pos3 = ro + tmat3.x*rd; //射线击中的物体表面的点\n        vec3 colorY = vec3(0,1,1);\n        float con3 = 1.0;//定义光照强度\n        vec3 nor3 = calcNormal(pos3,time+d3);\n        vec2 pro3; //\n        col3 = circleColor(pos3,nor3,pro3,time+d3,colorY);\n        \n    }\n\n    fragColor = vec4(col1*col2*col3,1.0);\n\n    \n}\n","name":"Image","description":"","type":"image"}]}