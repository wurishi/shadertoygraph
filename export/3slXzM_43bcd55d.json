{"ver":"0.1","info":{"id":"3slXzM","date":"1550960896","viewed":458,"name":"hippieCircles","username":"ghost7","description":"test","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["circle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nint b(int N, int B) { return N>>B & 1; }\nint T[] = int[](0x15,0x38,0x32,0x2c,0x0d,0x13,0x07,0x2a);\nint A[] = int[](0,0,0);\n\nint b(int i, int j, int k, int B) { return T[b(i,B)<<2 | b(j,B)<<1 | b(k,B)]; }\n\nint shuffle(int i, int j, int k) {\n    return b(i,j,k,0) + b(j,k,i,1) + b(k,i,j,2) + b(i,j,k,3) +\n        b(j,k,i,4) + b(k,i,j,5) + b(i,j,k,6) + b(j,k,i,7) ;\n}\n\nfloat K(int a, vec3 uvw, vec3 ijk)\n{\n    float s = float(A[0]+A[1]+A[2])/6.0;\n    float x = uvw.x - float(A[0]) + s,\n        y = uvw.y - float(A[1]) + s,\n        z = uvw.z - float(A[2]) + s,\n        t = 0.6 - x * x - y * y - z * z;\n    int h = shuffle(int(ijk.x) + A[0], int(ijk.y) + A[1], int(ijk.z) + A[2]);\n    A[a]++;\n    if (t < 0.0)\n        return 0.0;\n    int b5 = h>>5 & 1, b4 = h>>4 & 1, b3 = h>>3 & 1, b2= h>>2 & 1, b = h & 3;\n    float p = b==1?x:b==2?y:z, q = b==1?y:b==2?z:x, r = b==1?z:b==2?x:y;\n    p = (b5==b3 ? -p : p); q = (b5==b4 ? -q : q); r = (b5!=(b4^b3) ? -r : r);\n    t *= t;\n    return 8.0 * t * t * (p + (b==0 ? q+r : b2==0 ? q : r));\n}\n    \nfloat noise(float x, float y, float z)\n{\n    float s = (x + y + z) / 3.0;  \n    vec3 ijk = vec3(int(floor(x+s)), int(floor(y+s)), int(floor(z+s)));\n    s = float(ijk.x + ijk.y + ijk.z) / 6.0;\n    vec3 uvw = vec3(x - float(ijk.x) + s, y - float(ijk.y) + s, z - float(ijk.z) + s);\n    A[0] = A[1] = A[2] = 0;\n    int hi = uvw.x >= uvw.z ? uvw.x >= uvw.y ? 0 : 1 : uvw.y >= uvw.z ? 1 : 2;\n    int lo = uvw.x <  uvw.z ? uvw.x <  uvw.y ? 0 : 1 : uvw.y <  uvw.z ? 1 : 2;\n    return K(hi, uvw, ijk) + K(3 - hi - lo, uvw, ijk) + K(lo, uvw, ijk) + K(0, uvw, ijk);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //box\n    //vec2 center = vec2(iResolution.x/2.0, iResolution.y/2.0);\n    //float boxSize = 200.0;\n    \n    //if (fragCoord.x > center.x - boxSize && fragCoord.x < center.x + boxSize && fragCoord.y > center.y - boxSize\n    //    && fragCoord.y < center.y + boxSize)\n    //{\n    //    float noiseyPt = noise(fragCoord.x, fragCoord.y, 0.0);\n    //\tfragColor = vec4(noiseyPt, noiseyPt, noiseyPt, noiseyPt);\n    //}\n    \n    \n    //circle\n    vec2 centerScreen = vec2(iResolution.x/2.0, iResolution.y/2.0);\n    float outerRadius = 150.0;\n    float innerRadius = 100.0;\n    \n    //just use distance!!! no need for formula of a circle bs!\n    float currentDistance = distance(fragCoord, centerScreen);\n    vec2 mouseDistance = vec2(distance(iMouse.x, centerScreen.x)/4.0, distance(iMouse.y, centerScreen.y));\n    float noiseSize = 8.0 * iTime;\n    \n    //float yMax = sqrt(pow(radius, 2.0) - pow(fragCoord.x - centerScreen.x, 2.0)) + centerScreen.y;\n    //float yMin = -1.0 * sqrt(pow(radius, 2.0) - pow(fragCoord.x - centerScreen.x, 2.0)) + centerScreen.y;\n    //float xMax = sqrt(pow(radius, 2.0) - pow(fragCoord.y - centerScreen.y, 2.0)) + centerScreen.x;\n    //float xMin = -1.0 * sqrt(pow(radius, 2.0) - pow(fragCoord.y - centerScreen.y, 2.0)) + centerScreen.x;\n\n    if (currentDistance > mouseDistance.x && currentDistance < mouseDistance.y)\n    {\n        float noiseyPt = iTime - 1.0/noise(fragCoord.x/noiseSize, fragCoord.y/noiseSize, iTime);\n        vec3 color = tan(noiseyPt + vec3(1, 2, 4));\n    \tfragColor = vec4(color, 0.5);\n    }\n    else\n    {\n        fragColor = vec4(255.0, 255.0, 255.0, 255.0);\n    }\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}