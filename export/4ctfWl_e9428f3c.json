{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"vec3 arrowTriangle(vec2 uv, vec2 coordc, vec2 pos1, vec2 pos2, vec2 pos3, vec2 c1, vec2 c2);\nfloat noise(vec2 p);\nfloat rand(vec2 n);\nvec3 bowstringTriangle(vec2 uv, vec2 pos1, vec2 pos2, vec2 pos3);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy - 0.5) * 2.0;\n    \n    //centralized pixel coords\n    vec2 coordc = (fragCoord - iResolution.xy/2.0) * 2.0;\n    \n    vec3 bgcol = vec3(0.1, 0.1, 0.23 - (uv.y + 0.4) * 0.07);\n    \n    if(uv.y < -pow(uv.x + 0.5, 2.0)/10.0 - 0.2){\n        if(uv.y > -pow(uv.x + 1.0, 2.0)/12.0 - 0.3){\n            if(noise(vec2(uv.x*7.0 + 0.03*sin(iTime + uv.y * 7.0) - 0.5, uv.y) * 100.0) > 0.75){\n                bgcol = vec3(0.11, 0.33, 0.1);\n            }\n            else{\n                bgcol = vec3(0.09, 0.26, 0.07);\n            }\n        }\n        else{\n            if(noise(vec2(uv.x*7.0 + 0.03*sin(iTime + uv.y * 7.0) - 0.5, uv.y) * 100.0) > 0.75){\n                bgcol = vec3(0.09, 0.25, 0.08);\n            }\n            else{\n                bgcol = vec3(0.07, 0.2, 0.05);\n            }\n        }\n        \n    }\n    \n    \n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    //projection matrix\n    mat4x3 proj;\n    proj[0] = vec3(3.0, 0.0, 0.0);\n    proj[1] = vec3(0.0, 3.0, 0.0);\n    proj[2] = vec3(0.0, 0.0, 1.0);\n    proj[3] = vec3(0.0, 0.0, 0.0);\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    //arrow: vertex and indices array\n    vec4 aVerts[12];\n    int aVertsLength = 12;\n    aVerts[0] = vec4(-1100.0, 200.0, 10.0, 1.0);\n    aVerts[1] = vec4(-600.0, 200.0, 10.0, 1.0);\n    aVerts[2] = vec4(-450.0, 70.0, 10.0, 1.0);\n    aVerts[3] = vec4(500.0, 70.0, 10.0, 1.0);\n    aVerts[4] = vec4(500.0, 200.0, 10.0, 1.0);\n    aVerts[5] = vec4(1100.0, 0.0, 10.0, 1.0);\n    aVerts[6] = vec4(500.0, -200.0, 10.0, 1.0);\n    aVerts[7] = vec4(500.0, -70.0, 10.0, 1.0);\n    aVerts[8] = vec4(-450.0, -70.0, 10.0, 1.0);\n    aVerts[9] = vec4(-600.0, -200.0, 10.0, 1.0);\n    aVerts[10] = vec4(-1100.0, -200.0, 10.0, 1.0);\n    aVerts[11] = vec4(-850.0, 0.0, 10.0, 1.0);\n    \n    for(int i = 0; i < aVertsLength; i++){\n        aVerts[i].z = 10.5 + (aVerts[i].x + 1100.0) * 0.005;\n    }\n    \n    int[30] aInds = int[30](0,1,11,1,2,11,2,8,11,8,9,11,9,10,11,2,3,7,2,7,8,3,4,5,7,3,5,6,7,5);\n    int aIndicesLength = 30;\n    \n    float modTime = mod(iTime, 5.0);\n    float epoch = floor(iTime/5.0);\n    \n    float disp = 0.0;\n    if(modTime < 1.0){\n        disp = -0.5 * modTime; \n    }\n    else{\n        disp = -0.5 + 6.0 * (modTime - 1.0); \n    }\n    vec4 aOffset = vec4(-500.0 + disp * 1200.0, 0.0, disp * 6.0, 0.0);\n    \n    vec4 c13d = aVerts[0] + aOffset;\n    vec4 c23d = aVerts[5] + aOffset;\n\n    vec3 c1h = proj * c13d;\n    vec3 c2h = proj * c23d;\n\n    vec2 c1 = (c1h.xy/c1h.z)/iResolution.xy;\n    vec2 c2 = (c2h.xy/c2h.z)/iResolution.xy;\n    \n    //projection and drawing each indexed triangle\n    for(int i = 0; i < aIndicesLength; i = i + 3){\n        vec4 pos13d = aVerts[aInds[i]] + aOffset;\n        vec4 pos23d = aVerts[aInds[i+1]] + aOffset;\n        vec4 pos33d = aVerts[aInds[i+2]] + aOffset;\n        \n        vec3 pos1h = proj * pos13d;\n        vec3 pos2h = proj * pos23d;\n        vec3 pos3h = proj * pos33d;\n\n        vec2 pos1 = (pos1h.xy/pos1h.z)/iResolution.xy;\n        vec2 pos2 = (pos2h.xy/pos2h.z)/iResolution.xy;\n        vec2 pos3 = (pos3h.xy/pos3h.z)/iResolution.xy;\n        \n        col = arrowTriangle(uv, coordc, pos1, pos2, pos3, c1, c2);\n        if(length(col) > 0.01){\n            break;\n        }\n    }\n    \n    //stars\n    vec3 starcol = vec3(0.0, 0.0, 0.0);\n    int numStars = int((rand(vec2(7.0, 1.0)) * 20.0 + 20.0));\n    for(int i = 0; i < numStars; i++){\n        float x = rand(vec2(19.0 * 84.76 + float(i), 2.0)) * iResolution.x * 2.0 - iResolution.x;\n        float y = rand(vec2(11.0 * 112.24 + float(i), 3.0)) * iResolution.y * 2.0 - iResolution.y;\n        if(y > iResolution.y/2.0 && length(vec2(x, y) - coordc) < 3.0){\n            starcol = vec3(0.65, 0.65, 0.65) + (sin(iTime + 2.4*x - 1.3*y)/2.0 + cos(2.3*iTime + 3.9*x + y)/2.0)/3.5;\n            break;\n        }\n    }\n    \n    \n    //bowstring\n    //bowstring: vertex and indices array\n    vec3 bscolt = vec3(0.0, 0.0, 0.0);\n    vec3 bscolb = vec3(0.0, 0.0, 0.0);\n    \n    vec4 bVerts[6];\n    int bVertsLength = 6;\n    bVerts[0] = vec4(-1850.0, 1803.75, 9.25, 1.0);\n    bVerts[1] = vec4(-1863.0, 1803.75, 9.25, 1.0);\n    bVerts[2] = vec4(-1850.0, 0.0, 9.25, 1.0);\n    bVerts[3] = vec4(-1863.0, 0.0, 9.25, 1.0);\n    bVerts[4] = vec4(-1850.0, -1803.75, 9.25, 1.0);\n    bVerts[5] = vec4(-1863.0, -1803.75, 9.25, 1.0);\n    \n    int[12] bInds = int[12](0, 1, 2, 1, 3, 2, 2, 3, 4, 3, 5, 4);\n    int bIndicesLength = 12;\n    \n    vec4 bOffset = vec4(0.0,0.0,0.0,0.0);\n    if(modTime > 5.0/6.0 && modTime < 0.98){\n        float dt = modTime - (5.0/6.0);\n        bOffset.x = -600.0 * dt;\n        bOffset.z = -3.0 * dt;\n    }\n    else if(modTime > 1.02 && modTime < 1.0 + (1.0/72.0)){\n        float dt = modTime - 1.0;\n        bOffset.x = -1350.0 + 7200.0 * dt;\n        bOffset.z = -0.5 + 36.0 * dt;\n    }\n    \n    \n    //projection and drawing each indexed triangle\n    for(int i = 0; i < bIndicesLength; i = i + 3){\n        vec4 pos13d = bVerts[bInds[i]];\n        vec4 pos23d = bVerts[bInds[i+1]];\n        vec4 pos33d = bVerts[bInds[i+2]];\n        \n        if(bInds[i] == 2 || bInds[i] == 3){\n            pos13d = pos13d + bOffset;\n        }\n        if(bInds[i+1] == 2 || bInds[i+1] == 3){\n            pos23d = pos23d + bOffset;\n        }\n        if(bInds[i+2] == 2 || bInds[i+2] == 3){\n            pos33d = pos33d + bOffset;\n        }\n        \n        vec3 pos1h = proj * pos13d;\n        vec3 pos2h = proj * pos23d;\n        vec3 pos3h = proj * pos33d;\n\n        vec2 pos1 = (pos1h.xy/pos1h.z)/iResolution.xy;\n        vec2 pos2 = (pos2h.xy/pos2h.z)/iResolution.xy;\n        vec2 pos3 = (pos3h.xy/pos3h.z)/iResolution.xy;\n        \n        if(i == 0 || i == 3){\n            bscolt = bowstringTriangle(uv, pos1, pos2, pos3);\n            if(length(bscolt) > 0.01){\n                break;\n            }\n        }\n        else{\n            bscolb = bowstringTriangle(uv, pos1, pos2, pos3);\n            if(length(bscolb) > 0.01){\n                break;\n            }\n        }\n        \n    }\n    \n    \n    \n    //draw the bow\n    vec3 bowcol = vec3(0.0,0.0,0.0);\n    float targetx = iResolution.x/2.0 - 250.0;\n    /*if(pow(fragCoord.x + 1000.0 - targetx, 2.0) + pow(fragCoord.y - 0.5*iResolution.y + 200.0, 2.0) > pow(1100.0, 2.0)){\n        bowcol = vec3(0.45, 0.33, 0.12);\n    }*/\n    if(pow(fragCoord.x + 450.0 - targetx, 2.0) + pow(fragCoord.y - 0.5*iResolution.y, 2.0) < pow(500.0, 2.0) && pow(fragCoord.x + 750.0 + 50.0 - targetx, 2.0) + pow(fragCoord.y - 0.5*iResolution.y, 2.0) > pow(800.0, 2.0)){\n        if(pow(fragCoord.x + 830.0 - targetx, 2.0) + pow(fragCoord.y - 0.5*iResolution.y + 60.0, 2.0) > pow(855.0, 2.0)){\n            bowcol = vec3(0.45, 0.33, 0.12);\n        }\n        else{\n            bowcol = vec3(0.35, 0.25, 0.04);\n        }     \n    }\n    \n    //orange    \n    \n    vec3 fruitcol = vec3(0.0,0.0,0.0);\n    vec2 opos = vec2(295.89, 0.0);\n    if(modTime < 1.5){\n        if(length(coordc - opos) < 20.0){\n            if(length(coordc - (opos - vec2(15, 7.5))) > 30.0){\n                fruitcol = vec3(0.75, 0.56, 0.13);\n            }\n            else{\n                fruitcol = vec3(0.6, 0.45, 0.05);\n            }\n            \n            vec2 spot1 = opos + vec2(2.3, 10.7);\n            vec2 spot2 = opos + vec2(-8.1, -5.2);\n            vec2 spot3 = opos + vec2(12.1, -7.7);\n            vec2 spot4 = opos + vec2(0.5, -1.0);\n            vec2 spot5 = opos + vec2(15.0, 3.3);\n            \n            if(length(coordc - spot1) < 2.0){\n                fruitcol = fruitcol - vec3(0.15, 0.15, 0.15);\n            }\n            if(length(coordc - spot2) < 2.0){\n                fruitcol = fruitcol - vec3(0.15, 0.15, 0.15);\n            }\n            if(length(coordc - spot3) < 2.0){\n                fruitcol = fruitcol - vec3(0.15, 0.15, 0.15);\n            }\n            if(length(coordc - spot4) < 2.0){\n                fruitcol = fruitcol - vec3(0.15, 0.15, 0.15);\n            }\n            if(length(coordc - spot5) < 2.0){\n                fruitcol = fruitcol - vec3(0.15, 0.15, 0.15);\n            }\n            \n        }\n    }\n    else{\n        const int numPellets = 5;\n    \n        vec3 pellets[numPellets]; //x and y for direction, z for radius\n        vec3 pelletColors[numPellets];\n        \n        float dt = (modTime - 1.5);\n\n        for(int i = 0; i < numPellets; i++){\n            pellets[i].x = rand(vec2(epoch + float(i), 100.0)) * 150.0 - 75.0;\n            pellets[i].y = rand(vec2(epoch + float(i), 200.0)) * 150.0 - 75.0;\n            pellets[i].z = rand(vec2(epoch + float(i), 300.0)) * 4.0 + 5.0 - dt * 5.0;\n            pelletColors[i].x = 0.69;\n            pelletColors[i].y = 0.4 + rand(vec2(epoch + float(i), 400.0)) * 0.3;\n            pelletColors[i].z = 0.2;\n\n            if(length(fruitcol) < 0.01){\n                if(length(coordc - (opos + pellets[i].xy * dt)) < pellets[i].z){\n                    fruitcol = pelletColors[i];\n                }\n            }\n        }\n    }\n    \n    //moon\n    \n    vec2 moonLoc = vec2(iResolution.x * 0.75, iResolution.y * 0.75);\n    float radius = 50.0;\n    vec3 mooncol = vec3(0.0, 0.0, 0.0);\n    if(length(coordc - moonLoc) < radius){\n        if(length(coordc - (moonLoc + vec2(12.5, 0.0))) > radius){\n            mooncol = vec3(0.8, 0.8, 0.8);\n        }\n        else{\n            mooncol = bgcol + vec3(0.25, 0.25, 0.25) * min(0.5, (50.0/(length(coordc - (moonLoc - vec2(15.0, 0.0)))) - 0.3));\n        }\n    }\n    else if(length(coordc - (moonLoc - vec2(15.0, 0.0))) < radius * 4.0){\n        mooncol = bgcol + vec3(0.25, 0.25, 0.25) * max(0.0, (50.0/(length(coordc - (moonLoc - vec2(15.0, 0.0)))) - 0.3));\n    }\n    \n    \n    vec3 finalColor = vec3(0.0, 0.0, 0.0);\n    finalColor = bowcol;\n    \n\n\n    // Output to screen\n    if(length(finalColor) < 0.01){\n        finalColor = bscolt;\n    }\n    if(length(finalColor) < 0.01){\n        finalColor = col;\n    }\n    if(length(finalColor) < 0.01){\n        finalColor = bscolb;\n    }\n    if(length(finalColor) < 0.01){\n        finalColor = fruitcol;\n    }\n    if(length(finalColor) < 0.01){\n        finalColor = mooncol;\n    }\n    if(length(finalColor) < 0.01){\n        finalColor = starcol;\n    }\n    if(length(finalColor) < 0.01){\n        finalColor = bgcol;\n    }\n    fragColor = vec4(finalColor,1.0);\n}\n\nvec3 arrowTriangle(vec2 uv, vec2 coordc, vec2 pos1, vec2 pos2, vec2 pos3, vec2 c1, vec2 c2){    \n    \n    vec2 edge1 = normalize(pos2 - pos1);\n    vec2 edge2 = normalize(pos3 - pos2);\n    vec2 edge3 = normalize(pos1 - pos3);\n    \n    vec2 n1 = vec2(edge1.y, -edge1.x);\n    vec2 n2 = vec2(edge2.y, -edge2.x);\n    vec2 n3 = vec2(edge3.y, -edge3.x);\n    \n    vec2 q1 = normalize(uv - pos1);\n    vec2 q2 = normalize(uv - pos2);\n    vec2 q3 = normalize(uv - pos3);\n    \n    float d1 = dot(n1, q1);\n    float d2 = dot(n2, q2);\n    float d3 = dot(n3, q3);\n    \n    if((d1 < 0.0 && d2 < 0.0 && d3 < 0.0) || (d1 > 0.0 && d2 > 0.0 && d3 > 0.0)){\n        float ny = 0.35 * c1.y + 0.65 * c2.y;\n        float m = (c2.y - ny)/(c2.x - c1.x);\n        if(uv.y > m * (uv.x - c2.x) + c2.y){\n            return vec3(0.75, 0.75, 0.75);\n        }\n        else{\n            return vec3(0.6, 0.6, 0.6);\n        }\n            \n    }\n    else{\n        return vec3(0, 0, 0);\n    }\n    \n}\n\nvec3 bowstringTriangle(vec2 uv, vec2 pos1, vec2 pos2, vec2 pos3){    \n    \n    vec2 edge1 = normalize(pos2 - pos1);\n    vec2 edge2 = normalize(pos3 - pos2);\n    vec2 edge3 = normalize(pos1 - pos3);\n    \n    vec2 n1 = vec2(edge1.y, -edge1.x);\n    vec2 n2 = vec2(edge2.y, -edge2.x);\n    vec2 n3 = vec2(edge3.y, -edge3.x);\n    \n    vec2 q1 = normalize(uv - pos1);\n    vec2 q2 = normalize(uv - pos2);\n    vec2 q3 = normalize(uv - pos3);\n    \n    float d1 = dot(n1, q1);\n    float d2 = dot(n2, q2);\n    float d3 = dot(n3, q3);\n    \n    if((d1 < 0.0 && d2 < 0.0 && d3 < 0.0) || (d1 > 0.0 && d2 > 0.0 && d3 > 0.0)){\n        return vec3(0.4, 0.4, 0.4);\n    }\n    \n}\n\n//noise function borrowed from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n    ","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4ctfWl","date":"1734145653","viewed":33,"name":"moonlight fruit shoot","username":"Augustus31","description":"see title","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"4ctBWl","parentname":"recreational archery"}}