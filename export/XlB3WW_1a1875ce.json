{"ver":"0.1","info":{"id":"XlB3WW","date":"1428820268","viewed":310,"name":"000 Missing Square Puzzle","username":"nmarsden","description":"optical illusion","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nuniform vec2 resolution;\nuniform float time;\n\nconst float PI = 3.14159;\nconst float NUM_GRID_X_CELLS = 13.0;\nconst float NUM_GRID_Y_CELLS = 5.0;\nconst float GRID_WIDTH_PERCENT = 0.78;\n\nvec2 rotate_point(vec2 pivot, float angle, vec2 point )\n{\n  \tvec2 rotation = vec2(cos(angle), sin(angle));\n\n  \t// translate point back to origin:\n  \tpoint.x -= pivot.x;\n  \tpoint.y -= pivot.y;\n\n  \t// rotate point\n  \tfloat xnew =  point.x * rotation.x + point.y * rotation.y;\n  \tfloat ynew =  point.y * rotation.x - point.x * rotation.y;\n\n  \t// translate point back:\n  \tpoint.x = xnew + pivot.x;\n  \tpoint.y = ynew + pivot.y;\n  \treturn point;\n}\n\nfloat draw_rectangle( vec2 uv, vec2 center, float width, float height )\n{\n    float half_width = width / 2.0;\n    float half_height = height / 2.0;\n\n    float right_edge = step(center.x+half_width,uv.x);\n    float left_edge = (1.0 - step(center.x-half_width,uv.x));\n    float top_edge = step(center.y+half_height,uv.y);\n    float bottom_edge = (1.0 - step(center.y-half_height,uv.y));\n\n    float border = 1.0 - min(right_edge + left_edge + top_edge + bottom_edge, 1.0);\n\n    return border;\n}\n\n\nfloat draw_triangle( vec2 uv, vec2 center, float width, float height )\n{\n    // calc start_point and end_point for longest edge (hypotenuse) of the triangle\n    vec2 start_point = vec2(center.x - width/0.5, center.y - height/0.5);\n    vec2 end_point   = vec2(center.x + width/0.5, center.y + height/0.5);\n\n    // determine m and c for the linear equation: y = mx + c\n    float m = (end_point.y - start_point.y) / (end_point.x - start_point.x);\n    float c = start_point.y - (m * start_point.x);\n\n    // check if uv is below the line\n    float y = m * uv.x + c;\n    if (uv.y < y) {\n        return draw_rectangle(uv, center, width, height);\n    }\n    return 0.0;\n}\n\nfloat draw_vertical_line( vec2 uv, vec2 start_point, vec2 end_point, float line_width )\n{\n    if (uv.y < min(start_point.y, end_point.y) || uv.y > max(start_point.y, end_point.y)) {\n        return 0.0;\n    }\n    if (uv.x >= (start_point.x - line_width*0.5) && uv.x <= (start_point.x + line_width*0.5)) {\n        return 1.0;\n    }\n    return 0.0;\n}\n\nfloat draw_horizontal_line( vec2 uv, vec2 start_point, vec2 end_point, float line_width )\n{\n    if (uv.x < min(start_point.x, end_point.x) || uv.x > max(start_point.x, end_point.x)) {\n        return 0.0;\n    }\n    if (uv.y >= (start_point.y - line_width*0.5) && uv.y <= (start_point.y + line_width*0.5)) {\n        return 1.0;\n    }\n    return 0.0;\n}\n\nvec3 grid( vec2 uv, float cell_width, float line_width )\n{\n    vec3 background = vec3(1.0, 1.0, 1.0);\n    float grid_width = NUM_GRID_X_CELLS * cell_width;\n    float grid_height = NUM_GRID_Y_CELLS * cell_width;\n\n    for (float y_cell=0.0; y_cell <= NUM_GRID_Y_CELLS; y_cell++) {\n        float y = y_cell * cell_width;\n\t\tbackground -= draw_horizontal_line(uv, vec2(0.0, y), vec2(grid_width, y), line_width);\n    }\n    for (float x_cell=0.0; x_cell <= NUM_GRID_X_CELLS; x_cell++) {\n        float x = x_cell * cell_width;\n\t\tbackground -= draw_vertical_line(uv, vec2(x, 0.0), vec2(x, grid_height), line_width);\n    }\n    return background;\n}\n\nfloat piece_A( vec2 uv, vec2 position, float cell_width )\n{\n\tfloat col = draw_rectangle (uv, cell_width * vec2(position.x + 2.5, position.y - 0.5), 5.0 * cell_width, cell_width);\n\tcol += draw_rectangle (uv, cell_width * vec2(position.x + 1.0, position.y - 1.5), 2.0 * cell_width, cell_width);\n    return min(col, 1.0);\n}\n\nfloat piece_B( vec2 uv, vec2 position, float cell_width )\n{\n\tfloat col = draw_rectangle (uv, cell_width * vec2(position.x + 3.5, position.y - 0.5), 3.0 * cell_width, cell_width);\n\tcol += draw_rectangle (uv, cell_width * vec2(position.x + 2.5, position.y - 1.5), 5.0 * cell_width, cell_width);\n    return min(col, 1.0);\n}\n\nfloat piece_C( vec2 uv, vec2 position, float cell_width )\n{\n    return draw_triangle(uv, cell_width * vec2(position.x + 2.5, position.y - 1.0), 5.0 * cell_width, 2.0 * cell_width);\n}\n\nfloat piece_D( vec2 uv, vec2 position, float cell_width )\n{\n    return draw_triangle(uv, cell_width * vec2(position.x + 4.0, position.y - 1.5), 8.0 * cell_width, 3.0 * cell_width);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n\n\tfloat max_x = iResolution.x / iResolution.y;\n\n\tfloat line_width = 1.0 / iResolution.y;\n\n    float t = iTime*0.5;\n\n    vec3 blue   = vec3(0.1, 0.1, 0.8);\n    vec3 yellow = vec3(1.0, 1.0, 0.1);\n    vec3 red    = vec3(0.8, 0.1, 0.1);\n    vec3 green  = vec3(0.2, 0.8, 0.1);\n    vec3 black  = vec3(0.0, 0.0, 0.0);\n\n    vec3 col = vec3(0.0,0.0,0.0);\n\n    float anim_time = 7.0;\n    float a = clamp(sin(2.0*PI/anim_time*(t + anim_time * 0.25)) + 0.5, 0.0, 1.0);\n\n\tfloat cell_width = (max_x * GRID_WIDTH_PERCENT) / NUM_GRID_X_CELLS;\n\tcell_width = 2.0 * (ceil(cell_width * 10000.0) / 20000.0); // ensure cell_width is an even number to four decimal places\n\n    uv.x -= (max_x - (cell_width * NUM_GRID_X_CELLS)) * 0.5;\n    uv.y -= (1.0 - (cell_width * NUM_GRID_Y_CELLS)) * 0.5;\n\n    vec2 piece_A_pos = mix(vec2(5.0, 2.0), vec2(8.0, 3.0), a);\n\tvec2 piece_B_pos = vec2(8.0, 2.0);\n\tvec2 piece_C_pos = mix(vec2(0.0, 2.0), vec2(8.0, 5.0), a);\n\tvec2 piece_D_pos = mix(vec2(5.0, 5.0), vec2(0.0, 3.0), a);\n    vec2 uv_rotated = rotate_point(vec2(0.5, 0.4), mix(0.0, 2.0*PI, a), uv);\n\n   \tcol += mix(yellow * piece_C(uv,         piece_C_pos, cell_width), black, ceil(col));\n   \tcol += mix(red    * piece_A(uv,         piece_A_pos, cell_width), black, ceil(col));\n   \tcol += mix(blue   * piece_B(uv,         piece_B_pos, cell_width), black, ceil(col));\n   \tcol += mix(green  * piece_D(uv_rotated, piece_D_pos, cell_width), black, ceil(col));\n\n    vec3 background = grid(uv, cell_width, line_width);\n    col = mix(background, col, ceil(col));\n\n    col = mix(col, vec3(dot(col,vec3(.33))),.5);  // fix harsh coder colors - thanks to mu6k !\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}