{"ver":"0.1","info":{"id":"43jBDc","date":"1731769709","viewed":132,"name":"【Sessions 2024】Stairs House","username":"ukeyshima","description":"Sessions 2024 GLSL Graphics Compo","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["pathtracing","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec4 tex = texture( iChannel0, uv );\n  vec3 color = tex.xyz;\n  fragColor = vec4( color, 1 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// COMMON DEFINITIONS\n#define EPS 0.002\n#define FLOAT_MAX float(0xffffffffu)\n#define MOD(A, B) (A - B * floor(A / B))\n#define MIN2(A) (min(A.x, A.y))\n#define MIN3(A) (min(A.x, min(A.y, A.z)))\n#define CROSS(X, Y) vec3(X.y*Y.z - X.z*Y.y, X.z*Y.x - X.x*Y.z, X.x*Y.y - X.y*Y.x)\n#define SATURATE(A) clamp(A, 0.0, 1.0)\n#define PI (3.14159265359)\n#define TAU (6.28318530718)\n#define OO vec2(0.0, 0.0)\n#define IO vec2(1.0, 0.0)\n#define OI vec2(0.0, 1.0)\n#define II vec2(1.0, 1.0)\n#define JO vec2(-1.0, 0.0)\n#define OJ vec2(0.0, -1.0)\n#define JJ vec2(-1.0, -1.0)\n#define IJ vec2(1.0, -1.0)\n#define JI vec2(-1.0, 1.0)\n#define OOO vec3(0.0, 0.0, 0.0)\n#define IOO vec3(1.0, 0.0, 0.0)\n#define OIO vec3(0.0, 1.0, 0.0)\n#define OOI vec3(0.0, 0.0, 1.0)\n#define IOI vec3(1.0, 0.0, 1.0)\n#define IIO vec3(1.0, 1.0, 0.0)\n#define OII vec3(0.0, 1.0, 1.0)\n#define III vec3(1.0, 1.0, 1.0)\n#define JOO vec3(-1.0, 0.0, 0.0)\n#define OJO vec3(0.0, -1.0, 0.0)\n#define OOJ vec3(0.0, 0.0, -1.0)\n#define JJO vec3(-1.0, -1.0, 0.0)\n#define JOJ vec3(-1.0, 0.0, -1.0)\n#define OJJ vec3(0.0, -1.0, -1.0)\n#define JJJ vec3(-1.0, -1.0, -1.0)\n#define IJJ vec3(1.0, -1.0, -1.0)\n#define JIJ vec3(-1.0, 1.0, -1.0)\n#define JJI vec3(-1.0, -1.0, 1.0)\n#define IIJ vec3(1.0, 1.0, -1.0)\n#define IJI vec3(1.0, -1.0, 1.0)\n#define JII vec3(-1.0, 1.0, 1.0)\n#define IOJ vec3(1.0, 0.0, -1.0)\n#define JIO vec3(-1.0, 1.0, 0.0)\n#define IJO vec3(1.0, -1.0, 0.0)\n//TRANSFORMATIONS\nmat3 TransformBasis(vec3 y, vec3 z)\n{\n    vec3 x = normalize(CROSS(y, z));\n    y = CROSS(z, x);\n    return mat3(x, y, z);\n}\nmat2 rotate2d(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n//DISTANCE FUNCTIONS\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdStairs(vec2 p)\n{\n    vec2 pf = vec2(p.x + p.y, p.x + p.y) * 0.5;\n    vec2 d = p - vec2(floor(pf.x), ceil(pf.y));\n    vec2 d2 = p - vec2(floor(pf.x + 0.5), floor(pf.y + 0.5));\n    float d3 = length(vec2(min(d.x, 0.0), max(d.y, 0.0)));\n    float d4 = length(vec2(max(d2.x, 0.0), min(d2.y, 0.0)));\n    return d3 - d4;\n}\nfloat sdStairs(vec2 p, float h)\n{\n    p.xy = p.y < p.x ? p.yx : p.xy;\n    return sdStairs(p - vec2(0.0, h));\n}\nfloat sdStairs(vec3 p, float h, float w)\n{\n    float x = abs(p.x) - w;\n    float d = sdStairs(p.zy, h);\n    return max(x, d);\n}\n//INFO\nstruct Surface {\n    int surfaceId;\n    int objectId;\n    float distance;\n};\nstruct Material {\n    vec3 baseColor;\n    float roughness;\n    vec3 emission;\n};\nSurface minSurface(Surface a, Surface b)\n{\n    if (a.distance < b.distance)\n    {\n        return a;\n    }\n    return b;\n}\n//HASH FUNCTIONS\nuint Pcg(uint v)\n{\n\tuint state = v * 747796405u + 2891336453u;\n\tuint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n\treturn (word >> 22u) ^ word;\n}\nuvec2 Pcg2d(uvec2 v)\n{\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n    v = v ^ (v>>16u);\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n    v = v ^ (v>>16u);\n    return v;\n}\nuvec3 Pcg3d(uvec3 v)\n{\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v ^= v >> 16u;\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    return v;\n}\nuvec4 Pcg4d(uvec4 v)\n{\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v.w += v.y*v.z;\n    v ^= v >> 16u;\n    v.x += v.y*v.w;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v.w += v.y*v.z;\n    return v;\n}\nfloat Pcg01(uint v) { return float(Pcg(v)) / FLOAT_MAX; }\nvec2 Pcg01(uvec2 v) { return vec2(Pcg2d(v)) / FLOAT_MAX; }\nvec3 Pcg01(uvec3 v) { return vec3(Pcg3d(v)) / FLOAT_MAX; }\nvec4 Pcg01(uvec4 v) { return vec4(Pcg4d(v)) / FLOAT_MAX; }\nfloat Pcg01(int v) { return Pcg01(uint(v)); }\nvec2 Pcg01(ivec2 v) { return Pcg01(uvec2(v)); }\nvec3 Pcg01(ivec3 v) { return Pcg01(uvec3(v)); }\nvec4 Pcg01(ivec4 v) { return Pcg01(uvec4(v)); }\nfloat Pcg01(float v) { return Pcg01(floatBitsToUint(v)); }\nvec2 Pcg01(vec2 v) { return Pcg01(floatBitsToUint(v)); }\nvec3 Pcg01(vec3 v) { return Pcg01(floatBitsToUint(v)); }\nvec4 Pcg01(vec4 v) { return Pcg01(floatBitsToUint(v)); }\n//BRDF FUNCTIONS\nvec3 Lambert(vec3 baseColor, vec3 N, vec3 L)\n{\n    return baseColor / dot(N, L);\n}\nvec3 FresnelSchlick(float VdotH, vec3 F0) {\n    // return F0 + (1.0 - F0) * pow(1.0 - VdotH, 5.0);\n    return F0 + (1.0 - F0) * exp2((-5.55473 * VdotH - 6.98316) * VdotH);\n}\nvec3 GGX(vec3 N, vec3 V, vec3 L, float roughness, vec3 baseColor)\n{\n    vec3 H = normalize(L + V);\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float VdotH = max(dot(V, H), 0.0);\n    float r = (roughness + 1.0);\n    float k = (r * r) / 8.0;\n    vec3 F = FresnelSchlick(VdotH, baseColor);\n    return F * VdotH / (NdotH * (NdotV * (1.0 - k) + k) * (NdotL * (1.0 - k) + k));\n}\n//SAMPLING FUNCTIONS\nvec3 SampleSphere(vec2 xi)\n{\n\tfloat a = xi.x * PI * 2.0;\n\tfloat z = xi.y * 2.0 - 1.0;\n    float r = sqrt(1.0 - z * z);\n\treturn vec3(r * cos(a), r * sin(a), z);\n}\nvec3 SampleHemiSphere(vec2 xi, vec3 dir)\n{\n\tvec3 v = SampleSphere(xi);\n\treturn dot(dir, v) < 0.0 ? -v : v;\n}\nvec3 ImportanceSampleGGX(vec2 xi, float roughness, vec3 n, vec3 v)\n{\n    float a = roughness * roughness;\n    float phi = 2.0 * PI * xi.x;\n    float cosTheta = sqrt((1.0 - xi.y) / (1.0 + (a * a - 1.0) * xi.y));\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n    vec3 h = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n    vec3 up = abs(n.z) < 0.999 ? vec3(0, 0, 1) : vec3(1, 0, 0);\n    vec3 tangentX = CROSS(up, n);\n    vec3 tangentY = CROSS(n, tangentX);\n    return reflect(v, tangentX * h.x + tangentY * h.y + n * h.z);\n}\nvec3 ImportanceSampleLambert(vec2 xi, vec3 n)\n{\n    float phi = 2.0 * PI * xi.x;\n    float cosTheta = sqrt(1.0f - xi.x);\n    float sinTheta = sqrt(xi.y);\n    vec3 h = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n    vec3 up = abs(n.z) < 0.999 ? vec3(0, 0, 1) : vec3(1, 0, 0);\n    vec3 tangentX = CROSS(up, n);\n    vec3 tangentY = CROSS(n, tangentX);\n    return tangentX * h.x + tangentY * h.y + n * h.z;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float dof = 1.5;\nconst int marchingStep = 70;\nconst float maxDistance = 400.0;\nconst float stairsHeight = 10.5;\nconst float stairsWidth = 11.0;\nconst float stairsTilingSize = 150.0;\nconst int bounceLimit = 2;\nconst int iterMax = 2;\nconst float wallWidth = 0.48;\n\nconst int ballNum = 15;\nconst float ballRadius = 5.0;\nconst float deltaTime = 0.05;\nconst float gravity = 1.0;\nconst float attraction = 10.0;\nconst float reflection = 10.0;\nconst float friction = -20.0;\nconst float randomize = 1.0;\nconst vec3 ballPosMax = vec3(200, 150, 400);\nconst vec3 ballPosMin = vec3(-200, -150, 75);\nconst vec3 ballVelMin = vec3(-100, -100, -100);\nconst vec3 ballVelMax = vec3(100, 100, 100);\nvec3 ballPos[ballNum];\nvec3 ballVel[ballNum];\n\nvec3 cameraPos, cameraDir, cameraUp;\n\nconst float bpm = 84.0;\nfloat elapsedTime;\nfloat beatTime;\nfloat sbeatTime;\nconst int phaseNum = 15;\nconst int phaseBPM[phaseNum + 1] =  int[](0, 8, 16, 20, 24, 32, 36, 40, 48, 64, 72, 80, 96, 112, 128, 144);\nfloat phasePeriod[phaseNum + 1];\nfloat phaseFrag[phaseNum];\nfloat phaseTime = 0.0;\n\nvoid CalcBeatTime()\n{\n    float scaledTime = elapsedTime * bpm / 60.0;\n    beatTime = floor(scaledTime);\n    sbeatTime = fract(scaledTime);\n    sbeatTime = beatTime + pow(sbeatTime, 20.0);\n}\n\nvoid CalcPhase()\n{\n    phaseTime = 0.0;\n    for(int i = 0; i < phaseNum; i++){\n        phasePeriod[i + 1] = float(phaseBPM[i + 1]) / bpm * 60.0;\n        phaseFrag[i] = step(phasePeriod[i], elapsedTime) * step(elapsedTime, phasePeriod[i + 1]);\n        phaseTime += phaseFrag[i] * (elapsedTime - phasePeriod[i]);\n    }\n}\n\nvoid CalcCameraParams(){\n    if(phaseFrag[10] < 0.5) cameraUp = vec3(0.0, 1.0, 0.0);\n    if(phaseFrag[10] > 0.5) cameraUp = vec3(0.0, cos(-phaseTime * 0.1 + PI * 0.25), sin(-phaseTime * 0.1 + PI * 0.25));\n\n    if(phaseFrag[0] > 0.5) cameraDir = vec3(0.0, 0.0, 1.0);\n    if(phaseFrag[1] > 0.5) cameraDir = vec3(cos(phaseTime * 0.1), 0.0, sin(phaseTime * 0.1));\n    if(phaseFrag[2] > 0.5) cameraDir = vec3(cos(phaseTime * 0.1 + PI * 0.75), 0.0, sin(phaseTime * 0.1 + PI * 0.75));\n    if(phaseFrag[3] > 0.5) cameraDir = vec3(cos(-phaseTime * 0.07 + PI), sin(-phaseTime * 0.08 + PI), sin(-phaseTime * 0.07 + PI));\n    if(phaseFrag[4] > 0.5) cameraDir = vec3(-1.0, 0.2, 0.8);\n    if(phaseFrag[5] > 0.5) cameraDir = vec3(-1.0, 0.0, 1.0);\n    if(phaseFrag[6] > 0.5) cameraDir = vec3(-1.5, sin(-phaseTime * 0.08 + PI), 1.0);\n    if(phaseFrag[7] > 0.5) cameraDir = vec3(1.0, sin(-phaseTime * 0.08 + PI), 1.0);\n    if(phaseFrag[8] > 0.5) cameraDir = vec3(0.0, 0.0, 1.0);\n    if(phaseFrag[9] > 0.5) cameraDir = vec3(cos(phaseTime * 0.2 + PI * 0.25), 0.0, sin(phaseTime * 0.2 + PI * 0.25));\n    if(phaseFrag[10] > 0.5) cameraDir = vec3(0.0, cos(-phaseTime * 0.1 + PI * 0.6), sin(-phaseTime * 0.1 + PI * 0.6));\n    if(phaseFrag[11] > 0.5) cameraDir = vec3(0.0, 0.0, 1.0);\n    if(phaseFrag[12] > 0.5) cameraDir = vec3(cos(-phaseTime * 0.1 + PI * 0.25), 0.0, sin(-phaseTime * 0.1 + PI * 0.25));\n    if(phaseFrag[13] > 0.5) cameraDir = vec3(vec3(cos(phaseTime * 0.1 + PI * 0.5), -sin(phaseTime * 0.1 + PI * 0.5), sin(phaseTime * 0.1 + PI * 0.5)));\n    if(phaseFrag[14] > 0.5) cameraDir = vec3(cos(phaseTime * 0.1 + PI * 1.5), -0.5, sin(phaseTime * 0.1 + PI * 1.5));\n\n    if(phaseFrag[0] > 0.5) cameraPos = (vec3(0.0, -20.0, 15.0) + cameraDir * phaseTime * 0.8);\n    if(phaseFrag[1] > 0.5) cameraPos = (vec3(0.0, -20.0, 15.0));\n    if(phaseFrag[2] > 0.5) cameraPos = (vec3(0.0, -20.0, 15.0));\n    if(phaseFrag[3] > 0.5) cameraPos = (vec3(0.0, -20.0, 15.0));\n    if(phaseFrag[4] > 0.5) cameraPos = (vec3(4.0, -62.0, 1.0));\n    if(phaseFrag[5] > 0.5) cameraPos = (vec3(0.0, -50.0 + phaseTime * 1.0, -15.0 + phaseTime * 1.0));\n    if(phaseFrag[6] > 0.5) cameraPos = (vec3(4.0, -40.0, 1.0));\n    if(phaseFrag[7] > 0.5) cameraPos = (vec3(2.0, -30.0, 1.0));\n    if(phaseFrag[8] > 0.5) cameraPos = (vec3(0.0, -10.0 + phaseTime * 1.0, 25.0 + phaseTime * 1.0));\n    if(phaseFrag[9] > 0.5) cameraPos = (vec3(0.0, 20.0, 55.0));\n    if(phaseFrag[10] > 0.5) cameraPos = (vec3(0.0, 20.0, 55.0));\n    if(phaseFrag[11] > 0.5) cameraPos = (vec3(0.0, 20.0, 55.0 + phaseTime * 1.5));\n    if(phaseFrag[12] > 0.5) cameraPos = (vec3(0.0, 15.0, 225.0) - cameraDir * 50.0);\n    if(phaseFrag[13] > 0.5) cameraPos = (vec3(0.0, 15.0, 225.0)  - cameraDir * 80.0);\n    if(phaseFrag[14] > 0.5) cameraPos = (vec3(0.0, 25.0, 75.0) - cameraDir * 130.0);\n}\n\nfloat sdTruchetStairs(vec3 p, float s, float t)\n{\n    float hs = s * 0.5;\n    vec3 p1 = mix(p - hs * IIO, p + hs * JOJ, t);\n    vec3 p2 = mix(p.zyx * JII + hs * IOJ, p.yzx + hs * JIO, t);\n    vec3 p3 = mix(p.yxz * JII + hs * IIO, p.zyx * JII + hs * IJO, t);\n    float d1 = sdStairs(p1 - OII * sbeatTime * 3.0 * step(phasePeriod[8], elapsedTime), stairsHeight, stairsWidth);\n    float d2 = sdStairs(p2 - OII * sbeatTime * 3.0 * step(phasePeriod[8], elapsedTime), stairsHeight, stairsWidth);\n    float d3 = sdStairs(p3 - OII * sbeatTime * 3.0 * step(phasePeriod[8], elapsedTime), stairsHeight, stairsWidth);\n    return min(min(d1, d2), d3);\n}\n\nfloat sdTruchetTiledStairs(vec3 p, float s){\n    float hs = s * 0.5;\n    vec3 pf = MOD(p, s);\n    vec3 pi = p - pf;\n    float s1 = Pcg01(pi + vec3(0, 38, 0)).x;\n    float s2 = Pcg01(pi + vec3(hs, 0, 0)).x;\n    pf.xz = s1 < 0.25 ? (pf - hs).zx * JI + hs:\n            s1 < 0.5 ? (pf - hs).xz * JJ + hs:\n            s1 < 0.75 ? (pf - hs).zx * IJ + hs:\n            pf.xz;\n    return sdTruchetStairs(pf, s, step(s2, 0.5));\n}\n\n#define STAIRS_MAP(p) sdTruchetTiledStairs(p - vec3(stairsTilingSize * 0.5, stairsTilingSize * 0.5, stairsTilingSize * 0.5), stairsTilingSize)\nvec3 GetStairsGrad(vec3 p)\n{\n    const float e = EPS;\n    const vec2 k = vec2(1, -1);\n    return k.xyy * STAIRS_MAP(p + k.xyy * e) +\n            k.yyx * STAIRS_MAP(p + k.yyx * e) +\n            k.yxy * STAIRS_MAP(p + k.yxy * e) +\n            k.xxx * STAIRS_MAP(p + k.xxx * e);\n}\n\nSurface WallMap(vec3 p)\n{\n    p.y += (phaseTime * 10.0 * Pcg01(int(p.z))) * phaseFrag[14];\n\n    ivec3 seed = ivec3(0.0, p.y, p.z);\n    vec3 hash = Pcg01(seed);\n\n    vec3 p1 = vec3(p.x, fract(p.y) - 0.5, fract(p.z) - 0.5);\n\n    float dx =\n        SATURATE(-(abs((floor(-p.y) + floor(p.z)) * 0.1 + hash.x * 0.4 - 6.2) - 1.0)) * pow(abs(sin(phaseTime / phasePeriod[1] * 1.0 * PI)), 4.0) * phaseFrag[0] +\n        SATURATE(-(abs((floor(-p.y) + floor(p.z)) * 0.1 + hash.x * 0.4 - 7.5 + phaseTime) - 1.0)) * phaseFrag[1] +\n        SATURATE(-(abs((floor(-p.y) + floor(p.z)) * 0.05 + hash.x * 0.4 - 10.0 + phaseTime * 1.6) - 1.0)) * phaseFrag[1] +\n        SATURATE(-(abs((floor(-p.y) + floor(p.z)) * 0.1 + hash.x * 1.5 - 7.5 + phaseTime) - 1.0)) * phaseFrag[2] +\n        SATURATE(-(abs((floor(-p.y) + floor(p.z)) * 0.1 + hash.x * 1.5 - 5.0 + phaseTime) - 1.0)) * phaseFrag[3] +\n        SATURATE(abs(sin(length(floor(vec3(0.0, p.y + 60.0, p.z))) * 0.2 + hash.x * 0.6 - phaseTime * 1.5) * 1.5) - 0.5) * phaseFrag[4] +\n        step(Pcg01(ivec4(vec4(p.x, p.y, floor(p.z) * 0.3 * Pcg01(int(sbeatTime)), sbeatTime * 10.0))).x, 0.3) * (phaseFrag[5] + phaseFrag[6] + phaseFrag[7]) +\n        mix(\n            step(Pcg01(ivec4(vec4(p.x, p.y, floor(p.z) * 0.3 * Pcg01(int(sbeatTime)), sbeatTime * 10.0))).x, 0.3),\n            SATURATE(sin(sbeatTime * 2.0 + (hash.x + hash.y) * PI) - 0.3),\n            SATURATE(phaseTime / phasePeriod[9] * 1.3)\n        ) * phaseFrag[8] +\n        SATURATE(sin(sbeatTime * 2.0 + (hash.x + hash.y) * PI) - 0.3) * (phaseFrag[9] + phaseFrag[10] + phaseFrag[11]) +\n        3.0 * (phaseFrag[12] + phaseFrag[13] + phaseFrag[14])\n    ;\n\n    float d = dx * wallWidth * 2.0;\n    vec3 delta = IOO * (d - (stairsWidth + wallWidth));\n    vec3 bSize = III * wallWidth * 0.8;\n    vec3 pSizeV = bSize * vec3(1.0, 0.15, 1.0);\n    vec3 pSizeH = bSize * vec3(1.0, 1.0, 0.15);\n\n    float sdWall1 = sdBox(p1 - delta, wallWidth * III);\n    sdWall1 = max(sdWall1,\n        -mix(\n            min(sdBox(p1 - wallWidth * IOO - delta, pSizeV), sdBox(p1 - wallWidth * IOO - delta, pSizeH)),\n            sdBox(p1 - wallWidth * IOO - delta, bSize), 1.0 - SATURATE(dx)));\n    sdWall1 = max(sdWall1, sdBox(p, stairsTilingSize * 0.5 * III));\n\n    float sdWall2 = sdBox(p1 + delta, wallWidth * III);\n    sdWall2 = max(sdWall2,\n        -mix(\n            min(sdBox(p1 + wallWidth * IOO + delta, pSizeV), sdBox(p1 + wallWidth * IOO + delta, pSizeH)),\n            sdBox(p1 + wallWidth * IOO + delta, bSize), 1.0 - SATURATE(dx)));\n    sdWall2 = max(sdWall2, sdBox(p, stairsTilingSize * 0.5 * III));\n\n    Surface wall1 = Surface(2, 0, sdWall1);\n    Surface wall2 = Surface(2, 1, sdWall2);\n\n    return minSurface(wall1, wall2);\n}\n\nvoid LoadBallParams(vec2 iResolution)\n{\n    for(int i = 0; i < ballNum; i++)\n    {\n        vec2 uv1 = (vec2(i, 0) + vec2(0.5, 0.5)) / iResolution;\n        vec2 uv2 = (vec2(i, 1) + vec2(0.5, 0.5)) / iResolution;\n        vec3 p = texture(iChannel0, uv1).xyz;\n        vec3 v = texture(iChannel0, uv2).xyz;\n        ballPos[i] = p * (ballPosMax - ballPosMin) + ballPosMin;\n        ballVel[i] = v * (ballVelMax - ballVelMin) + ballVelMin;\n    }\n}\n\nvoid SaveBallParams(ivec2 fragCoord, inout vec4 col)\n{\n    for(int i = 0; i < ballNum; i++)\n    {\n        vec3 vel = ballVel[i];\n        vec3 pos = ballPos[i];\n\n        vec3 rand = Pcg01(vec4(pos.xz, i, elapsedTime)).xyz * 2.0 - 1.0;\n        float d = STAIRS_MAP(pos);\n        vec3 g = GetStairsGrad(pos);\n        vec3 norm = length(g) < 0.001 ? OIO : normalize(g);\n        vec3 up = abs(norm.z) < 0.999 ? OOI : IOO;\n        vec3 bitangent = CROSS(up, norm);\n        vec3 tangent = CROSS(norm, bitangent);\n        vel = d < ballRadius ?\n            reflection * norm - friction * tangent + randomize * rand :\n            vel + (-OIO * gravity - norm * attraction) * deltaTime;\n\n        pos += vel * deltaTime;\n        if(elapsedTime < phasePeriod[11]||\n            pos.x < ballPosMin.x || pos.x > ballPosMax.x ||\n            pos.y < ballPosMin.y || pos.y > ballPosMax.y ||\n            pos.z < ballPosMin.z || pos.z > ballPosMax.z){\n            pos = mix(ballPosMin, ballPosMax, rand * 0.2 + vec3(0.4, 0.6, 0.5));\n            vel = OOO;\n        }\n\n        vel = SATURATE((vel - ballVelMin) / (ballVelMax - ballVelMin));\n        pos = SATURATE((pos - ballPosMin) / (ballPosMax - ballPosMin));\n\n        if(fragCoord.x == i)\n        {\n                 if(fragCoord.y == 0) { col = vec4(pos, 0.0); }\n            else if(fragCoord.y == 1) { col = vec4(vel, 0.0); }\n        }\n    }\n}\n\nSurface Map(vec3 p)\n{\n    float sdStairs = STAIRS_MAP(p);\n    Surface s = Surface(0, 0, sdStairs);\n\n    vec3 ballPosCenter = (ballPosMax + ballPosMin) * 0.5;\n    vec3 ballArea = ballPosMax - ballPosMin;\n\n    s = minSurface(s, WallMap(p));\n\n    vec3 p1 = p - vec3(0.0, 19.0, 75.0);\n    p1.x -= 4.0;\n    p1.xz = rotate2d(mix(0.0, PI * 0.75, SATURATE((elapsedTime - phasePeriod[11] - 3.0) * 0.15))) * p1.xz;\n    p1.x += 4.0;\n    Surface door = Surface(3, 0, sdBox(p1, vec3(4.0, 9.0, wallWidth * 0.5)));\n    s = minSurface(s, door);\n\n    Surface doorWall = Surface(4, 0, max(\n        sdBox(p - vec3(0.0, 40.0, stairsTilingSize * 0.5), vec3(stairsWidth * 1.2, 30.0, wallWidth)),\n        -sdBox(p - vec3(0.0, 19.0, 75.0), vec3(4.0, 9.0, wallWidth * 1.1)))\n    );\n    s = minSurface(s, doorWall);\n\n    Surface monitor = Surface(1, 0, sdBox(p - vec3(0.0, 32.0, 73.0), vec3(5.333, 3.0, wallWidth * 0.5)));\n    s = minSurface(s, monitor);\n\n    Surface room = Surface(5, 0, max(\n        sdBox(p - ballPosCenter, ballArea * 0.5),\n        -sdBox(p - ballPosCenter + vec3(0.0, 0.0, 20.0), ballArea * 0.5 - vec3(5.0, 5.0, 5.0)))\n    );\n    s = minSurface(s, room);\n\n    for(int i = 0; i < ballNum; i++){\n        float sd = sdSphere(p - ballPos[i], ballRadius);\n        Surface ball = Surface(6, i, sd);\n        s = minSurface(s, ball);\n    }\n\n    return s;\n}\n\n#define LIMIT_MARCHING_DISTANCE(D,RD,RP) mix(D, min(MIN3(((1.0 * step(0.0, RD) - MOD(RP, 1.0)) / RD)) + EPS, D), \\\nstep(RP.y, stairsTilingSize * 0.5) * step(-stairsTilingSize * 0.5, RP.y) * step(RP.z, stairsTilingSize * 0.5) * step(-stairsTilingSize * 0.5, RP.z) * \\\n(step(RP.x, -stairsWidth - wallWidth + wallWidth * 8.0) * step(-stairsWidth - wallWidth - wallWidth * 8.0, RP.x) + step(RP.x, stairsWidth + wallWidth + wallWidth * 8.0) * step(stairsWidth + wallWidth - wallWidth * 8.0, RP.x))\\\n)\n#define MAP(P) Map(P)\n\nbool RayMarching(vec3 ro, vec3 rd, int stepCount, float maxDistance, out vec3 rp, out Surface s)\n{\n    rp = ro;\n    float rl = 0.0;\n    for (int i = 0; i < stepCount; i++)\n    {\n        s = MAP(rp);\n        float d = s.distance;\n        if (abs(d) < EPS){ return true; }\n        if (rl > maxDistance){ break; }\n        d = LIMIT_MARCHING_DISTANCE(d, rd, rp);\n        rl += d;\n        rp = ro + rd * rl;\n        if(elapsedTime < -1.0) break;\n    }\n    return false;\n}\n\nvec3 GetGrad(vec3 p)\n{\n    const float e = EPS;\n    const vec2 k = vec2(1, -1);\n    return k.xyy * MAP(p + k.xyy * e).distance +\n           k.yyx * MAP(p + k.yyx * e).distance +\n           k.yxy * MAP(p + k.yxy * e).distance +\n           k.xxx * MAP(p + k.xxx * e).distance;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    return normalize(GetGrad(p));\n}\n\nMaterial GetMaterial(Surface s, vec3 p)\n{\n    Material m = Material(III, 0.0, OOO);\n\n    vec3 defaultColor = mix(\n        mix(vec3(0.7, 0.8, 1.0), vec3(0.6, 0.05, 0.1), SATURATE(elapsedTime - phasePeriod[9] - 3.0)),\n        vec3(0.7, 0.8, 1.0), SATURATE(elapsedTime - phasePeriod[10] - 7.0));\n\n    if(s.surfaceId == 0) //Stairs\n    {\n        ivec3 seed = ivec3(p.x, p.y, p.z);\n        vec3 hash = Pcg01(seed);\n\n        m.baseColor = defaultColor;\n        m.roughness = mix(0.01, 0.25, hash.x);\n        m.emission = OOO;\n        return m;\n    }\n    else if(s.surfaceId == 1) //Monitor\n    {\n        float mask = step(sin(p.x * 2.0 + sbeatTime * 3.0 - p.y * 2.0), 0.0);\n\n        int seed = int((p.x * 2.0 + sbeatTime * 3.0 - p.y * 2.0) / PI);\n        float hash = Pcg01(seed);\n\n        vec3 color =\n        mix(vec3(1.0, 0.7, 0.8),\n        mix(vec3(0.7, 0.8, 1.0),\n        vec3(0.7, 1.0, 0.8),\n        step(hash, 0.33)), step(hash, 0.66));\n\n        color = mix(defaultColor, color, SATURATE(elapsedTime - phasePeriod[10] - 7.0));\n\n        m.baseColor = OOO;\n        m.roughness = 1.0;\n        m.emission = mask * color;\n        return m;\n    }\n    else if(s.surfaceId == 2) //Wall\n    {\n        float mask = s.objectId == 0 ? SATURATE(p.x + stairsWidth) : SATURATE(- p.x + stairsWidth);\n        mask *= 0.6;\n\n        ivec2 seed = ivec2(p.y, p.z);\n        vec2 hash = Pcg01(seed);\n\n        vec3 color =\n        mix(vec3(1.0, 0.7, 0.8),\n        mix(vec3(0.7, 0.8, 1.0),\n        vec3(0.7, 1.0, 0.8),\n        step(hash.x, 0.33)), step(hash.x, 0.66));\n\n        color = mix(defaultColor, color, SATURATE(elapsedTime - phasePeriod[10] - 7.0));\n\n        m.baseColor = color;\n        m.roughness = 0.4;\n        m.emission = mix(vec3(0.0, 0.0, 0.0), color, mask);\n        return m;\n    }\n    else if(s.surfaceId == 3) //door\n    {\n        m.baseColor = III;\n        m.roughness = 0.01;\n        m.emission = OOO;\n        return m;\n    }\n    else if(s.surfaceId == 4) //door wall\n    {\n        ivec2 seed = ivec2(p.x, p.y);\n        vec2 hash = Pcg01(seed);\n        m.baseColor = III;\n        m.roughness = mix(0.02, 0.98, hash.x * hash.y);\n        m.emission = OOO;\n        return m;\n    }\n    else if(s.surfaceId == 5) //room\n    {\n        ivec3 seed = ivec3(vec3(p.x, p.y, p.z) * 0.1);\n        seed.x += int(sbeatTime * 30.0);\n        seed.y += int(sbeatTime * 30.0);\n        seed.z += int(sbeatTime * 30.0);\n        vec3 hash = Pcg01(seed);\n\n        float mask = step(sin(p.x * 0.1 + elapsedTime * 3.0 - p.y * 0.1), 0.0);\n\n        m.baseColor = III;\n        m.roughness = mix(0.03, 0.98, hash.x);\n        m.emission = mix(0.1, 0.5, mask) * defaultColor;\n        return m;\n    }\n    else if(s.surfaceId == 6) //ball\n    {\n        vec3 hash = Pcg01(ivec3(s.objectId, 0, 0));\n        m.baseColor = hash;\n        m.roughness = 0.03;\n        m.emission = hash * 0.5;\n        return m;\n    }\n\n    return m;\n}\n\nvec3 SampleRadiance(vec3 ro0, vec3 rd0, vec3 color)\n{\n    vec3 sum = OOO;\n    Surface s;\n    bool hit;\n    Material m;\n    vec3 n;\n    vec2 rand;\n    vec3 brdfOverPdf;\n    vec3 v;\n    vec3 hitPos;\n    for(int iter = 0; iter < iterMax; iter++)\n    {\n        vec3 ro = ro0;\n        vec3 rd = rd0;\n        vec3 acc = OOO;\n        vec3 weight = III;\n        for (int bounce = 0; bounce <= bounceLimit; bounce++)\n        {\n            hit = RayMarching(ro, rd, marchingStep, maxDistance, hitPos, s);\n            if(!hit) {\n                acc += color * weight;\n                break;\n            }\n            m = GetMaterial(s, hitPos);\n            n = GetNormal(hitPos);\n            rand = Pcg01(vec4(hitPos, float(iter * bounceLimit + bounce) + elapsedTime)).xy;\n            ro = hitPos + n * EPS * 2.0;\n\n            if(m.roughness > 0.99)\n            {\n                rd = ImportanceSampleLambert(rand, n);\n                brdfOverPdf = Lambert(m.baseColor, n, rd);\n            }\n            else\n            {\n                v = -rd;\n                rd = ImportanceSampleGGX(rand, m.roughness, n, rd);\n                if (dot(rd, n) < 0.0 ) { break; }\n                brdfOverPdf = GGX(n, v, rd, m.roughness, m.baseColor);\n            }\n            acc += m.emission * weight;\n            weight *= brdfOverPdf * max(dot(rd, n), 0.0);\n            if (dot(weight, weight) < EPS) { break; }\n        }\n        sum += acc;\n    }\n    return sum / float(iterMax);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 r = iResolution.xy;\n    elapsedTime = mod(iTime, float(phaseBPM[15]) / bpm * 60.0);\n    CalcBeatTime();\n    CalcPhase();\n    CalcCameraParams();\n    LoadBallParams(r);\n    vec4 col = vec4(0.0, 0.0, 0.0, 1.0);\n    vec3 p = vec3((fragCoord.xy * 2.0 - r) / min(r.x, r.y), 0.0);\n    cameraDir = normalize(cameraDir);\n    cameraUp = normalize(cameraUp);\n    vec3 cameraRight = CROSS(cameraUp, cameraDir);\n    cameraUp = CROSS(cameraDir, cameraRight);\n    vec3 ray = normalize(cameraRight * p.x + cameraUp * p.y + cameraDir * dof);\n    vec3 ro = cameraPos;\n    vec3 rd = ray;\n    col.xyz = SampleRadiance(ro, rd, col.xyz);\n    SaveBallParams(ivec2(fragCoord.xy), col);\n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"}]}