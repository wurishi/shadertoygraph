{"ver":"0.1","info":{"id":"MtsBR8","date":"1511032082","viewed":1171,"name":"Continuous LOD Marching Cubes","username":"huwb","description":"Idea: continuous LOD marching squares by smoothly varying sample points, seems to work pretty well. LMB to add a blob under the cursor for fun, and to move the detail center.","likes":22,"published":1,"flags":0,"usePreview":1,"tags":["lod","sampling","marchingcubes","cdlod"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Uses similar ideas to continuous level of detail clipmaps: https://www.shadertoy.com/view/MstGRn .\n// Emulates a basic implementation of 2D marching cubes (without any fanciness with Hermite data).\n// \n// Varies sample points smoothly to achieve continuous LOD. Just moving points seems to be enough to\n// get pretty good results. There are some artifacts that need polishing and could use more work.\n//\n// I think this could work well in full 3D with generated geometry, and is an interesting direction\n// for future work.\n//\n// Some relevant links:\n//  http://catlikecoding.com/unity/tutorials/marching-squares-3/\n//  https://github.com/Scrawk/Marching-Cubes-On-The-GPU\n//\n// Huw Bowles 2017\n\n#define VEL 20.\n\n// the function that is being sampled. geometry will be generate along the isoline\n// = 0.5 of this function\nfloat ImplicitFunction( vec2 x, float sep, float lod )\n{\n    vec2 y = x;\n    y.y -= iTime*VEL;\n\n    // hacky form of prefiltering - blend out stuff that is too high res for the lod\n    float result = 0.;\n    result += (texture( iChannel0, y/32000. ).x-0.5) * .7;\n    result += (texture( iChannel0, y/16000. ).x-0.5) * .5;\n    result += smoothstep( 64., 32., sep*(1.+lod) ) * (texture( iChannel0, y/ 8000. ).x-0.5) * .25;\n    result += smoothstep( 32., 16., sep*(1.+lod) ) * (texture( iChannel0, y/ 4000. ).x-0.5) * .125;\n    result += smoothstep( 8., 4., sep*(1.+lod) ) * (texture( iChannel0, y/ 1000. ).x-0.5) * .0625;\n    \n    result += .7;\n    result *= max(0., 1. - x.y/iResolution.y);\n    \n    if( iMouse.z > 0. )\n    {\n        float r = length(iMouse.xy-x);\n        //dens += 16.*cos(.05*r)/r;\n        result += 1.-smoothstep(0., 40., r);\n    }\n    \n    return result;\n}\n\nstruct Edge\n{\n    bool valid;\n    vec2 s; // start\n    vec2 e; // end\n};\nstruct EdgePair\n{\n    Edge e0;\n    Edge e1;\n};\n#if 0\n;\n#endif\n\nEdgePair g_EdgeTable[8];\n\nvoid InitMarchingCubeLUT()\n{\n    // the look up table copied from here:\n    // https://en.wikipedia.org/wiki/Marching_squares\n    \n    // no edges\n    g_EdgeTable[0].e0.valid = false;\n    g_EdgeTable[0].e1.valid = false;\n    \n    // one edge\n    g_EdgeTable[1].e0.valid = true;\n    g_EdgeTable[1].e0.s = vec2(0., .5);\n    g_EdgeTable[1].e0.e = vec2(.5, 0.);\n    g_EdgeTable[1].e1.valid = false;\n    \n    g_EdgeTable[2].e0.valid = true;\n    g_EdgeTable[2].e0.s = vec2(1., .5);\n    g_EdgeTable[2].e0.e = vec2(.5, 0.);\n    g_EdgeTable[2].e1.valid = false;\n    \n    g_EdgeTable[3].e0.valid = true;\n    g_EdgeTable[3].e0.s = vec2(0., .5);\n    g_EdgeTable[3].e0.e = vec2(1., .5);\n    g_EdgeTable[3].e1.valid = false;\n\n    g_EdgeTable[4].e0.valid = true;\n    g_EdgeTable[4].e0.s = vec2(.5, 1.);\n    g_EdgeTable[4].e0.e = vec2(1., .5);\n    g_EdgeTable[4].e1.valid = false;\n\n    // two edges\n    g_EdgeTable[5].e0.valid = true;\n    g_EdgeTable[5].e1.valid = true;\n    g_EdgeTable[5].e0.s = vec2(0., .5);\n    g_EdgeTable[5].e0.e = vec2(.5, 1.);\n    g_EdgeTable[5].e1.s = vec2(.5, 0.);\n    g_EdgeTable[5].e1.e = vec2(1., .5);\n    \n    g_EdgeTable[6].e0.valid = true;\n    g_EdgeTable[6].e0.s = vec2(.5, 0.);\n    g_EdgeTable[6].e0.e = vec2(.5, 1.);\n    g_EdgeTable[6].e1.valid = false;\n\n    g_EdgeTable[7].e0.valid = true;\n    g_EdgeTable[7].e0.s = vec2(.0, .5);\n    g_EdgeTable[7].e0.e = vec2(.5, 1.);\n    g_EdgeTable[7].e1.valid = false;\n}\n\nEdgePair LookupEdges(int mask)\n{\n    // symmetry! https://en.wikipedia.org/wiki/Marching_squares\n    if( mask > 7 ) mask = 15 - mask;\n    \n    return g_EdgeTable[mask];\n}\n\n// adjusts the vertex position to approximate the isosurface, given values\n// sampled at cube corners\nvec2 MakeVertexLerpData( vec2 p, float v00, float v01, float v10, float v11 )\n{\n    vec2 result = p;\n    \n\tif\t\t( p.y == 0. ) result.x = p.x * 2. * (0.5-v00) / (v10-v00);\n\telse if ( p.y == 1. ) result.x = p.x * 2. * (0.5-v01) / (v11-v01);\n\tif\t\t( p.x == 0. ) result.y = p.y * 2. * (0.5-v00) / (v01-v00);\n\telse if ( p.x == 1. ) result.y = p.y * 2. * (0.5-v10) / (v11-v10);\n    \n    // could do a second sample at new position and do a secant method step,\n    // but this may be too expensive in practive.\n        \n    return result;\n}\n\n// compute the 1 or 2 edges for this cube\nEdgePair GenerateEdges( vec2 x00, vec2 cubeSize, float sep, float lod )\n{\n    vec2 x10 = x00 + vec2(cubeSize.x,0.);\n    vec2 x01 = x00 + vec2(0.,cubeSize.y);\n    vec2 x11 = x00 + cubeSize;\n    \n    // minus 0.5 baked into the uses of vXY\n    float v00 = ImplicitFunction(x00, sep, lod);// - 0.5;\n    float v01 = ImplicitFunction(x01, sep, lod);// - 0.5;\n    float v10 = ImplicitFunction(x10, sep, lod);// - 0.5;\n    float v11 = ImplicitFunction(x11, sep, lod);// - 0.5;\n    \n    int mask = 0;\n    \n    if( v00 < 0.5 ) mask += 1;\n    if( v10 < 0.5 ) mask += 2;\n    if( v11 < 0.5 ) mask += 4;\n    if( v01 < 0.5 ) mask += 8;\n\n    EdgePair e = LookupEdges(mask);\n    \n    if( e.e0.valid )\n    {\n        e.e0.s = MakeVertexLerpData( e.e0.s, v00, v01, v10, v11 );\n        e.e0.e = MakeVertexLerpData( e.e0.e, v00, v01, v10, v11 );\n    }\n    if( e.e1.valid )\n    {\n        e.e1.s = MakeVertexLerpData( e.e1.s, v00, v01, v10, v11 );\n        e.e1.e = MakeVertexLerpData( e.e1.e, v00, v01, v10, v11 );\n    }\n    \n    return e;\n}\n\n// compute grid resolution, and interpolation factor between lods.\n// the resolution could be seeded directly by geometry.\nvoid ComputeSepLod(in vec2 x, in vec2 detailCenter, out float sep, out float lod )\n{\n    // detail driven by taxicab norm, this gives square isolines that can be a good\n    // fit to rectilinear world space textures. we use this in our Crest ocean renderer\n    // see slides: https://github.com/huwb/crest-oceanrender\n    float taxi = max(abs(x.x-detailCenter.x),abs(x.y-detailCenter.y));\n    float sepLin = taxi / 20.;\n    float sepLog = log2(sepLin);\n    float sepLogMin = 2.; // min spacing: 4\n    sepLog = max( sepLog, sepLogMin );\n    float sepLogFloor = floor(sepLog);\n    \n    sep = exp2( sepLogFloor );\n    lod = sepLog - sepLogFloor;\n}\n\n// compute the marching cube around the current pixel. ordinarily the cube\n// geometry would be submitted as vertices to a geometry shader explicitly. there is\n// currently some error in this function, especially visible at low lods.\nvoid ComputeCubeFromPixel(vec2 x, float sep, float lod, out vec2 x00, out vec2 cubeSize)\n{\n    cubeSize = vec2(sep);\n    \n    vec2 xrem = mod(x+vec2(0.,-iTime*VEL*.7-iMouse.y*0.), 2.*cubeSize);\n    x00 = x - xrem;\n    \n    // hackery to emulate smoothly changing cube sizes\n    \n    if( xrem.x < (1. - lod)*cubeSize.x )\n    {\n\t    cubeSize.x *= 1. - lod;\n    }\n    else\n    {\n        x00.x += (1. - lod)*cubeSize.x;\n        cubeSize.x *= 1. + lod;\n    }\n    if( xrem.y < (1. - lod)*cubeSize.y )\n    {\n\t    cubeSize.y *= 1. - lod;\n    }\n    else\n    {\n        x00.y += (1. - lod)*cubeSize.y;\n        cubeSize.y *= 1. + lod;\n    }\n}\n\nfloat Dot(vec2 x, vec2 c);\nfloat Line(vec2 x, vec2 a, vec2 b);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0, 0, 0, 1);\n    \n    InitMarchingCubeLUT();\n    \n    vec2 x = fragCoord;\n    \n    // detail center\n    vec2 detailCenter = vec2(.5-0.5*cos(.4*iTime),0.5) * iResolution.xy;\n    if( iMouse.z > 0. )\n        detailCenter = iMouse.xy;\n    \n    // compute grid resolution, and interpolation factor between lods.\n    float lod, sep;\n    ComputeSepLod( x, detailCenter, sep, lod );\n    \n    // compute the marching cube around the current pixel.\n    vec2 x00, cubeSize;\n\tComputeCubeFromPixel( x, sep, lod, x00, cubeSize);\n    \n    // compute 1 or 2 edges that pass through this cube\n    EdgePair e = GenerateEdges(x00, cubeSize, sep, lod);\n    \n    // draw the lines\n    if( e.e0.valid ) fragColor.xy += Line(x, x00 + e.e0.s * cubeSize, x00 + e.e0.e * cubeSize);\n    if( e.e1.valid ) fragColor.xy += Line(x, x00 + e.e1.s * cubeSize, x00 + e.e1.e * cubeSize);\n    \n    // draw the value at the center of the cube for debug vis\n    fragColor.b += clamp(.5+20.*(ImplicitFunction(x00+.5*cubeSize,max(cubeSize.x,cubeSize.y),0.)-.5),0.,.4);\n    // draw the cube corners for debug vis\n    if(iMouse.z > 0. || true)\n    {\n        float v = 0.;\n        v = max( v, Dot(x00,x) );\n        v = max( v, Dot(x00+cubeSize,x) );\n        v = max( v, Dot(x00+vec2(cubeSize.x,0.),x) );\n        v = max( v, Dot(x00+vec2(0.,cubeSize.y),x) );\n        fragColor += .6*v;\n    }\n    \n    fragColor.rgb += .1;\n}\n\n// Utility functions...\n\n// Return minimum distance between line segment vw and point p\n// HB: This code is not mine, I lost the reference, sorry original author!\nfloat line_d(vec2 p, vec2 v, vec2 w)\n{\n  float l2 = dot(v-w, v-w);  // i.e. |w-v|^2 -  avoid a sqrt\n  if (l2 == 0.0) return distance(p, v);   // v == w case\n  // Consider the line extending the segment, parameterized as v + t (w - v).\n  // We find projection of point p onto the line. \n  // It falls where t = [(p-v) . (w-v)] / |w-v|^2\n  float t = dot(p - v, w - v) / l2;\n  if (t < 0.0) return distance(p, v);       // Beyond the 'v' end of the segment\n  else if (t > 1.0) return distance(p, w);  // Beyond the 'w' end of the segment\n  vec2 projection = v + t * (w - v);  // Projection falls on the segment\n  return distance(p, projection);\n}\n\nfloat Dot(vec2 x, vec2 c)\n{\n    float R = 1.5;\n    return smoothstep(R,0.,length(x-c));\n}\n\nfloat Line(vec2 x, vec2 a, vec2 b)\n{\n    float R = 2.;\n    return smoothstep(R,0.,line_d(x,a,b));\n}\n\n// transition points in opposite x direction\n/*if( xrem.x < (1.+lod)*cubeSize.x )\n{\ncubeSize.x *= 1. + lod;\n}\nelse\n{\nx00.x += (1.+lod)*cubeSize.x;\ncubeSize.x *= 1. - lod;\n}*/\n","name":"Image","description":"","type":"image"}]}