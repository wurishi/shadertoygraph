{"ver":"0.1","info":{"id":"tsXBzX","date":"1588721994","viewed":218,"name":"glsl bug (ANGLE? HLSL?)","username":"16807","description":"This renders a smooth sphere on linux, but creates horizontal artifacts on windows. ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["glslbug"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nstruct maybe_float\n{\n    float value;\n    bool exists;\n};\nstruct maybe_vec2\n{\n    vec2 value;\n    bool exists;\n};\nconst float PI = 3.14159265;\n\n/*\nA0 line reference\nA  line direction, normalized\nB0 sphere origin\nR  sphere radius along each coordinate axis\n*/\nmaybe_vec2 get_distances_along_3d_line_to_sphere(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in float r\n){\n    float t = dot(B0 - A0, A);\n    vec3  At = A0 + A*t - B0;\n    float y2 = r*r - dot(At,At);\n    float dxr = sqrt(max(y2, 1e-20));\n    return maybe_vec2(\n        vec2(t - dxr, t + dxr),\n        y2 > 0.\n    );\n}\n/*\nA0 point position\nB0 sphere origin\nr  radius\n*/\nvec3 get_surface_normal_of_point_near_sphere( in vec3 A0, in vec3 B0 )\n{\n    return normalize( A0-B0 );\n}\n\nmat4 get_rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, 0.0,\n                oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, 0.0,\n                oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c, 0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\nmat4 get_translation_matrix(vec3 offset)\n{\n    return mat4(1,0,0,0,\n                0,1,0,0,\n                0,0,1,0,\n                offset,1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // world\n    float r = 1000.0;      // surface of the world\n    vec3 B0 = vec3(0,0,0);  // center of the world\n    \n    highp vec2 mouse = vec2(float(iMouse.x) / float(iResolution.x), iMouse.y/iResolution.y);\n    mat4  projection_matrix_inverse = (mat4(0.5,0,0,0,\n                                            0,0.3,0,0,\n                                            0,0,0,-50,\n                                            0,0,-1,50));\n    highp float mousey = iMouse.y;\n    lowp vec2 foo = vec2(0,0.6777);\n    bool IS_FIRST_PERSON_POV = false;\n    mat4 view_matrix_inverse = \n            get_rotation_matrix(vec3(1,0,0), PI/2.0+PI*(iTime*.1)) *\n            get_translation_matrix(vec3(0,0,6.0*r)) *\n            mat4(1);\n    \n    float reference_distance = 1.0f;//8000m;\n    \n    vec2  screenspace    = fragCoord/iResolution.xy;\n    vec2  clipspace      = 2.0 * screenspace - 1.0;\n    vec3  view_direction = normalize(view_matrix_inverse * projection_matrix_inverse * vec4(clipspace, 1, 1)).xyz;\n    vec3  view_origin    = view_matrix_inverse[3].xyz * reference_distance;\n\n    // view ray\n    vec3 V0 = view_origin;\n    vec3 V  = view_direction;\n    vec3 Vi = V0;            // point along view ray\n    \n    // light ray\n    // static\n    vec3 L  = normalize(vec3(1,0,0)); \n    \n    maybe_vec2 world_along_view_ray = \n            get_distances_along_3d_line_to_sphere(V0, V, B0, r);\n    \n    if(world_along_view_ray.exists){\n        vec3 Vt = V0+V*(world_along_view_ray.value.x-0.001);\n        vec3 N = get_surface_normal_of_point_near_sphere(Vt, B0);\n        float NL = max(dot(N, L), 0.);\n        fragColor = vec4(NL,NL,NL, 1);\n    }\n}","name":"Image","description":"","type":"image"}]}