{"ver":"0.1","info":{"id":"cscSR4","date":"1679455774","viewed":153,"name":"Elevator","username":"ianertson","description":"Sadly, you cannot look around with the mouse this time.\nHowever, press \"V\" on your keyboard to toggle WASD mode.\nYou'll be able to walk around using WASD.\nFly up with Space, fly down with Shift.","likes":13,"published":1,"flags":48,"usePreview":1,"tags":["3d","raytracing","raymarching","raymarch","sdf","materials","textures","elevator"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#pragma optimize(off)\n#pragma optionNV(fastmath off)\n#pragma optionNV(fastprecision off)\n#pragma optionNV(unroll none)\n\nfloat wnoise(in vec2 uv, in int iter, float dim) {\n    vec2 k = uv*2.0-1.0;\n    vec2 r = vec2(0.0);\n    float f = 1.0;\n    for (int i = ZERO; i < iter; i++) {\n        r += sin( k*f +(float(i)/float(iter))*2.5) / f;\n        k = k * mat2(8.0, 6.28, -8.0, 6.28)*.1 + r*.29;     \n        r += sin( k*f +(float(i)/float(iter))*2.5) / f;\n        k = k * mat2(8.0, 6.28, -8.0, 6.28)*.1 + r*.29;\n    };\n    float n = 1.0-dFdx(length(r)*dim);\n    return clamp(exp(n-1.5)*n, 0.0, 1.0);\n}\n\nvec3 wallPaperTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 hf1 = snoise(uv, 0.0003215, 3.0, 196.0, 6);\n    vec3 hf2 = snoise(uv, 5.5909992, 3.0, 196.0, 6);\n    vec3 col = vec3(0.0);\n    float tile = 2.0;\n    vec2 id = floor(uv*tile);\n    vec2 uuv = uv;\n    uuv.x += id.y/tile/2.;\n    vec2 lv = fract(uuv*tile);\n    vec2 alv = abs(lv*2.0-1.0);\n\n           \n    vec3 c1 = rgb(250, 254, 255);\n    vec3 c2 = rgb(238, 229, 212);\n    vec3 c3 = rgb(226, 197, 158);\n    vec3 c4 = rgb(163, 87, 47);\n\n    vec3 l1 = rgb(174, 144, 111);\n    vec3 l2 = rgb(169, 147, 130);\n    vec3 l3 = rgb(187, 84, 73);\n    vec3 l4 = rgb(64, 44, 25);\n\n    vec3 bg = mix4(c1, c2, c3, c4, hf1);\n    vec3 fg = mix4(l1, l2, l3, l4, hf2);    \n    \n    col += bg;\n           \n           \n    float pat = line2D(alv, vec2(0.5 + ((lv.y*lv.y*lv.y*0.5)), 0.0), vec2(0.0, 0.7), 0.05);\n    pat += line2D(alv, vec2(0.5 + cos(alv.x*2.), -sin(alv.x*6.)), vec2(0.0 + sin((alv.x-alv.y)*2.), 0.7), 0.1);\n  \n    \n    pat = clamp(pat, 0.0, 1.0);\n    col = mix(col, fg, pat); \n    \n    float pat2 = line2D(alv, vec2(0.0, 0.0), vec2(1.0 + lv.y, 0.5+sin(alv.x*6.)*0.5), 0.04);\n    \n    col = mix(col, c3, pat2);\n    \n    m.spec = clamp(pat+pat2, 0.0, 1.0);\n\n    \n    return col;\n}\n\nvec3 brownMarbleTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    \n    vec3 c1 = rgb(61, 41, 36);\n    vec3 c2 = rgb(129, 100, 82);\n    vec3 c3 = rgb(110, 92, 81);\n    vec3 c4 = rgb(80, 51, 35);\n\n    vec3 w1 = rgb(171, 153, 128);\n    vec3 w2 = rgb(247, 209, 186);\n    vec3 w3 = rgb(243, 227, 200);\n    vec3 w4 = rgb(255, 201, 123);\n    \n    vec3 hf1 = snoise(uv, 0.0003215, 0.5, 96.0, 6);\n    vec3 hf2 = snoise(uv, 5.5909992, 0.5, 96.0, 6);\n    vec3 lf1 = snoise(uv, 9.9872314, 0.2, 8.0, 6);\n    vec3 lf2 = snoise(uv, 16.699833, 0.2, 7.0, 6);\n    \n    vec3 hf3 = abs(normalize(reflect(cross(lf2*2.0-1.0, lf1*2.0-1.0), hf1*2.0-1.0)));\n    vec3 hf4 = abs(normalize(reflect(cross(hf3*2.0-1.0, hf2*2.0-1.0), lf2*2.0-1.0)));\n    vec3 grainF = abs(normalize(cross(hf3, hf4)));\n    vec3 col1 = mix4(c1, c2, c3, c4, hf1);\n    vec3 col2 = mix4(c1, c2, c3, c4, hf3);\n    vec3 baseCol = mix(col1, col2, lf2.z);\n    col += baseCol;\n    \n    vec3 sepCol1 = mix4(w1, w2, w3, w4, mix(hf2, lf1, clamp(hf1.y+0.2, 0.0, 1.0)));\n    vec3 sepCol2 = mix4(w1, w2, w3, w4, hf4);\n    vec3 sepCol = mix(sepCol1, sepCol2, hf3.y);\n    sepCol = mix(sepCol, sepCol*sepCol*sepCol, smoothstep(0.4, 0.7, lf2.z));\n        \n    float cracks1 = (1.0-smoothstep(0.0, 0.08, abs(lf1.x-lf1.y)))*hf2.z*lf1.z*lf1.z;\n    cracks1 = clamp((cracks1*cracks1)*16., 0.0, 1.0);\n    col += sepCol2*cracks1*0.5;\n    uv *= 2.0;\n    vec2 id = floor(uv);\n    vec2 lv = fract(uv);\n    vec2 alv = abs(lv*2.0-1.0);\n    vec2 alv2 = abs(fract(uv+vec2(0.03, 0.03))*2.0-1.0);\n    \n    float sep = smoothstep(0.48-(hf3.x*0.09), 0.5, alv2.x-0.5) +\n           smoothstep(0.48-(hf3.y*0.09), 0.5, alv2.y-0.5);\n           \n           \n    float sep2 = smoothstep(0.39, 0.48, alv.x-0.5) +\n           smoothstep(0.39, 0.48, alv.y-0.5);\n    \n    \n    col += sep * sepCol;\n    \n    float grain = grainF.x * grainF.x * (0.5+hf3.y*0.5);\n    grain = grain*grain;\n  \n    col = mix(col, (col*0.5)*col, grain);\n    \n    float pat = clamp(mod(id.x-id.y, 2.0), 0.0, 1.0);\n    \n    col = mix(col, (col+(col*sepCol)), pat);\n    col = mix(col, col*0.3, sep2*max(0.0, 1.0-(sep*0.09)));\n    \n    \n    m.z = clamp(1.0-(sep2 + (cracks1*0.03*lf2.z)), 0.0, 1.0);\n    m.spec = clamp(sep+cracks1+0.06, 0.09, 1.0);\n    \n    return col;\n}\n\nvec3 marbleTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 hf1 = snoiseWarp(uv, 2.244234, 1., 24.0, 4, 0.3);\n    vec3 hf2 = snoiseWarp(uv, 8.727231, 0.3, 20.0, 6, 0.003);\n    vec3 hf3 = snoise(uv, 11.83772244, 0.2, 18.0, 4);\n    \n    vec3 hf4 = snoise(uv, 0.00392123, 0.09, 32.0, 6);\n     \n    vec3 w1 = rgb(247, 247, 247);\n    vec3 w2 = rgb(219, 218, 224);\n    vec3 w3 = rgb(211, 207, 207);\n    vec3 w4 = rgb(217, 207, 195);\n    \n    vec3 bg = mix(mix(mix(w1, w2, hf1.x), w3, hf1.y), w4, hf1.z);\n    col += bg;\n    \n    float edges = max(0.0, 1.0-smoothstep(0.02, 0.1, abs(hf2.x*2.0-1.0)));\n    float edges2 = max(0.0, 1.0-smoothstep(0.02, 0.1, abs(hf3.z*2.0-1.0)));\n    \n    vec3 c1 = rgb(196, 169, 127);\n    vec3 c2 = rgb(247, 178, 191);\n    vec3 c3 = rgb(158, 155, 149);\n    vec3 c4 = rgb(80, 77, 72);\n    \n    float edgeReg = edges2*smoothstep(0.39, 0.8, hf4.x);\n    vec3 pCol = mix(mix(mix(c1, c2, hf3.x), c3, hf3.y), c4, hf3.z);\n    col = mix(col, pCol, edgeReg);\n    col = mix(col, col*col, edges*hf4.z*hf4.y*(0.33+hf1.z));\n    \n    m.spec = clamp((1.0-edgeReg)*hf1.y, 0.0, 1.0);\n    \n    return col;\n}\n\nvec3 plankTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 hf1 = snoise(uv, 0.0321122, 0.33, 128.0, 6);\n    vec3 hf2 = snoise(uv, 1.0928325, 0.5, 128.0, 6);\n    \n    vec3 lf1 = snoise(uv, 4.3092911, 0.1, 4.0, 6);\n    \n    vec3 c1 = rgb(159, 112, 90);\n    vec3 c2 = rgb(204, 131, 74);\n    vec3 c3 = rgb(156, 126, 108);\n    vec3 c4 = rgb(99, 54, 30);\n    vec3 c5 = rgb(230, 192, 141);\n    \n    vec3 col1 = mix(mix(mix(mix(c1, c2, hf1.x), c3, hf1.y), c4, hf1.z), c5, hf2.x*hf2.x);\n    col += col1;\n    \n    float tile = 2.0;\n    vec2 id = floor(uv*tile);\n    vec2 lv = fract(uv*tile);\n    vec2 alv = abs(lv*2.0-1.0);\n    \n    float lines = mod(length(vec2(alv.x/2., alv.y)), 0.4*cos(alv.y*(TAU-(alv.x/2.+hf2.y)))*hf2.z);\n    lines = max(0.002, 1.0-max(0.0, 0.5-lines));\n    \n    col = mix(col, col*col*col, lines);\n    \n    float x = 1.0+fract(uv.x/2.);\n    \n    float w2 = fract(mod((x*tile)*10.*lf1.y, sin((uv.y*tile)*TAU)*2.));\n    col = mix(col, mix(c1, c5, hf1.z), w2*0.6);\n    \n    float t2 = fract(uv.y*tile*2.);\n    float gs = smoothstep(0.5-0.25, 0.5+0.25, abs(t2*2.0-1.0)-0.5);\n    col = mix(col, col*col, gs);\n    \n    m.z = clamp(1.0-((gs*0.1)+(lines*0.5)), 0.0, 1.0);\n    m.spec = clamp(w2*lf1.y, 0.0, 1.0);\n    \n    return col;\n}\n\nvec3 dirtyMetalTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 c1 = rgb(131, 131, 131);\n    vec3 c2 = rgb(172, 173, 176);\n    vec3 c3 = rgb(103, 113, 125);\n    vec3 c4 = rgb(192, 192, 192);\n    \n    vec3 d1 = rgb(87, 78, 76);\n    vec3 d2 = rgb(59, 53, 44);\n    vec3 d3 = rgb(178, 118, 83);\n    vec3 d4 = rgb(176, 80, 70);\n    \n    vec3 warp = snoiseWarp(uv, 0.0288231, 1., 32.0, 6, 0.2);\n    vec3 hf1 = snoise(uv, 2.8981819, 1.0, 100.0, 6);\n    float w = wnoise(uv*12., 6, 1.);\n    vec3 hf2 = abs(normalize(cross(vec3(warp.z*2.0-1.0, hf1.x*2.0-1.0, w*2.0-1.0), hf1-warp)));\n    vec3 lf1 = snoise(uv, 5.54828155, 0.5, 8.0, 6);\n    \n    vec3 col1 = mix(mix(mix(c1, c2, hf1.x), c3, hf1.y), c4, hf1.z);\n    vec3 dirtCol = mix(mix(mix(d1, d2, hf2.x), d3, hf2.y), d4, hf2.z);\n \n    float dirtReg = smoothstep(0.3 + (hf2.x*0.09), 1.0, lf1.y);\n    float wear = smoothstep(0.0+hf2.z, 1.-(lf1.y*0.2), abs(hf2.x*2.0-1.0));\n    wear = wear*lf1.z*warp.y;\n    float bulge = w*warp.x*hf2.y;\n    float scratch = max(0.0, 1.0-smoothstep(0.02, 0.04, abs(lf1.x*2.0-1.0)));\n    scratch = scratch*bulge*lf1.z;\n    \n    col += col1;\n    \n    col = mix(col, dirtCol, dirtReg);\n    col = mix(col, col*col, wear);\n    col = mix(col, col*col, bulge);\n    col = mix(col, dirtCol, scratch);\n    \n    m.rough = clamp((wear+scratch+bulge)*1.9, 0.0, 1.0);\n    m.metallic = clamp(1.0-((wear+bulge)*3.), 0.0, 1.0);\n    m.spec = clamp(1.0-((wear+scratch)*3.), 0.0, 1.0);\n    \n    return col;\n}\n\n\n#define ID_GROUND 0\n#define ID_ELEVATOR 1\n#define ID_ELEVATOR_DOOR 2\n#define ID_ELEVATOR_LIGHT0 3\n#define ID_ELEVATOR_LIGHT1 4\n#define ID_ELEVATOR_CONTROL 5\n#define ID_ROOM 6\n#define ID_ROOM_ELEVATOR_WALL 7\n#define ID_ROOM_FLOOR 8\n\n#define ELEVATOR_MOVES 1\n#define ELEVATOR_WIDTH 1.9\n#define ELEVATOR_HEIGHT 1.9\n#define ELEVATOR_MAX_Y 16.\n#define ELEVATOR_SIZE vec3(ELEVATOR_WIDTH, ELEVATOR_HEIGHT, ELEVATOR_WIDTH)\n#define ELEVATOR_POS vec3(0, 0, 0)\n\n#define ELEVATOR_LIGHT0_POS (ELEVATOR_POS + vec3(0, (ELEVATOR_HEIGHT*2.)-0.12, ELEVATOR_WIDTH))\n#define ELEVATOR_LIGHT1_POS (ELEVATOR_POS + vec3(0, (ELEVATOR_HEIGHT*2.)-0.25, 0))\n\n#define ROOM_WIDTH 8.0\n#define ROOM_HEIGHT ((ELEVATOR_MAX_Y/2.)+ELEVATOR_HEIGHT*1.6)\n#define ROOM_SIZE vec3(ROOM_WIDTH, ROOM_HEIGHT, ROOM_WIDTH)\n\n\nstruct Elevator {\n    Object o;\n    float open;\n};\n\nstruct Scene {\n    Elevator e;\n    vec3 ro;\n    vec3 lookp;\n};\n\n#define ANIMATION_TIME (T*0.7)\n#define ANIMATION_TRANS_TIME 0.9\n#define ANIMATION_NUM_FRAMES 19.0\n\nScene getScene(vec3 ro, vec3 lookp) {    \n    ro = vec3(0, 0.0, 7);\n    lookp = vec3(0, 0, -5);\n    vec3 olookp = lookp;\n    vec3 oro = ro;\n    Scene scene = Scene(Elevator(NEW_OBJECT, 0.0), ro, lookp);\n\n    float yMargin = 0.9;\n\n    float time = ANIMATION_TIME;\n    float transTime = ANIMATION_TRANS_TIME;\n    float frame = 1.0;\n    float nrSteps = ANIMATION_NUM_FRAMES;\n\n    scene.e.o.p = vec3(0, ELEVATOR_MAX_Y, 0);\n    scene.e.o.p = onCycle(scene.e.o.p, vec3(0, 0.0, 0), time, nrSteps, transTime, frame);\n    scene.ro = onCycle(scene.ro, vec3(0, oro.y, 6.5), time, nrSteps, transTime, frame);\n    scene.lookp = onCycle(scene.lookp, vec3(-0.5, oro.y, -5.), time, nrSteps, transTime, frame);\n    frame += 1.0;\n    \n    scene.e.o.p = onCycle(scene.e.o.p, vec3(0, 0.0, 0), time, nrSteps, transTime, frame);\n    scene.ro = onCycle(scene.ro, vec3(0, oro.y, 6.0), time, nrSteps, transTime, frame);\n    scene.lookp = onCycle(scene.lookp, vec3(-0.5, scene.e.o.p.y+0.1, -4.), time, nrSteps, transTime, frame);\n    frame += 1.0;\n    \n    scene.e.o.p = onCycle(scene.e.o.p, vec3(0, 0.0, 0), time, nrSteps, transTime, frame);\n    scene.ro = onCycle(scene.ro, vec3(0, oro.y, 2.0), time, nrSteps, transTime, frame);\n    scene.lookp = onCycle(scene.lookp, vec3(-1.5, scene.e.o.p.y+0.1, 0.0), time, nrSteps, transTime, frame);\n    frame += 1.0;\n    \n    scene.e.o.p = onCycle(scene.e.o.p, vec3(0, 0.0, 0), time, nrSteps, transTime, frame);\n    scene.ro = onCycle(scene.ro, scene.e.o.p + vec3(0, 0.5, 0), time, nrSteps, transTime, frame);\n    scene.lookp = onCycle(scene.lookp, vec3(-2.6, scene.e.o.p.y+0.5, 0.9), time, nrSteps, transTime, frame);\n    frame += 1.0;\n    \n    // arrives at top\n    scene.e.o.p = onCycle(scene.e.o.p, vec3(0, ELEVATOR_MAX_Y, 0), time, nrSteps, transTime, frame);\n    scene.ro = onCycle(scene.ro, scene.e.o.p + vec3(0, 0.5, 0), time, nrSteps, transTime, frame);\n    scene.lookp = onCycle(scene.lookp, vec3(-1., scene.ro.y+0.5, 3.), time, nrSteps, transTime, frame);\n    frame += 1.0;\n    \n    scene.e.o.p = onCycle(scene.e.o.p, vec3(0, ELEVATOR_MAX_Y, 0), time, nrSteps, transTime, frame);\n    scene.ro = onCycle(scene.ro, scene.e.o.p + vec3(0, 0.5, 0), time, nrSteps, transTime, frame);\n    scene.lookp = onCycle(scene.lookp, vec3(-0.5, scene.ro.y+0.5, 4), time, nrSteps, transTime, frame);\n    frame += 1.0;\n    \n    scene.e.o.p = onCycle(scene.e.o.p, vec3(0, ELEVATOR_MAX_Y, 0), time, nrSteps, transTime, frame);\n    scene.ro = onCycle(scene.ro, scene.e.o.p + vec3(0, 0.5, 0), time, nrSteps, transTime, frame);\n    scene.lookp = onCycle(scene.lookp, vec3(-0.1, scene.ro.y+0.5, 7.), time, nrSteps, transTime, frame);\n    frame += 1.0;\n    \n    scene.e.o.p = onCycle(scene.e.o.p, vec3(0, ELEVATOR_MAX_Y, 0), time, nrSteps, transTime, frame);\n    scene.ro = onCycle(scene.ro, vec3(oro.x, scene.ro.y-0.5, oro.z), time, nrSteps, transTime, frame);\n    scene.lookp = onCycle(scene.lookp, vec3(-2., scene.ro.y+1.0, 8.), time, nrSteps, transTime, frame);\n    frame += 1.0;\n    \n    \n    scene.e.o.p = onCycle(scene.e.o.p, vec3(0, ELEVATOR_MAX_Y, 0), time, nrSteps, transTime, frame);\n    scene.ro = onCycle(scene.ro, vec3(oro.x, ELEVATOR_MAX_Y, oro.z), time, nrSteps, transTime, frame);\n    scene.lookp = onCycle(scene.lookp, vec3(-3., scene.ro.y+0.8, 1.), time, nrSteps, transTime, frame);\n    frame += 1.0;\n    \n    scene.e.o.p = onCycle(scene.e.o.p, vec3(0, ELEVATOR_MAX_Y, 0), time, nrSteps, transTime, frame);\n    scene.ro = onCycle(scene.ro, vec3(oro.x, ELEVATOR_MAX_Y, oro.z), time, nrSteps, transTime, frame);\n    scene.lookp = onCycle(scene.lookp, vec3(-0.5, scene.ro.y+0.5, 0.0), time, nrSteps, transTime, frame);\n    frame += 1.0;\n    \n    // turn around\n    scene.e.o.p = onCycle(scene.e.o.p, vec3(0, ELEVATOR_MAX_Y, 0), time, nrSteps, transTime, frame);\n    scene.ro = onCycle(scene.ro, mix(vec3(oro.x, ELEVATOR_MAX_Y, oro.z), scene.e.o.p, 0.5), time, nrSteps, transTime, frame);\n    scene.lookp = onCycle(scene.lookp, vec3(1.5, scene.ro.y, 1.0), time, nrSteps, transTime, frame);\n    frame += 1.0;\n    \n    scene.e.o.p = onCycle(scene.e.o.p, vec3(0, ELEVATOR_MAX_Y, 0), time, nrSteps, transTime, frame);\n    scene.ro = onCycle(scene.ro, scene.e.o.p, time, nrSteps, transTime, frame);\n    scene.lookp = onCycle(scene.lookp, vec3(2.5, scene.ro.y, 3.0), time, nrSteps, transTime, frame);\n    frame += 1.0;\n    \n    scene.e.o.p = onCycle(scene.e.o.p, vec3(0, ELEVATOR_MAX_Y, 0), time, nrSteps, transTime, frame);\n    scene.ro = onCycle(scene.ro, scene.e.o.p, time, nrSteps, transTime, frame);\n    scene.lookp = onCycle(scene.lookp, vec3(2.1, scene.ro.y+0.5, 5), time, nrSteps, transTime, frame);\n    frame += 1.0;\n    \n    // go down\n    scene.e.o.p = onCycle(scene.e.o.p, vec3(0, ELEVATOR_MAX_Y/2., 0), time, nrSteps, transTime, frame);\n    scene.ro = onCycle(scene.ro, scene.e.o.p, time, nrSteps, transTime, frame);\n    scene.lookp = onCycle(scene.lookp, vec3(-0.5, scene.ro.y+0.5, 6), time, nrSteps, transTime, frame);\n    frame += 1.0;\n    \n    scene.e.o.p = onCycle(scene.e.o.p, vec3(0, 0.0, 0), time, nrSteps, transTime, frame);\n    scene.ro = onCycle(scene.ro, scene.e.o.p, time, nrSteps, transTime, frame);\n    scene.lookp = onCycle(scene.lookp, vec3(-0.5, scene.ro.y+0.5, 7), time, nrSteps, transTime, frame);\n    frame += 1.0;\n    \n    scene.e.o.p = onCycle(scene.e.o.p, vec3(0, 0.0, 0), time, nrSteps, transTime, frame);\n    scene.ro = onCycle(scene.ro, scene.e.o.p, time, nrSteps, transTime, frame);\n    scene.lookp = onCycle(scene.lookp, vec3(-0.15, scene.ro.y+0.5, 7), time, nrSteps, transTime, frame);\n    frame += 1.0;\n    \n    scene.e.o.p = onCycle(scene.e.o.p, vec3(0, 0.0, 0), time, nrSteps, transTime, frame);\n    scene.ro = onCycle(scene.ro, mix(scene.ro, oro, 0.5), time, nrSteps, transTime, frame);\n    scene.lookp = onCycle(scene.lookp, mix(scene.lookp + vec3(-1.5, 0, 0.5), olookp + vec3(-2.5, 0, 2.0), 0.5), time, nrSteps, transTime, frame);\n    frame += 1.0;\n    \n    scene.e.o.p = onCycle(scene.e.o.p, vec3(0, 0.0, 0), time, nrSteps, transTime, frame);\n    scene.ro = onCycle(scene.ro, oro, time, nrSteps, transTime, frame);\n    scene.lookp = onCycle(scene.lookp, olookp, time, nrSteps, transTime, frame);\n    frame += 1.0;\n    \n    scene.e.o.p = onCycle(scene.e.o.p, vec3(0, ELEVATOR_MAX_Y, 0), time, nrSteps, transTime, frame);\n    scene.ro = onCycle(scene.ro, oro, time, nrSteps, transTime, frame);\n    scene.lookp = onCycle(scene.lookp, olookp, time, nrSteps, transTime, frame);\n    frame += 1.0;\n\n\n    float distanceToTop = max(0.0, ELEVATOR_MAX_Y-scene.e.o.p.y);\n    float distanceToBot = max(0.0, scene.e.o.p.y);\n\n    float zone = 0.1;\n\n    float openTop = 1.0-smoothstep(0.0, 1.0, distanceToTop-zone);\n    float openBot = 1.0-smoothstep(0.0, 1.0, distanceToBot-zone);\n    scene.e.open = max(openTop, openBot);\n    \n    lookp = scene.lookp;     \n\n    scene.e.o.p.y += yMargin;\n    scene.ro.y += 1.1;\n    \n    scene.ro.y = mix(scene.ro.y, scene.e.o.p.y, 1.0-smoothstep(0.0, 1.0+0.7, max(0.0, distance(scene.ro.xz, scene.e.o.p.xz)-0.7)));\n    scene.lookp.y = max(scene.lookp.y, scene.ro.y-0.5);\n    scene.lookp.y += cos(time*6.)*0.2;\n    scene.lookp.x += sin(time*2.)*0.5;\n\n    return scene;\n}\n\nScene getScene() {\n    return getScene(vec3(0.), vec3(0.));\n}\n\nElevator getElevator() {\n    Scene scene = getScene();\n    return scene.e;\n}\n\nfloat elevatorControlSDF(in vec3 p, in vec3 size, in vec3 openingSize, in int skip, inout int id, inout Object o) {\n    float control1 = boxSDF(p, size);\n    vec3 displaySize = vec3(size.x*0.8, size.y*0.45, size.z);\n    float controlDisplay1 = boxSDF(p - (vec3(0, displaySize.y, 0.05)), displaySize);\n    control1 = smax(control1, -controlDisplay1, 0.02)-0.005;\n    o.lum += float(p.z > 0.0002 && p.y > 0.0 && p.y < (displaySize.y*2.) && p.x > 0.0 - displaySize.x && p.x < displaySize.x);\n\n    vec3 buttonSize = vec3(0.02);\n\n    vec3 pp = p;\n    p.x = mod(p.x-0.006, 0.09)-0.039;\n    p.y = mod(p.y, 0.09)-0.26;\n\n    if (!(abs(pp.x)  > displaySize.x-0.029 || pp.y > 0. || pp.y < -0.2)) {\n        float button = boxSDF(p - (vec3(0, 0, 0.) + vec3(0, -(size.y+buttonSize.y), (size.z+(buttonSize.z*0.5)))), buttonSize)/1.2;\n        control1 = min(control1, button);\n    }\n    return control1/1.2;\n}\n\nfloat elevatorSDF(\n    in vec3 p,\n    in vec3 size,\n    in int skip,\n    inout int id,\n    inout Elevator e,\n    inout float opening,\n    inout float inside\n) {\n    Object o = e.o;\n    float open = e.open;\n    \n    float dist = FAR;\n    float base = boxSDF(p - vec3(0, size.y, 0), size);\n    \n    inside = boxSDF(p - vec3(0, (size.y*0.9)+0.09, 0), size*0.9);\n    base = max(base, -inside);\n    \n    vec3 openingSize = vec3(size.x*0.4, size.y*0.9, size.z*0.9);\n    opening = boxSDF(p - vec3(0, openingSize.y+0.09, 0.5), openingSize);\n    base = max(base, -opening);\n    \n    vec3 doorSize = vec3((openingSize.x)/2., size.y*0.9, 0.05);\n    float door = boxSDF(vec3(abs(p.x)-max(open, 0.01), p.y, p.z) - vec3(doorSize.x, doorSize.y+0.09, (size.z-(doorSize.z*6.))), doorSize);\n    \n    float control1 = FAR;\n    float control2 = FAR;\n    \n    Object oControl1 = Object(0.0, vec3(0.0));\n    Object oControl2 = Object(0.0, o.p);\n    float controlWidth = clamp(abs(size.x-openingSize.x)*0.25, 0.02, 0.15);\n    vec3 controlSize = vec3(controlWidth, 0.2, 0.05);\n    vec3 controlPos = vec3(-((openingSize.x*3.)+controlSize.x*2.), controlSize.y+size.y+1.2, (size.z+controlSize.z*0.9)) - o.p;\n    control1 = elevatorControlSDF(p - controlPos, controlSize, openingSize, skip, id, oControl1);\n    \n    {\n        vec3 p = p;\n        \n        vec3 controlPos2 = vec3(-(size.x-controlSize.x*1.5), controlSize.y+size.y, 0.0);\n        p -= controlPos2;\n        p.xz *= rot(radians(90. + 180.));\n        control2 = elevatorControlSDF(p, controlSize, openingSize, skip, id, oControl2);\n    }\n   \n    float light0 = sphereSDF(p - ELEVATOR_LIGHT0_POS, 0.2);\n    float light1 = sphereSDF(p - ELEVATOR_LIGHT1_POS, 0.2);\n    \n    Object oLight0 = Object(1.0, ELEVATOR_LIGHT0_POS);\n    Object oLight1 = Object(1.0, ELEVATOR_LIGHT1_POS);\n    \n    SAMPLE(base, o, ID_ELEVATOR);\n    SAMPLE(door, o, ID_ELEVATOR_DOOR);\n    SAMPLE(control1, oControl1, ID_ELEVATOR_CONTROL);\n    SAMPLE(control2, oControl2, ID_ELEVATOR_CONTROL);\n    SAMPLE(light0, oLight0, ID_ELEVATOR_LIGHT0);\n    SAMPLE(light1, oLight1, ID_ELEVATOR_LIGHT1);\n    \n    e.o = o;\n    return dist;\n}\n\n\nfloat roomSDF(\n    in vec3 p,\n    in vec3 size,\n    in float elevatorOpening,\n    in float elevatorInside,\n    in int skip,\n    inout int id,\n    inout Object o\n) {\n    id = ID_ROOM;\n    float dist = FAR;\n    float base = boxSDF(p - vec3(0, size.y, 0), size);\n    float inside = boxSDF(p - vec3(0, size.y-2., 0), vec3(size.x*0.9, size.y+0.8, size.z*0.9));\n    base = max(base, -inside);\n    vec3 elevatorWallSize = vec3(size.x, size.y, (size.z/2.)-ELEVATOR_WIDTH*2.);\n    vec3 wallPos = vec3(0, size.y, (-((ELEVATOR_WIDTH*2.)+elevatorWallSize.z*2.9)));\n    float elevatorWall = boxSDF(p - wallPos, elevatorWallSize);\n    elevatorWall = max(elevatorWall, -elevatorOpening);\n    \n    vec3 buckSize = vec3(ELEVATOR_WIDTH, size.y, 0.1);    \n    vec3 floorSize = vec3(size.x*0.9, 0.15, size.z*0.9);\n    float floorY = ELEVATOR_MAX_Y;\n    float floor1 = boxSDF(p - vec3(0, (floorSize.y*6.)+floorY, 0), floorSize);\n    \n    float buck = boxSDF(p - (vec3(wallPos.x, buckSize.y+1., wallPos.z+0.15)), buckSize)-0.1;\n    elevatorWall = smax(elevatorWall, -buck, 0.2);\n    floor1 = max(floor1, -elevatorInside);\n    \n    float floor0 = boxSDF(p - vec3(0, floorSize.y*6., 0), floorSize);\n    floor0 = max(floor0, -elevatorInside);\n    float roomFloor = min(floor0, floor1);   \n    int roomId = ID_ROOM;\n    \n    SAMPLE(base, o, roomId);\n    SAMPLE(elevatorWall, o, ID_ROOM_ELEVATOR_WALL);\n    SAMPLE(roomFloor, o, ID_ROOM_FLOOR);\n    \n    return dist;\n}\n\nfloat getGroundHeight(in vec3 p) { return 0.0; }\n\n\n\nMARCHER(\n    // ray origin\n    vec3(1.3, 1.9, -3.),\n    // configure ray\n    {\n        ro = vec3(0, 1.1, 7);\n        vec3 lookp = vec3(0, 0, -5);\n        Scene scene = getScene(ro, lookp);\n        ro = scene.ro;\n        lookp = scene.lookp;\n        rd = look(uv, lookp, ro);\n        ro.y += 2.1;\n        return Ray(ro, rd);\n    },\n    // Scene\n    {\n        vec3 elevatorSize = ELEVATOR_SIZE;\n        float ground = groundSDF(p);\n        SAMPLE(ground, o, ID_GROUND);\n        \n        int roomId = 0;\n        Object oRoom = NEW_OBJECT;\n        \n        \n        float elevatorOpening = FAR;\n        float elevatorInside = FAR;\n        int elevatorId = 0;\n        Elevator oElevator = getElevator();\n        float elevator = elevatorSDF(p - oElevator.o.p, ELEVATOR_SIZE,\n        skip, elevatorId, oElevator, elevatorOpening, elevatorInside);\n        SAMPLE(elevator, oElevator.o, elevatorId);\n        \n        float room = roomSDF(p - vec3(0, 0, ROOM_WIDTH-ELEVATOR_WIDTH), ROOM_SIZE,\n            elevatorOpening, elevatorInside, skip, roomId, oRoom);\n        SAMPLE(room, oRoom, roomId); \n        \n    },\n    // Textures    \n    {\n        case ID_ROOM: {\n            vec3 p = data.p;\n            vec3 col = vec3(0.0);\n            if (p.y > (ROOM_HEIGHT*2.)-1.3) {\n                col = plankTexture(uv, p, data.m);\n                data.n = makeNormal(data.n, data.m.z, 0.3, 0.5);\n            } else {\n                col = wallPaperTexture(uv, data.p, data.m);\n            }\n            return col;\n        }; break;\n        case ID_ROOM_ELEVATOR_WALL: {\n            vec3 col = wallPaperTexture(uv, data.p, data.m);\n            return col;\n        }; break;\n        case ID_ROOM_FLOOR: {\n            vec3 col = brownMarbleTexture(uv, data.p, data.m);\n            data.n = makeNormal(data.n, data.m.z, 0.3, 0.5);\n            return col;\n        }; break;\n        case ID_ELEVATOR_DOOR: {\n            vec3 col = dirtyMetalTexture(uv, data.p, data.m);\n            return col;\n        }; break;\n        case ID_ELEVATOR_CONTROL: {\n            vec3 col = dirtyMetalTexture(uv, data.p, data.m);\n            return col;\n        }; break;\n        case ID_ELEVATOR: {\n            vec3 col = marbleTexture(uv, data.p, data.m);\n            return col;\n        }; break;\n        case ID_ELEVATOR_LIGHT0: {\n            data.m.lum = 1.0;\n            return lights[0].c;\n        }; break;\n        case ID_ELEVATOR_LIGHT1: {\n            data.m.lum = 1.0;\n            return lights[1].c;\n        }; break;\n    },\n    // Setup lights\n    Light[4](\n        Light(ELEVATOR_LIGHT0_POS, vec3(0.0), vec3(1.0), 3., LIGHT_POINT),\n        Light(ELEVATOR_LIGHT1_POS, vec3(0.0), vec3(1.0), 3., LIGHT_POINT),\n        Light(vec3(0, (ROOM_HEIGHT*2.)-0.99, (ROOM_WIDTH/2.) + ELEVATOR_WIDTH*2.), vec3(0.0), COLOR_SUN, 6., LIGHT_POINT),\n        Light(vec3(0, (ELEVATOR_MAX_Y-0.5)-0.99, (ROOM_WIDTH/2.) + ELEVATOR_WIDTH*2.), vec3(0.0), COLOR_SUN, 6., LIGHT_POINT)\n    ),\n    // How many lights\n    4,\n    // light transform\n    {\n        Elevator e = getElevator();\n        lights[0].p += e.o.p;\n        lights[1].p += e.o.p; \n        lights[0].c = mix(vec3(1, 0, 0), vec3(0, 1, 0), e.open);\n        lights[1].c = mix(vec3(1, 0, 0), vec3(0, 1, 0), e.open);\n    }\n)\n\nvoid mainImage( out vec4 O, in vec2 fc ) {\n    #ifdef DEBUG_TEXTURE\n    Material ma = NEW_MATERIAL;\n    O = vec4(DEBUG_TEXTURE(fc.xy/R.xy, vec3(0.0), ma), 1.0);\n    #else\n    O = blit(fc);\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#pragma optimize(off)\n#pragma optionNV(fastmath off)\n#pragma optionNV(fastprecision off)\n#pragma optionNV(unroll none)\n\n#define R (iResolution.xy)\n#define T (iFrame <= 2 || iTime <= 0.00005 ? 2.709 : iTime)\n#define M_PI (3.14159265359)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, iFrame))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n#define SHADOW_NO_SKIP -16\n#define SAMPLE(var, OBJ, id_)\\\n    {\\\n        if (!((skip >= 0 || skip == SHADOW_NO_SKIP) && OBJ.lum > 0.001) && id_ != skip && var < dist) {\\\n              o = OBJ;\\\n              id = id_;\\\n              dist = var;\\\n        }\\\n    }\n\n#define NEAR 0.003\n#define FAR 100.0\n#define STEPS 100\n#define SHADOW_STEPS 33\n#define FAR_LOD 1.0\n#define NORMAL_RANGE 0.001\n#define AMBIENT 0.05\n#define NUM_BOUNCES 2\n\n#define COLOR_SKY vec3(0.29, 0.61, 0.9)\n#define COLOR_SUN vec3(0.97, 0.81, 0.79)\n\n#define SPECULAR_AMPLITUDE 64.0\n#define SHADOW_NDOTL_EPSILON 0.000003\n\n#define ID_NONE -1\n\nvec3 look(vec2 uv, vec3 point, vec3 ro) {\n    vec3 camForward = normalize(point - ro);\n    vec3 camRight = -normalize(cross(camForward, vec3(0, 1, 0)));\n    vec3 camUp = -normalize(cross(camRight, camForward));\n    vec3 screenCenter = ro + camForward * 1.;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\n\nmat2 rot(in float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\nstruct Material { float rough; float spec; float metallic; float lum; float z; float ior; };\n#define NEW_MATERIAL Material(1.0, 1.0, 0.0, 0.0, 0.0, 0.0)\n\nstruct Object {\n    float lum;\n    vec3 p;\n};\n#define NEW_OBJECT Object(0.0, vec3(0.0))\n\nstruct Data {\n    vec3 p;\n    vec3 n;\n    float d;\n    int skip;\n    int id;\n    float sig;\n    int count;\\\n    Object o;\n    Material m;\n};\n\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), FAR, ID_NONE, ID_NONE, 1.0, 0, NEW_OBJECT, NEW_MATERIAL)\n\n\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\n#define NOISE(p, seed, lod) (textureLod(iChannel3, (p + (seed*1.9287827185))/256.0, lod).rgb)\nvec3 snoise(in vec2 p, in float seed, in float lod, in float freq, const in int octaves);\nvec3 snoiseWarp(in vec2 p, in float seed, in float lod, in float freq, const in int octaves, in float warp);\nuint hash21u(in vec2 ip, in float seed) {\n    uvec2 p = uvec2(floatBitsToUint(ip.x), floatBitsToUint(ip.y)); uint s = floatBitsToUint(seed);\n    s ^= ~s >> 3U; p ^= (p << 17U); s ^= (~p.x); s ^= (~p.y);\n    p ^= (p >> 11U); p ^= (p << 5U); p ^= (s << 3U);\n    return ((p.x + p.y) ^ (p.x * s + p.y))*293U;\n}\n\nfloat hash21(in vec2 ip, in float seed) {return float(hash21u(ip, seed))/float(0xFFFFFFFFU);}\nvec3 hash23(in vec2 ip, in float seed) {\n    uint n = hash21u(ip, seed); n ^= (n >> 13U);\n    return vec3(float((n >> 16U) & 0xFFU), float((n >> 8U) & 0xFFU), float(n & 0xFFU)) / float(0xFFU);\n}\n\nvec3 mix4(vec3 c1, vec3 c2, vec3 c3, vec3 c4, vec3 m) {\n    return mix(mix(mix(c1, c2, m.x), c3, m.y), c4, m.z);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\nfloat smax(float a, float b, float k) {\n    return smin(a, b, -k);\n}\n\nvec3 makeNormal(in vec3 wn, in float z, in float mx, in float s) {\n    if (abs(z) <= 0.000000001) return wn;\n    vec2 dx = vec2(dFdx(z), 0.0);\n    vec2 dy = vec2(0.0, dFdy(z));\n    float bumpScale = s;\n    vec3 cp = cross(vec3(dx, bumpScale), vec3(dy, bumpScale));\n    if (length(cp) <= 0.0003) return wn;\n    cp = normalize(cp);   \n    vec3 next = normalize(mix(wn, normalize(wn+cp), mx));\n    if (length(next) <= 0.0003) return wn;\n    return next;\n}\n\nfloat sphereSDF(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat boxSDF(in vec3 p, in vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\nfloat cylSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    vec3 c = a + t * ab;\n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n    return e + i;\n}\nfloat line2D(in vec2 p, in vec2 a, in vec2 b, float t) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return clamp(1.0-length(pa - ba * h)/t, 0.0, 1.0);\n}\nvec3 onCycle(vec3 from, vec3 to, float time, float nrSteps, float transTime, float frame) {\n    float cycle = mod(time, nrSteps + transTime);\n    return mix(from, to, smoothstep(frame - transTime, frame + transTime, cycle));\n}\n\n#define MARCHER(RAY_ORIGIN, GET_RAY_HOOK, SDF_FUN, TEX_LOOKUP, LIGHTS, NUM_LIGHTS, LIGHT_TRANSFORM)\\\n    vec3 snoise(in vec2 p, in float seed, in float lod) {\\\n        p += 0.99288124;\\\n        vec2 id = floor(p);\\\n        vec2 lv = fract(p); lv = lv*lv*(3.0-2.0*lv);\\\n        return mix(\\\n            mix(NOISE(id, seed, lod), NOISE(id + vec2(1, 0), seed, lod), lv.x),\\\n            mix(NOISE(id + vec2(0, 1), seed, lod), NOISE(id + vec2(1, 1), seed, lod), lv.x),\\\n            lv.y\\\n        );\\\n    }\\\n    vec3 snoise(in vec2 p, in float seed, in float lod, in float freq, const in int octaves) {\\\n        p += 0.99288124;\\\n        float div = 0.0;\\\n        float amp = 1.0;\\\n        vec3 n = vec3(0.0);\\\n        for (int i = ZERO; i < octaves; i++) {\\\n            n += amp * snoise(p*freq, seed, lod); div += amp; amp /= 2.0; lod /= 2.0; freq *= 2.0;\\\n        }\\\n        return n / div;\\\n    }\\\n    vec3 snoiseWarp(in vec2 p, in float seed, in float lod, in float freq, const in int octaves, in float warp) {\\\n        p += 0.99288124;\\\n        float div = 0.0;\\\n        float amp = 1.0;\\\n        vec3 n = vec3(0.0);\\\n        for (int i = ZERO; i < octaves; i++) {\\\n            n += amp * snoise(p*freq, seed, lod); div += amp; amp /= 2.0; lod /= 2.0; freq *= 2.0;\\\n            p += (n.xy*n.z)*warp;\\\n        }\\\n        return n / div;\\\n    }\\\n    float luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\\\n    vec3 aces(vec3 x) { return x*(2.51*x + .03) / (x*(2.43*x + .59) + .14); }\\\n    vec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\\\n        return F0 + (max(vec3(1.0 - roughness), F0) - F0) *\\\n                  pow(max(1.0 - cosTheta, 0.0), 5.0);\\\n    }\\\n    struct Ray {\\\n        vec3 ro;\\\n        vec3 rd;\\\n    };\\\n    \\\n    \\\n    struct Light { vec3 p; vec3 d; vec3 c; float s; int type; };\\\n    \\\n    vec3 getLightDir(in Light light, in vec3 p) {\\\n        return light.type == LIGHT_AMBIENT ? normalize(light.p) :\\\n               light.type == LIGHT_POINT ? normalize(light.p - p) :\\\n               normalize(-light.d);\\\n    }\\\n    \\\n    vec3 getLightAtt(in Light light, in vec3 p, in vec3 n) {\\\n        vec3 L = getLightDir(light, p);\\\n        float NdotL = max(AMBIENT, dot(n, L));\\\n        \\\n        switch (light.type) {\\\n            case LIGHT_AMBIENT: return light.c * light.s * NdotL; break;\\\n            case LIGHT_POINT: return light.c * NdotL * (\\\n                pow(light.s, 2.0) / max(0.0001, pow(distance(light.p, p), 2.0))\\\n            ); break;\\\n            case LIGHT_DIR: return light.c * light.s * NdotL * smoothstep(0.8, 1.0, dot(\\\n                normalize(light.p - p),\\\n                L\\\n            )); break;\\\n        }\\\n        \\\n        return vec3(0.0);\\\n    }\\\n    vec2 boxUv(in vec3 p, in vec3 n) {\\\n        return mix(mix(p.xy, p.zy, round(adot(n, vec3(1, 0, 0)))), p.xz, round(adot(n, vec3(0, 1, 0))));\\\n    }\\\n    float getGroundHeight(in vec3 p);\\\n    float groundSDF(in vec3 p) {\\\n        return p.y - getGroundHeight(p);\\\n    }\\\n    float sdf(inout Data data, in vec3 p) {\\\n        int skip = data.skip;\\\n        Object o = NEW_OBJECT;\\\n        int id = ID_NONE;\\\n        float dist = FAR;\\\n        int count = data.count;\\\n        SDF_FUN\\\n        data.id = id;\\\n        data.o = o;\\\n        return dist;\\\n    }\\\n    \\\n    bool march(inout Data data, in vec3 ro, in vec3 rd) {\\\n        float d = 0.0;\\\n        float sig = data.sig;\\\n        for (int i = ZERO; i < STEPS; i++) {\\\n            vec3 p = ro+rd*d;\\\n            float next = sig * sdf(data, p);\\\n            d += next;\\\n            if (abs(next) <= (NEAR * (1.0 + (d / FAR_LOD)))) break;\\\n            if (abs(d) >= FAR) return false;\\\n        }\\\n        \\\n        vec3 p = ro+rd*d;\\\n        vec2 e = vec2(NORMAL_RANGE, 0.0);\\\n        vec3 n = normalize(sdf(data, p) - vec3(\\\n            sdf(data, p - e.xyy),\\\n            sdf(data, p - e.yxy),\\\n            sdf(data, p - e.yyx)\\\n        ));\\\n        \\\n        data.d = d;\\\n        data.p = p;\\\n        data.n = n;\\\n        \\\n        return true;\\\n    }\\\n    float getShadow(in vec3 ro, in vec3 rd, in vec3 n, in float near, in float far, in int skip) {\\\n        float NdotL = cdot(n, rd);\\\n        if (NdotL <= SHADOW_NDOTL_EPSILON) return 1.0;\\\n        Data data = NEW_DATA;\\\n        data.skip = SHADOW_NO_SKIP;\\\n        \\\n        float d = 0.001;\\\n        float r = 1.0;\\\n        float count = 0.0;\\\n        ro += rd*NEAR*10.;\\\n        for (int i = ZERO; i < SHADOW_STEPS && d < far; i++) {\\\n            vec3 p = ro+rd*d;\\\n            float next = sdf(data, p);\\\n            r = min(r, next/max(0.0001, 0.44*d));\\\n            d += clamp(next, 0.009, 0.5003145);\\\n            count += 1.0;\\\n            if (abs(next) <= (NEAR * (1.0 + (d / FAR_LOD)))) break;\\\n        }\\\n        \\\n        float dd = d / (1.0 + d);\\\n        float ss = r + 0.77*(dd*dd);\\\n        return clamp(ss*ss*(d/far)*0.9, AMBIENT, 1.0);\\\n    }\\\n    \\\n    Ray getRay(in vec2 uv, in vec4 m) {\\\n        vec3 org = RAY_ORIGIN;\\\n        vec3 ro = vec3(0, 0, org.z);\\\n        vec3 rd = normalize(vec3(uv.xy, 1.0));\\\n        vec3 toggleWalk = texelFetch(iChannel0, ivec2(2, 0), 0).xyz;\\\n        if (toggleWalk.x > 0.001) {\\\n            vec3 walk = texelFetch(iChannel0, ivec2(0, 0), 0).xyz;\\\n            vec3 fly = texelFetch(iChannel0, ivec2(1, 0), 0).xyz;\\\n            ro += walk;\\\n            ro.y += fly.y;\\\n            rd.yz *= rot(m.y*TAU);\\\n            rd.xz *= rot(m.x*TAU);\\\n            return Ray(ro, rd);\\\n        }\\\n        if (m.z > 0.001 && length(m.xy) > 0.0001 && iFrame > 1 && iTime > 0.0001) {\\\n            ro.yz *= rot(m.y*TAU);\\\n            ro.xz *= rot(m.x*TAU);\\\n            \\\n            rd.yz *= rot(m.y*TAU);\\\n            rd.xz *= rot(m.x*TAU);\\\n        }\\\n        GET_RAY_HOOK\\\n        ro.xy += org.xy;\\\n        ro.y = max(org.y, ro.y);\\\n        return Ray(ro, rd);\\\n    }\\\n    vec3 getAlbedo(inout Data data, in Light[NUM_LIGHTS] lights) {\\\n        vec2 uv = boxUv(data.p - data.o.p, data.n);\\\n        switch (data.id) \\\n            TEX_LOOKUP\\\n        \\\n        \\\n        return vec3(0.77);\\\n    }\\\n    \\\n    vec3 getSky(in vec3 rd) {\\\n        float dotup = cdot(rd, vec3(0, 1, 0));\\\n        vec3 col = pow(COLOR_SKY, vec3(1.0 + dotup));\\\n        return col;\\\n    }\\\n    \\\n    vec3 forEachLight(in Light light, in Data data, in vec3 ro, in vec3 rd, in vec3 diffuse, in vec3 on) {\\\n        vec3 p = data.p;\\\n        vec3 n = data.n;\\\n        vec3 L = getLightDir(light, p);\\\n        vec3 ref = reflect(L, n);\\\n        float VdotR = cdot(rd, ref);\\\n        float spec = data.m.spec * pow(VdotR, SPECULAR_AMPLITUDE);\\\n        vec3 att = getLightAtt(light, p, n);\\\n        att = max(att, diffuse*data.o.lum);\\\n        float shadow = data.o.lum > 0.001 ? 1.0 : getShadow(p + (on*NEAR*3.0), L, on, data.d, light.type == LIGHT_AMBIENT ? FAR :\\\n            distance(light.p, p), data.id);\\\n            \\\n        return (diffuse + spec) * att * shadow; \\\n    }\\\n    vec3 render(inout Data data, in vec3 ro, in vec3 rd, inout float depth) {\\\n        vec3 col = vec3(0.0);\\\n        depth = 1.0;\\\n        vec3 oro = ro;\\\n        vec3 ord = rd;\\\n        Data od = data;\\\n        float minDist = FAR;\\\n        Light lights[NUM_LIGHTS] = LIGHTS;\\\n        LIGHT_TRANSFORM\\\n        float dotup = cdot(rd, vec3(0, 1, 0));\\\n        int hits = 0;\\\n        vec3 mixf = vec3(1.0);\\\n        int k = 0;\\\n        ord = rd;\\\n        oro = ro;\\\n        bool hit = false;\\\n        data.count = k;\\\n        for (int j = ZERO; j < NUM_BOUNCES; j++) {\\\n            if (march(data, ro, rd)) {\\\n                hits += 1;\\\n                if (k > 0 && data.d > minDist) break;\\\n                if (k > 0 && j <= 0) { col = mix(col, col*col, clamp(0.5*(abs(minDist - data.d)/FAR), 0.0, 1.0)); mixf *= 1.33; };\\\n                hit = true;\\\n                vec3 n = data.n;\\\n                vec3 albedo = getAlbedo(data, lights);\\\n                vec3 diffuse = albedo / M_PI;\\\n                for (int i = ZERO; i < NUM_LIGHTS; i++) {\\\n                    Light light = lights[i];\\\n                    col += forEachLight(light, data, ro, rd, diffuse, n) * mixf;\\\n                }\\\n                if (j <= 0) { od = data; minDist = min(minDist, data.d); }\\\n                float rough = data.m.rough;\\\n                if (rough >= 0.992) break;\\\n                float metallic = data.m.metallic;\\\n                ro = (data.p + (data.n*NEAR*2.));\\\n                rd = reflect(rd, data.n);\\\n                float NdotV = dot(data.n, rd);\\\n                vec3 f0 = mix(vec3(0.04), diffuse, metallic);\\\n                vec3 F = fresnelSchlickRoughness(NdotV, f0, rough*rough);\\\n                mixf = F+(metallic*0.5);\\\n            } else if (k <= 0 || j > 1) {\\\n                col += getSky(rd) * mixf;\\\n                col += smoothstep(0.001, 1.0, data.d/FAR) * max(0.0, 1.0-smoothstep(0.0, 0.25, cdot(rd, vec3(0, 1, 0))));\\\n                break;\\\n            }\\\n        }\\\n        ro = oro;\\\n        rd = ord;\\\n        data = od;\\\n        \\\n        if (hits > 0) {\\\n            col += smoothstep(0.001, 1.0, minDist/FAR) * max(0.0, 1.0-smoothstep(0.0, 0.25, dotup));\\\n        }\\\n        return col;\\\n    }\\\n    \\\n    vec4 blit(in vec2 fc) {\\\n        vec3 col = vec3(0.0);\\\n        vec2 uv = (fc-0.5*R.xy)/R.y;\\\n        vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y, iMouse.zw);\\\n        Ray ray = getRay(uv, m);\\\n        vec3 ro = ray.ro;\\\n        vec3 rd = ray.rd;\\\n        Data data = NEW_DATA;\\\n        float depth = 1.0;\\\n        col += render(data, ro, rd, depth);\\\n        col = aces(col);\\\n        col = pow(col, vec3(1.0 / 2.2));\\\n        return vec4(col, depth);\\\n    }\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"#pragma optimize(off)\n#pragma optionNV(fastmath off)\n#pragma optionNV(fastprecision off)\n#pragma optionNV(unroll none)\n\n// taken from https://www.shadertoy.com/view/ldGGzV\n\n#define MOVE_SPEED 10.\n#define PI 3.14159\n\nconst float KEY_W = 87.5 / 256.0;\nconst float KEY_A = 65.5 / 256.0;\nconst float KEY_S = 83.5 / 256.0;\nconst float KEY_D = 68.5 / 256.0;\nconst float KEY_SHIFT = 16.0;\nconst float KEY_SPACE = 32.0;\nconst float KEY_V = 86.0;\n\n\nbool isEnabled() {\n    return texelFetch(iChannel1, ivec2(2, 0), 0).x > 0.001;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos = texture(iChannel1, vec2(0.)).xyz;\n    if(iFrame <= 1) pos = vec3(0., 2.0, 10.);\n    \n    switch (int(fragCoord.x)) {\n        case 0: {\n            if (isEnabled()) {\n                float mx = iMouse.xy == vec2(0.) ? 0. : ((iMouse.x / iResolution.x) * 2. - 1.) * 360.;\n                float speed = MOVE_SPEED * iTimeDelta;\n\n                float forwardBackward =\n                texture(iChannel0, vec2(KEY_W, 0.)).r -\n                texture(iChannel0, vec2(KEY_S, 0.)).r;\n\n                float leftRight =\n                texture(iChannel0, vec2(KEY_A, 0.)).r -\n                texture(iChannel0, vec2(KEY_D, 0.)).r;\n\n                float s = sin(radians(mx));\n                float c = cos(radians(mx));\n\n                pos.x += speed * (forwardBackward * s - leftRight * c);\n                pos.z += speed * (forwardBackward * c + leftRight * s);\n            }\n        }; break;\n        case 1: {\n            if (isEnabled()) {\n                pos = texelFetch(iChannel1, ivec2(1, 0), 0).xyz;\n                float space = texelFetch(iChannel0, ivec2(KEY_SPACE, 0), 0).r;\n                float shift = texelFetch(iChannel0, ivec2(KEY_SHIFT, 0), 0).r;\n\n                pos.y += space * 0.2;\n                pos.y -= shift * 0.2;\n            }\n        }; break;\n        \n        case 2: {\n            pos = texelFetch(iChannel1, ivec2(2, 0), 0).xyz;\n            float v = texelFetch(iChannel0, ivec2(KEY_V, 0), 0).r;\n            \n            float timeDiff = iTime - pos.y;\n            \n             if (timeDiff > 0.07) {\n                bool prev = pos.x > 0.0001;\n                bool toggle = v > 0.0001;\n\n                bool next = prev;\n\n\n                if (toggle) {\n                    next = !prev;\n                }\n                pos.y = iTime;\n                pos.x = next ? 1.0 : 0.0;\n            }\n        \n        }; break;\n    }\n    \n    \n    fragColor = vec4(pos, 0.);\n}","name":"Buffer D","description":"","type":"buffer"}]}